From mean at mail.berlios.de  Fri Jan  1 19:41:00 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 1 Jan 2010 19:41:00 +0100
Subject: [Avidemux-svn-commit] r5804 - in
	branches/avidemux_2.5_branch_gruntster/avidemux:
	ADM_coreImage/include ADM_filter ADM_video
Message-ID: <201001011841.o01If0GR029672@sheep.berlios.de>

Author: mean
Date: 2010-01-01 19:40:56 +0100 (Fri, 01 Jan 2010)
New Revision: 5804

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreImage/include/ADM_videoFilter_internal.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_filter/filter.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidPartial.cpp
Log:
[Filter] Fix partial filer, closes #66

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreImage/include/ADM_videoFilter_internal.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreImage/include/ADM_videoFilter_internal.h	2009-12-31 19:01:06 UTC (rev 5803)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreImage/include/ADM_videoFilter_internal.h	2010-01-01 18:40:56 UTC (rev 5804)
@@ -33,7 +33,7 @@
 }VF_CATEGORY;
 #define VF_INVALID 		  0
 
-#define VF_PARTIAL_FILTER  filterGetTagFromName( "partial" )
+#define VF_PARTIAL_FILTER 9 // filterGetTagFromName( "partial" )
 #define VF_START_TAG 	  10
 
 typedef uint32_t VF_FILTERS ;
@@ -98,6 +98,7 @@
 FILTER      *getCurrentVideoFilterList (uint32_t * count);
 const FilterDescriptor * filterGetEntryFromTag (VF_FILTERS tag);
 const char *filterGetNameFromTag(VF_FILTERS tag);
+const char  *filterGetInternalNameFromTag(VF_FILTERS tag);
 VF_FILTERS 	filterGetTagFromName(const char *inname);
 uint8_t 	filterAddScript(VF_FILTERS tags,uint32_t n,Arg *args);
 

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_filter/filter.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_filter/filter.cpp	2009-12-31 19:01:06 UTC (rev 5803)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_filter/filter.cpp	2010-01-01 18:40:56 UTC (rev 5804)
@@ -124,6 +124,8 @@
 	const char *name;
 	int max = allfilters.size();
 	VF_FILTERS filter = VF_INVALID;
+    if(inname)
+        if(!strcasecmp(inname,"partial")) return VF_PARTIAL_FILTER;
 
 	for (uint32_t i = 0; i < max; i++)
 	{
@@ -417,6 +419,13 @@
     ADM_assert(entry);
     return entry->name;
 }
+
+const char  *filterGetInternalNameFromTag(VF_FILTERS tag)
+{
+    const FilterDescriptor * entry = filterGetEntryFromTag (tag);
+    ADM_assert(entry);
+    return entry->filterName;
+}
 /*____________________________________
 	Save and load current set of filters
 

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidPartial.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidPartial.cpp	2009-12-31 19:01:06 UTC (rev 5803)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidPartial.cpp	2010-01-01 18:40:56 UTC (rev 5804)
@@ -26,11 +26,12 @@
 #include "ADM_videoFilter.h"
 #include "ADM_videoFilter_internal.h"
 #include "ADM_video/ADM_vidPartial.h"
+#include "DIA_coreToolkit.h"
 
 extern AVDMGenericVideoStream *filterCreateFromTag(VF_FILTERS tag,CONFcouple *couple, AVDMGenericVideoStream *in);
 
 
-static FILTER_PARAM partialParam={VARIABLE_PARAMS+3,{"_start","_end","_tag"}};
+static FILTER_PARAM partialParam={VARIABLE_PARAMS+3,{"_start","_end","_name"}};
 
 
 SCRIPT_CREATE(partial_script,ADMVideoPartial,partialParam);
@@ -50,6 +51,7 @@
 ADMVideoPartial::ADMVideoPartial(   AVDMGenericVideoStream *in,
 							CONFcouple		*couples)
 {
+        char *name;
 		_param=NEW( PARTIAL_CONFIG);
 		_param->_start=0;
 		_param->_end=0;
@@ -57,7 +59,14 @@
 
 			GET(_start);
 			GET(_end);
-			GET(_tag);
+            ADM_assert(couples->getCouple("_name",&name));
+            _param->_tag=filterGetTagFromName(name);
+            if(_param->_tag==VF_INVALID)
+            {
+                GUI_Error_HIG("Error","Cannot find the filter with name %s",name);
+                ADM_assert(0);
+            }
+//			GET(_tag);
 			// we share the same parameters
 			_son= filterCreateFromTag((VF_FILTERS)_param->_tag,couples,_in);
 		 	memcpy(&_info,_in->getInfo(),sizeof(_info));
@@ -91,7 +100,8 @@
 				*couples=new CONFcouple(3);
 				CSET(_start);
 				CSET(_end);
-				CSET(_tag);
+                (*couples)->setCouple("_name",filterGetInternalNameFromTag(_param->_tag));
+				//CSET(_tag);
 				return 1;
 			}
 
@@ -101,7 +111,8 @@
 			*couples=new CONFcouple(3+nbParam);
 			CSET(_start);
 			CSET(_end);
-			CSET(_tag);
+			//CSET(_tag);
+            (*couples)->setCouple("_name",filterGetNameFromTag(_param->_tag));
 
 	// then set the child ones
 	char *nm,*vl;



From gruntster at mail.berlios.de  Sat Jan  2 13:46:01 2010
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Sat, 2 Jan 2010 13:46:01 +0100
Subject: [Avidemux-svn-commit] r5805 - in
	branches/avidemux_2.5_branch_gruntster/avidemux: . ADM_editor
	ADM_outputs/oplug_avi ADM_outputs/oplug_mpegFF ADM_script
	ADM_userInterfaces/ADM_GTK/ADM_gui2 ADM_userInterfaces/ADM_GTK/glade
	ADM_userInterfaces/ADM_QT4/ADM_gui ADM_userInterfaces/ADM_commonUI
Message-ID: <201001021246.o02Ck1dm030391@sheep.berlios.de>

Author: gruntster
Date: 2010-01-02 13:45:44 +0100 (Sat, 02 Jan 2010)
New Revision: 5805

Added:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_mpegFF/ps_muxer.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_muxerMpegPs.cpp
Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_editor/ADM_edLoadSave.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_editor/ADM_outputfmt.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_avi/op_avisave.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_avi/op_avisave.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_mpegFF/oplug_vcdff.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemux.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2/GUI_bindings.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2/GUI_main2.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2/GUI_menumap.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/glade/gtk2_build.glade
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/Q_gui2.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/gui2.ui
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/translation_table.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/gtk_gui.cpp
Log:
[mpeg-ps] make mpeg-ps muxer configurable

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_editor/ADM_edLoadSave.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_editor/ADM_edLoadSave.cpp	2010-01-01 18:40:56 UTC (rev 5804)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_editor/ADM_edLoadSave.cpp	2010-01-02 12:45:44 UTC (rev 5805)
@@ -41,6 +41,8 @@
 #include "ADM_encoder/adm_encConfig.h"
 #include "prefs.h"
 #include "avi_vars.h"
+#include "ADM_editor/ADM_outputfmt.h"
+#include "ADM_userInterfaces/ADM_commonUI/GUI_ui.h"
 
 // Ugly but sooo usefull
 extern uint32_t frameStart,frameEnd;
@@ -268,7 +270,29 @@
 
   // container
         
-  qfprintf(fd,"app.setContainer(\"%s\");\n",getCurrentContainerAsString());
+  qfprintf(fd, "app.setContainer(\"%s\"", getCurrentContainerAsString());
+  ADM_OUT_FORMAT format = UI_GetCurrentFormat();
+
+  for (int i = 0; i < ADM_FORMAT_MAX; i++)
+  {
+	  if (ADM_allOutputFormat[i].format == format)
+	  {
+		  if (ADM_allOutputFormat[i].configSize > 0)
+		  {
+			  const uint8_t* config = (uint8_t*)ADM_allOutputFormat[i].currentConfig;
+			  qfprintf(fd, ", \"");
+
+			  for (int j = 0; j < ADM_allOutputFormat[i].configSize; j++)
+				  qfprintf(fd, "%02x ", config[j]);
+		  }
+
+		  qfprintf(fd,"\"");
+		  break;
+	  }
+  }
+
+  qfprintf(fd,");\n");
+
   if(outputname)
   {
         char *o=ADM_cleanupPath(outputname);

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_editor/ADM_outputfmt.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_editor/ADM_outputfmt.h	2010-01-01 18:40:56 UTC (rev 5804)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_editor/ADM_outputfmt.h	2010-01-02 12:45:44 UTC (rev 5805)
@@ -11,7 +11,14 @@
 //
 #ifndef ADM_OUT_FMT
 #define ADM_OUT_FMT
+
 #include "config.h"
+#include "ADM_outputs/oplug_mpegFF/ps_muxer.h"
+
+extern ps_muxer psMuxerConfig;
+extern bool muxerMpegPsConfigure(void);
+extern bool ADM_aviUISetMuxer(void);
+
 typedef enum 
 {
 	ADM_AVI=0,
@@ -28,31 +35,35 @@
         ADM_MATROSKA,
 	ADM_DUMMY,
 	ADM_FORMAT_MAX,
-}ADM_OUT_FORMAT;
+} ADM_OUT_FORMAT;
 
 typedef struct 
 {
   ADM_OUT_FORMAT format;
   const char *text;
-}ADM_FORMAT_DESC;
+  bool (*muxerConfigure)(void);
+  int configSize;
+  const void *defaultConfig;
+  void *currentConfig;
+} ADM_FORMAT_DESC;
 /**
  * 	This is used to fill-in the menus in GUIs
  */
 const ADM_FORMAT_DESC ADM_allOutputFormat[]=
 {
-  {ADM_AVI,QT_TR_NOOP("AVI")},
-  {ADM_AVI_DUAL,QT_TR_NOOP("AVI, dual audio")},
-  {ADM_AVI_PAK,QT_TR_NOOP("AVI, pack VOP")},
-  {ADM_AVI_UNP,QT_TR_NOOP("AVI, unpack VOP")},  
-  {ADM_PS,QT_TR_NOOP("MPEG-PS (A+V)")},
-  {ADM_TS,QT_TR_NOOP("MPEG-TS (A+V)")},
-  {ADM_ES,QT_TR_NOOP("MPEG video")},
-  {ADM_MP4,QT_TR_NOOP("MP4")},
-  {ADM_PSP,QT_TR_NOOP("MP4 (PSP)")},
-  {ADM_OGM,QT_TR_NOOP("OGM")},
-  {ADM_FLV,QT_TR_NOOP("FLV")},
-  {ADM_MATROSKA,QT_TR_NOOP("MKV")},
-  {ADM_DUMMY,QT_TR_NOOP("DUMMY")}
+  {ADM_AVI, QT_TR_NOOP("AVI"), ADM_aviUISetMuxer, 0, NULL, NULL},
+  {ADM_AVI_DUAL, QT_TR_NOOP("AVI, dual audio"), ADM_aviUISetMuxer, 0, NULL, NULL},
+  {ADM_AVI_PAK, QT_TR_NOOP("AVI, pack VOP"), ADM_aviUISetMuxer, 0, NULL, NULL},
+  {ADM_AVI_UNP, QT_TR_NOOP("AVI, unpack VOP"), ADM_aviUISetMuxer, 0, NULL, NULL},
+  {ADM_PS, QT_TR_NOOP("MPEG-PS (A+V)"), muxerMpegPsConfigure, sizeof(ps_muxer), &ps_muxer_default, &psMuxerConfig},
+  {ADM_TS, QT_TR_NOOP("MPEG-TS (A+V)"), NULL, 0, NULL, NULL},
+  {ADM_ES, QT_TR_NOOP("MPEG video"), NULL, 0, NULL, NULL},
+  {ADM_MP4, QT_TR_NOOP("MP4"), NULL, 0, NULL, NULL},
+  {ADM_PSP, QT_TR_NOOP("MP4 (PSP)"), NULL, 0, NULL, NULL},
+  {ADM_OGM, QT_TR_NOOP("OGM"), NULL, 0, NULL, NULL},
+  {ADM_FLV, QT_TR_NOOP("FLV"), NULL, 0, NULL, NULL},
+  {ADM_MATROSKA, QT_TR_NOOP("MKV"), NULL, 0, NULL, NULL},
+  {ADM_DUMMY, QT_TR_NOOP("DUMMY"), NULL, 0, NULL, NULL}
 };
 
 #endif

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_avi/op_avisave.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_avi/op_avisave.cpp	2010-01-01 18:40:56 UTC (rev 5804)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_avi/op_avisave.cpp	2010-01-02 12:45:44 UTC (rev 5805)
@@ -51,7 +51,7 @@
 #include "ADM_coreUI/include/DIA_factory.h"
 const char *getStrFromAudioCodec( uint32_t codec);
 //_________________________
-uint8_t ADM_aviUISetMuxer(  void )
+bool ADM_aviUISetMuxer(  void )
 {
   
 //	return DIA_setUserMuxParam ((int *) &muxMode, (int *) &muxParam, (int *) &muxSize);

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_avi/op_avisave.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_avi/op_avisave.h	2010-01-01 18:40:56 UTC (rev 5804)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_avi/op_avisave.h	2010-01-02 12:45:44 UTC (rev 5805)
@@ -83,6 +83,6 @@
    };
 extern uint32_t muxSize;
 uint8_t ADM_aviSetSplitSize(uint32_t size);
-uint8_t ADM_aviUISetMuxer(  void );
+bool ADM_aviUISetMuxer(  void );
   #endif
 

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_mpegFF/oplug_vcdff.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_mpegFF/oplug_vcdff.cpp	2010-01-01 18:40:56 UTC (rev 5804)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_mpegFF/oplug_vcdff.cpp	2010-01-02 12:45:44 UTC (rev 5805)
@@ -54,6 +54,8 @@
 static char *twoPass = NULL;
 static char *twoFake = NULL;
 
+ps_muxer psMuxerConfig = {PS_MUXER_DVD, 0};
+
 uint8_t oplug_mpegff(const char *name, ADM_OUT_FORMAT type)
 {
 AVDMGenericVideoStream *_incoming;
@@ -137,38 +139,49 @@
                 if (videoCodecGetType() == CodecVCD ||
 					(videoCodecGetType() == CodecExternal && strcmp(videoCodecPluginGetGuid(), "85FC9CAC-CE6C-4aa6-9D5F-352D6349BA3E") == 0) || // avcodec MPEG-1 plugin
 					(videoCodecGetType() == CodecExternal && strcmp(videoCodecPluginGetGuid(), "DBAECD8B-CF29-4846-AF57-B596427FE7D3") == 0)) // avcodec MPEG-2 plugin
-                {
-                        if(hdr->frequency!=44100 ||  hdr->encoding != WAV_MP2)
-                        {
-                            GUI_Error_HIG(("Incompatible audio"),QT_TR_NOOP( "For VCD, audio must be 44.1 kHz MP2."));
-							goto finishvcdff;
-                        }
-                        mux=MUXER_VCD;
-                        printf("X*CD: Using VCD PS\n");
-                }else
-                {    
-                        aviInfo info;
-                        video_body->getVideoInfo(&info);
-                        if(hdr->frequency==44100 && _w==480&&hdr->encoding == WAV_MP2 ) // SVCD ?
-                        {
-                            mux=MUXER_SVCD;
-                            printf("X*VCD: Using SVCD PS\n");
-                        }
-                        else
-                        {
-                            // mpeg2, we do only DVD right now
-                            if(hdr->frequency!=48000 || 
-                                (hdr->encoding != WAV_MP2 && hdr->encoding!=WAV_AC3 && hdr->encoding!=WAV_LPCM))
-                            {
-                                GUI_Error_HIG(QT_TR_NOOP("Incompatible audio"), QT_TR_NOOP("For DVD, audio must be 48 kHz MP2, AC3 or LPCM."));
+				{
+					switch (psMuxerConfig.muxingType)
+					{
+						case PS_MUXER_VCD:
+						{
+							if (!psMuxerConfig.acceptNonCompliant && (hdr->frequency != 44100 || hdr->encoding != WAV_MP2))
+							{
+								GUI_Error_HIG(("Incompatible audio"),QT_TR_NOOP( "For VCD, audio must be 44.1 kHz MP2."));
 								goto finishvcdff;
-                            }
-                            mux=MUXER_DVD;
-                            printf("X*VCD: Using DVD PS\n");
-                        }
-                }
+							}
+
+							mux = MUXER_VCD;
+							printf("X*CD: Using VCD PS\n");
+							break;
+						}
+						case PS_MUXER_SVCD:
+						{
+							if (!psMuxerConfig.acceptNonCompliant && (hdr->frequency != 44100 && hdr->encoding == WAV_MP2))
+							{
+								GUI_Error_HIG(("Incompatible audio"),QT_TR_NOOP( "For SVCD, audio must be 44.1 kHz MP2."));
+								goto finishvcdff;
+							}
+
+							mux = MUXER_SVCD;
+							printf("X*VCD: Using SVCD PS\n");
+							break;
+						}
+						case PS_MUXER_DVD:
+						{
+							if (!psMuxerConfig.acceptNonCompliant && (hdr->frequency != 48000 || (hdr->encoding != WAV_MP2 && hdr->encoding != WAV_AC3 && hdr->encoding != WAV_LPCM)))
+							{
+								GUI_Error_HIG(("Incompatible audio"), QT_TR_NOOP("For DVD, audio must be 48 kHz MP2, AC3 or LPCM."));
+								goto finishvcdff;								
+							}
+
+							mux = MUXER_DVD;
+							printf("X*VCD: Using DVD PS\n");
+							break;
+						}
+					}
+				}
             }
-         }        
+         }
         // Create muxer
        encoder = getVideoEncoder(0);
 

Added: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_mpegFF/ps_muxer.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_mpegFF/ps_muxer.h	2010-01-01 18:40:56 UTC (rev 5804)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_mpegFF/ps_muxer.h	2010-01-02 12:45:44 UTC (rev 5805)
@@ -0,0 +1,15 @@
+#ifndef ADM_ps_muxer_CONF_H
+#define ADM_ps_muxer_CONF_H
+
+#define PS_MUXER_DVD 0
+#define PS_MUXER_VCD 1
+#define PS_MUXER_SVCD 2
+
+typedef struct {
+	uint32_t muxingType;
+	uint32_t acceptNonCompliant;
+} ps_muxer;
+
+const ps_muxer ps_muxer_default = {PS_MUXER_DVD, 0};
+
+#endif

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemux.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemux.cpp	2010-01-01 18:40:56 UTC (rev 5804)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemux.cpp	2010-01-02 12:45:44 UTC (rev 5805)
@@ -1,577 +1,615 @@
-// // C++ Interface: Spider Monkey interface
-//
-// Description: 
-//
-//
-// Author: Anish Mistry
-//      Some modification by mean
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-#include "config.h"
-
-#include <math.h>
-
-#include "ADM_default.h"
-#include "ADM_JSAvidemux.h"
-#include "avi_vars.h"
-#include "DIA_coreToolkit.h"
-#include "../ADM_userInterfaces/ADM_commonUI/GUI_ui.h"
-#include "ADM_script/ADM_container.h"
-
-#include "ADM_osSupport/ADM_debugID.h"
-#define MODULE_NAME MODULE_SCRIPT
-#include "ADM_osSupport/ADM_debug.h"
-
-extern int A_openAvi (const char *name);
-extern int A_Save (const char *name);
-extern int A_appendAvi (const char *name);
-extern uint8_t ogmSave(char *name);
-extern int GUI_GoToFrame(uint32_t frame);
-extern int filterLoadXml(const char *docname,uint8_t silent);
-extern int A_delete(uint32_t start, uint32_t end);
-
-extern uint8_t A_ListAllBlackFrames( char *file );
-extern uint8_t A_jumpToTime(uint32_t hh,uint32_t mm,uint32_t ss,uint32_t ms);
-extern uint8_t addFile(char *name);
-
-uint8_t A_setContainer(const char *cont);
-const char *getCurrentContainerAsString(void);
-
-JSPropertySpec ADM_JSAvidemux::avidemux_properties[] = 
-{ 
-
-	{ "markerA", markerA_prop, JSPROP_ENUMERATE },	// set marker A
-	{ "markerB", markerB_prop, JSPROP_ENUMERATE },	// set marker B
-	{ "audio", audio_prop, JSPROP_ENUMERATE },	// audio object
-	{ "video", video_prop, JSPROP_ENUMERATE },	// video object
-	{ "container", container_prop, JSPROP_ENUMERATE },	// set container type
-	{ "currentFrame", currentframe_prop, JSPROP_ENUMERATE },	// set current frame
-	{ "fps", fps_prop, JSPROP_ENUMERATE },	// set movie frame rate
-	{ 0 }
-};
-
-JSFunctionSpec ADM_JSAvidemux::avidemux_methods[] = 
-{
-	{ "append", Append, 1, 0, 0 },	// append video
-	{ "delete", Delete, 2, 0, 0 },	// delete section
-	{ "exit", Exit, 0, 0, 0 },	// exit Avidemux
-	{ "load", Load, 1, 0, 0 },	// Load movie
-	{ "loadFilters", LoadFilters, 1, 0, 0 },	// Load filters from file
-	{ "save", Save, 1, 0, 0 },	// Save movie
-/*	{ "saveDVD", SaveDVD, 1, 0, 0 },	// Save movie as DVD
-	{ "saveOGM", SaveOGM, 1, 0, 0 },	// Save movie as OGM*/
-        { "clearSegments", ClearSegments ,0,0,0}, // Clear all segments
-        { "addSegment", AddSegment ,3,0,0}, // Clear all segments
-	{ "goToTime", GoToTime, 3, 0, 0 },	// more current frame to time index
-	{ "forceUnpack", forceUnpack, 0, 0, 0 },
-        { "smartCopyMode", smartcopyMode, 0, 0, 0 },
-        { "setContainer", setContainer, 1, 0, 0 },
-        { "rebuildIndex", rebuildIndex, 0, 0, 0 },
-
-	{ 0 }
-};
-
-JSClass ADM_JSAvidemux::m_classAvidemux = 
-{
-	"Avidemux", JSCLASS_HAS_PRIVATE,
-	JS_PropertyStub, JS_PropertyStub,
-	ADM_JSAvidemux::JSGetProperty, ADM_JSAvidemux::JSSetProperty,
-	JS_EnumerateStub, JS_ResolveStub, 
-	JS_ConvertStub, ADM_JSAvidemux::JSDestructor
-};
-
-ADM_JSAvidemux::~ADM_JSAvidemux(void)
-{
-	if(m_pObject != NULL)
-		delete m_pObject;
-	m_pObject = NULL;
-}
-
-void ADM_JSAvidemux::setObject(ADM_Avidemux *pObject)
-{
-	m_pObject = pObject; 
-}
-	
-ADM_Avidemux *ADM_JSAvidemux::getObject()
-{
-	return m_pObject; 
-}
-
-JSObject *ADM_JSAvidemux::JSInit(JSContext *cx, JSObject *obj, JSObject *proto)
-{
-	JSObject *newObj = JS_InitClass(cx, obj, proto, &m_classAvidemux, 
-									ADM_JSAvidemux::JSConstructor, 0,
-									ADM_JSAvidemux::avidemux_properties, ADM_JSAvidemux::avidemux_methods,
-									NULL, NULL);
-	return newObj;
-}
-
-JSBool ADM_JSAvidemux::JSConstructor(JSContext *cx, JSObject *obj, uintN argc, 
-								 jsval *argv, jsval *rval)
-{
-	if(argc != 0)
-		return JS_FALSE;
-	ADM_JSAvidemux *p = new ADM_JSAvidemux();
-	ADM_Avidemux *pObject = new ADM_Avidemux();
-	p->setObject(pObject);
-	if ( ! JS_SetPrivate(cx, obj, p) )
-		return JS_FALSE;
-	*rval = OBJECT_TO_JSVAL(obj);
-	return JS_TRUE;
-}
-
-void ADM_JSAvidemux::JSDestructor(JSContext *cx, JSObject *obj)
-{
-	ADM_JSAvidemux *p = (ADM_JSAvidemux *)JS_GetPrivate(cx, obj);
-	if(p != NULL)
-		delete p;
-	p = NULL;
-}
-
-JSBool ADM_JSAvidemux::JSGetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
-{
-        if (JSVAL_IS_INT(id)) 
-        {
-                ADM_JSAvidemux *priv = (ADM_JSAvidemux *) JS_GetPrivate(cx, obj);
-                switch(JSVAL_TO_INT(id))
-                {
-
-                        case markerA_prop:
-                                *vp = INT_TO_JSVAL(frameStart);
-                                break;
-                        case markerB_prop:
-                                *vp = INT_TO_JSVAL(frameEnd);
-                                break;
-                        case audio_prop:
-								if (avifileinfo)
-									*vp = OBJECT_TO_JSVAL(priv->getObject()->m_pAudio);
-								else
-									*vp = NULL;
-
-                                break;
-                        case video_prop:
-								if (avifileinfo)
-									*vp = OBJECT_TO_JSVAL(priv->getObject()->m_pVideo);
-								else
-									*vp = NULL;
-
-                                break;
-                        case container_prop:
-                                *vp = STRING_TO_JSVAL(priv->getObject()->m_pContainer);
-                                break;
-                        case currentframe_prop:
-                                *vp = INT_TO_JSVAL(priv->getObject()->m_nCurrentFrame);
-                                break;
-                        case fps_prop:
-                                {
-                                        aviInfo info;
-
-                                        if (avifileinfo)
-                                        {
-                                                enterLock();
-                                                video_body->getVideoInfo(&info);
-                                                priv->getObject()->m_dFPS = info.fps1000/1000.0; 
-                                                video_body->updateVideoInfo (&info);
-                                                video_body->getVideoInfo (avifileinfo);
-                                                leaveLock();
-                                        } 
-                                        else 
-                                        {
-                                                return JS_FALSE;
-                                        }
-                                        *vp = DOUBLE_TO_JSVAL(priv->getObject()->m_dFPS);
-                                }
-                                break;
-                }
-        }
-        return JS_TRUE;
-}
-
-JSBool ADM_JSAvidemux::JSSetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
-{
-	if (JSVAL_IS_INT(id)) 
-	{
-		ADM_JSAvidemux *priv = (ADM_JSAvidemux *) JS_GetPrivate(cx, obj);
-		switch(JSVAL_TO_INT(id))
-		{
-			case markerA_prop:
-				if(JSVAL_IS_INT(*vp) == false)
-					break;
-				{
-					int f=JSVAL_TO_INT(*vp);
-					if (!avifileinfo)
-					{
-						return JS_FALSE;
-					} 
-					if(f==-1)
-						f=avifileinfo->nb_frames-1;
-					if(f<0 || f>avifileinfo->nb_frames-1)
-						return JS_FALSE;
-					frameStart=f;
-				}
-				break;
-			case markerB_prop:
-				if(JSVAL_IS_INT(*vp) == false)
-					break;
-				{
-					int f=JSVAL_TO_INT(*vp);
-					if (!avifileinfo)
-					{
-						return JS_FALSE;
-					} 
-					if(f==-1)
-						f=avifileinfo->nb_frames-1;
-					if(f<0 || f>avifileinfo->nb_frames-1)
-						return JS_FALSE;
-					frameEnd=f;
-				}
-				break;
-			case audio_prop:
-				return JS_FALSE;
-				break;
-			case video_prop:
-				return JS_FALSE;
-				break;
-			case container_prop:
-				if(JSVAL_IS_STRING(*vp) == false)
-					break;
-				{
-					priv->getObject()->m_pContainer = JSVAL_TO_STRING(*vp);
-					char *pContainer = JS_GetStringBytes(priv->getObject()->m_pContainer);
-					aprintf("Setting container format \"%s\"\n",pContainer);
-                                        if(A_setContainer(pContainer))
-                                                return JS_TRUE;
-                                        return JS_FALSE;
-					return JS_FALSE;
-				}
-				break;
-			case currentframe_prop:
-				if(JSVAL_IS_INT(*vp) == false)
-					break;
-				{
-					int frameno;
-					if (!avifileinfo)
-						return JS_FALSE;
-					
-					frameno = JSVAL_TO_INT(*vp);
-					if( frameno<0)
-					{
-						aviInfo info;
-						video_body->getVideoInfo(&info);
-						frameno=-frameno;
-						if(frameno>info.nb_frames)
-							return JS_FALSE;
-						
-						frameno = info.nb_frames-frameno;
-					}
-                                        enterLock();
-					if(GUI_GoToFrame( frameno ))
-					{
-						leaveLock();
-						return JS_TRUE;
-					}
-					leaveLock();
-					return JS_FALSE;
-				}
-				break;
-			case fps_prop:
-				if(JSVAL_IS_DOUBLE(*vp) == false)
-					break;
-				{
-					priv->getObject()->m_dFPS = *JSVAL_TO_DOUBLE(*vp);
-					aviInfo info;
-
-					if (avifileinfo)
-					{
-						video_body->getVideoInfo(&info);				
-						info.fps1000 = (uint32_t)floor(priv->getObject()->m_dFPS*1000.f);
-						video_body->updateVideoInfo (&info);
-						video_body->getVideoInfo (avifileinfo);
-						return JS_TRUE;
-					} else 
-					{
-						return JS_FALSE;
-					}
-				}
-				break;
-		}
-	}
-	return JS_TRUE;
-}
-
-JSBool ADM_JSAvidemux::Load(JSContext *cx, JSObject *obj, uintN argc, 
-                                       jsval *argv, jsval *rval)
-{// begin Load
-        JSBool ret=JS_FALSE;
-        ADM_JSAvidemux *p = (ADM_JSAvidemux *)JS_GetPrivate(cx, obj);
-        // default return value
-        *rval = BOOLEAN_TO_JSVAL(false);
-        if(argc != 1)
-                return JS_FALSE;
-        if(JSVAL_IS_STRING(argv[0]) == false)
-                return JS_FALSE;
-        char *pTempStr = JS_GetStringBytes(JSVAL_TO_STRING(argv[0]));
-        printf("Loading \"%s\"\n",pTempStr);
-        // Do a failure instead of returing ko
-        *rval = BOOLEAN_TO_JSVAL(JS_TRUE);
-        enterLock();
-        if(!A_openAvi(pTempStr)) 
-        {
-          ret= JS_FALSE;	
-        }else 
-        {
-          ret=JS_TRUE;
-        }
-        leaveLock();
-	return ret;
-}// end Load
-
-JSBool ADM_JSAvidemux::LoadFilters(JSContext *cx, JSObject *obj, uintN argc, 
-                                       jsval *argv, jsval *rval)
-{// begin LoadFilters
-        ADM_JSAvidemux *p = (ADM_JSAvidemux *)JS_GetPrivate(cx, obj);
-        // default return value
-        *rval = BOOLEAN_TO_JSVAL(false);
-        if(argc != 1)
-                return JS_FALSE;
-        if(JSVAL_IS_STRING(argv[0]) == false)
-                return JS_FALSE;
-        char *pTempStr = JS_GetStringBytes(JSVAL_TO_STRING(argv[0]));
-        printf("Loading Filters \"%s\"\n",pTempStr);
-        enterLock();
-        *rval = BOOLEAN_TO_JSVAL(filterLoadXml(pTempStr,0));
-        leaveLock();
-	return JS_TRUE;
-}// end LoadFilters
-
-
-JSBool ADM_JSAvidemux::Append(JSContext *cx, JSObject *obj, uintN argc, 
-                                       jsval *argv, jsval *rval)
-{// begin Append
-        ADM_JSAvidemux *p = (ADM_JSAvidemux *)JS_GetPrivate(cx, obj);
-        // default return value
-        *rval = BOOLEAN_TO_JSVAL(false);
-        if(argc != 1)
-                return JS_FALSE;
-        if(JSVAL_IS_STRING(argv[0]) == false)
-                return JS_FALSE;
-        char *pTempStr = JS_GetStringBytes(JSVAL_TO_STRING(argv[0]));
-        printf("Appending \"%s\"\n",pTempStr);
-        enterLock();
-        *rval = BOOLEAN_TO_JSVAL(A_appendAvi(pTempStr));
-        leaveLock();
-	return JS_TRUE;
-}// end Append
-
-JSBool ADM_JSAvidemux::Delete(JSContext *cx, JSObject *obj, uintN argc, 
-                                       jsval *argv, jsval *rval)
-{// begin Delete
-        ADM_JSAvidemux *p = (ADM_JSAvidemux *)JS_GetPrivate(cx, obj);
-        // default return value
-        *rval = BOOLEAN_TO_JSVAL(false);
-        if(argc != 2)
-                return JS_FALSE;
-        if(JSVAL_IS_INT(argv[0]) == false || JSVAL_IS_INT(argv[1]) == false)
-                return JS_FALSE;
-        int a = JSVAL_TO_INT(argv[0]);
-        int b = JSVAL_TO_INT(argv[1]);
-        aprintf("Deleting %d-%d\n",a,b);
-        enterLock();
-        *rval = BOOLEAN_TO_JSVAL(A_delete(a,b));
-        leaveLock();
-        return JS_TRUE;
-}// end Delete
-
-JSBool ADM_JSAvidemux::Save(JSContext *cx, JSObject *obj, uintN argc, 
-                                       jsval *argv, jsval *rval)
-{// begin Save
-        ADM_JSAvidemux *p = (ADM_JSAvidemux *)JS_GetPrivate(cx, obj);
-        // default return value
-        *rval = BOOLEAN_TO_JSVAL(false);
-        if(argc != 1)
-                return JS_FALSE;
-        if(JSVAL_IS_STRING(argv[0]) == false)
-                return JS_FALSE;
-        char *pTempStr = JS_GetStringBytes(JSVAL_TO_STRING(argv[0]));
-        printf("Saving \"%s\"\n",pTempStr);
-        enterLock();
-        *rval = BOOLEAN_TO_JSVAL(A_Save(pTempStr));
-        leaveLock();
-        return JS_TRUE;
-}// end Save
-
-static void updateAll(void)
-{
-        if(!avifileinfo) return;
-        if (!video_body->updateVideoInfo (avifileinfo))
-        {
-                GUI_Error_HIG ("OOPS","Something bad happened when executing that script");
-        }
-        frameStart=0;
-        if(avifileinfo->nb_frames)
-                frameEnd=avifileinfo->nb_frames-1;
-        else
-                frameEnd=0;
-}
-JSBool ADM_JSAvidemux::ClearSegments(JSContext *cx, JSObject *obj, uintN argc, 
-                                       jsval *argv, jsval *rval)
-{// begin ClearSegments
-        ADM_JSAvidemux *p = (ADM_JSAvidemux *)JS_GetPrivate(cx, obj);
-        // default return value
-        *rval = BOOLEAN_TO_JSVAL(false);
-        if(argc != 0)
-                return JS_FALSE;
-        printf("clearing segments \n");
-        enterLock();
-        *rval = BOOLEAN_TO_JSVAL(video_body->deleteAllSegments());
-	leaveLock();
-        updateAll();
-        return JS_TRUE;
-}// end ClearSegments
-/*
-add a segment. addsegment(source video,startframe, nbframes)",     
-*/
-JSBool ADM_JSAvidemux::AddSegment(JSContext *cx, JSObject *obj, uintN argc, 
-                                       jsval *argv, jsval *rval)
-{// begin AddSegment
-        ADM_JSAvidemux *p = (ADM_JSAvidemux *)JS_GetPrivate(cx, obj);
-        // default return value
-        *rval = BOOLEAN_TO_JSVAL(false);
-        if(argc != 3)
-                return JS_FALSE;
-	if(JSVAL_IS_INT(argv[0]) == false || JSVAL_IS_INT(argv[1]) == false || JSVAL_IS_INT(argv[2]) == false)
-		return JS_FALSE;
-        int a = JSVAL_TO_INT(argv[0]);
-        int b = JSVAL_TO_INT(argv[1]);
-        int c = JSVAL_TO_INT(argv[2]);
-        aprintf("adding segment :%d %d %d\n",a,b,c);
-        enterLock();
-        *rval = BOOLEAN_TO_JSVAL( video_body->addSegment(a,b,c));
-	leaveLock();
-        updateAll();
-        return JS_TRUE;
-}// end AddSegment
-
-
-JSBool ADM_JSAvidemux::Exit(JSContext *cx, JSObject *obj, uintN argc, 
-                                       jsval *argv, jsval *rval)
-{// begin Exit
-	ADM_JSAvidemux *p = (ADM_JSAvidemux *)JS_GetPrivate(cx, obj);
-	// default return value
-	*rval = BOOLEAN_TO_JSVAL(false);
-	if(argc != 0)
-		return JS_FALSE;
-	exit(0);
-	*rval = INT_TO_JSVAL(1);
-	return JS_TRUE;
-}// end Exit
-
-JSBool ADM_JSAvidemux::GoToTime(JSContext *cx, JSObject *obj, uintN argc, 
-                                       jsval *argv, jsval *rval)
-{// begin GoToTime
-	ADM_JSAvidemux *p = (ADM_JSAvidemux *)JS_GetPrivate(cx, obj);
-	// default return value
-	*rval = BOOLEAN_TO_JSVAL(false);
-	if(argc != 3)
-		return JS_FALSE;
-	if(JSVAL_IS_INT(argv[0]) == false || JSVAL_IS_INT(argv[1]) == false || JSVAL_IS_INT(argv[2]) == false)
-		return JS_FALSE;
-        enterLock();
-	*rval = INT_TO_JSVAL(A_jumpToTime(JSVAL_TO_INT(argv[0]),JSVAL_TO_INT(argv[1]),JSVAL_TO_INT(argv[2]), 0));
-	leaveLock();
-	return JS_TRUE;
-}// end GoToTime
-
-JSBool ADM_JSAvidemux::forceUnpack(JSContext *cx, JSObject *obj, uintN argc, 
-                                       jsval *argv, jsval *rval)
-{// begin GoToTime
-        ADM_JSAvidemux *p = (ADM_JSAvidemux *)JS_GetPrivate(cx, obj);
-        // default return value
-        *rval = BOOLEAN_TO_JSVAL(false);
-        if(argc != 0)
-                return JS_FALSE;
-        enterLock();
-        video_body->setEnv(ENV_EDITOR_PVOP);
-        leaveLock();
-        *rval = INT_TO_JSVAL(1);
-        return JS_TRUE;
-}// end GoToTime
-JSBool ADM_JSAvidemux::rebuildIndex(JSContext *cx, JSObject *obj, uintN argc, 
-                                       jsval *argv, jsval *rval)
-{// begin GoToTime
-        ADM_JSAvidemux *p = (ADM_JSAvidemux *)JS_GetPrivate(cx, obj);
-        // default return value
-        *rval = BOOLEAN_TO_JSVAL(false);
-        if(argc != 0)
-                return JS_FALSE;
-        enterLock();
-        if(!video_body->isReordered(0)) // already done
-        {
-          video_body->rebuildFrameType();
-        }
- 	leaveLock();
-       return JS_TRUE;
-}// end GoToTime
-
-JSBool ADM_JSAvidemux::smartcopyMode(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
-{
-
-ADM_JSAvidemux *p = (ADM_JSAvidemux *)JS_GetPrivate(cx, obj);
-        // default return value
-        printf("[JS]Setting smart copy mode(1)\n");
-        *rval = BOOLEAN_TO_JSVAL(false);
-        if(argc != 0)
-                return JS_FALSE;
-        printf("[JS]Setting smart copy mode (2)\n");
-        enterLock();
-        video_body->setEnv(ENV_EDITOR_SMART);
-        *rval = BOOLEAN_TO_JSVAL( true);
-        leaveLock();
-        return JS_TRUE;
-}
-JSBool ADM_JSAvidemux::setContainer(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
-{
-
-ADM_JSAvidemux *p = (ADM_JSAvidemux *)JS_GetPrivate(cx, obj);
-        // default return value
-        *rval = BOOLEAN_TO_JSVAL(false);
-        if(argc != 1)
-                return JS_FALSE;
-        if(JSVAL_IS_STRING(argv[0]) == false)
-                return JS_FALSE;
-        char *str = JS_GetStringBytes(JSVAL_TO_STRING(argv[0]));
-        enterLock();
-        if(A_setContainer(str))
-                *rval = BOOLEAN_TO_JSVAL( true);
-        leaveLock();
-        return JS_TRUE;
-}
-uint8_t A_setContainer(const char *cont)
-{
-       for(int i=0;i<NB_CONT;i++)
-       {
-                printf("%s\n",container[i].name);
-                if(!strcasecmp(cont,container[i].name))
-                {
-                        UI_SetCurrentFormat(container[i].type);
-                        return 1;
-                }
-       }
-       printf("Cannot set output format \"%s\"\n",cont);
-       return 0;
-}
-
-const char *getCurrentContainerAsString(void)
-{
-        ADM_OUT_FORMAT cont=UI_GetCurrentFormat();
-        for(int i=0;i<sizeof(container)/sizeof(ADM_CONTAINER);i++)
-        {
-                if(container[i].type==cont) 
-                        return container[i].name;
-        }
-        ADM_assert(0);
-        return NULL;
-
-}
+// // C++ Interface: Spider Monkey interface
+//
+// Description: 
+//
+//
+// Author: Anish Mistry
+//      Some modification by mean
+//
+// Copyright: See COPYING file that comes with this distribution
+//
+//
+#include "config.h"
+
+#include <math.h>
+
+#include "ADM_default.h"
+#include "ADM_JSAvidemux.h"
+#include "avi_vars.h"
+#include "DIA_coreToolkit.h"
+#include "../ADM_userInterfaces/ADM_commonUI/GUI_ui.h"
+#include "ADM_script/ADM_container.h"
+
+#include "ADM_osSupport/ADM_debugID.h"
+#define MODULE_NAME MODULE_SCRIPT
+#include "ADM_osSupport/ADM_debug.h"
+
+extern int A_openAvi (const char *name);
+extern int A_Save (const char *name);
+extern int A_appendAvi (const char *name);
+extern uint8_t ogmSave(char *name);
+extern int GUI_GoToFrame(uint32_t frame);
+extern int filterLoadXml(const char *docname,uint8_t silent);
+extern int A_delete(uint32_t start, uint32_t end);
+
+extern uint8_t A_ListAllBlackFrames( char *file );
+extern uint8_t A_jumpToTime(uint32_t hh,uint32_t mm,uint32_t ss,uint32_t ms);
+extern uint8_t addFile(char *name);
+extern uint8_t mk_hex(uint8_t a, uint8_t b);
+
+uint8_t A_setContainer(const char *cont);
+const char *getCurrentContainerAsString(void);
+
+JSPropertySpec ADM_JSAvidemux::avidemux_properties[] = 
+{ 
+
+	{ "markerA", markerA_prop, JSPROP_ENUMERATE },	// set marker A
+	{ "markerB", markerB_prop, JSPROP_ENUMERATE },	// set marker B
+	{ "audio", audio_prop, JSPROP_ENUMERATE },	// audio object
+	{ "video", video_prop, JSPROP_ENUMERATE },	// video object
+	{ "container", container_prop, JSPROP_ENUMERATE },	// set container type
+	{ "currentFrame", currentframe_prop, JSPROP_ENUMERATE },	// set current frame
+	{ "fps", fps_prop, JSPROP_ENUMERATE },	// set movie frame rate
+	{ 0 }
+};
+
+JSFunctionSpec ADM_JSAvidemux::avidemux_methods[] = 
+{
+	{ "append", Append, 1, 0, 0 },	// append video
+	{ "delete", Delete, 2, 0, 0 },	// delete section
+	{ "exit", Exit, 0, 0, 0 },	// exit Avidemux
+	{ "load", Load, 1, 0, 0 },	// Load movie
+	{ "loadFilters", LoadFilters, 1, 0, 0 },	// Load filters from file
+	{ "save", Save, 1, 0, 0 },	// Save movie
+/*	{ "saveDVD", SaveDVD, 1, 0, 0 },	// Save movie as DVD
+	{ "saveOGM", SaveOGM, 1, 0, 0 },	// Save movie as OGM*/
+        { "clearSegments", ClearSegments ,0,0,0}, // Clear all segments
+        { "addSegment", AddSegment ,3,0,0}, // Clear all segments
+	{ "goToTime", GoToTime, 3, 0, 0 },	// more current frame to time index
+	{ "forceUnpack", forceUnpack, 0, 0, 0 },
+        { "smartCopyMode", smartcopyMode, 0, 0, 0 },
+        { "setContainer", setContainer, 1, 0, 0 },
+        { "rebuildIndex", rebuildIndex, 0, 0, 0 },
+
+	{ 0 }
+};
+
+JSClass ADM_JSAvidemux::m_classAvidemux = 
+{
+	"Avidemux", JSCLASS_HAS_PRIVATE,
+	JS_PropertyStub, JS_PropertyStub,
+	ADM_JSAvidemux::JSGetProperty, ADM_JSAvidemux::JSSetProperty,
+	JS_EnumerateStub, JS_ResolveStub, 
+	JS_ConvertStub, ADM_JSAvidemux::JSDestructor
+};
+
+ADM_JSAvidemux::~ADM_JSAvidemux(void)
+{
+	if(m_pObject != NULL)
+		delete m_pObject;
+	m_pObject = NULL;
+}
+
+void ADM_JSAvidemux::setObject(ADM_Avidemux *pObject)
+{
+	m_pObject = pObject; 
+}
+	
+ADM_Avidemux *ADM_JSAvidemux::getObject()
+{
+	return m_pObject; 
+}
+
+JSObject *ADM_JSAvidemux::JSInit(JSContext *cx, JSObject *obj, JSObject *proto)
+{
+	JSObject *newObj = JS_InitClass(cx, obj, proto, &m_classAvidemux, 
+									ADM_JSAvidemux::JSConstructor, 0,
+									ADM_JSAvidemux::avidemux_properties, ADM_JSAvidemux::avidemux_methods,
+									NULL, NULL);
+	return newObj;
+}
+
+JSBool ADM_JSAvidemux::JSConstructor(JSContext *cx, JSObject *obj, uintN argc, 
+								 jsval *argv, jsval *rval)
+{
+	if(argc != 0)
+		return JS_FALSE;
+	ADM_JSAvidemux *p = new ADM_JSAvidemux();
+	ADM_Avidemux *pObject = new ADM_Avidemux();
+	p->setObject(pObject);
+	if ( ! JS_SetPrivate(cx, obj, p) )
+		return JS_FALSE;
+	*rval = OBJECT_TO_JSVAL(obj);
+	return JS_TRUE;
+}
+
+void ADM_JSAvidemux::JSDestructor(JSContext *cx, JSObject *obj)
+{
+	ADM_JSAvidemux *p = (ADM_JSAvidemux *)JS_GetPrivate(cx, obj);
+	if(p != NULL)
+		delete p;
+	p = NULL;
+}
+
+JSBool ADM_JSAvidemux::JSGetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
+{
+        if (JSVAL_IS_INT(id)) 
+        {
+                ADM_JSAvidemux *priv = (ADM_JSAvidemux *) JS_GetPrivate(cx, obj);
+                switch(JSVAL_TO_INT(id))
+                {
+
+                        case markerA_prop:
+                                *vp = INT_TO_JSVAL(frameStart);
+                                break;
+                        case markerB_prop:
+                                *vp = INT_TO_JSVAL(frameEnd);
+                                break;
+                        case audio_prop:
+								if (avifileinfo)
+									*vp = OBJECT_TO_JSVAL(priv->getObject()->m_pAudio);
+								else
+									*vp = NULL;
+
+                                break;
+                        case video_prop:
+								if (avifileinfo)
+									*vp = OBJECT_TO_JSVAL(priv->getObject()->m_pVideo);
+								else
+									*vp = NULL;
+
+                                break;
+                        case container_prop:
+                                *vp = STRING_TO_JSVAL(priv->getObject()->m_pContainer);
+                                break;
+                        case currentframe_prop:
+                                *vp = INT_TO_JSVAL(priv->getObject()->m_nCurrentFrame);
+                                break;
+                        case fps_prop:
+                                {
+                                        aviInfo info;
+
+                                        if (avifileinfo)
+                                        {
+                                                enterLock();
+                                                video_body->getVideoInfo(&info);
+                                                priv->getObject()->m_dFPS = info.fps1000/1000.0; 
+                                                video_body->updateVideoInfo (&info);
+                                                video_body->getVideoInfo (avifileinfo);
+                                                leaveLock();
+                                        } 
+                                        else 
+                                        {
+                                                return JS_FALSE;
+                                        }
+                                        *vp = DOUBLE_TO_JSVAL(priv->getObject()->m_dFPS);
+                                }
+                                break;
+                }
+        }
+        return JS_TRUE;
+}
+
+JSBool ADM_JSAvidemux::JSSetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
+{
+	if (JSVAL_IS_INT(id)) 
+	{
+		ADM_JSAvidemux *priv = (ADM_JSAvidemux *) JS_GetPrivate(cx, obj);
+		switch(JSVAL_TO_INT(id))
+		{
+			case markerA_prop:
+				if(JSVAL_IS_INT(*vp) == false)
+					break;
+				{
+					int f=JSVAL_TO_INT(*vp);
+					if (!avifileinfo)
+					{
+						return JS_FALSE;
+					} 
+					if(f==-1)
+						f=avifileinfo->nb_frames-1;
+					if(f<0 || f>avifileinfo->nb_frames-1)
+						return JS_FALSE;
+					frameStart=f;
+				}
+				break;
+			case markerB_prop:
+				if(JSVAL_IS_INT(*vp) == false)
+					break;
+				{
+					int f=JSVAL_TO_INT(*vp);
+					if (!avifileinfo)
+					{
+						return JS_FALSE;
+					} 
+					if(f==-1)
+						f=avifileinfo->nb_frames-1;
+					if(f<0 || f>avifileinfo->nb_frames-1)
+						return JS_FALSE;
+					frameEnd=f;
+				}
+				break;
+			case audio_prop:
+				return JS_FALSE;
+				break;
+			case video_prop:
+				return JS_FALSE;
+				break;
+			case container_prop:
+				if(JSVAL_IS_STRING(*vp) == false)
+					break;
+				{
+					priv->getObject()->m_pContainer = JSVAL_TO_STRING(*vp);
+					char *pContainer = JS_GetStringBytes(priv->getObject()->m_pContainer);
+					aprintf("Setting container format \"%s\"\n",pContainer);
+                                        if(A_setContainer(pContainer))
+                                                return JS_TRUE;
+                                        return JS_FALSE;
+					return JS_FALSE;
+				}
+				break;
+			case currentframe_prop:
+				if(JSVAL_IS_INT(*vp) == false)
+					break;
+				{
+					int frameno;
+					if (!avifileinfo)
+						return JS_FALSE;
+					
+					frameno = JSVAL_TO_INT(*vp);
+					if( frameno<0)
+					{
+						aviInfo info;
+						video_body->getVideoInfo(&info);
+						frameno=-frameno;
+						if(frameno>info.nb_frames)
+							return JS_FALSE;
+						
+						frameno = info.nb_frames-frameno;
+					}
+                                        enterLock();
+					if(GUI_GoToFrame( frameno ))
+					{
+						leaveLock();
+						return JS_TRUE;
+					}
+					leaveLock();
+					return JS_FALSE;
+				}
+				break;
+			case fps_prop:
+				if(JSVAL_IS_DOUBLE(*vp) == false)
+					break;
+				{
+					priv->getObject()->m_dFPS = *JSVAL_TO_DOUBLE(*vp);
+					aviInfo info;
+
+					if (avifileinfo)
+					{
+						video_body->getVideoInfo(&info);				
+						info.fps1000 = (uint32_t)floor(priv->getObject()->m_dFPS*1000.f);
+						video_body->updateVideoInfo (&info);
+						video_body->getVideoInfo (avifileinfo);
+						return JS_TRUE;
+					} else 
+					{
+						return JS_FALSE;
+					}
+				}
+				break;
+		}
+	}
+	return JS_TRUE;
+}
+
+JSBool ADM_JSAvidemux::Load(JSContext *cx, JSObject *obj, uintN argc, 
+                                       jsval *argv, jsval *rval)
+{// begin Load
+        JSBool ret=JS_FALSE;
+        ADM_JSAvidemux *p = (ADM_JSAvidemux *)JS_GetPrivate(cx, obj);
+        // default return value
+        *rval = BOOLEAN_TO_JSVAL(false);
+        if(argc != 1)
+                return JS_FALSE;
+        if(JSVAL_IS_STRING(argv[0]) == false)
+                return JS_FALSE;
+        char *pTempStr = JS_GetStringBytes(JSVAL_TO_STRING(argv[0]));
+        printf("Loading \"%s\"\n",pTempStr);
+        // Do a failure instead of returing ko
+        *rval = BOOLEAN_TO_JSVAL(JS_TRUE);
+        enterLock();
+        if(!A_openAvi(pTempStr)) 
+        {
+          ret= JS_FALSE;	
+        }else 
+        {
+          ret=JS_TRUE;
+        }
+        leaveLock();
+	return ret;
+}// end Load
+
+JSBool ADM_JSAvidemux::LoadFilters(JSContext *cx, JSObject *obj, uintN argc, 
+                                       jsval *argv, jsval *rval)
+{// begin LoadFilters
+        ADM_JSAvidemux *p = (ADM_JSAvidemux *)JS_GetPrivate(cx, obj);
+        // default return value
+        *rval = BOOLEAN_TO_JSVAL(false);
+        if(argc != 1)
+                return JS_FALSE;
+        if(JSVAL_IS_STRING(argv[0]) == false)
+                return JS_FALSE;
+        char *pTempStr = JS_GetStringBytes(JSVAL_TO_STRING(argv[0]));
+        printf("Loading Filters \"%s\"\n",pTempStr);
+        enterLock();
+        *rval = BOOLEAN_TO_JSVAL(filterLoadXml(pTempStr,0));
+        leaveLock();
+	return JS_TRUE;
+}// end LoadFilters
+
+
+JSBool ADM_JSAvidemux::Append(JSContext *cx, JSObject *obj, uintN argc, 
+                                       jsval *argv, jsval *rval)
+{// begin Append
+        ADM_JSAvidemux *p = (ADM_JSAvidemux *)JS_GetPrivate(cx, obj);
+        // default return value
+        *rval = BOOLEAN_TO_JSVAL(false);
+        if(argc != 1)
+                return JS_FALSE;
+        if(JSVAL_IS_STRING(argv[0]) == false)
+                return JS_FALSE;
+        char *pTempStr = JS_GetStringBytes(JSVAL_TO_STRING(argv[0]));
+        printf("Appending \"%s\"\n",pTempStr);
+        enterLock();
+        *rval = BOOLEAN_TO_JSVAL(A_appendAvi(pTempStr));
+        leaveLock();
+	return JS_TRUE;
+}// end Append
+
+JSBool ADM_JSAvidemux::Delete(JSContext *cx, JSObject *obj, uintN argc, 
+                                       jsval *argv, jsval *rval)
+{// begin Delete
+        ADM_JSAvidemux *p = (ADM_JSAvidemux *)JS_GetPrivate(cx, obj);
+        // default return value
+        *rval = BOOLEAN_TO_JSVAL(false);
+        if(argc != 2)
+                return JS_FALSE;
+        if(JSVAL_IS_INT(argv[0]) == false || JSVAL_IS_INT(argv[1]) == false)
+                return JS_FALSE;
+        int a = JSVAL_TO_INT(argv[0]);
+        int b = JSVAL_TO_INT(argv[1]);
+        aprintf("Deleting %d-%d\n",a,b);
+        enterLock();
+        *rval = BOOLEAN_TO_JSVAL(A_delete(a,b));
+        leaveLock();
+        return JS_TRUE;
+}// end Delete
+
+JSBool ADM_JSAvidemux::Save(JSContext *cx, JSObject *obj, uintN argc, 
+                                       jsval *argv, jsval *rval)
+{// begin Save
+        ADM_JSAvidemux *p = (ADM_JSAvidemux *)JS_GetPrivate(cx, obj);
+        // default return value
+        *rval = BOOLEAN_TO_JSVAL(false);
+        if(argc != 1)
+                return JS_FALSE;
+        if(JSVAL_IS_STRING(argv[0]) == false)
+                return JS_FALSE;
+        char *pTempStr = JS_GetStringBytes(JSVAL_TO_STRING(argv[0]));
+        printf("Saving \"%s\"\n",pTempStr);
+        enterLock();
+        *rval = BOOLEAN_TO_JSVAL(A_Save(pTempStr));
+        leaveLock();
+        return JS_TRUE;
+}// end Save
+
+static void updateAll(void)
+{
+        if(!avifileinfo) return;
+        if (!video_body->updateVideoInfo (avifileinfo))
+        {
+                GUI_Error_HIG ("OOPS","Something bad happened when executing that script");
+        }
+        frameStart=0;
+        if(avifileinfo->nb_frames)
+                frameEnd=avifileinfo->nb_frames-1;
+        else
+                frameEnd=0;
+}
+JSBool ADM_JSAvidemux::ClearSegments(JSContext *cx, JSObject *obj, uintN argc, 
+                                       jsval *argv, jsval *rval)
+{// begin ClearSegments
+        ADM_JSAvidemux *p = (ADM_JSAvidemux *)JS_GetPrivate(cx, obj);
+        // default return value
+        *rval = BOOLEAN_TO_JSVAL(false);
+        if(argc != 0)
+                return JS_FALSE;
+        printf("clearing segments \n");
+        enterLock();
+        *rval = BOOLEAN_TO_JSVAL(video_body->deleteAllSegments());
+	leaveLock();
+        updateAll();
+        return JS_TRUE;
+}// end ClearSegments
+/*
+add a segment. addsegment(source video,startframe, nbframes)",     
+*/
+JSBool ADM_JSAvidemux::AddSegment(JSContext *cx, JSObject *obj, uintN argc, 
+                                       jsval *argv, jsval *rval)
+{// begin AddSegment
+        ADM_JSAvidemux *p = (ADM_JSAvidemux *)JS_GetPrivate(cx, obj);
+        // default return value
+        *rval = BOOLEAN_TO_JSVAL(false);
+        if(argc != 3)
+                return JS_FALSE;
+	if(JSVAL_IS_INT(argv[0]) == false || JSVAL_IS_INT(argv[1]) == false || JSVAL_IS_INT(argv[2]) == false)
+		return JS_FALSE;
+        int a = JSVAL_TO_INT(argv[0]);
+        int b = JSVAL_TO_INT(argv[1]);
+        int c = JSVAL_TO_INT(argv[2]);
+        aprintf("adding segment :%d %d %d\n",a,b,c);
+        enterLock();
+        *rval = BOOLEAN_TO_JSVAL( video_body->addSegment(a,b,c));
+	leaveLock();
+        updateAll();
+        return JS_TRUE;
+}// end AddSegment
+
+
+JSBool ADM_JSAvidemux::Exit(JSContext *cx, JSObject *obj, uintN argc, 
+                                       jsval *argv, jsval *rval)
+{// begin Exit
+	ADM_JSAvidemux *p = (ADM_JSAvidemux *)JS_GetPrivate(cx, obj);
+	// default return value
+	*rval = BOOLEAN_TO_JSVAL(false);
+	if(argc != 0)
+		return JS_FALSE;
+	exit(0);
+	*rval = INT_TO_JSVAL(1);
+	return JS_TRUE;
+}// end Exit
+
+JSBool ADM_JSAvidemux::GoToTime(JSContext *cx, JSObject *obj, uintN argc, 
+                                       jsval *argv, jsval *rval)
+{// begin GoToTime
+	ADM_JSAvidemux *p = (ADM_JSAvidemux *)JS_GetPrivate(cx, obj);
+	// default return value
+	*rval = BOOLEAN_TO_JSVAL(false);
+	if(argc != 3)
+		return JS_FALSE;
+	if(JSVAL_IS_INT(argv[0]) == false || JSVAL_IS_INT(argv[1]) == false || JSVAL_IS_INT(argv[2]) == false)
+		return JS_FALSE;
+        enterLock();
+	*rval = INT_TO_JSVAL(A_jumpToTime(JSVAL_TO_INT(argv[0]),JSVAL_TO_INT(argv[1]),JSVAL_TO_INT(argv[2]), 0));
+	leaveLock();
+	return JS_TRUE;
+}// end GoToTime
+
+JSBool ADM_JSAvidemux::forceUnpack(JSContext *cx, JSObject *obj, uintN argc, 
+                                       jsval *argv, jsval *rval)
+{// begin GoToTime
+        ADM_JSAvidemux *p = (ADM_JSAvidemux *)JS_GetPrivate(cx, obj);
+        // default return value
+        *rval = BOOLEAN_TO_JSVAL(false);
+        if(argc != 0)
+                return JS_FALSE;
+        enterLock();
+        video_body->setEnv(ENV_EDITOR_PVOP);
+        leaveLock();
+        *rval = INT_TO_JSVAL(1);
+        return JS_TRUE;
+}// end GoToTime
+JSBool ADM_JSAvidemux::rebuildIndex(JSContext *cx, JSObject *obj, uintN argc, 
+                                       jsval *argv, jsval *rval)
+{// begin GoToTime
+        ADM_JSAvidemux *p = (ADM_JSAvidemux *)JS_GetPrivate(cx, obj);
+        // default return value
+        *rval = BOOLEAN_TO_JSVAL(false);
+        if(argc != 0)
+                return JS_FALSE;
+        enterLock();
+        if(!video_body->isReordered(0)) // already done
+        {
+          video_body->rebuildFrameType();
+        }
+ 	leaveLock();
+       return JS_TRUE;
+}// end GoToTime
+
+JSBool ADM_JSAvidemux::smartcopyMode(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+
+ADM_JSAvidemux *p = (ADM_JSAvidemux *)JS_GetPrivate(cx, obj);
+        // default return value
+        printf("[JS]Setting smart copy mode(1)\n");
+        *rval = BOOLEAN_TO_JSVAL(false);
+        if(argc != 0)
+                return JS_FALSE;
+        printf("[JS]Setting smart copy mode (2)\n");
+        enterLock();
+        video_body->setEnv(ENV_EDITOR_SMART);
+        *rval = BOOLEAN_TO_JSVAL( true);
+        leaveLock();
+        return JS_TRUE;
+}
+JSBool ADM_JSAvidemux::setContainer(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+
+ADM_JSAvidemux *p = (ADM_JSAvidemux *)JS_GetPrivate(cx, obj);
+        // default return value
+        *rval = BOOLEAN_TO_JSVAL(false);
+        if(argc < 1 || argc > 2)
+                return JS_FALSE;
+        if(JSVAL_IS_STRING(argv[0]) == false)
+                return JS_FALSE;
+		if(argc == 2 && !JSVAL_IS_STRING(argv[1]))
+			return JS_FALSE;
+
+        char *str = JS_GetStringBytes(JSVAL_TO_STRING(argv[0]));
+        enterLock();
+		if(A_setContainer(str))
+		{
+			if (argc == 2)
+			{
+				const char *config = JS_GetStringBytes(JSVAL_TO_STRING(argv[1]));
+				ADM_OUT_FORMAT format = UI_GetCurrentFormat();
+
+				for (int i = 0; i < ADM_FORMAT_MAX; i++)
+				{
+					if (ADM_allOutputFormat[i].format == format)
+					{
+						int configLength = strlen(config);
+
+						if (ADM_allOutputFormat[i].configSize > 0 && configLength > 0)
+						{
+							uint8_t* currentConfig = (uint8_t*)ADM_allOutputFormat[i].currentConfig;
+							const char* configHexPtr = config;
+							int configByteCount = 0;
+
+							memcpy(ADM_allOutputFormat[i].currentConfig, ADM_allOutputFormat[i].defaultConfig, ADM_allOutputFormat[i].configSize);
+
+							while ((configHexPtr - config) < configLength && configByteCount < ADM_allOutputFormat[i].configSize)
+							{
+								currentConfig[configByteCount] = mk_hex(*configHexPtr, *(configHexPtr + 1));
+								configHexPtr += 3;
+								configByteCount += 1;
+							}
+						}
+
+						break;
+					}
+				}
+			}
+
+			*rval = BOOLEAN_TO_JSVAL(true);
+		}
+        leaveLock();
+        return JS_TRUE;
+}
+uint8_t A_setContainer(const char *cont)
+{
+       for(int i=0;i<NB_CONT;i++)
+       {
+                printf("%s\n",container[i].name);
+                if(!strcasecmp(cont,container[i].name))
+                {
+                        UI_SetCurrentFormat(container[i].type);
+                        return 1;
+                }
+       }
+       printf("Cannot set output format \"%s\"\n",cont);
+       return 0;
+}
+
+const char *getCurrentContainerAsString(void)
+{
+        ADM_OUT_FORMAT cont=UI_GetCurrentFormat();
+        for(int i=0;i<sizeof(container)/sizeof(ADM_CONTAINER);i++)
+        {
+                if(container[i].type==cont) 
+                        return container[i].name;
+        }
+        ADM_assert(0);
+        return NULL;
+
+}

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2/GUI_bindings.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2/GUI_bindings.cpp	2010-01-01 18:40:56 UTC (rev 5804)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2/GUI_bindings.cpp	2010-01-02 12:45:44 UTC (rev 5805)
@@ -177,6 +177,7 @@
 	{"buttonAudioFilter"		,"clicked"		,ACT_AudioFilters},
 	{"buttonConfV"			,"clicked"		,ACT_VideoCodec},
 	{"buttonConfA"			,"clicked"		,ACT_AudioCodec},
+	{"buttonConfM"			,"clicked"		,ACT_SetMuxParam},
 
 	{"buttonPrevBlack"		,"clicked"		,ACT_PrevBlackFrame},
 	{"buttonNextBlack"		,"clicked"		,ACT_NextBlackFrame},
@@ -1044,9 +1045,20 @@
         {
           gtk_widget_set_sensitive(lookup_widget(guiRootWindow,VIDEO_WIDGET),0);  
           
-        }else
+        }
+		else
         {
-          gtk_widget_set_sensitive(lookup_widget(guiRootWindow,VIDEO_WIDGET),1);  
+          gtk_widget_set_sensitive(lookup_widget(guiRootWindow,VIDEO_WIDGET),1);
+
+			for (int i = 0; i < ADM_FORMAT_MAX; i++)
+			{
+				if (ADM_allOutputFormat[i].format == fmt)
+				{
+					gtk_widget_set_sensitive(lookup_widget(guiRootWindow, "buttonConfM"), ADM_allOutputFormat[i].muxerConfigure != NULL);
+
+					break;
+				}
+			}
         }
 
 }

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2/GUI_main2.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2/GUI_main2.cpp	2010-01-01 18:40:56 UTC (rev 5804)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2/GUI_main2.cpp	2010-01-02 12:45:44 UTC (rev 5805)
@@ -216,7 +216,9 @@
   GtkWidget *vbox13;
   GtkWidget *label20;
   GtkWidget *alignment14;
+  GtkWidget *vbox15;
   GtkWidget *comboboxFormat;
+  GtkWidget *buttonConfM;
   GtkWidget *guiDrawing;
   GtkWidget *table2;
   GtkWidget *hbox16;
@@ -1171,7 +1173,7 @@
   gtk_widget_show (label23);
   gtk_box_pack_start (GTK_BOX (hbox19), label23, FALSE, FALSE, 0);
 
-  vbox13 = gtk_vbox_new (FALSE, 0);
+  vbox13 = gtk_vbox_new (FALSE, 4);
   gtk_widget_show (vbox13);
   gtk_box_pack_start (GTK_BOX (vbox9), vbox13, FALSE, FALSE, 0);
 
@@ -1186,10 +1188,18 @@
   gtk_box_pack_start (GTK_BOX (vbox13), alignment14, TRUE, TRUE, 0);
   gtk_alignment_set_padding (GTK_ALIGNMENT (alignment14), 3, 0, 12, 0);
 
+  vbox15 = gtk_vbox_new (FALSE, 4);
+  gtk_widget_show (vbox15);
+  gtk_container_add (GTK_CONTAINER (alignment14), vbox15);
+
   comboboxFormat = gtk_combo_box_new_text ();
   gtk_widget_show (comboboxFormat);
-  gtk_container_add (GTK_CONTAINER (alignment14), comboboxFormat);
+  gtk_box_pack_start (GTK_BOX (vbox15), comboboxFormat, TRUE, TRUE, 0);
 
+  buttonConfM = gtk_button_new_with_mnemonic (QT_TR_NOOP("Configure"));
+  gtk_widget_show (buttonConfM);
+  gtk_box_pack_start (GTK_BOX (vbox15), buttonConfM, FALSE, FALSE, 0);
+
   guiDrawing = gtk_drawing_area_new ();
   gtk_widget_show (guiDrawing);
   gtk_box_pack_start (GTK_BOX (hbox14), guiDrawing, TRUE, TRUE, 0);
@@ -1474,7 +1484,8 @@
   GTK_WIDGET_SET_FLAGS (labelMarkA, GTK_CAN_FOCUS);
   gtk_label_set_selectable (GTK_LABEL (labelMarkA), TRUE);
 
-  jogg = jog_shuttle_new ();gtk_widget_set_size_request (jogg, -1, 16); 
+  jogg = jog_shuttle_new ();
+  gtk_widget_set_size_request (jogg, -1, 16); 
   gtk_widget_show (jogg);
   gtk_table_attach (GTK_TABLE (table2), jogg, 1, 2, 0, 1,
                     (GtkAttachOptions) (GTK_FILL),
@@ -1670,7 +1681,9 @@
   GLADE_HOOKUP_OBJECT (mainWindow, vbox13, "vbox13");
   GLADE_HOOKUP_OBJECT (mainWindow, label20, "label20");
   GLADE_HOOKUP_OBJECT (mainWindow, alignment14, "alignment14");
+  GLADE_HOOKUP_OBJECT (mainWindow, vbox15, "vbox15");
   GLADE_HOOKUP_OBJECT (mainWindow, comboboxFormat, "comboboxFormat");
+  GLADE_HOOKUP_OBJECT (mainWindow, buttonConfM, "buttonConfM");
   GLADE_HOOKUP_OBJECT (mainWindow, guiDrawing, "guiDrawing");
   GLADE_HOOKUP_OBJECT (mainWindow, table2, "table2");
   GLADE_HOOKUP_OBJECT (mainWindow, hbox16, "hbox16");

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2/GUI_menumap.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2/GUI_menumap.h	2010-01-01 18:40:56 UTC (rev 5804)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2/GUI_menumap.h	2010-01-02 12:45:44 UTC (rev 5805)
@@ -18,7 +18,6 @@
 CALLBACK( append_video1     			,ACT_AppendAvi);
 CALLBACK( save_audio1         			,ACT_SaveWave);
 CALLBACK( save_as_avi1       			,ACT_SaveAvi);
-CALLBACK(avi_muxer_options1 			,ACT_SetMuxParam);
 
 //CALLBACK(load_project         			,ACT_OpenAvi); 
 CALLBACK(save_project_as1              		,ACT_SaveWork);

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/glade/gtk2_build.glade
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/glade/gtk2_build.glade	2010-01-01 18:40:56 UTC (rev 5804)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/glade/gtk2_build.glade	2010-01-02 12:45:44 UTC (rev 5805)
@@ -1,2664 +1,2693 @@
-<?xml version="1.0" standalone="no"?> <!--*- mode: xml -*-->
-<!DOCTYPE glade-interface SYSTEM "http://glade.gnome.org/glade-2.0.dtd">
-
-<glade-interface>
-
-<widget class="GtkWindow" id="mainWindow">
-  <property name="visible">True</property>
-  <property name="title" translatable="yes">Avidemux</property>
-  <property name="type">GTK_WINDOW_TOPLEVEL</property>
-  <property name="window_position">GTK_WIN_POS_NONE</property>
-  <property name="modal">False</property>
-  <property name="resizable">True</property>
-  <property name="destroy_with_parent">False</property>
-  <property name="icon">avidemux_icon_small.png</property>
-  <property name="decorated">True</property>
-  <property name="skip_taskbar_hint">False</property>
-  <property name="skip_pager_hint">False</property>
-  <property name="type_hint">GDK_WINDOW_TYPE_HINT_NORMAL</property>
-  <property name="gravity">GDK_GRAVITY_NORTH_WEST</property>
-  <property name="focus_on_map">True</property>
-
-  <child>
-    <widget class="GtkVBox" id="vbox1">
-      <property name="visible">True</property>
-      <property name="homogeneous">False</property>
-      <property name="spacing">0</property>
-
-      <child>
-	<widget class="GtkMenuBar" id="menuBar">
-	  <property name="visible">True</property>
-	  <property name="can_focus">True</property>
-
-	  <child>
-	    <widget class="GtkMenuItem" id="menuitem1">
-	      <property name="visible">True</property>
-	      <property name="label" translatable="yes">_File</property>
-	      <property name="use_underline">True</property>
-
-	      <child>
-		<widget class="GtkMenu" id="menuitem1_menu">
-
-		  <child>
-		    <widget class="GtkImageMenuItem" id="open_video1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">_Open...</property>
-		      <property name="use_underline">True</property>
-		      <accelerator key="O" modifiers="GDK_CONTROL_MASK" signal="activate"/>
-
-		      <child internal-child="image">
-			<widget class="GtkImage" id="image8523">
-			  <property name="visible">True</property>
-			  <property name="stock">gtk-open</property>
-			  <property name="icon_size">1</property>
-			  <property name="xalign">0.5</property>
-			  <property name="yalign">0.5</property>
-			  <property name="xpad">0</property>
-			  <property name="ypad">0</property>
-			</widget>
-		      </child>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkImageMenuItem" id="append_video1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">_Append...</property>
-		      <property name="use_underline">True</property>
-		      <accelerator key="A" modifiers="GDK_CONTROL_MASK | GDK_MOD1_MASK" signal="activate"/>
-
-		      <child internal-child="image">
-			<widget class="GtkImage" id="image8524">
-			  <property name="visible">True</property>
-			  <property name="stock">gtk-add</property>
-			  <property name="icon_size">1</property>
-			  <property name="xalign">0.5</property>
-			  <property name="yalign">0.5</property>
-			  <property name="xpad">0</property>
-			  <property name="ypad">0</property>
-			</widget>
-		      </child>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkImageMenuItem" id="save_stuff">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">_Save</property>
-		      <property name="use_underline">True</property>
-
-		      <child internal-child="image">
-			<widget class="GtkImage" id="image8525">
-			  <property name="visible">True</property>
-			  <property name="stock">gtk-save</property>
-			  <property name="icon_size">1</property>
-			  <property name="xalign">0.5</property>
-			  <property name="yalign">0.5</property>
-			  <property name="xpad">0</property>
-			  <property name="ypad">0</property>
-			</widget>
-		      </child>
-
-		      <child>
-			<widget class="GtkMenu" id="save_stuff_menu">
-
-			  <child>
-			    <widget class="GtkMenuItem" id="save_as_avi1">
-			      <property name="visible">True</property>
-			      <property name="label" translatable="yes">Save _Video...</property>
-			      <property name="use_underline">True</property>
-			      <accelerator key="S" modifiers="GDK_CONTROL_MASK" signal="activate"/>
-			    </widget>
-			  </child>
-
-			  <child>
-			    <widget class="GtkSeparatorMenuItem" id="separator1">
-			      <property name="visible">True</property>
-			    </widget>
-			  </child>
-
-			  <child>
-			    <widget class="GtkMenuItem" id="save_image1">
-			      <property name="visible">True</property>
-			      <property name="label" translatable="yes">Save _BMP Image...</property>
-			      <property name="use_underline">True</property>
-			    </widget>
-			  </child>
-
-			  <child>
-			    <widget class="GtkMenuItem" id="save_jpg_image1">
-			      <property name="visible">True</property>
-			      <property name="label" translatable="yes">Save _JPEG Image...</property>
-			      <property name="use_underline">True</property>
-			    </widget>
-			  </child>
-
-			  <child>
-			    <widget class="GtkMenuItem" id="save_selection_as_jpegs1">
-			      <property name="visible">True</property>
-			      <property name="label" translatable="yes">Save _Selection as JPEG Images...</property>
-			      <property name="use_underline">True</property>
-			    </widget>
-			  </child>
-			</widget>
-		      </child>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkImageMenuItem" id="close1">
-		      <property name="visible">True</property>
-		      <property name="label">gtk-close</property>
-		      <property name="use_stock">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkSeparatorMenuItem" id="separator3">
-		      <property name="visible">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkImageMenuItem" id="save_project1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Save _Project</property>
-		      <property name="use_underline">True</property>
-
-		      <child internal-child="image">
-			<widget class="GtkImage" id="image8526">
-			  <property name="visible">True</property>
-			  <property name="stock">gtk-save</property>
-			  <property name="icon_size">1</property>
-			  <property name="xalign">0.5</property>
-			  <property name="yalign">0.5</property>
-			  <property name="xpad">0</property>
-			  <property name="ypad">0</property>
-			</widget>
-		      </child>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkImageMenuItem" id="save_project_as1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Save P_roject As...</property>
-		      <property name="use_underline">True</property>
-
-		      <child internal-child="image">
-			<widget class="GtkImage" id="image8527">
-			  <property name="visible">True</property>
-			  <property name="stock">gtk-save-as</property>
-			  <property name="icon_size">1</property>
-			  <property name="xalign">0.5</property>
-			  <property name="yalign">0.5</property>
-			  <property name="xpad">0</property>
-			  <property name="ypad">0</property>
-			</widget>
-		      </child>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkImageMenuItem" id="run_script1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">_Load/Run Project...</property>
-		      <property name="use_underline">True</property>
-
-		      <child internal-child="image">
-			<widget class="GtkImage" id="image8528">
-			  <property name="visible">True</property>
-			  <property name="stock">gtk-execute</property>
-			  <property name="icon_size">1</property>
-			  <property name="xalign">0.5</property>
-			  <property name="yalign">0.5</property>
-			  <property name="xpad">0</property>
-			  <property name="ypad">0</property>
-			</widget>
-		      </child>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="add_to_joblist1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">A_dd to Joblist...</property>
-		      <property name="use_underline">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="joblist1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Show _Joblist</property>
-		      <property name="use_underline">True</property>
-		      <accelerator key="J" modifiers="GDK_CONTROL_MASK" signal="activate"/>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkSeparatorMenuItem" id="separator16">
-		      <property name="visible">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="connect_to_avsproxy1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Co_nnect to avsproxy</property>
-		      <property name="use_underline">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkSeparatorMenuItem" id="separator18">
-		      <property name="visible">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkImageMenuItem" id="video_informations1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Proper_ties</property>
-		      <property name="use_underline">True</property>
-		      <accelerator key="Return" modifiers="GDK_MOD1_MASK" signal="activate"/>
-
-		      <child internal-child="image">
-			<widget class="GtkImage" id="image8529">
-			  <property name="visible">True</property>
-			  <property name="stock">gtk-properties</property>
-			  <property name="icon_size">1</property>
-			  <property name="xalign">0.5</property>
-			  <property name="yalign">0.5</property>
-			  <property name="xpad">0</property>
-			  <property name="ypad">0</property>
-			</widget>
-		      </child>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="avi_muxer_options1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">AVI _Muxer Options</property>
-		      <property name="use_underline">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkSeparatorMenuItem" id="separator4">
-		      <property name="visible">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkImageMenuItem" id="quit1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">_Quit</property>
-		      <property name="use_underline">True</property>
-		      <accelerator key="Q" modifiers="GDK_CONTROL_MASK" signal="activate"/>
-
-		      <child internal-child="image">
-			<widget class="GtkImage" id="image8530">
-			  <property name="visible">True</property>
-			  <property name="stock">gtk-quit</property>
-			  <property name="icon_size">1</property>
-			  <property name="xalign">0.5</property>
-			  <property name="yalign">0.5</property>
-			  <property name="xpad">0</property>
-			  <property name="ypad">0</property>
-			</widget>
-		      </child>
-		    </widget>
-		  </child>
-		</widget>
-	      </child>
-	    </widget>
-	  </child>
-
-	  <child>
-	    <widget class="GtkMenuItem" id="menuitem2">
-	      <property name="visible">True</property>
-	      <property name="label" translatable="yes">_Edit</property>
-	      <property name="use_underline">True</property>
-
-	      <child>
-		<widget class="GtkMenu" id="menuitem2_menu">
-
-		  <child>
-		    <widget class="GtkImageMenuItem" id="reset_edits1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">_Reset Edits</property>
-		      <property name="use_underline">True</property>
-
-		      <child internal-child="image">
-			<widget class="GtkImage" id="image8531">
-			  <property name="visible">True</property>
-			  <property name="stock">gtk-undo</property>
-			  <property name="icon_size">1</property>
-			  <property name="xalign">0.5</property>
-			  <property name="yalign">0.5</property>
-			  <property name="xpad">0</property>
-			  <property name="ypad">0</property>
-			</widget>
-		      </child>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkSeparatorMenuItem" id="separator5">
-		      <property name="visible">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkImageMenuItem" id="cut1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Cu_t</property>
-		      <property name="use_underline">True</property>
-		      <accelerator key="X" modifiers="GDK_CONTROL_MASK" signal="activate"/>
-
-		      <child internal-child="image">
-			<widget class="GtkImage" id="image8532">
-			  <property name="visible">True</property>
-			  <property name="stock">gtk-cut</property>
-			  <property name="icon_size">1</property>
-			  <property name="xalign">0.5</property>
-			  <property name="yalign">0.5</property>
-			  <property name="xpad">0</property>
-			  <property name="ypad">0</property>
-			</widget>
-		      </child>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkImageMenuItem" id="copy1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">_Copy</property>
-		      <property name="use_underline">True</property>
-		      <accelerator key="C" modifiers="GDK_CONTROL_MASK" signal="activate"/>
-
-		      <child internal-child="image">
-			<widget class="GtkImage" id="image8533">
-			  <property name="visible">True</property>
-			  <property name="stock">gtk-copy</property>
-			  <property name="icon_size">1</property>
-			  <property name="xalign">0.5</property>
-			  <property name="yalign">0.5</property>
-			  <property name="xpad">0</property>
-			  <property name="ypad">0</property>
-			</widget>
-		      </child>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkImageMenuItem" id="paste1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">_Paste</property>
-		      <property name="use_underline">True</property>
-		      <accelerator key="V" modifiers="GDK_CONTROL_MASK" signal="activate"/>
-
-		      <child internal-child="image">
-			<widget class="GtkImage" id="image8534">
-			  <property name="visible">True</property>
-			  <property name="stock">gtk-paste</property>
-			  <property name="icon_size">1</property>
-			  <property name="xalign">0.5</property>
-			  <property name="yalign">0.5</property>
-			  <property name="xpad">0</property>
-			  <property name="ypad">0</property>
-			</widget>
-		      </child>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkImageMenuItem" id="delete1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">_Delete</property>
-		      <property name="use_underline">True</property>
-		      <accelerator key="Delete" modifiers="0" signal="activate"/>
-
-		      <child internal-child="image">
-			<widget class="GtkImage" id="image8535">
-			  <property name="visible">True</property>
-			  <property name="stock">gtk-remove</property>
-			  <property name="icon_size">1</property>
-			  <property name="xalign">0.5</property>
-			  <property name="yalign">0.5</property>
-			  <property name="xpad">0</property>
-			  <property name="ypad">0</property>
-			</widget>
-		      </child>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkSeparatorMenuItem" id="separator6">
-		      <property name="visible">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="set_marker_a1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Set Marker _A</property>
-		      <property name="use_underline">True</property>
-		      <accelerator key="bracketleft" modifiers="0" signal="activate"/>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="set_marker_b1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Set Marker _B</property>
-		      <property name="use_underline">True</property>
-		      <accelerator key="bracketright" modifiers="0" signal="activate"/>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkSeparatorMenuItem" id="separator7">
-		      <property name="visible">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkImageMenuItem" id="preferences1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Pre_ferences</property>
-		      <property name="use_underline">True</property>
-
-		      <child internal-child="image">
-			<widget class="GtkImage" id="image8536">
-			  <property name="visible">True</property>
-			  <property name="stock">gtk-preferences</property>
-			  <property name="icon_size">1</property>
-			  <property name="xalign">0.5</property>
-			  <property name="yalign">0.5</property>
-			  <property name="xpad">0</property>
-			  <property name="ypad">0</property>
-			</widget>
-		      </child>
-		    </widget>
-		  </child>
-		</widget>
-	      </child>
-	    </widget>
-	  </child>
-
-	  <child>
-	    <widget class="GtkMenuItem" id="view1">
-	      <property name="visible">True</property>
-	      <property name="label" translatable="yes">_View</property>
-	      <property name="use_underline">True</property>
-
-	      <child>
-		<widget class="GtkMenu" id="view1_menu">
-
-		  <child>
-		    <widget class="GtkCheckMenuItem" id="toolbar1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">_Main Toolbar</property>
-		      <property name="use_underline">True</property>
-		      <property name="active">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkCheckMenuItem" id="sidebar1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">_A/V Sidebar</property>
-		      <property name="use_underline">True</property>
-		      <property name="active">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkSeparatorMenuItem" id="separator8">
-		      <property name="visible">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="zoom_1_4">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">_Zoom 1:4</property>
-		      <property name="use_underline">True</property>
-		      <accelerator key="4" modifiers="GDK_CONTROL_MASK | GDK_SHIFT_MASK" signal="activate"/>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="zoom_1_2">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Z_oom 1:2</property>
-		      <property name="use_underline">True</property>
-		      <accelerator key="2" modifiers="GDK_CONTROL_MASK | GDK_SHIFT_MASK" signal="activate"/>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="zoom_1_1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Zoom _1:1</property>
-		      <property name="use_underline">True</property>
-		      <accelerator key="1" modifiers="GDK_CONTROL_MASK | GDK_MOD1_MASK" signal="activate"/>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="zoom_2_1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Zoom _2:1</property>
-		      <property name="use_underline">True</property>
-		      <accelerator key="2" modifiers="GDK_CONTROL_MASK | GDK_MOD1_MASK" signal="activate"/>
-		    </widget>
-		  </child>
-		</widget>
-	      </child>
-	    </widget>
-	  </child>
-
-	  <child>
-	    <widget class="GtkMenuItem" id="video_1">
-	      <property name="visible">True</property>
-	      <property name="label" translatable="yes">Vi_deo</property>
-	      <property name="use_underline">True</property>
-
-	      <child>
-		<widget class="GtkMenu" id="video_1_menu">
-
-		  <child>
-		    <widget class="GtkMenuItem" id="decoder_options1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">_Decoder Options</property>
-		      <property name="use_underline">True</property>
-		      <accelerator key="F3" modifiers="0" signal="activate"/>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="set_postprocessing1">
-		      <property name="visible">True</property>
-		      <property name="tooltip" translatable="yes">Select postprocessing level</property>
-		      <property name="label" translatable="yes">_Postprocessing</property>
-		      <property name="use_underline">True</property>
-		      <accelerator key="F4" modifiers="0" signal="activate"/>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkSeparatorMenuItem" id="separator9">
-		      <property name="visible">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkCheckMenuItem" id="preview1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">P_review</property>
-		      <property name="use_underline">True</property>
-		      <property name="active">False</property>
-		      <accelerator key="F5" modifiers="0" signal="activate"/>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkCheckMenuItem" id="display_output1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Display _Output</property>
-		      <property name="use_underline">True</property>
-		      <property name="active">False</property>
-		      <accelerator key="F6" modifiers="0" signal="activate"/>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkSeparatorMenuItem" id="separator10">
-		      <property name="visible">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="change_fps">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">_Frame Rate</property>
-		      <property name="use_underline">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="videoencoder">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">_Encoder</property>
-		      <property name="use_underline">True</property>
-		      <accelerator key="V" modifiers="GDK_CONTROL_MASK | GDK_MOD1_MASK" signal="activate"/>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="filters1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Fil_ters</property>
-		      <property name="use_underline">True</property>
-		      <accelerator key="F" modifiers="GDK_CONTROL_MASK | GDK_MOD1_MASK" signal="activate"/>
-		    </widget>
-		  </child>
-		</widget>
-	      </child>
-	    </widget>
-	  </child>
-
-	  <child>
-	    <widget class="GtkMenuItem" id="audio1">
-	      <property name="visible">True</property>
-	      <property name="label" translatable="yes">_Audio</property>
-	      <property name="use_underline">True</property>
-
-	      <child>
-		<widget class="GtkMenu" id="audio1_menu">
-
-		  <child>
-		    <widget class="GtkMenuItem" id="main_audio">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">_Main Track</property>
-		      <property name="use_underline">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="second_audio_track1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">_Second Track</property>
-		      <property name="use_underline">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="build_vbr_time_map1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">_Build VBR Time Map</property>
-		      <property name="use_underline">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkSeparatorMenuItem" id="separator11">
-		      <property name="visible">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkImageMenuItem" id="save_audio1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">S_ave...</property>
-		      <property name="use_underline">True</property>
-		      <accelerator key="S" modifiers="GDK_CONTROL_MASK | GDK_MOD1_MASK" signal="activate"/>
-
-		      <child internal-child="image">
-			<widget class="GtkImage" id="image8537">
-			  <property name="visible">True</property>
-			  <property name="stock">gtk-save-as</property>
-			  <property name="icon_size">1</property>
-			  <property name="xalign">0.5</property>
-			  <property name="yalign">0.5</property>
-			  <property name="xpad">0</property>
-			  <property name="ypad">0</property>
-			</widget>
-		      </child>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="audio_encoder1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">_Encoder</property>
-		      <property name="use_underline">True</property>
-		      <accelerator key="A" modifiers="GDK_CONTROL_MASK | GDK_MOD1_MASK" signal="activate"/>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="filters2">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">_Filters</property>
-		      <property name="use_underline">True</property>
-		    </widget>
-		  </child>
-		</widget>
-	      </child>
-	    </widget>
-	  </child>
-
-	  <child>
-	    <widget class="GtkMenuItem" id="tools1">
-	      <property name="visible">True</property>
-	      <property name="label" translatable="yes">_Tools</property>
-	      <property name="use_underline">True</property>
-
-	      <child>
-		<widget class="GtkMenu" id="tools1_menu">
-
-		  <child>
-		    <widget class="GtkImageMenuItem" id="calculator1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">_Calculator</property>
-		      <property name="use_underline">True</property>
-		      <accelerator key="F7" modifiers="0" signal="activate"/>
-
-		      <child internal-child="image">
-			<widget class="GtkImage" id="image8538">
-			  <property name="visible">True</property>
-			  <property name="pixbuf">gnome-calculator_small.xpm</property>
-			  <property name="xalign">0.5</property>
-			  <property name="yalign">0.5</property>
-			  <property name="xpad">0</property>
-			  <property name="ypad">0</property>
-			</widget>
-		      </child>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkSeparatorMenuItem" id="separator12">
-		      <property name="visible">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="rebuild_frames">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">_Rebuild Frames (I &amp; B)</property>
-		      <property name="use_underline">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="check_frames">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">C_heck Frames (slow)</property>
-		      <property name="use_underline">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="bitrate_histogram1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">_Bitrate Histogram</property>
-		      <property name="use_underline">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="item1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">_Scan for Black Frames...</property>
-		      <property name="use_underline">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkSeparatorMenuItem" id="separator13">
-		      <property name="visible">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="v2v">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">_VOB -&gt; VobSub</property>
-		      <property name="use_underline">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="ocr_vobsub_2_srt">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">_OCR (VobSub -&gt; srt)</property>
-		      <property name="use_underline">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="ocr_dvb">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">OCR (TS-&gt;srt)</property>
-		      <property name="use_underline">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="edit_glyph1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">_Edit Glyph</property>
-		      <property name="use_underline">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkSeparatorMenuItem" id="separator17">
-		      <property name="visible">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="see_hex1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">_Frame Hex Dump</property>
-		      <property name="use_underline">True</property>
-		    </widget>
-		  </child>
-		</widget>
-	      </child>
-	    </widget>
-	  </child>
-
-	  <child>
-	    <widget class="GtkMenuItem" id="help1">
-	      <property name="visible">True</property>
-	      <property name="label" translatable="yes">A_uto</property>
-	      <property name="use_underline">True</property>
-
-	      <child>
-		<widget class="GtkMenu" id="help1_menu">
-
-		  <child>
-		    <widget class="GtkMenuItem" id="vcd1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">_VCD</property>
-		      <property name="use_underline">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="svcd1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">_SVCD</property>
-		      <property name="use_underline">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="dvd1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">_DVD</property>
-		      <property name="use_underline">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="psp1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">_PSP</property>
-		      <property name="use_underline">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="psp_(h264)1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">PSP (_H.264)</property>
-		      <property name="use_underline">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="flv1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">F_LV</property>
-		      <property name="use_underline">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="Ipod">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">IPOD (mpeg4)</property>
-		      <property name="use_underline">True</property>
-		    </widget>
-		  </child>
-		</widget>
-	      </child>
-	    </widget>
-	  </child>
-
-	  <child>
-	    <widget class="GtkMenuItem" id="go1">
-	      <property name="visible">True</property>
-	      <property name="label" translatable="yes">_Go</property>
-	      <property name="use_underline">True</property>
-
-	      <child>
-		<widget class="GtkMenu" id="go1_menu">
-
-		  <child>
-		    <widget class="GtkImageMenuItem" id="play_video1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">_Play/Stop</property>
-		      <property name="use_underline">True</property>
-		      <accelerator key="P" modifiers="0" signal="activate"/>
-
-		      <child internal-child="image">
-			<widget class="GtkImage" id="image8539">
-			  <property name="visible">True</property>
-			  <property name="stock">gtk-media-play</property>
-			  <property name="icon_size">1</property>
-			  <property name="xalign">0.5</property>
-			  <property name="yalign">0.5</property>
-			  <property name="xpad">0</property>
-			  <property name="ypad">0</property>
-			</widget>
-		      </child>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkImageMenuItem" id="previous_frame1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">P_revious Frame</property>
-		      <property name="use_underline">True</property>
-		      <accelerator key="KP_4" modifiers="0" signal="activate"/>
-
-		      <child internal-child="image">
-			<widget class="GtkImage" id="image8540">
-			  <property name="visible">True</property>
-			  <property name="stock">gtk-media-previous</property>
-			  <property name="icon_size">1</property>
-			  <property name="xalign">0.5</property>
-			  <property name="yalign">0.5</property>
-			  <property name="xpad">0</property>
-			  <property name="ypad">0</property>
-			</widget>
-		      </child>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkImageMenuItem" id="next_frame1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">_Next Frame</property>
-		      <property name="use_underline">True</property>
-		      <accelerator key="KP_6" modifiers="0" signal="activate"/>
-
-		      <child internal-child="image">
-			<widget class="GtkImage" id="image8541">
-			  <property name="visible">True</property>
-			  <property name="stock">gtk-media-next</property>
-			  <property name="icon_size">1</property>
-			  <property name="xalign">0.5</property>
-			  <property name="yalign">0.5</property>
-			  <property name="xpad">0</property>
-			  <property name="ypad">0</property>
-			</widget>
-		      </child>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkImageMenuItem" id="previous_intra_frame1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Pr_evious Intra Frame</property>
-		      <property name="use_underline">True</property>
-		      <accelerator key="KP_2" modifiers="0" signal="activate"/>
-
-		      <child internal-child="image">
-			<widget class="GtkImage" id="image8542">
-			  <property name="visible">True</property>
-			  <property name="stock">gtk-media-rewind</property>
-			  <property name="icon_size">1</property>
-			  <property name="xalign">0.5</property>
-			  <property name="yalign">0.5</property>
-			  <property name="xpad">0</property>
-			  <property name="ypad">0</property>
-			</widget>
-		      </child>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkImageMenuItem" id="next_intra_frame1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Next _Intra Frame</property>
-		      <property name="use_underline">True</property>
-		      <accelerator key="KP_8" modifiers="0" signal="activate"/>
-
-		      <child internal-child="image">
-			<widget class="GtkImage" id="image8543">
-			  <property name="visible">True</property>
-			  <property name="stock">gtk-media-forward</property>
-			  <property name="icon_size">1</property>
-			  <property name="xalign">0.5</property>
-			  <property name="yalign">0.5</property>
-			  <property name="xpad">0</property>
-			  <property name="ypad">0</property>
-			</widget>
-		      </child>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="search_previous_black_frame1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Previou_s Black Frame</property>
-		      <property name="use_underline">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="search_next_black_frame1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Ne_xt Black Frame</property>
-		      <property name="use_underline">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkImageMenuItem" id="first_frame1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">_First Frame</property>
-		      <property name="use_underline">True</property>
-		      <accelerator key="Home" modifiers="0" signal="activate"/>
-
-		      <child internal-child="image">
-			<widget class="GtkImage" id="image8544">
-			  <property name="visible">True</property>
-			  <property name="stock">gtk-goto-first</property>
-			  <property name="icon_size">1</property>
-			  <property name="xalign">0.5</property>
-			  <property name="yalign">0.5</property>
-			  <property name="xpad">0</property>
-			  <property name="ypad">0</property>
-			</widget>
-		      </child>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkImageMenuItem" id="last_frame1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">_Last Frame</property>
-		      <property name="use_underline">True</property>
-		      <accelerator key="End" modifiers="0" signal="activate"/>
-
-		      <child internal-child="image">
-			<widget class="GtkImage" id="image8545">
-			  <property name="visible">True</property>
-			  <property name="stock">gtk-goto-last</property>
-			  <property name="icon_size">1</property>
-			  <property name="xalign">0.5</property>
-			  <property name="yalign">0.5</property>
-			  <property name="xpad">0</property>
-			  <property name="ypad">0</property>
-			</widget>
-		      </child>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkSeparatorMenuItem" id="separator14">
-		      <property name="visible">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="go_to_marker_a1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Go to Marker _A</property>
-		      <property name="use_underline">True</property>
-		      <accelerator key="bracketleft" modifiers="GDK_CONTROL_MASK" signal="activate"/>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="go_to_marker_b1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Go to Marker _B</property>
-		      <property name="use_underline">True</property>
-		      <accelerator key="bracketright" modifiers="GDK_CONTROL_MASK" signal="activate"/>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkSeparatorMenuItem" id="separator15">
-		      <property name="visible">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkImageMenuItem" id="jum_to_frame1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Go to Fra_me...</property>
-		      <property name="use_underline">True</property>
-		      <accelerator key="F" modifiers="GDK_CONTROL_MASK" signal="activate"/>
-
-		      <child internal-child="image">
-			<widget class="GtkImage" id="image8546">
-			  <property name="visible">True</property>
-			  <property name="stock">gtk-jump-to</property>
-			  <property name="icon_size">1</property>
-			  <property name="xalign">0.5</property>
-			  <property name="yalign">0.5</property>
-			  <property name="xpad">0</property>
-			  <property name="ypad">0</property>
-			</widget>
-		      </child>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkImageMenuItem" id="jump_to_time1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Go to _Time...</property>
-		      <property name="use_underline">True</property>
-		      <accelerator key="T" modifiers="GDK_CONTROL_MASK" signal="activate"/>
-
-		      <child internal-child="image">
-			<widget class="GtkImage" id="image8547">
-			  <property name="visible">True</property>
-			  <property name="stock">gtk-jump-to</property>
-			  <property name="icon_size">1</property>
-			  <property name="xalign">0.5</property>
-			  <property name="yalign">0.5</property>
-			  <property name="xpad">0</property>
-			  <property name="ypad">0</property>
-			</widget>
-		      </child>
-		    </widget>
-		  </child>
-		</widget>
-	      </child>
-	    </widget>
-	  </child>
-
-	  <child>
-	    <widget class="GtkMenuItem" id="custom1">
-	      <property name="visible">True</property>
-	      <property name="label" translatable="yes">_Custom</property>
-	      <property name="use_underline">True</property>
-	    </widget>
-	  </child>
-
-	  <child>
-	    <widget class="GtkMenuItem" id="help2">
-	      <property name="visible">True</property>
-	      <property name="label" translatable="yes">_Help</property>
-	      <property name="use_underline">True</property>
-
-	      <child>
-		<widget class="GtkMenu" id="help2_menu">
-
-		  <child>
-		    <widget class="GtkMenuItem" id="plugins1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">_Plugins</property>
-		      <property name="use_underline">True</property>
-		      <signal name="activate" handler="on_plugins1_activate" last_modification_time="Sat, 21 Jun 2008 18:24:10 GMT"/>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="show_builtin_support1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">_Built-in Support</property>
-		      <property name="use_underline">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkImageMenuItem" id="about1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">_About</property>
-		      <property name="use_underline">True</property>
-
-		      <child internal-child="image">
-			<widget class="GtkImage" id="image8548">
-			  <property name="visible">True</property>
-			  <property name="stock">gtk-about</property>
-			  <property name="icon_size">1</property>
-			  <property name="xalign">0.5</property>
-			  <property name="yalign">0.5</property>
-			  <property name="xpad">0</property>
-			  <property name="ypad">0</property>
-			</widget>
-		      </child>
-		    </widget>
-		  </child>
-		</widget>
-	      </child>
-	    </widget>
-	  </child>
-	</widget>
-	<packing>
-	  <property name="padding">0</property>
-	  <property name="expand">False</property>
-	  <property name="fill">False</property>
-	</packing>
-      </child>
-
-      <child>
-	<widget class="GtkToolbar" id="toolbar2">
-	  <property name="visible">True</property>
-	  <property name="orientation">GTK_ORIENTATION_HORIZONTAL</property>
-	  <property name="toolbar_style">GTK_TOOLBAR_BOTH_HORIZ</property>
-	  <property name="tooltips">True</property>
-	  <property name="show_arrow">True</property>
-
-	  <child>
-	    <widget class="GtkMenuToolButton" id="menutoolbuttonOpen">
-	      <property name="visible">True</property>
-	      <property name="tooltip" translatable="yes">Open a file</property>
-	      <property name="stock_id">gtk-open</property>
-	      <property name="visible_horizontal">True</property>
-	      <property name="visible_vertical">True</property>
-	      <property name="is_important">True</property>
-	    </widget>
-	    <packing>
-	      <property name="expand">False</property>
-	      <property name="homogeneous">False</property>
-	    </packing>
-	  </child>
-
-	  <child>
-	    <widget class="GtkToolItem" id="toolitem11">
-	      <property name="visible">True</property>
-	      <property name="visible_horizontal">True</property>
-	      <property name="visible_vertical">True</property>
-	      <property name="is_important">False</property>
-	    </widget>
-	    <packing>
-	      <property name="expand">False</property>
-	      <property name="homogeneous">False</property>
-	    </packing>
-	  </child>
-
-	  <child>
-	    <widget class="GtkToolButton" id="toolbuttonSave">
-	      <property name="visible">True</property>
-	      <property name="tooltip" translatable="yes">Save the file</property>
-	      <property name="stock_id">gtk-save</property>
-	      <property name="visible_horizontal">True</property>
-	      <property name="visible_vertical">True</property>
-	      <property name="is_important">True</property>
-	    </widget>
-	    <packing>
-	      <property name="expand">False</property>
-	      <property name="homogeneous">True</property>
-	    </packing>
-	  </child>
-
-	  <child>
-	    <widget class="GtkToolButton" id="toolbuttonInfo">
-	      <property name="visible">True</property>
-	      <property name="tooltip" translatable="yes">Audio/video file information</property>
-	      <property name="stock_id">gtk-properties</property>
-	      <property name="visible_horizontal">True</property>
-	      <property name="visible_vertical">True</property>
-	      <property name="is_important">False</property>
-	    </widget>
-	    <packing>
-	      <property name="expand">False</property>
-	      <property name="homogeneous">True</property>
-	    </packing>
-	  </child>
-
-	  <child>
-	    <widget class="GtkSeparatorToolItem" id="separatortoolitem1">
-	      <property name="visible">True</property>
-	      <property name="draw">True</property>
-	      <property name="visible_horizontal">True</property>
-	      <property name="visible_vertical">True</property>
-	    </widget>
-	    <packing>
-	      <property name="expand">False</property>
-	      <property name="homogeneous">False</property>
-	    </packing>
-	  </child>
-
-	  <child>
-	    <widget class="GtkToolButton" id="toolbuttonCalc">
-	      <property name="visible">True</property>
-	      <property name="tooltip" translatable="yes">Bitrate/size calculator</property>
-	      <property name="label" translatable="yes">Calculator</property>
-	      <property name="use_underline">True</property>
-	      <property name="icon">gnome-calculator.png</property>
-	      <property name="visible_horizontal">True</property>
-	      <property name="visible_vertical">True</property>
-	      <property name="is_important">True</property>
-	    </widget>
-	    <packing>
-	      <property name="expand">False</property>
-	      <property name="homogeneous">True</property>
-	    </packing>
-	  </child>
-
-	  <child>
-	    <widget class="GtkSeparatorToolItem" id="separatortoolitem2">
-	      <property name="visible">True</property>
-	      <property name="draw">True</property>
-	      <property name="visible_horizontal">True</property>
-	      <property name="visible_vertical">True</property>
-	    </widget>
-	    <packing>
-	      <property name="expand">False</property>
-	      <property name="homogeneous">False</property>
-	    </packing>
-	  </child>
-
-	  <child>
-	    <widget class="GtkToolItem" id="toolitem12">
-	      <property name="visible">True</property>
-	      <property name="visible_horizontal">True</property>
-	      <property name="visible_vertical">True</property>
-	      <property name="is_important">False</property>
-
-	      <child>
-		<widget class="GtkComboBox" id="comboboxPreview">
-		  <property name="visible">True</property>
-		  <property name="items" translatable="yes"></property>
-		  <property name="add_tearoffs">False</property>
-		  <property name="focus_on_click">True</property>
-		</widget>
-	      </child>
-	    </widget>
-	    <packing>
-	      <property name="expand">False</property>
-	      <property name="homogeneous">False</property>
-	    </packing>
-	  </child>
-
-	  <child>
-	    <widget class="GtkToolItem" id="toolitem13">
-	      <property name="visible">True</property>
-	      <property name="visible_horizontal">True</property>
-	      <property name="visible_vertical">True</property>
-	      <property name="is_important">False</property>
-
-	      <child>
-		<widget class="GtkToggleButton" id="togglebutton1">
-		  <property name="visible">True</property>
-		  <property name="can_focus">True</property>
-		  <property name="relief">GTK_RELIEF_NONE</property>
-		  <property name="focus_on_click">True</property>
-		  <property name="active">False</property>
-		  <property name="inconsistent">False</property>
-
-		  <child>
-		    <widget class="GtkImage" id="image8272">
-		      <property name="width_request">17</property>
-		      <property name="height_request">16</property>
-		      <property name="visible">True</property>
-		      <property name="pixbuf">audio-volume-medium.png</property>
-		      <property name="xalign">0.5</property>
-		      <property name="yalign">0.5</property>
-		      <property name="xpad">0</property>
-		      <property name="ypad">0</property>
-		    </widget>
-		  </child>
-		</widget>
-	      </child>
-	    </widget>
-	    <packing>
-	      <property name="expand">False</property>
-	      <property name="homogeneous">False</property>
-	    </packing>
-	  </child>
-
-	  <child>
-	    <widget class="GtkToolItem" id="toolitem14">
-	      <property name="visible">True</property>
-	      <property name="visible_horizontal">True</property>
-	      <property name="visible_vertical">True</property>
-	      <property name="is_important">False</property>
-
-	      <child>
-		<widget class="GtkHScale" id="hscalVolume">
-		  <property name="width_request">100</property>
-		  <property name="visible">True</property>
-		  <property name="can_focus">True</property>
-		  <property name="draw_value">False</property>
-		  <property name="value_pos">GTK_POS_TOP</property>
-		  <property name="digits">0</property>
-		  <property name="update_policy">GTK_UPDATE_CONTINUOUS</property>
-		  <property name="inverted">False</property>
-		  <property name="adjustment">99 0 100 1 1 0</property>
-		</widget>
-	      </child>
-	    </widget>
-	    <packing>
-	      <property name="expand">False</property>
-	      <property name="homogeneous">False</property>
-	    </packing>
-	  </child>
-	</widget>
-	<packing>
-	  <property name="padding">0</property>
-	  <property name="expand">False</property>
-	  <property name="fill">False</property>
-	</packing>
-      </child>
-
-      <child>
-	<widget class="GtkVBox" id="vbox10">
-	  <property name="visible">True</property>
-	  <property name="homogeneous">False</property>
-	  <property name="spacing">3</property>
-
-	  <child>
-	    <widget class="GtkHBox" id="hbox14">
-	      <property name="visible">True</property>
-	      <property name="homogeneous">False</property>
-	      <property name="spacing">0</property>
-
-	      <child>
-		<widget class="GtkAlignment" id="alignment19">
-		  <property name="visible">True</property>
-		  <property name="xalign">0.5</property>
-		  <property name="yalign">0.5</property>
-		  <property name="xscale">1</property>
-		  <property name="yscale">1</property>
-		  <property name="top_padding">3</property>
-		  <property name="bottom_padding">0</property>
-		  <property name="left_padding">3</property>
-		  <property name="right_padding">0</property>
-
-		  <child>
-		    <widget class="GtkVBox" id="vbox9">
-		      <property name="visible">True</property>
-		      <property name="homogeneous">False</property>
-		      <property name="spacing">9</property>
-
-		      <child>
-			<widget class="GtkVBox" id="vbox11">
-			  <property name="visible">True</property>
-			  <property name="homogeneous">False</property>
-			  <property name="spacing">0</property>
-
-			  <child>
-			    <widget class="GtkLabel" id="label18">
-			      <property name="visible">True</property>
-			      <property name="label" translatable="yes">&lt;b&gt;Video&lt;/b&gt;</property>
-			      <property name="use_underline">False</property>
-			      <property name="use_markup">True</property>
-			      <property name="justify">GTK_JUSTIFY_LEFT</property>
-			      <property name="wrap">False</property>
-			      <property name="selectable">False</property>
-			      <property name="xalign">0</property>
-			      <property name="yalign">0.5</property>
-			      <property name="xpad">0</property>
-			      <property name="ypad">0</property>
-			      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-			      <property name="width_chars">-1</property>
-			      <property name="single_line_mode">False</property>
-			      <property name="angle">0</property>
-			    </widget>
-			    <packing>
-			      <property name="padding">0</property>
-			      <property name="expand">False</property>
-			      <property name="fill">False</property>
-			    </packing>
-			  </child>
-
-			  <child>
-			    <widget class="GtkAlignment" id="alignment12">
-			      <property name="visible">True</property>
-			      <property name="xalign">0.5</property>
-			      <property name="yalign">0.5</property>
-			      <property name="xscale">1</property>
-			      <property name="yscale">1</property>
-			      <property name="top_padding">3</property>
-			      <property name="bottom_padding">0</property>
-			      <property name="left_padding">12</property>
-			      <property name="right_padding">0</property>
-
-			      <child>
-				<widget class="GtkVBox" id="vbox7">
-				  <property name="visible">True</property>
-				  <property name="homogeneous">False</property>
-				  <property name="spacing">3</property>
-
-				  <child>
-				    <widget class="GtkComboBox" id="comboboxVideo">
-				      <property name="visible">True</property>
-				      <property name="items" translatable="yes">Copy</property>
-				      <property name="add_tearoffs">False</property>
-				      <property name="focus_on_click">True</property>
-				    </widget>
-				    <packing>
-				      <property name="padding">0</property>
-				      <property name="expand">False</property>
-				      <property name="fill">False</property>
-				    </packing>
-				  </child>
-
-				  <child>
-				    <widget class="GtkButton" id="buttonConfV">
-				      <property name="visible">True</property>
-				      <property name="tooltip" translatable="yes">Configure video encoder</property>
-				      <property name="can_focus">True</property>
-				      <property name="label" translatable="yes">Configure</property>
-				      <property name="use_underline">True</property>
-				      <property name="relief">GTK_RELIEF_NORMAL</property>
-				      <property name="focus_on_click">True</property>
-				      <accelerator key="F3" modifiers="0" signal="clicked"/>
-				    </widget>
-				    <packing>
-				      <property name="padding">0</property>
-				      <property name="expand">False</property>
-				      <property name="fill">False</property>
-				    </packing>
-				  </child>
-
-				  <child>
-				    <widget class="GtkButton" id="buttonFilters">
-				      <property name="visible">True</property>
-				      <property name="tooltip" translatable="yes">Video filters</property>
-				      <property name="can_focus">True</property>
-				      <property name="label" translatable="yes">Filters</property>
-				      <property name="use_underline">True</property>
-				      <property name="relief">GTK_RELIEF_NORMAL</property>
-				      <property name="focus_on_click">True</property>
-				      <accelerator key="F1" modifiers="0" signal="clicked"/>
-				    </widget>
-				    <packing>
-				      <property name="padding">0</property>
-				      <property name="expand">False</property>
-				      <property name="fill">False</property>
-				    </packing>
-				  </child>
-				</widget>
-			      </child>
-			    </widget>
-			    <packing>
-			      <property name="padding">0</property>
-			      <property name="expand">True</property>
-			      <property name="fill">True</property>
-			    </packing>
-			  </child>
-			</widget>
-			<packing>
-			  <property name="padding">0</property>
-			  <property name="expand">False</property>
-			  <property name="fill">False</property>
-			</packing>
-		      </child>
-
-		      <child>
-			<widget class="GtkVBox" id="vbox12">
-			  <property name="visible">True</property>
-			  <property name="homogeneous">False</property>
-			  <property name="spacing">0</property>
-
-			  <child>
-			    <widget class="GtkLabel" id="label19">
-			      <property name="visible">True</property>
-			      <property name="label" translatable="yes">&lt;b&gt;Audio&lt;/b&gt;</property>
-			      <property name="use_underline">False</property>
-			      <property name="use_markup">True</property>
-			      <property name="justify">GTK_JUSTIFY_LEFT</property>
-			      <property name="wrap">False</property>
-			      <property name="selectable">False</property>
-			      <property name="xalign">0</property>
-			      <property name="yalign">0.5</property>
-			      <property name="xpad">0</property>
-			      <property name="ypad">0</property>
-			      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-			      <property name="width_chars">-1</property>
-			      <property name="single_line_mode">False</property>
-			      <property name="angle">0</property>
-			    </widget>
-			    <packing>
-			      <property name="padding">0</property>
-			      <property name="expand">False</property>
-			      <property name="fill">False</property>
-			    </packing>
-			  </child>
-
-			  <child>
-			    <widget class="GtkAlignment" id="alignment13">
-			      <property name="visible">True</property>
-			      <property name="xalign">0.5</property>
-			      <property name="yalign">0.5</property>
-			      <property name="xscale">1</property>
-			      <property name="yscale">1</property>
-			      <property name="top_padding">3</property>
-			      <property name="bottom_padding">0</property>
-			      <property name="left_padding">12</property>
-			      <property name="right_padding">0</property>
-
-			      <child>
-				<widget class="GtkVBox" id="vbox8">
-				  <property name="visible">True</property>
-				  <property name="homogeneous">False</property>
-				  <property name="spacing">3</property>
-
-				  <child>
-				    <widget class="GtkComboBox" id="comboboxAudio">
-				      <property name="visible">True</property>
-				      <property name="items" translatable="yes">Copy</property>
-				      <property name="add_tearoffs">False</property>
-				      <property name="focus_on_click">True</property>
-				    </widget>
-				    <packing>
-				      <property name="padding">0</property>
-				      <property name="expand">False</property>
-				      <property name="fill">False</property>
-				    </packing>
-				  </child>
-
-				  <child>
-				    <widget class="GtkButton" id="buttonConfA">
-				      <property name="visible">True</property>
-				      <property name="tooltip" translatable="yes">Configure audio encoder</property>
-				      <property name="can_focus">True</property>
-				      <property name="label" translatable="yes">Configure</property>
-				      <property name="use_underline">True</property>
-				      <property name="relief">GTK_RELIEF_NORMAL</property>
-				      <property name="focus_on_click">True</property>
-				      <accelerator key="F4" modifiers="0" signal="clicked"/>
-				    </widget>
-				    <packing>
-				      <property name="padding">0</property>
-				      <property name="expand">False</property>
-				      <property name="fill">False</property>
-				    </packing>
-				  </child>
-
-				  <child>
-				    <widget class="GtkButton" id="buttonAudioFilter">
-				      <property name="visible">True</property>
-				      <property name="tooltip" translatable="yes">Audio filters</property>
-				      <property name="can_focus">True</property>
-				      <property name="relief">GTK_RELIEF_NORMAL</property>
-				      <property name="focus_on_click">True</property>
-				      <accelerator key="F2" modifiers="0" signal="clicked"/>
-
-				      <child>
-					<widget class="GtkAlignment" id="alignment16">
-					  <property name="visible">True</property>
-					  <property name="xalign">0.5</property>
-					  <property name="yalign">0.5</property>
-					  <property name="xscale">0</property>
-					  <property name="yscale">0</property>
-					  <property name="top_padding">0</property>
-					  <property name="bottom_padding">0</property>
-					  <property name="left_padding">0</property>
-					  <property name="right_padding">0</property>
-
-					  <child>
-					    <widget class="GtkHBox" id="hbox18">
-					      <property name="visible">True</property>
-					      <property name="homogeneous">False</property>
-					      <property name="spacing">2</property>
-
-					      <child>
-						<widget class="GtkLabel" id="label22">
-						  <property name="visible">True</property>
-						  <property name="label" translatable="yes">Filters</property>
-						  <property name="use_underline">True</property>
-						  <property name="use_markup">False</property>
-						  <property name="justify">GTK_JUSTIFY_LEFT</property>
-						  <property name="wrap">False</property>
-						  <property name="selectable">False</property>
-						  <property name="xalign">0.5</property>
-						  <property name="yalign">0.5</property>
-						  <property name="xpad">0</property>
-						  <property name="ypad">0</property>
-						  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-						  <property name="width_chars">-1</property>
-						  <property name="single_line_mode">False</property>
-						  <property name="angle">0</property>
-						</widget>
-						<packing>
-						  <property name="padding">0</property>
-						  <property name="expand">False</property>
-						  <property name="fill">False</property>
-						</packing>
-					      </child>
-					    </widget>
-					  </child>
-					</widget>
-				      </child>
-				    </widget>
-				    <packing>
-				      <property name="padding">0</property>
-				      <property name="expand">False</property>
-				      <property name="fill">False</property>
-				    </packing>
-				  </child>
-
-				  <child>
-				    <widget class="GtkHBox" id="hbox19">
-				      <property name="visible">True</property>
-				      <property name="homogeneous">False</property>
-				      <property name="spacing">6</property>
-
-				      <child>
-					<widget class="GtkCheckButton" id="CheckButtonTimeshift">
-					  <property name="visible">True</property>
-					  <property name="tooltip" translatable="yes">Enable time shift</property>
-					  <property name="can_focus">True</property>
-					  <property name="label" translatable="yes">Shift:</property>
-					  <property name="use_underline">True</property>
-					  <property name="relief">GTK_RELIEF_NORMAL</property>
-					  <property name="focus_on_click">True</property>
-					  <property name="active">False</property>
-					  <property name="inconsistent">False</property>
-					  <property name="draw_indicator">True</property>
-					</widget>
-					<packing>
-					  <property name="padding">0</property>
-					  <property name="expand">False</property>
-					  <property name="fill">False</property>
-					</packing>
-				      </child>
-
-				      <child>
-					<widget class="GtkSpinButton" id="spinbuttonTimeShift">
-					  <property name="visible">True</property>
-					  <property name="tooltip" translatable="yes">Audio/video time shift (ms)</property>
-					  <property name="can_focus">True</property>
-					  <property name="climb_rate">1</property>
-					  <property name="digits">0</property>
-					  <property name="numeric">True</property>
-					  <property name="update_policy">GTK_UPDATE_ALWAYS</property>
-					  <property name="snap_to_ticks">False</property>
-					  <property name="wrap">False</property>
-					  <property name="adjustment">0 -99999 99999 1 10 0</property>
-					</widget>
-					<packing>
-					  <property name="padding">0</property>
-					  <property name="expand">True</property>
-					  <property name="fill">True</property>
-					</packing>
-				      </child>
-
-				      <child>
-					<widget class="GtkLabel" id="label23">
-					  <property name="visible">True</property>
-					  <property name="label" translatable="yes">ms</property>
-					  <property name="use_underline">False</property>
-					  <property name="use_markup">False</property>
-					  <property name="justify">GTK_JUSTIFY_LEFT</property>
-					  <property name="wrap">False</property>
-					  <property name="selectable">False</property>
-					  <property name="xalign">0.5</property>
-					  <property name="yalign">0.5</property>
-					  <property name="xpad">0</property>
-					  <property name="ypad">0</property>
-					  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-					  <property name="width_chars">-1</property>
-					  <property name="single_line_mode">False</property>
-					  <property name="angle">0</property>
-					</widget>
-					<packing>
-					  <property name="padding">0</property>
-					  <property name="expand">False</property>
-					  <property name="fill">False</property>
-					</packing>
-				      </child>
-				    </widget>
-				    <packing>
-				      <property name="padding">0</property>
-				      <property name="expand">True</property>
-				      <property name="fill">True</property>
-				    </packing>
-				  </child>
-				</widget>
-			      </child>
-			    </widget>
-			    <packing>
-			      <property name="padding">0</property>
-			      <property name="expand">True</property>
-			      <property name="fill">True</property>
-			    </packing>
-			  </child>
-			</widget>
-			<packing>
-			  <property name="padding">0</property>
-			  <property name="expand">False</property>
-			  <property name="fill">False</property>
-			</packing>
-		      </child>
-
-		      <child>
-			<widget class="GtkVBox" id="vbox13">
-			  <property name="visible">True</property>
-			  <property name="homogeneous">False</property>
-			  <property name="spacing">0</property>
-
-			  <child>
-			    <widget class="GtkLabel" id="label20">
-			      <property name="visible">True</property>
-			      <property name="label" translatable="yes">&lt;b&gt;Format&lt;/b&gt;</property>
-			      <property name="use_underline">False</property>
-			      <property name="use_markup">True</property>
-			      <property name="justify">GTK_JUSTIFY_LEFT</property>
-			      <property name="wrap">False</property>
-			      <property name="selectable">False</property>
-			      <property name="xalign">0</property>
-			      <property name="yalign">0.5</property>
-			      <property name="xpad">0</property>
-			      <property name="ypad">0</property>
-			      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-			      <property name="width_chars">-1</property>
-			      <property name="single_line_mode">False</property>
-			      <property name="angle">0</property>
-			    </widget>
-			    <packing>
-			      <property name="padding">0</property>
-			      <property name="expand">False</property>
-			      <property name="fill">False</property>
-			    </packing>
-			  </child>
-
-			  <child>
-			    <widget class="GtkAlignment" id="alignment14">
-			      <property name="visible">True</property>
-			      <property name="xalign">0.5</property>
-			      <property name="yalign">0.5</property>
-			      <property name="xscale">1</property>
-			      <property name="yscale">1</property>
-			      <property name="top_padding">3</property>
-			      <property name="bottom_padding">0</property>
-			      <property name="left_padding">12</property>
-			      <property name="right_padding">0</property>
-
-			      <child>
-				<widget class="GtkComboBox" id="comboboxFormat">
-				  <property name="visible">True</property>
-				  <property name="add_tearoffs">False</property>
-				  <property name="focus_on_click">True</property>
-				</widget>
-			      </child>
-			    </widget>
-			    <packing>
-			      <property name="padding">0</property>
-			      <property name="expand">True</property>
-			      <property name="fill">True</property>
-			    </packing>
-			  </child>
-			</widget>
-			<packing>
-			  <property name="padding">0</property>
-			  <property name="expand">False</property>
-			  <property name="fill">False</property>
-			</packing>
-		      </child>
-		    </widget>
-		  </child>
-		</widget>
-		<packing>
-		  <property name="padding">0</property>
-		  <property name="expand">False</property>
-		  <property name="fill">False</property>
-		</packing>
-	      </child>
-
-	      <child>
-		<widget class="GtkDrawingArea" id="guiDrawing">
-		  <property name="width_request">496</property>
-		  <property name="height_request">288</property>
-		  <property name="visible">True</property>
-		  <property name="sensitive">False</property>
-		</widget>
-		<packing>
-		  <property name="padding">0</property>
-		  <property name="expand">True</property>
-		  <property name="fill">True</property>
-		</packing>
-	      </child>
-	    </widget>
-	    <packing>
-	      <property name="padding">0</property>
-	      <property name="expand">True</property>
-	      <property name="fill">True</property>
-	    </packing>
-	  </child>
-
-	  <child>
-	    <widget class="GtkTable" id="table2">
-	      <property name="border_width">3</property>
-	      <property name="visible">True</property>
-	      <property name="n_rows">3</property>
-	      <property name="n_columns">2</property>
-	      <property name="homogeneous">False</property>
-	      <property name="row_spacing">0</property>
-	      <property name="column_spacing">6</property>
-
-	      <child>
-		<widget class="GtkHBox" id="hbox16">
-		  <property name="visible">True</property>
-		  <property name="homogeneous">False</property>
-		  <property name="spacing">6</property>
-
-		  <child>
-		    <widget class="GtkLabel" id="label1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Frame: </property>
-		      <property name="use_underline">False</property>
-		      <property name="use_markup">False</property>
-		      <property name="justify">GTK_JUSTIFY_LEFT</property>
-		      <property name="wrap">False</property>
-		      <property name="selectable">False</property>
-		      <property name="xalign">0.5</property>
-		      <property name="yalign">0.5</property>
-		      <property name="xpad">0</property>
-		      <property name="ypad">0</property>
-		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-		      <property name="width_chars">-1</property>
-		      <property name="single_line_mode">False</property>
-		      <property name="angle">0</property>
-		    </widget>
-		    <packing>
-		      <property name="padding">0</property>
-		      <property name="expand">False</property>
-		      <property name="fill">False</property>
-		    </packing>
-		  </child>
-
-		  <child>
-		    <widget class="GtkEntry" id="boxCurFrame">
-		      <property name="visible">True</property>
-		      <property name="tooltip" translatable="yes">Current frame</property>
-		      <property name="can_focus">True</property>
-		      <property name="editable">True</property>
-		      <property name="visibility">True</property>
-		      <property name="max_length">8</property>
-		      <property name="text" translatable="yes">0</property>
-		      <property name="has_frame">True</property>
-		      <property name="invisible_char">*</property>
-		      <property name="activates_default">False</property>
-		      <property name="width_chars">8</property>
-		    </widget>
-		    <packing>
-		      <property name="padding">0</property>
-		      <property name="expand">False</property>
-		      <property name="fill">False</property>
-		    </packing>
-		  </child>
-
-		  <child>
-		    <widget class="GtkLabel" id="labelTotalFrame">
-		      <property name="visible">True</property>
-		      <property name="can_focus">True</property>
-		      <property name="label" translatable="yes">/ 0000000</property>
-		      <property name="use_underline">False</property>
-		      <property name="use_markup">False</property>
-		      <property name="justify">GTK_JUSTIFY_LEFT</property>
-		      <property name="wrap">False</property>
-		      <property name="selectable">True</property>
-		      <property name="xalign">0.5</property>
-		      <property name="yalign">0.5</property>
-		      <property name="xpad">5</property>
-		      <property name="ypad">0</property>
-		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-		      <property name="width_chars">-1</property>
-		      <property name="single_line_mode">False</property>
-		      <property name="angle">0</property>
-		    </widget>
-		    <packing>
-		      <property name="padding">0</property>
-		      <property name="expand">False</property>
-		      <property name="fill">False</property>
-		    </packing>
-		  </child>
-
-		  <child>
-		    <widget class="GtkLabel" id="label4">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Time: </property>
-		      <property name="use_underline">False</property>
-		      <property name="use_markup">False</property>
-		      <property name="justify">GTK_JUSTIFY_LEFT</property>
-		      <property name="wrap">False</property>
-		      <property name="selectable">False</property>
-		      <property name="xalign">0.5</property>
-		      <property name="yalign">0.5</property>
-		      <property name="xpad">0</property>
-		      <property name="ypad">0</property>
-		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-		      <property name="width_chars">-1</property>
-		      <property name="single_line_mode">False</property>
-		      <property name="angle">0</property>
-		    </widget>
-		    <packing>
-		      <property name="padding">0</property>
-		      <property name="expand">False</property>
-		      <property name="fill">False</property>
-		    </packing>
-		  </child>
-
-		  <child>
-		    <widget class="GtkEntry" id="boxCurTime">
-		      <property name="visible">True</property>
-		      <property name="tooltip" translatable="yes">Current time</property>
-		      <property name="can_focus">True</property>
-		      <property name="editable">True</property>
-		      <property name="visibility">True</property>
-		      <property name="max_length">0</property>
-		      <property name="text" translatable="yes">00:00:00.000</property>
-		      <property name="has_frame">True</property>
-		      <property name="invisible_char">*</property>
-		      <property name="activates_default">False</property>
-		      <property name="width_chars">13</property>
-		    </widget>
-		    <packing>
-		      <property name="padding">0</property>
-		      <property name="expand">False</property>
-		      <property name="fill">False</property>
-		    </packing>
-		  </child>
-
-		  <child>
-		    <widget class="GtkLabel" id="labelTotalTime">
-		      <property name="visible">True</property>
-		      <property name="can_focus">True</property>
-		      <property name="label" translatable="yes">/ 00:00:00,000</property>
-		      <property name="use_underline">False</property>
-		      <property name="use_markup">False</property>
-		      <property name="justify">GTK_JUSTIFY_LEFT</property>
-		      <property name="wrap">False</property>
-		      <property name="selectable">True</property>
-		      <property name="xalign">0.5</property>
-		      <property name="yalign">0.5</property>
-		      <property name="xpad">5</property>
-		      <property name="ypad">0</property>
-		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-		      <property name="width_chars">-1</property>
-		      <property name="single_line_mode">False</property>
-		      <property name="angle">0</property>
-		    </widget>
-		    <packing>
-		      <property name="padding">0</property>
-		      <property name="expand">False</property>
-		      <property name="fill">False</property>
-		    </packing>
-		  </child>
-
-		  <child>
-		    <widget class="GtkLabel" id="labelFrameType">
-		      <property name="visible">True</property>
-		      <property name="can_focus">True</property>
-		      <property name="label" translatable="yes">Frame: ?</property>
-		      <property name="use_underline">False</property>
-		      <property name="use_markup">False</property>
-		      <property name="justify">GTK_JUSTIFY_LEFT</property>
-		      <property name="wrap">False</property>
-		      <property name="selectable">True</property>
-		      <property name="xalign">0.5</property>
-		      <property name="yalign">0.5</property>
-		      <property name="xpad">0</property>
-		      <property name="ypad">0</property>
-		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-		      <property name="width_chars">-1</property>
-		      <property name="single_line_mode">False</property>
-		      <property name="angle">0</property>
-		    </widget>
-		    <packing>
-		      <property name="padding">0</property>
-		      <property name="expand">False</property>
-		      <property name="fill">False</property>
-		    </packing>
-		  </child>
-		</widget>
-		<packing>
-		  <property name="left_attach">0</property>
-		  <property name="right_attach">1</property>
-		  <property name="top_attach">2</property>
-		  <property name="bottom_attach">3</property>
-		  <property name="y_options"></property>
-		</packing>
-	      </child>
-
-	      <child>
-		<widget class="GtkHScale" id="sliderNavigate">
-		  <property name="visible">True</property>
-		  <property name="draw_value">True</property>
-		  <property name="value_pos">GTK_POS_LEFT</property>
-		  <property name="digits">1</property>
-		  <property name="update_policy">GTK_UPDATE_CONTINUOUS</property>
-		  <property name="inverted">False</property>
-		  <property name="adjustment">0 0 99.9899978638 0.00999999977648 1 0</property>
-		</widget>
-		<packing>
-		  <property name="left_attach">0</property>
-		  <property name="right_attach">1</property>
-		  <property name="top_attach">0</property>
-		  <property name="bottom_attach">1</property>
-		</packing>
-	      </child>
-
-	      <child>
-		<widget class="GtkHBox" id="hbox10">
-		  <property name="visible">True</property>
-		  <property name="homogeneous">False</property>
-		  <property name="spacing">0</property>
-
-		  <child>
-		    <widget class="GtkButton" id="buttonPlay">
-		      <property name="visible">True</property>
-		      <property name="tooltip" translatable="yes">Play</property>
-		      <property name="relief">GTK_RELIEF_NONE</property>
-		      <property name="focus_on_click">False</property>
-		      <accelerator key="space" modifiers="0" signal="clicked"/>
-
-		      <child>
-			<widget class="GtkImage" id="image591">
-			  <property name="visible">True</property>
-			  <property name="pixbuf">play.xpm</property>
-			  <property name="xalign">0.5</property>
-			  <property name="yalign">0.5</property>
-			  <property name="xpad">0</property>
-			  <property name="ypad">0</property>
-			</widget>
-		      </child>
-		    </widget>
-		    <packing>
-		      <property name="padding">0</property>
-		      <property name="expand">False</property>
-		      <property name="fill">False</property>
-		    </packing>
-		  </child>
-
-		  <child>
-		    <widget class="GtkButton" id="buttonStop">
-		      <property name="visible">True</property>
-		      <property name="tooltip" translatable="yes">Stop</property>
-		      <property name="can_focus">True</property>
-		      <property name="relief">GTK_RELIEF_NONE</property>
-		      <property name="focus_on_click">False</property>
-
-		      <child>
-			<widget class="GtkImage" id="image5056">
-			  <property name="visible">True</property>
-			  <property name="pixbuf">stop.xpm</property>
-			  <property name="xalign">0.5</property>
-			  <property name="yalign">0.5</property>
-			  <property name="xpad">0</property>
-			  <property name="ypad">0</property>
-			</widget>
-		      </child>
-		    </widget>
-		    <packing>
-		      <property name="padding">0</property>
-		      <property name="expand">False</property>
-		      <property name="fill">False</property>
-		    </packing>
-		  </child>
-
-		  <child>
-		    <widget class="GtkButton" id="buttonPrevFrame">
-		      <property name="visible">True</property>
-		      <property name="tooltip" translatable="yes">Previous frame</property>
-		      <property name="relief">GTK_RELIEF_NONE</property>
-		      <property name="focus_on_click">False</property>
-		      <accelerator key="KP_4" modifiers="0" signal="clicked"/>
-
-		      <child>
-			<widget class="GtkImage" id="image593">
-			  <property name="visible">True</property>
-			  <property name="pixbuf">backward.xpm</property>
-			  <property name="xalign">0.5</property>
-			  <property name="yalign">0.5</property>
-			  <property name="xpad">0</property>
-			  <property name="ypad">0</property>
-			</widget>
-		      </child>
-		    </widget>
-		    <packing>
-		      <property name="padding">0</property>
-		      <property name="expand">False</property>
-		      <property name="fill">False</property>
-		    </packing>
-		  </child>
-
-		  <child>
-		    <widget class="GtkButton" id="buttonNextFrame">
-		      <property name="visible">True</property>
-		      <property name="tooltip" translatable="yes">Next frame</property>
-		      <property name="relief">GTK_RELIEF_NONE</property>
-		      <property name="focus_on_click">False</property>
-		      <accelerator key="KP_6" modifiers="0" signal="clicked"/>
-
-		      <child>
-			<widget class="GtkImage" id="image594">
-			  <property name="visible">True</property>
-			  <property name="pixbuf">forward.xpm</property>
-			  <property name="xalign">0.5</property>
-			  <property name="yalign">0.5</property>
-			  <property name="xpad">0</property>
-			  <property name="ypad">0</property>
-			</widget>
-		      </child>
-		    </widget>
-		    <packing>
-		      <property name="padding">0</property>
-		      <property name="expand">False</property>
-		      <property name="fill">False</property>
-		    </packing>
-		  </child>
-
-		  <child>
-		    <widget class="GtkButton" id="buttonPrevKFrame">
-		      <property name="visible">True</property>
-		      <property name="tooltip" translatable="yes">Previous keyframe</property>
-		      <property name="relief">GTK_RELIEF_NONE</property>
-		      <property name="focus_on_click">False</property>
-		      <accelerator key="KP_2" modifiers="0" signal="clicked"/>
-
-		      <child>
-			<widget class="GtkImage" id="image595">
-			  <property name="visible">True</property>
-			  <property name="pixbuf">Kbackward.xpm</property>
-			  <property name="xalign">0.5</property>
-			  <property name="yalign">0.5</property>
-			  <property name="xpad">0</property>
-			  <property name="ypad">0</property>
-			</widget>
-		      </child>
-		    </widget>
-		    <packing>
-		      <property name="padding">0</property>
-		      <property name="expand">False</property>
-		      <property name="fill">False</property>
-		    </packing>
-		  </child>
-
-		  <child>
-		    <widget class="GtkButton" id="buttonNextKFrame">
-		      <property name="visible">True</property>
-		      <property name="tooltip" translatable="yes">Next keyframe</property>
-		      <property name="relief">GTK_RELIEF_NONE</property>
-		      <property name="focus_on_click">False</property>
-		      <accelerator key="KP_8" modifiers="0" signal="clicked"/>
-
-		      <child>
-			<widget class="GtkImage" id="image596">
-			  <property name="visible">True</property>
-			  <property name="pixbuf">Kforward.xpm</property>
-			  <property name="xalign">0.5</property>
-			  <property name="yalign">0.5</property>
-			  <property name="xpad">0</property>
-			  <property name="ypad">0</property>
-			</widget>
-		      </child>
-		    </widget>
-		    <packing>
-		      <property name="padding">0</property>
-		      <property name="expand">False</property>
-		      <property name="fill">False</property>
-		    </packing>
-		  </child>
-
-		  <child>
-		    <widget class="GtkButton" id="buttonMarkA">
-		      <property name="visible">True</property>
-		      <property name="tooltip" translatable="yes">Selection: start</property>
-		      <property name="can_focus">True</property>
-		      <property name="relief">GTK_RELIEF_NONE</property>
-		      <property name="focus_on_click">False</property>
-
-		      <child>
-			<widget class="GtkImage" id="image2306">
-			  <property name="visible">True</property>
-			  <property name="pixbuf">markA.xpm</property>
-			  <property name="xalign">0.5</property>
-			  <property name="yalign">0.5</property>
-			  <property name="xpad">0</property>
-			  <property name="ypad">0</property>
-			</widget>
-		      </child>
-		    </widget>
-		    <packing>
-		      <property name="padding">0</property>
-		      <property name="expand">False</property>
-		      <property name="fill">False</property>
-		    </packing>
-		  </child>
-
-		  <child>
-		    <widget class="GtkButton" id="buttonMarkB">
-		      <property name="visible">True</property>
-		      <property name="tooltip" translatable="yes">Selection: end</property>
-		      <property name="can_focus">True</property>
-		      <property name="relief">GTK_RELIEF_NONE</property>
-		      <property name="focus_on_click">False</property>
-
-		      <child>
-			<widget class="GtkImage" id="image2307">
-			  <property name="visible">True</property>
-			  <property name="pixbuf">markB.xpm</property>
-			  <property name="xalign">0.5</property>
-			  <property name="yalign">0.5</property>
-			  <property name="xpad">0</property>
-			  <property name="ypad">0</property>
-			</widget>
-		      </child>
-		    </widget>
-		    <packing>
-		      <property name="padding">0</property>
-		      <property name="expand">False</property>
-		      <property name="fill">False</property>
-		    </packing>
-		  </child>
-
-		  <child>
-		    <widget class="GtkButton" id="buttonPrevBlack">
-		      <property name="visible">True</property>
-		      <property name="tooltip" translatable="yes">Previous black frame</property>
-		      <property name="can_focus">True</property>
-		      <property name="relief">GTK_RELIEF_NONE</property>
-		      <property name="focus_on_click">False</property>
-
-		      <child>
-			<widget class="GtkImage" id="image2308">
-			  <property name="visible">True</property>
-			  <property name="pixbuf">xpm_prevblack.xpm</property>
-			  <property name="xalign">0.5</property>
-			  <property name="yalign">0.5</property>
-			  <property name="xpad">0</property>
-			  <property name="ypad">0</property>
-			</widget>
-		      </child>
-		    </widget>
-		    <packing>
-		      <property name="padding">0</property>
-		      <property name="expand">False</property>
-		      <property name="fill">False</property>
-		    </packing>
-		  </child>
-
-		  <child>
-		    <widget class="GtkButton" id="buttonNextBlack">
-		      <property name="visible">True</property>
-		      <property name="tooltip" translatable="yes">Next black frame</property>
-		      <property name="can_focus">True</property>
-		      <property name="relief">GTK_RELIEF_NONE</property>
-		      <property name="focus_on_click">False</property>
-
-		      <child>
-			<widget class="GtkImage" id="image2309">
-			  <property name="visible">True</property>
-			  <property name="pixbuf">xpm_nextblack.xpm</property>
-			  <property name="xalign">0.5</property>
-			  <property name="yalign">0.5</property>
-			  <property name="xpad">0</property>
-			  <property name="ypad">0</property>
-			</widget>
-		      </child>
-		    </widget>
-		    <packing>
-		      <property name="padding">0</property>
-		      <property name="expand">False</property>
-		      <property name="fill">False</property>
-		    </packing>
-		  </child>
-
-		  <child>
-		    <widget class="GtkButton" id="buttonBegin">
-		      <property name="visible">True</property>
-		      <property name="tooltip" translatable="yes">First frame</property>
-		      <property name="can_focus">True</property>
-		      <property name="relief">GTK_RELIEF_NONE</property>
-		      <property name="focus_on_click">False</property>
-
-		      <child>
-			<widget class="GtkImage" id="image5057">
-			  <property name="visible">True</property>
-			  <property name="pixbuf">begin.xpm</property>
-			  <property name="xalign">0.5</property>
-			  <property name="yalign">0.5</property>
-			  <property name="xpad">0</property>
-			  <property name="ypad">0</property>
-			</widget>
-		      </child>
-		    </widget>
-		    <packing>
-		      <property name="padding">0</property>
-		      <property name="expand">False</property>
-		      <property name="fill">False</property>
-		    </packing>
-		  </child>
-
-		  <child>
-		    <widget class="GtkButton" id="buttonEnd">
-		      <property name="visible">True</property>
-		      <property name="tooltip" translatable="yes">Last frame</property>
-		      <property name="can_focus">True</property>
-		      <property name="relief">GTK_RELIEF_NONE</property>
-		      <property name="focus_on_click">False</property>
-
-		      <child>
-			<widget class="GtkImage" id="image2245">
-			  <property name="visible">True</property>
-			  <property name="pixbuf">end.xpm</property>
-			  <property name="xalign">0.5</property>
-			  <property name="yalign">0.5</property>
-			  <property name="xpad">0</property>
-			  <property name="ypad">0</property>
-			</widget>
-		      </child>
-		    </widget>
-		    <packing>
-		      <property name="padding">0</property>
-		      <property name="expand">False</property>
-		      <property name="fill">False</property>
-		    </packing>
-		  </child>
-		</widget>
-		<packing>
-		  <property name="left_attach">0</property>
-		  <property name="right_attach">1</property>
-		  <property name="top_attach">1</property>
-		  <property name="bottom_attach">2</property>
-		</packing>
-	      </child>
-
-	      <child>
-		<widget class="GtkVBox" id="vbox14">
-		  <property name="visible">True</property>
-		  <property name="homogeneous">False</property>
-		  <property name="spacing">0</property>
-
-		  <child>
-		    <widget class="GtkLabel" id="label21">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">&lt;b&gt;Selection&lt;/b&gt;</property>
-		      <property name="use_underline">False</property>
-		      <property name="use_markup">True</property>
-		      <property name="justify">GTK_JUSTIFY_LEFT</property>
-		      <property name="wrap">False</property>
-		      <property name="selectable">False</property>
-		      <property name="xalign">0</property>
-		      <property name="yalign">0.5</property>
-		      <property name="xpad">0</property>
-		      <property name="ypad">0</property>
-		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-		      <property name="width_chars">-1</property>
-		      <property name="single_line_mode">False</property>
-		      <property name="angle">0</property>
-		    </widget>
-		    <packing>
-		      <property name="padding">0</property>
-		      <property name="expand">False</property>
-		      <property name="fill">False</property>
-		    </packing>
-		  </child>
-
-		  <child>
-		    <widget class="GtkAlignment" id="alignment15">
-		      <property name="visible">True</property>
-		      <property name="xalign">0.5</property>
-		      <property name="yalign">0.5</property>
-		      <property name="xscale">1</property>
-		      <property name="yscale">1</property>
-		      <property name="top_padding">3</property>
-		      <property name="bottom_padding">0</property>
-		      <property name="left_padding">12</property>
-		      <property name="right_padding">0</property>
-
-		      <child>
-			<widget class="GtkTable" id="table1">
-			  <property name="visible">True</property>
-			  <property name="n_rows">2</property>
-			  <property name="n_columns">2</property>
-			  <property name="homogeneous">False</property>
-			  <property name="row_spacing">3</property>
-			  <property name="column_spacing">3</property>
-
-			  <child>
-			    <widget class="GtkButton" id="buttonGotoB">
-			      <property name="height_request">20</property>
-			      <property name="visible">True</property>
-			      <property name="tooltip" translatable="yes">Go to marker B</property>
-			      <property name="label" translatable="yes">B:</property>
-			      <property name="use_underline">True</property>
-			      <property name="relief">GTK_RELIEF_NORMAL</property>
-			      <property name="focus_on_click">True</property>
-			    </widget>
-			    <packing>
-			      <property name="left_attach">0</property>
-			      <property name="right_attach">1</property>
-			      <property name="top_attach">1</property>
-			      <property name="bottom_attach">2</property>
-			      <property name="x_options"></property>
-			      <property name="y_options"></property>
-			    </packing>
-			  </child>
-
-			  <child>
-			    <widget class="GtkButton" id="buttonGotoA">
-			      <property name="height_request">20</property>
-			      <property name="visible">True</property>
-			      <property name="tooltip" translatable="yes">Go to marker A</property>
-			      <property name="label" translatable="yes">A:</property>
-			      <property name="use_underline">True</property>
-			      <property name="relief">GTK_RELIEF_NORMAL</property>
-			      <property name="focus_on_click">True</property>
-			    </widget>
-			    <packing>
-			      <property name="left_attach">0</property>
-			      <property name="right_attach">1</property>
-			      <property name="top_attach">0</property>
-			      <property name="bottom_attach">1</property>
-			      <property name="x_options"></property>
-			      <property name="y_options"></property>
-			    </packing>
-			  </child>
-
-			  <child>
-			    <widget class="GtkLabel" id="labelMarkB">
-			      <property name="visible">True</property>
-			      <property name="can_focus">True</property>
-			      <property name="label" translatable="yes"> 0000000</property>
-			      <property name="use_underline">False</property>
-			      <property name="use_markup">False</property>
-			      <property name="justify">GTK_JUSTIFY_LEFT</property>
-			      <property name="wrap">False</property>
-			      <property name="selectable">True</property>
-			      <property name="xalign">0.5</property>
-			      <property name="yalign">0.5</property>
-			      <property name="xpad">0</property>
-			      <property name="ypad">0</property>
-			      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-			      <property name="width_chars">-1</property>
-			      <property name="single_line_mode">False</property>
-			      <property name="angle">0</property>
-			    </widget>
-			    <packing>
-			      <property name="left_attach">1</property>
-			      <property name="right_attach">2</property>
-			      <property name="top_attach">1</property>
-			      <property name="bottom_attach">2</property>
-			      <property name="x_options"></property>
-			      <property name="y_options"></property>
-			    </packing>
-			  </child>
-
-			  <child>
-			    <widget class="GtkLabel" id="labelMarkA">
-			      <property name="visible">True</property>
-			      <property name="can_focus">True</property>
-			      <property name="label" translatable="yes"> 0000000</property>
-			      <property name="use_underline">False</property>
-			      <property name="use_markup">False</property>
-			      <property name="justify">GTK_JUSTIFY_LEFT</property>
-			      <property name="wrap">False</property>
-			      <property name="selectable">True</property>
-			      <property name="xalign">0.5</property>
-			      <property name="yalign">0.5</property>
-			      <property name="xpad">0</property>
-			      <property name="ypad">0</property>
-			      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-			      <property name="width_chars">-1</property>
-			      <property name="single_line_mode">False</property>
-			      <property name="angle">0</property>
-			    </widget>
-			    <packing>
-			      <property name="left_attach">1</property>
-			      <property name="right_attach">2</property>
-			      <property name="top_attach">0</property>
-			      <property name="bottom_attach">1</property>
-			      <property name="x_options"></property>
-			      <property name="y_options"></property>
-			    </packing>
-			  </child>
-			</widget>
-		      </child>
-		    </widget>
-		    <packing>
-		      <property name="padding">0</property>
-		      <property name="expand">True</property>
-		      <property name="fill">True</property>
-		    </packing>
-		  </child>
-		</widget>
-		<packing>
-		  <property name="left_attach">1</property>
-		  <property name="right_attach">2</property>
-		  <property name="top_attach">1</property>
-		  <property name="bottom_attach">3</property>
-		  <property name="x_options"></property>
-		  <property name="y_options"></property>
-		</packing>
-	      </child>
-
-	      <child>
-		<widget class="Custom" id="jogg">
-		  <property name="visible">True</property>
-		  <property name="creation_function">jog_shuttle_new</property>
-		  <property name="int1">0</property>
-		  <property name="int2">0</property>
-		  <property name="last_modification_time">Sun, 07 Oct 2007 12:58:40 GMT</property>
-		</widget>
-		<packing>
-		  <property name="left_attach">1</property>
-		  <property name="right_attach">2</property>
-		  <property name="top_attach">0</property>
-		  <property name="bottom_attach">1</property>
-		  <property name="x_options">fill</property>
-		  <property name="y_options">expand</property>
-		</packing>
-	      </child>
-	    </widget>
-	    <packing>
-	      <property name="padding">0</property>
-	      <property name="expand">False</property>
-	      <property name="fill">False</property>
-	    </packing>
-	  </child>
-	</widget>
-	<packing>
-	  <property name="padding">0</property>
-	  <property name="expand">True</property>
-	  <property name="fill">True</property>
-	</packing>
-      </child>
-    </widget>
-  </child>
-</widget>
-
-</glade-interface>
+<?xml version="1.0" standalone="no"?> <!--*- mode: xml -*-->
+<!DOCTYPE glade-interface SYSTEM "http://glade.gnome.org/glade-2.0.dtd">
+
+<glade-interface>
+
+<widget class="GtkWindow" id="mainWindow">
+  <property name="visible">True</property>
+  <property name="title" translatable="yes">Avidemux</property>
+  <property name="type">GTK_WINDOW_TOPLEVEL</property>
+  <property name="window_position">GTK_WIN_POS_NONE</property>
+  <property name="modal">False</property>
+  <property name="resizable">True</property>
+  <property name="destroy_with_parent">False</property>
+  <property name="icon">avidemux_icon_small.png</property>
+  <property name="decorated">True</property>
+  <property name="skip_taskbar_hint">False</property>
+  <property name="skip_pager_hint">False</property>
+  <property name="type_hint">GDK_WINDOW_TYPE_HINT_NORMAL</property>
+  <property name="gravity">GDK_GRAVITY_NORTH_WEST</property>
+  <property name="focus_on_map">True</property>
+
+  <child>
+    <widget class="GtkVBox" id="vbox1">
+      <property name="visible">True</property>
+      <property name="homogeneous">False</property>
+      <property name="spacing">0</property>
+
+      <child>
+	<widget class="GtkMenuBar" id="menuBar">
+	  <property name="visible">True</property>
+	  <property name="can_focus">True</property>
+
+	  <child>
+	    <widget class="GtkMenuItem" id="menuitem1">
+	      <property name="visible">True</property>
+	      <property name="label" translatable="yes">_File</property>
+	      <property name="use_underline">True</property>
+
+	      <child>
+		<widget class="GtkMenu" id="menuitem1_menu">
+
+		  <child>
+		    <widget class="GtkImageMenuItem" id="open_video1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_Open...</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="O" modifiers="GDK_CONTROL_MASK" signal="activate"/>
+
+		      <child internal-child="image">
+			<widget class="GtkImage" id="image8523">
+			  <property name="visible">True</property>
+			  <property name="stock">gtk-open</property>
+			  <property name="icon_size">1</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkImageMenuItem" id="append_video1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_Append...</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="A" modifiers="GDK_CONTROL_MASK | GDK_MOD1_MASK" signal="activate"/>
+
+		      <child internal-child="image">
+			<widget class="GtkImage" id="image8524">
+			  <property name="visible">True</property>
+			  <property name="stock">gtk-add</property>
+			  <property name="icon_size">1</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkImageMenuItem" id="save_stuff">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_Save</property>
+		      <property name="use_underline">True</property>
+
+		      <child internal-child="image">
+			<widget class="GtkImage" id="image8525">
+			  <property name="visible">True</property>
+			  <property name="stock">gtk-save</property>
+			  <property name="icon_size">1</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+
+		      <child>
+			<widget class="GtkMenu" id="save_stuff_menu">
+
+			  <child>
+			    <widget class="GtkMenuItem" id="save_as_avi1">
+			      <property name="visible">True</property>
+			      <property name="label" translatable="yes">Save _Video...</property>
+			      <property name="use_underline">True</property>
+			      <accelerator key="S" modifiers="GDK_CONTROL_MASK" signal="activate"/>
+			    </widget>
+			  </child>
+
+			  <child>
+			    <widget class="GtkSeparatorMenuItem" id="separator1">
+			      <property name="visible">True</property>
+			    </widget>
+			  </child>
+
+			  <child>
+			    <widget class="GtkMenuItem" id="save_image1">
+			      <property name="visible">True</property>
+			      <property name="label" translatable="yes">Save _BMP Image...</property>
+			      <property name="use_underline">True</property>
+			    </widget>
+			  </child>
+
+			  <child>
+			    <widget class="GtkMenuItem" id="save_jpg_image1">
+			      <property name="visible">True</property>
+			      <property name="label" translatable="yes">Save _JPEG Image...</property>
+			      <property name="use_underline">True</property>
+			    </widget>
+			  </child>
+
+			  <child>
+			    <widget class="GtkMenuItem" id="save_selection_as_jpegs1">
+			      <property name="visible">True</property>
+			      <property name="label" translatable="yes">Save _Selection as JPEG Images...</property>
+			      <property name="use_underline">True</property>
+			    </widget>
+			  </child>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkImageMenuItem" id="close1">
+		      <property name="visible">True</property>
+		      <property name="label">gtk-close</property>
+		      <property name="use_stock">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkSeparatorMenuItem" id="separator3">
+		      <property name="visible">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkImageMenuItem" id="save_project1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Save _Project</property>
+		      <property name="use_underline">True</property>
+
+		      <child internal-child="image">
+			<widget class="GtkImage" id="image8526">
+			  <property name="visible">True</property>
+			  <property name="stock">gtk-save</property>
+			  <property name="icon_size">1</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkImageMenuItem" id="save_project_as1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Save P_roject As...</property>
+		      <property name="use_underline">True</property>
+
+		      <child internal-child="image">
+			<widget class="GtkImage" id="image8527">
+			  <property name="visible">True</property>
+			  <property name="stock">gtk-save-as</property>
+			  <property name="icon_size">1</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkImageMenuItem" id="run_script1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_Load/Run Project...</property>
+		      <property name="use_underline">True</property>
+
+		      <child internal-child="image">
+			<widget class="GtkImage" id="image8528">
+			  <property name="visible">True</property>
+			  <property name="stock">gtk-execute</property>
+			  <property name="icon_size">1</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="add_to_joblist1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">A_dd to Joblist...</property>
+		      <property name="use_underline">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="joblist1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Show _Joblist</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="J" modifiers="GDK_CONTROL_MASK" signal="activate"/>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkSeparatorMenuItem" id="separator16">
+		      <property name="visible">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="connect_to_avsproxy1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Co_nnect to avsproxy</property>
+		      <property name="use_underline">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkSeparatorMenuItem" id="separator18">
+		      <property name="visible">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkImageMenuItem" id="video_informations1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Proper_ties</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="Return" modifiers="GDK_MOD1_MASK" signal="activate"/>
+
+		      <child internal-child="image">
+			<widget class="GtkImage" id="image8529">
+			  <property name="visible">True</property>
+			  <property name="stock">gtk-properties</property>
+			  <property name="icon_size">1</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="avi_muxer_options1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">AVI _Muxer Options</property>
+		      <property name="use_underline">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkSeparatorMenuItem" id="separator4">
+		      <property name="visible">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkImageMenuItem" id="quit1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_Quit</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="Q" modifiers="GDK_CONTROL_MASK" signal="activate"/>
+
+		      <child internal-child="image">
+			<widget class="GtkImage" id="image8530">
+			  <property name="visible">True</property>
+			  <property name="stock">gtk-quit</property>
+			  <property name="icon_size">1</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+		</widget>
+	      </child>
+	    </widget>
+	  </child>
+
+	  <child>
+	    <widget class="GtkMenuItem" id="menuitem2">
+	      <property name="visible">True</property>
+	      <property name="label" translatable="yes">_Edit</property>
+	      <property name="use_underline">True</property>
+
+	      <child>
+		<widget class="GtkMenu" id="menuitem2_menu">
+
+		  <child>
+		    <widget class="GtkImageMenuItem" id="reset_edits1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_Reset Edits</property>
+		      <property name="use_underline">True</property>
+
+		      <child internal-child="image">
+			<widget class="GtkImage" id="image8531">
+			  <property name="visible">True</property>
+			  <property name="stock">gtk-undo</property>
+			  <property name="icon_size">1</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkSeparatorMenuItem" id="separator5">
+		      <property name="visible">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkImageMenuItem" id="cut1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Cu_t</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="X" modifiers="GDK_CONTROL_MASK" signal="activate"/>
+
+		      <child internal-child="image">
+			<widget class="GtkImage" id="image8532">
+			  <property name="visible">True</property>
+			  <property name="stock">gtk-cut</property>
+			  <property name="icon_size">1</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkImageMenuItem" id="copy1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_Copy</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="C" modifiers="GDK_CONTROL_MASK" signal="activate"/>
+
+		      <child internal-child="image">
+			<widget class="GtkImage" id="image8533">
+			  <property name="visible">True</property>
+			  <property name="stock">gtk-copy</property>
+			  <property name="icon_size">1</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkImageMenuItem" id="paste1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_Paste</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="V" modifiers="GDK_CONTROL_MASK" signal="activate"/>
+
+		      <child internal-child="image">
+			<widget class="GtkImage" id="image8534">
+			  <property name="visible">True</property>
+			  <property name="stock">gtk-paste</property>
+			  <property name="icon_size">1</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkImageMenuItem" id="delete1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_Delete</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="Delete" modifiers="0" signal="activate"/>
+
+		      <child internal-child="image">
+			<widget class="GtkImage" id="image8535">
+			  <property name="visible">True</property>
+			  <property name="stock">gtk-remove</property>
+			  <property name="icon_size">1</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkSeparatorMenuItem" id="separator6">
+		      <property name="visible">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="set_marker_a1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Set Marker _A</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="bracketleft" modifiers="0" signal="activate"/>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="set_marker_b1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Set Marker _B</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="bracketright" modifiers="0" signal="activate"/>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkSeparatorMenuItem" id="separator7">
+		      <property name="visible">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkImageMenuItem" id="preferences1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Pre_ferences</property>
+		      <property name="use_underline">True</property>
+
+		      <child internal-child="image">
+			<widget class="GtkImage" id="image8536">
+			  <property name="visible">True</property>
+			  <property name="stock">gtk-preferences</property>
+			  <property name="icon_size">1</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+		</widget>
+	      </child>
+	    </widget>
+	  </child>
+
+	  <child>
+	    <widget class="GtkMenuItem" id="view1">
+	      <property name="visible">True</property>
+	      <property name="label" translatable="yes">_View</property>
+	      <property name="use_underline">True</property>
+
+	      <child>
+		<widget class="GtkMenu" id="view1_menu">
+
+		  <child>
+		    <widget class="GtkCheckMenuItem" id="toolbar1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_Main Toolbar</property>
+		      <property name="use_underline">True</property>
+		      <property name="active">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkCheckMenuItem" id="sidebar1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_A/V Sidebar</property>
+		      <property name="use_underline">True</property>
+		      <property name="active">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkSeparatorMenuItem" id="separator8">
+		      <property name="visible">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="zoom_1_4">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_Zoom 1:4</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="4" modifiers="GDK_CONTROL_MASK | GDK_SHIFT_MASK" signal="activate"/>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="zoom_1_2">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Z_oom 1:2</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="2" modifiers="GDK_CONTROL_MASK | GDK_SHIFT_MASK" signal="activate"/>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="zoom_1_1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Zoom _1:1</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="1" modifiers="GDK_CONTROL_MASK | GDK_MOD1_MASK" signal="activate"/>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="zoom_2_1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Zoom _2:1</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="2" modifiers="GDK_CONTROL_MASK | GDK_MOD1_MASK" signal="activate"/>
+		    </widget>
+		  </child>
+		</widget>
+	      </child>
+	    </widget>
+	  </child>
+
+	  <child>
+	    <widget class="GtkMenuItem" id="video_1">
+	      <property name="visible">True</property>
+	      <property name="label" translatable="yes">Vi_deo</property>
+	      <property name="use_underline">True</property>
+
+	      <child>
+		<widget class="GtkMenu" id="video_1_menu">
+
+		  <child>
+		    <widget class="GtkMenuItem" id="decoder_options1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_Decoder Options</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="F3" modifiers="0" signal="activate"/>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="set_postprocessing1">
+		      <property name="visible">True</property>
+		      <property name="tooltip" translatable="yes">Select postprocessing level</property>
+		      <property name="label" translatable="yes">_Postprocessing</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="F4" modifiers="0" signal="activate"/>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkSeparatorMenuItem" id="separator9">
+		      <property name="visible">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkCheckMenuItem" id="preview1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">P_review</property>
+		      <property name="use_underline">True</property>
+		      <property name="active">False</property>
+		      <accelerator key="F5" modifiers="0" signal="activate"/>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkCheckMenuItem" id="display_output1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Display _Output</property>
+		      <property name="use_underline">True</property>
+		      <property name="active">False</property>
+		      <accelerator key="F6" modifiers="0" signal="activate"/>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkSeparatorMenuItem" id="separator10">
+		      <property name="visible">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="change_fps">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_Frame Rate</property>
+		      <property name="use_underline">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="videoencoder">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_Encoder</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="V" modifiers="GDK_CONTROL_MASK | GDK_MOD1_MASK" signal="activate"/>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="filters1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Fil_ters</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="F" modifiers="GDK_CONTROL_MASK | GDK_MOD1_MASK" signal="activate"/>
+		    </widget>
+		  </child>
+		</widget>
+	      </child>
+	    </widget>
+	  </child>
+
+	  <child>
+	    <widget class="GtkMenuItem" id="audio1">
+	      <property name="visible">True</property>
+	      <property name="label" translatable="yes">_Audio</property>
+	      <property name="use_underline">True</property>
+
+	      <child>
+		<widget class="GtkMenu" id="audio1_menu">
+
+		  <child>
+		    <widget class="GtkMenuItem" id="main_audio">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_Main Track</property>
+		      <property name="use_underline">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="second_audio_track1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_Second Track</property>
+		      <property name="use_underline">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="build_vbr_time_map1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_Build VBR Time Map</property>
+		      <property name="use_underline">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkSeparatorMenuItem" id="separator11">
+		      <property name="visible">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkImageMenuItem" id="save_audio1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">S_ave...</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="S" modifiers="GDK_CONTROL_MASK | GDK_MOD1_MASK" signal="activate"/>
+
+		      <child internal-child="image">
+			<widget class="GtkImage" id="image8537">
+			  <property name="visible">True</property>
+			  <property name="stock">gtk-save-as</property>
+			  <property name="icon_size">1</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="audio_encoder1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_Encoder</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="A" modifiers="GDK_CONTROL_MASK | GDK_MOD1_MASK" signal="activate"/>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="filters2">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_Filters</property>
+		      <property name="use_underline">True</property>
+		    </widget>
+		  </child>
+		</widget>
+	      </child>
+	    </widget>
+	  </child>
+
+	  <child>
+	    <widget class="GtkMenuItem" id="tools1">
+	      <property name="visible">True</property>
+	      <property name="label" translatable="yes">_Tools</property>
+	      <property name="use_underline">True</property>
+
+	      <child>
+		<widget class="GtkMenu" id="tools1_menu">
+
+		  <child>
+		    <widget class="GtkImageMenuItem" id="calculator1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_Calculator</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="F7" modifiers="0" signal="activate"/>
+
+		      <child internal-child="image">
+			<widget class="GtkImage" id="image8538">
+			  <property name="visible">True</property>
+			  <property name="pixbuf">gnome-calculator_small.xpm</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkSeparatorMenuItem" id="separator12">
+		      <property name="visible">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="rebuild_frames">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_Rebuild Frames (I &amp; B)</property>
+		      <property name="use_underline">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="check_frames">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">C_heck Frames (slow)</property>
+		      <property name="use_underline">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="bitrate_histogram1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_Bitrate Histogram</property>
+		      <property name="use_underline">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="item1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_Scan for Black Frames...</property>
+		      <property name="use_underline">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkSeparatorMenuItem" id="separator13">
+		      <property name="visible">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="v2v">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_VOB -&gt; VobSub</property>
+		      <property name="use_underline">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="ocr_vobsub_2_srt">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_OCR (VobSub -&gt; srt)</property>
+		      <property name="use_underline">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="ocr_dvb">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">OCR (TS-&gt;srt)</property>
+		      <property name="use_underline">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="edit_glyph1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_Edit Glyph</property>
+		      <property name="use_underline">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkSeparatorMenuItem" id="separator17">
+		      <property name="visible">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="see_hex1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_Frame Hex Dump</property>
+		      <property name="use_underline">True</property>
+		    </widget>
+		  </child>
+		</widget>
+	      </child>
+	    </widget>
+	  </child>
+
+	  <child>
+	    <widget class="GtkMenuItem" id="help1">
+	      <property name="visible">True</property>
+	      <property name="label" translatable="yes">A_uto</property>
+	      <property name="use_underline">True</property>
+
+	      <child>
+		<widget class="GtkMenu" id="help1_menu">
+
+		  <child>
+		    <widget class="GtkMenuItem" id="vcd1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_VCD</property>
+		      <property name="use_underline">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="svcd1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_SVCD</property>
+		      <property name="use_underline">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="dvd1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_DVD</property>
+		      <property name="use_underline">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="psp1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_PSP</property>
+		      <property name="use_underline">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="psp_(h264)1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">PSP (_H.264)</property>
+		      <property name="use_underline">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="flv1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">F_LV</property>
+		      <property name="use_underline">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="Ipod">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">IPOD (mpeg4)</property>
+		      <property name="use_underline">True</property>
+		    </widget>
+		  </child>
+		</widget>
+	      </child>
+	    </widget>
+	  </child>
+
+	  <child>
+	    <widget class="GtkMenuItem" id="go1">
+	      <property name="visible">True</property>
+	      <property name="label" translatable="yes">_Go</property>
+	      <property name="use_underline">True</property>
+
+	      <child>
+		<widget class="GtkMenu" id="go1_menu">
+
+		  <child>
+		    <widget class="GtkImageMenuItem" id="play_video1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_Play/Stop</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="P" modifiers="0" signal="activate"/>
+
+		      <child internal-child="image">
+			<widget class="GtkImage" id="image8539">
+			  <property name="visible">True</property>
+			  <property name="stock">gtk-media-play</property>
+			  <property name="icon_size">1</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkImageMenuItem" id="previous_frame1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">P_revious Frame</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="KP_4" modifiers="0" signal="activate"/>
+
+		      <child internal-child="image">
+			<widget class="GtkImage" id="image8540">
+			  <property name="visible">True</property>
+			  <property name="stock">gtk-media-previous</property>
+			  <property name="icon_size">1</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkImageMenuItem" id="next_frame1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_Next Frame</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="KP_6" modifiers="0" signal="activate"/>
+
+		      <child internal-child="image">
+			<widget class="GtkImage" id="image8541">
+			  <property name="visible">True</property>
+			  <property name="stock">gtk-media-next</property>
+			  <property name="icon_size">1</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkImageMenuItem" id="previous_intra_frame1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Pr_evious Intra Frame</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="KP_2" modifiers="0" signal="activate"/>
+
+		      <child internal-child="image">
+			<widget class="GtkImage" id="image8542">
+			  <property name="visible">True</property>
+			  <property name="stock">gtk-media-rewind</property>
+			  <property name="icon_size">1</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkImageMenuItem" id="next_intra_frame1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Next _Intra Frame</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="KP_8" modifiers="0" signal="activate"/>
+
+		      <child internal-child="image">
+			<widget class="GtkImage" id="image8543">
+			  <property name="visible">True</property>
+			  <property name="stock">gtk-media-forward</property>
+			  <property name="icon_size">1</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="search_previous_black_frame1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Previou_s Black Frame</property>
+		      <property name="use_underline">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="search_next_black_frame1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Ne_xt Black Frame</property>
+		      <property name="use_underline">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkImageMenuItem" id="first_frame1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_First Frame</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="Home" modifiers="0" signal="activate"/>
+
+		      <child internal-child="image">
+			<widget class="GtkImage" id="image8544">
+			  <property name="visible">True</property>
+			  <property name="stock">gtk-goto-first</property>
+			  <property name="icon_size">1</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkImageMenuItem" id="last_frame1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_Last Frame</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="End" modifiers="0" signal="activate"/>
+
+		      <child internal-child="image">
+			<widget class="GtkImage" id="image8545">
+			  <property name="visible">True</property>
+			  <property name="stock">gtk-goto-last</property>
+			  <property name="icon_size">1</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkSeparatorMenuItem" id="separator14">
+		      <property name="visible">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="go_to_marker_a1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Go to Marker _A</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="bracketleft" modifiers="GDK_CONTROL_MASK" signal="activate"/>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="go_to_marker_b1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Go to Marker _B</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="bracketright" modifiers="GDK_CONTROL_MASK" signal="activate"/>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkSeparatorMenuItem" id="separator15">
+		      <property name="visible">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkImageMenuItem" id="jum_to_frame1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Go to Fra_me...</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="F" modifiers="GDK_CONTROL_MASK" signal="activate"/>
+
+		      <child internal-child="image">
+			<widget class="GtkImage" id="image8546">
+			  <property name="visible">True</property>
+			  <property name="stock">gtk-jump-to</property>
+			  <property name="icon_size">1</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkImageMenuItem" id="jump_to_time1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Go to _Time...</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="T" modifiers="GDK_CONTROL_MASK" signal="activate"/>
+
+		      <child internal-child="image">
+			<widget class="GtkImage" id="image8547">
+			  <property name="visible">True</property>
+			  <property name="stock">gtk-jump-to</property>
+			  <property name="icon_size">1</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+		</widget>
+	      </child>
+	    </widget>
+	  </child>
+
+	  <child>
+	    <widget class="GtkMenuItem" id="custom1">
+	      <property name="visible">True</property>
+	      <property name="label" translatable="yes">_Custom</property>
+	      <property name="use_underline">True</property>
+	    </widget>
+	  </child>
+
+	  <child>
+	    <widget class="GtkMenuItem" id="help2">
+	      <property name="visible">True</property>
+	      <property name="label" translatable="yes">_Help</property>
+	      <property name="use_underline">True</property>
+
+	      <child>
+		<widget class="GtkMenu" id="help2_menu">
+
+		  <child>
+		    <widget class="GtkMenuItem" id="plugins1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_Plugins</property>
+		      <property name="use_underline">True</property>
+		      <signal name="activate" handler="on_plugins1_activate" last_modification_time="Sat, 21 Jun 2008 18:24:10 GMT"/>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="show_builtin_support1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_Built-in Support</property>
+		      <property name="use_underline">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkImageMenuItem" id="about1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_About</property>
+		      <property name="use_underline">True</property>
+
+		      <child internal-child="image">
+			<widget class="GtkImage" id="image8548">
+			  <property name="visible">True</property>
+			  <property name="stock">gtk-about</property>
+			  <property name="icon_size">1</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+		</widget>
+	      </child>
+	    </widget>
+	  </child>
+	</widget>
+	<packing>
+	  <property name="padding">0</property>
+	  <property name="expand">False</property>
+	  <property name="fill">False</property>
+	</packing>
+      </child>
+
+      <child>
+	<widget class="GtkToolbar" id="toolbar2">
+	  <property name="visible">True</property>
+	  <property name="orientation">GTK_ORIENTATION_HORIZONTAL</property>
+	  <property name="toolbar_style">GTK_TOOLBAR_BOTH_HORIZ</property>
+	  <property name="tooltips">True</property>
+	  <property name="show_arrow">True</property>
+
+	  <child>
+	    <widget class="GtkMenuToolButton" id="menutoolbuttonOpen">
+	      <property name="visible">True</property>
+	      <property name="tooltip" translatable="yes">Open a file</property>
+	      <property name="stock_id">gtk-open</property>
+	      <property name="visible_horizontal">True</property>
+	      <property name="visible_vertical">True</property>
+	      <property name="is_important">True</property>
+	    </widget>
+	    <packing>
+	      <property name="expand">False</property>
+	      <property name="homogeneous">False</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkToolItem" id="toolitem11">
+	      <property name="visible">True</property>
+	      <property name="visible_horizontal">True</property>
+	      <property name="visible_vertical">True</property>
+	      <property name="is_important">False</property>
+	    </widget>
+	    <packing>
+	      <property name="expand">False</property>
+	      <property name="homogeneous">False</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkToolButton" id="toolbuttonSave">
+	      <property name="visible">True</property>
+	      <property name="tooltip" translatable="yes">Save the file</property>
+	      <property name="stock_id">gtk-save</property>
+	      <property name="visible_horizontal">True</property>
+	      <property name="visible_vertical">True</property>
+	      <property name="is_important">True</property>
+	    </widget>
+	    <packing>
+	      <property name="expand">False</property>
+	      <property name="homogeneous">True</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkToolButton" id="toolbuttonInfo">
+	      <property name="visible">True</property>
+	      <property name="tooltip" translatable="yes">Audio/video file information</property>
+	      <property name="stock_id">gtk-properties</property>
+	      <property name="visible_horizontal">True</property>
+	      <property name="visible_vertical">True</property>
+	      <property name="is_important">False</property>
+	    </widget>
+	    <packing>
+	      <property name="expand">False</property>
+	      <property name="homogeneous">True</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkSeparatorToolItem" id="separatortoolitem1">
+	      <property name="visible">True</property>
+	      <property name="draw">True</property>
+	      <property name="visible_horizontal">True</property>
+	      <property name="visible_vertical">True</property>
+	    </widget>
+	    <packing>
+	      <property name="expand">False</property>
+	      <property name="homogeneous">False</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkToolButton" id="toolbuttonCalc">
+	      <property name="visible">True</property>
+	      <property name="tooltip" translatable="yes">Bitrate/size calculator</property>
+	      <property name="label" translatable="yes">Calculator</property>
+	      <property name="use_underline">True</property>
+	      <property name="icon">gnome-calculator.png</property>
+	      <property name="visible_horizontal">True</property>
+	      <property name="visible_vertical">True</property>
+	      <property name="is_important">True</property>
+	    </widget>
+	    <packing>
+	      <property name="expand">False</property>
+	      <property name="homogeneous">True</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkSeparatorToolItem" id="separatortoolitem2">
+	      <property name="visible">True</property>
+	      <property name="draw">True</property>
+	      <property name="visible_horizontal">True</property>
+	      <property name="visible_vertical">True</property>
+	    </widget>
+	    <packing>
+	      <property name="expand">False</property>
+	      <property name="homogeneous">False</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkToolItem" id="toolitem12">
+	      <property name="visible">True</property>
+	      <property name="visible_horizontal">True</property>
+	      <property name="visible_vertical">True</property>
+	      <property name="is_important">False</property>
+
+	      <child>
+		<widget class="GtkComboBox" id="comboboxPreview">
+		  <property name="visible">True</property>
+		  <property name="items" translatable="yes"></property>
+		  <property name="add_tearoffs">False</property>
+		  <property name="focus_on_click">True</property>
+		</widget>
+	      </child>
+	    </widget>
+	    <packing>
+	      <property name="expand">False</property>
+	      <property name="homogeneous">False</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkToolItem" id="toolitem13">
+	      <property name="visible">True</property>
+	      <property name="visible_horizontal">True</property>
+	      <property name="visible_vertical">True</property>
+	      <property name="is_important">False</property>
+
+	      <child>
+		<widget class="GtkToggleButton" id="togglebutton1">
+		  <property name="visible">True</property>
+		  <property name="can_focus">True</property>
+		  <property name="relief">GTK_RELIEF_NONE</property>
+		  <property name="focus_on_click">True</property>
+		  <property name="active">False</property>
+		  <property name="inconsistent">False</property>
+
+		  <child>
+		    <widget class="GtkImage" id="image8272">
+		      <property name="width_request">17</property>
+		      <property name="height_request">16</property>
+		      <property name="visible">True</property>
+		      <property name="pixbuf">audio-volume-medium.png</property>
+		      <property name="xalign">0.5</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xpad">0</property>
+		      <property name="ypad">0</property>
+		    </widget>
+		  </child>
+		</widget>
+	      </child>
+	    </widget>
+	    <packing>
+	      <property name="expand">False</property>
+	      <property name="homogeneous">False</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkToolItem" id="toolitem14">
+	      <property name="visible">True</property>
+	      <property name="visible_horizontal">True</property>
+	      <property name="visible_vertical">True</property>
+	      <property name="is_important">False</property>
+
+	      <child>
+		<widget class="GtkHScale" id="hscalVolume">
+		  <property name="width_request">100</property>
+		  <property name="visible">True</property>
+		  <property name="can_focus">True</property>
+		  <property name="draw_value">False</property>
+		  <property name="value_pos">GTK_POS_TOP</property>
+		  <property name="digits">0</property>
+		  <property name="update_policy">GTK_UPDATE_CONTINUOUS</property>
+		  <property name="inverted">False</property>
+		  <property name="adjustment">99 0 100 1 1 0</property>
+		</widget>
+	      </child>
+	    </widget>
+	    <packing>
+	      <property name="expand">False</property>
+	      <property name="homogeneous">False</property>
+	    </packing>
+	  </child>
+	</widget>
+	<packing>
+	  <property name="padding">0</property>
+	  <property name="expand">False</property>
+	  <property name="fill">False</property>
+	</packing>
+      </child>
+
+      <child>
+	<widget class="GtkVBox" id="vbox10">
+	  <property name="visible">True</property>
+	  <property name="homogeneous">False</property>
+	  <property name="spacing">3</property>
+
+	  <child>
+	    <widget class="GtkHBox" id="hbox14">
+	      <property name="visible">True</property>
+	      <property name="homogeneous">False</property>
+	      <property name="spacing">0</property>
+
+	      <child>
+		<widget class="GtkAlignment" id="alignment19">
+		  <property name="visible">True</property>
+		  <property name="xalign">0.5</property>
+		  <property name="yalign">0.5</property>
+		  <property name="xscale">1</property>
+		  <property name="yscale">1</property>
+		  <property name="top_padding">3</property>
+		  <property name="bottom_padding">0</property>
+		  <property name="left_padding">3</property>
+		  <property name="right_padding">0</property>
+
+		  <child>
+		    <widget class="GtkVBox" id="vbox9">
+		      <property name="visible">True</property>
+		      <property name="homogeneous">False</property>
+		      <property name="spacing">9</property>
+
+		      <child>
+			<widget class="GtkVBox" id="vbox11">
+			  <property name="visible">True</property>
+			  <property name="homogeneous">False</property>
+			  <property name="spacing">0</property>
+
+			  <child>
+			    <widget class="GtkLabel" id="label18">
+			      <property name="visible">True</property>
+			      <property name="label" translatable="yes">&lt;b&gt;Video&lt;/b&gt;</property>
+			      <property name="use_underline">False</property>
+			      <property name="use_markup">True</property>
+			      <property name="justify">GTK_JUSTIFY_LEFT</property>
+			      <property name="wrap">False</property>
+			      <property name="selectable">False</property>
+			      <property name="xalign">0</property>
+			      <property name="yalign">0.5</property>
+			      <property name="xpad">0</property>
+			      <property name="ypad">0</property>
+			      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+			      <property name="width_chars">-1</property>
+			      <property name="single_line_mode">False</property>
+			      <property name="angle">0</property>
+			    </widget>
+			    <packing>
+			      <property name="padding">0</property>
+			      <property name="expand">False</property>
+			      <property name="fill">False</property>
+			    </packing>
+			  </child>
+
+			  <child>
+			    <widget class="GtkAlignment" id="alignment12">
+			      <property name="visible">True</property>
+			      <property name="xalign">0.5</property>
+			      <property name="yalign">0.5</property>
+			      <property name="xscale">1</property>
+			      <property name="yscale">1</property>
+			      <property name="top_padding">3</property>
+			      <property name="bottom_padding">0</property>
+			      <property name="left_padding">12</property>
+			      <property name="right_padding">0</property>
+
+			      <child>
+				<widget class="GtkVBox" id="vbox7">
+				  <property name="visible">True</property>
+				  <property name="homogeneous">False</property>
+				  <property name="spacing">3</property>
+
+				  <child>
+				    <widget class="GtkComboBox" id="comboboxVideo">
+				      <property name="visible">True</property>
+				      <property name="items" translatable="yes">Copy</property>
+				      <property name="add_tearoffs">False</property>
+				      <property name="focus_on_click">True</property>
+				    </widget>
+				    <packing>
+				      <property name="padding">0</property>
+				      <property name="expand">False</property>
+				      <property name="fill">False</property>
+				    </packing>
+				  </child>
+
+				  <child>
+				    <widget class="GtkButton" id="buttonConfV">
+				      <property name="visible">True</property>
+				      <property name="tooltip" translatable="yes">Configure video encoder</property>
+				      <property name="can_focus">True</property>
+				      <property name="label" translatable="yes">Configure</property>
+				      <property name="use_underline">True</property>
+				      <property name="relief">GTK_RELIEF_NORMAL</property>
+				      <property name="focus_on_click">True</property>
+				      <accelerator key="F3" modifiers="0" signal="clicked"/>
+				    </widget>
+				    <packing>
+				      <property name="padding">0</property>
+				      <property name="expand">False</property>
+				      <property name="fill">False</property>
+				    </packing>
+				  </child>
+
+				  <child>
+				    <widget class="GtkButton" id="buttonFilters">
+				      <property name="visible">True</property>
+				      <property name="tooltip" translatable="yes">Video filters</property>
+				      <property name="can_focus">True</property>
+				      <property name="label" translatable="yes">Filters</property>
+				      <property name="use_underline">True</property>
+				      <property name="relief">GTK_RELIEF_NORMAL</property>
+				      <property name="focus_on_click">True</property>
+				      <accelerator key="F1" modifiers="0" signal="clicked"/>
+				    </widget>
+				    <packing>
+				      <property name="padding">0</property>
+				      <property name="expand">False</property>
+				      <property name="fill">False</property>
+				    </packing>
+				  </child>
+				</widget>
+			      </child>
+			    </widget>
+			    <packing>
+			      <property name="padding">0</property>
+			      <property name="expand">True</property>
+			      <property name="fill">True</property>
+			    </packing>
+			  </child>
+			</widget>
+			<packing>
+			  <property name="padding">0</property>
+			  <property name="expand">False</property>
+			  <property name="fill">False</property>
+			</packing>
+		      </child>
+
+		      <child>
+			<widget class="GtkVBox" id="vbox12">
+			  <property name="visible">True</property>
+			  <property name="homogeneous">False</property>
+			  <property name="spacing">0</property>
+
+			  <child>
+			    <widget class="GtkLabel" id="label19">
+			      <property name="visible">True</property>
+			      <property name="label" translatable="yes">&lt;b&gt;Audio&lt;/b&gt;</property>
+			      <property name="use_underline">False</property>
+			      <property name="use_markup">True</property>
+			      <property name="justify">GTK_JUSTIFY_LEFT</property>
+			      <property name="wrap">False</property>
+			      <property name="selectable">False</property>
+			      <property name="xalign">0</property>
+			      <property name="yalign">0.5</property>
+			      <property name="xpad">0</property>
+			      <property name="ypad">0</property>
+			      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+			      <property name="width_chars">-1</property>
+			      <property name="single_line_mode">False</property>
+			      <property name="angle">0</property>
+			    </widget>
+			    <packing>
+			      <property name="padding">0</property>
+			      <property name="expand">False</property>
+			      <property name="fill">False</property>
+			    </packing>
+			  </child>
+
+			  <child>
+			    <widget class="GtkAlignment" id="alignment13">
+			      <property name="visible">True</property>
+			      <property name="xalign">0.5</property>
+			      <property name="yalign">0.5</property>
+			      <property name="xscale">1</property>
+			      <property name="yscale">1</property>
+			      <property name="top_padding">3</property>
+			      <property name="bottom_padding">0</property>
+			      <property name="left_padding">12</property>
+			      <property name="right_padding">0</property>
+
+			      <child>
+				<widget class="GtkVBox" id="vbox8">
+				  <property name="visible">True</property>
+				  <property name="homogeneous">False</property>
+				  <property name="spacing">3</property>
+
+				  <child>
+				    <widget class="GtkComboBox" id="comboboxAudio">
+				      <property name="visible">True</property>
+				      <property name="items" translatable="yes">Copy</property>
+				      <property name="add_tearoffs">False</property>
+				      <property name="focus_on_click">True</property>
+				    </widget>
+				    <packing>
+				      <property name="padding">0</property>
+				      <property name="expand">False</property>
+				      <property name="fill">False</property>
+				    </packing>
+				  </child>
+
+				  <child>
+				    <widget class="GtkButton" id="buttonConfA">
+				      <property name="visible">True</property>
+				      <property name="tooltip" translatable="yes">Configure audio encoder</property>
+				      <property name="can_focus">True</property>
+				      <property name="label" translatable="yes">Configure</property>
+				      <property name="use_underline">True</property>
+				      <property name="relief">GTK_RELIEF_NORMAL</property>
+				      <property name="focus_on_click">True</property>
+				      <accelerator key="F4" modifiers="0" signal="clicked"/>
+				    </widget>
+				    <packing>
+				      <property name="padding">0</property>
+				      <property name="expand">False</property>
+				      <property name="fill">False</property>
+				    </packing>
+				  </child>
+
+				  <child>
+				    <widget class="GtkButton" id="buttonAudioFilter">
+				      <property name="visible">True</property>
+				      <property name="tooltip" translatable="yes">Audio filters</property>
+				      <property name="can_focus">True</property>
+				      <property name="relief">GTK_RELIEF_NORMAL</property>
+				      <property name="focus_on_click">True</property>
+				      <accelerator key="F2" modifiers="0" signal="clicked"/>
+
+				      <child>
+					<widget class="GtkAlignment" id="alignment16">
+					  <property name="visible">True</property>
+					  <property name="xalign">0.5</property>
+					  <property name="yalign">0.5</property>
+					  <property name="xscale">0</property>
+					  <property name="yscale">0</property>
+					  <property name="top_padding">0</property>
+					  <property name="bottom_padding">0</property>
+					  <property name="left_padding">0</property>
+					  <property name="right_padding">0</property>
+
+					  <child>
+					    <widget class="GtkHBox" id="hbox18">
+					      <property name="visible">True</property>
+					      <property name="homogeneous">False</property>
+					      <property name="spacing">2</property>
+
+					      <child>
+						<widget class="GtkLabel" id="label22">
+						  <property name="visible">True</property>
+						  <property name="label" translatable="yes">Filters</property>
+						  <property name="use_underline">True</property>
+						  <property name="use_markup">False</property>
+						  <property name="justify">GTK_JUSTIFY_LEFT</property>
+						  <property name="wrap">False</property>
+						  <property name="selectable">False</property>
+						  <property name="xalign">0.5</property>
+						  <property name="yalign">0.5</property>
+						  <property name="xpad">0</property>
+						  <property name="ypad">0</property>
+						  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+						  <property name="width_chars">-1</property>
+						  <property name="single_line_mode">False</property>
+						  <property name="angle">0</property>
+						</widget>
+						<packing>
+						  <property name="padding">0</property>
+						  <property name="expand">False</property>
+						  <property name="fill">False</property>
+						</packing>
+					      </child>
+					    </widget>
+					  </child>
+					</widget>
+				      </child>
+				    </widget>
+				    <packing>
+				      <property name="padding">0</property>
+				      <property name="expand">False</property>
+				      <property name="fill">False</property>
+				    </packing>
+				  </child>
+
+				  <child>
+				    <widget class="GtkHBox" id="hbox19">
+				      <property name="visible">True</property>
+				      <property name="homogeneous">False</property>
+				      <property name="spacing">6</property>
+
+				      <child>
+					<widget class="GtkCheckButton" id="CheckButtonTimeshift">
+					  <property name="visible">True</property>
+					  <property name="tooltip" translatable="yes">Enable time shift</property>
+					  <property name="can_focus">True</property>
+					  <property name="label" translatable="yes">Shift:</property>
+					  <property name="use_underline">True</property>
+					  <property name="relief">GTK_RELIEF_NORMAL</property>
+					  <property name="focus_on_click">True</property>
+					  <property name="active">False</property>
+					  <property name="inconsistent">False</property>
+					  <property name="draw_indicator">True</property>
+					</widget>
+					<packing>
+					  <property name="padding">0</property>
+					  <property name="expand">False</property>
+					  <property name="fill">False</property>
+					</packing>
+				      </child>
+
+				      <child>
+					<widget class="GtkSpinButton" id="spinbuttonTimeShift">
+					  <property name="visible">True</property>
+					  <property name="tooltip" translatable="yes">Audio/video time shift (ms)</property>
+					  <property name="can_focus">True</property>
+					  <property name="climb_rate">1</property>
+					  <property name="digits">0</property>
+					  <property name="numeric">True</property>
+					  <property name="update_policy">GTK_UPDATE_ALWAYS</property>
+					  <property name="snap_to_ticks">False</property>
+					  <property name="wrap">False</property>
+					  <property name="adjustment">0 -99999 99999 1 10 0</property>
+					</widget>
+					<packing>
+					  <property name="padding">0</property>
+					  <property name="expand">True</property>
+					  <property name="fill">True</property>
+					</packing>
+				      </child>
+
+				      <child>
+					<widget class="GtkLabel" id="label23">
+					  <property name="visible">True</property>
+					  <property name="label" translatable="yes">ms</property>
+					  <property name="use_underline">False</property>
+					  <property name="use_markup">False</property>
+					  <property name="justify">GTK_JUSTIFY_LEFT</property>
+					  <property name="wrap">False</property>
+					  <property name="selectable">False</property>
+					  <property name="xalign">0.5</property>
+					  <property name="yalign">0.5</property>
+					  <property name="xpad">0</property>
+					  <property name="ypad">0</property>
+					  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+					  <property name="width_chars">-1</property>
+					  <property name="single_line_mode">False</property>
+					  <property name="angle">0</property>
+					</widget>
+					<packing>
+					  <property name="padding">0</property>
+					  <property name="expand">False</property>
+					  <property name="fill">False</property>
+					</packing>
+				      </child>
+				    </widget>
+				    <packing>
+				      <property name="padding">0</property>
+				      <property name="expand">True</property>
+				      <property name="fill">True</property>
+				    </packing>
+				  </child>
+				</widget>
+			      </child>
+			    </widget>
+			    <packing>
+			      <property name="padding">0</property>
+			      <property name="expand">True</property>
+			      <property name="fill">True</property>
+			    </packing>
+			  </child>
+			</widget>
+			<packing>
+			  <property name="padding">0</property>
+			  <property name="expand">False</property>
+			  <property name="fill">False</property>
+			</packing>
+		      </child>
+
+		      <child>
+			<widget class="GtkVBox" id="vbox13">
+			  <property name="visible">True</property>
+			  <property name="homogeneous">False</property>
+			  <property name="spacing">4</property>
+
+			  <child>
+			    <widget class="GtkLabel" id="label20">
+			      <property name="visible">True</property>
+			      <property name="label" translatable="yes">&lt;b&gt;Format&lt;/b&gt;</property>
+			      <property name="use_underline">False</property>
+			      <property name="use_markup">True</property>
+			      <property name="justify">GTK_JUSTIFY_LEFT</property>
+			      <property name="wrap">False</property>
+			      <property name="selectable">False</property>
+			      <property name="xalign">0</property>
+			      <property name="yalign">0.5</property>
+			      <property name="xpad">0</property>
+			      <property name="ypad">0</property>
+			      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+			      <property name="width_chars">-1</property>
+			      <property name="single_line_mode">False</property>
+			      <property name="angle">0</property>
+			    </widget>
+			    <packing>
+			      <property name="padding">0</property>
+			      <property name="expand">False</property>
+			      <property name="fill">False</property>
+			    </packing>
+			  </child>
+
+			  <child>
+			    <widget class="GtkAlignment" id="alignment14">
+			      <property name="visible">True</property>
+			      <property name="xalign">0.5</property>
+			      <property name="yalign">0.5</property>
+			      <property name="xscale">1</property>
+			      <property name="yscale">1</property>
+			      <property name="top_padding">3</property>
+			      <property name="bottom_padding">0</property>
+			      <property name="left_padding">12</property>
+			      <property name="right_padding">0</property>
+
+			      <child>
+				<widget class="GtkVBox" id="vbox15">
+				  <property name="visible">True</property>
+				  <property name="homogeneous">False</property>
+				  <property name="spacing">4</property>
+
+				  <child>
+				    <widget class="GtkComboBox" id="comboboxFormat">
+				      <property name="visible">True</property>
+				      <property name="add_tearoffs">False</property>
+				      <property name="focus_on_click">True</property>
+				    </widget>
+				    <packing>
+				      <property name="padding">0</property>
+				      <property name="expand">True</property>
+				      <property name="fill">True</property>
+				    </packing>
+				  </child>
+
+				  <child>
+				    <widget class="GtkButton" id="buttonConfM">
+				      <property name="visible">True</property>
+				      <property name="can_focus">True</property>
+				      <property name="label" translatable="yes">Configure</property>
+				      <property name="use_underline">True</property>
+				      <property name="relief">GTK_RELIEF_NORMAL</property>
+				      <property name="focus_on_click">True</property>
+				    </widget>
+				    <packing>
+				      <property name="padding">0</property>
+				      <property name="expand">False</property>
+				      <property name="fill">False</property>
+				    </packing>
+				  </child>
+				</widget>
+			      </child>
+			    </widget>
+			    <packing>
+			      <property name="padding">0</property>
+			      <property name="expand">True</property>
+			      <property name="fill">True</property>
+			    </packing>
+			  </child>
+			</widget>
+			<packing>
+			  <property name="padding">0</property>
+			  <property name="expand">False</property>
+			  <property name="fill">False</property>
+			</packing>
+		      </child>
+		    </widget>
+		  </child>
+		</widget>
+		<packing>
+		  <property name="padding">0</property>
+		  <property name="expand">False</property>
+		  <property name="fill">False</property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkDrawingArea" id="guiDrawing">
+		  <property name="width_request">496</property>
+		  <property name="height_request">288</property>
+		  <property name="visible">True</property>
+		  <property name="sensitive">False</property>
+		</widget>
+		<packing>
+		  <property name="padding">0</property>
+		  <property name="expand">True</property>
+		  <property name="fill">True</property>
+		</packing>
+	      </child>
+	    </widget>
+	    <packing>
+	      <property name="padding">0</property>
+	      <property name="expand">True</property>
+	      <property name="fill">True</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkTable" id="table2">
+	      <property name="border_width">3</property>
+	      <property name="visible">True</property>
+	      <property name="n_rows">3</property>
+	      <property name="n_columns">2</property>
+	      <property name="homogeneous">False</property>
+	      <property name="row_spacing">0</property>
+	      <property name="column_spacing">6</property>
+
+	      <child>
+		<widget class="GtkHBox" id="hbox16">
+		  <property name="visible">True</property>
+		  <property name="homogeneous">False</property>
+		  <property name="spacing">6</property>
+
+		  <child>
+		    <widget class="GtkLabel" id="label1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Frame: </property>
+		      <property name="use_underline">False</property>
+		      <property name="use_markup">False</property>
+		      <property name="justify">GTK_JUSTIFY_LEFT</property>
+		      <property name="wrap">False</property>
+		      <property name="selectable">False</property>
+		      <property name="xalign">0.5</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xpad">0</property>
+		      <property name="ypad">0</property>
+		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		      <property name="width_chars">-1</property>
+		      <property name="single_line_mode">False</property>
+		      <property name="angle">0</property>
+		    </widget>
+		    <packing>
+		      <property name="padding">0</property>
+		      <property name="expand">False</property>
+		      <property name="fill">False</property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkEntry" id="boxCurFrame">
+		      <property name="visible">True</property>
+		      <property name="tooltip" translatable="yes">Current frame</property>
+		      <property name="can_focus">True</property>
+		      <property name="editable">True</property>
+		      <property name="visibility">True</property>
+		      <property name="max_length">8</property>
+		      <property name="text" translatable="yes">0</property>
+		      <property name="has_frame">True</property>
+		      <property name="invisible_char">*</property>
+		      <property name="activates_default">False</property>
+		      <property name="width_chars">8</property>
+		    </widget>
+		    <packing>
+		      <property name="padding">0</property>
+		      <property name="expand">False</property>
+		      <property name="fill">False</property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkLabel" id="labelTotalFrame">
+		      <property name="visible">True</property>
+		      <property name="can_focus">True</property>
+		      <property name="label" translatable="yes">/ 0000000</property>
+		      <property name="use_underline">False</property>
+		      <property name="use_markup">False</property>
+		      <property name="justify">GTK_JUSTIFY_LEFT</property>
+		      <property name="wrap">False</property>
+		      <property name="selectable">True</property>
+		      <property name="xalign">0.5</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xpad">5</property>
+		      <property name="ypad">0</property>
+		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		      <property name="width_chars">-1</property>
+		      <property name="single_line_mode">False</property>
+		      <property name="angle">0</property>
+		    </widget>
+		    <packing>
+		      <property name="padding">0</property>
+		      <property name="expand">False</property>
+		      <property name="fill">False</property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkLabel" id="label4">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Time: </property>
+		      <property name="use_underline">False</property>
+		      <property name="use_markup">False</property>
+		      <property name="justify">GTK_JUSTIFY_LEFT</property>
+		      <property name="wrap">False</property>
+		      <property name="selectable">False</property>
+		      <property name="xalign">0.5</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xpad">0</property>
+		      <property name="ypad">0</property>
+		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		      <property name="width_chars">-1</property>
+		      <property name="single_line_mode">False</property>
+		      <property name="angle">0</property>
+		    </widget>
+		    <packing>
+		      <property name="padding">0</property>
+		      <property name="expand">False</property>
+		      <property name="fill">False</property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkEntry" id="boxCurTime">
+		      <property name="visible">True</property>
+		      <property name="tooltip" translatable="yes">Current time</property>
+		      <property name="can_focus">True</property>
+		      <property name="editable">True</property>
+		      <property name="visibility">True</property>
+		      <property name="max_length">0</property>
+		      <property name="text" translatable="yes">00:00:00.000</property>
+		      <property name="has_frame">True</property>
+		      <property name="invisible_char">*</property>
+		      <property name="activates_default">False</property>
+		      <property name="width_chars">13</property>
+		    </widget>
+		    <packing>
+		      <property name="padding">0</property>
+		      <property name="expand">False</property>
+		      <property name="fill">False</property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkLabel" id="labelTotalTime">
+		      <property name="visible">True</property>
+		      <property name="can_focus">True</property>
+		      <property name="label" translatable="yes">/ 00:00:00,000</property>
+		      <property name="use_underline">False</property>
+		      <property name="use_markup">False</property>
+		      <property name="justify">GTK_JUSTIFY_LEFT</property>
+		      <property name="wrap">False</property>
+		      <property name="selectable">True</property>
+		      <property name="xalign">0.5</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xpad">5</property>
+		      <property name="ypad">0</property>
+		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		      <property name="width_chars">-1</property>
+		      <property name="single_line_mode">False</property>
+		      <property name="angle">0</property>
+		    </widget>
+		    <packing>
+		      <property name="padding">0</property>
+		      <property name="expand">False</property>
+		      <property name="fill">False</property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkLabel" id="labelFrameType">
+		      <property name="visible">True</property>
+		      <property name="can_focus">True</property>
+		      <property name="label" translatable="yes">Frame: ?</property>
+		      <property name="use_underline">False</property>
+		      <property name="use_markup">False</property>
+		      <property name="justify">GTK_JUSTIFY_LEFT</property>
+		      <property name="wrap">False</property>
+		      <property name="selectable">True</property>
+		      <property name="xalign">0.5</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xpad">0</property>
+		      <property name="ypad">0</property>
+		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		      <property name="width_chars">-1</property>
+		      <property name="single_line_mode">False</property>
+		      <property name="angle">0</property>
+		    </widget>
+		    <packing>
+		      <property name="padding">0</property>
+		      <property name="expand">False</property>
+		      <property name="fill">False</property>
+		    </packing>
+		  </child>
+		</widget>
+		<packing>
+		  <property name="left_attach">0</property>
+		  <property name="right_attach">1</property>
+		  <property name="top_attach">2</property>
+		  <property name="bottom_attach">3</property>
+		  <property name="y_options"></property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkHScale" id="sliderNavigate">
+		  <property name="visible">True</property>
+		  <property name="draw_value">True</property>
+		  <property name="value_pos">GTK_POS_LEFT</property>
+		  <property name="digits">1</property>
+		  <property name="update_policy">GTK_UPDATE_CONTINUOUS</property>
+		  <property name="inverted">False</property>
+		  <property name="adjustment">0 0 99.9899978638 0.00999999977648 1 0</property>
+		</widget>
+		<packing>
+		  <property name="left_attach">0</property>
+		  <property name="right_attach">1</property>
+		  <property name="top_attach">0</property>
+		  <property name="bottom_attach">1</property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkHBox" id="hbox10">
+		  <property name="visible">True</property>
+		  <property name="homogeneous">False</property>
+		  <property name="spacing">0</property>
+
+		  <child>
+		    <widget class="GtkButton" id="buttonPlay">
+		      <property name="visible">True</property>
+		      <property name="tooltip" translatable="yes">Play</property>
+		      <property name="relief">GTK_RELIEF_NONE</property>
+		      <property name="focus_on_click">False</property>
+		      <accelerator key="space" modifiers="0" signal="clicked"/>
+
+		      <child>
+			<widget class="GtkImage" id="image591">
+			  <property name="visible">True</property>
+			  <property name="pixbuf">play.xpm</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		    <packing>
+		      <property name="padding">0</property>
+		      <property name="expand">False</property>
+		      <property name="fill">False</property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkButton" id="buttonStop">
+		      <property name="visible">True</property>
+		      <property name="tooltip" translatable="yes">Stop</property>
+		      <property name="can_focus">True</property>
+		      <property name="relief">GTK_RELIEF_NONE</property>
+		      <property name="focus_on_click">False</property>
+
+		      <child>
+			<widget class="GtkImage" id="image5056">
+			  <property name="visible">True</property>
+			  <property name="pixbuf">stop.xpm</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		    <packing>
+		      <property name="padding">0</property>
+		      <property name="expand">False</property>
+		      <property name="fill">False</property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkButton" id="buttonPrevFrame">
+		      <property name="visible">True</property>
+		      <property name="tooltip" translatable="yes">Previous frame</property>
+		      <property name="relief">GTK_RELIEF_NONE</property>
+		      <property name="focus_on_click">False</property>
+		      <accelerator key="KP_4" modifiers="0" signal="clicked"/>
+
+		      <child>
+			<widget class="GtkImage" id="image593">
+			  <property name="visible">True</property>
+			  <property name="pixbuf">backward.xpm</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		    <packing>
+		      <property name="padding">0</property>
+		      <property name="expand">False</property>
+		      <property name="fill">False</property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkButton" id="buttonNextFrame">
+		      <property name="visible">True</property>
+		      <property name="tooltip" translatable="yes">Next frame</property>
+		      <property name="relief">GTK_RELIEF_NONE</property>
+		      <property name="focus_on_click">False</property>
+		      <accelerator key="KP_6" modifiers="0" signal="clicked"/>
+
+		      <child>
+			<widget class="GtkImage" id="image594">
+			  <property name="visible">True</property>
+			  <property name="pixbuf">forward.xpm</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		    <packing>
+		      <property name="padding">0</property>
+		      <property name="expand">False</property>
+		      <property name="fill">False</property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkButton" id="buttonPrevKFrame">
+		      <property name="visible">True</property>
+		      <property name="tooltip" translatable="yes">Previous keyframe</property>
+		      <property name="relief">GTK_RELIEF_NONE</property>
+		      <property name="focus_on_click">False</property>
+		      <accelerator key="KP_2" modifiers="0" signal="clicked"/>
+
+		      <child>
+			<widget class="GtkImage" id="image595">
+			  <property name="visible">True</property>
+			  <property name="pixbuf">Kbackward.xpm</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		    <packing>
+		      <property name="padding">0</property>
+		      <property name="expand">False</property>
+		      <property name="fill">False</property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkButton" id="buttonNextKFrame">
+		      <property name="visible">True</property>
+		      <property name="tooltip" translatable="yes">Next keyframe</property>
+		      <property name="relief">GTK_RELIEF_NONE</property>
+		      <property name="focus_on_click">False</property>
+		      <accelerator key="KP_8" modifiers="0" signal="clicked"/>
+
+		      <child>
+			<widget class="GtkImage" id="image596">
+			  <property name="visible">True</property>
+			  <property name="pixbuf">Kforward.xpm</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		    <packing>
+		      <property name="padding">0</property>
+		      <property name="expand">False</property>
+		      <property name="fill">False</property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkButton" id="buttonMarkA">
+		      <property name="visible">True</property>
+		      <property name="tooltip" translatable="yes">Selection: start</property>
+		      <property name="can_focus">True</property>
+		      <property name="relief">GTK_RELIEF_NONE</property>
+		      <property name="focus_on_click">False</property>
+
+		      <child>
+			<widget class="GtkImage" id="image2306">
+			  <property name="visible">True</property>
+			  <property name="pixbuf">markA.xpm</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		    <packing>
+		      <property name="padding">0</property>
+		      <property name="expand">False</property>
+		      <property name="fill">False</property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkButton" id="buttonMarkB">
+		      <property name="visible">True</property>
+		      <property name="tooltip" translatable="yes">Selection: end</property>
+		      <property name="can_focus">True</property>
+		      <property name="relief">GTK_RELIEF_NONE</property>
+		      <property name="focus_on_click">False</property>
+
+		      <child>
+			<widget class="GtkImage" id="image2307">
+			  <property name="visible">True</property>
+			  <property name="pixbuf">markB.xpm</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		    <packing>
+		      <property name="padding">0</property>
+		      <property name="expand">False</property>
+		      <property name="fill">False</property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkButton" id="buttonPrevBlack">
+		      <property name="visible">True</property>
+		      <property name="tooltip" translatable="yes">Previous black frame</property>
+		      <property name="can_focus">True</property>
+		      <property name="relief">GTK_RELIEF_NONE</property>
+		      <property name="focus_on_click">False</property>
+
+		      <child>
+			<widget class="GtkImage" id="image2308">
+			  <property name="visible">True</property>
+			  <property name="pixbuf">xpm_prevblack.xpm</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		    <packing>
+		      <property name="padding">0</property>
+		      <property name="expand">False</property>
+		      <property name="fill">False</property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkButton" id="buttonNextBlack">
+		      <property name="visible">True</property>
+		      <property name="tooltip" translatable="yes">Next black frame</property>
+		      <property name="can_focus">True</property>
+		      <property name="relief">GTK_RELIEF_NONE</property>
+		      <property name="focus_on_click">False</property>
+
+		      <child>
+			<widget class="GtkImage" id="image2309">
+			  <property name="visible">True</property>
+			  <property name="pixbuf">xpm_nextblack.xpm</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		    <packing>
+		      <property name="padding">0</property>
+		      <property name="expand">False</property>
+		      <property name="fill">False</property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkButton" id="buttonBegin">
+		      <property name="visible">True</property>
+		      <property name="tooltip" translatable="yes">First frame</property>
+		      <property name="can_focus">True</property>
+		      <property name="relief">GTK_RELIEF_NONE</property>
+		      <property name="focus_on_click">False</property>
+
+		      <child>
+			<widget class="GtkImage" id="image5057">
+			  <property name="visible">True</property>
+			  <property name="pixbuf">begin.xpm</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		    <packing>
+		      <property name="padding">0</property>
+		      <property name="expand">False</property>
+		      <property name="fill">False</property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkButton" id="buttonEnd">
+		      <property name="visible">True</property>
+		      <property name="tooltip" translatable="yes">Last frame</property>
+		      <property name="can_focus">True</property>
+		      <property name="relief">GTK_RELIEF_NONE</property>
+		      <property name="focus_on_click">False</property>
+
+		      <child>
+			<widget class="GtkImage" id="image2245">
+			  <property name="visible">True</property>
+			  <property name="pixbuf">end.xpm</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		    <packing>
+		      <property name="padding">0</property>
+		      <property name="expand">False</property>
+		      <property name="fill">False</property>
+		    </packing>
+		  </child>
+		</widget>
+		<packing>
+		  <property name="left_attach">0</property>
+		  <property name="right_attach">1</property>
+		  <property name="top_attach">1</property>
+		  <property name="bottom_attach">2</property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkVBox" id="vbox14">
+		  <property name="visible">True</property>
+		  <property name="homogeneous">False</property>
+		  <property name="spacing">0</property>
+
+		  <child>
+		    <widget class="GtkLabel" id="label21">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">&lt;b&gt;Selection&lt;/b&gt;</property>
+		      <property name="use_underline">False</property>
+		      <property name="use_markup">True</property>
+		      <property name="justify">GTK_JUSTIFY_LEFT</property>
+		      <property name="wrap">False</property>
+		      <property name="selectable">False</property>
+		      <property name="xalign">0</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xpad">0</property>
+		      <property name="ypad">0</property>
+		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		      <property name="width_chars">-1</property>
+		      <property name="single_line_mode">False</property>
+		      <property name="angle">0</property>
+		    </widget>
+		    <packing>
+		      <property name="padding">0</property>
+		      <property name="expand">False</property>
+		      <property name="fill">False</property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkAlignment" id="alignment15">
+		      <property name="visible">True</property>
+		      <property name="xalign">0.5</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xscale">1</property>
+		      <property name="yscale">1</property>
+		      <property name="top_padding">3</property>
+		      <property name="bottom_padding">0</property>
+		      <property name="left_padding">12</property>
+		      <property name="right_padding">0</property>
+
+		      <child>
+			<widget class="GtkTable" id="table1">
+			  <property name="visible">True</property>
+			  <property name="n_rows">2</property>
+			  <property name="n_columns">2</property>
+			  <property name="homogeneous">False</property>
+			  <property name="row_spacing">3</property>
+			  <property name="column_spacing">3</property>
+
+			  <child>
+			    <widget class="GtkButton" id="buttonGotoB">
+			      <property name="height_request">20</property>
+			      <property name="visible">True</property>
+			      <property name="tooltip" translatable="yes">Go to marker B</property>
+			      <property name="label" translatable="yes">B:</property>
+			      <property name="use_underline">True</property>
+			      <property name="relief">GTK_RELIEF_NORMAL</property>
+			      <property name="focus_on_click">True</property>
+			    </widget>
+			    <packing>
+			      <property name="left_attach">0</property>
+			      <property name="right_attach">1</property>
+			      <property name="top_attach">1</property>
+			      <property name="bottom_attach">2</property>
+			      <property name="x_options"></property>
+			      <property name="y_options"></property>
+			    </packing>
+			  </child>
+
+			  <child>
+			    <widget class="GtkButton" id="buttonGotoA">
+			      <property name="height_request">20</property>
+			      <property name="visible">True</property>
+			      <property name="tooltip" translatable="yes">Go to marker A</property>
+			      <property name="label" translatable="yes">A:</property>
+			      <property name="use_underline">True</property>
+			      <property name="relief">GTK_RELIEF_NORMAL</property>
+			      <property name="focus_on_click">True</property>
+			    </widget>
+			    <packing>
+			      <property name="left_attach">0</property>
+			      <property name="right_attach">1</property>
+			      <property name="top_attach">0</property>
+			      <property name="bottom_attach">1</property>
+			      <property name="x_options"></property>
+			      <property name="y_options"></property>
+			    </packing>
+			  </child>
+
+			  <child>
+			    <widget class="GtkLabel" id="labelMarkB">
+			      <property name="visible">True</property>
+			      <property name="can_focus">True</property>
+			      <property name="label" translatable="yes"> 0000000</property>
+			      <property name="use_underline">False</property>
+			      <property name="use_markup">False</property>
+			      <property name="justify">GTK_JUSTIFY_LEFT</property>
+			      <property name="wrap">False</property>
+			      <property name="selectable">True</property>
+			      <property name="xalign">0.5</property>
+			      <property name="yalign">0.5</property>
+			      <property name="xpad">0</property>
+			      <property name="ypad">0</property>
+			      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+			      <property name="width_chars">-1</property>
+			      <property name="single_line_mode">False</property>
+			      <property name="angle">0</property>
+			    </widget>
+			    <packing>
+			      <property name="left_attach">1</property>
+			      <property name="right_attach">2</property>
+			      <property name="top_attach">1</property>
+			      <property name="bottom_attach">2</property>
+			      <property name="x_options"></property>
+			      <property name="y_options"></property>
+			    </packing>
+			  </child>
+
+			  <child>
+			    <widget class="GtkLabel" id="labelMarkA">
+			      <property name="visible">True</property>
+			      <property name="can_focus">True</property>
+			      <property name="label" translatable="yes"> 0000000</property>
+			      <property name="use_underline">False</property>
+			      <property name="use_markup">False</property>
+			      <property name="justify">GTK_JUSTIFY_LEFT</property>
+			      <property name="wrap">False</property>
+			      <property name="selectable">True</property>
+			      <property name="xalign">0.5</property>
+			      <property name="yalign">0.5</property>
+			      <property name="xpad">0</property>
+			      <property name="ypad">0</property>
+			      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+			      <property name="width_chars">-1</property>
+			      <property name="single_line_mode">False</property>
+			      <property name="angle">0</property>
+			    </widget>
+			    <packing>
+			      <property name="left_attach">1</property>
+			      <property name="right_attach">2</property>
+			      <property name="top_attach">0</property>
+			      <property name="bottom_attach">1</property>
+			      <property name="x_options"></property>
+			      <property name="y_options"></property>
+			    </packing>
+			  </child>
+			</widget>
+		      </child>
+		    </widget>
+		    <packing>
+		      <property name="padding">0</property>
+		      <property name="expand">True</property>
+		      <property name="fill">True</property>
+		    </packing>
+		  </child>
+		</widget>
+		<packing>
+		  <property name="left_attach">1</property>
+		  <property name="right_attach">2</property>
+		  <property name="top_attach">1</property>
+		  <property name="bottom_attach">3</property>
+		  <property name="x_options"></property>
+		  <property name="y_options"></property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="Custom" id="jogg">
+		  <property name="visible">True</property>
+		  <property name="creation_function">jog_shuttle_new</property>
+		  <property name="int1">0</property>
+		  <property name="int2">0</property>
+		  <property name="last_modification_time">Sun, 07 Oct 2007 12:58:40 GMT</property>
+		</widget>
+		<packing>
+		  <property name="left_attach">1</property>
+		  <property name="right_attach">2</property>
+		  <property name="top_attach">0</property>
+		  <property name="bottom_attach">1</property>
+		  <property name="x_options">fill</property>
+		  <property name="y_options">expand</property>
+		</packing>
+	      </child>
+	    </widget>
+	    <packing>
+	      <property name="padding">0</property>
+	      <property name="expand">False</property>
+	      <property name="fill">False</property>
+	    </packing>
+	  </child>
+	</widget>
+	<packing>
+	  <property name="padding">0</property>
+	  <property name="expand">True</property>
+	  <property name="fill">True</property>
+	</packing>
+      </child>
+    </widget>
+  </child>
+</widget>
+
+</glade-interface>

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/Q_gui2.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/Q_gui2.cpp	2010-01-01 18:40:56 UTC (rev 5804)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/Q_gui2.cpp	2010-01-02 12:45:44 UTC (rev 5805)
@@ -140,6 +140,16 @@
 		else
 		{
 			ui.comboBoxVideo->setEnabled(true);
+
+			for (int i = 0; i < ADM_FORMAT_MAX; i++)
+			{
+				if (ADM_allOutputFormat[i].format == fmt)
+				{
+					ui.pushButtonMuxerConf->setEnabled((ADM_allOutputFormat[i].muxerConfigure != NULL));
+
+					break;
+				}
+			}
 		}
 	}
 }

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/gui2.ui
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/gui2.ui	2010-01-01 18:40:56 UTC (rev 5804)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/gui2.ui	2010-01-02 12:45:44 UTC (rev 5805)
@@ -7,7 +7,7 @@
     <x>0</x>
     <y>0</y>
     <width>709</width>
-    <height>526</height>
+    <height>545</height>
    </rect>
   </property>
   <property name="windowTitle" >
@@ -77,18 +77,6 @@
           </property>
           <item>
            <widget class="QLabel" name="label_3" >
-            <property name="sizePolicy" >
-             <sizepolicy vsizetype="Preferred" hsizetype="Preferred" >
-              <horstretch>0</horstretch>
-              <verstretch>0</verstretch>
-             </sizepolicy>
-            </property>
-            <property name="maximumSize" >
-             <size>
-              <width>180</width>
-              <height>16777215</height>
-             </size>
-            </property>
             <property name="font" >
              <font>
               <weight>75</weight>
@@ -171,12 +159,6 @@
               </property>
               <item>
                <widget class="QComboBox" name="comboBoxVideo" >
-                <property name="sizePolicy" >
-                 <sizepolicy vsizetype="Fixed" hsizetype="Minimum" >
-                  <horstretch>0</horstretch>
-                  <verstretch>0</verstretch>
-                 </sizepolicy>
-                </property>
                 <property name="maxVisibleItems" >
                  <number>20</number>
                 </property>
@@ -189,15 +171,6 @@
               </item>
               <item>
                <widget class="QPushButton" name="pushButtonVideoConf" >
-                <property name="enabled" >
-                 <bool>true</bool>
-                </property>
-                <property name="sizePolicy" >
-                 <sizepolicy vsizetype="Fixed" hsizetype="Minimum" >
-                  <horstretch>0</horstretch>
-                  <verstretch>0</verstretch>
-                 </sizepolicy>
-                </property>
                 <property name="text" >
                  <string>Configure</string>
                 </property>
@@ -205,15 +178,6 @@
               </item>
               <item>
                <widget class="QPushButton" name="pushButtonVideoFilter" >
-                <property name="enabled" >
-                 <bool>true</bool>
-                </property>
-                <property name="sizePolicy" >
-                 <sizepolicy vsizetype="Fixed" hsizetype="Minimum" >
-                  <horstretch>0</horstretch>
-                  <verstretch>0</verstretch>
-                 </sizepolicy>
-                </property>
                 <property name="text" >
                  <string>Filters</string>
                 </property>
@@ -241,18 +205,6 @@
           </item>
           <item>
            <widget class="QLabel" name="label_5" >
-            <property name="sizePolicy" >
-             <sizepolicy vsizetype="Preferred" hsizetype="Preferred" >
-              <horstretch>0</horstretch>
-              <verstretch>0</verstretch>
-             </sizepolicy>
-            </property>
-            <property name="maximumSize" >
-             <size>
-              <width>180</width>
-              <height>16777215</height>
-             </size>
-            </property>
             <property name="font" >
              <font>
               <weight>75</weight>
@@ -335,12 +287,6 @@
               </property>
               <item>
                <widget class="QComboBox" name="comboBoxAudio" >
-                <property name="sizePolicy" >
-                 <sizepolicy vsizetype="Fixed" hsizetype="Minimum" >
-                  <horstretch>0</horstretch>
-                  <verstretch>0</verstretch>
-                 </sizepolicy>
-                </property>
                 <property name="maxVisibleItems" >
                  <number>20</number>
                 </property>
@@ -353,15 +299,6 @@
               </item>
               <item>
                <widget class="QPushButton" name="pushButtonAudioConf" >
-                <property name="enabled" >
-                 <bool>true</bool>
-                </property>
-                <property name="sizePolicy" >
-                 <sizepolicy vsizetype="Fixed" hsizetype="Minimum" >
-                  <horstretch>0</horstretch>
-                  <verstretch>0</verstretch>
-                 </sizepolicy>
-                </property>
                 <property name="text" >
                  <string>Configure</string>
                 </property>
@@ -369,15 +306,6 @@
               </item>
               <item>
                <widget class="QPushButton" name="pushButtonAudioFilter" >
-                <property name="enabled" >
-                 <bool>true</bool>
-                </property>
-                <property name="sizePolicy" >
-                 <sizepolicy vsizetype="Fixed" hsizetype="Minimum" >
-                  <horstretch>0</horstretch>
-                  <verstretch>0</verstretch>
-                 </sizepolicy>
-                </property>
                 <property name="text" >
                  <string>Filters</string>
                 </property>
@@ -460,12 +388,6 @@
           </item>
           <item>
            <widget class="QLabel" name="label_4" >
-            <property name="sizePolicy" >
-             <sizepolicy vsizetype="Preferred" hsizetype="Preferred" >
-              <horstretch>0</horstretch>
-              <verstretch>0</verstretch>
-             </sizepolicy>
-            </property>
             <property name="font" >
              <font>
               <weight>75</weight>
@@ -530,17 +452,37 @@
              </spacer>
             </item>
             <item>
-             <widget class="QComboBox" name="comboBoxFormat" >
-              <property name="sizePolicy" >
-               <sizepolicy vsizetype="Fixed" hsizetype="Minimum" >
-                <horstretch>0</horstretch>
-                <verstretch>0</verstretch>
-               </sizepolicy>
+             <layout class="QVBoxLayout" >
+              <property name="spacing" >
+               <number>6</number>
               </property>
-              <property name="maxVisibleItems" >
-               <number>20</number>
+              <property name="leftMargin" >
+               <number>0</number>
               </property>
-             </widget>
+              <property name="topMargin" >
+               <number>0</number>
+              </property>
+              <property name="rightMargin" >
+               <number>0</number>
+              </property>
+              <property name="bottomMargin" >
+               <number>0</number>
+              </property>
+              <item>
+               <widget class="QComboBox" name="comboBoxFormat" >
+                <property name="maxVisibleItems" >
+                 <number>20</number>
+                </property>
+               </widget>
+              </item>
+              <item>
+               <widget class="QPushButton" name="pushButtonMuxerConf" >
+                <property name="text" >
+                 <string>Configure</string>
+                </property>
+               </widget>
+              </item>
+             </layout>
             </item>
            </layout>
           </item>

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/translation_table.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/translation_table.h	2010-01-01 18:40:56 UTC (rev 5804)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/translation_table.h	2010-01-02 12:45:44 UTC (rev 5805)
@@ -43,7 +43,6 @@
 PROCESS(actionVob_to_vobsub,ACT_V2V) \
 PROCESS(actionOCR,ACT_Ocr) \
 PROCESS(action_Preferences, ACT_Pref) \
-PROCESS(actionAVI_Muxer_Options, ACT_SetMuxParam) \
 PROCESS(actionPlay_Stop,ACT_StopAvi) \
 PROCESS(actionPrevious_Frame,ACT_PreviousFrame) \
 PROCESS(actionNext_Frame,ACT_NextFrame) \
@@ -85,6 +84,7 @@
 PROCESS(pushButtonVideoFilter, ACT_VideoParameter) \
 PROCESS(pushButtonAudioConf, ACT_AudioCodec) \
 PROCESS(pushButtonAudioFilter, ACT_AudioFilters) \
+PROCESS(pushButtonMuxerConf, ACT_SetMuxParam) \
 PROCESS(toolButtonPlay, ACT_PlayAvi) \
 PROCESS(toolButtonStop, ACT_StopAvi) \
 PROCESS(toolButtonPreviousFrame, ACT_PreviousFrame) \

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/CMakeLists.txt	2010-01-01 18:40:56 UTC (rev 5804)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/CMakeLists.txt	2010-01-02 12:45:44 UTC (rev 5805)
@@ -16,6 +16,7 @@
 DIA_tsSub.cpp        
 DIA_jobs_save.cpp
 DIA_plugins.cpp
+DIA_muxerMpegPs.cpp
 )
 
 SET(OBSOLETE_SRCS

Added: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_muxerMpegPs.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_muxerMpegPs.cpp	2010-01-01 18:40:56 UTC (rev 5804)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_muxerMpegPs.cpp	2010-01-02 12:45:44 UTC (rev 5805)
@@ -0,0 +1,18 @@
+#include "avi_vars.h"
+#include "DIA_factory.h"
+#include "ADM_outputs/oplug_mpegFF/ps_muxer.h"
+#include "ADM_outputs/ADM_lavformat.h"
+
+extern ps_muxer psMuxerConfig;
+
+bool muxerMpegPsConfigure(void)
+{
+	diaMenuEntry format[] = {{PS_MUXER_VCD, "Video CD"}, {PS_MUXER_SVCD, "Super Video CD"}, {PS_MUXER_DVD, "DVD"}};
+
+	diaElemMenu menuFormat(&psMuxerConfig.muxingType, "Muxing Format", 3, format, "");
+	diaElemToggle alternate(&psMuxerConfig.acceptNonCompliant, "Allow Non-compliant Stream");
+
+	diaElem *tabs[] = {&menuFormat, &alternate};
+
+	return diaFactoryRun(("MPEG-PS Muxer"), 2, tabs);
+}

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/gtk_gui.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/gtk_gui.cpp	2010-01-01 18:40:56 UTC (rev 5804)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/gtk_gui.cpp	2010-01-02 12:45:44 UTC (rev 5805)
@@ -40,7 +40,6 @@
 #include "gtkgui.h"
 
 #include "ADM_outputs/oplug_avi/GUI_mux.h"
-#include "ADM_outputs/oplug_mpegFF/oplug_vcdff.h"
 #include "ADM_audiofilter/audioeng_buildfilters.h"
 #include "prefs.h"
 #include "ADM_encoder/adm_encConfig.h"
@@ -60,6 +59,7 @@
 #include "ADM_libraries/ADM_libmpeg2enc/ADM_mpeg2enc.h"
 #include "ADM_video/ADM_vidMisc.h"
 #include "ADM_preview.h"
+
 AudioSource currentAudioSource = AudioAvi;
 AudioSource secondAudioSource = AudioNone;
 char *currentAudioName = NULL;
@@ -99,7 +99,6 @@
 //static void A_selectEncoder ( void );
 extern uint8_t A_SaveAudioDualAudio (const char *a);
 
-extern uint8_t ADM_aviUISetMuxer(  void );
 void A_Resync(void);
 void A_addJob(void);
 static void updateSecondAudioTrack (void);
@@ -314,10 +313,22 @@
  #endif     
       prefs->save ();
       return;
-    case ACT_SetMuxParam:
-      ADM_aviUISetMuxer();
-      return;
-      break;
+	case ACT_SetMuxParam:
+	{
+		int index = UI_GetCurrentFormat();
+
+		for (int i = 0; i < ADM_FORMAT_MAX; i++)
+		{
+			if (ADM_allOutputFormat[index].format == index && ADM_allOutputFormat[index].muxerConfigure != NULL)
+			{
+				ADM_allOutputFormat[index].muxerConfigure();
+
+				break;
+			}
+		}
+
+		return;
+	}
     case ACT_Fast:
       ADM_assert(0);
       break;



From gruntster at mail.berlios.de  Sat Jan  2 14:15:22 2010
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Sat, 2 Jan 2010 14:15:22 +0100
Subject: [Avidemux-svn-commit] r5806 - in
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces:
	ADM_GTK/ADM_gui2 ADM_GTK/glade ADM_QT4/ADM_gui
Message-ID: <201001021315.o02DFMUE032313@sheep.berlios.de>

Author: gruntster
Date: 2010-01-02 14:15:14 +0100 (Sat, 02 Jan 2010)
New Revision: 5806

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2/GUI_main2.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/glade/gtk2_build.glade
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/gui2.ui
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/translation_table.h
Log:
[gui] remove avi muxer menu option and redundant Qt actions

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2/GUI_main2.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2/GUI_main2.cpp	2010-01-02 12:45:44 UTC (rev 5805)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2/GUI_main2.cpp	2010-01-02 13:15:14 UTC (rev 5806)
@@ -59,7 +59,6 @@
   GtkWidget *separator18;
   GtkWidget *video_informations1;
   GtkWidget *image8529;
-  GtkWidget *avi_muxer_options1;
   GtkWidget *separator4;
   GtkWidget *quit1;
   GtkWidget *image8530;
@@ -422,10 +421,6 @@
   gtk_widget_show (image8529);
   gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (video_informations1), image8529);
 
-  avi_muxer_options1 = gtk_menu_item_new_with_mnemonic (QT_TR_NOOP("AVI _Muxer Options"));
-  gtk_widget_show (avi_muxer_options1);
-  gtk_container_add (GTK_CONTAINER (menuitem1_menu), avi_muxer_options1);
-
   separator4 = gtk_separator_menu_item_new ();
   gtk_widget_show (separator4);
   gtk_container_add (GTK_CONTAINER (menuitem1_menu), separator4);
@@ -1527,7 +1522,6 @@
   GLADE_HOOKUP_OBJECT (mainWindow, separator18, "separator18");
   GLADE_HOOKUP_OBJECT (mainWindow, video_informations1, "video_informations1");
   GLADE_HOOKUP_OBJECT (mainWindow, image8529, "image8529");
-  GLADE_HOOKUP_OBJECT (mainWindow, avi_muxer_options1, "avi_muxer_options1");
   GLADE_HOOKUP_OBJECT (mainWindow, separator4, "separator4");
   GLADE_HOOKUP_OBJECT (mainWindow, quit1, "quit1");
   GLADE_HOOKUP_OBJECT (mainWindow, image8530, "image8530");

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/glade/gtk2_build.glade
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/glade/gtk2_build.glade	2010-01-02 12:45:44 UTC (rev 5805)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/glade/gtk2_build.glade	2010-01-02 13:15:14 UTC (rev 5806)
@@ -278,14 +278,6 @@
 		  </child>
 
 		  <child>
-		    <widget class="GtkMenuItem" id="avi_muxer_options1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">AVI _Muxer Options</property>
-		      <property name="use_underline">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
 		    <widget class="GtkSeparatorMenuItem" id="separator4">
 		      <property name="visible">True</property>
 		    </widget>

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/gui2.ui
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/gui2.ui	2010-01-02 12:45:44 UTC (rev 5805)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/gui2.ui	2010-01-02 13:15:14 UTC (rev 5806)
@@ -1423,7 +1423,6 @@
     <addaction name="actionGlyphs_Edit" />
     <addaction name="separator" />
     <addaction name="action_Preferences" />
-    <addaction name="actionAVI_Muxer_Options" />
    </widget>
    <addaction name="menuFile" />
    <addaction name="menuEdit" />
@@ -1563,11 +1562,6 @@
     <string>]</string>
    </property>
   </action>
-  <action name="actionPreferences" >
-   <property name="text" >
-    <string>Pre&amp;ferences...</string>
-   </property>
-  </action>
   <action name="actionProperties" >
    <property name="icon" >
     <iconset resource="avidemux.qrc" >:/new/prefix1/pics/info.png</iconset>
@@ -1660,16 +1654,6 @@
     <string>Save Project As</string>
    </property>
   </action>
-  <action name="actionMain_toolbar" >
-   <property name="text" >
-    <string>Main toolbar</string>
-   </property>
-  </action>
-  <action name="actionA_V_toolbar" >
-   <property name="text" >
-    <string>A/V toolbar</string>
-   </property>
-  </action>
   <action name="actionZoom_1_4" >
    <property name="checkable" >
     <bool>true</bool>
@@ -1717,11 +1701,6 @@
     <string>Ctrl+Alt+2</string>
    </property>
   </action>
-  <action name="actionZoom_4_1" >
-   <property name="text" >
-    <string>Zoom 4:1</string>
-   </property>
-  </action>
   <action name="actionDecoder_options" >
    <property name="text" >
     <string>&amp;Decoder Options...</string>
@@ -1755,11 +1734,6 @@
     <string>Frame Rate</string>
    </property>
   </action>
-  <action name="actionEncoder" >
-   <property name="text" >
-    <string>Encoder</string>
-   </property>
-  </action>
   <action name="actionFilters" >
    <property name="text" >
     <string>Fil&amp;ters...</string>
@@ -1797,11 +1771,6 @@
     <string>Ctrl+Alt+S</string>
    </property>
   </action>
-  <action name="actionEncoder_2" >
-   <property name="text" >
-    <string>Encoder</string>
-   </property>
-  </action>
   <action name="actionFilters_2" >
    <property name="text" >
     <string>&amp;Filters</string>
@@ -1882,23 +1851,6 @@
     <string>OCR (VobSub -> srt)</string>
    </property>
   </action>
-  <action name="actionPlay_Stop" >
-   <property name="icon" >
-    <iconset resource="avidemux.qrc" >:/new/prefix1/pics/player_stop.png</iconset>
-   </property>
-   <property name="text" >
-    <string>Stop</string>
-   </property>
-   <property name="iconText" >
-    <string>Stop</string>
-   </property>
-   <property name="toolTip" >
-    <string>Stop</string>
-   </property>
-   <property name="shortcut" >
-    <string>P</string>
-   </property>
-  </action>
   <action name="actionPrevious_Frame" >
    <property name="icon" >
     <iconset resource="avidemux.qrc" >:/new/prefix1/pics/back.png</iconset>
@@ -2114,37 +2066,6 @@
     <string>Recent3</string>
    </property>
   </action>
-  <action name="actionVCD" >
-   <property name="text" >
-    <string>&amp;Video CD...</string>
-   </property>
-  </action>
-  <action name="actionSVCD" >
-   <property name="text" >
-    <string>&amp;Super Video CD...</string>
-   </property>
-  </action>
-  <action name="actionDVD" >
-   <property name="text" >
-    <string>&amp;DVD...</string>
-   </property>
-  </action>
-  <action name="actionPSP" >
-   <property name="text" >
-    <string>&amp;PlayStation Portable...</string>
-   </property>
-  </action>
-  <action name="actionPSP_H264" >
-   <property name="text" >
-    <string>PlayStation Portable (&amp;H.264)...</string>
-   </property>
-   <property name="iconText" >
-    <string>PlayStation Portable (H.264)</string>
-   </property>
-   <property name="toolTip" >
-    <string>PlayStation Portable (H.264)</string>
-   </property>
-  </action>
   <action name="actionAdd_to_joblist" >
    <property name="text" >
     <string>Add to &amp;Joblist...</string>
@@ -2186,11 +2107,6 @@
     <string>&amp;Reset Edits</string>
    </property>
   </action>
-  <action name="actionSave" >
-   <property name="text" >
-    <string>Save</string>
-   </property>
-  </action>
   <action name="actionOCR_DVB_T_TS_files" >
    <property name="text" >
     <string>OCR (&amp;TS -> srt)...</string>
@@ -2271,41 +2187,6 @@
     <string>&amp;Separate</string>
    </property>
   </action>
-  <action name="action_Input" >
-   <property name="text" >
-    <string>&amp;Input</string>
-   </property>
-  </action>
-  <action name="action_Output" >
-   <property name="text" >
-    <string>&amp;Output</string>
-   </property>
-  </action>
-  <action name="actionSi_de" >
-   <property name="text" >
-    <string>Si&amp;de</string>
-   </property>
-  </action>
-  <action name="action_Top" >
-   <property name="text" >
-    <string>&amp;Top</string>
-   </property>
-  </action>
-  <action name="action_Separate" >
-   <property name="text" >
-    <string>&amp;Separate</string>
-   </property>
-  </action>
-  <action name="actionFLV" >
-   <property name="text" >
-    <string>&amp;Flash Video</string>
-   </property>
-  </action>
-  <action name="actionIPOD" >
-   <property name="text" >
-    <string>&amp;iPod (MPEG-4 ASP)...</string>
-   </property>
-  </action>
   <action name="actionClose" >
    <property name="text" >
     <string>&amp;Close</string>
@@ -2324,11 +2205,6 @@
     <string>&amp;Preferences...</string>
    </property>
   </action>
-  <action name="actionAVI_Muxer_Options" >
-   <property name="text" >
-    <string>&amp;AVI Muxer Options...</string>
-   </property>
-  </action>
   <action name="action_Plugins" >
    <property name="text" >
     <string>&amp;Plugins...</string>

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/translation_table.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/translation_table.h	2010-01-02 12:45:44 UTC (rev 5805)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/translation_table.h	2010-01-02 13:15:14 UTC (rev 5806)
@@ -28,13 +28,11 @@
 PROCESS(actionDecoder_options,ACT_DecoderOption) \
 PROCESS(actionPostprocessing,ACT_SetPostProcessing) \
 PROCESS(actionFrame_rate,ACT_ChangeFPS) \
-PROCESS(actionEncoder,ACT_SelectEncoder) \
 PROCESS(actionFilters,ACT_VideoParameter) \
 PROCESS(actionMain_Track,ACT_SelectTrack1) \
 PROCESS(actionSecondary_Track,ACT_SecondAudioTrack) \
 PROCESS(actionBuild_VBR_time_map,ACT_AudioMap) \
 PROCESS(actionSave_2,ACT_SaveWave) \
-PROCESS(actionEncoder_2,ACT_SelectEncoder) \
 PROCESS(actionFilters_2,ACT_AudioFilters) \
 PROCESS(actionCalculator,ACT_Bitrate) \
 PROCESS(actionRebuild_I_B_Frames,ACT_RebuildKF) \
@@ -43,7 +41,6 @@
 PROCESS(actionVob_to_vobsub,ACT_V2V) \
 PROCESS(actionOCR,ACT_Ocr) \
 PROCESS(action_Preferences, ACT_Pref) \
-PROCESS(actionPlay_Stop,ACT_StopAvi) \
 PROCESS(actionPrevious_Frame,ACT_PreviousFrame) \
 PROCESS(actionNext_Frame,ACT_NextFrame) \
 PROCESS(actionPrevious_black_frame,ACT_PrevBlackFrame) \



From gruntster at mail.berlios.de  Sat Jan  2 14:19:59 2010
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Sat, 2 Jan 2010 14:19:59 +0100
Subject: [Avidemux-svn-commit] r5807 - in
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces:
	ADM_GTK/ADM_dialog ADM_QT4/ADM_dialog
Message-ID: <201001021319.o02DJxCl032606@sheep.berlios.de>

Author: gruntster
Date: 2010-01-02 14:19:52 +0100 (Sat, 02 Jan 2010)
New Revision: 5807

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_about.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/about.ui
Log:
[gui] update copyright year

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_about.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_about.cpp	2010-01-02 13:15:14 UTC (rev 5806)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_about.cpp	2010-01-02 13:19:52 UTC (rev 5807)
@@ -52,7 +52,7 @@
   gtk_about_dialog_set_version (GTK_ABOUT_DIALOG (aboutdialog1), subversion);
 // /MEANX
   gtk_about_dialog_set_name (GTK_ABOUT_DIALOG (aboutdialog1), "Avidemux");
-  gtk_about_dialog_set_copyright (GTK_ABOUT_DIALOG (aboutdialog1), "\302\251 2001 - 2009 Mean");
+  gtk_about_dialog_set_copyright (GTK_ABOUT_DIALOG (aboutdialog1), "\302\251 2001 - 2010 Mean");
   gtk_about_dialog_set_comments (GTK_ABOUT_DIALOG (aboutdialog1), QT_TR_NOOP("Multi-platform Video Editor"));
   gtk_about_dialog_set_license (GTK_ABOUT_DIALOG (aboutdialog1), QT_TR_NOOP("Avidemux is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License version 2\nas published by the Free Software Foundation.\n\n\t\t    GNU GENERAL PUBLIC LICENSE\n\t\t       Version 2, June 1991\n\n Copyright (C) 1989, 1991 Free Software Foundation, Inc.\n                       51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n\t\t\t    Preamble\n\n  The licenses for most software are designed to take away your\nfreedom to share and change it.  By contrast, the GNU General Public\nLicense is intended to guarantee your freedom to share and change free\nsoftware--to make sure the software is free for all its users.  This\nGeneral Public License applies to most of the Free Software\nFoundation's software and to any othe!
 r program whose authors commit to\nusing it.  (Some other Free Software Foundation software is covered by\nthe GNU Library General Public License instead.)  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthis service if you wish), that you receive source code or can get it\nif you want it, that you can change the software or use pieces of it\nin new free programs; and that you know you can do these things.\n\n  To protect your rights, we need to make restrictions that forbid\nanyone to deny you these rights or to ask you to surrender the rights.\nThese restrictions translate to certain responsibilities for you if you\ndistribute copies of the software, or if you modify it.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you m!
 ust give the recipients all the rights that\nyou have.  You mu!
 st make 
sure that they, too, receive or can get the\nsource code.  And you must show them these terms so they know their\nrights.\n\n  We protect your rights with two steps: (1) copyright the software, and\n(2) offer you this license which gives you legal permission to copy,\ndistribute and/or modify the software.\n\n  Also, for each author's protection and ours, we want to make certain\nthat everyone understands that there is no warranty for this free\nsoftware.  If the software is modified by someone else and passed on, we\nwant its recipients to know that what they have is not the original, so\nthat any problems introduced by others will not reflect on the original\nauthors' reputations.\n\n  Finally, any free program is threatened constantly by software\npatents.  We wish to avoid the danger that redistributors of a free\nprogram will individually obtain patent licenses, in effect making the\nprogram proprietary.  To prevent this, we have made it clear that any\npatent must be l!
 icensed for everyone's free use or not licensed at all.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n\t\t    GNU GENERAL PUBLIC LICENSE\n   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n\n  0. This License applies to any program or other work which contains\na notice placed by the copyright holder saying it may be distributed\nunder the terms of this General Public License.  The \"Program\", below,\nrefers to any such program or work, and a \"work based on the Program\"\nmeans either the Program or any derivative work under copyright law:\nthat is to say, a work containing the Program or a portion of it,\neither verbatim or with modifications and/or translated into another\nlanguage.  (Hereinafter, translation is included without limitation in\nthe term \"modification\".)  Each licensee is addressed as \"you\".\n\nActivities other than copying, distribution and modification are not\ncovered by this License; !
 they are outside its scope.  The act of\nrunning the Program i!
 s not re
stricted, and the output from the Program\nis covered only if its contents constitute a work based on the\nProgram (independent of having been made by running the Program).\nWhether that is true depends on what the Program does.\n\n  1. You may copy and distribute verbatim copies of the Program's\nsource code as you receive it, in any medium, provided that you\nconspicuously and appropriately publish on each copy an appropriate\ncopyright notice and disclaimer of warranty; keep intact all the\nnotices that refer to this License and to the absence of any warranty;\nand give any other recipients of the Program a copy of this License\nalong with the Program.\n\nYou may charge a fee for the physical act of transferring a copy, and\nyou may at your option offer warranty protection in exchange for a fee.\n\n  2. You may modify your copy or copies of the Program or any portion\nof it, thus forming a work based on the Program, and copy and\ndistribute such modifications or work unde!
 r the terms of Section 1\nabove, provided that you also meet all of these conditions:\n\n    a) You must cause the modified files to carry prominent notices\n    stating that you changed the files and the date of any change.\n\n    b) You must cause any work that you distribute or publish, that in\n    whole or in part contains or is derived from the Program or any\n    part thereof, to be licensed as a whole at no charge to all third\n    parties under the terms of this License.\n\n    c) If the modified program normally reads commands interactively\n    when run, you must cause it, when started running for such\n    interactive use in the most ordinary way, to print or display an\n    announcement including an appropriate copyright notice and a\n    notice that there is no warranty (or else, saying that you provide\n    a warranty) and that users may redistribute the program under\n    these conditions, and telling the user how to view a copy of this\n    License.  (Excep!
 tion: if the Program itself is interactive but\n    does not n!
 ormally 
print such an announcement, your work based on\n    the Program is not required to print an announcement.)\n\nThese requirements apply to the modified work as a whole.  If\nidentifiable sections of that work are not derived from the Program,\nand can be reasonably considered independent and separate works in\nthemselves, then this License, and its terms, do not apply to those\nsections when you distribute them as separate works.  But when you\ndistribute the same sections as part of a whole which is a work based\non the Program, the distribution of the whole must be on the terms of\nthis License, whose permissions for other licensees extend to the\nentire whole, and thus to each and every part regardless of who wrote it.\n\nThus, it is not the intent of this section to claim rights or contest\nyour rights to work written entirely by you; rather, the intent is to\nexercise the right to control the distribution of derivative or\ncollective works based on the Program.\n\nIn add!
 ition, mere aggregation of another work not based on the Program\nwith the Program (or with a work based on the Program) on a volume of\na storage or distribution medium does not bring the other work under\nthe scope of this License.\n\n  3. You may copy and distribute the Program (or a work based on it,\nunder Section 2) in object code or executable form under the terms of\nSections 1 and 2 above provided that you also do one of the following:\n\n    a) Accompany it with the complete corresponding machine-readable\n    source code, which must be distributed under the terms of Sections\n    1 and 2 above on a medium customarily used for software interchange; or,\n\n    b) Accompany it with a written offer, valid for at least three\n    years, to give any third party, for a charge no more than your\n    cost of physically performing source distribution, a complete\n    machine-readable copy of the corresponding source code, to be\n    distributed under the terms of Sections !
 1 and 2 above on a medium\n    customarily used for software i!
 nterchan
ge; or,\n\n    c) Accompany it with the information you received as to the offer\n    to distribute corresponding source code.  (This alternative is\n    allowed only for noncommercial distribution and only if you\n    received the program in object code or executable form with such\n    an offer, in accord with Subsection b above.)\n\nThe source code for a work means the preferred form of the work for\nmaking modifications to it.  For an executable work, complete source\ncode means all the source code for all modules it contains, plus any\nassociated interface definition files, plus the scripts used to\ncontrol compilation and installation of the executable.  However, as a\nspecial exception, the source code distributed need not include\nanything that is normally distributed (in either source or binary\nform) with the major components (compiler, kernel, and so on) of the\noperating system on which the executable runs, unless that component\nitself accompanies the executable!
 .\n\nIf distribution of executable or object code is made by offering\naccess to copy from a designated place, then offering equivalent\naccess to copy the source code from the same place counts as\ndistribution of the source code, even though third parties are not\ncompelled to copy the source along with the object code.\n\n  4. You may not copy, modify, sublicense, or distribute the Program\nexcept as expressly provided under this License.  Any attempt\notherwise to copy, modify, sublicense or distribute the Program is\nvoid, and will automatically terminate your rights under this License.\nHowever, parties who have received copies, or rights, from you under\nthis License will not have their licenses terminated so long as such\nparties remain in full compliance.\n\n  5. You are not required to accept this License, since you have not\nsigned it.  However, nothing else grants you permission to modify or\ndistribute the Program or its derivative works.  These actions are\npr!
 ohibited by law if you do not accept this License.  Therefore,!
  by\nmod
ifying or distributing the Program (or any work based on the\nProgram), you indicate your acceptance of this License to do so, and\nall its terms and conditions for copying, distributing or modifying\nthe Program or works based on it.\n\n  6. Each time you redistribute the Program (or any work based on the\nProgram), the recipient automatically receives a license from the\noriginal licensor to copy, distribute or modify the Program subject to\nthese terms and conditions.  You may not impose any further\nrestrictions on the recipients' exercise of the rights granted herein.\nYou are not responsible for enforcing compliance by third parties to\nthis License.\n\n  7. If, as a consequence of a court judgment or allegation of patent\ninfringement or for any other reason (not limited to patent issues),\nconditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this !
 License.  If you cannot\ndistribute so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you\nmay not distribute the Program at all.  For example, if a patent\nlicense would not permit royalty-free redistribution of the Program by\nall those who receive copies directly or indirectly through you, then\nthe only way you could satisfy both it and this License would be to\nrefrain entirely from distribution of the Program.\n\nIf any portion of this section is held invalid or unenforceable under\nany particular circumstance, the balance of the section is intended to\napply and the section as a whole is intended to apply in other\ncircumstances.\n\nIt is not the purpose of this section to induce you to infringe any\npatents or other property right claims or to contest validity of any\nsuch claims; this section has the sole purpose of protecting the\nintegrity of the free software distribution system, which!
  is\nimplemented by public license practices.  Many people hav!
 e made\n
generous contributions to the wide range of software distributed\nthrough that system in reliance on consistent application of that\nsystem; it is up to the author/donor to decide if he or she is willing\nto distribute software through any other system and a licensee cannot\nimpose that choice.\n\nThis section is intended to make thoroughly clear what is believed to\nbe a consequence of the rest of this License.\n\n  8. If the distribution and/or use of the Program is restricted in\ncertain countries either by patents or by copyrighted interfaces, the\noriginal copyright holder who places the Program under this License\nmay add an explicit geographical distribution limitation excluding\nthose countries, so that distribution is permitted only in or among\ncountries not thus excluded.  In such case, this License incorporates\nthe limitation as if written in the body of this License.\n\n  9. The Free Software Foundation may publish revised and/or new versions\nof the General Pu!
 blic License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\nEach version is given a distinguishing version number.  If the Program\nspecifies a version number of this License which applies to it and \"any\nlater version\", you have the option of following the terms and conditions\neither of that version or of any later version published by the Free\nSoftware Foundation.  If the Program does not specify a version number of\nthis License, you may choose any version ever published by the Free Software\nFoundation.\n\n  10. If you wish to incorporate parts of the Program into other free\nprograms whose distribution conditions are different, write to the author\nto ask for permission.  For software which is copyrighted by the Free\nSoftware Foundation, write to the Free Software Foundation; we sometimes\nmake exceptions for this.  Our decision will be guided by the two goa!
 ls\nof preserving the free status of all derivatives of our fr!
 ee softw
are and\nof promoting the sharing and reuse of software generally.\n\n\t\t\t    NO WARRANTY\n\n  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY\nFOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN\nOTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES\nPROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED\nOR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS\nTO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE\nPROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,\nREPAIR OR CORRECTION.\n\n  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR\nREDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,\nINCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENT!
 IAL DAMAGES ARISING\nOUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED\nTO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY\nYOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER\nPROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGES.\n\n\t\t     END OF TERMS AND CONDITIONS\n\n\t    How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nconvey the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the program's !
 name and a brief idea of what it does.>\n    Copyright (C) <ye!
 ar>  <na
me of author>\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program; if not, write to the Free Software\n    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n\n\nAlso add information on how to contact you by electronic and paper mail.\n\nIf the program is interactive, make it output a short notice like this\nwhen it starts in an interactive mode:\n\n    Gnomovision version 69, Copyright (C) ye!
 ar name of author\n    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, the commands you use may\nbe called something other than `show w' and `show c'; they could even be\nmouse-clicks or menu items--whatever suits your program.\n\nYou should also get your employer (if you work as a programmer) or your\nschool, if any, to sign a \"copyright disclaimer\" for the program, if\nnecessary.  Here is a sample; alter the names:\n\n  Yoyodyne, Inc., hereby disclaims all copyright interest in the program\n  `Gnomovision' (which makes passes at compilers) written by James Hacker.\n\n  <signature of Ty Coon>, 1 April 1989\n  Ty Coon, President of Vice\n\nThis General Public License does not permit incorporating !
 your program into\nproprietary programs.  If your program is a!
  subrout
ine library, you may\nconsider it more useful to permit linking proprietary applications with the\nlibrary.  If this is what you want to do, use the GNU Library General\nPublic License instead of this License."));
   gtk_about_dialog_set_website (GTK_ABOUT_DIALOG (aboutdialog1), "http://www.avidemux.org");

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/about.ui
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/about.ui	2010-01-02 13:15:14 UTC (rev 5806)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/about.ui	2010-01-02 13:19:52 UTC (rev 5807)
@@ -107,7 +107,7 @@
      <item>
       <widget class="QLabel" name="label_3" >
        <property name="text" >
-        <string>? 2001 - 2009  Mean</string>
+        <string>? 2001 - 2010  Mean</string>
        </property>
        <property name="alignment" >
         <set>Qt::AlignCenter</set>



From gruntster at mail.berlios.de  Sat Jan  2 16:11:35 2010
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Sat, 2 Jan 2010 16:11:35 +0100
Subject: [Avidemux-svn-commit] r5809 -
	branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/avidemux
Message-ID: <201001021511.o02FBZFR006600@sheep.berlios.de>

Author: gruntster
Date: 2010-01-02 16:11:30 +0100 (Sat, 02 Jan 2010)
New Revision: 5809

Modified:
   branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/avidemux/1a. Prepare Build.bat
   branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/avidemux/1b. Continue Build.bat
Log:
[win32] tweaks to build scripts

Modified: branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/avidemux/1a. Prepare Build.bat
===================================================================
--- branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/avidemux/1a. Prepare Build.bat	2010-01-02 14:00:18 UTC (rev 5808)
+++ branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/avidemux/1a. Prepare Build.bat	2010-01-02 15:11:30 UTC (rev 5809)
@@ -10,6 +10,7 @@
 rmdir /s /q %buildFolder% 2> NUL
 
 cd "%sourceDir%\plugins"
+echo Cleaning plugin build directory (%CD%\%BuildFolder%)
 rmdir /s /q %buildFolder% 2> NUL
 
 if exist %buildFolder% goto removalFailure

Modified: branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/avidemux/1b. Continue Build.bat
===================================================================
--- branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/avidemux/1b. Continue Build.bat	2010-01-02 14:00:18 UTC (rev 5808)
+++ branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/avidemux/1b. Continue Build.bat	2010-01-02 15:11:30 UTC (rev 5809)
@@ -19,9 +19,14 @@
 cd "%sourceDir%\%buildFolder%"
 make install
 
+if errorlevel 1 goto error
+
 cd "%sourceDir%\plugins\%buildFolder%"
+rmdir /s /q "%buildDir%\plugins" 2> NUL
 make install
 
+if errorlevel 1 goto error
+
 del /s "%buildDir%\*.a"
 
 echo Finished!



From gruntster at mail.berlios.de  Sat Jan  2 16:24:51 2010
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Sat, 2 Jan 2010 16:24:51 +0100
Subject: [Avidemux-svn-commit] r5810 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script
Message-ID: <201001021524.o02FOp18007468@sheep.berlios.de>

Author: gruntster
Date: 2010-01-02 16:24:46 +0100 (Sat, 02 Jan 2010)
New Revision: 5810

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemux.cpp
Log:
[muxer] always set muxer back to defaults if config not specified in JavaScript

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemux.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemux.cpp	2010-01-02 15:11:30 UTC (rev 5809)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemux.cpp	2010-01-02 15:24:46 UTC (rev 5810)
@@ -558,21 +558,24 @@
 				{
 					if (ADM_allOutputFormat[i].format == format)
 					{
-						int configLength = strlen(config);
-
-						if (ADM_allOutputFormat[i].configSize > 0 && configLength > 0)
+						if (ADM_allOutputFormat[i].configSize > 0)
 						{
-							uint8_t* currentConfig = (uint8_t*)ADM_allOutputFormat[i].currentConfig;
-							const char* configHexPtr = config;
-							int configByteCount = 0;
-
 							memcpy(ADM_allOutputFormat[i].currentConfig, ADM_allOutputFormat[i].defaultConfig, ADM_allOutputFormat[i].configSize);
 
-							while ((configHexPtr - config) < configLength && configByteCount < ADM_allOutputFormat[i].configSize)
+							int configLength = strlen(config);
+
+							if (configLength > 0)
 							{
-								currentConfig[configByteCount] = mk_hex(*configHexPtr, *(configHexPtr + 1));
-								configHexPtr += 3;
-								configByteCount += 1;
+								uint8_t* currentConfig = (uint8_t*)ADM_allOutputFormat[i].currentConfig;
+								const char* configHexPtr = config;
+								int configByteCount = 0;
+
+								while ((configHexPtr - config) < configLength && configByteCount < ADM_allOutputFormat[i].configSize)
+								{
+									currentConfig[configByteCount] = mk_hex(*configHexPtr, *(configHexPtr + 1));
+									configHexPtr += 3;
+									configByteCount += 1;
+								}
 							}
 						}
 



From mean at mail.berlios.de  Sat Jan  2 17:30:45 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 2 Jan 2010 17:30:45 +0100
Subject: [Avidemux-svn-commit] r5811 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska
Message-ID: <201001021630.o02GUjtU011950@sheep.berlios.de>

Author: mean
Date: 2010-01-02 17:30:45 +0100 (Sat, 02 Jan 2010)
New Revision: 5811

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkvIndexer.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/mkv_tagenum.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/mkv_tags.cpp
Log:
[mkv] Ignore CRC and other tags in mkv

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.h	2010-01-02 15:24:46 UTC (rev 5810)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.h	2010-01-02 16:30:45 UTC (rev 5811)
@@ -65,7 +65,7 @@
   uint32_t  _defaultFrameDuration; // Duration of ONE frame in us!
 }mkvTrak;
 
-#define MKV_MAX_LACES 20 // ?
+#define MKV_MAX_LACES 31 // ?
 /**
     \class mkvAccess
     \brief Matroska audio demuxer

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkvIndexer.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkvIndexer.cpp	2010-01-02 15:24:46 UTC (rev 5810)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkvIndexer.cpp	2010-01-02 16:30:45 UTC (rev 5811)
@@ -93,7 +93,7 @@
                                 //printf(">%s\n",ss);
                                 switch(id)
                                 {
-                                  default: blockGroup.skip(len);
+                                  default: blockGroup.skip(len);break;
                                   case MKV_BLOCK :
                                   case MKV_SIMPLE_BLOCK:
                                   {
@@ -330,7 +330,7 @@
    fileSize=parser->getFileSize();
    if(!parser->simplefind(MKV_SEGMENT,&vlen,1))
    {
-     printf("[MKV] cluster indexer, cannot find CLUSTER atom\n");
+     ADM_warning("[MKV] cluster indexer, cannot find CLUSTER atom\n");
      return 0;
    }
    ADM_ebml_file segment(parser,vlen);
@@ -353,12 +353,24 @@
      _clusters[_nbClusters].size=alen;
 
      // Normally the timecode is the 1st one following
+
+tryAgain:
        segment.readElemId(&id,&len);
+       switch(id)
+        {
+            case MKV_CRC32:
+            case MKV_PREV_SIZE:
+            case MKV_POSITION:
+                segment.skip(len);
+                goto tryAgain;
+            default:break;
+        }
        int seekme=_nbClusters;
        if(id!=MKV_TIMECODE)
        {
+          ss=NULL;
           ADM_searchMkvTag( (MKV_ELEM_ID)id,&ss,&type);
-          printf("[MKV] Cluster : no time code Found %s(0x%"LLX"), expected MKV_TIMECODE  (0x%x)\n",
+          ADM_warning("[MKV] Cluster : no time code Found %s(0x%"LLX"), expected MKV_TIMECODE  (0x%x)\n",
                   ss,id,MKV_TIMECODE);
        }
        else
@@ -371,7 +383,7 @@
        //printf("Position :%u %u MB\n", _clusters[seekme].pos+ _clusters[seekme].size,( _clusters[seekme].pos+ _clusters[seekme].size)>>20);
    }
    delete work;
-   printf("[MKV] Found %u clusters\n",_nbClusters);
+   ADM_info("[MKV] Found %u clusters\n",_nbClusters);
    return 1;
 }
 //EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/mkv_tagenum.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/mkv_tagenum.h	2010-01-02 15:24:46 UTC (rev 5810)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/mkv_tagenum.h	2010-01-02 16:30:45 UTC (rev 5811)
@@ -127,7 +127,9 @@
    MKTAG(MKV_FLAG_INTERLACED,0x9A,ADM_MKV_TYPE_UINTEGER),
    MKTAG(MKV_NAME,0x536e,ADM_MKV_TYPE_UTF8),
 
-
+    MKTAG(MKV_CRC32,0xBF,ADM_MKV_TYPE_BINARY),
+    MKTAG(MKV_PREV_SIZE,0xAB,ADM_MKV_TYPE_UINTEGER),
+    MKTAG(MKV_POSITION,0xA7,ADM_MKV_TYPE_UINTEGER),
          //*************************
    MKTAG(MKV_MAX,0xFFFF,ADM_MKV_TYPE_UNKNOWN)
 

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/mkv_tags.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/mkv_tags.cpp	2010-01-02 15:24:46 UTC (rev 5810)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/mkv_tags.cpp	2010-01-02 16:30:45 UTC (rev 5811)
@@ -55,6 +55,8 @@
     }
     
   }
+  *asString="??";
+  *type=ADM_MKV_TYPE_UNKNOWN;
   return 0;
 }
 /**



From mean at mail.berlios.de  Sat Jan  2 17:30:49 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 2 Jan 2010 17:30:49 +0100
Subject: [Avidemux-svn-commit] r5812 - in
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2:
	include src
Message-ID: <201001021630.o02GUnGa011966@sheep.berlios.de>

Author: mean
Date: 2010-01-02 17:30:47 +0100 (Sat, 02 Jan 2010)
New Revision: 5812

Added:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsAvidemuxInfo.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/include/ADM_jsAvidemux.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsAvidemux_js.c
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsAvidemux_js.idl
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/CMakeLists.txt
Log:
[js] Add getWidth, getHeight, getFps100 and getVideoCodec to js interface

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/include/ADM_jsAvidemux.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/include/ADM_jsAvidemux.h	2010-01-02 16:30:45 UTC (rev 5811)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/include/ADM_jsAvidemux.h	2010-01-02 16:30:47 UTC (rev 5812)
@@ -35,6 +35,12 @@
 void   jsSetMarkerB(double b);
 //
 int    jsClearVideoFilters();
+// Info
+int jsGetWidth ( void) ;
+int jsGetHeight ( void) ;
+int jsGetFps1000 ( void) ;
+char *jsGetVideoCodec ( void) ;
+
 // non jsapigen function, variables number of args
 JSBool jsAdmaddVideoFilter(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
 JSBool jsAdmaudioCodec(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);

Added: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsAvidemuxInfo.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsAvidemuxInfo.cpp	2010-01-02 16:30:45 UTC (rev 5811)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsAvidemuxInfo.cpp	2010-01-02 16:30:47 UTC (rev 5812)
@@ -0,0 +1,59 @@
+/**
+    \file ADM_jsLoad.cpp
+    \brief Load oriented functions
+    \author mean (c) 2009 fixounet at free.fr
+
+
+*/
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "ADM_js.h"
+#include "ADM_editor/ADM_edit.hxx"
+#include "ADM_jsAvidemux.h"
+#include "fourcc.h"
+extern ADM_Composer *video_body;
+/**
+    \fn jsGetWidth
+*/
+int jsGetWidth ( void)
+{
+aviInfo info;
+        video_body->getVideoInfo(&info);
+        return info.width;
+}
+/**
+    \fn jsGetHeight
+*/
+int jsGetHeight ( void)
+{
+aviInfo info;
+        video_body->getVideoInfo(&info);
+        return info.height;
+}
+/**
+    \fn jsGetFps1000
+*/
+int jsGetFps1000 ( void)
+{
+aviInfo info;
+        video_body->getVideoInfo(&info);
+        return info.fps1000;
+}
+/**
+    \fn jsGetVideoCodec
+*/
+char *jsGetVideoCodec ( void)
+{
+uint32_t fcc;
+aviInfo info;
+        video_body->getVideoInfo(&info);
+        fcc=info.fcc;
+        return fourCC::tostring(fcc);
+}
+// EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsAvidemux_js.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsAvidemux_js.c	2010-01-02 16:30:45 UTC (rev 5811)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsAvidemux_js.c	2010-01-02 16:30:47 UTC (rev 5812)
@@ -20,6 +20,10 @@
         printf("Constructor invoked\n");
 }
 
+#ifdef HAVE_ALLOCA_H
+#include <alloca.h>
+#endif
+#include <stdlib.h>
 #include <string.h>
 #include <wchar.h>
 #include <jsapi.h>
@@ -38,6 +42,9 @@
 #ifndef JS_FS_END
 #define JS_FS_END {NULL, NULL, 0, 0, 0}
 #endif
+#ifdef HAVE_ALLOCA_H
+static size_t jj_alloca_limit = 0;
+#endif
 static JSPropertySpec jj_static_ps[] = {
     {NULL, 0, 0, NULL, NULL}
 };
@@ -201,34 +208,34 @@
 jjadmloadVideo(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
     JSObject *var35;
-    char *var40;
     int var36;
     int var39;
+    char *var40;
     int var41;
     jsval var42;
     JSString *var43;
-    jsval var368;
+    jsval var389;
     size_t var44;
     size_t var45;
     int var47;
-    jschar *var46;
-    jsval var369;
-    jsval var48;
+    jschar *var48;
+    jsval var390;
+    jsval var49;
     JSBool var34;
     var35 = NULL;
-    var40 = NULL;
     var36 = 0;
     var39 = 0;
+    var40 = NULL;
     var41 = 0;
     var42 = JSVAL_NULL;
     var43 = NULL;
-    var368 = JSVAL_NULL;
+    var389 = JSVAL_NULL;
     var44 = 0;
     var45 = 0;
     var47 = 0;
-    var46 = NULL;
-    var369 = JSVAL_NULL;
-    var48 = JSVAL_NULL;
+    var48 = NULL;
+    var390 = JSVAL_NULL;
+    var49 = JSVAL_NULL;
     var34 = JS_FALSE;
     var35 = obj;
     var39 = argc;
@@ -240,39 +247,48 @@
     if (!var43) {
         goto do_return;
     }
-    var368 = STRING_TO_JSVAL(var43);
-    argv[argc+0] = var368;
+    var389 = STRING_TO_JSVAL(var43);
+    argv[argc+0] = var389;
     var44 = JS_GetStringLength(var43);
     var45 = 1;
     var45 += var44;
-    var40 = JS_malloc(cx, var45);
-    if (!var40) {
-        goto do_return;
+#ifdef HAVE_ALLOCA
+    if (var45 < jj_alloca_limit) {
+        var40 = alloca(var45);
+    } else {
+#endif
+        var40 = malloc(var45);
+        if (!var40) {
+            goto do_return;
+        } else {
+            var47 = 1;
+        }
+#ifdef HAVE_ALLOCA
     }
-    var47 = 1;
-    var46 = JS_GetStringChars(var43);
-    var369 = STRING_TO_JSVAL(var43);
-    argv[argc+1] = var369;
+#endif
+    var48 = JS_GetStringChars(var43);
+    var390 = STRING_TO_JSVAL(var43);
+    argv[argc+1] = var390;
     {
         size_t i;
         for (i = 0; i < var44; ++i) {
-            var40[i] = wctob(var46[i]);
+            var40[i] = wctob(var48[i]);
         }
         var40[var44] = '\0';
     }
     }
     var36 = jsLoadVideo(var40);
-    if (JS_NewNumberValue(cx, var36, &var48) != JS_TRUE) {
+    if (JS_NewNumberValue(cx, var36, &var49) != JS_TRUE) {
         goto do_return;
     }
-    argv[argc+2] = var48;
+    argv[argc+2] = var49;
     if (rval) {
-        *rval = var48;
+        *rval = var49;
     }
     var34 = JS_TRUE;
     do_return:
     if (var47) {
-        JS_free(cx, var40);
+        free(var40);
         var40 = NULL;
         var47 = 0;
     }
@@ -281,1580 +297,1723 @@
 static JSBool
 jjadmclearSegments(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
-    JSObject *var50;
-    int var51;
-    int var54;
-    jsval var55;
-    JSBool var49;
-    var50 = NULL;
-    var51 = 0;
-    var54 = 0;
-    var55 = JSVAL_NULL;
-    var49 = JS_FALSE;
-    var50 = obj;
-    var54 = argc;
-    var51 = jsClearSegments();
-    if (JS_NewNumberValue(cx, var51, &var55) != JS_TRUE) {
+    JSObject *var51;
+    int var52;
+    int var55;
+    jsval var56;
+    JSBool var50;
+    var51 = NULL;
+    var52 = 0;
+    var55 = 0;
+    var56 = JSVAL_NULL;
+    var50 = JS_FALSE;
+    var51 = obj;
+    var55 = argc;
+    var52 = jsClearSegments();
+    if (JS_NewNumberValue(cx, var52, &var56) != JS_TRUE) {
         goto do_return;
     }
-    argv[argc+0] = var55;
+    argv[argc+0] = var56;
     if (rval) {
-        *rval = var55;
+        *rval = var56;
     }
-    var49 = JS_TRUE;
+    var50 = JS_TRUE;
     do_return:
-    return var49;
+    return var50;
 }
 static JSBool
 jjadmappendVideo(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
-    JSObject *var57;
-    char *var62;
-    int var58;
-    int var61;
-    int var63;
-    jsval var64;
-    JSString *var65;
-    jsval var372;
-    size_t var66;
+    JSObject *var58;
+    int var59;
+    int var62;
+    char *var63;
+    int var64;
+    jsval var65;
+    JSString *var66;
+    jsval var393;
     size_t var67;
-    int var69;
-    jschar *var68;
-    jsval var373;
-    jsval var70;
-    JSBool var56;
-    var57 = NULL;
-    var62 = NULL;
-    var58 = 0;
-    var61 = 0;
-    var63 = 0;
-    var64 = JSVAL_NULL;
-    var65 = NULL;
-    var372 = JSVAL_NULL;
-    var66 = 0;
+    size_t var68;
+    int var70;
+    jschar *var71;
+    jsval var394;
+    jsval var72;
+    JSBool var57;
+    var58 = NULL;
+    var59 = 0;
+    var62 = 0;
+    var63 = NULL;
+    var64 = 0;
+    var65 = JSVAL_NULL;
+    var66 = NULL;
+    var393 = JSVAL_NULL;
     var67 = 0;
-    var69 = 0;
-    var68 = NULL;
-    var373 = JSVAL_NULL;
-    var70 = JSVAL_NULL;
-    var56 = JS_FALSE;
-    var57 = obj;
-    var61 = argc;
-    var63 = 0;
-    var63 = var63 < var61;
-    if (var63) {
-    var64 = argv[0];
-    var65 = JS_ValueToString(cx, var64);
-    if (!var65) {
+    var68 = 0;
+    var70 = 0;
+    var71 = NULL;
+    var394 = JSVAL_NULL;
+    var72 = JSVAL_NULL;
+    var57 = JS_FALSE;
+    var58 = obj;
+    var62 = argc;
+    var64 = 0;
+    var64 = var64 < var62;
+    if (var64) {
+    var65 = argv[0];
+    var66 = JS_ValueToString(cx, var65);
+    if (!var66) {
         goto do_return;
     }
-    var372 = STRING_TO_JSVAL(var65);
-    argv[argc+0] = var372;
-    var66 = JS_GetStringLength(var65);
-    var67 = 1;
-    var67 += var66;
-    var62 = JS_malloc(cx, var67);
-    if (!var62) {
-        goto do_return;
+    var393 = STRING_TO_JSVAL(var66);
+    argv[argc+0] = var393;
+    var67 = JS_GetStringLength(var66);
+    var68 = 1;
+    var68 += var67;
+#ifdef HAVE_ALLOCA
+    if (var68 < jj_alloca_limit) {
+        var63 = alloca(var68);
+    } else {
+#endif
+        var63 = malloc(var68);
+        if (!var63) {
+            goto do_return;
+        } else {
+            var70 = 1;
+        }
+#ifdef HAVE_ALLOCA
     }
-    var69 = 1;
-    var68 = JS_GetStringChars(var65);
-    var373 = STRING_TO_JSVAL(var65);
-    argv[argc+1] = var373;
+#endif
+    var71 = JS_GetStringChars(var66);
+    var394 = STRING_TO_JSVAL(var66);
+    argv[argc+1] = var394;
     {
         size_t i;
-        for (i = 0; i < var66; ++i) {
-            var62[i] = wctob(var68[i]);
+        for (i = 0; i < var67; ++i) {
+            var63[i] = wctob(var71[i]);
         }
-        var62[var66] = '\0';
+        var63[var67] = '\0';
     }
     }
-    var58 = jsAppendVideo(var62);
-    if (JS_NewNumberValue(cx, var58, &var70) != JS_TRUE) {
+    var59 = jsAppendVideo(var63);
+    if (JS_NewNumberValue(cx, var59, &var72) != JS_TRUE) {
         goto do_return;
     }
-    argv[argc+2] = var70;
+    argv[argc+2] = var72;
     if (rval) {
-        *rval = var70;
+        *rval = var72;
     }
-    var56 = JS_TRUE;
+    var57 = JS_TRUE;
     do_return:
-    if (var69) {
-        JS_free(cx, var62);
-        var62 = NULL;
-        var69 = 0;
+    if (var70) {
+        free(var63);
+        var63 = NULL;
+        var70 = 0;
     }
-    return var56;
+    return var57;
 }
 static JSBool
 jjadmaddSegment(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
-    JSObject *var72;
-    int var77;
-    double var78;
-    double var79;
-    int var73;
-    int var76;
-    int var80;
-    jsval var81;
-    int32 var82;
-    int var83;
-    jsval var84;
-    jsdouble var85;
-    int var86;
-    jsval var87;
-    jsdouble var88;
+    JSObject *var74;
+    int var75;
+    int var78;
+    int var79;
+    int var82;
+    jsval var83;
+    int32 var84;
+    double var80;
+    int var85;
+    jsval var86;
+    jsdouble var87;
+    double var81;
+    int var88;
     jsval var89;
-    JSBool var71;
-    var72 = NULL;
-    var77 = 0;
-    var78 = 0.0;
-    var79 = 0.0;
-    var73 = 0;
-    var76 = 0;
-    var80 = 0;
-    var81 = JSVAL_NULL;
+    jsdouble var90;
+    jsval var91;
+    JSBool var73;
+    var74 = NULL;
+    var75 = 0;
+    var78 = 0;
+    var79 = 0;
     var82 = 0;
-    var83 = 0;
-    var84 = JSVAL_NULL;
-    var85 = 0.0;
-    var86 = 0;
-    var87 = JSVAL_NULL;
-    var88 = 0.0;
+    var83 = JSVAL_NULL;
+    var84 = 0;
+    var80 = 0.0;
+    var85 = 0;
+    var86 = JSVAL_NULL;
+    var87 = 0.0;
+    var81 = 0.0;
+    var88 = 0;
     var89 = JSVAL_NULL;
-    var71 = JS_FALSE;
-    var72 = obj;
-    var76 = argc;
-    var80 = 0;
-    var80 = var80 < var76;
-    if (var80) {
-    var81 = argv[0];
-    if (JS_ValueToInt32(cx, var81, &var82) != JS_TRUE) {
+    var90 = 0.0;
+    var91 = JSVAL_NULL;
+    var73 = JS_FALSE;
+    var74 = obj;
+    var78 = argc;
+    var82 = 0;
+    var82 = var82 < var78;
+    if (var82) {
+    var83 = argv[0];
+    if (JS_ValueToInt32(cx, var83, &var84) != JS_TRUE) {
         goto do_return;
     }
-    var77 = (int)var82;
+    var79 = (int)var84;
     }
-    var83 = 1;
-    var83 = var83 < var76;
-    if (var83) {
-    var84 = argv[1];
-    if (JS_ValueToNumber(cx, var84, &var85) != JS_TRUE) {
+    var85 = 1;
+    var85 = var85 < var78;
+    if (var85) {
+    var86 = argv[1];
+    if (JS_ValueToNumber(cx, var86, &var87) != JS_TRUE) {
         goto do_return;
     }
-    var78 = (double)var85;
+    var80 = (double)var87;
     }
-    var86 = 2;
-    var86 = var86 < var76;
-    if (var86) {
-    var87 = argv[2];
-    if (JS_ValueToNumber(cx, var87, &var88) != JS_TRUE) {
+    var88 = 2;
+    var88 = var88 < var78;
+    if (var88) {
+    var89 = argv[2];
+    if (JS_ValueToNumber(cx, var89, &var90) != JS_TRUE) {
         goto do_return;
     }
-    var79 = (double)var88;
+    var81 = (double)var90;
     }
-    var73 = jsAddSegment(var77, var78, var79);
-    if (JS_NewNumberValue(cx, var73, &var89) != JS_TRUE) {
+    var75 = jsAddSegment(var79, var80, var81);
+    if (JS_NewNumberValue(cx, var75, &var91) != JS_TRUE) {
         goto do_return;
     }
-    argv[argc+0] = var89;
+    argv[argc+0] = var91;
     if (rval) {
-        *rval = var89;
+        *rval = var91;
     }
-    var71 = JS_TRUE;
+    var73 = JS_TRUE;
     do_return:
-    return var71;
+    return var73;
 }
 static JSBool
 jjadmsetPostProc(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
-    JSObject *var91;
-    int var96;
+    JSObject *var93;
+    int var94;
     int var97;
     int var98;
-    int var92;
-    int var95;
+    int var101;
+    jsval var102;
+    int32 var103;
     int var99;
-    jsval var100;
-    int32 var101;
-    int var102;
-    jsval var103;
-    int32 var104;
-    int var105;
-    jsval var106;
-    int32 var107;
+    int var104;
+    jsval var105;
+    int32 var106;
+    int var100;
+    int var107;
     jsval var108;
-    JSBool var90;
-    var91 = NULL;
-    var96 = 0;
+    int32 var109;
+    jsval var110;
+    JSBool var92;
+    var93 = NULL;
+    var94 = 0;
     var97 = 0;
     var98 = 0;
-    var92 = 0;
-    var95 = 0;
+    var101 = 0;
+    var102 = JSVAL_NULL;
+    var103 = 0;
     var99 = 0;
-    var100 = JSVAL_NULL;
-    var101 = 0;
-    var102 = 0;
-    var103 = JSVAL_NULL;
     var104 = 0;
-    var105 = 0;
-    var106 = JSVAL_NULL;
+    var105 = JSVAL_NULL;
+    var106 = 0;
+    var100 = 0;
     var107 = 0;
     var108 = JSVAL_NULL;
-    var90 = JS_FALSE;
-    var91 = obj;
-    var95 = argc;
-    var99 = 0;
-    var99 = var99 < var95;
-    if (var99) {
-    var100 = argv[0];
-    if (JS_ValueToInt32(cx, var100, &var101) != JS_TRUE) {
+    var109 = 0;
+    var110 = JSVAL_NULL;
+    var92 = JS_FALSE;
+    var93 = obj;
+    var97 = argc;
+    var101 = 0;
+    var101 = var101 < var97;
+    if (var101) {
+    var102 = argv[0];
+    if (JS_ValueToInt32(cx, var102, &var103) != JS_TRUE) {
         goto do_return;
     }
-    var96 = (int)var101;
+    var98 = (int)var103;
     }
-    var102 = 1;
-    var102 = var102 < var95;
-    if (var102) {
-    var103 = argv[1];
-    if (JS_ValueToInt32(cx, var103, &var104) != JS_TRUE) {
+    var104 = 1;
+    var104 = var104 < var97;
+    if (var104) {
+    var105 = argv[1];
+    if (JS_ValueToInt32(cx, var105, &var106) != JS_TRUE) {
         goto do_return;
     }
-    var97 = (int)var104;
+    var99 = (int)var106;
     }
-    var105 = 2;
-    var105 = var105 < var95;
-    if (var105) {
-    var106 = argv[2];
-    if (JS_ValueToInt32(cx, var106, &var107) != JS_TRUE) {
+    var107 = 2;
+    var107 = var107 < var97;
+    if (var107) {
+    var108 = argv[2];
+    if (JS_ValueToInt32(cx, var108, &var109) != JS_TRUE) {
         goto do_return;
     }
-    var98 = (int)var107;
+    var100 = (int)var109;
     }
-    var92 = jsSetPostProc(var96, var97, var98);
-    if (JS_NewNumberValue(cx, var92, &var108) != JS_TRUE) {
+    var94 = jsSetPostProc(var98, var99, var100);
+    if (JS_NewNumberValue(cx, var94, &var110) != JS_TRUE) {
         goto do_return;
     }
-    argv[argc+0] = var108;
+    argv[argc+0] = var110;
     if (rval) {
-        *rval = var108;
+        *rval = var110;
     }
-    var90 = JS_TRUE;
+    var92 = JS_TRUE;
     do_return:
-    return var90;
+    return var92;
 }
 static JSBool
-jjadmaudioReset(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+jjadmgetWidth(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
-    JSObject *var110;
-    int var111;
-    int var114;
-    jsval var115;
-    JSBool var109;
-    var110 = NULL;
-    var111 = 0;
-    var114 = 0;
-    var115 = JSVAL_NULL;
-    var109 = JS_FALSE;
-    var110 = obj;
-    var114 = argc;
-    var111 = jsAudioReset();
-    if (JS_NewNumberValue(cx, var111, &var115) != JS_TRUE) {
+    JSObject *var112;
+    int var113;
+    int var116;
+    jsval var117;
+    JSBool var111;
+    var112 = NULL;
+    var113 = 0;
+    var116 = 0;
+    var117 = JSVAL_NULL;
+    var111 = JS_FALSE;
+    var112 = obj;
+    var116 = argc;
+    var113 = jsGetWidth();
+    if (JS_NewNumberValue(cx, var113, &var117) != JS_TRUE) {
         goto do_return;
     }
-    argv[argc+0] = var115;
+    argv[argc+0] = var117;
     if (rval) {
-        *rval = var115;
+        *rval = var117;
     }
-    var109 = JS_TRUE;
+    var111 = JS_TRUE;
     do_return:
-    return var109;
+    return var111;
 }
 static JSBool
-jjadmaudioMixer(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+jjadmgetHeight(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
-    JSObject *var117;
-    char *var122;
-    int var118;
-    int var121;
+    JSObject *var119;
+    int var120;
     int var123;
     jsval var124;
-    JSString *var125;
-    jsval var378;
-    size_t var126;
-    size_t var127;
-    int var129;
-    jschar *var128;
-    jsval var379;
-    jsval var130;
-    JSBool var116;
-    var117 = NULL;
-    var122 = NULL;
-    var118 = 0;
-    var121 = 0;
+    JSBool var118;
+    var119 = NULL;
+    var120 = 0;
     var123 = 0;
     var124 = JSVAL_NULL;
-    var125 = NULL;
-    var378 = JSVAL_NULL;
-    var126 = 0;
+    var118 = JS_FALSE;
+    var119 = obj;
+    var123 = argc;
+    var120 = jsGetHeight();
+    if (JS_NewNumberValue(cx, var120, &var124) != JS_TRUE) {
+        goto do_return;
+    }
+    argv[argc+0] = var124;
+    if (rval) {
+        *rval = var124;
+    }
+    var118 = JS_TRUE;
+    do_return:
+    return var118;
+}
+static JSBool
+jjadmgetFps1000(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject *var126;
+    int var127;
+    int var130;
+    jsval var131;
+    JSBool var125;
+    var126 = NULL;
     var127 = 0;
-    var129 = 0;
-    var128 = NULL;
-    var379 = JSVAL_NULL;
-    var130 = JSVAL_NULL;
-    var116 = JS_FALSE;
-    var117 = obj;
-    var121 = argc;
-    var123 = 0;
-    var123 = var123 < var121;
-    if (var123) {
-    var124 = argv[0];
-    var125 = JS_ValueToString(cx, var124);
-    if (!var125) {
+    var130 = 0;
+    var131 = JSVAL_NULL;
+    var125 = JS_FALSE;
+    var126 = obj;
+    var130 = argc;
+    var127 = jsGetFps1000();
+    if (JS_NewNumberValue(cx, var127, &var131) != JS_TRUE) {
         goto do_return;
     }
-    var378 = STRING_TO_JSVAL(var125);
-    argv[argc+0] = var378;
-    var126 = JS_GetStringLength(var125);
-    var127 = 1;
-    var127 += var126;
-    var122 = JS_malloc(cx, var127);
-    if (!var122) {
+    argv[argc+0] = var131;
+    if (rval) {
+        *rval = var131;
+    }
+    var125 = JS_TRUE;
+    do_return:
+    return var125;
+}
+static JSBool
+jjadmgetVideoCodec(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject *var133;
+    char *var134;
+    int var137;
+    jsval var138;
+    JSString *var139;
+    jsval var401;
+    char *var140;
+    jsval var402;
+    JSBool var132;
+    var133 = NULL;
+    var134 = NULL;
+    var137 = 0;
+    var138 = JSVAL_NULL;
+    var139 = NULL;
+    var401 = JSVAL_NULL;
+    var140 = NULL;
+    var402 = JSVAL_NULL;
+    var132 = JS_FALSE;
+    var133 = obj;
+    var137 = argc;
+    var134 = jsGetVideoCodec();
+    if (var134) {
+    var139 = JS_NewStringCopyZ(cx, var134);
+    if (!var139) {
         goto do_return;
     }
-    var129 = 1;
-    var128 = JS_GetStringChars(var125);
-    var379 = STRING_TO_JSVAL(var125);
-    argv[argc+1] = var379;
+    var401 = STRING_TO_JSVAL(var139);
+    argv[argc+0] = var401;
+    } else {
+    var140 = "";
+    var139 = JS_InternString(cx, var140);
+    if (!var139) {
+        goto do_return;
+    }
+    var402 = STRING_TO_JSVAL(var139);
+    argv[argc+1] = var402;
+    }
+    var138 = STRING_TO_JSVAL(var139);
+    if (rval) {
+        *rval = var138;
+    }
+    var132 = JS_TRUE;
+    do_return:
+    return var132;
+}
+static JSBool
+jjadmaudioReset(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject *var142;
+    int var143;
+    int var146;
+    jsval var147;
+    JSBool var141;
+    var142 = NULL;
+    var143 = 0;
+    var146 = 0;
+    var147 = JSVAL_NULL;
+    var141 = JS_FALSE;
+    var142 = obj;
+    var146 = argc;
+    var143 = jsAudioReset();
+    if (JS_NewNumberValue(cx, var143, &var147) != JS_TRUE) {
+        goto do_return;
+    }
+    argv[argc+0] = var147;
+    if (rval) {
+        *rval = var147;
+    }
+    var141 = JS_TRUE;
+    do_return:
+    return var141;
+}
+static JSBool
+jjadmaudioMixer(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject *var149;
+    int var150;
+    int var153;
+    char *var154;
+    int var155;
+    jsval var156;
+    JSString *var157;
+    jsval var404;
+    size_t var158;
+    size_t var159;
+    int var161;
+    jschar *var162;
+    jsval var405;
+    jsval var163;
+    JSBool var148;
+    var149 = NULL;
+    var150 = 0;
+    var153 = 0;
+    var154 = NULL;
+    var155 = 0;
+    var156 = JSVAL_NULL;
+    var157 = NULL;
+    var404 = JSVAL_NULL;
+    var158 = 0;
+    var159 = 0;
+    var161 = 0;
+    var162 = NULL;
+    var405 = JSVAL_NULL;
+    var163 = JSVAL_NULL;
+    var148 = JS_FALSE;
+    var149 = obj;
+    var153 = argc;
+    var155 = 0;
+    var155 = var155 < var153;
+    if (var155) {
+    var156 = argv[0];
+    var157 = JS_ValueToString(cx, var156);
+    if (!var157) {
+        goto do_return;
+    }
+    var404 = STRING_TO_JSVAL(var157);
+    argv[argc+0] = var404;
+    var158 = JS_GetStringLength(var157);
+    var159 = 1;
+    var159 += var158;
+#ifdef HAVE_ALLOCA
+    if (var159 < jj_alloca_limit) {
+        var154 = alloca(var159);
+    } else {
+#endif
+        var154 = malloc(var159);
+        if (!var154) {
+            goto do_return;
+        } else {
+            var161 = 1;
+        }
+#ifdef HAVE_ALLOCA
+    }
+#endif
+    var162 = JS_GetStringChars(var157);
+    var405 = STRING_TO_JSVAL(var157);
+    argv[argc+1] = var405;
     {
         size_t i;
-        for (i = 0; i < var126; ++i) {
-            var122[i] = wctob(var128[i]);
+        for (i = 0; i < var158; ++i) {
+            var154[i] = wctob(var162[i]);
         }
-        var122[var126] = '\0';
+        var154[var158] = '\0';
     }
     }
-    var118 = jsAudioMixer(var122);
-    if (JS_NewNumberValue(cx, var118, &var130) != JS_TRUE) {
+    var150 = jsAudioMixer(var154);
+    if (JS_NewNumberValue(cx, var150, &var163) != JS_TRUE) {
         goto do_return;
     }
-    argv[argc+2] = var130;
+    argv[argc+2] = var163;
     if (rval) {
-        *rval = var130;
+        *rval = var163;
     }
-    var116 = JS_TRUE;
+    var148 = JS_TRUE;
     do_return:
-    if (var129) {
-        JS_free(cx, var122);
-        var122 = NULL;
-        var129 = 0;
+    if (var161) {
+        free(var154);
+        var154 = NULL;
+        var161 = 0;
     }
-    return var116;
+    return var148;
 }
 static JSBool
 jjadmclearVideoFilters(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
-    JSObject *var132;
-    int var133;
-    int var136;
-    jsval var137;
-    JSBool var131;
-    var132 = NULL;
-    var133 = 0;
-    var136 = 0;
-    var137 = JSVAL_NULL;
-    var131 = JS_FALSE;
-    var132 = obj;
-    var136 = argc;
-    var133 = jsClearVideoFilters();
-    if (JS_NewNumberValue(cx, var133, &var137) != JS_TRUE) {
+    JSObject *var165;
+    int var166;
+    int var169;
+    jsval var170;
+    JSBool var164;
+    var165 = NULL;
+    var166 = 0;
+    var169 = 0;
+    var170 = JSVAL_NULL;
+    var164 = JS_FALSE;
+    var165 = obj;
+    var169 = argc;
+    var166 = jsClearVideoFilters();
+    if (JS_NewNumberValue(cx, var166, &var170) != JS_TRUE) {
         goto do_return;
     }
-    argv[argc+0] = var137;
+    argv[argc+0] = var170;
     if (rval) {
-        *rval = var137;
+        *rval = var170;
     }
-    var131 = JS_TRUE;
+    var164 = JS_TRUE;
     do_return:
-    return var131;
+    return var164;
 }
 static JSBool
 jjadmvideoCodec_ignore(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
-    JSObject *var139;
-    char *var144;
-    char **var145;
-    int var140;
-    int var143;
-    int var146;
-    jsval var147;
-    JSString *var148;
-    jsval var382;
-    size_t var149;
-    size_t var150;
-    int var152;
-    jschar *var151;
-    jsval var383;
-    int var153;
-    jsval var154;
-    JSObject *var155;
-    jsval var384;
-    jsuint var156;
-    char **var158;
-    size_t var159;
+    JSObject *var172;
+    int var173;
+    int var176;
+    char *var177;
+    int var179;
+    jsval var180;
+    JSString *var181;
+    jsval var408;
+    size_t var182;
+    size_t var183;
     int var185;
-    size_t var160;
-    JSString *var161;
-    size_t var162;
-    JSString **var168;
-    int var186;
-    jsuint var163;
-    jsint var164;
-    JSBool var165;
-    jsval var166;
-    JSString *var167;
-    jsval var385;
-    size_t var171;
-    jsuint var169;
-    jsint var170;
-    JSString *var173;
-    size_t var172;
-    size_t var174;
-    char var183;
-    size_t var184;
-    char *var175;
+    jschar *var186;
+    jsval var409;
+    char **var178;
     int var187;
-    char *var176;
-    size_t var177;
-    int var188;
-    char *var180;
-    jsuint var178;
-    jsint var179;
-    JSString *var182;
-    size_t var181;
-    size_t var189;
-    size_t var190;
-    int var192;
-    jschar *var191;
-    jsval var386;
-    jsval var193;
-    JSBool var138;
-    var139 = NULL;
-    var144 = NULL;
-    var145 = NULL;
-    var140 = 0;
-    var143 = 0;
-    var146 = 0;
-    var147 = JSVAL_NULL;
-    var148 = NULL;
-    var382 = JSVAL_NULL;
-    var149 = 0;
-    var150 = 0;
-    var152 = 0;
-    var151 = NULL;
-    var383 = JSVAL_NULL;
-    var153 = 0;
-    var154 = JSVAL_NULL;
-    var155 = NULL;
-    var384 = JSVAL_NULL;
-    var156 = 0;
-    var158 = NULL;
-    var159 = 0;
+    jsval var188;
+    JSObject *var189;
+    jsval var410;
+    jsuint var190;
+    size_t var194;
+    JSString *var195;
+    size_t var196;
+    JSString **var202;
+    int var219;
+    jsuint var197;
+    jsint var198;
+    JSBool var199;
+    jsval var200;
+    JSString *var201;
+    jsval var411;
+    size_t var205;
+    jsuint var203;
+    jsint var204;
+    JSString *var207;
+    size_t var206;
+    size_t var208;
+    char var217;
+    size_t var218;
+    char *var209;
+    int var220;
+    char *var210;
+    size_t var211;
+    int var221;
+    char *var214;
+    jsuint var212;
+    jsint var213;
+    JSString *var216;
+    size_t var215;
+    jschar *var222;
+    jsval var412;
+    jsval var223;
+    JSBool var171;
+    var172 = NULL;
+    var173 = 0;
+    var176 = 0;
+    var177 = NULL;
+    var179 = 0;
+    var180 = JSVAL_NULL;
+    var181 = NULL;
+    var408 = JSVAL_NULL;
+    var182 = 0;
+    var183 = 0;
     var185 = 0;
-    var160 = 0;
-    var161 = NULL;
-    var162 = 0;
-    var168 = NULL;
-    var186 = 0;
-    var163 = 0;
-    var164 = 0;
-    var165 = JS_FALSE;
-    var166 = JSVAL_NULL;
-    var167 = NULL;
-    var385 = JSVAL_NULL;
-    var171 = 0;
-    var169 = 0;
-    var170 = 0;
-    var173 = NULL;
-    var172 = 0;
-    var174 = 0;
-    var183 = 0;
-    var184 = 0;
-    var175 = NULL;
+    var186 = NULL;
+    var409 = JSVAL_NULL;
+    var178 = NULL;
     var187 = 0;
-    var176 = NULL;
-    var177 = 0;
-    var188 = 0;
-    var180 = NULL;
-    var178 = 0;
+    var188 = JSVAL_NULL;
+    var189 = NULL;
+    var410 = JSVAL_NULL;
+    var190 = 0;
+    var194 = 0;
+    var195 = NULL;
+    var196 = 0;
+    var202 = NULL;
+    var219 = 0;
+    var197 = 0;
+    var198 = 0;
+    var199 = JS_FALSE;
+    var200 = JSVAL_NULL;
+    var201 = NULL;
+    var411 = JSVAL_NULL;
+    var205 = 0;
+    var203 = 0;
+    var204 = 0;
+    var207 = NULL;
+    var206 = 0;
+    var208 = 0;
+    var217 = 0;
+    var218 = 0;
+    var209 = NULL;
+    var220 = 0;
+    var210 = NULL;
+    var211 = 0;
+    var221 = 0;
+    var214 = NULL;
+    var212 = 0;
+    var213 = 0;
+    var216 = NULL;
+    var215 = 0;
+    var222 = NULL;
+    var412 = JSVAL_NULL;
+    var223 = JSVAL_NULL;
+    var171 = JS_FALSE;
+    var172 = obj;
+    var176 = argc;
     var179 = 0;
-    var182 = NULL;
-    var181 = 0;
-    var189 = 0;
-    var190 = 0;
-    var192 = 0;
-    var191 = NULL;
-    var386 = JSVAL_NULL;
-    var193 = JSVAL_NULL;
-    var138 = JS_FALSE;
-    var139 = obj;
-    var143 = argc;
-    var146 = 0;
-    var146 = var146 < var143;
-    if (var146) {
-    var147 = argv[0];
-    var148 = JS_ValueToString(cx, var147);
-    if (!var148) {
+    var179 = var179 < var176;
+    if (var179) {
+    var180 = argv[0];
+    var181 = JS_ValueToString(cx, var180);
+    if (!var181) {
         goto do_return;
     }
-    var382 = STRING_TO_JSVAL(var148);
-    argv[argc+0] = var382;
-    var149 = JS_GetStringLength(var148);
-    var150 = 1;
-    var150 += var149;
-    var144 = JS_malloc(cx, var150);
-    if (!var144) {
-        goto do_return;
+    var408 = STRING_TO_JSVAL(var181);
+    argv[argc+0] = var408;
+    var182 = JS_GetStringLength(var181);
+    var183 = 1;
+    var183 += var182;
+#ifdef HAVE_ALLOCA
+    if (var183 < jj_alloca_limit) {
+        var177 = alloca(var183);
+    } else {
+#endif
+        var177 = malloc(var183);
+        if (!var177) {
+            goto do_return;
+        } else {
+            var185 = 1;
+        }
+#ifdef HAVE_ALLOCA
     }
-    var152 = 1;
-    var151 = JS_GetStringChars(var148);
-    var383 = STRING_TO_JSVAL(var148);
-    argv[argc+1] = var383;
+#endif
+    var186 = JS_GetStringChars(var181);
+    var409 = STRING_TO_JSVAL(var181);
+    argv[argc+1] = var409;
     {
         size_t i;
-        for (i = 0; i < var149; ++i) {
-            var144[i] = wctob(var151[i]);
+        for (i = 0; i < var182; ++i) {
+            var177[i] = wctob(var186[i]);
         }
-        var144[var149] = '\0';
+        var177[var182] = '\0';
     }
     }
-    var153 = 1;
-    var153 = var153 < var143;
-    if (var153) {
-    var154 = argv[1];
-    if (JS_ValueToObject(cx, var154, &var155) != JS_TRUE) {
+    var187 = 1;
+    var187 = var187 < var176;
+    if (var187) {
+    var188 = argv[1];
+    if (JS_ValueToObject(cx, var188, &var189) != JS_TRUE) {
         goto do_return;
     }
-    var384 = OBJECT_TO_JSVAL(var155);
-    argv[argc+2] = var384;
-    if (JS_GetArrayLength(cx, var155, &var156) != JS_TRUE) {
+    var410 = OBJECT_TO_JSVAL(var189);
+    argv[argc+2] = var410;
+    if (JS_GetArrayLength(cx, var189, &var190) != JS_TRUE) {
         goto do_return;
     }
-    var159 = sizeof(var158);
-    var159 *= var156;
-    var145 = JS_malloc(cx, var159);
-    if (!var145) {
-        goto do_return;
+    var194 = var190;
+    var196 = sizeof(var195);
+    var194 *= var196;
+#ifdef HAVE_ALLOCA
+    if (var194 < jj_alloca_limit) {
+        var202 = alloca(var194);
+    } else {
+#endif
+        var202 = malloc(var194);
+        if (!var202) {
+            goto do_return;
+        } else {
+            var219 = 1;
+        }
+#ifdef HAVE_ALLOCA
     }
-    var185 = 1;
-    var160 = var156;
-    var162 = sizeof(var161);
-    var160 *= var162;
-    var168 = JS_malloc(cx, var160);
-    if (!var168) {
-        goto do_return;
-    }
-    var186 = 1;
-    var163 = var156;
-    var164 = -1;
-    while (var163)
+#endif
+    var197 = var190;
+    var198 = -1;
+    while (var197)
     {
-    var163 += var164;
-    var165 = JS_GetElement(cx, var155, var163, &var166);
-    var167 = JS_ValueToString(cx, var166);
-    if (!var167) {
+    var197 += var198;
+    var199 = JS_GetElement(cx, var189, var197, &var200);
+    var201 = JS_ValueToString(cx, var200);
+    if (!var201) {
         goto do_return;
     }
-    var385 = STRING_TO_JSVAL(var167);
-    argv[argc+3] = var385;
-    var168[var163] = var167;
+    var411 = STRING_TO_JSVAL(var201);
+    argv[argc+3] = var411;
+    var202[var197] = var201;
     }
-    var171 = 0;
-    var169 = var156;
-    var170 = -1;
-    while (var169)
+    var205 = 0;
+    var203 = var190;
+    var204 = -1;
+    while (var203)
     {
-    var169 += var170;
-    var173 = var168[var169];
-    var172 = JS_GetStringLength(var173);
-    var171 += var172;
-    var174 = 1;
-    var171 += var174;
+    var203 += var204;
+    var207 = var202[var203];
+    var206 = JS_GetStringLength(var207);
+    var205 += var206;
+    var208 = 1;
+    var205 += var208;
     }
-    var184 = sizeof(var183);
-    var184 *= var171;
-    var175 = JS_malloc(cx, var184);
-    if (!var175) {
-        goto do_return;
+    var218 = sizeof(var217);
+    var218 *= var205;
+#ifdef HAVE_ALLOCA
+    if (var218 < jj_alloca_limit) {
+        var209 = alloca(var218);
+    } else {
+#endif
+        var209 = malloc(var218);
+        if (!var209) {
+            goto do_return;
+        } else {
+            var220 = 1;
+        }
+#ifdef HAVE_ALLOCA
     }
-    var187 = 1;
-    var177 = sizeof(var176);
-    var177 *= var156;
-    var145 = JS_malloc(cx, var177);
-    if (!var145) {
-        goto do_return;
+#endif
+    var211 = sizeof(var210);
+    var211 *= var190;
+#ifdef HAVE_ALLOCA
+    if (var211 < jj_alloca_limit) {
+        var178 = alloca(var211);
+    } else {
+#endif
+        var178 = malloc(var211);
+        if (!var178) {
+            goto do_return;
+        } else {
+            var221 = 1;
+        }
+#ifdef HAVE_ALLOCA
     }
-    var188 = 1;
-    var180 = var175;
-    var180 += var171;
-    var178 = var156;
-    var179 = -1;
-    while (var178)
+#endif
+    var214 = var209;
+    var214 += var205;
+    var212 = var190;
+    var213 = -1;
+    while (var212)
     {
-    var178 += var179;
-    var182 = var168[var178];
-    var181 = JS_GetStringLength(var182);
-    var180 -= var181;
-    var180 += var179;
-    var189 = JS_GetStringLength(var182);
-    var190 = 1;
-    var190 += var189;
-    var180 = JS_malloc(cx, var190);
-    if (!var180) {
-        goto do_return;
-    }
-    var192 = 1;
-    var191 = JS_GetStringChars(var182);
-    var386 = STRING_TO_JSVAL(var182);
-    argv[argc+4] = var386;
+    var212 += var213;
+    var216 = var202[var212];
+    var215 = JS_GetStringLength(var216);
+    var214 -= var215;
+    var214 += var213;
+    var222 = JS_GetStringChars(var216);
+    var412 = STRING_TO_JSVAL(var216);
+    argv[argc+4] = var412;
     {
         size_t i;
-        for (i = 0; i < var189; ++i) {
-            var180[i] = wctob(var191[i]);
+        for (i = 0; i < var215; ++i) {
+            var214[i] = wctob(var222[i]);
         }
-        var180[var189] = '\0';
+        var214[var215] = '\0';
     }
-    var145[var178] = var180;
+    var178[var212] = var214;
     }
     }
-    var140 = jsVideoCodec(var144, var145);
-    if (JS_NewNumberValue(cx, var140, &var193) != JS_TRUE) {
+    var173 = jsVideoCodec(var177, var178);
+    if (JS_NewNumberValue(cx, var173, &var223) != JS_TRUE) {
         goto do_return;
     }
-    argv[argc+5] = var193;
+    argv[argc+5] = var223;
     if (rval) {
-        *rval = var193;
+        *rval = var223;
     }
-    var138 = JS_TRUE;
+    var171 = JS_TRUE;
     do_return:
-    if (var192) {
-        JS_free(cx, var180);
-        var180 = NULL;
-        var192 = 0;
+    if (var221) {
+        free(var178);
+        var178 = NULL;
+        var221 = 0;
     }
-    if (var188) {
-        JS_free(cx, var145);
-        var145 = NULL;
-        var188 = 0;
+    if (var220) {
+        free(var209);
+        var209 = NULL;
+        var220 = 0;
     }
-    if (var187) {
-        JS_free(cx, var175);
-        var175 = NULL;
-        var187 = 0;
+    if (var219) {
+        free(var202);
+        var202 = NULL;
+        var219 = 0;
     }
-    if (var186) {
-        JS_free(cx, var168);
-        var168 = NULL;
-        var186 = 0;
-    }
     if (var185) {
-        JS_free(cx, var145);
-        var145 = NULL;
+        free(var177);
+        var177 = NULL;
         var185 = 0;
     }
-    if (var152) {
-        JS_free(cx, var144);
-        var144 = NULL;
-        var152 = 0;
-    }
-    return var138;
+    return var171;
 }
 static JSBool
 jjadmaddVideoFilter_ignore(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
-    JSObject *var195;
-    char *var200;
-    char **var201;
-    int var196;
-    int var199;
-    int var202;
-    jsval var203;
-    JSString *var204;
-    jsval var388;
-    size_t var205;
-    size_t var206;
-    int var208;
-    jschar *var207;
-    jsval var389;
-    int var209;
-    jsval var210;
-    JSObject *var211;
-    jsval var390;
-    jsuint var212;
-    char **var214;
-    size_t var215;
-    int var241;
-    size_t var216;
-    JSString *var217;
-    size_t var218;
-    JSString **var224;
-    int var242;
-    jsuint var219;
-    jsint var220;
-    JSBool var221;
-    jsval var222;
-    JSString *var223;
-    jsval var391;
-    size_t var227;
-    jsuint var225;
-    jsint var226;
-    JSString *var229;
-    size_t var228;
-    size_t var230;
-    char var239;
-    size_t var240;
-    char *var231;
-    int var243;
-    char *var232;
-    size_t var233;
-    int var244;
-    char *var236;
-    jsuint var234;
-    jsint var235;
-    JSString *var238;
-    size_t var237;
-    size_t var245;
-    size_t var246;
-    int var248;
-    jschar *var247;
-    jsval var392;
-    jsval var249;
-    JSBool var194;
-    var195 = NULL;
-    var200 = NULL;
-    var201 = NULL;
-    var196 = 0;
-    var199 = 0;
-    var202 = 0;
-    var203 = JSVAL_NULL;
-    var204 = NULL;
-    var388 = JSVAL_NULL;
-    var205 = 0;
-    var206 = 0;
-    var208 = 0;
-    var207 = NULL;
-    var389 = JSVAL_NULL;
-    var209 = 0;
-    var210 = JSVAL_NULL;
-    var211 = NULL;
-    var390 = JSVAL_NULL;
-    var212 = 0;
-    var214 = NULL;
-    var215 = 0;
-    var241 = 0;
-    var216 = 0;
-    var217 = NULL;
-    var218 = 0;
-    var224 = NULL;
-    var242 = 0;
-    var219 = 0;
-    var220 = 0;
-    var221 = JS_FALSE;
-    var222 = JSVAL_NULL;
-    var223 = NULL;
-    var391 = JSVAL_NULL;
-    var227 = 0;
-    var225 = 0;
+    JSObject *var225;
+    int var226;
+    int var229;
+    char *var230;
+    int var232;
+    jsval var233;
+    JSString *var234;
+    jsval var414;
+    size_t var235;
+    size_t var236;
+    int var238;
+    jschar *var239;
+    jsval var415;
+    char **var231;
+    int var240;
+    jsval var241;
+    JSObject *var242;
+    jsval var416;
+    jsuint var243;
+    size_t var247;
+    JSString *var248;
+    size_t var249;
+    JSString **var255;
+    int var272;
+    jsuint var250;
+    jsint var251;
+    JSBool var252;
+    jsval var253;
+    JSString *var254;
+    jsval var417;
+    size_t var258;
+    jsuint var256;
+    jsint var257;
+    JSString *var260;
+    size_t var259;
+    size_t var261;
+    char var270;
+    size_t var271;
+    char *var262;
+    int var273;
+    char *var263;
+    size_t var264;
+    int var274;
+    char *var267;
+    jsuint var265;
+    jsint var266;
+    JSString *var269;
+    size_t var268;
+    jschar *var275;
+    jsval var418;
+    jsval var276;
+    JSBool var224;
+    var225 = NULL;
     var226 = 0;
-    var229 = NULL;
-    var228 = 0;
-    var230 = 0;
-    var239 = 0;
+    var229 = 0;
+    var230 = NULL;
+    var232 = 0;
+    var233 = JSVAL_NULL;
+    var234 = NULL;
+    var414 = JSVAL_NULL;
+    var235 = 0;
+    var236 = 0;
+    var238 = 0;
+    var239 = NULL;
+    var415 = JSVAL_NULL;
+    var231 = NULL;
     var240 = 0;
-    var231 = NULL;
+    var241 = JSVAL_NULL;
+    var242 = NULL;
+    var416 = JSVAL_NULL;
     var243 = 0;
-    var232 = NULL;
-    var233 = 0;
-    var244 = 0;
-    var236 = NULL;
-    var234 = 0;
-    var235 = 0;
-    var238 = NULL;
-    var237 = 0;
-    var245 = 0;
-    var246 = 0;
-    var248 = 0;
-    var247 = NULL;
-    var392 = JSVAL_NULL;
-    var249 = JSVAL_NULL;
-    var194 = JS_FALSE;
-    var195 = obj;
-    var199 = argc;
-    var202 = 0;
-    var202 = var202 < var199;
-    if (var202) {
-    var203 = argv[0];
-    var204 = JS_ValueToString(cx, var203);
-    if (!var204) {
+    var247 = 0;
+    var248 = NULL;
+    var249 = 0;
+    var255 = NULL;
+    var272 = 0;
+    var250 = 0;
+    var251 = 0;
+    var252 = JS_FALSE;
+    var253 = JSVAL_NULL;
+    var254 = NULL;
+    var417 = JSVAL_NULL;
+    var258 = 0;
+    var256 = 0;
+    var257 = 0;
+    var260 = NULL;
+    var259 = 0;
+    var261 = 0;
+    var270 = 0;
+    var271 = 0;
+    var262 = NULL;
+    var273 = 0;
+    var263 = NULL;
+    var264 = 0;
+    var274 = 0;
+    var267 = NULL;
+    var265 = 0;
+    var266 = 0;
+    var269 = NULL;
+    var268 = 0;
+    var275 = NULL;
+    var418 = JSVAL_NULL;
+    var276 = JSVAL_NULL;
+    var224 = JS_FALSE;
+    var225 = obj;
+    var229 = argc;
+    var232 = 0;
+    var232 = var232 < var229;
+    if (var232) {
+    var233 = argv[0];
+    var234 = JS_ValueToString(cx, var233);
+    if (!var234) {
         goto do_return;
     }
-    var388 = STRING_TO_JSVAL(var204);
-    argv[argc+0] = var388;
-    var205 = JS_GetStringLength(var204);
-    var206 = 1;
-    var206 += var205;
-    var200 = JS_malloc(cx, var206);
-    if (!var200) {
-        goto do_return;
+    var414 = STRING_TO_JSVAL(var234);
+    argv[argc+0] = var414;
+    var235 = JS_GetStringLength(var234);
+    var236 = 1;
+    var236 += var235;
+#ifdef HAVE_ALLOCA
+    if (var236 < jj_alloca_limit) {
+        var230 = alloca(var236);
+    } else {
+#endif
+        var230 = malloc(var236);
+        if (!var230) {
+            goto do_return;
+        } else {
+            var238 = 1;
+        }
+#ifdef HAVE_ALLOCA
     }
-    var208 = 1;
-    var207 = JS_GetStringChars(var204);
-    var389 = STRING_TO_JSVAL(var204);
-    argv[argc+1] = var389;
+#endif
+    var239 = JS_GetStringChars(var234);
+    var415 = STRING_TO_JSVAL(var234);
+    argv[argc+1] = var415;
     {
         size_t i;
-        for (i = 0; i < var205; ++i) {
-            var200[i] = wctob(var207[i]);
+        for (i = 0; i < var235; ++i) {
+            var230[i] = wctob(var239[i]);
         }
-        var200[var205] = '\0';
+        var230[var235] = '\0';
     }
     }
-    var209 = 1;
-    var209 = var209 < var199;
-    if (var209) {
-    var210 = argv[1];
-    if (JS_ValueToObject(cx, var210, &var211) != JS_TRUE) {
+    var240 = 1;
+    var240 = var240 < var229;
+    if (var240) {
+    var241 = argv[1];
+    if (JS_ValueToObject(cx, var241, &var242) != JS_TRUE) {
         goto do_return;
     }
-    var390 = OBJECT_TO_JSVAL(var211);
-    argv[argc+2] = var390;
-    if (JS_GetArrayLength(cx, var211, &var212) != JS_TRUE) {
+    var416 = OBJECT_TO_JSVAL(var242);
+    argv[argc+2] = var416;
+    if (JS_GetArrayLength(cx, var242, &var243) != JS_TRUE) {
         goto do_return;
     }
-    var215 = sizeof(var214);
-    var215 *= var212;
-    var201 = JS_malloc(cx, var215);
-    if (!var201) {
-        goto do_return;
+    var247 = var243;
+    var249 = sizeof(var248);
+    var247 *= var249;
+#ifdef HAVE_ALLOCA
+    if (var247 < jj_alloca_limit) {
+        var255 = alloca(var247);
+    } else {
+#endif
+        var255 = malloc(var247);
+        if (!var255) {
+            goto do_return;
+        } else {
+            var272 = 1;
+        }
+#ifdef HAVE_ALLOCA
     }
-    var241 = 1;
-    var216 = var212;
-    var218 = sizeof(var217);
-    var216 *= var218;
-    var224 = JS_malloc(cx, var216);
-    if (!var224) {
-        goto do_return;
-    }
-    var242 = 1;
-    var219 = var212;
-    var220 = -1;
-    while (var219)
+#endif
+    var250 = var243;
+    var251 = -1;
+    while (var250)
     {
-    var219 += var220;
-    var221 = JS_GetElement(cx, var211, var219, &var222);
-    var223 = JS_ValueToString(cx, var222);
-    if (!var223) {
+    var250 += var251;
+    var252 = JS_GetElement(cx, var242, var250, &var253);
+    var254 = JS_ValueToString(cx, var253);
+    if (!var254) {
         goto do_return;
     }
-    var391 = STRING_TO_JSVAL(var223);
-    argv[argc+3] = var391;
-    var224[var219] = var223;
+    var417 = STRING_TO_JSVAL(var254);
+    argv[argc+3] = var417;
+    var255[var250] = var254;
     }
-    var227 = 0;
-    var225 = var212;
-    var226 = -1;
-    while (var225)
+    var258 = 0;
+    var256 = var243;
+    var257 = -1;
+    while (var256)
     {
-    var225 += var226;
-    var229 = var224[var225];
-    var228 = JS_GetStringLength(var229);
-    var227 += var228;
-    var230 = 1;
-    var227 += var230;
+    var256 += var257;
+    var260 = var255[var256];
+    var259 = JS_GetStringLength(var260);
+    var258 += var259;
+    var261 = 1;
+    var258 += var261;
     }
-    var240 = sizeof(var239);
-    var240 *= var227;
-    var231 = JS_malloc(cx, var240);
-    if (!var231) {
-        goto do_return;
+    var271 = sizeof(var270);
+    var271 *= var258;
+#ifdef HAVE_ALLOCA
+    if (var271 < jj_alloca_limit) {
+        var262 = alloca(var271);
+    } else {
+#endif
+        var262 = malloc(var271);
+        if (!var262) {
+            goto do_return;
+        } else {
+            var273 = 1;
+        }
+#ifdef HAVE_ALLOCA
     }
-    var243 = 1;
-    var233 = sizeof(var232);
-    var233 *= var212;
-    var201 = JS_malloc(cx, var233);
-    if (!var201) {
-        goto do_return;
+#endif
+    var264 = sizeof(var263);
+    var264 *= var243;
+#ifdef HAVE_ALLOCA
+    if (var264 < jj_alloca_limit) {
+        var231 = alloca(var264);
+    } else {
+#endif
+        var231 = malloc(var264);
+        if (!var231) {
+            goto do_return;
+        } else {
+            var274 = 1;
+        }
+#ifdef HAVE_ALLOCA
     }
-    var244 = 1;
-    var236 = var231;
-    var236 += var227;
-    var234 = var212;
-    var235 = -1;
-    while (var234)
+#endif
+    var267 = var262;
+    var267 += var258;
+    var265 = var243;
+    var266 = -1;
+    while (var265)
     {
-    var234 += var235;
-    var238 = var224[var234];
-    var237 = JS_GetStringLength(var238);
-    var236 -= var237;
-    var236 += var235;
-    var245 = JS_GetStringLength(var238);
-    var246 = 1;
-    var246 += var245;
-    var236 = JS_malloc(cx, var246);
-    if (!var236) {
-        goto do_return;
-    }
-    var248 = 1;
-    var247 = JS_GetStringChars(var238);
-    var392 = STRING_TO_JSVAL(var238);
-    argv[argc+4] = var392;
+    var265 += var266;
+    var269 = var255[var265];
+    var268 = JS_GetStringLength(var269);
+    var267 -= var268;
+    var267 += var266;
+    var275 = JS_GetStringChars(var269);
+    var418 = STRING_TO_JSVAL(var269);
+    argv[argc+4] = var418;
     {
         size_t i;
-        for (i = 0; i < var245; ++i) {
-            var236[i] = wctob(var247[i]);
+        for (i = 0; i < var268; ++i) {
+            var267[i] = wctob(var275[i]);
         }
-        var236[var245] = '\0';
+        var267[var268] = '\0';
     }
-    var201[var234] = var236;
+    var231[var265] = var267;
     }
     }
-    var196 = jsVideoFilter(var200, var201);
-    if (JS_NewNumberValue(cx, var196, &var249) != JS_TRUE) {
+    var226 = jsVideoFilter(var230, var231);
+    if (JS_NewNumberValue(cx, var226, &var276) != JS_TRUE) {
         goto do_return;
     }
-    argv[argc+5] = var249;
+    argv[argc+5] = var276;
     if (rval) {
-        *rval = var249;
+        *rval = var276;
     }
-    var194 = JS_TRUE;
+    var224 = JS_TRUE;
     do_return:
-    if (var248) {
-        JS_free(cx, var236);
-        var236 = NULL;
-        var248 = 0;
-    }
-    if (var244) {
-        JS_free(cx, var201);
-        var201 = NULL;
-        var244 = 0;
-    }
-    if (var243) {
-        JS_free(cx, var231);
+    if (var274) {
+        free(var231);
         var231 = NULL;
-        var243 = 0;
+        var274 = 0;
     }
-    if (var242) {
-        JS_free(cx, var224);
-        var224 = NULL;
-        var242 = 0;
+    if (var273) {
+        free(var262);
+        var262 = NULL;
+        var273 = 0;
     }
-    if (var241) {
-        JS_free(cx, var201);
-        var201 = NULL;
-        var241 = 0;
+    if (var272) {
+        free(var255);
+        var255 = NULL;
+        var272 = 0;
     }
-    if (var208) {
-        JS_free(cx, var200);
-        var200 = NULL;
-        var208 = 0;
+    if (var238) {
+        free(var230);
+        var230 = NULL;
+        var238 = 0;
     }
-    return var194;
+    return var224;
 }
 static JSBool
 jjadmaudioCodec_ignore(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
-    JSObject *var251;
-    char *var256;
-    char **var257;
-    int var252;
-    int var255;
-    int var258;
-    jsval var259;
-    JSString *var260;
-    jsval var394;
-    size_t var261;
-    size_t var262;
-    int var264;
-    jschar *var263;
-    jsval var395;
-    int var265;
-    jsval var266;
-    JSObject *var267;
-    jsval var396;
-    jsuint var268;
-    char **var270;
-    size_t var271;
-    int var297;
-    size_t var272;
-    JSString *var273;
-    size_t var274;
-    JSString **var280;
-    int var298;
-    jsuint var275;
-    jsint var276;
-    JSBool var277;
-    jsval var278;
-    JSString *var279;
-    jsval var397;
-    size_t var283;
-    jsuint var281;
-    jsint var282;
-    JSString *var285;
-    size_t var284;
-    size_t var286;
-    char var295;
-    size_t var296;
-    char *var287;
-    int var299;
-    char *var288;
+    JSObject *var278;
+    int var279;
+    int var282;
+    char *var283;
+    int var285;
+    jsval var286;
+    JSString *var287;
+    jsval var420;
+    size_t var288;
     size_t var289;
-    int var300;
-    char *var292;
-    jsuint var290;
-    jsint var291;
-    JSString *var294;
-    size_t var293;
-    size_t var301;
+    int var291;
+    jschar *var292;
+    jsval var421;
+    char **var284;
+    int var293;
+    jsval var294;
+    JSObject *var295;
+    jsval var422;
+    jsuint var296;
+    size_t var300;
+    JSString *var301;
     size_t var302;
-    int var304;
-    jschar *var303;
-    jsval var398;
-    jsval var305;
-    JSBool var250;
-    var251 = NULL;
-    var256 = NULL;
-    var257 = NULL;
-    var252 = 0;
-    var255 = 0;
-    var258 = 0;
-    var259 = JSVAL_NULL;
-    var260 = NULL;
-    var394 = JSVAL_NULL;
-    var261 = 0;
-    var262 = 0;
-    var264 = 0;
-    var263 = NULL;
-    var395 = JSVAL_NULL;
-    var265 = 0;
-    var266 = JSVAL_NULL;
-    var267 = NULL;
-    var396 = JSVAL_NULL;
-    var268 = 0;
-    var270 = NULL;
-    var271 = 0;
-    var297 = 0;
-    var272 = 0;
-    var273 = NULL;
-    var274 = 0;
-    var280 = NULL;
-    var298 = 0;
-    var275 = 0;
-    var276 = 0;
-    var277 = JS_FALSE;
-    var278 = JSVAL_NULL;
-    var279 = NULL;
-    var397 = JSVAL_NULL;
-    var283 = 0;
-    var281 = 0;
+    JSString **var308;
+    int var325;
+    jsuint var303;
+    jsint var304;
+    JSBool var305;
+    jsval var306;
+    JSString *var307;
+    jsval var423;
+    size_t var311;
+    jsuint var309;
+    jsint var310;
+    JSString *var313;
+    size_t var312;
+    size_t var314;
+    char var323;
+    size_t var324;
+    char *var315;
+    int var326;
+    char *var316;
+    size_t var317;
+    int var327;
+    char *var320;
+    jsuint var318;
+    jsint var319;
+    JSString *var322;
+    size_t var321;
+    jschar *var328;
+    jsval var424;
+    jsval var329;
+    JSBool var277;
+    var278 = NULL;
+    var279 = 0;
     var282 = 0;
-    var285 = NULL;
-    var284 = 0;
-    var286 = 0;
-    var295 = 0;
-    var296 = 0;
+    var283 = NULL;
+    var285 = 0;
+    var286 = JSVAL_NULL;
     var287 = NULL;
-    var299 = 0;
-    var288 = NULL;
+    var420 = JSVAL_NULL;
+    var288 = 0;
     var289 = 0;
-    var300 = 0;
+    var291 = 0;
     var292 = NULL;
-    var290 = 0;
-    var291 = 0;
-    var294 = NULL;
+    var421 = JSVAL_NULL;
+    var284 = NULL;
     var293 = 0;
-    var301 = 0;
+    var294 = JSVAL_NULL;
+    var295 = NULL;
+    var422 = JSVAL_NULL;
+    var296 = 0;
+    var300 = 0;
+    var301 = NULL;
     var302 = 0;
+    var308 = NULL;
+    var325 = 0;
+    var303 = 0;
     var304 = 0;
-    var303 = NULL;
-    var398 = JSVAL_NULL;
-    var305 = JSVAL_NULL;
-    var250 = JS_FALSE;
-    var251 = obj;
-    var255 = argc;
-    var258 = 0;
-    var258 = var258 < var255;
-    if (var258) {
-    var259 = argv[0];
-    var260 = JS_ValueToString(cx, var259);
-    if (!var260) {
+    var305 = JS_FALSE;
+    var306 = JSVAL_NULL;
+    var307 = NULL;
+    var423 = JSVAL_NULL;
+    var311 = 0;
+    var309 = 0;
+    var310 = 0;
+    var313 = NULL;
+    var312 = 0;
+    var314 = 0;
+    var323 = 0;
+    var324 = 0;
+    var315 = NULL;
+    var326 = 0;
+    var316 = NULL;
+    var317 = 0;
+    var327 = 0;
+    var320 = NULL;
+    var318 = 0;
+    var319 = 0;
+    var322 = NULL;
+    var321 = 0;
+    var328 = NULL;
+    var424 = JSVAL_NULL;
+    var329 = JSVAL_NULL;
+    var277 = JS_FALSE;
+    var278 = obj;
+    var282 = argc;
+    var285 = 0;
+    var285 = var285 < var282;
+    if (var285) {
+    var286 = argv[0];
+    var287 = JS_ValueToString(cx, var286);
+    if (!var287) {
         goto do_return;
     }
-    var394 = STRING_TO_JSVAL(var260);
-    argv[argc+0] = var394;
-    var261 = JS_GetStringLength(var260);
-    var262 = 1;
-    var262 += var261;
-    var256 = JS_malloc(cx, var262);
-    if (!var256) {
-        goto do_return;
+    var420 = STRING_TO_JSVAL(var287);
+    argv[argc+0] = var420;
+    var288 = JS_GetStringLength(var287);
+    var289 = 1;
+    var289 += var288;
+#ifdef HAVE_ALLOCA
+    if (var289 < jj_alloca_limit) {
+        var283 = alloca(var289);
+    } else {
+#endif
+        var283 = malloc(var289);
+        if (!var283) {
+            goto do_return;
+        } else {
+            var291 = 1;
+        }
+#ifdef HAVE_ALLOCA
     }
-    var264 = 1;
-    var263 = JS_GetStringChars(var260);
-    var395 = STRING_TO_JSVAL(var260);
-    argv[argc+1] = var395;
+#endif
+    var292 = JS_GetStringChars(var287);
+    var421 = STRING_TO_JSVAL(var287);
+    argv[argc+1] = var421;
     {
         size_t i;
-        for (i = 0; i < var261; ++i) {
-            var256[i] = wctob(var263[i]);
+        for (i = 0; i < var288; ++i) {
+            var283[i] = wctob(var292[i]);
         }
-        var256[var261] = '\0';
+        var283[var288] = '\0';
     }
     }
-    var265 = 1;
-    var265 = var265 < var255;
-    if (var265) {
-    var266 = argv[1];
-    if (JS_ValueToObject(cx, var266, &var267) != JS_TRUE) {
+    var293 = 1;
+    var293 = var293 < var282;
+    if (var293) {
+    var294 = argv[1];
+    if (JS_ValueToObject(cx, var294, &var295) != JS_TRUE) {
         goto do_return;
     }
-    var396 = OBJECT_TO_JSVAL(var267);
-    argv[argc+2] = var396;
-    if (JS_GetArrayLength(cx, var267, &var268) != JS_TRUE) {
+    var422 = OBJECT_TO_JSVAL(var295);
+    argv[argc+2] = var422;
+    if (JS_GetArrayLength(cx, var295, &var296) != JS_TRUE) {
         goto do_return;
     }
-    var271 = sizeof(var270);
-    var271 *= var268;
-    var257 = JS_malloc(cx, var271);
-    if (!var257) {
-        goto do_return;
+    var300 = var296;
+    var302 = sizeof(var301);
+    var300 *= var302;
+#ifdef HAVE_ALLOCA
+    if (var300 < jj_alloca_limit) {
+        var308 = alloca(var300);
+    } else {
+#endif
+        var308 = malloc(var300);
+        if (!var308) {
+            goto do_return;
+        } else {
+            var325 = 1;
+        }
+#ifdef HAVE_ALLOCA
     }
-    var297 = 1;
-    var272 = var268;
-    var274 = sizeof(var273);
-    var272 *= var274;
-    var280 = JS_malloc(cx, var272);
-    if (!var280) {
-        goto do_return;
-    }
-    var298 = 1;
-    var275 = var268;
-    var276 = -1;
-    while (var275)
+#endif
+    var303 = var296;
+    var304 = -1;
+    while (var303)
     {
-    var275 += var276;
-    var277 = JS_GetElement(cx, var267, var275, &var278);
-    var279 = JS_ValueToString(cx, var278);
-    if (!var279) {
+    var303 += var304;
+    var305 = JS_GetElement(cx, var295, var303, &var306);
+    var307 = JS_ValueToString(cx, var306);
+    if (!var307) {
         goto do_return;
     }
-    var397 = STRING_TO_JSVAL(var279);
-    argv[argc+3] = var397;
-    var280[var275] = var279;
+    var423 = STRING_TO_JSVAL(var307);
+    argv[argc+3] = var423;
+    var308[var303] = var307;
     }
-    var283 = 0;
-    var281 = var268;
-    var282 = -1;
-    while (var281)
+    var311 = 0;
+    var309 = var296;
+    var310 = -1;
+    while (var309)
     {
-    var281 += var282;
-    var285 = var280[var281];
-    var284 = JS_GetStringLength(var285);
-    var283 += var284;
-    var286 = 1;
-    var283 += var286;
+    var309 += var310;
+    var313 = var308[var309];
+    var312 = JS_GetStringLength(var313);
+    var311 += var312;
+    var314 = 1;
+    var311 += var314;
     }
-    var296 = sizeof(var295);
-    var296 *= var283;
-    var287 = JS_malloc(cx, var296);
-    if (!var287) {
-        goto do_return;
+    var324 = sizeof(var323);
+    var324 *= var311;
+#ifdef HAVE_ALLOCA
+    if (var324 < jj_alloca_limit) {
+        var315 = alloca(var324);
+    } else {
+#endif
+        var315 = malloc(var324);
+        if (!var315) {
+            goto do_return;
+        } else {
+            var326 = 1;
+        }
+#ifdef HAVE_ALLOCA
     }
-    var299 = 1;
-    var289 = sizeof(var288);
-    var289 *= var268;
-    var257 = JS_malloc(cx, var289);
-    if (!var257) {
-        goto do_return;
+#endif
+    var317 = sizeof(var316);
+    var317 *= var296;
+#ifdef HAVE_ALLOCA
+    if (var317 < jj_alloca_limit) {
+        var284 = alloca(var317);
+    } else {
+#endif
+        var284 = malloc(var317);
+        if (!var284) {
+            goto do_return;
+        } else {
+            var327 = 1;
+        }
+#ifdef HAVE_ALLOCA
     }
-    var300 = 1;
-    var292 = var287;
-    var292 += var283;
-    var290 = var268;
-    var291 = -1;
-    while (var290)
+#endif
+    var320 = var315;
+    var320 += var311;
+    var318 = var296;
+    var319 = -1;
+    while (var318)
     {
-    var290 += var291;
-    var294 = var280[var290];
-    var293 = JS_GetStringLength(var294);
-    var292 -= var293;
-    var292 += var291;
-    var301 = JS_GetStringLength(var294);
-    var302 = 1;
-    var302 += var301;
-    var292 = JS_malloc(cx, var302);
-    if (!var292) {
-        goto do_return;
-    }
-    var304 = 1;
-    var303 = JS_GetStringChars(var294);
-    var398 = STRING_TO_JSVAL(var294);
-    argv[argc+4] = var398;
+    var318 += var319;
+    var322 = var308[var318];
+    var321 = JS_GetStringLength(var322);
+    var320 -= var321;
+    var320 += var319;
+    var328 = JS_GetStringChars(var322);
+    var424 = STRING_TO_JSVAL(var322);
+    argv[argc+4] = var424;
     {
         size_t i;
-        for (i = 0; i < var301; ++i) {
-            var292[i] = wctob(var303[i]);
+        for (i = 0; i < var321; ++i) {
+            var320[i] = wctob(var328[i]);
         }
-        var292[var301] = '\0';
+        var320[var321] = '\0';
     }
-    var257[var290] = var292;
+    var284[var318] = var320;
     }
     }
-    var252 = jsAudioCodec(var256, var257);
-    if (JS_NewNumberValue(cx, var252, &var305) != JS_TRUE) {
+    var279 = jsAudioCodec(var283, var284);
+    if (JS_NewNumberValue(cx, var279, &var329) != JS_TRUE) {
         goto do_return;
     }
-    argv[argc+5] = var305;
+    argv[argc+5] = var329;
     if (rval) {
-        *rval = var305;
+        *rval = var329;
     }
-    var250 = JS_TRUE;
+    var277 = JS_TRUE;
     do_return:
-    if (var304) {
-        JS_free(cx, var292);
-        var292 = NULL;
-        var304 = 0;
+    if (var327) {
+        free(var284);
+        var284 = NULL;
+        var327 = 0;
     }
-    if (var300) {
-        JS_free(cx, var257);
-        var257 = NULL;
-        var300 = 0;
+    if (var326) {
+        free(var315);
+        var315 = NULL;
+        var326 = 0;
     }
-    if (var299) {
-        JS_free(cx, var287);
-        var287 = NULL;
-        var299 = 0;
+    if (var325) {
+        free(var308);
+        var308 = NULL;
+        var325 = 0;
     }
-    if (var298) {
-        JS_free(cx, var280);
-        var280 = NULL;
-        var298 = 0;
+    if (var291) {
+        free(var283);
+        var283 = NULL;
+        var291 = 0;
     }
-    if (var297) {
-        JS_free(cx, var257);
-        var257 = NULL;
-        var297 = 0;
-    }
-    if (var264) {
-        JS_free(cx, var256);
-        var256 = NULL;
-        var264 = 0;
-    }
-    return var250;
+    return var277;
 }
 static JSBool
 jjadmsetContainer_ignore(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
-    JSObject *var307;
-    char *var312;
-    char **var313;
-    int var308;
-    int var311;
-    int var314;
-    jsval var315;
-    JSString *var316;
-    jsval var400;
-    size_t var317;
-    size_t var318;
-    int var320;
-    jschar *var319;
-    jsval var401;
-    int var321;
-    jsval var322;
-    JSObject *var323;
-    jsval var402;
-    jsuint var324;
-    char **var326;
-    size_t var327;
-    int var353;
-    size_t var328;
-    JSString *var329;
-    size_t var330;
-    JSString **var336;
-    int var354;
-    jsuint var331;
-    jsint var332;
-    JSBool var333;
-    jsval var334;
-    JSString *var335;
-    jsval var403;
-    size_t var339;
-    jsuint var337;
-    jsint var338;
-    JSString *var341;
-    size_t var340;
+    JSObject *var331;
+    int var332;
+    int var335;
+    char *var336;
+    int var338;
+    jsval var339;
+    JSString *var340;
+    jsval var426;
+    size_t var341;
     size_t var342;
-    char var351;
-    size_t var352;
-    char *var343;
-    int var355;
-    char *var344;
-    size_t var345;
-    int var356;
-    char *var348;
-    jsuint var346;
-    jsint var347;
-    JSString *var350;
-    size_t var349;
-    size_t var357;
-    size_t var358;
-    int var360;
-    jschar *var359;
-    jsval var404;
-    jsval var361;
-    JSBool var306;
-    var307 = NULL;
-    var312 = NULL;
-    var313 = NULL;
-    var308 = 0;
-    var311 = 0;
-    var314 = 0;
-    var315 = JSVAL_NULL;
-    var316 = NULL;
-    var400 = JSVAL_NULL;
-    var317 = 0;
-    var318 = 0;
-    var320 = 0;
-    var319 = NULL;
-    var401 = JSVAL_NULL;
-    var321 = 0;
-    var322 = JSVAL_NULL;
-    var323 = NULL;
-    var402 = JSVAL_NULL;
-    var324 = 0;
-    var326 = NULL;
-    var327 = 0;
-    var353 = 0;
-    var328 = 0;
-    var329 = NULL;
-    var330 = 0;
+    int var344;
+    jschar *var345;
+    jsval var427;
+    char **var337;
+    int var346;
+    jsval var347;
+    JSObject *var348;
+    jsval var428;
+    jsuint var349;
+    size_t var353;
+    JSString *var354;
+    size_t var355;
+    JSString **var361;
+    int var378;
+    jsuint var356;
+    jsint var357;
+    JSBool var358;
+    jsval var359;
+    JSString *var360;
+    jsval var429;
+    size_t var364;
+    jsuint var362;
+    jsint var363;
+    JSString *var366;
+    size_t var365;
+    size_t var367;
+    char var376;
+    size_t var377;
+    char *var368;
+    int var379;
+    char *var369;
+    size_t var370;
+    int var380;
+    char *var373;
+    jsuint var371;
+    jsint var372;
+    JSString *var375;
+    size_t var374;
+    jschar *var381;
+    jsval var430;
+    jsval var382;
+    JSBool var330;
+    var331 = NULL;
+    var332 = 0;
+    var335 = 0;
     var336 = NULL;
-    var354 = 0;
-    var331 = 0;
-    var332 = 0;
-    var333 = JS_FALSE;
-    var334 = JSVAL_NULL;
-    var335 = NULL;
-    var403 = JSVAL_NULL;
-    var339 = 0;
-    var337 = 0;
     var338 = 0;
-    var341 = NULL;
-    var340 = 0;
+    var339 = JSVAL_NULL;
+    var340 = NULL;
+    var426 = JSVAL_NULL;
+    var341 = 0;
     var342 = 0;
-    var351 = 0;
-    var352 = 0;
-    var343 = NULL;
+    var344 = 0;
+    var345 = NULL;
+    var427 = JSVAL_NULL;
+    var337 = NULL;
+    var346 = 0;
+    var347 = JSVAL_NULL;
+    var348 = NULL;
+    var428 = JSVAL_NULL;
+    var349 = 0;
+    var353 = 0;
+    var354 = NULL;
     var355 = 0;
-    var344 = NULL;
-    var345 = 0;
+    var361 = NULL;
+    var378 = 0;
     var356 = 0;
-    var348 = NULL;
-    var346 = 0;
-    var347 = 0;
-    var350 = NULL;
-    var349 = 0;
     var357 = 0;
-    var358 = 0;
-    var360 = 0;
-    var359 = NULL;
-    var404 = JSVAL_NULL;
-    var361 = JSVAL_NULL;
-    var306 = JS_FALSE;
-    var307 = obj;
-    var311 = argc;
-    var314 = 0;
-    var314 = var314 < var311;
-    if (var314) {
-    var315 = argv[0];
-    var316 = JS_ValueToString(cx, var315);
-    if (!var316) {
+    var358 = JS_FALSE;
+    var359 = JSVAL_NULL;
+    var360 = NULL;
+    var429 = JSVAL_NULL;
+    var364 = 0;
+    var362 = 0;
+    var363 = 0;
+    var366 = NULL;
+    var365 = 0;
+    var367 = 0;
+    var376 = 0;
+    var377 = 0;
+    var368 = NULL;
+    var379 = 0;
+    var369 = NULL;
+    var370 = 0;
+    var380 = 0;
+    var373 = NULL;
+    var371 = 0;
+    var372 = 0;
+    var375 = NULL;
+    var374 = 0;
+    var381 = NULL;
+    var430 = JSVAL_NULL;
+    var382 = JSVAL_NULL;
+    var330 = JS_FALSE;
+    var331 = obj;
+    var335 = argc;
+    var338 = 0;
+    var338 = var338 < var335;
+    if (var338) {
+    var339 = argv[0];
+    var340 = JS_ValueToString(cx, var339);
+    if (!var340) {
         goto do_return;
     }
-    var400 = STRING_TO_JSVAL(var316);
-    argv[argc+0] = var400;
-    var317 = JS_GetStringLength(var316);
-    var318 = 1;
-    var318 += var317;
-    var312 = JS_malloc(cx, var318);
-    if (!var312) {
-        goto do_return;
+    var426 = STRING_TO_JSVAL(var340);
+    argv[argc+0] = var426;
+    var341 = JS_GetStringLength(var340);
+    var342 = 1;
+    var342 += var341;
+#ifdef HAVE_ALLOCA
+    if (var342 < jj_alloca_limit) {
+        var336 = alloca(var342);
+    } else {
+#endif
+        var336 = malloc(var342);
+        if (!var336) {
+            goto do_return;
+        } else {
+            var344 = 1;
+        }
+#ifdef HAVE_ALLOCA
     }
-    var320 = 1;
-    var319 = JS_GetStringChars(var316);
-    var401 = STRING_TO_JSVAL(var316);
-    argv[argc+1] = var401;
+#endif
+    var345 = JS_GetStringChars(var340);
+    var427 = STRING_TO_JSVAL(var340);
+    argv[argc+1] = var427;
     {
         size_t i;
-        for (i = 0; i < var317; ++i) {
-            var312[i] = wctob(var319[i]);
+        for (i = 0; i < var341; ++i) {
+            var336[i] = wctob(var345[i]);
         }
-        var312[var317] = '\0';
+        var336[var341] = '\0';
     }
     }
-    var321 = 1;
-    var321 = var321 < var311;
-    if (var321) {
-    var322 = argv[1];
-    if (JS_ValueToObject(cx, var322, &var323) != JS_TRUE) {
+    var346 = 1;
+    var346 = var346 < var335;
+    if (var346) {
+    var347 = argv[1];
+    if (JS_ValueToObject(cx, var347, &var348) != JS_TRUE) {
         goto do_return;
     }
-    var402 = OBJECT_TO_JSVAL(var323);
-    argv[argc+2] = var402;
-    if (JS_GetArrayLength(cx, var323, &var324) != JS_TRUE) {
+    var428 = OBJECT_TO_JSVAL(var348);
+    argv[argc+2] = var428;
+    if (JS_GetArrayLength(cx, var348, &var349) != JS_TRUE) {
         goto do_return;
     }
-    var327 = sizeof(var326);
-    var327 *= var324;
-    var313 = JS_malloc(cx, var327);
-    if (!var313) {
-        goto do_return;
+    var353 = var349;
+    var355 = sizeof(var354);
+    var353 *= var355;
+#ifdef HAVE_ALLOCA
+    if (var353 < jj_alloca_limit) {
+        var361 = alloca(var353);
+    } else {
+#endif
+        var361 = malloc(var353);
+        if (!var361) {
+            goto do_return;
+        } else {
+            var378 = 1;
+        }
+#ifdef HAVE_ALLOCA
     }
-    var353 = 1;
-    var328 = var324;
-    var330 = sizeof(var329);
-    var328 *= var330;
-    var336 = JS_malloc(cx, var328);
-    if (!var336) {
-        goto do_return;
-    }
-    var354 = 1;
-    var331 = var324;
-    var332 = -1;
-    while (var331)
+#endif
+    var356 = var349;
+    var357 = -1;
+    while (var356)
     {
-    var331 += var332;
-    var333 = JS_GetElement(cx, var323, var331, &var334);
-    var335 = JS_ValueToString(cx, var334);
-    if (!var335) {
+    var356 += var357;
+    var358 = JS_GetElement(cx, var348, var356, &var359);
+    var360 = JS_ValueToString(cx, var359);
+    if (!var360) {
         goto do_return;
     }
-    var403 = STRING_TO_JSVAL(var335);
-    argv[argc+3] = var403;
-    var336[var331] = var335;
+    var429 = STRING_TO_JSVAL(var360);
+    argv[argc+3] = var429;
+    var361[var356] = var360;
     }
-    var339 = 0;
-    var337 = var324;
-    var338 = -1;
-    while (var337)
+    var364 = 0;
+    var362 = var349;
+    var363 = -1;
+    while (var362)
     {
-    var337 += var338;
-    var341 = var336[var337];
-    var340 = JS_GetStringLength(var341);
-    var339 += var340;
-    var342 = 1;
-    var339 += var342;
+    var362 += var363;
+    var366 = var361[var362];
+    var365 = JS_GetStringLength(var366);
+    var364 += var365;
+    var367 = 1;
+    var364 += var367;
     }
-    var352 = sizeof(var351);
-    var352 *= var339;
-    var343 = JS_malloc(cx, var352);
-    if (!var343) {
-        goto do_return;
+    var377 = sizeof(var376);
+    var377 *= var364;
+#ifdef HAVE_ALLOCA
+    if (var377 < jj_alloca_limit) {
+        var368 = alloca(var377);
+    } else {
+#endif
+        var368 = malloc(var377);
+        if (!var368) {
+            goto do_return;
+        } else {
+            var379 = 1;
+        }
+#ifdef HAVE_ALLOCA
     }
-    var355 = 1;
-    var345 = sizeof(var344);
-    var345 *= var324;
-    var313 = JS_malloc(cx, var345);
-    if (!var313) {
-        goto do_return;
+#endif
+    var370 = sizeof(var369);
+    var370 *= var349;
+#ifdef HAVE_ALLOCA
+    if (var370 < jj_alloca_limit) {
+        var337 = alloca(var370);
+    } else {
+#endif
+        var337 = malloc(var370);
+        if (!var337) {
+            goto do_return;
+        } else {
+            var380 = 1;
+        }
+#ifdef HAVE_ALLOCA
     }
-    var356 = 1;
-    var348 = var343;
-    var348 += var339;
-    var346 = var324;
-    var347 = -1;
-    while (var346)
+#endif
+    var373 = var368;
+    var373 += var364;
+    var371 = var349;
+    var372 = -1;
+    while (var371)
     {
-    var346 += var347;
-    var350 = var336[var346];
-    var349 = JS_GetStringLength(var350);
-    var348 -= var349;
-    var348 += var347;
-    var357 = JS_GetStringLength(var350);
-    var358 = 1;
-    var358 += var357;
-    var348 = JS_malloc(cx, var358);
-    if (!var348) {
-        goto do_return;
-    }
-    var360 = 1;
-    var359 = JS_GetStringChars(var350);
-    var404 = STRING_TO_JSVAL(var350);
-    argv[argc+4] = var404;
+    var371 += var372;
+    var375 = var361[var371];
+    var374 = JS_GetStringLength(var375);
+    var373 -= var374;
+    var373 += var372;
+    var381 = JS_GetStringChars(var375);
+    var430 = STRING_TO_JSVAL(var375);
+    argv[argc+4] = var430;
     {
         size_t i;
-        for (i = 0; i < var357; ++i) {
-            var348[i] = wctob(var359[i]);
+        for (i = 0; i < var374; ++i) {
+            var373[i] = wctob(var381[i]);
         }
-        var348[var357] = '\0';
+        var373[var374] = '\0';
     }
-    var313[var346] = var348;
+    var337[var371] = var373;
     }
     }
-    var308 = jsSetContainer(var312, var313);
-    if (JS_NewNumberValue(cx, var308, &var361) != JS_TRUE) {
+    var332 = jsSetContainer(var336, var337);
+    if (JS_NewNumberValue(cx, var332, &var382) != JS_TRUE) {
         goto do_return;
     }
-    argv[argc+5] = var361;
+    argv[argc+5] = var382;
     if (rval) {
-        *rval = var361;
+        *rval = var382;
     }
-    var306 = JS_TRUE;
+    var330 = JS_TRUE;
     do_return:
-    if (var360) {
-        JS_free(cx, var348);
-        var348 = NULL;
-        var360 = 0;
+    if (var380) {
+        free(var337);
+        var337 = NULL;
+        var380 = 0;
     }
-    if (var356) {
-        JS_free(cx, var313);
-        var313 = NULL;
-        var356 = 0;
+    if (var379) {
+        free(var368);
+        var368 = NULL;
+        var379 = 0;
     }
-    if (var355) {
-        JS_free(cx, var343);
-        var343 = NULL;
-        var355 = 0;
+    if (var378) {
+        free(var361);
+        var361 = NULL;
+        var378 = 0;
     }
-    if (var354) {
-        JS_free(cx, var336);
+    if (var344) {
+        free(var336);
         var336 = NULL;
-        var354 = 0;
+        var344 = 0;
     }
-    if (var353) {
-        JS_free(cx, var313);
-        var313 = NULL;
-        var353 = 0;
-    }
-    if (var320) {
-        JS_free(cx, var312);
-        var312 = NULL;
-        var320 = 0;
-    }
-    return var306;
+    return var330;
 }
 static JSBool
 jjadm__construct__(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
-    JSObject *var363;
-    int var367;
-    JSBool var362;
-    var363 = NULL;
-    var367 = 0;
-    var362 = JS_FALSE;
-    var363 = obj;
-    var367 = argc;
+    JSObject *var384;
+    int var388;
+    JSBool var383;
+    var384 = NULL;
+    var388 = 0;
+    var383 = JS_FALSE;
+    var384 = obj;
+    var388 = argc;
     jsAvidemux();
-    var362 = JS_TRUE;
-    return var362;
+    var383 = JS_TRUE;
+    return var383;
 }
 static JSPropertySpec jjadm_static_ps[] = {
     {"markerA", 0, 0|JSPROP_ENUMERATE, jjadmmarkerA_get, jjadmmarkerA_set},
@@ -1871,6 +2030,10 @@
     JS_FS("appendVideo", jjadmappendVideo, 1, 0, 3),
     JS_FS("addSegment", jjadmaddSegment, 3, 0, 1),
     JS_FS("setPostProc", jjadmsetPostProc, 3, 0, 1),
+    JS_FS("getWidth", jjadmgetWidth, 0, 0, 1),
+    JS_FS("getHeight", jjadmgetHeight, 0, 0, 1),
+    JS_FS("getFps1000", jjadmgetFps1000, 0, 0, 1),
+    JS_FS("getVideoCodec", jjadmgetVideoCodec, 0, 0, 2),
     JS_FS("audioReset", jjadmaudioReset, 0, 0, 1),
     JS_FS("audioMixer", jjadmaudioMixer, 1, 0, 3),
     JS_FS("clearVideoFilters", jjadmclearVideoFilters, 0, 0, 1),

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsAvidemux_js.idl
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsAvidemux_js.idl	2010-01-02 16:30:45 UTC (rev 5811)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsAvidemux_js.idl	2010-01-02 16:30:47 UTC (rev 5812)
@@ -14,6 +14,10 @@
         function int appendVideo    : jsAppendVideo (cstring ) <static>;
         function int addSegment     : jsAddSegment (int ,double , double ) <static>;
         function int setPostProc    : jsSetPostProc (int ,int , int ) <static>;
+        function int getWidth       : jsGetWidth ( ) <static>;
+        function int getHeight      : jsGetHeight ( ) <static>;
+        function int getFps1000     : jsGetFps1000 ( ) <static>;
+     function cstring getVideoCodec : jsGetVideoCodec ( ) <static>;
         /*            JSFUNC                 C FUNC           PARAM     */
         function int audioReset     : jsAudioReset () <static>;
         function int audioMixer     : jsAudioMixer (cstring ) <static>;

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/CMakeLists.txt	2010-01-02 16:30:45 UTC (rev 5811)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/CMakeLists.txt	2010-01-02 16:30:47 UTC (rev 5812)
@@ -9,6 +9,7 @@
         ADM_jsTestFactory_js.c
 # Load segment
         ADM_jsAvidemux.cpp
+        ADM_jsAvidemuxInfo.cpp
         ADM_jsAvidemux_js.c
 # Debug / editor class
         ADM_jsEditor.cpp



From mean at mail.berlios.de  Sat Jan  2 17:30:50 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 2 Jan 2010 17:30:50 +0100
Subject: [Avidemux-svn-commit] r5813 -
	branches/avidemux_2.6_branch_mean/avidemux/common
Message-ID: <201001021630.o02GUoTM012006@sheep.berlios.de>

Author: mean
Date: 2010-01-02 17:30:50 +0100 (Sat, 02 Jan 2010)
New Revision: 5813

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/gui_navigate.cpp
Log:
[ui/navigate] Display time also in the mm:ss:ms format when seeking

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/gui_navigate.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/gui_navigate.cpp	2010-01-02 16:30:47 UTC (rev 5812)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/gui_navigate.cpp	2010-01-02 16:30:50 UTC (rev 5813)
@@ -60,13 +60,14 @@
           tme/=ADM_SCALE_SIZE;
           uint64_t pts=(uint64_t)tme;
           ADM_info("Scale Time:%"LLU" ms (total=%"LLU" ms)\n",pts/1000,video_body->getDurationInUs()/1000);
+          ADM_info("Scale Time:%s ms \n",ADM_us2plain(pts));
            if(false==video_body->getPKFramePTS(&pts))
             {
-                ADM_warning("Cannot seel to %"LLU" ms\n",pts/1000);
+                ADM_warning("Cannot seek to %"LLU" ms\n",pts/1000);
                 ignore_change--;
                 break;
             }
-            
+             ADM_info("Seeking to  Time:%s ms \n",ADM_us2plain(pts));
             if(true!=admPreview::seekToIntraPts(pts))
             {
                 ADM_warning("Scale: Seeking to intra at %"LLU" ms failed\n",pts/1000);



From mean at mail.berlios.de  Sat Jan  2 17:30:52 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 2 Jan 2010 17:30:52 +0100
Subject: [Avidemux-svn-commit] r5814 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegPS
Message-ID: <201001021630.o02GUqwq012017@sheep.berlios.de>

Author: mean
Date: 2010-01-02 17:30:51 +0100 (Sat, 02 Jan 2010)
New Revision: 5814

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegPS/ADM_psIndex.cpp
Log:
[PsDemuxer] Detect movies with time wrapping, only take the first part + some preparatory work to detect interlaced (field encoded) meg2

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegPS/ADM_psIndex.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegPS/ADM_psIndex.cpp	2010-01-02 16:30:50 UTC (rev 5813)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegPS/ADM_psIndex.cpp	2010-01-02 16:30:51 UTC (rev 5814)
@@ -53,6 +53,8 @@
     uint32_t h;
     uint32_t fps;
     uint32_t interlaced;
+    uint32_t frameNumber;
+    uint32_t fieldNumber;
     uint32_t ar;
 }PSVideo;
 
@@ -89,6 +91,8 @@
         psPacketLinearTracker *pkt;
         listOfPsAudioTracks *audioTracks;
         DIA_workingBase  *ui;
+        bool             headerDumped;
+        uint64_t         lastValidVideoDts;
 public:
                 PsIndexer(void);
                 ~PsIndexer();
@@ -121,6 +125,8 @@
     pkt=NULL;
     audioTracks=NULL;
     ui=createWorking ("Indexing");
+    headerDumped=false;
+    lastValidVideoDts=ADM_NO_PTS;
 }
 
 /**
@@ -147,7 +153,7 @@
 PSVideo video;
 indexerData  data;    
 dmxPacketInfo info;
-
+    memset(&video,0,sizeof(video));
     memset(&data,0,sizeof(data));
     char indexName[strlen(file)+5];
     sprintf(indexName,"%s.idx2",file);
@@ -206,6 +212,7 @@
                           //
                           seq_found=1;
                           val=pkt->readi32();
+                          video.interlaced=0; // how to detect ?
                           video.w=val>>20;
                           video.w=((video.w+15)&~15);
                           video.h= (((val>>8) & 0xfff)+15)& ~15;
@@ -215,11 +222,47 @@
                           
                           video.fps= FPS[val & 0xf];
                           pkt->forward(4);
-                          writeVideo(&video);
-                          writeAudio();
                           pkt->resetStats();
-                          qfprintf(index,"[Data]");
                           break;
+                  case 0xB5: //  extension
+                                { 
+                                    uint8_t id=pkt->readi8()>>4;
+                                    uint8_t two;
+                                    switch(id)
+                                    {
+                                        case 1: // Sequence extension
+                                            val=(val>>3)&1; // gop type progressive, unreliable, not used
+                                            break;
+                                        case 8: // picture coding extension (mpeg2)
+                                        {
+                                            // skip motion vector
+                                            uint8_t picture_structure;
+                                            pkt->forward(1); // 4*4 bits
+                                            two=pkt->readi8();
+                                            picture_structure=(two)&3;
+                                            
+                                            //printf("Picture type %02x struct:%x\n",two,picture_structure);
+                                            switch(picture_structure)
+                                            {
+                                            case 3: video.frameNumber++;break;
+                                            case 1:
+                                            case 2:  video.fieldNumber++;break;
+                                            default: ADM_warning("frame type 0 met, this is illegal\n");
+                                            }
+                                        }
+                                        default:break;
+                                    }
+                                }
+#if 0
+#define EXT_SIZE 6
+                                    uint8_t ext[EXT_SIZE];
+                                    pkt->read(EXT_SIZE,ext);
+                                    printf("Sequence Extension :");
+                                    for(int i=0;i<EXT_SIZE;i++) printf("%02x ",ext[i]);
+                                    printf("\n");
+#endif
+                                
+                                break;
                   case 0xb8: // GOP
                           // Update ui
                             {
@@ -231,6 +274,12 @@
                             }
 
                           if(!seq_found) continue;
+                          if(headerDumped==false)
+                          {
+                               
+                                qfprintf(index,"[Data]");
+                                headerDumped=true;
+                          }
                           if(data.state==idx_startAtGopOrSeq) 
                           {         
                                   continue;;
@@ -258,8 +307,20 @@
                                                   info.startAt,info.offset);
                                   continue;
                           }
+                          if(lastValidVideoDts!=ADM_NO_PTS && info.dts!=ADM_NO_PTS)
+                          {
+                                    if(lastValidVideoDts>info.dts)
+                                    {
+                                            ADM_warning("DTS are going back, aborting, maybe several video appended ?");
+                                            goto theEnd;
+                                     }
+                            }
+                            if(info.dts!=ADM_NO_PTS)
+                            {
+                                    lastValidVideoDts=info.dts;
+                            }
+                           
                           
-                          
                           if(data.state==idx_startAtGopOrSeq) 
                           {
                                 update=markEnd;
@@ -274,9 +335,17 @@
                     break;
                   }
       }
-    
+theEnd:    
         printf("\n");
+        // Dump progressive/frame gop
         Mark(&data,&info,markStart);
+        
+        qfprintf(index,"\n# Found %"LU" images \n",data.nbPics); // Size
+        qfprintf(index,"# Found %"LU" frame pictures\n",video.frameNumber); // Size
+        qfprintf(index,"# Found %"LU" field pictures\n",video.fieldNumber); // Size
+        // Now write the header
+        writeVideo(&video);
+        writeAudio();
         qfprintf(index,"\n[End]\n");
         qfclose(index);
         index=NULL;
@@ -358,7 +427,10 @@
     qfprintf(index,"[Video]\n");
     qfprintf(index,"Width=%d\n",video->w);
     qfprintf(index,"Height=%d\n",video->h);
-    qfprintf(index,"Fps=%d\n",video->fps);
+    if(video->interlaced)
+        qfprintf(index,"Fps=%d\n",video->fps*2);
+    else
+        qfprintf(index,"Fps=%d\n",video->fps);
     qfprintf(index,"Interlaced=%d\n",video->interlaced);
     qfprintf(index,"AR=%d\n",video->ar);
     return true;



From mean at mail.berlios.de  Sat Jan  2 17:30:53 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 2 Jan 2010 17:30:53 +0100
Subject: [Avidemux-svn-commit] r5815 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegPS
Message-ID: <201001021630.o02GUr7s012030@sheep.berlios.de>

Author: mean
Date: 2010-01-02 17:30:53 +0100 (Sat, 02 Jan 2010)
New Revision: 5815

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegPS/ADM_ps.cpp
Log:
[PSdemuxer] Speed up cleanup

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegPS/ADM_ps.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegPS/ADM_ps.cpp	2010-01-02 16:30:51 UTC (rev 5814)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegPS/ADM_ps.cpp	2010-01-02 16:30:53 UTC (rev 5815)
@@ -174,11 +174,13 @@
 uint8_t psHeader::close(void)
 {
     // Destroy index
-    while(ListOfFrames.size())
+    int nb=ListOfFrames.size();
+    for(int i=0;i<nb;i++)
     {
-        delete ListOfFrames[0];
-        ListOfFrames.erase(ListOfFrames.begin());
+        if(ListOfFrames[i]) delete ListOfFrames[i];
+        ListOfFrames[i]=0;
     }
+    ListOfFrames.clear();
     if(psPacket)
     {
         psPacket->close();



From mean at mail.berlios.de  Sat Jan  2 17:31:01 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 2 Jan 2010 17:31:01 +0100
Subject: [Avidemux-svn-commit] r5816 - in
	branches/avidemux_2.6_branch_mean/avidemux: common
	gtk/ADM_userInterfaces/ADM_filters
Message-ID: <201001021631.o02GV1Wh012043@sheep.berlios.de>

Author: mean
Date: 2010-01-02 17:30:57 +0100 (Sat, 02 Jan 2010)
New Revision: 5816

Removed:
   branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_filters/gui_filterlist.cpp
   branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_filters/gui_filtermanager_dialog.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.cpp
   branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_filters/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_filters/gui_filtermanager.cpp
Log:
[Gtk] Improve a bit the filter manager, still broken. Remove obsolete files

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.cpp	2010-01-02 16:30:53 UTC (rev 5815)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.cpp	2010-01-02 16:30:57 UTC (rev 5816)
@@ -48,9 +48,7 @@
 #include "ADM_commonUI/GUI_ui.h"
 #include "ADM_preview.h"
 #define MAX(a,b) ( (a)>(b) ? (a) : (b) )
-
-//extern FILTER  videofilters[VF_MAX_FILTER];
-//extern uint32_t nb_active_filter;
+#include "DIA_coreToolkit.h"
 extern void    UI_setCurrentTime(uint64_t curTime);
 
 static void previewBlit(ADMImage *from,ADMImage *to,uint32_t startx,uint32_t starty);
@@ -679,43 +677,16 @@
 */
 bool admPreview::previousFrame(void)
 {
-#if 0
     uint64_t pts=rdrImage->Pts;
-    // If the frame is not an intra, the previous one
-    // is still in the cache
-    if(rdrImage->flags!=AVI_KEY_FRAME)
+    ADMImage *tmpImage=NULL;
+    //tmpImage=video_body->seekAndGetImageBefore(pts);
+    if(!tmpImage)
     {
-        
-        if(true==video_body->getImageFromCacheForFrameBefore(pts,rdrImage))
-        {
-            renderUpdateImage(rdrImage->data,zoom);
-            return true;
-        }
+        GUI_Error_HIG("Seek","Cannot find previous frame");
         return false;
     }
-
-    // Else go to the previous  keyframe...
-    if(!video_body->getPKFrame(&frame)) return false;
-    if(!video_body->GoToIntra(frame)) return false;
-    // Now forward until we reach our frame
-    if(!video_body->samePicture(rdrImage)) return false;
-    if(rdrImage->Pts==pts) 
-    {
-            renderUpdateImage(rdrImage->data,zoom);
-            return true;
-    }
-    while(1)
-    {
-        if(!video_body->NextPicture(rdrImage)) return false;
-        if(rdrImage->Pts==pts) break;
-    }
-    if(rdrImage->Pts!=pts) return false;
-    if(true==video_body->getImageFromCacheForFrameBefore(pts,rdrImage))
-    {
-        renderUpdateImage(rdrImage->data,zoom);
-        return true;
-    }
-#endif
-    return false;
+    rdrImage=tmpImage;
+    renderUpdateImage(rdrImage->data,zoom);
+    return true;
 }
 // EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_filters/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_filters/CMakeLists.txt	2010-01-02 16:30:53 UTC (rev 5815)
+++ branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_filters/CMakeLists.txt	2010-01-02 16:30:57 UTC (rev 5816)
@@ -1,7 +1,8 @@
 SET(ADM_LIB ADM_filtersGtk)
 
 SET(${ADM_LIB}_SRCS
-	gui_filtermanager.cpp  gui_filtermanager_dialog.cpp)
+	gui_filtermanager.cpp  
+)
 
 ADD_LIBRARY(${ADM_LIB} STATIC ${${ADM_LIB}_SRCS})
 FILE(GLOB ADM_filterIcons ${AVIDEMUX_TOP_SOURCE_DIR}/avidemux/common/ADM_icons/videoFilter/*.png)

Deleted: branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_filters/gui_filterlist.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_filters/gui_filterlist.cpp	2010-01-02 16:30:53 UTC (rev 5815)
+++ branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_filters/gui_filterlist.cpp	2010-01-02 16:30:57 UTC (rev 5816)
@@ -1,313 +0,0 @@
-/*
-	gui_filterlist
-	Build the dialog box that list all available filters
-
-
-*/
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include "config.h"
-#include "ADM_toolkitGtk.h"
-#include "ADM_default.h"
-
-GtkListStore 	*storeFilterList;
-GtkWidget	*create_dialogList (void)
-{
-  GtkWidget *dialog1;
-  GtkWidget *dialog_vbox1;
-  GtkWidget *notebook1;
-  GtkWidget *scrolledwindow1;
-  GtkWidget *treeview11;
-  GtkWidget *hbox1;
-  GtkWidget *image1;
-  GtkWidget *label17;
-  GtkWidget *scrolledwindow2;
-  GtkWidget *treeview12;
-  GtkWidget *hbox2;
-  GtkWidget *image2;
-  GtkWidget *label18;
-  GtkWidget *scrolledwindow3;
-  GtkWidget *treeview13;
-  GtkWidget *hbox3;
-  GtkWidget *image3;
-  GtkWidget *label19;
-  GtkWidget *scrolledwindow4;
-  GtkWidget *treeview14;
-  GtkWidget *hbox4;
-  GtkWidget *image4;
-  GtkWidget *label20;
-  GtkWidget *scrolledwindow5;
-  GtkWidget *treeview15;
-  GtkWidget *hbox5;
-  GtkWidget *image5;
-  GtkWidget *label21;
-  GtkWidget *scrolledwindow6;
-  GtkWidget *treeview16;
-  GtkWidget *hbox6;
-  GtkWidget *image6;
-  GtkWidget *label22;
-  GtkWidget *scrolledwindow7;
-  GtkWidget *treeview17;
-  GtkWidget *hbox7;
-  GtkWidget *image7;
-  GtkWidget *label23;
-  GtkWidget *dialog_action_area1;
-  GtkWidget *cancelbutton1;
-  GtkWidget *okbutton1;
-
-  dialog1 = gtk_dialog_new ();
-  gtk_container_set_border_width (GTK_CONTAINER (dialog1), 6);
-  gtk_window_set_title (GTK_WINDOW (dialog1), QT_TR_NOOP("Add Video Filter"));
-  gtk_window_set_type_hint (GTK_WINDOW (dialog1), GDK_WINDOW_TYPE_HINT_DIALOG);
-  gtk_dialog_set_has_separator (GTK_DIALOG (dialog1), FALSE);
-
-  dialog_vbox1 = GTK_DIALOG (dialog1)->vbox;
-  gtk_widget_show (dialog_vbox1);
-
-  notebook1 = gtk_notebook_new ();
-  gtk_widget_show (notebook1);
-  gtk_box_pack_start (GTK_BOX (dialog_vbox1), notebook1, TRUE, TRUE, 0);
-  gtk_container_set_border_width (GTK_CONTAINER (notebook1), 6);
-  gtk_notebook_set_tab_pos (GTK_NOTEBOOK (notebook1), GTK_POS_LEFT);
-
-  scrolledwindow1 = gtk_scrolled_window_new (NULL, NULL);
-  gtk_scrolled_window_set_shadow_type(GTK_SCROLLED_WINDOW(scrolledwindow1), GTK_SHADOW_IN);
-  gtk_widget_show (scrolledwindow1);
-  gtk_container_add (GTK_CONTAINER (notebook1), scrolledwindow1);
-  gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scrolledwindow1), GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);
-
-  treeview11 = gtk_tree_view_new ();
-  gtk_widget_show (treeview11);
-  gtk_container_add (GTK_CONTAINER (scrolledwindow1), treeview11);
-  gtk_tree_view_set_headers_visible (GTK_TREE_VIEW (treeview11), FALSE);
-  gtk_tree_view_set_rules_hint (GTK_TREE_VIEW (treeview11), TRUE);
-  gtk_tree_view_set_enable_search (GTK_TREE_VIEW (treeview11), FALSE);
-
-  hbox1 = gtk_hbox_new (FALSE, 6);
-  gtk_widget_show (hbox1);
-  gtk_notebook_set_tab_label (GTK_NOTEBOOK (notebook1), gtk_notebook_get_nth_page (GTK_NOTEBOOK (notebook1), 0), hbox1);
-
-  image1 = create_pixmap (dialog1, "1.png");
-  gtk_widget_show (image1);
-  gtk_box_pack_start (GTK_BOX (hbox1), image1, FALSE, FALSE, 0);
-
-  label17 = gtk_label_new (QT_TR_NOOP("Transformation"));
-  gtk_widget_show (label17);
-  gtk_box_pack_start (GTK_BOX (hbox1), label17, FALSE, FALSE, 0);
-
-  scrolledwindow2 = gtk_scrolled_window_new (NULL, NULL);
-  gtk_scrolled_window_set_shadow_type(GTK_SCROLLED_WINDOW(scrolledwindow2), GTK_SHADOW_IN);
-  gtk_widget_show (scrolledwindow2);
-  gtk_container_add (GTK_CONTAINER (notebook1), scrolledwindow2);
-  gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scrolledwindow2), GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);
-
-  treeview12 = gtk_tree_view_new ();
-  gtk_widget_show (treeview12);
-  gtk_container_add (GTK_CONTAINER (scrolledwindow2), treeview12);
-  gtk_tree_view_set_headers_visible (GTK_TREE_VIEW (treeview12), FALSE);
-  gtk_tree_view_set_rules_hint (GTK_TREE_VIEW (treeview12), TRUE);
-  gtk_tree_view_set_enable_search (GTK_TREE_VIEW (treeview12), FALSE);
-
-  hbox2 = gtk_hbox_new (FALSE, 6);
-  gtk_widget_show (hbox2);
-  gtk_notebook_set_tab_label (GTK_NOTEBOOK (notebook1), gtk_notebook_get_nth_page (GTK_NOTEBOOK (notebook1), 1), hbox2);
-
-  image2 = create_pixmap (dialog1, "2.png");
-  gtk_widget_show (image2);
-  gtk_box_pack_start (GTK_BOX (hbox2), image2, FALSE, FALSE, 0);
-
-  label18 = gtk_label_new (QT_TR_NOOP("Interlacing"));
-  gtk_widget_show (label18);
-  gtk_box_pack_start (GTK_BOX (hbox2), label18, FALSE, FALSE, 0);
-
-  scrolledwindow3 = gtk_scrolled_window_new (NULL, NULL);
-  gtk_scrolled_window_set_shadow_type(GTK_SCROLLED_WINDOW(scrolledwindow3), GTK_SHADOW_IN);
-  gtk_widget_show (scrolledwindow3);
-  gtk_container_add (GTK_CONTAINER (notebook1), scrolledwindow3);
-  gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scrolledwindow3), GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);
-
-  treeview13 = gtk_tree_view_new ();
-  gtk_widget_show (treeview13);
-  gtk_container_add (GTK_CONTAINER (scrolledwindow3), treeview13);
-  gtk_tree_view_set_headers_visible (GTK_TREE_VIEW (treeview13), FALSE);
-  gtk_tree_view_set_rules_hint (GTK_TREE_VIEW (treeview13), TRUE);
-  gtk_tree_view_set_enable_search (GTK_TREE_VIEW (treeview13), FALSE);
-
-  hbox3 = gtk_hbox_new (FALSE, 6);
-  gtk_widget_show (hbox3);
-  gtk_notebook_set_tab_label (GTK_NOTEBOOK (notebook1), gtk_notebook_get_nth_page (GTK_NOTEBOOK (notebook1), 2), hbox3);
-
-  image3 = create_pixmap (dialog1, "4.png");
-  gtk_widget_show (image3);
-  gtk_box_pack_start (GTK_BOX (hbox3), image3, FALSE, FALSE, 0);
-
-  label19 = gtk_label_new (QT_TR_NOOP("Colors"));
-  gtk_widget_show (label19);
-  gtk_box_pack_start (GTK_BOX (hbox3), label19, FALSE, FALSE, 0);
-
-  scrolledwindow4 = gtk_scrolled_window_new (NULL, NULL);
-  gtk_scrolled_window_set_shadow_type(GTK_SCROLLED_WINDOW(scrolledwindow4), GTK_SHADOW_IN);
-  gtk_widget_show (scrolledwindow4);
-  gtk_container_add (GTK_CONTAINER (notebook1), scrolledwindow4);
-  gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scrolledwindow4), GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);
-
-  treeview14 = gtk_tree_view_new ();
-  gtk_widget_show (treeview14);
-  gtk_container_add (GTK_CONTAINER (scrolledwindow4), treeview14);
-  gtk_tree_view_set_headers_visible (GTK_TREE_VIEW (treeview14), FALSE);
-  gtk_tree_view_set_rules_hint (GTK_TREE_VIEW (treeview14), TRUE);
-  gtk_tree_view_set_enable_search (GTK_TREE_VIEW (treeview14), FALSE);
-
-  hbox4 = gtk_hbox_new (FALSE, 6);
-  gtk_widget_show (hbox4);
-  gtk_notebook_set_tab_label (GTK_NOTEBOOK (notebook1), gtk_notebook_get_nth_page (GTK_NOTEBOOK (notebook1), 3), hbox4);
-
-  image4 = create_pixmap (dialog1, "5.png");
-  gtk_widget_show (image4);
-  gtk_box_pack_start (GTK_BOX (hbox4), image4, FALSE, FALSE, 0);
-
-  label20 = gtk_label_new (QT_TR_NOOP("Denoise"));
-  gtk_widget_show (label20);
-  gtk_box_pack_start (GTK_BOX (hbox4), label20, FALSE, FALSE, 0);
-
-  scrolledwindow5 = gtk_scrolled_window_new (NULL, NULL);
-  gtk_scrolled_window_set_shadow_type(GTK_SCROLLED_WINDOW(scrolledwindow5), GTK_SHADOW_IN);
-  gtk_widget_show (scrolledwindow5);
-  gtk_container_add (GTK_CONTAINER (notebook1), scrolledwindow5);
-  gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scrolledwindow5), GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);
-
-  treeview15 = gtk_tree_view_new ();
-  gtk_widget_show (treeview15);
-  gtk_container_add (GTK_CONTAINER (scrolledwindow5), treeview15);
-  gtk_tree_view_set_headers_visible (GTK_TREE_VIEW (treeview15), FALSE);
-  gtk_tree_view_set_rules_hint (GTK_TREE_VIEW (treeview15), TRUE);
-  gtk_tree_view_set_enable_search (GTK_TREE_VIEW (treeview15), FALSE);
-
-  hbox5 = gtk_hbox_new (FALSE, 6);
-  gtk_widget_show (hbox5);
-  gtk_notebook_set_tab_label (GTK_NOTEBOOK (notebook1), gtk_notebook_get_nth_page (GTK_NOTEBOOK (notebook1), 4), hbox5);
-
-  image5 = create_pixmap (dialog1, "3.png");
-  gtk_widget_show (image5);
-  gtk_box_pack_start (GTK_BOX (hbox5), image5, FALSE, FALSE, 0);
-
-  label21 = gtk_label_new (QT_TR_NOOP("Sharpen/Blur"));
-  gtk_widget_show (label21);
-  gtk_box_pack_start (GTK_BOX (hbox5), label21, FALSE, FALSE, 0);
-
-  scrolledwindow6 = gtk_scrolled_window_new (NULL, NULL);
-  gtk_scrolled_window_set_shadow_type(GTK_SCROLLED_WINDOW(scrolledwindow6), GTK_SHADOW_IN);
-  gtk_widget_show (scrolledwindow6);
-  gtk_container_add (GTK_CONTAINER (notebook1), scrolledwindow6);
-  gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scrolledwindow6), GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);
-
-  treeview16 = gtk_tree_view_new ();
-  gtk_widget_show (treeview16);
-  gtk_container_add (GTK_CONTAINER (scrolledwindow6), treeview16);
-  gtk_tree_view_set_headers_visible (GTK_TREE_VIEW (treeview16), FALSE);
-  gtk_tree_view_set_rules_hint (GTK_TREE_VIEW (treeview16), TRUE);
-  gtk_tree_view_set_enable_search (GTK_TREE_VIEW (treeview16), FALSE);
-
-  hbox6 = gtk_hbox_new (FALSE, 6);
-  gtk_widget_show (hbox6);
-  gtk_notebook_set_tab_label (GTK_NOTEBOOK (notebook1), gtk_notebook_get_nth_page (GTK_NOTEBOOK (notebook1), 5), hbox6);
-
-  image6 = create_pixmap (dialog1, "7.png");
-  gtk_widget_show (image6);
-  gtk_box_pack_start (GTK_BOX (hbox6), image6, FALSE, FALSE, 0);
-
-  label22 = gtk_label_new (QT_TR_NOOP("Subtitles"));
-  gtk_widget_show (label22);
-  gtk_box_pack_start (GTK_BOX (hbox6), label22, FALSE, FALSE, 0);
-
-  scrolledwindow7 = gtk_scrolled_window_new (NULL, NULL);
-  gtk_scrolled_window_set_shadow_type(GTK_SCROLLED_WINDOW(scrolledwindow7), GTK_SHADOW_IN);
-  gtk_widget_show (scrolledwindow7);
-  gtk_container_add (GTK_CONTAINER (notebook1), scrolledwindow7);
-  gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scrolledwindow7), GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);
-
-  treeview17 = gtk_tree_view_new ();
-  gtk_widget_show (treeview17);
-  gtk_container_add (GTK_CONTAINER (scrolledwindow7), treeview17);
-  gtk_tree_view_set_headers_visible (GTK_TREE_VIEW (treeview17), FALSE);
-  gtk_tree_view_set_rules_hint (GTK_TREE_VIEW (treeview17), TRUE);
-  gtk_tree_view_set_enable_search (GTK_TREE_VIEW (treeview17), FALSE);
-
-  hbox7 = gtk_hbox_new (FALSE, 6);
-  gtk_widget_show (hbox7);
-  gtk_notebook_set_tab_label (GTK_NOTEBOOK (notebook1), gtk_notebook_get_nth_page (GTK_NOTEBOOK (notebook1), 6), hbox7);
-
-  image7 = create_pixmap (dialog1, "6.png");
-  gtk_widget_show (image7);
-  gtk_box_pack_start (GTK_BOX (hbox7), image7, FALSE, FALSE, 0);
-
-  label23 = gtk_label_new (QT_TR_NOOP("Miscellaneous"));
-  gtk_widget_show (label23);
-  gtk_box_pack_start (GTK_BOX (hbox7), label23, FALSE, FALSE, 0);
-
-  dialog_action_area1 = GTK_DIALOG (dialog1)->action_area;
-  gtk_widget_show (dialog_action_area1);
-  gtk_button_box_set_layout (GTK_BUTTON_BOX (dialog_action_area1), GTK_BUTTONBOX_END);
-
-  cancelbutton1 = gtk_button_new_from_stock ("gtk-cancel");
-  gtk_widget_show (cancelbutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), cancelbutton1, GTK_RESPONSE_CANCEL);
-  GTK_WIDGET_SET_FLAGS (cancelbutton1, GTK_CAN_DEFAULT);
-
-  okbutton1 = gtk_button_new_from_stock ("gtk-ok");
-  gtk_widget_show (okbutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), okbutton1, GTK_RESPONSE_OK);
-  GTK_WIDGET_SET_FLAGS (okbutton1, GTK_CAN_DEFAULT);
-
-  /* Store pointers to all widgets, for use by lookup_widget(). */
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog1, "dialog1");
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_vbox1, "dialog_vbox1");
-  GLADE_HOOKUP_OBJECT (dialog1, notebook1, "notebook1");
-  GLADE_HOOKUP_OBJECT (dialog1, scrolledwindow1, "scrolledwindow1");
-  GLADE_HOOKUP_OBJECT (dialog1, treeview11, "treeview11");
-  GLADE_HOOKUP_OBJECT (dialog1, hbox1, "hbox1");
-  GLADE_HOOKUP_OBJECT (dialog1, image1, "image1");
-  GLADE_HOOKUP_OBJECT (dialog1, label17, "label17");
-  GLADE_HOOKUP_OBJECT (dialog1, scrolledwindow2, "scrolledwindow2");
-  GLADE_HOOKUP_OBJECT (dialog1, treeview12, "treeview12");
-  GLADE_HOOKUP_OBJECT (dialog1, hbox2, "hbox2");
-  GLADE_HOOKUP_OBJECT (dialog1, image2, "image2");
-  GLADE_HOOKUP_OBJECT (dialog1, label18, "label18");
-  GLADE_HOOKUP_OBJECT (dialog1, scrolledwindow3, "scrolledwindow3");
-  GLADE_HOOKUP_OBJECT (dialog1, treeview13, "treeview13");
-  GLADE_HOOKUP_OBJECT (dialog1, hbox3, "hbox3");
-  GLADE_HOOKUP_OBJECT (dialog1, image3, "image3");
-  GLADE_HOOKUP_OBJECT (dialog1, label19, "label19");
-  GLADE_HOOKUP_OBJECT (dialog1, scrolledwindow4, "scrolledwindow4");
-  GLADE_HOOKUP_OBJECT (dialog1, treeview14, "treeview14");
-  GLADE_HOOKUP_OBJECT (dialog1, hbox4, "hbox4");
-  GLADE_HOOKUP_OBJECT (dialog1, image4, "image4");
-  GLADE_HOOKUP_OBJECT (dialog1, label20, "label20");
-  GLADE_HOOKUP_OBJECT (dialog1, scrolledwindow5, "scrolledwindow5");
-  GLADE_HOOKUP_OBJECT (dialog1, treeview15, "treeview15");
-  GLADE_HOOKUP_OBJECT (dialog1, hbox5, "hbox5");
-  GLADE_HOOKUP_OBJECT (dialog1, image5, "image5");
-  GLADE_HOOKUP_OBJECT (dialog1, label21, "label21");
-  GLADE_HOOKUP_OBJECT (dialog1, scrolledwindow6, "scrolledwindow6");
-  GLADE_HOOKUP_OBJECT (dialog1, treeview16, "treeview16");
-  GLADE_HOOKUP_OBJECT (dialog1, hbox6, "hbox6");
-  GLADE_HOOKUP_OBJECT (dialog1, image6, "image6");
-  GLADE_HOOKUP_OBJECT (dialog1, label22, "label22");
-  GLADE_HOOKUP_OBJECT (dialog1, scrolledwindow7, "scrolledwindow7");
-  GLADE_HOOKUP_OBJECT (dialog1, treeview17, "treeview17");
-  GLADE_HOOKUP_OBJECT (dialog1, hbox7, "hbox7");
-  GLADE_HOOKUP_OBJECT (dialog1, image7, "image7");
-  GLADE_HOOKUP_OBJECT (dialog1, label23, "label23");
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_action_area1, "dialog_action_area1");
-  GLADE_HOOKUP_OBJECT (dialog1, cancelbutton1, "cancelbutton1");
-  GLADE_HOOKUP_OBJECT (dialog1, okbutton1, "okbutton1");
-
-  return dialog1;
-}
-

Modified: branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_filters/gui_filtermanager.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_filters/gui_filtermanager.cpp	2010-01-02 16:30:53 UTC (rev 5815)
+++ branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_filters/gui_filtermanager.cpp	2010-01-02 16:30:57 UTC (rev 5816)
@@ -17,8 +17,10 @@
 #include "ADM_editor/ADM_edit.hxx"
 #include "avi_vars.h"
 #include "GUI_glade.h"
+#include "ADM_filterCategory.h"
+#include "ADM_videoFilterApi.h"
 
-static admGlade glade;
+
 #define WOD(x) glade.getWidget (#x)
 typedef enum
 {
@@ -28,17 +30,75 @@
     actionRemove,
     actionConfigure
 }vFilterAction;
+
+static void displayFamily(uint32_t family);
+#define MAX_NB_TREE VF_MAX
+static  uint32_t max = 0;
+
 /**
+    \class VideoFilterHandler
+*/
+class VideoFilterHandler
+{
+protected:
+  GtkWidget *treesAvailable;
+  GtkListStore *storesAvailable[MAX_NB_TREE];
+  GtkTreeViewColumn *columnsAvailable[MAX_NB_TREE];
+  GtkCellRenderer *renderersAvailable[MAX_NB_TREE];
+  admGlade glade;
+
+  void initFamily(int family);
+  void displayFamily(int family);
+
+  void initActive(void);
+  void displayActive(void);
+
+public:
+        VideoFilterHandler();
+        ~VideoFilterHandler();
+    bool run(void);
+
+};
+/**
     \fn GUI_handleVFilter
 */
 int GUI_handleVFilter (void)
 {
      ADM_info("Entering video filter\n");
+     VideoFilterHandler *handler=new VideoFilterHandler;
+     bool r=handler->run();
+     delete handler;
+     return (int)r;
+}
+/**
+
+*/
+VideoFilterHandler::VideoFilterHandler()
+{
+    treesAvailable=NULL;
+    for(int i=0;i<MAX_NB_TREE;i++)
+    {
+        storesAvailable[i]=NULL;
+        columnsAvailable[i]=NULL;
+        renderersAvailable[i]=NULL;
+    }
+}
+/**
+
+*/
+VideoFilterHandler::~VideoFilterHandler()
+{
+}
+/**
+
+*/
+bool VideoFilterHandler::run(void)
+{
      glade.init();
      if(!glade.loadFile("videoFilter/videoFilter.gtkBuilder"))
      {
             GUI_Error_HIG("Glade","Cannot load glade file");
-            return 0;
+            return false;
     }
     // create top window
     GtkWidget *dialog=glade.getWidget("dialog1");
@@ -53,7 +113,14 @@
 	    
 	   
 	gtk_widget_show(dialog);
-    
+    // fill in families
+    int nbFamily=MAX_NB_TREE;
+    for(int i=0;i<nbFamily;i++)     initFamily(i);
+    displayFamily(0);
+
+    initActive();
+    displayActive();
+
     bool ext=false;
 
     while(false==ext)
@@ -63,21 +130,81 @@
         switch(action)
         {
             case actionAdd:
+                        break;
             case actionUp:
+                        break;
             case actionDown:
+                        break;
             case actionRemove:
+                        break;
             case actionConfigure:
-                    break;
+                        break;
             default:
                 ext=true;
-
+                break;
         }
     };
     gtk_widget_destroy(dialog);
-    return 0;
+    return true;
 }
+/**
+    \fn displayFamily
+*/
+void VideoFilterHandler::displayFamily(int family)
+{
+    treesAvailable=WOD(treeviewAvailable);  
+    ADM_assert(treesAvailable);
+    gtk_tree_view_append_column(GTK_TREE_VIEW (treesAvailable), columnsAvailable[family]);
+    gtk_tree_view_set_model(GTK_TREE_VIEW(treesAvailable),GTK_TREE_MODEL (storesAvailable[family]));
+}
+/**
+    \fn initFamily
+*/
+void VideoFilterHandler::initFamily(int family)
+{
+  
+    storesAvailable[family]=gtk_list_store_new (1, G_TYPE_STRING);
 
+    //load stores with filter names, get start filter for each page
+    char *str=NULL;
+    GtkTreeIter iter;
+    uint32_t nb=ADM_vf_getNbFiltersInCategory((VF_CATEGORY)family);
+    ADM_info("Video filter Family :%u, nb %d\n",family,nb);
+    for (uint32_t i = 0; i < nb; i++)
+    {
+        const char *name,*desc;
+        uint32_t major,minor,patch;
+          ADM_vf_getFilterInfo((VF_CATEGORY)family,i,&name, &desc,&major,&minor,&patch);
+          str = g_strconcat(
+				 "<span weight=\"bold\">",name, "</span>\n",
+                 "<span size=\"smaller\">",desc, "</span>", NULL);
+            gtk_list_store_append (storesAvailable[family], &iter);
+            gtk_list_store_set (storesAvailable[family], &iter, 0, str ,-1);
+            g_free(str);
+     }
+        renderersAvailable[family] = gtk_cell_renderer_text_new();
+   		columnsAvailable[family] = gtk_tree_view_column_new_with_attributes (
+                            "",
+                            renderersAvailable[family],
+                            "markup", (GdkModifierType) 0,
+                            NULL);
+		gtk_cell_renderer_text_set_fixed_height_from_font
+			(GTK_CELL_RENDERER_TEXT(renderersAvailable[family]), 3);
+        g_object_set(renderersAvailable[family], "wrap-width", 0, NULL);
+       
+}
+/**
+*/
+void VideoFilterHandler::initActive(void)
+{
 
+}
+/**
+*/
+void VideoFilterHandler::displayActive(void)
+{
+
+}
 #if 0
 //___________________________________________
 typedef enum 

Deleted: branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_filters/gui_filtermanager_dialog.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_filters/gui_filtermanager_dialog.cpp	2010-01-02 16:30:53 UTC (rev 5815)
+++ branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_filters/gui_filtermanager_dialog.cpp	2010-01-02 16:30:57 UTC (rev 5816)
@@ -1,652 +0,0 @@
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include "ADM_toolkitGtk.h"
-#include "ADM_default.h"
-
-
-
-#define GLADE_HOOKUP_OBJECT(component,widget,name) \
-  g_object_set_data_full (G_OBJECT (component), name, \
-    gtk_widget_ref (widget), (GDestroyNotify) gtk_widget_unref)
-
-#define GLADE_HOOKUP_OBJECT_NO_REF(component,widget,name) \
-  g_object_set_data (G_OBJECT (component), name, widget)
-
-#define GLADE_HOOKUP_OBJECT(component,widget,name) \
-  g_object_set_data_full (G_OBJECT (component), name, \
-    gtk_widget_ref (widget), (GDestroyNotify) gtk_widget_unref)
-
-#define GLADE_HOOKUP_OBJECT_NO_REF(component,widget,name) \
-  g_object_set_data (G_OBJECT (component), name, widget)
-
-GtkWidget*
-create_dialog1 (void)
-{
-  GtkWidget *dialog1;
-  GtkWidget *dialog_vbox1;
-  GtkWidget *vbox3b;
-  GtkWidget *toolbar1;
-  GtkIconSize tmp_toolbar_icon_size;
-  GtkWidget *toolbuttonOpen;
-  GtkWidget *toolbuttonSave;
-  GtkWidget *tmp_image;
-  GtkWidget *toolbuttonScript;
-  GtkWidget *toolbuttonDVD;
-  GtkWidget *toolbuttonHalfD1;
-  GtkWidget *toolbuttonSVCD;
-  GtkWidget *toolbuttonVCD;
-  GtkWidget *hbox11;
-  GtkWidget *frame1;
-  GtkWidget *alignment1;
-  GtkWidget *vbox2;
-  GtkWidget *notebook1;
-  GtkWidget *scrolledwindow1;
-  GtkWidget *treeview1;
-  GtkWidget *hbox5;
-  GtkWidget *image1;
-  GtkWidget *label11;
-  GtkWidget *scrolledwindow2;
-  GtkWidget *treeview2;
-  GtkWidget *hbox6;
-  GtkWidget *image2;
-  GtkWidget *label17;
-  GtkWidget *scrolledwindow3;
-  GtkWidget *treeview3;
-  GtkWidget *hbox7;
-  GtkWidget *image3;
-  GtkWidget *label18;
-  GtkWidget *scrolledwindow4;
-  GtkWidget *treeview4;
-  GtkWidget *hbox8;
-  GtkWidget *image4;
-  GtkWidget *label19;
-  GtkWidget *scrolledwindow5;
-  GtkWidget *treeview5;
-  GtkWidget *hbox9;
-  GtkWidget *image5;
-  GtkWidget *label20;
-  GtkWidget *scrolledwindow6;
-  GtkWidget *treeview6;
-  GtkWidget *hbox10;
-  GtkWidget *image6;
-  GtkWidget *label21;
-  GtkWidget *scrolledwindow7;
-  GtkWidget *treeview7;
-  GtkWidget *hbox4;
-  GtkWidget *image7;
-  GtkWidget *label22;
-  GtkWidget *treeview8;
-  GtkWidget *label28;
-  GtkWidget *hbox13;
-  GtkWidget *buttonAdd;
-  GtkWidget *image11;
-  GtkWidget *label23;
-  GtkWidget *frame2;
-  GtkWidget *alignment2;
-  GtkWidget *hbox1;
-  GtkWidget *vbox3;
-  GtkWidget *scrolledwindow9;
-  GtkWidget *treeview0;
-  GtkWidget *hbox14;
-  GtkWidget *buttonRemove;
-  GtkWidget *image15;
-  GtkWidget *buttonDown;
-  GtkWidget *image14;
-  GtkWidget *buttonUp;
-  GtkWidget *image13;
-  GtkWidget *buttonPartial;
-  GtkWidget *buttonProperties;
-  GtkWidget *alignment4;
-  GtkWidget *hbox16;
-  GtkWidget *label25;
-  GtkWidget *label2;
-  GtkWidget *dialog_action_area1;
-  GtkWidget *buttonPreview;
-  GtkWidget *alignment5;
-  GtkWidget *hbox17;
-  GtkWidget *image17;
-  GtkWidget *label26;
-  GtkWidget *buttonClose;
-  GtkAccelGroup *accel_group;
-  GtkTooltips *tooltips;
-
-  tooltips = gtk_tooltips_new ();
-
-  accel_group = gtk_accel_group_new ();
-
-  dialog1 = gtk_dialog_new ();
-  gtk_container_set_border_width (GTK_CONTAINER (dialog1), 6);
-  gtk_window_set_title (GTK_WINDOW (dialog1), QT_TR_NOOP("Video Filter Manager"));
-  gtk_window_set_type_hint (GTK_WINDOW (dialog1), GDK_WINDOW_TYPE_HINT_DIALOG);
-  gtk_dialog_set_has_separator (GTK_DIALOG (dialog1), FALSE);
-
-  dialog_vbox1 = GTK_DIALOG (dialog1)->vbox;
-  gtk_box_set_spacing (GTK_BOX(dialog_vbox1), 12);
-  gtk_widget_show (dialog_vbox1);
-
-  vbox3b = gtk_vbox_new (FALSE, 12);
-  gtk_widget_show (vbox3b);
-  gtk_box_pack_start (GTK_BOX (dialog_vbox1), vbox3b, TRUE, TRUE, 0);
-  gtk_container_set_border_width (GTK_CONTAINER (vbox3b), 6);
-
-  toolbar1 = gtk_toolbar_new ();
-  gtk_widget_show (toolbar1);
-  gtk_box_pack_start (GTK_BOX (vbox3b), toolbar1, FALSE, FALSE, 0);
-  gtk_toolbar_set_style (GTK_TOOLBAR (toolbar1), GTK_TOOLBAR_BOTH);
-  tmp_toolbar_icon_size = gtk_toolbar_get_icon_size (GTK_TOOLBAR (toolbar1));
-
-  toolbuttonOpen = (GtkWidget*) gtk_tool_button_new_from_stock ("gtk-open");
-  gtk_widget_show (toolbuttonOpen);
-  gtk_container_add (GTK_CONTAINER (toolbar1), toolbuttonOpen);
-  gtk_tool_item_set_tooltip (GTK_TOOL_ITEM (toolbuttonOpen), tooltips, QT_TR_NOOP("Open filter list [Ctrl-O]"), NULL);
-  gtk_widget_add_accelerator (toolbuttonOpen, "clicked", accel_group,
-                              GDK_O, (GdkModifierType) GDK_CONTROL_MASK,
-                              GTK_ACCEL_VISIBLE);
-  gtk_tool_item_set_is_important (GTK_TOOL_ITEM (toolbuttonOpen), TRUE);
-
-  toolbuttonSave = (GtkWidget*) gtk_tool_button_new_from_stock ("gtk-save");
-  gtk_widget_show (toolbuttonSave);
-  gtk_container_add (GTK_CONTAINER (toolbar1), toolbuttonSave);
-  gtk_tool_item_set_tooltip (GTK_TOOL_ITEM (toolbuttonSave), tooltips, QT_TR_NOOP("Save filter list [Ctrl-S]"), NULL);
-  gtk_widget_add_accelerator (toolbuttonSave, "clicked", accel_group,
-                              GDK_S, (GdkModifierType) GDK_CONTROL_MASK,
-                              GTK_ACCEL_VISIBLE);
-  gtk_tool_item_set_is_important (GTK_TOOL_ITEM (toolbuttonSave), TRUE);
-
-  tmp_image = gtk_image_new_from_stock ("gtk-save-as", tmp_toolbar_icon_size);
-  gtk_widget_show (tmp_image);
-  toolbuttonScript = (GtkWidget*) gtk_tool_button_new (tmp_image, QT_TR_NOOP("Save Script"));
-  gtk_widget_show (toolbuttonScript);
-  gtk_container_add (GTK_CONTAINER (toolbar1), toolbuttonScript);
-  gtk_tool_item_set_tooltip (GTK_TOOL_ITEM (toolbuttonScript), tooltips, QT_TR_NOOP("Save as script [Ctrl-J]"), NULL);
-  gtk_widget_add_accelerator (toolbuttonScript, "clicked", accel_group,
-                              GDK_J, (GdkModifierType) GDK_CONTROL_MASK,
-                              GTK_ACCEL_VISIBLE);
-  gtk_tool_item_set_is_important (GTK_TOOL_ITEM (toolbuttonScript), TRUE);
-
-  tmp_image = gtk_image_new_from_stock ("gtk-cdrom", tmp_toolbar_icon_size);
-  gtk_widget_show (tmp_image);
-  toolbuttonDVD = (GtkWidget*) gtk_tool_button_new (tmp_image, QT_TR_NOOP("DVD Res"));
-  gtk_widget_show (toolbuttonDVD);
-  gtk_container_add (GTK_CONTAINER (toolbar1), toolbuttonDVD);
-  gtk_tool_item_set_tooltip (GTK_TOOL_ITEM (toolbuttonDVD), tooltips, QT_TR_NOOP("DVD resolution [Ctrl-1]"), NULL);
-  gtk_widget_add_accelerator (toolbuttonDVD, "clicked", accel_group,
-                              GDK_1, (GdkModifierType) GDK_CONTROL_MASK,
-                              GTK_ACCEL_VISIBLE);
-  gtk_tool_item_set_is_important (GTK_TOOL_ITEM (toolbuttonDVD), TRUE);
-
-  tmp_image = gtk_image_new_from_stock ("gtk-cdrom", tmp_toolbar_icon_size);
-  gtk_widget_show (tmp_image);
-  toolbuttonHalfD1 = (GtkWidget*) gtk_tool_button_new (tmp_image, QT_TR_NOOP("Half D1 Res"));
-  gtk_widget_show (toolbuttonHalfD1);
-  gtk_container_add (GTK_CONTAINER (toolbar1), toolbuttonHalfD1);
-  gtk_tool_item_set_tooltip (GTK_TOOL_ITEM (toolbuttonHalfD1), tooltips, QT_TR_NOOP("Half D1 resolution [Ctrl-2]"), NULL);
-  gtk_widget_add_accelerator (toolbuttonHalfD1, "clicked", accel_group,
-                              GDK_2, (GdkModifierType) GDK_CONTROL_MASK,
-                              GTK_ACCEL_VISIBLE);
-  gtk_tool_item_set_is_important (GTK_TOOL_ITEM (toolbuttonHalfD1), TRUE);
-
-  tmp_image = gtk_image_new_from_stock ("gtk-cdrom", tmp_toolbar_icon_size);
-  gtk_widget_show (tmp_image);
-  toolbuttonSVCD = (GtkWidget*) gtk_tool_button_new (tmp_image, QT_TR_NOOP("SVCD Res"));
-  gtk_widget_show (toolbuttonSVCD);
-  gtk_container_add (GTK_CONTAINER (toolbar1), toolbuttonSVCD);
-  gtk_tool_item_set_tooltip (GTK_TOOL_ITEM (toolbuttonSVCD), tooltips, QT_TR_NOOP("SVCD resolution [Ctrl-3]"), NULL);
-  gtk_widget_add_accelerator (toolbuttonSVCD, "clicked", accel_group,
-                              GDK_3, (GdkModifierType) GDK_CONTROL_MASK,
-                              GTK_ACCEL_VISIBLE);
-  gtk_tool_item_set_is_important (GTK_TOOL_ITEM (toolbuttonSVCD), TRUE);
-
-  tmp_image = gtk_image_new_from_stock ("gtk-cdrom", tmp_toolbar_icon_size);
-  gtk_widget_show (tmp_image);
-  toolbuttonVCD = (GtkWidget*) gtk_tool_button_new (tmp_image, QT_TR_NOOP("VCD Res"));
-  gtk_widget_show (toolbuttonVCD);
-  gtk_container_add (GTK_CONTAINER (toolbar1), toolbuttonVCD);
-  gtk_tool_item_set_tooltip (GTK_TOOL_ITEM (toolbuttonVCD), tooltips, QT_TR_NOOP("VCD resolution [Ctrl-4]"), NULL);
-  gtk_widget_add_accelerator (toolbuttonVCD, "clicked", accel_group,
-                              GDK_4, (GdkModifierType) GDK_CONTROL_MASK,
-                              GTK_ACCEL_VISIBLE);
-  gtk_tool_item_set_is_important (GTK_TOOL_ITEM (toolbuttonVCD), TRUE);
-
-  hbox11 = gtk_hbox_new (FALSE, 12);
-  gtk_widget_show (hbox11);
-  gtk_box_pack_start (GTK_BOX (vbox3b), hbox11, TRUE, TRUE, 0);
-
-  frame1 = gtk_frame_new (NULL);
-  gtk_widget_show (frame1);
-  gtk_box_pack_start (GTK_BOX (hbox11), frame1, TRUE, TRUE, 0);
-  gtk_frame_set_shadow_type (GTK_FRAME (frame1), GTK_SHADOW_NONE);
-
-  alignment1 = gtk_alignment_new (0.5, 0.5, 1, 1);
-  gtk_widget_show (alignment1);
-  gtk_container_add (GTK_CONTAINER (frame1), alignment1);
-  gtk_alignment_set_padding (GTK_ALIGNMENT (alignment1), 6, 0, 18, 0);
-
-  vbox2 = gtk_vbox_new (FALSE, 6);
-  gtk_widget_show (vbox2);
-  gtk_container_add (GTK_CONTAINER (alignment1), vbox2);
-
-  notebook1 = gtk_notebook_new ();
-  gtk_widget_show (notebook1);
-  gtk_box_pack_start (GTK_BOX (vbox2), notebook1, TRUE, TRUE, 0);
-  gtk_notebook_set_show_border (GTK_NOTEBOOK (notebook1), FALSE);
-  gtk_notebook_set_tab_pos (GTK_NOTEBOOK (notebook1), GTK_POS_LEFT);
-
-  scrolledwindow1 = gtk_scrolled_window_new (NULL, NULL);
-  gtk_widget_show (scrolledwindow1);
-  gtk_container_add (GTK_CONTAINER (notebook1), scrolledwindow1);
-  gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scrolledwindow1), GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);
-
-  treeview1 = gtk_tree_view_new ();
-  gtk_widget_show (treeview1);
-  gtk_container_add (GTK_CONTAINER (scrolledwindow1), treeview1);
-  gtk_widget_set_size_request (treeview1, 288, 336);
-  gtk_tree_view_set_headers_visible (GTK_TREE_VIEW (treeview1), FALSE);
-  gtk_tree_view_set_rules_hint (GTK_TREE_VIEW (treeview1), TRUE);
-  gtk_tree_view_set_enable_search (GTK_TREE_VIEW (treeview1), FALSE);
-
-  hbox5 = gtk_hbox_new (FALSE, 0);
-  gtk_widget_show (hbox5);
-  gtk_notebook_set_tab_label (GTK_NOTEBOOK (notebook1), gtk_notebook_get_nth_page (GTK_NOTEBOOK (notebook1), 0), hbox5);
-
-  image1 = create_pixmap (dialog1, "1.png");
-  gtk_widget_show (image1);
-  gtk_box_pack_start (GTK_BOX (hbox5), image1, FALSE, FALSE, 0);
-
-  label11 = gtk_label_new_with_mnemonic (QT_TR_NOOP("Transform"));
-  gtk_widget_show (label11);
-  gtk_box_pack_start (GTK_BOX (hbox5), label11, FALSE, FALSE, 4);
-  gtk_label_set_use_markup (GTK_LABEL (label11), TRUE);
-
-  scrolledwindow2 = gtk_scrolled_window_new (NULL, NULL);
-  gtk_widget_show (scrolledwindow2);
-  gtk_container_add (GTK_CONTAINER (notebook1), scrolledwindow2);
-  gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scrolledwindow2), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
-
-  treeview2 = gtk_tree_view_new ();
-  gtk_widget_show (treeview2);
-  gtk_container_add (GTK_CONTAINER (scrolledwindow2), treeview2);
-  gtk_tree_view_set_headers_visible (GTK_TREE_VIEW (treeview2), FALSE);
-  gtk_tree_view_set_rules_hint (GTK_TREE_VIEW (treeview2), TRUE);
-  gtk_tree_view_set_enable_search (GTK_TREE_VIEW (treeview2), FALSE);
-
-  hbox6 = gtk_hbox_new (FALSE, 0);
-  gtk_widget_show (hbox6);
-  gtk_notebook_set_tab_label (GTK_NOTEBOOK (notebook1), gtk_notebook_get_nth_page (GTK_NOTEBOOK (notebook1), 1), hbox6);
-
-  image2 = create_pixmap (dialog1, "2.png");
-  gtk_widget_show (image2);
-  gtk_box_pack_start (GTK_BOX (hbox6), image2, FALSE, FALSE, 0);
-
-  label17 = gtk_label_new_with_mnemonic (QT_TR_NOOP("Interlacing"));
-  gtk_widget_show (label17);
-  gtk_box_pack_start (GTK_BOX (hbox6), label17, FALSE, FALSE, 4);
-
-  scrolledwindow3 = gtk_scrolled_window_new (NULL, NULL);
-  gtk_widget_show (scrolledwindow3);
-  gtk_container_add (GTK_CONTAINER (notebook1), scrolledwindow3);
-  gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scrolledwindow3), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
-
-  treeview3 = gtk_tree_view_new ();
-  gtk_widget_show (treeview3);
-  gtk_container_add (GTK_CONTAINER (scrolledwindow3), treeview3);
-  gtk_tree_view_set_headers_visible (GTK_TREE_VIEW (treeview3), FALSE);
-  gtk_tree_view_set_rules_hint (GTK_TREE_VIEW (treeview3), TRUE);
-  gtk_tree_view_set_enable_search (GTK_TREE_VIEW (treeview3), FALSE);
-
-  hbox7 = gtk_hbox_new (FALSE, 0);
-  gtk_widget_show (hbox7);
-  gtk_notebook_set_tab_label (GTK_NOTEBOOK (notebook1), gtk_notebook_get_nth_page (GTK_NOTEBOOK (notebook1), 2), hbox7);
-
-  image3 = create_pixmap (dialog1, "4.png");
-  gtk_widget_show (image3);
-  gtk_box_pack_start (GTK_BOX (hbox7), image3, FALSE, FALSE, 0);
-
-  label18 = gtk_label_new_with_mnemonic (QT_TR_NOOP("Colors"));
-  gtk_widget_show (label18);
-  gtk_box_pack_start (GTK_BOX (hbox7), label18, FALSE, FALSE, 4);
-
-  scrolledwindow4 = gtk_scrolled_window_new (NULL, NULL);
-  gtk_widget_show (scrolledwindow4);
-  gtk_container_add (GTK_CONTAINER (notebook1), scrolledwindow4);
-  gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scrolledwindow4), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
-
-  treeview4 = gtk_tree_view_new ();
-  gtk_widget_show (treeview4);
-  gtk_container_add (GTK_CONTAINER (scrolledwindow4), treeview4);
-  gtk_tree_view_set_headers_visible (GTK_TREE_VIEW (treeview4), FALSE);
-  gtk_tree_view_set_rules_hint (GTK_TREE_VIEW (treeview4), TRUE);
-  gtk_tree_view_set_enable_search (GTK_TREE_VIEW (treeview4), FALSE);
-
-  hbox8 = gtk_hbox_new (FALSE, 0);
-  gtk_widget_show (hbox8);
-  gtk_notebook_set_tab_label (GTK_NOTEBOOK (notebook1), gtk_notebook_get_nth_page (GTK_NOTEBOOK (notebook1), 3), hbox8);
-
-  image4 = create_pixmap (dialog1, "5.png");
-  gtk_widget_show (image4);
-  gtk_box_pack_start (GTK_BOX (hbox8), image4, FALSE, FALSE, 0);
-
-  label19 = gtk_label_new_with_mnemonic (QT_TR_NOOP("Noise"));
-  gtk_widget_show (label19);
-  gtk_box_pack_start (GTK_BOX (hbox8), label19, FALSE, FALSE, 4);
-
-  scrolledwindow5 = gtk_scrolled_window_new (NULL, NULL);
-  gtk_widget_show (scrolledwindow5);
-  gtk_container_add (GTK_CONTAINER (notebook1), scrolledwindow5);
-  gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scrolledwindow5), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
-
-  treeview5 = gtk_tree_view_new ();
-  gtk_widget_show (treeview5);
-  gtk_container_add (GTK_CONTAINER (scrolledwindow5), treeview5);
-  gtk_tree_view_set_headers_visible (GTK_TREE_VIEW (treeview5), FALSE);
-  gtk_tree_view_set_rules_hint (GTK_TREE_VIEW (treeview5), TRUE);
-  gtk_tree_view_set_enable_search (GTK_TREE_VIEW (treeview5), FALSE);
-
-  hbox9 = gtk_hbox_new (FALSE, 0);
-  gtk_widget_show (hbox9);
-  gtk_notebook_set_tab_label (GTK_NOTEBOOK (notebook1), gtk_notebook_get_nth_page (GTK_NOTEBOOK (notebook1), 4), hbox9);
-
-  image5 = create_pixmap (dialog1, "3.png");
-  gtk_widget_show (image5);
-  gtk_box_pack_start (GTK_BOX (hbox9), image5, FALSE, FALSE, 0);
-
-  label20 = gtk_label_new_with_mnemonic (QT_TR_NOOP("Sharpness"));
-  gtk_widget_show (label20);
-  gtk_box_pack_start (GTK_BOX (hbox9), label20, FALSE, FALSE, 4);
-
-  scrolledwindow6 = gtk_scrolled_window_new (NULL, NULL);
-  gtk_widget_show (scrolledwindow6);
-  gtk_container_add (GTK_CONTAINER (notebook1), scrolledwindow6);
-  gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scrolledwindow6), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
-
-  treeview6 = gtk_tree_view_new ();
-  gtk_widget_show (treeview6);
-  gtk_container_add (GTK_CONTAINER (scrolledwindow6), treeview6);
-  gtk_tree_view_set_headers_visible (GTK_TREE_VIEW (treeview6), FALSE);
-  gtk_tree_view_set_rules_hint (GTK_TREE_VIEW (treeview6), TRUE);
-  gtk_tree_view_set_enable_search (GTK_TREE_VIEW (treeview6), FALSE);
-
-  hbox10 = gtk_hbox_new (FALSE, 0);
-  gtk_widget_show (hbox10);
-  gtk_notebook_set_tab_label (GTK_NOTEBOOK (notebook1), gtk_notebook_get_nth_page (GTK_NOTEBOOK (notebook1), 5), hbox10);
-
-  image6 = create_pixmap (dialog1, "7.png");
-  gtk_widget_show (image6);
-  gtk_box_pack_start (GTK_BOX (hbox10), image6, FALSE, FALSE, 0);
-
-  label21 = gtk_label_new_with_mnemonic (QT_TR_NOOP("Subtitles"));
-  gtk_widget_show (label21);
-  gtk_box_pack_start (GTK_BOX (hbox10), label21, FALSE, FALSE, 4);
-
-  scrolledwindow7 = gtk_scrolled_window_new (NULL, NULL);
-  gtk_widget_show (scrolledwindow7);
-  gtk_container_add (GTK_CONTAINER (notebook1), scrolledwindow7);
-  gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scrolledwindow7), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
-
-  treeview7 = gtk_tree_view_new ();
-  gtk_widget_show (treeview7);
-  gtk_container_add (GTK_CONTAINER (scrolledwindow7), treeview7);
-  gtk_tree_view_set_headers_visible (GTK_TREE_VIEW (treeview7), FALSE);
-  gtk_tree_view_set_rules_hint (GTK_TREE_VIEW (treeview7), TRUE);
-  gtk_tree_view_set_enable_search (GTK_TREE_VIEW (treeview7), FALSE);
-
-  hbox4 = gtk_hbox_new (FALSE, 0);
-  gtk_widget_show (hbox4);
-  gtk_notebook_set_tab_label (GTK_NOTEBOOK (notebook1), gtk_notebook_get_nth_page (GTK_NOTEBOOK (notebook1), 6), hbox4);
-
-  image7 = create_pixmap (dialog1, "6.png");
-  gtk_widget_show (image7);
-  gtk_box_pack_start (GTK_BOX (hbox4), image7, FALSE, FALSE, 0);
-
-  label22 = gtk_label_new_with_mnemonic (QT_TR_NOOP("Misc"));
-  gtk_widget_show (label22);
-  gtk_box_pack_start (GTK_BOX (hbox4), label22, FALSE, FALSE, 4);
-
-  treeview8 = gtk_tree_view_new ();
-  gtk_widget_show (treeview8);
-  gtk_container_add (GTK_CONTAINER (notebook1), treeview8);
-  gtk_tree_view_set_headers_visible (GTK_TREE_VIEW (treeview8), FALSE);
-  gtk_tree_view_set_rules_hint (GTK_TREE_VIEW (treeview8), TRUE);
-  gtk_tree_view_set_enable_search (GTK_TREE_VIEW (treeview8), FALSE);
-
-  label28 = gtk_label_new (QT_TR_NOOP("External"));
-  gtk_widget_show (label28);
-  gtk_notebook_set_tab_label (GTK_NOTEBOOK (notebook1), gtk_notebook_get_nth_page (GTK_NOTEBOOK (notebook1), 7), label28);
-
-  hbox13 = gtk_hbox_new (FALSE, 6);
-  gtk_widget_show (hbox13);
-  gtk_box_pack_start (GTK_BOX (vbox2), hbox13, FALSE, FALSE, 0);
-
-  buttonAdd = gtk_button_new ();
-  gtk_widget_show (buttonAdd);
-  gtk_box_pack_end (GTK_BOX (hbox13), buttonAdd, FALSE, FALSE, 0);
-  gtk_tooltips_set_tip (tooltips, buttonAdd, QT_TR_NOOP("Add selected filter to the Active Filters list"), NULL);
-
-  image11 = gtk_image_new_from_stock ("gtk-add", GTK_ICON_SIZE_BUTTON);
-  gtk_widget_show (image11);
-  gtk_container_add (GTK_CONTAINER (buttonAdd), image11);
-
-  label23 = gtk_label_new (QT_TR_NOOP("<b>Available Filters</b>"));
-  gtk_widget_show (label23);
-  gtk_frame_set_label_widget (GTK_FRAME (frame1), label23);
-  gtk_label_set_use_markup (GTK_LABEL (label23), TRUE);
-  gtk_misc_set_alignment (GTK_MISC (label23), 1, 1);
-
-  frame2 = gtk_frame_new (NULL);
-  gtk_widget_show (frame2);
-  gtk_box_pack_start (GTK_BOX (hbox11), frame2, TRUE, TRUE, 0);
-  gtk_frame_set_shadow_type (GTK_FRAME (frame2), GTK_SHADOW_NONE);
-
-  alignment2 = gtk_alignment_new (0.5, 0.5, 1, 1);
-  gtk_widget_show (alignment2);
-  gtk_container_add (GTK_CONTAINER (frame2), alignment2);
-  gtk_alignment_set_padding (GTK_ALIGNMENT (alignment2), 6, 0, 18, 0);
-
-  hbox1 = gtk_hbox_new (FALSE, 0);
-  gtk_widget_show (hbox1);
-  gtk_container_add (GTK_CONTAINER (alignment2), hbox1);
-
-  vbox3 = gtk_vbox_new (FALSE, 6);
-  gtk_widget_show (vbox3);
-  gtk_box_pack_start (GTK_BOX (hbox1), vbox3, TRUE, TRUE, 0);
-
-  scrolledwindow9 = gtk_scrolled_window_new (NULL, NULL);
-  gtk_widget_show (scrolledwindow9);
-  gtk_box_pack_start (GTK_BOX (vbox3), scrolledwindow9, TRUE, TRUE, 0);
-  gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scrolledwindow9), GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);
-  gtk_scrolled_window_set_shadow_type (GTK_SCROLLED_WINDOW (scrolledwindow9), GTK_SHADOW_OUT);
-
-  treeview0 = gtk_tree_view_new ();
-  gtk_widget_show (treeview0);
-  gtk_container_add (GTK_CONTAINER (scrolledwindow9), treeview0);
-  gtk_widget_set_size_request (treeview0, 288, 336);
-  gtk_tree_view_set_headers_visible (GTK_TREE_VIEW (treeview0), FALSE);
-  gtk_tree_view_set_rules_hint (GTK_TREE_VIEW (treeview0), TRUE);
-  gtk_tree_view_set_enable_search (GTK_TREE_VIEW (treeview0), FALSE);
-
-  hbox14 = gtk_hbox_new (FALSE, 6);
-  gtk_widget_show (hbox14);
-  gtk_box_pack_start (GTK_BOX (vbox3), hbox14, FALSE, FALSE, 0);
-
-  buttonRemove = gtk_button_new ();
-  gtk_widget_show (buttonRemove);
-  gtk_box_pack_end (GTK_BOX (hbox14), buttonRemove, FALSE, FALSE, 0);
-  gtk_tooltips_set_tip (tooltips, buttonRemove, QT_TR_NOOP("Remove filter"), NULL);
-
-  image15 = gtk_image_new_from_stock ("gtk-remove", GTK_ICON_SIZE_BUTTON);
-  gtk_widget_show (image15);
-  gtk_container_add (GTK_CONTAINER (buttonRemove), image15);
-
-  buttonDown = gtk_button_new ();
-  gtk_widget_show (buttonDown);
-  gtk_box_pack_end (GTK_BOX (hbox14), buttonDown, FALSE, FALSE, 0);
-  gtk_tooltips_set_tip (tooltips, buttonDown, QT_TR_NOOP("Move filter down"), NULL);
-
-  image14 = gtk_image_new_from_icon_name ("gtk-go-down", GTK_ICON_SIZE_BUTTON);
-  gtk_widget_show (image14);
-  gtk_container_add (GTK_CONTAINER (buttonDown), image14);
-
-  buttonUp = gtk_button_new ();
-  gtk_widget_show (buttonUp);
-  gtk_box_pack_end (GTK_BOX (hbox14), buttonUp, FALSE, FALSE, 0);
-  gtk_tooltips_set_tip (tooltips, buttonUp, QT_TR_NOOP("Move filter up"), NULL);
-
-  image13 = gtk_image_new_from_icon_name ("gtk-go-up", GTK_ICON_SIZE_BUTTON);
-  gtk_widget_show (image13);
-  gtk_container_add (GTK_CONTAINER (buttonUp), image13);
-
-  buttonPartial = gtk_button_new_with_mnemonic (QT_TR_NOOP("P_artial"));
-  gtk_widget_show (buttonPartial);
-  gtk_box_pack_end (GTK_BOX (hbox14), buttonPartial, FALSE, FALSE, 0);
-  gtk_tooltips_set_tip (tooltips, buttonPartial, QT_TR_NOOP("Apply the current filter only to a part of the file"), NULL);
-
-  buttonProperties = gtk_button_new ();
-  gtk_widget_show (buttonProperties);
-  gtk_box_pack_end (GTK_BOX (hbox14), buttonProperties, FALSE, FALSE, 0);
-  gtk_tooltips_set_tip (tooltips, buttonProperties, QT_TR_NOOP("Configure filter"), NULL);
-
-  alignment4 = gtk_alignment_new (0.5, 0.5, 0, 0);
-  gtk_widget_show (alignment4);
-  gtk_container_add (GTK_CONTAINER (buttonProperties), alignment4);
-
-  hbox16 = gtk_hbox_new (FALSE, 2);
-  gtk_widget_show (hbox16);
-  gtk_container_add (GTK_CONTAINER (alignment4), hbox16);
-
-  label25 = gtk_label_new_with_mnemonic (QT_TR_NOOP("C_onfigure"));
-  gtk_widget_show (label25);
-  gtk_box_pack_start (GTK_BOX (hbox16), label25, FALSE, FALSE, 0);
-
-  label2 = gtk_label_new (QT_TR_NOOP("<b >Active Filters</b>"));
-  gtk_widget_show (label2);
-  gtk_frame_set_label_widget (GTK_FRAME (frame2), label2);
-  gtk_label_set_use_markup (GTK_LABEL (label2), TRUE);
-  gtk_misc_set_alignment (GTK_MISC (label2), 1, 1);
-
-  dialog_action_area1 = GTK_DIALOG (dialog1)->action_area;
-  gtk_widget_show (dialog_action_area1);
-  gtk_button_box_set_layout (GTK_BUTTON_BOX (dialog_action_area1), GTK_BUTTONBOX_END);
-
-  buttonPreview = gtk_button_new ();
-  gtk_widget_show (buttonPreview);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), buttonPreview, GTK_RESPONSE_APPLY);
-  GTK_WIDGET_SET_FLAGS (buttonPreview, GTK_CAN_DEFAULT);
-
-  alignment5 = gtk_alignment_new (0.5, 0.5, 0, 0);
-  gtk_widget_show (alignment5);
-  gtk_container_add (GTK_CONTAINER (buttonPreview), alignment5);
-
-  hbox17 = gtk_hbox_new (FALSE, 2);
-  gtk_widget_show (hbox17);
-  gtk_container_add (GTK_CONTAINER (alignment5), hbox17);
-
-  image17 = create_pixmap (dialog1, "preview-button.png");
-  gtk_widget_show (image17);
-  gtk_box_pack_start (GTK_BOX (hbox17), image17, FALSE, FALSE, 0);
-
-  label26 = gtk_label_new_with_mnemonic (QT_TR_NOOP("_Preview"));
-  gtk_widget_show (label26);
-  gtk_box_pack_start (GTK_BOX (hbox17), label26, FALSE, FALSE, 0);
-
-  buttonClose = gtk_button_new_from_stock ("gtk-close");
-  gtk_widget_show (buttonClose);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), buttonClose, GTK_RESPONSE_CLOSE);
-  GTK_WIDGET_SET_FLAGS (buttonClose, GTK_CAN_DEFAULT);
-
-  /* Store pointers to all widgets, for use by lookup_widget(). */
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog1, "dialog1");
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_vbox1, "dialog_vbox1");
-  GLADE_HOOKUP_OBJECT (dialog1, vbox3b, "vbox3b");
-  GLADE_HOOKUP_OBJECT (dialog1, toolbar1, "toolbar1");
-  GLADE_HOOKUP_OBJECT (dialog1, toolbuttonOpen, "toolbuttonOpen");
-  GLADE_HOOKUP_OBJECT (dialog1, toolbuttonSave, "toolbuttonSave");
-  GLADE_HOOKUP_OBJECT (dialog1, toolbuttonScript, "toolbuttonScript");
-  GLADE_HOOKUP_OBJECT (dialog1, toolbuttonDVD, "toolbuttonDVD");
-  GLADE_HOOKUP_OBJECT (dialog1, toolbuttonHalfD1, "toolbuttonHalfD1");
-  GLADE_HOOKUP_OBJECT (dialog1, toolbuttonSVCD, "toolbuttonSVCD");
-  GLADE_HOOKUP_OBJECT (dialog1, toolbuttonVCD, "toolbuttonVCD");
-  GLADE_HOOKUP_OBJECT (dialog1, hbox11, "hbox11");
-  GLADE_HOOKUP_OBJECT (dialog1, frame1, "frame1");
-  GLADE_HOOKUP_OBJECT (dialog1, alignment1, "alignment1");
-  GLADE_HOOKUP_OBJECT (dialog1, vbox2, "vbox2");
-  GLADE_HOOKUP_OBJECT (dialog1, notebook1, "notebook1");
-  GLADE_HOOKUP_OBJECT (dialog1, scrolledwindow1, "scrolledwindow1");
-  GLADE_HOOKUP_OBJECT (dialog1, treeview1, "treeview1");
-  GLADE_HOOKUP_OBJECT (dialog1, hbox5, "hbox5");
-  GLADE_HOOKUP_OBJECT (dialog1, image1, "image1");
-  GLADE_HOOKUP_OBJECT (dialog1, label11, "label11");
-  GLADE_HOOKUP_OBJECT (dialog1, scrolledwindow2, "scrolledwindow2");
-  GLADE_HOOKUP_OBJECT (dialog1, treeview2, "treeview2");
-  GLADE_HOOKUP_OBJECT (dialog1, hbox6, "hbox6");
-  GLADE_HOOKUP_OBJECT (dialog1, image2, "image2");
-  GLADE_HOOKUP_OBJECT (dialog1, label17, "label17");
-  GLADE_HOOKUP_OBJECT (dialog1, scrolledwindow3, "scrolledwindow3");
-  GLADE_HOOKUP_OBJECT (dialog1, treeview3, "treeview3");
-  GLADE_HOOKUP_OBJECT (dialog1, hbox7, "hbox7");
-  GLADE_HOOKUP_OBJECT (dialog1, image3, "image3");
-  GLADE_HOOKUP_OBJECT (dialog1, label18, "label18");
-  GLADE_HOOKUP_OBJECT (dialog1, scrolledwindow4, "scrolledwindow4");
-  GLADE_HOOKUP_OBJECT (dialog1, treeview4, "treeview4");
-  GLADE_HOOKUP_OBJECT (dialog1, hbox8, "hbox8");
-  GLADE_HOOKUP_OBJECT (dialog1, image4, "image4");
-  GLADE_HOOKUP_OBJECT (dialog1, label19, "label19");
-  GLADE_HOOKUP_OBJECT (dialog1, scrolledwindow5, "scrolledwindow5");
-  GLADE_HOOKUP_OBJECT (dialog1, treeview5, "treeview5");
-  GLADE_HOOKUP_OBJECT (dialog1, hbox9, "hbox9");
-  GLADE_HOOKUP_OBJECT (dialog1, image5, "image5");
-  GLADE_HOOKUP_OBJECT (dialog1, label20, "label20");
-  GLADE_HOOKUP_OBJECT (dialog1, scrolledwindow6, "scrolledwindow6");
-  GLADE_HOOKUP_OBJECT (dialog1, treeview6, "treeview6");
-  GLADE_HOOKUP_OBJECT (dialog1, hbox10, "hbox10");
-  GLADE_HOOKUP_OBJECT (dialog1, image6, "image6");
-  GLADE_HOOKUP_OBJECT (dialog1, label21, "label21");
-  GLADE_HOOKUP_OBJECT (dialog1, scrolledwindow7, "scrolledwindow7");
-  GLADE_HOOKUP_OBJECT (dialog1, treeview7, "treeview7");
-  GLADE_HOOKUP_OBJECT (dialog1, hbox4, "hbox4");
-  GLADE_HOOKUP_OBJECT (dialog1, image7, "image7");
-  GLADE_HOOKUP_OBJECT (dialog1, label22, "label22");
-  GLADE_HOOKUP_OBJECT (dialog1, treeview8, "treeview8");
-  GLADE_HOOKUP_OBJECT (dialog1, label28, "label28");
-  GLADE_HOOKUP_OBJECT (dialog1, hbox13, "hbox13");
-  GLADE_HOOKUP_OBJECT (dialog1, buttonAdd, "buttonAdd");
-  GLADE_HOOKUP_OBJECT (dialog1, image11, "image11");
-  GLADE_HOOKUP_OBJECT (dialog1, label23, "label23");
-  GLADE_HOOKUP_OBJECT (dialog1, frame2, "frame2");
-  GLADE_HOOKUP_OBJECT (dialog1, alignment2, "alignment2");
-  GLADE_HOOKUP_OBJECT (dialog1, hbox1, "hbox1");
-  GLADE_HOOKUP_OBJECT (dialog1, vbox3, "vbox3");
-  GLADE_HOOKUP_OBJECT (dialog1, scrolledwindow9, "scrolledwindow9");
-  GLADE_HOOKUP_OBJECT (dialog1, treeview0, "treeview0");
-  GLADE_HOOKUP_OBJECT (dialog1, hbox14, "hbox14");
-  GLADE_HOOKUP_OBJECT (dialog1, buttonRemove, "buttonRemove");
-  GLADE_HOOKUP_OBJECT (dialog1, image15, "image15");
-  GLADE_HOOKUP_OBJECT (dialog1, buttonDown, "buttonDown");
-  GLADE_HOOKUP_OBJECT (dialog1, image14, "image14");
-  GLADE_HOOKUP_OBJECT (dialog1, buttonUp, "buttonUp");
-  GLADE_HOOKUP_OBJECT (dialog1, image13, "image13");
-  GLADE_HOOKUP_OBJECT (dialog1, buttonPartial, "buttonPartial");
-  GLADE_HOOKUP_OBJECT (dialog1, buttonProperties, "buttonProperties");
-  GLADE_HOOKUP_OBJECT (dialog1, alignment4, "alignment4");
-  GLADE_HOOKUP_OBJECT (dialog1, hbox16, "hbox16");
-  GLADE_HOOKUP_OBJECT (dialog1, label25, "label25");
-  GLADE_HOOKUP_OBJECT (dialog1, label2, "label2");
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_action_area1, "dialog_action_area1");
-  GLADE_HOOKUP_OBJECT (dialog1, buttonPreview, "buttonPreview");
-  GLADE_HOOKUP_OBJECT (dialog1, alignment5, "alignment5");
-  GLADE_HOOKUP_OBJECT (dialog1, hbox17, "hbox17");
-  GLADE_HOOKUP_OBJECT (dialog1, image17, "image17");
-  GLADE_HOOKUP_OBJECT (dialog1, label26, "label26");
-  GLADE_HOOKUP_OBJECT (dialog1, buttonClose, "buttonClose");
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, tooltips, "tooltips");
-
-  gtk_window_add_accel_group (GTK_WINDOW (dialog1), accel_group);
-
-  return dialog1;
-}
-



From gruntster at mail.berlios.de  Sun Jan  3 18:15:56 2010
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Sun, 3 Jan 2010 18:15:56 +0100
Subject: [Avidemux-svn-commit] r5817 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_editor
Message-ID: <201001031715.o03HFu0g030467@sheep.berlios.de>

Author: gruntster
Date: 2010-01-03 18:15:52 +0100 (Sun, 03 Jan 2010)
New Revision: 5817

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_editor/ADM_edLoadSave.cpp
Log:
[js] fix output when there are no muxer settings

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_editor/ADM_edLoadSave.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_editor/ADM_edLoadSave.cpp	2010-01-02 16:30:57 UTC (rev 5816)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_editor/ADM_edLoadSave.cpp	2010-01-03 17:15:52 UTC (rev 5817)
@@ -284,9 +284,10 @@
 
 			  for (int j = 0; j < ADM_allOutputFormat[i].configSize; j++)
 				  qfprintf(fd, "%02x ", config[j]);
+
+			  qfprintf(fd,"\"");
 		  }
 
-		  qfprintf(fd,"\"");
 		  break;
 	  }
   }



From gruntster at mail.berlios.de  Sun Jan  3 20:45:28 2010
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Sun, 3 Jan 2010 20:45:28 +0100
Subject: [Avidemux-svn-commit] r5818 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_mpegFF
Message-ID: <201001031945.o03JjSCf025370@sheep.berlios.de>

Author: gruntster
Date: 2010-01-03 20:45:24 +0100 (Sun, 03 Jan 2010)
New Revision: 5818

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_mpegFF/oplug_vcdff.cpp
Log:
[mpeg-ps] fix regression in mpeg-ps muxer preventing mpeg2enc SVCD and DVD from working

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_mpegFF/oplug_vcdff.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_mpegFF/oplug_vcdff.cpp	2010-01-03 17:15:52 UTC (rev 5817)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_mpegFF/oplug_vcdff.cpp	2010-01-03 19:45:24 UTC (rev 5818)
@@ -136,48 +136,43 @@
                 WAVHeader *hdr=audio->getInfo();	
                 audio_encoding=hdr->encoding;
 
-                if (videoCodecGetType() == CodecVCD ||
-					(videoCodecGetType() == CodecExternal && strcmp(videoCodecPluginGetGuid(), "85FC9CAC-CE6C-4aa6-9D5F-352D6349BA3E") == 0) || // avcodec MPEG-1 plugin
-					(videoCodecGetType() == CodecExternal && strcmp(videoCodecPluginGetGuid(), "DBAECD8B-CF29-4846-AF57-B596427FE7D3") == 0)) // avcodec MPEG-2 plugin
+				switch (psMuxerConfig.muxingType)
 				{
-					switch (psMuxerConfig.muxingType)
+					case PS_MUXER_VCD:
 					{
-						case PS_MUXER_VCD:
+						if (!psMuxerConfig.acceptNonCompliant && (hdr->frequency != 44100 || hdr->encoding != WAV_MP2))
 						{
-							if (!psMuxerConfig.acceptNonCompliant && (hdr->frequency != 44100 || hdr->encoding != WAV_MP2))
-							{
-								GUI_Error_HIG(("Incompatible audio"),QT_TR_NOOP( "For VCD, audio must be 44.1 kHz MP2."));
-								goto finishvcdff;
-							}
-
-							mux = MUXER_VCD;
-							printf("X*CD: Using VCD PS\n");
-							break;
+							GUI_Error_HIG(("Incompatible audio"),QT_TR_NOOP( "For VCD, audio must be 44.1 kHz MP2."));
+							goto finishvcdff;
 						}
-						case PS_MUXER_SVCD:
-						{
-							if (!psMuxerConfig.acceptNonCompliant && (hdr->frequency != 44100 && hdr->encoding == WAV_MP2))
-							{
-								GUI_Error_HIG(("Incompatible audio"),QT_TR_NOOP( "For SVCD, audio must be 44.1 kHz MP2."));
-								goto finishvcdff;
-							}
 
-							mux = MUXER_SVCD;
-							printf("X*VCD: Using SVCD PS\n");
-							break;
-						}
-						case PS_MUXER_DVD:
+						mux = MUXER_VCD;
+						printf("X*CD: Using VCD PS\n");
+						break;
+					}
+					case PS_MUXER_SVCD:
+					{
+						if (!psMuxerConfig.acceptNonCompliant && (hdr->frequency != 44100 && hdr->encoding == WAV_MP2))
 						{
-							if (!psMuxerConfig.acceptNonCompliant && (hdr->frequency != 48000 || (hdr->encoding != WAV_MP2 && hdr->encoding != WAV_AC3 && hdr->encoding != WAV_LPCM)))
-							{
-								GUI_Error_HIG(("Incompatible audio"), QT_TR_NOOP("For DVD, audio must be 48 kHz MP2, AC3 or LPCM."));
-								goto finishvcdff;								
-							}
+							GUI_Error_HIG(("Incompatible audio"),QT_TR_NOOP( "For SVCD, audio must be 44.1 kHz MP2."));
+							goto finishvcdff;
+						}
 
-							mux = MUXER_DVD;
-							printf("X*VCD: Using DVD PS\n");
-							break;
+						mux = MUXER_SVCD;
+						printf("X*VCD: Using SVCD PS\n");
+						break;
+					}
+					case PS_MUXER_DVD:
+					{
+						if (!psMuxerConfig.acceptNonCompliant && (hdr->frequency != 48000 || (hdr->encoding != WAV_MP2 && hdr->encoding != WAV_AC3 && hdr->encoding != WAV_LPCM)))
+						{
+							GUI_Error_HIG(("Incompatible audio"), QT_TR_NOOP("For DVD, audio must be 48 kHz MP2, AC3 or LPCM."));
+							goto finishvcdff;								
 						}
+
+						mux = MUXER_DVD;
+						printf("X*VCD: Using DVD PS\n");
+						break;
 					}
 				}
             }



From mean at mail.berlios.de  Tue Jan  5 07:19:21 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 5 Jan 2010 07:19:21 +0100
Subject: [Avidemux-svn-commit] r5819 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska
Message-ID: <201001050619.o056JLfn019032@sheep.berlios.de>

Author: mean
Date: 2010-01-05 07:19:19 +0100 (Tue, 05 Jan 2010)
New Revision: 5819

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.h
Log:
[mkv] Improved DTS derivation. We need a ~ correct DTS to properly mux the stream afterward in copy mode. But mkv only provides PTS. So we try to put a non-stupid dts that respects DTS<PTS for all frames, but DTS does not go too far away so that it an be demuxed. It is still not perfect

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.cpp	2010-01-03 19:45:24 UTC (rev 5818)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.cpp	2010-01-05 06:19:19 UTC (rev 5819)
@@ -87,21 +87,51 @@
   ADM_assert(_parser->open(name));
   _filename=ADM_strdup(name);
 
-  // Finaly update index with queue
-  float duration=_videostream.dwLength*_tracks[0]._defaultFrameDuration;
-  duration/=1000;
-  uint32_t duration32=(uint32_t)duration;
-  printf("[MKV] Video Track duration %u ms\n",_videostream.dwLength);
-  // Useless.....readCue(&ebml);
-  for(int i=0;i<_nbAudioTrack;i++)
+  // Delay frames + recompute frame duration
+// now that we have a good frameduration and max pts dts difference, we can set a proper DTS for all video frame
+  uint64_t ptsdtsdelta=delayFrameIfBFrames();
+  
+  int last=_tracks[0].index.size();
+  uint64_t increment=_tracks[0]._defaultFrameDuration;
+  uint64_t lastDts=0;
+  _tracks[0].index[0].Dts=0;
+  mkvTrak                 *vid=_tracks;
+  for(int i=1;i<last;i++)
   {
-    rescaleTrack(&(_tracks[1+i]),duration32);
-    if(_tracks[1+i].wavHeader.encoding==WAV_OGG_VORBIS)
-    {
-        printf("[MKV] Reformatting vorbis header for track %u\n",i);
-        reformatVorbisHeader(&(_tracks[1+i]));
+        uint64_t pts,dts;
+        pts=vid->index[i].Pts;
+        lastDts+=increment; // This frame dts with no correction
+        if(pts=ADM_NO_PTS)
+        {
+            vid->index[i].Dts=lastDts;
+            continue;
+        }
+        uint64_t limitDts=vid->index[i].Pts-ptsdtsdelta;
+        if(  lastDts<limitDts)
+        {
+            lastDts=limitDts;
+        }
+        vid->index[i].Dts=lastDts;
+  }
+
+
+  if(last)
+  {
+          float duration=_tracks[0].index[last-1].Pts;
+          duration/=1000;
+          uint32_t duration32=(uint32_t)duration;
+          printf("[MKV] Video Track duration for %u ms\n",duration32);
+          // Useless.....readCue(&ebml);
+          for(int i=0;i<_nbAudioTrack;i++)
+          {
+            rescaleTrack(&(_tracks[1+i]),duration32);
+            if(_tracks[1+i].wavHeader.encoding==WAV_OGG_VORBIS)
+            {
+                printf("[MKV] Reformatting vorbis header for track %u\n",i);
+                reformatVorbisHeader(&(_tracks[1+i]));
+            }
+          }
     }
-  }
     _access=new mkvAccess *[_nbAudioTrack];
     _audioStreams=new ADM_audioStream *[_nbAudioTrack];
     for(int i=0;i<_nbAudioTrack;i++)
@@ -109,7 +139,7 @@
         _access[i]=new mkvAccess(_filename,&(_tracks[i+1]));
         _audioStreams[i]=ADM_audioCreateStream(&(_tracks[1+i].wavHeader), _access[i]);;
     }
-  delayFrameIfBFrames();
+  
   printf("[MKV]Matroska successfully read\n");
 
   return 1;
@@ -128,22 +158,71 @@
     }
     return true;
 }
-bool mkvHeader::delayFrameIfBFrames(void)
+/**
+    \fn delayFrameIfBFrames
+    \brief recompute max pts/dts distance and delay all tracks if needed
+    we dont want a negative dts.
+    \return maxdelta in us
+*/
+uint32_t mkvHeader::delayFrameIfBFrames(void)
 {
     mkvTrak *track=_tracks;
     int nb=track->index.size();
     int nbBFrame=0;
-    for(int i=0;i<nb;i++) if(track->index[i].flags==AVI_B_FRAME) nbBFrame++;
-    if(nbBFrame<2)
+    int64_t delta,maxDelta=0;
+    int64_t minDelta=100000000;
+    if(nb>1)
     {
-        printf("[Mkv] no b frames detected\n");
-        return true;
+        // Search minimum and maximum between 2 frames
+        // the minimum will give us the maximum fps
+        // the maximum will give us the max PTS-DTS delta so that we can compute DTS
+        for(int i=0;i<nb-1;i++) 
+        {
+            if(track->index[i].flags==AVI_B_FRAME) nbBFrame++;
+            delta=(int64_t)track->index[i+1].Pts-(int64_t)track->index[i].Pts;
+            if(delta<0) delta=-delta;
+            if(delta<minDelta) minDelta=delta;
+            if(delta>maxDelta) maxDelta=delta;
+            //printf("\/=%"LLD" Min %"LLD" MAX %"LLD"\n",delta,minDelta,maxDelta);
+        }
     }
-    uint64_t twoFrames=track->_defaultFrameDuration*2;
-    printf("[mkv] Delaying PTS by %"LLU" us\n",twoFrames);
-    for(int i=0;i<_nbAudioTrack+1;i++)
-        delayTrack(&(_tracks[i]),twoFrames);
-    return true;
+    ADM_info("Minimum delta found %"LLD" us\n",minDelta);
+    ADM_info("Maximum delta found %"LLD" us\n",maxDelta);
+    if(minDelta)
+    {
+        if(minDelta<track->_defaultFrameDuration && abs(minDelta-track->_defaultFrameDuration)>1000)
+        {
+            ADM_info("Changing default frame duration from %"LLU" to %"LLU" us\n",
+                    track->_defaultFrameDuration,minDelta);
+            track->_defaultFrameDuration=minDelta;
+            // updated fps also
+            float f=minDelta;
+            f=1000000./f;
+            _videostream.dwScale=1000;
+            _videostream.dwRate=(uint32_t)(f*1000.);
+        }else
+        {
+            ADM_info("Keeping default frame duration  %"LLU" us\n", track->_defaultFrameDuration);
+        }
+
+    }
+    ADM_info("First frame pts     %"LLD" us\n",track->index[0].Pts);
+    uint64_t adj;
+    if(maxDelta>track->index[0].Pts) // need to correct
+    {
+        
+        adj=maxDelta-track->index[0].Pts;
+        ADM_info("Delaying video by %"LLU" us\n",adj);
+        
+        for(int i=0;i<nb;i++)
+                track->index[i].Pts+=adj;
+    
+    
+        printf("[mkv] Delaying audio by %"LLU" us\n",adj);
+        for(int i=0;i<_nbAudioTrack+1;i++)
+            delayTrack(&(_tracks[i]),adj);
+    }
+    return (uint32_t)maxDelta;
 }
 /**
     \fn rescaleTrack

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.h	2010-01-03 19:45:24 UTC (rev 5818)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.h	2010-01-05 06:19:19 UTC (rev 5819)
@@ -146,7 +146,7 @@
     uint8_t                 rescaleTrack(mkvTrak *track,uint32_t durationMs);
 
     bool                    delayTrack(mkvTrak *track, uint64_t value);
-    bool                    delayFrameIfBFrames(void);
+    uint32_t                delayFrameIfBFrames(void);
 
   public:
 



From mean at mail.berlios.de  Tue Jan  5 07:19:28 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 5 Jan 2010 07:19:28 +0100
Subject: [Avidemux-svn-commit] r5820 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska
Message-ID: <201001050619.o056JSH4019301@sheep.berlios.de>

Author: mean
Date: 2010-01-05 07:19:27 +0100 (Tue, 05 Jan 2010)
New Revision: 5820

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv_audio.cpp
Log:
[MkV] Handle the case where we want to seek prior the first audio block

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv_audio.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv_audio.cpp	2010-01-05 06:19:19 UTC (rev 5819)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv_audio.cpp	2010-01-05 06:19:27 UTC (rev 5820)
@@ -111,7 +111,7 @@
   uint32_t limit=_track->index.size();
   if(x>=limit)
   {
-    printf("Exceeding max cluster : asked: %u max :%u\n",x,limit);
+    ADM_warning("Exceeding max cluster : asked: %u max :%u\n",x,limit);
     return 0;  // FIXME
   }
 
@@ -131,6 +131,10 @@
     mkvListOfIndex *dex=&(_track->index);
       // First identify the cluster...
       int clus=-1;
+            if(timeUs<(*dex)[0].Dts)
+            {
+                clus=0;
+            }else
             for(int i=0;i<limit-1;i++)
             {
               if(targetUs>=(*dex)[i].Dts && targetUs<(*dex)[i+1].Dts)



From mean at mail.berlios.de  Tue Jan  5 07:19:31 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 5 Jan 2010 07:19:31 +0100
Subject: [Avidemux-svn-commit] r5821 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska
Message-ID: <201001050619.o056JVPs019421@sheep.berlios.de>

Author: mean
Date: 2010-01-05 07:19:30 +0100 (Tue, 05 Jan 2010)
New Revision: 5821

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.cpp
Log:
[mkv] Dump the size of all tracks"s index

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.cpp	2010-01-05 06:19:27 UTC (rev 5820)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.cpp	2010-01-05 06:19:30 UTC (rev 5821)
@@ -87,6 +87,11 @@
   ADM_assert(_parser->open(name));
   _filename=ADM_strdup(name);
 
+  // Now dump some infos about the track
+    for(int i=0;i<1+_nbAudioTrack;i++)
+        ADM_info("Track %"LU" has an index size of %d entries\n",i,_tracks[i].index.size());
+
+
   // Delay frames + recompute frame duration
 // now that we have a good frameduration and max pts dts difference, we can set a proper DTS for all video frame
   uint64_t ptsdtsdelta=delayFrameIfBFrames();



From mean at mail.berlios.de  Tue Jan  5 07:19:35 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 5 Jan 2010 07:19:35 +0100
Subject: [Avidemux-svn-commit] r5822 -
	branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_shell
Message-ID: <201001050619.o056JZiW019549@sheep.berlios.de>

Author: mean
Date: 2010-01-05 07:19:34 +0100 (Tue, 05 Jan 2010)
New Revision: 5822

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_shell/Q_shell.cpp
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_shell/Q_shell.h
Log:
[qShell] Handle small history in shell

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_shell/Q_shell.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_shell/Q_shell.cpp	2010-01-05 06:19:30 UTC (rev 5821)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_shell/Q_shell.cpp	2010-01-05 06:19:34 UTC (rev 5822)
@@ -24,31 +24,57 @@
 #include "Q_shell.h"
 #include "ADM_default.h"
 #include "ui_shell.h"
-
+/**
+    \fn qShell
+*/
 qShell::qShell(jsShellEvaluate *s) : QDialog()
 {
     ADM_info("Setting up JS shell..\n");
     evaluator=s;
+    for(int i=0;i<Q_SHELL_HISTORY;i++)
+                    history[i]=NULL;
+
     ui.setupUi(this);
+    ui.textBrowser_2->installEventFilter(this);
     connect((ui.evalute),SIGNAL(clicked(bool)),this,SLOT(evaluate(bool)));
     connect((ui.clear),SIGNAL(clicked(bool)),this,SLOT(clear(bool)));
-    print(JS_LOG_NORMAL,"Enter your commands then press the evaluate button or CTRL+ENTER\nReady.\n");
+    print(JS_LOG_NORMAL,"Enter your commands then press the evaluate button or CTRL+ENTER.\n");
+    print(JS_LOG_NORMAL,"You can use CTRL+PageUP and CTRL+Page Down to recall previous commands\nReady.\n");
+    indexRead=indexWrite=0;
 }
-
+/**
+    \fn ~qShell
+*/
 qShell::~qShell()
 {
     ADM_info("Destroying JS shell..\n");
+    for(int i=0;i<Q_SHELL_HISTORY;i++)
+    {
+            if(history[i]) delete history[i];
+            history[i]=NULL;
+    }
+
 } 
 bool qShell::run(void)
 {
     this->exec();
     return true;
 }
+/**
+        \fn evaluate
+        \brief callback for the evaluate button
+*/
 bool            qShell::evaluate(bool x)
 {
     ADM_info("Evaluating...\n");
     // 1 Get text from UI
     QString text=ui.textBrowser_2->toPlainText();
+    int dex=indexWrite & (Q_SHELL_HISTORY-1);
+    if(history[dex]) delete history[dex];
+    history[dex]=new QString(text);
+    indexWrite++;
+    indexRead=indexWrite-1; // Points to the last one
+
     ui.textBrowser->setFontItalic(true);
     ui.textBrowser->append(text);
     ui.textBrowser->setFontItalic(false);
@@ -80,7 +106,52 @@
     ui.textBrowser->clear();
     return true;
 }
-
+/**
+    \fn eventFilter
+    \brief 
+*/
+bool qShell::eventFilter(QObject* watched, QEvent* event)
+{
+	if(event->type()==QEvent::KeyPress)
+    {
+			QKeyEvent *keyEvent = (QKeyEvent*)event;
+            if(keyEvent->modifiers() == Qt::ControlModifier)
+                switch (keyEvent->key())
+                {
+                    case Qt::Key_PageUp:   previousCommand();return true;break;
+                    case Qt::Key_PageDown: nextCommand();return true;break;
+                    default:break;
+                }
+    }
+    return QObject::eventFilter(watched, event);
+}
+/**
+    \fn previousCommand
+*/
+bool   qShell::previousCommand(void)
+{
+    int dex=indexRead & (Q_SHELL_HISTORY-1);
+    QString *copy=history[dex];
+    if(indexRead) indexRead--;
+    if(!copy) return true;
+    ui.textBrowser_2->clear();
+    ui.textBrowser_2->append(*copy);
+    return true;
+}
+/**
+    \fn nextCommand
+*/
+bool   qShell::nextCommand(void)
+{
+    if(indexRead+1<indexWrite) indexRead++;
+            else return true;
+    int dex=indexRead & (Q_SHELL_HISTORY-1);
+    QString *copy=history[dex];
+    if(!copy) return true;
+    ui.textBrowser_2->clear();
+    ui.textBrowser_2->append(*copy);
+    return true;
+}
 //EOF
 
 

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_shell/Q_shell.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_shell/Q_shell.h	2010-01-05 06:19:30 UTC (rev 5821)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_shell/Q_shell.h	2010-01-05 06:19:34 UTC (rev 5822)
@@ -10,13 +10,19 @@
 /**
     \class ADM_jsQt4Shell
 */
-
+#define Q_SHELL_HISTORY 8 // Must be a power of 2!
 class qShell: public QDialog
 {
 	Q_OBJECT
 protected:
     jsShellEvaluate      *evaluator;
     Ui_SpiderMonkeyShell ui;
+    bool                 eventFilter(QObject* watched, QEvent* event);
+    bool                 previousCommand(void);
+    bool                 nextCommand(void);
+    QString              *history[Q_SHELL_HISTORY];
+    int                  indexWrite;
+    int                  indexRead;
 public:
                     qShell(jsShellEvaluate *s) ;
     virtual         ~qShell() ;



From gruntster at mail.berlios.de  Wed Jan  6 19:16:09 2010
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Wed, 6 Jan 2010 19:16:09 +0100
Subject: [Avidemux-svn-commit] r5823 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui
Message-ID: <201001061816.o06IG9pv028875@sheep.berlios.de>

Author: gruntster
Date: 2010-01-06 19:16:01 +0100 (Wed, 06 Jan 2010)
New Revision: 5823

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/Q_gui2.cpp
Log:
[macosx] disable correct preferences action on main Qt interface

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/Q_gui2.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/Q_gui2.cpp	2010-01-05 06:19:34 UTC (rev 5822)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/Q_gui2.cpp	2010-01-06 18:16:01 UTC (rev 5823)
@@ -238,7 +238,7 @@
 
 #if defined(__APPLE__) && defined(USE_SDL)
 	ui.actionAbout_avidemux->setMenuRole(QAction::NoRole);
-	ui.actionPreferences->setMenuRole(QAction::NoRole);
+	ui.action_Preferences->setMenuRole(QAction::NoRole);
 	ui.actionQuit->setMenuRole(QAction::NoRole);
 #endif
 



From mean at mail.berlios.de  Thu Jan  7 07:26:53 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 7 Jan 2010 07:26:53 +0100
Subject: [Avidemux-svn-commit] r5824 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src
Message-ID: <201001070626.o076Qrig031116@sheep.berlios.de>

Author: mean
Date: 2010-01-07 07:26:51 +0100 (Thu, 07 Jan 2010)
New Revision: 5824

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsEditor.cpp
Log:
[JS] Also print out pts-dts when available

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsEditor.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsEditor.cpp	2010-01-06 18:16:01 UTC (rev 5823)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsEditor.cpp	2010-01-07 06:26:51 UTC (rev 5824)
@@ -28,7 +28,9 @@
     uint64_t pts,dts;
     if(true==video_body->getVideoPtsDts(framenumber, &flags,&pts,&dts))
     {
-        jsLog(JS_LOG_NORMAL,"Frame %"LU" : Flags 0x%"LX" pts=%"LLD" dts=%"LLD"\n",framenumber,flags,pts,dts);
+        int64_t delta=0;
+        if(pts!=ADM_NO_PTS && dts!=ADM_NO_PTS) delta=(int64_t)pts-(int64_t)dts;
+        jsLog(JS_LOG_NORMAL,"Frame %"LU" : Flags 0x%"LX" pts=%"LLD" dts=%"LLD" delta=%"LLD" ms",framenumber,flags,pts,dts,delta/1000LL);
     }else
     {
         jsLog(JS_LOG_NORMAL,"Cannot get info for frame %"LU,framenumber);



From mean at mail.berlios.de  Thu Jan  7 07:26:59 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 7 Jan 2010 07:26:59 +0100
Subject: [Avidemux-svn-commit] r5825 -
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src
Message-ID: <201001070626.o076Qxpl031209@sheep.berlios.de>

Author: mean
Date: 2010-01-07 07:26:58 +0100 (Thu, 07 Jan 2010)
New Revision: 5825

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_coreMuxerFfmpeg.cpp
Log:
[ffMuxer] By default all audio frames are keyframes

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_coreMuxerFfmpeg.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_coreMuxerFfmpeg.cpp	2010-01-07 06:26:51 UTC (rev 5824)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_coreMuxerFfmpeg.cpp	2010-01-07 06:26:58 UTC (rev 5825)
@@ -442,6 +442,7 @@
                     pkt.stream_index=1+audio;
                     pkt.data= audioTrack->buffer;
                     pkt.size= audioTrack->size;
+                    pkt.flags |= PKT_FLAG_KEY; // Assume all audio are keyframe, which is slightly wrong
                     ret =av_write_frame(oc, &pkt);
                     audioTrack->present=false; // consumed
                     if(ret)



From mean at mail.berlios.de  Thu Jan  7 07:27:03 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 7 Jan 2010 07:27:03 +0100
Subject: [Avidemux-svn-commit] r5826 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska
Message-ID: <201001070627.o076R3GP031390@sheep.berlios.de>

Author: mean
Date: 2010-01-07 07:27:02 +0100 (Thu, 07 Jan 2010)
New Revision: 5826

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.cpp
Log:
[Mkv] = vs == stupid typo

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.cpp	2010-01-07 06:26:58 UTC (rev 5825)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.cpp	2010-01-07 06:27:02 UTC (rev 5826)
@@ -106,7 +106,7 @@
         uint64_t pts,dts;
         pts=vid->index[i].Pts;
         lastDts+=increment; // This frame dts with no correction
-        if(pts=ADM_NO_PTS)
+        if(pts==ADM_NO_PTS)
         {
             vid->index[i].Dts=lastDts;
             continue;



From mean at mail.berlios.de  Thu Jan  7 20:08:11 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 7 Jan 2010 20:08:11 +0100
Subject: [Avidemux-svn-commit] r5827 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_openDML
Message-ID: <201001071908.o07J8BsQ026731@sheep.berlios.de>

Author: mean
Date: 2010-01-07 20:08:04 +0100 (Thu, 07 Jan 2010)
New Revision: 5827

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_openDML/ADM_openDML.cpp
Log:
[Avi] Fix weird dv-avi files with fq=0, put 48kHz

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_openDML/ADM_openDML.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_openDML/ADM_openDML.cpp	2010-01-07 06:27:02 UTC (rev 5826)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_openDML/ADM_openDML.cpp	2010-01-07 19:08:04 UTC (rev 5827)
@@ -446,6 +446,24 @@
                 {
                         // build audio stream
                         odmlAudioTrack *track;
+                        // Check it is not a weird DV file
+                        if(fourCC::check(_video_bih.biCompression,(uint8_t *)"dvsd"))
+                        {
+                             for(int i=0;i<_nbAudioTracks;i++)
+                             {
+                                    track=&(_audioTracks[i]);
+                                    WAVHeader *hdr=  track->wavHeader;
+                                    if(!hdr->frequency)
+                                    {
+                                            printf("Fixing audio track to be PCM\n");
+                                            hdr->frequency=48000;
+                                            //hdr->channels=2;
+                                            hdr->byterate=48000*hdr->channels*2;
+                                            hdr->blockalign=2*hdr->channels;
+                                    }
+                             }
+
+                        }
                         for(int i=0;i<_nbAudioTracks;i++)
                         {
                                 track=&(_audioTracks[i]);



From gruntster at mail.berlios.de  Thu Jan  7 20:25:19 2010
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Thu, 7 Jan 2010 20:25:19 +0100
Subject: [Avidemux-svn-commit] r5828 -
	branches/avidemux_2.5_branch_gruntster/platforms/windows/installer
Message-ID: <201001071925.o07JPJEC030221@sheep.berlios.de>

Author: gruntster
Date: 2010-01-07 20:25:14 +0100 (Thu, 07 Jan 2010)
New Revision: 5828

Modified:
   branches/avidemux_2.5_branch_gruntster/platforms/windows/installer/avidemux.nsi
Log:
[win32] update installer script to bundle different GCC files

Modified: branches/avidemux_2.5_branch_gruntster/platforms/windows/installer/avidemux.nsi
===================================================================
--- branches/avidemux_2.5_branch_gruntster/platforms/windows/installer/avidemux.nsi	2010-01-07 19:08:04 UTC (rev 5827)
+++ branches/avidemux_2.5_branch_gruntster/platforms/windows/installer/avidemux.nsi	2010-01-07 19:25:14 UTC (rev 5828)
@@ -283,8 +283,8 @@
     ${File} avutil-*.dll
     ${File} postproc-*.dll
     ${File} swscale-*.dll
-    ${File} libgcc_sjlj_*.dll
-    ${File} libstdc++_sjlj_*.dll
+    ${File} libgcc_s_sjlj-*.dll
+    ${File} libstdc++.dll
     SetOutPath $INSTDIR\scripts
     ${Folder} scripts
 SectionEnd
@@ -352,7 +352,6 @@
         ${File} avidemux2_qt4.exe
         ${File} libADM_render_qt4.dll
         ${File} libADM_UIQT4.dll
-        ${File} mingwm10.dll
         ${File} QtCore4.dll
     ${MementoSectionEnd}
 !endif



From gruntster at mail.berlios.de  Thu Jan  7 20:59:53 2010
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Thu, 7 Jan 2010 20:59:53 +0100
Subject: [Avidemux-svn-commit] r5829 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/include
Message-ID: <201001071959.o07Jxr5l001927@sheep.berlios.de>

Author: gruntster
Date: 2010-01-07 20:59:48 +0100 (Thu, 07 Jan 2010)
New Revision: 5829

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/include/ADM_assert.h
Log:
[win32] fast memory copy fix for mingw-w32

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/include/ADM_assert.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/include/ADM_assert.h	2010-01-07 19:25:14 UTC (rev 5828)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/include/ADM_assert.h	2010-01-07 19:59:48 UTC (rev 5829)
@@ -18,8 +18,16 @@
 #include <assert.h>
 #include "ADM_inttype.h"
 
-#if defined(__WIN64)
-#include <intrin.h>
+#if defined(__MINGW32__)
+	#include <_mingw.h>
+
+	#if defined(__MINGW64_VERSION_STR)
+		#if defined (__WIN64)
+			#include <intrin.h>
+		#else
+			#include <wchar.h>
+		#endif
+	#endif
 #endif
 
 #define ADM_assert(x) { if(!(x)) {ADM_backTrack("Assert failed :"#x,__LINE__,__FILE__);  }}



From gruntster at mail.berlios.de  Thu Jan  7 21:01:22 2010
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Thu, 7 Jan 2010 21:01:22 +0100
Subject: [Avidemux-svn-commit] r5830 - in
	branches/avidemux_2.5_branch_gruntster/cmake: . patches
Message-ID: <201001072001.o07K1MVN002143@sheep.berlios.de>

Author: gruntster
Date: 2010-01-07 21:01:15 +0100 (Thu, 07 Jan 2010)
New Revision: 5830

Removed:
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavutil_internal.h.patch
Modified:
   branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake
   branches/avidemux_2.5_branch_gruntster/cmake/patches/createPatches.sh
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_h263dec.c.patch
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_utils.c.patch
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_movenc.c.patch
Log:
[ffmpeg] update FFmpeg to r21066 & libswscale r30236

Modified: branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake	2010-01-07 19:59:48 UTC (rev 5829)
+++ branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake	2010-01-07 20:01:15 UTC (rev 5830)
@@ -1,7 +1,7 @@
 include(admFFmpegUtil)
 
-set(FFMPEG_VERSION 20900)	# http://git.ffmpeg.org/?p=ffmpeg;a=snapshot;h=c2a40c2de2f3b764180c6e74e8c2a88d2f56dfac;sf=tgz
-set(SWSCALE_VERSION 30075)	# http://git.ffmpeg.org/?p=libswscale;a=snapshot;h=8158fe4ce45496fb7ded193cd9d64e9e75268be4;sf=tgz
+set(FFMPEG_VERSION 21066)	# http://git.ffmpeg.org/?p=ffmpeg;a=snapshot;h=9de84cea40e10210b102d85736695d67a468fc06;sf=tgz
+set(SWSCALE_VERSION 30236)	# http://git.ffmpeg.org/?p=libswscale;a=snapshot;h=aa49d64093654ce136015962fcd0b9bb37249f69;sf=tgz
 
 set(LIBRARY_SOURCE_DIR "${CMAKE_SOURCE_DIR}/avidemux/ADM_libraries")
 set(FFMPEG_SOURCE_DIR "${LIBRARY_SOURCE_DIR}/ffmpeg")

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/createPatches.sh
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/createPatches.sh	2010-01-07 19:59:48 UTC (rev 5829)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/createPatches.sh	2010-01-07 20:01:15 UTC (rev 5830)
@@ -32,4 +32,4 @@
 updatePatch libavformat matroskaenc.c
 updatePatch libavformat movenc.c
 updatePatch libavutil avutil.h
-updatePatch libavutil internal.h
+

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_h263dec.c.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_h263dec.c.patch	2010-01-07 19:59:48 UTC (rev 5829)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_h263dec.c.patch	2010-01-07 20:01:15 UTC (rev 5830)
@@ -1,8 +1,8 @@
-*** libavcodec/h263dec.c.old	Tue Nov 24 18:57:47 2009
---- libavcodec/h263dec.c	Tue Nov 24 18:57:47 2009
+*** libavcodec/h263dec.c.old	Thu Jan  7 19:26:04 2010
+--- libavcodec/h263dec.c	Thu Jan  7 19:26:04 2010
 ***************
-*** 124,129 ****
---- 124,146 ----
+*** 125,130 ****
+--- 125,147 ----
   
       return 0;
   }
@@ -27,8 +27,8 @@
   av_cold int ff_h263_decode_end(AVCodecContext *avctx)
   {
 ***************
-*** 419,424 ****
---- 436,447 ----
+*** 420,425 ****
+--- 437,448 ----
       } else {
           ret = h263_decode_picture_header(s);
       }
@@ -42,8 +42,8 @@
       if(ret==FRAME_SKIPPED) return get_consumed_bytes(s, buf_size);
   
 ***************
-*** 711,716 ****
---- 734,747 ----
+*** 713,718 ****
+--- 736,749 ----
   
   assert(s->current_picture.pict_type == s->current_picture_ptr->pict_type);
   assert(s->current_picture.pict_type == s->pict_type);

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_utils.c.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_utils.c.patch	2010-01-07 19:59:48 UTC (rev 5829)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_utils.c.patch	2010-01-07 20:01:15 UTC (rev 5830)
@@ -1,5 +1,5 @@
-*** libavcodec/utils.c.old	Sat Dec 19 22:15:59 2009
---- libavcodec/utils.c	Sat Dec 19 22:16:00 2009
+*** libavcodec/utils.c.old	Thu Jan  7 19:26:08 2010
+--- libavcodec/utils.c	Thu Jan  7 19:26:09 2010
 ***************
 *** 616,625 ****
 --- 616,627 ----
@@ -16,7 +16,7 @@
           *frame_size_ptr < avctx->channels * avctx->frame_size * sizeof(int16_t)){
               av_log(avctx, AV_LOG_ERROR, "buffer %d too small\n", *frame_size_ptr);
 ***************
-*** 1053,1059 ****
+*** 1056,1062 ****
           return -1;
       }
   #if !HAVE_MKSTEMP
@@ -24,7 +24,7 @@
   #else
       snprintf(*filename, len, "/tmp/%sXXXXXX", prefix);
       fd = mkstemp(*filename);
---- 1055,1061 ----
+--- 1058,1064 ----
           return -1;
       }
   #if !HAVE_MKSTEMP

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_movenc.c.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_movenc.c.patch	2010-01-07 19:59:48 UTC (rev 5829)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_movenc.c.patch	2010-01-07 20:01:15 UTC (rev 5830)
@@ -1,8 +1,8 @@
-*** libavformat/movenc.c.old	Sat Dec 19 22:16:15 2009
---- libavformat/movenc.c	Sat Dec 19 22:16:15 2009
+*** libavformat/movenc.c.old	Thu Jan  7 19:26:12 2010
+--- libavformat/movenc.c	Thu Jan  7 19:26:12 2010
 ***************
-*** 2135,2137 ****
---- 2135,2149 ----
+*** 2138,2140 ****
+--- 2138,2152 ----
       .codec_tag = (const AVCodecTag* const []){codec_ipod_tags, 0},
   };
   #endif

Deleted: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavutil_internal.h.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavutil_internal.h.patch	2010-01-07 19:59:48 UTC (rev 5829)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavutil_internal.h.patch	2010-01-07 20:01:15 UTC (rev 5830)
@@ -1,19 +0,0 @@
-*** libavutil/internal.h.old	Tue Nov 24 18:58:16 2009
---- libavutil/internal.h	Tue Nov 24 18:58:16 2009
-***************
-*** 214,225 ****
---- 214,227 ----
-  #endif
-  
-  /* avoid usage of dangerous/inappropriate system functions */
-+ #if 0 //MEANX
-  #undef  malloc
-  #define malloc please_use_av_malloc
-  #undef  free
-  #define free please_use_av_free
-  #undef  realloc
-  #define realloc please_use_av_realloc
-+ #endif
-  #undef  time
-  #define time time_is_forbidden_due_to_security_issues
-  #undef  rand



From mean at mail.berlios.de  Fri Jan  8 19:55:07 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 8 Jan 2010 19:55:07 +0100
Subject: [Avidemux-svn-commit] r5831 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video
Message-ID: <201001081855.o08It7uh012725@sheep.berlios.de>

Author: mean
Date: 2010-01-08 19:55:07 +0100 (Fri, 08 Jan 2010)
New Revision: 5831

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidPartial.cpp
Log:
[filter] fix partial when child has parameters, fixes #66, again.

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidPartial.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidPartial.cpp	2010-01-07 20:01:15 UTC (rev 5830)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_vidPartial.cpp	2010-01-08 18:55:07 UTC (rev 5831)
@@ -100,7 +100,7 @@
 				*couples=new CONFcouple(3);
 				CSET(_start);
 				CSET(_end);
-                (*couples)->setCouple("_name",filterGetInternalNameFromTag(_param->_tag));
+                                (*couples)->setCouple("_name",filterGetInternalNameFromTag(_param->_tag));
 				//CSET(_tag);
 				return 1;
 			}
@@ -112,7 +112,7 @@
 			CSET(_start);
 			CSET(_end);
 			//CSET(_tag);
-            (*couples)->setCouple("_name",filterGetNameFromTag(_param->_tag));
+                        (*couples)->setCouple("_name",filterGetInternalNameFromTag(_param->_tag));
 
 	// then set the child ones
 	char *nm,*vl;



From mean at mail.berlios.de  Sat Jan  9 12:03:20 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 9 Jan 2010 12:03:20 +0100
Subject: [Avidemux-svn-commit] r5832 - in
	branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass:
	. ADM_libAss
Message-ID: <201001091103.o09B3K0f017202@sheep.berlios.de>

Author: mean
Date: 2010-01-09 12:03:17 +0100 (Sat, 09 Jan 2010)
New Revision: 5832

Added:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_parse.c
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_parse.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_render.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_strtod.c
Modified:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass.c
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_bitmap.c
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_bitmap.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_cache.c
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_cache.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_cache_template.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_drawing.c
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_drawing.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_font.c
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_font.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_fontconfig.c
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_fontconfig.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_library.c
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_library.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_render.c
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_types.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_utils.c
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_utils.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/readme
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_vidASS.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_vidASS.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/CMakeLists.txt
Log:
[Ass] Update libass to git version + tweak a bit CMakelist.txt to enable fontconfig/freetype if they are there

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/CMakeLists.txt	2010-01-08 18:55:07 UTC (rev 5831)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/CMakeLists.txt	2010-01-09 11:03:17 UTC (rev 5832)
@@ -10,6 +10,7 @@
 
         SET(${ADM_LIB}_SRCS 
         ass_bitmap.c  ass.c  ass_cache.c  ass_drawing.c  ass_font.c    ass_library.c  ass_render.c  ass_utils.c
+        ass_parse.c ass_strtod.c
         )
     IF (FONTCONFIG_FOUND)
         ADD_DEFINITIONS(${FONTCONFIG_CFLAGS} "-DHAVE_FONTCONFIG=1" "-DCONFIG_FONTCONFIG=1")

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass.c	2010-01-08 18:55:07 UTC (rev 5831)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass.c	2010-01-09 11:03:17 UTC (rev 5832)
@@ -38,11 +38,16 @@
 #include "ass_utils.h"
 #include "ass_library.h"
 
-typedef enum { PST_UNKNOWN =
-        0, PST_INFO, PST_STYLES, PST_EVENTS, PST_FONTS } parser_state_t;
+typedef enum {
+    PST_UNKNOWN = 0,
+    PST_INFO,
+    PST_STYLES,
+    PST_EVENTS,
+    PST_FONTS
+} ParserState;
 
 struct parser_priv {
-    parser_state_t state;
+    ParserState state;
     char *fontname;
     char *fontdata;
     int fontdata_size;
@@ -52,7 +57,7 @@
 #define ASS_STYLES_ALLOC 20
 #define ASS_EVENTS_ALLOC 200
 
-void ass_free_track(ass_track_t *track)
+void ass_free_track(ASS_Track *track)
 {
     int i;
 
@@ -84,7 +89,7 @@
 /// \brief Allocate a new style struct
 /// \param track track
 /// \return style id
-int ass_alloc_style(ass_track_t *track)
+int ass_alloc_style(ASS_Track *track)
 {
     int sid;
 
@@ -93,20 +98,20 @@
     if (track->n_styles == track->max_styles) {
         track->max_styles += ASS_STYLES_ALLOC;
         track->styles =
-            (ass_style_t *) realloc(track->styles,
-                                    sizeof(ass_style_t) *
-                                    track->max_styles);
+            (ASS_Style *) realloc(track->styles,
+                                  sizeof(ASS_Style) *
+                                  track->max_styles);
     }
 
     sid = track->n_styles++;
-    memset(track->styles + sid, 0, sizeof(ass_style_t));
+    memset(track->styles + sid, 0, sizeof(ASS_Style));
     return sid;
 }
 
 /// \brief Allocate a new event struct
 /// \param track track
 /// \return event id
-int ass_alloc_event(ass_track_t *track)
+int ass_alloc_event(ASS_Track *track)
 {
     int eid;
 
@@ -115,19 +120,19 @@
     if (track->n_events == track->max_events) {
         track->max_events += ASS_EVENTS_ALLOC;
         track->events =
-            (ass_event_t *) realloc(track->events,
-                                    sizeof(ass_event_t) *
-                                    track->max_events);
+            (ASS_Event *) realloc(track->events,
+                                  sizeof(ASS_Event) *
+                                  track->max_events);
     }
 
     eid = track->n_events++;
-    memset(track->events + eid, 0, sizeof(ass_event_t));
+    memset(track->events + eid, 0, sizeof(ASS_Event));
     return eid;
 }
 
-void ass_free_event(ass_track_t *track, int eid)
+void ass_free_event(ASS_Track *track, int eid)
 {
-    ass_event_t *event = track->events + eid;
+    ASS_Event *event = track->events + eid;
     if (event->Name)
         free(event->Name);
     if (event->Effect)
@@ -138,9 +143,9 @@
         free(event->render_priv);
 }
 
-void ass_free_style(ass_track_t *track, int sid)
+void ass_free_style(ASS_Track *track, int sid)
 {
-    ass_style_t *style = track->styles + sid;
+    ASS_Style *style = track->styles + sid;
     if (style->Name)
         free(style->Name);
     if (style->FontName)
@@ -173,7 +178,7 @@
  * Returnes 0 if no styles found => expects at least 1 style.
  * Parsing code always adds "Default" style in the end.
  */
-static int lookup_style(ass_track_t *track, char *name)
+static int lookup_style(ASS_Track *track, char *name)
 {
     int i;
     if (*name == '*')
@@ -190,14 +195,14 @@
     return i;                   // use the first style
 }
 
-static uint32_t string2color(ass_library_t *library, char *p)
+static uint32_t string2color(ASS_Library *library, char *p)
 {
     uint32_t tmp;
-    (void) strtocolor(library, &p, &tmp);
+    (void) strtocolor(library, &p, &tmp, 0);
     return tmp;
 }
 
-static long long string2timecode(ass_library_t *library, char *p)
+static long long string2timecode(ASS_Library *library, char *p)
 {
     unsigned h, m, s, ms;
     long long tm;
@@ -294,14 +299,14 @@
  * \param str string to parse, zero-terminated
  * \param n_ignored number of format options to skip at the beginning
 */
-static int process_event_tail(ass_track_t *track, ass_event_t *event,
+static int process_event_tail(ASS_Track *track, ASS_Event *event,
                               char *str, int n_ignored)
 {
     char *token;
     char *tname;
     char *p = str;
     int i;
-    ass_event_t *target = event;
+    ASS_Event *target = event;
 
     char *format = strdup(track->event_format);
     char *q = format;           // format scanning pointer
@@ -357,10 +362,10 @@
  * \param track track to apply overrides to
  * The format for overrides is [StyleName.]Field=Value
  */
-void ass_process_force_style(ass_track_t *track)
+void ass_process_force_style(ASS_Track *track)
 {
     char **fs, *eq, *dt, *style, *tname, *token;
-    ass_style_t *target;
+    ASS_Style *target;
     int sid;
     char **list = track->library->style_overrides;
 
@@ -384,6 +389,8 @@
             track->WrapStyle = atoi(token);
         else if (!strcasecmp(*fs, "ScaledBorderAndShadow"))
             track->ScaledBorderAndShadow = parse_bool(token);
+        else if (!strcasecmp(*fs, "Kerning"))
+            track->Kerning = parse_bool(token);
 
         dt = strrchr(*fs, '.');
         if (dt) {
@@ -436,7 +443,7 @@
  * \param str string to parse, zero-terminated
  * Allocates a new style struct.
 */
-static int process_style(ass_track_t *track, char *str)
+static int process_style(ASS_Track *track, char *str)
 {
 
     char *token;
@@ -445,8 +452,8 @@
     char *format;
     char *q;                    // format scanning pointer
     int sid;
-    ass_style_t *style;
-    ass_style_t *target;
+    ASS_Style *style;
+    ASS_Style *target;
 
     if (!track->style_format) {
         // no style format header
@@ -474,7 +481,8 @@
 
     style = track->styles + sid;
     target = style;
-// fill style with some default values
+
+    // fill style with some default values
     style->ScaleX = 100.;
     style->ScaleY = 100.;
 
@@ -482,8 +490,6 @@
         NEXT(q, tname);
         NEXT(p, token);
 
-//              ALIAS(TertiaryColour,OutlineColour) // ignore TertiaryColour; it appears only in SSA, and is overridden by BackColour
-
         if (0) {                // cool ;)
             STRVAL(Name)
             if ((strcmp(target->Name, "Default") == 0)
@@ -539,7 +545,7 @@
 
 }
 
-static int process_styles_line(ass_track_t *track, char *str)
+static int process_styles_line(ASS_Track *track, char *str)
 {
     if (!strncmp(str, "Format:", 7)) {
         char *p = str + 7;
@@ -555,7 +561,7 @@
     return 0;
 }
 
-static int process_info_line(ass_track_t *track, char *str)
+static int process_info_line(ASS_Track *track, char *str)
 {
     if (!strncmp(str, "PlayResX:", 9)) {
         track->PlayResX = atoi(str + 9);
@@ -567,11 +573,13 @@
         track->WrapStyle = atoi(str + 10);
     } else if (!strncmp(str, "ScaledBorderAndShadow:", 22)) {
         track->ScaledBorderAndShadow = parse_bool(str + 22);
+    } else if (!strncmp(str, "Kerning:", 8)) {
+        track->Kerning = parse_bool(str + 8);
     }
     return 0;
 }
 
-static void event_format_fallback(ass_track_t *track)
+static void event_format_fallback(ASS_Track *track)
 {
     track->parser_priv->state = PST_EVENTS;
     if (track->track_type == TRACK_TYPE_SSA)
@@ -584,7 +592,7 @@
             "No event format found, using fallback");
 }
 
-static int process_events_line(ass_track_t *track, char *str)
+static int process_events_line(ASS_Track *track, char *str)
 {
     if (!strncmp(str, "Format:", 7)) {
         char *p = str + 7;
@@ -596,7 +604,7 @@
         // They have slightly different format and are parsed in ass_process_chunk,
         // called directly from demuxer
         int eid;
-        ass_event_t *event;
+        ASS_Event *event;
 
         str += 9;
         skip_spaces(&str);
@@ -636,7 +644,7 @@
     return dst;
 }
 
-static int decode_font(ass_track_t *track)
+static int decode_font(ASS_Track *track)
 {
     unsigned char *p;
     unsigned char *q;
@@ -684,7 +692,7 @@
     return 0;
 }
 
-static int process_fonts_line(ass_track_t *track, char *str)
+static int process_fonts_line(ASS_Track *track, char *str)
 {
     int len;
 
@@ -730,7 +738,7 @@
  * \param track track
  * \param str string to parse, zero-terminated
 */
-static int process_line(ass_track_t *track, char *str)
+static int process_line(ASS_Track *track, char *str)
 {
     if (!strncasecmp(str, "[Script Info]", 13)) {
         track->parser_priv->state = PST_INFO;
@@ -771,7 +779,7 @@
     return 0;
 }
 
-static int process_text(ass_track_t *track, char *str)
+static int process_text(ASS_Track *track, char *str)
 {
     char *p = str;
     while (1) {
@@ -804,7 +812,7 @@
  * \param data string to parse
  * \param size length of data
 */
-void ass_process_data(ass_track_t *track, char *data, int size)
+void ass_process_data(ASS_Track *track, char *data, int size)
 {
     char *str = malloc(size + 1);
 
@@ -823,7 +831,7 @@
  * \param size length of data
  CodecPrivate section contains [Stream Info] and [V4+ Styles] ([V4 Styles] for SSA) sections
 */
-void ass_process_codec_private(ass_track_t *track, char *data, int size)
+void ass_process_codec_private(ASS_Track *track, char *data, int size)
 {
     ass_process_data(track, data, size);
 
@@ -835,7 +843,7 @@
     ass_process_force_style(track);
 }
 
-static int check_duplicate_event(ass_track_t *track, int ReadOrder)
+static int check_duplicate_event(ASS_Track *track, int ReadOrder)
 {
     int i;
     for (i = 0; i < track->n_events - 1; ++i)   // ignoring last event, it is the one we are comparing with
@@ -852,14 +860,14 @@
  * \param timecode starting time of the event (milliseconds)
  * \param duration duration of the event (milliseconds)
 */
-void ass_process_chunk(ass_track_t *track, char *data, int size,
+void ass_process_chunk(ASS_Track *track, char *data, int size,
                        long long timecode, long long duration)
 {
     char *str;
     int eid;
     char *p;
     char *token;
-    ass_event_t *event;
+    ASS_Event *event;
 
     if (!track->event_format) {
         ass_msg(track->library, MSGL_WARN, "Event format header missing");
@@ -908,7 +916,7 @@
  * \param size buffer size
  * \return a pointer to recoded buffer, caller is responsible for freeing it
 **/
-static char *sub_recode(ass_library_t *library, char *data, size_t size,
+static char *sub_recode(ASS_Library *library, char *data, size_t size,
                         char *codepage)
 {
     iconv_t icdsc;
@@ -987,7 +995,7 @@
  * \param bufsize out: file size
  * \return pointer to file contents. Caller is responsible for its deallocation.
  */
-static char *read_file(ass_library_t *library, char *fname, size_t *bufsize)
+static char *read_file(ASS_Library *library, char *fname, size_t *bufsize)
 {
     int res;
     long sz;
@@ -1046,9 +1054,9 @@
 /*
  * \param buf pointer to subtitle text in utf-8
  */
-static ass_track_t *parse_memory(ass_library_t *library, char *buf)
+static ASS_Track *parse_memory(ASS_Library *library, char *buf)
 {
-    ass_track_t *track;
+    ASS_Track *track;
     int i;
 
     track = ass_new_track(library);
@@ -1082,22 +1090,23 @@
  * \param codepage recode buffer contents from given codepage
  * \return newly allocated track
 */
-ass_track_t *ass_read_memory(ass_library_t *library, char *buf,
-                             size_t bufsize, char *codepage)
+ASS_Track *ass_read_memory(ASS_Library *library, char *buf,
+                           size_t bufsize, char *codepage)
 {
-    ass_track_t *track;
+    ASS_Track *track;
     int need_free = 0;
 
     if (!buf)
         return 0;
 
 #ifdef CONFIG_ICONV
-    if (codepage)
+    if (codepage) {
         buf = sub_recode(library, buf, bufsize, codepage);
-    if (!buf)
-        return 0;
-    else
-        need_free = 1;
+        if (!buf)
+            return 0;
+        else
+            need_free = 1;
+    }
 #endif
     track = parse_memory(library, buf);
     if (need_free)
@@ -1111,7 +1120,7 @@
     return track;
 }
 
-static char *read_file_recode(ass_library_t *library, char *fname,
+static char *read_file_recode(ASS_Library *library, char *fname,
                               char *codepage, size_t *size)
 {
     char *buf;
@@ -1140,11 +1149,11 @@
  * \param codepage recode buffer contents from given codepage
  * \return newly allocated track
 */
-ass_track_t *ass_read_file(ass_library_t *library, char *fname,
-                           char *codepage)
+ASS_Track *ass_read_file(ASS_Library *library, char *fname,
+                         char *codepage)
 {
     char *buf;
-    ass_track_t *track;
+    ASS_Track *track;
     size_t bufsize;
 
     buf = read_file_recode(library, fname, codepage, &bufsize);
@@ -1167,10 +1176,10 @@
 /**
  * \brief read styles from file into already initialized track
  */
-int ass_read_styles(ass_track_t *track, char *fname, char *codepage)
+int ass_read_styles(ASS_Track *track, char *fname, char *codepage)
 {
     char *buf;
-    parser_state_t old_state;
+    ParserState old_state;
     size_t sz;
 
     buf = read_file(track->library, fname, &sz);
@@ -1195,7 +1204,7 @@
     return 0;
 }
 
-long long ass_step_sub(ass_track_t *track, long long now, int movement)
+long long ass_step_sub(ASS_Track *track, long long now, int movement)
 {
     int i;
 
@@ -1227,11 +1236,11 @@
     return ((long long) track->events[i].Start) - now;
 }
 
-ass_track_t *ass_new_track(ass_library_t *library)
+ASS_Track *ass_new_track(ASS_Library *library)
 {
-    ass_track_t *track = calloc(1, sizeof(ass_track_t));
+    ASS_Track *track = calloc(1, sizeof(ASS_Track));
     track->library = library;
     track->ScaledBorderAndShadow = 1;
-    track->parser_priv = calloc(1, sizeof(parser_priv_t));
+    track->parser_priv = calloc(1, sizeof(ASS_ParserPriv));
     return track;
 }

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass.h	2010-01-08 18:55:07 UTC (rev 5831)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass.h	2010-01-09 11:03:17 UTC (rev 5832)
@@ -25,7 +25,7 @@
 #include <stdarg.h>
 #include "ass_types.h"
 
-#define LIBASS_VERSION 0x00907000
+#define LIBASS_VERSION 0x00908000
 
 /*
  * A linked list of images produced by an ass renderer.
@@ -46,10 +46,10 @@
     int dst_x, dst_y;           // Bitmap placement inside the video frame
 
     struct ass_image *next;   // Next image, or NULL
-} ass_image_t;
+} ASS_Image;
 
 /*
- * Hintint type. (see ass_set_hinting below)
+ * Hinting type. (see ass_set_hinting below)
  *
  * FreeType's native hinter is still buggy sometimes and it is recommended
  * to use the light autohinter, ASS_HINTING_LIGHT, instead.  For best
@@ -60,19 +60,19 @@
     ASS_HINTING_LIGHT,
     ASS_HINTING_NORMAL,
     ASS_HINTING_NATIVE
-} ass_hinting_t;
+} ASS_Hinting;
 
 /**
  * \brief Initialize the library.
  * \return library handle or NULL if failed
  */
-ass_library_t *ass_library_init(void);
+ASS_Library *ass_library_init(void);
 
 /**
  * \brief Finalize the library
  * \param priv library handle
  */
-void ass_library_done(ass_library_t *);
+void ass_library_done(ASS_Library *priv);
 
 /**
  * \brief Set private font directory.
@@ -81,14 +81,14 @@
  * \param priv library handle
  * \param fonts_dir private directory for font extraction
  */
-void ass_set_fonts_dir(ass_library_t *priv, const char *fonts_dir);
+void ass_set_fonts_dir(ASS_Library *priv, const char *fonts_dir);
 
 /**
  * \brief Whether fonts should be extracted from track data.
  * \param priv library handle
  * \param extract whether to extract fonts
  */
-void ass_set_extract_fonts(ass_library_t *priv, int extract);
+void ass_set_extract_fonts(ASS_Library *priv, int extract);
 
 /**
  * \brief Register style overrides with a library instance.
@@ -99,13 +99,13 @@
  * \param priv library handle
  * \param list NULL-terminated list of strings
  */
-void ass_set_style_overrides(ass_library_t *priv, char **list);
+void ass_set_style_overrides(ASS_Library *priv, char **list);
 
 /**
  * \brief Explicitly process style overrides for a track.
  * \param track track handle
  */
-void ass_process_force_style(ass_track_t *track);
+void ass_process_force_style(ASS_Track *track);
 
 /**
  * \brief Register a callback for debug/info messages.
@@ -121,7 +121,7 @@
  * \param msg_cb pointer to callback function
  * \param data additional data, will be passed to callback
  */
-void ass_set_message_cb(ass_library_t *priv, void (*msg_cb)
+void ass_set_message_cb(ASS_Library *priv, void (*msg_cb)
                         (int level, const char *fmt, va_list args, void *data),
                         void *data);
 
@@ -130,13 +130,13 @@
  * \param priv library handle
  * \return renderer handle or NULL if failed
  */
-ass_renderer_t *ass_renderer_init(ass_library_t *);
+ASS_Renderer *ass_renderer_init(ASS_Library *);
 
 /**
  * \brief Finalize the renderer.
  * \param priv renderer handle
  */
-void ass_renderer_done(ass_renderer_t *priv);
+void ass_renderer_done(ASS_Renderer *priv);
 
 /**
  * \brief Set the frame size in pixels, including margins.
@@ -144,7 +144,7 @@
  * \param w width
  * \param h height
  */
-void ass_set_frame_size(ass_renderer_t *priv, int w, int h);
+void ass_set_frame_size(ASS_Renderer *priv, int w, int h);
 
 /**
  * \brief Set frame margins.  These values may be negative if pan-and-scan
@@ -155,53 +155,56 @@
  * \param l left margin
  * \param r right margin
  */
-void ass_set_margins(ass_renderer_t *priv, int t, int b, int l, int r);
+void ass_set_margins(ASS_Renderer *priv, int t, int b, int l, int r);
 
 /**
  * \brief Whether margins should be used for placing regular events.
  * \param priv renderer handle
  * \param use whether to use the margins
  */
-void ass_set_use_margins(ass_renderer_t *priv, int use);
+void ass_set_use_margins(ASS_Renderer *priv, int use);
 
 /**
  * \brief Set aspect ratio parameters.
  * \param priv renderer handle
- * \param ar physical aspect ratio
- * \param par pixel ratio, e.g. width / height of the video
+ * \param dar display aspect ratio (DAR), prescaled for output PAR
+ * \param sar storage aspect ratio (SAR)
  */
-void ass_set_aspect_ratio(ass_renderer_t *priv, double ar, double par);
+void ass_set_aspect_ratio(ASS_Renderer *priv, double dar, double sar);
 
 /**
  * \brief Set a fixed font scaling factor.
  * \param priv renderer handle
  * \param font_scale scaling factor, default is 1.0
  */
-void ass_set_font_scale(ass_renderer_t *priv, double font_scale);
+void ass_set_font_scale(ASS_Renderer *priv, double font_scale);
 
 /**
  * \brief Set font hinting method.
  * \param priv renderer handle
  * \param ht hinting method
  */
-void ass_set_hinting(ass_renderer_t *priv, ass_hinting_t ht);
+void ass_set_hinting(ASS_Renderer *priv, ASS_Hinting ht);
 
 /**
  * \brief Set line spacing. Will not be scaled with frame size.
  * \param priv renderer handle
  * \param line_spacing line spacing in pixels
  */
-void ass_set_line_spacing(ass_renderer_t *priv, double line_spacing);
+void ass_set_line_spacing(ASS_Renderer *priv, double line_spacing);
 
 /**
  * \brief Set font lookup defaults.
+ * \param default_font path to default font to use. Must be supplied if
+ * fontconfig is disabled or unavailable.
+ * \param default_family fallback font family for fontconfig, or NULL
  * \param fc whether to use fontconfig
  * \param config path to fontconfig configuration file, or NULL.  Only relevant
  * if fontconfig is used.
  * \param update whether fontconfig cache should be built/updated now.  Only
  * relevant if fontconfig is used.
  */
-void ass_set_fonts(ass_renderer_t *priv, const char *default_font,
+void ass_set_fonts(ASS_Renderer *priv, const char *default_font,
                    const char *default_family, int fc, const char *config,
                    int update);
 
@@ -212,7 +215,7 @@
  * \param priv renderer handle
  * \return success
  */
-int ass_fonts_update(ass_renderer_t *priv);
+int ass_fonts_update(ASS_Renderer *priv);
 
 /**
  * \brief Set hard cache limits.  Do not set, or set to zero, for reasonable
@@ -222,19 +225,19 @@
  * \param glyph_max maximum number of cached glyphs
  * \param bitmap_max_size maximum bitmap cache size (in MB)
  */
-void ass_set_cache_limits(ass_renderer_t *priv, int glyph_max,
+void ass_set_cache_limits(ASS_Renderer *priv, int glyph_max,
                           int bitmap_max_size);
 
 /**
- * \brief Render a frame, producing a list of ass_image_t.
+ * \brief Render a frame, producing a list of ASS_Image.
  * \param priv renderer handle
  * \param track subtitle track
  * \param now video timestamp in milliseconds
  * \param detect_change will be set to 1 if a change occured compared
  * to the last invocation
  */
-ass_image_t *ass_render_frame(ass_renderer_t *priv, ass_track_t *track,
-                              long long now, int *detect_change);
+ASS_Image *ass_render_frame(ASS_Renderer *priv, ASS_Track *track,
+                            long long now, int *detect_change);
 
 
 /*
@@ -247,27 +250,27 @@
  * \param library handle
  * \return pointer to empty track
  */
-ass_track_t *ass_new_track(ass_library_t *);
+ASS_Track *ass_new_track(ASS_Library *);
 
 /**
  * \brief Deallocate track and all its child objects (styles and events).
  * \param track track to deallocate
  */
-void ass_free_track(ass_track_t *track);
+void ass_free_track(ASS_Track *track);
 
 /**
  * \brief Allocate new style.
  * \param track track
  * \return newly allocated style id
  */
-int ass_alloc_style(ass_track_t *track);
+int ass_alloc_style(ASS_Track *track);
 
 /**
  * \brief Allocate new event.
  * \param track track
  * \return newly allocated event id
  */
-int ass_alloc_event(ass_track_t *track);
+int ass_alloc_event(ASS_Track *track);
 
 /**
  * \brief Delete a style.
@@ -275,7 +278,7 @@
  * \param sid style id
  * Deallocates style data. Does not modify track->n_styles.
  */
-void ass_free_style(ass_track_t *track, int sid);
+void ass_free_style(ASS_Track *track, int sid);
 
 /**
  * \brief Delete an event.
@@ -283,7 +286,7 @@
  * \param eid event id
  * Deallocates event data. Does not modify track->n_events.
  */
-void ass_free_event(ass_track_t *track, int eid);
+void ass_free_event(ASS_Track *track, int eid);
 
 /**
  * \brief Parse a chunk of subtitle stream data.
@@ -291,7 +294,7 @@
  * \param data string to parse
  * \param size length of data
  */
-void ass_process_data(ass_track_t *track, char *data, int size);
+void ass_process_data(ASS_Track *track, char *data, int size);
 
 /**
  * \brief Parse Codec Private section of subtitle stream.
@@ -299,7 +302,7 @@
  * \param data string to parse
  * \param size length of data
  */
-void ass_process_codec_private(ass_track_t *track, char *data, int size);
+void ass_process_codec_private(ASS_Track *track, char *data, int size);
 
 /**
  * \brief Parse a chunk of subtitle stream data. In Matroska,
@@ -310,7 +313,7 @@
  * \param timecode starting time of the event (milliseconds)
  * \param duration duration of the event (milliseconds)
  */
-void ass_process_chunk(ass_track_t *track, char *data, int size,
+void ass_process_chunk(ASS_Track *track, char *data, int size,
                        long long timecode, long long duration);
 
 /**
@@ -320,8 +323,8 @@
  * \param codepage encoding (iconv format)
  * \return newly allocated track
 */
-ass_track_t *ass_read_file(ass_library_t *library, char *fname,
-                           char *codepage);
+ASS_Track *ass_read_file(ASS_Library *library, char *fname,
+                         char *codepage);
 
 /**
  * \brief Read subtitles from memory.
@@ -331,15 +334,15 @@
  * \param codepage encoding (iconv format)
  * \return newly allocated track
 */
-ass_track_t *ass_read_memory(ass_library_t *library, char *buf,
-                             size_t bufsize, char *codepage);
+ASS_Track *ass_read_memory(ASS_Library *library, char *buf,
+                           size_t bufsize, char *codepage);
 /**
  * \brief Read styles from file into already initialized track.
  * \param fname file name
  * \param codepage encoding (iconv format)
  * \return 0 on success
  */
-int ass_read_styles(ass_track_t *track, char *fname, char *codepage);
+int ass_read_styles(ASS_Track *track, char *fname, char *codepage);
 
 /**
  * \brief Add a memory font.
@@ -348,14 +351,14 @@
  * \param data binary font data
  * \param data_size data size
 */
-void ass_add_font(ass_library_t *library, char *name, char *data,
+void ass_add_font(ASS_Library *library, char *name, char *data,
                   int data_size);
 
 /**
  * \brief Remove all fonts stored in an ass_library object.
  * \param library library handle
  */
-void ass_clear_fonts(ass_library_t *library);
+void ass_clear_fonts(ASS_Library *library);
 
 /**
  * \brief Calculates timeshift from now to the start of some other subtitle
@@ -366,6 +369,6 @@
  * +2 means "the one after the next", -1 means "previous"
  * \return timeshift in milliseconds
  */
-long long ass_step_sub(ass_track_t *track, long long now, int movement);
+long long ass_step_sub(ASS_Track *track, long long now, int movement);
 
 #endif /* LIBASS_ASS_H */

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_bitmap.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_bitmap.c	2010-01-08 18:55:07 UTC (rev 5831)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_bitmap.c	2010-01-09 11:03:17 UTC (rev 5832)
@@ -44,7 +44,7 @@
 static const unsigned int maxcolor = 255;
 static const unsigned base = 256;
 
-static int generate_tables(ass_synth_priv_t *priv, double radius)
+static int generate_tables(ASS_SynthPriv *priv, double radius)
 {
     double A = log(1.0 / base) / (radius * radius * 2);
     int mx, i;
@@ -101,7 +101,7 @@
     return 0;
 }
 
-static void resize_tmp(ass_synth_priv_t *priv, int w, int h)
+static void resize_tmp(ASS_SynthPriv *priv, int w, int h)
 {
     if (priv->tmp_w >= w && priv->tmp_h >= h)
         return;
@@ -118,14 +118,14 @@
     priv->tmp = malloc((priv->tmp_w + 1) * priv->tmp_h * sizeof(short));
 }
 
-ass_synth_priv_t *ass_synth_init(double radius)
+ASS_SynthPriv *ass_synth_init(double radius)
 {
-    ass_synth_priv_t *priv = calloc(1, sizeof(ass_synth_priv_t));
+    ASS_SynthPriv *priv = calloc(1, sizeof(ASS_SynthPriv));
     generate_tables(priv, radius);
     return priv;
 }
 
-void ass_synth_done(ass_synth_priv_t *priv)
+void ass_synth_done(ASS_SynthPriv *priv)
 {
     if (priv->tmp)
         free(priv->tmp);
@@ -136,10 +136,10 @@
     free(priv);
 }
 
-static bitmap_t *alloc_bitmap(int w, int h)
+static Bitmap *alloc_bitmap(int w, int h)
 {
-    bitmap_t *bm;
-    bm = calloc(1, sizeof(bitmap_t));
+    Bitmap *bm;
+    bm = calloc(1, sizeof(Bitmap));
     bm->buffer = malloc(w * h);
     bm->w = w;
     bm->h = h;
@@ -147,7 +147,7 @@
     return bm;
 }
 
-void ass_free_bitmap(bitmap_t *bm)
+void ass_free_bitmap(Bitmap *bm)
 {
     if (bm) {
         if (bm->buffer)
@@ -156,16 +156,16 @@
     }
 }
 
-static bitmap_t *copy_bitmap(const bitmap_t *src)
+static Bitmap *copy_bitmap(const Bitmap *src)
 {
-    bitmap_t *dst = alloc_bitmap(src->w, src->h);
+    Bitmap *dst = alloc_bitmap(src->w, src->h);
     dst->left = src->left;
     dst->top = src->top;
     memcpy(dst->buffer, src->buffer, src->w * src->h);
     return dst;
 }
 
-static int check_glyph_area(ass_library_t *library, FT_Glyph glyph)
+static int check_glyph_area(ASS_Library *library, FT_Glyph glyph)
 {
     FT_BBox bbox;
     long long dx, dy;
@@ -180,12 +180,12 @@
         return 0;
 }
 
-static bitmap_t *glyph_to_bitmap_internal(ass_library_t *library,
+static Bitmap *glyph_to_bitmap_internal(ASS_Library *library,
                                           FT_Glyph glyph, int bord)
 {
     FT_BitmapGlyph bg;
     FT_Bitmap *bit;
-    bitmap_t *bm;
+    Bitmap *bm;
     int w, h;
     unsigned char *src;
     unsigned char *dst;
@@ -230,12 +230,12 @@
 }
 
 /**
- * \brief fix outline bitmap and generate shadow bitmap
- * Two things are done here:
- * 1. Glyph bitmap is subtracted from outline bitmap. This way looks much better in some cases.
- * 2. Shadow bitmap is created as a sum of glyph and outline bitmaps.
+ * \brief fix outline bitmap
+ *
+ * The glyph bitmap is subtracted from outline bitmap. This way looks much
+ * better in some cases.
  */
-static bitmap_t *fix_outline_and_shadow(bitmap_t *bm_g, bitmap_t *bm_o)
+static void fix_outline(Bitmap *bm_g, Bitmap *bm_o)
 {
     int x, y;
     const int l = bm_o->left > bm_g->left ? bm_o->left : bm_g->left;
@@ -247,30 +247,21 @@
         bm_o->top + bm_o->h <
         bm_g->top + bm_g->h ? bm_o->top + bm_o->h : bm_g->top + bm_g->h;
 
-    bitmap_t *bm_s = copy_bitmap(bm_o);
-
     unsigned char *g =
         bm_g->buffer + (t - bm_g->top) * bm_g->w + (l - bm_g->left);
     unsigned char *o =
         bm_o->buffer + (t - bm_o->top) * bm_o->w + (l - bm_o->left);
-    unsigned char *s =
-        bm_s->buffer + (t - bm_s->top) * bm_s->w + (l - bm_s->left);
 
     for (y = 0; y < b - t; ++y) {
         for (x = 0; x < r - l; ++x) {
             unsigned char c_g, c_o;
             c_g = g[x];
             c_o = o[x];
-            o[x] = (c_o > (3 * c_g) / 5) ? c_o - (3 * c_g) / 5 : 0;
-            s[x] = (c_o < 0xFF - c_g) ? c_o + c_g : 0xFF;
+            o[x] = (c_o > c_g) ? c_o - (c_g / 2) : 0;
         }
         g += bm_g->w;
         o += bm_o->w;
-        s += bm_s->w;
     }
-
-    assert(bm_s);
-    return bm_s;
 }
 
 /**
@@ -472,10 +463,11 @@
     }
 }
 
-int glyph_to_bitmap(ass_library_t *library, ass_synth_priv_t *priv_blur,
+int glyph_to_bitmap(ASS_Library *library, ASS_SynthPriv *priv_blur,
                     FT_Glyph glyph, FT_Glyph outline_glyph,
-                    bitmap_t **bm_g, bitmap_t **bm_o, bitmap_t **bm_s,
-                    int be, double blur_radius, FT_Vector shadow_offset)
+                    Bitmap **bm_g, Bitmap **bm_o, Bitmap **bm_s,
+                    int be, double blur_radius, FT_Vector shadow_offset,
+                    int border_style)
 {
     blur_radius *= 2;
     int bbord = be > 0 ? sqrt(2 * be) : 0;
@@ -527,14 +519,19 @@
                            priv_blur->g_w);
     }
 
-    if (*bm_o)
-        *bm_s = fix_outline_and_shadow(*bm_g, *bm_o);
-    else
+    // Create shadow and fix outline as needed
+    if (*bm_o && border_style != 3) {
+        *bm_s = copy_bitmap(*bm_o);
+        fix_outline(*bm_g, *bm_o);
+    } else if (*bm_o) {
+        *bm_s = copy_bitmap(*bm_o);
+    } else
         *bm_s = copy_bitmap(*bm_g);
 
+    assert(bm_s);
+
     shift_bitmap((*bm_s)->buffer, (*bm_s)->w,(*bm_s)->h,
                  shadow_offset.x, shadow_offset.y);
 
-    assert(bm_s);
     return 0;
 }

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_bitmap.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_bitmap.h	2010-01-08 18:55:07 UTC (rev 5831)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_bitmap.h	2010-01-09 11:03:17 UTC (rev 5832)
@@ -26,16 +26,16 @@
 
 #include "ass.h"
 
-typedef struct ass_synth_priv ass_synth_priv_t;
+typedef struct ass_synth_priv ASS_SynthPriv;
 
-ass_synth_priv_t *ass_synth_init(double);
-void ass_synth_done(ass_synth_priv_t *priv);
+ASS_SynthPriv *ass_synth_init(double);
+void ass_synth_done(ASS_SynthPriv *priv);
 
 typedef struct {
     int left, top;
     int w, h;                   // width, height
     unsigned char *buffer;      // w x h buffer
-} bitmap_t;
+} Bitmap;
 
 /**
  * \brief perform glyph rendering
@@ -46,11 +46,12 @@
  * \param bm_g out: pointer to the bitmap of glyph shadow is returned here
  * \param be 1 = produces blurred bitmaps, 0 = normal bitmaps
  */
-int glyph_to_bitmap(ass_library_t *library, ass_synth_priv_t *priv_blur,
+int glyph_to_bitmap(ASS_Library *library, ASS_SynthPriv *priv_blur,
                     FT_Glyph glyph, FT_Glyph outline_glyph,
-                    bitmap_t **bm_g, bitmap_t **bm_o, bitmap_t **bm_s,
-                    int be, double blur_radius, FT_Vector shadow_offset);
+                    Bitmap **bm_g, Bitmap **bm_o, Bitmap **bm_s,
+                    int be, double blur_radius, FT_Vector shadow_offset,
+                    int border_style);
 
-void ass_free_bitmap(bitmap_t *bm);
+void ass_free_bitmap(Bitmap *bm);
 
 #endif                          /* LIBASS_BITMAP_H */

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_cache.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_cache.c	2010-01-08 18:55:07 UTC (rev 5831)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_cache.c	2010-01-09 11:03:17 UTC (rev 5832)
@@ -51,13 +51,13 @@
     free(value);
 }
 
-hashmap_t *hashmap_init(ass_library_t *library, size_t key_size,
-                        size_t value_size, int nbuckets,
-                        hashmap_item_dtor_t item_dtor,
-                        hashmap_key_compare_t key_compare,
-                        hashmap_hash_t hash)
+Hashmap *hashmap_init(ASS_Library *library, size_t key_size,
+                      size_t value_size, int nbuckets,
+                      HashmapItemDtor item_dtor,
+                      HashmapKeyCompare key_compare,
+                      HashmapHash hash)
 {
-    hashmap_t *map = calloc(1, sizeof(hashmap_t));
+    Hashmap *map = calloc(1, sizeof(Hashmap));
     map->library = library;
     map->nbuckets = nbuckets;
     map->key_size = key_size;
@@ -69,7 +69,7 @@
     return map;
 }
 
-void hashmap_done(hashmap_t *map)
+void hashmap_done(Hashmap *map)
 {
     int i;
     // print stats
@@ -81,9 +81,9 @@
                map->miss_count, map->count);
 
     for (i = 0; i < map->nbuckets; ++i) {
-        hashmap_item_t *item = map->root[i];
+        HashmapItem *item = map->root[i];
         while (item) {
-            hashmap_item_t *next = item->next;
+            HashmapItem *next = item->next;
             map->item_dtor(item->key, map->key_size, item->value,
                            map->value_size);
             free(item);
@@ -95,17 +95,17 @@
 }
 
 // does nothing if key already exists
-void *hashmap_insert(hashmap_t *map, void *key, void *value)
+void *hashmap_insert(Hashmap *map, void *key, void *value)
 {
     unsigned hash = map->hash(key, map->key_size);
-    hashmap_item_t **next = map->root + (hash % map->nbuckets);
+    HashmapItem **next = map->root + (hash % map->nbuckets);
     while (*next) {
         if (map->key_compare(key, (*next)->key, map->key_size))
             return (*next)->value;
         next = &((*next)->next);
         assert(next);
     }
-    (*next) = malloc(sizeof(hashmap_item_t));
+    (*next) = malloc(sizeof(HashmapItem));
     (*next)->key = malloc(map->key_size);
     (*next)->value = malloc(map->value_size);
     memcpy((*next)->key, key, map->key_size);
@@ -116,10 +116,10 @@
     return (*next)->value;
 }
 
-void *hashmap_find(hashmap_t *map, void *key)
+void *hashmap_find(Hashmap *map, void *key)
 {
     unsigned hash = map->hash(key, map->key_size);
-    hashmap_item_t *item = map->root[hash % map->nbuckets];
+    HashmapItem *item = map->root[hash % map->nbuckets];
     while (item) {
         if (map->key_compare(key, item->key, map->key_size)) {
             map->hit_count++;
@@ -136,7 +136,7 @@
 
 static unsigned font_desc_hash(void *buf, size_t len)
 {
-    ass_font_desc_t *desc = buf;
+    ASS_FontDesc *desc = buf;
     unsigned hval;
     hval = fnv_32a_str(desc->family, FNV1_32A_INIT);
     hval = fnv_32a_buf(&desc->bold, sizeof(desc->bold), hval);
@@ -146,8 +146,8 @@
 
 static int font_compare(void *key1, void *key2, size_t key_size)
 {
-    ass_font_desc_t *a = key1;
-    ass_font_desc_t *b = key2;
+    ASS_FontDesc *a = key1;
+    ASS_FontDesc *b = key2;
     if (strcmp(a->family, b->family) != 0)
         return 0;
     if (a->bold != b->bold)
@@ -166,8 +166,8 @@
     free(key);
 }
 
-ass_font_t *ass_font_cache_find(hashmap_t *font_cache,
-                                ass_font_desc_t *desc)
+ASS_Font *ass_font_cache_find(Hashmap *font_cache,
+                              ASS_FontDesc *desc)
 {
     return hashmap_find(font_cache, desc);
 }
@@ -176,22 +176,22 @@
  * \brief Add a face struct to cache.
  * \param font font struct
 */
-void *ass_font_cache_add(hashmap_t *font_cache, ass_font_t *font)
+void *ass_font_cache_add(Hashmap *font_cache, ASS_Font *font)
 {
     return hashmap_insert(font_cache, &(font->desc), font);
 }
 
-hashmap_t *ass_font_cache_init(ass_library_t *library)
+Hashmap *ass_font_cache_init(ASS_Library *library)
 {
-    hashmap_t *font_cache;
-    font_cache = hashmap_init(library, sizeof(ass_font_desc_t),
-                              sizeof(ass_font_t),
+    Hashmap *font_cache;
+    font_cache = hashmap_init(library, sizeof(ASS_FontDesc),
+                              sizeof(ASS_Font),
                               1000,
                               font_hash_dtor, font_compare, font_desc_hash);
     return font_cache;
 }
 
-void ass_font_cache_done(hashmap_t *font_cache)
+void ass_font_cache_done(Hashmap *font_cache)
 {
     hashmap_done(font_cache);
 }
@@ -209,7 +209,7 @@
 static void bitmap_hash_dtor(void *key, size_t key_size, void *value,
                              size_t value_size)
 {
-    bitmap_hash_val_t *v = value;
+    BitmapHashValue *v = value;
     if (v->bm)
         ass_free_bitmap(v->bm);
     if (v->bm_o)
@@ -220,13 +220,13 @@
     free(value);
 }
 
-void *cache_add_bitmap(hashmap_t *bitmap_cache, bitmap_hash_key_t *key,
-                       bitmap_hash_val_t *val)
+void *cache_add_bitmap(Hashmap *bitmap_cache, BitmapHashKey *key,
+                       BitmapHashValue *val)
 {
     // Note: this is only an approximation
     if (val->bm_o)
         bitmap_cache->cache_size += val->bm_o->w * val->bm_o->h * 3;
-    else
+    else if (val->bm)
         bitmap_cache->cache_size += val->bm->w * val->bm->h * 3;
 
     return hashmap_insert(bitmap_cache, key, val);
@@ -237,32 +237,32 @@
  * \param key hash key
  * \return requested hash val or 0 if not found
 */
-bitmap_hash_val_t *cache_find_bitmap(hashmap_t *bitmap_cache,
-                                     bitmap_hash_key_t *key)
+BitmapHashValue *cache_find_bitmap(Hashmap *bitmap_cache,
+                                   BitmapHashKey *key)
 {
     return hashmap_find(bitmap_cache, key);
 }
 
-hashmap_t *ass_bitmap_cache_init(ass_library_t *library)
+Hashmap *ass_bitmap_cache_init(ASS_Library *library)
 {
-    hashmap_t *bitmap_cache;
+    Hashmap *bitmap_cache;
     bitmap_cache = hashmap_init(library,
-                                sizeof(bitmap_hash_key_t),
-                                sizeof(bitmap_hash_val_t),
+                                sizeof(BitmapHashKey),
+                                sizeof(BitmapHashValue),
                                 0xFFFF + 13,
                                 bitmap_hash_dtor, bitmap_compare,
                                 bitmap_hash);
     return bitmap_cache;
 }
 
-void ass_bitmap_cache_done(hashmap_t *bitmap_cache)
+void ass_bitmap_cache_done(Hashmap *bitmap_cache)
 {
     hashmap_done(bitmap_cache);
 }
 
-hashmap_t *ass_bitmap_cache_reset(hashmap_t *bitmap_cache)
+Hashmap *ass_bitmap_cache_reset(Hashmap *bitmap_cache)
 {
-    ass_library_t *lib = bitmap_cache->library;
+    ASS_Library *lib = bitmap_cache->library;
 
     ass_bitmap_cache_done(bitmap_cache);
     return ass_bitmap_cache_init(lib);
@@ -274,7 +274,7 @@
 static void glyph_hash_dtor(void *key, size_t key_size, void *value,
                             size_t value_size)
 {
-    glyph_hash_val_t *v = value;
+    GlyphHashValue *v = value;
     if (v->glyph)
         FT_Done_Glyph(v->glyph);
     if (v->outline_glyph)
@@ -283,8 +283,8 @@
     free(value);
 }
 
-void *cache_add_glyph(hashmap_t *glyph_cache, glyph_hash_key_t *key,
-                      glyph_hash_val_t *val)
+void *cache_add_glyph(Hashmap *glyph_cache, GlyphHashKey *key,
+                      GlyphHashValue *val)
 {
     return hashmap_insert(glyph_cache, key, val);
 }
@@ -294,30 +294,30 @@
  * \param key hash key
  * \return requested hash val or 0 if not found
 */
-glyph_hash_val_t *cache_find_glyph(hashmap_t *glyph_cache,
-                                   glyph_hash_key_t *key)
+GlyphHashValue *cache_find_glyph(Hashmap *glyph_cache,
+                                 GlyphHashKey *key)
 {
     return hashmap_find(glyph_cache, key);
 }
 
-hashmap_t *ass_glyph_cache_init(ass_library_t *library)
+Hashmap *ass_glyph_cache_init(ASS_Library *library)
 {
-    hashmap_t *glyph_cache;
-    glyph_cache = hashmap_init(library, sizeof(glyph_hash_key_t),
-                               sizeof(glyph_hash_val_t),
+    Hashmap *glyph_cache;
+    glyph_cache = hashmap_init(library, sizeof(GlyphHashKey),
+                               sizeof(GlyphHashValue),
                                0xFFFF + 13,
                                glyph_hash_dtor, glyph_compare, glyph_hash);
     return glyph_cache;
 }
 
-void ass_glyph_cache_done(hashmap_t *glyph_cache)
+void ass_glyph_cache_done(Hashmap *glyph_cache)
 {
     hashmap_done(glyph_cache);
 }
 
-hashmap_t *ass_glyph_cache_reset(hashmap_t *glyph_cache)
+Hashmap *ass_glyph_cache_reset(Hashmap *glyph_cache)
 {
-    ass_library_t *lib = glyph_cache->library;
+    ASS_Library *lib = glyph_cache->library;
 
     ass_glyph_cache_done(glyph_cache);
     return ass_glyph_cache_init(lib);
@@ -330,16 +330,16 @@
 static void composite_hash_dtor(void *key, size_t key_size, void *value,
                                 size_t value_size)
 {
-    composite_hash_val_t *v = value;
+    CompositeHashValue *v = value;
     free(v->a);
     free(v->b);
     free(key);
     free(value);
 }
 
-void *cache_add_composite(hashmap_t *composite_cache,
-                          composite_hash_key_t *key,
-                          composite_hash_val_t *val)
+void *cache_add_composite(Hashmap *composite_cache,
+                          CompositeHashKey *key,
+                          CompositeHashValue *val)
 {
     return hashmap_insert(composite_cache, key, val);
 }
@@ -349,31 +349,31 @@
  * \param key hash key
  * \return requested hash val or 0 if not found
 */
-composite_hash_val_t *cache_find_composite(hashmap_t *composite_cache,
-                                           composite_hash_key_t *key)
+CompositeHashValue *cache_find_composite(Hashmap *composite_cache,
+                                         CompositeHashKey *key)
 {
     return hashmap_find(composite_cache, key);
 }
 
-hashmap_t *ass_composite_cache_init(ass_library_t *library)
+Hashmap *ass_composite_cache_init(ASS_Library *library)
 {
-    hashmap_t *composite_cache;
-    composite_cache = hashmap_init(library, sizeof(composite_hash_key_t),
-                                   sizeof(composite_hash_val_t),
+    Hashmap *composite_cache;
+    composite_cache = hashmap_init(library, sizeof(CompositeHashKey),
+                                   sizeof(CompositeHashValue),
                                    0xFFFF + 13,
                                    composite_hash_dtor, composite_compare,
                                    composite_hash);
     return composite_cache;
 }
 
-void ass_composite_cache_done(hashmap_t *composite_cache)
+void ass_composite_cache_done(Hashmap *composite_cache)
 {
     hashmap_done(composite_cache);
 }
 
-hashmap_t *ass_composite_cache_reset(hashmap_t *composite_cache)
+Hashmap *ass_composite_cache_reset(Hashmap *composite_cache)
 {
-    ass_library_t *lib = composite_cache->library;
+    ASS_Library *lib = composite_cache->library;
 
     ass_composite_cache_done(composite_cache);
     return ass_composite_cache_init(lib);

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_cache.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_cache.h	2010-01-08 18:55:07 UTC (rev 5831)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_cache.h	2010-01-09 11:03:17 UTC (rev 5832)
@@ -25,79 +25,79 @@
 #include "ass_font.h"
 #include "ass_bitmap.h"
 
-typedef void (*hashmap_item_dtor_t) (void *key, size_t key_size,
-                                     void *value, size_t value_size);
-typedef int (*hashmap_key_compare_t) (void *key1, void *key2,
-                                      size_t key_size);
-typedef unsigned (*hashmap_hash_t) (void *key, size_t key_size);
+typedef void (*HashmapItemDtor) (void *key, size_t key_size,
+                                 void *value, size_t value_size);
+typedef int (*HashmapKeyCompare) (void *key1, void *key2,
+                                  size_t key_size);
+typedef unsigned (*HashmapHash) (void *key, size_t key_size);
 
 typedef struct hashmap_item {
     void *key;
     void *value;
     struct hashmap_item *next;
-} hashmap_item_t;
-typedef hashmap_item_t *hashmap_item_p;
+} HashmapItem;
+typedef HashmapItem *hashmap_item_p;
 
 typedef struct {
     int nbuckets;
     size_t key_size, value_size;
     hashmap_item_p *root;
-    hashmap_item_dtor_t item_dtor;      // a destructor for hashmap key/value pairs
-    hashmap_key_compare_t key_compare;
-    hashmap_hash_t hash;
+    HashmapItemDtor item_dtor;      // a destructor for hashmap key/value pairs
+    HashmapKeyCompare key_compare;
+    HashmapHash hash;
     size_t cache_size;
     // stats
     int hit_count;
     int miss_count;
     int count;
-    ass_library_t *library;
-} hashmap_t;
+    ASS_Library *library;
+} Hashmap;
 
-hashmap_t *hashmap_init(ass_library_t *library, size_t key_size,
-                        size_t value_size, int nbuckets,
-                        hashmap_item_dtor_t item_dtor,
-                        hashmap_key_compare_t key_compare,
-                        hashmap_hash_t hash);
-void hashmap_done(hashmap_t *map);
-void *hashmap_insert(hashmap_t *map, void *key, void *value);
-void *hashmap_find(hashmap_t *map, void *key);
+Hashmap *hashmap_init(ASS_Library *library, size_t key_size,
+                      size_t value_size, int nbuckets,
+                      HashmapItemDtor item_dtor,
+                      HashmapKeyCompare key_compare,
+                      HashmapHash hash);
+void hashmap_done(Hashmap *map);
+void *hashmap_insert(Hashmap *map, void *key, void *value);
+void *hashmap_find(Hashmap *map, void *key);
 
-hashmap_t *ass_font_cache_init(ass_library_t *library);
-ass_font_t *ass_font_cache_find(hashmap_t *, ass_font_desc_t *desc);
-void *ass_font_cache_add(hashmap_t *, ass_font_t *font);
-void ass_font_cache_done(hashmap_t *);
+Hashmap *ass_font_cache_init(ASS_Library *library);
+ASS_Font *ass_font_cache_find(Hashmap *, ASS_FontDesc *desc);
+void *ass_font_cache_add(Hashmap *, ASS_Font *font);
+void ass_font_cache_done(Hashmap *);
 
 // Create definitions for bitmap_hash_key and glyph_hash_key
 #define CREATE_STRUCT_DEFINITIONS
 #include "ass_cache_template.h"
 
 typedef struct {
-    bitmap_t *bm;               // the actual bitmaps
-    bitmap_t *bm_o;
-    bitmap_t *bm_s;
-} bitmap_hash_val_t;
+    Bitmap *bm;               // the actual bitmaps
+    Bitmap *bm_o;
+    Bitmap *bm_s;
+} BitmapHashValue;
 
-hashmap_t *ass_bitmap_cache_init(ass_library_t *library);
-void *cache_add_bitmap(hashmap_t *, bitmap_hash_key_t *key,
-                       bitmap_hash_val_t *val);
-bitmap_hash_val_t *cache_find_bitmap(hashmap_t *bitmap_cache,
-                                     bitmap_hash_key_t *key);
-hashmap_t *ass_bitmap_cache_reset(hashmap_t *bitmap_cache);
-void ass_bitmap_cache_done(hashmap_t *bitmap_cache);
+Hashmap *ass_bitmap_cache_init(ASS_Library *library);
+void *cache_add_bitmap(Hashmap *, BitmapHashKey *key,
+                       BitmapHashValue *val);
+BitmapHashValue *cache_find_bitmap(Hashmap *bitmap_cache,
+                                   BitmapHashKey *key);
+Hashmap *ass_bitmap_cache_reset(Hashmap *bitmap_cache);
+void ass_bitmap_cache_done(Hashmap *bitmap_cache);
 
 
 typedef struct {
     unsigned char *a;
     unsigned char *b;
-} composite_hash_val_t;
+} CompositeHashValue;
 
-hashmap_t *ass_composite_cache_init(ass_library_t *library);
-void *cache_add_composite(hashmap_t *, composite_hash_key_t *key,
-                          composite_hash_val_t *val);
-composite_hash_val_t *cache_find_composite(hashmap_t *composite_cache,
-                                           composite_hash_key_t *key);
-hashmap_t *ass_composite_cache_reset(hashmap_t *composite_cache);
-void ass_composite_cache_done(hashmap_t *composite_cache);
+Hashmap *ass_composite_cache_init(ASS_Library *library);
+void *cache_add_composite(Hashmap *, CompositeHashKey *key,
+                          CompositeHashValue *val);
+CompositeHashValue *cache_find_composite(Hashmap *composite_cache,
+                                         CompositeHashKey *key);
+Hashmap *ass_composite_cache_reset(Hashmap *composite_cache);
+void ass_composite_cache_done(Hashmap *composite_cache);
 
 
 typedef struct {
@@ -106,14 +106,14 @@
     FT_BBox bbox_scaled;        // bbox after scaling, but before rotation
     FT_Vector advance;          // 26.6, advance distance to the next bitmap in line
     int asc, desc;              // ascender/descender of a drawing
-} glyph_hash_val_t;
+} GlyphHashValue;
 
-hashmap_t *ass_glyph_cache_init(ass_library_t *library);
-void *cache_add_glyph(hashmap_t *, glyph_hash_key_t *key,
-                      glyph_hash_val_t *val);
-glyph_hash_val_t *cache_find_glyph(hashmap_t *glyph_cache,
-                                   glyph_hash_key_t *key);
-hashmap_t *ass_glyph_cache_reset(hashmap_t *glyph_cache);
-void ass_glyph_cache_done(hashmap_t *glyph_cache);
+Hashmap *ass_glyph_cache_init(ASS_Library *library);
+void *cache_add_glyph(Hashmap *, GlyphHashKey *key,
+                      GlyphHashValue *val);
+GlyphHashValue *cache_find_glyph(Hashmap *glyph_cache,
+                                 GlyphHashKey *key);
+Hashmap *ass_glyph_cache_reset(Hashmap *glyph_cache);
+void ass_glyph_cache_done(Hashmap *glyph_cache);
 
 #endif                          /* LIBASS_CACHE_H */

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_cache_template.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_cache_template.h	2010-01-08 18:55:07 UTC (rev 5831)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_cache_template.h	2010-01-09 11:03:17 UTC (rev 5832)
@@ -7,7 +7,7 @@
 #define FTVECTOR(member) \
         FT_Vector member;
 #define BITMAPHASHKEY(member) \
-        bitmap_hash_key_t member;
+        BitmapHashKey member;
 #define END(typedefnamename) \
     } typedefnamename;
 
@@ -54,9 +54,9 @@
 
 
 // describes a bitmap; bitmaps with equivalents structs are considered identical
-START(bitmap, bipmap_hash_key)
+START(bitmap, bitmap_hash_key)
     GENERIC(char, bitmap) // bool : true = bitmap, false = outline
-    GENERIC(ass_font_t *, font)
+    GENERIC(ASS_Font *, font)
     GENERIC(double, size) // font size
     GENERIC(uint32_t, ch) // character code
     FTVECTOR(outline) // border width, 16.16 fixed point value
@@ -79,11 +79,13 @@
     FTVECTOR(advance) // subpixel shift vector
     FTVECTOR(shadow_offset) // shadow subpixel shift
     GENERIC(unsigned, drawing_hash) // hashcode of a drawing
-END(bitmap_hash_key_t)
+    GENERIC(unsigned, flags)    // glyph decoration
+    GENERIC(unsigned, border_style)
+END(BitmapHashKey)
 
 // describes an outline glyph
 START(glyph, glyph_hash_key)
-    GENERIC(ass_font_t *, font)
+    GENERIC(ASS_Font *, font)
     GENERIC(double, size) // font size
     GENERIC(uint32_t, ch) // character code
     GENERIC(int, bold)
@@ -93,7 +95,8 @@
     FTVECTOR(outline) // border width, 16.16
     GENERIC(unsigned, drawing_hash) // hashcode of a drawing
     GENERIC(unsigned, flags)    // glyph decoration flags
-END(glyph_hash_key_t)
+    GENERIC(unsigned, border_style)
+END(GlyphHashKey)
 
 // Cache for composited bitmaps
 START(composite, composite_hash_key)
@@ -105,9 +108,11 @@
     GENERIC(int, ay)
     GENERIC(int, bx)
     GENERIC(int, by)
-    BITMAPHASHKEY(a)
-    BITMAPHASHKEY(b)
-END(composite_hash_key_t)
+    GENERIC(int, as)
+    GENERIC(int, bs)
+    GENERIC(unsigned char *, a)
+    GENERIC(unsigned char *, b)
+END(CompositeHashKey)
 
 
 #undef START

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_drawing.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_drawing.c	2010-01-08 18:55:07 UTC (rev 5831)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_drawing.c	2010-01-09 11:03:17 UTC (rev 5832)
@@ -33,29 +33,30 @@
 /*
  * \brief Get and prepare a FreeType glyph
  */
-static void drawing_make_glyph(ass_drawing_t *drawing, void *fontconfig_priv,
-                               ass_font_t *font, ass_hinting_t hint)
+static void drawing_make_glyph(ASS_Drawing *drawing, void *fontconfig_priv,
+                               ASS_Font *font, ASS_Hinting hint)
 {
     FT_OutlineGlyph glyph;
 
     // This is hacky...
     glyph = (FT_OutlineGlyph) ass_font_get_glyph(fontconfig_priv, font,
                                                  (uint32_t) ' ', hint, 0);
+    if (glyph) {
+        FT_Outline_Done(drawing->ftlibrary, &glyph->outline);
+        FT_Outline_New(drawing->ftlibrary, GLYPH_INITIAL_POINTS,
+                       GLYPH_INITIAL_CONTOURS, &glyph->outline);
 
-    FT_Outline_Done(drawing->ftlibrary, &glyph->outline);
-    FT_Outline_New(drawing->ftlibrary, GLYPH_INITIAL_POINTS,
-                   GLYPH_INITIAL_CONTOURS, &glyph->outline);
-
-    glyph->outline.n_contours = 0;
-    glyph->outline.n_points = 0;
-    glyph->root.advance.x = glyph->root.advance.y = 0;
+        glyph->outline.n_contours = 0;
+        glyph->outline.n_points = 0;
+        glyph->root.advance.x = glyph->root.advance.y = 0;
+    }
     drawing->glyph = glyph;
 }
 
 /*
  * \brief Add a single point to a contour.
  */
-static inline void drawing_add_point(ass_drawing_t *drawing,
+static inline void drawing_add_point(ASS_Drawing *drawing,
                                      FT_Vector *point)
 {
     FT_Outline *ol = &drawing->glyph->outline;
@@ -76,7 +77,7 @@
 /*
  * \brief Close a contour and check glyph size overflow.
  */
-static inline void drawing_close_shape(ass_drawing_t *drawing)
+static inline void drawing_close_shape(ASS_Drawing *drawing)
 {
     FT_Outline *ol = &drawing->glyph->outline;
 
@@ -86,14 +87,16 @@
                                drawing->max_contours);
     }
 
-    ol->contours[ol->n_contours] = ol->n_points - 1;
-    ol->n_contours++;
+    if (ol->n_points) {
+        ol->contours[ol->n_contours] = ol->n_points - 1;
+        ol->n_contours++;
+    }
 }
 
 /*
  * \brief Prepare drawing for parsing.  This just sets a few parameters.
  */
-static void drawing_prepare(ass_drawing_t *drawing)
+static void drawing_prepare(ASS_Drawing *drawing)
 {
     // Scaling parameters
     drawing->point_scale_x = drawing->scale_x *
@@ -106,7 +109,7 @@
  * \brief Finish a drawing.  This only sets the horizontal advance according
  * to the glyph's bbox at the moment.
  */
-static void drawing_finish(ass_drawing_t *drawing, int raw_mode)
+static void drawing_finish(ASS_Drawing *drawing, int raw_mode)
 {
     int i, offset;
     FT_BBox bbox;
@@ -150,7 +153,7 @@
 /*
  * \brief Check whether a number of items on the list is available
  */
-static int token_check_values(ass_drawing_token_t *token, int i, int type)
+static int token_check_values(ASS_DrawingToken *token, int i, int type)
 {
     int j;
     for (j = 0; j < i; j++) {
@@ -162,16 +165,16 @@
 }
 
 /*
- * \brief Tokenize a drawing string into a list of ass_drawing_token_t
+ * \brief Tokenize a drawing string into a list of ASS_DrawingToken
  * This also expands points for closing b-splines
  */
-static ass_drawing_token_t *drawing_tokenize(char *str)
+static ASS_DrawingToken *drawing_tokenize(char *str)
 {
     char *p = str;
     int i, val, type = -1, is_set = 0;
     FT_Vector point = {0, 0};
 
-    ass_drawing_token_t *root = NULL, *tail = NULL, *spline_start = NULL;
+    ASS_DrawingToken *root = NULL, *tail = NULL, *spline_start = NULL;
 
     while (*p) {
         if (*p == 'c' && spline_start) {
@@ -179,7 +182,7 @@
             // back to the end
             if (token_check_values(spline_start->next, 2, TOKEN_B_SPLINE)) {
                 for (i = 0; i < 3; i++) {
-                    tail->next = calloc(1, sizeof(ass_drawing_token_t));
+                    tail->next = calloc(1, sizeof(ASS_DrawingToken));
                     tail->next->prev = tail;
                     tail = tail->next;
                     tail->type = TOKEN_B_SPLINE;
@@ -214,11 +217,11 @@
 
         if (type != -1 && is_set == 2) {
             if (root) {
-                tail->next = calloc(1, sizeof(ass_drawing_token_t));
+                tail->next = calloc(1, sizeof(ASS_DrawingToken));
                 tail->next->prev = tail;
                 tail = tail->next;
             } else
-                root = tail = calloc(1, sizeof(ass_drawing_token_t));
+                root = tail = calloc(1, sizeof(ASS_DrawingToken));
             tail->type = type;
             tail->point = point;
             is_set = 0;
@@ -230,7 +233,7 @@
 
 #if 0
     // Check tokens
-    ass_drawing_token_t *t = root;
+    ASS_DrawingToken *t = root;
     while(t) {
         printf("token %d point (%d, %d)\n", t->type, t->point.x, t->point.y);
         t = t->next;
@@ -243,10 +246,10 @@
 /*
  * \brief Free a list of tokens
  */
-static void drawing_free_tokens(ass_drawing_token_t *token)
+static void drawing_free_tokens(ASS_DrawingToken *token)
 {
     while (token) {
-        ass_drawing_token_t *at = token;
+        ASS_DrawingToken *at = token;
         token = token->next;
         free(at);
     }
@@ -256,7 +259,7 @@
  * \brief Translate and scale a point coordinate according to baseline
  * offset and scale.
  */
-static inline void translate_point(ass_drawing_t *drawing, FT_Vector *point)
+static inline void translate_point(ASS_Drawing *drawing, FT_Vector *point)
 {
     point->x = drawing->point_scale_x * point->x;
     point->y = drawing->point_scale_y * -point->y;
@@ -267,8 +270,8 @@
  * This curve evaluator is also used in VSFilter (RTS.cpp); it's a simple
  * implementation of the De Casteljau algorithm.
  */
-static void drawing_evaluate_curve(ass_drawing_t *drawing,
-                                   ass_drawing_token_t *token, char spline,
+static void drawing_evaluate_curve(ASS_Drawing *drawing,
+                                   ASS_DrawingToken *token, char spline,
                                    int started)
 {
     double cx3, cx2, cx1, cx0, cy3, cy2, cy1, cy0;
@@ -358,18 +361,20 @@
 /*
  * \brief Create and initialize a new drawing and return it
  */
-ass_drawing_t *ass_drawing_new(void *fontconfig_priv, ass_font_t *font,
-                               ass_hinting_t hint, FT_Library lib)
+ASS_Drawing *ass_drawing_new(void *fontconfig_priv, ASS_Font *font,
+                             ASS_Hinting hint, FT_Library lib)
 {
-    ass_drawing_t* drawing;
+    ASS_Drawing *drawing;
 
     drawing = calloc(1, sizeof(*drawing));
     drawing->text = calloc(1, DRAWING_INITIAL_SIZE);
     drawing->size = DRAWING_INITIAL_SIZE;
 
     drawing->ftlibrary = lib;
-    drawing->library = font->library;
-    drawing_make_glyph(drawing, fontconfig_priv, font, hint);
+    if (font) {
+        drawing->library = font->library;
+        drawing_make_glyph(drawing, fontconfig_priv, font, hint);
+    }
 
     drawing->scale_x = 1.;
     drawing->scale_y = 1.;
@@ -382,17 +387,20 @@
 /*
  * \brief Free a drawing
  */
-void ass_drawing_free(ass_drawing_t* drawing)
+void ass_drawing_free(ASS_Drawing* drawing)
 {
-    FT_Done_Glyph((FT_Glyph) drawing->glyph);
-    free(drawing->text);
+    if (drawing) {
+        if (drawing->glyph)
+            FT_Done_Glyph((FT_Glyph) drawing->glyph);
+        free(drawing->text);
+    }
     free(drawing);
 }
 
 /*
  * \brief Add one ASCII character to the drawing text buffer
  */
-void ass_drawing_add_char(ass_drawing_t* drawing, char symbol)
+void ass_drawing_add_char(ASS_Drawing* drawing, char symbol)
 {
     drawing->text[drawing->i++] = symbol;
     drawing->text[drawing->i] = 0;
@@ -407,7 +415,7 @@
  * \brief Create a hashcode for the drawing
  * XXX: To avoid collisions a better hash algorithm might be useful.
  */
-void ass_drawing_hash(ass_drawing_t* drawing)
+void ass_drawing_hash(ASS_Drawing* drawing)
 {
     drawing->hash = fnv_32a_str(drawing->text, FNV1_32A_INIT);
 }
@@ -415,12 +423,15 @@
 /*
  * \brief Convert token list to outline.  Calls the line and curve evaluators.
  */
-FT_OutlineGlyph *ass_drawing_parse(ass_drawing_t *drawing, int raw_mode)
+FT_OutlineGlyph *ass_drawing_parse(ASS_Drawing *drawing, int raw_mode)
 {
     int started = 0;
-    ass_drawing_token_t *token;
+    ASS_DrawingToken *token;
     FT_Vector pen = {0, 0};
 
+    if (!drawing->glyph)
+        return NULL;
+
     drawing->tokens = drawing_tokenize(drawing->text);
     drawing_prepare(drawing);
 

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_drawing.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_drawing.h	2010-01-08 18:55:07 UTC (rev 5831)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_drawing.h	2010-01-09 11:03:17 UTC (rev 5832)
@@ -35,14 +35,14 @@
     TOKEN_B_SPLINE,
     TOKEN_EXTEND_SPLINE,
     TOKEN_CLOSE
-} ass_token_type_t;
+} ASS_TokenType;
 
 typedef struct ass_drawing_token {
-    ass_token_type_t type;
+    ASS_TokenType type;
     FT_Vector point;
     struct ass_drawing_token *next;
     struct ass_drawing_token *prev;
-} ass_drawing_token_t;
+} ASS_DrawingToken;
 
 typedef struct {
     char *text; // drawing string
@@ -58,20 +58,20 @@
 
     // private
     FT_Library ftlibrary;   // FT library instance, needed for font ops
-    ass_library_t *library;
+    ASS_Library *library;
     int size;           // current buffer size
-    ass_drawing_token_t *tokens;    // tokenized drawing
+    ASS_DrawingToken *tokens;    // tokenized drawing
     int max_points;     // current maximum size
     int max_contours;
     double point_scale_x;
     double point_scale_y;
-} ass_drawing_t;
+} ASS_Drawing;
 
-ass_drawing_t *ass_drawing_new(void *fontconfig_priv, ass_font_t *font,
-                               ass_hinting_t hint, FT_Library lib);
-void ass_drawing_free(ass_drawing_t* drawing);
-void ass_drawing_add_char(ass_drawing_t* drawing, char symbol);
-void ass_drawing_hash(ass_drawing_t* drawing);
-FT_OutlineGlyph *ass_drawing_parse(ass_drawing_t *drawing, int raw_mode);
+ASS_Drawing *ass_drawing_new(void *fontconfig_priv, ASS_Font *font,
+                             ASS_Hinting hint, FT_Library lib);
+void ass_drawing_free(ASS_Drawing* drawing);
+void ass_drawing_add_char(ASS_Drawing* drawing, char symbol);
+void ass_drawing_hash(ASS_Drawing* drawing);
+FT_OutlineGlyph *ass_drawing_parse(ASS_Drawing *drawing, int raw_mode);
 
 #endif /* LIBASS_DRAWING_H */

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_font.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_font.c	2010-01-08 18:55:07 UTC (rev 5831)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_font.c	2010-01-09 11:03:17 UTC (rev 5832)
@@ -26,6 +26,7 @@
 #include FT_SYNTHESIS_H
 #include FT_GLYPH_H
 #include FT_TRUETYPE_TABLES_H
+#include FT_OUTLINE_H
 
 #include "ass.h"
 #include "ass_library.h"
@@ -39,7 +40,7 @@
  * Select Microfost Unicode CharMap, if the font has one.
  * Otherwise, let FreeType decide.
  */
-static void charmap_magic(ass_library_t *library, FT_Face face)
+static void charmap_magic(ASS_Library *library, FT_Face face)
 {
     int i;
     for (i = 0; i < face->num_charmaps; ++i) {
@@ -66,7 +67,7 @@
     }
 }
 
-static void update_transform(ass_font_t *font)
+static void update_transform(ASS_Font *font)
 {
     int i;
     FT_Matrix m;
@@ -80,7 +81,7 @@
 /**
  * \brief find a memory font by name
  */
-static int find_font(ass_library_t *library, char *name)
+static int find_font(ASS_Library *library, char *name)
 {
     int i;
     for (i = 0; i < library->num_fontdata; ++i)
@@ -111,10 +112,10 @@
 }
 
 /**
- * \brief Select a face with the given charcode and add it to ass_font_t
+ * \brief Select a face with the given charcode and add it to ASS_Font
  * \return index of the new face in font->faces, -1 if failed
  */
-static int add_face(void *fc_priv, ass_font_t *font, uint32_t ch)
+static int add_face(void *fc_priv, ASS_Font *font, uint32_t ch)
 {
     char *path;
     int index;
@@ -166,17 +167,17 @@
 }
 
 /**
- * \brief Create a new ass_font_t according to "desc" argument
+ * \brief Create a new ASS_Font according to "desc" argument
  */
-ass_font_t *ass_font_new(void *font_cache, ass_library_t *library,
-                         FT_Library ftlibrary, void *fc_priv,
-                         ass_font_desc_t *desc)
+ASS_Font *ass_font_new(void *font_cache, ASS_Library *library,
+                       FT_Library ftlibrary, void *fc_priv,
+                       ASS_FontDesc *desc)
 {
     int error;
-    ass_font_t *fontp;
-    ass_font_t font;
+    ASS_Font *fontp;
+    ASS_Font font;
 
-    fontp = ass_font_cache_find((hashmap_t *) font_cache, desc);
+    fontp = ass_font_cache_find((Hashmap *) font_cache, desc);
     if (fontp)
         return fontp;
 
@@ -197,13 +198,13 @@
         free(font.desc.family);
         return 0;
     } else
-        return ass_font_cache_add((hashmap_t *) font_cache, &font);
+        return ass_font_cache_add((Hashmap *) font_cache, &font);
 }
 
 /**
  * \brief Set font transformation matrix and shift vector
  **/
-void ass_font_set_transform(ass_font_t *font, double scale_x,
+void ass_font_set_transform(ASS_Font *font, double scale_x,
                             double scale_y, FT_Vector *v)
 {
     font->scale_x = scale_x;
@@ -217,7 +218,6 @@
 
 static void face_set_size(FT_Face face, double size)
 {
-#if (FREETYPE_MAJOR > 2) || ((FREETYPE_MAJOR == 2) && (FREETYPE_MINOR > 1))
     TT_HoriHeader *hori = FT_Get_Sfnt_Table(face, ft_sfnt_hhea);
     TT_OS2 *os2 = FT_Get_Sfnt_Table(face, ft_sfnt_os2);
     double mscale = 1.;
@@ -240,15 +240,12 @@
     m->ascender /= mscale;
     m->descender /= mscale;
     m->height /= mscale;
-#else
-    FT_Set_Char_Size(face, 0, double_to_d6(size), 0, 0);
-#endif
 }
 
 /**
  * \brief Set font size
  **/
-void ass_font_set_size(ass_font_t *font, double size)
+void ass_font_set_size(ASS_Font *font, double size)
 {
     int i;
     if (font->size != size) {
@@ -263,7 +260,7 @@
  * \param ch character code
  * The values are extracted from the font face that provides glyphs for the given character
  **/
-void ass_font_get_asc_desc(ass_font_t *font, uint32_t ch, int *asc,
+void ass_font_get_asc_desc(ASS_Font *font, uint32_t ch, int *asc,
                            int *desc)
 {
     int i;
@@ -293,14 +290,17 @@
  * being accurate.
  *
  */
-static int ass_strike_outline_glyph(FT_Face face, ass_font_t *font,
+static int ass_strike_outline_glyph(FT_Face face, ASS_Font *font,
                                     FT_Glyph glyph, int under, int through)
 {
     TT_OS2 *os2 = FT_Get_Sfnt_Table(face, ft_sfnt_os2);
     TT_Postscript *ps = FT_Get_Sfnt_Table(face, ft_sfnt_post);
     FT_Outline *ol = &((FT_OutlineGlyph) glyph)->outline;
-    int bear, advance, y_scale, i;
+    int bear, advance, y_scale, i, dir;
 
+    if (!under && !through)
+        return 0;
+
     // Grow outline
     i = (under ? 4 : 0) + (through ? 4 : 0);
     ol->points = realloc(ol->points, sizeof(FT_Vector) *
@@ -317,6 +317,9 @@
     advance = d16_to_d6(glyph->advance.x) + 32;
     y_scale = face->size->metrics.y_scale;
 
+    // Reverse drawing direction for non-truetype fonts
+    dir = FT_Outline_Get_Orientation(ol);
+
     // Add points to the outline
     if (under && ps) {
         int pos, size;
@@ -325,7 +328,7 @@
                          y_scale * font->scale_y / 2);
 
         if (pos > 0 || size <= 0)
-            return 0;
+            return 1;
 
         FT_Vector points[4] = {
             {.x = bear,      .y = pos + size},
@@ -334,10 +337,18 @@
             {.x = bear,      .y = pos - size},
         };
 
-        for (i = 0; i < 4; i++) {
-            ol->points[ol->n_points] = points[i];
-            ol->tags[ol->n_points++] = 1;
+        if (dir == FT_ORIENTATION_TRUETYPE) {
+            for (i = 0; i < 4; i++) {
+                ol->points[ol->n_points] = points[i];
+                ol->tags[ol->n_points++] = 1;
+            }
+        } else {
+            for (i = 3; i >= 0; i--) {
+                ol->points[ol->n_points] = points[i];
+                ol->tags[ol->n_points++] = 1;
+            }
         }
+
         ol->contours[ol->n_contours++] = ol->n_points - 1;
     }
 
@@ -347,7 +358,7 @@
         size = FT_MulFix(os2->yStrikeoutSize, y_scale * font->scale_y / 2);
 
         if (pos < 0 || size <= 0)
-            return 0;
+            return 1;
 
         FT_Vector points[4] = {
             {.x = bear,      .y = pos + size},
@@ -356,23 +367,46 @@
             {.x = bear,      .y = pos - size},
         };
 
-        for (i = 0; i < 4; i++) {
-            ol->points[ol->n_points] = points[i];
-            ol->tags[ol->n_points++] = 1;
+        if (dir == FT_ORIENTATION_TRUETYPE) {
+            for (i = 0; i < 4; i++) {
+                ol->points[ol->n_points] = points[i];
+                ol->tags[ol->n_points++] = 1;
+            }
+        } else {
+            for (i = 3; i >= 0; i--) {
+                ol->points[ol->n_points] = points[i];
+                ol->tags[ol->n_points++] = 1;
+            }
         }
 
         ol->contours[ol->n_contours++] = ol->n_points - 1;
     }
 
-    return 1;
+    return 0;
 }
 
 /**
+ * Slightly embold a glyph without touching its metrics
+ */
+static void ass_glyph_embolden(FT_GlyphSlot slot)
+{
+    int str;
+
+    if (slot->format != FT_GLYPH_FORMAT_OUTLINE)
+        return;
+
+    str = FT_MulFix(slot->face->units_per_EM,
+                    slot->face->size->metrics.y_scale) / 64;
+
+    FT_Outline_Embolden(&slot->outline, str);
+}
+
+/**
  * \brief Get a glyph
  * \param ch character code
  **/
-FT_Glyph ass_font_get_glyph(void *fontconfig_priv, ass_font_t *font,
-                            uint32_t ch, ass_hinting_t hinting, int deco)
+FT_Glyph ass_font_get_glyph(void *fontconfig_priv, ASS_Font *font,
+                            uint32_t ch, ASS_Hinting hinting, int deco)
 {
     int error;
     int index = 0;
@@ -383,6 +417,9 @@
 
     if (ch < 0x20)
         return 0;
+    // Handle NBSP like a regular space when rendering the glyph
+    if (ch == 0xa0)
+        ch = ' ';
     if (font->n_faces == 0)
         return 0;
 
@@ -435,15 +472,15 @@
                 index);
         return 0;
     }
-#if (FREETYPE_MAJOR > 2) || \
-    ((FREETYPE_MAJOR == 2) && (FREETYPE_MINOR >= 2)) || \
-    ((FREETYPE_MAJOR == 2) && (FREETYPE_MINOR == 1) && (FREETYPE_PATCH >= 10))
-// FreeType >= 2.1.10 required
     if (!(face->style_flags & FT_STYLE_FLAG_ITALIC) &&
         (font->desc.italic > 55)) {
         FT_GlyphSlot_Oblique(face->glyph);
     }
-#endif
+
+    if (!(face->style_flags & FT_STYLE_FLAG_BOLD) &&
+        (font->desc.bold > 80)) {
+        ass_glyph_embolden(face->glyph);
+    }
     error = FT_Get_Glyph(face->glyph, &glyph);
     if (error) {
         ass_msg(font->library, MSGL_WARN, "Error loading glyph, index %d",
@@ -460,7 +497,7 @@
 /**
  * \brief Get kerning for the pair of glyphs.
  **/
-FT_Vector ass_font_get_kerning(ass_font_t *font, uint32_t c1, uint32_t c2)
+FT_Vector ass_font_get_kerning(ASS_Font *font, uint32_t c1, uint32_t c2)
 {
     FT_Vector v = { 0, 0 };
     int i;
@@ -481,9 +518,9 @@
 }
 
 /**
- * \brief Deallocate ass_font_t
+ * \brief Deallocate ASS_Font
  **/
-void ass_font_free(ass_font_t *font)
+void ass_font_free(ASS_Font *font)
 {
     int i;
     for (i = 0; i < font->n_faces; ++i)

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_font.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_font.h	2010-01-08 18:55:07 UTC (rev 5831)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_font.h	2010-01-09 11:03:17 UTC (rev 5832)
@@ -36,31 +36,31 @@
     unsigned bold;
     unsigned italic;
     int treat_family_as_pattern;
-} ass_font_desc_t;
+} ASS_FontDesc;
 
 typedef struct {
-    ass_font_desc_t desc;
-    ass_library_t *library;
+    ASS_FontDesc desc;
+    ASS_Library *library;
     FT_Library ftlibrary;
     FT_Face faces[ASS_FONT_MAX_FACES];
     int n_faces;
     double scale_x, scale_y;    // current transform
     FT_Vector v;                // current shift
     double size;
-} ass_font_t;
+} ASS_Font;
 
 // FIXME: passing the hashmap via a void pointer is very ugly.
-ass_font_t *ass_font_new(void *font_cache, ass_library_t *library,
-                         FT_Library ftlibrary, void *fc_priv,
-                         ass_font_desc_t *desc);
-void ass_font_set_transform(ass_font_t *font, double scale_x,
+ASS_Font *ass_font_new(void *font_cache, ASS_Library *library,
+                       FT_Library ftlibrary, void *fc_priv,
+                       ASS_FontDesc *desc);
+void ass_font_set_transform(ASS_Font *font, double scale_x,
                             double scale_y, FT_Vector *v);
-void ass_font_set_size(ass_font_t *font, double size);
-void ass_font_get_asc_desc(ass_font_t *font, uint32_t ch, int *asc,
+void ass_font_set_size(ASS_Font *font, double size);
+void ass_font_get_asc_desc(ASS_Font *font, uint32_t ch, int *asc,
                            int *desc);
-FT_Glyph ass_font_get_glyph(void *fontconfig_priv, ass_font_t *font,
-                            uint32_t ch, ass_hinting_t hinting, int flags);
-FT_Vector ass_font_get_kerning(ass_font_t *font, uint32_t c1, uint32_t c2);
-void ass_font_free(ass_font_t *font);
+FT_Glyph ass_font_get_glyph(void *fontconfig_priv, ASS_Font *font,
+                            uint32_t ch, ASS_Hinting hinting, int flags);
+FT_Vector ass_font_get_kerning(ASS_Font *font, uint32_t c1, uint32_t c2);
+void ass_font_free(ASS_Font *font);
 
 #endif                          /* LIBASS_FONT_H */

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_fontconfig.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_fontconfig.c	2010-01-08 18:55:07 UTC (rev 5831)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_fontconfig.c	2010-01-09 11:03:17 UTC (rev 5832)
@@ -51,15 +51,6 @@
 
 #ifdef CONFIG_FONTCONFIG
 
-// 4yo fontconfig does not have these.
-// They are only needed for debug output, anyway.
-#ifndef FC_FULLNAME
-#define FC_FULLNAME "fullname"
-#endif
-#ifndef FC_EMBOLDEN
-#define FC_EMBOLDEN "embolden"
-#endif
-
 /**
  * \brief Low-level font selection.
  * \param priv private data
@@ -71,7 +62,7 @@
  * \param code: the character that should be present in the font, can be 0
  * \return font file path
 */
-static char *_select_font(ass_library_t *library, fc_instance_t *priv,
+static char *_select_font(ASS_Library *library, FCInstance *priv,
                           const char *family, int treat_family_as_pattern,
                           unsigned bold, unsigned italic, int *index,
                           uint32_t code)
@@ -159,7 +150,6 @@
     if (curf >= fset->nfont)
         goto error;
 
-#if (FC_VERSION >= 20297)
     if (!treat_family_as_pattern) {
         // Remove all extra family names from original pattern.
         // After this, FcFontRenderPrepare will select the most relevant family
@@ -167,7 +157,6 @@
         for (; family_cnt > 1; --family_cnt)
             FcPatternRemove(pat, FC_FAMILY, family_cnt - 1);
     }
-#endif
 
     rpat = FcFontRenderPrepare(priv->config, pat, fset->fonts[curf]);
     if (!rpat)
@@ -242,7 +231,7 @@
  * \param code: the character that should be present in the font, can be 0
  * \return font file path
 */
-char *fontconfig_select(ass_library_t *library, fc_instance_t *priv,
+char *fontconfig_select(ASS_Library *library, FCInstance *priv,
                         const char *family, int treat_family_as_pattern,
                         unsigned bold, unsigned italic, int *index,
                         uint32_t code)
@@ -250,7 +239,8 @@
     char *res = 0;
     if (!priv->config) {
         *index = priv->index_default;
-        return priv->path_default;
+        res = priv->path_default ? strdup(priv->path_default) : 0;
+        return res;
     }
     if (family && *family)
         res =
@@ -266,7 +256,7 @@
                     family, bold, italic, res, *index);
     }
     if (!res && priv->path_default) {
-        res = priv->path_default;
+        res = strdup(priv->path_default);
         *index = priv->index_default;
         ass_msg(library, MSGL_WARN, "fontconfig_select: Using default font: "
                 "(%s, %d, %d) -> %s, %d", family, bold, italic,
@@ -287,41 +277,6 @@
     return res;
 }
 
-#if (FC_VERSION < 20402)
-static char *validate_fname(char *name)
-{
-    char *fname;
-    char *p;
-    char *q;
-    unsigned code;
-    int sz = strlen(name);
-
-    q = fname = malloc(sz + 1);
-    p = name;
-    while (*p) {
-        code = ass_utf8_get_char(&p);
-        if (code == 0)
-            break;
-        if ((code > 0x7F) ||
-            (code == '\\') ||
-            (code == '/') ||
-            (code == ':') ||
-            (code == '*') ||
-            (code == '?') ||
-            (code == '<') ||
-            (code == '>') || (code == '|') || (code == 0)) {
-            *q++ = '_';
-        } else {
-            *q++ = code;
-        }
-        if (p - name > sz)
-            break;
-    }
-    *q = 0;
-    return fname;
-}
-#endif
-
 /**
  * \brief Process memory font.
  * \param priv private data
@@ -331,7 +286,7 @@
  * With FontConfig >= 2.4.2, builds a font pattern in memory via FT_New_Memory_Face/FcFreeTypeQueryFace.
  * With older FontConfig versions, save the font to ~/.mplayer/fonts.
 */
-static void process_fontdata(fc_instance_t *priv, ass_library_t *library,
+static void process_fontdata(FCInstance *priv, ASS_Library *library,
                              FT_Library ftlibrary, int idx)
 {
     int rc;
@@ -339,44 +294,6 @@
     const char *data = library->fontdata[idx].data;
     int data_size = library->fontdata[idx].size;
 
-#if (FC_VERSION < 20402)
-    struct stat st;
-    char *fname;
-    const char *fonts_dir = library->fonts_dir;
-    char buf[1000];
-    FILE *fp = NULL;
-
-    if (!fonts_dir)
-        return;
-    rc = stat(fonts_dir, &st);
-    if (rc) {
-        int res;
-#ifndef __MINGW32__
-        res = mkdir(fonts_dir, 0700);
-#else
-        res = mkdir(fonts_dir);
-#endif
-        if (res) {
-            ass_msg(library, MSGL_WARN, "Failed to create directory '%s'",
-                    fonts_dir);
-        }
-    } else if (!S_ISDIR(st.st_mode)) {
-        ass_msg(library, MSGL_WARN, "Not a directory: '%s'", fonts_dir);
-    }
-
-    fname = validate_fname((char *) name);
-
-    snprintf(buf, 1000, "%s/%s", fonts_dir, fname);
-    free(fname);
-
-    fp = fopen(buf, "wb");
-    if (!fp)
-        return;
-
-    fwrite(data, data_size, 1, fp);
-    fclose(fp);
-
-#else                           // (FC_VERSION >= 20402)
     FT_Face face;
     FcPattern *pattern;
     FcFontSet *fset;
@@ -418,7 +335,6 @@
 
         FT_Done_Face(face);
     }
-#endif
 }
 
 /**
@@ -432,13 +348,13 @@
  * \param update whether the fontconfig cache should be built/updated
  * \return pointer to fontconfig private data
 */
-fc_instance_t *fontconfig_init(ass_library_t *library,
-                               FT_Library ftlibrary, const char *family,
-                               const char *path, int fc, const char *config,
-                               int update)
+FCInstance *fontconfig_init(ASS_Library *library,
+                            FT_Library ftlibrary, const char *family,
+                            const char *path, int fc, const char *config,
+                            int update)
 {
     int rc;
-    fc_instance_t *priv = calloc(1, sizeof(fc_instance_t));
+    FCInstance *priv = calloc(1, sizeof(FCInstance));
     const char *dir = library->fonts_dir;
     int i;
 
@@ -472,41 +388,8 @@
         process_fontdata(priv, library, ftlibrary, i);
 
     if (dir) {
-        if (FcDirCacheValid((const FcChar8 *) dir) == FcFalse) {
-            ass_msg(library, MSGL_INFO, "Updating font cache");
-            if (FcGetVersion() >= 20390 && FcGetVersion() < 20400)
-                ass_msg(library, MSGL_WARN, "Beta versions of fontconfig"
-                        "are not supported. Update before reporting any bugs");
-            // FontConfig >= 2.4.0 updates cache automatically in FcConfigAppFontAddDir()
-            if (FcGetVersion() < 20390) {
-                FcFontSet *fcs;
-                FcStrSet *fss;
-                fcs = FcFontSetCreate();
-                fss = FcStrSetCreate();
-                rc = FcStrSetAdd(fss, (const FcChar8 *) dir);
-                if (!rc) {
-                    ass_msg(library, MSGL_WARN, "%s failed", "FcStrSetAdd");
-                    goto ErrorFontCache;
-                }
+        ass_msg(library, MSGL_INFO, "Updating font cache");
 
-                rc = FcDirScan(fcs, fss, NULL,
-                               FcConfigGetBlanks(priv->config),
-                               (const FcChar8 *) dir, FcFalse);
-                if (!rc) {
-                    ass_msg(library, MSGL_WARN, "%s failed", "FcDirScan");
-                    goto ErrorFontCache;
-                }
-
-                rc = FcDirSave(fcs, fss, (const FcChar8 *) dir);
-                if (!rc) {
-                    ass_msg(library, MSGL_WARN, "%s failed", "FcDirSave");
-                    goto ErrorFontCache;
-                }
-              ErrorFontCache:
-                ;
-            }
-        }
-
         rc = FcConfigAppFontAddDir(priv->config, (const FcChar8 *) dir);
         if (!rc) {
             ass_msg(library, MSGL_WARN, "%s failed", "FcConfigAppFontAddDir");
@@ -521,40 +404,41 @@
     return priv;
 }
 
-int fontconfig_update(fc_instance_t *priv)
+int fontconfig_update(FCInstance *priv)
 {
         return FcConfigBuildFonts(priv->config);
 }
 
 #else                           /* CONFIG_FONTCONFIG */
 
-char *fontconfig_select(ass_library_t *library, fc_instance_t *priv,
+char *fontconfig_select(ASS_Library *library, FCInstance *priv,
                         const char *family, int treat_family_as_pattern,
                         unsigned bold, unsigned italic, int *index,
                         uint32_t code)
 {
     *index = priv->index_default;
-    return priv->path_default;
+    char* res = priv->path_default ? strdup(priv->path_default) : 0;
+    return res;
 }
 
-fc_instance_t *fontconfig_init(ass_library_t *library,
-                               FT_Library ftlibrary, const char *family,
-                               const char *path, int fc, const char *config,
-                               int update)
+FCInstance *fontconfig_init(ASS_Library *library,
+                            FT_Library ftlibrary, const char *family,
+                            const char *path, int fc, const char *config,
+                            int update)
 {
-    fc_instance_t *priv;
+    FCInstance *priv;
 
     ass_msg(library, MSGL_WARN,
         "Fontconfig disabled, only default font will be used.");
 
-    priv = calloc(1, sizeof(fc_instance_t));
+    priv = calloc(1, sizeof(FCInstance));
 
-    priv->path_default = strdup(path);
+    priv->path_default = path ? strdup(path) : 0;
     priv->index_default = 0;
     return priv;
 }
 
-int fontconfig_update(fc_instance_t *priv)
+int fontconfig_update(FCInstance *priv)
 {
     // Do nothing
     return 1;
@@ -562,10 +446,12 @@
 
 #endif
 
-void fontconfig_done(fc_instance_t *priv)
+void fontconfig_done(FCInstance *priv)
 {
+#ifdef CONFIG_FONTCONFIG
     if (priv && priv->config)
         FcConfigDestroy(priv->config);
+#endif
     if (priv && priv->path_default)
         free(priv->path_default);
     if (priv && priv->family_default)

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_fontconfig.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_fontconfig.h	2010-01-08 18:55:07 UTC (rev 5831)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_fontconfig.h	2010-01-09 11:03:17 UTC (rev 5832)
@@ -31,17 +31,17 @@
 #include <fontconfig/fontconfig.h>
 #endif
 
-typedef struct fc_instance fc_instance_t;
+typedef struct fc_instance FCInstance;
 
-fc_instance_t *fontconfig_init(ass_library_t *library,
-                               FT_Library ftlibrary, const char *family,
-                               const char *path, int fc, const char *config,
-                               int update);
-char *fontconfig_select(ass_library_t *library, fc_instance_t *priv,
+FCInstance *fontconfig_init(ASS_Library *library,
+                            FT_Library ftlibrary, const char *family,
+                            const char *path, int fc, const char *config,
+                            int update);
+char *fontconfig_select(ASS_Library *library, FCInstance *priv,
                         const char *family, int treat_family_as_pattern,
                         unsigned bold, unsigned italic, int *index,
                         uint32_t code);
-void fontconfig_done(fc_instance_t *priv);
-int fontconfig_update(fc_instance_t *priv);
+void fontconfig_done(FCInstance *priv);
+int fontconfig_update(FCInstance *priv);
 
 #endif                          /* LIBASS_FONTCONFIG_H */

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_library.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_library.c	2010-01-08 18:55:07 UTC (rev 5831)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_library.c	2010-01-09 11:03:17 UTC (rev 5832)
@@ -37,15 +37,15 @@
     fprintf(stderr, "\n");
 }
 
-ass_library_t *ass_library_init(void)
+ASS_Library *ass_library_init(void)
 {
-    ass_library_t* lib = calloc(1, sizeof(ass_library_t));
+    ASS_Library* lib = calloc(1, sizeof(*lib));
     lib->msg_callback = ass_msg_handler;
 
     return lib;
 }
 
-void ass_library_done(ass_library_t *priv)
+void ass_library_done(ASS_Library *priv)
 {
     if (priv) {
         ass_set_fonts_dir(priv, NULL);
@@ -55,7 +55,7 @@
     }
 }
 
-void ass_set_fonts_dir(ass_library_t *priv, const char *fonts_dir)
+void ass_set_fonts_dir(ASS_Library *priv, const char *fonts_dir)
 {
     if (priv->fonts_dir)
         free(priv->fonts_dir);
@@ -63,12 +63,12 @@
     priv->fonts_dir = fonts_dir ? strdup(fonts_dir) : 0;
 }
 
-void ass_set_extract_fonts(ass_library_t *priv, int extract)
+void ass_set_extract_fonts(ASS_Library *priv, int extract)
 {
     priv->extract_fonts = !!extract;
 }
 
-void ass_set_style_overrides(ass_library_t *priv, char **list)
+void ass_set_style_overrides(ASS_Library *priv, char **list)
 {
     char **p;
     char **q;
@@ -98,7 +98,7 @@
         *array = realloc(*array, (nelem + 32) * elsize);
 }
 
-void ass_add_font(ass_library_t *priv, char *name, char *data, int size)
+void ass_add_font(ASS_Library *priv, char *name, char *data, int size)
 {
     int idx = priv->num_fontdata;
     if (!name || !data || !size)
@@ -116,7 +116,7 @@
     priv->num_fontdata++;
 }
 
-void ass_clear_fonts(ass_library_t *priv)
+void ass_clear_fonts(ASS_Library *priv)
 {
     int i;
     for (i = 0; i < priv->num_fontdata; ++i) {
@@ -136,7 +136,7 @@
  * \param msg_cb the callback function
  * \param data additional data that will be passed to the callback
  */
-void ass_set_message_cb(ass_library_t *priv,
+void ass_set_message_cb(ASS_Library *priv,
                         void (*msg_cb)(int, const char *, va_list, void *),
                         void *data)
 {

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_library.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_library.h	2010-01-08 18:55:07 UTC (rev 5831)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_library.h	2010-01-09 11:03:17 UTC (rev 5832)
@@ -27,14 +27,14 @@
     char *name;
     char *data;
     int size;
-} ass_fontdata_t;
+} ASS_Fontdata;
 
 struct ass_library {
     char *fonts_dir;
     int extract_fonts;
     char **style_overrides;
 
-    ass_fontdata_t *fontdata;
+    ASS_Fontdata *fontdata;
     int num_fontdata;
     void (*msg_callback)(int, const char *, va_list, void *);
     void *msg_callback_data;

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_parse.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_parse.c	2010-01-08 18:55:07 UTC (rev 5831)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_parse.c	2010-01-09 11:03:17 UTC (rev 5832)
@@ -0,0 +1,926 @@
+/*
+ * Copyright (C) 2009 Grigori Goronzy <greg at geekmind.org>
+ *
+ * This file is part of libass.
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include "config.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <math.h>
+
+#include "ass_render.h"
+#include "ass_parse.h"
+
+#define MAX_BE 127
+#define NBSP 0xa0   // unicode non-breaking space character
+
+#define skip_to(x) while ((*p != (x)) && (*p != '}') && (*p != 0)) { ++p;}
+#define skip(x) if (*p == (x)) ++p; else { return p; }
+#define skipopt(x) if (*p == (x)) { ++p; }
+
+/**
+ * \brief Check if starting part of (*p) matches sample.
+ * If true, shift p to the first symbol after the matching part.
+ */
+static inline int mystrcmp(char **p, const char *sample)
+{
+    int len = strlen(sample);
+    if (strncmp(*p, sample, len) == 0) {
+        (*p) += len;
+        return 1;
+    } else
+        return 0;
+}
+
+static void change_font_size(ASS_Renderer *render_priv, double sz)
+{
+    double size = sz * render_priv->font_scale;
+
+    if (size < 1)
+        size = 1;
+    else if (size > render_priv->height * 2)
+        size = render_priv->height * 2;
+
+    ass_font_set_size(render_priv->state.font, size);
+
+    render_priv->state.font_size = sz;
+}
+
+/**
+ * \brief Change current font, using setting from render_priv->state.
+ */
+void update_font(ASS_Renderer *render_priv)
+{
+    unsigned val;
+    ASS_FontDesc desc;
+    desc.family = strdup(render_priv->state.family);
+    desc.treat_family_as_pattern =
+        render_priv->state.treat_family_as_pattern;
+
+    val = render_priv->state.bold;
+    // 0 = normal, 1 = bold, >1 = exact weight
+    if (val == 1 || val == -1)
+        val = 200;              // bold
+    else if (val <= 0)
+        val = 80;               // normal
+    desc.bold = val;
+
+    val = render_priv->state.italic;
+    if (val == 1 || val == -1)
+        val = 110;              // italic
+    else if (val <= 0)
+        val = 0;                // normal
+    desc.italic = val;
+
+    render_priv->state.font =
+        ass_font_new(render_priv->cache.font_cache, render_priv->library,
+                     render_priv->ftlibrary, render_priv->fontconfig_priv,
+                     &desc);
+    free(desc.family);
+
+    if (render_priv->state.font)
+        change_font_size(render_priv, render_priv->state.font_size);
+}
+
+/**
+ * \brief Change border width
+ * negative value resets border to style value
+ */
+void change_border(ASS_Renderer *render_priv, double border_x,
+                   double border_y)
+{
+    int bord;
+    if (!render_priv->state.font)
+        return;
+
+    if (border_x < 0 && border_y < 0) {
+        if (render_priv->state.style->BorderStyle == 1 ||
+            render_priv->state.style->BorderStyle == 3)
+            border_x = border_y = render_priv->state.style->Outline;
+        else
+            border_x = border_y = 1.;
+    }
+
+    render_priv->state.border_x = border_x;
+    render_priv->state.border_y = border_y;
+
+    bord = 64 * border_x * render_priv->border_scale;
+    if (bord > 0 && border_x == border_y) {
+        if (!render_priv->state.stroker) {
+            int error;
+            error =
+                FT_Stroker_New(render_priv->ftlibrary,
+                               &render_priv->state.stroker);
+            if (error) {
+                ass_msg(render_priv->library, MSGL_V,
+                        "failed to get stroker");
+                render_priv->state.stroker = 0;
+            }
+        }
+        if (render_priv->state.stroker)
+            FT_Stroker_Set(render_priv->state.stroker, bord,
+                           FT_STROKER_LINECAP_ROUND,
+                           FT_STROKER_LINEJOIN_ROUND, 0);
+    } else {
+        FT_Stroker_Done(render_priv->state.stroker);
+        render_priv->state.stroker = 0;
+    }
+}
+
+/**
+ * \brief Calculate a weighted average of two colors
+ * calculates c1*(1-a) + c2*a, but separately for each component except alpha
+ */
+static void change_color(uint32_t *var, uint32_t new, double pwr)
+{
+    (*var) = ((uint32_t) (_r(*var) * (1 - pwr) + _r(new) * pwr) << 24) +
+        ((uint32_t) (_g(*var) * (1 - pwr) + _g(new) * pwr) << 16) +
+        ((uint32_t) (_b(*var) * (1 - pwr) + _b(new) * pwr) << 8) + _a(*var);
+}
+
+// like change_color, but for alpha component only
+inline void change_alpha(uint32_t *var, uint32_t new, double pwr)
+{
+    *var =
+        (_r(*var) << 24) + (_g(*var) << 16) + (_b(*var) << 8) +
+        (uint32_t) (_a(*var) * (1 - pwr) + _a(new) * pwr);
+}
+
+/**
+ * \brief Multiply two alpha values
+ * \param a first value
+ * \param b second value
+ * \return result of multiplication
+ * Parameters and result are limited by 0xFF.
+ */
+inline uint32_t mult_alpha(uint32_t a, uint32_t b)
+{
+    return 0xFF - (0xFF - a) * (0xFF - b) / 0xFF;
+}
+
+/**
+ * \brief Calculate alpha value by piecewise linear function
+ * Used for \fad, \fade implementation.
+ */
+static unsigned
+interpolate_alpha(long long now, long long t1, long long t2, long long t3,
+                  long long t4, unsigned a1, unsigned a2, unsigned a3)
+{
+    unsigned a;
+    double cf;
+    if (now <= t1) {
+        a = a1;
+    } else if (now >= t4) {
+        a = a3;
+    } else if (now < t2) {      // and > t1
+        cf = ((double) (now - t1)) / (t2 - t1);
+        a = a1 * (1 - cf) + a2 * cf;
+    } else if (now > t3) {
+        cf = ((double) (now - t3)) / (t4 - t3);
+        a = a2 * (1 - cf) + a3 * cf;
+    } else {                    // t2 <= now <= t3
+        a = a2;
+    }
+
+    return a;
+}
+
+/**
+ * Parse a vector clip into an outline, using the proper scaling
+ * parameters.  Translate it to correct for screen borders, if needed.
+ */
+static char *parse_vector_clip(ASS_Renderer *render_priv, char *p)
+{
+    int scale = 1;
+    int res = 0;
+    ASS_Drawing *drawing;
+
+    render_priv->state.clip_drawing = ass_drawing_new(
+        render_priv->fontconfig_priv,
+        render_priv->state.font,
+        render_priv->settings.hinting,
+        render_priv->ftlibrary);
+    drawing = render_priv->state.clip_drawing;
+    skipopt('(');
+    res = mystrtoi(&p, &scale);
+    skipopt(',')
+    if (!res)
+        scale = 1;
+    drawing->scale = scale;
+    drawing->scale_x = render_priv->font_scale_x * render_priv->font_scale;
+    drawing->scale_y = render_priv->font_scale;
+    while (*p != ')' && *p != '}' && p != 0)
+        ass_drawing_add_char(drawing, *p++);
+    skipopt(')');
+    if (ass_drawing_parse(drawing, 1)) {
+        // We need to translate the clip according to screen borders
+        if (render_priv->settings.left_margin != 0 ||
+            render_priv->settings.top_margin != 0) {
+            FT_Vector trans = {
+                .x = int_to_d6(render_priv->settings.left_margin),
+                .y = -int_to_d6(render_priv->settings.top_margin),
+            };
+            FT_Outline_Translate(&drawing->glyph->outline, trans.x, trans.y);
+        }
+        ass_msg(render_priv->library, MSGL_DBG2,
+                "Parsed vector clip: scale %d, scales (%f, %f) string [%s]\n",
+                scale, drawing->scale_x, drawing->scale_y, drawing->text);
+    }
+
+    return p;
+}
+
+/**
+ * \brief Parse style override tag.
+ * \param p string to parse
+ * \param pwr multiplier for some tag effects (comes from \t tags)
+ */
+static char *parse_tag(ASS_Renderer *render_priv, char *p, double pwr)
+{
+    skip_to('\\');
+    skip('\\');
+    if ((*p == '}') || (*p == 0))
+        return p;
+
+    // New tags introduced in vsfilter 2.39
+    if (mystrcmp(&p, "xbord")) {
+        double val;
+        if (mystrtod(&p, &val))
+            val = render_priv->state.border_x * (1 - pwr) + val * pwr;
+        else
+            val = -1.;
+        change_border(render_priv, val, render_priv->state.border_y);
+    } else if (mystrcmp(&p, "ybord")) {
+        double val;
+        if (mystrtod(&p, &val))
+            val = render_priv->state.border_y * (1 - pwr) + val * pwr;
+        else
+            val = -1.;
+        change_border(render_priv, render_priv->state.border_x, val);
+    } else if (mystrcmp(&p, "xshad")) {
+        double val;
+        if (mystrtod(&p, &val))
+            val = render_priv->state.shadow_x * (1 - pwr) + val * pwr;
+        else
+            val = 0.;
+        render_priv->state.shadow_x = val;
+    } else if (mystrcmp(&p, "yshad")) {
+        double val;
+        if (mystrtod(&p, &val))
+            val = render_priv->state.shadow_y * (1 - pwr) + val * pwr;
+        else
+            val = 0.;
+        render_priv->state.shadow_y = val;
+    } else if (mystrcmp(&p, "fax")) {
+        double val;
+        if (mystrtod(&p, &val))
+            render_priv->state.fax =
+                val * pwr + render_priv->state.fax * (1 - pwr);
+        else
+            render_priv->state.fax = 0.;
+    } else if (mystrcmp(&p, "fay")) {
+        double val;
+        if (mystrtod(&p, &val))
+            render_priv->state.fay =
+                val * pwr + render_priv->state.fay * (1 - pwr);
+        else
+            render_priv->state.fay = 0.;
+    } else if (mystrcmp(&p, "iclip")) {
+        int x0, y0, x1, y1;
+        int res = 1;
+        char *start = p;
+        skipopt('(');
+        res &= mystrtoi(&p, &x0);
+        skipopt(',');
+        res &= mystrtoi(&p, &y0);
+        skipopt(',');
+        res &= mystrtoi(&p, &x1);
+        skipopt(',');
+        res &= mystrtoi(&p, &y1);
+        skipopt(')');
+        if (res) {
+            render_priv->state.clip_x0 =
+                render_priv->state.clip_x0 * (1 - pwr) + x0 * pwr;
+            render_priv->state.clip_x1 =
+                render_priv->state.clip_x1 * (1 - pwr) + x1 * pwr;
+            render_priv->state.clip_y0 =
+                render_priv->state.clip_y0 * (1 - pwr) + y0 * pwr;
+            render_priv->state.clip_y1 =
+                render_priv->state.clip_y1 * (1 - pwr) + y1 * pwr;
+            render_priv->state.clip_mode = 1;
+        } else if (!render_priv->state.clip_drawing) {
+            p = parse_vector_clip(render_priv, start);
+            render_priv->state.clip_drawing_mode = 1;
+        } else
+            render_priv->state.clip_mode = 0;
+    } else if (mystrcmp(&p, "blur")) {
+        double val;
+        if (mystrtod(&p, &val)) {
+            val = render_priv->state.blur * (1 - pwr) + val * pwr;
+            val = (val < 0) ? 0 : val;
+            val = (val > BLUR_MAX_RADIUS) ? BLUR_MAX_RADIUS : val;
+            render_priv->state.blur = val;
+        } else
+            render_priv->state.blur = 0.0;
+        // ASS standard tags
+    } else if (mystrcmp(&p, "fsc")) {
+        char tp = *p++;
+        double val;
+        if (tp == 'x') {
+            if (mystrtod(&p, &val)) {
+                val /= 100;
+                render_priv->state.scale_x =
+                    render_priv->state.scale_x * (1 - pwr) + val * pwr;
+            } else
+                render_priv->state.scale_x =
+                    render_priv->state.style->ScaleX;
+        } else if (tp == 'y') {
+            if (mystrtod(&p, &val)) {
+                val /= 100;
+                render_priv->state.scale_y =
+                    render_priv->state.scale_y * (1 - pwr) + val * pwr;
+            } else
+                render_priv->state.scale_y =
+                    render_priv->state.style->ScaleY;
+        }
+    } else if (mystrcmp(&p, "fsp")) {
+        double val;
+        if (mystrtod(&p, &val))
+            render_priv->state.hspacing =
+                render_priv->state.hspacing * (1 - pwr) + val * pwr;
+        else
+            render_priv->state.hspacing = render_priv->state.style->Spacing;
+    } else if (mystrcmp(&p, "fs")) {
+        double val;
+        if (mystrtod(&p, &val))
+            val = render_priv->state.font_size * (1 - pwr) + val * pwr;
+        else
+            val = render_priv->state.style->FontSize;
+        if (render_priv->state.font)
+            change_font_size(render_priv, val);
+    } else if (mystrcmp(&p, "bord")) {
+        double val;
+        if (mystrtod(&p, &val)) {
+            if (render_priv->state.border_x == render_priv->state.border_y)
+                val = render_priv->state.border_x * (1 - pwr) + val * pwr;
+        } else
+            val = -1.;          // reset to default
+        change_border(render_priv, val, val);
+    } else if (mystrcmp(&p, "move")) {
+        double x1, x2, y1, y2;
+        long long t1, t2, delta_t, t;
+        double x, y;
+        double k;
+        skip('(');
+        mystrtod(&p, &x1);
+        skip(',');
+        mystrtod(&p, &y1);
+        skip(',');
+        mystrtod(&p, &x2);
+        skip(',');
+        mystrtod(&p, &y2);
+        if (*p == ',') {
+            skip(',');
+            mystrtoll(&p, &t1);
+            skip(',');
+            mystrtoll(&p, &t2);
+            ass_msg(render_priv->library, MSGL_DBG2,
+                   "movement6: (%f, %f) -> (%f, %f), (%" PRId64 " .. %"
+                   PRId64 ")\n", x1, y1, x2, y2, (int64_t) t1,
+                   (int64_t) t2);
+        } else {
+            t1 = 0;
+            t2 = render_priv->state.event->Duration;
+            ass_msg(render_priv->library, MSGL_DBG2,
+                   "movement: (%f, %f) -> (%f, %f)", x1, y1, x2, y2);
+        }
+        skip(')');
+        delta_t = t2 - t1;
+        t = render_priv->time - render_priv->state.event->Start;
+        if (t < t1)
+            k = 0.;
+        else if (t > t2)
+            k = 1.;
+        else
+            k = ((double) (t - t1)) / delta_t;
+        x = k * (x2 - x1) + x1;
+        y = k * (y2 - y1) + y1;
+        if (render_priv->state.evt_type != EVENT_POSITIONED) {
+            render_priv->state.pos_x = x;
+            render_priv->state.pos_y = y;
+            render_priv->state.detect_collisions = 0;
+            render_priv->state.evt_type = EVENT_POSITIONED;
+        }
+    } else if (mystrcmp(&p, "frx")) {
+        double val;
+        if (mystrtod(&p, &val)) {
+            val *= M_PI / 180;
+            render_priv->state.frx =
+                val * pwr + render_priv->state.frx * (1 - pwr);
+        } else
+            render_priv->state.frx = 0.;
+    } else if (mystrcmp(&p, "fry")) {
+        double val;
+        if (mystrtod(&p, &val)) {
+            val *= M_PI / 180;
+            render_priv->state.fry =
+                val * pwr + render_priv->state.fry * (1 - pwr);
+        } else
+            render_priv->state.fry = 0.;
+    } else if (mystrcmp(&p, "frz") || mystrcmp(&p, "fr")) {
+        double val;
+        if (mystrtod(&p, &val)) {
+            val *= M_PI / 180;
+            render_priv->state.frz =
+                val * pwr + render_priv->state.frz * (1 - pwr);
+        } else
+            render_priv->state.frz =
+                M_PI * render_priv->state.style->Angle / 180.;
+    } else if (mystrcmp(&p, "fn")) {
+        char *start = p;
+        char *family;
+        skip_to('\\');
+        if (p > start) {
+            family = malloc(p - start + 1);
+            strncpy(family, start, p - start);
+            family[p - start] = '\0';
+        } else
+            family = strdup(render_priv->state.style->FontName);
+        if (render_priv->state.family)
+            free(render_priv->state.family);
+        render_priv->state.family = family;
+        update_font(render_priv);
+    } else if (mystrcmp(&p, "alpha")) {
+        uint32_t val;
+        int i;
+        int hex = render_priv->track->track_type == TRACK_TYPE_ASS;
+        if (strtocolor(render_priv->library, &p, &val, hex)) {
+            unsigned char a = val >> 24;
+            for (i = 0; i < 4; ++i)
+                change_alpha(&render_priv->state.c[i], a, pwr);
+        } else {
+            change_alpha(&render_priv->state.c[0],
+                         render_priv->state.style->PrimaryColour, pwr);
+            change_alpha(&render_priv->state.c[1],
+                         render_priv->state.style->SecondaryColour, pwr);
+            change_alpha(&render_priv->state.c[2],
+                         render_priv->state.style->OutlineColour, pwr);
+            change_alpha(&render_priv->state.c[3],
+                         render_priv->state.style->BackColour, pwr);
+        }
+        // FIXME: simplify
+    } else if (mystrcmp(&p, "an")) {
+        int val;
+        if (mystrtoi(&p, &val) && val) {
+            int v = (val - 1) / 3;      // 0, 1 or 2 for vertical alignment
+            ass_msg(render_priv->library, MSGL_DBG2, "an %d", val);
+            if (v != 0)
+                v = 3 - v;
+            val = ((val - 1) % 3) + 1;  // horizontal alignment
+            val += v * 4;
+            ass_msg(render_priv->library, MSGL_DBG2, "align %d", val);
+            render_priv->state.alignment = val;
+        } else
+            render_priv->state.alignment =
+                render_priv->state.style->Alignment;
+    } else if (mystrcmp(&p, "a")) {
+        int val;
+        if (mystrtoi(&p, &val) && val)
+            // take care of a vsfilter quirk: handle illegal \a8 like \a5
+            render_priv->state.alignment = (val == 8) ? 5 : val;
+        else
+            render_priv->state.alignment =
+                render_priv->state.style->Alignment;
+    } else if (mystrcmp(&p, "pos")) {
+        double v1, v2;
+        skip('(');
+        mystrtod(&p, &v1);
+        skip(',');
+        mystrtod(&p, &v2);
+        skip(')');
+        ass_msg(render_priv->library, MSGL_DBG2, "pos(%f, %f)", v1, v2);
+        if (render_priv->state.evt_type == EVENT_POSITIONED) {
+            ass_msg(render_priv->library, MSGL_V, "Subtitle has a new \\pos "
+                   "after \\move or \\pos, ignoring");
+        } else {
+            render_priv->state.evt_type = EVENT_POSITIONED;
+            render_priv->state.detect_collisions = 0;
+            render_priv->state.pos_x = v1;
+            render_priv->state.pos_y = v2;
+        }
+    } else if (mystrcmp(&p, "fad")) {
+        int a1, a2, a3;
+        long long t1, t2, t3, t4;
+        if (*p == 'e')
+            ++p;                // either \fad or \fade
+        skip('(');
+        mystrtoi(&p, &a1);
+        skip(',');
+        mystrtoi(&p, &a2);
+        if (*p == ')') {
+            // 2-argument version (\fad, according to specs)
+            // a1 and a2 are fade-in and fade-out durations
+            t1 = 0;
+            t4 = render_priv->state.event->Duration;
+            t2 = a1;
+            t3 = t4 - a2;
+            a1 = 0xFF;
+            a2 = 0;
+            a3 = 0xFF;
+        } else {
+            // 6-argument version (\fade)
+            // a1 and a2 (and a3) are opacity values
+            skip(',');
+            mystrtoi(&p, &a3);
+            skip(',');
+            mystrtoll(&p, &t1);
+            skip(',');
+            mystrtoll(&p, &t2);
+            skip(',');
+            mystrtoll(&p, &t3);
+            skip(',');
+            mystrtoll(&p, &t4);
+        }
+        skip(')');
+        render_priv->state.fade =
+            interpolate_alpha(render_priv->time -
+                              render_priv->state.event->Start, t1, t2,
+                              t3, t4, a1, a2, a3);
+    } else if (mystrcmp(&p, "org")) {
+        int v1, v2;
+        skip('(');
+        mystrtoi(&p, &v1);
+        skip(',');
+        mystrtoi(&p, &v2);
+        skip(')');
+        ass_msg(render_priv->library, MSGL_DBG2, "org(%d, %d)", v1, v2);
+        if (!render_priv->state.have_origin) {
+            render_priv->state.org_x = v1;
+            render_priv->state.org_y = v2;
+            render_priv->state.have_origin = 1;
+            render_priv->state.detect_collisions = 0;
+        }
+    } else if (mystrcmp(&p, "t")) {
+        double v[3];
+        int v1, v2;
+        double v3;
+        int cnt;
+        long long t1, t2, t, delta_t;
+        double k;
+        skip('(');
+        for (cnt = 0; cnt < 3; ++cnt) {
+            if (*p == '\\')
+                break;
+            v[cnt] = strtod(p, &p);
+            skip(',');
+        }
+        if (cnt == 3) {
+            v1 = v[0];
+            v2 = (v[1] < v1) ? render_priv->state.event->Duration : v[1];
+            v3 = v[2];
+        } else if (cnt == 2) {
+            v1 = v[0];
+            v2 = (v[1] < v1) ? render_priv->state.event->Duration : v[1];
+            v3 = 1.;
+        } else if (cnt == 1) {
+            v1 = 0;
+            v2 = render_priv->state.event->Duration;
+            v3 = v[0];
+        } else {                // cnt == 0
+            v1 = 0;
+            v2 = render_priv->state.event->Duration;
+            v3 = 1.;
+        }
+        render_priv->state.detect_collisions = 0;
+        t1 = v1;
+        t2 = v2;
+        delta_t = v2 - v1;
+        if (v3 < 0.)
+            v3 = 0.;
+        t = render_priv->time - render_priv->state.event->Start;        // FIXME: move to render_context
+        if (t <= t1)
+            k = 0.;
+        else if (t >= t2)
+            k = 1.;
+        else {
+            assert(delta_t != 0.);
+            k = pow(((double) (t - t1)) / delta_t, v3);
+        }
+        while (*p == '\\')
+            p = parse_tag(render_priv, p, k);   // maybe k*pwr ? no, specs forbid nested \t's
+        skip_to(')');           // in case there is some unknown tag or a comment
+        skip(')');
+    } else if (mystrcmp(&p, "clip")) {
+        char *start = p;
+        int x0, y0, x1, y1;
+        int res = 1;
+        skipopt('(');
+        res &= mystrtoi(&p, &x0);
+        skipopt(',');
+        res &= mystrtoi(&p, &y0);
+        skipopt(',');
+        res &= mystrtoi(&p, &x1);
+        skipopt(',');
+        res &= mystrtoi(&p, &y1);
+        skipopt(')');
+        if (res) {
+            render_priv->state.clip_x0 =
+                render_priv->state.clip_x0 * (1 - pwr) + x0 * pwr;
+            render_priv->state.clip_x1 =
+                render_priv->state.clip_x1 * (1 - pwr) + x1 * pwr;
+            render_priv->state.clip_y0 =
+                render_priv->state.clip_y0 * (1 - pwr) + y0 * pwr;
+            render_priv->state.clip_y1 =
+                render_priv->state.clip_y1 * (1 - pwr) + y1 * pwr;
+        // Might be a vector clip
+        } else if (!render_priv->state.clip_drawing) {
+            p = parse_vector_clip(render_priv, start);
+            render_priv->state.clip_drawing_mode = 0;
+        } else {
+            render_priv->state.clip_x0 = 0;
+            render_priv->state.clip_y0 = 0;
+            render_priv->state.clip_x1 = render_priv->track->PlayResX;
+            render_priv->state.clip_y1 = render_priv->track->PlayResY;
+        }
+    } else if (mystrcmp(&p, "c")) {
+        uint32_t val;
+        int hex = render_priv->track->track_type == TRACK_TYPE_ASS;
+        if (!strtocolor(render_priv->library, &p, &val, hex))
+            val = render_priv->state.style->PrimaryColour;
+        ass_msg(render_priv->library, MSGL_DBG2, "color: %X", val);
+        change_color(&render_priv->state.c[0], val, pwr);
+    } else if ((*p >= '1') && (*p <= '4') && (++p)
+               && (mystrcmp(&p, "c") || mystrcmp(&p, "a"))) {
+        char n = *(p - 2);
+        int cidx = n - '1';
+        char cmd = *(p - 1);
+        uint32_t val;
+        int hex = render_priv->track->track_type == TRACK_TYPE_ASS;
+        assert((n >= '1') && (n <= '4'));
+        if (!strtocolor(render_priv->library, &p, &val, hex))
+            switch (n) {
+            case '1':
+                val = render_priv->state.style->PrimaryColour;
+                break;
+            case '2':
+                val = render_priv->state.style->SecondaryColour;
+                break;
+            case '3':
+                val = render_priv->state.style->OutlineColour;
+                break;
+            case '4':
+                val = render_priv->state.style->BackColour;
+                break;
+            default:
+                val = 0;
+                break;          // impossible due to assert; avoid compilation warning
+            }
+        switch (cmd) {
+        case 'c':
+            change_color(render_priv->state.c + cidx, val, pwr);
+            break;
+        case 'a':
+            change_alpha(render_priv->state.c + cidx, val >> 24, pwr);
+            break;
+        default:
+            ass_msg(render_priv->library, MSGL_WARN, "Bad command: %c%c",
+                    n, cmd);
+            break;
+        }
+        ass_msg(render_priv->library, MSGL_DBG2, "single c/a at %f: %c%c = %X",
+               pwr, n, cmd, render_priv->state.c[cidx]);
+    } else if (mystrcmp(&p, "r")) {
+        reset_render_context(render_priv);
+    } else if (mystrcmp(&p, "be")) {
+        int val;
+        if (mystrtoi(&p, &val)) {
+            // Clamp to a safe upper limit, since high values need excessive CPU
+            val = (val < 0) ? 0 : val;
+            val = (val > MAX_BE) ? MAX_BE : val;
+            render_priv->state.be = val;
+        } else
+            render_priv->state.be = 0;
+    } else if (mystrcmp(&p, "b")) {
+        int b;
+        if (mystrtoi(&p, &b)) {
+            if (pwr >= .5)
+                render_priv->state.bold = b;
+        } else
+            render_priv->state.bold = render_priv->state.style->Bold;
+        update_font(render_priv);
+    } else if (mystrcmp(&p, "i")) {
+        int i;
+        if (mystrtoi(&p, &i)) {
+            if (pwr >= .5)
+                render_priv->state.italic = i;
+        } else
+            render_priv->state.italic = render_priv->state.style->Italic;
+        update_font(render_priv);
+    } else if (mystrcmp(&p, "kf") || mystrcmp(&p, "K")) {
+        int val = 0;
+        mystrtoi(&p, &val);
+        render_priv->state.effect_type = EF_KARAOKE_KF;
+        if (render_priv->state.effect_timing)
+            render_priv->state.effect_skip_timing +=
+                render_priv->state.effect_timing;
+        render_priv->state.effect_timing = val * 10;
+    } else if (mystrcmp(&p, "ko")) {
+        int val = 0;
+        mystrtoi(&p, &val);
+        render_priv->state.effect_type = EF_KARAOKE_KO;
+        if (render_priv->state.effect_timing)
+            render_priv->state.effect_skip_timing +=
+                render_priv->state.effect_timing;
+        render_priv->state.effect_timing = val * 10;
+    } else if (mystrcmp(&p, "k")) {
+        int val = 0;
+        mystrtoi(&p, &val);
+        render_priv->state.effect_type = EF_KARAOKE;
+        if (render_priv->state.effect_timing)
+            render_priv->state.effect_skip_timing +=
+                render_priv->state.effect_timing;
+        render_priv->state.effect_timing = val * 10;
+    } else if (mystrcmp(&p, "shad")) {
+        double val;
+        if (mystrtod(&p, &val)) {
+            if (render_priv->state.shadow_x == render_priv->state.shadow_y)
+                val = render_priv->state.shadow_x * (1 - pwr) + val * pwr;
+        } else
+            val = 0.;
+        render_priv->state.shadow_x = render_priv->state.shadow_y = val;
+    } else if (mystrcmp(&p, "s")) {
+        int val;
+        if (mystrtoi(&p, &val) && val)
+            render_priv->state.flags |= DECO_STRIKETHROUGH;
+        else
+            render_priv->state.flags &= ~DECO_STRIKETHROUGH;
+    } else if (mystrcmp(&p, "u")) {
+        int val;
+        if (mystrtoi(&p, &val) && val)
+            render_priv->state.flags |= DECO_UNDERLINE;
+        else
+            render_priv->state.flags &= ~DECO_UNDERLINE;
+    } else if (mystrcmp(&p, "pbo")) {
+        double val = 0;
+        if (mystrtod(&p, &val))
+            render_priv->state.drawing->pbo = val;
+    } else if (mystrcmp(&p, "p")) {
+        int val;
+        if (!mystrtoi(&p, &val))
+            val = 0;
+        if (val)
+            render_priv->state.drawing->scale = val;
+        render_priv->state.drawing_mode = !!val;
+    } else if (mystrcmp(&p, "q")) {
+        int val;
+        if (!mystrtoi(&p, &val))
+            val = render_priv->track->WrapStyle;
+        render_priv->state.wrap_style = val;
+    }
+
+    return p;
+}
+
+void apply_transition_effects(ASS_Renderer *render_priv, ASS_Event *event)
+{
+    int v[4];
+    int cnt;
+    char *p = event->Effect;
+
+    if (!p || !*p)
+        return;
+
+    cnt = 0;
+    while (cnt < 4 && (p = strchr(p, ';'))) {
+        v[cnt++] = atoi(++p);
+    }
+
+    if (strncmp(event->Effect, "Banner;", 7) == 0) {
+        int delay;
+        if (cnt < 1) {
+            ass_msg(render_priv->library, MSGL_V,
+                    "Error parsing effect: '%s'", event->Effect);
+            return;
+        }
+        if (cnt >= 2 && v[1] == 0)      // right-to-left
+            render_priv->state.scroll_direction = SCROLL_RL;
+        else                    // left-to-right
+            render_priv->state.scroll_direction = SCROLL_LR;
+
+        delay = v[0];
+        if (delay == 0)
+            delay = 1;          // ?
+        render_priv->state.scroll_shift =
+            (render_priv->time - render_priv->state.event->Start) / delay;
+        render_priv->state.evt_type = EVENT_HSCROLL;
+        return;
+    }
+
+    if (strncmp(event->Effect, "Scroll up;", 10) == 0) {
+        render_priv->state.scroll_direction = SCROLL_BT;
+    } else if (strncmp(event->Effect, "Scroll down;", 12) == 0) {
+        render_priv->state.scroll_direction = SCROLL_TB;
+    } else {
+        ass_msg(render_priv->library, MSGL_V,
+                "Unknown transition effect: '%s'", event->Effect);
+        return;
+    }
+    // parse scroll up/down parameters
+    {
+        int delay;
+        int y0, y1;
+        if (cnt < 3) {
+            ass_msg(render_priv->library, MSGL_V,
+                    "Error parsing effect: '%s'", event->Effect);
+            return;
+        }
+        delay = v[2];
+        if (delay == 0)
+            delay = 1;          // ?
+        render_priv->state.scroll_shift =
+            (render_priv->time - render_priv->state.event->Start) / delay;
+        if (v[0] < v[1]) {
+            y0 = v[0];
+            y1 = v[1];
+        } else {
+            y0 = v[1];
+            y1 = v[0];
+        }
+        if (y1 == 0)
+            y1 = render_priv->track->PlayResY;  // y0=y1=0 means fullscreen scrolling
+        render_priv->state.clip_y0 = y0;
+        render_priv->state.clip_y1 = y1;
+        render_priv->state.evt_type = EVENT_VSCROLL;
+        render_priv->state.detect_collisions = 0;
+    }
+
+}
+
+/**
+ * \brief Get next ucs4 char from string, parsing and executing style overrides
+ * \param str string pointer
+ * \return ucs4 code of the next char
+ * On return str points to the unparsed part of the string
+ */
+unsigned get_next_char(ASS_Renderer *render_priv, char **str)
+{
+    char *p = *str;
+    unsigned chr;
+    if (*p == '{') {            // '\0' goes here
+        p++;
+        while (1) {
+            p = parse_tag(render_priv, p, 1.);
+            if (*p == '}') {    // end of tag
+                p++;
+                if (*p == '{') {
+                    p++;
+                    continue;
+                } else
+                    break;
+            } else if (*p != '\\')
+                ass_msg(render_priv->library, MSGL_V,
+                        "Unable to parse: '%s'", p);
+            if (*p == 0)
+                break;
+        }
+    }
+    if (*p == '\t') {
+        ++p;
+        *str = p;
+        return ' ';
+    }
+    if (*p == '\\') {
+        if ((p[1] == 'N') || ((p[1] == 'n') &&
+                              (render_priv->state.wrap_style == 2))) {
+            p += 2;
+            *str = p;
+            return '\n';
+        } else if (p[1] == 'n') {
+            p += 2;
+            *str = p;
+            return ' ';
+        } else if (p[1] == 'h') {
+            p += 2;
+            *str = p;
+            return NBSP;
+        }
+    }
+    chr = ass_utf8_get_char((char **) &p);
+    *str = p;
+    return chr;
+}

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_parse.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_parse.h	2010-01-08 18:55:07 UTC (rev 5831)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_parse.h	2010-01-09 11:03:17 UTC (rev 5832)
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2009 Grigori Goronzy <greg at geekmind.org>
+ *
+ * This file is part of libass.
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef LIBASS_PARSE_H
+#define LIBASS_PARSE_H
+
+#define BLUR_MAX_RADIUS 100.0
+
+#define _r(c)   ((c) >> 24)
+#define _g(c)   (((c) >> 16) & 0xFF)
+#define _b(c)   (((c) >> 8) & 0xFF)
+#define _a(c)   ((c) & 0xFF)
+
+void update_font(ASS_Renderer *render_priv);
+void change_border(ASS_Renderer *render_priv, double border_x,
+                   double border_y);
+void apply_transition_effects(ASS_Renderer *render_priv, ASS_Event *event);
+unsigned get_next_char(ASS_Renderer *render_priv, char **str);
+extern void change_alpha(uint32_t *var, uint32_t new, double pwr);
+extern uint32_t mult_alpha(uint32_t a, uint32_t b);
+
+
+#endif /* LIBASS_PARSE_H */

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_render.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_render.c	2010-01-08 18:55:07 UTC (rev 5831)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_render.c	2010-01-09 11:03:17 UTC (rev 5832)
@@ -37,221 +37,19 @@
 #include "ass_fontconfig.h"
 #include "ass_library.h"
 #include "ass_drawing.h"
+#include "ass_render.h"
+#include "ass_parse.h"
 
 #define MAX_GLYPHS_INITIAL 1024
 #define MAX_LINES_INITIAL 64
-#define BLUR_MAX_RADIUS 100.0
-#define MAX_BE 127
 #define SUBPIXEL_MASK 63
 #define SUBPIXEL_ACCURACY 7    // d6 mask for subpixel accuracy adjustment
 #define GLYPH_CACHE_MAX 1000
-#define BITMAP_CACHE_MAX_SIZE 50 * 1048576;
+#define BITMAP_CACHE_MAX_SIZE 50 * 1048576
 
-typedef struct {
-    double xMin;
-    double xMax;
-    double yMin;
-    double yMax;
-} double_bbox_t;
-
-typedef struct {
-    double x;
-    double y;
-} double_vector_t;
-
-typedef struct free_list {
-    void *object;
-    struct free_list *next;
-} free_list_t;
-
-typedef struct {
-    int frame_width;
-    int frame_height;
-    double font_size_coeff;     // font size multiplier
-    double line_spacing;        // additional line spacing (in frame pixels)
-    int top_margin;             // height of top margin. Everything except toptitles is shifted down by top_margin.
-    int bottom_margin;          // height of bottom margin. (frame_height - top_margin - bottom_margin) is original video height.
-    int left_margin;
-    int right_margin;
-    int use_margins;            // 0 - place all subtitles inside original frame
-    // 1 - use margins for placing toptitles and subtitles
-    double aspect;              // frame aspect ratio, d_width / d_height.
-    double pixel_ratio;         // pixel ratio of the source image
-    ass_hinting_t hinting;
-
-    char *default_font;
-    char *default_family;
-} ass_settings_t;
-
-// a rendered event
-typedef struct {
-    ass_image_t *imgs;
-    int top, height;
-    int detect_collisions;
-    int shift_direction;
-    ass_event_t *event;
-} event_images_t;
-
-typedef enum { EF_NONE = 0, EF_KARAOKE, EF_KARAOKE_KF, EF_KARAOKE_KO
-} effect_t;
-
-// describes a glyph
-// glyph_info_t and text_info_t are used for text centering and word-wrapping operations
-typedef struct {
-    unsigned symbol;
-    FT_Glyph glyph;
-    FT_Glyph outline_glyph;
-    bitmap_t *bm;               // glyph bitmap
-    bitmap_t *bm_o;             // outline bitmap
-    bitmap_t *bm_s;             // shadow bitmap
-    FT_BBox bbox;
-    FT_Vector pos;
-    char linebreak;             // the first (leading) glyph of some line ?
-    uint32_t c[4];              // colors
-    FT_Vector advance;          // 26.6
-    effect_t effect_type;
-    int effect_timing;          // time duration of current karaoke word
-    // after process_karaoke_effects: distance in pixels from the glyph origin.
-    // part of the glyph to the left of it is displayed in a different color.
-    int effect_skip_timing;     // delay after the end of last karaoke word
-    int asc, desc;              // font max ascender and descender
-//      int height;
-    int be;                     // blur edges
-    double blur;                // gaussian blur
-    double shadow_x;
-    double shadow_y;
-    double frx, fry, frz;       // rotation
-    double fax, fay;            // text shearing
-
-    bitmap_hash_key_t hash_key;
-} glyph_info_t;
-
-typedef struct {
-    double asc, desc;
-} line_info_t;
-
-typedef struct {
-    glyph_info_t *glyphs;
-    int length;
-    line_info_t *lines;
-    int n_lines;
-    double height;
-    int max_glyphs;
-    int max_lines;
-} text_info_t;
-
-
-// Renderer state.
-// Values like current font face, color, screen position, clipping and so on are stored here.
-typedef struct {
-    ass_event_t *event;
-    ass_style_t *style;
-
-    ass_font_t *font;
-    char *font_path;
-    double font_size;
-    int flags;                  // decoration flags (underline/strike-through)
-
-    FT_Stroker stroker;
-    int alignment;              // alignment overrides go here; if zero, style value will be used
-    double frx, fry, frz;
-    double fax, fay;            // text shearing
-    enum { EVENT_NORMAL,        // "normal" top-, sub- or mid- title
-        EVENT_POSITIONED,       // happens after pos(,), margins are ignored
-        EVENT_HSCROLL,          // "Banner" transition effect, text_width is unlimited
-        EVENT_VSCROLL           // "Scroll up", "Scroll down" transition effects
-    } evt_type;
-    double pos_x, pos_y;        // position
-    double org_x, org_y;        // origin
-    char have_origin;           // origin is explicitly defined; if 0, get_base_point() is used
-    double scale_x, scale_y;
-    double hspacing;            // distance between letters, in pixels
-    double border_x;              // outline width
-    double border_y;
-    uint32_t c[4];              // colors(Primary, Secondary, so on) in RGBA
-    int clip_x0, clip_y0, clip_x1, clip_y1;
-    char clip_mode;             // 1 = iclip
-    char detect_collisions;
-    uint32_t fade;              // alpha from \fad
-    char be;                    // blur edges
-    double blur;                // gaussian blur
-    double shadow_x;
-    double shadow_y;
-    int drawing_mode;           // not implemented; when != 0 text is discarded, except for style override tags
-    ass_drawing_t *drawing;     // current drawing
-    ass_drawing_t *clip_drawing;// clip vector
-    int clip_drawing_mode;      // 0 = regular clip, 1 = inverse clip
-
-    effect_t effect_type;
-    int effect_timing;
-    int effect_skip_timing;
-
-    enum { SCROLL_LR,           // left-to-right
-        SCROLL_RL,
-        SCROLL_TB,              // top-to-bottom
-        SCROLL_BT
-    } scroll_direction;         // for EVENT_HSCROLL, EVENT_VSCROLL
-    int scroll_shift;
-
-    // face properties
-    char *family;
-    unsigned bold;
-    unsigned italic;
-    int treat_family_as_pattern;
-
-} render_context_t;
-
-typedef struct {
-    hashmap_t *font_cache;
-    hashmap_t *glyph_cache;
-    hashmap_t *bitmap_cache;
-    hashmap_t *composite_cache;
-    size_t glyph_max;
-    size_t bitmap_max_size;
-} cache_store_t;
-
-struct ass_renderer {
-    ass_library_t *library;
-    FT_Library ftlibrary;
-    fc_instance_t *fontconfig_priv;
-    ass_settings_t settings;
-    int render_id;
-    ass_synth_priv_t *synth_priv;
-
-    ass_image_t *images_root;   // rendering result is stored here
-    ass_image_t *prev_images_root;
-
-    event_images_t *eimg;       // temporary buffer for sorting rendered events
-    int eimg_size;              // allocated buffer size
-
-    // frame-global data
-    int width, height;          // screen dimensions
-    int orig_height;            // frame height ( = screen height - margins )
-    int orig_width;             // frame width ( = screen width - margins )
-    int orig_height_nocrop;     // frame height ( = screen height - margins + cropheight)
-    int orig_width_nocrop;      // frame width ( = screen width - margins + cropwidth)
-    ass_track_t *track;
-    long long time;             // frame's timestamp, ms
-    double font_scale;
-    double font_scale_x;        // x scale applied to all glyphs to preserve text aspect ratio
-    double border_scale;
-
-    render_context_t state;
-    text_info_t text_info;
-    cache_store_t cache;
-
-    free_list_t *free_head;
-    free_list_t *free_tail;
-};
-
-struct render_priv {
-    int top, height;
-    int render_id;
-};
-
-static void ass_lazy_track_init(ass_renderer_t *render_priv)
+static void ass_lazy_track_init(ASS_Renderer *render_priv)
 {
-    ass_track_t *track = render_priv->track;
+    ASS_Track *track = render_priv->track;
 
     if (track->PlayResX && track->PlayResY)
         return;
@@ -281,11 +79,11 @@
     }
 }
 
-ass_renderer_t *ass_renderer_init(ass_library_t *library)
+ASS_Renderer *ass_renderer_init(ASS_Library *library)
 {
     int error;
     FT_Library ft;
-    ass_renderer_t *priv = 0;
+    ASS_Renderer *priv = 0;
     int vmajor, vminor, vpatch;
 
     error = FT_Init_FreeType(&ft);
@@ -300,7 +98,7 @@
     ass_msg(library, MSGL_V, "FreeType headers version: %d.%d.%d",
            FREETYPE_MAJOR, FREETYPE_MINOR, FREETYPE_PATCH);
 
-    priv = calloc(1, sizeof(ass_renderer_t));
+    priv = calloc(1, sizeof(ASS_Renderer));
     if (!priv) {
         FT_Done_FreeType(ft);
         goto ass_init_exit;
@@ -322,8 +120,8 @@
     priv->text_info.max_glyphs = MAX_GLYPHS_INITIAL;
     priv->text_info.max_lines = MAX_LINES_INITIAL;
     priv->text_info.glyphs =
-        calloc(MAX_GLYPHS_INITIAL, sizeof(glyph_info_t));
-    priv->text_info.lines = calloc(MAX_LINES_INITIAL, sizeof(line_info_t));
+        calloc(MAX_GLYPHS_INITIAL, sizeof(GlyphInfo));
+    priv->text_info.lines = calloc(MAX_LINES_INITIAL, sizeof(LineInfo));
 
   ass_init_exit:
     if (priv)
@@ -334,7 +132,7 @@
     return priv;
 }
 
-void ass_set_cache_limits(ass_renderer_t *render_priv, int glyph_max,
+void ass_set_cache_limits(ASS_Renderer *render_priv, int glyph_max,
                           int bitmap_max)
 {
     render_priv->cache.glyph_max = glyph_max ? glyph_max : GLYPH_CACHE_MAX;
@@ -342,12 +140,12 @@
                                          BITMAP_CACHE_MAX_SIZE;
 }
 
-static void free_list_clear(ass_renderer_t *render_priv)
+static void free_list_clear(ASS_Renderer *render_priv)
 {
     if (render_priv->free_head) {
-        free_list_t *item = render_priv->free_head;
+        FreeList *item = render_priv->free_head;
         while(item) {
-            free_list_t *oi = item;
+            FreeList *oi = item;
             free(item->object);
             item = item->next;
             free(oi);
@@ -356,9 +154,9 @@
     }
 }
 
-static void ass_free_images(ass_image_t *img);
+static void ass_free_images(ASS_Image *img);
 
-void ass_renderer_done(ass_renderer_t *render_priv)
+void ass_renderer_done(ASS_Renderer *render_priv)
 {
     ass_font_cache_done(render_priv->cache.font_cache);
     ass_bitmap_cache_done(render_priv->cache.bitmap_cache);
@@ -391,14 +189,14 @@
 }
 
 /**
- * \brief Create a new ass_image_t
- * Parameters are the same as ass_image_t fields.
+ * \brief Create a new ASS_Image
+ * Parameters are the same as ASS_Image fields.
  */
-static ass_image_t *my_draw_bitmap(unsigned char *bitmap, int bitmap_w,
-                                   int bitmap_h, int stride, int dst_x,
-                                   int dst_y, uint32_t color)
+static ASS_Image *my_draw_bitmap(unsigned char *bitmap, int bitmap_w,
+                                 int bitmap_h, int stride, int dst_x,
+                                 int dst_y, uint32_t color)
 {
-    ass_image_t *img = calloc(1, sizeof(ass_image_t));
+    ASS_Image *img = calloc(1, sizeof(ASS_Image));
 
     img->w = bitmap_w;
     img->h = bitmap_h;
@@ -411,18 +209,11 @@
     return img;
 }
 
-static double x2scr_pos(ass_renderer_t *render_priv, double x);
-static double y2scr_pos(ass_renderer_t *render_priv, double y);
+static double x2scr_pos(ASS_Renderer *render_priv, double x);
+static double y2scr_pos(ASS_Renderer *render_priv, double y);
 
-typedef struct {
-    int x0;
-    int y0;
-    int x1;
-    int y1;
-} rect_t;
-
 /*
- * \brief Convert bitmap glyphs into ass_image_t list with inverse clipping
+ * \brief Convert bitmap glyphs into ASS_Image list with inverse clipping
  *
  * Inverse clipping with the following strategy:
  * - find rectangle from (x0, y0) to (cx0, y1)
@@ -434,14 +225,14 @@
  * In an additional pass, the rectangles need to be split up left/right for
  * karaoke effects.  This can result in a lot of bitmaps (6 to be exact).
  */
-static ass_image_t **render_glyph_i(ass_renderer_t *render_priv,
-                                    bitmap_t *bm, int dst_x, int dst_y,
-                                    uint32_t color, uint32_t color2, int brk,
-                                    ass_image_t **tail)
+static ASS_Image **render_glyph_i(ASS_Renderer *render_priv,
+                                  Bitmap *bm, int dst_x, int dst_y,
+                                  uint32_t color, uint32_t color2, int brk,
+                                  ASS_Image **tail)
 {
     int i, j, x0, y0, x1, y1, cx0, cy0, cx1, cy1, sx, sy, zx, zy;
-    rect_t r[4];
-    ass_image_t *img;
+    Rect r[4];
+    ASS_Image *img;
 
     dst_x += bm->left;
     dst_y += bm->top;
@@ -521,7 +312,7 @@
 }
 
 /**
- * \brief convert bitmap glyph into ass_image_t struct(s)
+ * \brief convert bitmap glyph into ASS_Image struct(s)
  * \param bit freetype bitmap glyph, FT_PIXEL_MODE_GRAY
  * \param dst_x bitmap x coordinate in video frame
  * \param dst_y bitmap y coordinate in video frame
@@ -532,10 +323,9 @@
  * \return pointer to the new list tail
  * Performs clipping. Uses my_draw_bitmap for actual bitmap convertion.
  */
-static ass_image_t **render_glyph(ass_renderer_t *render_priv,
-                                  bitmap_t *bm, int dst_x, int dst_y,
-                                  uint32_t color, uint32_t color2, int brk,
-                                  ass_image_t **tail)
+static ASS_Image **
+render_glyph(ASS_Renderer *render_priv, Bitmap *bm, int dst_x, int dst_y,
+             uint32_t color, uint32_t color2, int brk, ASS_Image **tail)
 {
     // Inverse clipping in use?
     if (render_priv->state.clip_mode)
@@ -548,7 +338,7 @@
     int b_x0, b_y0, b_x1, b_y1; // visible part of the bitmap
     int clip_x0, clip_y0, clip_x1, clip_y1;
     int tmp;
-    ass_image_t *img;
+    ASS_Image *img;
 
     dst_x += bm->left;
     dst_y += bm->top;
@@ -610,11 +400,11 @@
 }
 
 /**
- * \brief Replace the bitmap buffer in ass_image_t with a copy
- * \param img ass_image_t to operate on
+ * \brief Replace the bitmap buffer in ASS_Image with a copy
+ * \param img ASS_Image to operate on
  * \return pointer to old bitmap buffer
  */
-static unsigned char *clone_bitmap_buffer(ass_image_t *img)
+static unsigned char *clone_bitmap_buffer(ASS_Image *img)
 {
     unsigned char *old_bitmap = img->bitmap;
     int size = img->stride * (img->h - 1) + img->w;
@@ -625,22 +415,21 @@
 
 /**
  * \brief Calculate overlapping area of two consecutive bitmaps and in case they
- * overlap, composite them together
+ * overlap, blend them together
  * Mainly useful for translucent glyphs and especially borders, to avoid the
  * luminance adding up where they overlap (which looks ugly)
  */
 static void
-render_overlap(ass_renderer_t *render_priv, ass_image_t **last_tail,
-               ass_image_t **tail, bitmap_hash_key_t *last_hash,
-               bitmap_hash_key_t *hash)
+render_overlap(ASS_Renderer *render_priv, ASS_Image **last_tail,
+               ASS_Image **tail)
 {
     int left, top, bottom, right;
     int old_left, old_top, w, h, cur_left, cur_top;
     int x, y, opos, cpos;
     char m;
-    composite_hash_key_t hk;
-    composite_hash_val_t *hv;
-    composite_hash_val_t chv;
+    CompositeHashKey hk;
+    CompositeHashValue *hv;
+    CompositeHashValue chv;
     int ax = (*last_tail)->dst_x;
     int ay = (*last_tail)->dst_y;
     int aw = (*last_tail)->w;
@@ -676,8 +465,8 @@
 
     // Query cache
     memset(&hk, 0, sizeof(hk));
-    memcpy(&hk.a, last_hash, sizeof(*last_hash));
-    memcpy(&hk.b, hash, sizeof(*hash));
+    hk.a = (*last_tail)->bitmap;
+    hk.b = (*tail)->bitmap;
     hk.aw = aw;
     hk.ah = ah;
     hk.bw = bw;
@@ -686,6 +475,8 @@
     hk.ay = ay;
     hk.bx = bx;
     hk.by = by;
+    hk.as = as;
+    hk.bs = bs;
     hv = cache_find_composite(render_priv->cache.composite_cache, &hk);
     if (hv) {
         (*last_tail)->bitmap = hv->a;
@@ -696,12 +487,12 @@
     a = clone_bitmap_buffer(*last_tail);
     b = clone_bitmap_buffer(*tail);
 
-    // Composite overlapping area
+    // Blend overlapping area
     for (y = 0; y < h; y++)
         for (x = 0; x < w; x++) {
             opos = (old_top + y) * (as) + (old_left + x);
             cpos = (cur_top + y) * (bs) + (cur_left + x);
-            m = (a[opos] > b[cpos]) ? a[opos] : b[cpos];
+            m = FFMIN(a[opos] + b[cpos], 0xff);
             (*last_tail)->bitmap[opos] = 0;
             (*tail)->bitmap[cpos] = m;
         }
@@ -712,14 +503,14 @@
     cache_add_composite(render_priv->cache.composite_cache, &hk, &chv);
 }
 
-static void free_list_add(ass_renderer_t *render_priv, void *object)
+static void free_list_add(ASS_Renderer *render_priv, void *object)
 {
     if (!render_priv->free_head) {
-        render_priv->free_head = calloc(1, sizeof(free_list_t));
+        render_priv->free_head = calloc(1, sizeof(FreeList));
         render_priv->free_head->object = object;
         render_priv->free_tail = render_priv->free_head;
     } else {
-        free_list_t *l = calloc(1, sizeof(free_list_t));
+        FreeList *l = calloc(1, sizeof(FreeList));
         l->object = object;
         render_priv->free_tail->next = l;
         render_priv->free_tail = render_priv->free_tail->next;
@@ -731,13 +522,13 @@
  * applicable. The blended bitmaps are added to a free list which is freed
  * at the start of a new frame.
  */
-static void blend_vector_clip(ass_renderer_t *render_priv,
-                              ass_image_t *head)
+static void blend_vector_clip(ASS_Renderer *render_priv,
+                              ASS_Image *head)
 {
     FT_Glyph glyph;
     FT_BitmapGlyph clip_bm;
-    ass_image_t *cur;
-    ass_drawing_t *drawing = render_priv->state.clip_drawing;
+    ASS_Image *cur;
+    ASS_Drawing *drawing = render_priv->state.clip_drawing;
     int error;
 
     if (!drawing)
@@ -801,7 +592,7 @@
             free_list_add(render_priv, nbuffer);
 
             // Blend together
-            memcpy(nbuffer, abuffer, as * ah);
+            memcpy(nbuffer, abuffer, as * (ah - 1) + aw);
             for (y = 0; y < h; y++)
                 for (x = 0; x < w; x++) {
                     apos = (atop + y) * as + aleft + x;
@@ -839,26 +630,25 @@
 }
 
 /**
- * \brief Convert text_info_t struct to ass_image_t list
+ * \brief Convert TextInfo struct to ASS_Image list
  * Splits glyphs in halves when needed (for \kf karaoke).
  */
-static ass_image_t *render_text(ass_renderer_t *render_priv, int dst_x,
+static ASS_Image *render_text(ASS_Renderer *render_priv, int dst_x,
                                 int dst_y)
 {
     int pen_x, pen_y;
     int i;
-    bitmap_t *bm;
-    ass_image_t *head;
-    ass_image_t **tail = &head;
-    ass_image_t **last_tail = 0;
-    ass_image_t **here_tail = 0;
-    bitmap_hash_key_t *last_hash = 0;
-    text_info_t *text_info = &render_priv->text_info;
+    Bitmap *bm;
+    ASS_Image *head;
+    ASS_Image **tail = &head;
+    ASS_Image **last_tail = 0;
+    ASS_Image **here_tail = 0;
+    TextInfo *text_info = &render_priv->text_info;
 
     for (i = 0; i < text_info->length; ++i) {
-        glyph_info_t *info = text_info->glyphs + i;
+        GlyphInfo *info = text_info->glyphs + i;
         if ((info->symbol == 0) || (info->symbol == '\n') || !info->bm_s
-            || (info->shadow_x == 0 && info->shadow_y == 0))
+            || (info->shadow_x == 0 && info->shadow_y == 0) || info->skip)
             continue;
 
         pen_x =
@@ -874,16 +664,16 @@
             render_glyph(render_priv, bm, pen_x, pen_y, info->c[3], 0,
                          1000000, tail);
         if (last_tail && tail != here_tail && ((info->c[3] & 0xff) > 0))
-            render_overlap(render_priv, last_tail, here_tail, last_hash,
-                           &info->hash_key);
+            render_overlap(render_priv, last_tail, here_tail);
+
         last_tail = here_tail;
-        last_hash = &info->hash_key;
     }
 
     last_tail = 0;
     for (i = 0; i < text_info->length; ++i) {
-        glyph_info_t *info = text_info->glyphs + i;
-        if ((info->symbol == 0) || (info->symbol == '\n') || !info->bm_o)
+        GlyphInfo *info = text_info->glyphs + i;
+        if ((info->symbol == 0) || (info->symbol == '\n') || !info->bm_o
+            || info->skip)
             continue;
 
         pen_x = dst_x + (info->pos.x >> 6);
@@ -899,15 +689,16 @@
                 render_glyph(render_priv, bm, pen_x, pen_y, info->c[2],
                              0, 1000000, tail);
             if (last_tail && tail != here_tail && ((info->c[2] & 0xff) > 0))
-                render_overlap(render_priv, last_tail, here_tail,
-                               last_hash, &info->hash_key);
+                render_overlap(render_priv, last_tail, here_tail);
+
             last_tail = here_tail;
-            last_hash = &info->hash_key;
         }
     }
+
     for (i = 0; i < text_info->length; ++i) {
-        glyph_info_t *info = text_info->glyphs + i;
-        if ((info->symbol == 0) || (info->symbol == '\n') || !info->bm)
+        GlyphInfo *info = text_info->glyphs + i;
+        if ((info->symbol == 0) || (info->symbol == '\n') || !info->bm
+            || info->skip)
             continue;
 
         pen_x = dst_x + (info->pos.x >> 6);
@@ -943,13 +734,13 @@
 /**
  * \brief Mapping between script and screen coordinates
  */
-static double x2scr(ass_renderer_t *render_priv, double x)
+static double x2scr(ASS_Renderer *render_priv, double x)
 {
     return x * render_priv->orig_width_nocrop /
         render_priv->track->PlayResX +
         FFMAX(render_priv->settings.left_margin, 0);
 }
-static double x2scr_pos(ass_renderer_t *render_priv, double x)
+static double x2scr_pos(ASS_Renderer *render_priv, double x)
 {
     return x * render_priv->orig_width / render_priv->track->PlayResX +
         render_priv->settings.left_margin;
@@ -958,20 +749,20 @@
 /**
  * \brief Mapping between script and screen coordinates
  */
-static double y2scr(ass_renderer_t *render_priv, double y)
+static double y2scr(ASS_Renderer *render_priv, double y)
 {
     return y * render_priv->orig_height_nocrop /
         render_priv->track->PlayResY +
         FFMAX(render_priv->settings.top_margin, 0);
 }
-static double y2scr_pos(ass_renderer_t *render_priv, double y)
+static double y2scr_pos(ASS_Renderer *render_priv, double y)
 {
     return y * render_priv->orig_height / render_priv->track->PlayResY +
         render_priv->settings.top_margin;
 }
 
 // the same for toptitles
-static double y2scr_top(ass_renderer_t *render_priv, double y)
+static double y2scr_top(ASS_Renderer *render_priv, double y)
 {
     if (render_priv->settings.use_margins)
         return y * render_priv->orig_height_nocrop /
@@ -983,7 +774,7 @@
 }
 
 // the same for subtitles
-static double y2scr_sub(ass_renderer_t *render_priv, double y)
+static double y2scr_sub(ASS_Renderer *render_priv, double y)
 {
     if (render_priv->settings.use_margins)
         return y * render_priv->orig_height_nocrop /
@@ -996,7 +787,7 @@
             FFMAX(render_priv->settings.top_margin, 0);
 }
 
-static void compute_string_bbox(text_info_t *info, double_bbox_t *bbox)
+static void compute_string_bbox(TextInfo *info, DBBox *bbox)
 {
     int i;
 
@@ -1008,6 +799,7 @@
                      d6_to_double(info->glyphs[0].pos.y);
 
         for (i = 0; i < info->length; ++i) {
+            if (info->glyphs[i].skip) continue;
             double s = d6_to_double(info->glyphs[i].pos.x);
             double e = s + d6_to_double(info->glyphs[i].advance.x);
             bbox->xMin = FFMIN(bbox->xMin, s);
@@ -1017,911 +809,11 @@
         bbox->xMin = bbox->xMax = bbox->yMin = bbox->yMax = 0.;
 }
 
-
 /**
- * \brief Check if starting part of (*p) matches sample. If true, shift p to the first symbol after the matching part.
- */
-static inline int mystrcmp(char **p, const char *sample)
-{
-    int len = strlen(sample);
-    if (strncmp(*p, sample, len) == 0) {
-        (*p) += len;
-        return 1;
-    } else
-        return 0;
-}
-
-static void change_font_size(ass_renderer_t *render_priv, double sz)
-{
-    double size = sz * render_priv->font_scale;
-
-    if (size < 1)
-        size = 1;
-    else if (size > render_priv->height * 2)
-        size = render_priv->height * 2;
-
-    ass_font_set_size(render_priv->state.font, size);
-
-    render_priv->state.font_size = sz;
-}
-
-/**
- * \brief Change current font, using setting from render_priv->state.
- */
-static void update_font(ass_renderer_t *render_priv)
-{
-    unsigned val;
-    ass_font_desc_t desc;
-    desc.family = strdup(render_priv->state.family);
-    desc.treat_family_as_pattern =
-        render_priv->state.treat_family_as_pattern;
-
-    val = render_priv->state.bold;
-    // 0 = normal, 1 = bold, >1 = exact weight
-    if (val == 1 || val == -1)
-        val = 200;              // bold
-    else if (val <= 0)
-        val = 80;               // normal
-    desc.bold = val;
-
-    val = render_priv->state.italic;
-    if (val == 1 || val == -1)
-        val = 110;              // italic
-    else if (val <= 0)
-        val = 0;                // normal
-    desc.italic = val;
-
-    render_priv->state.font =
-        ass_font_new(render_priv->cache.font_cache, render_priv->library,
-                     render_priv->ftlibrary, render_priv->fontconfig_priv,
-                     &desc);
-    free(desc.family);
-
-    if (render_priv->state.font)
-        change_font_size(render_priv, render_priv->state.font_size);
-}
-
-/**
- * \brief Change border width
- * negative value resets border to style value
- */
-static void change_border(ass_renderer_t *render_priv, double border_x,
-                          double border_y)
-{
-    int bord;
-    if (!render_priv->state.font)
-        return;
-
-    if (border_x < 0 && border_y < 0) {
-        if (render_priv->state.style->BorderStyle == 1)
-            border_x = border_y = render_priv->state.style->Outline;
-        else
-            border_x = border_y = 1.;
-    }
-
-    render_priv->state.border_x = border_x;
-    render_priv->state.border_y = border_y;
-
-    bord = 64 * border_x * render_priv->border_scale;
-    if (bord > 0 && border_x == border_y) {
-        if (!render_priv->state.stroker) {
-            int error;
-#if (FREETYPE_MAJOR > 2) || ((FREETYPE_MAJOR == 2) && (FREETYPE_MINOR > 1))
-            error =
-                FT_Stroker_New(render_priv->ftlibrary,
-                               &render_priv->state.stroker);
-#else                           // < 2.2
-            error =
-                FT_Stroker_New(render_priv->state.font->faces[0]->
-                               memory, &render_priv->state.stroker);
-#endif
-            if (error) {
-                ass_msg(render_priv->library, MSGL_V,
-                        "failed to get stroker");
-                render_priv->state.stroker = 0;
-            }
-        }
-        if (render_priv->state.stroker)
-            FT_Stroker_Set(render_priv->state.stroker, bord,
-                           FT_STROKER_LINECAP_ROUND,
-                           FT_STROKER_LINEJOIN_ROUND, 0);
-    } else {
-        FT_Stroker_Done(render_priv->state.stroker);
-        render_priv->state.stroker = 0;
-    }
-}
-
-#define _r(c)  ((c)>>24)
-#define _g(c)  (((c)>>16)&0xFF)
-#define _b(c)  (((c)>>8)&0xFF)
-#define _a(c)  ((c)&0xFF)
-
-/**
- * \brief Calculate a weighted average of two colors
- * calculates c1*(1-a) + c2*a, but separately for each component except alpha
- */
-static void change_color(uint32_t *var, uint32_t new, double pwr)
-{
-    (*var) = ((uint32_t) (_r(*var) * (1 - pwr) + _r(new) * pwr) << 24) +
-        ((uint32_t) (_g(*var) * (1 - pwr) + _g(new) * pwr) << 16) +
-        ((uint32_t) (_b(*var) * (1 - pwr) + _b(new) * pwr) << 8) + _a(*var);
-}
-
-// like change_color, but for alpha component only
-static void change_alpha(uint32_t *var, uint32_t new, double pwr)
-{
-    *var =
-        (_r(*var) << 24) + (_g(*var) << 16) + (_b(*var) << 8) +
-        (_a(*var) * (1 - pwr) + _a(new) * pwr);
-}
-
-/**
- * \brief Multiply two alpha values
- * \param a first value
- * \param b second value
- * \return result of multiplication
- * Parameters and result are limited by 0xFF.
- */
-static uint32_t mult_alpha(uint32_t a, uint32_t b)
-{
-    return 0xFF - (0xFF - a) * (0xFF - b) / 0xFF;
-}
-
-/**
- * \brief Calculate alpha value by piecewise linear function
- * Used for \fad, \fade implementation.
- */
-static unsigned
-interpolate_alpha(long long now,
-                  long long t1, long long t2, long long t3, long long t4,
-                  unsigned a1, unsigned a2, unsigned a3)
-{
-    unsigned a;
-    double cf;
-    if (now <= t1) {
-        a = a1;
-    } else if (now >= t4) {
-        a = a3;
-    } else if (now < t2) {      // and > t1
-        cf = ((double) (now - t1)) / (t2 - t1);
-        a = a1 * (1 - cf) + a2 * cf;
-    } else if (now > t3) {
-        cf = ((double) (now - t3)) / (t4 - t3);
-        a = a2 * (1 - cf) + a3 * cf;
-    } else {                    // t2 <= now <= t3
-        a = a2;
-    }
-
-    return a;
-}
-
-#define skip_to(x) while ((*p != (x)) && (*p != '}') && (*p != 0)) { ++p;}
-#define skip(x) if (*p == (x)) ++p; else { return p; }
-#define skipopt(x) if (*p == (x)) { ++p; }
-
-/**
- * Parse a vector clip into an outline, using the proper scaling
- * parameters.  Translate it to correct for screen borders, if needed.
- */
-static char *parse_vector_clip(ass_renderer_t *render_priv, char *p)
-{
-    int scale = 1;
-    int res = 0;
-    ass_drawing_t *drawing;
-    render_priv->state.clip_drawing = ass_drawing_new(
-        render_priv->fontconfig_priv,
-        render_priv->state.font,
-        render_priv->settings.hinting,
-        render_priv->ftlibrary);
-    drawing = render_priv->state.clip_drawing;
-    skipopt('(');
-    res = mystrtoi(&p, &scale);
-    skipopt(',')
-    if (!res)
-        scale = 1;
-    drawing->scale = scale;
-    drawing->scale_x = render_priv->font_scale_x * render_priv->font_scale;
-    drawing->scale_y = render_priv->font_scale;
-    while (*p != ')' && *p != '}' && p != 0)
-        ass_drawing_add_char(drawing, *p++);
-    skipopt(')');
-    ass_drawing_parse(drawing, 1);
-    // We need to translate the clip according to screen borders
-    if (render_priv->settings.left_margin != 0 ||
-        render_priv->settings.top_margin != 0) {
-        FT_Vector trans = {
-            .x = int_to_d6(render_priv->settings.left_margin),
-            .y = -int_to_d6(render_priv->settings.top_margin),
-        };
-        FT_Outline_Translate(&drawing->glyph->outline, trans.x, trans.y);
-    }
-    ass_msg(render_priv->library, MSGL_DBG2,
-            "Parsed vector clip: scale %d, scales (%f, %f) string [%s]\n",
-            scale, drawing->scale_x, drawing->scale_y, drawing->text);
-
-    return p;
-}
-
-static void reset_render_context(ass_renderer_t *);
-
-/**
- * \brief Parse style override tag.
- * \param p string to parse
- * \param pwr multiplier for some tag effects (comes from \t tags)
- */
-static char *parse_tag(ass_renderer_t *render_priv, char *p, double pwr)
-{
-    skip_to('\\');
-    skip('\\');
-    if ((*p == '}') || (*p == 0))
-        return p;
-
-    // New tags introduced in vsfilter 2.39
-    if (mystrcmp(&p, "xbord")) {
-        double val;
-        if (mystrtod(&p, &val))
-            val = render_priv->state.border_x * (1 - pwr) + val * pwr;
-        else
-            val = -1.;
-        change_border(render_priv, val, render_priv->state.border_y);
-    } else if (mystrcmp(&p, "ybord")) {
-        double val;
-        if (mystrtod(&p, &val))
-            val = render_priv->state.border_y * (1 - pwr) + val * pwr;
-        else
-            val = -1.;
-        change_border(render_priv, render_priv->state.border_x, val);
-    } else if (mystrcmp(&p, "xshad")) {
-        double val;
-        if (mystrtod(&p, &val))
-            val = render_priv->state.shadow_x * (1 - pwr) + val * pwr;
-        else
-            val = 0.;
-        render_priv->state.shadow_x = val;
-    } else if (mystrcmp(&p, "yshad")) {
-        double val;
-        if (mystrtod(&p, &val))
-            val = render_priv->state.shadow_y * (1 - pwr) + val * pwr;
-        else
-            val = 0.;
-        render_priv->state.shadow_y = val;
-    } else if (mystrcmp(&p, "fax")) {
-        double val;
-        if (mystrtod(&p, &val))
-            render_priv->state.fax =
-                val * pwr + render_priv->state.fax * (1 - pwr);
-        else
-            render_priv->state.fax = 0.;
-    } else if (mystrcmp(&p, "fay")) {
-        double val;
-        if (mystrtod(&p, &val))
-            render_priv->state.fay =
-                val * pwr + render_priv->state.fay * (1 - pwr);
-        else
-            render_priv->state.fay = 0.;
-    } else if (mystrcmp(&p, "iclip")) {
-        int x0, y0, x1, y1;
-        int res = 1;
-        char *start = p;
-        skipopt('(');
-        res &= mystrtoi(&p, &x0);
-        skipopt(',');
-        res &= mystrtoi(&p, &y0);
-        skipopt(',');
-        res &= mystrtoi(&p, &x1);
-        skipopt(',');
-        res &= mystrtoi(&p, &y1);
-        skipopt(')');
-        if (res) {
-            render_priv->state.clip_x0 =
-                render_priv->state.clip_x0 * (1 - pwr) + x0 * pwr;
-            render_priv->state.clip_x1 =
-                render_priv->state.clip_x1 * (1 - pwr) + x1 * pwr;
-            render_priv->state.clip_y0 =
-                render_priv->state.clip_y0 * (1 - pwr) + y0 * pwr;
-            render_priv->state.clip_y1 =
-                render_priv->state.clip_y1 * (1 - pwr) + y1 * pwr;
-            render_priv->state.clip_mode = 1;
-        } else if (!render_priv->state.clip_drawing) {
-            p = parse_vector_clip(render_priv, start);
-            render_priv->state.clip_drawing_mode = 1;
-        } else
-            render_priv->state.clip_mode = 0;
-    } else if (mystrcmp(&p, "blur")) {
-        double val;
-        if (mystrtod(&p, &val)) {
-            val = render_priv->state.blur * (1 - pwr) + val * pwr;
-            val = (val < 0) ? 0 : val;
-            val = (val > BLUR_MAX_RADIUS) ? BLUR_MAX_RADIUS : val;
-            render_priv->state.blur = val;
-        } else
-            render_priv->state.blur = 0.0;
-        // ASS standard tags
-    } else if (mystrcmp(&p, "fsc")) {
-        char tp = *p++;
-        double val;
-        if (tp == 'x') {
-            if (mystrtod(&p, &val)) {
-                val /= 100;
-                render_priv->state.scale_x =
-                    render_priv->state.scale_x * (1 - pwr) + val * pwr;
-            } else
-                render_priv->state.scale_x =
-                    render_priv->state.style->ScaleX;
-        } else if (tp == 'y') {
-            if (mystrtod(&p, &val)) {
-                val /= 100;
-                render_priv->state.scale_y =
-                    render_priv->state.scale_y * (1 - pwr) + val * pwr;
-            } else
-                render_priv->state.scale_y =
-                    render_priv->state.style->ScaleY;
-        }
-    } else if (mystrcmp(&p, "fsp")) {
-        double val;
-        if (mystrtod(&p, &val))
-            render_priv->state.hspacing =
-                render_priv->state.hspacing * (1 - pwr) + val * pwr;
-        else
-            render_priv->state.hspacing = render_priv->state.style->Spacing;
-    } else if (mystrcmp(&p, "fs")) {
-        double val;
-        if (mystrtod(&p, &val))
-            val = render_priv->state.font_size * (1 - pwr) + val * pwr;
-        else
-            val = render_priv->state.style->FontSize;
-        if (render_priv->state.font)
-            change_font_size(render_priv, val);
-    } else if (mystrcmp(&p, "bord")) {
-        double val;
-        if (mystrtod(&p, &val)) {
-            if (render_priv->state.border_x == render_priv->state.border_y)
-                val = render_priv->state.border_x * (1 - pwr) + val * pwr;
-        } else
-            val = -1.;          // reset to default
-        change_border(render_priv, val, val);
-    } else if (mystrcmp(&p, "move")) {
-        double x1, x2, y1, y2;
-        long long t1, t2, delta_t, t;
-        double x, y;
-        double k;
-        skip('(');
-        mystrtod(&p, &x1);
-        skip(',');
-        mystrtod(&p, &y1);
-        skip(',');
-        mystrtod(&p, &x2);
-        skip(',');
-        mystrtod(&p, &y2);
-        if (*p == ',') {
-            skip(',');
-            mystrtoll(&p, &t1);
-            skip(',');
-            mystrtoll(&p, &t2);
-            ass_msg(render_priv->library, MSGL_DBG2,
-                   "movement6: (%f, %f) -> (%f, %f), (%" PRId64 " .. %"
-                   PRId64 ")\n", x1, y1, x2, y2, (int64_t) t1,
-                   (int64_t) t2);
-        } else {
-            t1 = 0;
-            t2 = render_priv->state.event->Duration;
-            ass_msg(render_priv->library, MSGL_DBG2,
-                   "movement: (%f, %f) -> (%f, %f)", x1, y1, x2, y2);
-        }
-        skip(')');
-        delta_t = t2 - t1;
-        t = render_priv->time - render_priv->state.event->Start;
-        if (t < t1)
-            k = 0.;
-        else if (t > t2)
-            k = 1.;
-        else
-            k = ((double) (t - t1)) / delta_t;
-        x = k * (x2 - x1) + x1;
-        y = k * (y2 - y1) + y1;
-        if (render_priv->state.evt_type != EVENT_POSITIONED) {
-            render_priv->state.pos_x = x;
-            render_priv->state.pos_y = y;
-            render_priv->state.detect_collisions = 0;
-            render_priv->state.evt_type = EVENT_POSITIONED;
-        }
-    } else if (mystrcmp(&p, "frx")) {
-        double val;
-        if (mystrtod(&p, &val)) {
-            val *= M_PI / 180;
-            render_priv->state.frx =
-                val * pwr + render_priv->state.frx * (1 - pwr);
-        } else
-            render_priv->state.frx = 0.;
-    } else if (mystrcmp(&p, "fry")) {
-        double val;
-        if (mystrtod(&p, &val)) {
-            val *= M_PI / 180;
-            render_priv->state.fry =
-                val * pwr + render_priv->state.fry * (1 - pwr);
-        } else
-            render_priv->state.fry = 0.;
-    } else if (mystrcmp(&p, "frz") || mystrcmp(&p, "fr")) {
-        double val;
-        if (mystrtod(&p, &val)) {
-            val *= M_PI / 180;
-            render_priv->state.frz =
-                val * pwr + render_priv->state.frz * (1 - pwr);
-        } else
-            render_priv->state.frz =
-                M_PI * render_priv->state.style->Angle / 180.;
-    } else if (mystrcmp(&p, "fn")) {
-        char *start = p;
-        char *family;
-        skip_to('\\');
-        if (p > start) {
-            family = malloc(p - start + 1);
-            strncpy(family, start, p - start);
-            family[p - start] = '\0';
-        } else
-            family = strdup(render_priv->state.style->FontName);
-        if (render_priv->state.family)
-            free(render_priv->state.family);
-        render_priv->state.family = family;
-        update_font(render_priv);
-    } else if (mystrcmp(&p, "alpha")) {
-        uint32_t val;
-        int i;
-        if (strtocolor(render_priv->library, &p, &val)) {
-            unsigned char a = val >> 24;
-            for (i = 0; i < 4; ++i)
-                change_alpha(&render_priv->state.c[i], a, pwr);
-        } else {
-            change_alpha(&render_priv->state.c[0],
-                         render_priv->state.style->PrimaryColour, pwr);
-            change_alpha(&render_priv->state.c[1],
-                         render_priv->state.style->SecondaryColour, pwr);
-            change_alpha(&render_priv->state.c[2],
-                         render_priv->state.style->OutlineColour, pwr);
-            change_alpha(&render_priv->state.c[3],
-                         render_priv->state.style->BackColour, pwr);
-        }
-        // FIXME: simplify
-    } else if (mystrcmp(&p, "an")) {
-        int val;
-        if (mystrtoi(&p, &val) && val) {
-            int v = (val - 1) / 3;      // 0, 1 or 2 for vertical alignment
-            ass_msg(render_priv->library, MSGL_DBG2, "an %d", val);
-            if (v != 0)
-                v = 3 - v;
-            val = ((val - 1) % 3) + 1;  // horizontal alignment
-            val += v * 4;
-            ass_msg(render_priv->library, MSGL_DBG2, "align %d", val);
-            render_priv->state.alignment = val;
-        } else
-            render_priv->state.alignment =
-                render_priv->state.style->Alignment;
-    } else if (mystrcmp(&p, "a")) {
-        int val;
-        if (mystrtoi(&p, &val) && val)
-            render_priv->state.alignment = val;
-        else
-            render_priv->state.alignment =
-                render_priv->state.style->Alignment;
-    } else if (mystrcmp(&p, "pos")) {
-        double v1, v2;
-        skip('(');
-        mystrtod(&p, &v1);
-        skip(',');
-        mystrtod(&p, &v2);
-        skip(')');
-        ass_msg(render_priv->library, MSGL_DBG2, "pos(%f, %f)", v1, v2);
-        if (render_priv->state.evt_type == EVENT_POSITIONED) {
-            ass_msg(render_priv->library, MSGL_V, "Subtitle has a new \\pos "
-                   "after \\move or \\pos, ignoring");
-        } else {
-            render_priv->state.evt_type = EVENT_POSITIONED;
-            render_priv->state.detect_collisions = 0;
-            render_priv->state.pos_x = v1;
-            render_priv->state.pos_y = v2;
-        }
-    } else if (mystrcmp(&p, "fad")) {
-        int a1, a2, a3;
-        long long t1, t2, t3, t4;
-        if (*p == 'e')
-            ++p;                // either \fad or \fade
-        skip('(');
-        mystrtoi(&p, &a1);
-        skip(',');
-        mystrtoi(&p, &a2);
-        if (*p == ')') {
-            // 2-argument version (\fad, according to specs)
-            // a1 and a2 are fade-in and fade-out durations
-            t1 = 0;
-            t4 = render_priv->state.event->Duration;
-            t2 = a1;
-            t3 = t4 - a2;
-            a1 = 0xFF;
-            a2 = 0;
-            a3 = 0xFF;
-        } else {
-            // 6-argument version (\fade)
-            // a1 and a2 (and a3) are opacity values
-            skip(',');
-            mystrtoi(&p, &a3);
-            skip(',');
-            mystrtoll(&p, &t1);
-            skip(',');
-            mystrtoll(&p, &t2);
-            skip(',');
-            mystrtoll(&p, &t3);
-            skip(',');
-            mystrtoll(&p, &t4);
-        }
-        skip(')');
-        render_priv->state.fade =
-            interpolate_alpha(render_priv->time -
-                              render_priv->state.event->Start, t1, t2,
-                              t3, t4, a1, a2, a3);
-    } else if (mystrcmp(&p, "org")) {
-        int v1, v2;
-        skip('(');
-        mystrtoi(&p, &v1);
-        skip(',');
-        mystrtoi(&p, &v2);
-        skip(')');
-        ass_msg(render_priv->library, MSGL_DBG2, "org(%d, %d)", v1, v2);
-        if (!render_priv->state.have_origin) {
-            render_priv->state.org_x = v1;
-            render_priv->state.org_y = v2;
-            render_priv->state.have_origin = 1;
-            render_priv->state.detect_collisions = 0;
-        }
-    } else if (mystrcmp(&p, "t")) {
-        double v[3];
-        int v1, v2;
-        double v3;
-        int cnt;
-        long long t1, t2, t, delta_t;
-        double k;
-        skip('(');
-        for (cnt = 0; cnt < 3; ++cnt) {
-            if (*p == '\\')
-                break;
-            v[cnt] = strtod(p, &p);
-            skip(',');
-        }
-        if (cnt == 3) {
-            v1 = v[0];
-            v2 = (v[1] < v1) ? render_priv->state.event->Duration : v[1];
-            v3 = v[2];
-        } else if (cnt == 2) {
-            v1 = v[0];
-            v2 = (v[1] < v1) ? render_priv->state.event->Duration : v[1];
-            v3 = 1.;
-        } else if (cnt == 1) {
-            v1 = 0;
-            v2 = render_priv->state.event->Duration;
-            v3 = v[0];
-        } else {                // cnt == 0
-            v1 = 0;
-            v2 = render_priv->state.event->Duration;
-            v3 = 1.;
-        }
-        render_priv->state.detect_collisions = 0;
-        t1 = v1;
-        t2 = v2;
-        delta_t = v2 - v1;
-        if (v3 < 0.)
-            v3 = 0.;
-        t = render_priv->time - render_priv->state.event->Start;        // FIXME: move to render_context
-        if (t <= t1)
-            k = 0.;
-        else if (t >= t2)
-            k = 1.;
-        else {
-            assert(delta_t != 0.);
-            k = pow(((double) (t - t1)) / delta_t, v3);
-        }
-        while (*p == '\\')
-            p = parse_tag(render_priv, p, k);   // maybe k*pwr ? no, specs forbid nested \t's
-        skip_to(')');           // in case there is some unknown tag or a comment
-        skip(')');
-    } else if (mystrcmp(&p, "clip")) {
-        char *start = p;
-        int x0, y0, x1, y1;
-        int res = 1;
-        skipopt('(');
-        res &= mystrtoi(&p, &x0);
-        skipopt(',');
-        res &= mystrtoi(&p, &y0);
-        skipopt(',');
-        res &= mystrtoi(&p, &x1);
-        skipopt(',');
-        res &= mystrtoi(&p, &y1);
-        skipopt(')');
-        if (res) {
-            render_priv->state.clip_x0 =
-                render_priv->state.clip_x0 * (1 - pwr) + x0 * pwr;
-            render_priv->state.clip_x1 =
-                render_priv->state.clip_x1 * (1 - pwr) + x1 * pwr;
-            render_priv->state.clip_y0 =
-                render_priv->state.clip_y0 * (1 - pwr) + y0 * pwr;
-            render_priv->state.clip_y1 =
-                render_priv->state.clip_y1 * (1 - pwr) + y1 * pwr;
-        // Might be a vector clip
-        } else if (!render_priv->state.clip_drawing) {
-            p = parse_vector_clip(render_priv, start);
-            render_priv->state.clip_drawing_mode = 0;
-        } else {
-            render_priv->state.clip_x0 = 0;
-            render_priv->state.clip_y0 = 0;
-            render_priv->state.clip_x1 = render_priv->track->PlayResX;
-            render_priv->state.clip_y1 = render_priv->track->PlayResY;
-        }
-    } else if (mystrcmp(&p, "c")) {
-        uint32_t val;
-        if (!strtocolor(render_priv->library, &p, &val))
-            val = render_priv->state.style->PrimaryColour;
-        ass_msg(render_priv->library, MSGL_DBG2, "color: %X", val);
-        change_color(&render_priv->state.c[0], val, pwr);
-    } else if ((*p >= '1') && (*p <= '4') && (++p)
-               && (mystrcmp(&p, "c") || mystrcmp(&p, "a"))) {
-        char n = *(p - 2);
-        int cidx = n - '1';
-        char cmd = *(p - 1);
-        uint32_t val;
-        assert((n >= '1') && (n <= '4'));
-        if (!strtocolor(render_priv->library, &p, &val))
-            switch (n) {
-            case '1':
-                val = render_priv->state.style->PrimaryColour;
-                break;
-            case '2':
-                val = render_priv->state.style->SecondaryColour;
-                break;
-            case '3':
-                val = render_priv->state.style->OutlineColour;
-                break;
-            case '4':
-                val = render_priv->state.style->BackColour;
-                break;
-            default:
-                val = 0;
-                break;          // impossible due to assert; avoid compilation warning
-            }
-        switch (cmd) {
-        case 'c':
-            change_color(render_priv->state.c + cidx, val, pwr);
-            break;
-        case 'a':
-            change_alpha(render_priv->state.c + cidx, val >> 24, pwr);
-            break;
-        default:
-            ass_msg(render_priv->library, MSGL_WARN, "Bad command: %c%c",
-                    n, cmd);
-            break;
-        }
-        ass_msg(render_priv->library, MSGL_DBG2, "single c/a at %f: %c%c = %X",
-               pwr, n, cmd, render_priv->state.c[cidx]);
-    } else if (mystrcmp(&p, "r")) {
-        reset_render_context(render_priv);
-    } else if (mystrcmp(&p, "be")) {
-        int val;
-        if (mystrtoi(&p, &val)) {
-            // Clamp to a safe upper limit, since high values need excessive CPU
-            val = (val < 0) ? 0 : val;
-            val = (val > MAX_BE) ? MAX_BE : val;
-            render_priv->state.be = val;
-        } else
-            render_priv->state.be = 0;
-    } else if (mystrcmp(&p, "b")) {
-        int b;
-        if (mystrtoi(&p, &b)) {
-            if (pwr >= .5)
-                render_priv->state.bold = b;
-        } else
-            render_priv->state.bold = render_priv->state.style->Bold;
-        update_font(render_priv);
-    } else if (mystrcmp(&p, "i")) {
-        int i;
-        if (mystrtoi(&p, &i)) {
-            if (pwr >= .5)
-                render_priv->state.italic = i;
-        } else
-            render_priv->state.italic = render_priv->state.style->Italic;
-        update_font(render_priv);
-    } else if (mystrcmp(&p, "kf") || mystrcmp(&p, "K")) {
-        int val = 0;
-        mystrtoi(&p, &val);
-        render_priv->state.effect_type = EF_KARAOKE_KF;
-        if (render_priv->state.effect_timing)
-            render_priv->state.effect_skip_timing +=
-                render_priv->state.effect_timing;
-        render_priv->state.effect_timing = val * 10;
-    } else if (mystrcmp(&p, "ko")) {
-        int val = 0;
-        mystrtoi(&p, &val);
-        render_priv->state.effect_type = EF_KARAOKE_KO;
-        if (render_priv->state.effect_timing)
-            render_priv->state.effect_skip_timing +=
-                render_priv->state.effect_timing;
-        render_priv->state.effect_timing = val * 10;
-    } else if (mystrcmp(&p, "k")) {
-        int val = 0;
-        mystrtoi(&p, &val);
-        render_priv->state.effect_type = EF_KARAOKE;
-        if (render_priv->state.effect_timing)
-            render_priv->state.effect_skip_timing +=
-                render_priv->state.effect_timing;
-        render_priv->state.effect_timing = val * 10;
-    } else if (mystrcmp(&p, "shad")) {
-        double val;
-        if (mystrtod(&p, &val)) {
-            if (render_priv->state.shadow_x == render_priv->state.shadow_y)
-                val = render_priv->state.shadow_x * (1 - pwr) + val * pwr;
-        } else
-            val = 0.;
-        render_priv->state.shadow_x = render_priv->state.shadow_y = val;
-    } else if (mystrcmp(&p, "s")) {
-        int val;
-        if (mystrtoi(&p, &val) && val)
-            render_priv->state.flags |= DECO_STRIKETHROUGH;
-        else
-            render_priv->state.flags &= ~DECO_STRIKETHROUGH;
-    } else if (mystrcmp(&p, "u")) {
-        int val;
-        if (mystrtoi(&p, &val) && val)
-            render_priv->state.flags |= DECO_UNDERLINE;
-        else
-            render_priv->state.flags &= ~DECO_UNDERLINE;
-    } else if (mystrcmp(&p, "pbo")) {
-        double val = 0;
-        if (mystrtod(&p, &val))
-            render_priv->state.drawing->pbo = val;
-    } else if (mystrcmp(&p, "p")) {
-        int val;
-        if (!mystrtoi(&p, &val))
-            val = 0;
-        if (val)
-            render_priv->state.drawing->scale = val;
-        render_priv->state.drawing_mode = !!val;
-    }
-
-    return p;
-
-#undef skip
-#undef skipopt
-#undef skip_to
-}
-
-/**
- * \brief Get next ucs4 char from string, parsing and executing style overrides
- * \param str string pointer
- * \return ucs4 code of the next char
- * On return str points to the unparsed part of the string
- */
-static unsigned get_next_char(ass_renderer_t *render_priv, char **str)
-{
-    char *p = *str;
-    unsigned chr;
-    if (*p == '{') {            // '\0' goes here
-        p++;
-        while (1) {
-            p = parse_tag(render_priv, p, 1.);
-            if (*p == '}') {    // end of tag
-                p++;
-                if (*p == '{') {
-                    p++;
-                    continue;
-                } else
-                    break;
-            } else if (*p != '\\')
-                ass_msg(render_priv->library, MSGL_V,
-                        "Unable to parse: '%s'", p);
-            if (*p == 0)
-                break;
-        }
-    }
-    if (*p == '\t') {
-        ++p;
-        *str = p;
-        return ' ';
-    }
-    if (*p == '\\') {
-        if ((*(p + 1) == 'N')
-            || ((*(p + 1) == 'n')
-                && (render_priv->track->WrapStyle == 2))) {
-            p += 2;
-            *str = p;
-            return '\n';
-        } else if ((*(p + 1) == 'n') || (*(p + 1) == 'h')) {
-            p += 2;
-            *str = p;
-            return ' ';
-        }
-    }
-    chr = ass_utf8_get_char((char **) &p);
-    *str = p;
-    return chr;
-}
-
-static void
-apply_transition_effects(ass_renderer_t *render_priv, ass_event_t *event)
-{
-    int v[4];
-    int cnt;
-    char *p = event->Effect;
-
-    if (!p || !*p)
-        return;
-
-    cnt = 0;
-    while (cnt < 4 && (p = strchr(p, ';'))) {
-        v[cnt++] = atoi(++p);
-    }
-
-    if (strncmp(event->Effect, "Banner;", 7) == 0) {
-        int delay;
-        if (cnt < 1) {
-            ass_msg(render_priv->library, MSGL_V,
-                    "Error parsing effect: '%s'", event->Effect);
-            return;
-        }
-        if (cnt >= 2 && v[1] == 0)      // right-to-left
-            render_priv->state.scroll_direction = SCROLL_RL;
-        else                    // left-to-right
-            render_priv->state.scroll_direction = SCROLL_LR;
-
-        delay = v[0];
-        if (delay == 0)
-            delay = 1;          // ?
-        render_priv->state.scroll_shift =
-            (render_priv->time - render_priv->state.event->Start) / delay;
-        render_priv->state.evt_type = EVENT_HSCROLL;
-        return;
-    }
-
-    if (strncmp(event->Effect, "Scroll up;", 10) == 0) {
-        render_priv->state.scroll_direction = SCROLL_BT;
-    } else if (strncmp(event->Effect, "Scroll down;", 12) == 0) {
-        render_priv->state.scroll_direction = SCROLL_TB;
-    } else {
-        ass_msg(render_priv->library, MSGL_V,
-                "Unknown transition effect: '%s'", event->Effect);
-        return;
-    }
-    // parse scroll up/down parameters
-    {
-        int delay;
-        int y0, y1;
-        if (cnt < 3) {
-            ass_msg(render_priv->library, MSGL_V,
-                    "Error parsing effect: '%s'", event->Effect);
-            return;
-        }
-        delay = v[2];
-        if (delay == 0)
-            delay = 1;          // ?
-        render_priv->state.scroll_shift =
-            (render_priv->time - render_priv->state.event->Start) / delay;
-        if (v[0] < v[1]) {
-            y0 = v[0];
-            y1 = v[1];
-        } else {
-            y0 = v[1];
-            y1 = v[0];
-        }
-        if (y1 == 0)
-            y1 = render_priv->track->PlayResY;  // y0=y1=0 means fullscreen scrolling
-        render_priv->state.clip_y0 = y0;
-        render_priv->state.clip_y1 = y1;
-        render_priv->state.evt_type = EVENT_VSCROLL;
-        render_priv->state.detect_collisions = 0;
-    }
-
-}
-
-/**
  * \brief partially reset render_context to style values
  * Works like {\r}: resets some style overrides
  */
-static void reset_render_context(ass_renderer_t *render_priv)
+void reset_render_context(ASS_Renderer *render_priv)
 {
     render_priv->state.c[0] = render_priv->state.style->PrimaryColour;
     render_priv->state.c[1] = render_priv->state.style->SecondaryColour;
@@ -1952,6 +844,7 @@
     render_priv->state.frx = render_priv->state.fry = 0.;
     render_priv->state.frz = M_PI * render_priv->state.style->Angle / 180.;
     render_priv->state.fax = render_priv->state.fay = 0.;
+    render_priv->state.wrap_style = render_priv->track->WrapStyle;
 
     // FIXME: does not reset unsupported attributes.
 }
@@ -1960,7 +853,7 @@
  * \brief Start new event. Reset render_priv->state.
  */
 static void
-init_render_context(ass_renderer_t *render_priv, ass_event_t *event)
+init_render_context(ASS_Renderer *render_priv, ASS_Event *event)
 {
     render_priv->state.event = event;
     render_priv->state.style = render_priv->track->styles + event->Style;
@@ -1978,6 +871,7 @@
     render_priv->state.clip_y0 = 0;
     render_priv->state.clip_x1 = render_priv->track->PlayResX;
     render_priv->state.clip_y1 = render_priv->track->PlayResY;
+    render_priv->state.clip_mode = 0;
     render_priv->state.detect_collisions = 1;
     render_priv->state.fade = 0;
     render_priv->state.drawing_mode = 0;
@@ -1993,7 +887,7 @@
     apply_transition_effects(render_priv, event);
 }
 
-static void free_render_context(ass_renderer_t *render_priv)
+static void free_render_context(ASS_Renderer *render_priv)
 {
     free(render_priv->state.family);
     ass_drawing_free(render_priv->state.drawing);
@@ -2085,10 +979,68 @@
 }
 
 /*
+ * Replace the outline of a glyph by a contour which makes up a simple
+ * opaque rectangle.
+ */
+static void draw_opaque_box(ASS_Renderer *render_priv, uint32_t ch,
+                            FT_Glyph glyph, int sx, int sy)
+{
+    int asc = 0, desc = 0;
+    int i;
+    int adv = d16_to_d6(glyph->advance.x);
+    double scale_y = render_priv->state.scale_y;
+    double scale_x = render_priv->state.scale_x
+                     * render_priv->font_scale_x;
+    FT_OutlineGlyph og = (FT_OutlineGlyph) glyph;
+    FT_Outline *ol;
+
+    // to avoid gaps
+    sx = FFMAX(64, sx);
+    sy = FFMAX(64, sy);
+
+    if (ch == -1) {
+        asc = render_priv->state.drawing->asc;
+        desc = render_priv->state.drawing->desc;
+    } else {
+        ass_font_get_asc_desc(render_priv->state.font, ch, &asc, &desc);
+        asc  *= scale_y;
+        desc *= scale_y;
+    }
+
+    // Emulate the WTFish behavior of VSFilter, i.e. double-scale
+    // the sizes of the opaque box.
+    adv += double_to_d6(render_priv->state.hspacing * render_priv->font_scale
+                        * scale_x);
+    adv *= scale_x;
+    sx *= scale_x;
+    sy *= scale_y;
+    desc *= scale_y;
+    desc += asc * (scale_y - 1.0);
+
+    FT_Vector points[4] = {
+        { .x = -sx,         .y = asc + sy },
+        { .x = adv + sx,    .y = asc + sy },
+        { .x = adv + sx,    .y = -desc - sy },
+        { .x = -sx,         .y = -desc - sy },
+    };
+
+    FT_Outline_Done(render_priv->ftlibrary, &og->outline);
+    FT_Outline_New(render_priv->ftlibrary, 4, 1, &og->outline);
+
+    ol = &og->outline;
+    ol->n_points = ol->n_contours = 0;
+    for (i = 0; i < 4; i++) {
+        ol->points[ol->n_points] = points[i];
+        ol->tags[ol->n_points++] = 1;
+    }
+    ol->contours[ol->n_contours++] = ol->n_points - 1;
+}
+
+/*
  * Stroke an outline glyph in x/y direction.  Applies various fixups to get
  * around limitations of the FreeType stroker.
  */
-static void stroke_outline_glyph(ass_renderer_t *render_priv,
+static void stroke_outline_glyph(ASS_Renderer *render_priv,
                                  FT_OutlineGlyph *glyph, int sx, int sy)
 {
     if (sx <= 0 && sy <= 0)
@@ -2137,11 +1089,11 @@
  * The glyphs are returned in info->glyph and info->outline_glyph
  */
 static void
-get_outline_glyph(ass_renderer_t *render_priv, int symbol,
-                  glyph_info_t *info, ass_drawing_t *drawing)
+get_outline_glyph(ASS_Renderer *render_priv, int symbol, GlyphInfo *info,
+                  ASS_Drawing *drawing)
 {
-    glyph_hash_val_t *val;
-    glyph_hash_key_t key;
+    GlyphHashValue *val;
+    GlyphHashKey key;
     memset(&key, 0, sizeof(key));
 
     if (drawing->hash) {
@@ -2149,6 +1101,7 @@
         key.scale_y = double_to_d16(render_priv->state.scale_y);
         key.outline.x = render_priv->state.border_x * 0xFFFF;
         key.outline.y = render_priv->state.border_y * 0xFFFF;
+        key.border_style = render_priv->state.style->BorderStyle;
         key.drawing_hash = drawing->hash;
     } else {
         key.font = render_priv->state.font;
@@ -2161,8 +1114,9 @@
         key.outline.x = render_priv->state.border_x * 0xFFFF;
         key.outline.y = render_priv->state.border_y * 0xFFFF;
         key.flags = render_priv->state.flags;
+        key.border_style = render_priv->state.style->BorderStyle;
     }
-    memset(info, 0, sizeof(glyph_info_t));
+    memset(info, 0, sizeof(GlyphInfo));
 
     val = cache_find_glyph(render_priv->cache.glyph_cache, &key);
     if (val) {
@@ -2177,9 +1131,10 @@
             drawing->desc = val->desc;
         }
     } else {
-        glyph_hash_val_t v;
+        GlyphHashValue v;
         if (drawing->hash) {
-            ass_drawing_parse(drawing, 0);
+            if(!ass_drawing_parse(drawing, 0))
+                return;
             FT_Glyph_Copy((FT_Glyph) drawing->glyph, &info->glyph);
         } else {
             info->glyph =
@@ -2194,8 +1149,17 @@
         info->advance.y = d16_to_d6(info->glyph->advance.y);
         FT_Glyph_Get_CBox(info->glyph, FT_GLYPH_BBOX_SUBPIXELS, &info->bbox);
 
-        if (render_priv->state.border_x > 0 ||
-            render_priv->state.border_y > 0) {
+        if (render_priv->state.style->BorderStyle == 3 &&
+            (render_priv->state.border_x > 0||
+             render_priv->state.border_y > 0)) {
+            FT_Glyph_Copy(info->glyph, &info->outline_glyph);
+            draw_opaque_box(render_priv, symbol, info->outline_glyph,
+                            double_to_d6(render_priv->state.border_x *
+                                         render_priv->border_scale),
+                            double_to_d6(render_priv->state.border_y *
+                                         render_priv->border_scale));
+        } else if (render_priv->state.border_x > 0 ||
+                   render_priv->state.border_y > 0) {
 
             FT_Glyph_Copy(info->glyph, &info->outline_glyph);
             stroke_outline_glyph(render_priv,
@@ -2222,7 +1186,8 @@
 
 static void transform_3d(FT_Vector shift, FT_Glyph *glyph,
                          FT_Glyph *glyph2, double frx, double fry,
-                         double frz, double fax, double fay, double scale);
+                         double frz, double fax, double fay, double scale,
+                         int yshift);
 
 /**
  * \brief Get bitmaps for a glyph
@@ -2233,10 +1198,10 @@
  * They are returned in info->bm (glyph), info->bm_o (outline) and info->bm_s (shadow).
  */
 static void
-get_bitmap_glyph(ass_renderer_t *render_priv, glyph_info_t *info)
+get_bitmap_glyph(ASS_Renderer *render_priv, GlyphInfo *info)
 {
-    bitmap_hash_val_t *val;
-    bitmap_hash_key_t *key = &info->hash_key;
+    BitmapHashValue *val;
+    BitmapHashKey *key = &info->hash_key;
 
     val = cache_find_bitmap(render_priv->cache.bitmap_cache, key);
 
@@ -2246,17 +1211,22 @@
         info->bm_s = val->bm_s;
     } else {
         FT_Vector shift;
-        bitmap_hash_val_t hash_val;
+        BitmapHashValue hash_val;
         int error;
+        double fax_scaled, fay_scaled;
         info->bm = info->bm_o = info->bm_s = 0;
-        if (info->glyph && info->symbol != '\n' && info->symbol != 0) {
+        if (info->glyph && info->symbol != '\n' && info->symbol != 0
+            && !info->skip) {
             // calculating rotation shift vector (from rotation origin to the glyph basepoint)
             shift.x = info->hash_key.shift_x;
             shift.y = info->hash_key.shift_y;
+            fax_scaled = info->fax * render_priv->font_scale_x *
+                         render_priv->state.scale_x;
+            fay_scaled = info->fay * render_priv->state.scale_y;
             // apply rotation
             transform_3d(shift, &info->glyph, &info->outline_glyph,
-                         info->frx, info->fry, info->frz, info->fax,
-                         info->fay, render_priv->font_scale);
+                         info->frx, info->fry, info->frz, fax_scaled,
+                         fay_scaled, render_priv->font_scale, info->asc);
 
             // subpixel shift
             if (info->glyph)
@@ -2277,7 +1247,8 @@
                                     &info->bm, &info->bm_o,
                                     &info->bm_s, info->be,
                                     info->blur * render_priv->border_scale,
-                                    info->hash_key.shadow_offset);
+                                    info->hash_key.shadow_offset,
+                                    info->hash_key.border_style);
             if (error)
                 info->symbol = 0;
 
@@ -2304,12 +1275,12 @@
  *   lines[].asc
  *   lines[].desc
  */
-static void measure_text(ass_renderer_t *render_priv)
+static void measure_text(ASS_Renderer *render_priv)
 {
-    text_info_t *text_info = &render_priv->text_info;
+    TextInfo *text_info = &render_priv->text_info;
     int cur_line = 0;
     double max_asc = 0., max_desc = 0.;
-    glyph_info_t *last = NULL;
+    GlyphInfo *last = NULL;
     int i;
     int empty_line = 1;
     text_info->height = 0.;
@@ -2328,7 +1299,7 @@
         } else
             empty_line = 0;
         if (i < text_info->length) {
-            glyph_info_t *cur = text_info->glyphs + i;
+            GlyphInfo *cur = text_info->glyphs + i;
             if (d6_to_double(cur->asc) > max_asc)
                 max_asc = d6_to_double(cur->asc);
             if (d6_to_double(cur->desc) > max_desc)
@@ -2343,6 +1314,61 @@
 }
 
 /**
+ * Mark extra whitespace for later removal.
+ */
+#define IS_WHITESPACE(x) ((x->symbol == ' ' || x->symbol == '\n') \
+                          && !x->linebreak)
+static void trim_whitespace(ASS_Renderer *render_priv)
+{
+    int i, j;
+    GlyphInfo *cur;
+    TextInfo *ti = &render_priv->text_info;
+
+    // Mark trailing spaces
+    i = ti->length - 1;
+    cur = ti->glyphs + i;
+    while (i && IS_WHITESPACE(cur)) {
+        cur->skip++;
+        cur = ti->glyphs + --i;
+    }
+
+    // Mark leading whitespace
+    i = 0;
+    cur = ti->glyphs;
+    while (i < ti->length && IS_WHITESPACE(cur)) {
+        cur->skip++;
+        cur = ti->glyphs + ++i;
+    }
+
+    // Mark all extraneous whitespace inbetween
+    for (i = 0; i < ti->length; ++i) {
+        cur = ti->glyphs + i;
+        if (cur->linebreak) {
+            // Mark whitespace before
+            j = i - 1;
+            cur = ti->glyphs + j;
+            while (j && IS_WHITESPACE(cur)) {
+                cur->skip++;
+                cur = ti->glyphs + --j;
+            }
+            // A break itself can contain a whitespace, too
+            cur = ti->glyphs + i;
+            if (cur->symbol == ' ')
+                cur->skip++;
+            // Mark whitespace after
+            j = i + 1;
+            cur = ti->glyphs + j;
+            while (j < ti->length && IS_WHITESPACE(cur)) {
+                cur->skip++;
+                cur = ti->glyphs + ++j;
+            }
+            i = j - 1;
+        }
+    }
+}
+#undef IS_WHITESPACE
+
+/**
  * \brief rearrange text between lines
  * \param max_text_width maximal text line width in pixels
  * The algo is similar to the one in libvo/sub.c:
@@ -2350,19 +1376,21 @@
  * 2. Try moving words from the end of a line to the beginning of the next one while it reduces
  * the difference in lengths between this two lines.
  * The result may not be optimal, but usually is good enough.
+ *
+ * FIXME: implement style 0 and 3 correctly, add support for style 1
  */
 static void
-wrap_lines_smart(ass_renderer_t *render_priv, double max_text_width)
+wrap_lines_smart(ASS_Renderer *render_priv, double max_text_width)
 {
     int i;
-    glyph_info_t *cur, *s1, *e1, *s2, *s3, *w;
+    GlyphInfo *cur, *s1, *e1, *s2, *s3, *w;
     int last_space;
     int break_type;
     int exit;
     double pen_shift_x;
     double pen_shift_y;
     int cur_line;
-    text_info_t *text_info = &render_priv->text_info;
+    TextInfo *text_info = &render_priv->text_info;
 
     last_space = -1;
     text_info->n_lines = 1;
@@ -2384,7 +1412,7 @@
         }
 
         if ((len >= max_text_width)
-            && (render_priv->track->WrapStyle != 2)) {
+            && (render_priv->state.wrap_style != 2)) {
             break_type = 1;
             break_at = last_space;
             if (break_at == -1)
@@ -2404,7 +1432,7 @@
                 // Raise maximum number of lines
                 text_info->max_lines *= 2;
                 text_info->lines = realloc(text_info->lines,
-                                           sizeof(line_info_t) *
+                                           sizeof(LineInfo) *
                                            text_info->max_lines);
             }
             if (lead < text_info->length)
@@ -2425,7 +1453,7 @@
     }
 #define DIFF(x,y) (((x) < (y)) ? (y - x) : (x - y))
     exit = 0;
-    while (!exit) {
+    while (!exit && render_priv->state.wrap_style != 1) {
         exit = 1;
         w = s3 = text_info->glyphs;
         s1 = s2 = 0;
@@ -2479,13 +1507,23 @@
 #undef DIFF
 
     measure_text(render_priv);
+    trim_whitespace(render_priv);
 
     pen_shift_x = 0.;
     pen_shift_y = 0.;
     cur_line = 1;
+
+    i = 0;
+    cur = text_info->glyphs + i;
+    while (i < text_info->length && cur->skip)
+        cur = text_info->glyphs + ++i;
+    pen_shift_x = d6_to_double(-cur->pos.x);
+
     for (i = 0; i < text_info->length; ++i) {
         cur = text_info->glyphs + i;
         if (cur->linebreak) {
+            while (i < text_info->length && cur->skip && cur->symbol != '\n')
+                cur = text_info->glyphs + ++i;
             double height =
                 text_info->lines[cur_line - 1].desc +
                 text_info->lines[cur_line].asc;
@@ -2512,11 +1550,11 @@
  * 2. sets effect_timing for all glyphs to x coordinate of the border line between the left and right karaoke parts
  * (left part is filled with PrimaryColour, right one - with SecondaryColour).
  */
-static void process_karaoke_effects(ass_renderer_t *render_priv)
+static void process_karaoke_effects(ASS_Renderer *render_priv)
 {
-    glyph_info_t *cur, *cur2;
-    glyph_info_t *s1, *e1;      // start and end of the current word
-    glyph_info_t *s2;           // start of the next word
+    GlyphInfo *cur, *cur2;
+    GlyphInfo *s1, *e1;      // start and end of the current word
+    GlyphInfo *s2;           // start of the next word
     int i;
     int timing;                 // current timing
     int tm_start, tm_end;       // timings at start and end of the current word
@@ -2577,7 +1615,7 @@
  * \param alignment alignment
  * \param bx, by out: base point coordinates
  */
-static void get_base_point(double_bbox_t *bbox, int alignment, double *bx, double *by)
+static void get_base_point(DBBox *bbox, int alignment, double *bx, double *by)
 {
     const int halign = alignment & 3;
     const int valign = alignment & 12;
@@ -2613,9 +1651,9 @@
  * onto the screen plane.
  */
 static void
-transform_3d_points(FT_Vector shift, FT_Glyph glyph, double frx,
-                    double fry, double frz, double fax, double fay,
-                    double scale)
+transform_3d_points(FT_Vector shift, FT_Glyph glyph, double frx, double fry,
+                    double frz, double fax, double fay, double scale,
+                    int yshift)
 {
     double sx = sin(frx);
     double sy = sin(fry);
@@ -2630,7 +1668,7 @@
 
     dist = 20000 * scale;
     for (i = 0; i < outline->n_points; i++) {
-        x = (double) p[i].x + shift.x + (-fax * p[i].y);
+        x = (double) p[i].x + shift.x + (fax * (yshift - p[i].y));
         y = (double) p[i].y + shift.y + (-fay * p[i].x);
         z = 0.;
 
@@ -2668,18 +1706,18 @@
 static void
 transform_3d(FT_Vector shift, FT_Glyph *glyph, FT_Glyph *glyph2,
              double frx, double fry, double frz, double fax, double fay,
-             double scale)
+             double scale, int yshift)
 {
     frx = -frx;
     frz = -frz;
     if (frx != 0. || fry != 0. || frz != 0. || fax != 0. || fay != 0.) {
         if (glyph && *glyph)
             transform_3d_points(shift, *glyph, frx, fry, frz,
-                                fax, fay, scale);
+                                fax, fay, scale, yshift);
 
         if (glyph2 && *glyph2)
             transform_3d_points(shift, *glyph2, frx, fry, frz,
-                                fax, fay, scale);
+                                fax, fay, scale, yshift);
     }
 }
 
@@ -2688,26 +1726,27 @@
  * \brief Main ass rendering function, glues everything together
  * \param event event to render
  * \param event_images struct containing resulting images, will also be initialized
- * Process event, appending resulting ass_image_t's to images_root.
+ * Process event, appending resulting ASS_Image's to images_root.
  */
 static int
-ass_render_event(ass_renderer_t *render_priv, ass_event_t *event,
-                 event_images_t *event_images)
+ass_render_event(ASS_Renderer *render_priv, ASS_Event *event,
+                 EventImages *event_images)
 {
     char *p;
     FT_UInt previous;
     FT_UInt num_glyphs;
     FT_Vector pen;
     unsigned code;
-    double_bbox_t bbox;
+    DBBox bbox;
     int i, j;
     int MarginL, MarginR, MarginV;
     int last_break;
     int alignment, halign, valign;
+    int kern = render_priv->track->Kerning;
     double device_x = 0;
     double device_y = 0;
-    text_info_t *text_info = &render_priv->text_info;
-    ass_drawing_t *drawing;
+    TextInfo *text_info = &render_priv->text_info;
+    ASS_Drawing *drawing;
 
     if (event->Style >= render_priv->track->n_styles) {
         ass_msg(render_priv->library, MSGL_WARN, "No style found");
@@ -2763,17 +1802,19 @@
             text_info->max_glyphs *= 2;
             text_info->glyphs =
                 realloc(text_info->glyphs,
-                        sizeof(glyph_info_t) * text_info->max_glyphs);
+                        sizeof(GlyphInfo) * text_info->max_glyphs);
         }
 
         // Add kerning to pen
-        if (previous && code && !drawing->hash) {
+        if (kern && previous && code && !drawing->hash) {
             FT_Vector delta;
             delta =
                 ass_font_get_kerning(render_priv->state.font, previous,
                                      code);
-            pen.x += delta.x * render_priv->state.scale_x;
-            pen.y += delta.y * render_priv->state.scale_y;
+            pen.x += delta.x * render_priv->state.scale_x
+                     * render_priv->font_scale_x;
+            pen.y += delta.y * render_priv->state.scale_y
+                     * render_priv->font_scale_x;
         }
 
         ass_font_set_transform(render_priv->state.font,
@@ -2784,14 +1825,30 @@
         get_outline_glyph(render_priv, code,
                           text_info->glyphs + text_info->length, drawing);
 
+        // Add additional space after italic to non-italic style changes
+        if (text_info->length &&
+            text_info->glyphs[text_info->length - 1].hash_key.italic &&
+            !render_priv->state.italic) {
+            int back = text_info->length - 1;
+            GlyphInfo *og = &text_info->glyphs[back];
+            while (back && og->bbox.xMax - og->bbox.xMin == 0
+                   && og->hash_key.italic)
+                og = &text_info->glyphs[--back];
+            if (og->bbox.xMax > og->advance.x) {
+                // The FreeType oblique slants by 6/16
+                pen.x += og->bbox.yMax * 0.375;
+            }
+        }
+
         text_info->glyphs[text_info->length].pos.x = pen.x;
         text_info->glyphs[text_info->length].pos.y = pen.y;
 
         pen.x += text_info->glyphs[text_info->length].advance.x;
         pen.x += double_to_d6(render_priv->state.hspacing *
-                              render_priv->font_scale);
+                              render_priv->font_scale
+                              * render_priv->state.scale_x);
         pen.y += text_info->glyphs[text_info->length].advance.y;
-        pen.y += render_priv->state.fay *
+        pen.y += (render_priv->state.fay * render_priv->state.scale_y) *
                  text_info->glyphs[text_info->length].advance.x;
 
         previous = code;
@@ -2850,29 +1907,31 @@
                 drawing->hash;
         text_info->glyphs[text_info->length].hash_key.ch = code;
         text_info->glyphs[text_info->length].hash_key.outline.x =
-            render_priv->state.border_x * 0xFFFF;
+            double_to_d16(render_priv->state.border_x);
         text_info->glyphs[text_info->length].hash_key.outline.y =
-            render_priv->state.border_y * 0xFFFF;
+            double_to_d16(render_priv->state.border_y);
         text_info->glyphs[text_info->length].hash_key.scale_x =
-            render_priv->state.scale_x * 0xFFFF;
+            double_to_d16(render_priv->state.scale_x);
         text_info->glyphs[text_info->length].hash_key.scale_y =
-            render_priv->state.scale_y * 0xFFFF;
+            double_to_d16(render_priv->state.scale_y);
         text_info->glyphs[text_info->length].hash_key.frx =
-            render_priv->state.frx * 0xFFFF;
+            rot_key(render_priv->state.frx);
         text_info->glyphs[text_info->length].hash_key.fry =
-            render_priv->state.fry * 0xFFFF;
+            rot_key(render_priv->state.fry);
         text_info->glyphs[text_info->length].hash_key.frz =
-            render_priv->state.frz * 0xFFFF;
+            rot_key(render_priv->state.frz);
         text_info->glyphs[text_info->length].hash_key.fax =
-            render_priv->state.fax * 0xFFFF;
+            double_to_d16(render_priv->state.fax);
         text_info->glyphs[text_info->length].hash_key.fay =
-            render_priv->state.fay * 0xFFFF;
+            double_to_d16(render_priv->state.fay);
         text_info->glyphs[text_info->length].hash_key.advance.x = pen.x;
         text_info->glyphs[text_info->length].hash_key.advance.y = pen.y;
         text_info->glyphs[text_info->length].hash_key.be =
             render_priv->state.be;
         text_info->glyphs[text_info->length].hash_key.blur =
             render_priv->state.blur;
+        text_info->glyphs[text_info->length].hash_key.border_style =
+            render_priv->state.style->BorderStyle;
         text_info->glyphs[text_info->length].hash_key.shadow_offset.x =
             double_to_d6(
                 render_priv->state.shadow_x * render_priv->border_scale -
@@ -2883,6 +1942,8 @@
                 render_priv->state.shadow_y * render_priv->border_scale -
                 (int) (render_priv->state.shadow_y *
                 render_priv->border_scale));
+        text_info->glyphs[text_info->length].hash_key.flags =
+            render_priv->state.flags;
 
         text_info->length++;
 
@@ -2942,13 +2003,17 @@
             if ((i == text_info->length)
                 || text_info->glyphs[i].linebreak) {
                 double width, shift = 0;
-                glyph_info_t *first_glyph =
+                GlyphInfo *first_glyph =
                     text_info->glyphs + last_break + 1;
-                glyph_info_t *last_glyph = text_info->glyphs + i - 1;
+                GlyphInfo *last_glyph = text_info->glyphs + i - 1;
 
+                while (first_glyph < last_glyph && first_glyph->skip)
+                    first_glyph++;
+
                 while ((last_glyph > first_glyph)
                        && ((last_glyph->symbol == '\n')
-                           || (last_glyph->symbol == 0)))
+                           || (last_glyph->symbol == 0)
+                           || (last_glyph->skip)))
                     last_glyph--;
 
                 width = d6_to_double(
@@ -3076,7 +2141,7 @@
     }
     // calculate rotation parameters
     {
-        double_vector_t center;
+        DVector center;
 
         if (render_priv->state.have_origin) {
             center.x = x2scr(render_priv, render_priv->state.org_x);
@@ -3089,7 +2154,7 @@
         }
 
         for (i = 0; i < text_info->length; ++i) {
-            glyph_info_t *info = text_info->glyphs + i;
+            GlyphInfo *info = text_info->glyphs + i;
 
             if (info->hash_key.frx || info->hash_key.fry
                 || info->hash_key.frz || info->hash_key.fax
@@ -3106,7 +2171,7 @@
 
     // convert glyphs to bitmaps
     for (i = 0; i < text_info->length; ++i) {
-        glyph_info_t *g = text_info->glyphs + i;
+        GlyphInfo *g = text_info->glyphs + i;
         g->hash_key.advance.x =
             double_to_d6(device_x - (int) device_x +
             d6_to_double(g->pos.x & SUBPIXEL_MASK)) & ~SUBPIXEL_ACCURACY;
@@ -3119,6 +2184,8 @@
     memset(event_images, 0, sizeof(*event_images));
     event_images->top = device_y - text_info->lines[0].asc;
     event_images->height = text_info->height;
+    event_images->left = device_x + bbox.xMin + 0.5;
+    event_images->width = bbox.xMax - bbox.xMin + 0.5;
     event_images->detect_collisions = render_priv->state.detect_collisions;
     event_images->shift_direction = (valign == VALIGN_TOP) ? 1 : -1;
     event_images->event = event;
@@ -3133,16 +2200,16 @@
  * \brief deallocate image list
  * \param img list pointer
  */
-static void ass_free_images(ass_image_t *img)
+static void ass_free_images(ASS_Image *img)
 {
     while (img) {
-        ass_image_t *next = img->next;
+        ASS_Image *next = img->next;
         free(img);
         img = next;
     }
 }
 
-static void ass_reconfigure(ass_renderer_t *priv)
+static void ass_reconfigure(ASS_Renderer *priv)
 {
     priv->render_id++;
     priv->cache.glyph_cache =
@@ -3155,20 +2222,20 @@
     priv->prev_images_root = 0;
 }
 
-void ass_set_frame_size(ass_renderer_t *priv, int w, int h)
+void ass_set_frame_size(ASS_Renderer *priv, int w, int h)
 {
     if (priv->settings.frame_width != w || priv->settings.frame_height != h) {
         priv->settings.frame_width = w;
         priv->settings.frame_height = h;
         if (priv->settings.aspect == 0.) {
             priv->settings.aspect = ((double) w) / h;
-            priv->settings.pixel_ratio = ((double) w) / h;
+            priv->settings.storage_aspect = ((double) w) / h;
         }
         ass_reconfigure(priv);
     }
 }
 
-void ass_set_margins(ass_renderer_t *priv, int t, int b, int l, int r)
+void ass_set_margins(ASS_Renderer *priv, int t, int b, int l, int r)
 {
     if (priv->settings.left_margin != l ||
         priv->settings.right_margin != r ||
@@ -3182,21 +2249,21 @@
     }
 }
 
-void ass_set_use_margins(ass_renderer_t *priv, int use)
+void ass_set_use_margins(ASS_Renderer *priv, int use)
 {
     priv->settings.use_margins = use;
 }
 
-void ass_set_aspect_ratio(ass_renderer_t *priv, double ar, double par)
+void ass_set_aspect_ratio(ASS_Renderer *priv, double dar, double sar)
 {
-    if (priv->settings.aspect != ar || priv->settings.pixel_ratio != par) {
-        priv->settings.aspect = ar;
-        priv->settings.pixel_ratio = par;
+    if (priv->settings.aspect != dar || priv->settings.storage_aspect != sar) {
+        priv->settings.aspect = dar;
+        priv->settings.storage_aspect = sar;
         ass_reconfigure(priv);
     }
 }
 
-void ass_set_font_scale(ass_renderer_t *priv, double font_scale)
+void ass_set_font_scale(ASS_Renderer *priv, double font_scale)
 {
     if (priv->settings.font_size_coeff != font_scale) {
         priv->settings.font_size_coeff = font_scale;
@@ -3204,7 +2271,7 @@
     }
 }
 
-void ass_set_hinting(ass_renderer_t *priv, ass_hinting_t ht)
+void ass_set_hinting(ASS_Renderer *priv, ASS_Hinting ht)
 {
     if (priv->settings.hinting != ht) {
         priv->settings.hinting = ht;
@@ -3212,12 +2279,12 @@
     }
 }
 
-void ass_set_line_spacing(ass_renderer_t *priv, double line_spacing)
+void ass_set_line_spacing(ASS_Renderer *priv, double line_spacing)
 {
     priv->settings.line_spacing = line_spacing;
 }
 
-void ass_set_fonts(ass_renderer_t *priv, const char *default_font,
+void ass_set_fonts(ASS_Renderer *priv, const char *default_font,
                    const char *default_family, int fc, const char *config,
                    int update)
 {
@@ -3234,7 +2301,7 @@
                         default_font, fc, config, update);
 }
 
-int ass_fonts_update(ass_renderer_t *render_priv)
+int ass_fonts_update(ASS_Renderer *render_priv)
 {
     return fontconfig_update(render_priv->fontconfig_priv);
 }
@@ -3243,11 +2310,11 @@
  * \brief Start a new frame
  */
 static int
-ass_start_frame(ass_renderer_t *render_priv, ass_track_t *track,
+ass_start_frame(ASS_Renderer *render_priv, ASS_Track *track,
                 long long now)
 {
-    ass_settings_t *settings_priv = &render_priv->settings;
-    cache_store_t *cache = &render_priv->cache;
+    ASS_Settings *settings_priv = &render_priv->settings;
+    CacheStore *cache = &render_priv->cache;
 
     if (!render_priv->settings.frame_width
         && !render_priv->settings.frame_height)
@@ -3293,7 +2360,7 @@
 
     // PAR correction
     render_priv->font_scale_x = render_priv->settings.aspect /
-                                render_priv->settings.pixel_ratio;
+                                render_priv->settings.storage_aspect;
 
     render_priv->prev_images_root = render_priv->images_root;
     render_priv->images_root = 0;
@@ -3321,8 +2388,8 @@
 
 static int cmp_event_layer(const void *p1, const void *p2)
 {
-    ass_event_t *e1 = ((event_images_t *) p1)->event;
-    ass_event_t *e2 = ((event_images_t *) p2)->event;
+    ASS_Event *e1 = ((EventImages *) p1)->event;
+    ASS_Event *e2 = ((EventImages *) p2)->event;
     if (e1->Layer < e2->Layer)
         return -1;
     if (e1->Layer > e2->Layer)
@@ -3334,41 +2401,36 @@
     return 0;
 }
 
-#define MAX_EVENTS 100
-
-static render_priv_t *get_render_priv(ass_renderer_t *render_priv,
-                                      ass_event_t *event)
+static ASS_RenderPriv *get_render_priv(ASS_Renderer *render_priv,
+                                       ASS_Event *event)
 {
     if (!event->render_priv)
-        event->render_priv = calloc(1, sizeof(render_priv_t));
-    // FIXME: check render_id
+        event->render_priv = calloc(1, sizeof(ASS_RenderPriv));
     if (render_priv->render_id != event->render_priv->render_id) {
-        memset(event->render_priv, 0, sizeof(render_priv_t));
+        memset(event->render_priv, 0, sizeof(ASS_RenderPriv));
         event->render_priv->render_id = render_priv->render_id;
     }
+
     return event->render_priv;
 }
 
-typedef struct {
-    int a, b;                   // top and height
-} segment_t;
-
-static int overlap(segment_t *s1, segment_t *s2)
+static int overlap(Segment *s1, Segment *s2)
 {
-    if (s1->a >= s2->b || s2->a >= s1->b)
+    if (s1->a >= s2->b || s2->a >= s1->b ||
+        s1->ha >= s2->hb || s2->ha >= s1->hb)
         return 0;
     return 1;
 }
 
 static int cmp_segment(const void *p1, const void *p2)
 {
-    return ((segment_t *) p1)->a - ((segment_t *) p2)->a;
+    return ((Segment *) p1)->a - ((Segment *) p2)->a;
 }
 
 static void
-shift_event(ass_renderer_t *render_priv, event_images_t *ei, int shift)
+shift_event(ASS_Renderer *render_priv, EventImages *ei, int shift)
 {
-    ass_image_t *cur = ei->imgs;
+    ASS_Image *cur = ei->imgs;
     while (cur) {
         cur->dst_y += shift;
         // clip top and bottom
@@ -3393,90 +2455,107 @@
 
 // dir: 1 - move down
 //      -1 - move up
-static int fit_segment(segment_t *s, segment_t *fixed, int *cnt, int dir)
+static int fit_segment(Segment *s, Segment *fixed, int *cnt, int dir)
 {
     int i;
     int shift = 0;
 
     if (dir == 1)               // move down
         for (i = 0; i < *cnt; ++i) {
-            if (s->b + shift <= fixed[i].a || s->a + shift >= fixed[i].b)
+            if (s->b + shift <= fixed[i].a || s->a + shift >= fixed[i].b ||
+                s->hb <= fixed[i].ha || s->ha >= fixed[i].hb)
                 continue;
             shift = fixed[i].b - s->a;
     } else                      // dir == -1, move up
         for (i = *cnt - 1; i >= 0; --i) {
-            if (s->b + shift <= fixed[i].a || s->a + shift >= fixed[i].b)
+            if (s->b + shift <= fixed[i].a || s->a + shift >= fixed[i].b ||
+                s->hb <= fixed[i].ha || s->ha >= fixed[i].hb)
                 continue;
             shift = fixed[i].a - s->b;
         }
 
     fixed[*cnt].a = s->a + shift;
     fixed[*cnt].b = s->b + shift;
+    fixed[*cnt].ha = s->ha;
+    fixed[*cnt].hb = s->hb;
     (*cnt)++;
-    qsort(fixed, *cnt, sizeof(segment_t), cmp_segment);
+    qsort(fixed, *cnt, sizeof(Segment), cmp_segment);
 
     return shift;
 }
 
 static void
-fix_collisions(ass_renderer_t *render_priv, event_images_t *imgs, int cnt)
+fix_collisions(ASS_Renderer *render_priv, EventImages *imgs, int cnt)
 {
-    segment_t used[MAX_EVENTS];
+    Segment *used = malloc(cnt * sizeof(*used));
     int cnt_used = 0;
     int i, j;
 
     // fill used[] with fixed events
     for (i = 0; i < cnt; ++i) {
-        render_priv_t *priv;
+        ASS_RenderPriv *priv;
         if (!imgs[i].detect_collisions)
             continue;
         priv = get_render_priv(render_priv, imgs[i].event);
         if (priv->height > 0) { // it's a fixed event
-            segment_t s;
+            Segment s;
             s.a = priv->top;
             s.b = priv->top + priv->height;
+            s.ha = priv->left;
+            s.hb = priv->left + priv->width;
             if (priv->height != imgs[i].height) {       // no, it's not
                 ass_msg(render_priv->library, MSGL_WARN,
                         "Warning! Event height has changed");
                 priv->top = 0;
                 priv->height = 0;
+                priv->left = 0;
+                priv->width = 0;
             }
             for (j = 0; j < cnt_used; ++j)
                 if (overlap(&s, used + j)) {    // no, it's not
                     priv->top = 0;
                     priv->height = 0;
+                    priv->left = 0;
+                    priv->width = 0;
                 }
             if (priv->height > 0) {     // still a fixed event
                 used[cnt_used].a = priv->top;
                 used[cnt_used].b = priv->top + priv->height;
+                used[cnt_used].ha = priv->left;
+                used[cnt_used].hb = priv->left + priv->width;
                 cnt_used++;
                 shift_event(render_priv, imgs + i, priv->top - imgs[i].top);
             }
         }
     }
-    qsort(used, cnt_used, sizeof(segment_t), cmp_segment);
+    qsort(used, cnt_used, sizeof(Segment), cmp_segment);
 
     // try to fit other events in free spaces
     for (i = 0; i < cnt; ++i) {
-        render_priv_t *priv;
+        ASS_RenderPriv *priv;
         if (!imgs[i].detect_collisions)
             continue;
         priv = get_render_priv(render_priv, imgs[i].event);
         if (priv->height == 0) {        // not a fixed event
             int shift;
-            segment_t s;
+            Segment s;
             s.a = imgs[i].top;
             s.b = imgs[i].top + imgs[i].height;
-            shift =
-                fit_segment(&s, used, &cnt_used, imgs[i].shift_direction);
+            s.ha = imgs[i].left;
+            s.hb = imgs[i].left + imgs[i].width;
+            shift = fit_segment(&s, used, &cnt_used, imgs[i].shift_direction);
             if (shift)
                 shift_event(render_priv, imgs + i, shift);
             // make it fixed
             priv->top = imgs[i].top;
             priv->height = imgs[i].height;
+            priv->left = imgs[i].left;
+            priv->width = imgs[i].width;
         }
 
     }
+
+    free(used);
 }
 
 /**
@@ -3485,7 +2564,7 @@
  * \param i2 second image
  * \return 0 if identical, 1 if different positions, 2 if different content
  */
-static int ass_image_compare(ass_image_t *i1, ass_image_t *i2)
+static int ass_image_compare(ASS_Image *i1, ASS_Image *i2)
 {
     if (i1->w != i2->w)
         return 2;
@@ -3509,16 +2588,16 @@
  * \param priv library handle
  * \return 0 if identical, 1 if different positions, 2 if different content
  */
-static int ass_detect_change(ass_renderer_t *priv)
+static int ass_detect_change(ASS_Renderer *priv)
 {
-    ass_image_t *img, *img2;
+    ASS_Image *img, *img2;
     int diff;
 
     img = priv->prev_images_root;
     img2 = priv->images_root;
     diff = 0;
     while (img && diff < 2) {
-        ass_image_t *next, *next2;
+        ASS_Image *next, *next2;
         next = img->next;
         if (img2) {
             int d = ass_image_compare(img, img2);
@@ -3550,12 +2629,12 @@
  *        0 if identical, 1 if different positions, 2 if different content.
  *        Can be NULL, in that case no detection is performed.
  */
-ass_image_t *ass_render_frame(ass_renderer_t *priv, ass_track_t *track,
-                              long long now, int *detect_change)
+ASS_Image *ass_render_frame(ASS_Renderer *priv, ASS_Track *track,
+                            long long now, int *detect_change)
 {
     int i, cnt, rc;
-    event_images_t *last;
-    ass_image_t **tail;
+    EventImages *last;
+    ASS_Image **tail;
 
     // init frame
     rc = ass_start_frame(priv, track, now);
@@ -3565,14 +2644,14 @@
     // render events separately
     cnt = 0;
     for (i = 0; i < track->n_events; ++i) {
-        ass_event_t *event = track->events + i;
+        ASS_Event *event = track->events + i;
         if ((event->Start <= now)
             && (now < (event->Start + event->Duration))) {
             if (cnt >= priv->eimg_size) {
                 priv->eimg_size += 100;
                 priv->eimg =
                     realloc(priv->eimg,
-                            priv->eimg_size * sizeof(event_images_t));
+                            priv->eimg_size * sizeof(EventImages));
             }
             rc = ass_render_event(priv, event, priv->eimg + cnt);
             if (!rc)
@@ -3581,7 +2660,7 @@
     }
 
     // sort by layer
-    qsort(priv->eimg, cnt, sizeof(event_images_t), cmp_event_layer);
+    qsort(priv->eimg, cnt, sizeof(EventImages), cmp_event_layer);
 
     // call fix_collisions for each group of events with the same layer
     last = priv->eimg;
@@ -3596,7 +2675,7 @@
     // concat lists
     tail = &priv->images_root;
     for (i = 0; i < cnt; ++i) {
-        ass_image_t *cur = priv->eimg[i].imgs;
+        ASS_Image *cur = priv->eimg[i].imgs;
         while (cur) {
             *tail = cur;
             tail = &cur->next;

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_render.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_render.h	2010-01-08 18:55:07 UTC (rev 5831)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_render.h	2010-01-09 11:03:17 UTC (rev 5832)
@@ -0,0 +1,262 @@
+/*
+ * Copyright (C) 2006 Evgeniy Stepanov <eugeni.stepanov at gmail.com>
+ * Copyright (C) 2009 Grigori Goronzy <greg at geekmind.org>
+ *
+ * This file is part of libass.
+ *
+ * libass is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libass is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with libass; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef LIBASS_RENDER_H
+#define LIBASS_RENDER_H
+
+#include <inttypes.h>
+#include <ft2build.h>
+#include FT_FREETYPE_H
+#include FT_STROKER_H
+#include FT_GLYPH_H
+#include FT_SYNTHESIS_H
+
+#include "ass.h"
+#include "ass_font.h"
+#include "ass_bitmap.h"
+#include "ass_cache.h"
+#include "ass_utils.h"
+#include "ass_fontconfig.h"
+#include "ass_library.h"
+#include "ass_drawing.h"
+
+typedef struct {
+    double xMin;
+    double xMax;
+    double yMin;
+    double yMax;
+} DBBox;
+
+typedef struct {
+    double x;
+    double y;
+} DVector;
+
+typedef struct free_list {
+    void *object;
+    struct free_list *next;
+} FreeList;
+
+typedef struct {
+    int frame_width;
+    int frame_height;
+    double font_size_coeff;     // font size multiplier
+    double line_spacing;        // additional line spacing (in frame pixels)
+    int top_margin;             // height of top margin. Everything except toptitles is shifted down by top_margin.
+    int bottom_margin;          // height of bottom margin. (frame_height - top_margin - bottom_margin) is original video height.
+    int left_margin;
+    int right_margin;
+    int use_margins;            // 0 - place all subtitles inside original frame
+    // 1 - use margins for placing toptitles and subtitles
+    double aspect;              // frame aspect ratio, d_width / d_height.
+    double storage_aspect;      // pixel ratio of the source image
+    ASS_Hinting hinting;
+
+    char *default_font;
+    char *default_family;
+} ASS_Settings;
+
+// a rendered event
+typedef struct {
+    ASS_Image *imgs;
+    int top, height, left, width;
+    int detect_collisions;
+    int shift_direction;
+    ASS_Event *event;
+} EventImages;
+
+typedef enum {
+    EF_NONE = 0,
+    EF_KARAOKE,
+    EF_KARAOKE_KF,
+    EF_KARAOKE_KO
+} Effect;
+
+// describes a glyph
+// GlyphInfo and TextInfo are used for text centering and word-wrapping operations
+typedef struct {
+    unsigned symbol;
+    unsigned skip;              // skip glyph when layouting text
+    FT_Glyph glyph;
+    FT_Glyph outline_glyph;
+    Bitmap *bm;                 // glyph bitmap
+    Bitmap *bm_o;               // outline bitmap
+    Bitmap *bm_s;               // shadow bitmap
+    FT_BBox bbox;
+    FT_Vector pos;
+    char linebreak;             // the first (leading) glyph of some line ?
+    uint32_t c[4];              // colors
+    FT_Vector advance;          // 26.6
+    Effect effect_type;
+    int effect_timing;          // time duration of current karaoke word
+    // after process_karaoke_effects: distance in pixels from the glyph origin.
+    // part of the glyph to the left of it is displayed in a different color.
+    int effect_skip_timing;     // delay after the end of last karaoke word
+    int asc, desc;              // font max ascender and descender
+    int be;                     // blur edges
+    double blur;                // gaussian blur
+    double shadow_x;
+    double shadow_y;
+    double frx, fry, frz;       // rotation
+    double fax, fay;            // text shearing
+
+    BitmapHashKey hash_key;
+} GlyphInfo;
+
+typedef struct {
+    double asc, desc;
+} LineInfo;
+
+typedef struct {
+    GlyphInfo *glyphs;
+    int length;
+    LineInfo *lines;
+    int n_lines;
+    double height;
+    int max_glyphs;
+    int max_lines;
+} TextInfo;
+
+// Renderer state.
+// Values like current font face, color, screen position, clipping and so on are stored here.
+typedef struct {
+    ASS_Event *event;
+    ASS_Style *style;
+
+    ASS_Font *font;
+    char *font_path;
+    double font_size;
+    int flags;                  // decoration flags (underline/strike-through)
+
+    FT_Stroker stroker;
+    int alignment;              // alignment overrides go here; if zero, style value will be used
+    double frx, fry, frz;
+    double fax, fay;            // text shearing
+    enum {
+        EVENT_NORMAL,           // "normal" top-, sub- or mid- title
+        EVENT_POSITIONED,       // happens after pos(,), margins are ignored
+        EVENT_HSCROLL,          // "Banner" transition effect, text_width is unlimited
+        EVENT_VSCROLL           // "Scroll up", "Scroll down" transition effects
+    } evt_type;
+    double pos_x, pos_y;        // position
+    double org_x, org_y;        // origin
+    char have_origin;           // origin is explicitly defined; if 0, get_base_point() is used
+    double scale_x, scale_y;
+    double hspacing;            // distance between letters, in pixels
+    double border_x;            // outline width
+    double border_y;
+    uint32_t c[4];              // colors(Primary, Secondary, so on) in RGBA
+    int clip_x0, clip_y0, clip_x1, clip_y1;
+    char clip_mode;             // 1 = iclip
+    char detect_collisions;
+    uint32_t fade;              // alpha from \fad
+    char be;                    // blur edges
+    double blur;                // gaussian blur
+    double shadow_x;
+    double shadow_y;
+    int drawing_mode;           // not implemented; when != 0 text is discarded, except for style override tags
+    ASS_Drawing *drawing;       // current drawing
+    ASS_Drawing *clip_drawing;  // clip vector
+    int clip_drawing_mode;      // 0 = regular clip, 1 = inverse clip
+
+    Effect effect_type;
+    int effect_timing;
+    int effect_skip_timing;
+
+    enum {
+        SCROLL_LR,              // left-to-right
+        SCROLL_RL,
+        SCROLL_TB,              // top-to-bottom
+        SCROLL_BT
+    } scroll_direction;         // for EVENT_HSCROLL, EVENT_VSCROLL
+    int scroll_shift;
+
+    // face properties
+    char *family;
+    unsigned bold;
+    unsigned italic;
+    int treat_family_as_pattern;
+    int wrap_style;
+} RenderContext;
+
+typedef struct {
+    Hashmap *font_cache;
+    Hashmap *glyph_cache;
+    Hashmap *bitmap_cache;
+    Hashmap *composite_cache;
+    size_t glyph_max;
+    size_t bitmap_max_size;
+} CacheStore;
+
+struct ass_renderer {
+    ASS_Library *library;
+    FT_Library ftlibrary;
+    FCInstance *fontconfig_priv;
+    ASS_Settings settings;
+    int render_id;
+    ASS_SynthPriv *synth_priv;
+
+    ASS_Image *images_root;     // rendering result is stored here
+    ASS_Image *prev_images_root;
+
+    EventImages *eimg;          // temporary buffer for sorting rendered events
+    int eimg_size;              // allocated buffer size
+
+    // frame-global data
+    int width, height;          // screen dimensions
+    int orig_height;            // frame height ( = screen height - margins )
+    int orig_width;             // frame width ( = screen width - margins )
+    int orig_height_nocrop;     // frame height ( = screen height - margins + cropheight)
+    int orig_width_nocrop;      // frame width ( = screen width - margins + cropwidth)
+    ASS_Track *track;
+    long long time;             // frame's timestamp, ms
+    double font_scale;
+    double font_scale_x;        // x scale applied to all glyphs to preserve text aspect ratio
+    double border_scale;
+
+    RenderContext state;
+    TextInfo text_info;
+    CacheStore cache;
+
+    FreeList *free_head;
+    FreeList *free_tail;
+};
+
+typedef struct render_priv {
+    int top, height, left, width;
+    int render_id;
+} RenderPriv;
+
+typedef struct {
+    int x0;
+    int y0;
+    int x1;
+    int y1;
+} Rect;
+
+typedef struct {
+    int a, b;                   // top and height
+    int ha, hb;                 // left and width
+} Segment;
+
+void reset_render_context(ASS_Renderer *render_priv);
+
+#endif /* LIBASS_RENDER_H */

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_strtod.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_strtod.c	2010-01-08 18:55:07 UTC (rev 5831)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_strtod.c	2010-01-09 11:03:17 UTC (rev 5832)
@@ -0,0 +1,247 @@
+/*
+ * Copyright (c) 1988-1993 The Regents of the University of California.
+ * Copyright (c) 1994 Sun Microsystems, Inc.
+ *
+ * Permission to use, copy, modify, and distribute this
+ * software and its documentation for any purpose and without
+ * fee is hereby granted, provided that the above copyright
+ * notice appear in all copies.  The University of California
+ * makes no representations about the suitability of this
+ * software for any purpose.  It is provided "as is" without
+ * express or implied warranty.
+ *
+ */
+
+#include <stdlib.h>
+#include <ctype.h>
+#include <errno.h>
+
+static int maxExponent = 511;   /* Largest possible base 10 exponent.  Any
+                                 * exponent larger than this will already
+                                 * produce underflow or overflow, so there's
+                                 * no need to worry about additional digits.
+                                 */
+
+static double powersOf10[] = {  /* Table giving binary powers of 10.  Entry */
+    10.,                        /* is 10^2^i.  Used to convert decimal */
+    100.,                       /* exponents into floating-point numbers. */
+    1.0e4,
+    1.0e8,
+    1.0e16,
+    1.0e32,
+    1.0e64,
+    1.0e128,
+    1.0e256
+};
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * strtod --
+ *
+ * This procedure converts a floating-point number from an ASCII
+ * decimal representation to internal double-precision format.
+ *
+ * Results:
+ * The return value is the double-precision floating-point
+ * representation of the characters in string.  If endPtr isn't
+ * NULL, then *endPtr is filled in with the address of the
+ * next character after the last one that was part of the
+ * floating-point number.
+ *
+ * Side effects:
+ * None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+double
+ass_strtod(string, endPtr)
+    const char *string;     /* A decimal ASCII floating-point number,
+                             * optionally preceded by white space.
+                             * Must have form "-I.FE-X", where I is the
+                             * integer part of the mantissa, F is the
+                             * fractional part of the mantissa, and X
+                             * is the exponent.  Either of the signs
+                             * may be "+", "-", or omitted.  Either I
+                             * or F may be omitted, or both.  The decimal
+                             * point isn't necessary unless F is present.
+                             * The "E" may actually be an "e".  E and X
+                             * may both be omitted (but not just one).
+                             */
+    char **endPtr;          /* If non-NULL, store terminating character's
+                             * address here. */
+{
+    int sign, expSign = 0;
+    double fraction, dblExp, *d;
+    register const char *p;
+    register int c;
+    int exp = 0;            /* Exponent read from "EX" field. */
+    int fracExp = 0;        /* Exponent that derives from the fractional
+                             * part.  Under normal circumstatnces, it is
+                             * the negative of the number of digits in F.
+                             * However, if I is very long, the last digits
+                             * of I get dropped (otherwise a long I with a
+                             * large negative exponent could cause an
+                             * unnecessary overflow on I alone).  In this
+                             * case, fracExp is incremented one for each
+                             * dropped digit. */
+    int mantSize;       /* Number of digits in mantissa. */
+    int decPt;          /* Number of mantissa digits BEFORE decimal
+                         * point. */
+    const char *pExp;       /* Temporarily holds location of exponent
+                             * in string. */
+
+    /*
+     * Strip off leading blanks and check for a sign.
+     */
+
+    p = string;
+    while (isspace(*p)) {
+        p += 1;
+    }
+    if (*p == '-') {
+        sign = 1;
+        p += 1;
+    } else {
+        if (*p == '+') {
+            p += 1;
+        }
+        sign = 0;
+    }
+
+    /*
+     * Count the number of digits in the mantissa (including the decimal
+     * point), and also locate the decimal point.
+     */
+
+    decPt = -1;
+    for (mantSize = 0; ; mantSize += 1)
+    {
+        c = *p;
+        if (!isdigit(c)) {
+            if ((c != '.') || (decPt >= 0)) {
+                break;
+            }
+            decPt = mantSize;
+        }
+        p += 1;
+    }
+
+    /*
+     * Now suck up the digits in the mantissa.  Use two integers to
+     * collect 9 digits each (this is faster than using floating-point).
+     * If the mantissa has more than 18 digits, ignore the extras, since
+     * they can't affect the value anyway.
+     */
+
+    pExp  = p;
+    p -= mantSize;
+    if (decPt < 0) {
+        decPt = mantSize;
+    } else {
+        mantSize -= 1;      /* One of the digits was the point. */
+    }
+    if (mantSize > 18) {
+        fracExp = decPt - 18;
+        mantSize = 18;
+    } else {
+        fracExp = decPt - mantSize;
+    }
+    if (mantSize == 0) {
+        fraction = 0.0;
+        p = string;
+        goto done;
+    } else {
+        int frac1, frac2;
+        frac1 = 0;
+        for ( ; mantSize > 9; mantSize -= 1)
+        {
+            c = *p;
+            p += 1;
+            if (c == '.') {
+                c = *p;
+                p += 1;
+            }
+            frac1 = 10*frac1 + (c - '0');
+        }
+        frac2 = 0;
+        for (; mantSize > 0; mantSize -= 1)
+        {
+            c = *p;
+            p += 1;
+            if (c == '.') {
+                c = *p;
+                p += 1;
+            }
+            frac2 = 10*frac2 + (c - '0');
+        }
+        fraction = (1.0e9 * frac1) + frac2;
+    }
+
+    /*
+     * Skim off the exponent.
+     */
+
+    p = pExp;
+    if ((*p == 'E') || (*p == 'e')) {
+        p += 1;
+        if (*p == '-') {
+            expSign = 1;
+            p += 1;
+        } else {
+            if (*p == '+') {
+                p += 1;
+            }
+            expSign = 0;
+        }
+        while (isdigit(*p)) {
+            exp = exp * 10 + (*p - '0');
+            p += 1;
+        }
+    }
+    if (expSign) {
+        exp = fracExp - exp;
+    } else {
+        exp = fracExp + exp;
+    }
+
+    /*
+     * Generate a floating-point number that represents the exponent.
+     * Do this by processing the exponent one bit at a time to combine
+     * many powers of 2 of 10. Then combine the exponent with the
+     * fraction.
+     */
+
+    if (exp < 0) {
+        expSign = 1;
+        exp = -exp;
+    } else {
+        expSign = 0;
+    }
+    if (exp > maxExponent) {
+        exp = maxExponent;
+        errno = ERANGE;
+    }
+    dblExp = 1.0;
+    for (d = powersOf10; exp != 0; exp >>= 1, d += 1) {
+        if (exp & 01) {
+            dblExp *= *d;
+        }
+    }
+    if (expSign) {
+        fraction /= dblExp;
+    } else {
+        fraction *= dblExp;
+    }
+
+done:
+    if (endPtr != NULL) {
+        *endPtr = (char *) p;
+    }
+
+    if (sign) {
+        return -fraction;
+    }
+    return fraction;
+}

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_types.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_types.h	2010-01-08 18:55:07 UTC (rev 5831)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_types.h	2010-01-09 11:03:17 UTC (rev 5832)
@@ -31,10 +31,10 @@
 #define HALIGN_RIGHT 3
 
 /* Opaque objects internally used by libass.  Contents are private. */
-typedef struct ass_renderer ass_renderer_t;
-typedef struct render_priv render_priv_t;
-typedef struct parser_priv parser_priv_t;
-typedef struct ass_library ass_library_t;
+typedef struct ass_renderer ASS_Renderer;
+typedef struct render_priv ASS_RenderPriv;
+typedef struct parser_priv ASS_ParserPriv;
+typedef struct ass_library ASS_Library;
 
 /* ASS Style: line */
 typedef struct ass_style {
@@ -62,10 +62,10 @@
     int MarginV;
     int Encoding;
     int treat_fontname_as_pattern;
-} ass_style_t;
+} ASS_Style;
 
 /*
- * ass_event_t corresponds to a single Dialogue line;
+ * ASS_Event corresponds to a single Dialogue line;
  * text is stored as-is, style overrides will be parsed later.
  */
 typedef struct ass_event {
@@ -82,8 +82,8 @@
     char *Effect;
     char *Text;
 
-    render_priv_t *render_priv;
-} ass_event_t;
+    ASS_RenderPriv *render_priv;
+} ASS_Event;
 
 /*
  * ass track represent either an external script or a matroska subtitle stream
@@ -95,8 +95,8 @@
     int max_styles;         // amount allocated
     int n_events;
     int max_events;
-    ass_style_t *styles;    // array of styles, max_styles length, n_styles used
-    ass_event_t *events;    // the same as styles
+    ASS_Style *styles;    // array of styles, max_styles length, n_styles used
+    ASS_Event *events;    // the same as styles
 
     char *style_format;     // style format line (everything after "Format: ")
     char *event_format;     // event format line
@@ -112,14 +112,14 @@
     int PlayResY;
     double Timer;
     int WrapStyle;
-    char ScaledBorderAndShadow;
+    int ScaledBorderAndShadow;
+    int Kerning;
 
-
     int default_style;      // index of default style
     char *name;             // file name in case of external subs, 0 for streams
 
-    ass_library_t *library;
-    parser_priv_t *parser_priv;
-} ass_track_t;
+    ASS_Library *library;
+    ASS_ParserPriv *parser_priv;
+} ASS_Track;
 
 #endif /* LIBASS_TYPES_H */

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_utils.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_utils.c	2010-01-08 18:55:07 UTC (rev 5831)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_utils.c	2010-01-09 11:03:17 UTC (rev 5832)
@@ -34,7 +34,7 @@
 {
     double temp_res;
     char *start = *p;
-    temp_res = strtod(*p, p);
+    temp_res = ass_strtod(*p, p);
     *res = (int) (temp_res + (temp_res > 0 ? 0.5 : -0.5));
     if (*p != start)
         return 1;
@@ -46,7 +46,7 @@
 {
     double temp_res;
     char *start = *p;
-    temp_res = strtod(*p, p);
+    temp_res = ass_strtod(*p, p);
     *res = (int) (temp_res + (temp_res > 0 ? 0.5 : -0.5));
     if (*p != start)
         return 1;
@@ -67,18 +67,19 @@
 int mystrtod(char **p, double *res)
 {
     char *start = *p;
-    *res = strtod(*p, p);
+    *res = ass_strtod(*p, p);
     if (*p != start)
         return 1;
     else
         return 0;
 }
 
-int strtocolor(ass_library_t *library, char **q, uint32_t *res)
+int strtocolor(ASS_Library *library, char **q, uint32_t *res, int hex)
 {
     uint32_t color = 0;
     int result;
     char *p = *q;
+    int base = hex ? 16 : 10;
 
     if (*p == '&')
         ++p;
@@ -89,7 +90,7 @@
         ++p;
         result = mystrtou32(&p, 16, &color);
     } else {
-        result = mystrtou32(&p, 0, &color);
+        result = mystrtou32(&p, base, &color);
     }
 
     {
@@ -122,7 +123,7 @@
     return 0;
 }
 
-void ass_msg(ass_library_t *priv, int lvl, char *fmt, ...)
+void ass_msg(ASS_Library *priv, int lvl, char *fmt, ...)
 {
     va_list va;
     va_start(va, fmt);
@@ -161,7 +162,7 @@
 }
 
 #ifdef CONFIG_ENCA
-void *ass_guess_buffer_cp(ass_library_t *library, unsigned char *buffer,
+void *ass_guess_buffer_cp(ASS_Library *library, unsigned char *buffer,
                           int buflen, char *preferred_language,
                           char *fallback)
 {

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_utils.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_utils.h	2010-01-08 18:55:07 UTC (rev 5831)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_utils.h	2010-01-09 11:03:17 UTC (rev 5832)
@@ -49,16 +49,19 @@
 int mystrtoll(char **p, long long *res);
 int mystrtou32(char **p, int base, uint32_t *res);
 int mystrtod(char **p, double *res);
-int strtocolor(ass_library_t *library, char **q, uint32_t *res);
+int strtocolor(ASS_Library *library, char **q, uint32_t *res, int hex);
 char parse_bool(char *str);
 unsigned ass_utf8_get_char(char **str);
-void ass_msg(ass_library_t *priv, int lvl, char *fmt, ...);
+void ass_msg(ASS_Library *priv, int lvl, char *fmt, ...);
 #ifdef CONFIG_ENCA
-void *ass_guess_buffer_cp(ass_library_t *library, unsigned char *buffer,
+void *ass_guess_buffer_cp(ASS_Library *library, unsigned char *buffer,
                           int buflen, char *preferred_language,
                           char *fallback);
 #endif
 
+/* defined in ass_strtod.c */
+double ass_strtod(const char *string, char **endPtr);
+
 static inline int d6_to_int(int x)
 {
     return (x + 32) >> 6;
@@ -99,7 +102,22 @@
 {
     return (int) (x * 0x10000);
 }
+static inline double d22_to_double(int x)
+{
+    return ((double) x) / 0x400000;
+}
+static inline int double_to_d22(double x)
+{
+    return (int) (x * 0x400000);
+}
 
+// Calculate cache key for a rotational angle in degrees
+static inline int rot_key(double a)
+{
+    const int m = double_to_d22(360.0);
+    return double_to_d22(a) % m;
+}
+
 #define FNV1_32A_INIT (unsigned)0x811c9dc5
 
 static inline unsigned fnv_32a_buf(void *buf, size_t len, unsigned hval)

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/readme
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/readme	2010-01-08 18:55:07 UTC (rev 5831)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/readme	2010-01-09 11:03:17 UTC (rev 5832)
@@ -1,2 +1,12 @@
 checkout http://repo.or.cz/w/libass.git
-done august first 8h36 AM, paris time, last commit      Do not round karaoke timing coordinates  
+Done 9 Jan 2010 at 1104
+Last commit
+commit 8db4a5b1b5ab6598b96092e08586f2bed8ab8f39
+Author: Grigori Goronzy <greg at blackbox>
+Date:   Fri Jan 8 18:23:34 2010 +0100
+
+    Remove support for freetype < 2.2.1
+
+    Get rid of compatibility #ifdefs and some code to support very old
+    versions of freetype. libass now requires at least version 2.2.1.
+

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_vidASS.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_vidASS.cpp	2010-01-08 18:55:07 UTC (rev 5831)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_vidASS.cpp	2010-01-09 11:03:17 UTC (rev 5832)
@@ -287,7 +287,7 @@
           return 1; 
         }
         int changed=0;
-        ass_image_t *img = ass_render_frame(_ass_rend, _ass_track, where,&changed);
+        ASS_Image *img = ass_render_frame(_ass_rend, _ass_track, where,&changed);
         
 
         while(img) {

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_vidASS.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_vidASS.h	2010-01-08 18:55:07 UTC (rev 5831)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_vidASS.h	2010-01-09 11:03:17 UTC (rev 5832)
@@ -22,9 +22,9 @@
 protected:
         virtual char* printConf(void);
         ASSParams* _params;
-        ass_library_t *_ass_lib;
-        ass_renderer_t *_ass_rend;
-        ass_track_t *_ass_track;
+        ASS_Library *_ass_lib;
+        ASS_Renderer *_ass_rend;
+        ASS_Track *_ass_track;
         uint8_t init(void);
 public:
         ADMVideoSubASS(AVDMGenericVideoStream *in, CONFcouple *conf);

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/CMakeLists.txt	2010-01-08 18:55:07 UTC (rev 5831)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/CMakeLists.txt	2010-01-09 11:03:17 UTC (rev 5832)
@@ -9,10 +9,12 @@
 
 	ADD_LIBRARY(ADM_vf_ssa SHARED ${ADM_vf_ssa_SRCS})
 	TARGET_LINK_LIBRARIES(ADM_vf_ssa ADM_libass)
+	ADD_TARGET_CFLAGS(ADM_vf_ssa "-DCONFIG_FREETYPE=1")
 	ADD_TARGET_LDFLAGS(ADM_vf_ssa "${FREETYPE2_LDFLAGS}")
 
 	IF (FONTCONFIG_FOUND)
 		ADD_TARGET_LDFLAGS(ADM_vf_ssa "${FONTCONFIG_LDFLAGS}")
+	        ADD_TARGET_CFLAGS(ADM_vf_ssa "-DCONFIG_FONTCONFIG=1")
 	ENDIF (FONTCONFIG_FOUND)
 
 	INIT_VIDEOFILTER_PLUGIN(ADM_vf_ssa)



From mean at mail.berlios.de  Sun Jan 10 19:08:36 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 10 Jan 2010 19:08:36 +0100
Subject: [Avidemux-svn-commit] r5833 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/OpenDml
Message-ID: <201001101808.o0AI8aDv013145@sheep.berlios.de>

Author: mean
Date: 2010-01-10 19:08:34 +0100 (Sun, 10 Jan 2010)
New Revision: 5833

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/OpenDml/ADM_openDML.cpp
Log:
[openDml] Handle weird dv-avi file with fq=0, force fq=48kHz/stereo, that might be wrong

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/OpenDml/ADM_openDML.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/OpenDml/ADM_openDML.cpp	2010-01-09 11:03:17 UTC (rev 5832)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/OpenDml/ADM_openDML.cpp	2010-01-10 18:08:34 UTC (rev 5833)
@@ -503,8 +503,27 @@
                 }
                 else
                 {
+                        odmlAudioTrack *track;
+                        // Check it is not a weird DV file
+                        if(fourCC::check(_video_bih.biCompression,(uint8_t *)"dvsd"))
+                        {
+                             for(int i=0;i<_nbAudioTracks;i++)
+                             {
+                                    track=&(_audioTracks[i]);
+                                    WAVHeader *hdr=  track->wavHeader;
+                                    if(!hdr->frequency)
+                                    {
+                                            ADM_warning("Fixing audio track to be PCM\n");
+                                            hdr->frequency=48000;
+                                            //hdr->channels=2;
+                                            hdr->byterate=48000*hdr->channels*2;
+                                            hdr->blockalign=2*hdr->channels;
+                                    }
+                             }
+
+                        }
                         // build audio stream
-                        odmlAudioTrack *track;
+                        
                         for(int i=0;i<_nbAudioTracks;i++)
                         {
                                 track=&(_audioTracks[i]);



From mean at mail.berlios.de  Sun Jan 10 19:08:42 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 10 Jan 2010 19:08:42 +0100
Subject: [Avidemux-svn-commit] r5834 - in branches/avidemux_2.6_branch_mean:
	avidemux/common avidemux/common/ADM_codecs avidemux_core
	avidemux_core/ADM_coreVideoCodec
	avidemux_core/ADM_coreVideoCodec/include
	avidemux_core/ADM_coreVideoCodec/src
Message-ID: <201001101808.o0AI8gHv013232@sheep.berlios.de>

Author: mean
Date: 2010-01-10 19:08:39 +0100 (Sun, 10 Jan 2010)
New Revision: 5834

Added:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_codec.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_codecNull.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_ffmp43.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_ffmpeg_vdpau_internal.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_mjpeg.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_png.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_rgb16.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_theora_dec.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_theora_enc.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_uyvy.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_codecs.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_ffmp43.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_ffmpeg_vdpau.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_mjpeg.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_png.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_rgb16.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_theora_dec.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_uyvy.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/CMakeLists.txt
Removed:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_codec.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_codecNull.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_codecs.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_ffmp43.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_ffmp43.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_ffmpeg_vdpau.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_ffmpeg_vdpau_internal.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_mjpeg.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_mjpeg.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_png.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_png.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_rgb16.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_rgb16.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_theora_dec.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_theora_dec.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_theora_enc.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_uyvy.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_uyvy.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/CMakeLists.txt
Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_core/CMakeLists.txt
Log:
[VideoCodec] Move them to  core

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_codec.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_codec.h	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_codec.h	2010-01-10 18:08:39 UTC (rev 5834)
@@ -1,160 +0,0 @@
-/***************************************************************************
-                          ADM_codec.h  -  description
-                             -------------------
-    begin                : Fri Apr 12 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifndef __CODECS__
-#define __CODECS__
-
-#include "ADM_image.h"
-#include "ADM_frameType.h"
-#include "ADM_codecType.h"
-
-#define ADM_QPEL_ON	1
-#define ADM_GMC_ON	2
-#define ADM_VOP_ON	4
-
-/*
-        Bitrate in configuration will always be in **kBITS**
-
-*/
-
-#include "ADM_bitstream.h"
-#include "ADM_compressedImage.h"
-/**
-    \class decoders
-    \brief base class for video decoders
-*/
-class decoders
-{
-protected:
-  uint32_t _w;
-  uint32_t _h;
-  uint8_t _lastQ;
-public:
-    decoders (uint32_t w, uint32_t h)
-  {
-    _w = w;
-    _h = h;
-    _lastQ = 0;
-  }
-  virtual ~ decoders ()
-  {
-  };
-  virtual uint8_t getPARWidth (void)
-  {
-    return 1;
-  };
-  virtual uint8_t getPARHeight (void)
-  {
-    return 1;
-  };
-  virtual void setParam (void)
-  {
-  };
-  virtual uint8_t uncompress (ADMCompressedImage * in, ADMImage * out)=0;
-
-  // does this codec *possibly* can have b-frame ?
-  virtual uint8_t dontcopy (void)
-  {
-    return 0;
-  }				// if 1 means the decoder will return reference
-  // no need to copy the datas to ADMimage
-  virtual uint8_t bFramePossible (void)
-  {
-    return 0;
-  }
-  virtual uint8_t decodeHeaderOnly (void)
-  {
-    return 0;
-  };
-  virtual uint8_t decodeFull (void)
-  {
-    return 0;
-  }
-  virtual uint8_t isDivxPacked (void)
-  {
-    return 0;
-  };
-  virtual uint32_t getSpecificMpeg4Info (void)
-  {
-    return 0;
-  };
-  virtual uint8_t isIndexable (void)
-  {
-    return 1;
-  };
-  virtual bool flush(void)
-    {
-        return true;
-    }
-};
-/* Dummy decoder in case we don't have the desired one */
-class decoderEmpty : public decoders
-{
-protected:
-public:
-    decoderEmpty (uint32_t w, uint32_t h) : decoders(w,h) {};
-    uint8_t uncompress (ADMCompressedImage * in, ADMImage * out) {return 1;}
-
-};
-
-decoders *getDecoder (uint32_t fcc, uint32_t w, uint32_t h, uint32_t extraLen,
-		      uint8_t * extraData,uint32_t bpp=0);
-decoders *getDecoderVopPacked (uint32_t fcc, uint32_t w, uint32_t h,
-			       uint32_t extraLen, uint8_t * extraData);
-decoders *getDecoderH264noLogic (uint32_t fcc, uint32_t w, uint32_t h, uint32_t extraLen,
-		     uint8_t * extraData);
-
-class coders
-{
-protected:
-  uint32_t _w;
-  uint32_t _h;
-public:
-    coders (uint32_t w, uint32_t h)
-  {
-    _w = w;
-    _h = h;
-  }
-  virtual ~ coders ()
-  {
-  };
-  virtual uint8_t compress (ADMImage * in, ADMBitstream * out);
-};
-decoders *getCoder (uint32_t fcc, uint32_t w, uint32_t h);
-/*----------------------------------------------------------*/
-class encoder
-{
-protected:uint32_t _w, _h;
-public:encoder (uint32_t width, uint32_t height)
-  {
-    _w = width;
-    _h = height;
-  };
-  virtual uint8_t stopEncoder (void) = 0;
-  virtual uint8_t init (uint32_t val, uint32_t fps1000) = 0;
-  virtual uint8_t encode (ADMImage * in, ADMBitstream *out) = 0;
-  virtual uint8_t getExtraData (uint32_t * l, uint8_t ** d)
-  {
-    *l = 0;
-    *d = NULL;
-    return 0;
-  }
-};
-
-
-
-
-#endif

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_codecNull.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_codecNull.h	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_codecNull.h	2010-01-10 18:08:39 UTC (rev 5834)
@@ -1,33 +0,0 @@
-/***************************************************************************
-                          ADM_codecNull.h  -  description
-                             -------------------
-    begin                : Fri Apr 19 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-class decoderNull:public decoders
-{
-protected:
-
-public:
-  decoderNull (uint32_t w, uint32_t h):decoders (w, h)
-  {
-  }
-  virtual ~ decoderNull ()
-  {
-  };
-  virtual uint8_t uncompress (ADMCompressedImage * in, ADMImage * out)
-  {
-    memcpy (out->data, in->data, in->dataLength);
-    return 1;
-  }
-};

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_codecs.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_codecs.cpp	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_codecs.cpp	2010-01-10 18:08:39 UTC (rev 5834)
@@ -1,316 +0,0 @@
-/***************************************************************************
-                          ADM_codecs.cpp  -  description
-                             -------------------
-    begin                : Fri Apr 12 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
-
-    see here : http://www.webartz.com/fourcc/
-
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include "config.h"
-
-
-#ifdef USE_FFMPEG
-extern "C"
-{
-#include "ADM_lavcodec.h"
-};
-#endif
-#include "ADM_default.h"
-#ifdef BIG_ENDIAN
-#undef BIG_ENDIAN
-#endif
-
-//#include "ADM_colorspace/colorspace.h"
-
-#ifdef USE_XX_XVID
-#include "xvid.h"
-#endif
-
-#include "ADM_codecs/ADM_codec.h"
-#include "ADM_codecs/ADM_mjpeg.h"
-#include "ADM_codecs/ADM_codecNull.h"
-#include "ADM_codecs/ADM_rgb16.h"
-#include "ADM_codecs/ADM_uyvy.h"
-#include "avidemutils.h"
-#include "fourcc.h"
-
-
-#include "ADM_codecs/ADM_ffmp43.h"
-
-
-#ifdef USE_THEORA
-#include "ADM_codecs/ADM_theora_dec.h"
-#endif
-
-#include "ADM_codecs/ADM_png.h"
-
-#include "ADM_assert.h"
-#include "prefs.h"
-
-extern uint8_t GUI_Question (char *);
-extern uint8_t use_fast_ffmpeg;
-extern bool vdpauUsable(void);
-
-uint8_t
-  decoders::uncompress (ADMCompressedImage * in, ADMImage * out)
-{
-  UNUSED_ARG (in);
-  UNUSED_ARG (out);
-  return 0;
-}
-decoders *
-getDecoderVopPacked (uint32_t fcc, uint32_t w, uint32_t h, uint32_t extraLen,
-		     uint8_t * extraData)
-{
-  UNUSED_ARG (fcc);
-  UNUSED_ARG (extraLen);
-  UNUSED_ARG (extraData);
-  return (decoders *) (new decoderFFMpeg4VopPacked (w, h));
-
-}
-decoders *getDecoderH264noLogic (uint32_t fcc, uint32_t w, uint32_t h, uint32_t extraLen,
-		     uint8_t * extraData)
-{
-  UNUSED_ARG (fcc);
-  UNUSED_ARG (extraLen);
-  UNUSED_ARG (extraData);
-  return (decoders *) (new decoderFFH264 (w, h, extraLen, extraData,0));
-
-}
-/**
-    \fn getDecoder
-    \brief returns the correct decoder for a stream
-*/
-decoders *getDecoder (uint32_t fcc, uint32_t w, uint32_t h, uint32_t extraLen,
-	    uint8_t * extraData,uint32_t bpp)
-{
-  printf("\nSearching decoder (%d x %d, extradataSize:%d)...\n",w,h,extraLen);
-  if (isMSMpeg4Compatible (fcc) == 1)
-    {
-      // For div3, no problem we take ffmpeg
-
-      return (decoders *) (new decoderFFDiv3 (w, h));
-    }
-
-#ifdef USE_FFMPEG
-  if (isDVCompatible(fcc))//"CDVC"))
-    {
-
-      return (decoders *) (new decoderFFDV (w, h, extraLen, extraData));
-    }
-#endif
-#ifdef USE_FFMPEG
-  if (fourCC::check (fcc, (uint8_t *) "MP42"))
-    {
-
-      return (decoders *) (new decoderFFMP42 (w, h));
-    }
-#endif
-    if (fourCC::check (fcc, (uint8_t *) "FLV1"))
-    {
-      return (decoders *) (new decoderFFFLV1 (w, h,extraLen, extraData));
-    }
-
-
-#ifdef USE_FFMPEG
-  if (fourCC::check (fcc, (uint8_t *) "H263"))
-    {
-
-      return (decoders *) (new decoderFFH263 (w, h));
-    }
-  if (fourCC::check (fcc, (uint8_t *) "HFYU"))
-    {
-
-      return (decoders *) (new decoderFFhuff (w, h, extraLen, extraData,bpp));
-    }
-#ifdef USE_PNG
-  if (fourCC::check (fcc, (uint8_t *) "PNG "))
-    {
-
-      return (decoders *) (new decoderPng (w, h));
-    }
-#endif
- if (fourCC::check (fcc, (uint8_t *) "cvid"))
-    {
-
-      return (decoders *) (new decoderFFCinepak (w, h, extraLen, extraData));
-    }
-  if (fourCC::check (fcc, (uint8_t *) "FFVH"))
-    {
-
-      return (decoders *) (new decoderFF_ffhuff (w, h, extraLen, extraData,bpp));
-    }
-if (fourCC::check (fcc, (uint8_t *) "SVQ1"))
-    {
-
-      return (decoders *) (new decoderFFSVQ1 (w, h, extraLen, extraData));
-    }
-
-  if (fourCC::check (fcc, (uint8_t *) "SVQ3"))
-    {
-
-      return (decoders *) (new decoderFFSVQ3 (w, h, extraLen, extraData));
-    }
-  if (fourCC::check (fcc, (uint8_t *) "tscc"))
-    {
-
-      return (decoders *) (new decoderCamtasia (w, h, bpp));
-    }
-
-     if (fourCC::check (fcc, (uint8_t *) "CRAM"))
-    {
-
-      return (decoders *) (new decoderFFCRAM (w, h, extraLen, extraData));
-    }
-  if (fourCC::check (fcc, (uint8_t *) "WMV2"))
-    {
-
-      return (decoders *) (new decoderFFWMV2 (w, h, extraLen, extraData));
-    }
-    if (fourCC::check (fcc, (uint8_t *) "WMV1"))
-    {
-
-      return (decoders *) (new decoderFFWMV1 (w, h, extraLen, extraData));
-    }
-
-  if (fourCC::check (fcc, (uint8_t *) "WMV3") )
-    {
-
-      return (decoders *) (new decoderFFWMV3 (w, h, extraLen, extraData));
-    }
-
-    if (fourCC::check (fcc, (uint8_t *) "WVC1")|| fourCC::check (fcc, (uint8_t *) "WMVA"))
-    {
-
-      return (decoders *) (new decoderFFVC1 (w, h, extraLen, extraData));
-    }
-
-if (fourCC::check (fcc, (uint8_t *) "FFV1"))
-    {
-
-      return (decoders *) (new decoderFFV1 (w, h));
-    }
-  if (fourCC::check (fcc, (uint8_t *) "SNOW"))
-    {
-
-      return (decoders *) (new decoderSnow (w, h));
-    }
-  if (isH264Compatible (fcc))
-    {
-#ifdef USE_VDPAU
-        if(vdpauUsable()==true)
-            return (decoders *) (new decoderFFVDPAU (w, h, extraLen, extraData));
-        else
-#endif
-            return (decoders *) (new decoderFFH264 (w, h, extraLen, extraData,1));
-    }
-#endif
-
-/*
-	Could be either divx5 packed crap or xvid or ffmpeg
-	For now we return FFmpeg and later will switch to divx5 if available
-		(ugly hack for ugly hack....)
-*/
-
-  if (isMpeg4Compatible (fcc) == 1)
-    {
-      return (decoders *) (new decoderFFMpeg4 (w, h, fcc,extraLen, extraData));
-      //    return(decoders *)( new decoderXvid(w,h));
-      //    return(decoders *)( new decoderDIVX(w,h));
-    }
-
-  if (fourCC::check (fcc, (uint8_t *) "MJPB"))
-    {
-      printf ("\n using FF mjpeg codec\n");
-      return (decoders *) (new decoderFFMjpegB (w, h,extraLen,extraData));
-    }
-if (fourCC::check (fcc, (uint8_t *) "MJPG")
-      || fourCC::check (fcc, (uint8_t *) "mjpa"))
-    {
-#if  0
-      //#ifdef USE_MJPEG
-      printf ("\n using mjpeg codec\n");
-      return (decoders *) (new decoderMjpeg (w, h));
-#else
-      printf ("\n using FF mjpeg codec\n");
-      return (decoders *) (new decoderFFMJPEG (w, h));
-#endif
-
-    }
-  if (fourCC::check (fcc, (uint8_t *) "YV12")
-      || fourCC::check (fcc, (uint8_t *) "yv12")
-      || fourCC::check (fcc, (uint8_t *) "I420"))
-    {
-      printf ("\n using null codec\n");
-      return (decoders *) (new decoderNull (w, h));
-    }
-  if (fourCC::check (fcc, (uint8_t *) "UYVY"))
-    {
-      printf ("\n using uyvy codec\n");
-      return (decoders *) (new decoderUYVY (w, h));
-    }
-  if (fourCC::check (fcc, (uint8_t *) "YUY2"))
-    {
-      printf ("\n using YUY2 codec\n");
-      return (decoders *) (new decoderYUY2 (w, h));
-    }
-  if (fourCC::check (fcc, (uint8_t *) "AMV "))
-    {
-      printf ("\n using AMV codec\n");
-      return (decoders *) (new decoderFFAMV (w, h,extraLen,extraData));
-    }
-
- if (fourCC::check (fcc, (uint8_t *) "VP6A"))
-    {
-      printf ("\n using YUY2 codec\n");
-      return (decoders *) (new decoderFFVP6A (w, h,extraLen,extraData));
-    }
-  if (isVP6Compatible(fcc))
-    {
-      printf ("\n using VP6F codec\n");
-      return (decoders *) (new decoderFFVP6F (w, h,extraLen,extraData));
-    }
-
-
-  if ((fcc == 0) || fourCC::check (fcc, (uint8_t *) "RGB "))
-    {
-      // RGB 16 Codecs
-      printf ("\n using RGB codec\n");
-      return (decoders *) (new decoderRGB16 (w, h, 1, bpp));
-
-    }
- if ((fcc == 0) || fourCC::check (fcc, (uint8_t *) "DIB "))
-    {
-      // RGB 16 Codecs
-      printf ("\n using DIB codec\n");
-      return (decoders *) (new decoderRGB16 (w, h, 0, bpp));
-
-    }
-  if (isMpeg12Compatible (fcc))
-	  return (decoders *) (new decoderFFMpeg12 (w, h, extraLen, extraData));
-
-  // default : null decoder
-  printf ("\n using invalid codec for \n");
-  fourCC::print (fcc);
-
-  return (decoders *) (new decoderEmpty (w, h));
-}
-
-uint8_t coders::compress (ADMImage * in, ADMBitstream * out)
-{
-  UNUSED_ARG (in);
-  UNUSED_ARG (out);
-
-  return 0;
-}

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_ffmp43.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_ffmp43.cpp	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_ffmp43.cpp	2010-01-10 18:08:39 UTC (rev 5834)
@@ -1,838 +0,0 @@
-/***************************************************************************
-                          ADM_ffmp43.cpp  -  description
-                             -------------------
-                             
-	Decoder for Divx3/4/..., using ffmpeg
-                             
-    begin                : Wed Sep 25 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include "config.h"
-
-
-#include "ADM_assert.h"
-#include "prefs.h"
-extern "C" {
-#include "ADM_lavcodec.h"
-}
-#include "ADM_default.h"
-
-#include "ADM_codecs/ADM_codec.h"
-#include "ADM_codecs/ADM_ffmp43.h"
-#include "DIA_coreToolkit.h"
-
-#include "ADM_debugID.h"
-#define MODULE_NAME  MODULE_CODEC
-#include "ADM_debug.h"
-#include "ADM_videoInfoExtractor.h"
-
-extern int ADM_cpu_num_processors(void);
-extern "C"
-{
-    static void ADM_releaseBuffer(struct AVCodecContext *avctx, AVFrame *pic);
-    static int  ADM_getBuffer(AVCodecContext *avctx, AVFrame *pic);
-}
-
-
-
-#define WRAP_Open_Template(funcz,argz,display,codecid) \
-{\
-AVCodec *codec=funcz(argz);\
-if(!codec) {GUI_Error_HIG("Codec",QT_TR_NOOP("Internal error finding codec"display));ADM_assert(0);} \
-  codecId=codecid; \
-  _context->workaround_bugs=1*FF_BUG_AUTODETECT +0*FF_BUG_NO_PADDING; \
-  _context->error_concealment=3; \
-  if (avcodec_open(_context, codec) < 0)  \
-                      { \
-                                        printf("[lavc] Decoder init: "display" video decoder failed!\n"); \
-                                        GUI_Error_HIG("Codec","Internal error opening "display); \
-                                        ADM_assert(0); \
-                                } \
-                                else \
-                                { \
-                                        printf("[lavc] Decoder init: "display" video decoder initialized! (%s)\n",codec->long_name); \
-                                } \
-}
-
-#define WRAP_Open(x)            {WRAP_Open_Template(avcodec_find_decoder,x,#x,x);}
-#define WRAP_OpenByName(x,y)    {WRAP_Open_Template(avcodec_find_decoder_by_name,#x,#x,y);}
-
-
-//****************************
-extern uint8_t DIA_lavDecoder (uint32_t * swapUv, uint32_t * showU);
-extern "C"
-{
-  int av_is_voppacked (AVCodecContext * avctx, int *vop_packed, int *gmc,
-		       int *qpel);
-};
-/**
-    \fn clonePic
-    \brief Convert AvFrame to ADMImage
-*/
-uint8_t decoderFF::clonePic (AVFrame * src, ADMImage * out)
-{
-  uint32_t    u,v;
-  ADM_assert(out->_isRef);
-  out->_planes[0] = (uint8_t *) src->data[0];
-  out->_planeStride[0] = src->linesize[0];
-  if (_swapUV)
-    {
-      u = 1;
-      v = 2;
-    }
-  else
-    {
-      u = 2;
-      v = 1;
-    }
-  out->_planes[1] = (uint8_t *) src->data[u];
-  out->_planeStride[1] = src->linesize[u];
-
-  out->_planes[2] = (uint8_t *) src->data[v];
-  out->_planeStride[2] = src->linesize[v];
-
-  _lastQ = 0;			//_context->quality;
-  out->_Qp = (src->quality * 32) / FF_LAMBDA_MAX;
-  out->flags = frameType ();
-
-  // Quant ?
-  if (src->qstride && src->qscale_table && codecId != CODEC_ID_H264)
-    {
-      out->quant = (uint8_t *) src->qscale_table;
-      out->_qStride = src->qstride;
-      out->_qSize = (_w + 15) >> 4;
-      out->_qSize *= (_h + 15) >> 4;	// FixME?
-    }
-  else
-    {
-      out->_qSize = out->_qStride = 0;
-      out->quant = NULL;
-    }
-    //printf("[LAVC] Old pts :%"LLD" new pts :%"LLD"\n",out->Pts, (uint64_t)(src->reordered_opaque));
-    //printf("[LAVC] pts: %"LLU"\n",src->pts);
-    out->Pts= (uint64_t)(src->reordered_opaque);
-    return 1;
-}
-/**
-        \fn decoderMultiThread
-        \brief Enabled multitheaded decoder if possible
-*/
-void decoderFF::decoderMultiThread (void)
-{
-  uint32_t threads = 0;
-
-  prefs->get(FEATURE_THREADING_LAVC, &threads);
-
-  if (threads == 0)
-	  threads = ADM_cpu_num_processors();
-
-  if (threads == 1)
-	  threads = 0;
-
-  if (threads)
-  {
-      printf ("[lavc] Enabling MT decoder with %u threads\n", threads);
-
-      if (avcodec_thread_init (_context, threads) == -1)
-	      printf ("[lavc] Failed!!\n");
-	  else
-          _usingMT = 1;
-  }
-}
-uint8_t decoderFF::getPARWidth (void)
-{
-  if(!_context->sample_aspect_ratio.num) return 1;
-  return _context->sample_aspect_ratio.num;
-}
-uint8_t decoderFF::getPARHeight (void)
-{
-  if(!_context->sample_aspect_ratio.den) return 1;
-  return _context->sample_aspect_ratio.den;
-
-}
-
-  
-uint8_t decoderFF::isDivxPacked (void)
-{
-  int
-    vop,
-    gmc,
-    qpel;
-  av_is_voppacked (_context, &vop, &gmc, &qpel);
-  return vop;
-}
-// Fill the bitfields for some mpeg4 specific info
-// It is a bit of a hack as we make it a general
-// stuff (i.e. shared with all codecs) whereas it is mpeg4 specific
-// and should stay within mpeg4 scope FIXME
-uint32_t decoderFF::getSpecificMpeg4Info (void)
-{
-  int
-    vop,
-    gmc,
-    qpel;
-  uint32_t
-    out = 0;
-  av_is_voppacked (_context, &vop, &gmc, &qpel);
-
-  if (qpel)
-    out += ADM_QPEL_ON;
-  if (_gmc)
-    out += ADM_GMC_ON;
-  if (vop)
-    out += ADM_VOP_ON;
-
-  return out;
-}
-
-//________________________________________________
-void
-decoderFF::setParam (void)
-{
-  DIA_lavDecoder (&_swapUV, &_showMv);
-  return;			// no param for ffmpeg
-}
-
-//-------------------------------
-decoderFF::decoderFF (uint32_t w, uint32_t h):decoders (w, h)
-{
-  codecId = 0;
-//                              memset(&_context,0,sizeof(_context));
-  _allowNull = 0;
-  _gmc = 0;
-  _context = NULL;
-  _refCopy = 0;
-  _usingMT = 0;
-#if LIBAVCODEC_BUILD >= 4624
-  _context = avcodec_alloc_context ();
-#else
-  _context = new AVCodecContext;
-  memset (_context, 0, sizeof (AVCodecContext));
-#endif
-  ADM_assert (_context);
-  memset (&_frame, 0, sizeof (_frame));
-
-  _context->max_b_frames = 0;
-
-  _context->width = _w;
-  _context->height = _h;
-  _context->pix_fmt = PIX_FMT_YUV420P;	//PIX_FMT_RGBA32
-  //_context->debug=1;
-
-  _internalBuffer = new uint8_t[w * h * 3];
-
-  _swapUV = 0;
-  //_context->strict_std_compliance=-1;
-
-  _showMv = 0;
-#define FF_SHOW		(FF_DEBUG_VIS_MV_P_FOR+	FF_DEBUG_VIS_MV_B_FOR+FF_DEBUG_VIS_MV_B_BACK)
-//#define FF_SHOW               (FF_DEBUG_VIS_MV_P_FOR)
-  printf ("[lavc] Build: %d\n", LIBAVCODEC_BUILD);
-  _context->debug_mv |= FF_SHOW;
-  _context->debug |= FF_DEBUG_VIS_MB_TYPE + FF_DEBUG_VIS_QP;
-  
-}
-
-//_____________________________________________________
-
-decoderFF::~decoderFF ()
-{
-  if (_usingMT)
-    {
-      printf ("[lavc] Killing decoding threads\n");
-      avcodec_thread_free (_context);
-      _usingMT = 0;
-    }
-
-  avcodec_close (_context);
-  ADM_dealloc (_context);
-  delete[]_internalBuffer;
-  printf ("[lavc] Destroyed\n");
-}
-
-/**
-    \fn frameType
-    \return frametype of the last decoded frame
-*/
-uint32_t decoderFF::frameType (void)
-{
-  uint32_t
-    flag = 0;
-
-  AVFrame *
-    target;
-#define SET(x) {flag=x;aprintf("Frame is %s\n",#x);}
-
-
-  target = &_frame;
-  switch (target->pict_type)
-    {
-    case FF_B_TYPE:
-      SET (AVI_B_FRAME);
-      if (target->key_frame)
-	aprintf ("\n But keyframe is set\n");
-      break;
-
-    case FF_I_TYPE:
-      SET (AVI_KEY_FRAME);
-      if (!target->key_frame)
-	{
-	  if (codecId == CODEC_ID_H264)
-	    {
-	      SET (AVI_P_FRAME);
-	    }
-	  else
-	    printf ("\n But keyframe is not set\n");
-	}
-      break;
-    case FF_S_TYPE:
-      _gmc = 1;			// No break, just inform that gmc is there
-    case FF_P_TYPE:
-      SET (AVI_P_FRAME);
-      if (target->key_frame)
-	aprintf ("\n But keyframe is set\n");
-      break;
-    default:
-//                              printf("\n OOops XXX frame ?\n");
-      break;
-    }
-  return flag;
-}
-uint8_t decoderFF::decodeHeaderOnly (void)
-{
-  if (codecId == CODEC_ID_H264)
-    _context->hurry_up = 4;
-  else
-    _context->hurry_up = 5;
-  printf ("\n[lavc] Hurry up\n");
-  return 1;
-}
-uint8_t decoderFF::decodeFull (void)
-{
-  _context->hurry_up = 0;
-  printf ("\n[lavc] full decoding\n");
-  return 1;
-}
-
-/**
-    \fn flush
-    \brief empty internal buffer
-*/
-bool    decoderFF::flush(void)
-{
-    if(_context)
-        avcodec_flush_buffers(_context);
-    return true;
-}
-/**
-    \fn uncompress
-    \brief Actually decode an image
-*/
-uint8_t   decoderFF::uncompress (ADMCompressedImage * in, ADMImage * out)
-{
-  int got_picture = 0;
-  uint8_t *oBuff[3];
-  int strideTab[3];
-  int strideTab2[3];
-  int ret = 0;
-  out->_noPicture = 0;
-  if (_showMv)
-    {
-      _context->debug_mv |= FF_SHOW;
-      _context->debug |= 0;	//FF_DEBUG_VIS_MB_TYPE;
-    }
-  else
-    {
-      _context->debug_mv &= ~FF_SHOW;
-      _context->debug &= ~(FF_DEBUG_VIS_MB_TYPE + FF_DEBUG_VIS_QP);
-    }
-
-   
-    
-  if (in->dataLength == 0 && !_allowNull)	// Null frame, silently skipped
-    {
-      
-      printf ("[Codec] null frame\n");
-        // search the last image
-        if (_context->coded_frame && 
-            _context->coded_frame->data &&
-            _context->coded_frame->data[0]
-            )
-          {
-            printf("[Codec] Cloning older pic\n");
-            clonePic (_context->coded_frame, out);
-            out->Pts=ADM_COMPRESSED_NO_PTS;
-          }
-        else
-            {
-                out->_noPicture = 1;
-                out->Pts=ADM_COMPRESSED_NO_PTS;
-                printf("[Codec] No Picture\n");
-            }
-          return 1;
-    }
-   // Put a safe value....
-   out->Pts=in->demuxerPts;
-    _context->reordered_opaque=in->demuxerPts;
-  //_frame.opaque=(void *)out->Pts;
-  //printf("Incoming Pts :%"LLD"\n",out->Pts);
-  ret = avcodec_decode_video (_context, &_frame, &got_picture, in->data, in->dataLength);
-  if(!bFramePossible())
-  {
-    // No delay, the value is sure, no need to hide it in opaque
-    _context->reordered_opaque=(int64_t)in->demuxerPts;
-  }
-  out->_qStride = 0;		//Default = no quant
-  if (0 > ret && !_context->hurry_up)
-    {
-      printf ("\n[lavc] error in lavcodec decoder!\n");
-      printf ("[lavc] Err: %d, size :%d\n", ret, in->dataLength);
-      return 0;
-    }
-  if (!got_picture && !_context->hurry_up)
-    {
-      // Some encoder code a vop header with the 
-      // vop flag set to 0
-      // it is meant to mean frame skipped but very dubious
-      if (in->dataLength <= 8 && codecId == CODEC_ID_MPEG4)
-	{
-	  printf ("[lavc] Probably pseudo black frame...\n");
-	  out->_Qp = 2;
-	  out->flags = 0;	// assume P ?
-
-	  clonePic (_context->coded_frame, out);
-	  return 1;
-	}
-      // allow null means we allow null frame in and so potentially
-      // have no frame out for a time
-      // in that case silently fill with black and returns it as KF
-      if (_allowNull)
-	{
-	  out->flags = AVI_KEY_FRAME;
-	  if (!_refCopy)
-	    {
-	      memset (out->data, 0, _w * _h);
-	      memset (out->data + _w * _h, 128, (_w * _h) >> 1);
-	    }
-	  else
-	    {
-	      out->_noPicture = 1;
-	    }
-	  printf ("\n[lavc] ignoring got pict ==0\n");
-	  return 1;
-
-	}
-      printf ("[lavc] Err: %d, size: %d\n", ret, in->dataLength);
-      printf ("\n[lavc] error in FFMP43/mpeg4!: got picture\n");
-      //GUI_Alert("Please retry with misc->Turbo off");
-      //return 1;
-      return 0;
-    }
-  if (_context->hurry_up)
-    {
-      out->flags = frameType ();
-      return 1;
-    }
-  // We have an image....
-  switch (_context->pix_fmt)
-    {
-    case PIX_FMT_YUV411P:
-      out->_colorspace = ADM_COLOR_YUV411;
-      break;
-
-    case PIX_FMT_YUV422P:
-    case PIX_FMT_YUVJ422P:
-      out->_colorspace = ADM_COLOR_YUV422;
-      break;
-
-    case PIX_FMT_YUV444P:
-    case PIX_FMT_YUVJ444P:
-      out->_colorspace = ADM_COLOR_YUV444;
-      break;
-    case PIX_FMT_YUV420P:
-    case PIX_FMT_YUVJ420P:
-    case PIX_FMT_YUVA420P:
-      // Default is YV12 or I420
-      // In that case depending on swap u/v
-      // we do it or not
-      out->_colorspace = ADM_COLOR_YV12;
-      break;
-
-    case PIX_FMT_RGBA: // ???PIX_FMT_RGBA32:
-      out->_colorspace = ADM_COLOR_RGB32A;
-      break;
-    case PIX_FMT_RGB555:
-      out->_colorspace = ADM_COLOR_RGB555;
-      break;
-    case PIX_FMT_VDPAU_H264:
-        out->_colorspace=ADM_COLOR_VDPAU;
-        break;
-    default:
-      printf ("[lavc] Unhandled colorspace: %d\n", _context->pix_fmt);
-      return 0;
-    }
-    clonePic (&_frame, out);
-    //printf("[AvCodec] Pts : %llu Out Pts:%llu \n",_frame.pts,out->Pts);
-
-  return 1;
-}
-
-#define LOWDELAY() {} //_context->flags |= CODEC_FLAG_LOW_DELAY
-
-
-decoderFFDiv3::decoderFFDiv3 (uint32_t w, uint32_t h):decoderFF (w, h)
-{
-  _refCopy = 1;			// YUV420 only
-  WRAP_Open (CODEC_ID_MSMPEG4V3);
-}
-//**************************************************
-decoderFFMpeg4VopPacked::decoderFFMpeg4VopPacked (uint32_t w, uint32_t h):decoderFF (w,
-	   h)
-{
-/* In that case, we cannot use lowdelay...*/
-  _refCopy = 1;			// YUV420 only
-  _allowNull = 1;
-  decoderMultiThread ();
-  WRAP_Open (CODEC_ID_MPEG4);
-  printf("[lavc] Non low delay mpeg4 decoder initialized\n");
-}
-uint8_t decoderFFMpeg4VopPacked::uncompress (ADMCompressedImage * in, ADMImage * out)
-{
-    // For pseudo startcode
-    if(in->dataLength)
-    {
-        in->data[in->dataLength]=0;
-        in->data[in->dataLength+1]=0;
-    }
-    return decoderFF::uncompress(in,out);
-
-}
-
-decoderFFMpeg4::decoderFFMpeg4 (uint32_t w, uint32_t h, uint32_t fcc,uint32_t l, uint8_t * d):decoderFF (w,
-	   h)
-{
-// force low delay as avidemux don't handle B-frames
-  LOWDELAY();
-  printf ("[lavc] Using %d bytes of extradata for MPEG4 decoder\n", l);
-  
-  _refCopy = 1;			// YUV420 only
-  _context->extradata = (uint8_t *) d;
-  _context->extradata_size = (int) l;
-  _context->codec_tag=fcc;
-  _context->stream_codec_tag=fcc;
-  decoderMultiThread ();
-  //  _context->flags|=FF_DEBUG_VIS_MV;
-  WRAP_Open (CODEC_ID_MPEG4);
-}
-uint8_t decoderFFMpeg4::uncompress (ADMCompressedImage * in, ADMImage * out)
-{
-    // For pseudo startcode
-    if(in->dataLength)
-    {
-        in->data[in->dataLength]=0;
-        in->data[in->dataLength+1]=0;
-    }
-    return decoderFF::uncompress(in,out);
-
-}
-//************************************
-decoderFFDV::decoderFFDV (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,
-	   h)
-{
-  _context->extradata = (uint8_t *) d;
-  _context->extradata_size = (int) l;
-  WRAP_Open (CODEC_ID_DVVIDEO);
-
-}
-decoderFFMP42::decoderFFMP42 (uint32_t w, uint32_t h):decoderFF (w, h)
-{
-  _refCopy = 1;			// YUV420 only
-  WRAP_Open (CODEC_ID_MSMPEG4V2);
-
-}
-decoderFFMpeg12::decoderFFMpeg12 (uint32_t w, uint32_t h, uint32_t extraLen, uint8_t * extraData):decoderFF (w,
-	   h)
-{
-  int
-    got_picture = 0;
-  LOWDELAY();
-  _refCopy = 1;			// YUV420 only
-  decoderMultiThread ();
-  WRAP_Open (CODEC_ID_MPEG2VIDEO);
-}
-decoderFFSVQ3::decoderFFSVQ3 (uint32_t w, uint32_t h, uint32_t extraLen, uint8_t * extraData):decoderFF (w,
-	   h)
-{
-  int
-    got_picture = 0;
-
-  LOWDELAY();
-  _context->extradata = (uint8_t *) extraData;
-  _context->extradata_size = (int) extraLen;
-  WRAP_Open (CODEC_ID_SVQ3);
-}
-
-decoderFFH263::decoderFFH263 (uint32_t w, uint32_t h):decoderFF (w, h)
-{
-  _refCopy = 1;			// YUV420 only
-  WRAP_Open (CODEC_ID_H263);
-
-}
-decoderFFV1::decoderFFV1 (uint32_t w, uint32_t h):decoderFF (w, h)
-{
-  _refCopy = 1;			// YUV420 only
-  WRAP_Open (CODEC_ID_FFV1);
-}
-decoderFF_ffhuff::decoderFF_ffhuff (uint32_t w, uint32_t h, uint32_t l, uint8_t * d,uint32_t bpp):decoderFF (w,
-	   h)
-{
-  _context->extradata = (uint8_t *) d;
-  _context->extradata_size = (int) l;
-  _context->bits_per_coded_sample=bpp;
-  printf ("[lavc] FFhuff: We have %d bytes of extra data\n", l);
-  WRAP_Open (CODEC_ID_FFVHUFF);
-
-}
-decoderFFH264::decoderFFH264 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d, uint32_t lowdelay):decoderFF (w,
-	   h)
-{
-  _lowDelay=lowdelay;
-  _refCopy = 1;			// YUV420 only
-  _context->extradata = (uint8_t *) d;
-  _context->extradata_size = (int) l;
-  decoderMultiThread ();
-  if(lowdelay)
-    LOWDELAY();
-  printf ("[lavc] Initializing H264 decoder with %d extradata\n", l);
-
-       {
-        WRAP_Open(CODEC_ID_H264);
-    }
-
-
-}
-//*********************
-extern "C" {int av_getAVCStreamInfo(AVCodecContext *avctx, uint32_t  *nalSize, uint32_t *isAvc);}
-
-uint8_t   decoderFFH264::uncompress (ADMCompressedImage * in, ADMImage * out)
-{
-  if(!_context->hurry_up) return decoderFF::uncompress (in, out);
-  
-  uint32_t nalSize, isAvc;
-  av_getAVCStreamInfo(_context,&nalSize,&isAvc);
-  if(isAvc)
-  {
-      return extractH264FrameType(nalSize, in->data,in->dataLength,&(out->flags));
-  }else
-  {
-    return extractH264FrameType_startCode(nalSize, in->data,in->dataLength,&(out->flags));
-  }
-}
-//*********************
-decoderFFhuff::decoderFFhuff (uint32_t w, uint32_t h, uint32_t l, uint8_t * d,uint32_t bpp):decoderFF (w,
-	   h)
-{
-  _context->extradata = (uint8_t *) d;
-  _context->extradata_size = (int) l;
-  _context->bits_per_coded_sample = bpp;
-  WRAP_Open (CODEC_ID_HUFFYUV);
-}
-decoderFFWMV2::decoderFFWMV2 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,
-	   h)
-{
-  _context->extradata = (uint8_t *) d;
-  _context->extradata_size = (int) l;
-
-  WRAP_Open (CODEC_ID_WMV2);
-
-}
-decoderFFWMV1::decoderFFWMV1 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,
-	   h)
-{
-  _context->extradata = (uint8_t *) d;
-  _context->extradata_size = (int) l;
-
-  WRAP_Open (CODEC_ID_WMV1);
-
-}
-
-decoderFFWMV3::decoderFFWMV3 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,
-	   h)
-{
-  _context->extradata = (uint8_t *) d;
-  _context->extradata_size = (int) l;
-
-  WRAP_Open (CODEC_ID_WMV3);
-
-}
-
-decoderFFVC1::decoderFFVC1(uint32_t w, uint32_t h, uint32_t l, uint8_t * d) : decoderFF(w, h)
-{
-  _context->extradata = (uint8_t *) d;
-  _context->extradata_size = (int) l;
-
-  WRAP_Open (CODEC_ID_VC1);
-}
-
-decoderFFcyuv::decoderFFcyuv (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,
-	   h)
-{
-  _context->extradata = (uint8_t *) d;
-  _context->extradata_size = (int) l;
-
-  WRAP_Open (CODEC_ID_CYUV);
-}
-decoderFFMJPEG::decoderFFMJPEG (uint32_t w, uint32_t h):decoderFF (w, h)
-{
-  WRAP_Open (CODEC_ID_MJPEG);
-}
-decoderFFTheora::decoderFFTheora (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,
-	   h)
-{
-  _context->extradata = (uint8_t *) d;
-  _context->extradata_size = (int) l;
-  WRAP_Open (CODEC_ID_THEORA);
-}
-decoderSnow::decoderSnow (uint32_t w, uint32_t h):decoderFF (w, h)
-{
-  WRAP_Open (CODEC_ID_SNOW);
-}
-//*************
-decoderCamtasia::decoderCamtasia (uint32_t w, uint32_t h,uint32_t bpp):decoderFF (w,  h)
-{
-  _context->bits_per_coded_sample = bpp;
-  WRAP_Open (CODEC_ID_TSCC);
-}
-//*************
-decoderFFCinepak::decoderFFCinepak (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,	   h)
-{
-  WRAP_Open (CODEC_ID_CINEPAK);
-}
-//*************
-decoderFFCRAM::decoderFFCRAM (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,	   h)
-{
-  WRAP_Open (CODEC_ID_MSVIDEO1);
-}
-//*************
-decoderFFVP6F::decoderFFVP6F (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,	   h)
-{
-  WRAP_Open (CODEC_ID_VP6F);
-}
-//*************
-decoderFFVP6A::decoderFFVP6A (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,	   h)
-{
-  WRAP_Open (CODEC_ID_VP6A);
-}
-
-//*************
-decoderFFSVQ1::decoderFFSVQ1 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,	   h)
-{
-  WRAP_Open (CODEC_ID_SVQ1);
-}
-
-//************
-decoderFFFLV1::decoderFFFLV1 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,	   h)
-{
-  WRAP_Open (CODEC_ID_FLV1);
-}
-decoderFFAMV::decoderFFAMV (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,   h)
-{
-  WRAP_Open (CODEC_ID_AMV);
-  //_context->codec_id=CODEC_ID_AMV;
-}
-decoderFFMjpegB::decoderFFMjpegB (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,   h)
-{
-  WRAP_Open (CODEC_ID_MJPEGB);
-  //_context->codec_id=CODEC_ID_AMV;
-}
-decoderFFDVBSub::decoderFFDVBSub (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,	   h)
-{
-  _context->sub_id=1;
-  WRAP_Open (CODEC_ID_DVB_SUBTITLE);
-}
-//*********************
-/**
-    \fn decoderFFSubs
-    \brief Constructor for DVB subtitles...
-*/
-
-decoderFFSubs::decoderFFSubs (uint32_t subid)
-{
-  _context = avcodec_alloc_context ();
-  codecId= CODEC_ID_DVB_SUBTITLE;
-  subId=subid;
-  _context->sub_id=subId;
-  WRAP_Open (CODEC_ID_DVB_SUBTITLE);
-}
-decoderFFSubs:: ~ decoderFFSubs ()
-{
-  avcodec_close (_context);
-  ADM_dealloc (_context);
-  _context=NULL;
-  
-}
-
-uint8_t decoderFFSubs::uncompress (ADMCompressedImage * in, AVSubtitle * out)
-{
-  int ret=0;
-  int got_picture=0;
-  ret=avcodec_decode_subtitle(_context, out,
-                            &got_picture,
-                            in->data, in->dataLength); 
-     if(ret<0) 
-     {
-        printf("[lavc] FFSUB Error %d\n",ret);
-        return 0; 
-     }
-     return 1;
-}
-
-
-//***************
-extern uint8_t  lavformat_init(void);
-extern void     avcodec_init(void );
-extern  void    avcodec_register_all(void );
-extern "C"
-{
-  void adm_lavLogCallback(void  *instance, int level, const char* fmt, va_list list);
-}
-/**
-    \fn ADM_lavInit
-    \brief Init both lavcodec and lavformat
-*/
-void ADM_lavInit(void)
-{
-    avcodec_init();
-    avcodec_register_all();
-//BAZOOKA    lavformat_init();
-    av_log_set_callback(adm_lavLogCallback);
-#ifdef ADM_DEBUG
-  //  av_log_set_level(AV_LOG_DEBUG);
-#endif
-
-}
-void adm_lavLogCallback(void  *instance, int level, const char* fmt, va_list list)
-{
-   // if(level>1) return;
-    char buf[256];
-  
-    vsnprintf(buf, sizeof(buf), fmt, list);
-    printf("[lavc] %s",buf);
-}
-
-void ADM_lavDestroy(void)
-{
-	//av_free_static();
-}
-
-// EOF

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_ffmp43.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_ffmp43.h	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_ffmp43.h	2010-01-10 18:08:39 UTC (rev 5834)
@@ -1,397 +0,0 @@
-/***************************************************************************
-                          ADM_ffmp43.h  -  description
-                             -------------------
-                             
-	Mpeg4 ****decoder******** using ffmpeg
-	                              
-    begin                : Wed Sep 25 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include "ADM_lavcodec.h"
-class decoderFFSubs
-{
-  protected:
-     int      codecId;
-     uint32_t subId;
-     AVCodecContext *_context;
-  public:
-
-    decoderFFSubs (uint32_t subId);
-    virtual ~ decoderFFSubs ();
-    virtual uint8_t uncompress (ADMCompressedImage * in, AVSubtitle * out); 
-};
-
-/****************************/
-class decoderFF:public decoders
-{
-protected:
-
-  int codecId;
-  uint8_t _refCopy;
-  AVCodecContext *_context;
-  AVFrame _frame;
-  uint8_t *_internalBuffer;
-  uint8_t _allowNull;
-  uint32_t _swapUV;
-  uint32_t frameType (void);
-  uint8_t clonePic (AVFrame * src, ADMImage * out);
-  void decoderMultiThread ();
-  uint32_t _showMv;
-  uint32_t _gmc;
-  uint32_t _usingMT;
-public:
-
-    decoderFF (uint32_t w, uint32_t h);
-    virtual ~ decoderFF ();
-  virtual uint8_t dontcopy (void)
-  {
-    return 1;
-  }
-  virtual uint8_t uncompress (ADMCompressedImage * in, ADMImage * out);
-  virtual void setParam (void);
-  virtual uint8_t bFramePossible (void)
-  {
-    return 0;
-  }
-  virtual uint8_t decodeHeaderOnly (void);
-  virtual uint8_t decodeFull (void);
-  virtual uint8_t isDivxPacked (void);
-  virtual uint32_t getSpecificMpeg4Info (void);
-  virtual uint8_t getPARWidth (void);
-  virtual uint8_t getPARHeight (void);
-  virtual bool    flush(void);
-};
-
-class decoderFFDiv3:public decoderFF
-{
-protected:
-
-
-public:
-
-  decoderFFDiv3 (uint32_t w, uint32_t h);
-
-};
-class decoderFFMpeg4VopPacked:public decoderFF
-{
-protected:
-
-
-public:
-  decoderFFMpeg4VopPacked (uint32_t w, uint32_t h);
-  uint8_t uncompress (ADMCompressedImage * in, ADMImage * out);
-  // mpeg4 can have B-frame
-  virtual uint8_t bFramePossible (void)
-  {
-    return 0;
-  }
-  // Vop packed are not indexable
-  virtual uint8_t isIndexable (void)
-  {
-    return 0;
-  };
-};
-class decoderFFMpeg4:public decoderFF
-{
-protected:
-
-
-public:
-  decoderFFMpeg4 (uint32_t w, uint32_t h, uint32_t fcc,uint32_t l, uint8_t * d);
-  uint8_t uncompress (ADMCompressedImage * in, ADMImage * out);
-  // mpeg4 can have B-frame
-  virtual uint8_t bFramePossible (void)
-  {
-    return 1;
-  }
-
-};
-class decoderFFMpeg12:public decoderFF
-{
-protected:
-
-
-public:
-  decoderFFMpeg12 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
-  // mpeg1/2 can have B-frame
-  virtual uint8_t bFramePossible (void)
-  {
-    return 1;
-  }
-
-};
-class decoderFFSVQ3:public decoderFF
-{
-protected:
-
-
-public:
-  decoderFFSVQ3 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
-  virtual uint8_t bFramePossible (void)
-  {
-    return 0;
-  }
-
-};
-
-class decoderFFDV:public decoderFF
-{
-protected:
-
-
-public:
-  decoderFFDV (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
-
-};
-class decoderFFMP42:public decoderFF
-{
-protected:
-
-
-public:
-  decoderFFMP42 (uint32_t w, uint32_t h);
-
-};
-class decoderFFH263:public decoderFF
-{
-protected:
-
-
-public:
-  decoderFFH263 (uint32_t w, uint32_t h);
-
-};
-class decoderFFH264:public decoderFF
-{
-protected:
-  uint32_t _lowDelay;
-
-public:
-  decoderFFH264 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d,uint32_t lowdelay);
-  virtual uint8_t bFramePossible (void)
-  {
-      return _lowDelay;
-  }
-  uint8_t   uncompress (ADMCompressedImage * in, ADMImage * out);
-
-};
-class decoderFFhuff:public decoderFF
-{
-protected:
-
-
-public:
-  decoderFFhuff (uint32_t w, uint32_t h, uint32_t l, uint8_t * d,uint32_t bpp);
-
-};
-class decoderFF_ffhuff:public decoderFF
-{
-protected:
-
-
-public:
-  decoderFF_ffhuff (uint32_t w, uint32_t h, uint32_t l, uint8_t * d,uint32_t bpp);
-
-};
-class decoderFFWMV2:public decoderFF
-{
-protected:
-
-
-public:
-  decoderFFWMV2 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
-
-};
-class decoderFFWMV1:public decoderFF
-{
-  protected:
-
-
-  public:
-    decoderFFWMV1 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
-
-};
-
-class decoderFFWMV3:public decoderFF
-{
-protected:
-
-
-public:
-  decoderFFWMV3 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
-
-};
-
-class decoderFFVC1:public decoderFF
-{
-protected:
-
-
-public:
-  decoderFFVC1 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
-
-};
-
-class decoderFFV1:public decoderFF
-{
-protected:
-
-
-public:
-  decoderFFV1 (uint32_t w, uint32_t h);
-
-};
-class decoderFFMJPEG:public decoderFF
-{
-protected:
-
-
-public:
-  decoderFFMJPEG (uint32_t w, uint32_t h);
-
-};
-class decoderSnow:public decoderFF
-{
-protected:
-
-
-public:
-  decoderSnow (uint32_t w, uint32_t h);
-
-};
-class decoderFFcyuv:public decoderFF
-{
-protected:
-
-
-public:
-  decoderFFcyuv (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
-
-};
-class decoderCamtasia:public decoderFF
-{
-protected:
-
-
-public:
-  decoderCamtasia (uint32_t w, uint32_t h,uint32_t bpp);
-
-};
-class decoderFFTheora:public decoderFF
-{
-protected:
-
-
-public:
-  decoderFFTheora (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
-
-};
-
-class decoderFFCinepak:public decoderFF
-{
-protected:
-
-
-public:
-  decoderFFCinepak (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
-
-};
-class decoderFFCRAM:public decoderFF
-{
-protected:
-
-
-public:
-  decoderFFCRAM (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
-
-};
-class decoderFFVP6F:public decoderFF
-{
-protected:
-public:
-  decoderFFVP6F (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
-};
-class decoderFFVP6A:public decoderFF
-{
-protected:
-public:
-  decoderFFVP6A (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
-};
-class decoderFFFLV1:public decoderFF
-{
-protected:
-public:
-  decoderFFFLV1 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
-};
-class decoderFFDVBSub:public decoderFF
-{
-protected:
-public:
-  decoderFFDVBSub (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
-};
-class decoderFFAMV:public decoderFF
-{
-protected:
-public:
-  decoderFFAMV (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
-};
-class decoderFFMjpegB:public decoderFF
-{
-protected:
-public:
-  decoderFFMjpegB (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
-};
-class decoderFFSVQ1:public decoderFF
-{
-protected:
-public:
-  decoderFFSVQ1 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
-};
-
-#ifdef USE_VDPAU
-class decoderFFVDPAU:public decoderFF
-{
-protected:
-                    int b_age;
-                    int ip_age[2];
-
-                    void     *vdpau;
-                    ADMImage *scratch;
-                    ADMImage *vdpau_copy;
-                    uint64_t vdpau_pts;
-                    bool     decode_status;
-                    bool     destroying;
-public:     // Callbacks
-                    int     getBuffer(AVCodecContext *avctx, AVFrame *pic);
-                    void    releaseBuffer(struct AVCodecContext *avctx, AVFrame *pic);
-                    void    goOn( const AVFrame *d,int type);            
-public:
-            // public API
-                    decoderFFVDPAU (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
-                    ~decoderFFVDPAU();
-    virtual uint8_t uncompress (ADMCompressedImage * in, ADMImage * out);
-    virtual uint8_t dontcopy (void)
-                      {
-                        return 0;
-                      }
-     virtual uint8_t bFramePossible (void)
-      {
-        return 1;
-      }
-
-};
-
-#endif
-// EOF
-

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_ffmpeg_vdpau.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_ffmpeg_vdpau.cpp	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_ffmpeg_vdpau.cpp	2010-01-10 18:08:39 UTC (rev 5834)
@@ -1,343 +0,0 @@
-/***************************************************************************
-            \file              ADM_ffmpeg_vdpau.cpp  
-            \brief Decoder using half ffmpeg/half VDPAU
-
-    The ffmpeg part is to preformat inputs for VDPAU
-    VDPAU is loaded dynamically to be able to make a binary
-        and have something working even if the target machine
-        does not have vdpau
-    Some part, especially get/buffer and ip_age borrowed from xbmc
-        as the api from ffmpeg is far from clear....
-
-
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-extern "C" {
-#include "ADM_lavcodec.h"
-}
-#include "ADM_default.h"
-#ifdef USE_VDPAU
-extern "C" {
- #include "ADM_ffmpeg/libavcodec/vdpau.h"
-}
-
-#include "vdpau/vdpau_x11.h"
-#include "vdpau/vdpau.h"
-#include "ADM_codecs/ADM_codec.h"
-#include "ADM_codecs/ADM_ffmp43.h"
-#include "DIA_coreToolkit.h"
-#include "ADM_dynamicLoading.h"
-#include "ADM_render/GUI_render.h"
-#include "ADM_ffmpeg_vdpau_internal.h"
-#include "prefs.h"
-
-static VdpFunctions funcs;
-
-static bool vdpauWorking=false;
-
-static ADM_LibWrapper        vdpauDynaLoader;
-static VdpDeviceCreateX11    *ADM_createVdpX11;
-static VdpDevice             vdpDevice;
-static VdpGetProcAddress     *vdpProcAddress;
-
-#define aprintf(...) {}
-
-/**
-    \fn vdpauUsable
-    \brief Return true if  vdpau can be used...
-*/
-bool vdpauUsable(void)
-{
-    uint32_t v=false;
-    if(!vdpauWorking) return false;
-    if(!prefs->get(FEATURE_VDPAU,&v)) v=false;
-    return v;
-}
-/**
-    \fn getFunc
-    \brief vdpau function pointers from ID
-*/
-static void *getFunc(uint32_t id)
-{
-    void *f;
-    if(VDP_STATUS_OK!=vdpProcAddress(vdpDevice,id,&f)) return NULL;
-    return (void *)f;
-}
-/**
-    \fn vdpauProbe
-    \brief Try loading vdpau...
-*/
-bool vdpauProbe(void)
-{
-    memset(&funcs,0,sizeof(funcs));
-    if(false==vdpauDynaLoader.loadLibrary("/usr/lib/libvdpau.so"))
-    {
-        return false;
-    }
-    ADM_createVdpX11=(VdpDeviceCreateX11*)vdpauDynaLoader.getSymbol("vdp_device_create_x11");
-    if(!ADM_createVdpX11) return false;
-
-    //
-    GUI_WindowInfo xinfo;
-    void *draw;
-    draw=UI_getDrawWidget();
-    UI_getWindowInfo(draw,&xinfo );
-    
-    // try to create....
-    if( VDP_STATUS_OK!=ADM_createVdpX11((Display*)xinfo.display,0,&vdpDevice,&vdpProcAddress))
-    {
-        return false;
-    }
-    // Now that we have the vdpProcAddress, time to get the functions....
-#define GetMe(fun,id)         funcs.fun= (typeof(funcs.fun))getFunc(id);ADM_assert(funcs.fun); 
-        
-    GetMe(getErrorString,VDP_FUNC_ID_GET_ERROR_STRING);
-    GetMe(getApiVersion,VDP_FUNC_ID_GET_API_VERSION);
-    GetMe(getInformationString,VDP_FUNC_ID_GET_INFORMATION_STRING);
-
-    GetMe(createSurface,VDP_FUNC_ID_VIDEO_SURFACE_CREATE);
-    GetMe(destroySurface,VDP_FUNC_ID_VIDEO_SURFACE_DESTROY);
-    GetMe(getDataSurface,VDP_FUNC_ID_VIDEO_SURFACE_GET_BITS_Y_CB_CR);
-
-    GetMe(decoderCreate,VDP_FUNC_ID_DECODER_CREATE);
-    GetMe(decoderDestroy,VDP_FUNC_ID_DECODER_DESTROY);
-    GetMe(decoderRender,VDP_FUNC_ID_DECODER_RENDER);
-
-
-
-    const char *versionString=NULL;
-    uint32_t version=0xff;
-        funcs.getInformationString(&versionString);
-        funcs.getApiVersion(&version);
-        printf("[VDPAU] API : 0x%x, info : %s\n",version,versionString);
-
-    vdpauWorking=true;
-    return true;
-}
-/**
-    \fn ADM_VDPAUgetBuffer
-    \brief trampoline to get a VDPAU surface
-*/
-int ADM_VDPAUgetBuffer(AVCodecContext *avctx, AVFrame *pic)
-{
-    decoderFFVDPAU *dec=(decoderFFVDPAU *)avctx->opaque;
-    return dec->getBuffer(avctx,pic);
-}
-/**
-    \fn getBuffer
-    \brief returns a VDPAU render masquerading as a AVFrame
-*/
-int decoderFFVDPAU::getBuffer(AVCodecContext *avctx, AVFrame *pic)
-{
-    vdpau_render_state * render;
-    if(VDPAU->freeQueue.size()==0)
-    {
-        printf("[VDPAU] No more available surface\n");
-        return -1;
-    }
-    // Get an image   
-    render=VDPAU->freeQueue.back();
-    VDPAU->freeQueue.pop_back();
-    render->state=0;
-    pic->data[0]=(uint8_t *)render;
-    pic->data[1]=(uint8_t *)render;
-    pic->data[2]=(uint8_t *)render;
-    pic->linesize[0]=0;
-    pic->linesize[1]=0;
-    pic->linesize[2]=0;
-    pic->type=FF_BUFFER_TYPE_USER;
-    render->state |= FF_VDPAU_STATE_USED_FOR_REFERENCE;
-    pic->reordered_opaque= avctx->reordered_opaque;
-    if(pic->reference)
-    {
-        pic->age=ip_age[0];
-        ip_age[0]=ip_age[1]+1;
-        ip_age[1]=1;
-        b_age++;
-    }else
-    {
-        pic->age=b_age;
-        ip_age[0]++;
-        ip_age[1]++;
-        b_age=1;
-    }
-    return 0;
-}
-/**
-    \fn releaseBuffer
-*/
-void decoderFFVDPAU::releaseBuffer(AVCodecContext *avctx, AVFrame *pic)
-{
-  vdpau_render_state * render;
-  int i;
-  if(destroying==true) return; // They are already freed...
-  render=(vdpau_render_state*)pic->data[0];
-  ADM_assert(render);
-
-  render->state &= ~FF_VDPAU_STATE_USED_FOR_REFERENCE;
-  for(i=0; i<4; i++){
-    pic->data[i]= NULL;
-  }
-  VDPAU->freeQueue.push_back(render);
-}
-/**
-    \fn ADM_VDPAUreleaseBuffer
-*/
- void ADM_VDPAUreleaseBuffer(struct AVCodecContext *avctx, AVFrame *pic)
-{
-    decoderFFVDPAU *dec=(decoderFFVDPAU *)avctx->opaque;
-    dec->releaseBuffer(avctx,pic);
-}
-/**
-    \fn decoderFFVDPAU
-*/
-decoderFFVDPAU::decoderFFVDPAU(uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,	   h)
-{
-        destroying=false;
-        _context->opaque          = this;
-        _context->get_buffer      = ADM_VDPAUgetBuffer;
-        _context->release_buffer  = ADM_VDPAUreleaseBuffer;
-        _context->draw_horiz_band = draw;
-        _context->slice_flags     = SLICE_FLAG_CODED_ORDER|SLICE_FLAG_ALLOW_FIELD;
-        _context->extradata = (uint8_t *) d;
-        _context->extradata_size = (int) l;
-
-        vdpau=(void *)new vdpauContext;
-        VDPAU->vdpDecoder=VDP_INVALID_HANDLE;
-        WRAP_OpenByName(h264_vdpau,CODEC_ID_H264);
-        
-        // Now instantiate our VDPAU surface & decoder
-        ADM_assert(VDP_STATUS_OK==funcs.decoderCreate(vdpDevice,VDP_DECODER_PROFILE_H264_HIGH,w,h,15,&(VDPAU->vdpDecoder)));
-        // Create our surfaces...
-        for(int i=0;i<NB_SURFACE;i++)
-        {
-            VDPAU->renders[i]=new vdpau_render_state;
-            memset(VDPAU->renders[i],0,sizeof( vdpau_render_state));
-            ADM_assert(VDP_STATUS_OK==funcs.createSurface(vdpDevice,VDP_CHROMA_TYPE_420,w,h,&(VDPAU->renders[i]->surface)));
-            VDPAU->freeQueue.push_back(VDPAU->renders[i]);
-        }
-        scratch=new ADMImage(w,h,1);
-        b_age = ip_age[0] = ip_age[1] = 256*256*256*64;
-
-}
-/**
-    \fn ~            void    goOn( const AVFrame *d);
-*/
-decoderFFVDPAU::~decoderFFVDPAU()
-{
-        printf("[VDPAU] Cleaning up\n");
-        destroying=true;
-        for(int i=0;i<NB_SURFACE;i++)
-        {
-            ADM_assert(VDP_STATUS_OK==funcs.destroySurface((VDPAU->renders[i]->surface)));
-            delete VDPAU->renders[i];
-        }
-         ADM_assert(VDP_STATUS_OK==funcs.decoderDestroy(VDPAU->vdpDecoder));
-         delete VDPAU;
-         vdpau=NULL;
-}
-/**
-    \fn uncompress
-*/
-uint8_t decoderFFVDPAU::uncompress (ADMCompressedImage * in, ADMImage * out)
-{
-VdpStatus status;
-    
-    // First let ffmpeg prepare datas...
-    vdpau_copy=out;
-    decode_status=false;
-    if(!decoderFF::uncompress (in, scratch))
-    {
-        printf("[VDPAU] No data from libavcodec\n");
-        return 0;
-    }
-    if(decode_status!=true)
-    {
-        printf("[VDPAU] error in renderDecode\n");
-        return 0;
-    }
-    // other part will be done in goOn
-  struct vdpau_render_state *rndr = (struct vdpau_render_state *)scratch->_planes[0];
-   VdpVideoSurface  surface;
-
-    surface=rndr->surface;
- void *planes[3];
-            planes[0]=vdpau_copy->GetWritePtr(PLANAR_Y);
-            planes[1]=vdpau_copy->GetWritePtr(PLANAR_U);
-            planes[2]=vdpau_copy->GetWritePtr(PLANAR_V);
-    uint32_t stride[3];
-            stride[0]=vdpau_copy->GetPitch(PLANAR_Y);
-            stride[1]=vdpau_copy->GetPitch(PLANAR_U);
-            stride[2]=vdpau_copy->GetPitch(PLANAR_V);
-
-    
-   // Copy back the decoded image to our output ADM_image
-   aprintf("[VDPAU] Getting datas from surface %d\n",surface);
-    status=funcs.getDataSurface(
-                surface,
-                VDP_YCBCR_FORMAT_YV12, //VdpYCbCrFormat   destination_ycbcr_format,
-                planes, //void * const *   destination_data,
-                stride //destination_pitches
-                );
-    if(VDP_STATUS_OK!=status)
-    {
-        
-        printf("[VDPAU] Cannot get data from surface <%s>\n",funcs.getErrorString(status));
-        decode_status=false;
-        return 0 ;
-    }
-    
-
-    //
-    out->Pts=scratch->Pts;
-    out->flags=scratch->flags;
-    return (uint8_t)decode_status;
-}
-/**
-    \fn goOn
-    \brief Callback from ffmpeg when a pic is ready to be decoded
-*/
-void decoderFFVDPAU::goOn( const AVFrame *d,int type)
-{
-   VdpStatus status;
-   struct vdpau_render_state *rndr = (struct vdpau_render_state *)d->data[0];
-   VdpVideoSurface  surface;
-
-    surface=rndr->surface;
-    vdpau_pts=d->reordered_opaque; // Retrieve our PTS
-
-     aprintf("[VDPAU] Decoding Using surface %d\n", surface);
-    status=funcs.decoderRender(VDPAU->vdpDecoder, surface,
-                            (void * const *)&rndr->info, rndr->bitstream_buffers_used, rndr->bitstream_buffers);
-    if(VDP_STATUS_OK!=status)
-    {
-        printf("[VDPAU] No data after decoderRender <%s>\n",funcs.getErrorString(status));
-        decode_status=false;
-        return ;
-    }
-    aprintf("[VDPAU] DecodeRender Ok***\n");
-    decode_status=true;
-    return;
-}
-
-
-/**
-    \fn draw
-    \brief callback invoked by lavcodec when a pic is ready to be decoded
-*/
-void draw(struct AVCodecContext *s,    const AVFrame *src, int offset[4],    int y, int type, int height)
-{
-    decoderFFVDPAU *dec=(decoderFFVDPAU *)s->opaque;
-    dec->goOn(src,type);
-}
-
-#endif
-// EOF

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_ffmpeg_vdpau_internal.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_ffmpeg_vdpau_internal.h	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_ffmpeg_vdpau_internal.h	2010-01-10 18:08:39 UTC (rev 5834)
@@ -1,82 +0,0 @@
-/***************************************************************************
-            \file              ADM_ffmpeg_vdpau.cpp  
-            \brief Decoder using half ffmpeg/half VDPAU
-
-    The ffmpeg part is to preformat inputs for VDPAU
-    VDPAU is loaded dynamically to be able to make a binary
-        and have something working even if the target machine
-        does not have vdpau
-
-
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifndef ADM_ffmpeg_vdpa_internal_H
-#define ADM_ffmpeg_vdpa_internal_H
-#include <vector>
-extern "C" {
-static void draw(struct AVCodecContext *s,    const AVFrame *src, int offset[4],    int y, int type, int height);
-static int ADM_VDPAUgetBuffer(AVCodecContext *avctx, AVFrame *pic);
-static void ADM_VDPAUreleaseBuffer(struct AVCodecContext *avctx, AVFrame *pic);
-}
-
-
-#define NB_SURFACE 50
-typedef struct 
-{
-        VdpDecoder            vdpDecoder;
-        vdpau_render_state *renders[NB_SURFACE];
-        std::vector <vdpau_render_state *>freeQueue;
-
-}vdpauContext;
-
-#define VDPAU ((vdpauContext *)vdpau)
-
-// VDPAU internal linker
-
-typedef struct 
-{
-    VdpGetErrorString       *getErrorString;
-    VdpGetApiVersion        *getApiVersion;
-    VdpGetInformationString *getInformationString;
-
-    VdpVideoSurfaceCreate   *createSurface;
-    VdpVideoSurfaceDestroy  *destroySurface;
-    VdpVideoSurfaceGetBitsYCbCr *getDataSurface;
-
-    VdpDecoderCreate        *decoderCreate;
-    VdpDecoderDestroy       *decoderDestroy;
-    VdpDecoderRender        *decoderRender;
-
-}VdpFunctions;
-
-#define WRAP_Open_Template(funcz,argz,display,codecid) \
-{\
-AVCodec *codec=funcz(argz);\
-if(!codec) {GUI_Error_HIG("Codec",QT_TR_NOOP("Internal error finding codec"display));ADM_assert(0);} \
-  codecId=codecid; \
-  _context->workaround_bugs=1*FF_BUG_AUTODETECT +0*FF_BUG_NO_PADDING; \
-  _context->error_concealment=3; \
-  if (avcodec_open(_context, codec) < 0)  \
-                      { \
-                                        printf("[lavc] Decoder init: "display" video decoder failed!\n"); \
-                                        GUI_Error_HIG("Codec","Internal error opening "display); \
-                                        ADM_assert(0); \
-                                } \
-                                else \
-                                { \
-                                        printf("[lavc] Decoder init: "display" video decoder initialized! (%s)\n",codec->long_name); \
-                                } \
-}
-
-#define WRAP_Open(x)            {WRAP_Open_Template(avcodec_find_decoder,x,#x,x);}
-#define WRAP_OpenByName(x,y)    {WRAP_Open_Template(avcodec_find_decoder_by_name,#x,#x,y);}
-
-#endif
\ No newline at end of file

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_mjpeg.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_mjpeg.cpp	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_mjpeg.cpp	2010-01-10 18:08:39 UTC (rev 5834)
@@ -1,115 +0,0 @@
-#if 0
-/***************************************************************************
-                          ADM_mjpeg.cpp  -  description
-                             -------------------
-          I think i could use plain jpeg instead but....
-
-
-    begin                : Fri Apr 12 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include <stdio.h>
-#include <stdlib.h>
-#include "ADM_assert.h"
-#include <string.h>
-#include <math.h>
-#include "ADM_default.h"
-#include "config.h"
-#ifdef USE_MJPEG
-#include "ADM_colorspace/colorspace.h"
-
-#include "ADM_codecs/ADM_codec.h"
-#include "ADM_codecs/ADM_mjpeg.h"
-extern "C"
-{
-#include "mjpegtools/jpegutils.h"
-}
-#include "ADM_gui/GUI_decodersettings.h"
- /*
-  * jpeg_data:       buffer with input / output jpeg
-  * len:             Length of jpeg buffer
-  * itype:           LAV_INTER_NONE: Not interlaced
-  *                  LAV_INTER_TOP_FIRST: Interlaced, top-field-first
-  *                  LAV_INTER_BOTTOM_FIRST: Interlaced, bottom-field-first
-  * ctype            Chroma format for decompression.
-  *                  Currently always 420 and hence ignored.
-  * raw0             buffer with input / output raw Y channel
-  * raw1             buffer with input / output raw U/Cb channel
-  * raw2             buffer with input / output raw V/Cr channel
-  * width            width of Y channel (width of U/V is width/2)
-  * height           height of Y channel (height of U/V is height/2)
-
-
-  int decode_jpeg_raw (unsigned char *jpeg_data, int len,
-  int itype, int ctype, int width, int height,
-  unsigned char *raw0, unsigned char *raw1,
-  unsigned char *raw2);
-
-  */
-void
-decoderMjpeg::setParam (void)
-{
-  int param;
-
-  param = _swap;
-  if (1 == getMjpegParams (&param))
-    {
-      _swap = param;
-    }
-
-}
-//________________________________________________
-
-uint8_t
-  decoderMjpeg::uncompress (uint8_t * in, uint8_t * out, uint32_t len,
-			    uint32_t * flagz)
-{
-  //
-  uint32_t delta;
-  uint8_t *outu, *outv;
-  //
-  UNUSED_ARG (flagz);
-
-
-  delta = _w * _h;
-
-  outu = out + delta;
-  outv = outu + (delta >> 2);
-  if (!_swap)
-
-    decode_jpeg_raw (in, len, 1, 0, _w, _h, out, outu, outv);
-
-  else
-    decode_jpeg_raw (in, len, 1, 0, _w, _h, out, outv, outu);
-
-  return 1;
-
-
-}
-
-//_____________________________________________________
-
-decoderMjpeg::~decoderMjpeg ()
-{
-
-
-}
-// constructor for mjpeg, init encoder and stuff
-decoderMjpeg::decoderMjpeg (uint32_t w, uint32_t h):decoders (w, h)
-{
-  // some mjpeg are encoded with u & v inverted
-  _swap = 0;
-
-}
-#endif
-#endif

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_mjpeg.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_mjpeg.h	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_mjpeg.h	2010-01-10 18:08:39 UTC (rev 5834)
@@ -1,29 +0,0 @@
-/***************************************************************************
-                          ADM_mjpeg.h  -  description
-                             -------------------
-    begin                : Sat Apr 13 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-class decoderMjpeg:decoders
-{
-protected:
-  uint8_t _swap;
-
-public:
-  decoderMjpeg (uint32_t w, uint32_t h);
-  virtual ~ decoderMjpeg ();
-  virtual void setParam (void);
-  virtual uint8_t uncompress (uint8_t * in, uint8_t * out, uint32_t len,
-			      uint32_t * flag = NULL);
-};

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_png.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_png.cpp	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_png.cpp	2010-01-10 18:08:39 UTC (rev 5834)
@@ -1,180 +0,0 @@
-/***************************************************************************
-                          ADM_png.cpp  -  description
-                             -------------------
-    begin                : Sat Sep 28 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include "config.h"
-#ifdef USE_PNG
-#include <stdio.h>
-#include <stdlib.h>
-
-#include <string.h>
-#include <math.h>
-
-#include "ADM_default.h"
-
-//#include "ADM_colorspace/colorspace.h"
-
-#include "ADM_codecs/ADM_codec.h"
-#include "ADM_codecs/ADM_png.h"
-extern "C"
-{
-#include "png.h"
-}
-#include "ADM_assert.h"
-
-#define PNG_PTR ((png_structp)png_ptr)
-#define INFO_PTR ((png_infop)info_ptr)
-#define INFO_END ((png_infop)end_info)
-/*
-   	Initialize codec
-*/
-static void user_read_data (png_structp png_ptr, png_bytep data, png_size_t length);
-
-void decoderPng::recalc (void)
-{
-  int mul;
-  if (colorspace == ADM_COLOR_RGB24)
-    mul = 3;
-
-  else
-    mul = 4;
-  for (int i = 0; i < _h; i++)
-    rows[i] = decoded + mul * _w * i;
-}
-
-
-decoderPng::decoderPng (uint32_t w, uint32_t h):decoders (w, h)
-{
-  rows = NULL;
-  decoded = NULL;
-  colorspace = ADM_COLOR_RGB24;
-
-  //****************************
-  // Prepare the decoded buffer*
-  //****************************
-  decoded = new uint8_t[4 * w * h];	// We take a bit more to be able to decode 32 bits png
-  // without causing a segfault
-  rows = new uint8_t *[h];
-  recalc ();
-}
- void decoderPng::Init (void)
-{
-  png_ptr =
-    (void *) png_create_read_struct (PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
-  ADM_assert (png_ptr);
-  info_ptr = (void *) png_create_info_struct (PNG_PTR);
-  ADM_assert (info_ptr);
-  end_info = (void *) png_create_info_struct (PNG_PTR);
-  ADM_assert (end_info);
-  memset (&io, 0, sizeof (io));
-  png_set_read_fn (PNG_PTR, &io, user_read_data);
-  png_set_rows (PNG_PTR, INFO_PTR, (png_byte **) rows);
-}
-void decoderPng::Cleanup (void)
-{
-  png_destroy_read_struct ((png_structpp) & png_ptr, (png_infopp) & info_ptr,
-			   (png_infopp) & end_info);
-}
-decoderPng::~decoderPng ()
-{
-  delete[]rows;
-  delete[]decoded;
-}
-/*
-   	Uncompress frame, set flags if needed
-*/
-uint8_t decoderPng::uncompress(ADMCompressedImage * in, ADMImage * out)
-{
-  int bpp;
-  int colortype;
-
-  // Check if it is png, and fill it
-  if (!!png_sig_cmp (in->data, 0, 8))
-
-    {
-      printf ("[PNG] wrong sig\n");
-      return 0;
-    }
-
-  //
-  //
-gain2:
-  Init ();
-  io.data = in->data;
-  io.size = in->dataLength;
-  io.cur = 0;
-  png_read_png (PNG_PTR, INFO_PTR, PNG_TRANSFORM_IDENTITY, NULL);
-
-  // Check if it is 24 or 32 bits RGB 
-  bpp = png_get_bit_depth (PNG_PTR, INFO_PTR);
-//   printf("Bpp:%u\n",bpp);
-  // if needed we change colorspace 
-  colortype = png_get_color_type (PNG_PTR, INFO_PTR);
-  // 
-  if (colorspace == ADM_COLOR_RGB24 && colortype == PNG_COLOR_TYPE_RGB_ALPHA)	// RGB32
-    {
-
-      // Switch to 32 bits
-      colorspace = ADM_COLOR_RGB32A;
-      recalc ();
-      goto gain2;
-    }
-
-  else if (colorspace == ADM_COLOR_RGB32A && colortype == PNG_COLOR_TYPE_RGB)
-
-    {
-
-      // Switch to 24 bits
-      colorspace = ADM_COLOR_RGB24;
-      recalc ();
-      goto gain2;
-    }
-  ADM_assert (out->_isRef);
-  out->_planes[0] = decoded;
-  out->_planes[1] = NULL;
-  out->_planes[2] = NULL;
-  if (colorspace == ADM_COLOR_RGB32A)
-    out->_planeStride[0] = _w * 4;
-
-  else
-    out->_planeStride[0] = _w * 3;
-  out->_planeStride[1] = 0;
-  out->_planeStride[2] = 0;
-  out->_colorspace = colorspace;
-  Cleanup ();
-  return 1;
-}
-
-// ******************************************************
-//    Memory based IO
-// ******************************************************
-void user_read_data (png_structp png_ptr, png_bytep data, png_size_t length)
-{
-  memAccess *ac;
-  ac = (memAccess *) png_get_io_ptr (png_ptr);
-  ADM_assert (length + ac->cur <= ac->size);	// or < ?
-  memcpy (data, ac->data + ac->cur, length);
-  ac->cur += length;
-} 
-
-void user_write_data (png_structp png_ptr, png_bytep data, png_size_t length)
-{
-} 
-
-void user_flush_data (png_structp png_ptr)
-{
-}
-//EOF
-#endif /*  */

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_png.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_png.h	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_png.h	2010-01-10 18:08:39 UTC (rev 5834)
@@ -1,78 +0,0 @@
-/***************************************************************************
-                          ADM_png  -  description
-                             -------------------
-    copyright            : (C) 2005 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
- 
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/ 
-#ifndef PNG_H_A
-#define PNG_H_A
-#ifdef USE_PNG
-
-typedef struct memAccess 
-{
-  
-int size;
-   
-int cur;
-   
-uint8_t * data;
-
-
-} memAccess;
-
-
-class decoderPng:public decoders 
-{
-
-protected:
-memAccess io;
-  
-ADM_colorspace colorspace;
-  
-void *png_ptr;
-  
-void *info_ptr;
-  
-void *end_info;
-  
-
-uint8_t ** rows;
-  
-uint8_t * decoded;
-  
-void Init (void);
-  
-void Cleanup (void);
-  
-void recalc (void);
-
-public:
-decoderPng (uint32_t w, uint32_t h);
-  
-virtual ~ decoderPng ();
-  
-virtual uint8_t uncompress(ADMCompressedImage * in, ADMImage * out);
-  
-uint8_t dontcopy (void)
-  {
-    return 1;
-  }
-
-
-
-};
-
-#endif /* 
- */
-#endif /* 
- */

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_rgb16.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_rgb16.cpp	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_rgb16.cpp	2010-01-10 18:08:39 UTC (rev 5834)
@@ -1,125 +0,0 @@
-/***************************************************************************
-                          ADM_rgb16.cpp  -  description
-                             -------------------
-    begin                : Mon May 27 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
-#include "ADM_default.h"
-//#include "ADM_colorspace/colorspace.h"
-
-#include "ADM_codecs/ADM_codec.h"
-#include "ADM_codecs/ADM_rgb16.h"
-
-decoderRGB16::decoderRGB16(uint32_t w, uint32_t h, uint32_t rgb, uint32_t bpp) : decoders (w, h)
-{
-	isRgb = rgb;
-	_bpp = bpp;
-
-	decoded = new uint8_t[_bpp * w * h];
-}
-
-decoderRGB16::~decoderRGB16()
-{
-	delete[] decoded;
-}
-
-uint8_t decoderRGB16::uncompress(ADMCompressedImage * in, ADMImage * out)
-{
-	int xx = _w * _h;
-	int lineSize = (_w * (_bpp / 8) + 3) & ~3;
-	ADM_colorspace colorspace;
-	int i, j;
-	uint8_t *src = in->data;
-	uint8_t *dst = decoded;
-
-	switch (_bpp)
-	{
-		case 16:
-			// FIXME - 16-bit could use a BGR555 or BGR565 colour mask
-			colorspace = ADM_COLOR_BGR555;
-			break;
-		case 24:
-		case 32:
-			if(isRgb)
-				colorspace = ADM_COLOR_RGB24;
-			else
-				colorspace = ADM_COLOR_BGR24;
-
-			break;
-		default:
-			printf("bpp %d not supported\n", _bpp);
-			return 0;
-	}
-
-	if (_bpp == 32)
-	{
-		for(i = 0; i < _h; i++)
-		{
-			uint8_t *buf = src;
-			uint8_t *ptr = dst;
-
-			for(j = 0; j < _w; j++)
-			{
-				ptr[0] = buf[0];
-				ptr[1] = buf[1];
-				ptr[2] = buf[2];
-				ptr += 3;
-				buf += 4;
-			}
-
-			src += lineSize;
-			dst += _w * 3;
-		}
-	}
-	else
-	{
-		memcpy(decoded, in->data, lineSize * _h);
-
-		if (lineSize == _w * _bpp)
-		{
-			// no extra junk in scanlines so copy as is
-			memcpy(decoded, in->data, lineSize * _h);
-		}
-		else
-		{
-			// strip extra junk from scanlines (due to 4 byte alignment)
-			for(i = 0; i < _h; i++)
-			{
-				memcpy(dst, src, _w * (_bpp / 8));
-				src += lineSize;
-				dst += _w * (_bpp / 8);
-			}
-		}
-	}
-
-	ADM_assert(out->_isRef);
-
-	out->flags = AVI_KEY_FRAME;
-	out->_colorspace = (ADM_colorspace)(colorspace | ADM_COLOR_BACKWARD);
-
-	out->_planes[0] = decoded;
-	out->_planes[1] = NULL;
-	out->_planes[2] = NULL;
-
-	out->_planeStride[0] = (_bpp / 8) * _w;
-	out->_planeStride[1] = 0;
-	out->_planeStride[2] = 0;
-
-	return 1;
-}
-//EOF

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_rgb16.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_rgb16.h	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_rgb16.h	2010-01-10 18:08:39 UTC (rev 5834)
@@ -1,38 +0,0 @@
-/***************************************************************************
-                          ADM_rgb16.h  -  description
-                             -------------------
-    begin                : Mon May 27 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifndef ADM_RGB16_H
-#define ADM_RGB16_H
-
-#include "ADM_colorspace.h"
-
-class decoderRGB16 : decoders
-{
-	protected:
-		uint8_t* planar;
-		ColRgbToYV12* color;
-		uint32_t isRgb; // Else BGR
-		uint32_t _bpp;
-		uint8_t* decoded;
-
-	public:
-		uint8_t dontcopy (void) { return 1; }
-		decoderRGB16 (uint32_t w, uint32_t h, uint32_t rgb, uint32_t bpp);
-		virtual ~decoderRGB16();
-		virtual uint8_t uncompress(ADMCompressedImage * in, ADMImage * out);
-};
-
-#endif

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_theora_dec.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_theora_dec.cpp	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_theora_dec.cpp	2010-01-10 18:08:39 UTC (rev 5834)
@@ -1,116 +0,0 @@
-/***************************************************************************
-                          ADM_theora_dec.cpp  -  description
-                             -------------------
-    begin                : Thu Sep 26 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include "config.h"
-#include "ADM_default.h"
-
-#ifdef USE_THEORA
-#include "ADM_colorspace/colorspace.h"
-
-#include "ADM_codecs/ADM_codec.h"
-
-#include "ADM_codecs/ADM_theora_dec.h"
-//________________________________________________
-void
-decoderTheora::setParam (void)
-{
-  return;			// no param for ffmpeg
-}
-//-------------------------------
-decoderTheora::decoderTheora (uint32_t w, uint32_t h):decoders (w, h)
-{
-  memset (&_tinfo, 0, sizeof (_tinfo));
-  memset (&_tstate, 0, sizeof (_tstate));
-
-  _tinfo.width = _w;
-  _tinfo.height = _h;
-  _tinfo.fps_numerator = 25;
-  _tinfo.fps_denominator = 1;
-  _tinfo.aspect_numerator = 4;
-  _tinfo.aspect_denominator = 3;
-  _tinfo.quality = 9;
-
-  _tinfo.version_major = 3;
-  _tinfo.version_minor = 1;
-
-
-  theora_decode_init (&_tstate, &_tinfo);
-  printf ("\n Theora initialized\n");
-}
-
-
-//-------------------------------
-
-uint8_t
-  decoderTheora::uncompress (uint8_t * in, uint8_t * out, uint32_t len,
-			     uint32_t * flagz)
-{
-  int got_picture = 0;
-
-  if (len == 0)			// Null frame, silently skip
-    {
-      if (flagz)
-	*flagz = 0;
-      return 1;
-    }
-  ogg_packet ogg;
-
-  memset (&ogg, 0, sizeof (ogg));
-  ogg.packet = in;
-  ogg.bytes = len;
-  /*
-     typedef struct {
-     unsigned char *packet;
-     long  bytes;
-     long  b_o_s;
-     long  e_o_s;
-
-     ogg_int64_t  granulepos;
-
-     ogg_int64_t  packetno;      sequence number for decode; the framing
-     knows where there's a hole in the data,
-     but we need coupling so that the codec
-     (which is in a seperate abstraction
-     layer) also knows about the gap 
-     } ogg_packet; */
-  if (theora_decode_packetin (&_tstate, &ogg))
-    {
-      printf ("\n error decoding theora ..\n");
-      return 0;
-    }
-  yuv_buffer yuv;
-  theora_decode_YUVout (&_tstate, &yuv);
-  memcpy (out, yuv.y, _w * _h);
-  memset (out + _w * _h, 128, (_w * _h) >> 1);
-
-
-
-
-
-  return 1;
-}
-
-//_____________________________________________________
-
-decoderTheora::~decoderTheora ()
-{
-
-  printf ("Theora destroyed\n");
-  theora_clear (&_tstate);
-}
-
-#endif

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_theora_dec.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_theora_dec.h	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_theora_dec.h	2010-01-10 18:08:39 UTC (rev 5834)
@@ -1,46 +0,0 @@
-/***************************************************************************
-                          ADM_theora_dec.h  -  description
-                             -------------------
-    begin                : Thu Sep 26 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifdef USE_THEORA
-#ifndef __theora__
-#define __theora__
-
-extern "C"
-{
-#include "theora/theora.h"
-}
-class decoderTheora:public decoders
-{
-protected:
-
-
-  theora_info _tinfo;
-  theora_state _tstate;
-
-
-
-public:
-    decoderTheora (uint32_t w, uint32_t h);
-    virtual ~ decoderTheora ();
-  virtual uint8_t uncompress (uint8_t * in, uint8_t * out, uint32_t len,
-			      uint32_t * flag = NULL);
-  virtual void setParam (void);
-
-
-};
-
-#endif
-#endif

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_theora_enc.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_theora_enc.h	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_theora_enc.h	2010-01-10 18:08:39 UTC (rev 5834)
@@ -1,16 +0,0 @@
-/***************************************************************************
-                          ADM_theora_enc.h  -  description
-                             -------------------
-    begin                : Thu Sep 26 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_uyvy.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_uyvy.cpp	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_uyvy.cpp	2010-01-10 18:08:39 UTC (rev 5834)
@@ -1,113 +0,0 @@
-//
-// C++ Implementation: ADM_uyvy
-//
-// Description: 
-//
-//
-// Author: mean <fixounet at free.fr>, (C) 2004
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-#include "config.h"
-#include <stdio.h>
-
-#ifdef HAVE_SYS_PARAM_H
-#include <sys/param.h>
-#endif
-#if  defined( __FreeBSD__ ) || defined(__APPLE__)
-#include <sys/types.h>
-#endif
-
-#include "ADM_default.h"
-#include "avifmt.h"
-#include "avifmt2.h"
-#include "fourcc.h"
-
-#include "ADM_codecs/ADM_codec.h"
-#include "ADM_codecs/ADM_uyvy.h"
-
-uint8_t
-  decoderUYVY::uncompress (ADMCompressedImage * in, ADMImage * out)
-{
-
-  if (in->dataLength < _w * _h * 2)
-    {
-      printf ("in:%d expected%d\n", in->dataLength, _w * _h * 2);
-      return 1;
-    }
-  uint8_t *ptrY, *ptrU, *ptrV, *ptr;
-
-  ptr = in->data;
-  ptrY = out->data;
-  ptrU = out->data + _w * _h;
-  ptrV = ptrU + ((_w * _h) >> 2);
-
-  for (uint32_t y = 0; y < _h; y++)
-    for (uint32_t x = 0; x < (_w >> 2); x++)
-      {
-	if (!(y & 1))
-	  {
-	    *ptrU++ = (*(ptr) + *(ptr + _w)) >> 1;
-	    ptr++;
-	    *ptrY++ = *ptr++;
-	    *ptrV++ = (*(ptr) + *(ptr + _w)) >> 1;
-	    ptr++;
-	    *ptrY++ = *ptr++;
-	  }
-	else
-	  {
-	    *ptrY++ = *(++ptr);
-	    *ptrY++ = *(ptr + 2);
-	    ptr++;
-	  }
-      }
-
-  
-  out->flags = AVI_KEY_FRAME;
-  return 1;
-
-}
-uint8_t
-  decoderYUY2::uncompress  (ADMCompressedImage * in, ADMImage * out)
-{
-
-  if (in->dataLength < _w * _h * 2)
-    {
-      printf ("in:%d expected%d\n", in->dataLength, _w * _h * 2);
-      return 1;
-    }
-  uint8_t *ptrY, *ptrU, *ptrV, *ptr;
-
-  ptr = in->data;
-  ptrY = out->data;
-  ptrV = out->data + _w * _h;
-  ptrU = out->data + ((_w * _h * 5) >> 2);
-
-
-  for (uint32_t y = 0; y < _h; y++)
-    for (uint32_t x = 0; x < (_w >> 1); x++)
-      {
-	if (!(y & 1))
-	  {
-	    *ptrY++ = *ptr++;
-	    *ptrU++ = (*(ptr) + *(ptr + _w * 2)) >> 1;
-	    ptr++;
-	    *ptrY++ = *ptr++;
-	    *ptrV++ = (*(ptr) + *(ptr + _w * 2)) >> 1;
-	    ptr++;
-
-	  }
-	else
-	  {
-	    *ptrY++ = *(ptr);
-	    *ptrY++ = *(ptr + 2);
-	    ptr += 4;
-	  }
-      }
-
-
-  out->flags = AVI_KEY_FRAME;
-  return 1;
-
-}

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_uyvy.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_uyvy.h	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_uyvy.h	2010-01-10 18:08:39 UTC (rev 5834)
@@ -1,37 +0,0 @@
-//
-// C++ Interface: ADM_uyvy
-//
-// Description: 
-//
-//
-// Author: mean <fixounet at free.fr>, (C) 2004
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-class decoderUYVY:decoders
-{
-protected:
-
-public:
-  decoderUYVY (uint32_t w, uint32_t h):decoders (w, h)
-  {
-  };
-  virtual ~ decoderUYVY ()
-  {
-  };
-  virtual uint8_t uncompress (ADMCompressedImage * in, ADMImage * out);
-};
-class decoderYUY2:decoders
-{
-protected:
-
-public:
-  decoderYUY2 (uint32_t w, uint32_t h):decoders (w, h)
-  {
-  };
-  virtual ~ decoderYUY2 ()
-  {
-  };
-  virtual uint8_t uncompress (ADMCompressedImage * in, ADMImage * out);
-};

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/CMakeLists.txt	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/CMakeLists.txt	2010-01-10 18:08:39 UTC (rev 5834)
@@ -1,18 +0,0 @@
-SET(ADM_codecs_SRCS 
-ADM_codecs.cpp
-ADM_png.cpp
-ADM_theora_dec.cpp
-ADM_ffmp43.cpp
-ADM_mjpeg.cpp
-ADM_rgb16.cpp
-ADM_uyvy.cpp
-ADM_ffmpeg_vdpau.cpp
-)
-
-ADD_LIBRARY(ADM_codecs6 STATIC ${ADM_codecs_SRCS})
-
-IF (USE_PNG)
-	 ADD_SOURCE_CFLAGS(ADM_png.cpp ${PNG_CFLAGS})
-ENDIF (USE_PNG)
-
-REMOVE_DEFINITIONS(-DHAVE_CONFIG_H)

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/CMakeLists.txt	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/CMakeLists.txt	2010-01-10 18:08:39 UTC (rev 5834)
@@ -1,7 +1,7 @@
 ADD_SUBDIRECTORY(ADM_audiocodec)
 ADD_SUBDIRECTORY(ADM_audioFilter)
 #ADD_SUBDIRECTORY(ADM_audioFilter_old)
-ADD_SUBDIRECTORY(ADM_codecs)
+#ADD_SUBDIRECTORY(ADM_codecs)
 ADD_SUBDIRECTORY(ADM_commonUI)
 ADD_SUBDIRECTORY(ADM_editor)
 #ADD_SUBDIRECTORY(ADM_filter)

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/CMakeLists.txt	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/CMakeLists.txt	2010-01-10 18:08:39 UTC (rev 5834)
@@ -0,0 +1 @@
+ADD_SUBDIRECTORY(src)

Copied: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_codec.h (from rev 5833, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_codec.h)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_codec.h	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_codec.h	2010-01-10 18:08:39 UTC (rev 5834)
@@ -0,0 +1,160 @@
+/***************************************************************************
+                          ADM_codec.h  -  description
+                             -------------------
+    begin                : Fri Apr 12 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef __CODECS__
+#define __CODECS__
+
+#include "ADM_image.h"
+#include "ADM_frameType.h"
+#include "ADM_codecType.h"
+
+#define ADM_QPEL_ON	1
+#define ADM_GMC_ON	2
+#define ADM_VOP_ON	4
+
+/*
+        Bitrate in configuration will always be in **kBITS**
+
+*/
+
+#include "ADM_bitstream.h"
+#include "ADM_compressedImage.h"
+/**
+    \class decoders
+    \brief base class for video decoders
+*/
+class decoders
+{
+protected:
+  uint32_t _w;
+  uint32_t _h;
+  uint8_t _lastQ;
+public:
+    decoders (uint32_t w, uint32_t h)
+  {
+    _w = w;
+    _h = h;
+    _lastQ = 0;
+  }
+  virtual ~ decoders ()
+  {
+  };
+  virtual uint8_t getPARWidth (void)
+  {
+    return 1;
+  };
+  virtual uint8_t getPARHeight (void)
+  {
+    return 1;
+  };
+  virtual void setParam (void)
+  {
+  };
+  virtual uint8_t uncompress (ADMCompressedImage * in, ADMImage * out)=0;
+
+  // does this codec *possibly* can have b-frame ?
+  virtual uint8_t dontcopy (void)
+  {
+    return 0;
+  }				// if 1 means the decoder will return reference
+  // no need to copy the datas to ADMimage
+  virtual uint8_t bFramePossible (void)
+  {
+    return 0;
+  }
+  virtual uint8_t decodeHeaderOnly (void)
+  {
+    return 0;
+  };
+  virtual uint8_t decodeFull (void)
+  {
+    return 0;
+  }
+  virtual uint8_t isDivxPacked (void)
+  {
+    return 0;
+  };
+  virtual uint32_t getSpecificMpeg4Info (void)
+  {
+    return 0;
+  };
+  virtual uint8_t isIndexable (void)
+  {
+    return 1;
+  };
+  virtual bool flush(void)
+    {
+        return true;
+    }
+};
+/* Dummy decoder in case we don't have the desired one */
+class decoderEmpty : public decoders
+{
+protected:
+public:
+    decoderEmpty (uint32_t w, uint32_t h) : decoders(w,h) {};
+    uint8_t uncompress (ADMCompressedImage * in, ADMImage * out) {return 1;}
+
+};
+
+decoders *getDecoder (uint32_t fcc, uint32_t w, uint32_t h, uint32_t extraLen,
+		      uint8_t * extraData,uint32_t bpp=0);
+decoders *getDecoderVopPacked (uint32_t fcc, uint32_t w, uint32_t h,
+			       uint32_t extraLen, uint8_t * extraData);
+decoders *getDecoderH264noLogic (uint32_t fcc, uint32_t w, uint32_t h, uint32_t extraLen,
+		     uint8_t * extraData);
+
+class coders
+{
+protected:
+  uint32_t _w;
+  uint32_t _h;
+public:
+    coders (uint32_t w, uint32_t h)
+  {
+    _w = w;
+    _h = h;
+  }
+  virtual ~ coders ()
+  {
+  };
+  virtual uint8_t compress (ADMImage * in, ADMBitstream * out);
+};
+decoders *getCoder (uint32_t fcc, uint32_t w, uint32_t h);
+/*----------------------------------------------------------*/
+class encoder
+{
+protected:uint32_t _w, _h;
+public:encoder (uint32_t width, uint32_t height)
+  {
+    _w = width;
+    _h = height;
+  };
+  virtual uint8_t stopEncoder (void) = 0;
+  virtual uint8_t init (uint32_t val, uint32_t fps1000) = 0;
+  virtual uint8_t encode (ADMImage * in, ADMBitstream *out) = 0;
+  virtual uint8_t getExtraData (uint32_t * l, uint8_t ** d)
+  {
+    *l = 0;
+    *d = NULL;
+    return 0;
+  }
+};
+
+
+
+
+#endif

Copied: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_codecNull.h (from rev 5833, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_codecNull.h)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_codecNull.h	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_codecNull.h	2010-01-10 18:08:39 UTC (rev 5834)
@@ -0,0 +1,33 @@
+/***************************************************************************
+                          ADM_codecNull.h  -  description
+                             -------------------
+    begin                : Fri Apr 19 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+class decoderNull:public decoders
+{
+protected:
+
+public:
+  decoderNull (uint32_t w, uint32_t h):decoders (w, h)
+  {
+  }
+  virtual ~ decoderNull ()
+  {
+  };
+  virtual uint8_t uncompress (ADMCompressedImage * in, ADMImage * out)
+  {
+    memcpy (out->data, in->data, in->dataLength);
+    return 1;
+  }
+};

Copied: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_ffmp43.h (from rev 5833, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_ffmp43.h)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_ffmp43.h	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_ffmp43.h	2010-01-10 18:08:39 UTC (rev 5834)
@@ -0,0 +1,397 @@
+/***************************************************************************
+                          ADM_ffmp43.h  -  description
+                             -------------------
+                             
+	Mpeg4 ****decoder******** using ffmpeg
+	                              
+    begin                : Wed Sep 25 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "ADM_lavcodec.h"
+class decoderFFSubs
+{
+  protected:
+     int      codecId;
+     uint32_t subId;
+     AVCodecContext *_context;
+  public:
+
+    decoderFFSubs (uint32_t subId);
+    virtual ~ decoderFFSubs ();
+    virtual uint8_t uncompress (ADMCompressedImage * in, AVSubtitle * out); 
+};
+
+/****************************/
+class decoderFF:public decoders
+{
+protected:
+
+  int codecId;
+  uint8_t _refCopy;
+  AVCodecContext *_context;
+  AVFrame _frame;
+  uint8_t *_internalBuffer;
+  uint8_t _allowNull;
+  uint32_t _swapUV;
+  uint32_t frameType (void);
+  uint8_t clonePic (AVFrame * src, ADMImage * out);
+  void decoderMultiThread ();
+  uint32_t _showMv;
+  uint32_t _gmc;
+  uint32_t _usingMT;
+public:
+
+    decoderFF (uint32_t w, uint32_t h);
+    virtual ~ decoderFF ();
+  virtual uint8_t dontcopy (void)
+  {
+    return 1;
+  }
+  virtual uint8_t uncompress (ADMCompressedImage * in, ADMImage * out);
+  virtual void setParam (void);
+  virtual uint8_t bFramePossible (void)
+  {
+    return 0;
+  }
+  virtual uint8_t decodeHeaderOnly (void);
+  virtual uint8_t decodeFull (void);
+  virtual uint8_t isDivxPacked (void);
+  virtual uint32_t getSpecificMpeg4Info (void);
+  virtual uint8_t getPARWidth (void);
+  virtual uint8_t getPARHeight (void);
+  virtual bool    flush(void);
+};
+
+class decoderFFDiv3:public decoderFF
+{
+protected:
+
+
+public:
+
+  decoderFFDiv3 (uint32_t w, uint32_t h);
+
+};
+class decoderFFMpeg4VopPacked:public decoderFF
+{
+protected:
+
+
+public:
+  decoderFFMpeg4VopPacked (uint32_t w, uint32_t h);
+  uint8_t uncompress (ADMCompressedImage * in, ADMImage * out);
+  // mpeg4 can have B-frame
+  virtual uint8_t bFramePossible (void)
+  {
+    return 0;
+  }
+  // Vop packed are not indexable
+  virtual uint8_t isIndexable (void)
+  {
+    return 0;
+  };
+};
+class decoderFFMpeg4:public decoderFF
+{
+protected:
+
+
+public:
+  decoderFFMpeg4 (uint32_t w, uint32_t h, uint32_t fcc,uint32_t l, uint8_t * d);
+  uint8_t uncompress (ADMCompressedImage * in, ADMImage * out);
+  // mpeg4 can have B-frame
+  virtual uint8_t bFramePossible (void)
+  {
+    return 1;
+  }
+
+};
+class decoderFFMpeg12:public decoderFF
+{
+protected:
+
+
+public:
+  decoderFFMpeg12 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+  // mpeg1/2 can have B-frame
+  virtual uint8_t bFramePossible (void)
+  {
+    return 1;
+  }
+
+};
+class decoderFFSVQ3:public decoderFF
+{
+protected:
+
+
+public:
+  decoderFFSVQ3 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+  virtual uint8_t bFramePossible (void)
+  {
+    return 0;
+  }
+
+};
+
+class decoderFFDV:public decoderFF
+{
+protected:
+
+
+public:
+  decoderFFDV (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+
+};
+class decoderFFMP42:public decoderFF
+{
+protected:
+
+
+public:
+  decoderFFMP42 (uint32_t w, uint32_t h);
+
+};
+class decoderFFH263:public decoderFF
+{
+protected:
+
+
+public:
+  decoderFFH263 (uint32_t w, uint32_t h);
+
+};
+class decoderFFH264:public decoderFF
+{
+protected:
+  uint32_t _lowDelay;
+
+public:
+  decoderFFH264 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d,uint32_t lowdelay);
+  virtual uint8_t bFramePossible (void)
+  {
+      return _lowDelay;
+  }
+  uint8_t   uncompress (ADMCompressedImage * in, ADMImage * out);
+
+};
+class decoderFFhuff:public decoderFF
+{
+protected:
+
+
+public:
+  decoderFFhuff (uint32_t w, uint32_t h, uint32_t l, uint8_t * d,uint32_t bpp);
+
+};
+class decoderFF_ffhuff:public decoderFF
+{
+protected:
+
+
+public:
+  decoderFF_ffhuff (uint32_t w, uint32_t h, uint32_t l, uint8_t * d,uint32_t bpp);
+
+};
+class decoderFFWMV2:public decoderFF
+{
+protected:
+
+
+public:
+  decoderFFWMV2 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+
+};
+class decoderFFWMV1:public decoderFF
+{
+  protected:
+
+
+  public:
+    decoderFFWMV1 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+
+};
+
+class decoderFFWMV3:public decoderFF
+{
+protected:
+
+
+public:
+  decoderFFWMV3 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+
+};
+
+class decoderFFVC1:public decoderFF
+{
+protected:
+
+
+public:
+  decoderFFVC1 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+
+};
+
+class decoderFFV1:public decoderFF
+{
+protected:
+
+
+public:
+  decoderFFV1 (uint32_t w, uint32_t h);
+
+};
+class decoderFFMJPEG:public decoderFF
+{
+protected:
+
+
+public:
+  decoderFFMJPEG (uint32_t w, uint32_t h);
+
+};
+class decoderSnow:public decoderFF
+{
+protected:
+
+
+public:
+  decoderSnow (uint32_t w, uint32_t h);
+
+};
+class decoderFFcyuv:public decoderFF
+{
+protected:
+
+
+public:
+  decoderFFcyuv (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+
+};
+class decoderCamtasia:public decoderFF
+{
+protected:
+
+
+public:
+  decoderCamtasia (uint32_t w, uint32_t h,uint32_t bpp);
+
+};
+class decoderFFTheora:public decoderFF
+{
+protected:
+
+
+public:
+  decoderFFTheora (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+
+};
+
+class decoderFFCinepak:public decoderFF
+{
+protected:
+
+
+public:
+  decoderFFCinepak (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+
+};
+class decoderFFCRAM:public decoderFF
+{
+protected:
+
+
+public:
+  decoderFFCRAM (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+
+};
+class decoderFFVP6F:public decoderFF
+{
+protected:
+public:
+  decoderFFVP6F (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+};
+class decoderFFVP6A:public decoderFF
+{
+protected:
+public:
+  decoderFFVP6A (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+};
+class decoderFFFLV1:public decoderFF
+{
+protected:
+public:
+  decoderFFFLV1 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+};
+class decoderFFDVBSub:public decoderFF
+{
+protected:
+public:
+  decoderFFDVBSub (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+};
+class decoderFFAMV:public decoderFF
+{
+protected:
+public:
+  decoderFFAMV (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+};
+class decoderFFMjpegB:public decoderFF
+{
+protected:
+public:
+  decoderFFMjpegB (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+};
+class decoderFFSVQ1:public decoderFF
+{
+protected:
+public:
+  decoderFFSVQ1 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+};
+
+#ifdef USE_VDPAU
+class decoderFFVDPAU:public decoderFF
+{
+protected:
+                    int b_age;
+                    int ip_age[2];
+
+                    void     *vdpau;
+                    ADMImage *scratch;
+                    ADMImage *vdpau_copy;
+                    uint64_t vdpau_pts;
+                    bool     decode_status;
+                    bool     destroying;
+public:     // Callbacks
+                    int     getBuffer(AVCodecContext *avctx, AVFrame *pic);
+                    void    releaseBuffer(struct AVCodecContext *avctx, AVFrame *pic);
+                    void    goOn( const AVFrame *d,int type);            
+public:
+            // public API
+                    decoderFFVDPAU (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+                    ~decoderFFVDPAU();
+    virtual uint8_t uncompress (ADMCompressedImage * in, ADMImage * out);
+    virtual uint8_t dontcopy (void)
+                      {
+                        return 0;
+                      }
+     virtual uint8_t bFramePossible (void)
+      {
+        return 1;
+      }
+
+};
+
+#endif
+// EOF
+

Copied: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_ffmpeg_vdpau_internal.h (from rev 5833, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_ffmpeg_vdpau_internal.h)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_ffmpeg_vdpau_internal.h	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_ffmpeg_vdpau_internal.h	2010-01-10 18:08:39 UTC (rev 5834)
@@ -0,0 +1,82 @@
+/***************************************************************************
+            \file              ADM_ffmpeg_vdpau.cpp  
+            \brief Decoder using half ffmpeg/half VDPAU
+
+    The ffmpeg part is to preformat inputs for VDPAU
+    VDPAU is loaded dynamically to be able to make a binary
+        and have something working even if the target machine
+        does not have vdpau
+
+
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef ADM_ffmpeg_vdpa_internal_H
+#define ADM_ffmpeg_vdpa_internal_H
+#include <vector>
+extern "C" {
+static void draw(struct AVCodecContext *s,    const AVFrame *src, int offset[4],    int y, int type, int height);
+static int ADM_VDPAUgetBuffer(AVCodecContext *avctx, AVFrame *pic);
+static void ADM_VDPAUreleaseBuffer(struct AVCodecContext *avctx, AVFrame *pic);
+}
+
+
+#define NB_SURFACE 50
+typedef struct 
+{
+        VdpDecoder            vdpDecoder;
+        vdpau_render_state *renders[NB_SURFACE];
+        std::vector <vdpau_render_state *>freeQueue;
+
+}vdpauContext;
+
+#define VDPAU ((vdpauContext *)vdpau)
+
+// VDPAU internal linker
+
+typedef struct 
+{
+    VdpGetErrorString       *getErrorString;
+    VdpGetApiVersion        *getApiVersion;
+    VdpGetInformationString *getInformationString;
+
+    VdpVideoSurfaceCreate   *createSurface;
+    VdpVideoSurfaceDestroy  *destroySurface;
+    VdpVideoSurfaceGetBitsYCbCr *getDataSurface;
+
+    VdpDecoderCreate        *decoderCreate;
+    VdpDecoderDestroy       *decoderDestroy;
+    VdpDecoderRender        *decoderRender;
+
+}VdpFunctions;
+
+#define WRAP_Open_Template(funcz,argz,display,codecid) \
+{\
+AVCodec *codec=funcz(argz);\
+if(!codec) {GUI_Error_HIG("Codec",QT_TR_NOOP("Internal error finding codec"display));ADM_assert(0);} \
+  codecId=codecid; \
+  _context->workaround_bugs=1*FF_BUG_AUTODETECT +0*FF_BUG_NO_PADDING; \
+  _context->error_concealment=3; \
+  if (avcodec_open(_context, codec) < 0)  \
+                      { \
+                                        printf("[lavc] Decoder init: "display" video decoder failed!\n"); \
+                                        GUI_Error_HIG("Codec","Internal error opening "display); \
+                                        ADM_assert(0); \
+                                } \
+                                else \
+                                { \
+                                        printf("[lavc] Decoder init: "display" video decoder initialized! (%s)\n",codec->long_name); \
+                                } \
+}
+
+#define WRAP_Open(x)            {WRAP_Open_Template(avcodec_find_decoder,x,#x,x);}
+#define WRAP_OpenByName(x,y)    {WRAP_Open_Template(avcodec_find_decoder_by_name,#x,#x,y);}
+
+#endif
\ No newline at end of file

Copied: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_mjpeg.h (from rev 5833, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_mjpeg.h)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_mjpeg.h	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_mjpeg.h	2010-01-10 18:08:39 UTC (rev 5834)
@@ -0,0 +1,29 @@
+/***************************************************************************
+                          ADM_mjpeg.h  -  description
+                             -------------------
+    begin                : Sat Apr 13 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+class decoderMjpeg:decoders
+{
+protected:
+  uint8_t _swap;
+
+public:
+  decoderMjpeg (uint32_t w, uint32_t h);
+  virtual ~ decoderMjpeg ();
+  virtual void setParam (void);
+  virtual uint8_t uncompress (uint8_t * in, uint8_t * out, uint32_t len,
+			      uint32_t * flag = NULL);
+};

Copied: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_png.h (from rev 5833, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_png.h)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_png.h	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_png.h	2010-01-10 18:08:39 UTC (rev 5834)
@@ -0,0 +1,78 @@
+/***************************************************************************
+                          ADM_png  -  description
+                             -------------------
+    copyright            : (C) 2005 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+ 
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/ 
+#ifndef PNG_H_A
+#define PNG_H_A
+#ifdef USE_PNG
+
+typedef struct memAccess 
+{
+  
+int size;
+   
+int cur;
+   
+uint8_t * data;
+
+
+} memAccess;
+
+
+class decoderPng:public decoders 
+{
+
+protected:
+memAccess io;
+  
+ADM_colorspace colorspace;
+  
+void *png_ptr;
+  
+void *info_ptr;
+  
+void *end_info;
+  
+
+uint8_t ** rows;
+  
+uint8_t * decoded;
+  
+void Init (void);
+  
+void Cleanup (void);
+  
+void recalc (void);
+
+public:
+decoderPng (uint32_t w, uint32_t h);
+  
+virtual ~ decoderPng ();
+  
+virtual uint8_t uncompress(ADMCompressedImage * in, ADMImage * out);
+  
+uint8_t dontcopy (void)
+  {
+    return 1;
+  }
+
+
+
+};
+
+#endif /* 
+ */
+#endif /* 
+ */

Copied: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_rgb16.h (from rev 5833, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_rgb16.h)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_rgb16.h	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_rgb16.h	2010-01-10 18:08:39 UTC (rev 5834)
@@ -0,0 +1,38 @@
+/***************************************************************************
+                          ADM_rgb16.h  -  description
+                             -------------------
+    begin                : Mon May 27 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef ADM_RGB16_H
+#define ADM_RGB16_H
+
+#include "ADM_colorspace.h"
+
+class decoderRGB16 : decoders
+{
+	protected:
+		uint8_t* planar;
+		ColRgbToYV12* color;
+		uint32_t isRgb; // Else BGR
+		uint32_t _bpp;
+		uint8_t* decoded;
+
+	public:
+		uint8_t dontcopy (void) { return 1; }
+		decoderRGB16 (uint32_t w, uint32_t h, uint32_t rgb, uint32_t bpp);
+		virtual ~decoderRGB16();
+		virtual uint8_t uncompress(ADMCompressedImage * in, ADMImage * out);
+};
+
+#endif

Copied: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_theora_dec.h (from rev 5833, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_theora_dec.h)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_theora_dec.h	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_theora_dec.h	2010-01-10 18:08:39 UTC (rev 5834)
@@ -0,0 +1,46 @@
+/***************************************************************************
+                          ADM_theora_dec.h  -  description
+                             -------------------
+    begin                : Thu Sep 26 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifdef USE_THEORA
+#ifndef __theora__
+#define __theora__
+
+extern "C"
+{
+#include "theora/theora.h"
+}
+class decoderTheora:public decoders
+{
+protected:
+
+
+  theora_info _tinfo;
+  theora_state _tstate;
+
+
+
+public:
+    decoderTheora (uint32_t w, uint32_t h);
+    virtual ~ decoderTheora ();
+  virtual uint8_t uncompress (uint8_t * in, uint8_t * out, uint32_t len,
+			      uint32_t * flag = NULL);
+  virtual void setParam (void);
+
+
+};
+
+#endif
+#endif

Copied: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_theora_enc.h (from rev 5833, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_theora_enc.h)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_theora_enc.h	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_theora_enc.h	2010-01-10 18:08:39 UTC (rev 5834)
@@ -0,0 +1,16 @@
+/***************************************************************************
+                          ADM_theora_enc.h  -  description
+                             -------------------
+    begin                : Thu Sep 26 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/

Copied: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_uyvy.h (from rev 5833, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_uyvy.h)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_uyvy.h	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_uyvy.h	2010-01-10 18:08:39 UTC (rev 5834)
@@ -0,0 +1,37 @@
+//
+// C++ Interface: ADM_uyvy
+//
+// Description: 
+//
+//
+// Author: mean <fixounet at free.fr>, (C) 2004
+//
+// Copyright: See COPYING file that comes with this distribution
+//
+//
+class decoderUYVY:decoders
+{
+protected:
+
+public:
+  decoderUYVY (uint32_t w, uint32_t h):decoders (w, h)
+  {
+  };
+  virtual ~ decoderUYVY ()
+  {
+  };
+  virtual uint8_t uncompress (ADMCompressedImage * in, ADMImage * out);
+};
+class decoderYUY2:decoders
+{
+protected:
+
+public:
+  decoderYUY2 (uint32_t w, uint32_t h):decoders (w, h)
+  {
+  };
+  virtual ~ decoderYUY2 ()
+  {
+  };
+  virtual uint8_t uncompress (ADMCompressedImage * in, ADMImage * out);
+};

Copied: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_codecs.cpp (from rev 5833, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_codecs.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_codecs.cpp	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_codecs.cpp	2010-01-10 18:08:39 UTC (rev 5834)
@@ -0,0 +1,316 @@
+/***************************************************************************
+                          ADM_codecs.cpp  -  description
+                             -------------------
+    begin                : Fri Apr 12 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+
+    see here : http://www.webartz.com/fourcc/
+
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "config.h"
+
+
+#ifdef USE_FFMPEG
+extern "C"
+{
+#include "ADM_lavcodec.h"
+};
+#endif
+#include "ADM_default.h"
+#ifdef BIG_ENDIAN
+#undef BIG_ENDIAN
+#endif
+
+//#include "ADM_colorspace/colorspace.h"
+
+#ifdef USE_XX_XVID
+#include "xvid.h"
+#endif
+
+#include "ADM_codecs/ADM_codec.h"
+#include "ADM_codecs/ADM_mjpeg.h"
+#include "ADM_codecs/ADM_codecNull.h"
+#include "ADM_codecs/ADM_rgb16.h"
+#include "ADM_codecs/ADM_uyvy.h"
+#include "avidemutils.h"
+#include "fourcc.h"
+
+
+#include "ADM_codecs/ADM_ffmp43.h"
+
+
+#ifdef USE_THEORA
+#include "ADM_codecs/ADM_theora_dec.h"
+#endif
+
+#include "ADM_codecs/ADM_png.h"
+
+#include "ADM_assert.h"
+#include "prefs.h"
+
+extern uint8_t GUI_Question (char *);
+extern uint8_t use_fast_ffmpeg;
+extern bool vdpauUsable(void);
+
+uint8_t
+  decoders::uncompress (ADMCompressedImage * in, ADMImage * out)
+{
+  UNUSED_ARG (in);
+  UNUSED_ARG (out);
+  return 0;
+}
+decoders *
+getDecoderVopPacked (uint32_t fcc, uint32_t w, uint32_t h, uint32_t extraLen,
+		     uint8_t * extraData)
+{
+  UNUSED_ARG (fcc);
+  UNUSED_ARG (extraLen);
+  UNUSED_ARG (extraData);
+  return (decoders *) (new decoderFFMpeg4VopPacked (w, h));
+
+}
+decoders *getDecoderH264noLogic (uint32_t fcc, uint32_t w, uint32_t h, uint32_t extraLen,
+		     uint8_t * extraData)
+{
+  UNUSED_ARG (fcc);
+  UNUSED_ARG (extraLen);
+  UNUSED_ARG (extraData);
+  return (decoders *) (new decoderFFH264 (w, h, extraLen, extraData,0));
+
+}
+/**
+    \fn getDecoder
+    \brief returns the correct decoder for a stream
+*/
+decoders *getDecoder (uint32_t fcc, uint32_t w, uint32_t h, uint32_t extraLen,
+	    uint8_t * extraData,uint32_t bpp)
+{
+  printf("\nSearching decoder (%d x %d, extradataSize:%d)...\n",w,h,extraLen);
+  if (isMSMpeg4Compatible (fcc) == 1)
+    {
+      // For div3, no problem we take ffmpeg
+
+      return (decoders *) (new decoderFFDiv3 (w, h));
+    }
+
+#ifdef USE_FFMPEG
+  if (isDVCompatible(fcc))//"CDVC"))
+    {
+
+      return (decoders *) (new decoderFFDV (w, h, extraLen, extraData));
+    }
+#endif
+#ifdef USE_FFMPEG
+  if (fourCC::check (fcc, (uint8_t *) "MP42"))
+    {
+
+      return (decoders *) (new decoderFFMP42 (w, h));
+    }
+#endif
+    if (fourCC::check (fcc, (uint8_t *) "FLV1"))
+    {
+      return (decoders *) (new decoderFFFLV1 (w, h,extraLen, extraData));
+    }
+
+
+#ifdef USE_FFMPEG
+  if (fourCC::check (fcc, (uint8_t *) "H263"))
+    {
+
+      return (decoders *) (new decoderFFH263 (w, h));
+    }
+  if (fourCC::check (fcc, (uint8_t *) "HFYU"))
+    {
+
+      return (decoders *) (new decoderFFhuff (w, h, extraLen, extraData,bpp));
+    }
+#ifdef USE_PNG
+  if (fourCC::check (fcc, (uint8_t *) "PNG "))
+    {
+
+      return (decoders *) (new decoderPng (w, h));
+    }
+#endif
+ if (fourCC::check (fcc, (uint8_t *) "cvid"))
+    {
+
+      return (decoders *) (new decoderFFCinepak (w, h, extraLen, extraData));
+    }
+  if (fourCC::check (fcc, (uint8_t *) "FFVH"))
+    {
+
+      return (decoders *) (new decoderFF_ffhuff (w, h, extraLen, extraData,bpp));
+    }
+if (fourCC::check (fcc, (uint8_t *) "SVQ1"))
+    {
+
+      return (decoders *) (new decoderFFSVQ1 (w, h, extraLen, extraData));
+    }
+
+  if (fourCC::check (fcc, (uint8_t *) "SVQ3"))
+    {
+
+      return (decoders *) (new decoderFFSVQ3 (w, h, extraLen, extraData));
+    }
+  if (fourCC::check (fcc, (uint8_t *) "tscc"))
+    {
+
+      return (decoders *) (new decoderCamtasia (w, h, bpp));
+    }
+
+     if (fourCC::check (fcc, (uint8_t *) "CRAM"))
+    {
+
+      return (decoders *) (new decoderFFCRAM (w, h, extraLen, extraData));
+    }
+  if (fourCC::check (fcc, (uint8_t *) "WMV2"))
+    {
+
+      return (decoders *) (new decoderFFWMV2 (w, h, extraLen, extraData));
+    }
+    if (fourCC::check (fcc, (uint8_t *) "WMV1"))
+    {
+
+      return (decoders *) (new decoderFFWMV1 (w, h, extraLen, extraData));
+    }
+
+  if (fourCC::check (fcc, (uint8_t *) "WMV3") )
+    {
+
+      return (decoders *) (new decoderFFWMV3 (w, h, extraLen, extraData));
+    }
+
+    if (fourCC::check (fcc, (uint8_t *) "WVC1")|| fourCC::check (fcc, (uint8_t *) "WMVA"))
+    {
+
+      return (decoders *) (new decoderFFVC1 (w, h, extraLen, extraData));
+    }
+
+if (fourCC::check (fcc, (uint8_t *) "FFV1"))
+    {
+
+      return (decoders *) (new decoderFFV1 (w, h));
+    }
+  if (fourCC::check (fcc, (uint8_t *) "SNOW"))
+    {
+
+      return (decoders *) (new decoderSnow (w, h));
+    }
+  if (isH264Compatible (fcc))
+    {
+#ifdef USE_VDPAU
+        if(vdpauUsable()==true)
+            return (decoders *) (new decoderFFVDPAU (w, h, extraLen, extraData));
+        else
+#endif
+            return (decoders *) (new decoderFFH264 (w, h, extraLen, extraData,1));
+    }
+#endif
+
+/*
+	Could be either divx5 packed crap or xvid or ffmpeg
+	For now we return FFmpeg and later will switch to divx5 if available
+		(ugly hack for ugly hack....)
+*/
+
+  if (isMpeg4Compatible (fcc) == 1)
+    {
+      return (decoders *) (new decoderFFMpeg4 (w, h, fcc,extraLen, extraData));
+      //    return(decoders *)( new decoderXvid(w,h));
+      //    return(decoders *)( new decoderDIVX(w,h));
+    }
+
+  if (fourCC::check (fcc, (uint8_t *) "MJPB"))
+    {
+      printf ("\n using FF mjpeg codec\n");
+      return (decoders *) (new decoderFFMjpegB (w, h,extraLen,extraData));
+    }
+if (fourCC::check (fcc, (uint8_t *) "MJPG")
+      || fourCC::check (fcc, (uint8_t *) "mjpa"))
+    {
+#if  0
+      //#ifdef USE_MJPEG
+      printf ("\n using mjpeg codec\n");
+      return (decoders *) (new decoderMjpeg (w, h));
+#else
+      printf ("\n using FF mjpeg codec\n");
+      return (decoders *) (new decoderFFMJPEG (w, h));
+#endif
+
+    }
+  if (fourCC::check (fcc, (uint8_t *) "YV12")
+      || fourCC::check (fcc, (uint8_t *) "yv12")
+      || fourCC::check (fcc, (uint8_t *) "I420"))
+    {
+      printf ("\n using null codec\n");
+      return (decoders *) (new decoderNull (w, h));
+    }
+  if (fourCC::check (fcc, (uint8_t *) "UYVY"))
+    {
+      printf ("\n using uyvy codec\n");
+      return (decoders *) (new decoderUYVY (w, h));
+    }
+  if (fourCC::check (fcc, (uint8_t *) "YUY2"))
+    {
+      printf ("\n using YUY2 codec\n");
+      return (decoders *) (new decoderYUY2 (w, h));
+    }
+  if (fourCC::check (fcc, (uint8_t *) "AMV "))
+    {
+      printf ("\n using AMV codec\n");
+      return (decoders *) (new decoderFFAMV (w, h,extraLen,extraData));
+    }
+
+ if (fourCC::check (fcc, (uint8_t *) "VP6A"))
+    {
+      printf ("\n using YUY2 codec\n");
+      return (decoders *) (new decoderFFVP6A (w, h,extraLen,extraData));
+    }
+  if (isVP6Compatible(fcc))
+    {
+      printf ("\n using VP6F codec\n");
+      return (decoders *) (new decoderFFVP6F (w, h,extraLen,extraData));
+    }
+
+
+  if ((fcc == 0) || fourCC::check (fcc, (uint8_t *) "RGB "))
+    {
+      // RGB 16 Codecs
+      printf ("\n using RGB codec\n");
+      return (decoders *) (new decoderRGB16 (w, h, 1, bpp));
+
+    }
+ if ((fcc == 0) || fourCC::check (fcc, (uint8_t *) "DIB "))
+    {
+      // RGB 16 Codecs
+      printf ("\n using DIB codec\n");
+      return (decoders *) (new decoderRGB16 (w, h, 0, bpp));
+
+    }
+  if (isMpeg12Compatible (fcc))
+	  return (decoders *) (new decoderFFMpeg12 (w, h, extraLen, extraData));
+
+  // default : null decoder
+  printf ("\n using invalid codec for \n");
+  fourCC::print (fcc);
+
+  return (decoders *) (new decoderEmpty (w, h));
+}
+
+uint8_t coders::compress (ADMImage * in, ADMBitstream * out)
+{
+  UNUSED_ARG (in);
+  UNUSED_ARG (out);
+
+  return 0;
+}

Copied: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_ffmp43.cpp (from rev 5833, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_ffmp43.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_ffmp43.cpp	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_ffmp43.cpp	2010-01-10 18:08:39 UTC (rev 5834)
@@ -0,0 +1,838 @@
+/***************************************************************************
+                          ADM_ffmp43.cpp  -  description
+                             -------------------
+                             
+	Decoder for Divx3/4/..., using ffmpeg
+                             
+    begin                : Wed Sep 25 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "config.h"
+
+
+#include "ADM_assert.h"
+#include "prefs.h"
+extern "C" {
+#include "ADM_lavcodec.h"
+}
+#include "ADM_default.h"
+
+#include "ADM_codecs/ADM_codec.h"
+#include "ADM_codecs/ADM_ffmp43.h"
+#include "DIA_coreToolkit.h"
+
+#include "ADM_debugID.h"
+#define MODULE_NAME  MODULE_CODEC
+#include "ADM_debug.h"
+#include "ADM_videoInfoExtractor.h"
+
+extern int ADM_cpu_num_processors(void);
+extern "C"
+{
+    static void ADM_releaseBuffer(struct AVCodecContext *avctx, AVFrame *pic);
+    static int  ADM_getBuffer(AVCodecContext *avctx, AVFrame *pic);
+}
+
+
+
+#define WRAP_Open_Template(funcz,argz,display,codecid) \
+{\
+AVCodec *codec=funcz(argz);\
+if(!codec) {GUI_Error_HIG("Codec",QT_TR_NOOP("Internal error finding codec"display));ADM_assert(0);} \
+  codecId=codecid; \
+  _context->workaround_bugs=1*FF_BUG_AUTODETECT +0*FF_BUG_NO_PADDING; \
+  _context->error_concealment=3; \
+  if (avcodec_open(_context, codec) < 0)  \
+                      { \
+                                        printf("[lavc] Decoder init: "display" video decoder failed!\n"); \
+                                        GUI_Error_HIG("Codec","Internal error opening "display); \
+                                        ADM_assert(0); \
+                                } \
+                                else \
+                                { \
+                                        printf("[lavc] Decoder init: "display" video decoder initialized! (%s)\n",codec->long_name); \
+                                } \
+}
+
+#define WRAP_Open(x)            {WRAP_Open_Template(avcodec_find_decoder,x,#x,x);}
+#define WRAP_OpenByName(x,y)    {WRAP_Open_Template(avcodec_find_decoder_by_name,#x,#x,y);}
+
+
+//****************************
+extern uint8_t DIA_lavDecoder (uint32_t * swapUv, uint32_t * showU);
+extern "C"
+{
+  int av_is_voppacked (AVCodecContext * avctx, int *vop_packed, int *gmc,
+		       int *qpel);
+};
+/**
+    \fn clonePic
+    \brief Convert AvFrame to ADMImage
+*/
+uint8_t decoderFF::clonePic (AVFrame * src, ADMImage * out)
+{
+  uint32_t    u,v;
+  ADM_assert(out->_isRef);
+  out->_planes[0] = (uint8_t *) src->data[0];
+  out->_planeStride[0] = src->linesize[0];
+  if (_swapUV)
+    {
+      u = 1;
+      v = 2;
+    }
+  else
+    {
+      u = 2;
+      v = 1;
+    }
+  out->_planes[1] = (uint8_t *) src->data[u];
+  out->_planeStride[1] = src->linesize[u];
+
+  out->_planes[2] = (uint8_t *) src->data[v];
+  out->_planeStride[2] = src->linesize[v];
+
+  _lastQ = 0;			//_context->quality;
+  out->_Qp = (src->quality * 32) / FF_LAMBDA_MAX;
+  out->flags = frameType ();
+
+  // Quant ?
+  if (src->qstride && src->qscale_table && codecId != CODEC_ID_H264)
+    {
+      out->quant = (uint8_t *) src->qscale_table;
+      out->_qStride = src->qstride;
+      out->_qSize = (_w + 15) >> 4;
+      out->_qSize *= (_h + 15) >> 4;	// FixME?
+    }
+  else
+    {
+      out->_qSize = out->_qStride = 0;
+      out->quant = NULL;
+    }
+    //printf("[LAVC] Old pts :%"LLD" new pts :%"LLD"\n",out->Pts, (uint64_t)(src->reordered_opaque));
+    //printf("[LAVC] pts: %"LLU"\n",src->pts);
+    out->Pts= (uint64_t)(src->reordered_opaque);
+    return 1;
+}
+/**
+        \fn decoderMultiThread
+        \brief Enabled multitheaded decoder if possible
+*/
+void decoderFF::decoderMultiThread (void)
+{
+  uint32_t threads = 0;
+
+  prefs->get(FEATURE_THREADING_LAVC, &threads);
+
+  if (threads == 0)
+	  threads = ADM_cpu_num_processors();
+
+  if (threads == 1)
+	  threads = 0;
+
+  if (threads)
+  {
+      printf ("[lavc] Enabling MT decoder with %u threads\n", threads);
+
+      if (avcodec_thread_init (_context, threads) == -1)
+	      printf ("[lavc] Failed!!\n");
+	  else
+          _usingMT = 1;
+  }
+}
+uint8_t decoderFF::getPARWidth (void)
+{
+  if(!_context->sample_aspect_ratio.num) return 1;
+  return _context->sample_aspect_ratio.num;
+}
+uint8_t decoderFF::getPARHeight (void)
+{
+  if(!_context->sample_aspect_ratio.den) return 1;
+  return _context->sample_aspect_ratio.den;
+
+}
+
+  
+uint8_t decoderFF::isDivxPacked (void)
+{
+  int
+    vop,
+    gmc,
+    qpel;
+  av_is_voppacked (_context, &vop, &gmc, &qpel);
+  return vop;
+}
+// Fill the bitfields for some mpeg4 specific info
+// It is a bit of a hack as we make it a general
+// stuff (i.e. shared with all codecs) whereas it is mpeg4 specific
+// and should stay within mpeg4 scope FIXME
+uint32_t decoderFF::getSpecificMpeg4Info (void)
+{
+  int
+    vop,
+    gmc,
+    qpel;
+  uint32_t
+    out = 0;
+  av_is_voppacked (_context, &vop, &gmc, &qpel);
+
+  if (qpel)
+    out += ADM_QPEL_ON;
+  if (_gmc)
+    out += ADM_GMC_ON;
+  if (vop)
+    out += ADM_VOP_ON;
+
+  return out;
+}
+
+//________________________________________________
+void
+decoderFF::setParam (void)
+{
+  DIA_lavDecoder (&_swapUV, &_showMv);
+  return;			// no param for ffmpeg
+}
+
+//-------------------------------
+decoderFF::decoderFF (uint32_t w, uint32_t h):decoders (w, h)
+{
+  codecId = 0;
+//                              memset(&_context,0,sizeof(_context));
+  _allowNull = 0;
+  _gmc = 0;
+  _context = NULL;
+  _refCopy = 0;
+  _usingMT = 0;
+#if LIBAVCODEC_BUILD >= 4624
+  _context = avcodec_alloc_context ();
+#else
+  _context = new AVCodecContext;
+  memset (_context, 0, sizeof (AVCodecContext));
+#endif
+  ADM_assert (_context);
+  memset (&_frame, 0, sizeof (_frame));
+
+  _context->max_b_frames = 0;
+
+  _context->width = _w;
+  _context->height = _h;
+  _context->pix_fmt = PIX_FMT_YUV420P;	//PIX_FMT_RGBA32
+  //_context->debug=1;
+
+  _internalBuffer = new uint8_t[w * h * 3];
+
+  _swapUV = 0;
+  //_context->strict_std_compliance=-1;
+
+  _showMv = 0;
+#define FF_SHOW		(FF_DEBUG_VIS_MV_P_FOR+	FF_DEBUG_VIS_MV_B_FOR+FF_DEBUG_VIS_MV_B_BACK)
+//#define FF_SHOW               (FF_DEBUG_VIS_MV_P_FOR)
+  printf ("[lavc] Build: %d\n", LIBAVCODEC_BUILD);
+  _context->debug_mv |= FF_SHOW;
+  _context->debug |= FF_DEBUG_VIS_MB_TYPE + FF_DEBUG_VIS_QP;
+  
+}
+
+//_____________________________________________________
+
+decoderFF::~decoderFF ()
+{
+  if (_usingMT)
+    {
+      printf ("[lavc] Killing decoding threads\n");
+      avcodec_thread_free (_context);
+      _usingMT = 0;
+    }
+
+  avcodec_close (_context);
+  ADM_dealloc (_context);
+  delete[]_internalBuffer;
+  printf ("[lavc] Destroyed\n");
+}
+
+/**
+    \fn frameType
+    \return frametype of the last decoded frame
+*/
+uint32_t decoderFF::frameType (void)
+{
+  uint32_t
+    flag = 0;
+
+  AVFrame *
+    target;
+#define SET(x) {flag=x;aprintf("Frame is %s\n",#x);}
+
+
+  target = &_frame;
+  switch (target->pict_type)
+    {
+    case FF_B_TYPE:
+      SET (AVI_B_FRAME);
+      if (target->key_frame)
+	aprintf ("\n But keyframe is set\n");
+      break;
+
+    case FF_I_TYPE:
+      SET (AVI_KEY_FRAME);
+      if (!target->key_frame)
+	{
+	  if (codecId == CODEC_ID_H264)
+	    {
+	      SET (AVI_P_FRAME);
+	    }
+	  else
+	    printf ("\n But keyframe is not set\n");
+	}
+      break;
+    case FF_S_TYPE:
+      _gmc = 1;			// No break, just inform that gmc is there
+    case FF_P_TYPE:
+      SET (AVI_P_FRAME);
+      if (target->key_frame)
+	aprintf ("\n But keyframe is set\n");
+      break;
+    default:
+//                              printf("\n OOops XXX frame ?\n");
+      break;
+    }
+  return flag;
+}
+uint8_t decoderFF::decodeHeaderOnly (void)
+{
+  if (codecId == CODEC_ID_H264)
+    _context->hurry_up = 4;
+  else
+    _context->hurry_up = 5;
+  printf ("\n[lavc] Hurry up\n");
+  return 1;
+}
+uint8_t decoderFF::decodeFull (void)
+{
+  _context->hurry_up = 0;
+  printf ("\n[lavc] full decoding\n");
+  return 1;
+}
+
+/**
+    \fn flush
+    \brief empty internal buffer
+*/
+bool    decoderFF::flush(void)
+{
+    if(_context)
+        avcodec_flush_buffers(_context);
+    return true;
+}
+/**
+    \fn uncompress
+    \brief Actually decode an image
+*/
+uint8_t   decoderFF::uncompress (ADMCompressedImage * in, ADMImage * out)
+{
+  int got_picture = 0;
+  uint8_t *oBuff[3];
+  int strideTab[3];
+  int strideTab2[3];
+  int ret = 0;
+  out->_noPicture = 0;
+  if (_showMv)
+    {
+      _context->debug_mv |= FF_SHOW;
+      _context->debug |= 0;	//FF_DEBUG_VIS_MB_TYPE;
+    }
+  else
+    {
+      _context->debug_mv &= ~FF_SHOW;
+      _context->debug &= ~(FF_DEBUG_VIS_MB_TYPE + FF_DEBUG_VIS_QP);
+    }
+
+   
+    
+  if (in->dataLength == 0 && !_allowNull)	// Null frame, silently skipped
+    {
+      
+      printf ("[Codec] null frame\n");
+        // search the last image
+        if (_context->coded_frame && 
+            _context->coded_frame->data &&
+            _context->coded_frame->data[0]
+            )
+          {
+            printf("[Codec] Cloning older pic\n");
+            clonePic (_context->coded_frame, out);
+            out->Pts=ADM_COMPRESSED_NO_PTS;
+          }
+        else
+            {
+                out->_noPicture = 1;
+                out->Pts=ADM_COMPRESSED_NO_PTS;
+                printf("[Codec] No Picture\n");
+            }
+          return 1;
+    }
+   // Put a safe value....
+   out->Pts=in->demuxerPts;
+    _context->reordered_opaque=in->demuxerPts;
+  //_frame.opaque=(void *)out->Pts;
+  //printf("Incoming Pts :%"LLD"\n",out->Pts);
+  ret = avcodec_decode_video (_context, &_frame, &got_picture, in->data, in->dataLength);
+  if(!bFramePossible())
+  {
+    // No delay, the value is sure, no need to hide it in opaque
+    _context->reordered_opaque=(int64_t)in->demuxerPts;
+  }
+  out->_qStride = 0;		//Default = no quant
+  if (0 > ret && !_context->hurry_up)
+    {
+      printf ("\n[lavc] error in lavcodec decoder!\n");
+      printf ("[lavc] Err: %d, size :%d\n", ret, in->dataLength);
+      return 0;
+    }
+  if (!got_picture && !_context->hurry_up)
+    {
+      // Some encoder code a vop header with the 
+      // vop flag set to 0
+      // it is meant to mean frame skipped but very dubious
+      if (in->dataLength <= 8 && codecId == CODEC_ID_MPEG4)
+	{
+	  printf ("[lavc] Probably pseudo black frame...\n");
+	  out->_Qp = 2;
+	  out->flags = 0;	// assume P ?
+
+	  clonePic (_context->coded_frame, out);
+	  return 1;
+	}
+      // allow null means we allow null frame in and so potentially
+      // have no frame out for a time
+      // in that case silently fill with black and returns it as KF
+      if (_allowNull)
+	{
+	  out->flags = AVI_KEY_FRAME;
+	  if (!_refCopy)
+	    {
+	      memset (out->data, 0, _w * _h);
+	      memset (out->data + _w * _h, 128, (_w * _h) >> 1);
+	    }
+	  else
+	    {
+	      out->_noPicture = 1;
+	    }
+	  printf ("\n[lavc] ignoring got pict ==0\n");
+	  return 1;
+
+	}
+      printf ("[lavc] Err: %d, size: %d\n", ret, in->dataLength);
+      printf ("\n[lavc] error in FFMP43/mpeg4!: got picture\n");
+      //GUI_Alert("Please retry with misc->Turbo off");
+      //return 1;
+      return 0;
+    }
+  if (_context->hurry_up)
+    {
+      out->flags = frameType ();
+      return 1;
+    }
+  // We have an image....
+  switch (_context->pix_fmt)
+    {
+    case PIX_FMT_YUV411P:
+      out->_colorspace = ADM_COLOR_YUV411;
+      break;
+
+    case PIX_FMT_YUV422P:
+    case PIX_FMT_YUVJ422P:
+      out->_colorspace = ADM_COLOR_YUV422;
+      break;
+
+    case PIX_FMT_YUV444P:
+    case PIX_FMT_YUVJ444P:
+      out->_colorspace = ADM_COLOR_YUV444;
+      break;
+    case PIX_FMT_YUV420P:
+    case PIX_FMT_YUVJ420P:
+    case PIX_FMT_YUVA420P:
+      // Default is YV12 or I420
+      // In that case depending on swap u/v
+      // we do it or not
+      out->_colorspace = ADM_COLOR_YV12;
+      break;
+
+    case PIX_FMT_RGBA: // ???PIX_FMT_RGBA32:
+      out->_colorspace = ADM_COLOR_RGB32A;
+      break;
+    case PIX_FMT_RGB555:
+      out->_colorspace = ADM_COLOR_RGB555;
+      break;
+    case PIX_FMT_VDPAU_H264:
+        out->_colorspace=ADM_COLOR_VDPAU;
+        break;
+    default:
+      printf ("[lavc] Unhandled colorspace: %d\n", _context->pix_fmt);
+      return 0;
+    }
+    clonePic (&_frame, out);
+    //printf("[AvCodec] Pts : %llu Out Pts:%llu \n",_frame.pts,out->Pts);
+
+  return 1;
+}
+
+#define LOWDELAY() {} //_context->flags |= CODEC_FLAG_LOW_DELAY
+
+
+decoderFFDiv3::decoderFFDiv3 (uint32_t w, uint32_t h):decoderFF (w, h)
+{
+  _refCopy = 1;			// YUV420 only
+  WRAP_Open (CODEC_ID_MSMPEG4V3);
+}
+//**************************************************
+decoderFFMpeg4VopPacked::decoderFFMpeg4VopPacked (uint32_t w, uint32_t h):decoderFF (w,
+	   h)
+{
+/* In that case, we cannot use lowdelay...*/
+  _refCopy = 1;			// YUV420 only
+  _allowNull = 1;
+  decoderMultiThread ();
+  WRAP_Open (CODEC_ID_MPEG4);
+  printf("[lavc] Non low delay mpeg4 decoder initialized\n");
+}
+uint8_t decoderFFMpeg4VopPacked::uncompress (ADMCompressedImage * in, ADMImage * out)
+{
+    // For pseudo startcode
+    if(in->dataLength)
+    {
+        in->data[in->dataLength]=0;
+        in->data[in->dataLength+1]=0;
+    }
+    return decoderFF::uncompress(in,out);
+
+}
+
+decoderFFMpeg4::decoderFFMpeg4 (uint32_t w, uint32_t h, uint32_t fcc,uint32_t l, uint8_t * d):decoderFF (w,
+	   h)
+{
+// force low delay as avidemux don't handle B-frames
+  LOWDELAY();
+  printf ("[lavc] Using %d bytes of extradata for MPEG4 decoder\n", l);
+  
+  _refCopy = 1;			// YUV420 only
+  _context->extradata = (uint8_t *) d;
+  _context->extradata_size = (int) l;
+  _context->codec_tag=fcc;
+  _context->stream_codec_tag=fcc;
+  decoderMultiThread ();
+  //  _context->flags|=FF_DEBUG_VIS_MV;
+  WRAP_Open (CODEC_ID_MPEG4);
+}
+uint8_t decoderFFMpeg4::uncompress (ADMCompressedImage * in, ADMImage * out)
+{
+    // For pseudo startcode
+    if(in->dataLength)
+    {
+        in->data[in->dataLength]=0;
+        in->data[in->dataLength+1]=0;
+    }
+    return decoderFF::uncompress(in,out);
+
+}
+//************************************
+decoderFFDV::decoderFFDV (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,
+	   h)
+{
+  _context->extradata = (uint8_t *) d;
+  _context->extradata_size = (int) l;
+  WRAP_Open (CODEC_ID_DVVIDEO);
+
+}
+decoderFFMP42::decoderFFMP42 (uint32_t w, uint32_t h):decoderFF (w, h)
+{
+  _refCopy = 1;			// YUV420 only
+  WRAP_Open (CODEC_ID_MSMPEG4V2);
+
+}
+decoderFFMpeg12::decoderFFMpeg12 (uint32_t w, uint32_t h, uint32_t extraLen, uint8_t * extraData):decoderFF (w,
+	   h)
+{
+  int
+    got_picture = 0;
+  LOWDELAY();
+  _refCopy = 1;			// YUV420 only
+  decoderMultiThread ();
+  WRAP_Open (CODEC_ID_MPEG2VIDEO);
+}
+decoderFFSVQ3::decoderFFSVQ3 (uint32_t w, uint32_t h, uint32_t extraLen, uint8_t * extraData):decoderFF (w,
+	   h)
+{
+  int
+    got_picture = 0;
+
+  LOWDELAY();
+  _context->extradata = (uint8_t *) extraData;
+  _context->extradata_size = (int) extraLen;
+  WRAP_Open (CODEC_ID_SVQ3);
+}
+
+decoderFFH263::decoderFFH263 (uint32_t w, uint32_t h):decoderFF (w, h)
+{
+  _refCopy = 1;			// YUV420 only
+  WRAP_Open (CODEC_ID_H263);
+
+}
+decoderFFV1::decoderFFV1 (uint32_t w, uint32_t h):decoderFF (w, h)
+{
+  _refCopy = 1;			// YUV420 only
+  WRAP_Open (CODEC_ID_FFV1);
+}
+decoderFF_ffhuff::decoderFF_ffhuff (uint32_t w, uint32_t h, uint32_t l, uint8_t * d,uint32_t bpp):decoderFF (w,
+	   h)
+{
+  _context->extradata = (uint8_t *) d;
+  _context->extradata_size = (int) l;
+  _context->bits_per_coded_sample=bpp;
+  printf ("[lavc] FFhuff: We have %d bytes of extra data\n", l);
+  WRAP_Open (CODEC_ID_FFVHUFF);
+
+}
+decoderFFH264::decoderFFH264 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d, uint32_t lowdelay):decoderFF (w,
+	   h)
+{
+  _lowDelay=lowdelay;
+  _refCopy = 1;			// YUV420 only
+  _context->extradata = (uint8_t *) d;
+  _context->extradata_size = (int) l;
+  decoderMultiThread ();
+  if(lowdelay)
+    LOWDELAY();
+  printf ("[lavc] Initializing H264 decoder with %d extradata\n", l);
+
+       {
+        WRAP_Open(CODEC_ID_H264);
+    }
+
+
+}
+//*********************
+extern "C" {int av_getAVCStreamInfo(AVCodecContext *avctx, uint32_t  *nalSize, uint32_t *isAvc);}
+
+uint8_t   decoderFFH264::uncompress (ADMCompressedImage * in, ADMImage * out)
+{
+  if(!_context->hurry_up) return decoderFF::uncompress (in, out);
+  
+  uint32_t nalSize, isAvc;
+  av_getAVCStreamInfo(_context,&nalSize,&isAvc);
+  if(isAvc)
+  {
+      return extractH264FrameType(nalSize, in->data,in->dataLength,&(out->flags));
+  }else
+  {
+    return extractH264FrameType_startCode(nalSize, in->data,in->dataLength,&(out->flags));
+  }
+}
+//*********************
+decoderFFhuff::decoderFFhuff (uint32_t w, uint32_t h, uint32_t l, uint8_t * d,uint32_t bpp):decoderFF (w,
+	   h)
+{
+  _context->extradata = (uint8_t *) d;
+  _context->extradata_size = (int) l;
+  _context->bits_per_coded_sample = bpp;
+  WRAP_Open (CODEC_ID_HUFFYUV);
+}
+decoderFFWMV2::decoderFFWMV2 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,
+	   h)
+{
+  _context->extradata = (uint8_t *) d;
+  _context->extradata_size = (int) l;
+
+  WRAP_Open (CODEC_ID_WMV2);
+
+}
+decoderFFWMV1::decoderFFWMV1 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,
+	   h)
+{
+  _context->extradata = (uint8_t *) d;
+  _context->extradata_size = (int) l;
+
+  WRAP_Open (CODEC_ID_WMV1);
+
+}
+
+decoderFFWMV3::decoderFFWMV3 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,
+	   h)
+{
+  _context->extradata = (uint8_t *) d;
+  _context->extradata_size = (int) l;
+
+  WRAP_Open (CODEC_ID_WMV3);
+
+}
+
+decoderFFVC1::decoderFFVC1(uint32_t w, uint32_t h, uint32_t l, uint8_t * d) : decoderFF(w, h)
+{
+  _context->extradata = (uint8_t *) d;
+  _context->extradata_size = (int) l;
+
+  WRAP_Open (CODEC_ID_VC1);
+}
+
+decoderFFcyuv::decoderFFcyuv (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,
+	   h)
+{
+  _context->extradata = (uint8_t *) d;
+  _context->extradata_size = (int) l;
+
+  WRAP_Open (CODEC_ID_CYUV);
+}
+decoderFFMJPEG::decoderFFMJPEG (uint32_t w, uint32_t h):decoderFF (w, h)
+{
+  WRAP_Open (CODEC_ID_MJPEG);
+}
+decoderFFTheora::decoderFFTheora (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,
+	   h)
+{
+  _context->extradata = (uint8_t *) d;
+  _context->extradata_size = (int) l;
+  WRAP_Open (CODEC_ID_THEORA);
+}
+decoderSnow::decoderSnow (uint32_t w, uint32_t h):decoderFF (w, h)
+{
+  WRAP_Open (CODEC_ID_SNOW);
+}
+//*************
+decoderCamtasia::decoderCamtasia (uint32_t w, uint32_t h,uint32_t bpp):decoderFF (w,  h)
+{
+  _context->bits_per_coded_sample = bpp;
+  WRAP_Open (CODEC_ID_TSCC);
+}
+//*************
+decoderFFCinepak::decoderFFCinepak (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,	   h)
+{
+  WRAP_Open (CODEC_ID_CINEPAK);
+}
+//*************
+decoderFFCRAM::decoderFFCRAM (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,	   h)
+{
+  WRAP_Open (CODEC_ID_MSVIDEO1);
+}
+//*************
+decoderFFVP6F::decoderFFVP6F (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,	   h)
+{
+  WRAP_Open (CODEC_ID_VP6F);
+}
+//*************
+decoderFFVP6A::decoderFFVP6A (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,	   h)
+{
+  WRAP_Open (CODEC_ID_VP6A);
+}
+
+//*************
+decoderFFSVQ1::decoderFFSVQ1 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,	   h)
+{
+  WRAP_Open (CODEC_ID_SVQ1);
+}
+
+//************
+decoderFFFLV1::decoderFFFLV1 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,	   h)
+{
+  WRAP_Open (CODEC_ID_FLV1);
+}
+decoderFFAMV::decoderFFAMV (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,   h)
+{
+  WRAP_Open (CODEC_ID_AMV);
+  //_context->codec_id=CODEC_ID_AMV;
+}
+decoderFFMjpegB::decoderFFMjpegB (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,   h)
+{
+  WRAP_Open (CODEC_ID_MJPEGB);
+  //_context->codec_id=CODEC_ID_AMV;
+}
+decoderFFDVBSub::decoderFFDVBSub (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,	   h)
+{
+  _context->sub_id=1;
+  WRAP_Open (CODEC_ID_DVB_SUBTITLE);
+}
+//*********************
+/**
+    \fn decoderFFSubs
+    \brief Constructor for DVB subtitles...
+*/
+
+decoderFFSubs::decoderFFSubs (uint32_t subid)
+{
+  _context = avcodec_alloc_context ();
+  codecId= CODEC_ID_DVB_SUBTITLE;
+  subId=subid;
+  _context->sub_id=subId;
+  WRAP_Open (CODEC_ID_DVB_SUBTITLE);
+}
+decoderFFSubs:: ~ decoderFFSubs ()
+{
+  avcodec_close (_context);
+  ADM_dealloc (_context);
+  _context=NULL;
+  
+}
+
+uint8_t decoderFFSubs::uncompress (ADMCompressedImage * in, AVSubtitle * out)
+{
+  int ret=0;
+  int got_picture=0;
+  ret=avcodec_decode_subtitle(_context, out,
+                            &got_picture,
+                            in->data, in->dataLength); 
+     if(ret<0) 
+     {
+        printf("[lavc] FFSUB Error %d\n",ret);
+        return 0; 
+     }
+     return 1;
+}
+
+
+//***************
+extern uint8_t  lavformat_init(void);
+extern void     avcodec_init(void );
+extern  void    avcodec_register_all(void );
+extern "C"
+{
+  void adm_lavLogCallback(void  *instance, int level, const char* fmt, va_list list);
+}
+/**
+    \fn ADM_lavInit
+    \brief Init both lavcodec and lavformat
+*/
+void ADM_lavInit(void)
+{
+    avcodec_init();
+    avcodec_register_all();
+//BAZOOKA    lavformat_init();
+    av_log_set_callback(adm_lavLogCallback);
+#ifdef ADM_DEBUG
+  //  av_log_set_level(AV_LOG_DEBUG);
+#endif
+
+}
+void adm_lavLogCallback(void  *instance, int level, const char* fmt, va_list list)
+{
+   // if(level>1) return;
+    char buf[256];
+  
+    vsnprintf(buf, sizeof(buf), fmt, list);
+    printf("[lavc] %s",buf);
+}
+
+void ADM_lavDestroy(void)
+{
+	//av_free_static();
+}
+
+// EOF

Copied: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_ffmpeg_vdpau.cpp (from rev 5833, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_ffmpeg_vdpau.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_ffmpeg_vdpau.cpp	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_ffmpeg_vdpau.cpp	2010-01-10 18:08:39 UTC (rev 5834)
@@ -0,0 +1,343 @@
+/***************************************************************************
+            \file              ADM_ffmpeg_vdpau.cpp  
+            \brief Decoder using half ffmpeg/half VDPAU
+
+    The ffmpeg part is to preformat inputs for VDPAU
+    VDPAU is loaded dynamically to be able to make a binary
+        and have something working even if the target machine
+        does not have vdpau
+    Some part, especially get/buffer and ip_age borrowed from xbmc
+        as the api from ffmpeg is far from clear....
+
+
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+extern "C" {
+#include "ADM_lavcodec.h"
+}
+#include "ADM_default.h"
+#ifdef USE_VDPAU
+extern "C" {
+ #include "ADM_ffmpeg/libavcodec/vdpau.h"
+}
+
+#include "vdpau/vdpau_x11.h"
+#include "vdpau/vdpau.h"
+#include "ADM_codecs/ADM_codec.h"
+#include "ADM_codecs/ADM_ffmp43.h"
+#include "DIA_coreToolkit.h"
+#include "ADM_dynamicLoading.h"
+#include "ADM_render/GUI_render.h"
+#include "ADM_ffmpeg_vdpau_internal.h"
+#include "prefs.h"
+
+static VdpFunctions funcs;
+
+static bool vdpauWorking=false;
+
+static ADM_LibWrapper        vdpauDynaLoader;
+static VdpDeviceCreateX11    *ADM_createVdpX11;
+static VdpDevice             vdpDevice;
+static VdpGetProcAddress     *vdpProcAddress;
+
+#define aprintf(...) {}
+
+/**
+    \fn vdpauUsable
+    \brief Return true if  vdpau can be used...
+*/
+bool vdpauUsable(void)
+{
+    uint32_t v=false;
+    if(!vdpauWorking) return false;
+    if(!prefs->get(FEATURE_VDPAU,&v)) v=false;
+    return v;
+}
+/**
+    \fn getFunc
+    \brief vdpau function pointers from ID
+*/
+static void *getFunc(uint32_t id)
+{
+    void *f;
+    if(VDP_STATUS_OK!=vdpProcAddress(vdpDevice,id,&f)) return NULL;
+    return (void *)f;
+}
+/**
+    \fn vdpauProbe
+    \brief Try loading vdpau...
+*/
+bool vdpauProbe(void)
+{
+    memset(&funcs,0,sizeof(funcs));
+    if(false==vdpauDynaLoader.loadLibrary("/usr/lib/libvdpau.so"))
+    {
+        return false;
+    }
+    ADM_createVdpX11=(VdpDeviceCreateX11*)vdpauDynaLoader.getSymbol("vdp_device_create_x11");
+    if(!ADM_createVdpX11) return false;
+
+    //
+    GUI_WindowInfo xinfo;
+    void *draw;
+    draw=UI_getDrawWidget();
+    UI_getWindowInfo(draw,&xinfo );
+    
+    // try to create....
+    if( VDP_STATUS_OK!=ADM_createVdpX11((Display*)xinfo.display,0,&vdpDevice,&vdpProcAddress))
+    {
+        return false;
+    }
+    // Now that we have the vdpProcAddress, time to get the functions....
+#define GetMe(fun,id)         funcs.fun= (typeof(funcs.fun))getFunc(id);ADM_assert(funcs.fun); 
+        
+    GetMe(getErrorString,VDP_FUNC_ID_GET_ERROR_STRING);
+    GetMe(getApiVersion,VDP_FUNC_ID_GET_API_VERSION);
+    GetMe(getInformationString,VDP_FUNC_ID_GET_INFORMATION_STRING);
+
+    GetMe(createSurface,VDP_FUNC_ID_VIDEO_SURFACE_CREATE);
+    GetMe(destroySurface,VDP_FUNC_ID_VIDEO_SURFACE_DESTROY);
+    GetMe(getDataSurface,VDP_FUNC_ID_VIDEO_SURFACE_GET_BITS_Y_CB_CR);
+
+    GetMe(decoderCreate,VDP_FUNC_ID_DECODER_CREATE);
+    GetMe(decoderDestroy,VDP_FUNC_ID_DECODER_DESTROY);
+    GetMe(decoderRender,VDP_FUNC_ID_DECODER_RENDER);
+
+
+
+    const char *versionString=NULL;
+    uint32_t version=0xff;
+        funcs.getInformationString(&versionString);
+        funcs.getApiVersion(&version);
+        printf("[VDPAU] API : 0x%x, info : %s\n",version,versionString);
+
+    vdpauWorking=true;
+    return true;
+}
+/**
+    \fn ADM_VDPAUgetBuffer
+    \brief trampoline to get a VDPAU surface
+*/
+int ADM_VDPAUgetBuffer(AVCodecContext *avctx, AVFrame *pic)
+{
+    decoderFFVDPAU *dec=(decoderFFVDPAU *)avctx->opaque;
+    return dec->getBuffer(avctx,pic);
+}
+/**
+    \fn getBuffer
+    \brief returns a VDPAU render masquerading as a AVFrame
+*/
+int decoderFFVDPAU::getBuffer(AVCodecContext *avctx, AVFrame *pic)
+{
+    vdpau_render_state * render;
+    if(VDPAU->freeQueue.size()==0)
+    {
+        printf("[VDPAU] No more available surface\n");
+        return -1;
+    }
+    // Get an image   
+    render=VDPAU->freeQueue.back();
+    VDPAU->freeQueue.pop_back();
+    render->state=0;
+    pic->data[0]=(uint8_t *)render;
+    pic->data[1]=(uint8_t *)render;
+    pic->data[2]=(uint8_t *)render;
+    pic->linesize[0]=0;
+    pic->linesize[1]=0;
+    pic->linesize[2]=0;
+    pic->type=FF_BUFFER_TYPE_USER;
+    render->state |= FF_VDPAU_STATE_USED_FOR_REFERENCE;
+    pic->reordered_opaque= avctx->reordered_opaque;
+    if(pic->reference)
+    {
+        pic->age=ip_age[0];
+        ip_age[0]=ip_age[1]+1;
+        ip_age[1]=1;
+        b_age++;
+    }else
+    {
+        pic->age=b_age;
+        ip_age[0]++;
+        ip_age[1]++;
+        b_age=1;
+    }
+    return 0;
+}
+/**
+    \fn releaseBuffer
+*/
+void decoderFFVDPAU::releaseBuffer(AVCodecContext *avctx, AVFrame *pic)
+{
+  vdpau_render_state * render;
+  int i;
+  if(destroying==true) return; // They are already freed...
+  render=(vdpau_render_state*)pic->data[0];
+  ADM_assert(render);
+
+  render->state &= ~FF_VDPAU_STATE_USED_FOR_REFERENCE;
+  for(i=0; i<4; i++){
+    pic->data[i]= NULL;
+  }
+  VDPAU->freeQueue.push_back(render);
+}
+/**
+    \fn ADM_VDPAUreleaseBuffer
+*/
+ void ADM_VDPAUreleaseBuffer(struct AVCodecContext *avctx, AVFrame *pic)
+{
+    decoderFFVDPAU *dec=(decoderFFVDPAU *)avctx->opaque;
+    dec->releaseBuffer(avctx,pic);
+}
+/**
+    \fn decoderFFVDPAU
+*/
+decoderFFVDPAU::decoderFFVDPAU(uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,	   h)
+{
+        destroying=false;
+        _context->opaque          = this;
+        _context->get_buffer      = ADM_VDPAUgetBuffer;
+        _context->release_buffer  = ADM_VDPAUreleaseBuffer;
+        _context->draw_horiz_band = draw;
+        _context->slice_flags     = SLICE_FLAG_CODED_ORDER|SLICE_FLAG_ALLOW_FIELD;
+        _context->extradata = (uint8_t *) d;
+        _context->extradata_size = (int) l;
+
+        vdpau=(void *)new vdpauContext;
+        VDPAU->vdpDecoder=VDP_INVALID_HANDLE;
+        WRAP_OpenByName(h264_vdpau,CODEC_ID_H264);
+        
+        // Now instantiate our VDPAU surface & decoder
+        ADM_assert(VDP_STATUS_OK==funcs.decoderCreate(vdpDevice,VDP_DECODER_PROFILE_H264_HIGH,w,h,15,&(VDPAU->vdpDecoder)));
+        // Create our surfaces...
+        for(int i=0;i<NB_SURFACE;i++)
+        {
+            VDPAU->renders[i]=new vdpau_render_state;
+            memset(VDPAU->renders[i],0,sizeof( vdpau_render_state));
+            ADM_assert(VDP_STATUS_OK==funcs.createSurface(vdpDevice,VDP_CHROMA_TYPE_420,w,h,&(VDPAU->renders[i]->surface)));
+            VDPAU->freeQueue.push_back(VDPAU->renders[i]);
+        }
+        scratch=new ADMImage(w,h,1);
+        b_age = ip_age[0] = ip_age[1] = 256*256*256*64;
+
+}
+/**
+    \fn ~            void    goOn( const AVFrame *d);
+*/
+decoderFFVDPAU::~decoderFFVDPAU()
+{
+        printf("[VDPAU] Cleaning up\n");
+        destroying=true;
+        for(int i=0;i<NB_SURFACE;i++)
+        {
+            ADM_assert(VDP_STATUS_OK==funcs.destroySurface((VDPAU->renders[i]->surface)));
+            delete VDPAU->renders[i];
+        }
+         ADM_assert(VDP_STATUS_OK==funcs.decoderDestroy(VDPAU->vdpDecoder));
+         delete VDPAU;
+         vdpau=NULL;
+}
+/**
+    \fn uncompress
+*/
+uint8_t decoderFFVDPAU::uncompress (ADMCompressedImage * in, ADMImage * out)
+{
+VdpStatus status;
+    
+    // First let ffmpeg prepare datas...
+    vdpau_copy=out;
+    decode_status=false;
+    if(!decoderFF::uncompress (in, scratch))
+    {
+        printf("[VDPAU] No data from libavcodec\n");
+        return 0;
+    }
+    if(decode_status!=true)
+    {
+        printf("[VDPAU] error in renderDecode\n");
+        return 0;
+    }
+    // other part will be done in goOn
+  struct vdpau_render_state *rndr = (struct vdpau_render_state *)scratch->_planes[0];
+   VdpVideoSurface  surface;
+
+    surface=rndr->surface;
+ void *planes[3];
+            planes[0]=vdpau_copy->GetWritePtr(PLANAR_Y);
+            planes[1]=vdpau_copy->GetWritePtr(PLANAR_U);
+            planes[2]=vdpau_copy->GetWritePtr(PLANAR_V);
+    uint32_t stride[3];
+            stride[0]=vdpau_copy->GetPitch(PLANAR_Y);
+            stride[1]=vdpau_copy->GetPitch(PLANAR_U);
+            stride[2]=vdpau_copy->GetPitch(PLANAR_V);
+
+    
+   // Copy back the decoded image to our output ADM_image
+   aprintf("[VDPAU] Getting datas from surface %d\n",surface);
+    status=funcs.getDataSurface(
+                surface,
+                VDP_YCBCR_FORMAT_YV12, //VdpYCbCrFormat   destination_ycbcr_format,
+                planes, //void * const *   destination_data,
+                stride //destination_pitches
+                );
+    if(VDP_STATUS_OK!=status)
+    {
+        
+        printf("[VDPAU] Cannot get data from surface <%s>\n",funcs.getErrorString(status));
+        decode_status=false;
+        return 0 ;
+    }
+    
+
+    //
+    out->Pts=scratch->Pts;
+    out->flags=scratch->flags;
+    return (uint8_t)decode_status;
+}
+/**
+    \fn goOn
+    \brief Callback from ffmpeg when a pic is ready to be decoded
+*/
+void decoderFFVDPAU::goOn( const AVFrame *d,int type)
+{
+   VdpStatus status;
+   struct vdpau_render_state *rndr = (struct vdpau_render_state *)d->data[0];
+   VdpVideoSurface  surface;
+
+    surface=rndr->surface;
+    vdpau_pts=d->reordered_opaque; // Retrieve our PTS
+
+     aprintf("[VDPAU] Decoding Using surface %d\n", surface);
+    status=funcs.decoderRender(VDPAU->vdpDecoder, surface,
+                            (void * const *)&rndr->info, rndr->bitstream_buffers_used, rndr->bitstream_buffers);
+    if(VDP_STATUS_OK!=status)
+    {
+        printf("[VDPAU] No data after decoderRender <%s>\n",funcs.getErrorString(status));
+        decode_status=false;
+        return ;
+    }
+    aprintf("[VDPAU] DecodeRender Ok***\n");
+    decode_status=true;
+    return;
+}
+
+
+/**
+    \fn draw
+    \brief callback invoked by lavcodec when a pic is ready to be decoded
+*/
+void draw(struct AVCodecContext *s,    const AVFrame *src, int offset[4],    int y, int type, int height)
+{
+    decoderFFVDPAU *dec=(decoderFFVDPAU *)s->opaque;
+    dec->goOn(src,type);
+}
+
+#endif
+// EOF

Copied: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_mjpeg.cpp (from rev 5833, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_mjpeg.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_mjpeg.cpp	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_mjpeg.cpp	2010-01-10 18:08:39 UTC (rev 5834)
@@ -0,0 +1,115 @@
+#if 0
+/***************************************************************************
+                          ADM_mjpeg.cpp  -  description
+                             -------------------
+          I think i could use plain jpeg instead but....
+
+
+    begin                : Fri Apr 12 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include <stdio.h>
+#include <stdlib.h>
+#include "ADM_assert.h"
+#include <string.h>
+#include <math.h>
+#include "ADM_default.h"
+#include "config.h"
+#ifdef USE_MJPEG
+#include "ADM_colorspace/colorspace.h"
+
+#include "ADM_codecs/ADM_codec.h"
+#include "ADM_codecs/ADM_mjpeg.h"
+extern "C"
+{
+#include "mjpegtools/jpegutils.h"
+}
+#include "ADM_gui/GUI_decodersettings.h"
+ /*
+  * jpeg_data:       buffer with input / output jpeg
+  * len:             Length of jpeg buffer
+  * itype:           LAV_INTER_NONE: Not interlaced
+  *                  LAV_INTER_TOP_FIRST: Interlaced, top-field-first
+  *                  LAV_INTER_BOTTOM_FIRST: Interlaced, bottom-field-first
+  * ctype            Chroma format for decompression.
+  *                  Currently always 420 and hence ignored.
+  * raw0             buffer with input / output raw Y channel
+  * raw1             buffer with input / output raw U/Cb channel
+  * raw2             buffer with input / output raw V/Cr channel
+  * width            width of Y channel (width of U/V is width/2)
+  * height           height of Y channel (height of U/V is height/2)
+
+
+  int decode_jpeg_raw (unsigned char *jpeg_data, int len,
+  int itype, int ctype, int width, int height,
+  unsigned char *raw0, unsigned char *raw1,
+  unsigned char *raw2);
+
+  */
+void
+decoderMjpeg::setParam (void)
+{
+  int param;
+
+  param = _swap;
+  if (1 == getMjpegParams (&param))
+    {
+      _swap = param;
+    }
+
+}
+//________________________________________________
+
+uint8_t
+  decoderMjpeg::uncompress (uint8_t * in, uint8_t * out, uint32_t len,
+			    uint32_t * flagz)
+{
+  //
+  uint32_t delta;
+  uint8_t *outu, *outv;
+  //
+  UNUSED_ARG (flagz);
+
+
+  delta = _w * _h;
+
+  outu = out + delta;
+  outv = outu + (delta >> 2);
+  if (!_swap)
+
+    decode_jpeg_raw (in, len, 1, 0, _w, _h, out, outu, outv);
+
+  else
+    decode_jpeg_raw (in, len, 1, 0, _w, _h, out, outv, outu);
+
+  return 1;
+
+
+}
+
+//_____________________________________________________
+
+decoderMjpeg::~decoderMjpeg ()
+{
+
+
+}
+// constructor for mjpeg, init encoder and stuff
+decoderMjpeg::decoderMjpeg (uint32_t w, uint32_t h):decoders (w, h)
+{
+  // some mjpeg are encoded with u & v inverted
+  _swap = 0;
+
+}
+#endif
+#endif

Copied: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_png.cpp (from rev 5833, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_png.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_png.cpp	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_png.cpp	2010-01-10 18:08:39 UTC (rev 5834)
@@ -0,0 +1,180 @@
+/***************************************************************************
+                          ADM_png.cpp  -  description
+                             -------------------
+    begin                : Sat Sep 28 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "config.h"
+#ifdef USE_PNG
+#include <stdio.h>
+#include <stdlib.h>
+
+#include <string.h>
+#include <math.h>
+
+#include "ADM_default.h"
+
+//#include "ADM_colorspace/colorspace.h"
+
+#include "ADM_codecs/ADM_codec.h"
+#include "ADM_codecs/ADM_png.h"
+extern "C"
+{
+#include "png.h"
+}
+#include "ADM_assert.h"
+
+#define PNG_PTR ((png_structp)png_ptr)
+#define INFO_PTR ((png_infop)info_ptr)
+#define INFO_END ((png_infop)end_info)
+/*
+   	Initialize codec
+*/
+static void user_read_data (png_structp png_ptr, png_bytep data, png_size_t length);
+
+void decoderPng::recalc (void)
+{
+  int mul;
+  if (colorspace == ADM_COLOR_RGB24)
+    mul = 3;
+
+  else
+    mul = 4;
+  for (int i = 0; i < _h; i++)
+    rows[i] = decoded + mul * _w * i;
+}
+
+
+decoderPng::decoderPng (uint32_t w, uint32_t h):decoders (w, h)
+{
+  rows = NULL;
+  decoded = NULL;
+  colorspace = ADM_COLOR_RGB24;
+
+  //****************************
+  // Prepare the decoded buffer*
+  //****************************
+  decoded = new uint8_t[4 * w * h];	// We take a bit more to be able to decode 32 bits png
+  // without causing a segfault
+  rows = new uint8_t *[h];
+  recalc ();
+}
+ void decoderPng::Init (void)
+{
+  png_ptr =
+    (void *) png_create_read_struct (PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
+  ADM_assert (png_ptr);
+  info_ptr = (void *) png_create_info_struct (PNG_PTR);
+  ADM_assert (info_ptr);
+  end_info = (void *) png_create_info_struct (PNG_PTR);
+  ADM_assert (end_info);
+  memset (&io, 0, sizeof (io));
+  png_set_read_fn (PNG_PTR, &io, user_read_data);
+  png_set_rows (PNG_PTR, INFO_PTR, (png_byte **) rows);
+}
+void decoderPng::Cleanup (void)
+{
+  png_destroy_read_struct ((png_structpp) & png_ptr, (png_infopp) & info_ptr,
+			   (png_infopp) & end_info);
+}
+decoderPng::~decoderPng ()
+{
+  delete[]rows;
+  delete[]decoded;
+}
+/*
+   	Uncompress frame, set flags if needed
+*/
+uint8_t decoderPng::uncompress(ADMCompressedImage * in, ADMImage * out)
+{
+  int bpp;
+  int colortype;
+
+  // Check if it is png, and fill it
+  if (!!png_sig_cmp (in->data, 0, 8))
+
+    {
+      printf ("[PNG] wrong sig\n");
+      return 0;
+    }
+
+  //
+  //
+gain2:
+  Init ();
+  io.data = in->data;
+  io.size = in->dataLength;
+  io.cur = 0;
+  png_read_png (PNG_PTR, INFO_PTR, PNG_TRANSFORM_IDENTITY, NULL);
+
+  // Check if it is 24 or 32 bits RGB 
+  bpp = png_get_bit_depth (PNG_PTR, INFO_PTR);
+//   printf("Bpp:%u\n",bpp);
+  // if needed we change colorspace 
+  colortype = png_get_color_type (PNG_PTR, INFO_PTR);
+  // 
+  if (colorspace == ADM_COLOR_RGB24 && colortype == PNG_COLOR_TYPE_RGB_ALPHA)	// RGB32
+    {
+
+      // Switch to 32 bits
+      colorspace = ADM_COLOR_RGB32A;
+      recalc ();
+      goto gain2;
+    }
+
+  else if (colorspace == ADM_COLOR_RGB32A && colortype == PNG_COLOR_TYPE_RGB)
+
+    {
+
+      // Switch to 24 bits
+      colorspace = ADM_COLOR_RGB24;
+      recalc ();
+      goto gain2;
+    }
+  ADM_assert (out->_isRef);
+  out->_planes[0] = decoded;
+  out->_planes[1] = NULL;
+  out->_planes[2] = NULL;
+  if (colorspace == ADM_COLOR_RGB32A)
+    out->_planeStride[0] = _w * 4;
+
+  else
+    out->_planeStride[0] = _w * 3;
+  out->_planeStride[1] = 0;
+  out->_planeStride[2] = 0;
+  out->_colorspace = colorspace;
+  Cleanup ();
+  return 1;
+}
+
+// ******************************************************
+//    Memory based IO
+// ******************************************************
+void user_read_data (png_structp png_ptr, png_bytep data, png_size_t length)
+{
+  memAccess *ac;
+  ac = (memAccess *) png_get_io_ptr (png_ptr);
+  ADM_assert (length + ac->cur <= ac->size);	// or < ?
+  memcpy (data, ac->data + ac->cur, length);
+  ac->cur += length;
+} 
+
+void user_write_data (png_structp png_ptr, png_bytep data, png_size_t length)
+{
+} 
+
+void user_flush_data (png_structp png_ptr)
+{
+}
+//EOF
+#endif /*  */

Copied: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_rgb16.cpp (from rev 5833, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_rgb16.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_rgb16.cpp	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_rgb16.cpp	2010-01-10 18:08:39 UTC (rev 5834)
@@ -0,0 +1,125 @@
+/***************************************************************************
+                          ADM_rgb16.cpp  -  description
+                             -------------------
+    begin                : Mon May 27 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "ADM_default.h"
+//#include "ADM_colorspace/colorspace.h"
+
+#include "ADM_codecs/ADM_codec.h"
+#include "ADM_codecs/ADM_rgb16.h"
+
+decoderRGB16::decoderRGB16(uint32_t w, uint32_t h, uint32_t rgb, uint32_t bpp) : decoders (w, h)
+{
+	isRgb = rgb;
+	_bpp = bpp;
+
+	decoded = new uint8_t[_bpp * w * h];
+}
+
+decoderRGB16::~decoderRGB16()
+{
+	delete[] decoded;
+}
+
+uint8_t decoderRGB16::uncompress(ADMCompressedImage * in, ADMImage * out)
+{
+	int xx = _w * _h;
+	int lineSize = (_w * (_bpp / 8) + 3) & ~3;
+	ADM_colorspace colorspace;
+	int i, j;
+	uint8_t *src = in->data;
+	uint8_t *dst = decoded;
+
+	switch (_bpp)
+	{
+		case 16:
+			// FIXME - 16-bit could use a BGR555 or BGR565 colour mask
+			colorspace = ADM_COLOR_BGR555;
+			break;
+		case 24:
+		case 32:
+			if(isRgb)
+				colorspace = ADM_COLOR_RGB24;
+			else
+				colorspace = ADM_COLOR_BGR24;
+
+			break;
+		default:
+			printf("bpp %d not supported\n", _bpp);
+			return 0;
+	}
+
+	if (_bpp == 32)
+	{
+		for(i = 0; i < _h; i++)
+		{
+			uint8_t *buf = src;
+			uint8_t *ptr = dst;
+
+			for(j = 0; j < _w; j++)
+			{
+				ptr[0] = buf[0];
+				ptr[1] = buf[1];
+				ptr[2] = buf[2];
+				ptr += 3;
+				buf += 4;
+			}
+
+			src += lineSize;
+			dst += _w * 3;
+		}
+	}
+	else
+	{
+		memcpy(decoded, in->data, lineSize * _h);
+
+		if (lineSize == _w * _bpp)
+		{
+			// no extra junk in scanlines so copy as is
+			memcpy(decoded, in->data, lineSize * _h);
+		}
+		else
+		{
+			// strip extra junk from scanlines (due to 4 byte alignment)
+			for(i = 0; i < _h; i++)
+			{
+				memcpy(dst, src, _w * (_bpp / 8));
+				src += lineSize;
+				dst += _w * (_bpp / 8);
+			}
+		}
+	}
+
+	ADM_assert(out->_isRef);
+
+	out->flags = AVI_KEY_FRAME;
+	out->_colorspace = (ADM_colorspace)(colorspace | ADM_COLOR_BACKWARD);
+
+	out->_planes[0] = decoded;
+	out->_planes[1] = NULL;
+	out->_planes[2] = NULL;
+
+	out->_planeStride[0] = (_bpp / 8) * _w;
+	out->_planeStride[1] = 0;
+	out->_planeStride[2] = 0;
+
+	return 1;
+}
+//EOF

Copied: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_theora_dec.cpp (from rev 5833, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_theora_dec.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_theora_dec.cpp	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_theora_dec.cpp	2010-01-10 18:08:39 UTC (rev 5834)
@@ -0,0 +1,116 @@
+/***************************************************************************
+                          ADM_theora_dec.cpp  -  description
+                             -------------------
+    begin                : Thu Sep 26 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "config.h"
+#include "ADM_default.h"
+
+#ifdef USE_THEORA
+#include "ADM_colorspace/colorspace.h"
+
+#include "ADM_codecs/ADM_codec.h"
+
+#include "ADM_codecs/ADM_theora_dec.h"
+//________________________________________________
+void
+decoderTheora::setParam (void)
+{
+  return;			// no param for ffmpeg
+}
+//-------------------------------
+decoderTheora::decoderTheora (uint32_t w, uint32_t h):decoders (w, h)
+{
+  memset (&_tinfo, 0, sizeof (_tinfo));
+  memset (&_tstate, 0, sizeof (_tstate));
+
+  _tinfo.width = _w;
+  _tinfo.height = _h;
+  _tinfo.fps_numerator = 25;
+  _tinfo.fps_denominator = 1;
+  _tinfo.aspect_numerator = 4;
+  _tinfo.aspect_denominator = 3;
+  _tinfo.quality = 9;
+
+  _tinfo.version_major = 3;
+  _tinfo.version_minor = 1;
+
+
+  theora_decode_init (&_tstate, &_tinfo);
+  printf ("\n Theora initialized\n");
+}
+
+
+//-------------------------------
+
+uint8_t
+  decoderTheora::uncompress (uint8_t * in, uint8_t * out, uint32_t len,
+			     uint32_t * flagz)
+{
+  int got_picture = 0;
+
+  if (len == 0)			// Null frame, silently skip
+    {
+      if (flagz)
+	*flagz = 0;
+      return 1;
+    }
+  ogg_packet ogg;
+
+  memset (&ogg, 0, sizeof (ogg));
+  ogg.packet = in;
+  ogg.bytes = len;
+  /*
+     typedef struct {
+     unsigned char *packet;
+     long  bytes;
+     long  b_o_s;
+     long  e_o_s;
+
+     ogg_int64_t  granulepos;
+
+     ogg_int64_t  packetno;      sequence number for decode; the framing
+     knows where there's a hole in the data,
+     but we need coupling so that the codec
+     (which is in a seperate abstraction
+     layer) also knows about the gap 
+     } ogg_packet; */
+  if (theora_decode_packetin (&_tstate, &ogg))
+    {
+      printf ("\n error decoding theora ..\n");
+      return 0;
+    }
+  yuv_buffer yuv;
+  theora_decode_YUVout (&_tstate, &yuv);
+  memcpy (out, yuv.y, _w * _h);
+  memset (out + _w * _h, 128, (_w * _h) >> 1);
+
+
+
+
+
+  return 1;
+}
+
+//_____________________________________________________
+
+decoderTheora::~decoderTheora ()
+{
+
+  printf ("Theora destroyed\n");
+  theora_clear (&_tstate);
+}
+
+#endif

Copied: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_uyvy.cpp (from rev 5833, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_uyvy.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_uyvy.cpp	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_uyvy.cpp	2010-01-10 18:08:39 UTC (rev 5834)
@@ -0,0 +1,113 @@
+//
+// C++ Implementation: ADM_uyvy
+//
+// Description: 
+//
+//
+// Author: mean <fixounet at free.fr>, (C) 2004
+//
+// Copyright: See COPYING file that comes with this distribution
+//
+//
+#include "config.h"
+#include <stdio.h>
+
+#ifdef HAVE_SYS_PARAM_H
+#include <sys/param.h>
+#endif
+#if  defined( __FreeBSD__ ) || defined(__APPLE__)
+#include <sys/types.h>
+#endif
+
+#include "ADM_default.h"
+#include "avifmt.h"
+#include "avifmt2.h"
+#include "fourcc.h"
+
+#include "ADM_codecs/ADM_codec.h"
+#include "ADM_codecs/ADM_uyvy.h"
+
+uint8_t
+  decoderUYVY::uncompress (ADMCompressedImage * in, ADMImage * out)
+{
+
+  if (in->dataLength < _w * _h * 2)
+    {
+      printf ("in:%d expected%d\n", in->dataLength, _w * _h * 2);
+      return 1;
+    }
+  uint8_t *ptrY, *ptrU, *ptrV, *ptr;
+
+  ptr = in->data;
+  ptrY = out->data;
+  ptrU = out->data + _w * _h;
+  ptrV = ptrU + ((_w * _h) >> 2);
+
+  for (uint32_t y = 0; y < _h; y++)
+    for (uint32_t x = 0; x < (_w >> 2); x++)
+      {
+	if (!(y & 1))
+	  {
+	    *ptrU++ = (*(ptr) + *(ptr + _w)) >> 1;
+	    ptr++;
+	    *ptrY++ = *ptr++;
+	    *ptrV++ = (*(ptr) + *(ptr + _w)) >> 1;
+	    ptr++;
+	    *ptrY++ = *ptr++;
+	  }
+	else
+	  {
+	    *ptrY++ = *(++ptr);
+	    *ptrY++ = *(ptr + 2);
+	    ptr++;
+	  }
+      }
+
+  
+  out->flags = AVI_KEY_FRAME;
+  return 1;
+
+}
+uint8_t
+  decoderYUY2::uncompress  (ADMCompressedImage * in, ADMImage * out)
+{
+
+  if (in->dataLength < _w * _h * 2)
+    {
+      printf ("in:%d expected%d\n", in->dataLength, _w * _h * 2);
+      return 1;
+    }
+  uint8_t *ptrY, *ptrU, *ptrV, *ptr;
+
+  ptr = in->data;
+  ptrY = out->data;
+  ptrV = out->data + _w * _h;
+  ptrU = out->data + ((_w * _h * 5) >> 2);
+
+
+  for (uint32_t y = 0; y < _h; y++)
+    for (uint32_t x = 0; x < (_w >> 1); x++)
+      {
+	if (!(y & 1))
+	  {
+	    *ptrY++ = *ptr++;
+	    *ptrU++ = (*(ptr) + *(ptr + _w * 2)) >> 1;
+	    ptr++;
+	    *ptrY++ = *ptr++;
+	    *ptrV++ = (*(ptr) + *(ptr + _w * 2)) >> 1;
+	    ptr++;
+
+	  }
+	else
+	  {
+	    *ptrY++ = *(ptr);
+	    *ptrY++ = *(ptr + 2);
+	    ptr += 4;
+	  }
+      }
+
+
+  out->flags = AVI_KEY_FRAME;
+  return 1;
+
+}

Copied: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/CMakeLists.txt (from rev 5833, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/CMakeLists.txt)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/CMakeLists.txt	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/CMakeLists.txt	2010-01-10 18:08:39 UTC (rev 5834)
@@ -0,0 +1,18 @@
+SET(ADM_codecs_SRCS 
+ADM_codecs.cpp
+ADM_png.cpp
+ADM_theora_dec.cpp
+ADM_ffmp43.cpp
+ADM_mjpeg.cpp
+ADM_rgb16.cpp
+ADM_uyvy.cpp
+ADM_ffmpeg_vdpau.cpp
+)
+
+ADD_LIBRARY(ADM_codecs6 STATIC ${ADM_codecs_SRCS})
+
+IF (USE_PNG)
+	 ADD_SOURCE_CFLAGS(ADM_png.cpp ${PNG_CFLAGS})
+ENDIF (USE_PNG)
+
+REMOVE_DEFINITIONS(-DHAVE_CONFIG_H)

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/CMakeLists.txt	2010-01-10 18:08:34 UTC (rev 5833)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/CMakeLists.txt	2010-01-10 18:08:39 UTC (rev 5834)
@@ -54,6 +54,7 @@
 ADD_SUBDIRECTORY(ADM_coreAudioEncoder)
 ADD_SUBDIRECTORY(ADM_coreDemuxer)
 ADD_SUBDIRECTORY(ADM_coreDemuxerMpeg)
+ADD_SUBDIRECTORY(ADM_coreVideoCodec)
 ADD_SUBDIRECTORY(ADM_coreImage)
 ADD_SUBDIRECTORY(ADM_coreMuxer)
 ADD_SUBDIRECTORY(ADM_coreUI)



From mean at mail.berlios.de  Sun Jan 10 19:08:59 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 10 Jan 2010 19:08:59 +0100
Subject: [Avidemux-svn-commit] r5835 - in branches/avidemux_2.6_branch_mean:
	avidemux avidemux/common/ADM_commonUI
	avidemux/common/ADM_editor avidemux/common/ADM_script
	avidemux/qt4/ADM_userInterfaces/ADM_dialog
	avidemux/qt4/ADM_userInterfaces/ADM_gui
	avidemux_core/ADM_coreVideoCodec/include
	avidemux_core/ADM_coreVideoCodec/src cmake
Message-ID: <201001101808.o0AI8xJ3013417@sheep.berlios.de>

Author: mean
Date: 2010-01-10 19:08:56 +0100 (Sun, 10 Jan 2010)
New Revision: 5835

Added:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_codecEmpty.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_codecSearch.cpp
Removed:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_mjpeg.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_theora_dec.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_theora_enc.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_mjpeg.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_theora_dec.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edStub.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script/ADM_JSAvidemuxVideo.cpp
   branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/Q_props.cpp
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_gui2.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_codec.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_codecNull.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_ffmp43.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_png.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_rgb16.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_uyvy.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_codecs.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_ffmp43.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_ffmpeg_vdpau.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_png.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_rgb16.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_uyvy.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/cmake/admCoreIncludes.cmake
Log:
[Codec] Move codec to core as a shared library before making them plugins

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/CMakeLists.txt	2010-01-10 18:08:39 UTC (rev 5834)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/CMakeLists.txt	2010-01-10 18:08:56 UTC (rev 5835)
@@ -13,7 +13,7 @@
 DIA_lavDecoder.cpp  
 DIA_requant.cpp   
 #DIA_ocr.cpp             
-DIA_tsSub.cpp        
+#DIA_tsSub.cpp        
 DIA_jobs_save.cpp
 DIA_flv1.cpp            
 DIA_plugins.cpp

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edStub.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edStub.cpp	2010-01-10 18:08:39 UTC (rev 5834)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edStub.cpp	2010-01-10 18:08:56 UTC (rev 5835)
@@ -37,9 +37,9 @@
 {
 	if(_segments.getNbSegments())
     {
-        _VIDEOS *vid=_segments.getRefVideo(0);
-		if(vid->decoder)
-	 		return vid->decoder->getSpecificMpeg4Info();
+ //       _VIDEOS *vid=_segments.getRefVideo(0);
+//		if(vid->decoder)
+//	 		return vid->decoder->getSpecificMpeg4Info();
     }
 	return 0;
 

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx	2010-01-10 18:08:39 UTC (rev 5834)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx	2010-01-10 18:08:56 UTC (rev 5835)
@@ -27,7 +27,7 @@
  #ifndef __ADM_composer__
  #define __ADM_composer__
  #include "ADM_Video.h"
- #include "../ADM_codecs/ADM_codec.h"
+ #include "ADM_codec.h"
  #include "ADM_image.h"
  #include "../ADM_editor/ADM_edCache.h"
  #include "ADM_pp.h"

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp	2010-01-10 18:08:39 UTC (rev 5834)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp	2010-01-10 18:08:56 UTC (rev 5835)
@@ -16,7 +16,7 @@
  ***************************************************************************/
 #include "ADM_default.h"
 #include "ADM_segment.h"
-#include "../ADM_codecs/ADM_codec.h"
+#include "ADM_codec.h"
 #include "ADM_image.h"
 #include "../ADM_editor/ADM_edCache.h"
 #include "ADM_pp.h"

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script/ADM_JSAvidemuxVideo.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script/ADM_JSAvidemuxVideo.cpp	2010-01-10 18:08:39 UTC (rev 5834)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script/ADM_JSAvidemuxVideo.cpp	2010-01-10 18:08:56 UTC (rev 5835)
@@ -472,7 +472,7 @@
          
         // default return value
         *rval=JS_FALSE;
-        if(info & ADM_VOP_ON) *rval=JS_TRUE;
+        //if(info & ADM_VOP_ON) *rval=JS_TRUE;
         return JS_TRUE;
 }// end PostProcess
 /**
@@ -492,7 +492,7 @@
         
         // default return value
         *rval=JS_FALSE;
-        if(info & ADM_GMC_ON) *rval=JS_TRUE;
+        //if(info & ADM_GMC_ON) *rval=JS_TRUE;
         return JS_TRUE;
 }// end PostProcess
 /**
@@ -511,7 +511,7 @@
         leaveLock(); 
         
         *rval=JS_FALSE;
-        if(info & ADM_QPEL_ON) *rval=JS_TRUE;
+        //if(info & ADM_QPEL_ON) *rval=JS_TRUE;
         return JS_TRUE;
 }// end PostProcess
 

Modified: branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake	2010-01-10 18:08:39 UTC (rev 5834)
+++ branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake	2010-01-10 18:08:56 UTC (rev 5835)
@@ -88,7 +88,7 @@
 ADM_audioFilter6
 ADM_editor6
 ADM_audiocodec6 
-ADM_codecs6 
+ADM_coreVideoCodec6 
 ADM_commonUI6
 )
 SET(commonLibs2

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/Q_props.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/Q_props.cpp	2010-01-10 18:08:39 UTC (rev 5834)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/Q_props.cpp	2010-01-10 18:08:56 UTC (rev 5835)
@@ -35,13 +35,13 @@
     text[0] = 0;
     if (!avifileinfo)
         return;
-  
+#if 0  
         // Fetch info
         info=video_body->getSpecificMpeg4Info();
         vop=!!(info & ADM_VOP_ON);
         qpel=!!(info & ADM_QPEL_ON);
         gmc=!!(info & ADM_GMC_ON);
-
+#endif
 #define FILLTEXT(a,b,c) {snprintf(text,79,b,c);ui.a->setText(text);}
 #define FILLTEXT4(a,b,c,d) {snprintf(text,79,b,c,d);ui.a->setText(text);}
 #define FILLTEXT5(a,b,c,d,e) {snprintf(text,79,b,c,d,e);ui.a->setText(text);}

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_gui2.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_gui2.cpp	2010-01-10 18:08:39 UTC (rev 5834)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_gui2.cpp	2010-01-10 18:08:56 UTC (rev 5835)
@@ -21,7 +21,7 @@
 #include "Q_gui2.h"
 #include "ADM_default.h"
 
-#include "ADM_codecs/ADM_codec.h"
+//#include "ADM_codecs/ADM_codec.h"
 #include "gui_action.hxx"
 #include "ADM_editor/ADM_outputfmt.h"
 #include "DIA_fileSel.h"

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_codec.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_codec.h	2010-01-10 18:08:39 UTC (rev 5834)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_codec.h	2010-01-10 18:08:56 UTC (rev 5835)
@@ -1,9 +1,8 @@
 /***************************************************************************
-                          ADM_codec.h  -  description
-                             -------------------
-    begin                : Fri Apr 12 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
+         \fn ADM_codec.h
+         \brief Base class for all decoders
+         \author mean, fixounet at free.fr (C) 2002-2010
+    
  ***************************************************************************/
 
 /***************************************************************************
@@ -14,16 +13,13 @@
  *   (at your option) any later version.                                   *
  *                                                                         *
  ***************************************************************************/
-#ifndef __CODECS__
-#define __CODECS__
+#ifndef __ADM_CODECS__
+#define __ADM_CODECS__
 
 #include "ADM_image.h"
 #include "ADM_frameType.h"
 #include "ADM_codecType.h"
 
-#define ADM_QPEL_ON	1
-#define ADM_GMC_ON	2
-#define ADM_VOP_ON	4
 
 /*
         Bitrate in configuration will always be in **kBITS**
@@ -43,7 +39,7 @@
   uint32_t _h;
   uint8_t _lastQ;
 public:
-    decoders (uint32_t w, uint32_t h)
+    decoders (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp)
   {
     _w = w;
     _h = h;
@@ -60,63 +56,46 @@
   {
     return 1;
   };
-  virtual void setParam (void)
+  virtual bool setParam (void)
   {
+        return false;
   };
-  virtual uint8_t uncompress (ADMCompressedImage * in, ADMImage * out)=0;
+  virtual bool uncompress (ADMCompressedImage * in, ADMImage * out)=0;
 
   // does this codec *possibly* can have b-frame ?
-  virtual uint8_t dontcopy (void)
+  virtual bool dontcopy (void)
   {
-    return 0;
+    return false;
   }				// if 1 means the decoder will return reference
   // no need to copy the datas to ADMimage
-  virtual uint8_t bFramePossible (void)
+  virtual bool bFramePossible (void)
   {
-    return 0;
+    return false;
   }
-  virtual uint8_t decodeHeaderOnly (void)
+  virtual bool decodeHeaderOnly (void)
   {
-    return 0;
+    return false;
   };
-  virtual uint8_t decodeFull (void)
+  virtual bool decodeFull (void)
   {
-    return 0;
+    return false;
   }
-  virtual uint8_t isDivxPacked (void)
-  {
-    return 0;
-  };
-  virtual uint32_t getSpecificMpeg4Info (void)
-  {
-    return 0;
-  };
-  virtual uint8_t isIndexable (void)
-  {
-    return 1;
-  };
   virtual bool flush(void)
     {
         return true;
     }
 };
-/* Dummy decoder in case we don't have the desired one */
-class decoderEmpty : public decoders
-{
-protected:
-public:
-    decoderEmpty (uint32_t w, uint32_t h) : decoders(w,h) {};
-    uint8_t uncompress (ADMCompressedImage * in, ADMImage * out) {return 1;}
 
-};
-
 decoders *getDecoder (uint32_t fcc, uint32_t w, uint32_t h, uint32_t extraLen,
 		      uint8_t * extraData,uint32_t bpp=0);
+#if 0
 decoders *getDecoderVopPacked (uint32_t fcc, uint32_t w, uint32_t h,
 			       uint32_t extraLen, uint8_t * extraData);
 decoders *getDecoderH264noLogic (uint32_t fcc, uint32_t w, uint32_t h, uint32_t extraLen,
 		     uint8_t * extraData);
 
+//***************************************
+
 class coders
 {
 protected:
@@ -154,7 +133,7 @@
   }
 };
 
+#endif
 
 
-
 #endif

Copied: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_codecEmpty.h (from rev 5834, branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_mjpeg.h)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_mjpeg.h	2010-01-10 18:08:39 UTC (rev 5834)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_codecEmpty.h	2010-01-10 18:08:56 UTC (rev 5835)
@@ -0,0 +1,31 @@
+/***************************************************************************
+         \fn ADM_codecEmpty.h
+         \brief Empty decoder
+         \author mean, fixounet at free.fr (C) 2002-2010
+    
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef ADM_codecEmpty_H
+#define ADM_codecEmpty_H
+/* Dummy decoder in case we don't have the desired one */
+class decoderEmpty : public decoders
+{
+protected:
+public:
+    decoderEmpty (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp)
+        :decoders (  w,   h,  fcc,   extraDataLen,  extraData,  bpp)
+    {
+
+    }
+    bool uncompress (ADMCompressedImage * in, ADMImage * out) {return true;}
+
+};
+#endif

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_codecNull.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_codecNull.h	2010-01-10 18:08:39 UTC (rev 5834)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_codecNull.h	2010-01-10 18:08:56 UTC (rev 5835)
@@ -19,13 +19,14 @@
 protected:
 
 public:
-  decoderNull (uint32_t w, uint32_t h):decoders (w, h)
+  decoderNull (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp)
+        :decoders (  w,   h,  fcc,   extraDataLen,  extraData,  bpp)
   {
   }
   virtual ~ decoderNull ()
   {
   };
-  virtual uint8_t uncompress (ADMCompressedImage * in, ADMImage * out)
+  virtual bool uncompress (ADMCompressedImage * in, ADMImage * out)
   {
     memcpy (out->data, in->data, in->dataLength);
     return 1;

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_ffmp43.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_ffmp43.h	2010-01-10 18:08:39 UTC (rev 5834)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_ffmp43.h	2010-01-10 18:08:56 UTC (rev 5835)
@@ -19,6 +19,7 @@
  ***************************************************************************/
 
 #include "ADM_lavcodec.h"
+#if 0
 class decoderFFSubs
 {
   protected:
@@ -31,8 +32,11 @@
     virtual ~ decoderFFSubs ();
     virtual uint8_t uncompress (ADMCompressedImage * in, AVSubtitle * out); 
 };
-
-/****************************/
+#endif
+/**
+    \class decoderFF
+    \brief Base class for lavcodec based decoder
+*/
 class decoderFF:public decoders
 {
 protected:
@@ -52,22 +56,21 @@
   uint32_t _usingMT;
 public:
 
-    decoderFF (uint32_t w, uint32_t h);
+    decoderFF (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
     virtual ~ decoderFF ();
-  virtual uint8_t dontcopy (void)
+  virtual bool dontcopy (void)
   {
-    return 1;
+    return true;
   }
-  virtual uint8_t uncompress (ADMCompressedImage * in, ADMImage * out);
-  virtual void setParam (void);
-  virtual uint8_t bFramePossible (void)
+  virtual bool uncompress (ADMCompressedImage * in, ADMImage * out);
+  virtual bool setParam (void);
+  virtual bool bFramePossible (void)
   {
-    return 0;
+    return false;
   }
-  virtual uint8_t decodeHeaderOnly (void);
-  virtual uint8_t decodeFull (void);
-  virtual uint8_t isDivxPacked (void);
-  virtual uint32_t getSpecificMpeg4Info (void);
+  virtual bool decodeHeaderOnly (void);
+  virtual bool decodeFull (void);
+//  virtual uint32_t getSpecificMpeg4Info (void);
   virtual uint8_t getPARWidth (void);
   virtual uint8_t getPARHeight (void);
   virtual bool    flush(void);
@@ -80,9 +83,10 @@
 
 public:
 
-  decoderFFDiv3 (uint32_t w, uint32_t h);
+  decoderFFDiv3 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
 
 };
+#if 0
 class decoderFFMpeg4VopPacked:public decoderFF
 {
 protected:
@@ -102,16 +106,17 @@
     return 0;
   };
 };
+#endif
 class decoderFFMpeg4:public decoderFF
 {
 protected:
 
 
 public:
-  decoderFFMpeg4 (uint32_t w, uint32_t h, uint32_t fcc,uint32_t l, uint8_t * d);
-  uint8_t uncompress (ADMCompressedImage * in, ADMImage * out);
+        decoderFFMpeg4 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
+  bool uncompress (ADMCompressedImage * in, ADMImage * out);
   // mpeg4 can have B-frame
-  virtual uint8_t bFramePossible (void)
+  virtual bool bFramePossible (void)
   {
     return 1;
   }
@@ -123,9 +128,9 @@
 
 
 public:
-  decoderFFMpeg12 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+  decoderFFMpeg12 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
   // mpeg1/2 can have B-frame
-  virtual uint8_t bFramePossible (void)
+  virtual bool bFramePossible (void)
   {
     return 1;
   }
@@ -137,8 +142,8 @@
 
 
 public:
-  decoderFFSVQ3 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
-  virtual uint8_t bFramePossible (void)
+  decoderFFSVQ3 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
+  virtual bool bFramePossible (void)
   {
     return 0;
   }
@@ -151,7 +156,7 @@
 
 
 public:
-  decoderFFDV (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+  decoderFFDV (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
 
 };
 class decoderFFMP42:public decoderFF
@@ -160,7 +165,7 @@
 
 
 public:
-  decoderFFMP42 (uint32_t w, uint32_t h);
+  decoderFFMP42 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
 
 };
 class decoderFFH263:public decoderFF
@@ -169,7 +174,7 @@
 
 
 public:
-  decoderFFH263 (uint32_t w, uint32_t h);
+  decoderFFH263 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
 
 };
 class decoderFFH264:public decoderFF
@@ -178,12 +183,12 @@
   uint32_t _lowDelay;
 
 public:
-  decoderFFH264 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d,uint32_t lowdelay);
-  virtual uint8_t bFramePossible (void)
+  decoderFFH264 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
+  virtual bool bFramePossible (void)
   {
       return _lowDelay;
   }
-  uint8_t   uncompress (ADMCompressedImage * in, ADMImage * out);
+  bool   uncompress (ADMCompressedImage * in, ADMImage * out);
 
 };
 class decoderFFhuff:public decoderFF
@@ -192,7 +197,7 @@
 
 
 public:
-  decoderFFhuff (uint32_t w, uint32_t h, uint32_t l, uint8_t * d,uint32_t bpp);
+  decoderFFhuff (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
 
 };
 class decoderFF_ffhuff:public decoderFF
@@ -201,7 +206,7 @@
 
 
 public:
-  decoderFF_ffhuff (uint32_t w, uint32_t h, uint32_t l, uint8_t * d,uint32_t bpp);
+  decoderFF_ffhuff (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
 
 };
 class decoderFFWMV2:public decoderFF
@@ -210,7 +215,7 @@
 
 
 public:
-  decoderFFWMV2 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+  decoderFFWMV2 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
 
 };
 class decoderFFWMV1:public decoderFF
@@ -219,7 +224,7 @@
 
 
   public:
-    decoderFFWMV1 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+    decoderFFWMV1 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
 
 };
 
@@ -229,7 +234,7 @@
 
 
 public:
-  decoderFFWMV3 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+  decoderFFWMV3 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
 
 };
 
@@ -239,7 +244,7 @@
 
 
 public:
-  decoderFFVC1 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+  decoderFFVC1 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
 
 };
 
@@ -249,7 +254,7 @@
 
 
 public:
-  decoderFFV1 (uint32_t w, uint32_t h);
+  decoderFFV1 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
 
 };
 class decoderFFMJPEG:public decoderFF
@@ -258,7 +263,7 @@
 
 
 public:
-  decoderFFMJPEG (uint32_t w, uint32_t h);
+  decoderFFMJPEG (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
 
 };
 class decoderSnow:public decoderFF
@@ -267,7 +272,7 @@
 
 
 public:
-  decoderSnow (uint32_t w, uint32_t h);
+  decoderSnow (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
 
 };
 class decoderFFcyuv:public decoderFF
@@ -276,7 +281,7 @@
 
 
 public:
-  decoderFFcyuv (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+  decoderFFcyuv (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
 
 };
 class decoderCamtasia:public decoderFF
@@ -285,7 +290,7 @@
 
 
 public:
-  decoderCamtasia (uint32_t w, uint32_t h,uint32_t bpp);
+  decoderCamtasia (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
 
 };
 class decoderFFTheora:public decoderFF
@@ -294,7 +299,7 @@
 
 
 public:
-  decoderFFTheora (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+  decoderFFTheora (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
 
 };
 
@@ -304,7 +309,7 @@
 
 
 public:
-  decoderFFCinepak (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+  decoderFFCinepak (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
 
 };
 class decoderFFCRAM:public decoderFF
@@ -313,50 +318,50 @@
 
 
 public:
-  decoderFFCRAM (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+  decoderFFCRAM (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
 
 };
 class decoderFFVP6F:public decoderFF
 {
 protected:
 public:
-  decoderFFVP6F (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+  decoderFFVP6F (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
 };
 class decoderFFVP6A:public decoderFF
 {
 protected:
 public:
-  decoderFFVP6A (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+  decoderFFVP6A (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
 };
 class decoderFFFLV1:public decoderFF
 {
 protected:
 public:
-  decoderFFFLV1 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+  decoderFFFLV1 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
 };
 class decoderFFDVBSub:public decoderFF
 {
 protected:
 public:
-  decoderFFDVBSub (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+  decoderFFDVBSub (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
 };
 class decoderFFAMV:public decoderFF
 {
 protected:
 public:
-  decoderFFAMV (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+  decoderFFAMV (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
 };
 class decoderFFMjpegB:public decoderFF
 {
 protected:
 public:
-  decoderFFMjpegB (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+  decoderFFMjpegB (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
 };
 class decoderFFSVQ1:public decoderFF
 {
 protected:
 public:
-  decoderFFSVQ1 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+  decoderFFSVQ1 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
 };
 
 #ifdef USE_VDPAU
@@ -380,12 +385,12 @@
             // public API
                     decoderFFVDPAU (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
                     ~decoderFFVDPAU();
-    virtual uint8_t uncompress (ADMCompressedImage * in, ADMImage * out);
-    virtual uint8_t dontcopy (void)
+    virtual bool uncompress (ADMCompressedImage * in, ADMImage * out);
+    virtual bool dontcopy (void)
                       {
                         return 0;
                       }
-     virtual uint8_t bFramePossible (void)
+    virtual bool bFramePossible (void)
       {
         return 1;
       }

Deleted: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_mjpeg.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_mjpeg.h	2010-01-10 18:08:39 UTC (rev 5834)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_mjpeg.h	2010-01-10 18:08:56 UTC (rev 5835)
@@ -1,29 +0,0 @@
-/***************************************************************************
-                          ADM_mjpeg.h  -  description
-                             -------------------
-    begin                : Sat Apr 13 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-class decoderMjpeg:decoders
-{
-protected:
-  uint8_t _swap;
-
-public:
-  decoderMjpeg (uint32_t w, uint32_t h);
-  virtual ~ decoderMjpeg ();
-  virtual void setParam (void);
-  virtual uint8_t uncompress (uint8_t * in, uint8_t * out, uint32_t len,
-			      uint32_t * flag = NULL);
-};

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_png.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_png.h	2010-01-10 18:08:39 UTC (rev 5834)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_png.h	2010-01-10 18:08:56 UTC (rev 5835)
@@ -16,63 +16,49 @@
  ***************************************************************************/ 
 #ifndef PNG_H_A
 #define PNG_H_A
-#ifdef USE_PNG
 
+/**
+    \struct memAccess   
+    \brief png io wrapper
+*/
 typedef struct memAccess 
 {
   
-int size;
-   
+int size;   
 int cur;
-   
 uint8_t * data;
-
-
 } memAccess;
 
-
+/**
+    \class decoderPng
+*/
 class decoderPng:public decoders 
 {
 
 protected:
-memAccess io;
-  
-ADM_colorspace colorspace;
-  
-void *png_ptr;
-  
-void *info_ptr;
-  
-void *end_info;
-  
+    memAccess io;      
+    ADM_colorspace colorspace;
+    void *png_ptr;
+    void *info_ptr;
+    void *end_info;
+    uint8_t ** rows;      
+    uint8_t * decoded;
+    void Init (void);
+    void Cleanup (void);
+    void recalc (void);
 
-uint8_t ** rows;
-  
-uint8_t * decoded;
-  
-void Init (void);
-  
-void Cleanup (void);
-  
-void recalc (void);
-
 public:
-decoderPng (uint32_t w, uint32_t h);
+            decoderPng (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
   
-virtual ~ decoderPng ();
+    virtual ~ decoderPng ();
   
-virtual uint8_t uncompress(ADMCompressedImage * in, ADMImage * out);
+    virtual bool uncompress(ADMCompressedImage * in, ADMImage * out);
   
-uint8_t dontcopy (void)
-  {
-    return 1;
-  }
-
-
-
+    bool dontcopy (void)
+            {
+                return true;
+            }
 };
 
-#endif /* 
- */
-#endif /* 
- */
+#endif 
+//EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_rgb16.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_rgb16.h	2010-01-10 18:08:39 UTC (rev 5834)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_rgb16.h	2010-01-10 18:08:56 UTC (rev 5835)
@@ -16,7 +16,7 @@
  ***************************************************************************/
 #ifndef ADM_RGB16_H
 #define ADM_RGB16_H
-
+#include "ADM_codec.h"
 #include "ADM_colorspace.h"
 
 class decoderRGB16 : decoders
@@ -24,15 +24,15 @@
 	protected:
 		uint8_t* planar;
 		ColRgbToYV12* color;
-		uint32_t isRgb; // Else BGR
+		bool     isRgb; // Else BGR
 		uint32_t _bpp;
 		uint8_t* decoded;
 
 	public:
-		uint8_t dontcopy (void) { return 1; }
-		decoderRGB16 (uint32_t w, uint32_t h, uint32_t rgb, uint32_t bpp);
+		bool dontcopy (void) { return 1; }
+		decoderRGB16 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
 		virtual ~decoderRGB16();
-		virtual uint8_t uncompress(ADMCompressedImage * in, ADMImage * out);
+		virtual bool uncompress(ADMCompressedImage * in, ADMImage * out);
 };
 
 #endif

Deleted: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_theora_dec.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_theora_dec.h	2010-01-10 18:08:39 UTC (rev 5834)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_theora_dec.h	2010-01-10 18:08:56 UTC (rev 5835)
@@ -1,46 +0,0 @@
-/***************************************************************************
-                          ADM_theora_dec.h  -  description
-                             -------------------
-    begin                : Thu Sep 26 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifdef USE_THEORA
-#ifndef __theora__
-#define __theora__
-
-extern "C"
-{
-#include "theora/theora.h"
-}
-class decoderTheora:public decoders
-{
-protected:
-
-
-  theora_info _tinfo;
-  theora_state _tstate;
-
-
-
-public:
-    decoderTheora (uint32_t w, uint32_t h);
-    virtual ~ decoderTheora ();
-  virtual uint8_t uncompress (uint8_t * in, uint8_t * out, uint32_t len,
-			      uint32_t * flag = NULL);
-  virtual void setParam (void);
-
-
-};
-
-#endif
-#endif

Deleted: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_theora_enc.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_theora_enc.h	2010-01-10 18:08:39 UTC (rev 5834)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_theora_enc.h	2010-01-10 18:08:56 UTC (rev 5835)
@@ -1,16 +0,0 @@
-/***************************************************************************
-                          ADM_theora_enc.h  -  description
-                             -------------------
-    begin                : Thu Sep 26 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_uyvy.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_uyvy.h	2010-01-10 18:08:39 UTC (rev 5834)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_uyvy.h	2010-01-10 18:08:56 UTC (rev 5835)
@@ -9,29 +9,35 @@
 // Copyright: See COPYING file that comes with this distribution
 //
 //
+#ifndef ADM_YUYV_H
+#define ADM_YUYV_H
+#include "ADM_codec.h"
 class decoderUYVY:decoders
 {
 protected:
 
 public:
-  decoderUYVY (uint32_t w, uint32_t h):decoders (w, h)
+  decoderUYVY (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp)
+                :decoders (  w,   h,  fcc,   extraDataLen,  extraData,  bpp)
   {
   };
   virtual ~ decoderUYVY ()
   {
   };
-  virtual uint8_t uncompress (ADMCompressedImage * in, ADMImage * out);
+  virtual bool uncompress (ADMCompressedImage * in, ADMImage * out);
 };
 class decoderYUY2:decoders
 {
 protected:
 
 public:
-  decoderYUY2 (uint32_t w, uint32_t h):decoders (w, h)
+  decoderYUY2 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp)
+                :decoders (  w,   h,  fcc,   extraDataLen,  extraData,  bpp)
   {
   };
   virtual ~ decoderYUY2 ()
   {
   };
-  virtual uint8_t uncompress (ADMCompressedImage * in, ADMImage * out);
+  virtual bool uncompress (ADMCompressedImage * in, ADMImage * out);
 };
+#endif

Copied: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_codecSearch.cpp (from rev 5834, branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_codecs.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_codecs.cpp	2010-01-10 18:08:39 UTC (rev 5834)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_codecSearch.cpp	2010-01-10 18:08:56 UTC (rev 5835)
@@ -0,0 +1,247 @@
+/***************************************************************************
+                          ADM_codecs.cpp  -  description
+                             -------------------
+    begin                : Fri Apr 12 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+
+    see here : http://www.webartz.com/fourcc/
+
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+extern "C"
+{
+#include "ADM_lavcodec.h"
+};
+#include "ADM_default.h"
+
+#ifdef BIG_ENDIAN
+#undef BIG_ENDIAN
+#endif
+
+#include "ADM_codec.h"
+#include "ADM_codecNull.h"
+#include "ADM_rgb16.h"
+#include "ADM_uyvy.h"
+#include "ADM_png.h"
+#include "ADM_codecEmpty.h"
+#include "ADM_ffmp43.h"
+
+#include "avidemutils.h"
+#include "fourcc.h"
+
+extern uint8_t GUI_Question (char *);
+extern uint8_t use_fast_ffmpeg;
+extern bool vdpauUsable(void);
+
+/**
+    \fn getDecoder
+    \brief returns the correct decoder for a stream w,h,fcc,extraLen,extraData,bpp
+*/
+decoders *getDecoder (uint32_t fcc, uint32_t w, uint32_t h, uint32_t extraLen, uint8_t * extraData,uint32_t bpp)
+{
+  ADM_info("Searching decoder (%d x %d, extradataSize:%d)...\n",w,h,extraLen);
+  if (isMSMpeg4Compatible (fcc) == 1)
+    {
+      // For div3, no problem we take ffmpeg
+
+      return (decoders *) (new decoderFFDiv3 (w,h,fcc,extraLen,extraData,bpp));
+    }
+  if (isDVCompatible(fcc))//"CDVC"))
+    {
+
+      return (decoders *) (new decoderFFDV (w,h,fcc,extraLen,extraData,bpp));
+    }
+  if (fourCC::check (fcc, (uint8_t *) "MP42"))
+    {
+
+      return (decoders *) (new decoderFFMP42 (w,h,fcc,extraLen,extraData,bpp));
+    }
+    if (fourCC::check (fcc, (uint8_t *) "FLV1"))
+    {
+      return (decoders *) (new decoderFFFLV1 (w,h,fcc,extraLen,extraData,bpp));
+    }
+  if (fourCC::check (fcc, (uint8_t *) "H263"))
+    {
+
+      return (decoders *) (new decoderFFH263 (w,h,fcc,extraLen,extraData,bpp));
+    }
+  if (fourCC::check (fcc, (uint8_t *) "HFYU"))
+    {
+
+      return (decoders *) (new decoderFFhuff (w,h,fcc,extraLen,extraData,bpp));
+    }
+  if (fourCC::check (fcc, (uint8_t *) "PNG "))
+    {
+
+      return (decoders *) (new decoderPng (w,h,fcc,extraLen,extraData,bpp));
+    }
+ if (fourCC::check (fcc, (uint8_t *) "cvid"))
+    {
+
+      return (decoders *) (new decoderFFCinepak (w,h,fcc,extraLen,extraData,bpp));
+    }
+  if (fourCC::check (fcc, (uint8_t *) "FFVH"))
+    {
+
+      return (decoders *) (new decoderFF_ffhuff (w,h,fcc,extraLen,extraData,bpp));
+    }
+if (fourCC::check (fcc, (uint8_t *) "SVQ1"))
+    {
+
+      return (decoders *) (new decoderFFSVQ1 (w,h,fcc,extraLen,extraData,bpp));
+    }
+
+  if (fourCC::check (fcc, (uint8_t *) "SVQ3"))
+    {
+
+      return (decoders *) (new decoderFFSVQ3 (w,h,fcc,extraLen,extraData,bpp));
+    }
+  if (fourCC::check (fcc, (uint8_t *) "tscc"))
+    {
+
+      return (decoders *) (new decoderCamtasia (w,h,fcc,extraLen,extraData,bpp));
+    }
+
+     if (fourCC::check (fcc, (uint8_t *) "CRAM"))
+    {
+
+      return (decoders *) (new decoderFFCRAM (w,h,fcc,extraLen,extraData,bpp));
+    }
+  if (fourCC::check (fcc, (uint8_t *) "WMV2"))
+    {
+
+      return (decoders *) (new decoderFFWMV2 (w,h,fcc,extraLen,extraData,bpp));
+    }
+    if (fourCC::check (fcc, (uint8_t *) "WMV1"))
+    {
+
+      return (decoders *) (new decoderFFWMV1 (w,h,fcc,extraLen,extraData,bpp));
+    }
+
+  if (fourCC::check (fcc, (uint8_t *) "WMV3") )
+    {
+
+      return (decoders *) (new decoderFFWMV3 (w,h,fcc,extraLen,extraData,bpp));
+    }
+
+    if (fourCC::check (fcc, (uint8_t *) "WVC1")|| fourCC::check (fcc, (uint8_t *) "WMVA"))
+    {
+
+      return (decoders *) (new decoderFFVC1 (w,h,fcc,extraLen,extraData,bpp));
+    }
+
+if (fourCC::check (fcc, (uint8_t *) "FFV1"))
+    {
+
+      return (decoders *) (new decoderFFV1 (w,h,fcc,extraLen,extraData,bpp));
+    }
+  if (fourCC::check (fcc, (uint8_t *) "SNOW"))
+    {
+
+      return (decoders *) (new decoderSnow (w,h,fcc,extraLen,extraData,bpp));
+    }
+  if (isH264Compatible (fcc))
+    {
+#if defined(USE_VDPAU) && 0
+        if(vdpauUsable()==true)
+            return (decoders *) (new decoderFFVDPAU (w,h,fcc,extraLen,extraData,bpp));
+        else
+#endif
+            return (decoders *) (new decoderFFH264 (w,h,fcc,extraLen,extraData,bpp));
+    }
+
+
+/*
+	Could be either divx5 packed crap or xvid or ffmpeg
+	For now we return FFmpeg and later will switch to divx5 if available
+		(ugly hack for ugly hack....)
+*/
+
+  if (isMpeg4Compatible (fcc) == 1)
+    {
+      return (decoders *) (new decoderFFMpeg4 (w,h,fcc,extraLen,extraData,bpp));
+      //    return(decoders *)( new decoderXvid(w,h));
+      //    return(decoders *)( new decoderDIVX(w,h));
+    }
+
+  if (fourCC::check (fcc, (uint8_t *) "MJPB"))
+    {
+      printf ("\n using FF mjpeg codec\n");
+      return (decoders *) (new decoderFFMjpegB (w,h,fcc,extraLen,extraData,bpp));
+    }
+if (fourCC::check (fcc, (uint8_t *) "MJPG")
+      || fourCC::check (fcc, (uint8_t *) "mjpa"))
+    {
+      printf ("\n using FF mjpeg codec\n");
+      return (decoders *) (new decoderFFMJPEG (w,h,fcc,extraLen,extraData,bpp));
+    }
+  if (fourCC::check (fcc, (uint8_t *) "YV12")
+      || fourCC::check (fcc, (uint8_t *) "yv12")
+      || fourCC::check (fcc, (uint8_t *) "I420"))
+    {
+      printf ("\n using null codec\n");
+      return (decoders *) (new decoderNull (w,h,fcc,extraLen,extraData,bpp));
+    }
+  if (fourCC::check (fcc, (uint8_t *) "UYVY"))
+    {
+      printf ("\n using uyvy codec\n");
+      return (decoders *) (new decoderUYVY (w,h,fcc,extraLen,extraData,bpp));
+    }
+  if (fourCC::check (fcc, (uint8_t *) "YUY2"))
+    {
+      printf ("\n using YUY2 codec\n");
+      return (decoders *) (new decoderYUY2 (w,h,fcc,extraLen,extraData,bpp));
+    }
+  if (fourCC::check (fcc, (uint8_t *) "AMV "))
+    {
+      printf ("\n using AMV codec\n");
+      return (decoders *) (new decoderFFAMV (w,h,fcc,extraLen,extraData,bpp));
+    }
+
+ if (fourCC::check (fcc, (uint8_t *) "VP6A"))
+    {
+      printf ("\n using YUY2 codec\n");
+      return (decoders *) (new decoderFFVP6A (w,h,fcc,extraLen,extraData,bpp));
+    }
+  if (isVP6Compatible(fcc))
+    {
+      printf ("\n using VP6F codec\n");
+      return (decoders *) (new decoderFFVP6F (w,h,fcc,extraLen,extraData,bpp));
+    }
+
+
+  if ((fcc == 0) || fourCC::check (fcc, (uint8_t *) "RGB "))
+    {
+      // RGB 16 Codecs
+      printf ("\n using RGB codec\n");
+      return (decoders *) (new decoderRGB16 (w,h,fcc,extraLen,extraData,bpp)); //1
+
+    }
+ if ((fcc == 0) || fourCC::check (fcc, (uint8_t *) "DIB "))
+    {
+      // RGB 16 Codecs
+      printf ("\n using DIB codec\n");
+      return (decoders *) (new decoderRGB16 (w,h,fcc,extraLen,extraData,bpp));  //0
+
+    }
+  if (isMpeg12Compatible (fcc))
+	  return (decoders *) (new decoderFFMpeg12 (w,h,fcc,extraLen,extraData,bpp));
+
+  // default : null decoder
+  printf ("\n using invalid codec for \n");
+  fourCC::print (fcc);
+
+  return (decoders *) (new decoderEmpty(w,h,fcc,extraLen,extraData,bpp));
+}
+//EOF
+

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_codecs.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_codecs.cpp	2010-01-10 18:08:39 UTC (rev 5834)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_codecs.cpp	2010-01-10 18:08:56 UTC (rev 5835)
@@ -17,296 +17,19 @@
  *   (at your option) any later version.                                   *
  *                                                                         *
  ***************************************************************************/
-#include "config.h"
-
-
-#ifdef USE_FFMPEG
-extern "C"
-{
-#include "ADM_lavcodec.h"
-};
-#endif
 #include "ADM_default.h"
-#ifdef BIG_ENDIAN
-#undef BIG_ENDIAN
-#endif
-
-//#include "ADM_colorspace/colorspace.h"
-
-#ifdef USE_XX_XVID
-#include "xvid.h"
-#endif
-
-#include "ADM_codecs/ADM_codec.h"
-#include "ADM_codecs/ADM_mjpeg.h"
-#include "ADM_codecs/ADM_codecNull.h"
-#include "ADM_codecs/ADM_rgb16.h"
-#include "ADM_codecs/ADM_uyvy.h"
-#include "avidemutils.h"
-#include "fourcc.h"
-
-
-#include "ADM_codecs/ADM_ffmp43.h"
-
-
-#ifdef USE_THEORA
-#include "ADM_codecs/ADM_theora_dec.h"
-#endif
-
-#include "ADM_codecs/ADM_png.h"
-
-#include "ADM_assert.h"
-#include "prefs.h"
-
-extern uint8_t GUI_Question (char *);
-extern uint8_t use_fast_ffmpeg;
-extern bool vdpauUsable(void);
-
-uint8_t
-  decoders::uncompress (ADMCompressedImage * in, ADMImage * out)
+#include "ADM_codec.h"
+/**
+    \fn uncompress
+*/
+bool  decoders::uncompress (ADMCompressedImage * in, ADMImage * out)
 {
   UNUSED_ARG (in);
   UNUSED_ARG (out);
-  return 0;
+  return false;
 }
-decoders *
-getDecoderVopPacked (uint32_t fcc, uint32_t w, uint32_t h, uint32_t extraLen,
-		     uint8_t * extraData)
-{
-  UNUSED_ARG (fcc);
-  UNUSED_ARG (extraLen);
-  UNUSED_ARG (extraData);
-  return (decoders *) (new decoderFFMpeg4VopPacked (w, h));
 
-}
-decoders *getDecoderH264noLogic (uint32_t fcc, uint32_t w, uint32_t h, uint32_t extraLen,
-		     uint8_t * extraData)
-{
-  UNUSED_ARG (fcc);
-  UNUSED_ARG (extraLen);
-  UNUSED_ARG (extraData);
-  return (decoders *) (new decoderFFH264 (w, h, extraLen, extraData,0));
-
-}
-/**
-    \fn getDecoder
-    \brief returns the correct decoder for a stream
-*/
-decoders *getDecoder (uint32_t fcc, uint32_t w, uint32_t h, uint32_t extraLen,
-	    uint8_t * extraData,uint32_t bpp)
-{
-  printf("\nSearching decoder (%d x %d, extradataSize:%d)...\n",w,h,extraLen);
-  if (isMSMpeg4Compatible (fcc) == 1)
-    {
-      // For div3, no problem we take ffmpeg
-
-      return (decoders *) (new decoderFFDiv3 (w, h));
-    }
-
-#ifdef USE_FFMPEG
-  if (isDVCompatible(fcc))//"CDVC"))
-    {
-
-      return (decoders *) (new decoderFFDV (w, h, extraLen, extraData));
-    }
-#endif
-#ifdef USE_FFMPEG
-  if (fourCC::check (fcc, (uint8_t *) "MP42"))
-    {
-
-      return (decoders *) (new decoderFFMP42 (w, h));
-    }
-#endif
-    if (fourCC::check (fcc, (uint8_t *) "FLV1"))
-    {
-      return (decoders *) (new decoderFFFLV1 (w, h,extraLen, extraData));
-    }
-
-
-#ifdef USE_FFMPEG
-  if (fourCC::check (fcc, (uint8_t *) "H263"))
-    {
-
-      return (decoders *) (new decoderFFH263 (w, h));
-    }
-  if (fourCC::check (fcc, (uint8_t *) "HFYU"))
-    {
-
-      return (decoders *) (new decoderFFhuff (w, h, extraLen, extraData,bpp));
-    }
-#ifdef USE_PNG
-  if (fourCC::check (fcc, (uint8_t *) "PNG "))
-    {
-
-      return (decoders *) (new decoderPng (w, h));
-    }
-#endif
- if (fourCC::check (fcc, (uint8_t *) "cvid"))
-    {
-
-      return (decoders *) (new decoderFFCinepak (w, h, extraLen, extraData));
-    }
-  if (fourCC::check (fcc, (uint8_t *) "FFVH"))
-    {
-
-      return (decoders *) (new decoderFF_ffhuff (w, h, extraLen, extraData,bpp));
-    }
-if (fourCC::check (fcc, (uint8_t *) "SVQ1"))
-    {
-
-      return (decoders *) (new decoderFFSVQ1 (w, h, extraLen, extraData));
-    }
-
-  if (fourCC::check (fcc, (uint8_t *) "SVQ3"))
-    {
-
-      return (decoders *) (new decoderFFSVQ3 (w, h, extraLen, extraData));
-    }
-  if (fourCC::check (fcc, (uint8_t *) "tscc"))
-    {
-
-      return (decoders *) (new decoderCamtasia (w, h, bpp));
-    }
-
-     if (fourCC::check (fcc, (uint8_t *) "CRAM"))
-    {
-
-      return (decoders *) (new decoderFFCRAM (w, h, extraLen, extraData));
-    }
-  if (fourCC::check (fcc, (uint8_t *) "WMV2"))
-    {
-
-      return (decoders *) (new decoderFFWMV2 (w, h, extraLen, extraData));
-    }
-    if (fourCC::check (fcc, (uint8_t *) "WMV1"))
-    {
-
-      return (decoders *) (new decoderFFWMV1 (w, h, extraLen, extraData));
-    }
-
-  if (fourCC::check (fcc, (uint8_t *) "WMV3") )
-    {
-
-      return (decoders *) (new decoderFFWMV3 (w, h, extraLen, extraData));
-    }
-
-    if (fourCC::check (fcc, (uint8_t *) "WVC1")|| fourCC::check (fcc, (uint8_t *) "WMVA"))
-    {
-
-      return (decoders *) (new decoderFFVC1 (w, h, extraLen, extraData));
-    }
-
-if (fourCC::check (fcc, (uint8_t *) "FFV1"))
-    {
-
-      return (decoders *) (new decoderFFV1 (w, h));
-    }
-  if (fourCC::check (fcc, (uint8_t *) "SNOW"))
-    {
-
-      return (decoders *) (new decoderSnow (w, h));
-    }
-  if (isH264Compatible (fcc))
-    {
-#ifdef USE_VDPAU
-        if(vdpauUsable()==true)
-            return (decoders *) (new decoderFFVDPAU (w, h, extraLen, extraData));
-        else
-#endif
-            return (decoders *) (new decoderFFH264 (w, h, extraLen, extraData,1));
-    }
-#endif
-
-/*
-	Could be either divx5 packed crap or xvid or ffmpeg
-	For now we return FFmpeg and later will switch to divx5 if available
-		(ugly hack for ugly hack....)
-*/
-
-  if (isMpeg4Compatible (fcc) == 1)
-    {
-      return (decoders *) (new decoderFFMpeg4 (w, h, fcc,extraLen, extraData));
-      //    return(decoders *)( new decoderXvid(w,h));
-      //    return(decoders *)( new decoderDIVX(w,h));
-    }
-
-  if (fourCC::check (fcc, (uint8_t *) "MJPB"))
-    {
-      printf ("\n using FF mjpeg codec\n");
-      return (decoders *) (new decoderFFMjpegB (w, h,extraLen,extraData));
-    }
-if (fourCC::check (fcc, (uint8_t *) "MJPG")
-      || fourCC::check (fcc, (uint8_t *) "mjpa"))
-    {
-#if  0
-      //#ifdef USE_MJPEG
-      printf ("\n using mjpeg codec\n");
-      return (decoders *) (new decoderMjpeg (w, h));
-#else
-      printf ("\n using FF mjpeg codec\n");
-      return (decoders *) (new decoderFFMJPEG (w, h));
-#endif
-
-    }
-  if (fourCC::check (fcc, (uint8_t *) "YV12")
-      || fourCC::check (fcc, (uint8_t *) "yv12")
-      || fourCC::check (fcc, (uint8_t *) "I420"))
-    {
-      printf ("\n using null codec\n");
-      return (decoders *) (new decoderNull (w, h));
-    }
-  if (fourCC::check (fcc, (uint8_t *) "UYVY"))
-    {
-      printf ("\n using uyvy codec\n");
-      return (decoders *) (new decoderUYVY (w, h));
-    }
-  if (fourCC::check (fcc, (uint8_t *) "YUY2"))
-    {
-      printf ("\n using YUY2 codec\n");
-      return (decoders *) (new decoderYUY2 (w, h));
-    }
-  if (fourCC::check (fcc, (uint8_t *) "AMV "))
-    {
-      printf ("\n using AMV codec\n");
-      return (decoders *) (new decoderFFAMV (w, h,extraLen,extraData));
-    }
-
- if (fourCC::check (fcc, (uint8_t *) "VP6A"))
-    {
-      printf ("\n using YUY2 codec\n");
-      return (decoders *) (new decoderFFVP6A (w, h,extraLen,extraData));
-    }
-  if (isVP6Compatible(fcc))
-    {
-      printf ("\n using VP6F codec\n");
-      return (decoders *) (new decoderFFVP6F (w, h,extraLen,extraData));
-    }
-
-
-  if ((fcc == 0) || fourCC::check (fcc, (uint8_t *) "RGB "))
-    {
-      // RGB 16 Codecs
-      printf ("\n using RGB codec\n");
-      return (decoders *) (new decoderRGB16 (w, h, 1, bpp));
-
-    }
- if ((fcc == 0) || fourCC::check (fcc, (uint8_t *) "DIB "))
-    {
-      // RGB 16 Codecs
-      printf ("\n using DIB codec\n");
-      return (decoders *) (new decoderRGB16 (w, h, 0, bpp));
-
-    }
-  if (isMpeg12Compatible (fcc))
-	  return (decoders *) (new decoderFFMpeg12 (w, h, extraLen, extraData));
-
-  // default : null decoder
-  printf ("\n using invalid codec for \n");
-  fourCC::print (fcc);
-
-  return (decoders *) (new decoderEmpty (w, h));
-}
-
+#if 0
 uint8_t coders::compress (ADMImage * in, ADMBitstream * out)
 {
   UNUSED_ARG (in);
@@ -314,3 +37,5 @@
 
   return 0;
 }
+#endif
+//EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_ffmp43.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_ffmp43.cpp	2010-01-10 18:08:39 UTC (rev 5834)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_ffmp43.cpp	2010-01-10 18:08:56 UTC (rev 5835)
@@ -1,12 +1,7 @@
 /***************************************************************************
-                          ADM_ffmp43.cpp  -  description
-                             -------------------
-                             
-	Decoder for Divx3/4/..., using ffmpeg
-                             
-    begin                : Wed Sep 25 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
+    \file ADM_ffmp43
+    \brief Decoders using lavcodec
+    \author mean & all (c) 2002-2010
  ***************************************************************************/
 
 /***************************************************************************
@@ -17,25 +12,17 @@
  *   (at your option) any later version.                                   *
  *                                                                         *
  ***************************************************************************/
-#include "config.h"
 
-
-#include "ADM_assert.h"
-#include "prefs.h"
 extern "C" {
 #include "ADM_lavcodec.h"
 }
 #include "ADM_default.h"
 
-#include "ADM_codecs/ADM_codec.h"
-#include "ADM_codecs/ADM_ffmp43.h"
+#include "ADM_codec.h"
+#include "ADM_ffmp43.h"
 #include "DIA_coreToolkit.h"
+//#include "ADM_videoInfoExtractor.h"
 
-#include "ADM_debugID.h"
-#define MODULE_NAME  MODULE_CODEC
-#include "ADM_debug.h"
-#include "ADM_videoInfoExtractor.h"
-
 extern int ADM_cpu_num_processors(void);
 extern "C"
 {
@@ -43,8 +30,8 @@
     static int  ADM_getBuffer(AVCodecContext *avctx, AVFrame *pic);
 }
 
+#define aprintf(...) {}
 
-
 #define WRAP_Open_Template(funcz,argz,display,codecid) \
 {\
 AVCodec *codec=funcz(argz);\
@@ -131,10 +118,10 @@
 {
   uint32_t threads = 0;
 
-  prefs->get(FEATURE_THREADING_LAVC, &threads);
+//  prefs->get(FEATURE_THREADING_LAVC, &threads);
 
-  if (threads == 0)
-	  threads = ADM_cpu_num_processors();
+//  if (threads == 0)
+//	  threads = ADM_cpu_num_processors();
 
   if (threads == 1)
 	  threads = 0;
@@ -161,7 +148,7 @@
 
 }
 
-  
+#if 0  
 uint8_t decoderFF::isDivxPacked (void)
 {
   int
@@ -194,17 +181,17 @@
 
   return out;
 }
-
+#endif
 //________________________________________________
-void
-decoderFF::setParam (void)
+bool  decoderFF::setParam (void)
 {
   DIA_lavDecoder (&_swapUV, &_showMv);
-  return;			// no param for ffmpeg
+  return true;			// no param for ffmpeg
 }
 
 //-------------------------------
-decoderFF::decoderFF (uint32_t w, uint32_t h):decoders (w, h)
+decoderFF::decoderFF (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp)
+            :decoders (w, h,fcc,extraDataLen,extraData,bpp)
 {
   codecId = 0;
 //                              memset(&_context,0,sizeof(_context));
@@ -308,7 +295,7 @@
     }
   return flag;
 }
-uint8_t decoderFF::decodeHeaderOnly (void)
+bool decoderFF::decodeHeaderOnly (void)
 {
   if (codecId == CODEC_ID_H264)
     _context->hurry_up = 4;
@@ -317,7 +304,7 @@
   printf ("\n[lavc] Hurry up\n");
   return 1;
 }
-uint8_t decoderFF::decodeFull (void)
+bool decoderFF::decodeFull (void)
 {
   _context->hurry_up = 0;
   printf ("\n[lavc] full decoding\n");
@@ -338,7 +325,7 @@
     \fn uncompress
     \brief Actually decode an image
 */
-uint8_t   decoderFF::uncompress (ADMCompressedImage * in, ADMImage * out)
+bool   decoderFF::uncompress (ADMCompressedImage * in, ADMImage * out)
 {
   int got_picture = 0;
   uint8_t *oBuff[3];
@@ -490,12 +477,14 @@
 #define LOWDELAY() {} //_context->flags |= CODEC_FLAG_LOW_DELAY
 
 
-decoderFFDiv3::decoderFFDiv3 (uint32_t w, uint32_t h):decoderFF (w, h)
+decoderFFDiv3::decoderFFDiv3 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
+decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
 {
   _refCopy = 1;			// YUV420 only
   WRAP_Open (CODEC_ID_MSMPEG4V3);
 }
 //**************************************************
+#if 0
 decoderFFMpeg4VopPacked::decoderFFMpeg4VopPacked (uint32_t w, uint32_t h):decoderFF (w,
 	   h)
 {
@@ -517,24 +506,24 @@
     return decoderFF::uncompress(in,out);
 
 }
-
-decoderFFMpeg4::decoderFFMpeg4 (uint32_t w, uint32_t h, uint32_t fcc,uint32_t l, uint8_t * d):decoderFF (w,
-	   h)
+#endif
+decoderFFMpeg4::decoderFFMpeg4 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
+decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
 {
 // force low delay as avidemux don't handle B-frames
   LOWDELAY();
-  printf ("[lavc] Using %d bytes of extradata for MPEG4 decoder\n", l);
+  ADM_info ("[lavc] Using %d bytes of extradata for MPEG4 decoder\n", (int)extraDataLen);
   
   _refCopy = 1;			// YUV420 only
-  _context->extradata = (uint8_t *) d;
-  _context->extradata_size = (int) l;
+  _context->extradata = (uint8_t *) extraDataLen;
+  _context->extradata_size = (int) extraDataLen;
   _context->codec_tag=fcc;
   _context->stream_codec_tag=fcc;
   decoderMultiThread ();
   //  _context->flags|=FF_DEBUG_VIS_MV;
   WRAP_Open (CODEC_ID_MPEG4);
 }
-uint8_t decoderFFMpeg4::uncompress (ADMCompressedImage * in, ADMImage * out)
+bool decoderFFMpeg4::uncompress (ADMCompressedImage * in, ADMImage * out)
 {
     // For pseudo startcode
     if(in->dataLength)
@@ -546,22 +535,23 @@
 
 }
 //************************************
-decoderFFDV::decoderFFDV (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,
-	   h)
+decoderFFDV::decoderFFDV (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
+decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
 {
-  _context->extradata = (uint8_t *) d;
-  _context->extradata_size = (int) l;
+  _context->extradata = (uint8_t *) extraData;
+  _context->extradata_size = (int) extraDataLen;
   WRAP_Open (CODEC_ID_DVVIDEO);
 
 }
-decoderFFMP42::decoderFFMP42 (uint32_t w, uint32_t h):decoderFF (w, h)
+decoderFFMP42::decoderFFMP42 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
+                decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
 {
   _refCopy = 1;			// YUV420 only
   WRAP_Open (CODEC_ID_MSMPEG4V2);
 
 }
-decoderFFMpeg12::decoderFFMpeg12 (uint32_t w, uint32_t h, uint32_t extraLen, uint8_t * extraData):decoderFF (w,
-	   h)
+decoderFFMpeg12::decoderFFMpeg12 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
+                decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
 {
   int
     got_picture = 0;
@@ -570,64 +560,62 @@
   decoderMultiThread ();
   WRAP_Open (CODEC_ID_MPEG2VIDEO);
 }
-decoderFFSVQ3::decoderFFSVQ3 (uint32_t w, uint32_t h, uint32_t extraLen, uint8_t * extraData):decoderFF (w,
-	   h)
+decoderFFSVQ3::decoderFFSVQ3 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp)
+        :decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
 {
   int
     got_picture = 0;
 
   LOWDELAY();
   _context->extradata = (uint8_t *) extraData;
-  _context->extradata_size = (int) extraLen;
+  _context->extradata_size = (int) extraDataLen;
   WRAP_Open (CODEC_ID_SVQ3);
 }
 
-decoderFFH263::decoderFFH263 (uint32_t w, uint32_t h):decoderFF (w, h)
+decoderFFH263::decoderFFH263 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp)
+            :decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
 {
   _refCopy = 1;			// YUV420 only
   WRAP_Open (CODEC_ID_H263);
 
 }
-decoderFFV1::decoderFFV1 (uint32_t w, uint32_t h):decoderFF (w, h)
+decoderFFV1::decoderFFV1 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp)
+            :decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
 {
   _refCopy = 1;			// YUV420 only
   WRAP_Open (CODEC_ID_FFV1);
 }
-decoderFF_ffhuff::decoderFF_ffhuff (uint32_t w, uint32_t h, uint32_t l, uint8_t * d,uint32_t bpp):decoderFF (w,
-	   h)
+decoderFF_ffhuff::decoderFF_ffhuff (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp)
+:decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
 {
-  _context->extradata = (uint8_t *) d;
-  _context->extradata_size = (int) l;
+  _context->extradata = (uint8_t *) extraData;
+  _context->extradata_size = (int) extraDataLen;
   _context->bits_per_coded_sample=bpp;
-  printf ("[lavc] FFhuff: We have %d bytes of extra data\n", l);
+  ADM_info ("[lavc] FFhuff: We have %d bytes of extra data\n", (int)extraDataLen);
   WRAP_Open (CODEC_ID_FFVHUFF);
 
 }
-decoderFFH264::decoderFFH264 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d, uint32_t lowdelay):decoderFF (w,
-	   h)
+decoderFFH264::decoderFFH264 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp)
+        :decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
 {
-  _lowDelay=lowdelay;
+
   _refCopy = 1;			// YUV420 only
-  _context->extradata = (uint8_t *) d;
-  _context->extradata_size = (int) l;
+  _context->extradata = (uint8_t *) extraData;
+  _context->extradata_size = (int) extraDataLen;
   decoderMultiThread ();
-  if(lowdelay)
-    LOWDELAY();
-  printf ("[lavc] Initializing H264 decoder with %d extradata\n", l);
-
-       {
-        WRAP_Open(CODEC_ID_H264);
-    }
-
-
+  ADM_info ("[lavc] Initializing H264 decoder with %d extradata\n", (int)extraDataLen);
+  WRAP_Open(CODEC_ID_H264);
 }
 //*********************
 extern "C" {int av_getAVCStreamInfo(AVCodecContext *avctx, uint32_t  *nalSize, uint32_t *isAvc);}
-
-uint8_t   decoderFFH264::uncompress (ADMCompressedImage * in, ADMImage * out)
+/**
+    \fn uncompress
+*/
+bool   decoderFFH264::uncompress (ADMCompressedImage * in, ADMImage * out)
 {
   if(!_context->hurry_up) return decoderFF::uncompress (in, out);
-  
+    ADM_assert(0);
+#if 0  
   uint32_t nalSize, isAvc;
   av_getAVCStreamInfo(_context,&nalSize,&isAvc);
   if(isAvc)
@@ -637,125 +625,140 @@
   {
     return extractH264FrameType_startCode(nalSize, in->data,in->dataLength,&(out->flags));
   }
+#endif
 }
 //*********************
-decoderFFhuff::decoderFFhuff (uint32_t w, uint32_t h, uint32_t l, uint8_t * d,uint32_t bpp):decoderFF (w,
-	   h)
+decoderFFhuff::decoderFFhuff (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
+decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
 {
-  _context->extradata = (uint8_t *) d;
-  _context->extradata_size = (int) l;
+  _context->extradata = (uint8_t *) extraData;
+  _context->extradata_size = (int) extraDataLen;
   _context->bits_per_coded_sample = bpp;
   WRAP_Open (CODEC_ID_HUFFYUV);
 }
-decoderFFWMV2::decoderFFWMV2 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,
-	   h)
+decoderFFWMV2::decoderFFWMV2 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
+decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
 {
-  _context->extradata = (uint8_t *) d;
-  _context->extradata_size = (int) l;
+  _context->extradata = (uint8_t *) extraData;
+  _context->extradata_size = (int) extraDataLen;
 
   WRAP_Open (CODEC_ID_WMV2);
 
 }
-decoderFFWMV1::decoderFFWMV1 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,
-	   h)
+decoderFFWMV1::decoderFFWMV1 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
+decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
 {
-  _context->extradata = (uint8_t *) d;
-  _context->extradata_size = (int) l;
+  _context->extradata = (uint8_t *) extraData;
+  _context->extradata_size = (int) extraDataLen;
 
   WRAP_Open (CODEC_ID_WMV1);
 
 }
 
-decoderFFWMV3::decoderFFWMV3 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,
-	   h)
+decoderFFWMV3::decoderFFWMV3 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
+decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
 {
-  _context->extradata = (uint8_t *) d;
-  _context->extradata_size = (int) l;
+  _context->extradata = (uint8_t *) extraData;
+  _context->extradata_size = (int) extraDataLen;
 
   WRAP_Open (CODEC_ID_WMV3);
 
 }
 
-decoderFFVC1::decoderFFVC1(uint32_t w, uint32_t h, uint32_t l, uint8_t * d) : decoderFF(w, h)
+decoderFFVC1::decoderFFVC1(uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp) : 
+decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
 {
-  _context->extradata = (uint8_t *) d;
-  _context->extradata_size = (int) l;
+  _context->extradata = (uint8_t *) extraData;
+  _context->extradata_size = (int) extraDataLen;
 
   WRAP_Open (CODEC_ID_VC1);
 }
 
-decoderFFcyuv::decoderFFcyuv (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,
-	   h)
+decoderFFcyuv::decoderFFcyuv (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
+decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
+
 {
-  _context->extradata = (uint8_t *) d;
-  _context->extradata_size = (int) l;
+  _context->extradata = (uint8_t *) extraData;
+  _context->extradata_size = (int) extraDataLen;
 
   WRAP_Open (CODEC_ID_CYUV);
 }
-decoderFFMJPEG::decoderFFMJPEG (uint32_t w, uint32_t h):decoderFF (w, h)
+decoderFFMJPEG::decoderFFMJPEG (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
+decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
 {
   WRAP_Open (CODEC_ID_MJPEG);
 }
-decoderFFTheora::decoderFFTheora (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,
-	   h)
+decoderFFTheora::decoderFFTheora (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp)
+:decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
 {
-  _context->extradata = (uint8_t *) d;
-  _context->extradata_size = (int) l;
+  _context->extradata = (uint8_t *) extraData;
+  _context->extradata_size = (int) extraDataLen;
   WRAP_Open (CODEC_ID_THEORA);
 }
-decoderSnow::decoderSnow (uint32_t w, uint32_t h):decoderFF (w, h)
+decoderSnow::decoderSnow (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp)
+:decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
 {
   WRAP_Open (CODEC_ID_SNOW);
 }
 //*************
-decoderCamtasia::decoderCamtasia (uint32_t w, uint32_t h,uint32_t bpp):decoderFF (w,  h)
+decoderCamtasia::decoderCamtasia (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp)
+:decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
 {
   _context->bits_per_coded_sample = bpp;
   WRAP_Open (CODEC_ID_TSCC);
 }
 //*************
-decoderFFCinepak::decoderFFCinepak (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,	   h)
+decoderFFCinepak::decoderFFCinepak (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
+decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
 {
   WRAP_Open (CODEC_ID_CINEPAK);
 }
 //*************
-decoderFFCRAM::decoderFFCRAM (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,	   h)
+decoderFFCRAM::decoderFFCRAM (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
+decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
 {
   WRAP_Open (CODEC_ID_MSVIDEO1);
 }
 //*************
-decoderFFVP6F::decoderFFVP6F (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,	   h)
+decoderFFVP6F::decoderFFVP6F (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
+decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
 {
   WRAP_Open (CODEC_ID_VP6F);
 }
 //*************
-decoderFFVP6A::decoderFFVP6A (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,	   h)
+decoderFFVP6A::decoderFFVP6A (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
+decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
 {
   WRAP_Open (CODEC_ID_VP6A);
 }
 
 //*************
-decoderFFSVQ1::decoderFFSVQ1 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,	   h)
+decoderFFSVQ1::decoderFFSVQ1 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
+decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
 {
   WRAP_Open (CODEC_ID_SVQ1);
 }
 
 //************
-decoderFFFLV1::decoderFFFLV1 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,	   h)
+decoderFFFLV1::decoderFFFLV1 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
+decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
 {
   WRAP_Open (CODEC_ID_FLV1);
 }
-decoderFFAMV::decoderFFAMV (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,   h)
+decoderFFAMV::decoderFFAMV (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
+decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
 {
   WRAP_Open (CODEC_ID_AMV);
   //_context->codec_id=CODEC_ID_AMV;
 }
-decoderFFMjpegB::decoderFFMjpegB (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,   h)
+decoderFFMjpegB::decoderFFMjpegB (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
+decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
 {
   WRAP_Open (CODEC_ID_MJPEGB);
   //_context->codec_id=CODEC_ID_AMV;
 }
-decoderFFDVBSub::decoderFFDVBSub (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,	   h)
+#if 0
+decoderFFDVBSub::decoderFFDVBSub (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):decoderFF (w,	   h)
 {
   _context->sub_id=1;
   WRAP_Open (CODEC_ID_DVB_SUBTITLE);
@@ -797,7 +800,7 @@
      return 1;
 }
 
-
+#endif
 //***************
 extern uint8_t  lavformat_init(void);
 extern void     avcodec_init(void );

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_ffmpeg_vdpau.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_ffmpeg_vdpau.cpp	2010-01-10 18:08:39 UTC (rev 5834)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_ffmpeg_vdpau.cpp	2010-01-10 18:08:56 UTC (rev 5835)
@@ -20,6 +20,7 @@
  *   (at your option) any later version.                                   *
  *                                                                         *
  ***************************************************************************/
+#if 0
 extern "C" {
 #include "ADM_lavcodec.h"
 }
@@ -31,13 +32,13 @@
 
 #include "vdpau/vdpau_x11.h"
 #include "vdpau/vdpau.h"
-#include "ADM_codecs/ADM_codec.h"
-#include "ADM_codecs/ADM_ffmp43.h"
+#include "ADM_codec.h"
+#include "ADM_ffmp43.h"
 #include "DIA_coreToolkit.h"
 #include "ADM_dynamicLoading.h"
 #include "ADM_render/GUI_render.h"
 #include "ADM_ffmpeg_vdpau_internal.h"
-#include "prefs.h"
+//#include "prefs.h"
 
 static VdpFunctions funcs;
 
@@ -340,4 +341,5 @@
 }
 
 #endif
+#endif
 // EOF

Deleted: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_mjpeg.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_mjpeg.cpp	2010-01-10 18:08:39 UTC (rev 5834)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_mjpeg.cpp	2010-01-10 18:08:56 UTC (rev 5835)
@@ -1,115 +0,0 @@
-#if 0
-/***************************************************************************
-                          ADM_mjpeg.cpp  -  description
-                             -------------------
-          I think i could use plain jpeg instead but....
-
-
-    begin                : Fri Apr 12 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include <stdio.h>
-#include <stdlib.h>
-#include "ADM_assert.h"
-#include <string.h>
-#include <math.h>
-#include "ADM_default.h"
-#include "config.h"
-#ifdef USE_MJPEG
-#include "ADM_colorspace/colorspace.h"
-
-#include "ADM_codecs/ADM_codec.h"
-#include "ADM_codecs/ADM_mjpeg.h"
-extern "C"
-{
-#include "mjpegtools/jpegutils.h"
-}
-#include "ADM_gui/GUI_decodersettings.h"
- /*
-  * jpeg_data:       buffer with input / output jpeg
-  * len:             Length of jpeg buffer
-  * itype:           LAV_INTER_NONE: Not interlaced
-  *                  LAV_INTER_TOP_FIRST: Interlaced, top-field-first
-  *                  LAV_INTER_BOTTOM_FIRST: Interlaced, bottom-field-first
-  * ctype            Chroma format for decompression.
-  *                  Currently always 420 and hence ignored.
-  * raw0             buffer with input / output raw Y channel
-  * raw1             buffer with input / output raw U/Cb channel
-  * raw2             buffer with input / output raw V/Cr channel
-  * width            width of Y channel (width of U/V is width/2)
-  * height           height of Y channel (height of U/V is height/2)
-
-
-  int decode_jpeg_raw (unsigned char *jpeg_data, int len,
-  int itype, int ctype, int width, int height,
-  unsigned char *raw0, unsigned char *raw1,
-  unsigned char *raw2);
-
-  */
-void
-decoderMjpeg::setParam (void)
-{
-  int param;
-
-  param = _swap;
-  if (1 == getMjpegParams (&param))
-    {
-      _swap = param;
-    }
-
-}
-//________________________________________________
-
-uint8_t
-  decoderMjpeg::uncompress (uint8_t * in, uint8_t * out, uint32_t len,
-			    uint32_t * flagz)
-{
-  //
-  uint32_t delta;
-  uint8_t *outu, *outv;
-  //
-  UNUSED_ARG (flagz);
-
-
-  delta = _w * _h;
-
-  outu = out + delta;
-  outv = outu + (delta >> 2);
-  if (!_swap)
-
-    decode_jpeg_raw (in, len, 1, 0, _w, _h, out, outu, outv);
-
-  else
-    decode_jpeg_raw (in, len, 1, 0, _w, _h, out, outv, outu);
-
-  return 1;
-
-
-}
-
-//_____________________________________________________
-
-decoderMjpeg::~decoderMjpeg ()
-{
-
-
-}
-// constructor for mjpeg, init encoder and stuff
-decoderMjpeg::decoderMjpeg (uint32_t w, uint32_t h):decoders (w, h)
-{
-  // some mjpeg are encoded with u & v inverted
-  _swap = 0;
-
-}
-#endif
-#endif

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_png.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_png.cpp	2010-01-10 18:08:39 UTC (rev 5834)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_png.cpp	2010-01-10 18:08:56 UTC (rev 5835)
@@ -14,25 +14,15 @@
  *   (at your option) any later version.                                   *
  *                                                                         *
  ***************************************************************************/
-#include "config.h"
-#ifdef USE_PNG
-#include <stdio.h>
-#include <stdlib.h>
 
-#include <string.h>
+#include "ADM_default.h"
 #include <math.h>
-
-#include "ADM_default.h"
-
-//#include "ADM_colorspace/colorspace.h"
-
-#include "ADM_codecs/ADM_codec.h"
-#include "ADM_codecs/ADM_png.h"
+#include "ADM_codec.h"
+#include "ADM_png.h"
 extern "C"
 {
 #include "png.h"
 }
-#include "ADM_assert.h"
 
 #define PNG_PTR ((png_structp)png_ptr)
 #define INFO_PTR ((png_infop)info_ptr)
@@ -41,7 +31,9 @@
    	Initialize codec
 */
 static void user_read_data (png_structp png_ptr, png_bytep data, png_size_t length);
-
+/**
+    \fn Recalc
+*/
 void decoderPng::recalc (void)
 {
   int mul;
@@ -54,8 +46,11 @@
     rows[i] = decoded + mul * _w * i;
 }
 
-
-decoderPng::decoderPng (uint32_t w, uint32_t h):decoders (w, h)
+/**
+    \fn decoderPng
+*/
+decoderPng::decoderPng (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
+                    decoders (w, h,fcc,extraDataLen,extraData,bpp)
 {
   rows = NULL;
   decoded = NULL;
@@ -69,10 +64,12 @@
   rows = new uint8_t *[h];
   recalc ();
 }
+/**
+    \fn Init
+*/
  void decoderPng::Init (void)
 {
-  png_ptr =
-    (void *) png_create_read_struct (PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
+  png_ptr =    (void *) png_create_read_struct (PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
   ADM_assert (png_ptr);
   info_ptr = (void *) png_create_info_struct (PNG_PTR);
   ADM_assert (info_ptr);
@@ -82,20 +79,27 @@
   png_set_read_fn (PNG_PTR, &io, user_read_data);
   png_set_rows (PNG_PTR, INFO_PTR, (png_byte **) rows);
 }
+/**
+    \fn Cleanup
+*/
 void decoderPng::Cleanup (void)
 {
   png_destroy_read_struct ((png_structpp) & png_ptr, (png_infopp) & info_ptr,
 			   (png_infopp) & end_info);
 }
+/**
+    \fn dtor
+*/
 decoderPng::~decoderPng ()
 {
   delete[]rows;
   delete[]decoded;
 }
-/*
-   	Uncompress frame, set flags if needed
+/**
+    \fn uncompress
+   	\brief Uncompress frame, set flags if needed
 */
-uint8_t decoderPng::uncompress(ADMCompressedImage * in, ADMImage * out)
+bool decoderPng::uncompress(ADMCompressedImage * in, ADMImage * out)
 {
   int bpp;
   int colortype;
@@ -104,8 +108,8 @@
   if (!!png_sig_cmp (in->data, 0, 8))
 
     {
-      printf ("[PNG] wrong sig\n");
-      return 0;
+      ADM_warning ("[PNG] wrong sig\n");
+      return false;
     }
 
   //
@@ -154,7 +158,7 @@
   out->_planeStride[2] = 0;
   out->_colorspace = colorspace;
   Cleanup ();
-  return 1;
+  return true;
 }
 
 // ******************************************************
@@ -177,4 +181,3 @@
 {
 }
 //EOF
-#endif /*  */

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_rgb16.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_rgb16.cpp	2010-01-10 18:08:39 UTC (rev 5834)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_rgb16.cpp	2010-01-10 18:08:56 UTC (rev 5835)
@@ -15,19 +15,14 @@
  *                                                                         *
  ***************************************************************************/
 
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
 #include "ADM_default.h"
-//#include "ADM_colorspace/colorspace.h"
+#include "ADM_codec.h"
+#include "ADM_rgb16.h"
 
-#include "ADM_codecs/ADM_codec.h"
-#include "ADM_codecs/ADM_rgb16.h"
-
-decoderRGB16::decoderRGB16(uint32_t w, uint32_t h, uint32_t rgb, uint32_t bpp) : decoders (w, h)
+decoderRGB16::decoderRGB16(uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp)
+    : decoders (  w,   h,  fcc,   extraDataLen,   extraData,  bpp)
 {
-	isRgb = rgb;
+	isRgb = true;
 	_bpp = bpp;
 
 	decoded = new uint8_t[_bpp * w * h];
@@ -38,7 +33,7 @@
 	delete[] decoded;
 }
 
-uint8_t decoderRGB16::uncompress(ADMCompressedImage * in, ADMImage * out)
+bool decoderRGB16::uncompress(ADMCompressedImage * in, ADMImage * out)
 {
 	int xx = _w * _h;
 	int lineSize = (_w * (_bpp / 8) + 3) & ~3;

Deleted: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_theora_dec.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_theora_dec.cpp	2010-01-10 18:08:39 UTC (rev 5834)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_theora_dec.cpp	2010-01-10 18:08:56 UTC (rev 5835)
@@ -1,116 +0,0 @@
-/***************************************************************************
-                          ADM_theora_dec.cpp  -  description
-                             -------------------
-    begin                : Thu Sep 26 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include "config.h"
-#include "ADM_default.h"
-
-#ifdef USE_THEORA
-#include "ADM_colorspace/colorspace.h"
-
-#include "ADM_codecs/ADM_codec.h"
-
-#include "ADM_codecs/ADM_theora_dec.h"
-//________________________________________________
-void
-decoderTheora::setParam (void)
-{
-  return;			// no param for ffmpeg
-}
-//-------------------------------
-decoderTheora::decoderTheora (uint32_t w, uint32_t h):decoders (w, h)
-{
-  memset (&_tinfo, 0, sizeof (_tinfo));
-  memset (&_tstate, 0, sizeof (_tstate));
-
-  _tinfo.width = _w;
-  _tinfo.height = _h;
-  _tinfo.fps_numerator = 25;
-  _tinfo.fps_denominator = 1;
-  _tinfo.aspect_numerator = 4;
-  _tinfo.aspect_denominator = 3;
-  _tinfo.quality = 9;
-
-  _tinfo.version_major = 3;
-  _tinfo.version_minor = 1;
-
-
-  theora_decode_init (&_tstate, &_tinfo);
-  printf ("\n Theora initialized\n");
-}
-
-
-//-------------------------------
-
-uint8_t
-  decoderTheora::uncompress (uint8_t * in, uint8_t * out, uint32_t len,
-			     uint32_t * flagz)
-{
-  int got_picture = 0;
-
-  if (len == 0)			// Null frame, silently skip
-    {
-      if (flagz)
-	*flagz = 0;
-      return 1;
-    }
-  ogg_packet ogg;
-
-  memset (&ogg, 0, sizeof (ogg));
-  ogg.packet = in;
-  ogg.bytes = len;
-  /*
-     typedef struct {
-     unsigned char *packet;
-     long  bytes;
-     long  b_o_s;
-     long  e_o_s;
-
-     ogg_int64_t  granulepos;
-
-     ogg_int64_t  packetno;      sequence number for decode; the framing
-     knows where there's a hole in the data,
-     but we need coupling so that the codec
-     (which is in a seperate abstraction
-     layer) also knows about the gap 
-     } ogg_packet; */
-  if (theora_decode_packetin (&_tstate, &ogg))
-    {
-      printf ("\n error decoding theora ..\n");
-      return 0;
-    }
-  yuv_buffer yuv;
-  theora_decode_YUVout (&_tstate, &yuv);
-  memcpy (out, yuv.y, _w * _h);
-  memset (out + _w * _h, 128, (_w * _h) >> 1);
-
-
-
-
-
-  return 1;
-}
-
-//_____________________________________________________
-
-decoderTheora::~decoderTheora ()
-{
-
-  printf ("Theora destroyed\n");
-  theora_clear (&_tstate);
-}
-
-#endif

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_uyvy.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_uyvy.cpp	2010-01-10 18:08:39 UTC (rev 5834)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_uyvy.cpp	2010-01-10 18:08:56 UTC (rev 5835)
@@ -1,34 +1,24 @@
-//
-// C++ Implementation: ADM_uyvy
-//
-// Description: 
-//
-//
-// Author: mean <fixounet at free.fr>, (C) 2004
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-#include "config.h"
-#include <stdio.h>
+/**
 
-#ifdef HAVE_SYS_PARAM_H
-#include <sys/param.h>
-#endif
-#if  defined( __FreeBSD__ ) || defined(__APPLE__)
-#include <sys/types.h>
-#endif
+    \file ADM_uyvy
+    \author mean fixounet at free.fr, 2004-1010
+*/
 
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
 #include "ADM_default.h"
 #include "avifmt.h"
 #include "avifmt2.h"
 #include "fourcc.h"
+#include "ADM_uyvy.h"
 
-#include "ADM_codecs/ADM_codec.h"
-#include "ADM_codecs/ADM_uyvy.h"
-
-uint8_t
-  decoderUYVY::uncompress (ADMCompressedImage * in, ADMImage * out)
+bool   decoderUYVY::uncompress (ADMCompressedImage * in, ADMImage * out)
 {
 
   if (in->dataLength < _w * _h * 2)
@@ -68,8 +58,7 @@
   return 1;
 
 }
-uint8_t
-  decoderYUY2::uncompress  (ADMCompressedImage * in, ADMImage * out)
+bool   decoderYUY2::uncompress  (ADMCompressedImage * in, ADMImage * out)
 {
 
   if (in->dataLength < _w * _h * 2)

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/CMakeLists.txt	2010-01-10 18:08:39 UTC (rev 5834)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/CMakeLists.txt	2010-01-10 18:08:56 UTC (rev 5835)
@@ -1,18 +1,16 @@
 SET(ADM_codecs_SRCS 
 ADM_codecs.cpp
 ADM_png.cpp
-ADM_theora_dec.cpp
 ADM_ffmp43.cpp
-ADM_mjpeg.cpp
 ADM_rgb16.cpp
 ADM_uyvy.cpp
 ADM_ffmpeg_vdpau.cpp
+ADM_png.cpp
+ADM_codecSearch.cpp
 )
 
-ADD_LIBRARY(ADM_codecs6 STATIC ${ADM_codecs_SRCS})
+ADD_LIBRARY(ADM_coreVideoCodec6 SHARED ${ADM_codecs_SRCS})
+ADD_SOURCE_CFLAGS(ADM_png.cpp ${PNG_CFLAGS})
+ADM_INSTALL_LIB(ADM_coreVideoCodec6)
 
-IF (USE_PNG)
-	 ADD_SOURCE_CFLAGS(ADM_png.cpp ${PNG_CFLAGS})
-ENDIF (USE_PNG)
-
 REMOVE_DEFINITIONS(-DHAVE_CONFIG_H)

Modified: branches/avidemux_2.6_branch_mean/cmake/admCoreIncludes.cmake
===================================================================
--- branches/avidemux_2.6_branch_mean/cmake/admCoreIncludes.cmake	2010-01-10 18:08:39 UTC (rev 5834)
+++ branches/avidemux_2.6_branch_mean/cmake/admCoreIncludes.cmake	2010-01-10 18:08:56 UTC (rev 5835)
@@ -14,6 +14,7 @@
 INCLUDE_DIRECTORIES(${AVIDEMUX_TOP_SOURCE_DIR}/avidemux_core/ADM_coreUtils/include)
 INCLUDE_DIRECTORIES(${AVIDEMUX_TOP_SOURCE_DIR}/avidemux_core/ADM_coreVideoEncoder/include)
 INCLUDE_DIRECTORIES(${AVIDEMUX_TOP_SOURCE_DIR}/avidemux_core/ADM_coreVideoFilter/include)
+INCLUDE_DIRECTORIES(${AVIDEMUX_TOP_SOURCE_DIR}/avidemux_core/ADM_coreVideoCodec/include)
 INCLUDE_DIRECTORIES(${AVIDEMUX_TOP_SOURCE_DIR}/avidemux_core/ADM_ffmpeg)
 INCLUDE_DIRECTORIES(${AVIDEMUX_INCLUDE_DIR}/avidemux/2.6/)
 



From mean at mail.berlios.de  Sun Jan 10 19:09:05 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 10 Jan 2010 19:09:05 +0100
Subject: [Avidemux-svn-commit] r5836 - in
	branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces:
	ADM_dialog ADM_gui2
Message-ID: <201001101809.o0AI95Yd013514@sheep.berlios.de>

Author: mean
Date: 2010-01-10 19:09:02 +0100 (Sun, 10 Jan 2010)
New Revision: 5836

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_dialog/DIA_properties.cpp
   branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_gui2/GUI_bindings.cpp
Log:
[codec] Update gtk

Modified: branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_dialog/DIA_properties.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_dialog/DIA_properties.cpp	2010-01-10 18:08:56 UTC (rev 5835)
+++ branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_dialog/DIA_properties.cpp	2010-01-10 18:09:02 UTC (rev 5836)
@@ -34,10 +34,10 @@
         return;
 
         // Fetch info
-        info=video_body->getSpecificMpeg4Info();
-        vop=!!(info & ADM_VOP_ON);
-        qpel=!!(info & ADM_QPEL_ON);
-        gmc=!!(info & ADM_GMC_ON);
+        //info=video_body->getSpecificMpeg4Info();
+        //vop=!!(info & ADM_VOP_ON);
+        //qpel=!!(info & ADM_QPEL_ON);
+        //gmc=!!(info & ADM_GMC_ON);
 
         dialog = create_dialog1();
 

Modified: branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_gui2/GUI_bindings.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_gui2/GUI_bindings.cpp	2010-01-10 18:08:56 UTC (rev 5835)
+++ branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_gui2/GUI_bindings.cpp	2010-01-10 18:09:02 UTC (rev 5836)
@@ -24,7 +24,7 @@
 #define MODULE_NAME MODULE_UI
 #include "ADM_debug.h"
 
-#include "ADM_codecs/ADM_codec.h"
+//#include "ADM_codecs/ADM_codec.h"
 #include "../ADM_commonUI/GUI_ui.h"
 
 #include "DIA_fileSel.h"



From mean at mail.berlios.de  Sun Jan 10 19:09:14 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 10 Jan 2010 19:09:14 +0100
Subject: [Avidemux-svn-commit] r5837 - in
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec:
	include src
Message-ID: <201001101809.o0AI9Eq2013568@sheep.berlios.de>

Author: mean
Date: 2010-01-10 19:09:07 +0100 (Sun, 10 Jan 2010)
New Revision: 5837

Added:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_codecFFsimple.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_codecFFsimple.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_ffmp43.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_codecSearch.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_ffmp43.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/CMakeLists.txt
Log:
[codec] Factorize codec

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_codecFFsimple.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_codecFFsimple.h	2010-01-10 18:09:02 UTC (rev 5836)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_codecFFsimple.h	2010-01-10 18:09:07 UTC (rev 5837)
@@ -0,0 +1,46 @@
+/***************************************************************************
+                          ADM_ffmp43.h  -  description
+                             -------------------
+                             
+	Mpeg4 ****decoder******** using ffmpeg
+	                              
+    begin                : Wed Sep 25 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef ADM_CODEC_FF_SIMPLE
+#define ADM_CODEC_FF_SIMPLE
+extern "C" {
+#include "ADM_lavcodec.h"
+}
+#include "ADM_default.h"
+#include "ADM_codec.h"
+#include "ADM_ffmp43.h"
+
+/**
+    \class decoderFFSimple
+*/
+class decoderFFSimple:public decoderFF
+{
+protected:
+
+
+public:
+  decoderFFSimple (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
+
+};
+
+decoders *admCreateFFSimple(uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
+
+#endif
+// EOF
+

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_ffmp43.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_ffmp43.h	2010-01-10 18:09:02 UTC (rev 5836)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_ffmp43.h	2010-01-10 18:09:07 UTC (rev 5837)
@@ -17,22 +17,11 @@
  *   (at your option) any later version.                                   *
  *                                                                         *
  ***************************************************************************/
+#ifndef ADM_FFMP43_H
+#define ADM_FFMP43_H
 
 #include "ADM_lavcodec.h"
-#if 0
-class decoderFFSubs
-{
-  protected:
-     int      codecId;
-     uint32_t subId;
-     AVCodecContext *_context;
-  public:
 
-    decoderFFSubs (uint32_t subId);
-    virtual ~ decoderFFSubs ();
-    virtual uint8_t uncompress (ADMCompressedImage * in, AVSubtitle * out); 
-};
-#endif
 /**
     \class decoderFF
     \brief Base class for lavcodec based decoder
@@ -209,45 +198,6 @@
   decoderFF_ffhuff (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
 
 };
-class decoderFFWMV2:public decoderFF
-{
-protected:
-
-
-public:
-  decoderFFWMV2 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
-
-};
-class decoderFFWMV1:public decoderFF
-{
-  protected:
-
-
-  public:
-    decoderFFWMV1 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
-
-};
-
-class decoderFFWMV3:public decoderFF
-{
-protected:
-
-
-public:
-  decoderFFWMV3 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
-
-};
-
-class decoderFFVC1:public decoderFF
-{
-protected:
-
-
-public:
-  decoderFFVC1 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
-
-};
-
 class decoderFFV1:public decoderFF
 {
 protected:
@@ -257,24 +207,7 @@
   decoderFFV1 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
 
 };
-class decoderFFMJPEG:public decoderFF
-{
-protected:
 
-
-public:
-  decoderFFMJPEG (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
-
-};
-class decoderSnow:public decoderFF
-{
-protected:
-
-
-public:
-  decoderSnow (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
-
-};
 class decoderFFcyuv:public decoderFF
 {
 protected:
@@ -303,15 +236,6 @@
 
 };
 
-class decoderFFCinepak:public decoderFF
-{
-protected:
-
-
-public:
-  decoderFFCinepak (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
-
-};
 class decoderFFCRAM:public decoderFF
 {
 protected:
@@ -321,48 +245,6 @@
   decoderFFCRAM (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
 
 };
-class decoderFFVP6F:public decoderFF
-{
-protected:
-public:
-  decoderFFVP6F (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
-};
-class decoderFFVP6A:public decoderFF
-{
-protected:
-public:
-  decoderFFVP6A (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
-};
-class decoderFFFLV1:public decoderFF
-{
-protected:
-public:
-  decoderFFFLV1 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
-};
-class decoderFFDVBSub:public decoderFF
-{
-protected:
-public:
-  decoderFFDVBSub (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
-};
-class decoderFFAMV:public decoderFF
-{
-protected:
-public:
-  decoderFFAMV (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
-};
-class decoderFFMjpegB:public decoderFF
-{
-protected:
-public:
-  decoderFFMjpegB (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
-};
-class decoderFFSVQ1:public decoderFF
-{
-protected:
-public:
-  decoderFFSVQ1 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
-};
 
 #ifdef USE_VDPAU
 class decoderFFVDPAU:public decoderFF
@@ -398,5 +280,6 @@
 };
 
 #endif
+#endif
 // EOF
 

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_codecFFsimple.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_codecFFsimple.cpp	2010-01-10 18:09:02 UTC (rev 5836)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_codecFFsimple.cpp	2010-01-10 18:09:07 UTC (rev 5837)
@@ -0,0 +1,112 @@
+/***************************************************************************
+    \file ADM_codecFFSimple.cpp
+    \brief Simple decoder class
+    \author mean fixounet at free.fr (c) 2010
+
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "ADM_codecFFsimple.h"
+#include "fourcc.h"
+#include "DIA_coreToolkit.h"
+typedef struct
+{
+    const char *string;
+    CodecID    codecId;
+    bool       extraData;
+}ffVideoCodec;
+
+const ffVideoCodec ffCodec[]=
+{
+
+  {"SNOW",  CODEC_ID_SNOW,      false},
+  {"cvid",  CODEC_ID_CINEPAK,   false},
+  // ?{,CODEC_ID_MSVIDEO1},
+  {"VP6F",  CODEC_ID_VP6F,      false},
+  {"VP6A",  CODEC_ID_VP6A,      false},
+  {"SVQ1",  CODEC_ID_SVQ1,      false},
+  {"FLV1",  CODEC_ID_FLV1,      false},
+  {"AMV",   CODEC_ID_AMV,       false},
+  {"MJPG",  CODEC_ID_MJPEG,     false},
+  {"mjpa",  CODEC_ID_MJPEG,     false},
+  {"MJPB",  CODEC_ID_MJPEGB,    false},
+
+  {"WMV2", CODEC_ID_WMV2,       true},
+  {"WMV1", CODEC_ID_WMV1,       true},
+  {"WMV3", CODEC_ID_WMV3,       true},
+  {"WVC1", CODEC_ID_VC1,        true},
+  {"WMVA", CODEC_ID_VC1,        true},
+
+  {"WMVA", CODEC_ID_DVVIDEO,        true},
+
+  //{"MJPB", CODEC_ID_CYUV,       true},
+ // {"MJPB", CODEC_ID_THEORA),    true}
+
+};
+/**
+    \fn getCodecIdFromFourcc
+*/
+static const ffVideoCodec *getCodecIdFromFourcc(uint32_t fcc)
+{
+    uint32_t n=sizeof(ffCodec)/sizeof(ffVideoCodec);
+    for(int i=0;i<n;i++)
+    {
+        const ffVideoCodec *c=ffCodec+i;
+        if(fourCC::check(fcc,(const uint8_t*)c->string))
+            return c;
+    }
+    return NULL;
+}
+
+/**
+    \fn decoderFFSimple
+*/
+decoderFFSimple::decoderFFSimple (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp)
+        : decoderFF(w,h,fcc,extraDataLen,extraData,bpp)
+{
+    const ffVideoCodec *c=getCodecIdFromFourcc(fcc);
+    ADM_assert(c);
+    CodecID id=c->codecId;
+    ADM_assert(id!=CODEC_ID_NONE);
+    if(true==c->extraData)
+    {
+         _context->extradata = (uint8_t *) extraData;
+         _context->extradata_size = (int) extraDataLen;
+    }
+    AVCodec *codec=avcodec_find_decoder(id);
+    if(!codec) {GUI_Error_HIG("Codec",QT_TR_NOOP("Internal error finding codec 0x%x"),fcc);ADM_assert(0);} 
+    codecId=id; 
+    _context->workaround_bugs=1*FF_BUG_AUTODETECT +0*FF_BUG_NO_PADDING; 
+    _context->error_concealment=3; \
+    if (avcodec_open(_context, codec) < 0)  
+                      { 
+                            printf("[lavc] Decoder init: %x video decoder failed!\n",fcc); 
+                            GUI_Error_HIG("Codec","Internal error opening 0x%x",fcc); 
+                            ADM_assert(0); 
+                    } 
+                    else 
+                    { 
+                            printf("[lavc] Decoder init: %x video decoder initialized! (%s)\n",fcc,codec->long_name); 
+                    } 
+}
+/**
+    \fn admCreateFFSimple
+*/
+decoders *admCreateFFSimple(uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp)
+{
+    const ffVideoCodec *c=getCodecIdFromFourcc(fcc);
+    if(!c) return NULL;
+    CodecID id=c->codecId;
+    if(id==CODEC_ID_NONE) return NULL;
+    return new decoderFFSimple(w,h,fcc,extraDataLen,extraData,bpp);
+}
+
+// EOF
+

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_codecSearch.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_codecSearch.cpp	2010-01-10 18:09:02 UTC (rev 5836)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_codecSearch.cpp	2010-01-10 18:09:07 UTC (rev 5837)
@@ -35,7 +35,7 @@
 #include "ADM_png.h"
 #include "ADM_codecEmpty.h"
 #include "ADM_ffmp43.h"
-
+#include "ADM_codecFFsimple.h"
 #include "avidemutils.h"
 #include "fourcc.h"
 
@@ -66,10 +66,7 @@
 
       return (decoders *) (new decoderFFMP42 (w,h,fcc,extraLen,extraData,bpp));
     }
-    if (fourCC::check (fcc, (uint8_t *) "FLV1"))
-    {
-      return (decoders *) (new decoderFFFLV1 (w,h,fcc,extraLen,extraData,bpp));
-    }
+  
   if (fourCC::check (fcc, (uint8_t *) "H263"))
     {
 
@@ -85,22 +82,12 @@
 
       return (decoders *) (new decoderPng (w,h,fcc,extraLen,extraData,bpp));
     }
- if (fourCC::check (fcc, (uint8_t *) "cvid"))
-    {
-
-      return (decoders *) (new decoderFFCinepak (w,h,fcc,extraLen,extraData,bpp));
-    }
   if (fourCC::check (fcc, (uint8_t *) "FFVH"))
     {
 
       return (decoders *) (new decoderFF_ffhuff (w,h,fcc,extraLen,extraData,bpp));
     }
-if (fourCC::check (fcc, (uint8_t *) "SVQ1"))
-    {
 
-      return (decoders *) (new decoderFFSVQ1 (w,h,fcc,extraLen,extraData,bpp));
-    }
-
   if (fourCC::check (fcc, (uint8_t *) "SVQ3"))
     {
 
@@ -117,39 +104,13 @@
 
       return (decoders *) (new decoderFFCRAM (w,h,fcc,extraLen,extraData,bpp));
     }
-  if (fourCC::check (fcc, (uint8_t *) "WMV2"))
-    {
+ 
 
-      return (decoders *) (new decoderFFWMV2 (w,h,fcc,extraLen,extraData,bpp));
-    }
-    if (fourCC::check (fcc, (uint8_t *) "WMV1"))
-    {
-
-      return (decoders *) (new decoderFFWMV1 (w,h,fcc,extraLen,extraData,bpp));
-    }
-
-  if (fourCC::check (fcc, (uint8_t *) "WMV3") )
-    {
-
-      return (decoders *) (new decoderFFWMV3 (w,h,fcc,extraLen,extraData,bpp));
-    }
-
-    if (fourCC::check (fcc, (uint8_t *) "WVC1")|| fourCC::check (fcc, (uint8_t *) "WMVA"))
-    {
-
-      return (decoders *) (new decoderFFVC1 (w,h,fcc,extraLen,extraData,bpp));
-    }
-
 if (fourCC::check (fcc, (uint8_t *) "FFV1"))
     {
 
       return (decoders *) (new decoderFFV1 (w,h,fcc,extraLen,extraData,bpp));
     }
-  if (fourCC::check (fcc, (uint8_t *) "SNOW"))
-    {
-
-      return (decoders *) (new decoderSnow (w,h,fcc,extraLen,extraData,bpp));
-    }
   if (isH264Compatible (fcc))
     {
 #if defined(USE_VDPAU) && 0
@@ -170,21 +131,7 @@
   if (isMpeg4Compatible (fcc) == 1)
     {
       return (decoders *) (new decoderFFMpeg4 (w,h,fcc,extraLen,extraData,bpp));
-      //    return(decoders *)( new decoderXvid(w,h));
-      //    return(decoders *)( new decoderDIVX(w,h));
     }
-
-  if (fourCC::check (fcc, (uint8_t *) "MJPB"))
-    {
-      printf ("\n using FF mjpeg codec\n");
-      return (decoders *) (new decoderFFMjpegB (w,h,fcc,extraLen,extraData,bpp));
-    }
-if (fourCC::check (fcc, (uint8_t *) "MJPG")
-      || fourCC::check (fcc, (uint8_t *) "mjpa"))
-    {
-      printf ("\n using FF mjpeg codec\n");
-      return (decoders *) (new decoderFFMJPEG (w,h,fcc,extraLen,extraData,bpp));
-    }
   if (fourCC::check (fcc, (uint8_t *) "YV12")
       || fourCC::check (fcc, (uint8_t *) "yv12")
       || fourCC::check (fcc, (uint8_t *) "I420"))
@@ -201,25 +148,7 @@
     {
       printf ("\n using YUY2 codec\n");
       return (decoders *) (new decoderYUY2 (w,h,fcc,extraLen,extraData,bpp));
-    }
-  if (fourCC::check (fcc, (uint8_t *) "AMV "))
-    {
-      printf ("\n using AMV codec\n");
-      return (decoders *) (new decoderFFAMV (w,h,fcc,extraLen,extraData,bpp));
-    }
-
- if (fourCC::check (fcc, (uint8_t *) "VP6A"))
-    {
-      printf ("\n using YUY2 codec\n");
-      return (decoders *) (new decoderFFVP6A (w,h,fcc,extraLen,extraData,bpp));
-    }
-  if (isVP6Compatible(fcc))
-    {
-      printf ("\n using VP6F codec\n");
-      return (decoders *) (new decoderFFVP6F (w,h,fcc,extraLen,extraData,bpp));
-    }
-
-
+    } 
   if ((fcc == 0) || fourCC::check (fcc, (uint8_t *) "RGB "))
     {
       // RGB 16 Codecs
@@ -237,6 +166,14 @@
   if (isMpeg12Compatible (fcc))
 	  return (decoders *) (new decoderFFMpeg12 (w,h,fcc,extraLen,extraData,bpp));
 
+    // Search ffsimple
+    decoders *dec=admCreateFFSimple(w,h,fcc,extraLen,extraData,bpp);
+    if(dec)
+    {
+        printf("using ffSimple\n");
+        return dec;
+    }
+
   // default : null decoder
   printf ("\n using invalid codec for \n");
   fourCC::print (fcc);

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_ffmp43.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_ffmp43.cpp	2010-01-10 18:09:02 UTC (rev 5836)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_ffmp43.cpp	2010-01-10 18:09:07 UTC (rev 5837)
@@ -636,171 +636,13 @@
   _context->bits_per_coded_sample = bpp;
   WRAP_Open (CODEC_ID_HUFFYUV);
 }
-decoderFFWMV2::decoderFFWMV2 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
-decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
-{
-  _context->extradata = (uint8_t *) extraData;
-  _context->extradata_size = (int) extraDataLen;
-
-  WRAP_Open (CODEC_ID_WMV2);
-
-}
-decoderFFWMV1::decoderFFWMV1 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
-decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
-{
-  _context->extradata = (uint8_t *) extraData;
-  _context->extradata_size = (int) extraDataLen;
-
-  WRAP_Open (CODEC_ID_WMV1);
-
-}
-
-decoderFFWMV3::decoderFFWMV3 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
-decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
-{
-  _context->extradata = (uint8_t *) extraData;
-  _context->extradata_size = (int) extraDataLen;
-
-  WRAP_Open (CODEC_ID_WMV3);
-
-}
-
-decoderFFVC1::decoderFFVC1(uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp) : 
-decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
-{
-  _context->extradata = (uint8_t *) extraData;
-  _context->extradata_size = (int) extraDataLen;
-
-  WRAP_Open (CODEC_ID_VC1);
-}
-
-decoderFFcyuv::decoderFFcyuv (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
-decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
-
-{
-  _context->extradata = (uint8_t *) extraData;
-  _context->extradata_size = (int) extraDataLen;
-
-  WRAP_Open (CODEC_ID_CYUV);
-}
-decoderFFMJPEG::decoderFFMJPEG (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
-decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
-{
-  WRAP_Open (CODEC_ID_MJPEG);
-}
-decoderFFTheora::decoderFFTheora (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp)
-:decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
-{
-  _context->extradata = (uint8_t *) extraData;
-  _context->extradata_size = (int) extraDataLen;
-  WRAP_Open (CODEC_ID_THEORA);
-}
-decoderSnow::decoderSnow (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp)
-:decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
-{
-  WRAP_Open (CODEC_ID_SNOW);
-}
-//*************
 decoderCamtasia::decoderCamtasia (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp)
 :decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
 {
   _context->bits_per_coded_sample = bpp;
   WRAP_Open (CODEC_ID_TSCC);
 }
-//*************
-decoderFFCinepak::decoderFFCinepak (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
-decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
-{
-  WRAP_Open (CODEC_ID_CINEPAK);
-}
-//*************
-decoderFFCRAM::decoderFFCRAM (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
-decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
-{
-  WRAP_Open (CODEC_ID_MSVIDEO1);
-}
-//*************
-decoderFFVP6F::decoderFFVP6F (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
-decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
-{
-  WRAP_Open (CODEC_ID_VP6F);
-}
-//*************
-decoderFFVP6A::decoderFFVP6A (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
-decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
-{
-  WRAP_Open (CODEC_ID_VP6A);
-}
 
-//*************
-decoderFFSVQ1::decoderFFSVQ1 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
-decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
-{
-  WRAP_Open (CODEC_ID_SVQ1);
-}
-
-//************
-decoderFFFLV1::decoderFFFLV1 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
-decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
-{
-  WRAP_Open (CODEC_ID_FLV1);
-}
-decoderFFAMV::decoderFFAMV (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
-decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
-{
-  WRAP_Open (CODEC_ID_AMV);
-  //_context->codec_id=CODEC_ID_AMV;
-}
-decoderFFMjpegB::decoderFFMjpegB (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
-decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
-{
-  WRAP_Open (CODEC_ID_MJPEGB);
-  //_context->codec_id=CODEC_ID_AMV;
-}
-#if 0
-decoderFFDVBSub::decoderFFDVBSub (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):decoderFF (w,	   h)
-{
-  _context->sub_id=1;
-  WRAP_Open (CODEC_ID_DVB_SUBTITLE);
-}
-//*********************
-/**
-    \fn decoderFFSubs
-    \brief Constructor for DVB subtitles...
-*/
-
-decoderFFSubs::decoderFFSubs (uint32_t subid)
-{
-  _context = avcodec_alloc_context ();
-  codecId= CODEC_ID_DVB_SUBTITLE;
-  subId=subid;
-  _context->sub_id=subId;
-  WRAP_Open (CODEC_ID_DVB_SUBTITLE);
-}
-decoderFFSubs:: ~ decoderFFSubs ()
-{
-  avcodec_close (_context);
-  ADM_dealloc (_context);
-  _context=NULL;
-  
-}
-
-uint8_t decoderFFSubs::uncompress (ADMCompressedImage * in, AVSubtitle * out)
-{
-  int ret=0;
-  int got_picture=0;
-  ret=avcodec_decode_subtitle(_context, out,
-                            &got_picture,
-                            in->data, in->dataLength); 
-     if(ret<0) 
-     {
-        printf("[lavc] FFSUB Error %d\n",ret);
-        return 0; 
-     }
-     return 1;
-}
-
-#endif
 //***************
 extern uint8_t  lavformat_init(void);
 extern void     avcodec_init(void );

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/CMakeLists.txt	2010-01-10 18:09:02 UTC (rev 5836)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/CMakeLists.txt	2010-01-10 18:09:07 UTC (rev 5837)
@@ -2,6 +2,7 @@
 ADM_codecs.cpp
 ADM_png.cpp
 ADM_ffmp43.cpp
+ADM_codecFFsimple.cpp
 ADM_rgb16.cpp
 ADM_uyvy.cpp
 ADM_ffmpeg_vdpau.cpp



From mean at mail.berlios.de  Sun Jan 10 19:09:17 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 10 Jan 2010 19:09:17 +0100
Subject: [Avidemux-svn-commit] r5838 - in
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec:
	include src
Message-ID: <201001101809.o0AI9H4m013669@sheep.berlios.de>

Author: mean
Date: 2010-01-10 19:09:17 +0100 (Sun, 10 Jan 2010)
New Revision: 5838

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_ffmp43.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_codecFFsimple.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_codecSearch.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_codecs.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_ffmp43.cpp
Log:
[Codec] Factorize most codec through FFsimple

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_ffmp43.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_ffmp43.h	2010-01-10 18:09:07 UTC (rev 5837)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_ffmp43.h	2010-01-10 18:09:17 UTC (rev 5838)
@@ -68,39 +68,13 @@
 class decoderFFDiv3:public decoderFF
 {
 protected:
-
-
 public:
-
   decoderFFDiv3 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
-
 };
-#if 0
-class decoderFFMpeg4VopPacked:public decoderFF
-{
-protected:
 
-
-public:
-  decoderFFMpeg4VopPacked (uint32_t w, uint32_t h);
-  uint8_t uncompress (ADMCompressedImage * in, ADMImage * out);
-  // mpeg4 can have B-frame
-  virtual uint8_t bFramePossible (void)
-  {
-    return 0;
-  }
-  // Vop packed are not indexable
-  virtual uint8_t isIndexable (void)
-  {
-    return 0;
-  };
-};
-#endif
 class decoderFFMpeg4:public decoderFF
 {
 protected:
-
-
 public:
         decoderFFMpeg4 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
   bool uncompress (ADMCompressedImage * in, ADMImage * out);
@@ -109,13 +83,10 @@
   {
     return 1;
   }
-
 };
 class decoderFFMpeg12:public decoderFF
 {
 protected:
-
-
 public:
   decoderFFMpeg12 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
   // mpeg1/2 can have B-frame
@@ -125,52 +96,18 @@
   }
 
 };
-class decoderFFSVQ3:public decoderFF
-{
-protected:
 
-
-public:
-  decoderFFSVQ3 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
-  virtual bool bFramePossible (void)
-  {
-    return 0;
-  }
-
-};
-
 class decoderFFDV:public decoderFF
 {
 protected:
-
-
 public:
   decoderFFDV (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
-
 };
-class decoderFFMP42:public decoderFF
-{
-protected:
 
-
-public:
-  decoderFFMP42 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
-
-};
-class decoderFFH263:public decoderFF
-{
-protected:
-
-
-public:
-  decoderFFH263 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
-
-};
 class decoderFFH264:public decoderFF
 {
 protected:
   uint32_t _lowDelay;
-
 public:
   decoderFFH264 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
   virtual bool bFramePossible (void)
@@ -178,74 +115,23 @@
       return _lowDelay;
   }
   bool   uncompress (ADMCompressedImage * in, ADMImage * out);
-
 };
+
 class decoderFFhuff:public decoderFF
 {
 protected:
-
-
 public:
   decoderFFhuff (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
-
 };
+
 class decoderFF_ffhuff:public decoderFF
 {
 protected:
-
-
 public:
   decoderFF_ffhuff (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
-
 };
-class decoderFFV1:public decoderFF
-{
-protected:
 
 
-public:
-  decoderFFV1 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
-
-};
-
-class decoderFFcyuv:public decoderFF
-{
-protected:
-
-
-public:
-  decoderFFcyuv (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
-
-};
-class decoderCamtasia:public decoderFF
-{
-protected:
-
-
-public:
-  decoderCamtasia (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
-
-};
-class decoderFFTheora:public decoderFF
-{
-protected:
-
-
-public:
-  decoderFFTheora (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
-
-};
-
-class decoderFFCRAM:public decoderFF
-{
-protected:
-
-
-public:
-  decoderFFCRAM (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
-
-};
-
 #ifdef USE_VDPAU
 class decoderFFVDPAU:public decoderFF
 {
@@ -276,7 +162,6 @@
       {
         return 1;
       }
-
 };
 
 #endif

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_codecFFsimple.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_codecFFsimple.cpp	2010-01-10 18:09:07 UTC (rev 5837)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_codecFFsimple.cpp	2010-01-10 18:09:17 UTC (rev 5838)
@@ -21,30 +21,39 @@
     const char *string;
     CodecID    codecId;
     bool       extraData;
+    bool       refCopy;
 }ffVideoCodec;
 
 const ffVideoCodec ffCodec[]=
 {
 
-  {"SNOW",  CODEC_ID_SNOW,      false},
-  {"cvid",  CODEC_ID_CINEPAK,   false},
-  // ?{,CODEC_ID_MSVIDEO1},
-  {"VP6F",  CODEC_ID_VP6F,      false},
-  {"VP6A",  CODEC_ID_VP6A,      false},
-  {"SVQ1",  CODEC_ID_SVQ1,      false},
-  {"FLV1",  CODEC_ID_FLV1,      false},
-  {"AMV",   CODEC_ID_AMV,       false},
-  {"MJPG",  CODEC_ID_MJPEG,     false},
-  {"mjpa",  CODEC_ID_MJPEG,     false},
-  {"MJPB",  CODEC_ID_MJPEGB,    false},
+  {"SNOW",  CODEC_ID_SNOW,      false, false},
+  {"cvid",  CODEC_ID_CINEPAK,   false, false},
+  {"CRAM",  CODEC_ID_MSVIDEO1,  false, false},
+  {"VP6F",  CODEC_ID_VP6F,      false, false},
+  {"VP6A",  CODEC_ID_VP6A,      false, false},
+  {"SVQ1",  CODEC_ID_SVQ1,      false, false},
+  {"FLV1",  CODEC_ID_FLV1,      false, false},
+  {"AMV",   CODEC_ID_AMV,       false, false},
+  {"MJPG",  CODEC_ID_MJPEG,     false, false},
+  {"mjpa",  CODEC_ID_MJPEG,     false, false},
+  {"MJPB",  CODEC_ID_MJPEGB,    false, false},
+  {"FPS1",  CODEC_ID_FRAPS,     false, false},
+  {"cvid",  CODEC_ID_CINEPAK,   false, false},
+// Need extradata
+  {"WMV2", CODEC_ID_WMV2,       true, false},
+  {"WMV1", CODEC_ID_WMV1,       true, false},
+  {"WMV3", CODEC_ID_WMV3,       true, false},
+  {"WVC1", CODEC_ID_VC1,        true, false},
+  {"WMVA", CODEC_ID_VC1,        true, false},
 
-  {"WMV2", CODEC_ID_WMV2,       true},
-  {"WMV1", CODEC_ID_WMV1,       true},
-  {"WMV3", CODEC_ID_WMV3,       true},
-  {"WVC1", CODEC_ID_VC1,        true},
-  {"WMVA", CODEC_ID_VC1,        true},
+  {"WMVA", CODEC_ID_DVVIDEO,    true, false},
+// RefCopy
+  {"FFV1", CODEC_ID_FFV1,       true, true},
+  {"H263", CODEC_ID_H263,       false, true},
+  {"MP42", CODEC_ID_MSMPEG4V2,  true, true},
+  {"SVQ3", CODEC_ID_SVQ3,       true, true},
 
-  {"WMVA", CODEC_ID_DVVIDEO,        true},
 
   //{"MJPB", CODEC_ID_CYUV,       true},
  // {"MJPB", CODEC_ID_THEORA),    true}
@@ -80,6 +89,9 @@
          _context->extradata = (uint8_t *) extraData;
          _context->extradata_size = (int) extraDataLen;
     }
+    if(true==c->refCopy)
+        _refCopy=1;
+
     AVCodec *codec=avcodec_find_decoder(id);
     if(!codec) {GUI_Error_HIG("Codec",QT_TR_NOOP("Internal error finding codec 0x%x"),fcc);ADM_assert(0);} 
     codecId=id; 

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_codecSearch.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_codecSearch.cpp	2010-01-10 18:09:07 UTC (rev 5837)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_codecSearch.cpp	2010-01-10 18:09:17 UTC (rev 5838)
@@ -52,65 +52,27 @@
   ADM_info("Searching decoder (%d x %d, extradataSize:%d)...\n",w,h,extraLen);
   if (isMSMpeg4Compatible (fcc) == 1)
     {
-      // For div3, no problem we take ffmpeg
-
       return (decoders *) (new decoderFFDiv3 (w,h,fcc,extraLen,extraData,bpp));
     }
   if (isDVCompatible(fcc))//"CDVC"))
     {
-
       return (decoders *) (new decoderFFDV (w,h,fcc,extraLen,extraData,bpp));
     }
-  if (fourCC::check (fcc, (uint8_t *) "MP42"))
-    {
-
-      return (decoders *) (new decoderFFMP42 (w,h,fcc,extraLen,extraData,bpp));
-    }
-  
-  if (fourCC::check (fcc, (uint8_t *) "H263"))
-    {
-
-      return (decoders *) (new decoderFFH263 (w,h,fcc,extraLen,extraData,bpp));
-    }
+ 
   if (fourCC::check (fcc, (uint8_t *) "HFYU"))
     {
-
       return (decoders *) (new decoderFFhuff (w,h,fcc,extraLen,extraData,bpp));
     }
   if (fourCC::check (fcc, (uint8_t *) "PNG "))
     {
-
       return (decoders *) (new decoderPng (w,h,fcc,extraLen,extraData,bpp));
     }
   if (fourCC::check (fcc, (uint8_t *) "FFVH"))
     {
-
       return (decoders *) (new decoderFF_ffhuff (w,h,fcc,extraLen,extraData,bpp));
     }
-
-  if (fourCC::check (fcc, (uint8_t *) "SVQ3"))
-    {
-
-      return (decoders *) (new decoderFFSVQ3 (w,h,fcc,extraLen,extraData,bpp));
-    }
-  if (fourCC::check (fcc, (uint8_t *) "tscc"))
-    {
-
-      return (decoders *) (new decoderCamtasia (w,h,fcc,extraLen,extraData,bpp));
-    }
-
-     if (fourCC::check (fcc, (uint8_t *) "CRAM"))
-    {
-
-      return (decoders *) (new decoderFFCRAM (w,h,fcc,extraLen,extraData,bpp));
-    }
  
 
-if (fourCC::check (fcc, (uint8_t *) "FFV1"))
-    {
-
-      return (decoders *) (new decoderFFV1 (w,h,fcc,extraLen,extraData,bpp));
-    }
   if (isH264Compatible (fcc))
     {
 #if defined(USE_VDPAU) && 0

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_codecs.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_codecs.cpp	2010-01-10 18:09:07 UTC (rev 5837)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_codecs.cpp	2010-01-10 18:09:17 UTC (rev 5838)
@@ -28,14 +28,4 @@
   UNUSED_ARG (out);
   return false;
 }
-
-#if 0
-uint8_t coders::compress (ADMImage * in, ADMBitstream * out)
-{
-  UNUSED_ARG (in);
-  UNUSED_ARG (out);
-
-  return 0;
-}
-#endif
 //EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_ffmp43.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_ffmp43.cpp	2010-01-10 18:09:07 UTC (rev 5837)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_ffmp43.cpp	2010-01-10 18:09:17 UTC (rev 5838)
@@ -473,45 +473,21 @@
 
   return 1;
 }
+// *******************************************************************
+// *******************************************************************
+// *******************************************************************
 
-#define LOWDELAY() {} //_context->flags |= CODEC_FLAG_LOW_DELAY
-
-
 decoderFFDiv3::decoderFFDiv3 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
 decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
 {
   _refCopy = 1;			// YUV420 only
   WRAP_Open (CODEC_ID_MSMPEG4V3);
 }
-//**************************************************
-#if 0
-decoderFFMpeg4VopPacked::decoderFFMpeg4VopPacked (uint32_t w, uint32_t h):decoderFF (w,
-	   h)
-{
-/* In that case, we cannot use lowdelay...*/
-  _refCopy = 1;			// YUV420 only
-  _allowNull = 1;
-  decoderMultiThread ();
-  WRAP_Open (CODEC_ID_MPEG4);
-  printf("[lavc] Non low delay mpeg4 decoder initialized\n");
-}
-uint8_t decoderFFMpeg4VopPacked::uncompress (ADMCompressedImage * in, ADMImage * out)
-{
-    // For pseudo startcode
-    if(in->dataLength)
-    {
-        in->data[in->dataLength]=0;
-        in->data[in->dataLength+1]=0;
-    }
-    return decoderFF::uncompress(in,out);
 
-}
-#endif
 decoderFFMpeg4::decoderFFMpeg4 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
 decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
 {
 // force low delay as avidemux don't handle B-frames
-  LOWDELAY();
   ADM_info ("[lavc] Using %d bytes of extradata for MPEG4 decoder\n", (int)extraDataLen);
   
   _refCopy = 1;			// YUV420 only
@@ -543,48 +519,14 @@
   WRAP_Open (CODEC_ID_DVVIDEO);
 
 }
-decoderFFMP42::decoderFFMP42 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
-                decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
-{
-  _refCopy = 1;			// YUV420 only
-  WRAP_Open (CODEC_ID_MSMPEG4V2);
-
-}
 decoderFFMpeg12::decoderFFMpeg12 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
                 decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
 {
-  int
-    got_picture = 0;
-  LOWDELAY();
   _refCopy = 1;			// YUV420 only
   decoderMultiThread ();
   WRAP_Open (CODEC_ID_MPEG2VIDEO);
 }
-decoderFFSVQ3::decoderFFSVQ3 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp)
-        :decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
-{
-  int
-    got_picture = 0;
 
-  LOWDELAY();
-  _context->extradata = (uint8_t *) extraData;
-  _context->extradata_size = (int) extraDataLen;
-  WRAP_Open (CODEC_ID_SVQ3);
-}
-
-decoderFFH263::decoderFFH263 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp)
-            :decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
-{
-  _refCopy = 1;			// YUV420 only
-  WRAP_Open (CODEC_ID_H263);
-
-}
-decoderFFV1::decoderFFV1 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp)
-            :decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
-{
-  _refCopy = 1;			// YUV420 only
-  WRAP_Open (CODEC_ID_FFV1);
-}
 decoderFF_ffhuff::decoderFF_ffhuff (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp)
 :decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
 {
@@ -636,12 +578,6 @@
   _context->bits_per_coded_sample = bpp;
   WRAP_Open (CODEC_ID_HUFFYUV);
 }
-decoderCamtasia::decoderCamtasia (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp)
-:decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
-{
-  _context->bits_per_coded_sample = bpp;
-  WRAP_Open (CODEC_ID_TSCC);
-}
 
 //***************
 extern uint8_t  lavformat_init(void);



From mean at mail.berlios.de  Mon Jan 11 07:16:48 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Mon, 11 Jan 2010 07:16:48 +0100
Subject: [Avidemux-svn-commit] r5839 -
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src
Message-ID: <201001110616.o0B6GmjZ017994@sheep.berlios.de>

Author: mean
Date: 2010-01-11 07:16:45 +0100 (Mon, 11 Jan 2010)
New Revision: 5839

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/CMakeLists.txt
Log:
[coreVideoCodec] Add lib dependancies for link on win32

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/CMakeLists.txt	2010-01-10 18:09:17 UTC (rev 5838)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/CMakeLists.txt	2010-01-11 06:16:45 UTC (rev 5839)
@@ -12,6 +12,15 @@
 
 ADD_LIBRARY(ADM_coreVideoCodec6 SHARED ${ADM_codecs_SRCS})
 ADD_SOURCE_CFLAGS(ADM_png.cpp ${PNG_CFLAGS})
+TARGET_LINK_LIBRARIES(ADM_coreVideoCodec6 
+                                          ADM_core6
+                                          ADM_coreImage6 
+                                          ADM_coreUI6
+                                          ADM_coreUtils6
+                                          ADM_libavcodec6
+                                          ADM_libavformat6
+                                          ADM_libavutil6
+)
 ADM_INSTALL_LIB(ADM_coreVideoCodec6)
 
 REMOVE_DEFINITIONS(-DHAVE_CONFIG_H)



From mean at mail.berlios.de  Mon Jan 11 07:31:33 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Mon, 11 Jan 2010 07:31:33 +0100
Subject: [Avidemux-svn-commit] r5840 -
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src
Message-ID: <201001110631.o0B6VXi9001343@sheep.berlios.de>

Author: mean
Date: 2010-01-11 07:31:32 +0100 (Mon, 11 Jan 2010)
New Revision: 5840

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/CMakeLists.txt
Log:
[coreVideoCodec] More lib dependancies

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/CMakeLists.txt	2010-01-11 06:16:45 UTC (rev 5839)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/CMakeLists.txt	2010-01-11 06:31:32 UTC (rev 5840)
@@ -19,8 +19,8 @@
                                           ADM_coreUtils6
                                           ADM_libavcodec6
                                           ADM_libavformat6
-                                          ADM_libavutil6
-)
+                                          ADM_libavutil6)
+TARGET_LINK_LIBRARIES(ADM_coreVideoCodec6 ${PNG_LIBRARIES})
 ADM_INSTALL_LIB(ADM_coreVideoCodec6)
 
 REMOVE_DEFINITIONS(-DHAVE_CONFIG_H)



From mean at mail.berlios.de  Mon Jan 11 07:31:36 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Mon, 11 Jan 2010 07:31:36 +0100
Subject: [Avidemux-svn-commit] r5841 - in branches/avidemux_2.6_branch_mean:
	avidemux/common/ADM_commonUI avidemux_core/ADM_coreVideoCodec/src
Message-ID: <201001110631.o0B6Va6W001409@sheep.berlios.de>

Author: mean
Date: 2010-01-11 07:31:35 +0100 (Mon, 11 Jan 2010)
New Revision: 5841

Added:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/DIA_lavDecoder.cpp
Removed:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/DIA_lavDecoder.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/CMakeLists.txt
Log:
[coreVideo] Move configuration to codec itself

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/CMakeLists.txt	2010-01-11 06:31:32 UTC (rev 5840)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/CMakeLists.txt	2010-01-11 06:31:35 UTC (rev 5841)
@@ -10,7 +10,6 @@
 DIA_prefs.cpp     
 DIA_SVCD.cpp       
 DIA_builtin.cpp       
-DIA_lavDecoder.cpp  
 DIA_requant.cpp   
 #DIA_ocr.cpp             
 #DIA_tsSub.cpp        

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/DIA_lavDecoder.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/DIA_lavDecoder.cpp	2010-01-11 06:31:32 UTC (rev 5840)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/DIA_lavDecoder.cpp	2010-01-11 06:31:35 UTC (rev 5841)
@@ -1,36 +0,0 @@
-//
-// C++ Implementation: ADM_vidForcedPP
-//
-// Description: 
-//
-//	Force postprocessing assuming constant quant & image type
-//	Uselefull on some badly authored DVD for example
-//
-// Author: mean <fixounet at free.fr>, (C) 2004
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-
-#include "config.h"
-#include "ADM_default.h"
-#include "DIA_factory.h"
-
-/**
-      \fn DIA_lavDecoder
-      \brief Dialog for lavcodec *DECODER* option
-*/
-uint8_t DIA_lavDecoder(uint32_t *swapUv, uint32_t *showU)
-{
-int ret=0;	
-         
-         diaElemToggle    swap(swapUv,QT_TR_NOOP("_Swap U and V"));
-         diaElemToggle    show(showU,QT_TR_NOOP("Show motion _vectors"));
-         diaElem *tabs[]={&swap,&show};
-        if( diaFactoryRun(QT_TR_NOOP("Decoder Options"),2,tabs))
-	{
-          return 1;
-        }
-         return 0;
-}
-// EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/CMakeLists.txt	2010-01-11 06:31:32 UTC (rev 5840)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/CMakeLists.txt	2010-01-11 06:31:35 UTC (rev 5841)
@@ -8,6 +8,7 @@
 ADM_ffmpeg_vdpau.cpp
 ADM_png.cpp
 ADM_codecSearch.cpp
+DIA_lavDecoder.cpp
 )
 
 ADD_LIBRARY(ADM_coreVideoCodec6 SHARED ${ADM_codecs_SRCS})

Copied: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/DIA_lavDecoder.cpp (from rev 5840, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/DIA_lavDecoder.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/DIA_lavDecoder.cpp	2010-01-11 06:31:32 UTC (rev 5840)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/DIA_lavDecoder.cpp	2010-01-11 06:31:35 UTC (rev 5841)
@@ -0,0 +1,35 @@
+//
+// C++ Implementation: ADM_vidForcedPP
+//
+// Description: 
+//
+//	Force postprocessing assuming constant quant & image type
+//	Uselefull on some badly authored DVD for example
+//
+// Author: mean <fixounet at free.fr>, (C) 2004
+//
+// Copyright: See COPYING file that comes with this distribution
+//
+//
+
+#include "ADM_default.h"
+#include "DIA_factory.h"
+#define QT_TR_NOOP(x) x
+/**
+      \fn DIA_lavDecoder
+      \brief Dialog for lavcodec *DECODER* option
+*/
+uint8_t DIA_lavDecoder(uint32_t *swapUv, uint32_t *showU)
+{
+int ret=0;	
+         
+         diaElemToggle    swap(swapUv,QT_TR_NOOP("_Swap U and V"));
+         diaElemToggle    show(showU,QT_TR_NOOP("Show motion _vectors"));
+         diaElem *tabs[]={&swap,&show};
+        if( diaFactoryRun(QT_TR_NOOP("Decoder Options"),2,tabs))
+	{
+          return 1;
+        }
+         return 0;
+}
+// EOF



From mean at mail.berlios.de  Mon Jan 11 20:09:34 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Mon, 11 Jan 2010 20:09:34 +0100
Subject: [Avidemux-svn-commit] r5842 - in branches/avidemux_2.6_branch_mean:
	avidemux avidemux/common avidemux/common/ADM_editor
	avidemux/common/ADM_videoCodec
	avidemux/common/ADM_videoCodec/include
	avidemux/common/ADM_videoCodec/src
	avidemux_core/ADM_coreVideoCodec/include
	avidemux_core/ADM_coreVideoCodec/src
Message-ID: <201001111909.o0BJ9YJa009345@sheep.berlios.de>

Author: mean
Date: 2010-01-11 20:09:33 +0100 (Mon, 11 Jan 2010)
New Revision: 5842

Added:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/include/
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/include/ADM_codecVdpau.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/include/ADM_ffmpeg_vdpau_internal.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src/
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src/ADM_ffmpeg_vdpau.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src/ADM_videoCodec.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src/CMakeLists.txt
Removed:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_ffmpeg_vdpau_internal.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_ffmpeg_vdpau.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_codec.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_ffmp43.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_codecSearch.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/CMakeLists.txt
Log:
[Codec] Allow codec override by application so that we can put back vdpau. Vdpau needs a X11 device so it cannot goes to coreVideoCodec. Plus it needs preference

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp	2010-01-11 06:31:35 UTC (rev 5841)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp	2010-01-11 19:09:33 UTC (rev 5842)
@@ -24,6 +24,7 @@
 #include "ADM_vidMisc.h"
 #include "ADM_audiocodec/ADM_audiocodec.h"
 #include "ADM_script/ADM_JSif.h"
+#include "ADM_codec.h"
 
 ADM_EditorSegment::ADM_EditorSegment(void)
 {
@@ -48,7 +49,7 @@
 
   ref->_aviheader->getVideoInfo (&info);
   ref->_aviheader->getExtraHeaderData (&l, &d);
-  ref->decoder = getDecoder (info.fcc,  info.width, info.height, l, d,info.bpp);
+  ref->decoder = ADM_getDecoder (info.fcc,  info.width, info.height, l, d,info.bpp);
   ref->_videoCache   =   new EditorCache(32,info.width,info.height) ;
 
   float frameD=info.fps1000;

Added: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/CMakeLists.txt	2010-01-11 06:31:35 UTC (rev 5841)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/CMakeLists.txt	2010-01-11 19:09:33 UTC (rev 5842)
@@ -0,0 +1 @@
+subdirs (src)

Added: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/include/ADM_codecVdpau.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/include/ADM_codecVdpau.h	2010-01-11 06:31:35 UTC (rev 5841)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/include/ADM_codecVdpau.h	2010-01-11 19:09:33 UTC (rev 5842)
@@ -0,0 +1,32 @@
+#ifdef USE_VDPAU
+class decoderFFVDPAU:public decoderFF
+{
+protected:
+                    int b_age;
+                    int ip_age[2];
+
+                    void     *vdpau;
+                    ADMImage *scratch;
+                    ADMImage *vdpau_copy;
+                    uint64_t vdpau_pts;
+                    bool     decode_status;
+                    bool     destroying;
+public:     // Callbacks
+                    int     getBuffer(AVCodecContext *avctx, AVFrame *pic);
+                    void    releaseBuffer(struct AVCodecContext *avctx, AVFrame *pic);
+                    void    goOn( const AVFrame *d,int type);            
+public:
+            // public API
+                    decoderFFVDPAU (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp);
+                    ~decoderFFVDPAU();
+    virtual bool uncompress (ADMCompressedImage * in, ADMImage * out);
+    virtual bool dontcopy (void)
+                      {
+                        return 0;
+                      }
+    virtual bool bFramePossible (void)
+      {
+        return 1;
+      }
+};
+#endif

Copied: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/include/ADM_ffmpeg_vdpau_internal.h (from rev 5841, branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_ffmpeg_vdpau_internal.h)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_ffmpeg_vdpau_internal.h	2010-01-11 06:31:35 UTC (rev 5841)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/include/ADM_ffmpeg_vdpau_internal.h	2010-01-11 19:09:33 UTC (rev 5842)
@@ -0,0 +1,82 @@
+/***************************************************************************
+            \file              ADM_ffmpeg_vdpau.cpp  
+            \brief Decoder using half ffmpeg/half VDPAU
+
+    The ffmpeg part is to preformat inputs for VDPAU
+    VDPAU is loaded dynamically to be able to make a binary
+        and have something working even if the target machine
+        does not have vdpau
+
+
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef ADM_ffmpeg_vdpa_internal_H
+#define ADM_ffmpeg_vdpa_internal_H
+#include <vector>
+extern "C" {
+static void draw(struct AVCodecContext *s,    const AVFrame *src, int offset[4],    int y, int type, int height);
+static int ADM_VDPAUgetBuffer(AVCodecContext *avctx, AVFrame *pic);
+static void ADM_VDPAUreleaseBuffer(struct AVCodecContext *avctx, AVFrame *pic);
+}
+
+
+#define NB_SURFACE 50
+typedef struct 
+{
+        VdpDecoder            vdpDecoder;
+        vdpau_render_state *renders[NB_SURFACE];
+        std::vector <vdpau_render_state *>freeQueue;
+
+}vdpauContext;
+
+#define VDPAU ((vdpauContext *)vdpau)
+
+// VDPAU internal linker
+
+typedef struct 
+{
+    VdpGetErrorString       *getErrorString;
+    VdpGetApiVersion        *getApiVersion;
+    VdpGetInformationString *getInformationString;
+
+    VdpVideoSurfaceCreate   *createSurface;
+    VdpVideoSurfaceDestroy  *destroySurface;
+    VdpVideoSurfaceGetBitsYCbCr *getDataSurface;
+
+    VdpDecoderCreate        *decoderCreate;
+    VdpDecoderDestroy       *decoderDestroy;
+    VdpDecoderRender        *decoderRender;
+
+}VdpFunctions;
+
+#define WRAP_Open_Template(funcz,argz,display,codecid) \
+{\
+AVCodec *codec=funcz(argz);\
+if(!codec) {GUI_Error_HIG("Codec",QT_TR_NOOP("Internal error finding codec"display));ADM_assert(0);} \
+  codecId=codecid; \
+  _context->workaround_bugs=1*FF_BUG_AUTODETECT +0*FF_BUG_NO_PADDING; \
+  _context->error_concealment=3; \
+  if (avcodec_open(_context, codec) < 0)  \
+                      { \
+                                        printf("[lavc] Decoder init: "display" video decoder failed!\n"); \
+                                        GUI_Error_HIG("Codec","Internal error opening "display); \
+                                        ADM_assert(0); \
+                                } \
+                                else \
+                                { \
+                                        printf("[lavc] Decoder init: "display" video decoder initialized! (%s)\n",codec->long_name); \
+                                } \
+}
+
+#define WRAP_Open(x)            {WRAP_Open_Template(avcodec_find_decoder,x,#x,x);}
+#define WRAP_OpenByName(x,y)    {WRAP_Open_Template(avcodec_find_decoder_by_name,#x,#x,y);}
+
+#endif
\ No newline at end of file

Copied: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src/ADM_ffmpeg_vdpau.cpp (from rev 5841, branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_ffmpeg_vdpau.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_ffmpeg_vdpau.cpp	2010-01-11 06:31:35 UTC (rev 5841)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src/ADM_ffmpeg_vdpau.cpp	2010-01-11 19:09:33 UTC (rev 5842)
@@ -0,0 +1,347 @@
+/***************************************************************************
+            \file              ADM_ffmpeg_vdpau.cpp  
+            \brief Decoder using half ffmpeg/half VDPAU
+
+    The ffmpeg part is to preformat inputs for VDPAU
+    VDPAU is loaded dynamically to be able to make a binary
+        and have something working even if the target machine
+        does not have vdpau
+    Some part, especially get/buffer and ip_age borrowed from xbmc
+        as the api from ffmpeg is far from clear....
+
+
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+extern "C" {
+#include "ADM_lavcodec.h"
+}
+#include "ADM_default.h"
+#ifdef USE_VDPAU
+extern "C" {
+ #include "ADM_ffmpeg/libavcodec/vdpau.h"
+}
+
+#include "vdpau/vdpau_x11.h"
+#include "vdpau/vdpau.h"
+#include "ADM_codec.h"
+#include "ADM_ffmp43.h"
+#include "DIA_coreToolkit.h"
+#include "ADM_dynamicLoading.h"
+#include "ADM_render/GUI_render.h"
+#include "ADM_ffmpeg_vdpau_internal.h"
+#include "prefs.h"
+#include "ADM_codecVdpau.h"
+
+static VdpFunctions funcs;
+
+static bool vdpauWorking=false;
+
+static ADM_LibWrapper        vdpauDynaLoader;
+static VdpDeviceCreateX11    *ADM_createVdpX11;
+static VdpDevice             vdpDevice;
+static VdpGetProcAddress     *vdpProcAddress;
+
+#define aprintf(...) {}
+
+/**
+    \fn vdpauUsable
+    \brief Return true if  vdpau can be used...
+*/
+bool vdpauUsable(void)
+{
+    uint32_t v=false;
+    if(!vdpauWorking) return false;
+    if(!prefs->get(FEATURE_VDPAU,&v)) v=false;
+    return v;
+}
+/**
+    \fn getFunc
+    \brief vdpau function pointers from ID
+*/
+static void *getFunc(uint32_t id)
+{
+    void *f;
+    if(VDP_STATUS_OK!=vdpProcAddress(vdpDevice,id,&f)) return NULL;
+    return (void *)f;
+}
+/**
+    \fn vdpauProbe
+    \brief Try loading vdpau...
+*/
+bool vdpauProbe(void)
+{
+    memset(&funcs,0,sizeof(funcs));
+    if(false==vdpauDynaLoader.loadLibrary("/usr/lib/libvdpau.so"))
+    {
+        return false;
+    }
+    ADM_createVdpX11=(VdpDeviceCreateX11*)vdpauDynaLoader.getSymbol("vdp_device_create_x11");
+    if(!ADM_createVdpX11) return false;
+
+    //
+    GUI_WindowInfo xinfo;
+    void *draw;
+    draw=UI_getDrawWidget();
+    UI_getWindowInfo(draw,&xinfo );
+    
+    // try to create....
+    if( VDP_STATUS_OK!=ADM_createVdpX11((Display*)xinfo.display,0,&vdpDevice,&vdpProcAddress))
+    {
+        return false;
+    }
+    // Now that we have the vdpProcAddress, time to get the functions....
+#define GetMe(fun,id)         funcs.fun= (typeof(funcs.fun))getFunc(id);ADM_assert(funcs.fun); 
+        
+    GetMe(getErrorString,VDP_FUNC_ID_GET_ERROR_STRING);
+    GetMe(getApiVersion,VDP_FUNC_ID_GET_API_VERSION);
+    GetMe(getInformationString,VDP_FUNC_ID_GET_INFORMATION_STRING);
+
+    GetMe(createSurface,VDP_FUNC_ID_VIDEO_SURFACE_CREATE);
+    GetMe(destroySurface,VDP_FUNC_ID_VIDEO_SURFACE_DESTROY);
+    GetMe(getDataSurface,VDP_FUNC_ID_VIDEO_SURFACE_GET_BITS_Y_CB_CR);
+
+    GetMe(decoderCreate,VDP_FUNC_ID_DECODER_CREATE);
+    GetMe(decoderDestroy,VDP_FUNC_ID_DECODER_DESTROY);
+    GetMe(decoderRender,VDP_FUNC_ID_DECODER_RENDER);
+
+
+
+    const char *versionString=NULL;
+    uint32_t version=0xff;
+        funcs.getInformationString(&versionString);
+        funcs.getApiVersion(&version);
+        printf("[VDPAU] API : 0x%x, info : %s\n",version,versionString);
+
+    vdpauWorking=true;
+    return true;
+}
+/**
+    \fn ADM_VDPAUgetBuffer
+    \brief trampoline to get a VDPAU surface
+*/
+int ADM_VDPAUgetBuffer(AVCodecContext *avctx, AVFrame *pic)
+{
+    decoderFFVDPAU *dec=(decoderFFVDPAU *)avctx->opaque;
+    return dec->getBuffer(avctx,pic);
+}
+/**
+    \fn getBuffer
+    \brief returns a VDPAU render masquerading as a AVFrame
+*/
+int decoderFFVDPAU::getBuffer(AVCodecContext *avctx, AVFrame *pic)
+{
+    vdpau_render_state * render;
+    if(VDPAU->freeQueue.size()==0)
+    {
+        printf("[VDPAU] No more available surface\n");
+        return -1;
+    }
+    // Get an image   
+    render=VDPAU->freeQueue.back();
+    VDPAU->freeQueue.pop_back();
+    render->state=0;
+    pic->data[0]=(uint8_t *)render;
+    pic->data[1]=(uint8_t *)render;
+    pic->data[2]=(uint8_t *)render;
+    pic->linesize[0]=0;
+    pic->linesize[1]=0;
+    pic->linesize[2]=0;
+    pic->type=FF_BUFFER_TYPE_USER;
+    render->state |= FF_VDPAU_STATE_USED_FOR_REFERENCE;
+    pic->reordered_opaque= avctx->reordered_opaque;
+    if(pic->reference)
+    {
+        pic->age=ip_age[0];
+        ip_age[0]=ip_age[1]+1;
+        ip_age[1]=1;
+        b_age++;
+    }else
+    {
+        pic->age=b_age;
+        ip_age[0]++;
+        ip_age[1]++;
+        b_age=1;
+    }
+    return 0;
+}
+/**
+    \fn releaseBuffer
+*/
+void decoderFFVDPAU::releaseBuffer(AVCodecContext *avctx, AVFrame *pic)
+{
+  vdpau_render_state * render;
+  int i;
+  if(destroying==true) return; // They are already freed...
+  render=(vdpau_render_state*)pic->data[0];
+  ADM_assert(render);
+
+  render->state &= ~FF_VDPAU_STATE_USED_FOR_REFERENCE;
+  for(i=0; i<4; i++){
+    pic->data[i]= NULL;
+  }
+  VDPAU->freeQueue.push_back(render);
+}
+/**
+    \fn ADM_VDPAUreleaseBuffer
+*/
+ void ADM_VDPAUreleaseBuffer(struct AVCodecContext *avctx, AVFrame *pic)
+{
+    decoderFFVDPAU *dec=(decoderFFVDPAU *)avctx->opaque;
+    dec->releaseBuffer(avctx,pic);
+}
+/**
+    \fn decoderFFVDPAU
+*/
+decoderFFVDPAU::decoderFFVDPAU(uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, 
+        uint8_t *extraData,uint32_t bpp)
+:decoderFF (w,h,fcc,extraDataLen,extraData,bpp)
+{
+        destroying=false;
+        _context->opaque          = this;
+        _context->get_buffer      = ADM_VDPAUgetBuffer;
+        _context->release_buffer  = ADM_VDPAUreleaseBuffer;
+        _context->draw_horiz_band = draw;
+        _context->slice_flags     = SLICE_FLAG_CODED_ORDER|SLICE_FLAG_ALLOW_FIELD;
+        _context->extradata = (uint8_t *) extraData;
+        _context->extradata_size = (int) extraDataLen;
+
+        vdpau=(void *)new vdpauContext;
+        VDPAU->vdpDecoder=VDP_INVALID_HANDLE;
+        WRAP_OpenByName(h264_vdpau,CODEC_ID_H264);
+        
+        // Now instantiate our VDPAU surface & decoder
+        ADM_assert(VDP_STATUS_OK==funcs.decoderCreate(vdpDevice,VDP_DECODER_PROFILE_H264_HIGH,w,h,15,&(VDPAU->vdpDecoder)));
+        // Create our surfaces...
+        for(int i=0;i<NB_SURFACE;i++)
+        {
+            VDPAU->renders[i]=new vdpau_render_state;
+            memset(VDPAU->renders[i],0,sizeof( vdpau_render_state));
+            ADM_assert(VDP_STATUS_OK==funcs.createSurface(vdpDevice,VDP_CHROMA_TYPE_420,w,h,&(VDPAU->renders[i]->surface)));
+            VDPAU->freeQueue.push_back(VDPAU->renders[i]);
+        }
+        scratch=new ADMImage(w,h,1);
+        b_age = ip_age[0] = ip_age[1] = 256*256*256*64;
+
+}
+/**
+    \fn ~            void    goOn( const AVFrame *d);
+*/
+decoderFFVDPAU::~decoderFFVDPAU()
+{
+        printf("[VDPAU] Cleaning up\n");
+        destroying=true;
+        for(int i=0;i<NB_SURFACE;i++)
+        {
+            ADM_assert(VDP_STATUS_OK==funcs.destroySurface((VDPAU->renders[i]->surface)));
+            delete VDPAU->renders[i];
+        }
+         ADM_assert(VDP_STATUS_OK==funcs.decoderDestroy(VDPAU->vdpDecoder));
+         delete VDPAU;
+         vdpau=NULL;
+}
+/**
+    \fn uncompress
+*/
+bool decoderFFVDPAU::uncompress (ADMCompressedImage * in, ADMImage * out)
+{
+VdpStatus status;
+    
+    // First let ffmpeg prepare datas...
+    vdpau_copy=out;
+    decode_status=false;
+    if(!decoderFF::uncompress (in, scratch))
+    {
+        printf("[VDPAU] No data from libavcodec\n");
+        return 0;
+    }
+    if(decode_status!=true)
+    {
+        printf("[VDPAU] error in renderDecode\n");
+        return 0;
+    }
+    // other part will be done in goOn
+  struct vdpau_render_state *rndr = (struct vdpau_render_state *)scratch->_planes[0];
+   VdpVideoSurface  surface;
+
+    surface=rndr->surface;
+ void *planes[3];
+            planes[0]=vdpau_copy->GetWritePtr(PLANAR_Y);
+            planes[1]=vdpau_copy->GetWritePtr(PLANAR_U);
+            planes[2]=vdpau_copy->GetWritePtr(PLANAR_V);
+    uint32_t stride[3];
+            stride[0]=vdpau_copy->GetPitch(PLANAR_Y);
+            stride[1]=vdpau_copy->GetPitch(PLANAR_U);
+            stride[2]=vdpau_copy->GetPitch(PLANAR_V);
+
+    
+   // Copy back the decoded image to our output ADM_image
+   aprintf("[VDPAU] Getting datas from surface %d\n",surface);
+    status=funcs.getDataSurface(
+                surface,
+                VDP_YCBCR_FORMAT_YV12, //VdpYCbCrFormat   destination_ycbcr_format,
+                planes, //void * const *   destination_data,
+                stride //destination_pitches
+                );
+    if(VDP_STATUS_OK!=status)
+    {
+        
+        printf("[VDPAU] Cannot get data from surface <%s>\n",funcs.getErrorString(status));
+        decode_status=false;
+        return 0 ;
+    }
+    
+
+    //
+    out->Pts=scratch->Pts;
+    out->flags=scratch->flags;
+    return (uint8_t)decode_status;
+}
+/**
+    \fn goOn
+    \brief Callback from ffmpeg when a pic is ready to be decoded
+*/
+void decoderFFVDPAU::goOn( const AVFrame *d,int type)
+{
+   VdpStatus status;
+   struct vdpau_render_state *rndr = (struct vdpau_render_state *)d->data[0];
+   VdpVideoSurface  surface;
+
+    surface=rndr->surface;
+    vdpau_pts=d->reordered_opaque; // Retrieve our PTS
+
+     aprintf("[VDPAU] Decoding Using surface %d\n", surface);
+    status=funcs.decoderRender(VDPAU->vdpDecoder, surface,
+                            (void * const *)&rndr->info, rndr->bitstream_buffers_used, rndr->bitstream_buffers);
+    if(VDP_STATUS_OK!=status)
+    {
+        printf("[VDPAU] No data after decoderRender <%s>\n",funcs.getErrorString(status));
+        decode_status=false;
+        return ;
+    }
+    aprintf("[VDPAU] DecodeRender Ok***\n");
+    decode_status=true;
+    return;
+}
+
+
+/**
+    \fn draw
+    \brief callback invoked by lavcodec when a pic is ready to be decoded
+*/
+void draw(struct AVCodecContext *s,    const AVFrame *src, int offset[4],    int y, int type, int height)
+{
+    decoderFFVDPAU *dec=(decoderFFVDPAU *)s->opaque;
+    dec->goOn(src,type);
+}
+
+#endif
+// EOF

Added: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src/ADM_videoCodec.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src/ADM_videoCodec.cpp	2010-01-11 06:31:35 UTC (rev 5841)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src/ADM_videoCodec.cpp	2010-01-11 19:09:33 UTC (rev 5842)
@@ -0,0 +1,51 @@
+/***************************************************************************
+        \file ADM_videoCodec
+        \brief Search and instantiate video coder
+        \author mean fixounet at free.fr (C) 2010
+
+    see here : http://www.webartz.com/fourcc/
+
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+extern "C"
+{
+#include "ADM_lavcodec.h"
+};
+#include "ADM_default.h"
+
+#include "ADM_codec.h"
+#include "ADM_ffmp43.h"
+#include "avidemutils.h"
+#include "fourcc.h"
+#include "ADM_codecVdpau.h"
+
+extern bool vdpauUsable(void);
+
+/**
+    \fn getDecoder
+    \brief returns the correct decoder for a stream w,h,fcc,extraLen,extraData,bpp
+*/
+decoders *ADM_getDecoder (uint32_t fcc, uint32_t w, uint32_t h, uint32_t extraLen, uint8_t * extraData,uint32_t bpp)
+{
+  ADM_info("Searching decoder in coreVideoCodec(%d x %d, extradataSize:%d)...\n",w,h,extraLen);
+  if (isH264Compatible (fcc))
+    {
+#if defined(USE_VDPAU) 
+        if(vdpauUsable()==true)
+            return (decoders *) (new decoderFFVDPAU (w,h,fcc,extraLen,extraData,bpp));
+        
+#endif
+    }
+    return ADM_coreCodecGetDecoder(fcc,w,h,extraLen,extraData,bpp);
+}
+//EOF
+

Added: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src/CMakeLists.txt	2010-01-11 06:31:35 UTC (rev 5841)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src/CMakeLists.txt	2010-01-11 19:09:33 UTC (rev 5842)
@@ -0,0 +1,7 @@
+SET(ADM_videoCodec_SRCS
+        ADM_ffmpeg_vdpau.cpp
+        ADM_videoCodec.cpp
+)
+
+ADD_LIBRARY(ADM_videocodec6 STATIC ${ADM_videoCodec_SRCS})
+include_directories(${CMAKE_CURRENT_SOURCE_DIR}/../include)

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/CMakeLists.txt	2010-01-11 06:31:35 UTC (rev 5841)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/CMakeLists.txt	2010-01-11 19:09:33 UTC (rev 5842)
@@ -21,3 +21,4 @@
 #ADD_SUBDIRECTORY(ADM_videoFilter)
 ADD_SUBDIRECTORY(ADM_videoEncoder)
 ADD_SUBDIRECTORY(ADM_videoFilter2)
+ADD_SUBDIRECTORY(ADM_videoCodec)

Modified: branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake	2010-01-11 06:31:35 UTC (rev 5841)
+++ branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake	2010-01-11 19:09:33 UTC (rev 5842)
@@ -89,6 +89,7 @@
 ADM_editor6
 ADM_audiocodec6 
 ADM_coreVideoCodec6 
+ADM_videocodec6 
 ADM_commonUI6
 )
 SET(commonLibs2

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_codec.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_codec.h	2010-01-11 06:31:35 UTC (rev 5841)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_codec.h	2010-01-11 19:09:33 UTC (rev 5842)
@@ -85,55 +85,10 @@
         return true;
     }
 };
+/* This function is to be implemented by the application, it is just here for reference */
+decoders *ADM_getDecoder (uint32_t fcc, uint32_t w, uint32_t h, uint32_t extraLen, uint8_t * extraData,uint32_t bpp=0);
+/* This function is implemented in coreVideoCodec, it will return a codec if it can find a suitable one, NULL if not */
+decoders *ADM_coreCodecGetDecoder (uint32_t fcc, uint32_t w, uint32_t h, uint32_t extraLen, uint8_t * extraData,uint32_t bpp=0);
 
-decoders *getDecoder (uint32_t fcc, uint32_t w, uint32_t h, uint32_t extraLen,
-		      uint8_t * extraData,uint32_t bpp=0);
-#if 0
-decoders *getDecoderVopPacked (uint32_t fcc, uint32_t w, uint32_t h,
-			       uint32_t extraLen, uint8_t * extraData);
-decoders *getDecoderH264noLogic (uint32_t fcc, uint32_t w, uint32_t h, uint32_t extraLen,
-		     uint8_t * extraData);
 
-//***************************************
-
-class coders
-{
-protected:
-  uint32_t _w;
-  uint32_t _h;
-public:
-    coders (uint32_t w, uint32_t h)
-  {
-    _w = w;
-    _h = h;
-  }
-  virtual ~ coders ()
-  {
-  };
-  virtual uint8_t compress (ADMImage * in, ADMBitstream * out);
-};
-decoders *getCoder (uint32_t fcc, uint32_t w, uint32_t h);
-/*----------------------------------------------------------*/
-class encoder
-{
-protected:uint32_t _w, _h;
-public:encoder (uint32_t width, uint32_t height)
-  {
-    _w = width;
-    _h = height;
-  };
-  virtual uint8_t stopEncoder (void) = 0;
-  virtual uint8_t init (uint32_t val, uint32_t fps1000) = 0;
-  virtual uint8_t encode (ADMImage * in, ADMBitstream *out) = 0;
-  virtual uint8_t getExtraData (uint32_t * l, uint8_t ** d)
-  {
-    *l = 0;
-    *d = NULL;
-    return 0;
-  }
-};
-
 #endif
-
-
-#endif

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_ffmp43.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_ffmp43.h	2010-01-11 06:31:35 UTC (rev 5841)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_ffmp43.h	2010-01-11 19:09:33 UTC (rev 5842)
@@ -132,39 +132,8 @@
 };
 
 
-#ifdef USE_VDPAU
-class decoderFFVDPAU:public decoderFF
-{
-protected:
-                    int b_age;
-                    int ip_age[2];
 
-                    void     *vdpau;
-                    ADMImage *scratch;
-                    ADMImage *vdpau_copy;
-                    uint64_t vdpau_pts;
-                    bool     decode_status;
-                    bool     destroying;
-public:     // Callbacks
-                    int     getBuffer(AVCodecContext *avctx, AVFrame *pic);
-                    void    releaseBuffer(struct AVCodecContext *avctx, AVFrame *pic);
-                    void    goOn( const AVFrame *d,int type);            
-public:
-            // public API
-                    decoderFFVDPAU (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
-                    ~decoderFFVDPAU();
-    virtual bool uncompress (ADMCompressedImage * in, ADMImage * out);
-    virtual bool dontcopy (void)
-                      {
-                        return 0;
-                      }
-    virtual bool bFramePossible (void)
-      {
-        return 1;
-      }
-};
-
 #endif
-#endif
+
 // EOF
 

Deleted: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_ffmpeg_vdpau_internal.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_ffmpeg_vdpau_internal.h	2010-01-11 06:31:35 UTC (rev 5841)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_ffmpeg_vdpau_internal.h	2010-01-11 19:09:33 UTC (rev 5842)
@@ -1,82 +0,0 @@
-/***************************************************************************
-            \file              ADM_ffmpeg_vdpau.cpp  
-            \brief Decoder using half ffmpeg/half VDPAU
-
-    The ffmpeg part is to preformat inputs for VDPAU
-    VDPAU is loaded dynamically to be able to make a binary
-        and have something working even if the target machine
-        does not have vdpau
-
-
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifndef ADM_ffmpeg_vdpa_internal_H
-#define ADM_ffmpeg_vdpa_internal_H
-#include <vector>
-extern "C" {
-static void draw(struct AVCodecContext *s,    const AVFrame *src, int offset[4],    int y, int type, int height);
-static int ADM_VDPAUgetBuffer(AVCodecContext *avctx, AVFrame *pic);
-static void ADM_VDPAUreleaseBuffer(struct AVCodecContext *avctx, AVFrame *pic);
-}
-
-
-#define NB_SURFACE 50
-typedef struct 
-{
-        VdpDecoder            vdpDecoder;
-        vdpau_render_state *renders[NB_SURFACE];
-        std::vector <vdpau_render_state *>freeQueue;
-
-}vdpauContext;
-
-#define VDPAU ((vdpauContext *)vdpau)
-
-// VDPAU internal linker
-
-typedef struct 
-{
-    VdpGetErrorString       *getErrorString;
-    VdpGetApiVersion        *getApiVersion;
-    VdpGetInformationString *getInformationString;
-
-    VdpVideoSurfaceCreate   *createSurface;
-    VdpVideoSurfaceDestroy  *destroySurface;
-    VdpVideoSurfaceGetBitsYCbCr *getDataSurface;
-
-    VdpDecoderCreate        *decoderCreate;
-    VdpDecoderDestroy       *decoderDestroy;
-    VdpDecoderRender        *decoderRender;
-
-}VdpFunctions;
-
-#define WRAP_Open_Template(funcz,argz,display,codecid) \
-{\
-AVCodec *codec=funcz(argz);\
-if(!codec) {GUI_Error_HIG("Codec",QT_TR_NOOP("Internal error finding codec"display));ADM_assert(0);} \
-  codecId=codecid; \
-  _context->workaround_bugs=1*FF_BUG_AUTODETECT +0*FF_BUG_NO_PADDING; \
-  _context->error_concealment=3; \
-  if (avcodec_open(_context, codec) < 0)  \
-                      { \
-                                        printf("[lavc] Decoder init: "display" video decoder failed!\n"); \
-                                        GUI_Error_HIG("Codec","Internal error opening "display); \
-                                        ADM_assert(0); \
-                                } \
-                                else \
-                                { \
-                                        printf("[lavc] Decoder init: "display" video decoder initialized! (%s)\n",codec->long_name); \
-                                } \
-}
-
-#define WRAP_Open(x)            {WRAP_Open_Template(avcodec_find_decoder,x,#x,x);}
-#define WRAP_OpenByName(x,y)    {WRAP_Open_Template(avcodec_find_decoder_by_name,#x,#x,y);}
-
-#endif
\ No newline at end of file

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_codecSearch.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_codecSearch.cpp	2010-01-11 06:31:35 UTC (rev 5841)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_codecSearch.cpp	2010-01-11 19:09:33 UTC (rev 5842)
@@ -39,17 +39,14 @@
 #include "avidemutils.h"
 #include "fourcc.h"
 
-extern uint8_t GUI_Question (char *);
-extern uint8_t use_fast_ffmpeg;
-extern bool vdpauUsable(void);
 
 /**
     \fn getDecoder
     \brief returns the correct decoder for a stream w,h,fcc,extraLen,extraData,bpp
 */
-decoders *getDecoder (uint32_t fcc, uint32_t w, uint32_t h, uint32_t extraLen, uint8_t * extraData,uint32_t bpp)
+decoders *ADM_coreCodecGetDecoder (uint32_t fcc, uint32_t w, uint32_t h, uint32_t extraLen, uint8_t * extraData,uint32_t bpp)
 {
-  ADM_info("Searching decoder (%d x %d, extradataSize:%d)...\n",w,h,extraLen);
+  ADM_info("Searching decoder in coreVideoCodec(%d x %d, extradataSize:%d)...\n",w,h,extraLen);
   if (isMSMpeg4Compatible (fcc) == 1)
     {
       return (decoders *) (new decoderFFDiv3 (w,h,fcc,extraLen,extraData,bpp));

Deleted: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_ffmpeg_vdpau.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_ffmpeg_vdpau.cpp	2010-01-11 06:31:35 UTC (rev 5841)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_ffmpeg_vdpau.cpp	2010-01-11 19:09:33 UTC (rev 5842)
@@ -1,345 +0,0 @@
-/***************************************************************************
-            \file              ADM_ffmpeg_vdpau.cpp  
-            \brief Decoder using half ffmpeg/half VDPAU
-
-    The ffmpeg part is to preformat inputs for VDPAU
-    VDPAU is loaded dynamically to be able to make a binary
-        and have something working even if the target machine
-        does not have vdpau
-    Some part, especially get/buffer and ip_age borrowed from xbmc
-        as the api from ffmpeg is far from clear....
-
-
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#if 0
-extern "C" {
-#include "ADM_lavcodec.h"
-}
-#include "ADM_default.h"
-#ifdef USE_VDPAU
-extern "C" {
- #include "ADM_ffmpeg/libavcodec/vdpau.h"
-}
-
-#include "vdpau/vdpau_x11.h"
-#include "vdpau/vdpau.h"
-#include "ADM_codec.h"
-#include "ADM_ffmp43.h"
-#include "DIA_coreToolkit.h"
-#include "ADM_dynamicLoading.h"
-#include "ADM_render/GUI_render.h"
-#include "ADM_ffmpeg_vdpau_internal.h"
-//#include "prefs.h"
-
-static VdpFunctions funcs;
-
-static bool vdpauWorking=false;
-
-static ADM_LibWrapper        vdpauDynaLoader;
-static VdpDeviceCreateX11    *ADM_createVdpX11;
-static VdpDevice             vdpDevice;
-static VdpGetProcAddress     *vdpProcAddress;
-
-#define aprintf(...) {}
-
-/**
-    \fn vdpauUsable
-    \brief Return true if  vdpau can be used...
-*/
-bool vdpauUsable(void)
-{
-    uint32_t v=false;
-    if(!vdpauWorking) return false;
-    if(!prefs->get(FEATURE_VDPAU,&v)) v=false;
-    return v;
-}
-/**
-    \fn getFunc
-    \brief vdpau function pointers from ID
-*/
-static void *getFunc(uint32_t id)
-{
-    void *f;
-    if(VDP_STATUS_OK!=vdpProcAddress(vdpDevice,id,&f)) return NULL;
-    return (void *)f;
-}
-/**
-    \fn vdpauProbe
-    \brief Try loading vdpau...
-*/
-bool vdpauProbe(void)
-{
-    memset(&funcs,0,sizeof(funcs));
-    if(false==vdpauDynaLoader.loadLibrary("/usr/lib/libvdpau.so"))
-    {
-        return false;
-    }
-    ADM_createVdpX11=(VdpDeviceCreateX11*)vdpauDynaLoader.getSymbol("vdp_device_create_x11");
-    if(!ADM_createVdpX11) return false;
-
-    //
-    GUI_WindowInfo xinfo;
-    void *draw;
-    draw=UI_getDrawWidget();
-    UI_getWindowInfo(draw,&xinfo );
-    
-    // try to create....
-    if( VDP_STATUS_OK!=ADM_createVdpX11((Display*)xinfo.display,0,&vdpDevice,&vdpProcAddress))
-    {
-        return false;
-    }
-    // Now that we have the vdpProcAddress, time to get the functions....
-#define GetMe(fun,id)         funcs.fun= (typeof(funcs.fun))getFunc(id);ADM_assert(funcs.fun); 
-        
-    GetMe(getErrorString,VDP_FUNC_ID_GET_ERROR_STRING);
-    GetMe(getApiVersion,VDP_FUNC_ID_GET_API_VERSION);
-    GetMe(getInformationString,VDP_FUNC_ID_GET_INFORMATION_STRING);
-
-    GetMe(createSurface,VDP_FUNC_ID_VIDEO_SURFACE_CREATE);
-    GetMe(destroySurface,VDP_FUNC_ID_VIDEO_SURFACE_DESTROY);
-    GetMe(getDataSurface,VDP_FUNC_ID_VIDEO_SURFACE_GET_BITS_Y_CB_CR);
-
-    GetMe(decoderCreate,VDP_FUNC_ID_DECODER_CREATE);
-    GetMe(decoderDestroy,VDP_FUNC_ID_DECODER_DESTROY);
-    GetMe(decoderRender,VDP_FUNC_ID_DECODER_RENDER);
-
-
-
-    const char *versionString=NULL;
-    uint32_t version=0xff;
-        funcs.getInformationString(&versionString);
-        funcs.getApiVersion(&version);
-        printf("[VDPAU] API : 0x%x, info : %s\n",version,versionString);
-
-    vdpauWorking=true;
-    return true;
-}
-/**
-    \fn ADM_VDPAUgetBuffer
-    \brief trampoline to get a VDPAU surface
-*/
-int ADM_VDPAUgetBuffer(AVCodecContext *avctx, AVFrame *pic)
-{
-    decoderFFVDPAU *dec=(decoderFFVDPAU *)avctx->opaque;
-    return dec->getBuffer(avctx,pic);
-}
-/**
-    \fn getBuffer
-    \brief returns a VDPAU render masquerading as a AVFrame
-*/
-int decoderFFVDPAU::getBuffer(AVCodecContext *avctx, AVFrame *pic)
-{
-    vdpau_render_state * render;
-    if(VDPAU->freeQueue.size()==0)
-    {
-        printf("[VDPAU] No more available surface\n");
-        return -1;
-    }
-    // Get an image   
-    render=VDPAU->freeQueue.back();
-    VDPAU->freeQueue.pop_back();
-    render->state=0;
-    pic->data[0]=(uint8_t *)render;
-    pic->data[1]=(uint8_t *)render;
-    pic->data[2]=(uint8_t *)render;
-    pic->linesize[0]=0;
-    pic->linesize[1]=0;
-    pic->linesize[2]=0;
-    pic->type=FF_BUFFER_TYPE_USER;
-    render->state |= FF_VDPAU_STATE_USED_FOR_REFERENCE;
-    pic->reordered_opaque= avctx->reordered_opaque;
-    if(pic->reference)
-    {
-        pic->age=ip_age[0];
-        ip_age[0]=ip_age[1]+1;
-        ip_age[1]=1;
-        b_age++;
-    }else
-    {
-        pic->age=b_age;
-        ip_age[0]++;
-        ip_age[1]++;
-        b_age=1;
-    }
-    return 0;
-}
-/**
-    \fn releaseBuffer
-*/
-void decoderFFVDPAU::releaseBuffer(AVCodecContext *avctx, AVFrame *pic)
-{
-  vdpau_render_state * render;
-  int i;
-  if(destroying==true) return; // They are already freed...
-  render=(vdpau_render_state*)pic->data[0];
-  ADM_assert(render);
-
-  render->state &= ~FF_VDPAU_STATE_USED_FOR_REFERENCE;
-  for(i=0; i<4; i++){
-    pic->data[i]= NULL;
-  }
-  VDPAU->freeQueue.push_back(render);
-}
-/**
-    \fn ADM_VDPAUreleaseBuffer
-*/
- void ADM_VDPAUreleaseBuffer(struct AVCodecContext *avctx, AVFrame *pic)
-{
-    decoderFFVDPAU *dec=(decoderFFVDPAU *)avctx->opaque;
-    dec->releaseBuffer(avctx,pic);
-}
-/**
-    \fn decoderFFVDPAU
-*/
-decoderFFVDPAU::decoderFFVDPAU(uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,	   h)
-{
-        destroying=false;
-        _context->opaque          = this;
-        _context->get_buffer      = ADM_VDPAUgetBuffer;
-        _context->release_buffer  = ADM_VDPAUreleaseBuffer;
-        _context->draw_horiz_band = draw;
-        _context->slice_flags     = SLICE_FLAG_CODED_ORDER|SLICE_FLAG_ALLOW_FIELD;
-        _context->extradata = (uint8_t *) d;
-        _context->extradata_size = (int) l;
-
-        vdpau=(void *)new vdpauContext;
-        VDPAU->vdpDecoder=VDP_INVALID_HANDLE;
-        WRAP_OpenByName(h264_vdpau,CODEC_ID_H264);
-        
-        // Now instantiate our VDPAU surface & decoder
-        ADM_assert(VDP_STATUS_OK==funcs.decoderCreate(vdpDevice,VDP_DECODER_PROFILE_H264_HIGH,w,h,15,&(VDPAU->vdpDecoder)));
-        // Create our surfaces...
-        for(int i=0;i<NB_SURFACE;i++)
-        {
-            VDPAU->renders[i]=new vdpau_render_state;
-            memset(VDPAU->renders[i],0,sizeof( vdpau_render_state));
-            ADM_assert(VDP_STATUS_OK==funcs.createSurface(vdpDevice,VDP_CHROMA_TYPE_420,w,h,&(VDPAU->renders[i]->surface)));
-            VDPAU->freeQueue.push_back(VDPAU->renders[i]);
-        }
-        scratch=new ADMImage(w,h,1);
-        b_age = ip_age[0] = ip_age[1] = 256*256*256*64;
-
-}
-/**
-    \fn ~            void    goOn( const AVFrame *d);
-*/
-decoderFFVDPAU::~decoderFFVDPAU()
-{
-        printf("[VDPAU] Cleaning up\n");
-        destroying=true;
-        for(int i=0;i<NB_SURFACE;i++)
-        {
-            ADM_assert(VDP_STATUS_OK==funcs.destroySurface((VDPAU->renders[i]->surface)));
-            delete VDPAU->renders[i];
-        }
-         ADM_assert(VDP_STATUS_OK==funcs.decoderDestroy(VDPAU->vdpDecoder));
-         delete VDPAU;
-         vdpau=NULL;
-}
-/**
-    \fn uncompress
-*/
-uint8_t decoderFFVDPAU::uncompress (ADMCompressedImage * in, ADMImage * out)
-{
-VdpStatus status;
-    
-    // First let ffmpeg prepare datas...
-    vdpau_copy=out;
-    decode_status=false;
-    if(!decoderFF::uncompress (in, scratch))
-    {
-        printf("[VDPAU] No data from libavcodec\n");
-        return 0;
-    }
-    if(decode_status!=true)
-    {
-        printf("[VDPAU] error in renderDecode\n");
-        return 0;
-    }
-    // other part will be done in goOn
-  struct vdpau_render_state *rndr = (struct vdpau_render_state *)scratch->_planes[0];
-   VdpVideoSurface  surface;
-
-    surface=rndr->surface;
- void *planes[3];
-            planes[0]=vdpau_copy->GetWritePtr(PLANAR_Y);
-            planes[1]=vdpau_copy->GetWritePtr(PLANAR_U);
-            planes[2]=vdpau_copy->GetWritePtr(PLANAR_V);
-    uint32_t stride[3];
-            stride[0]=vdpau_copy->GetPitch(PLANAR_Y);
-            stride[1]=vdpau_copy->GetPitch(PLANAR_U);
-            stride[2]=vdpau_copy->GetPitch(PLANAR_V);
-
-    
-   // Copy back the decoded image to our output ADM_image
-   aprintf("[VDPAU] Getting datas from surface %d\n",surface);
-    status=funcs.getDataSurface(
-                surface,
-                VDP_YCBCR_FORMAT_YV12, //VdpYCbCrFormat   destination_ycbcr_format,
-                planes, //void * const *   destination_data,
-                stride //destination_pitches
-                );
-    if(VDP_STATUS_OK!=status)
-    {
-        
-        printf("[VDPAU] Cannot get data from surface <%s>\n",funcs.getErrorString(status));
-        decode_status=false;
-        return 0 ;
-    }
-    
-
-    //
-    out->Pts=scratch->Pts;
-    out->flags=scratch->flags;
-    return (uint8_t)decode_status;
-}
-/**
-    \fn goOn
-    \brief Callback from ffmpeg when a pic is ready to be decoded
-*/
-void decoderFFVDPAU::goOn( const AVFrame *d,int type)
-{
-   VdpStatus status;
-   struct vdpau_render_state *rndr = (struct vdpau_render_state *)d->data[0];
-   VdpVideoSurface  surface;
-
-    surface=rndr->surface;
-    vdpau_pts=d->reordered_opaque; // Retrieve our PTS
-
-     aprintf("[VDPAU] Decoding Using surface %d\n", surface);
-    status=funcs.decoderRender(VDPAU->vdpDecoder, surface,
-                            (void * const *)&rndr->info, rndr->bitstream_buffers_used, rndr->bitstream_buffers);
-    if(VDP_STATUS_OK!=status)
-    {
-        printf("[VDPAU] No data after decoderRender <%s>\n",funcs.getErrorString(status));
-        decode_status=false;
-        return ;
-    }
-    aprintf("[VDPAU] DecodeRender Ok***\n");
-    decode_status=true;
-    return;
-}
-
-
-/**
-    \fn draw
-    \brief callback invoked by lavcodec when a pic is ready to be decoded
-*/
-void draw(struct AVCodecContext *s,    const AVFrame *src, int offset[4],    int y, int type, int height)
-{
-    decoderFFVDPAU *dec=(decoderFFVDPAU *)s->opaque;
-    dec->goOn(src,type);
-}
-
-#endif
-#endif
-// EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/CMakeLists.txt	2010-01-11 06:31:35 UTC (rev 5841)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/CMakeLists.txt	2010-01-11 19:09:33 UTC (rev 5842)
@@ -5,7 +5,6 @@
 ADM_codecFFsimple.cpp
 ADM_rgb16.cpp
 ADM_uyvy.cpp
-ADM_ffmpeg_vdpau.cpp
 ADM_png.cpp
 ADM_codecSearch.cpp
 DIA_lavDecoder.cpp



From mean at mail.berlios.de  Mon Jan 11 20:09:37 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Mon, 11 Jan 2010 20:09:37 +0100
Subject: [Avidemux-svn-commit] r5843 - in branches/avidemux_2.6_branch_mean:
	avidemux/common/ADM_videoCodec/src
	avidemux_core/ADM_coreVideoCodec/src
Message-ID: <201001111909.o0BJ9bbi009355@sheep.berlios.de>

Author: mean
Date: 2010-01-11 20:09:36 +0100 (Mon, 11 Jan 2010)
New Revision: 5843

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src/ADM_ffmpeg_vdpau.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_ffmp43.cpp
Log:
[codec] Small cleanup

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src/ADM_ffmpeg_vdpau.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src/ADM_ffmpeg_vdpau.cpp	2010-01-11 19:09:33 UTC (rev 5842)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src/ADM_ffmpeg_vdpau.cpp	2010-01-11 19:09:36 UTC (rev 5843)
@@ -146,8 +146,8 @@
         return -1;
     }
     // Get an image   
-    render=VDPAU->freeQueue.back();
-    VDPAU->freeQueue.pop_back();
+    render=VDPAU->freeQueue.front();
+    VDPAU->freeQueue.erase(VDPAU->freeQueue.begin());
     render->state=0;
     pic->data[0]=(uint8_t *)render;
     pic->data[1]=(uint8_t *)render;

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_ffmp43.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_ffmp43.cpp	2010-01-11 19:09:33 UTC (rev 5842)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_ffmp43.cpp	2010-01-11 19:09:36 UTC (rev 5843)
@@ -118,11 +118,12 @@
 {
   uint32_t threads = 0;
 
-//  prefs->get(FEATURE_THREADING_LAVC, &threads);
+ // prefs->get(FEATURE_THREADING_LAVC, &threads);
+#warning Fixme
+    threads=1;
+  if (threads == 0)
+	  threads = ADM_cpu_num_processors();
 
-//  if (threads == 0)
-//	  threads = ADM_cpu_num_processors();
-
   if (threads == 1)
 	  threads = 0;
 
@@ -148,40 +149,6 @@
 
 }
 
-#if 0  
-uint8_t decoderFF::isDivxPacked (void)
-{
-  int
-    vop,
-    gmc,
-    qpel;
-  av_is_voppacked (_context, &vop, &gmc, &qpel);
-  return vop;
-}
-// Fill the bitfields for some mpeg4 specific info
-// It is a bit of a hack as we make it a general
-// stuff (i.e. shared with all codecs) whereas it is mpeg4 specific
-// and should stay within mpeg4 scope FIXME
-uint32_t decoderFF::getSpecificMpeg4Info (void)
-{
-  int
-    vop,
-    gmc,
-    qpel;
-  uint32_t
-    out = 0;
-  av_is_voppacked (_context, &vop, &gmc, &qpel);
-
-  if (qpel)
-    out += ADM_QPEL_ON;
-  if (_gmc)
-    out += ADM_GMC_ON;
-  if (vop)
-    out += ADM_VOP_ON;
-
-  return out;
-}
-#endif
 //________________________________________________
 bool  decoderFF::setParam (void)
 {



From mean at mail.berlios.de  Tue Jan 12 07:22:48 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 12 Jan 2010 07:22:48 +0100
Subject: [Avidemux-svn-commit] r5844 -
	branches/avidemux_2.6_branch_mean/avidemux
Message-ID: <201001120622.o0C6MmKX023579@sheep.berlios.de>

Author: mean
Date: 2010-01-12 07:22:44 +0100 (Tue, 12 Jan 2010)
New Revision: 5844

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake
Log:
[videoCodec] Link order fix (win32)

Modified: branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake	2010-01-11 19:09:36 UTC (rev 5843)
+++ branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake	2010-01-12 06:22:44 UTC (rev 5844)
@@ -88,8 +88,8 @@
 ADM_audioFilter6
 ADM_editor6
 ADM_audiocodec6 
+ADM_videocodec6 
 ADM_coreVideoCodec6 
-ADM_videocodec6 
 ADM_commonUI6
 )
 SET(commonLibs2



From mean at mail.berlios.de  Wed Jan 13 20:51:54 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 13 Jan 2010 20:51:54 +0100
Subject: [Avidemux-svn-commit] r5845 - in branches/avidemux_2.6_branch_mean:
	avidemux avidemux/common avidemux_core
	avidemux_core/ADM_coreImage/include
	avidemux_core/ADM_coreImageLoader
	avidemux_core/ADM_coreImageLoader/include
	avidemux_core/ADM_coreImageLoader/src cmake
Message-ID: <201001131951.o0DJpsjM030040@sheep.berlios.de>

Author: mean
Date: 2010-01-13 20:51:53 +0100 (Wed, 13 Jan 2010)
New Revision: 5845

Added:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImageLoader/
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImageLoader/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImageLoader/include/
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImageLoader/include/ADM_imageLoader.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImageLoader/src/
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImageLoader/src/ADM_imageLoader.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImageLoader/src/CMakeLists.txt
Removed:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_imageLoader.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/include/ADM_image.h
   branches/avidemux_2.6_branch_mean/avidemux_core/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/cmake/admCoreIncludes.cmake
Log:
[imageLoader] Make imageLoader a core library so that it can be used by plugins

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_imageLoader.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_imageLoader.cpp	2010-01-12 06:22:44 UTC (rev 5844)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_imageLoader.cpp	2010-01-13 19:51:53 UTC (rev 5845)
@@ -1,454 +0,0 @@
-/***************************************************************************
-    copyright            : (C) 2007 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include "ADM_default.h"
-
-
-#include "ADM_image.h"
-#if 0
-#include "ADM_lavcodec.h"
-#include "ADM_codecs/ADM_codec.h"
-#include "ADM_codecs/ADM_ffmp43.h"
-#include "ADM_codecs/ADM_png.h"
-#endif
-
-#include "ADM_bitmap.h"
-#include "ADM_editor/ADM_edit.hxx"
-#include "DIA_coreToolkit.h"
-//**********************************
-//static ADMImage *createImageFromFile_jpeg(const char *filename);
-static ADMImage *createImageFromFile_Bmp(const char *filename);
-static ADMImage *createImageFromFile_Bmp2(const char *filename);
-//static ADMImage *createImageFromFile_png(const char *filename);
-//***********************************
-static uint8_t read8(FILE *fd)
-{
-	return fgetc(fd);
-}
-static uint32_t read16(FILE *fd)
-{
-	uint32_t a,b;
-	
-	a=fgetc(fd);
-	b=fgetc(fd);
-	return (a<<8)+b;
-		
-}
-static uint32_t read32(FILE *fd)
-{
-	uint32_t a,b,c,d;
-	
-	a=fgetc(fd);
-	b=fgetc(fd);
-	c=fgetc(fd);
-	d=fgetc(fd);
-	return (a<<24)+(b<<16)+(c<<8)+d;
-		
-}
-
-/**
-		\fn 	createImageFromFile
-		\brief 	Create and returns an ADMImage from a file, only YV12 jpg supported ATM
-
-*/
-ADMImage *createImageFromFile(const char *filename)
-{
-	uint32_t w,h;
-	switch(ADM_identidyImageFile(filename,&w,&h))
-	{
-		case  ADM_IMAGE_UNKNOWN: 
-					printf("[imageLoader] Trouble identifying /loading %s\n",filename);
-					return NULL;
-#if 0
-		case ADM_IMAGE_JPG:
-					return createImageFromFile_jpeg(filename);
-					break;
-		case ADM_IMAGE_PNG:
-					return createImageFromFile_png(filename);
-					break;
-#endif
-		case ADM_IMAGE_BMP2:
-					return createImageFromFile_Bmp2(filename);
-					break;
-		default:
-				ADM_assert(0);
-	
-	}
-	ADM_assert(0);
-}
-#if 0
-/**
- * 	\fn createImageFromFile_jpeg
- *  \brief Create image from jpeg file
- */
-ADMImage *createImageFromFile_jpeg(const char *filename)
-{
-	
-	FILE *fd;
-	uint32_t _imgSize;
-	uint32_t w = 0, h = 0;
-	   
-
-		fd = ADM_fopen(filename, "rb");
-		fseek(fd, 0, SEEK_END);
-		_imgSize = ftell(fd);
-		fseek(fd, 0, SEEK_SET);
-
-		//Retrieve width & height
-		//_______________________
-		    uint16_t tag = 0, count = 0, off;
-
-		    
-		    fseek(fd, 0, SEEK_SET);
-		    read16(fd);	// skip jpeg ffd8
-		    while (count < 10 && tag != 0xFFC0) 
-		    {
-
-		    	tag = read16(fd);
-		    	if ((tag >> 8) != 0xff) 
-		    	{
-		    		printf("[imageLoader]invalid jpeg tag found (%x)\n", tag);
-		    	}
-		    	if (tag == 0xFFC0) 
-		    	{
-		    		read16(fd);	// size
-		    		read8(fd);	// precision
-		    		h = read16(fd);
-		    		w = read16(fd);
-	                if(w&1) w++;
-	                if(h&1) h++;
-		    	} 
-		    	else 
-		    	{
-		    		off = read16(fd);
-		    		if (off < 2) 
-		    		{
-		    			printf("[imageLoader]Offset too short!\n");
-		    		    fclose(fd);
-		    		    return NULL;
-		    		}
-		    		fseek(fd, off - 2, SEEK_CUR);
-		    	}
-			count++;
-		    }
-		    if (tag != 0xffc0) 
-		    {
-		    	printf("[imageLoader]Cannot fint start of frame\n");
-				fclose(fd);
-				return NULL;
-		    }
-		    printf("[imageLoader] %lu x %lu.., total Size : %u, offset %u\n", w, h,_imgSize,off);
-		    
-		// Load the binary coded image
-		    uint8_t *data=new uint8_t[_imgSize];
-		    fseek(fd, 0, SEEK_SET);
-		    fread(data,_imgSize,1,fd);
-		    fclose(fd);
-		  //
-		    
-		    ADMImage tmpImage(w,h,1); // It is a reference image
-		    // Now unpack it ...
-		    decoderFFMJPEG *decoder=new decoderFFMJPEG(w,h);
-		    ADMCompressedImage bin;
-		    bin.data=data;
-		    bin.dataLength=_imgSize; // This is more than actually, but who cares...
-		    
-		    decoder->uncompress (&bin, &tmpImage);
-		    //
-		    ADMImage *image=NULL;
-		    switch(tmpImage._colorspace)
-		    {
-		    case ADM_COLOR_YV12:
-		    {
-		    	printf("[imageLoader] YV12\n");
-	    		image=new ADMImage(w,h);
-	    		image->duplicate(&tmpImage);
-	    		break;
-		    }
-		    case ADM_COLOR_YUV422:
-		    {
-		    	printf("[imageLoader] YUY2\n");
-		    	image=new ADMImage(w,h);
-		    	COL_422_YV12(tmpImage._planes, tmpImage._planeStride,  image->data,w,h);
-		    	break;
-		    }
-		    default:
-		    	GUI_Error_HIG(QT_TR_NOOP("Wrong Colorspace"),QT_TR_NOOP("Only YV12/I420 or YUY2/I422 JPegs are supported"));
-		    }
-		    // Cannot destroy decoder earlier as tmpImage has pointers to its internals
-		    delete decoder;
-		    decoder=NULL;
-		    delete [] data;
-		    return image;		
-}
-#endif
-/**
- * 	\fn createImageFromFile_jpeg
- *  \brief Create image from Bmp
- */
-ADMImage *createImageFromFile_Bmp(const char *filename)
-{
-	
-	FILE *fd;
-	uint32_t _imgSize;
-	uint32_t w = 0, h = 0;
-    uint16_t  s16;
-    uint32_t s32;
-
-		fd = ADM_fopen(filename, "rb");
-		fseek(fd, 0, SEEK_END);
-		_imgSize = ftell(fd);
-		fseek(fd, 0, SEEK_SET);
-
-		//Retrieve width & height
-		//_______________________
-		   		ADM_BITMAPINFOHEADER bmph;
-
-			    fread(&s16, 2, 1, fd);
-			    if (s16 != 0x4D42) 
-			    {
-			    	printf("[imageLoader] incorrect bmp sig.\n");
-			    	fclose(fd);
-			    	return NULL;
-			    }
-			    fread(&s32, 4, 1, fd);
-			    fread(&s32, 4, 1, fd);
-			    fread(&s32, 4, 1, fd);
-			    fread(&bmph, sizeof(bmph), 1, fd);
-			    if (bmph.biCompression != 0) 
-			    {
-			    	printf("[imageLoader]cannot handle compressed bmp\n");
-			    	fclose(fd);
-			    	return NULL;
-			    }
-			    
-			    w = bmph.biWidth;
-			    h = bmph.biHeight;
-			    
-			    
-			    printf("[ImageLoader] BMP %u * %u\n",w,h);
-
-		// Load the binary coded image
-		    uint8_t *data=new uint8_t[w*h*3];
-		    fread(data,w*h*3,1,fd);
-		    fclose(fd);
-		    
-		  // Colorconversion
-		    
-		    	ADMImage *image=new ADMImage(w,h);
-		    	COL_RGB24_to_YV12( w, h,data,image->data);
-		    
-		    delete [] data;
-		    return image;		
-}
-/**
- * 	\fn createImageFromFile_bmp2
- *  \brief Create image from Bmp2 (BM6)
- */
-ADMImage *createImageFromFile_Bmp2(const char *filename)
-{
-    
-	ADM_BITMAPINFOHEADER bmph;
-    uint8_t fcc_tab[4];
-    uint32_t offset;
-    FILE *fd=NULL;
-    uint32_t w,h;
-
-		fd = ADM_fopen(filename, "rb");
- 	    fseek(fd, 10, SEEK_SET);
-
- #define MK32() (fcc_tab[0]+(fcc_tab[1]<<8)+(fcc_tab[2]<<16)+ \
- 						(fcc_tab[3]<<24))
-
- 	    fread(fcc_tab, 4, 1, fd);
- 	    offset = MK32();
- 	    // size, width height follow as int32 
- 	    fread(&bmph, sizeof(bmph), 1, fd);
- #ifdef ADM_BIG_ENDIAN
- 	    Endian_BitMapInfo(&bmph);
- #endif
- 	    if (bmph.biCompression != 0) 
- 	    {
- 	    	printf("[imageLoader] BMP2:Cannot handle compressed bmp\n");
- 	    	fclose(fd);
- 	    	return NULL;
- 	    }
- 	    w = bmph.biWidth;
- 	    h = bmph.biHeight;
- 	    printf("[imageLoader] BMP2 W: %d H: %d offset : %d\n", w, h, offset);
-// Load the binary coded image
- 	fseek(fd,offset,SEEK_SET);
-    uint8_t *data=new uint8_t[w*h*3];
-    fread(data,w*h*3,1,fd);
-    fclose(fd);
-    
-  // Colorconversion
-    
-    	ADMImage *image=new ADMImage(w,h);
-    	COL_RGB24_to_YV12_revert( w, h,data,image->data);
-    
-    	delete [] data;
-    	return image;		
-}
-#if 0
-/**
- * 	\fn createImageFromFile_png
- *  \brief Create image from PNG
- */
-ADMImage *createImageFromFile_png(const char *filename)
-{
-    
-	ADM_BITMAPINFOHEADER bmph;
-    uint8_t fcc_tab[4];
-    uint32_t offset,size;
-    FILE *fd=NULL;
-    uint32_t w,h;
-
-		fd = ADM_fopen(filename, "rb");
- 	    fseek(fd, 0, SEEK_END);
- 	    size=ftell(fd);
- 	   fseek(fd, 0, SEEK_SET);
- 	   read32(fd);
- 	   read32(fd);
- 	   read32(fd);
- 	   read32(fd);
- 	   w=read32(fd);
- 	   h=read32(fd);
- 	   fseek(fd,0,SEEK_SET);
- 	   uint8_t *data=new uint8_t[size];
- 	   fread(data,size,1,fd);
- 	   fclose(fd);
-    
-  
-    
- 	   ADMImage tmpImage(w,h,1);
-    	// Decode PNG
-    	decoderPng decoder(w,h);
-    	ADMCompressedImage bin;
-    	bin.data=data;
-    	bin.dataLength=size; // This is more than actually, but who cares...
-    			    
-    	decoder.uncompress (&bin, &tmpImage);
-    	
-    	ADMImage *image=new ADMImage(w,h);
-    	COL_RGB24_to_YV12( w, h,tmpImage._planes[0],image->data);
-    
-    	delete [] data;
-    	return image;		
-}
-#endif
-/**
- * 		\fn ADM_identidyImageFile
- * 		\brief Identidy image type, returns type and width/height
- */
-ADM_IMAGE_TYPE ADM_identidyImageFile(const char *filename,uint32_t *w,uint32_t *h)
-{
-			uint32_t *fcc;
-		    uint8_t fcc_tab[4];
-		    FILE *fd;
-		    uint32_t off,tag=0,count,size;
-
-		    // 1- identity the file type
-		    //
-		    fcc = (uint32_t *) fcc_tab;
-		    fd = ADM_fopen(filename, "rb");
-		    if (!fd) 
-		    {
-		    	printf("[imageIdentify] Cannot open that file!\n");
-		    	return ADM_IMAGE_UNKNOWN;
-		    }
-		    fread(fcc_tab, 4, 1, fd);
-		    fcc = (uint32_t *) fcc_tab;
-		    // 2- JPEG ?
-		    if (fcc_tab[0] == 0xff && fcc_tab[1] == 0xd8) 
-		    {
-		    			// JPEG
-		    	  			fseek(fd, 0, SEEK_SET);
-		    			    read16(fd);	// skip jpeg ffd8
-		    			    count=0;
-		    			    while (count < 10 && tag != 0xFFC0) 
-		    			    {
-
-		    			    	tag = read16(fd);
-		    			    	if ((tag >> 8) != 0xff) 
-		    			    	{
-		    			    		printf("[imageIdentify]invalid jpeg tag found (%x)\n", tag);
-		    			    	}
-		    			    	if (tag == 0xFFC0) 
-		    			    	{
-		    			    		read16(fd);	// size
-		    			    		read8(fd);	// precision
-		    			    		*h = read16(fd);
-		    			    		*w = read16(fd);
-		    		                if(*w&1) *w++;
-		    		                if(*h&1) *h++;
-		    			    	} 
-		    			    	else 
-		    			    	{
-		    			    		off = read16(fd);
-		    			    		if (off < 2) 
-		    			    		{
-		    			    			printf("[imageIdentify]Offset too short!\n");
-		    			    		    fclose(fd);
-		    			    		    return ADM_IMAGE_UNKNOWN;
-		    			    		}
-		    			    		fseek(fd, off - 2, SEEK_CUR);
-		    			    	}
-		    				count++;
-		    			    }
-		    			    fclose(fd);
-		    			    if(count>=10) return ADM_IMAGE_UNKNOWN;
-		    			    return ADM_IMAGE_JPG;
-		    }
-		    // PNG ?
-		    if (fcc_tab[1] == 'P' && fcc_tab[2] == 'N' && fcc_tab[3] == 'G') 
-			    {
-		     	    fseek(fd, 0, SEEK_SET);
-		     	    read32(fd);
-		     	    read32(fd);
-		     	    read32(fd);
-		     	    read32(fd);
-		     	    *w=read32(fd);
-		     	    *h=read32(fd);	
-		     	    fclose(fd);
-		     	    return ADM_IMAGE_PNG;
-			    }
-		    // BMP2?
-		    if (fcc_tab[0] == 'B' && fcc_tab[1] == 'M') 
-		    {
-		    	    ADM_BITMAPINFOHEADER bmph;
-
-		     	    fseek(fd, 10, SEEK_SET);
-		     	    fread(fcc_tab, 4, 1, fd);
-		     	    // size, width height follow as int32 
-		     	    fread(&bmph, sizeof(bmph), 1, fd);
-		     #ifdef ADM_BIG_ENDIAN
-		     	    Endian_BitMapInfo(&bmph);
-		     #endif
-		     	    if (bmph.biCompression != 0) 
-		     	    {
-		     	    	printf("[imageIdentify] BMP2:Cannot handle compressed bmp\n");
-		     	    	fclose(fd);
-		     	    	return ADM_IMAGE_UNKNOWN;
-		     	    }
-		     	    *w = bmph.biWidth;
-		     	    *h = bmph.biHeight;
-	     	    	fclose(fd);
-	     	    	return ADM_IMAGE_BMP2;
-		    }
-		    // Unknown filetype...
-		    fclose(fd);
-		    return ADM_IMAGE_UNKNOWN;
-}
-//EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake	2010-01-12 06:22:44 UTC (rev 5844)
+++ branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake	2010-01-13 19:51:53 UTC (rev 5845)
@@ -50,7 +50,6 @@
 ../common/gui_action.cpp
 ../common/gui_audio.cpp
 ../common/gui_blackframes.cpp
-../common/ADM_imageLoader.cpp  
 ../common/ADM_gettext.cpp
 )
 
@@ -72,6 +71,7 @@
 ADM_coreUtils6
 ADM_coreVideoEncoder6
 ADM_coreVideoFilter6
+ADM_coreImageLoader6
 ADM_libavcodec6
 ADM_libavformat6
 ADM_libavutil6

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/include/ADM_image.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/include/ADM_image.h	2010-01-12 06:22:44 UTC (rev 5844)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/include/ADM_image.h	2010-01-13 19:51:53 UTC (rev 5845)
@@ -46,15 +46,6 @@
         PLANAR_V=3
         
 } ADM_PLANE;
-typedef enum 
-{
-		ADM_IMAGE_UNKNOWN=0,
-        ADM_IMAGE_JPG=1,
-        ADM_IMAGE_PNG=2,
-        ADM_IMAGE_BMP=3,
-        ADM_IMAGE_BMP2=4
-        
-} ADM_IMAGE_TYPE;
 /**
     \class ADMImage
     \brief Stores image
@@ -191,6 +182,4 @@
 uint8_t BitBlit(uint8_t *dst, uint32_t pitchDest,uint8_t *src,uint32_t pitchSrc,uint32_t width, uint32_t height);
 uint8_t BitBlitAlpha(uint8_t *dst, uint32_t pitchDst,uint8_t *src,uint32_t pitchSrc,uint32_t width, uint32_t height,uint32_t alpha);
 
-ADMImage *createImageFromFile(const char *filename);
-ADM_IMAGE_TYPE ADM_identidyImageFile(const char *filename,uint32_t *w,uint32_t *h);
 #endif

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImageLoader/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImageLoader/CMakeLists.txt	2010-01-12 06:22:44 UTC (rev 5844)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImageLoader/CMakeLists.txt	2010-01-13 19:51:53 UTC (rev 5845)
@@ -0,0 +1 @@
+ADD_SUBDIRECTORY(src)

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImageLoader/include/ADM_imageLoader.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImageLoader/include/ADM_imageLoader.h	2010-01-12 06:22:44 UTC (rev 5844)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImageLoader/include/ADM_imageLoader.h	2010-01-13 19:51:53 UTC (rev 5845)
@@ -0,0 +1,21 @@
+/**
+    \file ADM_imageLoader
+*/
+//
+#ifndef ADM_IMAGE_LOADER
+#define ADM_IMAGE_LOADER
+#include "ADM_default.h"
+#include "ADM_image.h"
+typedef enum 
+{
+		ADM_IMAGE_UNKNOWN=0,
+        ADM_IMAGE_JPG=1,
+        ADM_IMAGE_PNG=2,
+        ADM_IMAGE_BMP=3,
+        ADM_IMAGE_BMP2=4
+        
+} ADM_IMAGE_TYPE;
+
+ADMImage *createImageFromFile(const char *filename);
+ADM_IMAGE_TYPE ADM_identidyImageFile(const char *filename,uint32_t *w,uint32_t *h);
+#endif

Copied: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImageLoader/src/ADM_imageLoader.cpp (from rev 5844, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_imageLoader.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_imageLoader.cpp	2010-01-12 06:22:44 UTC (rev 5844)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImageLoader/src/ADM_imageLoader.cpp	2010-01-13 19:51:53 UTC (rev 5845)
@@ -0,0 +1,448 @@
+/***************************************************************************
+    copyright            : (C) 2007 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "ADM_default.h"
+
+
+#include "ADM_image.h"
+#include "ADM_bitmap.h"
+#include "DIA_coreToolkit.h"
+#include "ADM_imageLoader.h"
+#include "ADM_colorspace.h"
+//**********************************
+//static ADMImage *createImageFromFile_jpeg(const char *filename);
+static ADMImage *createImageFromFile_Bmp(const char *filename);
+static ADMImage *createImageFromFile_Bmp2(const char *filename);
+//static ADMImage *createImageFromFile_png(const char *filename);
+//***********************************
+static uint8_t read8(FILE *fd)
+{
+	return fgetc(fd);
+}
+static uint32_t read16(FILE *fd)
+{
+	uint32_t a,b;
+	
+	a=fgetc(fd);
+	b=fgetc(fd);
+	return (a<<8)+b;
+		
+}
+static uint32_t read32(FILE *fd)
+{
+	uint32_t a,b,c,d;
+	
+	a=fgetc(fd);
+	b=fgetc(fd);
+	c=fgetc(fd);
+	d=fgetc(fd);
+	return (a<<24)+(b<<16)+(c<<8)+d;
+		
+}
+
+/**
+		\fn 	createImageFromFile
+		\brief 	Create and returns an ADMImage from a file, only YV12 jpg supported ATM
+
+*/
+ADMImage *createImageFromFile(const char *filename)
+{
+	uint32_t w,h;
+	switch(ADM_identidyImageFile(filename,&w,&h))
+	{
+		case  ADM_IMAGE_UNKNOWN: 
+					printf("[imageLoader] Trouble identifying /loading %s\n",filename);
+					return NULL;
+#if 0
+		case ADM_IMAGE_JPG:
+					return createImageFromFile_jpeg(filename);
+					break;
+		case ADM_IMAGE_PNG:
+					return createImageFromFile_png(filename);
+					break;
+#endif
+		case ADM_IMAGE_BMP2:
+					return createImageFromFile_Bmp2(filename);
+					break;
+		default:
+				ADM_assert(0);
+	
+	}
+	ADM_assert(0);
+}
+#if 0
+/**
+ * 	\fn createImageFromFile_jpeg
+ *  \brief Create image from jpeg file
+ */
+ADMImage *createImageFromFile_jpeg(const char *filename)
+{
+	
+	FILE *fd;
+	uint32_t _imgSize;
+	uint32_t w = 0, h = 0;
+	   
+
+		fd = ADM_fopen(filename, "rb");
+		fseek(fd, 0, SEEK_END);
+		_imgSize = ftell(fd);
+		fseek(fd, 0, SEEK_SET);
+
+		//Retrieve width & height
+		//_______________________
+		    uint16_t tag = 0, count = 0, off;
+
+		    
+		    fseek(fd, 0, SEEK_SET);
+		    read16(fd);	// skip jpeg ffd8
+		    while (count < 10 && tag != 0xFFC0) 
+		    {
+
+		    	tag = read16(fd);
+		    	if ((tag >> 8) != 0xff) 
+		    	{
+		    		printf("[imageLoader]invalid jpeg tag found (%x)\n", tag);
+		    	}
+		    	if (tag == 0xFFC0) 
+		    	{
+		    		read16(fd);	// size
+		    		read8(fd);	// precision
+		    		h = read16(fd);
+		    		w = read16(fd);
+	                if(w&1) w++;
+	                if(h&1) h++;
+		    	} 
+		    	else 
+		    	{
+		    		off = read16(fd);
+		    		if (off < 2) 
+		    		{
+		    			printf("[imageLoader]Offset too short!\n");
+		    		    fclose(fd);
+		    		    return NULL;
+		    		}
+		    		fseek(fd, off - 2, SEEK_CUR);
+		    	}
+			count++;
+		    }
+		    if (tag != 0xffc0) 
+		    {
+		    	printf("[imageLoader]Cannot fint start of frame\n");
+				fclose(fd);
+				return NULL;
+		    }
+		    printf("[imageLoader] %lu x %lu.., total Size : %u, offset %u\n", w, h,_imgSize,off);
+		    
+		// Load the binary coded image
+		    uint8_t *data=new uint8_t[_imgSize];
+		    fseek(fd, 0, SEEK_SET);
+		    fread(data,_imgSize,1,fd);
+		    fclose(fd);
+		  //
+		    
+		    ADMImage tmpImage(w,h,1); // It is a reference image
+		    // Now unpack it ...
+		    decoderFFMJPEG *decoder=new decoderFFMJPEG(w,h);
+		    ADMCompressedImage bin;
+		    bin.data=data;
+		    bin.dataLength=_imgSize; // This is more than actually, but who cares...
+		    
+		    decoder->uncompress (&bin, &tmpImage);
+		    //
+		    ADMImage *image=NULL;
+		    switch(tmpImage._colorspace)
+		    {
+		    case ADM_COLOR_YV12:
+		    {
+		    	printf("[imageLoader] YV12\n");
+	    		image=new ADMImage(w,h);
+	    		image->duplicate(&tmpImage);
+	    		break;
+		    }
+		    case ADM_COLOR_YUV422:
+		    {
+		    	printf("[imageLoader] YUY2\n");
+		    	image=new ADMImage(w,h);
+		    	COL_422_YV12(tmpImage._planes, tmpImage._planeStride,  image->data,w,h);
+		    	break;
+		    }
+		    default:
+		    	GUI_Error_HIG(QT_TR_NOOP("Wrong Colorspace"),QT_TR_NOOP("Only YV12/I420 or YUY2/I422 JPegs are supported"));
+		    }
+		    // Cannot destroy decoder earlier as tmpImage has pointers to its internals
+		    delete decoder;
+		    decoder=NULL;
+		    delete [] data;
+		    return image;		
+}
+#endif
+/**
+ * 	\fn createImageFromFile_jpeg
+ *  \brief Create image from Bmp
+ */
+ADMImage *createImageFromFile_Bmp(const char *filename)
+{
+	
+	FILE *fd;
+	uint32_t _imgSize;
+	uint32_t w = 0, h = 0;
+    uint16_t  s16;
+    uint32_t s32;
+
+		fd = ADM_fopen(filename, "rb");
+		fseek(fd, 0, SEEK_END);
+		_imgSize = ftell(fd);
+		fseek(fd, 0, SEEK_SET);
+
+		//Retrieve width & height
+		//_______________________
+		   		ADM_BITMAPINFOHEADER bmph;
+
+			    fread(&s16, 2, 1, fd);
+			    if (s16 != 0x4D42) 
+			    {
+			    	printf("[imageLoader] incorrect bmp sig.\n");
+			    	fclose(fd);
+			    	return NULL;
+			    }
+			    fread(&s32, 4, 1, fd);
+			    fread(&s32, 4, 1, fd);
+			    fread(&s32, 4, 1, fd);
+			    fread(&bmph, sizeof(bmph), 1, fd);
+			    if (bmph.biCompression != 0) 
+			    {
+			    	printf("[imageLoader]cannot handle compressed bmp\n");
+			    	fclose(fd);
+			    	return NULL;
+			    }
+			    
+			    w = bmph.biWidth;
+			    h = bmph.biHeight;
+			    
+			    
+			    printf("[ImageLoader] BMP %u * %u\n",w,h);
+
+		// Load the binary coded image
+		    uint8_t *data=new uint8_t[w*h*3];
+		    fread(data,w*h*3,1,fd);
+		    fclose(fd);
+		    
+		  // Colorconversion
+		    
+		    	ADMImage *image=new ADMImage(w,h);
+		    	COL_RGB24_to_YV12( w, h,data,image->data);
+		    
+		    delete [] data;
+		    return image;		
+}
+/**
+ * 	\fn createImageFromFile_bmp2
+ *  \brief Create image from Bmp2 (BM6)
+ */
+ADMImage *createImageFromFile_Bmp2(const char *filename)
+{
+    
+	ADM_BITMAPINFOHEADER bmph;
+    uint8_t fcc_tab[4];
+    uint32_t offset;
+    FILE *fd=NULL;
+    uint32_t w,h;
+
+		fd = ADM_fopen(filename, "rb");
+ 	    fseek(fd, 10, SEEK_SET);
+
+ #define MK32() (fcc_tab[0]+(fcc_tab[1]<<8)+(fcc_tab[2]<<16)+ \
+ 						(fcc_tab[3]<<24))
+
+ 	    fread(fcc_tab, 4, 1, fd);
+ 	    offset = MK32();
+ 	    // size, width height follow as int32 
+ 	    fread(&bmph, sizeof(bmph), 1, fd);
+ #ifdef ADM_BIG_ENDIAN
+ 	    Endian_BitMapInfo(&bmph);
+ #endif
+ 	    if (bmph.biCompression != 0) 
+ 	    {
+ 	    	printf("[imageLoader] BMP2:Cannot handle compressed bmp\n");
+ 	    	fclose(fd);
+ 	    	return NULL;
+ 	    }
+ 	    w = bmph.biWidth;
+ 	    h = bmph.biHeight;
+ 	    printf("[imageLoader] BMP2 W: %d H: %d offset : %d\n", w, h, offset);
+// Load the binary coded image
+ 	fseek(fd,offset,SEEK_SET);
+    uint8_t *data=new uint8_t[w*h*3];
+    fread(data,w*h*3,1,fd);
+    fclose(fd);
+    
+  // Colorconversion
+    
+    	ADMImage *image=new ADMImage(w,h);
+    	COL_RGB24_to_YV12_revert( w, h,data,image->data);
+    
+    	delete [] data;
+    	return image;		
+}
+#if 0
+/**
+ * 	\fn createImageFromFile_png
+ *  \brief Create image from PNG
+ */
+ADMImage *createImageFromFile_png(const char *filename)
+{
+    
+	ADM_BITMAPINFOHEADER bmph;
+    uint8_t fcc_tab[4];
+    uint32_t offset,size;
+    FILE *fd=NULL;
+    uint32_t w,h;
+
+		fd = ADM_fopen(filename, "rb");
+ 	    fseek(fd, 0, SEEK_END);
+ 	    size=ftell(fd);
+ 	   fseek(fd, 0, SEEK_SET);
+ 	   read32(fd);
+ 	   read32(fd);
+ 	   read32(fd);
+ 	   read32(fd);
+ 	   w=read32(fd);
+ 	   h=read32(fd);
+ 	   fseek(fd,0,SEEK_SET);
+ 	   uint8_t *data=new uint8_t[size];
+ 	   fread(data,size,1,fd);
+ 	   fclose(fd);
+    
+  
+    
+ 	   ADMImage tmpImage(w,h,1);
+    	// Decode PNG
+    	decoderPng decoder(w,h);
+    	ADMCompressedImage bin;
+    	bin.data=data;
+    	bin.dataLength=size; // This is more than actually, but who cares...
+    			    
+    	decoder.uncompress (&bin, &tmpImage);
+    	
+    	ADMImage *image=new ADMImage(w,h);
+    	COL_RGB24_to_YV12( w, h,tmpImage._planes[0],image->data);
+    
+    	delete [] data;
+    	return image;		
+}
+#endif
+/**
+ * 		\fn ADM_identidyImageFile
+ * 		\brief Identidy image type, returns type and width/height
+ */
+ADM_IMAGE_TYPE ADM_identidyImageFile(const char *filename,uint32_t *w,uint32_t *h)
+{
+			uint32_t *fcc;
+		    uint8_t fcc_tab[4];
+		    FILE *fd;
+		    uint32_t off,tag=0,count,size;
+
+		    // 1- identity the file type
+		    //
+		    fcc = (uint32_t *) fcc_tab;
+		    fd = ADM_fopen(filename, "rb");
+		    if (!fd) 
+		    {
+		    	printf("[imageIdentify] Cannot open that file!\n");
+		    	return ADM_IMAGE_UNKNOWN;
+		    }
+		    fread(fcc_tab, 4, 1, fd);
+		    fcc = (uint32_t *) fcc_tab;
+		    // 2- JPEG ?
+		    if (fcc_tab[0] == 0xff && fcc_tab[1] == 0xd8) 
+		    {
+		    			// JPEG
+		    	  			fseek(fd, 0, SEEK_SET);
+		    			    read16(fd);	// skip jpeg ffd8
+		    			    count=0;
+		    			    while (count < 10 && tag != 0xFFC0) 
+		    			    {
+
+		    			    	tag = read16(fd);
+		    			    	if ((tag >> 8) != 0xff) 
+		    			    	{
+		    			    		printf("[imageIdentify]invalid jpeg tag found (%x)\n", tag);
+		    			    	}
+		    			    	if (tag == 0xFFC0) 
+		    			    	{
+		    			    		read16(fd);	// size
+		    			    		read8(fd);	// precision
+		    			    		*h = read16(fd);
+		    			    		*w = read16(fd);
+		    		                if(*w&1) *w++;
+		    		                if(*h&1) *h++;
+		    			    	} 
+		    			    	else 
+		    			    	{
+		    			    		off = read16(fd);
+		    			    		if (off < 2) 
+		    			    		{
+		    			    			printf("[imageIdentify]Offset too short!\n");
+		    			    		    fclose(fd);
+		    			    		    return ADM_IMAGE_UNKNOWN;
+		    			    		}
+		    			    		fseek(fd, off - 2, SEEK_CUR);
+		    			    	}
+		    				count++;
+		    			    }
+		    			    fclose(fd);
+		    			    if(count>=10) return ADM_IMAGE_UNKNOWN;
+		    			    return ADM_IMAGE_JPG;
+		    }
+		    // PNG ?
+		    if (fcc_tab[1] == 'P' && fcc_tab[2] == 'N' && fcc_tab[3] == 'G') 
+			    {
+		     	    fseek(fd, 0, SEEK_SET);
+		     	    read32(fd);
+		     	    read32(fd);
+		     	    read32(fd);
+		     	    read32(fd);
+		     	    *w=read32(fd);
+		     	    *h=read32(fd);	
+		     	    fclose(fd);
+		     	    return ADM_IMAGE_PNG;
+			    }
+		    // BMP2?
+		    if (fcc_tab[0] == 'B' && fcc_tab[1] == 'M') 
+		    {
+		    	    ADM_BITMAPINFOHEADER bmph;
+
+		     	    fseek(fd, 10, SEEK_SET);
+		     	    fread(fcc_tab, 4, 1, fd);
+		     	    // size, width height follow as int32 
+		     	    fread(&bmph, sizeof(bmph), 1, fd);
+		     #ifdef ADM_BIG_ENDIAN
+		     	    Endian_BitMapInfo(&bmph);
+		     #endif
+		     	    if (bmph.biCompression != 0) 
+		     	    {
+		     	    	printf("[imageIdentify] BMP2:Cannot handle compressed bmp\n");
+		     	    	fclose(fd);
+		     	    	return ADM_IMAGE_UNKNOWN;
+		     	    }
+		     	    *w = bmph.biWidth;
+		     	    *h = bmph.biHeight;
+	     	    	fclose(fd);
+	     	    	return ADM_IMAGE_BMP2;
+		    }
+		    // Unknown filetype...
+		    fclose(fd);
+		    return ADM_IMAGE_UNKNOWN;
+}
+//EOF

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImageLoader/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImageLoader/src/CMakeLists.txt	2010-01-12 06:22:44 UTC (rev 5844)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImageLoader/src/CMakeLists.txt	2010-01-13 19:51:53 UTC (rev 5845)
@@ -0,0 +1,13 @@
+SET(ADM_imageLoader_SRCS 
+ADM_imageLoader.cpp
+)
+
+ADD_LIBRARY(ADM_coreImageLoader6 SHARED ${ADM_imageLoader_SRCS})
+TARGET_LINK_LIBRARIES(ADM_coreImageLoader6 
+                                          ADM_core6
+                                          ADM_coreImage6 
+                                          ADM_coreUI6
+                                          ADM_coreUtils6
+                                          ADM_coreVideoCodec6)
+include_directories(../include)
+ADM_INSTALL_LIB(ADM_coreImageLoader6)

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/CMakeLists.txt	2010-01-12 06:22:44 UTC (rev 5844)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/CMakeLists.txt	2010-01-13 19:51:53 UTC (rev 5845)
@@ -63,7 +63,7 @@
 ADD_SUBDIRECTORY(ADM_coreVideoFilter)
 ADD_SUBDIRECTORY(ADM_ffmpeg)
 ADD_SUBDIRECTORY(ADM_smjs)
-
+ADD_SUBDIRECTORY(ADM_coreImageLoader)
 ########################################
 # Config Summary
 ########################################

Modified: branches/avidemux_2.6_branch_mean/cmake/admCoreIncludes.cmake
===================================================================
--- branches/avidemux_2.6_branch_mean/cmake/admCoreIncludes.cmake	2010-01-12 06:22:44 UTC (rev 5844)
+++ branches/avidemux_2.6_branch_mean/cmake/admCoreIncludes.cmake	2010-01-13 19:51:53 UTC (rev 5845)
@@ -15,6 +15,7 @@
 INCLUDE_DIRECTORIES(${AVIDEMUX_TOP_SOURCE_DIR}/avidemux_core/ADM_coreVideoEncoder/include)
 INCLUDE_DIRECTORIES(${AVIDEMUX_TOP_SOURCE_DIR}/avidemux_core/ADM_coreVideoFilter/include)
 INCLUDE_DIRECTORIES(${AVIDEMUX_TOP_SOURCE_DIR}/avidemux_core/ADM_coreVideoCodec/include)
+INCLUDE_DIRECTORIES(${AVIDEMUX_TOP_SOURCE_DIR}/avidemux_core/ADM_coreImageLoader/include)
 INCLUDE_DIRECTORIES(${AVIDEMUX_TOP_SOURCE_DIR}/avidemux_core/ADM_ffmpeg)
 INCLUDE_DIRECTORIES(${AVIDEMUX_INCLUDE_DIR}/avidemux/2.6/)
 



From mean at mail.berlios.de  Wed Jan 13 20:51:56 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 13 Jan 2010 20:51:56 +0100
Subject: [Avidemux-svn-commit] r5846 -
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImageLoader/src
Message-ID: <201001131951.o0DJpua9030050@sheep.berlios.de>

Author: mean
Date: 2010-01-13 20:51:56 +0100 (Wed, 13 Jan 2010)
New Revision: 5846

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImageLoader/src/ADM_imageLoader.cpp
Log:
[imageLoader] Re-enable png and jpg now that the codec are in a easy to access abstraction lib

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImageLoader/src/ADM_imageLoader.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImageLoader/src/ADM_imageLoader.cpp	2010-01-13 19:51:53 UTC (rev 5845)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImageLoader/src/ADM_imageLoader.cpp	2010-01-13 19:51:56 UTC (rev 5846)
@@ -13,18 +13,18 @@
  ***************************************************************************/
 
 #include "ADM_default.h"
-
-
 #include "ADM_image.h"
 #include "ADM_bitmap.h"
 #include "DIA_coreToolkit.h"
 #include "ADM_imageLoader.h"
 #include "ADM_colorspace.h"
+#include "ADM_codec.h"
+#include "fourcc.h"
 //**********************************
-//static ADMImage *createImageFromFile_jpeg(const char *filename);
+static ADMImage *createImageFromFile_jpeg(const char *filename);
 static ADMImage *createImageFromFile_Bmp(const char *filename);
 static ADMImage *createImageFromFile_Bmp2(const char *filename);
-//static ADMImage *createImageFromFile_png(const char *filename);
+static ADMImage *createImageFromFile_png(const char *filename);
 //***********************************
 static uint8_t read8(FILE *fd)
 {
@@ -64,14 +64,12 @@
 		case  ADM_IMAGE_UNKNOWN: 
 					printf("[imageLoader] Trouble identifying /loading %s\n",filename);
 					return NULL;
-#if 0
 		case ADM_IMAGE_JPG:
 					return createImageFromFile_jpeg(filename);
 					break;
 		case ADM_IMAGE_PNG:
 					return createImageFromFile_png(filename);
 					break;
-#endif
 		case ADM_IMAGE_BMP2:
 					return createImageFromFile_Bmp2(filename);
 					break;
@@ -81,7 +79,6 @@
 	}
 	ADM_assert(0);
 }
-#if 0
 /**
  * 	\fn createImageFromFile_jpeg
  *  \brief Create image from jpeg file
@@ -153,12 +150,17 @@
 		    
 		    ADMImage tmpImage(w,h,1); // It is a reference image
 		    // Now unpack it ...
-		    decoderFFMJPEG *decoder=new decoderFFMJPEG(w,h);
+            decoders *dec=ADM_coreCodecGetDecoder (fourCC::get((uint8_t *)"MJPG"),   w,   h, 0 , NULL,0);
+            if(!dec)
+            {
+                ADM_warning("Cannot find decoder for mpjeg");
+                return NULL;
+            }
 		    ADMCompressedImage bin;
 		    bin.data=data;
 		    bin.dataLength=_imgSize; // This is more than actually, but who cares...
 		    
-		    decoder->uncompress (&bin, &tmpImage);
+		    dec->uncompress (&bin, &tmpImage);
 		    //
 		    ADMImage *image=NULL;
 		    switch(tmpImage._colorspace)
@@ -181,12 +183,11 @@
 		    	GUI_Error_HIG(QT_TR_NOOP("Wrong Colorspace"),QT_TR_NOOP("Only YV12/I420 or YUY2/I422 JPegs are supported"));
 		    }
 		    // Cannot destroy decoder earlier as tmpImage has pointers to its internals
-		    delete decoder;
-		    decoder=NULL;
+		    delete dec;
+		    dec=NULL;
 		    delete [] data;
 		    return image;		
 }
-#endif
 /**
  * 	\fn createImageFromFile_jpeg
  *  \brief Create image from Bmp
@@ -295,7 +296,6 @@
     	delete [] data;
     	return image;		
 }
-#if 0
 /**
  * 	\fn createImageFromFile_png
  *  \brief Create image from PNG
@@ -323,25 +323,28 @@
  	   uint8_t *data=new uint8_t[size];
  	   fread(data,size,1,fd);
  	   fclose(fd);
-    
-  
-    
  	   ADMImage tmpImage(w,h,1);
     	// Decode PNG
-    	decoderPng decoder(w,h);
+        decoders *dec=ADM_coreCodecGetDecoder (fourCC::get((uint8_t *)"PNG "),   w,   h, 0 , NULL,0);
+    	if(!dec)
+        {
+            ADM_warning("Cannot get PNG decoder");
+            return NULL;
+        }
     	ADMCompressedImage bin;
     	bin.data=data;
     	bin.dataLength=size; // This is more than actually, but who cares...
     			    
-    	decoder.uncompress (&bin, &tmpImage);
+    	dec->uncompress (&bin, &tmpImage);
     	
     	ADMImage *image=new ADMImage(w,h);
     	COL_RGB24_to_YV12( w, h,tmpImage._planes[0],image->data);
     
     	delete [] data;
+        delete dec;
+        dec=NULL;
     	return image;		
 }
-#endif
 /**
  * 		\fn ADM_identidyImageFile
  * 		\brief Identidy image type, returns type and width/height



From mean at mail.berlios.de  Wed Jan 13 20:52:00 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 13 Jan 2010 20:52:00 +0100
Subject: [Avidemux-svn-commit] r5847 -
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImageLoader/src
Message-ID: <201001131952.o0DJq0rU030063@sheep.berlios.de>

Author: mean
Date: 2010-01-13 20:51:59 +0100 (Wed, 13 Jan 2010)
New Revision: 5847

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImageLoader/src/ADM_imageLoader.cpp
Log:
[imageLoader] use adm_info and adm_warning rather than printf

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImageLoader/src/ADM_imageLoader.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImageLoader/src/ADM_imageLoader.cpp	2010-01-13 19:51:56 UTC (rev 5846)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImageLoader/src/ADM_imageLoader.cpp	2010-01-13 19:51:59 UTC (rev 5847)
@@ -62,7 +62,7 @@
 	switch(ADM_identidyImageFile(filename,&w,&h))
 	{
 		case  ADM_IMAGE_UNKNOWN: 
-					printf("[imageLoader] Trouble identifying /loading %s\n",filename);
+					ADM_warning("[imageLoader] Trouble identifying /loading %s\n",filename);
 					return NULL;
 		case ADM_IMAGE_JPG:
 					return createImageFromFile_jpeg(filename);
@@ -109,7 +109,7 @@
 		    	tag = read16(fd);
 		    	if ((tag >> 8) != 0xff) 
 		    	{
-		    		printf("[imageLoader]invalid jpeg tag found (%x)\n", tag);
+		    		ADM_warning("[imageLoader]invalid jpeg tag found (%x)\n", tag);
 		    	}
 		    	if (tag == 0xFFC0) 
 		    	{
@@ -125,7 +125,7 @@
 		    		off = read16(fd);
 		    		if (off < 2) 
 		    		{
-		    			printf("[imageLoader]Offset too short!\n");
+		    			ADM_warning("[imageLoader]Offset too short!\n");
 		    		    fclose(fd);
 		    		    return NULL;
 		    		}
@@ -135,11 +135,11 @@
 		    }
 		    if (tag != 0xffc0) 
 		    {
-		    	printf("[imageLoader]Cannot fint start of frame\n");
+		    	ADM_warning("[imageLoader]Cannot fint start of frame\n");
 				fclose(fd);
 				return NULL;
 		    }
-		    printf("[imageLoader] %lu x %lu.., total Size : %u, offset %u\n", w, h,_imgSize,off);
+		    ADM_info("[imageLoader] %"LU" x %"LU".., total Size : %u, offset %u\n", w, h,_imgSize,off);
 		    
 		// Load the binary coded image
 		    uint8_t *data=new uint8_t[_imgSize];
@@ -167,14 +167,14 @@
 		    {
 		    case ADM_COLOR_YV12:
 		    {
-		    	printf("[imageLoader] YV12\n");
+		    	ADM_info("[imageLoader] YV12\n");
 	    		image=new ADMImage(w,h);
 	    		image->duplicate(&tmpImage);
 	    		break;
 		    }
 		    case ADM_COLOR_YUV422:
 		    {
-		    	printf("[imageLoader] YUY2\n");
+		    	ADM_info("[imageLoader] YUY2\n");
 		    	image=new ADMImage(w,h);
 		    	COL_422_YV12(tmpImage._planes, tmpImage._planeStride,  image->data,w,h);
 		    	break;
@@ -213,7 +213,7 @@
 			    fread(&s16, 2, 1, fd);
 			    if (s16 != 0x4D42) 
 			    {
-			    	printf("[imageLoader] incorrect bmp sig.\n");
+			    	ADM_warning("[imageLoader] incorrect bmp sig.\n");
 			    	fclose(fd);
 			    	return NULL;
 			    }
@@ -223,7 +223,7 @@
 			    fread(&bmph, sizeof(bmph), 1, fd);
 			    if (bmph.biCompression != 0) 
 			    {
-			    	printf("[imageLoader]cannot handle compressed bmp\n");
+			    	ADM_warning("[imageLoader]cannot handle compressed bmp\n");
 			    	fclose(fd);
 			    	return NULL;
 			    }
@@ -232,7 +232,7 @@
 			    h = bmph.biHeight;
 			    
 			    
-			    printf("[ImageLoader] BMP %u * %u\n",w,h);
+			    ADM_info("[ImageLoader] BMP %u * %u\n",w,h);
 
 		// Load the binary coded image
 		    uint8_t *data=new uint8_t[w*h*3];
@@ -275,13 +275,13 @@
  #endif
  	    if (bmph.biCompression != 0) 
  	    {
- 	    	printf("[imageLoader] BMP2:Cannot handle compressed bmp\n");
+ 	    	ADM_warning("[imageLoader] BMP2:Cannot handle compressed bmp\n");
  	    	fclose(fd);
  	    	return NULL;
  	    }
  	    w = bmph.biWidth;
  	    h = bmph.biHeight;
- 	    printf("[imageLoader] BMP2 W: %d H: %d offset : %d\n", w, h, offset);
+ 	    ADM_info("[imageLoader] BMP2 W: %"LU" H: %"LU" offset : %"LU"\n", w, h, offset);
 // Load the binary coded image
  	fseek(fd,offset,SEEK_SET);
     uint8_t *data=new uint8_t[w*h*3];
@@ -380,7 +380,7 @@
 		    			    	tag = read16(fd);
 		    			    	if ((tag >> 8) != 0xff) 
 		    			    	{
-		    			    		printf("[imageIdentify]invalid jpeg tag found (%x)\n", tag);
+		    			    		ADM_warning("[imageIdentify]invalid jpeg tag found (%x)\n", tag);
 		    			    	}
 		    			    	if (tag == 0xFFC0) 
 		    			    	{
@@ -396,7 +396,7 @@
 		    			    		off = read16(fd);
 		    			    		if (off < 2) 
 		    			    		{
-		    			    			printf("[imageIdentify]Offset too short!\n");
+		    			    			ADM_warning("[imageIdentify]Offset too short!\n");
 		    			    		    fclose(fd);
 		    			    		    return ADM_IMAGE_UNKNOWN;
 		    			    		}
@@ -435,7 +435,7 @@
 		     #endif
 		     	    if (bmph.biCompression != 0) 
 		     	    {
-		     	    	printf("[imageIdentify] BMP2:Cannot handle compressed bmp\n");
+		     	    	ADM_warning("[imageIdentify] BMP2:Cannot handle compressed bmp\n");
 		     	    	fclose(fd);
 		     	    	return ADM_IMAGE_UNKNOWN;
 		     	    }



From mean at mail.berlios.de  Sun Jan 17 16:52:15 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 17 Jan 2010 16:52:15 +0100
Subject: [Avidemux-svn-commit] r5849 - in
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers:
	. AvsProxy
Message-ID: <201001171552.o0HFqFvn013729@sheep.berlios.de>

Author: mean
Date: 2010-01-17 16:52:14 +0100 (Sun, 17 Jan 2010)
New Revision: 5849

Added:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/ADM_avsPlugin.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/ADM_avsproxy.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/ADM_avsproxy.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/ADM_avsproxy_internal.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/ADM_avsproxy_net.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/CMakeLists.txt
Log:
[avsProxy] Import

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/ADM_avsPlugin.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/ADM_avsPlugin.cpp	2010-01-16 18:05:36 UTC (rev 5848)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/ADM_avsPlugin.cpp	2010-01-17 15:52:14 UTC (rev 5849)
@@ -0,0 +1,40 @@
+/***************************************************************************
+    copyright            : (C) 2007 by mean
+    email                : fixounet at free.fr
+    
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "ADM_default.h"
+#include "ADM_avsproxy.h"
+#include "ADM_demuxerInternal.h"
+#include "fourcc.h"
+
+ADM_DEMUXER_BEGIN( avsHeader,
+                    1,0,0,
+                    "avs",
+                    "avsProxy demuxer plugin (c) Mean 2007/2010"
+                );
+
+/**
+    \fn Probe
+*/
+
+extern "C"  uint32_t         probe(uint32_t magic, const char *fileName)
+{
+       
+    if (!strcmp(fileName,AVS_PROXY_DUMMY_FILE))
+    {
+	  printf (" [avsProxy] AvsProxy pseudo file detected...\n");
+	  return 100;
+    }
+    printf (" [avsProxy] Cannot open that\n");
+    return 0;
+}

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/ADM_avsproxy.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/ADM_avsproxy.cpp	2010-01-16 18:05:36 UTC (rev 5848)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/ADM_avsproxy.cpp	2010-01-17 15:52:14 UTC (rev 5849)
@@ -0,0 +1,200 @@
+/***************************************************************************
+    \file ADM_avsproxy.cpp
+    \author (C) 2007-2010 by mean  fixounet at free.fr
+
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "ADM_default.h"
+#include "fourcc.h"
+#include "DIA_coreToolkit.h"
+
+#include "fourcc.h"
+#include "ADM_avsproxy.h"
+#include "ADM_avsproxy_internal.h"
+
+
+/**
+    \fn avsHeader
+*/
+avsHeader::avsHeader()
+{
+    mySocket=0;
+}
+/**
+    \fn avsHeader
+*/
+
+ avsHeader::~avsHeader(  )
+{
+    close();   
+}
+
+/**
+    \fn open
+*/
+uint8_t avsHeader::open(const char *name)
+{
+    mySocket=0;
+    if(!bindMe(9999))
+    {
+        printf("[avsProxy]Open failed\n");
+        return 0;
+    }
+    // now time to grab some info
+    avsInfo info;
+    if(!askFor(AvsCmd_GetInfo,0,sizeof(info),(uint8_t*)&info))
+    {
+        printf("Get info failed\n");
+        return 0;   
+    }
+    // Build header..
+    _isaudiopresent = 0;	// Remove audio ATM
+    _isvideopresent = 1;	// Remove audio ATM
+
+#define CLR(x)              memset(& x,0,sizeof(  x));
+
+    CLR(_videostream);
+    CLR(_mainaviheader);
+
+    _videostream.dwScale = 1000;
+    _videostream.dwRate = info.fps1000;
+    _mainaviheader.dwMicroSecPerFrame = 40000;;	// 25 fps hard coded
+    _videostream.fccType = fourCC::get((uint8_t *) "YV12");
+
+    _video_bih.biBitCount = 24;
+
+    _videostream.dwLength = _mainaviheader.dwTotalFrames = info.nbFrames;
+    _videostream.dwInitialFrames = 0;
+    _videostream.dwStart = 0;
+    //
+    //_video_bih.biCompression= 24;
+    //
+    _video_bih.biWidth = _mainaviheader.dwWidth = info.width;
+    _video_bih.biHeight = _mainaviheader.dwHeight = info.height;
+    _video_bih.biCompression = _videostream.fccHandler =  fourCC::get((uint8_t *) "YV12");
+    
+    printf("Connection to avsproxy succeed\n");
+    return 1;
+}
+/**
+
+*/
+uint64_t    avsHeader::frameToTime(uint32_t frame)
+{
+
+
+}
+/**
+    \fn getFrame
+*/
+uint8_t  avsHeader::getFrame(uint32_t framenum,ADMCompressedImage *img)
+{
+    uint32_t page=(_mainaviheader.dwWidth*_mainaviheader.dwHeight*3)>>1;
+    
+    if(framenum>=_mainaviheader.dwTotalFrames)
+    {
+        ADM_warning("Avisynth proxy out of bound %u / %u\n",framenum,_mainaviheader.dwTotalFrames);
+        return 0;
+    }
+    if(!askFor(AvsCmd_GetFrame,framenum,page,img->data))
+    {
+        printf("Get frame failed for frame %u\n",framenum);
+        return 0;   
+    }
+    img->dataLength=page;
+    return 1;
+}
+/**
+    \fn getFrame
+*/
+
+  uint8_t  avsHeader::setFlag(uint32_t frame,uint32_t flags)
+{
+    return 0; // All keyframes
+}
+/**
+    \fn getFrame
+*/
+
+  uint32_t avsHeader::getFlags(uint32_t frame,uint32_t *flags)
+{
+    *flags=AVI_KEY_FRAME;
+    if(frame>=_mainaviheader.dwTotalFrames)
+    {
+        ADM_warning("Avisynth proxy out of bound %u / %u\n",frame,_mainaviheader.dwTotalFrames);
+        return 0;
+    }
+    return 1;
+}
+/**
+    \fn getTime
+*/
+
+  uint64_t avsHeader::getTime(uint32_t frame)
+{
+    if(frame>=_mainaviheader.dwTotalFrames)
+    {
+        ADM_warning("Avisynth proxy out of bound %u / %u\n",frame,_mainaviheader.dwTotalFrames);
+        return 0;
+    }
+}
+/**
+    \fn getExtraHeaderData
+*/
+
+         uint8_t  avsHeader::getExtraHeaderData(uint32_t *len, uint8_t **data)
+{
+    *len=0; 
+    *data=NULL;
+    return 1;
+}
+/**
+    \fn getVideoDuration
+*/
+
+  uint64_t avsHeader::getVideoDuration(void)
+{
+    return 1;
+}
+/**
+    \fn getPtsDts
+*/
+
+bool   avsHeader::getPtsDts(uint32_t frame,uint64_t *pts,uint64_t *dts)
+{
+    float f=frame;
+    
+    return true;
+}
+/**
+    \fn setPtsDts
+*/
+
+bool   avsHeader::setPtsDts(uint32_t frame,uint64_t pts,uint64_t dts)
+{
+    return false;
+}
+/**
+    \fn getFrameSize
+*/
+uint8_t                 avsHeader::getFrameSize(uint32_t frame,uint32_t *size)
+{
+    if(frame>=_mainaviheader.dwTotalFrames)
+    {
+        ADM_warning("Avisynth proxy out of bound %u / %u\n",frame,_mainaviheader.dwTotalFrames);
+        return 0;
+    } 
+    *size=(_mainaviheader.dwWidth*_mainaviheader.dwHeight*3)>>1;
+    return true;
+}
+//EOF
+

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/ADM_avsproxy.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/ADM_avsproxy.h	2010-01-16 18:05:36 UTC (rev 5848)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/ADM_avsproxy.h	2010-01-17 15:52:14 UTC (rev 5849)
@@ -0,0 +1,77 @@
+/***************************************************************************
+    \file ADM_avsproxy.h
+    \author (C) 2007-2010 by mean  fixounet at free.fr
+
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef AVS_PROXY_H
+#define AVS_PROXY_H
+#include "avifmt.h"
+#include "avifmt2.h"
+#include "ADM_Video.h"
+#include "ADM_audioStream.h"
+
+#define AVS_PROXY_DUMMY_FILE "::ADM_AVS_PROXY::" // warning this is duplicated in main app
+
+/**
+    \class avsHeader
+*/
+class avsHeader         :public vidHeader
+{
+    protected:
+        int         mySocket;
+        uint8_t     bindMe(uint32_t port);
+        uint8_t     sendData(uint32_t cmd,uint32_t frame, uint32_t payload_size,uint8_t *payload);
+        uint8_t     receiveData(uint32_t *cmd, uint32_t *frame,uint32_t *payload_size,uint8_t *payload);
+        uint8_t     askFor(uint32_t cmd,uint32_t frame, uint32_t payloadsize,uint8_t *payload);
+        uint8_t     rxData(uint32_t howmuch, uint8_t *where);
+        uint8_t     txData(uint32_t howmuch, uint8_t *where);
+        uint64_t    frameToTime(uint32_t frame);
+    public:
+
+
+        virtual   void 				Dump(void) {};
+
+        avsHeader( void );
+        ~avsHeader(  );
+// AVI io
+        virtual 	uint8_t			open(const char *name);
+        virtual 	uint8_t			close(void) ;
+  //__________________________
+  //				 Info
+  //__________________________
+
+  //__________________________
+  //				 Audio
+  //__________________________
+
+virtual 	WAVHeader              *getAudioInfo(uint32_t i )  ;
+virtual 	uint8_t                 getAudioStream(uint32_t i,ADM_audioStream  **audio);
+virtual     uint8_t                 getNbAudioStreams(void);
+
+  //__________________________
+  //				 video
+  //__________________________
+ virtual uint8_t  setFlag(uint32_t frame,uint32_t flags);
+ virtual uint32_t getFlags(uint32_t frame,uint32_t *flags);
+ virtual uint8_t  getFrame(uint32_t framenum,ADMCompressedImage *img);
+ virtual uint64_t getTime(uint32_t frame);
+         uint8_t  getExtraHeaderData(uint32_t *len, uint8_t **data);
+ virtual uint64_t getVideoDuration(void);
+
+virtual   bool                    getPtsDts(uint32_t frame,uint64_t *pts,uint64_t *dts);
+virtual   bool                    setPtsDts(uint32_t frame,uint64_t pts,uint64_t dts);
+
+ bool                       providePts(void) {return true;};
+virtual 	uint8_t                 getFrameSize(uint32_t frame,uint32_t *size);
+};
+#endif
+//EOF

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/ADM_avsproxy_internal.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/ADM_avsproxy_internal.h	2010-01-16 18:05:36 UTC (rev 5848)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/ADM_avsproxy_internal.h	2010-01-17 15:52:14 UTC (rev 5849)
@@ -0,0 +1,38 @@
+/** 
+	\file avsHeader.h
+	\brief Content of exchanges between avidemux and avsproxy
+
+
+*/
+#ifndef AVS_HEADER_H
+#define AVS_HEADER_H
+#define AVSHEADER_API_VERSION 2
+typedef enum AvsEnum
+{
+	AvsCmd_GetInfo=1,
+	AvsCmd_SendInfo=2,
+	AvsCmd_GetFrame=3,
+	AvsCmd_SendFrame=4,
+	AvsCmd_GetAudio=5,
+	AvsCmd_SendAudio=6,
+	AvsCmd_Quit=99
+};
+
+typedef struct avsInfo
+{
+	uint32_t version;
+	uint32_t width;
+	uint32_t height;
+	uint32_t fps1000;
+	uint32_t nbFrames;
+	uint32_t frequency;
+	uint32_t channels;
+}avsyInfo;
+
+typedef struct 
+{
+	uint32_t sizeInFloatSample;
+	uint64_t startSample;       // -1 means continue
+}avsAudioFrame;
+#endif
+

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/ADM_avsproxy_net.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/ADM_avsproxy_net.cpp	2010-01-16 18:05:36 UTC (rev 5848)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/ADM_avsproxy_net.cpp	2010-01-17 15:52:14 UTC (rev 5849)
@@ -0,0 +1,176 @@
+
+
+#ifdef __MINGW32__
+#include <windows.h>
+#include <winbase.h>
+#include <io.h>
+#include <winsock2.h>
+#else
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <math.h>
+#include <errno.h>
+#include "ADM_default.h"
+#include "ADM_avsproxy_internal.h"
+#include "ADM_avsproxy.h"
+
+#define MAGGIC 0xDEADBEEF
+
+#define aprintf(...) {}
+
+uint8_t avsHeader::bindMe(uint32_t port)
+{
+ #ifdef __MINGW32__
+ mySocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
+ #else
+ mySocket = socket(PF_INET, SOCK_STREAM, 0);
+ #endif
+    if(mySocket==-1)
+    {
+        printf("Socket failed\n");
+        return 0;
+    }
+    struct sockaddr_in  service;
+    service.sin_family = AF_INET;
+#ifdef DEBUG_NET
+    service.sin_addr.s_addr = inet_addr("192.168.0.10");
+#else
+    service.sin_addr.s_addr = inet_addr("127.0.0.1");
+#endif    
+    service.sin_port = htons(port);
+    
+    if(connect(mySocket,(struct sockaddr *)&service,sizeof(service)))
+    {
+        printf("[avsProxy]Socket connect error %d on port %d\n",errno,port);
+        return 0;
+    }
+    printf("[avsproxy]Connected to avsproxy : port %d, socket %d\n",port,mySocket);
+    return 1;
+}
+uint8_t avsHeader::close(void)
+{
+    if(mySocket)
+    {
+        int er;
+#ifdef __MINGW32__
+		er=shutdown(mySocket,SD_BOTH);
+#else
+        er=shutdown(mySocket,SHUT_RDWR);
+#endif
+        if(er) printf("[avsProxy]Error when socket shutdown  %d (socket %d)\n",er,mySocket);
+        mySocket=0;
+    }
+    return 1;
+}
+
+uint8_t avsHeader::askFor(uint32_t cmd,uint32_t frame, uint32_t payloadsize,uint8_t *payload)
+{
+   
+    if(!sendData(cmd,frame,0,NULL))
+    {
+        printf("[avsProxy]Send Cmd %u failed for frame %u\n",cmd,frame);
+        return 0;
+    }
+    // Wait reply
+    uint32_t size,reply,outframe;
+    if(!receiveData(&reply,&outframe,&size,payload))
+    {
+        printf("[avsProxy]Rx Cmd %u failed for frame %u\n",cmd,frame);
+        return 0;   
+    }
+  
+    // Check!
+    ADM_assert(outframe==frame);
+    ADM_assert(reply==cmd+1);
+    ADM_assert(size==payloadsize);
+    aprintf("[avsProxy]Cmd %u on frame %u succeed\n",cmd,frame);
+    return 1;
+    
+}
+uint8_t avsHeader::rxData(uint32_t howmuch, uint8_t *where)
+{
+uint32_t got=0;
+int rx;
+    while(got<howmuch)
+    {
+        rx=recv(mySocket,(char *)where,howmuch-got,0);
+        if(rx<0)
+        {
+          perror("RxData");
+          return 0;
+        }
+        where+=rx;
+        got+=rx;
+    }
+  return 1;
+}
+uint8_t avsHeader::txData(uint32_t howmuch, uint8_t *where)
+{
+uint32_t got=0,tx;
+    while(got<howmuch)
+    {
+        tx=send(mySocket,(char *)where,howmuch-got,0);
+         if(tx<0)
+        {
+          perror("TxData");
+          return 0;
+        }
+        where+=tx;
+        got+=tx;
+    }
+  return 1;
+}
+
+uint8_t avsHeader::receiveData(uint32_t *cmd, uint32_t *frame,uint32_t *payload_size,uint8_t *payload)
+{
+        SktHeader header;
+        memset(&header,0,sizeof(header));
+        int rx;
+
+
+        rx=rxData(sizeof(header),(uint8_t *)&header);
+       
+        *cmd=header.cmd;
+        *payload_size=header.payloadLen;
+        *frame=header.frame;
+        if(header.magic!=(uint32_t)MAGGIC)
+        {
+            printf("[avsProxy]Wrong magic %x/%x\n",header.magic,MAGGIC);
+            return 0;
+        }
+        if(header.payloadLen)
+        {
+            int togo=header.payloadLen;
+            return rxData(togo,payload);
+            
+        }
+
+        return 1;
+}
+
+
+uint8_t avsHeader::sendData(uint32_t cmd,uint32_t frame, uint32_t payload_size,uint8_t *payload)
+{
+        SktHeader header;
+        memset(&header,0,sizeof(header));
+
+        header.cmd=cmd;
+        header.payloadLen=payload_size;
+        header.frame=frame;
+        header.magic=(uint32_t)MAGGIC;
+        if(!txData(sizeof(header),(uint8_t *)&header))
+        {
+            printf("Error in senddata: header %d\n",sizeof(header));
+            return 0;
+        }
+        int togo=payload_size;
+        int chunk;
+        return txData(togo,payload);
+}

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/CMakeLists.txt	2010-01-16 18:05:36 UTC (rev 5848)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/CMakeLists.txt	2010-01-17 15:52:14 UTC (rev 5849)
@@ -0,0 +1,10 @@
+include(dm_plugin)
+SET(ADM_avsproxy_SRCS 
+	ADM_avsproxy.cpp  
+        ADM_avsproxy_net.cpp
+        ADM_avsPlugin.cpp
+)
+ADD_LIBRARY(ADM_dm_avsproxy SHARED ${ADM_avsproxy_SRCS})
+INIT_DEMUXER(ADM_dm_avsproxy)
+INSTALL_DEMUXER(ADM_dm_avsproxy)
+



From mean at mail.berlios.de  Sun Jan 17 16:52:16 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 17 Jan 2010 16:52:16 +0100
Subject: [Avidemux-svn-commit] r5850 -
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include
Message-ID: <201001171552.o0HFqGZx013739@sheep.berlios.de>

Author: mean
Date: 2010-01-17 16:52:16 +0100 (Sun, 17 Jan 2010)
New Revision: 5850

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_codecNull.h
Log:
[Decoder] Also set pts/dts for null codec

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_codecNull.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_codecNull.h	2010-01-17 15:52:14 UTC (rev 5849)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_codecNull.h	2010-01-17 15:52:16 UTC (rev 5850)
@@ -29,6 +29,16 @@
   virtual bool uncompress (ADMCompressedImage * in, ADMImage * out)
   {
     memcpy (out->data, in->data, in->dataLength);
+    uint64_t pts,dts;
+    pts=in->demuxerPts;
+    dts=in->demuxerDts;
+    if(pts!=ADM_COMPRESSED_NO_PTS)
+    {
+        out->Pts=pts;
+    }else
+    {
+        out->Pts=dts;
+    }
     return 1;
   }
 };



From mean at mail.berlios.de  Sun Jan 17 16:52:19 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 17 Jan 2010 16:52:19 +0100
Subject: [Avidemux-svn-commit] r5851 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor
Message-ID: <201001171552.o0HFqJA1013749@sheep.berlios.de>

Author: mean
Date: 2010-01-17 16:52:17 +0100 (Sun, 17 Jan 2010)
New Revision: 5851

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx
Log:
[main] Override for connect-to-avs-proxy openfile

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp	2010-01-17 15:52:16 UTC (rev 5850)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp	2010-01-17 15:52:17 UTC (rev 5851)
@@ -126,20 +126,22 @@
 
   uint8_t    ret =    0;
   aviInfo    info;
-
+  uint32_t   magic;
   _VIDEOS video;
     memset(&video,0,sizeof(video));
 
-	
-  
-    FILE *f=ADM_fopen(name,"r");
-    uint8_t buffer[4];
-    if(!f) return 0;
-    fread(buffer,4,1,f);
-    fclose(f);
-    uint32_t magic=(buffer[3]<<24)+(buffer[2]<<16)+(buffer[1]<<8)+(buffer[0]);
+	if(!strcmp(name, AVS_PROXY_DUMMY_FILE))
+        magic=0;
+    else
+    {
+        FILE *f=ADM_fopen(name,"r");
+        uint8_t buffer[4];
+        if(!f) return 0;
+        fread(buffer,4,1,f);
+        fclose(f);
+        magic=(buffer[3]<<24)+(buffer[2]<<16)+(buffer[1]<<8)+(buffer[0]);
+    }
 
-
   // First find the demuxer....
    	video._aviheader=ADM_demuxerSpawn(magic,name);
     if(!video._aviheader)

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx	2010-01-17 15:52:16 UTC (rev 5850)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx	2010-01-17 15:52:17 UTC (rev 5851)
@@ -39,7 +39,7 @@
  #include <vector>
 
 #define ADM_EDITOR_AUDIO_BUFFER_SIZE (128*1024*6*sizeof(float))
-
+#define AVS_PROXY_DUMMY_FILE "::ADM_AVS_PROXY::" 
 /**
     \enum _ENV_EDITOR_FLAGS
 */



From mean at mail.berlios.de  Sun Jan 17 16:52:20 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 17 Jan 2010 16:52:20 +0100
Subject: [Avidemux-svn-commit] r5852 -
	branches/avidemux_2.6_branch_mean/avidemux/common
Message-ID: <201001171552.o0HFqKE8013760@sheep.berlios.de>

Author: mean
Date: 2010-01-17 16:52:20 +0100 (Sun, 17 Jan 2010)
New Revision: 5852

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp
Log:
[main] Override for connect-to-avs-proxy openfile

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp	2010-01-17 15:52:17 UTC (rev 5851)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp	2010-01-17 15:52:20 UTC (rev 5852)
@@ -1279,7 +1279,7 @@
 
 
   GUI_close();
-  res = video_body->addFile ("avsproxy.avs");
+  res = video_body->addFile (AVS_PROXY_DUMMY_FILE);
   // forget last project file
   if( actual_workbench_file ){
      ADM_dealloc(actual_workbench_file);



From mean at mail.berlios.de  Sun Jan 17 16:52:23 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 17 Jan 2010 16:52:23 +0100
Subject: [Avidemux-svn-commit] r5853 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Flv
Message-ID: <201001171552.o0HFqNcx013770@sheep.berlios.de>

Author: mean
Date: 2010-01-17 16:52:23 +0100 (Sun, 17 Jan 2010)
New Revision: 5853

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Flv/ADM_flv.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Flv/ADM_flv.h
Log:
[flv demuxer] Cosmetic

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Flv/ADM_flv.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Flv/ADM_flv.cpp	2010-01-17 15:52:20 UTC (rev 5852)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Flv/ADM_flv.cpp	2010-01-17 15:52:23 UTC (rev 5853)
@@ -1,6 +1,6 @@
 /***************************************************************************
-    copyright            : (C) 2007 by mean
-    email                : fixounet at free.fr
+    \file ADM_flv.cpp
+    \author (C) 2007 by mean    email                : fixounet at free.fr
 
 
 Not sure if the timestamp is PTS or DTS (...)

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Flv/ADM_flv.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Flv/ADM_flv.h	2010-01-17 15:52:20 UTC (rev 5852)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Flv/ADM_flv.h	2010-01-17 15:52:23 UTC (rev 5853)
@@ -21,7 +21,6 @@
 #define ADM_FLV_H
 
 #include "ADM_Video.h"
-//#include "ADM_audio/aviaudio.hxx"
 #include "ADM_audioStream.h"
 
 typedef struct 



From mean at mail.berlios.de  Sun Jan 17 16:52:25 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 17 Jan 2010 16:52:25 +0100
Subject: [Avidemux-svn-commit] r5854 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy
Message-ID: <201001171552.o0HFqPqB013785@sheep.berlios.de>

Author: mean
Date: 2010-01-17 16:52:25 +0100 (Sun, 17 Jan 2010)
New Revision: 5854

Added:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/ADM_avsproxy_net.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/avsHeader.h
Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/ADM_avsproxy.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/ADM_avsproxy.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/ADM_avsproxy_internal.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/ADM_avsproxy_net.cpp
Log:
[avsproxy demuxer] Add avsproxy, using new declaration + update protocol to make room for version and later audio

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/ADM_avsproxy.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/ADM_avsproxy.cpp	2010-01-17 15:52:23 UTC (rev 5853)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/ADM_avsproxy.cpp	2010-01-17 15:52:25 UTC (rev 5854)
@@ -27,7 +27,7 @@
 */
 avsHeader::avsHeader()
 {
-    mySocket=0;
+    
 }
 /**
     \fn avsHeader
@@ -37,25 +37,52 @@
 {
     close();   
 }
-
+uint8_t avsHeader::close()
+{
+    network.close();
+    return 1;
+}
 /**
     \fn open
 */
 uint8_t avsHeader::open(const char *name)
 {
-    mySocket=0;
-    if(!bindMe(9999))
+   
+    if(!network.bindMe(9999))
     {
         printf("[avsProxy]Open failed\n");
         return 0;
     }
     // now time to grab some info
     avsInfo info;
-    if(!askFor(AvsCmd_GetInfo,0,sizeof(info),(uint8_t*)&info))
+    avsNetPacket in,out;
+    out.buffer=(uint8_t *)&info;
+    out.sizeMax=sizeof(info);
+    out.size=0;
+    typedef struct 
     {
+        uint32_t ver;
+        uint32_t api;
+    }version;
+    version v={AVSHEADER_API_VERSION,6};
+    in.buffer=(uint8_t *)&v;
+    in.size=sizeof(v);
+    in.sizeMax=sizeof(v);
+
+    if(!network.command(AvsCmd_GetInfo,0,&in,&out))
+    {
         printf("Get info failed\n");
         return 0;   
     }
+    // Dump some info
+#define PINFO(x) printf(#x":%d\n",info.x);
+    PINFO( version);
+	PINFO( width);
+	PINFO( height);
+	PINFO( fps1000);
+	PINFO( nbFrames);
+	PINFO( frequency);
+	PINFO( channels);
     // Build header..
     _isaudiopresent = 0;	// Remove audio ATM
     _isvideopresent = 1;	// Remove audio ATM
@@ -86,12 +113,17 @@
     return 1;
 }
 /**
-
+    \fn frameToTime 
+    \brief convert a give frame into time
 */
 uint64_t    avsHeader::frameToTime(uint32_t frame)
 {
-
-
+    float f=frame;
+    f*=1000000000; // Want us
+    f/=_videostream.dwRate;
+    uint64_t t=(uint64_t)f;
+    //printf("%"LU" -> %"LLU"\n",frame,t);
+    return t;
 }
 /**
     \fn getFrame
@@ -105,12 +137,21 @@
         ADM_warning("Avisynth proxy out of bound %u / %u\n",framenum,_mainaviheader.dwTotalFrames);
         return 0;
     }
-    if(!askFor(AvsCmd_GetFrame,framenum,page,img->data))
+    avsNetPacket out;
+    out.buffer=img->data;
+    out.sizeMax=page;
+    out.size=0;
+    //printf("Asking for frame %d\n",framenum);
+    if(!network.command(AvsCmd_GetFrame,framenum,NULL,&out))
     {
-        printf("Get frame failed for frame %u\n",framenum);
+        ADM_error("Get frame failed for frame %u\n",framenum);
         return 0;   
     }
+    ADM_assert(out.size==page);
     img->dataLength=page;
+    img->demuxerDts=frameToTime(framenum);
+    img->demuxerPts=img->demuxerDts;
+    //printf("Frame :%"LU" Time=%"LLU"\n",framenum,img->demuxerPts);
     return 1;
 }
 /**
@@ -146,6 +187,7 @@
         ADM_warning("Avisynth proxy out of bound %u / %u\n",frame,_mainaviheader.dwTotalFrames);
         return 0;
     }
+    return frameToTime(frame);
 }
 /**
     \fn getExtraHeaderData
@@ -163,7 +205,7 @@
 
   uint64_t avsHeader::getVideoDuration(void)
 {
-    return 1;
+    return frameToTime(_mainaviheader.dwTotalFrames);
 }
 /**
     \fn getPtsDts
@@ -171,8 +213,8 @@
 
 bool   avsHeader::getPtsDts(uint32_t frame,uint64_t *pts,uint64_t *dts)
 {
-    float f=frame;
-    
+    *pts=frameToTime(frame);
+    *dts=*pts;
     return true;
 }
 /**
@@ -196,5 +238,9 @@
     *size=(_mainaviheader.dwWidth*_mainaviheader.dwHeight*3)>>1;
     return true;
 }
+WAVHeader              *avsHeader::getAudioInfo(uint32_t i ) {return NULL;} ;
+uint8_t                 avsHeader::getAudioStream(uint32_t i,ADM_audioStream  **audio){*audio=NULL;return 0;}
+uint8_t                 avsHeader::getNbAudioStreams(void) {return 0;};
+
 //EOF
 

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/ADM_avsproxy.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/ADM_avsproxy.h	2010-01-17 15:52:23 UTC (rev 5853)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/ADM_avsproxy.h	2010-01-17 15:52:25 UTC (rev 5854)
@@ -18,7 +18,7 @@
 #include "avifmt2.h"
 #include "ADM_Video.h"
 #include "ADM_audioStream.h"
-
+#include "ADM_avsproxy_net.h"
 #define AVS_PROXY_DUMMY_FILE "::ADM_AVS_PROXY::" // warning this is duplicated in main app
 
 /**
@@ -27,21 +27,15 @@
 class avsHeader         :public vidHeader
 {
     protected:
-        int         mySocket;
-        uint8_t     bindMe(uint32_t port);
-        uint8_t     sendData(uint32_t cmd,uint32_t frame, uint32_t payload_size,uint8_t *payload);
-        uint8_t     receiveData(uint32_t *cmd, uint32_t *frame,uint32_t *payload_size,uint8_t *payload);
-        uint8_t     askFor(uint32_t cmd,uint32_t frame, uint32_t payloadsize,uint8_t *payload);
-        uint8_t     rxData(uint32_t howmuch, uint8_t *where);
-        uint8_t     txData(uint32_t howmuch, uint8_t *where);
-        uint64_t    frameToTime(uint32_t frame);
+        uint64_t                    frameToTime(uint32_t frame);
+        avsNet                      network;
     public:
 
 
         virtual   void 				Dump(void) {};
 
-        avsHeader( void );
-        ~avsHeader(  );
+                                    avsHeader( void );
+                                    ~avsHeader(  );
 // AVI io
         virtual 	uint8_t			open(const char *name);
         virtual 	uint8_t			close(void) ;
@@ -60,18 +54,18 @@
   //__________________________
   //				 video
   //__________________________
- virtual uint8_t  setFlag(uint32_t frame,uint32_t flags);
- virtual uint32_t getFlags(uint32_t frame,uint32_t *flags);
- virtual uint8_t  getFrame(uint32_t framenum,ADMCompressedImage *img);
- virtual uint64_t getTime(uint32_t frame);
-         uint8_t  getExtraHeaderData(uint32_t *len, uint8_t **data);
- virtual uint64_t getVideoDuration(void);
+ virtual uint8_t                    setFlag(uint32_t frame,uint32_t flags);
+ virtual uint32_t                   getFlags(uint32_t frame,uint32_t *flags);
+ virtual uint8_t                    getFrame(uint32_t framenum,ADMCompressedImage *img);
+ virtual uint64_t                   getTime(uint32_t frame);
+         uint8_t                    getExtraHeaderData(uint32_t *len, uint8_t **data);
+ virtual uint64_t                   getVideoDuration(void);
 
-virtual   bool                    getPtsDts(uint32_t frame,uint64_t *pts,uint64_t *dts);
-virtual   bool                    setPtsDts(uint32_t frame,uint64_t pts,uint64_t dts);
+virtual   bool                      getPtsDts(uint32_t frame,uint64_t *pts,uint64_t *dts);
+virtual   bool                      setPtsDts(uint32_t frame,uint64_t pts,uint64_t dts);
 
- bool                       providePts(void) {return true;};
-virtual 	uint8_t                 getFrameSize(uint32_t frame,uint32_t *size);
+          bool                      providePts(void) {return true;};
+virtual   uint8_t                   getFrameSize(uint32_t frame,uint32_t *size);
 };
 #endif
 //EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/ADM_avsproxy_internal.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/ADM_avsproxy_internal.h	2010-01-17 15:52:23 UTC (rev 5853)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/ADM_avsproxy_internal.h	2010-01-17 15:52:25 UTC (rev 5854)
@@ -1,38 +1,16 @@
-/** 
-	\file avsHeader.h
-	\brief Content of exchanges between avidemux and avsproxy
+/*
 
-
+(c) Mean 2006
 */
-#ifndef AVS_HEADER_H
-#define AVS_HEADER_H
-#define AVSHEADER_API_VERSION 2
-typedef enum AvsEnum
+#ifndef AVS_PROXY_INTERNAL_H
+#include "avsHeader.h"
+typedef struct SktHeader
 {
-	AvsCmd_GetInfo=1,
-	AvsCmd_SendInfo=2,
-	AvsCmd_GetFrame=3,
-	AvsCmd_SendFrame=4,
-	AvsCmd_GetAudio=5,
-	AvsCmd_SendAudio=6,
-	AvsCmd_Quit=99
-};
+    uint32_t cmd;
+    uint32_t frame;
+    uint32_t payloadLen;
+    uint32_t magic;
+}SktHeader;
 
-typedef struct avsInfo
-{
-	uint32_t version;
-	uint32_t width;
-	uint32_t height;
-	uint32_t fps1000;
-	uint32_t nbFrames;
-	uint32_t frequency;
-	uint32_t channels;
-}avsyInfo;
 
-typedef struct 
-{
-	uint32_t sizeInFloatSample;
-	uint64_t startSample;       // -1 means continue
-}avsAudioFrame;
 #endif
-

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/ADM_avsproxy_net.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/ADM_avsproxy_net.cpp	2010-01-17 15:52:23 UTC (rev 5853)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/ADM_avsproxy_net.cpp	2010-01-17 15:52:25 UTC (rev 5854)
@@ -1,5 +1,20 @@
 
+/***************************************************************************
+    \file ADM_avsproxy_net.cpp
+    \brief Handle the network part of avsproxy demuxer
+    \author (C) 2007-2010 by mean  fixounet at free.fr
 
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
 #ifdef __MINGW32__
 #include <windows.h>
 #include <winbase.h>
@@ -19,13 +34,16 @@
 #include <errno.h>
 #include "ADM_default.h"
 #include "ADM_avsproxy_internal.h"
-#include "ADM_avsproxy.h"
+#include "ADM_avsproxy_net.h"
 
 #define MAGGIC 0xDEADBEEF
 
 #define aprintf(...) {}
-
-uint8_t avsHeader::bindMe(uint32_t port)
+#define DEBUG_NET
+/**
+    \fn bindMe
+*/
+bool avsNet::bindMe(uint32_t port)
 {
  #ifdef __MINGW32__
  mySocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
@@ -40,7 +58,7 @@
     struct sockaddr_in  service;
     service.sin_family = AF_INET;
 #ifdef DEBUG_NET
-    service.sin_addr.s_addr = inet_addr("192.168.0.10");
+    service.sin_addr.s_addr = inet_addr("192.168.0.22");
 #else
     service.sin_addr.s_addr = inet_addr("127.0.0.1");
 #endif    
@@ -54,7 +72,10 @@
     printf("[avsproxy]Connected to avsproxy : port %d, socket %d\n",port,mySocket);
     return 1;
 }
-uint8_t avsHeader::close(void)
+/**
+    \fn close
+*/
+bool avsNet::close(void)
 {
     if(mySocket)
     {
@@ -69,32 +90,37 @@
     }
     return 1;
 }
-
-uint8_t avsHeader::askFor(uint32_t cmd,uint32_t frame, uint32_t payloadsize,uint8_t *payload)
+/**
+    \fn askFor
+*/
+bool avsNet::command(uint32_t cmd,uint32_t frame,avsNetPacket *in,avsNetPacket *out)
 {
-   
-    if(!sendData(cmd,frame,0,NULL))
+   avsNetPacket dummy={0,0,NULL};
+   avsNetPacket *in2=in;
+    if(!in2) in2=&dummy;
+    if(!sendData(cmd,frame,in2->size,in2->buffer))
     {
         printf("[avsProxy]Send Cmd %u failed for frame %u\n",cmd,frame);
         return 0;
     }
     // Wait reply
     uint32_t size,reply,outframe;
-    if(!receiveData(&reply,&outframe,&size,payload))
+    if(!receiveData(&reply,&outframe,&(out->size),out->buffer))
     {
         printf("[avsProxy]Rx Cmd %u failed for frame %u\n",cmd,frame);
         return 0;   
     }
   
     // Check!
-    ADM_assert(outframe==frame);
+    ADM_assert(out->size<=out->sizeMax);
     ADM_assert(reply==cmd+1);
-    ADM_assert(size==payloadsize);
     aprintf("[avsProxy]Cmd %u on frame %u succeed\n",cmd,frame);
-    return 1;
-    
+    return 1;   
 }
-uint8_t avsHeader::rxData(uint32_t howmuch, uint8_t *where)
+/**
+    \fn rxData
+*/
+bool avsNet::rxData(uint32_t howmuch, uint8_t *where)
 {
 uint32_t got=0;
 int rx;
@@ -111,7 +137,10 @@
     }
   return 1;
 }
-uint8_t avsHeader::txData(uint32_t howmuch, uint8_t *where)
+/**
+    \fn txData
+*/
+bool avsNet::txData(uint32_t howmuch, uint8_t *where)
 {
 uint32_t got=0,tx;
     while(got<howmuch)
@@ -127,8 +156,10 @@
     }
   return 1;
 }
-
-uint8_t avsHeader::receiveData(uint32_t *cmd, uint32_t *frame,uint32_t *payload_size,uint8_t *payload)
+/**
+    \fn receiveData
+*/
+bool avsNet::receiveData(uint32_t *cmd, uint32_t *frame,uint32_t *payload_size,uint8_t *payload)
 {
         SktHeader header;
         memset(&header,0,sizeof(header));
@@ -149,14 +180,14 @@
         {
             int togo=header.payloadLen;
             return rxData(togo,payload);
-            
         }
-
         return 1;
 }
 
-
-uint8_t avsHeader::sendData(uint32_t cmd,uint32_t frame, uint32_t payload_size,uint8_t *payload)
+/**
+    \fn sendData
+*/
+bool avsNet::sendData(uint32_t cmd,uint32_t frame, uint32_t payload_size,uint8_t *payload)
 {
         SktHeader header;
         memset(&header,0,sizeof(header));
@@ -167,10 +198,19 @@
         header.magic=(uint32_t)MAGGIC;
         if(!txData(sizeof(header),(uint8_t *)&header))
         {
-            printf("Error in senddata: header %d\n",sizeof(header));
+            printf("Error in senddata: header %d\n",(int)sizeof(header));
             return 0;
         }
         int togo=payload_size;
         int chunk;
         return txData(togo,payload);
 }
+avsNet::avsNet()
+{
+    mySocket=0;
+}
+avsNet::~avsNet()
+{
+    close();
+}
+//EOF

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/ADM_avsproxy_net.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/ADM_avsproxy_net.h	2010-01-17 15:52:23 UTC (rev 5853)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/ADM_avsproxy_net.h	2010-01-17 15:52:25 UTC (rev 5854)
@@ -0,0 +1,50 @@
+/***************************************************************************
+    \file ADM_avsproxy_net.h
+    \author (C) 2007-2010 by mean  fixounet at free.fr
+
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef AVS_PROXY_NET_H
+#define AVS_PROXY_NET_H
+
+typedef struct
+{
+    uint32_t size;
+    uint32_t sizeMax;
+    uint8_t  *buffer;
+}avsNetPacket;
+
+/**
+    \class avsNet
+*/
+class avsNet       
+{
+    protected:
+        int         mySocket;
+    public:
+        bool     bindMe(uint32_t port);
+        bool     sendData(uint32_t cmd,uint32_t frame, uint32_t payload_size,uint8_t *payload);
+        bool     receiveData(uint32_t *cmd, uint32_t *frame,uint32_t *payload_size,uint8_t *payload);
+        
+        bool     command(uint32_t cmd,uint32_t frame,avsNetPacket *in,avsNetPacket *out);
+        bool     rxData(uint32_t howmuch, uint8_t *where);
+        bool     txData(uint32_t howmuch, uint8_t *where);
+        bool     close(void);
+    public:
+
+
+        virtual   void 				Dump(void) {};
+
+        avsNet( void );
+        ~avsNet(  );
+};
+#endif
+//EOF

Copied: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/avsHeader.h (from rev 5853, branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/ADM_avsproxy_internal.h)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/ADM_avsproxy_internal.h	2010-01-17 15:52:23 UTC (rev 5853)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/avsHeader.h	2010-01-17 15:52:25 UTC (rev 5854)
@@ -0,0 +1,38 @@
+/** 
+	\file avsHeader.h
+	\brief Content of exchanges between avidemux and avsproxy
+
+
+*/
+#ifndef AVS_HEADER_H
+#define AVS_HEADER_H
+#define AVSHEADER_API_VERSION 2
+ enum AvsEnum
+{
+	AvsCmd_GetInfo=1,
+	AvsCmd_SendInfo=2,
+	AvsCmd_GetFrame=3,
+	AvsCmd_SendFrame=4,
+	AvsCmd_GetAudio=5,
+	AvsCmd_SendAudio=6,
+	AvsCmd_Quit=99
+};
+
+typedef struct avsInfo
+{
+	uint32_t version;
+	uint32_t width;
+	uint32_t height;
+	uint32_t fps1000;
+	uint32_t nbFrames;
+	uint32_t frequency;
+	uint32_t channels;
+}avsyInfo;
+
+typedef struct 
+{
+	uint32_t sizeInFloatSample;
+	uint64_t startSample;       // -1 means continue
+}avsAudioFrame;
+#endif
+


Property changes on: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/avsHeader.h
___________________________________________________________________
Name: svn:executable
   + *



From mean at mail.berlios.de  Sun Jan 17 16:52:27 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 17 Jan 2010 16:52:27 +0100
Subject: [Avidemux-svn-commit] r5856 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy
Message-ID: <201001171552.o0HFqR1v013810@sheep.berlios.de>

Author: mean
Date: 2010-01-17 16:52:27 +0100 (Sun, 17 Jan 2010)
New Revision: 5856

Added:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/ADM_avsproxyAudio.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/ADM_avsproxy.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/ADM_avsproxy.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/ADM_avsproxy_net.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/ADM_avsproxy_net.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/CMakeLists.txt
Log:
[avsDemuxer] Add audio + set low delay so that audio can come in quickly, we do a lot of smallish request here

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/ADM_avsproxy.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/ADM_avsproxy.cpp	2010-01-17 15:52:26 UTC (rev 5855)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/ADM_avsproxy.cpp	2010-01-17 15:52:27 UTC (rev 5856)
@@ -27,7 +27,10 @@
 */
 avsHeader::avsHeader()
 {
-    
+    haveAudio=false;
+    memset(&wavHeader,0,sizeof(wavHeader));
+    audioStream=NULL;
+    audioAccess=NULL;
 }
 /**
     \fn avsHeader
@@ -36,9 +39,17 @@
  avsHeader::~avsHeader(  )
 {
     close();   
+    
 }
+/**
+    \fn close
+*/
 uint8_t avsHeader::close()
 {
+    if(audioStream) delete audioStream;
+    if(audioAccess) delete audioAccess;
+    audioStream=NULL;
+    audioAccess=NULL;
     network.close();
     return 1;
 }
@@ -108,7 +119,28 @@
     _video_bih.biWidth = _mainaviheader.dwWidth = info.width;
     _video_bih.biHeight = _mainaviheader.dwHeight = info.height;
     _video_bih.biCompression = _videostream.fccHandler =  fourCC::get((uint8_t *) "YV12");
-    
+   
+    //
+    if(info.frequency)
+    {
+        wavHeader.frequency=info.frequency;
+        wavHeader.channels=info.channels;
+        wavHeader.bitspersample=16;
+        wavHeader.blockalign=info.channels*2;
+        wavHeader.byterate=info.frequency*2*info.channels;
+        wavHeader.encoding=WAV_PCM;
+        audioAccess=new ADM_avsAccess(&network,&wavHeader,10000);
+        _isaudiopresent=1;
+        if(audioAccess)
+            audioStream=ADM_audioCreateStream(&wavHeader,audioAccess);
+        if(audioStream)
+        {
+            ADM_info("Created audio stream\n");
+            haveAudio=true;
+        }
+        else
+            ADM_warning("Error when creating audio stream\n");
+    }
     printf("Connection to avsproxy succeed\n");
     return 1;
 }
@@ -137,6 +169,7 @@
         ADM_warning("Avisynth proxy out of bound %u / %u\n",framenum,_mainaviheader.dwTotalFrames);
         return 0;
     }
+    
     avsNetPacket out;
     out.buffer=img->data;
     out.sizeMax=page;
@@ -238,9 +271,6 @@
     *size=(_mainaviheader.dwWidth*_mainaviheader.dwHeight*3)>>1;
     return true;
 }
-WAVHeader              *avsHeader::getAudioInfo(uint32_t i ) {return NULL;} ;
-uint8_t                 avsHeader::getAudioStream(uint32_t i,ADM_audioStream  **audio){*audio=NULL;return 0;}
-uint8_t                 avsHeader::getNbAudioStreams(void) {return 0;};
 
 //EOF
 

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/ADM_avsproxy.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/ADM_avsproxy.h	2010-01-17 15:52:26 UTC (rev 5855)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/ADM_avsproxy.h	2010-01-17 15:52:27 UTC (rev 5856)
@@ -20,8 +20,39 @@
 #include "ADM_audioStream.h"
 #include "ADM_avsproxy_net.h"
 #define AVS_PROXY_DUMMY_FILE "::ADM_AVS_PROXY::" // warning this is duplicated in main app
-
 /**
+    \fn ADM_avsAccess
+*/
+class ADM_avsAccess : public ADM_audioAccess
+{
+protected:
+                      
+                avsNet           *network;
+                WAVHeader        *wavHeader;
+                uint64_t         duration;
+                uint64_t         nextSample;
+                uint8_t          *audioBuffer;
+                uint64_t         sampleToTime(uint64_t sample);
+                void             increment(uint64_t sample);
+public:
+                                  ADM_avsAccess(avsNet *net, WAVHeader *wav,uint64_t duration); 
+                virtual           ~ADM_avsAccess();
+                                    /// Hint, the stream is pure CBR (AC3,MP2,MP3)
+                virtual bool      isCBR(void) { return true;}
+                                    /// Return true if the demuxer can seek in time
+                virtual bool      canSeekTime(void) {return true;};
+                                    /// Return true if the demuxer can seek by offser
+                virtual bool      canSeekOffset(void) {return false;};
+                                    /// Return true if we can have the audio duration
+                virtual bool      canGetDuration(void) {return true;};
+                                    /// Returns audio duration in us
+                virtual uint64_t  getDurationInUs(void);
+                                    /// Go to a given time
+                virtual bool      goToTime(uint64_t timeUs);
+                virtual bool      getPacket(uint8_t *buffer, uint32_t *size, uint32_t maxSize,uint64_t *dts);
+                bool              getExtraData(uint32_t *l, uint8_t **d){*l=0;*d=NULL;return true;};
+};
+/**
     \class avsHeader
 */
 class avsHeader         :public vidHeader
@@ -29,6 +60,10 @@
     protected:
         uint64_t                    frameToTime(uint32_t frame);
         avsNet                      network;
+        WAVHeader                   wavHeader;
+        bool                        haveAudio;
+        ADM_audioStream             *audioStream;
+        ADM_avsAccess               *audioAccess;
     public:
 
 
@@ -47,9 +82,26 @@
   //				 Audio
   //__________________________
 
-virtual 	WAVHeader              *getAudioInfo(uint32_t i )  ;
-virtual 	uint8_t                 getAudioStream(uint32_t i,ADM_audioStream  **audio);
-virtual     uint8_t                 getNbAudioStreams(void);
+virtual 	WAVHeader              *getAudioInfo(uint32_t i )  
+                                    {
+                                        if(true==haveAudio) 
+                                            return &wavHeader;
+                                        return NULL;
+                                    };
+virtual 	uint8_t                 getAudioStream(uint32_t i,ADM_audioStream  **audio)
+                                    {
+                                            *audio=NULL;
+                                            if(false==haveAudio) return 0;
+                                            if(i) return 0;
+                                            *audio= audioStream;
+                                            return true;
+                                    }
+virtual     uint8_t                 getNbAudioStreams(void) 
+                                    {
+                                        if(true==haveAudio) 
+                                                return 1;
+                                        return 0;
+                                    }
 
   //__________________________
   //				 video

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/ADM_avsproxyAudio.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/ADM_avsproxyAudio.cpp	2010-01-17 15:52:26 UTC (rev 5855)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/ADM_avsproxyAudio.cpp	2010-01-17 15:52:27 UTC (rev 5856)
@@ -0,0 +1,123 @@
+/***************************************************************************
+    \file ADM_avsproxyAudio.cpp
+    \author (C) 2007-2010 by mean  fixounet at free.fr
+
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "ADM_default.h"
+#include "fourcc.h"
+#include "DIA_coreToolkit.h"
+
+#include "fourcc.h"
+#include "ADM_avsproxy.h"
+#include "ADM_avsproxy_internal.h"
+#define AVS_AUDIO_BUFFER_SIZE (48000*6*4)
+/**
+    \fn ADM_avsAccess
+*/
+ADM_avsAccess::ADM_avsAccess(avsNet *net, WAVHeader *wav,uint64_t duration)
+{
+    network=net;
+    this->wavHeader=wav;
+    this->duration=duration;
+    nextSample=0;
+    audioBuffer=new uint8_t[AVS_AUDIO_BUFFER_SIZE];
+}
+/**
+    \fn ~ADM_avsAccess
+*/
+
+ADM_avsAccess::~ADM_avsAccess()
+{
+    if(audioBuffer)
+        delete [] audioBuffer;
+    audioBuffer=NULL;
+}
+/**
+    \fn getDurationInUs
+*/
+uint64_t  ADM_avsAccess::getDurationInUs(void)
+{
+    return duration;
+}
+/**
+    \fn goToTime
+*/
+bool      ADM_avsAccess::goToTime(uint64_t timeUs)
+{
+    // convert us to sample
+    float f=timeUs;
+    f*=wavHeader->frequency;
+    f/=1000000.;
+    nextSample=(uint32_t )f;
+    return true;
+}
+/**
+    \fn sampleToTime
+*/
+uint64_t ADM_avsAccess::sampleToTime(uint64_t sample)
+{
+    float f=sample;
+    f/=wavHeader->frequency;
+    f*=1000000;
+    return (uint64_t)f;
+}
+/**
+    \fn increment
+*/
+void ADM_avsAccess::increment(uint64_t sample)
+{
+    nextSample+=sample;
+}
+/**
+    \fn getPacket
+*/
+bool      ADM_avsAccess::getPacket(uint8_t *buffer, uint32_t *size, uint32_t maxSize,uint64_t *dts)
+{
+    avsNetPacket out;
+    avsNetPacket in;
+    avsAudioFrame aFrame;
+    aFrame.startSample=nextSample;
+    
+#warning this is incorrect
+    aFrame.sizeInFloatSample=maxSize/(2*wavHeader->channels);
+    in.buffer=(uint8_t *)&aFrame;
+    in.size=sizeof(aFrame);
+
+    out.buffer=audioBuffer;
+    out.sizeMax=maxSize+sizeof(aFrame);
+    out.size=0;
+    //printf("Asking for frame %d\n",framenum);
+    if(!network->command(AvsCmd_GetAudio,0,&in,&out))
+    {
+        ADM_error("Get audio failed for frame \n");
+        return false;   
+    }
+  //  printf("Out size : %d\n",(int)out.size);
+    
+    //
+    //
+    memcpy(&aFrame,audioBuffer,sizeof(aFrame));
+   // printf("NbSample : %d\n",(int)aFrame.sizeInFloatSample);
+    if(!aFrame.sizeInFloatSample)
+    {
+        ADM_warning("Error in audio (Zero samples\n");
+        return false;
+    }
+    *dts=sampleToTime(nextSample);
+    increment(aFrame.sizeInFloatSample);
+    *size=out.size-sizeof(aFrame);
+    memcpy(buffer,audioBuffer+sizeof(aFrame),out.size-sizeof(aFrame));
+  return true;
+};
+//EOF
+

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/ADM_avsproxy_net.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/ADM_avsproxy_net.cpp	2010-01-17 15:52:26 UTC (rev 5855)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/ADM_avsproxy_net.cpp	2010-01-17 15:52:27 UTC (rev 5856)
@@ -1,4 +1,3 @@
-
 /***************************************************************************
     \file ADM_avsproxy_net.cpp
     \brief Handle the network part of avsproxy demuxer
@@ -25,6 +24,7 @@
 #include <sys/socket.h>
 #include <netinet/in.h>
 #include <arpa/inet.h>
+#include <netinet/tcp.h>
 #endif
 
 #include <stdio.h>
@@ -39,7 +39,7 @@
 #define MAGGIC 0xDEADBEEF
 
 #define aprintf(...) {}
-#define DEBUG_NET
+//#define DEBUG_NET
 /**
     \fn bindMe
 */
@@ -58,12 +58,17 @@
     struct sockaddr_in  service;
     service.sin_family = AF_INET;
 #ifdef DEBUG_NET
-    service.sin_addr.s_addr = inet_addr("192.168.0.22");
+    service.sin_addr.s_addr = inet_addr("192.168.0.21");
 #else
     service.sin_addr.s_addr = inet_addr("127.0.0.1");
 #endif    
     service.sin_port = htons(port);
     
+// Set socket to lowdelay, else it will be choppy
+    int flag = 1;
+    setsockopt( mySocket, IPPROTO_TCP, TCP_NODELAY, (char *)&flag, sizeof(flag) );
+
+
     if(connect(mySocket,(struct sockaddr *)&service,sizeof(service)))
     {
         printf("[avsProxy]Socket connect error %d on port %d\n",errno,port);
@@ -98,9 +103,11 @@
    avsNetPacket dummy={0,0,NULL};
    avsNetPacket *in2=in;
     if(!in2) in2=&dummy;
+    lock.lock();
     if(!sendData(cmd,frame,in2->size,in2->buffer))
     {
         printf("[avsProxy]Send Cmd %u failed for frame %u\n",cmd,frame);
+        lock.unlock();
         return 0;
     }
     // Wait reply
@@ -115,6 +122,7 @@
     ADM_assert(out->size<=out->sizeMax);
     ADM_assert(reply==cmd+1);
     aprintf("[avsProxy]Cmd %u on frame %u succeed\n",cmd,frame);
+    lock.unlock();
     return 1;   
 }
 /**

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/ADM_avsproxy_net.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/ADM_avsproxy_net.h	2010-01-17 15:52:26 UTC (rev 5855)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/ADM_avsproxy_net.h	2010-01-17 15:52:27 UTC (rev 5856)
@@ -14,7 +14,7 @@
  ***************************************************************************/
 #ifndef AVS_PROXY_NET_H
 #define AVS_PROXY_NET_H
-
+#include "ADM_threads.h"
 typedef struct
 {
     uint32_t size;
@@ -29,6 +29,7 @@
 {
     protected:
         int         mySocket;
+        admMutex    lock;
     public:
         bool     bindMe(uint32_t port);
         bool     sendData(uint32_t cmd,uint32_t frame, uint32_t payload_size,uint8_t *payload);

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/CMakeLists.txt	2010-01-17 15:52:26 UTC (rev 5855)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/CMakeLists.txt	2010-01-17 15:52:27 UTC (rev 5856)
@@ -3,6 +3,7 @@
 	ADM_avsproxy.cpp  
         ADM_avsproxy_net.cpp
         ADM_avsPlugin.cpp
+        ADM_avsproxyAudio.cpp
 )
 ADD_LIBRARY(ADM_dm_avsproxy SHARED ${ADM_avsproxy_SRCS})
 INIT_DEMUXER(ADM_dm_avsproxy)



From mean at mail.berlios.de  Sun Jan 17 16:52:26 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 17 Jan 2010 16:52:26 +0100
Subject: [Avidemux-svn-commit] r5855 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers
Message-ID: <201001171552.o0HFqQlG013800@sheep.berlios.de>

Author: mean
Date: 2010-01-17 16:52:26 +0100 (Sun, 17 Jan 2010)
New Revision: 5855

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/CMakeLists.txt
Log:
[demuxer] Add avsproxy demuxer

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/CMakeLists.txt	2010-01-17 15:52:25 UTC (rev 5854)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/CMakeLists.txt	2010-01-17 15:52:26 UTC (rev 5855)
@@ -6,4 +6,5 @@
 ADD_SUBDIRECTORY(MpegPS)
 ADD_SUBDIRECTORY(MpegTS)
 ADD_SUBDIRECTORY(Asf)
+ADD_SUBDIRECTORY(AvsProxy)
 #



From mean at mail.berlios.de  Sun Jan 17 17:00:13 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 17 Jan 2010 17:00:13 +0100
Subject: [Avidemux-svn-commit] r5857 -
	branches/avidemux_2.6_branch_mean/addons/avisynthproxy
Message-ID: <201001171600.o0HG0DC4014478@sheep.berlios.de>

Author: mean
Date: 2010-01-17 17:00:09 +0100 (Sun, 17 Jan 2010)
New Revision: 5857

Added:
   branches/avidemux_2.6_branch_mean/addons/avisynthproxy/vc90.idb
   branches/avidemux_2.6_branch_mean/addons/avisynthproxy/vc90.pdb
Modified:
   branches/avidemux_2.6_branch_mean/addons/avisynthproxy/avsHeader.h
   branches/avidemux_2.6_branch_mean/addons/avisynthproxy/avsproxy.cpp
   branches/avidemux_2.6_branch_mean/addons/avisynthproxy/avsproxy.vcproj
   branches/avidemux_2.6_branch_mean/addons/avisynthproxy/sket.cpp
   branches/avidemux_2.6_branch_mean/addons/avisynthproxy/sket.h
Log:
[avsproxy] new version with audio

Modified: branches/avidemux_2.6_branch_mean/addons/avisynthproxy/avsHeader.h
===================================================================
--- branches/avidemux_2.6_branch_mean/addons/avisynthproxy/avsHeader.h	2010-01-17 15:52:27 UTC (rev 5856)
+++ branches/avidemux_2.6_branch_mean/addons/avisynthproxy/avsHeader.h	2010-01-17 16:00:09 UTC (rev 5857)
@@ -1,25 +1,38 @@
-/*
+/** 
+	\file avsHeader.h
+	\brief Content of exchanges between avidemux and avsproxy
 
 
-
 */
 #ifndef AVS_HEADER_H
 #define AVS_HEADER_H
+#define AVSHEADER_API_VERSION 2
 typedef enum AvsEnum
 {
 	AvsCmd_GetInfo=1,
-	AvsCmd_SendInfo,
-	AvsCmd_GetFrame,
-	AvsCmd_SendFrame,
-	AvsCmd_Quit
+	AvsCmd_SendInfo=2,
+	AvsCmd_GetFrame=3,
+	AvsCmd_SendFrame=4,
+	AvsCmd_GetAudio=5,
+	AvsCmd_SendAudio=6,
+	AvsCmd_Quit=99
 };
 
 typedef struct avsInfo
 {
+	uint32_t version;
 	uint32_t width;
 	uint32_t height;
 	uint32_t fps1000;
 	uint32_t nbFrames;
+	uint32_t frequency;
+	uint32_t channels;
 }avsyInfo;
+
+typedef struct 
+{
+	uint32_t sizeInFloatSample;
+	uint64_t startSample;       // -1 means continue
+}avsAudioFrame;
 #endif
 

Modified: branches/avidemux_2.6_branch_mean/addons/avisynthproxy/avsproxy.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/addons/avisynthproxy/avsproxy.cpp	2010-01-17 15:52:27 UTC (rev 5856)
+++ branches/avidemux_2.6_branch_mean/addons/avisynthproxy/avsproxy.cpp	2010-01-17 16:00:09 UTC (rev 5857)
@@ -5,14 +5,9 @@
 // the Free Software Foundation; either version 2 of the License, or
 // (at your option) any later version.
 
-/* #include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <io.h>
-#include <fcntl.h>
-#include <windef.h>*/
 
 #define __int64_t long long int
+#define uint64_t long long unsigned int
 
 #include "internal.h"
 #include "sket.h"
@@ -22,33 +17,37 @@
 #define INT_MAX 0x7fffffff
 #endif
 
-#define MY_VERSION "Avs2YUV 0.24 ADM_0.1"
+#define MY_VERSION "Avs2YUV 0.24 ADM_1.1"
 #define MAX_FH 10
-
 #include "winsock2.h"
-	int vid_width=-1;
-	int vid_height=-1;
-	int vid_fps1000=-1;
-	int vid_nbFrame=-1;
-	uint32_t currentFrame=0xFFFF0000;
-	char *Buffer;
+#define Log printf
+/******************************************/
+int vid_width=-1;
+int vid_height=-1;
+int vid_fps1000=-1;
+int vid_nbFrame=-1;
+uint32_t currentFrame=0xFFFF0000;
+char *Buffer;
 
-static int framePack(PVideoFrame p);
-static void handleError(void);
-static uint8_t initAvisynth(const char *infile);
-
-
-
 PVideoFrame Aframe=NULL;
 IScriptEnvironment* env =NULL;
 PClip clip =NULL;
 avsyInfo    info;
 
+/*****************************************/
+static int framePack(PVideoFrame p);
+static void handleError(void);
+static bool initAvisynth(const char *infile);
 
+
+/**
+	\fn main
+*/
 int __cdecl main(int argc, const char* argv[])
 {
 	const char* infile = NULL;
-	
+	char *audioBuffer=new char[48000*6*2];
+	char *audioBufferData=audioBuffer+sizeof(avsAudioFrame);
 
 	printf("AvsSocket Proxy, derivated from avs2yuv by  Loren Merritt \n");
 	fflush(stdout);
@@ -134,14 +133,53 @@
 					case AvsCmd_GetInfo:
 							printf("Received get info...\n");
 							fflush(stdout);
+							if(len!=8)
+							{
+									// Version
+									printf("This version of avsproxy is not compatible with the avidemux version you are using\n");
+									fflush(stdout);
+									exit( -1);
+							}
+							uint32_t api,ver;
+							api=*(uint32_t *)payload;
+							ver=*(uint32_t *)(payload+4);
+							printf("Connection from avidemux, api=%d version=%d\n",api,ver);
+							if(api!=AVSHEADER_API_VERSION)
+							{
+									printf("This version of avsproxy has api version %d, avidemux has version %d, exiting\n",AVSHEADER_API_VERSION,api);
+									fflush(stdout);
+									exit(-1);
+							}
 							sket->sendData(AvsCmd_SendInfo,0,sizeof(info),(uint8_t *)&info);
 							break;
+					case AvsCmd_GetAudio:
+							// Read payload
+							if(len!=sizeof(avsAudioFrame))
+							{
+									printf("get audio command, expected %d bytes , got %d \n",sizeof(avsAudioFrame),len);
+									fflush(stdout);
+									exit(-1);	
+							}
+							avsAudioFrame aFrame;
+							memcpy(&aFrame,payload,len);
+							// Read...
+							try {
+								clip->GetAudio(audioBufferData, aFrame.startSample, aFrame.sizeInFloatSample, env);
+							}catch(AvisynthError err) 
+							{
+								fprintf(stderr, "Get Audio :Avisynth error:\n%s\n", err.msg);	
+							    aFrame.sizeInFloatSample=0;
+							}
+							// Send reply...
+							memcpy(audioBuffer,&aFrame,sizeof(aFrame));
+							sket->sendData(AvsCmd_SendAudio,0,aFrame.sizeInFloatSample*2*info.channels+sizeof(aFrame),(uint8_t *)audioBuffer);
+							break;
 					case AvsCmd_GetFrame:
 							if(currentFrame!=frame)
 							{
 								
 							try{
-								printf("Get frame %u (old:%u)\n",frame,currentFrame);
+								Log("Get frame %u (old:%u)\n",frame,currentFrame);
 								fflush(stdout);
 								Aframe= clip->GetFrame(frame, env);
 								framePack(Aframe);	
@@ -175,12 +213,12 @@
 			}
 
 
-		}
-
-		//get(currentFrame);
-	
+		}	
 }
-
+/**
+	\fn framePack
+	\brief Pack a video frame inside our buffer
+*/
 int framePack(PVideoFrame p)
 {
 			int w,stride;
@@ -222,7 +260,9 @@
 			}
 			return 1;
 }
-
+/**
+	\fn handleError
+*/
 void handleError(void)
 {
 	DWORD er=GetLastError();
@@ -231,10 +271,12 @@
 	exit(-1);
 
 }
-#if 1
+/**
+	\fn initAvisynth
+*/
 typedef IScriptEnvironment * __stdcall DLLFUNC(int);
 
-uint8_t initAvisynth(const char *infile)
+bool initAvisynth(const char *infile)
 {
 		HMODULE instance;
 		DLLFUNC *CreateScriptEnvironment=NULL;
@@ -247,7 +289,7 @@
 			handleError();
 			fprintf(stderr, "failed to load avisynth.dll\n"); 
 			fflush(stderr);
-			return 2;
+			return false;
 		}
 		printf("Avisynth.dll loaded\n");
 		fflush(stdout);
@@ -255,12 +297,18 @@
 		printf("Env created\n");
 		fflush(stdout);
 		if(!CreateScriptEnvironment)
-			{fprintf(stderr, "failed to load CreateScriptEnvironment()\n"); fflush(stderr); return 1;}
+		{
+			fprintf(stderr, "failed to load CreateScriptEnvironment()\n"); 
+			fflush(stderr); 
+			return false;
+		}
 try{
 		env = CreateScriptEnvironment(AVISYNTH_INTERFACE_VERSION);
 		if(!env)
 		{
-			{fprintf(stderr, "Env failed\n"); fflush(stderr); return 1;}
+			fprintf(stderr, "Env failed\n"); 
+			fflush(stderr); 
+			return false;
 		}
 		AVSValue args[]={infile};
 		printf("Importing..\n");
@@ -269,7 +317,9 @@
 		clip=dummy;
 
 		VideoInfo inf = clip->GetVideoInfo();
-	
+	    memset(&info,0,sizeof(info));
+		info.version=AVSHEADER_API_VERSION;
+		// Video part
 		info.width=vid_width=inf.width;
 		info.height=vid_height=inf.height;
 		info.fps1000=vid_fps1000=(inf.fps_numerator*1000)/inf.fps_denominator;
@@ -280,59 +330,52 @@
 		f/=inf.fps_denominator;
 		vid_fps1000=info.fps1000=(uint32_t)ceil(f);
 		info.nbFrames=vid_nbFrame=inf.num_frames;
-		
+		// audio part
+		info.frequency=inf.SamplesPerSecond(); // 0 means no audio
+		info.channels=inf.AudioChannels();
+		if(inf.SampleType()!=SAMPLE_INT16)
+		{
+			printf("Only int16 for audio and not %d!\n",(int)inf.SampleType());
+			fflush(stdout);
+			handleError();
+			return false;	
+		}
 		if(!inf.IsYV12()) 
 		{
 			printf("Only yv12!\n");
 			fflush(stdout);
 			handleError();
+			return false;
 		}
 		if(!inf.IsYV12())
-			{fprintf(stderr, "Couldn't convert input to YV12\n"); fflush(stderr); return 1;}
+			{fprintf(stderr, "Couldn't convert input to YV12\n"); fflush(stderr); return false;}
 		if(inf.IsFieldBased())
-			{fprintf(stderr, "Needs progressive input\n"); fflush(stderr); return 1;}
+			{fprintf(stderr, "Needs progressive input\n"); fflush(stderr); return false;}
 
 	
 		// Incoming ready
-		printf("Info\n");
-		printf("Width   :%d \n",vid_width);
-		printf("Height  :%d \n",vid_height);
-		printf("Fps1K   :%d \n",vid_fps1000);
-		printf("NbFrame :%d \n",vid_nbFrame);
+		printf("Clip Info\n");
+		printf("_________\n");
+		printf("Width     :%d \n",vid_width);
+		printf("Height    :%d \n",vid_height);
+		printf("Fps1K     :%d \n",vid_fps1000);
+		printf("NbFrame   :%d \n",vid_nbFrame);
+		printf("Frequency :%d \n",info.frequency);
+		printf("#channels :%d \n",info.channels);
 		fflush(stdout);
+		return true;
 }
 catch(AvisynthError err) {
 		
 			fprintf(stderr, "\nAvisynth error:\n%s\n", err.msg);
 			fflush(stderr);
-		return 1;
+		return false;
 	}
 
 
 
-		return 1;
+		return true;
 }
 
-#else
-typedef IScriptEnvironment * __stdcall FUNC(int);
-uint8_t initAvisynth(const char *infile)
-{
-HINSTANCE lib = LoadLibrary("avisynth.dll");
-FUNC *func = (FUNC *)GetProcAddress(lib, "CreateScriptEnvironment");
-IScriptEnvironment *env = func(AVISYNTH_INTERFACE_VERSION);
-
-{
-	AVSValue args[] = { infile };
-	PClip clip(env->Invoke("Import", AVSValue(args, 1)).AsClip());
-	const VideoInfo& vi = clip->GetVideoInfo();
-
-	printf("%d %d %d", vi.width, vi.height, vi.BitsPerPixel());
-}
-
-delete env;
-FreeLibrary(lib);
-return 1;
-}
-#endif
 //EOF
 

Modified: branches/avidemux_2.6_branch_mean/addons/avisynthproxy/avsproxy.vcproj
===================================================================
--- branches/avidemux_2.6_branch_mean/addons/avisynthproxy/avsproxy.vcproj	2010-01-17 15:52:27 UTC (rev 5856)
+++ branches/avidemux_2.6_branch_mean/addons/avisynthproxy/avsproxy.vcproj	2010-01-17 16:00:09 UTC (rev 5857)
@@ -1,10 +1,11 @@
 <?xml version="1.0" encoding="Windows-1252"?>
 <VisualStudioProject
 	ProjectType="Visual C++"
-	Version="8.00"
+	Version="9,00"
 	Name="avsproxy"
 	ProjectGUID="{FDA95A7F-919C-4343-96C6-FB0F59FFE5B0}"
 	RootNamespace="avsproxy"
+	TargetFrameworkVersion="131072"
 	>
 	<Platforms>
 		<Platform
@@ -77,6 +78,8 @@
 				SuppressStartupBanner="true"
 				ProgramDatabaseFile="./avsproxy.pdb"
 				SubSystem="1"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
 				TargetMachine="1"
 			/>
 			<Tool
@@ -98,9 +101,6 @@
 				Name="VCAppVerifierTool"
 			/>
 			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
 				Name="VCPostBuildEventTool"
 			/>
 		</Configuration>
@@ -170,6 +170,8 @@
 				GenerateDebugInformation="true"
 				ProgramDatabaseFile="./avsproxy.pdb"
 				SubSystem="1"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
 				TargetMachine="1"
 			/>
 			<Tool
@@ -191,9 +193,6 @@
 				Name="VCAppVerifierTool"
 			/>
 			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
 				Name="VCPostBuildEventTool"
 			/>
 		</Configuration>

Modified: branches/avidemux_2.6_branch_mean/addons/avisynthproxy/sket.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/addons/avisynthproxy/sket.cpp	2010-01-17 15:52:27 UTC (rev 5856)
+++ branches/avidemux_2.6_branch_mean/addons/avisynthproxy/sket.cpp	2010-01-17 16:00:09 UTC (rev 5857)
@@ -1,17 +1,21 @@
-/*
+/**
+	\file sket.cpp
+	\brief Socket handling
+	\author mean fixounet at free.fr
 
+*/
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
 
 
-*/
-
+//#define DEBUG
 #include <stdio.h>
 #include "sket.h"
 
 Sket::Sket(void)
 {
-
-
-
 	mySocket=0;
 	port=9999;
 
@@ -20,19 +24,49 @@
   sockaddr_in service;
   service.sin_family = AF_INET;
 #ifdef DEBUG
-  service.sin_addr.s_addr = inet_addr("192.168.0.10");
+	// Get the local host information
+  hostent* localHost;
+  char* localIP;
+	localHost = gethostbyname("");
+	localIP = inet_ntoa (*(struct in_addr *)*localHost->h_addr_list);
+	service.sin_addr.s_addr = inet_addr(localIP);
+	printf("Binding ...\n");
+	int ip=service.sin_addr.s_addr;
+	for(int i=0;i<4;i++)
+	{
+			printf("%d ",ip&0xff);
+		    ip>>=8;
+	}
+	printf("\n");
 #else
-  service.sin_addr.s_addr = inet_addr("127.0.0.1");
+	#define BIND_ADR "127.0.0.1"
+    service.sin_addr.s_addr = inet_addr(BIND_ADR);
+	printf("Binding on %s\n",BIND_ADR);
 #endif
+  
+  
   service.sin_port = htons(port);
 
-   if (bind( mySocket,   (SOCKADDR*) &service,  sizeof(service)) == SOCKET_ERROR) 
-   {
-    printf("bind() failed to port %u \n",port);
-	fflush(stdout);
-    closesocket(mySocket);
-	mySocket=0;
-    exit(-1);
+
+  int one=true;
+  if (bind( mySocket,   (SOCKADDR*) &service,  sizeof(service)) == SOCKET_ERROR) 
+  {
+	int opt=setsockopt(mySocket,
+				SOL_SOCKET,
+				SO_REUSEADDR,
+				(char *)&one,sizeof(one));
+	printf("Trying to use SO_REUSEADDR\n");
+	if(opt) printf("Error in setsockopt:%d\n",opt);
+  
+	  // Retry with SO_REUSEADDR set...
+	   if (bind( mySocket,   (SOCKADDR*) &service,  sizeof(service)) == SOCKET_ERROR) 
+	   {
+		printf("bind() failed to port %u \n",port);
+		fflush(stdout);
+		closesocket(mySocket);
+		mySocket=0;
+		exit(-1);
+	  }
   }
    // Set high buffer + low delay
   printf("Socket bound to port %u\n",port);
@@ -82,10 +116,10 @@
 	SktHeader header;
 	memset(&header,0,sizeof(header));
 
-
-	if( sizeof(header)!=recv(workSocket,(char *)&header,sizeof(header),0))
+	int rx=recv(workSocket,(char *)&header,sizeof(header),0);
+	if( sizeof(header)!=rx)
 	{
-		printf("Error in receivedata: header\n");
+		printf("Error in receivedata: header, expected %d, received %d\n",(int) sizeof(header),rx);
 		fflush(stdout);
 		exit(-1);
 	}

Modified: branches/avidemux_2.6_branch_mean/addons/avisynthproxy/sket.h
===================================================================
--- branches/avidemux_2.6_branch_mean/addons/avisynthproxy/sket.h	2010-01-17 15:52:27 UTC (rev 5856)
+++ branches/avidemux_2.6_branch_mean/addons/avisynthproxy/sket.h	2010-01-17 16:00:09 UTC (rev 5857)
@@ -7,7 +7,7 @@
 #include "proxytype.h"
 #ifndef SKET_H
 #define SKET_H
-
+#define DEBUG
 #define MAGGIC 0xDEADBEEF
 
 typedef struct SktHeader

Added: branches/avidemux_2.6_branch_mean/addons/avisynthproxy/vc90.idb
===================================================================
--- branches/avidemux_2.6_branch_mean/addons/avisynthproxy/vc90.idb	2010-01-17 15:52:27 UTC (rev 5856)
+++ branches/avidemux_2.6_branch_mean/addons/avisynthproxy/vc90.idb	2010-01-17 16:00:09 UTC (rev 5857)
@@ -0,0 +1,82 @@
+Microsoft C/C++ MSF 7.00
+DS

+
+
+
+

+
+
+
+
+
+
+
+
+

dks\windows\v6.0a\include\ktmtypes.h
inversedeps/c:\program files (x86)\microsoft visual studio 9.0\vc\include\vadefs.h


files\microsoft sdks\windows\v6.0a\include\winsmcrd.h
oft sdks\windows\v6.0a\include\ktmtypes.h


r/inversedeps/c:\program files\microsoft sdks\windows\v6.0a\include\guiddef.h
ef.h
+
+
xception
+
+
+
+
+
+
+
+
+
+
nversedeps/c:\program files (x86)\microsoft visual studio 9.0\vc\include\climits
m files (x86)\microsoft visual studio 9.0\vc\include\vector
S
+
+
+
+

m files\microsoft sdDRS 8

lude\xstddef

+
+
+
+
+
+


















+
+
+
+
\program files\microsoft sdks\windows\v6.0a\include\specstrings_undef.h
program files\microsoft sdks\windows\v6.0a\include\rpcnterr.h
c:\program files\microsoft sdks\windows\v6.0a\include\commdlg.h
+
+
+
+
+
+
+
+
+
+
+
+

.h
soft sdks\windows\v6.0a\include\bcrypt.h
nclude\windef.h
s/c:\program files (x86)\microsoft visual studio 9.0\vc\include\codeanalysis\sourceannotations.h
+
+
+
+
+
mr/inversedeps/c:\program files (x86)\microsoft visual studio 9.0\vc\include\vadefs.h
 files\microsoft sdks\windows\v6.0a\include\winsmcrd.h

+
+
+
+
+
















































+
+
s\v6.0a\include\commdlg.h
ual studio 9.0\vc\include\xstddef
+
+
+
+

+
+
+
+
+
+
+
+
+
poppack.h
/d:\avidemux_2.6_branch_mean\addons\avisynthproxy\sket.h
dows\v6.0a\include\winsock.h
rsedeps/c:\program files\microsoft sdks\windows\v6.0a\include\guiddef.h
gram files (x86)\microsoft visual studio 9.0\vc\include\vector

+
+
+
+




\ No newline at end of file


Property changes on: branches/avidemux_2.6_branch_mean/addons/avisynthproxy/vc90.idb
___________________________________________________________________
Name: svn:executable
   + *

Added: branches/avidemux_2.6_branch_mean/addons/avisynthproxy/vc90.pdb
===================================================================
--- branches/avidemux_2.6_branch_mean/addons/avisynthproxy/vc90.pdb	2010-01-17 15:52:27 UTC (rev 5856)
+++ branches/avidemux_2.6_branch_mean/addons/avisynthproxy/vc90.pdb	2010-01-17 16:00:09 UTC (rev 5857)
@@ -0,0 +1,1187 @@
+Microsoft C/C++ MSF 7.00
+DS

?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????!
 ????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????!
 ??????????????????????????????????????????????????????????????!
 ????????
?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????!
 ????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????!
 ?????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????!
 ????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????!
 ??????????????????????????????????????????????????????????????!
 ????????
?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????!
 ????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????!
 ???????????????????????????????????????????????????????

+
+
+?
+
+
+?
+
+?
+
+?
+
+
+?
+
+?
+
+
+
+?
+
+
+
+?
+
+
+
+?
+
+?
+
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+
+
+?
+
+
+?
+
+?
+
+?
+
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+
+
+
+
+?
+
+
+
+?
+
+
+
+
+
+
+
+?
+
+
+
+
+
+?
+
+
+?
+
+?
+
+?
+
+?
+
+
+
+
+
+?
+
+
+?
+
+?
+
+?
+
+?
+
+?
+
+
+
+
+?
+
+
+
+?
+
+?
+
+?
+
+
+?
+
+?
+
+
+?
+
+
+
+
+?
+
+?
+
+
+
+
+?
+
+
+
+
+
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+
+
+
+
+?
+
+
+
+
+?
+
+
+
+
+?
+
+
+?
+
+
+?
+
+
+?
+
+
+
+
+
+?
+
+
+
+
+
+?
+
+?
+
+?
+
+
+?
+
+
+?
+
+?
+
+?
+
+?
+
+
+
+?
+
+?
+
+
+?
+
+?
+
+?
+
+
+
+
+
+
+
+?
+
+
+?
+
+?
+
+
+
+
+?
+
+
+?
+
+?
+
+?
+
+?
+
+
+
+
+
+?
+
+?
+
+
+
+?
+
+
+?
+
+
+?
+
+?
+
+
+
+?
+
+
+?
+
+?
+
+?
+
+
+
+
+?
+
+?
+
+
+
+
+
+
+?
+
+?
+
+?
+
+?
+
+?
+
+
+
+
+
+
+
+
+?


+
+?
+
+
+
+
+
+
+
+?
+
+
+
+?
+
+?
+
+
+
+
+
+
+
+?
+
+?
+
+
+?
+
+?
+
+?
+
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+
+
+
+
+
+
+
+
+?
+
+?
+
+?
+
+
+?
+
+?
+
+
+
+?
+
+
+
+
+
+
+
+
+?
+
+?
+
+
+?
+
+
+
+
+
+
+
+
+
+

C@@
+
+?
+
+?
+
+?
+
+?
+
+
+
+
+
+
+
+
+?
+
+
+
+
+
+
EGER@@
+
+
+?
+
+?
+
+?
+
+?
+
+?
+
+
+
+
+
+
+
+
+
+
+?
+
+?
+
+
+?
+
+?
+
+?
+
+?
+
+?
+
+
+
+?


+

+
+
+?
+
+?
+
+
+?
+
+?
+
+
+
+?
+
+
+
+?
+
+
+
+?
+
+?
+
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+
+
+?
+
+
+?
+
+?
+
+?
+
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+


+

+
+
+
+
+
+?
+
+
+
+?
+
+
+
+
+
+
+
+
+?
+
+
+
+
+
+?
+
+?
+
+?
+
+
+
+
+
+?
+
+?
+
+
+
+
+
+?
+
+
+
+
+
+?
+
+
+
+
+
+?
+
+
+
+
+?
+
+
+?
+
+
+
+
+
+?
+
+?
+
+
+
+
+
+?
+
+
+
+
+
+
+?
+
+
+
+?
+
+?
+
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+
+?
+
+?
+
+
+
+
+?
+
+?
+
+?
+
+
+
+
+?
+
+
+
+
+?
+
+?
+
+
+?
+
+
+
+?
+
+?
+
+?
+
+?
+
+
+
+
+
+?
+
+?
+
+?
+
+?
+
+?
+
+
+
+
+?
+
+
+?
+
+
+?
+
+?
+
+?
+
+
+?
+
+?
+
+
+?
+
+
+?
+
+?
+
+?
+
+
+
+
+
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+
+
+
+
+?
+
+?
+
+?
+
+?
+
+
+?
+
+
+
+
+
+
+
+?
+
+?
+
+?
+
+?
+
+
+?
+
+?
+
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+
+?
+
+
+?
+
+
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+
+
+?
+
+?
+
+
+
+?
+
+
+
+?
+
+
+
+?
+
+
+
+?
+
+
+?
+
+?
+
+
+?
+
+
+?
+
+?
+
+
+
+
+
+
+
+?
+
+
+?
+
+
+?
+
+
+?
+
+
_30@@
+
+?
+
+
+
+
+?
+
+
+
+
+
+?
+
+?
+

+
+
+
+
+p
+I
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+?
+
+
+?
+
+?
+
+?
+
+
+?
+
+?
+
+
+
+?
+
+
+
+?
+
+
+
+?
+
+?
+
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+
+
+?
+
+
+?
+
+?
+
+?
+
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+

+
+
+?
+
+
+?
+
+?
+
+?
+
+
+?
+
+?
+
+
+
+?
+
+
+
+?
+
+
+
+?
+
+?
+
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+
+
+?
+
+
+?
+
+?
+
+?
+
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?
+
+?


+



\ No newline at end of file


Property changes on: branches/avidemux_2.6_branch_mean/addons/avisynthproxy/vc90.pdb
___________________________________________________________________
Name: svn:executable
   + *



From mean at mail.berlios.de  Mon Jan 18 19:40:03 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Mon, 18 Jan 2010 19:40:03 +0100
Subject: [Avidemux-svn-commit] r5858 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_avsproxy
Message-ID: <201001181840.o0IIe381002746@sheep.berlios.de>

Author: mean
Date: 2010-01-18 19:40:01 +0100 (Mon, 18 Jan 2010)
New Revision: 5858

Added:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_avsproxy/ADM_avsproxyAudio.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_avsproxy/ADM_avsproxy_net.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_avsproxy/avsHeader.h
Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_avsproxy/ADM_avsproxy.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_avsproxy/ADM_avsproxy.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_avsproxy/ADM_avsproxy_internal.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_avsproxy/ADM_avsproxy_net.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_avsproxy/CMakeLists.txt
Log:
[avsproxy] Sync with avsproxy from 2.6, part 1, no audio

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_avsproxy/ADM_avsproxy.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_avsproxy/ADM_avsproxy.cpp	2010-01-17 16:00:09 UTC (rev 5857)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_avsproxy/ADM_avsproxy.cpp	2010-01-18 18:40:01 UTC (rev 5858)
@@ -1,56 +1,100 @@
-/*
+/***************************************************************************
+    \file ADM_avsproxy.cpp
+    \author (C) 2007-2010 by mean  fixounet at free.fr
 
-(c) Mean 2006
-*/
-#include "config.h"
+ ***************************************************************************/
 
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <math.h>
-#include <errno.h>
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
 
-#include "ADM_assert.h"
 #include "ADM_default.h"
-#include "ADM_editor/ADM_Video.h"
+#include "fourcc.h"
+#include "DIA_coreToolkit.h"
 
 #include "fourcc.h"
 #include "ADM_avsproxy.h"
 #include "ADM_avsproxy_internal.h"
 
-
-#include "ADM_osSupport/ADM_debugID.h"
-#define MODULE_NAME MODULE_3GP
-#include "ADM_osSupport/ADM_debug.h"
-
-
-
-
+#define ADM_info printf
+#define ADM_warning printf
+#define ADM_error printf
+/**
+    \fn avsHeader
+*/
 avsHeader::avsHeader()
 {
-    mySocket=0;
+    haveAudio=false;
+    memset(&wavHeader,0,sizeof(wavHeader));
+    audioStream=NULL;
 }
+/**
+    \fn avsHeader
+*/
+
  avsHeader::~avsHeader(  )
 {
     close();   
+    
 }
-
-
+/**
+    \fn close
+*/
+uint8_t avsHeader::close()
+{
+    if(audioStream) delete audioStream;
+    
+    audioStream=NULL;
+    
+    network.close();
+    return 1;
+}
+/**
+    \fn open
+*/
 uint8_t avsHeader::open(const char *name)
 {
-    mySocket=0;
-    if(!bindMe(9999))
+   
+    if(!network.bindMe(9999))
     {
         printf("[avsProxy]Open failed\n");
         return 0;
     }
     // now time to grab some info
     avsInfo info;
-    if(!askFor(AvsCmd_GetInfo,0,sizeof(info),(uint8_t*)&info))
+    avsNetPacket in,out;
+    out.buffer=(uint8_t *)&info;
+    out.sizeMax=sizeof(info);
+    out.size=0;
+    typedef struct 
     {
+        uint32_t ver;
+        uint32_t api;
+    }version;
+    version v={AVSHEADER_API_VERSION,6};
+    in.buffer=(uint8_t *)&v;
+    in.size=sizeof(v);
+    in.sizeMax=sizeof(v);
+
+    if(!network.command(AvsCmd_GetInfo,0,&in,&out))
+    {
         printf("Get info failed\n");
         return 0;   
     }
+    // Dump some info
+#define PINFO(x) printf(#x":%d\n",info.x);
+    PINFO( version);
+	PINFO( width);
+	PINFO( height);
+	PINFO( fps1000);
+	PINFO( nbFrames);
+	PINFO( frequency);
+	PINFO( channels);
     // Build header..
     _isaudiopresent = 0;	// Remove audio ATM
     _isvideopresent = 1;	// Remove audio ATM
@@ -76,30 +120,168 @@
     _video_bih.biWidth = _mainaviheader.dwWidth = info.width;
     _video_bih.biHeight = _mainaviheader.dwHeight = info.height;
     _video_bih.biCompression = _videostream.fccHandler =  fourCC::get((uint8_t *) "YV12");
-    
+#if 0   
+    //
+    if(info.frequency)
+    {
+        wavHeader.frequency=info.frequency;
+        wavHeader.channels=info.channels;
+        wavHeader.bitspersample=16;
+        wavHeader.blockalign=info.channels*2;
+        wavHeader.byterate=info.frequency*2*info.channels;
+        wavHeader.encoding=WAV_PCM;
+        audioStream=new avsAudio(&network,&wavHeader,10000);
+        _isaudiopresent=1;
+        haveAudio=true;
+    }
+#endif
     printf("Connection to avsproxy succeed\n");
     return 1;
 }
-
-
-
+/**
+    \fn frameToTime 
+    \brief convert a give frame into time
+*/
+uint64_t    avsHeader::frameToTime(uint32_t frame)
+{
+    float f=frame;
+    f*=1000000000; // Want us
+    f/=_videostream.dwRate;
+    uint64_t t=(uint64_t)f;
+    //printf("%"LU" -> %"LLU"\n",frame,t);
+    return t;
+}
+/**
+    \fn getFrame
+*/
 uint8_t  avsHeader::getFrameNoAlloc(uint32_t framenum,ADMCompressedImage *img)
 {
     uint32_t page=(_mainaviheader.dwWidth*_mainaviheader.dwHeight*3)>>1;
     
     if(framenum>=_mainaviheader.dwTotalFrames)
     {
-        printf("Avisynth proxy out of bound %u / %u\n",framenum,_mainaviheader.dwTotalFrames);
+        ADM_warning("Avisynth proxy out of bound %u / %u\n",framenum,_mainaviheader.dwTotalFrames);
         return 0;
     }
-    if(!askFor(AvsCmd_GetFrame,framenum,page,img->data))
+    
+    avsNetPacket out;
+    out.buffer=img->data;
+    out.sizeMax=page;
+    out.size=0;
+    //printf("Asking for frame %d\n",framenum);
+    if(!network.command(AvsCmd_GetFrame,framenum,NULL,&out))
     {
-        printf("Get frame failed for frame %u\n",framenum);
+        ADM_error("Get frame failed for frame %u\n",framenum);
         return 0;   
     }
+    ADM_assert(out.size==page);
     img->dataLength=page;
+    img->demuxerDts=frameToTime(framenum);
+    img->demuxerPts=img->demuxerDts;
+    //printf("Frame :%"LU" Time=%"LLU"\n",framenum,img->demuxerPts);
     return 1;
 }
+/**
+    \fn getFrame
+*/
 
+  uint8_t  avsHeader::setFlag(uint32_t frame,uint32_t flags)
+{
+    return 0; // All keyframes
+}
+/**
+    \fn getFrame
+*/
 
+  uint32_t avsHeader::getFlags(uint32_t frame,uint32_t *flags)
+{
+    *flags=AVI_KEY_FRAME;
+    if(frame>=_mainaviheader.dwTotalFrames)
+    {
+        ADM_warning("Avisynth proxy out of bound %u / %u\n",frame,_mainaviheader.dwTotalFrames);
+        return 0;
+    }
+    return 1;
+}
+/**
+    \fn getTime
+*/
 
+  uint64_t avsHeader::getTime(uint32_t frame)
+{
+    if(frame>=_mainaviheader.dwTotalFrames)
+    {
+        ADM_warning("Avisynth proxy out of bound %u / %u\n",frame,_mainaviheader.dwTotalFrames);
+        return 0;
+    }
+    return frameToTime(frame);
+}
+/**
+    \fn getExtraHeaderData
+*/
+
+         uint8_t  avsHeader::getExtraHeaderData(uint32_t *len, uint8_t **data)
+{
+    *len=0; 
+    *data=NULL;
+    return 1;
+}
+/**
+    \fn getVideoDuration
+*/
+
+  uint64_t avsHeader::getVideoDuration(void)
+{
+    return frameToTime(_mainaviheader.dwTotalFrames);
+}
+/**
+    \fn getPtsDts
+*/
+
+bool   avsHeader::getPtsDts(uint32_t frame,uint64_t *pts,uint64_t *dts)
+{
+    *pts=frameToTime(frame);
+    *dts=*pts;
+    return true;
+}
+/**
+    \fn setPtsDts
+*/
+
+bool   avsHeader::setPtsDts(uint32_t frame,uint64_t pts,uint64_t dts)
+{
+    return false;
+}
+/**
+    \fn getFrameSize
+*/
+uint8_t                 avsHeader::getFrameSize(uint32_t frame,uint32_t *size)
+{
+    if(frame>=_mainaviheader.dwTotalFrames)
+    {
+        ADM_warning("Avisynth proxy out of bound %u / %u\n",frame,_mainaviheader.dwTotalFrames);
+        return 0;
+    } 
+    *size=(_mainaviheader.dwWidth*_mainaviheader.dwHeight*3)>>1;
+    return true;
+}
+ WAVHeader *avsHeader::getAudioInfo(void ) 
+{
+    if(haveAudio) return &wavHeader;
+    return NULL;
+}
+ uint8_t avsHeader::getAudioStream(AVDMGenericAudioStream **audio)
+{
+    *audio=NULL;
+    if(haveAudio)
+    {
+        *audio=audioStream;
+        return 1;
+    }
+    return 1;
+
+}
+//EOF
+
+
+

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_avsproxy/ADM_avsproxy.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_avsproxy/ADM_avsproxy.h	2010-01-17 16:00:09 UTC (rev 5857)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_avsproxy/ADM_avsproxy.h	2010-01-18 18:40:01 UTC (rev 5858)
@@ -1,34 +1,83 @@
-/*
+/***************************************************************************
+    \file ADM_avsproxy.h
+    \author (C) 2007-2010 by mean  fixounet at free.fr
 
-(c) Mean 2006
-*/
+ ***************************************************************************/
 
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
 #ifndef AVS_PROXY_H
-
+#define AVS_PROXY_H
 #include "avifmt.h"
 #include "avifmt2.h"
+#include "ADM_editor/ADM_Video.h"//#include "ADM_Video.h"
+//#include "ADM_audioStream.h"
+#include "ADM_avsproxy_net.h"
+#define AVS_PROXY_DUMMY_FILE "::ADM_AVS_PROXY::" // warning this is duplicated in main app
 
-#include "ADM_editor/ADM_Video.h"
-#include "ADM_audio/aviaudio.hxx"
+/**
+    \fn ADM_avsAccess
+*/
+class avsAudio : public AVDMGenericAudioStream
+{
+protected:
+                      
+                avsNet           *network;
+                WAVHeader        *wavHeader;
+                uint64_t         duration;
+                uint64_t         nextSample;
+                uint8_t          *audioBuffer;
+                uint64_t         sampleToTime(uint64_t sample);
+                void             increment(uint64_t sample);
+public:
+                                  avsAudio(avsNet *net, WAVHeader *wav,uint64_t duration); 
+                virtual           ~avsAudio();
+                                    /// Hint, the stream is pure CBR (AC3,MP2,MP3)
+                virtual bool      isCBR(void) { return true;}
+                                    /// Return true if the demuxer can seek in time
+                virtual bool      canSeekTime(void) {return true;};
+                                    /// Return true if the demuxer can seek by offser
+                virtual bool      canSeekOffset(void) {return false;};
+                                    /// Return true if we can have the audio duration
+                virtual bool      canGetDuration(void) {return true;};
+                                    /// Returns audio duration in us
+                virtual uint64_t  getDurationInUs(void);
+                                    /// Go to a given time
+                virtual bool      goToTime(uint64_t timeUs);
+                virtual bool      getPacket(uint8_t *buffer, uint32_t *size, uint32_t maxSize,uint64_t *dts);
+                bool              getExtraData(uint32_t *l, uint8_t **d){*l=0;*d=NULL;return true;};
+// 2.5
+    virtual uint32_t            read(uint32_t len,uint8_t *buffer);
+    virtual uint8_t             goTo(uint32_t newoffset);
+    virtual uint8_t             getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples);
+    virtual uint8_t             goToTime(uint32_t mstime);
+    virtual uint8_t             extraData(uint32_t *l,uint8_t **d);
 
-
+};
+/**
+    \class avsHeader
+*/
 class avsHeader         :public vidHeader
 {
     protected:
-        int         mySocket;
-        uint8_t     bindMe(uint32_t port);
-        uint8_t     sendData(uint32_t cmd,uint32_t frame, uint32_t payload_size,uint8_t *payload);
-        uint8_t     receiveData(uint32_t *cmd, uint32_t *frame,uint32_t *payload_size,uint8_t *payload);
-        uint8_t     askFor(uint32_t cmd,uint32_t frame, uint32_t payloadsize,uint8_t *payload);
-        uint8_t     rxData(uint32_t howmuch, uint8_t *where);
-        uint8_t     txData(uint32_t howmuch, uint8_t *where);
+        uint64_t                    frameToTime(uint32_t frame);
+        avsNet                      network;
+        WAVHeader                   wavHeader;
+        bool                        haveAudio;
+        avsAudio                    *audioStream;
     public:
 
 
         virtual   void 				Dump(void) {};
 
-        avsHeader( void );
-        ~avsHeader(  );
+                                    avsHeader( void );
+                                    ~avsHeader(  );
 // AVI io
         virtual 	uint8_t			open(const char *name);
         virtual 	uint8_t			close(void) ;
@@ -40,20 +89,41 @@
   //				 Audio
   //__________________________
 
-        virtual 	WAVHeader *getAudioInfo(void ) { return NULL ;} ;
-        virtual 	uint8_t			getAudioStream(AVDMGenericAudioStream **audio)
-        {  *audio=NULL;return 1;};
-
-// Frames
+virtual 	WAVHeader              *getAudioInfo(uint32_t i )  
+                                    {
+                                        if(true==haveAudio) 
+                                            return &wavHeader;
+                                        return NULL;
+                                    };
+#if 0
+virtual 	uint8_t                 getAudioStream(uint32_t i,ADM_audioStream  **audio)
+                                    {
+                                            *audio=NULL;
+                                            if(false==haveAudio) return 0;
+                                            if(i) return 0;
+                                            *audio= audioStream;
+                                            return true;
+                                    }
+ #endif
   //__________________________
   //				 video
   //__________________________
+ virtual uint8_t                    setFlag(uint32_t frame,uint32_t flags);
+ virtual uint32_t                   getFlags(uint32_t frame,uint32_t *flags);
+ virtual uint8_t                    getFrameNoAlloc(uint32_t framenum,ADMCompressedImage *img);
+ virtual uint64_t                   getTime(uint32_t frame);
+         uint8_t                    getExtraHeaderData(uint32_t *len, uint8_t **data);
+ virtual uint64_t                   getVideoDuration(void);
 
-        virtual 	uint8_t  setFlag(uint32_t frame,uint32_t flags) {return 1;}
-        virtual 	uint32_t getFlags(uint32_t frame,uint32_t *flags) 
-                            {*flags=AVI_KEY_FRAME;return AVI_KEY_FRAME;}
-        virtual 	uint8_t  getFrameNoAlloc(uint32_t framenum,ADMCompressedImage *img);
+virtual   bool                      getPtsDts(uint32_t frame,uint64_t *pts,uint64_t *dts);
+virtual   bool                      setPtsDts(uint32_t frame,uint64_t pts,uint64_t dts);
 
+          bool                      providePts(void) {return true;};
+virtual   uint8_t                   getFrameSize(uint32_t frame,uint32_t *size);
+// 2.5
+    virtual   WAVHeader *getAudioInfo(void ) ;
+    virtual uint8_t getAudioStream(AVDMGenericAudioStream **audio);
+
 };
 #endif
 //EOF

Added: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_avsproxy/ADM_avsproxyAudio.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_avsproxy/ADM_avsproxyAudio.cpp	2010-01-17 16:00:09 UTC (rev 5857)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_avsproxy/ADM_avsproxyAudio.cpp	2010-01-18 18:40:01 UTC (rev 5858)
@@ -0,0 +1,129 @@
+/***************************************************************************
+    \file ADM_avsproxyAudio.cpp
+    \author (C) 2007-2010 by mean  fixounet at free.fr
+
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "ADM_default.h"
+#include "fourcc.h"
+#include "DIA_coreToolkit.h"
+
+#include "fourcc.h"
+#include "ADM_avsproxy.h"
+#include "ADM_avsproxy_internal.h"
+#define AVS_AUDIO_BUFFER_SIZE (48000*6*4)
+
+
+#define ADM_info printf
+#define ADM_warning printf
+#define ADM_error printf
+
+/**
+    \fn ADM_avsAccess
+*/
+avsAudio::avsAudio(avsNet *net, WAVHeader *wav,uint64_t duration)
+{
+    network=net;
+    this->wavHeader=wav;
+    this->duration=duration;
+    nextSample=0;
+    audioBuffer=new uint8_t[AVS_AUDIO_BUFFER_SIZE];
+}
+/**
+    \fn ~ADM_avsAccess
+*/
+
+avsAudio::~avsAudio()
+{
+    if(audioBuffer)
+        delete [] audioBuffer;
+    audioBuffer=NULL;
+}
+/**
+    \fn getDurationInUs
+*/
+uint64_t  avsAudio::getDurationInUs(void)
+{
+    return duration;
+}
+/**
+    \fn goToTime
+*/
+bool      avsAudio::goToTime(uint64_t timeUs)
+{
+    // convert us to sample
+    float f=timeUs;
+    f*=wavHeader->frequency;
+    f/=1000000.;
+    nextSample=(uint32_t )f;
+    return true;
+}
+/**
+    \fn sampleToTime
+*/
+uint64_t avsAudio::sampleToTime(uint64_t sample)
+{
+    float f=sample;
+    f/=wavHeader->frequency;
+    f*=1000000;
+    return (uint64_t)f;
+}
+/**
+    \fn increment
+*/
+void avsAudio::increment(uint64_t sample)
+{
+    nextSample+=sample;
+}
+/**
+    \fn getPacket
+*/
+bool      avsAudio::getPacket(uint8_t *buffer, uint32_t *size, uint32_t maxSize,uint64_t *dts)
+{
+    avsNetPacket out;
+    avsNetPacket in;
+    avsAudioFrame aFrame;
+    aFrame.startSample=nextSample;
+    
+#warning this is incorrect
+    aFrame.sizeInFloatSample=maxSize/(2*wavHeader->channels);
+    in.buffer=(uint8_t *)&aFrame;
+    in.size=sizeof(aFrame);
+
+    out.buffer=audioBuffer;
+    out.sizeMax=maxSize+sizeof(aFrame);
+    out.size=0;
+    //printf("Asking for frame %d\n",framenum);
+    if(!network->command(AvsCmd_GetAudio,0,&in,&out))
+    {
+        ADM_error("Get audio failed for frame \n");
+        return false;   
+    }
+  //  printf("Out size : %d\n",(int)out.size);
+    
+    //
+    //
+    memcpy(&aFrame,audioBuffer,sizeof(aFrame));
+   // printf("NbSample : %d\n",(int)aFrame.sizeInFloatSample);
+    if(!aFrame.sizeInFloatSample)
+    {
+        ADM_warning("Error in audio (Zero samples\n");
+        return false;
+    }
+    *dts=sampleToTime(nextSample);
+    increment(aFrame.sizeInFloatSample);
+    *size=out.size-sizeof(aFrame);
+    memcpy(buffer,audioBuffer+sizeof(aFrame),out.size-sizeof(aFrame));
+  return true;
+};
+//EOF
+

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_avsproxy/ADM_avsproxy_internal.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_avsproxy/ADM_avsproxy_internal.h	2010-01-17 16:00:09 UTC (rev 5857)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_avsproxy/ADM_avsproxy_internal.h	2010-01-18 18:40:01 UTC (rev 5858)
@@ -3,23 +3,7 @@
 (c) Mean 2006
 */
 #ifndef AVS_PROXY_INTERNAL_H
-typedef enum 
-{
-    AvsCmd_GetInfo=1,
-    AvsCmd_SendInfo,
-    AvsCmd_GetFrame,
-    AvsCmd_SendFrame,
-    AvsCmd_Quit
-}AvsEnum;
-
-typedef struct avsInfo
-{
-    uint32_t width;
-    uint32_t height;
-    uint32_t fps1000;
-    uint32_t nbFrames;
-}avsInfo;
-
+#include "avsHeader.h"
 typedef struct SktHeader
 {
     uint32_t cmd;

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_avsproxy/ADM_avsproxy_net.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_avsproxy/ADM_avsproxy_net.cpp	2010-01-17 16:00:09 UTC (rev 5857)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_avsproxy/ADM_avsproxy_net.cpp	2010-01-18 18:40:01 UTC (rev 5858)
@@ -1,5 +1,19 @@
-#include "config.h"
+/***************************************************************************
+    \file ADM_avsproxy_net.cpp
+    \brief Handle the network part of avsproxy demuxer
+    \author (C) 2007-2010 by mean  fixounet at free.fr
 
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
 #ifdef __MINGW32__
 #include <windows.h>
 #include <winbase.h>
@@ -10,6 +24,7 @@
 #include <sys/socket.h>
 #include <netinet/in.h>
 #include <arpa/inet.h>
+#include <netinet/tcp.h>
 #endif
 
 #include <stdio.h>
@@ -17,18 +32,18 @@
 #include <string.h>
 #include <math.h>
 #include <errno.h>
-#include "ADM_assert.h"
 #include "ADM_default.h"
 #include "ADM_avsproxy_internal.h"
-#include "ADM_avsproxy.h"
+#include "ADM_avsproxy_net.h"
 
-#include "ADM_osSupport/ADM_debugID.h"
-#define MODULE_NAME MODULE_3GP
-#include "ADM_osSupport/ADM_debug.h"
-
 #define MAGGIC 0xDEADBEEF
 
-uint8_t avsHeader::bindMe(uint32_t port)
+#define aprintf(...) {}
+//#define DEBUG_NET
+/**
+    \fn bindMe
+*/
+bool avsNet::bindMe(uint32_t port)
 {
  #ifdef __MINGW32__
  mySocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
@@ -43,12 +58,17 @@
     struct sockaddr_in  service;
     service.sin_family = AF_INET;
 #ifdef DEBUG_NET
-    service.sin_addr.s_addr = inet_addr("192.168.0.10");
+    service.sin_addr.s_addr = inet_addr("192.168.0.21");
 #else
     service.sin_addr.s_addr = inet_addr("127.0.0.1");
 #endif    
     service.sin_port = htons(port);
     
+// Set socket to lowdelay, else it will be choppy
+    int flag = 1;
+    setsockopt( mySocket, IPPROTO_TCP, TCP_NODELAY, (char *)&flag, sizeof(flag) );
+
+
     if(connect(mySocket,(struct sockaddr *)&service,sizeof(service)))
     {
         printf("[avsProxy]Socket connect error %d on port %d\n",errno,port);
@@ -57,7 +77,10 @@
     printf("[avsproxy]Connected to avsproxy : port %d, socket %d\n",port,mySocket);
     return 1;
 }
-uint8_t avsHeader::close(void)
+/**
+    \fn close
+*/
+bool avsNet::close(void)
 {
     if(mySocket)
     {
@@ -72,32 +95,40 @@
     }
     return 1;
 }
-
-uint8_t avsHeader::askFor(uint32_t cmd,uint32_t frame, uint32_t payloadsize,uint8_t *payload)
+/**
+    \fn askFor
+*/
+bool avsNet::command(uint32_t cmd,uint32_t frame,avsNetPacket *in,avsNetPacket *out)
 {
-   
-    if(!sendData(cmd,frame,0,NULL))
+   avsNetPacket dummy={0,0,NULL};
+   avsNetPacket *in2=in;
+    if(!in2) in2=&dummy;
+    lock.lock();
+    if(!sendData(cmd,frame,in2->size,in2->buffer))
     {
         printf("[avsProxy]Send Cmd %u failed for frame %u\n",cmd,frame);
+        lock.unlock();
         return 0;
     }
     // Wait reply
     uint32_t size,reply,outframe;
-    if(!receiveData(&reply,&outframe,&size,payload))
+    if(!receiveData(&reply,&outframe,&(out->size),out->buffer))
     {
         printf("[avsProxy]Rx Cmd %u failed for frame %u\n",cmd,frame);
         return 0;   
     }
   
     // Check!
-    ADM_assert(outframe==frame);
+    ADM_assert(out->size<=out->sizeMax);
     ADM_assert(reply==cmd+1);
-    ADM_assert(size==payloadsize);
     aprintf("[avsProxy]Cmd %u on frame %u succeed\n",cmd,frame);
-    return 1;
-    
+    lock.unlock();
+    return 1;   
 }
-uint8_t avsHeader::rxData(uint32_t howmuch, uint8_t *where)
+/**
+    \fn rxData
+*/
+bool avsNet::rxData(uint32_t howmuch, uint8_t *where)
 {
 uint32_t got=0;
 int rx;
@@ -114,7 +145,10 @@
     }
   return 1;
 }
-uint8_t avsHeader::txData(uint32_t howmuch, uint8_t *where)
+/**
+    \fn txData
+*/
+bool avsNet::txData(uint32_t howmuch, uint8_t *where)
 {
 uint32_t got=0,tx;
     while(got<howmuch)
@@ -130,8 +164,10 @@
     }
   return 1;
 }
-
-uint8_t avsHeader::receiveData(uint32_t *cmd, uint32_t *frame,uint32_t *payload_size,uint8_t *payload)
+/**
+    \fn receiveData
+*/
+bool avsNet::receiveData(uint32_t *cmd, uint32_t *frame,uint32_t *payload_size,uint8_t *payload)
 {
         SktHeader header;
         memset(&header,0,sizeof(header));
@@ -152,14 +188,14 @@
         {
             int togo=header.payloadLen;
             return rxData(togo,payload);
-            
         }
-
         return 1;
 }
 
-
-uint8_t avsHeader::sendData(uint32_t cmd,uint32_t frame, uint32_t payload_size,uint8_t *payload)
+/**
+    \fn sendData
+*/
+bool avsNet::sendData(uint32_t cmd,uint32_t frame, uint32_t payload_size,uint8_t *payload)
 {
         SktHeader header;
         memset(&header,0,sizeof(header));
@@ -170,10 +206,19 @@
         header.magic=(uint32_t)MAGGIC;
         if(!txData(sizeof(header),(uint8_t *)&header))
         {
-            printf("Error in senddata: header %d\n",sizeof(header));
+            printf("Error in senddata: header %d\n",(int)sizeof(header));
             return 0;
         }
         int togo=payload_size;
         int chunk;
         return txData(togo,payload);
 }
+avsNet::avsNet()
+{
+    mySocket=0;
+}
+avsNet::~avsNet()
+{
+    close();
+}
+//EOF

Added: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_avsproxy/ADM_avsproxy_net.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_avsproxy/ADM_avsproxy_net.h	2010-01-17 16:00:09 UTC (rev 5857)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_avsproxy/ADM_avsproxy_net.h	2010-01-18 18:40:01 UTC (rev 5858)
@@ -0,0 +1,51 @@
+/***************************************************************************
+    \file ADM_avsproxy_net.h
+    \author (C) 2007-2010 by mean  fixounet at free.fr
+
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef AVS_PROXY_NET_H
+#define AVS_PROXY_NET_H
+#include "ADM_threads.h"
+typedef struct
+{
+    uint32_t size;
+    uint32_t sizeMax;
+    uint8_t  *buffer;
+}avsNetPacket;
+
+/**
+    \class avsNet
+*/
+class avsNet       
+{
+    protected:
+        int         mySocket;
+        admMutex    lock;
+    public:
+        bool     bindMe(uint32_t port);
+        bool     sendData(uint32_t cmd,uint32_t frame, uint32_t payload_size,uint8_t *payload);
+        bool     receiveData(uint32_t *cmd, uint32_t *frame,uint32_t *payload_size,uint8_t *payload);
+        
+        bool     command(uint32_t cmd,uint32_t frame,avsNetPacket *in,avsNetPacket *out);
+        bool     rxData(uint32_t howmuch, uint8_t *where);
+        bool     txData(uint32_t howmuch, uint8_t *where);
+        bool     close(void);
+    public:
+
+
+        virtual   void 				Dump(void) {};
+
+        avsNet( void );
+        ~avsNet(  );
+};
+#endif
+//EOF

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_avsproxy/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_avsproxy/CMakeLists.txt	2010-01-17 16:00:09 UTC (rev 5857)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_avsproxy/CMakeLists.txt	2010-01-18 18:40:01 UTC (rev 5858)
@@ -1,4 +1,7 @@
 SET(ADM_avsproxy_SRCS 
-	ADM_avsproxy.cpp  ADM_avsproxy_net.cpp)
+	ADM_avsproxy.cpp  
+        ADM_avsproxy_net.cpp
+        ADM_avsproxyAudio.cpp
+)
 
-ADD_ADM_LIB_ALL_TARGETS(ADM_avsproxy ${ADM_avsproxy_SRCS})
\ No newline at end of file
+ADD_ADM_LIB_ALL_TARGETS(ADM_avsproxy ${ADM_avsproxy_SRCS})

Added: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_avsproxy/avsHeader.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_avsproxy/avsHeader.h	2010-01-17 16:00:09 UTC (rev 5857)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_avsproxy/avsHeader.h	2010-01-18 18:40:01 UTC (rev 5858)
@@ -0,0 +1,38 @@
+/** 
+	\file avsHeader.h
+	\brief Content of exchanges between avidemux and avsproxy
+
+
+*/
+#ifndef AVS_HEADER_H
+#define AVS_HEADER_H
+#define AVSHEADER_API_VERSION 2
+ enum AvsEnum
+{
+	AvsCmd_GetInfo=1,
+	AvsCmd_SendInfo=2,
+	AvsCmd_GetFrame=3,
+	AvsCmd_SendFrame=4,
+	AvsCmd_GetAudio=5,
+	AvsCmd_SendAudio=6,
+	AvsCmd_Quit=99
+};
+
+typedef struct avsInfo
+{
+	uint32_t version;
+	uint32_t width;
+	uint32_t height;
+	uint32_t fps1000;
+	uint32_t nbFrames;
+	uint32_t frequency;
+	uint32_t channels;
+}avsyInfo;
+
+typedef struct 
+{
+	uint32_t sizeInFloatSample;
+	uint64_t startSample;       // -1 means continue
+}avsAudioFrame;
+#endif
+


Property changes on: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_avsproxy/avsHeader.h
___________________________________________________________________
Name: svn:executable
   + *



From mean at mail.berlios.de  Mon Jan 18 19:40:05 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Mon, 18 Jan 2010 19:40:05 +0100
Subject: [Avidemux-svn-commit] r5859 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_avsproxy
Message-ID: <201001181840.o0IIe5IF002825@sheep.berlios.de>

Author: mean
Date: 2010-01-18 19:40:05 +0100 (Mon, 18 Jan 2010)
New Revision: 5859

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_avsproxy/ADM_avsproxy.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_avsproxy/ADM_avsproxyAudio.cpp
Log:
[avsProxy] Audio support (not tested much)

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_avsproxy/ADM_avsproxy.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_avsproxy/ADM_avsproxy.cpp	2010-01-18 18:40:01 UTC (rev 5858)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_avsproxy/ADM_avsproxy.cpp	2010-01-18 18:40:05 UTC (rev 5859)
@@ -120,7 +120,7 @@
     _video_bih.biWidth = _mainaviheader.dwWidth = info.width;
     _video_bih.biHeight = _mainaviheader.dwHeight = info.height;
     _video_bih.biCompression = _videostream.fccHandler =  fourCC::get((uint8_t *) "YV12");
-#if 0   
+
     //
     if(info.frequency)
     {
@@ -133,8 +133,8 @@
         audioStream=new avsAudio(&network,&wavHeader,10000);
         _isaudiopresent=1;
         haveAudio=true;
+        printf("Audio present\n");
     }
-#endif
     printf("Connection to avsproxy succeed\n");
     return 1;
 }
@@ -276,7 +276,6 @@
     if(haveAudio)
     {
         *audio=audioStream;
-        return 1;
     }
     return 1;
 

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_avsproxy/ADM_avsproxyAudio.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_avsproxy/ADM_avsproxyAudio.cpp	2010-01-18 18:40:01 UTC (rev 5858)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_avsproxy/ADM_avsproxyAudio.cpp	2010-01-18 18:40:05 UTC (rev 5859)
@@ -37,6 +37,7 @@
     this->duration=duration;
     nextSample=0;
     audioBuffer=new uint8_t[AVS_AUDIO_BUFFER_SIZE];
+    _wavheader=wavHeader;
 }
 /**
     \fn ~ADM_avsAccess
@@ -125,5 +126,46 @@
     memcpy(buffer,audioBuffer+sizeof(aFrame),out.size-sizeof(aFrame));
   return true;
 };
+
+//**************** 2.5****************
+uint32_t            avsAudio::read(uint32_t len,uint8_t *buffer)
+{
+    uint32_t size;
+    uint64_t dts;
+    if(true==getPacket(buffer,&size,len,&dts))
+    {
+        return size;
+    }
+    return 0;
+}
+uint8_t             avsAudio::goTo(uint32_t newoffset)
+{
+    uint32_t f=newoffset;
+    f/=(2*wavHeader->channels); 
+    nextSample=f;
+    return 1;
+}
+uint8_t             avsAudio::getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples)
+{
+    uint64_t dts;
+    if(true==getPacket(dest, len, (wavHeader->channels*wavHeader->frequency*2)/10,&dts)) // 50 ms chunk
+    {
+        *samples=*len/(2*wavHeader->channels);
+        return true;
+    }
+    return false;
+}
+uint8_t             avsAudio::goToTime(uint32_t mstime)
+{
+uint64_t t=mstime;
+            t=t*1000;
+            return goToTime(t);
+}
+uint8_t             avsAudio::extraData(uint32_t *l,uint8_t **d)
+{
+        *l=0;
+        *d=NULL;
+        return 1;
+}
 //EOF
 



From mean at mail.berlios.de  Tue Jan 19 07:30:21 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 19 Jan 2010 07:30:21 +0100
Subject: [Avidemux-svn-commit] r5860 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy
Message-ID: <201001190630.o0J6UL3p029530@sheep.berlios.de>

Author: mean
Date: 2010-01-19 07:30:15 +0100 (Tue, 19 Jan 2010)
New Revision: 5860

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/CMakeLists.txt
Log:
[avsproxy] avs plugin needs winsock

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/CMakeLists.txt	2010-01-18 18:40:05 UTC (rev 5859)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/CMakeLists.txt	2010-01-19 06:30:15 UTC (rev 5860)
@@ -6,6 +6,9 @@
         ADM_avsproxyAudio.cpp
 )
 ADD_LIBRARY(ADM_dm_avsproxy SHARED ${ADM_avsproxy_SRCS})
+if(WIN32)
+        link_libraries(ADM_dm_avsproxy wsock32)
+endif(WIN32)
 INIT_DEMUXER(ADM_dm_avsproxy)
 INSTALL_DEMUXER(ADM_dm_avsproxy)
 



From mean at mail.berlios.de  Tue Jan 19 08:02:52 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 19 Jan 2010 08:02:52 +0100
Subject: [Avidemux-svn-commit] r5861 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy
Message-ID: <201001190702.o0J72qg1026778@sheep.berlios.de>

Author: mean
Date: 2010-01-19 08:02:52 +0100 (Tue, 19 Jan 2010)
New Revision: 5861

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/CMakeLists.txt
Log:
[avsproxy] avs plugin needs winsock (2)

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/CMakeLists.txt	2010-01-19 06:30:15 UTC (rev 5860)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/AvsProxy/CMakeLists.txt	2010-01-19 07:02:52 UTC (rev 5861)
@@ -7,7 +7,7 @@
 )
 ADD_LIBRARY(ADM_dm_avsproxy SHARED ${ADM_avsproxy_SRCS})
 if(WIN32)
-        link_libraries(ADM_dm_avsproxy wsock32)
+        target_link_libraries(ADM_dm_avsproxy wsock32)
 endif(WIN32)
 INIT_DEMUXER(ADM_dm_avsproxy)
 INSTALL_DEMUXER(ADM_dm_avsproxy)



From gruntster at mail.berlios.de  Tue Jan 19 23:27:36 2010
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Tue, 19 Jan 2010 23:27:36 +0100
Subject: [Avidemux-svn-commit] r5862 - in
	branches/avidemux_2.5_branch_gruntster:
	avidemux/ADM_coreImage/include avidemux/ADM_coreImage/src
	avidemux/ADM_encoder cmake cmake/patches
Message-ID: <201001192227.o0JMRaW7018376@sheep.berlios.de>

Author: gruntster
Date: 2010-01-19 23:27:28 +0100 (Tue, 19 Jan 2010)
New Revision: 5862

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreImage/include/ADM_image.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreImage/src/ADM_colorspace.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreImage/src/ADM_imageResizer.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreImage/src/ADM_rgb.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreImage/src/rgb2yuv.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/ADM_externalEncoder.cpp
   branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_avcodec.h.patch
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_h263dec.c.patch
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_h264.c.patch
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_mpegvideo_enc.c.patch
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_isom.c.patch
Log:
[ffmpeg] update FFmpeg to r21328 & libswscale to r30376

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreImage/include/ADM_image.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreImage/include/ADM_image.h	2010-01-19 07:02:52 UTC (rev 5861)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreImage/include/ADM_image.h	2010-01-19 22:27:28 UTC (rev 5862)
@@ -172,7 +172,7 @@
 		uint32_t destWidth, destHeight;
 
 		void init(uint32_t ow, uint32_t oh, uint32_t dw, uint32_t dh, PixelFormat srcFormat, PixelFormat dstFormat);
-		void getYuvPlanes(uint8_t *source, uint32_t width, uint32_t height, uint8_t*& yPlane, uint8_t*& uPlane, uint8_t*& vPlane);
+		void getYuvPlanes(const uint8_t *source, uint32_t width, uint32_t height, const uint8_t*& yPlane, const uint8_t*& uPlane, const uint8_t*& vPlane);
 	public:
 		ADMImageResizer(uint32_t ow,uint32_t oh, uint32_t dw, uint32_t dh);
 		ADMImageResizer(uint32_t ow, uint32_t oh, uint32_t dw, uint32_t dh, PixelFormat srcFormat, PixelFormat dstFormat);
@@ -181,7 +181,7 @@
 		uint8_t resize(ADMImage *src, ADMImage *dest);
 		uint8_t resize(uint8_t *src, ADMImage *dest);
 		uint8_t resize(ADMImage *src, uint8_t *dest);
-		uint8_t resize(uint8_t *src, uint8_t *dest);
+		uint8_t resize(const uint8_t *src, uint8_t *dest);
 };
 
 // Misc utilities

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreImage/src/ADM_colorspace.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreImage/src/ADM_colorspace.cpp	2010-01-19 07:02:52 UTC (rev 5861)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreImage/src/ADM_colorspace.cpp	2010-01-19 22:27:28 UTC (rev 5862)
@@ -102,7 +102,7 @@
   
   getStrideAndPointers(from,fromColor,srcData,srcStride);
   getStrideAndPointers(to,toColor,dstData,dstStride);
-  sws_scale(CONTEXT,srcData,srcStride,0,height,dstData,dstStride);
+  sws_scale(CONTEXT,(const uint8_t**)srcData,srcStride,0,height,dstData,dstStride);
   return 1;
   
 }

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreImage/src/ADM_imageResizer.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreImage/src/ADM_imageResizer.cpp	2010-01-19 07:02:52 UTC (rev 5861)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreImage/src/ADM_imageResizer.cpp	2010-01-19 22:27:28 UTC (rev 5862)
@@ -97,10 +97,10 @@
 	return resize(source, dest->data);
 }
 
-uint8_t ADMImageResizer::resize(uint8_t *source, uint8_t *dest)
+uint8_t ADMImageResizer::resize(const uint8_t *source, uint8_t *dest)
 {
-	uint8_t *src[3];
-	uint8_t *dst[3];
+	const uint8_t *src[3];
+	const uint8_t *dst[3];
 	int ssrc[3];
 	int ddst[3];
 
@@ -140,12 +140,12 @@
 		ddst[2] = 0;
 	}
 
-    sws_scale((SwsContext*)_context, src, ssrc, 0, orgHeight, dst, ddst);
+    sws_scale((SwsContext*)_context, (const uint8_t**)src, ssrc, 0, orgHeight, (uint8_t **)dst, ddst);
 
     return 1;
 }
 
-void ADMImageResizer::getYuvPlanes(uint8_t *source, uint32_t width, uint32_t height, uint8_t*& yPlane, uint8_t*& uPlane, uint8_t*& vPlane)
+void ADMImageResizer::getYuvPlanes(const uint8_t *source, uint32_t width, uint32_t height, const uint8_t*& yPlane, const uint8_t*& uPlane, const uint8_t*& vPlane)
 {
 	// Unfortunately xPLANE macros expect an ADMImage object so doubling up on logic.
 	yPlane = source;

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreImage/src/ADM_rgb.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreImage/src/ADM_rgb.cpp	2010-01-19 07:02:52 UTC (rev 5861)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreImage/src/ADM_rgb.cpp	2010-01-19 22:27:28 UTC (rev 5862)
@@ -153,7 +153,7 @@
 */
  uint8_t ColYuvRgb::scale(uint8_t *src, uint8_t *target)
  {
-    uint8_t *srd[3];
+    const uint8_t *srd[3];
 	uint8_t *dst[3];
 	int ssrc[3];
 	int ddst[3];
@@ -218,7 +218,7 @@
 */
  uint8_t ColYuvRgb::scale(uint8_t *src, uint8_t *target,uint32_t startx,uint32_t starty, uint32_t tw,uint32_t th,uint32_t totalW,uint32_t totalH)
  {
-    uint8_t *srd[3];
+    const uint8_t *srd[3];
     uint8_t *dst[3];
     int ssrc[3];
     int ddst[3];
@@ -299,7 +299,7 @@
 }
   uint8_t ColYv12Rgb24::scale(uint8_t *src, uint8_t *target)
  {
-    uint8_t *srd[3];
+    const uint8_t *srd[3];
 	uint8_t *dst[3];
 	int ssrc[3];
 	int ddst[3];
@@ -369,7 +369,7 @@
 //***********************************************
  uint8_t ColRgbToYV12::scale(uint8_t *src, uint8_t *target)
  {
-    uint8_t *srd[3];
+    const uint8_t *srd[3];
         uint8_t *dst[3];
         int ssrc[3];
         int ddst[3];
@@ -529,7 +529,7 @@
 
 uint8_t COL_Generic2YV12::transform(uint8_t **planes, uint32_t *strides,uint8_t *target)
 {
-	uint8_t *srd[3];
+	const uint8_t *srd[3];
 	uint8_t *dst[3];
 	int ssrc[3];
 	int ddst[3];

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreImage/src/rgb2yuv.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreImage/src/rgb2yuv.cpp	2010-01-19 07:02:52 UTC (rev 5861)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreImage/src/rgb2yuv.cpp	2010-01-19 22:27:28 UTC (rev 5862)
@@ -228,7 +228,7 @@
 	    									  flags, NULL, NULL,NULL);
 	    ADM_assert(context);
 	
-	    uint8_t *src[3]={rgb+w*h*3-w*3,NULL,NULL};
+	    const uint8_t *src[3]={rgb+w*h*3-w*3,NULL,NULL};
 	    int srcStride[3]={-w*3,0,0};
 	    int dstStride[3]={w,w>>1,w>>1};
 	    uint8_t *dst[3]={yuv,yuv+w*h,yuv+((w*h*5)>>2)};
@@ -265,7 +265,7 @@
 	    									  flags, NULL, NULL,NULL);
 	    ADM_assert(context);
 	
-	    uint8_t *src[3]={rgb,NULL,NULL};
+	    const uint8_t *src[3]={rgb,NULL,NULL};
 	    int srcStride[3]={w*3,0,0};
 	    int dstStride[3]={w,w>>1,w>>1};
 	    uint8_t *dst[3]={yuv,yuv+((w*h*5)>>2),yuv+w*h};

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/ADM_externalEncoder.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/ADM_externalEncoder.cpp	2010-01-19 07:02:52 UTC (rev 5861)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/ADM_externalEncoder.cpp	2010-01-19 22:27:28 UTC (rev 5862)
@@ -186,7 +186,7 @@
 			sourcePicture.data[2] = tmpPlane;
 
 			sws_scale(
-				_swsContext, sourcePicture.data, sourcePicture.linesize, 0,
+				_swsContext, (const uint8_t**)sourcePicture.data, sourcePicture.linesize, 0,
 				_h, resamplePicture.data, resamplePicture.linesize);
 
 			inputPicture = &resamplePicture;

Modified: branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake	2010-01-19 07:02:52 UTC (rev 5861)
+++ branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake	2010-01-19 22:27:28 UTC (rev 5862)
@@ -1,7 +1,7 @@
 include(admFFmpegUtil)
 
-set(FFMPEG_VERSION 21066)	# http://git.ffmpeg.org/?p=ffmpeg;a=snapshot;h=9de84cea40e10210b102d85736695d67a468fc06;sf=tgz
-set(SWSCALE_VERSION 30236)	# http://git.ffmpeg.org/?p=libswscale;a=snapshot;h=aa49d64093654ce136015962fcd0b9bb37249f69;sf=tgz
+set(FFMPEG_VERSION 21328)	# http://git.ffmpeg.org/?p=ffmpeg;a=snapshot;h=6cb2817bfe7271b43edfee3c139952318dc49184;sf=tgz
+set(SWSCALE_VERSION 30376)	# http://git.ffmpeg.org/?p=libswscale;a=snapshot;h=f88913c5b4e9ec1c729aa289411627d4510db354;sf=tgz
 
 set(LIBRARY_SOURCE_DIR "${CMAKE_SOURCE_DIR}/avidemux/ADM_libraries")
 set(FFMPEG_SOURCE_DIR "${LIBRARY_SOURCE_DIR}/ffmpeg")
@@ -114,6 +114,12 @@
 					WORKING_DIRECTORY "${FFMPEG_BINARY_DIR}"
 					${ffmpegBuildOutput})
 
+	execute_process(COMMAND ${CMAKE_COMMAND} -E make_directory "libavutil"
+					WORKING_DIRECTORY "${CMAKE_BINARY_DIR}/config")
+
+	execute_process(COMMAND ${CMAKE_COMMAND} -E copy "./libavutil/avconfig.h" "${CMAKE_BINARY_DIR}/config/libavutil"
+					WORKING_DIRECTORY "${FFMPEG_BINARY_DIR}")
+
 	if (UNIX AND NOT APPLE)
 		find_patch()
 		patch_file("${FFMPEG_BINARY_DIR}" "${CMAKE_SOURCE_DIR}/cmake/patches/config.mak.diff")

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_avcodec.h.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_avcodec.h.patch	2010-01-19 07:02:52 UTC (rev 5861)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_avcodec.h.patch	2010-01-19 22:27:28 UTC (rev 5862)
@@ -1,8 +1,8 @@
-*** libavcodec/avcodec.h.old	Sat Dec 19 22:15:38 2009
---- libavcodec/avcodec.h	Sat Dec 19 22:15:38 2009
+*** libavcodec/avcodec.h.old	Sun Jan 17 19:05:10 2010
+--- libavcodec/avcodec.h	Sun Jan 17 19:05:10 2010
 ***************
-*** 583,588 ****
---- 583,590 ----
+*** 584,589 ****
+--- 584,591 ----
   #define CODEC_FLAG2_NON_LINEAR_QUANT 0x00010000 ///< Use MPEG-2 nonlinear quantizer.
   #define CODEC_FLAG2_BIT_RESERVOIR 0x00020000 ///< Use a bit reservoir when encoding if possible
   #define CODEC_FLAG2_MBTREE        0x00040000 ///< Use macroblock tree ratecontrol (x264 only)
@@ -12,8 +12,8 @@
   /* Unsupported options :
    *              Syntax Arithmetic coding (SAC)
 ***************
-*** 1441,1446 ****
---- 1443,1449 ----
+*** 1442,1447 ****
+--- 1444,1450 ----
        * - decoding: unused
        */
       int rc_max_rate;
@@ -22,8 +22,8 @@
       /**
        * minimum bitrate
 ***************
-*** 1455,1460 ****
---- 1458,1465 ----
+*** 1456,1461 ****
+--- 1459,1466 ----
        * - decoding: unused
        */
       int rc_buffer_size;

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_h263dec.c.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_h263dec.c.patch	2010-01-19 07:02:52 UTC (rev 5861)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_h263dec.c.patch	2010-01-19 22:27:28 UTC (rev 5862)
@@ -1,8 +1,8 @@
-*** libavcodec/h263dec.c.old	Thu Jan  7 19:26:04 2010
---- libavcodec/h263dec.c	Thu Jan  7 19:26:04 2010
+*** libavcodec/h263dec.c.old	Sun Jan 17 19:05:15 2010
+--- libavcodec/h263dec.c	Sun Jan 17 19:05:15 2010
 ***************
-*** 125,130 ****
---- 125,147 ----
+*** 119,124 ****
+--- 119,141 ----
   
       return 0;
   }
@@ -27,8 +27,8 @@
   av_cold int ff_h263_decode_end(AVCodecContext *avctx)
   {
 ***************
-*** 420,425 ****
---- 437,448 ----
+*** 414,419 ****
+--- 431,442 ----
       } else {
           ret = h263_decode_picture_header(s);
       }
@@ -42,8 +42,8 @@
       if(ret==FRAME_SKIPPED) return get_consumed_bytes(s, buf_size);
   
 ***************
-*** 713,718 ****
---- 736,749 ----
+*** 707,712 ****
+--- 730,743 ----
   
   assert(s->current_picture.pict_type == s->current_picture_ptr->pict_type);
   assert(s->current_picture.pict_type == s->pict_type);

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_h264.c.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_h264.c.patch	2010-01-19 07:02:52 UTC (rev 5861)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_h264.c.patch	2010-01-19 22:27:28 UTC (rev 5862)
@@ -1,8 +1,8 @@
-*** libavcodec/h264.c.old	Sat Dec 19 22:15:48 2009
---- libavcodec/h264.c	Sat Dec 19 22:15:48 2009
+*** libavcodec/h264.c.old	Tue Jan 19 19:20:51 2010
+--- libavcodec/h264.c	Tue Jan 19 19:20:52 2010
 ***************
-*** 8158,8163 ****
---- 8158,8174 ----
+*** 3113,3118 ****
+--- 3113,3129 ----
       return 0;
   }
   

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_mpegvideo_enc.c.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_mpegvideo_enc.c.patch	2010-01-19 07:02:52 UTC (rev 5861)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_mpegvideo_enc.c.patch	2010-01-19 22:27:28 UTC (rev 5862)
@@ -1,8 +1,8 @@
-*** libavcodec/mpegvideo_enc.c.old	Sat Dec 19 22:15:57 2009
---- libavcodec/mpegvideo_enc.c	Sat Dec 19 22:15:58 2009
+*** libavcodec/mpegvideo_enc.c.old	Sun Jan 17 19:05:25 2010
+--- libavcodec/mpegvideo_enc.c	Sun Jan 17 19:05:25 2010
 ***************
-*** 363,374 ****
---- 363,376 ----
+*** 366,377 ****
+--- 366,379 ----
   
           av_log(avctx, AV_LOG_INFO, "Warning vbv_delay will be set to 0xFFFF (=VBR) as the specified vbv buffer is too large for the given bitrate!\n");
       }
@@ -18,8 +18,8 @@
       if(s->obmc && s->avctx->mb_decision != FF_MB_DECISION_SIMPLE){
           av_log(avctx, AV_LOG_ERROR, "OBMC is only supported with simple mb decision\n");
 ***************
-*** 409,418 ****
---- 411,422 ----
+*** 412,421 ****
+--- 414,425 ----
           return -1;
       }
   

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_isom.c.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_isom.c.patch	2010-01-19 07:02:52 UTC (rev 5861)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_isom.c.patch	2010-01-19 22:27:28 UTC (rev 5862)
@@ -1,7 +1,7 @@
-*** libavformat/isom.c.old	Sat Dec 19 22:16:07 2009
---- libavformat/isom.c	Sat Dec 19 22:16:07 2009
+*** libavformat/isom.c.old	Sun Jan 17 19:05:32 2010
+--- libavformat/isom.c	Sun Jan 17 19:05:32 2010
 ***************
-*** 203,209 ****
+*** 205,211 ****
       { CODEC_ID_MP1, MKTAG('.', 'm', 'p', '1') }, /* MPEG layer 1 */
       { CODEC_ID_MP2, MKTAG('.', 'm', 'p', '2') }, /* MPEG layer 2 */
   
@@ -9,7 +9,7 @@
       { CODEC_ID_MP3, 0x6D730055 }, /* MPEG layer 3 */
   
   /*  { CODEC_ID_OGG_VORBIS, MKTAG('O', 'g', 'g', 'S') }, *//* sample files at http://heroinewarrior.com/xmovie.php3 use this tag */
---- 203,212 ----
+--- 205,214 ----
       { CODEC_ID_MP1, MKTAG('.', 'm', 'p', '1') }, /* MPEG layer 1 */
       { CODEC_ID_MP2, MKTAG('.', 'm', 'p', '2') }, /* MPEG layer 2 */
   



From mean at mail.berlios.de  Wed Jan 20 07:34:11 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 20 Jan 2010 07:34:11 +0100
Subject: [Avidemux-svn-commit] r5863 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor
Message-ID: <201001200634.o0K6YB6S000668@sheep.berlios.de>

Author: mean
Date: 2010-01-20 07:34:09 +0100 (Wed, 20 Jan 2010)
New Revision: 5863

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edCache.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edCache.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRenderInternal.cpp
Log:
[editor] Simplify cache handling, incomplete. That breaks decoding, to be continued

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edCache.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edCache.cpp	2010-01-19 22:27:28 UTC (rev 5862)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edCache.cpp	2010-01-20 06:34:09 UTC (rev 5863)
@@ -1,21 +1,22 @@
-
 /**
     \file edCache
     \brief Handle internal cache for decoded image
+    \author mean fixounet at free.fr (c) 2003-2010
 
-    Eviction is done using LRU method
-    Counter is "now" and farther frame are seleced for replacement
-
+   Simple fifo queue for dedcoded image with helper functions to search image in it.
 */
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
 #include "ADM_default.h"
 #include "ADM_image.h"
 #include "ADM_editor/ADM_edCache.h"
-
-
-#include "ADM_debugID.h"
-#define MODULE_NAME MODULE_EDITOR
-#include "ADM_debug.h"
-#undef aprintf
+#define ADM_NO_PTS 0xffffffffffffffffLL
 #if 1
 #define aprintf(...) {}
 #else
@@ -32,10 +33,8 @@
 	for(uint32_t i=0;i<size;i++)
 	{
 		_elem[i].image=new ADMImage(w,h);
-		_elem[i].frameNum=ADM_INVALID_CACHE;
-		_elem[i].lastUse=ADM_INVALID_CACHE;
+		_elem[i].pts=ADM_NO_PTS;
 	}
-	_counter=0;
 	_nbImage=size;
 }
 /**
@@ -49,26 +48,26 @@
 		delete _elem[i].image;
 	}
 	delete[] _elem;
-
 }
 /**
-    \fn getImage
-    \brief find image by framenumber, returns null if not found (obsolete)
+
 */
-ADMImage 	*EditorCache::getImage(uint32_t no)
+void EditorCache::check()
 {
-	for(uint32_t i=0;i<_nbImage;i++)
-	{
-		if(_elem[i].frameNum==no)
-		{
-			aprintf("EdCache: %lu  in cache %lu\n",no,i);
-			_elem[i].lastUse=_counter;
-			_counter++;
-			 return _elem[i].image;
-		}
-	}
-// 	aprintf("EdCache: %lu not in cache\n",no);
-	return NULL;
+    if(readIndex==writeIndex) // empty
+    {
+        readIndex=writeIndex=0;
+    }
+    // Wrap
+    if(writeIndex &0x80000000)
+    {
+        int min=readIndex;
+        if(writeIndex<min) min=writeIndex;
+        int mul=min/_nbImage;
+        int start=mul*_nbImage;
+        readIndex-=start;
+        writeIndex-=start;
+    }
 }
 /**
     \fn getFreeImage
@@ -81,33 +80,20 @@
 	uint32_t min=0;
 	uint64_t  delta=0;
     int found=-1;
-
-    // First search for a really free image
-    for(int i=0;i<_nbImage;i++)
+    check();
+    // next!
+    int r,w;
+    r=readIndex%_nbImage;
+    w=(writeIndex)%_nbImage;
+    if(r==w)
     {
-        if(_elem[i].frameNum==ADM_INVALID_CACHE)
-                found=i;
-        aprintf("[edCache] Buffer %d free\n",found);
+        readIndex++;
+        found=writeIndex%_nbImage;
     }
-    // Then the older one/LRU
-    if(found==-1)
-    {
-        aprintf("[edCache] looking for older cache entry\n");
-        for(int i=0;i<_nbImage;i++)
-        {
-            delta=abs((int)(_counter-_elem[i].lastUse));
-            if(delta>min)
-            {
-                min=delta;
-                found=i;
-                
-            }
-        }
-    }
+    // Mark it as used
     if(found==-1) ADM_assert(0);
-	_elem[found].lastUse=_counter+1;;
-	_elem[found].frameNum=ADM_IN_USE_CACHE;
-
+	_elem[found].pts=ADM_NO_PTS;;
+    writeIndex++;
 	return _elem[found].image;
 
 }
@@ -121,8 +107,9 @@
     printf("[edCache] Flush\n");
     for(int i=0;i<_nbImage;i++)
     {
-        _elem[i].frameNum=ADM_INVALID_CACHE;
+        _elem[i].pts=ADM_NO_PTS;
     }
+    writeIndex=readIndex=0;
 }
 /**
     \fn invalidate
@@ -130,14 +117,15 @@
 */
 void        EditorCache::invalidate(ADMImage *image)
 {
-   
     for(int i=0;i<_nbImage;i++)
     {
         if(_elem[i].image==image)
             {
-                   _elem[i].frameNum=ADM_INVALID_CACHE;
-                    aprintf("[edCache] Invalidating %d\n",i);
-                  return;
+                uint32_t prev=(writeIndex+_nbImage-1)%_nbImage;
+                 ADM_assert(i==prev);
+                 ADM_assert(_elem[i].pts==ADM_NO_PTS);
+                 writeIndex=prev;
+                 return;
             }
     }
     printf("[edCache]Image not in cache\n");
@@ -148,24 +136,20 @@
         \brief update the frameNo associated to a cache line (obsolete)
                Only used to mark it as valid
 */
-uint8_t		EditorCache::updateFrameNum(ADMImage *image,uint32_t frameno)
+bool		EditorCache::validate(ADMImage *image)
 {
 	for(uint32_t i=0;i<_nbImage;i++)
 	{
 		if(_elem[i].image==image)
 		{
-			ADM_assert(_elem[i].frameNum==ADM_IN_USE_CACHE);
-			_elem[i].frameNum=frameno;
-			_elem[i].lastUse=_counter;
-            aprintf("[edCache] Updatding %d with framenum %"LU"\n",i,frameno);
-			_counter++;
-			return 1;
-
+            ADM_assert(_elem[i].pts==ADM_NO_PTS);
+			_elem[i].pts=image->Pts;
+			return true;
 		}
 
 	}
 	ADM_assert(0);
-
+    return false;
 }
 /**
     \fn dump
@@ -173,15 +157,15 @@
 */
 void EditorCache::dump( void)
 {
+    printf("ReadIndex:%"LU", WriteIndex:%"LU"\n",readIndex,writeIndex);
 	for(int i=0;i<_nbImage;i++)
 	{
         cacheElem *e=&(_elem[i]);
-        switch(e->frameNum)
+        switch(e->pts)
         {
-            case ADM_IN_USE_CACHE:  printf("Edcache content[%d] In use\n",i);break;
-            case ADM_INVALID_CACHE: printf("Edcache content[%d] Free\n",i);break;
+            case ADM_NO_PTS:  printf("Not used\n",i);break;
             default:
-                printf("Edcache content[%d]: Num:%"LU" PTS : %"LLU" us%"LLU" ms\n",i,e->frameNum,
+                printf("Edcache content[%d]: PTS : %"LLU" us%"LLU" ms\n",i,
                                                                     e->image->Pts,e->image->Pts/1000);
         }
 	}
@@ -191,67 +175,58 @@
     \brief Find the image with the closest PTS just above pts.
 
 */
-ADMImage    *EditorCache::findJustAfter(uint64_t pts)
+ADMImage    *EditorCache::getAfter(uint64_t pts)
 {
-int smallest=-1;
-uint64_t value=0xF000000000000000LL;
-
-    for(uint32_t i=0;i<_nbImage;i++)
+    for(uint32_t i=readIndex;i<writeIndex-1;i++)
 	{
-		if(_elem[i].frameNum==ADM_INVALID_CACHE) continue;
-		if(_elem[i].image->Pts>pts)
+        int index=i%_nbImage;
+        ADM_assert(_elem[index].pts!=ADM_NO_PTS);
+        if(_elem[index].pts==pts)
         {
-            //printf("[Editor::findJustAfer] Looking for %lu, got %lu\n",pts,_elem[i].image->Pts);
-            if(_elem[i].image->Pts < value)
-            {
-                value=_elem[i].image->Pts;
-                smallest=i;
-            }
+            index++;
+            index%=_nbImage;
+            return _elem[index].image;
         }
     }
-	if(smallest==-1) return NULL;
-    return _elem[smallest].image;
+    ADM_warning("Cannot find image after %"LLU" ms in cache\n",pts/1000);
+    return NULL;
 }
 /**
-    \fn getByPts
-    \brief returns the image that has exactly that PTS
+    \fn findJustAfter
+    \brief Find the image with the closest PTS just above pts.
+
 */
-ADMImage *EditorCache::getByPts(uint64_t Pts)
+ADMImage    *EditorCache::getBefore(uint64_t pts)
 {
-    for(int i=0;i<_nbImage;i++)
+    for(uint32_t i=readIndex+1;i<writeIndex;i++)
 	{
-		if(_elem[i].frameNum==ADM_INVALID_CACHE) continue;
-		if(_elem[i].image->Pts==Pts)
+        int index=i%_nbImage;
+        ADM_assert(_elem[index].pts!=ADM_NO_PTS);
+        if(_elem[index].pts==pts)
         {
-            _elem[i].lastUse=_counter;
-			_counter++;
-            return _elem[i].image;
+            index--;
+            index%=_nbImage;
+            return _elem[index].image;
         }
     }
+    ADM_warning("Cannot find image before %"LLU" ms in cache\n",pts/1000);
     return NULL;
 }
+
 /**
-        \fn findLastBefore
-        \brief Search the cache for the image just before pts
+    \fn getByPts
+    \brief returns the image that has exactly that PTS
 */
-ADMImage    *EditorCache::findLastBefore(uint64_t pts)
+ADMImage *EditorCache::getByPts(uint64_t Pts)
 {
-  uint64_t delta=1<<31; // should be enough
-  int index=-1;
-  for(int i=0;i<_nbImage;i++)
+    for(int i=readIndex;i<writeIndex;i++)
 	{
-        cacheElem *elem=&(_elem[i]);
-		if(elem->frameNum==ADM_INVALID_CACHE) continue;
-		if(elem->image->Pts>=pts)  continue;
-        uint64_t d=abs(pts-elem->image->Pts);
-        if(d<delta)
+		if(_elem[i].image->Pts==Pts)
         {
-            delta=d;
-            index=i;
+            return _elem[i].image;
         }
     }
-    if(index==-1)
-        return NULL;
-    return _elem[index].image;
+    return NULL;
 }
+
 // EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edCache.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edCache.h	2010-01-19 22:27:28 UTC (rev 5862)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edCache.h	2010-01-20 06:34:09 UTC (rev 5863)
@@ -16,29 +16,30 @@
 #define ADM_IN_USE_CACHE  0xfffe
 typedef struct cacheElem
 {
-	uint32_t lastUse;
-	uint32_t frameNum;
 	ADMImage *image;
-
+    uint64_t pts;       // If set to ADM_NO_PTS -> unused entry
 }cacheElem;
+/**
+    \class EditorCache
+    \brief internal source-attached image cache
+*/
 class EditorCache
 {
 	private :
-			uint32_t	_counter;
+			uint32_t     readIndex,writeIndex;
 			cacheElem	 *_elem;
 			uint32_t	_nbImage;
+            void        check(void);
 	public:
                         EditorCache(uint32_t size,uint32_t w, uint32_t h);
                         ~EditorCache(void);
 			ADMImage	*getFreeImage(void);	
-			ADMImage 	*getImage(uint32_t no);
-			uint8_t		updateFrameNum(ADMImage *image,uint32_t frame);
+			bool		validate(ADMImage *image);
 			void		dump(void);
             void        flush(void);
             void        invalidate(ADMImage *image);
-            ADMImage    *findJustAfter(uint64_t pts);
-            ADMImage    *findLastBefore(uint64_t pts);
-            ADMImage    *getByPts(uint64_t Pts);
-            
+            ADMImage    *getByPts(uint64_t Pts);            
+            ADMImage    *getAfter(uint64_t Pts);
+            ADMImage    *getBefore(uint64_t Pts);
 };
 #endif

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRenderInternal.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRenderInternal.cpp	2010-01-19 22:27:28 UTC (rev 5862)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRenderInternal.cpp	2010-01-20 06:34:09 UTC (rev 5863)
@@ -150,7 +150,7 @@
             continue;
         }
         // Search the lowest PTS above our current PTS...
-        ADMImage *img=cache->findJustAfter(vid->lastReadPts);
+        ADMImage *img=cache->getAfter(vid->lastReadPts);
         if(img)
         {
             // Duplicate
@@ -231,7 +231,7 @@
          cache->invalidate(result);
          return true; // Not an error in itself
       }
-     cache->updateFrameNum(result,vid->lastSentFrame);
+     
      uint64_t pts=result->Pts;
      uint64_t old=vid->lastDecodedPts;
         if(pts==ADM_COMPRESSED_NO_PTS) // No PTS available ?
@@ -244,6 +244,8 @@
                 aprintf("[Editor] got PTS\n");
                 vid->lastDecodedPts=pts;
             }
+
+    cache->validate(result);
     aprintf(">>Decoded frame %"LU" with pts=%"LLD" us, %"LLD" ms, ptsdelta=%"LLD" ms \n",
     frame,
     vid->lastDecodedPts,
@@ -546,7 +548,7 @@
              continue;
           }else
             {
-                cache->updateFrameNum(result,vid->lastSentFrame);
+                
                 uint64_t pts=result->Pts;
                 aprintf("[Decoder] Decoder Frame %"LU" pts=%"LLU" ms, %"LLU" us\n",vid->lastSentFrame,
                                                         result->Pts/1000,result->Pts);
@@ -572,6 +574,7 @@
                     }
                     vid->lastDecodedPts=pts;
                 }
+                cache->validate(result);
             }
 
             // Found our image ?



From mean at mail.berlios.de  Wed Jan 20 19:26:50 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 20 Jan 2010 19:26:50 +0100
Subject: [Avidemux-svn-commit] r5864 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor
Message-ID: <201001201826.o0KIQoFR019248@sheep.berlios.de>

Author: mean
Date: 2010-01-20 19:26:48 +0100 (Wed, 20 Jan 2010)
New Revision: 5864

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edCache.cpp
Log:
[edCache] Fix cache handling

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edCache.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edCache.cpp	2010-01-20 06:34:09 UTC (rev 5863)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edCache.cpp	2010-01-20 18:26:48 UTC (rev 5864)
@@ -85,11 +85,12 @@
     int r,w;
     r=readIndex%_nbImage;
     w=(writeIndex)%_nbImage;
-    if(r==w)
+    if(r==w && readIndex!=writeIndex) //full
     {
-        readIndex++;
-        found=writeIndex%_nbImage;
+        readIndex++; // free older
     }
+    found=writeIndex%_nbImage;
+    
     // Mark it as used
     if(found==-1) ADM_assert(0);
 	_elem[found].pts=ADM_NO_PTS;;
@@ -124,7 +125,7 @@
                 uint32_t prev=(writeIndex+_nbImage-1)%_nbImage;
                  ADM_assert(i==prev);
                  ADM_assert(_elem[i].pts==ADM_NO_PTS);
-                 writeIndex=prev;
+                 writeIndex--;
                  return;
             }
     }
@@ -204,7 +205,7 @@
         ADM_assert(_elem[index].pts!=ADM_NO_PTS);
         if(_elem[index].pts==pts)
         {
-            index--;
+            index+=_nbImage-1;
             index%=_nbImage;
             return _elem[index].image;
         }
@@ -221,9 +222,10 @@
 {
     for(int i=readIndex;i<writeIndex;i++)
 	{
-		if(_elem[i].image->Pts==Pts)
+        int index=i%_nbImage;
+		if(_elem[index].image->Pts==Pts)
         {
-            return _elem[i].image;
+            return _elem[index].image;
         }
     }
     return NULL;



From gruntster at mail.berlios.de  Sat Jan 23 13:23:42 2010
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Sat, 23 Jan 2010 13:23:42 +0100
Subject: [Avidemux-svn-commit] r5865 - in
	branches/avidemux_2.5_branch_gruntster:
	avidemux/ADM_videoFilter cmake cmake/patches
Message-ID: <201001231223.o0NCNgff006063@sheep.berlios.de>

Author: gruntster
Date: 2010-01-23 13:23:32 +0100 (Sat, 23 Jan 2010)
New Revision: 5865

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidVobSubRender.cpp
   branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_avcodec.h.patch
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_mpegvideo.c.patch
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_matroskaenc.c.patch
Log:
[ffmpeg] update FFmpeg to r21394 & libswscale to r30400

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidVobSubRender.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidVobSubRender.cpp	2010-01-20 18:26:48 UTC (rev 5864)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_videoFilter/ADM_vidVobSubRender.cpp	2010-01-23 12:23:32 UTC (rev 5865)
@@ -624,7 +624,7 @@
   ADM_assert(ctx);
     
   //************************
-  uint8_t *src[3];
+  const uint8_t *src[3];
   uint8_t *dst[3];
   int ssrc[3];
   int ddst[3];

Modified: branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake	2010-01-20 18:26:48 UTC (rev 5864)
+++ branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake	2010-01-23 12:23:32 UTC (rev 5865)
@@ -1,7 +1,7 @@
 include(admFFmpegUtil)
 
-set(FFMPEG_VERSION 21328)	# http://git.ffmpeg.org/?p=ffmpeg;a=snapshot;h=6cb2817bfe7271b43edfee3c139952318dc49184;sf=tgz
-set(SWSCALE_VERSION 30376)	# http://git.ffmpeg.org/?p=libswscale;a=snapshot;h=f88913c5b4e9ec1c729aa289411627d4510db354;sf=tgz
+set(FFMPEG_VERSION 21394)	# http://git.ffmpeg.org/?p=ffmpeg;a=snapshot;h=42e589b65e001e0888fd3e676ebf7bb8c44e9b36;sf=tgz
+set(SWSCALE_VERSION 30400)	# http://git.ffmpeg.org/?p=libswscale;a=snapshot;h=281ba1ce52f8df13ec9da3cc6c913a804251918c;sf=tgz
 
 set(LIBRARY_SOURCE_DIR "${CMAKE_SOURCE_DIR}/avidemux/ADM_libraries")
 set(FFMPEG_SOURCE_DIR "${LIBRARY_SOURCE_DIR}/ffmpeg")

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_avcodec.h.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_avcodec.h.patch	2010-01-20 18:26:48 UTC (rev 5864)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_avcodec.h.patch	2010-01-23 12:23:32 UTC (rev 5865)
@@ -1,5 +1,5 @@
-*** libavcodec/avcodec.h.old	Sun Jan 17 19:05:10 2010
---- libavcodec/avcodec.h	Sun Jan 17 19:05:10 2010
+*** libavcodec/avcodec.h.old	Sat Jan 23 11:31:04 2010
+--- libavcodec/avcodec.h	Sat Jan 23 11:31:05 2010
 ***************
 *** 584,589 ****
 --- 584,591 ----
@@ -12,8 +12,8 @@
   /* Unsupported options :
    *              Syntax Arithmetic coding (SAC)
 ***************
-*** 1442,1447 ****
---- 1444,1450 ----
+*** 1450,1455 ****
+--- 1452,1458 ----
        * - decoding: unused
        */
       int rc_max_rate;
@@ -22,8 +22,8 @@
       /**
        * minimum bitrate
 ***************
-*** 1456,1461 ****
---- 1459,1466 ----
+*** 1464,1469 ****
+--- 1467,1474 ----
        * - decoding: unused
        */
       int rc_buffer_size;

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_mpegvideo.c.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_mpegvideo.c.patch	2010-01-20 18:26:48 UTC (rev 5864)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_mpegvideo.c.patch	2010-01-23 12:23:32 UTC (rev 5865)
@@ -1,7 +1,7 @@
-*** libavcodec/mpegvideo.c.old	Thu Sep 17 16:14:03 2009
---- libavcodec/mpegvideo.c	Thu Sep 17 16:14:04 2009
+*** libavcodec/mpegvideo.c.old	Sat Jan 23 11:31:10 2010
+--- libavcodec/mpegvideo.c	Sat Jan 23 11:31:10 2010
 ***************
-*** 613,619 ****
+*** 614,620 ****
       FF_ALLOCZ_OR_GOTO(s->avctx, s->prev_pict_types, PREV_PICT_TYPES_BUFFER_SIZE, fail);
   
       s->parse_context.state= -1;
@@ -9,7 +9,7 @@
          s->visualization_buffer[0] = av_malloc((s->mb_width*16 + 2*EDGE_WIDTH) * s->mb_height*16 + 2*EDGE_WIDTH);
          s->visualization_buffer[1] = av_malloc((s->mb_width*16 + 2*EDGE_WIDTH) * s->mb_height*16 + 2*EDGE_WIDTH);
          s->visualization_buffer[2] = av_malloc((s->mb_width*16 + 2*EDGE_WIDTH) * s->mb_height*16 + 2*EDGE_WIDTH);
---- 613,623 ----
+--- 614,624 ----
       FF_ALLOCZ_OR_GOTO(s->avctx, s->prev_pict_types, PREV_PICT_TYPES_BUFFER_SIZE, fail);
   
       s->parse_context.state= -1;

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_matroskaenc.c.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_matroskaenc.c.patch	2010-01-20 18:26:48 UTC (rev 5864)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_matroskaenc.c.patch	2010-01-23 12:23:32 UTC (rev 5865)
@@ -1,5 +1,5 @@
-*** libavformat/matroskaenc.c.old	Sun Oct 18 17:15:09 2009
---- libavformat/matroskaenc.c	Sun Oct 18 17:15:10 2009
+*** libavformat/matroskaenc.c.old	Sat Jan 23 11:31:16 2010
+--- libavformat/matroskaenc.c	Sat Jan 23 11:31:16 2010
 ***************
 *** 395,400 ****
 --- 395,401 ----
@@ -42,34 +42,36 @@
   
   static void get_aac_sample_rates(AVFormatContext *s, AVCodecContext *codec, int *sample_rate, int *output_sample_rate)
 ***************
-*** 534,539 ****
---- 557,579 ----
-          put_ebml_uint (pb, MATROSKA_ID_TRACKNUMBER     , i + 1);
-          put_ebml_uint (pb, MATROSKA_ID_TRACKUID        , i + 1);
+*** 536,541 ****
+--- 559,583 ----
           put_ebml_uint (pb, MATROSKA_ID_TRACKFLAGLACING , 0);    // no lacing (yet)
-+ /**  MEANX : Add a default duration for video **/
-+         if(codec->codec_type==CODEC_TYPE_VIDEO)
-+         {
-+           if(codec->time_base.den && codec->time_base.num)
-+           {
-+             int num=codec->time_base.num;
-+             int den=codec->time_base.den;
-+             unsigned int default_duration;
-+             float period=num;
-+                   period/=den;
-+                   period*=1000*1000*1000; // in ns
-+                   default_duration=(unsigned int)floor(period);
-+                   put_ebml_uint (pb, MATROSKA_ID_TRACKDEFAULTDURATION ,default_duration);
-+           }
-+         }
-+         
-+ /**  MEANX : Add a default duration for video **/
+          put_ebml_float(pb, MATROSKA_ID_TRACKTIMECODESCALE, 1.0);
   
++ 		/**  MEANX : Add a default duration for video **/
++ 		if(codec->codec_type==CODEC_TYPE_VIDEO)
++ 		{
++ 			if(codec->time_base.den && codec->time_base.num)
++ 			{
++ 				int num = codec->time_base.num;
++ 				int den = codec->time_base.den;
++ 				unsigned int default_duration;
++ 				float period = num;
++ 
++ 				period /= den;
++ 				period *= 1000*1000*1000; // in ns
++ 				default_duration = (unsigned int)floor(period);
++ 				put_ebml_uint(pb, MATROSKA_ID_TRACKDEFAULTDURATION, default_duration);
++ 			}
++ 		}
++ 
++ 		/**  MEANX : Add a default duration for video **/
++ 
           if ((tag = av_metadata_get(st->metadata, "description", NULL, 0)))
               put_ebml_string(pb, MATROSKA_ID_TRACKNAME, tag->value);
+          tag = av_metadata_get(st->metadata, "language", NULL, 0);
 ***************
-*** 954,956 ****
---- 994,1006 ----
+*** 955,957 ****
+--- 997,1009 ----
       .flags = AVFMT_GLOBALHEADER,
       .codec_tag = (const AVCodecTag* const []){ff_codec_wav_tags, 0},
   };



From gruntster at mail.berlios.de  Sat Jan 23 13:27:57 2010
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Sat, 23 Jan 2010 13:27:57 +0100
Subject: [Avidemux-svn-commit] r5866 -
	branches/avidemux_2.5_branch_gruntster/cmake
Message-ID: <201001231227.o0NCRv3v010891@sheep.berlios.de>

Author: gruntster
Date: 2010-01-23 13:27:41 +0100 (Sat, 23 Jan 2010)
New Revision: 5866

Modified:
   branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake
Log:
[ffmpeg] ensure Yasm is installed and DXVA2 is detected on Win32

Modified: branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake	2010-01-23 12:23:32 UTC (rev 5865)
+++ branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake	2010-01-23 12:27:41 UTC (rev 5866)
@@ -114,6 +114,21 @@
 					WORKING_DIRECTORY "${FFMPEG_BINARY_DIR}"
 					${ffmpegBuildOutput})
 
+	file(READ ${FFMPEG_BINARY_DIR}/config.h FF_CONFIG_H)
+	string(REGEX MATCH "#define[ ]+HAVE_YASM[ ]+1" FF_YASM "${FF_CONFIG_H}")
+
+	if (NOT FF_YASM)
+		message(FATAL_ERROR "Yasm was not found.")
+	endif (NOT FF_YASM)
+
+	if (WIN32)
+		string(REGEX MATCH "#define[ ]+CONFIG_DXVA2[ ]+1" FF_DXVA2 "${FF_CONFIG_H}")
+		
+		if (NOT FF_DXVA2)
+			message(FATAL_ERROR "DXVA2 not detected.  Ensure the dxva2api.h system header exists (available from Microsoft or http://downloads.videolan.org/pub/videolan/testing/contrib/dxva2api.h).")
+		endif (NOT FF_DXVA2)			
+	endif (WIN32)
+
 	execute_process(COMMAND ${CMAKE_COMMAND} -E make_directory "libavutil"
 					WORKING_DIRECTORY "${CMAKE_BINARY_DIR}/config")
 



From gruntster at mail.berlios.de  Sat Jan 23 14:37:26 2010
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Sat, 23 Jan 2010 14:37:26 +0100
Subject: [Avidemux-svn-commit] r5867 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs
Message-ID: <201001231337.o0NDbQAK025202@sheep.berlios.de>

Author: gruntster
Date: 2010-01-23 14:37:20 +0100 (Sat, 23 Jan 2010)
New Revision: 5867

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/ADM_lavformat.cpp
Log:
[ffmpeg] move from newly deprecated function

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/ADM_lavformat.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/ADM_lavformat.cpp	2010-01-23 12:27:41 UTC (rev 5866)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/ADM_lavformat.cpp	2010-01-23 13:37:20 UTC (rev 5867)
@@ -115,28 +115,28 @@
 	switch(_type)
 	{
 	case MUXER_TS:
-		fmt=guess_format("mpegts", NULL, NULL);
+		fmt = av_guess_format("mpegts", NULL, NULL);
 		break;
 	case MUXER_DVD:
-		fmt = guess_format("dvd", NULL, NULL);
+		fmt = av_guess_format("dvd", NULL, NULL);
 		break;
 	case MUXER_VCD:
-		fmt = guess_format("vcd", NULL, NULL);
+		fmt = av_guess_format("vcd", NULL, NULL);
 		break;
 	case MUXER_SVCD:
-		fmt = guess_format("svcd", NULL, NULL);
+		fmt = av_guess_format("svcd", NULL, NULL);
 		break;
 	case MUXER_MP4:
-		fmt = guess_format("mp4", NULL, NULL);
+		fmt = av_guess_format("mp4", NULL, NULL);
 		break;
 	case MUXER_PSP:
-		fmt = guess_format("psp", NULL, NULL);
+		fmt = av_guess_format("psp", NULL, NULL);
 		break;
 	case MUXER_FLV:
-		fmt = guess_format("flv", NULL, NULL);
+		fmt = av_guess_format("flv", NULL, NULL);
 		break;
 	case MUXER_MATROSKA:
-		fmt = guess_format("matroska", NULL, NULL);
+		fmt = av_guess_format("matroska", NULL, NULL);
 		break;
 
 	default:



From gruntster at mail.berlios.de  Sat Jan 23 15:31:45 2010
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Sat, 23 Jan 2010 15:31:45 +0100
Subject: [Avidemux-svn-commit] r5868 -
	branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264
Message-ID: <201001231431.o0NEVjvF008967@sheep.berlios.de>

Author: gruntster
Date: 2010-01-23 15:31:40 +0100 (Sat, 23 Jan 2010)
New Revision: 5868

Modified:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/encoder.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/encoder.h
Log:
[x264] don't drop SEI userdata from x264 encoder.  FFmpeg muxers ignore the SEI when placed in extradata so insert in front of first video frame instead.

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/encoder.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/encoder.cpp	2010-01-23 13:37:20 UTC (rev 5867)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/encoder.cpp	2010-01-23 14:31:40 UTC (rev 5868)
@@ -60,11 +60,6 @@
 	_extraData = NULL;
 	_extraDataSize = 0;
 
-#if X264_BUILD < 76
-	_seiUserData = NULL;
-	_seiUserDataLen = 0;
-#endif
-
 	_encodeOptions.structSize = sizeof(vidEncOptions);
 	_encodeOptions.encodeMode = DEFAULT_ENCODE_MODE;
 	_encodeOptions.encodeModeParameter = DEFAULT_ENCODE_MODE_PARAMETER;
@@ -245,6 +240,8 @@
 	_openPass = true;
 	_currentPass++;
 	_currentFrame = 0;
+	_seiUserDataLen = 0;
+	_seiUserData = NULL;
 
 	char *logFileName = NULL;
 
@@ -332,15 +329,17 @@
 	}
 
 #if X264_BUILD > 75
-	int size = x264_encoder_encode(_handle, &nal, &nalCount, encodeParams->frameData[0] ? &_picture : NULL, &picture_out);
-
-	if (size > 0)
+	if (x264_encoder_encode(_handle, &nal, &nalCount, encodeParams->frameData[0] ? &_picture : NULL, &picture_out) < 0)
 	{
-		memcpy(_buffer, nal->p_payload, size);
+		printf("[x264] Error encoding\n");
+		return ADM_VIDENC_ERR_FAILED;
 	}
-	else if (size < 0)
+
+	int size = encodeNals(_buffer, _bufferSize, nal, nalCount, false);
+
+	if (size < 0)
 	{
-		printf("[x264] Error encoding\n");
+		printf("[x264] Error encoding NALs\n");
 		return ADM_VIDENC_ERR_FAILED;
 	}
 
@@ -427,6 +426,37 @@
 	return ADM_VIDENC_ERR_SUCCESS;
 }
 
+#if X264_BUILD > 75
+int x264Encoder::encodeNals(uint8_t *buf, int size, x264_nal_t *nals, int nalCount, bool skipSei)
+{
+    uint8_t *p = buf;
+    int i;
+
+    if (_seiUserDataLen > 0 && nalCount > 0)
+	{
+        memcpy(p, _seiUserData, _seiUserDataLen);
+        p += _seiUserDataLen;
+        _seiUserDataLen = 0;
+    }
+
+    for (i = 0; i < nalCount; i++)
+	{
+        if (skipSei && nals[i].i_type == NAL_SEI)
+		{
+            _seiUserDataLen = nals[i].i_payload;
+            _seiUserData = new uint8_t[_seiUserDataLen];
+            memcpy(_seiUserData, nals[i].p_payload, nals[i].i_payload);
+            continue;
+        }
+
+        memcpy(p, nals[i].p_payload, nals[i].i_payload);
+        p += nals[i].i_payload;
+    }
+
+    return p - buf;
+}
+#endif
+
 bool x264Encoder::createHeader(void)
 {
 	x264_nal_t *nal;
@@ -441,7 +471,7 @@
 #if X264_BUILD > 75
 	_extraDataSize = x264_encoder_headers(_handle, &nal, &nalCount);
 	_extraData = new uint8_t[_extraDataSize];
-	memcpy(_extraData, nal->p_payload, _extraDataSize);
+	_extraDataSize = encodeNals(_extraData, _extraDataSize, nal, nalCount, true);
 #else
 	uint32_t offset = 0;
 	uint8_t buffer[X264_MAX_HEADER_SIZE];
@@ -521,7 +551,7 @@
 	offset += picParamLen;
 
 	// Where x264 stores all its header, save it for later use
-	if (seiParamLen) 
+	if (seiParamLen)
 	{
 		_seiUserDataLen = seiParamLen;
 		_seiUserData = new uint8_t[_seiUserDataLen];
@@ -557,14 +587,12 @@
 		_extraDataSize = 0;
 	}
 
-#if X264_BUILD < 76
 	if (_seiUserData)
 	{
 		delete [] _seiUserData;
 		_seiUserData = NULL;
 		_seiUserDataLen = 0;
 	}
-#endif
 
 	return ADM_VIDENC_ERR_SUCCESS;
 }

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/encoder.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/encoder.h	2010-01-23 13:37:20 UTC (rev 5867)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/encoder.h	2010-01-23 14:31:40 UTC (rev 5868)
@@ -52,10 +52,8 @@
 		int _currentPass, _passCount;
 		bool _opened, _openPass;
 
-#if X264_BUILD < 76
 		uint8_t *_seiUserData;
 		uint32_t _seiUserDataLen;
-#endif
 
 		uint8_t *_extraData;
 		int _extraDataSize;
@@ -64,6 +62,7 @@
 		void printCqm(const uint8_t cqm[], int size);
 		void updateEncodeParameters(vidEncVideoProperties *properties);
 		unsigned int calculateBitrate(unsigned int fpsNum, unsigned int fpsDen, unsigned int frameCount, unsigned int sizeInMb);
+		int encodeNals(uint8_t *buf, int size, x264_nal_t *nals, int nnal, bool skipSei);
 		bool createHeader(void);
 
 	public:



From gruntster at mail.berlios.de  Sat Jan 23 15:41:11 2010
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Sat, 23 Jan 2010 15:41:11 +0100
Subject: [Avidemux-svn-commit] r5869 -
	branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts
Message-ID: <201001231441.o0NEfBeO012212@sheep.berlios.de>

Author: gruntster
Date: 2010-01-23 15:41:01 +0100 (Sat, 23 Jan 2010)
New Revision: 5869

Modified:
   branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/Set Common Environment Variables.bat
Log:
[win32] update build script to include DirectX headers

Modified: branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/Set Common Environment Variables.bat
===================================================================
--- branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/Set Common Environment Variables.bat	2010-01-23 14:31:40 UTC (rev 5868)
+++ branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/Set Common Environment Variables.bat	2010-01-23 14:41:01 UTC (rev 5869)
@@ -27,7 +27,7 @@
 set CMAKE_LIBRARY_PATH=%usrLocalDir%/lib
 set PKG_CONFIG_PATH=%usrLocalDir%\lib\pkgconfig
 set SDLDIR=%usrLocalDir%
-set CFLAGS=-I%CMAKE_INCLUDE_PATH% -L%CMAKE_LIBRARY_PATH%
+set CFLAGS=-I%CMAKE_INCLUDE_PATH% -L%CMAKE_LIBRARY_PATH% -I%mingwDir:\=/%/i686-w64-mingw32/include/directx
 set CXXFLAGS=-I%CMAKE_INCLUDE_PATH% -L%CMAKE_LIBRARY_PATH%
 set LDFLAGS=-L%CMAKE_LIBRARY_PATH%
 



From gruntster at mail.berlios.de  Sat Jan 23 16:56:13 2010
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Sat, 23 Jan 2010 16:56:13 +0100
Subject: [Avidemux-svn-commit] r5870 -
	branches/avidemux_2.5_branch_gruntster/cmake
Message-ID: <201001231556.o0NFuD6E026238@sheep.berlios.de>

Author: gruntster
Date: 2010-01-23 16:56:08 +0100 (Sat, 23 Jan 2010)
New Revision: 5870

Modified:
   branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake
Log:
[ffmpeg] only check for Yasm on x86

Modified: branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake	2010-01-23 14:41:01 UTC (rev 5869)
+++ branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake	2010-01-23 15:56:08 UTC (rev 5870)
@@ -114,20 +114,22 @@
 					WORKING_DIRECTORY "${FFMPEG_BINARY_DIR}"
 					${ffmpegBuildOutput})
 
-	file(READ ${FFMPEG_BINARY_DIR}/config.h FF_CONFIG_H)
-	string(REGEX MATCH "#define[ ]+HAVE_YASM[ ]+1" FF_YASM "${FF_CONFIG_H}")
+	if (ADM_CPU_X86)
+		file(READ ${FFMPEG_BINARY_DIR}/config.h FF_CONFIG_H)
+		string(REGEX MATCH "#define[ ]+HAVE_YASM[ ]+1" FF_YASM "${FF_CONFIG_H}")
 
-	if (NOT FF_YASM)
-		message(FATAL_ERROR "Yasm was not found.")
-	endif (NOT FF_YASM)
+		if (NOT FF_YASM)
+			message(FATAL_ERROR "Yasm was not found.")
+		endif (NOT FF_YASM)
 
-	if (WIN32)
-		string(REGEX MATCH "#define[ ]+CONFIG_DXVA2[ ]+1" FF_DXVA2 "${FF_CONFIG_H}")
-		
-		if (NOT FF_DXVA2)
-			message(FATAL_ERROR "DXVA2 not detected.  Ensure the dxva2api.h system header exists (available from Microsoft or http://downloads.videolan.org/pub/videolan/testing/contrib/dxva2api.h).")
-		endif (NOT FF_DXVA2)			
-	endif (WIN32)
+		if (WIN32)
+			string(REGEX MATCH "#define[ ]+CONFIG_DXVA2[ ]+1" FF_DXVA2 "${FF_CONFIG_H}")
+			
+			if (NOT FF_DXVA2)
+				message(FATAL_ERROR "DXVA2 not detected.  Ensure the dxva2api.h system header exists (available from Microsoft or http://downloads.videolan.org/pub/videolan/testing/contrib/dxva2api.h).")
+			endif (NOT FF_DXVA2)
+		endif (WIN32)
+	endif (ADM_CPU_X86)
 
 	execute_process(COMMAND ${CMAKE_COMMAND} -E make_directory "libavutil"
 					WORKING_DIRECTORY "${CMAKE_BINARY_DIR}/config")



From mean at mail.berlios.de  Sat Jan 23 20:30:25 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 23 Jan 2010 20:30:25 +0100
Subject: [Avidemux-svn-commit] r5871 - in
	branches/avidemux_2.6_branch_mean/avidemux/common: . ADM_editor
Message-ID: <201001231930.o0NJUP2C020535@sheep.berlios.de>

Author: mean
Date: 2010-01-23 20:30:19 +0100 (Sat, 23 Jan 2010)
New Revision: 5871

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edCache.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRenderInternal.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.h
   branches/avidemux_2.6_branch_mean/avidemux/common/gui_navigate.cpp
Log:
[Editor] Previous picture, part 1

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edCache.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edCache.cpp	2010-01-23 15:56:08 UTC (rev 5870)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edCache.cpp	2010-01-23 19:30:19 UTC (rev 5871)
@@ -17,7 +17,7 @@
 #include "ADM_image.h"
 #include "ADM_editor/ADM_edCache.h"
 #define ADM_NO_PTS 0xffffffffffffffffLL
-#if 1
+#if 0
 #define aprintf(...) {}
 #else
 #define aprintf printf
@@ -85,9 +85,11 @@
     int r,w;
     r=readIndex%_nbImage;
     w=(writeIndex)%_nbImage;
+    aprintf("Read: %"LU" write :%"LU"\n",readIndex,writeIndex);
     if(r==w && readIndex!=writeIndex) //full
     {
         readIndex++; // free older
+        aprintf("Erasing read\n");
     }
     found=writeIndex%_nbImage;
     
@@ -95,6 +97,7 @@
     if(found==-1) ADM_assert(0);
 	_elem[found].pts=ADM_NO_PTS;;
     writeIndex++;
+    aprintf("Using free image at index %d\n",found);
 	return _elem[found].image;
 
 }
@@ -125,6 +128,7 @@
                 uint32_t prev=(writeIndex+_nbImage-1)%_nbImage;
                  ADM_assert(i==prev);
                  ADM_assert(_elem[i].pts==ADM_NO_PTS);
+                 aprintf("Invalidate writeIndex %"LU"\n",writeIndex);
                  writeIndex--;
                  return;
             }
@@ -145,6 +149,7 @@
 		{
             ADM_assert(_elem[i].pts==ADM_NO_PTS);
 			_elem[i].pts=image->Pts;
+            aprintf("validate Index %"LU" with pts=%"LLU"ms\n",i,image->Pts);
 			return true;
 		}
 

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp	2010-01-23 15:56:08 UTC (rev 5870)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp	2010-01-23 19:30:19 UTC (rev 5871)
@@ -124,10 +124,22 @@
         return false;
     }
     _SEGMENT *seg=_segments.getSegment(_currentSegment);
+    // Ok, we have switched to a new segment
+    // Flush the cache
+    _VIDEOS *vid= _segments.getRefVideo(seg->_reference);
     if(false== DecodePictureUpToIntra(seg->_reference,frame))
     {
         return false;
     }
+    // Get the last decoded PTS and it is our current PTS
+    _currentPts=vid->lastDecodedPts+seg->_startTimeUs;
+    _currentPts-=seg->_refStartTimeUs;
+#if 0
+    ADM_info("decodec DTS=%"LLU" ms\n",vid->lastDecodedPts/1000);
+    ADM_info("startTime DTS=%"LLU" ms\n",seg->_startTimeUs/1000);
+    ADM_info("refstart DTS=%"LLU" ms\n",seg->_refStartTimeUs/1000);
+    ADM_info("Current DTS=%"LLU" ms\n",_currentPts/1000);
+#endif
     return true;
 }
 /**
@@ -146,9 +158,9 @@
     
     // Try to seek...
     _SEGMENT *s=_segments.getSegment(seg);
+    _VIDEOS *v=_segments.getRefVideo(s->_reference);
     if(!s->_reference && !segTime)
     {
-        _VIDEOS *v=_segments.getRefVideo(s->_reference);
         segTime=v->firstFramePts;
         ADM_warning("Fixating start time to %"LLU" ms\n",segTime/1000);
     }
@@ -159,9 +171,11 @@
             return false;
     }
     _currentSegment=seg;
+    _currentPts=v->lastDecodedPts;
     return true;
 
 }
+
 /**
     \fn NextPicture
     \brief decode & returns the next picture
@@ -170,15 +184,31 @@
 {
 uint64_t pts;
 uint64_t tail;
-
-    // Decode image...
-    _SEGMENT *seg=_segments.getSegment(_currentSegment);
-    if(false== nextPictureInternal(seg->_reference,image))
-    {
-        goto np_nextSeg;
-    }
-        // Refresh in case we switched....
-        seg=_segments.getSegment(_currentSegment);
+    
+        // Decode image...
+        _SEGMENT *seg=_segments.getSegment(_currentSegment);
+        // Search it in the cache...
+        _VIDEOS *vid=_segments.getRefVideo(seg->_reference);
+        
+        uint64_t refPts=_currentPts-seg->_startTimeUs+seg->_refStartTimeUs; // time in the ref video
+        ADMImage *cached=vid->_videoCache->getAfter(refPts);
+        if(cached)
+        {
+            uint64_t delta=cached->Pts-seg->_refStartTimeUs;
+            if(delta<seg->_durationUs)
+            {
+                // Got it
+                image->duplicate(cached);
+            }else
+                goto np_nextSeg;
+        }else 
+        { // Not in cache, decode next one
+            if(false== nextPictureInternal(seg->_reference,image))
+            {
+                goto np_nextSeg;
+            }
+        }
+        // Got it, update timing
         updateImageTiming(seg,image);
         // no we have our image, let's check it is within this segment range..
         pts=image->Pts;
@@ -190,8 +220,7 @@
                 _segments.dump();
                 goto np_nextSeg;
         }
-        
-
+        _currentPts=pts;
         return true;
 
 // Try to get an image for the following segment....
@@ -207,12 +236,41 @@
             seg=_segments.getSegment(_currentSegment);
             samePictureInternal(seg->_reference,image);
             updateImageTiming(seg,image);
+            _currentPts=pts;
             return true;
-        } else  
+        } 
+        ADM_warning("Cannot get next picture. Last segment\n");
+        return false;
+}
+
+/**
+    \fn NextPicture
+    \brief decode & returns the next picture
+*/
+bool        ADM_Composer::previousPicture(ADMImage *image)
+{
+uint64_t pts;
+uint64_t tail;
+    
+        // Decode image...
+        _SEGMENT *seg=_segments.getSegment(_currentSegment);
+        // Search it in the cache...
+        _VIDEOS *vid=_segments.getRefVideo(seg->_reference);
+        
+        uint64_t refPts=_currentPts-seg->_startTimeUs+seg->_refStartTimeUs; // time in the ref video
+        ADMImage *cached=vid->_videoCache->getBefore(refPts);
+        if(cached)
         {
-                ADM_warning("Cannot get next picture. Last segment\n");
-                return false;
+            if(cached->Pts>=seg->_refStartTimeUs)
+            {
+                // Got it
+                image->duplicate(cached);
+                updateImageTiming(seg,image);
+                _currentPts=pts;
+                return true;
+            }
         }
+
         return false;
 }
 /**
@@ -222,13 +280,31 @@
 bool        ADM_Composer::samePicture(ADMImage *image)
 {
       _SEGMENT *seg=_segments.getSegment(_currentSegment);
-        if(false== samePictureInternal(seg->_reference,image))
-        {
-            ADM_warning("SamePicture failed\n");
-            return false;
-        }
-         updateImageTiming(seg,image);
-        return true;
+      _VIDEOS  *ref=_segments.getRefVideo(seg->_reference);
+
+        // Do Pts->ref PTs
+uint64_t refPts;
+uint64_t segTime;
+uint32_t segNo;
+    if(false==_segments.convertLinearTimeToSeg(_currentPts,&segNo,&segTime))
+    {
+          ADM_error("Cannot convert time in samePicture\n");         
+          return false;
+    }
+      ADM_assert(_currentSegment==segNo);
+      refPts=segTime+seg->_refStartTimeUs;
+
+      ADMImage *last=ref->_videoCache->getByPts(refPts);
+      if(last)
+      {
+            image->duplicate(last);
+            updateImageTiming(seg,image);
+            return true;
+      }
+      ADM_error("Cannot find same image in cache\n"); 
+      ADM_info("Looking for PTS=%"LLU" ms\n",refPts/1000);
+      ref->_videoCache->dump();
+      return false;
 }
 
 
@@ -338,8 +414,10 @@
 bool ADM_Composer::rewind(void)
 {
         ADM_info("Rewinding\n");
-        return switchToSegment(0);
-
+        if(switchToSegment(0)==false) return false;
+        _VIDEOS *vid=_segments.getRefVideo(_segments.getSegment(0)->_reference);
+        _currentPts=vid->lastDecodedPts;
+        return true;
 }
 /**
     \fn addSegment

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRenderInternal.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRenderInternal.cpp	2010-01-23 15:56:08 UTC (rev 5870)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRenderInternal.cpp	2010-01-23 19:30:19 UTC (rev 5871)
@@ -133,9 +133,9 @@
 bool ADM_Composer::nextPictureInternal(uint32_t ref,ADMImage *out)
 {
   ADMImage	*result;
-  EditorCache   *cache=_segments.getRefVideo(ref)->_videoCache;
+  
   _VIDEOS *vid=_segments.getRefVideo(ref);
-
+  EditorCache   *cache=vid->_videoCache;
   ADM_assert(vid);
 
    uint32_t loop=20; // Try 20 frames ahead

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx	2010-01-23 15:56:08 UTC (rev 5870)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx	2010-01-23 19:30:19 UTC (rev 5871)
@@ -100,7 +100,8 @@
                     uint32_t	_internalFlags;  // Flags :
                     ADM_PP      _pp;             // Postprocessing settings
                     ADMImage	*_imageBuffer;   // Temp buffer used for decoding
-                    uint32_t    _currentSegment;   // Current video segment
+                    uint64_t    _currentPts;        // Current image PTS
+                    uint32_t    _currentSegment;    // Current video segment
                     uint64_t    _nextFrameDts;      // COPYMODE Used in copy mode to fill the missing timestamp
                                                     // Warning, it is actually the DTS of the NEXT frame to fetch
 //****************************** Audio **********************************
@@ -152,6 +153,7 @@
                     bool        goToIntraTimeVideo(uint64_t time);
                     bool        nextPicture(ADMImage *image);
                     bool        samePicture(ADMImage *image);
+                    bool        previousPicture(ADMImage *image);
                     bool        rewind(void);
 // Used for stream copy
                     bool        GoToIntraTime_noDecoding(uint64_t time,uint32_t *toframe=NULL);

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.cpp	2010-01-23 15:56:08 UTC (rev 5870)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.cpp	2010-01-23 19:30:19 UTC (rev 5871)
@@ -541,7 +541,163 @@
     }
     return true;
 }
+
 /**
+      \fn admPreview::update
+      \brief display data associated with framenum image
+      @param image : current main image (input)
+      @param framenum, framenumber
+*/
+
+uint8_t admPreview::previousPicture(void)
+{
+    uint32_t fl,len,flags;	
+
+    switch(previewMode)
+    {
+      case ADM_PREVIEW_NONE:
+       {
+#if 0
+        if( !video_body->getUncompressedFrame(framenum+playbackOffset,rdrImage,&flags))
+        {
+          return 0; 
+        }
+#else
+
+        if(!video_body->previousPicture(rdrImage)) return 0;
+#endif
+            UI_setFrameType(  rdrImage->flags,rdrImage->_Qp);
+
+            if(zoom==ZOOM_1_1 || renderHasAccelZoom() )
+            {
+               if(!defered_display) 
+               {
+                  renderUpdateImage(rdrImage->data,zoom);
+                  
+                }
+            }else
+            {
+                ADM_assert(resizer);
+                ADM_assert(resized);
+                resizer->resize(rdrImage,resized);
+                if(!defered_display) 
+                  renderUpdateImage(resized->data,ZOOM_1_1);
+            }
+           // printf("[admPreview] PTs: %llu\n",rdrImage->Pts);
+        }
+        break;
+#if 0
+      case ADM_PREVIEW_OUTPUT:
+            if(framenum<=preview->getInfo()->nb_frames-1)
+                  {
+                          if(!preview->getFrameNumberNoAlloc(framenum,&len,previewImage,&fl)) return 0;
+                          if(zoom==ZOOM_1_1 || renderHasAccelZoom() )
+                          {
+                            if(!defered_display) renderUpdateImage(previewImage->data,zoom);
+                          }
+                          else
+                          {
+                             resizer->resize(previewImage,resized);
+                             if(!defered_display) 
+                                  renderUpdateImage(resized->data,ZOOM_1_1);
+                          }
+                  }
+            break;
+      case ADM_PREVIEW_SEPARATE:
+            ADM_assert(preview);
+            ADM_assert(previewImage);
+
+              if( !video_body->getUncompressedFrame(framenum+playbackOffset,rdrImage,&flags))
+              {
+                  return 0; 
+              }
+              UI_setFrameType(  rdrImage->flags,rdrImage->_Qp);
+
+            if(zoom==ZOOM_1_1 || renderHasAccelZoom()  )
+            {
+              if(!defered_display) 
+				  renderUpdateImage(rdrImage->data,zoom);
+            }
+			else
+            {
+                ADM_assert(resizer);
+                ADM_assert(resized);
+                resizer->resize(rdrImage,resized);
+                if(!defered_display) 
+                  renderUpdateImage(resized->data,zoom);
+            }
+          if( DIA_previewStillAlive())
+          {
+                  aprintf("Preview: Ask for frame %lu\n",framenum);
+                  if(framenum<=preview->getInfo()->nb_frames-1)
+                  {
+                          preview->getFrameNumberNoAlloc(framenum,&len,previewImage,&fl);
+                          if(!defered_display) DIA_previewUpdate(previewImage->data);
+                  }
+          }
+          break;
+      case ADM_PREVIEW_SIDE:
+              ADM_assert(preview);
+              ADM_assert(previewImage);
+              ADM_assert(original);
+              
+              if( !video_body->getUncompressedFrame(framenum+playbackOffset,rdrImage,&flags))
+              {
+                  return 0; 
+              }
+              UI_setFrameType(  rdrImage->flags,rdrImage->_Qp);
+              previewBlit(rdrImage,original,0,0);
+              
+              if(preview->getFrameNumberNoAlloc(framenum,&len,previewImage,&fl))
+              {
+                previewBlit(previewImage,original,rdrPhysicalW,0);
+              }
+              else printf("Cannot get frame %u\n",framenum);
+              if(zoom==ZOOM_1_1  || renderHasAccelZoom() )
+              {
+                if(!defered_display)
+                  renderUpdateImage(original->data,zoom);
+              }else
+              {
+                resizer->resize(original,resized);
+                if(!defered_display) 
+                  renderUpdateImage(resized->data,ZOOM_1_1);
+              }
+              break;
+        
+      case ADM_PREVIEW_TOP:
+              ADM_assert(preview);
+              ADM_assert(previewImage);
+              ADM_assert(original);
+              
+              if( !video_body->getUncompressedFrame(framenum+playbackOffset,rdrImage,&flags))
+              {
+                  return 0; 
+              }
+              UI_setFrameType(  rdrImage->flags,rdrImage->_Qp);
+              previewBlit(rdrImage,original,0,0);
+              if(preview->getFrameNumberNoAlloc(framenum,&len,previewImage,&fl))
+              {
+                previewBlit(previewImage,original,0,rdrPhysicalH);
+              }
+              else printf("Cannot get frame %u\n",framenum);
+              if(zoom==ZOOM_1_1 || renderHasAccelZoom() )
+              {
+                if(!defered_display)
+                  renderUpdateImage(original->data,zoom);
+              }else
+              {
+                resizer->resize(original,resized);
+                if(!defered_display) 
+                  renderUpdateImage(resized->data,ZOOM_1_1);
+              }
+              break;
+#endif
+      default: ADM_assert(0);
+    }
+    return true;
+}
+/**
       \fn previewBlit(ADMImage *from,ADMImage *to,uint32_t startx,uint32_t starty)
       \brief Blit "from" to "to" at position startx,starty
 */

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.h	2010-01-23 15:56:08 UTC (rev 5870)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.h	2010-01-23 19:30:19 UTC (rev 5871)
@@ -23,6 +23,7 @@
 {
   public:
       static uint8_t nextPicture(void);
+      static uint8_t previousPicture(void);
       static uint8_t samePicture(void);
 //      static uint8_t seekToIntra(uint32_t framenum);
       static bool seekToIntraPts(uint64_t timeframe);

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/gui_navigate.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/gui_navigate.cpp	2010-01-23 15:56:08 UTC (rev 5870)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/gui_navigate.cpp	2010-01-23 19:30:19 UTC (rev 5871)
@@ -329,7 +329,7 @@
     if (!avifileinfo)	return;
 
 
-    if (!admPreview::previousFrame())
+    if (!admPreview::previousPicture())
       {
             GUI_Error_HIG(QT_TR_NOOP("Error"),	QT_TR_NOOP("Cannot go to previous frame"));
             return;



From mean at mail.berlios.de  Sat Jan 23 20:30:31 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 23 Jan 2010 20:30:31 +0100
Subject: [Avidemux-svn-commit] r5872 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor
Message-ID: <201001231930.o0NJUVs5020589@sheep.berlios.de>

Author: mean
Date: 2010-01-23 20:30:28 +0100 (Sat, 23 Jan 2010)
New Revision: 5872

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edCache.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.h
Log:
[editor] Handle prev/next frame, not perfect yet

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edCache.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edCache.cpp	2010-01-23 19:30:19 UTC (rev 5871)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edCache.cpp	2010-01-23 19:30:28 UTC (rev 5872)
@@ -204,7 +204,7 @@
 */
 ADMImage    *EditorCache::getBefore(uint64_t pts)
 {
-    for(uint32_t i=readIndex+1;i<writeIndex;i++)
+    for(int i=readIndex+1;i<writeIndex;i++)
 	{
         int index=i%_nbImage;
         ADM_assert(_elem[index].pts!=ADM_NO_PTS);
@@ -212,6 +212,7 @@
         {
             index+=_nbImage-1;
             index%=_nbImage;
+            printf("GetBefore : Looking for %"LLU" ms get %"LLU" ms\n",pts/1000,_elem[index].image->Pts/1000);
             return _elem[index].image;
         }
     }

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp	2010-01-23 19:30:19 UTC (rev 5871)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp	2010-01-23 19:30:28 UTC (rev 5872)
@@ -26,6 +26,7 @@
 #endif
 
 #include "ADM_pp.h"
+#define SET_CURRENT_PTS(x) {printf("Old PTS: %"LLU" ms, new PTS %"LLU" ms\n",_currentPts,x);_currentPts=x;}
 /**
     \fn recalibrate
     \brief Convert time given in time from absolute ref video to linear time
@@ -132,8 +133,9 @@
         return false;
     }
     // Get the last decoded PTS and it is our current PTS
-    _currentPts=vid->lastDecodedPts+seg->_startTimeUs;
-    _currentPts-=seg->_refStartTimeUs;
+    uint64_t newPts=vid->lastDecodedPts+seg->_startTimeUs;
+    newPts-=seg->_refStartTimeUs;
+    SET_CURRENT_PTS(newPts);
 #if 0
     ADM_info("decodec DTS=%"LLU" ms\n",vid->lastDecodedPts/1000);
     ADM_info("startTime DTS=%"LLU" ms\n",seg->_startTimeUs/1000);
@@ -171,7 +173,7 @@
             return false;
     }
     _currentSegment=seg;
-    _currentPts=v->lastDecodedPts;
+    SET_CURRENT_PTS(v->lastDecodedPts);
     return true;
 
 }
@@ -220,7 +222,9 @@
                 _segments.dump();
                 goto np_nextSeg;
         }
-        _currentPts=pts;
+        
+        SET_CURRENT_PTS(pts);
+        ADM_info("Current PTS:%"LLU"\n",_currentPts);
         return true;
 
 // Try to get an image for the following segment....
@@ -236,7 +240,7 @@
             seg=_segments.getSegment(_currentSegment);
             samePictureInternal(seg->_reference,image);
             updateImageTiming(seg,image);
-            _currentPts=pts;
+            SET_CURRENT_PTS(pts);
             return true;
         } 
         ADM_warning("Cannot get next picture. Last segment\n");
@@ -249,9 +253,7 @@
 */
 bool        ADM_Composer::previousPicture(ADMImage *image)
 {
-uint64_t pts;
-uint64_t tail;
-    
+uint64_t targetPts=_currentPts;    
         // Decode image...
         _SEGMENT *seg=_segments.getSegment(_currentSegment);
         // Search it in the cache...
@@ -259,6 +261,7 @@
         
         uint64_t refPts=_currentPts-seg->_startTimeUs+seg->_refStartTimeUs; // time in the ref video
         ADMImage *cached=vid->_videoCache->getBefore(refPts);
+       
         if(cached)
         {
             if(cached->Pts>=seg->_refStartTimeUs)
@@ -266,11 +269,78 @@
                 // Got it
                 image->duplicate(cached);
                 updateImageTiming(seg,image);
-                _currentPts=pts;
+                SET_CURRENT_PTS(image->Pts);
                 return true;
             }
         }
+        ADM_info("Previous pic: %"LLU"\n",_currentPts);
+        ADM_info("while looking for frame %"LLU"\n",_currentPts);
+        vid->_videoCache->dump();
+        // The previous is not available
+        // either it is in the same segment but we have decoded later, or it is in the previous segment
+        // Let's check...
+        if(!_currentPts) return false;
+        uint64_t segTime;
+        uint32_t segNo;
+            if(false==_segments.convertLinearTimeToSeg(_currentPts-1,&segNo,&segTime))
+            {
+                  ADM_error("Cannot convert time in samePicture\n");         
+                  return false;
+            }
+        
+        seg=_segments.getSegment(segNo);
+        int ref=seg->_reference;
 
+        uint64_t refTime;
+        if(false==_segments.LinearToRefTime(segNo,_currentPts,&refTime))
+        {
+            ADM_warning("Cannot find ref time\n");
+            return false;
+        }
+        uint64_t previousKf;
+        if(false==searchPreviousKeyFrameInRef(ref,refTime,&previousKf))
+        {
+            ADM_warning("Cannot find previous keyframe in ref %d, time=%"LLU" \n",ref,refTime);
+            return false;
+        }
+        // Convert it to linear...
+        // We are in the right segment..
+        if(false==seektoTime(ref,previousKf,false))
+        {
+            ADM_warning("Cannot seek to time=%"LLU" \n",previousKf);
+            return false;            
+        }
+        // Update our _currentSegment
+        _currentSegment=segNo;
+        // Now forward till we reach out frame
+        while(1)
+        {
+            if(false==nextPicture(image))
+            {
+                    ADM_warning("Error in decoding forward");
+                    return false;
+            }
+            if(image->Pts==targetPts)
+            {
+                ADM_info("Decoding forward, we have our image, let's take its predecessor\n");
+                refPts=targetPts-seg->_startTimeUs+seg->_refStartTimeUs; // time in the ref video
+                cached=vid->_videoCache->getBefore(refPts);
+               
+                if(cached)
+                {
+                    if(cached->Pts>=seg->_refStartTimeUs)
+                    {
+                        // Got it
+                        image->duplicate(cached);
+                        updateImageTiming(seg,image);
+                        SET_CURRENT_PTS(image->Pts);
+                        return true;
+                    }
+                }
+                ADM_error("Find our frame and its predecessor, but it is out of range\n");
+                return false;
+            }
+        }
         return false;
 }
 /**
@@ -416,7 +486,7 @@
         ADM_info("Rewinding\n");
         if(switchToSegment(0)==false) return false;
         _VIDEOS *vid=_segments.getRefVideo(_segments.getSegment(0)->_reference);
-        _currentPts=vid->lastDecodedPts;
+        SET_CURRENT_PTS(vid->lastDecodedPts);
         return true;
 }
 /**

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp	2010-01-23 19:30:19 UTC (rev 5871)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp	2010-01-23 19:30:28 UTC (rev 5872)
@@ -50,7 +50,7 @@
   ref->_aviheader->getVideoInfo (&info);
   ref->_aviheader->getExtraHeaderData (&l, &d);
   ref->decoder = ADM_getDecoder (info.fcc,  info.width, info.height, l, d,info.bpp);
-  ref->_videoCache   =   new EditorCache(32,info.width,info.height) ;
+  ref->_videoCache   =   new EditorCache(8,info.width,info.height) ;
 
   float frameD=info.fps1000;
   frameD=frameD/1000;
@@ -522,4 +522,30 @@
     }
     return true;
 }
+/**
+    \fn LinearToRefTime
+    \brief Convert linear time to the time in the ref video
+
+*/
+bool        ADM_EditorSegment::LinearToRefTime(int segNo,uint64_t linear,uint64_t *refTime)
+{
+    _SEGMENT *seg=getSegment(segNo);
+    ADM_assert(seg);
+    if(linear<seg->_startTimeUs)
+    {
+        ADM_error("This given time is not in the segment: Given time %"LLU", seg start at %"LLU"\n",
+                        linear, seg->_startTimeUs);
+        return false;
+    }
+    if(linear>=seg->_startTimeUs+seg->_durationUs)
+    {
+        ADM_error("This given time is not in the segment: Given time %"LLU", seg end at %"LLU"\n",
+                        linear, seg->_startTimeUs+seg->_durationUs);
+        return false;
+
+    }
+    *refTime=seg->_refStartTimeUs+linear;
+    *refTime-=seg->_startTimeUs;
+    return true;
+}
 //EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.h	2010-01-23 19:30:19 UTC (rev 5871)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.h	2010-01-23 19:30:28 UTC (rev 5872)
@@ -137,6 +137,8 @@
 
             bool        removeChunk(uint64_t from, uint64_t to);
             bool        dtsFromPts(uint32_t refVideo,uint64_t pts,uint64_t *dts);
+
+            bool        LinearToRefTime(int segNo,uint64_t linear,uint64_t *refTime);
 };
 
 #endif



From mean at mail.berlios.de  Sat Jan 23 20:30:36 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 23 Jan 2010 20:30:36 +0100
Subject: [Avidemux-svn-commit] r5873 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor
Message-ID: <201001231930.o0NJUak6020623@sheep.berlios.de>

Author: mean
Date: 2010-01-23 20:30:33 +0100 (Sat, 23 Jan 2010)
New Revision: 5873

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx
Log:
[editor] Cleanup a bit the code for get previous frame

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp	2010-01-23 19:30:28 UTC (rev 5872)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp	2010-01-23 19:30:33 UTC (rev 5873)
@@ -246,7 +246,54 @@
         ADM_warning("Cannot get next picture. Last segment\n");
         return false;
 }
+/**
+    \fn decodeTillPicture
+    \brief that one is a bit different compare to goToTime as we
+                dont want to decode the targetPts if it is a keyframe
+                but have the frame before
+*/
+bool ADM_Composer::decodeTillPictureAtPts(uint64_t targetPts,ADMImage *image)
+{
+ // Go to the previous keyframe and decode forward...
+                _SEGMENT *seg=_segments.getSegment(_currentSegment);
+                int ref=seg->_reference;
 
+                uint64_t refTime;
+                if(false==_segments.LinearToRefTime(_currentSegment,targetPts-1,&refTime))
+                {
+                    ADM_warning("Cannot find ref time\n");
+                    return false;
+                }
+                uint64_t previousKf;
+                if(false==searchPreviousKeyFrameInRef(ref,refTime,&previousKf))
+                {
+                    ADM_warning("Cannot find previous keyframe in ref %d, time=%"LLU" \n",ref,refTime);
+                    return false;
+                }
+                // go to it...
+                if(false==seektoTime(ref,previousKf,false))
+                {
+                    ADM_warning("Cannot seek to time=%"LLU" \n",previousKf);
+                    return false;            
+                }
+                // Now forward till we reach out frame
+                while(1)
+                {
+                    if(false==nextPicture(image))
+                    {
+                            ADM_warning("Error in decoding forward");
+                            return false;
+                    }
+                    if(image->Pts==targetPts)
+                            break;
+                }
+                if(image->Pts!=targetPts)
+                {
+                    ADM_error("Could not retrieve our own frame at PTS=%"LLU" ms\n",targetPts/1000);
+                    return false;
+                }
+                return true;
+}
 /**
     \fn NextPicture
     \brief decode & returns the next picture
@@ -277,7 +324,8 @@
         ADM_info("while looking for frame %"LLU"\n",_currentPts);
         vid->_videoCache->dump();
         // The previous is not available
-        // either it is in the same segment but we have decoded later, or it is in the previous segment
+        // either it is in the same segment but we have decoded later in that segment
+        // , or it is in the previous segment
         // Let's check...
         if(!_currentPts) return false;
         uint64_t segTime;
@@ -287,45 +335,19 @@
                   ADM_error("Cannot convert time in samePicture\n");         
                   return false;
             }
-        
+        // Two possiblities
+        // 1- we are still in the same segment, in that case, we have to go back
+        // and decode forward 
+        // 2- We are at a jum, i.e. what we want is the last image from the previous segment
         seg=_segments.getSegment(segNo);
-        int ref=seg->_reference;
-
-        uint64_t refTime;
-        if(false==_segments.LinearToRefTime(segNo,_currentPts,&refTime))
+        if(segNo==_currentSegment) // Still in the same segment..
         {
-            ADM_warning("Cannot find ref time\n");
-            return false;
-        }
-        uint64_t previousKf;
-        if(false==searchPreviousKeyFrameInRef(ref,refTime,&previousKf))
-        {
-            ADM_warning("Cannot find previous keyframe in ref %d, time=%"LLU" \n",ref,refTime);
-            return false;
-        }
-        // Convert it to linear...
-        // We are in the right segment..
-        if(false==seektoTime(ref,previousKf,false))
-        {
-            ADM_warning("Cannot seek to time=%"LLU" \n",previousKf);
-            return false;            
-        }
-        // Update our _currentSegment
-        _currentSegment=segNo;
-        // Now forward till we reach out frame
-        while(1)
-        {
-            if(false==nextPicture(image))
-            {
-                    ADM_warning("Error in decoding forward");
+                if(false==decodeTillPictureAtPts(targetPts,image))
+                {
+                    ADM_error("Cannot decode till our current pts\n");
                     return false;
-            }
-            if(image->Pts==targetPts)
-            {
-                ADM_info("Decoding forward, we have our image, let's take its predecessor\n");
-                refPts=targetPts-seg->_startTimeUs+seg->_refStartTimeUs; // time in the ref video
+                }
                 cached=vid->_videoCache->getBefore(refPts);
-               
                 if(cached)
                 {
                     if(cached->Pts>=seg->_refStartTimeUs)
@@ -336,11 +358,16 @@
                         SET_CURRENT_PTS(image->Pts);
                         return true;
                     }
+                    ADM_warning("The image found is before refStartTime ???\n");
                 }
-                ADM_error("Find our frame and its predecessor, but it is out of range\n");
+                ADM_error("Find our frame and its predecessor (%"LLU"), but it is out of range\n",refPts);
+                vid->_videoCache->dump();
                 return false;
-            }
         }
+        ADM_assert(segNo+1==_currentSegment);
+        // it is basically the same as above except the exit condition is that the frame is out of reach
+        ADM_error("Searching across segment is not implemented\n");
+       
         return false;
 }
 /**

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp	2010-01-23 19:30:28 UTC (rev 5872)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp	2010-01-23 19:30:33 UTC (rev 5873)
@@ -566,9 +566,7 @@
 */
 uint64_t    ADM_Composer::getCurrentFramePts(void)
 {
-    _SEGMENT *seg=_segments.getSegment(_currentSegment);
-    _VIDEOS *vid=_segments.getRefVideo(seg->_reference);
-    return vid->lastDecodedPts;
+   return _currentPts;
 }
 /**
     \fn remove

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx	2010-01-23 19:30:28 UTC (rev 5872)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx	2010-01-23 19:30:33 UTC (rev 5873)
@@ -75,6 +75,8 @@
                     // Some useful functions...
                     void        recalibrate(uint64_t *time,_SEGMENT *seg);
                     bool        updateImageTiming(_SEGMENT *seg,ADMImage *image);
+                    // Need to get the image just before targetPts
+                    bool        decodeTillPictureAtPts(uint64_t targetPts,ADMImage *image);
 
 protected:
                                 /// Decode frame and on until frame is popped out of decoders



From mean at mail.berlios.de  Sat Jan 23 20:30:39 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 23 Jan 2010 20:30:39 +0100
Subject: [Avidemux-svn-commit] r5874 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor
Message-ID: <201001231930.o0NJUdb2020650@sheep.berlios.de>

Author: mean
Date: 2010-01-23 20:30:38 +0100 (Sat, 23 Jan 2010)
New Revision: 5874

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edCache.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp
Log:
[editor] Silence debug code

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edCache.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edCache.cpp	2010-01-23 19:30:33 UTC (rev 5873)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edCache.cpp	2010-01-23 19:30:38 UTC (rev 5874)
@@ -17,10 +17,13 @@
 #include "ADM_image.h"
 #include "ADM_editor/ADM_edCache.h"
 #define ADM_NO_PTS 0xffffffffffffffffLL
-#if 0
+
+#if 1
 #define aprintf(...) {}
+#define aADM_warning(...) {}
 #else
 #define aprintf printf
+#define aADM_warning(...) ADM_warning
 #endif
 /**
     \fn EditorCache
@@ -194,7 +197,7 @@
             return _elem[index].image;
         }
     }
-    ADM_warning("Cannot find image after %"LLU" ms in cache\n",pts/1000);
+    aADM_warning("Cannot find image after %"LLU" ms in cache\n",pts/1000);
     return NULL;
 }
 /**
@@ -216,7 +219,7 @@
             return _elem[index].image;
         }
     }
-    ADM_warning("Cannot find image before %"LLU" ms in cache\n",pts/1000);
+    aADM_warning("Cannot find image before %"LLU" ms in cache\n",pts/1000);
     return NULL;
 }
 

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp	2010-01-23 19:30:33 UTC (rev 5873)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp	2010-01-23 19:30:38 UTC (rev 5874)
@@ -19,14 +19,16 @@
 #include "ADM_default.h"
 #include "ADM_editor/ADM_edit.hxx"
 
-#if defined(ADM_DEBUG) && 0
+#if 0
 #define aprintf printf
+#define SET_CURRENT_PTS(x) {printf("Old PTS: %"LLU" ms, new PTS %"LLU" ms\n",_currentPts,x);_currentPts=x;}
 #else
 #define aprintf(...) {}// printf
+#define SET_CURRENT_PTS(x) {_currentPts=x;}
 #endif
 
 #include "ADM_pp.h"
-#define SET_CURRENT_PTS(x) {printf("Old PTS: %"LLU" ms, new PTS %"LLU" ms\n",_currentPts,x);_currentPts=x;}
+
 /**
     \fn recalibrate
     \brief Convert time given in time from absolute ref video to linear time
@@ -192,7 +194,8 @@
         // Search it in the cache...
         _VIDEOS *vid=_segments.getRefVideo(seg->_reference);
         
-        uint64_t refPts=_currentPts-seg->_startTimeUs+seg->_refStartTimeUs; // time in the ref video
+        uint64_t refPts;
+        _segments.LinearToRefTime(_currentSegment,_currentPts,&refPts);
         ADMImage *cached=vid->_videoCache->getAfter(refPts);
         if(cached)
         {
@@ -224,7 +227,7 @@
         }
         
         SET_CURRENT_PTS(pts);
-        ADM_info("Current PTS:%"LLU"\n",_currentPts);
+        //ADM_info("Current PTS:%"LLU"\n",_currentPts);
         return true;
 
 // Try to get an image for the following segment....
@@ -306,12 +309,14 @@
         // Search it in the cache...
         _VIDEOS *vid=_segments.getRefVideo(seg->_reference);
         
-        uint64_t refPts=_currentPts-seg->_startTimeUs+seg->_refStartTimeUs; // time in the ref video
+        uint64_t refPts;
+
+        _segments.LinearToRefTime(_currentSegment,_currentPts,&refPts);
         ADMImage *cached=vid->_videoCache->getBefore(refPts);
        
         if(cached)
         {
-            if(cached->Pts>=seg->_refStartTimeUs)
+            if(cached->Pts>=seg->_refStartTimeUs) // It might be in the cache but belonging to the previous seg
             {
                 // Got it
                 image->duplicate(cached);
@@ -366,6 +371,7 @@
         }
         ADM_assert(segNo+1==_currentSegment);
         // it is basically the same as above except the exit condition is that the frame is out of reach
+        // Either because we reached end of segment or end of source for that segment
         ADM_error("Searching across segment is not implemented\n");
        
         return false;



From mean at mail.berlios.de  Sat Jan 23 20:30:45 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 23 Jan 2010 20:30:45 +0100
Subject: [Avidemux-svn-commit] r5875 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor
Message-ID: <201001231930.o0NJUjGv020682@sheep.berlios.de>

Author: mean
Date: 2010-01-23 20:30:41 +0100 (Sat, 23 Jan 2010)
New Revision: 5875

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edCache.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edCache.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp
Log:
[editor] Go to previous frame across segments

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edCache.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edCache.cpp	2010-01-23 19:30:38 UTC (rev 5874)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edCache.cpp	2010-01-23 19:30:41 UTC (rev 5875)
@@ -239,5 +239,14 @@
     }
     return NULL;
 }
-
+/**
+    \fn getLast
+    \brief Return the most recent image from cache
+*/
+ADMImage *EditorCache::getLast(void)
+{
+    if(readIndex==writeIndex) return NULL;
+    int index=(writeIndex-1)%_nbImage;
+    return _elem[index].image;
+}
 // EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edCache.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edCache.h	2010-01-23 19:30:38 UTC (rev 5874)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edCache.h	2010-01-23 19:30:41 UTC (rev 5875)
@@ -41,5 +41,6 @@
             ADMImage    *getByPts(uint64_t Pts);            
             ADMImage    *getAfter(uint64_t Pts);
             ADMImage    *getBefore(uint64_t Pts);
+            ADMImage    *getLast(void);
 };
 #endif

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp	2010-01-23 19:30:38 UTC (rev 5874)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp	2010-01-23 19:30:41 UTC (rev 5875)
@@ -184,7 +184,7 @@
     \fn NextPicture
     \brief decode & returns the next picture
 */
-bool        ADM_Composer::nextPicture(ADMImage *image)
+bool        ADM_Composer::nextPicture(ADMImage *image,bool dontcross)
 {
 uint64_t pts;
 uint64_t tail;
@@ -232,6 +232,11 @@
 
 // Try to get an image for the following segment....
 np_nextSeg:
+        if(true==dontcross)
+        {
+            ADM_warning("Not allowed to cross segment\n");
+            return false;
+        }
         if(_currentSegment+1<_segments.getNbSegments())
         {
             if(switchToNextSegment()==false)
@@ -258,6 +263,7 @@
 bool ADM_Composer::decodeTillPictureAtPts(uint64_t targetPts,ADMImage *image)
 {
  // Go to the previous keyframe and decode forward...
+                uint32_t thisSeg=_currentSegment;
                 _SEGMENT *seg=_segments.getSegment(_currentSegment);
                 int ref=seg->_reference;
 
@@ -282,13 +288,15 @@
                 // Now forward till we reach out frame
                 while(1)
                 {
-                    if(false==nextPicture(image))
+                    if(false==nextPicture(image,true))
                     {
                             ADM_warning("Error in decoding forward");
                             return false;
                     }
-                    if(image->Pts==targetPts)
+                    if(image->Pts>=targetPts)
                             break;
+                    if(thisSeg!=_currentSegment)
+                            break;
                 }
                 if(image->Pts!=targetPts)
                 {
@@ -325,7 +333,6 @@
                 return true;
             }
         }
-        ADM_info("Previous pic: %"LLU"\n",_currentPts);
         ADM_info("while looking for frame %"LLU"\n",_currentPts);
         vid->_videoCache->dump();
         // The previous is not available
@@ -372,9 +379,45 @@
         ADM_assert(segNo+1==_currentSegment);
         // it is basically the same as above except the exit condition is that the frame is out of reach
         // Either because we reached end of segment or end of source for that segment
-        ADM_error("Searching across segment is not implemented\n");
-       
-        return false;
+        ADM_info("Searching across segment....\n");
+        if(false==switchToSegment(segNo))
+        {
+            ADM_error("Cannot switch to previous segment to get previous frame\n");
+            return false;
+        }
+        
+        seg=_segments.getSegment(_currentSegment);
+        vid=_segments.getRefVideo(seg->_reference);
+        
+
+        decodeTillPictureAtPts(targetPts,image);
+        _currentSegment=segNo;
+        // We may have overshot...
+        uint64_t last=vid->lastDecodedPts;
+        _segments.LinearToRefTime(_currentSegment,targetPts,&refPts);
+        ADMImage *candidate=vid->_videoCache->getLast();
+        if(!candidate)
+        {
+            ADM_error("No frame in cache !\n");
+            return false;
+        }
+        while(1)
+        {
+            if(candidate->Pts<refPts) // got it!
+            {
+                break;
+            }
+            // Try to go before...
+            ADMImage *img=vid->_videoCache->getBefore(candidate->Pts);
+            if(!img) break;
+            candidate=img;
+        }
+        image->duplicate(candidate);
+        updateImageTiming(seg,image);
+        SET_CURRENT_PTS(image->Pts);
+        return true;
+        
+        
 }
 /**
     \fn samePicture

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx	2010-01-23 19:30:38 UTC (rev 5874)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx	2010-01-23 19:30:41 UTC (rev 5875)
@@ -153,7 +153,7 @@
                     uint64_t    getCurrentFramePts(void);
                     bool        goToTimeVideo(uint64_t time);
                     bool        goToIntraTimeVideo(uint64_t time);
-                    bool        nextPicture(ADMImage *image);
+                    bool        nextPicture(ADMImage *image,bool dontcross=false);
                     bool        samePicture(ADMImage *image);
                     bool        previousPicture(ADMImage *image);
                     bool        rewind(void);

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp	2010-01-23 19:30:38 UTC (rev 5874)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp	2010-01-23 19:30:41 UTC (rev 5875)
@@ -533,19 +533,19 @@
     ADM_assert(seg);
     if(linear<seg->_startTimeUs)
     {
-        ADM_error("This given time is not in the segment: Given time %"LLU", seg start at %"LLU"\n",
+        ADM_warning("This given time is not in the segment: Given time %"LLU", seg start at %"LLU"\n",
                         linear, seg->_startTimeUs);
-        return false;
     }
     if(linear>=seg->_startTimeUs+seg->_durationUs)
     {
-        ADM_error("This given time is not in the segment: Given time %"LLU", seg end at %"LLU"\n",
+        ADM_warning("This given time is not in the segment: Given time %"LLU", seg end at %"LLU"\n",
                         linear, seg->_startTimeUs+seg->_durationUs);
-        return false;
 
     }
-    *refTime=seg->_refStartTimeUs+linear;
-    *refTime-=seg->_startTimeUs;
+    int64_t time=(int64_t)seg->_refStartTimeUs+(int64_t)linear;
+    time-=(int64_t)seg->_startTimeUs;
+    if(time<0) return false;
+    *refTime=(uint64_t )time;
     return true;
 }
 //EOF



From gruntster at mail.berlios.de  Sun Jan 24 21:07:41 2010
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Sun, 24 Jan 2010 21:07:41 +0100
Subject: [Avidemux-svn-commit] r5876 - in
	branches/avidemux_2.5_branch_gruntster/avidemux:
	ADM_UIs/ADM_QT4/include ADM_editor
	ADM_userInterfaces/ADM_QT4/ADM_dialog
Message-ID: <201001242007.o0OK7fKo013700@sheep.berlios.de>

Author: gruntster
Date: 2010-01-24 21:07:35 +0100 (Sun, 24 Jan 2010)
New Revision: 5876

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_QT4/include/ADM_toolkitQt.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_editor/ADM_edit.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_editor/ADM_edit.hxx
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_busy.cpp
Log:
[editor] remove 100 video restriction

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_QT4/include/ADM_toolkitQt.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_QT4/include/ADM_toolkitQt.h	2010-01-23 19:30:41 UTC (rev 5875)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_QT4/include/ADM_toolkitQt.h	2010-01-24 20:07:35 UTC (rev 5876)
@@ -2,6 +2,8 @@
 #define QT_TOOLKIT_H
 #include <QtGui/QWidget>
 
+void UI_purge(void);
+
 void qtRegisterDialog(QWidget *dialog);
 void qtUnregisterDialog(QWidget *dialog);
 QWidget* qtLastRegisteredDialog();

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_editor/ADM_edit.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_editor/ADM_edit.cpp	2010-01-23 19:30:41 UTC (rev 5875)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_editor/ADM_edit.cpp	2010-01-24 20:07:35 UTC (rev 5876)
@@ -100,11 +100,16 @@
   updatePostProc(&_pp);
   _imageBuffer=NULL;    
   _internalFlags=0;
-  // Start with a clean base
-  memset (_videos, 0, sizeof (_videos));
+
+  // Start with a clean base  
   max_seg = MAX_SEG;
   _segments = new _SEGMENT[max_seg];
   memset (_segments, 0, sizeof (_segments));
+
+  max_videos = MAX_VIDEO;
+  _videos = new _VIDEOS[max_videos];
+  memset(_videos, 0, sizeof(_VIDEOS) * max_videos);
+  
   _scratch=NULL;
   
 }
@@ -206,7 +211,7 @@
       _videos[vid]._videoCache=NULL;
     }
 
-  memset (_videos, 0, sizeof (_videos));
+  memset(_videos, 0, sizeof(_VIDEOS) * max_videos);
   
   
   if(_imageBuffer)
@@ -261,8 +266,26 @@
 
 UNUSED_ARG(mode);
 	_haveMarkers=0; // by default no markers are present
+
+  if (_nb_video == (max_videos - 1))
+  {
+	  max_videos += MAX_VIDEO;
+	  printf("extending max_videos: %i\n", max_videos);
+
+	  _VIDEOS *vid = new _VIDEOS[max_videos];
+
+	  memset(vid, 0, sizeof(_VIDEOS) * max_videos);
+	  memcpy(vid, _videos, sizeof(_VIDEOS) * (max_videos - MAX_VIDEO));
+
+	  delete _videos;
+	  _videos = vid;
+  }
+
+  if (_nb_segment == max_seg - 1)
+	  extendSegmentBuffer();
+
   ADM_assert (_nb_segment < max_seg);
-  ADM_assert (_nb_video < MAX_VIDEO);
+  ADM_assert (_nb_video < max_videos);
 
   // Autodetect file type ?
   if(Unknown_FileType==type)
@@ -853,6 +876,20 @@
 
   return 1;
 }
+
+void ADM_Composer::extendSegmentBuffer()
+{
+	max_seg += MAX_SEG;
+
+	_SEGMENT *s = new _SEGMENT[max_seg];
+
+	memset(s, 0, sizeof(_SEGMENT) * max_seg);
+	memcpy(s, _segments, sizeof(_SEGMENT) * (max_seg - MAX_SEG));
+
+	delete _segments;
+	_segments = s;
+}
+
 /*
         param:
                 source : source #
@@ -862,16 +899,9 @@
 uint8_t ADM_Composer::addSegment(uint32_t source,uint32_t start, uint32_t nb)
 {
         // do some sanity check
-        if(_nb_segment==max_seg-1)
-	{
-	   _SEGMENT *s;
-            max_seg += MAX_SEG;
-            s = new _SEGMENT[max_seg];
-            memset (s, 0, sizeof(_SEGMENT)*max_seg);
-            memcpy(s,_segments,sizeof(_SEGMENT)*(max_seg-MAX_SEG));
-            delete _segments;
-            _segments = s;
-        }
+        if (_nb_segment == max_seg - 1)
+			extendSegmentBuffer();
+
         if(_nb_video<=source)
         {
                 printf("[editor]: No such source %d/%d\n",source,_nb_video);

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_editor/ADM_edit.hxx
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_editor/ADM_edit.hxx	2010-01-23 19:30:41 UTC (rev 5875)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_editor/ADM_edit.hxx	2010-01-24 20:07:35 UTC (rev 5876)
@@ -135,7 +135,9 @@
 					uint32_t	max_seg;
   					_SEGMENT 		*_segments;
 					_SEGMENT 		_clipboard[MAX_SEG];
-					_VIDEOS 		_videos[MAX_VIDEO];
+
+					int max_videos;
+					_VIDEOS 		*_videos;
                                         ADMImage                *_scratch;
 						uint8_t  	convFrame2Seg(uint32_t framenum,uint32_t *seg,
 																			uint32_t *relframe);
@@ -160,6 +162,7 @@
 
   public:
                                                 uint8_t hasVBRVideos(void);
+												void extendSegmentBuffer();
                                                 uint8_t addSegment(uint32_t source,uint32_t start, uint32_t nb);
                                                 uint8_t deleteAllSegments(void);
   						uint8_t 	getExtraHeaderData(uint32_t *len, uint8_t **data);

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_busy.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_busy.cpp	2010-01-23 19:30:41 UTC (rev 5875)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_busy.cpp	2010-01-24 20:07:35 UTC (rev 5876)
@@ -17,12 +17,9 @@
  *   (at your option) any later version.                                   *
  *                                                                         *
  ***************************************************************************/
-#include "ADM_default.h"
-
-
 #include "DIA_busy.h"
+#include "ADM_toolkitQt.h"
 
-
 void DIA_StartBusy( void )
 {
 
@@ -35,6 +32,7 @@
 
 void DIA_StartBusyDialog( void )
 {
+	UI_purge();
 }
 
 void DIA_StopBusyDialog( void )
@@ -43,4 +41,5 @@
 
 void DIA_runBusy( void )
 {
+	UI_purge();
 }



From mean at mail.berlios.de  Wed Jan 27 07:42:06 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 27 Jan 2010 07:42:06 +0100
Subject: [Avidemux-svn-commit] r5877 -
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src
Message-ID: <201001270642.o0R6g6u3012552@sheep.berlios.de>

Author: mean
Date: 2010-01-27 07:42:03 +0100 (Wed, 27 Jan 2010)
New Revision: 5877

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_image.cpp
Log:
[image] half cosmetic, return a value if we say we do

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_image.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_image.cpp	2010-01-24 20:07:35 UTC (rev 5876)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_image.cpp	2010-01-27 06:42:03 UTC (rev 5877)
@@ -244,6 +244,7 @@
 	flags=src->flags;
 	_aspect=src->_aspect;
     Pts=src->Pts;
+    return 1;
 }
 //
 //	By design the reallocation of quant should happen at startup



From mean at mail.berlios.de  Wed Jan 27 07:42:10 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 27 Jan 2010 07:42:10 +0100
Subject: [Avidemux-svn-commit] r5878 - in
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder:
	include src
Message-ID: <201001270642.o0R6gA2k012635@sheep.berlios.de>

Author: mean
Date: 2010-01-27 07:42:09 +0100 (Wed, 27 Jan 2010)
New Revision: 5878

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/include/ADM_coreVideoEncoderFFmpeg.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/ADM_coreVideoEncoderFFmpeg.cpp
Log:
[lavcodec/encoder] Return a valid dts/pts pair. Mandatory if the input is vfr

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/include/ADM_coreVideoEncoderFFmpeg.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/include/ADM_coreVideoEncoderFFmpeg.h	2010-01-27 06:42:03 UTC (rev 5877)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/include/ADM_coreVideoEncoderFFmpeg.h	2010-01-27 06:42:09 UTC (rev 5878)
@@ -103,6 +103,7 @@
                FILE             *statFile;
                int              pass;   // Pass number = 1 or 2, valid only if we use 2 pass mode
                bool             _isMT; // True if multithreaded
+               uint64_t         nextDts;
 protected:
     virtual               bool             prolog(void); 
     virtual               bool             preEncode(void); 
@@ -114,8 +115,9 @@
                           bool             setupPass(void);  
                           bool             encoderMT (void);
 public:
-                            ADM_coreVideoEncoderFFmpeg(ADM_coreVideoFilter *src,FFcodecSetting *settings=NULL);
-virtual                     ~ADM_coreVideoEncoderFFmpeg();
+                                            ADM_coreVideoEncoderFFmpeg(ADM_coreVideoFilter *src,FFcodecSetting *settings=NULL);
+virtual                                     ~ADM_coreVideoEncoderFFmpeg();
+virtual                   uint64_t          getDelayUs(void);
 
 };
 #endif
\ No newline at end of file

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/ADM_coreVideoEncoderFFmpeg.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/ADM_coreVideoEncoderFFmpeg.cpp	2010-01-27 06:42:03 UTC (rev 5877)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/ADM_coreVideoEncoderFFmpeg.cpp	2010-01-27 06:42:09 UTC (rev 5878)
@@ -21,7 +21,11 @@
 #include "prefs.h"
 #define ADM_NO_PTS 0xFFFFFFFFFFFFFFFFLL // FIXME
 //#define TIME_TENTH_MILLISEC
-#define aprintf(...) {}
+#if 1
+    #define aprintf(...) {}
+#else
+    #define aprintf printf
+#endif
 
 typedef struct
 {
@@ -34,8 +38,8 @@
 {
     {  40000,40000,1 ,25},
     {  20000,20000,1 ,50},
-    {  33360,33369,30,1001},
-    {  41700,41710,24,1001},
+    {  33360,33369,1001,30000},
+    {  41700,41710,1001,24000},
 }; 
 
 /**
@@ -78,8 +82,17 @@
     *d=base;
     return true;
 }
-
 /**
+    \fn getDelayUs
+*/
+uint64_t          ADM_coreVideoEncoderFFmpeg::getDelayUs(void)
+{
+    ADM_assert(_context);
+    ADM_assert(source);
+uint64_t d=source->getInfo()->frameIncrement;
+        return d*_context->max_b_frames;
+}
+/**
     \fn ADM_coreVideoEncoderFFmpeg
     \brief Constructor
 
@@ -206,30 +219,10 @@
         return false;
     }
     prolog();
-#if 1
-    _frame.pts=AV_NOPTS_VALUE;
-#else
-    // put a time stamp...
-    if(image->Pts==ADM_NO_PTS) 
-    {
-        ADM_assert(0);
-        _frame.pts=AV_NOPTS_VALUE;
-    }
-    else
-    {
-        float f=image->Pts,n=_context->time_base.num,d=_context->time_base.den;
-#ifdef TIME_TENTH_MILLISEC
-        f=f/100;
-#else
-        f=f/1000;
-        f=f/n;
-#endif
-        _frame.pts=f;
 
-        //printf("*** PTS:%d time_base :%d/%d\n",_frame.pts,_context->time_base.num,_context->time_base.den);
-    }
-#endif
-    //
+    double p=image->Pts;
+    nextDts=image->Pts;
+    _frame.pts= floor(p / (1000000.*av_q2d(_context->time_base) + 0.5));    //
     //printf("[PTS] :%"LU" num:%"LU" den:%"LU"\n",_frame.pts,_context->time_base.num,_context->time_base.den);
     //
     switch(targetColorSpace)
@@ -375,12 +368,14 @@
         out->flags=AVI_KEY_FRAME;
     else if(pict_type==FF_B_TYPE)
             out->flags=AVI_B_FRAME;
-    out->pts=out->dts=image->Pts;
-    // Update PTS/Dts
-    out->pts=_frame.reordered_opaque;
-    out->dts=-1; // FIXME
     
+    // Update PTS/Dts
 
+    out->pts=getDelayUs();
+    out->pts+= _context->coded_frame->pts * 1000000.*av_q2d(_context->time_base);
+    out->dts=nextDts; // FIXME
+    aprintf("Out pts=%"LLU" us\n",out->pts);    
+
     // Update quant
     if(!_context->coded_frame->quality)
       out->out_quantizer=(int) floor (_frame.quality / (float) FF_QP2LAMBDA);



From mean at mail.berlios.de  Wed Jan 27 19:52:24 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 27 Jan 2010 19:52:24 +0100
Subject: [Avidemux-svn-commit] r5879 - in branches/avidemux_2.6_branch_mean:
	avidemux/common/ADM_muxerGate/src
	avidemux_core/ADM_coreMuxer/include
	avidemux_core/ADM_coreVideoEncoder/include
	avidemux_core/ADM_coreVideoEncoder/src
Message-ID: <201001271852.o0RIqO04010641@sheep.berlios.de>

Author: mean
Date: 2010-01-27 19:52:23 +0100 (Wed, 27 Jan 2010)
New Revision: 5879

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoProcess.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/include/ADM_muxer.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/include/ADM_coreVideoEncoder.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/include/ADM_coreVideoEncoderFFmpeg.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/include/ADM_coreVideoEncoderInternal.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/ADM_coreVideoEncoder.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/ADM_coreVideoEncoderFFmpeg.cpp
Log:
[muxer/Encoder] Make changes so that videoEncoder can declare the delay they are introducing and so that it is propagated to the videoStream. Finally the information is available at muxer level so that they can compensate by delaying the audio in the same amount

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoProcess.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoProcess.cpp	2010-01-27 06:42:09 UTC (rev 5878)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoProcess.cpp	2010-01-27 18:52:23 UTC (rev 5879)
@@ -39,6 +39,8 @@
     bitstream=new ADMBitstream(width*height*4);
     data=new uint8_t [width*height*4];
     bitstream->data=data;
+    videoDelay=encoder->getEncoderDelay();
+    printf("[StreamProcess] Video Encoder Delay=%"LLU"ms\n",videoDelay/1000);
 }
 /**
     \fn ADM_videoStreamProcess

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/include/ADM_muxer.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/include/ADM_muxer.h	2010-01-27 06:42:09 UTC (rev 5878)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/include/ADM_muxer.h	2010-01-27 18:52:23 UTC (rev 5879)
@@ -22,17 +22,19 @@
             uint32_t width,height,averageFps1000;
             uint32_t fourCC;
             bool     isCFR;
+            uint64_t videoDelay;
 
 
             DIA_workingBase *encoding;
 public:
-                      ADM_videoStream() {};
+                      ADM_videoStream() {videoDelay=0;} ;
             virtual ~ADM_videoStream() {};
             uint32_t getWidth(void) {return width;}
             uint32_t getHeight(void) {return height;}
             uint32_t getFCC(void) {return fourCC;}
             bool     getIsCfr(void) {return isCFR;}
             uint32_t getAvgFps1000(void) {return averageFps1000;}
+            uint64_t getVideoDelay(void) {return videoDelay;}
 
 virtual     bool     getPacket(uint32_t *len, uint8_t *data, uint32_t maxLen,uint64_t *pts,uint64_t *dts,
                                         uint32_t *flags)=0;

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/include/ADM_coreVideoEncoder.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/include/ADM_coreVideoEncoder.h	2010-01-27 06:42:09 UTC (rev 5878)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/include/ADM_coreVideoEncoder.h	2010-01-27 18:52:23 UTC (rev 5879)
@@ -37,6 +37,7 @@
 protected:
                             ADM_coreVideoFilter *source;
                             ADMImage            *image;
+                            uint64_t            encoderDelay;
 public:
                             ADM_coreVideoEncoder(ADM_coreVideoFilter *src);
 virtual                     ~ADM_coreVideoEncoder();
@@ -52,6 +53,7 @@
                uint32_t    getFrameIncrement(void) {return source->getInfo()->frameIncrement;}
                uint64_t    getTotalDuration(void) {return source->getInfo()->totalDuration;}
 virtual        bool        setPassAndLogFile(int pass,const char *name) {return false;}
+               uint64_t    getEncoderDelay(void){return encoderDelay;}
 };
 
 #endif

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/include/ADM_coreVideoEncoderFFmpeg.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/include/ADM_coreVideoEncoderFFmpeg.h	2010-01-27 06:42:09 UTC (rev 5878)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/include/ADM_coreVideoEncoderFFmpeg.h	2010-01-27 18:52:23 UTC (rev 5879)
@@ -117,7 +117,6 @@
 public:
                                             ADM_coreVideoEncoderFFmpeg(ADM_coreVideoFilter *src,FFcodecSetting *settings=NULL);
 virtual                                     ~ADM_coreVideoEncoderFFmpeg();
-virtual                   uint64_t          getDelayUs(void);
 
 };
 #endif
\ No newline at end of file

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/include/ADM_coreVideoEncoderInternal.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/include/ADM_coreVideoEncoderInternal.h	2010-01-27 06:42:09 UTC (rev 5878)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/include/ADM_coreVideoEncoderInternal.h	2010-01-27 18:52:23 UTC (rev 5879)
@@ -15,7 +15,7 @@
 #ifndef VIDEOENCODERINTERNAL_H
 #define VIDEOENCODERINTERNAL_H
 
-#define ADM_VIDEO_ENCODER_API_VERSION 2
+#define ADM_VIDEO_ENCODER_API_VERSION 3
 #include "ADM_coreVideoEncoder.h"
 #include "DIA_uiTypes.h"
 #include "ADM_paramList.h"

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/ADM_coreVideoEncoder.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/ADM_coreVideoEncoder.cpp	2010-01-27 06:42:09 UTC (rev 5878)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/ADM_coreVideoEncoder.cpp	2010-01-27 18:52:23 UTC (rev 5879)
@@ -25,7 +25,7 @@
 {
     source=src;
     image=NULL;
-
+    encoderDelay=0;
 }
 
 /**

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/ADM_coreVideoEncoderFFmpeg.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/ADM_coreVideoEncoderFFmpeg.cpp	2010-01-27 06:42:09 UTC (rev 5878)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/ADM_coreVideoEncoderFFmpeg.cpp	2010-01-27 18:52:23 UTC (rev 5879)
@@ -83,16 +83,6 @@
     return true;
 }
 /**
-    \fn getDelayUs
-*/
-uint64_t          ADM_coreVideoEncoderFFmpeg::getDelayUs(void)
-{
-    ADM_assert(_context);
-    ADM_assert(source);
-uint64_t d=source->getInfo()->frameIncrement;
-        return d*_context->max_b_frames;
-}
-/**
     \fn ADM_coreVideoEncoderFFmpeg
     \brief Constructor
 
@@ -121,7 +111,8 @@
     statFileName=NULL;
     statFile=NULL;
     _isMT=false;
-
+    encoderDelay=source->getInfo()->frameIncrement*Settings.max_b_frames;
+    ADM_info("[Lavcodec] Using a video encoder delay of %d ms\n",(int)(encoderDelay/1000));
 }
 /**
     \fn ADM_coreVideoEncoderFFmpeg
@@ -371,7 +362,7 @@
     
     // Update PTS/Dts
 
-    out->pts=getDelayUs();
+    out->pts=getEncoderDelay();
     out->pts+= _context->coded_frame->pts * 1000000.*av_q2d(_context->time_base);
     out->dts=nextDts; // FIXME
     aprintf("Out pts=%"LLU" us\n",out->pts);    



From mean at mail.berlios.de  Fri Jan 29 19:29:26 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 29 Jan 2010 19:29:26 +0100
Subject: [Avidemux-svn-commit] r5880 -
	branches/avidemux_2.6_branch_mean/avidemux/common
Message-ID: <201001291829.o0TITQZ2019155@sheep.berlios.de>

Author: mean
Date: 2010-01-29 19:29:23 +0100 (Fri, 29 Jan 2010)
New Revision: 5880

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/main.cpp
Log:
[vdpau] re-enable vdpau

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/main.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/main.cpp	2010-01-27 18:52:23 UTC (rev 5879)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/main.cpp	2010-01-29 18:29:23 UTC (rev 5880)
@@ -25,6 +25,7 @@
 #include "config.h"
 #include "ADM_default.h"
 #include "ADM_threads.h"
+#include "DIA_uiTypes.h"
 
 #define __DECLARE__
 #include "avi_vars.h"
@@ -289,10 +290,14 @@
 	__try1(exceptionHandler);
 #endif
 
-#if defined( USE_VDPAU) && (ADM_UI_TYPE_BUILD!=ADM_UI_CLI)
+#if defined( USE_VDPAU) 
+  #if (ADM_UI_TYPE_BUILD!=ADM_UI_CLI)
     printf("Probing for VDPAU...\n");
     if(vdpauProbe()==true) printf("VDPAU available\n");
         else printf("VDPAU not available\n");
+  #else
+    printf("Cannot use VDPAU in cli mode %d,%d\n",ADM_UI_TYPE_BUILD,ADM_UI_CLI);
+  #endif
 #endif
 
     UI_RunApp();



From mean at mail.berlios.de  Sat Jan 30 14:11:51 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 30 Jan 2010 14:11:51 +0100
Subject: [Avidemux-svn-commit] r5882 - in
	branches/avidemux_2.6_branch_mean/avidemux_core:
	ADM_coreUtils/src ADM_coreVideoEncoder/include
	ADM_coreVideoEncoder/src
Message-ID: <201001301311.o0UDBpFB000585@sheep.berlios.de>

Author: mean
Date: 2010-01-30 14:11:50 +0100 (Sat, 30 Jan 2010)
New Revision: 5882

Added:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/FFcodecContext_desc.cpp
Removed:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/include/FFcodecContext_desc.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_paramList.cpp
Log:
[paramList] Also declare COMPRES_PARAM as a parameter in configuration

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_paramList.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_paramList.cpp	2010-01-30 13:11:48 UTC (rev 5881)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_paramList.cpp	2010-01-30 13:11:50 UTC (rev 5882)
@@ -1,8 +1,12 @@
 /** *************************************************************************
     \file ADM_paramList
     \brief Handle Param list 
-                      
-    copyright            : (C) 2009 by mean
+    \author  mean (C) 2009/2010   fixounet at free.fr                
+    Usually only basic types should be handled by this
+    We make 2 exceptions though :
+        * lavcodec settings as we use a lot of derivative class. It is to simplify derivative configuration
+        * same for COMPRESS_PARAMS, since is used by all video encoder, it is "smart" to make it a dedicated 
+                    configuration type.
     
  ***************************************************************************/
 
@@ -15,24 +19,178 @@
  ***************************************************************************/
 #include "ADM_default.h"
 #include "ADM_paramList.h"
+#include <stddef.h>
+#include "ADM_encoderConf.h"
 #include "ADM_coreVideoEncoderFFmpeg_param.h"
+#include "../src/FFcodecContext_desc.cpp"
+#define MAX_LAV_STRING 1024
+/**
+    \fn loadCoupleFromString
+*/
+static bool loadCoupleFromString(const char *str,const ADM_paramList *tmpl,void *data)
+{
+  // Split str to couples...
+    uint32_t nb=0;
+    const char *s=str;
+    char tmp[256];
+    while(*s)
+    {
+        if(*s==':') nb++;
+        s++;
+    }
 
+    int p=0;
+    const ADM_paramList *l=tmpl;
+    while(l->paramName)
+    {
+        p++;
+        l++;
+    };
+    if(nb!=p)
+    {
+        ADM_error("Mistmatch in the number of parameters (%d/%d)\n",(int)nb,(int)p);
+        return false;
+    }
+    CONFcouple *couples=new CONFcouple(nb);
+    s=str;
+    const char *n;
+    for(int i=0;i<nb;i++)
+    {
+        if(*s!=':')
+        {
+            ADM_error("Bad split :%s insteald of ':'\n",s);
+            delete [] couples;
+            return false;
+        }
+        n=s+1;
+        while(*n!=':') n++;
+        n--;
+        memcpy(tmp,s+1,n-s);
+        tmp[n-s]=0;       
+        s=n+1;
+       // printf("tmp:%s\n",tmp);
+        // Now we have aaa=bbb in tmp, split it
+        char *equal,*tail;
+        equal=tmp;
+        tail=tmp+strlen(tmp);
+        while(*equal!='=' && equal<tail)
+        {
+            equal++;
+        }
+        if(*equal!='=')
+        {
+            ADM_error("Malformed string :%s\n",tmp);
+            delete [] couples;
+            return false;
+        }
+        *equal=0;
+        couples->setInternalName(tmp,equal+1);
+       // printf("%s->%s\n",tmp,equal+1);
+    }
+    // Now build structure from couple
+    bool r=ADM_paramLoad(couples, tmpl,data);
+    delete  couples;
+    return r;
+}
+
+
+/**
+    \fn lavReadFromString
+*/
 static bool lavReadFromString(FFcodecContext *ctx,const char *str)
 {
-    printf("String:%s\n",str);
-    return true;
+   return  loadCoupleFromString(str,FFcodecContext_param,ctx);
 }
+/**
+    \fn lavWriteToString
+*/
 static bool lavWriteToString(FFcodecContext *ctx,char **str)
 {
-    *str=ADM_strdup("foobar");
+    CONFcouple *couples=NULL;
+    if(false==ADM_paramSave(&couples, FFcodecContext_param,ctx))
+    {
+        ADM_error("ADM_paramSave failed (lavContext)\n");
+        return false;
+    }
+    // Iterate through ctx and save..
+    char *s=(char *)ADM_alloc(MAX_LAV_STRING);
+    char tmp[256];
+    *s=0;
+    *str=s;
+    uint32_t nb=couples->getSize();
+    for(int i=0;i<nb;i++)
+    {
+        char *name,*value;
+        couples->getInternalName(i,&name,&value);
+        sprintf(tmp,":%s=%s",name,value);
+        ADM_assert(strlen(tmp)<255);
+        strcat(s,tmp);
+        ADM_assert(strlen(s)<MAX_LAV_STRING);
+    }
+    delete couples;
     return true;
 }
-
 /**
+    \fn compressReadFromString
+*/
+static bool compressReadFromString(COMPRES_PARAMS *params,const char *str)
+{
+    char tmp[256];
+    if(!strcasecmp(str,"SAME"))
+    {
+        params->mode=COMPRESS_SAME;
+        return true;
+    }
+    // all other are in the form a=b
+    strcpy(tmp,str);
+    char *s=tmp;
+    while(*s)
+    {
+        if(*s=='=') break;
+        s++;
+    }
+    if(!(*s))
+    {
+        ADM_error("Malformed compressVideo line (%s)\n",str);
+        return false;
+    }
+    *s=0;
+    uint32_t val=atoi(s+1);
+    if(!strcasecmp(tmp,"CQ"))    {params->mode=COMPRESS_CQ;params->qz=val;return true;}
+    if(!strcasecmp(tmp,"CBR"))   {params->mode=COMPRESS_CBR;params->bitrate=val;return true;}
+    if(!strcasecmp(tmp,"2PASS")) {params->mode=COMPRESS_2PASS;params->finalsize=val;return true;}
+    if(!strcasecmp(tmp,"2PASSBITRATE")) {params->mode=COMPRESS_2PASS_BITRATE;params->avg_bitrate=val;return true;}
+    if(!strcasecmp(tmp,"AQ")) {params->mode=COMPRESS_AQ;params->qz=val;return true;}
+    ADM_error("Unknown mode :%s\n",tmp);
+    return false;
+    
+}
+/**
+    \fn compressWriteToString
+*/
+static bool compressWriteToString(COMPRES_PARAMS *params,  char **str)
+{
+    char tmp[256];
+    switch(params->mode)
+    {
+        case COMPRESS_CQ:    sprintf(tmp,"CQ=%"LU,params->qz);break;
+        case COMPRESS_CBR:   sprintf(tmp,"CBR=%"LU,params->bitrate);break;
+        case COMPRESS_2PASS: sprintf(tmp,"2PASS=%"LU,params->finalsize);break;
+        case COMPRESS_SAME:  sprintf(tmp,"SAME");break;
+        case COMPRESS_2PASS_BITRATE: sprintf(tmp,"2PASSBITRATE=%"LU,params->avg_bitrate);break;
+        case COMPRESS_AQ:    sprintf(tmp,"AQ=%"LU,params->qz);break;
+        default:
+            ADM_error("Unknown compressin mode \n");
+            return false;
+    }
+    *str=ADM_strdup(tmp);
+    return true;
+}
+/**
     \fn ADM_paramValidate
     \brief Check the confcouples match the param list
 */
-bool ADM_paramValidate(CONFcouple *couples, const ADM_paramList *params)
+bool ADM_paramValidate(CONFcouple *couples, const    ADM_paramList *params)
 {
     int n=couples->getSize();
     int found=0;
@@ -83,6 +241,23 @@
            SWAL(ADM_param_int32_t, int32_t, i32,Int32)
            SWAL(ADM_param_float,   float ,  f,Float)
            SWAL(ADM_param_bool,    bool ,   b,Bool)
+           case ADM_param_video_encode:
+                        {
+                        char *lavString;
+                        if(false==couples->readAsString(name,&lavString))
+                        {
+                                ADM_error("Error reading video_encode conf");
+                                return false;
+                        }
+                        bool r=compressReadFromString((COMPRES_PARAMS *)(address+params[i].offset),lavString);
+                        ADM_dezalloc(lavString);
+                        if(false==r)
+                            {
+                                    ADM_error("Error reading codecParam string");
+                                    return false;
+                            }
+                        }
+                        break;
            case ADM_param_lavcodec_context:
                         {
                         char *lavString;
@@ -108,7 +283,7 @@
 }
 /**
     \fn ADM_paramLoad
-    \brief Load a structure from a list of confCouple
+    \brief Save a structure to a list of confCouple
 */
 bool ADM_paramSave(CONFcouple **couples, const ADM_paramList *params,void *s)
 {
@@ -138,6 +313,23 @@
            SWAL(ADM_param_int32_t, int32_t, i32,Int32)
            SWAL(ADM_param_float,   float ,  f,Float)
            SWAL(ADM_param_bool,    bool ,   b,Bool)
+            case ADM_param_video_encode:
+              {
+                        char *lavString;
+                        if(false==compressWriteToString((COMPRES_PARAMS *)(address+params[i].offset),&lavString))
+                        {
+                                ADM_error("Error writing paramvideo string");
+                                return false;
+                        }
+                        bool r=c->setInternalName(name,lavString);
+                        ADM_dezalloc(lavString);
+                        if(false==r)
+                        {
+                                ADM_error("Error writing paramvideo conf");
+                                return false;
+                        }
+              }
+                break;
            case ADM_param_lavcodec_context:
               {
                         char *lavString;

Deleted: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/include/FFcodecContext_desc.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/include/FFcodecContext_desc.cpp	2010-01-30 13:11:48 UTC (rev 5881)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/include/FFcodecContext_desc.cpp	2010-01-30 13:11:50 UTC (rev 5882)
@@ -1,44 +0,0 @@
-// Automatically generated, do not edit!
-const ADM_paramList FFcodecContext_param[]={
- {"version",offsetof( FFcodecContext,version),"uint32_t",ADM_param_uint32_t},
- {"MultiThreaded",offsetof( FFcodecContext,MultiThreaded),"bool",ADM_param_bool},
- {"me_method",offsetof( FFcodecContext,me_method),"uint32_t",ADM_param_uint32_t},
- {"_GMC",offsetof( FFcodecContext,_GMC),"uint32_t",ADM_param_uint32_t},
- {"_4MV",offsetof( FFcodecContext,_4MV),"uint32_t",ADM_param_uint32_t},
- {"_QPEL",offsetof( FFcodecContext,_QPEL),"uint32_t",ADM_param_uint32_t},
- {"_TRELLIS_QUANT",offsetof( FFcodecContext,_TRELLIS_QUANT),"uint32_t",ADM_param_uint32_t},
- {"qmin",offsetof( FFcodecContext,qmin),"uint32_t",ADM_param_uint32_t},
- {"qmax",offsetof( FFcodecContext,qmax),"uint32_t",ADM_param_uint32_t},
- {"max_qdiff",offsetof( FFcodecContext,max_qdiff),"uint32_t",ADM_param_uint32_t},
- {"max_b_frames",offsetof( FFcodecContext,max_b_frames),"uint32_t",ADM_param_uint32_t},
- {"mpeg_quant",offsetof( FFcodecContext,mpeg_quant),"uint32_t",ADM_param_uint32_t},
- {"is_luma_elim_threshold",offsetof( FFcodecContext,is_luma_elim_threshold),"uint32_t",ADM_param_uint32_t},
- {"luma_elim_threshold",offsetof( FFcodecContext,luma_elim_threshold),"uint32_t",ADM_param_uint32_t},
- {"is_chroma_elim_threshold",offsetof( FFcodecContext,is_chroma_elim_threshold),"uint32_t",ADM_param_uint32_t},
- {"chroma_elim_threshold",offsetof( FFcodecContext,chroma_elim_threshold),"uint32_t",ADM_param_uint32_t},
- {"lumi_masking",offsetof( FFcodecContext,lumi_masking),"float",ADM_param_float},
- {"is_lumi_masking",offsetof( FFcodecContext,is_lumi_masking),"int32_t",ADM_param_int32_t},
- {"dark_masking",offsetof( FFcodecContext,dark_masking),"float",ADM_param_float},
- {"is_dark_masking",offsetof( FFcodecContext,is_dark_masking),"int32_t",ADM_param_int32_t},
- {"qcompress",offsetof( FFcodecContext,qcompress),"float",ADM_param_float},
- {"qblur",offsetof( FFcodecContext,qblur),"float",ADM_param_float},
- {"minBitrate",offsetof( FFcodecContext,minBitrate),"uint32_t",ADM_param_uint32_t},
- {"maxBitrate",offsetof( FFcodecContext,maxBitrate),"uint32_t",ADM_param_uint32_t},
- {"user_matrix",offsetof( FFcodecContext,user_matrix),"uint32_t",ADM_param_uint32_t},
- {"gop_size",offsetof( FFcodecContext,gop_size),"uint32_t",ADM_param_uint32_t},
- {"interlaced",offsetof( FFcodecContext,interlaced),"uint32_t",ADM_param_uint32_t},
- {"bff",offsetof( FFcodecContext,bff),"uint32_t",ADM_param_uint32_t},
- {"widescreen",offsetof( FFcodecContext,widescreen),"uint32_t",ADM_param_uint32_t},
- {"mb_eval",offsetof( FFcodecContext,mb_eval),"uint32_t",ADM_param_uint32_t},
- {"vratetol",offsetof( FFcodecContext,vratetol),"uint32_t",ADM_param_uint32_t},
- {"is_temporal_cplx_masking",offsetof( FFcodecContext,is_temporal_cplx_masking),"uint32_t",ADM_param_uint32_t},
- {"temporal_cplx_masking",offsetof( FFcodecContext,temporal_cplx_masking),"float",ADM_param_float},
- {"is_spatial_cplx_masking",offsetof( FFcodecContext,is_spatial_cplx_masking),"uint32_t",ADM_param_uint32_t},
- {"spatial_cplx_masking",offsetof( FFcodecContext,spatial_cplx_masking),"float",ADM_param_float},
- {"_NORMALIZE_AQP",offsetof( FFcodecContext,_NORMALIZE_AQP),"uint32_t",ADM_param_uint32_t},
- {"use_xvid_ratecontrol",offsetof( FFcodecContext,use_xvid_ratecontrol),"uint32_t",ADM_param_uint32_t},
- {"bufferSize",offsetof( FFcodecContext,bufferSize),"uint32_t",ADM_param_uint32_t},
- {"override_ratecontrol",offsetof( FFcodecContext,override_ratecontrol),"uint32_t",ADM_param_uint32_t},
- {"dummy",offsetof( FFcodecContext,dummy),"uint32_t",ADM_param_uint32_t},
-{NULL,0,NULL}
-};

Copied: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/FFcodecContext_desc.cpp (from rev 5881, branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/include/FFcodecContext_desc.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/include/FFcodecContext_desc.cpp	2010-01-30 13:11:48 UTC (rev 5881)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/FFcodecContext_desc.cpp	2010-01-30 13:11:50 UTC (rev 5882)
@@ -0,0 +1,44 @@
+// Automatically generated, do not edit!
+const ADM_paramList FFcodecContext_param[]={
+ {"version",offsetof( FFcodecContext,version),"uint32_t",ADM_param_uint32_t},
+ {"MultiThreaded",offsetof( FFcodecContext,MultiThreaded),"bool",ADM_param_bool},
+ {"me_method",offsetof( FFcodecContext,me_method),"uint32_t",ADM_param_uint32_t},
+ {"_GMC",offsetof( FFcodecContext,_GMC),"uint32_t",ADM_param_uint32_t},
+ {"_4MV",offsetof( FFcodecContext,_4MV),"uint32_t",ADM_param_uint32_t},
+ {"_QPEL",offsetof( FFcodecContext,_QPEL),"uint32_t",ADM_param_uint32_t},
+ {"_TRELLIS_QUANT",offsetof( FFcodecContext,_TRELLIS_QUANT),"uint32_t",ADM_param_uint32_t},
+ {"qmin",offsetof( FFcodecContext,qmin),"uint32_t",ADM_param_uint32_t},
+ {"qmax",offsetof( FFcodecContext,qmax),"uint32_t",ADM_param_uint32_t},
+ {"max_qdiff",offsetof( FFcodecContext,max_qdiff),"uint32_t",ADM_param_uint32_t},
+ {"max_b_frames",offsetof( FFcodecContext,max_b_frames),"uint32_t",ADM_param_uint32_t},
+ {"mpeg_quant",offsetof( FFcodecContext,mpeg_quant),"uint32_t",ADM_param_uint32_t},
+ {"is_luma_elim_threshold",offsetof( FFcodecContext,is_luma_elim_threshold),"uint32_t",ADM_param_uint32_t},
+ {"luma_elim_threshold",offsetof( FFcodecContext,luma_elim_threshold),"uint32_t",ADM_param_uint32_t},
+ {"is_chroma_elim_threshold",offsetof( FFcodecContext,is_chroma_elim_threshold),"uint32_t",ADM_param_uint32_t},
+ {"chroma_elim_threshold",offsetof( FFcodecContext,chroma_elim_threshold),"uint32_t",ADM_param_uint32_t},
+ {"lumi_masking",offsetof( FFcodecContext,lumi_masking),"float",ADM_param_float},
+ {"is_lumi_masking",offsetof( FFcodecContext,is_lumi_masking),"int32_t",ADM_param_int32_t},
+ {"dark_masking",offsetof( FFcodecContext,dark_masking),"float",ADM_param_float},
+ {"is_dark_masking",offsetof( FFcodecContext,is_dark_masking),"int32_t",ADM_param_int32_t},
+ {"qcompress",offsetof( FFcodecContext,qcompress),"float",ADM_param_float},
+ {"qblur",offsetof( FFcodecContext,qblur),"float",ADM_param_float},
+ {"minBitrate",offsetof( FFcodecContext,minBitrate),"uint32_t",ADM_param_uint32_t},
+ {"maxBitrate",offsetof( FFcodecContext,maxBitrate),"uint32_t",ADM_param_uint32_t},
+ {"user_matrix",offsetof( FFcodecContext,user_matrix),"uint32_t",ADM_param_uint32_t},
+ {"gop_size",offsetof( FFcodecContext,gop_size),"uint32_t",ADM_param_uint32_t},
+ {"interlaced",offsetof( FFcodecContext,interlaced),"uint32_t",ADM_param_uint32_t},
+ {"bff",offsetof( FFcodecContext,bff),"uint32_t",ADM_param_uint32_t},
+ {"widescreen",offsetof( FFcodecContext,widescreen),"uint32_t",ADM_param_uint32_t},
+ {"mb_eval",offsetof( FFcodecContext,mb_eval),"uint32_t",ADM_param_uint32_t},
+ {"vratetol",offsetof( FFcodecContext,vratetol),"uint32_t",ADM_param_uint32_t},
+ {"is_temporal_cplx_masking",offsetof( FFcodecContext,is_temporal_cplx_masking),"uint32_t",ADM_param_uint32_t},
+ {"temporal_cplx_masking",offsetof( FFcodecContext,temporal_cplx_masking),"float",ADM_param_float},
+ {"is_spatial_cplx_masking",offsetof( FFcodecContext,is_spatial_cplx_masking),"uint32_t",ADM_param_uint32_t},
+ {"spatial_cplx_masking",offsetof( FFcodecContext,spatial_cplx_masking),"float",ADM_param_float},
+ {"_NORMALIZE_AQP",offsetof( FFcodecContext,_NORMALIZE_AQP),"uint32_t",ADM_param_uint32_t},
+ {"use_xvid_ratecontrol",offsetof( FFcodecContext,use_xvid_ratecontrol),"uint32_t",ADM_param_uint32_t},
+ {"bufferSize",offsetof( FFcodecContext,bufferSize),"uint32_t",ADM_param_uint32_t},
+ {"override_ratecontrol",offsetof( FFcodecContext,override_ratecontrol),"uint32_t",ADM_param_uint32_t},
+ {"dummy",offsetof( FFcodecContext,dummy),"uint32_t",ADM_param_uint32_t},
+{NULL,0,NULL}
+};



From mean at mail.berlios.de  Sat Jan 30 14:11:49 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 30 Jan 2010 14:11:49 +0100
Subject: [Avidemux-svn-commit] r5881 - in branches/avidemux_2.6_branch_mean:
	avidemux_core/ADM_coreUtils/include avidemux_core/ADM_coreUtils/src
	avidemux_core/ADM_coreVideoEncoder/include
	avidemux_core/ADM_coreVideoEncoder/src
	avidemux_plugins/ADM_videoEncoder/ffFlv1
	avidemux_plugins/ADM_videoEncoder/ffMpeg4
	avidemux_plugins/ADM_videoEncoder/ffMsMpeg4 cmake
Message-ID: <201001301311.o0UDBnpV000575@sheep.berlios.de>

Author: mean
Date: 2010-01-30 14:11:48 +0100 (Sat, 30 Jan 2010)
New Revision: 5881

Added:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/include/ADM_coreVideoEncoderFFmpeg_param.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/include/FFcodecContext.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/include/FFcodecContext_desc.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/include/FFcodecSettings.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/FFcodecContext.conf
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/FFcodecSettings.conf
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/FFcodecSettings_desc.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/include/ADM_paramList.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_paramList.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/include/ADM_coreVideoEncoderFFmpeg.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/ADM_coreVideoEncoderFFmpeg.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/ffFlv1/ADM_ffFlv1.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/ffMpeg4/ADM_ffMpeg4.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/ffMpeg4/ffMpeg4Plugin.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/ffMsMpeg4/ADM_ffMsMp4.cpp
   branches/avidemux_2.6_branch_mean/cmake/admSerialization.pl
Log:
[videoEncoder] Prepare to store metaconf : lavcCodec and compressParam

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/include/ADM_paramList.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/include/ADM_paramList.h	2010-01-29 18:29:23 UTC (rev 5880)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/include/ADM_paramList.h	2010-01-30 13:11:48 UTC (rev 5881)
@@ -28,7 +28,9 @@
         ADM_param_int32_t=2,
         ADM_param_float=3,
         ADM_param_bool=4,
-        ADM_param_string=5
+        ADM_param_string=5,
+        ADM_param_video_encode=6,
+        ADM_param_lavcodec_context=7
 }ADM_paramType;
 
 

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_paramList.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_paramList.cpp	2010-01-29 18:29:23 UTC (rev 5880)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_paramList.cpp	2010-01-30 13:11:48 UTC (rev 5881)
@@ -15,6 +15,19 @@
  ***************************************************************************/
 #include "ADM_default.h"
 #include "ADM_paramList.h"
+#include "ADM_coreVideoEncoderFFmpeg_param.h"
+
+static bool lavReadFromString(FFcodecContext *ctx,const char *str)
+{
+    printf("String:%s\n",str);
+    return true;
+}
+static bool lavWriteToString(FFcodecContext *ctx,char **str)
+{
+    *str=ADM_strdup("foobar");
+    return true;
+}
+
 /**
     \fn ADM_paramValidate
     \brief Check the confcouples match the param list
@@ -70,6 +83,24 @@
            SWAL(ADM_param_int32_t, int32_t, i32,Int32)
            SWAL(ADM_param_float,   float ,  f,Float)
            SWAL(ADM_param_bool,    bool ,   b,Bool)
+           case ADM_param_lavcodec_context:
+                        {
+                        char *lavString;
+                        if(false==couples->readAsString(name,&lavString))
+                        {
+                                ADM_error("Error reading lavcodec conf");
+                                return false;
+                        }
+                        bool r=lavReadFromString((FFcodecContext *)(address+params[i].offset),lavString);
+                        ADM_dezalloc(lavString);
+                        if(false==r)
+                            {
+                                    ADM_error("Error reading lavcodec string");
+                                    return false;
+                            }
+                       }
+                        break;
+                        
            case ADM_param_string: ADM_error("not implemented string for paramList\n");ADM_assert(0);
         }
     }
@@ -107,6 +138,23 @@
            SWAL(ADM_param_int32_t, int32_t, i32,Int32)
            SWAL(ADM_param_float,   float ,  f,Float)
            SWAL(ADM_param_bool,    bool ,   b,Bool)
+           case ADM_param_lavcodec_context:
+              {
+                        char *lavString;
+                        if(false==lavWriteToString((FFcodecContext *)(address+params[i].offset),&lavString))
+                        {
+                                ADM_error("Error writing lavcodec string");
+                                return false;
+                        }
+                        bool r=c->setInternalName(name,lavString);
+                        ADM_dezalloc(lavString);
+                        if(false==r)
+                        {
+                                ADM_error("Error writing lavcodec conf");
+                                return false;
+                        }
+              }
+                break;
            case ADM_param_string: ADM_error("not implemented string for paramList\n");ADM_assert(0);
         }
     }

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/include/ADM_coreVideoEncoderFFmpeg.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/include/ADM_coreVideoEncoderFFmpeg.h	2010-01-29 18:29:23 UTC (rev 5880)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/include/ADM_coreVideoEncoderFFmpeg.h	2010-01-30 13:11:48 UTC (rev 5881)
@@ -20,79 +20,17 @@
 
 #include "ADM_coreVideoEncoder.h"
 #include "ADM_colorspace.h"
-extern "C" 
-{
-#include "ADM_lavcodec.h"
-}
 #include "ADM_encoderConf.h"
+#include "ADM_coreVideoEncoderFFmpeg_param.h"
+#include "FFcodecSettings.h"
 /**
-    FFcodecSetting
-*/
-typedef struct 
-{
-  const bool MultiThreaded;
-  COMPRES_PARAMS params;
-//
-
-  Motion_Est_ID me_method;
-  uint32_t _GMC;
-  uint32_t _4MV;
-  uint32_t _QPEL;
-  uint32_t _TRELLIS_QUANT;
-  uint32_t qmin;			// 2-31
-  uint32_t qmax;			// 2-31
-  uint32_t max_qdiff;		// 1-31
-  uint32_t max_b_frames;		// 0-1
-  uint32_t mpeg_quant;		// 0-1
-  uint32_t is_luma_elim_threshold;
-  uint32_t luma_elim_threshold;	// -99--99
-  uint32_t is_chroma_elim_threshold;	// -99--99           
-  uint32_t chroma_elim_threshold;	// -99--99      
-
-  float lumi_masking;		// -1--1        
-  int32_t is_lumi_masking;		// -1--1
-  float dark_masking;		// -1--1        
-  int32_t is_dark_masking;		// -1--1
-  float qcompress;		// 0.0--1.0
-  float qblur;			// 0.0--1.0
-  uint32_t minBitrate;          // In kBits/s
-  uint32_t maxBitrate;          // In kBits/s
-  uint32_t user_matrix;		// 0 normal / 1 tmpgenc / 2 anime / 3 kvcd / 4 hr-tmpgenc
-  uint32_t gop_size;			// For mpeg1/2 , 12 is good
-  uint16_t *intra_matrix;
-  uint16_t *inter_matrix;
-  uint32_t interlaced;
-  uint32_t bff;			// WLA: bottom field first flag
-  uint32_t widescreen;          //0 4/3  1 16/9
-
-  // new stuff from jakub ui
-  uint32_t mb_eval;			// Replace hq 0..2
-  uint32_t vratetol;			// filesize tolerance in kb
-
-  uint32_t is_temporal_cplx_masking;	// temporal masking 0--1        
-  float temporal_cplx_masking;	// temporal masking 0--1
-
-  uint32_t is_spatial_cplx_masking;	// spatial masking 0--1
-  float spatial_cplx_masking;	// spatial masking 0--1
-  uint32_t _NORMALIZE_AQP;		// normalize adap quantiz
-
-  //
-  uint32_t use_xvid_ratecontrol;
-  uint32_t bufferSize;		// in KBYTES !!!!
-  uint32_t override_ratecontrol;
-  uint32_t dummy;
-
-} FFcodecSetting;
-
-
-/**
     \class ADM_coreVideoEncoderFFmpeg
     \brief base class for VideoEncoder based on libavcodec
 */
 class ADM_coreVideoEncoderFFmpeg :public ADM_coreVideoEncoder
 {
 protected:
-               FFcodecSetting   Settings;
+               FFcodecSettings  Settings;
                AVCodecContext   *_context;      // Context 
                AVFrame          _frame;     
                ADMColorspace    *colorSpace;    // Colorspace converter if needed
@@ -109,14 +47,14 @@
     virtual               bool             preEncode(void); 
     virtual               bool             setup(CodecID codecId);
     virtual               bool             getExtraData(uint32_t *l,uint8_t **d) ;
-                          bool             presetContext(FFcodecSetting *set);
+                          bool             presetContext(FFcodecSettings *set);
                           bool             postEncode(ADMBitstream *out, uint32_t size);
     virtual               bool             setPassAndLogFile(int pass,const char *name); // Call this before setup if needed !
                           bool             setupPass(void);  
                           bool             encoderMT (void);
 public:
-                                            ADM_coreVideoEncoderFFmpeg(ADM_coreVideoFilter *src,FFcodecSetting *settings=NULL);
+                                            ADM_coreVideoEncoderFFmpeg(ADM_coreVideoFilter *src,FFcodecSettings *settings=NULL);
 virtual                                     ~ADM_coreVideoEncoderFFmpeg();
 
 };
-#endif
\ No newline at end of file
+#endif

Copied: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/include/ADM_coreVideoEncoderFFmpeg_param.h (from rev 5880, branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/ffMpeg4/ffMpeg4Plugin.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/ffMpeg4/ffMpeg4Plugin.cpp	2010-01-29 18:29:23 UTC (rev 5880)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/include/ADM_coreVideoEncoderFFmpeg_param.h	2010-01-30 13:11:48 UTC (rev 5881)
@@ -0,0 +1,28 @@
+/***************************************************************************
+                          \fn ADM_coreVideoEncoder
+                          \brief Base class for video encoder plugin
+                             -------------------
+    
+    copyright            : (C) 2002/2009 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef ADM_CORE_VIDEO_ENCODER_FF_PARAM_H
+#define ADM_CORE_VIDEO_ENCODER_FF_PARAM_H
+
+
+#define ADM_AVCODEC_SETTING_VERSION 2
+extern "C" 
+{
+#include "ADM_lavcodec.h"
+}
+#include "FFcodecContext.h"
+#endif

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/include/FFcodecContext.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/include/FFcodecContext.h	2010-01-29 18:29:23 UTC (rev 5880)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/include/FFcodecContext.h	2010-01-30 13:11:48 UTC (rev 5881)
@@ -0,0 +1,47 @@
+// Automatically generated, do not edit!
+#ifndef ADM_FFcodecContext_CONF_H
+#define ADM_FFcodecContext_CONF_H
+typedef struct {
+   uint32_t version;
+   bool MultiThreaded;
+   uint32_t me_method;
+   uint32_t _GMC;
+   uint32_t _4MV;
+   uint32_t _QPEL;
+   uint32_t _TRELLIS_QUANT;
+   uint32_t qmin;
+   uint32_t qmax;
+   uint32_t max_qdiff;
+   uint32_t max_b_frames;
+   uint32_t mpeg_quant;
+   uint32_t is_luma_elim_threshold;
+   uint32_t luma_elim_threshold;
+   uint32_t is_chroma_elim_threshold;
+   uint32_t chroma_elim_threshold;
+   float lumi_masking;
+   int32_t is_lumi_masking;
+   float dark_masking;
+   int32_t is_dark_masking;
+   float qcompress;
+   float qblur;
+   uint32_t minBitrate;
+   uint32_t maxBitrate;
+   uint32_t user_matrix;
+   uint32_t gop_size;
+   uint32_t interlaced;
+   uint32_t bff;
+   uint32_t widescreen;
+   uint32_t mb_eval;
+   uint32_t vratetol;
+   uint32_t is_temporal_cplx_masking;
+   float temporal_cplx_masking;
+   uint32_t is_spatial_cplx_masking;
+   float spatial_cplx_masking;
+   uint32_t _NORMALIZE_AQP;
+   uint32_t use_xvid_ratecontrol;
+   uint32_t bufferSize;
+   uint32_t override_ratecontrol;
+   uint32_t dummy;
+}FFcodecContext;
+#endif //FFcodecContext
+//EOF

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/include/FFcodecContext_desc.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/include/FFcodecContext_desc.cpp	2010-01-29 18:29:23 UTC (rev 5880)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/include/FFcodecContext_desc.cpp	2010-01-30 13:11:48 UTC (rev 5881)
@@ -0,0 +1,44 @@
+// Automatically generated, do not edit!
+const ADM_paramList FFcodecContext_param[]={
+ {"version",offsetof( FFcodecContext,version),"uint32_t",ADM_param_uint32_t},
+ {"MultiThreaded",offsetof( FFcodecContext,MultiThreaded),"bool",ADM_param_bool},
+ {"me_method",offsetof( FFcodecContext,me_method),"uint32_t",ADM_param_uint32_t},
+ {"_GMC",offsetof( FFcodecContext,_GMC),"uint32_t",ADM_param_uint32_t},
+ {"_4MV",offsetof( FFcodecContext,_4MV),"uint32_t",ADM_param_uint32_t},
+ {"_QPEL",offsetof( FFcodecContext,_QPEL),"uint32_t",ADM_param_uint32_t},
+ {"_TRELLIS_QUANT",offsetof( FFcodecContext,_TRELLIS_QUANT),"uint32_t",ADM_param_uint32_t},
+ {"qmin",offsetof( FFcodecContext,qmin),"uint32_t",ADM_param_uint32_t},
+ {"qmax",offsetof( FFcodecContext,qmax),"uint32_t",ADM_param_uint32_t},
+ {"max_qdiff",offsetof( FFcodecContext,max_qdiff),"uint32_t",ADM_param_uint32_t},
+ {"max_b_frames",offsetof( FFcodecContext,max_b_frames),"uint32_t",ADM_param_uint32_t},
+ {"mpeg_quant",offsetof( FFcodecContext,mpeg_quant),"uint32_t",ADM_param_uint32_t},
+ {"is_luma_elim_threshold",offsetof( FFcodecContext,is_luma_elim_threshold),"uint32_t",ADM_param_uint32_t},
+ {"luma_elim_threshold",offsetof( FFcodecContext,luma_elim_threshold),"uint32_t",ADM_param_uint32_t},
+ {"is_chroma_elim_threshold",offsetof( FFcodecContext,is_chroma_elim_threshold),"uint32_t",ADM_param_uint32_t},
+ {"chroma_elim_threshold",offsetof( FFcodecContext,chroma_elim_threshold),"uint32_t",ADM_param_uint32_t},
+ {"lumi_masking",offsetof( FFcodecContext,lumi_masking),"float",ADM_param_float},
+ {"is_lumi_masking",offsetof( FFcodecContext,is_lumi_masking),"int32_t",ADM_param_int32_t},
+ {"dark_masking",offsetof( FFcodecContext,dark_masking),"float",ADM_param_float},
+ {"is_dark_masking",offsetof( FFcodecContext,is_dark_masking),"int32_t",ADM_param_int32_t},
+ {"qcompress",offsetof( FFcodecContext,qcompress),"float",ADM_param_float},
+ {"qblur",offsetof( FFcodecContext,qblur),"float",ADM_param_float},
+ {"minBitrate",offsetof( FFcodecContext,minBitrate),"uint32_t",ADM_param_uint32_t},
+ {"maxBitrate",offsetof( FFcodecContext,maxBitrate),"uint32_t",ADM_param_uint32_t},
+ {"user_matrix",offsetof( FFcodecContext,user_matrix),"uint32_t",ADM_param_uint32_t},
+ {"gop_size",offsetof( FFcodecContext,gop_size),"uint32_t",ADM_param_uint32_t},
+ {"interlaced",offsetof( FFcodecContext,interlaced),"uint32_t",ADM_param_uint32_t},
+ {"bff",offsetof( FFcodecContext,bff),"uint32_t",ADM_param_uint32_t},
+ {"widescreen",offsetof( FFcodecContext,widescreen),"uint32_t",ADM_param_uint32_t},
+ {"mb_eval",offsetof( FFcodecContext,mb_eval),"uint32_t",ADM_param_uint32_t},
+ {"vratetol",offsetof( FFcodecContext,vratetol),"uint32_t",ADM_param_uint32_t},
+ {"is_temporal_cplx_masking",offsetof( FFcodecContext,is_temporal_cplx_masking),"uint32_t",ADM_param_uint32_t},
+ {"temporal_cplx_masking",offsetof( FFcodecContext,temporal_cplx_masking),"float",ADM_param_float},
+ {"is_spatial_cplx_masking",offsetof( FFcodecContext,is_spatial_cplx_masking),"uint32_t",ADM_param_uint32_t},
+ {"spatial_cplx_masking",offsetof( FFcodecContext,spatial_cplx_masking),"float",ADM_param_float},
+ {"_NORMALIZE_AQP",offsetof( FFcodecContext,_NORMALIZE_AQP),"uint32_t",ADM_param_uint32_t},
+ {"use_xvid_ratecontrol",offsetof( FFcodecContext,use_xvid_ratecontrol),"uint32_t",ADM_param_uint32_t},
+ {"bufferSize",offsetof( FFcodecContext,bufferSize),"uint32_t",ADM_param_uint32_t},
+ {"override_ratecontrol",offsetof( FFcodecContext,override_ratecontrol),"uint32_t",ADM_param_uint32_t},
+ {"dummy",offsetof( FFcodecContext,dummy),"uint32_t",ADM_param_uint32_t},
+{NULL,0,NULL}
+};

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/include/FFcodecSettings.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/include/FFcodecSettings.h	2010-01-29 18:29:23 UTC (rev 5880)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/include/FFcodecSettings.h	2010-01-30 13:11:48 UTC (rev 5881)
@@ -0,0 +1,9 @@
+// Automatically generated, do not edit!
+#ifndef ADM_FFcodecSettings_CONF_H
+#define ADM_FFcodecSettings_CONF_H
+typedef struct {
+   COMPRES_PARAMS params;
+   FFcodecContext lavcSettings;
+}FFcodecSettings;
+#endif //FFcodecSettings
+//EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/ADM_coreVideoEncoderFFmpeg.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/ADM_coreVideoEncoderFFmpeg.cpp	2010-01-29 18:29:23 UTC (rev 5880)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/ADM_coreVideoEncoderFFmpeg.cpp	2010-01-30 13:11:48 UTC (rev 5881)
@@ -27,6 +27,7 @@
     #define aprintf printf
 #endif
 
+#define LAVS(x) Settings.lavcSettings.x
 typedef struct
 {
     uint64_t mn,mx;
@@ -88,7 +89,7 @@
 
 */
 
-ADM_coreVideoEncoderFFmpeg::ADM_coreVideoEncoderFFmpeg(ADM_coreVideoFilter *src,FFcodecSetting *set) 
+ADM_coreVideoEncoderFFmpeg::ADM_coreVideoEncoderFFmpeg(ADM_coreVideoFilter *src,FFcodecSettings *set) 
                     : ADM_coreVideoEncoder(src)
 {
 uint32_t w,h;
@@ -111,7 +112,7 @@
     statFileName=NULL;
     statFile=NULL;
     _isMT=false;
-    encoderDelay=source->getInfo()->frameIncrement*Settings.max_b_frames;
+    encoderDelay=source->getInfo()->frameIncrement*LAVS(max_b_frames);
     ADM_info("[Lavcodec] Using a video encoder delay of %d ms\n",(int)(encoderDelay/1000));
 }
 /**
@@ -269,7 +270,7 @@
     }
    prolog();
    printf("[ff] Time base %d/%d\n", _context->time_base.num,_context->time_base.den);
-   if(Settings.MultiThreaded==true)
+   if(LAVS(MultiThreaded)==true)
         encoderMT();
    res=avcodec_open(_context, codec); 
    if(res<0) 
@@ -387,12 +388,12 @@
     \fn presetContext
     \brief put sensible values into context
 */
-bool ADM_coreVideoEncoderFFmpeg::presetContext(FFcodecSetting *set)
+bool ADM_coreVideoEncoderFFmpeg::presetContext(FFcodecSettings *set)
 {
 	  _context->gop_size = 250;
 	
-#define SETX(x) _context->x=set->x; printf("[LAVCODEC]"#x" : %d\n",set->x);
-#define SETX_COND(x) if(set->is_##x) {_context->x=set->x; printf("[LAVCODEC]"#x" : %d\n",set->x);} else\
+#define SETX(x) _context->x=set->lavcSettings.x; printf("[LAVCODEC]"#x" : %d\n",set->lavcSettings.x);
+#define SETX_COND(x) if(set->lavcSettings.is_##x) {_context->x=set->lavcSettings.x; printf("[LAVCODEC]"#x" : %d\n",set->lavcSettings.x);} else\
 		{ printf(#x" is not activated\n");}
       SETX (me_method);
       SETX (qmin);
@@ -406,8 +407,8 @@
 #undef SETX
 #undef SETX_COND
 
-#define SETX(x)  _context->x=set->x; printf("[LAVCODEC]"#x" : %f\n",set->x);
-#define SETX_COND(x)  if(set->is_##x) {_context->x=set->x; printf("[LAVCODEC]"#x" : %f\n",set->x);} else  \
+#define SETX(x)  _context->x=set->lavcSettings.x; printf("[LAVCODEC]"#x" : %f\n",set->lavcSettings.x);
+#define SETX_COND(x)  if(set->lavcSettings.is_##x) {_context->x=set->lavcSettings.x; printf("[LAVCODEC]"#x" : %f\n",set->lavcSettings.x);} else  \
 									{printf("[LAVCODEC]"#x" No activated\n");}
       SETX_COND (lumi_masking);
       SETX_COND (dark_masking);
@@ -419,11 +420,11 @@
 #undef SETX
 #undef SETX_COND
 
-#define SETX(x) if(set->x){ _context->flags|=CODEC_FLAG##x;printf("[LAVCODEC]"#x" is set\n");}
+#define SETX(x) if(set->lavcSettings.x){ _context->flags|=CODEC_FLAG##x;printf("[LAVCODEC]"#x" is set\n");}
       SETX (_GMC);
 
 
-    switch (set->mb_eval)
+    switch (set->lavcSettings.mb_eval)
 	{
         case 0:
           _context->mb_decision = FF_MB_DECISION_SIMPLE;
@@ -440,11 +441,11 @@
       
       SETX (_4MV);
       SETX (_QPEL);
-      if(set->_TRELLIS_QUANT) _context->trellis=1;
+      if(set->lavcSettings._TRELLIS_QUANT) _context->trellis=1;
       //SETX(_HQ);
       //SETX (_NORMALIZE_AQP);
 
-      if (set->widescreen)
+      if (set->lavcSettings.widescreen)
         {
           _context->sample_aspect_ratio.num = 16;
           _context->sample_aspect_ratio.den = 9;

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/FFcodecContext.conf
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/FFcodecContext.conf	2010-01-29 18:29:23 UTC (rev 5880)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/FFcodecContext.conf	2010-01-30 13:11:48 UTC (rev 5881)
@@ -0,0 +1,40 @@
+uint32_t:version;
+bool:MultiThreaded;
+uint32_t:me_method;
+uint32_t:_GMC;
+uint32_t:_4MV;
+uint32_t:_QPEL;
+uint32_t:_TRELLIS_QUANT;
+uint32_t:qmin;			// 2-31
+uint32_t:qmax;			// 2-31
+uint32_t:max_qdiff;		// 1-31
+uint32_t:max_b_frames;		// 0-1
+uint32_t:mpeg_quant;		// 0-1
+uint32_t:is_luma_elim_threshold;
+uint32_t:luma_elim_threshold;	// -99--99
+uint32_t:is_chroma_elim_threshold;	// -99--99           
+uint32_t:chroma_elim_threshold;	// -99--99      
+float:lumi_masking;		// -1--1        
+int32_t:is_lumi_masking;		// -1--1
+float:dark_masking;		// -1--1        
+int32_t:is_dark_masking;		// -1--1
+float:qcompress;		// 0.0--1.0
+float:qblur;			// 0.0--1.0
+uint32_t:minBitrate;          // In kBits/s
+uint32_t:maxBitrate;          // In kBits/s
+uint32_t:user_matrix;		// 0 normal / 1 tmpgenc / 2 anime / 3 kvcd / 4 hr-tmpgenc
+uint32_t:gop_size;			// For mpeg1/2 , 12 is good
+uint32_t:interlaced;
+uint32_t:bff;			// WLA: bottom field first flag
+uint32_t:widescreen;          //0 4/3  1 16/9
+uint32_t:mb_eval;			// Replace hq 0..2
+uint32_t:vratetol;			// filesize tolerance in kb
+uint32_t:is_temporal_cplx_masking;	// temporal masking 0--1        
+float:temporal_cplx_masking;	// temporal masking 0--1
+uint32_t:is_spatial_cplx_masking;	// spatial masking 0--1
+float:spatial_cplx_masking;	// spatial masking 0--1
+uint32_t:_NORMALIZE_AQP;		// normalize adap quantiz
+uint32_t:use_xvid_ratecontrol;
+uint32_t:bufferSize;		// in KBYTES !!!!
+uint32_t:override_ratecontrol;
+uint32_t:dummy;

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/FFcodecSettings.conf
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/FFcodecSettings.conf	2010-01-29 18:29:23 UTC (rev 5880)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/FFcodecSettings.conf	2010-01-30 13:11:48 UTC (rev 5881)
@@ -0,0 +1,2 @@
+video_encode:params
+lavcodec_context:lavcSettings

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/FFcodecSettings_desc.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/FFcodecSettings_desc.cpp	2010-01-29 18:29:23 UTC (rev 5880)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/FFcodecSettings_desc.cpp	2010-01-30 13:11:48 UTC (rev 5881)
@@ -0,0 +1,6 @@
+// Automatically generated, do not edit!
+const ADM_paramList FFcodecSettings_param[]={
+ {"params",offsetof( FFcodecSettings,params),"COMPRES_PARAMS",ADM_param_video_encode},
+ {"lavcSettings",offsetof( FFcodecSettings,lavcSettings),"FFcodecContext",ADM_param_lavcodec_context},
+{NULL,0,NULL}
+};

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/ffFlv1/ADM_ffFlv1.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/ffFlv1/ADM_ffFlv1.cpp	2010-01-29 18:29:23 UTC (rev 5880)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/ffFlv1/ADM_ffFlv1.cpp	2010-01-30 13:11:48 UTC (rev 5881)
@@ -27,9 +27,9 @@
 #define aprintf printf
 #endif
 
-static FFcodecSetting Flv1Settings=
+static FFcodecSettings Flv1Settings=
 {
-    false,
+    
     {
     COMPRESS_CQ, //COMPRESSION_MODE  mode;
     2,              // uint32_t          qz;           /// Quantizer
@@ -38,6 +38,9 @@
     1500,           //uint32_t          avg_bitrate;  /// avg_bitrate is in kb/s!!
     ADM_ENC_CAP_CBR+ADM_ENC_CAP_CQ+ADM_ENC_CAP_2PASS+ADM_ENC_CAP_2PASS_BR
     },
+    {
+          ADM_AVCODEC_SETTING_VERSION,
+          false,
           ME_EPZS,			// ME
           0,				// GMC     
           0,				// 4MV
@@ -75,6 +78,7 @@
           0.0,				// spatial masking
           0,				// NAQ
           0				    // DUMMY 
+    }
 };
 /**
         \fn ADM_ffFlv1Encoder
@@ -217,10 +221,10 @@
   {2,QT_TR_NOOP("Rate distortion")}
 };     
 
-        FFcodecSetting *conf=&Flv1Settings;
+        FFcodecSettings *conf=&Flv1Settings;
 
-uint32_t me=(uint32_t)conf->me_method;  
-#define PX(x) &(conf->x)
+uint32_t me=(uint32_t)conf->lavcSettings.me_method;  
+#define PX(x) &(conf->lavcSettings.x)
 
          diaElemBitrate   bitrate(&(Flv1Settings.params),NULL);
          diaElemUInteger  qminM(PX(qmin),QT_TR_NOOP("Mi_n. quantizer:"),1,31);
@@ -250,7 +254,7 @@
          diaElemTabs *tabs[]={&tabMode,&tabQz,&tabRC};
         if( diaFactoryRunTabs(QT_TR_NOOP("libavcodec FLV1 configuration"),3,tabs))
         {
-          conf->me_method=(Motion_Est_ID)me;
+          conf->lavcSettings.me_method=(Motion_Est_ID)me;
           return true;
         }
          return false;

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/ffMpeg4/ADM_ffMpeg4.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/ffMpeg4/ADM_ffMpeg4.cpp	2010-01-29 18:29:23 UTC (rev 5880)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/ffMpeg4/ADM_ffMpeg4.cpp	2010-01-30 13:11:48 UTC (rev 5881)
@@ -27,9 +27,8 @@
 #define aprintf printf
 #endif
 
-static FFcodecSetting Mp4Settings=
+FFcodecSettings Mp4Settings=
 {
-    true, // Multithreaded
     {
     COMPRESS_CQ, //COMPRESSION_MODE  mode;
     2,              // uint32_t          qz;           /// Quantizer
@@ -38,6 +37,9 @@
     1500,           //uint32_t          avg_bitrate;  /// avg_bitrate is in kb/s!!
     ADM_ENC_CAP_CBR+ADM_ENC_CAP_CQ+ADM_ENC_CAP_2PASS+ADM_ENC_CAP_2PASS_BR+ADM_ENC_CAP_GLOBAL+ADM_ENC_CAP_SAME
     },
+    {
+        ADM_AVCODEC_SETTING_VERSION,
+        true, // Multithreaded
           ME_EPZS,			// ME
           0,				// GMC     
           1,				// 4MV
@@ -75,6 +77,7 @@
           0.0,				// spatial masking
           0,				// NAQ
           0				    // DUMMY 
+    }
 };
 /**
         \fn ADM_ffMpeg4Encoder
@@ -239,10 +242,10 @@
   {2,QT_TR_NOOP("Rate distortion")}
 };     
 
-        FFcodecSetting *conf=&Mp4Settings;
+        FFcodecSettings *conf=&Mp4Settings;
 
-uint32_t me=(uint32_t)conf->me_method;  
-#define PX(x) &(conf->x)
+uint32_t me=(uint32_t)conf->lavcSettings.me_method;  
+#define PX(x) &(conf->lavcSettings.x)
 
          diaElemBitrate   bitrate(&(Mp4Settings.params),NULL);
          diaElemMenu      meM(&me,QT_TR_NOOP("Matrices"),4,meE);
@@ -294,7 +297,7 @@
          diaElemTabs *tabs[]={&tabMode,&tabME,&tabQz,&tabRC};
         if( diaFactoryRunTabs(QT_TR_NOOP("libavcodec MPEG-4 configuration"),4,tabs))
         {
-          conf->me_method=(Motion_Est_ID)me;
+          conf->lavcSettings.me_method=(Motion_Est_ID)me;
           return true;
         }
          return false;

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/ffMpeg4/ffMpeg4Plugin.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/ffMpeg4/ffMpeg4Plugin.cpp	2010-01-29 18:29:23 UTC (rev 5880)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/ffMpeg4/ffMpeg4Plugin.cpp	2010-01-30 13:11:48 UTC (rev 5881)
@@ -18,9 +18,9 @@
 #include "ADM_default.h"
 #include "ADM_ffMpeg4.h"
 #include "ADM_coreVideoEncoderInternal.h"
-
+#include "../src/FFcodecSettings_desc.cpp"
 extern bool         ffMpeg4Configure(void);
-
+extern FFcodecSettings Mp4Settings;
 ADM_DECLARE_VIDEO_ENCODER_PREAMBLE(ADM_ffMpeg4Encoder);
 ADM_DECLARE_VIDEO_ENCODER_MAIN("ffMpeg4",
                                "Mpeg4 ASP (ff)",
@@ -28,6 +28,6 @@
                                 ffMpeg4Configure, // No configuration
                                 ADM_UI_ALL,
                                 1,0,0,
-                                NULL, // conf template
-                                NULL // conf var
+                                FFcodecSettings_param, // conf template
+                                &Mp4Settings // conf var
 );

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/ffMsMpeg4/ADM_ffMsMp4.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/ffMsMpeg4/ADM_ffMsMp4.cpp	2010-01-29 18:29:23 UTC (rev 5880)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/ffMsMpeg4/ADM_ffMsMp4.cpp	2010-01-30 13:11:48 UTC (rev 5881)
@@ -27,9 +27,9 @@
 #define aprintf printf
 #endif
 
-static FFcodecSetting MsMp4Settings=
+static FFcodecSettings MsMp4Settings=
 {
-    false,
+
     {
     COMPRESS_CQ, //COMPRESSION_MODE  mode;
     2,              // uint32_t          qz;           /// Quantizer
@@ -38,6 +38,9 @@
     1500,           //uint32_t          avg_bitrate;  /// avg_bitrate is in kb/s!!
     ADM_ENC_CAP_CBR+ADM_ENC_CAP_CQ+ADM_ENC_CAP_2PASS+ADM_ENC_CAP_2PASS_BR+ADM_ENC_CAP_GLOBAL+ADM_ENC_CAP_SAME
     },
+    {
+          ADM_AVCODEC_SETTING_VERSION,
+          false, // MT
           ME_EPZS,			// ME
           0,				// GMC     
           0,				// 4MV
@@ -75,6 +78,7 @@
           0.0,				// spatial masking
           0,				// NAQ
           0				    // DUMMY 
+    }
 };
 /**
         \fn ADM_ffMsMp4Encoder
@@ -225,10 +229,10 @@
   {2,QT_TR_NOOP("Rate distortion")}
 };     
 
-        FFcodecSetting *conf=&MsMp4Settings;
+        FFcodecSettings *conf=&MsMp4Settings;
 
-uint32_t me=(uint32_t)conf->me_method;  
-#define PX(x) &(conf->x)
+uint32_t me=(uint32_t)conf->lavcSettings.me_method;  
+#define PX(x) &(conf->lavcSettings.x)
 
          diaElemBitrate   bitrate(&(MsMp4Settings.params),NULL);
          diaElemUInteger  qminM(PX(qmin),QT_TR_NOOP("Mi_n. quantizer:"),1,31);
@@ -258,7 +262,7 @@
          diaElemTabs *tabs[]={&tabMode,&tabQz,&tabRC};
         if( diaFactoryRunTabs(QT_TR_NOOP("libavcodec MPEG-4 configuration"),3,tabs))
         {
-          conf->me_method=(Motion_Est_ID)me;
+          conf->lavcSettings.me_method=(Motion_Est_ID)me;
           return true;
         }
          return false;

Modified: branches/avidemux_2.6_branch_mean/cmake/admSerialization.pl
===================================================================
--- branches/avidemux_2.6_branch_mean/cmake/admSerialization.pl	2010-01-29 18:29:23 UTC (rev 5880)
+++ branches/avidemux_2.6_branch_mean/cmake/admSerialization.pl	2010-01-30 13:11:48 UTC (rev 5881)
@@ -13,6 +13,8 @@
 $ctypes{"string"}="char *";
 $ctypes{"bool"}="bool";
 $ctypes{"float"}="float";
+$ctypes{"video_encode"}="COMPRES_PARAMS";
+$ctypes{"lavcodec_context"}="FFcodecContext";
 
 $atypes{"uint32_t"}="ADM_param_uint32_t";
 $atypes{"int32_t"}="ADM_param_int32_t";
@@ -20,6 +22,8 @@
 $atypes{"bool"}="ADM_param_bool";
 $atypes{"string"}="ADM_param_string";
 $atypes{"float"}="ADM_param_float";
+$atypes{"video_encode"}="ADM_param_video_encode";
+$atypes{"lavcodec_context"}="ADM_param_lavcodec_context";
 
 #
 sub processLine
@@ -101,6 +105,7 @@
         my $name;
         ($type,$name)=split ":",$a;
         #print "1: ".$a.",2:".$type.",3:".$name."\n" ;
+        $name=~s/;.*$//g;
         processLine($type,$name);
 }
 writeHeaderFoot();



From mean at mail.berlios.de  Sat Jan 30 14:24:35 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 30 Jan 2010 14:24:35 +0100
Subject: [Avidemux-svn-commit] r5883 - in
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder:
	ffFlv1 ffMsMpeg4
Message-ID: <201001301324.o0UDOZiW001768@sheep.berlios.de>

Author: mean
Date: 2010-01-30 14:24:35 +0100 (Sat, 30 Jan 2010)
New Revision: 5883

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/ffFlv1/ADM_ffFlv1.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/ffFlv1/ffFlv1Plugin.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/ffMsMpeg4/ADM_ffMsMp4.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/ffMsMpeg4/ffMsMp4Plugin.cpp
Log:
[videoEncoder] Convert configuration of lavcodec based video encoder to new scheme (flv/msmpeg4)

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/ffFlv1/ADM_ffFlv1.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/ffFlv1/ADM_ffFlv1.cpp	2010-01-30 13:11:50 UTC (rev 5882)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/ffFlv1/ADM_ffFlv1.cpp	2010-01-30 13:24:35 UTC (rev 5883)
@@ -27,7 +27,7 @@
 #define aprintf printf
 #endif
 
-static FFcodecSettings Flv1Settings=
+FFcodecSettings Flv1Settings=
 {
     
     {

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/ffFlv1/ffFlv1Plugin.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/ffFlv1/ffFlv1Plugin.cpp	2010-01-30 13:11:50 UTC (rev 5882)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/ffFlv1/ffFlv1Plugin.cpp	2010-01-30 13:24:35 UTC (rev 5883)
@@ -18,7 +18,8 @@
 #include "ADM_default.h"
 #include "ADM_ffFlv1.h"
 #include "ADM_coreVideoEncoderInternal.h"
-
+#include "../src/FFcodecSettings_desc.cpp"
+extern FFcodecSettings Flv1Settings;
 extern bool         ffFlv1Configure(void);
 
 ADM_DECLARE_VIDEO_ENCODER_PREAMBLE(ADM_ffFlv1Encoder);
@@ -28,6 +29,6 @@
                                 ffFlv1Configure, // No configuration
                                 ADM_UI_ALL,
                                 1,0,0,
-                                NULL, // conf template
-                                NULL // conf var
+                                 FFcodecSettings_param, // conf template
+                                &Flv1Settings // conf var
 );

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/ffMsMpeg4/ADM_ffMsMp4.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/ffMsMpeg4/ADM_ffMsMp4.cpp	2010-01-30 13:11:50 UTC (rev 5882)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/ffMsMpeg4/ADM_ffMsMp4.cpp	2010-01-30 13:24:35 UTC (rev 5883)
@@ -27,7 +27,7 @@
 #define aprintf printf
 #endif
 
-static FFcodecSettings MsMp4Settings=
+FFcodecSettings MsMp4Settings=
 {
 
     {

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/ffMsMpeg4/ffMsMp4Plugin.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/ffMsMpeg4/ffMsMp4Plugin.cpp	2010-01-30 13:11:50 UTC (rev 5882)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/ffMsMpeg4/ffMsMp4Plugin.cpp	2010-01-30 13:24:35 UTC (rev 5883)
@@ -18,8 +18,9 @@
 #include "ADM_default.h"
 #include "ADM_ffMsMp4.h"
 #include "ADM_coreVideoEncoderInternal.h"
-
+#include "../src/FFcodecSettings_desc.cpp"
 extern bool         ffMsMp4Configure(void);
+extern FFcodecSettings MsMp4Settings;
 
 ADM_DECLARE_VIDEO_ENCODER_PREAMBLE(ADM_ffMsMp4Encoder);
 ADM_DECLARE_VIDEO_ENCODER_MAIN("ffMsMp4",
@@ -28,6 +29,6 @@
                                 ffMsMp4Configure, // No configuration
                                 ADM_UI_ALL,
                                 1,0,0,
-                                NULL, // conf template
-                                NULL // conf var
+                                 FFcodecSettings_param, // conf template
+                                &MsMp4Settings // conf var
 );



From mean at mail.berlios.de  Sun Jan 31 18:38:29 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 31 Jan 2010 18:38:29 +0100
Subject: [Avidemux-svn-commit] r5884 - in branches/avidemux_2.6_branch_mean:
	avidemux_core/ADM_coreVideoEncoder/include
	avidemux_core/ADM_coreVideoEncoder/src
	avidemux_plugins/ADM_videoEncoder/ffMpeg4
	avidemux_plugins/ADM_videoEncoder/ffMsMpeg4
Message-ID: <201001311738.o0VHcThE010231@sheep.berlios.de>

Author: mean
Date: 2010-01-31 18:38:28 +0100 (Sun, 31 Jan 2010)
New Revision: 5884

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/include/FFcodecContext.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/ADM_coreVideoEncoderFFmpeg.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/FFcodecContext.conf
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/FFcodecContext_desc.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/ffMpeg4/ADM_ffMpeg4.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/ffMsMpeg4/ADM_ffMsMp4.cpp
Log:
[lav] Set # of threads on a per encoder / per job basis, no more global

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/include/FFcodecContext.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/include/FFcodecContext.h	2010-01-30 13:24:35 UTC (rev 5883)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/include/FFcodecContext.h	2010-01-31 17:38:28 UTC (rev 5884)
@@ -3,7 +3,7 @@
 #define ADM_FFcodecContext_CONF_H
 typedef struct {
    uint32_t version;
-   bool MultiThreaded;
+   uint32_t MultiThreaded;
    uint32_t me_method;
    uint32_t _GMC;
    uint32_t _4MV;

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/ADM_coreVideoEncoderFFmpeg.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/ADM_coreVideoEncoderFFmpeg.cpp	2010-01-30 13:24:35 UTC (rev 5883)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/ADM_coreVideoEncoderFFmpeg.cpp	2010-01-31 17:38:28 UTC (rev 5884)
@@ -215,6 +215,7 @@
     double p=image->Pts;
     nextDts=image->Pts;
     _frame.pts= floor(p / (1000000.*av_q2d(_context->time_base) + 0.5));    //
+    if(!_frame.pts) _frame.pts=AV_NOPTS_VALUE;
     //printf("[PTS] :%"LU" num:%"LU" den:%"LU"\n",_frame.pts,_context->time_base.num,_context->time_base.den);
     //
     switch(targetColorSpace)
@@ -270,8 +271,10 @@
     }
    prolog();
    printf("[ff] Time base %d/%d\n", _context->time_base.num,_context->time_base.den);
-   if(LAVS(MultiThreaded)==true)
+   if(LAVS(MultiThreaded))
+    {
         encoderMT();
+    }
    res=avcodec_open(_context, codec); 
    if(res<0) 
     {   printf("[ff] Cannot open codec\n");
@@ -558,16 +561,14 @@
 */  
 bool ADM_coreVideoEncoderFFmpeg::encoderMT (void)
 {
-  uint32_t threads = 0;
-
-  prefs->get(FEATURE_THREADING_LAVC, &threads);
-
-  if (threads == 0)
-	  threads = ADM_cpu_num_processors();
-
-  if (threads == 1)
-	  threads = 0;
-
+ 
+  uint32_t threads =    LAVS(MultiThreaded);
+  switch(threads)
+  {
+    case 99:threads = ADM_cpu_num_processors();break;
+    case 1: threads=0;
+    break;
+  }
   if (threads)
   {
       printf ("[lavc] Enabling MT encoder with %u threads\n", threads);

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/FFcodecContext.conf
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/FFcodecContext.conf	2010-01-30 13:24:35 UTC (rev 5883)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/FFcodecContext.conf	2010-01-31 17:38:28 UTC (rev 5884)
@@ -1,5 +1,5 @@
 uint32_t:version;
-bool:MultiThreaded;
+uint32_t:MultiThreaded;
 uint32_t:me_method;
 uint32_t:_GMC;
 uint32_t:_4MV;

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/FFcodecContext_desc.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/FFcodecContext_desc.cpp	2010-01-30 13:24:35 UTC (rev 5883)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/FFcodecContext_desc.cpp	2010-01-31 17:38:28 UTC (rev 5884)
@@ -1,7 +1,7 @@
 // Automatically generated, do not edit!
 const ADM_paramList FFcodecContext_param[]={
  {"version",offsetof( FFcodecContext,version),"uint32_t",ADM_param_uint32_t},
- {"MultiThreaded",offsetof( FFcodecContext,MultiThreaded),"bool",ADM_param_bool},
+ {"MultiThreaded",offsetof( FFcodecContext,MultiThreaded),"uint32_t",ADM_param_uint32_t},
  {"me_method",offsetof( FFcodecContext,me_method),"uint32_t",ADM_param_uint32_t},
  {"_GMC",offsetof( FFcodecContext,_GMC),"uint32_t",ADM_param_uint32_t},
  {"_4MV",offsetof( FFcodecContext,_4MV),"uint32_t",ADM_param_uint32_t},

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/ffMpeg4/ADM_ffMpeg4.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/ffMpeg4/ADM_ffMpeg4.cpp	2010-01-30 13:24:35 UTC (rev 5883)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/ffMpeg4/ADM_ffMpeg4.cpp	2010-01-31 17:38:28 UTC (rev 5884)
@@ -39,7 +39,7 @@
     },
     {
         ADM_AVCODEC_SETTING_VERSION,
-        true, // Multithreaded
+        2, // Multithreaded
           ME_EPZS,			// ME
           0,				// GMC     
           1,				// 4MV
@@ -241,7 +241,14 @@
   {1,QT_TR_NOOP("Fewest bits (vhq)")},
   {2,QT_TR_NOOP("Rate distortion")}
 };     
+diaMenuEntry threads[]={
+  {0,QT_TR_NOOP("One thread")},
+  {2,QT_TR_NOOP("Two threads)")},
+  {3,QT_TR_NOOP("Three threads")},
+  {99,QT_TR_NOOP("Auto (#cpu)")}
+};     
 
+
         FFcodecSettings *conf=&Mp4Settings;
 
 uint32_t me=(uint32_t)conf->lavcSettings.me_method;  
@@ -249,6 +256,7 @@
 
          diaElemBitrate   bitrate(&(Mp4Settings.params),NULL);
          diaElemMenu      meM(&me,QT_TR_NOOP("Matrices"),4,meE);
+         diaElemMenu      threadM(PX(MultiThreaded),QT_TR_NOOP("Threading"),4,threads);
          diaElemUInteger  qminM(PX(qmin),QT_TR_NOOP("Mi_n. quantizer:"),1,31);
          diaElemUInteger  qmaxM(PX(qmax),QT_TR_NOOP("Ma_x. quantizer:"),1,31);
          diaElemUInteger  qdiffM(PX(max_qdiff),QT_TR_NOOP("Max. quantizer _difference:"),1,31);
@@ -272,8 +280,8 @@
          
         diaElemUInteger GopSize(PX(gop_size),QT_TR_NOOP("_Gop Size:"),1,500); 
           /* First Tab : encoding mode */
-        diaElem *diamode[]={&GopSize,&bitrate};
-        diaElemTabs tabMode(QT_TR_NOOP("User Interface"),2,diamode);
+        diaElem *diamode[]={&GopSize,&threadM,&bitrate};
+        diaElemTabs tabMode(QT_TR_NOOP("User Interface"),3,diamode);
         
         /* 2nd Tab : ME */
         diaElemFrame frameMe(QT_TR_NOOP("Advanced Simple Profile"));

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/ffMsMpeg4/ADM_ffMsMp4.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/ffMsMpeg4/ADM_ffMsMp4.cpp	2010-01-30 13:24:35 UTC (rev 5883)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/ffMsMpeg4/ADM_ffMsMp4.cpp	2010-01-31 17:38:28 UTC (rev 5884)
@@ -40,7 +40,7 @@
     },
     {
           ADM_AVCODEC_SETTING_VERSION,
-          false, // MT
+          0, // MT
           ME_EPZS,			// ME
           0,				// GMC     
           0,				// 4MV



From mean at mail.berlios.de  Sun Jan 31 20:10:15 2010
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 31 Jan 2010 20:10:15 +0100
Subject: [Avidemux-svn-commit] r5885 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor
Message-ID: <201001311910.o0VJAFCf029362@sheep.berlios.de>

Author: mean
Date: 2010-01-31 20:10:15 +0100 (Sun, 31 Jan 2010)
New Revision: 5885

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp
Log:
[editor] Fix _currentPts after seeking

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp	2010-01-31 17:38:28 UTC (rev 5884)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp	2010-01-31 19:10:15 UTC (rev 5885)
@@ -175,7 +175,9 @@
             return false;
     }
     _currentSegment=seg;
-    SET_CURRENT_PTS(v->lastDecodedPts);
+    int64_t newTime=(int64_t)v->lastDecodedPts+(int64_t)s->_startTimeUs-(int64_t)s->_refStartTimeUs;
+    ADM_info("Seek done, in reference, gone to %"LLU" with segment start at %"LLU"\n",v->lastDecodedPts,s->_refStartTimeUs);
+    SET_CURRENT_PTS(newTime);
     return true;
 
 }
@@ -439,7 +441,6 @@
     }
       ADM_assert(_currentSegment==segNo);
       refPts=segTime+seg->_refStartTimeUs;
-
       ADMImage *last=ref->_videoCache->getByPts(refPts);
       if(last)
       {



