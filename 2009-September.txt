From mean at mail.berlios.de  Tue Sep  1 10:53:01 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 1 Sep 2009 10:53:01 +0200
Subject: [Avidemux-svn-commit] r5284 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Flv
Message-ID: <200909010853.n818r1Oq012700@sheep.berlios.de>

Author: mean
Date: 2009-09-01 10:53:01 +0200 (Tue, 01 Sep 2009)
New Revision: 5284

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Flv/ADM_flv.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Flv/ADM_flv.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Flv/ADM_flvAudio.cpp
Log:
[flv/demuxer] Try to set also pts for h264

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Flv/ADM_flv.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Flv/ADM_flv.cpp	2009-08-31 15:56:21 UTC (rev 5283)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Flv/ADM_flv.cpp	2009-09-01 08:53:01 UTC (rev 5284)
@@ -191,7 +191,7 @@
     for(int i=0;i<videoTrack->_nbIndex-1;i++)
     {
         flvIndex *x=&(videoTrack->_index[i]);
-        if((x[1].timeCodeUs-x[0].timeCodeUs)<delta) delta=x[1].timeCodeUs-x[0].timeCodeUs;
+        if((x[1].dtsUs-x[0].dtsUs)<delta) delta=x[1].dtsUs-x[0].dtsUs;
 
     }
     return delta;
@@ -200,14 +200,15 @@
     \fn extraHeader
     \brief if returns true means we must skip the remainder
 */
-bool flvHeader::extraHeader(flvTrak *trk,uint32_t *remain,bool have_cts,uint64_t *cts)
+bool flvHeader::extraHeader(flvTrak *trk,uint32_t *remain,bool have_cts,int32_t *cts)
 {
     int type=read8();
     int r=*remain;
     r--;
     if(have_cts)
     {
-        *cts=read24();
+        uint32_t c=read24();
+         *cts=(c+0xff800000)^0xff800000;
         //printf("Type :%d\n",type);
         r-=3;
     }
@@ -303,7 +304,9 @@
   // Loop
   while(pos<fileSize-14)
   {
-    uint64_t cts;
+    int32_t cts=0;
+    uint32_t pts=0xffffffff;
+
     pos=ftello(_fd);
     prevLen=read32();
     type=read8();
@@ -369,10 +372,13 @@
             if(codec==FLV_CODECID_H264)
             {
                 if(true==extraHeader(videoTrack,&remaining,true,&cts)) continue;
+                int64_t sum=cts+dts;
+                if(sum<0) pts=0xffffffff;
+                    else pts=dts+(int32_t)cts;
 
             }
             if(remaining)
-                insertVideo(ftello(_fd),remaining,frameType,dts);
+                insertVideo(ftello(_fd),remaining,frameType,dts,pts);
           }
            break;
       default: printf("[FLV]At 0x%x, unhandled type %u\n",pos,type);
@@ -385,7 +391,7 @@
    _videostream.dwLength= _mainaviheader.dwTotalFrames=videoTrack->_nbIndex;
    // Compute average fps
     float f=_videostream.dwLength;
-    uint64_t duration=videoTrack->_index[videoTrack->_nbIndex-1].timeCodeUs;
+    uint64_t duration=videoTrack->_index[videoTrack->_nbIndex-1].dtsUs;
 
     if(duration)
           f=1000.*1000.*1000.*f/duration;
@@ -406,7 +412,7 @@
     }
     _videostream.dwScale=1000;
     _mainaviheader.dwMicroSecPerFrame=ADM_UsecFromFps1000(_videostream.dwRate);
-   printf("[FLV] Duration %"LLU" ms\n",videoTrack->_index[videoTrack->_nbIndex-1].timeCodeUs/1000);
+   printf("[FLV] Duration %"LLU" ms\n",videoTrack->_index[videoTrack->_nbIndex-1].dtsUs/1000);
 
    //
     _videostream.fccType=fourCC::get((uint8_t *)"vids");
@@ -437,7 +443,7 @@
 */
 uint64_t flvHeader::getVideoDuration(void)
 {
-     uint64_t dur=videoTrack->_index[videoTrack->_nbIndex-1].timeCodeUs;
+     uint64_t dur=videoTrack->_index[videoTrack->_nbIndex-1].dtsUs;
     return dur;
 }
 
@@ -534,13 +540,16 @@
       \fn insertVideo
       \brief add a frame to the index, grow the index if needed
 */
-uint8_t flvHeader::insertVideo(uint32_t pos,uint32_t size,uint32_t frameType,uint32_t dts)
+uint8_t flvHeader::insertVideo(uint32_t pos,uint32_t size,uint32_t frameType,uint32_t dts,uint32_t pts)
 {
     videoTrack->grow();
     flvIndex *x=&(videoTrack->_index[videoTrack->_nbIndex]);
     x->size=size;
     x->pos=pos;
-    x->timeCodeUs=dts*1000LL;
+    x->dtsUs=dts*1000LL;
+    if(pts==0xffffffff) x->ptsUs=ADM_NO_PTS;
+        else
+      x->ptsUs=pts*1000LL;
     if(frameType==1)
     {
         x->flags=AVI_KEY_FRAME;
@@ -562,7 +571,7 @@
     flvIndex *x=&(audioTrack->_index[audioTrack->_nbIndex]);
     x->size=size;
     x->pos=pos;
-    x->timeCodeUs=pts*1000LL;
+    x->dtsUs=pts*1000LL;
     x->flags=0;
     audioTrack->_nbIndex++;
     return 1;
@@ -717,7 +726,7 @@
 {
      if(frame>=videoTrack->_nbIndex) return 0;
      flvIndex *idx=&(videoTrack->_index[frame]);
-     return idx->timeCodeUs;
+     return idx->dtsUs;
 }
 /**
         \fn getFrame
@@ -733,8 +742,8 @@
      img->flags=idx->flags;
      //img->demuxerDts=ADM_COMPRESSED_NO_PTS;
     // For flash assume PTS=DTS (???)
-     img->demuxerDts=idx->timeCodeUs;;
-     img->demuxerPts=idx->timeCodeUs;;
+     img->demuxerDts=idx->dtsUs;;
+     img->demuxerPts=idx->ptsUs;;
      return 1;
 }
 /**
@@ -783,8 +792,8 @@
 
      flvIndex *idx=&(videoTrack->_index[frame]);
     
-    *dts=idx->timeCodeUs; // FIXME
-    *pts=idx->timeCodeUs;
+    *dts=idx->dtsUs; // FIXME
+    *pts=idx->ptsUs;
     return true;
 }
 /**
@@ -800,7 +809,8 @@
 
      flvIndex *idx=&(videoTrack->_index[frame]);
     
-    idx->timeCodeUs=dts; // FIXME
+    idx->dtsUs=dts; // FIXME
+    idx->ptsUs=pts;
     //*pts=idx->timeCodeUs; // FIXME PTS=DTS ??
     return true;
 }

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Flv/ADM_flv.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Flv/ADM_flv.h	2009-08-31 15:56:21 UTC (rev 5283)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Flv/ADM_flv.h	2009-09-01 08:53:01 UTC (rev 5284)
@@ -29,7 +29,8 @@
     uint64_t pos;       // Absolute position in bytes
     uint32_t size;      // Size in bytes
     uint32_t flags;
-    uint64_t timeCodeUs;  // Time code in us from start
+    uint64_t dtsUs;  // Time code in us from start
+    uint64_t ptsUs;  // Time code in us from start
 }flvIndex;
 //**********************************************
 class flvTrak 
@@ -110,11 +111,11 @@
     uint32_t    read24(void);
     uint32_t    read32(void);
     uint8_t     Skip(uint32_t len);
-    uint8_t     insertVideo(uint32_t pos,uint32_t size,uint32_t frameType,uint32_t pts);
+    uint8_t     insertVideo(uint32_t pos,uint32_t size,uint32_t frameType,uint32_t dts,uint32_t pts);
     uint8_t     insertAudio(uint32_t pos,uint32_t size,uint32_t pts);
     uint8_t     setAudioHeader(uint32_t format,uint32_t fq,uint32_t bps,uint32_t channels);
     uint8_t     setVideoHeader(uint8_t codec,uint32_t *remaining);
-    bool        extraHeader(flvTrak *trk,uint32_t *remain,bool haveCts,uint64_t *cts);
+    bool        extraHeader(flvTrak *trk,uint32_t *remain,bool haveCts,int32_t *cts);
     
     uint8_t     getFrameSize (uint32_t frame, uint32_t * size);
     char        *readFlvString(void);

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Flv/ADM_flvAudio.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Flv/ADM_flvAudio.cpp	2009-08-31 15:56:21 UTC (rev 5283)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Flv/ADM_flvAudio.cpp	2009-09-01 08:53:01 UTC (rev 5284)
@@ -68,7 +68,7 @@
 {
     if(!_track->_nbIndex) return 0;
     // ms -> us
-    uint64_t dur=_track->_index[_track->_nbIndex-1].timeCodeUs;
+    uint64_t dur=_track->_index[_track->_nbIndex-1].dtsUs;
     
     return dur;
 }
@@ -85,7 +85,7 @@
 
       // First identify the cluster...
       // Special case when first chunk does not start at 0
-      if(_nbClusters && mstime<_track->_index[0].timeCodeUs)
+      if(_nbClusters && mstime<_track->_index[0].dtsUs)
       {
             goToBlock(0);
             return true;
@@ -93,7 +93,7 @@
       int clus=-1;
             for(int i=0;i<_nbClusters-1;i++)
             {
-              if(target>=_track->_index[i].timeCodeUs && target<_track->_index[i+1].timeCodeUs)
+              if(target>=_track->_index[i].dtsUs && target<_track->_index[i+1].dtsUs)
               {
                 clus=i;
                 i=_nbClusters; 
@@ -117,7 +117,7 @@
     x=&(_track->_index[currentBlock]);
     fread(buffer,x->size,1,_fd);
     *osize=x->size;
-    *dts=((uint64_t)x->timeCodeUs);
+    *dts=((uint64_t)x->dtsUs);
     
     currentBlock++;
     //



From mean at mail.berlios.de  Tue Sep  1 10:53:03 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 1 Sep 2009 10:53:03 +0200
Subject: [Avidemux-svn-commit] r5285 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs
Message-ID: <200909010853.n818r3Pw012710@sheep.berlios.de>

Author: mean
Date: 2009-09-01 10:53:03 +0200 (Tue, 01 Sep 2009)
New Revision: 5285

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_codecs.cpp
Log:
[codec] WVMA = VC1

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_codecs.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_codecs.cpp	2009-09-01 08:53:01 UTC (rev 5284)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_codecs.cpp	2009-09-01 08:53:03 UTC (rev 5285)
@@ -178,13 +178,13 @@
       return (decoders *) (new decoderFFWMV1 (w, h, extraLen, extraData));
     }
 
-  if (fourCC::check (fcc, (uint8_t *) "WMV3"))
+  if (fourCC::check (fcc, (uint8_t *) "WMV3") )
     {
 
       return (decoders *) (new decoderFFWMV3 (w, h, extraLen, extraData));
     }
 
-    if (fourCC::check (fcc, (uint8_t *) "WVC1"))
+    if (fourCC::check (fcc, (uint8_t *) "WVC1")|| fourCC::check (fcc, (uint8_t *) "WMVA"))
     {
 
       return (decoders *) (new decoderFFVC1 (w, h, extraLen, extraData));



From mean at mail.berlios.de  Tue Sep  1 10:53:04 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 1 Sep 2009 10:53:04 +0200
Subject: [Avidemux-svn-commit] r5286 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Flv
Message-ID: <200909010853.n818r4Ww012721@sheep.berlios.de>

Author: mean
Date: 2009-09-01 10:53:04 +0200 (Tue, 01 Sep 2009)
New Revision: 5286

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Flv/ADM_flv.cpp
Log:
[flv/demuxer] Fix extra data

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Flv/ADM_flv.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Flv/ADM_flv.cpp	2009-09-01 08:53:03 UTC (rev 5285)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Flv/ADM_flv.cpp	2009-09-01 08:53:04 UTC (rev 5286)
@@ -216,15 +216,15 @@
     {  // Grab extra data
         if(trk->extraData) 
         {
-            Skip(*remain);
+            Skip(r);
             r=0;
         }
         else    
         {
-            printf("[FLV] found some extradata %"LU"\n",*remain);
-            trk->extraData=new uint8_t[*remain];
-            trk->extraDataLen=*remain;
-            read(*remain,trk->extraData);
+            printf("[FLV] found some extradata %"LU"\n",r);
+            trk->extraData=new uint8_t[r];
+            trk->extraDataLen=r;
+            read(r,trk->extraData);
             r=0;            
         }
         *remain=r;



From mean at mail.berlios.de  Tue Sep  1 10:53:05 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 1 Sep 2009 10:53:05 +0200
Subject: [Avidemux-svn-commit] r5287 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska
Message-ID: <200909010853.n818r5XS012731@sheep.berlios.de>

Author: mean
Date: 2009-09-01 10:53:05 +0200 (Tue, 01 Sep 2009)
New Revision: 5287

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkvIndexer.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv_audio.cpp
Log:
[Mkv Demux] switch to vector for indeces, might be slower but much more elegant

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.cpp	2009-09-01 08:53:04 UTC (rev 5286)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.cpp	2009-09-01 08:53:05 UTC (rev 5287)
@@ -81,7 +81,7 @@
       return 0;
     }
   // update some infos
-  _videostream.dwLength= _mainaviheader.dwTotalFrames=_tracks[0]._nbIndex;
+  _videostream.dwLength= _mainaviheader.dwTotalFrames=_tracks[0].index.size();;
 
   _parser=new ADM_ebml_file();
   ADM_assert(_parser->open(name));
@@ -259,21 +259,7 @@
   {
     FREEIF(1+i);
   }
-  // Delete index
-  if(_isvideopresent && _tracks[0]._index)
-  {
-    delete []  _tracks[0]._index;
-    _tracks[0]._index=NULL;
-  }
-  for(int i=0;i<_nbAudioTrack;i++)
-  {
-    mkvIndex **dx=&(_tracks[1+i]._index);
-    if(*dx)
-    {
-        delete []  *dx;
-        *dx=NULL;
-    }
-  }
+
     if(_audioStreams)
     {
         for(int i=0;i<_nbAudioTrack;i++) if(_audioStreams[i]) delete _audioStreams[i];
@@ -324,8 +310,8 @@
 
   uint8_t  mkvHeader::setFlag(uint32_t frame,uint32_t flags)
 {
-  if(frame>=_tracks[0]._nbIndex) return 0;
-  _tracks[0]._index[frame].flags=flags;
+  if(frame>=_tracks[0].index.size()) return 0;
+  _tracks[0].index[frame].flags=flags;
   return 1;
 }
 
@@ -335,8 +321,8 @@
 */
 uint32_t mkvHeader::getFlags(uint32_t frame,uint32_t *flags)
 {
-  if(frame>=_tracks[0]._nbIndex) return 0;
-  *flags=_tracks[0]._index[frame].flags;
+  if(frame>=_tracks[0].index.size()) return 0;
+  *flags=_tracks[0].index[frame].flags;
   if(!frame) *flags=AVI_KEY_FRAME;
   return 1;
 }
@@ -345,8 +331,8 @@
 */
 uint64_t mkvHeader::getTime(uint32_t frame)
 {
- if(frame>=_tracks[0]._nbIndex) return ADM_COMPRESSED_NO_PTS;
-  return _tracks[0]._index[frame].Pts;
+ if(frame>=_tracks[0].index.size()) return ADM_COMPRESSED_NO_PTS;
+  return _tracks[0].index[frame].Pts;
 }
 /**
     \fn getVideoDuration
@@ -354,7 +340,9 @@
 */
 uint64_t mkvHeader::getVideoDuration(void)
 {
-    return _tracks[0]._index[_tracks[0]._nbIndex-1].Pts;
+    uint32_t limit=_tracks[0].index.size();
+    if(!limit) return 0;
+    return _tracks[0].index[limit-1].Pts;
 }
 
 /**
@@ -362,8 +350,8 @@
 */
 uint8_t                 mkvHeader::getFrameSize(uint32_t frame,uint32_t *size)
 {
-    if(frame>=_tracks[0]._nbIndex) return 0;
-    *size=_tracks[0]._index[frame].size;
+    if(frame>=_tracks[0].index.size()) return 0;
+    *size=_tracks[0].index[frame].size;
     return 1;
 }
 
@@ -375,9 +363,9 @@
 uint8_t  mkvHeader::getFrame(uint32_t framenum,ADMCompressedImage *img)
 {
   ADM_assert(_parser);
-  if(framenum>=_tracks[0]._nbIndex) return 0;
+  if(framenum>=_tracks[0].index.size()) return 0;
 
-  mkvIndex *dx=&(_tracks[0]._index[framenum]);
+  mkvIndex *dx=&(_tracks[0].index[framenum]);
 
   _parser->seek(dx->pos);
   _parser->readSignedInt(2); // Timecode
@@ -501,12 +489,12 @@
 bool    mkvHeader::getPtsDts(uint32_t frame,uint64_t *pts,uint64_t *dts)
 {
      ADM_assert(_parser);
-     if(frame>=_tracks[0]._nbIndex) 
+     if(frame>=_tracks[0].index.size()) 
      {
-            printf("[MKV] Frame %"LU" exceeds # of frames %"LU"\n",frame,_tracks[0]._nbIndex);
+            printf("[MKV] Frame %"LU" exceeds # of frames %"LU"\n",frame,_tracks[0].index.size());
             return false;
      }
-    mkvIndex *dx=&(_tracks[0]._index[frame]);
+    mkvIndex *dx=&(_tracks[0].index[frame]);
     
     *dts=dx->Dts; // FIXME
     *pts=dx->Pts;
@@ -518,12 +506,12 @@
 bool    mkvHeader::setPtsDts(uint32_t frame,uint64_t pts,uint64_t dts)
 {
       ADM_assert(_parser);
-     if(frame>=_tracks[0]._nbIndex) 
+     if(frame>=_tracks[0].index.size()) 
      {
-            printf("[MKV] Frame %"LU" exceeds # of frames %"LU"\n",frame,_tracks[0]._nbIndex);
+            printf("[MKV] Frame %"LU" exceeds # of frames %"LU"\n",frame,_tracks[0].index.size());
             return false;
      }
-    mkvIndex *dx=&(_tracks[0]._index[frame]);
+    mkvIndex *dx=&(_tracks[0].index[frame]);
     
     dx->Dts=dts; // FIXME
     dx->Pts=pts;

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.h	2009-09-01 08:53:04 UTC (rev 5286)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.h	2009-09-01 08:53:05 UTC (rev 5287)
@@ -25,7 +25,7 @@
 #include "ADM_Video.h"
 #include "ADM_audioStream.h"
 #include "ADM_ebml.h"
-
+#include <vector>
 /**
     \struct mkvIndex
     \brief defines a frame, audio or video
@@ -39,7 +39,7 @@
     uint64_t Pts;   // Pts in us
 }mkvIndex;
 
-
+typedef std::vector <mkvIndex > mkvListOfIndex;
 /**
     \struct mkvTrak
     \brief Hold information about a give track, the track #0  is always video.
@@ -53,14 +53,14 @@
   WAVHeader wavHeader;
   uint32_t  nbPackets; // number of blocks (used for audio)
   uint32_t  nbFrames;  // number of distinct frames
-  uint32_t  length;    // Number of bytes seen
+  uint32_t  length;    // Number o;f bytes seen
   
   /* Used for both */
   uint8_t    *extraData;
   uint32_t   extraDataLen;
-  mkvIndex  *_index;
-  uint32_t  _nbIndex;  // current size of the index
-  uint32_t  _indexMax; // Max size of the index
+  
+  mkvListOfIndex  index;
+
   uint32_t  _sizeInBytes; // Approximate size in bytes of that stream
   uint32_t  _defaultFrameDuration; // Duration of ONE frame in us!
 }mkvTrak;

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkvIndexer.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkvIndexer.cpp	2009-09-01 08:53:04 UTC (rev 5286)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkvIndexer.cpp	2009-09-01 08:53:05 UTC (rev 5287)
@@ -37,12 +37,7 @@
 
    parser->seek(0);
    DIA_workingBase *work=createWorking("Matroska Images");
-   // Start with a small index, it will grow automatically afterward
-   for(int i=0;i<_nbAudioTrack+1;i++)
-   {
-    _tracks[i]._indexMax=1000;
-    _tracks[i]._index=new mkvIndex[_tracks[i]._indexMax];
-   }
+ 
     //************
    work->update(0);
    for(int clusters=0;clusters<_nbClusters;clusters++)
@@ -107,7 +102,7 @@
      }
    // printf("[MKV] ending cluster at 0x%llx\n",segment.tell());
   }
-     printf("Found %"LU" images in this cluster\n",VIDEO._nbIndex);
+     printf("Found %"LU" images in this cluster\n",(uint32_t)VIDEO.index.size());
      delete work;
      return 1;
 }
@@ -152,25 +147,16 @@
 {
   //
   mkvTrak *Track=&(_tracks[track]);
-  // Need to grow index ?
-  if(Track->_nbIndex==Track->_indexMax-1)
-  {
-    // Realloc
-    mkvIndex *dx=new mkvIndex[Track->_indexMax*2];
-    memcpy(dx, Track->_index,sizeof(mkvIndex)*Track->_nbIndex);
-    Track->_indexMax*=2;
-    delete [] Track->_index;
-    Track->_index=dx;
-  }
+  mkvIndex ix;
 
-  mkvIndex *index=Track->_index;
-  int x=Track->_nbIndex;
-  index[x].pos=where;
-  index[x].size=size;
-  index[x].flags=AVI_KEY_FRAME;
-  index[x].Dts=timecodeMS*1000;
-  index[x].Pts=timecodeMS*1000;
-  Track->_nbIndex++;
+  ix.pos=where;
+  ix.size=size;
+  ix.flags=AVI_KEY_FRAME;
+  ix.Dts=timecodeMS*1000;
+  ix.Pts=timecodeMS*1000;
+
+  Track->index.push_back(ix);
+
   return 1;
 }
 

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv_audio.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv_audio.cpp	2009-09-01 08:53:04 UTC (rev 5286)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv_audio.cpp	2009-09-01 08:53:05 UTC (rev 5287)
@@ -87,9 +87,10 @@
 */
 uint64_t  mkvAccess::getDurationInUs(void)
 {
-    uint32_t limit=_track->_nbIndex;
-    mkvIndex *dex=_track->_index;
-    return dex[limit-1].Dts;
+    
+    uint32_t limit=_track->index.size();
+    if(!limit) return 0;
+    return _track->index[limit-1].Dts;
 }
 /**
     \fn mkvAccess
@@ -106,14 +107,14 @@
 */
 uint8_t mkvAccess::goToBlock(uint32_t x)
 {
-
-  if(x>=_track->_nbIndex)
+  uint32_t limit=_track->index.size();
+  if(x>=limit)
   {
-    printf("Exceeding max cluster : asked: %u max :%u\n",x,_track->_nbIndex);
+    printf("Exceeding max cluster : asked: %u max :%u\n",x,limit);
     return 0;  // FIXME
   }
 
-  _parser->seek(_track->_index[x].pos);
+  _parser->seek(_track->index[x].pos);
   _currentLace=_maxLace=0;
   _currentBlock=x;
   return 1;
@@ -125,13 +126,13 @@
 {
 uint64_t targetUs=timeUs;
 
-    uint32_t limit=_track->_nbIndex;
-    mkvIndex *dex=_track->_index;
+    uint32_t limit=_track->index.size();
+    mkvListOfIndex *dex=&(_track->index);
       // First identify the cluster...
       int clus=-1;
             for(int i=0;i<limit-1;i++)
             {
-              if(targetUs>=dex[i].Dts && targetUs<dex[i+1].Dts)
+              if(targetUs>=(*dex)[i].Dts && targetUs<(*dex)[i+1].Dts)
               {
                 clus=i;
                 break;
@@ -139,7 +140,7 @@
             }
             if(clus==-1) clus=limit-1; // Hopefully in the last one
 
-            targetUs-=dex[clus].Dts; // now the time is relative
+            targetUs-=(*dex)[clus].Dts; // now the time is relative
             goToBlock(clus);
 
             printf("[MKVAUDIO] Asked for %"LLU" us, go to block %d, which starts at %"LLU" ms\n",timeUs,clus,targetUs);
@@ -193,12 +194,12 @@
       _currentLace++;
       return true;
     }
-    if(_currentBlock>=_track->_nbIndex) return false;
+    if(_currentBlock>=_track->index.size()) return false;
     // Else we start a new lace (or no lacing at all)
     goToBlock(_currentBlock);
-    mkvIndex *dex=_track->_index;
-    uint64_t size=dex[_currentBlock].size-3;
-    uint64_t time=dex[_currentBlock].Dts;
+    mkvIndex *dex=&(_track->index[_currentBlock]);
+    uint64_t size=dex->size-3;
+    uint64_t time=dex->Dts;
     if(!time && _currentBlock) time=ADM_AUDIO_NO_DTS;
     vprintf("[MKV] Time :%lu block:%u\n",time,_currentBlock);
     // Read headers & flags



From mean at mail.berlios.de  Tue Sep  1 10:53:09 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 1 Sep 2009 10:53:09 +0200
Subject: [Avidemux-svn-commit] r5288 - in branches/avidemux_2.6_branch_mean:
	avidemux_core/ADM_coreUtils/include avidemux_core/ADM_coreUtils/src
	avidemux_plugins/ADM_demuxers/OpenDml
Message-ID: <200909010853.n818r98x012741@sheep.berlios.de>

Author: mean
Date: 2009-09-01 10:53:08 +0200 (Tue, 01 Sep 2009)
New Revision: 5288

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/include/ADM_videoInfoExtractor.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_infoExtractor.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/OpenDml/ADM_openDMLDepack.cpp
Log:
[Utils] Move search Vop to utils, can be handy for other use cases beside unpacking

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/include/ADM_videoInfoExtractor.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/include/ADM_videoInfoExtractor.h	2009-09-01 08:53:05 UTC (rev 5287)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/include/ADM_videoInfoExtractor.h	2009-09-01 08:53:08 UTC (rev 5288)
@@ -22,5 +22,20 @@
 uint8_t extractH264FrameType(uint32_t nalSize,uint8_t *buffer,uint32_t len,uint32_t *flags);
 uint8_t extractH264FrameType_startCode(uint32_t nalSize,uint8_t *buffer,uint32_t len,uint32_t *flags);
 
+/**
+    \struct ADM_vopS
+    \brief describe a vop inside a bitstream (mpeg4 SP/ASP)
+*/
+typedef struct 
+{
+	uint32_t offset;
+	uint32_t type;
+    uint32_t vopCoded;
+    uint32_t modulo;
+    uint32_t timeInc;
+}ADM_vopS;
+
+
+uint32_t ADM_searchVop(uint8_t *begin, uint8_t *end,uint32_t *nb, ADM_vopS *vop,uint32_t *timeincbits);
 #endif
 //EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_infoExtractor.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_infoExtractor.cpp	2009-09-01 08:53:05 UTC (rev 5287)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_infoExtractor.cpp	2009-09-01 08:53:08 UTC (rev 5288)
@@ -21,9 +21,11 @@
 
 #define aprintf(...) {}
 #include "ADM_getbits.h"
+#include "ADM_videoInfoExtractor.h"
 #include "ADM_h264_tag.h"
 
 static void refineH264FrameType(uint8_t *head,uint8_t *tail,uint32_t *flags);
+bool ADM_findMpegStartCode(uint8_t *start, uint8_t *end,uint8_t *outstartcode,uint32_t *offset);
 /*
     Extract width & height from vol header passed as arg
 
@@ -593,4 +595,76 @@
                 sliceType -= 5;
             if(sliceType==3) *flags=AVI_B_FRAME;  
 }
+/**
+    \fn ADM_searchVop
+    \brief search vop header in a bitstream 
+    Used for packed bitstream and also to identify the frametype
+
+*/
+uint32_t ADM_searchVop(uint8_t *begin, uint8_t *end,uint32_t *nb, ADM_vopS *vop,uint32_t *timeincbits)
+{
+
+	uint32_t off=0;
+	uint32_t globalOff=0;
+	uint32_t voptype;
+	uint8_t code;
+        uint32_t w,h,t;
+        uint32_t modulo,time_inc,vopcoded,vopType;
+	*nb=0;
+	while(begin<end-3)
+	{
+    	if( ADM_findMpegStartCode(begin, end,&code,&off))
+    	{
+        	if(code==0xb6)
+			{
+				// Analyse a bit the vop header
+				uint8_t coding_type=begin[off];
+				coding_type>>=6;
+				aprintf("\t at %u %d Img type:%s\n",off,*nb,s_voptype[coding_type]);
+				switch(coding_type)
+				{
+					case 0: voptype=AVI_KEY_FRAME;break;
+					case 1: voptype=0;break;
+					case 2: voptype=AVI_B_FRAME;break;
+					case 3: printf("[Avi] Glouglou\n");voptype=0;break;
+
+				}
+        	                vop[*nb].offset=globalOff+off-4;
+				vop[*nb].type=voptype;
+
+
+
+                                /* Get more info */
+                                if( extractVopInfo(begin+off, end-begin-off, *timeincbits,&vopType,&modulo, &time_inc,&vopcoded))
+                                {
+                                    aprintf(" frame found: vopType:%x modulo:%d time_inc:%d vopcoded:%d\n",vopType,modulo,time_inc,vopcoded);
+                                    vop[*nb].modulo=modulo;
+                                    vop[*nb].timeInc=time_inc;
+                                    vop[*nb].vopCoded=vopcoded;
+                                }
+                                *nb=(*nb)+1;
+                                begin+=off+1;
+				globalOff+=off+1;
+				continue;
+
+			}
+                else if(code==0x20 && off>=4	) // Vol start
+                {
+
+                   if(extractMpeg4Info(begin+off-4,end+4-off-begin,&w,&h,timeincbits))
+                   {
+                      aprintf("Found Vol header : w:%d h:%d timeincbits:%d\n",w,h,*timeincbits);
+                   }
+
+                }
+        	begin+=off;
+        	globalOff+=off;
+        	continue;
+    	}
+    	return 1;
+    }
+	return 1;
+}
+
+
 //EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/OpenDml/ADM_openDMLDepack.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/OpenDml/ADM_openDMLDepack.cpp	2009-09-01 08:53:05 UTC (rev 5287)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/OpenDml/ADM_openDMLDepack.cpp	2009-09-01 08:53:08 UTC (rev 5288)
@@ -29,7 +29,7 @@
 #include "ADM_openDML.h"
 
 #include "DIA_working.h"
-//#include "ADM_libraries/ADM_utilities/avidemutils.h"
+#include "ADM_videoInfoExtractor.h"
 
 
 #define aprintf(...) {}
@@ -39,14 +39,7 @@
 #endif
 #define DEPACK_VERBOSE
 #define QT_TR_NOOP(x) x
-typedef struct vopS
-{
-	uint32_t offset;
-	uint32_t type;
-        uint32_t vopCoded;
-        uint32_t modulo;
-        uint32_t timeInc;
-}vopS;
+
 #define MAX_VOP 10
 
 /* Forward declaration */
@@ -55,7 +48,7 @@
 uint8_t extractMpeg4Info(uint8_t *data,uint32_t dataSize,uint32_t *w,uint32_t *h,uint32_t *time_inc);
 
 /* Static ones */
-static uint32_t searchVop(uint8_t *begin, uint8_t *end,uint32_t *nb, vopS *vop,uint32_t *timeincbits);
+
 static const char *s_voptype[4]={"I frame","P frame","B frame","D frame"};
 /**
     \fn unpackPacked
@@ -68,9 +61,9 @@
 	uint32_t firstType, secondType,thirdType;
 	uint32_t targetIndex=0,nbVop;
 	uint32_t nbDuped=0;
-        uint32_t timcincbits=16;  /* Nb bits used to code time_inc 16 is a safe default */
+    uint32_t timcincbits=16;  /* Nb bits used to code time_inc 16 is a safe default */
 
-	vopS	myVops[MAX_VOP]; // should be enough
+	ADM_vopS	myVops[MAX_VOP]; // should be enough
 	// here we got the vidHeader to get the file easily
 	// we only deal with avi now, so cast it to its proper type (i.e. avi)
 
@@ -134,7 +127,7 @@
                                 continue;
                 }
                 /* Cannot find vop, corrupted or WTF ...*/
-                if(!searchVop(buffer,buffer+image.dataLength,&nbVop,myVops,&timcincbits))
+                if(!ADM_searchVop(buffer,buffer+image.dataLength,&nbVop,myVops,&timcincbits))
                 {
                     printf("[Avi] img :%u failed to find vop!\n",img);
                     memcpy(&newIndex[targetIndex],&_idx[img],sizeof(_idx[0]));
@@ -232,70 +225,3 @@
 
 	return ret;
 }
-// Search a start vop in it
-// and return also the vop type
-// needed to update the index
-uint32_t searchVop(uint8_t *begin, uint8_t *end,uint32_t *nb, vopS *vop,uint32_t *timeincbits)
-{
-
-	uint32_t off=0;
-	uint32_t globalOff=0;
-	uint32_t voptype;
-	uint8_t code;
-        uint32_t w,h,t;
-        uint32_t modulo,time_inc,vopcoded,vopType;
-	*nb=0;
-	while(begin<end-3)
-	{
-    	if( ADM_findMpegStartCode(begin, end,&code,&off))
-    	{
-        	if(code==0xb6)
-			{
-				// Analyse a bit the vop header
-				uint8_t coding_type=begin[off];
-				coding_type>>=6;
-				aprintf("\t at %u %d Img type:%s\n",off,*nb,s_voptype[coding_type]);
-				switch(coding_type)
-				{
-					case 0: voptype=AVI_KEY_FRAME;break;
-					case 1: voptype=0;break;
-					case 2: voptype=AVI_B_FRAME;break;
-					case 3: printf("[Avi] Glouglou\n");voptype=0;break;
-
-				}
-        	                vop[*nb].offset=globalOff+off-4;
-				vop[*nb].type=voptype;
-
-
-
-                                /* Get more info */
-                                if( extractVopInfo(begin+off, end-begin-off, *timeincbits,&vopType,&modulo, &time_inc,&vopcoded))
-                                {
-                                    aprintf(" frame found: vopType:%x modulo:%d time_inc:%d vopcoded:%d\n",vopType,modulo,time_inc,vopcoded);
-                                    vop[*nb].modulo=modulo;
-                                    vop[*nb].timeInc=time_inc;
-                                    vop[*nb].vopCoded=vopcoded;
-                                }
-                                *nb=(*nb)+1;
-                                begin+=off+1;
-				globalOff+=off+1;
-				continue;
-
-			}
-                else if(code==0x20 && off>=4	) // Vol start
-                {
-
-                   if(extractMpeg4Info(begin+off-4,end+4-off-begin,&w,&h,timeincbits))
-                   {
-                      aprintf("Found Vol header : w:%d h:%d timeincbits:%d\n",w,h,*timeincbits);
-                   }
-
-                }
-        	begin+=off;
-        	globalOff+=off;
-        	continue;
-    	}
-    	return 1;
-    }
-	return 1;
-}



From mean at mail.berlios.de  Tue Sep  1 10:53:10 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 1 Sep 2009 10:53:10 +0200
Subject: [Avidemux-svn-commit] r5289 -
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src
Message-ID: <200909010853.n818rAr8012763@sheep.berlios.de>

Author: mean
Date: 2009-09-01 10:53:10 +0200 (Tue, 01 Sep 2009)
New Revision: 5289

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_infoExtractor.cpp
Log:
[utils] Fix extractH264 frametype + refine which are buggy for non startcode case

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_infoExtractor.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_infoExtractor.cpp	2009-09-01 08:53:08 UTC (rev 5288)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_infoExtractor.cpp	2009-09-01 08:53:10 UTC (rev 5289)
@@ -493,6 +493,7 @@
   {
     
               uint32_t length=(head[0]<<24) + (head[1]<<16) +(head[2]<<8)+(head[3]);
+              //printf("Block size : %"LU", available : %"LU"\n",length,len);
               if(length>len||length<6)
               {
                 printf("Warning , incomplete nal (%u/%u),(%0x/%0x)\n",length,len,length,len);
@@ -500,8 +501,7 @@
                 return 0;
               }
               head+=4; // Skip nal lenth
-              length-=4;
-              stream=*(head++)&0x1F;
+              stream=*(head)&0x1F;
                 switch(stream)
                 {
                   case NAL_IDR: 
@@ -510,12 +510,13 @@
                                   return 1;
                                   break; 
                   case NAL_NON_IDR: 
-                                  refineH264FrameType(head,tail,flags);
+                                  refineH264FrameType(head+1,tail,flags);
                                   return 1;
-                                  break;
+                                  break;                  
                   default:
                           printf("??0x%x\n",stream);
-                          head+=length-5;
+                  case NAL_SEI:  
+                          head+=length;
                           continue;
                 }
   }
@@ -585,7 +586,7 @@
             *flags=0;
             init_get_bits(&s,head, (tail-head)*8);
             get_ue_golomb(&s);
-            sliceType= get_ue_golomb(&s);
+            sliceType= get_ue_golomb_31(&s);
             if(sliceType > 9) 
             {
               printf("Weird Slice %d\n",sliceType);
@@ -593,7 +594,8 @@
             }
             if(sliceType > 4)
                 sliceType -= 5;
-            if(sliceType==3) *flags=AVI_B_FRAME;  
+            if(sliceType==1) *flags=AVI_B_FRAME;
+            //printf("[H264] Slice type : %"LU"\n",sliceType);
 }
 /**
     \fn ADM_searchVop



From mean at mail.berlios.de  Tue Sep  1 10:53:12 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 1 Sep 2009 10:53:12 +0200
Subject: [Avidemux-svn-commit] r5291 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska
Message-ID: <200909010853.n818rCpu012784@sheep.berlios.de>

Author: mean
Date: 2009-09-01 10:53:12 +0200 (Tue, 01 Sep 2009)
New Revision: 5291

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkvIndexer.cpp
Log:
[mkv/demuxer] Dont forget to update the index

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkvIndexer.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkvIndexer.cpp	2009-09-01 08:53:11 UTC (rev 5290)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkvIndexer.cpp	2009-09-01 08:53:12 UTC (rev 5291)
@@ -187,6 +187,7 @@
                 {
                     printf("[MKV/H264] Frame %"LU" is a keyframe\n",(uint32_t)Track->index.size());
                 }
+                ix.flags=flags;
                 //printf("[] Flags=%x\n",flags);
 
     }



From mean at mail.berlios.de  Tue Sep  1 10:53:11 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 1 Sep 2009 10:53:11 +0200
Subject: [Avidemux-svn-commit] r5290 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska
Message-ID: <200909010853.n818rBD1012773@sheep.berlios.de>

Author: mean
Date: 2009-09-01 10:53:11 +0200 (Tue, 01 Sep 2009)
New Revision: 5290

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkvIndexer.cpp
Log:
[mkv demuxer] On the fly indexing for h264 and mpeg4 SP/ASP video stream, still buggy

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.cpp	2009-09-01 08:53:10 UTC (rev 5289)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.cpp	2009-09-01 08:53:11 UTC (rev 5290)
@@ -491,7 +491,7 @@
      ADM_assert(_parser);
      if(frame>=_tracks[0].index.size()) 
      {
-            printf("[MKV] Frame %"LU" exceeds # of frames %"LU"\n",frame,_tracks[0].index.size());
+            printf("[MKV] Frame %"LU" exceeds # of frames %"LU"\n",frame,(uint32_t)_tracks[0].index.size());
             return false;
      }
     mkvIndex *dx=&(_tracks[0].index[frame]);
@@ -508,7 +508,7 @@
       ADM_assert(_parser);
      if(frame>=_tracks[0].index.size()) 
      {
-            printf("[MKV] Frame %"LU" exceeds # of frames %"LU"\n",frame,_tracks[0].index.size());
+            printf("[MKV] Frame %"LU" exceeds # of frames %"LU"\n",frame,(uint32_t)_tracks[0].index.size());
             return false;
      }
     mkvIndex *dx=&(_tracks[0].index[frame]);

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.h	2009-09-01 08:53:10 UTC (rev 5289)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.h	2009-09-01 08:53:11 UTC (rev 5290)
@@ -136,7 +136,7 @@
     uint8_t                 reformatVorbisHeader(mkvTrak *trk);
     // Indexers
 
-    uint8_t                 addIndexEntry(uint32_t track,uint64_t where, uint32_t size,uint32_t flags,
+    uint8_t                 addIndexEntry(uint32_t track,ADM_ebml_file *parser,uint64_t where, uint32_t size,uint32_t flags,
                                             uint32_t timecodeMS);
     uint8_t                 videoIndexer(ADM_ebml_file *parser);
     uint8_t                 readCue(ADM_ebml_file *parser);

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkvIndexer.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkvIndexer.cpp	2009-09-01 08:53:10 UTC (rev 5289)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkvIndexer.cpp	2009-09-01 08:53:11 UTC (rev 5290)
@@ -22,6 +22,8 @@
 
 #include "mkv_tags.h"
 #include "DIA_working.h"
+#include "ADM_codecType.h"
+#include "ADM_videoInfoExtractor.h"
 #define VIDEO _tracks[0]
 /**
     \fn videoIndexer
@@ -133,7 +135,7 @@
 
       lacing=((flags>>1)&3);
 
-      addIndexEntry(track,blockBegin,tail-blockBegin,entryFlags,clusterTimeCodeMs+timecode);
+      addIndexEntry(track,parser,blockBegin,tail-blockBegin,entryFlags,clusterTimeCodeMs+timecode);
       parser->seek(tail);
       return 1;
 }
@@ -143,7 +145,7 @@
     \brief add an entry to the video index
     @param timecodeMS PTS of the frame in ms!
 */
-uint8_t mkvHeader::addIndexEntry(uint32_t track,uint64_t where, uint32_t size,uint32_t flags,uint32_t timecodeMS)
+uint8_t mkvHeader::addIndexEntry(uint32_t track,ADM_ebml_file *parser,uint64_t where, uint32_t size,uint32_t flags,uint32_t timecodeMS)
 {
   //
   mkvTrak *Track=&(_tracks[track]);
@@ -154,7 +156,41 @@
   ix.flags=AVI_KEY_FRAME;
   ix.Dts=timecodeMS*1000;
   ix.Pts=timecodeMS*1000;
+  
+  // since frame type is unreliable for mkv, we scan each frame
+  // For the 2 most common cases : mp4 & h264.
+  // Hackish, we already read the 3 bytes header
+  // But they are already taken into account in the size part 
+  if(!track) // Track 0 is video
+  {
+    if( isMpeg4Compatible(_videostream.fccHandler))
+    {
+        uint8_t buffer[size];
+        
+            parser->readBin(buffer,size-3);
+            // Search the frame type...
 
+             uint32_t nb,vopType,timeinc=16;
+             ADM_vopS vops[10];
+             vops[0].type=AVI_KEY_FRAME;
+             ADM_searchVop(buffer,buffer+size-3,&nb,vops, &timeinc);
+             ix.flags=vops[0].type;
+        
+    }else
+    if(isH264Compatible(_videostream.fccHandler))
+    {
+            uint8_t buffer[size];
+                uint32_t flags=AVI_KEY_FRAME;
+                parser->readBin(buffer,size-3);
+                extractH264FrameType(2,buffer,size-3,&flags); // Nal size is not used in that case
+                if(flags & AVI_KEY_FRAME)
+                {
+                    printf("[MKV/H264] Frame %"LU" is a keyframe\n",(uint32_t)Track->index.size());
+                }
+                //printf("[] Flags=%x\n",flags);
+
+    }
+  }
   Track->index.push_back(ix);
 
   return 1;



From gruntster at mail.berlios.de  Wed Sep  2 23:14:55 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Wed, 2 Sep 2009 23:14:55 +0200
Subject: [Avidemux-svn-commit] r5292 - in
	branches/avidemux_2.5_branch_gruntster/avidemux: .
	ADM_libraries/ADM_mplex ADM_outputs/oplug_avi
	ADM_outputs/oplug_dummy ADM_outputs/oplug_flv
	ADM_outputs/oplug_mp4 ADM_outputs/oplug_mpeg
	ADM_outputs/oplug_mpegFF ADM_script ADM_toolkit
Message-ID: <200909022114.n82LEsFp013677@sheep.berlios.de>

Author: gruntster
Date: 2009-09-02 23:14:47 +0200 (Wed, 02 Sep 2009)
New Revision: 5292

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_mplex/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_avi/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_dummy/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_flv/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_mp4/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_mpeg/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_mpegFF/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_toolkit/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/CMakeLists.txt
Log:
[cmake] add pthread include directory where required

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_mplex/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_mplex/CMakeLists.txt	2009-09-01 08:53:12 UTC (rev 5291)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_mplex/CMakeLists.txt	2009-09-02 21:14:47 UTC (rev 5292)
@@ -6,6 +6,7 @@
 	ADM_mplexmuxer.cpp  ADM_transfert.cpp  interact.cpp       mpastrm_in.cpp  stillsstream.cpp  mpegconsts.c      mjpeg_logging.c    decodebufmodel.cpp
 	yuv4mpeg.c          cpu_accel.c)
 
+include_directories("${PTHREAD_INCLUDE_DIR}")
 ADD_ADM_LIB_ALL_TARGETS(${ADM_LIB} ${${ADM_LIB}_SRCS})
 ADD_CFLAGS_ALL_TARGETS(${ADM_LIB} "-I${CMAKE_CURRENT_SOURCE_DIR} -DHAVE_FMAX -DRETSIGTYPE=void")
 

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_avi/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_avi/CMakeLists.txt	2009-09-01 08:53:12 UTC (rev 5291)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_avi/CMakeLists.txt	2009-09-02 21:14:47 UTC (rev 5292)
@@ -2,4 +2,6 @@
 	avilist.cpp  op_avisavecopy_pack.cpp   op_avisave.cpp   op_aviwrite.cpp   op_savesmart.cpp
 	op_avisavecopy.cpp  op_avisavecopy_unpack.cpp  op_avisavedual.cpp  op_saveprocess.cpp)
 
+include_directories("${PTHREAD_INCLUDE_DIR}")
+
 ADD_ADM_LIB_ALL_TARGETS(oplug_avi ${ADM_oplug_avi_SRCS})

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_dummy/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_dummy/CMakeLists.txt	2009-09-01 08:53:12 UTC (rev 5291)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_dummy/CMakeLists.txt	2009-09-02 21:14:47 UTC (rev 5292)
@@ -1,3 +1,4 @@
 SET(ADM_oplug_dummy_SRCS oplug_dummy.cpp)
 
+include_directories("${PTHREAD_INCLUDE_DIR}")
 ADD_ADM_LIB_ALL_TARGETS(oplug_dummy ${ADM_oplug_dummy_SRCS})
\ No newline at end of file

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_flv/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_flv/CMakeLists.txt	2009-09-01 08:53:12 UTC (rev 5291)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_flv/CMakeLists.txt	2009-09-02 21:14:47 UTC (rev 5292)
@@ -1,3 +1,4 @@
 SET(ADM_oplug_flv_SRCS oplug_flv.cpp)
 
+include_directories("${PTHREAD_INCLUDE_DIR}")
 ADD_ADM_LIB_ALL_TARGETS(oplug_flv ${ADM_oplug_flv_SRCS})
\ No newline at end of file

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_mp4/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_mp4/CMakeLists.txt	2009-09-01 08:53:12 UTC (rev 5291)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_mp4/CMakeLists.txt	2009-09-02 21:14:47 UTC (rev 5292)
@@ -1,3 +1,4 @@
 SET(ADM_oplug_mp4_SRCS oplug_mp4.cpp)
 
+include_directories("${PTHREAD_INCLUDE_DIR}")
 ADD_ADM_LIB_ALL_TARGETS(oplug_mp4 ${ADM_oplug_mp4_SRCS})

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_mpeg/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_mpeg/CMakeLists.txt	2009-09-01 08:53:12 UTC (rev 5291)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_mpeg/CMakeLists.txt	2009-09-02 21:14:47 UTC (rev 5292)
@@ -1,4 +1,5 @@
 SET(ADM_oplug_mpeg_SRCS 
 	op_mpegpass.cpp)
-	
+
+include_directories("${PTHREAD_INCLUDE_DIR}")
 ADD_ADM_LIB_ALL_TARGETS(oplug_mpeg ${ADM_oplug_mpeg_SRCS})
\ No newline at end of file

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_mpegFF/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_mpegFF/CMakeLists.txt	2009-09-01 08:53:12 UTC (rev 5291)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_mpegFF/CMakeLists.txt	2009-09-02 21:14:47 UTC (rev 5292)
@@ -1,4 +1,5 @@
 SET(ADM_oplug_mpegFF_SRCS 
 	oplug_vcdff.cpp)
 
+include_directories("${PTHREAD_INCLUDE_DIR}")
 ADD_ADM_LIB_ALL_TARGETS(oplug_mpegFF ${ADM_oplug_mpegFF_SRCS})

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/CMakeLists.txt	2009-09-01 08:53:12 UTC (rev 5291)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/CMakeLists.txt	2009-09-02 21:14:47 UTC (rev 5292)
@@ -3,6 +3,7 @@
 	ADM_Avidemux.cpp       ADM_JSAvidemuxAudio.cpp  ADM_JSAvidemuxVideo.cpp  ADM_JSFunctions.cpp        DirectorySearch.cpp
 	ADM_JSDialogFactory.cpp  ADM_JSDFMenu.cpp  ADM_JSAppliedVideoFilter.cpp  ADM_JSAudioTrackInfo.cpp)
 
+include_directories("${PTHREAD_INCLUDE_DIR}")
 ADD_ADM_LIB_ALL_TARGETS(ADM_script ${ADM_script_SRCS})
 
 IF (WIN32)

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_toolkit/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_toolkit/CMakeLists.txt	2009-09-01 08:53:12 UTC (rev 5291)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_toolkit/CMakeLists.txt	2009-09-02 21:14:47 UTC (rev 5292)
@@ -1,4 +1,5 @@
 SET(ADM_toolkit_SRCS 
 	ADM_audioQueue.cpp  ADM_packetQueue.cpp  automation.cpp  filesel.cpp)
-	
+
+include_directories("${PTHREAD_INCLUDE_DIR}")
 ADD_ADM_LIB_ALL_TARGETS(ADM_toolkit ${ADM_toolkit_SRCS})

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/CMakeLists.txt	2009-09-01 08:53:12 UTC (rev 5291)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/CMakeLists.txt	2009-09-02 21:14:47 UTC (rev 5292)
@@ -169,7 +169,8 @@
 ENDIF (ADM_UI_QT4)
 
 SDLify(main.cpp)
-ADD_SOURCE_CFLAGS(main.cpp "-DADM_SUBVERSION=${ADM_SUBVERSION}")
+ADD_SOURCE_CFLAGS(main.cpp "-DADM_SUBVERSION=${ADM_SUBVERSION} -I${PTHREAD_INCLUDE_DIR}")
+ADD_SOURCE_CFLAGS(gui_savenew.cpp "-I${PTHREAD_INCLUDE_DIR}")
 
 ########################################
 # FFmpeg



From gruntster at mail.berlios.de  Thu Sep  3 00:04:26 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Thu, 3 Sep 2009 00:04:26 +0200
Subject: [Avidemux-svn-commit] r5293 -
	branches/avidemux_2.5_branch_gruntster/cmake
Message-ID: <200909022204.n82M4QZN017291@sheep.berlios.de>

Author: gruntster
Date: 2009-09-03 00:04:21 +0200 (Thu, 03 Sep 2009)
New Revision: 5293

Modified:
   branches/avidemux_2.5_branch_gruntster/cmake/admCheckX264.cmake
Log:
[cmake] detect new x264 api

Modified: branches/avidemux_2.5_branch_gruntster/cmake/admCheckX264.cmake
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/admCheckX264.cmake	2009-09-02 21:14:47 UTC (rev 5292)
+++ branches/avidemux_2.5_branch_gruntster/cmake/admCheckX264.cmake	2009-09-02 22:04:21 UTC (rev 5293)
@@ -6,8 +6,7 @@
 		MESSAGE(STATUS "*****************")
 
 		IF (X264)
-			FIND_HEADER_AND_LIB(X264 x264.h x264 x264_encoder_open)
-			PRINT_LIBRARY_INFO("x264" X264_FOUND "${X264_INCLUDE_DIR}" "${X264_LIBRARY_DIR}")
+			FIND_HEADER_AND_LIB(X264 x264.h)
 
 			IF (X264_FOUND)
 				FILE(READ ${X264_INCLUDE_DIR}/x264.h X264_H)
@@ -18,8 +17,14 @@
 				IF (x264_version LESS 54)
 					MESSAGE("WARNING: x264 core version is too old.  At least version 54 is required.")
 					SET(X264_FOUND 0)
+				ELSEIF (x264_version GREATER 73)
+					FIND_HEADER_AND_LIB(X264 "" x264 x264_encoder_open_${x264_version})
+				ELSE (x264_version LESS 54)
+					FIND_HEADER_AND_LIB(X264 "" x264 x264_encoder_open)
 				ENDIF (x264_version LESS 54)
 			ENDIF (X264_FOUND)
+
+			PRINT_LIBRARY_INFO("x264" X264_FOUND "${X264_INCLUDE_DIR}" "${X264_LIBRARY_DIR}")
 		ELSE (X264)
 			MESSAGE("${MSG_DISABLE_OPTION}")
 		ENDIF (X264)



From gruntster at mail.berlios.de  Thu Sep  3 00:24:02 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Thu, 3 Sep 2009 00:24:02 +0200
Subject: [Avidemux-svn-commit] r5294 -
	branches/avidemux_2.5_branch_gruntster/cmake
Message-ID: <200909022224.n82MO21w018980@sheep.berlios.de>

Author: gruntster
Date: 2009-09-03 00:23:57 +0200 (Thu, 03 Sep 2009)
New Revision: 5294

Modified:
   branches/avidemux_2.5_branch_gruntster/cmake/admCheckX264.cmake
Log:
[cmake] fix x264 detection

Modified: branches/avidemux_2.5_branch_gruntster/cmake/admCheckX264.cmake
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/admCheckX264.cmake	2009-09-02 22:04:21 UTC (rev 5293)
+++ branches/avidemux_2.5_branch_gruntster/cmake/admCheckX264.cmake	2009-09-02 22:23:57 UTC (rev 5294)
@@ -6,10 +6,10 @@
 		MESSAGE(STATUS "*****************")
 
 		IF (X264)
-			FIND_HEADER_AND_LIB(X264 x264.h)
+			FIND_HEADER_AND_LIB(_X264 x264.h)
 
-			IF (X264_FOUND)
-				FILE(READ ${X264_INCLUDE_DIR}/x264.h X264_H)
+			IF (_X264_FOUND)
+				FILE(READ ${_X264_INCLUDE_DIR}/x264.h X264_H)
 				STRING(REGEX MATCH "#define[ ]+X264_BUILD[ ]+([0-9]+)" X264_H "${X264_H}")
 				STRING(REGEX REPLACE ".*[ ]([0-9]+).*" "\\1" x264_version "${X264_H}")
 				MESSAGE(STATUS "  core version: ${x264_version}")
@@ -18,11 +18,13 @@
 					MESSAGE("WARNING: x264 core version is too old.  At least version 54 is required.")
 					SET(X264_FOUND 0)
 				ELSEIF (x264_version GREATER 73)
-					FIND_HEADER_AND_LIB(X264 "" x264 x264_encoder_open_${x264_version})
+					FIND_HEADER_AND_LIB(X264 x264.h x264 x264_encoder_open_${x264_version})
 				ELSE (x264_version LESS 54)
-					FIND_HEADER_AND_LIB(X264 "" x264 x264_encoder_open)
+					FIND_HEADER_AND_LIB(X264 x264.h x264 x264_encoder_open)
 				ENDIF (x264_version LESS 54)
-			ENDIF (X264_FOUND)
+			ELSE (_X264_FOUND)
+				SET(X264_FOUND 0)
+			ENDIF (_X264_FOUND)
 
 			PRINT_LIBRARY_INFO("x264" X264_FOUND "${X264_INCLUDE_DIR}" "${X264_LIBRARY_DIR}")
 		ELSE (X264)



From mean at mail.berlios.de  Thu Sep  3 09:48:24 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 3 Sep 2009 09:48:24 +0200
Subject: [Avidemux-svn-commit] r5295 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter
Message-ID: <200909030748.n837mOlV003864@sheep.berlios.de>

Author: mean
Date: 2009-09-03 09:48:23 +0200 (Thu, 03 Sep 2009)
New Revision: 5295

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audio_encoderPlugin.cpp
Log:
[FLV] inverted check in audioEncoder, made flv output crash

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audio_encoderPlugin.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audio_encoderPlugin.cpp	2009-09-02 22:23:57 UTC (rev 5294)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audio_encoderPlugin.cpp	2009-09-03 07:48:23 UTC (rev 5295)
@@ -281,7 +281,7 @@
  */
 uint32_t audioFilter_getOuputCodec(void)
 {
-	ADM_assert(!currentEncoder);
+    ADM_assert(currentEncoder);
     return ListOfAudioEncoder[currentEncoder]->wavTag;
 }
 



From mean at mail.berlios.de  Thu Sep  3 15:51:56 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 3 Sep 2009 15:51:56 +0200
Subject: [Avidemux-svn-commit] r5296 - in
	branches/avidemux_2.6_branch_mean/avidemux_core:
	ADM_coreVideoEncoder/src ADM_coreVideoFilter/include
Message-ID: <200909031351.n83DpuMl009374@sheep.berlios.de>

Author: mean
Date: 2009-09-03 15:51:55 +0200 (Thu, 03 Sep 2009)
New Revision: 5296

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/ADM_coreVideoEncoderFFmpeg.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_coreVideoFilter.h
Log:
[Encoder/ffmpeg] dont put timestamp in codec, it might override the one from demuxer

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/ADM_coreVideoEncoderFFmpeg.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/ADM_coreVideoEncoderFFmpeg.cpp	2009-09-03 07:48:23 UTC (rev 5295)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/ADM_coreVideoEncoderFFmpeg.cpp	2009-09-03 13:51:55 UTC (rev 5296)
@@ -206,6 +206,9 @@
         return false;
     }
     prolog();
+#if 1
+    _frame.pts=AV_NOPTS_VALUE;
+#else
     // put a time stamp...
     if(image->Pts==ADM_NO_PTS) 
     {
@@ -225,6 +228,7 @@
 
         //printf("*** PTS:%d time_base :%d/%d\n",_frame.pts,_context->time_base.num,_context->time_base.den);
     }
+#endif
     //
     //printf("[PTS] :%"LU" num:%"LU" den:%"LU"\n",_frame.pts,_context->time_base.num,_context->time_base.den);
     //

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_coreVideoFilter.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_coreVideoFilter.h	2009-09-03 07:48:23 UTC (rev 5295)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_coreVideoFilter.h	2009-09-03 13:51:55 UTC (rev 5296)
@@ -40,11 +40,11 @@
             ADM_coreVideoFilter(ADM_coreVideoFilter *previous,CONFcouple *conf=NULL);
             ~ADM_coreVideoFilter();
 
-       virtual const char   *getConfiguration(void);                    /// Return  current configuration as a human readable string
-       virtual bool         getNextFrame(ADMImage *image)=0;    /// Return the next image
-	   virtual FilterInfo  *getInfo(void);                                      /// Return picture parameters after this filter
-	   virtual bool         getCoupledConf(CONFcouple **couples)=0 ; /// Return the current filter configuration
-
+       virtual const char   *getConfiguration(void);                   /// Return  current configuration as a human readable string
+       virtual bool         getNextFrame(ADMImage *image)=0;           /// Return the next image
+	   virtual FilterInfo  *getInfo(void);                             /// Return picture parameters after this filter
+	   virtual bool         getCoupledConf(CONFcouple **couples)=0 ;   /// Return the current filter configuration
+       virtual bool         configure(void) {return true;}             /// Start graphical user interface
 protected:
             ADM_coreVideoFilter *previousFilter;
 };



From mean at mail.berlios.de  Thu Sep  3 15:51:58 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 3 Sep 2009 15:51:58 +0200
Subject: [Avidemux-svn-commit] r5297 - in
	branches/avidemux_2.6_branch_mean/avidemux/common: . ADM_editor
Message-ID: <200909031351.n83Dpw20009384@sheep.berlios.de>

Author: mean
Date: 2009-09-03 15:51:57 +0200 (Thu, 03 Sep 2009)
New Revision: 5297

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edCache.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edCache.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.h
   branches/avidemux_2.6_branch_mean/avidemux/common/gui_navigate.cpp
Log:
[Editor] Partial implementation of previous frame

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edCache.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edCache.cpp	2009-09-03 13:51:55 UTC (rev 5296)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edCache.cpp	2009-09-03 13:51:57 UTC (rev 5297)
@@ -230,3 +230,28 @@
     }
     return NULL;
 }
+/**
+        \fn findLastBefore
+        \brief Search the cache for the image just before pts
+*/
+ADMImage    *EditorCache::findLastBefore(uint64_t pts)
+{
+  uint64_t delta=1<<31; // should be enough
+  int index=-1;
+  for(int i=0;i<_nbImage;i++)
+	{
+        cacheElem *elem=&(_elem[i]);
+		if(elem->frameNum==ADM_INVALID_CACHE) continue;
+		if(elem->image->Pts>=pts)  continue;
+        uint64_t d=abs(pts-elem->image->Pts);
+        if(d<delta)
+        {
+            delta=d;
+            index=i;
+        }
+    }
+    if(index==-1)
+        return NULL;
+    return _elem[index].image;
+}
+// EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edCache.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edCache.h	2009-09-03 13:51:55 UTC (rev 5296)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edCache.h	2009-09-03 13:51:57 UTC (rev 5297)
@@ -37,6 +37,8 @@
             void        flush(void);
             void        invalidate(ADMImage *image);
             ADMImage    *findJustAfter(uint64_t pts);
+            ADMImage    *findLastBefore(uint64_t pts);
             ADMImage    *getByPts(uint64_t Pts);
+            
 };
 #endif

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp	2009-09-03 13:51:55 UTC (rev 5296)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp	2009-09-03 13:51:57 UTC (rev 5297)
@@ -1327,4 +1327,21 @@
     }
     return nb-1;
 }
+/**
+    \fn getImageFromCacheForFrameBefore
+    \brief Search the cache for the image with PTS just before the input PTS
+*/
+bool    ADM_Composer::getImageFromCacheForFrameBefore(uint64_t pts,ADMImage *out)
+{
+    int ref=0;
+    EditorCache   *cache;
+	_VIDEOS *vid=&_videos[ref];
+	cache=_videos[ref]._videoCache;
+	ADM_assert(cache);
+        ADMImage *r=cache->findLastBefore(pts);
+        if(!r) return false;
+        out->duplicateFull(r);
+        return true;
+
+}
 //EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx	2009-09-03 13:51:55 UTC (rev 5296)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx	2009-09-03 13:51:57 UTC (rev 5297)
@@ -232,6 +232,7 @@
                         uint32_t    currentFrame;
 public:
                         uint32_t    getCurrentFrame(void);
+                        
                         bool        setCurrentFrame(uint32_t frame);
                         bool        GoToIntra(uint32_t frame);
                         bool        GoToTime(uint64_t time);
@@ -240,6 +241,8 @@
                         bool        getCompressedPicure(uint32_t framenum,ADMCompressedImage *img);
                         uint64_t    estimatePts(uint32_t frame);
                         uint32_t    searchFrameBefore(uint64_t pts);
+                        bool        getImageFromCacheForFrameBefore(uint64_t pts,ADMImage *out);
+                        bool        getPictureJustBefore(uint64_t pts);
 /************************************ Internal ******************************/
 public:
                                     /// Decode frame and on until frame is popped out of decoders

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.cpp	2009-09-03 13:51:55 UTC (rev 5296)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.cpp	2009-09-03 13:51:57 UTC (rev 5297)
@@ -641,5 +641,49 @@
     video_body->setCurrentFrame(frame);
     samePicture();
     return true;
+}/**
+    \fn previousFrame
+
+*/
+bool admPreview::previousFrame(void)
+{
+    uint64_t pts=rdrImage->Pts;
+    uint32_t frame=video_body->getCurrentFrame();
+    if(!frame) return false;
+    // If the frame is not an intra, the previous one
+    // is still in the cache
+    if(rdrImage->flags!=AVI_KEY_FRAME)
+    {
+        
+        if(true==video_body->getImageFromCacheForFrameBefore(pts,rdrImage))
+        {
+            renderUpdateImage(rdrImage->data,zoom);
+            return true;
+        }
+        return false;
+    }
+
+    // Else go to the previous  keyframe...
+    if(!video_body->getPKFrame(&frame)) return false;
+    if(!video_body->GoToIntra(frame)) return false;
+    // Now forward until we reach our frame
+    if(!video_body->samePicture(rdrImage)) return false;
+    if(rdrImage->Pts==pts) 
+    {
+            renderUpdateImage(rdrImage->data,zoom);
+            return true;
+    }
+    while(1)
+    {
+        if(!video_body->NextPicture(rdrImage)) return false;
+        if(rdrImage->Pts==pts) break;
+    }
+    if(rdrImage->Pts!=pts) return false;
+    if(true==video_body->getImageFromCacheForFrameBefore(pts,rdrImage))
+    {
+        renderUpdateImage(rdrImage->data,zoom);
+        return true;
+    }
+    return false;
 }
 // EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.h	2009-09-03 13:51:55 UTC (rev 5296)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.h	2009-09-03 13:51:57 UTC (rev 5297)
@@ -36,5 +36,6 @@
       static uint64_t getCurrentPts(void);
       static bool nextKeyFrame(void);
       static bool previousKeyFrame(void);
+      static bool previousFrame(void);
 };
 #endif

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/gui_navigate.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/gui_navigate.cpp	2009-09-03 13:51:55 UTC (rev 5296)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/gui_navigate.cpp	2009-09-03 13:51:57 UTC (rev 5297)
@@ -95,17 +95,17 @@
 
       case ACT_PreviousKFrame:
         GUI_PreviousKeyFrame();
-	  break;
+        break;
       case ACT_PreviousFrame:
         GUI_PrevFrame();
-	  break;
+        break;
       case ACT_Forward100Frames:
         //GUI_GoToKFrame (curframe + (avifileinfo->fps1000 / 1000 * 4));
-	  break;
+        break;
 
       case ACT_Back100Frames:
         //GUI_GoToKFrame (curframe - (avifileinfo->fps1000 / 1000 * 4));
-	  break;
+        break;
 
 
       case ACT_Forward50Frames:
@@ -313,7 +313,17 @@
 */
 void GUI_PrevFrame(uint32_t frameCount)
 {
-    return;
+     if (playing)	    return;
+    if (!avifileinfo)	return;
+
+
+    if (!admPreview::previousFrame())
+      {
+            GUI_Error_HIG(QT_TR_NOOP("Error"),	QT_TR_NOOP("Cannot go to previous frame"));
+            return;
+      }
+    GUI_setCurrentFrameAndTime();
+    UI_purge();
 }
 /**
       \fn A_jogRead



From mean at mail.berlios.de  Thu Sep  3 15:52:01 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 3 Sep 2009 15:52:01 +0200
Subject: [Avidemux-svn-commit] r5298 - in
	branches/avidemux_2.6_branch_mean/avidemux_core: ADM_core/src
	ADM_coreImage/src
Message-ID: <200909031352.n83Dq1T2009397@sheep.berlios.de>

Author: mean
Date: 2009-09-03 15:52:00 +0200 (Thu, 03 Sep 2009)
New Revision: 5298

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/ADM_memsupport.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_image.cpp
Log:
[Memory] Cleanup memory usage (kb vs MB)

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/ADM_memsupport.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/ADM_memsupport.cpp	2009-09-03 13:51:57 UTC (rev 5297)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/ADM_memsupport.cpp	2009-09-03 13:52:00 UTC (rev 5298)
@@ -32,6 +32,7 @@
 #undef realloc
 
 static uint32_t ADM_consumed = 0;
+static uint32_t ADM_maxConsumed = 0;
 static admMutex memAccess("MemAccess");
 static int doMemStat = 0;
 
@@ -68,6 +69,8 @@
 {
 	printf("Global mem stat\n______________\n");
 	printf("\tMemory consumed: %"LU" (MB)\n", ADM_consumed >> 20);
+    printf("\tMax consumed   : %"LU" (MB)\n", ADM_maxConsumed >> 20);
+
 }
 
 #if !defined(ADM_DEBUG) || !defined(FIND_LEAKS)
@@ -109,11 +112,14 @@
 	backdoor = (uint32_t*)(c - 8);
 	*backdoor = (0xdead << 16) + l - lorg;
 	backdoor[1] = size;
+    
+    ADM_consumed += size;
+    if(ADM_consumed>ADM_maxConsumed) ADM_maxConsumed=ADM_consumed;
 
-	if(dome)
+    if(dome)
 		memAccess.unlock();
 
-	ADM_consumed += size;
+	
 
 	return c;
 #endif

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_image.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_image.cpp	2009-09-03 13:51:57 UTC (rev 5297)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_image.cpp	2009-09-03 13:52:00 UTC (rev 5298)
@@ -28,8 +28,8 @@
 {
 	printf("\nImages stat:\n");
 	printf("___________\n");
-	printf("Max memory consumed (MB)     : %"LU"\n",imgMaxMem>>10);
-	printf("Current memory consumed (MB) : %"LU"\n",imgCurMem>>10);
+	printf("Max memory consumed (MB)     : %"LU"\n",imgMaxMem>>20);
+	printf("Current memory consumed (MB) : %"LU"\n",imgCurMem>>20);
 	printf("Max image used               : %"LU"\n",imgMaxNb);
 	printf("Cur image used               : %"LU"\n",imgCurNb);
 
@@ -79,13 +79,13 @@
 //
 ADMImage::~ADMImage()
 {
-        if(!_isRef)
-        {
-	       if(quant) delete [] quant;
-	       quant=NULL;
-	       if(data) delete [] data;
-	       data=NULL;
-               imgCurMem-=(_width*_height*3)>>1;
+    if(!_isRef)
+    {
+       if(quant) delete [] quant;
+       quant=NULL;
+       if(data) delete [] data;
+       data=NULL;
+       imgCurMem-=(_width*_height*3)>>1;
 	}
 	imgCurNb--;
 



From mean at mail.berlios.de  Thu Sep  3 15:52:02 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 3 Sep 2009 15:52:02 +0200
Subject: [Avidemux-svn-commit] r5299 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/OpenDml
Message-ID: <200909031352.n83Dq25L009410@sheep.berlios.de>

Author: mean
Date: 2009-09-03 15:52:02 +0200 (Thu, 03 Sep 2009)
New Revision: 5299

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/OpenDml/ADM_openDML.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/OpenDml/ADM_openDML.h
Log:
[Avi/demuxer] Remove empty frames

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/OpenDml/ADM_openDML.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/OpenDml/ADM_openDML.cpp	2009-09-03 13:52:00 UTC (rev 5298)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/OpenDml/ADM_openDML.cpp	2009-09-03 13:52:02 UTC (rev 5299)
@@ -132,7 +132,8 @@
 */
 uint64_t  OpenDMLHeader::getVideoDuration(void)
 {
-    return frameToUs(_videostream.dwLength); 
+    if(!_videostream.dwLength) return 0;
+    return _idx[_videostream.dwLength-1].dts; 
 }
 
 OpenDMLHeader::~OpenDMLHeader()
@@ -521,10 +522,44 @@
                 else
                 _videostream.fccHandler=_video_bih.biCompression;
                 printf("\nOpenDML file successfully read..\n");
-                if(ret==1) computePtsDts();
+                if(ret==1) 
+                {
+                    computePtsDts();
+                    removeEmptyFrames();
+                }
                 return ret;
 }
 /**
+    \fn removeEmptyFrames
+    \brief Remove the null padding frames, they are not needed and indeed harmful
+*/
+bool OpenDMLHeader::removeEmptyFrames(void)
+{
+    
+    odmlIndex *nwIdx=new odmlIndex[_videostream.dwLength];
+    int index=0;
+    for(int i=0;i<_videostream.dwLength;i++)
+    {
+        if(_idx[i].size)
+        {
+            nwIdx[index++]=_idx[i];
+        }
+    }
+    if(index==_videostream.dwLength)
+    {
+        delete [] nwIdx;
+        printf("[openDml] No empty frames\n");
+        return true;
+    }
+    int delta=_videostream.dwLength-index;
+
+    printf("[openDml] Removed %d empty frames\n",(int)delta);
+    _mainaviheader.dwTotalFrames=_videostream.dwLength=index;
+    delete [] _idx;
+    _idx=nwIdx;
+    return true;
+}
+/**
     \fn computePtsDts
     \brief Compute PtsDts
 */

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/OpenDml/ADM_openDML.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/OpenDml/ADM_openDML.h	2009-09-03 13:52:00 UTC (rev 5298)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/OpenDml/ADM_openDML.h	2009-09-03 13:52:02 UTC (rev 5299)
@@ -120,7 +120,8 @@
 
 	  uint8_t           computePtsDts(void);
       uint8_t           mpegReorder(void);
-	  uint8_t			unpackPacked( void );	  	
+	  uint8_t			unpackPacked( void );	
+      bool              removeEmptyFrames (void);
 public:
 	  
 virtual   void 				Dump(void) ;



From mean at mail.berlios.de  Thu Sep  3 15:52:04 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 3 Sep 2009 15:52:04 +0200
Subject: [Avidemux-svn-commit] r5300 - in
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate:
	include src
Message-ID: <200909031352.n83Dq4id009421@sheep.berlios.de>

Author: mean
Date: 2009-09-03 15:52:03 +0200 (Thu, 03 Sep 2009)
New Revision: 5300

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/include/ADM_videoCopy.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoCopy.cpp
Log:
[videoCopy] Pts might be available in copy mode, incomplete

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/include/ADM_videoCopy.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/include/ADM_videoCopy.h	2009-09-03 13:52:02 UTC (rev 5299)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/include/ADM_videoCopy.h	2009-09-03 13:52:03 UTC (rev 5300)
@@ -25,7 +25,7 @@
 virtual     bool     getPacket(uint32_t *len, uint8_t *data, uint32_t maxLen,uint64_t *pts,uint64_t *dts,
                                     uint32_t *flags);
 virtual     bool     getExtraData(uint32_t *extraLen, uint8_t **extraData) ;
-virtual     bool     providePts(void) {return false;}
+virtual     bool     providePts(void);
 virtual     uint64_t getVideoDuration(void);
 };
 

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoCopy.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoCopy.cpp	2009-09-03 13:52:02 UTC (rev 5299)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoCopy.cpp	2009-09-03 13:52:03 UTC (rev 5300)
@@ -106,4 +106,10 @@
     return video_body->getVideoDuration();
 
 }
-     
+/**
+
+*/
+bool     ADM_videoStreamCopy::providePts(void)
+{
+    return true;
+}



From mean at mail.berlios.de  Thu Sep  3 15:52:07 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 3 Sep 2009 15:52:07 +0200
Subject: [Avidemux-svn-commit] r5301 - in branches/avidemux_2.6_branch_mean:
	avidemux_core/ADM_coreMuxer/include avidemux_core/ADM_coreMuxer/src
	avidemux_plugins/ADM_muxers/muxerMp4
Message-ID: <200909031352.n83Dq7cI009434@sheep.berlios.de>

Author: mean
Date: 2009-09-03 15:52:05 +0200 (Thu, 03 Sep 2009)
New Revision: 5301

Added:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/include/ADM_coreMuxerFfmpeg.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_coreMuxerFfmpeg.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4/muxerMP4.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4/muxerMP4.h
Log:
[Muxer] Factorize FFmpeg based muxer code

Copied: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/include/ADM_coreMuxerFfmpeg.h (from rev 5300, branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4/muxerMP4.h)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4/muxerMP4.h	2009-09-03 13:52:03 UTC (rev 5300)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/include/ADM_coreMuxerFfmpeg.h	2009-09-03 13:52:05 UTC (rev 5301)
@@ -0,0 +1,51 @@
+/***************************************************************************
+            \file            ADM_coreMuxerFfmpeg.h
+            \brief           Base class for ffmpeg based muxers
+                             -------------------
+    
+    copyright            : (C) 2009 by mean
+    email                : fixounet at free.fr
+        
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef ADM_COREMUXERFFMPEG_H
+#define ADM_COREMUXERFFMPEG_H
+#include "ADM_default.h"
+#include "fourcc.h"
+#include "ADM_muxer.h"
+#include "ADM_lavcodec.h"
+extern "C"
+{
+    #include "libavformat/avformat.h"
+};
+/**
+    \class muxerFFmpeg
+*/
+class muxerFFmpeg : public ADM_muxer
+{
+protected:
+        AVOutputFormat *fmt;
+        AVFormatContext *oc;
+        AVStream *audio_st;
+        AVStream *video_st;
+        double audio_pts, video_pts;
+
+        bool closeMuxer(void);
+        bool setupMuxer(const char *format,const char *filename);
+        bool initVideo(ADM_videoStream *stream);
+        bool initAudio(uint32_t nbAudioTrack,ADM_audioStream **audio);
+public:
+                muxerFFmpeg();
+        virtual ~muxerFFmpeg();
+
+};
+
+#endif
\ No newline at end of file

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_coreMuxerFfmpeg.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_coreMuxerFfmpeg.cpp	2009-09-03 13:52:03 UTC (rev 5300)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_coreMuxerFfmpeg.cpp	2009-09-03 13:52:05 UTC (rev 5301)
@@ -0,0 +1,197 @@
+/***************************************************************************
+            \file            muxerFFmpeg
+            \brief           Base class for ffmpeg based muxer
+                             -------------------
+    
+    copyright            : (C) 2009 by mean
+    email                : fixounet at free.fr
+        
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "ADM_default.h"
+#include "fourcc.h"
+#include "ADM_coreMuxerFfmpeg.h"
+#include "ADM_muxerUtils.h"
+/**
+    \fn muxerFFmpeg
+*/
+muxerFFmpeg::muxerFFmpeg()
+{
+    fmt=NULL;
+    oc=NULL;
+    audio_st=NULL;
+    video_st=NULL;
+}
+/**
+    \fn closeMuxer
+*/
+bool muxerFFmpeg::closeMuxer()
+{
+    if(oc)
+    {
+        av_write_trailer(oc);
+        url_fclose((oc->pb));
+    }
+    if(audio_st)
+    {
+         av_free(audio_st);
+    }
+    if(video_st)
+    {
+         av_free(video_st);
+    }
+    video_st=NULL;
+    audio_st=NULL;
+    if(oc)
+        av_free(oc);
+    oc=NULL;
+    return true;
+}
+/**
+    \fn muxerFFmpeg
+*/
+muxerFFmpeg::~muxerFFmpeg()
+{
+        closeMuxer();
+}
+/**
+    \fn setupMuxer
+    \brief open and do the base muxer setup
+*/
+bool muxerFFmpeg::setupMuxer(const char *format,const char *filename)
+{
+    fmt=guess_format(format, NULL, NULL);
+    if(!fmt)
+    {
+            printf("[FF] guess format failed\n");
+            return false;
+    }
+    oc = avformat_alloc_context();
+	if (!oc)
+	{
+       		printf("[FF] alloc format context failed\n");
+            return false;
+	}
+	oc->oformat = fmt;
+	snprintf(oc->filename,1000,"file://%s",filename);
+    // probably a memeleak here
+    char *foo=ADM_strdup(filename);
+    
+    strcpy(oc->title,ADM_GetFileName(foo));
+    strcpy(oc->author,"Avidemux");
+    printf("[FF] Muxer opened\n");
+    return true;
+}
+/**
+    \fn initVideo
+    \brief setup video part of muxer
+*/
+bool muxerFFmpeg::initVideo(ADM_videoStream *stream)
+{
+    video_st = av_new_stream(oc, 0);
+	if (!video_st)
+	{
+		printf("[FF] new stream failed\n");
+		return false;
+	}
+    AVCodecContext *c;
+        c = video_st->codec;
+        c->sample_aspect_ratio.num=1;
+        c->sample_aspect_ratio.den=1;
+        video_st->sample_aspect_ratio=c->sample_aspect_ratio;
+
+        uint32_t videoExtraDataSize=0;
+        uint8_t  *videoExtraData;
+        stream->getExtraData(&videoExtraDataSize,&videoExtraData);
+        printf("[FF] Using %d bytes for video extradata\n",(int)videoExtraDataSize);
+        if(videoExtraDataSize)
+        {
+                c->extradata=videoExtraData;
+                c->extradata_size= videoExtraDataSize;
+        }
+        
+        c->rc_buffer_size=8*1024*224;
+        c->rc_max_rate=9500*1000;
+        c->rc_min_rate=0;
+        c->bit_rate=9000*1000;
+        c->codec_type = CODEC_TYPE_VIDEO;
+        c->flags=CODEC_FLAG_QSCALE;
+        c->width = stream->getWidth();
+        c->height =stream->getHeight();
+        printf("[FF] Video initialized\n");
+
+    return true;
+}
+/**
+    \fn initAudio
+    \brief setup the audio parts if present
+*/
+bool muxerFFmpeg::initAudio(uint32_t nbAudioTrack,ADM_audioStream **audio)
+{
+    if(!nbAudioTrack)
+    {
+        printf("[FF] No audio\n");
+        return true;
+    }
+#warning : only handle one audio track!
+    for(int i=0;i<1;i++)
+    {
+          uint32_t audioextraSize;
+          uint8_t  *audioextraData;
+          
+          audio[i]->getExtraData(&audioextraSize,&audioextraData);
+
+          audio_st = av_new_stream(oc, 1);
+          if (!audio_st)
+          {
+                  printf("[FF]: new stream failed (audio)\n");
+                  return false;
+          }
+          WAVHeader *audioheader=audio[i]->getInfo();;
+          AVCodecContext *c;
+          c = audio_st->codec;
+          c->frame_size=1024; //For AAC mainly, sample per frame
+          printf("[FF] Bitrate %u\n",(audioheader->byterate*8)/1000);
+          c->sample_rate = audioheader->frequency;
+          switch(audioheader->encoding)
+          {
+                  case WAV_AC3: c->codec_id = CODEC_ID_AC3;c->frame_size=6*256;break;
+                  case WAV_MP2: c->codec_id = CODEC_ID_MP2;break;
+                  case WAV_MP3:
+  #warning FIXME : Probe deeper
+                              c->frame_size=1152;
+                              c->codec_id = CODEC_ID_MP3;
+                              break;
+                  case WAV_PCM:
+                                  // One chunk is 10 ms (1/100 of fq)
+                                  c->frame_size=4;
+                                  c->codec_id = CODEC_ID_PCM_S16LE;break;
+                  case WAV_AAC:
+                                  c->extradata=audioextraData;
+                                  c->extradata_size= audioextraSize;
+                                  c->codec_id = CODEC_ID_AAC;
+                                  c->frame_size=1024;
+                                  break;
+                  default:
+                                 printf("[FF]: Unsupported audio\n");
+                                 return false; 
+                          break;
+          }
+          c->codec_type = CODEC_TYPE_AUDIO;
+          c->bit_rate = audioheader->byterate*8;
+          c->rc_buffer_size=(c->bit_rate/(2*8)); // 500 ms worth
+          c->channels = audioheader->channels;
+
+        }
+        printf("[FF] Audio initialized\n");
+        return true;
+}
+// EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/CMakeLists.txt	2009-09-03 13:52:03 UTC (rev 5300)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/CMakeLists.txt	2009-09-03 13:52:05 UTC (rev 5301)
@@ -3,6 +3,7 @@
 ADM_dynaMuxer.cpp
 ADM_muxerUtils.cpp
 ADM_audioClock.cpp
+ADM_coreMuxerFfmpeg.cpp
 )	
 #*************************************************
 ADD_LIBRARY(ADM_coreMuxer6 SHARED ${ADMcoreMuxer_SRCS})

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4/muxerMP4.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4/muxerMP4.cpp	2009-09-03 13:52:03 UTC (rev 5300)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4/muxerMP4.cpp	2009-09-03 13:52:05 UTC (rev 5301)
@@ -32,7 +32,7 @@
 static    AVStream *video_st;
 static    double audio_pts, video_pts;
 
-#if 1
+#if 0
 #define aprintf(...) {}
 #else
 #define aprintf printf
@@ -59,26 +59,7 @@
 
 muxerMP4::~muxerMP4() 
 {
-    printf("[MP4] Destructing\n");
-    if(oc)
-    {
-        av_write_trailer(oc);
-		url_fclose((oc->pb));
-	}
-	if(audio_st)
-	{
-		 av_free(audio_st);
-	}
-	if(video_st)
-	{
-		 av_free(video_st);
-	}
-	video_st=NULL;
-	audio_st=NULL;
-	if(oc)
-		av_free(oc);
-	oc=NULL;
-
+   
 }
 /**
     \fn open
@@ -93,7 +74,6 @@
             return false;
     }
     if(nbAudioTrack)
-    {
         for(int i=0;i<nbAudioTrack;i++)
         {
             uint32_t acc=a[i]->getInfo()->encoding;
@@ -102,48 +82,23 @@
                 GUI_Error_HIG("Unsupported","Only AAC & mpegaudio supported for audio");
                 return false;
             }
-
         }
-
-    }
     /* All seems fine, open stuff */
     const char *f="mp4";
     if(muxerConfig.muxerType==MP4_MUXER_PSP) f="psp";
-    fmt=guess_format(f, NULL, NULL);
-    if(!fmt)
+    if(false==setupMuxer(f,file))
     {
-            printf("[Mp4] guess format failed\n");
-            return false;
+        printf("[MP4] Failed to open muxer\n");
+        return false;
     }
-    oc = av_alloc_format_context();
-	if (!oc)
-	{
-       		printf("[Mp4] alloc format context failed\n");
-            return false;
-	}
-	oc->oformat = fmt;
-	snprintf(oc->filename,1000,"file://%s",file);
-// *******************************************
-// *******************************************
-//                  VIDEO
-// *******************************************
-// *******************************************
-    video_st = av_new_stream(oc, 0);
-	if (!video_st)
-	{
-		printf("[Mp4] new stream failed\n");
-		return false;
-	}
-    AVCodecContext *c;
-	c = video_st->codec;
-    
-  // probably a memeleak here
-        char *foo=ADM_strdup(file);
-        
-        strcpy(oc->title,ADM_GetFileName(foo));
-        strcpy(oc->author,"Avidemux");
-        c->sample_aspect_ratio.num=1;
-        c->sample_aspect_ratio.den=1;
+ 
+   if(initVideo(s)==false) 
+    {
+        printf("[MP4] Failed to init video\n");
+        return false;
+    }
+   AVCodecContext *c;
+        c = video_st->codec;
         if(isMpeg4Compatible(s->getFCC()))
         {
                 c->codec_id = CODEC_ID_MPEG4;
@@ -191,87 +146,17 @@
                         }
                 }
         }
-        uint32_t videoExtraDataSize=0;
-        uint8_t  *videoExtraData;
-        s->getExtraData(&videoExtraDataSize,&videoExtraData);
-        if(videoExtraDataSize)
-        {
-                c->extradata=videoExtraData;
-                c->extradata_size= videoExtraDataSize;
-        }
-        
-        c->rc_buffer_size=8*1024*224;
-        c->rc_max_rate=9500*1000;
-        c->rc_min_rate=0;
-//        if(!inbitrate)
-                c->bit_rate=9000*1000;
-        //else
-          //      c->bit_rate=inbitrate;
-        c->codec_type = CODEC_TYPE_VIDEO;
-        c->flags=CODEC_FLAG_QSCALE;
-        c->width = s->getWidth();
-        c->height =s->getHeight();
+    
 
         rescaleFps(s->getAvgFps1000(),&(c->time_base));
         c->gop_size=15;
         
-        
-
-// *******************************************
-// *******************************************
-//                  AUDIO
-// *******************************************
-// *******************************************
-        if(nbAudioTrack)
+        if(initAudio(nbAudioTrack,a)==false)
         {
-          uint32_t audioextraSize;
-          uint8_t  *audioextraData;
-          
-          a[0]->getExtraData(&audioextraSize,&audioextraData);
-
-          audio_st = av_new_stream(oc, 1);
-          if (!audio_st)
-          {
-                  printf("[MP4]: new stream failed (audio)\n");
-                  return false;
-          }
-          WAVHeader *audioheader=a[0]->getInfo();;
-
-          c = audio_st->codec;
-          c->frame_size=1024; //For AAC mainly, sample per frame
-          printf("[MP4] Bitrate %u\n",(audioheader->byterate*8)/1000);
-          c->sample_rate = audioheader->frequency;
-          switch(audioheader->encoding)
-          {
-                  case WAV_AC3: c->codec_id = CODEC_ID_AC3;c->frame_size=6*256;break;
-                  case WAV_MP2: c->codec_id = CODEC_ID_MP2;break;
-                  case WAV_MP3:
-  #warning FIXME : Probe deeper
-                              c->frame_size=1152;
-                              c->codec_id = CODEC_ID_MP3;
-                              break;
-                  case WAV_PCM:
-                                  // One chunk is 10 ms (1/100 of fq)
-                                  c->frame_size=4;
-                                  c->codec_id = CODEC_ID_PCM_S16LE;break;
-                  case WAV_AAC:
-                                  c->extradata=audioextraData;
-                                  c->extradata_size= audioextraSize;
-                                  c->codec_id = CODEC_ID_AAC;
-                                  break;
-                  default:
-                                 printf("[MP4]: Unsupported audio\n");
-                                 return false; 
-                          break;
-          }
-          c->codec_type = CODEC_TYPE_AUDIO;
-
-          c->bit_rate = audioheader->byterate*8;
-          c->rc_buffer_size=(c->bit_rate/(2*8)); // 500 ms worth
-
-          c->channels = audioheader->channels;
-
+            printf("[MP4] Failed to init audio\n");
+            return false;
         }
+        
         // /audio
         oc->mux_rate=10080*1000;
         oc->preload=AV_TIME_BASE/10; // 100 ms preloading
@@ -322,7 +207,7 @@
     AVRational *scale=&(video_st->codec->time_base);
     uint64_t videoDuration=vStream->getVideoDuration();
 
-    char *title=QT_TR_NOOP("Saving mp4");
+    const char *title=QT_TR_NOOP("Saving mp4");
     if(muxerConfig.muxerType==MP4_MUXER_PSP) title=QT_TR_NOOP("Saving PSP");
     encoding=createWorking(title);
 
@@ -340,9 +225,14 @@
                 result=false;
                 break;
             }
+            int64_t xpts=(int64_t)pts;
+            int64_t xdts=(int64_t)dts;
+            if(pts==ADM_NO_PTS) xpts=-1;
+            if(dts==ADM_NO_PTS) xdts=-1;
+            aprintf("[MP4:V] Pts: %"LLD" DTS:%"LLD" ms\n",xpts/1000,xdts/1000);
 
-
-            aprintf("[MP5] LastDts:%08lu Dts:%08lu (%04.4lu) Delta : %u\n",lastVideoDts,dts,dts/1000000,dts-lastVideoDts);
+            aprintf("[MP4:V] LastDts:%08"LLU" Dts:%08"LLU" (%04"LLU") Delta : %"LLU"\n",
+                        lastVideoDts,dts,dts/1000000,dts-lastVideoDts);
             rawDts=dts;
             if(rawDts==ADM_NO_PTS)
             {
@@ -353,8 +243,8 @@
             }
             pts=rescaleLavPts(pts,scale);
             dts=rescaleLavPts(dts,scale);
-            aprintf("[MP4] RawDts:%lu Scaled Dts:%lu\n",rawDts,dts);
-            aprintf("[MP4] Rescaled: Len : %d flags:%x Pts:%llu Dts:%llu\n",len,flags,pts,dts);
+            aprintf("[MP4:V] RawDts:%lu Scaled Dts:%lu\n",rawDts,dts);
+            aprintf("[MP4:V] Rescaled: Len : %d flags:%x Pts:%"LLU" Dts:%"LLU"\n",len,flags,pts,dts);
 
             av_init_packet(&pkt);
             pkt.dts=dts;
@@ -397,7 +287,8 @@
                    
                     
                     uint64_t rescaledDts=(uint64_t)(f+0.4);
-                    aprintf("[MP4] Video frame  %d, audio Dts :%lu size :%lu nbSample : %lu rescaled:%lu\n",written,audioDts,audioSize,nbSample,rescaledDts);
+                    aprintf("[MP4] A: Video frame  %d, audio Dts :%"LLU" size :%"LU" nbSample : %"LU" rescaled:%"LLU"\n",
+                                    written,audioDts,audioSize,nbSample,rescaledDts);
                     av_init_packet(&pkt);
                     pkt.dts=rescaledDts;
                     pkt.pts=rescaledDts;
@@ -410,13 +301,13 @@
                         printf("[LavFormat]Error writing audio packet\n");
                         break;
                     }
-                    aprintf("%u vs %u\n",audioDts/1000,(lastVideoDts+videoIncrement)/1000);
+                    aprintf("[MP4] A:%"LU" ms vs V: %"LU" ms\n",(uint32_t)audioDts/1000,(uint32_t)(lastVideoDts+videoIncrement)/1000);
                     if(audioDts!=ADM_NO_PTS)
                     {
                         if(audioDts>lastVideoDts+videoIncrement) break;
                     }
                 }
-                if(!nb) printf("[MP4] No audio for video frame %d\n",written);
+                if(!nb) printf("[MP4] A: No audio for video frame %d\n",written);
             }
 
     }
@@ -431,26 +322,9 @@
 */
 bool muxerMP4::close(void) 
 {
-    if(oc)
-    {
-        av_write_trailer(oc);
-        url_fclose((oc->pb));
-        if(audio_st)
-        {
-             av_free(audio_st);
-        }
-        if(video_st)
-        {
-             av_free(video_st);
-        }
-        video_st=NULL;
-        audio_st=NULL;
-        if(oc)
-            av_free(oc);
-        oc=NULL;
-    }
+   
     printf("[MP4] Closing\n");
-    return true;
+    return closeMuxer();
 }
 
 //EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4/muxerMP4.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4/muxerMP4.h	2009-09-03 13:52:03 UTC (rev 5300)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4/muxerMP4.h	2009-09-03 13:52:05 UTC (rev 5301)
@@ -18,7 +18,7 @@
 #define ADM_MUXER_MP4
 
 #include "ADM_muxer.h"
-
+#include "ADM_coreMuxerFfmpeg.h"
 typedef enum
 {
     MP4_MUXER_MP4,
@@ -33,7 +33,7 @@
 
 extern M4MUXERCONFIG muxerConfig;
 
-class muxerMP4 : public ADM_muxer
+class muxerMP4 : public muxerFFmpeg
 {
 protected:
 



From mean at mail.berlios.de  Thu Sep  3 15:52:09 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 3 Sep 2009 15:52:09 +0200
Subject: [Avidemux-svn-commit] r5302 - in branches/avidemux_2.6_branch_mean:
	avidemux_core/ADM_coreMuxer/src avidemux_plugins/ADM_muxers/muxerFlv
	avidemux_plugins/ADM_muxers/muxerMp4
Message-ID: <200909031352.n83Dq9Zw009445@sheep.berlios.de>

Author: mean
Date: 2009-09-03 15:52:09 +0200 (Thu, 03 Sep 2009)
New Revision: 5302

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_coreMuxerFfmpeg.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerFlv/muxerFlv.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerFlv/muxerFlv.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4/muxerMP4.cpp
Log:
[Muxer/Flv] Use the factorized code for FLV muxer

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_coreMuxerFfmpeg.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_coreMuxerFfmpeg.cpp	2009-09-03 13:52:05 UTC (rev 5301)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_coreMuxerFfmpeg.cpp	2009-09-03 13:52:09 UTC (rev 5302)
@@ -126,6 +126,77 @@
         c->flags=CODEC_FLAG_QSCALE;
         c->width = stream->getWidth();
         c->height =stream->getHeight();
+
+        if(isMpeg4Compatible(stream->getFCC()))
+        {
+                c->codec_id = CODEC_ID_MPEG4;
+                if(stream->providePts()==true)
+                {
+                    c->has_b_frames=1; // in doubt...
+                    c->max_b_frames=2;
+                }else   
+                {
+                    c->has_b_frames=0; // No PTS=cannot handle CTS...
+                    c->max_b_frames=0;
+                }
+        }else
+        {
+                if(isH264Compatible(stream->getFCC()))
+                {
+                        if(stream->providePts()==true)
+                        {
+                            c->has_b_frames=1; // in doubt...
+                            c->max_b_frames=2;
+                        }else
+                        {
+                            printf("[MP4] Source video has no PTS information, assuming no b frames\n");
+                            c->has_b_frames=0; // No PTS=cannot handle CTS...
+                            c->max_b_frames=0;
+                        }
+                        c->codec_id = CODEC_ID_H264;
+                        c->codec=new AVCodec;
+                        memset(c->codec,0,sizeof(AVCodec));
+                        c->codec->name=ADM_strdup("H264");
+                }
+                else
+                {
+                        if(isDVCompatible(stream->getFCC()))
+                        {
+                          c->codec_id = CODEC_ID_DVVIDEO;
+                        }else
+                        {
+                          if(fourCC::check(stream->getFCC(),(uint8_t *)"H263"))
+                          {
+                                    c->codec_id=CODEC_ID_H263;
+                            }else
+
+                           if(isVP6Compatible(stream->getFCC()))
+                                {
+                                         c->codec=new AVCodec;
+                                         c->codec_id=CODEC_ID_VP6F;
+                                         c->codec->name=ADM_strdup("VP6F");
+                                         c->has_b_frames=0; // No PTS=cannot handle CTS...
+                                         c->max_b_frames=0;
+                                }else
+                                        if(fourCC::check(stream->getFCC(),(uint8_t *)"FLV1"))
+                                        {
+                                                c->has_b_frames=0; // No PTS=cannot handle CTS...
+                                                c->max_b_frames=0;
+                                                c->codec_id=CODEC_ID_FLV1;
+
+                                                c->codec=new AVCodec;
+                                                memset(c->codec,0,sizeof(AVCodec));
+                                                c->codec->name=ADM_strdup("FLV1");
+                                        }else
+                                        {
+                                            printf("[FF] Unknown video codec\n");
+                                            return false;
+                                        }
+                        }
+                }
+        }
+
+
         printf("[FF] Video initialized\n");
 
     return true;

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerFlv/muxerFlv.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerFlv/muxerFlv.cpp	2009-09-03 13:52:05 UTC (rev 5301)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerFlv/muxerFlv.cpp	2009-09-03 13:52:09 UTC (rev 5302)
@@ -22,16 +22,6 @@
 #include "DIA_coreToolkit.h"
 #include "ADM_muxerUtils.h"
 
-
-
-
-
-static    AVOutputFormat *fmt=NULL;
-static    AVFormatContext *oc=NULL;
-static    AVStream *audio_st;
-static    AVStream *video_st;
-static    double audio_pts, video_pts;
-
 #if 1
 #define aprintf(...) {}
 #else
@@ -59,24 +49,7 @@
 muxerFlv::~muxerFlv()
 {
     printf("[FLV] Destructing\n");
-    if(oc)
-    {
-        av_write_trailer(oc);
-		url_fclose((oc->pb));
-	}
-	if(audio_st)
-	{
-		 av_free(audio_st);
-	}
-	if(video_st)
-	{
-		 av_free(video_st);
-	}
-	video_st=NULL;
-	audio_st=NULL;
-	if(oc)
-		av_free(oc);
-	oc=NULL;
+    closeMuxer();
 
 }
 /**
@@ -88,8 +61,6 @@
 {
     uint32_t fcc=s->getFCC();
     bool r=true;
-    uint32_t videoExtraDataSize=0;
-    uint8_t  *videoExtraData;
     char *fileTitle=NULL;
         
      if(fourCC::check(fcc,(uint8_t *)"FLV1") || isVP6Compatible(fcc))
@@ -115,160 +86,37 @@
         }
 
     }
-    /* All seems fine, open stuff */
-    const char *f="flv";
 
-    fmt=guess_format(f, NULL, NULL);
-    if(!fmt)
+    if(false==setupMuxer("flv",file))
     {
-            printf("[FLV] guess format failed\n");
-            return false;
+        printf("[FLV] Failed to open muxer\n");
+        return false;
     }
-    oc = av_alloc_format_context();
-	if (!oc)
-	{
-       		printf("[FLV] alloc format context failed\n");
-            return false;
-	}
-	oc->oformat = fmt;
-	snprintf(oc->filename,1000,"file://%s",file);
-// *******************************************
-// *******************************************
-//                  VIDEO
-// *******************************************
-// *******************************************
-    video_st = av_new_stream(oc, 0);
-	if (!video_st)
-	{
-		printf("[FLV] new stream failed\n");
-		r=false;
-        goto finish;
-	}
+ 
+   if(initVideo(s)==false) 
+    {
+        printf("[FLV] Failed to init video\n");
+        return false;
+    }
+  
     AVCodecContext *c;
-	c = video_st->codec;
-        video_st->sample_aspect_ratio.num=1;
-        video_st->sample_aspect_ratio.den=1;
-  // probably a memeleak here
-        fileTitle=ADM_strdup(file);
+    c = video_st->codec;   
+    rescaleFps(s->getAvgFps1000(),&(c->time_base));
+    c->gop_size=15;
 
-        strcpy(oc->title,ADM_GetFileName(fileTitle));
-        strcpy(oc->author,"Avidemux");
-        c->sample_aspect_ratio.num=1;
-        c->sample_aspect_ratio.den=1;
-        if(isVP6Compatible(s->getFCC()))
-        {
-                 c->codec=new AVCodec;
-                 c->codec_id=CODEC_ID_VP6F;
-                 c->codec->name=ADM_strdup("VP6F");
-                 c->has_b_frames=0; // No PTS=cannot handle CTS...
-                 c->max_b_frames=0;
-        }else
-                if(fourCC::check(fcc,(uint8_t *)"FLV1"))
-                {
-                        c->has_b_frames=0; // No PTS=cannot handle CTS...
-                        c->max_b_frames=0;
-                        c->codec_id=CODEC_ID_FLV1;
+    if(initAudio(nbAudioTrack,a)==false)
+    {
+        printf("[FLV] Failed to init audio\n");
+        return false;
+    }
 
-                        c->codec=new AVCodec;
-                        memset(c->codec,0,sizeof(AVCodec));
-                        c->codec->name=ADM_strdup("FLV1");
-                }
-                else
-                {
-                        ADM_assert(0);
-                }
-
-        s->getExtraData(&videoExtraDataSize,&videoExtraData);
-        if(videoExtraDataSize)
-        {
-                c->extradata=videoExtraData;
-                c->extradata_size= videoExtraDataSize;
-        }
-
-        c->rc_buffer_size=8*1024*224;
-        c->rc_max_rate=9500*1000;
-        c->rc_min_rate=0;
-//        if(!inbitrate)
-                c->bit_rate=9000*1000;
-        //else
-          //      c->bit_rate=inbitrate;
-        c->codec_type = CODEC_TYPE_VIDEO;
-        c->flags=CODEC_FLAG_QSCALE;
-        c->width = s->getWidth();
-        c->height =s->getHeight();
         
-        rescaleFps(s->getAvgFps1000(),&(c->time_base));
-        c->gop_size=15;
-
-
-
-// *******************************************
-// *******************************************
-//                  AUDIO
-// *******************************************
-// *******************************************
-        if(nbAudioTrack)
-        {
-          uint32_t audioextraSize;
-          uint8_t  *audioextraData;
-
-          a[0]->getExtraData(&audioextraSize,&audioextraData);
-
-          audio_st = av_new_stream(oc, 1);
-          if (!audio_st)
-          {
-                  printf("[FLV]: new stream failed (audio)\n");
-                  r=false;
-                  goto finish;
-                                 
-          }
-          WAVHeader *audioheader=a[0]->getInfo();;
-
-          c = audio_st->codec;
-          c->frame_size=1024; //For AAC mainly, sample per frame
-          printf("[FLV] Bitrate %u\n",(audioheader->byterate*8)/1000);
-          c->sample_rate = audioheader->frequency;
-          switch(audioheader->encoding)
-          {
-                  case WAV_AC3: c->codec_id = CODEC_ID_AC3;c->frame_size=6*256;break;
-                  case WAV_MP2: c->codec_id = CODEC_ID_MP2;break;
-                  case WAV_MP3:
-  #warning FIXME : Probe deeper
-                              c->frame_size=1152;
-                              c->codec_id = CODEC_ID_MP3;
-                              break;
-                  case WAV_PCM:
-                                  // One chunk is 10 ms (1/100 of fq)
-                                  c->frame_size=4;
-                                  c->codec_id = CODEC_ID_PCM_S16LE;break;
-                  case WAV_AAC:
-                                  c->extradata=audioextraData;
-                                  c->extradata_size= audioextraSize;
-                                  c->codec_id = CODEC_ID_AAC;
-                                  break;
-                  default:
-                                 printf("[FLV]: Unsupported audio\n");
-                                 r=false;
-                                 goto finish;
-                                 return false;
-                          break;
-          }
-          c->codec_type = CODEC_TYPE_AUDIO;
-
-          c->bit_rate = audioheader->byterate*8;
-          c->rc_buffer_size=(c->bit_rate/(2*8)); // 500 ms worth
-
-          c->channels = audioheader->channels;
-
-        }
-        // /audio
-        
         oc->mux_rate=10080*1000;
         oc->preload=AV_TIME_BASE/10; // 100 ms preloading
         oc->max_delay=200*1000; // 500 ms
         if (av_set_parameters(oc, NULL) < 0)
         {
-            printf("Lav: set param failed \n");
+            printf("[FLV]: set param failed \n");
             return false;
         }
         if (url_fopen(&(oc->pb), file, URL_WRONLY) < 0)

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerFlv/muxerFlv.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerFlv/muxerFlv.h	2009-09-03 13:52:05 UTC (rev 5301)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerFlv/muxerFlv.h	2009-09-03 13:52:09 UTC (rev 5302)
@@ -18,7 +18,7 @@
 #define ADM_MUXER_FLV
 
 #include "ADM_muxer.h"
-
+#include "ADM_coreMuxerFfmpeg.h"
 typedef struct
 {
     
@@ -27,7 +27,7 @@
 
 extern FLVMUXERCONFIG muxerConfig;
 
-class muxerFlv : public ADM_muxer
+class muxerFlv : public muxerFFmpeg
 {
 protected:
 

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4/muxerMP4.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4/muxerMP4.cpp	2009-09-03 13:52:05 UTC (rev 5301)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4/muxerMP4.cpp	2009-09-03 13:52:09 UTC (rev 5302)
@@ -22,16 +22,6 @@
 #include "DIA_coreToolkit.h"
 #include "ADM_muxerUtils.h"
 
-
-
-
-
-static    AVOutputFormat *fmt=NULL;
-static    AVFormatContext *oc=NULL;
-static    AVStream *audio_st;
-static    AVStream *video_st;
-static    double audio_pts, video_pts;
-
 #if 0
 #define aprintf(...) {}
 #else
@@ -97,57 +87,10 @@
         printf("[MP4] Failed to init video\n");
         return false;
     }
-   AVCodecContext *c;
-        c = video_st->codec;
-        if(isMpeg4Compatible(s->getFCC()))
-        {
-                c->codec_id = CODEC_ID_MPEG4;
-                if(s->providePts()==true)
-                {
-                    c->has_b_frames=1; // in doubt...
-                    c->max_b_frames=2;
-                }else   
-                {
-                    c->has_b_frames=0; // No PTS=cannot handle CTS...
-                    c->max_b_frames=0;
-                }
-        }else
-        {
-                if(isH264Compatible(s->getFCC()))
-                {
-                        if(s->providePts()==true)
-                        {
-                            c->has_b_frames=1; // in doubt...
-                            c->max_b_frames=2;
-                        }else
-                        {
-                            printf("[MP4] Source video has no PTS information, assuming no b frames\n");
-                            c->has_b_frames=0; // No PTS=cannot handle CTS...
-                            c->max_b_frames=0;
-                        }
-                        c->codec_id = CODEC_ID_H264;
-                        c->codec=new AVCodec;
-                        memset(c->codec,0,sizeof(AVCodec));
-                        c->codec->name=ADM_strdup("H264");
-                }
-                else
-                {
-                        if(isDVCompatible(s->getFCC()))
-                        {
-                          c->codec_id = CODEC_ID_DVVIDEO;
-                        }else
-                        {
-                          if(fourCC::check(s->getFCC(),(uint8_t *)"H263"))
-                          {
-                                    c->codec_id=CODEC_ID_H263;
-                            }else{
-                                    return false;
-                                }
-                        }
-                }
-        }
+  
     
-
+        AVCodecContext *c;
+        c = video_st->codec;
         rescaleFps(s->getAvgFps1000(),&(c->time_base));
         c->gop_size=15;
         



From mean at mail.berlios.de  Thu Sep  3 15:52:10 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 3 Sep 2009 15:52:10 +0200
Subject: [Avidemux-svn-commit] r5303 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerFlv
Message-ID: <200909031352.n83DqAvc009455@sheep.berlios.de>

Author: mean
Date: 2009-09-03 15:52:10 +0200 (Thu, 03 Sep 2009)
New Revision: 5303

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerFlv/muxerFlv.cpp
Log:
[Muxer/Flv] cleanup

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerFlv/muxerFlv.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerFlv/muxerFlv.cpp	2009-09-03 13:52:09 UTC (rev 5302)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerFlv/muxerFlv.cpp	2009-09-03 13:52:10 UTC (rev 5303)
@@ -1,9 +1,9 @@
 /***************************************************************************
             \file            muxerFlv
-            \brief           i/f to lavformat mpeg4 muxer
+            \brief           i/f to lavformat Flv muxer
                              -------------------
 
-    copyright            : (C) 2008 by mean
+    copyright            : (C) 2009 by mean
     email                : fixounet at free.fr
 
  ***************************************************************************/
@@ -73,7 +73,6 @@
         }
 
     if(nbAudioTrack)
-    {
         for(int i=0;i<nbAudioTrack;i++)
         {
             uint32_t acc=a[i]->getInfo()->encoding;
@@ -85,8 +84,6 @@
 
         }
 
-    }
-
     if(false==setupMuxer("flv",file))
     {
         printf("[FLV] Failed to open muxer\n");
@@ -257,25 +254,8 @@
 */
 bool muxerFlv::close(void)
 {
-    if(oc)
-    {
-        av_write_trailer(oc);
-        url_fclose((oc->pb));
-        if(audio_st)
-        {
-             av_free(audio_st);
-        }
-        if(video_st)
-        {
-             av_free(video_st);
-        }
-        video_st=NULL;
-        audio_st=NULL;
-        if(oc)
-            av_free(oc);
-        oc=NULL;
-    }
     printf("[FLV] Closing\n");
+    closeMuxer();
     return true;
 }
 



From mean at mail.berlios.de  Thu Sep  3 20:42:29 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 3 Sep 2009 20:42:29 +0200
Subject: [Avidemux-svn-commit] r5304 - in branches/avidemux_2.6_branch_mean:
	avidemux_core/ADM_coreMuxer/include avidemux_core/ADM_coreMuxer/src
	avidemux_plugins/ADM_muxers/muxerFlv
	avidemux_plugins/ADM_muxers/muxerMp4
Message-ID: <200909031842.n83IgTIg027932@sheep.berlios.de>

Author: mean
Date: 2009-09-03 20:42:29 +0200 (Thu, 03 Sep 2009)
New Revision: 5304

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/include/ADM_coreMuxerFfmpeg.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_coreMuxerFfmpeg.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerFlv/muxerFlv.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerFlv/muxerFlv.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4/muxerMP4.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4/muxerMP4.h
Log:
[Flv/Mp4 muxers] Also factorize main loop

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/include/ADM_coreMuxerFfmpeg.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/include/ADM_coreMuxerFfmpeg.h	2009-09-03 13:52:10 UTC (rev 5303)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/include/ADM_coreMuxerFfmpeg.h	2009-09-03 18:42:29 UTC (rev 5304)
@@ -32,6 +32,11 @@
 class muxerFFmpeg : public ADM_muxer
 {
 protected:
+        virtual bool muxerRescaleVideoTime(uint64_t *time)=0;
+        virtual bool muxerRescaleAudioTime(uint64_t *time,uint32_t fq)=0;
+protected:
+        bool saveLoop(const char *title);
+protected:
         AVOutputFormat *fmt;
         AVFormatContext *oc;
         AVStream *audio_st;

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_coreMuxerFfmpeg.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_coreMuxerFfmpeg.cpp	2009-09-03 13:52:10 UTC (rev 5303)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_coreMuxerFfmpeg.cpp	2009-09-03 18:42:29 UTC (rev 5304)
@@ -20,6 +20,13 @@
 #include "fourcc.h"
 #include "ADM_coreMuxerFfmpeg.h"
 #include "ADM_muxerUtils.h"
+
+#if 1
+#define aprintf(...) {}
+#else
+#define aprintf printf
+#endif
+
 /**
     \fn muxerFFmpeg
 */
@@ -265,4 +272,140 @@
         printf("[FF] Audio initialized\n");
         return true;
 }
+/**
+
+*/
+bool muxerFFmpeg::saveLoop(const char *title)
+{
+#define AUDIO_BUFFER_SIZE 48000*6*sizeof(float)
+
+    printf("[FF] Saving\n");
+    uint32_t bufSize=vStream->getWidth()*vStream->getHeight()*3;
+    uint8_t *buffer=new uint8_t[bufSize];
+    uint32_t len,flags;
+    uint64_t pts,dts,rawDts;
+    uint64_t lastVideoDts=0;
+    uint64_t videoIncrement;
+    int ret;
+    int written=0;
+    bool result=true;
+
+    float f=(float)vStream->getAvgFps1000();
+    f=1000./f;
+    f*=1000000;
+    videoIncrement=(uint64_t)f;
+
+    uint8_t *audioBuffer=new uint8_t[AUDIO_BUFFER_SIZE];
+
+
+    printf("[MP4]avg fps=%u\n",vStream->getAvgFps1000());
+    AVRational *scale=&(video_st->codec->time_base);
+    uint64_t videoDuration=vStream->getVideoDuration();
+    
+    encoding=createWorking(title);
+
+    while(true==vStream->getPacket(&len, buffer, bufSize,&pts,&dts,&flags))
+    {
+	AVPacket pkt;
+
+            float p=0.5;
+            if(videoDuration)
+                    p=lastVideoDts/videoDuration;
+            p=p*100;
+            encoding->update((uint32_t)p);
+            if(!encoding->isAlive()) 
+            {
+                result=false;
+                break;
+            }
+            int64_t xpts=(int64_t)pts;
+            int64_t xdts=(int64_t)dts;
+            if(pts==ADM_NO_PTS) xpts=-1;
+            if(dts==ADM_NO_PTS) xdts=-1;
+            aprintf("[FF:V] Pts: %"LLD" DTS:%"LLD" ms\n",xpts/1000,xdts/1000);
+
+            aprintf("[FF:V] LastDts:%08"LLU" Dts:%08"LLU" (%04"LLU") Delta : %"LLU"\n",
+                        lastVideoDts,dts,dts/1000000,dts-lastVideoDts);
+            rawDts=dts;
+            if(rawDts==ADM_NO_PTS)
+            {
+                lastVideoDts+=videoIncrement;
+            }else
+            {
+                lastVideoDts=dts;
+            }
+            muxerRescaleVideoTime(&pts);
+            muxerRescaleVideoTime(&dts);
+
+            aprintf("[FF:V] RawDts:%lu Scaled Dts:%lu\n",rawDts,dts);
+            aprintf("[FF:V] Rescaled: Len : %d flags:%x Pts:%"LLU" Dts:%"LLU"\n",len,flags,pts,dts);
+
+            av_init_packet(&pkt);
+            pkt.dts=dts;
+            if(vStream->providePts()==true)
+            {
+                pkt.pts=pts;
+            }else
+            {
+                pkt.pts=pkt.dts;
+            }
+            pkt.stream_index=0;
+            pkt.data= buffer;
+            pkt.size= len;
+            if(flags & 0x10) // FIXME AVI_KEY_FRAME
+                        pkt.flags |= PKT_FLAG_KEY;
+            ret =av_write_frame(oc, &pkt);
+            aprintf("[FF]Frame:%u, DTS=%08lu PTS=%08lu\n",written,dts,pts);
+            if(ret)
+            {
+                printf("[FF]Error writing video packet\n");
+                break;
+            }
+            written++;
+            // Now send audio until they all have DTS > lastVideoDts+increment
+            for(int audio=0;audio<nbAStreams;audio++)
+            {
+                uint32_t audioSize,nbSample;
+                uint64_t audioDts;
+                ADM_audioStream*a=aStreams[audio];
+                uint32_t fq=a->getInfo()->frequency;
+                int nb=0;
+                while(a->getPacket(audioBuffer,&audioSize, AUDIO_BUFFER_SIZE,&nbSample,&audioDts))
+                {
+                    // Write...
+                    nb++;
+                    AVPacket pkt;
+                    uint64_t rescaledDts;
+                    rescaledDts=audioDts;
+                    muxerRescaleAudioTime(&rescaledDts,a->getInfo()->frequency);
+                    aprintf("[FF] A: Video frame  %d, audio Dts :%"LLU" size :%"LU" nbSample : %"LU" rescaled:%"LLU"\n",
+                                    written,audioDts,audioSize,nbSample,rescaledDts);
+                    av_init_packet(&pkt);
+                    
+                    pkt.dts=rescaledDts;
+                    pkt.pts=rescaledDts;
+                    pkt.stream_index=1+audio;
+                    pkt.data= audioBuffer;
+                    pkt.size= audioSize;
+                    ret =av_write_frame(oc, &pkt);
+                    if(ret)
+                    {
+                        printf("[FF]Error writing audio packet\n");
+                        break;
+                    }
+                    aprintf("[FF] A:%"LU" ms vs V: %"LU" ms\n",(uint32_t)audioDts/1000,(uint32_t)(lastVideoDts+videoIncrement)/1000);
+                    if(audioDts!=ADM_NO_PTS)
+                    {
+                        if(audioDts>lastVideoDts+videoIncrement) break;
+                    }
+                }
+                if(!nb) printf("[FF] A: No audio for video frame %d\n",written);
+            }
+
+    }
+    delete [] buffer;
+    delete [] audioBuffer;
+    printf("[FF] Wrote %d frames, nb audio streams %d\n",written,nbAStreams);
+    return result;
+}
 // EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerFlv/muxerFlv.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerFlv/muxerFlv.cpp	2009-09-03 13:52:10 UTC (rev 5303)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerFlv/muxerFlv.cpp	2009-09-03 18:42:29 UTC (rev 5304)
@@ -141,113 +141,22 @@
 */
 bool muxerFlv::save(void)
 {
-    printf("[FLV] Saving\n");
-    uint32_t bufSize=vStream->getWidth()*vStream->getHeight()*3;
-    uint8_t *buffer=new uint8_t[bufSize];
-    uint32_t len,flags;
-    uint64_t pts,dts,rawDts;
-    uint64_t lastVideoDts=0;
-    int ret;
-    bool result=true;
-    int written=0;
-#define AUDIO_BUFFER_SIZE 48000*6*sizeof(float)
-    uint8_t *audioBuffer=new uint8_t[AUDIO_BUFFER_SIZE];
+    return saveLoop("FLV");
+}
 
 
-    printf("[FLV]avg fps=%u\n",vStream->getAvgFps1000());
+bool muxerFlv::muxerRescaleVideoTime(uint64_t *time)
+{
     AVRational *scale=&(video_st->codec->time_base);
-    initUI("Saving Flv file..");
-    while(true==vStream->getPacket(&len, buffer, bufSize,&pts,&dts,&flags))
-    {
-	AVPacket pkt;
-            printf("[MP5] LastDts:%08"LLU" Dts:%08"LLU" (%04"LLU") Delta : %"LLD"\n",lastVideoDts,dts,dts/1000000,dts-lastVideoDts);
-            rawDts=dts;
-            if(rawDts==ADM_NO_PTS)
-            {
-                lastVideoDts+=videoIncrement;
-            }else
-            {
-                lastVideoDts=dts;
-            }
-            if(false==updateUI(lastVideoDts))
-            {
-                result=false;
-                goto abt;
-             }
-#define RESCALE(x) x=rescaleLavPts(x,scale);
-
-            dts=lastVideoDts/1000;
-
-            aprintf("[FLV] RawDts:%lu Scaled Dts:%lu\n",rawDts,dts);
-            aprintf("[FLV] Rescaled: Len : %d flags:%x Pts:%llu Dts:%llu\n",len,flags,pts,dts);
-            RESCALE(pts);
-            av_init_packet(&pkt);
-            pkt.dts=dts;
-            if(vStream->providePts()==true)
-            {
-                pkt.pts=pts;
-            }else
-            {
-                pkt.pts=pkt.dts;
-            }
-            pkt.stream_index=0;
-            pkt.data= buffer;
-            pkt.size= len;
-            if(flags & 0x10) // FIXME AVI_KEY_FRAME
-                        pkt.flags |= PKT_FLAG_KEY;
-            ret =av_write_frame(oc, &pkt);
-            aprintf("[FLV]Frame:%u, DTS=%08lu PTS=%08lu\n",written,dts,pts);
-            if(ret)
-            {
-                printf("[LavFormat]Error writing video packet\n");
-                break;
-            }
-            written++;
-            // Now send audio until they all have DTS > lastVideoDts+increment
-            for(int audio=0;audio<nbAStreams;audio++)
-            {
-                uint32_t audioSize,nbSample;
-                uint64_t audioDts,rescaled;
-                ADM_audioStream*a=aStreams[audio];
-                uint32_t fq=a->getInfo()->frequency;
-                int nb=0;
-                while(a->getPacket(audioBuffer,&audioSize, AUDIO_BUFFER_SIZE,&nbSample,&audioDts))
-                {
-                    // Write...
-                    nb++;
-                    AVPacket pkt;
-                    rescaled=audioDts/1000;
-
-                    aprintf("[FLV] Video frame  %d, audio Dts :%lu size :%lu nbSample : %lu rescaled:%lu\n",written,audioDts,audioSize,nbSample,rescaledDts);
-                    av_init_packet(&pkt);
-                    pkt.dts=rescaled;
-                    pkt.pts=rescaled;
-                    pkt.stream_index=1+audio;
-                    pkt.data= audioBuffer;
-                    pkt.size= audioSize;
-                    ret =av_write_frame(oc, &pkt);
-                    if(ret)
-                    {
-                        printf("[LavFormat]Error writing audio packet\n");
-                        break;
-                    }
-                    aprintf("%u vs %u\n",audioDts/1000,(lastVideoDts+videoIncrement)/1000);
-                    if(audioDts!=ADM_NO_PTS)
-                    {
-                        if(audioDts>lastVideoDts+videoIncrement) break;
-                    }
-                }
-                if(!nb) printf("[FLV] No audio for video frame %d\n",written);
-            }
-
-    }
-abt:
-    closeUI();
-    delete [] buffer;
-    delete [] audioBuffer;
-    printf("[FLV] Wrote %d frames, nb audio streams %d\n",written,nbAStreams);
-    return result;
+    *time=rescaleLavPts(*time,scale);
+    return true;
 }
+bool muxerFlv::muxerRescaleAudioTime(uint64_t *time,uint32_t fq)
+{
+    *time=*time/1000;
+    return true;
+}
+
 /**
     \fn close
     \brief Cleanup is done in the dtor

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerFlv/muxerFlv.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerFlv/muxerFlv.h	2009-09-03 13:52:10 UTC (rev 5303)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerFlv/muxerFlv.h	2009-09-03 18:42:29 UTC (rev 5304)
@@ -31,6 +31,8 @@
 {
 protected:
 
+        bool muxerRescaleVideoTime(uint64_t *time);
+        bool muxerRescaleAudioTime(uint64_t *time,uint32_t fq);
 public:
                 muxerFlv();
         virtual ~muxerFlv();

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4/muxerMP4.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4/muxerMP4.cpp	2009-09-03 13:52:10 UTC (rev 5303)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4/muxerMP4.cpp	2009-09-03 18:42:29 UTC (rev 5304)
@@ -127,138 +127,28 @@
 */
 bool muxerMP4::save(void) 
 {
-    printf("[MP4] Saving\n");
-    uint32_t bufSize=vStream->getWidth()*vStream->getHeight()*3;
-    uint8_t *buffer=new uint8_t[bufSize];
-    uint32_t len,flags;
-    uint64_t pts,dts,rawDts;
-    uint64_t lastVideoDts=0;
-    uint64_t videoIncrement;
-    int ret;
-    int written=0;
-    bool result=true;
-
-    float f=(float)vStream->getAvgFps1000();
-    f=1000./f;
-    f*=1000000;
-    videoIncrement=(uint64_t)f;
-#define AUDIO_BUFFER_SIZE 48000*6*sizeof(float)
-    uint8_t *audioBuffer=new uint8_t[AUDIO_BUFFER_SIZE];
-
-
-    printf("[MP4]avg fps=%u\n",vStream->getAvgFps1000());
-    AVRational *scale=&(video_st->codec->time_base);
-    uint64_t videoDuration=vStream->getVideoDuration();
-
     const char *title=QT_TR_NOOP("Saving mp4");
     if(muxerConfig.muxerType==MP4_MUXER_PSP) title=QT_TR_NOOP("Saving PSP");
-    encoding=createWorking(title);
+    return saveLoop(title);
+}
 
-    while(true==vStream->getPacket(&len, buffer, bufSize,&pts,&dts,&flags))
-    {
-	AVPacket pkt;
+bool muxerMP4::muxerRescaleVideoTime(uint64_t *time)
+{
+    AVRational *scale=&(video_st->codec->time_base);
+    *time=rescaleLavPts(*time,scale);
+    return true;
+}
+bool muxerMP4::muxerRescaleAudioTime(uint64_t *time,uint32_t fq)
+{
+  AVPacket pkt;
+    double f=*time;
+    f*=fq; // In samples
+    f/=1000.*1000.; // In sec
 
-            float p=0.5;
-            if(videoDuration)
-                    p=lastVideoDts/videoDuration;
-            p=p*100;
-            encoding->update((uint32_t)p);
-            if(!encoding->isAlive()) 
-            {
-                result=false;
-                break;
-            }
-            int64_t xpts=(int64_t)pts;
-            int64_t xdts=(int64_t)dts;
-            if(pts==ADM_NO_PTS) xpts=-1;
-            if(dts==ADM_NO_PTS) xdts=-1;
-            aprintf("[MP4:V] Pts: %"LLD" DTS:%"LLD" ms\n",xpts/1000,xdts/1000);
 
-            aprintf("[MP4:V] LastDts:%08"LLU" Dts:%08"LLU" (%04"LLU") Delta : %"LLU"\n",
-                        lastVideoDts,dts,dts/1000000,dts-lastVideoDts);
-            rawDts=dts;
-            if(rawDts==ADM_NO_PTS)
-            {
-                lastVideoDts+=videoIncrement;
-            }else
-            {
-                lastVideoDts=dts;
-            }
-            pts=rescaleLavPts(pts,scale);
-            dts=rescaleLavPts(dts,scale);
-            aprintf("[MP4:V] RawDts:%lu Scaled Dts:%lu\n",rawDts,dts);
-            aprintf("[MP4:V] Rescaled: Len : %d flags:%x Pts:%"LLU" Dts:%"LLU"\n",len,flags,pts,dts);
-
-            av_init_packet(&pkt);
-            pkt.dts=dts;
-            if(vStream->providePts()==true)
-            {
-                pkt.pts=pts;
-            }else
-            {
-                pkt.pts=pkt.dts;
-            }
-            pkt.stream_index=0;
-            pkt.data= buffer;
-            pkt.size= len;
-            if(flags & 0x10) // FIXME AVI_KEY_FRAME
-                        pkt.flags |= PKT_FLAG_KEY;
-            ret =av_write_frame(oc, &pkt);
-            aprintf("[MP4]Frame:%u, DTS=%08lu PTS=%08lu\n",written,dts,pts);
-            if(ret)
-            {
-                printf("[LavFormat]Error writing video packet\n");
-                break;
-            }
-            written++;
-            // Now send audio until they all have DTS > lastVideoDts+increment
-            for(int audio=0;audio<nbAStreams;audio++)
-            {
-                uint32_t audioSize,nbSample;
-                uint64_t audioDts;
-                ADM_audioStream*a=aStreams[audio];
-                uint32_t fq=a->getInfo()->frequency;
-                int nb=0;
-                while(a->getPacket(audioBuffer,&audioSize, AUDIO_BUFFER_SIZE,&nbSample,&audioDts))
-                {
-                    // Write...
-                    nb++;
-                    AVPacket pkt;
-                    double f=audioDts;
-                    f*=fq; // In samples
-                    f/=1000.*1000.; // In sec
-                   
-                    
-                    uint64_t rescaledDts=(uint64_t)(f+0.4);
-                    aprintf("[MP4] A: Video frame  %d, audio Dts :%"LLU" size :%"LU" nbSample : %"LU" rescaled:%"LLU"\n",
-                                    written,audioDts,audioSize,nbSample,rescaledDts);
-                    av_init_packet(&pkt);
-                    pkt.dts=rescaledDts;
-                    pkt.pts=rescaledDts;
-                    pkt.stream_index=1+audio;
-                    pkt.data= audioBuffer;
-                    pkt.size= audioSize;
-                    ret =av_write_frame(oc, &pkt);
-                    if(ret)
-                    {
-                        printf("[LavFormat]Error writing audio packet\n");
-                        break;
-                    }
-                    aprintf("[MP4] A:%"LU" ms vs V: %"LU" ms\n",(uint32_t)audioDts/1000,(uint32_t)(lastVideoDts+videoIncrement)/1000);
-                    if(audioDts!=ADM_NO_PTS)
-                    {
-                        if(audioDts>lastVideoDts+videoIncrement) break;
-                    }
-                }
-                if(!nb) printf("[MP4] A: No audio for video frame %d\n",written);
-            }
-
-    }
-    delete [] buffer;
-    delete [] audioBuffer;
-    printf("[MP4] Wrote %d frames, nb audio streams %d\n",written,nbAStreams);
-    return result;
+    *time=(uint64_t)(f+0.4);
 }
+  
 /**
     \fn close
     \brief Cleanup is done in the dtor

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4/muxerMP4.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4/muxerMP4.h	2009-09-03 13:52:10 UTC (rev 5303)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4/muxerMP4.h	2009-09-03 18:42:29 UTC (rev 5304)
@@ -36,7 +36,8 @@
 class muxerMP4 : public muxerFFmpeg
 {
 protected:
-
+        bool muxerRescaleVideoTime(uint64_t *time);
+        bool muxerRescaleAudioTime(uint64_t *time,uint32_t fq);
 public:
                 muxerMP4();
         virtual ~muxerMP4();



From mean at mail.berlios.de  Thu Sep  3 20:42:31 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 3 Sep 2009 20:42:31 +0200
Subject: [Avidemux-svn-commit] r5305 - in
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers:
	. muxerMkv
Message-ID: <200909031842.n83IgVCV027942@sheep.berlios.de>

Author: mean
Date: 2009-09-03 20:42:31 +0200 (Thu, 03 Sep 2009)
New Revision: 5305

Added:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMkv/
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMkv/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMkv/muxerMkv.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMkv/muxerMkv.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMkv/muxerMkvConfig.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMkv/muxerMkvPlugin.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/CMakeLists.txt
Log:
[Mkv Muxer] Incomplete mkv muxer, using coreMuxerFfmpeg

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/CMakeLists.txt	2009-09-03 18:42:29 UTC (rev 5304)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/CMakeLists.txt	2009-09-03 18:42:31 UTC (rev 5305)
@@ -3,16 +3,4 @@
 ADD_SUBDIRECTORY(muxerAvi)
 ADD_SUBDIRECTORY(muxerRaw)
 ADD_SUBDIRECTORY(muxerFlv)
-#ADD_SUBDIRECTORY(oplug_avi)
-#ADD_SUBDIRECTORY(oplug_mp4)
-#ADD_SUBDIRECTORY(oplug_mpeg)
-#ADD_SUBDIRECTORY(oplug_mpegFF)
-#ADD_SUBDIRECTORY(oplug_ogm)
-#ADD_SUBDIRECTORY(oplug_flv)
-#ADD_SUBDIRECTORY(oplug_dummy)
-
-#SET(ADM_LIB ADM_outputs)
-#SET(${ADM_LIB}_SRCS 
-#	ADM_lavformat.cpp  ADM_muxts.cpp)
-
-#ADD_ADM_LIB_ALL_TARGETS(${ADM_LIB} ${${ADM_LIB}_SRCS})
+ADD_SUBDIRECTORY(muxerMkv)

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMkv/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMkv/CMakeLists.txt	2009-09-03 18:42:29 UTC (rev 5304)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMkv/CMakeLists.txt	2009-09-03 18:42:31 UTC (rev 5305)
@@ -0,0 +1,14 @@
+include(mx_plugin)
+SET(ADM_Mkv_SRCS 
+	muxerMkv.cpp
+	muxerMkvPlugin.cpp
+        muxerMkvConfig.cpp
+)
+
+ADD_LIBRARY(ADM_mx_Mkv SHARED ${ADM_Mkv_SRCS})
+
+INCLUDE_DIRECTORIES("${AVIDEMUX_SOURCE_DIR}/avidemux/ADM_libraries/ADM_ffmpeg")
+TARGET_LINK_LIBRARIES(ADM_mx_Mkv  ADM_libavutil6 ADM_libavcodec6 ADM_libavformat6)
+INIT_MUXER(ADM_mx_Mkv)
+INSTALL_MUXER(ADM_mx_Mkv)
+

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMkv/muxerMkv.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMkv/muxerMkv.cpp	2009-09-03 18:42:29 UTC (rev 5304)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMkv/muxerMkv.cpp	2009-09-03 18:42:31 UTC (rev 5305)
@@ -0,0 +1,138 @@
+/***************************************************************************
+            \file            muxerMkv
+            \brief           i/f to lavformat Matroska muxer
+                             -------------------
+    
+    copyright            : (C) 2009 by mean
+    email                : fixounet at free.fr
+        
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "ADM_default.h"
+#include "fourcc.h"
+#include "muxerMkv.h"
+#include "DIA_coreToolkit.h"
+#include "ADM_muxerUtils.h"
+
+#if 0
+#define aprintf(...) {}
+#else
+#define aprintf printf
+#endif
+
+
+
+/**
+    \fn     muxerMkv
+    \brief  Constructor
+*/
+muxerMkv::muxerMkv() 
+{
+};
+/**
+    \fn     muxerMkv
+    \brief  Destructor
+*/
+
+muxerMkv::~muxerMkv() 
+{
+   
+}
+/**
+    \fn open
+    \brief Check that the streams are ok, initialize context...
+*/
+
+bool muxerMkv::open(const char *file, ADM_videoStream *s,uint32_t nbAudioTrack,ADM_audioStream **a)
+{
+    /* All seems fine, open stuff */
+    if(false==setupMuxer("matroska",file))
+    {
+        printf("[Mkv] Failed to open muxer\n");
+        return false;
+    }
+ 
+   if(initVideo(s)==false) 
+    {
+        printf("[Mkv] Failed to init video\n");
+        return false;
+    }
+  
+    
+        AVCodecContext *c;
+        c = video_st->codec;
+        rescaleFps(s->getAvgFps1000(),&(c->time_base));
+        c->gop_size=15;
+        
+        if(initAudio(nbAudioTrack,a)==false)
+        {
+            printf("[Mkv] Failed to init audio\n");
+            return false;
+        }
+        
+        // /audio
+        oc->mux_rate=10080*1000;
+        oc->preload=AV_TIME_BASE/10; // 100 ms preloading
+        oc->max_delay=200*1000; // 500 ms
+        if (av_set_parameters(oc, NULL) < 0)
+        {
+            printf("Lav: set param failed \n");
+            return false;
+        }
+        if (url_fopen(&(oc->pb), file, URL_WRONLY) < 0)
+        {
+            printf("[Mkv]: Failed to open file :%s\n",file);
+            return false;
+        }
+
+        ADM_assert(av_write_header(oc)>=0);
+        vStream=s;
+        aStreams=a;
+        nbAStreams=nbAudioTrack;
+        return true;
+}
+
+/**
+    \fn save
+*/
+bool muxerMkv::save(void) 
+{
+    const char *title=QT_TR_NOOP("Saving Mkv");
+    return saveLoop(title);
+}
+
+bool muxerMkv::muxerRescaleVideoTime(uint64_t *time)
+{
+    AVRational *scale=&(video_st->codec->time_base);
+    *time=rescaleLavPts(*time,scale);
+    return true;
+}
+bool muxerMkv::muxerRescaleAudioTime(uint64_t *time,uint32_t fq)
+{
+   *time=*time/1000;
+    return true;
+}
+  
+/**
+    \fn close
+    \brief Cleanup is done in the dtor
+*/
+bool muxerMkv::close(void) 
+{
+   
+    printf("[Mkv] Closing\n");
+    return closeMuxer();
+}
+
+//EOF
+
+
+

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMkv/muxerMkv.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMkv/muxerMkv.h	2009-09-03 18:42:29 UTC (rev 5304)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMkv/muxerMkv.h	2009-09-03 18:42:31 UTC (rev 5305)
@@ -0,0 +1,37 @@
+/***************************************************************************
+                          oplug_vcdff.h  -  description
+                             -------------------
+    begin                : Sun Nov 10 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef ADM_MUXER_MKV
+#define ADM_MUXER_MKV
+
+#include "ADM_muxer.h"
+#include "ADM_coreMuxerFfmpeg.h"
+
+class muxerMkv : public muxerFFmpeg
+{
+protected:
+        bool muxerRescaleVideoTime(uint64_t *time);
+        bool muxerRescaleAudioTime(uint64_t *time,uint32_t fq);
+public:
+                muxerMkv();
+        virtual ~muxerMkv();
+        virtual bool open(const char *file, ADM_videoStream *s,uint32_t nbAudioTrack,ADM_audioStream **a);
+        virtual bool save(void) ;
+        virtual bool close(void) ;
+
+};
+
+#endif

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMkv/muxerMkvConfig.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMkv/muxerMkvConfig.cpp	2009-09-03 18:42:29 UTC (rev 5304)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMkv/muxerMkvConfig.cpp	2009-09-03 18:42:31 UTC (rev 5305)
@@ -0,0 +1,26 @@
+/***************************************************************************
+    copyright            : (C) 2007 by mean
+    email                : fixounet at free.fr
+    
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "ADM_default.h"
+#include "ADM_muxerInternal.h"
+#include "muxerMkv.h"
+#define ADM_MINIMAL_UI_INTERFACE
+#include "DIA_factory.h"
+#include "fourcc.h"
+bool mkvConfigure(void)
+{
+        return true;
+}
+
+

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMkv/muxerMkvPlugin.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMkv/muxerMkvPlugin.cpp	2009-09-03 18:42:29 UTC (rev 5304)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMkv/muxerMkvPlugin.cpp	2009-09-03 18:42:31 UTC (rev 5305)
@@ -0,0 +1,32 @@
+/***************************************************************************
+    copyright            : (C) 2007 by mean
+    email                : fixounet at free.fr
+    
+      See lavformat/flv[dec/env].c for detail
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "ADM_default.h"
+#include "ADM_muxerInternal.h"
+#include "muxerMkv.h"
+
+#include "fourcc.h"
+ bool mkvConfigure(void);
+
+ADM_MUXER_BEGIN( muxerMkv,
+                    1,0,0,
+                    "MKV",    // Internal name
+                    "Matroska muxer plugin (c) Mean 2009",
+                    "Mkv Muxer", // DIsplay name
+                    mkvConfigure,
+                    NULL,
+                    0
+                );
+



From mean at mail.berlios.de  Thu Sep  3 20:42:32 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 3 Sep 2009 20:42:32 +0200
Subject: [Avidemux-svn-commit] r5306 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMkv
Message-ID: <200909031842.n83IgW7o027952@sheep.berlios.de>

Author: mean
Date: 2009-09-03 20:42:32 +0200 (Thu, 03 Sep 2009)
New Revision: 5306

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMkv/muxerMkv.cpp
Log:
[mkv/muxer] Corrent rescaling of time, should work now

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMkv/muxerMkv.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMkv/muxerMkv.cpp	2009-09-03 18:42:31 UTC (rev 5305)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMkv/muxerMkv.cpp	2009-09-03 18:42:32 UTC (rev 5306)
@@ -111,14 +111,26 @@
 
 bool muxerMkv::muxerRescaleVideoTime(uint64_t *time)
 {
+#if 0
     AVRational *scale=&(video_st->codec->time_base);
     *time=rescaleLavPts(*time,scale);
+#else
+    *time=*time/1000;
+#endif
     return true;
 }
 bool muxerMkv::muxerRescaleAudioTime(uint64_t *time,uint32_t fq)
 {
+#if 1
    *time=*time/1000;
     return true;
+#else
+ AVPacket pkt;
+    double f=*time;
+    f*=fq; // In samples
+    f/=1000.*1000.; // In sec
+    *time=(uint64_t)(f+0.4);
+#endif
 }
   
 /**



From mean at mail.berlios.de  Fri Sep  4 09:25:52 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 4 Sep 2009 09:25:52 +0200
Subject: [Avidemux-svn-commit] r5307 -
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src
Message-ID: <200909040725.n847Pqai015004@sheep.berlios.de>

Author: mean
Date: 2009-09-04 09:25:52 +0200 (Fri, 04 Sep 2009)
New Revision: 5307

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/CMakeLists.txt
Log:
[muxer] Add dependencies to coreUtils (win32)

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/CMakeLists.txt	2009-09-03 18:42:32 UTC (rev 5306)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/CMakeLists.txt	2009-09-04 07:25:52 UTC (rev 5307)
@@ -9,6 +9,6 @@
 ADD_LIBRARY(ADM_coreMuxer6 SHARED ${ADMcoreMuxer_SRCS})
 INCLUDE_DIRECTORIES(${CMAKE_SOURCE_DIR}/avidemux/ADM_coreAudio/include)
 INCLUDE_DIRECTORIES(${CMAKE_SOURCE_DIR}/avidemux/ADM_libraries/ADM_ffmpeg)
-TARGET_LINK_LIBRARIES(ADM_coreMuxer6 ADM_coreImage6 ADM_coreAudio6 ADM_core6 ADM_libavcodec6 ADM_libavformat6 ADM_libavutil6)
+TARGET_LINK_LIBRARIES(ADM_coreMuxer6 ADM_coreImage6 ADM_coreAudio6 ADM_core6 ADM_libavcodec6 ADM_libavformat6 ADM_libavutil6 ADM_coreUtils6)
 
 ADM_INSTALL_LIB(ADM_coreMuxer6)



From mean at mail.berlios.de  Fri Sep  4 17:09:54 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 4 Sep 2009 17:09:54 +0200
Subject: [Avidemux-svn-commit] r5308 - in
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg:
	ffmpeg_config libavformat
Message-ID: <200909041509.n84F9sNK021279@sheep.berlios.de>

Author: mean
Date: 2009-09-04 17:09:53 +0200 (Fri, 04 Sep 2009)
New Revision: 5308

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/ffmpeg_config/config.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/ffmpeg_config/ffconf.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/mpegenc.c
Log:
[ffmpeg] Add support for mpeg PS muxers

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/ffmpeg_config/config.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/ffmpeg_config/config.h	2009-09-04 07:25:52 UTC (rev 5307)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/ffmpeg_config/config.h	2009-09-04 15:09:53 UTC (rev 5308)
@@ -401,6 +401,10 @@
 #define CONFIG_PSP_MUXER 1
 #define CONFIG_TG2_MUXER 1
 #define CONFIG_TGP_MUXER 1
+#define CONFIG_MPEG1VCD_MUXER 1
+#define CONFIG_MPEG2SVCD_MUXER 1
+#define CONFIG_MPEG2DVD_MUXER 1
+#define CONFIG_MPEG2VOB_MUXER 1
 #define CONFIG_ENCODERS 1
 #define CONFIG_DVVIDEO_ENCODER 1
 #define CONFIG_SNOW_ENCODER 1

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/ffmpeg_config/ffconf.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/ffmpeg_config/ffconf.c	2009-09-04 07:25:52 UTC (rev 5307)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/ffmpeg_config/ffconf.c	2009-09-04 15:09:53 UTC (rev 5308)
@@ -455,6 +455,10 @@
 	DECLARE_MUXER(PSP, psp)
 	DECLARE_MUXER(TG2, tg2)
 	DECLARE_MUXER(TGP, tgp)
+	DECLARE_MUXER(MPEG1VCD, tgp)
+	DECLARE_MUXER(MPEG2SVCD, tgp)
+	DECLARE_MUXER(MPEG2DVD, tgp)
+	DECLARE_MUXER(MPEG2VOB, tgp)
 
 	printf("#define CONFIG_ENCODERS 1\n");
 	printf("#define CONFIG_DVVIDEO_ENCODER 1\n");

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/CMakeLists.txt	2009-09-04 07:25:52 UTC (rev 5307)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/CMakeLists.txt	2009-09-04 15:09:53 UTC (rev 5308)
@@ -5,7 +5,9 @@
 	movenc.c  avienc.c  wav.c  mov.c  matroska.c  isom.c  isom.h  
 	flvenc.c  matroskaenc.c metadata.c metadata_compat.c options.c
         flacenc.c
-	avc.c raw.c  riff.c)
+	avc.c raw.c  riff.c
+        mpegenc.c
+)
 
 ADD_LIBRARY(${ADM_LIB} SHARED ${${ADM_LIB}_SRCS})
 TARGET_LINK_LIBRARIES(${ADM_LIB} ADM_core6 ADM_libavutil6 ADM_libavcodec6)

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/mpegenc.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/mpegenc.c	2009-09-04 07:25:52 UTC (rev 5307)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/mpegenc.c	2009-09-04 15:09:53 UTC (rev 5308)
@@ -1300,3 +1300,13 @@
     mpeg_mux_end,
 };
 #endif
+// MEANX
+//
+int mpegenc_init(void)
+{
+    av_register_output_format(&mpeg2dvd_muxer);
+    av_register_output_format(&mpeg2svcd_muxer);
+    av_register_output_format(&mpeg2vob_muxer);
+    av_register_output_format(&mpeg1vcd_muxer);
+    return 0;
+}
\ No newline at end of file



From mean at mail.berlios.de  Fri Sep  4 17:09:56 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 4 Sep 2009 17:09:56 +0200
Subject: [Avidemux-svn-commit] r5309 - in
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer:
	include src
Message-ID: <200909041509.n84F9uUm021321@sheep.berlios.de>

Author: mean
Date: 2009-09-04 17:09:55 +0200 (Fri, 04 Sep 2009)
New Revision: 5309

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/include/ADM_muxerUtils.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_coreMuxerFfmpeg.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_dynaMuxer.cpp
Log:
[muxer/ff] add mpeg1/mpeg2 video + factorize the isxxxxcompatible declaration

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/include/ADM_muxerUtils.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/include/ADM_muxerUtils.h	2009-09-04 15:09:53 UTC (rev 5308)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/include/ADM_muxerUtils.h	2009-09-04 15:09:55 UTC (rev 5309)
@@ -21,14 +21,8 @@
 };
 
 #define ADM_NO_PTS 0xFFFFFFFFFFFFFFFFLL // FIXME
+#include "ADM_codecType.h"
 
-// Fwd ref
-uint8_t isMpeg4Compatible (uint32_t fourcc);
-uint8_t isH264Compatible (uint32_t fourcc);
-uint8_t isMSMpeg4Compatible (uint32_t fourcc);
-uint8_t isDVCompatible (uint32_t fourcc);
-uint8_t isVP6Compatible (uint32_t fourcc);
-
 /**
     \fn rescaleFps
     \brief Rescale fps to be accurate (i.e. 23.976 become 24000/1001)

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_coreMuxerFfmpeg.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_coreMuxerFfmpeg.cpp	2009-09-04 15:09:53 UTC (rev 5308)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_coreMuxerFfmpeg.cpp	2009-09-04 15:09:55 UTC (rev 5309)
@@ -133,8 +133,8 @@
         c->flags=CODEC_FLAG_QSCALE;
         c->width = stream->getWidth();
         c->height =stream->getHeight();
-
-        if(isMpeg4Compatible(stream->getFCC()))
+        uint32_t fcc=stream->getFCC();
+        if(isMpeg4Compatible(fcc))
         {
                 c->codec_id = CODEC_ID_MPEG4;
                 if(stream->providePts()==true)
@@ -148,7 +148,7 @@
                 }
         }else
         {
-                if(isH264Compatible(stream->getFCC()))
+                if(isH264Compatible(fcc))
                 {
                         if(stream->providePts()==true)
                         {
@@ -167,12 +167,12 @@
                 }
                 else
                 {
-                        if(isDVCompatible(stream->getFCC()))
+                        if(isDVCompatible(fcc))
                         {
                           c->codec_id = CODEC_ID_DVVIDEO;
                         }else
                         {
-                          if(fourCC::check(stream->getFCC(),(uint8_t *)"H263"))
+                          if(fourCC::check(fcc,(uint8_t *)"H263"))
                           {
                                     c->codec_id=CODEC_ID_H263;
                             }else
@@ -196,8 +196,22 @@
                                                 c->codec->name=ADM_strdup("FLV1");
                                         }else
                                         {
-                                            printf("[FF] Unknown video codec\n");
-                                            return false;
+                                            if(fourCC::check(stream->getFCC(),(uint8_t *)"MPEG1"))
+                                            {
+                                                c->has_b_frames=1; // No PTS=cannot handle CTS...
+                                                c->max_b_frames=2;
+                                                c->codec_id=CODEC_ID_MPEG1VIDEO;
+                                            }
+                                            else if(fourCC::check(stream->getFCC(),(uint8_t *)"MPEG2"))
+                                            {
+                                                c->has_b_frames=1; // No PTS=cannot handle CTS...
+                                                c->max_b_frames=2;
+                                                c->codec_id=CODEC_ID_MPEG2VIDEO;
+                                            }else
+                                            {
+                                                printf("[FF] Unknown video codec\n");
+                                                return false;
+                                            }
                                         }
                         }
                 }

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_dynaMuxer.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_dynaMuxer.cpp	2009-09-04 15:09:53 UTC (rev 5308)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_dynaMuxer.cpp	2009-09-04 15:09:55 UTC (rev 5309)
@@ -176,6 +176,7 @@
 extern void movenc_init(void);
 extern void flvenc_init(void);
 extern void matroskaenc_init(void);
+extern void mpegenc_init(void);
 }
 extern struct URLProtocol file_protocol ;
 /**
@@ -189,7 +190,8 @@
         movenc_init();
         flvenc_init();
         matroskaenc_init();
-        register_protocol(&file_protocol);
+        mpegenc_init();
+        av_register_protocol(&file_protocol);
 }
 // EOF
 



From mean at mail.berlios.de  Fri Sep  4 17:09:58 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 4 Sep 2009 17:09:58 +0200
Subject: [Avidemux-svn-commit] r5310 -
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches
Message-ID: <200909041509.n84F9w1i021332@sheep.berlios.de>

Author: mean
Date: 2009-09-04 17:09:57 +0200 (Fri, 04 Sep 2009)
New Revision: 5310

Added:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavformat_mpegenc.c.patch
Log:
[ffmpeg/mpegenc] Declaration of muxers

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavformat_mpegenc.c.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavformat_mpegenc.c.patch	2009-09-04 15:09:55 UTC (rev 5309)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavformat_mpegenc.c.patch	2009-09-04 15:09:57 UTC (rev 5310)
@@ -0,0 +1,17 @@
+--- libavformat/mpegenc.c
++++ libavformat/mpegenc.c
+@@ -1300,3 +1300,13 @@ AVOutputFormat mpeg2dvd_muxer = {
+     mpeg_mux_end,
+ };
+ #endif
++// MEANX
++//
++int mpegenc_init(void)
++{
++    av_register_output_format(&mpeg2dvd_muxer);
++    av_register_output_format(&mpeg2svcd_muxer);
++    av_register_output_format(&mpeg2vob_muxer);
++    av_register_output_format(&mpeg1vcd_muxer);
++    return 0;
++}
+\ No newline at end of file



From mean at mail.berlios.de  Fri Sep  4 17:09:59 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 4 Sep 2009 17:09:59 +0200
Subject: [Avidemux-svn-commit] r5311 - in
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers:
	. muxerffPS
Message-ID: <200909041509.n84F9xSZ021361@sheep.berlios.de>

Author: mean
Date: 2009-09-04 17:09:59 +0200 (Fri, 04 Sep 2009)
New Revision: 5311

Added:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffPS/
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffPS/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffPS/muxerffPS.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffPS/muxerffPS.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffPS/muxerffPSConfig.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffPS/muxerffPSPlugin.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/CMakeLists.txt
Log:
[PS muxer] Skeleton for PS muxer (incomplete)

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/CMakeLists.txt	2009-09-04 15:09:57 UTC (rev 5310)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/CMakeLists.txt	2009-09-04 15:09:59 UTC (rev 5311)
@@ -4,3 +4,4 @@
 ADD_SUBDIRECTORY(muxerRaw)
 ADD_SUBDIRECTORY(muxerFlv)
 ADD_SUBDIRECTORY(muxerMkv)
+ADD_SUBDIRECTORY(muxerffPS)

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffPS/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffPS/CMakeLists.txt	2009-09-04 15:09:57 UTC (rev 5310)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffPS/CMakeLists.txt	2009-09-04 15:09:59 UTC (rev 5311)
@@ -0,0 +1,14 @@
+include(mx_plugin)
+SET(ADM_ffPS_SRCS 
+	muxerffPS.cpp
+	muxerffPSPlugin.cpp
+        muxerffPSConfig.cpp
+)
+
+ADD_LIBRARY(ADM_mx_ffPS SHARED ${ADM_ffPS_SRCS})
+
+INCLUDE_DIRECTORIES("${AVIDEMUX_SOURCE_DIR}/avidemux/ADM_libraries/ADM_ffmpeg")
+TARGET_LINK_LIBRARIES(ADM_mx_ffPS  ADM_libavutil6 ADM_libavcodec6 ADM_libavformat6)
+INIT_MUXER(ADM_mx_ffPS)
+INSTALL_MUXER(ADM_mx_ffPS)
+

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffPS/muxerffPS.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffPS/muxerffPS.cpp	2009-09-04 15:09:57 UTC (rev 5310)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffPS/muxerffPS.cpp	2009-09-04 15:09:59 UTC (rev 5311)
@@ -0,0 +1,239 @@
+/***************************************************************************
+            \file            muxerffPS
+            \brief           i/f to lavformat PS muxer
+                             -------------------
+    
+    copyright            : (C) 2009 by mean
+    email                : fixounet at free.fr
+        
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "ADM_default.h"
+#include "fourcc.h"
+#include "muxerffPS.h"
+#include "DIA_coreToolkit.h"
+#include "ADM_muxerUtils.h"
+#include "ADM_codecType.h"
+#if 0
+#define aprintf(...) {}
+#else
+#define aprintf printf
+#endif
+
+psMuxerConfig_s psMuxerConfig=
+{
+    MUXER_DVD,false
+};
+
+/**
+    \fn     muxerffPS
+    \brief  Constructor
+*/
+muxerffPS::muxerffPS() 
+{
+};
+/**
+    \fn     muxerffPS
+    \brief  Destructor
+*/
+
+muxerffPS::~muxerffPS() 
+{
+   
+}
+/**
+    \fn open
+    \brief Check that the streams are ok, initialize context...
+*/
+
+bool muxerffPS::open(const char *file, ADM_videoStream *s,uint32_t nbAudioTrack,ADM_audioStream **a)
+{
+    uint32_t fcc=s->getFCC();
+    uint32_t w,h;
+     w=s->getWidth();
+     h=s->getHeight();
+        
+     if(!isMpeg12Compatible(fcc))
+     {
+            printf("[ffPs] video not compatible\n");
+            return false;
+     }
+    if(!psMuxerConfig.acceptNonCompliant)
+    {
+        switch(psMuxerConfig.muxingType)
+        {
+            case MUXER_VCD:
+                    if(w!=352 || (h!=240 && h!=288))
+                    {
+                            printf("[ffPs] Bad width/height for VCD\n");
+                            return false;
+                    }
+                    break;
+            case MUXER_SVCD:
+                    if((w!=352 && w!=480)|| (h!=576 && h!=480))
+                    {
+                            printf("[ffPs] Bad width/height for SVCD\n");
+                            return false;
+                    }
+                    break;
+            case MUXER_DVD:
+                    if((w!=720 && w!=704)|| (h!=576 && h!=480))
+                    {
+                            printf("[ffPs] Bad width/height for DVD\n");
+                            return false;
+                    }
+                    break;
+            default:
+                    ADM_assert(0);
+        }
+    }
+    if(!nbAudioTrack) 
+        {
+            printf("[ffPS] One audio track needed\n");
+            return false;
+        }
+    for(int i=0;i<nbAudioTrack;i++)
+    {
+        WAVHeader *head=a[i]->getInfo();
+        switch(psMuxerConfig.muxingType)
+        {
+            case MUXER_VCD:
+            case MUXER_SVCD:
+                    if(head->encoding!=WAV_MP2) 
+                    {
+                        printf("[ffPS] VCD : only MP2 audio accepted\n");
+                        return false;
+                    }
+                    if(head->frequency!=44100) 
+                    {
+                        printf("[ffPS] VCD : only 44.1 khz audio accepted\n");
+                        return false;
+                    }
+                    break;
+            case MUXER_DVD:
+                    if(head->encoding!=WAV_MP2 && head->encoding!=WAV_AC3 && head->encoding!=WAV_DTS) 
+                    {
+                        printf("[ffPS] DVD : only MP2/AC3/DTS audio accepted\n");
+                        return false;
+                    }
+                    if(head->frequency!=48000) 
+                    {
+                        printf("[ffPS] DVD : only 48 khz audio accepted\n");
+                        return false;
+                    }
+                    break;
+            default:
+                    ADM_assert(0);
+        }
+    }
+
+    /* All seems fine, open stuff */
+    const char *fmt;
+     switch(psMuxerConfig.muxingType)
+        {
+            case MUXER_VCD: fmt="vcd";break;
+            case MUXER_SVCD:fmt="svcd";break;
+            case MUXER_DVD: fmt="dvd";break;
+        }
+    if(false==setupMuxer(fmt,file))
+    {
+        printf("[ffPS] Failed to open muxer\n");
+        return false;
+    }
+ 
+   if(initVideo(s)==false) 
+    {
+        printf("[ffPS] Failed to init video\n");
+        return false;
+    }
+  
+    
+        AVCodecContext *c;
+        c = video_st->codec;
+        rescaleFps(s->getAvgFps1000(),&(c->time_base));
+        c->gop_size=15;
+        
+        if(initAudio(nbAudioTrack,a)==false)
+        {
+            printf("[ffPS] Failed to init audio\n");
+            return false;
+        }
+        
+        // /audio
+        oc->mux_rate=10080*1000;
+        oc->preload=AV_TIME_BASE/10; // 100 ms preloading
+        oc->max_delay=200*1000; // 500 ms
+        if (av_set_parameters(oc, NULL) < 0)
+        {
+            printf("Lav: set param failed \n");
+            return false;
+        }
+        if (url_fopen(&(oc->pb), file, URL_WRONLY) < 0)
+        {
+            printf("[ffPS]: Failed to open file :%s\n",file);
+            return false;
+        }
+
+        ADM_assert(av_write_header(oc)>=0);
+        vStream=s;
+        aStreams=a;
+        nbAStreams=nbAudioTrack;
+        return true;
+}
+
+/**
+    \fn save
+*/
+bool muxerffPS::save(void) 
+{
+    const char *title=QT_TR_NOOP("Saving mpeg PS (ff)");
+    return saveLoop(title);
+}
+
+bool muxerffPS::muxerRescaleVideoTime(uint64_t *time)
+{
+#if 0
+    AVRational *scale=&(video_st->codec->time_base);
+    *time=rescaleLavPts(*time,scale);
+#else
+    *time=*time/1000;
+#endif
+    return true;
+}
+bool muxerffPS::muxerRescaleAudioTime(uint64_t *time,uint32_t fq)
+{
+#if 1
+   *time=*time/1000;
+    return true;
+#else
+ AVPacket pkt;
+    double f=*time;
+    f*=fq; // In samples
+    f/=1000.*1000.; // In sec
+    *time=(uint64_t)(f+0.4);
+#endif
+}
+  
+/**
+    \fn close
+    \brief Cleanup is done in the dtor
+*/
+bool muxerffPS::close(void) 
+{
+   
+    printf("[ffPS] Closing\n");
+    return closeMuxer();
+}
+
+//EOF
+
+
+

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffPS/muxerffPS.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffPS/muxerffPS.h	2009-09-04 15:09:57 UTC (rev 5310)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffPS/muxerffPS.h	2009-09-04 15:09:59 UTC (rev 5311)
@@ -0,0 +1,55 @@
+/***************************************************************************
+                          oplug_vcdff.h  -  description
+                             -------------------
+    begin                : Sun Nov 10 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef ADM_MUXER_ffPS
+#define ADM_MUXER_ffPS
+
+#include "ADM_muxer.h"
+#include "ADM_coreMuxerFfmpeg.h"
+
+typedef enum
+{
+    MUXER_VCD,
+    MUXER_SVCD,
+    MUXER_DVD
+}psMuxingType;
+
+typedef struct
+{
+    psMuxingType muxingType;
+    bool         acceptNonCompliant;
+}psMuxerConfig_s;
+
+extern psMuxerConfig_s psMuxerConfig;
+
+/**
+    \fn class muxerffPS
+*/
+class muxerffPS : public muxerFFmpeg
+{
+protected:
+        bool muxerRescaleVideoTime(uint64_t *time);
+        bool muxerRescaleAudioTime(uint64_t *time,uint32_t fq);
+public:
+                muxerffPS();
+        virtual ~muxerffPS();
+        virtual bool open(const char *file, ADM_videoStream *s,uint32_t nbAudioTrack,ADM_audioStream **a);
+        virtual bool save(void) ;
+        virtual bool close(void) ;
+
+};
+
+#endif

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffPS/muxerffPSConfig.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffPS/muxerffPSConfig.cpp	2009-09-04 15:09:57 UTC (rev 5310)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffPS/muxerffPSConfig.cpp	2009-09-04 15:09:59 UTC (rev 5311)
@@ -0,0 +1,41 @@
+/***************************************************************************
+    copyright            : (C) 2007 by mean
+    email                : fixounet at free.fr
+    
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "ADM_default.h"
+#include "ADM_muxerInternal.h"
+#include "muxerffPS.h"
+#define ADM_MINIMAL_UI_INTERFACE
+#include "DIA_factory.h"
+#include "fourcc.h"
+bool ffPSConfigure(void)
+{
+        uint32_t mux=(uint32_t)psMuxerConfig.muxingType;
+        uint32_t tolerance=(uint32_t)psMuxerConfig.acceptNonCompliant;
+        diaMenuEntry format[]={{MUXER_VCD,"VCD"},{MUXER_SVCD,"SVCD"},{MUXER_DVD,"DVD"}};
+
+        diaElemMenu  menuFormat(&mux,"Muxing Format",3,format,"");
+        diaElemToggle alternate(&tolerance,"Allow non compliant stream");
+
+        diaElem *tabs[]={&menuFormat,&alternate};
+        if( diaFactoryRun(("Mpeg PS Muxer"),2,tabs))
+        {
+            psMuxerConfig.muxingType=(psMuxingType)mux;
+            psMuxerConfig.acceptNonCompliant=tolerance;
+            return true;
+        }
+        return false;
+}
+// EOF
+
+

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffPS/muxerffPSPlugin.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffPS/muxerffPSPlugin.cpp	2009-09-04 15:09:57 UTC (rev 5310)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffPS/muxerffPSPlugin.cpp	2009-09-04 15:09:59 UTC (rev 5311)
@@ -0,0 +1,32 @@
+/***************************************************************************
+    copyright            : (C) 2007 by mean
+    email                : fixounet at free.fr
+    
+      See lavformat/flv[dec/env].c for detail
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "ADM_default.h"
+#include "ADM_muxerInternal.h"
+#include "muxerffPS.h"
+
+#include "fourcc.h"
+ bool ffPSConfigure(void);
+
+ADM_MUXER_BEGIN( muxerffPS,
+                    1,0,0,
+                    "ffPS",    // Internal name
+                    "ffMpeg PS muxer plugin (c) Mean 2009",
+                    "ffPS Muxer", // DIsplay name
+                    ffPSConfigure,
+                    &psMuxerConfig,
+                    sizeof(psMuxerConfig)
+                );
+



From mean at mail.berlios.de  Fri Sep  4 17:10:01 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 4 Sep 2009 17:10:01 +0200
Subject: [Avidemux-svn-commit] r5312 -
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/include
Message-ID: <200909041510.n84FA1im021410@sheep.berlios.de>

Author: mean
Date: 2009-09-04 17:10:01 +0200 (Fri, 04 Sep 2009)
New Revision: 5312

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/include/ADM_coreMuxerFfmpeg.h
Log:
[ffMuxer] Handle DTS in a specific way for muxers that hate to not have DTS for all frame

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/include/ADM_coreMuxerFfmpeg.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/include/ADM_coreMuxerFfmpeg.h	2009-09-04 15:09:59 UTC (rev 5311)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/include/ADM_coreMuxerFfmpeg.h	2009-09-04 15:10:01 UTC (rev 5312)
@@ -33,7 +33,12 @@
 {
 protected:
         virtual bool muxerRescaleVideoTime(uint64_t *time)=0;
+        virtual bool muxerRescaleVideoTimeDts(uint64_t *time,uint64_t computedDts)
+                    {
+                        return muxerRescaleVideoTime(time);
+                    }
         virtual bool muxerRescaleAudioTime(uint64_t *time,uint32_t fq)=0;
+
 protected:
         bool saveLoop(const char *title);
 protected:



From mean at mail.berlios.de  Fri Sep  4 17:10:06 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 4 Sep 2009 17:10:06 +0200
Subject: [Avidemux-svn-commit] r5314 - in branches/avidemux_2.6_branch_mean:
	avidemux_core/ADM_coreMuxer/include
	avidemux_plugins/ADM_muxers/muxerMkv
	avidemux_plugins/ADM_muxers/muxerffPS
Message-ID: <200909041510.n84FA6ou021477@sheep.berlios.de>

Author: mean
Date: 2009-09-04 17:10:05 +0200 (Fri, 04 Sep 2009)
New Revision: 5314

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/include/ADM_coreMuxerFfmpeg.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMkv/muxerMkv.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMkv/muxerMkv.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffPS/muxerffPS.cpp
Log:
[ffMuxer] lavformat muxers do not like not having DTS, recompute it systematically

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/include/ADM_coreMuxerFfmpeg.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/include/ADM_coreMuxerFfmpeg.h	2009-09-04 15:10:03 UTC (rev 5313)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/include/ADM_coreMuxerFfmpeg.h	2009-09-04 15:10:05 UTC (rev 5314)
@@ -26,6 +26,9 @@
 {
     #include "libavformat/avformat.h"
 };
+#ifndef INT64_C
+#define INT64_C (uint64_t)
+#endif
 /**
     \class muxerFFmpeg
 */

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMkv/muxerMkv.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMkv/muxerMkv.cpp	2009-09-04 15:10:03 UTC (rev 5313)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMkv/muxerMkv.cpp	2009-09-04 15:10:05 UTC (rev 5314)
@@ -111,28 +111,30 @@
 
 bool muxerMkv::muxerRescaleVideoTime(uint64_t *time)
 {
-#if 0
-    AVRational *scale=&(video_st->codec->time_base);
-    *time=rescaleLavPts(*time,scale);
-#else
+    if(*time==ADM_NO_PTS)
+    {
+        *time=AV_NOPTS_VALUE;
+        return true;
+    }
     *time=*time/1000;
-#endif
+
     return true;
 }
 bool muxerMkv::muxerRescaleAudioTime(uint64_t *time,uint32_t fq)
 {
-#if 1
+
    *time=*time/1000;
     return true;
-#else
- AVPacket pkt;
-    double f=*time;
-    f*=fq; // In samples
-    f/=1000.*1000.; // In sec
-    *time=(uint64_t)(f+0.4);
-#endif
 }
-  
+bool muxerMkv::muxerRescaleVideoTimeDts(uint64_t *time,uint64_t computedDts)
+{
+    if(*time==ADM_NO_PTS)
+    {
+        *time=computedDts;
+        return muxerRescaleVideoTime(time);
+    }
+    return muxerRescaleVideoTime(time);
+}  
 /**
     \fn close
     \brief Cleanup is done in the dtor

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMkv/muxerMkv.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMkv/muxerMkv.h	2009-09-04 15:10:03 UTC (rev 5313)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMkv/muxerMkv.h	2009-09-04 15:10:05 UTC (rev 5314)
@@ -25,6 +25,7 @@
 protected:
         bool muxerRescaleVideoTime(uint64_t *time);
         bool muxerRescaleAudioTime(uint64_t *time,uint32_t fq);
+        bool muxerRescaleVideoTimeDts(uint64_t *time,uint64_t computedDts);
 public:
                 muxerMkv();
         virtual ~muxerMkv();

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffPS/muxerffPS.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffPS/muxerffPS.cpp	2009-09-04 15:10:03 UTC (rev 5313)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffPS/muxerffPS.cpp	2009-09-04 15:10:05 UTC (rev 5314)
@@ -203,16 +203,16 @@
     const char *title=QT_TR_NOOP("Saving mpeg PS (ff)");
     return saveLoop(title);
 }
+#define INT64_C (uint64_t)
 bool muxerffPS::muxerRescaleVideoTime(uint64_t *time)
 {
-#if 0
-    printf("<<in Video TS: %"LLU"\n",*time);
-    AVRational *scale=&(video_st->codec->time_base);
-    *time=rescaleLavPts(*time,scale);
-    printf(">>out Video TS: %"LLU"\n",*time);
-#endif
-#define INT64_C (uint64_t)
-    if(*time==ADM_NO_PTS) *time=AV_NOPTS_VALUE;
+    if(*time==ADM_NO_PTS)
+    {
+        *time=AV_NOPTS_VALUE;
+        return true;
+    }
+    *time=*time/90;
+    
     return true;
 }
 bool muxerffPS::muxerRescaleVideoTimeDts(uint64_t *time,uint64_t computedDts)
@@ -227,14 +227,7 @@
 
 bool muxerffPS::muxerRescaleAudioTime(uint64_t *time,uint32_t fq)
 {
-#if 0
-    printf("Audio TS: %"LLU"\n",*time);
- AVPacket pkt;
-    double f=*time;
-    f*=fq; // In samples
-    f/=1000.*1000.; // In sec
-    *time=(uint64_t)(f+0.4);
-#endif
+    *time=*time/90;
     return true;
 }
   



From mean at mail.berlios.de  Fri Sep  4 17:10:09 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 4 Sep 2009 17:10:09 +0200
Subject: [Avidemux-svn-commit] r5315 - in branches/avidemux_2.6_branch_mean:
	avidemux_core/ADM_coreMuxer/include avidemux_core/ADM_coreMuxer/src
	avidemux_plugins/ADM_muxers/muxerFlv
	avidemux_plugins/ADM_muxers/muxerMkv
	avidemux_plugins/ADM_muxers/muxerMp4
	avidemux_plugins/ADM_muxers/muxerffPS
Message-ID: <200909041510.n84FA9Ik021510@sheep.berlios.de>

Author: mean
Date: 2009-09-04 17:10:07 +0200 (Fri, 04 Sep 2009)
New Revision: 5315

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/include/ADM_coreMuxerFfmpeg.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_coreMuxerFfmpeg.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_muxerUtils.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerFlv/muxerFlv.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerFlv/muxerFlv.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMkv/muxerMkv.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMkv/muxerMkv.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4/muxerMP4.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4/muxerMP4.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffPS/muxerffPS.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffPS/muxerffPS.h
Log:
[ff muxers] Better way of computing scale (in fact the right one :) ), factorize away some code

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/include/ADM_coreMuxerFfmpeg.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/include/ADM_coreMuxerFfmpeg.h	2009-09-04 15:10:05 UTC (rev 5314)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/include/ADM_coreMuxerFfmpeg.h	2009-09-04 15:10:07 UTC (rev 5315)
@@ -21,6 +21,7 @@
 #include "ADM_default.h"
 #include "fourcc.h"
 #include "ADM_muxer.h"
+#include "ADM_muxerUtils.h"
 #include "ADM_lavcodec.h"
 extern "C"
 {
@@ -35,13 +36,24 @@
 class muxerFFmpeg : public ADM_muxer
 {
 protected:
-        virtual bool muxerRescaleVideoTime(uint64_t *time)=0;
+        virtual bool muxerRescaleVideoTime(uint64_t *time)
+        {
+             AVRational *scale=&(video_st->time_base);
+            *time=rescaleLavPts(*time,scale);
+            return true;
+        }
+        virtual bool muxerRescaleAudioTime(uint64_t *time,uint32_t fq)
+        {       
+             AVRational *scale=&(audio_st->time_base);
+            *time=rescaleLavPts(*time,scale);
+            return true;
+        }
+        // On case the muxer does not accept ADM_NO_PTS we can use computedDts
+        // The default is use ADM_NO_PTS
         virtual bool muxerRescaleVideoTimeDts(uint64_t *time,uint64_t computedDts)
-                    {
-                        return muxerRescaleVideoTime(time);
-                    }
-        virtual bool muxerRescaleAudioTime(uint64_t *time,uint32_t fq)=0;
-
+        {
+            return muxerRescaleVideoTime(time);
+        }
 protected:
         bool saveLoop(const char *title);
 protected:

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_coreMuxerFfmpeg.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_coreMuxerFfmpeg.cpp	2009-09-04 15:10:05 UTC (rev 5314)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_coreMuxerFfmpeg.cpp	2009-09-04 15:10:07 UTC (rev 5315)
@@ -256,7 +256,7 @@
           switch(audioheader->encoding)
           {
                   case WAV_AC3: c->codec_id = CODEC_ID_AC3;c->frame_size=6*256;break;
-                  case WAV_MP2: c->codec_id = CODEC_ID_MP2;break;
+                  case WAV_MP2: c->codec_id = CODEC_ID_MP2;c->frame_size=1152;break;
                   case WAV_MP3:
   #warning FIXME : Probe deeper
                               c->frame_size=1152;
@@ -367,7 +367,7 @@
             pkt.size= len;
             if(flags & 0x10) // FIXME AVI_KEY_FRAME
                         pkt.flags |= PKT_FLAG_KEY;
-            ret =av_write_frame(oc, &pkt);
+            ret =av_interleaved_write_frame(oc, &pkt);
             aprintf("[FF]Frame:%u, DTS=%08lu PTS=%08lu\n",written,dts,pts);
             if(ret)
             {
@@ -400,7 +400,7 @@
                     pkt.stream_index=1+audio;
                     pkt.data= audioBuffer;
                     pkt.size= audioSize;
-                    ret =av_write_frame(oc, &pkt);
+                    ret =av_interleaved_write_frame(oc, &pkt);
                     if(ret)
                     {
                         printf("[FF]Error writing audio packet\n");

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_muxerUtils.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_muxerUtils.cpp	2009-09-04 15:10:05 UTC (rev 5314)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_muxerUtils.cpp	2009-09-04 15:10:07 UTC (rev 5315)
@@ -49,8 +49,10 @@
 */
 uint64_t rescaleLavPts(uint64_t us, AVRational *scale)
 {
-
-     if(us==ADM_NO_PTS) return 0x8000000000000000LL;  // AV_NOPTS_VALUE
+#ifndef INT64_C
+#define INT64_C (uint64_t)
+#endif
+     if(us==ADM_NO_PTS) return AV_NOPTS_VALUE;  // AV_NOPTS_VALUE
     double db=(double)us;
     double s=scale->den;
 

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerFlv/muxerFlv.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerFlv/muxerFlv.cpp	2009-09-04 15:10:05 UTC (rev 5314)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerFlv/muxerFlv.cpp	2009-09-04 15:10:07 UTC (rev 5315)
@@ -145,17 +145,6 @@
 }
 
 
-bool muxerFlv::muxerRescaleVideoTime(uint64_t *time)
-{
-    AVRational *scale=&(video_st->codec->time_base);
-    *time=rescaleLavPts(*time,scale);
-    return true;
-}
-bool muxerFlv::muxerRescaleAudioTime(uint64_t *time,uint32_t fq)
-{
-    *time=*time/1000;
-    return true;
-}
 
 /**
     \fn close

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerFlv/muxerFlv.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerFlv/muxerFlv.h	2009-09-04 15:10:05 UTC (rev 5314)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerFlv/muxerFlv.h	2009-09-04 15:10:07 UTC (rev 5315)
@@ -31,8 +31,6 @@
 {
 protected:
 
-        bool muxerRescaleVideoTime(uint64_t *time);
-        bool muxerRescaleAudioTime(uint64_t *time,uint32_t fq);
 public:
                 muxerFlv();
         virtual ~muxerFlv();

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMkv/muxerMkv.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMkv/muxerMkv.cpp	2009-09-04 15:10:05 UTC (rev 5314)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMkv/muxerMkv.cpp	2009-09-04 15:10:07 UTC (rev 5315)
@@ -109,23 +109,6 @@
     return saveLoop(title);
 }
 
-bool muxerMkv::muxerRescaleVideoTime(uint64_t *time)
-{
-    if(*time==ADM_NO_PTS)
-    {
-        *time=AV_NOPTS_VALUE;
-        return true;
-    }
-    *time=*time/1000;
-
-    return true;
-}
-bool muxerMkv::muxerRescaleAudioTime(uint64_t *time,uint32_t fq)
-{
-
-   *time=*time/1000;
-    return true;
-}
 bool muxerMkv::muxerRescaleVideoTimeDts(uint64_t *time,uint64_t computedDts)
 {
     if(*time==ADM_NO_PTS)

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMkv/muxerMkv.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMkv/muxerMkv.h	2009-09-04 15:10:05 UTC (rev 5314)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMkv/muxerMkv.h	2009-09-04 15:10:07 UTC (rev 5315)
@@ -23,8 +23,6 @@
 class muxerMkv : public muxerFFmpeg
 {
 protected:
-        bool muxerRescaleVideoTime(uint64_t *time);
-        bool muxerRescaleAudioTime(uint64_t *time,uint32_t fq);
         bool muxerRescaleVideoTimeDts(uint64_t *time,uint64_t computedDts);
 public:
                 muxerMkv();

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4/muxerMP4.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4/muxerMP4.cpp	2009-09-04 15:10:05 UTC (rev 5314)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4/muxerMP4.cpp	2009-09-04 15:10:07 UTC (rev 5315)
@@ -132,23 +132,6 @@
     return saveLoop(title);
 }
 
-bool muxerMP4::muxerRescaleVideoTime(uint64_t *time)
-{
-    AVRational *scale=&(video_st->codec->time_base);
-    *time=rescaleLavPts(*time,scale);
-    return true;
-}
-bool muxerMP4::muxerRescaleAudioTime(uint64_t *time,uint32_t fq)
-{
-  AVPacket pkt;
-    double f=*time;
-    f*=fq; // In samples
-    f/=1000.*1000.; // In sec
-
-
-    *time=(uint64_t)(f+0.4);
-}
-  
 /**
     \fn close
     \brief Cleanup is done in the dtor

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4/muxerMP4.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4/muxerMP4.h	2009-09-04 15:10:05 UTC (rev 5314)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4/muxerMP4.h	2009-09-04 15:10:07 UTC (rev 5315)
@@ -36,8 +36,6 @@
 class muxerMP4 : public muxerFFmpeg
 {
 protected:
-        bool muxerRescaleVideoTime(uint64_t *time);
-        bool muxerRescaleAudioTime(uint64_t *time,uint32_t fq);
 public:
                 muxerMP4();
         virtual ~muxerMP4();

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffPS/muxerffPS.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffPS/muxerffPS.cpp	2009-09-04 15:10:05 UTC (rev 5314)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffPS/muxerffPS.cpp	2009-09-04 15:10:07 UTC (rev 5315)
@@ -159,6 +159,15 @@
         AVCodecContext *c;
         c = video_st->codec;
         rescaleFps(s->getAvgFps1000(),&(c->time_base));
+        // Override codec settings
+#define MKX(a,bsize,maxb) case a: c->bit_rate=maxb*1000;c->rc_buffer_size=bsize*8*1000;break;
+        switch(psMuxerConfig.muxingType)
+        {
+            MKX(MUXER_VCD,  40,1152)
+            MKX(MUXER_SVCD,112,2400)
+            MKX(MUXER_DVD, 224,9800)
+        }
+
         c->gop_size=15;
         
         if(initAudio(nbAudioTrack,a)==false)
@@ -175,8 +184,8 @@
             case MUXER_DVD:  oc->mux_rate=1152*1000;;break;
         }
        
-        oc->preload=AV_TIME_BASE/10; // 100 ms preloading
-        oc->max_delay=200*1000; // 500 ms
+        oc->preload=0; // 100 ms preloading
+        oc->max_delay=2000; // 500 ms
         if (av_set_parameters(oc, NULL) < 0)
         {
             printf("[ffPs]Lav: set param failed \n");
@@ -203,33 +212,18 @@
     const char *title=QT_TR_NOOP("Saving mpeg PS (ff)");
     return saveLoop(title);
 }
-#define INT64_C (uint64_t)
-bool muxerffPS::muxerRescaleVideoTime(uint64_t *time)
-{
-    if(*time==ADM_NO_PTS)
-    {
-        *time=AV_NOPTS_VALUE;
-        return true;
-    }
-    *time=*time/90;
-    
-    return true;
-}
+// Clock is 90 Khz for all mpeg streams
+// Since the unit is in us=10e6,
+// time=time/10E6*90E3
+// time=(time*9)/100
 bool muxerffPS::muxerRescaleVideoTimeDts(uint64_t *time,uint64_t computedDts)
 {
     if(*time==ADM_NO_PTS)
     {
         *time=computedDts;
-        return muxerRescaleVideoTime(time);
     }
     return muxerRescaleVideoTime(time);
 }
-
-bool muxerffPS::muxerRescaleAudioTime(uint64_t *time,uint32_t fq)
-{
-    *time=*time/90;
-    return true;
-}
   
 /**
     \fn close

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffPS/muxerffPS.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffPS/muxerffPS.h	2009-09-04 15:10:05 UTC (rev 5314)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffPS/muxerffPS.h	2009-09-04 15:10:07 UTC (rev 5315)
@@ -41,10 +41,8 @@
 class muxerffPS : public muxerFFmpeg
 {
 protected:
-        bool muxerRescaleVideoTime(uint64_t *time);
-        bool muxerRescaleVideoTimeDts(uint64_t *time,uint64_t computedDts);
         
-        bool muxerRescaleAudioTime(uint64_t *time,uint32_t fq);
+        bool muxerRescaleVideoTimeDts(uint64_t *time,uint64_t computedDts);
 
 public:
                 muxerffPS();



From mean at mail.berlios.de  Fri Sep  4 17:10:04 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 4 Sep 2009 17:10:04 +0200
Subject: [Avidemux-svn-commit] r5313 - in branches/avidemux_2.6_branch_mean:
	avidemux_core/ADM_coreMuxer/src
	avidemux_plugins/ADM_muxers/muxerffPS
Message-ID: <200909041510.n84FA4fs021441@sheep.berlios.de>

Author: mean
Date: 2009-09-04 17:10:03 +0200 (Fri, 04 Sep 2009)
New Revision: 5313

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_coreMuxerFfmpeg.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffPS/muxerffPS.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffPS/muxerffPS.h
Log:
[ff PS muxer] improve ps muxer, timestamps are still wrong

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_coreMuxerFfmpeg.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_coreMuxerFfmpeg.cpp	2009-09-04 15:10:01 UTC (rev 5312)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_coreMuxerFfmpeg.cpp	2009-09-04 15:10:03 UTC (rev 5313)
@@ -348,9 +348,8 @@
             {
                 lastVideoDts=dts;
             }
+            muxerRescaleVideoTimeDts(&dts,lastVideoDts);
             muxerRescaleVideoTime(&pts);
-            muxerRescaleVideoTime(&dts);
-
             aprintf("[FF:V] RawDts:%lu Scaled Dts:%lu\n",rawDts,dts);
             aprintf("[FF:V] Rescaled: Len : %d flags:%x Pts:%"LLU" Dts:%"LLU"\n",len,flags,pts,dts);
 

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffPS/muxerffPS.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffPS/muxerffPS.cpp	2009-09-04 15:10:01 UTC (rev 5312)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffPS/muxerffPS.cpp	2009-09-04 15:10:03 UTC (rev 5313)
@@ -168,12 +168,18 @@
         }
         
         // /audio
-        oc->mux_rate=10080*1000;
+        switch(psMuxerConfig.muxingType)
+        {
+            case MUXER_VCD:  oc->mux_rate=10080*1000;;break;
+            case MUXER_SVCD: oc->mux_rate=2500*1000;;break;
+            case MUXER_DVD:  oc->mux_rate=1152*1000;;break;
+        }
+       
         oc->preload=AV_TIME_BASE/10; // 100 ms preloading
         oc->max_delay=200*1000; // 500 ms
         if (av_set_parameters(oc, NULL) < 0)
         {
-            printf("Lav: set param failed \n");
+            printf("[ffPs]Lav: set param failed \n");
             return false;
         }
         if (url_fopen(&(oc->pb), file, URL_WRONLY) < 0)
@@ -197,29 +203,39 @@
     const char *title=QT_TR_NOOP("Saving mpeg PS (ff)");
     return saveLoop(title);
 }
-
 bool muxerffPS::muxerRescaleVideoTime(uint64_t *time)
 {
 #if 0
+    printf("<<in Video TS: %"LLU"\n",*time);
     AVRational *scale=&(video_st->codec->time_base);
     *time=rescaleLavPts(*time,scale);
-#else
-    *time=*time/1000;
+    printf(">>out Video TS: %"LLU"\n",*time);
 #endif
+#define INT64_C (uint64_t)
+    if(*time==ADM_NO_PTS) *time=AV_NOPTS_VALUE;
     return true;
 }
+bool muxerffPS::muxerRescaleVideoTimeDts(uint64_t *time,uint64_t computedDts)
+{
+    if(*time==ADM_NO_PTS)
+    {
+        *time=computedDts;
+        return muxerRescaleVideoTime(time);
+    }
+    return muxerRescaleVideoTime(time);
+}
+
 bool muxerffPS::muxerRescaleAudioTime(uint64_t *time,uint32_t fq)
 {
-#if 1
-   *time=*time/1000;
-    return true;
-#else
+#if 0
+    printf("Audio TS: %"LLU"\n",*time);
  AVPacket pkt;
     double f=*time;
     f*=fq; // In samples
     f/=1000.*1000.; // In sec
     *time=(uint64_t)(f+0.4);
 #endif
+    return true;
 }
   
 /**

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffPS/muxerffPS.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffPS/muxerffPS.h	2009-09-04 15:10:01 UTC (rev 5312)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffPS/muxerffPS.h	2009-09-04 15:10:03 UTC (rev 5313)
@@ -42,7 +42,10 @@
 {
 protected:
         bool muxerRescaleVideoTime(uint64_t *time);
+        bool muxerRescaleVideoTimeDts(uint64_t *time,uint64_t computedDts);
+        
         bool muxerRescaleAudioTime(uint64_t *time,uint32_t fq);
+
 public:
                 muxerffPS();
         virtual ~muxerffPS();



From mean at mail.berlios.de  Fri Sep  4 17:59:22 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 4 Sep 2009 17:59:22 +0200
Subject: [Avidemux-svn-commit] r5316 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerFlv
Message-ID: <200909041559.n84FxM93025675@sheep.berlios.de>

Author: mean
Date: 2009-09-04 17:59:19 +0200 (Fri, 04 Sep 2009)
New Revision: 5316

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerFlv/muxerFlv.cpp
Log:
[Flv muxer] Warn if the fq is unsupported for flv format

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerFlv/muxerFlv.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerFlv/muxerFlv.cpp	2009-09-04 15:10:07 UTC (rev 5315)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerFlv/muxerFlv.cpp	2009-09-04 15:59:19 UTC (rev 5316)
@@ -81,7 +81,14 @@
                 GUI_Error_HIG("Unsupported","Only AAC & mpegaudio supported for audio");
                 return false;
             }
+            uint32_t fq=a[i]->getInfo()->frequency;
+            if(fq!=44100 &&fq!=22050 && fq!=11025)
+            {
+                GUI_Error_HIG("Unsupported","Only 44.1, 22.050 and 11.025 kHz supported");
+                return false;
+            }
 
+
         }
 
     if(false==setupMuxer("flv",file))



From mean at mail.berlios.de  Fri Sep  4 17:59:29 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 4 Sep 2009 17:59:29 +0200
Subject: [Avidemux-svn-commit] r5317 - in
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg:
	libavformat patches
Message-ID: <200909041559.n84FxTOC025690@sheep.berlios.de>

Author: mean
Date: 2009-09-04 17:59:26 +0200 (Fri, 04 Sep 2009)
New Revision: 5317

Added:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavformat_mpegtsenc.c.patch
Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/mpegtsenc.c
Log:
[Core/ffmpeg] Add TS muxer init

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/mpegtsenc.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/mpegtsenc.c	2009-09-04 15:59:19 UTC (rev 5316)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/mpegtsenc.c	2009-09-04 15:59:26 UTC (rev 5317)
@@ -809,3 +809,8 @@
     mpegts_write_packet,
     mpegts_write_end,
 };
+int mpegtsenc_init(void)
+{
+    av_register_output_format(&mpegts_muxer);
+    return 0;
+}
\ No newline at end of file

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavformat_mpegtsenc.c.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavformat_mpegtsenc.c.patch	2009-09-04 15:59:19 UTC (rev 5316)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavformat_mpegtsenc.c.patch	2009-09-04 15:59:26 UTC (rev 5317)
@@ -0,0 +1,12 @@
+--- libavformat/mpegtsenc.c
++++ libavformat/mpegtsenc.c
+@@ -809,3 +809,8 @@ AVOutputFormat mpegts_muxer = {
+     mpegts_write_packet,
+     mpegts_write_end,
+ };
++int mpegtsenc_init(void)
++{
++    av_register_output_format(&mpegts_muxer);
++    return 0;
++}
+\ No newline at end of file



From mean at mail.berlios.de  Fri Sep  4 17:59:39 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 4 Sep 2009 17:59:39 +0200
Subject: [Avidemux-svn-commit] r5318 -
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src
Message-ID: <200909041559.n84FxdPe025703@sheep.berlios.de>

Author: mean
Date: 2009-09-04 17:59:36 +0200 (Fri, 04 Sep 2009)
New Revision: 5318

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_dynaMuxer.cpp
Log:
[Core/ffmpeg] Add TS muxer init

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_dynaMuxer.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_dynaMuxer.cpp	2009-09-04 15:59:26 UTC (rev 5317)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_dynaMuxer.cpp	2009-09-04 15:59:36 UTC (rev 5318)
@@ -177,6 +177,7 @@
 extern void flvenc_init(void);
 extern void matroskaenc_init(void);
 extern void mpegenc_init(void);
+extern void mpegtsenc_init(void);
 }
 extern struct URLProtocol file_protocol ;
 /**
@@ -191,6 +192,7 @@
         flvenc_init();
         matroskaenc_init();
         mpegenc_init();
+        mpegtsenc_init();
         av_register_protocol(&file_protocol);
 }
 // EOF



From mean at mail.berlios.de  Fri Sep  4 17:59:43 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 4 Sep 2009 17:59:43 +0200
Subject: [Avidemux-svn-commit] r5319 - in
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers:
	. muxerffTS
Message-ID: <200909041559.n84Fxh0X025719@sheep.berlios.de>

Author: mean
Date: 2009-09-04 17:59:41 +0200 (Fri, 04 Sep 2009)
New Revision: 5319

Added:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffTS/
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffTS/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffTS/muxerffTS.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffTS/muxerffTS.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffTS/muxerffTSConfig.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffTS/muxerffTSPlugin.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/CMakeLists.txt
Log:
[Muxer] Add simple mpeg TS muxer

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/CMakeLists.txt	2009-09-04 15:59:36 UTC (rev 5318)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/CMakeLists.txt	2009-09-04 15:59:41 UTC (rev 5319)
@@ -5,3 +5,4 @@
 ADD_SUBDIRECTORY(muxerFlv)
 ADD_SUBDIRECTORY(muxerMkv)
 ADD_SUBDIRECTORY(muxerffPS)
+ADD_SUBDIRECTORY(muxerffTS)

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffTS/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffTS/CMakeLists.txt	2009-09-04 15:59:36 UTC (rev 5318)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffTS/CMakeLists.txt	2009-09-04 15:59:41 UTC (rev 5319)
@@ -0,0 +1,14 @@
+include(mx_plugin)
+SET(ADM_ffTS_SRCS 
+	muxerffTS.cpp
+	muxerffTSPlugin.cpp
+        muxerffTSConfig.cpp
+)
+
+ADD_LIBRARY(ADM_mx_ffTS SHARED ${ADM_ffTS_SRCS})
+
+INCLUDE_DIRECTORIES("${AVIDEMUX_SOURCE_DIR}/avidemux/ADM_libraries/ADM_ffmpeg")
+TARGET_LINK_LIBRARIES(ADM_mx_ffTS  ADM_libavutil6 ADM_libavcodec6 ADM_libavformat6)
+INIT_MUXER(ADM_mx_ffTS)
+INSTALL_MUXER(ADM_mx_ffTS)
+

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffTS/muxerffTS.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffTS/muxerffTS.cpp	2009-09-04 15:59:36 UTC (rev 5318)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffTS/muxerffTS.cpp	2009-09-04 15:59:41 UTC (rev 5319)
@@ -0,0 +1,164 @@
+/***************************************************************************
+            \file            muxerffTS
+            \brief           i/f to lavformat PS muxer
+                             -------------------
+    
+    copyright            : (C) 2009 by mean
+    email                : fixounet at free.fr
+        
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "ADM_default.h"
+#include "fourcc.h"
+#include "muxerffTS.h"
+#include "DIA_coreToolkit.h"
+#include "ADM_muxerUtils.h"
+#include "ADM_codecType.h"
+#if 0
+#define aprintf(...) {}
+#else
+#define aprintf printf
+#endif
+
+tsMuxerConfig_s tsMuxerConfig=
+{
+    false
+};
+
+/**
+    \fn     muxerffTS
+    \brief  Constructor
+*/
+muxerffTS::muxerffTS() 
+{
+};
+/**
+    \fn     muxerffTS
+    \brief  Destructor
+*/
+
+muxerffTS::~muxerffTS() 
+{
+   
+}
+/**
+    \fn open
+    \brief Check that the streams are ok, initialize context...
+*/
+
+bool muxerffTS::open(const char *file, ADM_videoStream *s,uint32_t nbAudioTrack,ADM_audioStream **a)
+{
+    uint32_t fcc=s->getFCC();
+    uint32_t w,h;
+     w=s->getWidth();
+     h=s->getHeight();
+        
+     if(!isMpeg12Compatible(fcc))
+     {
+            printf("[ffTS] video not compatible\n");
+            return false;
+     }
+   
+    if(!nbAudioTrack) 
+        {
+            printf("[ffTS] One audio track needed\n");
+            return false;
+        }
+   
+    /* All seems fine, open stuff */
+    const char *fmt="mpegts";
+    
+    if(false==setupMuxer(fmt,file))
+    {
+        printf("[ffTS] Failed to open muxer\n");
+        return false;
+    }
+ 
+   if(initVideo(s)==false) 
+    {
+        printf("[ffTS] Failed to init video\n");
+        return false;
+    }
+  
+    
+        AVCodecContext *c;
+        c = video_st->codec;
+        rescaleFps(s->getAvgFps1000(),&(c->time_base));
+
+
+        c->gop_size=15;
+        
+        if(initAudio(nbAudioTrack,a)==false)
+        {
+            printf("[ffTS] Failed to init audio\n");
+            return false;
+        }
+        
+        // /audio
+        oc->mux_rate=30080*1000;
+        
+       
+        oc->preload=3000; // 30 ms preloading
+        oc->max_delay=2000; // 500 ms
+        if (av_set_parameters(oc, NULL) < 0)
+        {
+            printf("[ffTS]Lav: set param failed \n");
+            return false;
+        }
+        if (url_fopen(&(oc->pb), file, URL_WRONLY) < 0)
+        {
+            printf("[ffTS]: Failed to open file :%s\n",file);
+            return false;
+        }
+
+        ADM_assert(av_write_header(oc)>=0);
+        vStream=s;
+        aStreams=a;
+        nbAStreams=nbAudioTrack;
+        return true;
+}
+
+/**
+    \fn save
+*/
+bool muxerffTS::save(void) 
+{
+    const char *title=QT_TR_NOOP("Saving mpeg TS (ff)");
+    return saveLoop(title);
+}
+// Clock is 90 Khz for all mpeg streams
+// Since the unit is in us=10e6,
+// time=time/10E6*90E3
+// time=(time*9)/100
+bool muxerffTS::muxerRescaleVideoTimeDts(uint64_t *time,uint64_t computedDts)
+{
+    if(*time==ADM_NO_PTS)
+    {
+        *time=computedDts;
+    }
+    return muxerRescaleVideoTime(time);
+}
+  
+/**
+    \fn close
+    \brief Cleanup is done in the dtor
+*/
+bool muxerffTS::close(void) 
+{
+   
+    printf("[ffTS] Closing\n");
+    return closeMuxer();
+}
+
+//EOF
+
+
+

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffTS/muxerffTS.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffTS/muxerffTS.h	2009-09-04 15:59:36 UTC (rev 5318)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffTS/muxerffTS.h	2009-09-04 15:59:41 UTC (rev 5319)
@@ -0,0 +1,49 @@
+/***************************************************************************
+                          oplug_vcdff.h  -  description
+                             -------------------
+    begin                : Sun Nov 10 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef ADM_MUXER_ffTS
+#define ADM_MUXER_ffTS
+
+#include "ADM_muxer.h"
+#include "ADM_coreMuxerFfmpeg.h"
+
+typedef struct
+{
+ 
+    bool         acceptNonCompliant;
+}tsMuxerConfig_s;
+
+extern tsMuxerConfig_s tsMuxerConfig;
+
+/**
+    \fn class muxerffTS
+*/
+class muxerffTS : public muxerFFmpeg
+{
+protected:
+        
+        bool muxerRescaleVideoTimeDts(uint64_t *time,uint64_t computedDts);
+
+public:
+                muxerffTS();
+        virtual ~muxerffTS();
+        virtual bool open(const char *file, ADM_videoStream *s,uint32_t nbAudioTrack,ADM_audioStream **a);
+        virtual bool save(void) ;
+        virtual bool close(void) ;
+
+};
+
+#endif

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffTS/muxerffTSConfig.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffTS/muxerffTSConfig.cpp	2009-09-04 15:59:36 UTC (rev 5318)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffTS/muxerffTSConfig.cpp	2009-09-04 15:59:41 UTC (rev 5319)
@@ -0,0 +1,27 @@
+/***************************************************************************
+    copyright            : (C) 2007 by mean
+    email                : fixounet at free.fr
+    
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "ADM_default.h"
+#include "ADM_muxerInternal.h"
+#include "muxerffTS.h"
+#define ADM_MINIMAL_UI_INTERFACE
+#include "DIA_factory.h"
+#include "fourcc.h"
+bool ffTSConfigure(void)
+{
+            return true;
+}
+// EOF
+
+

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffTS/muxerffTSPlugin.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffTS/muxerffTSPlugin.cpp	2009-09-04 15:59:36 UTC (rev 5318)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffTS/muxerffTSPlugin.cpp	2009-09-04 15:59:41 UTC (rev 5319)
@@ -0,0 +1,32 @@
+/***************************************************************************
+    copyright            : (C) 2007 by mean
+    email                : fixounet at free.fr
+    
+      See lavformat/flv[dec/env].c for detail
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "ADM_default.h"
+#include "ADM_muxerInternal.h"
+#include "muxerffTS.h"
+
+#include "fourcc.h"
+ bool ffTSConfigure(void);
+
+ADM_MUXER_BEGIN( muxerffTS,
+                    1,0,0,
+                    "ffTS",    // Internal name
+                    "ffMpeg PS muxer plugin (c) Mean 2009",
+                    "ffTS Muxer", // DIsplay name
+                    ffTSConfigure,
+                    &tsMuxerConfig,
+                    sizeof(tsMuxerConfig)
+                );
+



From mean at mail.berlios.de  Sat Sep  5 10:19:13 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 5 Sep 2009 10:19:13 +0200
Subject: [Avidemux-svn-commit] r5320 - in
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers:
	. muxerMplex
Message-ID: <200909050819.n858JDEp017038@sheep.berlios.de>

Author: mean
Date: 2009-09-05 10:19:09 +0200 (Sat, 05 Sep 2009)
New Revision: 5320

Added:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ADM_inout.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ADM_mplexInput.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ADM_mplexMuxer.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ADM_mplexOutput.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ADM_mthread.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ADM_mthread.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ADM_transfert.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ADM_transfert.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ac3strm_in.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/audiostrm.hpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/audiostrm_out.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/aunit.hpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/aunitbuffer.hpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/bits.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/bits.hpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/cpu_accel.c
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/cpu_accel.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/decodebufmodel.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/decodebufmodel.hpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/dtsstrm_in.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/format_codes.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/inputstrm.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/inputstrm.hpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/interact.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/interact.hpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/lpcmstrm_in.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/mjpeg_logging.c
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/mjpeg_logging.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/mjpeg_types.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/mpastrm_in.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/mpegconsts.c
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/mpegconsts.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/mplexconsts.hpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/multiplexor.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/multiplexor.hpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/outputstrm.hpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/padstrm.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/padstrm.hpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/stillsstream.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/stillsstream.hpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/streamType.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/stream_params.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/stream_params.hpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/systems.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/systems.hpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/videostrm.hpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/videostrm_in.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/videostrm_out.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/yuv4mpeg.c
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/yuv4mpeg.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/yuv4mpeg_intern.h
Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/CMakeLists.txt
Log:
[Muxer] Added mplex, verbatime from 2.5

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/CMakeLists.txt	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/CMakeLists.txt	2009-09-05 08:19:09 UTC (rev 5320)
@@ -5,4 +5,5 @@
 ADD_SUBDIRECTORY(muxerFlv)
 ADD_SUBDIRECTORY(muxerMkv)
 ADD_SUBDIRECTORY(muxerffPS)
+ADD_SUBDIRECTORY(muxerMplex)
 ADD_SUBDIRECTORY(muxerffTS)

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ADM_inout.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ADM_inout.h	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ADM_inout.h	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,53 @@
+//
+// C++ Interface: %{MODULE}
+//
+// Description: 
+//
+//
+// Author: %{AUTHOR} <%{EMAIL}>, (C) %{YEAR}
+//
+// Copyright: See COPYING file that comes with this distribution
+//
+//
+#ifndef _ADM_IN_OUT_
+#define _ADM_IN_OUT_
+
+#ifndef MAXPATHLEN
+#define MAXPATHLEN 1024
+#endif
+
+#include "ADM_transfert.h"
+
+class FileOutputStream : public OutputStream
+{
+public:
+    FileOutputStream( const char *filename_pat );
+    virtual int  Open( );
+    virtual void Close();
+    virtual off_t SegmentSize( );
+    virtual void NextSegment();
+    virtual void Write(uint8_t *data, unsigned int len);
+
+private:
+    FILE *strm;
+    int strm_fd;
+    char filename_pat[MAXPATHLEN];
+    char cur_filename[MAXPATHLEN];
+
+};
+
+class IFileBitStream : public IBitStream
+{
+public:
+        IFileBitStream( PacketQueue *inQueue, mplexStreamDescriptor *streamDesc,unsigned int buf_size = BUFFER_SIZE);
+        ~IFileBitStream();
+
+private:
+        PacketQueue       *queue;
+        virtual size_t ReadStreamBytes( uint8_t *buf, size_t number ) ;
+        virtual bool EndOfStream() ;
+        
+};
+
+#endif
+//EOF

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ADM_mplexInput.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ADM_mplexInput.cpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ADM_mplexInput.cpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,90 @@
+
+#include "ADM_default.h"
+#include "ADM_threads.h"
+#include "interact.hpp"
+
+#undef malloc
+#undef realloc
+#undef free
+
+
+
+#include "ADM_osSupport/ADM_debugID.h"
+#define MODULE_NAME MODULE_LAVFORMAT
+#include "ADM_osSupport/ADM_debug.h"
+
+#include "cpu_accel.h"
+#include "mjpeg_types.h"
+#include "mjpeg_logging.h"
+#include "mpegconsts.h"
+
+#include "bits.hpp"
+#include "outputstrm.hpp"
+#include "multiplexor.hpp"
+
+#include "ADM_inout.h"
+#include "ADM_transfert.h"
+
+
+/******************************************************************************/
+/********************************
+ *
+ * IFileBitStream - Input bit stream class for bit streams sourced
+ * from standard file I/O (this of course *includes* network sockets,
+ * fifo's, et al).
+ *
+ * OLAF: To hook into your PES reader/reconstructor you need to define
+ * a class like this one, where 'ReadStreamBytes' calls you code to
+ * generate the required number of bytes of ES data and transfer it 
+ * to the specified buffer.  The logical way to do this would be to
+ * inherit IBitStream as a base class of the top-level classes for the ES
+ * reconstructors.
+ *
+ ********************************/
+
+bool IFileBitStream::EndOfStream(void) 
+{
+        if(queue->isEof()) return true;
+        return false;
+
+}
+
+IFileBitStream::IFileBitStream(PacketQueue *q, mplexStreamDescriptor *desc, unsigned int buf_size) : IBitStream(desc) //MEANX
+{
+        queue=q;        
+        SetBufSize(buf_size);
+        eobs = false;
+        byteidx = 0;
+        
+        if (!ReadIntoBuffer())
+        {
+                        ADM_assert(buffered);
+                
+        }
+        
+}
+
+
+/**
+   Destructor: close the device containing the bit stream after a read
+   process
+*/
+IFileBitStream::~IFileBitStream()
+{
+        
+        
+        Release();
+}
+/**
+
+*/
+ size_t IFileBitStream::ReadStreamBytes( uint8_t *buf, size_t number )
+ {
+uint32_t s,z;
+        if(!queue->Pop(buf,&z,&s)) return 0;
+      ADM_assert(z);
+      ADM_assert(z<=number);
+        return z;
+ }
+ //EOF
+ 

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ADM_mplexMuxer.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ADM_mplexMuxer.cpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ADM_mplexMuxer.cpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,377 @@
+//
+// C++ Implementation: %{MODULE}
+//
+// Description:
+//
+//
+// Author: %{AUTHOR} <%{EMAIL}>, (C) %{YEAR}
+//
+// Copyright: See COPYING file that comes with this distribution
+//
+//
+
+
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include <sys/stat.h>
+
+#include "ADM_default.h"
+#include "ADM_threads.h"
+
+#include "interact.hpp"
+
+#undef malloc
+#undef realloc
+#undef free
+
+
+#include "ADM_audiofilter/audioprocess.hxx"
+#include "ADM_audio/ADM_a52info.h"
+#include "avifmt.h"
+#include "avifmt2.h"
+#include "ADM_editor/ADM_Video.h"
+#include "ADM_outputs/ADM_lavformat.h"
+
+#include "ADM_osSupport/ADM_debugID.h"
+#define MODULE_NAME MODULE_LAVFORMAT
+#include "ADM_osSupport/ADM_debug.h"
+
+#include "cpu_accel.h"
+#include "mjpeg_types.h"
+#include "mjpeg_logging.h"
+#include "mpegconsts.h"
+
+#include "bits.hpp"
+#include "outputstrm.hpp"
+#include "multiplexor.hpp"
+
+#include "ADM_inout.h"
+#include "multiplexor.hpp"
+
+/* 
+        Define class to handle output stream(s)
+      
+*/
+
+
+//#define VERBOSE_GOP
+
+
+/***************************************************************************/
+
+
+static PacketQueue     *channelaudio=NULL;
+static PacketQueue     *channelvideo=NULL;
+static FileOutputStream *outputStream=NULL;
+static IFileBitStream   *audioin=NULL;
+static IFileBitStream   *videoin=NULL;
+static uint32_t         fps1000;
+static int              mux_format;
+static int              slaveRunning=0;
+
+static  vector<IBitStream *> inputs;
+
+static int slaveThread( WAVHeader *audioheader );
+
+admMutex mutex_slaveThread_problem("mutex_slaveThread_problem");
+admCond  *cond_slaveThread_problem;
+char * kind_of_slaveThread_problem;
+unsigned int kind_of_slaveThread_problem_rc;
+extern uint8_t DIA_quota( char * msg );
+
+typedef  void * (*THRINP)(void *p);
+//___________________________________________________________________________
+mplexMuxer::mplexMuxer( void )
+{
+        _running=0;
+        _restamp=0;
+	cond_slaveThread_problem = new admCond(&mutex_slaveThread_problem);
+	kind_of_slaveThread_problem = 0;
+
+	mjpeg_default_handler_verbosity(1);
+}
+//___________________________________________________________________________
+mplexMuxer::~mplexMuxer()
+{
+        close();
+}
+//___________________________________________________________________________
+uint8_t mplexMuxer::audioEof(void)
+{
+        channelaudio->Abort();
+}
+uint8_t mplexMuxer::videoEof(void)
+{
+  channelvideo->Abort();
+}
+
+//___________________________________________________________________________
+uint8_t mplexMuxer::open(const char *filename, uint32_t inbitrate,ADM_MUXER_TYPE type, aviInfo *info, WAVHeader *audioheader)
+{
+        printf("Opening mplex muxer (%s)\n",filename);
+        _running=1;
+
+        
+        channelaudio=new PacketQueue(  "Mplex audioQ",TRANSFERT_SLOT,TRANSFERT_BUFFER);
+        channelvideo=new PacketQueue(  "Mplex videoQ",TRANSFERT_SLOT,TRANSFERT_BUFFER);
+        
+        outputStream=new FileOutputStream ( filename );
+        
+        fps1000=info->fps1000;
+        
+        switch(type)
+        {
+                case MUXER_DVD: mux_format=MPEG_FORMAT_DVD_NAV;break; //FIXME
+                case MUXER_VCD: mux_format=MPEG_FORMAT_VCD;break;
+                case MUXER_SVCD:mux_format=MPEG_FORMAT_SVCD;break;
+                default:
+                        printf("Unknown muxing type\n");
+                        ADM_assert(0);
+        }
+        printf("mplex type is :%d\n",mux_format);
+       
+       
+        
+        printf("creating slave thread\n");
+        
+        pthread_t slave;
+        slaveRunning=1;
+        ADM_assert(!pthread_create(&slave,NULL,(THRINP)slaveThread,audioheader));
+
+        ADM_usleep(1000*50); // Allow slave thread to start
+        
+        printf("Init ok\n");
+        return 1;
+}
+
+extern const char *getStrFromAudioCodec( uint32_t codec);
+static uint8_t wavToStreamType(WAVHeader *hdr,mplexStreamDescriptor *desc)
+{
+    ADM_assert(hdr);
+    desc->frequency=hdr->frequency;
+    desc->channel=hdr->channels;
+    switch(hdr->encoding)
+    {
+        case WAV_LPCM:  desc->kind= LPCM_AUDIO;break;
+        case WAV_AC3:   desc->kind=  AC3_AUDIO;;break;
+        case WAV_MP2: case WAV_MP3:   desc->kind=  MPEG_AUDIO;;break;
+        case WAV_DTS:    desc->kind=  DTS_AUDIO;;break;
+        default: return 0;
+    }
+  return 1;
+}
+
+int slaveThread( WAVHeader *audioheader )
+{
+        MultiplexJob job;
+        mplexStreamDescriptor audioDesc;
+        mplexStreamDescriptor videoDesc;
+
+        printf("[Muxer Slave Thread] Creating job & muxer\n");
+        wavToStreamType(audioheader,&audioDesc);
+
+        printf("output file created\n");
+        audioin=new IFileBitStream(channelaudio,&audioDesc);
+        
+        printf("audio done (%s), creating video bitstream\n",getStrFromAudioCodec(audioheader->encoding));
+        videoDesc.kind=MPEG_VIDEO;
+
+        videoin=new IFileBitStream(channelvideo,&videoDesc);
+        
+        printf("Both stream ready\n");
+         
+        inputs.push_back( videoin );
+        inputs.push_back( audioin );
+        
+        job.mux_format=mux_format;
+        job.SetupInputStreams( inputs );
+
+        Multiplexor mux(job, *outputStream);
+               
+        printf("[Muxer Slave Thread] Muxing\n");
+        mux.Multiplex();
+
+        slaveRunning=0;
+        printf("[Muxer Slave Thread] Exiting\n");
+        pthread_exit(0);
+}        
+//___________________________________________________________________________
+uint8_t mplexMuxer::writeAudioPacket(uint32_t len, uint8_t *buf)
+{
+        
+        return channelaudio->Push(buf,len,0);
+}
+//___________________________________________________________________________
+uint8_t mplexMuxer::needAudio( void )
+{
+        
+       return 1;
+}
+static uint8_t seq_start_code [] = {0x00, 0x00, 0x01, 0xB3};
+static uint8_t gop_start_code [] = {0x00, 0x00, 0x01, 0xB8};
+
+//___________________________________________________________________________
+uint8_t mplexMuxer::writeVideoPacket(ADMBitstream *bitstream)
+{
+uint8_t r=0;   
+uint16_t a1,a2,a3,a4,ff;           
+        if(_restamp) // restamp timecode ?
+        {
+            if ( !memcmp(bitstream->data, seq_start_code, 4) || !memcmp(bitstream->data, gop_start_code, 4) )
+                {
+                        uint8_t *ptr;
+                        uint32_t size;
+                        
+                        ptr=bitstream->data;
+                        size=bitstream->len;
+                        // There is a gop a or seq header
+                        if(bitstream->data[3]==0xb3) // Seq
+                        {
+                                while((ptr[0] || ptr[1] || ptr[2]!=1 || ptr[3]!=0xB8 ) && size>0)
+                                {
+                                        ptr++;
+                                        size--;
+                                }
+                        
+                        }
+                        if(!size || size < 8) 
+                        {
+                                printf("Mplex:Gop/seq inconsistency\n");
+                        }
+                        else
+                        {       // Now we are at gop start with a packet size
+                                // Compute the current gop timestamp
+                                double newtime=bitstream->ptsFrame;
+                                uint32_t hh,mm,ss,ms;
+                                
+                                ptr+=4; // skip gop header go to timestamp
+                                
+#ifdef VERBOSE_GOP              
+                               
+                                                       
+                                a1=*ptr;
+                                a2=*(ptr+1);
+                                a3=*(ptr+2);
+                                a4=*(ptr+3);
+                                hh=(a1>>2)&0x1f;
+                                mm=((a1&3)<<4)+(a2>>4);
+                                ss=((a2&7)<<3)+(a3>>5);
+                                ff=((a3&0x1f)<<1)+(a4>>7);
+
+                                printf("Old : h:%02d m:%02d s:%02d f:%02d\n",hh,mm,ss,ff);
+#endif  
+                                
+                                newtime=(newtime*1000);
+                                newtime/=fps1000; // in seconds
+                                
+                                hh=(uint32_t)newtime/3600;
+                                newtime-=hh*3600;
+                                mm=(uint32_t)newtime/60;
+                                newtime-=mm*60;
+                                ss=(uint32_t)newtime;
+                                newtime-=ss;
+                                newtime*=1000;
+                                ms=(uint32_t)newtime;
+                                
+                                *(ptr+0)=(hh<<2)+(mm>>4);
+                                *(ptr+1)=((mm&0xf)<<4)+8+(ss>>3);
+                                *(ptr+2)= ((ss&7)<<5)+(ms>>1);
+                                *(ptr+3)&=0x7f;
+                                *(ptr+3)+=(ms&1) <<7;
+                                
+#ifdef VERBOSE_GOP              
+                               
+                                                       
+                                a1=*ptr;
+                                a2=*(ptr+1);
+                                a3=*(ptr+2);
+                                a4=*(ptr+3);
+                                hh=(a1>>2)&0x1f;
+                                mm=((a1&3)<<4)+(a2>>4);
+                                ss=((a2&7)<<3)+(a3>>5);
+                                ff=((a3&0x1f)<<1)+(a4>>7);
+
+                                printf("New : h:%02d m:%02d s:%02d f:%02d\n",hh,mm,ss,ff);
+#endif  
+                                
+                        
+                        }
+        
+                }
+        }
+
+        if( cond_slaveThread_problem->iswaiting() )
+        {
+               kind_of_slaveThread_problem_rc = DIA_quota(kind_of_slaveThread_problem);
+               cond_slaveThread_problem->wakeup();
+         }
+        // Check for overflow
+        // Should not happen on audio
+#warning the value is set also in mplex as BitStreamBuffering::BUFFER_SIZE
+#define INPUT_MAX_BLOCK (64*1024-1)
+        uint8_t *ptr=bitstream->data;
+        uint32_t len=bitstream->len;
+
+        while(len)
+        {
+          if(len>INPUT_MAX_BLOCK)
+          {
+              channelvideo->Push(ptr,INPUT_MAX_BLOCK,0);
+              len-=INPUT_MAX_BLOCK;
+              ptr+=INPUT_MAX_BLOCK;
+          }
+          else
+          {
+            channelvideo->Push(ptr,len,0);
+            len=0;
+          }
+        }
+        return 1;
+}
+//___________________________________________________________________________
+uint8_t mplexMuxer::forceRestamp(void)
+{
+        _restamp=1;
+        return 1;
+}
+//___________________________________________________________________________
+uint8_t mplexMuxer::close( void )
+{
+        if(_running)
+        {
+                _running=0;
+                channelvideo->Abort();
+                channelaudio->Abort();
+                while(slaveRunning)
+                {
+                        printf("Waiting for slave thread to end\n");
+                        ADM_usleep(100*1000);
+                }
+                        // Flush
+                        // Cause deadlock :
+                delete audioin;
+                delete videoin;
+                delete channelvideo;
+                delete channelaudio;
+                delete outputStream;
+                inputs.erase( inputs.begin(), inputs.end() );
+                printf("Mplex : All destroyed\n");
+        }
+        return 1;
+}
+//___________________________________________________________________________
+uint8_t mplexMuxer::audioEmpty( void)
+{
+        return 0;
+}
+
+
+//EOF

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ADM_mplexOutput.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ADM_mplexOutput.cpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ADM_mplexOutput.cpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,148 @@
+//
+// C++ Implementation: %{MODULE}
+//
+// Description:
+//
+//
+// Author: %{AUTHOR} <%{EMAIL}>, (C) %{YEAR}
+//
+// Copyright: See COPYING file that comes with this distribution
+//
+//
+
+#include <sys/stat.h>
+#include <errno.h>
+
+#include "ADM_default.h"
+#include "ADM_threads.h"
+#include "interact.hpp"
+
+#undef malloc
+#undef realloc
+#undef free
+
+
+
+#include "ADM_osSupport/ADM_debugID.h"
+#define MODULE_NAME MODULE_LAVFORMAT
+#include "ADM_osSupport/ADM_debug.h"
+
+#include "cpu_accel.h"
+#include "mjpeg_types.h"
+#include "mjpeg_logging.h"
+#include "mpegconsts.h"
+
+#include "bits.hpp"
+#include "outputstrm.hpp"
+#include "multiplexor.hpp"
+
+#include "ADM_inout.h"
+
+extern admMutex mutex_slaveThread_problem;
+extern admCond  *cond_slaveThread_problem;
+extern char * kind_of_slaveThread_problem;
+extern unsigned int kind_of_slaveThread_problem_rc;
+
+FileOutputStream::FileOutputStream( const char *name_pat ) 
+{
+        strncpy( filename_pat, name_pat, MAXPATHLEN );
+        snprintf( cur_filename, MAXPATHLEN, filename_pat, segment_num );
+	strm_fd = -1;
+}
+      
+int FileOutputStream::Open()
+{
+  char msg[512];
+   while( !(strm = fopen( cur_filename, "wb" )) ){
+      if( errno == ENOSPC
+#ifndef __MINGW32__
+                          || errno == EDQUOT
+#endif
+                                             ){
+         ADM_assert(snprintf(msg,512,"can't open \"%s\": %s\n%s\n",
+                             cur_filename,
+                             (errno==ENOSPC?"filesystem full":"quota exceeded"),
+                             "Please free up some space and press RETRY to try again.")!=-1);
+         mutex_slaveThread_problem.lock();
+           kind_of_slaveThread_problem = ADM_strdup(msg);
+           cond_slaveThread_problem->wait(); /* implicit mutex_slaveThread_problem.unlock(); */
+           ADM_dealloc(kind_of_slaveThread_problem);
+           kind_of_slaveThread_problem = NULL;
+         if( kind_of_slaveThread_problem_rc == 0 ){ /* ignore */
+            /* it doesn't make any sense to continue */
+            mjpeg_error_exit1( "Could not open for writing: %s", cur_filename );
+         }
+      }else{
+         fprintf(stderr,"can't open \"%s\": %u (%s)\n", cur_filename, errno, strerror(errno));
+         ADM_assert(0);
+      }
+   }
+   strm_fd = fileno(strm);
+   return 0;
+}
+
+void FileOutputStream::Close()
+{ 
+    fclose(strm);
+    strm_fd = -1;
+}
+
+
+off_t
+FileOutputStream::SegmentSize()
+{
+        struct stat stb;
+    fstat(fileno(strm), &stb);
+        off_t written = stb.st_size;
+    return written;
+}
+
+void 
+FileOutputStream::NextSegment( )
+{
+        Close();
+        ++segment_num;
+    
+        cur_filename[strlen(cur_filename)-1]++; // increase
+        Open();
+}
+
+void
+FileOutputStream::Write( uint8_t *buf, unsigned int len )
+{
+  uint8_t *p = buf;
+  unsigned int plen = len;
+  int rc;
+   ADM_assert(strm_fd != -1);
+   while( (rc=write(strm_fd,p,plen)) != plen ){
+      if( rc > 0 ){
+         p+=rc;
+         plen-=rc;
+         continue;
+      }
+      if( rc == -1 && (errno == ENOSPC
+#ifndef __MINGW32__
+                                       || errno == EDQUOT
+#endif
+                                                          ) ){
+        char msg[512];
+         fprintf(stderr,"slaveThread: we have a problem. errno=%u\n",errno);
+         ADM_assert(snprintf(msg,512,"can't write to file \"%s\": %s\n%s\n",
+                             cur_filename,
+                             (errno==ENOSPC?"filesystem full":"quota exceeded"),
+                             "Please free up some space and press RETRY to try again.")!=-1);
+         mutex_slaveThread_problem.lock();
+           kind_of_slaveThread_problem = ADM_strdup(msg);
+           cond_slaveThread_problem->wait(); /* implicit mutex_slaveThread_problem.unlock(); */
+           ADM_dealloc(kind_of_slaveThread_problem);
+           kind_of_slaveThread_problem = NULL;
+         if( kind_of_slaveThread_problem_rc == 0 ){ /* ignore */
+            /* it doesn't make any sense to continue */
+            mjpeg_error_exit1( "Failed write: %s", cur_filename );
+         }
+      }else{
+         mjpeg_error_exit1( "Failed write: %s", cur_filename );
+      }
+   }
+}
+

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ADM_mthread.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ADM_mthread.cpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ADM_mthread.cpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,129 @@
+/***************************************************************************
+    copyright            : (C) 2006 by mean
+    email                : fixounet at free.fr
+    
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+
+#include "ADM_default.h"
+#include "ADM_threads.h"
+
+
+#include "ADM_editor/ADM_edit.hxx"
+#include "ADM_videoFilter.h"
+#include "ADM_encoder/ADM_vidEncode.hxx"
+#include "ADM_encoder/adm_encoder.h"
+#include "ADM_userInterfaces/ADM_commonUI/DIA_encoding.h"
+#include "ADM_audiofilter/audioprocess.hxx"
+#include "ADM_audiofilter/audioeng_buildfilters.h"
+#include "ADM_outputs/ADM_lavformat.h"
+#include "ADM_mthread.h"
+
+admMutex accessMutex("accessMutex_MT_muxer");
+
+//*******************************************************
+int defaultAudioSlave( muxerMT *context )
+{
+DIA_encoding *work=(DIA_encoding *)context->opaque;
+  uint32_t total_sample=0;
+  uint32_t total_size=0;
+  uint32_t samples,audioLen;
+  printf("[AudioThread] Starting\n");
+  while(context->audioEncoder->getPacket(context->audioBuffer, &audioLen, &samples) && total_sample<context->audioTargetSample)
+  { 
+    total_sample+=samples;
+    total_size+=audioLen;
+    accessMutex.lock();
+    if(context->audioAbort)
+    {
+      context->audioDone=1;
+      context->muxer->audioEof();
+      accessMutex.unlock();
+      return 1;
+    }
+    work->setAudioSize(total_size);
+    accessMutex.unlock();
+      
+    while(!context->muxer->needAudio()) 
+    {
+      if(context->audioAbort)
+      {
+        context->muxer->audioEof();
+        context->audioDone=1;
+        return 1;
+      } 
+    };
+    if(audioLen) 
+    {
+      context->muxer->writeAudioPacket(audioLen,context->audioBuffer); 
+    }
+    accessMutex.lock();
+    context->feedAudio+=audioLen;
+    accessMutex.unlock();
+
+  }
+  accessMutex.lock();
+  // Let's say audio is always ok, shall we :)
+  context->audioDone=1;
+  context->muxer->audioEof();
+  accessMutex.unlock();
+  printf("[AudioThread] Exiting\n");
+  printf("[AudioThread] Target %u, got %u, %f %%\n",context->audioTargetSample,total_sample,
+         (float)total_sample/(float)context->audioTargetSample);
+  return 1;
+}
+//*******************************************************
+int defaultVideoSlave( muxerMT *context )
+{
+DIA_encoding *work=(DIA_encoding *)context->opaque;
+ADMBitstream *bitstream=context->bitstream;
+uint32_t mx=context->nbVideoFrame;
+  printf("[VideoThread] Starting\n");
+  for(uint32_t i=0;i<mx;i++)
+  {
+
+    bitstream->cleanup(i);
+    if(context->videoAbort)
+    {
+      context->videoDone=1;
+      context->muxer->videoEof();
+      return 1;
+    }
+    if(!context->videoEncoder->encode( i,bitstream))
+    {
+      accessMutex.lock();
+      context->videoDone=2;
+      context->muxer->videoEof();
+      accessMutex.unlock();
+  
+      return 1;
+    }
+    if(bitstream->len)
+      context->muxer->writeVideoPacket(bitstream);
+    work->setFrame(i,bitstream->len,bitstream->out_quantizer,mx);
+    accessMutex.lock();
+    context->currentVideoFrame=i;
+    context->feedVideo+=bitstream->len;
+    accessMutex.unlock();
+          
+
+  }
+  accessMutex.lock();
+  context->videoDone=1;
+  context->muxer->videoEof();
+  accessMutex.unlock();
+
+  printf("[VideoThread] Exiting\n");
+  return 1;
+}
+//EOF
+

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ADM_mthread.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ADM_mthread.h	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ADM_mthread.h	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,49 @@
+/***************************************************************************
+                         Fake encoder used for copy mode
+
+        We have to reorder !
+        TODO FIXME
+
+    begin                : Sun Jul 14 2002
+    copyright            : (C) 2002/2003 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef ADM_MTHREADS_H
+#define ADM_MTHREADS_H
+typedef  void * (*THRINP)(void *p);
+
+extern admMutex accessMutex;
+
+typedef struct 
+{
+  Encoder                   *videoEncoder;
+  AVDMGenericAudioStream    *audioEncoder;
+  mplexMuxer                *muxer;
+  ADMBitstream              *bitstream;
+  uint32_t                  nbVideoFrame;
+  uint32_t                  audioTargetSample;
+  uint8_t                   *audioBuffer;
+  uint32_t                  audioDone;
+  uint32_t                  videoDone;
+  uint32_t                  currentVideoFrame;
+  uint32_t                  feedAudio;
+  uint32_t                  feedVideo;
+  uint32_t                  audioAbort;
+  uint32_t                  videoAbort;
+  void                      *opaque;
+}muxerMT;
+
+extern int defaultAudioSlave( muxerMT *context );
+extern int defaultVideoSlave( muxerMT *context );
+
+
+#endif

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ADM_transfert.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ADM_transfert.cpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ADM_transfert.cpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,231 @@
+//
+// C++ Implementation: %{MODULE}
+//
+// Description:
+//
+//
+// Author: %{AUTHOR} <%{EMAIL}>, (C) %{YEAR}
+//
+// Copyright: See COPYING file that comes with this distribution
+//
+//
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "ADM_default.h"
+#include "ADM_threads.h"
+#include "ADM_transfert.h"
+
+#define HIGH_LVL        ((TRANSFERT_BUFFER*2)/3)
+#define LOW_LVL         (TRANSFERT_BUFFER/3)
+// minimum amount of audio buffer we need
+#define MIN_REQUIRED    (1024*1024)
+//#define MPLEX_D
+#define threadFailure(x) if(!(x)){printf("Condition "#x" failed at line %d\n",__LINE__);dumpStatus();ADM_assert(0);}
+
+//**************** Transfert *******************
+// *** Lot of race here : FIXME
+#if 0
+Transfert::Transfert(uint32_t minBuffer)
+{
+        cond=new admCond(&mutex);
+        clientCond=new admCond(&mutex);
+        _minRequired=minBuffer;
+        buffer=new uint8_t[TRANSFERT_BUFFER];
+
+        aborted=0;
+        transfered_r=0;
+        transfered_w=0;
+        
+        head=tail=0;
+        
+}
+Transfert::~Transfert()
+{
+        delete cond;
+        delete clientCond;
+        delete [] buffer;
+        
+}
+uint8_t Transfert::dumpStatus(void)
+{
+    printf("Mplex threading status : \n");
+    printf("Aborted :%d\n",aborted);
+    printf("head :%u\n",head);
+    printf("tail :%u\n",tail);
+    printf("mutex :%u\n",mutex.isLocked());
+    printf("cond :%u\n",cond->iswaiting());
+    printf("Clientcond :%u\n",clientCond->iswaiting());
+    printf("Written : %u bytes\n",transfered_w);
+    printf("Read : %u bytes\n",transfered_r);
+
+    printf("cond waiting :%u\n",cond->waiting);
+    printf("cond aborted :%u\n",cond->aborted);
+
+    printf("clientCond waiting :%u\n",clientCond->waiting);
+    printf("clientCond aborted :%u\n",clientCond->aborted);
+
+    
+    return 1;
+}
+uint32_t Transfert:: read(uint8_t *buf, uint32_t nb  )
+{
+uint32_t r=0;
+uint32_t fill=0;
+#ifdef MPLEX_D                 
+         printf("Reading %lu\n",nb);
+#endif          
+        
+  while(1)
+  {
+        mutex.lock();
+        fill=tail-head;        
+        if(fill>=nb)
+        {
+                
+                memcpy(buf,buffer+head,nb);                
+                head+=nb;
+                r+=nb;
+                transfered_r+=nb;
+                goto endit;                                                    
+        }
+        
+        // Purge
+         memcpy(buf,buffer+head,fill);
+         buf+=fill;
+         nb-=fill;
+         r+=fill;         
+         head=tail=0;
+         if(aborted) 
+         {
+                
+                goto endit;
+         }
+         if(clientCond->iswaiting()) printf("Client : %d\n",clientCond->waiting);
+         threadFailure(!clientCond->iswaiting());
+         
+#ifdef MPLEX_D      
+         printf("Wanted : %lu , left :%lu\n",nb,fill);   
+         printf("Slave sleeping\n");
+#endif         
+         
+         cond->wait();         
+         
+         if(aborted) 
+         {         
+                mutex.lock();       
+                goto endit;
+         }                                   
+  }
+endit: 
+        if(clientCond->iswaiting()) // No need to protect as the client is locked
+        {
+                fill=tail-head;       
+                if(fill<LOW_LVL)
+                {
+                        printf("Waking..\n");
+                        clientCond->wakeup();        
+                }
+        }
+        mutex.unlock();
+        transfered_w+=r;
+        return r;               
+}
+//*********************************
+uint8_t Transfert::fillingUp( void)
+{
+uint8_t r=0;
+
+        mutex.lock();
+        if((tail-head)>HIGH_LVL)
+                r=1;
+        else r=0;
+        mutex.unlock();
+        return r;
+        
+
+}
+uint8_t Transfert:: write(uint8_t *buf, uint32_t nb  )
+{
+        if(aborted) return 0;
+        
+#ifdef MPLEX_D                 
+         printf("Writing %lu\n",nb);
+#endif          
+        mutex.lock(); 
+        // Need to pack ?
+        if(nb+tail>=TRANSFERT_BUFFER)
+        {
+                memmove(buffer,buffer+head,tail-head);
+                tail-=head;
+                head=0;
+        }
+        // Overflow ?
+        if(nb+tail>=TRANSFERT_BUFFER)
+        {
+                printf("\n When writting %lu bytes, we overflow the existing %lu bytes\n",nb,tail-head);
+                threadFailure(0);
+        
+        }
+        memcpy(buffer+tail,buf,nb);       
+        transfered_w+=nb;
+        tail+=nb;
+        
+        if(cond->iswaiting())
+        {
+#ifdef MPLEX_D      
+           
+         printf("Slave waking\n");
+#endif     
+                cond->wakeup();
+        }                
+        mutex.unlock();
+        return 1;
+}        
+uint8_t Transfert::needData( void )
+{
+  int32_t l;
+  uint8_t r=0;
+        mutex.lock(); 
+        l=tail-head;
+        threadFailure(l>=0);
+        mutex.unlock();
+        if(l<_minRequired) r=1;
+        if(cond->iswaiting()) r=1;
+//        return cond->iswaiting();
+        return r;
+ 
+ }
+uint8_t Transfert::abort( void )
+{
+        aborted=1;
+        if(cond->iswaiting())
+                cond->abort();
+        return 1;
+ 
+ }
+  
+uint8_t Transfert::clientLock( void )
+{
+#ifdef MPLEX_D               
+         printf("Slave sleeping (%lu)\n",tail-=head);
+#endif         
+
+        mutex.lock();
+        // Redo check under same mutex lock
+        if((tail-head)<HIGH_LVL)
+        {
+            mutex.unlock();
+            return 1;
+        }
+        clientCond->wait();               
+        return 1;
+
+}
+#endif

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ADM_transfert.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ADM_transfert.h	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ADM_transfert.h	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,22 @@
+//
+// C++ Interface: %{MODULE}
+//
+// Description: 
+//
+//
+// Author: %{AUTHOR} <%{EMAIL}>, (C) %{YEAR}
+//
+// Copyright: See COPYING file that comes with this distribution
+//
+//
+#ifndef _ADM_TRANSFERT_
+#define _ADM_TRANSFERT_
+
+#define TRANSFERT_BUFFER 1024*1024*10
+#define TRANSFERT_SLOT   10000
+
+
+#include "ADM_toolkit/ADM_packetQueue.h"
+#endif
+//EOF
+

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/CMakeLists.txt	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/CMakeLists.txt	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,33 @@
+include(mx_plugin)
+SET(ADM_LIB ADM_mx_mplex)
+
+SET(${ADM_LIB}_SRCS 
+	ADM_mplexMuxer.cpp  
+        ADM_mplexInput.cpp   
+	ADM_mplexOutput.cpp     
+	ac3strm_in.cpp      
+        audiostrm_out.cpp  dtsstrm_in.cpp  lpcmstrm_in.cpp   multiplexor.cpp   stream_params.cpp  videostrm_in.cpp
+        ADM_mthread.cpp    bits.cpp           inputstrm.cpp   padstrm.cpp       systems.cpp       videostrm_out.cpp
+        ADM_transfert.cpp  interact.cpp       mpastrm_in.cpp  stillsstream.cpp  mpegconsts.c      mjpeg_logging.c    decodebufmodel.cpp
+	yuv4mpeg.c          cpu_accel.c)
+
+include_directories("${PTHREAD_INCLUDE_DIR}")
+ADD_LIBRARY(${ADM_LIB} SHARED ${${ADM_LIB}_SRCS})
+ADD_DEFINITIONS(${ADM_LIB} "-I${CMAKE_CURRENT_SOURCE_DIR} -DHAVE_FMAX -DRETSIGTYPE=void")
+
+IF (NOT APPLE)
+    ADD_DEFINITIONS(${ADM_LIB} "-DHAVE_MEMALIGN")
+ENDIF (NOT APPLE)
+
+IF (ADM_CPU_X86)
+    ADD_DEFINITIONS(${ADM_LIB} "-DHAVE_X86CPU")
+    
+    IF (ADM_CPU_X86_64)
+		ADD_DEFINITIONS(${ADM_LIB} "-DHAVE_X86_64CPU")
+    ENDIF (ADM_CPU_X86_64)
+ELSEIF (ADM_CPU_ALTIVEC)
+    ADD_DEFINITIONS(${ADM_LIB} "-DHAVE_ALTIVEC")
+ENDIF (ADM_CPU_X86)
+
+INIT_MUXER(${ADM_LIB})
+INSTALL_MUXER(${ADM_LIB})

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ac3strm_in.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ac3strm_in.cpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ac3strm_in.cpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,478 @@
+/*
+ *  ac3strm_in.c: AC3 Audio strem class members handling scanning and
+ *  buffering raw input stream.
+ *
+ *  Copyright (C) 2001 Andrew Stevens <andrew.stevens at philips.com>
+ *  Copyright (C) 2000,2001 Brent Byeler for original header-structure
+ *                          parsing code.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of version 2 of the GNU General Public License
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#include <config.h>
+#include <math.h>
+#include <stdlib.h>
+
+#include "audiostrm.hpp"
+#include "interact.hpp"
+#include "multiplexor.hpp"
+
+//#define DEBUG_AC3_HEADERS
+#define AC3_SYNCWORD            0x0b77
+#define AC3_PACKET_SAMPLES      1536
+
+const unsigned int AC3Stream::default_buffer_size = 16*1024;
+
+/// table for the available AC3 bitrates
+static const unsigned int ac3_bitrate_index[32] =
+{ 32,40,48,56,64,80,96,112,128,160,192,
+  224,256,320,384,448,512,576,640,
+  0,0,0,0,0,0,0,0,0,0,0,0,0
+};
+
+static const unsigned int ac3_frame_size[3][32] =
+{
+    { 64,80,96,112,128,160,192,224,256,320,384,
+      448,512,640,768,896,1024, 1152,1280,
+      0,0,0,0,0,0,0,0,0,0,0,0,0
+    },
+    { 69,87,104,121,139,174,208,243,278,348,417,
+      487,557,696,835,975,1114, 1253,1393,
+          0,0,0,0,0,0,0,0,0,0,0,0,0
+    },
+    { 96,120,144,168,192,240,288,336,384,480,576,
+      672,768,960,1152,1344, 1536,1728,1920,
+      0,0,0,0,0,0,0,0,0,0,0,0,0
+    }
+}; 
+
+/// table for the available AC3 frequencies
+static const unsigned int ac3_frequency[4] = 
+{ 48000, 44100, 32000, 0};
+
+
+AC3Stream::AC3Stream(IBitStream &ibs, Multiplexor &into) : 
+	AudioStream( ibs, into )
+{
+num_frames = 0;
+}
+
+bool AC3Stream::Probe(IBitStream &bs )
+{
+    return bs.GetBits(16) == AC3_SYNCWORD;
+}
+
+
+/*************************************************************************
+ *
+ * Reads initial stream parameters and displays feedback banner to users
+ * @param stream_num AC3 substream ID
+ *************************************************************************/
+
+
+void  AC3Stream::DisplayAc3HeaderInfo()
+{
+        /* Some stuff to generate frame-header information */
+        printf( "bsid         = %d\n", bs.GetBits(5) );
+        printf( "bsmode       = 0x%1x\n", bs.GetBits(3) ); 
+        int acmode = bs.GetBits(3);
+        int nfchans = 0;
+        switch( acmode )
+        {
+        case 0x0 :
+            nfchans = 2; break;
+        case 0x1 :
+            nfchans = 1; break;
+        case 0x2 :
+            nfchans = 2; break;
+        case 0x3 :
+        case 0x4 :
+            nfchans = 3; break;
+        case 0x5 :
+        case 0x6 :
+            nfchans = 4; break;
+        case 0x7 :
+            nfchans = 5; break;
+        }
+        printf( "acmode       = 0x%1x (%d channels)\n", acmode, nfchans ); 
+        if( (acmode & 0x1) && (acmode != 1 ) )
+            printf( "cmixlev  = %d\n", bs.GetBits(2) ); 
+        if( (acmode & 0x4) )
+            printf( "smixlev  = %d\n", bs.GetBits(2) ); 
+        if( acmode == 2 ) 
+            printf( "dsurr    = %d\n", bs.GetBits(2) ); 
+        printf( "lfeon        = %d\n", bs.GetBits(1) ); 
+        printf( "dialnorm     = %02d\n", bs.GetBits(5) ); 
+        int compre = bs.GetBits(1);
+        printf( "compre       = %d\n", compre ); 
+        if( compre )
+            printf( "compr    = %02d\n", bs.GetBits(8) ); 
+        int langcode = bs.GetBits(1);
+        printf( "langcode     = %d\n", langcode ); 
+        if( langcode )
+            printf( "langcod  = 0x%02x\n", bs.GetBits(8) ); 
+        int audprodie =  bs.GetBits(1);
+        printf( "audprodie    = %d\n", audprodie );
+        if( audprodie )
+        {
+            printf( "mixlevel = 0x%02x\n", bs.GetBits(5) );
+            printf( "roomtyp  = 0x%02x\n", bs.GetBits(2) );
+        }
+        if( acmode == 0 )
+        {
+            printf( "Skipping 1+1 mode parameters\n" );
+            bs.GetBits(5+1+8+1+8);
+            if( bs.GetBits(1) )
+                bs.GetBits(7);
+        }
+        printf( "Copyright  = %d\n", bs.GetBits(1) ); 
+        printf( "Original   = %d\n", bs.GetBits(1) ); 
+        int timecod1e = bs.GetBits(1);
+        if( timecod1e )
+        {
+            printf( "timecod1 = 0x%03x\n", bs.GetBits(14) );
+        }
+        int timecod2e = bs.GetBits(1);
+        if( timecod2e )
+        {
+            printf( "timecod2 = 0x%03x\n", bs.GetBits(14) );
+        }
+        int addbsie = bs.GetBits(1);
+        if( addbsie )
+        {
+            printf( "addbsil  = %02x\n", bs.GetBits(6) );
+        }
+        
+
+        // FROM This point on we're actually right into the actual audio block
+        printf( "Audio block header...\n" );
+        printf( "blksw  [ch] = %02x\n", bs.GetBits(nfchans) );
+        printf( "dithflg[ch] = %02x\n", bs.GetBits(nfchans) );
+        int dynrnge = bs.GetBits(1);
+        printf( "Dynrange    = %d\n", bs.GetBits(1) ); 
+        if( dynrnge )
+        {
+            printf( "dynrng    = %02x\n", bs.GetBits(8) );
+        }
+        if( acmode == 0 && bs.GetBits(1) )
+        {
+            printf( "dynrng2   = %02x\n", bs.GetBits(8) );
+        }
+        int cplstre = bs.GetBits(1);
+        printf( "cplstre     = %d\n", cplstre ); 
+        int cplinu = 0;
+        if( cplstre )
+        {
+            cplinu = bs.GetBits(1);
+            printf( "cplinu    = %d\n", cplinu );
+            if( cplinu )
+            {
+                printf( "Skipping cplinu=1 info...\n");
+                bs.GetBits(nfchans);
+                if( acmode == 2 )
+                    bs.GetBits(1);
+                int cplbegf = bs.GetBits(4);
+                int cplendf = bs.GetBits(4);
+                bs.GetBits(3+cplbegf-cplendf);
+            }
+        }
+        if( cplinu )
+        {
+            printf( "Warning: no parser for coupling co-ordinates mess\n");
+            return;
+        }
+
+        if( acmode == 2 )
+        {
+            int rmatstr = bs.GetBits(1);
+            printf( "rmatstr = %d\n", rmatstr );
+            printf( "Warning: no parser for rematrixing...\n" );
+        }
+        
+
+}
+
+void AC3Stream::Init ( const int _stream_num)
+
+{
+    unsigned int framesize_code;
+    stream_num = _stream_num;
+	MuxStream::Init( PRIVATE_STR_1, 
+					 1,  // Buffer scale
+					 default_buffer_size,
+					 false,
+					 muxinto.buffers_in_audio,
+					 muxinto.always_buffers_in_audio
+		);
+    mjpeg_info ("Scanning for header info: AC3 Audio stream %02x (%s)",
+                stream_num,
+                bs.StreamName()
+                );
+
+	AU_start = bs.bitcount();
+    if (bs.GetBits(16)==AC3_SYNCWORD)
+    {
+		num_syncword++;
+        bs.GetBits(16);         // CRC field
+        frequency = bs.GetBits(2);  // Sample rate code
+        framesize_code = bs.GetBits(6); // Frame size code
+        framesize = ac3_frame_size[frequency][framesize_code>>1];
+        framesize = 
+            (framesize_code&1) && frequency == 1 ?
+            (framesize + 1) << 1:
+            (framesize <<1);
+            
+        header_skip = 5;        // Initially skipped past  5 bytes of header 
+
+	num_frames++;
+        access_unit.start = AU_start;
+	access_unit.length = framesize;
+        mjpeg_info( "AC3 frame size = %d", framesize );
+        bit_rate = ac3_bitrate_index[framesize_code>>1];
+		samples_per_second = ac3_frequency[frequency];
+
+		/* Presentation time-stamping  */
+		access_unit.PTS = static_cast<clockticks>(decoding_order) * 
+			static_cast<clockticks>(AC3_PACKET_SAMPLES) * 
+			static_cast<clockticks>(CLOCKS)	/ samples_per_second;
+		access_unit.DTS = access_unit.PTS;
+		access_unit.dorder = decoding_order;
+		++decoding_order;
+		aunits.Append( access_unit );
+
+    } else
+    {
+		mjpeg_error ( "Invalid AC3 Audio stream header.");
+		exit (1);
+    }
+
+
+	OutputHdrInfo();
+}
+
+/// @returns the current bitrate
+unsigned int AC3Stream::NominalBitRate()
+{ 
+	return bit_rate*1024;
+}
+
+/// Prefills the internal buffer for output multiplexing.
+/// @param frames_to_buffer the number of audio frames to read ahead
+void AC3Stream::FillAUbuffer(unsigned int frames_to_buffer )
+{
+	unsigned int framesize_code;
+
+	last_buffered_AU += frames_to_buffer;
+	mjpeg_debug( "Scanning %d AC3 audio frames to frame %d", 
+				 frames_to_buffer, last_buffered_AU );
+
+    int skip;
+	while( !bs.eos() 
+           && decoding_order < last_buffered_AU 
+           && !muxinto.AfterMaxPTS(access_unit.PTS)
+        )
+	{
+		skip=access_unit.length-header_skip; 
+        bs.SeekFwdBits(skip);
+		prev_offset = AU_start;
+		AU_start = bs.bitcount();
+        if( AU_start - prev_offset != access_unit.length*8 )
+        {
+            mjpeg_warn( "Discarding incomplete final frame AC3 stream %d!",
+                       stream_num);
+            aunits.DropLast();
+            --decoding_order;
+            break;
+        }
+
+		/* Check we have reached the end of have  another catenated 
+		   stream to process before finishing ... */
+		if ( (syncword = bs.GetBits(16))!=AC3_SYNCWORD )
+		{
+			if( !bs.eos()   )
+			{
+				mjpeg_error_exit1( "Can't find next AC3 frame: @ %lld we have %04x - broken bit-stream?", AU_start/8, syncword );
+            }
+            break;
+		}
+
+        bs.GetBits(16);         // CRC field
+        bs.GetBits(2);          // Sample rate code TOOD: check for change!
+        framesize_code = bs.GetBits(6);
+        framesize = ac3_frame_size[frequency][framesize_code>>1];
+        framesize = 
+            (framesize_code&1) && frequency == 1 ?
+            (framesize + 1) << 1:
+            (framesize <<1);
+		access_unit.start = AU_start;
+		access_unit.length = framesize;
+		access_unit.PTS = static_cast<clockticks>(decoding_order) * 
+			static_cast<clockticks>(AC3_PACKET_SAMPLES) * 
+			static_cast<clockticks>(CLOCKS)	/ samples_per_second;;
+		access_unit.DTS = access_unit.PTS;
+		access_unit.dorder = decoding_order;
+		decoding_order++;
+		aunits.Append( access_unit );
+		num_frames++;
+		
+		num_syncword++;
+
+		if (num_syncword >= old_frames+10 )
+		{
+			mjpeg_debug ("Got %d frame headers.", num_syncword);
+			old_frames=num_syncword;
+		}
+        
+    }
+	last_buffered_AU = decoding_order;
+	eoscan = bs.eos() || muxinto.AfterMaxPTS(access_unit.PTS);
+}
+
+
+/// Closes the AC3 stream and prints some statistics.
+void AC3Stream::Close()
+{
+    stream_length = AU_start >> 3;
+	mjpeg_info ("AUDIO_STATISTICS: %02x", stream_id); 
+    mjpeg_info ("Audio stream length %lld bytes.", stream_length);
+    mjpeg_info   ("Frames         : %8u",  num_frames);
+}
+
+/*************************************************************************
+	OutputAudioInfo
+	gibt gesammelte Informationen zu den Audio Access Units aus.
+
+	Prints information on audio access units
+*************************************************************************/
+
+void AC3Stream::OutputHdrInfo ()
+{
+	mjpeg_info("AC3 AUDIO STREAM:");
+
+    mjpeg_info ("Bit rate       : %8u bytes/sec (%3u kbit/sec)",
+				bit_rate*128, bit_rate);
+
+    if (frequency == 3)
+		mjpeg_info ("Frequency      : reserved");
+    else
+		mjpeg_info ("Frequency      :     %d Hz",
+				ac3_frequency[frequency]);
+
+}
+
+/**
+Reads the bytes neccessary to complete the current packet payload. 
+ at param to_read number of bytes to read
+ at param dst byte buffer pointer to read to 
+ at returns the number of bytes read
+ */
+unsigned int 
+AC3Stream::ReadPacketPayload(uint8_t *dst, unsigned int to_read)
+{
+    bitcount_t read_start = bs.GetBytePos();
+    // Remember to change StreamHeaderLen if you write a different
+    // length re-using this code...
+    unsigned int bytes_read = bs.GetBytes( dst+4, to_read-4 );
+    assert( bytes_read > 0 );   // Should never try to read nothing
+    bs.Flush( read_start );
+	clockticks   decode_time;
+
+    unsigned int first_header = 
+        (new_au_next_sec || au_unsent > bytes_read )
+        ? 0 
+        : au_unsent;
+
+    // BUG BUG BUG: how do we set the 1st header pointer if we have
+    // the *middle* part of a large frame?
+    assert( first_header+2 <= to_read );
+
+    unsigned int syncwords = 0;
+    unsigned int bytes_muxed = bytes_read;
+  
+	if (bytes_muxed == 0 || MuxCompleted() )
+    {
+		goto completion;
+    }
+
+
+	/* Work through what's left of the current AU and the following AU's
+	   updating the info until we reach a point where an AU had to be
+	   split between packets.
+	   NOTE: It *is* possible for this loop to iterate. 
+
+	   The DTS/PTS field for the packet in this case would have been
+	   given the that for the first AU to start in the packet.
+
+	*/
+
+	decode_time = RequiredDTS();
+	while (au_unsent < bytes_muxed)
+	{	  
+        // BUG BUG BUG: if we ever had odd payload / packet size we might
+        // split an AC3 frame in the middle of the syncword!
+        assert( bytes_muxed > 1 );
+		bufmodel.Queued(au_unsent, decode_time);
+		bytes_muxed -= au_unsent;
+        if( new_au_next_sec )
+            ++syncwords;
+		if( !NextAU() )
+        {
+            goto completion;
+        }
+		new_au_next_sec = true;
+		decode_time = RequiredDTS();
+	};
+
+	// We've now reached a point where the current AU overran or
+	// fitted exactly.  We need to distinguish the latter case
+	// so we can record whether the next packet starts with an
+	// existing AU or not - info we need to decide what PTS/DTS
+	// info to write at the start of the next packet.
+	
+	if (au_unsent > bytes_muxed)
+	{
+        if( new_au_next_sec )
+            ++syncwords;
+		bufmodel.Queued( bytes_muxed, decode_time);
+		au_unsent -= bytes_muxed;
+		new_au_next_sec = false;
+	} 
+	else //  if (au_unsent == bytes_muxed)
+	{
+		bufmodel.Queued(bytes_muxed, decode_time);
+        if( new_au_next_sec )
+            ++syncwords;
+        new_au_next_sec = NextAU();
+	}	   
+completion:
+    // Generate the AC3 header...
+    // Note the index counts from the low byte of the offset so
+    // the smallest value is 1!
+    dst[0] = AC3_SUB_STR_0 + stream_num;
+    dst[1] = syncwords;
+    dst[2] = (first_header+1)>>8;
+    dst[3] = (first_header+1)&0xff;
+	return bytes_read+4;
+}
+
+
+
+/* 
+ * Local variables:
+ *  c-file-style: "stroustrup"
+ *  tab-width: 4
+ *  indent-tabs-mode: nil
+ * End:
+ */

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/audiostrm.hpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/audiostrm.hpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/audiostrm.hpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,218 @@
+
+/*
+ *  audiostrm.hpp:  Audio stream class sub-hierarchy for MPEG multiplexing
+ *
+ *  Copyright (C) 2001 Andrew Stevens <andrew.stevens at philips.com>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of version 2 of the GNU General Public License
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#ifndef __AUDIOSTRM_H__
+#define __AUDIOSTRM_H__
+
+#include "inputstrm.hpp"
+#include "stream_params.hpp"
+
+// TODO AudioStream is reall NonVideoStream as it is also a base for
+// SUBPStream (sub)classes
+
+class AudioStream : public ElementaryStream
+{
+public:   
+    AudioStream(IBitStream &ibs, Multiplexor &into );
+    virtual void Init(const int stream_num) = 0;
+    virtual void Close() = 0;
+
+    void OutputSector();
+    bool RunOutComplete();
+    virtual unsigned int NominalBitRate() = 0;
+
+    unsigned int num_syncword;
+
+protected:
+	virtual void FillAUbuffer(unsigned int frames_to_buffer) = 0;
+    
+	/* State variables for scanning source bit-stream */
+    AUnit access_unit;
+    unsigned int header_skip;
+}; 	
+
+class MPAStream : public AudioStream
+{
+public:   
+    MPAStream(IBitStream &ibs, Multiplexor &into );
+    virtual void Init(const int stream_num);
+    static bool Probe(IBitStream &bs);
+    virtual void Close();
+    virtual unsigned int NominalBitRate();
+
+
+private:
+	void OutputHdrInfo();
+	unsigned int SizeFrame( int bit_rate, int padding_bit );
+	virtual void FillAUbuffer(unsigned int frames_to_buffer);
+
+
+    /* Stream information for logging and parsing purposes */
+    unsigned int samples_per_second;
+	unsigned int version_id ;
+    unsigned int layer		;
+    unsigned int protection	;
+    unsigned int bit_rate_code;
+    unsigned int frequency	;
+    unsigned int mode		;
+    unsigned int mode_extension ;
+    unsigned int copyright      ;
+    unsigned int original_copy  ;
+    unsigned int emphasis	;
+
+	/* State variables for scanning source bit-stream */
+    unsigned int framesize;
+    unsigned int num_frames [2];
+    unsigned int size_frames[2];
+
+}; 	
+
+
+
+class AC3Stream : public AudioStream
+{
+public:   
+    AC3Stream(IBitStream &ibs,Multiplexor &into );
+    virtual void Init(const int stream_num);
+    static bool Probe(IBitStream &bs);
+    virtual void Close();
+    virtual unsigned int NominalBitRate();
+
+    virtual unsigned int ReadPacketPayload(uint8_t *dst, unsigned int to_read);
+    virtual unsigned int StreamHeaderSize() { return 4; }
+    
+
+private:
+	void OutputHdrInfo();
+    void DisplayAc3HeaderInfo();
+	virtual void FillAUbuffer(unsigned int frames_to_buffer);
+    
+    static const unsigned int default_buffer_size;
+	/* State variables for scanning source bit-stream */
+    unsigned int framesize;
+    unsigned int frequency;
+    unsigned int samples_per_second;
+    unsigned int bit_rate;
+    unsigned int stream_num;
+    unsigned int num_frames;
+}; 	
+
+class DTSStream : public AudioStream
+{
+public:   
+    DTSStream(IBitStream &ibs,Multiplexor &into );
+    virtual void Init(const int stream_num);
+    static bool Probe(IBitStream &bs);
+    virtual void Close();
+    virtual unsigned int NominalBitRate();
+
+    virtual unsigned int ReadPacketPayload(uint8_t *dst, unsigned int to_read);
+    virtual unsigned int StreamHeaderSize() { return 4; }
+    
+
+private:
+	void OutputHdrInfo();
+#ifdef DEBUG_DTS
+    void DisplayDtsHeaderInfo();
+#endif
+	virtual void FillAUbuffer(unsigned int frames_to_buffer);
+    
+    static const unsigned int default_buffer_size;
+
+	/* State variables for scanning source bit-stream */
+    unsigned int framesize;
+    unsigned int samples_per_second;
+    unsigned int bit_rate;
+    unsigned int stream_num;
+    unsigned int frequency	;
+    unsigned int num_frames;
+}; 	
+
+class LPCMStream : public AudioStream
+{
+public:   
+    LPCMStream(IBitStream &ibs, LpcmParams *parms, Multiplexor &into );
+    virtual void Init(const int stream_num);
+    static bool Probe(IBitStream &bs);
+    virtual void Close();
+    virtual unsigned int NominalBitRate();
+
+    virtual unsigned int ReadPacketPayload(uint8_t *dst, unsigned int to_read);
+    virtual unsigned int StreamHeaderSize() { return 7; }
+    
+
+private:
+	void OutputHdrInfo();
+	virtual void FillAUbuffer(unsigned int frames_to_buffer);
+    
+    static const unsigned int default_buffer_size;
+    static const unsigned int ticks_per_frame_90kHz;
+    unsigned int num_frames;
+
+	/* State variables for scanning source bit-stream */
+    unsigned int stream_num;
+    unsigned int samples_per_second;
+    unsigned int channels;
+    unsigned int bits_per_sample;
+    unsigned int bytes_per_frame;
+    unsigned int frame_index;
+    unsigned int dynamic_range_code;
+    LpcmParams *parms;
+}; 	
+
+class SUBPStream : public AudioStream
+{
+public:   
+    SUBPStream(IBitStream &ibs,Multiplexor &into );
+    virtual void Init(const int stream_num);
+    virtual void Close();
+    // TODO: rough and ready measure...
+    virtual unsigned int NominalBitRate() {return 50*1024;}
+    virtual unsigned int ReadPacketPayload(uint8_t *dst, unsigned int to_read);
+    virtual unsigned int StreamHeaderSize() { return 1; }
+    
+
+private:
+	void OutputHdrInfo();
+	virtual void FillAUbuffer(unsigned int frames_to_buffer);
+    
+    static const unsigned int default_buffer_size;
+
+	/* State variables for scanning source bit-stream */
+    unsigned int framesize;
+    unsigned int samples_per_second;
+    unsigned int bit_rate;
+    unsigned int stream_num;
+    unsigned int frequency	;
+    unsigned int num_frames;
+}; 	
+
+
+#endif // __AUDIOSTRM_H__
+
+
+/* 
+ * Local variables:
+ *  c-file-style: "stroustrup"
+ *  tab-width: 4
+ *  indent-tabs-mode: nil
+ * End:
+ */

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/audiostrm_out.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/audiostrm_out.cpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/audiostrm_out.cpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,149 @@
+
+/*
+ *  audiostrm_out.cpp: Members of audio stream classes related to
+ *  muxing out into the output stream.
+ *
+ *  Copyright (C) 2001 Andrew Stevens <andrew.stevens at philips.com>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of version 2 of the GNU General Public License
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+
+#include <config.h>
+#include <assert.h>
+
+#include "mjpeg_types.h"
+#include "audiostrm.hpp"
+#include "multiplexor.hpp"
+
+
+AudioStream::AudioStream(IBitStream &ibs, Multiplexor &into) : 
+	ElementaryStream( ibs, into,  ElementaryStream::audio ),
+	num_syncword(0)
+{
+    FRAME_CHUNK = 24;
+}
+
+
+
+/*********************************
+ * Signals when audio stream has completed mux run-out specified
+ * in associated mux stream. 
+ *********************************/
+
+bool AudioStream::RunOutComplete()
+{
+	return (au_unsent == 0 || 
+			( muxinto.running_out && RequiredPTS() >= muxinto.runout_PTS));
+}
+
+
+/******************************************************************
+	Output_Audio
+	generates Pack/Sys Header/Packet information from the
+	audio stream and saves them into the sector
+******************************************************************/
+
+void AudioStream::OutputSector ( )
+
+{
+	clockticks   PTS;
+	unsigned int max_packet_data; 	 
+	unsigned int actual_payload;
+	unsigned int old_au_then_new_payload;
+
+	PTS = RequiredDTS();
+	old_au_then_new_payload = 
+		muxinto.PacketPayload( *this, buffers_in_header, false, false );
+    bool last_packet = Lookahead() == 0;
+    // Ensure we have access units data buffered to allow a sector to be
+    // written.
+	max_packet_data = 0;
+	if( (muxinto.running_out && NextRequiredPTS() > muxinto.runout_PTS)
+        || last_packet)
+	{
+		/* We're now in the last AU of a segment.  So we don't want to
+		   go beyond it's end when writing sectors. Hence we limit
+		   packet payload size to (remaining) AU length.
+		*/
+		max_packet_data = au_unsent+StreamHeaderSize();
+	}
+  
+	/* CASE: packet starts with new access unit			*/
+	
+	if (new_au_next_sec)
+    {
+		actual_payload = 
+			muxinto.WritePacket ( max_packet_data,
+								  *this,
+								  buffers_in_header, PTS, 0,
+								  TIMESTAMPBITS_PTS);
+
+    }
+
+
+	/* CASE: packet starts with old access unit, no new one	*/
+	/*       starts in this very same packet			*/
+	else if (!(new_au_next_sec) && 
+			 (au_unsent >= old_au_then_new_payload))
+    {
+		actual_payload = 
+			muxinto.WritePacket ( max_packet_data,
+								  *this,
+								  buffers_in_header, 0, 0,
+								  TIMESTAMPBITS_NO );
+    }
+
+
+	/* CASE: packet starts with old access unit, a new one	*/
+	/*       starts in this very same packet			*/
+	else /* !(new_au_next_sec) &&  (au_unsent < old_au_then_new_payload)) */
+    {
+		/* is there another access unit anyway ? */
+		if( !last_packet )
+		{
+			PTS = NextRequiredDTS();
+			actual_payload = 
+				muxinto.WritePacket ( max_packet_data,
+									  *this,
+									  buffers_in_header, PTS, 0,
+									  TIMESTAMPBITS_PTS );
+
+		} 
+		else
+		{
+			actual_payload = muxinto.WritePacket ( max_packet_data,
+                                                   *this,
+                                                   buffers_in_header, 0, 0,
+                                                   TIMESTAMPBITS_NO );
+		};
+		
+    }
+
+    ++nsec;
+
+	buffers_in_header = always_buffers_in_header;
+	
+}
+
+
+
+/* 
+ * Local variables:
+ *  c-file-style: "stroustrup"
+ *  tab-width: 4
+ *  indent-tabs-mode: nil
+ * End:
+ */

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/aunit.hpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/aunit.hpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/aunit.hpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,36 @@
+#ifndef __AUNIT_H__
+#define __AUNIT_H__
+
+#include "mjpeg_types.h"
+#include "bits.hpp"
+
+typedef int64_t clockticks;		// This value *must* be signed
+                                // because we frequently compute *offsets*
+
+class AUnit
+{
+public:
+	AUnit() : length(0), PTS(0), DTS(0) {}
+	//
+	// How many payload bytes muxing AU will require.  Eventually will be more
+	// complex for input streams where AU are no contiguous
+	//
+	inline unsigned int PayloadSize() const { return length; }
+	void markempty() { length = 0; }
+	bitcount_t start;
+	unsigned int length;
+    clockticks PTS;
+    int        dorder;
+	//
+	// Remainder Used only for video AU's... 
+	//
+    clockticks DTS;
+    int		   porder;
+    unsigned int type;
+	bool	   seq_header;
+	bool	   end_seq;
+
+};
+
+
+#endif // __AUNIT_H__

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/aunitbuffer.hpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/aunitbuffer.hpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/aunitbuffer.hpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,65 @@
+#ifndef __AUNITBUFFER_H__
+#define __AUNITBUFFER_H__
+
+#include <deque>
+#include "mjpeg_logging.h"
+#include "aunit.hpp"
+
+class AUStream
+{
+public:
+	AUStream()  {}
+	~AUStream() 
+	{
+		for( std::deque<AUnit *>::iterator i = buf.begin(); i < buf.end(); ++i )
+			delete *i;
+	}
+	
+	void Append( AUnit &rec )
+	{
+		if( buf.size() >= BUF_SIZE_SANITY )
+			mjpeg_error_exit1( "INTERNAL ERROR: AU buffer overflow" );
+		buf.push_back( new AUnit(rec) );
+	}
+
+	inline AUnit *Next( ) 
+	{ 
+		if( buf.size()==0 )
+		{
+			return 0;
+		}
+	    else
+		{
+			AUnit *res = buf.front();
+			buf.pop_front();
+			return res;
+		}
+	}
+
+	inline void DropLast()
+		{
+			if( buf.empty() )
+				mjpeg_error_exit1( "INTERNAL ERROR: droplast empty AU buffer" );
+			buf.pop_back();
+			
+		}
+
+	inline AUnit *Lookahead( unsigned int n)
+	{
+		return buf.size() <= n ? 0 : buf[n];
+    }
+
+	inline unsigned int MaxAULookahead() const { return buf.size(); }
+
+private:
+	static const unsigned int BUF_SIZE_SANITY = 1000;
+
+
+	
+	std::deque<AUnit *> buf;
+};
+
+
+
+
+#endif // __AUSTREAM_H__

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/bits.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/bits.cpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/bits.cpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,502 @@
+/** @file bits.cc, bit-level output                                              */
+
+/* Copyright (C) 2001, Andrew Stevens <andrew.stevens at philips.com> *
+
+ *
+ * Disclaimer of Warranty
+ *
+ * These software programs are available to the user without any license fee or
+ * royalty on an "as is" basis.  The MPEG Software Simulation Group disclaims
+ * any and all warranties, whether express, implied, or statuary, including any
+ * implied warranties or merchantability or of fitness for a particular
+ * purpose.  In no event shall the copyright-holder be liable for any
+ * incidental, punitive, or consequential damages of any kind whatsoever
+ * arising from the use of these programs.
+ *
+ * This disclaimer of warranty extends to the user of these programs and user's
+ * customers, employees, agents, transferees, successors, and assigns.
+ *
+ * The MPEG Software Simulation Group does not represent or warrant that the
+ * programs furnished hereunder are free of infringement of any third-party
+ * patents.
+ *
+ * Commercial implementations of MPEG-1 and MPEG-2 video, including shareware,
+ * are subject to royalty fees to patent holders.  Many of these patents are
+ * general enough such that they are unavoidable regardless of implementation
+ * design.
+ *
+ */
+
+#include <config.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <string.h>
+#include <assert.h>
+#include "mjpeg_logging.h"
+#include "bits.hpp"
+
+
+const unsigned int BitStreamBuffering::BUFFER_SIZE = 64 * 1024;
+const unsigned int BitStreamBuffering::BUFFER_CEILING = 32 * 1024 * 1024;
+
+BitStreamBuffering::BitStreamBuffering() :
+    bfr(0),
+    bfr_size(0),
+    buffered(0)
+    
+{
+}
+
+
+/*****
+ *
+ * Pseudo-destructor. Frees the internal buffer and marks buffer as
+ * empty.
+ *
+ *****/
+void BitStreamBuffering::Release()
+{
+    if( bfr != 0)
+        delete[] bfr;
+    bfr = 0;
+    bfr_size = 0;
+    buffered = 0;
+}
+
+
+/*****
+ *
+ * Empty the buffer.
+ *
+ *****/
+
+void BitStreamBuffering::Empty()
+{
+    buffered = 0;
+}
+
+/** sets the internal buffer size. 
+    @param new_buf_size requests new internal buffer size 
+*/
+void BitStreamBuffering::SetBufSize( unsigned int new_buf_size)
+{
+    //
+    // If size has changed and we won't lose buffered data
+    // we adjust the buffer size, otherwise we ignore the request
+    //
+	if( new_buf_size > BUFFER_CEILING )
+	{
+		mjpeg_error_exit1("INTERNAL ERROR: additional data required but "
+                          " input buffer size would exceed ceiling");
+	}
+    
+    if( new_buf_size > buffered && bfr_size != new_buf_size )
+	{
+		uint8_t *new_buf = new uint8_t[new_buf_size];
+		memcpy( new_buf, bfr, static_cast<size_t>(buffered) );
+        if( bfr != 0 )
+            delete [] bfr;
+		bfr_size = new_buf_size;
+		bfr = new_buf;
+	}
+
+}
+
+/****************************
+ *
+ * Return the pointer to where (after, if necessary extending the
+ * buffer) up to to_append bytes may be appended to the buffered bytes
+ *
+ ****************************/
+
+uint8_t *BitStreamBuffering::StartAppendPoint( unsigned int to_append )
+{
+    unsigned int resize_size = bfr_size;
+    assert( resize_size != 0 );
+    while( resize_size - buffered < to_append )
+    {
+        resize_size *= 2;
+    }
+    if( resize_size != bfr_size )
+        SetBufSize( resize_size );
+    return bfr+buffered;
+}
+
+/**
+   Refills an IBitStream's input buffer based on the internal
+   variables buffered and bfr_size.
+   Strategy: we read 1/4 of a buffer, always.
+ */
+bool IBitStream::ReadIntoBuffer(unsigned int to_read)
+{
+	size_t i;
+    unsigned int read_pow2 = BUFFER_SIZE/4;
+    while( read_pow2 < to_read ) 
+        read_pow2 <<= 1;
+
+
+    i = ReadStreamBytes( StartAppendPoint(read_pow2), 
+                         static_cast<size_t>(read_pow2) );      
+	//i = fread(StartAppendPoint(read_pow2), sizeof(uint8_t), 
+    //			  static_cast<size_t>(read_pow2), fileh);
+    Appended(static_cast<unsigned int>(i));
+
+	if ( i == 0 )
+	{
+		eobs = true;
+		return false;
+	}
+	return true;
+}
+
+
+
+
+#define masks(idx) (1<<(idx))
+
+/*read 1 bit from the bit stream 
+ at returns the read bit, 0 on EOF */
+uint32_t IBitStream::Get1Bit()
+{
+	unsigned int bit;
+
+	if (eobs)
+		return 0;
+
+	bit = (bfr[byteidx] & masks(bitidx - 1)) >> (bitidx - 1);
+	bitreadpos++;
+	bitidx--;
+	if (!bitidx)
+	{
+		bitidx = 8;
+		byteidx++;
+		if (byteidx == buffered)
+		{
+			ReadIntoBuffer();
+		}
+	}
+
+	return bit;
+}
+
+/*read N bits from the bit stream 
+ at returns the read bits, 0 on EOF */
+uint32_t IBitStream::GetBits(int N)
+{
+	uint32_t val = 0;
+	int i = N;
+	unsigned int j;
+
+	// Optimize: we are on byte boundary and want to read multiple of bytes!
+	if ((bitidx == 8) && ((N & 7) == 0))
+	{
+		i = N >> 3;
+		while (i > 0)
+		{
+			if (eobs)
+				return 0;
+			val = (val << 8) | bfr[byteidx];
+			byteidx++;
+			bitreadpos += 8;
+			if (byteidx == buffered)
+			{
+				ReadIntoBuffer();
+			}
+			i--;
+		}
+	}
+	else
+	{
+		while (i > 0)
+		{
+			if (eobs)
+				return 0;
+
+			j = (bfr[byteidx] & masks(bitidx - 1)) >> (bitidx - 1);
+			bitreadpos++;
+			bitidx--;
+			if (!bitidx)
+			{
+				bitidx = 8;
+				byteidx++;
+				if (byteidx == buffered)
+				{
+					ReadIntoBuffer();
+				}
+			}
+			val = (val << 1) | j;
+			i--;
+		}
+	}
+	return val;
+}
+
+
+/** This function seeks for a byte aligned sync word (max 32 bits) in the bit stream and
+    places the bit stream pointer right after the sync.
+    This function returns 1 if the sync was found otherwise it returns 0
+ at param sync the sync word to search for
+ at param N the number of bits to retrieve
+ at param lim number of bytes to search through
+ at returns false on error */
+
+bool IBitStream::SeekSync(uint32_t sync, int N, int lim)
+{
+	uint32_t val, val1;
+	uint32_t maxi = ((1U<<N)-1); /* pow(2.0, (double)N) - 1 */;
+	if( maxi == 0 )
+	{
+		maxi = 0xffffffff;
+	}
+	while (bitidx != 8)
+	{
+		Get1Bit();
+	}
+
+	val = GetBits(N);
+	if( eobs )
+		return false;
+	while ((val & maxi) != sync && --lim)
+	{
+		val <<= 8;
+		val1 = GetBits( 8 );
+		val |= val1;
+		if( eobs )
+			return false;
+	}
+  
+	return (!!lim);
+}
+
+/****************
+ *
+ * Move the bit read position forward a specified number of bytes
+ * buffering bytes skipped over that are not already buffered
+ *
+ ***************/
+
+void IBitStream::SeekFwdBits( unsigned int bytes_to_seek_fwd)
+{ 
+    assert(bitidx == 8);
+    unsigned int req_byteidx = byteidx + bytes_to_seek_fwd;
+    while( req_byteidx >= buffered && !eobs)
+    {
+        ReadIntoBuffer( req_byteidx - (buffered-1) );
+    }
+    
+    eobs = ( req_byteidx >= buffered );
+    if( eobs )
+        bitreadpos += (buffered - byteidx)*8;
+    else
+        bitreadpos += bytes_to_seek_fwd*8;
+    byteidx = req_byteidx;
+}
+
+
+/**
+  Flushes all read input up-to *but not including* byte flush_upto.
+  @param flush_to the number of bits to flush
+*/
+
+void IBitStream::Flush(bitcount_t flush_upto )
+{
+	if( flush_upto > bfr_start+buffered )
+		mjpeg_error_exit1("INTERNAL ERROR: attempt to flush input beyond buffered amount" );
+
+	if( flush_upto < bfr_start )
+		mjpeg_error_exit1("INTERNAL ERROR: attempt to flush input stream before  first buffered byte %lld last is %lld", flush_upto, bfr_start );
+
+	unsigned int bytes_to_flush = 
+		static_cast<unsigned int>(flush_upto - bfr_start);
+	//
+	// Don't bother actually flushing until a good fraction of a buffer
+	// will be cleared.
+	//
+
+	if( bytes_to_flush < bfr_size/2 )
+		return;
+	buffered -= bytes_to_flush;
+	bfr_start = flush_upto;
+	byteidx -= bytes_to_flush;
+	memmove( bfr, bfr+bytes_to_flush, static_cast<size_t>(buffered));
+}
+
+
+/**
+  Undo scanning / reading
+  N.b buffer *must not* be flushed between prepareundo and undochanges.
+  @param undo handle to store the undo information
+*/
+void IBitStream::PrepareUndo( IBitStreamUndo &undo)
+{
+	undo = *(static_cast<IBitStreamUndo*>(this));
+}
+
+/**
+Undoes changes committed to an IBitStream. 
+ at param undo handle to retrieve the undo information   
+ */
+void IBitStream::UndoChanges( IBitStreamUndo &undo)
+{
+	*(static_cast<IBitStreamUndo*>(this)) = undo;
+}
+
+/**
+   Read a number bytes over an IBitStream, using the buffer. 
+   @param dst buffer to read to 
+   @param length the number of bytes to read
+ */
+unsigned int IBitStream::GetBytes(uint8_t *dst, unsigned int length)
+{
+	unsigned int to_read = length;
+	if( bytereadpos < bfr_start)
+		mjpeg_error_exit1("INTERNAL ERROR: access to input stream buffer @ %lld: before first buffered byte (%lld)", bytereadpos, bfr_start );
+
+	if(  bytereadpos+length > bfr_start+buffered )
+	{
+		if( !EndOfStream() )
+        {
+			mjpeg_error("INTERNAL ERROR: access to input stream buffer beyond last buffered byte @POS=%lld END=%d REQ=%lld + %d bytes", 
+                        bytereadpos,
+                        buffered, 
+                        bytereadpos-bfr_start,
+                        length  );
+            abort();
+        }
+		to_read = static_cast<unsigned int>( (bfr_start+buffered)- bytereadpos );
+	}
+	memcpy( dst, 
+			bfr+(static_cast<unsigned int>( bytereadpos-bfr_start)), 
+			to_read);
+	// We only ever flush up to the start of a read as we
+	// have only scanned up to a header *beginning* a block that is then
+	// read
+	//flush( bytereadpos );
+	bytereadpos += to_read;
+	return to_read;
+}
+
+
+#ifdef REDUNDANT_CODE
+/**
+   Initialize buffer, call once before first putbits or alignbits.
+  @param bs_filename output filename
+  @param buf_size size of the temporary output buffer to use
+*/
+void OBitStream::open(char *bs_filename, unsigned int buf_size)
+{
+	if ((fileh = fopen(bs_filename, "wb")) == NULL)
+	{
+		mjpeg_error_exit1( "Unable to open file %s for writing; %s", 
+						   bs_filename, strerror(errno));
+	}
+	filename = strcpy( new char[strlen(bs_filename)+1], bs_filename );
+    SetBufSize(buf_size);
+	// Save multiple buffering...
+	setvbuf(fileh, 0, _IONBF, 0 );
+	bitidx = 8;
+	byteidx = 0;
+	bitwritepos = 0LL;
+	outbyte = 0;
+}
+
+
+/** 
+    Closes the OBitStream. Flushes the output buffer and closes the output file if one was open. 
+ */
+void OBitStream::close()
+{
+	if (fileh)
+	{
+		if (byteidx != 0)
+			fwrite(bfr, sizeof(uint8_t), byteidx, fileh);
+		fclose(fileh);
+		delete filename;
+		fileh = NULL;
+	}
+}
+
+/**
+  Puts a byte into the OBitStream.  Puts the byte into the internal
+  buffer; if the buffer is full, it flushes the buffer to disk.
+ */
+void OBitStream::putbyte()
+{
+    bfr[byteidx++] = outbyte;
+    if (byteidx == bfr_size)
+    {
+		if (fwrite(bfr, sizeof(uint8_t), bfr_size, fileh) != bfr_size)
+			mjpeg_error_exit1( "Write failed: %s", strerror(errno));
+		byteidx = 0;
+    }
+	bitidx = 8;
+}
+
+/** write rightmost n (0<=n<=32) bits of val to outfile 
+ at param val value to write bitwise
+ at param n number of bits to write
+*/
+void OBitStream::putbits(uint32_t val, int n)
+{
+	int i;
+	unsigned int mask;
+
+    bitwritepos += n;
+    while( n >= bitidx )
+    {
+        outbyte = 
+            (outbyte<<bitidx) | ((val >> (n-bitidx)) & ((1u<<bitidx)-1));
+        n -= bitidx;
+        putbyte();
+    }
+    if( n > 0 )
+    {
+        bitidx -= n;
+        outbyte = val & ((1u<<bitidx)-1);
+    }
+#ifdef ORIGINAL
+	mask = 1 << (n - 1); /* selects first (leftmost, msb) bit */
+	for (i = 0; i < n; i++)
+	{
+		bitwritepos += 1;
+		outbyte <<= 1;
+		if (val & mask)
+			outbyte |= 1;
+		mask >>= 1; /* select next bit */
+		bitidx--;
+		if (bitidx == 0) /* 8 bit buffer full */
+			putbyte();
+	}
+#endif
+}
+
+/** write rightmost bit of val to outfile
+    @param val value to write one bit of
+*/
+void OBitStream::put1bit(int val)
+{
+	++bitwritepos;
+    outbyte = (outbyte<<1) | (val & 0x1);
+	--bitidx;
+	if (bitidx == 0) /* 8 bit buffer full */
+		putbyte();
+}
+
+
+/** zero bit stuffing to next byte boundary (5.2.3, 6.2.1) */
+void OBitStream::alignbits()
+{
+	if (bitidx != 8)
+		putbits( 0, bitidx);
+    flush_bytes();
+}
+
+#endif
+
+/* 
+ * Local variables:
+ *  c-file-style: "stroustrup"
+ *  tab-width: 4
+ *  indent-tabs-mode: nil
+ * End:
+ */

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/bits.hpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/bits.hpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/bits.hpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,207 @@
+#ifndef __BITS_H__
+#define __BITS_H__
+
+#include <stdio.h>
+#include <assert.h>
+// MEANX
+#include "streamType.h"
+// /MEANX
+
+typedef uint64_t bitcount_t;
+
+
+class BitStreamBuffering
+{
+public:
+	BitStreamBuffering();
+	void Release();
+	void Empty();
+	void SetBufSize( unsigned int buf_size);
+	uint8_t *StartAppendPoint(unsigned int additional);
+	inline void Appended(unsigned int additional)
+		{
+			buffered += additional;
+			assert( buffered <= bfr_size );
+		}
+private:
+	inline uint8_t *BufferEnd() { return bfr+buffered; }
+protected:
+	//
+	// TODO: really we should set these based on system parameters etc.
+	//
+	static const unsigned int BUFFER_SIZE;
+	static const unsigned int BUFFER_CEILING;
+	uint8_t *bfr;				// The read/write buffer tiself
+	unsigned int bfr_size;		// The physical size of the buffer =
+								// maximum buffered data-bytes possible
+	unsigned int buffered;		// Number of data-bytes in buffer
+};
+
+
+
+/*******
+ *
+ * the input bit stream class (see below) provides a mechanism to
+ * restore the scanning state to a marked point, provided no flush has
+ * taken place.
+ *
+ * This base class contains the state information needed to mark/restore
+ * between flushes.
+ *
+ * N.b. not that we override the BitStreamBuffering destructor so
+ * we don't cheerfully deallocate the buffer when an undo
+ * goes out of scope!
+ *
+ ******/
+ 
+class IBitStreamUndo : public BitStreamBuffering
+{
+public:
+	IBitStreamUndo() :
+		bfr_start(0),
+		bitreadpos(0),
+		bitidx(8),
+		bytereadpos(0),
+		eobs(true)
+		{}
+	inline bool eos() { return eobs; }
+	inline bitcount_t bitcount() { return bitreadpos; }
+
+protected:
+	bitcount_t bfr_start;	    // The position in the underlying
+								// data-stream of the first byte of
+								// the buffer.
+	unsigned int byteidx;		// Byte in buffer holding bit at current
+								// to current bit read position
+	bitcount_t bitreadpos;			// Total bits read at current bit read position
+	int bitidx;					// Position in byteidx buffer byte of
+								// bit at current bit read position
+								// N.b. coded as bits-left-to-read count-down
+	
+	bitcount_t bytereadpos;			// Bit position of the current *byte*
+								// read position
+	bool eobs;					// End-of-bitstream  flag: true iff
+								// Bit read position has reached the end
+								// of the underlying bitstream...
+};
+
+/***************************************
+ *
+ * IBitStream -  Input bit stream base class.  Supports the
+ * "scanning" of a stream held in a large buffer which is flushed
+ * once it has been "read".
+ *
+ * I.e. there are in effect two file-pointers: 
+ *
+ * A bit-level parsing file-pointers intended for bit-level parsing
+ * through the 'Get*' and 'Seek*'.  Scanning/seeking using these entry
+ * points keeps appending the got/sought data from the underlying
+ * stream to a (dynamically sized) internal buffer.
+ *
+ * A byte-level I/O file pointer used for reading chunks of data
+ * identified through parsing.
+ *
+ * A final set of entry-points allow parsed/read data that no longer
+ * needs to buffered to be flushed from the buffer (and buffer space
+ * reclaimed!).
+ *
+ * INVARIANT: only data items up to the bit-level file-pointer can be 'read'
+ *
+ * The actual source of the bit stream to be parsed/read is *abstract*
+ * in this base class.  Access in derived classes is through the
+ * virtual member function 'ReadStreamBytes' which should behave in
+ * the same way as 'fread'.  I.e. it should only return a short count
+ * at EOF or ERROR and further calls after EOF or ERROR should return
+ * a zero count.
+ *
+ * Hence the actual source of the bit stream need not support seeking.
+ *
+ ******************************************/
+
+
+
+class IBitStream : public IBitStreamUndo 
+{
+public:
+           mplexStreamDescriptor      streamDesc; //MEANX
+
+ 	IBitStream(mplexStreamDescriptor *desc) :
+		IBitStreamUndo(),
+		streamname( "unnamed" )
+		{
+                streamDesc=*desc; // MEANX
+		}
+	virtual ~IBitStream() { Release(); }
+
+
+	// Bit-level Parsing file-pointer entry-points
+	uint32_t Get1Bit();
+	uint32_t GetBits(int N);
+	bool SeekSync( uint32_t sync, int N, int lim);
+	void SeekFwdBits( unsigned int bytes_to_seek_fwd );
+
+	// Bit-level parsing state undo mechanism
+	void PrepareUndo(IBitStreamUndo &undobuf);
+	void UndoChanges(IBitStreamUndo &undobuf);
+
+	// Byte-level file-I/O entry-points
+	inline bitcount_t GetBytePos() { return bytereadpos; }
+	inline unsigned int BufferedBytes()
+		{
+			return static_cast<unsigned int>(bfr_start+buffered-bytereadpos);
+		}
+	unsigned int GetBytes( uint8_t *dst,
+						   unsigned int length_bytes);
+
+	//
+	// Byte data buffer management
+	void Flush( bitcount_t byte_position );
+
+	inline const char *StreamName() { return streamname; }
+protected:
+	bool ReadIntoBuffer( unsigned int to_read = BUFFER_SIZE );
+	virtual size_t ReadStreamBytes( uint8_t *buf, size_t number ) = 0;
+	virtual bool EndOfStream() = 0;
+	const char *streamname;
+
+};
+
+#ifdef REDUNDANT_CODE
+class OBitStreamUndo : public BitStreamBuffering
+{
+protected:
+	uint8_t outbyte;
+	unsigned int byteidx;
+	unsigned int bitidx;
+	unsigned int buffered;
+	bitcount_t bitwritepos;
+	uint8_t *bfr;
+	unsigned int bfr_size;
+
+};
+
+
+class BitStream : public OBitStreamUndo
+{
+};
+
+
+
+class OBitStream : public OBitStreamUndo {
+public:
+	inline bitcount_t bitcount() { return bitwritepos; }
+	void open( char *bs_filename, unsigned int buf_size = BUFFER_SIZE);
+	void close();
+	void putbits( int val, int n);
+	void put1bit( int val);
+	void alignbits();
+private:
+	FILE *fileh;
+	const char *filename;
+	void putbyte();
+};
+
+#endif
+
+#endif  // __BITS_H__
+

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/cpu_accel.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/cpu_accel.c	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/cpu_accel.c	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,445 @@
+/*
+* cpu_accel.c
+* Copyright (C) 1999-2000 Aaron Holtzman <aholtzma at ess.engr.uvic.ca>
+*
+* This file is part of mpeg2dec, a free MPEG-2 video stream decoder.
+*
+* mpeg2dec is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* mpeg2dec is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#define ADM_LEGACY_PROGGY
+#include "ADM_default.h"
+
+#include <signal.h>
+#include <setjmp.h>
+#include <unistd.h>
+#include <string.h>
+#include <errno.h>
+#include "cpu_accel.h"
+#include "mjpeg_logging.h"
+
+#ifdef HAVE_ALTIVEC
+extern int altivec_copy_v0();
+#endif
+
+/*
+ * Don't add "mblocks_sub44_mests" to the list below because it does not
+ * have a C-reference code counterpart (mblocks_sub44_mests only exists as
+ * a SIMD routine).
+*/
+
+	const char *disable_simd_flags[] = {
+		"sad_00",
+		"sad_01",
+		"sad_10",
+		"sad_11",
+		"sad_sub22",
+		"sad_sub44",
+		"bsad",
+		"variance",
+		"sumsq",
+		"sumsq_sub22",
+		"bsumsq_sub22",
+		"bsumsq",
+		"build_sub22_mests",
+		"build_sub44_mests",
+		"subsample_image",
+		"find_best_one_pel",
+		"quant_nonintra",
+		"quant_weight_intra",
+		"quant_weight_nonintra",
+		"iquant_intra",
+		"iquant_nonintra",
+		NULL
+		};
+
+static char *parse_next(char **, const char *);
+
+#ifdef HAVE_X86CPU 
+
+/* Some miscelaneous stuff to allow checking whether SSE instructions cause
+   illegal instruction errors.
+*/
+#if !defined(__MINGW32__)
+static sigjmp_buf sigill_recover;
+
+static RETSIGTYPE sigillhandler(int sig )
+{
+	siglongjmp( sigill_recover, 1 );
+}
+
+typedef RETSIGTYPE (*__sig_t)(int);
+#endif
+
+static int testsseill()
+{
+	int illegal;
+#if defined(__CYGWIN__) || defined(__MINGW32__)
+	/* SSE causes a crash on CYGWIN, apparently.
+	   Perhaps the wrong signal is being caught or something along
+	   those line ;-) or maybe SSE itself won't work...
+	*/
+	illegal = 1;
+#else
+	__sig_t old_handler = signal( SIGILL, sigillhandler);
+	if( sigsetjmp( sigill_recover, 1 ) == 0 )
+	{
+		asm ( "movups %xmm0, %xmm0" );
+		illegal = 0;
+	}
+	else
+		illegal = 1;
+	signal( SIGILL, old_handler );
+#endif
+	return illegal;
+}
+
+static int x86_accel (void)
+{
+    intptr_t eax, ebx, ecx, edx;
+    int32_t AMD;
+    int32_t caps;
+
+	/* Slightly weirdified cpuid that preserves the ebx and edi required
+	   by gcc for PIC offset table and frame pointer */
+
+#ifdef HAVE_X86_64CPU
+#  define REG_b "rbx"
+#  define REG_S "rsi"
+#else
+#  define REG_b "ebx"
+#  define REG_S "esi"
+#endif
+	   
+#define cpuid(op,eax,ebx,ecx,edx)	\
+    asm ( "push %%"REG_b"\n" \
+	      "cpuid\n" \
+	      "mov   %%"REG_b", %%"REG_S"\n" \
+	      "pop   %%"REG_b"\n"  \
+	 : "=a" (eax),			\
+	   "=S" (ebx),			\
+	   "=c" (ecx),			\
+	   "=d" (edx)			\
+	 : "a" (op)			\
+	 : "cc", "edi")
+
+    asm ("pushf\n\t"
+	 "pop %0\n\t"
+	 "mov %0,%1\n\t"
+	 "xor $0x200000,%0\n\t"
+	 "push %0\n\t"
+	 "popf\n\t"
+	 "pushf\n\t"
+	 "pop %0"
+         : "=a" (eax),
+	       "=c" (ecx)
+	 :
+	 : "cc");
+
+
+    if (eax == ecx)		// no cpuid
+	return 0;
+
+    cpuid (0x00000000, eax, ebx, ecx, edx);
+    if (!eax)			// vendor string only
+	return 0;
+
+    AMD = (ebx == 0x68747541) && (ecx == 0x444d4163) && (edx == 0x69746e65);
+
+    cpuid (0x00000001, eax, ebx, ecx, edx);
+    if (! (edx & 0x00800000))	// no MMX
+	return 0;
+
+    caps = ACCEL_X86_MMX;
+    /* If SSE capable CPU has same MMX extensions as AMD
+	   and then some. However, to use SSE O.S. must have signalled
+	   it use of FXSAVE/FXRSTOR through CR4.OSFXSR and hence FXSR (bit 24)
+	   here
+	*/
+    if ((edx & 0x02000000))	
+		caps = ACCEL_X86_MMX | ACCEL_X86_MMXEXT;
+	if( (edx & 0x03000000) == 0x03000000 )
+	{
+		/* Check whether O.S. has SSE support... has to be done with
+		   exception 'cos those Intel morons put the relevant bit
+		   in a reg that is only accesible in ring 0... doh! 
+		*/
+		if( !testsseill() )
+			caps |= ACCEL_X86_SSE;
+	}
+
+    cpuid (0x80000000, eax, ebx, ecx, edx);
+    if (eax < 0x80000001)	// no extended capabilities
+		return caps;
+
+    cpuid (0x80000001, eax, ebx, ecx, edx);
+
+    if (edx & 0x80000000)
+	caps |= ACCEL_X86_3DNOW;
+
+    if (AMD && (edx & 0x00400000))	// AMD MMX extensions
+	{
+		caps |= ACCEL_X86_MMXEXT;
+	}
+
+    return caps;
+}
+#endif
+
+
+#ifdef HAVE_ALTIVEC
+/* AltiVec optimized library for MJPEG tools MPEG-1/2 Video Encoder
+ * Copyright (C) 2002  James Klicman <james at klicman.org>
+ *
+ * The altivec_detect() function has been moved here to workaround a bug in a
+ * released version of GCC (3.3.3). When -maltivec and -mabi=altivec are
+ * specified, the bug causes VRSAVE instructions at the beginning and end of
+ * functions which do not use AltiVec. GCC 3.3.3 also lacks support for
+ * '#pragma altivec_vrsave off' which would have been the preferred workaround.
+ *
+ * This AltiVec detection code relies on the operating system to provide an
+ * illegal instruction signal if AltiVec is not present. It is known to work
+ * on Mac OS X and Linux.
+ */
+
+static sigjmp_buf jmpbuf;
+
+static void sig_ill(int sig)
+{
+    siglongjmp(jmpbuf, 1);
+}
+
+int detect_altivec()
+{
+    volatile int detected = 0; /* volatile (modified after sigsetjmp) */
+    struct sigaction act, oact;
+
+    act.sa_handler = sig_ill;
+    sigemptyset(&act.sa_mask);
+    act.sa_flags = 0;
+
+    if (sigaction(SIGILL, &act, &oact)) {
+	perror("sigaction");
+	return 0;
+    }
+
+    if (sigsetjmp(jmpbuf, 1))
+	goto noAltiVec;
+
+    /* try to read an AltiVec register */ 
+    altivec_copy_v0();
+
+    detected = 1;
+
+noAltiVec:
+    if (sigaction(SIGILL, &oact, (struct sigaction *)0))
+	perror("sigaction");
+
+    return detected;
+}
+#endif
+
+
+int32_t cpu_accel (void)
+{
+#ifdef HAVE_X86CPU 
+    static int got_accel = 0;
+    static int accel;
+
+    if (!got_accel) {
+		got_accel = 1;
+		accel = x86_accel ();
+    }
+
+    return accel;
+#elif defined(HAVE_ALTIVEC)
+    return detect_altivec();
+#else
+    return 0;
+#endif
+}
+
+/*****************************
+ *
+ * Allocate memory aligned to suit SIMD 
+ *
+ ****************************/
+
+#define powerof2(x)     ((((x)-1)&(x))==0)
+
+#if	!defined(HAVE_POSIX_MEMALIGN)
+
+int
+posix_memalign(void **ptr, size_t alignment, size_t size)
+{
+	void *mem;
+
+	if	(alignment % sizeof (void *) != 0 || !powerof2(alignment) != 0)
+		return(EINVAL);
+	mem = malloc((size + alignment - 1) & ~(alignment - 1));
+	if	(mem != NULL)
+	{
+		*ptr = mem;
+		return(0);
+	}
+	return(ENOMEM);
+}
+#endif
+
+#if	!defined(HAVE_MEMALIGN)
+void *
+memalign(size_t alignment, size_t size)
+{
+
+	if 	(alignment % sizeof (void *) || !powerof2(alignment))
+	{
+		errno = EINVAL;
+		return(NULL);
+	}
+	return(malloc((size + alignment - 1) & ~(alignment - 1)));
+}
+#endif
+
+/***********************
+ * Implement fmax() for systems which do not have it.  Not a strictly
+ * conforming implementation - we don't bother checking for NaN which if
+ * mpeg2enc gets means big trouble I suspect ;)
+************************/
+
+#if	!defined(HAVE_FMAX)
+double
+fmax(double x, double y)
+{
+	if	(x > y)
+		return(x);
+	return(y);
+}
+#endif
+
+void *bufalloc( size_t size )
+{
+	static size_t simd_alignment = 16;
+	static int bufalloc_init = 0;
+	int  pgsize;
+	void *buf = NULL;
+
+	if( !bufalloc_init )
+	{
+#ifdef HAVE_X86CPU 
+		if( (cpu_accel() &  (ACCEL_X86_SSE|ACCEL_X86_3DNOW)) != 0 )
+		{
+			simd_alignment = 64;
+			bufalloc_init = 1;
+		}
+#endif		
+	}
+		
+#ifdef __MINGW32__	// GRUNTSTER
+	pgsize = 4096;
+#else
+	pgsize = sysconf(_SC_PAGESIZE);
+#endif
+
+/*
+ * If posix_memalign fails it could be a broken glibc that caused the error,
+ * so try again with a page aligned memalign request
+*/
+	if (posix_memalign( &buf, simd_alignment, size))
+		buf = memalign(pgsize, size);
+	if (buf && ((size_t)buf & (simd_alignment - 1)))
+	{
+		free(buf);
+		buf = memalign(pgsize, size);
+	}
+	if (buf == NULL)
+		mjpeg_error_exit1("malloc of %d bytes failed", (int)size);
+	if ((size_t)buf & (simd_alignment - 1))
+		mjpeg_error_exit1("could not allocate %d bytes aligned on a %d byte boundary", (int)size, (int)simd_alignment);
+	return buf;
+}
+
+int
+disable_simd(char *name)
+	{
+	int	foundit;
+	char	*cp, *simd_env, *dup_backup;
+	const char **dft;
+
+	if	((cp = getenv("MJPEGTOOLS_SIMD_DISABLE")) == NULL)
+		return(0);
+
+/*
+ * Special case for "all" so that all 22 or whatever names don't have to be
+ * explicitly specified.  If "all" is seen as the only name in the environment
+ * variable then always return 1.
+*/
+	if	(strcasecmp(cp, "all") == 0)
+		return(1);
+
+/*
+ * First check that the routine being tested for disabled status exists in
+ * the list of known functions.
+*/
+	foundit = 0;
+	for	(dft = disable_simd_flags; *dft; dft++)
+		{
+		if	(strcasecmp(name, *dft) == 0)
+			{
+			foundit = 1;
+			break;
+			}
+		}
+	if	(foundit == 0)
+		return(0);
+
+/*
+ * Next compare the function name passed as input to the comma separated
+ * names in the environment variable.  If a match is found then return 1
+*/
+	dup_backup = simd_env = strdup(cp);
+	while	((cp = parse_next(&simd_env, ",")))
+		{
+		foundit = 0;
+		if	(strcasecmp(cp, name) == 0)
+			{
+			foundit = 1;
+			break;
+			}
+		}
+	free(dup_backup);
+	return(foundit);
+	}
+
+static char *parse_next(char **sptr, const char *delim)
+{
+	char *start, *ret;
+	start = ret = *sptr;
+	if ((ret == NULL) || ret == '\0') {
+	   return (NULL);
+	}
+
+	while (*ret != '\0' &&
+		   strchr(delim, *ret) == NULL) {
+		ret++;
+	}
+	if (*ret == '\0') {
+		*sptr = NULL;
+	} else {
+	    *ret = '\0';
+	    ret++;
+	    *sptr = ret;
+	}
+	return (start);
+}

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/cpu_accel.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/cpu_accel.h	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/cpu_accel.h	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,58 @@
+/*
+ * cpu_accel.h
+ * Copyright (C) 1999-2000 Aaron Holtzman <aholtzma at ess.engr.uvic.ca>
+ *
+ * This file was part of mpeg2dec, a free MPEG-2 video stream decoder.
+ *
+ * mpeg2dec is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * mpeg2dec is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef _CPU_ACCEL_HH
+#define _CPU_ACCEL_HH
+
+#include <stdlib.h>
+#include "mjpeg_types.h"
+
+
+// x86 accelerations
+#define ACCEL_X86_MMX	0x80000000
+#define ACCEL_X86_3DNOW	0x40000000
+#define ACCEL_X86_MMXEXT 0x20000000
+#define ACCEL_X86_SSE   0x10000000
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+	int32_t cpu_accel (void);
+	void *bufalloc( size_t size );
+#if	!defined(HAVE_POSIX_MEMALIGN)
+	int posix_memalign(void **, size_t, size_t);
+#endif
+#if	!defined(HAVE_MEMALIGN)
+	void *memalign(size_t, size_t);
+#endif
+#if	!defined(HAVE_FMAX)
+	double fmax(double, double);
+#endif
+
+extern const char *disable_simd_flags[];
+extern int disable_simd(char *);
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/decodebufmodel.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/decodebufmodel.cpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/decodebufmodel.cpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,83 @@
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "decodebufmodel.hpp"
+#include <stdlib.h>
+
+using std::deque;
+
+/******************************************************************
+ *	Remove entries from FIFO buffer list, if their DTS is less than
+ *	actual SCR. These packet data have been already decoded and have
+ *	been removed from the system target decoder's elementary stream
+ *	buffer.
+ *****************************************************************/
+
+void DecodeBufModel::Cleaned(clockticks SCR)
+{
+    while ( bufstate.size() != 0 && bufstate.front().DTS < SCR)
+    {
+		bufstate.pop_front();
+    }
+}
+
+/******************************************************************
+ * Return the SCR when there will next be some change in the
+ * buffer.
+ * If the buffer is empty return a zero timestamp.
+ *****************************************************************/
+
+clockticks DecodeBufModel::NextChange()
+{
+	if( bufstate.size() == 0 )
+		return static_cast<clockticks>(0);
+	else
+		return bufstate.front().DTS;
+}
+
+
+/******************************************************************
+ *
+ *	Remove all entries from FIFO buffer list.
+ *
+ *****************************************************************/
+
+void DecodeBufModel::Flushed ()
+{
+	bufstate.clear();
+}
+
+/******************************************************************
+	DecodeBufModel::Space
+
+	returns free space in the buffer
+******************************************************************/
+
+unsigned int DecodeBufModel::Space ()
+{
+	unsigned int used_bytes = 0;
+	for( std::deque<DecodeBufEntry>::iterator i = bufstate.begin(); 
+		 i < bufstate.end();
+		 ++i )
+	{
+		used_bytes += i->size;
+    }
+
+    return (buffer_size - used_bytes);
+
+}
+
+/******************************************************************
+	Queue_Buffer
+
+	adds entry into the buffer FIFO queue
+******************************************************************/
+
+void DecodeBufModel::Queued (unsigned int bytes, clockticks TS)
+{
+	DecodeBufEntry entry;
+	entry.size = bytes;
+	entry.DTS = TS;
+	bufstate.push_back( entry );
+}

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/decodebufmodel.hpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/decodebufmodel.hpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/decodebufmodel.hpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,68 @@
+
+/*
+ *  buffer.hpp:  Classes for decoder buffer models for mux despatch
+ *
+ *  Copyright (C) 2001 Andrew Stevens <andrew.stevens at philips.com>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of version 2 of the GNU General Public License
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+
+#ifndef __DECODEBUFMODEL_H__
+#define __DECODEBUFMODEL_H__
+
+#include "aunit.hpp"
+#include <deque>
+
+
+struct DecodeBufEntry
+{
+	unsigned int size	;	/* als verkettete Liste implementiert	*/
+    clockticks DTS	;
+};
+    
+
+class DecodeBufModel
+{
+public:
+  DecodeBufModel() : buffer_size(0) {}
+  void Init ( unsigned int size)
+  {
+    buffer_size = size;
+  }
+  
+  void Cleaned(  clockticks timenow);
+  clockticks NextChange();
+  void Flushed( );
+  unsigned int Space();
+  void Queued( unsigned int bytes, clockticks removaltime);
+  inline unsigned int Size() { return buffer_size; }
+private:
+  unsigned int buffer_size;
+  std::deque<DecodeBufEntry> bufstate ;
+};
+
+
+
+#endif // __DECODEBUFMODEL_H__
+
+
+/* 
+ * Local variables:
+ *  c-file-style: "gnu"
+ *  tab-width: 4
+ *  indent-tabs-mode: nil
+ * End:
+ */

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/dtsstrm_in.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/dtsstrm_in.cpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/dtsstrm_in.cpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,398 @@
+/*
+ *  dtsstrm_in.c: dts Audio stream class members handling scanning and
+ *  buffering raw input stream.
+ *
+ *  Copyright (C) 2003 Markus Plail <plail at web.de>
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of version 2 of the GNU General Public License
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#include <config.h>
+#include <math.h>
+#include <stdlib.h>
+
+#include "audiostrm.hpp"
+#include "interact.hpp"
+#include "multiplexor.hpp"
+
+#define DTS_SYNCWORD            0x7ffe8001
+#define DTS_PACKET_SAMPLES      1536
+
+const unsigned int DTSStream::default_buffer_size = 16*1024;
+
+/// table for the available dts bitrates
+static const unsigned int dts_bitrate_index[32] =
+{ 32,56,64,96,112,128,192,224,
+  256,320,384,448,512,576,640,768,
+  960,1024,1152,1280,1344,1408,1411,1472,
+  1536,1920,2048,3072,3840,0,0,0
+};
+
+/// table for the available dts frequencies
+static const unsigned int dts_frequency[17] = 
+{ 0, 8000, 16000, 32000, 0, 0, 11025, 22050, 44100, 0, 0, 12000, 24000, 48000, 0, 0 };
+
+/// samples per frame
+static const unsigned int dts_packet_samples[4] = 
+{ 256, 512, 1024, 2048 };
+
+
+DTSStream::DTSStream(IBitStream &ibs, Multiplexor &into) : 
+	AudioStream( ibs, into )
+{
+	num_frames = 0;
+}
+
+bool DTSStream::Probe(IBitStream &bs )
+{
+    return bs.GetBits(32) == DTS_SYNCWORD;
+}
+
+#ifdef DEBUG_DTS
+
+static char *binString(int value, int length)
+{
+    char *bin = (char *) malloc((length + 1) * sizeof(char));
+    int index;
+    int dummy = 1 << (length - 1);
+
+    for(index = 0; index < length; index++)
+    {
+        if(value & dummy)
+            bin[index] = '1';
+        else
+            bin[index] = '0';
+
+        dummy >>= 1;
+    }
+    bin[index] = '\0';
+
+    return(bin);
+}
+
+
+/*************************************************************************
+ *
+ * Reads initial stream parameters and displays feedback banner to users
+ * @param stream_num dts substream ID
+ *************************************************************************/
+
+
+void  DTSStream::DisplayDtsHeaderInfo()
+{
+    /* Some stuff to generate frame-header information */
+    printf( "normal/termination? = %i\n", bs.GetBits(1) ); 
+    printf( "deficit sample count = %i\n", bs.GetBits(5) ); 
+    int crc = bs.GetBits(1);
+    printf( "CRC present? = %i\n", crc ); 
+    printf( "PCM samples = %i\n", bs.GetBits(7) ); 
+    printf( "frame byte size = %i\n", bs.GetBits(14) ); 
+    int acmode = bs.GetBits(6);
+    printf( "audio channel = %s\n", binString(acmode, 6) ); 
+    printf( "audio sampling freqency = %s\n", binString(bs.GetBits(4), 4) ); 
+    printf( "bit rate = %s\n", binString(bs.GetBits(5), 5) ); 
+    printf( "downmix enabled = %i\n", bs.GetBits(1) ); 
+    printf( "dynamic range flag = %i\n", bs.GetBits(1) ); 
+    printf( "time stamp = %i\n", bs.GetBits(1) ); 
+    printf( "auxiliary data = %i\n", bs.GetBits(1) ); 
+    printf( "HDCD = %i\n", bs.GetBits(1) ); 
+    printf( "extended coding flag = %i\n", bs.GetBits(1) ); 
+    printf( "audio sync word insert = %i\n", bs.GetBits(1) ); 
+    printf( "low frequency effects = %i\n", bs.GetBits(1) ); 
+    printf( "predictor history = %i\n", bs.GetBits(1) ); 
+    if (crc) printf( "CRC = %i\n", bs.GetBits(16) ); 
+    printf( "multirate interpolator = %i\n", bs.GetBits(1) ); 
+    printf( "encoder software revision = %i\n", bs.GetBits(4) ); 
+    printf( "copy history = %i\n", bs.GetBits(2) ); 
+    printf( "PCM resolution = %s\n", binString(bs.GetBits(3), 3) ); 
+    printf( "front sums difference flags = %i\n", bs.GetBits(1) ); 
+    printf( "surround sums difference flags = %i\n", bs.GetBits(1) ); 
+    printf( "dialog normalization parameter = %i\n", bs.GetBits(4) ); 
+}
+#endif
+void DTSStream::Init ( const int _stream_num)
+
+{
+    stream_num = _stream_num;
+	MuxStream::Init( PRIVATE_STR_1, 
+					 1,  // Buffer scale
+					 default_buffer_size,
+					 false,
+					 muxinto.buffers_in_audio,
+					 muxinto.always_buffers_in_audio
+		);
+    mjpeg_info ("Scanning for header info: dts Audio stream %02x (%s)",
+                stream_num,
+                bs.StreamName()
+                );
+
+	AU_start = bs.bitcount();
+    if (bs.GetBits(32)==DTS_SYNCWORD)
+    {
+		num_syncword++;
+        bs.GetBits(6);         // additional sync
+        bs.GetBits(1);         // CRC
+        bs.GetBits(7);         // pcm samples
+        framesize = bs.GetBits(14) + 1;        // frame size
+
+        bs.GetBits(6);         // audio channels
+        frequency = bs.GetBits(4);  // sample rate code
+        bit_rate = dts_bitrate_index[bs.GetBits(5)];
+        bs.GetBits(5);              // misc.
+
+        header_skip = 10;        // Initially skipped past 10 bytes of header 
+
+		num_frames++;
+        access_unit.start = AU_start;
+		access_unit.length = framesize;
+        mjpeg_info( "dts frame size = %d", framesize );
+		samples_per_second = dts_frequency[frequency];
+
+		/* Presentation time-stamping  */
+		access_unit.PTS = static_cast<clockticks>(decoding_order) * 
+			static_cast<clockticks>(DTS_PACKET_SAMPLES) * 
+			static_cast<clockticks>(CLOCKS)	/ samples_per_second;
+		access_unit.DTS = access_unit.PTS;
+		access_unit.dorder = decoding_order;
+		++decoding_order;
+		aunits.Append( access_unit );
+
+    } else
+    {
+		mjpeg_error ( "Invalid dts Audio stream header.");
+		exit (1);
+    }
+	OutputHdrInfo();
+}
+
+/// @returns the current bitrate
+unsigned int DTSStream::NominalBitRate()
+{ 
+	return bit_rate*1024;
+}
+
+/// Prefills the internal buffer for output multiplexing.
+/// @param frames_to_buffer the number of audio frames to read ahead
+void DTSStream::FillAUbuffer(unsigned int frames_to_buffer )
+{
+    unsigned int packet_samples;
+
+	last_buffered_AU += frames_to_buffer;
+	mjpeg_debug( "Scanning %d dts audio frames to frame %d", 
+				 frames_to_buffer, last_buffered_AU );
+
+	while( !bs.eos() && decoding_order < last_buffered_AU 
+            && !muxinto.AfterMaxPTS(access_unit.PTS) )
+	{
+		int skip = access_unit.length - header_skip; 
+        bs.SeekFwdBits(skip);
+		prev_offset = AU_start;
+		AU_start = bs.bitcount();
+
+        if( AU_start - prev_offset != access_unit.length*8 )
+        {
+            mjpeg_warn( "Discarding incomplete final frame dts stream %d!",
+                       stream_num);
+            aunits.DropLast();
+            decoding_order--;
+            break;
+        }
+
+		/* Check if we have reached the end or have  another catenated 
+		   stream to process before finishing ... */
+		if ( (syncword = bs.GetBits(32))!=DTS_SYNCWORD )
+		{
+			if( !bs.eos()   )
+			{
+				mjpeg_error_exit1( "Can't find next dts frame: @ %lld we have %04x - broken bit-stream?", AU_start/8, syncword );
+            }
+            break;
+		}
+
+        bs.GetBits(6);         // additional sync
+        bs.GetBits(1);         // CRC
+        packet_samples = (bs.GetBits(7) + 1) * 32;         // pcm samples
+        framesize = bs.GetBits(14) + 1;        // frame size
+
+        bs.GetBits(6);              // audio channels
+        bs.GetBits(4);              // sample rate code
+        bs.GetBits(5);              // bitrate
+        bs.GetBits(5);              // misc.
+
+        access_unit.start = AU_start;
+		access_unit.length = framesize;
+		access_unit.PTS = static_cast<clockticks>(decoding_order) * 
+			static_cast<clockticks>(packet_samples) * 
+			static_cast<clockticks>(CLOCKS)	/ samples_per_second;
+		access_unit.DTS = access_unit.PTS;
+		access_unit.dorder = decoding_order;
+		decoding_order++;
+		aunits.Append( access_unit );
+		num_frames++;
+
+		num_syncword++;
+
+		if (num_syncword >= old_frames+10 )
+		{
+			mjpeg_debug ("Got %d frame headers.", num_syncword);
+			old_frames=num_syncword;
+		}
+
+    }
+	last_buffered_AU = decoding_order;
+	eoscan = bs.eos() || muxinto.AfterMaxPTS(access_unit.PTS);
+}
+
+
+/// Closes the dts stream and prints some statistics.
+void DTSStream::Close()
+{
+    stream_length = AU_start >> 3;
+	mjpeg_info ("DTS STATISTICS: %02x", stream_id); 
+    mjpeg_info ("Audio stream length %lld bytes.", stream_length);
+    mjpeg_info   ("Frames         : %8u",  num_frames);
+}
+
+/*************************************************************************
+	OutputAudioInfo
+	gibt gesammelte Informationen zu den Audio Access Units aus.
+
+	Prints information on audio access units
+*************************************************************************/
+
+void DTSStream::OutputHdrInfo ()
+{
+	mjpeg_info("dts AUDIO STREAM:");
+
+    mjpeg_info ("Bit rate       : %8u bytes/sec (%3u kbit/sec)",
+				bit_rate*128, bit_rate);
+
+    if (frequency == 3)
+		mjpeg_info ("Frequency      : reserved");
+    else
+		mjpeg_info ("Frequency      :     %d Hz",
+				dts_frequency[frequency]);
+
+}
+
+/**
+Reads the bytes neccessary to complete the current packet payload. 
+ at param to_read number of bytes to read
+ at param dst byte buffer pointer to read to 
+ at returns the number of bytes read
+ */
+unsigned int 
+DTSStream::ReadPacketPayload(uint8_t *dst, unsigned int to_read)
+{
+	clockticks   decode_time;
+    // TODO: BUG BUG BUG: if there is a change in format in the stream
+    // this framesize will be invalid!  It only *looks* like it works...
+    // really each AU should store its own framesize...
+    unsigned int frames = to_read / framesize;
+    bitcount_t read_start = bs.GetBytePos();
+    unsigned int bytes_read =  bs.GetBytes( dst + 4, framesize * frames);
+    unsigned int bytes_muxed = bytes_read;
+
+    assert( bytes_read > 0 );   // Should never try to read nothing
+
+    bs.Flush( read_start );
+
+    unsigned int first_header = 
+        (new_au_next_sec || au_unsent > bytes_read )
+        ? 0 
+        : au_unsent;
+
+    // BUG BUG BUG: how do we set the 1st header pointer if we have
+    // the *middle* part of a large frame?
+    assert( first_header+2 <= to_read );
+
+    unsigned int syncwords = 0;
+  
+	if (bytes_muxed == 0 || MuxCompleted() )
+    {
+		goto completion;
+    }
+
+
+	/* Work through what's left of the current AU and the following AU's
+	   updating the info until we reach a point where an AU had to be
+	   split between packets.
+	   NOTE: It *is* possible for this loop to iterate. 
+
+	   The DTS/PTS field for the packet in this case would have been
+	   given the that for the first AU to start in the packet.
+
+	*/
+
+	decode_time = RequiredDTS();
+	while (au_unsent < bytes_muxed)
+	{	  
+        // BUG BUG BUG: if we ever had odd payload / packet size we might
+        // split a DTS frame in the middle of the syncword!
+        assert( bytes_muxed > 1 );
+		bufmodel.Queued(au_unsent, decode_time);
+		bytes_muxed -= au_unsent;
+        if( new_au_next_sec )
+            ++syncwords;
+		if( !NextAU() )
+        {
+            goto completion;
+        }
+		new_au_next_sec = true;
+		decode_time = RequiredDTS();
+	};
+
+	// We've now reached a point where the current AU overran or
+	// fitted exactly.  We need to distinguish the latter case
+	// so we can record whether the next packet starts with an
+	// existing AU or not - info we need to decide what PTS/DTS
+	// info to write at the start of the next packet.
+	
+	if (au_unsent > bytes_muxed)
+	{
+        if( new_au_next_sec )
+            ++syncwords;
+		bufmodel.Queued( bytes_muxed, decode_time);
+		au_unsent -= bytes_muxed;
+		new_au_next_sec = false;
+	} 
+	else //  if (au_unsent == bytes_muxed)
+	{
+		bufmodel.Queued(bytes_muxed, decode_time);
+        if( new_au_next_sec )
+            ++syncwords;
+        new_au_next_sec = NextAU();
+	}	   
+
+completion:
+    // Generate the dts header...
+    // Note the index counts from the low byte of the offset so
+    // the smallest value is 1!
+    dst[0] = DTS_SUB_STR_0 + stream_num;
+    dst[1] = frames;
+    dst[2] = (first_header+1)>>8;
+    dst[3] = (first_header+1)&0xff;
+
+	return bytes_read + 4;
+}
+
+
+
+/* 
+ * Local variables:
+ *  c-file-style: "stroustrup"
+ *  tab-width: 4
+ *  indent-tabs-mode: nil
+ * End:
+ */

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/format_codes.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/format_codes.h	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/format_codes.h	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,39 @@
+/*
+    $Id: format_codes.h,v 1.9 2002/12/17 21:54:24 wackston2 Exp $
+
+    Copyright (C) 2001 Andrew Stevens <andrew.stevens at planet-interkom.de>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#ifndef __FORMAT_CODES_H__
+#define __FORMAT_CODES_H__
+
+#define MPEG_FORMAT_MPEG1   0
+#define MPEG_FORMAT_VCD     1
+#define MPEG_FORMAT_VCD_NSR 2
+#define MPEG_FORMAT_MPEG2   3
+#define MPEG_FORMAT_SVCD     4
+#define MPEG_FORMAT_SVCD_NSR 5
+#define MPEG_FORMAT_VCD_STILL 6
+#define MPEG_FORMAT_SVCD_STILL 7
+#define MPEG_FORMAT_DVD_NAV 8
+#define MPEG_FORMAT_DVD      9
+
+#define MPEG_FORMAT_FIRST 0
+#define MPEG_FORMAT_LAST MPEG_FORMAT_DVD
+
+#define MPEG_STILLS_FORMAT(x) (x==MPEG_FORMAT_VCD_STILL||x==MPEG_FORMAT_SVCD_STILL)
+#endif /* __FORMAT_CODES_H__ */

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/inputstrm.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/inputstrm.cpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/inputstrm.cpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,283 @@
+
+/*
+ *  inputstrm.c:  Base classes related to muxing out input streams into
+ *                the output stream.
+ *
+ *  Copyright (C) 2001 Andrew Stevens <andrew.stevens at philips.com>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of version 2 of the GNU General Public License
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+
+#include <config.h>
+#include <assert.h>
+#include <limits.h>
+
+#include "mjpeg_types.h"
+#include "inputstrm.hpp"
+#include "multiplexor.hpp"
+
+MuxStream::MuxStream() : init(false) 
+{
+}
+
+void MuxStream::Init( const int strm_id, 
+			const unsigned int _buf_scale,
+			const unsigned int buf_size,
+			const unsigned int _zero_stuffing,
+			bool bufs_in_first, 
+			bool always_bufs) 
+{
+	stream_id = strm_id;
+	nsec = 0;
+	zero_stuffing = _zero_stuffing;
+	buffer_scale = _buf_scale;
+	buffer_size = buf_size;
+	bufmodel.Init( buf_size );
+	buffers_in_header = bufs_in_first;
+	always_buffers_in_header = always_bufs;
+	new_au_next_sec = true;
+	init = true;
+    min_pes_header_len = 0;
+}
+
+
+unsigned int 
+MuxStream::BufferSizeCode()
+{
+	if( buffer_scale == 1 )
+		return buffer_size / 1024;
+	else if( buffer_scale == 0 )
+		return buffer_size / 128;
+	else
+		assert(false);
+    return 0;                   // Never reached...
+}
+
+
+ElementaryStream::ElementaryStream( IBitStream &ibs,
+                                    Multiplexor &into, stream_kind _kind) : 
+    InputStream( ibs ),
+    au(0),
+	muxinto( into ),
+	kind(_kind),
+    buffer_min(INT_MAX),
+    buffer_max(1)
+{
+}
+
+/***********************************
+ *
+ * Scan ahead to buffer enough info on the coming Access Units to
+ * permit look-ahead of look_ahead/processing AUs forward from the
+ * current AU *and* the muxing of at least one sector.
+ *
+ **********************************/
+
+void 
+ElementaryStream::AUBufferLookaheadFill( unsigned int look_ahead)
+{
+    while( !eoscan &&
+           ( look_ahead+1 > aunits.MaxAULookahead() 
+             || bs.BufferedBytes() < muxinto.sector_size ) )
+    {
+        FillAUbuffer(FRAME_CHUNK);
+    }
+}
+
+/******************************************
+ *
+ * Move on to the next Access unit in the Elementary stream
+ *
+ *****************************************/
+
+bool 
+ElementaryStream::NextAU()
+{
+    // Free up no longer needed AU record
+    if( au != 0 )
+        delete au;
+
+    // Ensure we have enough in the AU buffer!
+    AUBufferLookaheadFill(1);
+
+    // Get the details of the next AU to be muxed....
+	AUnit *p_au = aunits.Next();
+	if( p_au != NULL )
+	{
+		au = p_au;
+		au_unsent = p_au->length;
+		return true;
+	}
+	else
+	{
+		au_unsent = 0;
+		return false;
+	}
+}
+
+
+AUnit *
+ElementaryStream::Lookahead( unsigned int n)
+{
+    AUBufferLookaheadFill(n);
+    return aunits.Lookahead( n );
+}
+
+unsigned int 
+ElementaryStream::BytesToMuxAUEnd(unsigned int sector_transport_size)
+{
+	return (au_unsent/min_packet_data)*sector_transport_size +
+		(au_unsent%min_packet_data)+(sector_transport_size-min_packet_data);
+}
+
+
+/******************************************************************
+ *	ElementaryStream::ReadPacketPayload
+ *
+ *  Reads the stream data from actual input stream, updates decode
+ *  buffer model and current access unit information from the
+ *  look-ahead scanning buffer to account for bytes_muxed bytes being
+ *  muxed out.  Particular important is the maintenance of "au_unsent"
+ *  the count of how much data in the current AU remains umuxed.  It
+ *  not only allows us to keep track of AU's but is also used for
+ *  generating substream headers
+ *
+ *  Unless we need to over-ride it to handle sub-stream headers
+ * The packet payload for an elementary stream is simply the parsed and
+ * spliced buffered stream data..
+ *
+ ******************************************************************/
+
+
+unsigned int 
+ElementaryStream::ReadPacketPayload(uint8_t *dst, unsigned int to_read)
+{
+    //
+    // Allow for the possibility that stream sub-headers might be needed
+    // E.g. AC3, LPCM, DTS....
+    unsigned int header_size = StreamHeaderSize();
+    bitcount_t read_start = bs.GetBytePos();
+    unsigned int actually_read = bs.GetBytes( dst+header_size, to_read-header_size );
+    bs.Flush( read_start );
+    Muxed( actually_read );
+    ReadStreamHeader(dst, header_size);
+	return actually_read;
+}
+
+void ElementaryStream::Muxed (unsigned int bytes_muxed)
+{
+	clockticks   decode_time;
+  
+	if (bytes_muxed == 0 || MuxCompleted() )
+		return;
+
+
+	/* Work through what's left of the current AU and the following AU's
+	   updating the info until we reach a point where an AU had to be
+	   split between packets.
+	   NOTE: It *is* possible for this loop to iterate. 
+
+	   The DTS/PTS field for the packet in this case would have been
+	   given the that for the first AU to start in the packet.
+	   Whether Joe-Blow's hardware VCD player handles this properly is
+	   another matter of course!
+	*/
+
+	decode_time = RequiredDTS();
+	while (au_unsent < bytes_muxed)
+	{	  
+        AUMuxed(true);          // Update stream specific tracking 
+                                // of AUs muxed...
+		bufmodel.Queued(au_unsent, decode_time);
+		bytes_muxed -= au_unsent;
+        new_au_next_sec = NextAU();
+        if( !new_au_next_sec )
+			return;
+		decode_time = RequiredDTS();
+	};
+
+	// We've now reached a point where the current AU overran or
+	// fitted exactly.  We need to distinguish the latter case
+	// so we can record whether the next packet starts with an
+	// existing AU or not - info we need to decide what PTS/DTS
+	// info to write at the start of the next packet.
+	
+	if (au_unsent > bytes_muxed)
+	{
+        AUMuxed(false);
+		bufmodel.Queued( bytes_muxed, decode_time);
+		au_unsent -= bytes_muxed;
+		new_au_next_sec = false;
+	} 
+	else //  if (au_unsent == bytes_muxed)
+	{
+        AUMuxed(false);
+		bufmodel.Queued(bytes_muxed, decode_time);
+		new_au_next_sec = NextAU();
+	}	   
+
+}
+
+bool ElementaryStream::MuxPossible(clockticks currentSCR)
+{
+	return (!RunOutComplete() &&
+			bufmodel.Space() > max_packet_data);
+}
+
+void ElementaryStream::UpdateBufferMinMax()
+{
+    buffer_min =  buffer_min < bufmodel.Space() ? 
+        buffer_min : bufmodel.Space();
+    buffer_max = buffer_max > bufmodel.Space() ? 
+        buffer_max : bufmodel.Space();
+}
+
+
+void ElementaryStream::AllDemuxed()
+{
+	bufmodel.Flushed();
+}
+
+void ElementaryStream::DemuxedTo( clockticks SCR )
+{
+	bufmodel.Cleaned( SCR );
+}
+
+bool ElementaryStream::MuxCompleted()
+{
+	return au_unsent == 0;
+}
+
+void 
+ElementaryStream::SetSyncOffset( clockticks sync_offset )
+{
+	timestamp_delay = sync_offset;
+}
+
+void ElementaryStream::BufferAndOutputSector( )
+{
+    AUBufferLookaheadFill(1);   // TODO is this really needed here?
+    OutputSector();
+}
+
+
+/* 
+ * Local variables:
+ *  c-file-style: "stroustrup"
+ *  tab-width: 4
+ *  indent-tabs-mode: nil
+ * End:
+ */

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/inputstrm.hpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/inputstrm.hpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/inputstrm.hpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,285 @@
+
+/*
+ *  inptstrm.hpp:  Input stream classes for MPEG multiplexing
+ *
+ *  Copyright (C) 2001 Andrew Stevens <andrew.stevens at philips.com>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of version 2 of the GNU General Public License
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#ifndef __INPUTSTRM_H__
+#define __INPUTSTRM_H__
+
+#include <stdio.h>
+#include <vector>
+#include <sys/stat.h>
+
+#include "mjpeg_types.h"
+#include "mpegconsts.h"
+#include "format_codes.h"
+#include "mjpeg_logging.h"
+
+#include "mplexconsts.hpp"
+#include "bits.hpp"
+#include "aunitbuffer.hpp"
+#include "decodebufmodel.hpp"
+
+using std::vector;
+
+class InputStream
+{
+public:
+	InputStream( IBitStream &istream ) :
+		stream_length(0),
+        bs( istream ),
+		eoscan(false),
+		last_buffered_AU(0),
+		decoding_order(0),
+		old_frames(0)
+		{}
+
+	void SetBufSize( unsigned int buf_size )
+		{
+			bs.SetBufSize( buf_size );
+		}
+
+    bitcount_t stream_length;
+
+protected:
+	off_t      file_length;
+    IBitStream &bs;
+	bool eoscan;
+	
+	unsigned int last_buffered_AU;		// decode seq num of last buffered frame + 1
+   	bitcount_t AU_start;
+    uint32_t  syncword;
+    bitcount_t prev_offset;
+    unsigned int decoding_order;
+    unsigned int old_frames;
+
+};
+
+class Multiplexor;
+
+
+class MuxStream 
+{
+public:
+	MuxStream();
+
+    void Init( const int strm_id,
+               const unsigned int _buf_scale,
+			   const unsigned int buf_size,
+			   const unsigned int _zero_stuffing,
+			   const bool bufs_in_first, 
+			   const bool always_bufs
+		  );
+
+	unsigned int BufferSizeCode();
+	inline unsigned int BufferSize() { return buffer_size; }
+	inline unsigned int BufferScale() { return buffer_scale; }
+
+	
+	inline void SetMaxPacketData( unsigned int max )
+		{
+			max_packet_data = max;
+		}
+	inline void SetMinPacketData( unsigned int min )
+		{
+			min_packet_data = min;
+		}
+	inline unsigned int MaxPacketData() { return max_packet_data; }
+	inline unsigned int MinPacketData() { return min_packet_data; }
+    inline bool NewAUNextSector() { return new_au_next_sec; }
+
+	//
+	//  Read the next packet payload (sub-stream headers plus
+	//  parsed and spliced stream data) for a packet with the
+	//  specified payload capacity.  Update the AU info.
+	//
+
+	virtual unsigned int ReadPacketPayload(uint8_t *dst, unsigned int to_read) = 0;
+
+    //
+    // Return the size of the substream headers...
+    //
+    virtual unsigned int StreamHeaderSize() { return 0; }
+
+public:  // TODO should go protected once encapsulation complete
+	int        stream_id;
+	unsigned int    buffer_scale;
+	unsigned int 	buffer_size;
+	DecodeBufModel  bufmodel;
+	unsigned int 	max_packet_data;
+	unsigned int	min_packet_data;
+	unsigned int    zero_stuffing;
+	unsigned int    nsec;
+    unsigned int    min_pes_header_len;
+	bool buffers_in_header;
+	bool always_buffers_in_header;
+	bool new_au_next_sec;
+	bool init;
+};
+
+class DummyMuxStream : public MuxStream
+{
+public:
+    DummyMuxStream( const int strm_id,
+                    const unsigned int buf_scale, 
+                    unsigned int buf_size )
+        {
+            stream_id = strm_id;
+            buffer_scale = buf_scale;
+            buffer_size = buf_size;
+        }
+
+    unsigned int ReadPacketPayload(uint8_t *dst, unsigned int to_read)
+        {
+            abort();
+            return 0;
+        }
+};
+
+
+class ElementaryStream : public InputStream,
+						 public MuxStream
+{
+public:
+	enum stream_kind { audio, video, dummy };
+	ElementaryStream( IBitStream &ibs,
+                      Multiplexor &into, 
+					  stream_kind kind
+					  );
+    virtual ~ElementaryStream () { }
+	virtual void Close() = 0;
+
+	bool NextAU();
+	AUnit *Lookahead( unsigned int n = 0);
+	unsigned int BytesToMuxAUEnd(unsigned int sector_transport_size);
+	bool MuxCompleted();
+	virtual bool MuxPossible(clockticks currentSCR );
+	void DemuxedTo( clockticks SCR );
+	void SetTSOffset( clockticks baseTS );
+	void AllDemuxed();
+	inline stream_kind Kind() { return kind; }
+    inline unsigned int BufferMin() { return buffer_min; }
+    inline unsigned int BufferMax() { return buffer_max; }
+    inline clockticks BaseDTS() { return au->DTS; };
+    inline clockticks BasePTS() { return au->PTS; };
+
+    inline int        DecodeOrder() { return au->dorder; }
+
+    inline clockticks RequiredDTS( const AUnit *unit )  
+        { return unit->DTS + timestamp_delay; };
+    inline clockticks RequiredPTS( const AUnit *unit ) 
+        { return unit->PTS + timestamp_delay; };
+    inline clockticks RequiredDTS()  
+        { return RequiredDTS(au); };
+    inline clockticks RequiredPTS() 
+        { return  RequiredPTS(au); };
+    inline clockticks NextRequiredDTS()
+        { 
+            AUnit *next = Lookahead();
+            if( next != 0 )
+                return RequiredDTS(next); 
+            else
+                return 0;
+        };
+    inline clockticks NextRequiredPTS()
+        { 
+            AUnit *next = Lookahead();
+            if( next != 0 )
+                return RequiredPTS(next); 
+            else
+                return 0;
+        };
+
+    void UpdateBufferMinMax();
+
+	void SetSyncOffset( clockticks timestamp_delay );
+
+	void BufferAndOutputSector();
+ 
+	inline bool BuffersInHeader() { return buffers_in_header; }
+	virtual unsigned int NominalBitRate() = 0;
+	virtual bool RunOutComplete() = 0;
+
+
+    /******************************************************************
+     *  Reads the stream data from actual input stream, updates decode
+     *  buffer model and current access unit information from the
+     *  look-ahead scanning buffer to account for bytes_muxed bytes being
+     *  muxed out.  
+     * TODO: No longer needs to be virtual
+     *
+     ******************************************************************/
+	virtual unsigned int ReadPacketPayload(uint8_t *dst, unsigned int to_read);
+
+    /********************************************************************
+     * Update stream-specific mux state information to reflect muxing of
+     * current AU.  first_in_sector is set true if AU is first muxed into
+     * the current sector.
+     *
+     *******************************************************************/
+
+    virtual void AUMuxed( bool first_in_sector ) {}
+
+    /**************************************************************
+     * The size of the stream-specific  sub-header (if any)
+     *************************************************************/
+    virtual unsigned int StreamHeaderSize() { return 0; }
+    
+    /*****************************************************************
+     * Reads/generates the stream-specific sub-header for AUs muxed
+     * since last call AUMuxed( true );
+     ****************************************************************/
+
+    virtual void ReadStreamHeader( uint8_t *dst, unsigned int len ) {}
+
+    bitcount_t bytes_read;
+private:
+    void AUBufferLookaheadFill( unsigned int look_ahead);
+
+//protected:
+public:
+	virtual void FillAUbuffer(unsigned int frames_to_buffer) = 0;
+    virtual void OutputSector() = 0;
+	AUStream aunits;
+	void Muxed( unsigned int bytes_muxed );
+	AUnit *au;
+	clockticks timestamp_delay;
+
+	unsigned int au_unsent;
+	AUnit *OLDnext();
+	Multiplexor &muxinto;
+	stream_kind kind;
+    unsigned int buffer_min;
+    unsigned int buffer_max;
+    int FRAME_CHUNK;
+									
+};
+
+
+
+#endif // __INPUTSTRM_H__
+
+
+/* 
+ * Local variables:
+ *  c-file-style: "stroustrup"
+ *  tab-width: 4
+ *  indent-tabs-mode: nil
+ * End:
+ */

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/interact.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/interact.cpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/interact.cpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,293 @@
+
+/*
+ *  interact.cc:  Simple command-line front-end
+ *
+ *  Copyright (C) 2001 Andrew Stevens <andrew.stevens at philips.com>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of version 2 of the GNU General Public License
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+
+#include <config.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <mjpeg_logging.h>
+#include <format_codes.h>
+
+#include "interact.hpp"
+#include "videostrm.hpp"
+#include "audiostrm.hpp"
+#ifdef ZALPHA
+#include "zalphastrm.hpp"
+#endif
+#include "mplexconsts.hpp"
+#include "aunit.hpp"
+
+
+static const char *KindNames[] =
+{
+    "MPEG audio",
+    "AC3 audio",
+    "LPCM audio",
+    "DTS audio",
+    "MPEG video",
+    "Z Alpha channel"
+};
+
+const char *JobStream::NameOfKind()
+{
+    return KindNames[kind];
+}
+
+Workarounds::Workarounds() 
+{
+}
+
+MultiplexJob::MultiplexJob()
+{
+    verbose = 1;
+    data_rate = 0;  /* 3486 = 174300B/sec would be right for VCD */
+    video_offset = 0;
+    audio_offset = 0;
+    sector_size = 2048;
+    VBR = false;
+    mpeg = 1;
+    mux_format = MPEG_FORMAT_MPEG1;
+    multifile_segment = false;
+    always_system_headers = false;
+    packets_per_pack = 1;
+    max_timeouts = 10;
+    max_PTS = 0;
+    max_segment_size = 0; // MB, default is unlimited (suitable for DVD)
+    outfile_pattern = 0;
+    packets_per_pack = 1;
+    audio_tracks = 0;
+    video_tracks = 0;
+    lpcm_tracks = 0;
+#ifdef ZALPHA
+    z_alpha_tracks = 0;
+#endif
+
+}
+
+
+MultiplexJob::~MultiplexJob()
+{
+	std::vector<JobStream *>::iterator i;
+    for( i = streams.begin(); i < streams.end(); ++i )
+        delete *i;
+}
+
+
+unsigned int MultiplexJob::NumberOfTracks( StreamKind kind )
+{
+    unsigned int count = 0;
+	std::vector<JobStream *>::iterator i;
+    for( i = streams.begin(); i < streams.end(); ++i )
+        if( (*i)->kind == kind )
+            ++count;
+    return count;
+    
+}
+
+void MultiplexJob::GetInputStreams( vector<JobStream *> &res, StreamKind kind )
+{
+    res.erase( res.begin(), res.end() );
+	std::vector<JobStream *>::iterator i;
+    for( i = streams.begin(); i < streams.end(); ++i )
+        if( (*i)->kind == kind )
+            res.push_back( *i );
+}
+
+
+// MEANX
+static const char *kindToString(StreamKind kind)
+{
+#define KID(x)  x##_AUDIO:return #x;
+    switch(kind)
+    {
+        case KID(MPEG)
+       case  KID(AC3)
+        case KID(LPCM)
+        case KID(DTS)
+        default: 
+            printf("Kind %d\n",kind);
+            assert(0);
+    }
+  return "Oops";
+}
+
+// /MEANS
+void MultiplexJob::SetupInputStreams( std::vector< IBitStream *> &inputs )
+{
+    IBitStream *bs;
+    IBitStreamUndo undo;
+    unsigned int i;
+    bool bad_file = false;
+    
+	for( i = 0; i < inputs.size(); ++i )
+    {
+        bs = inputs[i];
+        // Remember the streams initial state...
+        bs->PrepareUndo( undo );
+// MEANX : Use the info we have to be sure of the stream type
+// Else we cannot detect safly LPCM/PCM/DTS
+        switch(bs->streamDesc.kind)
+        {
+            case MPEG_AUDIO:
+            case AC3_AUDIO:
+            case LPCM_AUDIO:
+            case DTS_AUDIO:
+                mjpeg_info ("File %s looks like an %s Audio stream (fq %u, channel %u).\n", bs->StreamName() , kindToString(bs->streamDesc.kind),bs->streamDesc.frequency,bs->streamDesc.channel);
+                bs->UndoChanges( undo );
+                streams.push_back( new JobStream( bs, bs->streamDesc.kind) );
+                ++audio_tracks;
+                if(bs->streamDesc.kind==LPCM_AUDIO) 
+                    lpcm_param.push_back(LpcmParams::Checked(  bs->streamDesc.frequency,                                         
+                                                   bs->streamDesc.channel,16));//++lpcm_tracks;
+                continue;
+            case MPEG_VIDEO:
+                mjpeg_info ("File %s looks like an Video stream.", bs->StreamName() );
+                bs->UndoChanges( undo );
+                streams.push_back( new JobStream( bs,MPEG_VIDEO) );
+                ++video_tracks;
+                continue;
+            default: assert(0);
+            
+        }
+    }
+
+#if 0 //MEANX
+        if( LPCMStream::Probe( *bs ) )
+        {
+            mjpeg_info ("File %s looks like an LPCM Audio stream.",
+                        bs->StreamName());
+            bs->UndoChanges( undo );
+            streams.push_back( new JobStream( bs,  LPCM_AUDIO) );
+            ++audio_tracks;
+            ++lpcm_tracks;
+            continue;
+        }
+
+        bs->UndoChanges( undo );
+        if( MPAStream::Probe( *bs ) )
+        {
+            mjpeg_info ("File %s looks like an MPEG Audio stream.", 
+                        bs->StreamName() );
+            bs->UndoChanges( undo );
+            streams.push_back( new JobStream( bs, MPEG_AUDIO) );
+            ++audio_tracks;
+            continue;
+        }
+
+        bs->UndoChanges( undo );
+        if( AC3Stream::Probe( *bs ) )
+        {
+            mjpeg_info ("File %s looks like an AC3 Audio stream.",
+                        bs->StreamName());
+            bs->UndoChanges( undo );
+            streams.push_back( new JobStream( bs, AC3_AUDIO) );
+            ++audio_tracks;
+            continue;
+        }
+
+        bs->UndoChanges( undo );
+        if( DTSStream::Probe( *bs ) )
+        {
+            mjpeg_info ("File %s looks like a dts Audio stream.",
+                        bs->StreamName());
+            bs->UndoChanges( undo);
+            streams.push_back( new JobStream( bs, DTS_AUDIO) );
+            ++audio_tracks;
+            continue;
+        }
+
+        bs->UndoChanges( undo );
+        if( VideoStream::Probe( *bs ) )
+        {
+            mjpeg_info ("File %s looks like an MPEG Video stream.",
+                        bs->StreamName());
+            bs->UndoChanges( undo );
+            streams.push_back( new JobStream( bs, MPEG_VIDEO) );
+            ++video_tracks;
+            continue;
+        }
+
+        bs->UndoChanges( undo );
+#ifdef ZALPHA
+        if( ZAlphaStream::Probe( *bs ) )
+        {
+            mjpeg_info ("File %s looks like an Z/Alpha Video stream.",
+                        bs->StreamName());
+            bs->UndoChanges( undo );
+            streams.push_back( new JobStream( bs, Z_ALPHA) );
+            ++video_tracks;
+            ++z_alpha_tracks;
+            continue;
+        }
+#endif
+        bad_file = true;
+        mjpeg_error ("File %s unrecogniseable!", bs->StreamName());
+        delete bs;
+    }
+#endif // MEANX IF 0 
+    if( bad_file )
+    {
+        mjpeg_error_exit1( "Unrecogniseable file(s)... exiting.");
+    }
+
+	//
+	// Where no parameters for streams have been specified
+	// simply set the default values (these will depend on the format
+	// we're muxing of course...)
+	//
+
+	for( i = video_param.size(); i < video_tracks; ++i )
+	{
+		video_param.push_back(VideoParams::Default( mux_format ));
+	}
+	for( i = lpcm_param.size(); i < lpcm_tracks; ++i )
+	{
+		lpcm_param.push_back(LpcmParams::Default(mux_format));
+	}
+
+	//
+	// Set standard values if the selected profile implies this...
+	//
+	for( i = 0; i <video_tracks; ++i )
+	{
+		if( video_param[i]->Force(mux_format) )
+		{
+			mjpeg_info( "Video stream %d: profile %d selected - ignoring non-standard options!", i, mux_format );
+		}
+	}
+
+	mjpeg_info( "Found %d audio streams and %d video streams",
+                audio_tracks,
+				video_tracks
+        );
+        
+}
+
+
+/* 
+ * Local variables:
+ *  c-file-style: "stroustrup"
+ *  tab-width: 4
+ *  indent-tabs-mode: nil
+ * End:
+ */

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/interact.hpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/interact.hpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/interact.hpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,160 @@
+
+/*
+ *  interact.hpp:  Simple command-line front-end
+ *
+ *  Copyright (C) 2001 Andrew Stevens <andrew.stevens at philips.com>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of version 2 of the GNU General Public License
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#ifndef __INTERACT_HH__
+#define __INTERACT_HH__
+
+#ifndef _WIN32
+#include <unistd.h>
+#endif
+#include <vector>
+#include "mjpeg_types.h"
+#include "stream_params.hpp"
+#include "systems.hpp"
+
+// MEANX
+#include "streamType.h"
+// /MEANX
+class IBitStream;
+
+using std::vector;
+
+/*************************************************************************
+ *
+ * The Multiplexor job Parameters:
+ * The various parametes of a multiplexing job: muxing options
+ *
+ *************************************************************************/
+
+struct Workarounds
+{
+  Workarounds();
+};
+
+class MultiplexParams
+{
+public:
+  unsigned int data_rate;
+  unsigned int packets_per_pack;
+  int video_offset;             // A/V sync offset. Always one 0 and the
+                                // other positive. Specified in 
+  int audio_offset;             // MPEG-2 CLOCKS: 1/(90000*300)-th sec
+  unsigned int sector_size;
+  bool VBR;
+  int mpeg;
+  int mux_format;
+  bool multifile_segment;
+  bool always_system_headers;
+  unsigned int max_PTS;
+  bool stills;
+  int verbose;
+  int max_timeouts;
+  char *outfile_pattern;
+  int max_segment_size;
+  int min_pes_header_len;
+  Workarounds workarounds;      // Special work-around flags that
+                                // constrain the syntax to suit
+                                // the foibles of particular MPEG
+                                // parsers that are (guessed) to be
+                                // actually slightly broken.  Always
+                                // off by default...
+
+};
+
+/***********************************************************************
+ *
+ * Multiplexor job - paramters plus the streams to mux.
+ *
+ *
+ **********************************************************************/
+// MEANX MOVED TO STREAMTYPE.H
+#if 0
+enum StreamKind
+  {
+    MPEG_AUDIO,
+    AC3_AUDIO,
+    LPCM_AUDIO,
+    DTS_AUDIO,
+    MPEG_VIDEO
+#ifdef ZALPHA
+    ,
+    Z_ALPHA
+#endif
+  };
+#endif
+// MEANX MOVED TO STREAMTYPE.H
+
+class JobStream
+{
+public:
+
+  JobStream( IBitStream *_bs,  StreamKind _kind ) :
+    bs(_bs),
+    kind(_kind)
+  {
+  }
+
+  const char *NameOfKind();
+  IBitStream *bs;
+  StreamKind kind;
+};
+
+class MultiplexJob : public MultiplexParams
+{
+public:
+  MultiplexJob();
+  virtual ~MultiplexJob();
+  unsigned int NumberOfTracks( StreamKind kind );
+  void GetInputStreams( vector<JobStream *> &streams, StreamKind kind );
+
+  void SetupInputStreams( vector<IBitStream *> &inputs );
+protected:
+
+public:  
+  vector<JobStream *> streams;
+  vector<LpcmParams *> lpcm_param;
+  vector<VideoParams *> video_param;
+  unsigned int audio_tracks;
+  unsigned int video_tracks;
+  unsigned int lpcm_tracks;
+#ifdef ZALPHA
+  unsigned int z_alpha_tracks;
+#endif
+};
+
+
+/*************************************************************************
+    Program ID
+*************************************************************************/
+ 
+#define MPLEX_VER    "2.2.4"
+#define MPLEX_DATE   "$Date$"
+
+#endif // __INTERACT_H__
+
+
+/* 
+ * Local variables:
+ *  c-file-style: "gnu"
+ *  tab-width: 8
+ *  indent-tabs-mode: nil
+ * End:
+ */

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/lpcmstrm_in.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/lpcmstrm_in.cpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/lpcmstrm_in.cpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,323 @@
+/*
+ *  lpcmstrm_in.c: LPCM Audio strem class members handling scanning and
+ *  buffering raw input stream.
+ *
+ * Takes a *RAW* LPCM stream as input.
+ * This is *signed* linear 16, 20, or 24-bit sample PCM.
+ * Samples are stored msb first.
+ * How  20-bit samples are allocated to bytes? I just don't know, but
+ * believe 4 bits are appended after the lsb (samples are msb-byte aligned).
+ *
+ *  Copyright (C) 2001 Andrew Stevens <andrew.stevens at philips.com>
+ *  Copyright (C) 2000,2001 Brent Byeler for original header-structure
+ *                          parsing code.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of version 2 of the GNU General Public License
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#include <config.h>
+#include <math.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "audiostrm.hpp"
+#include "interact.hpp"
+#include "multiplexor.hpp"
+
+
+const unsigned int LPCMStream::default_buffer_size = 58*1024;
+const unsigned int LPCMStream::ticks_per_frame_90kHz = 150;
+
+
+LPCMStream::LPCMStream(IBitStream &ibs, LpcmParams *parms, Multiplexor &into) : 
+	AudioStream( ibs, into ),
+    parms(parms)
+{
+	num_frames = 0;
+}
+
+
+
+
+bool LPCMStream::Probe(IBitStream &bs )
+{
+    const char *last_dot = strrchr( bs.StreamName(), '.' );
+    return 
+        last_dot != NULL 
+        && strcmp( last_dot+1, "lpcm") == 0;
+
+}
+
+
+/*************************************************************************
+ *
+ * Reads initial stream parameters and displays feedback banner to users
+ *
+ *************************************************************************/
+
+
+void LPCMStream::Init ( const int _stream_num)
+
+{
+    stream_num = _stream_num;
+    header_skip = 0;
+	MuxStream::Init( PRIVATE_STR_1, 
+					 1,  // Buffer scale
+					 default_buffer_size,
+					 false,
+					 muxinto.buffers_in_audio,
+					 muxinto.always_buffers_in_audio
+		);
+
+    // This seems to be necessary not only for some software players but
+    // for some standalone players too.   Yuck... shades of the VCD audio
+    // sectors.
+    min_pes_header_len = 10;
+    mjpeg_info ("Scanning for header info: LPCM Audio stream %02x (%s)",
+                stream_num,
+                bs.StreamName()
+                );
+
+    
+	AU_start = bs.bitcount();
+
+    // This is a dummy debug version that simply assumes 48kHz
+    // two channel 16 bit sample LPCM
+    
+    samples_per_second = parms->SamplesPerSec();
+    channels = parms->Channels();
+    bits_per_sample = parms->BitsPerSample();
+    bytes_per_frame = 
+        samples_per_second * channels * bits_per_sample / 8
+        * ticks_per_frame_90kHz
+        / 90000;
+    frame_index = 0;
+    dynamic_range_code = 0x80;
+
+    /* Presentation/decoding time-stamping  */
+    access_unit.start = AU_start;
+    access_unit.length = bytes_per_frame;
+    access_unit.PTS = static_cast<clockticks>(decoding_order) * 
+        (CLOCKS_per_90Kth_sec * ticks_per_frame_90kHz);
+    access_unit.DTS = access_unit.PTS;
+    access_unit.dorder = decoding_order;
+    decoding_order++;
+    aunits.Append( access_unit );
+    
+	OutputHdrInfo();
+}
+
+unsigned int LPCMStream::NominalBitRate()
+{ 
+	return samples_per_second * channels * bits_per_sample;
+}
+
+
+
+void LPCMStream::FillAUbuffer(unsigned int frames_to_buffer )
+{
+	last_buffered_AU += frames_to_buffer;
+	mjpeg_debug( "Scanning %d MPEG LPCM audio frames to frame %d", 
+				 frames_to_buffer, last_buffered_AU );
+
+	while ( !bs.eos() 
+            && decoding_order < last_buffered_AU 
+            && !muxinto.AfterMaxPTS(access_unit.PTS) )
+	{
+		int skip=access_unit.length; 
+        bs.SeekFwdBits( skip );
+		prev_offset = AU_start;
+		AU_start = bs.bitcount();
+        if( AU_start - prev_offset != access_unit.length*8 )
+        {
+            mjpeg_warn("Discarding incomplete final frame LPCM  stream %d",
+                       stream_num);
+            aunits.DropLast();
+            --decoding_order;
+            break;
+        }
+
+        // Here we would check for header data but LPCM has no headers...
+        if( bs.eos()   )
+            break;
+
+		access_unit.start = AU_start;
+		access_unit.length = bytes_per_frame;
+		access_unit.PTS = static_cast<clockticks>(decoding_order) * 
+            (CLOCKS_per_90Kth_sec * ticks_per_frame_90kHz);
+		access_unit.DTS = access_unit.PTS;
+		access_unit.dorder = decoding_order;
+		decoding_order++;
+		aunits.Append( access_unit );
+		num_frames++;
+		
+		num_syncword++;
+
+		if (num_syncword >= old_frames+10 )
+		{
+			mjpeg_debug ("Got %d frame headers.", num_syncword);
+			old_frames=num_syncword;
+		}
+        mjpeg_debug( "Got frame %d\n", decoding_order );
+
+    }
+	last_buffered_AU = decoding_order;
+	eoscan =  bs.eos() || muxinto.AfterMaxPTS(access_unit.PTS);
+}
+
+
+
+void LPCMStream::Close()
+{
+    stream_length = AU_start / 8;
+	mjpeg_info ("AUDIO_STATISTICS: %02x", stream_id); 
+    mjpeg_info ("Audio stream length %lld bytes.", stream_length);
+    mjpeg_info   ("Frames         : %8u ",  num_frames);
+}
+
+/*************************************************************************
+	OutputAudioInfo
+	gibt gesammelte Informationen zu den Audio Access Units aus.
+
+	Prints information on audio access units
+*************************************************************************/
+
+void LPCMStream::OutputHdrInfo ()
+{
+	mjpeg_info("LPCM AUDIO STREAM:");
+
+    mjpeg_info ("Bit rate       : %8u bytes/sec (%u) bit/sec)",
+                NominalBitRate()/8, NominalBitRate() );
+    mjpeg_info ("Channels       :     %d", channels);
+    mjpeg_info ("Bits per sample:     %d", bits_per_sample );
+    mjpeg_info ("Frequency      :     %d Hz", samples_per_second );
+
+}
+
+
+unsigned int 
+LPCMStream::ReadPacketPayload(uint8_t *dst, unsigned int to_read)
+{
+    unsigned int header_size = LPCMStream::StreamHeaderSize();
+    bitcount_t read_start = bs.GetBytePos();
+    unsigned int bytes_read = bs.GetBytes( dst+header_size, 
+                                           to_read-header_size );
+    bs.Flush( read_start );
+    
+	clockticks   decode_time;
+    bool starting_frame_found = false;
+    uint8_t starting_frame_index = 0;
+
+    int starting_frame_offset = 
+        (new_au_next_sec || au_unsent > bytes_read )
+        ? 0 
+        : au_unsent;
+
+    unsigned int frames = 0;
+    unsigned int bytes_muxed = bytes_read;
+  
+	if (bytes_muxed == 0 || MuxCompleted() )
+    {
+		goto completion;
+    }
+
+
+	/* Work through what's left of the current frames and the
+	   following frames's updating the info until we reach a point where
+	   an frame had to be split between packets. 
+
+	   The DTS/PTS field for the packet in this case would have been
+	   given the that for the first AU to start in the packet.
+
+	*/
+
+	decode_time = RequiredDTS();
+	while (au_unsent < bytes_muxed)
+	{	  
+        assert( bytes_muxed > 1 );
+		bufmodel.Queued(au_unsent, decode_time);
+		bytes_muxed -= au_unsent;
+        if( new_au_next_sec )
+        {
+            ++frames;
+            if( ! starting_frame_found )
+            {
+                starting_frame_index = static_cast<uint8_t>(au->dorder % 20);
+                starting_frame_found = true;
+            }
+        }
+		if( !NextAU() )
+        {
+            goto completion;
+        }
+		new_au_next_sec = true;
+		decode_time = RequiredDTS();
+	};
+
+	// We've now reached a point where the current AU overran or
+	// fitted exactly.  We need to distinguish the latter case so we
+	// can record whether the next packet starts with the tail end of
+	// // an already started frame or a new one. We need this info to
+	// decide what PTS/DTS info to write at the start of the next
+	// packet.
+	
+	if (au_unsent > bytes_muxed)
+	{
+        if( new_au_next_sec )
+            ++frames;
+		bufmodel.Queued( bytes_muxed, decode_time);
+		au_unsent -= bytes_muxed;
+		new_au_next_sec = false;
+	} 
+	else //  if (au_unsent == bytes_muxed)
+	{
+		bufmodel.Queued(bytes_muxed, decode_time);
+        if( new_au_next_sec )
+            ++frames;
+        new_au_next_sec = NextAU();
+	}	   
+completion:
+    // Generate the LPCM header...
+    // Note the index counts from the low byte of the offset so
+    // the smallest value is 1!
+    dst[0] = LPCM_SUB_STR_0 + stream_num;
+    dst[1] = frames;
+    dst[2] = (starting_frame_offset+4)>>8;
+    dst[3] = (starting_frame_offset+4)&0xff;
+    unsigned int bps_code;
+    switch( bits_per_sample )
+    {
+    case 16 : bps_code = 0; break;
+    case 20 : bps_code = 1; break;
+    case 24 : bps_code = 2; break;
+    default : bps_code = 3; break;
+    }
+    dst[4] = starting_frame_index;
+    unsigned int bsf_code = (samples_per_second == 48000) ? 0 : 1;
+    unsigned int channels_code = channels - 1;
+    dst[5] = (bps_code << 6) | (bsf_code << 4) | channels_code;
+    dst[6] = dynamic_range_code;
+	return bytes_read+header_size;
+}
+
+
+
+/* 
+ * Local variables:
+ *  c-file-style: "stroustrup"
+ *  tab-width: 4
+ *  indent-tabs-mode: nil
+ * End:
+ */

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/mjpeg_logging.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/mjpeg_logging.c	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/mjpeg_logging.c	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,229 @@
+/*
+    $Id: mjpeg_logging.c,v 1.14 2005/05/18 17:21:47 sms00 Exp $
+
+    Copyright (C) 2000 Herbert Valerio Riedel <hvr at gnu.org>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#include <stdlib.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <assert.h>
+#include <string.h>
+
+#include "mjpeg_logging.h"
+
+#define MAX_DEFAULT_ID_SIZE 16
+#define DEFAULT_DEFAULT_ID "???"
+
+#ifdef HAVE___PROGNAME
+extern const char *__progname;
+#endif
+
+static log_level_t mjpeg_log_verbosity = LOG_NONE;
+static char default_handler_id[MAX_DEFAULT_ID_SIZE];
+static char default_handler_id_is_set = 0;
+
+static int default_mjpeg_log_filter( log_level_t level )
+{
+  int verb_from_env;
+  if( mjpeg_log_verbosity == 0 )
+    {
+      char *mjpeg_verb_env = getenv("MJPEG_VERBOSITY");
+      if( mjpeg_verb_env != NULL )
+        {
+          verb_from_env = LOG_WARN-atoi(mjpeg_verb_env);
+          if( verb_from_env >= LOG_DEBUG && verb_from_env <= LOG_ERROR )
+            mjpeg_log_verbosity = (log_level_t)verb_from_env;
+        }
+    }
+  return (level < LOG_WARN && level < mjpeg_log_verbosity);
+}
+
+static mjpeg_log_filter_t _filter = default_mjpeg_log_filter;
+
+static void
+default_mjpeg_log_handler(log_level_t level, const char message[])
+{
+  const char *ids;
+
+  if( (*_filter)( level ) )
+    return;
+  if (default_handler_id_is_set) {
+    ids = default_handler_id;
+  } else {
+#ifdef HAVE___PROGNAME
+    ids = __progname;
+#else
+    ids = DEFAULT_DEFAULT_ID;
+#endif
+  }
+  switch(level) {
+  case LOG_ERROR:
+    fprintf(stderr, "**ERROR: [%s] %s\n", ids, message);
+    break;
+  case LOG_DEBUG:
+    //fprintf(stderr, "--DEBUG: [%s] %s\n", ids, message);
+    break;
+  case LOG_WARN:
+    fprintf(stderr, "++ WARN: [%s] %s\n", ids, message);
+    break;
+  case LOG_INFO:
+    fprintf(stderr, "   INFO: [%s] %s\n", ids, message);
+    break;
+  default:
+    assert(0);
+  }
+}
+
+static mjpeg_log_handler_t _handler = default_mjpeg_log_handler;
+
+
+mjpeg_log_handler_t
+mjpeg_log_set_handler(mjpeg_log_handler_t new_handler)
+{
+  mjpeg_log_handler_t old_handler = _handler;
+
+  _handler = new_handler;
+
+  return old_handler;
+}
+
+/***************
+ *
+ * Set default log handlers degree of verboseity.
+ * 0 = quiet, 1 = info, 2 = debug
+ *
+ *************/
+
+int
+mjpeg_default_handler_verbosity(int verbosity)
+{
+  int prev_verb = mjpeg_log_verbosity;
+  mjpeg_log_verbosity = (log_level_t)(LOG_WARN - verbosity);
+  return prev_verb;
+}
+
+/*
+ * Set identifier string used by default handler
+ *
+ */
+int
+mjpeg_default_handler_identifier(const char *new_id)
+{
+  const char *s;
+  if (new_id == NULL) {
+    default_handler_id_is_set = 0;
+    return 0;
+  }
+  /* find basename of new_id (remove any directory prefix) */
+  if ((s = strrchr(new_id, '/')) == NULL)
+    s = new_id;
+  else
+    s = s + 1;
+  strncpy(default_handler_id, s, MAX_DEFAULT_ID_SIZE);
+  default_handler_id[MAX_DEFAULT_ID_SIZE-1] = '\0';
+  default_handler_id_is_set = 1;
+  return 0;
+}
+
+
+static void
+mjpeg_logv(log_level_t level, const char format[], va_list args)
+{
+  char buf[1024] = { 0, };
+
+  /* TODO: Original had a re-entrancy error trap to assist bug
+     finding.  To make this work with multi-threaded applications a
+     lock is needed hence delete.
+  */
+
+  
+  vsnprintf(buf, sizeof(buf)-1, format, args);
+
+  _handler(level, buf);
+}
+
+void
+mjpeg_log(log_level_t level, const char format[], ...)
+{
+  va_list args;
+  va_start (args, format);
+  mjpeg_logv(level, format, args);
+  va_end (args);
+}
+
+void
+mjpeg_debug(const char format[], ...)
+{
+  va_list args;
+  va_start (args, format);
+  mjpeg_logv(LOG_DEBUG, format, args);
+  va_end (args);
+}
+
+void
+mjpeg_info(const char format[], ...)
+{
+#if 0
+  va_list args;
+  va_start (args, format);
+  mjpeg_logv(LOG_INFO, format, args);
+  va_end (args);
+#endif
+}
+
+void
+mjpeg_warn(const char format[], ...)
+{
+  va_list args;
+  va_start (args, format);
+  mjpeg_logv(LOG_WARN, format, args);
+  va_end (args);
+}
+
+void
+mjpeg_error(const char format[], ...)
+{
+  va_list args;
+  va_start (args, format);
+  mjpeg_logv(LOG_ERROR, format, args);
+  va_end (args);
+}
+
+void
+mjpeg_error_exit1(const char format[], ...)
+{
+  va_list args;
+  va_start( args, format );
+  mjpeg_logv( LOG_ERROR, format, args);
+  va_end(args);           
+  exit(EXIT_FAILURE);
+}
+
+
+/* 
+ * Local variables:
+ *  c-file-style: "gnu"
+ *  tab-width: 8
+ *  indent-tabs-mode: nil
+ * End:
+ */

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/mjpeg_logging.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/mjpeg_logging.h	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/mjpeg_logging.h	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,80 @@
+/*
+    $Id: mjpeg_logging.h,v 1.8 2004/09/01 02:55:30 sms00 Exp $
+
+    Copyright (C) 2000 Herbert Valerio Riedel <hvr at gnu.org>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#ifndef __MJPEG_LOGGING_H__
+#define __MJPEG_LOGGING_H__
+
+#include <mjpeg_types.h>
+
+typedef enum {
+  LOG_NONE = 0,
+  LOG_DEBUG,
+  LOG_INFO,
+  LOG_WARN,
+  LOG_ERROR
+} log_level_t;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+void
+mjpeg_log(log_level_t level, const char format[], ...) GNUC_PRINTF(2, 3);
+
+typedef int(*mjpeg_log_filter_t)(log_level_t level);
+    
+typedef void(*mjpeg_log_handler_t)(log_level_t level, const char message[]);
+
+mjpeg_log_handler_t
+mjpeg_log_set_handler(mjpeg_log_handler_t new_handler);
+
+int
+mjpeg_default_handler_identifier(const char *new_id);
+
+int
+mjpeg_default_handler_verbosity(int verbosity);
+
+void
+mjpeg_debug(const char format[], ...) GNUC_PRINTF(1,2);
+
+void
+mjpeg_info(const char format[], ...) GNUC_PRINTF(1,2);
+
+void
+mjpeg_warn(const char format[], ...) GNUC_PRINTF(1,2);
+
+void
+mjpeg_error(const char format[], ...) GNUC_PRINTF(1,2);
+
+void
+mjpeg_error_exit1(const char format[], ...) GNUC_PRINTF(1,2);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* __MJPEG_LOGGING_H__ */
+
+
+/* 
+ * Local variables:
+ *  c-file-style: "gnu"
+ *  tab-width: 8
+ *  indent-tabs-mode: nil
+ * End:
+ */

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/mjpeg_types.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/mjpeg_types.h	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/mjpeg_types.h	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,42 @@
+/*
+    $Id: mjpeg_types.h,v 1.14 2005/05/18 17:21:47 sms00 Exp $
+
+    Copyright (C) 2000 Herbert Valerio Riedel <hvr at gnu.org>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#ifndef __MJPEG_TYPES_H__
+#define __MJPEG_TYPES_H__
+
+#include "ADM_default.h"
+
+#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ > 4)
+#define GNUC_PRINTF( format_idx, arg_idx )    \
+  __attribute__((format (printf, format_idx, arg_idx)))
+#else   /* !__GNUC__ */
+#define GNUC_PRINTF( format_idx, arg_idx )
+#endif  /* !__GNUC__ */
+
+#endif /* __MJPEG_TYPES_H__ */
+
+
+/* 
+ * Local variables:
+ *  c-file-style: "gnu"
+ *  tab-width: 8
+ *  indent-tabs-mode: nil
+ * End:
+ */

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/mpastrm_in.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/mpastrm_in.cpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/mpastrm_in.cpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,335 @@
+/*
+ *  audiostrm_in.c: MPEG Audio strem class members handling scanning
+ *  and buffering raw input stream.
+ *
+ *  Copyright (C) 2001 Andrew Stevens <andrew.stevens at philips.com>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of version 2 of the GNU General Public License
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#include <config.h>
+#include <math.h>
+#include <stdlib.h>
+
+#include "audiostrm.hpp"
+#include "interact.hpp"
+#include "multiplexor.hpp"
+
+
+static const char *mpa_audio_version[4] =
+{
+	"2.5",
+	"2.0",
+	"reserved",
+	"1.0"
+};
+
+static const unsigned int mpa_bitrates_kbps [4][3][16] =
+{
+	{ /* MPEG audio V2.5 */
+		{0,32,48,56,64,80,96,112,128,144,160,176,192,224,256,0},
+		{0,8,16,24,32,40,48,56,64,80,96,112,128,144,160,0},
+		{0,8,16,24,32,40,48,56,64,80,96,112,128,144,160,0}
+	},
+	{ /*RESERVED*/
+		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
+		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
+		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
+	},
+	{ /* MPEG audio V2 */
+		{0,32,48,56,64,80,96,112,128,144,160,176,192,224,256,0},
+		{0,8,16,24,32,40,48,56,64,80,96,112,128,144,160,0},
+		{0,8,16,24,32,40,48,56,64,80,96,112,128,144,160,0}
+	},
+	{ /* MPEG audio V1 */
+		{0,32,64,96,128,160,192,224,256,288,320,352,384,416,448,0},
+		{0,32,48,56,64,80,96,112,128,160,192,224,256,320,384,0},
+		{0,32,40,48,56,64,80,96,112,128,160,192,224,256,320,0}
+	}
+
+};
+
+
+static const int mpa_freq_table [4][4] = 
+{
+	/* MPEG audio V2.5 */
+	{11025,12000,8000,0},
+	/* RESERVED */
+	{ 0, 0, 0, 0 }, 
+	/* MPEG audio V2 */
+	{22050,24000, 16000,0},
+	/* MPEG audio V1 */
+	{44100, 48000, 32000, 0}
+};
+
+static const char mpa_stereo_mode [4][15] =
+{ "stereo", "joint stereo", "dual channel", "single channel" };
+static const char mpa_copyright_status [2][20] =
+{ "no copyright","copyright protected" };
+static const char mpa_original_bit [2][10] =
+{ "copy","original" };
+static const char mpa_emphasis_mode [4][20] =
+{ "none", "50/15 microseconds", "reserved", "CCITT J.17" };
+static const unsigned int mpa_slots [4] = {12, 144, 144, 0};
+static const unsigned int mpa_samples [4] = {384, 1152, 1152, 0};
+
+
+
+MPAStream::MPAStream(IBitStream &ibs, Multiplexor &into) : 
+	AudioStream( ibs, into )
+{
+	for( int i = 0; i <2 ; ++i )
+		num_frames[i] = size_frames[i] = 0;
+}
+
+bool MPAStream::Probe(IBitStream &bs )
+{
+    return bs.GetBits(11) == AUDIO_SYNCWORD;
+}
+
+
+/*************************************************************************
+ *
+ * Reads initial stream parameters and displays feedback banner to users
+ *
+ *************************************************************************/
+
+
+void MPAStream::Init ( const int stream_num )
+
+{
+	int padding_bit;
+
+	MuxStream::Init( AUDIO_STR_0 + stream_num, 
+					 0,  // Buffer scale
+					 muxinto.audio_buffer_size,
+					 muxinto.vcd_zero_stuffing,
+					 muxinto.buffers_in_audio,
+					 muxinto.always_buffers_in_audio
+		);
+    mjpeg_info ("Scanning for header info: Audio stream %02x (%s)",
+                AUDIO_STR_0 + stream_num,
+                bs.StreamName()
+                );
+
+	/* A.Stevens 2000 - update to be compatible up to  MPEG2.5
+	 */
+    AU_start = bs.bitcount();
+    if (bs.GetBits(11)==AUDIO_SYNCWORD)
+    {
+		num_syncword++;
+		version_id = bs.GetBits( 2);
+		layer 		= 3-bs.GetBits( 2); /* 0..2 not 1..3!! */
+		protection 		= bs.Get1Bit();
+		bit_rate_code	= bs.GetBits( 4);
+		frequency 		= bs.GetBits( 2);
+		padding_bit     = bs.Get1Bit();
+		bs.Get1Bit();
+		mode 		= bs.GetBits( 2);
+		mode_extension 	= bs.GetBits( 2);
+		copyright 		= bs.Get1Bit();
+		original_copy 	= bs.Get1Bit ();
+		emphasis		= bs.GetBits( 2);
+
+		framesize =
+			mpa_bitrates_kbps[version_id][layer][bit_rate_code]  * 
+			mpa_slots[layer] *1000 /
+			mpa_freq_table[version_id][frequency];
+
+		size_frames[0] = framesize * ( layer == 0 ? 4 : 1);
+		size_frames[1] = (framesize+1) * ( layer == 0 ? 4 : 1);
+		num_frames[padding_bit]++;
+        access_unit.start  = AU_start;
+		access_unit.length = size_frames[padding_bit];
+	  
+		samples_per_second = mpa_freq_table[version_id][frequency];
+
+		/* Presentation time-stamping  */
+		access_unit.PTS = static_cast<clockticks>(decoding_order) * 
+			static_cast<clockticks>(mpa_samples [layer]) * 
+			static_cast<clockticks>(CLOCKS)	/ samples_per_second;
+		access_unit.DTS = access_unit.PTS;
+		access_unit.dorder = decoding_order;
+		++decoding_order;
+		aunits.Append( access_unit );
+
+    } else
+    {
+		mjpeg_error ( "Invalid MPEG Audio stream header.");
+		exit (1);
+    }
+
+
+	OutputHdrInfo();
+}
+
+unsigned int MPAStream::NominalBitRate()
+{ 
+	return mpa_bitrates_kbps[version_id][layer][bit_rate_code]*1024;
+}
+
+
+unsigned int MPAStream::SizeFrame( int rate_code, int padding )
+{
+	return ( mpa_bitrates_kbps[version_id][layer][rate_code]  * 
+		mpa_slots [layer] *1000 /
+		mpa_freq_table[version_id][frequency] + padding ) * ( layer == 0 ? 4 : 1);
+}
+
+void MPAStream::FillAUbuffer(unsigned int frames_to_buffer )
+{
+	unsigned int padding_bit;
+	last_buffered_AU += frames_to_buffer;
+
+    if( eoscan )
+        return;
+
+    mjpeg_debug( "Scanning %d MPA frames to frame %d", 
+                frames_to_buffer,
+                last_buffered_AU );
+	while( !bs.eos() 
+           && decoding_order < last_buffered_AU 
+           && !muxinto.AfterMaxPTS(access_unit.PTS) )
+	{
+
+		int skip=access_unit.length-4;
+        bs.SeekFwdBits( skip );
+		prev_offset = AU_start;
+		AU_start = bs.bitcount();
+        if( AU_start - prev_offset != access_unit.length*8 )
+        {
+            mjpeg_warn("Discarding incomplete final frame MPEG audio stream %02x!",
+                       stream_id
+                       );
+            aunits.DropLast();
+            --decoding_order;
+            break;
+        }
+		/* Check we have reached the end of have  another catenated 
+		   stream to process before finishing ... */
+		if ( (syncword = bs.GetBits( 11))!=AUDIO_SYNCWORD )
+		{
+            //
+            // Handle a broken last frame...
+			if( !bs.eos()   )
+			{
+                mjpeg_warn( "Data follows end of last recogniseable MPEG audio frame - bad stream?");
+                eoscan = true;
+                return;
+			}
+            break;
+		}
+		// Skip version_id:2, layer:2, protection:1
+		(void) bs.GetBits( 5);
+		int rate_code	= bs.GetBits( 4);
+		// Skip frequency
+		(void) bs.GetBits( 2);
+
+		padding_bit=bs.Get1Bit();
+		access_unit.start = AU_start;
+		access_unit.length = SizeFrame( rate_code, padding_bit );
+		access_unit.PTS = static_cast<clockticks>(decoding_order) * static_cast<clockticks>(mpa_samples[layer]) * static_cast<clockticks>(CLOCKS)
+			/ samples_per_second;
+		access_unit.DTS = access_unit.PTS;
+		access_unit.dorder = decoding_order;
+		decoding_order++;
+		aunits.Append( access_unit );
+		num_frames[padding_bit]++;
+
+		bs.GetBits( 9);
+		
+		num_syncword++;
+
+		if (num_syncword >= old_frames+10 )
+		{
+			mjpeg_debug ("Got %d frame headers.", num_syncword);
+			old_frames=num_syncword;
+		
+		}
+	
+
+
+    }
+	last_buffered_AU = decoding_order;
+	eoscan = bs.eos() || muxinto.AfterMaxPTS(access_unit.PTS);
+}
+
+
+
+void MPAStream::Close()
+{
+    stream_length = AU_start >> 3;
+	mjpeg_info ("AUDIO_STATISTICS: %02x", stream_id); 
+    mjpeg_info ("Audio stream length %lld bytes.", stream_length);
+    mjpeg_info   ("Syncwords      : %8u",num_syncword);
+    mjpeg_info   ("Frames         : %8u padded",  num_frames[0]);
+    mjpeg_info   ("Frames         : %8u unpadded", num_frames[1]);
+	
+}
+
+/*************************************************************************
+	OutputAudioInfo
+	gibt gesammelte Informationen zu den Audio Access Units aus.
+
+	Prints information on audio access units
+*************************************************************************/
+
+void MPAStream::OutputHdrInfo ()
+{
+    unsigned int bitrate;
+    bitrate = mpa_bitrates_kbps[version_id][layer][bit_rate_code];
+
+
+	mjpeg_info("MPEG AUDIO STREAM: %02x", stream_id);
+	mjpeg_info("Audio version  : %s", mpa_audio_version[version_id]);
+    mjpeg_info("Layer          : %8u",layer+1);
+
+    if (protection == 0) mjpeg_info ("CRC checksums  :      yes");
+    else  mjpeg_info ("CRC checksums  :       no");
+
+    if (bit_rate_code == 0)
+		mjpeg_info ("Bit rate       :     free");
+    else if (bit_rate_code == 0xf)
+		mjpeg_info ("Bit rate       : reserved");
+    else
+		mjpeg_info ("Bit rate       : %8u bytes/sec (%3u kbit/sec)",
+				bitrate*128, bitrate);
+
+    if (frequency == 3)
+		mjpeg_info ("Frequency      : reserved");
+    else
+		mjpeg_info ("Frequency      :     %d Hz",
+				mpa_freq_table[version_id][frequency]);
+
+    mjpeg_info   ("Mode           : %8u %s",
+			  mode,mpa_stereo_mode[mode]);
+    mjpeg_info   ("Mode extension : %8u",mode_extension);
+    mjpeg_info   ("Copyright bit  : %8u %s",
+			  copyright,mpa_copyright_status[copyright]);
+    mjpeg_info   ("Original/Copy  : %8u %s",
+			  original_copy,mpa_original_bit[original_copy]);
+    mjpeg_info   ("Emphasis       : %8u %s",
+			  emphasis,mpa_emphasis_mode[emphasis]);
+}
+
+
+
+/* 
+ * Local variables:
+ *  c-file-style: "stroustrup"
+ *  tab-width: 4
+ *  indent-tabs-mode: nil
+ * End:
+ */

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/mpegconsts.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/mpegconsts.c	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/mpegconsts.c	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,484 @@
+
+/*
+ *  mpegconsts.c:  Video format constants for MPEG and utilities for display
+ *                 and conversion to format used for yuv4mpeg
+ *
+ *  Copyright (C) 2001 Andrew Stevens <andrew.stevens at philips.com>
+ *  Copyright (C) 2001 Matthew Marjanovic <maddog at mir.com>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of version 2 of the GNU General Public License
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#include <config.h>
+#include "mpegconsts.h"
+#include "yuv4mpeg.h"
+#include "yuv4mpeg_intern.h"
+
+static y4m_ratio_t
+mpeg_framerates[] = {
+  Y4M_FPS_UNKNOWN,
+  Y4M_FPS_NTSC_FILM,
+  Y4M_FPS_FILM,
+  Y4M_FPS_PAL,
+  Y4M_FPS_NTSC,
+  Y4M_FPS_30,
+  Y4M_FPS_PAL_FIELD,
+  Y4M_FPS_NTSC_FIELD,
+  Y4M_FPS_60
+};
+
+
+#define MPEG_NUM_RATES (sizeof(mpeg_framerates)/sizeof(mpeg_framerates[0]))
+static const mpeg_framerate_code_t mpeg_num_framerates = MPEG_NUM_RATES;
+
+//static const char *
+//framerate_definitions[MPEG_NUM_RATES] =
+//{
+//   "illegal", 
+//  "24000.0/1001.0 (NTSC 3:2 pulldown converted FILM)",
+//  "24.0 (NATIVE FILM)",
+//  "25.0 (PAL/SECAM VIDEO / converted FILM)",
+//  "30000.0/1001.0 (NTSC VIDEO)",
+//  "30.0",
+//  "50.0 (PAL FIELD RATE)",
+//  "60000.0/1001.0 (NTSC FIELD RATE)",
+//  "60.0"
+//};
+
+
+static const char *mpeg1_aspect_ratio_definitions[] =
+{
+    "illegal",
+	"1:1 (square pixels)",
+	"1:0.6735",
+	"1:0.7031 (16:9 Anamorphic PAL/SECAM for 720x578/352x288 images)",
+	"1:0.7615",
+	"1:0.8055",
+	"1:0.8437 (16:9 Anamorphic NTSC for 720x480/352x240 images)",
+	"1:0.8935",
+	"1:0.9375 (4:3 PAL/SECAM for 720x578/352x288 images)",
+	"1:0.9815",
+	"1:1.0255",
+	"1:1:0695",
+	"1:1.1250 (4:3 NTSC for 720x480/352x240 images)",
+	"1:1.1575",
+	"1:1.2015"
+};
+
+static const y4m_ratio_t mpeg1_aspect_ratios[] =
+{
+    Y4M_SAR_UNKNOWN,
+	Y4M_SAR_MPEG1_1,
+	Y4M_SAR_MPEG1_2,
+	Y4M_SAR_MPEG1_3, /* Anamorphic 16:9 PAL */
+	Y4M_SAR_MPEG1_4,
+	Y4M_SAR_MPEG1_5,
+	Y4M_SAR_MPEG1_6, /* Anamorphic 16:9 NTSC */
+	Y4M_SAR_MPEG1_7,
+	Y4M_SAR_MPEG1_8, /* PAL/SECAM 4:3 */
+	Y4M_SAR_MPEG1_9,
+	Y4M_SAR_MPEG1_10,
+	Y4M_SAR_MPEG1_11,
+	Y4M_SAR_MPEG1_12, /* NTSC 4:3 */
+	Y4M_SAR_MPEG1_13,
+	Y4M_SAR_MPEG1_14,
+};
+
+static const char *mpeg2_aspect_ratio_definitions[] = 
+{
+    "illegal",
+	"1:1 pixels",
+	"4:3 display",
+	"16:9 display",
+	"2.21:1 display"
+};
+
+
+static const y4m_ratio_t mpeg2_aspect_ratios[] =
+{
+    Y4M_DAR_UNKNOWN,
+	Y4M_DAR_MPEG2_1,
+	Y4M_DAR_MPEG2_2,
+ 	Y4M_DAR_MPEG2_3,
+	Y4M_DAR_MPEG2_4
+};
+
+static const char **aspect_ratio_definitions[2] = 
+{
+	mpeg1_aspect_ratio_definitions,
+	mpeg2_aspect_ratio_definitions
+};
+
+//static const y4m_ratio_t *mpeg_aspect_ratios[2] = 
+//{
+//	mpeg1_aspect_ratios,
+//	mpeg2_aspect_ratios
+//};
+
+static const mpeg_aspect_code_t mpeg_num_aspect_ratios[2] = 
+{
+  sizeof(mpeg1_aspect_ratios)/sizeof(mpeg1_aspect_ratios[0]),
+  sizeof(mpeg2_aspect_ratios)/sizeof(mpeg2_aspect_ratios[0])
+};
+
+
+/*
+ * Is code a valid MPEG framerate code?
+ */
+
+int
+MX_mpeg_valid_framerate_code( mpeg_framerate_code_t code )
+{
+    return ((code > 0) && (code < mpeg_num_framerates)) ? 1 : 0;
+}
+
+
+/*
+ * Convert MPEG frame-rate code to corresponding frame-rate
+ */
+
+y4m_ratio_t
+MX_mpeg_framerate( mpeg_framerate_code_t code )
+{
+    if ((code > 0) && (code < mpeg_num_framerates))
+		return mpeg_framerates[code];
+    else
+		return y4m_fps_UNKNOWN;
+}
+
+///*
+// * Look-up MPEG frame rate code for a (exact) frame rate.
+// */
+//
+//
+//mpeg_framerate_code_t 
+//mpeg_framerate_code( y4m_ratio_t framerate )
+//{
+//	mpeg_framerate_code_t i;
+//  
+//	y4m_ratio_reduce(&framerate);
+//    /* start at '1', because 0 is unknown/illegal */
+//	for (i = 1; i < mpeg_num_framerates; ++i) {
+//		if (Y4M_RATIO_EQL(framerate, mpeg_framerates[i]))
+//			return i;
+//	}
+//	return 0;
+//}
+//
+//
+///* small enough to distinguish 1/1000 from 1/1001 */
+//#define MPEG_FPS_TOLERANCE 0.0001
+//
+//
+//y4m_ratio_t
+//mpeg_conform_framerate( double fps )
+//{
+//	mpeg_framerate_code_t i;
+//	y4m_ratio_t result;
+//
+//	/* try to match it to a standard frame rate */
+//    /* (start at '1', because 0 is unknown/illegal) */
+//	for (i = 1; i < mpeg_num_framerates; i++) 
+//	{
+//		double deviation = 1.0 - (Y4M_RATIO_DBL(mpeg_framerates[i]) / fps);
+//		if ( (deviation > -MPEG_FPS_TOLERANCE) &&
+//			 (deviation < +MPEG_FPS_TOLERANCE) )
+//			return mpeg_framerates[i];
+//	}
+//	/* no luck?  just turn it into a ratio (6 decimal place accuracy) */
+//	result.n = (int)((fps * 1000000.0) + 0.5);
+//	result.d = 1000000;
+//	y4m_ratio_reduce(&result);
+//	return result;
+//}
+
+  
+
+/*
+ * Is code a valid MPEG aspect-ratio code?
+ */
+
+int
+MX_mpeg_valid_aspect_code( int version, mpeg_framerate_code_t c )
+{
+	if ((version == 1) || (version == 2))
+        return ((c > 0) && (c < mpeg_num_aspect_ratios[version-1])) ? 1 : 0;
+    else
+        return 0;
+}
+
+
+///*
+// * Convert MPEG aspect-ratio code to corresponding aspect-ratio
+// */
+//
+//y4m_ratio_t 
+//mpeg_aspect_ratio( int mpeg_version,  mpeg_aspect_code_t code )
+//{
+//	y4m_ratio_t ratio;
+//    if ((mpeg_version >= 1) && (mpeg_version <= 2) &&
+//        (code > 0) && (code < mpeg_num_aspect_ratios[mpeg_version-1]))
+//	{
+//		ratio = mpeg_aspect_ratios[mpeg_version-1][code];
+//		y4m_ratio_reduce(&ratio);
+//		return ratio;
+//	}
+//    else
+//		return y4m_sar_UNKNOWN;
+//}
+//
+//
+//
+///*
+// * Look-up corresponding MPEG aspect ratio code given an exact aspect ratio.
+// *
+// * WARNING: The semantics of aspect ratio coding *changed* between
+// * MPEG1 and MPEG2.  In MPEG1 it is the *pixel* aspect ratio. In
+// * MPEG2 it is the (far more sensible) aspect ratio of the eventual
+// * display.
+// *
+// */
+//
+//mpeg_aspect_code_t 
+//mpeg_frame_aspect_code( int mpeg_version, y4m_ratio_t aspect_ratio )
+//{
+//	mpeg_aspect_code_t i;
+//	y4m_ratio_t red_ratio = aspect_ratio;
+//	y4m_ratio_reduce( &red_ratio );
+//	if( mpeg_version < 1 || mpeg_version > 2 )
+//		return 0;
+//    /* (start at '1', because 0 is unknown/illegal) */
+//	for( i = 1; i < mpeg_num_aspect_ratios[mpeg_version-1]; ++i )
+//	{
+//		y4m_ratio_t red_entry =  mpeg_aspect_ratios[mpeg_version-1][i];
+//		y4m_ratio_reduce( &red_entry );
+//		if(  Y4M_RATIO_EQL( red_entry, red_ratio) )
+//			return i;
+//	}
+//
+//	return 0;
+//			
+//}
+//
+//
+//
+///*
+// * Guess the correct MPEG aspect ratio code,
+// *  given the true sample aspect ratio and frame size of a video stream
+// *  (and the MPEG version, 1 or 2).
+// *
+// * Returns 0 if it has no good guess.
+// *
+// */
+//
+//
+///* this is big enough to accommodate the difference between 720 and 704 */
+//#define GUESS_ASPECT_TOLERANCE 0.03
+//
+//mpeg_aspect_code_t 
+//mpeg_guess_mpeg_aspect_code(int mpeg_version, y4m_ratio_t sampleaspect,
+//							int frame_width, int frame_height)
+//{
+//	if (Y4M_RATIO_EQL(sampleaspect, y4m_sar_UNKNOWN))
+//    {
+//		return 0;
+//    }
+//	switch (mpeg_version) {
+//	case 1:
+//		if (Y4M_RATIO_EQL(sampleaspect, y4m_sar_SQUARE))
+//		{
+//			return 1;
+//		} 
+//		else if (Y4M_RATIO_EQL(sampleaspect, y4m_sar_NTSC_CCIR601))
+//		{
+//			return 12;
+//		} 
+//		else if (Y4M_RATIO_EQL(sampleaspect, y4m_sar_NTSC_16_9))
+//		{
+//			return 6;
+//		} 
+//		else if (Y4M_RATIO_EQL(sampleaspect, y4m_sar_PAL_CCIR601))
+//		{
+//			return 8;
+//		} 
+//		else if (Y4M_RATIO_EQL(sampleaspect, y4m_sar_PAL_16_9))
+//		{
+//			return 3;
+//		} 
+//		return 0;
+//		break;
+//	case 2:
+//		if (Y4M_RATIO_EQL(sampleaspect, y4m_sar_SQUARE))
+//		{
+//			return 1;  /* '1' means square *pixels* in MPEG-2; go figure. */
+//		}
+//		else
+//		{
+//			int i;
+//			double true_far;  /* true frame aspect ratio */
+//			true_far = 
+//				(double)(sampleaspect.n * frame_width) /
+//				(double)(sampleaspect.d * frame_height);
+//			/* start at '2'... */
+//			for (i = 2; i < (int)(mpeg_num_aspect_ratios[mpeg_version-1]); i++) 
+//			{
+//				double ratio = 
+//					true_far / Y4M_RATIO_DBL(mpeg_aspect_ratios[mpeg_version-1][i]);
+//				if ( (ratio > (1.0 - GUESS_ASPECT_TOLERANCE)) &&
+//					 (ratio < (1.0 + GUESS_ASPECT_TOLERANCE)) )
+//					return i;
+//			}
+//			return 0;
+//		}
+//		break;
+//	default:
+//		return 0;
+//		break;
+//	}
+//}
+//
+//
+//
+//
+///*
+// * Guess the true sample aspect ratio of a video stream,
+// *  given the MPEG aspect ratio code and the actual frame size
+// *  (and the MPEG version, 1 or 2).
+// *
+// * Returns y4m_sar_UNKNOWN if it has no good guess.
+// *
+// */
+//y4m_ratio_t 
+//mpeg_guess_sample_aspect_ratio(int mpeg_version,
+//							   mpeg_aspect_code_t code,
+//							   int frame_width, int frame_height)
+//{
+//	switch (mpeg_version) 
+//	{
+//	case 1:
+//		/* MPEG-1 codes turn into SAR's, just not quite the right ones.
+//		   For the common/known values, we provide the ratio used in practice,
+//		   otherwise say we don't know.*/
+//		switch (code)
+//		{
+//		case 1:  return y4m_sar_SQUARE;        break;
+//		case 3:  return y4m_sar_PAL_16_9;      break;
+//		case 6:  return y4m_sar_NTSC_16_9;     break;
+//		case 8:  return y4m_sar_PAL_CCIR601;   break;
+//		case 12: return y4m_sar_NTSC_CCIR601;  break;
+//		default:
+//			return y4m_sar_UNKNOWN;       break;
+//		}
+//		break;
+//	case 2:
+//		/* MPEG-2 codes turn into Display Aspect Ratios, though not exactly the
+//		   DAR's used in practice.  For common/standard frame sizes, we provide
+//		   the original SAR; otherwise, we say we don't know. */
+//		if (code == 1) 
+//		{
+//			return y4m_sar_SQUARE; /* '1' means square *pixels* in MPEG-2 */
+//		}
+//		else if ((code >= 2) && (code <= 4))
+//		{
+//            return y4m_guess_sar(frame_width, frame_height,
+//                                 mpeg2_aspect_ratios[code]);
+//		} 
+//		else
+//		{
+//			return y4m_sar_UNKNOWN;
+//		}
+//		break;
+//	default:
+//		return y4m_sar_UNKNOWN;
+//		break;
+//	}
+//}
+//
+//
+//
+//
+//
+///*
+// * Look-up MPEG explanatory definition string for frame rate code
+// *
+// */
+//
+//
+//const char *
+//mpeg_framerate_code_definition(   mpeg_framerate_code_t code  )
+//{
+//	if( code == 0 || code >=  mpeg_num_framerates )
+//		return "UNDEFINED: illegal/reserved frame-rate ratio code";
+//
+//	return framerate_definitions[code];
+//}
+
+/*
+ * Look-up MPEG explanatory definition string aspect ratio code for an
+ * aspect ratio code
+ *
+ */
+
+const char *
+MX_mpeg_aspect_code_definition( int mpeg_version,  mpeg_aspect_code_t code  )
+{
+	if( mpeg_version < 1 || mpeg_version > 2 )
+		return "UNDEFINED: illegal MPEG version";
+	
+	if( code < 1 || code >=  mpeg_num_aspect_ratios[mpeg_version-1] )
+		return "UNDEFINED: illegal aspect ratio code";
+
+	return aspect_ratio_definitions[mpeg_version-1][code];
+}
+
+
+///*
+// * Look-up explanatory definition of interlace field order code
+// *
+// */
+//
+//const char *
+//mpeg_interlace_code_definition( int yuv4m_interlace_code )
+//{
+//	const char *def;
+//	switch( yuv4m_interlace_code )
+//	{
+//	case Y4M_UNKNOWN :
+//		def = "unknown";
+//		break;
+//	case Y4M_ILACE_NONE :
+//		def = "none/progressive";
+//		break;
+//	case Y4M_ILACE_TOP_FIRST :
+//		def = "top-field-first";
+//		break;
+//	case Y4M_ILACE_BOTTOM_FIRST :
+//		def = "bottom-field-first";
+//		break;
+//	default :
+//		def = "UNDEFINED: illegal video interlacing type-code!";
+//		break;
+//	}
+//	return def;
+//}
+
+
+/* 
+ * Local variables:
+ *  c-file-style: "stroustrup"
+ *  tab-width: 4
+ *  indent-tabs-mode: nil
+ * End:
+ */

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/mpegconsts.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/mpegconsts.h	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/mpegconsts.h	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,165 @@
+
+/*
+ *  mpegconsts.c:  Video format constants for MPEG and utilities for display
+ *                 and conversion to format used for yuv4mpeg
+ *
+ *  Copyright (C) 2001 Andrew Stevens <andrew.stevens at philips.com>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of version 2 of the GNU General Public License
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#ifndef __MPEGCONSTS_H__
+#define __MPEGCONSTS_H__
+
+#include <yuv4mpeg.h>
+
+typedef unsigned int mpeg_framerate_code_t;
+typedef unsigned int mpeg_aspect_code_t;
+
+#ifdef __cplusplus
+#define START_CPP_WRAP extern "C" {
+#define END_CPP_WRAP };
+#else
+#define START_CPP_WRAP
+#define END_CPP_WRAP
+#endif
+
+START_CPP_WRAP
+
+
+/*
+ * Convert MPEG frame-rate code to corresponding frame-rate
+ *  y4m_fps_UNKNOWN = { 0, 0 } = Undefined/resrerved code.
+ */
+
+y4m_ratio_t
+MX_mpeg_framerate( mpeg_framerate_code_t code );
+
+
+/*
+ * Is code a valid MPEG frame-rate code?
+ * Return 1 if true; 0 otherwise.
+ */
+
+int
+MX_mpeg_valid_framerate_code( mpeg_framerate_code_t code );
+
+
+///*
+// * Look-up MPEG frame rate code for a (exact) frame rate.
+// *  0 = No MPEG code defined for frame-rate
+// */
+//
+//mpeg_framerate_code_t 
+//mpeg_framerate_code( y4m_ratio_t framerate );
+//
+//
+///*
+// * Convert floating-point framerate to an exact ratio.
+// *  Uses a standard MPEG rate, if it finds one within MPEG_FPS_TOLERANCE
+// *  (see mpegconsts.c), otherwise uses "fps:1000000" as the ratio.
+// */
+//
+//y4m_ratio_t
+//mpeg_conform_framerate( double fps );
+//
+//
+///*
+// * Convert MPEG aspect ratio code to corresponding aspect ratio
+// *
+// * WARNING: The semantics of aspect ratio coding *changed* between
+// * MPEG1 and MPEG2.  In MPEG1 it is the *pixel* aspect ratio. In
+// * MPEG2 it is the (far more sensible) aspect ratio of the eventual
+// * display.
+// *
+// */
+//
+//y4m_ratio_t
+//mpeg_aspect_ratio( int mpeg_version,  mpeg_aspect_code_t code );
+
+
+/*
+ * Is code a valid MPEG(1,2) aspect-ratio code?
+ * Return 1 if true; 0 otherwise.
+ */
+
+int
+MX_mpeg_valid_aspect_code( int mpeg_version, mpeg_aspect_code_t code );
+
+
+///*
+// * Look-up MPEG aspect ratio code for an aspect ratio - tolerance
+// * is Y4M_ASPECT_MULT used by YUV4MPEG (see yuv4mpeg_intern.h)
+// *
+// * WARNING: The semantics of aspect ratio coding *changed* between
+// * MPEG1 and MPEG2.  In MPEG1 it is the *pixel* aspect ratio. In
+// * MPEG2 it is the (far more sensible) aspect ratio of the eventual
+// * display.
+// *
+// */
+//
+//mpeg_aspect_code_t 
+//mpeg_frame_aspect_code( int mpeg_version, y4m_ratio_t aspect_ratio );
+
+/*
+ * Look-up MPEG explanatory definition string aspect ratio code for an
+ * aspect ratio code
+ *
+ */
+
+const char *
+MX_mpeg_aspect_code_definition( int mpeg_version,  mpeg_aspect_code_t code  );
+
+///*
+// * Look-up MPEG explanatory definition string aspect ratio code for an
+// * frame rate code
+// *
+// */
+//
+//const char *
+//mpeg_framerate_code_definition( mpeg_framerate_code_t code  );
+//
+//const char *
+//mpeg_interlace_code_definition( int yuv4m_interlace_code );
+//
+//
+///*
+// * Guess the correct MPEG aspect ratio code,
+// *  given the true sample aspect ratio and frame size of a video stream
+// *  (and the MPEG version, 1 or 2).
+// *
+// * Returns 0 if it has no good answer.
+// *
+// */
+//mpeg_aspect_code_t 
+//mpeg_guess_mpeg_aspect_code(int mpeg_version, y4m_ratio_t sampleaspect,
+//			    int frame_width, int frame_height);
+//
+///*
+// * Guess the true sample aspect ratio of a video stream,
+// *  given the MPEG aspect ratio code and the actual frame size
+// *  (and the MPEG version, 1 or 2).
+// *
+// * Returns y4m_sar_UNKNOWN if it has no good answer.
+// *
+// */
+//y4m_ratio_t 
+//mpeg_guess_sample_aspect_ratio(int mpeg_version,
+//			       mpeg_aspect_code_t code,
+//			       int frame_width, int frame_height);
+
+END_CPP_WRAP
+
+#endif /* __MPEGCONSTS_H__ */

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/mplexconsts.hpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/mplexconsts.hpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/mplexconsts.hpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,87 @@
+#ifndef __MPLEXCONSTS_H__
+#define __MPLEXCONSTS_H__
+
+
+#define SEQUENCE_HEADER 	0x000001b3
+#define SEQUENCE_END		0x000001b7
+#define PICTURE_START		0x00000100
+#define EXT_START_CODE 0x000001b5
+#define GROUP_START		0x000001b8
+#define SYNCWORD_START		0x000001
+
+#define ZA_SEQUENCE_HEADER      0x000001f8
+
+#define IFRAME                  1
+#define PFRAME                  2
+#define BFRAME                  3
+#define DFRAME                  4
+#define NOFRAME                 5
+
+#define PIC_TOP_FIELD 1
+#define PIC_BOT_FIELD 2
+#define PIC_FRAME 3
+
+#define CODING_EXT_ID       8
+#define AUDIO_SYNCWORD		0x7ff
+
+
+#define PACK_START		0x000001ba
+#define SYS_HEADER_START	0x000001bb
+#define ISO11172_END		0x000001b9
+#define PACKET_START		0x000001
+
+#define MAX_FFFFFFFF		4294967295.0 	/* = 0xffffffff in dec.	*/
+
+#define CLOCKS_per_90Kth_sec 300
+
+#define CLOCKS			(CLOCKS_per_90Kth_sec*90000)	
+/* MPEG-2 System Clock Hertz - we divide down by 300.0 for MPEG-1*/
+
+/* Range of sizes of the fields following the packet length field in packet header:
+	used to calculate if recieve buffers will have enough space... */
+
+#define MPEG2_BUFFERINFO_LENGTH 3
+#define MPEG1_BUFFERINFO_LENGTH 2
+#define DTS_PTS_TIMESTAMP_LENGTH 5
+#define MPEG2_AFTER_PACKET_LENGTH_MIN    3
+#define MPEG1_AFTER_PACKET_LENGTH_MIN    (0+1)
+
+	/* Sector under-size below which header stuffing rather than padding packets
+		or post-packet zero stuffing is used.  *Must* be less than 20 for VCD
+		multiplexing to work correctly!
+	 */
+	 
+#define MINIMUM_PADDING_PACKET_SIZE 10
+
+#define PACKET_HEADER_SIZE	6
+
+#define AUDIO_STREAMS		0xb8		/* Marker Audio Streams	*/
+#define VIDEO_STREAMS		0xb9		/* Marker Video Streams	*/
+#define AUDIO_STR_0		0xc0		/* Marker Audio Stream0	*/
+#define VIDEO_STR_0		0xe0		/* Marker Video Stream0	*/
+#define ZALPHA_STR_0		0xf8		/* Marker Z/Alpha Stream0 */
+#define PADDING_STR		0xbe		/* Marker Padding Stream*/
+#define PRIVATE_STR_1   0xbd            /* private stream 1 */
+#define PRIVATE_STR_2   0xbf            /* private stream 2 */
+#define AC3_SUB_STR_0   0x80            /* AC3 substream id 0 */
+#define DTS_SUB_STR_0   0x88            /* DTS substream id 0 */
+
+#define LPCM_SUB_STR_0  0xa0	        /* LPCM substream id 0 */
+
+#define ZERO_STUFFING_BYTE	0
+#define STUFFING_BYTE		0xff
+#define RESERVED_BYTE		0xff
+#define TIMESTAMPBITS_NO		0		/* Flag NO timestamps	*/
+#define TIMESTAMPBITS_PTS		2		/* Flag PTS timestamp	*/
+#define TIMESTAMPBITS_DTS		1		/* Flag PTS timestamp	*/
+#define TIMESTAMPBITS_PTS_DTS	(TIMESTAMPBITS_DTS|TIMESTAMPBITS_PTS)		/* Flag BOTH timestamps	*/
+
+#define MARKER_MPEG1_SCR		2		/* Marker SCR		*/
+#define MARKER_MPEG2_SCR        1		/* These don't need to be distinct! */
+#define MARKER_JUST_PTS			2		/* Marker only PTS	*/
+#define MARKER_PTS				3		/* Marker PTS		*/
+#define MARKER_DTS				1		/* Marker DTS		*/
+#define MARKER_NO_TIMESTAMPS	0x0f	/* Marker NO timestamps	*/
+
+
+#endif // __MPLEXCONSTS_H__

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/multiplexor.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/multiplexor.cpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/multiplexor.cpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,1502 @@
+/*
+ *  multiplexor.cpp:  Program/System stream Multiplex despatcher 
+ *
+ *  Copyright (C) 2003 Andrew Stevens <andrew.stevens at philips.com>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of version 2 of the GNU General Public License
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#define STREAM_LOGGING
+#include <config.h>
+#include <math.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <mjpeg_types.h>
+#include <mjpeg_logging.h>
+#include <format_codes.h>
+
+#include "interact.hpp"
+#include "videostrm.hpp"
+#include "stillsstream.hpp"
+#include "audiostrm.hpp"
+#ifdef ZALPHA
+#include "zalphastrm.hpp"
+#endif
+#include "multiplexor.hpp"
+
+
+/****************
+ *
+ * Constructor - sets up per-run stuff and initialised parameters
+ * that control syntax of generated stream from the job options set
+ * by the user.
+ *
+ ***************/
+
+Multiplexor::Multiplexor(MultiplexJob &job, OutputStream &output)
+{
+    underrun_ignore = 0;
+    underruns = 0;
+	start_of_new_pack = false;
+    InitSyntaxParameters(job);
+    InitInputStreams(job);
+
+    psstrm = new PS_Stream(mpeg, sector_size, output, max_segment_size );
+
+}
+
+
+/******************************************************************
+ *
+ * Initialisation of stream syntax paramters based on selected user
+ * options.  Depending of mux_format some selections may only act as
+ * defaults or may simply be ignored if they are inconsistent with the
+ * selected output format.
+ *
+ ******************************************************************/
+
+
+void Multiplexor::InitSyntaxParameters(MultiplexJob &job)
+{
+	seg_starts_with_video = false;
+	audio_buffer_size = 4 * 1024;
+    mux_format = job.mux_format;
+    vbr = job.VBR;
+    packets_per_pack = job.packets_per_pack;
+    data_rate = job.data_rate;
+    mpeg = job.mpeg;
+    always_sys_header_in_pack = job.always_system_headers;
+    sector_transport_size = job.sector_size;
+    sector_size = job.sector_size;
+	split_at_seq_end = !job.multifile_segment;
+    workarounds = job.workarounds;
+    max_segment_size = static_cast<off_t>(job.max_segment_size)
+                       * static_cast<off_t>(1024 * 1024);
+    max_PTS = static_cast<clockticks>(job.max_PTS) * CLOCKS;
+	video_delay = static_cast<clockticks>(job.video_offset);
+	audio_delay = static_cast<clockticks>(job.audio_offset);
+ 	switch( mux_format  )
+	{
+	case MPEG_FORMAT_VCD :
+		data_rate = 75*2352;  			 /* 75 raw CD sectors/sec */ 
+	case MPEG_FORMAT_VCD_NSR : /* VCD format, non-standard rate */
+		mjpeg_info( "Selecting VCD output profile");
+		video_buffers_iframe_only = false;
+		mpeg = 1;
+	 	packets_per_pack = 1;
+	  	sys_header_in_pack1 = 0;
+	  	always_sys_header_in_pack = 0;
+	  	sector_transport_size = 2352;	      /* Each 2352 bytes with 2324 bytes payload */
+	  	transport_prefix_sectors = 30;
+	  	sector_size = 2324;
+		buffers_in_video = 1;
+		always_buffers_in_video = 0;
+		buffers_in_audio = 1;   		// This is needed as otherwise we have
+		always_buffers_in_audio = 1;	//  to stuff the packer header which 
+                                        // must be 13 bytes for VCD audio
+		vcd_zero_stuffing = 20;         // The famous 20 zero bytes for VCD
+                                        // audio sectors.
+		dtspts_for_all_vau = false;
+		sector_align_iframeAUs = false;
+        timestamp_iframe_only = false;
+		seg_starts_with_video = true;
+        if( job.video_tracks == 0 )
+        {
+            mjpeg_info( "Audio-only VCD track - variable-bit-rate (VCD2.0)");
+            vbr = true;
+        }
+		break;
+		
+	case  MPEG_FORMAT_MPEG2 : 
+		mjpeg_info( "Selecting generic MPEG2 output profile");
+		mpeg = 2;
+	 	packets_per_pack = 1;
+	  	sys_header_in_pack1 = 1;
+	  	always_sys_header_in_pack = 0;
+	  	sector_transport_size = 2048;	      /* Each 2352 bytes with 2324 bytes payload */
+	  	transport_prefix_sectors = 0;
+	  	sector_size = 2048;
+		buffers_in_video = 1;
+		always_buffers_in_video = 0;
+		buffers_in_audio = 1;
+		always_buffers_in_audio = 1;
+		vcd_zero_stuffing = 0;
+		vbr = true;
+        	dtspts_for_all_vau = 0;
+        	timestamp_iframe_only = false;
+        	video_buffers_iframe_only = false;
+		break;
+
+	case MPEG_FORMAT_SVCD :
+		data_rate = 150*2324;
+
+	case MPEG_FORMAT_SVCD_NSR :		/* Non-standard data-rate */
+		mjpeg_info( "Selecting SVCD output profile");
+		mpeg = 2;
+	 	packets_per_pack = 1;
+	  	sys_header_in_pack1 = 0;
+	  	always_sys_header_in_pack = 0;
+	  	sector_transport_size = 2324;
+	  	transport_prefix_sectors = 0;
+	  	sector_size = 2324;
+		vbr = true;
+		buffers_in_video = 1;
+		always_buffers_in_video = 0;
+		buffers_in_audio = 1;
+		always_buffers_in_audio = 0;
+		vcd_zero_stuffing = 0;
+        dtspts_for_all_vau = 0;
+		sector_align_iframeAUs = true;
+		seg_starts_with_video = true;
+        timestamp_iframe_only = false;
+        video_buffers_iframe_only = false;
+		break;
+
+	case MPEG_FORMAT_VCD_STILL :
+		data_rate = 75*2352;  			 /* 75 raw CD sectors/sec */ 
+	  	vbr = false;
+		mpeg = 1;
+		split_at_seq_end = false;
+	 	packets_per_pack = 1;
+	  	sys_header_in_pack1 = 0;
+	  	always_sys_header_in_pack = 0;
+	  	sector_transport_size = 2352;	      /* Each 2352 bytes with 2324 bytes payload */
+	  	transport_prefix_sectors = 0;
+	  	sector_size = 2324;
+		buffers_in_video = 1;
+		always_buffers_in_video = 0;
+		buffers_in_audio = 1;
+		always_buffers_in_audio = 0;
+		vcd_zero_stuffing = 20;
+		dtspts_for_all_vau = 1;
+		sector_align_iframeAUs = true;
+        timestamp_iframe_only = false;
+        video_buffers_iframe_only = false;
+		break;
+
+	case MPEG_FORMAT_SVCD_STILL :
+		mjpeg_info( "Selecting SVCD output profile");
+		if( data_rate == 0 )
+			data_rate = 150*2324;
+		mpeg = 2;
+	 	packets_per_pack = 1;
+	  	sys_header_in_pack1 = 0;
+	  	always_sys_header_in_pack = 0;
+	  	sector_transport_size = 2324;
+	  	transport_prefix_sectors = 0;
+	  	sector_size = 2324;
+		vbr = true;
+		buffers_in_video = 1;
+		always_buffers_in_video = 0;
+		buffers_in_audio = 1;
+		always_buffers_in_audio = 0;
+		vcd_zero_stuffing = 0;
+        dtspts_for_all_vau = 0;
+		sector_align_iframeAUs = true;
+        timestamp_iframe_only = false;
+        video_buffers_iframe_only = false;
+		break;
+
+    case MPEG_FORMAT_DVD :
+		mjpeg_info( "Selecting generic DVD output profile (PROVISIONAL)");
+        if( data_rate == 0 )
+            data_rate = 1260000;
+		mpeg = 2;
+	 	packets_per_pack = 1;
+	  	sys_header_in_pack1 = false; // Handle by control packets
+	  	always_sys_header_in_pack = false;
+	  	sector_transport_size = 2048;
+	  	transport_prefix_sectors = 0;
+	  	sector_size = 2048;
+		buffers_in_video = true;
+		always_buffers_in_video = false;
+		buffers_in_audio = true;
+		always_buffers_in_audio = false;
+		vcd_zero_stuffing = 0;
+        dtspts_for_all_vau = 0;
+		sector_align_iframeAUs = true;
+        timestamp_iframe_only = true;
+        video_buffers_iframe_only = true;
+		vbr = true;
+        break;
+
+    case MPEG_FORMAT_DVD_NAV :
+		mjpeg_info( "Selecting dvdauthor DVD output profile");
+        if( data_rate == 0 )
+            data_rate = 1260000;
+		mpeg = 2;
+	 	packets_per_pack = 1;
+	  	sys_header_in_pack1 = false; // Handle by control packets
+	  	always_sys_header_in_pack = false;
+	  	sector_transport_size = 2048;
+	  	transport_prefix_sectors = 0;
+	  	sector_size = 2048;
+		buffers_in_video = true;
+		always_buffers_in_video = false;
+		buffers_in_audio = true;
+		always_buffers_in_audio = false;
+		vcd_zero_stuffing = 0;
+        dtspts_for_all_vau = 0;
+		sector_align_iframeAUs = true;
+        timestamp_iframe_only = true;
+        video_buffers_iframe_only = true;
+		vbr = true;
+        seg_starts_with_video = true; // Needs special NAV sector 1st!
+        break;
+			 
+	default : /* MPEG_FORMAT_MPEG1 - auto format MPEG1 */
+		mjpeg_info( "Selecting generic MPEG1 output profile");
+		//mpeg = 1;
+		sys_header_in_pack1 = 1;
+		transport_prefix_sectors = 0;
+		buffers_in_video = 1;
+		always_buffers_in_video = 1;
+		buffers_in_audio = 0;
+		always_buffers_in_audio = 1;
+		vcd_zero_stuffing = 0;
+        dtspts_for_all_vau = 0;
+		sector_align_iframeAUs = false;
+        timestamp_iframe_only = false;
+        video_buffers_iframe_only = false;
+		break;
+	}
+}
+
+/**************************************
+ *
+ * Initialise the elementary stream readers / output sector formatter
+ * objects for the various kinds of input stream.
+ *
+ *************************************/
+
+void Multiplexor::InitInputStreams(MultiplexJob &job)
+{
+    //
+    // S(VCD) Stills are sufficiently unusual to require their own
+    // special initialisation
+    //
+	if( MPEG_STILLS_FORMAT(job.mux_format) )
+        InitInputStreamsForStills( job );
+    else
+        InitInputStreamsForVideo( job );
+}
+
+void Multiplexor::InitInputStreamsForStills(MultiplexJob & job )
+{
+	std::vector<VideoParams *>::iterator vidparm = job.video_param.begin();
+    unsigned int frame_interval;
+    unsigned int i;
+    vector<JobStream *> video_strms;
+    job.GetInputStreams( video_strms, MPEG_VIDEO );
+    vector<JobStream *> mpa_strms;
+    job.GetInputStreams( mpa_strms, MPEG_AUDIO );
+
+    switch( job.mux_format )
+    {
+    case MPEG_FORMAT_VCD_STILL :
+        mjpeg_info( "Multiplexing VCD stills: %d stills streams.", video_strms.size() );
+        {
+            frame_interval = 30; // 30 Frame periods
+            if( mpa_strms.size() > 0 && video_strms.size() > 2  )
+                mjpeg_error_exit1("VCD stills: no more than two streams (one normal one hi-res) possible");
+
+
+            VCDStillsStream *str[2];
+            
+            for( i = 0; i< video_strms.size(); ++i )
+            {
+                FrameIntervals *ints = 
+                    new ConstantFrameIntervals( frame_interval );
+                str[i] = 
+                    new VCDStillsStream( *(video_strms[i]->bs),
+                                         new StillsParams( *vidparm, ints),
+                                         *this );
+                estreams.push_back( str[i] );
+                vstreams.push_back( str[i] );
+                str[i]->Init();
+                ++vidparm;
+            }
+            if( video_strms.size() == 2 )
+            {
+                str[0]->SetSibling(str[1]);
+                str[1]->SetSibling(str[0]);
+            }
+        }
+        break;
+    case MPEG_FORMAT_SVCD_STILL :
+        mjpeg_info( "Multiplexing SVCD stills: %d stills streams %d audio streams", video_strms.size(), mpa_strms.size() );
+        frame_interval = 30;
+        if( video_strms.size() > 1 )
+        {
+            mjpeg_error_exit1("SVCD stills streams may only contain a single video stream");
+        }
+        else if( video_strms.size() > 0 )
+        {
+            ConstantFrameIntervals *intervals;
+            StillsStream *str;
+            intervals = new ConstantFrameIntervals( frame_interval );
+            str = new StillsStream( *(video_strms[0]->bs),
+                                    new StillsParams( *vidparm, intervals ),
+                                    *this );
+            estreams.push_back( str );
+            vstreams.push_back( str );
+            str->Init();
+        }
+        for( i = 0 ; i < mpa_strms.size() ; ++i )
+        {
+            AudioStream *audioStrm = new MPAStream( *(mpa_strms[i]->bs), *this);
+            audioStrm->Init ( i);
+            estreams.push_back(audioStrm);
+            astreams.push_back(audioStrm);
+        }
+        break;
+    default:
+        mjpeg_error_exit1("Only VCD and SVCD stills format for the moment...");
+    }
+
+}
+
+void Multiplexor::InitInputStreamsForVideo(MultiplexJob & job )
+{
+    mjpeg_info( "Multiplexing video program stream!" );
+
+    unsigned int audio_track = 0;
+    unsigned int video_track = 0;
+	std::vector<VideoParams *>::iterator vidparm = job.video_param.begin();
+	std::vector<LpcmParams *>::iterator lpcmparm = job.lpcm_param.begin();
+
+
+    std::vector<JobStream *>::iterator i;
+    for( i = job.streams.begin() ; i < job.streams.end() ; ++i )
+    {
+        switch( (*i)->kind )
+        {
+            
+        case MPEG_VIDEO :
+        {
+            VideoStream *videoStrm;
+            //
+            // The first video stream is made the master stream...
+            //
+            if( video_track == 0  && job.mux_format ==  MPEG_FORMAT_DVD_NAV )
+                videoStrm = new DVDVideoStream( *(*i)->bs, 
+                                                *vidparm,
+                                                *this);
+            else
+                    videoStrm = new VideoStream( *(*i)->bs,
+                                                 *vidparm,
+                                                 *this);
+            videoStrm->Init( video_track );
+            ++video_track;
+            ++vidparm;
+            estreams.push_back( videoStrm );
+            vstreams.push_back( videoStrm );
+        }
+        break;
+        case MPEG_AUDIO :
+        {
+            AudioStream *audioStrm = new MPAStream( *(*i)->bs, *this);
+            audioStrm->Init ( audio_track );
+            estreams.push_back(audioStrm);
+            astreams.push_back(audioStrm);
+           ++audio_track;
+        }
+        break;
+        case AC3_AUDIO :
+        {
+            AudioStream *audioStrm =  new AC3Stream( *(*i)->bs, *this);
+            audioStrm->Init ( audio_track );
+            estreams.push_back(audioStrm);
+            astreams.push_back(audioStrm);
+            ++audio_track;
+        }
+        break;
+        case DTS_AUDIO :
+        {
+            AudioStream *audioStrm = new DTSStream( *(*i)->bs, *this);
+            audioStrm->Init ( audio_track );
+            estreams.push_back(audioStrm);
+            astreams.push_back(audioStrm);
+            ++audio_track;
+        }
+        break;
+        case LPCM_AUDIO :
+        {
+            AudioStream *audioStrm =  new LPCMStream( *(*i)->bs, *lpcmparm, *this);
+            audioStrm->Init ( audio_track );
+            estreams.push_back(audioStrm);
+            astreams.push_back(audioStrm);
+            ++lpcmparm;
+            ++audio_track;
+        }
+        break;
+#ifdef ZALPHA
+        // just copies the video parameters from the first video stream
+        case Z_ALPHA :
+        {
+            ZAlphaStream *zalphaStrm = new ZAlphaStream( *(*i)->bs, *(job.video_param.begin()), *this);
+            zalphaStrm->Init (0);
+            estreams.push_back(zalphaStrm);
+            vstreams.push_back(zalphaStrm);
+            //++vidparm;
+        }
+#endif		
+        }
+    }
+}
+
+
+/******************************************************************* 
+	Find the timecode corresponding to given position in the system stream
+   (assuming the SCR starts at 0 at the beginning of the stream 
+ at param bytepos byte position in the stream
+ at param ts returns the number of clockticks the bytepos is from the file start    
+****************************************************************** */
+
+void Multiplexor::ByteposTimecode(bitcount_t bytepos, clockticks &ts)
+{
+	ts = (bytepos*CLOCKS)/static_cast<bitcount_t>(dmux_rate);
+}
+
+
+/**********
+ *
+ * NextPosAndSCR - Update nominal (may be >= actual) byte count
+ * and SCR to next output sector.
+ *
+ ********/
+
+void Multiplexor::NextPosAndSCR()
+{
+	bytes_output += sector_transport_size;
+	ByteposTimecode( bytes_output, current_SCR );
+    if (start_of_new_pack)
+    {
+        psstrm->CreatePack (&pack_header, current_SCR, mux_rate);
+        pack_header_ptr = &pack_header;
+        if( include_sys_header )
+            sys_header_ptr = &sys_header;
+        else
+            sys_header_ptr = NULL;
+        
+    }
+    else
+        pack_header_ptr = NULL;
+}
+
+
+/**********
+ *
+ * SetPosAndSCR - Update nominal (may be >= actual) byte count
+ * and SCR to next output sector.
+ * @param bytepos byte position in the stream
+ ********/
+
+void Multiplexor::SetPosAndSCR( bitcount_t bytepos )
+{
+	bytes_output = bytepos;
+	ByteposTimecode( bytes_output, current_SCR );
+    if (start_of_new_pack)
+    {
+        psstrm->CreatePack (&pack_header, current_SCR, mux_rate);
+        pack_header_ptr = &pack_header;
+        if( include_sys_header )
+            sys_header_ptr = &sys_header;
+        else
+            sys_header_ptr = NULL;
+        
+    }
+    else
+        pack_header_ptr = NULL;
+}
+
+/* 
+   Stream syntax parameters.
+*/
+		
+	
+
+
+
+typedef enum { start_segment, mid_segment, 
+			   runout_segment }
+segment_state;
+
+
+/**
+ * Compute the number of run-in sectors needed to fill up the buffers to
+ * suit the type of stream being muxed.
+ *
+ * For stills we have to ensure an entire buffer is loaded as we only
+ * ever process one frame at a time.
+ * @returns the number of run-in sectors needed to fill up the buffers to suit the type of stream being muxed.
+ */
+
+unsigned int Multiplexor::RunInSectors()
+{
+	std::vector<ElementaryStream *>::iterator str;
+	unsigned int sectors_delay = 1;
+
+	for( str = vstreams.begin(); str < vstreams.end(); ++str )
+	{
+
+		if( MPEG_STILLS_FORMAT( mux_format ) )
+		{
+			sectors_delay += static_cast<unsigned int>(1.02*(*str)->BufferSize()) / sector_size+2;
+		}
+		else if( vbr )
+			sectors_delay += 3*(*str)->BufferSize() / ( 4 * sector_size );
+		else
+			sectors_delay += 5 *(*str)->BufferSize() / ( 6 * sector_size );
+	}
+    sectors_delay += astreams.size();
+	return sectors_delay;
+}
+
+/**********************************************************************
+ *
+ *  Initializes the output stream proper. Traverses the input files
+ *  and calculates their payloads.  Estimates the multiplex
+ *  rate. Estimates the necessary stream delay for the different
+ *  substreams.
+ *
+ *********************************************************************/
+
+
+void Multiplexor::Init()
+{
+	std::vector<ElementaryStream *>::iterator str;
+	clockticks delay;
+	unsigned int sectors_delay;
+
+	Pack_struc 			dummy_pack;
+	Sys_header_struc 	dummy_sys_header;	
+	Sys_header_struc *sys_hdr;
+	unsigned int nominal_rate_sum;
+	
+	mjpeg_info("SYSTEMS/PROGRAM stream:");
+	psstrm->Open();
+	
+    /* These are used to make (conservative) decisions
+	   about whether a packet should fit into the recieve buffers... 
+	   Audio packets always have PTS fields, video packets needn'.	
+	   TODO: Really this should be encapsulated in Elementary stream...?
+	*/ 
+	psstrm->CreatePack (&dummy_pack, 0, mux_rate);
+	if( always_sys_header_in_pack )
+	{
+        vector<MuxStream *> muxstreams;
+        AppendMuxStreamsOf( estreams, muxstreams );
+		psstrm->CreateSysHeader (&dummy_sys_header, mux_rate,  
+								 !vbr, 1,  true, true, muxstreams);
+		sys_hdr = &dummy_sys_header;
+	}
+	else
+		sys_hdr = NULL;
+	
+	nominal_rate_sum = 0;
+	for( str = estreams.begin(); str < estreams.end(); ++str )
+	{
+		switch( (*str)->Kind() )
+		{
+		case ElementaryStream::audio :
+			(*str)->SetMaxPacketData( 
+				psstrm->PacketPayload( **str, NULL, NULL, 
+									   false, true, false ) 
+				); 
+			(*str)->SetMinPacketData(
+				psstrm->PacketPayload( **str, sys_hdr, &dummy_pack, 
+									   always_buffers_in_audio, true, false )
+				);
+				
+			break;
+		case ElementaryStream::video :
+			(*str)->SetMaxPacketData( 
+				psstrm->PacketPayload( **str, NULL, NULL, 
+									   false, false, false ) 
+				); 
+			(*str)->SetMinPacketData( 
+				psstrm->PacketPayload( **str, sys_hdr, &dummy_pack, 
+									   always_buffers_in_video, true, true )
+				);
+			break;
+		default :
+			mjpeg_error_exit1("INTERNAL: Only audio and video payload calculations implemented!");
+			
+		}
+
+		if( (*str)->NominalBitRate() == 0 && data_rate == 0)
+			mjpeg_error_exit1( "Variable bit-rate stream present: output stream (max) data-rate *must* be specified!");
+		nominal_rate_sum += (*str)->NominalBitRate();
+	}
+		
+	/* Attempt to guess a sensible mux rate for the given video and *
+	 audio estreams. This is a rough and ready guess for MPEG-1 like
+	 formats. */
+	   
+	 
+	dmux_rate = static_cast<int>(1.0205 * nominal_rate_sum);
+	dmux_rate = (dmux_rate/50 + 25)*50/8;
+	
+	mjpeg_info ("rough-guess multiplexed stream data rate    : %07d", dmux_rate*8 );
+	if( data_rate != 0 )
+		mjpeg_info ("target data-rate specified               : %7d", data_rate*8 );
+
+	if( data_rate == 0 )
+	{
+		mjpeg_info( "Setting best-guess data rate.");
+	}
+	else if ( data_rate >= dmux_rate)
+	{
+		mjpeg_info( "Setting specified specified data rate: %7d", data_rate*8 );
+		dmux_rate = data_rate;
+	}
+	else if ( data_rate < dmux_rate )
+	{
+		mjpeg_warn( "Target data rate lower than computed requirement!");
+		mjpeg_warn( "N.b. a 20%% or so discrepancy in variable bit-rate");
+		mjpeg_warn( "streams is common and harmless provided no time-outs will occur"); 
+		dmux_rate = data_rate;
+	}
+
+	mux_rate = dmux_rate/50;
+
+
+	//
+	// Now that all mux parameters are set we can trigger parsing
+	// of actual input stream data and calculation of associated 
+	// PTS/DTS by causing the read of the first AU's...
+	//
+	for( str = estreams.begin(); str < estreams.end(); ++str )
+	{
+		(*str)->NextAU();
+	}
+
+    //
+    // Now that we have both output and input streams initialised and
+    // data-rates set we can make a decent job of setting the maximum
+    // STD buffer delay in video streams.
+    //
+   
+    for( str = vstreams.begin(); str < vstreams.end(); ++str )
+    {
+        static_cast<VideoStream*>(*str)->SetMaxStdBufferDelay( dmux_rate );
+    }				 
+
+	/* To avoid Buffer underflow, the DTS of the first video and audio AU's
+	   must be offset sufficiently	forward of the SCR to allow the buffer 
+	   time to fill before decoding starts. Calculate the necessary delays...
+	*/
+
+	sectors_delay = RunInSectors();
+
+	ByteposTimecode( 
+		static_cast<bitcount_t>(sectors_delay*sector_transport_size),
+		delay );
+    video_delay += delay;
+    audio_delay += delay;
+
+    /* 
+     * The PTS of the first frame may be different from its DTS.
+     * Thus to hit perfect A/V sync we need to delay audio by the difference
+     * PTS-DTS.
+     *
+     */
+    
+    if(  vstreams.size() != 0 )
+    {
+        audio_delay += vstreams[0]->BasePTS()-vstreams[0]->BaseDTS();
+    }
+
+	mjpeg_info( "Run-in Sectors = %d Video delay = %lld Audio delay = %lld",
+				sectors_delay,
+				 video_delay / 300,
+				 audio_delay / 300 );
+
+    if( max_PTS != 0 )
+        
+        mjpeg_info( "Multiplexed stream will be ended at %lld seconds playback time\n", max_PTS/CLOCKS );
+
+}
+
+/**
+   Prints the current status of the substreams. 
+   @param level the desired log level 
+ */
+void Multiplexor::MuxStatus(log_level_t level)
+{
+	std::vector<ElementaryStream *>::iterator str;
+	for( str = estreams.begin(); str < estreams.end(); ++str )
+	{
+		switch( (*str)->Kind()  )
+		{
+		case ElementaryStream::video :
+			mjpeg_log( level,
+					   "Video %02x: buf=%7d frame=%06d sector=%08d",
+					   (*str)->stream_id,
+					   (*str)->BufferSize()-(*str)->bufmodel.Space(),
+					   (*str)->DecodeOrder(),
+					   (*str)->nsec
+				);
+			break;
+		case ElementaryStream::audio :
+			mjpeg_log( level,
+					   "Audio %02x: buf=%7d frame=%06d sector=%08d",
+					   (*str)->stream_id,
+					   (*str)->BufferSize()-(*str)->bufmodel.Space(),
+					   (*str)->DecodeOrder(),
+					   (*str)->nsec
+				);
+			break;
+		default :
+			mjpeg_log( level,
+					   "Other %02x: buf=%7d sector=%08d",
+					   (*str)->stream_id,
+					   (*str)->bufmodel.Space(),
+					   (*str)->nsec
+				);
+			break;
+		}
+	}
+	if( !vbr )
+		mjpeg_log( level,
+				   "Padding : sector=%08d",
+				   pstrm.nsec
+			);
+	
+	
+}
+
+
+/**
+   Append input substreams to the output multiplex stream.
+ */
+void Multiplexor::AppendMuxStreamsOf( vector<ElementaryStream *> &elem, 
+                                       vector<MuxStream *> &mux )
+{
+	std::vector<ElementaryStream *>::iterator str;
+    for( str = elem.begin(); str < elem.end(); ++str )
+    {
+        mux.push_back( static_cast<MuxStream *>( *str ) );
+    }
+}
+
+/******************************************************************
+    Program start-up packets.  Generate any irregular packets						
+needed at the start of the stream...
+	Note: *must* leave a sensible in-stream system header in
+	sys_header.
+	TODO: get rid of this grotty sys_header global.
+******************************************************************/
+void Multiplexor::OutputPrefix( )
+{
+    vector<MuxStream *> vmux,amux,emux;
+    AppendMuxStreamsOf( vstreams, vmux );
+    AppendMuxStreamsOf( astreams, amux );
+    AppendMuxStreamsOf( estreams, emux );
+
+	/* Deal with transport padding */
+	SetPosAndSCR( bytes_output + 
+				  transport_prefix_sectors*sector_transport_size );
+	
+	/* VCD: Two padding packets with video and audio system headers */
+
+	switch (mux_format)
+	{
+	case MPEG_FORMAT_VCD :
+	case MPEG_FORMAT_VCD_NSR :
+
+		/* Annoyingly VCD generates seperate system headers for
+		   audio and video ... DOH... */
+		if( astreams.size() > 1 || vstreams.size() > 1 ||
+			astreams.size() + vstreams.size() != estreams.size() )
+		{
+				mjpeg_error_exit1("VCD man only have max. 1 audio and 1 video stream");
+		}
+
+        if( vstreams.size() > 0 )
+        {
+		/* First packet carries video-info-only sys_header */
+		psstrm->CreateSysHeader (&sys_header, mux_rate, 
+								 false, true, 
+								 true, true, vmux  );
+		sys_header_ptr = &sys_header;
+		pack_header_ptr = &pack_header;
+	  	OutputPadding( false);		
+        }
+
+        if( astreams.size() > 0 )
+        {
+
+            /* Second packet carries audio-info-only sys_header */
+            psstrm->CreateSysHeader (&sys_header, mux_rate,  
+                                     false, true, 
+                                     true, true, amux );
+            sys_header_ptr = &sys_header;
+            pack_header_ptr = &pack_header;
+            OutputPadding( true );
+        }
+        break;
+		
+	case MPEG_FORMAT_SVCD :
+	case MPEG_FORMAT_SVCD_NSR :
+		/* First packet carries sys_header */
+		psstrm->CreateSysHeader (&sys_header, mux_rate,  !vbr, true, 
+                                 true, true, emux );
+		sys_header_ptr = &sys_header;
+		pack_header_ptr = &pack_header;
+	  	OutputPadding(false);
+        break;
+
+	case MPEG_FORMAT_VCD_STILL :
+		/* First packet carries small-still sys_header */
+		/* TODO No support mixed-mode stills sequences... */
+		psstrm->CreateSysHeader (&sys_header, mux_rate, false, false,
+								 true, true, emux );
+		sys_header_ptr = &sys_header;
+		pack_header_ptr = &pack_header;
+		OutputPadding(  false);	
+        break;
+			
+	case MPEG_FORMAT_SVCD_STILL :
+		/* TODO: Video only at present */
+		/* First packet carries video-info-only sys_header */
+		psstrm->CreateSysHeader (&sys_header, mux_rate, 
+								 false, true, 
+								 true, true, vmux );
+		sys_header_ptr = &sys_header;
+		pack_header_ptr = &pack_header;
+	  	OutputPadding( false);		
+		break;
+
+    case MPEG_FORMAT_DVD_NAV :
+        /* A DVD System header is a weird thing.  We seem to need to
+           include buffer info about streams 0xb8, 0xb9, 0xbd, 0xbf even if
+           they're not physically present but the buffers for the actual
+           video streams aren't included.  
+        */
+    {
+        // MANY DVD streams appear not to include system headers
+        // and some tools have weak parsers that can't handle all
+        // the possible variations. Soooo probably best not to generate
+        // them
+        DummyMuxStream dvd_0xb9_strm_dummy( 0xb9, 1, 232*1024 );
+        DummyMuxStream dvd_0xb8_strm_dummy( 0xb8, 0, 4096 );
+        DummyMuxStream dvd_0xbf_strm_dummy( 0xbf, 1, 2048 );
+        vector<MuxStream *> dvdmux;
+		std::vector<MuxStream *>::iterator muxstr;
+        dvdmux.push_back( &dvd_0xb9_strm_dummy );
+        dvdmux.push_back( &dvd_0xb8_strm_dummy );
+        unsigned int max_priv1_buffer = 58*1024;
+        for( muxstr = amux.begin(); muxstr < amux.end(); ++muxstr )
+        {
+            // We mux *many* substreams on PRIVATE_STR_1
+            // we set the system header buffer size to the maximum
+            // of all those we find
+            if( (*muxstr)->stream_id == PRIVATE_STR_1 ) 
+            {
+                if( (*muxstr)->BufferSize() > max_priv1_buffer )
+                    max_priv1_buffer = (*muxstr)->BufferSize();
+            }
+            // Now the *sane* thing to do if MPEG audio is present would be
+            // record this in the system header.  However, dvdauthor lacks
+            // a header parser and barfs if the system headers aren't exactly
+            // 18 bytes.  Soooo we simply skip them for now...
+            // TOOD: Add back in when dvdauthor can parse system headers
+            //else
+            //    dvdmux.push_back( *muxstr );
+        }
+        
+        DummyMuxStream dvd_priv1_strm_dummy( PRIVATE_STR_1, 1, 
+                                             max_priv1_buffer );
+        dvdmux.push_back( &dvd_priv1_strm_dummy );
+            
+        dvdmux.push_back( &dvd_0xbf_strm_dummy );
+        psstrm->CreateSysHeader (&sys_header, mux_rate, !vbr, false, 
+                                 true, true, dvdmux );
+        sys_header_ptr = &sys_header;
+        pack_header_ptr = &pack_header;
+        /* It is then followed up by a pair of PRIVATE_STR_2 packets which
+            we keep empty 'cos we don't know what goes there...
+        */
+    }
+    break;
+
+    default :
+        /* Create the in-stream header in case it is needed */
+        psstrm->CreateSysHeader (&sys_header, mux_rate, !vbr, false, 
+                                 true, true, emux );
+
+
+	}
+
+
+
+}
+
+
+
+/******************************************************************
+    Program shutdown packets.  Generate any irregular packets
+    needed at the end of the stream...
+   
+******************************************************************/
+
+void Multiplexor::OutputSuffix()
+{
+	psstrm->CreatePack (&pack_header, current_SCR, mux_rate);
+	psstrm->CreateSector (&pack_header, NULL,
+						  0,
+						  pstrm, 
+						  false,
+						  true,
+						  0, 0,
+						  TIMESTAMPBITS_NO );
+}
+
+/******************************************************************
+
+	Main multiplex iteration.
+	Opens and closes all needed files and manages the correct
+	call od the respective Video- and Audio- packet routines.
+	The basic multiplexing is done here. Buffer capacity and 
+	Timestamp checking is also done here, decision is taken
+	wether we should genereate a Video-, Audio- or Padding-
+	packet.
+******************************************************************/
+
+
+	
+void Multiplexor::Multiplex()
+
+{
+	segment_state seg_state;
+	std::vector<bool> completed;
+	std::vector<bool>::iterator pcomp;
+	std::vector<ElementaryStream *>::iterator str;
+
+	unsigned int packets_left_in_pack = 0; /* Suppress warning */
+	bool padding_packet;
+	bool video_first = true;
+
+	Init( );
+
+	unsigned int i;
+    for(i = 0; i < estreams.size() ; ++i )
+		completed.push_back(false);
+
+    
+	/*  Let's try to read in unit after unit and to write it out into
+		the outputstream. The only difficulty herein lies into the
+		buffer management, and into the fact the the actual access
+		unit *has* to arrive in time, that means the whole unit
+		(better yet, packet data), has to arrive before arrival of
+		DTS. If both buffers are full we'll generate a padding packet
+	  
+		Of course, when we start we're starting a new segment with no
+		bytes output...
+	*/
+
+	ByteposTimecode( sector_transport_size, ticks_per_sector );
+	seg_state = start_segment;
+	running_out = false;
+	for(;;)
+	{
+		bool completion = true;
+
+		for( str = estreams.begin(); str < estreams.end() ; ++str )
+			completion &= (*str)->MuxCompleted();
+		if( completion )
+			break;
+
+		/* A little state-machine for handling the transition from one
+		   segment to the next 
+		*/
+		bool runout_incomplete;
+		VideoStream *master;
+		switch( seg_state )
+		{
+
+			/* Audio and slave video access units at end of segment.
+			   If there are any audio AU's whose PTS implies they
+			   should be played *before* the video AU starting the
+			   next segement is presented we mux them out.  Once
+			   they're gone we've finished this segment so we write
+			   the suffix switch file, and start muxing a new segment.
+			*/
+		case runout_segment :
+			runout_incomplete = false;
+			for( str = estreams.begin(); str < estreams.end(); ++str )
+			{
+				runout_incomplete |= !(*str)->RunOutComplete();
+			}
+
+			if( runout_incomplete )
+				break;
+
+			/* Otherwise we write the stream suffix and start a new
+			   stream file */
+			OutputSuffix();
+			psstrm->NextSegment();
+
+			running_out = false;
+			seg_state = start_segment;
+
+			/* Starting a new segment.
+			   We send the segment prefix, video and audio reciever
+			   buffers are assumed to start empty.  We reset the segment
+			   length count and hence the SCR.
+			   
+			*/
+
+		case start_segment :
+			mjpeg_info( "New sequence commences..." );
+			SetPosAndSCR(0);
+			MuxStatus( LOG_INFO );
+
+			for( str = estreams.begin(); str < estreams.end(); ++str )
+			{
+				(*str)->AllDemuxed();
+			}
+
+			packets_left_in_pack = packets_per_pack;
+            start_of_new_pack = true;
+			include_sys_header = sys_header_in_pack1;
+			buffers_in_video = always_buffers_in_video;
+			video_first = seg_starts_with_video & (vstreams.size() > 0);
+			OutputPrefix();
+
+			/* Set the offset applied to the raw PTS/DTS of AU's to
+               make the DTS of the first AU in the master (video) stream
+               precisely the video delay plus whatever time we wasted in
+               the sequence pre-amble.
+
+               The DTS of the remaining streams are set so that
+               (modulo the relevant delay offset) they maintain the
+               same relative timing to the master stream.
+               
+			*/
+
+            clockticks ZeroSCR;
+
+            if( vstreams.size() != 0 )
+                ZeroSCR = vstreams[0]->BaseDTS();
+            else
+                ZeroSCR = estreams[0]->BaseDTS();
+
+			for( str = vstreams.begin(); str < vstreams.end(); ++str )
+				(*str)->SetSyncOffset(video_delay + current_SCR - ZeroSCR );
+			for( str = astreams.begin(); str < astreams.end(); ++str )
+				(*str)->SetSyncOffset(audio_delay + current_SCR - ZeroSCR );
+			pstrm.nsec = 0;
+			for( str = estreams.begin(); str < estreams.end(); ++str )
+				(*str)->nsec = 0;
+			seg_state = mid_segment;
+			break;
+
+		case mid_segment :
+			/* Once we exceed our file size limit, we need to
+			   start a new file soon.  If we want a single stream we
+			   simply switch.
+				
+			   Otherwise we're in the last gop of the current segment
+			   (and need to start running streams out ready for a
+			   clean continuation in the next segment).
+			   TODO: runout_PTS really needs to be expressed in
+			   sync delay adjusted units...
+			*/
+			
+			master = 
+				vstreams.size() > 0 ? 
+				static_cast<VideoStream*>(vstreams[0]) : 0 ;
+			if( psstrm->SegmentLimReached() )
+			{
+				if( split_at_seq_end )
+                    mjpeg_warn( "File size exceeded before split-point in video stream" );
+                mjpeg_info( "Starting new output file...");
+                psstrm->NextSegment();
+			}
+			else if( master != 0 && master->SeqEndRunOut() )
+			{
+                const AUnit *nextIframe = master->NextIFrame();
+				if(  split_at_seq_end && nextIframe != 0)
+				{
+					runout_PTS = master->RequiredPTS(nextIframe);
+                    mjpeg_info( "Sequence end marker! Running out...");
+                    mjpeg_info("Run out PTS limit to AU %d %lld SCR=%lld", 
+                               nextIframe->dorder,
+                               runout_PTS/300, 
+                               current_SCR/300 );
+                    MuxStatus( LOG_INFO );
+					running_out = true;
+					seg_state = runout_segment;
+				}
+                else
+                {
+                    mjpeg_warn( "Sequence end without following I-frame!" );
+                }
+			}
+			break;
+			
+		}
+
+		padding_packet = false;
+		start_of_new_pack = (packets_left_in_pack == packets_per_pack); 
+        
+		for( str = estreams.begin(); str < estreams.end(); ++str )
+		{
+			(*str)->DemuxedTo(current_SCR);
+		}
+
+
+		
+		//
+		// Find the ready-to-mux stream with the most urgent DTS
+		//
+		ElementaryStream *despatch = 0;
+		clockticks earliest = 0;
+		for( str = estreams.begin(); str < estreams.end(); ++str )
+		{
+#ifdef STREAM_LOGGING
+            mjpeg_debug("%02x: SCR=%lld (%.3f) mux=%d %d reqDTS=%lld ", 
+                        (*str)->stream_id,
+                        current_SCR,
+                        static_cast<double>(current_SCR) /(90.0*300.0),
+                        (*str)->MuxPossible(current_SCR),
+                        (*str)->BufferSize()-(*str)->bufmodel.Space(),
+                        (*str)->RequiredDTS()/300
+                        
+				);
+#endif
+			if( (*str)->MuxPossible(current_SCR) && 
+				( !video_first || (*str)->Kind() == ElementaryStream::video )
+				 )
+			{
+				if( despatch == 0 || earliest > (*str)->RequiredDTS() )
+				{
+					despatch = *str;
+					earliest = (*str)->RequiredDTS();
+				}
+			}
+		}
+		
+		if( underrun_ignore > 0 )
+			--underrun_ignore;
+
+		if( despatch )
+		{
+			despatch->BufferAndOutputSector();
+			video_first = false;
+			if( current_SCR >=  earliest && underrun_ignore == 0)
+			{
+				mjpeg_warn( "Stream %02x: data will arrive too late sent(SCR)=%lld required(DTS)=%lld", 
+							despatch->stream_id, 
+							current_SCR/300, 
+							earliest/300 );
+				MuxStatus( LOG_WARN );
+				// Give the stream a chance to recover
+				underrun_ignore = 300;
+				++underruns;
+				if( underruns > 10  )
+				{
+					//mjpeg_error_exit1("Too many frame drops -exiting" );
+				}
+			}
+            if( despatch->nsec > 50 &&
+                despatch->Lookahead( ) != 0 && ! running_out)
+                despatch->UpdateBufferMinMax();
+			padding_packet = false;
+
+		}
+		else
+		{
+            //
+            // If we got here no stream could be muxed out.
+            // We therefore generate padding packets if necessary
+            // usually this is because reciever buffers are likely to be
+            // full.  
+            //
+            if( vbr )
+            {
+                //
+                // VBR: For efficiency we bump SCR up to five times or
+                // until it looks like buffer status will change
+                NextPosAndSCR();
+                clockticks next_change = static_cast<clockticks>(0);
+                for( str = estreams.begin(); str < estreams.end(); ++str )
+                {
+                    clockticks change_time = (*str)->bufmodel.NextChange();
+                    if( next_change == 0 || change_time < next_change )
+                    {
+                        next_change = change_time;
+                    }
+                }
+
+                unsigned int bumps = 5;
+                while( bumps > 0 
+                       && next_change > current_SCR + ticks_per_sector)
+                {
+                    NextPosAndSCR();
+                    --bumps;
+                }
+                            
+            }
+            else
+            {
+                // Just output a padding packet
+                OutputPadding (	false);
+            }
+			padding_packet = true;
+		}
+
+		/* Update the counter for pack packets.  VBR is a tricky 
+		   case as here padding packets are "virtual" */
+		
+		if( ! (vbr && padding_packet) )
+		{
+			--packets_left_in_pack;
+			if (packets_left_in_pack == 0) 
+				packets_left_in_pack = packets_per_pack;
+		}
+
+		MuxStatus( LOG_DEBUG );
+		/* Unless sys headers are always required we turn them off after the first
+		   packet has been generated */
+		include_sys_header = always_sys_header_in_pack;
+
+		pcomp = completed.begin();
+		str = estreams.begin();
+		while( str < estreams.end() )
+		{
+			if( !(*pcomp) && (*str)->MuxCompleted() )
+			{
+				mjpeg_info( "STREAM %02x completed @ frame %d.", (*str)->stream_id, (*str)->DecodeOrder() );
+				MuxStatus( LOG_DEBUG );
+				(*pcomp) = true;
+			}
+			++str;
+			++pcomp;
+		}
+	}
+	// Tidy up
+	
+	OutputSuffix( );
+	psstrm->Close();
+	mjpeg_info( "Multiplex completion at SCR=%lld.", current_SCR/300);
+	MuxStatus( LOG_INFO );
+	for( str = estreams.begin(); str < estreams.end(); ++str )
+	{
+		(*str)->Close();
+        if( (*str)->nsec <= 50 )
+            mjpeg_info( "BUFFERING stream too short for useful statistics");
+        else
+            mjpeg_info( "BUFFERING min %d Buf max %d",
+                        (*str)->BufferMin(),
+                        (*str)->BufferMax() 
+                );
+	}
+
+    if( underruns> 0 )
+	{
+		mjpeg_info( "MUX STATUS: Frame data under-runs detected!" ); // MEANX was exit
+	}
+	else
+	{
+		mjpeg_info( "MUX STATUS: no under-runs detected.");
+	}
+}
+
+/**
+   Calculate the packet payload of the output stream at a certain timestamp. 
+ at param strm the output stream
+ at param buffers the number of buffers
+ at param PTSstamp presentation time stamp
+ at param DTSstamp decoding time stamp
+ */
+unsigned int Multiplexor::PacketPayload( MuxStream &strm, bool buffers, 
+										  bool PTSstamp, bool DTSstamp )
+{
+	return psstrm->PacketPayload( strm, sys_header_ptr, pack_header_ptr, 
+								  buffers, 
+								  PTSstamp, DTSstamp)
+        - strm.StreamHeaderSize();
+}
+
+/***************************************************
+
+  WritePacket - Write out a normal packet carrying data from one of
+              the elementary stream being muxed.
+ at param max_packet_data_size the maximum packet data size allowed
+ at param strm output mux stream
+ at param buffers ?
+ at param PTSstamp presentation time stamp of the packet
+ at param DTSstamp decoding time stamp of the packet
+ at param timestamps ?
+ at param returns the written bytes/packets (?)
+***************************************************/
+
+unsigned int 
+Multiplexor::WritePacket( unsigned int     max_packet_data_size,
+                           MuxStream        &strm,
+                           bool 	 buffers,
+                           clockticks   	 PTS,
+                           clockticks   	 DTS,
+                           uint8_t 	 timestamps
+	)
+{
+    unsigned int written =
+        psstrm->CreateSector ( pack_header_ptr,
+                               sys_header_ptr,
+                               max_packet_data_size,
+                               strm,
+                               buffers,
+                               false,
+                               PTS,
+                               DTS,
+                               timestamps );
+    NextPosAndSCR();
+    return written;
+}
+
+/***************************************************
+ *
+ * WriteRawSector - Write out a packet carrying data for
+ *                    a control packet with irregular content.
+ at param rawsector data for the raw sector
+ at param length length of the raw sector
+ ***************************************************/
+
+void
+Multiplexor::WriteRawSector(  uint8_t *rawsector,
+                               unsigned int     length
+	)
+{
+    //
+    // Writing raw sectors when packs stretch over multiple sectors
+    // is a recipe for disaster!
+    //
+    assert( packets_per_pack == 1 );
+	psstrm->RawWrite( rawsector, length );
+	NextPosAndSCR();
+
+}
+
+
+
+/******************************************************************
+	OutputPadding
+
+	generates Pack/Sys Header/Packet information for a 
+	padding stream and saves the sector
+
+	We have to pass in a special flag to cope with appalling mess VCD
+	makes of audio packets (the last 20 bytes being dropped thing) 0 =
+	Fill the packet completetely.  This include "audio packets" that
+    include no actual audio, only a system header and padding.
+ at param vcd_audio_pad flag for VCD audio padding
+******************************************************************/
+
+
+void Multiplexor::OutputPadding (bool vcd_audio_pad)
+
+{
+    if( vcd_audio_pad )
+        psstrm->CreateSector ( pack_header_ptr, sys_header_ptr,
+                               0,
+                               vcdapstrm,
+                               false, false,
+                               0, 0,
+                               TIMESTAMPBITS_NO );
+    else
+        psstrm->CreateSector ( pack_header_ptr, sys_header_ptr,
+                               0,
+                               pstrm,
+                               false, false,
+                               0, 0,
+                               TIMESTAMPBITS_NO );
+    ++pstrm.nsec;
+	NextPosAndSCR();
+
+}
+
+ /******************************************************************
+ *	OutputGOPControlSector
+ *  DVD System headers are carried in peculiar sectors carrying 2
+ *  PrivateStream2 packets.   We're sticking 0's in the packets
+ *  as we have no idea what's supposed to be in there.
+ *
+ * Thanks to Brent Byeler who worked out this work-around.
+ *
+ ******************************************************************/
+
+void Multiplexor::OutputDVDPriv2 (	)
+{
+    uint8_t *packet_size_field;
+    uint8_t *index;
+    uint8_t *sector_buf = new uint8_t[sector_size];
+    unsigned int tozero;
+    assert( sector_size == 2048 );
+    PS_Stream::BufferSectorHeader( sector_buf,
+                                pack_header_ptr,
+                                &sys_header,
+                                index );
+    PS_Stream::BufferPacketHeader( index,
+                                   PRIVATE_STR_2,
+                                   2,      // MPEG 2
+                                   false,  // No buffers
+                                   0,
+                                   0,
+                                   0,      // No timestamps
+                                   0,
+                                   TIMESTAMPBITS_NO,
+                                   0, // Natural PES header length
+                                   packet_size_field,
+                                   index );
+    tozero = sector_buf+1024-index;
+    memset( index, 0, tozero);
+    index += tozero;
+    PS_Stream::BufferPacketSize( packet_size_field, index );    
+
+    PS_Stream::BufferPacketHeader( index,
+                                   PRIVATE_STR_2,
+                                   2,      // MPEG 2
+                                   false,  // No buffers
+                                   0,
+                                   0,
+                                   0,      // No timestamps
+                                   0,
+                                   TIMESTAMPBITS_NO,
+                                   0, // Natural PES header length
+                                   packet_size_field,
+                                   index );
+    tozero = sector_buf+2048-index;
+    memset( index, 0, tozero );
+    index += tozero;
+    PS_Stream::BufferPacketSize( packet_size_field, index );
+
+    WriteRawSector( sector_buf, sector_size );
+
+	delete [] sector_buf;
+}
+
+
+/* 
+ * Local variables:
+ *  c-file-style: "stroustrup"
+ *  tab-width: 4
+ *  indent-tabs-mode: nil
+ * End:
+ */

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/multiplexor.hpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/multiplexor.hpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/multiplexor.hpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,155 @@
+
+#ifndef __OUTPUTSTREAM_H__
+#define __OUTPUTSTREAM_H__
+
+#include <stdio.h>
+#include "mjpeg_types.h"
+#include "interact.hpp"
+#include "inputstrm.hpp"
+#include "padstrm.hpp"
+#include "systems.hpp"
+
+
+class Multiplexor
+{
+public:
+	Multiplexor(MultiplexJob &job, OutputStream &output);
+	void Multiplex ();
+
+
+	void ByteposTimecode( bitcount_t bytepos, clockticks &ts );
+	
+	inline Sys_header_struc *SystemHeader() { return &sys_header; }
+
+	unsigned int PacketPayload(	MuxStream &strm,
+								bool buffers, bool PTSstamp, bool DTSstamp );
+	unsigned int WritePacket( unsigned int     max_packet_data_size,
+							  MuxStream        &strm,
+							  bool 	 buffers,
+							  clockticks   	 PTS,
+							  clockticks   	 DTS,
+							  uint8_t 	 timestamps
+		);
+
+	bool AfterMaxPTS(clockticks &timestamp) 
+		{ return max_PTS != 0 && timestamp >= max_PTS; }
+
+
+	/* Special "unusual" sector types needed for particular formats 
+	 */
+	  
+	void OutputDVDPriv2 ();
+
+	/* Syntax control parameters, public becaus they're partly referenced
+	   by the input stream objects.
+	 */
+	
+	bool always_sys_header_in_pack;
+	bool dtspts_for_all_vau;
+	bool sys_header_in_pack1;
+	bool buffers_in_video;
+	bool always_buffers_in_video;	
+	bool buffers_in_audio;
+	bool always_buffers_in_audio;
+	bool sector_align_iframeAUs;
+	bool split_at_seq_end;
+	bool seg_starts_with_video;
+	bool timestamp_iframe_only;
+	bool video_buffers_iframe_only;
+	unsigned int audio_buffer_size;
+	unsigned int packets_per_pack;
+	unsigned int min_pes_header_len;
+	clockticks max_PTS;
+
+	int mpeg;
+	int data_rate;
+	int mux_format;
+	off_t max_segment_size;
+
+	Workarounds workarounds;
+
+/* In some situations the system/PES packets are embedded with
+   external transport data which has to be taken into account for SCR
+   calculations to be correct.  E.g. VCD streams. Where each 2324 byte
+   system packet is embedded in a 2352 byte CD sector and the actual
+   MPEG data is preceded by 30 empty sectors.
+*/
+
+	unsigned int	sector_transport_size;
+	unsigned int    transport_prefix_sectors; 
+	unsigned int 	sector_size;
+	unsigned int	vcd_zero_stuffing;	/* VCD audio sectors have 20 0 bytes :-( */
+
+	int 		dmux_rate;	/* Actual data mux-rate for calculations always a multiple of 50  */
+	int 		mux_rate;	/* MPEG mux rate (50 byte/sec units      */
+
+
+	/* Sequence run-out control */
+	bool running_out;
+	clockticks runout_PTS;
+	
+private:	
+	
+    /* Stream packet component buffers */
+	
+	Sys_header_struc 	sys_header;
+	Pack_struc          pack_header;
+	Pack_struc *pack_header_ptr;
+	Sys_header_struc *sys_header_ptr;
+	bool start_of_new_pack;
+	bool include_sys_header;
+
+	/* Under-run error messages */
+	unsigned int underruns;
+	unsigned int underrun_ignore;
+
+	/* Output data stream... */
+	PS_Stream *psstrm;
+	bitcount_t bytes_output;
+    clockticks ticks_per_sector;
+
+public:
+	clockticks current_SCR;
+private:
+	clockticks audio_delay;
+	clockticks video_delay;
+	bool vbr;
+	/* Source data streams */
+	/* Note: 1st video stream is regarded as the "master" stream for
+	   the purpose of splitting sequences etc...
+	*/
+	vector<ElementaryStream *> estreams; // Complete set
+	vector<ElementaryStream *> vstreams; // Video streams in estreams
+	vector<ElementaryStream *> astreams; // Audio streams in estreams
+	
+	PaddingStream pstrm;
+	VCDAPadStream vcdapstrm;
+	DVDPriv2Stream dvdpriv2strm;
+
+private:
+	void InitSyntaxParameters(MultiplexJob &job);
+	void InitInputStreams(MultiplexJob &job);
+	void InitInputStreamsForStills(MultiplexJob & job );
+	void InitInputStreamsForVideo(MultiplexJob & job );
+	unsigned int RunInSectors();
+	void Init();
+	
+
+	void NextPosAndSCR();
+	void SetPosAndSCR( bitcount_t bytepos );
+
+	void OutputPrefix( );
+
+	void OutputSuffix();
+	void OutputPadding ( bool vcd_audio_pad );
+	void MuxStatus( log_level_t level );
+
+	void WriteRawSector( uint8_t *rawpackets,
+						 unsigned int     length
+		);
+	void AppendMuxStreamsOf( vector<ElementaryStream *> &elem, 
+							 vector<MuxStream *> &mux );
+};
+
+
+#endif //__OUTPUTSTREAM_H__

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/outputstrm.hpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/outputstrm.hpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/outputstrm.hpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,43 @@
+
+/*
+ *  outputstream.h: Base Class for output
+ *
+ *
+ *  Copyright (C) 2001 Andrew Stevens <andrew.stevens at philips.com>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of version 2 of the GNU General Public License
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+
+#ifndef __OUTPUTSTRM_H__
+#define __OUTPUTSTRM_H__
+
+
+class OutputStream
+{
+public:
+    OutputStream() :
+        segment_num( 1 )
+        {}
+    virtual int  Open( ) = 0;
+    virtual void Close() = 0;
+    virtual off_t SegmentSize( ) = 0;
+    virtual void NextSegment() = 0;
+    virtual void Write(uint8_t *data, unsigned int len) = 0;
+protected:
+    int segment_num;
+};
+
+#endif /* __OUTPUTSTRM_H__ */

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/padstrm.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/padstrm.cpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/padstrm.cpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,61 @@
+
+/*
+ *  padstrm.cc:  Padding stream pseudo-input streams
+ *
+ *  Copyright (C) 2001 Andrew Stevens <andrew.stevens at philips.com>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of version 2 of the GNU General Public License
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+#include <string.h>
+
+#include "padstrm.hpp"
+
+
+
+//
+// Generator for padding packets in a padding stream...
+//
+
+
+unsigned int PaddingStream::ReadPacketPayload(uint8_t *dst, unsigned int to_read)
+{
+	memset( dst, STUFFING_BYTE, to_read );
+	return to_read;
+}
+
+unsigned int VCDAPadStream::ReadPacketPayload(uint8_t *dst, unsigned int to_read)
+{
+	memset( dst, STUFFING_BYTE, to_read );
+	return to_read;
+}
+
+unsigned int DVDPriv2Stream::ReadPacketPayload(uint8_t *dst, unsigned int to_read)
+{
+	memset( dst, 0, to_read );
+	return to_read;
+}
+
+/* 
+ * Local variables:
+ *  c-file-style: "stroustrup"
+ *  tab-width: 4
+ *  indent-tabs-mode: nil
+ * End:
+ */

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/padstrm.hpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/padstrm.hpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/padstrm.hpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,73 @@
+
+/*
+ *  padstrm.hpp:  Padding stream pseudo input-streamsin
+ *
+ *  Copyright (C) 2001 Andrew Stevens <andrew.stevens at philips.com>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of version 2 of the GNU General Public License
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#ifndef __PADSTRM_H__
+#define __PADSTRM_H__
+
+#include "inputstrm.hpp"
+
+
+class PaddingStream : public MuxStream
+{
+public:
+	PaddingStream()
+		{
+			MuxStream::Init( PADDING_STR, 0, 0,  0, false,false );
+		}
+
+	unsigned int ReadPacketPayload(uint8_t *dst, unsigned int to_read);
+};
+
+class VCDAPadStream : public MuxStream
+{
+public:
+	VCDAPadStream()
+		{
+			Init( PADDING_STR, 0, 0, 20, false, false );
+
+		}
+
+	unsigned int ReadPacketPayload(uint8_t *dst, unsigned int to_read);
+};
+
+class DVDPriv2Stream : public MuxStream
+{
+public:
+	DVDPriv2Stream()
+		{
+			Init( PRIVATE_STR_2, 0, 0, 0, false, false );
+
+		}
+
+	unsigned int ReadPacketPayload(uint8_t *dst, unsigned int to_read);
+};
+
+
+#endif // __PADSTRM_H__
+
+
+/* 
+ * Local variables:
+ *  c-file-style: "stroustrup"
+ *  tab-width: 4
+ *  indent-tabs-mode: nil
+ * End:
+ */

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/stillsstream.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/stillsstream.cpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/stillsstream.cpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,216 @@
+
+/*
+ *  stillsstreams.c: Class for elemenary still video streams
+ *                   Most functionality is inherited from VideoStream
+ *
+ *  Copyright (C) 2001 Andrew Stevens <andrew.stevens at philips.com>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of version 2 of the GNU General Public License
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <format_codes.h>
+
+#include "stillsstream.hpp"
+#include "interact.hpp"
+#include "multiplexor.hpp"
+
+void StillsStream::Init ( )
+{
+	int stream_id = -1;
+	int buffer_size = -1;
+
+	SetBufSize( 4*1024*1024 );
+	ScanFirstSeqHeader();
+
+	mjpeg_debug( "Stills: Video buffer suggestion ignored!" );
+	switch( muxinto.mux_format )
+	{
+	case  MPEG_FORMAT_VCD_STILL :
+		if( horizontal_size > 352 )
+		{
+			stream_id = VIDEO_STR_0+2 ;
+			buffer_size = vbv_buffer_size*2048;
+			mjpeg_info( "Stills Stream %02x: high-resolution VCD stills %d KB each", 
+						stream_id,
+						buffer_size );
+			if( buffer_size < 46*1024 )
+				mjpeg_error_exit1( "I Can't multiplex high-res stills smaller than normal res stills - sorry!");
+
+		}
+		else
+		{
+			stream_id = VIDEO_STR_0+1 ;
+			buffer_size = 46*1024;
+			mjpeg_info( "Stills Stream %02x: normal VCD stills", stream_id );
+		}
+		break;
+	case MPEG_FORMAT_SVCD_STILL :
+		if( horizontal_size > 480 )
+		{
+			stream_id = VIDEO_STR_0+1;
+			buffer_size = 230*1024;
+			mjpeg_info( "Stills Stream %02x: high-resolution SVCD stills.", 
+						stream_id );
+		}
+		else
+		{
+			stream_id = VIDEO_STR_0+1 ;
+			buffer_size = 230*1024;
+			mjpeg_info( "Stills Stream %02x: normal-resolution SVCD stills.", stream_id );
+		}
+		break;
+	default:
+		mjpeg_error_exit1( "Only SVCD and VCD Still currently supported");
+	}
+
+
+	MuxStream::Init( stream_id,
+					 1,  // Buffer scale
+					 buffer_size,
+					 0,  // Zero stuffing
+					 muxinto.buffers_in_video,
+					 muxinto.always_buffers_in_video);
+	
+	/* Skip to the end of the 1st AU (*2nd* Picture start!)
+	*/
+	AU_hdr = SEQUENCE_HEADER;
+	AU_pict_data = 0;
+	AU_start = 0;
+
+    OutputSeqhdrInfo();
+
+}
+
+
+
+
+/*
+ * Compute DTS / PTS for a VCD/SVCD Stills sequence
+ * TODO: Very crude. Simply assumes each still stays for the specified
+ * frame interval and that enough run-in delay is present for the first
+ * frame to be loaded.
+ *
+ */
+
+void StillsStream::NextDTSPTS( )
+{
+    StillsParams *sparms = static_cast<StillsParams*>(parms);
+
+	clockticks interval = static_cast<clockticks>
+		(sparms->Intervals()->NextFrameInterval() * CLOCKS / frame_rate);
+	clockticks time_for_xfer;
+	muxinto.ByteposTimecode( BufferSize(), time_for_xfer );
+		
+	access_unit.DTS = current_PTS + time_for_xfer;	// This frame decoded just after
+	                                    // Predecessor completed.
+	access_unit.PTS = current_PTS + time_for_xfer + interval;
+	current_PTS = access_unit.PTS;
+	current_DTS = access_unit.DTS;
+    fields_presented += 2;
+}
+
+/*
+ * VCD mixed stills segment items have the constraint that both stills
+ * streams must end together.  To do this each stream has to know
+ * about its "sibling".
+ *
+ */
+
+void VCDStillsStream::SetSibling( VCDStillsStream *_sibling )
+{
+	assert( _sibling != 0 );
+	sibling = _sibling;
+	if( sibling->stream_id == stream_id )
+	{
+		mjpeg_error_exit1("VCD mixed stills stream cannot contain two streams of the same type!");
+	}
+
+}
+
+/*
+ * Check if we've reached the last sector of the last AU.  Note: that
+ * we know no PTS/DTS time-stamps will be needed because no new AU
+ * will appear in the last sector.  WARNING: We assume a still won't
+ * fit into a single secotr.
+ *
+ */
+
+bool VCDStillsStream::LastSectorLastAU()
+{
+	return ( Lookahead() == 0 &&
+			 au_unsent <= muxinto.PacketPayload( *this,
+												 buffers_in_header, 
+												 false, false )
+		);
+}
+
+
+/*
+ * The requirement that VCD mixed stills segment items constituent streams
+ * end together means we can't mux the last sector of the last AU of
+ * such streams until its sibling has already completed muxing or is
+ * also ready to mux the last sector of its last AU.
+ *
+ * NOTE: Will not work right if sector_align_iframe_AUs not set as this
+ * will allow multiple AU's in  a sector.
+ *
+ */
+
+
+bool VCDStillsStream::MuxPossible(clockticks currentSCR)
+{
+    if( bufmodel.Size() < au_unsent )
+    {
+        mjpeg_error_exit1( "Illegal VCD still: larger than maximum permitted by its buffering parameters!");
+    }
+	if (RunOutComplete() ||	bufmodel.Space() < au_unsent)
+	{
+		return false;
+	}
+	
+	if( LastSectorLastAU() )
+	{
+		if( sibling != 0 )
+        {
+            if( !stream_mismatch_warned && sibling->NextAUType() != NOFRAME  )
+            {
+                mjpeg_warn( "One VCD stills stream runs significantly longer than the other!");
+                mjpeg_warn( "Simultaneous stream ending recommended by standard not possible" );
+                return true;
+            }
+            return sibling->MuxCompleted() || sibling->LastSectorLastAU();
+        }
+        else
+            return true;
+	}
+	else
+		return true;
+}
+
+
+
+
+/* 
+ * Local variables:
+ *  c-file-style: "stroustrup"
+ *  tab-width: 4
+ *  indent-tabs-mode: nil
+ * End:
+ */

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/stillsstream.hpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/stillsstream.hpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/stillsstream.hpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,81 @@
+
+/*
+ *  stillsstreams.c: Class for elemenary still video streams
+ *                   Most functionality is inherited from VideoStream
+ *
+ *  Copyright (C) 2001 Andrew Stevens <andrew.stevens at philips.com>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of version 2 of the GNU General Public License
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+
+#include "videostrm.hpp"
+
+//
+// Class for video stills sequence for (S)VCD non-mixed stills segment 
+// item
+//
+
+class StillsStream : public VideoStream
+{
+public:
+	StillsStream( IBitStream &ibs, 
+                  StillsParams *parms,
+                  Multiplexor &into) :
+		VideoStream( ibs, parms, into ),
+		current_PTS(0),
+		current_DTS(0)
+		{}
+	void Init( );
+private:
+	virtual void NextDTSPTS( );
+	clockticks current_PTS;
+	clockticks current_DTS;
+};
+
+//
+// Class for video stills sequence for VCD mixed stills Segment item.
+// 
+
+class VCDStillsStream : public StillsStream
+{
+public:
+	VCDStillsStream( IBitStream &ibs,
+                     StillsParams *vparms,
+                     Multiplexor &into ) :
+		StillsStream( ibs, vparms, into ),
+		sibling( 0 ),
+        stream_mismatch_warned( false )
+		{}
+	
+	void SetSibling( VCDStillsStream * );
+	virtual bool MuxPossible(clockticks currentSCR);
+private:
+	bool LastSectorLastAU();
+	VCDStillsStream *sibling;
+    bool stream_mismatch_warned;
+	
+};
+	
+
+
+
+/* 
+ * Local variables:
+ *  c-file-style: "stroustrup"
+ *  tab-width: 4
+ *  indent-tabs-mode: nil
+ * End:
+ */

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/streamType.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/streamType.h	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/streamType.h	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,22 @@
+#ifndef STREAM_TYPE_H
+#define STREAM_TYPE_H
+enum StreamKind
+  {
+      MPEG_AUDIO=1,
+      AC3_AUDIO,
+      LPCM_AUDIO,
+      DTS_AUDIO,
+      MPEG_VIDEO
+#ifdef ZALPHA
+        ,
+      Z_ALPHA
+#endif
+  };
+
+typedef struct mplexStreamDescriptor
+{
+  int channel;
+  int frequency;
+  StreamKind kind;
+}mplexStreamDescriptor;
+#endif

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/stream_params.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/stream_params.cpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/stream_params.cpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,125 @@
+/*
+ * params.hpp:  User specifiable parameters for various types of stream
+ *
+ *  The Check<stream>Params pseudo-constructors are constructed so that
+ *  they will only construct legal combinations of parameters.
+ *
+ *  Copyright (C) 2002 Andrew Stevens <andrew.stevens at philips.com>
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of version 2 of the GNU General Public License
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "stream_params.hpp"
+#include "format_codes.h"
+
+LpcmParams *LpcmParams::Default(unsigned int mux_format)
+{
+	return new LpcmParams(48000,2,16);
+}
+
+LpcmParams::LpcmParams( unsigned int samples,  
+						unsigned int chans, 
+						unsigned int bits ) :
+	samples_per_sec( samples ),
+	channels(chans),
+	bits_per_sample(bits)
+{
+}
+
+LpcmParams *LpcmParams::Checked(unsigned int samples,  
+								unsigned int chans, 
+								unsigned int bits )
+{
+    if( samples != 48000 && samples != 96000 )
+        return 0;
+    if( chans < 1 || chans > 7 )
+        return 0;
+    if( bits != 16 && bits != 20 && bits != 24 )
+        return 0;
+
+    return new LpcmParams(samples,chans,bits);
+}
+
+bool VideoParams::Force( unsigned int mux_format )
+{
+	unsigned int bufsiz;
+	//
+	// Handle formats that force the buffer size parameter to a
+	// standard-conforming value
+	//
+	switch( mux_format )
+	{
+	case MPEG_FORMAT_SVCD :
+		bufsiz = 230;
+		break;
+	case MPEG_FORMAT_VCD :
+		bufsiz = 46;
+		break;
+	case MPEG_FORMAT_DVD :
+	case MPEG_FORMAT_DVD_NAV :
+		bufsiz = 232;
+		break;
+	default :
+		return false;
+	}
+	decode_buffer_size = bufsiz;
+	return true;
+}
+
+VideoParams *VideoParams::Checked( unsigned int bufsiz)
+{
+	if( bufsiz < 20 && bufsiz >= 4096 )	// In KB here...
+		return 0;
+	return new VideoParams(bufsiz);
+}
+
+VideoParams::VideoParams( unsigned int bufsiz ) :
+	decode_buffer_size(bufsiz)
+{
+}
+
+VideoParams *VideoParams::Default(unsigned int mux_format)
+{
+	unsigned int bufsiz;
+	switch( mux_format )
+	{
+	case MPEG_FORMAT_MPEG2 :
+	case MPEG_FORMAT_SVCD :
+	case MPEG_FORMAT_SVCD_NSR :	
+	case MPEG_FORMAT_SVCD_STILL :
+		bufsiz = 230;
+		break;
+	case MPEG_FORMAT_DVD :		
+	case MPEG_FORMAT_DVD_NAV :		
+		bufsiz = 232;
+		break;
+	default :
+		bufsiz = 46;
+	}
+	return new VideoParams(bufsiz);
+}
+
+
+/* 
+ * Local variables:
+ *  c-file-style: "stroustrup"
+ *  tab-width: 4
+ *  indent-tabs-mode: nil
+ * End:
+ */

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/stream_params.hpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/stream_params.hpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/stream_params.hpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,109 @@
+/*
+ * streamparams.hpp:  User specifiable parameter classes for various types of stream
+ *
+ * The class constructors etc are defined so that it is impossible to build
+ * objects with illegal combinations of constructors.
+ *
+ *  Copyright (C) 2002 Andrew Stevens <andrew.stevens at philips.com>
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of version 2 of the GNU General Public License
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#ifndef __STREAM_PARAMS_HH__
+#define __STREAM_PARAMS_HH__
+
+
+class LpcmParams
+{
+public:
+  static LpcmParams *Checked(  unsigned int samples,  
+                               unsigned int chans, 
+                               unsigned int bits );
+  static LpcmParams *Default(  unsigned int opt_mux_format );
+  inline unsigned int SamplesPerSec() { return samples_per_sec; }
+  inline unsigned int Channels() { return channels; }
+  inline unsigned int BitsPerSample() { return bits_per_sample; }
+  
+private:
+  LpcmParams(unsigned int samples,  
+             unsigned int chans, 
+             unsigned int bits);
+  unsigned int samples_per_sec;
+  unsigned int channels;
+  unsigned int bits_per_sample;
+};
+
+
+class VideoParams
+{
+public:
+  static VideoParams *Checked(unsigned int bufsiz);
+  static VideoParams *Default(unsigned int mux_format);
+  bool Force(unsigned int mux_format);
+  inline unsigned int DecodeBufferSize() { return decode_buffer_size; }
+private:
+  VideoParams(unsigned int bufsiz);
+  unsigned int decode_buffer_size;
+};
+
+
+
+//
+// Class of sequence of frame intervals.
+//
+
+
+
+class FrameIntervals
+{
+public:
+	virtual int NextFrameInterval() = 0;
+};
+
+
+class ConstantFrameIntervals : public FrameIntervals
+{
+public:
+	ConstantFrameIntervals( int _frame_interval ) :
+		frame_interval( _frame_interval )
+		{
+		}
+	int NextFrameInterval() { return frame_interval; };
+private:
+	int frame_interval;
+};
+
+
+class StillsParams : public VideoParams
+{
+public:
+  StillsParams( VideoParams *parms, FrameIntervals *ints ) :
+    VideoParams(*parms),
+    intervals(ints)
+  {}
+  inline FrameIntervals *Intervals() { return intervals; }
+private:
+  FrameIntervals *intervals;
+};
+
+
+#endif
+
+/* 
+ * Local variables:
+ *  c-file-style: "gnu"
+ *  tab-width: 8
+ *  indent-tabs-mode: nil
+ * End:
+ */

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/systems.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/systems.cpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/systems.cpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,739 @@
+
+/*
+ *  systems.cpp: Program/System stream packet generator 
+ *
+ *
+ *  Copyright (C) 2001 Andrew Stevens <andrew.stevens at philips.com>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of version 2 of the GNU General Public License
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+
+#include <config.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <sys/param.h>
+#include "systems.hpp"
+#include "mplexconsts.hpp"
+
+PS_Stream:: PS_Stream( unsigned _mpeg,
+                       unsigned int _sector_size,
+                       OutputStream &_output_strm, 
+                       off_t max_seg_size )
+    : mpeg_version( _mpeg),
+      sector_size( _sector_size ),
+      output_strm(_output_strm ),
+      max_segment_size( max_seg_size )
+{
+    sector_buf = new uint8_t[sector_size];
+	max_segment_size = max_seg_size;
+}
+
+PS_Stream::~PS_Stream()
+{
+    delete [] sector_buf;
+}
+
+
+bool
+PS_Stream::SegmentLimReached()
+{
+	off_t written = output_strm.SegmentSize();
+	return max_segment_size != 0 && written > max_segment_size;
+}
+
+
+
+
+/**************************************************************
+
+ 	 Packet payload compute how much payload a sector-sized packet with the 
+	 specified headers can carry...
+     TODO: Should really be called "Sector Payload"
+**************************************************************/
+	
+		
+unsigned int 
+PS_Stream::PacketPayload( MuxStream &mux_strm,
+						  Sys_header_struc *sys_header, 
+						  Pack_struc *pack_header, 
+						  int buffers, int PTSstamp, int DTSstamp )
+{
+  int payload = sector_size - (PACKET_HEADER_SIZE + mux_strm.zero_stuffing);
+	if( sys_header != NULL )
+		payload -= sys_header->length;
+	if( mpeg_version == 2 )
+	{
+	  if( buffers )
+	    payload -= MPEG2_BUFFERINFO_LENGTH;
+
+	  payload -= MPEG2_AFTER_PACKET_LENGTH_MIN;
+	  if( pack_header != NULL )
+	    payload -= pack_header->length;
+	  if( DTSstamp )
+	    payload -= DTS_PTS_TIMESTAMP_LENGTH;
+	  if ( PTSstamp )
+	    payload -= DTS_PTS_TIMESTAMP_LENGTH;
+
+	}
+	else
+	{
+		if( buffers )
+			payload -= MPEG1_BUFFERINFO_LENGTH;
+
+		payload -= MPEG1_AFTER_PACKET_LENGTH_MIN;
+		if( pack_header != NULL )
+			payload -= pack_header->length;
+		if( DTSstamp )
+			payload -= DTS_PTS_TIMESTAMP_LENGTH;
+		if (PTSstamp )
+			payload -= DTS_PTS_TIMESTAMP_LENGTH;
+		if( DTSstamp || PTSstamp )
+			payload += 1;  /* No need for nostamp marker ... */
+
+	}
+	
+	return payload;
+}
+
+
+
+/*************************************************************************
+    Kopiert einen TimeCode in einen Bytebuffer. Dabei wird er nach
+    MPEG-Verfahren in bits aufgesplittet.
+
+    Makes a Copy of a TimeCode in a Buffer, splitting it into bitfields
+    for MPEG-1/2 DTS/PTS fields and MPEG-1 pack scr fields
+*************************************************************************/
+
+void 
+PS_Stream::BufferDtsPtsMpeg1ScrTimecode (clockticks    timecode,
+										 uint8_t  marker,
+										 uint8_t *&buffer)
+
+{
+	clockticks thetime_base;
+    uint8_t temp;
+    unsigned int msb, lsb;
+     
+ 	/* MPEG-1 uses a 90KHz clock, extended to 300*90KHz = 27Mhz in MPEG-2 */
+	/* For these fields we only encode to MPEG-1 90Khz resolution... */
+	
+	thetime_base = timecode /300;
+	msb = (thetime_base >> 32) & 1;
+	lsb = (thetime_base & static_cast<uint64_t>(0xFFFFFFFF));
+		
+    temp = (marker << 4) | (msb <<3) |
+		((lsb >> 29) & 0x6) | 1;
+    *(buffer++)=temp;
+    temp = (lsb & 0x3fc00000) >> 22;
+    *(buffer++)=temp;
+    temp = ((lsb & 0x003f8000) >> 14) | 1;
+    *(buffer++)=temp;
+    temp = (lsb & 0x7f80) >> 7;
+    *(buffer++)=temp;
+    temp = ((lsb & 0x007f) << 1) | 1;
+    *(buffer++)=temp;
+
+}
+
+/*************************************************************************
+    Makes a Copy of a TimeCode in a Buffer, splitting it into bitfields
+    for MPEG-2 pack scr fields  which use the full 27Mhz resolution
+    
+    Did they *really* need to put a 27Mhz
+    clock source into the system stream.  Does anyone really need it
+    for their decoders?  Get real... I guess they thought it might allow
+    someone somewhere to save on a proper clock circuit.
+*************************************************************************/
+
+
+void 
+PS_Stream::BufferMpeg2ScrTimecode( clockticks    timecode,
+								   uint8_t *&buffer
+	)
+{
+ 	clockticks thetime_base;
+	unsigned int thetime_ext;
+    uint8_t temp;
+    unsigned int msb, lsb;
+     
+	thetime_base = timecode /300;
+	thetime_ext =  timecode % 300;
+	msb = (thetime_base>> 32) & 1;
+	lsb = thetime_base & static_cast<uint64_t>(0xFFFFFFFF);
+
+
+      temp = (MARKER_MPEG2_SCR << 6) | (msb << 5) |
+		  ((lsb >> 27) & 0x18) | 0x4 | ((lsb >> 28) & 0x3);
+      *(buffer++)=temp;
+      temp = (lsb & 0x0ff00000) >> 20;
+      *(buffer++)=temp;
+      temp = ((lsb & 0x000f8000) >> 12) | 0x4 |
+             ((lsb & 0x00006000) >> 13);
+      *(buffer++)=temp;
+      temp = (lsb & 0x00001fe0) >> 5;
+      *(buffer++)=temp;
+      temp = ((lsb & 0x0000001f) << 3) | 0x4 |
+             ((thetime_ext & 0x00000180) >> 7);
+      *(buffer++)=temp;
+      temp = ((thetime_ext & 0x0000007F) << 1) | 1;
+      *(buffer++)=temp;
+}
+
+/*************************************************************************
+
+BufferPaddingPacket - Insert a padding packet of the desired length
+                      into the specified Program/System stream buffer
+
+**************************************************************************/
+
+void
+PS_Stream::BufferPaddingPacket( int padding,  uint8_t *&buffer  )
+{
+    uint8_t *index = buffer;
+    int i;
+
+    assert( (mpeg_version == 2 && padding >= 6) ||
+            (mpeg_version == 1 && padding >= 7) );
+
+    *(index++) = static_cast<uint8_t>(PACKET_START)>>16;
+    *(index++) = static_cast<uint8_t>(PACKET_START & 0x00ffff)>>8;
+    *(index++) = static_cast<uint8_t>(PACKET_START & 0x0000ff);
+    *(index++) = PADDING_STR;
+    *(index++) = static_cast<uint8_t>((padding - 6) >> 8);
+    *(index++) = static_cast<uint8_t>((padding - 6) & 0xff);
+    if (mpeg_version == 2)
+        {
+            for (i = 0; i < padding - 6; i++)
+                *(index++) = static_cast<uint8_t>(STUFFING_BYTE);
+        }
+        else
+        {
+            *(index++) = 0x0F;
+            for (i = 0; i < padding - 7; i++)
+                *(index++) = static_cast<uint8_t>(STUFFING_BYTE);
+        }
+
+    buffer = index;
+}
+
+
+void 
+PS_Stream::BufferSectorHeader( uint8_t *index,
+                               Pack_struc	 	 *pack,
+                               Sys_header_struc *sys_header,
+                               uint8_t     *&header_end
+    )
+{
+    /* Pack header if present */
+
+    if (pack != NULL)
+    {
+		memcpy ( index, pack->buf, pack->length);
+		index += pack->length;
+    }
+
+    /* System header if present */
+
+    if (sys_header != NULL)
+    {
+		memcpy (index, sys_header->buf, sys_header->length);
+		index += sys_header->length;
+    }
+    header_end = index;
+}
+
+/******************************************
+ *
+ * BufferPacketHeader
+ * Construct an MPEG-1/2 header for a packet in the specified
+ * buffer (which *MUST* be long enough) and set points to the start of
+ * the payload and packet length fields.
+ *
+ ******************************************/
+
+
+void PS_Stream::BufferPacketHeader( uint8_t *buf,
+                                    uint8_t type,
+                                    unsigned int mpeg_version,
+                                    bool buffers,
+                                    unsigned int buffer_size,
+                                    uint8_t buffer_scale,
+                                    clockticks   	 PTS,
+                                    clockticks   	 DTS,
+                                    uint8_t 	 timestamps,
+                                    unsigned    int min_pes_hdr_len,
+                                    uint8_t     *&size_field,
+                                    uint8_t     *&header_end
+    )
+{
+
+    uint8_t *index = buf;
+	uint8_t *pes_header_len_field = 0;
+
+
+    /* konstante Packet Headerwerte eintragen */
+    /* write constant packet header data */
+
+    *(index++) = static_cast<uint8_t>(PACKET_START)>>16;
+    *(index++) = static_cast<uint8_t>(PACKET_START & 0x00ffff)>>8;
+    *(index++) = static_cast<uint8_t>(PACKET_START & 0x0000ff);
+    *(index++) = type;	
+
+
+    /* we remember this offset so we can fill in the packet size field once
+	   we know the actual size... */
+    size_field = index;   
+    index += 2;
+
+	if( mpeg_version == 1 )
+	{
+		/* MPEG-1: buffer information */
+		if (buffers)
+		{
+			*(index++) = static_cast<uint8_t> (0x40 |
+                                               (buffer_scale << 5) | (buffer_size >> 8));
+			*(index++) = static_cast<uint8_t> (buffer_size & 0xff);
+		}
+
+		/* MPEG-1: PTS, PTS & DTS, oder gar nichts? */
+		/* should we write PTS, PTS & DTS or nothing at all ? */
+
+		switch (timestamps)
+		{
+		case TIMESTAMPBITS_NO:
+			*(index++) = MARKER_NO_TIMESTAMPS;
+			break;
+		case TIMESTAMPBITS_PTS:
+			BufferDtsPtsMpeg1ScrTimecode (PTS, MARKER_JUST_PTS, index);
+			break;
+		case TIMESTAMPBITS_PTS_DTS:
+			BufferDtsPtsMpeg1ScrTimecode (PTS, MARKER_PTS, index);
+			BufferDtsPtsMpeg1ScrTimecode (DTS, MARKER_DTS, index);
+			break;
+		}
+	}
+	else if( type != PADDING_STR )
+	{
+	  	/* MPEG-2 packet syntax header flags. */
+        /* These *DO NOT* appear in padding packets 			*/
+        /* TODO: They don't appear in several others either!	*/
+		/* First byte:
+		   <1,0><PES_scrambling_control:2=0><PES_priority><data_alignment_ind.=0>
+		   <copyright=0><original=1> */
+		*(index++) = 0x81;
+		/* Second byte: PTS PTS_DTS or neither?  Buffer info?
+		   <PTS_DTS:2><ESCR=0><ES_rate=0>
+		   <DSM_trick_mode:2=0><PES_CRC=0><PES_extension=(!!buffers)>
+		*/
+		*(index++) = (timestamps << 6) | (!!buffers);
+		/* Third byte:
+		   <PES_header_length:8> */
+		pes_header_len_field = index;  /* To fill in later! */
+		index++;
+		/* MPEG-2: the timecodes if required */
+		switch (timestamps)
+		{
+		case TIMESTAMPBITS_PTS:
+			BufferDtsPtsMpeg1ScrTimecode(PTS, MARKER_JUST_PTS, index);
+			break;
+
+		case TIMESTAMPBITS_PTS_DTS:
+			BufferDtsPtsMpeg1ScrTimecode(PTS, MARKER_PTS, index);
+			BufferDtsPtsMpeg1ScrTimecode(DTS, MARKER_DTS, index);
+			break;
+		}
+
+		/* MPEG-2 The buffer information in a PES_extension */
+		if( buffers )
+		{
+			/* MPEG-2 PES extension header
+			   <PES_private_data:1=0><pack_header_field=0>
+			   <program_packet_sequence_counter=0>
+			   <P-STD_buffer=1><reserved:3=1><{PES_extension_flag_2=0> */
+			*(index++) = static_cast<uint8_t>(0x1e);
+			*(index++) = static_cast<uint8_t> (0x40 | (buffer_scale << 5) | 
+                                               (buffer_size >> 8));
+			*(index++) = static_cast<uint8_t> (buffer_size & 0xff);
+		}
+        /* If required pad the PES header: needed for some workarounds */
+        while( index-(pes_header_len_field+1) < min_pes_hdr_len )
+            *(index++)=static_cast<uint8_t>(STUFFING_BYTE);
+	}
+
+    if( mpeg_version == 2 && type != PADDING_STR )
+    {
+        *pes_header_len_field = 
+            static_cast<uint8_t>(index-(pes_header_len_field+1));	
+    }
+    header_end = index;
+}
+
+/*************************************************************************
+ *	CreateSector
+ *
+ *  Creates a complete sector to carry a padding packet or a packet
+ *  from one of the elementary streams.  Pack and System headers are
+ *  prepended if required.
+ *
+ *  We allow for situations where want to
+ *  deliberately reduce the payload carried by stuffing.
+ *  This allows us to deal with tricky situations where the
+ *	header overhead of adding in additional information
+ *	would exceed the remaining payload capacity.
+ *
+ *    Header stuffing and/or a padding packet is appended if the sector is
+ *    unfilled.   Zero stuffing after the end of a packet is also supported
+ *    to allow thos wretched audio packets from VCD's to be handled.
+ *
+ *  TODO: Should really be called "WriteSector" 
+ * 
+ * TODO: We need to add a generic mechanism for sub-headers of
+ * private streams to be generated...
+ *
+ *************************************************************************/
+
+
+unsigned int
+PS_Stream::CreateSector (Pack_struc	 	 *pack,
+						 Sys_header_struc *sys_header,
+						 unsigned int     max_packet_data_size,
+						 MuxStream        &mux_strm,
+						 bool 	 buffers,
+						 bool    end_marker,
+						 clockticks   	 PTS,
+						 clockticks   	 DTS,
+						 uint8_t 	 timestamps
+	)
+
+{
+    int i;
+    uint8_t *index;
+    uint8_t *size_offset;
+	unsigned int target_packet_data_size;
+	unsigned int actual_packet_data_size;
+	int packet_data_to_read;
+	int bytes_short;
+	uint8_t 	 type = mux_strm.stream_id;
+	uint8_t 	 buffer_scale = mux_strm.BufferScale();
+	unsigned int buffer_size = mux_strm.BufferSizeCode();
+	unsigned int sector_pack_area;
+	index = sector_buf;
+
+	sector_pack_area = sector_size - mux_strm.zero_stuffing;
+	if( end_marker )
+		sector_pack_area -= 4;
+
+    BufferSectorHeader( index, pack, sys_header, index );
+    BufferPacketHeader( index, type, mpeg_version,
+                        buffers, buffer_size, buffer_scale,
+                        PTS, DTS, timestamps,
+                        mux_strm.min_pes_header_len,
+                        size_offset,
+                        index );
+
+    
+    /* MPEG-1, MPEG-2: data available to be filled is packet_size less
+     * header and MPEG-1 trailer... */
+
+    target_packet_data_size = sector_pack_area - (index - sector_buf );
+	
+		
+    /* DEBUG: A handy consistency check when we're messing around */
+#ifdef MUX_DEBUG		
+    if( type != PADDING_STR &&
+
+        (end_marker ? target_packet_data_size+4 : target_packet_data_size) 
+        != 
+        PacketPayload( mux_strm, sys_header, pack, buffers,
+                       timestamps & TIMESTAMPBITS_PTS, timestamps & TIMESTAMPBITS_DTS) )
+	
+    { 
+		printf("\nPacket size calculation error %d S%d P%d B%d %d %d!\n ",
+               timestamps,
+			   sys_header!=0, pack!=0, buffers,
+			   target_packet_data_size , 
+			   PacketPayload( mux_strm, sys_header, pack, buffers,
+							  timestamps & TIMESTAMPBITS_PTS, 
+                              timestamps & TIMESTAMPBITS_DTS));
+        exit(1);
+    }
+#endif	
+              
+    /* If a maximum payload data size is specified (!=0) and is
+       smaller than the space available thats all we read (the
+       remaining space is stuffed) */
+    if( max_packet_data_size != 0 && 
+        max_packet_data_size < target_packet_data_size )
+    {
+        packet_data_to_read = max_packet_data_size;
+    }
+    else
+        packet_data_to_read = target_packet_data_size;
+              
+
+    /* MPEG-1, MPEG-2: read in available packet data ... */
+
+    actual_packet_data_size = mux_strm.ReadPacketPayload(index,packet_data_to_read);
+
+    bytes_short = target_packet_data_size - actual_packet_data_size;
+#ifdef MUX_DEBUG
+    if( type == PRIVATE_STR_1 )
+    {
+        mjpeg_info( "Substream %02x short %d", index[0], bytes_short );
+
+    }
+#endif
+	
+    /* Handle the situations where we don't have enough data to fill
+       the packet size fully ...  small shortfalls are dealt with here
+       by stuffing, big ones dealt with later by appending padding packets.
+    */
+
+
+    if(  bytes_short < MINIMUM_PADDING_PACKET_SIZE && bytes_short > 0 )
+    {
+        if (mpeg_version == 1 )
+        {
+            /* MPEG-1 stuffing happens *before* header data fields. */
+            uint8_t *fixed_packet_header_end = size_offset + 2;
+            memmove( fixed_packet_header_end+bytes_short, 
+                     fixed_packet_header_end, 
+                     actual_packet_data_size+(index-fixed_packet_header_end)
+                );
+            for( i=0; i< bytes_short; ++i)
+                fixed_packet_header_end[i] = static_cast<uint8_t>(STUFFING_BYTE);
+        }
+        else
+        {
+            memmove( index+bytes_short, index,  actual_packet_data_size );
+            for( i=0; i< bytes_short; ++i)
+                *(index+i)=static_cast<uint8_t>(STUFFING_BYTE);
+            // Correct PES length field (if present)
+            if( type != PADDING_STR )
+            {
+                uint8_t *pes_header_len_offset = size_offset + 4;
+                unsigned int pes_header_len = 
+                    index+bytes_short-(pes_header_len_offset+1);
+                *pes_header_len_offset = static_cast<uint8_t>(pes_header_len);	            }
+        }
+        index += bytes_short;
+        bytes_short = 0;
+    }
+
+	
+    /* MPEG-2: We now know the final PES header after padding...
+     */
+    index += actual_packet_data_size;	 
+    /* MPEG-1, MPEG-2: Now we know that actual packet size */
+    size_offset[0] = static_cast<uint8_t>((index-size_offset-2)>>8);
+    size_offset[1] = static_cast<uint8_t>((index-size_offset-2)&0xff);
+	
+    /* The case where we have fallen short enough to allow it to be
+       dealt with by inserting a stuffing packet... */	
+    if ( bytes_short != 0 )
+    {
+        *(index++) = static_cast<uint8_t>(PACKET_START)>>16;
+        *(index++) = static_cast<uint8_t>(PACKET_START & 0x00ffff)>>8;
+        *(index++) = static_cast<uint8_t>(PACKET_START & 0x0000ff);
+        *(index++) = PADDING_STR;
+        *(index++) = static_cast<uint8_t>((bytes_short - 6) >> 8);
+        *(index++) = static_cast<uint8_t>((bytes_short - 6) & 0xff);
+        if (mpeg_version == 2)
+        {
+            for (i = 0; i < bytes_short - 6; i++)
+                *(index++) = static_cast<uint8_t>(STUFFING_BYTE);
+        }
+        else
+        {
+            *(index++) = 0x0F;
+            for (i = 0; i < bytes_short - 7; i++)
+                *(index++) = static_cast<uint8_t>(STUFFING_BYTE);
+        }
+		
+        bytes_short = 0;
+    }
+	 
+    if( end_marker )
+    {
+        *(index++) = static_cast<uint8_t>((ISO11172_END)>>24);
+        *(index++) = static_cast<uint8_t>((ISO11172_END & 0x00ff0000)>>16);
+        *(index++) = static_cast<uint8_t>((ISO11172_END & 0x0000ff00)>>8);
+        *(index++) = static_cast<uint8_t>(ISO11172_END & 0x000000ff);
+    }
+
+    unsigned int j;
+    for (j = 0; j < mux_strm.zero_stuffing; j++)
+        *(index++) = static_cast<uint8_t>(0);
+	
+
+    /* At this point padding or stuffing will have ensured the packet
+       is filled to target_packet_data_size
+    */ 
+    RawWrite(sector_buf, sector_size);
+    return actual_packet_data_size;
+}
+
+
+
+
+/*************************************************************************
+	Create_Pack
+	erstellt in einem Buffer die spezifischen Pack-Informationen.
+	Diese werden dann spaeter von der Sector-Routine nochmals
+	in dem Sektor kopiert.
+
+	writes specifical pack header information into a buffer
+	later this will be copied from the sector routine into
+	the sector buffer
+*************************************************************************/
+
+void 
+PS_Stream::CreatePack ( Pack_struc	 *pack,
+                        clockticks   SCR,
+                        unsigned int 	 mux_rate
+    )
+{
+    uint8_t *index;
+
+    index = pack->buf;
+
+    *(index++) = static_cast<uint8_t>((PACK_START)>>24);
+    *(index++) = static_cast<uint8_t>((PACK_START & 0x00ff0000)>>16);
+    *(index++) = static_cast<uint8_t>((PACK_START & 0x0000ff00)>>8);
+    *(index++) = static_cast<uint8_t>(PACK_START & 0x000000ff);
+        
+    if (mpeg_version == 2)
+    {
+        /* Annoying: MPEG-2's SCR pack header time is different from
+           all the rest... */
+        BufferMpeg2ScrTimecode(SCR, index);
+        *(index++) = static_cast<uint8_t>(mux_rate >> 14);
+        *(index++) = static_cast<uint8_t>(0xff & (mux_rate >> 6));
+        *(index++) = static_cast<uint8_t>(0x03 | ((mux_rate & 0x3f) << 2));
+        *(index++) = (uint8_t)(RESERVED_BYTE << 3 | 0); /* No pack stuffing */
+    }
+    else
+    {
+        BufferDtsPtsMpeg1ScrTimecode(SCR, MARKER_MPEG1_SCR, index);
+        *(index++) = static_cast<uint8_t>(0x80 | (mux_rate >> 15));
+        *(index++) = static_cast<uint8_t>(0xff & (mux_rate >> 7));
+        *(index++) = static_cast<uint8_t>(0x01 | ((mux_rate & 0x7f) << 1));
+    }
+    pack->SCR = SCR;
+    pack->length = index-pack->buf;
+}
+
+
+/*************************************************************************
+	Create_Sys_Header
+	erstelle in einem Buffer die spezifischen Sys_Header
+	Informationen. Diese werden spaeter von der Sector-Routine
+	nochmals zum Sectorbuffer kopiert.
+
+	writes specifical system header information into a buffer
+	later this will be copied from the sector routine into
+	the sector buffer
+	RETURN: Length of header created...
+*************************************************************************/
+
+void 
+PS_Stream::CreateSysHeader (	Sys_header_struc *sys_header,
+                                unsigned int	 rate_bound,
+                                bool	 fixed,
+                                int	     CSPS,
+                                bool	 audio_lock,
+                                bool	 video_lock,
+                                vector<MuxStream *> &streams
+    )
+
+{
+    uint8_t *index;
+    uint8_t *len_index;
+    int system_header_size;
+    index = sys_header->buf;
+    int video_bound = 0;
+    int audio_bound = 0;
+	std::vector<MuxStream *>::iterator str;
+    for( str = streams.begin(); str < streams.end(); ++str )
+    {
+        switch( ((*str)->stream_id & 0xf0) )
+        {
+        case 0xe0 :             // MPEG Video
+            ++video_bound;
+            break;
+        case 0xb0 :             // DVD seems to use these stream id in
+                                // system headers for buffer size counts
+            if( (*str)->stream_id == 0xb9 )
+                ++video_bound;   
+            if( (*str)->stream_id == 0xbd )
+                ++audio_bound;   
+            break;
+        case 0xc0 :
+            ++audio_bound;      // MPEG Audio
+            break;
+        default :
+            break;
+        }
+    }
+
+    /* if we are not using both streams, we should clear some
+       options here */
+
+    *(index++) = static_cast<uint8_t>((SYS_HEADER_START)>>24);
+    *(index++) = static_cast<uint8_t>((SYS_HEADER_START & 0x00ff0000)>>16);
+    *(index++) = static_cast<uint8_t>((SYS_HEADER_START & 0x0000ff00)>>8);
+    *(index++) = static_cast<uint8_t>(SYS_HEADER_START & 0x000000ff);
+
+    len_index = index;	/* Skip length field for now... */
+    index +=2;
+
+    *(index++) = static_cast<uint8_t>(0x80 | (rate_bound >>15));
+    *(index++) = static_cast<uint8_t>(0xff & (rate_bound >> 7));
+    *(index++) = static_cast<uint8_t>(0x01 | ((rate_bound & 0x7f)<<1));
+    *(index++) = static_cast<uint8_t>((audio_bound << 2)|(fixed << 1)|CSPS);
+    *(index++) = static_cast<uint8_t>((audio_lock << 7)|
+                                      (video_lock << 6)|0x20|video_bound);
+
+    *(index++) = static_cast<uint8_t>(RESERVED_BYTE);
+    for( str = streams.begin(); str < streams.end(); ++str )
+    {
+        *(index++) = (*str)->stream_id;
+        *(index++) = static_cast<uint8_t> 
+            (0xc0 |
+             ((*str)->BufferScale() << 5) | ((*str)->BufferSizeCode() >> 8));
+        *(index++) = static_cast<uint8_t>((*str)->BufferSizeCode() & 0xff);
+    }
+
+
+    system_header_size = (index - sys_header->buf);
+    len_index[0] = static_cast<uint8_t>((system_header_size-6) >> 8);
+    len_index[1] = static_cast<uint8_t>((system_header_size-6) & 0xff);
+    sys_header->length = system_header_size;
+}
+
+
+
+
+/* 
+ * Local variables:
+ *  c-file-style: "stroustrup"
+ *  tab-width: 4
+ *  indent-tabs-mode: nil
+ * End:
+ */

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/systems.hpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/systems.hpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/systems.hpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,158 @@
+
+/*
+ *  interact.h:  Program/System stream packet generator
+ *
+ *  Copyright (C) 2003 Andrew Stevens <andrew.stevens at philips.com>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of version 2 of the GNU General Public License
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#ifndef __SYSTEMS_HH__
+#define __SYSTEMS_HH__
+
+#include "inputstrm.hpp"
+#include "outputstrm.hpp"
+#include <vector>
+
+using std::vector;
+
+/* Buffer size parameters */
+
+#define MAX_SECTOR_SIZE         16384
+#define MAX_PACK_HEADER_SIZE	255
+#define MAX_SYS_HEADER_SIZE     255
+
+
+typedef struct sector_struc	/* Ein Sektor, kann Pack, Sys Header	*/
+/* und Packet enthalten.		*/
+{   unsigned char  buf [MAX_SECTOR_SIZE] ;
+  unsigned int   length_of_packet_data ;
+  //clockticks TS                ;
+} Sector_struc;
+
+struct Pack_struc	/* Pack Info				*/
+{ 
+    uint8_t buf[MAX_PACK_HEADER_SIZE];
+    int length;
+    clockticks SCR;
+};
+
+struct Sys_header_struc	/* System Header Info			*/
+{   
+    uint8_t buf[MAX_SYS_HEADER_SIZE];
+    int length;
+};
+
+
+class PS_Stream
+{
+public:
+    PS_Stream( unsigned _mpeg,
+               unsigned int _sector_size,
+               OutputStream &_output_strm, 
+               off_t max_segment_size // 0 = No Limit
+        );
+    virtual ~PS_Stream();
+
+    unsigned int PacketPayload( MuxStream &strm,
+                                Sys_header_struc *sys_header, 
+                                Pack_struc *pack_header, 
+                                int buffers, int PTSstamp, int DTSstamp );
+
+    unsigned int CreateSector (Pack_struc	 	 *pack,
+                               Sys_header_struc *sys_header,
+                               unsigned int     max_packet_data_size,
+                               MuxStream        &strm,
+                               bool 	 buffers,
+                               bool      end_marker,
+                               clockticks   	 PTS,
+                               clockticks   	 DTS,
+                               uint8_t 	 timestamps
+        );
+    static void BufferSectorHeader( uint8_t *buf,
+                             Pack_struc	 	 *pack,
+                             Sys_header_struc *sys_header,
+                             uint8_t *&header_end );
+    static void BufferPacketHeader( uint8_t *buf,
+                                    uint8_t type,
+                                    unsigned int mpeg_version,
+                                    bool buffers,
+                                    unsigned int buffer_size,
+                                    uint8_t buffer_scale,
+                                    clockticks   	 PTS,
+                                    clockticks   	 DTS,
+                                    uint8_t 	 timestamps,
+                                    unsigned int min_pes_hdr_len,
+                                    uint8_t     *&size_field,
+                                    uint8_t     *&header_end );
+    
+    static inline void 
+    BufferPacketSize( uint8_t *size_field, uint8_t *packet_end )
+        {
+            unsigned int packet_size = packet_end-size_field-2;
+            size_field[0] = static_cast<uint8_t>(packet_size>>8);
+            size_field[1] = static_cast<uint8_t>(packet_size&0xff);
+
+        }
+
+    virtual void CreatePack ( Pack_struc	 *pack,
+                      clockticks   SCR,
+                      unsigned int 	 mux_rate
+        );
+    virtual void CreateSysHeader ( Sys_header_struc *sys_header,
+                           unsigned int	 rate_bound,
+                           bool	 fixed,
+                           int	     CSPS,
+                           bool	 audio_lock,
+                           bool	 video_lock,
+                           vector<MuxStream *> &streams
+        );
+
+    inline int Open() { return output_strm.Open(); }
+    inline void Close() { output_strm.Close(); }
+    inline void RawWrite(uint8_t *data, unsigned int len)
+        {
+            return output_strm.Write( data, len );
+        }
+    inline void NextSegment() { output_strm.NextSegment(); }
+    bool SegmentLimReached();
+
+
+private:
+    static void 
+    BufferDtsPtsMpeg1ScrTimecode (clockticks    timecode,
+                                  uint8_t  marker,
+                                  uint8_t *&buffer);
+    static void BufferMpeg2ScrTimecode( clockticks    timecode,
+                                        uint8_t *&buffer);
+    void BufferPaddingPacket( int padding,
+                              uint8_t *&buffer );
+private:
+    OutputStream &output_strm; 
+    unsigned int mpeg_version;
+    unsigned int sector_size;
+    off_t max_segment_size;
+    uint8_t *sector_buf;
+};
+#endif // __SYSTEMS_HH__
+
+
+/* 
+ * Local variables:
+ *  c-file-style: "stroustrup"
+ *  tab-width: 4
+ *  indent-tabs-mode: nil
+ * End:
+ */

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/videostrm.hpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/videostrm.hpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/videostrm.hpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,153 @@
+
+/*
+ *  videostrm.hpp:  Video stream elementary input stream
+ *
+ *  Copyright (C) 2001 Andrew Stevens <andrew.stevens at philips.com>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of version 2 of the GNU General Public License
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#ifndef __VIDEOSTRM_H__
+#define __VIDEOSTRM_H__
+
+#include "inputstrm.hpp"
+#include "interact.hpp"
+#include "stream_params.hpp"
+
+class VideoStream : public ElementaryStream
+{
+public:
+	VideoStream(IBitStream &ibs, VideoParams *parms, 
+                Multiplexor &into);
+	void Init( const int stream_num );
+
+    static bool Probe(IBitStream &bs );
+
+	void Close();
+
+    inline int DecoderOrder() { return au->dorder; }
+	inline int AUType()	{ return au->type; }
+
+    bool SeqEndRunOut();
+
+    const AUnit *NextIFrame();
+
+
+	inline int NextAUType()
+		{
+			AUnit *p_au = Lookahead();
+			if( p_au != 0 )
+				return p_au->type;
+			else
+				return NOFRAME;
+		}
+
+
+	virtual unsigned int NominalBitRate() 
+		{ 
+			return bit_rate * 400;
+		}
+
+    virtual void OutputGOPControlSector();
+	bool RunOutComplete();
+	virtual bool MuxPossible(clockticks currentSCR);
+    virtual void AUMuxed( bool first_in_sector ) ;
+
+    void SetMaxStdBufferDelay( unsigned int demux_rate );
+	void OutputSector();
+
+
+protected:
+    static const unsigned int MAX_GOP_LENGTH = 128;
+	void OutputSeqhdrInfo();
+	virtual void FillAUbuffer(unsigned int frames_to_buffer);
+	virtual void NextDTSPTS(  );
+	void ScanFirstSeqHeader();
+    uint8_t NewAUTimestamps( int AUtype );
+    bool NewAUBuffers( int AUtype );
+
+    unsigned int ExcludeNextIFramePayload();
+
+public:	
+    unsigned int num_sequence 	;
+    unsigned int num_seq_end	;
+    unsigned int num_pictures 	;
+    unsigned int num_groups 	;
+    unsigned int num_frames[4] 	;
+         int64_t avg_frames[4]  ;
+    
+    unsigned int horizontal_size;
+    unsigned int vertical_size 	;
+     unsigned int aspect_ratio	;
+    unsigned int picture_rate	;
+    unsigned int bit_rate 	;
+    unsigned int vbv_buffer_size;
+    unsigned int CSPF 		;
+    double secs_per_frame;
+
+	
+	bool dtspts_for_all_au;     // Ensure every AU has a timestamp 
+                                // (no two AU can start in one sector)
+    bool gop_control_packet;
+
+protected:
+
+
+	/* State variables for scanning source bit-stream */
+    AUnit access_unit;
+	int fields_presented;
+    int group_start_pic;
+	int group_start_field;
+    int group_start_SCR;
+    int temporal_reference;
+    unsigned int pict_struct;
+	int pulldown_32;
+	int repeat_first_field;
+	int prev_temp_ref;
+    int ref_present;
+    int prev_ref_present;
+    double frame_rate;
+	double max_bits_persec;
+	int AU_pict_data;
+	int AU_hdr;
+    clockticks max_STD_buffer_delay;
+    VideoParams *parms;
+}; 	
+
+//
+// DVD's generate control sectors for each GOP...
+//
+
+class DVDVideoStream : public VideoStream
+{
+public:
+	DVDVideoStream(IBitStream &ibs,VideoParams *parms,Multiplexor &into) : 
+        VideoStream( ibs, parms, into )
+        {
+            gop_control_packet = true;
+        }
+    void OutputGOPControlSector();  
+};
+
+#endif // __INPUTSTRM_H__
+
+
+/* 
+ * Local variables:
+ *  c-file-style: "stroustrup"
+ *  tab-width: 4
+ *  indent-tabs-mode: nil
+ * End:
+ */

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/videostrm_in.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/videostrm_in.cpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/videostrm_in.cpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,498 @@
+/*
+ *  inptstrm.c:  Members of video stream class related to raw stream
+ *               scanning and buffering.
+ *
+ *  Copyright (C) 2001 Andrew Stevens <andrew.stevens at philips.com>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of version 2 of the GNU General Public License
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#include <config.h>
+#include <math.h>
+#include <stdlib.h>
+
+#include "videostrm.hpp"
+#include "interact.hpp"
+#include "multiplexor.hpp"
+
+
+
+static void marker_bit (IBitStream &bs, unsigned int what)
+{
+    if (what != bs.Get1Bit())
+    {
+        mjpeg_error ("Illegal MPEG stream at offset (bits) %lld: supposed marker bit not found.",bs.bitcount());
+        exit (1);
+    }
+}
+
+
+void VideoStream::ScanFirstSeqHeader()
+{
+    if (bs.GetBits( 32)==SEQUENCE_HEADER)
+    {
+		num_sequence++;
+		horizontal_size	= bs.GetBits( 12);
+		vertical_size	= bs.GetBits( 12);
+		aspect_ratio	= bs.GetBits(  4);
+		picture_rate 	= bs.GetBits(  4);
+		bit_rate		= bs.GetBits( 18);
+		marker_bit( bs, 1);
+		vbv_buffer_size	= bs.GetBits( 10);
+		CSPF		= bs.Get1Bit();
+
+    } else
+    {
+		mjpeg_error ("Invalid MPEG Video stream header.");
+		exit (1);
+    }
+
+	if (MX_mpeg_valid_framerate_code(picture_rate))
+    {
+		frame_rate = Y4M_RATIO_DBL(MX_mpeg_framerate(picture_rate));
+	}
+    else
+    {
+		frame_rate = 25.0;
+	}
+
+}
+
+
+
+
+void VideoStream::Init ( const int stream_num )
+{
+	mjpeg_debug( "SETTING video buffer to %d", parms->DecodeBufferSize() );
+	MuxStream::Init( VIDEO_STR_0+stream_num,
+					 1,  // Buffer scale
+					 parms->DecodeBufferSize()*1024,
+					 0,  // Zero stuffing
+					 muxinto.buffers_in_video,
+					 muxinto.always_buffers_in_video);
+    mjpeg_info( "Scanning for header info: Video stream %02x (%s) ",
+                VIDEO_STR_0+stream_num,
+                bs.StreamName()
+                );
+
+	SetBufSize( 4*1024*1024 );
+	ScanFirstSeqHeader();
+
+	/* Skip to the end of the 1st AU (*2nd* Picture start!)
+	*/
+	AU_hdr = SEQUENCE_HEADER;
+	AU_pict_data = 0;
+	AU_start = 0;
+    
+    fields_presented = 0;
+    group_start_pic = 0;
+    group_start_field = 0;
+    OutputSeqhdrInfo();
+}
+
+//
+// Set the Maximum STD buffer delay for this video stream.
+// By default we set 1 second but if we have specified a video
+// buffer that can hold more than 1.0 seconds demuxed data we
+// set the delay to the time to fill the buffer.
+//
+
+void VideoStream::SetMaxStdBufferDelay( unsigned int dmux_rate )
+{
+    double max_delay = CLOCKS;
+    if( static_cast<double>(BufferSize()) / dmux_rate > 1.0 )
+        max_delay *= static_cast<double>(BufferSize()) / dmux_rate;
+
+    //
+    // To enforce a maximum STD buffer residency the
+    // calculation is a bit tricky as when we decide to mux we may
+    // (but not always) have some of the *previous* picture left to
+    // mux in which case it is the timestamp of the next picture that counts.
+    // For simplicity we simply reduce the limit by 1.5 frame intervals
+    // and use the timestamp for the current picture.
+    //
+    if( frame_rate > 10.0 )
+        max_STD_buffer_delay = static_cast<clockticks>(max_delay * (frame_rate-1.5)/frame_rate);
+    else
+        max_STD_buffer_delay = static_cast<clockticks>(10.0 * max_delay / frame_rate);
+
+}
+
+
+//
+// Refill the AU unit buffer setting  AU PTS DTS from the scanned
+// header information...
+//
+
+void VideoStream::FillAUbuffer(unsigned int frames_to_buffer)
+{
+    if( eoscan )
+        return;
+
+	last_buffered_AU += frames_to_buffer;
+	mjpeg_debug( "Scanning %d video frames to start of frame %d", 
+				 frames_to_buffer, last_buffered_AU );
+
+    // We set a limit of 2M to seek before we give up.
+    // This is intentionally very high because some heavily
+    // padded still frames may have a loooong gap before
+    // a following sequence end marker.
+    // IMPORTANT: SeekSync *must* come last otherwise a header
+    // will be lost!!!!
+	while(!bs.eos() 
+          && decoding_order < last_buffered_AU  
+          && !muxinto.AfterMaxPTS(access_unit.PTS)
+		  && bs.SeekSync( SYNCWORD_START, 24, 2*1024*1024)
+		)
+	{
+		syncword = (SYNCWORD_START<<8) + bs.GetBits( 8);
+		if( AU_pict_data )
+		{
+			
+			/* Handle the header *ending* an AU...
+			   If we have the AU picture data an AU and have now
+			   reached a header marking the end of an AU fill in the
+			   the AU length and append it to the list of AU's and
+			   start a new AU.  I.e. sequence and gop headers count as
+			   part of the AU of the corresponding picture
+			*/
+			stream_length = bs.bitcount()-static_cast<bitcount_t>(32);
+			switch (syncword) 
+			{
+			case SEQUENCE_HEADER :
+                mjpeg_debug( "Seq hdr @ %lld", bs.bitcount() / 8-4 );
+			case GROUP_START :
+                mjpeg_debug( "Group hdr @ %lld", bs.bitcount() / 8-4 );
+			case PICTURE_START :
+				access_unit.start = AU_start;
+				access_unit.length = static_cast<int>(stream_length - AU_start)>>3;
+				access_unit.end_seq = 0;
+				avg_frames[access_unit.type-1]+=access_unit.length;
+				mjpeg_debug( "AU %d %d %d @ %lld: DTS=%ud", 
+                             decoding_order,
+                             access_unit.type,
+                             access_unit.length,
+                             bs.bitcount() / 8-4,
+							 static_cast<unsigned int>(access_unit.DTS/300) );
+
+
+				aunits.Append( access_unit );					
+                decoding_order++;
+				AU_hdr = syncword;
+				AU_start = stream_length;
+				AU_pict_data = 0;
+				break;
+			case SEQUENCE_END:
+				access_unit.length = ((stream_length - AU_start)>>3)+4;
+				access_unit.end_seq = 1;
+				aunits.Append( access_unit );
+				mjpeg_info( "Scanned to end AU %d", access_unit.dorder );
+				avg_frames[access_unit.type-1]+=access_unit.length;
+
+				/* Do we have a sequence split in the video stream? */
+				if( !bs.eos() && 
+					bs.GetBits( 32) ==SEQUENCE_HEADER )
+				{
+					stream_length = bs.bitcount()-static_cast<bitcount_t>(32);
+					AU_start = stream_length;
+					syncword  = AU_hdr = SEQUENCE_HEADER;
+					AU_pict_data = 0;
+					if( !muxinto.split_at_seq_end )
+						mjpeg_warn("Sequence end marker found in video stream but single-segment splitting specified!" );
+				}
+				else
+				{
+					if( !bs.eos() && muxinto.split_at_seq_end )
+						mjpeg_warn("No seq. header starting new sequence after seq. end!");
+				}
+                decoding_order++;
+				num_seq_end++;
+				break;
+			}
+		}
+
+		/* Handle the headers starting an AU... */
+		switch (syncword) 
+		{
+		case SEQUENCE_HEADER:
+			/* TODO: Really we should update the info here so we can handle
+			 streams where parameters change on-the-fly... */
+			num_sequence++;
+			break;
+			
+		case GROUP_START:
+			num_groups++;
+			break;
+			
+		case PICTURE_START:
+			/* We have reached AU's picture data... */
+			AU_pict_data = 1;
+            mjpeg_debug( "Picture start @ %lld", bs.bitcount() / 8-4 );
+			
+            prev_temp_ref = temporal_reference;
+			temporal_reference = bs.GetBits( 10);
+			access_unit.type   = bs.GetBits( 3);
+
+			/* Now scan forward a little for an MPEG-2 picture coding extension
+			   so we can get pulldown info (if present) */
+			if( bs.SeekSync(EXT_START_CODE, 32, 64) &&
+                bs.GetBits(4) == CODING_EXT_ID)
+			{
+				/* Skip: 4 F-codes (4)... */
+				(void)bs.GetBits(16); 
+                /* Skip: DC Precision(2) */
+                (void)bs.GetBits(2);
+                pict_struct = bs.GetBits(2);
+                /* Skip: topfirst (1) frame pred dct (1),
+                   concealment_mv(1), q_scale_type (1), */
+				(void)bs.GetBits(4);	
+				/* Skip: intra_vlc_format(1), alternate_scan (1) */
+				(void)bs.GetBits(2);	
+				repeat_first_field = bs.Get1Bit();
+				pulldown_32 |= repeat_first_field;
+
+			}
+			else
+			{
+				repeat_first_field = 0;
+                pict_struct = PIC_FRAME;
+			}
+				
+			if( access_unit.type == IFRAME )
+			{
+                double bits_persec = 
+                    static_cast<double>( stream_length - prev_offset) 
+                    * 2.0 * frame_rate  
+                    / static_cast<double>(fields_presented - group_start_field);
+                
+				if( bits_persec > max_bits_persec )
+				{
+					max_bits_persec = bits_persec;
+				}
+				prev_offset = stream_length;
+				group_start_pic = decoding_order;
+				group_start_field = fields_presented;
+			}
+
+			NextDTSPTS( );
+
+			access_unit.dorder = decoding_order;
+			access_unit.porder = temporal_reference + group_start_pic;
+
+			access_unit.seq_header = ( AU_hdr == SEQUENCE_HEADER);
+
+			if ((access_unit.type>0) && (access_unit.type<5))
+			{
+				num_frames[access_unit.type-1]++;
+			}
+
+			
+			if ( decoding_order >= old_frames+1000 )
+			{
+				mjpeg_debug("Got %d picture headers.", decoding_order);
+				old_frames = decoding_order;
+			}
+			
+			break;		    
+
+  
+				
+		}
+	}
+
+	last_buffered_AU = decoding_order;
+	num_pictures = decoding_order;	
+	eoscan = bs.eos() || muxinto.AfterMaxPTS(access_unit.PTS);
+}
+
+void VideoStream::Close()
+{
+    unsigned int comp_bit_rate	;
+    unsigned int peak_bit_rate  ;
+
+    stream_length = bs.bitcount() / 8;
+    for( int i=0; i<4; i++)
+	{
+		avg_frames[i] /= num_frames[i] == 0 ? 1 : num_frames[i];
+	}
+
+	/* Average and Peak bit rate in 50B/sec units... */
+    comp_bit_rate = 
+        static_cast<unsigned int>( static_cast<unsigned int>( stream_length / fields_presented * 2 ) 
+                                   * frame_rate  + 25) / 50;
+
+	peak_bit_rate = static_cast<unsigned int>((max_bits_persec / 8 + 25) / 50);
+	mjpeg_info ("VIDEO_STATISTICS: %02x", stream_id); 
+    mjpeg_info ("Video Stream length: %11llu bytes", stream_length);
+    mjpeg_info ("Sequence headers: %8u",num_sequence);
+    mjpeg_info ("Sequence ends   : %8u",num_seq_end);
+    mjpeg_info ("No. Pictures    : %8u",num_pictures);
+    mjpeg_info ("No. Groups      : %8u",num_groups);
+    mjpeg_info ("No. I Frames    : %8u avg. size%6u bytes",
+			  num_frames[0], (uint32_t)avg_frames[0]);
+    mjpeg_info ("No. P Frames    : %8u avg. size%6u bytes",
+			  num_frames[1], (uint32_t)avg_frames[1]);
+    mjpeg_info ("No. B Frames    : %8u avg. size%6u bytes",
+			  num_frames[2], (uint32_t)avg_frames[2]);
+    mjpeg_info("Average bit-rate : %8u bits/sec",comp_bit_rate*400);
+    mjpeg_info("Peak bit-rate    : %8u  bits/sec",peak_bit_rate*400);
+	
+}
+	
+
+
+
+/*************************************************************************
+	OutputSeqHdrInfo
+     Display sequence header parameters
+*************************************************************************/
+
+void VideoStream::OutputSeqhdrInfo ()
+{
+	const char *str;
+	mjpeg_info("VIDEO STREAM: %02x", stream_id);
+
+    mjpeg_info ("Frame width     : %u",horizontal_size);
+    mjpeg_info ("Frame height    : %u",vertical_size);
+	if (MX_mpeg_valid_aspect_code(muxinto.mpeg, aspect_ratio))
+		str =  MX_mpeg_aspect_code_definition(muxinto.mpeg,aspect_ratio);
+	else
+		str = "forbidden";
+    mjpeg_info ("Aspect ratio    : %s", str );
+				
+
+    if (picture_rate == 0)
+		mjpeg_info( "Picture rate    : forbidden");
+    else if (MX_mpeg_valid_framerate_code(picture_rate))
+		mjpeg_info( "Picture rate    : %2.3f frames/sec",
+					Y4M_RATIO_DBL(MX_mpeg_framerate(picture_rate)) );
+    else
+		mjpeg_info( "Picture rate    : %x reserved",picture_rate);
+
+    if (bit_rate == 0x3ffff)
+		{
+			bit_rate = 0;
+			mjpeg_info( "Bit rate        : variable"); 
+		}
+    else if (bit_rate == 0)
+		mjpeg_info( "Bit rate       : forbidden");
+    else
+		mjpeg_info( "Bit rate        : %u bits/sec",
+					bit_rate*400);
+
+    mjpeg_info("Vbv buffer size : %u bytes",vbv_buffer_size*2048);
+    mjpeg_info("CSPF            : %u",CSPF);
+}
+
+//
+// Compute PTS DTS of current AU in the video sequence being
+// scanned.  This is is the PTS/DTS calculation for normal video only.
+// It is virtual and over-ridden for non-standard streams (Stills
+// etc!).
+//
+
+int gopfields_32pd( int temporal_ref, bool repeat_first_field )
+{
+    int frames2field;
+    int frames3field;
+    //
+    // Assume first presented frame of GOP has temporal ref 0
+    if( repeat_first_field )
+    {
+        frames2field = (temporal_ref+1) / 2;
+        frames3field = temporal_ref / 2;
+    }
+    else
+    {
+        frames2field = (temporal_ref) / 2;
+        frames3field = (temporal_ref+1) / 2;
+    }
+
+    return frames2field*2 + frames3field*3;
+
+}
+
+/****************************************************
+ *
+ * Work out DTS PTS stamps for the current AU.
+ * Note: Current strategy assumes decoders model 'ideal'
+ * timing with instantaneous decoding.
+ * This makes sense it is what is assumed for B-frames anyway
+ * (no seperate DTS).
+ *
+ ******************************************************/
+
+void VideoStream::NextDTSPTS()
+{
+    const int decode_delay = 0;
+    int startup_skew = 2;
+    int decode_fields, present_fields;
+    if( pict_struct != PIC_FRAME )
+    {
+		decode_fields = fields_presented;
+        present_fields = temporal_reference*2 + group_start_field+decode_delay/2;
+        if( temporal_reference == prev_temp_ref )
+            present_fields += 1;
+        fields_presented += 1;
+    }	
+    else if( pulldown_32 )
+	{
+        present_fields = group_start_field  + startup_skew + decode_delay +
+            gopfields_32pd( temporal_reference, repeat_first_field );
+        
+        if( decoding_order == 0 )
+        {
+            // Special case... first IFRAME is not decoded during presentation
+            // of previous ref frame but immediately at start
+            decode_fields = 0;
+            prev_ref_present = present_fields ;
+        }
+        else if( access_unit.type == IFRAME || access_unit.type == PFRAME )
+        {
+            decode_fields = prev_ref_present-decode_delay;
+            prev_ref_present = present_fields;
+        }
+        else
+        {
+            decode_fields = present_fields - decode_delay;
+        }
+        fields_presented += repeat_first_field ? 3 : 2;
+	}
+    else
+	{
+        decode_fields = decoding_order*2;
+        present_fields = (temporal_reference + group_start_pic)*2
+            + startup_skew + decode_delay;
+		fields_presented += 2;
+	}
+
+    access_unit.DTS = static_cast<clockticks>
+        (decode_fields * (double)(CLOCKS/2) / frame_rate);
+    
+    access_unit.PTS = static_cast<clockticks>
+        (present_fields * (double)(CLOCKS/2) / frame_rate);
+}
+
+
+
+
+
+/* 
+ * Local variables:
+ *  c-file-style: "stroustrup"
+ *  tab-width: 4
+ *  indent-tabs-mode: nil
+ * End:
+ */

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/videostrm_out.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/videostrm_out.cpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/videostrm_out.cpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,371 @@
+
+/*
+ *  inptstrm.c:  Members of input stream classes related to muxing out into
+ *               the output stream.
+ *
+ *  Copyright (C) 2001 Andrew Stevens <andrew.stevens at philips.com>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of version 2 of the GNU General Public License
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+
+#include <config.h>
+#include <assert.h>
+
+#include "mjpeg_types.h"
+#include "videostrm.hpp"
+#include "multiplexor.hpp"
+
+VideoStream::VideoStream(IBitStream &ibs, VideoParams *parms, 
+                         Multiplexor &into ) :
+	ElementaryStream( ibs, into, ElementaryStream::video ),
+	num_sequence(0),
+	num_seq_end(0),
+	num_pictures(0),
+	num_groups(0),
+	dtspts_for_all_au( into.dtspts_for_all_vau ),
+    gop_control_packet( false ),
+    parms(parms)
+{
+	prev_offset=0;
+    decoding_order=0;
+	fields_presented=0;
+    group_start_pic=0;
+	group_start_field=0;
+    temporal_reference=0;
+	pulldown_32 = 0;
+    temporal_reference = -1;   // Needed to recognise 2nd field of 1st
+                               // frame in a field pic sequence
+	last_buffered_AU=0;
+	max_bits_persec = 0;
+	AU_hdr = SEQUENCE_HEADER;  /* GOP or SEQ Header starting AU? */
+	for( int i =0; i<4; ++i )
+		num_frames[i] = avg_frames[i] = 0;
+    FRAME_CHUNK = 6;
+		
+}
+
+bool VideoStream::Probe(IBitStream &bs )
+{
+    return bs.GetBits( 32)  == 0x1b3;
+}
+
+/*********************************
+ * Signals when video stream has completed mux run-out specified
+ * in associated mux stream.   Run-out is always to complete GOP's.
+ *********************************/
+
+bool VideoStream::RunOutComplete()
+{
+ 
+	return (au_unsent == 0 || 
+			( muxinto.running_out &&
+			  au->type == IFRAME && RequiredPTS() >= muxinto.runout_PTS));
+}
+
+/*********************************
+ * Signals if it is permissible/possible to Mux out a sector from the Stream.
+ * The universal constraints that muxing should not be complete and that
+ * that the reciever buffer should have sufficient it also insists that
+ * the muxed data won't hang around in the receiver buffer for more than
+ * one second.  This is mainly for the benefit of (S)VCD and DVD applications
+ * where long delays mess up random access.
+ *******************************/
+
+bool VideoStream::MuxPossible( clockticks currentSCR )
+{
+	return ( ElementaryStream::MuxPossible(currentSCR) && 
+             RequiredDTS() < currentSCR + max_STD_buffer_delay );
+}
+
+
+void VideoStream::AUMuxed( bool first_in_sector )
+{
+    //DEBUG
+    //mjpeg_info( "VidMuxed: %d %lld ", au->dorder, RequiredDTS()/300 );
+}
+
+
+/*********************************
+ * Work out the timestamps to be set in the header of sectors starting
+ * new AU's.
+ *********************************/
+
+uint8_t VideoStream::NewAUTimestamps( int AUtype )
+{
+	uint8_t timestamps;
+    if( AUtype == BFRAME)
+        timestamps=TIMESTAMPBITS_PTS;
+    else 
+        timestamps=TIMESTAMPBITS_PTS_DTS;
+
+    if( muxinto.timestamp_iframe_only && AUtype != IFRAME)
+        timestamps=TIMESTAMPBITS_NO;
+    return timestamps;
+}
+
+/*********************************
+ * Work out the buffer records to be set in the header of sectors
+ * starting new AU's.
+ *********************************/
+
+bool VideoStream::NewAUBuffers( int AUtype )
+{
+    return buffers_in_header & 
+        !(muxinto.video_buffers_iframe_only && AUtype != IFRAME);
+}
+
+/********************************
+ *
+ * Check if the next sector could potentially include parts of AUs
+ * following a sequence end marker... in this case a run-out may be needed
+ *
+ *******************************/
+
+bool VideoStream::SeqEndRunOut()
+{
+    unsigned int payload = au_unsent;
+    unsigned int ahead = 0;
+    AUnit *next_au = au;
+    for(;;)
+    {
+        if( next_au->end_seq || payload >= muxinto.sector_size)
+            break;  
+        ++ahead;
+        next_au = Lookahead(ahead);
+        if( next_au == 0 )
+            break;
+        payload += next_au->PayloadSize();
+    }
+    
+    // We don't need to start run-out if the next sector cannot contain
+    // next sequence or there is no next sequence (no AU after the one with
+    // the sequence end marker
+    return next_au != 0 && next_au->end_seq 
+        && payload < muxinto.sector_size
+        && Lookahead(ahead+1) != 0;
+
+}
+
+/********************************
+ *
+ * Check if the next sector could potentially include a seq_end marker
+ *
+ *******************************/
+
+const AUnit *VideoStream::NextIFrame()
+{
+    unsigned int ahead = 0;
+    AUnit *au_ahead = Lookahead(ahead);
+    while( au_ahead != 0 && au_ahead->type != IFRAME 
+           && ahead < MAX_GOP_LENGTH )
+    {
+        ++ahead;
+        au_ahead = Lookahead(ahead);
+    }
+    return au_ahead;
+}
+
+/********************************
+ *
+ * Calculate how much payload can be muxed next sector without
+ * including the next IFRAME.
+ *
+ *******************************/
+
+unsigned int VideoStream::ExcludeNextIFramePayload()
+{
+    unsigned int payload = au_unsent;
+    unsigned int ahead = 0;
+    AUnit *au_ahead;
+    for(;;)
+    {
+        au_ahead = Lookahead(ahead);
+        if( au_ahead == 0 || payload >= muxinto.sector_size || au_ahead->type == IFRAME )
+            break;
+        payload += au_ahead->PayloadSize();
+        ++ahead;
+    }
+    assert( eoscan || au_ahead != 0 );
+    return payload;
+}
+
+/******************************************************************
+	Output_Video
+	generiert Pack/Sys_Header/Packet Informationen aus dem
+	Video Stream und speichert den so erhaltenen Sektor ab.
+
+	generates Pack/Sys_Header/Packet information from the
+	video stream and writes out the new sector
+******************************************************************/
+
+void VideoStream::OutputSector ( )
+
+{
+	unsigned int max_packet_payload; 	 
+	unsigned int actual_payload;
+	unsigned int old_au_then_new_payload;
+	clockticks  DTS,PTS;
+    int autype;
+
+	max_packet_payload = 0;	/* 0 = Fill sector */
+  	/* 	
+       I-frame aligning.  For the last AU of segment or for formats
+       with ACCESS-POINT sectors where I-frame (and preceding headers)
+       are sector aligned.
+
+       We need to look ahead to see how much we may put into the current packet
+       without without touching the next I-frame (which is supposed to be
+       placed at the start of its own sector).
+
+       N.b.runout_PTS is the PTS of the after which the next I frame
+       marks the start of the next sequence.
+	*/
+    
+    /* TODO finish this: Need to look-ahead sufficiently far to
+       guarantee finding an I-FRAME even if its predecessors are very
+       small.  
+    */
+	if( muxinto.sector_align_iframeAUs || muxinto.running_out )
+	{
+		max_packet_payload = ExcludeNextIFramePayload();
+	}
+
+	/* Figure out the threshold payload size below which we can fit more
+	   than one AU into a packet N.b. because fitting more than one in
+	   imposses an overhead of additional header fields so there is a
+	   dead spot where we *have* to stuff the packet rather than start
+	   fitting in an extra AU.  Slightly over-conservative in the case
+	   of the last packet...  */
+
+	old_au_then_new_payload = muxinto.PacketPayload( *this,
+					buffers_in_header, 
+					true, true);
+
+	/* CASE: Packet starts with new access unit			*/
+	if (new_au_next_sec  )
+	{
+        autype = AUType();
+        //
+        // Some types of output format (e.g. DVD) require special
+        // control sectors before the sector starting a new GOP
+        // N.b. this implies muxinto.sector_align_iframeAUs
+        //
+        if( gop_control_packet && autype == IFRAME )
+        {
+            OutputGOPControlSector();
+        }
+
+        //
+        // If we demand every AU should have its own timestamp
+        // We can't start two in the same sector...
+        //
+        if(  dtspts_for_all_au  && max_packet_payload == 0 )
+            max_packet_payload = au_unsent;
+
+        PTS = RequiredPTS();
+        DTS = RequiredDTS();
+		actual_payload =
+			muxinto.WritePacket ( max_packet_payload,
+						*this,
+						NewAUBuffers(autype), 
+                                  		PTS, DTS,
+						NewAUTimestamps(autype) );
+
+	}
+
+	/* CASE: Packet begins with old access unit, no new one	*/
+	/*	     can begin in the very same packet					*/
+
+	else if ( au_unsent >= old_au_then_new_payload ||
+              (max_packet_payload != 0 && au_unsent >= max_packet_payload) )
+	{
+		actual_payload = 
+			muxinto.WritePacket( au_unsent,
+							*this,
+							false, 0, 0,
+							TIMESTAMPBITS_NO );
+	}
+
+	/* CASE: Packet begins with old access unit, a new one	*/
+	/*	     could begin in the very same packet			*/
+	else /* if ( !new_au_next_sec  && 
+			(au_unsent < old_au_then_new_payload)) */
+	{
+		/* Is there a new access unit ? */
+		if( Lookahead() != 0 )
+		{
+            autype = NextAUType();
+			if(  dtspts_for_all_au  && max_packet_payload == 0 )
+				max_packet_payload = au_unsent + Lookahead()->length;
+
+			PTS = NextRequiredPTS();
+			DTS = NextRequiredDTS();
+
+			actual_payload = 
+				muxinto.WritePacket ( max_packet_payload,
+						*this,
+						NewAUBuffers(autype), 
+                                      		PTS, DTS,
+						NewAUTimestamps(autype) );
+		} 
+		else
+		{
+			actual_payload = muxinto.WritePacket ( au_unsent, 
+							*this, false, 0, 0,
+							TIMESTAMPBITS_NO);
+		}
+	}
+	++nsec;
+	buffers_in_header = always_buffers_in_header;
+}
+
+
+/***********************************************
+   OutputControlSector - Write control sectors prefixing a GOP
+   For "normal" video streams this doesn't happen and so represents
+   a bug and triggers an abort.
+
+   In DVD's these sectors carry a system header and what is
+   presumably indexing and/or sub-title information in
+   private_stream_2 packets.  I have no idea what to put in here so we
+   simply pad the sector out.
+***********************************************/
+
+void VideoStream::OutputGOPControlSector()
+{
+    abort();
+}
+
+ /******************************************************************
+ *	OutputGOPControlSector
+ *  DVD System headers are carried in peculiar sectors carrying 2
+ *  PrivateStream2 packets.   We're sticking 0's in the packets
+ *  as we have no idea what's supposed to be in there.
+ ******************************************************************/
+
+void DVDVideoStream::OutputGOPControlSector()
+{
+    muxinto.OutputDVDPriv2 ();
+}
+
+
+/* 
+ * Local variables:
+ *  c-file-style: "stroustrup"
+ *  tab-width: 4
+ *  indent-tabs-mode: nil
+ * End:
+ */

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/yuv4mpeg.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/yuv4mpeg.c	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/yuv4mpeg.c	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,1334 @@
+/*
+ *  yuv4mpeg.c:  Functions for reading and writing "new" YUV4MPEG streams
+ *
+ *  Copyright (C) 2001 Matthew J. Marjanovic <maddog at mir.com>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version 2
+ *  of the License, or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ */
+#define ADM_LEGACY_PROGGY
+#include "ADM_default.h"
+#define INTERNAL_Y4M_LIBCODE_STUFF_QPX
+#include "yuv4mpeg.h"
+#include "yuv4mpeg_intern.h"
+#include "mjpeg_logging.h"
+
+
+static int _y4mparam_allow_unknown_tags = 1;  /* default is forgiveness */
+static int _y4mparam_feature_level = 0;       /* default is ol YUV4MPEG2 */
+
+static void *(*_y4m_alloc)(size_t bytes) = malloc;
+static void (*_y4m_free)(void *ptr) = free;
+
+
+
+int y4m_allow_unknown_tags(int yn)
+{
+  int old = _y4mparam_allow_unknown_tags;
+  if (yn >= 0)
+    _y4mparam_allow_unknown_tags = (yn) ? 1 : 0;
+  return old;
+}
+
+
+int y4m_accept_extensions(int level)
+{
+  int old = _y4mparam_feature_level;
+  if (level >= 0)
+    _y4mparam_feature_level = level;
+  return old;
+}
+
+
+
+/*************************************************************************
+ *
+ * Convenience functions for fd read/write
+ *
+ *   - guaranteed to transfer entire payload (or fail)
+ *   - returns:
+ *               0 on complete success
+ *               +(# of remaining bytes) on eof (for y4m_read)
+ *               -(# of rem. bytes) on error (and ERRNO should be set)
+ *     
+ *************************************************************************/
+
+
+ssize_t y4m_read(int fd, void *buf, size_t len)
+{
+   ssize_t n;
+   uint8_t *ptr = (uint8_t *)buf;
+
+   while (len > 0) {
+     n = read(fd, ptr, len);
+     if (n <= 0) {
+       /* return amount left to read */
+       if (n == 0)
+	 return len;  /* n == 0 --> eof */
+       else
+	 return -len; /* n < 0 --> error */
+     }
+     ptr += n;
+     len -= n;
+   }
+   return 0;
+}
+
+
+ssize_t y4m_write(int fd, const void *buf, size_t len)
+{
+   ssize_t n;
+   const uint8_t *ptr = (const uint8_t *)buf;
+
+   while (len > 0) {
+     n = write(fd, ptr, len);
+     if (n <= 0) return -len;  /* return amount left to write */
+     ptr += n;
+     len -= n;
+   }
+   return 0;
+}
+
+
+
+
+/*************************************************************************
+ *
+ * "Extra tags" handling
+ *
+ *************************************************************************/
+
+
+static char *y4m_new_xtag(void)
+{
+  return _y4m_alloc(Y4M_MAX_XTAG_SIZE * sizeof(char));
+}
+
+
+void y4m_init_xtag_list(y4m_xtag_list_t *xtags)
+{
+  int i;
+  xtags->count = 0;
+  for (i = 0; i < Y4M_MAX_XTAGS; i++) {
+    xtags->tags[i] = NULL;
+  }
+}
+
+
+void y4m_fini_xtag_list(y4m_xtag_list_t *xtags)
+{
+  int i;
+  for (i = 0; i < Y4M_MAX_XTAGS; i++) {
+    if (xtags->tags[i] != NULL) {
+      _y4m_free(xtags->tags[i]);
+      xtags->tags[i] = NULL;
+    }
+  }
+  xtags->count = 0;
+}
+
+
+void y4m_copy_xtag_list(y4m_xtag_list_t *dest, const y4m_xtag_list_t *src)
+{
+  int i;
+  for (i = 0; i < src->count; i++) {
+    if (dest->tags[i] == NULL) 
+      dest->tags[i] = y4m_new_xtag();
+    strncpy(dest->tags[i], src->tags[i], Y4M_MAX_XTAG_SIZE);
+  }
+  dest->count = src->count;
+}
+
+
+
+static int y4m_snprint_xtags(char *s, int maxn, const y4m_xtag_list_t *xtags)
+{
+  int i, room;
+  
+  for (i = 0, room = maxn - 1; i < xtags->count; i++) {
+    int n = snprintf(s, room + 1, " %s", xtags->tags[i]);
+    if ((n < 0) || (n > room)) return Y4M_ERR_HEADER;
+    s += n;
+    room -= n;
+  }
+  s[0] = '\n';  /* finish off header with newline */
+  s[1] = '\0';  /* ...and end-of-string           */
+  return Y4M_OK;
+}
+
+
+int y4m_xtag_count(const y4m_xtag_list_t *xtags)
+{
+  return xtags->count;
+}
+
+
+const char *y4m_xtag_get(const y4m_xtag_list_t *xtags, int n)
+{
+  if (n >= xtags->count)
+    return NULL;
+  else
+    return xtags->tags[n];
+}
+
+
+int y4m_xtag_add(y4m_xtag_list_t *xtags, const char *tag)
+{
+  if (xtags->count >= Y4M_MAX_XTAGS) return Y4M_ERR_XXTAGS;
+  if (xtags->tags[xtags->count] == NULL) 
+    xtags->tags[xtags->count] = y4m_new_xtag();
+  strncpy(xtags->tags[xtags->count], tag, Y4M_MAX_XTAG_SIZE);
+  (xtags->count)++;
+  return Y4M_OK;
+}
+
+
+int y4m_xtag_remove(y4m_xtag_list_t *xtags, int n)
+{
+  int i;
+  char *q;
+
+  if ((n < 0) || (n >= xtags->count)) return Y4M_ERR_RANGE;
+  q = xtags->tags[n];
+  for (i = n; i < (xtags->count - 1); i++)
+    xtags->tags[i] = xtags->tags[i+1];
+  xtags->tags[i] = q;
+  (xtags->count)--;
+  return Y4M_OK;
+}
+
+
+int y4m_xtag_clearlist(y4m_xtag_list_t *xtags)
+{
+  xtags->count = 0;
+  return Y4M_OK;
+}
+
+
+int y4m_xtag_addlist(y4m_xtag_list_t *dest, const y4m_xtag_list_t *src)
+{
+  int i, j;
+
+  if ((dest->count + src->count) > Y4M_MAX_XTAGS) return Y4M_ERR_XXTAGS;
+  for (i = dest->count, j = 0;
+       j < src->count;
+       i++, j++) {
+    if (dest->tags[i] == NULL) 
+      dest->tags[i] = y4m_new_xtag();
+    strncpy(dest->tags[i], src->tags[i], Y4M_MAX_XTAG_SIZE);
+  }
+  dest->count += src->count;
+  return Y4M_OK;
+}  
+
+
+/*************************************************************************
+ *
+ * Creators/destructors for y4m_*_info_t structures
+ *
+ *************************************************************************/
+
+
+void y4m_init_stream_info(y4m_stream_info_t *info)
+{
+  if (info == NULL) return;
+  /* init substructures */
+  y4m_init_xtag_list(&(info->x_tags));
+  /* set defaults */
+  y4m_clear_stream_info(info);
+}
+
+
+void y4m_clear_stream_info(y4m_stream_info_t *info)
+{
+  if (info == NULL) return;
+  /* clear/initialize info */
+  info->width = Y4M_UNKNOWN;
+  info->height = Y4M_UNKNOWN;
+  info->interlace = Y4M_UNKNOWN;
+  info->framerate = y4m_fps_UNKNOWN;
+  info->sampleaspect = y4m_sar_UNKNOWN;
+  if (_y4mparam_feature_level < 1) {
+    info->chroma = Y4M_CHROMA_420JPEG;
+  } else {
+    info->chroma = Y4M_UNKNOWN;
+  }
+  y4m_xtag_clearlist(&(info->x_tags));
+}
+
+
+void y4m_copy_stream_info(y4m_stream_info_t *dest,
+			  const y4m_stream_info_t *src)
+{
+  if ((dest == NULL) || (src == NULL)) return;
+  /* copy info */
+  dest->width = src->width;
+  dest->height = src->height;
+  dest->interlace = src->interlace;
+  dest->framerate = src->framerate;
+  dest->sampleaspect = src->sampleaspect;
+  dest->chroma = src->chroma;
+  y4m_copy_xtag_list(&(dest->x_tags), &(src->x_tags));
+}
+
+
+void y4m_fini_stream_info(y4m_stream_info_t *info)
+{
+  if (info == NULL) return;
+  y4m_fini_xtag_list(&(info->x_tags));
+}
+
+
+void y4m_si_set_width(y4m_stream_info_t *si, int width)
+{
+  si->width = width;
+}
+
+int y4m_si_get_width(const y4m_stream_info_t *si)
+{ return si->width; }
+
+void y4m_si_set_height(y4m_stream_info_t *si, int height)
+{
+  si->height = height; 
+}
+
+int y4m_si_get_height(const y4m_stream_info_t *si)
+{ return si->height; }
+
+void y4m_si_set_interlace(y4m_stream_info_t *si, int interlace)
+{ si->interlace = interlace; }
+
+int y4m_si_get_interlace(const y4m_stream_info_t *si)
+{ return si->interlace; }
+
+void y4m_si_set_framerate(y4m_stream_info_t *si, y4m_ratio_t framerate)
+{ si->framerate = framerate; }
+
+y4m_ratio_t y4m_si_get_framerate(const y4m_stream_info_t *si)
+{ return si->framerate; }
+
+void y4m_si_set_sampleaspect(y4m_stream_info_t *si, y4m_ratio_t sar)
+{ si->sampleaspect = sar; }
+
+y4m_ratio_t y4m_si_get_sampleaspect(const y4m_stream_info_t *si)
+{ return si->sampleaspect; }
+
+void y4m_si_set_chroma(y4m_stream_info_t *si, int chroma_mode)
+{ si->chroma = chroma_mode; }
+
+int y4m_si_get_chroma(const y4m_stream_info_t *si)
+{ return si->chroma; }
+
+
+int y4m_si_get_plane_count(const y4m_stream_info_t *si)
+{
+  switch (si->chroma) {
+  case Y4M_CHROMA_420JPEG:
+  case Y4M_CHROMA_420MPEG2:
+  case Y4M_CHROMA_420PALDV:
+  case Y4M_CHROMA_444:
+  case Y4M_CHROMA_422:
+  case Y4M_CHROMA_411:
+    return 3;
+  case Y4M_CHROMA_MONO:
+    return 1;
+  case Y4M_CHROMA_444ALPHA:
+    return 4;
+  default:
+    return Y4M_UNKNOWN;
+  }
+}
+
+int y4m_si_get_plane_width(const y4m_stream_info_t *si, int plane)
+{
+  switch (plane) {
+  case 0:
+    return (si->width);
+  case 1:
+  case 2:
+    switch (si->chroma) {
+    case Y4M_CHROMA_420JPEG: 
+    case Y4M_CHROMA_420MPEG2:
+    case Y4M_CHROMA_420PALDV:
+      return (si->width) / 2;
+    case Y4M_CHROMA_444:
+    case Y4M_CHROMA_444ALPHA:
+      return (si->width);
+    case Y4M_CHROMA_422:
+      return (si->width) / 2;
+    case Y4M_CHROMA_411:
+      return (si->width) / 4;
+    default:
+      return Y4M_UNKNOWN;
+    }
+  case 3:
+    switch (si->chroma) {
+    case Y4M_CHROMA_444ALPHA:
+      return (si->width);
+    default:
+      return Y4M_UNKNOWN;
+    }
+  default:
+    return Y4M_UNKNOWN;
+  }
+}
+
+int y4m_si_get_plane_height(const y4m_stream_info_t *si, int plane)
+{
+  switch (plane) {
+  case 0:
+    return (si->height);
+  case 1:
+  case 2:
+    switch (si->chroma) {
+    case Y4M_CHROMA_420JPEG: 
+    case Y4M_CHROMA_420MPEG2:
+    case Y4M_CHROMA_420PALDV:
+      return (si->height) / 2;
+    case Y4M_CHROMA_444:
+    case Y4M_CHROMA_444ALPHA:
+    case Y4M_CHROMA_422:
+    case Y4M_CHROMA_411:
+      return (si->height);
+    default:
+      return Y4M_UNKNOWN;
+    }
+  case 3:
+    switch (si->chroma) {
+    case Y4M_CHROMA_444ALPHA:
+      return (si->height);
+    default:
+      return Y4M_UNKNOWN;
+    }
+  default:
+    return Y4M_UNKNOWN;
+  }
+}
+
+int y4m_si_get_plane_length(const y4m_stream_info_t *si, int plane)
+{
+  int w = y4m_si_get_plane_width(si, plane);
+  int h = y4m_si_get_plane_height(si, plane);
+  if ((w != Y4M_UNKNOWN) && (h != Y4M_UNKNOWN))
+    return (w * h);
+  else
+    return Y4M_UNKNOWN;
+}
+
+int y4m_si_get_framelength(const y4m_stream_info_t *si)
+{
+  int total = 0;
+  int planes = y4m_si_get_plane_count(si);
+  int p;
+  for (p = 0; p < planes; p++) {
+    int plen = y4m_si_get_plane_length(si, p);
+    if (plen == Y4M_UNKNOWN) return Y4M_UNKNOWN;
+    total += plen;
+  }
+  return total;
+}
+
+
+y4m_xtag_list_t *y4m_si_xtags(y4m_stream_info_t *si)
+{ return &(si->x_tags); }
+
+
+
+void y4m_init_frame_info(y4m_frame_info_t *info)
+{
+  if (info == NULL) return;
+  /* init substructures */
+  y4m_init_xtag_list(&(info->x_tags));
+  /* set defaults */
+  y4m_clear_frame_info(info);
+}
+
+
+void y4m_clear_frame_info(y4m_frame_info_t *info)
+{
+  if (info == NULL) return;
+  /* clear/initialize info */
+  info->spatial = Y4M_UNKNOWN;
+  info->temporal = Y4M_UNKNOWN;
+  info->presentation = Y4M_UNKNOWN;
+  y4m_xtag_clearlist(&(info->x_tags));
+}
+
+
+void y4m_copy_frame_info(y4m_frame_info_t *dest, const y4m_frame_info_t *src)
+{
+  if ((dest == NULL) || (src == NULL)) return;
+  /* copy info */
+  dest->spatial = src->spatial;
+  dest->temporal = src->temporal;
+  dest->presentation = src->presentation;
+  y4m_copy_xtag_list(&(dest->x_tags), &(src->x_tags));
+}
+
+void y4m_fini_frame_info(y4m_frame_info_t *info)
+{
+  if (info == NULL) return;
+  y4m_fini_xtag_list(&(info->x_tags));
+}
+
+
+void y4m_fi_set_presentation(y4m_frame_info_t *fi, int pres)
+{ fi->presentation = pres; }
+
+int y4m_fi_get_presentation(const y4m_frame_info_t *fi)
+{ return fi->presentation; }
+
+void y4m_fi_set_temporal(y4m_frame_info_t *fi, int sampling)
+{ fi->temporal = sampling; }
+
+int y4m_fi_get_temporal(const y4m_frame_info_t *fi)
+{ return fi->temporal; }
+
+void y4m_fi_set_spatial(y4m_frame_info_t *fi, int sampling)
+{ fi->spatial = sampling; }
+
+int y4m_fi_get_spatial(const y4m_frame_info_t *fi)
+{ return fi->spatial; }
+
+
+
+y4m_xtag_list_t *y4m_fi_xtags(y4m_frame_info_t *fi)
+{ return &(fi->x_tags); }
+
+
+/*************************************************************************
+ *
+ * Tag parsing 
+ *
+ *************************************************************************/
+
+
+/* Parse (the first) old, unofficial X-tag chroma specification,
+   and then remove that tag from the X-tag list. */
+static int
+handle_old_chroma_xtag(y4m_stream_info_t *si)
+{
+  y4m_xtag_list_t *xtags = y4m_si_xtags(si);
+  const char *tag = NULL;
+  int n, chroma;
+
+  for (n = y4m_xtag_count(xtags) - 1; n >= 0; n--) {
+    tag = y4m_xtag_get(xtags, n);
+    if (!strncmp("XYSCSS=", tag, 7)) break;
+  }
+  if ((tag == NULL) || (n < 0)) return Y4M_UNKNOWN;
+  mjpeg_warn("Deprecated X-tag for chroma found in a stream header...");
+  mjpeg_warn("...pester someone to upgrade the source's program!");
+  /* parse the tag */
+  tag += 7;
+  if (!strcmp("411", tag))           chroma = Y4M_CHROMA_411;
+  else if (!strcmp(tag, "420"))      chroma = Y4M_CHROMA_420JPEG;
+  else if (!strcmp(tag, "420MPEG2")) chroma = Y4M_CHROMA_420MPEG2;
+  else if (!strcmp(tag, "420PALDV")) chroma = Y4M_CHROMA_420PALDV;
+  else if (!strcmp(tag, "420JPEG"))  chroma = Y4M_CHROMA_420JPEG;
+  else if (!strcmp(tag, "444"))      chroma = Y4M_CHROMA_444;
+  else chroma = Y4M_UNKNOWN;
+  /* Remove the 'X' tag so that no one has to worry about it any more. */
+  y4m_xtag_remove(xtags, n);
+  /* Hmm... what if there are more XYSCSS tags?  Broken is as broken does;
+     thank goodness this is temporary code. */
+  return chroma;
+}
+
+
+
+
+int y4m_parse_stream_tags(char *s, y4m_stream_info_t *i)
+{
+  char *token, *value;
+  char tag;
+  int err;
+
+  /* parse fields */
+  for (token = strtok(s, Y4M_DELIM); 
+       token != NULL; 
+       token = strtok(NULL, Y4M_DELIM)) {
+    if (token[0] == '\0') continue;   /* skip empty strings */
+    tag = token[0];
+    value = token + 1;
+    switch (tag) {
+    case 'W':  /* width */
+      i->width = atoi(value);
+      if (i->width <= 0) return Y4M_ERR_RANGE;
+      break;
+    case 'H':  /* height */
+      i->height = atoi(value); 
+      if (i->height <= 0) return Y4M_ERR_RANGE;
+      break;
+    case 'F':  /* frame rate (fps) */
+      if ((err = y4m_parse_ratio(&(i->framerate), value)) != Y4M_OK)
+	return err;
+      if (i->framerate.n < 0) return Y4M_ERR_RANGE;
+      break;
+    case 'I':  /* interlacing */
+      switch (value[0]) {
+      case 'p':  i->interlace = Y4M_ILACE_NONE; break;
+      case 't':  i->interlace = Y4M_ILACE_TOP_FIRST; break;
+      case 'b':  i->interlace = Y4M_ILACE_BOTTOM_FIRST; break;
+      case 'm':  i->interlace = Y4M_ILACE_MIXED; break;
+      case '?':
+      default:
+	i->interlace = Y4M_UNKNOWN; break;
+      }
+      break;
+    case 'A':  /* sample (pixel) aspect ratio */
+      if ((err = y4m_parse_ratio(&(i->sampleaspect), value)) != Y4M_OK)
+	return err;
+      if (i->sampleaspect.n < 0) return Y4M_ERR_RANGE;
+      break;
+    case 'C':
+      i->chroma = y4m_chroma_parse_keyword(value);
+      if (i->chroma == Y4M_UNKNOWN)
+	return Y4M_ERR_HEADER;
+      break;
+    case 'X':  /* 'X' meta-tag */
+      if ((err = y4m_xtag_add(&(i->x_tags), token)) != Y4M_OK) return err;
+      break;
+    default:
+      /* possible error on unknown options */
+      if (_y4mparam_allow_unknown_tags) {
+	/* unknown tags ok:  store in xtag list and warn... */
+	if ((err = y4m_xtag_add(&(i->x_tags), token)) != Y4M_OK) return err;
+	mjpeg_warn("Unknown stream tag encountered:  '%s'", token);
+      } else {
+	/* unknown tags are *not* ok */
+	return Y4M_ERR_BADTAG;
+      }
+      break;
+    }
+  }
+
+  /* If feature_level > 0, then handle and/or remove any old-style XYSCSS
+     chroma tags.  The new-style 'C' tag takes precedence, however. */
+  if (_y4mparam_feature_level > 0) {
+    int xt_chroma = handle_old_chroma_xtag(i);
+
+    if (i->chroma == Y4M_UNKNOWN)
+      i->chroma = xt_chroma;
+    else if ((xt_chroma != Y4M_UNKNOWN) &&
+             (xt_chroma != i->chroma))
+      mjpeg_warn("Old chroma X-tag (ignored) does not match new chroma tag.");
+  }
+
+  /* Without 'C' tag or any other chroma spec, default to 420jpeg */
+  if (i->chroma == Y4M_UNKNOWN) 
+    i->chroma = Y4M_CHROMA_420JPEG;
+
+  /* Error checking... */
+  /*      - Width and Height are required. */
+  if ((i->width == Y4M_UNKNOWN) || (i->height == Y4M_UNKNOWN))
+    return Y4M_ERR_HEADER;
+  /*      - Non-420 chroma and mixed interlace require level >= 1 */
+  if (_y4mparam_feature_level < 1) {
+    if ((i->chroma != Y4M_CHROMA_420JPEG) &&
+	(i->chroma != Y4M_CHROMA_420MPEG2) &&
+	(i->chroma != Y4M_CHROMA_420PALDV))
+      return Y4M_ERR_FEATURE;
+    if (i->interlace == Y4M_ILACE_MIXED)
+      return Y4M_ERR_FEATURE;
+  }
+
+  /* ta da!  done. */
+  return Y4M_OK;
+}
+
+
+
+static int y4m_parse_frame_tags(char *s, const y4m_stream_info_t *si,
+				y4m_frame_info_t *fi)
+{
+  char *token, *value;
+  char tag;
+  int err;
+
+  /* parse fields */
+  for (token = strtok(s, Y4M_DELIM); 
+       token != NULL; 
+       token = strtok(NULL, Y4M_DELIM)) {
+    if (token[0] == '\0') continue;   /* skip empty strings */
+    tag = token[0];
+    value = token + 1;
+    switch (tag) {
+    case 'I':
+      /* frame 'I' tag requires feature level >= 1 */
+      if (_y4mparam_feature_level < 1) return Y4M_ERR_FEATURE;
+      if (si->interlace != Y4M_ILACE_MIXED) return Y4M_ERR_BADTAG;
+      switch (value[0]) {
+      case 't':  fi->presentation = Y4M_PRESENT_TOP_FIRST;        break;
+      case 'T':  fi->presentation = Y4M_PRESENT_TOP_FIRST_RPT;    break;
+      case 'b':  fi->presentation = Y4M_PRESENT_BOTTOM_FIRST;     break;
+      case 'B':  fi->presentation = Y4M_PRESENT_BOTTOM_FIRST_RPT; break;
+      case '1':  fi->presentation = Y4M_PRESENT_PROG_SINGLE;      break;
+      case '2':  fi->presentation = Y4M_PRESENT_PROG_DOUBLE;      break;
+      case '3':  fi->presentation = Y4M_PRESENT_PROG_TRIPLE;      break;
+      default: 
+	return Y4M_ERR_BADTAG;
+      }
+      switch (value[1]) {
+      case 'p':  fi->temporal = Y4M_SAMPLING_PROGRESSIVE; break;
+      case 'i':  fi->temporal = Y4M_SAMPLING_INTERLACED;  break;
+      default: 
+	return Y4M_ERR_BADTAG;
+      }
+      switch (value[2]) {
+      case 'p':  fi->spatial = Y4M_SAMPLING_PROGRESSIVE; break;
+      case 'i':  fi->spatial = Y4M_SAMPLING_INTERLACED;  break;
+      case '?':  fi->spatial = Y4M_UNKNOWN;              break;
+      default: 
+	return Y4M_ERR_BADTAG;
+      }
+      break;
+    case 'X':  /* 'X' meta-tag */
+      if ((err = y4m_xtag_add(&(fi->x_tags), token)) != Y4M_OK) return err;
+      break;
+    default:
+      /* possible error on unknown options */
+      if (_y4mparam_allow_unknown_tags) {
+	/* unknown tags ok:  store in xtag list and warn... */
+	if ((err = y4m_xtag_add(&(fi->x_tags), token)) != Y4M_OK) return err;
+	mjpeg_warn("Unknown frame tag encountered:  '%s'", token);
+      } else {
+	/* unknown tags are *not* ok */
+	return Y4M_ERR_BADTAG;
+      }
+      break;
+    }
+  }
+  /* error-checking and/or non-mixed defaults */
+  switch (si->interlace) {
+  case Y4M_ILACE_MIXED:
+    /* T and P are required if stream "Im" */
+    if ((fi->presentation == Y4M_UNKNOWN) || (fi->temporal == Y4M_UNKNOWN))
+      return Y4M_ERR_HEADER;
+    /* and S is required if stream is also 4:2:0 */
+    if ( ((si->chroma == Y4M_CHROMA_420JPEG) ||
+          (si->chroma == Y4M_CHROMA_420MPEG2) ||
+          (si->chroma == Y4M_CHROMA_420PALDV)) &&
+         (fi->spatial == Y4M_UNKNOWN) )
+      return Y4M_ERR_HEADER;
+    break;
+  case Y4M_ILACE_NONE:
+    /* stream "Ip" --> equivalent to frame "I1pp" */
+    fi->spatial = Y4M_SAMPLING_PROGRESSIVE;
+    fi->temporal = Y4M_SAMPLING_PROGRESSIVE;
+    fi->presentation = Y4M_PRESENT_PROG_SINGLE;
+    break;
+  case Y4M_ILACE_TOP_FIRST:
+    /* stream "It" --> equivalent to frame "Itii" */
+    fi->spatial = Y4M_SAMPLING_INTERLACED;
+    fi->temporal = Y4M_SAMPLING_INTERLACED;
+    fi->presentation = Y4M_PRESENT_TOP_FIRST;
+    break;
+  case Y4M_ILACE_BOTTOM_FIRST:
+    /* stream "Ib" --> equivalent to frame "Ibii" */
+    fi->spatial = Y4M_SAMPLING_INTERLACED;
+    fi->temporal = Y4M_SAMPLING_INTERLACED;
+    fi->presentation = Y4M_PRESENT_BOTTOM_FIRST;
+    break;
+  default:
+    /* stream unknown:  then, whatever */
+    break;
+  }
+  /* ta da!  done. */
+  return Y4M_OK;
+}
+
+
+
+
+
+/*************************************************************************
+ *
+ * Read/Write stream header
+ *
+ *************************************************************************/
+
+
+int y4m_read_stream_header(int fd, y4m_stream_info_t *i)
+{
+   char line[Y4M_LINE_MAX];
+   char *p;
+   int n;
+   int err;
+
+  /* start with a clean slate */
+  y4m_clear_stream_info(i);
+   /* read the header line */
+   for (n = 0, p = line; n < Y4M_LINE_MAX; n++, p++) {
+     if (read(fd, p, 1) < 1) 
+       return Y4M_ERR_SYSTEM;
+     if (*p == '\n') {
+       *p = '\0';           /* Replace linefeed by end of string */
+       break;
+     }
+   }
+   if (n >= Y4M_LINE_MAX)
+      return Y4M_ERR_HEADER;
+   /* look for keyword in header */
+   if (strncmp(line, Y4M_MAGIC, strlen(Y4M_MAGIC)))
+    return Y4M_ERR_MAGIC;
+   if ((err = y4m_parse_stream_tags(line + strlen(Y4M_MAGIC), i)) != Y4M_OK)
+     return err;
+
+   return Y4M_OK;
+}
+
+
+
+int y4m_write_stream_header(int fd, const y4m_stream_info_t *i)
+{
+  char s[Y4M_LINE_MAX+1];
+  int n;
+  int err;
+  y4m_ratio_t rate = i->framerate;
+  y4m_ratio_t aspect = i->sampleaspect;
+  const char *chroma_keyword = y4m_chroma_keyword(i->chroma);
+
+  if ((i->chroma == Y4M_UNKNOWN) || (chroma_keyword == NULL))
+    return Y4M_ERR_HEADER;
+  if (_y4mparam_feature_level < 1) {
+    if ((i->chroma != Y4M_CHROMA_420JPEG) &&
+	(i->chroma != Y4M_CHROMA_420MPEG2) &&
+	(i->chroma != Y4M_CHROMA_420PALDV))
+      return Y4M_ERR_FEATURE;
+    if (i->interlace == Y4M_ILACE_MIXED)
+      return Y4M_ERR_FEATURE;
+  }
+  y4m_ratio_reduce(&rate);
+  y4m_ratio_reduce(&aspect);
+  n = snprintf(s, sizeof(s), "%s W%d H%d F%d:%d I%s A%d:%d C%s",
+	       Y4M_MAGIC,
+	       i->width,
+	       i->height,
+	       rate.n, rate.d,
+	       (i->interlace == Y4M_ILACE_NONE) ? "p" :
+	       (i->interlace == Y4M_ILACE_TOP_FIRST) ? "t" :
+	       (i->interlace == Y4M_ILACE_BOTTOM_FIRST) ? "b" :
+	       (i->interlace == Y4M_ILACE_MIXED) ? "m" : "?",
+	       aspect.n, aspect.d,
+	       chroma_keyword
+	       );
+  if ((n < 0) || (n > Y4M_LINE_MAX)) return Y4M_ERR_HEADER;
+  if ((err = y4m_snprint_xtags(s + n, sizeof(s) - n - 1, &(i->x_tags))) 
+      != Y4M_OK) 
+    return err;
+  /* non-zero on error */
+  return (y4m_write(fd, s, strlen(s)) ? Y4M_ERR_SYSTEM : Y4M_OK);
+}
+
+
+
+
+
+/*************************************************************************
+ *
+ * Read/Write frame header
+ *
+ *************************************************************************/
+
+int y4m_read_frame_header(int fd,
+			  const y4m_stream_info_t *si,
+			  y4m_frame_info_t *fi)
+{
+  char line[Y4M_LINE_MAX];
+  char *p;
+  int n;
+  ssize_t remain;
+  
+  /* start with a clean slate */
+  y4m_clear_frame_info(fi);
+  /* This is more clever than read_stream_header...
+     Try to read "FRAME\n" all at once, and don't try to parse
+     if nothing else is there...
+  */
+  remain = y4m_read(fd, line, sizeof(Y4M_FRAME_MAGIC)-1+1); /* -'\0', +'\n' */
+  if (remain < 0) return Y4M_ERR_SYSTEM;
+  if (remain > 0) {
+    /* A clean EOF should end exactly at a frame-boundary */
+    if (remain == sizeof(Y4M_FRAME_MAGIC))
+      return Y4M_ERR_EOF;
+    else
+      return Y4M_ERR_BADEOF;
+  }
+  if (strncmp(line, Y4M_FRAME_MAGIC, sizeof(Y4M_FRAME_MAGIC)-1))
+    return Y4M_ERR_MAGIC;
+  if (line[sizeof(Y4M_FRAME_MAGIC)-1] == '\n')
+    return Y4M_OK; /* done -- no tags:  that was the end-of-line. */
+
+  if (line[sizeof(Y4M_FRAME_MAGIC)-1] != Y4M_DELIM[0]) {
+    return Y4M_ERR_MAGIC; /* wasn't a space -- what was it? */
+  }
+
+  /* proceed to get the tags... (overwrite the magic) */
+  for (n = 0, p = line; n < Y4M_LINE_MAX; n++, p++) {
+    if (y4m_read(fd, p, 1))
+      return Y4M_ERR_SYSTEM;
+    if (*p == '\n') {
+      *p = '\0';           /* Replace linefeed by end of string */
+      break;
+    }
+  }
+  if (n >= Y4M_LINE_MAX) return Y4M_ERR_HEADER;
+  /* non-zero on error */
+  return y4m_parse_frame_tags(line, si, fi);
+}
+
+
+int y4m_write_frame_header(int fd,
+			   const y4m_stream_info_t *si,
+			   const y4m_frame_info_t *fi)
+{
+  char s[Y4M_LINE_MAX+1];
+  int n, err;
+
+  if (si->interlace == Y4M_ILACE_MIXED) {
+    if (_y4mparam_feature_level < 1) return Y4M_ERR_FEATURE;
+    n = snprintf(s, sizeof(s), "%s I%c%c%c", Y4M_FRAME_MAGIC,
+		 (fi->presentation == Y4M_PRESENT_TOP_FIRST)        ? 't' :
+		 (fi->presentation == Y4M_PRESENT_TOP_FIRST_RPT)    ? 'T' :
+		 (fi->presentation == Y4M_PRESENT_BOTTOM_FIRST)     ? 'b' :
+		 (fi->presentation == Y4M_PRESENT_BOTTOM_FIRST_RPT) ? 'B' :
+		 (fi->presentation == Y4M_PRESENT_PROG_SINGLE) ? '1' :
+		 (fi->presentation == Y4M_PRESENT_PROG_DOUBLE) ? '2' :
+		 (fi->presentation == Y4M_PRESENT_PROG_TRIPLE) ? '3' :
+		 '?',
+		 (fi->temporal == Y4M_SAMPLING_PROGRESSIVE) ? 'p' :
+		 (fi->temporal == Y4M_SAMPLING_INTERLACED)  ? 'i' :
+		 '?',
+		 (fi->spatial == Y4M_SAMPLING_PROGRESSIVE) ? 'p' :
+		 (fi->spatial == Y4M_SAMPLING_INTERLACED)  ? 'i' :
+		 '?'
+		 );
+  } else {
+    n = snprintf(s, sizeof(s), "%s", Y4M_FRAME_MAGIC);
+  }
+  
+  if ((n < 0) || (n > Y4M_LINE_MAX)) return Y4M_ERR_HEADER;
+  if ((err = y4m_snprint_xtags(s + n, sizeof(s) - n - 1, &(fi->x_tags))) 
+      != Y4M_OK) 
+    return err;
+  /* non-zero on error */
+  return (y4m_write(fd, s, strlen(s)) ? Y4M_ERR_SYSTEM : Y4M_OK);
+}
+
+
+
+/*************************************************************************
+ *
+ * Read/Write entire frame
+ *
+ *************************************************************************/
+
+int y4m_read_frame_data(int fd, const y4m_stream_info_t *si, 
+                        y4m_frame_info_t *fi, uint8_t * const *frame)
+{
+  int planes = y4m_si_get_plane_count(si);
+  int p;
+  
+  /* Read each plane */
+  for (p = 0; p < planes; p++) {
+    int w = y4m_si_get_plane_width(si, p);
+    int h = y4m_si_get_plane_height(si, p);
+    if (y4m_read(fd, frame[p], w*h)) return Y4M_ERR_SYSTEM;
+  }
+  return Y4M_OK;
+}
+
+
+
+int y4m_read_frame(int fd, const y4m_stream_info_t *si, 
+		   y4m_frame_info_t *fi, uint8_t * const *frame)
+{
+  int err;
+  
+  /* Read frame header */
+  if ((err = y4m_read_frame_header(fd, si, fi)) != Y4M_OK) return err;
+  /* Read date */
+  return y4m_read_frame_data(fd, si, fi, frame);
+}
+
+
+
+
+int y4m_write_frame(int fd, const y4m_stream_info_t *si, 
+		    const y4m_frame_info_t *fi, uint8_t * const *frame)
+{
+  int planes = y4m_si_get_plane_count(si);
+  int err, p;
+
+  /* Write frame header */
+  if ((err = y4m_write_frame_header(fd, si, fi)) != Y4M_OK) return err;
+  /* Write each plane */
+  for (p = 0; p < planes; p++) {
+    int w = y4m_si_get_plane_width(si, p);
+    int h = y4m_si_get_plane_height(si, p);
+    if (y4m_write(fd, frame[p], w*h)) return Y4M_ERR_SYSTEM;
+  }
+  return Y4M_OK;
+}
+
+
+
+/*************************************************************************
+ *
+ * Read/Write entire frame, (de)interleaved (to)from two separate fields
+ *
+ *************************************************************************/
+
+
+int y4m_read_fields_data(int fd, const y4m_stream_info_t *si,
+                         y4m_frame_info_t *fi,
+                         uint8_t * const *upper_field, 
+                         uint8_t * const *lower_field)
+{
+  int p;
+  int planes = y4m_si_get_plane_count(si);
+  const int maxrbuf=32*1024;
+  uint8_t *rbuf=_y4m_alloc(maxrbuf);
+  int rbufpos=0,rbuflen=0;
+  
+  /* Read each plane */
+  for (p = 0; p < planes; p++) {
+    uint8_t *dsttop = upper_field[p];
+    uint8_t *dstbot = lower_field[p];
+    int height = y4m_si_get_plane_height(si, p);
+    int width = y4m_si_get_plane_width(si, p);
+    int y;
+    /* alternately read one line into each field */
+    for (y = 0; y < height; y += 2) {
+      if( width*2 >= maxrbuf ) {
+        if (y4m_read(fd, dsttop, width)) goto y4merr;
+        if (y4m_read(fd, dstbot, width)) goto y4merr;
+      } else {
+        if( rbufpos==rbuflen ) {
+          rbuflen=(height-y)*width;
+          if( rbuflen>maxrbuf )
+            rbuflen=maxrbuf-maxrbuf%(2*width);
+          if( y4m_read(fd,rbuf,rbuflen) )
+            goto y4merr;
+          rbufpos=0;
+        }
+            
+        memcpy(dsttop,rbuf+rbufpos,width); rbufpos+=width;
+        memcpy(dstbot,rbuf+rbufpos,width); rbufpos+=width;
+      }
+      dsttop+=width;
+      dstbot+=width;
+    }
+  }
+  _y4m_free(rbuf);
+  return Y4M_OK;
+
+ y4merr:
+  _y4m_free(rbuf);
+  return Y4M_ERR_SYSTEM;
+}
+
+
+int y4m_read_fields(int fd, const y4m_stream_info_t *si, y4m_frame_info_t *fi,
+                    uint8_t * const *upper_field, 
+                    uint8_t * const *lower_field)
+{
+  int err;
+  /* Read frame header */
+  if ((err = y4m_read_frame_header(fd, si, fi)) != Y4M_OK) return err;
+  /* Read data */
+  return y4m_read_fields_data(fd, si, fi, upper_field, lower_field);
+}
+
+
+
+int y4m_write_fields(int fd, const y4m_stream_info_t *si,
+		     const y4m_frame_info_t *fi,
+		     uint8_t * const *upper_field, 
+		     uint8_t * const *lower_field)
+{
+  int p, err;
+  int planes = y4m_si_get_plane_count(si);
+  int numwbuf=0;
+  const int maxwbuf=32*1024;
+  uint8_t *wbuf;
+  
+  /* Write frame header */
+  if ((err = y4m_write_frame_header(fd, si, fi)) != Y4M_OK) return err;
+  /* Write each plane */
+  wbuf=_y4m_alloc(maxwbuf);
+  for (p = 0; p < planes; p++) {
+    uint8_t *srctop = upper_field[p];
+    uint8_t *srcbot = lower_field[p];
+    int height = y4m_si_get_plane_height(si, p);
+    int width = y4m_si_get_plane_width(si, p);
+    int y;
+    /* alternately write one line from each field */
+    for (y = 0; y < height; y += 2) {
+      if( width*2 >= maxwbuf ) {
+        if (y4m_write(fd, srctop, width)) goto y4merr;
+        if (y4m_write(fd, srcbot, width)) goto y4merr;
+      } else {
+        if (numwbuf + 2 * width > maxwbuf) {
+          if(y4m_write(fd, wbuf, numwbuf)) goto y4merr;
+          numwbuf=0;
+        }
+
+        memcpy(wbuf+numwbuf,srctop,width); numwbuf += width;
+        memcpy(wbuf+numwbuf,srcbot,width); numwbuf += width;
+      }
+      srctop  += width;
+      srcbot  += width;
+    }
+  }
+  if( numwbuf )
+    if( y4m_write(fd, wbuf, numwbuf) )
+      goto y4merr;
+  _y4m_free(wbuf);
+  return Y4M_OK;
+
+ y4merr:
+  _y4m_free(wbuf);
+  return Y4M_ERR_SYSTEM;
+}
+
+
+/*************************************************************************
+ *
+ * Handy logging of stream info
+ *
+ *************************************************************************/
+
+void y4m_log_stream_info(log_level_t level, const char *prefix,
+			 const y4m_stream_info_t *i)
+{
+  char s[256];
+
+  snprintf(s, sizeof(s), "  frame size:  ");
+  if (i->width == Y4M_UNKNOWN)
+    snprintf(s+strlen(s), sizeof(s)-strlen(s), "(?)x");
+  else
+    snprintf(s+strlen(s), sizeof(s)-strlen(s), "%dx", i->width);
+  if (i->height == Y4M_UNKNOWN)
+    snprintf(s+strlen(s), sizeof(s)-strlen(s), "(?) pixels ");
+  else
+    snprintf(s+strlen(s), sizeof(s)-strlen(s), "%d pixels ", i->height);
+  {
+    int framelength = y4m_si_get_framelength(i);
+    if (framelength == Y4M_UNKNOWN)
+      snprintf(s+strlen(s), sizeof(s)-strlen(s), "(? bytes)");
+    else
+      snprintf(s+strlen(s), sizeof(s)-strlen(s), "(%d bytes)", framelength);
+    mjpeg_log(level, "%s%s", prefix, s);
+  }
+  {
+    const char *desc = y4m_chroma_description(i->chroma);
+    if (desc == NULL) desc = "unknown!";
+    mjpeg_log(level, "%s      chroma:  %s", prefix, desc);
+  }
+  if ((i->framerate.n == 0) && (i->framerate.d == 0))
+    mjpeg_log(level, "%s  frame rate:  ??? fps", prefix);
+  else
+    mjpeg_log(level, "%s  frame rate:  %d/%d fps (~%f)", prefix,
+	      i->framerate.n, i->framerate.d, 
+	      (double) i->framerate.n / (double) i->framerate.d);
+  mjpeg_log(level, "%s   interlace:  %s", prefix,
+	  (i->interlace == Y4M_ILACE_NONE) ? "none/progressive" :
+	  (i->interlace == Y4M_ILACE_TOP_FIRST) ? "top-field-first" :
+	  (i->interlace == Y4M_ILACE_BOTTOM_FIRST) ? "bottom-field-first" :
+	  (i->interlace == Y4M_ILACE_MIXED) ? "mixed-mode" :
+	  "anyone's guess");
+  if ((i->sampleaspect.n == 0) && (i->sampleaspect.d == 0))
+    mjpeg_log(level, "%ssample aspect ratio:  ?:?", prefix);
+  else
+    mjpeg_log(level, "%ssample aspect ratio:  %d:%d", prefix,
+	      i->sampleaspect.n, i->sampleaspect.d);
+}
+
+
+/*************************************************************************
+ *
+ * Convert error code to string
+ *
+ *************************************************************************/
+
+const char *y4m_strerr(int err)
+{
+  switch (err) {
+  case Y4M_OK:          return "no error";
+  case Y4M_ERR_RANGE:   return "parameter out of range";
+  case Y4M_ERR_SYSTEM:  return "system error (failed read/write)";
+  case Y4M_ERR_HEADER:  return "bad stream or frame header";
+  case Y4M_ERR_BADTAG:  return "unknown header tag";
+  case Y4M_ERR_MAGIC:   return "bad header magic";
+  case Y4M_ERR_XXTAGS:  return "too many xtags";
+  case Y4M_ERR_EOF:     return "end-of-file";
+  case Y4M_ERR_BADEOF:  return "stream ended unexpectedly (EOF)";
+  case Y4M_ERR_FEATURE: return "stream requires unsupported features";
+  default: 
+    return "unknown error code";
+  }
+}
+
+
+/*************************************************************************
+ *
+ * Chroma subsampling stuff
+ *
+ *************************************************************************/
+
+y4m_ratio_t y4m_chroma_ss_x_ratio(int chroma_mode)
+{
+  y4m_ratio_t r;
+  switch (chroma_mode) {
+  case Y4M_CHROMA_444ALPHA:
+  case Y4M_CHROMA_444:
+  case Y4M_CHROMA_MONO:
+    r.n = 1; r.d = 1; break;
+  case Y4M_CHROMA_420JPEG:
+  case Y4M_CHROMA_420MPEG2:
+  case Y4M_CHROMA_420PALDV:
+  case Y4M_CHROMA_422:
+    r.n = 1; r.d = 2; break;
+  case Y4M_CHROMA_411:
+    r.n = 1; r.d = 4; break;
+  default:
+    r.n = 0; r.d = 0;
+  }
+  return r;
+}
+
+y4m_ratio_t y4m_chroma_ss_y_ratio(int chroma_mode)
+{
+  y4m_ratio_t r;
+  switch (chroma_mode) {
+  case Y4M_CHROMA_444ALPHA:
+  case Y4M_CHROMA_444:
+  case Y4M_CHROMA_MONO:
+  case Y4M_CHROMA_422:
+  case Y4M_CHROMA_411:
+    r.n = 1; r.d = 1; break;
+  case Y4M_CHROMA_420JPEG:
+  case Y4M_CHROMA_420MPEG2:
+  case Y4M_CHROMA_420PALDV:
+    r.n = 1; r.d = 2; break;
+  default:
+    r.n = 0; r.d = 0;
+  }
+  return r;
+}
+
+
+#if 0  /* unfinished work here */
+y4m_ratio_t y4m_chroma_ss_x_offset(int chroma_mode, int field, int plane)
+{
+  y4m_ratio_t r;
+  switch (chroma_mode) {
+  case Y4M_CHROMA_444ALPHA:
+  case Y4M_CHROMA_444:
+  case Y4M_CHROMA_MONO:
+  case Y4M_CHROMA_422:
+  case Y4M_CHROMA_411:
+    r.n = 0; r.d = 1; break;
+  case Y4M_CHROMA_420JPEG:
+  case Y4M_CHROMA_420MPEG2:
+  case Y4M_CHROMA_420PALDV:
+    r.n = 1; r.d = 2; break;
+  default:
+    r.n = 0; r.d = 0;
+  }
+  return r;
+}
+
+y4m_ratio_t y4m_chroma_ss_y_offset(int chroma_mode, int field, int plane);
+{
+  y4m_ratio_t r;
+  switch (chroma_mode) {
+  case Y4M_CHROMA_444ALPHA:
+  case Y4M_CHROMA_444:
+  case Y4M_CHROMA_MONO:
+  case Y4M_CHROMA_422:
+  case Y4M_CHROMA_411:
+    r.n = 0; r.d = 1; break;
+  case Y4M_CHROMA_420JPEG:
+  case Y4M_CHROMA_420MPEG2:
+  case Y4M_CHROMA_420PALDV:
+    r.n = 1; r.d = 2; break;
+  default:
+    r.n = 0; r.d = 0;
+  }
+  return r;
+}
+#endif
+
+
+
+int y4m_chroma_parse_keyword(const char *s)
+{
+  if (!strcasecmp("420jpeg", s))
+    return Y4M_CHROMA_420JPEG;
+  else if (!strcasecmp("420mpeg2", s))
+    return Y4M_CHROMA_420MPEG2;
+  else if (!strcasecmp("420paldv", s))
+    return Y4M_CHROMA_420PALDV;
+  else if (!strcasecmp("444", s))
+    return Y4M_CHROMA_444;
+  else if (!strcasecmp("422", s))
+    return Y4M_CHROMA_422;
+  else if (!strcasecmp("411", s))
+    return Y4M_CHROMA_411;
+  else if (!strcasecmp("mono", s))
+    return Y4M_CHROMA_MONO;
+  else if (!strcasecmp("444alpha", s))
+    return Y4M_CHROMA_444ALPHA;
+  else
+    return Y4M_UNKNOWN;
+}
+
+
+const char *y4m_chroma_keyword(int chroma_mode)
+{
+  switch (chroma_mode) {
+  case Y4M_CHROMA_420JPEG:  return "420jpeg";
+  case Y4M_CHROMA_420MPEG2: return "420mpeg2";
+  case Y4M_CHROMA_420PALDV: return "420paldv";
+  case Y4M_CHROMA_444:      return "444";
+  case Y4M_CHROMA_422:      return "422";
+  case Y4M_CHROMA_411:      return "411";
+  case Y4M_CHROMA_MONO:     return "mono";
+  case Y4M_CHROMA_444ALPHA: return "444alpha";
+  default:
+    return NULL;
+  }
+}  
+
+
+const char *y4m_chroma_description(int chroma_mode)
+{           
+  switch (chroma_mode) {
+  case Y4M_CHROMA_420JPEG:  return "4:2:0 JPEG/MPEG-1 (interstitial)";
+  case Y4M_CHROMA_420MPEG2: return "4:2:0 MPEG-2 (horiz. cositing)";
+  case Y4M_CHROMA_420PALDV: return "4:2:0 PAL-DV (altern. siting)";
+  case Y4M_CHROMA_444:      return "4:4:4 (no subsampling)";
+  case Y4M_CHROMA_422:      return "4:2:2 (horiz. cositing)";
+  case Y4M_CHROMA_411:      return "4:1:1 (horiz. cositing)";
+  case Y4M_CHROMA_MONO:     return "luma plane only";
+  case Y4M_CHROMA_444ALPHA: return "4:4:4 with alpha channel";
+  default:
+    return NULL;
+  }
+}

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/yuv4mpeg.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/yuv4mpeg.h	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/yuv4mpeg.h	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,666 @@
+/*
+ *  yuv4mpeg.h:  Functions for reading and writing "new" YUV4MPEG2 streams.
+ *
+ *               Stream format is described at the end of this file.
+ *
+ *
+ *  Copyright (C) 2004 Matthew J. Marjanovic <maddog at mir.com>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version 2
+ *  of the License, or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#ifndef __YUV4MPEG_H__
+#define __YUV4MPEG_H__
+
+#include <stdlib.h>
+#include <mjpeg_types.h>
+#ifndef _WIN32
+#include <unistd.h>
+#endif
+#include <mjpeg_logging.h>
+
+
+/************************************************************************
+ *  error codes returned by y4m_* functions
+ ************************************************************************/
+#define Y4M_OK          0
+#define Y4M_ERR_RANGE   1  /* argument or tag value out of range */
+#define Y4M_ERR_SYSTEM  2  /* failed system call, check errno */
+#define Y4M_ERR_HEADER  3  /* illegal/malformed header */
+#define Y4M_ERR_BADTAG  4  /* illegal tag character */
+#define Y4M_ERR_MAGIC   5  /* bad header magic */
+#define Y4M_ERR_EOF     6  /* end-of-file (clean) */
+#define Y4M_ERR_XXTAGS  7  /* too many xtags */
+#define Y4M_ERR_BADEOF  8  /* unexpected end-of-file */
+#define Y4M_ERR_FEATURE 9  /* stream requires features beyond allowed level */
+
+
+/* generic 'unknown' value for integer parameters (e.g. interlace, height) */
+#define Y4M_UNKNOWN -1
+
+/************************************************************************
+ * values for the "interlace" parameter [y4m_*_interlace()]
+ ************************************************************************/
+#define Y4M_ILACE_NONE          0   /* non-interlaced, progressive frame */
+#define Y4M_ILACE_TOP_FIRST     1   /* interlaced, top-field first       */
+#define Y4M_ILACE_BOTTOM_FIRST  2   /* interlaced, bottom-field first    */
+#define Y4M_ILACE_MIXED         3   /* mixed, "refer to frame header"    */
+
+/************************************************************************
+ * values for the "chroma" parameter [y4m_*_chroma()]
+ ************************************************************************/
+#define Y4M_CHROMA_420JPEG     0  /* 4:2:0, H/V centered, for JPEG/MPEG-1 */
+#define Y4M_CHROMA_420MPEG2    1  /* 4:2:0, H cosited, for MPEG-2         */
+#define Y4M_CHROMA_420PALDV    2  /* 4:2:0, alternating Cb/Cr, for PAL-DV */
+#define Y4M_CHROMA_444         3  /* 4:4:4, no subsampling, phew.         */
+#define Y4M_CHROMA_422         4  /* 4:2:2, H cosited                     */
+#define Y4M_CHROMA_411         5  /* 4:1:1, H cosited                     */
+#define Y4M_CHROMA_MONO        6  /* luma plane only                      */
+#define Y4M_CHROMA_444ALPHA    7  /* 4:4:4 with an alpha channel          */
+
+/************************************************************************
+ * values for sampling parameters [y4m_*_spatial(), y4m_*_temporal()]
+ ************************************************************************/
+#define Y4M_SAMPLING_PROGRESSIVE 0
+#define Y4M_SAMPLING_INTERLACED  1
+
+/************************************************************************
+ * values for "presentation" parameter [y4m_*_presentation()]
+ ************************************************************************/
+#define Y4M_PRESENT_TOP_FIRST         0  /* top-field-first                 */
+#define Y4M_PRESENT_TOP_FIRST_RPT     1  /* top-first, repeat top           */
+#define Y4M_PRESENT_BOTTOM_FIRST      2  /* bottom-field-first              */
+#define Y4M_PRESENT_BOTTOM_FIRST_RPT  3  /* bottom-first, repeat bottom     */
+#define Y4M_PRESENT_PROG_SINGLE       4  /* single progressive frame        */
+#define Y4M_PRESENT_PROG_DOUBLE       5  /* progressive frame, repeat once  */
+#define Y4M_PRESENT_PROG_TRIPLE       6  /* progressive frame, repeat twice */
+
+#define Y4M_MAX_NUM_PLANES 4
+
+/************************************************************************
+ *  'ratio' datatype, for rational numbers
+ *                                     (see 'ratio' functions down below)
+ ************************************************************************/
+typedef struct _y4m_ratio {
+  int n;  /* numerator   */
+  int d;  /* denominator */
+} y4m_ratio_t;
+
+
+/************************************************************************
+ *  useful standard framerates (as ratios)
+ ************************************************************************/
+extern const y4m_ratio_t y4m_fps_UNKNOWN;
+extern const y4m_ratio_t y4m_fps_NTSC_FILM;  /* 24000/1001 film (in NTSC)  */
+extern const y4m_ratio_t y4m_fps_FILM;       /* 24fps film                 */
+extern const y4m_ratio_t y4m_fps_PAL;        /* 25fps PAL                  */
+extern const y4m_ratio_t y4m_fps_NTSC;       /* 30000/1001 NTSC            */
+extern const y4m_ratio_t y4m_fps_30;         /* 30fps                      */
+extern const y4m_ratio_t y4m_fps_PAL_FIELD;  /* 50fps PAL field rate       */
+extern const y4m_ratio_t y4m_fps_NTSC_FIELD; /* 60000/1001 NTSC field rate */
+extern const y4m_ratio_t y4m_fps_60;         /* 60fps                      */
+
+/************************************************************************
+ *  useful standard sample (pixel) aspect ratios (W:H)
+ ************************************************************************/
+extern const y4m_ratio_t y4m_sar_UNKNOWN; 
+extern const y4m_ratio_t y4m_sar_SQUARE;        /* square pixels */
+extern const y4m_ratio_t y4m_sar_NTSC_CCIR601;  /* 525-line (NTSC) Rec.601 */
+extern const y4m_ratio_t y4m_sar_NTSC_16_9;     /* 16:9 NTSC/Rec.601       */
+extern const y4m_ratio_t y4m_sar_NTSC_SVCD_4_3; /* NTSC SVCD 4:3           */
+extern const y4m_ratio_t y4m_sar_NTSC_SVCD_16_9;/* NTSC SVCD 16:9          */
+extern const y4m_ratio_t y4m_sar_PAL_CCIR601;   /* 625-line (PAL) Rec.601  */
+extern const y4m_ratio_t y4m_sar_PAL_16_9;      /* 16:9 PAL/Rec.601        */
+extern const y4m_ratio_t y4m_sar_PAL_SVCD_4_3;  /* PAL SVCD 4:3            */
+extern const y4m_ratio_t y4m_sar_PAL_SVCD_16_9; /* PAL SVCD 16:9           */
+extern const y4m_ratio_t y4m_sar_SQR_ANA16_9;   /* anamorphic 16:9 sampled */
+                                            /* from 4:3 with square pixels */
+
+/************************************************************************
+ *  useful standard display aspect ratios (W:H)
+ ************************************************************************/
+extern const y4m_ratio_t y4m_dar_UNKNOWN; 
+extern const y4m_ratio_t y4m_dar_4_3;     /* standard TV   */
+extern const y4m_ratio_t y4m_dar_16_9;    /* widescreen TV */
+extern const y4m_ratio_t y4m_dar_221_100; /* word-to-your-mother TV */
+
+
+#define Y4M_MAX_XTAGS 32        /* maximum number of xtags in list       */
+#define Y4M_MAX_XTAG_SIZE 32    /* max length of an xtag (including 'X') */
+
+typedef struct _y4m_xtag_list y4m_xtag_list_t;
+typedef struct _y4m_stream_info y4m_stream_info_t;
+typedef struct _y4m_frame_info y4m_frame_info_t;
+
+
+#ifdef __cplusplus
+#define BEGIN_CDECLS extern "C" {
+#define END_CDECLS   }
+#else
+#define BEGIN_CDECLS 
+#define END_CDECLS   
+#endif
+
+BEGIN_CDECLS
+
+/************************************************************************
+ *  'ratio' functions
+ ************************************************************************/
+
+/* 'normalize' a ratio (remove common factors) */
+void y4m_ratio_reduce(y4m_ratio_t *r);
+
+/* parse "nnn:ddd" into a ratio (returns Y4M_OK or Y4M_ERR_RANGE) */
+int y4m_parse_ratio(y4m_ratio_t *r, const char *s);
+
+/* quick test of two ratios for equality (i.e. identical components) */
+#define Y4M_RATIO_EQL(a,b) ( ((a).n == (b).n) && ((a).d == (b).d) )
+
+/* quick conversion of a ratio to a double (no divide-by-zero check!) */
+#define Y4M_RATIO_DBL(r) ((double)(r).n / (double)(r).d)
+
+/*************************************************************************
+ *
+ * Guess the true SAR (sample aspect ratio) from a list of commonly 
+ * encountered values, given the "suggested" display aspect ratio (DAR),
+ * and the true frame width and height.
+ *
+ * Returns y4m_sar_UNKNOWN if no match is found.
+ *
+ *************************************************************************/
+y4m_ratio_t y4m_guess_sar(int width, int height, y4m_ratio_t dar);
+
+
+/*************************************************************************
+ *
+ * Chroma Subsampling Mode information
+ *
+ *  x_ratio, y_ratio  -  subsampling of chroma planes
+ *  x_offset, y_offset - offset of chroma sample grid,
+ *                        relative to luma (0,0) sample
+ *
+ *************************************************************************/
+
+y4m_ratio_t y4m_chroma_ss_x_ratio(int chroma_mode);
+y4m_ratio_t y4m_chroma_ss_y_ratio(int chroma_mode);
+#if 0
+y4m_ratio_t y4m_chroma_ss_x_offset(int chroma_mode, int field, int plane);
+y4m_ratio_t y4m_chroma_ss_y_offset(int chroma_mode, int field, int plane);
+#endif
+
+/* Given a string containing a (case-insensitive) chroma-tag keyword,
+   return appropriate chroma mode (or Y4M_UNKNOWN) */
+int y4m_chroma_parse_keyword(const char *s);
+
+/* Given a Y4M_CHROMA_* mode, return appropriate chroma-tag keyword,
+   or NULL if there is none. */
+const char *y4m_chroma_keyword(int chroma_mode);
+
+/* Given a Y4M_CHROMA_* mode, return appropriate chroma mode description,
+   or NULL if there is none. */
+const char *y4m_chroma_description(int chroma_mode);
+
+
+
+/************************************************************************
+ *  'xtag' functions
+ *
+ * o Before using an xtag_list (but after the structure/memory has been
+ *    allocated), you must initialize it via y4m_init_xtag_list().
+ * o After using an xtag_list (but before the structure is released),
+ *    call y4m_fini_xtag_list() to free internal memory.
+ *
+ ************************************************************************/
+
+/* initialize an xtag_list structure */
+void y4m_init_xtag_list(y4m_xtag_list_t *xtags);
+
+/* finalize an xtag_list structure */
+void y4m_fini_xtag_list(y4m_xtag_list_t *xtags);
+
+/* make one xtag_list into a copy of another */
+void y4m_copy_xtag_list(y4m_xtag_list_t *dest, const y4m_xtag_list_t *src);
+
+/* return number of tags in an xtag_list */
+int y4m_xtag_count(const y4m_xtag_list_t *xtags);
+
+/* access n'th tag in an xtag_list */
+const char *y4m_xtag_get(const y4m_xtag_list_t *xtags, int n);
+
+/* append a new tag to an xtag_list
+    returns:          Y4M_OK - success
+              Y4M_ERR_XXTAGS - list is already full */
+int y4m_xtag_add(y4m_xtag_list_t *xtags, const char *tag);
+
+/* remove a tag from an xtag_list 
+    returns:         Y4M_OK - success
+              Y4M_ERR_RANGE - n is out of range */
+int y4m_xtag_remove(y4m_xtag_list_t *xtags, int n);
+
+/* remove all tags from an xtag_list 
+    returns:   Y4M_OK - success       */
+int y4m_xtag_clearlist(y4m_xtag_list_t *xtags);
+
+/* append copies of tags from src list to dest list
+    returns:          Y4M_OK - success
+              Y4M_ERR_XXTAGS - operation would overfill dest list */
+int y4m_xtag_addlist(y4m_xtag_list_t *dest, const y4m_xtag_list_t *src);
+
+
+
+/************************************************************************
+ *  '*_info' functions
+ *
+ * o Before using a *_info structure (but after the structure/memory has
+ *    been allocated), you must initialize it via y4m_init_*_info().
+ * o After using a *_info structure (but before the structure is released),
+ *    call y4m_fini_*_info() to free internal memory.
+ * o Use the 'set' and 'get' accessors to modify or access the fields in
+ *    the structures; don't touch the structure directly.  (Ok, so there
+ *    is no really convenient C syntax to prevent you from doing this,
+ *    but we are all responsible programmers here, so just don't do it!)
+ *
+ ************************************************************************/
+
+/* initialize a stream_info structure */
+void y4m_init_stream_info(y4m_stream_info_t *i);
+
+/* finalize a stream_info structure */
+void y4m_fini_stream_info(y4m_stream_info_t *i);
+
+/* reset stream_info back to default/unknown values */
+void y4m_clear_stream_info(y4m_stream_info_t *info);
+
+/* make one stream_info into a copy of another */
+void y4m_copy_stream_info(y4m_stream_info_t *dest,
+			  const y4m_stream_info_t *src);
+
+/* access or set stream_info fields */
+/*      level 0                   */
+int y4m_si_get_width(const y4m_stream_info_t *si);
+int y4m_si_get_height(const y4m_stream_info_t *si);
+int y4m_si_get_interlace(const y4m_stream_info_t *si);
+y4m_ratio_t y4m_si_get_framerate(const y4m_stream_info_t *si);
+y4m_ratio_t y4m_si_get_sampleaspect(const y4m_stream_info_t *si);
+void y4m_si_set_width(y4m_stream_info_t *si, int width);
+void y4m_si_set_height(y4m_stream_info_t *si, int height);
+void y4m_si_set_interlace(y4m_stream_info_t *si, int interlace);
+void y4m_si_set_framerate(y4m_stream_info_t *si, y4m_ratio_t framerate);
+void y4m_si_set_sampleaspect(y4m_stream_info_t *si, y4m_ratio_t sar);
+/*      level 1                   */
+void y4m_si_set_chroma(y4m_stream_info_t *si, int chroma_mode);
+int y4m_si_get_chroma(const y4m_stream_info_t *si);
+
+/* derived quantities (no setter) */
+/*      level 0                   */
+int y4m_si_get_framelength(const y4m_stream_info_t *si);
+/*      level 1                   */
+int y4m_si_get_plane_count(const y4m_stream_info_t *si);
+int y4m_si_get_plane_width(const y4m_stream_info_t *si, int plane);
+int y4m_si_get_plane_height(const y4m_stream_info_t *si, int plane);
+int y4m_si_get_plane_length(const y4m_stream_info_t *si, int plane);
+
+
+/* access stream_info xtag_list */
+y4m_xtag_list_t *y4m_si_xtags(y4m_stream_info_t *si);
+
+
+/* initialize a frame_info structure */
+void y4m_init_frame_info(y4m_frame_info_t *i);
+
+/* finalize a frame_info structure */
+void y4m_fini_frame_info(y4m_frame_info_t *i);
+
+/* reset frame_info back to default/unknown values */
+void y4m_clear_frame_info(y4m_frame_info_t *info);
+
+/* make one frame_info into a copy of another */
+void y4m_copy_frame_info(y4m_frame_info_t *dest,
+			 const y4m_frame_info_t *src);
+
+
+/* access or set frame_info fields (level 1) */
+int y4m_fi_get_presentation(const y4m_frame_info_t *fi);
+int y4m_fi_get_temporal(const y4m_frame_info_t *fi);
+int y4m_fi_get_spatial(const y4m_frame_info_t *fi);
+
+void y4m_fi_set_presentation(y4m_frame_info_t *fi, int pres);
+void y4m_fi_set_temporal(y4m_frame_info_t *fi, int sampling);
+void y4m_fi_set_spatial(y4m_frame_info_t *fi, int sampling);
+
+
+/* access frame_info xtag_list */
+y4m_xtag_list_t *y4m_fi_xtags(y4m_frame_info_t *fi);
+
+
+
+/************************************************************************
+ *  blocking read and write functions
+ *
+ *  o guaranteed to transfer entire payload (or fail)
+ *  o return values:
+ *                         0 (zero)   complete success
+ *          -(# of remaining bytes)   error (and errno left set)
+ *          +(# of remaining bytes)   EOF (for y4m_read only)
+ *
+ ************************************************************************/
+
+/* read len bytes from fd into buf */
+ssize_t y4m_read(int fd, void *buf, size_t len);
+
+/* write len bytes from fd into buf */
+ssize_t y4m_write(int fd, const void *buf, size_t len);
+
+
+
+/************************************************************************
+ *  stream header processing functions
+ *  
+ *  o return values:
+ *                   Y4M_OK - success
+ *                Y4M_ERR_* - error (see y4m_strerr() for descriptions)
+ *
+ ************************************************************************/
+
+/* parse a string of stream header tags */
+int y4m_parse_stream_tags(char *s, y4m_stream_info_t *i);
+
+/* read a stream header from file descriptor fd
+   (the current contents of stream_info are erased first) */
+int y4m_read_stream_header(int fd, y4m_stream_info_t *i);
+
+/* write a stream header to file descriptor fd */
+int y4m_write_stream_header(int fd, const y4m_stream_info_t *i);
+
+
+
+/************************************************************************
+ *  frame processing functions
+ *  
+ *  o return values:
+ *                   Y4M_OK - success
+ *                Y4M_ERR_* - error (see y4m_strerr() for descriptions)
+ *
+ ************************************************************************/
+
+/* write a frame header to file descriptor fd */
+int y4m_write_frame_header(int fd,
+			   const y4m_stream_info_t *si,
+			   const y4m_frame_info_t *fi);
+
+/* write a complete frame (header + data)
+   o planes[] points to 1-4 buffers, one each for image plane */
+int y4m_write_frame(int fd, const y4m_stream_info_t *si, 
+		    const y4m_frame_info_t *fi, uint8_t * const *planes);
+
+
+/* write a complete frame (header + data), but interleave fields
+    from two separate buffers
+   o upper_field[] same as planes[] above, but for upper field only
+   o lower_field[] same as planes[] above, but for lower field only
+*/
+int y4m_write_fields(int fd, const y4m_stream_info_t *si, 
+		     const y4m_frame_info_t *fi,
+		     uint8_t * const *upper_field, 
+		     uint8_t * const *lower_field);
+
+
+/* read a frame header from file descriptor fd 
+   (the current contents of frame_info are erased first) */
+int y4m_read_frame_header(int fd,
+			  const y4m_stream_info_t *si,
+			  y4m_frame_info_t *fi);
+
+/* read frame data [to be called after y4m_read_frame_header()]
+   o planes[] points to 1-4 buffers, one each for image plane */
+int y4m_read_frame_data(int fd, const y4m_stream_info_t *si, 
+                        y4m_frame_info_t *fi, uint8_t * const *planes);
+
+/* read frame data, but de-interleave fields into two separate buffers
+    [to be called after y4m_read_frame_header()]
+   o upper_field[] same as planes[] above, but for upper field only
+   o lower_field[] same as planes[] above, but for lower field only
+*/
+int y4m_read_fields_data(int fd, const y4m_stream_info_t *si, 
+                         y4m_frame_info_t *fi,
+                         uint8_t * const *upper_field, 
+                         uint8_t * const *lower_field);
+
+/* read a complete frame (header + data)
+   o planes[] points to 1-4 buffers, one each for image plane */
+int y4m_read_frame(int fd, const y4m_stream_info_t *si, 
+		   y4m_frame_info_t *fi, uint8_t * const *planes);
+
+/* read a complete frame (header + data), but de-interleave fields
+    into two separate buffers
+   o upper_field[] same as planes[] above, but for upper field only
+   o lower_field[] same as planes[] above, but for lower field only
+*/
+int y4m_read_fields(int fd, const y4m_stream_info_t *si, 
+		    y4m_frame_info_t *fi,
+		    uint8_t * const *upper_field, 
+		    uint8_t * const *lower_field);
+
+
+/************************************************************************
+ *  miscellaneous functions
+ ************************************************************************/
+
+/* convenient dump of stream header info via mjpeg_log facility
+ *  - each logged/printed line is prefixed by 'prefix'
+ */
+void y4m_log_stream_info(log_level_t level, const char *prefix,
+			 const y4m_stream_info_t *i);
+
+/* convert a Y4M_ERR_* error code into mildly explanatory string */
+const char *y4m_strerr(int err);
+
+/* set 'allow_unknown_tag' flag for library...
+    o yn = 0 :  unknown header tags will produce a parsing error
+    o yn = 1 :  unknown header tags/values will produce a warning, but
+                 are otherwise passed along via the xtags list
+    o yn = -1:  don't change, just return current setting
+
+   return value:  previous setting of flag
+*/
+int y4m_allow_unknown_tags(int yn);
+
+
+/* set level of "accepted extensions" for the library...
+    o level = 0:  default - conform to original YUV4MPEG2 spec; yield errors
+                   when reading or writing a stream which exceeds it.
+    o level = 1:  allow reading/writing streams which contain non-420jpeg
+                   chroma and/or mixed-mode interlacing
+    o level = -1: don't change, just return current setting
+
+   return value:  previous setting of level
+ */
+int y4m_accept_extensions(int level);
+
+
+END_CDECLS
+
+
+/************************************************************************
+ ************************************************************************
+
+  Description of the (new!, forever?) YUV4MPEG2 stream format:
+
+  STREAM consists of
+    o one '\n' terminated STREAM-HEADER
+    o unlimited number of FRAMEs
+
+  FRAME consists of
+    o one '\n' terminated FRAME-HEADER
+    o "length" octets of planar YCrCb 4:2:0 image data
+        (if frame is interlaced, then the two fields are interleaved)
+
+
+  STREAM-HEADER consists of
+     o string "YUV4MPEG2"
+     o unlimited number TAGGED-FIELDs, each preceded by ' ' separator
+     o '\n' line terminator
+
+  FRAME-HEADER consists of
+     o string "FRAME"
+     o unlimited number of TAGGED-FIELDs, each preceded by ' ' separator
+     o '\n' line terminator
+
+
+  TAGGED-FIELD consists of
+     o single ascii character tag
+     o VALUE (which does not contain whitespace)
+
+  VALUE consists of
+     o integer (base 10 ascii representation)
+  or o RATIO
+  or o single ascii character
+  or o non-whitespace ascii string
+
+  RATIO consists of
+     o numerator (integer)
+     o ':' (a colon)
+     o denominator (integer)
+
+
+  The currently supported tags for the STREAM-HEADER:
+     W - [integer] frame width, pixels, should be > 0
+     H - [integer] frame height, pixels, should be > 0
+     C - [string]  chroma-subsampling/data format
+           420jpeg   (default)
+           420mpeg2
+           420paldv
+           411
+           422
+           444       - non-subsampled Y'CbCr
+	   444alpha  - Y'CbCr with alpha channel (with Y' black/white point)
+           mono      - Y' plane only
+     I - [char] interlacing:  p - progressive (none)
+                              t - top-field-first
+                              b - bottom-field-first
+                              m - mixed -- see 'I' tag in frame header
+                              ? - unknown
+     F - [ratio] frame-rate, 0:0 == unknown
+     A - [ratio] sample (pixel) aspect ratio, 0:0 == unknown
+     X - [character string] 'metadata' (unparsed, but passed around)
+
+  The currently supported tags for the FRAME-HEADER:
+     Ixyz - framing/sampling (required if-and-only-if stream is "Im")
+          x:  t - top-field-first
+              T - top-field-first and repeat
+	      b - bottom-field-first
+              B - bottom-field-first and repeat
+              1 - single progressive frame
+              2 - double progressive frame (repeat)
+              3 - triple progressive frame (repeat twice)
+
+          y:  p - progressive:  fields sampled at same time
+              i - interlaced:   fields sampled at different times
+
+          z:  p - progressive:  subsampling over whole frame
+              i - interlaced:   each field subsampled independently
+              ? - unknown (allowed only for non-4:2:0 subsampling)           
+       
+     X - character string 'metadata' (unparsed, but passed around)
+
+ ************************************************************************
+ ************************************************************************/
+
+
+/*
+
+   THAT'S ALL FOLKS!
+
+   Thank you for reading the source code.  We hope you have thoroughly
+   enjoyed the experience.
+
+*/
+
+
+
+
+
+#ifdef INTERNAL_Y4M_LIBCODE_STUFF_QPX
+#define Y4MPRIVATIZE(identifier) identifier
+#else
+#define Y4MPRIVATIZE(identifier) PRIVATE##identifier
+#endif
+
+/* 
+ * Actual structure definitions of structures which you shouldn't touch.
+ *
+ */
+
+/************************************************************************
+ *  'xtag_list' --- list of unparsed and/or meta/X header tags
+ *
+ *     Do not touch this structure directly!
+ *
+ *     Use the y4m_xtag_*() functions (see below).
+ *     You must initialize/finalize this structure before/after use.
+ ************************************************************************/
+struct _y4m_xtag_list {
+  int Y4MPRIVATIZE(count);
+  char *Y4MPRIVATIZE(tags)[Y4M_MAX_XTAGS];
+};
+
+
+/************************************************************************
+ *  'stream_info' --- stream header information
+ *
+ *     Do not touch this structure directly!
+ *
+ *     Use the y4m_si_*() functions (see below).
+ *     You must initialize/finalize this structure before/after use.
+ ************************************************************************/
+struct _y4m_stream_info {
+  /* values from header/setters */
+  int Y4MPRIVATIZE(width);
+  int Y4MPRIVATIZE(height);
+  int Y4MPRIVATIZE(interlace);            /* see Y4M_ILACE_* definitions  */
+  y4m_ratio_t Y4MPRIVATIZE(framerate);    /* see Y4M_FPS_* definitions    */
+  y4m_ratio_t Y4MPRIVATIZE(sampleaspect); /* see Y4M_SAR_* definitions    */
+  int Y4MPRIVATIZE(chroma);               /* see Y4M_CHROMA_* definitions */
+
+  /* mystical X tags */
+  y4m_xtag_list_t Y4MPRIVATIZE(x_tags);
+};
+
+
+/************************************************************************
+ *  'frame_info' --- frame header information
+ *
+ *     Do not touch this structure directly!
+ *
+ *     Use the y4m_fi_*() functions (see below).
+ *     You must initialize/finalize this structure before/after use.
+ ************************************************************************/
+
+struct _y4m_frame_info {
+  int Y4MPRIVATIZE(spatial);      /* see Y4M_SAMPLING_* definitions */
+  int Y4MPRIVATIZE(temporal);     /* see Y4M_SAMPLING_* definitions */
+  int Y4MPRIVATIZE(presentation); /* see Y4M_PRESENT_* definitions  */
+  /* mystical X tags */
+  y4m_xtag_list_t Y4MPRIVATIZE(x_tags);
+};
+
+
+#undef Y4MPRIVATIZE
+
+
+#endif /* __YUV4MPEG_H__ */
+
+

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/yuv4mpeg_intern.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/yuv4mpeg_intern.h	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/yuv4mpeg_intern.h	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,85 @@
+/*
+ *  yuv4mpeg_intern.h:  Internal constants for "new" YUV4MPEG streams
+ *
+ *  Copyright (C) 2001 Andrew Stevens <andrew.stevens at philips.com>
+ *  Copyright (C) 2001 Matthew J. Marjanovic <maddog at mir.com>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of version 2 of the GNU General Public License
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#ifndef __YUV4MPEG_INTERN_H__
+#define __YUV4MPEG_INTERN_H__
+
+
+#define Y4M_MAGIC "YUV4MPEG2"
+#define Y4M_FRAME_MAGIC "FRAME"
+
+#define Y4M_DELIM " "  /* single-character(space) separating tagged fields */
+
+#define Y4M_LINE_MAX 256   /* max number of characters in a header line
+                               (including the '\n', but not the '\0') */
+
+
+/* standard framerate ratios */
+#define Y4M_FPS_UNKNOWN    { 0, 0 }
+#define Y4M_FPS_NTSC_FILM  { 24000, 1001 }
+#define Y4M_FPS_FILM       { 24, 1 }
+#define Y4M_FPS_PAL        { 25, 1 }
+#define Y4M_FPS_NTSC       { 30000, 1001 }
+#define Y4M_FPS_30         { 30, 1 }
+#define Y4M_FPS_PAL_FIELD  { 50, 1 }
+#define Y4M_FPS_NTSC_FIELD { 60000, 1001 }
+#define Y4M_FPS_60         { 60, 1 }
+
+/* standard sample/pixel aspect ratios */
+#define Y4M_SAR_UNKNOWN        {   0, 0  }
+#define Y4M_SAR_SQUARE         {   1, 1  }
+#define Y4M_SAR_SQR_ANA_16_9   {   4, 3  }
+#define Y4M_SAR_NTSC_CCIR601   {  10, 11 }
+#define Y4M_SAR_NTSC_16_9      {  40, 33 }
+#define Y4M_SAR_NTSC_SVCD_4_3  {  15, 11 }
+#define Y4M_SAR_NTSC_SVCD_16_9 {  20, 11 }
+#define Y4M_SAR_PAL_CCIR601    {  59, 54 }
+#define Y4M_SAR_PAL_16_9       { 118, 81 }
+#define Y4M_SAR_PAL_SVCD_4_3   {  59, 36 }
+#define Y4M_SAR_PAL_SVCD_16_9  {  59, 27 }
+
+#define Y4M_SAR_MPEG1_1  Y4M_SAR_SQUARE
+#define Y4M_SAR_MPEG1_2  { 10000, 6735 }
+#define Y4M_SAR_MPEG1_3  { 10000, 7031 } /* Anamorphic 16:9 PAL */
+#define Y4M_SAR_MPEG1_4  { 10000, 7615 }
+#define Y4M_SAR_MPEG1_5  { 10000, 8055 }
+#define Y4M_SAR_MPEG1_6  { 10000, 8437 } /* Anamorphic 16:9 NTSC */
+#define Y4M_SAR_MPEG1_7  { 10000, 8935 } 
+#define Y4M_SAR_MPEG1_8  { 10000, 9375 } /* PAL/SECAM 4:3 */
+#define Y4M_SAR_MPEG1_9  { 10000, 9815 }
+#define Y4M_SAR_MPEG1_10 { 10000, 10255 }
+#define Y4M_SAR_MPEG1_11 { 10000, 10695 }
+#define Y4M_SAR_MPEG1_12 { 10000, 11250 } /* NTSC 4:3 */
+#define Y4M_SAR_MPEG1_13 { 10000, 11575 }
+#define Y4M_SAR_MPEG1_14 { 10000, 12015 }
+
+#define Y4M_DAR_UNKNOWN  {   0, 0   }
+#define Y4M_DAR_4_3      {   4, 3   }
+#define Y4M_DAR_16_9     {  16, 9   }
+#define Y4M_DAR_221_100  { 221, 100 }
+
+#define Y4M_DAR_MPEG2_1 {   1, 1   }
+#define Y4M_DAR_MPEG2_2 {   4, 3   }
+#define Y4M_DAR_MPEG2_3 {  16, 9   }
+#define Y4M_DAR_MPEG2_4 { 221, 100 }
+
+#endif /* __YUV4MPEG_INTERN_H__ */
+



From mean at mail.berlios.de  Sat Sep  5 10:19:15 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 5 Sep 2009 10:19:15 +0200
Subject: [Avidemux-svn-commit] r5321 - in
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer:
	include src
Message-ID: <200909050819.n858JFrn017050@sheep.berlios.de>

Author: mean
Date: 2009-09-05 10:19:15 +0200 (Sat, 05 Sep 2009)
New Revision: 5321

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/include/ADM_coreMuxerFfmpeg.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_muxerUtils.cpp
Log:
[core] Fix AV_NOPTS_VALUE requiring long long attributes on 32 bits systems

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/include/ADM_coreMuxerFfmpeg.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/include/ADM_coreMuxerFfmpeg.h	2009-09-05 08:19:09 UTC (rev 5320)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/include/ADM_coreMuxerFfmpeg.h	2009-09-05 08:19:15 UTC (rev 5321)
@@ -28,7 +28,7 @@
     #include "libavformat/avformat.h"
 };
 #ifndef INT64_C
-#define INT64_C (uint64_t)
+#define INT64_C(x) (uint64_t)(x##LL)
 #endif
 /**
     \class muxerFFmpeg
@@ -73,4 +73,4 @@
 
 };
 
-#endif
\ No newline at end of file
+#endif

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_muxerUtils.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_muxerUtils.cpp	2009-09-05 08:19:09 UTC (rev 5320)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_muxerUtils.cpp	2009-09-05 08:19:15 UTC (rev 5321)
@@ -50,7 +50,7 @@
 uint64_t rescaleLavPts(uint64_t us, AVRational *scale)
 {
 #ifndef INT64_C
-#define INT64_C (uint64_t)
+#define INT64_C(x) (uint64_t)(x##LL)
 #endif
      if(us==ADM_NO_PTS) return AV_NOPTS_VALUE;  // AV_NOPTS_VALUE
     double db=(double)us;



From mean at mail.berlios.de  Sat Sep  5 10:19:17 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 5 Sep 2009 10:19:17 +0200
Subject: [Avidemux-svn-commit] r5322 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers
Message-ID: <200909050819.n858JH7D017060@sheep.berlios.de>

Author: mean
Date: 2009-09-05 10:19:16 +0200 (Sat, 05 Sep 2009)
New Revision: 5322

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/CMakeLists.txt
Log:
[Muxer] Disable mplex for the moment

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/CMakeLists.txt	2009-09-05 08:19:15 UTC (rev 5321)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/CMakeLists.txt	2009-09-05 08:19:16 UTC (rev 5322)
@@ -5,5 +5,5 @@
 ADD_SUBDIRECTORY(muxerFlv)
 ADD_SUBDIRECTORY(muxerMkv)
 ADD_SUBDIRECTORY(muxerffPS)
-ADD_SUBDIRECTORY(muxerMplex)
 ADD_SUBDIRECTORY(muxerffTS)
+#ADD_SUBDIRECTORY(muxerMplex)



From mean at mail.berlios.de  Sat Sep  5 16:40:53 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 5 Sep 2009 16:40:53 +0200
Subject: [Avidemux-svn-commit] r5323 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffPS
Message-ID: <200909051440.n85EerJG009559@sheep.berlios.de>

Author: mean
Date: 2009-09-05 16:40:52 +0200 (Sat, 05 Sep 2009)
New Revision: 5323

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffPS/muxerffPS.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffPS/muxerffPS.h
Log:
[ff PS Muxer] Simplify

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffPS/muxerffPS.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffPS/muxerffPS.cpp	2009-09-05 08:19:16 UTC (rev 5322)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffPS/muxerffPS.cpp	2009-09-05 14:40:52 UTC (rev 5323)
@@ -28,6 +28,21 @@
 #define aprintf printf
 #endif
 
+typedef struct
+{
+    const char *fmt;
+    uint32_t   bufferSizekBytes;
+    uint32_t   muxRatekBits;
+    uint32_t   videoRatekBits;
+}mpegPsStruct;
+
+const mpegPsStruct psDescriptor[3]=
+{
+    { "vcd",  40,1400,1152},  // Verify, not sure!
+    { "svcd",112,2800,2400},
+    { "dvd", 224,11000,9800},
+};
+
 psMuxerConfig_s psMuxerConfig=
 {
     MUXER_DVD,false
@@ -53,97 +68,18 @@
     \fn open
     \brief Check that the streams are ok, initialize context...
 */
-
 bool muxerffPS::open(const char *file, ADM_videoStream *s,uint32_t nbAudioTrack,ADM_audioStream **a)
 {
-    uint32_t fcc=s->getFCC();
-    uint32_t w,h;
-     w=s->getWidth();
-     h=s->getHeight();
-        
-     if(!isMpeg12Compatible(fcc))
-     {
-            printf("[ffPs] video not compatible\n");
-            return false;
-     }
-    if(!psMuxerConfig.acceptNonCompliant)
+const char *er;
+
+    if(verifyCompatibility(psMuxerConfig.acceptNonCompliant,psMuxerConfig.muxingType,s,nbAudioTrack,a,&er)==false)
     {
-        switch(psMuxerConfig.muxingType)
-        {
-            case MUXER_VCD:
-                    if(w!=352 || (h!=240 && h!=288))
-                    {
-                            printf("[ffPs] Bad width/height for VCD\n");
-                            return false;
-                    }
-                    break;
-            case MUXER_SVCD:
-                    if((w!=352 && w!=480)|| (h!=576 && h!=480))
-                    {
-                            printf("[ffPs] Bad width/height for SVCD\n");
-                            return false;
-                    }
-                    break;
-            case MUXER_DVD:
-                    if((w!=720 && w!=704)|| (h!=576 && h!=480))
-                    {
-                            printf("[ffPs] Bad width/height for DVD\n");
-                            return false;
-                    }
-                    break;
-            default:
-                    ADM_assert(0);
-        }
+        GUI_Error_HIG("[Mismatch]","%s",er);
+        return false;
     }
-    if(!nbAudioTrack) 
-        {
-            printf("[ffPS] One audio track needed\n");
-            return false;
-        }
-    for(int i=0;i<nbAudioTrack;i++)
-    {
-        WAVHeader *head=a[i]->getInfo();
-        switch(psMuxerConfig.muxingType)
-        {
-            case MUXER_VCD:
-            case MUXER_SVCD:
-                    if(head->encoding!=WAV_MP2) 
-                    {
-                        printf("[ffPS] VCD : only MP2 audio accepted\n");
-                        return false;
-                    }
-                    if(head->frequency!=44100) 
-                    {
-                        printf("[ffPS] VCD : only 44.1 khz audio accepted\n");
-                        return false;
-                    }
-                    break;
-            case MUXER_DVD:
-                    if(head->encoding!=WAV_MP2 && head->encoding!=WAV_AC3 && head->encoding!=WAV_DTS) 
-                    {
-                        printf("[ffPS] DVD : only MP2/AC3/DTS audio accepted\n");
-                        return false;
-                    }
-                    if(head->frequency!=48000) 
-                    {
-                        printf("[ffPS] DVD : only 48 khz audio accepted\n");
-                        return false;
-                    }
-                    break;
-            default:
-                    ADM_assert(0);
-        }
-    }
 
-    /* All seems fine, open stuff */
-    const char *fmt;
-     switch(psMuxerConfig.muxingType)
-        {
-            case MUXER_VCD: fmt="vcd";break;
-            case MUXER_SVCD:fmt="svcd";break;
-            case MUXER_DVD: fmt="dvd";break;
-        }
-    if(false==setupMuxer(fmt,file))
+    mpegPsStruct myself=psDescriptor[psMuxerConfig.muxingType];
+    if(false==setupMuxer(myself.fmt,file))
     {
         printf("[ffPS] Failed to open muxer\n");
         return false;
@@ -158,32 +94,26 @@
     
         AVCodecContext *c;
         c = video_st->codec;
+
+        // Override codec settings
         rescaleFps(s->getAvgFps1000(),&(c->time_base));
-        // Override codec settings
-#define MKX(a,bsize,maxb) case a: c->bit_rate=maxb*1000;c->rc_buffer_size=bsize*8*1000;break;
-        switch(psMuxerConfig.muxingType)
-        {
-            MKX(MUXER_VCD,  40,1152)
-            MKX(MUXER_SVCD,112,2400)
-            MKX(MUXER_DVD, 224,9800)
-        }
+        c->bit_rate=myself.videoRatekBits*1000;
+        c->rc_buffer_size=myself.bufferSizekBytes*8*1024;
+        c->rc_buffer_size_header=myself.bufferSizekBytes*8*1024;
+        c->gop_size=15;
 
-        c->gop_size=15;
-        
+        // Audio
         if(initAudio(nbAudioTrack,a)==false)
         {
             printf("[ffPS] Failed to init audio\n");
             return false;
         }
-        
+        audio_st->codec->bit_rate=a[0]->getInfo()->byterate*8;        
         // /audio
-        switch(psMuxerConfig.muxingType)
-        {
-            case MUXER_VCD:  oc->mux_rate=10080*1000;;break;
-            case MUXER_SVCD: oc->mux_rate=2500*1000;;break;
-            case MUXER_DVD:  oc->mux_rate=1152*1000;;break;
-        }
-       
+        oc->mux_rate=myself.muxRatekBits*1024;
+        // Also copy audio & video bitrate
+
+
         oc->preload=0; // 100 ms preloading
         oc->max_delay=2000; // 500 ms
         if (av_set_parameters(oc, NULL) < 0)
@@ -236,6 +166,89 @@
     return closeMuxer();
 }
 
+/**
+    \fn verifyCompatibility
+    \return true if the streams are ok to be muxed by selected muxer
+
+*/
+#define FAIL(x) {*er=x;return false;}
+bool muxerffPS::verifyCompatibility(bool nonCompliantOk, psMuxingType muxingType,
+                                    ADM_videoStream *s,uint32_t nbAudioTrack,ADM_audioStream **a, 
+                                    const char **er)
+{
+    uint32_t fcc=s->getFCC();
+    uint32_t w,h;
+     w=s->getWidth();
+     h=s->getHeight();
+     *er="??";
+
+     if(!isMpeg12Compatible(fcc))
+     {
+            FAIL(" video not compatible\n");
+     }
+    if(!nonCompliantOk)
+    {
+        switch(muxingType)
+        {
+            case MUXER_VCD:
+                    if(w!=352 || (h!=240 && h!=288))
+                    {
+                            FAIL(" Bad width/height for VCD\n");
+                    }
+                    break;
+            case MUXER_SVCD:
+                    if((w!=352 && w!=480)|| (h!=576 && h!=480))
+                    {
+                            FAIL(" Bad width/height for SVCD\n");
+                    }
+                    break;
+            case MUXER_DVD:
+                    if((w!=720 && w!=704)|| (h!=576 && h!=480))
+                    {
+                            FAIL(" Bad width/height for DVD\n");
+                    }
+                    break;
+            default:
+                    ADM_assert(0);
+        }
+    }
+    if(!nbAudioTrack) 
+        {
+            FAIL(" One audio track needed\n");
+            
+        }
+    for(int i=0;i<nbAudioTrack;i++)
+    {
+        WAVHeader *head=a[i]->getInfo();
+        switch(muxingType)
+        {
+            case MUXER_VCD:
+            case MUXER_SVCD:
+                    if(head->encoding!=WAV_MP2) 
+                    {
+                        FAIL(" VCD : only MP2 audio accepted\n");
+                    }
+                    if(head->frequency!=44100) 
+                    {
+                        FAIL(" VCD : only 44.1 khz audio accepted\n");
+                    }
+                    break;
+            case MUXER_DVD:
+                    if(head->encoding!=WAV_MP2 && head->encoding!=WAV_AC3 && head->encoding!=WAV_DTS) 
+                    {
+                        FAIL("[ffPS] DVD : only MP2/AC3/DTS audio accepted\n");
+                    }
+                    if(head->frequency!=48000) 
+                    {
+                        FAIL(" DVD : only 48 khz audio accepted\n");
+                    }
+                    break;
+            default:
+                    ADM_assert(0);
+        }
+    }
+    return true;
+}
 //EOF
 
 

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffPS/muxerffPS.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffPS/muxerffPS.h	2009-09-05 08:19:16 UTC (rev 5322)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffPS/muxerffPS.h	2009-09-05 14:40:52 UTC (rev 5323)
@@ -22,9 +22,9 @@
 
 typedef enum
 {
-    MUXER_VCD,
-    MUXER_SVCD,
-    MUXER_DVD
+    MUXER_VCD=0,
+    MUXER_SVCD=1,
+    MUXER_DVD=2
 }psMuxingType;
 
 typedef struct
@@ -43,6 +43,9 @@
 protected:
         
         bool muxerRescaleVideoTimeDts(uint64_t *time,uint64_t computedDts);
+        bool verifyCompatibility(bool nonCompliantOk, psMuxingType muxingType,
+                                    ADM_videoStream *s,uint32_t nbAudioTrack,ADM_audioStream **a, 
+                                    const char **er);
 
 public:
                 muxerffPS();



From mean at mail.berlios.de  Sat Sep  5 17:04:31 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 5 Sep 2009 17:04:31 +0200
Subject: [Avidemux-svn-commit] r5324 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffPS
Message-ID: <200909051504.n85F4VJq012211@sheep.berlios.de>

Author: mean
Date: 2009-09-05 17:04:31 +0200 (Sat, 05 Sep 2009)
New Revision: 5324

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffPS/muxerffPS.cpp
Log:
[ff PS muxer] Kilobit, not kilobyte

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffPS/muxerffPS.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffPS/muxerffPS.cpp	2009-09-05 14:40:52 UTC (rev 5323)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerffPS/muxerffPS.cpp	2009-09-05 15:04:31 UTC (rev 5324)
@@ -110,7 +110,7 @@
         }
         audio_st->codec->bit_rate=a[0]->getInfo()->byterate*8;        
         // /audio
-        oc->mux_rate=myself.muxRatekBits*1024;
+        oc->mux_rate=myself.muxRatekBits*1000;
         // Also copy audio & video bitrate
 
 



From mean at mail.berlios.de  Mon Sep  7 07:44:34 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Mon, 7 Sep 2009 07:44:34 +0200
Subject: [Avidemux-svn-commit] r5325 -
	branches/avidemux_2.6_branch_mean/addons/mkvscan
Message-ID: <200909070544.n875iYhx000736@sheep.berlios.de>

Author: mean
Date: 2009-09-07 07:44:31 +0200 (Mon, 07 Sep 2009)
New Revision: 5325

Modified:
   branches/avidemux_2.6_branch_mean/addons/mkvscan/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/addons/mkvscan/Makefile
Log:
[Addons] updated mkvscan CMakelist.txt

Modified: branches/avidemux_2.6_branch_mean/addons/mkvscan/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/addons/mkvscan/CMakeLists.txt	2009-09-05 15:04:31 UTC (rev 5324)
+++ branches/avidemux_2.6_branch_mean/addons/mkvscan/CMakeLists.txt	2009-09-07 05:44:31 UTC (rev 5325)
@@ -1,6 +1,6 @@
 PROJECT(mkv)
 INCLUDE_DIRECTORIES( .) 
-set(MKV ../../plugins/ADM_demuxers/Matroska/)
+set(MKV ../../avidemux_plugins/ADM_demuxers/Matroska/)
 INCLUDE_DIRECTORIES( ${MKV})
 #LINK_DIRECTORIES(${ITK_LIBRARY_DIRS})
 ADD_DEFINITIONS("-g")

Modified: branches/avidemux_2.6_branch_mean/addons/mkvscan/Makefile
===================================================================
--- branches/avidemux_2.6_branch_mean/addons/mkvscan/Makefile	2009-09-05 15:04:31 UTC (rev 5324)
+++ branches/avidemux_2.6_branch_mean/addons/mkvscan/Makefile	2009-09-07 05:44:31 UTC (rev 5325)
@@ -112,34 +112,34 @@
 .PHONY : mkv/fast
 
 # target to build an object file
-home/fx/workspace/gitted/plugins/ADM_demuxers/Matroska/ebml.o:
-	$(MAKE) -f CMakeFiles/mkv.dir/build.make CMakeFiles/mkv.dir/home/fx/workspace/gitted/plugins/ADM_demuxers/Matroska/ebml.o
-.PHONY : home/fx/workspace/gitted/plugins/ADM_demuxers/Matroska/ebml.o
+home/fx/workspace/gitted/avidemux_plugins/ADM_demuxers/Matroska/ebml.o:
+	$(MAKE) -f CMakeFiles/mkv.dir/build.make CMakeFiles/mkv.dir/home/fx/workspace/gitted/avidemux_plugins/ADM_demuxers/Matroska/ebml.o
+.PHONY : home/fx/workspace/gitted/avidemux_plugins/ADM_demuxers/Matroska/ebml.o
 
 # target to preprocess a source file
-home/fx/workspace/gitted/plugins/ADM_demuxers/Matroska/ebml.i:
-	$(MAKE) -f CMakeFiles/mkv.dir/build.make CMakeFiles/mkv.dir/home/fx/workspace/gitted/plugins/ADM_demuxers/Matroska/ebml.i
-.PHONY : home/fx/workspace/gitted/plugins/ADM_demuxers/Matroska/ebml.i
+home/fx/workspace/gitted/avidemux_plugins/ADM_demuxers/Matroska/ebml.i:
+	$(MAKE) -f CMakeFiles/mkv.dir/build.make CMakeFiles/mkv.dir/home/fx/workspace/gitted/avidemux_plugins/ADM_demuxers/Matroska/ebml.i
+.PHONY : home/fx/workspace/gitted/avidemux_plugins/ADM_demuxers/Matroska/ebml.i
 
 # target to generate assembly for a file
-home/fx/workspace/gitted/plugins/ADM_demuxers/Matroska/ebml.s:
-	$(MAKE) -f CMakeFiles/mkv.dir/build.make CMakeFiles/mkv.dir/home/fx/workspace/gitted/plugins/ADM_demuxers/Matroska/ebml.s
-.PHONY : home/fx/workspace/gitted/plugins/ADM_demuxers/Matroska/ebml.s
+home/fx/workspace/gitted/avidemux_plugins/ADM_demuxers/Matroska/ebml.s:
+	$(MAKE) -f CMakeFiles/mkv.dir/build.make CMakeFiles/mkv.dir/home/fx/workspace/gitted/avidemux_plugins/ADM_demuxers/Matroska/ebml.s
+.PHONY : home/fx/workspace/gitted/avidemux_plugins/ADM_demuxers/Matroska/ebml.s
 
 # target to build an object file
-home/fx/workspace/gitted/plugins/ADM_demuxers/Matroska/mkv_tags.o:
-	$(MAKE) -f CMakeFiles/mkv.dir/build.make CMakeFiles/mkv.dir/home/fx/workspace/gitted/plugins/ADM_demuxers/Matroska/mkv_tags.o
-.PHONY : home/fx/workspace/gitted/plugins/ADM_demuxers/Matroska/mkv_tags.o
+home/fx/workspace/gitted/avidemux_plugins/ADM_demuxers/Matroska/mkv_tags.o:
+	$(MAKE) -f CMakeFiles/mkv.dir/build.make CMakeFiles/mkv.dir/home/fx/workspace/gitted/avidemux_plugins/ADM_demuxers/Matroska/mkv_tags.o
+.PHONY : home/fx/workspace/gitted/avidemux_plugins/ADM_demuxers/Matroska/mkv_tags.o
 
 # target to preprocess a source file
-home/fx/workspace/gitted/plugins/ADM_demuxers/Matroska/mkv_tags.i:
-	$(MAKE) -f CMakeFiles/mkv.dir/build.make CMakeFiles/mkv.dir/home/fx/workspace/gitted/plugins/ADM_demuxers/Matroska/mkv_tags.i
-.PHONY : home/fx/workspace/gitted/plugins/ADM_demuxers/Matroska/mkv_tags.i
+home/fx/workspace/gitted/avidemux_plugins/ADM_demuxers/Matroska/mkv_tags.i:
+	$(MAKE) -f CMakeFiles/mkv.dir/build.make CMakeFiles/mkv.dir/home/fx/workspace/gitted/avidemux_plugins/ADM_demuxers/Matroska/mkv_tags.i
+.PHONY : home/fx/workspace/gitted/avidemux_plugins/ADM_demuxers/Matroska/mkv_tags.i
 
 # target to generate assembly for a file
-home/fx/workspace/gitted/plugins/ADM_demuxers/Matroska/mkv_tags.s:
-	$(MAKE) -f CMakeFiles/mkv.dir/build.make CMakeFiles/mkv.dir/home/fx/workspace/gitted/plugins/ADM_demuxers/Matroska/mkv_tags.s
-.PHONY : home/fx/workspace/gitted/plugins/ADM_demuxers/Matroska/mkv_tags.s
+home/fx/workspace/gitted/avidemux_plugins/ADM_demuxers/Matroska/mkv_tags.s:
+	$(MAKE) -f CMakeFiles/mkv.dir/build.make CMakeFiles/mkv.dir/home/fx/workspace/gitted/avidemux_plugins/ADM_demuxers/Matroska/mkv_tags.s
+.PHONY : home/fx/workspace/gitted/avidemux_plugins/ADM_demuxers/Matroska/mkv_tags.s
 
 # target to build an object file
 mkv_c.o:
@@ -165,12 +165,12 @@
 	@echo "... edit_cache"
 	@echo "... mkv"
 	@echo "... rebuild_cache"
-	@echo "... home/fx/workspace/gitted/plugins/ADM_demuxers/Matroska/ebml.o"
-	@echo "... home/fx/workspace/gitted/plugins/ADM_demuxers/Matroska/ebml.i"
-	@echo "... home/fx/workspace/gitted/plugins/ADM_demuxers/Matroska/ebml.s"
-	@echo "... home/fx/workspace/gitted/plugins/ADM_demuxers/Matroska/mkv_tags.o"
-	@echo "... home/fx/workspace/gitted/plugins/ADM_demuxers/Matroska/mkv_tags.i"
-	@echo "... home/fx/workspace/gitted/plugins/ADM_demuxers/Matroska/mkv_tags.s"
+	@echo "... home/fx/workspace/gitted/avidemux_plugins/ADM_demuxers/Matroska/ebml.o"
+	@echo "... home/fx/workspace/gitted/avidemux_plugins/ADM_demuxers/Matroska/ebml.i"
+	@echo "... home/fx/workspace/gitted/avidemux_plugins/ADM_demuxers/Matroska/ebml.s"
+	@echo "... home/fx/workspace/gitted/avidemux_plugins/ADM_demuxers/Matroska/mkv_tags.o"
+	@echo "... home/fx/workspace/gitted/avidemux_plugins/ADM_demuxers/Matroska/mkv_tags.i"
+	@echo "... home/fx/workspace/gitted/avidemux_plugins/ADM_demuxers/Matroska/mkv_tags.s"
 	@echo "... mkv_c.o"
 	@echo "... mkv_c.i"
 	@echo "... mkv_c.s"



From mean at mail.berlios.de  Mon Sep  7 07:44:43 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Mon, 7 Sep 2009 07:44:43 +0200
Subject: [Avidemux-svn-commit] r5326 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska
Message-ID: <200909070544.n875ihJP000773@sheep.berlios.de>

Author: mean
Date: 2009-09-07 07:44:38 +0200 (Mon, 07 Sep 2009)
New Revision: 5326

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkvEntries.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkvIndexer.cpp
Log:
[Mkv] Print out Track timescale + fix overflow on Dts/Pts computation

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkvEntries.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkvEntries.cpp	2009-09-07 05:44:31 UTC (rev 5325)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkvEntries.cpp	2009-09-07 05:44:38 UTC (rev 5326)
@@ -196,7 +196,10 @@
         //case MKV_AUDIO_OUT_FREQUENCY:entry->fq=(uint32_t)floor(father.readFloat(len));break;
         case  MKV_VIDEO_WIDTH: entry->w=father.readUnsignedInt(len);break;
         case  MKV_VIDEO_HEIGHT: entry->h=father.readUnsignedInt(len);break;
-        case  MKV_TRACK_TIMECODESCALE:father.skip(len);break; //FIXME
+        case  MKV_TRACK_TIMECODESCALE:
+                                {
+                                    printf("[Mkv] TimeCodeScale=%"LLU"\n",father.readUnsignedInt(len));
+                                };break; //FIXME
 
         case  MKV_FRAME_DEFAULT_DURATION: entry->defaultDuration=father.readUnsignedInt(len)/1000; break; // In us
         case  MKV_CODEC_EXTRADATA:

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkvIndexer.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkvIndexer.cpp	2009-09-07 05:44:31 UTC (rev 5325)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkvIndexer.cpp	2009-09-07 05:44:38 UTC (rev 5326)
@@ -42,7 +42,13 @@
  
     //************
    work->update(0);
+#if 0
    for(int clusters=0;clusters<_nbClusters;clusters++)
+    {
+        printf("[Cluster] %d/%d StartTimecode=%"LLU" ms\n",clusters,_nbClusters,_clusters[clusters].Dts);
+    }
+#endif
+   for(int clusters=0;clusters<_nbClusters;clusters++)
    {
    parser->seek(_clusters[clusters].pos);
    ADM_ebml_file cluster(parser,_clusters[clusters].size);
@@ -154,8 +160,8 @@
   ix.pos=where;
   ix.size=size;
   ix.flags=AVI_KEY_FRAME;
-  ix.Dts=timecodeMS*1000;
-  ix.Pts=timecodeMS*1000;
+  ix.Dts=timecodeMS*1000LL;
+  ix.Pts=timecodeMS*1000LL;
   
   // since frame type is unreliable for mkv, we scan each frame
   // For the 2 most common cases : mp4 & h264.



From gruntster at mail.berlios.de  Mon Sep  7 22:38:05 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Mon, 7 Sep 2009 22:38:05 +0200
Subject: [Avidemux-svn-commit] r5327 -
	branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_xvid
Message-ID: <200909072038.n87Kc5Uj006070@sheep.berlios.de>

Author: gruntster
Date: 2009-09-07 22:38:01 +0200 (Mon, 07 Sep 2009)
New Revision: 5327

Modified:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_xvid/encoder.cpp
Log:
[xvid] destroy xvid context after each pass

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_xvid/encoder.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_xvid/encoder.cpp	2009-09-07 05:44:38 UTC (rev 5326)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_xvid/encoder.cpp	2009-09-07 20:38:01 UTC (rev 5327)
@@ -387,6 +387,12 @@
 
 	if (_openPass)
 		_openPass = false;
+
+	if (_xvid_enc_create.handle)
+	{
+		xvid_encore(_xvid_enc_create.handle, XVID_ENC_DESTROY, NULL, NULL);
+		_xvid_enc_create.handle = NULL;
+	}
 }
 
 void XvidEncoder::close(void)
@@ -397,12 +403,6 @@
 	_opened = false;
 	_currentPass = 0;
 
-	if (_xvid_enc_create.handle)
-	{
-		xvid_encore (_xvid_enc_create.handle, XVID_ENC_DESTROY, NULL, NULL);
-		_xvid_enc_create.handle = NULL;
-	}
-
 	if (_buffer)
 	{
 		delete [] _buffer;



From gruntster at mail.berlios.de  Tue Sep 15 20:57:56 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Tue, 15 Sep 2009 20:57:56 +0200
Subject: [Avidemux-svn-commit] r5329 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src
Message-ID: <200909151857.n8FIvunC012640@sheep.berlios.de>

Author: gruntster
Date: 2009-09-15 20:57:49 +0200 (Tue, 15 Sep 2009)
New Revision: 5329

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_fileio.cpp
Log:
[win32] handle unicode names when checking for file existence

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_fileio.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_fileio.cpp	2009-09-10 05:17:51 UTC (rev 5328)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_fileio.cpp	2009-09-15 18:57:49 UTC (rev 5329)
@@ -56,16 +56,16 @@
 extern int wideCharStringToUtf8(const wchar_t *wideCharString, int wideCharStringLength, char *utf8String);
 #endif
 
-uint8_t ADM_fileExist(char *name)
-{
-	FILE *file = fopen(name, "rb");
-
-	if (!file)
-		return 0;
-
-	fclose(file);
-
-	return 1;
+uint8_t ADM_fileExist(char *name)
+{
+	FILE *file = ADM_fopen(name, "rb");
+
+	if (!file)
+		return 0;
+
+	fclose(file);
+
+	return 1;
 }
 
 size_t ADM_fread (void *ptr, size_t size, size_t n, FILE *sstream)



From gruntster at mail.berlios.de  Tue Sep 15 21:10:38 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Tue, 15 Sep 2009 21:10:38 +0200
Subject: [Avidemux-svn-commit] r5330 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_mplex
Message-ID: <200909151910.n8FJAcf9013604@sheep.berlios.de>

Author: gruntster
Date: 2009-09-15 21:10:33 +0200 (Tue, 15 Sep 2009)
New Revision: 5330

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_mplex/ADM_mplexin.cpp
Log:
[win32] fix mpeg muxer to handle unicode file names (fixes #38)

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_mplex/ADM_mplexin.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_mplex/ADM_mplexin.cpp	2009-09-15 18:57:49 UTC (rev 5329)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_mplex/ADM_mplexin.cpp	2009-09-15 19:10:33 UTC (rev 5330)
@@ -53,7 +53,7 @@
 int FileOutputStream::Open()
 {
   char msg[512];
-   while( !(strm = fopen( cur_filename, "wb" )) ){
+   while( !(strm = ADM_fopen( cur_filename, "wb" )) ){
       if( errno == ENOSPC
 #ifndef __MINGW32__
                           || errno == EDQUOT



From mean at mail.berlios.de  Wed Sep 16 19:36:18 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 16 Sep 2009 19:36:18 +0200
Subject: [Avidemux-svn-commit] r5331 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs
Message-ID: <200909161736.n8GHaIZd018799@sheep.berlios.de>

Author: mean
Date: 2009-09-16 19:36:16 +0200 (Wed, 16 Sep 2009)
New Revision: 5331

Added:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_codecFrameType.h
Log:
[mkv] Derive frame type while indexing (merge from 2.6)

Added: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_codecFrameType.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_codecFrameType.h	2009-09-15 19:10:33 UTC (rev 5330)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_codecFrameType.h	2009-09-16 17:36:16 UTC (rev 5331)
@@ -0,0 +1,160 @@
+/***************************************************************************
+                          ADM_codec.h  -  description
+                             -------------------
+    begin                : Fri Apr 12 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef __CODECS__
+#define __CODECS__
+#include "ADM_image.h"
+
+#define AVI_KEY_FRAME	0x10
+#define AVI_B_FRAME	0x4000	// hopefully it is not used..
+#define AVI_P_FRAME   	0x0
+
+#define ADM_QPEL_ON	1
+#define ADM_GMC_ON	2
+#define ADM_VOP_ON	4
+
+#define ADM_ENC_REQ_NULL_FLUSH	1
+
+/*
+        Bitrate in configuration will always be in **kBITS**
+
+*/
+
+#include "ADM_bitstream.h"
+#include "ADM_compressedImage.h"
+class decoders
+{
+protected:
+  uint32_t _w;
+  uint32_t _h;
+  uint8_t _lastQ;
+public:
+    decoders (uint32_t w, uint32_t h)
+  {
+    _w = w;
+    _h = h;
+    _lastQ = 0;
+  }
+  virtual ~ decoders ()
+  {
+  };
+  virtual uint8_t getPARWidth (void)
+  {
+    return 1;
+  };
+  virtual uint8_t getPARHeight (void)
+  {
+    return 1;
+  };
+  virtual void setParam (void)
+  {
+  };
+  virtual uint8_t uncompress (ADMCompressedImage * in, ADMImage * out)=0;
+
+  // does this codec *possibly* can have b-frame ?
+  virtual uint8_t dontcopy (void)
+  {
+    return 0;
+  }				// if 1 means the decoder will return reference
+  // no need to copy the datas to ADMimage
+  virtual uint8_t bFramePossible (void)
+  {
+    return 0;
+  }
+  virtual uint8_t decodeHeaderOnly (void)
+  {
+    return 0;
+  };
+  virtual uint8_t decodeFull (void)
+  {
+    return 0;
+  }
+  virtual uint8_t isDivxPacked (void)
+  {
+    return 0;
+  };
+  virtual uint32_t getSpecificMpeg4Info (void)
+  {
+    return 0;
+  };
+  virtual uint8_t isIndexable (void)
+  {
+    return 1;
+  };
+};
+/* Dummy decoder in case we don't have the desired one */
+class decoderEmpty : public decoders
+{
+protected:
+public:
+    decoderEmpty (uint32_t w, uint32_t h) : decoders(w,h) {};
+    uint8_t uncompress (ADMCompressedImage * in, ADMImage * out) {return 1;}
+
+};
+
+decoders *getDecoder (uint32_t fcc, uint32_t w, uint32_t h, uint32_t extraLen,
+		      uint8_t * extraData,uint32_t bpp=0);
+decoders *getDecoderVopPacked (uint32_t fcc, uint32_t w, uint32_t h,
+			       uint32_t extraLen, uint8_t * extraData);
+decoders *getDecoderH264noLogic (uint32_t fcc, uint32_t w, uint32_t h, uint32_t extraLen,
+		     uint8_t * extraData);
+
+class coders
+{
+protected:
+  uint32_t _w;
+  uint32_t _h;
+public:
+    coders (uint32_t w, uint32_t h)
+  {
+    _w = w;
+    _h = h;
+  }
+  virtual ~ coders ()
+  {
+  };
+  virtual uint8_t compress (ADMImage * in, ADMBitstream * out);
+};
+decoders *getCoder (uint32_t fcc, uint32_t w, uint32_t h);
+uint8_t isMpeg4Compatible (uint32_t fourcc);
+uint8_t isH264Compatible (uint32_t fourcc);
+uint8_t isMSMpeg4Compatible (uint32_t fourcc);
+uint8_t isDVCompatible (uint32_t fourcc);
+
+/*----------------------------------------------------------*/
+class encoder
+{
+protected:uint32_t _w, _h;
+public:encoder (uint32_t width, uint32_t height)
+  {
+    _w = width;
+    _h = height;
+  };
+  virtual uint8_t stopEncoder (void) = 0;
+  virtual uint8_t init (uint32_t val, uint32_t fps1000) = 0;
+  virtual uint8_t encode (ADMImage * in, ADMBitstream *out) = 0;
+  virtual uint8_t getExtraData (uint32_t * l, uint8_t ** d)
+  {
+    *l = 0;
+    *d = NULL;
+    return 0;
+  }
+};
+
+
+
+
+#endif



From mean at mail.berlios.de  Wed Sep 16 19:36:26 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 16 Sep 2009 19:36:26 +0200
Subject: [Avidemux-svn-commit] r5332 - in
	branches/avidemux_2.5_branch_gruntster/avidemux: ADM_codecs
	ADM_infoExtractor ADM_inputs/ADM_matroska
	ADM_inputs/ADM_openDML ADM_video
Message-ID: <200909161736.n8GHaQLI019071@sheep.berlios.de>

Author: mean
Date: 2009-09-16 19:36:23 +0200 (Wed, 16 Sep 2009)
New Revision: 5332

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_codec.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_codecFrameType.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_infoExtractor/ADM_infoextractor.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_matroska/ADM_mkv.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_matroska/ADM_mkvIndexer.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_openDML/ADM_openDMLDepack.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_videoInfoExtractor.h
Log:
[mkv] Derive frame type while indexing (merge from 2.6)

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_codec.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_codec.h	2009-09-16 17:36:16 UTC (rev 5331)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_codec.h	2009-09-16 17:36:23 UTC (rev 5332)
@@ -17,11 +17,7 @@
 #ifndef __CODECS__
 #define __CODECS__
 #include "ADM_image.h"
-
-#define AVI_KEY_FRAME	0x10
-#define AVI_B_FRAME	0x4000	// hopefully it is not used..
-#define AVI_P_FRAME   	0x0
-
+#include "ADM_codecFrameType.h"
 #define ADM_QPEL_ON	1
 #define ADM_GMC_ON	2
 #define ADM_VOP_ON	4
@@ -129,10 +125,6 @@
   virtual uint8_t compress (ADMImage * in, ADMBitstream * out);
 };
 decoders *getCoder (uint32_t fcc, uint32_t w, uint32_t h);
-uint8_t isMpeg4Compatible (uint32_t fourcc);
-uint8_t isH264Compatible (uint32_t fourcc);
-uint8_t isMSMpeg4Compatible (uint32_t fourcc);
-uint8_t isDVCompatible (uint32_t fourcc);
 
 /*----------------------------------------------------------*/
 class encoder

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_codecFrameType.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_codecFrameType.h	2009-09-16 17:36:16 UTC (rev 5331)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_codecFrameType.h	2009-09-16 17:36:23 UTC (rev 5332)
@@ -14,147 +14,22 @@
  *   (at your option) any later version.                                   *
  *                                                                         *
  ***************************************************************************/
-#ifndef __CODECS__
-#define __CODECS__
-#include "ADM_image.h"
+#ifndef __CODECS_FT__
+#define __CODECS_FT__
 
 #define AVI_KEY_FRAME	0x10
 #define AVI_B_FRAME	0x4000	// hopefully it is not used..
 #define AVI_P_FRAME   	0x0
 
-#define ADM_QPEL_ON	1
-#define ADM_GMC_ON	2
-#define ADM_VOP_ON	4
-
-#define ADM_ENC_REQ_NULL_FLUSH	1
-
-/*
-        Bitrate in configuration will always be in **kBITS**
-
-*/
-
-#include "ADM_bitstream.h"
-#include "ADM_compressedImage.h"
-class decoders
-{
-protected:
-  uint32_t _w;
-  uint32_t _h;
-  uint8_t _lastQ;
-public:
-    decoders (uint32_t w, uint32_t h)
-  {
-    _w = w;
-    _h = h;
-    _lastQ = 0;
-  }
-  virtual ~ decoders ()
-  {
-  };
-  virtual uint8_t getPARWidth (void)
-  {
-    return 1;
-  };
-  virtual uint8_t getPARHeight (void)
-  {
-    return 1;
-  };
-  virtual void setParam (void)
-  {
-  };
-  virtual uint8_t uncompress (ADMCompressedImage * in, ADMImage * out)=0;
-
-  // does this codec *possibly* can have b-frame ?
-  virtual uint8_t dontcopy (void)
-  {
-    return 0;
-  }				// if 1 means the decoder will return reference
-  // no need to copy the datas to ADMimage
-  virtual uint8_t bFramePossible (void)
-  {
-    return 0;
-  }
-  virtual uint8_t decodeHeaderOnly (void)
-  {
-    return 0;
-  };
-  virtual uint8_t decodeFull (void)
-  {
-    return 0;
-  }
-  virtual uint8_t isDivxPacked (void)
-  {
-    return 0;
-  };
-  virtual uint32_t getSpecificMpeg4Info (void)
-  {
-    return 0;
-  };
-  virtual uint8_t isIndexable (void)
-  {
-    return 1;
-  };
-};
-/* Dummy decoder in case we don't have the desired one */
-class decoderEmpty : public decoders
-{
-protected:
-public:
-    decoderEmpty (uint32_t w, uint32_t h) : decoders(w,h) {};
-    uint8_t uncompress (ADMCompressedImage * in, ADMImage * out) {return 1;}
-
-};
-
-decoders *getDecoder (uint32_t fcc, uint32_t w, uint32_t h, uint32_t extraLen,
-		      uint8_t * extraData,uint32_t bpp=0);
-decoders *getDecoderVopPacked (uint32_t fcc, uint32_t w, uint32_t h,
-			       uint32_t extraLen, uint8_t * extraData);
-decoders *getDecoderH264noLogic (uint32_t fcc, uint32_t w, uint32_t h, uint32_t extraLen,
-		     uint8_t * extraData);
-
-class coders
-{
-protected:
-  uint32_t _w;
-  uint32_t _h;
-public:
-    coders (uint32_t w, uint32_t h)
-  {
-    _w = w;
-    _h = h;
-  }
-  virtual ~ coders ()
-  {
-  };
-  virtual uint8_t compress (ADMImage * in, ADMBitstream * out);
-};
-decoders *getCoder (uint32_t fcc, uint32_t w, uint32_t h);
 uint8_t isMpeg4Compatible (uint32_t fourcc);
 uint8_t isH264Compatible (uint32_t fourcc);
 uint8_t isMSMpeg4Compatible (uint32_t fourcc);
 uint8_t isDVCompatible (uint32_t fourcc);
 
-/*----------------------------------------------------------*/
-class encoder
-{
-protected:uint32_t _w, _h;
-public:encoder (uint32_t width, uint32_t height)
-  {
-    _w = width;
-    _h = height;
-  };
-  virtual uint8_t stopEncoder (void) = 0;
-  virtual uint8_t init (uint32_t val, uint32_t fps1000) = 0;
-  virtual uint8_t encode (ADMImage * in, ADMBitstream *out) = 0;
-  virtual uint8_t getExtraData (uint32_t * l, uint8_t ** d)
-  {
-    *l = 0;
-    *d = NULL;
-    return 0;
-  }
-};
 
 
 
+#define MAX_VOP 10
 
+
 #endif

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_infoExtractor/ADM_infoextractor.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_infoExtractor/ADM_infoextractor.cpp	2009-09-16 17:36:16 UTC (rev 5331)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_infoExtractor/ADM_infoextractor.cpp	2009-09-16 17:36:23 UTC (rev 5332)
@@ -18,8 +18,8 @@
 
 #include "fourcc.h"
 #include "ADM_inputs/ADM_mp4/ADM_mp4.h"
+#include "ADM_video/ADM_videoInfoExtractor.h"
 
-
 #include "ADM_osSupport/ADM_debugID.h"
 #define MODULE_NAME MODULE_3GP
 #include "ADM_osSupport/ADM_debug.h"
@@ -635,3 +635,75 @@
 
 	return 1;
 }
+/**
+    \fn ADM_searchVop
+
+ Search a start vop in it
+ and return also the vop type
+ needed for example to rederive frame type or unpack streams
+*/
+uint32_t ADM_searchVop(uint8_t *begin, uint8_t *end,uint32_t *nb, ADM_vopS *vop,uint32_t *timeincbits)
+{
+	
+	uint32_t off=0;
+	uint32_t globalOff=0;
+	uint32_t voptype;
+	uint8_t code;
+        uint32_t w,h,t;
+        uint32_t modulo,time_inc,vopcoded,vopType;
+	*nb=0;
+	while(begin<end-3)
+	{
+    	if( ADM_findMpegStartCode(begin, end,&code,&off))
+    	{
+        	if(code==0xb6)
+			{
+				// Analyse a bit the vop header
+				uint8_t coding_type=begin[off];
+				coding_type>>=6;
+				//aprintf("\t at %u %d Img type:%s\n",off,*nb,s_voptype[coding_type]);
+				switch(coding_type)
+				{
+					case 0: voptype=AVI_KEY_FRAME;break;
+					case 1: voptype=0;break;
+					case 2: voptype=AVI_B_FRAME;break;
+					case 3: printf("Glouglou\n");voptype=0;break;
+				
+				}
+        	                vop[*nb].offset=globalOff+off-4;
+				vop[*nb].type=voptype;
+
+				
+                                
+                                /* Get more info */
+                                if( extractVopInfo(begin+off, end-begin-off, *timeincbits,&vopType,&modulo,
+                                            &time_inc,&vopcoded))
+                                {
+                                    aprintf(" frame found: vopType:%x modulo:%d time_inc:%d vopcoded:%d\n",vopType,modulo,time_inc,vopcoded);
+                                    vop[*nb].modulo=modulo;
+                                    vop[*nb].timeInc=time_inc;
+                                    vop[*nb].vopCoded=vopcoded;
+                                }
+                                *nb=(*nb)+1;
+                                begin+=off+1;
+				globalOff+=off+1;
+				continue;
+			
+			}
+                else if(code==0x20 && off>=4	) // Vol start
+                {
+                  
+                   if(extractMpeg4Info(begin+off-4,end+4-off-begin,&w,&h,timeincbits))
+                   {
+                      aprintf("Found Vol header : w:%d h:%d timeincbits:%d\n",w,h,*timeincbits);
+                   }
+                  
+                }
+        	begin+=off;
+        	globalOff+=off;
+        	continue;
+    	}
+    	return 1; 
+    }   
+	return 1;
+}
\ No newline at end of file

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_matroska/ADM_mkv.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_matroska/ADM_mkv.h	2009-09-16 17:36:16 UTC (rev 5331)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_matroska/ADM_mkv.h	2009-09-16 17:36:23 UTC (rev 5332)
@@ -114,8 +114,8 @@
     uint8_t                 reformatVorbisHeader(mkvTrak *trk);
     // Indexers
 
-    uint8_t                 addIndexEntry(uint32_t track,uint64_t where, uint32_t size,uint32_t flags,
-                                            uint32_t timecodeMS);
+    uint8_t                 addIndexEntry(uint32_t track,ADM_ebml_file *parser,uint64_t where, 
+                                            uint32_t size,uint32_t flags,  uint32_t timecodeMS);
     uint8_t                 videoIndexer(ADM_ebml_file *parser);
     uint8_t                 readCue(ADM_ebml_file *parser);
     uint8_t                 indexClusters(ADM_ebml_file *parser);

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_matroska/ADM_mkvIndexer.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_matroska/ADM_mkvIndexer.cpp	2009-09-16 17:36:16 UTC (rev 5331)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_matroska/ADM_mkvIndexer.cpp	2009-09-16 17:36:23 UTC (rev 5332)
@@ -32,6 +32,8 @@
 #include "mkv_tags.h"
 #include "ADM_userInterfaces/ADM_commonUI/DIA_idx_pg.h"
 #include "ADM_userInterfaces/ADM_commonUI/DIA_working.h"
+#include "ADM_video/ADM_videoInfoExtractor.h"
+#include "ADM_codecs/ADM_codecFrameType.h"
 #define VIDEO _tracks[0]
 /**
     \fn videoIndexer
@@ -154,7 +156,7 @@
         case 0: // No lacing
               if(!track) // Video
               {
-                  addIndexEntry(track,parser->tell(),remaining,entryFlags,clusterTimeCodeMs+timecode);
+                  addIndexEntry(track,parser,parser->tell(),remaining,entryFlags,clusterTimeCodeMs+timecode);
               }
               else
               {
@@ -177,7 +179,7 @@
                     }
                     if(!track)
                     {
-                      addIndexEntry(track,parser->tell(),remaining,0,clusterTimeCodeMs+timecode);
+                      addIndexEntry(track,parser,parser->tell(),remaining,0,clusterTimeCodeMs+timecode);
                       printf("Warning lacing on video track\n");
                     }
                     else
@@ -247,7 +249,8 @@
     \brief add an entry to the video index
     @param timecodeMS PTS of the frame in ms!
 */
-uint8_t mkvHeader::addIndexEntry(uint32_t track,uint64_t where, uint32_t size,uint32_t flags,uint32_t timecodeMS)
+uint8_t mkvHeader::addIndexEntry(uint32_t track,ADM_ebml_file *parser,
+                                uint64_t where, uint32_t size,uint32_t flags,uint32_t timecodeMS)
 {
   //
   mkvTrak *Track=&(_tracks[track]);
@@ -286,6 +289,39 @@
   }
   Track->_nbIndex++;
 
+  if(track) return 1; // no 0 track = audio or subs, we are done here
+
+    // Try to update frame type on the fly...
+    // Only do it for Mpeg4 SP/ASP/AVC
+    if( isMpeg4Compatible(_videostream.fccHandler))
+    {
+        uint8_t buffer[size];
+        
+        parser->readBin(buffer,size-3);
+        // Search the frame type...
+
+         uint32_t nb,vopType,timeinc=16;
+         ADM_vopS vops[10];
+         vops[0].type=AVI_KEY_FRAME;
+         ADM_searchVop(buffer,buffer+size-3,&nb,vops, &timeinc);
+         index[x].flags=vops[0].type;
+    
+    }
+    else
+    if(isH264Compatible(_videostream.fccHandler))
+    {
+        uint8_t buffer[size];
+            uint32_t flags=AVI_KEY_FRAME;
+            parser->readBin(buffer,size-3);
+            extractH264FrameType(2,buffer,size-3,&flags); // Nal size is not used in that case
+            if(flags & AVI_KEY_FRAME)
+            {
+                //printf("[MKV/H264] Frame %"LU" is a keyframe\n",(uint32_t)Track->index.size());
+            }
+            index[x].flags=flags;
+    }
+
+
  // printf("++\n");
   return 1;
 }

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_openDML/ADM_openDMLDepack.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_openDML/ADM_openDMLDepack.cpp	2009-09-16 17:36:16 UTC (rev 5331)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_openDML/ADM_openDMLDepack.cpp	2009-09-16 17:36:23 UTC (rev 5332)
@@ -20,7 +20,7 @@
 
 #include "ADM_userInterfaces/ADM_commonUI/DIA_working.h"
 #include "ADM_libraries/ADM_utilities/avidemutils.h"
-
+#include "ADM_video/ADM_videoInfoExtractor.h"
 #include "ADM_osSupport/ADM_debugID.h"
 #define MODULE_NAME MODULE_UNPACKER
 #include "ADM_osSupport/ADM_debug.h"
@@ -29,22 +29,11 @@
 #endif
 #define DEPACK_VERBOSE
 
-typedef struct vopS
-{
-	uint32_t offset;
-	uint32_t type;
-        uint32_t vopCoded;
-        uint32_t modulo;
-        uint32_t timeInc;
-}vopS;
-#define MAX_VOP 10
 
-uint8_t ADM_findMpegStartCode(uint8_t *start, uint8_t *end,uint8_t *outstartcode,uint32_t *offset);
 uint8_t extractVopInfo(uint8_t *data, uint32_t len,uint32_t timeincbits,uint32_t *vopType,uint32_t *modulo, uint32_t *time_inc,uint32_t *vopcoded);
 uint8_t extractMpeg4Info(uint8_t *data,uint32_t dataSize,uint32_t *w,uint32_t *h,uint32_t *time_inc);
 
 
-static uint32_t searchVop(uint8_t *begin, uint8_t *end,uint32_t *nb, vopS *vop,uint32_t *timeincbits);
 
 static const char *s_voptype[4]={"I frame","P frame","B frame","D frame"};
 uint8_t OpenDMLHeader::unpackPacked( void )
@@ -56,7 +45,7 @@
 	uint32_t nbDuped=0;
         uint32_t timcincbits=16;  /* Nb bits used to code time_inc 16 is a safe default */
 	
-	vopS	myVops[MAX_VOP]; // should be enough
+	ADM_vopS	myVops[MAX_VOP]; // should be enough
 	// here we got the vidHeader to get the file easily
 	// we only deal with avi now, so cast it to its proper type (i.e. avi)
 		
@@ -120,7 +109,7 @@
                                 continue;
                 }
                 /* Cannot find vop, corrupted or WTF ...*/
-                if(!searchVop(buffer,buffer+image.dataLength,&nbVop,myVops,&timcincbits))
+                if(!ADM_searchVop(buffer,buffer+image.dataLength,&nbVop,myVops,&timcincbits))
                 {
                     printf("img :%u failed to find vop!\n",img); 
                     memcpy(&newIndex[targetIndex],&_idx[img],sizeof(_idx[0]));
@@ -218,70 +207,4 @@
 
 	return ret;
 }
-// Search a start vop in it
-// and return also the vop type
-// needed to update the index
-uint32_t searchVop(uint8_t *begin, uint8_t *end,uint32_t *nb, vopS *vop,uint32_t *timeincbits)
-{
-	
-	uint32_t off=0;
-	uint32_t globalOff=0;
-	uint32_t voptype;
-	uint8_t code;
-        uint32_t w,h,t;
-        uint32_t modulo,time_inc,vopcoded,vopType;
-	*nb=0;
-	while(begin<end-3)
-	{
-    	if( ADM_findMpegStartCode(begin, end,&code,&off))
-    	{
-        	if(code==0xb6)
-			{
-				// Analyse a bit the vop header
-				uint8_t coding_type=begin[off];
-				coding_type>>=6;
-				aprintf("\t at %u %d Img type:%s\n",off,*nb,s_voptype[coding_type]);
-				switch(coding_type)
-				{
-					case 0: voptype=AVI_KEY_FRAME;break;
-					case 1: voptype=0;break;
-					case 2: voptype=AVI_B_FRAME;break;
-					case 3: printf("Glouglou\n");voptype=0;break;
-				
-				}
-        	                vop[*nb].offset=globalOff+off-4;
-				vop[*nb].type=voptype;
 
-				
-                                
-                                /* Get more info */
-                                if( extractVopInfo(begin+off, end-begin-off, *timeincbits,&vopType,&modulo, &time_inc,&vopcoded))
-                                {
-                                    aprintf(" frame found: vopType:%x modulo:%d time_inc:%d vopcoded:%d\n",vopType,modulo,time_inc,vopcoded);
-                                    vop[*nb].modulo=modulo;
-                                    vop[*nb].timeInc=time_inc;
-                                    vop[*nb].vopCoded=vopcoded;
-                                }
-                                *nb=(*nb)+1;
-                                begin+=off+1;
-				globalOff+=off+1;
-				continue;
-			
-			}
-                else if(code==0x20 && off>=4	) // Vol start
-                {
-                  
-                   if(extractMpeg4Info(begin+off-4,end+4-off-begin,&w,&h,timeincbits))
-                   {
-                      aprintf("Found Vol header : w:%d h:%d timeincbits:%d\n",w,h,*timeincbits);
-                   }
-                  
-                }
-        	begin+=off;
-        	globalOff+=off;
-        	continue;
-    	}
-    	return 1; 
-    }   
-	return 1;
-}

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_videoInfoExtractor.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_videoInfoExtractor.h	2009-09-16 17:36:16 UTC (rev 5331)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_video/ADM_videoInfoExtractor.h	2009-09-16 17:36:23 UTC (rev 5332)
@@ -17,10 +17,21 @@
 
 uint8_t extractMpeg4Info(uint8_t *data,uint32_t dataSize,uint32_t *w,uint32_t *h,uint32_t *time_inc);
 uint8_t extractH263Info(uint8_t *data,uint32_t dataSize,uint32_t *w,uint32_t *h);
-uint8_t extractVopInfo(uint8_t *data, uint32_t len,uint32_t timeincbits,uint32_t *vopType,uint32_t *modulo, uint32_t *time_inc);
+uint8_t extractVopInfo(uint8_t *data, uint32_t len,uint32_t timeincbits,uint32_t *vopType,uint32_t *modulo, uint32_t *time_inc,uint32_t *vopcoded);
 uint8_t extractSPSInfo(uint8_t *data, uint32_t len,uint32_t *wwidth,uint32_t *hheight);
 uint8_t extractH264FrameType(uint32_t nalSize,uint8_t *buffer,uint32_t len,uint32_t *flags);
 uint8_t extractH264FrameType_startCode(uint32_t nalSize,uint8_t *buffer,uint32_t len,uint32_t *flags);
 
+typedef struct ADM_vopS
+{
+	uint32_t offset;
+	uint32_t type;
+    uint32_t vopCoded;
+    uint32_t modulo;
+    uint32_t timeInc;
+}vopS;
+#define MAX_VOP 9
+uint8_t ADM_findMpegStartCode(uint8_t *start, uint8_t *end,uint8_t *outstartcode,uint32_t *offset);
+uint32_t ADM_searchVop(uint8_t *begin, uint8_t *end,uint32_t *nb, ADM_vopS *vop,uint32_t *timeincbits);
 #endif
 //EOF



From mean at mail.berlios.de  Wed Sep 16 19:47:41 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 16 Sep 2009 19:47:41 +0200
Subject: [Avidemux-svn-commit] r5333 - in
	branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters:
	. CurveEditor CurveEditor/qt4
Message-ID: <200909161747.n8GHlflP010207@sheep.berlios.de>

Author: mean
Date: 2009-09-16 19:47:34 +0200 (Wed, 16 Sep 2009)
New Revision: 5333

Added:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/ADM_Point.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/ADM_PointArrayList.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/ADM_PointArrayList.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/ADM_Utils.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/ADM_vidCurveEditor.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/ADM_vidCurveEditor.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/ADM_vidCurveEditor_param.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/qt4/
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/qt4/CurveDialog.ui
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/qt4/Q_CurveDialog.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/qt4/Q_CurveDialog.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/qt4/T_PaintWidget.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/qt4/T_PaintWidget.h
Modified:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CMakeLists.txt
Log:
[plugin] Curve editor, by janec

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CMakeLists.txt	2009-09-16 17:36:23 UTC (rev 5332)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CMakeLists.txt	2009-09-16 17:47:34 UTC (rev 5333)
@@ -56,3 +56,4 @@
 # Dependancy toward codec & pics ADD_SUBDIRECTORY(Animated)
 #ADD_SUBDIRECTORY(leakKernelDeint)
 ADD_SUBDIRECTORY(TIsophote)
+ADD_SUBDIRECTORY(CurveEditor)

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/ADM_Point.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/ADM_Point.h	2009-09-16 17:36:23 UTC (rev 5332)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/ADM_Point.h	2009-09-16 17:47:34 UTC (rev 5333)
@@ -0,0 +1,33 @@
+#ifndef POINT_H
+#define POINT_H
+
+#include <stdio.h>
+#include <math.h>
+
+#define POINT_RADIUS 6.0f
+
+typedef struct point {
+    int x;
+    int y;
+    point(int x = 0, int y = 0): x(x), y(y) {}
+    point(const point &src) { x = src.x; y = src.y; }
+    point(const char *str)
+    {
+        if (str) sscanf(str, "[%d;%d]", &x, &y);
+        else x = y = -1;
+    }
+    void set(int newx, int newy) { x = newx; y = newy; }
+    bool contains(int testx, int testy) const
+    {
+        return sqrt((testx-x)*(testx-x) + (testy-y)*(testy-y)) < POINT_RADIUS;
+    }
+    int serialize(char *str)
+    {
+        return sprintf(str, "[%d;%d]", x, y);
+    }
+    void print() { printf("[%d;%d]", x, y); }
+    void println() { printf("[%d;%d]\n", x, y); }
+} Point, *p_Point;
+
+#endif
+

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/ADM_PointArrayList.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/ADM_PointArrayList.cpp	2009-09-16 17:36:23 UTC (rev 5332)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/ADM_PointArrayList.cpp	2009-09-16 17:47:34 UTC (rev 5333)
@@ -0,0 +1,260 @@
+/*
+                        ADM_PointArrayList.cpp
+                        ----------------------
+    This module is specialized implementation of array list. It can insert
+    or remove points from list at specified position. Maximum capacity
+    of PointArrayList is set to value 32 (ADM_PointArrayList.h).
+    PointArrayList can be also serialized (or deserialized) to convert
+    class data into string (from string).
+    email: george.janec at gmail.com
+    
+    Copyright (C) 2009 Jiri Janecek
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+
+#include "ADM_Utils.h"
+#include "ADM_PointArrayList.h"
+
+
+/*
+ * Initialization of class parameters.
+ */
+PointArrayList::PointArrayList()
+{
+    itemCount = 0;
+    reset();
+}
+
+/*
+ * Destroying whole list.
+ */
+PointArrayList::~PointArrayList()
+{
+    freeMem();
+}
+
+/*
+ * Copies parameters from input object src.
+ */
+void PointArrayList::copy(const PointArrayList &src)
+{
+    freeMem();
+    itemCount = src.itemCount;
+    for (register int i = 0; i < itemCount; i++)
+    {
+        items[i] = new Point(*src.items[i]);
+    }
+}
+
+/*
+ * Frees all items of list.
+ */
+void PointArrayList::freeMem()
+{
+    for (register int i = 0; i < itemCount; i++)
+    {
+        if (items[i]) delete items[i];
+    }
+    memset(items, 0, sizeof(items));
+    itemCount = 0;
+}
+
+/*
+ * Sets default list.
+ */
+void PointArrayList::reset()
+{
+    freeMem();
+    items[0] = new Point(0, 0);
+    items[1] = new Point(255, 255);
+    itemCount = 2;
+}
+
+/*
+ * If list is empty returns true else returns false.
+ */
+bool PointArrayList::isEmpty() const
+{
+    return itemCount == 0;
+}
+
+/*
+ * Returns item count.
+ */
+int PointArrayList::count() const
+{
+    return itemCount;
+}
+
+/*
+ * Returns pointer to structure Point on specified position index.
+ * If index is out of bounds then resulting value is NULL.
+ */
+p_Point PointArrayList::get(const int index) const
+{
+    if (index >= 0 && index < itemCount) return items[index];
+    if (itemCount == 0)
+    {
+        printf("Error: List is empty!\n");
+    }
+    else
+    {
+        printf("Error: Index out of bounds (0,%d)! ", itemCount-1);
+        PRINT_VAR(index);
+    }
+    return NULL;
+}
+
+/*
+ * Searches list for key x (member of Point).
+ * Returns position of Point if item exists. If item does not exist, method
+ * returns insert position coded as -(insert_position + 1).
+ */
+int PointArrayList::search(const int x) const
+{
+    register int i;
+    for (i = 0; i < itemCount && items[i]->x < x; i++)
+        ;
+    if (i == itemCount || items[i]->x != x)
+        return -(i+1);  // can't find x, returns -(insert_position + 1)
+    else
+        return i;       // successfully found, returns item index.
+}
+
+/*
+ * Inserts new Point at position index.
+ */
+bool PointArrayList::insert(const int index, int x, int y)
+{
+    if (itemCount >= LIST_CAPACITY) return false;
+    
+    if (index < 0 || index > itemCount)
+    {
+        printf("Error: Index out of bounds (0,%d)! ", itemCount);
+        PRINT_VAR(index);
+        return false;
+    }
+
+    // data shifting to the right
+    for (register int i = itemCount - 1; i >= index; i--)
+    {
+        items[i+1] = items[i];
+    }
+    items[index] = new Point(x, y);  // insert at position index
+    itemCount++;
+    return true;
+}
+
+/*
+ * Removes item at position index.
+ */
+void PointArrayList::remove(const int index)
+{
+    if (itemCount < 3) return;
+
+    if (index < 0 || index > itemCount-1)
+    {
+        printf("Error: Index out of bounds (0,%d)! ", itemCount-1);
+        PRINT_VAR(index);
+        return;
+    }
+    
+    if (items[index]) delete items[index];
+    
+    // data shifting to the left
+    if (index < itemCount - 1)
+    {
+        memcpy(&items[index], &items[index+1], (itemCount - index - 1) * sizeof(p_Point));
+    }
+    items[itemCount - 1] = NULL;
+    itemCount--;
+}
+
+/*
+ * Serializes class parameters into string.
+ */
+char *PointArrayList::serialize() const
+{
+    char *tempPtr = new char[24 + itemCount * 26 + 1];
+    char itemStr[26];
+    char *p = tempPtr;
+    p += sprintf(p, "%d;", itemCount);
+    for (int i = 0; i < itemCount; i++)
+    {
+        p += items[i]->serialize(p);
+        *p++ = ' ';
+    }
+    *p = '\0';
+    return tempPtr;
+}
+
+/*
+ * Restores class parameters from string.
+ */
+void PointArrayList::deserialize(char *str)
+{
+    char itemStr[26];
+    if (!str)
+    {
+        printf("Can't deserialize, because no input string specified! ");
+        PRINT_VAR(str);
+        return;
+    }
+    freeMem();
+    itemCount = atoi(strtok(str, ";"));
+    for (int i = 0; i < itemCount; i++)
+    {
+        items[i] = new Point(strtok(NULL, " "));
+    }
+}
+
+/* ===== Item printing methods (only for debuging) ===== */
+
+void PointArrayList::println() const
+{
+    printf("PointArrayList(c:%d):\n{", itemCount);
+    items[0]->print();
+    for (register int i = 1; i < itemCount; i++)
+    {
+        printf(",");
+        items[i]->print();
+    }
+    printf("}\n");
+}
+
+void PointArrayList::printAll() const
+{
+    printf("PointArrayList(c:%d):\n{", itemCount);
+    if (items[0] == NULL)
+        printf("NULL");
+    else {
+        printf("0x%X", items[0]); items[0]->print();
+    }
+    for (register int i = 1; i < LIST_CAPACITY; i++)
+    {
+        printf(",");
+        if (items[i] == NULL)
+            printf("NULL");
+        else {
+            printf("0x%X", items[i]); items[i]->print();
+        }
+    }
+    printf("}\n");
+}
+

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/ADM_PointArrayList.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/ADM_PointArrayList.h	2009-09-16 17:36:23 UTC (rev 5332)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/ADM_PointArrayList.h	2009-09-16 17:47:34 UTC (rev 5333)
@@ -0,0 +1,32 @@
+#ifndef POINT_ARRAY_LIST_H
+#define POINT_ARRAY_LIST_H
+
+#include "ADM_Point.h"
+
+#define LIST_CAPACITY 32
+
+
+class PointArrayList {
+private:
+    int itemCount;
+    p_Point items[LIST_CAPACITY];
+
+public:
+    PointArrayList();
+    ~PointArrayList();
+    void copy(const PointArrayList &src);
+    void freeMem();
+    void reset();
+    bool isEmpty() const;
+    int count() const;
+    p_Point get(const int index) const;
+    int search(const int x) const;
+    bool insert(const int index, int x, int y);
+    void remove(const int index);
+    char *serialize() const;
+    void deserialize(char *str);
+    void println() const;
+    void printAll() const;
+};
+
+#endif // POINT_ARRAY_LIST

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/ADM_Utils.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/ADM_Utils.h	2009-09-16 17:36:23 UTC (rev 5332)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/ADM_Utils.h	2009-09-16 17:47:34 UTC (rev 5333)
@@ -0,0 +1,21 @@
+#ifndef UTILS_H
+#define UTILS_H
+
+#define PRINT_VAR(x) printf("[%s:%d] "#x"=%d (0x%X)\n", __FILE__, __LINE__, x, x);
+
+//#ifdef __DEBUG__
+#define PRINT_BEGIN() printf("BEGIN[%s:%d]\n", __FILE__, __LINE__);
+#define PRINT_MARK() printf("MARK[%s:%d]\n", __FILE__, __LINE__);
+#define PRINT_END() printf("END[%s:%d]\n", __FILE__, __LINE__);
+/*#else
+#define PRINT_BEGIN()
+#define PRINT_MARK()
+#define PRINT_END()
+#endif*/
+
+#define ROUND(x) ((x)>=0 ? (int)((x) + 0.5f) : (int)((x) - 0.5f))
+
+#define BOUNDS(index, max) ((index) >= 0 && (index) <= (max))
+
+#endif
+

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/ADM_vidCurveEditor.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/ADM_vidCurveEditor.cpp	2009-09-16 17:36:23 UTC (rev 5332)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/ADM_vidCurveEditor.cpp	2009-09-16 17:47:34 UTC (rev 5333)
@@ -0,0 +1,256 @@
+/*
+                        ADM_vidCurveEditor.cpp
+                        ----------------------
+    This program is creating spline curves that can be used for colour
+    adjustment. You can edit three curves in YUV colour space.
+    email: george.janec at gmail.com
+    
+    Copyright (C) 2009 Jiri Janecek
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "ADM_Utils.h"
+#include "ADM_PointArrayList.h"
+#include "ADM_vidCurveEditor.h"
+
+#ifdef SETS
+#undef SETS
+#endif
+#define SETS(x,y) (*couples)->setCouple(x,y)
+
+#ifdef GETS
+#undef GETS
+#endif
+#define GETS(x,y) ADM_assert(couples->getCouple(x,&y))
+
+
+static FILTER_PARAM curveParam = {6,
+    {"pointsY", "pointsU", "pointsV", "tableY", "tableU", "tableV"}
+};
+
+VF_DEFINE_FILTER_UI(
+    CurveEditor,                            // class name
+    curveParam,                             // filter parameters
+    curveEditor,                            // library name
+    QT_TR_NOOP("Color Curve Editor"),       // string name
+    1,                                      // version
+    VF_COLORS,                              // family
+    QT_TR_NOOP("Color adjustment by color curves in YUV color space."));
+
+
+extern uint8_t DIA_RunCurveDialog(p_ColorCurveParam param,
+    AVDMGenericVideoStream *in);
+
+
+/*
+ * Serializes transformation table into string representation. Created string
+ * is saved to couples.
+ */
+void CurveEditor::serializeTable(const uint8_t *table, const char *name,
+    CONFcouple **couples)
+{
+    ADM_assert(table);
+    ADM_assert(name);
+    char *tempStr = new char[256 * 4 + 1];
+    ADM_assert(tempStr);
+    char *p = tempStr;
+    for (int i = 0; i < 256; i++)
+    {
+        p += sprintf(p, "%d,", table[i]);
+    }
+    SETS(name, tempStr);
+    delete [] tempStr;
+}
+
+/*
+ * Restores transformation table from input string to table address table.
+ */
+void CurveEditor::deserializeTable(uint8_t *table, const char *name,
+    CONFcouple *couples)
+{
+    char *token = NULL;
+    ADM_assert(table);
+    ADM_assert(name);
+    GETS(name, token);
+    ADM_assert(token);
+    token = strtok(token, ",");
+    for (int i = 0; i < 256; i++)
+    {
+        table[i] = (uint8_t) atoi(token);
+        token = strtok(NULL, ",");
+    }
+    ADM_dealloc(token);
+}
+
+/*
+ * Creates temporary image buffer _uncompressed for uncompressed frames.
+ * If couples is not NULL then filter parameters are restored from couples
+ * else default values are adjusted.
+ */
+CurveEditor::CurveEditor(AVDMGenericVideoStream *in, CONFcouple *couples)
+{
+    ADM_assert(in);
+    _in = in;
+    memcpy(&_info, _in->getInfo(), sizeof(_info));
+    _info.encoding = 1;
+    _uncompressed = new ADMImage(_in->getInfo()->width, _in->getInfo()->height);
+    ADM_assert(_uncompressed);
+
+    if (couples != NULL)
+    {
+        char *tempStr = NULL;
+        GETS("pointsY",tempStr);
+        _param.points[0].deserialize(tempStr);
+        if (tempStr) ADM_dealloc(tempStr);
+        GETS("pointsU",tempStr);
+        _param.points[1].deserialize(tempStr);
+        if (tempStr) ADM_dealloc(tempStr);
+        GETS("pointsV",tempStr);
+        _param.points[2].deserialize(tempStr);
+        if (tempStr) ADM_dealloc(tempStr);
+        deserializeTable(_param.table[0], "tableY", couples);
+        deserializeTable(_param.table[1], "tableU", couples);
+        deserializeTable(_param.table[2], "tableV", couples);
+    }
+    else
+    {
+        for (int i = 0; i < 256; i++)
+        {
+            _param.table[0][i] = _param.table[1][i] = _param.table[2][i] = i;
+        }
+    }
+}
+
+/*
+ * Frees uncompressed image buffer.
+ */
+CurveEditor::~CurveEditor()
+{
+    delete _uncompressed;
+    _uncompressed = NULL;
+}
+
+/*
+ * Returns filter configuration in string.
+ */
+char *CurveEditor::printConf(void)
+{
+    static char buf[0xFF];
+    sprintf((char *) buf, QT_TR_NOOP("Control points count: Y:%d, U:%d, V:%d"),
+        _param.points[0].count(),
+        _param.points[1].count(),
+        _param.points[2].count());
+    return buf;
+}
+
+/*
+ * Creates couples of current parameters.
+ */
+uint8_t CurveEditor::getCoupledConf(CONFcouple **couples)
+{
+    *couples = new CONFcouple(6); // Number of param in your structure
+    char *tempStr = _param.points[0].serialize();
+    SETS("pointsY", tempStr);
+    if (tempStr) delete [] tempStr;
+    tempStr = _param.points[1].serialize();
+    SETS("pointsU", tempStr);
+    if (tempStr) delete [] tempStr;
+    tempStr = _param.points[2].serialize();
+    SETS("pointsV", tempStr);
+    if (tempStr) delete [] tempStr;
+    serializeTable(_param.table[0], "tableY", couples);
+    serializeTable(_param.table[1], "tableU", couples);
+    serializeTable(_param.table[2], "tableV", couples);
+    return 1;
+}
+
+/*
+ * Opens configuration dialog for adjusting parameters.
+ */
+uint8_t CurveEditor::configure(AVDMGenericVideoStream *in)
+{
+    _in=in;
+    return DIA_RunCurveDialog(&_param, in);
+}
+
+/*
+ * Core method for applying filter at specified frame number.
+ */
+uint8_t CurveEditor::getFrameNumberNoAlloc(uint32_t frame,
+    uint32_t *len,
+    ADMImage *data,
+    uint32_t *flags)
+{
+    if(frame >= _info.nb_frames)
+        return 0;
+    // read uncompressed frame
+    if(!_in->getFrameNumberNoAlloc(frame, len, _uncompressed, flags))
+        return 0;
+
+    uint8_t *in, *out;
+    uint8_t *currTable;
+
+    uint32_t stride = _info.width;
+    uint32_t hstride = stride / 2;
+    uint32_t h = _info.height;
+    uint32_t hh = h / 2;
+
+    // edit luma
+    in = YPLANE(_uncompressed);
+    out = YPLANE(data);
+    currTable = _param.table[0];
+    for (uint32_t y = 0; y < h; y++)
+    {
+        for (uint32_t x = 0; x < stride; x++)
+        {
+            *(out + x) = currTable[*(in + x)];  // colour transformation
+        }
+        in += stride;
+        out += stride;
+    }
+
+    // edit chroma (U)
+    in = UPLANE(_uncompressed);
+    out = UPLANE(data);
+    currTable = _param.table[1];
+    for(uint32_t y = 0; y < hh; y++)
+    {
+        for (uint32_t x = 0; x < hstride; x++)
+        {
+            *(out + x) = currTable[*(in + x)];
+        }
+        in += hstride;
+        out += hstride;
+    }
+
+    // edit chroma (V)
+    in = VPLANE(_uncompressed);
+    out = VPLANE(data);
+    currTable = _param.table[2];
+    for(uint32_t y = 0; y < hh; y++)
+    {
+        for (uint32_t x = 0; x < hstride; x++)
+        {
+            *(out + x) = currTable[*(in + x)];
+        }
+        in += hstride;
+        out += hstride;
+    }
+
+    data->copyInfo(_uncompressed);
+
+    return 1;
+}
+

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/ADM_vidCurveEditor.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/ADM_vidCurveEditor.h	2009-09-16 17:36:23 UTC (rev 5332)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/ADM_vidCurveEditor.h	2009-09-16 17:47:34 UTC (rev 5333)
@@ -0,0 +1,31 @@
+#ifndef CURVE_EDITOR_H
+#define CURVE_EDITOR_H
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+
+#include "ADM_default.h"
+#include "ADM_videoFilterDynamic.h"
+
+#include "ADM_vidCurveEditor_param.h"
+
+
+class CurveEditor: public AVDMGenericVideoStream {
+    private:
+        void serializeTable(const uint8_t *table, const char *name, CONFcouple **couples);
+        void deserializeTable(uint8_t *table, const char *name, CONFcouple *couples);
+    protected:
+        AVDMGenericVideoStream *_in;
+        ColorCurveParam _param;
+        virtual char *printConf(void);
+    public:
+        CurveEditor(AVDMGenericVideoStream *in, CONFcouple *setup);
+        virtual ~CurveEditor();
+        virtual uint8_t getCoupledConf(CONFcouple **couples);
+        virtual uint8_t configure(AVDMGenericVideoStream *in);
+        virtual uint8_t getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
+            ADMImage *data, uint32_t *flags);
+};
+
+#endif // CURVE_EDITOR_H

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/ADM_vidCurveEditor_param.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/ADM_vidCurveEditor_param.h	2009-09-16 17:36:23 UTC (rev 5332)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/ADM_vidCurveEditor_param.h	2009-09-16 17:47:34 UTC (rev 5333)
@@ -0,0 +1,18 @@
+#ifndef CURVE_EDITOR_PARAM_H
+#define CURVE_EDITOR_PARAM_H
+
+#include "ADM_PointArrayList.h"
+
+/*
+ * Filter parameters.
+ */
+typedef struct
+{
+    // Lists of control points.
+    PointArrayList points[3];
+    // Transformation colour tables with bounds 0..255.
+    unsigned char table[3][256];
+} ColorCurveParam, *p_ColorCurveParam;
+
+#endif
+

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/CMakeLists.txt	2009-09-16 17:36:23 UTC (rev 5332)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/CMakeLists.txt	2009-09-16 17:47:34 UTC (rev 5333)
@@ -0,0 +1,16 @@
+INCLUDE(vf_plugin)
+
+
+SET(curveEditorCommon_SRCS
+    ADM_vidCurveEditor.cpp  ADM_PointArrayList.cpp
+)
+
+INCLUDE(vf_plugin_qt4)
+
+SET(curveEditorQT_SRCS  qt4/Q_CurveDialog.cpp qt4/T_PaintWidget.cpp)
+SET(curveEditorQT_HEADERS   qt4/Q_CurveDialog.h qt4/T_PaintWidget.h)
+SET(curveEditorQT_UI    qt4/CurveDialog)
+
+INIT_VIDEOFILTER_PLUGIN_QT4(ADM_vf_curveEditor_qt4
+    "${curveEditorQT_SRCS}" "${curveEditorQT_HEADERS}" "${curveEditorQT_UI}" "${curveEditorCommon_SRCS}")
+

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/qt4/CurveDialog.ui
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/qt4/CurveDialog.ui	2009-09-16 17:36:23 UTC (rev 5332)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/qt4/CurveDialog.ui	2009-09-16 17:47:34 UTC (rev 5333)
@@ -0,0 +1,158 @@
+<ui version="4.0" >
+ <class>CurveDialog</class>
+ <widget class="QDialog" name="CurveDialog" >
+  <property name="windowModality" >
+   <enum>Qt::WindowModal</enum>
+  </property>
+  <property name="geometry" >
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>305</width>
+    <height>100</height>
+   </rect>
+  </property>
+  <property name="focusPolicy" >
+   <enum>Qt::ClickFocus</enum>
+  </property>
+  <property name="windowTitle" >
+   <string>Curve Editor</string>
+  </property>
+  <layout class="QVBoxLayout" name="mainVerticalLayout" >
+   <item>
+    <layout class="QHBoxLayout" name="curveToolsLayout" >
+     <item>
+      <widget class="QComboBox" name="channelComboBox" >
+       <property name="toolTip" >
+        <string>Choose channel for editing</string>
+       </property>
+       <property name="currentIndex" >
+        <number>0</number>
+       </property>
+       <property name="maxCount" >
+        <number>4</number>
+       </property>
+       <item>
+        <property name="text" >
+         <string>Luma (Y)</string>
+        </property>
+       </item>
+       <item>
+        <property name="text" >
+         <string>Chroma (U)</string>
+        </property>
+       </item>
+       <item>
+        <property name="text" >
+         <string>Chroma (V)</string>
+        </property>
+       </item>
+      </widget>
+     </item>
+     <item>
+      <widget class="QPushButton" name="defaultButton" >
+       <property name="sizePolicy" >
+        <sizepolicy vsizetype="Fixed" hsizetype="Fixed" >
+         <horstretch>0</horstretch>
+         <verstretch>0</verstretch>
+        </sizepolicy>
+       </property>
+       <property name="toolTip" >
+        <string>Sets default curve</string>
+       </property>
+       <property name="text" >
+        <string>Refresh</string>
+       </property>
+      </widget>
+     </item>
+     <item>
+      <spacer name="horizontalSpacer" >
+       <property name="orientation" >
+        <enum>Qt::Horizontal</enum>
+       </property>
+       <property name="sizeType" >
+        <enum>QSizePolicy::Expanding</enum>
+       </property>
+       <property name="sizeHint" stdset="0" >
+        <size>
+         <width>10</width>
+         <height>0</height>
+        </size>
+       </property>
+      </spacer>
+     </item>
+     <item>
+      <widget class="QPushButton" name="helpButton" >
+       <property name="sizePolicy" >
+        <sizepolicy vsizetype="Fixed" hsizetype="Fixed" >
+         <horstretch>0</horstretch>
+         <verstretch>0</verstretch>
+        </sizepolicy>
+       </property>
+       <property name="text" >
+        <string>Help</string>
+       </property>
+      </widget>
+     </item>
+    </layout>
+   </item>
+   <item>
+    <widget class="QDialogButtonBox" name="buttonBox" >
+     <property name="sizePolicy" >
+      <sizepolicy vsizetype="Fixed" hsizetype="Expanding" >
+       <horstretch>0</horstretch>
+       <verstretch>0</verstretch>
+      </sizepolicy>
+     </property>
+     <property name="layoutDirection" >
+      <enum>Qt::LeftToRight</enum>
+     </property>
+     <property name="orientation" >
+      <enum>Qt::Horizontal</enum>
+     </property>
+     <property name="standardButtons" >
+      <set>QDialogButtonBox::Cancel|QDialogButtonBox::Ok</set>
+     </property>
+     <property name="centerButtons" >
+      <bool>false</bool>
+     </property>
+    </widget>
+   </item>
+  </layout>
+ </widget>
+ <resources/>
+ <connections>
+  <connection>
+   <sender>buttonBox</sender>
+   <signal>accepted()</signal>
+   <receiver>CurveDialog</receiver>
+   <slot>accept()</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>257</x>
+     <y>491</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>157</x>
+     <y>274</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>buttonBox</sender>
+   <signal>rejected()</signal>
+   <receiver>CurveDialog</receiver>
+   <slot>reject()</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>264</x>
+     <y>491</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>273</x>
+     <y>274</y>
+    </hint>
+   </hints>
+  </connection>
+ </connections>
+</ui>

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/qt4/Q_CurveDialog.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/qt4/Q_CurveDialog.cpp	2009-09-16 17:36:23 UTC (rev 5332)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/qt4/Q_CurveDialog.cpp	2009-09-16 17:47:34 UTC (rev 5333)
@@ -0,0 +1,141 @@
+/*
+                          Q_CurveDialog.cpp
+                          -----------------
+    This module including declaration of CurveDialog class that shows main
+    dialog window of this filter. Curve painting mechanism is located in
+    PaintWidget class (T_PaintWidget.cpp).
+    email: george.janec at gmail.com
+    
+    Copyright (C) 2009 Jiri Janecek
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include <string.h>
+
+#include <QtGui/QMessageBox>
+#include <QtGui/QApplication>
+
+#include "ADM_toolkitQt.h"
+
+#include "Q_CurveDialog.h"
+#include "ADM_Utils.h"
+#include "ADM_vidCurveEditor_param.h"
+
+
+/* =========================== *
+ *    Method implementation    *
+ * =========================== */
+
+/*
+ * Initialization of all window components (widgets) and saving input filter
+ * parameters.
+ */
+CurveDialog::CurveDialog(QWidget *parent, p_ColorCurveParam param,
+    AVDMGenericVideoStream *in) : QDialog(parent)
+{
+    setupUi(this);
+    ADM_assert(param);
+    ADM_assert(in);
+    paintWidget = new PaintWidget(this, param);
+    mainVerticalLayout->insertWidget(mainVerticalLayout->count()-1, paintWidget);
+}
+
+/*
+ * Handles key pressing events.
+ */
+void CurveDialog::keyPressEvent(QKeyEvent *event)
+{
+    if (event->key() == Qt::Key_Delete && paintWidget->isSelected())
+    {
+        paintWidget->removePoint(paintWidget->getSelectedIndex());
+    }
+    else
+    {
+        QWidget::keyPressEvent(event);
+    }
+}
+
+/*
+ * Handles key releasing events.
+ */
+void CurveDialog::keyReleaseEvent(QKeyEvent *event)
+{
+    QWidget::keyReleaseEvent(event);
+}
+
+/*
+ * Changes active color channel.
+ */
+void CurveDialog::on_channelComboBox_currentIndexChanged(int index)
+{
+    paintWidget->setCurrentChannel(index);
+}
+
+/*
+ * Sets default curve on current channel.
+ */
+void CurveDialog::on_defaultButton_clicked()
+{
+    paintWidget->resetPoints();
+}
+
+/*
+ * Shows help dialog.
+ */
+void CurveDialog::on_helpButton_clicked()
+{
+    static char msg[] = "<h2>Color Curve Editor for Avidemux 2.5</h2>\n"
+    "<b>email: george.janec at gmail.com</b>\n"
+    "<p>This program is creating spline curves that can be used for colour "
+    "adjustment. You can edit three curves in YUV colour space.</p>\n"
+    "<i>Copyright (C) 2009 Jiri Janecek</i>\n"
+    "<p><i>This program is distributed in the hope that it will be useful, "
+    "but WITHOUT ANY WARRANTY; without even the implied warranty of "
+    "MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the "
+    "GNU General Public License for more details.</i></p>\n"
+    "<h3>Program usage</h3>\n"
+    "<p>Colour channel can be selected by pop-up list located at top-left part "
+    "of dialog window. Each channel is edited separately. New points can be "
+    "created by clicking on marked area. Moving points can be done by dragging "
+    "a point to a different location. Refresh button loads default curve. "
+    "Selected points (marked by red colour) can by erased by pressing Delete key.</p>";
+    QString qtitle = QString::fromUtf8("About");
+    QString qmsg = QString::fromUtf8(msg, sizeof(msg));
+    QMessageBox::information(this, qtitle, qmsg, QMessageBox::Ok, QMessageBox::Ok);
+}
+
+
+/* ============================================================== *
+ *     Implementation of function from ADM_vidCurveEditor.cpp     *
+ * ============================================================== */
+
+/*
+ * Shows filter dialog window. If dialog is confirmed by Ok button then local
+ * changes are applied on input parameters.
+ */
+uint8_t DIA_RunCurveDialog(p_ColorCurveParam param, AVDMGenericVideoStream *in)
+{
+    uint8_t retcode = 0;
+    CurveDialog mainDiag(qtLastRegisteredDialog(), param, in);
+    qtRegisterDialog(&mainDiag);
+    if (mainDiag.exec() == QDialog::Accepted)
+    {
+        mainDiag.paintWidget->applyChanges();
+        retcode = 1;
+    }
+    qtUnregisterDialog(&mainDiag);
+    return retcode;
+}
+

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/qt4/Q_CurveDialog.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/qt4/Q_CurveDialog.h	2009-09-16 17:36:23 UTC (rev 5332)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/qt4/Q_CurveDialog.h	2009-09-16 17:47:34 UTC (rev 5333)
@@ -0,0 +1,33 @@
+#ifndef CURVEDIALOG_H
+#define CURVEDIALOG_H
+
+#include <QtGui/QWidget>
+#include <QtGui/QKeyEvent>
+
+#include "ADM_default.h"
+#include "ADM_videoFilterDynamic.h"
+
+#include "ui_CurveDialog.h"
+#include "T_PaintWidget.h"
+#include "ADM_vidCurveEditor_param.h"
+
+
+class CurveDialog : public QDialog, public Ui::CurveDialog {
+    Q_OBJECT
+
+public:
+    PaintWidget *paintWidget;
+    CurveDialog(QWidget *parent, p_ColorCurveParam param, AVDMGenericVideoStream *in);
+
+protected:
+    void keyPressEvent(QKeyEvent *event);
+    void keyReleaseEvent(QKeyEvent *event);
+
+private slots:
+    void on_channelComboBox_currentIndexChanged(int index);
+    void on_defaultButton_clicked();
+    void on_helpButton_clicked();
+};
+
+#endif // CURVEDIALOG_H
+

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/qt4/T_PaintWidget.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/qt4/T_PaintWidget.cpp	2009-09-16 17:36:23 UTC (rev 5332)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/qt4/T_PaintWidget.cpp	2009-09-16 17:47:34 UTC (rev 5333)
@@ -0,0 +1,437 @@
+/*
+                          T_PaintWidget.cpp
+                          -----------------
+    This module including declaration of PaintWidget class that paints cubic
+    Hermite spline curve.
+    email: george.janec at gmail.com
+    
+    Copyright (C) 2009 Jiri Janecek
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include <stdlib.h>
+#include <math.h>
+
+#include <QtCore/QString>
+#include <QtCore/QSize>
+#include <QtGui/QPainter>
+#include <QtGui/QSizePolicy>
+
+#include "ADM_default.h"
+
+#include "T_PaintWidget.h"
+#include "ADM_Utils.h"
+
+
+/* ======================== *
+ *    Macro declaration     *
+ * ======================== */
+
+/*
+ * Crops input value in defined bounds (min, max).
+ * Result is saved to value.
+ */
+#define CLAMP(val, min, max) \
+    (val) = (val) < (min) ? (min) : (val) > (max) ? (max) : (val)
+
+/*
+ * Flips vertical coordinate to convert window coords to real coords.
+ */
+#define FLIP(y) (255 - (y))
+
+/*
+ * Calculates real coordinate by scaling factor.
+ */
+#define SCALE(x) ROUND((x) * scaleFactor)
+#define RESCALE(b) ROUND((b) / scaleFactor)
+
+/*
+ * CP = Current point(index)
+ * CT = Current table(index)
+ */
+#define CP(index) p_param->points[currentChannel].get(index)
+#define CT(index) p_param->table[currentChannel][index]
+
+/*
+ * Calculates one-sided difference from point at index k.
+ */
+#define DIFF(k) (float)(CP(k+1)->y - CP(k)->y) / (CP(k+1)->x - CP(k)->x)
+
+
+/* =========================== *
+ *    Method implementation    *
+ * =========================== */
+
+/*
+ * Components are initialized here and input parameters in_param are copied to
+ * temporary variable p_param.
+ */
+PaintWidget::PaintWidget(QWidget *parent, p_ColorCurveParam param)
+    : QWidget(parent)
+{
+    setObjectName(QString::fromUtf8("PaintWidget"));
+    QSizePolicy sizePolicy1(QSizePolicy::Expanding, QSizePolicy::Expanding);
+    sizePolicy1.setHorizontalStretch(0);
+    sizePolicy1.setVerticalStretch(0);
+    sizePolicy1.setHeightForWidth(this->sizePolicy().hasHeightForWidth());
+    setSizePolicy(sizePolicy1);
+    setMinimumSize(QSize(256, 256));
+    setCursor(Qt::OpenHandCursor);
+    setMouseTracking(true);
+
+    in_param = param;   // save address of original parameters
+    p_param = new ColorCurveParam();
+    p_param->points[0].copy(in_param->points[0]);
+    p_param->points[1].copy(in_param->points[1]);
+    p_param->points[2].copy(in_param->points[2]);
+    memcpy(p_param->table, in_param->table, sizeof(in_param->table));
+
+    scaleFactor = 1.0f;
+    currentChannel = 0;
+    selectedIndex = -1;
+    dragging = false;
+    *posText = '\0';        // empty string
+}
+
+/*
+ * Delete local parameters.
+ */
+PaintWidget::~PaintWidget()
+{
+    if (p_param) delete p_param;
+}
+
+/*
+ * Overwrites original parameters in_param with values stored in p_param.
+ */
+void PaintWidget::applyChanges() const
+{
+    in_param->points[0].copy(p_param->points[0]);
+    in_param->points[1].copy(p_param->points[1]);
+    in_param->points[2].copy(p_param->points[2]);
+    memcpy(in_param->table , p_param->table, sizeof(p_param->table));
+}
+
+/*
+ * Set active channel. Value must be between 0 and 2.
+ */
+void PaintWidget::setCurrentChannel(const int index)
+{
+    currentChannel = (index >= 0 && index <= 2) ? index : 0;
+    selectedIndex = -1;
+    update();
+}
+
+/*
+ * Returns true if some point is selected else false.
+ */
+bool PaintWidget::isSelected() const
+{
+    return selectedIndex != -1;
+}
+
+/*
+ * Returns index of selected point.
+ */
+int PaintWidget::getSelectedIndex() const
+{
+    return selectedIndex;
+}
+
+/*
+ * Removes point from list at index.
+ */
+void PaintWidget::removePoint(const int index)
+{
+    p_param->points[currentChannel].remove(index);
+    generateTable();
+    if (index == selectedIndex) selectedIndex = -1;
+    update();
+}
+
+/*
+ * Sets default curve.
+ */
+void PaintWidget::resetPoints()
+{
+    p_param->points[currentChannel].reset();
+    generateTable();
+    selectedIndex = -1;
+    update();
+}
+
+/*
+ * Calculates scaling factor for adjusting curve size.
+ */
+void PaintWidget::resizeEvent(QResizeEvent *event)
+{
+    QSize s = event->size();
+    if (s.width() != s.height())
+    {
+        int newSize = s.width() < s.height() ? s.width() : s.height();
+        resize(newSize, newSize);
+        scaleFactor = 256.0f / newSize;
+    }
+}
+
+/*
+ * Handles moving points over painting area.
+ */
+void PaintWidget::mouseMoveEvent(QMouseEvent *event)
+{
+    int x = SCALE(event->x());
+    int y = FLIP(SCALE(event->y()));
+    int count = p_param->points[currentChannel].count();
+    if (dragging && isSelected()) {
+        if (selectedIndex == 0) {
+            CLAMP(x, 0, CP(selectedIndex + 1)->x - 1);
+        } else if (selectedIndex == count-1) {
+            CLAMP(x, CP(selectedIndex - 1)->x + 1, 255);
+        } else {
+            CLAMP(x, CP(selectedIndex - 1)->x + 1, CP(selectedIndex + 1)->x - 1);
+        }
+        CLAMP(y, 0, 255);
+        CP(selectedIndex)->set(x, y);
+        generateTable();
+        sprintf(posText, "input: %d output: %d", x, y);
+    } else {
+        QWidget::mouseMoveEvent(event);
+    }
+    update();
+}
+
+/*
+ * Handles creating and selecting points by mouse clicking.
+ */
+void PaintWidget::mousePressEvent(QMouseEvent *event)
+{
+    int insPos;
+    int max = p_param->points[currentChannel].count() - 1;
+    int x = SCALE(event->x());
+    int y = SCALE(event->y());
+    if (event->button() == Qt::LeftButton
+            && x >= 0 && x <= 255 && y >= 0 && y <= 255) {
+        y = FLIP(y);
+        insPos = p_param->points[currentChannel].search(x);
+        insPos = insPos < 0 ? -(insPos + 1) : insPos;
+        // testing at most 3 points around middle point
+        int i = -1;
+        while (true)
+        {
+            if (BOUNDS(insPos + i, max) && CP(insPos + i)->contains(x, y))
+            {
+                selectedIndex = insPos + i;
+                break;
+            }
+            // terminating condition
+            if (i == 1)
+            {
+                if (p_param->points[currentChannel].insert(insPos, x, y))
+                {
+                    generateTable();
+                    selectedIndex = insPos;
+                }
+                else
+                {
+                    selectedIndex = -1;
+                }
+                break;
+            }
+            i++;
+        }
+        sprintf(posText, "input: %d output: %d", x, y);
+        dragging = true;
+        this->setCursor(Qt::ClosedHandCursor);
+        update();
+    } else if (event->button() == Qt::RightButton) {
+        selectedIndex = -1;
+        update();
+    } else {
+        QWidget::mousePressEvent(event);
+    }
+}
+
+/*
+ * Handles mouse release event.
+ */
+void PaintWidget::mouseReleaseEvent(QMouseEvent *event)
+{
+    if (event->button() == Qt::LeftButton) {
+        *posText = '\0';
+        dragging = false;
+        this->setCursor(Qt::OpenHandCursor);
+    }
+    else {
+        QWidget::mouseReleaseEvent(event);
+    }
+}
+
+/*
+ * Draws spline on widget.
+ */
+void PaintWidget::paintEvent(QPaintEvent *event)
+{
+    QWidget::paintEvent(event);
+    QPainter painter;
+
+    painter.begin(this);
+    painter.setRenderHint(QPainter::Antialiasing);
+    painter.setBrush(Qt::blue);
+    painter.fillRect(QRect(0, 0, this->width(), this->height()), QBrush(Qt::white));
+
+    painter.setPen(QColor::fromRgb(192, 192, 192));
+    painter.drawLine(RESCALE(63), RESCALE(0), RESCALE(63), RESCALE(255));
+    painter.drawLine(RESCALE(127), RESCALE(0), RESCALE(127), RESCALE(255));
+    painter.drawLine(RESCALE(191), RESCALE(0), RESCALE(191), RESCALE(255));
+
+    painter.drawLine(RESCALE(0), RESCALE(63), RESCALE(255), RESCALE(63));
+    painter.drawLine(RESCALE(0), RESCALE(127), RESCALE(255), RESCALE(127));
+    painter.drawLine(RESCALE(0), RESCALE(191), RESCALE(255), RESCALE(191));
+
+    painter.drawLine(RESCALE(0), RESCALE(255), RESCALE(255), RESCALE(0));
+
+    // drawing spline
+    painter.setPen(Qt::black);
+    for (int i = 1; i < 256; i++)
+    {
+        painter.drawLine(
+            RESCALE(i-1), RESCALE(FLIP(CT(i-1))),
+            RESCALE(i), RESCALE(FLIP(CT(i)))
+        );
+    }
+
+    // drawing control points
+    for (int i = 0; i < p_param->points[currentChannel].count(); i++) {
+        if (selectedIndex == i) {
+            painter.fillRect(
+                RESCALE(CP(i)->x) - 3,
+                RESCALE(FLIP(CP(i)->y)) - 3,
+                7, 7, QBrush(Qt::red)
+            );
+        }
+        else {
+            painter.fillRect(
+                RESCALE(CP(i)->x) - 3,
+                RESCALE(FLIP(CP(i)->y)) - 3,
+                7, 7, painter.brush()
+            );
+        }
+    }
+
+    if (posText[0] != '\0') {
+        painter.setFont(QFont("Arial", 10));
+        painter.drawText(6, 16, QString::fromUtf8(posText));
+    }
+
+    painter.end();
+}
+
+/*
+ * Calculates spline curve in segment between points pid1 and pid2 with
+ * tangents m1 and m2. Description of Cubic Hermite splines you can find at:
+ * http://en.wikipedia.org/wiki/Cubic_Hermite_spline
+ */
+inline void PaintWidget::hermiteInterp(int pid1, int pid2, float m1, float m2)
+{
+    float F1, F2, F3, F4;
+    int Q;
+    float Qf;
+    int intervalWidth = CP(pid2)->x - CP(pid1)->x;
+    float norm = 1.0f / intervalWidth;
+    float t, t2, t3;
+
+    CT(CP(pid1)->x) = CP(pid1)->y;
+    for (int i = 1; i <= intervalWidth; i++) {
+        t = i * norm;
+        t2 = t * t;
+        t3 = t2 * t;
+
+        F1 = 2*t3 - 3*t2 + 1;
+        F2 = -2*t3 + 3*t2;
+        F3 = t3 - 2*t2 + t;
+        F4 = t3 - t2;
+
+        // Calculates interpolation
+        Qf = CP(pid1)->y*F1 + CP(pid2)->y*F2 + m1*intervalWidth*F3 + m2*intervalWidth*F4;
+
+        Q = ROUND(Qf);      // rounding to integer
+        CLAMP(Q, 0, 255);   // cropping values <0, 255>
+
+        CT(CP(pid1)->x + i) = (uint8_t) Q;
+    }
+}
+
+/*
+ * Creates transformation table. First tangents are calculated.
+ * Finally interpolation method is called.
+ * Tangents are generated by algorithm described at Wikipedia:
+ * Monotone cubic Hermite interpolation
+ * http://en.wikipedia.org/wiki/Monotone_cubic_interpolation
+ */
+void PaintWidget::generateTable()
+{
+    int count = p_param->points[currentChannel].count();
+    float *m = new float[count];
+    float *sec = new float[count-1];
+
+    for (int i = 0; i < CP(0)->x; i++) {
+        CT(i) = CP(0)->y;
+    }
+
+    // data preprocessing
+    for (int i = 0; i < count - 1; i++) sec[i] = DIFF(i);
+
+    m[0] = DIFF(0);
+    m[count - 1] = DIFF(count - 2);
+    for (int i = 1; i < count - 1; i++) m[i] = (sec[i-1] + sec[i]) / 2.0f;
+
+    for (int i = 0; i < count - 1; i++)
+    {
+        float tmpSec = sec[i];
+        if (tmpSec == 0)
+        {
+            m[i] = m[i + 1] = 0;
+        }
+        else
+        {
+            float ak, bk;
+            float *m1 = &m[i];
+            float *m2 = &m[i + 1];
+            ak = *m1 / tmpSec;
+            bk = *m2 / tmpSec;
+            float cirEq = ak*ak + bk*bk;
+            if (cirEq > 9.0f)
+            {
+                float tk = 3.0f / sqrt(cirEq);
+                *m1 = *m1 * tk;
+                *m2 = *m2 * tk;
+            }
+        }
+    }
+
+    // cubic interpolation
+    for (int i = 0; i < count - 1; i++)
+    {
+        hermiteInterp(i, i + 1, m[i], m[i + 1]);
+    }
+
+    for (int i = CP(count-1)->x + 1; i < 256; i++) {
+        CT(i) = CP(count-1)->y;
+    }
+    
+    delete [] m;
+    delete [] sec;
+}
+

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/qt4/T_PaintWidget.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/qt4/T_PaintWidget.h	2009-09-16 17:36:23 UTC (rev 5332)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/qt4/T_PaintWidget.h	2009-09-16 17:47:34 UTC (rev 5333)
@@ -0,0 +1,45 @@
+#ifndef PAINTWIDGET_H
+#define PAINTWIDGET_H
+
+#include <QtGui/QWidget>
+#include <QtGui/QMouseEvent>
+#include <QtGui/QPaintEvent>
+
+#include "ADM_Point.h"
+#include "ADM_vidCurveEditor_param.h"
+
+
+class PaintWidget : public QWidget {
+    Q_OBJECT
+
+public:
+    PaintWidget(QWidget *parent, p_ColorCurveParam param);
+    ~PaintWidget();
+    void applyChanges() const;
+    void setCurrentChannel(const int index);
+    bool isSelected() const;
+    int getSelectedIndex() const;
+    void removePoint(const int index);
+    void resetPoints();
+
+protected:
+    void resizeEvent(QResizeEvent *event);
+    void mouseMoveEvent(QMouseEvent *event);
+    void mousePressEvent(QMouseEvent *event);
+    void mouseReleaseEvent(QMouseEvent *event);
+    void paintEvent(QPaintEvent *event);
+
+private:
+    p_ColorCurveParam in_param; // input parameters
+    p_ColorCurveParam p_param;  // local copy of input parameters
+    float scaleFactor;
+    int currentChannel;
+    int selectedIndex;
+    bool dragging;
+    char posText[48];
+    void hermiteInterp(int pid1, int pid2, float m1, float m2);
+    void generateTable();
+};
+
+#endif // PAINTWIDGET_H
+



From mean at mail.berlios.de  Wed Sep 16 19:56:12 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 16 Sep 2009 19:56:12 +0200
Subject: [Avidemux-svn-commit] r5334 - in branches/avidemux_2.6_branch_mean:
	avidemux/common avidemux_core/ADM_coreAudio/include
	avidemux_core/ADM_coreMuxer/src
	avidemux_plugins/ADM_audioDecoders/ADM_ad_vorbis
	avidemux_plugins/ADM_audioEncoders/vorbis
	avidemux_plugins/ADM_demuxers/Matroska
Message-ID: <200909161756.n8GHuCUv013559@sheep.berlios.de>

Author: mean
Date: 2009-09-16 19:56:02 +0200 (Wed, 16 Sep 2009)
New Revision: 5334

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/gui_audio.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/include/ADM_audioCodecEnum.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_coreMuxerFfmpeg.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_vorbis/ADM_ad_vorbis.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioEncoders/vorbis/audioencoder_vorbis.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkvIndexer.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkvTrackType.cpp
Log:
[Mkv] Add vorbis support to ffmpeg based muxers + rename WAV_OGG to WAV_OGG_VORBIS which is still bad, but less

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/gui_audio.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/gui_audio.cpp	2009-09-16 17:47:34 UTC (rev 5333)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/gui_audio.cpp	2009-09-16 17:56:02 UTC (rev 5334)
@@ -20,7 +20,7 @@
               case WAV_LPCM: return QT_TR_NOOP("LPCM");
               case WAV_AC3:  return QT_TR_NOOP("AC3");
               case WAV_EAC3:  return QT_TR_NOOP("E-AC3");
-              case WAV_OGG: return QT_TR_NOOP("Ogg Vorbis");
+              case WAV_OGG_VORBIS: return QT_TR_NOOP("Ogg Vorbis");
               case WAV_MP4: return QT_TR_NOOP("MP4");
               case WAV_AAC: return QT_TR_NOOP("AAC");
               case WAV_QDM2: return QT_TR_NOOP("QDM2");

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/include/ADM_audioCodecEnum.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/include/ADM_audioCodecEnum.h	2009-09-16 17:47:34 UTC (rev 5333)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/include/ADM_audioCodecEnum.h	2009-09-16 17:56:02 UTC (rev 5334)
@@ -13,7 +13,7 @@
 #define WAV_AC3 	0x2000
 #define WAV_DTS 	0x2001
 #define WAV_EAC3 	0x2002 // dummy
-#define WAV_OGG 0x676f
+#define WAV_OGG_VORBIS 0x676f
 #define WAV_8BITS 	53 // dummy id
 #define WAV_MP4 	54 // dummy id
 #define WAV_AAC 	0xff // dummy id

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_coreMuxerFfmpeg.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_coreMuxerFfmpeg.cpp	2009-09-16 17:47:34 UTC (rev 5333)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_coreMuxerFfmpeg.cpp	2009-09-16 17:56:02 UTC (rev 5334)
@@ -255,6 +255,11 @@
           c->sample_rate = audioheader->frequency;
           switch(audioheader->encoding)
           {
+                  case WAV_OGG_VORBIS: 
+                                c->codec_id = CODEC_ID_VORBIS;c->frame_size=6*256;
+                                c->extradata=audioextraData;
+                                c->extradata_size= audioextraSize;
+                                break;
                   case WAV_AC3: c->codec_id = CODEC_ID_AC3;c->frame_size=6*256;break;
                   case WAV_MP2: c->codec_id = CODEC_ID_MP2;c->frame_size=1152;break;
                   case WAV_MP3:

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_vorbis/ADM_ad_vorbis.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_vorbis/ADM_ad_vorbis.cpp	2009-09-16 17:47:34 UTC (rev 5333)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_vorbis/ADM_ad_vorbis.cpp	2009-09-16 17:56:02 UTC (rev 5334)
@@ -51,7 +51,7 @@
 // Supported formats + declare our plugin
 //*******************************************************
 static  ad_supportedFormat Formats[]={
-        {WAV_OGG,AD_MEDIUM_QUAL},
+        {WAV_OGG_VORBIS,AD_MEDIUM_QUAL},
 };
 DECLARE_AUDIO_DECODER(ADM_vorbis,						// Class
 			0,0,1, 												// Major, minor,patch

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioEncoders/vorbis/audioencoder_vorbis.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioEncoders/vorbis/audioencoder_vorbis.cpp	2009-09-16 17:47:34 UTC (rev 5333)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioEncoders/vorbis/audioencoder_vorbis.cpp	2009-09-16 17:56:02 UTC (rev 5334)
@@ -62,7 +62,7 @@
   "Vorbis encoder plugin Mean 2008",
   6,                    // Max channels
   1,0,0,                // Version
-  WAV_OGG,
+  WAV_OGG_VORBIS,
   200,                  // Priority
   getConfigurationData,  // Defined by macro automatically
   setConfigurationData,  // Defined by macro automatically
@@ -85,7 +85,7 @@
 {
   printf("[Vorbis] Creating Vorbis\n");
   _handle=NULL;
-  wavheader.encoding=WAV_OGG;
+  wavheader.encoding=WAV_OGG_VORBIS;
   _oldpos=0;
   _handle=(void *)new  vorbisStruct;
   outputChannelMapping[0] = ADM_CH_FRONT_LEFT;

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.cpp	2009-09-16 17:47:34 UTC (rev 5333)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.cpp	2009-09-16 17:56:02 UTC (rev 5334)
@@ -96,7 +96,7 @@
   for(int i=0;i<_nbAudioTrack;i++)
   {
     rescaleTrack(&(_tracks[1+i]),duration32);
-    if(_tracks[1+i].wavHeader.encoding==WAV_OGG)
+    if(_tracks[1+i].wavHeader.encoding==WAV_OGG_VORBIS)
     {
         printf("[MKV] Reformatting vorbis header for track %u\n",i);
         reformatVorbisHeader(&(_tracks[1+i]));

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkvIndexer.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkvIndexer.cpp	2009-09-16 17:47:34 UTC (rev 5333)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkvIndexer.cpp	2009-09-16 17:56:02 UTC (rev 5334)
@@ -194,6 +194,7 @@
                     printf("[MKV/H264] Frame %"LU" is a keyframe\n",(uint32_t)Track->index.size());
                 }
                 ix.flags=flags;
+                if(Track->index.size()) ix.Dts=ADM_NO_PTS;
                 //printf("[] Flags=%x\n",flags);
 
     }

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkvTrackType.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkvTrackType.cpp	2009-09-16 17:47:34 UTC (rev 5333)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkvTrackType.cpp	2009-09-16 17:56:02 UTC (rev 5334)
@@ -42,7 +42,7 @@
   {"A_AAC/MPEG4/LC/SBR",0,WAV_AAC,""},
   
   {"A_AAC",0,WAV_AAC,""},
-  {"A_VORBIS",0,WAV_OGG,""},
+  {"A_VORBIS",0,WAV_OGG_VORBIS,""},
   {"A_DTS",0,WAV_DTS,""},
   
   // Video



From mean at mail.berlios.de  Wed Sep 16 19:56:19 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 16 Sep 2009 19:56:19 +0200
Subject: [Avidemux-svn-commit] r5335 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska
Message-ID: <200909161756.n8GHuJGW013611@sheep.berlios.de>

Author: mean
Date: 2009-09-16 19:56:18 +0200 (Wed, 16 Sep 2009)
New Revision: 5335

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.h
Log:
[mkv demuxer] Adjust pts if b frames are present so that we dont end up with pts<=dts when saving the result later

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.cpp	2009-09-16 17:56:02 UTC (rev 5334)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.cpp	2009-09-16 17:56:18 UTC (rev 5335)
@@ -109,12 +109,43 @@
         _access[i]=new mkvAccess(_filename,&(_tracks[i+1]));
         _audioStreams[i]=ADM_audioCreateStream(&(_tracks[1+i].wavHeader), _access[i]);;
     }
-
+  delayFrameIfBFrames();
   printf("[MKV]Matroska successfully read\n");
 
   return 1;
 }
 /**
+    \fn delayFrameIfBFrames
+    \brief delay audio and video by 2 * time increment if b frames present
+                else we may have PTS<DTS
+*/
+bool mkvHeader::delayTrack(mkvTrak *track, uint64_t value)
+{
+    int nb=track->index.size();
+    for(int i=0;i<nb;i++)
+    {
+        if(track->index[i].Pts!=ADM_NO_PTS) track->index[i].Pts+=value;
+    }
+    return true;
+}
+bool mkvHeader::delayFrameIfBFrames(void)
+{
+    mkvTrak *track=_tracks;
+    int nb=track->index.size();
+    int nbBFrame=0;
+    for(int i=0;i<nb;i++) if(track->index[i].flags==AVI_B_FRAME) nbBFrame++;
+    if(nbBFrame<2)
+    {
+        printf("[Mkv] no b frames detected\n");
+        return true;
+    }
+    uint64_t twoFrames=track->_defaultFrameDuration*2;
+    printf("[mkv] Delaying PTS by %"LLU" us\n",twoFrames);
+    for(int i=0;i<_nbAudioTrack+1;i++)
+        delayTrack(&(_tracks[i]),twoFrames);
+    return true;
+}
+/**
     \fn rescaleTrack
     \brief Compute the average duration of one audio frame if the info is not present in the stream
 

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.h	2009-09-16 17:56:02 UTC (rev 5334)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.h	2009-09-16 17:56:18 UTC (rev 5335)
@@ -144,6 +144,10 @@
     uint8_t                 indexBlock(ADM_ebml_file *parser,uint32_t count,uint32_t timecodeMS);
 
     uint8_t                 rescaleTrack(mkvTrak *track,uint32_t durationMs);
+
+    bool                    delayTrack(mkvTrak *track, uint64_t value);
+    bool                    delayFrameIfBFrames(void);
+
   public:
 
 



From mean at mail.berlios.de  Wed Sep 16 19:56:24 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 16 Sep 2009 19:56:24 +0200
Subject: [Avidemux-svn-commit] r5336 -
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src
Message-ID: <200909161756.n8GHuOFY013648@sheep.berlios.de>

Author: mean
Date: 2009-09-16 19:56:21 +0200 (Wed, 16 Sep 2009)
New Revision: 5336

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_coreMuxerFfmpeg.cpp
Log:
[ffmpeg muxers] Fix progress bar

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_coreMuxerFfmpeg.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_coreMuxerFfmpeg.cpp	2009-09-16 17:56:18 UTC (rev 5335)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_coreMuxerFfmpeg.cpp	2009-09-16 17:56:21 UTC (rev 5336)
@@ -327,10 +327,14 @@
     {
 	AVPacket pkt;
 
-            float p=0.5;
+            float p=1;
             if(videoDuration)
-                    p=lastVideoDts/videoDuration;
-            p=p*100;
+            {
+                    p=lastVideoDts;
+                    p/=videoDuration;
+                    p=p*100;
+            }
+            
             encoding->update((uint32_t)p);
             if(!encoding->isAlive()) 
             {



From mean at mail.berlios.de  Wed Sep 16 19:56:33 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 16 Sep 2009 19:56:33 +0200
Subject: [Avidemux-svn-commit] r5337 -
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src
Message-ID: <200909161756.n8GHuW1L013681@sheep.berlios.de>

Author: mean
Date: 2009-09-16 19:56:31 +0200 (Wed, 16 Sep 2009)
New Revision: 5337

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/ADM_misc.cpp
Log:
[core] Merge of gruntster fix concerning utf/unicode filename for ADM_fileExist

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/ADM_misc.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/ADM_misc.cpp	2009-09-16 17:56:21 UTC (rev 5336)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/ADM_misc.cpp	2009-09-16 17:56:31 UTC (rev 5337)
@@ -222,7 +222,7 @@
 uint8_t         ADM_fileExist(const char *name)
 {
 FILE *file;
-                file=fopen(name,"rb");
+                file=ADM_fopen(name,"rb");
                 if(!file) return 0;
                 fclose(file);
                 return 1;



From mean at mail.berlios.de  Thu Sep 17 07:18:47 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 17 Sep 2009 07:18:47 +0200
Subject: [Avidemux-svn-commit] r5338 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_matroska
Message-ID: <200909170518.n8H5IlCx009649@sheep.berlios.de>

Author: mean
Date: 2009-09-17 07:18:37 +0200 (Thu, 17 Sep 2009)
New Revision: 5338

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_matroska/ADM_mkvTrackType.cpp
Log:
[MKV] Add another alias for AAC

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_matroska/ADM_mkvTrackType.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_matroska/ADM_mkvTrackType.cpp	2009-09-16 17:56:31 UTC (rev 5337)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_matroska/ADM_mkvTrackType.cpp	2009-09-17 05:18:37 UTC (rev 5338)
@@ -45,6 +45,7 @@
   {"A_AC3",0,WAV_AC3,""}, 
   {"A_AAC/MPEG2/LC",0,WAV_AAC,""},
   {"A_AAC/MPEG4/LC/SBR",0,WAV_AAC,""},
+  {"A_AAC/MPEG4/LC",0,WAV_AAC,""},
   
   {"A_AAC",0,WAV_AAC,""},
   {"A_VORBIS",0,WAV_OGG,""},



From mean at mail.berlios.de  Thu Sep 17 07:20:05 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 17 Sep 2009 07:20:05 +0200
Subject: [Avidemux-svn-commit] r5339 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska
Message-ID: <200909170520.n8H5K5oA011118@sheep.berlios.de>

Author: mean
Date: 2009-09-17 07:20:04 +0200 (Thu, 17 Sep 2009)
New Revision: 5339

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkvTrackType.cpp
Log:
[mkv] Add another alias for AAC

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkvTrackType.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkvTrackType.cpp	2009-09-17 05:18:37 UTC (rev 5338)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkvTrackType.cpp	2009-09-17 05:20:04 UTC (rev 5339)
@@ -40,7 +40,8 @@
   {"A_AC3",0,WAV_AC3,""}, 
   {"A_AAC/MPEG2/LC",0,WAV_AAC,""},
   {"A_AAC/MPEG4/LC/SBR",0,WAV_AAC,""},
-  
+  {"A_AAC/MPEG4/LC",0,WAV_AAC,""},
+
   {"A_AAC",0,WAV_AAC,""},
   {"A_VORBIS",0,WAV_OGG_VORBIS,""},
   {"A_DTS",0,WAV_DTS,""},



From gruntster at mail.berlios.de  Thu Sep 17 18:03:25 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Thu, 17 Sep 2009 18:03:25 +0200
Subject: [Avidemux-svn-commit] r5340 - in
	branches/avidemux_2.5_branch_gruntster/cmake: . patches
Message-ID: <200909171603.n8HG3PZe012522@sheep.berlios.de>

Author: gruntster
Date: 2009-09-17 18:03:02 +0200 (Thu, 17 Sep 2009)
New Revision: 5340

Modified:
   branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_avcodec.h.patch
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_mpegvideo.c.patch
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_utils.c.patch
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_flvenc.c.patch
Log:
[ffmpeg] update FFmpeg to r19894 & libswscale r29686

Modified: branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake	2009-09-17 05:20:04 UTC (rev 5339)
+++ branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake	2009-09-17 16:03:02 UTC (rev 5340)
@@ -1,7 +1,7 @@
 include(admFFmpegUtil)
 
-set(FFMPEG_VERSION 19733)	# http://git.ffmpeg.org/?p=ffmpeg;a=snapshot;h=98a20315c84e530ada85050aa19c82080e35a635;sf=tgz
-set(SWSCALE_VERSION 29569)	# http://git.ffmpeg.org/?p=libswscale;a=snapshot;h=30c6a4d2f849809c0d1f9ca6d548f786990b1d38;sf=tgz
+set(FFMPEG_VERSION 19894)	# http://git.ffmpeg.org/?p=ffmpeg;a=snapshot;h=2e3afeca36da83a20f58962b150580d00a48b6c6;sf=tgz
+set(SWSCALE_VERSION 29686)	# http://git.ffmpeg.org/?p=libswscale;a=snapshot;h=ef1afb1cee3222c7d41f56363c1f536a8ae4f442;sf=tgz
 
 set(LIBRARY_SOURCE_DIR "${CMAKE_SOURCE_DIR}/avidemux/ADM_libraries")
 set(FFMPEG_SOURCE_DIR "${LIBRARY_SOURCE_DIR}/ffmpeg")

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_avcodec.h.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_avcodec.h.patch	2009-09-17 05:20:04 UTC (rev 5339)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_avcodec.h.patch	2009-09-17 16:03:02 UTC (rev 5340)
@@ -1,8 +1,8 @@
-*** libavcodec/avcodec.h.old	Thu Aug 27 21:15:55 2009
---- libavcodec/avcodec.h	Thu Aug 27 21:15:55 2009
+*** libavcodec/avcodec.h.old	Thu Sep 17 16:13:53 2009
+--- libavcodec/avcodec.h	Thu Sep 17 16:13:53 2009
 ***************
-*** 571,576 ****
---- 571,578 ----
+*** 572,577 ****
+--- 572,579 ----
   #define CODEC_FLAG2_CHUNKS        0x00008000 ///< Input bitstream might be truncated at a packet boundaries instead of only at frame boundaries.
   #define CODEC_FLAG2_NON_LINEAR_QUANT 0x00010000 ///< Use MPEG-2 nonlinear quantizer.
   #define CODEC_FLAG2_BIT_RESERVOIR 0x00020000 ///< Use a bit reservoir when encoding if possible
@@ -12,8 +12,8 @@
   /* Unsupported options :
    *              Syntax Arithmetic coding (SAC)
 ***************
-*** 1425,1430 ****
---- 1427,1433 ----
+*** 1430,1435 ****
+--- 1432,1438 ----
        * - decoding: unused
        */
       int rc_max_rate;
@@ -22,8 +22,8 @@
       /**
        * minimum bitrate
 ***************
-*** 1439,1444 ****
---- 1442,1449 ----
+*** 1444,1449 ****
+--- 1447,1454 ----
        * - decoding: unused
        */
       int rc_buffer_size;

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_mpegvideo.c.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_mpegvideo.c.patch	2009-09-17 05:20:04 UTC (rev 5339)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_mpegvideo.c.patch	2009-09-17 16:03:02 UTC (rev 5340)
@@ -1,8 +1,8 @@
-*** libavcodec/mpegvideo.c.old	Sat Jun 27 18:45:15 2009
---- libavcodec/mpegvideo.c	Sat Jun 27 18:45:14 2009
+*** libavcodec/mpegvideo.c.old	Thu Sep 17 16:14:03 2009
+--- libavcodec/mpegvideo.c	Thu Sep 17 16:14:04 2009
 ***************
 *** 613,619 ****
-      CHECKED_ALLOCZ(s->prev_pict_types, PREV_PICT_TYPES_BUFFER_SIZE);
+      FF_ALLOCZ_OR_GOTO(s->avctx, s->prev_pict_types, PREV_PICT_TYPES_BUFFER_SIZE, fail);
   
       s->parse_context.state= -1;
 !     if((s->avctx->debug&(FF_DEBUG_VIS_QP|FF_DEBUG_VIS_MB_TYPE)) || (s->avctx->debug_mv)){
@@ -10,7 +10,7 @@
          s->visualization_buffer[1] = av_malloc((s->mb_width*16 + 2*EDGE_WIDTH) * s->mb_height*16 + 2*EDGE_WIDTH);
          s->visualization_buffer[2] = av_malloc((s->mb_width*16 + 2*EDGE_WIDTH) * s->mb_height*16 + 2*EDGE_WIDTH);
 --- 613,623 ----
-      CHECKED_ALLOCZ(s->prev_pict_types, PREV_PICT_TYPES_BUFFER_SIZE);
+      FF_ALLOCZ_OR_GOTO(s->avctx, s->prev_pict_types, PREV_PICT_TYPES_BUFFER_SIZE, fail);
   
       s->parse_context.state= -1;
 !  //MEANX: Allocate them always, as they may be free when we decode 1st image

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_utils.c.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_utils.c.patch	2009-09-17 05:20:04 UTC (rev 5339)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_utils.c.patch	2009-09-17 16:03:02 UTC (rev 5340)
@@ -1,8 +1,8 @@
-*** libavcodec/utils.c.old	Sat Jun 27 18:45:21 2009
---- libavcodec/utils.c	Sat Jun 27 18:45:20 2009
+*** libavcodec/utils.c.old	Thu Sep 17 16:14:07 2009
+--- libavcodec/utils.c	Thu Sep 17 16:14:07 2009
 ***************
-*** 609,618 ****
---- 609,620 ----
+*** 611,620 ****
+--- 611,622 ----
   
       if((avctx->codec->capabilities & CODEC_CAP_DELAY) || avpkt->size){
           //FIXME remove the check below _after_ ensuring that all audio check that the available space is enough
@@ -16,7 +16,7 @@
           *frame_size_ptr < avctx->channels * avctx->frame_size * sizeof(int16_t)){
               av_log(avctx, AV_LOG_ERROR, "buffer %d too small\n", *frame_size_ptr);
 ***************
-*** 1047,1053 ****
+*** 1049,1055 ****
           return -1;
       }
   #if !HAVE_MKSTEMP
@@ -24,7 +24,7 @@
   #else
       snprintf(*filename, len, "/tmp/%sXXXXXX", prefix);
       fd = mkstemp(*filename);
---- 1049,1055 ----
+--- 1051,1057 ----
           return -1;
       }
   #if !HAVE_MKSTEMP

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_flvenc.c.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_flvenc.c.patch	2009-09-17 05:20:04 UTC (rev 5339)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_flvenc.c.patch	2009-09-17 16:03:02 UTC (rev 5340)
@@ -1,5 +1,5 @@
-*** libavformat/flvenc.c.old	Mon Feb  2 19:49:58 2009
---- libavformat/flvenc.c	Mon Feb  2 19:49:57 2009
+*** libavformat/flvenc.c.old	Thu Sep 17 16:14:10 2009
+--- libavformat/flvenc.c	Thu Sep 17 16:14:10 2009
 ***************
 *** 389,395 ****
       "video/x-flv",
@@ -22,7 +22,7 @@
 *** 401,403 ****
 --- 402,410 ----
       .codec_tag= (const AVCodecTag* const []){flv_video_codec_ids, flv_audio_codec_ids, 0},
-      .flags= AVFMT_GLOBALHEADER,
+      .flags= AVFMT_GLOBALHEADER | AVFMT_VARIABLE_FPS,
   };
 + // MEANX
 + int flvenc_init(void)



From gruntster at mail.berlios.de  Thu Sep 17 18:06:49 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Thu, 17 Sep 2009 18:06:49 +0200
Subject: [Avidemux-svn-commit] r5341 - in
	branches/avidemux_2.5_branch_gruntster/platforms/windows:
	build_scripts/avidemux installer
Message-ID: <200909171606.n8HG6npA013300@sheep.berlios.de>

Author: gruntster
Date: 2009-09-17 18:06:23 +0200 (Thu, 17 Sep 2009)
New Revision: 5341

Modified:
   branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/avidemux/Package Notes.xml
   branches/avidemux_2.5_branch_gruntster/platforms/windows/installer/avidemux.nsi
Log:
[win32] include new colour curve editor filter in Windows installer

Modified: branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/avidemux/Package Notes.xml
===================================================================
--- branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/avidemux/Package Notes.xml	2009-09-17 16:03:02 UTC (rev 5340)
+++ branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/avidemux/Package Notes.xml	2009-09-17 16:06:23 UTC (rev 5341)
@@ -1,7 +1,17 @@
 <?xml version="1.0"?>
 <log>
+  <buildentry revision="5327" date="2009-09-09">
+    <comment>Updated x264 to r1251.</comment>
+  </buildentry>
+  <buildentry revision="5281" date="2009-08-29">
+    <comment>Updated x264 to r1240.</comment>
+  </buildentry>
+  <buildentry revision="5273" date="2009-08-27">
+    <comment>Updated x264 to r1235.</comment>
+    <comment>Updated Xvid to version 1.2.2.</comment>
+  </buildentry>
   <buildentry revision="5268" date="2009-08-23">
-    <comment>Updated x264 r1222.</comment>
+    <comment>Updated x264 to r1222.</comment>
   </buildentry>
   <buildentry revision="5249 [2.5.1 Final]" date="2009-08-16">
     <comment>Updated Fontconfig to version 2.7.1-2.</comment>

Modified: branches/avidemux_2.5_branch_gruntster/platforms/windows/installer/avidemux.nsi
===================================================================
--- branches/avidemux_2.5_branch_gruntster/platforms/windows/installer/avidemux.nsi	2009-09-17 16:03:02 UTC (rev 5340)
+++ branches/avidemux_2.5_branch_gruntster/platforms/windows/installer/avidemux.nsi	2009-09-17 16:06:23 UTC (rev 5341)
@@ -845,6 +845,14 @@
 				SetOutPath $INSTDIR\plugins\videoFilter
 				${File} plugins\videoFilter\libADM_vidChromaV.dll
 			${MementoSectionEnd}
+!ifdef INST_QT
+			${MementoSection} "Colour Curve Editor" SecVidFltColourCurveEditor
+				SectionIn 1 2
+				SetOverwrite on
+				SetOutPath $INSTDIR\plugins\videoFilter
+				${File} plugins\videoFilter\libADM_vf_curveEditor_qt4.dll
+			${MementoSectionEnd}
+!endif
 			${MementoSection} "Contrast" SecVidFltContrast
 				SectionIn 1 2
 				SetOverwrite on



From mean at mail.berlios.de  Sat Sep 19 18:03:19 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 19 Sep 2009 18:03:19 +0200
Subject: [Avidemux-svn-commit] r5342 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor
Message-ID: <200909191603.n8JG3JxS015741@sheep.berlios.de>

Author: mean
Date: 2009-09-19 18:03:17 +0200 (Sat, 19 Sep 2009)
New Revision: 5342

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx
Log:
[editor] Add PTS/DTS information at video_editor level from demuxer

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp	2009-09-17 16:06:23 UTC (rev 5341)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp	2009-09-19 16:03:17 UTC (rev 5342)
@@ -1344,4 +1344,17 @@
         return true;
 
 }
+/**
+    \fn getPtsDts
+    \brief Return PTS & DTS for a given frame (in bitstream order)
+*/
+bool        ADM_Composer::getPtsDts(uint32_t frame,uint64_t *pts,uint64_t *dts)
+{
+     _VIDEOS   *vid=&_videos[0];
+    vidHeader *demuxer=vid->_aviheader;
+    return demuxer->getPtsDts(frame,pts,dts); // FIXME : Rescale frame number
+
+}
+
+
 //EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx	2009-09-17 16:06:23 UTC (rev 5341)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx	2009-09-19 16:03:17 UTC (rev 5342)
@@ -243,6 +243,7 @@
                         uint32_t    searchFrameBefore(uint64_t pts);
                         bool        getImageFromCacheForFrameBefore(uint64_t pts,ADMImage *out);
                         bool        getPictureJustBefore(uint64_t pts);
+                        bool        getPtsDts(uint32_t frame,uint64_t *pts,uint64_t *dts);
 /************************************ Internal ******************************/
 public:
                                     /// Decode frame and on until frame is popped out of decoders



From mean at mail.berlios.de  Sat Sep 19 18:03:21 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 19 Sep 2009 18:03:21 +0200
Subject: [Avidemux-svn-commit] r5343 -
	branches/avidemux_2.6_branch_mean/avidemux/common
Message-ID: <200909191603.n8JG3LBX015767@sheep.berlios.de>

Author: mean
Date: 2009-09-19 18:03:20 +0200 (Sat, 19 Sep 2009)
New Revision: 5343

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/gui_savenew.cpp
Log:
[save] Use the video start time from muxerGate to shift the audio accordingly

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/gui_savenew.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/gui_savenew.cpp	2009-09-19 16:03:17 UTC (rev 5342)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/gui_savenew.cpp	2009-09-19 16:03:20 UTC (rev 5343)
@@ -232,14 +232,9 @@
 */
 bool admSaver::save(void)
 {
-    
-    int ret=1;
-    
-    
-     
-     
+    int ret=1; 
+    uint64_t startAudioTime=markerA; // Actual start time (for both audio & video actually)
     printf("[A_Save] Saving..\n");
-
     
     if(!(muxer=ADM_MuxerSpawnFromIndex(muxerIndex)))
     {
@@ -256,13 +251,18 @@
         nbAStream=0; // FIXME
     }else
     {
-        audio->goToTime(markerA); // Rewind audio
+        audio->goToTime(startAudioTime); // Rewind audio
     }
     ADM_videoStream *video=NULL;
     // Video Stream 
     if(!videoEncoderIndex) // Copy
     {
-        video=new ADM_videoStreamCopy(markerA,markerB);
+        ADM_videoStreamCopy *copy=new ADM_videoStreamCopy(markerA,markerB);
+        video=copy;
+        // In that case, get the real time and update audio with it...
+        // Because we might have go back in time to catch the first intra
+        startAudioTime=copy->getStartTime();
+        audio->goToTime(startAudioTime);
     }else
     {
         // 1- create filter chain
@@ -303,7 +303,6 @@
             delete encoder;
             encoder=NULL;
             return false;
-
         }
         video= new ADM_videoStreamProcess(encoder);
         if(!video)
@@ -312,7 +311,6 @@
                 delete encoder;
                 return 0;
         }
-        
     }
     //
     ADM_audioStream *astreams[1];
@@ -324,17 +322,15 @@
         if(audio)   // Process
         {
             // Access..
-            ADM_audioStream *access=createEncodingStream(markerA,0); // FIXME LEAK
+            ADM_audioStream *access=createEncodingStream(startAudioTime,0); // FIXME LEAK
             astreams[0]=access;
         }
     }
     if(!muxer->open(fileName,video,nbAStream,astreams))
     {
         GUI_Error_HIG("Muxer","Cannot open ");
-        
     }else   
     {
-
         muxer->save();
         muxer->close();
     }



From mean at mail.berlios.de  Sat Sep 19 18:03:22 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 19 Sep 2009 18:03:22 +0200
Subject: [Avidemux-svn-commit] r5344 - in
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate:
	include src
Message-ID: <200909191603.n8JG3MLA015783@sheep.berlios.de>

Author: mean
Date: 2009-09-19 18:03:22 +0200 (Sat, 19 Sep 2009)
New Revision: 5344

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/include/ADM_videoCopy.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoCopy.cpp
Log:
[muxer] Since in copy mode, we might go back in time to fecth an intra, make the videoCopy cass report the actual starttime it is using

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/include/ADM_videoCopy.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/include/ADM_videoCopy.h	2009-09-19 16:03:20 UTC (rev 5343)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/include/ADM_videoCopy.h	2009-09-19 16:03:22 UTC (rev 5344)
@@ -27,6 +27,7 @@
 virtual     bool     getExtraData(uint32_t *extraLen, uint8_t **extraData) ;
 virtual     bool     providePts(void);
 virtual     uint64_t getVideoDuration(void);
+virtual     uint64_t getStartTime(void);
 };
 
 #endif

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoCopy.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoCopy.cpp	2009-09-19 16:03:20 UTC (rev 5343)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoCopy.cpp	2009-09-19 16:03:22 UTC (rev 5344)
@@ -42,6 +42,19 @@
     eofMet=false;
     this->startTime=startTime;
     this->endTime=endTime;
+    // Update start time if needed
+    uint64_t sPts,sDts,sStart=ADM_NO_PTS;
+    video_body->getPtsDts(currentFrame,&sPts,&sDts);
+    if(sDts!=ADM_NO_PTS) sStart=sDts;
+    else
+        if(sPts!=ADM_NO_PTS)
+        {
+            sStart=sPts;
+            printf("[Warning] No Dts available for first frame, guessing ...\n");
+        }
+    if(sStart!=ADM_NO_PTS)
+        this->startTime=sStart;
+    printf("[StreamCopy] Fixating start time by %u\n",abs((int)(this->startTime-startTime)));
 }
 /**
     \fn ADM_videoStreamCopy
@@ -68,6 +81,13 @@
     return 0;
 }
 /**
+    \fn getStartTime
+*/
+uint64_t  ADM_videoStreamCopy::getStartTime(void)
+{
+    return this->startTime;
+}
+/**
     \fn getPacket
 */
 bool  ADM_videoStreamCopy::getPacket(uint32_t *len, uint8_t *data, uint32_t maxLen,



From mean at mail.berlios.de  Sat Sep 19 20:34:37 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 19 Sep 2009 20:34:37 +0200
Subject: [Avidemux-svn-commit] r5345 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src
Message-ID: <200909191834.n8JIYbV6022200@sheep.berlios.de>

Author: mean
Date: 2009-09-19 20:34:36 +0200 (Sat, 19 Sep 2009)
New Revision: 5345

Added:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/audiocopy.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/audiofilter_encoder.cpp
Log:
[audio] Add a function to create a copy stream for audio (with rescaling of timestamp

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/CMakeLists.txt	2009-09-19 16:03:22 UTC (rev 5344)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/CMakeLists.txt	2009-09-19 18:34:36 UTC (rev 5345)
@@ -13,6 +13,7 @@
 audiofilter_SRC.cpp
 audiofilter_encoder.cpp
 audiofilter_interface.cpp
+audiocopy.cpp
 ADM_audioResample.cpp
 audiofilter.cpp
 ADM_libsamplerate/samplerate.c  

Added: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/audiocopy.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/audiocopy.cpp	2009-09-19 16:03:22 UTC (rev 5344)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/audiocopy.cpp	2009-09-19 18:34:36 UTC (rev 5345)
@@ -0,0 +1,77 @@
+/***************************************************************************
+            \file audiofilter_encoder.cpp
+            \brief Generate a access class = to the output of encoder + filterchain
+              (c) 2006 Mean , fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+
+#include "ADM_default.h"
+#include "ADM_editor/ADM_edit.hxx"
+#include <math.h>
+
+extern ADM_Composer *video_body;
+
+/**
+        \fn ADM_audioStream
+        \brief Base class for audio stream
+
+*/
+class ADM_audioStreamCopy : public ADM_audioStream
+{
+        protected:
+                        ADM_audioStream *in;
+                        uint64_t        startTime;
+        public:
+
+                       ADM_audioStreamCopy(ADM_audioStream *input,uint64_t startTime, int64_t shift);  
+virtual                 WAVHeader                *getInfo(void) {return in->getInfo();};
+virtual uint8_t         getPacket(uint8_t *buffer,uint32_t *size, uint32_t sizeMax,uint32_t *nbSample,uint64_t *dts);
+//virtual bool            goToTime(uint64_t nbUs);
+virtual bool            getExtraData(uint32_t *l, uint8_t **d);
+        uint64_t        getDurationInUs(void);
+};
+// Pass Through class, just do the timing
+
+ADM_audioStreamCopy::ADM_audioStreamCopy(ADM_audioStream *input,uint64_t startTime, int64_t shift) : 
+                    ADM_audioStream(NULL,NULL)
+{
+    in=input;
+    this->startTime=startTime;
+    in->goToTime(startTime);
+#warning handle shift ???
+}
+bool            ADM_audioStreamCopy::getExtraData(uint32_t *l, uint8_t **d)
+{
+    return in->getExtraData(l,d); 
+}
+uint64_t ADM_audioStreamCopy::getDurationInUs(void)
+{
+       return in->getDurationInUs();
+}
+uint8_t         ADM_audioStreamCopy::getPacket(uint8_t *buffer,uint32_t *size, uint32_t sizeMax,uint32_t *nbSample,uint64_t *dts)
+{
+again:
+    if(false==in->getPacket(buffer,size,sizeMax,nbSample,dts)) return false;
+    if(*dts!=ADM_NO_PTS && *dts<startTime) goto again;
+    *dts=*dts-startTime;
+    return true;
+
+}
+/**
+        \fn audioCreateCopyStream
+*/
+ADM_audioStream *audioCreateCopyStream(uint64_t startTime,int32_t shift,ADM_audioStream *input)
+{
+  return new ADM_audioStreamCopy(input,startTime,shift);
+}
+
+// EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/audiofilter_encoder.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/audiofilter_encoder.cpp	2009-09-19 16:03:22 UTC (rev 5344)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/audiofilter_encoder.cpp	2009-09-19 18:34:36 UTC (rev 5345)
@@ -64,7 +64,7 @@
 /**
     \fn createEncodingAccess
 */
-ADM_audioStream *createEncodingStream(uint64_t startTime,int32_t shift)
+ADM_audioStream *audioCreateEncodingStream(uint64_t startTime,int32_t shift)
 {
     printf("[AccessFilter] Creating access filter\n");
     // 1-Create access filter



From mean at mail.berlios.de  Sat Sep 19 20:34:38 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 19 Sep 2009 20:34:38 +0200
Subject: [Avidemux-svn-commit] r5346 -
	branches/avidemux_2.6_branch_mean/avidemux/common
Message-ID: <200909191834.n8JIYcQP022212@sheep.berlios.de>

Author: mean
Date: 2009-09-19 20:34:38 +0200 (Sat, 19 Sep 2009)
New Revision: 5346

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/gui_savenew.cpp
Log:
[save] Use the new copyStream audio so that we have the right timestamps when saving from the middle of the stream

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/gui_savenew.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/gui_savenew.cpp	2009-09-19 18:34:36 UTC (rev 5345)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/gui_savenew.cpp	2009-09-19 18:34:38 UTC (rev 5346)
@@ -41,7 +41,8 @@
 #include "ADM_filterChain.h"
 
 ADM_muxer               *ADM_MuxerSpawnFromIndex(int index);
-extern ADM_audioStream  *createEncodingStream(uint64_t startTime,int32_t shift);
+extern ADM_audioStream  *audioCreateEncodingStream(uint64_t startTime,int32_t shift);
+extern ADM_audioStream *audioCreateCopyStream(uint64_t startTime,int32_t shift,ADM_audioStream *input);
 extern ADM_videoStream  *createVideoStream(ADM_coreVideoEncoder *encoder);
 
 /**
@@ -101,7 +102,7 @@
  if(logFileName) 
         delete [] logFileName;
  logFileName=NULL;
- if (audioProcessMode() && astreams[0])
+ if ( astreams[0])
         delete astreams[0];
  astreams[0]=NULL;
  if(video)   
@@ -313,16 +314,17 @@
         }
     }
     //
-    ADM_audioStream *astreams[1];
+    ADM_audioStream *astreams[1]={NULL};
     if (!audioProcessMode())
     {
-        astreams[0]=audio; //copy
+        if(audio)
+            astreams[0]=audioCreateCopyStream(startAudioTime,0,audio); //copy
     }else    
     {
         if(audio)   // Process
         {
             // Access..
-            ADM_audioStream *access=createEncodingStream(startAudioTime,0); // FIXME LEAK
+            ADM_audioStream *access=audioCreateEncodingStream(startAudioTime,0); // FIXME LEAK
             astreams[0]=access;
         }
     }



From gruntster at mail.berlios.de  Tue Sep 22 20:21:23 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Tue, 22 Sep 2009 20:21:23 +0200
Subject: [Avidemux-svn-commit] r5347 -
	branches/avidemux_2.5_branch_gruntster/avidemux
Message-ID: <200909221821.n8MILNO6010678@sheep.berlios.de>

Author: gruntster
Date: 2009-09-22 20:21:19 +0200 (Tue, 22 Sep 2009)
New Revision: 5347

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/CMakeLists.txt
Log:
[macosx] fix reference to icon file

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/CMakeLists.txt	2009-09-19 18:34:38 UTC (rev 5346)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/CMakeLists.txt	2009-09-22 18:21:19 UTC (rev 5347)
@@ -85,8 +85,8 @@
 ########################################
 IF (APPLE)
 	# add icon
-	SET(ADM_EXE_SRCS ${ADM_EXE_SRCS} ${CMAKE_CURRENT_SOURCE_DIR}/xpm/avidemux.icns)
-	SET_SOURCE_FILES_PROPERTIES(${CMAKE_CURRENT_SOURCE_DIR}/xpm/avidemux.icns PROPERTIES MACOSX_PACKAGE_LOCATION Resources)
+	SET(ADM_EXE_SRCS ${ADM_EXE_SRCS} ${CMAKE_CURRENT_SOURCE_DIR}/ADM_icons/xpm/avidemux.icns)
+	SET_SOURCE_FILES_PROPERTIES(${CMAKE_CURRENT_SOURCE_DIR}/ADM_icons/xpm/avidemux.icns PROPERTIES MACOSX_PACKAGE_LOCATION Resources)
 
 	# bundle version info
 	SET(ADM_OSX_VERSION "${VERSION}")



From mean at mail.berlios.de  Wed Sep 23 19:52:12 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 23 Sep 2009 19:52:12 +0200
Subject: [Avidemux-svn-commit] r5349 -
	branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/FastConvolution
Message-ID: <200909231752.n8NHqCKD022141@sheep.berlios.de>

Author: mean
Date: 2009-09-23 19:52:12 +0200 (Wed, 23 Sep 2009)
New Revision: 5349

Modified:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/FastConvolution/Gauss.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/FastConvolution/Mean.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/FastConvolution/Median.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/FastConvolution/Sharpen.cpp
Log:
[Video/Filters] Move convolution filter to the sharpness category, closes #10

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/FastConvolution/Gauss.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/FastConvolution/Gauss.cpp	2009-09-23 17:52:11 UTC (rev 5348)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/FastConvolution/Gauss.cpp	2009-09-23 17:52:12 UTC (rev 5349)
@@ -26,7 +26,7 @@
                 gaussian,
                 QT_TR_NOOP("Gauss smooth"),
                 1,
-                VF_INTERLACING,
+                VF_SHARPNESS,
                 QT_TR_NOOP("Gaussian smooth. Blur the picture."));
 
 //          6 10 6

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/FastConvolution/Mean.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/FastConvolution/Mean.cpp	2009-09-23 17:52:11 UTC (rev 5348)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/FastConvolution/Mean.cpp	2009-09-23 17:52:12 UTC (rev 5349)
@@ -30,7 +30,7 @@
                 mean,
                 QT_TR_NOOP("Mean"),
                 1,
-                VF_INTERLACING,
+                VF_SHARPNESS,
                 QT_TR_NOOP("Mean (blur) kernel."));
 
 char 	*AVDMFastVideoMean::printConf(void)

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/FastConvolution/Median.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/FastConvolution/Median.cpp	2009-09-23 17:52:11 UTC (rev 5348)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/FastConvolution/Median.cpp	2009-09-23 17:52:12 UTC (rev 5349)
@@ -26,7 +26,7 @@
                 median,
                 QT_TR_NOOP("Median"),
                 1,
-                VF_INTERLACING,
+                VF_SHARPNESS,
                 QT_TR_NOOP("Median kernel 3x3. Remove high frequency noise."));
 
 

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/FastConvolution/Sharpen.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/FastConvolution/Sharpen.cpp	2009-09-23 17:52:11 UTC (rev 5348)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/FastConvolution/Sharpen.cpp	2009-09-23 17:52:12 UTC (rev 5349)
@@ -25,7 +25,7 @@
                 sharpen,
                 QT_TR_NOOP("Sharpen"),
                 1,
-                VF_INTERLACING,
+                VF_SHARPNESS,
                 QT_TR_NOOP("Enhance difference between near pixels."));
 
 



From mean at mail.berlios.de  Wed Sep 23 19:52:11 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 23 Sep 2009 19:52:11 +0200
Subject: [Avidemux-svn-commit] r5348 -
	branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/KeepField
Message-ID: <200909231752.n8NHqBR8022131@sheep.berlios.de>

Author: mean
Date: 2009-09-23 19:52:11 +0200 (Wed, 23 Sep 2009)
New Revision: 5348

Modified:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/KeepField/ADM_vidHzStackField.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/KeepField/ADM_vidMergeField.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/KeepField/ADM_vidSeparateField.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/KeepField/ADM_vidStackField.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/KeepField/ADM_vidUnstackField.cpp
Log:
[Filter/Field] Cleanup/rename filters, ref #10

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/KeepField/ADM_vidHzStackField.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/KeepField/ADM_vidHzStackField.cpp	2009-09-22 18:21:19 UTC (rev 5347)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/KeepField/ADM_vidHzStackField.cpp	2009-09-23 17:52:11 UTC (rev 5348)
@@ -1,5 +1,5 @@
 /***************************************************************************
-                          Separate Fields.cpp  -  description
+                          Hz stack field Fields.cpp  -  description
                              -------------------
 Convert a x*y * f fps video into -> x*(y/2)*fps/2 video
 
@@ -30,10 +30,10 @@
 //QT_TR_NOOP("Put botj fields side by side."),VF_HZSTACKFIELD,1,hzstackfield_create,hzstackfield_script);
 VF_DEFINE_FILTER(AVDMVideoHzStackField,swapParam,
     hzstackfield,
-                QT_TR_NOOP("separatefields"),
+                QT_TR_NOOP("Horizontal Stack Field"),
                 1,
                 VF_INTERLACING,
-                QT_TR_NOOP("Put botj fields side by side."));
+                QT_TR_NOOP("Put both fields side by side."));
 
 //*************************************************************
 //_______________________Hz Stack Fields_______________________

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/KeepField/ADM_vidMergeField.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/KeepField/ADM_vidMergeField.cpp	2009-09-22 18:21:19 UTC (rev 5347)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/KeepField/ADM_vidMergeField.cpp	2009-09-23 17:52:11 UTC (rev 5348)
@@ -1,5 +1,5 @@
 /***************************************************************************
-                          Separate Fields.cpp  -  description
+                          Merge Fields.cpp  -  description
                              -------------------
 Convert a x*y * f fps video into -> x*(y/2)*fps/2 video
 

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/KeepField/ADM_vidSeparateField.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/KeepField/ADM_vidSeparateField.cpp	2009-09-22 18:21:19 UTC (rev 5347)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/KeepField/ADM_vidSeparateField.cpp	2009-09-23 17:52:11 UTC (rev 5348)
@@ -27,11 +27,9 @@
 
 
 static FILTER_PARAM swapParam={0,{""}};
-//REGISTERX(VF_INTERLACING, "separatefields",QT_TR_NOOP("Separate fields"),QT_TR_NOOP
-//("Each field becomes full picture, half sized."),VF_SEPARATEFIELDS,1, separatefield_create,separatefield_script);
 VF_DEFINE_FILTER(AVDMVideoSeparateField,swapParam,
                 separatefields,
-                QT_TR_NOOP("Fade"),
+                QT_TR_NOOP("Separate Fields"),
                 1,
                 VF_INTERLACING,
                 QT_TR_NOOP("Each field becomes full picture, half sized."));
@@ -94,208 +92,4 @@
 		vidCache->unlockAll();
       return 1;
 }
-//------------------ and merge them ------------------
 
-
-char *AVDMVideoMergeField::printConf( void )
-{
- 	ADM_FILTER_DECLARE_CONF(" Merge fields");
-        
-}
-
-//_______________________________________________________________
-AVDMVideoMergeField::AVDMVideoMergeField(
-									AVDMGenericVideoStream *in,CONFcouple *setup)
-{
-UNUSED_ARG(setup);
-  	_in=in;
-   	memcpy(&_info,_in->getInfo(),sizeof(_info));	
-	vidCache=new VideoCache(4,_in);
-	
-
-	_info.height<<=1;
-	_info.fps1000>>=1;
-	_info.nb_frames>>=1;
-
-
-}
-
-// ___ destructor_____________
-AVDMVideoMergeField::~AVDMVideoMergeField()
-{
- 		delete vidCache;
-		vidCache=NULL;
-}
-
-/**
-	Interleave frame*2 and frame*2+1
-*/
-uint8_t AVDMVideoMergeField::getFrameNumberNoAlloc(uint32_t frame,
-				uint32_t *len,
-   				ADMImage *data,
-				uint32_t *flags)
-{
-uint32_t ref,ref2;
-ADMImage *ptr1,*ptr2;
-		if(frame>=_info.nb_frames) return 0;
-
-		ref=frame<<1;
-		ref2=ref+1;
-		ptr1=vidCache->getImage(ref);
-		ptr2=vidCache->getImage(ref+1);
-		
-		if(!ptr1 || !ptr2)
-		{
-			printf("Merge field : cannot read\n");
-			vidCache->unlockAll();
-		 	return 0;
-		}
-		 vidFieldMerge(_info.width,_info.height,ptr1->data,ptr2->data,data->data);
-		 vidCache->unlockAll();
-		
-      return 1;
-}
-//_______________________Stack Fields_______________________
-
-char *AVDMVideoStackField::printConf( void )
-{
- 	ADM_FILTER_DECLARE_CONF(" Stack fields");
-        
-}
-
-//_______________________________________________________________
-AVDMVideoStackField::AVDMVideoStackField(	AVDMGenericVideoStream *in,CONFcouple *setup)
-{
-UNUSED_ARG(setup);
-  	_in=in;
-   	memcpy(&_info,_in->getInfo(),sizeof(_info));	
-	_uncompressed=new ADMImage(_info.width,_info.height);	
-
-}
-
-// ___ destructor_____________
-AVDMVideoStackField::~AVDMVideoStackField()
-{
- 		delete _uncompressed;
-		_uncompressed=NULL;
-}
-
-/**
-	Interleave frame*2 and frame*2+1
-*/
-uint8_t AVDMVideoStackField::getFrameNumberNoAlloc(uint32_t frame,
-				uint32_t *len,
-   				ADMImage *data,
-				uint32_t *flags)
-{
-uint32_t ref,ref2;
-ADMImage *ptr1,*ptr2;
-		if(frame>=_info.nb_frames) return 0;
-
-		 if(!_in->getFrameNumberNoAlloc(frame, len, _uncompressed, flags)) return 0;
-		 
-		  vidFielStack(_info.width ,_info.height,YPLANE(_uncompressed),YPLANE(data));
-		data->copyInfo(_uncompressed);	
-      return 1;
-}
-
-/****/
-
-//*************************************************************
-//_______________________Hz Stack Fields_______________________
-
-char *AVDMVideoHzStackField::printConf( void )
-{
-       ADM_FILTER_DECLARE_CONF(" Hz Stack fields");
-        
-}
-
-//_______________________________________________________________
-AVDMVideoHzStackField::AVDMVideoHzStackField(	AVDMGenericVideoStream *in,CONFcouple *setup)
-{
-UNUSED_ARG(setup);
-        _in=in;
-        memcpy(&_info,_in->getInfo(),sizeof(_info));
-        _info.width<<=1;
-        _info.height>>=1;
-        _uncompressed=new ADMImage(in->getInfo()->width,in->getInfo()->height);	
-}
-
-// ___ destructor_____________
-AVDMVideoHzStackField::~AVDMVideoHzStackField()
-{
-        delete _uncompressed;
-        _uncompressed=NULL;
-}
-
-/*
-        Put fields side by side	
-*/
-static void fCopy(uint8_t *d, uint8_t *sr, uint32_t w, uint32_t sstride,uint32_t dstride,uint32_t h)
-{
-
-}
-uint8_t AVDMVideoHzStackField::getFrameNumberNoAlloc(uint32_t frame,
-                            uint32_t *len,
-                            ADMImage *data,
-                            uint32_t *flags)
-{
-uint32_t ref,ref2;
-ADMImage *ptr1,*ptr2;
-        if(frame>=_info.nb_frames) return 0;
-        if(!_in->getFrameNumberNoAlloc(frame, len, _uncompressed, flags)) return 0;
-
-        uint32_t pg=_info.width*_info.height;
-        // Duplicate _uncompressed
-        memcpy(YPLANE(data),YPLANE(_uncompressed),pg);
-        memcpy(UPLANE(data),UPLANE(_uncompressed),pg>>2);
-        memcpy(VPLANE(data),VPLANE(_uncompressed),pg>>2);
-
-
-        return 1;
-}
-
-/****/
-//_______________________UnStack Fields_______________________
-
-char *AVDMVideoUnStackField::printConf( void )
-{
-        ADM_FILTER_DECLARE_CONF(" UnStack fields");
-        
-}
-
-//______________________Unstack Fields_________________________________________
-AVDMVideoUnStackField::AVDMVideoUnStackField(       AVDMGenericVideoStream *in,CONFcouple *setup)
-{
-UNUSED_ARG(setup);
-        _in=in;
-        memcpy(&_info,_in->getInfo(),sizeof(_info));    
-        _uncompressed=new ADMImage(_info.width,_info.height);   
-
-}
-
-// ___ destructor_____________
-AVDMVideoUnStackField::~AVDMVideoUnStackField()
-{
-                delete _uncompressed;
-                _uncompressed=NULL;
-}
-//*************************************************************
-/**
-        Interleave frame*2 and frame*2+1
-*/
-uint8_t AVDMVideoUnStackField::getFrameNumberNoAlloc(uint32_t frame,
-                                uint32_t *len,
-                                ADMImage *data,
-                                uint32_t *flags)
-{
-uint32_t ref,ref2;
-ADMImage *ptr1,*ptr2;
-                if(frame>=_info.nb_frames) return 0;
-
-                 if(!_in->getFrameNumberNoAlloc(frame, len, _uncompressed, flags)) return 0;
-                 
-                  vidFielUnStack(_info.width ,_info.height,YPLANE(_uncompressed),YPLANE(data));
-                data->copyInfo(_uncompressed);  
-      return 1;
-}

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/KeepField/ADM_vidStackField.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/KeepField/ADM_vidStackField.cpp	2009-09-22 18:21:19 UTC (rev 5347)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/KeepField/ADM_vidStackField.cpp	2009-09-23 17:52:11 UTC (rev 5348)
@@ -1,5 +1,5 @@
 /***************************************************************************
-                          Separate Fields.cpp  -  description
+                          Stack Fields.cpp  -  description
                              -------------------
 Convert a x*y * f fps video into -> x*(y/2)*fps/2 video
 

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/KeepField/ADM_vidUnstackField.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/KeepField/ADM_vidUnstackField.cpp	2009-09-22 18:21:19 UTC (rev 5347)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/KeepField/ADM_vidUnstackField.cpp	2009-09-23 17:52:11 UTC (rev 5348)
@@ -1,5 +1,5 @@
 /***************************************************************************
-                          Separate Fields.cpp  -  description
+                          Unstack Fields.cpp  -  description
                              -------------------
 Convert a x*y * f fps video into -> x*(y/2)*fps/2 video
 



From mean at mail.berlios.de  Fri Sep 25 09:16:59 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 25 Sep 2009 09:16:59 +0200
Subject: [Avidemux-svn-commit] r5350 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src
Message-ID: <200909250716.n8P7Gxj3015314@sheep.berlios.de>

Author: mean
Date: 2009-09-25 09:16:58 +0200 (Fri, 25 Sep 2009)
New Revision: 5350

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_crashdump.cpp
Log:
[backtrace] Better backtrace using glibc functions (backport from 2.6)

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_crashdump.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_crashdump.cpp	2009-09-23 17:52:12 UTC (rev 5349)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_crashdump.cpp	2009-09-25 07:16:58 UTC (rev 5350)
@@ -25,6 +25,8 @@
 #include <windows.h>
 #include <excpt.h>
 #include <imagehlp.h>
+#else
+#include <cxxabi.h>
 #endif
 
 #include "ADM_default.h"
@@ -284,151 +286,78 @@
 #endif
 
 void sig_segfault_handler(int signo);
-void installSigHandler()
-{
-    signal(11, sig_segfault_handler); // show stacktrace on default
-}
-
-static int lenCount(uint8_t *start,uint8_t *end,int *d)
-{
-  int val=0;
-  int digit=0;
-  *d=0;
-  while(*start>='0' && *start<='9' && start<end) 
-  {
-    val=val*10+*start-'0'; 
-    start++;
-    digit++;
-  }
-  *d=digit;
-  return val;
-}
-
-static int decodeOne(uint8_t *start, uint8_t *end,int *cons)
-{
-  *cons=0;
-  int len,digit;
-  uint8_t *org=start;
-  if(start+2>=end) return 0;
-  switch(*start )
-  {
-    case 'Z':
-    case 'P':  
-      
-        len=lenCount(start+1,end,&digit);
-        start+=1+digit;
-        for(int z=0;z<len;z++) printf("%c",*start++);
-        break;
-  }
-  return (int)((uint64_t)start-(uint64_t)org);
-}
-static int demangle(int i,  uint8_t *string)
-{
- // Search 1st (
-  if(!string) return 0;
-  int len=strlen((char *)string);
-  if(!len) return 0;
-   
-  uint8_t *end=string+len;
-  uint8_t *start=string;
-  
-  while(*start!='(' && start+3<end) start++;
-  if(*start!='(') return 0;
-  start++;
-  
-  //  _qt(_Z9crashTestP9JSContextP8JSObjectjPlS3_+0) [0x4acf80]
-  
-  if(*start!='_' || start[1]!='Z')
-  {
-    return 0;
-  }
-  // Seems good !
-  start++;
-  start++;  
-  int digit;
-  // Function name..
-  int l=lenCount(start,end,&digit);
-  printf("\t<");
-  for(int i=0;i<l;i++)
-  {
-    printf("%c",start[digit+i]); 
-  }
-  printf(">(");
-  start+=digit+l;
-  
-  // Parama
-  int first=0;
-  while(start+2<end && *start=='P')
-  {
-    if(!first)  first=1;
-    else
-        printf(",");
-    
-      
-    start++;
-    l=lenCount(start,end,&digit);
-    for(int i=0;i<l;i++)
-    {
-      printf("%c",start[digit+i]); 
-    }
-    start+=digit+l;
-  }
-  printf(")\n");
-  return 1;
-}
-
-/**
-      \fn sig_segfault_handler
-      \brief our segfault handler
-
-*/
-void sig_segfault_handler(int signo)
-{
-     
-     static int running=0;
-      if(running) 
-      {
-        signo=0;
-        exit(1);
-      }
-      running=0; 
-      ADM_backTrack("Segfault",0,"??");
-}
-
-void ADM_backTrack(const char *info,int lineno,const char *file)
-{
-	char wholeStuff[2048];
-	void *stack[20];
-	char **functions;
-	int count, i;
-
-	wholeStuff[0]=0;
-
-	if(mysaveFunction)
-		mysaveFunction();
-
-#ifndef __CYGWIN__
-	printf("\n*********** BACKTRACK **************\n");
-
-	count = backtrace(stack, 20);
-	functions = backtrace_symbols(stack, count);
-	sprintf(wholeStuff,"%s\n at line %d, file %s",info,lineno,file);
-
-	for (i=0; i < count; i++) 
-	{
-		printf("Frame %2d: %s \n", i, functions[i]);
-		demangle(i,(uint8_t *)functions[i]);
-		strcat(wholeStuff,functions[i]);
-		strcat(wholeStuff,"\n");
-	}
-
-	printf("*********** BACKTRACK **************\n");
-
-	if(myFatalFunction)
-		myFatalFunction("Crash", wholeStuff); // FIXME
-#endif	//__CYGWIN__
-
-	exit(-1); // _exit(1) ???
-}
+void installSigHandler()
+{
+    signal(11, sig_segfault_handler); // show stacktrace on default
+}
+
+
+/**
+      \fn sig_segfault_handler
+      \brief our segfault handler
+
+*/
+void sig_segfault_handler(int signo)
+{
+     
+     static int running=0;
+      if(running) 
+      {
+        signo=0;
+        exit(1);
+      }
+      running=0; 
+      ADM_backTrack("Segfault",0,"??");
+}
+
+void ADM_backTrack(const char *info,int lineno,const char *file)
+{
+	char wholeStuff[2048];
+    char buffer[2048];
+    char in[2048];
+	void *stack[20];
+	char **functions;
+	int count, i;
+
+	wholeStuff[0]=0;
+
+	if(mysaveFunction)
+		mysaveFunction();
+
+#ifndef __CYGWIN__
+	printf("\n*********** BACKTRACK **************\n");
+
+	count = backtrace(stack, 20);
+	functions = backtrace_symbols(stack, count);
+	sprintf(wholeStuff,"%s\n at line %d, file %s",info,lineno,file);
+    int status;
+    size_t size=2047;
+    // it looks like that xxxx (functionName+0x***) XXXX
+	for (i=0; i < count; i++) 
+	{
+        char *s=strstr(functions[i],"(");
+        buffer[0]=0;
+        if(s && strstr(s+1,"+"))
+        {
+            strcpy(in,s+1);
+            char *e=strstr(in,"+");
+            *e=0;                
+            __cxxabiv1::__cxa_demangle(in,buffer,&size,&status);
+            if(status) strcpy(buffer,in);
+        }else       
+            strcpy(buffer,functions[i]);
+        printf("%s:%d:<%s>:%d\n",functions[i],i,buffer,status);
+		strcat(wholeStuff,buffer);
+		strcat(wholeStuff,"\n");
+	}
+
+	printf("*********** BACKTRACK **************\n");
+
+	if(myFatalFunction)
+		myFatalFunction("Crash", wholeStuff); // FIXME
+#endif	//__CYGWIN__
+
+	exit(-1); // _exit(1) ???
+}
 #endif
 //EOF



From mean at mail.berlios.de  Fri Sep 25 19:38:04 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 25 Sep 2009 19:38:04 +0200
Subject: [Avidemux-svn-commit] r5351 -
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src
Message-ID: <200909251738.n8PHc4an030922@sheep.berlios.de>

Author: mean
Date: 2009-09-25 19:38:02 +0200 (Fri, 25 Sep 2009)
New Revision: 5351

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/ADM_crashdump.cpp
Log:
[backtrace] Merge 64 stuff from 2.5

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/ADM_crashdump.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/ADM_crashdump.cpp	2009-09-25 07:16:58 UTC (rev 5350)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/ADM_crashdump.cpp	2009-09-25 17:38:02 UTC (rev 5351)
@@ -44,7 +44,6 @@
         myFatalFunction=fatal;
 }
 
-static void saveCrashProject(void);
 extern char *ADM_getBaseDir(void);
 extern void A_parseECMAScript(const char *name);
 
@@ -75,10 +74,16 @@
 
 static void dumpFrame(void* processId, void* frameAddr)
 {
+#ifdef ADM_CPU_X86_64
+#define ARCH_DWORD DWORD64
+#else
+#define ARCH_DWORD DWORD
+#endif
+
 	MEMORY_BASIC_INFORMATION mbi;
 	char moduleName[MAX_PATH];
 	HMODULE moduleAddr;
-	DWORD symDisplacement;
+	ARCH_DWORD symDisplacement;
 	IMAGEHLP_SYMBOL* pSymbol;
 
 	if (VirtualQuery(frameAddr, &mbi, sizeof(mbi)))
@@ -90,12 +95,12 @@
 
 		printf("%s(", moduleName);
 
-		if (SymGetSymFromAddr(processId, (uint32_t)frameAddr, &symDisplacement, pSymbol))
+		if (SymGetSymFromAddr(processId, (ARCH_DWORD)frameAddr, &symDisplacement, pSymbol))
 			printf("%s", pSymbol->Name);
 		else
 			printf("<unknown>");
 
-		printf("+0x%X) [0x%08X]\n", (uint32_t)frameAddr - (uint32_t)moduleAddr, frameAddr);
+		printf("+0x%X) [0x%08X]\n", (ARCH_DWORD)frameAddr - (ARCH_DWORD)moduleAddr, frameAddr);
 
 		fflush(stdout);
 	}
@@ -105,8 +110,14 @@
 {
 	printf("\n*********** EXCEPTION **************\n");
 	printf("Registers:\n");
+#ifdef ADM_CPU_X86_64
+	printf("RAX: %08X  RBX: %08X  RCX: %08X  RDX: %08X  RSI: %08X  RDI: %08X  RSP: %08X  RBP: %08X\n", pContextRecord->Rax, pContextRecord->Rbx, pContextRecord->Rcx, pContextRecord->Rdx, pContextRecord->Rsi, pContextRecord->Rdi, pContextRecord->Rsp, pContextRecord->Rbp);
+	printf("R8: %08X  R9: %08X  R10: %08X  R11: %08X  R12: %08X  R13: %08X  R14: %08X  R15: %08X\n", pContextRecord->R8, pContextRecord->R9, pContextRecord->R10, pContextRecord->R11, pContextRecord->R12, pContextRecord->R13, pContextRecord->R14, pContextRecord->R15);
+	printf("RIP: %08X  EFlags: %08X\n\n", pContextRecord->Rip, pContextRecord->EFlags);
+#else
 	printf("EAX: %08X  EBX: %08X  ECX: %08X  EDX: %08X  ESI: %08X\n", pContextRecord->Eax, pContextRecord->Ebx, pContextRecord->Ecx, pContextRecord->Edx, pContextRecord->Esi);
 	printf("EDI: %08X  ESP: %08X  EBP: %08X  EIP: %08X  EFlags: %08X\n\n", pContextRecord->Edi, pContextRecord->Esp, pContextRecord->Ebp, pContextRecord->Eip, pContextRecord->EFlags);
+#endif
 
 	printf("Exception Code: ");
 
@@ -180,7 +191,13 @@
 	printf("Exception Flags: %08X\n", pExceptionRec->ExceptionFlags);
 
 	printf("\nOrigin:\n");
+
+#ifdef ADM_CPU_X86_64
+	dumpFrame(processId, (void*)pContextRecord->Rip);
+#else
 	dumpFrame(processId, (void*)pContextRecord->Eip);
+#endif
+
 	printf("*********** EXCEPTION **************\n");
 	fflush(stdout);
 }



From mean at mail.berlios.de  Fri Sep 25 19:38:07 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 25 Sep 2009 19:38:07 +0200
Subject: [Avidemux-svn-commit] r5352 - in branches/avidemux_2.6_branch_mean:
	avidemux/common avidemux/common/ADM_editor
	avidemux/common/ADM_videoFilter2
	avidemux_core/ADM_coreVideoFilter/include
	avidemux_core/ADM_coreVideoFilter/src
Message-ID: <200909251738.n8PHc7EQ030998@sheep.berlios.de>

Author: mean
Date: 2009-09-25 19:38:06 +0200 (Fri, 25 Sep 2009)
New Revision: 5352

Removed:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edAudio.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edAudio.hxx
Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/ADM_videoFilterBridge.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/common/main.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_coreVideoFilter.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_videoFilterBridge.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/ADM_coreVideoFilter.cpp
Log:
[videoFilter] Skeleton for video filter

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edAudio.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edAudio.cpp	2009-09-25 17:38:02 UTC (rev 5351)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edAudio.cpp	2009-09-25 17:38:06 UTC (rev 5352)
@@ -1 +0,0 @@
-// Rmed
\ No newline at end of file

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edAudio.hxx
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edAudio.hxx	2009-09-25 17:38:02 UTC (rev 5351)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edAudio.hxx	2009-09-25 17:38:06 UTC (rev 5352)
@@ -1 +0,0 @@
-//

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp	2009-09-25 17:38:02 UTC (rev 5351)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp	2009-09-25 17:38:06 UTC (rev 5352)
@@ -31,6 +31,7 @@
 #include "ADM_pp.h"
 
 // FIXME BADLY !!!
+// This should be in a context somewhere
 static uint8_t compBuffer[MAXIMUM_SIZE * MAXIMUM_SIZE * 3];
 /**
         \fn GoToIntra

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/CMakeLists.txt	2009-09-25 17:38:02 UTC (rev 5351)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/CMakeLists.txt	2009-09-25 17:38:06 UTC (rev 5352)
@@ -1,5 +1,4 @@
 SET(ADM_editor_SRCS
-ADM_edAudio.cpp 
 ADM_edCache.cpp 
 ADM_edIdentify.cpp 
 ADM_edLoadSave.cpp 

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/ADM_videoFilterBridge.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/ADM_videoFilterBridge.cpp	2009-09-25 17:38:02 UTC (rev 5351)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/ADM_videoFilterBridge.cpp	2009-09-25 17:38:06 UTC (rev 5352)
@@ -48,6 +48,7 @@
     printf("[VideoBridge] Goint to %"LU" ms\n",(uint32_t)(startTime/1000));
     video_body->GoToTime(startTime);
     firstImage=true;
+    lastSentImage=0;
     return true;
 }
 
@@ -63,7 +64,7 @@
     \fn getNextFrame
     \brief
 */
-bool         ADM_videoFilterBridge::getNextFrame(ADMImage *image)
+bool         ADM_videoFilterBridge::nextFrame(ADMImage *image)
 {
 again:
     bool r=false;
@@ -71,9 +72,11 @@
     {
         firstImage=false;
         r=video_body->samePicture(image);
+        lastSentImage=0;
     }else
     {
         r=   video_body->NextPicture(image);
+        lastSentImage++;
     }
     if(r==false) return false;
     // Translate pts if any
@@ -93,6 +96,28 @@
     return true;
 }
 /**
+    \fn getFrame
+    \brief This one is special. the lower level can only do sequential access
+            so we in case of non-sequential access we rely on the cache of decoded image.
+            (TODO)
+*/
+bool         ADM_videoFilterBridge::getFrame(uint32_t frame,ADMImage *image)
+{
+    if(frame==0)
+    {
+        rewind();
+        return nextFrame(image);
+    }
+    // Sequential access ?
+    if(frame==lastSentImage+1)
+    {
+        return nextFrame(image);
+    }
+    // Non sequential access : todo
+    ADM_assert(0);
+    return false;
+}
+/**
     \fn ADM_videoFilterBridge
 
 */

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/CMakeLists.txt	2009-09-25 17:38:02 UTC (rev 5351)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/CMakeLists.txt	2009-09-25 17:38:06 UTC (rev 5352)
@@ -1,5 +1,6 @@
 SET(ADM_internalVideoFilter_SRCS 
 	ADM_videoFilterBridge.cpp
         ADM_filterChain.cpp
+        ADM_pluginLoad.cpp
 )
 ADD_LIBRARY(ADM_internalVideoFilter6 STATIC ${ADM_internalVideoFilter_SRCS})

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/main.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/main.cpp	2009-09-25 17:38:02 UTC (rev 5351)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/main.cpp	2009-09-25 17:38:06 UTC (rev 5352)
@@ -239,17 +239,14 @@
     char *dmPlugins = ADM_getInstallRelativePath(startDir,"ADM_plugins6","demuxers");    
     char *mxPlugins = ADM_getInstallRelativePath(startDir,"ADM_plugins6","muxers");    
     char *vePlugins = ADM_getInstallRelativePath(startDir,"ADM_plugins6","videoEncoders");    
-    char *vfPlugins = ADM_getInstallRelativePath(startDir,"ADM_plugins6","videoFilter");
+    char *vfPlugins = ADM_getInstallRelativePath(startDir,"ADM_plugins6","videoFilters");
 
     ADM_mx_loadPlugins(mxPlugins);
     delete [] mxPlugins;
 
 	ADM_ad_loadPlugins(adPlugins);
 	delete [] adPlugins;
-#if 0 // Dont load video filter now
-	ADM_vf_loadPlugins(vfPlugins);
-	delete [] vfPlugins;
-#endif
+
     ADM_av_loadPlugins(avPlugins);
     delete [] avPlugins;
 
@@ -262,6 +259,8 @@
     ADM_ve6_loadPlugins(vePlugins);
     delete [] vePlugins;
 
+    ADM_vf_loadPlugins(vfPlugins);
+    delete [] vfPlugins;
 
     // load local audio decoder plugins
 	adPlugins=ADM_getHomeRelativePath("plugins6","audioDecoder");

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_coreVideoFilter.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_coreVideoFilter.h	2009-09-25 17:38:02 UTC (rev 5351)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_coreVideoFilter.h	2009-09-25 17:38:06 UTC (rev 5352)
@@ -36,12 +36,15 @@
  */
 class ADM_coreVideoFilter
 {
+protected:
+            uint32_t             nextFrame;
 public:
             ADM_coreVideoFilter(ADM_coreVideoFilter *previous,CONFcouple *conf=NULL);
             ~ADM_coreVideoFilter();
 
        virtual const char   *getConfiguration(void);                   /// Return  current configuration as a human readable string
-       virtual bool         getNextFrame(ADMImage *image)=0;           /// Return the next image
+       virtual bool         getFrame(uint32_t frame,ADMImage *image)=0;    /// Return the next image
+       virtual bool         getNextFrame(ADMImage *image);              /// Dont mix getFrame & getNextFrame !
 	   virtual FilterInfo  *getInfo(void);                             /// Return picture parameters after this filter
 	   virtual bool         getCoupledConf(CONFcouple **couples)=0 ;   /// Return the current filter configuration
        virtual bool         configure(void) {return true;}             /// Start graphical user interface

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_videoFilterBridge.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_videoFilterBridge.h	2009-09-25 17:38:02 UTC (rev 5351)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_videoFilterBridge.h	2009-09-25 17:38:06 UTC (rev 5352)
@@ -30,11 +30,13 @@
         uint64_t            startTime,endTime;
         FilterInfo          bridgeInfo;
         bool                firstImage;
+        uint32_t            lastSentImage;
+        virtual bool        nextFrame(ADMImage *image);    /// Return the next image
 public:
                             ADM_videoFilterBridge(uint64_t startTime, uint64_t endTime);
                             ~ADM_videoFilterBridge();
-
-       virtual bool         getNextFrame(ADMImage *image);    /// Return the next image
+       virtual bool         getFrame(uint32_t frame,ADMImage *image);
+       
 	   virtual FilterInfo  *getInfo(void);                                      /// Return picture parameters after this filter
 	   virtual bool         getCoupledConf(CONFcouple **couples) {*couples=NULL;return true;} ; /// Return the current filter configuration
 

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/ADM_coreVideoFilter.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/ADM_coreVideoFilter.cpp	2009-09-25 17:38:02 UTC (rev 5351)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/ADM_coreVideoFilter.cpp	2009-09-25 17:38:06 UTC (rev 5352)
@@ -37,6 +37,7 @@
  ADM_coreVideoFilter::ADM_coreVideoFilter(ADM_coreVideoFilter *previous,CONFcouple *conf)
 {
     previousFilter=previous;
+    nextFrame=0;
 }
 /**
     \fn  ~ADM_coreVideoFilter
@@ -61,4 +62,14 @@
     ADM_assert(previousFilter);
     return previousFilter->getInfo();
 }
+/**
+        \fn getNextFrame
+        \brief 
+*/  
+bool         ADM_coreVideoFilter::getNextFrame(ADMImage *image)     
+{
+      bool r=getFrame(nextFrame,image);
+      nextFrame++;
+      return true;
+}
 // EOF



From mean at mail.berlios.de  Fri Sep 25 19:38:11 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 25 Sep 2009 19:38:11 +0200
Subject: [Avidemux-svn-commit] r5353 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2
Message-ID: <200909251738.n8PHcBCn031022@sheep.berlios.de>

Author: mean
Date: 2009-09-25 19:38:09 +0200 (Fri, 25 Sep 2009)
New Revision: 5353

Added:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/ADM_pluginLoad.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/ADM_vf_plugin.h
Log:
[videoFilter] Skeleton for video filter (2)

Added: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/ADM_pluginLoad.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/ADM_pluginLoad.cpp	2009-09-25 17:38:06 UTC (rev 5352)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/ADM_pluginLoad.cpp	2009-09-25 17:38:09 UTC (rev 5353)
@@ -0,0 +1,165 @@
+/**
+        \file ADM_pluginLoad.cpp
+        \brief Interface for dynamically loaded video filter
+
+
+*/
+
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ ***************************************************************************/
+#include "ADM_default.h"
+#include "ADM_vf_plugin.h"
+#include "DIA_fileSel.h"
+#include "ADM_dynamicLoading.h"
+#include <vector>
+
+#if 1
+#define aprintf printf
+#else
+#define aprintf(...) {}
+#endif
+
+
+/**
+ *
+ */
+class ADM_vf_plugin : public ADM_LibWrapper
+{
+	public:
+		ADM_vf_CreateFunction		*create;
+		ADM_vf_DeleteFunction		*destroy;
+		ADM_vf_SupportedUI		    *supportedUI;
+		ADM_vf_GetApiVersion		*getApiVersion;
+		ADM_ad_GetPluginVersion	    *getFilterVersion;
+		ADM_ADM_vf_GetString    	*getDesc;
+        ADM_ADM_vf_GetString    	*getInternalName;
+        ADM_ADM_vf_GetString    	*getDisplayName;
+        
+		const char 					*nameOfLibrary;
+        const char                  *internalName;
+        const char                  *displayName;
+        const char                  *desc;
+
+		ADM_vf_plugin(const char *file) : ADM_LibWrapper()
+		{
+			initialised = (loadLibrary(file) && getSymbols(6,
+				&create, "create",
+				&destroy, "destroy",
+				&getApiVersion, "getApiVersion",
+				&supportedUI, "supportedUI",
+				&getFilterVersion, "getFilterVersion",
+				&getDesc, "getDesc",
+				&getInternalName, "getInternalName",
+				&getDisplayName, "getDisplayName"
+                ));
+		};
+};
+
+std::vector<ADM_vf_plugin *> ADM_videoFilterPluginsList;
+/**
+ * 	\fn tryLoadingVideoFilterPlugin
+ *  \brief try to load the plugin given as argument..
+ */
+static uint8_t tryLoadingVideoFilterPlugin(const char *file)
+{
+	ADM_vf_plugin *plugin = new ADM_vf_plugin(file);
+
+	if (!plugin->isAvailable())
+	{
+		printf("[ADM_vf_plugin] Unable to load %s\n", ADM_GetFileName(file));
+		goto Err_ad;
+	}
+
+	// Check API version
+	if (plugin->getApiVersion() != VF_API_VERSION)
+	{
+		printf("[ADM_vf_plugin] File %s has API version too old (%d vs %d)\n",
+			ADM_GetFileName(file), plugin->getApiVersion(), VF_API_VERSION);
+		goto Err_ad;
+	}
+
+	// Get infos
+	uint32_t major, minor, patch;
+
+	plugin->getFilterVersion(&major, &minor, &patch);
+	plugin->nameOfLibrary = ADM_strdup(ADM_GetFileName(file));
+
+    plugin->internalName=plugin->getInternalName();
+    plugin->desc=plugin->getDesc();
+    plugin->displayName=plugin->getDisplayName();
+
+	printf("[ADM_vf_plugin] Plugin loaded version %d.%d.%d, name %s/%s\n",
+		major, minor, patch, plugin->internalName, plugin->displayName);
+
+	ADM_videoFilterPluginsList.push_back(plugin);
+
+	return 1;
+
+Err_ad:
+	delete plugin;
+	return 0;
+}
+/**
+    \fn ADM_ad_GetPluginVersion
+    \brief returns the # of loaded audio decoder
+*/
+uint32_t ADM_vf_getNbFilters(void)
+{
+    return (uint32_t )ADM_videoFilterPluginsList.size();
+}
+/**
+    \fn ADM_vf_getFilterInfo
+    \brief returns infos about a given filter
+    @param filter [in] # of the filter we are intereseted in, between 0 & ADM_ad_getNbFilters
+    @param name [out] Name of the decoder plugin
+    @param major, minor,patch [out] Version number
+    @return true
+*/
+bool ADM_vf_getFilterInfo(int filter, const char **name, uint32_t *major,uint32_t *minor,uint32_t *patch)
+{
+
+        ADM_assert(filter>=0 && filter<ADM_videoFilterPluginsList.size());
+
+    	ADM_vf_plugin *a=ADM_videoFilterPluginsList[filter];
+        a->getFilterVersion(major, minor, patch);
+
+        *name=a->displayName;
+        return 1;
+}
+
+/**
+ * 	\fn ADM_ad_GetPluginVersion
+ *  \brief load all audio plugins
+ */
+uint8_t ADM_vf_loadPlugins(const char *path)
+{
+#define MAX_EXTERNAL_FILTER 50
+
+	char *files[MAX_EXTERNAL_FILTER];
+	uint32_t nbFile;
+
+	memset(files,0,sizeof(char *)*MAX_EXTERNAL_FILTER);
+	printf("[ADM_vf_plugin] Scanning directory %s\n",path);
+
+	if(!buildDirectoryContent(&nbFile, path, files, MAX_EXTERNAL_FILTER, SHARED_LIB_EXT))
+	{
+		printf("[ADM_vf_plugin] Cannot parse plugin\n");
+		return 0;
+	}
+
+	for(int i=0;i<nbFile;i++)
+		tryLoadingVideoFilterPlugin(files[i]);
+
+	printf("[ADM_vf_plugin] Scanning done, found %d codec\n", (int)ADM_videoFilterPluginsList.size());
+
+	return 1;
+}
+
+
+//EOF

Added: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/ADM_vf_plugin.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/ADM_vf_plugin.h	2009-09-25 17:38:06 UTC (rev 5352)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/ADM_vf_plugin.h	2009-09-25 17:38:09 UTC (rev 5353)
@@ -0,0 +1,60 @@
+/**
+        \fn ADM_vf_plugin.h
+        \brief Interface for dynamically loaded video filter
+*/
+#ifndef ADM_vf_plugin_h
+#define ADM_vf_plugin_h
+#include "ADM_default.h"
+#include "ADM_coreVideoFilter.h"
+
+#define VF_API_VERSION 1
+/* These are the 6 functions exported by each plugin ...*/
+typedef ADM_coreVideoFilter  *(ADM_vf_CreateFunction)(ADM_coreVideoFilter *previous,CONFcouple *conf);
+typedef void             (ADM_vf_DeleteFunction)(ADM_coreVideoFilter *codec);
+typedef int             (ADM_vf_SupportedUI)(void); //  QT4/GTK / ALL
+typedef uint32_t         (ADM_vf_GetApiVersion)(void);
+typedef bool            (ADM_ad_GetPluginVersion)(uint32_t *major, uint32_t *minor, uint32_t *patch);
+typedef const char       *(ADM_ADM_vf_GetString)(void);
+
+
+#define DECLARE_VIDEO_FILTER(Class,Major,Minor,Patch,UI,internalName,displayName,Desc) \
+	extern "C" { \
+	ADM_coreVideoFilter *create(ADM_coreVideoFilter *previous,CONFcouple *conf)\
+	{ \
+		return new Class(previous,conf);\
+	} \
+	void *destroy(ADM_coreVideoFilter *codec) \
+	{ \
+		Class *a=(Class *)codec;\
+		delete a;\
+	}\
+	int supportedUI(void) \
+	{ \
+		return 0; \
+	} \
+	uint32_t getApiVersion(void)\
+	{\
+			return VF_API_VERSION;\
+	}\
+	bool getFilterVersion(uint32_t *major,uint32_t *minor, uint32_t *patch)\
+	{\
+		*major=Major;\
+		*minor=Minor;\
+		*patch=Patch;\
+		return true;\
+	}\
+	const char *getDesc(void)\
+	{\
+		return Desc; \
+	}\
+	const char *getInternalName(void)\
+	{\
+		return internalName; \
+	}\
+	const char *getDisplayName(void)\
+	{\
+		return displayName; \
+	}\
+	}
+
+#endif



From mean at mail.berlios.de  Fri Sep 25 19:38:19 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 25 Sep 2009 19:38:19 +0200
Subject: [Avidemux-svn-commit] r5354 - in branches/avidemux_2.6_branch_mean:
	. avidemux_plugins cmake
Message-ID: <200909251738.n8PHcJcO031065@sheep.berlios.de>

Author: mean
Date: 2009-09-25 19:38:18 +0200 (Fri, 25 Sep 2009)
New Revision: 5354

Modified:
   branches/avidemux_2.6_branch_mean/.gitignore
   branches/avidemux_2.6_branch_mean/avidemux_plugins/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/cmake/vf_plugin.cmake
Log:
[videoFilter] Skeleton for video filter (3)

Modified: branches/avidemux_2.6_branch_mean/.gitignore
===================================================================
--- branches/avidemux_2.6_branch_mean/.gitignore	2009-09-25 17:38:09 UTC (rev 5353)
+++ branches/avidemux_2.6_branch_mean/.gitignore	2009-09-25 17:38:18 UTC (rev 5354)
@@ -8,3 +8,4 @@
 *.sw*
 build*
 debs
+addons/*

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/CMakeLists.txt	2009-09-25 17:38:09 UTC (rev 5353)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/CMakeLists.txt	2009-09-25 17:38:18 UTC (rev 5354)
@@ -60,7 +60,7 @@
 ADD_SUBDIRECTORY(ADM_audioDecoders)
 ADD_SUBDIRECTORY(ADM_audioDevices)
 ADD_SUBDIRECTORY(ADM_videoEncoder)
-#ADD_SUBDIRECTORY(ADM_videoFilters)
+ADD_SUBDIRECTORY(ADM_videoFilters6)
 ADD_SUBDIRECTORY(ADM_audioEncoders)
 ADD_SUBDIRECTORY(ADM_demuxers)
 ADD_SUBDIRECTORY(ADM_muxers)

Modified: branches/avidemux_2.6_branch_mean/cmake/vf_plugin.cmake
===================================================================
--- branches/avidemux_2.6_branch_mean/cmake/vf_plugin.cmake	2009-09-25 17:38:09 UTC (rev 5353)
+++ branches/avidemux_2.6_branch_mean/cmake/vf_plugin.cmake	2009-09-25 17:38:18 UTC (rev 5354)
@@ -1,12 +1,17 @@
-MACRO(INIT_VIDEOFILTER_PLUGIN _lib)
-    INCLUDE_DIRECTORIES(.)
+SET(VF_PLUGIN_DIR "${CMAKE_INSTALL_PREFIX}/lib/ADM_plugins6/videoFilters/")
+MACRO(INIT_VIDEO_FILTER _lib)
+        INCLUDE_DIRECTORIES(.)
 	INCLUDE_DIRECTORIES("${AVIDEMUX_CORECONFIG_DIR}")
 	INCLUDE_DIRECTORIES("${AVIDEMUX_TOP_SOURCE_DIR}/avidemux/ADM_core/include")
 	INCLUDE_DIRECTORIES("${AVIDEMUX_TOP_SOURCE_DIR}/avidemux/ADM_coreUI/include")
-	INCLUDE_DIRECTORIES("${AVIDEMUX_TOP_SOURCE_DIR}/avidemux/ADM_coreImage/include")
-ENDMACRO(INIT_VIDEOFILTER_PLUGIN)
+	INCLUDE_DIRECTORIES("${AVIDEMUX_TOP_SOURCE_DIR}/avidemux/ADM_coreUtils/include/")
+	INCLUDE_DIRECTORIES("${AVIDEMUX_TOP_SOURCE_DIR}/avidemux/ADM_coreVideoFilter/include/")
+	INCLUDE_DIRECTORIES("${AVIDEMUX_TOP_SOURCE_DIR}/avidemux/ADM_coreImage/include/")
+        ADD_DEFINITIONS("-DADM_MINIMAL_UI_INTERFACE")
+ENDMACRO(INIT_VIDEO_FILTER)
 
-MACRO(INSTALL_VIDEOFILTER _lib)
-	TARGET_LINK_LIBRARIES(${_lib} ADM_core6 ADM_coreUI6 ADM_coreImage6 )
-	INSTALL(TARGETS ${_lib} DESTINATION "${CMAKE_INSTALL_PREFIX}/lib/ADM_plugins6/videoFilter/")
-ENDMACRO(INSTALL_VIDEOFILTER)
+MACRO(INSTALL_VIDEO_FILTER _lib)
+	INSTALL(TARGETS ${_lib} DESTINATION "${VF_PLUGIN_DIR}")
+	TARGET_LINK_LIBRARIES(${_lib} ADM_core6 ADM_coreUI6 ADM_coreVideoFilter6 ADM_coreImage6)
+ENDMACRO(INSTALL_VIDEO_FILTER)
+



From mean at mail.berlios.de  Fri Sep 25 19:38:22 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 25 Sep 2009 19:38:22 +0200
Subject: [Avidemux-svn-commit] r5355 - in
	branches/avidemux_2.6_branch_mean/avidemux_plugins: .
	ADM_videoFilters6 ADM_videoFilters6/dummy
Message-ID: <200909251738.n8PHcMLT031087@sheep.berlios.de>

Author: mean
Date: 2009-09-25 19:38:21 +0200 (Fri, 25 Sep 2009)
New Revision: 5355

Added:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/dummy/
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/dummy/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/dummy/dummyVideoFilter.cpp
Log:
[VideoFilter] Dummy video filter

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/CMakeLists.txt	2009-09-25 17:38:18 UTC (rev 5354)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/CMakeLists.txt	2009-09-25 17:38:21 UTC (rev 5355)
@@ -0,0 +1 @@
+ADD_SUBDIRECTORY(dummy)

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/dummy/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/dummy/CMakeLists.txt	2009-09-25 17:38:18 UTC (rev 5354)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/dummy/CMakeLists.txt	2009-09-25 17:38:21 UTC (rev 5355)
@@ -0,0 +1,9 @@
+INCLUDE(vf_plugin)
+
+
+SET(ADM_vf_dummy_SRCS dummyVideoFilter.cpp)
+
+ADD_LIBRARY(ADM_vf_dummy SHARED ${ADM_vf_dummy_SRCS})
+
+INIT_VIDEO_FILTER(ADM_vf_dummy)
+INSTALL_VIDEO_FILTER(ADM_vf_dummy)

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/dummy/dummyVideoFilter.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/dummy/dummyVideoFilter.cpp	2009-09-25 17:38:18 UTC (rev 5354)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/dummy/dummyVideoFilter.cpp	2009-09-25 17:38:21 UTC (rev 5355)
@@ -0,0 +1,94 @@
+/** *************************************************************************
+                    \fn       dummyVideoFilter.cpp  
+                    \brief simplest of all video filters, it does nothing
+
+    copyright            : (C) 2009 by mean
+
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "ADM_default.h"
+#include "ADM_vf_plugin.h"
+
+/**
+    \class dummyVideoFilter
+*/
+class dummyVideoFilter : public  ADM_coreVideoFilter
+{
+public:
+                    dummyVideoFilter(ADM_coreVideoFilter *previous,CONFcouple *conf);
+                    ~dummyVideoFilter();
+
+       virtual const char   *getConfiguration(void);                   /// Return  current configuration as a human readable string
+       virtual bool         getFrame(uint32_t frame,ADMImage *image);    /// Return the next image
+	 //  virtual FilterInfo  *getInfo(void);                             /// Return picture parameters after this filter
+	   virtual bool         getCoupledConf(CONFcouple **couples) ;   /// Return the current filter configuration
+       virtual bool         configure(void) {return true;}             /// Start graphical user interface
+};
+
+// Add the hook to make it valid plugin
+DECLARE_VIDEO_FILTER(   dummyVideoFilter,   // Class
+                        1,0,0,              // Version
+                        0,                  // UI
+                        "dummy",            // internal name (must be uniq!)
+                        "Dummy",            // Display name
+                        "Null filter, it does nothing at all." // Description
+                    );
+
+// Now implements the interesting parts
+/**
+    \fn dummyVideoFilter
+    \brief constructor
+*/
+dummyVideoFilter::dummyVideoFilter(  ADM_coreVideoFilter *in,CONFcouple *setup) : ADM_coreVideoFilter(in,setup)
+{
+UNUSED_ARG(setup);
+
+    // By default the info field contains the output of previous filter
+    // Tweak it here if you change fps, duration, width,...
+}
+/**
+    \fn dummyVideoFilter
+    \brief destructor
+*/
+dummyVideoFilter::~dummyVideoFilter()
+{
+		
+}
+/**
+    \fn getFrame
+    \brief Get a processed frame
+*/
+bool dummyVideoFilter::getFrame(uint32_t frame,ADMImage *image)
+{
+    // since we do nothing, just get the output of previous filter
+    return previousFilter->getFrame(frame,image);
+}
+/**
+    \fn getCoupledConf
+    \brief Return our current configuration as couple name=value
+*/
+bool         dummyVideoFilter::getCoupledConf(CONFcouple **couples)
+{
+    *couples=new CONFcouple(0); // Even if we dont have configuration we must allocate one 
+    return true;
+}
+/**
+    \fn getConfiguration
+    \brief Return current setting as a string
+*/
+const char *dummyVideoFilter::getConfiguration(void)
+{
+    
+    return "Dummy Filter.";
+}
+// Normally not needed :virtual FilterInfo  *getInfo(void)
+//EOF
\ No newline at end of file



From mean at mail.berlios.de  Fri Sep 25 19:38:27 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 25 Sep 2009 19:38:27 +0200
Subject: [Avidemux-svn-commit] r5356 - in branches/avidemux_2.6_branch_mean:
	avidemux/common/ADM_videoFilter2
	avidemux_core/ADM_coreVideoFilter/include
	avidemux_core/ADM_coreVideoFilter/src cmake
Message-ID: <200909251738.n8PHcRYd031142@sheep.berlios.de>

Author: mean
Date: 2009-09-25 19:38:25 +0200 (Fri, 25 Sep 2009)
New Revision: 5356

Added:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_vf_plugin.h
Removed:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/ADM_vf_plugin.h
Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_coreVideoFilter.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/ADM_coreVideoFilter.cpp
   branches/avidemux_2.6_branch_mean/cmake/vf_plugin.cmake
Log:
[videoFilter] Cleanup

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/ADM_vf_plugin.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/ADM_vf_plugin.h	2009-09-25 17:38:21 UTC (rev 5355)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/ADM_vf_plugin.h	2009-09-25 17:38:25 UTC (rev 5356)
@@ -1,60 +0,0 @@
-/**
-        \fn ADM_vf_plugin.h
-        \brief Interface for dynamically loaded video filter
-*/
-#ifndef ADM_vf_plugin_h
-#define ADM_vf_plugin_h
-#include "ADM_default.h"
-#include "ADM_coreVideoFilter.h"
-
-#define VF_API_VERSION 1
-/* These are the 6 functions exported by each plugin ...*/
-typedef ADM_coreVideoFilter  *(ADM_vf_CreateFunction)(ADM_coreVideoFilter *previous,CONFcouple *conf);
-typedef void             (ADM_vf_DeleteFunction)(ADM_coreVideoFilter *codec);
-typedef int             (ADM_vf_SupportedUI)(void); //  QT4/GTK / ALL
-typedef uint32_t         (ADM_vf_GetApiVersion)(void);
-typedef bool            (ADM_ad_GetPluginVersion)(uint32_t *major, uint32_t *minor, uint32_t *patch);
-typedef const char       *(ADM_ADM_vf_GetString)(void);
-
-
-#define DECLARE_VIDEO_FILTER(Class,Major,Minor,Patch,UI,internalName,displayName,Desc) \
-	extern "C" { \
-	ADM_coreVideoFilter *create(ADM_coreVideoFilter *previous,CONFcouple *conf)\
-	{ \
-		return new Class(previous,conf);\
-	} \
-	void *destroy(ADM_coreVideoFilter *codec) \
-	{ \
-		Class *a=(Class *)codec;\
-		delete a;\
-	}\
-	int supportedUI(void) \
-	{ \
-		return 0; \
-	} \
-	uint32_t getApiVersion(void)\
-	{\
-			return VF_API_VERSION;\
-	}\
-	bool getFilterVersion(uint32_t *major,uint32_t *minor, uint32_t *patch)\
-	{\
-		*major=Major;\
-		*minor=Minor;\
-		*patch=Patch;\
-		return true;\
-	}\
-	const char *getDesc(void)\
-	{\
-		return Desc; \
-	}\
-	const char *getInternalName(void)\
-	{\
-		return internalName; \
-	}\
-	const char *getDisplayName(void)\
-	{\
-		return displayName; \
-	}\
-	}
-
-#endif

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_coreVideoFilter.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_coreVideoFilter.h	2009-09-25 17:38:21 UTC (rev 5355)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_coreVideoFilter.h	2009-09-25 17:38:25 UTC (rev 5356)
@@ -37,6 +37,7 @@
 class ADM_coreVideoFilter
 {
 protected:
+            FilterInfo           info;
             uint32_t             nextFrame;
 public:
             ADM_coreVideoFilter(ADM_coreVideoFilter *previous,CONFcouple *conf=NULL);

Copied: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_vf_plugin.h (from rev 5355, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/ADM_vf_plugin.h)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/ADM_vf_plugin.h	2009-09-25 17:38:21 UTC (rev 5355)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_vf_plugin.h	2009-09-25 17:38:25 UTC (rev 5356)
@@ -0,0 +1,60 @@
+/**
+        \fn ADM_vf_plugin.h
+        \brief Interface for dynamically loaded video filter
+*/
+#ifndef ADM_vf_plugin_h
+#define ADM_vf_plugin_h
+#include "ADM_default.h"
+#include "ADM_coreVideoFilter.h"
+
+#define VF_API_VERSION 1
+/* These are the 6 functions exported by each plugin ...*/
+typedef ADM_coreVideoFilter  *(ADM_vf_CreateFunction)(ADM_coreVideoFilter *previous,CONFcouple *conf);
+typedef void             (ADM_vf_DeleteFunction)(ADM_coreVideoFilter *codec);
+typedef int             (ADM_vf_SupportedUI)(void); //  QT4/GTK / ALL
+typedef uint32_t         (ADM_vf_GetApiVersion)(void);
+typedef bool            (ADM_ad_GetPluginVersion)(uint32_t *major, uint32_t *minor, uint32_t *patch);
+typedef const char       *(ADM_ADM_vf_GetString)(void);
+
+
+#define DECLARE_VIDEO_FILTER(Class,Major,Minor,Patch,UI,internalName,displayName,Desc) \
+	extern "C" { \
+	ADM_coreVideoFilter *create(ADM_coreVideoFilter *previous,CONFcouple *conf)\
+	{ \
+		return new Class(previous,conf);\
+	} \
+	void *destroy(ADM_coreVideoFilter *codec) \
+	{ \
+		Class *a=(Class *)codec;\
+		delete a;\
+	}\
+	int supportedUI(void) \
+	{ \
+		return 0; \
+	} \
+	uint32_t getApiVersion(void)\
+	{\
+			return VF_API_VERSION;\
+	}\
+	bool getFilterVersion(uint32_t *major,uint32_t *minor, uint32_t *patch)\
+	{\
+		*major=Major;\
+		*minor=Minor;\
+		*patch=Patch;\
+		return true;\
+	}\
+	const char *getDesc(void)\
+	{\
+		return Desc; \
+	}\
+	const char *getInternalName(void)\
+	{\
+		return internalName; \
+	}\
+	const char *getDisplayName(void)\
+	{\
+		return displayName; \
+	}\
+	}
+
+#endif

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/ADM_coreVideoFilter.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/ADM_coreVideoFilter.cpp	2009-09-25 17:38:21 UTC (rev 5355)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/ADM_coreVideoFilter.cpp	2009-09-25 17:38:25 UTC (rev 5356)
@@ -38,6 +38,7 @@
 {
     previousFilter=previous;
     nextFrame=0;
+    if(previous) memcpy(&info,previous->getInfo(),sizeof(info));
 }
 /**
     \fn  ~ADM_coreVideoFilter

Modified: branches/avidemux_2.6_branch_mean/cmake/vf_plugin.cmake
===================================================================
--- branches/avidemux_2.6_branch_mean/cmake/vf_plugin.cmake	2009-09-25 17:38:21 UTC (rev 5355)
+++ branches/avidemux_2.6_branch_mean/cmake/vf_plugin.cmake	2009-09-25 17:38:25 UTC (rev 5356)
@@ -1,12 +1,12 @@
-SET(VF_PLUGIN_DIR "${CMAKE_INSTALL_PREFIX}/lib/ADM_plugins6/videoFilters/")
+SET(VF_PLUGIN_DIR "${CMAKE_INSTALL_PREFIX}/lib/ADM_plugins6/videoFilters/")
 MACRO(INIT_VIDEO_FILTER _lib)
         INCLUDE_DIRECTORIES(.)
-	INCLUDE_DIRECTORIES("${AVIDEMUX_CORECONFIG_DIR}")
-	INCLUDE_DIRECTORIES("${AVIDEMUX_TOP_SOURCE_DIR}/avidemux/ADM_core/include")
-	INCLUDE_DIRECTORIES("${AVIDEMUX_TOP_SOURCE_DIR}/avidemux/ADM_coreUI/include")
-	INCLUDE_DIRECTORIES("${AVIDEMUX_TOP_SOURCE_DIR}/avidemux/ADM_coreUtils/include/")
-	INCLUDE_DIRECTORIES("${AVIDEMUX_TOP_SOURCE_DIR}/avidemux/ADM_coreVideoFilter/include/")
-	INCLUDE_DIRECTORIES("${AVIDEMUX_TOP_SOURCE_DIR}/avidemux/ADM_coreImage/include/")
+	#INCLUDE_DIRECTORIES("${AVIDEMUX_CORECONFIG_DIR}")
+	INCLUDE_DIRECTORIES("${AVIDEMUX_TOP_SOURCE_DIR}/avidemux_core/ADM_core/include")
+	INCLUDE_DIRECTORIES("${AVIDEMUX_TOP_SOURCE_DIR}/avidemux_core/ADM_coreUI/include")
+	INCLUDE_DIRECTORIES("${AVIDEMUX_TOP_SOURCE_DIR}/avidemux_core/ADM_coreUtils/include/")
+	INCLUDE_DIRECTORIES("${AVIDEMUX_TOP_SOURCE_DIR}/avidemux_core/ADM_coreVideoFilter/include/")
+	INCLUDE_DIRECTORIES("${AVIDEMUX_TOP_SOURCE_DIR}/avidemux_core/ADM_coreImage/include/")
         ADD_DEFINITIONS("-DADM_MINIMAL_UI_INTERFACE")
 ENDMACRO(INIT_VIDEO_FILTER)
 



From mean at mail.berlios.de  Sat Sep 26 09:45:37 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 26 Sep 2009 09:45:37 +0200
Subject: [Avidemux-svn-commit] r5357 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor
Message-ID: <200909260745.n8Q7jbPI003600@sheep.berlios.de>

Author: mean
Date: 2009-09-26 09:45:37 +0200 (Sat, 26 Sep 2009)
New Revision: 5357

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADMedAVIAUD.cpp
Log:
[editor] Dont use removed file

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADMedAVIAUD.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADMedAVIAUD.cpp	2009-09-25 17:38:25 UTC (rev 5356)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADMedAVIAUD.cpp	2009-09-26 07:45:37 UTC (rev 5357)
@@ -31,7 +31,6 @@
 
 #include "fourcc.h"
 #include "ADM_editor/ADM_edit.hxx"
-#include "ADM_editor/ADM_edAudio.hxx"
 
 #include "ADM_debugID.h"
 #define MODULE_NAME MODULE_AUDIO_EDITOR



From gruntster at mail.berlios.de  Sat Sep 26 12:07:14 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Sat, 26 Sep 2009 12:07:14 +0200
Subject: [Avidemux-svn-commit] r5358 -
	branches/avidemux_2.5_branch_gruntster/cmake
Message-ID: <200909261007.n8QA7EG2013361@sheep.berlios.de>

Author: gruntster
Date: 2009-09-26 12:07:07 +0200 (Sat, 26 Sep 2009)
New Revision: 5358

Modified:
   branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake
   branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegUtil.cmake
Log:
[macosx] keep original ffmpeg library names on Mac

Modified: branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake	2009-09-26 07:45:37 UTC (rev 5357)
+++ branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake	2009-09-26 10:07:07 UTC (rev 5358)
@@ -39,9 +39,9 @@
 		patch_file("${FFMPEG_SOURCE_DIR}" "${patchFile}")
 	endforeach(patchFile)
 
-	if (NOT WIN32)
+	if (UNIX AND NOT APPLE)
 		patch_file("${FFMPEG_SOURCE_DIR}" "${CMAKE_SOURCE_DIR}/cmake/patches/common.mak.diff")
-	endif (NOT WIN32)
+	endif (UNIX AND NOT APPLE)
 
 	message("")
 endif (FFMPEG_PERFORM_PATCH)
@@ -110,10 +110,10 @@
 					WORKING_DIRECTORY "${FFMPEG_BINARY_DIR}"
 					${ffmpegBuildOutput})
 
-	if (NOT WIN32)
+	if (UNIX AND NOT APPLE)
 		find_patch()
 		patch_file("${FFMPEG_BINARY_DIR}" "${CMAKE_SOURCE_DIR}/cmake/patches/config.mak.diff")
-	endif (NOT WIN32)
+	endif (UNIX AND NOT APPLE)
 
 	message("")
 endif (FFMPEG_PERFORM_BUILD)

Modified: branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegUtil.cmake
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegUtil.cmake	2009-09-26 07:45:37 UTC (rev 5357)
+++ branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegUtil.cmake	2009-09-26 10:07:07 UTC (rev 5358)
@@ -11,9 +11,9 @@
 	getFfmpegVersionFromHeader("libpostproc" "${sourceDir}/libpostproc/postprocess.h" LIBPOSTPROC_VERSION_MAJOR LIBPOSTPROC_VERSION)
 	getFfmpegVersionFromHeader("libswscale" "${sourceDir}/libswscale/swscale.h" LIBSWSCALE_VERSION_MAJOR LIBSWSCALE_VERSION)
 
-	if (NOT WIN32)
+	if (UNIX AND NOT APPLE)
 		set(LIBAVCODEC_ADM ADM5)
-	endif (NOT WIN32)
+	endif (UNIX AND NOT APPLE)
 
 	if (APPLE)
 		set(LIBAVCODEC_LIB lib${LIBAVCODEC_ADM}avcodec.${LIBAVCODEC_VERSION}${CMAKE_SHARED_LIBRARY_SUFFIX})



From gruntster at mail.berlios.de  Wed Sep 30 23:25:24 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Wed, 30 Sep 2009 23:25:24 +0200
Subject: [Avidemux-svn-commit] r5360 -
	branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264
Message-ID: <200909302125.n8ULPO25019848@sheep.berlios.de>

Author: gruntster
Date: 2009-09-30 23:25:18 +0200 (Wed, 30 Sep 2009)
New Revision: 5360

Modified:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/encoder.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/encoder.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/x264Options.cpp
Log:
[x264] support API version 76

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/encoder.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/encoder.cpp	2009-09-29 05:00:26 UTC (rev 5359)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/encoder.cpp	2009-09-30 21:25:18 UTC (rev 5360)
@@ -60,8 +60,10 @@
 	_extraData = NULL;
 	_extraDataSize = 0;
 
+#if X264_BUILD < 76
 	_seiUserData = NULL;
 	_seiUserDataLen = 0;
+#endif
 
 	_encodeOptions.structSize = sizeof(vidEncOptions);
 	_encodeOptions.encodeMode = DEFAULT_ENCODE_MODE;
@@ -329,15 +331,27 @@
 		_picture.img.i_plane = 3;
 	}
 
+#if X264_BUILD > 75
+	int size = x264_encoder_encode(_handle, &nal, &nalCount, encodeParams->frameData[0] ? &_picture : NULL, &picture_out);
+
+	if (size > 0)
+	{
+		memcpy(_buffer, nal->p_payload, size);
+	}
+	else if (size < 0)
+	{
+		printf("[x264] Error encoding\n");
+		return ADM_VIDENC_ERR_FAILED;
+	}
+
+	encodeParams->encodedDataSize = size;
+#else
 	if (x264_encoder_encode(_handle, &nal, &nalCount, encodeParams->frameData[0] ? &_picture : NULL, &picture_out) < 0)
 	{
 		printf("[x264] Error encoding\n");
 		return ADM_VIDENC_ERR_FAILED;
 	}
 
-	_currentFrame++;
-
-	// Write
 	int size = 0;
 	int currentNal, sizemax;
 
@@ -363,13 +377,16 @@
 	}
 
 	encodeParams->encodedDataSize = size;
+#endif
+
+	_currentFrame++;
 	encodeParams->ptsFrame = picture_out.i_pts;	// In fact it is the picture number in out case
 
 	switch (picture_out.i_type)
 	{
 		case X264_TYPE_IDR:
 			encodeParams->frameType = ADM_VIDENC_FRAMETYPE_IDR;
-
+#if X264_BUILD < 76
 			if(!_param.b_repeat_headers && _seiUserData && !picture_out.i_pts)
 			{
 				// Put our SEI front...
@@ -389,6 +406,7 @@
 				size += 4 + _seiUserDataLen;
 				encodeParams->encodedDataSize = size; // update total size
 			}
+#endif
 
 			break;
 		case X264_TYPE_I:
@@ -413,6 +431,18 @@
 {
 	x264_nal_t *nal;
 	int nalCount;
+
+	if (!_handle)
+		return false;
+
+	if (_extraData)
+		delete _extraData;
+
+#if X264_BUILD > 75
+	_extraDataSize = x264_encoder_headers(_handle, &nal, &nalCount);
+	_extraData = new uint8_t[_extraDataSize];
+	memcpy(_extraData, nal->p_payload, _extraDataSize);
+#else
 	uint32_t offset = 0;
 	uint8_t buffer[X264_MAX_HEADER_SIZE];
 	uint8_t picParam[X264_MAX_HEADER_SIZE];
@@ -421,21 +451,11 @@
 	int picParamLen = 0, seqParamLen = 0, seiParamLen = 0, len;
 	int sz;
 
-	if (!_handle)
-		return false;
-
-	if (x264_encoder_headers(_handle, &nal, &nalCount))
-	{
-		printf("[x264] Cannot create header\n");
-		return false;
-	}
-
-	if (_extraData)
-		delete _extraData;
-
 	_extraData = new uint8_t[X264_MAX_HEADER_SIZE];
 	_extraDataSize = 0;
 
+	x264_encoder_headers(_handle, &nal, &nalCount)
+
 	printf("[x264] Nal count: %d\n", nalCount);
 
 	// Now encode them
@@ -509,8 +529,10 @@
 	}
 
 	_extraDataSize = offset;
+#endif
 
 	printf("[x264] generated %d extra bytes for header\n", _extraDataSize);
+
 	return true;
 }
 
@@ -535,12 +557,14 @@
 		_extraDataSize = 0;
 	}
 
+#if X264_BUILD < 76
 	if (_seiUserData)
 	{
 		delete [] _seiUserData;
 		_seiUserData = NULL;
 		_seiUserDataLen = 0;
 	}
+#endif
 
 	return ADM_VIDENC_ERR_SUCCESS;
 }

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/encoder.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/encoder.h	2009-09-29 05:00:26 UTC (rev 5359)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/encoder.h	2009-09-30 21:25:18 UTC (rev 5360)
@@ -52,8 +52,10 @@
 		int _currentPass, _passCount;
 		bool _opened, _openPass;
 
+#if X264_BUILD < 76
 		uint8_t *_seiUserData;
 		uint32_t _seiUserDataLen;
+#endif
 
 		uint8_t *_extraData;
 		int _extraDataSize;

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/x264Options.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/x264Options.cpp	2009-09-29 05:00:26 UTC (rev 5359)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/x264Options.cpp	2009-09-30 21:25:18 UTC (rev 5360)
@@ -24,8 +24,6 @@
 #include <math.h>
 #include <libxml/parser.h>
 #include <libxml/xmlschemas.h>
-#include <sstream>
-#include <string>
 
 #include "config.h"
 #include "ADM_inttype.h"



