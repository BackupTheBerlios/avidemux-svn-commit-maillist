From mean at mail.berlios.de  Mon Jan  1 19:14:56 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Mon, 1 Jan 2007 19:14:56 +0100
Subject: [Avidemux-svn-commit] r2671 -
	branches/avidemux_2.4_branch/avidemux/ADM_encoder
Message-ID: <200701011814.l01IEuj6013192@sheep.berlios.de>

Author: mean
Date: 2007-01-01 19:14:55 +0100 (Mon, 01 Jan 2007)
New Revision: 2671

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_encoder/ADM_encCodecDesc.h
   branches/avidemux_2.4_branch/avidemux/ADM_encoder/adm_encConfig.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_encoder/adm_encConfig.h
Log:
prepare for PSP/H264 profile (not working)

Modified: branches/avidemux_2.4_branch/avidemux/ADM_encoder/ADM_encCodecDesc.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_encoder/ADM_encCodecDesc.h	2006-12-30 10:32:54 UTC (rev 2670)
+++ branches/avidemux_2.4_branch/avidemux/ADM_encoder/ADM_encCodecDesc.h	2007-01-01 18:14:55 UTC (rev 2671)
@@ -218,7 +218,7 @@
   0.5,				//         qblur;      /* amount of qscale smoothing over time (0.0-1.0) */
   (600 * 1000 >> 3),		// min bitrate in kB/S
   (2200 * 1000) >> 3,		// max bitrate
-  0,				// user_matrix 0->default, 1 tmpg, 2 anim? , 3 kvcd
+  0,				// user_matrix 0->default, 1 tmpg, 2 anim???, 3 kvcd
   12,				// Safe gop size limit
   NULL,				// inter & intra matrix, will be set depending on user_matrix
   NULL,
@@ -278,7 +278,7 @@
   0.5,				//         qblur;      /* amount of qscale smoothing over time (0.0-1.0) */
   0,				// min bitrate in kB/S
   (8000 * 1000) >> 3,		// max bitrate
-  0,				// user_matrix 0->default, 1 tmpg, 2 anim? , 3 kvcd
+  0,				// user_matrix 0->default, 1 tmpg, 2 anim???, 3 kvcd
   12,				// Safe gop size limit
   NULL,				// inter & intra matrix, will be set depending on user_matrix
   NULL,
@@ -338,7 +338,7 @@
   0.5,				//         qblur;      /* amount of qscale smoothing over time (0.0-1.0) */
   0,				// min bitrate in kB/S
   (2400 * 1000) >> 3,		// max bitrate
-  0,				// user_matrix 0->default, 1 tmpg, 2 anim? , 3 kvcd
+  0,				// user_matrix 0->default, 1 tmpg, 2 anim???, 3 kvcd
   12,				// Safe gop size limit
   NULL,				// inter & intra matrix, will be set depending on user_matrix
   NULL,
@@ -614,10 +614,60 @@
 1,//     uint32_t Trellis;
 1, //        ChromaME
 0, // Mixed Ref
-0 //NoiseReduction
-  
+0, //NoiseReduction
+51 // level IDC for psp  
 };
-
+/**************************************/
+ADM_x264Param x264ExtraPSP = {
+0,//     uint32_t  globalHeader;
+0,//     uint32_t  nbThreads;
+NULL,//     char      *logfile;
+//     //
+40,//     uint32_t KeyframeBoost;
+30,//     uint32_t BframeReduction;
+60,//     uint32_t BitrateVariability;
+//     //
+10,//     uint32_t  MinQp;
+51,//     uint32_t  MaxQp;
+4,//     uint32_t  QpStep;
+//     //
+1, //     uint32_t maxRefScene
+40,//     uint32_t  SceneCut;
+25,//     uint32_t  MinIdr;
+250,//     uint32_t  MaxIdr;
+//     //
+1,//     uint32_t  _8x8;
+1,//     uint32_t   _8x8P;
+1,//     uint32_t   _8x8B;
+0,//     uint32_t   _4x4;
+1,//     uint32_t   _8X8I;
+0,//     uint32_t   _4x4I;
+//     //
+0,//     uint32_t  MaxBFrame;
+0,//     int32_t   Bias;
+//     //
+0,//     uint32_t BasReference;
+0,//     uint32_t BidirME;
+1,//     uint32_t Adaptative;
+1,//     uint32_t Weighted;
+0,//     uint32_t DirectMode;
+//     //
+4,//     uint32_t PartitionDecision;
+32, //Range
+1,//     uint32_t Method;
+4,//     uint32_t AR_Num;
+3,//     uint32_t AR_Den;
+1,//     uint32_t DeblockingFilter;
+0,//     int32_t  Strength;
+0,//     int32_t  Threshold;
+0,//     uint32_t CABAC;
+0,//     uint32_t Trellis;
+1, //        ChromaME
+0, // Mixed Ref
+0, //NoiseReduction
+30 // level IDC for psp  
+};
+/**************************************/
 ADM_x264Param x264ExtraDefault=x264Extra;
 extern uint8_t DIA_x264 (COMPRES_PARAMS * conf);
 COMPRES_PARAMS x264Codec = {

Modified: branches/avidemux_2.4_branch/avidemux/ADM_encoder/adm_encConfig.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_encoder/adm_encConfig.cpp	2006-12-30 10:32:54 UTC (rev 2670)
+++ branches/avidemux_2.4_branch/avidemux/ADM_encoder/adm_encConfig.cpp	2007-01-01 18:14:55 UTC (rev 2671)
@@ -949,6 +949,16 @@
   DVDExtra.maxBitrate = (DVDExtra.maxBitrate*1000) >> 3;
   return 1;
 }
+#ifdef USE_X264
+/**
+    \fn     setPSP_X264Preset(void)
+    \brief  set x264 codec conf to the PSP preset
+*/
+void setPSP_X264Preset(void)
+{
+ memcpy(&x264Extra,&x264ExtraPSP,sizeof(x264ExtraPSP)); 
+}
+#endif
 uint8_t oplug_mpegStore(void)
 {
   uint32_t br;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_encoder/adm_encConfig.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_encoder/adm_encConfig.h	2006-12-30 10:32:54 UTC (rev 2670)
+++ branches/avidemux_2.4_branch/avidemux/ADM_encoder/adm_encConfig.h	2007-01-01 18:14:55 UTC (rev 2671)
@@ -15,4 +15,6 @@
 const char *videoCodecGetMode (void);
 uint8_t videoCodecSetFinalSize (uint32_t size);
 
+//
+void setPSP_X264Preset(void);
 #endif



From mean at mail.berlios.de  Mon Jan  1 19:15:50 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Mon, 1 Jan 2007 19:15:50 +0100
Subject: [Avidemux-svn-commit] r2672 - in
	branches/avidemux_2.4_branch/avidemux: . ADM_codecs ADM_filter
Message-ID: <200701011815.l01IFoJk016382@sheep.berlios.de>

Author: mean
Date: 2007-01-01 19:15:50 +0100 (Mon, 01 Jan 2007)
New Revision: 2672

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_x264param.h
   branches/avidemux_2.4_branch/avidemux/ADM_filter/vidVCD.cpp
   branches/avidemux_2.4_branch/avidemux/gui_action.hxx
   branches/avidemux_2.4_branch/avidemux/gui_autodrive.cpp
Log:
prepare for PSP/H264 profile (not working)

Modified: branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_x264param.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_x264param.h	2007-01-01 18:14:55 UTC (rev 2671)
+++ branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_x264param.h	2007-01-01 18:15:50 UTC (rev 2672)
@@ -60,7 +60,7 @@
   uint32_t MixedRefs;
   uint32_t NoiseReduction;
   //
-
+  uint32_t idc;
   //
 
 } ADM_x264Param;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_filter/vidVCD.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_filter/vidVCD.cpp	2007-01-01 18:14:55 UTC (rev 2671)
+++ branches/avidemux_2.4_branch/avidemux/ADM_filter/vidVCD.cpp	2007-01-01 18:15:50 UTC (rev 2672)
@@ -72,7 +72,11 @@
 static targetFmt SVCD={480, 720, 576, 480};
 static targetFmt DVD={720, 720, 576, 480};
 static targetFmt DVDHD1={352, 720, 576, 480};
+#if 0
+static targetFmt PSP={368, 368, 208, 208};
+#else
 static targetFmt PSP={320, 320, 240, 240};
+#endif
 targetFmt *allFormats[5]={&VCD,&SVCD,&DVD,&DVDHD1,&PSP};
 extern AVDMGenericVideoStream *createResampleFps(AVDMGenericVideoStream *in,uint32_t targetfps1000);
 #define ARME(x) format=RESWIZ_##x;
@@ -83,6 +87,10 @@
   ARME (VCD);
   return computeResize();
 }
+/**
+    \fn     setPSP (void)
+    \brief  Setup  video size & fps to be compatible with PSP
+*/
 uint8_t setPSP (void)
 {
 uint8_t r=0;

Modified: branches/avidemux_2.4_branch/avidemux/gui_action.hxx
===================================================================
--- branches/avidemux_2.4_branch/avidemux/gui_action.hxx	2007-01-01 18:14:55 UTC (rev 2671)
+++ branches/avidemux_2.4_branch/avidemux/gui_action.hxx	2007-01-01 18:15:50 UTC (rev 2672)
@@ -174,6 +174,7 @@
 ACT_AUTO_SVCD,
 ACT_AUTO_DVD,
 ACT_AUTO_PSP,
+ACT_AUTO_PSP_H264,
 
 ACT_ADD_JOB,
 ACT_HANDLE_JOB,

Modified: branches/avidemux_2.4_branch/avidemux/gui_autodrive.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/gui_autodrive.cpp	2007-01-01 18:14:55 UTC (rev 2671)
+++ branches/avidemux_2.4_branch/avidemux/gui_autodrive.cpp	2007-01-01 18:15:50 UTC (rev 2672)
@@ -57,20 +57,40 @@
         switch(action)
         {
                 case ACT_AUTO_PSP:
-                                // Resize
-                                if(!setPSP()) return 0;
-                                // Video codec
+                case ACT_AUTO_PSP_H264:
+                    // Resize
+                    if(!setPSP()) return 0;
+                    // Video codec
+                    switch(action)
+                    {
+                    case ACT_AUTO_PSP:
+                          {
 #ifdef USE_XVID_4
-                    if(!videoCodecSelectByName("XVID4")) 
+                            if(!videoCodecSelectByName("XVID4")) 
 #else
-                    if(!videoCodecSelectByName("FFMpeg4"))            
+                            if(!videoCodecSelectByName("FFMpeg4"))            
 #endif
+                            {
+                              GUI_Error_HIG(_("Codec Error"),_( "Cannot select mpeg4 sp codec."));
+                                return 0;
+                            }
+                            // Set mode & bitrate 
+                            setVideoEncoderSettings(COMPRESS_CBR,768,0,NULL);
+                          }
+                          break;
+                    case ACT_AUTO_PSP_H264:
                     {
-                      GUI_Error_HIG(_("Codec Error"),_( "Cannot select mpeg4 sp codec."));
-                        return 0;
+#ifdef USE_X264
+                          videoCodecSelectByName("X264"); 
+                          setPSP_X264Preset(); 
+                          setVideoEncoderSettings(COMPRESS_CBR,768,0,NULL);
+#endif
                     }
-                    // Set mode & bitrate 
-                    setVideoEncoderSettings(COMPRESS_CBR,768,0,NULL);
+                    break;
+                    
+                    default:
+                          ADM_assert(0);
+                    }
                     // Audio Codec
                     if((currentaudiostream->getInfo()->frequency==PSP_AUDIO_FQ)&&
                         (currentaudiostream->getInfo()->channels==2)&&
@@ -83,14 +103,15 @@
 #ifdef USE_FAAC
                           audioCodecSetcodec(AUDIOENC_FAAC);
 #else
-                          GUI_Error_HIG(_("Codec Error"),_( "You don't have FAAC!.\nIt is needed to create PSP compatible video."));
+                          GUI_Error_HIG(_("Codec Error"),
+                                        _( "You don't have FAAC!.\nIt is needed to create PSP compatible video."));
 #endif
                                     // ? Needed ?
                           if(currentaudiostream->getInfo()->frequency!=PSP_AUDIO_FQ)
                           {
                               audioFilterResample(PSP_AUDIO_FQ);
                           }
-                          audioFilter_SetBitrate(112);
+                          audioFilter_SetBitrate(128);
                       }
                                 break;
                 case ACT_AUTO_VCD:
@@ -188,11 +209,15 @@
         }
         // Set output format to mpeg PS
         // Except for PSP
-        if(action==ACT_AUTO_PSP)
-          UI_SetCurrentFormat(ADM_PSP);
-        else
-          UI_SetCurrentFormat(ADM_PS);
-        
+        switch(action)
+        {
+          case ACT_AUTO_PSP:
+          case ACT_AUTO_PSP_H264:
+              UI_SetCurrentFormat(ADM_PSP);
+              break;
+          default:
+              UI_SetCurrentFormat(ADM_PS);
+        }
         return 1;
 }
 //EOF



From mean at mail.berlios.de  Mon Jan  1 19:17:38 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Mon, 1 Jan 2007 19:17:38 +0100
Subject: [Avidemux-svn-commit] r2673 - branches/avidemux_2.4_branch/avidemux
Message-ID: <200701011817.l01IHcBi024589@sheep.berlios.de>

Author: mean
Date: 2007-01-01 19:17:37 +0100 (Mon, 01 Jan 2007)
New Revision: 2673

Modified:
   branches/avidemux_2.4_branch/avidemux/gtk_gui.cpp
Log:
prepare for PSP/H264 profile (not working)

Modified: branches/avidemux_2.4_branch/avidemux/gtk_gui.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/gtk_gui.cpp	2007-01-01 18:15:50 UTC (rev 2672)
+++ branches/avidemux_2.4_branch/avidemux/gtk_gui.cpp	2007-01-01 18:17:37 UTC (rev 2673)
@@ -479,6 +479,7 @@
         case ACT_AUTO_SVCD:
         case ACT_AUTO_DVD:
         case ACT_AUTO_PSP:
+        case ACT_AUTO_PSP_H264:
                 A_autoDrive( action);
                 break;
      case ACT_TimeShift:



From mean at mail.berlios.de  Mon Jan  1 19:18:09 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Mon, 1 Jan 2007 19:18:09 +0100
Subject: [Avidemux-svn-commit] r2674 -
	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_utilities
Message-ID: <200701011818.l01II9e4024708@sheep.berlios.de>

Author: mean
Date: 2007-01-01 19:18:09 +0100 (Mon, 01 Jan 2007)
New Revision: 2674

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_utilities/ADM_compressedImage.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_utilities/ADM_image.h
Log:
new api

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_utilities/ADM_compressedImage.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_utilities/ADM_compressedImage.h	2007-01-01 18:17:37 UTC (rev 2673)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_utilities/ADM_compressedImage.h	2007-01-01 18:18:09 UTC (rev 2674)
@@ -9,6 +9,7 @@
 #ifndef ADM_COMPRESSED_IMAGE_H
 #define ADM_COMPRESSED_IMAGE_H
 
+#define ADM_COMPRESSED_NO_PTS 0xffffffff
 class ADMCompressedImage
 {
   
@@ -20,11 +21,17 @@
         /* Associated flags, in most cases filled by decoder */
         uint32_t flags;
         /* Some interesting informations */
-        uint32_t demuxerFrameNo;
+        uint32_t demuxerFrameNo; /* In bitstream order i.e. decoding order */
         uint32_t demuxerPts;  /* In ms !*/
         uint32_t demuxerDts;  /* In ms */
         /*         */
-        
+        void cleanup(uint32_t demuxerNo) 
+            {
+              flags=0;
+              demuxerFrameNo=demuxerNo;
+              demuxerPts=ADM_COMPRESSED_NO_PTS;  
+              demuxerDts=ADM_COMPRESSED_NO_PTS;
+            }
   
 };
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_utilities/ADM_image.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_utilities/ADM_image.h	2007-01-01 18:17:37 UTC (rev 2673)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_utilities/ADM_image.h	2007-01-01 18:18:09 UTC (rev 2674)
@@ -48,7 +48,9 @@
 class ADMImage
 {
 public:
-        
+        uint32_t        demuxerFrameno;
+  
+        //*****************
         uint8_t		*data;		/// Pointer to actual image data
         uint32_t	_width;		/// Width of image
         uint32_t	_height;	/// Height of image



From mean at mail.berlios.de  Mon Jan  1 19:18:33 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Mon, 1 Jan 2007 19:18:33 +0100
Subject: [Avidemux-svn-commit] r2675 -
	branches/avidemux_2.4_branch/avidemux/ADM_editor
Message-ID: <200701011818.l01IIXS3024778@sheep.berlios.de>

Author: mean
Date: 2007-01-01 19:18:33 +0100 (Mon, 01 Jan 2007)
New Revision: 2675

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_editor/ADM_edRender.cpp
Log:
new api

Modified: branches/avidemux_2.4_branch/avidemux/ADM_editor/ADM_edRender.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_editor/ADM_edRender.cpp	2007-01-01 18:18:09 UTC (rev 2674)
+++ branches/avidemux_2.4_branch/avidemux/ADM_editor/ADM_edRender.cpp	2007-01-01 18:18:33 UTC (rev 2675)
@@ -372,6 +372,7 @@
 ADMCompressedImage img;
         
         img.data=compBuffer;
+        img.cleanup(frame);
 	 if (!_videos[seg]._aviheader->getFrameNoAlloc (frame,&img))
 	{
 	  printf ("\nEditor: last decoding failed.%ld)\n",   frame );



From mean at mail.berlios.de  Mon Jan  1 19:35:55 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Mon, 1 Jan 2007 19:35:55 +0100
Subject: [Avidemux-svn-commit] r2676 -
	branches/avidemux_2.4_branch/avidemux/ADM_audiofilter
Message-ID: <200701011835.l01IZt4A027176@sheep.berlios.de>

Author: mean
Date: 2007-01-01 19:35:54 +0100 (Mon, 01 Jan 2007)
New Revision: 2676

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_audiofilter/audioencoder_pcm.cpp
Log:
fix overflow when saving as PCM/LPCM

Modified: branches/avidemux_2.4_branch/avidemux/ADM_audiofilter/audioencoder_pcm.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_audiofilter/audioencoder_pcm.cpp	2007-01-01 18:18:33 UTC (rev 2675)
+++ branches/avidemux_2.4_branch/avidemux/ADM_audiofilter/audioencoder_pcm.cpp	2007-01-01 18:35:54 UTC (rev 2676)
@@ -65,7 +65,7 @@
 {
   
   _wavheader->byterate=_wavheader->channels*_wavheader->frequency*2;
-  _chunk = (_wavheader->frequency/10)*_wavheader->channels*2;
+  _chunk = (_wavheader->frequency/100)*_wavheader->channels*2;
   
 
  



From mean at mail.berlios.de  Mon Jan  1 19:38:39 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Mon, 1 Jan 2007 19:38:39 +0100
Subject: [Avidemux-svn-commit] r2677 -
	branches/avidemux_2.3_branch/avidemux/ADM_audiofilter
Message-ID: <200701011838.l01IcdJA027657@sheep.berlios.de>

Author: mean
Date: 2007-01-01 19:38:37 +0100 (Mon, 01 Jan 2007)
New Revision: 2677

Modified:
   branches/avidemux_2.3_branch/avidemux/ADM_audiofilter/audioencoder_pcm.cpp
Log:
fix overflow when saving as PCM/LPCM (2.3)

Modified: branches/avidemux_2.3_branch/avidemux/ADM_audiofilter/audioencoder_pcm.cpp
===================================================================
--- branches/avidemux_2.3_branch/avidemux/ADM_audiofilter/audioencoder_pcm.cpp	2007-01-01 18:35:54 UTC (rev 2676)
+++ branches/avidemux_2.3_branch/avidemux/ADM_audiofilter/audioencoder_pcm.cpp	2007-01-01 18:38:37 UTC (rev 2677)
@@ -65,7 +65,7 @@
 {
   
   _wavheader->byterate=_wavheader->channels*_wavheader->frequency*2;
-  _chunk = (_wavheader->frequency/10)*_wavheader->channels*2;
+  _chunk = (_wavheader->frequency/100)*_wavheader->channels*2;
   
 
  



From mean at mail.berlios.de  Wed Jan  3 20:47:39 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 3 Jan 2007 20:47:39 +0100
Subject: [Avidemux-svn-commit] r2678 - in
	branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4:
	ADM_filters ADM_gui
Message-ID: <200701031947.l03Jld4e007482@sheep.berlios.de>

Author: mean
Date: 2007-01-03 20:47:39 +0100 (Wed, 03 Jan 2007)
New Revision: 2678

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/Q_mainfilter.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/mainfilter.ui
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/Q_gui2.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/gui2.ui
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/translation_table.h
Log:
some small improvements on QT4 UI

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/Q_mainfilter.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/Q_mainfilter.cpp	2007-01-01 18:38:37 UTC (rev 2677)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/Q_mainfilter.cpp	2007-01-03 19:47:39 UTC (rev 2678)
@@ -39,7 +39,8 @@
 extern uint32_t nb_video_filter;
 extern FILTER videofilters[MAX_FILTER];
 extern uint32_t nb_active_filter;
-//extern ADM_Composer *video_body;
+extern const char  *filterGetNameFromTag(VF_FILTERS tag);
+extern ADM_Composer *video_body;
 
 /*******************************************************/
 class filtermainWindow : public QDialog
@@ -50,13 +51,16 @@
      filtermainWindow();
  //    virtual ~filtermainWindow();
      void             buildAvailableFilterList(void);
+     void             buildActiveFilterList(void);
      Ui_mainFilterDialog ui;
      
      QStringList      allList[NB_TREE];
      QStringListModel allModel[NB_TREE];
-     QListView        *listView[NB_TREE];
      
+     QStringList      activeList;
+     QStringListModel activeModel;
      
+     
  public slots:
  private slots:
  private:
@@ -68,17 +72,18 @@
 void filtermainWindow::buildAvailableFilterList(void)
 {
   int current_tree=-1;
-  char str[1024];
   
+  
   max=0;
   for (uint32_t i = 0; i < nb_video_filter; i++)
     {
       if (allfilters[i].viewable==1)
         {
-          snprintf(str,1023,"<big><b>%s</b></big>\n%s", 
-                allfilters[i].name, allfilters[i].description);
-  
-          allList[current_tree]=allList[current_tree] << str;
+          QString str; //="<b>";
+          str+=allfilters[i].name;
+          str+=":";//"</b><br>";
+          str+=allfilters[i].description;
+          allList[current_tree]+=str;
           max++;
         }else 
         {
@@ -94,23 +99,35 @@
     {
       allModel[i].setStringList(allList[i]);
     }
-   
 }
-  
   /**
+        \fn     buildActiveFilterList(void)
+        \brief  Build and display all active filters (may be empty)
+*/
+void filtermainWindow::buildActiveFilterList(void)
+{
+  VF_FILTERS fil;
+  activeList.clear();
+  for (uint32_t i = 1; i < nb_active_filter; i++)
+    {
+                QString str;
+                fil=videofilters[i].tag;
+
+                 str =filterGetNameFromTag(fil);
+                 str+= videofilters[i].filter->printConf ();
+                 activeList+=str;
+    }
+    activeModel.setStringList(activeList);
+
+}
+  /**
   */
 filtermainWindow::filtermainWindow()     : QDialog()
  {
       buildAvailableFilterList();
+      buildActiveFilterList();
       ui.setupUi(this);
       
-    listView[0]=ui.listViewTransform;
-    listView[1]=ui.listViewInterlacing;
-    listView[2]=ui.listViewColors;
-    listView[3]=ui.listViewNoise;
-    listView[4]=ui.listViewSharpness;
-    listView[5]=ui.listViewSubtitles;
-    listView[6]=ui.listViewMisc;
     
     ui.listViewTransform->setModel(&(allModel[0]));
     ui.listViewInterlacing->setModel(&(allModel[1]));
@@ -120,6 +137,7 @@
     ui.listViewSubtitles->setModel(&(allModel[5]));;
     ui.listViewMisc->setModel(&(allModel[6]));;
       
+    ui.listViewActive->setModel(&activeModel);
 
 
  }

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/mainfilter.ui
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/mainfilter.ui	2007-01-01 18:38:37 UTC (rev 2677)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/mainfilter.ui	2007-01-03 19:47:39 UTC (rev 2678)
@@ -33,9 +33,6 @@
      </property>
     </widget>
    </item>
-   <item row="1" column="1" >
-    <widget class="QListWidget" name="listWidgetCurrent" />
-   </item>
    <item row="2" column="0" >
     <layout class="QHBoxLayout" >
      <property name="margin" >
@@ -282,6 +279,9 @@
      </widget>
     </widget>
    </item>
+   <item row="1" column="1" >
+    <widget class="QListView" name="listViewActive" />
+   </item>
   </layout>
  </widget>
  <resources/>

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/Q_gui2.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/Q_gui2.cpp	2007-01-01 18:38:37 UTC (rev 2677)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/Q_gui2.cpp	2007-01-03 19:47:39 UTC (rev 2678)
@@ -100,12 +100,32 @@
      {
         const char *source=qPrintable(sender()->objectName());
 
-        printf("From : %s\n",source);
-        if(!strcmp(source,"comboBoxVideo"))  HandleAction (ACT_VideoCodecChanged) ;
-        else if(!strcmp(source,"comboBoxAudio"))  HandleAction (ACT_AudioCodecChanged) ;
+        if(!strcmp(source,"comboBoxVideo"))  
+        {
+          bool b=FALSE;;
+          if(ui.comboBoxVideo->currentIndex())
+          {
+             b=TRUE;
+          }
+          ui.pushButtonVideoConf->setEnabled(b);
+          ui.pushButtonVideoFilter->setEnabled(b);
+          HandleAction (ACT_VideoCodecChanged) ;
+        }
+        else 
+          if(!strcmp(source,"comboBoxAudio"))  
+        {
+          bool b=FALSE;
+          if(ui.comboBoxAudio->currentIndex())
+          {
+             b=TRUE;
+          }
+          ui.pushButtonAudioConf->setEnabled(b);
+          ui.pushButtonAudioFilter->setEnabled(b);
+          HandleAction (ACT_AudioCodecChanged) ;
+        }
         
 
-        printf("From : %s\n",source);
+        printf("From +: %s\n",source);
      }
       void sliderMoved(int u) 
         {
@@ -165,6 +185,13 @@
             ADD(actionNext_blak_frame);
             ADD(actionFirst_Frame);
             ADD(actionLast_Frame);
+            
+            // default state
+            bool b=0;
+          ui.pushButtonVideoConf->setEnabled(b);
+          ui.pushButtonVideoFilter->setEnabled(b);
+          ui.pushButtonAudioConf->setEnabled(b);
+          ui.pushButtonAudioFilter->setEnabled(b);
  }
  /*
       We receive a button press event
@@ -174,7 +201,7 @@
     // Receveid a key press Event, look into table..
    const char *source=qPrintable(sender()->objectName());
 
-    printf("From : %s\n",source);
+    printf("Button From : %s\n",source);
     Action action=searchTranslationTable(source);
     if(action!=ACT_DUMMY)
     {
@@ -226,7 +253,10 @@
     setupMenus();
     return a.exec();
 }
-
+/**
+    \fn searchTranslationTable(const char *name))
+    \brief return the action corresponding to a give button. The translation table is in translation_table.h
+*/
 Action searchTranslationTable(const char *name)
 {
   for(int i=0;i< SIZEOF_MY_TRANSLATION;i++)
@@ -235,7 +265,6 @@
     {
       return  myTranslationTable[i].action;
     }
-    
   }
   printf("WARNING : Signal not found in translation table : %s\n",name);
   return ACT_DUMMY;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/gui2.ui
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/gui2.ui	2007-01-01 18:38:37 UTC (rev 2677)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/gui2.ui	2007-01-03 19:47:39 UTC (rev 2678)
@@ -210,7 +210,7 @@
            <number>6</number>
           </property>
           <item>
-           <widget class="QPushButton" name="pushButton" >
+           <widget class="QPushButton" name="setMarkerA" >
             <property name="sizePolicy" >
              <sizepolicy>
               <hsizetype>1</hsizetype>
@@ -246,7 +246,7 @@
            </widget>
           </item>
           <item>
-           <widget class="QPushButton" name="pushButton_2" >
+           <widget class="QPushButton" name="setMarkerB" >
             <property name="sizePolicy" >
              <sizepolicy>
               <hsizetype>4</hsizetype>
@@ -405,9 +405,9 @@
            </widget>
           </item>
           <item>
-           <widget class="QPushButton" name="pushButton_5" >
+           <widget class="QPushButton" name="pushButtonVideoConf" >
             <property name="enabled" >
-             <bool>false</bool>
+             <bool>true</bool>
             </property>
             <property name="sizePolicy" >
              <sizepolicy>
@@ -420,12 +420,15 @@
             <property name="text" >
              <string>Configure</string>
             </property>
+            <property name="checkable" >
+             <bool>false</bool>
+            </property>
            </widget>
           </item>
           <item>
-           <widget class="QPushButton" name="pushButton_6" >
+           <widget class="QPushButton" name="pushButtonVideoFilter" >
             <property name="enabled" >
-             <bool>false</bool>
+             <bool>true</bool>
             </property>
             <property name="sizePolicy" >
              <sizepolicy>
@@ -534,9 +537,9 @@
            </widget>
           </item>
           <item>
-           <widget class="QPushButton" name="pushButton_7" >
+           <widget class="QPushButton" name="pushButtonAudioConf" >
             <property name="enabled" >
-             <bool>false</bool>
+             <bool>true</bool>
             </property>
             <property name="sizePolicy" >
              <sizepolicy>
@@ -552,9 +555,9 @@
            </widget>
           </item>
           <item>
-           <widget class="QPushButton" name="pushButton_8" >
+           <widget class="QPushButton" name="pushButtonAudioFilter" >
             <property name="enabled" >
-             <bool>false</bool>
+             <bool>true</bool>
             </property>
             <property name="sizePolicy" >
              <sizepolicy>

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/translation_table.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/translation_table.h	2007-01-01 18:38:37 UTC (rev 2677)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/translation_table.h	2007-01-03 19:47:39 UTC (rev 2678)
@@ -66,18 +66,10 @@
 
 
 #define LIST_OF_BUTTONS     \
+PROCESS(setMarkerA , ACT_MarkA  ) \
+PROCESS(setMarkerB ,ACT_MarkB )  \
+PROCESS(pushButtonVideoConf ,ACT_VideoConfigure )  \
+PROCESS(pushButtonVideoFilter , ACT_VideoParameter  ) \
+PROCESS(pushButtonAudioConf ,ACT_AudioConfigure ) \
+PROCESS(pushButtonAudioFilter ,ACT_AudioFilters )  
 
-#if 0
-PROCESS(toolButtonPlay , ACT_PlayAvi  ) \
-PROCESS(toolButtonBPrev ,ACT_PrevBlackFrame ) \
-PROCESS(toolButtonA ,    ACT_MarkA) \
-PROCESS(toolButtonKNext ,ACT_NextKFrame ) \
-PROCESS(toolButtonEnd ,  ACT_End ) \
-PROCESS(toolButtonPrev,  ACT_PreviousFrame ) \
-PROCESS(toolButtonNext , ACT_NextFrame ) \
-PROCESS(toolButtonBegin ,ACT_Begin ) \
-PROCESS(toolButtoBNext,  ACT_NextBlackFrame ) \
-PROCESS(toolButtonB ,    ACT_MarkB) \
-PROCESS(toolButtonKPrev ,ACT_PreviousKFrame ) \
-PROCESS(toolButtonStop , ACT_StopAvi) 
-#endif



From mean at mail.berlios.de  Fri Jan  5 19:52:28 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 5 Jan 2007 19:52:28 +0100
Subject: [Avidemux-svn-commit] r2679 - in branches/avidemux_2.4_branch:
	admin avidemux avidemux/ADM_filter
	avidemux/ADM_libraries/ADM_utilities avidemux/ADM_osSupport
	avidemux/ADM_toolkit avidemux/ADM_userInterfaces/ADM_GTK/ADM_filters
Message-ID: <200701051852.l05IqS4G017065@sheep.berlios.de>

Author: mean
Date: 2007-01-05 19:52:27 +0100 (Fri, 05 Jan 2007)
New Revision: 2679

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_filter/filter_dylib.cpp
Modified:
   branches/avidemux_2.4_branch/admin/prefs_gen.pl
   branches/avidemux_2.4_branch/avidemux/ADM_filter/Makefile.am
   branches/avidemux_2.4_branch/avidemux/ADM_filter/filter.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_filter/video_filters.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_utilities/prefs.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_osSupport/ADM_fileio.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_toolkit/filesel.h
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_filters/gui_filtermanager.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_filters/gui_filtermanager_dialog.cpp
   branches/avidemux_2.4_branch/avidemux/GUI_jobs.cpp
   branches/avidemux_2.4_branch/avidemux/Makefile.am
   branches/avidemux_2.4_branch/avidemux/gtk_gui.cpp
   branches/avidemux_2.4_branch/avidemux/main.cpp
   branches/avidemux_2.4_branch/avidemux/prefs.in
Log:
support for external filters as .so/.dll

Modified: branches/avidemux_2.4_branch/admin/prefs_gen.pl
===================================================================
--- branches/avidemux_2.4_branch/admin/prefs_gen.pl	2007-01-03 19:47:39 UTC (rev 2678)
+++ branches/avidemux_2.4_branch/admin/prefs_gen.pl	2007-01-05 18:52:27 UTC (rev 2679)
@@ -12,7 +12,7 @@
 
 my $in  = "$srcdir/prefs.in";
 my $h   = "$srcdir/prefs.h";
-my $cpp = "$srcdir/prefs.cpp";
+my $cpp = "$srcdir/ADM_libraries/ADM_utilities/prefs.cpp";
 #print "In:$in\n";
 my $h_str = "typedef enum {\n";
 my $cpp_str = "typedef enum {\n".
@@ -115,7 +115,7 @@
 
 @data = ();
 $flag = 0;
-open($fd,"< $cpp") or die;
+open($fd,"< $cpp") or die($cpp);
 while(<$fd>){
         if( /^\/\/ <\/prefs_gen>/ ){
                 $flag = 2;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_filter/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_filter/Makefile.am	2007-01-03 19:47:39 UTC (rev 2678)
+++ branches/avidemux_2.4_branch/avidemux/ADM_filter/Makefile.am	2007-01-05 18:52:27 UTC (rev 2679)
@@ -5,7 +5,7 @@
 
 libADM_filter_a_METASOURCES = AUTO
 
-libADM_filter_a_SOURCES = vidVCD.cpp  filter_declaration.cpp filter.cpp  filter_saveload.cpp 
+libADM_filter_a_SOURCES = vidVCD.cpp  filter_declaration.cpp filter.cpp  filter_saveload.cpp  filter_dylib.cpp
 
 
 EXTRA_DIST = filter.cpp             \

Modified: branches/avidemux_2.4_branch/avidemux/ADM_filter/filter.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_filter/filter.cpp	2007-01-03 19:47:39 UTC (rev 2678)
+++ branches/avidemux_2.4_branch/avidemux/ADM_filter/filter.cpp	2007-01-05 18:52:27 UTC (rev 2679)
@@ -273,14 +273,29 @@
 	 AVDMGenericVideoStream *filter;
 
 			ADM_assert(tag!=VF_INVALID);
-			for(unsigned int i=0;i<nb_video_filter;i++)
-				{
-					if(tag==allfilters[i].tag)
-						{
-	 						filter=allfilters[i].create( in, couple);
-							return filter;
-						}
-				}
+                        if(tag>=VF_EXTERNAL_START)
+                        {
+                          // start from the end, it is an external filter 
+                          for(uint32_t i=nb_video_filter-1;i>=0;i--)
+                          {
+                              if(tag==allfilters[i].tag)
+                                {
+                                        filter=allfilters[i].create( in, couple);
+                                        return filter;
+                                }
+                          }
+                        } // else search forward
+                        else
+                        {
+                          for(unsigned int i=0;i<nb_video_filter;i++)
+                                  {
+                                          if(tag==allfilters[i].tag)
+                                                  {
+                                                          filter=allfilters[i].create( in, couple);
+                                                          return filter;
+                                                  }
+                                  }
+                        }
 			ADM_assert(0);
 			return NULL;                      
 }

Added: branches/avidemux_2.4_branch/avidemux/ADM_filter/filter_dylib.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_filter/filter_dylib.cpp	2007-01-03 19:47:39 UTC (rev 2678)
+++ branches/avidemux_2.4_branch/avidemux/ADM_filter/filter_dylib.cpp	2007-01-05 18:52:27 UTC (rev 2679)
@@ -0,0 +1,146 @@
+/***************************************************************************
+                         
+  Load external filter through dynamic loading (.so /.dll)
+    copyright            : (C) 2006 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "config.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <dlfcn.h>
+
+#include <ADM_assert.h>
+
+#include "fourcc.h"
+#include "avio.hxx"
+
+#include "ADM_toolkit/toolkit.hxx"
+#include "ADM_toolkit/filesel.h"
+#include "ADM_editor/ADM_edit.hxx"
+#include "ADM_video/ADM_genvideo.hxx"
+#include "ADM_filter/video_filters.h"
+#include "ADM_video/ADM_vidPartial.h"
+#include "avi_vars.h"
+
+#include "ADM_osSupport/ADM_debugID.h"
+#define MODULE_NAME MODULE_PREVIEW
+#include "ADM_osSupport/ADM_debug.h"
+#include "ADM_osSupport/ADM_quota.h"
+
+typedef char *(ADM_getStringT)(void);
+
+static void tryLoading(void *handle);
+static void *loadSym(void *handle,const char *sym);
+static uint32_t dynTag=0xF0000000;
+/**
+    \fn  loadSym(void *handle,const char *sym)
+    \brief Get a pointer to the function name given as parameter
+
+*/
+void *loadSym(void *handle,const char *sym)
+{
+  void *f;
+   
+  f=dlsym(handle,sym);
+  if(!f) 
+  {
+    printf("\t Symbold %s not found\n",sym); 
+  }
+  return f;
+  
+}
+
+/**
+    \fn  tryLoadin(void *handle)
+    \brief try do use the dynlib pointer by handle
+
+*/
+void tryLoading(void *handle)
+{
+  ADM_assert(handle);
+  
+  void *f;
+  int success=1;
+  ADM_createT *createP;
+  ADM_create_from_scriptT *createFromScriptP;
+  ADM_getStringT *nameP;
+  ADM_getStringT *descP;
+  
+#define LOADSYM(x,y,z) if(!(f=loadSym(handle,x))) { success=0;printf("%s",dlerror());}   else {y=(z *)f;}
+  
+  
+    LOADSYM("FILTER_create",createP,ADM_createT);
+    LOADSYM("FILTER_create_fromscript",createFromScriptP,ADM_create_from_scriptT);
+    LOADSYM("FILTER_getName",nameP,ADM_getStringT);
+    LOADSYM("FILTER_getDesc",descP,ADM_getStringT);
+    
+    if(!success)
+    {
+      dlclose(handle);
+      return;
+    }
+    
+    char *name,*desc;
+    
+    name=nameP();
+    desc=descP();
+    
+    ADM_assert(name);
+    ADM_assert(desc);
+    
+    printf("Loaded filter %s\n",name);
+  
+   registerFilterEx(name,(VF_FILTERS)dynTag,1,createP,name,createFromScriptP,desc);
+
+}
+
+/**
+    \fn filterDynLoad(char *path)
+    \brief load dynamically filters by scanning the path directory
+
+*/
+#define MAX_EXTERNAL_FILTER 50
+uint8_t filterDynLoad(const char *path)
+{
+  char *files[MAX_EXTERNAL_FILTER];
+  uint32_t nbFile;
+  printf("** Registering dynamic filters (%s) **\n",path);
+  memset(files,0,sizeof(char *)*MAX_EXTERNAL_FILTER);
+  if(!buildDirectoryContent(&nbFile,path, files,MAX_EXTERNAL_FILTER,".so"))
+  {
+      GUI_Error_HIG("External Filter","Loading external filters failed.");
+      return 0;
+  }
+  printf("Found %u candidated\n",nbFile);
+  // Try to dyload them
+  for(int i=0;i<nbFile;i++)
+  {
+    void *h=dlopen(files[i],RTLD_NOW);
+    if(!h)
+    {
+        printf("Dlopened failed for %s er:%s\n",files[i],dlerror());
+        continue;
+    }
+    tryLoading(h);
+    
+  }
+  // Cleanup
+  for(int i=0;i<nbFile;i++)
+  {
+    ADM_dealloc(files[i]); 
+  }
+  printf("** Done registering dynamic filters**\n");
+  return 1;
+  
+}

Modified: branches/avidemux_2.4_branch/avidemux/ADM_filter/video_filters.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_filter/video_filters.h	2007-01-03 19:47:39 UTC (rev 2678)
+++ branches/avidemux_2.4_branch/avidemux/ADM_filter/video_filters.h	2007-01-05 18:52:27 UTC (rev 2679)
@@ -19,12 +19,12 @@
 
  #define MAX_FILTER 80
 #include "ADM_script/adm_scanner.h"
- 	typedef enum
- 	{
-		VF_INVALID=0,
- 	      	VF_RESIZE=1,
- 	      	VF_CROP,
-	      	VF_TELECIDE,
+typedef enum
+{
+                VF_INVALID=0,
+                VF_RESIZE=1,
+                VF_CROP,
+                VF_TELECIDE,
                 VF_BLACKEN,
                 VF_SHARPEN,
                 VF_MEAN,
@@ -46,33 +46,33 @@
                 VF_LARGEMEDIAN,
                 VF_FLUXSMOOTH,
                 VF_SALT,
-		VF_PARTIAL          ,
-		VF_VLADSMOOTH,
-		VF_ROTATE,
-		VF_DROPOUT,
-		VF_SWAPFIELDS,
-		VF_KEEPODD,
-		VF_KEEPEVEN,
-		VF_SEPARATEFIELDS,
-		VF_MERGEFIELDS,
-		VF_CHROMASHIFT,
-		VF_SMARTSWAPFIELDS,
-		VF_MPLAYERRESIZE,
-		VF_IVTC,
-		VF_PULLDOWN,
-		VF_MPLHQD3D,
-		VF_MPLLQD3D,
-		VF_LAVDEINT,
-		VF_MPDETC,
-		VF_KRNDEINT,
-		VF_FORCEDPP,
-		VF_SOFTEN,
-		VF_DECOMB,
-		VF_DECIMATE,
-		VF_MSMOOTH,
-		VF_STACKFIELD,
-		VF_WHIRL,
-		VF_EQUALIZER,
+                VF_PARTIAL          ,
+                VF_VLADSMOOTH,
+                VF_ROTATE,
+                VF_DROPOUT,
+                VF_SWAPFIELDS,
+                VF_KEEPODD,
+                VF_KEEPEVEN,
+                VF_SEPARATEFIELDS,
+                VF_MERGEFIELDS,
+                VF_CHROMASHIFT,
+                VF_SMARTSWAPFIELDS,
+                VF_MPLAYERRESIZE,
+                VF_IVTC,
+                VF_PULLDOWN,
+                VF_MPLHQD3D,
+                VF_MPLLQD3D,
+                VF_LAVDEINT,
+                VF_MPDETC,
+                VF_KRNDEINT,
+                VF_FORCEDPP,
+                VF_SOFTEN,
+                VF_DECOMB,
+                VF_DECIMATE,
+                VF_MSMOOTH,
+                VF_STACKFIELD,
+                VF_WHIRL,
+                VF_EQUALIZER,
                 VF_VOBSUB,
                 VF_CHFPS,
                 VF_RESAMPLE_FPS,
@@ -83,8 +83,8 @@
                 VF_DGBOB,
                 VF_MSHARPEN,
                 VF_ASHARP,
-		VF_CNR2,
-		VF_DELTA,
+                VF_CNR2,
+                VF_DELTA,
                 VF_UNBLEND,
                 VF_HARDIVTC,
                 VF_MOSAIC,
@@ -96,40 +96,45 @@
                 VF_MCDEINT,
                 VF_REVERSE,
                 VF_FADE,
-		VF_ASS,
-		VF_DUMMY
- 	 }VF_FILTERS;
- 	
+                VF_ASS,
+                VF_DUMMY,
+                VF_EXTERNAL_START=0xF0000000
+          }VF_FILTERS;
+
+typedef AVDMGenericVideoStream *(ADM_createT) (AVDMGenericVideoStream *in, CONFcouple *);
+typedef AVDMGenericVideoStream *(ADM_create_from_scriptT) (AVDMGenericVideoStream *in, int n,Arg *args);
+
+         
    typedef struct
    {
-       		const char 		*name;
-		AVDMGenericVideoStream *(*create) (AVDMGenericVideoStream *in, CONFcouple *);
-		VF_FILTERS 	tag;
-		uint8_t		viewable;
-		char		*filtername;
-                char            *description;
-		AVDMGenericVideoStream *(*create_from_script) (AVDMGenericVideoStream *in, int n,Arg *args);	
+        const char        *name;
+        ADM_createT       *create;
+        void              *destroy( AVDMGenericVideoStream *old); /* Maybe needed ...*/
+        VF_FILTERS        tag;
+        uint8_t           viewable;
+        char              *filtername;
+        char              *description;
+        ADM_create_from_scriptT *create_from_script;
    }FILTER_ENTRY;
  	
  typedef struct
    {
-   		VF_FILTERS				tag;
-		AVDMGenericVideoStream 	*filter;
-		CONFcouple				*conf;
+          VF_FILTERS              tag;
+          AVDMGenericVideoStream *filter;
+          CONFcouple             *conf;
+   }FILTER;
 
-   }FILTER; 	
-   
    typedef struct
    {
-   		uint32_t nb;
-		const char 	*param[25];
+            uint32_t    nb;
+            const char  *param[25];
    }FILTER_PARAM;
    
-  AVDMGenericVideoStream *getLastVideoFilter( uint32_t frameStart, uint32_t nbFrame);
-    AVDMGenericVideoStream *getLastVideoFilter( void );
- AVDMGenericVideoStream *getFirstVideoFilter( uint32_t frameStart, uint32_t nbFrame);
-  AVDMGenericVideoStream *getFirstVideoFilter( void);
-  AVDMGenericVideoStream *getFirstCurrentVideoFilter( void);
+AVDMGenericVideoStream *getLastVideoFilter( uint32_t frameStart, uint32_t nbFrame);
+AVDMGenericVideoStream *getLastVideoFilter( void );
+AVDMGenericVideoStream *getFirstVideoFilter( uint32_t frameStart, uint32_t nbFrame);
+AVDMGenericVideoStream *getFirstVideoFilter( void);
+AVDMGenericVideoStream *getFirstCurrentVideoFilter( void);
   
   void	filterSetPostProc( void );
   
@@ -145,12 +150,17 @@
  void filterSave(char *name,uint8_t silent);
 CONFcouple *filterBuildCouple(FILTER_PARAM *param,uint32_t n,Arg *args);
 void filterSaveScriptJS(FILE *f);
+
 void registerFilter(const char *name,VF_FILTERS tag,uint8_t viewable,
-			AVDMGenericVideoStream *(*create) (AVDMGenericVideoStream *in, CONFcouple *),char *fname);
-void registerFilterEx(const char *name,VF_FILTERS tag,uint8_t viewable
-		,AVDMGenericVideoStream *(*create) (AVDMGenericVideoStream *in, CONFcouple *)
-		,char *filtername,AVDMGenericVideoStream *(*create_from_script) (AVDMGenericVideoStream *in, int n,Arg *args),
+                    ADM_createT  *create,
+                    char *fname);
+                    
+void registerFilterEx(const char *name,VF_FILTERS tag,uint8_t viewable,
+                ADM_createT  *create,
+		char *filtername,
+                ADM_create_from_scriptT *create_from_script,
                 char *description);
+                
 void 		filterListAll( void );
 VF_FILTERS 	filterGetTagFromName(char *inname);
 uint8_t 	filterAddScript(VF_FILTERS tags,uint32_t n,Arg *args);

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_utilities/prefs.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_utilities/prefs.cpp	2007-01-03 19:47:39 UTC (rev 2678)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_utilities/prefs.cpp	2007-01-05 18:52:27 UTC (rev 2679)
@@ -113,10 +113,12 @@
 	{"feature.audiobar_uses_master",		UINT,	"0",	NULL,	"0",	"1"	},
 	{"feature.multi_thread",		UINT,	"0",	NULL,	"0",	"4"	},
 	{"feature.mpeg_no_limit",		UINT,	"0",	NULL,	"0",	"1"	},
-	{"downmixing.prologic",		UINT,	"2",	NULL,	"0",	"2"	}
+	{"downmixing.prologic",		UINT,	"2",	NULL,	"0",	"2"	},
+	{"filters.autoload.path",		STRING,"/tmp/",NULL, NULL, NULL },
+	{"filters.autoload.active",		UINT,	"0",	NULL,	"0",	"1"	}
 };
 
-int num_opts = 67;
+int num_opts = 69;
 // </prefs_gen>
 
 #ifdef USE_LIBXML2

Modified: branches/avidemux_2.4_branch/avidemux/ADM_osSupport/ADM_fileio.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_osSupport/ADM_fileio.cpp	2007-01-03 19:47:39 UTC (rev 2678)
+++ branches/avidemux_2.4_branch/avidemux/ADM_osSupport/ADM_fileio.cpp	2007-01-05 18:52:27 UTC (rev 2679)
@@ -200,12 +200,15 @@
               closedir(dir); 
               return 1;
 }
-uint8_t buildDirectoryContent(uint32_t *outnb,const char *base, char *jobName[],int maxElems)
+uint8_t buildDirectoryContent(uint32_t *outnb,const char *base, char *jobName[],int maxElems,const char *ext)
 {
 
 DIR *dir;
 struct dirent *direntry;
 int dirmax=0,len;
+int extlen=strlen(ext);
+    ADM_assert(extlen);
+    
          dir=opendir(base);
         if(!dir)
         {
@@ -214,8 +217,10 @@
         while((direntry=readdir(dir)))
         {
                 len=strlen(direntry->d_name);
-                if(len<4) continue;
-                if(direntry->d_name[len-1]!='s' || direntry->d_name[len-2]!='j' || direntry->d_name[len-3]!='.')
+                if(len<(extlen+1)) continue;
+                int xbase=len-extlen;
+                if(memcmp(direntry->d_name+xbase,ext,extlen))
+                //if(direntry->d_name[len-1]!='s' || direntry->d_name[len-2]!='j' || direntry->d_name[len-3]!='.')
                 {
                         printf("ignored:%s\n",direntry->d_name);
                         continue;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_toolkit/filesel.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_toolkit/filesel.h	2007-01-03 19:47:39 UTC (rev 2678)
+++ branches/avidemux_2.4_branch/avidemux/ADM_toolkit/filesel.h	2007-01-05 18:52:27 UTC (rev 2679)
@@ -27,7 +27,7 @@
 char *ADM_getJobDir(void);
 char *ADM_getCustomDir(void);
 
-uint8_t buildDirectoryContent(uint32_t *outnb,const char *base, char *jobName[],int maxElems);
+uint8_t buildDirectoryContent(uint32_t *outnb,const char *base, char *jobName[],int maxElems,const char *ext);
 const char *GetFileName(const char *str);
 uint8_t ADM_mkdir(const char *name);
 #endif

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_filters/gui_filtermanager.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_filters/gui_filtermanager.cpp	2007-01-03 19:47:39 UTC (rev 2678)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_filters/gui_filtermanager.cpp	2007-01-05 18:52:27 UTC (rev 2679)
@@ -69,7 +69,7 @@
 static VF_FILTERS getFilterFromSelection (void);
 static void wrapToolButton(GtkWidget * wid, gpointer user_data);
 //___________________________________________
-#define NB_TREE 8
+#define NB_TREE 9
 static  uint32_t max = 0;
 static  GtkWidget *trees[NB_TREE];
 static  GtkListStore *stores[NB_TREE];
@@ -436,6 +436,7 @@
     LOOK(5);
     LOOK(6);
     LOOK(7);
+    LOOK(8);
 
     //load stores with filter names, get start filter for each page
     char *str=NULL;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_filters/gui_filtermanager_dialog.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_filters/gui_filtermanager_dialog.cpp	2007-01-03 19:47:39 UTC (rev 2678)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_filters/gui_filtermanager_dialog.cpp	2007-01-05 18:52:27 UTC (rev 2679)
@@ -23,7 +23,6 @@
 #define GLADE_HOOKUP_OBJECT_NO_REF(component,widget,name) \
   g_object_set_data (G_OBJECT (component), name, widget)
 
-
 GtkWidget*
 create_dialog1 (void)
 {
@@ -80,6 +79,8 @@
   GtkWidget *hbox4;
   GtkWidget *image7;
   GtkWidget *label22;
+  GtkWidget *treeview8;
+  GtkWidget *label28;
   GtkWidget *hbox13;
   GtkWidget *buttonAdd;
   GtkWidget *image11;
@@ -242,7 +243,7 @@
   treeview1 = gtk_tree_view_new ();
   gtk_widget_show (treeview1);
   gtk_container_add (GTK_CONTAINER (scrolledwindow1), treeview1);
-  gtk_widget_set_size_request (treeview1, 288, 336);
+  gtk_widget_set_size_request (treeview1, -1, 336);
   gtk_tree_view_set_headers_visible (GTK_TREE_VIEW (treeview1), FALSE);
   gtk_tree_view_set_rules_hint (GTK_TREE_VIEW (treeview1), TRUE);
   gtk_tree_view_set_enable_search (GTK_TREE_VIEW (treeview1), FALSE);
@@ -263,7 +264,7 @@
   scrolledwindow2 = gtk_scrolled_window_new (NULL, NULL);
   gtk_widget_show (scrolledwindow2);
   gtk_container_add (GTK_CONTAINER (notebook1), scrolledwindow2);
-  gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scrolledwindow2), GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);
+  gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scrolledwindow2), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
 
   treeview2 = gtk_tree_view_new ();
   gtk_widget_show (treeview2);
@@ -287,7 +288,7 @@
   scrolledwindow3 = gtk_scrolled_window_new (NULL, NULL);
   gtk_widget_show (scrolledwindow3);
   gtk_container_add (GTK_CONTAINER (notebook1), scrolledwindow3);
-  gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scrolledwindow3), GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);
+  gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scrolledwindow3), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
 
   treeview3 = gtk_tree_view_new ();
   gtk_widget_show (treeview3);
@@ -311,7 +312,7 @@
   scrolledwindow4 = gtk_scrolled_window_new (NULL, NULL);
   gtk_widget_show (scrolledwindow4);
   gtk_container_add (GTK_CONTAINER (notebook1), scrolledwindow4);
-  gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scrolledwindow4), GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);
+  gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scrolledwindow4), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
 
   treeview4 = gtk_tree_view_new ();
   gtk_widget_show (treeview4);
@@ -335,7 +336,7 @@
   scrolledwindow5 = gtk_scrolled_window_new (NULL, NULL);
   gtk_widget_show (scrolledwindow5);
   gtk_container_add (GTK_CONTAINER (notebook1), scrolledwindow5);
-  gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scrolledwindow5), GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);
+  gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scrolledwindow5), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
 
   treeview5 = gtk_tree_view_new ();
   gtk_widget_show (treeview5);
@@ -359,7 +360,7 @@
   scrolledwindow6 = gtk_scrolled_window_new (NULL, NULL);
   gtk_widget_show (scrolledwindow6);
   gtk_container_add (GTK_CONTAINER (notebook1), scrolledwindow6);
-  gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scrolledwindow6), GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);
+  gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scrolledwindow6), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
 
   treeview6 = gtk_tree_view_new ();
   gtk_widget_show (treeview6);
@@ -383,7 +384,7 @@
   scrolledwindow7 = gtk_scrolled_window_new (NULL, NULL);
   gtk_widget_show (scrolledwindow7);
   gtk_container_add (GTK_CONTAINER (notebook1), scrolledwindow7);
-  gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scrolledwindow7), GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);
+  gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scrolledwindow7), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
 
   treeview7 = gtk_tree_view_new ();
   gtk_widget_show (treeview7);
@@ -404,6 +405,17 @@
   gtk_widget_show (label22);
   gtk_box_pack_start (GTK_BOX (hbox4), label22, FALSE, FALSE, 4);
 
+  treeview8 = gtk_tree_view_new ();
+  gtk_widget_show (treeview8);
+  gtk_container_add (GTK_CONTAINER (notebook1), treeview8);
+  gtk_tree_view_set_headers_visible (GTK_TREE_VIEW (treeview8), FALSE);
+  gtk_tree_view_set_rules_hint (GTK_TREE_VIEW (treeview8), TRUE);
+  gtk_tree_view_set_enable_search (GTK_TREE_VIEW (treeview8), FALSE);
+
+  label28 = gtk_label_new (_("External"));
+  gtk_widget_show (label28);
+  gtk_notebook_set_tab_label (GTK_NOTEBOOK (notebook1), gtk_notebook_get_nth_page (GTK_NOTEBOOK (notebook1), 7), label28);
+
   hbox13 = gtk_hbox_new (FALSE, 6);
   gtk_widget_show (hbox13);
   gtk_box_pack_start (GTK_BOX (vbox2), hbox13, FALSE, FALSE, 0);
@@ -450,7 +462,6 @@
   treeview0 = gtk_tree_view_new ();
   gtk_widget_show (treeview0);
   gtk_container_add (GTK_CONTAINER (scrolledwindow9), treeview0);
-  gtk_widget_set_size_request (treeview0, 288, 336);
   gtk_tree_view_set_headers_visible (GTK_TREE_VIEW (treeview0), FALSE);
   gtk_tree_view_set_rules_hint (GTK_TREE_VIEW (treeview0), TRUE);
   gtk_tree_view_set_enable_search (GTK_TREE_VIEW (treeview0), FALSE);
@@ -596,6 +607,8 @@
   GLADE_HOOKUP_OBJECT (dialog1, hbox4, "hbox4");
   GLADE_HOOKUP_OBJECT (dialog1, image7, "image7");
   GLADE_HOOKUP_OBJECT (dialog1, label22, "label22");
+  GLADE_HOOKUP_OBJECT (dialog1, treeview8, "treeview8");
+  GLADE_HOOKUP_OBJECT (dialog1, label28, "label28");
   GLADE_HOOKUP_OBJECT (dialog1, hbox13, "hbox13");
   GLADE_HOOKUP_OBJECT (dialog1, buttonAdd, "buttonAdd");
   GLADE_HOOKUP_OBJECT (dialog1, image11, "image11");

Modified: branches/avidemux_2.4_branch/avidemux/GUI_jobs.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/GUI_jobs.cpp	2007-01-03 19:47:39 UTC (rev 2678)
+++ branches/avidemux_2.4_branch/avidemux/GUI_jobs.cpp	2007-01-05 18:52:27 UTC (rev 2679)
@@ -32,7 +32,7 @@
 char     *name;
         memset(jobName,0,sizeof(jobName));
 
-        if(!buildDirectoryContent(&nb,ADM_getJobDir(),jobName,MAX_JOBS))
+        if(!buildDirectoryContent(&nb,ADM_getJobDir(),jobName,MAX_JOBS,".js"))
         {
           GUI_Error_HIG(_("Oops"),_("Something very wrong happened when buildint joblist"));
                 return 0;

Modified: branches/avidemux_2.4_branch/avidemux/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/Makefile.am	2007-01-03 19:47:39 UTC (rev 2678)
+++ branches/avidemux_2.4_branch/avidemux/Makefile.am	2007-01-05 18:52:27 UTC (rev 2679)
@@ -124,10 +124,10 @@
 avidemux2_gtk_LDADD=$(adm_lib) $(user_interface_gtk) $(adm_postlib)
 endif
 
-avidemux2_cli_LDADD=$(adm_lib) $(user_interface_cli) $(adm_postlib)
+avidemux2_cli_LDADD=$(adm_lib) $(user_interface_cli) $(adm_postlib) 
 
 if ADM_UI_QT4	
-avidemux2_qt4_LDADD=$(adm_lib) $(user_interface_qt4) $(adm_postlib)
+avidemux2_qt4_LDADD=$(adm_lib) $(user_interface_qt4) $(adm_postlib) 
 endif
 
 
@@ -141,13 +141,13 @@
 
 # the library search path.
 if ADM_UI_GTK
-avidemux2_gtk_LDFLAGS=$(all_libraries)  $(SDL_LIBS) $(GTK_LIBS) $(FREETYPE_LIBS) $(FC_LIBS) $(ARTS_LIBS) $(XML_LIBS) $(GLIB_LIBS)
+avidemux2_gtk_LDFLAGS=-Wl,--export-dynamic $(all_libraries)  $(SDL_LIBS) $(GTK_LIBS) $(FREETYPE_LIBS) $(FC_LIBS) $(ARTS_LIBS) $(XML_LIBS) $(GLIB_LIBS)
 endif
 
-avidemux2_cli_LDFLAGS = $(all_libraries)  $(SDL_LIBS) $(FREETYPE_LIBS) $(FC_LIBS) $(ARTS_LIBS) $(XML_LIBS)  $(GLIB_LIBS)
+avidemux2_cli_LDFLAGS =-Wl,--export-dynamic  $(all_libraries)  $(SDL_LIBS) $(FREETYPE_LIBS) $(FC_LIBS) $(ARTS_LIBS) $(XML_LIBS)  $(GLIB_LIBS)
 
 if ADM_UI_QT4	
-avidemux2_qt4_LDFLAGS=$(all_libraries)  $(SDL_LIBS) $(ADM_QTLIBS) $(FREETYPE_LIBS) $(FC_LIBS) $(ARTS_LIBS) $(XML_LIBS) $(GLIB_LIBS)
+avidemux2_qt4_LDFLAGS= -Wl,--export-dynamic $(all_libraries)  $(SDL_LIBS) $(ADM_QTLIBS) $(FREETYPE_LIBS) $(FC_LIBS) $(ARTS_LIBS) $(XML_LIBS) $(GLIB_LIBS)
 endif
 
 noinst_HEADERS = 

Modified: branches/avidemux_2.4_branch/avidemux/gtk_gui.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/gtk_gui.cpp	2007-01-03 19:47:39 UTC (rev 2678)
+++ branches/avidemux_2.4_branch/avidemux/gtk_gui.cpp	2007-01-05 18:52:27 UTC (rev 2679)
@@ -1204,7 +1204,7 @@
   if (!video_body->addFile (name))
     {
       DIA_StopBusy ();
-      GUI_Error_HIG (_("Something failed"), NULL);
+      GUI_Error_HIG (_("Something failed when appending"), NULL);
       return 0;
     }
   DIA_StopBusy ();

Modified: branches/avidemux_2.4_branch/avidemux/main.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/main.cpp	2007-01-03 19:47:39 UTC (rev 2678)
+++ branches/avidemux_2.4_branch/avidemux/main.cpp	2007-01-05 18:52:27 UTC (rev 2679)
@@ -46,7 +46,7 @@
 #ifdef USE_XVID_4
 extern void xvid4_init(void);
 #endif
-
+extern uint8_t filterDynLoad(const char *path);
 typedef void *FCT_VOID(void *);
 uint8_t lavformat_init(void);
 #ifdef USE_FFMPEG
@@ -198,7 +198,17 @@
 #ifdef HAVE_ENCODER
      registerVideoFilters(  );
 #endif
-
+// Try load load external filter
+     uint32_t loadpref=0;
+     char *dynloadPath=NULL;
+     prefs->get(FILTERS_AUTOLOAD_ACTIVE,&loadpref);
+     prefs->get(FILTERS_AUTOLOAD_PATH,&dynloadPath);
+     
+     if(loadpref && dynloadPath)
+     {
+      filterDynLoad(dynloadPath);
+     }
+// external filter
 #ifdef USE_FFMPEG
     avcodec_init();
     avcodec_register_all();

Modified: branches/avidemux_2.4_branch/avidemux/prefs.in
===================================================================
--- branches/avidemux_2.4_branch/avidemux/prefs.in	2007-01-03 19:47:39 UTC (rev 2678)
+++ branches/avidemux_2.4_branch/avidemux/prefs.in	2007-01-05 18:52:27 UTC (rev 2679)
@@ -85,3 +85,5 @@
 feature.mpeg_no_limit,                  UINT,   0,      0,      1
 # prologic 1/2
 downmixing.prologic,			UINT,	2,	0,	2
+filters.autoload.path,                  STRING, "/tmp/"
+filters.autoload.active,                UINT,   0,      0,      1
\ No newline at end of file



From mean at mail.berlios.de  Fri Jan  5 19:53:01 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 5 Jan 2007 19:53:01 +0100
Subject: [Avidemux-svn-commit] r2680 - branches/avidemux_2.4_branch/avidemux
Message-ID: <200701051853.l05Ir1Rb017180@sheep.berlios.de>

Author: mean
Date: 2007-01-05 19:53:00 +0100 (Fri, 05 Jan 2007)
New Revision: 2680

Modified:
   branches/avidemux_2.4_branch/avidemux/prefs.h
Log:
support for external filter, default pref file

Modified: branches/avidemux_2.4_branch/avidemux/prefs.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/prefs.h	2007-01-05 18:52:27 UTC (rev 2679)
+++ branches/avidemux_2.4_branch/avidemux/prefs.h	2007-01-05 18:53:00 UTC (rev 2680)
@@ -74,7 +74,9 @@
 	FEATURE_AUDIOBAR_USES_MASTER,
 	FEATURE_MULTI_THREAD,
 	FEATURE_MPEG_NO_LIMIT,
-	DOWNMIXING_PROLOGIC
+	DOWNMIXING_PROLOGIC,
+	FILTERS_AUTOLOAD_PATH,
+	FILTERS_AUTOLOAD_ACTIVE
 } options;
 // </prefs_gen>
 



From mean at mail.berlios.de  Fri Jan  5 20:10:01 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 5 Jan 2007 20:10:01 +0100
Subject: [Avidemux-svn-commit] r2681 - in
	branches/avidemux_2.4_branch/avidemux: ADM_filter ADM_video
Message-ID: <200701051910.l05JA13x018981@sheep.berlios.de>

Author: mean
Date: 2007-01-05 20:10:00 +0100 (Fri, 05 Jan 2007)
New Revision: 2681

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_filter/ADM_vidDummyFilter.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_filter/buildummy.sh
Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_genvideo.hxx
Log:
more robust external filter loading + sample code

Added: branches/avidemux_2.4_branch/avidemux/ADM_filter/ADM_vidDummyFilter.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_filter/ADM_vidDummyFilter.cpp	2007-01-05 18:53:00 UTC (rev 2680)
+++ branches/avidemux_2.4_branch/avidemux/ADM_filter/ADM_vidDummyFilter.cpp	2007-01-05 19:10:00 UTC (rev 2681)
@@ -0,0 +1,151 @@
+/***************************************************************************
+                          ADM_vidFlipV.cpp  -  description
+                             -------------------
+    begin                : Wed Nov 6 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+ #include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ADM_assert.h>
+
+#include "config.h"
+#include "fourcc.h"
+#include "avio.hxx"
+#include "config.h"
+#include "avi_vars.h"
+
+
+#include "ADM_toolkit/toolkit.hxx"
+#include "ADM_editor/ADM_edit.hxx"
+#include "ADM_video/ADM_genvideo.hxx"
+#include "ADM_video/ADM_vidFlipV.h"
+#include "ADM_filter/video_filters.h"
+
+//#define REDUCED
+//adm_fast_memcpy myAdmMemcpy=memcpy;
+#undef memcpy
+
+static FILTER_PARAM flipParam={0,{""}};
+
+//********************************************
+extern "C"
+{
+SCRIPT_CREATE(FILTER_create_fromscript,ADMVideoFlipV,flipParam);
+BUILD_CREATE(FILTER_create,ADMVideoFlipV);
+char *FILTER_getName(void)
+{
+	return "DynFLIPPER";
+}
+
+char *FILTER_getDesc(void)
+{
+	return "Vertical flip, demo for dynamically loaded filters";
+}
+
+
+
+uint32_t FILTER_getVersion(void)
+{
+  return 1; 
+}
+uint32_t FILTER_getAPIVersion(void)
+{
+  return ADM_FILTER_API_VERSION; 
+}
+}
+
+//********************************************
+char *ADMVideoFlipV::printConf( void )
+{
+ 	static char buf[50];
+ 	
+ 	sprintf((char *)buf," V-Flip");
+        return buf;
+}
+
+ADMVideoFlipV::ADMVideoFlipV(  AVDMGenericVideoStream *in,CONFcouple *setup)
+{
+    UNUSED_ARG(setup);
+    	ADM_assert(in);
+ 	_in=in;		
+	printf("%s\n",_in->printConf());
+   	memcpy(&_info,_in->getInfo(),sizeof(_info)); 	
+  	_info.encoding=1;	
+	_uncompressed=new ADMImage(_in->getInfo()->width,_in->getInfo()->height);
+	ADM_assert(_uncompressed);    	  	
+}
+ADMVideoFlipV::~ADMVideoFlipV()
+{
+ 	delete  _uncompressed;	
+	_uncompressed=NULL;
+  
+}
+uint8_t ADMVideoFlipV::getFrameNumberNoAlloc(uint32_t frame,
+				uint32_t *len,
+   				ADMImage *data,
+				uint32_t *flags)
+{
+
+	ADM_assert(frame<_info.nb_frames);
+	// read uncompressed frame
+	if(!_in->getFrameNumberNoAlloc(frame, len,_uncompressed,flags)) return 0;
+
+         uint8_t *in,*out;
+         uint32_t stride=_info.width;
+         uint32_t h=_info.height;
+         uint32_t page,qpage;
+        
+
+	  
+         page=stride*h;
+         qpage=page>>2;
+         
+         in=YPLANE(_uncompressed);
+         out=YPLANE(data)+(h-1)*stride;
+         // flip y
+         for(uint32_t y=h;y>0;y--)
+         {
+		 memcpy(out,in,stride);
+		 in+=stride;
+		 out-=stride;
+	}
+	// Flip U & V			         
+        stride>>=1;
+	in=UPLANE(_uncompressed);	
+        out=UPLANE(data)+qpage-stride;
+         // flip u
+         for(uint32_t y=h>>1;y>0;y--)
+         {
+		 memcpy(out,in,stride);
+		 in+=stride;
+		 out-=stride;
+	}
+	in=VPLANE(_uncompressed);
+        out=VPLANE(data)+qpage-stride;
+       
+      
+         // flip u
+         for(uint32_t y=h>>1;y>0;y--)
+         {
+		 memcpy(out,in,stride);
+		 in+=stride;
+		 out-=stride;
+	}   
+	data->copyInfo(_uncompressed);
+	return 1;
+}
+
+
+

Added: branches/avidemux_2.4_branch/avidemux/ADM_filter/buildummy.sh
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_filter/buildummy.sh	2007-01-05 18:53:00 UTC (rev 2680)
+++ branches/avidemux_2.4_branch/avidemux/ADM_filter/buildummy.sh	2007-01-05 19:10:00 UTC (rev 2681)
@@ -0,0 +1,3 @@
+g++ -DHAVE_CONFIG_H -I. -I. -I../..  -I../ADM_libraries -I../ADM_libraries/ADM_utilities -I../ADM_libraries/ADM_lavutil -I/usr/include/libxml2  -I/usr/include/malloc -I/usr/include/libxml2 -I/usr/include/SDL -D_GNU_SOURCE=1 -D_REENTRANT  -I.. -I../ADM_lavutil -IADM_utilities -I../ADM_utilities  -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64 -g -O2 -I../.. -O1 -g3 -falign-loops=16 -shared -o dummy.so ADM_vidDummyFilter.cpp -fPIC
+g++ -DHAVE_CONFIG_H -I. -I. -I../..  -I../ADM_libraries -I../ADM_libraries/ADM_utilities -I../ADM_libraries/ADM_lavutil -I/usr/include/libxml2  -I/usr/include/malloc -I/usr/include/libxml2 -I/usr/include/SDL -D_GNU_SOURCE=1 -D_REENTRANT  -I.. -I../ADM_lavutil -IADM_utilities -I../ADM_utilities  -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64 -g -O2 -I../.. -O1 -g3 -falign-loops=16 -o dummy.E -E ADM_vidDummyFilter.cpp -fPIC
+cp dummy.so ~/Xfilters

Modified: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_genvideo.hxx
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_genvideo.hxx	2007-01-05 18:53:00 UTC (rev 2680)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_genvideo.hxx	2007-01-05 19:10:00 UTC (rev 2681)
@@ -14,6 +14,8 @@
  *   (at your option) any later version.                                   *
  *                                                                         *
  ***************************************************************************/
+ 
+#define ADM_FILTER_API_VERSION 1
 /**
 	Not for filter writters :
 



From mean at mail.berlios.de  Fri Jan  5 20:10:28 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 5 Jan 2007 20:10:28 +0100
Subject: [Avidemux-svn-commit] r2682 -
	branches/avidemux_2.4_branch/avidemux/ADM_filter
Message-ID: <200701051910.l05JAS8V019168@sheep.berlios.de>

Author: mean
Date: 2007-01-05 20:10:28 +0100 (Fri, 05 Jan 2007)
New Revision: 2682

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_filter/filter_dylib.cpp
Log:
more robust external filter loading + sample code

Modified: branches/avidemux_2.4_branch/avidemux/ADM_filter/filter_dylib.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_filter/filter_dylib.cpp	2007-01-05 19:10:00 UTC (rev 2681)
+++ branches/avidemux_2.4_branch/avidemux/ADM_filter/filter_dylib.cpp	2007-01-05 19:10:28 UTC (rev 2682)
@@ -66,6 +66,8 @@
     \brief try do use the dynlib pointer by handle
 
 */
+typedef uint32_t (ADM_getIntP)(void);
+
 void tryLoading(void *handle)
 {
   ADM_assert(handle);
@@ -74,16 +76,30 @@
   int success=1;
   ADM_createT *createP;
   ADM_create_from_scriptT *createFromScriptP;
-  ADM_getStringT *nameP;
-  ADM_getStringT *descP;
+  ADM_getStringT  *nameP;
+  ADM_getStringT  *descP;
+  ADM_getIntP     *APIVersionP;
+  ADM_getIntP     *versionP;
+  uint32_t apiV;
+#define LOADSYM(x,y,z) if(success && !(f=loadSym(handle,x))) { success=0;printf("%s",dlerror());}   else {y=(z *)f;}
   
-#define LOADSYM(x,y,z) if(!(f=loadSym(handle,x))) { success=0;printf("%s",dlerror());}   else {y=(z *)f;}
   
-  
-    LOADSYM("FILTER_create",createP,ADM_createT);
+    LOADSYM("FILTER_create",        createP,    ADM_createT);
     LOADSYM("FILTER_create_fromscript",createFromScriptP,ADM_create_from_scriptT);
-    LOADSYM("FILTER_getName",nameP,ADM_getStringT);
-    LOADSYM("FILTER_getDesc",descP,ADM_getStringT);
+    LOADSYM("FILTER_getName",       nameP,      ADM_getStringT);
+    LOADSYM("FILTER_getDesc",       descP,      ADM_getStringT);
+    LOADSYM("FILTER_getVersion",    versionP,   ADM_getIntP);
+    LOADSYM("FILTER_getAPIVersion", APIVersionP,ADM_getIntP);
+    if(success)
+    {
+      apiV=APIVersionP();
+      if(apiV!=ADM_FILTER_API_VERSION)  // Check version did not change -> incompatble filter
+      {
+          printf("Wrong api version :%d expected %d\n",APIVersionP(),ADM_FILTER_API_VERSION);
+          success=0;
+      }
+    }    
+    // Check it is not a dupe ...
     
     if(!success)
     {
@@ -91,6 +107,8 @@
       return;
     }
     
+    
+    
     char *name,*desc;
     
     name=nameP();
@@ -99,7 +117,16 @@
     ADM_assert(name);
     ADM_assert(desc);
     
-    printf("Loaded filter %s\n",name);
+    VF_FILTERS id=filterGetTagFromName(name);
+    if(VF_DUMMY!=id)
+    {
+      printf("This filter(%s) is already registered as %u\n", name,id);
+      dlclose(handle);
+      return;
+    }
+
+    
+    printf("Loaded filter %s, version %d\n",name,versionP());
   
    registerFilterEx(name,(VF_FILTERS)dynTag,1,createP,name,createFromScriptP,desc);
 



From mean at mail.berlios.de  Fri Jan  5 20:11:24 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 5 Jan 2007 20:11:24 +0100
Subject: [Avidemux-svn-commit] r2683 -
	branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2
Message-ID: <200701051911.l05JBOAX019347@sheep.berlios.de>

Author: mean
Date: 2007-01-05 20:11:23 +0100 (Fri, 05 Jan 2007)
New Revision: 2683

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2/GUI_bindings.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2/GUI_main2.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2/GUI_menumap.h
Log:
some not working profile for PSP/H264

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2/GUI_bindings.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2/GUI_bindings.cpp	2007-01-05 19:10:28 UTC (rev 2682)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2/GUI_bindings.cpp	2007-01-05 19:11:23 UTC (rev 2683)
@@ -444,7 +444,7 @@
       return;
   }
   /* Collect the name */
-   if(! buildDirectoryContent(&ADM_nbCustom,customdir, customNames,ADM_MAC_CUSTOM_SCRIPT))
+   if(! buildDirectoryContent(&ADM_nbCustom,customdir, customNames,ADM_MAC_CUSTOM_SCRIPT,".js"))
     {
       printf("Failed to build custom dir content");
       return;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2/GUI_main2.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2/GUI_main2.cpp	2007-01-05 19:10:28 UTC (rev 2682)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2/GUI_main2.cpp	2007-01-05 19:11:23 UTC (rev 2683)
@@ -14,7 +14,11 @@
 
 #include <gdk/gdkkeysyms.h>
 #include <gtk/gtk.h>
-
+/*
+#include "callbacks.h"
+#include "interface.h"
+#include "support.h"
+*/
 #include "ADM_toolkit_gtk/ADM_gladeSupport.h"
 
 #define GLADE_HOOKUP_OBJECT(component,widget,name) \
@@ -34,11 +38,11 @@
   GtkWidget *menuitem1;
   GtkWidget *menuitem1_menu;
   GtkWidget *open_video1;
-  GtkWidget *image7946;
+  GtkWidget *image7996;
   GtkWidget *append_video1;
-  GtkWidget *image7947;
+  GtkWidget *image7997;
   GtkWidget *save_stuff;
-  GtkWidget *image7948;
+  GtkWidget *image7998;
   GtkWidget *save_stuff_menu;
   GtkWidget *save_as_avi1;
   GtkWidget *separator1;
@@ -47,39 +51,39 @@
   GtkWidget *save_selection_as_jpegs1;
   GtkWidget *separator3;
   GtkWidget *save_project1;
-  GtkWidget *image7949;
+  GtkWidget *image7999;
   GtkWidget *save_project_as1;
-  GtkWidget *image7950;
+  GtkWidget *image8000;
   GtkWidget *run_script1;
-  GtkWidget *image7951;
+  GtkWidget *image8001;
   GtkWidget *add_to_joblist1;
   GtkWidget *joblist1;
   GtkWidget *separator16;
   GtkWidget *video_informations1;
-  GtkWidget *image7952;
+  GtkWidget *image8002;
   GtkWidget *avi_muxer_options1;
   GtkWidget *separator4;
   GtkWidget *quit1;
-  GtkWidget *image7953;
+  GtkWidget *image8003;
   GtkWidget *menuitem2;
   GtkWidget *menuitem2_menu;
   GtkWidget *reset_edits1;
-  GtkWidget *image7954;
+  GtkWidget *image8004;
   GtkWidget *separator5;
   GtkWidget *cut1;
-  GtkWidget *image7955;
+  GtkWidget *image8005;
   GtkWidget *copy1;
-  GtkWidget *image7956;
+  GtkWidget *image8006;
   GtkWidget *paste1;
-  GtkWidget *image7957;
+  GtkWidget *image8007;
   GtkWidget *delete1;
-  GtkWidget *image7958;
+  GtkWidget *image8008;
   GtkWidget *separator6;
   GtkWidget *set_marker_a1;
   GtkWidget *set_marker_b1;
   GtkWidget *separator7;
   GtkWidget *preferences1;
-  GtkWidget *image7959;
+  GtkWidget *image8009;
   GtkWidget *view1;
   GtkWidget *view1_menu;
   GtkWidget *toolbar1;
@@ -108,13 +112,13 @@
   GtkWidget *build_vbr_time_map1;
   GtkWidget *separator11;
   GtkWidget *save_audio1;
-  GtkWidget *image7960;
+  GtkWidget *image8010;
   GtkWidget *audio_encoder1;
   GtkWidget *filters2;
   GtkWidget *tools1;
   GtkWidget *tools1_menu;
   GtkWidget *calculator1;
-  GtkWidget *image7961;
+  GtkWidget *image8011;
   GtkWidget *separator12;
   GtkWidget *rebuild_frames;
   GtkWidget *check_frames;
@@ -129,37 +133,38 @@
   GtkWidget *svcd1;
   GtkWidget *dvd1;
   GtkWidget *psp1;
+  GtkWidget *psp__h264_1;
   GtkWidget *go1;
   GtkWidget *go1_menu;
   GtkWidget *play_video1;
-  GtkWidget *image7962;
+  GtkWidget *image8012;
   GtkWidget *previous_frame1;
-  GtkWidget *image7963;
+  GtkWidget *image8013;
   GtkWidget *next_frame1;
-  GtkWidget *image7964;
+  GtkWidget *image8014;
   GtkWidget *previous_intra_frame1;
-  GtkWidget *image7965;
+  GtkWidget *image8015;
   GtkWidget *next_intra_frame1;
-  GtkWidget *image7966;
+  GtkWidget *image8016;
   GtkWidget *search_previous_black_frame1;
   GtkWidget *search_next_black_frame1;
   GtkWidget *first_frame1;
-  GtkWidget *image7967;
+  GtkWidget *image8017;
   GtkWidget *last_frame1;
-  GtkWidget *image7968;
+  GtkWidget *image8018;
   GtkWidget *separator14;
   GtkWidget *go_to_marker_a1;
   GtkWidget *go_to_marker_b1;
   GtkWidget *separator15;
   GtkWidget *jum_to_frame1;
-  GtkWidget *image7969;
+  GtkWidget *image8019;
   GtkWidget *jump_to_time1;
-  GtkWidget *image7970;
+  GtkWidget *image8020;
   GtkWidget *custom1;
   GtkWidget *help2;
   GtkWidget *help2_menu;
   GtkWidget *about1;
-  GtkWidget *image7971;
+  GtkWidget *image8021;
   GtkWidget *show_builtin_support1;
   GtkWidget *toolbar2;
   GtkIconSize tmp_toolbar_icon_size;
@@ -286,9 +291,9 @@
                               GDK_O, (GdkModifierType)( GDK_CONTROL_MASK),
                               GTK_ACCEL_VISIBLE);
 
-  image7946 = gtk_image_new_from_stock ("gtk-open", GTK_ICON_SIZE_MENU);
-  gtk_widget_show (image7946);
-  gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (open_video1), image7946);
+  image7996 = gtk_image_new_from_stock ("gtk-open", GTK_ICON_SIZE_MENU);
+  gtk_widget_show (image7996);
+  gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (open_video1), image7996);
 
   append_video1 = gtk_image_menu_item_new_with_mnemonic (_("_Append..."));
   gtk_widget_show (append_video1);
@@ -297,17 +302,17 @@
                               GDK_A, (GdkModifierType)( GDK_CONTROL_MASK | GDK_MOD1_MASK),
                               GTK_ACCEL_VISIBLE);
 
-  image7947 = gtk_image_new_from_stock ("gtk-add", GTK_ICON_SIZE_MENU);
-  gtk_widget_show (image7947);
-  gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (append_video1), image7947);
+  image7997 = gtk_image_new_from_stock ("gtk-add", GTK_ICON_SIZE_MENU);
+  gtk_widget_show (image7997);
+  gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (append_video1), image7997);
 
   save_stuff = gtk_image_menu_item_new_with_mnemonic (_("_Save"));
   gtk_widget_show (save_stuff);
   gtk_container_add (GTK_CONTAINER (menuitem1_menu), save_stuff);
 
-  image7948 = gtk_image_new_from_stock ("gtk-save", GTK_ICON_SIZE_MENU);
-  gtk_widget_show (image7948);
-  gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (save_stuff), image7948);
+  image7998 = gtk_image_new_from_stock ("gtk-save", GTK_ICON_SIZE_MENU);
+  gtk_widget_show (image7998);
+  gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (save_stuff), image7998);
 
   save_stuff_menu = gtk_menu_new ();
   gtk_menu_item_set_submenu (GTK_MENU_ITEM (save_stuff), save_stuff_menu);
@@ -345,25 +350,25 @@
   gtk_widget_show (save_project1);
   gtk_container_add (GTK_CONTAINER (menuitem1_menu), save_project1);
 
-  image7949 = gtk_image_new_from_stock ("gtk-save", GTK_ICON_SIZE_MENU);
-  gtk_widget_show (image7949);
-  gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (save_project1), image7949);
+  image7999 = gtk_image_new_from_stock ("gtk-save", GTK_ICON_SIZE_MENU);
+  gtk_widget_show (image7999);
+  gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (save_project1), image7999);
 
   save_project_as1 = gtk_image_menu_item_new_with_mnemonic (_("Save P_roject As..."));
   gtk_widget_show (save_project_as1);
   gtk_container_add (GTK_CONTAINER (menuitem1_menu), save_project_as1);
 
-  image7950 = gtk_image_new_from_stock ("gtk-save-as", GTK_ICON_SIZE_MENU);
-  gtk_widget_show (image7950);
-  gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (save_project_as1), image7950);
+  image8000 = gtk_image_new_from_stock ("gtk-save-as", GTK_ICON_SIZE_MENU);
+  gtk_widget_show (image8000);
+  gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (save_project_as1), image8000);
 
   run_script1 = gtk_image_menu_item_new_with_mnemonic (_("_Load/Run Project..."));
   gtk_widget_show (run_script1);
   gtk_container_add (GTK_CONTAINER (menuitem1_menu), run_script1);
 
-  image7951 = gtk_image_new_from_stock ("gtk-execute", GTK_ICON_SIZE_MENU);
-  gtk_widget_show (image7951);
-  gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (run_script1), image7951);
+  image8001 = gtk_image_new_from_stock ("gtk-execute", GTK_ICON_SIZE_MENU);
+  gtk_widget_show (image8001);
+  gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (run_script1), image8001);
 
   add_to_joblist1 = gtk_menu_item_new_with_mnemonic (_("A_dd to Joblist..."));
   gtk_widget_show (add_to_joblist1);
@@ -388,9 +393,9 @@
                               GDK_Return, (GdkModifierType)( GDK_MOD1_MASK),
                               GTK_ACCEL_VISIBLE);
 
-  image7952 = gtk_image_new_from_stock ("gtk-properties", GTK_ICON_SIZE_MENU);
-  gtk_widget_show (image7952);
-  gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (video_informations1), image7952);
+  image8002 = gtk_image_new_from_stock ("gtk-properties", GTK_ICON_SIZE_MENU);
+  gtk_widget_show (image8002);
+  gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (video_informations1), image8002);
 
   avi_muxer_options1 = gtk_menu_item_new_with_mnemonic (_("AVI _Muxer Options"));
   gtk_widget_show (avi_muxer_options1);
@@ -408,9 +413,9 @@
                               GDK_Q, (GdkModifierType)( GDK_CONTROL_MASK),
                               GTK_ACCEL_VISIBLE);
 
-  image7953 = gtk_image_new_from_stock ("gtk-quit", GTK_ICON_SIZE_MENU);
-  gtk_widget_show (image7953);
-  gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (quit1), image7953);
+  image8003 = gtk_image_new_from_stock ("gtk-quit", GTK_ICON_SIZE_MENU);
+  gtk_widget_show (image8003);
+  gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (quit1), image8003);
 
   menuitem2 = gtk_menu_item_new_with_mnemonic (_("_Edit"));
   gtk_widget_show (menuitem2);
@@ -423,9 +428,9 @@
   gtk_widget_show (reset_edits1);
   gtk_container_add (GTK_CONTAINER (menuitem2_menu), reset_edits1);
 
-  image7954 = gtk_image_new_from_stock ("gtk-undo", GTK_ICON_SIZE_MENU);
-  gtk_widget_show (image7954);
-  gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (reset_edits1), image7954);
+  image8004 = gtk_image_new_from_stock ("gtk-undo", GTK_ICON_SIZE_MENU);
+  gtk_widget_show (image8004);
+  gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (reset_edits1), image8004);
 
   separator5 = gtk_separator_menu_item_new ();
   gtk_widget_show (separator5);
@@ -439,9 +444,9 @@
                               GDK_X, (GdkModifierType)( GDK_CONTROL_MASK),
                               GTK_ACCEL_VISIBLE);
 
-  image7955 = gtk_image_new_from_stock ("gtk-cut", GTK_ICON_SIZE_MENU);
-  gtk_widget_show (image7955);
-  gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (cut1), image7955);
+  image8005 = gtk_image_new_from_stock ("gtk-cut", GTK_ICON_SIZE_MENU);
+  gtk_widget_show (image8005);
+  gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (cut1), image8005);
 
   copy1 = gtk_image_menu_item_new_with_mnemonic (_("_Copy"));
   gtk_widget_show (copy1);
@@ -450,9 +455,9 @@
                               GDK_C, (GdkModifierType)( GDK_CONTROL_MASK),
                               GTK_ACCEL_VISIBLE);
 
-  image7956 = gtk_image_new_from_stock ("gtk-copy", GTK_ICON_SIZE_MENU);
-  gtk_widget_show (image7956);
-  gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (copy1), image7956);
+  image8006 = gtk_image_new_from_stock ("gtk-copy", GTK_ICON_SIZE_MENU);
+  gtk_widget_show (image8006);
+  gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (copy1), image8006);
 
   paste1 = gtk_image_menu_item_new_with_mnemonic (_("_Paste"));
   gtk_widget_show (paste1);
@@ -461,9 +466,9 @@
                               GDK_V, (GdkModifierType)( GDK_CONTROL_MASK),
                               GTK_ACCEL_VISIBLE);
 
-  image7957 = gtk_image_new_from_stock ("gtk-paste", GTK_ICON_SIZE_MENU);
-  gtk_widget_show (image7957);
-  gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (paste1), image7957);
+  image8007 = gtk_image_new_from_stock ("gtk-paste", GTK_ICON_SIZE_MENU);
+  gtk_widget_show (image8007);
+  gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (paste1), image8007);
 
   delete1 = gtk_image_menu_item_new_with_mnemonic (_("_Delete"));
   gtk_widget_show (delete1);
@@ -472,9 +477,9 @@
                               GDK_Delete, (GdkModifierType)( 0 ),
                               GTK_ACCEL_VISIBLE);
 
-  image7958 = gtk_image_new_from_stock ("gtk-remove", GTK_ICON_SIZE_MENU);
-  gtk_widget_show (image7958);
-  gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (delete1), image7958);
+  image8008 = gtk_image_new_from_stock ("gtk-remove", GTK_ICON_SIZE_MENU);
+  gtk_widget_show (image8008);
+  gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (delete1), image8008);
 
   separator6 = gtk_separator_menu_item_new ();
   gtk_widget_show (separator6);
@@ -504,9 +509,9 @@
   gtk_widget_show (preferences1);
   gtk_container_add (GTK_CONTAINER (menuitem2_menu), preferences1);
 
-  image7959 = gtk_image_new_from_stock ("gtk-preferences", GTK_ICON_SIZE_MENU);
-  gtk_widget_show (image7959);
-  gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (preferences1), image7959);
+  image8009 = gtk_image_new_from_stock ("gtk-preferences", GTK_ICON_SIZE_MENU);
+  gtk_widget_show (image8009);
+  gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (preferences1), image8009);
 
   view1 = gtk_menu_item_new_with_mnemonic (_("_View"));
   gtk_widget_show (view1);
@@ -660,9 +665,9 @@
                               GDK_S, (GdkModifierType)( GDK_CONTROL_MASK | GDK_MOD1_MASK),
                               GTK_ACCEL_VISIBLE);
 
-  image7960 = gtk_image_new_from_stock ("gtk-save-as", GTK_ICON_SIZE_MENU);
-  gtk_widget_show (image7960);
-  gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (save_audio1), image7960);
+  image8010 = gtk_image_new_from_stock ("gtk-save-as", GTK_ICON_SIZE_MENU);
+  gtk_widget_show (image8010);
+  gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (save_audio1), image8010);
 
   audio_encoder1 = gtk_menu_item_new_with_mnemonic (_("_Encoder"));
   gtk_widget_show (audio_encoder1);
@@ -689,9 +694,9 @@
                               GDK_F7, (GdkModifierType)( 0 ),
                               GTK_ACCEL_VISIBLE);
 
-  image7961 = create_pixmap (mainWindow, "gnome-calculator_small.xpm");
-  gtk_widget_show (image7961);
-  gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (calculator1), image7961);
+  image8011 = create_pixmap (mainWindow, "gnome-calculator_small.xpm");
+  gtk_widget_show (image8011);
+  gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (calculator1), image8011);
 
   separator12 = gtk_separator_menu_item_new ();
   gtk_widget_show (separator12);
@@ -750,6 +755,10 @@
   gtk_widget_show (psp1);
   gtk_container_add (GTK_CONTAINER (help1_menu), psp1);
 
+  psp__h264_1 = gtk_menu_item_new_with_mnemonic (_("PSP (H264)"));
+  gtk_widget_show (psp__h264_1);
+  gtk_container_add (GTK_CONTAINER (help1_menu), psp__h264_1);
+
   go1 = gtk_menu_item_new_with_mnemonic (_("_Go"));
   gtk_widget_show (go1);
   gtk_container_add (GTK_CONTAINER (menuBar), go1);
@@ -764,9 +773,9 @@
                               GDK_P, (GdkModifierType)( 0 ),
                               GTK_ACCEL_VISIBLE);
 
-  image7962 = gtk_image_new_from_stock ("gtk-media-play", GTK_ICON_SIZE_MENU);
-  gtk_widget_show (image7962);
-  gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (play_video1), image7962);
+  image8012 = gtk_image_new_from_stock ("gtk-media-play", GTK_ICON_SIZE_MENU);
+  gtk_widget_show (image8012);
+  gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (play_video1), image8012);
 
   previous_frame1 = gtk_image_menu_item_new_with_mnemonic (_("P_revious Frame"));
   gtk_widget_show (previous_frame1);
@@ -775,9 +784,9 @@
                               GDK_KP_4, (GdkModifierType)( 0 ),
                               GTK_ACCEL_VISIBLE);
 
-  image7963 = gtk_image_new_from_stock ("gtk-media-previous", GTK_ICON_SIZE_MENU);
-  gtk_widget_show (image7963);
-  gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (previous_frame1), image7963);
+  image8013 = gtk_image_new_from_stock ("gtk-media-previous", GTK_ICON_SIZE_MENU);
+  gtk_widget_show (image8013);
+  gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (previous_frame1), image8013);
 
   next_frame1 = gtk_image_menu_item_new_with_mnemonic (_("_Next Frame"));
   gtk_widget_show (next_frame1);
@@ -786,9 +795,9 @@
                               GDK_KP_6, (GdkModifierType)( 0 ),
                               GTK_ACCEL_VISIBLE);
 
-  image7964 = gtk_image_new_from_stock ("gtk-media-next", GTK_ICON_SIZE_MENU);
-  gtk_widget_show (image7964);
-  gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (next_frame1), image7964);
+  image8014 = gtk_image_new_from_stock ("gtk-media-next", GTK_ICON_SIZE_MENU);
+  gtk_widget_show (image8014);
+  gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (next_frame1), image8014);
 
   previous_intra_frame1 = gtk_image_menu_item_new_with_mnemonic (_("Pr_evious Intra Frame"));
   gtk_widget_show (previous_intra_frame1);
@@ -797,9 +806,9 @@
                               GDK_KP_2, (GdkModifierType)( 0 ),
                               GTK_ACCEL_VISIBLE);
 
-  image7965 = gtk_image_new_from_stock ("gtk-media-rewind", GTK_ICON_SIZE_MENU);
-  gtk_widget_show (image7965);
-  gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (previous_intra_frame1), image7965);
+  image8015 = gtk_image_new_from_stock ("gtk-media-rewind", GTK_ICON_SIZE_MENU);
+  gtk_widget_show (image8015);
+  gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (previous_intra_frame1), image8015);
 
   next_intra_frame1 = gtk_image_menu_item_new_with_mnemonic (_("Next _Intra Frame"));
   gtk_widget_show (next_intra_frame1);
@@ -808,9 +817,9 @@
                               GDK_KP_8, (GdkModifierType)( 0 ),
                               GTK_ACCEL_VISIBLE);
 
-  image7966 = gtk_image_new_from_stock ("gtk-media-forward", GTK_ICON_SIZE_MENU);
-  gtk_widget_show (image7966);
-  gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (next_intra_frame1), image7966);
+  image8016 = gtk_image_new_from_stock ("gtk-media-forward", GTK_ICON_SIZE_MENU);
+  gtk_widget_show (image8016);
+  gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (next_intra_frame1), image8016);
 
   search_previous_black_frame1 = gtk_menu_item_new_with_mnemonic (_("Previou_s Black Frame"));
   gtk_widget_show (search_previous_black_frame1);
@@ -827,9 +836,9 @@
                               GDK_Home, (GdkModifierType)( 0 ),
                               GTK_ACCEL_VISIBLE);
 
-  image7967 = gtk_image_new_from_stock ("gtk-goto-first", GTK_ICON_SIZE_MENU);
-  gtk_widget_show (image7967);
-  gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (first_frame1), image7967);
+  image8017 = gtk_image_new_from_stock ("gtk-goto-first", GTK_ICON_SIZE_MENU);
+  gtk_widget_show (image8017);
+  gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (first_frame1), image8017);
 
   last_frame1 = gtk_image_menu_item_new_with_mnemonic (_("_Last Frame"));
   gtk_widget_show (last_frame1);
@@ -838,9 +847,9 @@
                               GDK_End, (GdkModifierType)( 0 ),
                               GTK_ACCEL_VISIBLE);
 
-  image7968 = gtk_image_new_from_stock ("gtk-goto-last", GTK_ICON_SIZE_MENU);
-  gtk_widget_show (image7968);
-  gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (last_frame1), image7968);
+  image8018 = gtk_image_new_from_stock ("gtk-goto-last", GTK_ICON_SIZE_MENU);
+  gtk_widget_show (image8018);
+  gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (last_frame1), image8018);
 
   separator14 = gtk_separator_menu_item_new ();
   gtk_widget_show (separator14);
@@ -873,9 +882,9 @@
                               GDK_F, (GdkModifierType)( GDK_CONTROL_MASK),
                               GTK_ACCEL_VISIBLE);
 
-  image7969 = gtk_image_new_from_stock ("gtk-jump-to", GTK_ICON_SIZE_MENU);
-  gtk_widget_show (image7969);
-  gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (jum_to_frame1), image7969);
+  image8019 = gtk_image_new_from_stock ("gtk-jump-to", GTK_ICON_SIZE_MENU);
+  gtk_widget_show (image8019);
+  gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (jum_to_frame1), image8019);
 
   jump_to_time1 = gtk_image_menu_item_new_with_mnemonic (_("Jump to _Time..."));
   gtk_widget_show (jump_to_time1);
@@ -884,9 +893,9 @@
                               GDK_T, (GdkModifierType)( GDK_CONTROL_MASK),
                               GTK_ACCEL_VISIBLE);
 
-  image7970 = gtk_image_new_from_stock ("gtk-jump-to", GTK_ICON_SIZE_MENU);
-  gtk_widget_show (image7970);
-  gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (jump_to_time1), image7970);
+  image8020 = gtk_image_new_from_stock ("gtk-jump-to", GTK_ICON_SIZE_MENU);
+  gtk_widget_show (image8020);
+  gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (jump_to_time1), image8020);
 
   custom1 = gtk_menu_item_new_with_mnemonic (_("Custom"));
   gtk_widget_show (custom1);
@@ -903,9 +912,9 @@
   gtk_widget_show (about1);
   gtk_container_add (GTK_CONTAINER (help2_menu), about1);
 
-  image7971 = gtk_image_new_from_stock ("gtk-about", GTK_ICON_SIZE_MENU);
-  gtk_widget_show (image7971);
-  gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (about1), image7971);
+  image8021 = gtk_image_new_from_stock ("gtk-about", GTK_ICON_SIZE_MENU);
+  gtk_widget_show (image8021);
+  gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (about1), image8021);
 
   show_builtin_support1 = gtk_menu_item_new_with_mnemonic (_("Show builtin support"));
   gtk_widget_show (show_builtin_support1);
@@ -1014,7 +1023,7 @@
   gtk_box_pack_start (GTK_BOX (vbox7), comboboxVideo, FALSE, FALSE, 0);
   gtk_combo_box_append_text (GTK_COMBO_BOX (comboboxVideo), _("Copy"));
 
-  buttonConfV = gtk_button_new_with_mnemonic (_("Configure"));
+  buttonConfV = gtk_button_new_with_mnemonic ("Configure");
   gtk_widget_show (buttonConfV);
   gtk_box_pack_start (GTK_BOX (vbox7), buttonConfV, FALSE, FALSE, 0);
   gtk_tooltips_set_tip (tooltips, buttonConfV, _("Configure video encoder"), NULL);
@@ -1054,7 +1063,7 @@
   gtk_box_pack_start (GTK_BOX (vbox8), comboboxAudio, FALSE, FALSE, 0);
   gtk_combo_box_append_text (GTK_COMBO_BOX (comboboxAudio), _("Copy"));
 
-  buttonConfA = gtk_button_new_with_mnemonic (_("Configure"));
+  buttonConfA = gtk_button_new_with_mnemonic ("Configure");
   gtk_widget_show (buttonConfA);
   gtk_box_pack_start (GTK_BOX (vbox8), buttonConfA, FALSE, FALSE, 0);
   gtk_tooltips_set_tip (tooltips, buttonConfA, _("Configure audio encoder"), NULL);
@@ -1124,7 +1133,7 @@
   gtk_combo_box_append_text (GTK_COMBO_BOX (comboboxFormat), _("MPEG PS A+V"));
   gtk_combo_box_append_text (GTK_COMBO_BOX (comboboxFormat), _("MPEG TS A+V"));
   gtk_combo_box_append_text (GTK_COMBO_BOX (comboboxFormat), _("MP4"));
-  gtk_combo_box_append_text (GTK_COMBO_BOX (comboboxFormat), _("PSP (broken)"));
+  gtk_combo_box_append_text (GTK_COMBO_BOX (comboboxFormat), _("PSP"));
 
   guiDrawing = gtk_drawing_area_new ();
   gtk_widget_show (guiDrawing);
@@ -1419,6 +1428,10 @@
   GTK_WIDGET_SET_FLAGS (labelFrameType, GTK_CAN_FOCUS);
   gtk_label_set_selectable (GTK_LABEL (labelFrameType), TRUE);
 
+//   g_signal_connect ((gpointer) psp__h264_1, "activate",
+//                     G_CALLBACK (on_psp_h264_activate),
+//                     NULL);
+
   /* Store pointers to all widgets, for use by lookup_widget(). */
   GLADE_HOOKUP_OBJECT_NO_REF (mainWindow, mainWindow, "mainWindow");
   GLADE_HOOKUP_OBJECT (mainWindow, vbox1, "vbox1");
@@ -1426,11 +1439,11 @@
   GLADE_HOOKUP_OBJECT (mainWindow, menuitem1, "menuitem1");
   GLADE_HOOKUP_OBJECT (mainWindow, menuitem1_menu, "menuitem1_menu");
   GLADE_HOOKUP_OBJECT (mainWindow, open_video1, "open_video1");
-  GLADE_HOOKUP_OBJECT (mainWindow, image7946, "image7946");
+  GLADE_HOOKUP_OBJECT (mainWindow, image7996, "image7996");
   GLADE_HOOKUP_OBJECT (mainWindow, append_video1, "append_video1");
-  GLADE_HOOKUP_OBJECT (mainWindow, image7947, "image7947");
+  GLADE_HOOKUP_OBJECT (mainWindow, image7997, "image7997");
   GLADE_HOOKUP_OBJECT (mainWindow, save_stuff, "save_stuff");
-  GLADE_HOOKUP_OBJECT (mainWindow, image7948, "image7948");
+  GLADE_HOOKUP_OBJECT (mainWindow, image7998, "image7998");
   GLADE_HOOKUP_OBJECT (mainWindow, save_stuff_menu, "save_stuff_menu");
   GLADE_HOOKUP_OBJECT (mainWindow, save_as_avi1, "save_as_avi1");
   GLADE_HOOKUP_OBJECT (mainWindow, separator1, "separator1");
@@ -1439,39 +1452,39 @@
   GLADE_HOOKUP_OBJECT (mainWindow, save_selection_as_jpegs1, "save_selection_as_jpegs1");
   GLADE_HOOKUP_OBJECT (mainWindow, separator3, "separator3");
   GLADE_HOOKUP_OBJECT (mainWindow, save_project1, "save_project1");
-  GLADE_HOOKUP_OBJECT (mainWindow, image7949, "image7949");
+  GLADE_HOOKUP_OBJECT (mainWindow, image7999, "image7999");
   GLADE_HOOKUP_OBJECT (mainWindow, save_project_as1, "save_project_as1");
-  GLADE_HOOKUP_OBJECT (mainWindow, image7950, "image7950");
+  GLADE_HOOKUP_OBJECT (mainWindow, image8000, "image8000");
   GLADE_HOOKUP_OBJECT (mainWindow, run_script1, "run_script1");
-  GLADE_HOOKUP_OBJECT (mainWindow, image7951, "image7951");
+  GLADE_HOOKUP_OBJECT (mainWindow, image8001, "image8001");
   GLADE_HOOKUP_OBJECT (mainWindow, add_to_joblist1, "add_to_joblist1");
   GLADE_HOOKUP_OBJECT (mainWindow, joblist1, "joblist1");
   GLADE_HOOKUP_OBJECT (mainWindow, separator16, "separator16");
   GLADE_HOOKUP_OBJECT (mainWindow, video_informations1, "video_informations1");
-  GLADE_HOOKUP_OBJECT (mainWindow, image7952, "image7952");
+  GLADE_HOOKUP_OBJECT (mainWindow, image8002, "image8002");
   GLADE_HOOKUP_OBJECT (mainWindow, avi_muxer_options1, "avi_muxer_options1");
   GLADE_HOOKUP_OBJECT (mainWindow, separator4, "separator4");
   GLADE_HOOKUP_OBJECT (mainWindow, quit1, "quit1");
-  GLADE_HOOKUP_OBJECT (mainWindow, image7953, "image7953");
+  GLADE_HOOKUP_OBJECT (mainWindow, image8003, "image8003");
   GLADE_HOOKUP_OBJECT (mainWindow, menuitem2, "menuitem2");
   GLADE_HOOKUP_OBJECT (mainWindow, menuitem2_menu, "menuitem2_menu");
   GLADE_HOOKUP_OBJECT (mainWindow, reset_edits1, "reset_edits1");
-  GLADE_HOOKUP_OBJECT (mainWindow, image7954, "image7954");
+  GLADE_HOOKUP_OBJECT (mainWindow, image8004, "image8004");
   GLADE_HOOKUP_OBJECT (mainWindow, separator5, "separator5");
   GLADE_HOOKUP_OBJECT (mainWindow, cut1, "cut1");
-  GLADE_HOOKUP_OBJECT (mainWindow, image7955, "image7955");
+  GLADE_HOOKUP_OBJECT (mainWindow, image8005, "image8005");
   GLADE_HOOKUP_OBJECT (mainWindow, copy1, "copy1");
-  GLADE_HOOKUP_OBJECT (mainWindow, image7956, "image7956");
+  GLADE_HOOKUP_OBJECT (mainWindow, image8006, "image8006");
   GLADE_HOOKUP_OBJECT (mainWindow, paste1, "paste1");
-  GLADE_HOOKUP_OBJECT (mainWindow, image7957, "image7957");
+  GLADE_HOOKUP_OBJECT (mainWindow, image8007, "image8007");
   GLADE_HOOKUP_OBJECT (mainWindow, delete1, "delete1");
-  GLADE_HOOKUP_OBJECT (mainWindow, image7958, "image7958");
+  GLADE_HOOKUP_OBJECT (mainWindow, image8008, "image8008");
   GLADE_HOOKUP_OBJECT (mainWindow, separator6, "separator6");
   GLADE_HOOKUP_OBJECT (mainWindow, set_marker_a1, "set_marker_a1");
   GLADE_HOOKUP_OBJECT (mainWindow, set_marker_b1, "set_marker_b1");
   GLADE_HOOKUP_OBJECT (mainWindow, separator7, "separator7");
   GLADE_HOOKUP_OBJECT (mainWindow, preferences1, "preferences1");
-  GLADE_HOOKUP_OBJECT (mainWindow, image7959, "image7959");
+  GLADE_HOOKUP_OBJECT (mainWindow, image8009, "image8009");
   GLADE_HOOKUP_OBJECT (mainWindow, view1, "view1");
   GLADE_HOOKUP_OBJECT (mainWindow, view1_menu, "view1_menu");
   GLADE_HOOKUP_OBJECT (mainWindow, toolbar1, "toolbar1");
@@ -1500,13 +1513,13 @@
   GLADE_HOOKUP_OBJECT (mainWindow, build_vbr_time_map1, "build_vbr_time_map1");
   GLADE_HOOKUP_OBJECT (mainWindow, separator11, "separator11");
   GLADE_HOOKUP_OBJECT (mainWindow, save_audio1, "save_audio1");
-  GLADE_HOOKUP_OBJECT (mainWindow, image7960, "image7960");
+  GLADE_HOOKUP_OBJECT (mainWindow, image8010, "image8010");
   GLADE_HOOKUP_OBJECT (mainWindow, audio_encoder1, "audio_encoder1");
   GLADE_HOOKUP_OBJECT (mainWindow, filters2, "filters2");
   GLADE_HOOKUP_OBJECT (mainWindow, tools1, "tools1");
   GLADE_HOOKUP_OBJECT (mainWindow, tools1_menu, "tools1_menu");
   GLADE_HOOKUP_OBJECT (mainWindow, calculator1, "calculator1");
-  GLADE_HOOKUP_OBJECT (mainWindow, image7961, "image7961");
+  GLADE_HOOKUP_OBJECT (mainWindow, image8011, "image8011");
   GLADE_HOOKUP_OBJECT (mainWindow, separator12, "separator12");
   GLADE_HOOKUP_OBJECT (mainWindow, rebuild_frames, "rebuild_frames");
   GLADE_HOOKUP_OBJECT (mainWindow, check_frames, "check_frames");
@@ -1521,37 +1534,38 @@
   GLADE_HOOKUP_OBJECT (mainWindow, svcd1, "svcd1");
   GLADE_HOOKUP_OBJECT (mainWindow, dvd1, "dvd1");
   GLADE_HOOKUP_OBJECT (mainWindow, psp1, "psp1");
+  GLADE_HOOKUP_OBJECT (mainWindow, psp__h264_1, "psp__h264_1");
   GLADE_HOOKUP_OBJECT (mainWindow, go1, "go1");
   GLADE_HOOKUP_OBJECT (mainWindow, go1_menu, "go1_menu");
   GLADE_HOOKUP_OBJECT (mainWindow, play_video1, "play_video1");
-  GLADE_HOOKUP_OBJECT (mainWindow, image7962, "image7962");
+  GLADE_HOOKUP_OBJECT (mainWindow, image8012, "image8012");
   GLADE_HOOKUP_OBJECT (mainWindow, previous_frame1, "previous_frame1");
-  GLADE_HOOKUP_OBJECT (mainWindow, image7963, "image7963");
+  GLADE_HOOKUP_OBJECT (mainWindow, image8013, "image8013");
   GLADE_HOOKUP_OBJECT (mainWindow, next_frame1, "next_frame1");
-  GLADE_HOOKUP_OBJECT (mainWindow, image7964, "image7964");
+  GLADE_HOOKUP_OBJECT (mainWindow, image8014, "image8014");
   GLADE_HOOKUP_OBJECT (mainWindow, previous_intra_frame1, "previous_intra_frame1");
-  GLADE_HOOKUP_OBJECT (mainWindow, image7965, "image7965");
+  GLADE_HOOKUP_OBJECT (mainWindow, image8015, "image8015");
   GLADE_HOOKUP_OBJECT (mainWindow, next_intra_frame1, "next_intra_frame1");
-  GLADE_HOOKUP_OBJECT (mainWindow, image7966, "image7966");
+  GLADE_HOOKUP_OBJECT (mainWindow, image8016, "image8016");
   GLADE_HOOKUP_OBJECT (mainWindow, search_previous_black_frame1, "search_previous_black_frame1");
   GLADE_HOOKUP_OBJECT (mainWindow, search_next_black_frame1, "search_next_black_frame1");
   GLADE_HOOKUP_OBJECT (mainWindow, first_frame1, "first_frame1");
-  GLADE_HOOKUP_OBJECT (mainWindow, image7967, "image7967");
+  GLADE_HOOKUP_OBJECT (mainWindow, image8017, "image8017");
   GLADE_HOOKUP_OBJECT (mainWindow, last_frame1, "last_frame1");
-  GLADE_HOOKUP_OBJECT (mainWindow, image7968, "image7968");
+  GLADE_HOOKUP_OBJECT (mainWindow, image8018, "image8018");
   GLADE_HOOKUP_OBJECT (mainWindow, separator14, "separator14");
   GLADE_HOOKUP_OBJECT (mainWindow, go_to_marker_a1, "go_to_marker_a1");
   GLADE_HOOKUP_OBJECT (mainWindow, go_to_marker_b1, "go_to_marker_b1");
   GLADE_HOOKUP_OBJECT (mainWindow, separator15, "separator15");
   GLADE_HOOKUP_OBJECT (mainWindow, jum_to_frame1, "jum_to_frame1");
-  GLADE_HOOKUP_OBJECT (mainWindow, image7969, "image7969");
+  GLADE_HOOKUP_OBJECT (mainWindow, image8019, "image8019");
   GLADE_HOOKUP_OBJECT (mainWindow, jump_to_time1, "jump_to_time1");
-  GLADE_HOOKUP_OBJECT (mainWindow, image7970, "image7970");
+  GLADE_HOOKUP_OBJECT (mainWindow, image8020, "image8020");
   GLADE_HOOKUP_OBJECT (mainWindow, custom1, "custom1");
   GLADE_HOOKUP_OBJECT (mainWindow, help2, "help2");
   GLADE_HOOKUP_OBJECT (mainWindow, help2_menu, "help2_menu");
   GLADE_HOOKUP_OBJECT (mainWindow, about1, "about1");
-  GLADE_HOOKUP_OBJECT (mainWindow, image7971, "image7971");
+  GLADE_HOOKUP_OBJECT (mainWindow, image8021, "image8021");
   GLADE_HOOKUP_OBJECT (mainWindow, show_builtin_support1, "show_builtin_support1");
   GLADE_HOOKUP_OBJECT (mainWindow, toolbar2, "toolbar2");
   GLADE_HOOKUP_OBJECT (mainWindow, menutoolbuttonOpen, "menutoolbuttonOpen");

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2/GUI_menumap.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2/GUI_menumap.h	2007-01-05 19:10:28 UTC (rev 2682)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2/GUI_menumap.h	2007-01-05 19:11:23 UTC (rev 2683)
@@ -83,6 +83,7 @@
 CALLBACK(svcd1                                  ,ACT_AUTO_SVCD);
 CALLBACK(dvd1                                   ,ACT_AUTO_DVD);
 CALLBACK(psp1                                   ,ACT_AUTO_PSP);
+CALLBACK(psp__h264_1,                           ACT_AUTO_PSP_H264);
 
 CALLBACK(add_to_joblist1                       ,ACT_ADD_JOB);
 CALLBACK(joblist1                              ,ACT_HANDLE_JOB);



From mean at mail.berlios.de  Sat Jan  6 11:20:52 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 6 Jan 2007 11:20:52 +0100
Subject: [Avidemux-svn-commit] r2685 -
	branches/avidemux_2.3_branch/avidemux/oplug_mpegFF
Message-ID: <200701061020.l06AKqit022679@sheep.berlios.de>

Author: mean
Date: 2007-01-06 11:20:52 +0100 (Sat, 06 Jan 2007)
New Revision: 2685

Modified:
   branches/avidemux_2.3_branch/avidemux/oplug_mpegFF/oplug_vcdff.cpp
Log:
fix for fix

Modified: branches/avidemux_2.3_branch/avidemux/oplug_mpegFF/oplug_vcdff.cpp
===================================================================
--- branches/avidemux_2.3_branch/avidemux/oplug_mpegFF/oplug_vcdff.cpp	2007-01-05 23:18:33 UTC (rev 2684)
+++ branches/avidemux_2.3_branch/avidemux/oplug_mpegFF/oplug_vcdff.cpp	2007-01-06 10:20:52 UTC (rev 2685)
@@ -130,8 +130,9 @@
         strcpy(twoPass,name);
         strcat(twoPass,".stat");
         /* orig: strcat(twoFake,".fake"); */
-	/* JSC v1: */ strcpy(twoFake,".fake");
-	/* JSC v2: */ strcpy(twoPass,name); strcat(twoFake,".fake");
+
+        strcpy(twoFake,name);
+        strcat(twoFake,".fake");
  
         _incoming = getLastVideoFilter (frameStart,frameEnd-frameStart);
         _w=_incoming->getInfo()->width;



From mean at mail.berlios.de  Sat Jan  6 16:08:27 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 6 Jan 2007 16:08:27 +0100
Subject: [Avidemux-svn-commit] r2686 -
	branches/avidemux_2.4_branch/avidemux/ADM_outputs/oplug_mpegFF
Message-ID: <200701061508.l06F8RSU028499@sheep.berlios.de>

Author: mean
Date: 2007-01-06 16:08:26 +0100 (Sat, 06 Jan 2007)
New Revision: 2686

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_outputs/oplug_mpegFF/oplug_vcdff.cpp
Log:
jens fix for 2.4

Modified: branches/avidemux_2.4_branch/avidemux/ADM_outputs/oplug_mpegFF/oplug_vcdff.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_outputs/oplug_mpegFF/oplug_vcdff.cpp	2007-01-06 10:20:52 UTC (rev 2685)
+++ branches/avidemux_2.4_branch/avidemux/ADM_outputs/oplug_mpegFF/oplug_vcdff.cpp	2007-01-06 15:08:26 UTC (rev 2686)
@@ -129,6 +129,7 @@
   
         strcpy(twoPass,name);
         strcat(twoPass,".stat");
+        strcpy(twoFake,name);
         strcat(twoFake,".fake");
  
         _incoming = getLastVideoFilter (frameStart,frameEnd-frameStart);



From mean at mail.berlios.de  Sat Jan  6 16:27:38 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 6 Jan 2007 16:27:38 +0100
Subject: [Avidemux-svn-commit] r2687 -
	branches/avidemux_2.4_branch/avidemux/ADM_filter
Message-ID: <200701061527.l06FRceT030265@sheep.berlios.de>

Author: mean
Date: 2007-01-06 16:27:38 +0100 (Sat, 06 Jan 2007)
New Revision: 2687

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_filter/filter_dylib.cpp
Log:
win32

Modified: branches/avidemux_2.4_branch/avidemux/ADM_filter/filter_dylib.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_filter/filter_dylib.cpp	2007-01-06 15:08:26 UTC (rev 2686)
+++ branches/avidemux_2.4_branch/avidemux/ADM_filter/filter_dylib.cpp	2007-01-06 15:27:38 UTC (rev 2687)
@@ -38,17 +38,27 @@
 #include "ADM_osSupport/ADM_debug.h"
 #include "ADM_osSupport/ADM_quota.h"
 
+#ifdef CYG_MANGLING
+#define TYPEOFHANDLE HMODULE
+#else
+#define TYPEOFHANDLE void*
+#endif
+
+
 typedef char *(ADM_getStringT)(void);
 
-static void tryLoading(void *handle);
-static void *loadSym(void *handle,const char *sym);
+static void tryLoading(TYPEOFHANDLE handle);
+static void *loadSym(TYPEOFHANDLE handle,const char *sym);
 static uint32_t dynTag=0xF0000000;
+
+
+
 /**
     \fn  loadSym(void *handle,const char *sym)
     \brief Get a pointer to the function name given as parameter
 
 */
-void *loadSym(void *handle,const char *sym)
+void *loadSym(TYPEOFHANDLE handle,const char *sym)
 {
   void *f;
    
@@ -68,7 +78,7 @@
 */
 typedef uint32_t (ADM_getIntP)(void);
 
-void tryLoading(void *handle)
+void tryLoading(TYPEOFHANDLE handle)
 {
   ADM_assert(handle);
   
@@ -81,9 +91,12 @@
   ADM_getIntP     *APIVersionP;
   ADM_getIntP     *versionP;
   uint32_t apiV;
+#ifdef CYG_MANGLING
+  #define LOADSYM(x,y,z) if(success && !(f=GetProcAddress(handle,x))) { success=0;}   else {y=(z *)f;}
+#else
 #define LOADSYM(x,y,z) if(success && !(f=loadSym(handle,x))) { success=0;printf("%s",dlerror());}   else {y=(z *)f;}
+#endif
   
-  
     LOADSYM("FILTER_create",        createP,    ADM_createT);
     LOADSYM("FILTER_create_fromscript",createFromScriptP,ADM_create_from_scriptT);
     LOADSYM("FILTER_getName",       nameP,      ADM_getStringT);
@@ -121,7 +134,9 @@
     if(VF_DUMMY!=id)
     {
       printf("This filter(%s) is already registered as %u\n", name,id);
+#ifndef CYG_MANGLING
       dlclose(handle);
+#endif
       return;
     }
 
@@ -153,7 +168,12 @@
   // Try to dyload them
   for(int i=0;i<nbFile;i++)
   {
-    void *h=dlopen(files[i],RTLD_NOW);
+    TYPEOFHANDLE h;
+#ifdef CYG_MANGLING
+    h= LoadLibrary(files[i]);
+#else
+    h=dlopen(files[i],RTLD_NOW);
+#endif
     if(!h)
     {
         printf("Dlopened failed for %s er:%s\n",files[i],dlerror());



From mean at mail.berlios.de  Sat Jan  6 17:28:31 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 6 Jan 2007 17:28:31 +0100
Subject: [Avidemux-svn-commit] r2688 -
	branches/avidemux_2.4_branch/avidemux/ADM_filter
Message-ID: <200701061628.l06GSVpQ002738@sheep.berlios.de>

Author: mean
Date: 2007-01-06 17:28:30 +0100 (Sat, 06 Jan 2007)
New Revision: 2688

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_filter/filter_dylib.cpp
Log:
win32 fixes

Modified: branches/avidemux_2.4_branch/avidemux/ADM_filter/filter_dylib.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_filter/filter_dylib.cpp	2007-01-06 15:27:38 UTC (rev 2687)
+++ branches/avidemux_2.4_branch/avidemux/ADM_filter/filter_dylib.cpp	2007-01-06 16:28:30 UTC (rev 2688)
@@ -18,7 +18,12 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#define WIN32_CLASH
+#ifdef CYG_MANGLING
+#include <windows.h> 
+#else
 #include <dlfcn.h>
+#endif
 
 #include <ADM_assert.h>
 
@@ -39,9 +44,18 @@
 #include "ADM_osSupport/ADM_quota.h"
 
 #ifdef CYG_MANGLING
-#define TYPEOFHANDLE HMODULE
+#define TYPEOFHANDLE     HMODULE
+#define OPENLIB(x)       LoadLibrary(x)
+#define CLOSELIB(x)      FreeLibrary(x)
+#define GETSYMBOL(h,x)   GetProcAddress(h,x)
+#define LIBERROR         "error"
+
 #else
-#define TYPEOFHANDLE void*
+#define TYPEOFHANDLE     void*
+#define OPENLIB(x)       dlopen(x,RTLD_NOW)
+#define CLOSELIB(x)      dlclose(x)
+#define GETSYMBOL(h,x)   loadSym(h,x)
+#define LIBERROR         dlerror()
 #endif
 
 
@@ -61,8 +75,11 @@
 void *loadSym(TYPEOFHANDLE handle,const char *sym)
 {
   void *f;
-   
+  #ifdef CYG_MANGLING
+  GetProcAddress(handle, sym);
+  #else
   f=dlsym(handle,sym);
+  #endif
   if(!f) 
   {
     printf("\t Symbold %s not found\n",sym); 
@@ -91,11 +108,7 @@
   ADM_getIntP     *APIVersionP;
   ADM_getIntP     *versionP;
   uint32_t apiV;
-#ifdef CYG_MANGLING
-  #define LOADSYM(x,y,z) if(success && !(f=GetProcAddress(handle,x))) { success=0;}   else {y=(z *)f;}
-#else
-#define LOADSYM(x,y,z) if(success && !(f=loadSym(handle,x))) { success=0;printf("%s",dlerror());}   else {y=(z *)f;}
-#endif
+#define LOADSYM(x,y,z) if(success && !(f=(void *)GETSYMBOL(handle,x))) { success=0;printf("%s",LIBERROR);}   else {y=(z *)f;}
   
     LOADSYM("FILTER_create",        createP,    ADM_createT);
     LOADSYM("FILTER_create_fromscript",createFromScriptP,ADM_create_from_scriptT);
@@ -116,7 +129,7 @@
     
     if(!success)
     {
-      dlclose(handle);
+      CLOSELIB(handle);
       return;
     }
     
@@ -134,9 +147,7 @@
     if(VF_DUMMY!=id)
     {
       printf("This filter(%s) is already registered as %u\n", name,id);
-#ifndef CYG_MANGLING
-      dlclose(handle);
-#endif
+      CLOSELIB(handle);
       return;
     }
 
@@ -169,14 +180,11 @@
   for(int i=0;i<nbFile;i++)
   {
     TYPEOFHANDLE h;
-#ifdef CYG_MANGLING
-    h= LoadLibrary(files[i]);
-#else
-    h=dlopen(files[i],RTLD_NOW);
-#endif
+
+    h=OPENLIB(files[i]);
     if(!h)
     {
-        printf("Dlopened failed for %s er:%s\n",files[i],dlerror());
+        printf("Dlopened failed for %s er:%s\n",files[i],LIBERROR);
         continue;
     }
     tryLoading(h);



From mean at mail.berlios.de  Sun Jan  7 14:26:34 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 7 Jan 2007 14:26:34 +0100
Subject: [Avidemux-svn-commit] r2689 -
	branches/avidemux_2.4_branch/avidemux/ADM_filter
Message-ID: <200701071326.l07DQYFj006081@sheep.berlios.de>

Author: mean
Date: 2007-01-07 14:26:34 +0100 (Sun, 07 Jan 2007)
New Revision: 2689

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_filter/filter_dylib.cpp
Log:
win32 again

Modified: branches/avidemux_2.4_branch/avidemux/ADM_filter/filter_dylib.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_filter/filter_dylib.cpp	2007-01-06 16:28:30 UTC (rev 2688)
+++ branches/avidemux_2.4_branch/avidemux/ADM_filter/filter_dylib.cpp	2007-01-07 13:26:34 UTC (rev 2689)
@@ -49,6 +49,7 @@
 #define CLOSELIB(x)      FreeLibrary(x)
 #define GETSYMBOL(h,x)   GetProcAddress(h,x)
 #define LIBERROR         "error"
+#define LIB_EXTENSION    ".dll"
 
 #else
 #define TYPEOFHANDLE     void*
@@ -56,6 +57,7 @@
 #define CLOSELIB(x)      dlclose(x)
 #define GETSYMBOL(h,x)   loadSym(h,x)
 #define LIBERROR         dlerror()
+#define LIB_EXTENSION    ".so"
 #endif
 
 
@@ -170,7 +172,7 @@
   uint32_t nbFile;
   printf("** Registering dynamic filters (%s) **\n",path);
   memset(files,0,sizeof(char *)*MAX_EXTERNAL_FILTER);
-  if(!buildDirectoryContent(&nbFile,path, files,MAX_EXTERNAL_FILTER,".so"))
+  if(!buildDirectoryContent(&nbFile,path, files,MAX_EXTERNAL_FILTER,LIB_EXTENSION))
   {
       GUI_Error_HIG("External Filter","Loading external filters failed.");
       return 0;



From mean at mail.berlios.de  Sun Jan  7 17:39:07 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 7 Jan 2007 17:39:07 +0100
Subject: [Avidemux-svn-commit] r2690 -
	branches/avidemux_2.4_branch/avidemux/ADM_filter
Message-ID: <200701071639.l07Gd7Be029584@sheep.berlios.de>

Author: mean
Date: 2007-01-07 17:39:06 +0100 (Sun, 07 Jan 2007)
New Revision: 2690

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_filter/filter_dylib.cpp
Log:
win32, to be cleaned up later

Modified: branches/avidemux_2.4_branch/avidemux/ADM_filter/filter_dylib.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_filter/filter_dylib.cpp	2007-01-07 13:26:34 UTC (rev 2689)
+++ branches/avidemux_2.4_branch/avidemux/ADM_filter/filter_dylib.cpp	2007-01-07 16:39:06 UTC (rev 2690)
@@ -15,12 +15,19 @@
  ***************************************************************************/
 #include "config.h"
 
+//#define USE_EDLL
+
+
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #define WIN32_CLASH
 #ifdef CYG_MANGLING
 #include <windows.h> 
+#ifdef USE_EDLL
+#include "edll/edll.h"
+#include "edll/ltdl.h"
+#endif
 #else
 #include <dlfcn.h>
 #endif
@@ -44,53 +51,42 @@
 #include "ADM_osSupport/ADM_quota.h"
 
 #ifdef CYG_MANGLING
+#ifdef USE_EDLL
+#define TYPEOFHANDLE     edll_module *
+#define OPENLIB(x)       edll_open(x)
+#define CLOSELIB(x)      edll_close(x)
+#define GETSYMBOL(h,x)   edll_sym(h,x)
+#define PRINTERROR()     printf("Last error %s (edll) \n",edll_strerror()) 
+#define LIB_EXTENSION    ".aplug"
+#define INIT()		 edll_init()
+#else
 #define TYPEOFHANDLE     HMODULE
 #define OPENLIB(x)       LoadLibrary(x)
 #define CLOSELIB(x)      FreeLibrary(x)
 #define GETSYMBOL(h,x)   GetProcAddress(h,x)
-#define LIBERROR         "error"
+#define PRINTERROR()     printf("Last error %d (%x)\n",GetLastError(),GetLastError()) 
 #define LIB_EXTENSION    ".dll"
-
+#define INIT()
+#endif
 #else
 #define TYPEOFHANDLE     void*
 #define OPENLIB(x)       dlopen(x,RTLD_NOW)
 #define CLOSELIB(x)      dlclose(x)
-#define GETSYMBOL(h,x)   loadSym(h,x)
-#define LIBERROR         dlerror()
+#define GETSYMBOL(h,x)   (void *)dlsym(h,x)
+#define PRINTERROR()     printf("Er:%s\n",dlerror())
 #define LIB_EXTENSION    ".so"
+#define INIT()
 #endif
 
 
 typedef char *(ADM_getStringT)(void);
 
 static void tryLoading(TYPEOFHANDLE handle);
-static void *loadSym(TYPEOFHANDLE handle,const char *sym);
 static uint32_t dynTag=0xF0000000;
 
 
 
 /**
-    \fn  loadSym(void *handle,const char *sym)
-    \brief Get a pointer to the function name given as parameter
-
-*/
-void *loadSym(TYPEOFHANDLE handle,const char *sym)
-{
-  void *f;
-  #ifdef CYG_MANGLING
-  GetProcAddress(handle, sym);
-  #else
-  f=dlsym(handle,sym);
-  #endif
-  if(!f) 
-  {
-    printf("\t Symbold %s not found\n",sym); 
-  }
-  return f;
-  
-}
-
-/**
     \fn  tryLoadin(void *handle)
     \brief try do use the dynlib pointer by handle
 
@@ -110,7 +106,7 @@
   ADM_getIntP     *APIVersionP;
   ADM_getIntP     *versionP;
   uint32_t apiV;
-#define LOADSYM(x,y,z) if(success && !(f=(void *)GETSYMBOL(handle,x))) { success=0;printf("%s",LIBERROR);}   else {y=(z *)f;}
+#define LOADSYM(x,y,z) if(success && !(f=(void *)GETSYMBOL(handle,x))) { success=0;printf("Loading symbol failed for "x"\n");PRINTERROR();}   else {y=(z *)f;}
   
     LOADSYM("FILTER_create",        createP,    ADM_createT);
     LOADSYM("FILTER_create_fromscript",createFromScriptP,ADM_create_from_scriptT);
@@ -171,7 +167,9 @@
   char *files[MAX_EXTERNAL_FILTER];
   uint32_t nbFile;
   printf("** Registering dynamic filters (%s) **\n",path);
+  INIT();
   memset(files,0,sizeof(char *)*MAX_EXTERNAL_FILTER);
+  printf("Searching for files %s\n",LIB_EXTENSION);
   if(!buildDirectoryContent(&nbFile,path, files,MAX_EXTERNAL_FILTER,LIB_EXTENSION))
   {
       GUI_Error_HIG("External Filter","Loading external filters failed.");
@@ -179,19 +177,34 @@
   }
   printf("Found %u candidated\n",nbFile);
   // Try to dyload them
+ #if 1
   for(int i=0;i<nbFile;i++)
   {
     TYPEOFHANDLE h;
-
+	printf("Trying %s\n",files[i]);
     h=OPENLIB(files[i]);
     if(!h)
     {
-        printf("Dlopened failed for %s er:%s\n",files[i],LIBERROR);
+        printf("Dlopened failed for %s \n",files[i]);
+	PRINTERROR();
         continue;
     }
     tryLoading(h);
     
   }
+  #else
+TYPEOFHANDLE h;
+char *u="dummy.aplug";
+    h=OPENLIB(u);
+    if(h)
+    {
+    tryLoading(h);
+    }
+    else 
+        printf("Dlopened failed for %s \n",u);
+    
+
+  #endif
   // Cleanup
   for(int i=0;i<nbFile;i++)
   {



From mean at mail.berlios.de  Sun Jan  7 17:46:00 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 7 Jan 2007 17:46:00 +0100
Subject: [Avidemux-svn-commit] r2691 -
	branches/avidemux_2.4_branch/avidemux/ADM_filter
Message-ID: <200701071646.l07Gk0Ne030377@sheep.berlios.de>

Author: mean
Date: 2007-01-07 17:45:59 +0100 (Sun, 07 Jan 2007)
New Revision: 2691

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_filter/buildummy_win32.sh
Log:
win32 version

Added: branches/avidemux_2.4_branch/avidemux/ADM_filter/buildummy_win32.sh
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_filter/buildummy_win32.sh	2007-01-07 16:39:06 UTC (rev 2690)
+++ branches/avidemux_2.4_branch/avidemux/ADM_filter/buildummy_win32.sh	2007-01-07 16:45:59 UTC (rev 2691)
@@ -0,0 +1,10 @@
+i586-mingw32msvc-g++ -DHAVE_CONFIG_H -I/rot2/include/ -I. -I. -I../..  -I../ADM_libraries -I../ADM_libraries/ADM_utilities -I../ADM_libraries/ADM_lavutil -I/usr/include/libxml2  -I/usr/include/malloc -I/usr/include/libxml2 -I/usr/include/SDL -D_GNU_SOURCE=1 -D_REENTRANT  -I.. -I../ADM_lavutil -IADM_utilities -I../ADM_utilities  -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64 -g -O2 -I../.. -O1 -g3 -falign-loops=16 \
+-c -o dummy.o \
+ADM_vidDummyFilter.cpp  -mno-cygwin -mms-bitfields -mwindows
+
+i586-mingw32msvc-g++ -shared dummy.o -o dummy.dll -L.. \
+    -Wl,--export-all-symbols \
+    -Wl,--enable-auto-import \
+    -mno-cygwin -lmingw32  ../libavidemux2.dll.a
+    #../avidemux2_gtk.exe
+#../avidemux2_gtk.exe.a \



From mean at mail.berlios.de  Sun Jan  7 17:46:53 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 7 Jan 2007 17:46:53 +0100
Subject: [Avidemux-svn-commit] r2692 - branches/avidemux_2.4_branch/avidemux
Message-ID: <200701071646.l07GkrcJ030442@sheep.berlios.de>

Author: mean
Date: 2007-01-07 17:46:53 +0100 (Sun, 07 Jan 2007)
New Revision: 2692

Added:
   branches/avidemux_2.4_branch/avidemux/script_to_build_plugin_on_windows.sh
Log:
win32

Added: branches/avidemux_2.4_branch/avidemux/script_to_build_plugin_on_windows.sh
===================================================================
--- branches/avidemux_2.4_branch/avidemux/script_to_build_plugin_on_windows.sh	2007-01-07 16:45:59 UTC (rev 2691)
+++ branches/avidemux_2.4_branch/avidemux/script_to_build_plugin_on_windows.sh	2007-01-07 16:46:53 UTC (rev 2692)
@@ -0,0 +1,113 @@
+/bin/sh ../libtool --silent --tag=CXX --mode=link i586-mingw32msvc-g++  -I.. -IADM_library -I../ADM_library  -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64 -O -Wnon-virtual-dtor -Wno-long-long -Wundef -Wall -W -Wpointer-arith -Wmissing-prototypes -Wwrite-strings -O2 -mno-cygwin -mms-bitfields -fno-exceptions -fno-check-new -O2   \
+-L/rot2/lib \
+ -mwindows \
+/rot2/lib/libpthreadGC1.a \
+ADM_osSupport/libADM_ossupport.a \
+./ADM_libraries/ADM_lavutil/libADM_lavutil.a \
+./ADM_libraries/ADM_utilities/libADM_library.a \
+ADM_userInterfaces/ADM_GTK/ADM_dialog/libADM_dialog.a \
+ADM_userInterfaces/ADM_GTK/ADM_gui2/libADM_gui2.a \
+ADM_userInterfaces/ADM_GTK/ADM_filters/libADM_filters.a \
+ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk/libADM_toolkit_gtk.a \
+ADM_userInterfaces/ADM_GTK/libADM_GTK.a \
+ ./ADM_libraries/ADM_lavcodec/libavcodec.a  \
+ ./ADM_libraries/ADM_lavcodec/libpostproc/libpostproc.a  \
+./ADM_script/libADM_script.a \
+./ADM_editor/libADM_editor.a \
+./ADM_audiocodec/libADM_audiocodec.a \
+./ADM_audio/libADM_audio.a \
+ ./ADM_outputs/oplug_mp4/liboplug_mp4.a \
+ ./ADM_outputs/oplug_mpeg/liboplug_mpeg.a \
+ ./ADM_outputs/oplug_mpegFF/liboplug_mpegFF.a \
+ ./ADM_outputs/oplug_ogm/liboplug_ogm.a \
+ ./ADM_outputs/oplug_avi/liboplug_avi.a \
+./ADM_requant/libADM_requant.a \
+./ADM_libraries/ADM_lvemux/libADM_lvemux.a \
+./ADM_libraries/ADM_lavformat/libADM_lavformat.a \
+./ADM_libraries/ADM_mplex/libADM_mplex.a \
+./ADM_filter/libADM_filter.a \
+./ADM_video/libADM_video.a \
+  ./ADM_encoder/libADM_encoder.a \
+./ADM_requant/libADM_requant.a \
+./ADM_codecs/libADM_codecs.a \
+ ./ADM_libraries/ADM_libMad/libADM_mad.a \
+ ./ADM_libraries/ADM_liba52/libADM_liba52.a \
+  ./ADM_audiofilter/libADM_audiofilter.a \
+ ./ADM_libraries/ADM_libtwolame/liblibtoolame.a \
+ ./ADM_libraries/ADM_xvidratectl/libADM_xvidratectl.a \
+ ./ADM_libraries/ADM_libmpeg2enc/libmpeg2enc.a  \
+ ./ADM_inputs/ADM_3gp/libADM_3gp.a \
+ ./ADM_inputs/ADM_asf/libADM_asf.a \
+ ./ADM_inputs/ADM_h263/libADM_h263.a \
+ ./ADM_inputs/ADM_inpics/libADM_inpics.a \
+ ./ADM_inputs/ADM_mpegdemuxer/libADM_mpegdemuxer.a \
+ ./ADM_inputs/ADM_nuv/libADM_nuv.a \
+ ./ADM_inputs/ADM_ogm/libADM_ogm.a \
+ ./ADM_inputs/ADM_openDML/libADM_openDML.a \
+ ./ADM_inputs/ADM_avsproxy/libADM_avsproxy.a \
+ ./ADM_inputs/ADM_matroska/libADM_matroska.a \
+ ./ADM_inputs/ADM_mpegdemuxer/libADM_mpegdemuxer.a \
+ ./ADM_libraries/ADM_libMpeg2Dec/liblibMpeg2Dec.a  \
+./ADM_ocr/libADM_ocr.a \
+./ADM_toolkit/libADM_toolkit.a \
+./ADM_colorspace/libADM_colorspace.a \
+ ./ADM_outputs/oplug_ogm/liboplug_ogm.a \
+ ./ADM_libraries/ADM_lavcodec/libavcodec.a  \
+ ./ADM_libraries/ADM_lavcodec/libpostproc/libpostproc.a  \
+/rot2/lib/libx264.dll.a \
+ ./ADM_libraries/ADM_lavutil/libADM_lavutil.a \
+ ./ADM_libraries/ADM_utilities/libADM_library.a \
+ADM_osSupport/libADM_ossupport.a \
+ADM_audiodevice/libADM_audiodevice.a \
+./ADM_libraries/ADM_libass/libass.a \
+ADM_userInterfaces/ADM_GTK/ADM_gui2/libADM_gui2.a \
+ADM_userInterfaces/ADM_GTK/ADM_filters/libADM_filters.a \
+ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk/libADM_toolkit_gtk.a \
+ADM_userInterfaces/ADM_GTK/libADM_GTK.a \
+ADM_userInterfaces/ADM_commonUI/libADM_CommonUI.a \
+ ADM_userInterfaces/ADM_GTK/ADM_dialog/libADM_dialog.a \
+ADM_osSupport/libADM_ossupport.a \
+ ./ADM_libraries/ADM_libswscale/libswscale.a \
+./ADM_ocr/libADM_ocr.a \
+ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk/libADM_toolkit_gtk.a \
+ \
+-lSDLmain  \
+ -lfaac \
+ -lmp3lame \
+ -lxvidcore \
+ -lxml2 \
+ -lfreetype \
+ -lfaad \
+ -liconv \
+ -lgettextpo \
+ -lintl \
+ -logg -lvorbis -lvorbisenc \
+ -laften \
+ -ljs \
+ gui_savenew.o \
+ gui_navigate.o \
+ gtk_gui.o \
+ main.o \
+ guiplay.o \
+ gui_autodrive.o \
+ GUI_jobs.o \
+ xpm/adm.o \
+-lgtk-win32-2.0 -lgdk-win32-2.0 -latk-1.0 -lgdk_pixbuf-2.0 -lpangowin32-1.0 -lgdi32 -lpango-1.0 -lgobject-2.0 -lgmodule-2.0 -lglib-2.0 -lgthread-2.0 \
+-lpng13 \
+  -lzdll \
+ -lpthreadGC1 \
+  -lnspr4 \
+  -lfontconfig \
+  -lmingw32 \
+ -lwinmm -lwsock32  \
+ -lSDLmain -lSDL \
+-o avidemux2_gtk.exe  \
+-Wl,--export-all-symbols \
+-Wl,--out-implib=libavidemux2.dll.a \
+    -Wl,--enable-auto-import \
+    -mno-cygwin 
+
+
+
+ #/rot/lib/libfaac.a \
+


Property changes on: branches/avidemux_2.4_branch/avidemux/script_to_build_plugin_on_windows.sh
___________________________________________________________________
Name: svn:executable
   + *



From mean at mail.berlios.de  Mon Jan  8 20:31:30 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Mon, 8 Jan 2007 20:31:30 +0100
Subject: [Avidemux-svn-commit] r2693 - in
	branches/avidemux_2.4_branch/avidemux: ADM_userInterfaces/ADM_GTK
	ADM_userInterfaces/ADM_GTK/ADM_dialogFactory
	ADM_userInterfaces/ADM_commonUI ADM_video
Message-ID: <200701081931.l08JVU5d001320@sheep.berlios.de>

Author: mean
Date: 2007-01-08 20:31:30 +0100 (Mon, 08 Jan 2007)
New Revision: 2693

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/DIA_dialogFactory.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/FAC_toggle.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/Makefile.am
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_factory.h
Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/Makefile.am
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFastConvolution.cpp
Log:
Dialog factory

Added: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/DIA_dialogFactory.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/DIA_dialogFactory.cpp	2007-01-07 16:46:53 UTC (rev 2692)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/DIA_dialogFactory.cpp	2007-01-08 19:31:30 UTC (rev 2693)
@@ -0,0 +1,135 @@
+/***************************************************************************
+  DIA_dialogFactory.cpp
+  (C) 2006 Mean Fixounet at free.fr 
+***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include <config.h>
+
+
+#include <string.h>
+#include <stdio.h>
+#include <math.h>
+
+#include "default.h"
+#include "ADM_toolkit_gtk/ADM_gladeSupport.h"
+#include "ADM_toolkit_gtk/toolkit_gtk.h"
+#include "ADM_toolkit_gtk/toolkit_gtk_include.h"
+#include "ADM_commonUI/DIA_factory.h"
+#include "ADM_assert.h"
+
+
+/**
+    \fn addLine(diaElem *elem, GtkDialog *dialog, GtkWidget *vbox)
+    \brief setup an line with the element given as parameter
+    @return nothing
+
+*/
+void addLine(diaElem *elem, GtkWidget *dialog, GtkWidget *vbox)
+{
+  switch(elem->mySelf)
+  {
+    case ELEM_TOGGLE:
+        {
+            diaElemToggle *toggle=(diaElemToggle *)elem;
+            toggle->setMe( (void *)dialog,(void *)vbox);
+        }
+        break;
+    default:
+        ADM_assert(0);  
+  }
+}
+/**
+    \fn getLine(diaElem *elem, GtkDialog *dialog, GtkWidget *vbox)
+    \brief read back an line with the element given as parameter
+    @return nothing
+
+*/
+void getLine(diaElem *elem, GtkWidget *dialog, GtkWidget *vbox)
+{
+  switch(elem->mySelf)
+  {
+    case ELEM_TOGGLE:
+        {
+            diaElemToggle *toggle=(diaElemToggle *)elem;
+            toggle->getMe();
+        }
+        break;
+    default:
+        ADM_assert(0);  
+  }
+}
+/**
+    \fn diaFactoryRun(const char *title,uint32_t nb,diaElem **elems)
+    \brief  Run a dialog made of nb elems, each elem being described in the **elems
+    @return 0 on failure, 1 on success
+*/
+
+uint8_t diaFactoryRun(const char *title,uint32_t nb,diaElem **elems)
+{
+  uint8_t ret=0;
+  ADM_assert(elems);
+  ADM_assert(nb);
+  ADM_assert(title);
+  
+  /* First there was a dialog ...*/
+  GtkWidget *dialog=gtk_dialog_new ();
+  GtkWidget *dialog_vbox1;
+  GtkWidget *vbox1;
+  
+  gtk_window_set_title (GTK_WINDOW (dialog),title );
+  dialog_vbox1 = GTK_DIALOG (dialog)->vbox;
+  gtk_widget_show (dialog_vbox1);
+  
+  vbox1 = gtk_vbox_new (FALSE, 0);
+  gtk_widget_show (vbox1);
+  gtk_box_pack_start (GTK_BOX (dialog_vbox1), vbox1, TRUE, TRUE, 0);
+
+  for(int i=0;i<nb;i++)
+  {
+    addLine(elems[i],dialog,vbox1);
+    
+  }
+  // Add ok & cancel button
+  GtkWidget *cancelbutton1,*okbutton1;
+  
+  cancelbutton1 = gtk_button_new_from_stock ("gtk-cancel");
+  gtk_widget_show (cancelbutton1);
+  gtk_dialog_add_action_widget (GTK_DIALOG (dialog), cancelbutton1, GTK_RESPONSE_CANCEL);
+  GTK_WIDGET_SET_FLAGS (cancelbutton1, GTK_CAN_DEFAULT);
+
+  okbutton1 = gtk_button_new_from_stock ("gtk-ok");
+  gtk_widget_show (okbutton1);
+  gtk_dialog_add_action_widget (GTK_DIALOG (dialog), okbutton1, GTK_RESPONSE_OK);
+  GTK_WIDGET_SET_FLAGS (okbutton1, GTK_CAN_DEFAULT);
+  
+  // Show it & run
+  gtk_register_dialog(dialog);
+  if(GTK_RESPONSE_OK==gtk_dialog_run(GTK_DIALOG(dialog)))
+  {
+    for(int i=0;i<nb;i++)
+      {
+        getLine(elems[i],dialog,vbox1);
+        
+      }
+    ret=1;  
+  }
+
+  // Cleanup
+  gtk_unregister_dialog(dialog);
+  gtk_widget_destroy(dialog);
+  return ret;
+  
+}
+
+
+
+//EOF

Added: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/FAC_toggle.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/FAC_toggle.cpp	2007-01-07 16:46:53 UTC (rev 2692)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/FAC_toggle.cpp	2007-01-08 19:31:30 UTC (rev 2693)
@@ -0,0 +1,63 @@
+/***************************************************************************
+  FAC_toggle.cpp
+  Handle dialog factory element : Toggle
+  (C) 2006 Mean Fixounet at free.fr 
+***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include <config.h>
+
+
+#include <string.h>
+#include <stdio.h>
+#include <math.h>
+
+#include "default.h"
+#include "ADM_toolkit_gtk/ADM_gladeSupport.h"
+#include "ADM_toolkit_gtk/toolkit_gtk.h"
+#include "ADM_toolkit_gtk/toolkit_gtk_include.h"
+#include "ADM_commonUI/DIA_factory.h"
+#include "ADM_assert.h"
+
+
+
+
+diaElemToggle::diaElemToggle(uint32_t *toggleValue,const char *toggleTitle, const char *tip)
+  : diaElem(ELEM_TOGGLE)
+{
+  param=(void *)toggleValue;
+  paramTitle=toggleTitle;
+  this->tip=tip;
+}
+
+diaElemToggle::~diaElemToggle()
+{
+  
+}
+void diaElemToggle::setMe(void *dialog, void *opaque)
+{
+  GtkWidget *widget;
+  
+  widget = gtk_check_button_new_with_mnemonic (paramTitle);
+  gtk_widget_show (widget);
+  myWidget=(void *)widget;
+  gtk_box_pack_start (GTK_BOX (opaque), widget, FALSE, FALSE, 0);
+  gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (widget), *(uint32_t *)param);
+}
+void diaElemToggle::getMe(void)
+{
+  GtkWidget *widget=(GtkWidget *)myWidget;
+  uint32_t *val=(uint32_t *)param;
+  ADM_assert(widget);
+  *(uint32_t *)param=gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (widget));
+}
+
+//EOF

Added: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/Makefile.am	2007-01-07 16:46:53 UTC (rev 2692)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/Makefile.am	2007-01-08 19:31:30 UTC (rev 2693)
@@ -0,0 +1,13 @@
+
+noinst_LIBRARIES = libADM_dialogFactory.a 
+
+INCLUDES = $(all_includes) $(GTK_CFLAGS) $(XML_CFLAGS)  $(FREETYPE_CFLAGS) -DADM_SUBVERSION=@ADM_SUBVERSION@ \
+		-I../../../ADM_libraries/ADM_utilities \
+		-I../../ADM_commonUI -I../../.. -I../../../ADM_libraries/ADM_lavutil \
+		-I../../../ADM_inputs -I../../../ADM_outputs
+
+libADM_dialogFactory_a_METASOURCES = AUTO
+
+libADM_dialogFactory_a_SOURCES = DIA_dialogFactory.cpp FAC_toggle.cpp
+
+

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/Makefile.am	2007-01-07 16:46:53 UTC (rev 2692)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/Makefile.am	2007-01-08 19:31:30 UTC (rev 2693)
@@ -1,4 +1,4 @@
-SUBDIRS= ADM_dialog  ADM_gui2 ADM_toolkit_gtk ADM_filters
+SUBDIRS= ADM_dialog  ADM_gui2 ADM_toolkit_gtk ADM_filters ADM_dialogFactory
 
 noinst_LIBRARIES = libADM_GTK.a 
 libADM_GTK_a_METASOURCES = AUTO

Added: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_factory.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_factory.h	2007-01-07 16:46:53 UTC (rev 2692)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_factory.h	2007-01-08 19:31:30 UTC (rev 2693)
@@ -0,0 +1,54 @@
+/***************************************************************************
+                          DIA_factory.h
+  Handles univeral dialog
+  (C) Mean 2006 fixounet at free.fr
+
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef DIA_FACTORY_H
+#define DIA_FACTORY_H
+
+typedef enum elemEnum
+{
+  ELEM_INVALID=0,
+  ELEM_TOGGLE,
+  ELEM_MAX=ELEM_TOGGLE
+};
+
+class diaElem
+{
+
+public:
+  void *param;
+  void *myWidget;
+  const char *paramTitle;
+  const char *tip;
+  elemEnum mySelf;
+
+  diaElem(elemEnum num) {param=NULL;mySelf=num;myWidget=NULL;};
+  virtual ~diaElem() {};
+  virtual void setMe(void *dialog, void *opaque)=0;
+  virtual void getMe(void)=0;
+};
+
+class diaElemToggle : public diaElem
+{
+
+public:
+  diaElemToggle(uint32_t *toggleValue,const char *toggleTitle, const char *tip=NULL);
+  virtual ~diaElemToggle() ;
+  void setMe(void *dialog, void *opaque);
+  void getMe(void);
+};
+
+uint8_t diaFactoryRun(const char *title,uint32_t nb,diaElem **elems);
+
+#endif

Modified: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFastConvolution.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFastConvolution.cpp	2007-01-07 16:46:53 UTC (rev 2692)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFastConvolution.cpp	2007-01-08 19:31:30 UTC (rev 2693)
@@ -26,7 +26,7 @@
 #include "ADM_video/ADM_genvideo.hxx"
 
 #include"ADM_video/ADM_vidConvolution.hxx"
-
+#include "ADM_userInterfaces/ADM_commonUI/DIA_factory.h"
 #include <ADM_assert.h>
 
 
@@ -455,7 +455,13 @@
 uint8_t AVDMFastVideoConvolution::configure(AVDMGenericVideoStream * instream)
 {
   
-  return DIA_getLumaChroma(&(_param->luma),&(_param->chroma)) ; 
+  //return DIA_getLumaChroma(&(_param->luma),&(_param->chroma)) ; 
+  diaElemToggle luma(&(_param->luma),"Process luma","Process luma plane");
+  diaElemToggle chroma(&(_param->chroma),"Process chroma");
+  
+  diaElem *elems[2]={&luma,&chroma};
+  
+  return diaFactoryRun("Fast Convolution",2,elems);
 }
 
 



From mean at mail.berlios.de  Mon Jan  8 20:35:28 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Mon, 8 Jan 2007 20:35:28 +0100
Subject: [Avidemux-svn-commit] r2694 - branches/avidemux_2.4_branch/avidemux
Message-ID: <200701081935.l08JZS3o001648@sheep.berlios.de>

Author: mean
Date: 2007-01-08 20:35:28 +0100 (Mon, 08 Jan 2007)
New Revision: 2694

Modified:
   branches/avidemux_2.4_branch/avidemux/Makefile.am
Log:
oops

Modified: branches/avidemux_2.4_branch/avidemux/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/Makefile.am	2007-01-08 19:31:30 UTC (rev 2693)
+++ branches/avidemux_2.4_branch/avidemux/Makefile.am	2007-01-08 19:35:28 UTC (rev 2694)
@@ -20,6 +20,7 @@
 user_interface_gtk = ./ADM_userInterfaces/ADM_GTK/ADM_gui2/libADM_gui2.a	\
 		./ADM_userInterfaces/ADM_GTK/libADM_GTK.a \
 		./ADM_userInterfaces/ADM_GTK/ADM_dialog/libADM_dialog.a	\
+		./ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/libADM_dialogFactory.a	\
 		./ADM_userInterfaces/ADM_commonUI/libADM_CommonUI.a	\
 		./ADM_userInterfaces/ADM_GTK/ADM_filters/libADM_filters.a \
 		./ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk/libADM_toolkit_gtk.a	



From mean at mail.berlios.de  Mon Jan  8 21:19:15 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Mon, 8 Jan 2007 21:19:15 +0100
Subject: [Avidemux-svn-commit] r2695 - in
	branches/avidemux_2.4_branch/avidemux: ADM_codecs
	ADM_inputs/ADM_openDML
Message-ID: <200701082019.l08KJFFg006387@sheep.berlios.de>

Author: mean
Date: 2007-01-08 21:19:14 +0100 (Mon, 08 Jan 2007)
New Revision: 2695

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_ffmp43.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_openDML/ADM_openDML.cpp
Log:
fix flags issues

Modified: branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_ffmp43.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_ffmp43.cpp	2007-01-08 19:35:28 UTC (rev 2694)
+++ branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_ffmp43.cpp	2007-01-08 20:19:14 UTC (rev 2695)
@@ -71,9 +71,7 @@
 
 uint8_t decoderFF::clonePic (AVFrame * src, ADMImage * out)
 {
-  uint32_t
-    u,
-    v;
+  uint32_t    u,v;
   out->_planes[0] = (uint8_t *) src->data[0];
   out->_planeStride[0] = src->linesize[0];
   if (_swapUV)
@@ -109,7 +107,7 @@
       out->_qSize = out->_qStride = 0;
       out->quant = NULL;
     }
-
+  out->demuxerFrameno=(uint32_t) (uint64_t)(src->opaque);
 }
 void
 decoderFF::decoderMultiThread (void)
@@ -334,7 +332,9 @@
       }
       return 1;
     }
-
+  
+  _frame.opaque=(void *)in->demuxerFrameNo;
+  
   ret = avcodec_decode_video (_context, &_frame, &got_picture, in->data, in->dataLength);
   out->_qStride = 0;		//Default = no quant
   if (0 > ret && !_context->hurry_up)
@@ -417,10 +417,15 @@
       printf ("\n Unhandled colorspace:%d\n", _context->pix_fmt);
       return 0;
     }
-  clonePic (&_frame, out);
+    clonePic (&_frame, out);
+    printf("Frame bitstream order : %u, display order %u Incoming :%u outgoing :%u\n",_frame.coded_picture_number,_frame.display_picture_number,
+         in->demuxerFrameNo,out->demuxerFrameno);
+    printf("in flags :%x out flags :%x\n",in->flags, out->flags);
+  
   return 1;
 }
 
+#define LOWDELAY() _context->flags |= CODEC_FLAG_LOW_DELAY
 
 
 decoderFFDiv3::decoderFFDiv3 (uint32_t w, uint32_t h):decoderFF (w, h)
@@ -431,8 +436,7 @@
 decoderFFMpeg4VopPacked::decoderFFMpeg4VopPacked (uint32_t w, uint32_t h):decoderFF (w,
 	   h)
 {
-// force low delay as avidemux don't handle B-frames
-
+/* In that case, we cannot use lowdelay...*/
   _refCopy = 1;			// YUV420 only
   _allowNull = 1;
   decoderMultiThread ();
@@ -442,8 +446,9 @@
 	   h)
 {
 // force low delay as avidemux don't handle B-frames
+  LOWDELAY();
   printf ("Using %d bytes of extradata for MPEG4 decoder\n", l);
-  _context->flags |= CODEC_FLAG_LOW_DELAY;
+  
   _refCopy = 1;			// YUV420 only
   _context->extradata = (void *) d;
   _context->extradata_size = (int) l;
@@ -470,7 +475,7 @@
 {
   int
     got_picture = 0;
-  _context->flags |= CODEC_FLAG_LOW_DELAY;
+  LOWDELAY();
   _refCopy = 1;			// YUV420 only
   decoderMultiThread ();
   WRAP_Open (CODEC_ID_MPEG2VIDEO);
@@ -481,7 +486,7 @@
   int
     got_picture = 0;
 
-  _context->flags |= CODEC_FLAG_LOW_DELAY;
+  LOWDELAY();
   _context->extradata = (void *) extraData;
   _context->extradata_size = (int) extraLen;
   WRAP_Open (CODEC_ID_SVQ3);
@@ -515,7 +520,7 @@
   _context->extradata = (void *) d;
   _context->extradata_size = (int) l;
   if(lowdelay)
-    _context->flags |= CODEC_FLAG_LOW_DELAY;
+    LOWDELAY();
   printf ("Initializing lavcodec H264 decoder with %d extradata\n", l);
   WRAP_Open (CODEC_ID_H264);
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_openDML/ADM_openDML.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_openDML/ADM_openDML.cpp	2007-01-08 19:35:28 UTC (rev 2694)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_openDML/ADM_openDML.cpp	2007-01-08 20:19:14 UTC (rev 2695)
@@ -97,13 +97,14 @@
 // 	if(_recHack)
 // 	{
 // 		offset=4+4+4;
-// 	}
+// 	} odmlIndex
 // 	
 	
 	
  	fseeko(_fd,offset,SEEK_SET);
  	fread(img->data, _idx[framenum].size, 1, _fd);
   	img->dataLength=_idx[framenum].size;
+        img->flags=_idx[framenum].intra;
 	aprintf("Size: %lu\n",_idx[framenum].size);
 //	if(offset & 1) printf("odd!\n");
  	return 1;



From mean at mail.berlios.de  Mon Jan  8 22:29:24 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Mon, 8 Jan 2007 22:29:24 +0100
Subject: [Avidemux-svn-commit] r2696 - in
	branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces:
	ADM_NONE ADM_NONE/ADM_dialogFactory ADM_QT4
	ADM_QT4/ADM_dialogFactory
Message-ID: <200701082129.l08LTOSi014474@sheep.berlios.de>

Author: mean
Date: 2007-01-08 22:29:24 +0100 (Mon, 08 Jan 2007)
New Revision: 2696

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialogFactory/
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialogFactory/DIA_dialogFactory.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialogFactory/FAC_toggle.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialogFactory/Makefile.am
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/DIA_dialogFactory.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/FAC_toggle.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/Makefile.am
Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/Makefile.am
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/Makefile.am
Log:
stub for dialogFactory

Added: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialogFactory/DIA_dialogFactory.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialogFactory/DIA_dialogFactory.cpp	2007-01-08 20:19:14 UTC (rev 2695)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialogFactory/DIA_dialogFactory.cpp	2007-01-08 21:29:24 UTC (rev 2696)
@@ -0,0 +1,40 @@
+/***************************************************************************
+  DIA_dialogFactory.cpp
+  (C) 2006 Mean Fixounet at free.fr 
+***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include <config.h>
+
+
+#include <string.h>
+#include <stdio.h>
+#include <math.h>
+
+#include "default.h"
+#include "ADM_commonUI/DIA_factory.h"
+#include "ADM_assert.h"
+
+/**
+    \fn diaFactoryRun(const char *title,uint32_t nb,diaElem **elems)
+    \brief  Run a dialog made of nb elems, each elem being described in the **elems
+    @return 0 on failure, 1 on success
+*/
+
+uint8_t diaFactoryRun(const char *title,uint32_t nb,diaElem **elems)
+{
+  return 0;
+  
+}
+
+
+
+//EOF

Added: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialogFactory/FAC_toggle.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialogFactory/FAC_toggle.cpp	2007-01-08 20:19:14 UTC (rev 2695)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialogFactory/FAC_toggle.cpp	2007-01-08 21:29:24 UTC (rev 2696)
@@ -0,0 +1,46 @@
+/***************************************************************************
+  FAC_toggle.cpp
+  Handle dialog factory element : Toggle
+  (C) 2006 Mean Fixounet at free.fr 
+***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include <config.h>
+
+
+#include <string.h>
+#include <stdio.h>
+#include <math.h>
+
+#include "default.h"
+#include "ADM_commonUI/DIA_factory.h"
+#include "ADM_assert.h"
+
+
+
+
+diaElemToggle::diaElemToggle(uint32_t *toggleValue,const char *toggleTitle, const char *tip)
+  : diaElem(ELEM_TOGGLE)
+{
+}
+
+diaElemToggle::~diaElemToggle()
+{
+  
+}
+void diaElemToggle::setMe(void *dialog, void *opaque)
+{
+}
+void diaElemToggle::getMe(void)
+{
+}
+
+//EOF

Added: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialogFactory/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialogFactory/Makefile.am	2007-01-08 20:19:14 UTC (rev 2695)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialogFactory/Makefile.am	2007-01-08 21:29:24 UTC (rev 2696)
@@ -0,0 +1,13 @@
+
+noinst_LIBRARIES = libADM_dialogFactory.a 
+
+INCLUDES = $(all_includes) $(GTK_CFLAGS) $(XML_CFLAGS)  $(FREETYPE_CFLAGS) -DADM_SUBVERSION=@ADM_SUBVERSION@ \
+		-I../../../ADM_libraries/ADM_utilities \
+		-I../../ADM_commonUI -I../../.. -I../../../ADM_libraries/ADM_lavutil \
+		-I../../../ADM_inputs -I../../../ADM_outputs
+
+libADM_dialogFactory_a_METASOURCES = AUTO
+
+libADM_dialogFactory_a_SOURCES = DIA_dialogFactory.cpp FAC_toggle.cpp
+
+

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/Makefile.am	2007-01-08 20:19:14 UTC (rev 2695)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/Makefile.am	2007-01-08 21:29:24 UTC (rev 2696)
@@ -1,2 +1,2 @@
-SUBDIRS= ADM_dialog  ADM_gui2  ADM_filters
+SUBDIRS= ADM_dialog  ADM_gui2  ADM_filters ADM_dialogFactory
 

Added: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/DIA_dialogFactory.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/DIA_dialogFactory.cpp	2007-01-08 20:19:14 UTC (rev 2695)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/DIA_dialogFactory.cpp	2007-01-08 21:29:24 UTC (rev 2696)
@@ -0,0 +1,40 @@
+/***************************************************************************
+  DIA_dialogFactory.cpp
+  (C) 2006 Mean Fixounet at free.fr 
+***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include <config.h>
+
+
+#include <string.h>
+#include <stdio.h>
+#include <math.h>
+
+#include "default.h"
+#include "ADM_commonUI/DIA_factory.h"
+#include "ADM_assert.h"
+
+/**
+    \fn diaFactoryRun(const char *title,uint32_t nb,diaElem **elems)
+    \brief  Run a dialog made of nb elems, each elem being described in the **elems
+    @return 0 on failure, 1 on success
+*/
+
+uint8_t diaFactoryRun(const char *title,uint32_t nb,diaElem **elems)
+{
+  return 0;
+  
+}
+
+
+
+//EOF

Added: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/FAC_toggle.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/FAC_toggle.cpp	2007-01-08 20:19:14 UTC (rev 2695)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/FAC_toggle.cpp	2007-01-08 21:29:24 UTC (rev 2696)
@@ -0,0 +1,46 @@
+/***************************************************************************
+  FAC_toggle.cpp
+  Handle dialog factory element : Toggle
+  (C) 2006 Mean Fixounet at free.fr 
+***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include <config.h>
+
+
+#include <string.h>
+#include <stdio.h>
+#include <math.h>
+
+#include "default.h"
+#include "ADM_commonUI/DIA_factory.h"
+#include "ADM_assert.h"
+
+
+
+
+diaElemToggle::diaElemToggle(uint32_t *toggleValue,const char *toggleTitle, const char *tip)
+  : diaElem(ELEM_TOGGLE)
+{
+}
+
+diaElemToggle::~diaElemToggle()
+{
+  
+}
+void diaElemToggle::setMe(void *dialog, void *opaque)
+{
+}
+void diaElemToggle::getMe(void)
+{
+}
+
+//EOF

Added: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/Makefile.am	2007-01-08 20:19:14 UTC (rev 2695)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/Makefile.am	2007-01-08 21:29:24 UTC (rev 2696)
@@ -0,0 +1,13 @@
+
+noinst_LIBRARIES = libADM_dialogFactory.a 
+
+INCLUDES = $(all_includes) $(GTK_CFLAGS) $(XML_CFLAGS)  $(FREETYPE_CFLAGS) -DADM_SUBVERSION=@ADM_SUBVERSION@ \
+		-I../../../ADM_libraries/ADM_utilities \
+		-I../../ADM_commonUI -I../../.. -I../../../ADM_libraries/ADM_lavutil \
+		-I../../../ADM_inputs -I../../../ADM_outputs
+
+libADM_dialogFactory_a_METASOURCES = AUTO
+
+libADM_dialogFactory_a_SOURCES = DIA_dialogFactory.cpp FAC_toggle.cpp
+
+

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/Makefile.am	2007-01-08 20:19:14 UTC (rev 2695)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/Makefile.am	2007-01-08 21:29:24 UTC (rev 2696)
@@ -1,4 +1,4 @@
-SUBDIRS= ADM_dialog  ADM_gui  ADM_filters
+SUBDIRS= ADM_dialog  ADM_gui  ADM_filters ADM_dialogFactory
 #SUBDIRS= ADM_gui  
 
 qclean:



From mean at mail.berlios.de  Tue Jan  9 20:54:43 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 9 Jan 2007 20:54:43 +0100
Subject: [Avidemux-svn-commit] r2697 - in
	branches/avidemux_2.4_branch/avidemux: .
	ADM_userInterfaces/ADM_GTK/ADM_dialog
	ADM_userInterfaces/ADM_GTK/ADM_dialogFactory
	ADM_userInterfaces/ADM_NONE/ADM_dialogFactory
	ADM_userInterfaces/ADM_QT4/ADM_dialogFactory
	ADM_userInterfaces/ADM_commonUI ADM_video ADM_videoFilter
Message-ID: <200701091954.l09Jshjm014040@sheep.berlios.de>

Author: mean
Date: 2007-01-09 20:54:42 +0100 (Tue, 09 Jan 2007)
New Revision: 2697

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/FAC_float.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidAddBorder.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidAddBorder.h
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidBSmear.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidFastConvolution.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidFlux.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidFlux.h
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMsmooth.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am
Removed:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_BSMear.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_Msmooth.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_clean.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_guiAddBorder.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_guiBSMear.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidAddBorder.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidAddBorder.h
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidBSmear.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFastConvolution.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFlux.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFlux.h
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMsmooth.cpp
Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/DIA_dialogFactory.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/FAC_toggle.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/Makefile.am
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialogFactory/FAC_toggle.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/FAC_toggle.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_factory.h
   branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am
   branches/avidemux_2.4_branch/avidemux/Makefile.am
Log:
enhance dialogFactory

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_BSMear.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_BSMear.cpp	2007-01-08 21:29:24 UTC (rev 2696)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_BSMear.cpp	2007-01-09 19:54:42 UTC (rev 2697)
@@ -1,28 +0,0 @@
-/***************************************************************************
-                          DIA_BSMear.cpp  -  description
-                             -------------------
-
-			    GUI for cropping including autocrop
-			    +Revisted the Gtk2 way
-			     +Autocrop now in RGB space (more accurate)
-
-    begin                : Fri May 3 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-
-// Empty
-void dummy_empty_bs( void )
-{
-
-}
\ No newline at end of file

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_Msmooth.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_Msmooth.cpp	2007-01-08 21:29:24 UTC (rev 2696)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_Msmooth.cpp	2007-01-09 19:54:42 UTC (rev 2697)
@@ -1,210 +0,0 @@
-//
-// C++ Implementation: DIA_Msmooth
-//
-// Description: 
-//
-//
-// Author: mean <fixounet at free.fr>, (C) 2004
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-//
-// C++ Implementation: DIA_decimate
-//
-// Description: 
-//
-//
-// Author: mean <fixounet at free.fr>, (C) 2004
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-//
-// C++ Implementation: DIA_dectel
-//
-// Description: 
-//
-//
-// Author: mean <fixounet at free.fr>, (C) 2004
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-
-
-#include <config.h>
-
-
-#include <string.h>
-#include <stdio.h>
-
-# include <math.h>
-
-#include "default.h"
-#include "ADM_toolkit_gtk/toolkit_gtk_include.h"
-#include "ADM_toolkit_gtk/ADM_gladeSupport.h"
-#include "ADM_toolkit_gtk/toolkit_gtk.h"
-
-#include "ADM_video/ADM_vidMSmooth_param.h"
-static GtkWidget	*create_dialog1 (void);
-#define SPIN_GET(x,y) {param->y= gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(WID(x))) ;}
-#define SPIN_SET(x,y)  {gtk_spin_button_set_value(GTK_SPIN_BUTTON(WID(x)),(gfloat)param->y) ;}
-#define CHECK_GET(x,y) {param->y=gtk_toggle_button_get_active( GTK_TOGGLE_BUTTON(WID(x)));}
-#define CHECK_SET(x,y) {gtk_toggle_button_set_active( GTK_TOGGLE_BUTTON(WID(x)),param->y);}	
-uint8_t DIA_getMSmooth(MSMOOTH_PARAM *param);
-uint8_t DIA_getMSmooth(MSMOOTH_PARAM *param)
-{
-GtkWidget *dialog;
-int ret=0;
-	dialog=create_dialog1();
-	
-	// Update
-	
-	CHECK_SET(checkbuttonHQ,highq);
-	CHECK_SET(checkbuttonShowMask,showmask);
-	
-	SPIN_SET(spinbuttonThresh,threshold);
-	SPIN_SET(spinbuttonStrength,strength);
-	gtk_register_dialog(dialog);
-	
-	if(gtk_dialog_run(GTK_DIALOG(dialog))==GTK_RESPONSE_OK)
-	{
-		CHECK_GET(checkbuttonHQ,highq);
-		CHECK_GET(checkbuttonShowMask,showmask);
-		SPIN_GET(spinbuttonThresh,threshold);
-		SPIN_GET(spinbuttonStrength,strength);		
-		ret=1;
-	
-	}
-        gtk_unregister_dialog(dialog);
-	gtk_widget_destroy(dialog);
-	return ret;
-
-}
-
-//__________________________________
-
-GtkWidget*
-create_dialog1 (void)
-{
-  GtkWidget *dialog1;
-  GtkWidget *dialog_vbox1;
-  GtkWidget *table1;
-  GtkWidget *label1;
-  GtkWidget *label2;
-  GtkWidget *label3;
-  GtkWidget *label4;
-  GtkWidget *checkbuttonHQ;
-  GtkWidget *checkbuttonShowMask;
-  GtkObject *spinbuttonThresh_adj;
-  GtkWidget *spinbuttonThresh;
-  GtkObject *spinbuttonStrength_adj;
-  GtkWidget *spinbuttonStrength;
-  GtkWidget *dialog_action_area1;
-  GtkWidget *cancelbutton1;
-  GtkWidget *okbutton1;
-
-  dialog1 = gtk_dialog_new ();
-  gtk_window_set_title (GTK_WINDOW (dialog1), _("MSmooth settings"));
-
-  dialog_vbox1 = GTK_DIALOG (dialog1)->vbox;
-  gtk_widget_show (dialog_vbox1);
-
-  table1 = gtk_table_new (4, 2, FALSE);
-  gtk_widget_show (table1);
-  gtk_box_pack_start (GTK_BOX (dialog_vbox1), table1, TRUE, TRUE, 0);
-
-  label1 = gtk_label_new (_("High Quality :"));
-  gtk_widget_show (label1);
-  gtk_table_attach (GTK_TABLE (table1), label1, 0, 1, 0, 1,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_label_set_justify (GTK_LABEL (label1), GTK_JUSTIFY_LEFT);
-  gtk_misc_set_alignment (GTK_MISC (label1), 0, 0.5);
-
-  label2 = gtk_label_new (_("Show Mask :"));
-  gtk_widget_show (label2);
-  gtk_table_attach (GTK_TABLE (table1), label2, 0, 1, 1, 2,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_label_set_justify (GTK_LABEL (label2), GTK_JUSTIFY_LEFT);
-  gtk_misc_set_alignment (GTK_MISC (label2), 0, 0.5);
-
-  label3 = gtk_label_new (_("Threshold :"));
-  gtk_widget_show (label3);
-  gtk_table_attach (GTK_TABLE (table1), label3, 0, 1, 2, 3,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_label_set_justify (GTK_LABEL (label3), GTK_JUSTIFY_LEFT);
-  gtk_misc_set_alignment (GTK_MISC (label3), 0, 0.5);
-
-  label4 = gtk_label_new (_("Filter Strength :"));
-  gtk_widget_show (label4);
-  gtk_table_attach (GTK_TABLE (table1), label4, 0, 1, 3, 4,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_label_set_justify (GTK_LABEL (label4), GTK_JUSTIFY_LEFT);
-  gtk_misc_set_alignment (GTK_MISC (label4), 0, 0.5);
-
-  checkbuttonHQ = gtk_check_button_new_with_mnemonic ("");
-  gtk_widget_show (checkbuttonHQ);
-  gtk_table_attach (GTK_TABLE (table1), checkbuttonHQ, 1, 2, 0, 1,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-
-  checkbuttonShowMask = gtk_check_button_new_with_mnemonic ("");
-  gtk_widget_show (checkbuttonShowMask);
-  gtk_table_attach (GTK_TABLE (table1), checkbuttonShowMask, 1, 2, 1, 2,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-
-  spinbuttonThresh_adj = gtk_adjustment_new (1, 0, 100, 1, 10, 10);
-  spinbuttonThresh = gtk_spin_button_new (GTK_ADJUSTMENT (spinbuttonThresh_adj), 1, 0);
-  gtk_widget_show (spinbuttonThresh);
-  gtk_table_attach (GTK_TABLE (table1), spinbuttonThresh, 1, 2, 2, 3,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (spinbuttonThresh), TRUE);
-
-  spinbuttonStrength_adj = gtk_adjustment_new (1, 0, 100, 1, 10, 10);
-  spinbuttonStrength = gtk_spin_button_new (GTK_ADJUSTMENT (spinbuttonStrength_adj), 1, 0);
-  gtk_widget_show (spinbuttonStrength);
-  gtk_table_attach (GTK_TABLE (table1), spinbuttonStrength, 1, 2, 3, 4,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (spinbuttonStrength), TRUE);
-
-  dialog_action_area1 = GTK_DIALOG (dialog1)->action_area;
-  gtk_widget_show (dialog_action_area1);
-  gtk_button_box_set_layout (GTK_BUTTON_BOX (dialog_action_area1), GTK_BUTTONBOX_END);
-
-  cancelbutton1 = gtk_button_new_from_stock ("gtk-cancel");
-  gtk_widget_show (cancelbutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), cancelbutton1, GTK_RESPONSE_CANCEL);
-  GTK_WIDGET_SET_FLAGS (cancelbutton1, GTK_CAN_DEFAULT);
-
-  okbutton1 = gtk_button_new_from_stock ("gtk-ok");
-  gtk_widget_show (okbutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), okbutton1, GTK_RESPONSE_OK);
-  GTK_WIDGET_SET_FLAGS (okbutton1, GTK_CAN_DEFAULT);
-
-  /* Store pointers to all widgets, for use by lookup_widget(). */
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog1, "dialog1");
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_vbox1, "dialog_vbox1");
-  GLADE_HOOKUP_OBJECT (dialog1, table1, "table1");
-  GLADE_HOOKUP_OBJECT (dialog1, label1, "label1");
-  GLADE_HOOKUP_OBJECT (dialog1, label2, "label2");
-  GLADE_HOOKUP_OBJECT (dialog1, label3, "label3");
-  GLADE_HOOKUP_OBJECT (dialog1, label4, "label4");
-  GLADE_HOOKUP_OBJECT (dialog1, checkbuttonHQ, "checkbuttonHQ");
-  GLADE_HOOKUP_OBJECT (dialog1, checkbuttonShowMask, "checkbuttonShowMask");
-  GLADE_HOOKUP_OBJECT (dialog1, spinbuttonThresh, "spinbuttonThresh");
-  GLADE_HOOKUP_OBJECT (dialog1, spinbuttonStrength, "spinbuttonStrength");
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_action_area1, "dialog_action_area1");
-  GLADE_HOOKUP_OBJECT (dialog1, cancelbutton1, "cancelbutton1");
-  GLADE_HOOKUP_OBJECT (dialog1, okbutton1, "okbutton1");
-
-  return dialog1;
-}
-

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_clean.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_clean.cpp	2007-01-08 21:29:24 UTC (rev 2696)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_clean.cpp	2007-01-09 19:54:42 UTC (rev 2697)
@@ -1,207 +0,0 @@
-/***************************************************************************
-                          ADM_guiClean.cpp  -  description
-                             -------------------
-    begin                : Sun Apr 14 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include "config.h"
-
- /*
- * DO NOT EDIT THIS FILE - it is generated by Glade.
- */
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
-#include <math.h>
-
-#include <gtk/gtk.h>
-#include <time.h>
-#include <sys/time.h>
-
-#include <ADM_assert.h>
-#include "fourcc.h"
-#include "avio.hxx"
-#include "avi_vars.h"
-#ifdef HAVE_ENCODER
-
-
-#include "ADM_editor/ADM_edit.hxx"
-#include "ADM_video/ADM_genvideo.hxx"
-#include "ADM_video/ADM_vidClean.h"
-
-
-
-static int getSmoothParams(	uint32_t *w,uint32_t 	*w2);
-static GtkWidget  *create_dialog1 (void);
-
-static GtkObject *blend_adj;
-static GtkObject *radius_adj;
-
-
-
-
-#if 0
-//
-//      Get crop parameters from GUI
-//                         left, right, top, down , initial size
-//
-int getSmoothParams(	uint32_t *radius,uint32_t 	*stre)
-{
-static 	GtkWidget *resi;
-uint32_t 	ir,is;
-int             r=0;
-
-                ir=*radius;
-                is=*stre;
-
-                resi=create_dialog1();
-                gtk_widget_show(resi);
-                gtk_adjustment_set_value( GTK_ADJUSTMENT(blend_adj),(  gdouble  ) is );
-                gtk_adjustment_set_value( GTK_ADJUSTMENT(radius_adj),(  gdouble  ) ir*2 );
-
-                int response;
-                response=gtk_dialog_run(GTK_DIALOG(dialog));
-
-                if(response==GTK_REPLY_OK)
-                {
-                        *radius= (uint32_t)floor(GTK_ADJUSTMENT(radius_adj)->value);
-                        *radius=*radius/2;
-                        *stre=is;
-                        r=1;
-                }
-                gtk_widget_destroy(resi);
-                return r;
-}
-//
-//
-//
-//
-
-
-GtkWidget*
-create_dialog1 (void)
-{
-  GtkWidget *dialog1;
-  GtkWidget *dialog_vbox1;
-  GtkWidget *vbox1;
-  GtkWidget *accellabel1;
-  GtkWidget *hscale1;
-  GtkWidget *label1;
-  GtkWidget *hscale2;
-  GtkWidget *dialog_action_area1;
-  GtkWidget *hbox1;
-  GtkWidget *button_ok;
-  GtkWidget *button_ko;
-  GtkWidget *button_preview;
-
-  dialog1 = gtk_dialog_new ();
-  gtk_object_set_data (GTK_OBJECT (dialog1), "dialog1", dialog1);
-  gtk_window_set_title (GTK_WINDOW (dialog1), "Clean smoother");
-  gtk_window_set_policy (GTK_WINDOW (dialog1), TRUE, TRUE, FALSE);
-   gtk_window_set_modal(GTK_WINDOW(dialog1), TRUE);
-  dialog_vbox1 = GTK_DIALOG (dialog1)->vbox;
-  gtk_object_set_data (GTK_OBJECT (dialog1), "dialog_vbox1", dialog_vbox1);
-
-  gtk_widget_show (dialog_vbox1);
-
-  vbox1 = gtk_vbox_new (FALSE, 0);
-  gtk_widget_ref (vbox1);
-  gtk_object_set_data_full (GTK_OBJECT (dialog1), "vbox1", vbox1,
-                            (GtkDestroyNotify) gtk_widget_unref);
-  gtk_widget_show (vbox1);
-  gtk_box_pack_start (GTK_BOX (dialog_vbox1), vbox1, TRUE, TRUE, 0);
-
-  accellabel1 = gtk_accel_label_new ("Diameter");
-  gtk_widget_ref (accellabel1);
-  gtk_object_set_data_full (GTK_OBJECT (dialog1), "accellabel1", accellabel1,
-                            (GtkDestroyNotify) gtk_widget_unref);
-  gtk_widget_show (accellabel1);
-  gtk_box_pack_start (GTK_BOX (vbox1), accellabel1, FALSE, FALSE, 0);
-
-  radius_adj=gtk_adjustment_new (2, 2, 10, 1, 1, 1);
-
-  hscale1 = gtk_hscale_new (GTK_ADJUSTMENT (radius_adj));
-  gtk_widget_ref (hscale1);
-  gtk_object_set_data_full (GTK_OBJECT (dialog1), "hscale1", hscale1,
-                            (GtkDestroyNotify) gtk_widget_unref);
-  gtk_widget_show (hscale1);
-  gtk_box_pack_start (GTK_BOX (vbox1), hscale1, TRUE, TRUE, 0);
-
-  gtk_scale_set_digits(GTK_SCALE(hscale1),0);
-
-  label1 = gtk_label_new ("Blend amount");
-  gtk_widget_ref (label1);
-  gtk_object_set_data_full (GTK_OBJECT (dialog1), "label1", label1,
-                            (GtkDestroyNotify) gtk_widget_unref);
-  gtk_widget_show (label1);
-  gtk_box_pack_start (GTK_BOX (vbox1), label1, FALSE, FALSE, 0);
-
-  blend_adj= gtk_adjustment_new (1, 1, 10, 1, 1, 1);
-  hscale2 = gtk_hscale_new (GTK_ADJUSTMENT (blend_adj));
-  gtk_widget_ref (hscale2);
-  gtk_object_set_data_full (GTK_OBJECT (dialog1), "hscale2", hscale2,
-                            (GtkDestroyNotify) gtk_widget_unref);
-   gtk_scale_set_digits(GTK_SCALE(hscale2),0);
-
-  gtk_widget_show (hscale2);
-  gtk_box_pack_start (GTK_BOX (vbox1), hscale2, TRUE, TRUE, 0);
-
-  dialog_action_area1 = GTK_DIALOG (dialog1)->action_area;
-  gtk_object_set_data (GTK_OBJECT (dialog1), "dialog_action_area1", dialog_action_area1);
-  gtk_widget_show (dialog_action_area1);
-  gtk_container_set_border_width (GTK_CONTAINER (dialog_action_area1), 10);
-
-  hbox1 = gtk_hbox_new (FALSE, 0);
-  gtk_widget_ref (hbox1);
-  gtk_object_set_data_full (GTK_OBJECT (dialog1), "hbox1", hbox1,
-                            (GtkDestroyNotify) gtk_widget_unref);
-  gtk_widget_show (hbox1);
-  gtk_box_pack_start (GTK_BOX (dialog_action_area1), hbox1, TRUE, TRUE, 0);
-
-  button_ok = gtk_button_new_with_label ("OK");
-  gtk_widget_ref (button_ok);
-  gtk_object_set_data_full (GTK_OBJECT (dialog1), "button_ok", button_ok,
-                            (GtkDestroyNotify) gtk_widget_unref);
-  gtk_widget_show (button_ok);
-  gtk_box_pack_start (GTK_BOX (hbox1), button_ok, FALSE, FALSE, 0);
-
-  button_ko = gtk_button_new_with_label ("Cancel");
-  gtk_widget_ref (button_ko);
-  gtk_object_set_data_full (GTK_OBJECT (dialog1), "button_ko", button_ko,
-                            (GtkDestroyNotify) gtk_widget_unref);
-  gtk_widget_show (button_ko);
-  gtk_box_pack_start (GTK_BOX (hbox1), button_ko, FALSE, FALSE, 0);
-
-  button_preview = gtk_button_new_with_label ("Preview");
-  gtk_widget_ref (button_preview);
-  gtk_object_set_data_full (GTK_OBJECT (dialog1), "button_preview", button_preview,
-                            (GtkDestroyNotify) gtk_widget_unref);
-  gtk_widget_show (button_preview);
-  gtk_box_pack_start (GTK_BOX (hbox1), button_preview, TRUE, FALSE, 0);
-
-  gtk_signal_connect (GTK_OBJECT (button_ok), "clicked",
-                      GTK_SIGNAL_FUNC (gui_ok),
-                      (void *)1);
-  gtk_signal_connect (GTK_OBJECT (button_ko), "clicked",
-                      GTK_SIGNAL_FUNC (gui_ok),
-                      (void *)0);
-
-
-
-  return dialog1;
-}
-
-#endif
-#endif 
-

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am	2007-01-08 21:29:24 UTC (rev 2696)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am	2007-01-09 19:54:42 UTC (rev 2697)
@@ -14,14 +14,13 @@
 	DIA_working.h DIA_busy.cpp DIA_busy.h DIA_exLame.cpp DIA_pipe.cpp DIA_mpeg2opt.cpp \
 	DIA_d3d.cpp DIA_postproc.cpp DIA_enter.cpp DIA_enter.h DIA_xvcd.cpp DIA_muxer.cpp \
 	DIA_xvid.cpp DIA_crop.cpp DIA_color.cpp DIA_encoding.cpp DIA_SVCD.cpp DIA_prefs.cpp \
-	DIA_requant.cpp DIA_xvid4.cpp DIA_lavcodec.cpp DIA_kerneldeint.cpp DIA_BSMear.cpp \
-	DIA_audiodevice.cpp DIA_dectel.cpp DIA_decimate.cpp DIA_Msmooth.cpp DIA_pause.cpp \
+	DIA_requant.cpp DIA_xvid4.cpp DIA_lavcodec.cpp DIA_kerneldeint.cpp \
+	DIA_audiodevice.cpp DIA_dectel.cpp DIA_decimate.cpp DIA_pause.cpp \
 	DIA_DVDff.cpp DIA_lavdecoder.cpp DIA_lame.cpp DIA_calculator.cpp DIA_equalizer.cpp \
 	DIA_vobsub.cpp DIA_x264.cpp DIA_ocr.cpp DIA_lavpp_deint.cpp DIA_hue.cpp DIA_eq2.cpp \
 	DIA_dgbob.cpp DIA_msharpen.cpp DIA_asharp.cpp DIA_dmx.cpp DIA_idx_pg.cpp DIA_gototime.cpp \
 	DIA_audioTrack.cpp DIA_cnr2.cpp DIA_resizeWiz.cpp DIA_jobs.cpp DIA_jobs_save.cpp DIA_mosaic.cpp \
 	DIA_deblend.cpp DIA_v2v.cpp DIA_tdeint.cpp DIA_builtin.cpp DIA_mpdelogo.cpp DIA_vorbis.cpp \
-	DIA_clean.cpp \
         DIA_chromaShift.cpp \
         DIA_denoise.cpp \
         DIA_preview.cpp \
@@ -41,11 +40,11 @@
 
 
 
-EXTRA_DIST =  DIA_4entries.cpp     DIA_clean.cpp         DIA_enter.cpp     \
+EXTRA_DIST =  DIA_4entries.cpp              DIA_enter.cpp     \
 DIA_mcdeint.cpp     DIA_resize.cpp \
-DIA_BSMear.cpp       DIA_cnr2.cpp          DIA_enter.h          DIA_mjpeg.cpp       DIA_resizeWiz.cpp \
+DIA_cnr2.cpp          DIA_enter.h          DIA_mjpeg.cpp       DIA_resizeWiz.cpp \
 DIA_DVDff.cpp        DIA_color.cpp         DIA_eq2.cpp          DIA_mosaic.cpp      DIA_resizeWiz.h \
-DIA_Msmooth.cpp      DIA_coloryuv.cpp      DIA_equalizer.cpp    DIA_mpdelogo.cpp    DIA_rotate.cpp \
+DIA_coloryuv.cpp      DIA_equalizer.cpp    DIA_mpdelogo.cpp    DIA_rotate.cpp \
 DIA_SVCD.cpp         DIA_contrast.cpp      DIA_exLame.cpp       DIA_mpeg2opt.cpp    DIA_srt.cpp \
 DIA_about.cpp        DIA_conv.cpp          DIA_fade.cpp         DIA_msharpen.cpp    DIA_tdeint.cpp \
 DIA_acodec.cpp       DIA_crop.cpp          DIA_gototime.cpp     DIA_muxer.cpp       DIA_v2v.cpp \

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/DIA_dialogFactory.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/DIA_dialogFactory.cpp	2007-01-08 21:29:24 UTC (rev 2696)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/DIA_dialogFactory.cpp	2007-01-09 19:54:42 UTC (rev 2697)
@@ -33,19 +33,10 @@
     @return nothing
 
 */
-void addLine(diaElem *elem, GtkWidget *dialog, GtkWidget *vbox)
+void addLine(diaElem *elem, GtkWidget *dialog, GtkWidget *vbox,uint32_t line)
 {
-  switch(elem->mySelf)
-  {
-    case ELEM_TOGGLE:
-        {
-            diaElemToggle *toggle=(diaElemToggle *)elem;
-            toggle->setMe( (void *)dialog,(void *)vbox);
-        }
-        break;
-    default:
-        ADM_assert(0);  
-  }
+            elem->setMe( (void *)dialog,(void *)vbox,line);
+  
 }
 /**
     \fn getLine(diaElem *elem, GtkDialog *dialog, GtkWidget *vbox)
@@ -53,19 +44,11 @@
     @return nothing
 
 */
-void getLine(diaElem *elem, GtkWidget *dialog, GtkWidget *vbox)
+void getLine(diaElem *elem, GtkWidget *dialog, GtkWidget *vbox,uint32_t line)
 {
-  switch(elem->mySelf)
-  {
-    case ELEM_TOGGLE:
-        {
-            diaElemToggle *toggle=(diaElemToggle *)elem;
-            toggle->getMe();
-        }
-        break;
-    default:
-        ADM_assert(0);  
-  }
+  
+             elem->getMe();
+  
 }
 /**
     \fn diaFactoryRun(const char *title,uint32_t nb,diaElem **elems)
@@ -83,19 +66,19 @@
   /* First there was a dialog ...*/
   GtkWidget *dialog=gtk_dialog_new ();
   GtkWidget *dialog_vbox1;
-  GtkWidget *vbox1;
+  GtkWidget *table1;
   
   gtk_window_set_title (GTK_WINDOW (dialog),title );
   dialog_vbox1 = GTK_DIALOG (dialog)->vbox;
   gtk_widget_show (dialog_vbox1);
   
-  vbox1 = gtk_vbox_new (FALSE, 0);
-  gtk_widget_show (vbox1);
-  gtk_box_pack_start (GTK_BOX (dialog_vbox1), vbox1, TRUE, TRUE, 0);
-
+  table1 = gtk_table_new (nb, 2, FALSE);
+  gtk_widget_show (table1);
+  gtk_box_pack_start (GTK_BOX (dialog_vbox1), table1, TRUE, TRUE, 0);
+  
   for(int i=0;i<nb;i++)
   {
-    addLine(elems[i],dialog,vbox1);
+    addLine(elems[i],dialog,table1,i);
     
   }
   // Add ok & cancel button
@@ -117,7 +100,7 @@
   {
     for(int i=0;i<nb;i++)
       {
-        getLine(elems[i],dialog,vbox1);
+        getLine(elems[i],dialog,table1,i);
         
       }
     ret=1;  

Added: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/FAC_float.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/FAC_float.cpp	2007-01-08 21:29:24 UTC (rev 2696)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/FAC_float.cpp	2007-01-09 19:54:42 UTC (rev 2697)
@@ -0,0 +1,86 @@
+/***************************************************************************
+  FAC_float.cpp
+  Handle dialog factory element : Toggle
+  (C) 2006 Mean Fixounet at free.fr 
+***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include <config.h>
+
+
+#include <string.h>
+#include <stdio.h>
+#include <math.h>
+
+#include "default.h"
+#include "ADM_toolkit_gtk/ADM_gladeSupport.h"
+#include "ADM_toolkit_gtk/toolkit_gtk.h"
+#include "ADM_toolkit_gtk/toolkit_gtk_include.h"
+#include "ADM_commonUI/DIA_factory.h"
+#include "ADM_assert.h"
+
+
+
+
+diaElemFloat::diaElemFloat(ELEM_TYPE_FLOAT *intValue,const char *toggleTitle, 
+                            ELEM_TYPE_FLOAT min, ELEM_TYPE_FLOAT max,const char *tip)
+  : diaElem(ELEM_FLOAT)
+{
+  param=(void *)intValue;
+  paramTitle=toggleTitle;
+  this->min=min;
+  this->max=max;
+  this->tip=tip;
+}
+
+diaElemFloat::~diaElemFloat()
+{
+  
+}
+void diaElemFloat::setMe(void *dialog, void *opaque,uint32_t line)
+{
+  GtkWidget *widget;
+  GtkObject *adj;
+  GtkWidget *label;
+  
+  label = gtk_label_new (paramTitle);
+  gtk_widget_show(label);
+  
+  gtk_table_attach (GTK_TABLE (opaque), label, 0, 1, line, line+1,
+                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  
+  ELEM_TYPE_FLOAT val=*(ELEM_TYPE_FLOAT *)param;
+  widget = gtk_spin_button_new_with_range(min,max,0.1);
+  gtk_spin_button_set_numeric (GTK_SPIN_BUTTON(widget),TRUE);
+  gtk_spin_button_set_digits  (GTK_SPIN_BUTTON(widget),2);
+  
+  
+  gtk_widget_show (widget);
+  
+  gtk_table_attach (GTK_TABLE (opaque), widget, 1, 2, line, line+1,
+                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  
+  
+  
+  myWidget=(void *)widget;
+  
+}
+void diaElemFloat::getMe(void)
+{
+  GtkWidget *widget=(GtkWidget *)myWidget;
+  ELEM_TYPE_FLOAT *val=(ELEM_TYPE_FLOAT *)param;
+  ADM_assert(widget);
+  *(ELEM_TYPE_FLOAT *)param=gtk_spin_button_get_value_as_int (GTK_SPIN_BUTTON (widget));
+}
+
+//EOF

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/FAC_toggle.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/FAC_toggle.cpp	2007-01-08 21:29:24 UTC (rev 2696)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/FAC_toggle.cpp	2007-01-09 19:54:42 UTC (rev 2697)
@@ -42,14 +42,26 @@
 {
   
 }
-void diaElemToggle::setMe(void *dialog, void *opaque)
+void diaElemToggle::setMe(void *dialog, void *opaque,uint32_t line)
 {
   GtkWidget *widget;
+  GtkWidget *label;
   
-  widget = gtk_check_button_new_with_mnemonic (paramTitle);
+  
+  label = gtk_label_new (paramTitle);
+  gtk_widget_show(label);
+  
+  gtk_table_attach (GTK_TABLE (opaque), label, 0, 1, line, line+1,
+                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  
+  widget = gtk_check_button_new_with_mnemonic ("");
   gtk_widget_show (widget);
   myWidget=(void *)widget;
-  gtk_box_pack_start (GTK_BOX (opaque), widget, FALSE, FALSE, 0);
+  
+  gtk_table_attach (GTK_TABLE (opaque), widget, 1, 2, line, line+1,
+                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
   gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (widget), *(uint32_t *)param);
 }
 void diaElemToggle::getMe(void)

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/Makefile.am	2007-01-08 21:29:24 UTC (rev 2696)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/Makefile.am	2007-01-09 19:54:42 UTC (rev 2697)
@@ -8,6 +8,6 @@
 
 libADM_dialogFactory_a_METASOURCES = AUTO
 
-libADM_dialogFactory_a_SOURCES = DIA_dialogFactory.cpp FAC_toggle.cpp
+libADM_dialogFactory_a_SOURCES = DIA_dialogFactory.cpp FAC_toggle.cpp FAC_integer.cpp FAC_float.cpp
 
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialogFactory/FAC_toggle.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialogFactory/FAC_toggle.cpp	2007-01-08 21:29:24 UTC (rev 2696)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialogFactory/FAC_toggle.cpp	2007-01-09 19:54:42 UTC (rev 2697)
@@ -36,11 +36,73 @@
 {
   
 }
-void diaElemToggle::setMe(void *dialog, void *opaque)
+void diaElemToggle::setMe(void *dialog, void *opaque,uint32_t l)
 {
 }
 void diaElemToggle::getMe(void)
 {
 }
 
+//******************************************************
+diaElemInteger::diaElemInteger(int32_t *intValue,const char *toggleTitle, int32_t min, int32_t max,const char *tip)
+  : diaElem(ELEM_TOGGLE)
+{
+ }
+
+diaElemInteger::~diaElemInteger()
+{
+  
+}
+void diaElemInteger::setMe(void *dialog, void *opaque,uint32_t line)
+{
+ 
+}
+void diaElemInteger::getMe(void)
+{
+ 
+}
+
+//******************************************************
+diaElemUInteger::diaElemUInteger(uint32_t *intValue,const char *toggleTitle, uint32_t min, uint32_t max,const char *tip)
+  : diaElem(ELEM_TOGGLE)
+{
+ }
+
+diaElemUInteger::~diaElemUInteger()
+{
+  
+}
+void diaElemUInteger::setMe(void *dialog, void *opaque,uint32_t line)
+{
+ 
+}
+void diaElemUInteger::getMe(void)
+{
+ 
+}
+
+//******************************************************
+
+diaElemFloat::diaElemFloat(ELEM_TYPE_FLOAT *intValue,const char *toggleTitle, 
+                            ELEM_TYPE_FLOAT min, ELEM_TYPE_FLOAT max,const char *tip)
+  : diaElem(ELEM_FLOAT)
+{
+}
+
+diaElemFloat::~diaElemFloat()
+{
+  
+}
+void diaElemFloat::setMe(void *dialog, void *opaque,uint32_t line)
+{
+  
+}
+void diaElemFloat::getMe(void)
+{
+ 
+}
+
+
+
+//******************************************************
 //EOF

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/FAC_toggle.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/FAC_toggle.cpp	2007-01-08 21:29:24 UTC (rev 2696)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/FAC_toggle.cpp	2007-01-09 19:54:42 UTC (rev 2697)
@@ -36,11 +36,71 @@
 {
   
 }
-void diaElemToggle::setMe(void *dialog, void *opaque)
+void diaElemToggle::setMe(void *dialog, void *opaque,uint32_t l)
 {
 }
 void diaElemToggle::getMe(void)
 {
 }
 
+
+
+//********************************************************************
+diaElemInteger::diaElemInteger(int32_t *intValue,const char *toggleTitle, int32_t min, int32_t max,const char *tip)
+  : diaElem(ELEM_TOGGLE)
+{
+ }
+
+diaElemInteger::~diaElemInteger()
+{
+  
+}
+void diaElemInteger::setMe(void *dialog, void *opaque,uint32_t line)
+{
+ 
+}
+void diaElemInteger::getMe(void)
+{
+ 
+}
+//******************************************************
+diaElemUInteger::diaElemUInteger(uint32_t *intValue,const char *toggleTitle, uint32_t min, uint32_t max,const char *tip)
+  : diaElem(ELEM_TOGGLE)
+{
+ }
+
+diaElemUInteger::~diaElemUInteger()
+{
+  
+}
+void diaElemUInteger::setMe(void *dialog, void *opaque,uint32_t line)
+{
+ 
+}
+void diaElemUInteger::getMe(void)
+{
+ 
+}
+
+//********************************************************************
+
+diaElemFloat::diaElemFloat(ELEM_TYPE_FLOAT *intValue,const char *toggleTitle, 
+                            ELEM_TYPE_FLOAT min, ELEM_TYPE_FLOAT max,const char *tip)
+  : diaElem(ELEM_FLOAT)
+{
+}
+
+diaElemFloat::~diaElemFloat()
+{
+  
+}
+void diaElemFloat::setMe(void *dialog, void *opaque,uint32_t line)
+{
+  
+}
+void diaElemFloat::getMe(void)
+{
+ 
+}
+
 //EOF

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_factory.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_factory.h	2007-01-08 21:29:24 UTC (rev 2696)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_factory.h	2007-01-09 19:54:42 UTC (rev 2697)
@@ -20,9 +20,11 @@
 {
   ELEM_INVALID=0,
   ELEM_TOGGLE,
+  ELEM_INTEGER,
+  ELEM_FLOAT,
   ELEM_MAX=ELEM_TOGGLE
 };
-
+/*********************************************/
 class diaElem
 {
 
@@ -35,20 +37,56 @@
 
   diaElem(elemEnum num) {param=NULL;mySelf=num;myWidget=NULL;};
   virtual ~diaElem() {};
-  virtual void setMe(void *dialog, void *opaque)=0;
+  virtual void setMe(void *dialog, void *opaque,uint32_t line)=0;
   virtual void getMe(void)=0;
 };
-
+/*********************************************/
 class diaElemToggle : public diaElem
 {
 
 public:
   diaElemToggle(uint32_t *toggleValue,const char *toggleTitle, const char *tip=NULL);
   virtual ~diaElemToggle() ;
-  void setMe(void *dialog, void *opaque);
+  void setMe(void *dialog, void *opaque,uint32_t line);
   void getMe(void);
 };
+/*********************************************/
+class diaElemInteger : public diaElem
+{
 
+public:
+  int32_t min,max;
+  diaElemInteger(int32_t *intValue,const char *toggleTitle, int32_t min, int32_t max,const char *tip=NULL);
+  virtual ~diaElemInteger() ;
+  void setMe(void *dialog, void *opaque,uint32_t line);
+  void getMe(void);
+};
+/* Same but unsigned */
+class diaElemUInteger : public diaElem
+{
+
+public:
+  uint32_t min,max;
+  diaElemUInteger(uint32_t *intValue,const char *toggleTitle, uint32_t min, uint32_t max,const char *tip=NULL);
+  virtual ~diaElemUInteger() ;
+  void setMe(void *dialog, void *opaque,uint32_t line);
+  void getMe(void);
+};
+
+/*********************************************/
+#define ELEM_TYPE_FLOAT float
+class diaElemFloat : public diaElem
+{
+
+public:
+  ELEM_TYPE_FLOAT min,max;
+  diaElemFloat(ELEM_TYPE_FLOAT *intValue,const char *toggleTitle, ELEM_TYPE_FLOAT min, 
+               ELEM_TYPE_FLOAT max,const char *tip=NULL);
+  virtual ~diaElemFloat() ;
+  void setMe(void *dialog, void *opaque,uint32_t line);
+  void getMe(void);
+};
+/*********************************************/
 uint8_t diaFactoryRun(const char *title,uint32_t nb,diaElem **elems);
 
 #endif

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_guiAddBorder.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_guiAddBorder.cpp	2007-01-08 21:29:24 UTC (rev 2696)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_guiAddBorder.cpp	2007-01-09 19:54:42 UTC (rev 2697)
@@ -1,61 +0,0 @@
-/***************************************************************************
-                          ADM_guiAddBorder.cpp  -  description
-                             -------------------
-    begin                : Sun Aug 11 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include "config.h"
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
-
-#include <time.h>
-#include <sys/time.h>
-
-
-#include "fourcc.h"
-#include "avio.hxx"
-#include "config.h"
-#include "avi_vars.h"
-#ifdef HAVE_ENCODER
-
-#include <ADM_assert.h>
-#include "ADM_editor/ADM_edit.hxx"
-#include "ADM_video/ADM_genvideo.hxx"
-//#include "ADM_video/ADM_resizebis.hxx"
-#include "ADM_video/ADM_vidAddBorder.h"
-
-extern uint8_t DIA_4entries(char *title,uint32_t *left,uint32_t *right,uint32_t *top,uint32_t *bottom);
-
-
-uint8_t AVDMVideoAddBorder::configure( AVDMGenericVideoStream *instream)
-{
-UNUSED_ARG(instream);
-
-CROP_PARAMS *par;
-
-     	par=_param;
-
-	 if(DIA_4entries((char *)"Add black borders",&par->left,&par->right,&par->top,&par->bottom))
-	 {
-	 		memcpy(&_info,_in->getInfo(),sizeof(_info));
-			_info.width+=_param->right+_param->left;
-			_info.height+=_param->bottom+_param->top;
-			return 1;
-	 }
-	 return 0;
-}
-
-#endif

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_guiBSMear.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_guiBSMear.cpp	2007-01-08 21:29:24 UTC (rev 2696)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_guiBSMear.cpp	2007-01-09 19:54:42 UTC (rev 2697)
@@ -1,54 +0,0 @@
-/***************************************************************************
-                          ADM_guiBSMear.cpp  -  description
-                             -------------------
- 			Actually it is the same as crop
- 			Blacken borders to remove for example, vhs parasites at bottom
-
-    begin                : Fri Mar 29 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include "config.h"
- 
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
-
-#include <time.h>
-#include <sys/time.h>
-
-
-#include <ADM_assert.h>
-#include "fourcc.h"
-#include "avio.hxx"
-#include "config.h"
-#include "avi_vars.h"
-#ifdef HAVE_ENCODER
-
-
-#include "ADM_editor/ADM_edit.hxx"
-#include "ADM_video/ADM_genvideo.hxx"
-#include "ADM_video/ADM_vidCommonFilter.h"
-
-#include "ADM_colorspace/colorspace.h"
-extern int DIA_getCropParams(	char *name,CROP_PARAMS *param,AVDMGenericVideoStream *in);
-
-uint8_t AVDMVideoStreamBSMear::configure( AVDMGenericVideoStream *instream)
-{
-UNUSED_ARG(instream);
-
-	return (DIA_getCropParams("Blacken Borders",_param,instream ));
-
-}
-
-#endif

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidAddBorder.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidAddBorder.cpp	2007-01-08 21:29:24 UTC (rev 2696)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidAddBorder.cpp	2007-01-09 19:54:42 UTC (rev 2697)
@@ -1,210 +0,0 @@
-/***************************************************************************
-                          ADM_vidAddBorder.cpp  -  description
-                             -------------------
-    begin                : Sun Aug 11 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <ADM_assert.h>
-
-#include "config.h"
-#include "fourcc.h"
-#include "avio.hxx"
-#include "config.h"
-#include "avi_vars.h"
-#ifdef HAVE_ENCODER
-
-
-#include "ADM_toolkit/toolkit.hxx"
-#include "ADM_editor/ADM_edit.hxx"
-#include "ADM_video/ADM_genvideo.hxx"
-#include "ADM_video/ADM_vidAddBorder.h"
-#include "ADM_video/ADM_vidCommonFilter.h"
-#include "ADM_filter/video_filters.h"
-
-
-static FILTER_PARAM cropParam={4,{"left","right","top","bottom"}};
-
-
-SCRIPT_CREATE(addBorder_script,AVDMVideoAddBorder,cropParam);
-BUILD_CREATE(addBorder_create,AVDMVideoAddBorder);
-
-char *AVDMVideoAddBorder::printConf( void )
-{
- 	static char buf[50];
-
- 	sprintf((char *)buf," Add Borders %lu x %lu --> %lu x %lu",
- 				_in->getInfo()->width,
- 				_in->getInfo()->height,
- 				_info.width,
- 				_info.height);
-        return buf;
-}
-
-AVDMVideoAddBorder::AVDMVideoAddBorder(  AVDMGenericVideoStream *in,CONFcouple *couples)
-{
-
- 	_in=in;		
-   	memcpy(&_info,_in->getInfo(),sizeof(_info));  		
-	
-		if(couples)
-		{
-
-			 _param=NEW(CROP_PARAMS);
-
-				GET(left);
-				GET(right);
-				GET(top);
-				GET(bottom);
-				_info.width+=_param->right+_param->left;
-				_info.height+=_param->bottom+_param->top;
-		}	
-			else 			
-		{	// default parameter	
-				_param=NEW(CROP_PARAMS);
-				_param->left=_param->top=
-				_param->right=_param->bottom=0;
-		}				
-					
- 	//_uncompressed=(uint8_t *)malloc(3*_in->getInfo()->width*_in->getInfo()->height);
- 	//_uncompressed=new uint8_t [3*_in->getInfo()->width*_in->getInfo()->height];
-	_uncompressed=new ADMImage(_in->getInfo()->width,_in->getInfo()->height);
-  ADM_assert(_uncompressed);
-  _info.encoding=1;
-
-  	  	
-}
-AVDMGenericVideoStream *create_addBorder(AVDMGenericVideoStream *in,uint32_t x,uint32_t x2,uint32_t y,uint32_t y2)
-{
-	return new AVDMVideoAddBorder(in,x,x2,y,y2);
-}
-AVDMVideoAddBorder::AVDMVideoAddBorder(  AVDMGenericVideoStream *in,uint32_t x,uint32_t x2,uint32_t y,uint32_t y2)
-{
-
- 	_in=in;		
-   	memcpy(&_info,_in->getInfo(),sizeof(_info));  		
-
-				_param=NEW(CROP_PARAMS);
-				_param->left=x;
-				_param->top=y;
-				_param->right=x2;
-				_param->bottom=y2;
-	_info.width+=_param->right+_param->left;
-	_info.height+=_param->bottom+_param->top;
- 	//_uncompressed=(uint8_t *)malloc(3*_in->getInfo()->width*_in->getInfo()->height);
- 	//_uncompressed=new uint8_t [3*_in->getInfo()->width*_in->getInfo()->height];
-	_uncompressed=new ADMImage(_in->getInfo()->width,_in->getInfo()->height);
-  ADM_assert(_uncompressed);
-  _info.encoding=1;
-
-
-}
-
-uint8_t	AVDMVideoAddBorder::getCoupledConf( CONFcouple **couples)
-{
-
-			ADM_assert(_param);
-			*couples=new CONFcouple(4);
-
-
-	CSET(left);
-	CSET(right);
-	CSET(top);
-	CSET(bottom);
-			return 1;
-
-}
-AVDMVideoAddBorder::~AVDMVideoAddBorder()
-{
- 	delete _uncompressed;
-	DELETE(_param);
-	_uncompressed=NULL;
- 	
-}
-uint8_t AVDMVideoAddBorder::getFrameNumberNoAlloc(uint32_t frame,
-				uint32_t *len,
-   				ADMImage *data,
-				uint32_t *flags)
-{
-
-		if(frame>=_info.nb_frames) 
-		{
-			printf("Filter : out of bound!\n");
-			return 0;
-		}
-	
-		ADM_assert(_param);									
-								
-			// read uncompressed frame
-       		if(!_in->getFrameNumberNoAlloc(frame, len,_uncompressed,flags)) return 0;
-       		
-				// blacken screen
-				memset(YPLANE(data),16,_info.width*_info.height);
-				memset(UPLANE(data),128,(_info.width*_info.height)>>2);
-				memset(VPLANE(data),128,(_info.width*_info.height)>>2);
-
-				// do luma
-				uint8_t *src,*dest;
-       		uint32_t y,x,line,lineout;
-       		
-       		y=_in->getInfo()->height;
-       		x=_in->getInfo()->width;
-       		line=x;
-		lineout=_info.width;
-		
-		// copy Luma
-       		src=YPLANE(_uncompressed);
-       		dest=YPLANE(data)+_param->left+_info.width*_param->top;
-       		
-       		for(uint32_t k=y;k>0;k--)
-       		{
-       		 	    memcpy(dest,src,line);
-       		 	    src+=line;
-       		 	    dest+=lineout;
-       		}
-       		 
-		// U and V now
-		uint8_t *src_u,*src_v;
-		uint8_t *dst_u,*dst_v;
-
-       		src_u=UPLANE(_uncompressed);
-       		src_v=VPLANE(_uncompressed);
-       		line>>=1;
-       		lineout>>=1;       		       		 	
-		dst_u=UPLANE( data)+(_info.width*_param->top>>2)+
-						(_param->left>>1);;
-		dst_v= VPLANE( data)+(_info.width*_param->top>>2)+
-						(_param->left>>1);;
-
-       		 for(uint32_t k=y>>1;k>0;k--)
-       		 {
-       		 	memcpy(dst_u,src_u,line);
-       		 	memcpy(dst_v,src_v,line);
-
-       			src_u+=line;
-       			src_v+=line;
-
-       			dst_u+=lineout;
-       		    	dst_v+=lineout;
-
-       		 }
-       		  *len= _info.width*_info.height+(_info.width*_info.height>>1);
-		  data->copyInfo(_uncompressed);
-      return 1;
-}
-
-
-
-#endif

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidAddBorder.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidAddBorder.h	2007-01-08 21:29:24 UTC (rev 2696)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidAddBorder.h	2007-01-09 19:54:42 UTC (rev 2697)
@@ -1,36 +0,0 @@
-/***************************************************************************
-                          ADM_vidAddBorder.h  -  description
-                             -------------------
-    begin                : Sun Aug 11 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifndef __ADDBORDER__
-#define     __ADDBORDER__
-  class  AVDMVideoAddBorder:public AVDMGenericVideoStream
- {
-
- protected:
-    		virtual char					*printConf(void);
-    		CROP_PARAMS			*_param;
- public:
-
-  							AVDMVideoAddBorder(  AVDMGenericVideoStream *in,CONFcouple *setup);
-							AVDMVideoAddBorder(  AVDMGenericVideoStream *in,uint32_t x,uint32_t x2,uint32_t y,uint32_t y2);
-  			virtual 			~AVDMVideoAddBorder();
-		        virtual 	uint8_t 	getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-          																	ADMImage *data,uint32_t *flags);
-         				uint8_t 	configure( AVDMGenericVideoStream *instream) ;
-					uint8_t	getCoupledConf( CONFcouple **couples)		;
- }     ;
-
-#endif

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidBSmear.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidBSmear.cpp	2007-01-08 21:29:24 UTC (rev 2696)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidBSmear.cpp	2007-01-09 19:54:42 UTC (rev 2697)
@@ -1,185 +0,0 @@
-/***************************************************************************
-                          ADM_vidBSMear.cpp  -  description
-                             -------------------
-         change part of video into black borders
-
-          Each one ,must be even
-
-          Copy / Paste from crop,almost the same thing
-
-
-    begin                : Sun Mar 24 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <ADM_assert.h>
-
-#include "config.h"
-#include "fourcc.h"
-#include "avio.hxx"
-#include "config.h"
-#include "avi_vars.h"
-#ifdef HAVE_ENCODER
-
-
-#include "ADM_toolkit/toolkit.hxx"
-#include "ADM_editor/ADM_edit.hxx"
-#include "ADM_video/ADM_genvideo.hxx"
-#include "ADM_video/ADM_vidCommonFilter.h"
-#include "ADM_filter/video_filters.h"
-
-
-static FILTER_PARAM cropParam={4,{"left","right","top","bottom"}};
-
-
-SCRIPT_CREATE(bsmear_script,AVDMVideoStreamBSMear,cropParam);
-
-char *AVDMVideoStreamBSMear::printConf( void )
-{
- 	static char buf[50];
- 	
- 	sprintf((char *)buf," Black l:%lu  r:%lu  u:%lu x d:%lu",
- 				_param->left,
- 					_param->right,
- 					_param->top,
- 					_param->bottom);
-        return buf;
-}
-
-//_______________________________________________________________
-
-AVDMVideoStreamBSMear::AVDMVideoStreamBSMear(  	AVDMGenericVideoStream *in,CONFcouple *couples)
-{
-
-
-  	_in=in;		
-   	memcpy(&_info,_in->getInfo(),sizeof(_info));  		
-
-		if(couples)
-		{
-			_param=NEW(CROP_PARAMS);
-			GET(left);
-			GET(right);
-			GET(top);
-			GET(bottom);
-		}	
-			else 	
-		{	// default parameter	
-				_param=NEW(CROP_PARAMS);
-				_param->left=_param->top=
-						_param->right=_param->bottom=0;
-		}										
- 	
-  _info.encoding=1;
-
-  	  	
-}
-
-uint8_t	AVDMVideoStreamBSMear::getCoupledConf( CONFcouple **couples)
-{
-
-			ADM_assert(_param);
-			*couples=new CONFcouple(4);
-
-#define CSET(x)  (*couples)->setCouple((char *)#x,(_param->x))
-	CSET(left);
-	CSET(right);
-	CSET(top);
-	CSET(bottom);
-			return 1;
-
-}
-AVDMVideoStreamBSMear::~AVDMVideoStreamBSMear()
-{
- 	DELETE(_param);
- 	
-}
-
-//
-//	Blacken borders, just setting luma to null should be enough
-//
-
-uint8_t AVDMVideoStreamBSMear::getFrameNumberNoAlloc(uint32_t frame,
-				uint32_t *len,
-   				ADMImage *data,
-				uint32_t *flags)
-{
-
-			if(frame>=_info.nb_frames) 
-			{
-				printf("Filter : out of bound!\n");
-				return 0;
-			}
-	
-			ADM_assert(_param);									
-								
-			// read uncompressed frame directly into follower
-			// and blacken there
-			
-       		if(!_in->getFrameNumberNoAlloc(frame, len,data,flags)) return 0;
-       		  *len= _info.width*_info.height+(_info.width*_info.height>>1);       			
-       		  // blacken top
-       		  uint8_t *srcY=YPLANE(data);
-		  uint8_t *srcU=UPLANE(data);
-		  uint8_t *srcV=VPLANE(data);
-       		  uint32_t bytes=_info.width*_param->top;
-		  uint32_t page=_info.width*_info.height;
-       		
-       		  memset(srcY,0x10,bytes);
-		  memset(srcU,0x80,bytes>>2);
-		  memset(srcV,0x80,bytes>>2);
-       		  // left & right
-       		  uint32_t stride=_info.width;
-		  
-       		  for(uint32_t y=_info.height;y>0;y--)
-       		  {
-       		        memset(srcY,0x10,_param->left);
-       		        memset(srcY+stride-_param->right,0,_param->right);       		
-       		        srcY+=stride;       		
-		 }
-		 for(uint32_t y=_info.height>>1;y>0;y--)
-       		  {
-       		        
-			memset(srcU,0x80,_param->left>>1);
-			memset(srcV,0x80,_param->left>>1);
-			memset(srcU+((stride-_param->right)>>1),0x80,_param->right>>1);
-			memset(srcV+((stride-_param->right)>>1),0x80,_param->right>>1);
-			srcU+=stride>>1;
-			srcV+=stride>>1;
-       		  }
-       		
-       		  // backen bottom
-       		  srcY=YPLANE(data)+_info.width*_info.height-1;
-       		
-       		 bytes=_info.width*_param->bottom;
-       	 	 srcY-=bytes;
-       		 memset(srcY,0x10,bytes);
-		// chroma
-		 srcU=UPLANE(data)+(page>>2)-1;
-		 srcU-=bytes>>2;
-       		 memset(srcU,0x80,bytes>>2);
-		 
-		 srcV=VPLANE(data)+(page>>2)-1;
-		 srcV-=bytes>>2;
-       		 memset(srcV,0x80,bytes>>2);
-		 
-		  
-       		  	
-       		         		       		
-      return 1;
-}
-
-#endif

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFastConvolution.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFastConvolution.cpp	2007-01-08 21:29:24 UTC (rev 2696)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFastConvolution.cpp	2007-01-09 19:54:42 UTC (rev 2697)
@@ -1,468 +0,0 @@
-/***************************************************************************
-                          ADM_vidFastConvolution.cpp  -  description
-                             -------------------
-    begin                : Sat Nov 23 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include "config.h"
-    
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include "default.h"
-
-#include "ADM_toolkit/toolkit.hxx"
-#include "ADM_editor/ADM_edit.hxx"
-#include "ADM_video/ADM_genvideo.hxx"
-
-#include"ADM_video/ADM_vidConvolution.hxx"
-#include "ADM_userInterfaces/ADM_commonUI/DIA_factory.h"
-#include <ADM_assert.h>
-
-
-BUILD_CREATE(mean_create,AVDMFastVideoMean);
-BUILD_CREATE(sharpen_create,AVDMFastVideoSharpen);
-BUILD_CREATE(Gaussian_create,AVDMFastVideoGauss);
-
-
-
-uint8_t	AVDMFastVideoConvolution::getCoupledConf( CONFcouple **couples)
-{
-
-	ADM_assert(_param);
-	
-	*couples=new CONFcouple(2);
-
-#define CSET(x)  (*couples)->setCouple((char *)#x,(_param->x))
-	CSET(chroma);
-	CSET(luma);
-	return 1;
-
-}
-
-//_______________________________________________________________
-
-AVDMFastVideoConvolution::AVDMFastVideoConvolution(
-			AVDMGenericVideoStream *in,CONFcouple *couples)
-{
-
-
-	_in=in;		
-	memcpy(&_info,_in->getInfo(),sizeof(_info));
-	_uncompressed=new ADMImage(_in->getInfo()->width,_in->getInfo()->height);	
-	ADM_assert(_uncompressed); 
-	_info.encoding=1;
-	if(couples==NULL)
-	{
-		_param=NEW( CONV_PARAM);
-		_param->chroma=1;
-		_param->luma=1;	
-		printf("\n Creating from null\n");				
-	}
-	else
-	{
-		_param=NEW(CONV_PARAM);
-		GET(luma);
-		GET(chroma);
-	}
-
-  	  	
-}
-AVDMFastVideoConvolution::~AVDMFastVideoConvolution()
-{
-	if(_uncompressed)
- 		delete _uncompressed;
-	_uncompressed=NULL;
- 	DELETE(_param);
-}
-
-//
-//	Basically ask a uncompressed frame from editor and ask
-//		GUI to decompress it .
-//
-
-uint8_t AVDMFastVideoConvolution::getFrameNumberNoAlloc(uint32_t frame,
-				uint32_t *len,
-   				ADMImage *data,
-				uint32_t *flags)
-{
-//uint8_t *dst,*dstu,*dstv,*srcu,*srcv;
-uint8_t *x1,*x2,*x3,*o1;
-uint32_t stride,page;
-
-	ADM_assert(frame<_info.nb_frames);
-	ADM_assert(_uncompressed);					
-	stride=_info.width;
-	page=(stride*_info.height)>>2;
-	
-
-	
-	// read uncompressed frame
-	if(!_in->getFrameNumberNoAlloc(frame, len,_uncompressed,flags)) return 0;               
-         
-	if(!_param->luma)
-	{
-		memcpy(YPLANE(data),YPLANE(_uncompressed),page*4);
-	}
-	else
-	{
-		o1=YPLANE(data)+stride;
-		x1=YPLANE(_uncompressed);
-		x2=x1+stride;
-		x3=x2+stride;
-
-		// first and last line
-		memcpy(YPLANE(data),YPLANE(_uncompressed),stride);
-		memcpy(YPLANE(data)+page*4-stride,YPLANE(_uncompressed)+page*4-stride,stride);          
-		// Luma
-		for(int32_t y=1;y<(int32_t)_info.height-1;y++)
-		{
-			doLine(x1,x2,x3,o1,stride);
-			x1=x2;
-			x2=x3;
-			x3+=stride; 
-			o1+=stride;                 
-		}
-	}
-      	// chroma u & v
-	if(!_param->chroma)
-	{
-		memcpy(UPLANE(data),UPLANE(_uncompressed),page);
-		memcpy(VPLANE(data),VPLANE(_uncompressed),page);
-	}
-	else
-	{
-		stride>>=1;
-		// chroma u
-		o1=UPLANE(data)+stride;
-		x1=UPLANE(_uncompressed);
-		x2=x1+stride;
-		x3=x2+stride;
-		// first and last line
-		memcpy(UPLANE(data),UPLANE(_uncompressed),stride);
-		memcpy(UPLANE(data)+page-stride,UPLANE(_uncompressed)+page-stride,stride);          
-		// Luma
-		for(int32_t y=1;y<(int32_t)(_info.height>>1)-1;y++)
-		{
-			doLine(x1,x2,x3,o1,stride);
-			x1=x2;
-			x2=x3;
-			x3+=stride; 
-			o1+=stride;                 
-		}
-		
-		// chroma V
-		o1=VPLANE(data)+stride;
-		x1=VPLANE(_uncompressed);
-		x2=x1+stride;
-		x3=x2+stride;
-		// first and last line
-		memcpy(VPLANE(data),VPLANE(_uncompressed),stride);
-		memcpy(VPLANE(data)+page-stride,VPLANE(_uncompressed)+page-stride,stride);          
-		// Luma
-		for(int32_t y=1;y<(int32_t)(_info.height>>1)-1;y++)
-		{
-			doLine(x1,x2,x3,o1,stride);
-			x1=x2;
-			x2=x3;
-			x3+=stride; 
-			o1+=stride;                 
-		}
-	}
-	data->copyInfo(_uncompressed);
-      return 1;
-}
-//
-//	Run the convolution kernel on a whole line
-//	to speed up things (cache effect + locality of datas)
-//
-//----------------------------------------------------------------
-//----------------------------------------------------------------
-//-----------------------MEAN---------------------
-//----------------------------------------------------------------
-//----------------------------------------------------------------
-
-char 	*AVDMFastVideoMean::printConf(void)
-{
-		static char str[]="Mean(fast)";
-		return (char *)str;
-	
-}
-uint8_t AVDMFastVideoMean::doLine(uint8_t  *pred,
-																					uint8_t *cur,
-   																				uint8_t *next,
-   																				uint8_t *out,
-                       										uint32_t w)
-                                 
-{
-	uint8_t a1,a2,a3;
-	uint8_t b1,b2,b3;
-	uint8_t c1,c2,c3;
-	int32_t o;
-	
-	a2=*pred++;a3=*pred++;
-	b2=*cur++;b3=*cur++;
-	c2=*next++;c3=*next++;
-	
-	*out++=b2;
-	w--;
-	
-	while(w>1)
-	{
-			a1=a2;
-			a2=a3;
-			a3=*pred++;
-			b1=b2;
-			b2=b3;
-			b3=*cur++;
-			c1=c2;
-			c2=c3;
-			c3=*next++;
-		
-		  //
-		  o=a1+a2+a3+b1+b2+b3+c1+c2+c3;
-		  o/=9;
-		  
-		  *out++=o;
-		  w--;
-	}	
-		*out++=b3;
-		return 1;
-}
-
-//----------------------------------------------------------------
-//----------------------------------------------------------------
-//-----------------------GAUSS---------------------
-//----------------------------------------------------------------
-//----------------------------------------------------------------
-
-//          6 10 6
-//         10 16 10 *1/80
-//		    6 10 6
-char 							*AVDMFastVideoGauss::printConf(void)
-{
-		static char str[]="Gauss(fast)";
-		return (char *)str;
-	
-}
- uint8_t AVDMFastVideoGauss::doLine(uint8_t  *pred,
-																					uint8_t *cur,
-   																				uint8_t *next,
-   																				uint8_t *out,
-                       										uint32_t w)
-                                 
-{
-	uint8_t a1,a2,a3;
-	uint8_t b1,b2,b3;
-	uint8_t c1,c2,c3;
-	int32_t o;
-//#define MASKED__	
-#define threshold 80
-	int v,r;
-	
-	a2=*pred++;a3=*pred++;
-	b2=*cur++;b3=*cur++;
-	c2=*next++;c3=*next++;
-	
-	*out++=b2;
-	w--;
-	
-	while(w>1)
-	{
-			a1=a2;
-			a2=a3;
-			a3=*pred++;
-			b1=b2;
-			b2=b3;
-			b3=*cur++;
-			c1=c2;
-			c2=c3;
-			c3=*next++;
-		
-		  //
-#ifdef MASKED__
-		v=b2;
-		r=16;
-		o=b2*16;
-		#define MORE(x,coef) if(abs(x-v)<=threshold) {o+=x*coef;r+=coef;}
-		MORE(a1,6);
-		MORE(a2,10);
-		MORE(a3,6);
-		
-		MORE(b1,10);
-		MORE(b3,10);
-		
-		MORE(c1,6);
-		MORE(c2,10);
-		MORE(c3,6);
-		
-		o=(o+r-1)/r;		
-		
-#else		  
-		  o=6*a1+10*a2+6*a3+10*b1+16*b2+10*b3+6*c1+10*c2+6*c3;		  
-		  o/=80;
-#endif		  
-		  
-		  *out++=o;
-		  w--;
-	}	
-	*out++=b3;
-		return 1;
-}
-//----------------------------------------------------------------
-//----------------------------------------------------------------
-//-----------------------SHARPEN---------------------
-//----------------------------------------------------------------
-//----------------------------------------------------------------
-
-//         -1 -2 -1
- 	//         -2 16 -2 *1/16
-  	//		    -1 -2 -1
-char 							*AVDMFastVideoSharpen::printConf(void)
-{
-		static char str[]="Sharpen(fast)";
-		return (char *)str;
-	
-}
- uint8_t AVDMFastVideoSharpen::doLine(uint8_t  *pred,
-																					uint8_t *cur,
-   																				uint8_t *next,
-   																				uint8_t *out,
-                       										uint32_t w)
-                                 
-{
-	uint8_t a1,a2,a3;
-	uint8_t b1,b2,b3;
-	uint8_t c1,c2,c3;
-	int32_t o;
-	
-	a2=*pred++;a3=*pred++;
-	b2=*cur++;b3=*cur++;
-	c2=*next++;c3=*next++;
-	
-	*out++=b2;
-	w--;
-	
-	while(w>1)
-	{
-			a1=a2;
-			a2=a3;
-			a3=*pred++;
-			b1=b2;
-			b2=b3;
-			b3=*cur++;
-			c1=c2;
-			c2=c3;
-			c3=*next++;
-		
-		  //
-		  //         -1 -2 -1
- 	//         -2 16 -2 *1/16
-  	//		    -1 -2 -1
-		  //o=-a1+-2*a2+-a3+-2*b1+16*b2+-2*b3+-1*c1+-2*c2+-1*c3;
-		  //o/=16;
-		  o=4*b2-a2-c2-b1-b3;
-		  o>>=2;
-		  o+=3*a2;
-		  o=o/3;
-		  if(o<0) o=0;
-		  if(o>255) o=255;
-		  
-		  *out++=o;
-		  w--;
-	}	
-	*out++=b3;
-		return 1;
-}
-//----------------------------------------------------------------
-//----------------------------------------------------------------
-//-----------------------Median---------------------
-//----------------------------------------------------------------
-//----------------------------------------------------------------
-
-//         -1 -2 -1
- 	//         -2 16 -2 *1/16
-  	//		    -1 -2 -1
-char 							*AVDMFastVideoMedian::printConf(void)
-{
-		static char str[]="Median(fast)";
-		return (char *)str;
-	
-}
- uint8_t AVDMFastVideoMedian::doLine(uint8_t  *pred,
-																					uint8_t *cur,
-   																				uint8_t *next,
-   																				uint8_t *out,
-                       										uint32_t w)
-                                 
-{
-	uint8_t a1,a2,a3;
-	uint8_t b1,b2,b3;
-	uint8_t c1,c2,c3; //,i;
-	//int32_t o;
-	uint8_t temp;
-	
-	static uint8_t tab[9];
-	a2=*pred++;a3=*pred++;
-	b2=*cur++;b3=*cur++;
-	c2=*next++;c3=*next++;
-	
-	*out++=b2;
-	w--;
-	
-	while(w>1)
-	{
-			tab[0]=a1=a2;
-			tab[1]=a2=a3;
-			tab[2]=a3=*pred++;
-			tab[3]=b1=b2;
-			tab[4]=b2=b3;
-			tab[5]=b3=*cur++;
-			tab[6]=c1=c2;
-			tab[7]=c2=c3;
-			tab[8]=c3=*next++;
-		
-#define PIX_SORT(a,b) { if ((a)>(b)) PIX_SWAP((a),(b)); }
-#define PIX_SWAP(a,b) { temp=(a);(a)=(b);(b)=temp; }
-
-   uint8_t *p=(uint8_t *)tab;
-								
-    PIX_SORT(p[1], p[2]) ; PIX_SORT(p[4], p[5]) ; PIX_SORT(p[7], p[8]) ;
-    PIX_SORT(p[0], p[1]) ; PIX_SORT(p[3], p[4]) ; PIX_SORT(p[6], p[7]) ;
-    PIX_SORT(p[1], p[2]) ; PIX_SORT(p[4], p[5]) ; PIX_SORT(p[7], p[8]) ;
-    PIX_SORT(p[0], p[3]) ; PIX_SORT(p[5], p[8]) ; PIX_SORT(p[4], p[7]) ;
-    PIX_SORT(p[3], p[6]) ; PIX_SORT(p[1], p[4]) ; PIX_SORT(p[2], p[5]) ;
-    PIX_SORT(p[4], p[7]) ; PIX_SORT(p[4], p[2]) ; PIX_SORT(p[6], p[4]) ;
-    PIX_SORT(p[4], p[2]) ; 
-		  
-		  *out++=tab[4];
-		  w--;
-	}	
-	*out++=b3;
-	return 1;
-}
-uint8_t  DIA_getLumaChroma(uint32_t *doLuma, uint32_t *doChroma);
-uint8_t AVDMFastVideoConvolution::configure(AVDMGenericVideoStream * instream)
-{
-  
-  //return DIA_getLumaChroma(&(_param->luma),&(_param->chroma)) ; 
-  diaElemToggle luma(&(_param->luma),"Process luma","Process luma plane");
-  diaElemToggle chroma(&(_param->chroma),"Process chroma");
-  
-  diaElem *elems[2]={&luma,&chroma};
-  
-  return diaFactoryRun("Fast Convolution",2,elems);
-}
-
-
-

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFlux.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFlux.cpp	2007-01-08 21:29:24 UTC (rev 2696)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFlux.cpp	2007-01-09 19:54:42 UTC (rev 2697)
@@ -1,649 +0,0 @@
-/***************************************************************************
-                          ADM_vidFlux.cpp  -  description
-                             -------------------
-    begin                : Tue Dec 31 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
-    
-    Ported from FluxSmooth
-    (c)  Ross Thomas <ross at grinfinity.com>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
- 
- 
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <ADM_assert.h>
-#include <math.h>
-
-#include "config.h"
-#include "fourcc.h"
-#include "avio.hxx"
-#include "config.h"
-#include "avi_vars.h"
-
-
-#include "ADM_toolkit/toolkit.hxx"
-#include "ADM_editor/ADM_edit.hxx"
-#include "ADM_video/ADM_genvideo.hxx"
-#include "admmangle.h"
-
-static int16_t scaletab[16];
-static uint64_t scaletab_MMX[65536];
-
-void initScaleTab( void )
-{
-//uint32_t i;
-
-		scaletab[1] = 32767;
-		for(int i = 2; i < 16; ++i)
-				scaletab[i] = (int)(32768.0 / i + 0.5);
-		for(uint32_t  i = 0; i < 65536; ++i)
-		{
-			scaletab_MMX[i] = ( (uint64_t)scaletab[ i        & 15]       ) |
-							  (((uint64_t)scaletab[(i >>  4) & 15]) << 16) |
-							  (((uint64_t)scaletab[(i >>  8) & 15]) << 32) |
-							  (((uint64_t)scaletab[(i >> 12) & 15]) << 48);
-		}
-}
- 
-#include "ADM_video/ADM_vidFlux.h"
-#include "ADM_filter/video_filters.h"
-
-static FILTER_PARAM fluxParam={2,{"temporal_threshold","spatial_threshold"}};
-
-
-SCRIPT_CREATE(fluxsmooth_script,ADMVideoFlux,fluxParam);
-
-//#define ASM_FLUX
-BUILD_CREATE(fluxsmooth_create,ADMVideoFlux);
-
-static uint64_t spat_thresh ASM_CONST =0LL;
-static uint64_t temp_thresh ASM_CONST =0LL;
-static uint64_t ASM_CONST _l_counter_init,_l_indexer,_l_prev_pels,_l_next_pels;
-static long int _l_src_pitch ASM_CONST =0;
-static long int _l_dst_pitch ASM_CONST =0;
-static int _l_xmax ASM_CONST=0;
-
-static int ycnt;
-static	uint8_t * _l_currp; 
-static	 uint8_t * _l_prevp;								  								  
-static	 uint8_t * _l_nextp; 
-static	 uint8_t * _l_destp; 
-
-
-static uint32_t size;
-
-ADMVideoFlux::ADMVideoFlux(AVDMGenericVideoStream *in,CONFcouple *couples)
-			
-{
-  
-	_in=in;
-	memcpy(&_info,in->getInfo(),sizeof(_info));
-	if(couples)
-	{
-		_param=NEW( FLUX_PARAM );
-		GET(temporal_threshold);
-		GET(spatial_threshold);
-	}
-	else
-	{
-		 _param=NEW( FLUX_PARAM );
-		 _param->spatial_threshold=7;
-		 _param->temporal_threshold=7;
-	}
-  	num_frame=0xffff0000;
-	vidCache=new VideoCache(5,in);
-}
-
-uint8_t	ADMVideoFlux::getCoupledConf( CONFcouple **couples)
-{
-
-			ADM_assert(_param);
-			*couples=new CONFcouple(2);
-
-#define CSET(x)  (*couples)->setCouple((char *)#x,(_param->x))
-	CSET(temporal_threshold);
-	CSET(spatial_threshold);
-		return 1;
-
-}
-uint8_t ADMVideoFlux::configure(AVDMGenericVideoStream *in)
-{
-UNUSED_ARG(in);
-int i,j;
-		i=_param->temporal_threshold;
-		j=_param->spatial_threshold;
-	  if(GUI_getIntegerValue(&i,0,255,"Temporal  Threshold"))
-			{
-					if(GUI_getIntegerValue(&j,0,255,"Spatial  Threshold"))
-					{
-						_param->temporal_threshold=(uint32_t)i;						
-						_param->spatial_threshold=(uint32_t)j;
-					}	
-					return 1;
-			}		
-			return 0;	
-}
-ADMVideoFlux::~ADMVideoFlux()
-{
-	DELETE(_param);
-	if(vidCache)
-		delete vidCache;
-	vidCache=NULL;
-}
-
-char	*ADMVideoFlux::printConf( void) 
-{
-	static char conf[100];
-
-		sprintf(conf,"FluxSmooth: Spatial :%02lu Temporal:%02lu",
-						_param->spatial_threshold,
-						_param->temporal_threshold);
-		return conf;
-	
-}
-uint8_t ADMVideoFlux::getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-          			ADMImage *data,uint32_t *flags)
-{
-UNUSED_ARG(flags);
-uint32_t dlen,dflags;
-uint32_t plane=_info.width*_info.height;
-ADMImage	*image,*next,*prev;
-
-
-			*len=(plane*3)>>1;
-			
-			size=(_info.width*_info.height*3)>>1;
-			if(frame>_info.nb_frames-1) return 0;
-			
-			image=vidCache->getImage(frame);
-			if(!image) return 0;
-			
-			if(!frame || (frame==_info.nb_frames-1))
-			{
-
-				data->duplicate(image);
-				data->copyInfo(image);
-				vidCache->unlockAll();
-				return 1;
-			}
-			next=vidCache->getImage(frame+1);
-			if(!next)
-			{
-				vidCache->unlockAll();
-				return 0;
-			}
-			prev=vidCache->getImage(frame-1);
-			if(!prev)
-			{
-				vidCache->unlockAll();
-				return 0;
-			}	    
-				
-
-		   			
-// now we have everything
-		int dst_pitch = _info.width,
-		src_pitch = _info.width,
-		row_size  = _info.width,
-		height    = _info.height;
-		
- uint8_t   		*currp = YPLANE(image),
-			*prevp = YPLANE(prev),
-			*nextp = YPLANE(next);;
-	uint8_t		*destp = YPLANE(data);
-
-	// line 1 and last
-	memcpy(destp, currp, row_size);
-	memcpy(destp + dst_pitch * (height - 1),
-		currp + src_pitch * (height - 1), row_size);
-
-	// skip one line		
-	currp += src_pitch;
-	prevp += src_pitch;
-	nextp += src_pitch;
-	destp += dst_pitch;
-	
-	DoFilter_C(currp, prevp, nextp, src_pitch,
-			destp, dst_pitch, row_size, height - 2);
-	// U
- 
-	
-	dst_pitch = _info.width>>1;
-	src_pitch = _info.width>>1;
-  row_size  = _info.width>>1;
-	height = _info.height>>1;
-	
-	currp = UPLANE(image);
-	prevp = UPLANE(prev);
-	nextp = UPLANE(next);
-	destp = UPLANE(data);;
-
-	memcpy(destp, currp, row_size);
-	memcpy(destp + dst_pitch * (height - 1),
-		currp + src_pitch * (height - 1), row_size);
-
-	currp += src_pitch;
-	prevp += src_pitch;
-	nextp += src_pitch;
-	destp += dst_pitch;
-
-		DoFilter_C(currp, prevp, nextp, src_pitch,
-			destp, dst_pitch, row_size, height - 2);
-
-	// V
-
-  plane=(_info.width*_info.height*5)>>2;
-	
-	dst_pitch = _info.width>>1;
-	src_pitch = _info.width>>1;
-  row_size  = _info.width>>1;
-	height = _info.height>>1;
-	
-	currp = VPLANE(image);
-	prevp = VPLANE(prev);
-	nextp = VPLANE(next);
-	destp = VPLANE(data);;
-
-	memcpy(destp, currp, row_size);
-	memcpy(destp + dst_pitch * (height - 1),
-		currp + src_pitch * (height - 1), row_size);
-
-	currp += src_pitch;
-	prevp += src_pitch;
-	nextp += src_pitch;
-	destp += dst_pitch;
-
-	#if (defined( ARCH_X86)  || defined(ARCH_X86_64)) && defined(ASM_FLUX)
-        if(CpuCaps::hasMMX())
-        {
-		DoFilter_MMX(currp, prevp, nextp, src_pitch,
-			destp, dst_pitch, row_size, height - 2);
-	}else
-	#endif
-        {
-		DoFilter_C(currp, prevp, nextp, src_pitch,
-			destp, dst_pitch, row_size, height - 2);
-        }
-	
-	data->copyInfo(image);
-	vidCache->unlockAll();
-	return 1;
-}	                           
-
-
-void ADMVideoFlux::DoFilter_C(
- uint8_t * currp, 
- uint8_t * prevp,								  								  
- uint8_t * nextp, 
- int src_pitch,
- uint8_t * destp, 
- int dst_pitch,
- int row_size, 
- int height)
-{
-
-	 int skip = src_pitch - row_size + 1,
-		dskip = dst_pitch - row_size + 1;
-	int ycnt = height;
-
-	do
-	{
-		*destp = *currp; // Copy left edge
-
-		++currp;
-		++prevp;
-		++nextp;
-		++destp;
-
-		int xcnt = row_size - 2;
-
-		do
-		{
-			int pbt = *prevp++, b = *currp, nbt = *nextp++;
-			int pdiff = pbt - b, ndiff = nbt - b;
-			if((pdiff < 0 && ndiff < 0) || (pdiff > 0 && ndiff > 0))
-			{
-				int pb1 = currp[-src_pitch - 1], pb2 = currp[-src_pitch],
-					pb3 = currp[-src_pitch + 1], b1 = currp[-1], b2 = currp[1],
-					nb1 = currp[src_pitch - 1], nb2 = currp[src_pitch],
-					nb3 = currp[src_pitch + 1], sum = b, cnt = 1;
-
-				if(abs(pbt - b) <= _param->temporal_threshold)
-				{
-					sum += pbt;
-					++cnt;
-				}
-				if(abs(nbt - b) <= _param->temporal_threshold)
-				{
-					sum += nbt;
-					++cnt;
-				}
-				if(abs(pb1 - b) <= _param->spatial_threshold)
-				{
-					sum += pb1;
-					++cnt;
-				}
-				if(abs(pb2 - b) <= _param->spatial_threshold)
-				{
-					sum += pb2;
-					++cnt;
-				}
-				if(abs(pb3 - b) <= _param->spatial_threshold)
-				{
-					sum += pb3;
-					++cnt;
-				}
-				if(abs(b1 - b) <= _param->spatial_threshold)
-				{
-					sum += b1;
-					++cnt;
-				}
-				if(abs(b2 - b) <= _param->spatial_threshold)
-				{
-					sum += b2;
-					++cnt;
-				}
-				if(abs(nb1 - b) <= _param->spatial_threshold)
-				{
-					sum += nb1;
-					++cnt;
-				}
-				if(abs(nb2 - b) <= _param->spatial_threshold)
-				{
-					sum += nb2;
-					++cnt;
-				}
-				if(abs(nb3 - b) <= _param->spatial_threshold)
-				{
-					sum += nb3;
-					++cnt;
-				}
-
-				ADM_assert(sum >= 0);
-				ADM_assert(sum < 2806);
-				ADM_assert(cnt > 0);
-				ADM_assert(cnt < 12);
-
-				*destp++ = (uint8_t )(((sum * 2 + cnt) * scaletab[cnt]) >> 16);
-				++currp;
-			} else
-				*destp++ = *currp++;
-		} while(--xcnt);
-		ADM_assert(xcnt == 0);
-
-		*destp = *currp; // Copy right edge
-
-		currp += skip;
-		prevp += skip;
-		nextp += skip;
-		destp += dskip;
-	} while(--ycnt);
-	ADM_assert(ycnt == 0);
-
-}
-#if (defined( ARCH_X86)  || defined(ARCH_X86_64))
-/*
-	__asm movq mm2, mm0 \
-	__asm movq mm3, mm1 \
-	__asm psubusw mm2, mm1 \
-	__asm psubusw mm3, mm0 \
-	__asm por mm2, mm3				/  mm2 = abs diff  / \
-	__asm pcmpgtw mm2, threshold	/  Compare with threshold  / \
-	__asm paddw mm6, mm2			/  -1 from counter if not within  / \
-	__asm pandn mm2, mm1 \
-	__asm paddw mm5, mm2			/  Add to sum  / \
-*/
-#define CHECK_AND_ADD(threshold) " movq %%mm0, %%mm2 \n\t" \
-"movq    %%mm1, %%mm3 \n\t" \
-"psubusw %%mm1, %%mm2 \n\t" \
-"psubusw %%mm0, %%mm3 \n\t" \
-"por     %%mm3, %%mm2				\n\t" /* mm2 = abs diff */ \
-"pcmpgtw "Mangle(threshold)", %%mm2	\n\t "/* Compare with threshold */ \
-"paddw   %%mm2, %%mm6	\n\t	"/* -1 from counter if not within */ \
-"pandn   %%mm1, %%mm2 \n\t" \
-"paddw   %%mm2, %%mm5	\n\t" /* Add to sum */ 
-
-#define EXPAND(x) { x=x+(x<<8)+(x<<16)+(x<<24)+(x<<32)+(x<<40) \
-										+(x<<48);}
-
-
-void ADMVideoFlux::DoFilter_MMX(
-uint8_t * currp, 
- uint8_t * prevp,
- uint8_t * nextp, 
- int src_pitch,
- uint8_t * destp, 
- int dst_pitch,
- int row_size, 
- int height)
-{
-	  _l_xmax = row_size - 4;
-	 	ycnt 		= height;
-	
-	
-	_l_currp = currp;
-  _l_prevp = prevp;								  								  
-  _l_nextp = nextp;  
-  _l_destp = destp; 
- 	_l_src_pitch =src_pitch;
-  _l_dst_pitch =dst_pitch;
- 
-		_l_counter_init = 0x000b000b000b000bLL,
-		_l_indexer = 0x1000010000100001LL;
-		
-		spat_thresh = _param->spatial_threshold;
-		temp_thresh = _param->temporal_threshold;
-		EXPAND( spat_thresh);
-		EXPAND( temp_thresh);
-
-UNUSED_ARG(_l_prev_pels);
-UNUSED_ARG(_l_next_pels);
-asm(
-"								 mov (%0),"REG_si" \n\t"
-"                mov "Mangle(_l_currp)", "REG_si" \n\t"
-"                mov "Mangle(_l_destp)", "REG_di" \n\t"
-"                pxor %%mm7,%%mm7 \n\t"
-" \n\t"
-"yloop%=:  \n\t"
-"                # Copy first dword \n\t"
-" \n\t"
-"                mov ("REG_si"),"REG_ax" \n\t"
-"                mov "REG_ax",("REG_di") \n\t"
-" \n\t"
-"                mov $4,"REG_cx" \n\t"
-" \n\t"
-"xloop%=:  \n\t"
-"                # Get current pels, init sum and counter \n\t"
-" \n\t"
-"                movd ("REG_si","REG_cx"),%%mm0 \n\t"
-"                punpcklbw %%mm7,%%mm0 \n\t"
-"                movq %%mm0,%%mm5 \n\t"
-"                movq "Mangle(_l_counter_init)",%%mm6 \n\t"
-" \n\t"
-"                # Middle left \n\t"
-" \n\t"
-"                movq %%mm0,%%mm1 \n\t"
-"                psllq $16,%%mm1 \n\t"
-"                movd -4("REG_si","REG_cx"),%%mm2 \n\t"
-"                punpcklbw %%mm7,%%mm2 \n\t"
-"                psrlq $48,%%mm2 \n\t"
-"                por %%mm2,%%mm1 \n\t"
-" \n\t"
-CHECK_AND_ADD(spat_thresh)
-" \n\t"
-"                # Middle right \n\t"
-" \n\t"
-"                movq %%mm0,%%mm1 \n\t"
-"                psrlq $16,%%mm1 \n\t"
-"                movd 4("REG_si","REG_cx"),%%mm2 \n\t"
-"                punpcklbw %%mm7,%%mm2 \n\t"
-"                psllq $48,%%mm2 \n\t"
-"                por %%mm2,%%mm1 \n\t"
-" \n\t"
-CHECK_AND_ADD(spat_thresh)
-" \n\t"
-"                # Top left \n\t"
-" \n\t"
-"                mov "REG_si","REG_ax" \n\t"
-"                sub "Mangle(_l_src_pitch)", "REG_ax" \n\t"
-"                movd ("REG_ax","REG_cx"),%%mm1 \n\t"
-"                punpcklbw %%mm7,%%mm1 \n\t"
-"                psllq $16,%%mm1 \n\t"
-"                movd -4("REG_ax","REG_cx"),%%mm2 \n\t"
-"                punpcklbw %%mm7,%%mm2 \n\t"
-"                psrlq $48,%%mm2 \n\t"
-"                por %%mm2,%%mm1 \n\t"
-" \n\t"
-CHECK_AND_ADD(spat_thresh)
-" \n\t"
-"                # Top centre \n\t"
-" \n\t"
-"                movd ("REG_ax","REG_cx"),%%mm1 \n\t"
-"                punpcklbw %%mm7,%%mm1 \n\t"
-" \n\t"
-CHECK_AND_ADD(spat_thresh)
-" \n\t"
-"                # Top right \n\t"
-" \n\t"
-"                psrlq $16,%%mm1 \n\t"
-"                movd 4("REG_ax","REG_cx"),%%mm2 \n\t"
-"                punpcklbw %%mm7,%%mm2 \n\t"
-"                psllq $48,%%mm2 \n\t"
-"                por %%mm2,%%mm1 \n\t"
-" \n\t"
-CHECK_AND_ADD(spat_thresh)
-" \n\t"
-"                # Bottom left \n\t"
-" \n\t"
-"                mov "REG_si","REG_ax" \n\t"
-"                add "Mangle(_l_src_pitch)", "REG_ax" \n\t"
-"                movd ("REG_ax","REG_cx"),%%mm1 \n\t"
-"                punpcklbw %%mm7,%%mm1 \n\t"
-"                psllq $16,%%mm1 \n\t"
-"                movd -4("REG_ax","REG_cx"),%%mm2 \n\t"
-"                punpcklbw %%mm7,%%mm2 \n\t"
-"                psrlq $48,%%mm2 \n\t"
-"                por %%mm2,%%mm1 \n\t"
-" \n\t"
-CHECK_AND_ADD(spat_thresh)
-" \n\t"
-"                # Bottom centre \n\t"
-" \n\t"
-"                movd ("REG_ax","REG_cx"),%%mm1 \n\t"
-"                punpcklbw %%mm7,%%mm1 \n\t"
-" \n\t"
-CHECK_AND_ADD(spat_thresh)
-" \n\t"
-"                # Bottom right \n\t"
-" \n\t"
-"                psrlq $16,%%mm1 \n\t"
-"                movd 4("REG_ax","REG_cx"),%%mm2 \n\t"
-"                punpcklbw %%mm7,%%mm2 \n\t"
-"                psllq $48,%%mm2 \n\t"
-"                por %%mm2,%%mm1 \n\t"
-" \n\t"
-CHECK_AND_ADD(spat_thresh)
-" \n\t"
-"                # Previous frame \n\t"
-" \n\t"
-"                mov "Mangle(_l_prevp)", "REG_ax" \n\t"
-"                movd ("REG_ax","REG_cx"),%%mm1 \n\t"
-"                punpcklbw %%mm7,%%mm1 \n\t"
-"                movq %%mm1, "Mangle(_l_prev_pels)" \n\t"
-" \n\t"
-CHECK_AND_ADD(temp_thresh)
-" \n\t"
-"                # Next frame \n\t"
-" \n\t"
-"                mov "Mangle(_l_nextp)", "REG_ax" \n\t"
-"                movd ("REG_ax","REG_cx"),%%mm1 \n\t"
-"                punpcklbw %%mm7,%%mm1 \n\t"
-"                movq %%mm1, "Mangle(_l_next_pels)" \n\t"
-" \n\t"
-CHECK_AND_ADD(temp_thresh)
-" \n\t"
-"                # Average \n\t"
-" \n\t"
-"                psllw $1,%%mm5                                  # sum *= 2 \n\t"
-"                paddw %%mm6,%%mm5                               # sum += count \n\t"
-" \n\t"
-"                pmaddwd "Mangle(_l_indexer)",%%mm6                  # Make index into lookup \n\t"
-"                movq %%mm6,%%mm1 \n\t"
-"                punpckhdq %%mm6,%%mm6 \n\t"
-"                mov "Mangle(scaletab_MMX)", "REG_ax" \n\t"
-"                paddd %%mm6,%%mm1 \n\t"
-"                movd %%mm1,"REG_bx" \n\t"
-" \n\t"
-"            movq ("REG_ax","REG_bx",8),%%mm2          # Do lookup \n\t"
-"            pmulhw %%mm2,%%mm5                                  # mm5 = average \n\t"
-" \n\t"
-"                # Apply smoothing only to fluctuating pels \n\t"
-" \n\t"
-"                movq %%mm0,%%mm1 \n\t"
-"                movq "Mangle(_l_prev_pels)",%%mm2 \n\t"
-"                movq %%mm0,%%mm3 \n\t"
-"                movq "Mangle(_l_next_pels)",%%mm4 \n\t"
-" \n\t"
-"                pcmpgtw %%mm2,%%mm1                             # curr > prev \n\t"
-"                pcmpgtw %%mm4,%%mm3                             # curr > next \n\t"
-"                pcmpgtw %%mm0,%%mm2                             # prev > curr \n\t"
-"                pcmpgtw %%mm0,%%mm4                             # next > curr \n\t"
-" \n\t"
-"                pand %%mm3,%%mm1                                # (curr > prev) and (curr > next) \n\t"
-"                pand %%mm4,%%mm2                                # (prev > curr) and (next > curr) \n\t"
-"                por %%mm2,%%mm1                                 # mm1 = FFh if fluctuating, else 00h \n\t"
-" \n\t"
-"                movq %%mm1,%%mm2 \n\t"
-"                pand %%mm5,%%mm1                                # mm1 = smoothed pels \n\t"
-"                pandn %%mm0,%%mm2                               # mm2 = unsmoothed pels \n\t"
-"                por %%mm2,%%mm1                                 # mm1 = result \n\t"
-" \n\t"
-"                # Store \n\t"
-" \n\t"
-"                packuswb %%mm7,%%mm1 \n\t"
-"                movntq %%mm1,("REG_di","REG_cx") \n\t"
-" \n\t"
-"                # Advance \n\t"
-" \n\t"
-"                add $4,"REG_cx" \n\t"
-"                cmp "Mangle(_l_xmax)", "REG_cx" \n\t"
-"                jl xloop%= \n\t"
-" \n\t"
-"                # Copy last dword \n\t"
-" \n\t"
-"                mov ("REG_si","REG_cx"),"REG_ax" \n\t"
-"                mov "REG_ax",("REG_di","REG_cx") \n\t"
-" \n\t"
-"                # Next row \n\t"
-" \n\t"
-"                add "Mangle(_l_src_pitch)", "REG_si" \n\t"
-"                mov "Mangle(_l_prevp)", "REG_ax" \n\t"
-"                add "Mangle(_l_src_pitch)", "REG_ax" \n\t"
-"                mov "REG_ax", "Mangle(_l_prevp)" \n\t"
-"                mov "Mangle(_l_nextp)", "REG_bx" \n\t"
-"                add "Mangle(_l_src_pitch)", "REG_bx" \n\t"
-"                mov "REG_bx", "Mangle(_l_nextp)" \n\t"
-"                add "Mangle(_l_dst_pitch)", "REG_di" \n\t"
-" \n\t"
-"                sub $1, "Mangle(ycnt)" \n\t"
-"                jnz yloop%= \n\t"
-" \n\t"
-//"MISMATCH: "                sfence" \n\t"
-"                emms \n\t"
-" \n\t"
-
- : : "r"(_l_src_pitch) );
-}
-#endif
-//

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFlux.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFlux.h	2007-01-08 21:29:24 UTC (rev 2696)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFlux.h	2007-01-09 19:54:42 UTC (rev 2697)
@@ -1,58 +0,0 @@
-/***************************************************************************
-                          ADM_vidFlux.h  -  description
-                             -------------------
-    begin                : Tue Dec 31 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
- 
-#ifndef __FLUX__
-#define __FLUX__   
-#include "ADM_video/ADM_cache.h"
-typedef struct FLUX_PARAM
-{
-	uint32_t temporal_threshold;
-	uint32_t spatial_threshold;
-	
-}FLUX_PARAM;
-
-class  ADMVideoFlux:public AVDMGenericVideoStream
- {
-
- protected:
-    	
-        			FLUX_PARAM		*_param;
-
-				void DoFilter_C( uint8_t * currp,  uint8_t * prevp, uint8_t * nextp, 
-							 int src_pitch, uint8_t * destp,  int dst_pitch,
-							 int row_size,  int height);
-				void DoFilter_MMX( uint8_t * currp,  uint8_t * prevp, uint8_t * nextp, 
-							 int src_pitch, uint8_t * destp,  int dst_pitch,
-							 int row_size,  int height);	 
-				int32_t num_frame;
-		 		VideoCache		*vidCache;
-			
- public:
- 		
-
-						ADMVideoFlux(  AVDMGenericVideoStream *in,CONFcouple *setup);
-
-  						 ~ADMVideoFlux();
-		        virtual uint8_t 	getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-          						ADMImage *data,uint32_t *flags);
-
-			virtual uint8_t 	configure( AVDMGenericVideoStream *instream);
-     			virtual char 		*printConf(void);
-			virtual uint8_t 	getCoupledConf( CONFcouple **couples);
-							
- }     ;
-#endif

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMsmooth.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMsmooth.cpp	2007-01-08 21:29:24 UTC (rev 2696)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMsmooth.cpp	2007-01-09 19:54:42 UTC (rev 2697)
@@ -1,816 +0,0 @@
-/***************************************************************************
-                          ADM_vidMsmooth  -  description
-                             -------------------
-    
-    email                : fixounet at free.fr
-
-    Port of Donal Graft MSMooth which is (c) Donald Graft
-    http://www.neuron2.net
-    http://puschpull.org/avisynth/decomb_reference_manual.html
-
- ***************************************************************************/
-/*
-	MSmooth plugin for Avisynth -- performs detail-preserving smoothing.
-
-	Copyright (C) 2003 Donald A. Graft
-
-	This program is free software; you can redistribute it and/or modify
-	it under the terms of the GNU General Public License as published by
-	the Free Software Foundation.
-
-	This program is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-	GNU General Public License for more details.
-
-	You should have received a copy of the GNU General Public License
-	along with this program; if not, write to the Free Software
-	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-*/
-
-#include "config.h"
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <ADM_assert.h>
-
-#include "config.h"
-#include "fourcc.h"
-#include "avio.hxx"
-#include "avi_vars.h"
-
-#include "ADM_toolkit/toolkit.hxx"
-#include "ADM_editor/ADM_edit.hxx"
-#include "ADM_video/ADM_genvideo.hxx"
-#include"ADM_video/ADM_vidField.h"
-#include"ADM_video/ADM_cache.h"
-
-#include "ADM_osSupport/ADM_debugID.h"
-#define MODULE_NAME MODULE_FILTER
-#include "ADM_osSupport/ADM_debug.h"
-
-#include "ADM_osSupport/ADM_cpuCap.h"
-#include "ADM_filter/video_filters.h"
-#ifdef HAVE_ALTIVEC_H
-#include "altivec.h"
-#endif
-#if 0
-#undef aprintf
-#define aprintf printf
-#endif
-#define GETFRAME(g, fp) \
-{ \
-	int GETFRAMEf; \
-	GETFRAMEf = (g); \
-	if (GETFRAMEf < 0) GETFRAMEf = 0; \
-	if (GETFRAMEf > num_frames_hi - 1) GETFRAMEf = num_frames_hi - 1; \
-	(fp) = vidCache->getImage(GETFRAMEf); \
-}
-
-#include "ADM_video/ADM_vidMSmooth_param.h"
-
-extern uint8_t DIA_getMSmooth(MSMOOTH_PARAM *param);
-extern uint8_t 	PutHintingData(unsigned char *video, unsigned int hint);
-extern uint8_t 	GetHintingData(unsigned char *video, unsigned int *hint);
-extern void 	BitBlt(uint8_t * dstp, int dst_pitch, const uint8_t* srcp,
-            		int src_pitch, int row_size, int height);
-//extern  void 	DrawString(uint8_t *dst, int x, int y, const char *s);
-//extern  void    DrawString(ADMImage *dst, int x, int y, const char *s);
-//#define DrawString(a,b,c,d) DrawString(NULL,b,c,d)
-#define DrawString drawString
-
-extern  void 	DrawStringYUY2(uint8_t *dst, int x, int y, const char *s); 
-
-static void Blur_C(uint8_t *in, uint8_t *out, uint32_t w, uint32_t h) ;
-#ifdef HAVE_ALTIVEC
-void Blur_Altivec(uint8_t *in, uint8_t *out, uint32_t w, uint32_t h);
-#endif
-#if (defined( ARCH_X86)  || defined(ARCH_X86_64))
-void Blur_MMX(uint8_t *in, uint8_t *out, uint32_t w, uint32_t h);
-#endif
-class Msmooth : public AVDMGenericVideoStream
-{
-private:
-	MSMOOTH_PARAM	*_param;
-	VideoCache	*vidCache;
-	uint8_t		show, debug;
-	ADMImage 	*blur,*work,*mask,*final,*final2;
-public:    
-
-			Msmooth(AVDMGenericVideoStream *in,CONFcouple *couples)   ;
-			~Msmooth();
-    	uint8_t 	*GetFrameYV12(int n);
-	void  		SmoothingPassYV12(const unsigned char *srcp, unsigned char *maskp, unsigned char *workp,
-				unsigned char *finalp,int row_size, int height, int spitch, int dpitch);
-	void 		EdgeMaskYV12(const unsigned char *srcp, unsigned char *blurp, unsigned char *workp,
-				 unsigned char *maskp,int row_size, int height, int src_pitch, int blur_pitch);
-				 
-	char 		*printConf( void );
-	uint8_t 	configure(AVDMGenericVideoStream *in);
-	uint8_t		getCoupledConf( CONFcouple **couples);
-	uint8_t 	getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-				ADMImage *data,uint32_t *flags);
-};
-
-BUILD_CREATE(create_msmooth,Msmooth);
-static FILTER_PARAM msmoothParam={4,{"showmask", "highq","threshold", "strength"}};
-
-
-SCRIPT_CREATE(msmooth_script,Msmooth,msmoothParam);
-//_______________________________________________
-
-Msmooth::Msmooth(AVDMGenericVideoStream *in,CONFcouple *couples)
-
-{
-	_in=in;		
-   	memcpy(&_info,_in->getInfo(),sizeof(_info));    
-  	_info.encoding=1;
-	_uncompressed=NULL;		
-  	_info.encoding=1;
-	show=0;
-	debug=0;
-	_param=new MSMOOTH_PARAM;
-	//
-	if(couples)
-		{
-			GET(showmask);
-			GET(threshold);
-			GET(highq);
-			GET(strength);	
-		}
-		else // Default
-  		{
-			_param->showmask=0;
-			_param->threshold=15;
-			_param->strength=3;
-			_param->highq=1;			
-		}
-		
-	uint32_t sz=(_info.width*_info.height*3)>>1;
-	#define NW(x) x=new ADMImage(_info.width,_info.height);ADM_assert(x);
-	NW(blur);
-	NW(work);
-	NW(mask);
-	NW(final);
-	NW(final2);
-	
-    	vidCache=new VideoCache(5,in);
-}
-//________________________________________________________
-uint8_t	Msmooth::getCoupledConf( CONFcouple **couples)
-{
-	*couples=NULL;
-	*couples=new CONFcouple(4);
-#define CSET(x)  (*couples)->setCouple((char *)#x,(_param->x))
-	CSET(showmask);
-	CSET(threshold);
-	CSET(highq);
-	CSET(strength);	
-	
-	return 1;
-}
-//________________________________________________________
-Msmooth::~Msmooth(void)
-{
-
-	if(vidCache) delete vidCache;
-	if(_param) delete _param;
-#undef NW
-#define NW(x) if(x) {delete  x;x=NULL;}
-	NW(blur);
-	NW(work);
-	NW(mask);
-	NW(final);
-	NW(final2);
-}
-//________________________________________________________
-uint8_t Msmooth::configure(AVDMGenericVideoStream *in)
-{
-	_in=in;
-	ADM_assert(_param);
-	//return  DIA_getDecombDecimate(_param);
-	//return 1;
-	return DIA_getMSmooth(_param);
-	
-}
-
-//________________________________________________________
-char *Msmooth::printConf( void )
-{
- 	static char buf[50];
-
-	ADM_assert(_param);
- 	sprintf((char *)buf," Donald Graft MSmooth");
-        return buf;
-}
-	
-//________________________________________________________
-uint8_t Msmooth::getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-				ADMImage *data,uint32_t *flags)
-{
-    ADMImage *src = vidCache->getImage(frame);
-   
-    ADMImage * deliver;
-
-	const unsigned char *srcpY = YPLANE(src) ;
-	const unsigned char *srcp_savedY = srcpY;
-    	int src_pitchY = _info.width;
-	
-	const unsigned char *srcpU =UPLANE(src);
-	const unsigned char *srcp_savedU = srcpU;
-    	int src_pitchUV = _info.width>>1;
-	const unsigned char *srcpV =VPLANE(src);
-	const unsigned char *srcp_savedV = srcpV;
-
-    	unsigned char *blurpY = YPLANE(blur);//
-	unsigned char *blurp_savedY = blurpY;
-    	int blur_pitchY =  _info.width;
-    	unsigned char *blurpU = UPLANE(blur);
-	unsigned char *blurp_savedU = blurpU;
-    	int blur_pitchUV = _info.width>>1;
-    	unsigned char *blurpV = VPLANE(blur);
-	unsigned char *blurp_savedV = blurpV;
-
-    unsigned char *workpY = YPLANE(work); //->GetWritePtr(PLANAR_Y);
-	unsigned char *workp_savedY = workpY;
-    unsigned char *workpU = UPLANE(work);
-	unsigned char *workp_savedU = workpU;
-    unsigned char *workpV = VPLANE(work);
-	unsigned char *workp_savedV = workpV;
-
-    unsigned char *maskpY = YPLANE(mask); //->GetWritePtr(PLANAR_Y);
-	unsigned char *maskp_savedY = maskpY;
-    unsigned char *maskpU = UPLANE(mask);
-	unsigned char *maskp_savedU = maskpU;
-    unsigned char *maskpV = VPLANE(mask);
-	unsigned char *maskp_savedV = maskpV;
-
-    unsigned char *finalpY = YPLANE(final);//->GetWritePtr(PLANAR_Y);
-	unsigned char *finalp_savedY = finalpY;
-    unsigned char *finalpU = UPLANE(final);
-	unsigned char *finalp_savedU = finalpU;
-    unsigned char *finalpV = VPLANE(final);
-	unsigned char *finalp_savedV = finalpV;
-
-    unsigned char *finalp2Y = YPLANE(final2); //->GetWritePtr(PLANAR_Y);
-	unsigned char *finalp2_savedY = finalp2Y;
-    unsigned char *finalp2U = UPLANE(final2);
-	unsigned char *finalp2_savedU = finalp2U;
-    unsigned char *finalp2V = VPLANE(final2);
-	unsigned char *finalp2_savedV = finalp2V;
-
-    int row_sizeY = _info.width;//blur->GetRowSize(PLANAR_Y);
-    int row_sizeUV = _info.width>>1;//blur->GetRowSize(PLANAR_U);
-    int heightY = _info.height;//blur->GetHeight(PLANAR_Y);
-    int heightUV = _info.height>>1;//blur->GetHeight(PLANAR_U);
-	int y, reps;
-
-	/* Create the detail mask. */
-	EdgeMaskYV12(srcpY, blurpY, workpY, maskpY, row_sizeY, heightY, src_pitchY, blur_pitchY);
-	EdgeMaskYV12(srcpU, blurpU, workpU, maskpU, row_sizeUV, heightUV, src_pitchUV, blur_pitchUV);
-	EdgeMaskYV12(srcpV, blurpV, workpV, maskpV, row_sizeUV, heightUV, src_pitchUV, blur_pitchUV);
-
-	if (_param->showmask == true)
-	{
-		if (show == true)
-		{
-			char buf[80];
-			//env->MakeWritable(&mask);
-			sprintf(buf, "0.2 beta");
-			DrawString(mask, 0, 0, buf);
-			sprintf(buf, "From Donald Graft");
-			DrawString(mask, 0, 1, buf);
-		}
-		//return mask;
-		memcpy(data->data,mask->data,(_info.width*_info.height*3)>>1);
-		data->copyInfo(src);
-		vidCache->unlockAll();
-		return 1;
-	}
-
-	/* Fix up output frame borders. */
-	srcpY = srcp_savedY;
-	finalpY = finalp_savedY;
-	finalp2Y = finalp2_savedY;
-	memcpy(finalpY, srcpY, row_sizeY);
-	memcpy(finalpY + (heightY-1)*blur_pitchY, srcpY + (heightY-1)*blur_pitchY, row_sizeY);
-	memcpy(finalp2Y, srcpY, row_sizeY);
-	memcpy(finalp2Y + (heightY-1)*blur_pitchY, srcpY + (heightY-1)*blur_pitchY, row_sizeY);
-	for (y = 0; y < heightY; y++)
-	{
-		finalpY[0] = finalp2Y[0] = srcpY[0];
-		finalpY[row_sizeY-1] = finalp2Y[row_sizeY-1] = srcpY[row_sizeY-1];
-		srcpY += src_pitchY;
-		finalpY += blur_pitchY;
-		finalp2Y += blur_pitchY;
-	}
-	srcpU = srcp_savedU;
-	finalpU = finalp_savedU;
-	finalp2U = finalp2_savedU;
-	memcpy(finalpU, srcpU, row_sizeUV);
-	memcpy(finalpU + (heightUV-1)*blur_pitchUV, srcpU + (heightUV-1)*blur_pitchUV, row_sizeUV);
-	memcpy(finalp2U, srcpU, row_sizeUV);
-	memcpy(finalp2U + (heightUV-1)*blur_pitchUV, srcpU + (heightUV-1)*blur_pitchUV, row_sizeUV);
-	for (y = 0; y < heightUV; y++)
-	{
-		finalpU[0] = finalp2U[0] = srcpU[0];
-		finalpU[row_sizeUV-1] = finalp2U[row_sizeUV-1] = srcpU[row_sizeUV-1];
-		srcpU += src_pitchUV;
-		finalpU += blur_pitchUV;
-		finalp2U += blur_pitchUV;
-	}
-	srcpV = srcp_savedV;
-	finalpV = finalp_savedV;
-	finalp2V = finalp2_savedV;
-	memcpy(finalpV, srcpV, row_sizeUV);
-	memcpy(finalpV + (heightUV-1)*blur_pitchUV, srcpV + (heightUV-1)*blur_pitchUV, row_sizeUV);
-	memcpy(finalp2V, srcpV, row_sizeUV);
-	memcpy(finalp2V + (heightUV-1)*blur_pitchUV, srcpV + (heightUV-1)*blur_pitchUV, row_sizeUV);
-	for (y = 0; y < heightUV; y++)
-	{
-		finalpV[0] = finalp2V[0] = srcpV[0];
-		finalpV[row_sizeUV-1] = finalp2V[row_sizeUV-1] = srcpV[row_sizeUV-1];
-		srcpV += src_pitchUV;
-		finalpV += blur_pitchUV;
-		finalp2V += blur_pitchUV;
-	}
-
-	/* Masked smoothing. */
-	reps = 0;
-	SmoothingPassYV12(srcp_savedY, maskp_savedY, workp_savedY, finalp_savedY, row_sizeY, heightY, src_pitchY, blur_pitchY);
-//	env->BitBlt(finalp_savedU, blur_pitchUV, srcp_savedU, src_pitchUV, row_sizeUV, heightUV);
-//	env->BitBlt(finalp_savedV, blur_pitchUV, srcp_savedV, src_pitchUV, row_sizeUV, heightUV);
-	SmoothingPassYV12(srcp_savedU, maskp_savedU, workp_savedU, finalp_savedU, row_sizeUV, heightUV, src_pitchUV, blur_pitchUV);
-	SmoothingPassYV12(srcp_savedV, maskp_savedV, workp_savedV, finalp_savedV, row_sizeUV, heightUV, src_pitchUV, blur_pitchUV);
-	if (++reps >= _param->strength)
-	{
-		deliver = final;
-		goto done;
-	}
-	while (1)
-	{
-		SmoothingPassYV12(finalp_savedY, maskp_savedY, workp_savedY, finalp2_savedY, row_sizeY, heightY, blur_pitchY, blur_pitchY);
-		SmoothingPassYV12(finalp_savedU, maskp_savedU, workp_savedU, finalp2_savedU, row_sizeUV, heightUV, blur_pitchUV, blur_pitchUV);
-		SmoothingPassYV12(finalp_savedV, maskp_savedV, workp_savedV, finalp2_savedV, row_sizeUV, heightUV, blur_pitchUV, blur_pitchUV);
-		if (++reps >=  _param->strength)
-		{
-			deliver = final2;
-			goto done;
-		}
-		SmoothingPassYV12(finalp2_savedY, maskp_savedY, workp_savedY, finalp_savedY, row_sizeY, heightY, blur_pitchY, blur_pitchY);
-		SmoothingPassYV12(finalp2_savedU, maskp_savedU, workp_savedU, finalp_savedU, row_sizeUV, heightUV, blur_pitchUV, blur_pitchUV);
-		SmoothingPassYV12(finalp2_savedV, maskp_savedV, workp_savedV, finalp_savedV, row_sizeUV, heightUV, blur_pitchUV, blur_pitchUV);
-		if (++reps >=  _param->strength)
-		{
-			deliver = final;
-			goto done;
-		}
-	}
-
-done:
-	if (show == true)
-	{
-		char buf[80];
-		//env->MakeWritable(&deliver);
-		sprintf(buf, "0.2beta");
-		DrawString(deliver, 0, 0, buf);
-		sprintf(buf, "Donald Graft");
-		DrawString(deliver, 0, 1, buf);
-	}
-	memcpy(data->data,deliver->data,(_info.width*_info.height*3)>>1);
-	//return(deliver);
-	data->copyInfo(src);
-	vidCache->unlockAll();
-	return 1;
-}
-
-
-#ifdef HAVE_ALTIVEC
-#define vecbyte vector unsigned char
-#define vect16 vector unsigned short
-
-#define LOAD_ALIGN(dest,src) \
-		dest = (vect16)vec_ld(0, src); 
-
-//______________________
-void Blur_Altivec(uint8_t *in, uint8_t *out, uint32_t w, uint32_t h)
-{
-uint8_t *srcp,*srcpn,*srcpp;
-uint8_t *workp;
-uint32_t x,y;
-int16_t  v16[8];
-
-    vect16 pp,pc,pn,res,res2;
-	vect16 rp,rc,rn,resl;
-	vect16 zero,deux;
-	
-	uint32_t off;
-	vector unsigned char MSQ,mask;
-	zero=vec_splat_u16(0);
-	deux=vec_splat_u16(2);
-
-	srcpp = in;
-	srcp  = srcpp + w;
-	srcpn = srcp + w;
-	workp = out + w;
-	for (y = 1; y < h - 1; y++)
-	{
-		for (x = 0; x < (w>>4); x++)
-		{
-			off=x<<4;
-			LOAD_ALIGN(pp,srcpp+off);
-			LOAD_ALIGN(pc,srcp+off);
-			LOAD_ALIGN(pn,srcpn+off);
-			
-			aprintf("sn %vd\n",pn); 
-			aprintf("sp %vd\n",pp);
-			aprintf("sc %vd\n",pc);
-		
-			
-			rp=(vect16)vec_mergel( (vecbyte)zero,(vecbyte)pp);
-			rn=(vect16)vec_mergel( (vecbyte)zero,(vecbyte)pn);
-			rc=(vect16)vec_mergel( (vecbyte)zero,(vecbyte)pc);
-			
-			aprintf("rn %vd\n",rn); 
-			aprintf("rp %vd\n",rp);
-			aprintf("rc %vd\n",rc);
-		
-			res=vec_add(rp,rc);
-			res2=vec_add(rc,rn);
-			
-			aprintf("re %vd\n",res);
-			aprintf("r2 %vd\n",res2);
-			
-			res=vec_add(res,res2);
-			
-			resl=vec_sr(res,deux);
-			aprintf("rS %vd\n",res);
-			aprintf("r2 %vd\n",res2);
-			aprintf("rl %vd\n",resl);
-									
-			pp=(vect16)vec_mergeh( (vecbyte)zero,(vecbyte)pp);
-			pn=(vect16)vec_mergeh( (vecbyte)zero,(vecbyte)pn);
-			pc=(vect16)vec_mergeh( (vecbyte)zero,(vecbyte)pc);
-			
-			res=vec_add(pp,pc);
-			res2=vec_add(pc,pn);
-			res=vec_add(res,res2);
-			res=vec_sr(res,deux);
-			
-			aprintf("rH %vd\n",res);
-			
-			res=(vect16)vec_pack(res,resl);
-			aprintf("rF %vd\n",res);
-			
-			vec_st((vecbyte)res,0,(vector unsigned char *)(workp+off));
-			
-		}
-		srcpp += w;
-        srcp += w;
-        srcpn += w;
-        workp += w;
-    }
-	// Do it at the end as it may have been scratched
-	// due to 16 byte alignment
-	memcpy(out, in, w);
-	memcpy(out + (h-1)*w, in + (h-1)*w, w);
-	
-}
-#endif
-
-#if (defined( ARCH_X86)  || defined(ARCH_X86_64))
-//______________________
-void Blur_MMX(uint8_t *in, uint8_t *out, uint32_t w, uint32_t h)
-{
-uint8_t *srcp,*srcpn,*srcpp;
-uint8_t *workp;
-uint32_t x,y;
-uint32_t off;
-	
-	srcpp = in;
-	srcp  = srcpp + w;
-	srcpn = srcp + w;
-	workp = out + w;
-	for (y = 1; y < h - 1; y++)
-	{
-		for (x =  (w>>3);x>0; x--)
-		{
-			off=x<<3;
-			
-			__asm__(
-			".align 16\n"
-			"pxor  %%mm7,%%mm7\n"
-			"movq  (%0),%%mm0\n"
-			"movq  %%mm0,%%mm6\n"
-			"punpckhbw %%mm7,%%mm0\n" // High part extended to 16 bits
-			"punpcklbw %%mm7,%%mm6\n" // low part ditto
-			
-			"movq  (%1),%%mm1\n"
-			"movq  %%mm1,%%mm5\n"
-			"punpckhbw %%mm7,%%mm1\n"
-			"punpcklbw %%mm7,%%mm5\n"
-			
-			"movq  (%2),%%mm2\n"
-			"movq  %%mm2,%%mm4\n"
-			"punpckhbw %%mm7,%%mm2\n"
-			"punpcklbw %%mm7,%%mm4\n"
-			
-			"paddw %%mm1,%%mm0\n"
-			"paddw %%mm5,%%mm6\n"
-			
-			"paddw %%mm1,%%mm2\n"
-			"paddw %%mm5,%%mm4\n"
-			
-			"paddw %%mm0,%%mm2\n"
-			"paddw %%mm6,%%mm4\n"
-			"psrlw $2, %%mm4\n"
-			"psrlw $2, %%mm2\n"
-			"packuswb %%mm2,%%mm4\n"
-			"movq %%mm4,(%3)\n" //
-			
-			: : "r" (srcpn+off),
-			   "r" (srcp+off), "r" (srcpp+off), "r" (workp+off)
-			);
-			
-		}
-		workp[0]=srcp[0];
-		workp[w-1]=srcp[w-1];
-		srcpp += w;
-        	srcp += w;
-        	srcpn += w;
-        	workp += w;
-    }
-	// Do it at the end as it may have been scratched
-	// due to 16 byte alignment
-	memcpy(out, in, w);
-	memcpy(out + (h-1)*w, in + (h-1)*w, w);
-	__asm__ ("emms\n" : :);
-	
-}
-#endif
-
-//______________________
-void Blur_C(uint8_t *in, uint8_t *out, uint32_t w, uint32_t h)
-{
-uint8_t *srcp,*srcpn,*srcpp;
-uint8_t *workp;
-uint32_t x,y;
-	srcpp = in;
-	srcp  = srcpp + w;
-	srcpn = srcp + w;
-	workp = out + w;
-	memcpy(out, in, w);
-	memcpy(out + (h-1)*w, in + (h-1)*w, w);
-	for (y = 1; y < h - 1; y++)
-	{
-		workp[0] = srcp[0];
-		workp[w-1] = srcp[w-1];
-        for (x = 1; x < w - 1; x++)
-		{
-			workp[x] = (srcpp[x] + srcp[x] + srcpn[x]) /3;
-		}
-        srcpp += w;
-        srcp += w;
-        srcpn += w;
-        workp += w;
-    }
-
-}
-//_______________________________
-void  Msmooth::EdgeMaskYV12(const unsigned char *srcp, unsigned char *blurp, unsigned char *workp, unsigned char *maskp,
-                        int row_size, int height, int src_pitch, int blur_pitch)
-{
-	const unsigned char *srcp_saved = srcp;
-	const unsigned char *srcpp;
-	const unsigned char *srcpn;
-
-	unsigned char *blurp_saved = blurp;
-	const unsigned char *blurpn;
-
-	unsigned char *workp_saved = workp;
-	unsigned char *workpp;
-	unsigned char *workpn;
-
-	unsigned char *maskp_saved = maskp;
-	int x, y;
-	int y1, y2, y3, y4;
-
-	/* Blur the source image prior to detail detection. */
-#if (defined( ARCH_X86)  || defined(ARCH_X86_64))
-		//printf("MMX\n");
-	if(CpuCaps::hasMMX())
-	{
-		Blur_MMX((uint8_t *)srcp,(uint8_t *)workp,row_size,height);
-		Blur_MMX((uint8_t *)workp,(uint8_t *)blurp,row_size,height);
-	}
-	else
-	#endif
-	#ifdef HAVE_ALTIVEC
-	#define ISALIGNED(x) (!( ((long long)x)&15 ))
-		if( ISALIGNED(srcp) && ISALIGNED(blurp) && ISALIGNED(workp) && ISALIGNED(maskp) && !(src_pitch&15))
-		{
-			Blur_Altivec((uint8_t *)srcp,(uint8_t *)workp,row_size,height);
-			Blur_Altivec((uint8_t *)workp,(uint8_t *)blurp,row_size,height);
-		}
-		else
-	#endif
-	{
-		Blur_C((uint8_t *)srcp,(uint8_t *)workp,row_size,height);
-		Blur_C((uint8_t *)workp,(uint8_t *)blurp,row_size,height);
-	}
-	/* Diagonal detail detection. */
-	blurp = (unsigned char *) workp_saved;
-	blurpn = blurp + blur_pitch;
-	maskp = maskp_saved;
-	y1 = blurp[0];
-	y3 = blurpn[0];
-	for (y = 0; y < height - 1; y++) 
-	{
-		for (x = 0; x < row_size - 1; x++)
-		{
-			y2 = blurp[x+1];
-			y4 = blurpn[x+1];
-			if ((abs(y1 - y4) >= _param->threshold) || (abs(y2 - y3) >= _param->threshold))
-			{
-				maskp[x] = 0xff;
-			}
-			else
-			{
-				maskp[x] = 0x0;
-			}
-			y1 = y2; y3 = y4;
-		}
-		maskp += blur_pitch;
-		blurp += blur_pitch;
-		blurpn += blur_pitch;
-	}
-
-	/* If set for high quality, also do horizontal and vertical
-	   detail detection. */
-	if ( _param->highq == true)
-	{
-		/* Msmooth convolve vertical. */
-		for (x = 0; x < row_size; x++)
-		{
- 			blurp = blurp_saved;
-			blurpn = blurp + blur_pitch;
-			maskp = maskp_saved;
-			y1 = blurp[x];
-			for (y = 0; y < height - 1; y++)
-			{
-				y2 = blurpn[x];
-				if (abs(y1 - y2) >= _param->threshold)
-				{
-					maskp[x] = 0xff;
-				}
-				y1 = y2;
-				maskp += blur_pitch;
-				blurp += blur_pitch;
-				blurpn += blur_pitch;
-			}
-		}
-
-		/* Msmooth convolve horizontal. */
-		blurp = blurp_saved;
-		maskp = maskp_saved;
-		for (y = 0; y < height; y++)
-		{
-			y1 = blurp[0];
-			for (x = 0; x < row_size - 1; x++)
-			{
-				y2 = blurp[x+1];
-				if (abs(y1 - y2) >= _param->threshold)
-				{
-					maskp[x] = 0xff;
-				}
-				y1 = y2;
-			}
-			maskp += blur_pitch;
-			blurp += blur_pitch;
-		}
-
-	}
-	/* Fix up detail map borders. */
-	maskp = maskp_saved;
-	memset(maskp, 0xff, row_size);
-	memset(maskp + (height-1)*blur_pitch, 0xff, row_size);
-	for (y = 0; y < height; y++)
-	{
-//		*((unsigned int *)(&maskp[0])) = 0xffffffff;
-//		*((unsigned int *)(&maskp[row_size-1])) = 0xffffffff;
-		maskp[0] = 0xff;
-		maskp[row_size-1] = 0xff;
-		maskp += blur_pitch;
-	}
-}
-
-void  Msmooth::SmoothingPassYV12(const unsigned char *srcp, unsigned char *maskp,
-									  unsigned char *workp, unsigned char *finalp,
-									  int row_size, int height, int spitch, int dpitch)
-{
-	const unsigned char *srcp_saved = srcp;
-	const unsigned char *srcpp;
-	const unsigned char *srcpn;
-
-	unsigned char *workp_saved = workp;
-	unsigned char *workpp;
-	unsigned char *workpn;
-
-	unsigned char *maskp_saved = maskp;
-	unsigned char *maskpp;
-	unsigned char *maskpn;
-
-	unsigned char *finalp_saved = finalp;
-
-	int x, y, ysum;
-
-	srcpp = srcp_saved;
- 	srcp = srcpp + spitch;
-	srcpn = srcp + spitch;
-	maskpp = maskp_saved;
- 	maskp = maskpp + dpitch;
-	maskpn = maskp + dpitch;
-	workp = workp_saved + dpitch;
-	memcpy(workp_saved, srcp_saved, row_size);
-	memcpy(workp_saved + (height-1)*dpitch, srcp_saved + (height-1)*spitch, row_size);
-	for (y = 1; y < height - 1; y++)
-	{
-		workp[0] = srcp[0];
-		workp[row_size-1] = srcp[row_size-1];
-        for (x = 1; x < row_size - 1; x++)
-		{
-			int count = 1;
-
-			if (!maskp[x])
-			{
-				ysum = srcp[x];
-				if (!maskpp[x])
-				{
-					ysum += srcpp[x];
-					count++;
-				}
-				if (!maskpn[x])
-				{
-					ysum += srcpn[x];
-					count++;
-				}
-				workp[x] = ysum / count;
-			}
-		}
-        srcpp += spitch;
-        srcp += spitch;
-        srcpn += spitch;
- 		maskpp += dpitch;
-		maskp += dpitch;
-		maskpn += dpitch;
-        workp += dpitch;
-    }
-	srcpp = srcp_saved;
- 	srcp = srcpp + spitch;
-	srcpn = srcp + spitch;
-	workpp = workp_saved;
- 	workp = workpp + dpitch;
-	workpn = workp + dpitch;
-	maskpp = maskp_saved;
- 	maskp = maskpp + dpitch;
-	maskpn = maskp + dpitch;
-	finalp = finalp_saved + dpitch;
-	for (y = 1; y < height - 1; y++)
-	{
-        for (x = 1; x < row_size - 1; x++)
-		{
-			int count = 1;
-
-			if (!maskp[x])
-			{
-				ysum = workp[x];
-				if (!maskp[x-1])
-				{
-					ysum += workp[x-1];
-					count++;
-				}
-				if (!maskp[x+1])
-				{
-					ysum += workp[x+1];
-					count++;
-				}
-				finalp[x] = ysum / count;
-			}
-			else
-			{
-				finalp[x] = srcp[x];
-			}
-		}
-        srcpp += spitch;
-        srcp += spitch;
-        srcpn += spitch;
-        workpp += dpitch;
-        workp += dpitch;
-        workpn += dpitch;
- 		maskpp += dpitch;
-		maskp += dpitch;
-		maskpn += dpitch;
-        finalp += dpitch;
-    }
-}
-

Modified: branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am	2007-01-08 21:29:24 UTC (rev 2696)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am	2007-01-09 19:54:42 UTC (rev 2697)
@@ -13,12 +13,10 @@
  ADM_vidLargeMedian.cpp \
  ADM_vidSalt.cpp \
  ADM_vidCached.cpp \
- ADM_vidFlux.cpp \
  ADM_vidPartial.cpp \
  ADM_vidFont.cpp \
  ADM_vidSRT.cpp \
  ADM_vidDenoise.cpp \
- ADM_vidFastConvolution.cpp \
 	ADM_vidFlipV.cpp \
  ADM_vidStabilize.cpp \
  ADM_vidContrast.cpp \
@@ -35,11 +33,7 @@
  ADM_vidUVSwap.cpp \
 	ADM_vidClean.cpp \
  ADM_vidChroma.cpp \
- ADM_vidBSmear.cpp \
- ADM_vidAddBorder.cpp \
 	ADM_resizebis.cpp \
- ADM_guiBSMear.cpp \
-	ADM_guiAddBorder.cpp \
  ADM_genvideo.cpp \
  ADM_vidRotate.cpp \
  ADM_vidRotate.h \
@@ -73,7 +67,6 @@
  ADM_vidDecTelecide.cpp \
  ADM_vidDecTelecide.h ADM_cache.cpp \
  ADM_vidDecDec.cpp \
- ADM_vidMsmooth.cpp \
  ADM_vidWirl.cpp \
  ADM_vidEqualizer.cpp \
  ADM_vidVobsub.cpp \
@@ -107,13 +100,13 @@
 
 
 EXTRA_DIST =  ADM_cache.cpp  ADM_vidDecDec_param.h ADM_vidMosaic_param.h \
-ADM_cache.h  ADM_vidDecTel_param.h ADM_vidMsmooth.cpp \
+ADM_cache.h  ADM_vidDecTel_param.h \
 ADM_confCouple.h ADM_vidDecTelecide.cpp  ADM_vidNull.cpp \
 ADM_confCouples.cpp  ADM_vidDecTelecide.h  ADM_vidPalShift.cpp \
 ADM_genvideo.cpp ADM_vidDeintASM.cpp ADM_vidPalShift.h \
 ADM_genvideo.hxx ADM_vidDeinterlace.cpp  ADM_vidPartial.cpp \
-ADM_guiAddBorder.cpp ADM_vidDeinterlace.h  ADM_vidPartial.h \
-ADM_guiBSMear.cpp  ADM_vidDelta.cpp  ADM_vidPartial_param.h \
+ADM_vidDeinterlace.h  ADM_vidPartial.h \
+ADM_vidDelta.cpp  ADM_vidPartial_param.h \
 ADM_guiCrop.cpp  ADM_vidDenoise.cpp  ADM_vidPulldown.cpp \
 ADM_guiMedianBig.cpp ADM_vidDenoise.h  ADM_vidPulldown.h \
 ADM_guiResize.cpp  ADM_vidDropOut.cpp  ADM_vidRaw.cpp \
@@ -124,17 +117,17 @@
 ADM_mpdetc.cpp ADM_vidEqualizer.h  ADM_vidRotate.cpp \
 ADM_mpdetc.h ADM_vidFade.cpp ADM_vidRotate.h \
 ADM_resizebis.cpp  ADM_vidFade_param.h ADM_vidSRT.cpp \
-ADM_resizebis.hxx  ADM_vidFastConvolution.cpp  ADM_vidSRT.h \
+ADM_resizebis.hxx    ADM_vidSRT.h \
 ADM_resizeter.cpp  ADM_vidField.h  ADM_vidSRTRender.cpp \
 ADM_separateField.cpp  ADM_vidFieldUnblend.cpp ADM_vidSRTload.cpp \
 ADM_vidASharp_param.h  ADM_vidFieldUtil.cpp  ADM_vidSalt.cpp \
-ADM_vidAddBorder.cpp ADM_vidFieldUtil.h  ADM_vidSalt.h \
-ADM_vidAddBorder.h ADM_vidFields.cpp ADM_vidSeparateField.cpp \
+ADM_vidFieldUtil.h  ADM_vidSalt.h \
+ADM_vidFields.cpp ADM_vidSeparateField.cpp \
 ADM_vidAnimated.cpp  ADM_vidFlipV.cpp  ADM_vidSeparateField.h \
 ADM_vidAnimated.h  ADM_vidFlipV.h  ADM_vidSoften.cpp \
-ADM_vidAnimated_param.h  ADM_vidFlux.cpp ADM_vidSoften.h \
-ADM_vidAsharp.cpp  ADM_vidFlux.h ADM_vidStabilize.cpp \
-ADM_vidBSmear.cpp  ADM_vidFont.cpp ADM_vidStabilize.h \
+ADM_vidAnimated_param.h   ADM_vidSoften.h \
+ADM_vidAsharp.cpp   ADM_vidStabilize.cpp \
+ADM_vidFont.cpp ADM_vidStabilize.h \
 ADM_vidBlend.cpp ADM_vidFont.h ADM_vidSwapFields.cpp \
 ADM_vidBlendRemoval.cpp  ADM_vidForcedPP.cpp ADM_vidSwapFields.h \
 ADM_vidBlendRemoval_param.h  ADM_vidForcedPP.h ADM_vidSwapSmart.cpp \

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidAddBorder.cpp (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidAddBorder.cpp)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidAddBorder.cpp	2006-10-31 15:59:58 UTC (rev 2489)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidAddBorder.cpp	2007-01-09 19:54:42 UTC (rev 2697)
@@ -0,0 +1,256 @@
+/***************************************************************************
+                          ADM_vidAddBorder.cpp  -  description
+                             -------------------
+    begin                : Sun Aug 11 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ADM_assert.h>
+
+#include "config.h"
+#include "fourcc.h"
+#include "avio.hxx"
+#include "config.h"
+#include "avi_vars.h"
+#ifdef HAVE_ENCODER
+
+
+#include "ADM_toolkit/toolkit.hxx"
+#include "ADM_editor/ADM_edit.hxx"
+#include "ADM_video/ADM_genvideo.hxx"
+#include "ADM_vidAddBorder.h"
+#include "ADM_video/ADM_vidCommonFilter.h"
+#include "ADM_filter/video_filters.h"
+
+#include "ADM_userInterfaces/ADM_commonUI/DIA_factory.h"
+
+static FILTER_PARAM cropParam={4,{"left","right","top","bottom"}};
+
+
+SCRIPT_CREATE(addBorder_script,AVDMVideoAddBorder,cropParam);
+BUILD_CREATE(addBorder_create,AVDMVideoAddBorder);
+
+char *AVDMVideoAddBorder::printConf( void )
+{
+ 	static char buf[50];
+
+ 	sprintf((char *)buf," Add Borders %lu x %lu --> %lu x %lu",
+ 				_in->getInfo()->width,
+ 				_in->getInfo()->height,
+ 				_info.width,
+ 				_info.height);
+        return buf;
+}
+
+AVDMVideoAddBorder::AVDMVideoAddBorder(  AVDMGenericVideoStream *in,CONFcouple *couples)
+{
+
+ 	_in=in;		
+   	memcpy(&_info,_in->getInfo(),sizeof(_info));  		
+	
+		if(couples)
+		{
+
+			 _param=NEW(CROP_PARAMS);
+
+				GET(left);
+				GET(right);
+				GET(top);
+				GET(bottom);
+				_info.width+=_param->right+_param->left;
+				_info.height+=_param->bottom+_param->top;
+		}	
+			else 			
+		{	// default parameter	
+				_param=NEW(CROP_PARAMS);
+				_param->left=_param->top=
+				_param->right=_param->bottom=0;
+		}				
+					
+ 	//_uncompressed=(uint8_t *)malloc(3*_in->getInfo()->width*_in->getInfo()->height);
+ 	//_uncompressed=new uint8_t [3*_in->getInfo()->width*_in->getInfo()->height];
+	_uncompressed=new ADMImage(_in->getInfo()->width,_in->getInfo()->height);
+  ADM_assert(_uncompressed);
+  _info.encoding=1;
+
+  	  	
+}
+AVDMGenericVideoStream *create_addBorder(AVDMGenericVideoStream *in,uint32_t x,uint32_t x2,uint32_t y,uint32_t y2)
+{
+	return new AVDMVideoAddBorder(in,x,x2,y,y2);
+}
+AVDMVideoAddBorder::AVDMVideoAddBorder(  AVDMGenericVideoStream *in,uint32_t x,uint32_t x2,uint32_t y,uint32_t y2)
+{
+
+ 	_in=in;		
+   	memcpy(&_info,_in->getInfo(),sizeof(_info));  		
+
+				_param=NEW(CROP_PARAMS);
+				_param->left=x;
+				_param->top=y;
+				_param->right=x2;
+				_param->bottom=y2;
+	_info.width+=_param->right+_param->left;
+	_info.height+=_param->bottom+_param->top;
+ 	//_uncompressed=(uint8_t *)malloc(3*_in->getInfo()->width*_in->getInfo()->height);
+ 	//_uncompressed=new uint8_t [3*_in->getInfo()->width*_in->getInfo()->height];
+	_uncompressed=new ADMImage(_in->getInfo()->width,_in->getInfo()->height);
+  ADM_assert(_uncompressed);
+  _info.encoding=1;
+
+
+}
+
+uint8_t	AVDMVideoAddBorder::getCoupledConf( CONFcouple **couples)
+{
+
+			ADM_assert(_param);
+			*couples=new CONFcouple(4);
+
+
+	CSET(left);
+	CSET(right);
+	CSET(top);
+	CSET(bottom);
+			return 1;
+
+}
+AVDMVideoAddBorder::~AVDMVideoAddBorder()
+{
+ 	delete _uncompressed;
+	DELETE(_param);
+	_uncompressed=NULL;
+ 	
+}
+uint8_t AVDMVideoAddBorder::getFrameNumberNoAlloc(uint32_t frame,
+				uint32_t *len,
+   				ADMImage *data,
+				uint32_t *flags)
+{
+
+		if(frame>=_info.nb_frames) 
+		{
+			printf("Filter : out of bound!\n");
+			return 0;
+		}
+	
+		ADM_assert(_param);									
+								
+			// read uncompressed frame
+       		if(!_in->getFrameNumberNoAlloc(frame, len,_uncompressed,flags)) return 0;
+       		
+				// blacken screen
+				memset(YPLANE(data),16,_info.width*_info.height);
+				memset(UPLANE(data),128,(_info.width*_info.height)>>2);
+				memset(VPLANE(data),128,(_info.width*_info.height)>>2);
+
+				// do luma
+				uint8_t *src,*dest;
+       		uint32_t y,x,line,lineout;
+       		
+       		y=_in->getInfo()->height;
+       		x=_in->getInfo()->width;
+       		line=x;
+		lineout=_info.width;
+		
+		// copy Luma
+       		src=YPLANE(_uncompressed);
+       		dest=YPLANE(data)+_param->left+_info.width*_param->top;
+       		
+       		for(uint32_t k=y;k>0;k--)
+       		{
+       		 	    memcpy(dest,src,line);
+       		 	    src+=line;
+       		 	    dest+=lineout;
+       		}
+       		 
+		// U and V now
+		uint8_t *src_u,*src_v;
+		uint8_t *dst_u,*dst_v;
+
+       		src_u=UPLANE(_uncompressed);
+       		src_v=VPLANE(_uncompressed);
+       		line>>=1;
+       		lineout>>=1;       		       		 	
+		dst_u=UPLANE( data)+(_info.width*_param->top>>2)+
+						(_param->left>>1);;
+		dst_v= VPLANE( data)+(_info.width*_param->top>>2)+
+						(_param->left>>1);;
+
+       		 for(uint32_t k=y>>1;k>0;k--)
+       		 {
+       		 	memcpy(dst_u,src_u,line);
+       		 	memcpy(dst_v,src_v,line);
+
+       			src_u+=line;
+       			src_v+=line;
+
+       			dst_u+=lineout;
+       		    	dst_v+=lineout;
+
+       		 }
+       		  *len= _info.width*_info.height+(_info.width*_info.height>>1);
+		  data->copyInfo(_uncompressed);
+      return 1;
+}
+uint8_t AVDMVideoAddBorder::configure(AVDMGenericVideoStream *in)
+{
+	_in=in;
+	ADM_assert(_param);
+        uint32_t width,height;
+#define MAKEME(x) uint32_t x=_param->x;
+        while(1)
+        {
+          MAKEME(left);
+          MAKEME(right);
+          MAKEME(top);
+          MAKEME(bottom);
+          
+          width=_in->getInfo()->width;
+          height=_in->getInfo()->height;
+          
+          diaElemUInteger dleft(&left,"Left",       0,width);
+          diaElemUInteger dright(&right,"Right",    0,width);
+          diaElemUInteger dtop(&(top),"Top",          0,height);
+          diaElemUInteger dbottom(&(bottom),"Bottom", 0,height);
+            
+          diaElem *elems[4]={&dleft,&dright,&dtop,&dbottom};
+          if(diaFactoryRun("Add border",4,elems))
+          {
+            if((left&1) || (right&1)|| (top&1) || (bottom&1))
+            {
+              GUI_Error_HIG("Incorrect parameters","All parameters must be even and within range"); 
+              continue;
+            }
+            else
+            {
+  #undef MAKEME
+  #define MAKEME(x) _param->x=x;
+                MAKEME(left);
+                MAKEME(right);
+                MAKEME(top);
+                MAKEME(bottom);
+                _info.width=width+left+right;
+                _info.height=height+top+bottom;
+                return 1;
+            }
+          }
+          return 0;
+      }
+}
+
+
+
+#endif

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidAddBorder.h (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidAddBorder.h)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidAddBorder.h	2006-10-31 15:59:58 UTC (rev 2489)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidAddBorder.h	2007-01-09 19:54:42 UTC (rev 2697)
@@ -0,0 +1,37 @@
+/***************************************************************************
+                          ADM_vidAddBorder.h  -  description
+                             -------------------
+    begin                : Sun Aug 11 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef __ADDBORDER__
+#define     __ADDBORDER__
+  class  AVDMVideoAddBorder:public AVDMGenericVideoStream
+ {
+
+ protected:
+              virtual char        *printConf(void);
+              CROP_PARAMS         *_param;
+ public:
+
+                                    AVDMVideoAddBorder(  AVDMGenericVideoStream *in,CONFcouple *setup);
+                                    AVDMVideoAddBorder(  AVDMGenericVideoStream *in,uint32_t x,uint32_t x2,
+                                                              uint32_t y,uint32_t y2);
+            virtual                 ~AVDMVideoAddBorder();
+            virtual 	uint8_t     getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
+                                            ADMImage *data,uint32_t *flags);
+                        uint8_t     configure( AVDMGenericVideoStream *instream) ;
+                        uint8_t     getCoupledConf( CONFcouple **couples);
+ }     ;
+
+#endif

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidBSmear.cpp (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidBSmear.cpp)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidBSmear.cpp	2006-10-31 15:59:58 UTC (rev 2489)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidBSmear.cpp	2007-01-09 19:54:42 UTC (rev 2697)
@@ -0,0 +1,232 @@
+/***************************************************************************
+                          ADM_vidBSMear.cpp  -  description
+                             -------------------
+         change part of video into black borders
+
+          Each one ,must be even
+
+          Copy / Paste from crop,almost the same thing
+
+
+    begin                : Sun Mar 24 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ADM_assert.h>
+
+#include "config.h"
+#include "fourcc.h"
+#include "avio.hxx"
+#include "config.h"
+#include "avi_vars.h"
+#ifdef HAVE_ENCODER
+
+
+#include "ADM_toolkit/toolkit.hxx"
+#include "ADM_editor/ADM_edit.hxx"
+#include "ADM_video/ADM_genvideo.hxx"
+#include "ADM_video/ADM_vidCommonFilter.h"
+#include "ADM_filter/video_filters.h"
+
+#include "ADM_userInterfaces/ADM_commonUI/DIA_factory.h"
+
+static FILTER_PARAM cropParam={4,{"left","right","top","bottom"}};
+
+
+SCRIPT_CREATE(bsmear_script,AVDMVideoStreamBSMear,cropParam);
+
+char *AVDMVideoStreamBSMear::printConf( void )
+{
+ 	static char buf[50];
+ 	
+ 	sprintf((char *)buf," Black l:%lu  r:%lu  u:%lu x d:%lu",
+ 				_param->left,
+ 					_param->right,
+ 					_param->top,
+ 					_param->bottom);
+        return buf;
+}
+
+//_______________________________________________________________
+
+AVDMVideoStreamBSMear::AVDMVideoStreamBSMear(  	AVDMGenericVideoStream *in,CONFcouple *couples)
+{
+
+
+  	_in=in;		
+   	memcpy(&_info,_in->getInfo(),sizeof(_info));  		
+
+		if(couples)
+		{
+			_param=NEW(CROP_PARAMS);
+			GET(left);
+			GET(right);
+			GET(top);
+			GET(bottom);
+		}	
+			else 	
+		{	// default parameter	
+				_param=NEW(CROP_PARAMS);
+				_param->left=_param->top=
+						_param->right=_param->bottom=0;
+		}										
+ 	
+  _info.encoding=1;
+
+  	  	
+}
+
+uint8_t	AVDMVideoStreamBSMear::getCoupledConf( CONFcouple **couples)
+{
+
+			ADM_assert(_param);
+			*couples=new CONFcouple(4);
+
+#define CSET(x)  (*couples)->setCouple((char *)#x,(_param->x))
+	CSET(left);
+	CSET(right);
+	CSET(top);
+	CSET(bottom);
+			return 1;
+
+}
+AVDMVideoStreamBSMear::~AVDMVideoStreamBSMear()
+{
+ 	DELETE(_param);
+ 	
+}
+
+//
+//	Blacken borders, just setting luma to null should be enough
+//
+
+uint8_t AVDMVideoStreamBSMear::getFrameNumberNoAlloc(uint32_t frame,
+				uint32_t *len,
+   				ADMImage *data,
+				uint32_t *flags)
+{
+
+			if(frame>=_info.nb_frames) 
+			{
+				printf("Filter : out of bound!\n");
+				return 0;
+			}
+	
+			ADM_assert(_param);									
+								
+			// read uncompressed frame directly into follower
+			// and blacken there
+			
+       		if(!_in->getFrameNumberNoAlloc(frame, len,data,flags)) return 0;
+       		  *len= _info.width*_info.height+(_info.width*_info.height>>1);       			
+       		  // blacken top
+       		  uint8_t *srcY=YPLANE(data);
+		  uint8_t *srcU=UPLANE(data);
+		  uint8_t *srcV=VPLANE(data);
+       		  uint32_t bytes=_info.width*_param->top;
+		  uint32_t page=_info.width*_info.height;
+       		
+       		  memset(srcY,0x10,bytes);
+		  memset(srcU,0x80,bytes>>2);
+		  memset(srcV,0x80,bytes>>2);
+       		  // left & right
+       		  uint32_t stride=_info.width;
+		  
+       		  for(uint32_t y=_info.height;y>0;y--)
+       		  {
+       		        memset(srcY,0x10,_param->left);
+       		        memset(srcY+stride-_param->right,0,_param->right);       		
+       		        srcY+=stride;       		
+		 }
+		 for(uint32_t y=_info.height>>1;y>0;y--)
+       		  {
+       		        
+			memset(srcU,0x80,_param->left>>1);
+			memset(srcV,0x80,_param->left>>1);
+			memset(srcU+((stride-_param->right)>>1),0x80,_param->right>>1);
+			memset(srcV+((stride-_param->right)>>1),0x80,_param->right>>1);
+			srcU+=stride>>1;
+			srcV+=stride>>1;
+       		  }
+       		
+       		  // backen bottom
+       		  srcY=YPLANE(data)+_info.width*_info.height-1;
+       		
+       		 bytes=_info.width*_param->bottom;
+       	 	 srcY-=bytes;
+       		 memset(srcY,0x10,bytes);
+		// chroma
+		 srcU=UPLANE(data)+(page>>2)-1;
+		 srcU-=bytes>>2;
+       		 memset(srcU,0x80,bytes>>2);
+		 
+		 srcV=VPLANE(data)+(page>>2)-1;
+		 srcV-=bytes>>2;
+       		 memset(srcV,0x80,bytes>>2);
+		 
+		  
+       		  	
+       		         		       		
+      return 1;
+}
+uint8_t AVDMVideoStreamBSMear::configure(AVDMGenericVideoStream *in)
+{
+	_in=in;
+	ADM_assert(_param);
+        uint32_t width,height;
+#define MAKEME(x) uint32_t x=_param->x;
+        while(1)
+        {
+          MAKEME(left);
+          MAKEME(right);
+          MAKEME(top);
+          MAKEME(bottom);
+          
+          width=_in->getInfo()->width;
+          height=_in->getInfo()->height;
+          
+          diaElemUInteger dleft(&left,"Left",       0,width);
+          diaElemUInteger dright(&right,"Right",    0,width);
+          diaElemUInteger dtop(&(top),"Top",          0,height);
+          diaElemUInteger dbottom(&(bottom),"Bottom", 0,height);
+            
+          diaElem *elems[4]={&dleft,&dright,&dtop,&dbottom};
+          if(diaFactoryRun("Blacken Borders",4,elems))
+          {
+            if((left&1) || (right&1)|| (top&1) || (bottom&1) ||
+                     (top+bottom>=height)|| (left+right>width))
+            {
+              GUI_Error_HIG("Incorrect parameters","All parameters must be even and within range"); 
+              continue;
+            }
+            else
+            {
+  #undef MAKEME
+  #define MAKEME(x) _param->x=x;
+                MAKEME(left);
+                MAKEME(right);
+                MAKEME(top);
+                MAKEME(bottom);
+                _info.width=width+left+right;
+                _info.height=height+top+bottom;
+                return 1;
+            }
+          }
+          return 0;
+      }
+}
+
+#endif

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidFastConvolution.cpp (from rev 2693, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFastConvolution.cpp)

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidFlux.cpp (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFlux.cpp)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFlux.cpp	2006-10-31 15:59:58 UTC (rev 2489)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidFlux.cpp	2007-01-09 19:54:42 UTC (rev 2697)
@@ -0,0 +1,659 @@
+/***************************************************************************
+                          ADM_vidFlux.cpp  -  description
+                             -------------------
+    begin                : Tue Dec 31 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+    
+    Ported from FluxSmooth
+    (c)  Ross Thomas <ross at grinfinity.com>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "config.h" 
+ 
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ADM_assert.h>
+#include <math.h>
+
+#include "default.h"
+#include "fourcc.h"
+#include "avio.hxx"
+#include "config.h"
+
+
+
+//#include "ADM_toolkit/toolkit.hxx"
+#include "ADM_editor/ADM_edit.hxx"
+#include "ADM_video/ADM_genvideo.hxx"
+#include "admmangle.h"
+
+#include "ADM_userInterfaces/ADM_commonUI/DIA_factory.h"
+#include "ADM_vidFlux.h"
+#include "ADM_filter/video_filters.h"
+
+
+#include "ADM_assert.h"
+
+static int16_t scaletab[16];
+static uint64_t scaletab_MMX[65536];
+
+void initScaleTab( void )
+{
+//uint32_t i;
+
+		scaletab[1] = 32767;
+		for(int i = 2; i < 16; ++i)
+				scaletab[i] = (int)(32768.0 / i + 0.5);
+		for(uint32_t  i = 0; i < 65536; ++i)
+		{
+			scaletab_MMX[i] = ( (uint64_t)scaletab[ i        & 15]       ) |
+							  (((uint64_t)scaletab[(i >>  4) & 15]) << 16) |
+							  (((uint64_t)scaletab[(i >>  8) & 15]) << 32) |
+							  (((uint64_t)scaletab[(i >> 12) & 15]) << 48);
+		}
+}
+ 
+
+static FILTER_PARAM fluxParam={2,{"temporal_threshold","spatial_threshold"}};
+
+
+SCRIPT_CREATE(fluxsmooth_script,ADMVideoFlux,fluxParam);
+
+//#define ASM_FLUX
+BUILD_CREATE(fluxsmooth_create,ADMVideoFlux);
+
+static uint64_t spat_thresh ASM_CONST =0LL;
+static uint64_t temp_thresh ASM_CONST =0LL;
+static uint64_t ASM_CONST _l_counter_init,_l_indexer,_l_prev_pels,_l_next_pels;
+static long int _l_src_pitch ASM_CONST =0;
+static long int _l_dst_pitch ASM_CONST =0;
+static int _l_xmax ASM_CONST=0;
+
+static int ycnt;
+static	uint8_t * _l_currp; 
+static	 uint8_t * _l_prevp;								  								  
+static	 uint8_t * _l_nextp; 
+static	 uint8_t * _l_destp; 
+
+
+static uint32_t size;
+
+ADMVideoFlux::ADMVideoFlux(AVDMGenericVideoStream *in,CONFcouple *couples)
+			
+{
+  
+	_in=in;
+	memcpy(&_info,in->getInfo(),sizeof(_info));
+	if(couples)
+	{
+		_param=NEW( FLUX_PARAM );
+		GET(temporal_threshold);
+		GET(spatial_threshold);
+	}
+	else
+	{
+		 _param=NEW( FLUX_PARAM );
+		 _param->spatial_threshold=7;
+		 _param->temporal_threshold=7;
+	}
+  	num_frame=0xffff0000;
+	vidCache=new VideoCache(5,in);
+}
+
+uint8_t	ADMVideoFlux::getCoupledConf( CONFcouple **couples)
+{
+
+			ADM_assert(_param);
+			*couples=new CONFcouple(2);
+
+#define CSET(x)  (*couples)->setCouple((char *)#x,(_param->x))
+	CSET(temporal_threshold);
+	CSET(spatial_threshold);
+		return 1;
+
+}
+uint8_t ADMVideoFlux::configure(AVDMGenericVideoStream *in)
+{
+UNUSED_ARG(in);
+int32_t temporal,spatial; // diaElem wants int32 not uint32
+uint8_t r;
+    temporal=_param->temporal_threshold;
+    spatial=_param->spatial_threshold;
+
+    diaElemInteger Gtemporal(&temporal,"Temporal  Threshold",0,255);
+    diaElemInteger Gspatial(&spatial,"Spatial  Threshold",0,255);
+	  
+    diaElem *elems[2]={&Gtemporal,&Gspatial};
+  
+    r=diaFactoryRun("Flux Smooth",2,elems);
+    if(r)
+    {
+       _param->temporal_threshold=temporal;
+       _param->spatial_threshold=spatial;
+    }
+    return r;
+    
+}
+ADMVideoFlux::~ADMVideoFlux()
+{
+	DELETE(_param);
+	if(vidCache)
+		delete vidCache;
+	vidCache=NULL;
+}
+
+char	*ADMVideoFlux::printConf( void) 
+{
+	static char conf[100];
+
+		sprintf(conf,"FluxSmooth: Spatial :%02lu Temporal:%02lu",
+						_param->spatial_threshold,
+						_param->temporal_threshold);
+		return conf;
+	
+}
+uint8_t ADMVideoFlux::getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
+          			ADMImage *data,uint32_t *flags)
+{
+UNUSED_ARG(flags);
+uint32_t dlen,dflags;
+uint32_t plane=_info.width*_info.height;
+ADMImage	*image,*next,*prev;
+
+
+			*len=(plane*3)>>1;
+			
+			size=(_info.width*_info.height*3)>>1;
+			if(frame>_info.nb_frames-1) return 0;
+			
+			image=vidCache->getImage(frame);
+			if(!image) return 0;
+			
+			if(!frame || (frame==_info.nb_frames-1))
+			{
+
+				data->duplicate(image);
+				data->copyInfo(image);
+				vidCache->unlockAll();
+				return 1;
+			}
+			next=vidCache->getImage(frame+1);
+			if(!next)
+			{
+				vidCache->unlockAll();
+				return 0;
+			}
+			prev=vidCache->getImage(frame-1);
+			if(!prev)
+			{
+				vidCache->unlockAll();
+				return 0;
+			}	    
+				
+
+		   			
+// now we have everything
+		int dst_pitch = _info.width,
+		src_pitch = _info.width,
+		row_size  = _info.width,
+		height    = _info.height;
+		
+ uint8_t   		*currp = YPLANE(image),
+			*prevp = YPLANE(prev),
+			*nextp = YPLANE(next);;
+	uint8_t		*destp = YPLANE(data);
+
+	// line 1 and last
+	memcpy(destp, currp, row_size);
+	memcpy(destp + dst_pitch * (height - 1),
+		currp + src_pitch * (height - 1), row_size);
+
+	// skip one line		
+	currp += src_pitch;
+	prevp += src_pitch;
+	nextp += src_pitch;
+	destp += dst_pitch;
+	
+	DoFilter_C(currp, prevp, nextp, src_pitch,
+			destp, dst_pitch, row_size, height - 2);
+	// U
+ 
+	
+	dst_pitch = _info.width>>1;
+	src_pitch = _info.width>>1;
+  row_size  = _info.width>>1;
+	height = _info.height>>1;
+	
+	currp = UPLANE(image);
+	prevp = UPLANE(prev);
+	nextp = UPLANE(next);
+	destp = UPLANE(data);;
+
+	memcpy(destp, currp, row_size);
+	memcpy(destp + dst_pitch * (height - 1),
+		currp + src_pitch * (height - 1), row_size);
+
+	currp += src_pitch;
+	prevp += src_pitch;
+	nextp += src_pitch;
+	destp += dst_pitch;
+
+		DoFilter_C(currp, prevp, nextp, src_pitch,
+			destp, dst_pitch, row_size, height - 2);
+
+	// V
+
+  plane=(_info.width*_info.height*5)>>2;
+	
+	dst_pitch = _info.width>>1;
+	src_pitch = _info.width>>1;
+  row_size  = _info.width>>1;
+	height = _info.height>>1;
+	
+	currp = VPLANE(image);
+	prevp = VPLANE(prev);
+	nextp = VPLANE(next);
+	destp = VPLANE(data);;
+
+	memcpy(destp, currp, row_size);
+	memcpy(destp + dst_pitch * (height - 1),
+		currp + src_pitch * (height - 1), row_size);
+
+	currp += src_pitch;
+	prevp += src_pitch;
+	nextp += src_pitch;
+	destp += dst_pitch;
+
+	#if (defined( ARCH_X86)  || defined(ARCH_X86_64)) && defined(ASM_FLUX)
+        if(CpuCaps::hasMMX())
+        {
+		DoFilter_MMX(currp, prevp, nextp, src_pitch,
+			destp, dst_pitch, row_size, height - 2);
+	}else
+	#endif
+        {
+		DoFilter_C(currp, prevp, nextp, src_pitch,
+			destp, dst_pitch, row_size, height - 2);
+        }
+	
+	data->copyInfo(image);
+	vidCache->unlockAll();
+	return 1;
+}	                           
+
+
+void ADMVideoFlux::DoFilter_C(
+ uint8_t * currp, 
+ uint8_t * prevp,								  								  
+ uint8_t * nextp, 
+ int src_pitch,
+ uint8_t * destp, 
+ int dst_pitch,
+ int row_size, 
+ int height)
+{
+
+	 int skip = src_pitch - row_size + 1,
+		dskip = dst_pitch - row_size + 1;
+	int ycnt = height;
+
+	do
+	{
+		*destp = *currp; // Copy left edge
+
+		++currp;
+		++prevp;
+		++nextp;
+		++destp;
+
+		int xcnt = row_size - 2;
+
+		do
+		{
+			int pbt = *prevp++, b = *currp, nbt = *nextp++;
+			int pdiff = pbt - b, ndiff = nbt - b;
+			if((pdiff < 0 && ndiff < 0) || (pdiff > 0 && ndiff > 0))
+			{
+				int pb1 = currp[-src_pitch - 1], pb2 = currp[-src_pitch],
+					pb3 = currp[-src_pitch + 1], b1 = currp[-1], b2 = currp[1],
+					nb1 = currp[src_pitch - 1], nb2 = currp[src_pitch],
+					nb3 = currp[src_pitch + 1], sum = b, cnt = 1;
+
+				if(abs(pbt - b) <= _param->temporal_threshold)
+				{
+					sum += pbt;
+					++cnt;
+				}
+				if(abs(nbt - b) <= _param->temporal_threshold)
+				{
+					sum += nbt;
+					++cnt;
+				}
+				if(abs(pb1 - b) <= _param->spatial_threshold)
+				{
+					sum += pb1;
+					++cnt;
+				}
+				if(abs(pb2 - b) <= _param->spatial_threshold)
+				{
+					sum += pb2;
+					++cnt;
+				}
+				if(abs(pb3 - b) <= _param->spatial_threshold)
+				{
+					sum += pb3;
+					++cnt;
+				}
+				if(abs(b1 - b) <= _param->spatial_threshold)
+				{
+					sum += b1;
+					++cnt;
+				}
+				if(abs(b2 - b) <= _param->spatial_threshold)
+				{
+					sum += b2;
+					++cnt;
+				}
+				if(abs(nb1 - b) <= _param->spatial_threshold)
+				{
+					sum += nb1;
+					++cnt;
+				}
+				if(abs(nb2 - b) <= _param->spatial_threshold)
+				{
+					sum += nb2;
+					++cnt;
+				}
+				if(abs(nb3 - b) <= _param->spatial_threshold)
+				{
+					sum += nb3;
+					++cnt;
+				}
+
+				ADM_assert(sum >= 0);
+				ADM_assert(sum < 2806);
+				ADM_assert(cnt > 0);
+				ADM_assert(cnt < 12);
+
+				*destp++ = (uint8_t )(((sum * 2 + cnt) * scaletab[cnt]) >> 16);
+				++currp;
+			} else
+				*destp++ = *currp++;
+		} while(--xcnt);
+		ADM_assert(xcnt == 0);
+
+		*destp = *currp; // Copy right edge
+
+		currp += skip;
+		prevp += skip;
+		nextp += skip;
+		destp += dskip;
+	} while(--ycnt);
+	ADM_assert(ycnt == 0);
+
+}
+#if (defined( ARCH_X86)  || defined(ARCH_X86_64))
+/*
+	__asm movq mm2, mm0 \
+	__asm movq mm3, mm1 \
+	__asm psubusw mm2, mm1 \
+	__asm psubusw mm3, mm0 \
+	__asm por mm2, mm3				/  mm2 = abs diff  / \
+	__asm pcmpgtw mm2, threshold	/  Compare with threshold  / \
+	__asm paddw mm6, mm2			/  -1 from counter if not within  / \
+	__asm pandn mm2, mm1 \
+	__asm paddw mm5, mm2			/  Add to sum  / \
+*/
+#define CHECK_AND_ADD(threshold) " movq %%mm0, %%mm2 \n\t" \
+"movq    %%mm1, %%mm3 \n\t" \
+"psubusw %%mm1, %%mm2 \n\t" \
+"psubusw %%mm0, %%mm3 \n\t" \
+"por     %%mm3, %%mm2				\n\t" /* mm2 = abs diff */ \
+"pcmpgtw "Mangle(threshold)", %%mm2	\n\t "/* Compare with threshold */ \
+"paddw   %%mm2, %%mm6	\n\t	"/* -1 from counter if not within */ \
+"pandn   %%mm1, %%mm2 \n\t" \
+"paddw   %%mm2, %%mm5	\n\t" /* Add to sum */ 
+
+#define EXPAND(x) { x=x+(x<<8)+(x<<16)+(x<<24)+(x<<32)+(x<<40) \
+										+(x<<48);}
+
+
+void ADMVideoFlux::DoFilter_MMX(
+uint8_t * currp, 
+ uint8_t * prevp,
+ uint8_t * nextp, 
+ int src_pitch,
+ uint8_t * destp, 
+ int dst_pitch,
+ int row_size, 
+ int height)
+{
+	  _l_xmax = row_size - 4;
+	 	ycnt 		= height;
+	
+	
+	_l_currp = currp;
+  _l_prevp = prevp;								  								  
+  _l_nextp = nextp;  
+  _l_destp = destp; 
+ 	_l_src_pitch =src_pitch;
+  _l_dst_pitch =dst_pitch;
+ 
+		_l_counter_init = 0x000b000b000b000bLL,
+		_l_indexer = 0x1000010000100001LL;
+		
+		spat_thresh = _param->spatial_threshold;
+		temp_thresh = _param->temporal_threshold;
+		EXPAND( spat_thresh);
+		EXPAND( temp_thresh);
+
+UNUSED_ARG(_l_prev_pels);
+UNUSED_ARG(_l_next_pels);
+asm(
+"								 mov (%0),"REG_si" \n\t"
+"                mov "Mangle(_l_currp)", "REG_si" \n\t"
+"                mov "Mangle(_l_destp)", "REG_di" \n\t"
+"                pxor %%mm7,%%mm7 \n\t"
+" \n\t"
+"yloop%=:  \n\t"
+"                # Copy first dword \n\t"
+" \n\t"
+"                mov ("REG_si"),"REG_ax" \n\t"
+"                mov "REG_ax",("REG_di") \n\t"
+" \n\t"
+"                mov $4,"REG_cx" \n\t"
+" \n\t"
+"xloop%=:  \n\t"
+"                # Get current pels, init sum and counter \n\t"
+" \n\t"
+"                movd ("REG_si","REG_cx"),%%mm0 \n\t"
+"                punpcklbw %%mm7,%%mm0 \n\t"
+"                movq %%mm0,%%mm5 \n\t"
+"                movq "Mangle(_l_counter_init)",%%mm6 \n\t"
+" \n\t"
+"                # Middle left \n\t"
+" \n\t"
+"                movq %%mm0,%%mm1 \n\t"
+"                psllq $16,%%mm1 \n\t"
+"                movd -4("REG_si","REG_cx"),%%mm2 \n\t"
+"                punpcklbw %%mm7,%%mm2 \n\t"
+"                psrlq $48,%%mm2 \n\t"
+"                por %%mm2,%%mm1 \n\t"
+" \n\t"
+CHECK_AND_ADD(spat_thresh)
+" \n\t"
+"                # Middle right \n\t"
+" \n\t"
+"                movq %%mm0,%%mm1 \n\t"
+"                psrlq $16,%%mm1 \n\t"
+"                movd 4("REG_si","REG_cx"),%%mm2 \n\t"
+"                punpcklbw %%mm7,%%mm2 \n\t"
+"                psllq $48,%%mm2 \n\t"
+"                por %%mm2,%%mm1 \n\t"
+" \n\t"
+CHECK_AND_ADD(spat_thresh)
+" \n\t"
+"                # Top left \n\t"
+" \n\t"
+"                mov "REG_si","REG_ax" \n\t"
+"                sub "Mangle(_l_src_pitch)", "REG_ax" \n\t"
+"                movd ("REG_ax","REG_cx"),%%mm1 \n\t"
+"                punpcklbw %%mm7,%%mm1 \n\t"
+"                psllq $16,%%mm1 \n\t"
+"                movd -4("REG_ax","REG_cx"),%%mm2 \n\t"
+"                punpcklbw %%mm7,%%mm2 \n\t"
+"                psrlq $48,%%mm2 \n\t"
+"                por %%mm2,%%mm1 \n\t"
+" \n\t"
+CHECK_AND_ADD(spat_thresh)
+" \n\t"
+"                # Top centre \n\t"
+" \n\t"
+"                movd ("REG_ax","REG_cx"),%%mm1 \n\t"
+"                punpcklbw %%mm7,%%mm1 \n\t"
+" \n\t"
+CHECK_AND_ADD(spat_thresh)
+" \n\t"
+"                # Top right \n\t"
+" \n\t"
+"                psrlq $16,%%mm1 \n\t"
+"                movd 4("REG_ax","REG_cx"),%%mm2 \n\t"
+"                punpcklbw %%mm7,%%mm2 \n\t"
+"                psllq $48,%%mm2 \n\t"
+"                por %%mm2,%%mm1 \n\t"
+" \n\t"
+CHECK_AND_ADD(spat_thresh)
+" \n\t"
+"                # Bottom left \n\t"
+" \n\t"
+"                mov "REG_si","REG_ax" \n\t"
+"                add "Mangle(_l_src_pitch)", "REG_ax" \n\t"
+"                movd ("REG_ax","REG_cx"),%%mm1 \n\t"
+"                punpcklbw %%mm7,%%mm1 \n\t"
+"                psllq $16,%%mm1 \n\t"
+"                movd -4("REG_ax","REG_cx"),%%mm2 \n\t"
+"                punpcklbw %%mm7,%%mm2 \n\t"
+"                psrlq $48,%%mm2 \n\t"
+"                por %%mm2,%%mm1 \n\t"
+" \n\t"
+CHECK_AND_ADD(spat_thresh)
+" \n\t"
+"                # Bottom centre \n\t"
+" \n\t"
+"                movd ("REG_ax","REG_cx"),%%mm1 \n\t"
+"                punpcklbw %%mm7,%%mm1 \n\t"
+" \n\t"
+CHECK_AND_ADD(spat_thresh)
+" \n\t"
+"                # Bottom right \n\t"
+" \n\t"
+"                psrlq $16,%%mm1 \n\t"
+"                movd 4("REG_ax","REG_cx"),%%mm2 \n\t"
+"                punpcklbw %%mm7,%%mm2 \n\t"
+"                psllq $48,%%mm2 \n\t"
+"                por %%mm2,%%mm1 \n\t"
+" \n\t"
+CHECK_AND_ADD(spat_thresh)
+" \n\t"
+"                # Previous frame \n\t"
+" \n\t"
+"                mov "Mangle(_l_prevp)", "REG_ax" \n\t"
+"                movd ("REG_ax","REG_cx"),%%mm1 \n\t"
+"                punpcklbw %%mm7,%%mm1 \n\t"
+"                movq %%mm1, "Mangle(_l_prev_pels)" \n\t"
+" \n\t"
+CHECK_AND_ADD(temp_thresh)
+" \n\t"
+"                # Next frame \n\t"
+" \n\t"
+"                mov "Mangle(_l_nextp)", "REG_ax" \n\t"
+"                movd ("REG_ax","REG_cx"),%%mm1 \n\t"
+"                punpcklbw %%mm7,%%mm1 \n\t"
+"                movq %%mm1, "Mangle(_l_next_pels)" \n\t"
+" \n\t"
+CHECK_AND_ADD(temp_thresh)
+" \n\t"
+"                # Average \n\t"
+" \n\t"
+"                psllw $1,%%mm5                                  # sum *= 2 \n\t"
+"                paddw %%mm6,%%mm5                               # sum += count \n\t"
+" \n\t"
+"                pmaddwd "Mangle(_l_indexer)",%%mm6                  # Make index into lookup \n\t"
+"                movq %%mm6,%%mm1 \n\t"
+"                punpckhdq %%mm6,%%mm6 \n\t"
+"                mov "Mangle(scaletab_MMX)", "REG_ax" \n\t"
+"                paddd %%mm6,%%mm1 \n\t"
+"                movd %%mm1,"REG_bx" \n\t"
+" \n\t"
+"            movq ("REG_ax","REG_bx",8),%%mm2          # Do lookup \n\t"
+"            pmulhw %%mm2,%%mm5                                  # mm5 = average \n\t"
+" \n\t"
+"                # Apply smoothing only to fluctuating pels \n\t"
+" \n\t"
+"                movq %%mm0,%%mm1 \n\t"
+"                movq "Mangle(_l_prev_pels)",%%mm2 \n\t"
+"                movq %%mm0,%%mm3 \n\t"
+"                movq "Mangle(_l_next_pels)",%%mm4 \n\t"
+" \n\t"
+"                pcmpgtw %%mm2,%%mm1                             # curr > prev \n\t"
+"                pcmpgtw %%mm4,%%mm3                             # curr > next \n\t"
+"                pcmpgtw %%mm0,%%mm2                             # prev > curr \n\t"
+"                pcmpgtw %%mm0,%%mm4                             # next > curr \n\t"
+" \n\t"
+"                pand %%mm3,%%mm1                                # (curr > prev) and (curr > next) \n\t"
+"                pand %%mm4,%%mm2                                # (prev > curr) and (next > curr) \n\t"
+"                por %%mm2,%%mm1                                 # mm1 = FFh if fluctuating, else 00h \n\t"
+" \n\t"
+"                movq %%mm1,%%mm2 \n\t"
+"                pand %%mm5,%%mm1                                # mm1 = smoothed pels \n\t"
+"                pandn %%mm0,%%mm2                               # mm2 = unsmoothed pels \n\t"
+"                por %%mm2,%%mm1                                 # mm1 = result \n\t"
+" \n\t"
+"                # Store \n\t"
+" \n\t"
+"                packuswb %%mm7,%%mm1 \n\t"
+"                movntq %%mm1,("REG_di","REG_cx") \n\t"
+" \n\t"
+"                # Advance \n\t"
+" \n\t"
+"                add $4,"REG_cx" \n\t"
+"                cmp "Mangle(_l_xmax)", "REG_cx" \n\t"
+"                jl xloop%= \n\t"
+" \n\t"
+"                # Copy last dword \n\t"
+" \n\t"
+"                mov ("REG_si","REG_cx"),"REG_ax" \n\t"
+"                mov "REG_ax",("REG_di","REG_cx") \n\t"
+" \n\t"
+"                # Next row \n\t"
+" \n\t"
+"                add "Mangle(_l_src_pitch)", "REG_si" \n\t"
+"                mov "Mangle(_l_prevp)", "REG_ax" \n\t"
+"                add "Mangle(_l_src_pitch)", "REG_ax" \n\t"
+"                mov "REG_ax", "Mangle(_l_prevp)" \n\t"
+"                mov "Mangle(_l_nextp)", "REG_bx" \n\t"
+"                add "Mangle(_l_src_pitch)", "REG_bx" \n\t"
+"                mov "REG_bx", "Mangle(_l_nextp)" \n\t"
+"                add "Mangle(_l_dst_pitch)", "REG_di" \n\t"
+" \n\t"
+"                sub $1, "Mangle(ycnt)" \n\t"
+"                jnz yloop%= \n\t"
+" \n\t"
+//"MISMATCH: "                sfence" \n\t"
+"                emms \n\t"
+" \n\t"
+
+ : : "r"(_l_src_pitch) );
+}
+#endif
+//

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidFlux.h (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFlux.h)

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMsmooth.cpp (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMsmooth.cpp)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMsmooth.cpp	2006-10-31 15:59:58 UTC (rev 2489)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMsmooth.cpp	2007-01-09 19:54:42 UTC (rev 2697)
@@ -0,0 +1,824 @@
+/***************************************************************************
+                          ADM_vidMsmooth  -  description
+                             -------------------
+    
+    email                : fixounet at free.fr
+
+    Port of Donal Graft MSMooth which is (c) Donald Graft
+    http://www.neuron2.net
+    http://puschpull.org/avisynth/decomb_reference_manual.html
+
+ ***************************************************************************/
+/*
+	MSmooth plugin for Avisynth -- performs detail-preserving smoothing.
+
+	Copyright (C) 2003 Donald A. Graft
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program; if not, write to the Free Software
+	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#include "config.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ADM_assert.h>
+
+#include "config.h"
+#include "fourcc.h"
+#include "avio.hxx"
+#include "avi_vars.h"
+
+#include "ADM_toolkit/toolkit.hxx"
+#include "ADM_editor/ADM_edit.hxx"
+#include "ADM_video/ADM_genvideo.hxx"
+#include"ADM_video/ADM_vidField.h"
+#include"ADM_video/ADM_cache.h"
+
+#include "ADM_osSupport/ADM_debugID.h"
+#define MODULE_NAME MODULE_FILTER
+#include "ADM_osSupport/ADM_debug.h"
+
+#include "ADM_osSupport/ADM_cpuCap.h"
+#include "ADM_filter/video_filters.h"
+
+#include "ADM_userInterfaces/ADM_commonUI/DIA_factory.h"
+
+#ifdef HAVE_ALTIVEC_H
+#include "altivec.h"
+#endif
+#if 0
+#undef aprintf
+#define aprintf printf
+#endif
+#define GETFRAME(g, fp) \
+{ \
+	int GETFRAMEf; \
+	GETFRAMEf = (g); \
+	if (GETFRAMEf < 0) GETFRAMEf = 0; \
+	if (GETFRAMEf > num_frames_hi - 1) GETFRAMEf = num_frames_hi - 1; \
+	(fp) = vidCache->getImage(GETFRAMEf); \
+}
+
+#include "ADM_video/ADM_vidMSmooth_param.h"
+
+extern uint8_t DIA_getMSmooth(MSMOOTH_PARAM *param);
+extern uint8_t 	PutHintingData(unsigned char *video, unsigned int hint);
+extern uint8_t 	GetHintingData(unsigned char *video, unsigned int *hint);
+extern void 	BitBlt(uint8_t * dstp, int dst_pitch, const uint8_t* srcp,
+            		int src_pitch, int row_size, int height);
+//extern  void 	DrawString(uint8_t *dst, int x, int y, const char *s);
+//extern  void    DrawString(ADMImage *dst, int x, int y, const char *s);
+//#define DrawString(a,b,c,d) DrawString(NULL,b,c,d)
+#define DrawString drawString
+
+extern  void 	DrawStringYUY2(uint8_t *dst, int x, int y, const char *s); 
+
+static void Blur_C(uint8_t *in, uint8_t *out, uint32_t w, uint32_t h) ;
+#ifdef HAVE_ALTIVEC
+void Blur_Altivec(uint8_t *in, uint8_t *out, uint32_t w, uint32_t h);
+#endif
+#if (defined( ARCH_X86)  || defined(ARCH_X86_64))
+void Blur_MMX(uint8_t *in, uint8_t *out, uint32_t w, uint32_t h);
+#endif
+class Msmooth : public AVDMGenericVideoStream
+{
+private:
+	MSMOOTH_PARAM	*_param;
+	VideoCache	*vidCache;
+	uint8_t		show, debug;
+	ADMImage 	*blur,*work,*mask,*final,*final2;
+public:    
+
+			Msmooth(AVDMGenericVideoStream *in,CONFcouple *couples)   ;
+			~Msmooth();
+    	uint8_t 	*GetFrameYV12(int n);
+	void  		SmoothingPassYV12(const unsigned char *srcp, unsigned char *maskp, unsigned char *workp,
+				unsigned char *finalp,int row_size, int height, int spitch, int dpitch);
+	void 		EdgeMaskYV12(const unsigned char *srcp, unsigned char *blurp, unsigned char *workp,
+				 unsigned char *maskp,int row_size, int height, int src_pitch, int blur_pitch);
+				 
+	char 		*printConf( void );
+	uint8_t 	configure(AVDMGenericVideoStream *in);
+	uint8_t		getCoupledConf( CONFcouple **couples);
+	uint8_t 	getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
+				ADMImage *data,uint32_t *flags);
+};
+
+BUILD_CREATE(create_msmooth,Msmooth);
+static FILTER_PARAM msmoothParam={4,{"showmask", "highq","threshold", "strength"}};
+
+
+SCRIPT_CREATE(msmooth_script,Msmooth,msmoothParam);
+//_______________________________________________
+
+Msmooth::Msmooth(AVDMGenericVideoStream *in,CONFcouple *couples)
+
+{
+	_in=in;		
+   	memcpy(&_info,_in->getInfo(),sizeof(_info));    
+  	_info.encoding=1;
+	_uncompressed=NULL;		
+  	_info.encoding=1;
+	show=0;
+	debug=0;
+	_param=new MSMOOTH_PARAM;
+	//
+	if(couples)
+		{
+			GET(showmask);
+			GET(threshold);
+			GET(highq);
+			GET(strength);	
+		}
+		else // Default
+  		{
+			_param->showmask=0;
+			_param->threshold=15;
+			_param->strength=3;
+			_param->highq=1;			
+		}
+		
+	uint32_t sz=(_info.width*_info.height*3)>>1;
+	#define NW(x) x=new ADMImage(_info.width,_info.height);ADM_assert(x);
+	NW(blur);
+	NW(work);
+	NW(mask);
+	NW(final);
+	NW(final2);
+	
+    	vidCache=new VideoCache(5,in);
+}
+//________________________________________________________
+uint8_t	Msmooth::getCoupledConf( CONFcouple **couples)
+{
+	*couples=NULL;
+	*couples=new CONFcouple(4);
+#define CSET(x)  (*couples)->setCouple((char *)#x,(_param->x))
+	CSET(showmask);
+	CSET(threshold);
+	CSET(highq);
+	CSET(strength);	
+	
+	return 1;
+}
+//________________________________________________________
+Msmooth::~Msmooth(void)
+{
+
+	if(vidCache) delete vidCache;
+	if(_param) delete _param;
+#undef NW
+#define NW(x) if(x) {delete  x;x=NULL;}
+	NW(blur);
+	NW(work);
+	NW(mask);
+	NW(final);
+	NW(final2);
+}
+//________________________________________________________
+uint8_t Msmooth::configure(AVDMGenericVideoStream *in)
+{
+	_in=in;
+	ADM_assert(_param);
+        
+        diaElemToggle toggle(&(_param->highq),"High Quality");
+        diaElemToggle mask(&(_param->showmask),"Show Mask");
+        diaElemUInteger threshold(&(_param->threshold),"Threshold",0,100);
+        diaElemUInteger strength(&(_param->strength),"Filter Strength",0,100);
+	  
+    diaElem *elems[4]={&toggle,&mask,&threshold,&strength};
+  
+    return diaFactoryRun("MSmooth by Donald Graft",4,elems);
+}
+
+//________________________________________________________
+char *Msmooth::printConf( void )
+{
+ 	static char buf[50];
+
+	ADM_assert(_param);
+ 	sprintf((char *)buf," Donald Graft MSmooth");
+        return buf;
+}
+	
+//________________________________________________________
+uint8_t Msmooth::getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
+				ADMImage *data,uint32_t *flags)
+{
+    ADMImage *src = vidCache->getImage(frame);
+   
+    ADMImage * deliver;
+
+	const unsigned char *srcpY = YPLANE(src) ;
+	const unsigned char *srcp_savedY = srcpY;
+    	int src_pitchY = _info.width;
+	
+	const unsigned char *srcpU =UPLANE(src);
+	const unsigned char *srcp_savedU = srcpU;
+    	int src_pitchUV = _info.width>>1;
+	const unsigned char *srcpV =VPLANE(src);
+	const unsigned char *srcp_savedV = srcpV;
+
+    	unsigned char *blurpY = YPLANE(blur);//
+	unsigned char *blurp_savedY = blurpY;
+    	int blur_pitchY =  _info.width;
+    	unsigned char *blurpU = UPLANE(blur);
+	unsigned char *blurp_savedU = blurpU;
+    	int blur_pitchUV = _info.width>>1;
+    	unsigned char *blurpV = VPLANE(blur);
+	unsigned char *blurp_savedV = blurpV;
+
+    unsigned char *workpY = YPLANE(work); //->GetWritePtr(PLANAR_Y);
+	unsigned char *workp_savedY = workpY;
+    unsigned char *workpU = UPLANE(work);
+	unsigned char *workp_savedU = workpU;
+    unsigned char *workpV = VPLANE(work);
+	unsigned char *workp_savedV = workpV;
+
+    unsigned char *maskpY = YPLANE(mask); //->GetWritePtr(PLANAR_Y);
+	unsigned char *maskp_savedY = maskpY;
+    unsigned char *maskpU = UPLANE(mask);
+	unsigned char *maskp_savedU = maskpU;
+    unsigned char *maskpV = VPLANE(mask);
+	unsigned char *maskp_savedV = maskpV;
+
+    unsigned char *finalpY = YPLANE(final);//->GetWritePtr(PLANAR_Y);
+	unsigned char *finalp_savedY = finalpY;
+    unsigned char *finalpU = UPLANE(final);
+	unsigned char *finalp_savedU = finalpU;
+    unsigned char *finalpV = VPLANE(final);
+	unsigned char *finalp_savedV = finalpV;
+
+    unsigned char *finalp2Y = YPLANE(final2); //->GetWritePtr(PLANAR_Y);
+	unsigned char *finalp2_savedY = finalp2Y;
+    unsigned char *finalp2U = UPLANE(final2);
+	unsigned char *finalp2_savedU = finalp2U;
+    unsigned char *finalp2V = VPLANE(final2);
+	unsigned char *finalp2_savedV = finalp2V;
+
+    int row_sizeY = _info.width;//blur->GetRowSize(PLANAR_Y);
+    int row_sizeUV = _info.width>>1;//blur->GetRowSize(PLANAR_U);
+    int heightY = _info.height;//blur->GetHeight(PLANAR_Y);
+    int heightUV = _info.height>>1;//blur->GetHeight(PLANAR_U);
+	int y, reps;
+
+	/* Create the detail mask. */
+	EdgeMaskYV12(srcpY, blurpY, workpY, maskpY, row_sizeY, heightY, src_pitchY, blur_pitchY);
+	EdgeMaskYV12(srcpU, blurpU, workpU, maskpU, row_sizeUV, heightUV, src_pitchUV, blur_pitchUV);
+	EdgeMaskYV12(srcpV, blurpV, workpV, maskpV, row_sizeUV, heightUV, src_pitchUV, blur_pitchUV);
+
+	if (_param->showmask == true)
+	{
+		if (show == true)
+		{
+			char buf[80];
+			//env->MakeWritable(&mask);
+			sprintf(buf, "0.2 beta");
+			DrawString(mask, 0, 0, buf);
+			sprintf(buf, "From Donald Graft");
+			DrawString(mask, 0, 1, buf);
+		}
+		//return mask;
+		memcpy(data->data,mask->data,(_info.width*_info.height*3)>>1);
+		data->copyInfo(src);
+		vidCache->unlockAll();
+		return 1;
+	}
+
+	/* Fix up output frame borders. */
+	srcpY = srcp_savedY;
+	finalpY = finalp_savedY;
+	finalp2Y = finalp2_savedY;
+	memcpy(finalpY, srcpY, row_sizeY);
+	memcpy(finalpY + (heightY-1)*blur_pitchY, srcpY + (heightY-1)*blur_pitchY, row_sizeY);
+	memcpy(finalp2Y, srcpY, row_sizeY);
+	memcpy(finalp2Y + (heightY-1)*blur_pitchY, srcpY + (heightY-1)*blur_pitchY, row_sizeY);
+	for (y = 0; y < heightY; y++)
+	{
+		finalpY[0] = finalp2Y[0] = srcpY[0];
+		finalpY[row_sizeY-1] = finalp2Y[row_sizeY-1] = srcpY[row_sizeY-1];
+		srcpY += src_pitchY;
+		finalpY += blur_pitchY;
+		finalp2Y += blur_pitchY;
+	}
+	srcpU = srcp_savedU;
+	finalpU = finalp_savedU;
+	finalp2U = finalp2_savedU;
+	memcpy(finalpU, srcpU, row_sizeUV);
+	memcpy(finalpU + (heightUV-1)*blur_pitchUV, srcpU + (heightUV-1)*blur_pitchUV, row_sizeUV);
+	memcpy(finalp2U, srcpU, row_sizeUV);
+	memcpy(finalp2U + (heightUV-1)*blur_pitchUV, srcpU + (heightUV-1)*blur_pitchUV, row_sizeUV);
+	for (y = 0; y < heightUV; y++)
+	{
+		finalpU[0] = finalp2U[0] = srcpU[0];
+		finalpU[row_sizeUV-1] = finalp2U[row_sizeUV-1] = srcpU[row_sizeUV-1];
+		srcpU += src_pitchUV;
+		finalpU += blur_pitchUV;
+		finalp2U += blur_pitchUV;
+	}
+	srcpV = srcp_savedV;
+	finalpV = finalp_savedV;
+	finalp2V = finalp2_savedV;
+	memcpy(finalpV, srcpV, row_sizeUV);
+	memcpy(finalpV + (heightUV-1)*blur_pitchUV, srcpV + (heightUV-1)*blur_pitchUV, row_sizeUV);
+	memcpy(finalp2V, srcpV, row_sizeUV);
+	memcpy(finalp2V + (heightUV-1)*blur_pitchUV, srcpV + (heightUV-1)*blur_pitchUV, row_sizeUV);
+	for (y = 0; y < heightUV; y++)
+	{
+		finalpV[0] = finalp2V[0] = srcpV[0];
+		finalpV[row_sizeUV-1] = finalp2V[row_sizeUV-1] = srcpV[row_sizeUV-1];
+		srcpV += src_pitchUV;
+		finalpV += blur_pitchUV;
+		finalp2V += blur_pitchUV;
+	}
+
+	/* Masked smoothing. */
+	reps = 0;
+	SmoothingPassYV12(srcp_savedY, maskp_savedY, workp_savedY, finalp_savedY, row_sizeY, heightY, src_pitchY, blur_pitchY);
+//	env->BitBlt(finalp_savedU, blur_pitchUV, srcp_savedU, src_pitchUV, row_sizeUV, heightUV);
+//	env->BitBlt(finalp_savedV, blur_pitchUV, srcp_savedV, src_pitchUV, row_sizeUV, heightUV);
+	SmoothingPassYV12(srcp_savedU, maskp_savedU, workp_savedU, finalp_savedU, row_sizeUV, heightUV, src_pitchUV, blur_pitchUV);
+	SmoothingPassYV12(srcp_savedV, maskp_savedV, workp_savedV, finalp_savedV, row_sizeUV, heightUV, src_pitchUV, blur_pitchUV);
+	if (++reps >= _param->strength)
+	{
+		deliver = final;
+		goto done;
+	}
+	while (1)
+	{
+		SmoothingPassYV12(finalp_savedY, maskp_savedY, workp_savedY, finalp2_savedY, row_sizeY, heightY, blur_pitchY, blur_pitchY);
+		SmoothingPassYV12(finalp_savedU, maskp_savedU, workp_savedU, finalp2_savedU, row_sizeUV, heightUV, blur_pitchUV, blur_pitchUV);
+		SmoothingPassYV12(finalp_savedV, maskp_savedV, workp_savedV, finalp2_savedV, row_sizeUV, heightUV, blur_pitchUV, blur_pitchUV);
+		if (++reps >=  _param->strength)
+		{
+			deliver = final2;
+			goto done;
+		}
+		SmoothingPassYV12(finalp2_savedY, maskp_savedY, workp_savedY, finalp_savedY, row_sizeY, heightY, blur_pitchY, blur_pitchY);
+		SmoothingPassYV12(finalp2_savedU, maskp_savedU, workp_savedU, finalp_savedU, row_sizeUV, heightUV, blur_pitchUV, blur_pitchUV);
+		SmoothingPassYV12(finalp2_savedV, maskp_savedV, workp_savedV, finalp_savedV, row_sizeUV, heightUV, blur_pitchUV, blur_pitchUV);
+		if (++reps >=  _param->strength)
+		{
+			deliver = final;
+			goto done;
+		}
+	}
+
+done:
+	if (show == true)
+	{
+		char buf[80];
+		//env->MakeWritable(&deliver);
+		sprintf(buf, "0.2beta");
+		DrawString(deliver, 0, 0, buf);
+		sprintf(buf, "Donald Graft");
+		DrawString(deliver, 0, 1, buf);
+	}
+	memcpy(data->data,deliver->data,(_info.width*_info.height*3)>>1);
+	//return(deliver);
+	data->copyInfo(src);
+	vidCache->unlockAll();
+	return 1;
+}
+
+
+#ifdef HAVE_ALTIVEC
+#define vecbyte vector unsigned char
+#define vect16 vector unsigned short
+
+#define LOAD_ALIGN(dest,src) \
+		dest = (vect16)vec_ld(0, src); 
+
+//______________________
+void Blur_Altivec(uint8_t *in, uint8_t *out, uint32_t w, uint32_t h)
+{
+uint8_t *srcp,*srcpn,*srcpp;
+uint8_t *workp;
+uint32_t x,y;
+int16_t  v16[8];
+
+    vect16 pp,pc,pn,res,res2;
+	vect16 rp,rc,rn,resl;
+	vect16 zero,deux;
+	
+	uint32_t off;
+	vector unsigned char MSQ,mask;
+	zero=vec_splat_u16(0);
+	deux=vec_splat_u16(2);
+
+	srcpp = in;
+	srcp  = srcpp + w;
+	srcpn = srcp + w;
+	workp = out + w;
+	for (y = 1; y < h - 1; y++)
+	{
+		for (x = 0; x < (w>>4); x++)
+		{
+			off=x<<4;
+			LOAD_ALIGN(pp,srcpp+off);
+			LOAD_ALIGN(pc,srcp+off);
+			LOAD_ALIGN(pn,srcpn+off);
+			
+			aprintf("sn %vd\n",pn); 
+			aprintf("sp %vd\n",pp);
+			aprintf("sc %vd\n",pc);
+		
+			
+			rp=(vect16)vec_mergel( (vecbyte)zero,(vecbyte)pp);
+			rn=(vect16)vec_mergel( (vecbyte)zero,(vecbyte)pn);
+			rc=(vect16)vec_mergel( (vecbyte)zero,(vecbyte)pc);
+			
+			aprintf("rn %vd\n",rn); 
+			aprintf("rp %vd\n",rp);
+			aprintf("rc %vd\n",rc);
+		
+			res=vec_add(rp,rc);
+			res2=vec_add(rc,rn);
+			
+			aprintf("re %vd\n",res);
+			aprintf("r2 %vd\n",res2);
+			
+			res=vec_add(res,res2);
+			
+			resl=vec_sr(res,deux);
+			aprintf("rS %vd\n",res);
+			aprintf("r2 %vd\n",res2);
+			aprintf("rl %vd\n",resl);
+									
+			pp=(vect16)vec_mergeh( (vecbyte)zero,(vecbyte)pp);
+			pn=(vect16)vec_mergeh( (vecbyte)zero,(vecbyte)pn);
+			pc=(vect16)vec_mergeh( (vecbyte)zero,(vecbyte)pc);
+			
+			res=vec_add(pp,pc);
+			res2=vec_add(pc,pn);
+			res=vec_add(res,res2);
+			res=vec_sr(res,deux);
+			
+			aprintf("rH %vd\n",res);
+			
+			res=(vect16)vec_pack(res,resl);
+			aprintf("rF %vd\n",res);
+			
+			vec_st((vecbyte)res,0,(vector unsigned char *)(workp+off));
+			
+		}
+		srcpp += w;
+        srcp += w;
+        srcpn += w;
+        workp += w;
+    }
+	// Do it at the end as it may have been scratched
+	// due to 16 byte alignment
+	memcpy(out, in, w);
+	memcpy(out + (h-1)*w, in + (h-1)*w, w);
+	
+}
+#endif
+
+#if (defined( ARCH_X86)  || defined(ARCH_X86_64))
+//______________________
+void Blur_MMX(uint8_t *in, uint8_t *out, uint32_t w, uint32_t h)
+{
+uint8_t *srcp,*srcpn,*srcpp;
+uint8_t *workp;
+uint32_t x,y;
+uint32_t off;
+	
+	srcpp = in;
+	srcp  = srcpp + w;
+	srcpn = srcp + w;
+	workp = out + w;
+	for (y = 1; y < h - 1; y++)
+	{
+		for (x =  (w>>3);x>0; x--)
+		{
+			off=x<<3;
+			
+			__asm__(
+			".align 16\n"
+			"pxor  %%mm7,%%mm7\n"
+			"movq  (%0),%%mm0\n"
+			"movq  %%mm0,%%mm6\n"
+			"punpckhbw %%mm7,%%mm0\n" // High part extended to 16 bits
+			"punpcklbw %%mm7,%%mm6\n" // low part ditto
+			
+			"movq  (%1),%%mm1\n"
+			"movq  %%mm1,%%mm5\n"
+			"punpckhbw %%mm7,%%mm1\n"
+			"punpcklbw %%mm7,%%mm5\n"
+			
+			"movq  (%2),%%mm2\n"
+			"movq  %%mm2,%%mm4\n"
+			"punpckhbw %%mm7,%%mm2\n"
+			"punpcklbw %%mm7,%%mm4\n"
+			
+			"paddw %%mm1,%%mm0\n"
+			"paddw %%mm5,%%mm6\n"
+			
+			"paddw %%mm1,%%mm2\n"
+			"paddw %%mm5,%%mm4\n"
+			
+			"paddw %%mm0,%%mm2\n"
+			"paddw %%mm6,%%mm4\n"
+			"psrlw $2, %%mm4\n"
+			"psrlw $2, %%mm2\n"
+			"packuswb %%mm2,%%mm4\n"
+			"movq %%mm4,(%3)\n" //
+			
+			: : "r" (srcpn+off),
+			   "r" (srcp+off), "r" (srcpp+off), "r" (workp+off)
+			);
+			
+		}
+		workp[0]=srcp[0];
+		workp[w-1]=srcp[w-1];
+		srcpp += w;
+        	srcp += w;
+        	srcpn += w;
+        	workp += w;
+    }
+	// Do it at the end as it may have been scratched
+	// due to 16 byte alignment
+	memcpy(out, in, w);
+	memcpy(out + (h-1)*w, in + (h-1)*w, w);
+	__asm__ ("emms\n" : :);
+	
+}
+#endif
+
+//______________________
+void Blur_C(uint8_t *in, uint8_t *out, uint32_t w, uint32_t h)
+{
+uint8_t *srcp,*srcpn,*srcpp;
+uint8_t *workp;
+uint32_t x,y;
+	srcpp = in;
+	srcp  = srcpp + w;
+	srcpn = srcp + w;
+	workp = out + w;
+	memcpy(out, in, w);
+	memcpy(out + (h-1)*w, in + (h-1)*w, w);
+	for (y = 1; y < h - 1; y++)
+	{
+		workp[0] = srcp[0];
+		workp[w-1] = srcp[w-1];
+        for (x = 1; x < w - 1; x++)
+		{
+			workp[x] = (srcpp[x] + srcp[x] + srcpn[x]) /3;
+		}
+        srcpp += w;
+        srcp += w;
+        srcpn += w;
+        workp += w;
+    }
+
+}
+//_______________________________
+void  Msmooth::EdgeMaskYV12(const unsigned char *srcp, unsigned char *blurp, unsigned char *workp, unsigned char *maskp,
+                        int row_size, int height, int src_pitch, int blur_pitch)
+{
+	const unsigned char *srcp_saved = srcp;
+	const unsigned char *srcpp;
+	const unsigned char *srcpn;
+
+	unsigned char *blurp_saved = blurp;
+	const unsigned char *blurpn;
+
+	unsigned char *workp_saved = workp;
+	unsigned char *workpp;
+	unsigned char *workpn;
+
+	unsigned char *maskp_saved = maskp;
+	int x, y;
+	int y1, y2, y3, y4;
+
+	/* Blur the source image prior to detail detection. */
+#if (defined( ARCH_X86)  || defined(ARCH_X86_64))
+		//printf("MMX\n");
+	if(CpuCaps::hasMMX())
+	{
+		Blur_MMX((uint8_t *)srcp,(uint8_t *)workp,row_size,height);
+		Blur_MMX((uint8_t *)workp,(uint8_t *)blurp,row_size,height);
+	}
+	else
+	#endif
+	#ifdef HAVE_ALTIVEC
+	#define ISALIGNED(x) (!( ((long long)x)&15 ))
+		if( ISALIGNED(srcp) && ISALIGNED(blurp) && ISALIGNED(workp) && ISALIGNED(maskp) && !(src_pitch&15))
+		{
+			Blur_Altivec((uint8_t *)srcp,(uint8_t *)workp,row_size,height);
+			Blur_Altivec((uint8_t *)workp,(uint8_t *)blurp,row_size,height);
+		}
+		else
+	#endif
+	{
+		Blur_C((uint8_t *)srcp,(uint8_t *)workp,row_size,height);
+		Blur_C((uint8_t *)workp,(uint8_t *)blurp,row_size,height);
+	}
+	/* Diagonal detail detection. */
+	blurp = (unsigned char *) workp_saved;
+	blurpn = blurp + blur_pitch;
+	maskp = maskp_saved;
+	y1 = blurp[0];
+	y3 = blurpn[0];
+	for (y = 0; y < height - 1; y++) 
+	{
+		for (x = 0; x < row_size - 1; x++)
+		{
+			y2 = blurp[x+1];
+			y4 = blurpn[x+1];
+			if ((abs(y1 - y4) >= _param->threshold) || (abs(y2 - y3) >= _param->threshold))
+			{
+				maskp[x] = 0xff;
+			}
+			else
+			{
+				maskp[x] = 0x0;
+			}
+			y1 = y2; y3 = y4;
+		}
+		maskp += blur_pitch;
+		blurp += blur_pitch;
+		blurpn += blur_pitch;
+	}
+
+	/* If set for high quality, also do horizontal and vertical
+	   detail detection. */
+	if ( _param->highq == true)
+	{
+		/* Msmooth convolve vertical. */
+		for (x = 0; x < row_size; x++)
+		{
+ 			blurp = blurp_saved;
+			blurpn = blurp + blur_pitch;
+			maskp = maskp_saved;
+			y1 = blurp[x];
+			for (y = 0; y < height - 1; y++)
+			{
+				y2 = blurpn[x];
+				if (abs(y1 - y2) >= _param->threshold)
+				{
+					maskp[x] = 0xff;
+				}
+				y1 = y2;
+				maskp += blur_pitch;
+				blurp += blur_pitch;
+				blurpn += blur_pitch;
+			}
+		}
+
+		/* Msmooth convolve horizontal. */
+		blurp = blurp_saved;
+		maskp = maskp_saved;
+		for (y = 0; y < height; y++)
+		{
+			y1 = blurp[0];
+			for (x = 0; x < row_size - 1; x++)
+			{
+				y2 = blurp[x+1];
+				if (abs(y1 - y2) >= _param->threshold)
+				{
+					maskp[x] = 0xff;
+				}
+				y1 = y2;
+			}
+			maskp += blur_pitch;
+			blurp += blur_pitch;
+		}
+
+	}
+	/* Fix up detail map borders. */
+	maskp = maskp_saved;
+	memset(maskp, 0xff, row_size);
+	memset(maskp + (height-1)*blur_pitch, 0xff, row_size);
+	for (y = 0; y < height; y++)
+	{
+//		*((unsigned int *)(&maskp[0])) = 0xffffffff;
+//		*((unsigned int *)(&maskp[row_size-1])) = 0xffffffff;
+		maskp[0] = 0xff;
+		maskp[row_size-1] = 0xff;
+		maskp += blur_pitch;
+	}
+}
+
+void  Msmooth::SmoothingPassYV12(const unsigned char *srcp, unsigned char *maskp,
+									  unsigned char *workp, unsigned char *finalp,
+									  int row_size, int height, int spitch, int dpitch)
+{
+	const unsigned char *srcp_saved = srcp;
+	const unsigned char *srcpp;
+	const unsigned char *srcpn;
+
+	unsigned char *workp_saved = workp;
+	unsigned char *workpp;
+	unsigned char *workpn;
+
+	unsigned char *maskp_saved = maskp;
+	unsigned char *maskpp;
+	unsigned char *maskpn;
+
+	unsigned char *finalp_saved = finalp;
+
+	int x, y, ysum;
+
+	srcpp = srcp_saved;
+ 	srcp = srcpp + spitch;
+	srcpn = srcp + spitch;
+	maskpp = maskp_saved;
+ 	maskp = maskpp + dpitch;
+	maskpn = maskp + dpitch;
+	workp = workp_saved + dpitch;
+	memcpy(workp_saved, srcp_saved, row_size);
+	memcpy(workp_saved + (height-1)*dpitch, srcp_saved + (height-1)*spitch, row_size);
+	for (y = 1; y < height - 1; y++)
+	{
+		workp[0] = srcp[0];
+		workp[row_size-1] = srcp[row_size-1];
+        for (x = 1; x < row_size - 1; x++)
+		{
+			int count = 1;
+
+			if (!maskp[x])
+			{
+				ysum = srcp[x];
+				if (!maskpp[x])
+				{
+					ysum += srcpp[x];
+					count++;
+				}
+				if (!maskpn[x])
+				{
+					ysum += srcpn[x];
+					count++;
+				}
+				workp[x] = ysum / count;
+			}
+		}
+        srcpp += spitch;
+        srcp += spitch;
+        srcpn += spitch;
+ 		maskpp += dpitch;
+		maskp += dpitch;
+		maskpn += dpitch;
+        workp += dpitch;
+    }
+	srcpp = srcp_saved;
+ 	srcp = srcpp + spitch;
+	srcpn = srcp + spitch;
+	workpp = workp_saved;
+ 	workp = workpp + dpitch;
+	workpn = workp + dpitch;
+	maskpp = maskp_saved;
+ 	maskp = maskpp + dpitch;
+	maskpn = maskp + dpitch;
+	finalp = finalp_saved + dpitch;
+	for (y = 1; y < height - 1; y++)
+	{
+        for (x = 1; x < row_size - 1; x++)
+		{
+			int count = 1;
+
+			if (!maskp[x])
+			{
+				ysum = workp[x];
+				if (!maskp[x-1])
+				{
+					ysum += workp[x-1];
+					count++;
+				}
+				if (!maskp[x+1])
+				{
+					ysum += workp[x+1];
+					count++;
+				}
+				finalp[x] = ysum / count;
+			}
+			else
+			{
+				finalp[x] = srcp[x];
+			}
+		}
+        srcpp += spitch;
+        srcp += spitch;
+        srcpn += spitch;
+        workpp += dpitch;
+        workp += dpitch;
+        workpn += dpitch;
+ 		maskpp += dpitch;
+		maskp += dpitch;
+		maskpn += dpitch;
+        finalp += dpitch;
+    }
+}
+

Added: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am	2007-01-08 21:29:24 UTC (rev 2696)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am	2007-01-09 19:54:42 UTC (rev 2697)
@@ -0,0 +1,20 @@
+####### kdevelop will overwrite this part!!! (begin)##########
+noinst_LIBRARIES = libADM_videoFilter.a
+
+## INCLUDES were found outside kdevelop specific part
+
+libADM_videoFilter_a_METASOURCES = AUTO
+#INCLUDES = $(all_includes) 
+
+libADM_videoFilter_a_SOURCES =  \
+ ADM_vidBSmear.cpp \
+ ADM_vidAddBorder.cpp \
+ ADM_vidFlux.cpp \
+ ADM_vidMsmooth.cpp \
+ ADM_vidFastConvolution.cpp 
+			
+
+
+####### kdevelop will overwrite this part!!! (end)############
+INCLUDES = $(all_includes) -I../ADM_libraries -I../ADM_libraries/ADM_utilities -I../ADM_libraries/ADM_lavutil \
+			 $(FREETYPE_CFLAGS) $(ALTIVEC_SWITCH) -I../ADM_userInterfaces/ADM_commonUI -I../ADM_inputs -I../ADM_video

Modified: branches/avidemux_2.4_branch/avidemux/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/Makefile.am	2007-01-08 21:29:24 UTC (rev 2696)
+++ branches/avidemux_2.4_branch/avidemux/Makefile.am	2007-01-09 19:54:42 UTC (rev 2697)
@@ -27,11 +27,13 @@
 		
 user_interface_cli = ./ADM_userInterfaces/ADM_NONE/ADM_gui2/libADM_gui2.a	\
 		./ADM_userInterfaces/ADM_NONE/ADM_dialog/libADM_dialog.a	\
+		./ADM_userInterfaces/ADM_NONE/ADM_dialogFactory/libADM_dialogFactory.a	\
 		./ADM_userInterfaces/ADM_NONE/ADM_filters/libADM_filters.a 
 		
 		
 user_interface_qt4 = 	./ADM_userInterfaces/ADM_QT4/ADM_gui/libADM_gui2.a	\
 			./ADM_userInterfaces/ADM_QT4/ADM_dialog/libADM_dialog.a	\
+			./ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/libADM_dialogFactory.a	\
 			./ADM_userInterfaces/ADM_commonUI/libADM_CommonUI.a	\
 			./ADM_userInterfaces/ADM_QT4/ADM_filters/libADM_filters.a 
 
@@ -51,7 +53,7 @@
 
 SUBDIRS = ADM_libraries ADM_audio ADM_audiocodec ADM_audiofilter ADM_codecs \
 	ADM_colorspace ADM_editor ADM_encoder ADM_filter  \
-	ADM_toolkit xpm ADM_video ADM_audiodevice \
+	ADM_toolkit xpm ADM_video ADM_videoFilter ADM_audiodevice \
 	\
 	ADM_requant \
 	ADM_script ADM_ocr \
@@ -79,6 +81,7 @@
 ./ADM_audio/libADM_audio.a				\
 ./ADM_script/libADM_script.a				\
 ./ADM_video/libADM_video.a				\
+./ADM_videoFilter/libADM_videoFilter.a			\
 ./ADM_colorspace/libADM_colorspace.a			\
 ./ADM_audiodevice/libADM_audiodevice.a			\
 ./ADM_ocr/libADM_ocr.a					\



From mean at mail.berlios.de  Tue Jan  9 20:59:27 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 9 Jan 2007 20:59:27 +0100
Subject: [Avidemux-svn-commit] r2698 -
	branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory
Message-ID: <200701091959.l09JxRYL014766@sheep.berlios.de>

Author: mean
Date: 2007-01-09 20:59:26 +0100 (Tue, 09 Jan 2007)
New Revision: 2698

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/FAC_integer.cpp
Log:
missing file

Added: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/FAC_integer.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/FAC_integer.cpp	2007-01-09 19:54:42 UTC (rev 2697)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/FAC_integer.cpp	2007-01-09 19:59:26 UTC (rev 2698)
@@ -0,0 +1,139 @@
+/***************************************************************************
+  FAC_toggle.cpp
+  Handle dialog factory element : Toggle
+  (C) 2006 Mean Fixounet at free.fr 
+***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include <config.h>
+
+
+#include <string.h>
+#include <stdio.h>
+#include <math.h>
+
+#include "default.h"
+#include "ADM_toolkit_gtk/ADM_gladeSupport.h"
+#include "ADM_toolkit_gtk/toolkit_gtk.h"
+#include "ADM_toolkit_gtk/toolkit_gtk_include.h"
+#include "ADM_commonUI/DIA_factory.h"
+#include "ADM_assert.h"
+
+
+
+
+diaElemInteger::diaElemInteger(int32_t *intValue,const char *toggleTitle, int32_t min, int32_t max,const char *tip)
+  : diaElem(ELEM_TOGGLE)
+{
+  param=(void *)intValue;
+  paramTitle=toggleTitle;
+  this->min=min;
+  this->max=max;
+  this->tip=tip;
+}
+
+diaElemInteger::~diaElemInteger()
+{
+  
+}
+void diaElemInteger::setMe(void *dialog, void *opaque,uint32_t line)
+{
+  GtkWidget *widget;
+  GtkObject *adj;
+  GtkWidget *label;
+  
+  label = gtk_label_new (paramTitle);
+  gtk_widget_show(label);
+  
+  gtk_table_attach (GTK_TABLE (opaque), label, 0, 1, line, line+1,
+                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  
+  int32_t val=*(int32_t *)param;
+  widget = gtk_spin_button_new_with_range(min,max,1);
+  gtk_spin_button_set_numeric (GTK_SPIN_BUTTON(widget),TRUE);
+  gtk_spin_button_set_digits  (GTK_SPIN_BUTTON(widget),0);
+  gtk_spin_button_set_value (GTK_SPIN_BUTTON(widget),val);
+  
+  gtk_widget_show (widget);
+  
+  gtk_table_attach (GTK_TABLE (opaque), widget, 1, 2, line, line+1,
+                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  
+  
+  
+  myWidget=(void *)widget;
+  
+}
+void diaElemInteger::getMe(void)
+{
+  GtkWidget *widget=(GtkWidget *)myWidget;
+  int32_t *val=(int32_t *)param;
+  ADM_assert(widget);
+  *(int32_t *)param=gtk_spin_button_get_value_as_int (GTK_SPIN_BUTTON (widget));
+}
+//**********************************************************************************
+
+diaElemUInteger::diaElemUInteger(uint32_t *intValue,const char *toggleTitle, uint32_t min, uint32_t max,const char *tip)
+  : diaElem(ELEM_TOGGLE)
+{
+  param=(void *)intValue;
+  paramTitle=toggleTitle;
+  this->min=min;
+  this->max=max;
+  this->tip=tip;
+}
+
+diaElemUInteger::~diaElemUInteger()
+{
+  
+}
+void diaElemUInteger::setMe(void *dialog, void *opaque,uint32_t line)
+{
+  GtkWidget *widget;
+  GtkObject *adj;
+  GtkWidget *label;
+  
+  label = gtk_label_new (paramTitle);
+  gtk_widget_show(label);
+  
+  gtk_table_attach (GTK_TABLE (opaque), label, 0, 1, line, line+1,
+                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  
+  uint32_t val=*(uint32_t *)param;
+  widget = gtk_spin_button_new_with_range(min,max,1);
+  gtk_spin_button_set_numeric (GTK_SPIN_BUTTON(widget),TRUE);
+  gtk_spin_button_set_digits  (GTK_SPIN_BUTTON(widget),0);
+  gtk_spin_button_set_value (GTK_SPIN_BUTTON(widget),val);
+  
+  gtk_widget_show (widget);
+  
+  gtk_table_attach (GTK_TABLE (opaque), widget, 1, 2, line, line+1,
+                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  
+  
+  
+  myWidget=(void *)widget;
+  
+}
+void diaElemUInteger::getMe(void)
+{
+  GtkWidget *widget=(GtkWidget *)myWidget;
+  uint32_t *val=(uint32_t *)param;
+  ADM_assert(widget);
+  *(uint32_t *)param=gtk_spin_button_get_value_as_int (GTK_SPIN_BUTTON (widget));
+}
+
+
+//EOF



From mean at mail.berlios.de  Wed Jan 10 20:52:38 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 10 Jan 2007 20:52:38 +0100
Subject: [Avidemux-svn-commit] r2699 - in
	branches/avidemux_2.4_branch/avidemux:
	ADM_userInterfaces/ADM_GTK/ADM_dialog
	ADM_userInterfaces/ADM_GTK/ADM_dialogFactory
	ADM_userInterfaces/ADM_NONE/ADM_dialog
	ADM_userInterfaces/ADM_NONE/ADM_dialogFactory
	ADM_userInterfaces/ADM_QT4/ADM_dialog
	ADM_userInterfaces/ADM_QT4/ADM_dialogFactory
	ADM_userInterfaces/ADM_commonUI ADM_video ADM_videoFilter
Message-ID: <200701101952.l0AJqctV011040@sheep.berlios.de>

Author: mean
Date: 2007-01-10 20:52:36 +0100 (Wed, 10 Jan 2007)
New Revision: 2699

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/FAC_menu.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidFade.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidFade_param.h
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidResampleFPS.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidSoften.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidSoften.h
Removed:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_4entries.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_audiodevice.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_fade.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_guiMedianBig.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFade.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFade_param.h
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidResampleFPS.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSoften.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSoften.h
Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/FAC_float.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/Makefile.am
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialogFactory/FAC_toggle.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/FAC_toggle.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_factory.h
   branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am
Log:
more use of dialogFactory

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_4entries.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_4entries.cpp	2007-01-09 19:59:26 UTC (rev 2698)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_4entries.cpp	2007-01-10 19:52:36 UTC (rev 2699)
@@ -1,188 +0,0 @@
-
-#include "config.h"
-
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <string.h>
-#include <stdio.h>
-
-#include "default.h"
-#include "ADM_toolkit_gtk/toolkit_gtk_include.h"
-#include "ADM_toolkit_gtk/ADM_gladeSupport.h"
-#include "ADM_toolkit_gtk/toolkit_gtk.h"
-
-static GtkWidget	*create_dialog1 (void);
-
-uint8_t DIA_4entries(char *title,uint32_t *left,uint32_t *right,uint32_t *top,uint32_t *bottom)
-{
-	GtkWidget *dialog;
-
-	char str[100];
-	uint8_t ret=0;
-
-	gint r;
-
-#define FILL_ENTRY(widget_name,value) 		{sprintf(str,"%ld",*value);r=-1;   \
-gtk_editable_delete_text(GTK_EDITABLE(lookup_widget(dialog,#widget_name)), 0,-1);\
-gtk_editable_insert_text(GTK_EDITABLE(lookup_widget(dialog,#widget_name)), str, strlen(str), &r);}
-
-	dialog=create_dialog1();
-//	gtk_transient(dialog);
-        gtk_register_dialog(dialog);
-  	gtk_window_set_title (GTK_WINDOW (dialog), title);
-	FILL_ENTRY(entryLeft,left);
-	FILL_ENTRY(entryRight,right);
-	FILL_ENTRY(entryTop,top);
-	FILL_ENTRY(entryBottom,bottom);
-
-
-	ret=0;
-	if(gtk_dialog_run(GTK_DIALOG(dialog))==GTK_RESPONSE_OK)
-	{
-
-			*left=gtk_read_entry(WID(entryLeft));
-			*right=gtk_read_entry(WID(entryRight));
-			*top=gtk_read_entry(WID(entryTop));
-			*bottom=gtk_read_entry(WID(entryBottom));
-			ret=1;
-	}
-        gtk_unregister_dialog(dialog);
-	gtk_widget_destroy(dialog);
-
-	return ret;
-
-}
-
-
-GtkWidget	*create_dialog1 (void)
-{
-  GtkWidget *dialog1;
-  GtkWidget *dialog_vbox1;
-  GtkWidget *table1;
-  GtkWidget *hbox1;
-  GtkWidget *label1;
-  GtkWidget *entryLeft;
-  GtkWidget *hbox2;
-  GtkWidget *label2;
-  GtkWidget *entryRight;
-  GtkWidget *hbox3;
-  GtkWidget *label3;
-  GtkWidget *entryTop;
-  GtkWidget *hbox4;
-  GtkWidget *label4;
-  GtkWidget *entryBottom;
-  GtkWidget *dialog_action_area1;
-  GtkWidget *cancelbutton1;
-  GtkWidget *okbutton1;
-
-  dialog1 = gtk_dialog_new ();
-  gtk_window_set_title (GTK_WINDOW (dialog1), _("dialog1"));
-
-  dialog_vbox1 = GTK_DIALOG (dialog1)->vbox;
-  gtk_widget_show (dialog_vbox1);
-
-  table1 = gtk_table_new (2, 2, FALSE);
-  gtk_widget_show (table1);
-  gtk_box_pack_start (GTK_BOX (dialog_vbox1), table1, TRUE, TRUE, 0);
-
-  hbox1 = gtk_hbox_new (FALSE, 0);
-  gtk_widget_show (hbox1);
-  gtk_table_attach (GTK_TABLE (table1), hbox1, 0, 1, 0, 1,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL), 0, 0);
-
-  label1 = gtk_label_new (_("Left:"));
-  gtk_widget_show (label1);
-  gtk_box_pack_start (GTK_BOX (hbox1), label1, TRUE, TRUE, 0);
-  gtk_label_set_justify (GTK_LABEL (label1), GTK_JUSTIFY_LEFT);
-
-  entryLeft = gtk_entry_new ();
-  gtk_widget_show (entryLeft);
-  gtk_box_pack_start (GTK_BOX (hbox1), entryLeft, TRUE, TRUE, 0);
-  gtk_widget_set_size_request (entryLeft, 60, -1);
-
-  hbox2 = gtk_hbox_new (FALSE, 0);
-  gtk_widget_show (hbox2);
-  gtk_table_attach (GTK_TABLE (table1), hbox2, 1, 2, 0, 1,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (GTK_FILL), 0, 0);
-
-  label2 = gtk_label_new (_("Right:"));
-  gtk_widget_show (label2);
-  gtk_box_pack_start (GTK_BOX (hbox2), label2, TRUE, TRUE, 0);
-  gtk_label_set_justify (GTK_LABEL (label2), GTK_JUSTIFY_LEFT);
-
-  entryRight = gtk_entry_new ();
-  gtk_widget_show (entryRight);
-  gtk_box_pack_start (GTK_BOX (hbox2), entryRight, TRUE, TRUE, 0);
-  gtk_widget_set_size_request (entryRight, 60, -1);
-
-  hbox3 = gtk_hbox_new (FALSE, 0);
-  gtk_widget_show (hbox3);
-  gtk_table_attach (GTK_TABLE (table1), hbox3, 0, 1, 1, 2,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL), 0, 0);
-
-  label3 = gtk_label_new (_("Top:"));
-  gtk_widget_show (label3);
-  gtk_box_pack_start (GTK_BOX (hbox3), label3, TRUE, TRUE, 0);
-  gtk_label_set_justify (GTK_LABEL (label3), GTK_JUSTIFY_LEFT);
-
-  entryTop = gtk_entry_new ();
-  gtk_widget_show (entryTop);
-  gtk_box_pack_start (GTK_BOX (hbox3), entryTop, TRUE, TRUE, 0);
-  gtk_widget_set_size_request (entryTop, 60, -1);
-
-  hbox4 = gtk_hbox_new (FALSE, 0);
-  gtk_widget_show (hbox4);
-  gtk_table_attach (GTK_TABLE (table1), hbox4, 1, 2, 1, 2,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (GTK_FILL), 0, 0);
-
-  label4 = gtk_label_new (_("Bottom:"));
-  gtk_widget_show (label4);
-  gtk_box_pack_start (GTK_BOX (hbox4), label4, TRUE, TRUE, 0);
-  gtk_label_set_justify (GTK_LABEL (label4), GTK_JUSTIFY_LEFT);
-
-  entryBottom = gtk_entry_new ();
-  gtk_widget_show (entryBottom);
-  gtk_box_pack_start (GTK_BOX (hbox4), entryBottom, TRUE, TRUE, 0);
-  gtk_widget_set_size_request (entryBottom, 60, -1);
-
-  dialog_action_area1 = GTK_DIALOG (dialog1)->action_area;
-  gtk_widget_show (dialog_action_area1);
-  gtk_button_box_set_layout (GTK_BUTTON_BOX (dialog_action_area1), GTK_BUTTONBOX_END);
-
-  cancelbutton1 = gtk_button_new_from_stock ("gtk-cancel");
-  gtk_widget_show (cancelbutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), cancelbutton1, GTK_RESPONSE_CANCEL);
-  GTK_WIDGET_SET_FLAGS (cancelbutton1, GTK_CAN_DEFAULT);
-
-  okbutton1 = gtk_button_new_from_stock ("gtk-ok");
-  gtk_widget_show (okbutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), okbutton1, GTK_RESPONSE_OK);
-  GTK_WIDGET_SET_FLAGS (okbutton1, GTK_CAN_DEFAULT);
-
-  /* Store pointers to all widgets, for use by lookup_widget(). */
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog1, "dialog1");
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_vbox1, "dialog_vbox1");
-  GLADE_HOOKUP_OBJECT (dialog1, table1, "table1");
-  GLADE_HOOKUP_OBJECT (dialog1, hbox1, "hbox1");
-  GLADE_HOOKUP_OBJECT (dialog1, label1, "label1");
-  GLADE_HOOKUP_OBJECT (dialog1, entryLeft, "entryLeft");
-  GLADE_HOOKUP_OBJECT (dialog1, hbox2, "hbox2");
-  GLADE_HOOKUP_OBJECT (dialog1, label2, "label2");
-  GLADE_HOOKUP_OBJECT (dialog1, entryRight, "entryRight");
-  GLADE_HOOKUP_OBJECT (dialog1, hbox3, "hbox3");
-  GLADE_HOOKUP_OBJECT (dialog1, label3, "label3");
-  GLADE_HOOKUP_OBJECT (dialog1, entryTop, "entryTop");
-  GLADE_HOOKUP_OBJECT (dialog1, hbox4, "hbox4");
-  GLADE_HOOKUP_OBJECT (dialog1, label4, "label4");
-  GLADE_HOOKUP_OBJECT (dialog1, entryBottom, "entryBottom");
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_action_area1, "dialog_action_area1");
-  GLADE_HOOKUP_OBJECT (dialog1, cancelbutton1, "cancelbutton1");
-  GLADE_HOOKUP_OBJECT (dialog1, okbutton1, "okbutton1");
-
-  return dialog1;
-}
-

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_audiodevice.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_audiodevice.cpp	2007-01-09 19:59:26 UTC (rev 2698)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_audiodevice.cpp	2007-01-10 19:52:36 UTC (rev 2699)
@@ -1 +0,0 @@
-// Obsoleted by our UI manager

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_fade.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_fade.cpp	2007-01-09 19:59:26 UTC (rev 2698)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_fade.cpp	2007-01-10 19:52:36 UTC (rev 2699)
@@ -1,224 +0,0 @@
-
-//
-// C++ Implementation: DIA_Fade
-//
-// Description: 
-//
-//
-// Author: mean <fixounet at free.fr>, (C) 2002-206
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-
-#include <config.h>
-
-#include <sys/types.h>
-#include <sys/stat.h>
-
-
-#include <gdk/gdkkeysyms.h>
-#include <gtk/gtk.h>
-
-
-#include <gdk/gdkkeysyms.h>
-#include <gtk/gtk.h>
-# include <math.h>
-
-#include "default.h"
-#include "ADM_toolkit_gtk/ADM_gladeSupport.h"
-#include "ADM_toolkit_gtk/toolkit_gtk.h"
-#include "ADM_toolkit_gtk/toolkit_gtk_include.h"
-#include "ADM_toolkit/toolkit.hxx"
-
-#include "ADM_video/ADM_vidFade_param.h"
-
-
-#define SPIN_GET(x,y) {param->y= gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(WID(x))) ;}
-#define SPIN_SET(x,y)  {gtk_spin_button_set_value(GTK_SPIN_BUTTON(WID(x)),(gfloat)param->y) ;}
-#define SGET(x) gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(WID(x))) 
-
-#define CHECK_GET(x,y) {param->y=gtk_toggle_button_get_active( GTK_TOGGLE_BUTTON(WID(x)));}
-#define CHECK_SET(x,y) {gtk_toggle_button_set_active( GTK_TOGGLE_BUTTON(WID(x)),param->y);}	
-
-static GtkWidget        *create_dialog1 (void);
-uint8_t DIA_fade(VIDFADE_PARAM *param)
-{
-  
-  GtkWidget *dialog;
-  int ret=0,done=0;
-  dialog=create_dialog1();
-        
-    // Update
-  SPIN_SET(spinbuttonStart,startFade);
-  SPIN_SET(spinbuttonEnd,endFade);
-  gtk_combo_box_set_active(GTK_COMBO_BOX(WID(comboboxinOut)),param->inOut);
-  CHECK_SET(checkbuttonBlack,toBlack);
-    // Run
-  gtk_register_dialog(dialog);
-  while(!done)
-  {
-    switch(gtk_dialog_run(GTK_DIALOG(dialog)))
-    {
-      case GTK_RESPONSE_OK:
-      {
-        uint32_t s,e;
-        s=SGET(spinbuttonStart);
-        e=SGET(spinbuttonEnd);
-        if(e<s)
-        {
-          GUI_Error_HIG("Bad parameters","The end frame must be after the start frame !"); 
-        }
-        else
-        {
-          param->startFade=s;
-          param->endFade=e;
-          param->inOut=gtk_combo_box_get_active(GTK_COMBO_BOX(WID(comboboxinOut)));
-          CHECK_GET(checkbuttonBlack,toBlack);
-          done=1;
-          ret=1;
-        }
-      }
-      break;
-      default:
-        done=1;
-        break;
-                
-    }
-  }
-  gtk_unregister_dialog(dialog);
-  gtk_widget_destroy(dialog);
-  return ret;
-}
-
-GtkWidget*
-create_dialog1 (void)
-{
-  GtkWidget *dialog1;
-  GtkWidget *dialog_vbox1;
-  GtkWidget *table1;
-  GtkWidget *label1;
-  GtkWidget *comboboxinOut;
-  GtkWidget *label2;
-  GtkWidget *label3;
-  GtkObject *spinbuttonStart_adj;
-  GtkWidget *spinbuttonStart;
-  GtkObject *spinbuttonEnd_adj;
-  GtkWidget *spinbuttonEnd;
-  GtkWidget *label4;
-  GtkWidget *checkbuttonBlack;
-  GtkWidget *dialog_action_area1;
-  GtkWidget *cancelbutton1;
-  GtkWidget *okbutton1;
-
-  dialog1 = gtk_dialog_new ();
-  gtk_window_set_title (GTK_WINDOW (dialog1), _("Fade Filter"));
-  gtk_window_set_type_hint (GTK_WINDOW (dialog1), GDK_WINDOW_TYPE_HINT_DIALOG);
-
-  dialog_vbox1 = GTK_DIALOG (dialog1)->vbox;
-  gtk_widget_show (dialog_vbox1);
-
-  table1 = gtk_table_new (4, 2, FALSE);
-  gtk_widget_show (table1);
-  gtk_box_pack_start (GTK_BOX (dialog_vbox1), table1, TRUE, TRUE, 0);
-
-  label1 = gtk_label_new (_("Fade Type"));
-  gtk_widget_show (label1);
-  gtk_table_attach (GTK_TABLE (table1), label1, 0, 1, 0, 1,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_misc_set_alignment (GTK_MISC (label1), 0, 0.5);
-
-  comboboxinOut = gtk_combo_box_new_text ();
-  gtk_widget_show (comboboxinOut);
-  gtk_table_attach (GTK_TABLE (table1), comboboxinOut, 1, 2, 0, 1,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (GTK_FILL), 0, 0);
-  gtk_combo_box_append_text (GTK_COMBO_BOX (comboboxinOut), _("Out"));
-  gtk_combo_box_append_text (GTK_COMBO_BOX (comboboxinOut), _("In"));
-
-  label2 = gtk_label_new (_("Start Frame"));
-  gtk_widget_show (label2);
-  gtk_table_attach (GTK_TABLE (table1), label2, 0, 1, 1, 2,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_misc_set_alignment (GTK_MISC (label2), 0, 0.5);
-
-  label3 = gtk_label_new (_("End Frame"));
-  gtk_widget_show (label3);
-  gtk_table_attach (GTK_TABLE (table1), label3, 0, 1, 2, 3,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_misc_set_alignment (GTK_MISC (label3), 0, 0.5);
-
-  spinbuttonStart_adj = gtk_adjustment_new (1, 0, 1000000, 1, 10, 10);
-  spinbuttonStart = gtk_spin_button_new (GTK_ADJUSTMENT (spinbuttonStart_adj), 1, 0);
-  gtk_widget_show (spinbuttonStart);
-  gtk_table_attach (GTK_TABLE (table1), spinbuttonStart, 1, 2, 1, 2,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (spinbuttonStart), TRUE);
-
-  spinbuttonEnd_adj = gtk_adjustment_new (1, 0, 1000000, 1, 10, 10);
-  spinbuttonEnd = gtk_spin_button_new (GTK_ADJUSTMENT (spinbuttonEnd_adj), 1, 0);
-  gtk_widget_show (spinbuttonEnd);
-  gtk_table_attach (GTK_TABLE (table1), spinbuttonEnd, 1, 2, 2, 3,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (spinbuttonEnd), TRUE);
-
-  label4 = gtk_label_new (_("Fade to black "));
-  gtk_widget_show (label4);
-  gtk_table_attach (GTK_TABLE (table1), label4, 0, 1, 3, 4,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_misc_set_alignment (GTK_MISC (label4), 0, 0.5);
-
-  checkbuttonBlack = gtk_check_button_new_with_mnemonic ("");
-  gtk_widget_show (checkbuttonBlack);
-  gtk_table_attach (GTK_TABLE (table1), checkbuttonBlack, 1, 2, 3, 4,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-
-  dialog_action_area1 = GTK_DIALOG (dialog1)->action_area;
-  gtk_widget_show (dialog_action_area1);
-  gtk_button_box_set_layout (GTK_BUTTON_BOX (dialog_action_area1), GTK_BUTTONBOX_END);
-
-  cancelbutton1 = gtk_button_new_from_stock ("gtk-cancel");
-  gtk_widget_show (cancelbutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), cancelbutton1, GTK_RESPONSE_CANCEL);
-  GTK_WIDGET_SET_FLAGS (cancelbutton1, GTK_CAN_DEFAULT);
-
-  okbutton1 = gtk_button_new_from_stock ("gtk-ok");
-  gtk_widget_show (okbutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), okbutton1, GTK_RESPONSE_OK);
-  GTK_WIDGET_SET_FLAGS (okbutton1, GTK_CAN_DEFAULT);
-
-  /* Store pointers to all widgets, for use by lookup_widget(). */
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog1, "dialog1");
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_vbox1, "dialog_vbox1");
-  GLADE_HOOKUP_OBJECT (dialog1, table1, "table1");
-  GLADE_HOOKUP_OBJECT (dialog1, label1, "label1");
-  GLADE_HOOKUP_OBJECT (dialog1, comboboxinOut, "comboboxinOut");
-  GLADE_HOOKUP_OBJECT (dialog1, label2, "label2");
-  GLADE_HOOKUP_OBJECT (dialog1, label3, "label3");
-  GLADE_HOOKUP_OBJECT (dialog1, spinbuttonStart, "spinbuttonStart");
-  GLADE_HOOKUP_OBJECT (dialog1, spinbuttonEnd, "spinbuttonEnd");
-  GLADE_HOOKUP_OBJECT (dialog1, label4, "label4");
-  GLADE_HOOKUP_OBJECT (dialog1, checkbuttonBlack, "checkbuttonBlack");
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_action_area1, "dialog_action_area1");
-  GLADE_HOOKUP_OBJECT (dialog1, cancelbutton1, "cancelbutton1");
-  GLADE_HOOKUP_OBJECT (dialog1, okbutton1, "okbutton1");
-
-  return dialog1;
-}
-

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am	2007-01-09 19:59:26 UTC (rev 2698)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am	2007-01-10 19:52:36 UTC (rev 2699)
@@ -10,12 +10,12 @@
 
 libADM_dialog_a_SOURCES = DIA_audio.cpp DIA_vcodec.cpp DIA_acodec.cpp \
 	DIA_audiocodec.cpp DIA_properties.cpp DIA_mjpeg.cpp DIA_about.cpp DIA_recent.cpp \
-	DIA_indexer.cpp DIA_resize.cpp DIA_4entries.cpp DIA_dnr.cpp DIA_working.cpp \
+	DIA_indexer.cpp DIA_resize.cpp DIA_dnr.cpp DIA_working.cpp \
 	DIA_working.h DIA_busy.cpp DIA_busy.h DIA_exLame.cpp DIA_pipe.cpp DIA_mpeg2opt.cpp \
 	DIA_d3d.cpp DIA_postproc.cpp DIA_enter.cpp DIA_enter.h DIA_xvcd.cpp DIA_muxer.cpp \
 	DIA_xvid.cpp DIA_crop.cpp DIA_color.cpp DIA_encoding.cpp DIA_SVCD.cpp DIA_prefs.cpp \
 	DIA_requant.cpp DIA_xvid4.cpp DIA_lavcodec.cpp DIA_kerneldeint.cpp \
-	DIA_audiodevice.cpp DIA_dectel.cpp DIA_decimate.cpp DIA_pause.cpp \
+	DIA_dectel.cpp DIA_decimate.cpp DIA_pause.cpp \
 	DIA_DVDff.cpp DIA_lavdecoder.cpp DIA_lame.cpp DIA_calculator.cpp DIA_equalizer.cpp \
 	DIA_vobsub.cpp DIA_x264.cpp DIA_ocr.cpp DIA_lavpp_deint.cpp DIA_hue.cpp DIA_eq2.cpp \
 	DIA_dgbob.cpp DIA_msharpen.cpp DIA_asharp.cpp DIA_dmx.cpp DIA_idx_pg.cpp DIA_gototime.cpp \
@@ -34,26 +34,25 @@
 	DIA_mcdeint.cpp \
 	DIA_defaultAudio.cpp \
 	DIA_partial.cpp \
-	DIA_fade.cpp \
 	DIA_ass.cpp DIA_bitrateHisto.cpp
 
 
 
 
-EXTRA_DIST =  DIA_4entries.cpp              DIA_enter.cpp     \
+EXTRA_DIST =  DIA_enter.cpp     \
 DIA_mcdeint.cpp     DIA_resize.cpp \
 DIA_cnr2.cpp          DIA_enter.h          DIA_mjpeg.cpp       DIA_resizeWiz.cpp \
 DIA_DVDff.cpp        DIA_color.cpp         DIA_eq2.cpp          DIA_mosaic.cpp      DIA_resizeWiz.h \
 DIA_coloryuv.cpp      DIA_equalizer.cpp    DIA_mpdelogo.cpp    DIA_rotate.cpp \
 DIA_SVCD.cpp         DIA_contrast.cpp      DIA_exLame.cpp       DIA_mpeg2opt.cpp    DIA_srt.cpp \
-DIA_about.cpp        DIA_conv.cpp          DIA_fade.cpp         DIA_msharpen.cpp    DIA_tdeint.cpp \
+DIA_about.cpp        DIA_conv.cpp          DIA_msharpen.cpp    DIA_tdeint.cpp \
 DIA_acodec.cpp       DIA_crop.cpp          DIA_gototime.cpp     DIA_muxer.cpp       DIA_v2v.cpp \
 DIA_animated.cpp     DIA_d3d.cpp           DIA_hue.cpp          DIA_ocr.cpp         DIA_vcodec.cpp \
 DIA_asharp.cpp       DIA_deblend.cpp       DIA_idx_pg.cpp       DIA_partial.cpp     DIA_vobsub.cpp \
 DIA_audio.cpp        DIA_decimate.cpp      DIA_idx_pg.h         DIA_pause.cpp       DIA_vorbis.cpp \
 DIA_audioTrack.cpp   DIA_dectel.cpp        DIA_indexer.cpp      DIA_pipe.cpp        DIA_working.cpp \
 DIA_audiocodec.cpp   DIA_defaultAudio.cpp  DIA_jobs.cpp         DIA_postproc.cpp    DIA_working.h \
-DIA_audiodevice.cpp  DIA_denoise.cpp       DIA_jobs_save.cpp    DIA_prefs.cpp       DIA_x264.cpp \
+DIA_denoise.cpp       DIA_jobs_save.cpp    DIA_prefs.cpp       DIA_x264.cpp \
 DIA_builtin.cpp      DIA_dgbob.cpp         DIA_kerneldeint.cpp  DIA_preview.cpp     DIA_xvcd.cpp \
 DIA_busy.cpp         DIA_dmx.cpp           DIA_lame.cpp         DIA_properties.cpp  DIA_xvid.cpp \
 DIA_busy.h           DIA_dnr.cpp           DIA_lavcodec.cpp     DIA_quota.cpp       DIA_xvid4.cpp \

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/FAC_float.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/FAC_float.cpp	2007-01-09 19:59:26 UTC (rev 2698)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/FAC_float.cpp	2007-01-10 19:52:36 UTC (rev 2699)
@@ -62,8 +62,8 @@
   widget = gtk_spin_button_new_with_range(min,max,0.1);
   gtk_spin_button_set_numeric (GTK_SPIN_BUTTON(widget),TRUE);
   gtk_spin_button_set_digits  (GTK_SPIN_BUTTON(widget),2);
+  gtk_spin_button_set_value (GTK_SPIN_BUTTON(widget),*(ELEM_TYPE_FLOAT *)param);
   
-  
   gtk_widget_show (widget);
   
   gtk_table_attach (GTK_TABLE (opaque), widget, 1, 2, line, line+1,

Added: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/FAC_menu.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/FAC_menu.cpp	2007-01-09 19:59:26 UTC (rev 2698)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/FAC_menu.cpp	2007-01-10 19:52:36 UTC (rev 2699)
@@ -0,0 +1,99 @@
+/***************************************************************************
+  FAC_toggle.cpp
+  Handle dialog factory element : Menu
+  (C) 2006 Mean Fixounet at free.fr 
+***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include <config.h>
+
+
+#include <string.h>
+#include <stdio.h>
+#include <math.h>
+
+#include "default.h"
+#include "ADM_toolkit_gtk/ADM_gladeSupport.h"
+#include "ADM_toolkit_gtk/toolkit_gtk.h"
+#include "ADM_toolkit_gtk/toolkit_gtk_include.h"
+#include "ADM_commonUI/DIA_factory.h"
+#include "ADM_assert.h"
+
+
+
+
+diaElemMenu::diaElemMenu(uint32_t *intValue,const char *itle, uint32_t nb, 
+               const diaMenuEntry *menu,const char *tip)
+  : diaElem(ELEM_MENU)
+{
+  param=(void *)intValue;
+  paramTitle=itle;
+  this->tip=tip;
+  this->menu=menu;
+  this->nbMenu=nb;
+}
+
+diaElemMenu::~diaElemMenu()
+{
+  
+}
+void diaElemMenu::setMe(void *dialog, void *opaque,uint32_t line)
+{
+  GtkWidget *widget;
+  GtkWidget *label;
+  GtkWidget *item;
+  GtkWidget *combo;
+  
+  
+  label = gtk_label_new (paramTitle);
+  gtk_widget_show(label);
+  
+  gtk_table_attach (GTK_TABLE (opaque), label, 0, 1, line, line+1,
+                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  
+  combo = gtk_combo_box_new_text ();
+  gtk_widget_show (combo);
+  gtk_table_attach (GTK_TABLE (opaque), combo, 1, 2, line, line+1,
+                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  
+  for(int i=0;i<nbMenu;i++)
+  {
+    gtk_combo_box_append_text (GTK_COMBO_BOX (combo),this->menu[i].text);
+  }
+  
+  for(int i=0;i<nbMenu;i++)
+  {
+    if(this->menu[i].val==*(uint32_t *)param) 
+    {
+      gtk_combo_box_set_active(GTK_COMBO_BOX(combo),i);
+    }
+  }
+  
+  
+  myWidget=(void *)combo;
+}
+
+void diaElemMenu::getMe(void)
+{
+  GtkWidget *widget=(GtkWidget *)myWidget;
+  uint32_t *val=(uint32_t *)param;
+  uint32_t rank;
+  ADM_assert(widget);
+  
+  
+  rank=gtk_combo_box_get_active(GTK_COMBO_BOX(widget));
+  ADM_assert(rank<this->nbMenu);
+  *(uint32_t *)param=this->menu[rank].val;
+}
+
+//EOF

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/Makefile.am	2007-01-09 19:59:26 UTC (rev 2698)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/Makefile.am	2007-01-10 19:52:36 UTC (rev 2699)
@@ -8,6 +8,6 @@
 
 libADM_dialogFactory_a_METASOURCES = AUTO
 
-libADM_dialogFactory_a_SOURCES = DIA_dialogFactory.cpp FAC_toggle.cpp FAC_integer.cpp FAC_float.cpp
+libADM_dialogFactory_a_SOURCES = DIA_dialogFactory.cpp FAC_toggle.cpp FAC_integer.cpp FAC_float.cpp FAC_menu.cpp
 
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp	2007-01-09 19:59:26 UTC (rev 2698)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp	2007-01-10 19:52:36 UTC (rev 2699)
@@ -43,7 +43,6 @@
 #include "ADM_video/ADM_vidDecTel_param.h"
 #include "ADM_audiofilter/audioencoder_lame_param.h"
 #include "ADM_video/ADM_vidDGbob_param.h"
-#include "ADM_video/ADM_vidFade_param.h"
 #include "ADM_audiofilter/audioencoder_lame_param.h"
 #include "ADM_video/ADM_vidMcDeint_param.h"
 #include "ADM_encoder/adm_encmjpeg_param.h"
@@ -99,7 +98,6 @@
 uint8_t  DIA_blendRemoval(BLEND_REMOVER_PARAM *mosaic){return 0;}
 uint8_t DIA_cnr2(CNR2Param *param){return 0;}
 uint8_t DIA_DVDffParam(COMPRES_PARAMS *incoming){return 0;}
-uint8_t DIA_fade(VIDFADE_PARAM *param){return 0;}
 uint8_t DIA_getASharp(ASHARP_PARAM *param, AVDMGenericVideoStream *in){return 0;}
 uint8_t DIA_getDecombDecimate(DECIMATE_PARAM *param){return 0;}
 uint8_t DIA_getDecombTelecide(TelecideParam *param){return 0;}

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialogFactory/FAC_toggle.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialogFactory/FAC_toggle.cpp	2007-01-09 19:59:26 UTC (rev 2698)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialogFactory/FAC_toggle.cpp	2007-01-10 19:52:36 UTC (rev 2699)
@@ -102,7 +102,27 @@
  
 }
 
+//******************************************************
 
+diaElemMenu::diaElemMenu(uint32_t *intValue,const char *itle, uint32_t nb, 
+               const diaMenuEntry *menu,const char *tip)
+  : diaElem(ELEM_MENU)
+{
+}
 
+diaElemMenu::~diaElemMenu()
+{
+  
+}
+void diaElemMenu::setMe(void *dialog, void *opaque,uint32_t line)
+{
+  
+}
+void diaElemMenu::getMe(void)
+{
+ 
+}
+
+
 //******************************************************
 //EOF

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp	2007-01-09 19:59:26 UTC (rev 2698)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp	2007-01-10 19:52:36 UTC (rev 2699)
@@ -43,7 +43,6 @@
 #include "ADM_video/ADM_vidDecTel_param.h"
 #include "ADM_audiofilter/audioencoder_lame_param.h"
 #include "ADM_video/ADM_vidDGbob_param.h"
-#include "ADM_video/ADM_vidFade_param.h"
 #include "ADM_audiofilter/audioencoder_lame_param.h"
 #include "ADM_video/ADM_vidMcDeint_param.h"
 #include "ADM_encoder/adm_encmjpeg_param.h"
@@ -99,7 +98,6 @@
 uint8_t  DIA_blendRemoval(BLEND_REMOVER_PARAM *mosaic){return 0;}
 uint8_t DIA_cnr2(CNR2Param *param){return 0;}
 uint8_t DIA_DVDffParam(COMPRES_PARAMS *incoming){return 0;}
-uint8_t DIA_fade(VIDFADE_PARAM *param){return 0;}
 uint8_t DIA_getASharp(ASHARP_PARAM *param, AVDMGenericVideoStream *in){return 0;}
 uint8_t DIA_getDecombDecimate(DECIMATE_PARAM *param){return 0;}
 uint8_t DIA_getDecombTelecide(TelecideParam *param){return 0;}

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/FAC_toggle.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/FAC_toggle.cpp	2007-01-09 19:59:26 UTC (rev 2698)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/FAC_toggle.cpp	2007-01-10 19:52:36 UTC (rev 2699)
@@ -102,5 +102,25 @@
 {
  
 }
+//******************************************************
 
+diaElemMenu::diaElemMenu(uint32_t *intValue,const char *itle, uint32_t nb, 
+               const diaMenuEntry *menu,const char *tip)
+  : diaElem(ELEM_MENU)
+{
+}
+
+diaElemMenu::~diaElemMenu()
+{
+  
+}
+void diaElemMenu::setMe(void *dialog, void *opaque,uint32_t line)
+{
+  
+}
+void diaElemMenu::getMe(void)
+{
+ 
+}
+
 //EOF

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_factory.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_factory.h	2007-01-09 19:59:26 UTC (rev 2698)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_factory.h	2007-01-10 19:52:36 UTC (rev 2699)
@@ -22,6 +22,7 @@
   ELEM_TOGGLE,
   ELEM_INTEGER,
   ELEM_FLOAT,
+  ELEM_MENU,
   ELEM_MAX=ELEM_TOGGLE
 };
 /*********************************************/
@@ -86,6 +87,29 @@
   void setMe(void *dialog, void *opaque,uint32_t line);
   void getMe(void);
 };
+/*************************************************/
+typedef struct diaMenuEntry
+{
+  uint32_t    val;
+  const char *text;
+  const char *desc;
+}diaMenuEntry;
+
+class diaElemMenu : public diaElem
+{
+const diaMenuEntry *menu;
+uint32_t     nbMenu;
+
+public:
+  diaElemMenu(uint32_t *intValue,const char *itle, uint32_t nb, 
+               const diaMenuEntry *menu,const char *tip=NULL);
+  
+  virtual ~diaElemMenu() ;
+  void setMe(void *dialog, void *opaque,uint32_t line);
+  void getMe(void);
+};
+
+/*************************************************/
 /*********************************************/
 uint8_t diaFactoryRun(const char *title,uint32_t nb,diaElem **elems);
 

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_guiMedianBig.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_guiMedianBig.cpp	2007-01-09 19:59:26 UTC (rev 2698)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_guiMedianBig.cpp	2007-01-10 19:52:36 UTC (rev 2699)
@@ -1 +0,0 @@
-// rmed

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFade.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFade.cpp	2007-01-09 19:59:26 UTC (rev 2698)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFade.cpp	2007-01-10 19:52:36 UTC (rev 2699)
@@ -1,263 +0,0 @@
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include "config.h"
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <math.h>
-#include <ADM_assert.h>
-
-#include "config.h"
-#include "fourcc.h"
-#include "avio.hxx"
-#include "avi_vars.h"
-
-#include "ADM_toolkit/toolkit.hxx"
-#include "ADM_editor/ADM_edit.hxx"
-#include "ADM_video/ADM_genvideo.hxx"
-#include"ADM_video/ADM_vidField.h"
-#include"ADM_video/ADM_cache.h"
-
-#include "ADM_osSupport/ADM_debugID.h"
-#define MODULE_NAME MODULE_FILTER
-#include "ADM_osSupport/ADM_debug.h"
-#include "ADM_filter/video_filters.h"
-#include "ADM_vidFade_param.h"
-
-class AVDM_Fade : public AVDMGenericVideoStream
-{
-  VideoCache      *vidCache;
-  VIDFADE_PARAM   *_param;
-  uint16_t         lookupLuma[256][256];
-  uint16_t         lookupChroma[256][256];
-  uint8_t         buildLut(void);
-  public:
-                                
-                    AVDM_Fade(AVDMGenericVideoStream *in,CONFcouple *couples);    
-                    ~AVDM_Fade(void);
-    uint8_t         getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-                                          ADMImage *data,uint32_t *flags);
-        
-    char            *printConf( void );
-    uint8_t         configure(AVDMGenericVideoStream *in);
-    uint8_t         getCoupledConf( CONFcouple **couples);
-};
-
-static FILTER_PARAM fadeParam={4,{"startFade","endFade","inOut","toBlack"}};
-
-BUILD_CREATE(fade_create,AVDM_Fade);
-SCRIPT_CREATE(fade_script,AVDM_Fade,fadeParam);
-
-/*************************************/
-uint8_t DIA_fade(VIDFADE_PARAM *param);
-uint8_t AVDM_Fade::configure(AVDMGenericVideoStream *in)
-{
-  _in=in;
-  return DIA_fade(_param);
-}
-
-char *AVDM_Fade::printConf( void )
-{
-  static char buf[50];
-
-        //ADM_assert(_param);
-  sprintf((char *)buf," Fade : Start %u End %u",_param->startFade,_param->endFade);
-  if(_param->inOut) strcat(buf," In"); else strcat(buf," Out");
-  return buf;
-}
-
-
-AVDM_Fade::AVDM_Fade(AVDMGenericVideoStream *in,CONFcouple *couples)
-
-{
-                
-  int count = 0;
-  char buf[80];
-  unsigned int *p;
-
-  _in=in;         
-  memcpy(&_info,_in->getInfo(),sizeof(_info));    
-  _info.encoding=1;
-  vidCache=new VideoCache(3,in);
-  
-  _param=new VIDFADE_PARAM;
-  if(couples)
-  {
-    GET(startFade);
-    GET(endFade);
-    GET(inOut);
-    GET(toBlack);
-    
-  }else
-  {
-    _param->startFade=0; 
-    _param->endFade=_info.nb_frames-1;
-    _param->inOut=0;
-    _param->toBlack=0;
-  }
-  buildLut();
-}
-//________________________________________________________
-uint8_t AVDM_Fade::getCoupledConf( CONFcouple **couples)
-{
-  *couples=new CONFcouple(4);
-  CSET(startFade);
-  CSET(endFade);
-  CSET(inOut);
-  CSET(toBlack);
-  return 1;
-}
-//________________________________________________________
-AVDM_Fade::~AVDM_Fade(void)
-{
-                
-  if(vidCache) delete vidCache;                
-  vidCache=NULL;   
-  if(_param) delete _param;
-  _param=NULL;
-}
-uint8_t AVDM_Fade::getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-                                            ADMImage *data,uint32_t *flags)
-{
-
-  uint32_t num_frames,tgt;
-  
-  ADMImage *src;
-
-  num_frames=_info.nb_frames;   // ??
-
-  tgt=frame+_info.orgFrame;
-  if(frame>=num_frames)
-  {
-    printf("[Fade] out of bound\n");
-    return 0;
-  }
-
-  src=vidCache->getImage(frame);
-  if(!src) return 0;
-  if(tgt>_param->endFade || tgt <_param->startFade ||_param->endFade==_param->startFade )
-  {
-    //printf("Cur %u start %u end %u\n",tgt,_param->startFade,_param->endFade);
-    data->duplicate(src);
-    vidCache->unlockAll();
-    return 1;
-  }
-  uint8_t *s,*d,*s2;
-  uint16_t *index,*invertedIndex;
-  uint32_t count=_info.width*_info.height,w;
-  float num,den;
-  
-  den=_param->endFade-_param->startFade;
-  
-  num=tgt-_param->startFade;
-  
-  num=num/den;
-  num*=255.;
-  w=(uint32_t)floor(num+0.4);
-  
-//printf("w :%u\n",w);
-
-  s=src->data;
-  d=data->data;
-  if(_param->toBlack)
-  {
-        index=lookupLuma[w];
-        for(int i=0;i<count;i++)
-        {
-          *d++=(index[*s++]>>8);
-        }
-        // Now do chroma
-        count>>=2;
-        s=UPLANE(src);
-        d=UPLANE(data);
-        index=lookupChroma[w];
-        for(int i=0;i<count;i++)
-        {
-          *d++=(index[*s++]>>8);
-        }
-        s=VPLANE(src);
-        d=VPLANE(data);
-        for(int i=0;i<count;i++)
-        {
-          *d++=(index[*s++]>>8);
-        }
-  }
-  else
-  {
-        uint32_t x,alpha;
-        ADMImage *final;
-
-        final=vidCache->getImage(_param->endFade-_info.orgFrame);
-        if(!final)
-        {
-              data->duplicate(src);
-              vidCache->unlockAll();
-              return 1;
-        }
-
-        s2=final->data;
-
-        index=lookupLuma[w];
-        
-        invertedIndex=lookupLuma[255-w];
-        for(int i=0;i<count;i++)
-        {
-          *d++=(index[*s++]+invertedIndex[*s2++])>>8;
-        }
-        // Now do chroma
-        count>>=2;
-        s=UPLANE(src);
-        d=UPLANE(data);
-        s2=UPLANE(final);
-        index=lookupChroma[w];
-        invertedIndex=lookupChroma[255-w];
-        for(int i=0;i<count;i++)
-        {
-            *d++=(index[*s++]+invertedIndex[*s2++]-(128<<8))>>8;
-        }
-        s=VPLANE(src);
-        d=VPLANE(data);
-        s2=VPLANE(final);
-        for(int i=0;i<count;i++)
-        {
-            *d++=(index[*s++]+invertedIndex[*s2++]-(128<<8))>>8;
-            
-        }
-  }
-  vidCache->unlockAll();
-  return 1;
-}
-
-uint8_t AVDM_Fade::buildLut(void)
-{
-  float f,ration;
-  for(int i=0;i<256;i++)
-  {
-    if(!_param->inOut) ration=255-i;
-    else ration=i;
-    for(int r=0;r<256;r++)
-    {
-      f=r;
-      f=f*ration;
-      lookupLuma[i][r]=(uint16_t)(f+0.4);
-
-      f=r-128;
-      f=f*ration;
-      lookupChroma[i][r]=(128<<8)+(uint16_t)(f+0.4);
-
-    }
-    
-  }
-  return 1;
-}
-//EOF
-
-
-

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFade_param.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFade_param.h	2007-01-09 19:59:26 UTC (rev 2698)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFade_param.h	2007-01-10 19:52:36 UTC (rev 2699)
@@ -1,23 +0,0 @@
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#ifndef ADM_VIDFADE_PARAM_H
-#define ADM_VIDFADE_PARAM_H
-
-typedef struct VIDFADE_PARAM
-{
-  uint32_t startFade;
-  uint32_t endFade;
-  uint32_t inOut; //0 Out 1 In
-  uint32_t toBlack; // =1 else fade to endFrame
-}VIDFADE_PARAM;
-
-
-
-#endif

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidResampleFPS.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidResampleFPS.cpp	2007-01-09 19:59:26 UTC (rev 2698)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidResampleFPS.cpp	2007-01-10 19:52:36 UTC (rev 2699)
@@ -1,363 +0,0 @@
-/***************************************************************************
-                          Resample fps
-                             -------------------
-    begin                : Wed Nov 6 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include <stdio.h>
-#include <math.h>
-
-#include <stdlib.h>
-#include <string.h>
-#include <ADM_assert.h>
-
-#include "config.h"
-#include "fourcc.h"
-#include "avio.hxx"
-#include "config.h"
-#include "avi_vars.h"
-#ifdef HAVE_ENCODER
-
-
-#include "ADM_toolkit/toolkit.hxx"
-#include "ADM_editor/ADM_edit.hxx"
-#include "ADM_video/ADM_genvideo.hxx"
-#include "ADM_video/ADM_vidFlipV.h"
-#include "ADM_filter/video_filters.h"
-#include "DIA_enter.h"
-#include "ADM_video/ADM_cache.h"
-#include "ADM_osSupport/ADM_cpuCap.h"
-#include "admmangle.h"
-
-static FILTER_PARAM ResampParam={2,{"newfps","use_linear"}};
-typedef struct FPS_Param
-{
-  uint32_t  newfps; 
-  uint32_t  use_linear;
-}FPS_Param;
-class  ADMVideoResampleFPS:public AVDMGenericVideoStream
-{
-
-  protected:
-    AVDMGenericVideoStream  *_in;           
-    virtual char            *printConf(void);
-            FPS_Param       *_param;    
-            VideoCache      *vidCache; 
-  public:
-                
-                        ADMVideoResampleFPS(  AVDMGenericVideoStream *in,CONFcouple *setup);
-                        ADMVideoResampleFPS(  AVDMGenericVideoStream *in,uint32_t target1000);
-    virtual             ~ADMVideoResampleFPS();
-    virtual uint8_t     configure(AVDMGenericVideoStream *in);
-    virtual uint8_t     getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-                                          ADMImage *data,uint32_t *flags);
-
-             uint8_t     getCoupledConf( CONFcouple **couples);
-}     ;
-
-SCRIPT_CREATE(resamplefps_script,ADMVideoResampleFPS,ResampParam);
-BUILD_CREATE(resamplefps_create,ADMVideoResampleFPS);
-
-AVDMGenericVideoStream *createResampleFps(AVDMGenericVideoStream *in,uint32_t targetfps1000)
-{
-  return new ADMVideoResampleFPS(in,targetfps1000);
-}
-
-uint8_t ADMVideoResampleFPS::configure(AVDMGenericVideoStream *in)
-{
-  uint8_t r=0;
-  float f=_param->newfps;
-  
-  f/=1000;
-  
-  _in=in;     
-  if(DIA_GetFloatValue(&f, 1.0, 200., "Enter new fps","New fps:"))
-  {
-    f*=1000;
-    _param->newfps=(uint32_t)floor(f+0.4); 
-    _info.fps1000=_param->newfps;   
-    
-    if(GUI_Question(_("Use linear blend ?")))
-    {
-        _param->use_linear=1;        
-    }
-    else
-    {
-        _param->use_linear=0;        
-    }
-    r=1;
-  } 
-  return r;        
-}
-char *ADMVideoResampleFPS::printConf( void )
-{
-  static char buf[50];
-        
-  sprintf((char *)buf," Resample to %2.2f fps (blend:%d)",(double)_param->newfps/1000.,
-                _param->use_linear);
-  return buf;
-}
-
-ADMVideoResampleFPS::ADMVideoResampleFPS(  AVDMGenericVideoStream *in,uint32_t target)
-{
-
-  _in=in;         
-  memcpy(&_info,_in->getInfo(),sizeof(_info));    
-  _info.encoding=1; 
-  _param=new  FPS_Param;
-   
-    _param->newfps =target;                
-    _param->use_linear=1;
- 
-  double newlength;
-  
-  newlength=_info.nb_frames;
-  newlength/=_info.fps1000;
-  newlength*=_param->newfps;
-  _info.nb_frames=(uint32_t)floor(newlength);
-  _info.fps1000=_param->newfps;
-  printf("[Resample FPS] %u -> %u\n",_in->getInfo()->nb_frames,_info.nb_frames);
-  vidCache=new VideoCache(3,_in);
-
-}
-
-ADMVideoResampleFPS::ADMVideoResampleFPS(  AVDMGenericVideoStream *in,CONFcouple *couples)
-{
-  
-  _in=in;         
-  memcpy(&_info,_in->getInfo(),sizeof(_info));    
-  _info.encoding=1; 
-  _param=new  FPS_Param;
-   
-  if(couples)
-  {                 
-    GET(newfps);    
-    GET(use_linear); 
-  }
-  else
-  {
-    _param->newfps =_info.fps1000;                
-    _param->use_linear=0;
-  }      
- 
-  double newlength;
-  
-  newlength=_info.nb_frames;
-  newlength/=_info.fps1000;
-  newlength*=_param->newfps;
-  _info.nb_frames=(uint32_t)floor(newlength);
-  _info.fps1000=_param->newfps;
-  vidCache=new VideoCache(3,_in);
-  
-}
-ADMVideoResampleFPS::~ADMVideoResampleFPS()
-{
-  delete _param;
-  delete vidCache;
-  
-}
-uint8_t ADMVideoResampleFPS::getCoupledConf( CONFcouple **couples)
-{
-  ADM_assert(_param);
-  *couples=new CONFcouple(2);
-
-
-                CSET(newfps);
-                CSET(use_linear);
-                return 1;
-}
-#if (defined( ARCH_X86)  || defined(ARCH_X86_64))
-static uint64_t low,high;
-static void blendMMX(uint8_t *src, uint8_t *src2, uint8_t *dst, uint8_t alpha, uint8_t beta,uint32_t count)
-{
-uint32_t left=count&3;
-#define EXPAND(x) (x)+((x)<<16)+((x)<<32) +((x)<<48)
-        high=alpha;
-        low=beta;
-        high=EXPAND(high);
-        low=EXPAND(low);
-        count>>=2;
-#ifdef GCC_2_95_X
-         __asm__ __volatile__ (
-                                "movq "Mangle(high)", %mm0\n"
-                                "movq "Mangle(low)",  %mm1\n"                                
-                                "pxor %mm7        ,  %mm7\n"
-                                :: );
-#else
-         __asm__ __volatile__ (
-                                "movq "Mangle(high)", %%mm0\n"
-                                "movq "Mangle(low)",  %%mm1\n"                                
-                                "pxor %%mm7        ,  %%mm7\n"
-                                :: );
-#endif
-
-        while(count>0)
-        {
-                __asm__ __volatile__ (
-                               
-                                "movd      (%0),  %%mm2\n"
-                                "movd      (%1),  %%mm3\n"                               
-
-                                "punpcklbw %%mm7, %%mm2\n"
-                                "punpcklbw %%mm7, %%mm3\n"
-
-                                "pmullw   %%mm0, %%mm2\n"
-                                "pmullw   %%mm1, %%mm3\n"
-                
-                                "paddw    %%mm3, %%mm2\n"
-
-                                "psrlw    $8,    %%mm2 \n"
-
-                                "packuswb %%mm2,%%mm2\n"
-                                "movd     %%mm2, (%2)\n"
-
-                                :: "r" (src), "r" (src2), "r" (dst) );
-                                
-                src+=4;
-                src2+=4;
-                dst+=4;
-                count--;
-        }
-        __asm__ __volatile__ (
-                                "emms\n"
-                                :: );
-        for(uint32_t i=0;i<left;i++)
-        {
-                dst[i] = ((src[i]*alpha) + (src2[i]*beta))>>8;
-        }
-}
-
-#endif
-
-uint8_t ADMVideoResampleFPS::getFrameNumberNoAlloc(uint32_t frame,
-                                             uint32_t *len,
-                                             ADMImage *data,
-                                             uint32_t *flags)
-{
-  ADMImage *mysrc1=NULL;
-  ADMImage *mysrc2=NULL;
-
-  ADM_assert(frame<_info.nb_frames);
-  // read uncompressed frame
-  
-  // What frame are we seeking ?
-  double f;
-  uint32_t page=_info.width*_info.height;
-  
-  f=frame;
-  f*=_in->getInfo()->fps1000;
-  f/=_param->newfps;
-  
-  if(!_param->use_linear)
-  {
-      uint32_t nw;
-      
-      nw=(uint32_t)floor(f+0.4);
-      if(nw>_in->getInfo()->nb_frames-1)
-        nw=_in->getInfo()->nb_frames-1;
-    
-      mysrc1=vidCache->getImage(nw);
-      if(!mysrc1) return 0;
-      
-      memcpy(YPLANE(data),YPLANE(mysrc1),page);
-      memcpy(UPLANE(data),UPLANE(mysrc1),page>>2);
-      memcpy(VPLANE(data),VPLANE(mysrc1),page>>2);
-    
-      vidCache->unlockAll();
-      
-      return 1;
-  }
-  /* With linear blending */
-  uint32_t nw;
-  uint8_t lowweight;
-  uint8_t highweight;
-  
-  double diff;
-  
-  nw=(uint32_t)floor(f);
-  diff=f-floor(f);
-  highweight = (uint8_t)floor(diff*256);
-  lowweight = 256 - highweight;
-
-  if(nw>=_in->getInfo()->nb_frames-1)
-    {
-      printf("[ResampleFps] In %u Out %u\n",frame,nw);
-      nw=_in->getInfo()->nb_frames-1;
-      highweight=0;
-    }
-  //printf("New:%lu old:%lu\n",frame,nw);
-
-  if(highweight == 0)
-    {
-      mysrc1=vidCache->getImage(nw);  
-      if(!mysrc1) return 0;
-      
-      memcpy(YPLANE(data),YPLANE(mysrc1),page);
-      memcpy(UPLANE(data),UPLANE(mysrc1),page>>2);
-      memcpy(VPLANE(data),VPLANE(mysrc1),page>>2);
-      
-      vidCache->unlockAll();
-    }
-  else
-    {
-      mysrc1=vidCache->getImage(nw);
-      mysrc2=vidCache->getImage(nw+1);
-      if(!mysrc1 || !mysrc2) return 0;
-      
-      uint8_t *out, *in1, *in2;
-      uint32_t count;
-      uint32_t idx;
-      
-      out = YPLANE(data);
-      in1 = YPLANE(mysrc1);
-      in2 = YPLANE(mysrc2);
-        
-      count = page;
-
-#if (defined( ARCH_X86)  || defined(ARCH_X86_64))
-        if(CpuCaps::hasMMX())
-                blendMMX(in1,in2,out,lowweight,highweight,(count*3)>>1);
-        else
-#endif
-      {
-      for(idx = 0; idx < count; ++idx)
-	out[idx] = ((in1[idx]*lowweight) + (in2[idx]*highweight))>>8;
-
-      out = UPLANE(data);
-      in1 = UPLANE(mysrc1);
-      in2 = UPLANE(mysrc2);
-      count = page>>2;
-
-      for(idx = 0; idx < count; ++idx)
-        out[idx] = ((in1[idx]*lowweight) + (in2[idx]*highweight))>>8;      
-
-
-      out = VPLANE(data);
-      in1 = VPLANE(mysrc1);
-      in2 = VPLANE(mysrc2);
-      count = page>>2;
-
-      for(idx = 0; idx < count; ++idx)
-	out[idx] = ((in1[idx]*lowweight) + (in2[idx]*highweight))>>8;
-      }
-
-      vidCache->unlockAll();
-    }
-  return 1;
- 
-}
-
-
-
-#endif

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSoften.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSoften.cpp	2007-01-09 19:59:26 UTC (rev 2698)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSoften.cpp	2007-01-10 19:52:36 UTC (rev 2699)
@@ -1,338 +0,0 @@
-//
-// C++ Implementation: Soften
-//
-// Description: 
-//
-// See .h file
-//
-// Author: mean <fixounet at free.fr>, (C) 2004
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-
-//
-//	This is the very unoptimized version
-//	could use some stuff and some mmx too
-//
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <ADM_assert.h>
-#include <math.h>
-#include <math.h>
-#include <iconv.h>
-#include "config.h"
-
-
-#include "fourcc.h"
-#include "avio.hxx"
-
-#include "avi_vars.h"
-
-#include "ADM_toolkit/toolkit.hxx"
-#include "ADM_editor/ADM_edit.hxx"
-#include "ADM_video/ADM_genvideo.hxx"
-
-#include "ADM_osSupport/ADM_debugID.h"
-#define MODULE_NAME MODULE_FILTER
-#include "ADM_osSupport/ADM_debug.h"
-
-
-
-#include "ADM_vidSoften.h"
-#include "DIA_enter.h"
-#include "ADM_filter/video_filters.h"
-
-
-static FILTER_PARAM softParam={3,{"radius","luma","chroma"}};
-
-
-SCRIPT_CREATE(soften_script,ADMVideoMaskedSoften,softParam);
-BUILD_CREATE(soften_create,ADMVideoMaskedSoften);
-
-extern uint8_t distMatrix[256][256];
-extern uint32_t fixMul[16];
-
-
-uint8_t ADMVideoMaskedSoften::configure( AVDMGenericVideoStream *instream)
-{
-	_in=instream;
-	int radius, luma, chroma;
-	
-		radius=_param->radius;
-		luma=_param->luma;
-		chroma=_param->chroma;
-		if(DIA_GetIntegerValue(&radius,1,60, "Radius","Radius:"))
-		{
-			if(DIA_GetIntegerValue(&luma,0,255, "Luma Threshold","Luma Threshold:"))
-			{	
-				if(DIA_GetIntegerValue(&chroma,0,255, "Chroma Threshold","Chroma Threshold:"))
-				{
-					_param->radius=radius;
-					_param->luma=luma;
-					_param->chroma=chroma;
-					return 1;
-				}
-			}
-
-		}
-		return 0;
-}
-uint8_t	ADMVideoMaskedSoften::getCoupledConf( CONFcouple **couples)
-{
-
-			*couples=new CONFcouple(3);
-
-			CSET(radius);
-			CSET(luma);
-			CSET(chroma);
-
-		return 1;	
-}
-char *ADMVideoMaskedSoften::printConf( void )
-{
- 	static char buf[50];
- 	
- 	sprintf((char *)buf," Soften : radius: %lu l:%lu c:%lu", 
-		_param->radius,_param->luma, _param->chroma);
-        return buf;
-}
-
-ADMVideoMaskedSoften::~ADMVideoMaskedSoften()
-{
-	if(_uncompressed)
- 		delete _uncompressed;	
- 	_uncompressed=NULL;
-}
-
-
- ADMVideoMaskedSoften::ADMVideoMaskedSoften( AVDMGenericVideoStream *in,CONFcouple *couples)
-{
-		
-		_uncompressed=NULL;
-		_in=in;
-		ADM_assert(in);
-		if(!couples)
-		{
-			
-			_param=NEW(MaskedSoften_CONF);
-	    		_param->radius=2; 
-	    		_param->luma=5;
-			_param->chroma=5;
-			
-	    	}
-		else
-		{
-			_param=NEW(MaskedSoften_CONF);
-			GET(radius);
-			GET(luma);
-			GET(chroma);
-			
-						
-		}
-		ADM_assert(in);
-		
-		memcpy(&_info,_in->getInfo(),sizeof(_info));	
-			    	
-	    	//_uncompressed=new uint8_t[3*_info.width*_info.height];	
-		_uncompressed=new ADMImage(_info.width,_info.height);	
-		
-
-}
-uint8_t ADMVideoMaskedSoften::getFrameNumberNoAlloc(uint32_t frame,
-				uint32_t *len,
-   				ADMImage *data,
-				uint32_t *flags)
-{
-		uint32_t page=_info.width*_info.height;
-		int32_t radius=_param->radius;
-		uint32_t offset;
-		
-		int blockx,blocky;
-		
-		*len=(page*3)>>1;
-		if(frame>=_info.nb_frames) return 0;		
-		
-				
-		if(!_in->getFrameNumberNoAlloc(frame, len,_uncompressed,flags))
-				 		return 0;
-
-		// do luma only ATM
-		// copy chroma
-		memcpy(UPLANE(data),UPLANE(_uncompressed),page>>2);
-		memcpy(VPLANE(data),VPLANE(_uncompressed),page>>2);
-		
-		// for luma, the radius first lines /last lines are unchanged
-		memcpy(YPLANE(data),YPLANE(_uncompressed),radius*_info.width);
-		
-		offset=page-_info.width*radius-1;
-		
-		memcpy(YPLANE(data)+offset,
-			YPLANE(_uncompressed)+offset,
-			radius*_info.width);
-
-		uint8_t *src,*dst;
-		uint32_t val,cur,coef;
-		//
-		data->copyInfo(_uncompressed);
-		// optimized one
-		if(radius==2) return radius5(YPLANE(_uncompressed),YPLANE(data));
-		if(radius==1) return radius3(YPLANE(_uncompressed),YPLANE(data));
-		
-		for(uint32_t y=radius;y<_info.height-radius;y++)
-		{
-			src=YPLANE(_uncompressed)+y*_info.width;
-			dst=YPLANE(data)+y*_info.width;
-			
-			memcpy(dst,src,radius);
-			src+=radius;
-			dst+=radius;
-			
-			for(uint32_t x=radius;x<_info.width-radius;x++)
-			{
-				coef=0;
-				val=0;
-			
-				for( blocky=-radius;blocky<=radius;blocky++)
-				{
-					for( blockx=-radius;blockx<=radius;blockx++)
-					{
-						cur=*(src+blockx+blocky*_info.width);
-						
-						if( distMatrix[cur][*src]<=_param->luma)
-						{
-							coef++;
-							val+=cur;
-						}
-					
-					
-					}
-				}
-				ADM_assert(coef);
-				if(coef!=1)
-					val=(val+(coef>>1)-1)/coef;
-				*dst++=val;
-				src++;
-				
-				//*dst++=*src++;
-			}
-			memcpy(dst,src,radius);
-		
-		}	
-	return 1;
-}
-uint8_t ADMVideoMaskedSoften::radius5(uint8_t *_uncompressed, uint8_t *data) 
-{
-int blockx,blocky;
-uint32_t val,coef;
-
-uint8_t *src,*dst;
-uint8_t cur;
-
-uint8_t *c0,*c1,*c2,*c3,*c4,ref;
-
-
-
-	for(uint32_t y=2;y<_info.height-2;y++)
-		{
-			src=_uncompressed+y*_info.width;
-			dst=data+y*_info.width;
-			
-			*dst++=*src++;
-			*dst++=*src++;
-			
-			for(uint32_t x=2;x<_info.width-2;x++)
-			{
-				coef=0;
-				val=0;
-				c0=src-2-2*_info.width;
-				c1=c0+_info.width;
-				c2=c1+_info.width;
-				c3=c2+_info.width;
-				c4=c3+_info.width;
-				
-				ref=*src;
-					
-#define CHECK(x) cur=*x;if(distMatrix[cur][ref]<=_param->luma) {coef++;val+=cur;}x++;					
-				for( blockx=5;blockx>0;blockx--)
-				{
-					CHECK(c0);
-					CHECK(c1);
-					CHECK(c2);
-					CHECK(c3);
-					CHECK(c4);
-				}
-				ADM_assert(coef);
-				if(coef!=1)
-					val=(val+(coef>>1)-1)/coef;
-
-				*dst++=val;
-				src++;
-			}
-			*dst++=*src++;
-			*dst++=*src++;		
-		}	
-}
-uint8_t ADMVideoMaskedSoften::radius3(uint8_t *_uncompressed, uint8_t *data) 
-{
-int blockx,blocky;
-uint32_t val,coef;
-
-uint8_t *src,*dst;
-uint8_t cur;
-
-uint8_t *c0,*c1,*c2,ref;
-
-uint8_t *dist;
-
-	for(uint32_t y=1;y<_info.height-1;y++)
-		{
-			src=_uncompressed+y*_info.width;
-			dst=data+y*_info.width;
-			
-			*dst++=*src++;
-			
-			
-			for(uint32_t x=1;x<_info.width-1;x++)
-			{
-				coef=0;
-				val=0;
-				c0=src-1-_info.width;
-				c1=c0+_info.width;
-				c2=c1+_info.width;
-				
-				ref=*src;
-				dist=distMatrix[ref];
-#undef CHECK				
-#define CHECK(x) cur=*x;if(dist[cur]<=_param->luma) {coef++;val+=cur;}x++;					
-					CHECK(c0);
-					CHECK(c0);
-					CHECK(c0);
-					
-					CHECK(c1);
-					CHECK(c1);					
-					CHECK(c1);
-					
-					CHECK(c2);
-					CHECK(c2);					
-					CHECK(c2);
-				
-					
-				ADM_assert(coef);
-				if(coef!=1)
-					val=(val+(coef>>1)-1)/coef;
-				*dst++=val;
-				src++;
-			}
-			*dst++=*src++;
-			
-		}	
-}
-
-
-
-
-
-

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSoften.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSoften.h	2007-01-09 19:59:26 UTC (rev 2698)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSoften.h	2007-01-10 19:52:36 UTC (rev 2699)
@@ -1,49 +0,0 @@
-//
-// C++ Interface: ADM_vidSoften
-//
-// Description: 
-//
-// Very similar to Avisynth spatial soften
-// you might even say inspired by
-//
-//
-// Author: mean <fixounet at free.fr>, (C) 2004
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-
-#ifndef MSOFTEN_
-#define MSOFTEN_
-
-typedef struct MaskedSoften_CONF
-{
-	uint32_t luma,chroma;
-	uint32_t radius;
-}MaskedSoften_CONF;
-
- class  ADMVideoMaskedSoften:public AVDMGenericVideoStream
- {
-
- protected:
-    		
-		
-     virtual 	char 			*printConf(void);
-		uint8_t			*_reverse;
-		uint8_t 		radius5(uint8_t *_uncompressed, uint8_t *data) ;
-		uint8_t 		radius3(uint8_t *_uncompressed, uint8_t *data) ;
-
- public:
-		MaskedSoften_CONF *_param;
-
-  				ADMVideoMaskedSoften(  AVDMGenericVideoStream *in,
-							CONFcouple *setup);
-
-  	virtual 		~ADMVideoMaskedSoften();
-	virtual uint8_t 	getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-          						ADMImage *data,uint32_t *flags);
-	virtual uint8_t 	configure( AVDMGenericVideoStream *instream) ;
-	virtual uint8_t		getCoupledConf( CONFcouple **couples);
-	
- }     ;
-#endif

Modified: branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am	2007-01-09 19:59:26 UTC (rev 2698)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am	2007-01-10 19:52:36 UTC (rev 2699)
@@ -9,7 +9,6 @@
 libADM_video_a_SOURCES = ADM_vidFields.cpp \
  ADM_vidDeintASM.cpp \
  ADM_vidVlad.cpp \
- ADM_guiMedianBig.cpp \
  ADM_vidLargeMedian.cpp \
  ADM_vidSalt.cpp \
  ADM_vidCached.cpp \
@@ -63,7 +62,6 @@
 	ADM_mpdetc.cpp \
  ADM_vidKernelDeint.cpp \
  ADM_vidForcedPP.cpp \
- ADM_vidSoften.cpp \
  ADM_vidDecTelecide.cpp \
  ADM_vidDecTelecide.h ADM_cache.cpp \
  ADM_vidDecDec.cpp \
@@ -73,7 +71,6 @@
  ADM_vobsubinfo.cpp \
  ADM_vidChangeFPS.cpp \
  ADM_vidVobSubRender.cpp \
- ADM_vidResampleFPS.cpp \
  ADM_lavpp_deint.cpp \
  ADM_vidHue.cpp \
  ADM_vidEq2.cpp \
@@ -93,7 +90,7 @@
  ADM_guiResize.cpp \
  ADM_vidAnimated.cpp \
  ADM_vidMcDeint.cpp \
- ADM_vidReverse.cpp ADM_vidFade.cpp \
+ ADM_vidReverse.cpp  \
  ADM_vidASS.cpp
 
 				
@@ -108,15 +105,15 @@
 ADM_vidDeinterlace.h  ADM_vidPartial.h \
 ADM_vidDelta.cpp  ADM_vidPartial_param.h \
 ADM_guiCrop.cpp  ADM_vidDenoise.cpp  ADM_vidPulldown.cpp \
-ADM_guiMedianBig.cpp ADM_vidDenoise.h  ADM_vidPulldown.h \
+ADM_vidDenoise.h  ADM_vidPulldown.h \
 ADM_guiResize.cpp  ADM_vidDropOut.cpp  ADM_vidRaw.cpp \
-ADM_interlaced.cpp ADM_vidDropOut.h  ADM_vidResampleFPS.cpp \
+ADM_interlaced.cpp ADM_vidDropOut.h  \
 ADM_interlaced.h ADM_vidEq2.cpp  ADM_vidResize.cpp \
 ADM_lavpp_deint.cpp  ADM_vidEq2.h  ADM_vidResize25.cpp \
 ADM_lavpp_deintparam.h ADM_vidEqualizer.cpp  ADM_vidReverse.cpp \
 ADM_mpdetc.cpp ADM_vidEqualizer.h  ADM_vidRotate.cpp \
-ADM_mpdetc.h ADM_vidFade.cpp ADM_vidRotate.h \
-ADM_resizebis.cpp  ADM_vidFade_param.h ADM_vidSRT.cpp \
+ADM_mpdetc.h ADM_vidRotate.h \
+ADM_resizebis.cpp   ADM_vidSRT.cpp \
 ADM_resizebis.hxx    ADM_vidSRT.h \
 ADM_resizeter.cpp  ADM_vidField.h  ADM_vidSRTRender.cpp \
 ADM_separateField.cpp  ADM_vidFieldUnblend.cpp ADM_vidSRTload.cpp \
@@ -124,8 +121,8 @@
 ADM_vidFieldUtil.h  ADM_vidSalt.h \
 ADM_vidFields.cpp ADM_vidSeparateField.cpp \
 ADM_vidAnimated.cpp  ADM_vidFlipV.cpp  ADM_vidSeparateField.h \
-ADM_vidAnimated.h  ADM_vidFlipV.h  ADM_vidSoften.cpp \
-ADM_vidAnimated_param.h   ADM_vidSoften.h \
+ADM_vidAnimated.h  ADM_vidFlipV.h  \
+ADM_vidAnimated_param.h   \
 ADM_vidAsharp.cpp   ADM_vidStabilize.cpp \
 ADM_vidFont.cpp ADM_vidStabilize.h \
 ADM_vidBlend.cpp ADM_vidFont.h ADM_vidSwapFields.cpp \
@@ -162,6 +159,6 @@
 INCLUDES = $(all_includes) -I../ADM_libraries -I../ADM_libraries/ADM_utilities -I../ADM_libraries/ADM_lavutil \
 			 $(FREETYPE_CFLAGS) $(ALTIVEC_SWITCH) -I../ADM_userInterfaces/ADM_commonUI -I../ADM_inputs
 noinst_HEADERS = ADM_vidlavdeint.h ADM_mpdetc.h ADM_vidKernelDeint.h \
-					ADM_vidForcedPP.h ADM_vidSoften.h ADM_cache.h ADM_vidDecTel_param.h ADM_vidDecDec_param.h \
+					ADM_vidForcedPP.h  ADM_cache.h ADM_vidDecTel_param.h ADM_vidDecDec_param.h \
 					ADM_vidMSmooth_param.h ADM_vidEqualizer.h ADM_vobsubinfo.h ADM_vidVobSub.h \
 		ADM_lavpp_deintparam.h ADM_vidEq2.h ADM_vidASS.h

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidFade.cpp (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFade.cpp)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFade.cpp	2006-10-31 15:59:58 UTC (rev 2489)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidFade.cpp	2007-01-10 19:52:36 UTC (rev 2699)
@@ -0,0 +1,293 @@
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "config.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <math.h>
+#include <ADM_assert.h>
+
+#include "config.h"
+#include "fourcc.h"
+#include "avio.hxx"
+#include "avi_vars.h"
+
+#include "ADM_toolkit/toolkit.hxx"
+#include "ADM_editor/ADM_edit.hxx"
+#include "ADM_video/ADM_genvideo.hxx"
+#include"ADM_video/ADM_vidField.h"
+#include"ADM_video/ADM_cache.h"
+
+#include "ADM_osSupport/ADM_debugID.h"
+#define MODULE_NAME MODULE_FILTER
+#include "ADM_osSupport/ADM_debug.h"
+#include "ADM_filter/video_filters.h"
+#include "ADM_vidFade_param.h"
+
+#include "ADM_userInterfaces/ADM_commonUI/DIA_factory.h"
+
+class AVDM_Fade : public AVDMGenericVideoStream
+{
+  VideoCache      *vidCache;
+  VIDFADE_PARAM   *_param;
+  uint16_t         lookupLuma[256][256];
+  uint16_t         lookupChroma[256][256];
+  uint8_t         buildLut(void);
+  public:
+                                
+                    AVDM_Fade(AVDMGenericVideoStream *in,CONFcouple *couples);    
+                    ~AVDM_Fade(void);
+    uint8_t         getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
+                                          ADMImage *data,uint32_t *flags);
+        
+    char            *printConf( void );
+    uint8_t         configure(AVDMGenericVideoStream *in);
+    uint8_t         getCoupledConf( CONFcouple **couples);
+};
+
+static FILTER_PARAM fadeParam={4,{"startFade","endFade","inOut","toBlack"}};
+
+BUILD_CREATE(fade_create,AVDM_Fade);
+SCRIPT_CREATE(fade_script,AVDM_Fade,fadeParam);
+
+/*************************************/
+uint8_t AVDM_Fade::configure(AVDMGenericVideoStream *in)
+{
+  uint32_t mx=_info.nb_frames;
+  _in=in;
+  
+  diaMenuEntry menuE[2]={{0,_("Out"),_("Fade out")},{1,_("In"),_("Fade in")}};
+  uint32_t start,end;
+  VIDFADE_PARAM param=*_param;
+  
+while(1)
+{
+    diaElemMenu     menu(&(param.inOut),_("Fade Type"), 2,menuE);
+    diaElemUInteger start(&(param.startFade),_("Start frame"),0,mx);
+    diaElemUInteger end(&(param.endFade),_("End frame"),0,mx);
+    diaElemToggle   black(&(param.toBlack),_("Fade to black"));
+    
+    diaElem *elems[4]={&menu,&start,&end,&black};
+  
+    if( diaFactoryRun("Fade",4,elems))
+    {
+      // Check it is consistent
+      if(param.startFade>=param.endFade || (param.startFade>=mx) || (param.endFade>=mx))
+      {
+        GUI_Error_HIG(_("Parameter Error"),_("Start must be before end, and both within video # of frames."));
+        continue; 
+      }
+      //
+      *_param=param;
+      return 1;
+    }else
+        return 0;
+} 
+  return 1;
+}
+
+char *AVDM_Fade::printConf( void )
+{
+  static char buf[50];
+
+        //ADM_assert(_param);
+  sprintf((char *)buf," Fade : Start %u End %u",_param->startFade,_param->endFade);
+  if(_param->inOut) strcat(buf," In"); else strcat(buf," Out");
+  return buf;
+}
+
+
+AVDM_Fade::AVDM_Fade(AVDMGenericVideoStream *in,CONFcouple *couples)
+
+{
+                
+  int count = 0;
+  char buf[80];
+  unsigned int *p;
+
+  _in=in;         
+  memcpy(&_info,_in->getInfo(),sizeof(_info));    
+  _info.encoding=1;
+  vidCache=new VideoCache(3,in);
+  
+  _param=new VIDFADE_PARAM;
+  if(couples)
+  {
+    GET(startFade);
+    GET(endFade);
+    GET(inOut);
+    GET(toBlack);
+    
+  }else
+  {
+    _param->startFade=0; 
+    _param->endFade=_info.nb_frames-1;
+    _param->inOut=0;
+    _param->toBlack=0;
+  }
+  buildLut();
+}
+//________________________________________________________
+uint8_t AVDM_Fade::getCoupledConf( CONFcouple **couples)
+{
+  *couples=new CONFcouple(4);
+  CSET(startFade);
+  CSET(endFade);
+  CSET(inOut);
+  CSET(toBlack);
+  return 1;
+}
+//________________________________________________________
+AVDM_Fade::~AVDM_Fade(void)
+{
+                
+  if(vidCache) delete vidCache;                
+  vidCache=NULL;   
+  if(_param) delete _param;
+  _param=NULL;
+}
+uint8_t AVDM_Fade::getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
+                                            ADMImage *data,uint32_t *flags)
+{
+
+  uint32_t num_frames,tgt;
+  
+  ADMImage *src;
+
+  num_frames=_info.nb_frames;   // ??
+
+  tgt=frame+_info.orgFrame;
+  if(frame>=num_frames)
+  {
+    printf("[Fade] out of bound\n");
+    return 0;
+  }
+
+  src=vidCache->getImage(frame);
+  if(!src) return 0;
+  if(tgt>_param->endFade || tgt <_param->startFade ||_param->endFade==_param->startFade )
+  {
+    //printf("Cur %u start %u end %u\n",tgt,_param->startFade,_param->endFade);
+    data->duplicate(src);
+    vidCache->unlockAll();
+    return 1;
+  }
+  uint8_t *s,*d,*s2;
+  uint16_t *index,*invertedIndex;
+  uint32_t count=_info.width*_info.height,w;
+  float num,den;
+  
+  den=_param->endFade-_param->startFade;
+  
+  num=tgt-_param->startFade;
+  
+  num=num/den;
+  num*=255.;
+  w=(uint32_t)floor(num+0.4);
+  
+//printf("w :%u\n",w);
+
+  s=src->data;
+  d=data->data;
+  if(_param->toBlack)
+  {
+        index=lookupLuma[w];
+        for(int i=0;i<count;i++)
+        {
+          *d++=(index[*s++]>>8);
+        }
+        // Now do chroma
+        count>>=2;
+        s=UPLANE(src);
+        d=UPLANE(data);
+        index=lookupChroma[w];
+        for(int i=0;i<count;i++)
+        {
+          *d++=(index[*s++]>>8);
+        }
+        s=VPLANE(src);
+        d=VPLANE(data);
+        for(int i=0;i<count;i++)
+        {
+          *d++=(index[*s++]>>8);
+        }
+  }
+  else
+  {
+        uint32_t x,alpha;
+        ADMImage *final;
+
+        final=vidCache->getImage(_param->endFade-_info.orgFrame);
+        if(!final)
+        {
+              data->duplicate(src);
+              vidCache->unlockAll();
+              return 1;
+        }
+
+        s2=final->data;
+
+        index=lookupLuma[w];
+        
+        invertedIndex=lookupLuma[255-w];
+        for(int i=0;i<count;i++)
+        {
+          *d++=(index[*s++]+invertedIndex[*s2++])>>8;
+        }
+        // Now do chroma
+        count>>=2;
+        s=UPLANE(src);
+        d=UPLANE(data);
+        s2=UPLANE(final);
+        index=lookupChroma[w];
+        invertedIndex=lookupChroma[255-w];
+        for(int i=0;i<count;i++)
+        {
+            *d++=(index[*s++]+invertedIndex[*s2++]-(128<<8))>>8;
+        }
+        s=VPLANE(src);
+        d=VPLANE(data);
+        s2=VPLANE(final);
+        for(int i=0;i<count;i++)
+        {
+            *d++=(index[*s++]+invertedIndex[*s2++]-(128<<8))>>8;
+            
+        }
+  }
+  vidCache->unlockAll();
+  return 1;
+}
+
+uint8_t AVDM_Fade::buildLut(void)
+{
+  float f,ration;
+  for(int i=0;i<256;i++)
+  {
+    if(!_param->inOut) ration=255-i;
+    else ration=i;
+    for(int r=0;r<256;r++)
+    {
+      f=r;
+      f=f*ration;
+      lookupLuma[i][r]=(uint16_t)(f+0.4);
+
+      f=r-128;
+      f=f*ration;
+      lookupChroma[i][r]=(128<<8)+(uint16_t)(f+0.4);
+
+    }
+    
+  }
+  return 1;
+}
+//EOF
+
+
+

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidFade_param.h (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFade_param.h)

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidResampleFPS.cpp (from rev 2530, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidResampleFPS.cpp)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidResampleFPS.cpp	2006-11-01 11:17:21 UTC (rev 2530)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidResampleFPS.cpp	2007-01-10 19:52:36 UTC (rev 2699)
@@ -0,0 +1,360 @@
+/***************************************************************************
+                          Resample fps
+                             -------------------
+    begin                : Wed Nov 6 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include <stdio.h>
+#include <math.h>
+
+#include <stdlib.h>
+#include <string.h>
+#include <ADM_assert.h>
+
+#include "config.h"
+#include "fourcc.h"
+#include "avio.hxx"
+#include "config.h"
+#include "avi_vars.h"
+#ifdef HAVE_ENCODER
+
+
+#include "ADM_toolkit/toolkit.hxx"
+#include "ADM_editor/ADM_edit.hxx"
+#include "ADM_video/ADM_genvideo.hxx"
+#include "ADM_video/ADM_vidFlipV.h"
+#include "ADM_filter/video_filters.h"
+#include "DIA_enter.h"
+#include "ADM_video/ADM_cache.h"
+#include "ADM_osSupport/ADM_cpuCap.h"
+#include "admmangle.h"
+
+#include "ADM_userInterfaces/ADM_commonUI/DIA_factory.h"
+
+static FILTER_PARAM ResampParam={2,{"newfps","use_linear"}};
+typedef struct FPS_Param
+{
+  uint32_t  newfps; 
+  uint32_t  use_linear;
+}FPS_Param;
+class  ADMVideoResampleFPS:public AVDMGenericVideoStream
+{
+
+  protected:
+    AVDMGenericVideoStream  *_in;           
+    virtual char            *printConf(void);
+            FPS_Param       *_param;    
+            VideoCache      *vidCache; 
+  public:
+                
+                        ADMVideoResampleFPS(  AVDMGenericVideoStream *in,CONFcouple *setup);
+                        ADMVideoResampleFPS(  AVDMGenericVideoStream *in,uint32_t target1000);
+    virtual             ~ADMVideoResampleFPS();
+    virtual uint8_t     configure(AVDMGenericVideoStream *in);
+    virtual uint8_t     getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
+                                          ADMImage *data,uint32_t *flags);
+
+             uint8_t     getCoupledConf( CONFcouple **couples);
+}     ;
+
+SCRIPT_CREATE(resamplefps_script,ADMVideoResampleFPS,ResampParam);
+BUILD_CREATE(resamplefps_create,ADMVideoResampleFPS);
+
+AVDMGenericVideoStream *createResampleFps(AVDMGenericVideoStream *in,uint32_t targetfps1000)
+{
+  return new ADMVideoResampleFPS(in,targetfps1000);
+}
+
+uint8_t ADMVideoResampleFPS::configure(AVDMGenericVideoStream *in)
+{
+  float f=_param->newfps; 
+  f/=1000;
+  
+  _in=in;
+  
+    diaElemFloat fps(&f,_("New FPS"),1,200.);
+    diaElemToggle blend(&(_param->use_linear),_("Blend"));
+    
+    diaElem *elems[2]={&fps,&blend};
+  
+    if( diaFactoryRun("Resample FPS",2,elems))
+    {
+        f*=1000;
+      _param->newfps=(uint32_t)floor(f+0.4); 
+      _info.fps1000=_param->newfps;
+      return 1;
+    }
+    return 0;
+}
+char *ADMVideoResampleFPS::printConf( void )
+{
+  static char buf[50];
+        
+  sprintf((char *)buf," Resample to %2.2f fps (blend:%d)",(double)_param->newfps/1000.,
+                _param->use_linear);
+  return buf;
+}
+
+ADMVideoResampleFPS::ADMVideoResampleFPS(  AVDMGenericVideoStream *in,uint32_t target)
+{
+
+  _in=in;         
+  memcpy(&_info,_in->getInfo(),sizeof(_info));    
+  _info.encoding=1; 
+  _param=new  FPS_Param;
+   
+    _param->newfps =target;                
+    _param->use_linear=1;
+ 
+  double newlength;
+  
+  newlength=_info.nb_frames;
+  newlength/=_info.fps1000;
+  newlength*=_param->newfps;
+  _info.nb_frames=(uint32_t)floor(newlength);
+  _info.fps1000=_param->newfps;
+  printf("[Resample FPS] %u -> %u\n",_in->getInfo()->nb_frames,_info.nb_frames);
+  vidCache=new VideoCache(3,_in);
+
+}
+
+ADMVideoResampleFPS::ADMVideoResampleFPS(  AVDMGenericVideoStream *in,CONFcouple *couples)
+{
+  
+  _in=in;         
+  memcpy(&_info,_in->getInfo(),sizeof(_info));    
+  _info.encoding=1; 
+  _param=new  FPS_Param;
+   
+  if(couples)
+  {                 
+    GET(newfps);    
+    GET(use_linear); 
+  }
+  else
+  {
+    _param->newfps =_info.fps1000;                
+    _param->use_linear=0;
+  }      
+ 
+  double newlength;
+  
+  newlength=_info.nb_frames;
+  newlength/=_info.fps1000;
+  newlength*=_param->newfps;
+  _info.nb_frames=(uint32_t)floor(newlength);
+  _info.fps1000=_param->newfps;
+  vidCache=new VideoCache(3,_in);
+  
+}
+ADMVideoResampleFPS::~ADMVideoResampleFPS()
+{
+  delete _param;
+  delete vidCache;
+  
+}
+uint8_t ADMVideoResampleFPS::getCoupledConf( CONFcouple **couples)
+{
+  ADM_assert(_param);
+  *couples=new CONFcouple(2);
+
+
+                CSET(newfps);
+                CSET(use_linear);
+                return 1;
+}
+#if (defined( ARCH_X86)  || defined(ARCH_X86_64))
+static uint64_t low,high;
+static void blendMMX(uint8_t *src, uint8_t *src2, uint8_t *dst, uint8_t alpha, uint8_t beta,uint32_t count)
+{
+uint32_t left=count&3;
+#define EXPAND(x) (x)+((x)<<16)+((x)<<32) +((x)<<48)
+        high=alpha;
+        low=beta;
+        high=EXPAND(high);
+        low=EXPAND(low);
+        count>>=2;
+#ifdef GCC_2_95_X
+         __asm__ __volatile__ (
+                                "movq "Mangle(high)", %mm0\n"
+                                "movq "Mangle(low)",  %mm1\n"                                
+                                "pxor %mm7        ,  %mm7\n"
+                                :: );
+#else
+         __asm__ __volatile__ (
+                                "movq "Mangle(high)", %%mm0\n"
+                                "movq "Mangle(low)",  %%mm1\n"                                
+                                "pxor %%mm7        ,  %%mm7\n"
+                                :: );
+#endif
+
+        while(count>0)
+        {
+                __asm__ __volatile__ (
+                               
+                                "movd      (%0),  %%mm2\n"
+                                "movd      (%1),  %%mm3\n"                               
+
+                                "punpcklbw %%mm7, %%mm2\n"
+                                "punpcklbw %%mm7, %%mm3\n"
+
+                                "pmullw   %%mm0, %%mm2\n"
+                                "pmullw   %%mm1, %%mm3\n"
+                
+                                "paddw    %%mm3, %%mm2\n"
+
+                                "psrlw    $8,    %%mm2 \n"
+
+                                "packuswb %%mm2,%%mm2\n"
+                                "movd     %%mm2, (%2)\n"
+
+                                :: "r" (src), "r" (src2), "r" (dst) );
+                                
+                src+=4;
+                src2+=4;
+                dst+=4;
+                count--;
+        }
+        __asm__ __volatile__ (
+                                "emms\n"
+                                :: );
+        for(uint32_t i=0;i<left;i++)
+        {
+                dst[i] = ((src[i]*alpha) + (src2[i]*beta))>>8;
+        }
+}
+
+#endif
+
+uint8_t ADMVideoResampleFPS::getFrameNumberNoAlloc(uint32_t frame,
+                                             uint32_t *len,
+                                             ADMImage *data,
+                                             uint32_t *flags)
+{
+  ADMImage *mysrc1=NULL;
+  ADMImage *mysrc2=NULL;
+
+  ADM_assert(frame<_info.nb_frames);
+  // read uncompressed frame
+  
+  // What frame are we seeking ?
+  double f;
+  uint32_t page=_info.width*_info.height;
+  
+  f=frame;
+  f*=_in->getInfo()->fps1000;
+  f/=_param->newfps;
+  
+  if(!_param->use_linear)
+  {
+      uint32_t nw;
+      
+      nw=(uint32_t)floor(f+0.4);
+      if(nw>_in->getInfo()->nb_frames-1)
+        nw=_in->getInfo()->nb_frames-1;
+    
+      mysrc1=vidCache->getImage(nw);
+      if(!mysrc1) return 0;
+      
+      memcpy(YPLANE(data),YPLANE(mysrc1),page);
+      memcpy(UPLANE(data),UPLANE(mysrc1),page>>2);
+      memcpy(VPLANE(data),VPLANE(mysrc1),page>>2);
+    
+      vidCache->unlockAll();
+      
+      return 1;
+  }
+  /* With linear blending */
+  uint32_t nw;
+  uint8_t lowweight;
+  uint8_t highweight;
+  
+  double diff;
+  
+  nw=(uint32_t)floor(f);
+  diff=f-floor(f);
+  highweight = (uint8_t)floor(diff*256);
+  lowweight = 256 - highweight;
+
+  if(nw>=_in->getInfo()->nb_frames-1)
+    {
+      printf("[ResampleFps] In %u Out %u\n",frame,nw);
+      nw=_in->getInfo()->nb_frames-1;
+      highweight=0;
+    }
+  //printf("New:%lu old:%lu\n",frame,nw);
+
+  if(highweight == 0)
+    {
+      mysrc1=vidCache->getImage(nw);  
+      if(!mysrc1) return 0;
+      
+      memcpy(YPLANE(data),YPLANE(mysrc1),page);
+      memcpy(UPLANE(data),UPLANE(mysrc1),page>>2);
+      memcpy(VPLANE(data),VPLANE(mysrc1),page>>2);
+      
+      vidCache->unlockAll();
+    }
+  else
+    {
+      mysrc1=vidCache->getImage(nw);
+      mysrc2=vidCache->getImage(nw+1);
+      if(!mysrc1 || !mysrc2) return 0;
+      
+      uint8_t *out, *in1, *in2;
+      uint32_t count;
+      uint32_t idx;
+      
+      out = YPLANE(data);
+      in1 = YPLANE(mysrc1);
+      in2 = YPLANE(mysrc2);
+        
+      count = page;
+
+#if (defined( ARCH_X86)  || defined(ARCH_X86_64))
+        if(CpuCaps::hasMMX())
+                blendMMX(in1,in2,out,lowweight,highweight,(count*3)>>1);
+        else
+#endif
+      {
+      for(idx = 0; idx < count; ++idx)
+	out[idx] = ((in1[idx]*lowweight) + (in2[idx]*highweight))>>8;
+
+      out = UPLANE(data);
+      in1 = UPLANE(mysrc1);
+      in2 = UPLANE(mysrc2);
+      count = page>>2;
+
+      for(idx = 0; idx < count; ++idx)
+        out[idx] = ((in1[idx]*lowweight) + (in2[idx]*highweight))>>8;      
+
+
+      out = VPLANE(data);
+      in1 = VPLANE(mysrc1);
+      in2 = VPLANE(mysrc2);
+      count = page>>2;
+
+      for(idx = 0; idx < count; ++idx)
+	out[idx] = ((in1[idx]*lowweight) + (in2[idx]*highweight))>>8;
+      }
+
+      vidCache->unlockAll();
+    }
+  return 1;
+ 
+}
+
+
+
+#endif

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidSoften.cpp (from rev 2530, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSoften.cpp)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSoften.cpp	2006-11-01 11:17:21 UTC (rev 2530)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidSoften.cpp	2007-01-10 19:52:36 UTC (rev 2699)
@@ -0,0 +1,331 @@
+//
+// C++ Implementation: Soften
+//
+// Description: 
+//
+// See .h file
+//
+// Author: mean <fixounet at free.fr>, (C) 2004
+//
+// Copyright: See COPYING file that comes with this distribution
+//
+//
+
+//
+//	This is the very unoptimized version
+//	could use some stuff and some mmx too
+//
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ADM_assert.h>
+#include <math.h>
+#include <math.h>
+#include <iconv.h>
+#include "config.h"
+
+
+#include "fourcc.h"
+#include "avio.hxx"
+
+#include "avi_vars.h"
+
+#include "ADM_toolkit/toolkit.hxx"
+#include "ADM_editor/ADM_edit.hxx"
+#include "ADM_video/ADM_genvideo.hxx"
+
+#include "ADM_osSupport/ADM_debugID.h"
+#define MODULE_NAME MODULE_FILTER
+#include "ADM_osSupport/ADM_debug.h"
+
+
+
+#include "ADM_vidSoften.h"
+#include "DIA_enter.h"
+#include "ADM_filter/video_filters.h"
+
+
+#include "ADM_userInterfaces/ADM_commonUI/DIA_factory.h"
+
+static FILTER_PARAM softParam={3,{"radius","luma","chroma"}};
+
+
+SCRIPT_CREATE(soften_script,ADMVideoMaskedSoften,softParam);
+BUILD_CREATE(soften_create,ADMVideoMaskedSoften);
+
+extern uint8_t distMatrix[256][256];
+extern uint32_t fixMul[16];
+
+
+uint8_t ADMVideoMaskedSoften::configure( AVDMGenericVideoStream *instream)
+{
+        _in=instream;
+        /*uint32_t luma,chroma;
+	uint32_t radius;
+	*/
+        
+        diaElemUInteger luma(&(_param->luma),_("Luma Treshold"),0,255);
+        diaElemUInteger chroma(&(_param->chroma),_("Chroma Treshold"),0,255);
+        diaElemUInteger radius(&(_param->radius),_("Radius"),1,60);
+	  
+    diaElem *elems[3]={&luma,&chroma,&radius};
+  
+    return diaFactoryRun("Soften",3,elems);
+}
+uint8_t	ADMVideoMaskedSoften::getCoupledConf( CONFcouple **couples)
+{
+
+			*couples=new CONFcouple(3);
+
+			CSET(radius);
+			CSET(luma);
+			CSET(chroma);
+
+		return 1;	
+}
+char *ADMVideoMaskedSoften::printConf( void )
+{
+ 	static char buf[50];
+ 	
+ 	sprintf((char *)buf," Soften : radius: %lu l:%lu c:%lu", 
+		_param->radius,_param->luma, _param->chroma);
+        return buf;
+}
+
+ADMVideoMaskedSoften::~ADMVideoMaskedSoften()
+{
+	if(_uncompressed)
+ 		delete _uncompressed;	
+ 	_uncompressed=NULL;
+}
+
+
+ ADMVideoMaskedSoften::ADMVideoMaskedSoften( AVDMGenericVideoStream *in,CONFcouple *couples)
+{
+		
+		_uncompressed=NULL;
+		_in=in;
+		ADM_assert(in);
+		if(!couples)
+		{
+			
+			_param=NEW(MaskedSoften_CONF);
+	    		_param->radius=2; 
+	    		_param->luma=5;
+			_param->chroma=5;
+			
+	    	}
+		else
+		{
+			_param=NEW(MaskedSoften_CONF);
+			GET(radius);
+			GET(luma);
+			GET(chroma);
+			
+						
+		}
+		ADM_assert(in);
+		
+		memcpy(&_info,_in->getInfo(),sizeof(_info));	
+			    	
+	    	//_uncompressed=new uint8_t[3*_info.width*_info.height];	
+		_uncompressed=new ADMImage(_info.width,_info.height);	
+		
+
+}
+uint8_t ADMVideoMaskedSoften::getFrameNumberNoAlloc(uint32_t frame,
+				uint32_t *len,
+   				ADMImage *data,
+				uint32_t *flags)
+{
+		uint32_t page=_info.width*_info.height;
+		int32_t radius=_param->radius;
+		uint32_t offset;
+		
+		int blockx,blocky;
+		
+		*len=(page*3)>>1;
+		if(frame>=_info.nb_frames) return 0;		
+		
+				
+		if(!_in->getFrameNumberNoAlloc(frame, len,_uncompressed,flags))
+				 		return 0;
+
+		// do luma only ATM
+		// copy chroma
+		memcpy(UPLANE(data),UPLANE(_uncompressed),page>>2);
+		memcpy(VPLANE(data),VPLANE(_uncompressed),page>>2);
+		
+		// for luma, the radius first lines /last lines are unchanged
+		memcpy(YPLANE(data),YPLANE(_uncompressed),radius*_info.width);
+		
+		offset=page-_info.width*radius-1;
+		
+		memcpy(YPLANE(data)+offset,
+			YPLANE(_uncompressed)+offset,
+			radius*_info.width);
+
+		uint8_t *src,*dst;
+		uint32_t val,cur,coef;
+		//
+		data->copyInfo(_uncompressed);
+		// optimized one
+		if(radius==2) return radius5(YPLANE(_uncompressed),YPLANE(data));
+		if(radius==1) return radius3(YPLANE(_uncompressed),YPLANE(data));
+		
+		for(uint32_t y=radius;y<_info.height-radius;y++)
+		{
+			src=YPLANE(_uncompressed)+y*_info.width;
+			dst=YPLANE(data)+y*_info.width;
+			
+			memcpy(dst,src,radius);
+			src+=radius;
+			dst+=radius;
+			
+			for(uint32_t x=radius;x<_info.width-radius;x++)
+			{
+				coef=0;
+				val=0;
+			
+				for( blocky=-radius;blocky<=radius;blocky++)
+				{
+					for( blockx=-radius;blockx<=radius;blockx++)
+					{
+						cur=*(src+blockx+blocky*_info.width);
+						
+						if( distMatrix[cur][*src]<=_param->luma)
+						{
+							coef++;
+							val+=cur;
+						}
+					
+					
+					}
+				}
+				ADM_assert(coef);
+				if(coef!=1)
+					val=(val+(coef>>1)-1)/coef;
+				*dst++=val;
+				src++;
+				
+				//*dst++=*src++;
+			}
+			memcpy(dst,src,radius);
+		
+		}	
+	return 1;
+}
+uint8_t ADMVideoMaskedSoften::radius5(uint8_t *_uncompressed, uint8_t *data) 
+{
+int blockx,blocky;
+uint32_t val,coef;
+
+uint8_t *src,*dst;
+uint8_t cur;
+
+uint8_t *c0,*c1,*c2,*c3,*c4,ref;
+
+
+
+	for(uint32_t y=2;y<_info.height-2;y++)
+		{
+			src=_uncompressed+y*_info.width;
+			dst=data+y*_info.width;
+			
+			*dst++=*src++;
+			*dst++=*src++;
+			
+			for(uint32_t x=2;x<_info.width-2;x++)
+			{
+				coef=0;
+				val=0;
+				c0=src-2-2*_info.width;
+				c1=c0+_info.width;
+				c2=c1+_info.width;
+				c3=c2+_info.width;
+				c4=c3+_info.width;
+				
+				ref=*src;
+					
+#define CHECK(x) cur=*x;if(distMatrix[cur][ref]<=_param->luma) {coef++;val+=cur;}x++;					
+				for( blockx=5;blockx>0;blockx--)
+				{
+					CHECK(c0);
+					CHECK(c1);
+					CHECK(c2);
+					CHECK(c3);
+					CHECK(c4);
+				}
+				ADM_assert(coef);
+				if(coef!=1)
+					val=(val+(coef>>1)-1)/coef;
+
+				*dst++=val;
+				src++;
+			}
+			*dst++=*src++;
+			*dst++=*src++;		
+		}	
+}
+uint8_t ADMVideoMaskedSoften::radius3(uint8_t *_uncompressed, uint8_t *data) 
+{
+int blockx,blocky;
+uint32_t val,coef;
+
+uint8_t *src,*dst;
+uint8_t cur;
+
+uint8_t *c0,*c1,*c2,ref;
+
+uint8_t *dist;
+
+	for(uint32_t y=1;y<_info.height-1;y++)
+		{
+			src=_uncompressed+y*_info.width;
+			dst=data+y*_info.width;
+			
+			*dst++=*src++;
+			
+			
+			for(uint32_t x=1;x<_info.width-1;x++)
+			{
+				coef=0;
+				val=0;
+				c0=src-1-_info.width;
+				c1=c0+_info.width;
+				c2=c1+_info.width;
+				
+				ref=*src;
+				dist=distMatrix[ref];
+#undef CHECK				
+#define CHECK(x) cur=*x;if(dist[cur]<=_param->luma) {coef++;val+=cur;}x++;					
+					CHECK(c0);
+					CHECK(c0);
+					CHECK(c0);
+					
+					CHECK(c1);
+					CHECK(c1);					
+					CHECK(c1);
+					
+					CHECK(c2);
+					CHECK(c2);					
+					CHECK(c2);
+				
+					
+				ADM_assert(coef);
+				if(coef!=1)
+					val=(val+(coef>>1)-1)/coef;
+				*dst++=val;
+				src++;
+			}
+			*dst++=*src++;
+			
+		}	
+}
+
+
+
+
+
+

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidSoften.h (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSoften.h)

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am	2007-01-09 19:59:26 UTC (rev 2698)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am	2007-01-10 19:52:36 UTC (rev 2699)
@@ -7,6 +7,9 @@
 #INCLUDES = $(all_includes) 
 
 libADM_videoFilter_a_SOURCES =  \
+ ADM_vidFade.cpp \
+ ADM_vidResampleFPS.cpp \
+ ADM_vidSoften.cpp \
  ADM_vidBSmear.cpp \
  ADM_vidAddBorder.cpp \
  ADM_vidFlux.cpp \



From mean at mail.berlios.de  Thu Jan 11 09:00:20 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 11 Jan 2007 09:00:20 +0100
Subject: [Avidemux-svn-commit] r2700 -
	branches/avidemux_2.4_branch/avidemux/ADM_video
Message-ID: <200701110800.l0B80KaT011084@sheep.berlios.de>

Author: mean
Date: 2007-01-11 09:00:20 +0100 (Thu, 11 Jan 2007)
New Revision: 2700

Removed:
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMcDeint.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMcDeint_param.h
Log:
moved to dialogFactory

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMcDeint.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMcDeint.cpp	2007-01-10 19:52:36 UTC (rev 2699)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMcDeint.cpp	2007-01-11 08:00:20 UTC (rev 2700)
@@ -1,500 +0,0 @@
-//
-//
-// Port to avidemux2 by mean
-// Original filter by M Niedermayer
-// See below
-/*
-    Copyright (C) 2006 Michael Niedermayer <michaelni at gmx.at>
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
-*/
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <ADM_assert.h>
-#include "ADM_lavcodec.h"
-
-#include "config.h"
-#include "fourcc.h"
-#include "avio.hxx"
-#include "config.h"
-#include "avi_vars.h"
-
-
-
-#include "ADM_toolkit/toolkit.hxx"
-#include "ADM_editor/ADM_edit.hxx"
-#include "ADM_video/ADM_genvideo.hxx"
-
-#include "ADM_filter/video_filters.h"
-#include "ADM_video/ADM_cache.h"
-
-#include "ADM_video/ADM_vidMcDeint_param.h"
-
-static FILTER_PARAM mcDeintParam={3,{"mode","qp","initial_parity"}};
-
-struct vf_priv_s {
-    int mode;
-    int qp;
-    int parity;
-#if 0
-    int temp_stride[3];
-    uint8_t *src[3];
-    int16_t *temp[3];
-#endif
-    int outbuf_size;
-    uint8_t *outbuf;
-    AVCodecContext *avctx_enc;
-    AVFrame *frame;
-    AVFrame *frame_dec;
-};
-
-
-class  AVDMVideoMCDeint:public AVDMGenericVideoStream
- {
-
- protected:
-                MCDEINT_PARAM *_param;
-                VideoCache      *vidCache;
-                uint8_t         init();
-                uint8_t         cleanup();
-                vf_priv_s       priv;
- public:
-    virtual char          *printConf(void) ;
-                  AVDMVideoMCDeint(  AVDMGenericVideoStream *in,CONFcouple *setup);
-                 ~AVDMVideoMCDeint();
- virtual uint8_t getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-                            ADMImage *data,uint32_t *flags);
-
-  virtual uint8_t configure( AVDMGenericVideoStream *instream);
-  virtual uint8_t getCoupledConf( CONFcouple **couples);
- }     ;
-
-SCRIPT_CREATE(mcdeint_script,AVDMVideoMCDeint,mcDeintParam);
-BUILD_CREATE(mcdeint_create,AVDMVideoMCDeint);
-
-static void filter(struct vf_priv_s *p, uint8_t *dst[3], uint8_t *src[3], int dst_stride[3], int src_stride[3], int width, int height);
-uint8_t DIA_mcDeint(MCDEINT_PARAM *param);
-
-
-char *AVDMVideoMCDeint::printConf( void )
-{
-static char buf[50];
-
-        sprintf((char *)buf," MC deinterlacer : Mode %d, qp %d, parity %d ",_param->mode,_param->qp,_param->initial_parity);
-        return buf;
-}
-uint8_t AVDMVideoMCDeint::configure(AVDMGenericVideoStream * instream)
-{
-    if( DIA_mcDeint(_param))
-    {
-      cleanup();
-      init();
-      return 1;
-    }
-    return 0;
-}
-uint8_t AVDMVideoMCDeint::getCoupledConf( CONFcouple **couples)
-{
-
-                        ADM_assert(_param);
-                        *couples=new CONFcouple(3);
-
-#define CSET(x)  (*couples)->setCouple((char *)#x,(_param->x))
-                CSET(mode);
-                CSET(qp);
-                CSET(initial_parity);
-                return 1;
-
-}
-
-//_______________________________________________________________
-AVDMVideoMCDeint::AVDMVideoMCDeint(AVDMGenericVideoStream *in,CONFcouple *couples)
-{
-
-        _in=in;
-        memcpy(&_info,_in->getInfo(),sizeof(_info));
-        _param=NEW(MCDEINT_PARAM);
-        vidCache=new VideoCache(4,_in);
-        if(couples)
-        {
-                GET(mode);
-                GET(qp);
-                GET(initial_parity);
-        }
-        else
-        {
-                _param->mode=0;
-                _param->qp=1;
-                _param->initial_parity=0;
-                
-        }
-        _info.encoding=1;
-        init();
-}
-
-
-
-// ___ destructor_____________
-AVDMVideoMCDeint::~AVDMVideoMCDeint()
-{
-      cleanup();
-      delete  vidCache;
-      delete _param;
-      _param=NULL;
-      vidCache=NULL;
-}
-uint8_t AVDMVideoMCDeint::getFrameNumberNoAlloc(uint32_t frame,
-                                uint32_t *len,
-                                ADMImage *data,
-                                uint32_t *flags)
-{
-                        if(frame>=_info.nb_frames) 
-                        {
-                                printf("MPdelogo : Filter : out of bound!\n");
-                                return 0;
-                        }
-        
-                        ADM_assert(_param);
-
-ADMImage *curImage;
-char txt[256];
-                        curImage=vidCache->getImage(frame);
-                        if(!curImage)
-                        {
-                                printf("MCDeint : error getting frame\n");
-                                return 0;
-                        }
-              
-                      // Prepare to call filter...
-                  uint8_t *dplanes[3],*splanes[3];
-                  int dstride[3],sstride[3];
-
-                  dstride[0]=sstride[0]=_info.width;
-                  dstride[2]=sstride[2]=dstride[1]=sstride[1]=_info.width>>1;
-
-                  splanes[0]=YPLANE(curImage);
-                  splanes[1]=UPLANE(curImage);
-                  splanes[2]=VPLANE(curImage);
-
-                  dplanes[0]=YPLANE(data);
-                  dplanes[1]=UPLANE(data);
-                  dplanes[2]=VPLANE(data);
-
-
-                  filter(&priv, dplanes, splanes, dstride, sstride, _info.width, _info.height);
-                  vidCache->unlockAll();
-        return 1;
-}
-uint8_t AVDMVideoMCDeint::init( void )
-{
-  memset(&priv,0,sizeof(priv));
-  int i;
-  
-  AVCodec *enc= avcodec_find_encoder(CODEC_ID_SNOW);
-  ADM_assert(enc);
-
-        for(i=0; i<3; i++)
-        {
-            AVCodecContext *avctx_enc;
-            avctx_enc=     priv.avctx_enc= avcodec_alloc_context();
-            avctx_enc->width = _info.width;
-            avctx_enc->height = _info.height;
-            avctx_enc->time_base= (AVRational){1,25};  // meaningless
-            avctx_enc->gop_size = 300;
-            avctx_enc->max_b_frames= 0;
-            avctx_enc->pix_fmt = PIX_FMT_YUV420P;
-            avctx_enc->flags = CODEC_FLAG_QSCALE | CODEC_FLAG_LOW_DELAY;
-            avctx_enc->strict_std_compliance = FF_COMPLIANCE_EXPERIMENTAL;
-            avctx_enc->global_quality= 1;
-            avctx_enc->flags2= CODEC_FLAG2_MEMC_ONLY;
-            avctx_enc->me_cmp=
-            avctx_enc->me_sub_cmp= FF_CMP_SAD; //SSE;
-            avctx_enc->mb_cmp= FF_CMP_SSE;
-
-            switch(_param->mode)
-            {
-            case 3:
-                avctx_enc->refs= 3;
-            case 2:
-                avctx_enc->me_method= ME_ITER;
-            case 1:
-                avctx_enc->flags |= CODEC_FLAG_4MV;
-                avctx_enc->dia_size=2;
-//                avctx_enc->mb_decision = MB_DECISSION_RD;
-            case 0:
-                avctx_enc->flags |= CODEC_FLAG_QPEL;
-            }
-
-            avcodec_open(avctx_enc, enc);
-
-        }
-        priv.frame= avcodec_alloc_frame();
-
-        priv.outbuf_size= _info.width*_info.height*10;
-        priv.outbuf= (uint8_t *)ADM_alloc(priv.outbuf_size);
-        priv.parity=_param->initial_parity;
-  return 1;
-}
-uint8_t AVDMVideoMCDeint::cleanup( void )
-{
-  //
-   avcodec_close(priv.avctx_enc);
-   av_free(priv.avctx_enc);
-   ADM_dezalloc(priv.outbuf);
-   memset(&priv,0,sizeof(priv));
-  return 1;
-}
-
-
-/*
-Known Issues:
-* The motion estimation is somewhat at the mercy of the input, if the input
-  frames are created purely based on spatial interpolation then for example
-  a thin black line or another random and not interpolateable pattern
-  will cause problems
-  Note: completly ignoring the "unavailable" lines during motion estimation 
-  didnt look any better, so the most obvious solution would be to improve
-  tfields or penalize problematic motion vectors ...
-
-* If non iterative ME is used then snow currently ignores the OBMC window
-  and as a result sometimes creates artifacts
-
-* only past frames are used, we should ideally use future frames too, something
-  like filtering the whole movie in forward and then backward direction seems 
-  like a interresting idea but the current filter framework is FAR from
-  supporting such things
-
-* combining the motion compensated image with the input image also isnt
-  as trivial as it seems, simple blindly taking even lines from one and
-  odd ones from the other doesnt work at all as ME/MC sometimes simple
-  has nothing in the previous frames which matches the current, the current
-  algo has been found by trial and error and almost certainly can be
-  improved ...
-*/
-
-
-
-#define MIN(a,b) ((a) > (b) ? (b) : (a))
-#define MAX(a,b) ((a) < (b) ? (b) : (a))
-#define ABS(a) ((a) > 0 ? (a) : (-(a)))
-
-//===========================================================================//
-
-
-static void filter(struct vf_priv_s *p, uint8_t *dst[3], uint8_t *src[3], int dst_stride[3], int src_stride[3], int width, int height){
-    int x, y, i;
-    int out_size;
-
-    for(i=0; i<3; i++){
-        p->frame->data[i]= src[i];
-        p->frame->linesize[i]= src_stride[i];
-    }
-
-    p->avctx_enc->me_cmp=
-    p->avctx_enc->me_sub_cmp= FF_CMP_SAD /*| (p->parity ? FF_CMP_ODD : FF_CMP_EVEN)*/;
-    p->frame->quality= p->qp*FF_QP2LAMBDA;
-    out_size = avcodec_encode_video(p->avctx_enc, p->outbuf, p->outbuf_size, p->frame);
-    p->frame_dec = p->avctx_enc->coded_frame;
-
-    for(i=0; i<3; i++){
-        int is_chroma= !!i;
-        int w= width >>is_chroma;
-        int h= height>>is_chroma;
-        int fils= p->frame_dec->linesize[i];
-        int srcs= src_stride[i];
-
-        for(y=0; y<h; y++){
-            if((y ^ p->parity) & 1){
-                for(x=0; x<w; x++){
-                    if((x-2)+(y-1)*w>=0 && (x+2)+(y+1)*w<w*h){ //FIXME either alloc larger images or optimize this
-                        uint8_t *filp= &p->frame_dec->data[i][x + y*fils];
-                        uint8_t *srcp= &src[i][x + y*srcs];
-                        int diff0= filp[-fils] - srcp[-srcs];
-                        int diff1= filp[+fils] - srcp[+srcs];
-                        int spatial_score= ABS(srcp[-srcs-1] - srcp[+srcs-1])
-                                          +ABS(srcp[-srcs  ] - srcp[+srcs  ])
-                                          +ABS(srcp[-srcs+1] - srcp[+srcs+1]) - 1;
-                        int temp= filp[0];
-
-#define CHECK(j)\
-    {   int score= ABS(srcp[-srcs-1+j] - srcp[+srcs-1-j])\
-                 + ABS(srcp[-srcs  +j] - srcp[+srcs  -j])\
-                 + ABS(srcp[-srcs+1+j] - srcp[+srcs+1-j]);\
-        if(score < spatial_score){\
-            spatial_score= score;\
-            diff0= filp[-fils+j] - srcp[-srcs+j];\
-            diff1= filp[+fils-j] - srcp[+srcs-j];
-
-                        CHECK(-1) CHECK(-2) }} }}
-                        CHECK( 1) CHECK( 2) }} }}
-#if 0
-                        if((diff0 ^ diff1) > 0){
-                            int mindiff= ABS(diff0) > ABS(diff1) ? diff1 : diff0;
-                            temp-= mindiff;
-                        }
-#elif 1
-                        if(diff0 + diff1 > 0)
-                            temp-= (diff0 + diff1 - ABS( ABS(diff0) - ABS(diff1) )/2)/2;
-                        else
-                            temp-= (diff0 + diff1 + ABS( ABS(diff0) - ABS(diff1) )/2)/2;
-#else
-                        temp-= (diff0 + diff1)/2;
-#endif
-#if 1
-                        filp[0]=
-                        dst[i][x + y*dst_stride[i]]= temp > 255U ? ~(temp>>31) : temp;
-#else
-                        dst[i][x + y*dst_stride[i]]= filp[0];
-                        filp[0]= temp > 255U ? ~(temp>>31) : temp;
-#endif
-                    }else
-                        dst[i][x + y*dst_stride[i]]= p->frame_dec->data[i][x + y*fils];
-                }
-            }
-        }
-        for(y=0; y<h; y++){
-            if(!((y ^ p->parity) & 1)){
-                for(x=0; x<w; x++){
-#if 1
-                    p->frame_dec->data[i][x + y*fils]=
-                    dst[i][x + y*dst_stride[i]]= src[i][x + y*srcs];
-#else
-                    dst[i][x + y*dst_stride[i]]= p->frame_dec->data[i][x + y*fils];
-                    p->frame_dec->data[i][x + y*fils]= src[i][x + y*srcs];
-#endif
-                }
-            }
-        }
-    }
-    p->parity ^= 1;
-
-}
-#ifdef titititititi_II
-static int config(struct vf_instance_s* vf,
-        int width, int height, int d_width, int d_height,
-	unsigned int flags, unsigned int outfmt){
-        int i;
-        AVCodec *enc= avcodec_find_encoder(CODEC_ID_SNOW);
-
-        for(i=0; i<3; i++){
-            AVCodecContext *avctx_enc;
-#if 0
-            int is_chroma= !!i;
-            int w= ((width  + 31) & (~31))>>is_chroma;
-            int h= ((height + 31) & (~31))>>is_chroma;
-
-            vf->priv->temp_stride[i]= w;
-            vf->priv->temp[i]= malloc(vf->priv->temp_stride[i]*h*sizeof(int16_t));
-            vf->priv->src [i]= malloc(vf->priv->temp_stride[i]*h*sizeof(uint8_t));
-#endif
-            avctx_enc=
-            vf->priv->avctx_enc= avcodec_alloc_context();
-            avctx_enc->width = width;
-            avctx_enc->height = height;
-            avctx_enc->time_base= (AVRational){1,25};  // meaningless
-            avctx_enc->gop_size = 300;
-            avctx_enc->max_b_frames= 0;
-            avctx_enc->pix_fmt = PIX_FMT_YUV420P;
-            avctx_enc->flags = CODEC_FLAG_QSCALE | CODEC_FLAG_LOW_DELAY;
-            avctx_enc->strict_std_compliance = FF_COMPLIANCE_EXPERIMENTAL;
-            avctx_enc->global_quality= 1;
-            avctx_enc->flags2= CODEC_FLAG2_MEMC_ONLY;
-            avctx_enc->me_cmp=
-            avctx_enc->me_sub_cmp= FF_CMP_SAD; //SSE;
-            avctx_enc->mb_cmp= FF_CMP_SSE;
-
-            switch(vf->priv->mode){
-            case 3:
-                avctx_enc->refs= 3;
-            case 2:
-                avctx_enc->me_method= ME_ITER;
-            case 1:
-                avctx_enc->flags |= CODEC_FLAG_4MV;
-                avctx_enc->dia_size=2;
-//                avctx_enc->mb_decision = MB_DECISSION_RD;
-            case 0:
-                avctx_enc->flags |= CODEC_FLAG_QPEL;
-            }
-
-            avcodec_open(avctx_enc, enc);
-
-        }
-        vf->priv->frame= avcodec_alloc_frame();
-
-        vf->priv->outbuf_size= width*height*10;
-        vf->priv->outbuf= malloc(vf->priv->outbuf_size);
-
-	return vf_next_config(vf,width,height,d_width,d_height,flags,outfmt);
-}
-
-static void get_image(struct vf_instance_s* vf, mp_image_t *mpi){
-    if(mpi->flags&MP_IMGFLAG_PRESERVE) return; // don't change
-return; //caused problems, dunno why
-    // ok, we can do pp in-place (or pp disabled):
-    vf->dmpi=vf_get_image(vf->next,mpi->imgfmt,
-        mpi->type, mpi->flags | MP_IMGFLAG_READABLE, mpi->width, mpi->height);
-    mpi->planes[0]=vf->dmpi->planes[0];
-    mpi->stride[0]=vf->dmpi->stride[0];
-    mpi->width=vf->dmpi->width;
-    if(mpi->flags&MP_IMGFLAG_PLANAR){
-        mpi->planes[1]=vf->dmpi->planes[1];
-        mpi->planes[2]=vf->dmpi->planes[2];
-	mpi->stride[1]=vf->dmpi->stride[1];
-	mpi->stride[2]=vf->dmpi->stride[2];
-    }
-    mpi->flags|=MP_IMGFLAG_DIRECT;
-}
-
-static int put_image(struct vf_instance_s* vf, mp_image_t *mpi, double pts){
-    mp_image_t *dmpi;
-
-    if(!(mpi->flags&MP_IMGFLAG_DIRECT)){
-        // no DR, so get a new image! hope we'll get DR buffer:
-        dmpi=vf_get_image(vf->next,mpi->imgfmt,
-            MP_IMGTYPE_TEMP,
-            MP_IMGFLAG_ACCEPT_STRIDE|MP_IMGFLAG_PREFER_ALIGNED_STRIDE,
-            mpi->width,mpi->height);
-        vf_clone_mpi_attributes(dmpi, mpi);
-    }else{
-        dmpi=vf->dmpi;
-    }
-
-    filter(vf->priv, dmpi->planes, mpi->planes, dmpi->stride, mpi->stride, mpi->w, mpi->h);
-
-    return vf_next_put_image(vf,dmpi, pts);
-}
-
-static void uninit(struct vf_instance_s* vf){
-    if(!vf->priv) return;
-
-#if 0
-    for(i=0; i<3; i++){
-        if(vf->priv->temp[i]) free(vf->priv->temp[i]);
-        vf->priv->temp[i]= NULL;
-        if(vf->priv->src[i]) free(vf->priv->src[i]);
-        vf->priv->src[i]= NULL;
-    }
-#endif
-    av_freep(&vf->priv->avctx_enc);
-
-    free(vf->priv->outbuf);
-    free(vf->priv);
-    vf->priv=NULL;
-}
-
-#endif
-//EOF

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMcDeint_param.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMcDeint_param.h	2007-01-10 19:52:36 UTC (rev 2699)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMcDeint_param.h	2007-01-11 08:00:20 UTC (rev 2700)
@@ -1,15 +0,0 @@
-
-
-#ifndef MC_DEINT_PARAM_H
-#define MC_DEINT_PARAM_H
-
-typedef struct MCDEINT_PARAM
-{
-    int32_t mode;
-    int32_t initial_parity;
-    int32_t qp;
-
-}MCDEINT_PARAM;
-
-
-#endif



From mean at mail.berlios.de  Thu Jan 11 09:00:52 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 11 Jan 2007 09:00:52 +0100
Subject: [Avidemux-svn-commit] r2701 -
	branches/avidemux_2.4_branch/avidemux/ADM_videoFilter
Message-ID: <200701110800.l0B80qdm011168@sheep.berlios.de>

Author: mean
Date: 2007-01-11 09:00:52 +0100 (Thu, 11 Jan 2007)
New Revision: 2701

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMcDeint.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMcDeint_param.h
Log:
moved to dialogFactory

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMcDeint.cpp (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMcDeint.cpp)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMcDeint.cpp	2006-10-31 15:59:58 UTC (rev 2489)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMcDeint.cpp	2007-01-11 08:00:52 UTC (rev 2701)
@@ -0,0 +1,513 @@
+//
+//
+// Port to avidemux2 by mean
+// Original filter by M Niedermayer
+// See below
+/*
+    Copyright (C) 2006 Michael Niedermayer <michaelni at gmx.at>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ADM_assert.h>
+#include "ADM_lavcodec.h"
+
+#include "config.h"
+#include "fourcc.h"
+#include "avio.hxx"
+#include "config.h"
+#include "avi_vars.h"
+
+
+
+#include "ADM_toolkit/toolkit.hxx"
+#include "ADM_editor/ADM_edit.hxx"
+#include "ADM_video/ADM_genvideo.hxx"
+
+#include "ADM_filter/video_filters.h"
+#include "ADM_video/ADM_cache.h"
+
+#include "ADM_vidMcDeint_param.h"
+
+#include "ADM_userInterfaces/ADM_commonUI/DIA_factory.h"
+
+static FILTER_PARAM mcDeintParam={3,{"mode","qp","initial_parity"}};
+
+struct vf_priv_s {
+    int mode;
+    int qp;
+    int parity;
+#if 0
+    int temp_stride[3];
+    uint8_t *src[3];
+    int16_t *temp[3];
+#endif
+    int outbuf_size;
+    uint8_t *outbuf;
+    AVCodecContext *avctx_enc;
+    AVFrame *frame;
+    AVFrame *frame_dec;
+};
+
+
+class  AVDMVideoMCDeint:public AVDMGenericVideoStream
+ {
+
+ protected:
+                MCDEINT_PARAM *_param;
+                VideoCache      *vidCache;
+                uint8_t         init();
+                uint8_t         cleanup();
+                vf_priv_s       priv;
+ public:
+    virtual char          *printConf(void) ;
+                  AVDMVideoMCDeint(  AVDMGenericVideoStream *in,CONFcouple *setup);
+                 ~AVDMVideoMCDeint();
+ virtual uint8_t getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
+                            ADMImage *data,uint32_t *flags);
+
+  virtual uint8_t configure( AVDMGenericVideoStream *instream);
+  virtual uint8_t getCoupledConf( CONFcouple **couples);
+ }     ;
+
+SCRIPT_CREATE(mcdeint_script,AVDMVideoMCDeint,mcDeintParam);
+BUILD_CREATE(mcdeint_create,AVDMVideoMCDeint);
+
+static void filter(struct vf_priv_s *p, uint8_t *dst[3], uint8_t *src[3], int dst_stride[3], int src_stride[3], int width, int height);
+uint8_t DIA_mcDeint(MCDEINT_PARAM *param);
+
+
+char *AVDMVideoMCDeint::printConf( void )
+{
+static char buf[50];
+
+        sprintf((char *)buf," MC deinterlacer : Mode %d, qp %d, parity %d ",_param->mode,_param->qp,_param->initial_parity);
+        return buf;
+}
+uint8_t AVDMVideoMCDeint::configure(AVDMGenericVideoStream * instream)
+{
+  
+   diaMenuEntry menuMode[4]={{0,_("Fast"),NULL},
+                             {1,_("Medium"),NULL},
+                             {2,_("Slow iterative motion search"),NULL},
+                             {3,_("Extra Slow (same as 3+multiple reference frame)"),NULL}
+                          };
+   diaMenuEntry menuField[2]={{0,_("Top"),NULL},
+                             {1,_("Bottom"),NULL}
+                          };
+  
+    diaElemMenu     menu1(&(_param->mode),_("Mode"), 4,menuMode);
+    diaElemMenu     menu2(&(_param->initial_parity),_("Field Dominance"), 2,menuField);
+    diaElemUInteger qp(&(_param->qp),_("Qp"),1,60);
+    
+    diaElem *elems[3]={&menu1,&menu2,&qp};
+  
+    return  diaFactoryRun("Fade",3,elems);
+
+}
+uint8_t AVDMVideoMCDeint::getCoupledConf( CONFcouple **couples)
+{
+
+                        ADM_assert(_param);
+                        *couples=new CONFcouple(3);
+
+#define CSET(x)  (*couples)->setCouple((char *)#x,(_param->x))
+                CSET(mode);
+                CSET(qp);
+                CSET(initial_parity);
+                return 1;
+
+}
+
+//_______________________________________________________________
+AVDMVideoMCDeint::AVDMVideoMCDeint(AVDMGenericVideoStream *in,CONFcouple *couples)
+{
+
+        _in=in;
+        memcpy(&_info,_in->getInfo(),sizeof(_info));
+        _param=NEW(MCDEINT_PARAM);
+        vidCache=new VideoCache(4,_in);
+        if(couples)
+        {
+                GET(mode);
+                GET(qp);
+                GET(initial_parity);
+        }
+        else
+        {
+                _param->mode=0;
+                _param->qp=1;
+                _param->initial_parity=0;
+                
+        }
+        _info.encoding=1;
+        init();
+}
+
+
+
+// ___ destructor_____________
+AVDMVideoMCDeint::~AVDMVideoMCDeint()
+{
+      cleanup();
+      delete  vidCache;
+      delete _param;
+      _param=NULL;
+      vidCache=NULL;
+}
+uint8_t AVDMVideoMCDeint::getFrameNumberNoAlloc(uint32_t frame,
+                                uint32_t *len,
+                                ADMImage *data,
+                                uint32_t *flags)
+{
+                        if(frame>=_info.nb_frames) 
+                        {
+                                printf("MPdelogo : Filter : out of bound!\n");
+                                return 0;
+                        }
+        
+                        ADM_assert(_param);
+
+ADMImage *curImage;
+char txt[256];
+                        curImage=vidCache->getImage(frame);
+                        if(!curImage)
+                        {
+                                printf("MCDeint : error getting frame\n");
+                                return 0;
+                        }
+              
+                      // Prepare to call filter...
+                  uint8_t *dplanes[3],*splanes[3];
+                  int dstride[3],sstride[3];
+
+                  dstride[0]=sstride[0]=_info.width;
+                  dstride[2]=sstride[2]=dstride[1]=sstride[1]=_info.width>>1;
+
+                  splanes[0]=YPLANE(curImage);
+                  splanes[1]=UPLANE(curImage);
+                  splanes[2]=VPLANE(curImage);
+
+                  dplanes[0]=YPLANE(data);
+                  dplanes[1]=UPLANE(data);
+                  dplanes[2]=VPLANE(data);
+
+
+                  filter(&priv, dplanes, splanes, dstride, sstride, _info.width, _info.height);
+                  vidCache->unlockAll();
+        return 1;
+}
+uint8_t AVDMVideoMCDeint::init( void )
+{
+  memset(&priv,0,sizeof(priv));
+  int i;
+  
+  AVCodec *enc= avcodec_find_encoder(CODEC_ID_SNOW);
+  ADM_assert(enc);
+
+        for(i=0; i<3; i++)
+        {
+            AVCodecContext *avctx_enc;
+            avctx_enc=     priv.avctx_enc= avcodec_alloc_context();
+            avctx_enc->width = _info.width;
+            avctx_enc->height = _info.height;
+            avctx_enc->time_base= (AVRational){1,25};  // meaningless
+            avctx_enc->gop_size = 300;
+            avctx_enc->max_b_frames= 0;
+            avctx_enc->pix_fmt = PIX_FMT_YUV420P;
+            avctx_enc->flags = CODEC_FLAG_QSCALE | CODEC_FLAG_LOW_DELAY;
+            avctx_enc->strict_std_compliance = FF_COMPLIANCE_EXPERIMENTAL;
+            avctx_enc->global_quality= 1;
+            avctx_enc->flags2= CODEC_FLAG2_MEMC_ONLY;
+            avctx_enc->me_cmp=
+            avctx_enc->me_sub_cmp= FF_CMP_SAD; //SSE;
+            avctx_enc->mb_cmp= FF_CMP_SSE;
+
+            switch(_param->mode)
+            {
+            case 3:
+                avctx_enc->refs= 3;
+            case 2:
+                avctx_enc->me_method= ME_ITER;
+            case 1:
+                avctx_enc->flags |= CODEC_FLAG_4MV;
+                avctx_enc->dia_size=2;
+//                avctx_enc->mb_decision = MB_DECISSION_RD;
+            case 0:
+                avctx_enc->flags |= CODEC_FLAG_QPEL;
+            }
+
+            avcodec_open(avctx_enc, enc);
+
+        }
+        priv.frame= avcodec_alloc_frame();
+
+        priv.outbuf_size= _info.width*_info.height*10;
+        priv.outbuf= (uint8_t *)ADM_alloc(priv.outbuf_size);
+        priv.parity=_param->initial_parity;
+  return 1;
+}
+uint8_t AVDMVideoMCDeint::cleanup( void )
+{
+  //
+   avcodec_close(priv.avctx_enc);
+   av_free(priv.avctx_enc);
+   ADM_dezalloc(priv.outbuf);
+   memset(&priv,0,sizeof(priv));
+  return 1;
+}
+
+
+/*
+Known Issues:
+* The motion estimation is somewhat at the mercy of the input, if the input
+  frames are created purely based on spatial interpolation then for example
+  a thin black line or another random and not interpolateable pattern
+  will cause problems
+  Note: completly ignoring the "unavailable" lines during motion estimation 
+  didnt look any better, so the most obvious solution would be to improve
+  tfields or penalize problematic motion vectors ...
+
+* If non iterative ME is used then snow currently ignores the OBMC window
+  and as a result sometimes creates artifacts
+
+* only past frames are used, we should ideally use future frames too, something
+  like filtering the whole movie in forward and then backward direction seems 
+  like a interresting idea but the current filter framework is FAR from
+  supporting such things
+
+* combining the motion compensated image with the input image also isnt
+  as trivial as it seems, simple blindly taking even lines from one and
+  odd ones from the other doesnt work at all as ME/MC sometimes simple
+  has nothing in the previous frames which matches the current, the current
+  algo has been found by trial and error and almost certainly can be
+  improved ...
+*/
+
+
+
+#define MIN(a,b) ((a) > (b) ? (b) : (a))
+#define MAX(a,b) ((a) < (b) ? (b) : (a))
+#define ABS(a) ((a) > 0 ? (a) : (-(a)))
+
+//===========================================================================//
+
+
+static void filter(struct vf_priv_s *p, uint8_t *dst[3], uint8_t *src[3], int dst_stride[3], int src_stride[3], int width, int height){
+    int x, y, i;
+    int out_size;
+
+    for(i=0; i<3; i++){
+        p->frame->data[i]= src[i];
+        p->frame->linesize[i]= src_stride[i];
+    }
+
+    p->avctx_enc->me_cmp=
+    p->avctx_enc->me_sub_cmp= FF_CMP_SAD /*| (p->parity ? FF_CMP_ODD : FF_CMP_EVEN)*/;
+    p->frame->quality= p->qp*FF_QP2LAMBDA;
+    out_size = avcodec_encode_video(p->avctx_enc, p->outbuf, p->outbuf_size, p->frame);
+    p->frame_dec = p->avctx_enc->coded_frame;
+
+    for(i=0; i<3; i++){
+        int is_chroma= !!i;
+        int w= width >>is_chroma;
+        int h= height>>is_chroma;
+        int fils= p->frame_dec->linesize[i];
+        int srcs= src_stride[i];
+
+        for(y=0; y<h; y++){
+            if((y ^ p->parity) & 1){
+                for(x=0; x<w; x++){
+                    if((x-2)+(y-1)*w>=0 && (x+2)+(y+1)*w<w*h){ //FIXME either alloc larger images or optimize this
+                        uint8_t *filp= &p->frame_dec->data[i][x + y*fils];
+                        uint8_t *srcp= &src[i][x + y*srcs];
+                        int diff0= filp[-fils] - srcp[-srcs];
+                        int diff1= filp[+fils] - srcp[+srcs];
+                        int spatial_score= ABS(srcp[-srcs-1] - srcp[+srcs-1])
+                                          +ABS(srcp[-srcs  ] - srcp[+srcs  ])
+                                          +ABS(srcp[-srcs+1] - srcp[+srcs+1]) - 1;
+                        int temp= filp[0];
+
+#define CHECK(j)\
+    {   int score= ABS(srcp[-srcs-1+j] - srcp[+srcs-1-j])\
+                 + ABS(srcp[-srcs  +j] - srcp[+srcs  -j])\
+                 + ABS(srcp[-srcs+1+j] - srcp[+srcs+1-j]);\
+        if(score < spatial_score){\
+            spatial_score= score;\
+            diff0= filp[-fils+j] - srcp[-srcs+j];\
+            diff1= filp[+fils-j] - srcp[+srcs-j];
+
+                        CHECK(-1) CHECK(-2) }} }}
+                        CHECK( 1) CHECK( 2) }} }}
+#if 0
+                        if((diff0 ^ diff1) > 0){
+                            int mindiff= ABS(diff0) > ABS(diff1) ? diff1 : diff0;
+                            temp-= mindiff;
+                        }
+#elif 1
+                        if(diff0 + diff1 > 0)
+                            temp-= (diff0 + diff1 - ABS( ABS(diff0) - ABS(diff1) )/2)/2;
+                        else
+                            temp-= (diff0 + diff1 + ABS( ABS(diff0) - ABS(diff1) )/2)/2;
+#else
+                        temp-= (diff0 + diff1)/2;
+#endif
+#if 1
+                        filp[0]=
+                        dst[i][x + y*dst_stride[i]]= temp > 255U ? ~(temp>>31) : temp;
+#else
+                        dst[i][x + y*dst_stride[i]]= filp[0];
+                        filp[0]= temp > 255U ? ~(temp>>31) : temp;
+#endif
+                    }else
+                        dst[i][x + y*dst_stride[i]]= p->frame_dec->data[i][x + y*fils];
+                }
+            }
+        }
+        for(y=0; y<h; y++){
+            if(!((y ^ p->parity) & 1)){
+                for(x=0; x<w; x++){
+#if 1
+                    p->frame_dec->data[i][x + y*fils]=
+                    dst[i][x + y*dst_stride[i]]= src[i][x + y*srcs];
+#else
+                    dst[i][x + y*dst_stride[i]]= p->frame_dec->data[i][x + y*fils];
+                    p->frame_dec->data[i][x + y*fils]= src[i][x + y*srcs];
+#endif
+                }
+            }
+        }
+    }
+    p->parity ^= 1;
+
+}
+#ifdef titititititi_II
+static int config(struct vf_instance_s* vf,
+        int width, int height, int d_width, int d_height,
+	unsigned int flags, unsigned int outfmt){
+        int i;
+        AVCodec *enc= avcodec_find_encoder(CODEC_ID_SNOW);
+
+        for(i=0; i<3; i++){
+            AVCodecContext *avctx_enc;
+#if 0
+            int is_chroma= !!i;
+            int w= ((width  + 31) & (~31))>>is_chroma;
+            int h= ((height + 31) & (~31))>>is_chroma;
+
+            vf->priv->temp_stride[i]= w;
+            vf->priv->temp[i]= malloc(vf->priv->temp_stride[i]*h*sizeof(int16_t));
+            vf->priv->src [i]= malloc(vf->priv->temp_stride[i]*h*sizeof(uint8_t));
+#endif
+            avctx_enc=
+            vf->priv->avctx_enc= avcodec_alloc_context();
+            avctx_enc->width = width;
+            avctx_enc->height = height;
+            avctx_enc->time_base= (AVRational){1,25};  // meaningless
+            avctx_enc->gop_size = 300;
+            avctx_enc->max_b_frames= 0;
+            avctx_enc->pix_fmt = PIX_FMT_YUV420P;
+            avctx_enc->flags = CODEC_FLAG_QSCALE | CODEC_FLAG_LOW_DELAY;
+            avctx_enc->strict_std_compliance = FF_COMPLIANCE_EXPERIMENTAL;
+            avctx_enc->global_quality= 1;
+            avctx_enc->flags2= CODEC_FLAG2_MEMC_ONLY;
+            avctx_enc->me_cmp=
+            avctx_enc->me_sub_cmp= FF_CMP_SAD; //SSE;
+            avctx_enc->mb_cmp= FF_CMP_SSE;
+
+            switch(vf->priv->mode){
+            case 3:
+                avctx_enc->refs= 3;
+            case 2:
+                avctx_enc->me_method= ME_ITER;
+            case 1:
+                avctx_enc->flags |= CODEC_FLAG_4MV;
+                avctx_enc->dia_size=2;
+//                avctx_enc->mb_decision = MB_DECISSION_RD;
+            case 0:
+                avctx_enc->flags |= CODEC_FLAG_QPEL;
+            }
+
+            avcodec_open(avctx_enc, enc);
+
+        }
+        vf->priv->frame= avcodec_alloc_frame();
+
+        vf->priv->outbuf_size= width*height*10;
+        vf->priv->outbuf= malloc(vf->priv->outbuf_size);
+
+	return vf_next_config(vf,width,height,d_width,d_height,flags,outfmt);
+}
+
+static void get_image(struct vf_instance_s* vf, mp_image_t *mpi){
+    if(mpi->flags&MP_IMGFLAG_PRESERVE) return; // don't change
+return; //caused problems, dunno why
+    // ok, we can do pp in-place (or pp disabled):
+    vf->dmpi=vf_get_image(vf->next,mpi->imgfmt,
+        mpi->type, mpi->flags | MP_IMGFLAG_READABLE, mpi->width, mpi->height);
+    mpi->planes[0]=vf->dmpi->planes[0];
+    mpi->stride[0]=vf->dmpi->stride[0];
+    mpi->width=vf->dmpi->width;
+    if(mpi->flags&MP_IMGFLAG_PLANAR){
+        mpi->planes[1]=vf->dmpi->planes[1];
+        mpi->planes[2]=vf->dmpi->planes[2];
+	mpi->stride[1]=vf->dmpi->stride[1];
+	mpi->stride[2]=vf->dmpi->stride[2];
+    }
+    mpi->flags|=MP_IMGFLAG_DIRECT;
+}
+
+static int put_image(struct vf_instance_s* vf, mp_image_t *mpi, double pts){
+    mp_image_t *dmpi;
+
+    if(!(mpi->flags&MP_IMGFLAG_DIRECT)){
+        // no DR, so get a new image! hope we'll get DR buffer:
+        dmpi=vf_get_image(vf->next,mpi->imgfmt,
+            MP_IMGTYPE_TEMP,
+            MP_IMGFLAG_ACCEPT_STRIDE|MP_IMGFLAG_PREFER_ALIGNED_STRIDE,
+            mpi->width,mpi->height);
+        vf_clone_mpi_attributes(dmpi, mpi);
+    }else{
+        dmpi=vf->dmpi;
+    }
+
+    filter(vf->priv, dmpi->planes, mpi->planes, dmpi->stride, mpi->stride, mpi->w, mpi->h);
+
+    return vf_next_put_image(vf,dmpi, pts);
+}
+
+static void uninit(struct vf_instance_s* vf){
+    if(!vf->priv) return;
+
+#if 0
+    for(i=0; i<3; i++){
+        if(vf->priv->temp[i]) free(vf->priv->temp[i]);
+        vf->priv->temp[i]= NULL;
+        if(vf->priv->src[i]) free(vf->priv->src[i]);
+        vf->priv->src[i]= NULL;
+    }
+#endif
+    av_freep(&vf->priv->avctx_enc);
+
+    free(vf->priv->outbuf);
+    free(vf->priv);
+    vf->priv=NULL;
+}
+
+#endif
+//EOF

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMcDeint_param.h (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMcDeint_param.h)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMcDeint_param.h	2006-10-31 15:59:58 UTC (rev 2489)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMcDeint_param.h	2007-01-11 08:00:52 UTC (rev 2701)
@@ -0,0 +1,15 @@
+
+
+#ifndef MC_DEINT_PARAM_H
+#define MC_DEINT_PARAM_H
+
+typedef struct MCDEINT_PARAM
+{
+    uint32_t mode;
+    uint32_t initial_parity;
+    uint32_t qp;
+
+}MCDEINT_PARAM;
+
+
+#endif



From mean at mail.berlios.de  Thu Jan 11 09:05:26 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 11 Jan 2007 09:05:26 +0100
Subject: [Avidemux-svn-commit] r2702 - in
	branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces:
	ADM_GTK/ADM_dialog ADM_NONE/ADM_dialog ADM_QT4/ADM_dialog
Message-ID: <200701110805.l0B85QdV011386@sheep.berlios.de>

Author: mean
Date: 2007-01-11 09:05:26 +0100 (Thu, 11 Jan 2007)
New Revision: 2702

Removed:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_mcdeint.cpp
Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp
Log:
DIA_ cleanup

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_mcdeint.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_mcdeint.cpp	2007-01-11 08:00:52 UTC (rev 2701)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_mcdeint.cpp	2007-01-11 08:05:26 UTC (rev 2702)
@@ -1,166 +0,0 @@
-
-#include <config.h>
-
-
-#include <string.h>
-#include <stdio.h>
-
-#include <gdk/gdkkeysyms.h>
-#include <gtk/gtk.h>
-
-
-#include <gdk/gdkkeysyms.h>
-#include <gtk/gtk.h>
-# include <math.h>
-
-#include "default.h"
-#include "ADM_toolkit_gtk/ADM_gladeSupport.h"
-#include "ADM_toolkit_gtk/toolkit_gtk.h"
-#include "ADM_toolkit_gtk/toolkit_gtk_include.h"
-#include "ADM_toolkit/toolkit.hxx"
-
-#include "ADM_video/ADM_vidMcDeint_param.h"
-static GtkWidget	*create_dialog1 (void);
-
-#define SPIN_GET(x,y) {param->y= gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(WID(x))) ;}
-#define SPIN_SET(x,y)  {gtk_spin_button_set_value(GTK_SPIN_BUTTON(WID(x)),(gfloat)param->y) ;}
-
-#define COMBO_SET(x,y) {gtk_combo_box_set_active(GTK_COMBO_BOX(WID(x)),param->y);}
-#define COMBO_GET(x,y) {param->y=gtk_combo_box_get_active(GTK_COMBO_BOX(WID(x)));}
-uint8_t DIA_mcDeint(MCDEINT_PARAM *param);
-uint8_t DIA_mcDeint(MCDEINT_PARAM *param)
-{
-GtkWidget *dialog;
-int ret=0;
-    dialog=create_dialog1();
-
-    // Update
-
-      COMBO_SET(comboboxMode,mode);
-      COMBO_SET(combobox2,initial_parity);
-
-      SPIN_SET(spinbutton1,qp);
-      gtk_register_dialog(dialog);
-
-      if(gtk_dialog_run(GTK_DIALOG(dialog))==GTK_RESPONSE_OK)
-      {
-           COMBO_GET(comboboxMode,mode);
-           COMBO_GET(combobox2,initial_parity);
-
-           SPIN_GET(spinbutton1,qp);
-          ret=1;
-      }
-      gtk_unregister_dialog(dialog);
-      gtk_widget_destroy(dialog);
-      return ret;
-
-}
-
-
-
-GtkWidget*
-create_dialog1 (void)
-{
-  GtkWidget *dialog1;
-  GtkWidget *dialog_vbox1;
-  GtkWidget *table1;
-  GtkWidget *label1;
-  GtkWidget *label2;
-  GtkWidget *label3;
-  GtkWidget *comboboxMode;
-  GtkWidget *combobox2;
-  GtkObject *spinbutton1_adj;
-  GtkWidget *spinbutton1;
-  GtkWidget *dialog_action_area1;
-  GtkWidget *cancelbutton1;
-  GtkWidget *okbutton1;
-
-  dialog1 = gtk_dialog_new ();
-  gtk_window_set_title (GTK_WINDOW (dialog1), _("MC Deint"));
-  gtk_window_set_type_hint (GTK_WINDOW (dialog1), GDK_WINDOW_TYPE_HINT_DIALOG);
-
-  dialog_vbox1 = GTK_DIALOG (dialog1)->vbox;
-  gtk_widget_show (dialog_vbox1);
-
-  table1 = gtk_table_new (3, 2, FALSE);
-  gtk_widget_show (table1);
-  gtk_box_pack_start (GTK_BOX (dialog_vbox1), table1, TRUE, TRUE, 0);
-
-  label1 = gtk_label_new (_("Mode :"));
-  gtk_widget_show (label1);
-  gtk_table_attach (GTK_TABLE (table1), label1, 0, 1, 0, 1,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_misc_set_alignment (GTK_MISC (label1), 0, 0.5);
-
-  label2 = gtk_label_new (_("Field Dominance :"));
-  gtk_widget_show (label2);
-  gtk_table_attach (GTK_TABLE (table1), label2, 0, 1, 1, 2,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_misc_set_alignment (GTK_MISC (label2), 0, 0.5);
-
-  label3 = gtk_label_new (_("Qp :"));
-  gtk_widget_show (label3);
-  gtk_table_attach (GTK_TABLE (table1), label3, 0, 1, 2, 3,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_misc_set_alignment (GTK_MISC (label3), 0, 0.5);
-
-  comboboxMode = gtk_combo_box_new_text ();
-  gtk_widget_show (comboboxMode);
-  gtk_table_attach (GTK_TABLE (table1), comboboxMode, 1, 2, 0, 1,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (GTK_FILL), 0, 0);
-  gtk_combo_box_append_text (GTK_COMBO_BOX (comboboxMode), _("0- Fast"));
-  gtk_combo_box_append_text (GTK_COMBO_BOX (comboboxMode), _("1- Medium"));
-  gtk_combo_box_append_text (GTK_COMBO_BOX (comboboxMode), _("2- Slow, iterative motion estimation"));
-  gtk_combo_box_append_text (GTK_COMBO_BOX (comboboxMode), _("3- Extra slow, same as [2] + multiple reference frame"));
-
-  combobox2 = gtk_combo_box_new_text ();
-  gtk_widget_show (combobox2);
-  gtk_table_attach (GTK_TABLE (table1), combobox2, 1, 2, 1, 2,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (GTK_FILL), 0, 0);
-  gtk_combo_box_append_text (GTK_COMBO_BOX (combobox2), _("Top"));
-  gtk_combo_box_append_text (GTK_COMBO_BOX (combobox2), _("Bottom"));
-
-  spinbutton1_adj = gtk_adjustment_new (1, 1, 60, 1, 10, 10);
-  spinbutton1 = gtk_spin_button_new (GTK_ADJUSTMENT (spinbutton1_adj), 1, 0);
-  gtk_widget_show (spinbutton1);
-  gtk_table_attach (GTK_TABLE (table1), spinbutton1, 1, 2, 2, 3,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (spinbutton1), TRUE);
-
-  dialog_action_area1 = GTK_DIALOG (dialog1)->action_area;
-  gtk_widget_show (dialog_action_area1);
-  gtk_button_box_set_layout (GTK_BUTTON_BOX (dialog_action_area1), GTK_BUTTONBOX_END);
-
-  cancelbutton1 = gtk_button_new_from_stock ("gtk-cancel");
-  gtk_widget_show (cancelbutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), cancelbutton1, GTK_RESPONSE_CANCEL);
-  GTK_WIDGET_SET_FLAGS (cancelbutton1, GTK_CAN_DEFAULT);
-
-  okbutton1 = gtk_button_new_from_stock ("gtk-ok");
-  gtk_widget_show (okbutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), okbutton1, GTK_RESPONSE_OK);
-  GTK_WIDGET_SET_FLAGS (okbutton1, GTK_CAN_DEFAULT);
-
-  /* Store pointers to all widgets, for use by lookup_widget(). */
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog1, "dialog1");
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_vbox1, "dialog_vbox1");
-  GLADE_HOOKUP_OBJECT (dialog1, table1, "table1");
-  GLADE_HOOKUP_OBJECT (dialog1, label1, "label1");
-  GLADE_HOOKUP_OBJECT (dialog1, label2, "label2");
-  GLADE_HOOKUP_OBJECT (dialog1, label3, "label3");
-  GLADE_HOOKUP_OBJECT (dialog1, comboboxMode, "comboboxMode");
-  GLADE_HOOKUP_OBJECT (dialog1, combobox2, "combobox2");
-  GLADE_HOOKUP_OBJECT (dialog1, spinbutton1, "spinbutton1");
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_action_area1, "dialog_action_area1");
-  GLADE_HOOKUP_OBJECT (dialog1, cancelbutton1, "cancelbutton1");
-  GLADE_HOOKUP_OBJECT (dialog1, okbutton1, "okbutton1");
-
-  return dialog1;
-}
-

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am	2007-01-11 08:00:52 UTC (rev 2701)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am	2007-01-11 08:05:26 UTC (rev 2702)
@@ -31,7 +31,6 @@
 	DIA_coloryuv.cpp \
 	DIA_quota.cpp \
 	DIA_animated.cpp \
-	DIA_mcdeint.cpp \
 	DIA_defaultAudio.cpp \
 	DIA_partial.cpp \
 	DIA_ass.cpp DIA_bitrateHisto.cpp

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp	2007-01-11 08:00:52 UTC (rev 2701)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp	2007-01-11 08:05:26 UTC (rev 2702)
@@ -44,7 +44,6 @@
 #include "ADM_audiofilter/audioencoder_lame_param.h"
 #include "ADM_video/ADM_vidDGbob_param.h"
 #include "ADM_audiofilter/audioencoder_lame_param.h"
-#include "ADM_video/ADM_vidMcDeint_param.h"
 #include "ADM_encoder/adm_encmjpeg_param.h"
 #include "ADM_video/ADM_vidMosaic_param.h"
 #include "ADM_video/ADM_vidMSharpen_param.h"
@@ -112,7 +111,6 @@
 uint8_t DIA_getMSmooth(MSMOOTH_PARAM *param){return 0;}
 uint8_t DIA_getPartial(PARTIAL_CONFIG *param,AVDMGenericVideoStream *son,AVDMGenericVideoStream *previous){return 0;}
 uint8_t DIA_lavpp_deint(lavc_pp_param *param){return 0;}
-uint8_t DIA_mcDeint(MCDEINT_PARAM *param){return 0;}
 uint8_t DIA_mjpegCodecSetting(COMPRES_PARAMS *param){return 0;}
 uint8_t  DIA_mosaic(MOSAIC_PARAMS *mosaic){return 0;}
 uint8_t DIA_pipe(char **cmd,char **param){return 0;}

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp	2007-01-11 08:00:52 UTC (rev 2701)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp	2007-01-11 08:05:26 UTC (rev 2702)
@@ -44,7 +44,6 @@
 #include "ADM_audiofilter/audioencoder_lame_param.h"
 #include "ADM_video/ADM_vidDGbob_param.h"
 #include "ADM_audiofilter/audioencoder_lame_param.h"
-#include "ADM_video/ADM_vidMcDeint_param.h"
 #include "ADM_encoder/adm_encmjpeg_param.h"
 #include "ADM_video/ADM_vidMosaic_param.h"
 #include "ADM_video/ADM_vidMSharpen_param.h"
@@ -112,7 +111,6 @@
 uint8_t DIA_getMSmooth(MSMOOTH_PARAM *param){return 0;}
 uint8_t DIA_getPartial(PARTIAL_CONFIG *param,AVDMGenericVideoStream *son,AVDMGenericVideoStream *previous){return 0;}
 uint8_t DIA_lavpp_deint(lavc_pp_param *param){return 0;}
-uint8_t DIA_mcDeint(MCDEINT_PARAM *param){return 0;}
 uint8_t DIA_mjpegCodecSetting(COMPRES_PARAMS *param){return 0;}
 uint8_t  DIA_mosaic(MOSAIC_PARAMS *mosaic){return 0;}
 uint8_t DIA_pipe(char **cmd,char **param){return 0;}



From mean at mail.berlios.de  Thu Jan 11 09:07:08 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 11 Jan 2007 09:07:08 +0100
Subject: [Avidemux-svn-commit] r2703 - in
	branches/avidemux_2.4_branch/avidemux: ADM_video ADM_videoFilter
Message-ID: <200701110807.l0B878Uk011455@sheep.berlios.de>

Author: mean
Date: 2007-01-11 09:07:07 +0100 (Thu, 11 Jan 2007)
New Revision: 2703

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am
Log:
oved to dialogFactory

Modified: branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am	2007-01-11 08:05:26 UTC (rev 2702)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am	2007-01-11 08:07:07 UTC (rev 2703)
@@ -89,7 +89,6 @@
  ADM_vidColorYuv.cpp  \
  ADM_guiResize.cpp \
  ADM_vidAnimated.cpp \
- ADM_vidMcDeint.cpp \
  ADM_vidReverse.cpp  \
  ADM_vidASS.cpp
 
@@ -149,8 +148,8 @@
 ADM_vidConvolution.cpp ADM_vidMSharpen.cpp ADM_vidlavdeint.h \
 ADM_vidConvolution.hxx ADM_vidMSharpen_param.h ADM_vobsubinfo.cpp \
 ADM_vidCrop.cpp  ADM_vidMSmooth_param.h  ADM_vobsubinfo.h \
-ADM_vidDGbob.cpp ADM_vidMcDeint.cpp  ASM_vidDenoise.cpp \
-ADM_vidDGbob_param.h ADM_vidMcDeint_param.h  DIA_kerneldeint.cpp \
+ADM_vidDGbob.cpp ASM_vidDenoise.cpp \
+ADM_vidDGbob_param.h   DIA_kerneldeint.cpp \
 ADM_vidDecDec.cpp  ADM_vidMosaic.cpp swscale_internal.h \
 ADM_vidTdeint_util.txt ADM_vidASS.h ADM_vidASS.cpp \
 ADM_vidAss_Params.h mmx_macros.h

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am	2007-01-11 08:05:26 UTC (rev 2702)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am	2007-01-11 08:07:07 UTC (rev 2703)
@@ -7,6 +7,7 @@
 #INCLUDES = $(all_includes) 
 
 libADM_videoFilter_a_SOURCES =  \
+ ADM_vidMcDeint.cpp \
  ADM_vidFade.cpp \
  ADM_vidResampleFPS.cpp \
  ADM_vidSoften.cpp \



From mean at mail.berlios.de  Thu Jan 11 20:18:09 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 11 Jan 2007 20:18:09 +0100
Subject: [Avidemux-svn-commit] r2704 - in
	branches/avidemux_2.4_branch/avidemux:
	ADM_userInterfaces/ADM_GTK/ADM_dialog
	ADM_userInterfaces/ADM_GTK/ADM_dialogFactory
	ADM_userInterfaces/ADM_NONE/ADM_dialog
	ADM_userInterfaces/ADM_QT4/ADM_dialog ADM_video ADM_videoFilter
Message-ID: <200701111918.l0BJI98s024329@sheep.berlios.de>

Author: mean
Date: 2007-01-11 20:18:08 +0100 (Thu, 11 Jan 2007)
New Revision: 2704

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_lavpp_deint.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_lavpp_deintparam.h
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidKernelDeint.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidKernelDeint.h
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMPLD3D.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMPLD3D.h
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMPLD3Dlow.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMPLD3Dlow.h
Removed:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_denoise.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_kerneldeint.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_lavpp_deint.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_lavpp_deint.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_lavpp_deintparam.h
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidKernelDeint.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidKernelDeint.h
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMPLD3D.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMPLD3D.h
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMPLD3Dlow.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMPLD3Dlow.h
   branches/avidemux_2.4_branch/avidemux/ADM_video/DIA_kerneldeint.cpp
Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/FAC_float.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/FAC_integer.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am
Log:
more dialogFactory

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_denoise.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_denoise.cpp	2007-01-11 08:07:07 UTC (rev 2703)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_denoise.cpp	2007-01-11 19:18:08 UTC (rev 2704)
@@ -1 +0,0 @@
-// EMPTY

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_kerneldeint.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_kerneldeint.cpp	2007-01-11 08:07:07 UTC (rev 2703)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_kerneldeint.cpp	2007-01-11 19:18:08 UTC (rev 2704)
@@ -1,203 +0,0 @@
-//
-
-# include <config.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-
-#include <gdk/gdkkeysyms.h>
-#include <gtk/gtk.h>
-
-
-#include <gdk/gdkkeysyms.h>
-#include <gtk/gtk.h>
-#include "config.h"
-#include "default.h"
-#include "ADM_toolkit_gtk/ADM_gladeSupport.h"
-#include "ADM_toolkit_gtk/toolkit_gtk.h"
-#include "ADM_toolkit_gtk/toolkit_gtk_include.h"
-
-static GtkWidget	*create_dialog1 (void);
-
-#define CHECK_GET(x,y) {*y=gtk_toggle_button_get_active( GTK_TOGGLE_BUTTON(WID(x)));}
-#define CHECK_SET(x,y) {gtk_toggle_button_set_active( GTK_TOGGLE_BUTTON(WID(x)),*y);}	
-
-#define SPIN_GET(x,y) {*y= gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(WID(x))) ;\
-				printf(#x":%d\n",*y);}
-
-#define SPIN_SET(x,y)  {gtk_spin_button_set_value(GTK_SPIN_BUTTON(WID(x)),(gfloat)*y) ; \
-				printf(#x":%d\n",*y);}
-
-
-uint8_t DIA_kerneldeint(uint32_t *order, uint32_t *threshold, uint32_t *sharp, 
-		uint32_t *twoway, uint32_t *map);
-uint8_t DIA_kerneldeint(uint32_t *order, uint32_t *threshold, uint32_t *sharp, 
-		uint32_t *twoway, uint32_t *map)
-{
-	GtkWidget *dialog;
-
-	char str[100];
-	uint8_t ret=0;
-
-	gint r;
-
-	dialog=create_dialog1();
-//	gtk_transient(dialog);
-        gtk_register_dialog(dialog);
-	// Now update the entries
-	if(*order==0) // BFF
-	{
-		RADIO_SET(radiobuttonBFF,1);	
-	}
-	else
-	{
-		RADIO_SET(radiobuttonTFF,1);			
-	}
-	CHECK_SET(checkbuttonSharp,sharp);
-	CHECK_SET(checkbuttonTwoWay,twoway);
-	CHECK_SET(checkbuttonMap,map);
-	SPIN_SET(spinbuttonThresold,threshold);
-	
-	ret=0;
-	if(gtk_dialog_run(GTK_DIALOG(dialog))==GTK_RESPONSE_OK)
-	{
-		CHECK_GET(checkbuttonSharp,sharp);
-		CHECK_GET(checkbuttonTwoWay,twoway);
-		CHECK_GET(checkbuttonMap,map);
-		SPIN_GET(spinbuttonThresold,threshold);
-		*order=RADIO_GET(radiobuttonTFF);	
-		ret=1;
-	}
-        gtk_unregister_dialog(dialog);
-	gtk_widget_destroy(dialog);
-
-	return ret;
-
-}
-
-GtkWidget*
-create_dialog1 (void)
-{
-  GtkWidget *dialog1;
-  GtkWidget *dialog_vbox1;
-  GtkWidget *vbox1;
-  GtkWidget *hbox1;
-  GtkWidget *label1;
-  GtkWidget *hbox2;
-  GtkWidget *radiobuttonBFF;
-  GSList *radiobuttonBFF_group = NULL;
-  GtkWidget *radiobuttonTFF;
-  GtkWidget *hbox3;
-  GtkWidget *label2;
-  GtkObject *spinbuttonThresold_adj;
-  GtkWidget *spinbuttonThresold;
-  GtkWidget *checkbuttonSharp;
-  GtkWidget *checkbuttonTwoWay;
-  GtkWidget *checkbuttonMap;
-  GtkWidget *dialog_action_area1;
-  GtkWidget *cancelbutton1;
-  GtkWidget *okbutton1;
-  GtkTooltips *tooltips;
-
-  tooltips = gtk_tooltips_new ();
-
-  dialog1 = gtk_dialog_new ();
-  gtk_window_set_title (GTK_WINDOW (dialog1), _("Kernel Deinterlacer"));
-
-  dialog_vbox1 = GTK_DIALOG (dialog1)->vbox;
-  gtk_widget_show (dialog_vbox1);
-
-  vbox1 = gtk_vbox_new (FALSE, 0);
-  gtk_widget_show (vbox1);
-  gtk_box_pack_start (GTK_BOX (dialog_vbox1), vbox1, TRUE, TRUE, 0);
-
-  hbox1 = gtk_hbox_new (FALSE, 0);
-  gtk_widget_show (hbox1);
-  gtk_box_pack_start (GTK_BOX (vbox1), hbox1, TRUE, TRUE, 0);
-
-  label1 = gtk_label_new (_("Field Order :"));
-  gtk_widget_show (label1);
-  gtk_box_pack_start (GTK_BOX (hbox1), label1, TRUE, FALSE, 0);
-
-  hbox2 = gtk_hbox_new (FALSE, 0);
-  gtk_widget_show (hbox2);
-  gtk_box_pack_start (GTK_BOX (hbox1), hbox2, TRUE, TRUE, 0);
-
-  radiobuttonBFF = gtk_radio_button_new_with_mnemonic (NULL, _("Bottom Field First"));
-  gtk_widget_show (radiobuttonBFF);
-  gtk_box_pack_start (GTK_BOX (hbox2), radiobuttonBFF, FALSE, FALSE, 0);
-  gtk_radio_button_set_group (GTK_RADIO_BUTTON (radiobuttonBFF), radiobuttonBFF_group);
-  radiobuttonBFF_group = gtk_radio_button_get_group (GTK_RADIO_BUTTON (radiobuttonBFF));
-
-  radiobuttonTFF = gtk_radio_button_new_with_mnemonic (NULL, _("Top Field First"));
-  gtk_widget_show (radiobuttonTFF);
-  gtk_box_pack_start (GTK_BOX (hbox2), radiobuttonTFF, FALSE, FALSE, 0);
-  gtk_radio_button_set_group (GTK_RADIO_BUTTON (radiobuttonTFF), radiobuttonBFF_group);
-  radiobuttonBFF_group = gtk_radio_button_get_group (GTK_RADIO_BUTTON (radiobuttonTFF));
-
-  hbox3 = gtk_hbox_new (FALSE, 0);
-  gtk_widget_show (hbox3);
-  gtk_box_pack_start (GTK_BOX (vbox1), hbox3, TRUE, TRUE, 0);
-
-  label2 = gtk_label_new (_("Threshold :"));
-  gtk_widget_show (label2);
-  gtk_box_pack_start (GTK_BOX (hbox3), label2, TRUE, FALSE, 0);
-
-  spinbuttonThresold_adj = gtk_adjustment_new (1, 0, 100, 1, 10, 10);
-  spinbuttonThresold = gtk_spin_button_new (GTK_ADJUSTMENT (spinbuttonThresold_adj), 1, 0);
-  gtk_widget_show (spinbuttonThresold);
-  gtk_box_pack_start (GTK_BOX (hbox3), spinbuttonThresold, TRUE, TRUE, 0);
-  gtk_tooltips_set_tip (tooltips, spinbuttonThresold, _("smaller means deinterlace more!"), NULL);
-  gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (spinbuttonThresold), TRUE);
-
-  checkbuttonSharp = gtk_check_button_new_with_mnemonic (_("Sharp"));
-  gtk_widget_show (checkbuttonSharp);
-  gtk_box_pack_start (GTK_BOX (vbox1), checkbuttonSharp, FALSE, FALSE, 0);
-  gtk_tooltips_set_tip (tooltips, checkbuttonSharp, _("Sharper engine"), NULL);
-
-  checkbuttonTwoWay = gtk_check_button_new_with_mnemonic (_("Two Way"));
-  gtk_widget_show (checkbuttonTwoWay);
-  gtk_box_pack_start (GTK_BOX (vbox1), checkbuttonTwoWay, FALSE, FALSE, 0);
-  gtk_tooltips_set_tip (tooltips, checkbuttonTwoWay, _("Extrapolate two ways (better not use it)"), NULL);
-
-  checkbuttonMap = gtk_check_button_new_with_mnemonic (_("Map"));
-  gtk_widget_show (checkbuttonMap);
-  gtk_box_pack_start (GTK_BOX (vbox1), checkbuttonMap, FALSE, FALSE, 0);
-  gtk_tooltips_set_tip (tooltips, checkbuttonMap, _("Show the interlaced areas (test only!)"), NULL);
-
-  dialog_action_area1 = GTK_DIALOG (dialog1)->action_area;
-  gtk_widget_show (dialog_action_area1);
-  gtk_button_box_set_layout (GTK_BUTTON_BOX (dialog_action_area1), GTK_BUTTONBOX_END);
-
-  cancelbutton1 = gtk_button_new_from_stock ("gtk-cancel");
-  gtk_widget_show (cancelbutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), cancelbutton1, GTK_RESPONSE_CANCEL);
-  GTK_WIDGET_SET_FLAGS (cancelbutton1, GTK_CAN_DEFAULT);
-
-  okbutton1 = gtk_button_new_from_stock ("gtk-ok");
-  gtk_widget_show (okbutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), okbutton1, GTK_RESPONSE_OK);
-  GTK_WIDGET_SET_FLAGS (okbutton1, GTK_CAN_DEFAULT);
-
-  /* Store pointers to all widgets, for use by lookup_widget(). */
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog1, "dialog1");
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_vbox1, "dialog_vbox1");
-  GLADE_HOOKUP_OBJECT (dialog1, vbox1, "vbox1");
-  GLADE_HOOKUP_OBJECT (dialog1, hbox1, "hbox1");
-  GLADE_HOOKUP_OBJECT (dialog1, label1, "label1");
-  GLADE_HOOKUP_OBJECT (dialog1, hbox2, "hbox2");
-  GLADE_HOOKUP_OBJECT (dialog1, radiobuttonBFF, "radiobuttonBFF");
-  GLADE_HOOKUP_OBJECT (dialog1, radiobuttonTFF, "radiobuttonTFF");
-  GLADE_HOOKUP_OBJECT (dialog1, hbox3, "hbox3");
-  GLADE_HOOKUP_OBJECT (dialog1, label2, "label2");
-  GLADE_HOOKUP_OBJECT (dialog1, spinbuttonThresold, "spinbuttonThresold");
-  GLADE_HOOKUP_OBJECT (dialog1, checkbuttonSharp, "checkbuttonSharp");
-  GLADE_HOOKUP_OBJECT (dialog1, checkbuttonTwoWay, "checkbuttonTwoWay");
-  GLADE_HOOKUP_OBJECT (dialog1, checkbuttonMap, "checkbuttonMap");
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_action_area1, "dialog_action_area1");
-  GLADE_HOOKUP_OBJECT (dialog1, cancelbutton1, "cancelbutton1");
-  GLADE_HOOKUP_OBJECT (dialog1, okbutton1, "okbutton1");
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, tooltips, "tooltips");
-
-  return dialog1;
-}
-

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_lavpp_deint.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_lavpp_deint.cpp	2007-01-11 08:07:07 UTC (rev 2703)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_lavpp_deint.cpp	2007-01-11 19:18:08 UTC (rev 2704)
@@ -1,194 +0,0 @@
-//
-// C++ Implementation: %{MODULE}
-//
-// Description: 
-//
-//
-// Author: %{AUTHOR} <%{EMAIL}>, (C) %{YEAR}
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-#include <config.h>
-#include "ADM_lavcodec.h"
-
-
-#include <string.h>
-#include <stdio.h>
-
-#include <gdk/gdkkeysyms.h>
-#include <gtk/gtk.h>
-
-
-
-#include <gdk/gdkkeysyms.h>
-#include <gtk/gtk.h>
-# include <math.h>
-
-
-#include "default.h"//#include "avi_vars.h"
-#include "ADM_toolkit_gtk/ADM_gladeSupport.h"
-#include "ADM_toolkit_gtk/toolkit_gtk.h"
-#include "ADM_toolkit_gtk/toolkit_gtk_include.h"
-
-
-
-#include "ADM_toolkit/toolkit.hxx"
-#include "ADM_assert.h" 
-
-#include "ADM_toolkit/toolkit.hxx"
-#include "ADM_video/ADM_lavpp_deintparam.h"
-
-#define CHECK_GET(x,y) {param->y=gtk_toggle_button_get_active( GTK_TOGGLE_BUTTON(WID(x)));}
-#define CHECK_SET(x,y) {gtk_toggle_button_set_active( GTK_TOGGLE_BUTTON(WID(x)),param->y);}                                 
-
-static GtkWidget        *create_dialog1 (void);
-
-uint8_t DIA_lavpp_deint(lavc_pp_param *param)
-{
-  GtkWidget *dialog;
-  uint8_t r=0;
-  
-  
-  dialog=create_dialog1();
-  gtk_register_dialog(dialog);
-  CHECK_SET(checkbuttonAutoLevel,autolevel);
- 
-  
-  gtk_option_menu_set_history (GTK_OPTION_MENU(WID(optionmenu1)),param->deintType);
-  
-  if(gtk_dialog_run(GTK_DIALOG(dialog))==GTK_RESPONSE_OK)
-  {
-    CHECK_GET(checkbuttonAutoLevel,autolevel);
-    param->deintType=getRangeInMenu(WID(optionmenu1));
-    r=1; 
-  }
-  gtk_unregister_dialog(dialog);
-  gtk_widget_destroy(dialog);
-  return r;
-}
-
-//**************************
-GtkWidget*
-create_dialog1 (void)
-{
-  GtkWidget *dialog1;
-  GtkWidget *dialog_vbox1;
-  GtkWidget *table1;
-  GtkWidget *label1;
-  GtkWidget *label2;
-  GtkWidget *checkbuttonAutoLevel;
-  GtkWidget *optionmenu1;
-  GtkWidget *menu1;
-  GtkWidget *none1;
-  GtkWidget *linear_blend1;
-  GtkWidget *linear_interpolation1;
-  GtkWidget *cubic_interpolation1;
-  GtkWidget *median_deinterlacer1;
-  GtkWidget *ffmpeg_deinterlacer1;
-  GtkWidget *dialog_action_area1;
-  GtkWidget *cancelbutton1;
-  GtkWidget *okbutton1;
-
-  dialog1 = gtk_dialog_new ();
-  gtk_window_set_title (GTK_WINDOW (dialog1), _("Lavc PP Deint"));
-
-  dialog_vbox1 = GTK_DIALOG (dialog1)->vbox;
-  gtk_widget_show (dialog_vbox1);
-
-  table1 = gtk_table_new (2, 2, FALSE);
-  gtk_widget_show (table1);
-  gtk_box_pack_start (GTK_BOX (dialog_vbox1), table1, TRUE, TRUE, 0);
-
-  label1 = gtk_label_new (_("Deinterlacing : "));
-  gtk_widget_show (label1);
-  gtk_table_attach (GTK_TABLE (table1), label1, 0, 1, 0, 1,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_label_set_justify (GTK_LABEL (label1), GTK_JUSTIFY_LEFT);
-  gtk_misc_set_alignment (GTK_MISC (label1), 0, 0.5);
-
-  label2 = gtk_label_new (_("AutoLevel :"));
-  gtk_widget_show (label2);
-  gtk_table_attach (GTK_TABLE (table1), label2, 0, 1, 1, 2,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_label_set_justify (GTK_LABEL (label2), GTK_JUSTIFY_LEFT);
-  gtk_misc_set_alignment (GTK_MISC (label2), 0, 0.5);
-
-  checkbuttonAutoLevel = gtk_check_button_new_with_mnemonic (_(" "));
-  gtk_widget_show (checkbuttonAutoLevel);
-  gtk_table_attach (GTK_TABLE (table1), checkbuttonAutoLevel, 1, 2, 1, 2,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-
-  optionmenu1 = gtk_option_menu_new ();
-  gtk_widget_show (optionmenu1);
-  gtk_table_attach (GTK_TABLE (table1), optionmenu1, 1, 2, 0, 1,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-
-  menu1 = gtk_menu_new ();
-
-  none1 = gtk_menu_item_new_with_mnemonic (_("None"));
-  gtk_widget_show (none1);
-  gtk_container_add (GTK_CONTAINER (menu1), none1);
-
-  linear_blend1 = gtk_menu_item_new_with_mnemonic (_("Linear Blend"));
-  gtk_widget_show (linear_blend1);
-  gtk_container_add (GTK_CONTAINER (menu1), linear_blend1);
-
-  linear_interpolation1 = gtk_menu_item_new_with_mnemonic (_("Linear Interpolation"));
-  gtk_widget_show (linear_interpolation1);
-  gtk_container_add (GTK_CONTAINER (menu1), linear_interpolation1);
-
-  cubic_interpolation1 = gtk_menu_item_new_with_mnemonic (_("Cubic interpolation"));
-  gtk_widget_show (cubic_interpolation1);
-  gtk_container_add (GTK_CONTAINER (menu1), cubic_interpolation1);
-
-  median_deinterlacer1 = gtk_menu_item_new_with_mnemonic (_("Median Deinterlacer"));
-  gtk_widget_show (median_deinterlacer1);
-  gtk_container_add (GTK_CONTAINER (menu1), median_deinterlacer1);
-
-  ffmpeg_deinterlacer1 = gtk_menu_item_new_with_mnemonic (_("FFmpeg Deinterlacer"));
-  gtk_widget_show (ffmpeg_deinterlacer1);
-  gtk_container_add (GTK_CONTAINER (menu1), ffmpeg_deinterlacer1);
-
-  gtk_option_menu_set_menu (GTK_OPTION_MENU (optionmenu1), menu1);
-
-  dialog_action_area1 = GTK_DIALOG (dialog1)->action_area;
-  gtk_widget_show (dialog_action_area1);
-  gtk_button_box_set_layout (GTK_BUTTON_BOX (dialog_action_area1), GTK_BUTTONBOX_END);
-
-  cancelbutton1 = gtk_button_new_from_stock ("gtk-cancel");
-  gtk_widget_show (cancelbutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), cancelbutton1, GTK_RESPONSE_CANCEL);
-  GTK_WIDGET_SET_FLAGS (cancelbutton1, GTK_CAN_DEFAULT);
-
-  okbutton1 = gtk_button_new_from_stock ("gtk-ok");
-  gtk_widget_show (okbutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), okbutton1, GTK_RESPONSE_OK);
-  GTK_WIDGET_SET_FLAGS (okbutton1, GTK_CAN_DEFAULT);
-
-  /* Store pointers to all widgets, for use by lookup_widget(). */
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog1, "dialog1");
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_vbox1, "dialog_vbox1");
-  GLADE_HOOKUP_OBJECT (dialog1, table1, "table1");
-  GLADE_HOOKUP_OBJECT (dialog1, label1, "label1");
-  GLADE_HOOKUP_OBJECT (dialog1, label2, "label2");
-  GLADE_HOOKUP_OBJECT (dialog1, checkbuttonAutoLevel, "checkbuttonAutoLevel");
-  GLADE_HOOKUP_OBJECT (dialog1, optionmenu1, "optionmenu1");
-  GLADE_HOOKUP_OBJECT (dialog1, menu1, "menu1");
-  GLADE_HOOKUP_OBJECT (dialog1, none1, "none1");
-  GLADE_HOOKUP_OBJECT (dialog1, linear_blend1, "linear_blend1");
-  GLADE_HOOKUP_OBJECT (dialog1, linear_interpolation1, "linear_interpolation1");
-  GLADE_HOOKUP_OBJECT (dialog1, cubic_interpolation1, "cubic_interpolation1");
-  GLADE_HOOKUP_OBJECT (dialog1, median_deinterlacer1, "median_deinterlacer1");
-  GLADE_HOOKUP_OBJECT (dialog1, ffmpeg_deinterlacer1, "ffmpeg_deinterlacer1");
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_action_area1, "dialog_action_area1");
-  GLADE_HOOKUP_OBJECT (dialog1, cancelbutton1, "cancelbutton1");
-  GLADE_HOOKUP_OBJECT (dialog1, okbutton1, "okbutton1");
-
-  return dialog1;
-}
-

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am	2007-01-11 08:07:07 UTC (rev 2703)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am	2007-01-11 19:18:08 UTC (rev 2704)
@@ -14,15 +14,15 @@
 	DIA_working.h DIA_busy.cpp DIA_busy.h DIA_exLame.cpp DIA_pipe.cpp DIA_mpeg2opt.cpp \
 	DIA_d3d.cpp DIA_postproc.cpp DIA_enter.cpp DIA_enter.h DIA_xvcd.cpp DIA_muxer.cpp \
 	DIA_xvid.cpp DIA_crop.cpp DIA_color.cpp DIA_encoding.cpp DIA_SVCD.cpp DIA_prefs.cpp \
-	DIA_requant.cpp DIA_xvid4.cpp DIA_lavcodec.cpp DIA_kerneldeint.cpp \
+	DIA_requant.cpp DIA_xvid4.cpp DIA_lavcodec.cpp \
 	DIA_dectel.cpp DIA_decimate.cpp DIA_pause.cpp \
 	DIA_DVDff.cpp DIA_lavdecoder.cpp DIA_lame.cpp DIA_calculator.cpp DIA_equalizer.cpp \
-	DIA_vobsub.cpp DIA_x264.cpp DIA_ocr.cpp DIA_lavpp_deint.cpp DIA_hue.cpp DIA_eq2.cpp \
+	DIA_vobsub.cpp DIA_x264.cpp DIA_ocr.cpp  DIA_hue.cpp DIA_eq2.cpp \
 	DIA_dgbob.cpp DIA_msharpen.cpp DIA_asharp.cpp DIA_dmx.cpp DIA_idx_pg.cpp DIA_gototime.cpp \
 	DIA_audioTrack.cpp DIA_cnr2.cpp DIA_resizeWiz.cpp DIA_jobs.cpp DIA_jobs_save.cpp DIA_mosaic.cpp \
 	DIA_deblend.cpp DIA_v2v.cpp DIA_tdeint.cpp DIA_builtin.cpp DIA_mpdelogo.cpp DIA_vorbis.cpp \
         DIA_chromaShift.cpp \
-        DIA_denoise.cpp \
+        \
         DIA_preview.cpp \
         DIA_contrast.cpp \
         DIA_srt.cpp \
@@ -51,8 +51,8 @@
 DIA_audio.cpp        DIA_decimate.cpp      DIA_idx_pg.h         DIA_pause.cpp       DIA_vorbis.cpp \
 DIA_audioTrack.cpp   DIA_dectel.cpp        DIA_indexer.cpp      DIA_pipe.cpp        DIA_working.cpp \
 DIA_audiocodec.cpp   DIA_defaultAudio.cpp  DIA_jobs.cpp         DIA_postproc.cpp    DIA_working.h \
-DIA_denoise.cpp       DIA_jobs_save.cpp    DIA_prefs.cpp       DIA_x264.cpp \
-DIA_builtin.cpp      DIA_dgbob.cpp         DIA_kerneldeint.cpp  DIA_preview.cpp     DIA_xvcd.cpp \
+DIA_jobs_save.cpp    DIA_prefs.cpp       DIA_x264.cpp \
+DIA_builtin.cpp      DIA_dgbob.cpp         DIA_preview.cpp     DIA_xvcd.cpp \
 DIA_busy.cpp         DIA_dmx.cpp           DIA_lame.cpp         DIA_properties.cpp  DIA_xvid.cpp \
 DIA_busy.h           DIA_dnr.cpp           DIA_lavcodec.cpp     DIA_quota.cpp       DIA_xvid4.cpp \
 DIA_calculator.cpp   DIA_encoding.cpp      DIA_lavdecoder.cpp   DIA_recent.cpp \

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/FAC_float.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/FAC_float.cpp	2007-01-11 08:07:07 UTC (rev 2703)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/FAC_float.cpp	2007-01-11 19:18:08 UTC (rev 2704)
@@ -80,7 +80,9 @@
   GtkWidget *widget=(GtkWidget *)myWidget;
   ELEM_TYPE_FLOAT *val=(ELEM_TYPE_FLOAT *)param;
   ADM_assert(widget);
-  *(ELEM_TYPE_FLOAT *)param=gtk_spin_button_get_value_as_int (GTK_SPIN_BUTTON (widget));
+  *val=gtk_spin_button_get_value(GTK_SPIN_BUTTON (widget));
+  if(*val<min) *val=min;
+  if(*val>max) *val=max;
 }
 
 //EOF

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/FAC_integer.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/FAC_integer.cpp	2007-01-11 08:07:07 UTC (rev 2703)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/FAC_integer.cpp	2007-01-11 19:18:08 UTC (rev 2704)
@@ -79,7 +79,10 @@
   GtkWidget *widget=(GtkWidget *)myWidget;
   int32_t *val=(int32_t *)param;
   ADM_assert(widget);
-  *(int32_t *)param=gtk_spin_button_get_value_as_int (GTK_SPIN_BUTTON (widget));
+  *val=gtk_spin_button_get_value_as_int (GTK_SPIN_BUTTON (widget));
+  if(*val<min) *val=min;
+  if(*val>max) *val=max;
+  
 }
 //**********************************************************************************
 
@@ -132,7 +135,10 @@
   GtkWidget *widget=(GtkWidget *)myWidget;
   uint32_t *val=(uint32_t *)param;
   ADM_assert(widget);
-  *(uint32_t *)param=gtk_spin_button_get_value_as_int (GTK_SPIN_BUTTON (widget));
+  *val=gtk_spin_button_get_value_as_int (GTK_SPIN_BUTTON (widget));
+  if(*val<min) *val=min;
+  if(*val>max) *val=max;
+
 }
 
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp	2007-01-11 08:07:07 UTC (rev 2703)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp	2007-01-11 19:18:08 UTC (rev 2704)
@@ -58,7 +58,6 @@
 #include "ADM_video/ADM_vidChromaShift_param.h"
 #include "ADM_video/ADM_vidMPdelogo.h"
 #include "ADM_video/ADM_vidEq2.h"
-#include "ADM_video/ADM_lavpp_deintparam.h"
 #include "ADM_video/ADM_vidContrast.h"
 #include "ADM_video/ADM_vidFont.h"
 #include "ADM_video/ADM_vidSRT.h"
@@ -110,7 +109,6 @@
 uint8_t DIA_getMSharpen(MSHARPEN_PARAM *param){return 0;}
 uint8_t DIA_getMSmooth(MSMOOTH_PARAM *param){return 0;}
 uint8_t DIA_getPartial(PARTIAL_CONFIG *param,AVDMGenericVideoStream *son,AVDMGenericVideoStream *previous){return 0;}
-uint8_t DIA_lavpp_deint(lavc_pp_param *param){return 0;}
 uint8_t DIA_mjpegCodecSetting(COMPRES_PARAMS *param){return 0;}
 uint8_t  DIA_mosaic(MOSAIC_PARAMS *mosaic){return 0;}
 uint8_t DIA_pipe(char **cmd,char **param){return 0;}

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp	2007-01-11 08:07:07 UTC (rev 2703)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp	2007-01-11 19:18:08 UTC (rev 2704)
@@ -58,7 +58,6 @@
 #include "ADM_video/ADM_vidChromaShift_param.h"
 #include "ADM_video/ADM_vidMPdelogo.h"
 #include "ADM_video/ADM_vidEq2.h"
-#include "ADM_video/ADM_lavpp_deintparam.h"
 #include "ADM_video/ADM_vidContrast.h"
 #include "ADM_video/ADM_vidFont.h"
 #include "ADM_video/ADM_vidSRT.h"
@@ -110,7 +109,6 @@
 uint8_t DIA_getMSharpen(MSHARPEN_PARAM *param){return 0;}
 uint8_t DIA_getMSmooth(MSMOOTH_PARAM *param){return 0;}
 uint8_t DIA_getPartial(PARTIAL_CONFIG *param,AVDMGenericVideoStream *son,AVDMGenericVideoStream *previous){return 0;}
-uint8_t DIA_lavpp_deint(lavc_pp_param *param){return 0;}
 uint8_t DIA_mjpegCodecSetting(COMPRES_PARAMS *param){return 0;}
 uint8_t  DIA_mosaic(MOSAIC_PARAMS *mosaic){return 0;}
 uint8_t DIA_pipe(char **cmd,char **param){return 0;}

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_lavpp_deint.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_lavpp_deint.cpp	2007-01-11 08:07:07 UTC (rev 2703)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_lavpp_deint.cpp	2007-01-11 19:18:08 UTC (rev 2704)
@@ -1,272 +0,0 @@
-//
-// C++ Implementation: %{MODULE}
-//
-// Description: 
-//
-//
-// Author: %{AUTHOR} <%{EMAIL}>, (C) %{YEAR}
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//  Small wrapper for lavcodec deinterlacer postprocessing
-
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include "config.h"
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <math.h>
-#include <ADM_assert.h>
-
-#include "config.h"
-#include "fourcc.h"
-
-#include "ADM_toolkit/toolkit.hxx"
-#include "ADM_editor/ADM_edit.hxx"
-#include "ADM_video/ADM_genvideo.hxx"
-#include "ADM_filter/video_filters.h"
-
-#include "ADM_toolkit/filesel.h"
-
-#include "ADM_colorspace/colorspace.h"
-
-#include "ADM_osSupport/ADM_cpuCap.h"
-
-#include "ADM_osSupport/ADM_debugID.h"
-#define MODULE_NAME MODULE_FILTER
-#include "ADM_osSupport/ADM_debug.h"
-
-#include "ADM_lavpp_deintparam.h"
-
-/*
-{"al", "autolevels",            0, 1, 2, LEVEL_FIX},
-{"lb", "linblenddeint",         1, 1, 4, LINEAR_BLEND_DEINT_FILTER},
-{"li", "linipoldeint",          1, 1, 4, LINEAR_IPOL_DEINT_FILTER},
-{"ci", "cubicipoldeint",        1, 1, 4, CUBIC_IPOL_DEINT_FILTER},
-{"md", "mediandeint",           1, 1, 4, MEDIAN_DEINT_FILTER},
-{"fd", "ffmpegdeint",           1, 1, 4, FFMPEG_DEINT_FILTER},
-{"tn", "tmpnoise",              1, 7, 8, TEMP_NOISE_FILTER},
-
-{"fq", "forcequant",            1, 0, 0, FORCE_QUANT}, *******************
-{"l5", "lowpass5",              1, 1, 4, LOWPASS5_DEINT_FILTER}, *********
-*/
-
-
-extern uint8_t DIA_lavpp_deint(lavc_pp_param *param);
-
-class  ADMVideoLavPPDeint:public AVDMGenericVideoStream
-{
-
-  protected:
-    virtual char                    *printConf(void);
-    void                            *ppcontext;
-    void                            *ppmode;
-    ADMImage                        *uncompressed;
-    lavc_pp_param                   *_param;
-    
-    void                            setup( void );
-    void                            cleanup( void );
-  public:
-    
-    
-    ADMVideoLavPPDeint(  AVDMGenericVideoStream *in,CONFcouple *setup);
-    ~ADMVideoLavPPDeint();
-    virtual uint8_t getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-                                          ADMImage *data,uint32_t *flags);
-    virtual uint8_t getCoupledConf( CONFcouple **couples)           ;
-    virtual uint8_t configure( AVDMGenericVideoStream *instream);
-                                                        
-};
-
-
-static FILTER_PARAM lavppdeint_param={2,{"deintType","autolevel"}};
-//*************************************************************
-//
-
-//*************************************************************
-SCRIPT_CREATE(lavppdeint_script,ADMVideoLavPPDeint,lavppdeint_param);
-BUILD_CREATE(lavppdeint_create,ADMVideoLavPPDeint);
-//*************************************************************
-uint8_t ADMVideoLavPPDeint::configure(AVDMGenericVideoStream *in)
-{
-
-  if(DIA_lavpp_deint(_param))
-  {
-    setup();
-    return 1; 
-  }
-  return 0;        
-}
- 
-//*************************************************************
-char *ADMVideoLavPPDeint::printConf( void )
-{
-  static char buf[50];
-        
-  sprintf((char *)buf," Lavcodec PP deinterlacer autolev:%d deint:%d",_param->autolevel,_param->deintType);
-  return buf;
-}
-//*************************************************************
-ADMVideoLavPPDeint::ADMVideoLavPPDeint(  AVDMGenericVideoStream *in,CONFcouple *couples)
-{
-
-  _in=in;         
-  memcpy(&_info,_in->getInfo(),sizeof(_info));    
-  _info.encoding=1;  
-  
-  ppcontext=NULL;  
-  ppmode=NULL;   
-  
-  _uncompressed=new ADMImage(_info.width,_info.height);
-  if(couples)
-  {   
-    _param=NEW(lavc_pp_param);
-    GET(deintType);    
-    GET(autolevel);
-  }      
-  else
-  {
-    _param=NEW(lavc_pp_param);
-    _param->deintType=0;
-    _param->autolevel=0;
-    
-  } 
-                 
-  setup();
- 
-}
-//*************************************************************
-void ADMVideoLavPPDeint::cleanup(void)
-{
-  if(ppcontext)
-  {
-    pp_free_context(ppcontext);
-    ppcontext=NULL;
-  }
-  if(ppmode)
-  {
-    pp_free_mode(ppmode);
-    ppmode=NULL;
-  }
-  
-} 
-//*************************************************************
-void ADMVideoLavPPDeint::setup(void)
-{
-  char string[1024];
-  uint32_t ppCaps=0;
-                
-  string[0]=0;
-  
-        cleanup();
-#if (defined( ARCH_X86)  || defined(ARCH_X86_64))
-#define ADD(x,y) if( CpuCaps::has##x()) ppCaps|=PP_CPU_CAPS_##y;                
-                ADD(MMX,MMX);           
-                ADD(3DNOW,3DNOW);
-                ADD(MMXEXT,MMX2);
-#endif             
-        cleanup();
-#undef ADD       
-#define ADD(z)  { if(string[0]) strcat(string,","#z); else strcpy(string,#z);}        
-               
-        if(_param->autolevel) ADD(al);
-        switch(_param->deintType)
-        {
-          case PP_BM_NONE:break;
-          case PP_BM_LINEAR_BLEND: ADD(lb);break;
-          case PP_BM_LINEAR_INTER: ADD(li);break;
-          case PP_BM_CUBIC_INTER: ADD(ci);break;
-          case PP_BM_MEDIAN_INTER: ADD(md);break;
-          case PP_BM_FFMPEG_DEINT: ADD(fd);break;                             
-        }        
-
-
-        ppcontext=pp_get_context(_info.width, _info.height, ppCaps);           
-        ppmode=pp_get_mode_by_name_and_quality(string,1);;
-        
-        ADM_assert(ppcontext);
-        ADM_assert(ppmode);
-  
-} 
-//*************************************************************
-ADMVideoLavPPDeint::~ADMVideoLavPPDeint()
-{
-  cleanup();
-  if(_uncompressed)
-        delete _uncompressed;
-  DELETE(_param);
-  _uncompressed=NULL;
-}
-
-//*************************************************************
-uint8_t ADMVideoLavPPDeint::getCoupledConf( CONFcouple **couples)
-{
-  
-  *couples=new CONFcouple(2);
-  CSET(deintType);    
-  CSET(autolevel);
-  
-  return 1;
-}
-//*************************************************************
-uint8_t ADMVideoLavPPDeint::getFrameNumberNoAlloc(uint32_t frame,
-                                              uint32_t *len,
-                                              ADMImage *data,
-                                              uint32_t *flags)
-{
-
- 
-  ADM_assert(frame<_info.nb_frames);
-        // read uncompressed frame
-  if(!_in->getFrameNumberNoAlloc(frame, len,_uncompressed,flags)) return 0;
-
-  
-  //
-  uint8_t *iBuff[3],*oBuff[3];
-  int strideTab[3],strideTab2[3];                 
-                                                                
-  oBuff[0]=YPLANE(data);
-  oBuff[1]=UPLANE(data);
-  oBuff[2]=VPLANE(data);
-                                
-  iBuff[0]=YPLANE(_uncompressed);
-  iBuff[1]=UPLANE(_uncompressed);
-  iBuff[2]=VPLANE(_uncompressed);
-                                
-                                
-  strideTab[0]=strideTab2[0]=_info.width;
-  strideTab[1]=strideTab2[1]=_info.width>>1;
-  strideTab[2]=strideTab2[2]=_info.width>>1;
-        
-  int type;
-  if(_uncompressed->flags&AVI_KEY_FRAME)
-    type=1;
-  else if(_uncompressed->flags & AVI_B_FRAME)
-    type=3;
-  else
-    type=2;
-  pp_postprocess(
-        iBuff,
-        strideTab,
-        oBuff,
-        strideTab2,
-        _info.width,
-        _info.height,
-        NULL,
-        0,
-        ppmode,
-        ppcontext,
-        type); // I ?
-                                
-  
-  data->copyInfo(_uncompressed);
-  return 1;
-}

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_lavpp_deintparam.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_lavpp_deintparam.h	2007-01-11 08:07:07 UTC (rev 2703)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_lavpp_deintparam.h	2007-01-11 19:18:08 UTC (rev 2704)
@@ -1,26 +0,0 @@
-//
-// C++ Interface: %{MODULE}
-//
-// Description: 
-//
-//
-// Author: %{AUTHOR} <%{EMAIL}>, (C) %{YEAR}
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-typedef enum 
-{
-  PP_BM_NONE           =0x0000,
-  PP_BM_LINEAR_BLEND   =0x0001, 
-  PP_BM_LINEAR_INTER   =0x0002, 
-  PP_BM_CUBIC_INTER    =0x0003, 
-  PP_BM_MEDIAN_INTER   =0x0004, 
-  PP_BM_FFMPEG_DEINT   =0x0005,  
-};
-
-typedef struct lavc_pp_param
-{
-  uint32_t      deintType;
-  uint32_t       autolevel;
-}lavc_pp_param;

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidKernelDeint.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidKernelDeint.cpp	2007-01-11 08:07:07 UTC (rev 2703)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidKernelDeint.cpp	2007-01-11 19:18:08 UTC (rev 2704)
@@ -1,449 +0,0 @@
-/***************************************************************************
-                          ADM_vidKernelDeint  -  description
-                             -------------------
- 			Port of another D Graft deinterlacer
-			http://neuron2.net/kerneldeint/kerneldeint.html
-     ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-
-/*
-	KernelDeint() plugin for Avisynth.
-
-	Copyright (C) 2003 Donald A. Graft
-
-	This program is free software; you can redistribute it and/or modify
-	it under the terms of the GNU General Public License as published by
-	the Free Software Foundation.
-
-	This program is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-	GNU General Public License for more details.
-
-	You should have received a copy of the GNU General Public License
-	along with this program; if not, write to the Free Software
-	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-*/
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <ADM_assert.h>
-#include <math.h>
-#include <math.h>
-#include <iconv.h>
-#include "config.h"
-
-
-#include "fourcc.h"
-#include "avio.hxx"
-
-#include "avi_vars.h"
-
-#include "ADM_toolkit/toolkit.hxx"
-#include "ADM_editor/ADM_edit.hxx"
-#include "ADM_video/ADM_genvideo.hxx"
-
-#include "ADM_osSupport/ADM_debugID.h"
-#define MODULE_NAME MODULE_FILTER
-#include "ADM_osSupport/ADM_debug.h"
-#include "ADM_filter/video_filters.h"
-#include "ADM_vidKernelDeint.h"
-
-static FILTER_PARAM kdintParam={5,{"order","threshold","sharp","twoway","map"}};
-
-
-SCRIPT_CREATE(kerneldeint_script,ADMVideoKernelDeint,kdintParam);
-BUILD_CREATE(kerneldeint_create,ADMVideoKernelDeint);
-
-static int PutHintingData(uint8_t *video, unsigned int hint);
-static int GetHintingData(uint8_t *video, unsigned int *hint);
-
-extern uint8_t DIA_kerneldeint(uint32_t *order, uint32_t *threshold, uint32_t *sharp, 
-		uint32_t *twoway, uint32_t *map);
-
-#define PROGRESSIVE  0x00000001
-
-
-
-
-
-uint8_t ADMVideoKernelDeint::configure( AVDMGenericVideoStream *instream)
-{
-	_in=instream;
-	#define PX(x) &_param->x
-	if(DIA_kerneldeint(PX(order), PX(threshold), PX(sharp), 
-		PX(twoway), PX(map)))
-					return 1;
-	return 0;	
- 	
-}
-uint8_t	ADMVideoKernelDeint::getCoupledConf( CONFcouple **couples)
-{
-
-			*couples=new CONFcouple(5);
-
-			CSET(order);
-			CSET(threshold);
-			CSET(sharp);
-			CSET(twoway);
-			CSET(map);	
-
-		return 1;	
-}
-char *ADMVideoKernelDeint::printConf( void )
-{
- 	static char buf[50];
- 	
- 	sprintf((char *)buf," D Graft Kernel Deint");
-        return buf;
-}
-
-ADMVideoKernelDeint::~ADMVideoKernelDeint()
-{
- if(vidCache) delete vidCache;
- 	
-}
-
-
- ADMVideoKernelDeint::ADMVideoKernelDeint( AVDMGenericVideoStream *in,CONFcouple *couples)
-{
-
-		if(!couples)
-		{
-			_param=NEW(KERNEL_CONF);
-	    		_param->order=1; // Bff=0 / 1=tff
-	    		_param->threshold=10;
-	    		_param->sharp=0;
-	    		_param->twoway=0;
-	    		_param->map=0;
-		}
-		else
-		{
-			_param=NEW(KERNEL_CONF);
-			GET(order);
-			GET(threshold);
-			GET(sharp);
-			GET(twoway);
-			GET(map);
-						
-		}
-	    debug=0;   
-	    _in=in;
-	    
-	   _uncompressed=NULL;
-
-  	memcpy(&_info,_in->getInfo(),sizeof(_info));
-	vidCache=new VideoCache(4,_in);
-
-
-}
-uint8_t ADMVideoKernelDeint::getFrameNumberNoAlloc(uint32_t frame,
-							uint32_t *len,
-							ADMImage *data,
-							uint32_t *flags)
-{
-		
-		uint32_t frame_prev;
-		uint32_t page=_info.width*_info.height;
-		ADMImage *mysrc=NULL, *myprev=NULL;
-		
-		if(frame>_info.nb_frames-1) return 0;
-
-
-		
-		frame_prev=frame;
-		if(frame_prev) frame_prev--;
-		
-		
-		
-			mysrc=vidCache->getImage(frame);
-			myprev=vidCache->getImage(frame_prev);
-			ADM_assert(mysrc);
-			ADM_assert(myprev);
-		// Now go to kernel deint code
-			
-    const uint8_t *srcp, *prvp,*prvp_saved, *prvpp, *prvpn, *prvppp, *prvpnn, *prvp4p, *prvp4n;
-	const uint8_t *srcp_saved;
-	const uint8_t *srcpp, *srcppp, *srcpn, *srcpnn, *srcp3p, *srcp3n, *srcp4p, *srcp4n;
-    uint8_t *dstp;
-	uint8_t *dstp_saved;
- 
-	int plane;
-	int src_pitch;
-    int dst_pitch;
-    int w;
-    int h;
-	int x, y, z;
-	int val, hi, lo;
-	double valf;
-	unsigned int hint;
-	char buf[80];
-	
-	uint32_t pitch;
-	uint32_t offset;
-	
-	
-	uint32_t		order, threshold;
-	uint8_t			sharp, twoway, map;
-	
-	order=_param->order;
-	threshold=_param->threshold;
-	sharp=_param->sharp;
-	twoway=_param->twoway;
-	map=_param->map;
-	
-	
-	for (z = 0; z < 3; z++)
-	{
-		
-		pitch=_info.width;
-		switch(z)
-		{
-			case 0:		offset=0;
-					srcp=srcp_saved= YPLANE(mysrc);
-					dstp = dstp_saved=YPLANE(data);
-					prvp_saved=prvp=YPLANE(myprev);
-					break;
-			case 1:		offset=page;
-					pitch>>=1;
-					srcp=srcp_saved=UPLANE(mysrc);
-					dstp = dstp_saved=UPLANE(data);
-					prvp_saved=prvp=UPLANE(myprev);
-					break;
-			case 2:		offset=((page*5)>>2);
-					pitch>>=1;
-					srcp=srcp_saved=VPLANE(mysrc);
-					dstp = dstp_saved=VPLANE(data);
-					prvp_saved=prvp=VPLANE(myprev);
-					break;
-		
-		}
-		
-		if (z==0 && (GetHintingData((uint8_t *) srcp, &hint) == false) && (hint & PROGRESSIVE))
-		{
-			if (debug ==true)
-			{
-				printf( "KernelDeint: frame %d: progressive\n", frame); 
-				
-			}
-			memcpy(YPLANE(data),YPLANE(mysrc),page);
-			memcpy(UPLANE(data),UPLANE(mysrc),page>>2);
-			memcpy(VPLANE(data),VPLANE(mysrc),page>>2);
-			vidCache->unlockAll();
-			data->copyInfo(mysrc);
-			return 1;
-		}
-		else
-		{
-			if (debug == true)
-			{
-				printf( "KernelDeint: frame %d: interkaced\n", frame); 
-			}
-		}
-		
-		src_pitch = pitch;	
-		dst_pitch = pitch;
-		
-		w = pitch; //dst->GetRowSize(plane);
-		h=_info.height;
-		if(z) h>>=1;  //h = dst->GetHeight(plane);
-		
-		srcp = srcp_saved  + (1-order) * src_pitch;
-		dstp = dstp_saved  + (1-order) * dst_pitch;
-		for (y = 0; y < h; y+=2)
-		{
-			memcpy(dstp, srcp, w);
-			srcp += 2*src_pitch;
-			dstp += 2*dst_pitch;
-		}
-
-		// Copy through the lines that will be missed below.
-		memcpy(dstp_saved + order*dst_pitch, srcp_saved + (1-order)*src_pitch, w);
-		memcpy(dstp_saved + (2+order)*dst_pitch, srcp_saved + (3-order)*src_pitch, w);
-		memcpy(dstp_saved + (h-2+order)*dst_pitch, srcp_saved + (h-1-order)*src_pitch, w);
-		memcpy(dstp_saved + (h-4+order)*dst_pitch, srcp_saved + (h-3-order)*src_pitch, w);
-		/* For the other field choose adaptively between using the previous field
-		   or the interpolant from the current field. */
-		//prvp = prv->GetReadPtr(plane) + 5*src_pitch - (1-order)*src_pitch;
-		prvp = prvp_saved + 5*src_pitch - (1-order)*src_pitch;
-		
-		
-		prvpp = prvp - src_pitch;
-		prvppp = prvp - 2*src_pitch;
-		prvp4p = prvp - 4*src_pitch;
-		prvpn = prvp + src_pitch;
-		prvpnn = prvp + 2*src_pitch;
-		prvp4n = prvp + 4*src_pitch;
-		srcp = srcp_saved + 5*src_pitch - (1-order)*src_pitch;
-		srcpp = srcp - src_pitch;
-		srcppp = srcp - 2*src_pitch;
-		srcp3p = srcp - 3*src_pitch;
-		srcp4p = srcp - 4*src_pitch;
-		srcpn = srcp + src_pitch;
-		srcpnn = srcp + 2*src_pitch;
-		srcp3n = srcp + 3*src_pitch;
-		srcp4n = srcp + 4*src_pitch;
-		dstp =  dstp_saved  + 5*dst_pitch - (1-order)*dst_pitch;
-		for (y = 5 - (1-order); y <= h - 5 - (1-order); y+=2)
-		{
-			for (x = 0; x < w; x++)
-			{
-				if ((threshold == 0) || (frame == 0) ||
-					(abs((int)prvp[x] - (int)srcp[x]) > threshold) ||
-					(abs((int)prvpp[x] - (int)srcpp[x]) > threshold) ||
-					(abs((int)prvpn[x] - (int)srcpn[x]) > threshold))
-				{
-					if (map == true)
-					{
-						int g = x & ~3;
-						
-						{
-							if (z == 0) dstp[x] = 235;
-							else dstp[x] = 128;
-						}
-					}
-					else
-					{
-						
-						{
-							hi = (z == 0) ? 235 : 240;
-							lo = 16;
-						}
-						
-						if (sharp == true)
-						{
-							if (twoway == true)
-								valf = + 0.526*((int)srcpp[x] +
-								 (int)srcpn[x])
-								   + 0.170*((int)srcp[x] + (int)prvp[x])
-								   - 0.116*((int)srcppp[x] +
-								    (int)srcpnn[x] + (int)prvppp[x] +
-								    (int)prvpnn[x])
-					 			   - 0.026*((int)srcp3p[x] +
-								    (int)srcp3n[x])
-								   + 0.031*((int)srcp4p[x] +
-								    (int)srcp4n[x] + (int)prvp4p[x] +
-								    (int)prvp4n[x]);
-							else
-								valf = + 0.526*((int)srcpp[x] +
-								 (int)srcpn[x])
-								   + 0.170*((int)prvp[x])
-								   - 0.116*((int)prvppp[x] +
-								    (int)prvpnn[x])
-					 			   - 0.026*((int)srcp3p[x] +
-								    (int)srcp3n[x])
-								   + 0.031*((int)prvp4p[x] +
-								    (int)prvp4p[x]);
-							if (valf > hi) valf = hi;
-							else if (valf < lo) valf = lo;
-							dstp[x] = (int) valf;
-						}
-						else
-						{
-							if (twoway == true)
-								val = (8*((int)srcpp[x] + (int)srcpn[x]) +
-								 2*((int)srcp[x] + (int)prvp[x]) -
-								 			 
-									(int)(srcppp[x]) -
-									 (int)(srcpnn[x]) -
-									(int)(prvppp[x]) -
-									 (int)(prvpnn[x])) >> 4;
-							else
-								val = (8*((int)srcpp[x] + (int)srcpn[x]) +
-								 2*((int)prvp[x]) -
-									(int)(prvppp[x]) -
-									 (int)(prvpnn[x])) >> 4;
-							if (val > hi) val = hi;
-							else if (val < lo) val = lo;
-							dstp[x] = (int) val;
-						}
-					}
-				}
-				else
-				{
-					dstp[x] = srcp[x];
-				}
-			}
-			prvp  += 2*src_pitch;
-			prvpp  += 2*src_pitch;
-			prvppp  += 2*src_pitch;
-			prvpn  += 2*src_pitch;
-			prvpnn  += 2*src_pitch;
-			prvp4p  += 2*src_pitch;
-			prvp4n  += 2*src_pitch;
-			srcp  += 2*src_pitch;
-			srcpp += 2*src_pitch;
-			srcppp += 2*src_pitch;
-			srcp3p += 2*src_pitch;
-			srcp4p += 2*src_pitch;
-			srcpn += 2*src_pitch;
-			srcpnn += 2*src_pitch;
-			srcp3n += 2*src_pitch;
-			srcp4n += 2*src_pitch;
-			dstp  += 2*dst_pitch;
-		}
-	}
-	data->copyInfo(mysrc);
-	vidCache->unlockAll();
-	return 1;
-}
-
-
-
-#define MAGIC_NUMBER (0xdeadbeef)
-
-int PutHintingData(uint8_t *video, unsigned int hint)
-{
-	uint8_t *p;
-	unsigned int i, magic_number = MAGIC_NUMBER;
-	int error = false;
-
-	p = video;
-	for (i = 0; i < 32; i++)
-	{
-		*p &= ~1; 
-		*p++ |= ((magic_number & (1 << i)) >> i);
-	}
-	for (i = 0; i < 32; i++)
-	{
-		*p &= ~1;
-		*p++ |= ((hint & (1 << i)) >> i);
-	}
-	return error;
-}
-
-int GetHintingData(uint8_t *video, unsigned int *hint)
-{
-	uint8_t *p;
-	unsigned int i, magic_number = 0;
-	int error = false;
-
-	p = video;
-	for (i = 0; i < 32; i++)
-	{
-		magic_number |= ((*p++ & 1) << i);
-	}
-	if (magic_number != MAGIC_NUMBER)
-	{
-		error = true;
-	}
-	else
-	{
-		*hint = 0;
-		for (i = 0; i < 32; i++)
-		{
-			*hint |= ((*p++ & 1) << i);
-		}
-	}
-	return error;
-}

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidKernelDeint.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidKernelDeint.h	2007-01-11 08:07:07 UTC (rev 2703)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidKernelDeint.h	2007-01-11 19:18:08 UTC (rev 2704)
@@ -1,34 +0,0 @@
-
-#ifndef ADM_KERNELDEINT
-#define ADM_KERNELDEINT
-
-#include "ADM_video/ADM_cache.h"
-typedef struct  KERNEL_CONF
-{
-	uint32_t		order, threshold;
-	uint32_t		sharp, twoway, map;
-
-}KERNEL_CONF;
-
-class  ADMVideoKernelDeint:public AVDMGenericVideoStream
- {
-
- protected:
-        virtual char 		*printConf(void) ;
-	KERNEL_CONF		*_param;
-        int			 debug;
-	VideoCache		*vidCache;
-	   
-
- public:
- 		
-  			ADMVideoKernelDeint(  AVDMGenericVideoStream *in,CONFcouple *setup);
-  			~ADMVideoKernelDeint();
-	virtual uint8_t getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-						ADMImage *data,uint32_t *flags);
-	virtual uint8_t	getCoupledConf( CONFcouple **couples)		;
-	virtual uint8_t configure( AVDMGenericVideoStream *instream);
-							
-};
-
-#endif

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMPLD3D.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMPLD3D.cpp	2007-01-11 08:07:07 UTC (rev 2703)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMPLD3D.cpp	2007-01-11 19:18:08 UTC (rev 2704)
@@ -1,347 +0,0 @@
-/***************************************************************************
-                          ADM_vidMPLD3D.cpp  -  description
-                             -------------------
-Mplayer HQDenoise3d port to avidemux2
-Original Authors
-Copyright (C) 2003
-Daniel Moreno <comac at comac.darktech.org>
-	& A'rpi
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <ADM_assert.h>
-#include <math.h>
-
-#include "config.h"
-#include "fourcc.h"
-#include "avio.hxx"
-#include "config.h"
-#include "avi_vars.h"
-
-#include "ADM_toolkit/toolkit.hxx"
-#include "ADM_editor/ADM_edit.hxx"
-#include "ADM_video/ADM_genvideo.hxx"
-#include "ADM_video/ADM_vidMPLD3D.h"
-
-#include "ADM_osSupport/ADM_debugID.h"
-#define MODULE_NAME MODULE_FILTER
-#include "ADM_osSupport/ADM_debug.h"
-#include "ADM_filter/video_filters.h"
-
-
-static FILTER_PARAM mp3Param={3,{"param1","param2","param3"}};
-
-
-SCRIPT_CREATE(MPD3D_script,ADMVideoMPD3D,mp3Param);
-
-BUILD_CREATE(MPD3D_create,ADMVideoMPD3D);
-
-#define PARAM1_DEFAULT 4.0
-#define PARAM2_DEFAULT 3.0
-#define PARAM3_DEFAULT 6.0
-uint8_t DIA_d3d(double *luma,double *chroma,double *temporal);
- char 	*ADMVideoMPD3D::printConf(void)
- {
-	  	static char buf[50];
-
- 				sprintf((char *)buf," MPlayer HQ Denoise 3D (%2.1f - %2.1f - %2.1f)'",
-						_param->param1,_param->param2,_param->param3);
-        return buf;
-}
-
-uint8_t ADMVideoMPD3D::configure(AVDMGenericVideoStream *instream)
-{
-
-			_in=instream;
-			if(DIA_d3d(&_param->param1,
-					&_param->param2,
-					&_param->param3))
-			{
-				setup();
-				return 1;
-			}
-			return 0;
-}
-ADMVideoMPD3D::~ADMVideoMPD3D()
-{
-
- 	DELETE(_param);
-	if(_uncompressed)
-		delete [] _uncompressed;
-	if(Line)
-		delete [] Line;
-	if(_storage)
-		delete  _storage;
-
-	_storage=NULL;
-	Line=NULL;
-	_uncompressed=NULL;
-}
-
-static inline unsigned int LowPassMul(unsigned int PrevMul, unsigned int CurrMul, int* Coef){
-//    int dMul= (PrevMul&0xFFFFFF)-(CurrMul&0xFFFFFF);
-    int dMul= PrevMul-CurrMul;
-    int d=((dMul+0x10007FF)/(65536/16));
-    return CurrMul + Coef[d];
-}
-
-void ADMVideoMPD3D::deNoise(unsigned char *Frame,        // mpi->planes[x]
-                    unsigned char *FrameDest,    // dmpi->planes[x]
-                   uint32_t 		 *LineAnt,      // vf->priv->Line (width bytes)
-		    unsigned short 	*FrameAntPtr,
-                    int W, int H, int sStride, int dStride,
-                    int *Horizontal, int *Vertical, int *Temporal)
-{
-    int X, Y;
-    int sLineOffs = 0, dLineOffs = 0;
-    unsigned int PixelAnt;
-    int PixelDst;
-    unsigned short* FrameAnt=(FrameAntPtr);
-    
-
-    /* First pixel has no left nor top neightbour. Only previous frame */
-    LineAnt[0] = PixelAnt = Frame[0]<<16;
-    PixelDst = LowPassMul(FrameAnt[0]<<8, PixelAnt, Temporal);
-    FrameAnt[0] = ((PixelDst+0x1000007F)/256);
-    FrameDest[0]= ((PixelDst+0x10007FFF)/65536);
-
-    /* Fist line has no top neightbour. Only left one for each pixel and
-     * last frame */
-    for (X = 1; X < W; X++){
-        LineAnt[X] = PixelAnt = LowPassMul(PixelAnt, Frame[X]<<16, Horizontal);
-        PixelDst = LowPassMul(FrameAnt[X]<<8, PixelAnt, Temporal);
-	FrameAnt[X] = ((PixelDst+0x1000007F)/256);
-	FrameDest[X]= ((PixelDst+0x10007FFF)/65536);
-    }
-
-    for (Y = 1; Y < H; Y++){
-	unsigned int PixelAnt;
-	unsigned short* LinePrev=&FrameAnt[Y*W];
-	sLineOffs += sStride, dLineOffs += dStride;
-        /* First pixel on each line doesn't have previous pixel */
-        PixelAnt = Frame[sLineOffs]<<16;
-        LineAnt[0] = LowPassMul(LineAnt[0], PixelAnt, Vertical);
-	PixelDst = LowPassMul(LinePrev[0]<<8, LineAnt[0], Temporal);
-	LinePrev[0] = ((PixelDst+0x1000007F)/256);
-	FrameDest[dLineOffs]= ((PixelDst+0x10007FFF)/65536);
-
-        for (X = 1; X < W; X++){
-	    int PixelDst;
-            /* The rest are normal */
-            PixelAnt = LowPassMul(PixelAnt, Frame[sLineOffs+X]<<16, Horizontal);
-            LineAnt[X] = LowPassMul(LineAnt[X], PixelAnt, Vertical);
-	    PixelDst = LowPassMul(LinePrev[X]<<8, LineAnt[X], Temporal);
-	    LinePrev[X] = ((PixelDst+0x1000007F)/256);
-	    FrameDest[dLineOffs+X]= ((PixelDst+0x10007FFF)/65536);
-        }
-    }
-}
-
-
-uint8_t  ADMVideoMPD3D::setup(void)
-{
- double LumSpac, LumTmp, ChromSpac, ChromTmp;
-
-        LumSpac = _param->param1;
-        LumTmp = _param->param3;
-
-        ChromSpac = _param->param2;
-        ChromTmp = LumTmp * ChromSpac / LumSpac;
-
-        PrecalcCoefs((int *)Coefs[0], LumSpac);
-        PrecalcCoefs((int *)Coefs[1], LumTmp);
-        PrecalcCoefs((int *)Coefs[2], ChromSpac);
-        PrecalcCoefs((int *)Coefs[3], ChromTmp);
-
-	aprintf("\n Param : %lf %lf %lf \n",
-		_param->param1,
-		_param->param2,
-		_param->param3);
-
-	return 1;
-}
-//--------------------------------------------------------
-ADMVideoMPD3D::ADMVideoMPD3D(AVDMGenericVideoStream *in,CONFcouple *couples)
-
-{
-  //uint32_t frame;
-  _storage=NULL;
-  _uncompressed=NULL;
-  Line=NULL;
-
-  _in=in;
-
-  Line=new uint32_t[in->getInfo()->width];
-  memcpy(&_info,in->getInfo(),sizeof(_info));
-  _info.encoding=1;
-  if(couples)
-  {
-			_param=NEW(MPD3D_PARAM);
-			GET(param1);
-			GET(param2);
-			GET(param3);
-	}
-	else
-	{
-			_param=NEW( MPD3D_PARAM);
-			_param->param1=PARAM1_DEFAULT;
-			_param->param2=PARAM2_DEFAULT;
-			_param->param3=PARAM3_DEFAULT;
-	}
-	_uncompressed=new uint16_t[(_info.width*_info.height*3)>>1];
-	_storage=new ADMImage(_info.width,_info.height);
-	setup();
-
-	_last=0xFFFFFFF;
-}
-
-
-uint8_t	ADMVideoMPD3D::getCoupledConf( CONFcouple **couples)
-{
-
-			ADM_assert(_param);
-			*couples=new CONFcouple(3);
- 			//(*couples)->setCouple((char *)"param",*_param);
-#define CSET(x)  (*couples)->setCouple((char *)#x,(_param->x))
-			CSET(param1);
-			CSET(param2);
-			CSET(param3);
-			return 1;
-
-}
-//                     1
-//		Get in range in 121 + coeff matrix
-//                     1
-//
-// If the value is too far away we ignore it
-// else we blend
-
-uint8_t ADMVideoMPD3D::getFrameNumberNoAlloc(uint32_t frame,
-				uint32_t *len,
-   				ADMImage *data,
-				uint32_t *flags)
-{
-UNUSED_ARG(flags);
-
-	int cw= _info.width>>1;
-	int ch= _info.height>>1;
-        int W = _info.width;
-	int H  = _info.height;
-	uint32_t dlen,dflags;
-
-  		if(frame> _info.nb_frames-1) return 0;
-		*len=(W*H*3)>>1;
-		// First and last frame we don"t modify.
-		if(!frame || (frame!=_last+1))
-			{
-					 if(!_in->getFrameNumberNoAlloc(frame, &dlen,data,&dflags))
-					 {
-					 	return 0;
-					}
-				 	unsigned short* dst=_uncompressed;
-	    				unsigned char* src=YPLANE(data);
-					for (int Y = 0; Y < W*H; Y++)
-						{
-	    						 	*(dst++)=*(src++)<<8;
-						}
-					src=UPLANE(data);
-					dst=_uncompressed+(W*H);
-					for (int Y = 0; Y < (W*H)>>2; Y++)
-						{
-	    						 	*(dst++)=*(src++)<<8;
-						}
-					src=VPLANE(data);
-					dst=_uncompressed+((5*W*H)>>2);
-					for (int Y = 0; Y < (W*H)>>2; Y++)
-						{
-	    						 	*(dst++)=*(src++)<<8;
-						}
-					
-					_last=frame;
-					return 1;
-
-			}
-		ADM_assert(frame<_info.nb_frames);
-		// read uncompressed frame
-		// else we fill previous/current/next
-		if(!_in->getFrameNumberNoAlloc(frame, &dlen,_storage,&dflags))
-		{
-			return 0;
-		}
-
-		uint8_t *c,*n;
-		unsigned short *ant;
-
-		ant=(_uncompressed);
-		n=YPLANE(data);
-		c=YPLANE(_storage);
-//
-   		deNoise(c, n,
-			Line,ant, W, H,
-                	W,W,
-                	(int *)Coefs[0],
-                	(int *)Coefs[0],
-                	(int *)Coefs[1]);
-
-
-		ant=(_uncompressed)+W*H;
-		n=UPLANE(data);
-		c=UPLANE(_storage);
-
-		deNoise(c, n,
-			Line, ant, cw, ch,
-                	cw,cw,
-                	(int *)Coefs[2],
-                	(int *)Coefs[2],
-                	(int *)Coefs[3]);
-
-
-		ant=_uncompressed+((W*H*5)>>2);
-		n=VPLANE(data);
-		c=VPLANE(_storage);
-
-		deNoise(c, n,
-			Line, ant, cw, ch,
-                	cw,cw,
-                	(int *)Coefs[2],
-                	(int *)Coefs[2],
-                	(int *)Coefs[3]);
-
-	// n is out....
-	_last=frame;
-	data->copyInfo(_storage);
-	return 1;
-
-
-}
-
-#define ABS(A) ( (A) > 0 ? (A) : -(A) )
-
-void ADMVideoMPD3D::PrecalcCoefs(int *Ct, double Dist25)
-{
-    int i;
-    double Gamma, Simil, C;
-
-    Gamma = log(0.25) / log(1.0 - Dist25/255.0 - 0.00001);
-
-    for (i = -256*16; i < 256*16; i++)
-    {
-        Simil = 1.0 - ABS(i) / (16*255.0);
-	C=4096.*(double)i;
-        C *= pow(Simil, Gamma) ;
-       Ct[16*256+i] = (int)((C<0) ? (C-0.5) : (C+0.5));
-    }
-
-}
-
-

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMPLD3D.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMPLD3D.h	2007-01-11 08:07:07 UTC (rev 2703)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMPLD3D.h	2007-01-11 19:18:08 UTC (rev 2704)
@@ -1,69 +0,0 @@
-/***************************************************************************
-                          ADM_vidMPLD3D.h  -  description
-                             -------------------
-Mplayer HQDenoise3d port to avidemux2
-Original Authors
-Copyright (C) 2003
-Daniel Moreno <comac at comac.darktech.org>
-	& A'rpi
-
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
- 
-#ifndef _D3D__
-#define _D3D__   
-#include "ADM_video/ADM_vidCached.h"
-typedef struct MPD3D_PARAM
-{
-	double  param1;
-	double  param2;
-	double  param3;
-}MPD3D_PARAM;
-
-class  ADMVideoMPD3D:public AVDMGenericVideoStream
- {
-
- protected:
-
-        			MPD3D_PARAM			*_param;
-
-				int	  					Coefs[4][512*16];
-        			uint32_t					*Line;
-
-				uint16_t				*_uncompressed;
-				ADMImage				*_storage;
-				uint32_t				_last;
-
-				void 	PrecalcCoefs(int *Ct, double Dist25);
-				uint8_t  	setup(void);
-				void 	deNoise(unsigned char *Frame,        // mpi->planes[x]
-                    					unsigned char *FrameDest,    // dmpi->planes[x]
-                    					uint32_t *LineAnt,      // vf->priv->Line (width bytes)
-		    					unsigned short *FrameAntPtr,
-                    					int W, int H, int sStride, int dStride,
-                    					int *Horizontal, int *Vertical, int *Temporal);
-
-
-
- public:
-
-
-						ADMVideoMPD3D(  AVDMGenericVideoStream *in,CONFcouple *setup);
-  						 ~ADMVideoMPD3D();
-		        virtual uint8_t 	getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-   								ADMImage *data,uint32_t *flags);
-
-			virtual uint8_t 	configure( AVDMGenericVideoStream *instream);
-     			virtual char 	*printConf(void);
-			virtual uint8_t 	getCoupledConf( CONFcouple **couples);
-							
- }     ;
-#endif

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMPLD3Dlow.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMPLD3Dlow.cpp	2007-01-11 08:07:07 UTC (rev 2703)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMPLD3Dlow.cpp	2007-01-11 19:18:08 UTC (rev 2704)
@@ -1,328 +0,0 @@
-/***************************************************************************
-                          ADM_vidMPLD3D.cpp  -  description
-                             -------------------
-Mplayer HQDenoise3d port to avidemux2
-Original Authors
-Copyright (C) 2003
-Daniel Moreno <comac at comac.darktech.org>
-	& A'rpi
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <ADM_assert.h>
-#include <math.h>
-
-#include "config.h"
-#include "fourcc.h"
-#include "avio.hxx"
-#include "config.h"
-#include "avi_vars.h"
-
-#include "ADM_toolkit/toolkit.hxx"
-#include "ADM_editor/ADM_edit.hxx"
-#include "ADM_video/ADM_genvideo.hxx"
-#include "ADM_video/ADM_vidMPLD3Dlow.h"
-
-#include "ADM_osSupport/ADM_debugID.h"
-#define MODULE_NAME MODULE_FILTER
-#include "ADM_osSupport/ADM_debug.h"
-#include "ADM_filter/video_filters.h"
-
-
-static FILTER_PARAM mp3Param={3,{"param1","param2","param3"}};
-
-
-SCRIPT_CREATE(MPD3Dlow_script,ADMVideoMPD3Dlow,mp3Param);
-BUILD_CREATE(MPD3Dlow_create,ADMVideoMPD3Dlow);
-
-#define PARAM1_DEFAULT 4.0
-#define PARAM2_DEFAULT 3.0
-#define PARAM3_DEFAULT 6.0
-uint8_t DIA_d3d(double *luma,double *chroma,double *temporal);
- char 	*ADMVideoMPD3Dlow::printConf(void)
- {
-	  	static char buf[50];
-
- 				sprintf((char *)buf," MPlayer Denoise 3D (%2.1f - %2.1f - %2.1f)'",
-						_param->param1,_param->param2,_param->param3);
-        return buf;
-}
-
-uint8_t ADMVideoMPD3Dlow::configure(AVDMGenericVideoStream *instream)
-{
-
-			_in=instream;
-			if(DIA_d3d(&_param->param1,
-					&_param->param2,
-					&_param->param3))
-			{
-				setup();
-				return 1;
-			}
-			return 0;
-}
-ADMVideoMPD3Dlow::~ADMVideoMPD3Dlow()
-{
-
- 	DELETE(_param);
-	delete  _uncompressed;
-	delete  _stored;
-	delete [] Line;
-	Line=NULL;
-	_param=NULL;
-	_uncompressed=NULL;
-	_stored=NULL;
-}
-
-
-#define LowPass(Prev, Curr, Coef) (Curr + Coef[Prev - Curr])
-
-
-void ADMVideoMPD3Dlow::deNoise(unsigned char *Frame,        // mpi->planes[x]
-                    unsigned char *FramePrev,    // pmpi->planes[x]
-                    unsigned char *FrameDest,    // dmpi->planes[x]
-                    unsigned char *LineAnt,      // vf->priv->Line (width bytes)
-                    int W, int H, int sStride, int pStride, int dStride,
-                    int *Horizontal, int *Vertical, int *Temporal)
-{
-    int X, Y;
-    int sLineOffs = 0, pLineOffs = 0, dLineOffs = 0;
-    unsigned char PixelAnt;
-
-    /* First pixel has no left nor top neightbour. Only previous frame */
-    LineAnt[0] = PixelAnt = Frame[0];
-    FrameDest[0] = LowPass(FramePrev[0], LineAnt[0], Temporal);
-
-    /* Fist line has no top neightbour. Only left one for each pixel and
-     * last frame */
-    for (X = 1; X < W; X++)
-    {
-        PixelAnt = LowPass(PixelAnt, Frame[X], Horizontal);
-        LineAnt[X] = PixelAnt;
-        FrameDest[X] = LowPass(FramePrev[X], LineAnt[X], Temporal);
-    }
-
-    for (Y = 1; Y < H; Y++)
-    {
-	sLineOffs += sStride, pLineOffs += pStride, dLineOffs += dStride;
-        /* First pixel on each line doesn't have previous pixel */
-        PixelAnt = Frame[sLineOffs];
-        LineAnt[0] = LowPass(LineAnt[0], PixelAnt, Vertical);
-        FrameDest[dLineOffs] = LowPass(FramePrev[pLineOffs], LineAnt[0], Temporal);
-
-        for (X = 1; X < W; X++)
-        {
-            /* The rest are normal */
-            PixelAnt = LowPass(PixelAnt, Frame[sLineOffs+X], Horizontal);
-            LineAnt[X] = LowPass(LineAnt[X], PixelAnt, Vertical);
-            FrameDest[dLineOffs+X] = LowPass(FramePrev[pLineOffs+X], LineAnt[X], Temporal);
-        }
-    }
-}
-
-
-
-uint8_t  ADMVideoMPD3Dlow::setup(void)
-{
- double LumSpac, LumTmp, ChromSpac, ChromTmp;
-
-        LumSpac = _param->param1;
-        LumTmp = _param->param3;
-
-        ChromSpac = _param->param2;
-        ChromTmp = LumTmp * ChromSpac / LumSpac;
-
-        PrecalcCoefs((int *)Coefs[0], LumSpac);
-        PrecalcCoefs((int *)Coefs[1], LumTmp);
-        PrecalcCoefs((int *)Coefs[2], ChromSpac);
-        PrecalcCoefs((int *)Coefs[3], ChromTmp);
-
-	aprintf("\n Param : %lf %lf %lf \n",
-		_param->param1,
-		_param->param2,
-		_param->param3);
-
-	_last=0xFFFFFFF;
-
-	return 1;
-}
-//--------------------------------------------------------
-ADMVideoMPD3Dlow::ADMVideoMPD3Dlow(
-									AVDMGenericVideoStream *in,CONFcouple *couples)
-
-{
-uint32_t page;
-
-  Line=new uint8_t [in->getInfo()->width];
-  memcpy(&_info,in->getInfo(),sizeof(_info));
-
-	page=_info.width*_info.height;
-
- // _stored=new uint8_t[(page*3)>>1];
- // _uncompressed=new uint8_t[ (page*3)>>1];
- 	_stored=new ADMImage(_info.width,_info.height);
-	_uncompressed=new ADMImage(_info.width,_info.height);
-
-  _info.encoding=1;
-  _in=in;
-  if(couples)
-  {
-			_param=NEW(MPD3D_PARAM);
-			GET(param1);
-			GET(param2);
-			GET(param3);
-	}
-	else
-	{
-			_param=NEW( MPD3D_PARAM);
-			_param->param1=PARAM1_DEFAULT;
-			_param->param2=PARAM2_DEFAULT;
-			_param->param3=PARAM3_DEFAULT;
-	}
-	setup();
-
-}
-
-
-uint8_t	ADMVideoMPD3Dlow::getCoupledConf( CONFcouple **couples)
-{
-
-			ADM_assert(_param);
-			*couples=new CONFcouple(3);
- 			//(*couples)->setCouple((char *)"param",*_param);
-#define CSET(x)  (*couples)->setCouple((char *)#x,(_param->x))
-			CSET(param1);
-			CSET(param2);
-			CSET(param3);
-			return 1;
-
-}
-//                     1
-//		Get in range in 121 + coeff matrix
-//                     1
-//
-// If the value is too far away we ignore it
-// else we blend
-
-uint8_t ADMVideoMPD3Dlow::getFrameNumberNoAlloc(uint32_t frame,
-				uint32_t *len,
-   				ADMImage *data,
-				uint32_t *flags)
-{
-UNUSED_ARG(flags);
-
-	int cw= _info.width>>1;
-	int ch= _info.height>>1;
-        int W = _info.width;
-	int H  = _info.height;
-	uint32_t dlen,dflags;
-
-  		if(frame> _info.nb_frames-1) return 0;
-		*len=(W*H*3)>>1;
-		// First and last frame we don"t modify.
-		if(!frame || (frame!=_last+1))
-			{
-				aprintf("D3D: First /last frame\n");
-				 if(!_in->getFrameNumberNoAlloc(frame, &dlen,data,&dflags))
-				 {
-					 	return 0;
-				 }
-				// store for future use
-				memcpy(_stored->data,data->data,*len);
-				_last=frame;
-				
-				return 1;
-			}
-			ADM_assert(frame<_info.nb_frames);
-			aprintf("D3D: next frame\n");
-			// read uncompressed frame
-	 		if(!_in->getFrameNumberNoAlloc(frame, &dlen,_uncompressed,&dflags))
-				 {
-					 	return 0;
-				 }
-
-		uint8_t *c,*d,*p;
-
-		d=YPLANE(data);
-		c=YPLANE(_uncompressed);
-		p=YPLANE(_stored);
-//
-
-   	deNoise(c,p, d,
-		Line, W, H,
-                W,W,W,
-               	Coefs[0] + 256,
-                Coefs[0] + 256,
-                Coefs[1] + 256);
-
-	uint32_t page=W*H;
-		d=UPLANE(data);
-		c=UPLANE(_uncompressed);
-		p=UPLANE(_stored);
-
-	deNoise(c,p, d,
-		Line, cw, ch,
-                cw,cw,cw,
-               	Coefs[2] + 256,
-                Coefs[2] + 256,
-                Coefs[3] + 256);
-
-	page=page>>2;		
-		d=VPLANE(data);
-		c=VPLANE(_uncompressed);
-		p=VPLANE(_stored);
-
-	deNoise(c,p, d,
-		Line, cw, ch,
-                cw,cw,cw,
-               	Coefs[2] + 256,
-              	Coefs[2] + 256,
-                Coefs[3] + 256);
-
-
-	_last=frame;
-	memcpy(YPLANE(_stored),YPLANE(data),W*H);
-	memcpy(UPLANE(_stored),UPLANE(data),(W*H)>>2);
-	memcpy(VPLANE(_stored),VPLANE(data),(W*H)>>2);
-	data->copyInfo(_uncompressed);
-	return 1;
-
-
-}
-
-#define ABS(A) ( (A) > 0 ? (A) : -(A) )
-
-void ADMVideoMPD3Dlow::PrecalcCoefs(int *Ct, double Dist25)
-{
- int i;
-    double Gamma, Simil, C;
-    double d;
-    Gamma = log(0.25) / log(1.0 - Dist25/255.0);
-
-    for (i = -256; i <= 255; i++)
-    {
-    	if(i>0) d=(double)i/255.;
-		else d=(double)-i/255.;
-        Simil = 1.0 - d;
-//        Ct[256+i] = lround(pow(Simil, Gamma) * (double)i);
- 	C= (double)i;
-        C *= pow(Simil, Gamma);
-
-  	Ct[256+i] = (int)((C<0) ? (C-0.5) : (C+0.5));
-
-    }
-
-
-}
-
-

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMPLD3Dlow.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMPLD3Dlow.h	2007-01-11 08:07:07 UTC (rev 2703)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMPLD3Dlow.h	2007-01-11 19:18:08 UTC (rev 2704)
@@ -1,65 +0,0 @@
-/***************************************************************************
-                          ADM_vidMPLD3D.h  -  description
-                             -------------------
-Mplayer Denoise3d port to avidemux2
-Original Authors
-Copyright (C) 2003
-Daniel Moreno <comac at comac.darktech.org>
-
-
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#ifndef __D3DLOW__
-#define __D3DLOW__
-#include "ADM_video/ADM_vidCached.h"
-#include "ADM_video/ADM_vidMPLD3D.h"
-
-class  ADMVideoMPD3Dlow:public AVDMGenericVideoStream
- {
-
- protected:
-
-        			MPD3D_PARAM			*_param;
-
-				int				Coefs[4][512];
-        			uint8_t				*Line;
-				ADMImage			*_stored;
-				
-
-
-				uint32_t					_last;
-
-				void 	PrecalcCoefs(int *Ct, double Dist25);
-				uint8_t  	setup(void);
-				void 	deNoise(unsigned char *Frame,        // mpi->planes[x]
-                    						unsigned char *FramePrev,    // pmpi->planes[x]
-                    						unsigned char *FrameDest,    // dmpi->planes[x]
-                    						unsigned char *LineAnt,      // vf->priv->Line (width bytes)
-                    						int W, int H, int sStride, int pStride, int dStride,
-                    						int *Horizontal, int *Vertical, int *Temporal);
-
-
-
- public:
-
-
-						ADMVideoMPD3Dlow(  AVDMGenericVideoStream *in,CONFcouple *setup);
-  						 ~ADMVideoMPD3Dlow();
-		        virtual uint8_t 	getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
- 									ADMImage *data,uint32_t *flags);
-
-			virtual uint8_t 	configure( AVDMGenericVideoStream *instream);
-     			virtual char 		*printConf(void);
-			virtual uint8_t 	getCoupledConf( CONFcouple **couples);
-
- }     ;
-#endif

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/DIA_kerneldeint.cpp
===================================================================

Modified: branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am	2007-01-11 08:07:07 UTC (rev 2703)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am	2007-01-11 19:18:08 UTC (rev 2704)
@@ -51,16 +51,12 @@
  ADM_vidIVTC.cpp \
  ADM_vidIVTC.h ADM_interlaced.cpp \
 	ADM_interlaced.h ADM_vidPulldown.h ADM_vidPulldown.cpp \
- ADM_vidMPLD3D.cpp \
- ADM_vidMPLD3D.h \
-	ADM_vidMPLD3Dlow.h ADM_vidMPLD3Dlow.cpp \
  ADM_vidBlend.cpp \
  ADM_vidRaw.cpp \
 	ADM_vidSRTRender.cpp \
  ADM_vidSRTload.cpp \
  ADM_vidlavdeint.cpp \
 	ADM_mpdetc.cpp \
- ADM_vidKernelDeint.cpp \
  ADM_vidForcedPP.cpp \
  ADM_vidDecTelecide.cpp \
  ADM_vidDecTelecide.h ADM_cache.cpp \
@@ -71,7 +67,6 @@
  ADM_vobsubinfo.cpp \
  ADM_vidChangeFPS.cpp \
  ADM_vidVobSubRender.cpp \
- ADM_lavpp_deint.cpp \
  ADM_vidHue.cpp \
  ADM_vidEq2.cpp \
  ADM_vidDGbob.cpp \
@@ -108,8 +103,8 @@
 ADM_guiResize.cpp  ADM_vidDropOut.cpp  ADM_vidRaw.cpp \
 ADM_interlaced.cpp ADM_vidDropOut.h  \
 ADM_interlaced.h ADM_vidEq2.cpp  ADM_vidResize.cpp \
-ADM_lavpp_deint.cpp  ADM_vidEq2.h  ADM_vidResize25.cpp \
-ADM_lavpp_deintparam.h ADM_vidEqualizer.cpp  ADM_vidReverse.cpp \
+ADM_vidEq2.h  ADM_vidResize25.cpp \
+ADM_vidEqualizer.cpp  ADM_vidReverse.cpp \
 ADM_mpdetc.cpp ADM_vidEqualizer.h  ADM_vidRotate.cpp \
 ADM_mpdetc.h ADM_vidRotate.h \
 ADM_resizebis.cpp   ADM_vidSRT.cpp \
@@ -132,16 +127,16 @@
 ADM_vidCached.cpp  ADM_vidHue.h  ADM_vidTdeint.cpp \
 ADM_vidCached.h  ADM_vidIVTC.cpp ADM_vidTelecide.cpp \
 ADM_vidChangeFPS.cpp ADM_vidIVTC.h ADM_vidTelecide.h \
-ADM_vidChangeFPS.h ADM_vidKernelDeint.cpp  ADM_vidTempSmooth.cpp \
-ADM_vidChroma.cpp  ADM_vidKernelDeint.h  ADM_vidTempSmooth.h \
+ADM_vidChangeFPS.h ADM_vidTempSmooth.cpp \
+ADM_vidChroma.cpp  ADM_vidTempSmooth.h \
 ADM_vidChroma.h  ADM_vidLargeMedian.cpp  ADM_vidUVSwap.cpp \
 ADM_vidChromaShift.cpp ADM_vidLargeMedian.h  ADM_vidUVSwap.h \
 ADM_vidChromaShift.h ADM_vidLuma.cpp ADM_vidUnblend.cpp \
 ADM_vidClean.cpp ADM_vidLuma.h ADM_vidUnblend_param.h \
-ADM_vidClean.h ADM_vidMPLD3D.cpp ADM_vidVlad.cpp \
-ADM_vidColorYuv.cpp  ADM_vidMPLD3D.h ADM_vidVlad.h \
-ADM_vidColorYuv.h  ADM_vidMPLD3Dlow.cpp  ADM_vidVobSub.h \
-ADM_vidColorYuv_param.h  ADM_vidMPLD3Dlow.h  ADM_vidVobSubRender.cpp \
+ADM_vidClean.h ADM_vidVlad.cpp \
+ADM_vidColorYuv.cpp  ADM_vidVlad.h \
+ADM_vidColorYuv.h  ADM_vidVobSub.h \
+ADM_vidColorYuv_param.h  ADM_vidVobSubRender.cpp \
 ADM_vidCommonFilter.h  ADM_vidMPLResize.cpp  ADM_vidVobsub.cpp \
 ADM_vidContrast.cpp  ADM_vidMPdelogo.cpp ADM_vidWirl.cpp \
 ADM_vidContrast.h  ADM_vidMPdelogo.h ADM_vidlavdeint.cpp \
@@ -149,7 +144,7 @@
 ADM_vidConvolution.hxx ADM_vidMSharpen_param.h ADM_vobsubinfo.cpp \
 ADM_vidCrop.cpp  ADM_vidMSmooth_param.h  ADM_vobsubinfo.h \
 ADM_vidDGbob.cpp ASM_vidDenoise.cpp \
-ADM_vidDGbob_param.h   DIA_kerneldeint.cpp \
+ADM_vidDGbob_param.h   \
 ADM_vidDecDec.cpp  ADM_vidMosaic.cpp swscale_internal.h \
 ADM_vidTdeint_util.txt ADM_vidASS.h ADM_vidASS.cpp \
 ADM_vidAss_Params.h mmx_macros.h
@@ -157,7 +152,7 @@
 ####### kdevelop will overwrite this part!!! (end)############
 INCLUDES = $(all_includes) -I../ADM_libraries -I../ADM_libraries/ADM_utilities -I../ADM_libraries/ADM_lavutil \
 			 $(FREETYPE_CFLAGS) $(ALTIVEC_SWITCH) -I../ADM_userInterfaces/ADM_commonUI -I../ADM_inputs
-noinst_HEADERS = ADM_vidlavdeint.h ADM_mpdetc.h ADM_vidKernelDeint.h \
+noinst_HEADERS = ADM_vidlavdeint.h ADM_mpdetc.h \
 					ADM_vidForcedPP.h  ADM_cache.h ADM_vidDecTel_param.h ADM_vidDecDec_param.h \
 					ADM_vidMSmooth_param.h ADM_vidEqualizer.h ADM_vobsubinfo.h ADM_vidVobSub.h \
-		ADM_lavpp_deintparam.h ADM_vidEq2.h ADM_vidASS.h
+		ADM_vidEq2.h ADM_vidASS.h

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_lavpp_deint.cpp (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_lavpp_deint.cpp)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_lavpp_deint.cpp	2006-10-31 15:59:58 UTC (rev 2489)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_lavpp_deint.cpp	2007-01-11 19:18:08 UTC (rev 2704)
@@ -0,0 +1,290 @@
+//
+// C++ Implementation: %{MODULE}
+//
+// Description: 
+//
+//
+// Author: %{AUTHOR} <%{EMAIL}>, (C) %{YEAR}
+//
+// Copyright: See COPYING file that comes with this distribution
+//
+//  Small wrapper for lavcodec deinterlacer postprocessing
+
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "config.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <math.h>
+#include <ADM_assert.h>
+
+#include "config.h"
+#include "fourcc.h"
+
+#include "ADM_toolkit/toolkit.hxx"
+#include "ADM_editor/ADM_edit.hxx"
+#include "ADM_video/ADM_genvideo.hxx"
+#include "ADM_filter/video_filters.h"
+
+#include "ADM_toolkit/filesel.h"
+
+#include "ADM_colorspace/colorspace.h"
+
+#include "ADM_osSupport/ADM_cpuCap.h"
+
+#include "ADM_osSupport/ADM_debugID.h"
+#define MODULE_NAME MODULE_FILTER
+#include "ADM_osSupport/ADM_debug.h"
+
+#include "ADM_lavpp_deintparam.h"
+
+#include "ADM_userInterfaces/ADM_commonUI/DIA_factory.h"
+/*
+{"al", "autolevels",            0, 1, 2, LEVEL_FIX},
+{"lb", "linblenddeint",         1, 1, 4, LINEAR_BLEND_DEINT_FILTER},
+{"li", "linipoldeint",          1, 1, 4, LINEAR_IPOL_DEINT_FILTER},
+{"ci", "cubicipoldeint",        1, 1, 4, CUBIC_IPOL_DEINT_FILTER},
+{"md", "mediandeint",           1, 1, 4, MEDIAN_DEINT_FILTER},
+{"fd", "ffmpegdeint",           1, 1, 4, FFMPEG_DEINT_FILTER},
+{"tn", "tmpnoise",              1, 7, 8, TEMP_NOISE_FILTER},
+
+{"fq", "forcequant",            1, 0, 0, FORCE_QUANT}, *******************
+{"l5", "lowpass5",              1, 1, 4, LOWPASS5_DEINT_FILTER}, *********
+*/
+
+
+
+class  ADMVideoLavPPDeint:public AVDMGenericVideoStream
+{
+
+  protected:
+    virtual char                    *printConf(void);
+    void                            *ppcontext;
+    void                            *ppmode;
+    ADMImage                        *uncompressed;
+    lavc_pp_param                   *_param;
+    
+    void                            setup( void );
+    void                            cleanup( void );
+  public:
+    
+    
+    ADMVideoLavPPDeint(  AVDMGenericVideoStream *in,CONFcouple *setup);
+    ~ADMVideoLavPPDeint();
+    virtual uint8_t getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
+                                          ADMImage *data,uint32_t *flags);
+    virtual uint8_t getCoupledConf( CONFcouple **couples)           ;
+    virtual uint8_t configure( AVDMGenericVideoStream *instream);
+                                                        
+};
+
+
+static FILTER_PARAM lavppdeint_param={2,{"deintType","autolevel"}};
+//*************************************************************
+//
+
+//*************************************************************
+SCRIPT_CREATE(lavppdeint_script,ADMVideoLavPPDeint,lavppdeint_param);
+BUILD_CREATE(lavppdeint_create,ADMVideoLavPPDeint);
+//*************************************************************
+uint8_t ADMVideoLavPPDeint::configure(AVDMGenericVideoStream *in)
+{
+
+  #define PX(x) &(_param->x)
+  _in=in;
+  
+  
+   diaMenuEntry menuField[6]={{PP_BM_NONE,        _("None"),NULL},
+                             {PP_BM_LINEAR_BLEND, _("Linear Blend"),NULL},
+                             {PP_BM_LINEAR_INTER, _("Linear Interpolate"),NULL},
+                             {PP_BM_CUBIC_INTER, _("Cubic Interpolate"),NULL},
+                             {PP_BM_MEDIAN_INTER, _("Median Interpolate"),NULL},
+                             {PP_BM_FFMPEG_DEINT, _("FFmpeg deint"),NULL},
+                          };
+  
+    
+    diaElemMenu     menu1(PX(deintType),_("Deinterlacing"), 6,menuField);
+    diaElemToggle   autolevel(PX(autolevel),_("Autolevel"));
+    
+    diaElem *elems[2]={&menu1,&autolevel};
+  
+   if(diaFactoryRun("Lavcodec deinterlacer",2,elems))
+  {
+    setup();
+    return 1; 
+  }
+  return 0;        
+}
+ 
+//*************************************************************
+char *ADMVideoLavPPDeint::printConf( void )
+{
+  static char buf[50];
+        
+  sprintf((char *)buf," Lavcodec PP deinterlacer autolev:%d deint:%d",_param->autolevel,_param->deintType);
+  return buf;
+}
+//*************************************************************
+ADMVideoLavPPDeint::ADMVideoLavPPDeint(  AVDMGenericVideoStream *in,CONFcouple *couples)
+{
+
+  _in=in;         
+  memcpy(&_info,_in->getInfo(),sizeof(_info));    
+  _info.encoding=1;  
+  
+  ppcontext=NULL;  
+  ppmode=NULL;   
+  
+  _uncompressed=new ADMImage(_info.width,_info.height);
+  if(couples)
+  {   
+    _param=NEW(lavc_pp_param);
+    GET(deintType);    
+    GET(autolevel);
+  }      
+  else
+  {
+    _param=NEW(lavc_pp_param);
+    _param->deintType=0;
+    _param->autolevel=0;
+    
+  } 
+                 
+  setup();
+ 
+}
+//*************************************************************
+void ADMVideoLavPPDeint::cleanup(void)
+{
+  if(ppcontext)
+  {
+    pp_free_context(ppcontext);
+    ppcontext=NULL;
+  }
+  if(ppmode)
+  {
+    pp_free_mode(ppmode);
+    ppmode=NULL;
+  }
+  
+} 
+//*************************************************************
+void ADMVideoLavPPDeint::setup(void)
+{
+  char string[1024];
+  uint32_t ppCaps=0;
+                
+  string[0]=0;
+  
+        cleanup();
+#if (defined( ARCH_X86)  || defined(ARCH_X86_64))
+#define ADD(x,y) if( CpuCaps::has##x()) ppCaps|=PP_CPU_CAPS_##y;                
+                ADD(MMX,MMX);           
+                ADD(3DNOW,3DNOW);
+                ADD(MMXEXT,MMX2);
+#endif             
+        cleanup();
+#undef ADD       
+#define ADD(z)  { if(string[0]) strcat(string,","#z); else strcpy(string,#z);}        
+               
+        if(_param->autolevel) ADD(al);
+        switch(_param->deintType)
+        {
+          case PP_BM_NONE:break;
+          case PP_BM_LINEAR_BLEND: ADD(lb);break;
+          case PP_BM_LINEAR_INTER: ADD(li);break;
+          case PP_BM_CUBIC_INTER: ADD(ci);break;
+          case PP_BM_MEDIAN_INTER: ADD(md);break;
+          case PP_BM_FFMPEG_DEINT: ADD(fd);break;                             
+        }        
+
+
+        ppcontext=pp_get_context(_info.width, _info.height, ppCaps);           
+        ppmode=pp_get_mode_by_name_and_quality(string,1);;
+        
+        ADM_assert(ppcontext);
+        ADM_assert(ppmode);
+  
+} 
+//*************************************************************
+ADMVideoLavPPDeint::~ADMVideoLavPPDeint()
+{
+  cleanup();
+  if(_uncompressed)
+        delete _uncompressed;
+  DELETE(_param);
+  _uncompressed=NULL;
+}
+
+//*************************************************************
+uint8_t ADMVideoLavPPDeint::getCoupledConf( CONFcouple **couples)
+{
+  
+  *couples=new CONFcouple(2);
+  CSET(deintType);    
+  CSET(autolevel);
+  
+  return 1;
+}
+//*************************************************************
+uint8_t ADMVideoLavPPDeint::getFrameNumberNoAlloc(uint32_t frame,
+                                              uint32_t *len,
+                                              ADMImage *data,
+                                              uint32_t *flags)
+{
+
+ 
+  ADM_assert(frame<_info.nb_frames);
+        // read uncompressed frame
+  if(!_in->getFrameNumberNoAlloc(frame, len,_uncompressed,flags)) return 0;
+
+  
+  //
+  uint8_t *iBuff[3],*oBuff[3];
+  int strideTab[3],strideTab2[3];                 
+                                                                
+  oBuff[0]=YPLANE(data);
+  oBuff[1]=UPLANE(data);
+  oBuff[2]=VPLANE(data);
+                                
+  iBuff[0]=YPLANE(_uncompressed);
+  iBuff[1]=UPLANE(_uncompressed);
+  iBuff[2]=VPLANE(_uncompressed);
+                                
+                                
+  strideTab[0]=strideTab2[0]=_info.width;
+  strideTab[1]=strideTab2[1]=_info.width>>1;
+  strideTab[2]=strideTab2[2]=_info.width>>1;
+        
+  int type;
+  if(_uncompressed->flags&AVI_KEY_FRAME)
+    type=1;
+  else if(_uncompressed->flags & AVI_B_FRAME)
+    type=3;
+  else
+    type=2;
+  pp_postprocess(
+        iBuff,
+        strideTab,
+        oBuff,
+        strideTab2,
+        _info.width,
+        _info.height,
+        NULL,
+        0,
+        ppmode,
+        ppcontext,
+        type); // I ?
+                                
+  
+  data->copyInfo(_uncompressed);
+  return 1;
+}

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_lavpp_deintparam.h (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_lavpp_deintparam.h)

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidKernelDeint.cpp (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidKernelDeint.cpp)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidKernelDeint.cpp	2006-10-31 15:59:58 UTC (rev 2489)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidKernelDeint.cpp	2007-01-11 19:18:08 UTC (rev 2704)
@@ -0,0 +1,461 @@
+/***************************************************************************
+                          ADM_vidKernelDeint  -  description
+                             -------------------
+ 			Port of another D Graft deinterlacer
+			http://neuron2.net/kerneldeint/kerneldeint.html
+     ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+
+/*
+	KernelDeint() plugin for Avisynth.
+
+	Copyright (C) 2003 Donald A. Graft
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program; if not, write to the Free Software
+	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ADM_assert.h>
+#include <math.h>
+#include <math.h>
+#include <iconv.h>
+#include "config.h"
+
+
+#include "fourcc.h"
+#include "avio.hxx"
+
+#include "avi_vars.h"
+
+#include "ADM_toolkit/toolkit.hxx"
+#include "ADM_editor/ADM_edit.hxx"
+#include "ADM_video/ADM_genvideo.hxx"
+
+#include "ADM_osSupport/ADM_debugID.h"
+#define MODULE_NAME MODULE_FILTER
+#include "ADM_osSupport/ADM_debug.h"
+#include "ADM_filter/video_filters.h"
+#include "ADM_vidKernelDeint.h"
+
+#include "ADM_userInterfaces/ADM_commonUI/DIA_factory.h"
+
+static FILTER_PARAM kdintParam={5,{"order","threshold","sharp","twoway","map"}};
+
+
+SCRIPT_CREATE(kerneldeint_script,ADMVideoKernelDeint,kdintParam);
+BUILD_CREATE(kerneldeint_create,ADMVideoKernelDeint);
+
+static int PutHintingData(uint8_t *video, unsigned int hint);
+static int GetHintingData(uint8_t *video, unsigned int *hint);
+
+// extern uint8_t DIA_kerneldeint(uint32_t *order, uint32_t *threshold, uint32_t *sharp, 
+// 		uint32_t *twoway, uint32_t *map);
+
+#define PROGRESSIVE  0x00000001
+
+
+
+
+
+uint8_t ADMVideoKernelDeint::configure( AVDMGenericVideoStream *instream)
+{
+  #define PX(x) &(_param->x)
+_in=instream;
+
+   diaMenuEntry menuField[2]={{1,_("Top"),NULL},
+                             {0,_("Bottom"),NULL}
+                          };
+  
+    
+    diaElemMenu     menu1(PX(order),_("Field Order"), 2,menuField);
+    diaElemUInteger threshold(PX(threshold),_("Threshold"),0,100,_("Smaller means more deinterlacing"));
+    diaElemToggle   sharp(PX(sharp),_("Sharp"),_("Sharper Engine"));
+    diaElemToggle   twoway(PX(twoway),_("Twoway"),_("Extrapolate better (better not to use it)"));
+    diaElemToggle   map(PX(map),_("Map"),_("Show interlaced areas (for test!)"));
+    
+    diaElem *elems[5]={&menu1,&threshold,&sharp,&twoway,&map};
+  
+   return  diaFactoryRun("Fade",5,elems);
+}
+uint8_t	ADMVideoKernelDeint::getCoupledConf( CONFcouple **couples)
+{
+
+			*couples=new CONFcouple(5);
+
+			CSET(order);
+			CSET(threshold);
+			CSET(sharp);
+			CSET(twoway);
+			CSET(map);	
+
+		return 1;	
+}
+char *ADMVideoKernelDeint::printConf( void )
+{
+ 	static char buf[50];
+ 	
+ 	sprintf((char *)buf," D Graft Kernel Deint");
+        return buf;
+}
+
+ADMVideoKernelDeint::~ADMVideoKernelDeint()
+{
+ if(vidCache) delete vidCache;
+ 	
+}
+
+
+ ADMVideoKernelDeint::ADMVideoKernelDeint( AVDMGenericVideoStream *in,CONFcouple *couples)
+{
+
+		if(!couples)
+		{
+			_param=NEW(KERNEL_CONF);
+	    		_param->order=1; // Bff=0 / 1=tff
+	    		_param->threshold=10;
+	    		_param->sharp=0;
+	    		_param->twoway=0;
+	    		_param->map=0;
+		}
+		else
+		{
+			_param=NEW(KERNEL_CONF);
+			GET(order);
+			GET(threshold);
+			GET(sharp);
+			GET(twoway);
+			GET(map);
+						
+		}
+	    debug=0;   
+	    _in=in;
+	    
+	   _uncompressed=NULL;
+
+  	memcpy(&_info,_in->getInfo(),sizeof(_info));
+	vidCache=new VideoCache(4,_in);
+
+
+}
+uint8_t ADMVideoKernelDeint::getFrameNumberNoAlloc(uint32_t frame,
+							uint32_t *len,
+							ADMImage *data,
+							uint32_t *flags)
+{
+		
+		uint32_t frame_prev;
+		uint32_t page=_info.width*_info.height;
+		ADMImage *mysrc=NULL, *myprev=NULL;
+		
+		if(frame>_info.nb_frames-1) return 0;
+
+
+		
+		frame_prev=frame;
+		if(frame_prev) frame_prev--;
+		
+		
+		
+			mysrc=vidCache->getImage(frame);
+			myprev=vidCache->getImage(frame_prev);
+			ADM_assert(mysrc);
+			ADM_assert(myprev);
+		// Now go to kernel deint code
+			
+    const uint8_t *srcp, *prvp,*prvp_saved, *prvpp, *prvpn, *prvppp, *prvpnn, *prvp4p, *prvp4n;
+	const uint8_t *srcp_saved;
+	const uint8_t *srcpp, *srcppp, *srcpn, *srcpnn, *srcp3p, *srcp3n, *srcp4p, *srcp4n;
+    uint8_t *dstp;
+	uint8_t *dstp_saved;
+ 
+	int plane;
+	int src_pitch;
+    int dst_pitch;
+    int w;
+    int h;
+	int x, y, z;
+	int val, hi, lo;
+	double valf;
+	unsigned int hint;
+	char buf[80];
+	
+	uint32_t pitch;
+	uint32_t offset;
+	
+	
+	uint32_t		order, threshold;
+	uint8_t			sharp, twoway, map;
+	
+	order=_param->order;
+	threshold=_param->threshold;
+	sharp=_param->sharp;
+	twoway=_param->twoway;
+	map=_param->map;
+	
+	
+	for (z = 0; z < 3; z++)
+	{
+		
+		pitch=_info.width;
+		switch(z)
+		{
+			case 0:		offset=0;
+					srcp=srcp_saved= YPLANE(mysrc);
+					dstp = dstp_saved=YPLANE(data);
+					prvp_saved=prvp=YPLANE(myprev);
+					break;
+			case 1:		offset=page;
+					pitch>>=1;
+					srcp=srcp_saved=UPLANE(mysrc);
+					dstp = dstp_saved=UPLANE(data);
+					prvp_saved=prvp=UPLANE(myprev);
+					break;
+			case 2:		offset=((page*5)>>2);
+					pitch>>=1;
+					srcp=srcp_saved=VPLANE(mysrc);
+					dstp = dstp_saved=VPLANE(data);
+					prvp_saved=prvp=VPLANE(myprev);
+					break;
+		
+		}
+		
+		if (z==0 && (GetHintingData((uint8_t *) srcp, &hint) == false) && (hint & PROGRESSIVE))
+		{
+			if (debug ==true)
+			{
+				printf( "KernelDeint: frame %d: progressive\n", frame); 
+				
+			}
+			memcpy(YPLANE(data),YPLANE(mysrc),page);
+			memcpy(UPLANE(data),UPLANE(mysrc),page>>2);
+			memcpy(VPLANE(data),VPLANE(mysrc),page>>2);
+			vidCache->unlockAll();
+			data->copyInfo(mysrc);
+			return 1;
+		}
+		else
+		{
+			if (debug == true)
+			{
+				printf( "KernelDeint: frame %d: interkaced\n", frame); 
+			}
+		}
+		
+		src_pitch = pitch;	
+		dst_pitch = pitch;
+		
+		w = pitch; //dst->GetRowSize(plane);
+		h=_info.height;
+		if(z) h>>=1;  //h = dst->GetHeight(plane);
+		
+		srcp = srcp_saved  + (1-order) * src_pitch;
+		dstp = dstp_saved  + (1-order) * dst_pitch;
+		for (y = 0; y < h; y+=2)
+		{
+			memcpy(dstp, srcp, w);
+			srcp += 2*src_pitch;
+			dstp += 2*dst_pitch;
+		}
+
+		// Copy through the lines that will be missed below.
+		memcpy(dstp_saved + order*dst_pitch, srcp_saved + (1-order)*src_pitch, w);
+		memcpy(dstp_saved + (2+order)*dst_pitch, srcp_saved + (3-order)*src_pitch, w);
+		memcpy(dstp_saved + (h-2+order)*dst_pitch, srcp_saved + (h-1-order)*src_pitch, w);
+		memcpy(dstp_saved + (h-4+order)*dst_pitch, srcp_saved + (h-3-order)*src_pitch, w);
+		/* For the other field choose adaptively between using the previous field
+		   or the interpolant from the current field. */
+		//prvp = prv->GetReadPtr(plane) + 5*src_pitch - (1-order)*src_pitch;
+		prvp = prvp_saved + 5*src_pitch - (1-order)*src_pitch;
+		
+		
+		prvpp = prvp - src_pitch;
+		prvppp = prvp - 2*src_pitch;
+		prvp4p = prvp - 4*src_pitch;
+		prvpn = prvp + src_pitch;
+		prvpnn = prvp + 2*src_pitch;
+		prvp4n = prvp + 4*src_pitch;
+		srcp = srcp_saved + 5*src_pitch - (1-order)*src_pitch;
+		srcpp = srcp - src_pitch;
+		srcppp = srcp - 2*src_pitch;
+		srcp3p = srcp - 3*src_pitch;
+		srcp4p = srcp - 4*src_pitch;
+		srcpn = srcp + src_pitch;
+		srcpnn = srcp + 2*src_pitch;
+		srcp3n = srcp + 3*src_pitch;
+		srcp4n = srcp + 4*src_pitch;
+		dstp =  dstp_saved  + 5*dst_pitch - (1-order)*dst_pitch;
+		for (y = 5 - (1-order); y <= h - 5 - (1-order); y+=2)
+		{
+			for (x = 0; x < w; x++)
+			{
+				if ((threshold == 0) || (frame == 0) ||
+					(abs((int)prvp[x] - (int)srcp[x]) > threshold) ||
+					(abs((int)prvpp[x] - (int)srcpp[x]) > threshold) ||
+					(abs((int)prvpn[x] - (int)srcpn[x]) > threshold))
+				{
+					if (map == true)
+					{
+						int g = x & ~3;
+						
+						{
+							if (z == 0) dstp[x] = 235;
+							else dstp[x] = 128;
+						}
+					}
+					else
+					{
+						
+						{
+							hi = (z == 0) ? 235 : 240;
+							lo = 16;
+						}
+						
+						if (sharp == true)
+						{
+							if (twoway == true)
+								valf = + 0.526*((int)srcpp[x] +
+								 (int)srcpn[x])
+								   + 0.170*((int)srcp[x] + (int)prvp[x])
+								   - 0.116*((int)srcppp[x] +
+								    (int)srcpnn[x] + (int)prvppp[x] +
+								    (int)prvpnn[x])
+					 			   - 0.026*((int)srcp3p[x] +
+								    (int)srcp3n[x])
+								   + 0.031*((int)srcp4p[x] +
+								    (int)srcp4n[x] + (int)prvp4p[x] +
+								    (int)prvp4n[x]);
+							else
+								valf = + 0.526*((int)srcpp[x] +
+								 (int)srcpn[x])
+								   + 0.170*((int)prvp[x])
+								   - 0.116*((int)prvppp[x] +
+								    (int)prvpnn[x])
+					 			   - 0.026*((int)srcp3p[x] +
+								    (int)srcp3n[x])
+								   + 0.031*((int)prvp4p[x] +
+								    (int)prvp4p[x]);
+							if (valf > hi) valf = hi;
+							else if (valf < lo) valf = lo;
+							dstp[x] = (int) valf;
+						}
+						else
+						{
+							if (twoway == true)
+								val = (8*((int)srcpp[x] + (int)srcpn[x]) +
+								 2*((int)srcp[x] + (int)prvp[x]) -
+								 			 
+									(int)(srcppp[x]) -
+									 (int)(srcpnn[x]) -
+									(int)(prvppp[x]) -
+									 (int)(prvpnn[x])) >> 4;
+							else
+								val = (8*((int)srcpp[x] + (int)srcpn[x]) +
+								 2*((int)prvp[x]) -
+									(int)(prvppp[x]) -
+									 (int)(prvpnn[x])) >> 4;
+							if (val > hi) val = hi;
+							else if (val < lo) val = lo;
+							dstp[x] = (int) val;
+						}
+					}
+				}
+				else
+				{
+					dstp[x] = srcp[x];
+				}
+			}
+			prvp  += 2*src_pitch;
+			prvpp  += 2*src_pitch;
+			prvppp  += 2*src_pitch;
+			prvpn  += 2*src_pitch;
+			prvpnn  += 2*src_pitch;
+			prvp4p  += 2*src_pitch;
+			prvp4n  += 2*src_pitch;
+			srcp  += 2*src_pitch;
+			srcpp += 2*src_pitch;
+			srcppp += 2*src_pitch;
+			srcp3p += 2*src_pitch;
+			srcp4p += 2*src_pitch;
+			srcpn += 2*src_pitch;
+			srcpnn += 2*src_pitch;
+			srcp3n += 2*src_pitch;
+			srcp4n += 2*src_pitch;
+			dstp  += 2*dst_pitch;
+		}
+	}
+	data->copyInfo(mysrc);
+	vidCache->unlockAll();
+	return 1;
+}
+
+
+
+#define MAGIC_NUMBER (0xdeadbeef)
+
+int PutHintingData(uint8_t *video, unsigned int hint)
+{
+	uint8_t *p;
+	unsigned int i, magic_number = MAGIC_NUMBER;
+	int error = false;
+
+	p = video;
+	for (i = 0; i < 32; i++)
+	{
+		*p &= ~1; 
+		*p++ |= ((magic_number & (1 << i)) >> i);
+	}
+	for (i = 0; i < 32; i++)
+	{
+		*p &= ~1;
+		*p++ |= ((hint & (1 << i)) >> i);
+	}
+	return error;
+}
+
+int GetHintingData(uint8_t *video, unsigned int *hint)
+{
+	uint8_t *p;
+	unsigned int i, magic_number = 0;
+	int error = false;
+
+	p = video;
+	for (i = 0; i < 32; i++)
+	{
+		magic_number |= ((*p++ & 1) << i);
+	}
+	if (magic_number != MAGIC_NUMBER)
+	{
+		error = true;
+	}
+	else
+	{
+		*hint = 0;
+		for (i = 0; i < 32; i++)
+		{
+			*hint |= ((*p++ & 1) << i);
+		}
+	}
+	return error;
+}

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidKernelDeint.h (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidKernelDeint.h)

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMPLD3D.cpp (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMPLD3D.cpp)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMPLD3D.cpp	2006-10-31 15:59:58 UTC (rev 2489)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMPLD3D.cpp	2007-01-11 19:18:08 UTC (rev 2704)
@@ -0,0 +1,364 @@
+/***************************************************************************
+                          ADM_vidMPLD3D.cpp  -  description
+                             -------------------
+Mplayer HQDenoise3d port to avidemux2
+Original Authors
+Copyright (C) 2003
+Daniel Moreno <comac at comac.darktech.org>
+	& A'rpi
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ADM_assert.h>
+#include <math.h>
+
+#include "config.h"
+#include "fourcc.h"
+#include "avio.hxx"
+#include "config.h"
+#include "avi_vars.h"
+
+#include "ADM_toolkit/toolkit.hxx"
+#include "ADM_editor/ADM_edit.hxx"
+#include "ADM_video/ADM_genvideo.hxx"
+#include "ADM_video/ADM_vidMPLD3D.h"
+
+#include "ADM_osSupport/ADM_debugID.h"
+#define MODULE_NAME MODULE_FILTER
+#include "ADM_osSupport/ADM_debug.h"
+#include "ADM_filter/video_filters.h"
+
+#include "ADM_userInterfaces/ADM_commonUI/DIA_factory.h"
+static FILTER_PARAM mp3Param={3,{"param1","param2","param3"}};
+
+
+SCRIPT_CREATE(MPD3D_script,ADMVideoMPD3D,mp3Param);
+
+BUILD_CREATE(MPD3D_create,ADMVideoMPD3D);
+
+#define PARAM1_DEFAULT 4.0
+#define PARAM2_DEFAULT 3.0
+#define PARAM3_DEFAULT 6.0
+uint8_t DIA_d3d(double *luma,double *chroma,double *temporal);
+ char 	*ADMVideoMPD3D::printConf(void)
+ {
+	  	static char buf[50];
+
+ 				sprintf((char *)buf," MPlayer HQ Denoise 3D (%2.1f - %2.1f - %2.1f)'",
+						_param->param1,_param->param2,_param->param3);
+        return buf;
+}
+
+uint8_t ADMVideoMPD3D::configure(AVDMGenericVideoStream *instream)
+{
+
+        _in=instream;
+        ELEM_TYPE_FLOAT fluma,fchroma,ftemporal;
+#define PX(x) &x
+#define OOP(x,y) f##x=(ELEM_TYPE_FLOAT )_param->y;
+        
+        OOP(luma,param1);
+        OOP(chroma,param2);
+        OOP(temporal,param3);
+        
+    diaElemFloat   luma(PX(fluma),_("Luma Spatial Threshold"),0.,100.);
+    diaElemFloat   chroma(PX(fchroma),_("Chroma Spatial Threshold"),0.,100.);
+    diaElemFloat   temporal(PX(ftemporal),_("Temporal Threshold"),0.,100.);
+    
+       diaElem *elems[3]={&luma,&chroma,&temporal};
+  
+   if(  diaFactoryRun("MPlayer D3D",3,elems))
+        {
+#undef OOP
+#define OOP(x,y) _param->y=(double) f##x
+                OOP(luma,param1);
+                OOP(chroma,param2);
+                OOP(temporal,param3);
+          
+                setup();
+                return 1;
+        }
+        return 0;}
+ADMVideoMPD3D::~ADMVideoMPD3D()
+{
+
+ 	DELETE(_param);
+	if(_uncompressed)
+		delete [] _uncompressed;
+	if(Line)
+		delete [] Line;
+	if(_storage)
+		delete  _storage;
+
+	_storage=NULL;
+	Line=NULL;
+	_uncompressed=NULL;
+}
+
+static inline unsigned int LowPassMul(unsigned int PrevMul, unsigned int CurrMul, int* Coef){
+//    int dMul= (PrevMul&0xFFFFFF)-(CurrMul&0xFFFFFF);
+    int dMul= PrevMul-CurrMul;
+    int d=((dMul+0x10007FF)/(65536/16));
+    return CurrMul + Coef[d];
+}
+
+void ADMVideoMPD3D::deNoise(unsigned char *Frame,        // mpi->planes[x]
+                    unsigned char *FrameDest,    // dmpi->planes[x]
+                   uint32_t 		 *LineAnt,      // vf->priv->Line (width bytes)
+		    unsigned short 	*FrameAntPtr,
+                    int W, int H, int sStride, int dStride,
+                    int *Horizontal, int *Vertical, int *Temporal)
+{
+    int X, Y;
+    int sLineOffs = 0, dLineOffs = 0;
+    unsigned int PixelAnt;
+    int PixelDst;
+    unsigned short* FrameAnt=(FrameAntPtr);
+    
+
+    /* First pixel has no left nor top neightbour. Only previous frame */
+    LineAnt[0] = PixelAnt = Frame[0]<<16;
+    PixelDst = LowPassMul(FrameAnt[0]<<8, PixelAnt, Temporal);
+    FrameAnt[0] = ((PixelDst+0x1000007F)/256);
+    FrameDest[0]= ((PixelDst+0x10007FFF)/65536);
+
+    /* Fist line has no top neightbour. Only left one for each pixel and
+     * last frame */
+    for (X = 1; X < W; X++){
+        LineAnt[X] = PixelAnt = LowPassMul(PixelAnt, Frame[X]<<16, Horizontal);
+        PixelDst = LowPassMul(FrameAnt[X]<<8, PixelAnt, Temporal);
+	FrameAnt[X] = ((PixelDst+0x1000007F)/256);
+	FrameDest[X]= ((PixelDst+0x10007FFF)/65536);
+    }
+
+    for (Y = 1; Y < H; Y++){
+	unsigned int PixelAnt;
+	unsigned short* LinePrev=&FrameAnt[Y*W];
+	sLineOffs += sStride, dLineOffs += dStride;
+        /* First pixel on each line doesn't have previous pixel */
+        PixelAnt = Frame[sLineOffs]<<16;
+        LineAnt[0] = LowPassMul(LineAnt[0], PixelAnt, Vertical);
+	PixelDst = LowPassMul(LinePrev[0]<<8, LineAnt[0], Temporal);
+	LinePrev[0] = ((PixelDst+0x1000007F)/256);
+	FrameDest[dLineOffs]= ((PixelDst+0x10007FFF)/65536);
+
+        for (X = 1; X < W; X++){
+	    int PixelDst;
+            /* The rest are normal */
+            PixelAnt = LowPassMul(PixelAnt, Frame[sLineOffs+X]<<16, Horizontal);
+            LineAnt[X] = LowPassMul(LineAnt[X], PixelAnt, Vertical);
+	    PixelDst = LowPassMul(LinePrev[X]<<8, LineAnt[X], Temporal);
+	    LinePrev[X] = ((PixelDst+0x1000007F)/256);
+	    FrameDest[dLineOffs+X]= ((PixelDst+0x10007FFF)/65536);
+        }
+    }
+}
+
+
+uint8_t  ADMVideoMPD3D::setup(void)
+{
+ double LumSpac, LumTmp, ChromSpac, ChromTmp;
+
+        LumSpac = _param->param1;
+        LumTmp = _param->param3;
+
+        ChromSpac = _param->param2;
+        ChromTmp = LumTmp * ChromSpac / LumSpac;
+
+        PrecalcCoefs((int *)Coefs[0], LumSpac);
+        PrecalcCoefs((int *)Coefs[1], LumTmp);
+        PrecalcCoefs((int *)Coefs[2], ChromSpac);
+        PrecalcCoefs((int *)Coefs[3], ChromTmp);
+
+	aprintf("\n Param : %lf %lf %lf \n",
+		_param->param1,
+		_param->param2,
+		_param->param3);
+
+	return 1;
+}
+//--------------------------------------------------------
+ADMVideoMPD3D::ADMVideoMPD3D(AVDMGenericVideoStream *in,CONFcouple *couples)
+
+{
+  //uint32_t frame;
+  _storage=NULL;
+  _uncompressed=NULL;
+  Line=NULL;
+
+  _in=in;
+
+  Line=new uint32_t[in->getInfo()->width];
+  memcpy(&_info,in->getInfo(),sizeof(_info));
+  _info.encoding=1;
+  if(couples)
+  {
+			_param=NEW(MPD3D_PARAM);
+			GET(param1);
+			GET(param2);
+			GET(param3);
+	}
+	else
+	{
+			_param=NEW( MPD3D_PARAM);
+			_param->param1=PARAM1_DEFAULT;
+			_param->param2=PARAM2_DEFAULT;
+			_param->param3=PARAM3_DEFAULT;
+	}
+	_uncompressed=new uint16_t[(_info.width*_info.height*3)>>1];
+	_storage=new ADMImage(_info.width,_info.height);
+	setup();
+
+	_last=0xFFFFFFF;
+}
+
+
+uint8_t	ADMVideoMPD3D::getCoupledConf( CONFcouple **couples)
+{
+
+			ADM_assert(_param);
+			*couples=new CONFcouple(3);
+ 			//(*couples)->setCouple((char *)"param",*_param);
+#define CSET(x)  (*couples)->setCouple((char *)#x,(_param->x))
+			CSET(param1);
+			CSET(param2);
+			CSET(param3);
+			return 1;
+
+}
+//                     1
+//		Get in range in 121 + coeff matrix
+//                     1
+//
+// If the value is too far away we ignore it
+// else we blend
+
+uint8_t ADMVideoMPD3D::getFrameNumberNoAlloc(uint32_t frame,
+				uint32_t *len,
+   				ADMImage *data,
+				uint32_t *flags)
+{
+UNUSED_ARG(flags);
+
+	int cw= _info.width>>1;
+	int ch= _info.height>>1;
+        int W = _info.width;
+	int H  = _info.height;
+	uint32_t dlen,dflags;
+
+  		if(frame> _info.nb_frames-1) return 0;
+		*len=(W*H*3)>>1;
+		// First and last frame we don"t modify.
+		if(!frame || (frame!=_last+1))
+			{
+					 if(!_in->getFrameNumberNoAlloc(frame, &dlen,data,&dflags))
+					 {
+					 	return 0;
+					}
+				 	unsigned short* dst=_uncompressed;
+	    				unsigned char* src=YPLANE(data);
+					for (int Y = 0; Y < W*H; Y++)
+						{
+	    						 	*(dst++)=*(src++)<<8;
+						}
+					src=UPLANE(data);
+					dst=_uncompressed+(W*H);
+					for (int Y = 0; Y < (W*H)>>2; Y++)
+						{
+	    						 	*(dst++)=*(src++)<<8;
+						}
+					src=VPLANE(data);
+					dst=_uncompressed+((5*W*H)>>2);
+					for (int Y = 0; Y < (W*H)>>2; Y++)
+						{
+	    						 	*(dst++)=*(src++)<<8;
+						}
+					
+					_last=frame;
+					return 1;
+
+			}
+		ADM_assert(frame<_info.nb_frames);
+		// read uncompressed frame
+		// else we fill previous/current/next
+		if(!_in->getFrameNumberNoAlloc(frame, &dlen,_storage,&dflags))
+		{
+			return 0;
+		}
+
+		uint8_t *c,*n;
+		unsigned short *ant;
+
+		ant=(_uncompressed);
+		n=YPLANE(data);
+		c=YPLANE(_storage);
+//
+   		deNoise(c, n,
+			Line,ant, W, H,
+                	W,W,
+                	(int *)Coefs[0],
+                	(int *)Coefs[0],
+                	(int *)Coefs[1]);
+
+
+		ant=(_uncompressed)+W*H;
+		n=UPLANE(data);
+		c=UPLANE(_storage);
+
+		deNoise(c, n,
+			Line, ant, cw, ch,
+                	cw,cw,
+                	(int *)Coefs[2],
+                	(int *)Coefs[2],
+                	(int *)Coefs[3]);
+
+
+		ant=_uncompressed+((W*H*5)>>2);
+		n=VPLANE(data);
+		c=VPLANE(_storage);
+
+		deNoise(c, n,
+			Line, ant, cw, ch,
+                	cw,cw,
+                	(int *)Coefs[2],
+                	(int *)Coefs[2],
+                	(int *)Coefs[3]);
+
+	// n is out....
+	_last=frame;
+	data->copyInfo(_storage);
+	return 1;
+
+
+}
+
+#define ABS(A) ( (A) > 0 ? (A) : -(A) )
+
+void ADMVideoMPD3D::PrecalcCoefs(int *Ct, double Dist25)
+{
+    int i;
+    double Gamma, Simil, C;
+
+    Gamma = log(0.25) / log(1.0 - Dist25/255.0 - 0.00001);
+
+    for (i = -256*16; i < 256*16; i++)
+    {
+        Simil = 1.0 - ABS(i) / (16*255.0);
+	C=4096.*(double)i;
+        C *= pow(Simil, Gamma) ;
+       Ct[16*256+i] = (int)((C<0) ? (C-0.5) : (C+0.5));
+    }
+
+}
+
+

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMPLD3D.h (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMPLD3D.h)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMPLD3D.h	2006-10-31 15:59:58 UTC (rev 2489)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMPLD3D.h	2007-01-11 19:18:08 UTC (rev 2704)
@@ -0,0 +1,69 @@
+/***************************************************************************
+                          ADM_vidMPLD3D.h  -  description
+                             -------------------
+Mplayer HQDenoise3d port to avidemux2
+Original Authors
+Copyright (C) 2003
+Daniel Moreno <comac at comac.darktech.org>
+	& A'rpi
+
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+ 
+#ifndef _D3D__
+#define _D3D__   
+#include "ADM_video/ADM_vidCached.h"
+typedef struct MPD3D_PARAM
+{
+	double  param1;  // Luma 
+	double  param2;  // Chroma
+	double  param3;  // Temporal
+}MPD3D_PARAM;
+
+class  ADMVideoMPD3D:public AVDMGenericVideoStream
+ {
+
+ protected:
+
+        			MPD3D_PARAM			*_param;
+
+				int	  					Coefs[4][512*16];
+        			uint32_t					*Line;
+
+				uint16_t				*_uncompressed;
+				ADMImage				*_storage;
+				uint32_t				_last;
+
+				void 	PrecalcCoefs(int *Ct, double Dist25);
+				uint8_t  	setup(void);
+				void 	deNoise(unsigned char *Frame,        // mpi->planes[x]
+                    					unsigned char *FrameDest,    // dmpi->planes[x]
+                    					uint32_t *LineAnt,      // vf->priv->Line (width bytes)
+		    					unsigned short *FrameAntPtr,
+                    					int W, int H, int sStride, int dStride,
+                    					int *Horizontal, int *Vertical, int *Temporal);
+
+
+
+ public:
+
+
+						ADMVideoMPD3D(  AVDMGenericVideoStream *in,CONFcouple *setup);
+  						 ~ADMVideoMPD3D();
+		        virtual uint8_t 	getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
+   								ADMImage *data,uint32_t *flags);
+
+			virtual uint8_t 	configure( AVDMGenericVideoStream *instream);
+     			virtual char 	*printConf(void);
+			virtual uint8_t 	getCoupledConf( CONFcouple **couples);
+							
+ }     ;
+#endif

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMPLD3Dlow.cpp (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMPLD3Dlow.cpp)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMPLD3Dlow.cpp	2006-10-31 15:59:58 UTC (rev 2489)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMPLD3Dlow.cpp	2007-01-11 19:18:08 UTC (rev 2704)
@@ -0,0 +1,347 @@
+/***************************************************************************
+                          ADM_vidMPLD3D.cpp  -  description
+                             -------------------
+Mplayer HQDenoise3d port to avidemux2
+Original Authors
+Copyright (C) 2003
+Daniel Moreno <comac at comac.darktech.org>
+	& A'rpi
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ADM_assert.h>
+#include <math.h>
+
+#include "config.h"
+#include "fourcc.h"
+#include "avio.hxx"
+#include "config.h"
+#include "avi_vars.h"
+
+#include "ADM_toolkit/toolkit.hxx"
+#include "ADM_editor/ADM_edit.hxx"
+#include "ADM_video/ADM_genvideo.hxx"
+#include "ADM_vidMPLD3Dlow.h"
+
+#include "ADM_osSupport/ADM_debugID.h"
+#define MODULE_NAME MODULE_FILTER
+#include "ADM_osSupport/ADM_debug.h"
+#include "ADM_filter/video_filters.h"
+
+#include "ADM_userInterfaces/ADM_commonUI/DIA_factory.h"
+
+static FILTER_PARAM mp3Param={3,{"param1","param2","param3"}};
+
+
+SCRIPT_CREATE(MPD3Dlow_script,ADMVideoMPD3Dlow,mp3Param);
+BUILD_CREATE(MPD3Dlow_create,ADMVideoMPD3Dlow);
+
+#define PARAM1_DEFAULT 4.0
+#define PARAM2_DEFAULT 3.0
+#define PARAM3_DEFAULT 6.0
+
+ char 	*ADMVideoMPD3Dlow::printConf(void)
+ {
+	  	static char buf[50];
+
+ 				sprintf((char *)buf," MPlayer Denoise 3D (%2.1f - %2.1f - %2.1f)'",
+						_param->param1,_param->param2,_param->param3);
+        return buf;
+}
+
+uint8_t ADMVideoMPD3Dlow::configure(AVDMGenericVideoStream *instream)
+{
+
+        _in=instream;
+        ELEM_TYPE_FLOAT fluma,fchroma,ftemporal;
+#define PX(x) &x
+#define OOP(x,y) f##x=(ELEM_TYPE_FLOAT )_param->y;
+        
+        OOP(luma,param1);
+        OOP(chroma,param2);
+        OOP(temporal,param3);
+        
+    diaElemFloat   luma(PX(fluma),_("Luma Spatial Threshold"),0.,100.);
+    diaElemFloat   chroma(PX(fchroma),_("Chroma Spatial Threshold"),0.,100.);
+    diaElemFloat   temporal(PX(ftemporal),_("Temporal Threshold"),0.,100.);
+    
+       diaElem *elems[3]={&luma,&chroma,&temporal};
+  
+   if(  diaFactoryRun("MPlayer D3D",3,elems))
+        {
+#undef OOP
+#define OOP(x,y) _param->y=(double) f##x
+                OOP(luma,param1);
+                OOP(chroma,param2);
+                OOP(temporal,param3);
+          
+                setup();
+                return 1;
+        }
+        return 0;
+}
+ADMVideoMPD3Dlow::~ADMVideoMPD3Dlow()
+{
+
+ 	DELETE(_param);
+	delete  _uncompressed;
+	delete  _stored;
+	delete [] Line;
+	Line=NULL;
+	_param=NULL;
+	_uncompressed=NULL;
+	_stored=NULL;
+}
+
+
+#define LowPass(Prev, Curr, Coef) (Curr + Coef[Prev - Curr])
+
+
+void ADMVideoMPD3Dlow::deNoise(unsigned char *Frame,        // mpi->planes[x]
+                    unsigned char *FramePrev,    // pmpi->planes[x]
+                    unsigned char *FrameDest,    // dmpi->planes[x]
+                    unsigned char *LineAnt,      // vf->priv->Line (width bytes)
+                    int W, int H, int sStride, int pStride, int dStride,
+                    int *Horizontal, int *Vertical, int *Temporal)
+{
+    int X, Y;
+    int sLineOffs = 0, pLineOffs = 0, dLineOffs = 0;
+    unsigned char PixelAnt;
+
+    /* First pixel has no left nor top neightbour. Only previous frame */
+    LineAnt[0] = PixelAnt = Frame[0];
+    FrameDest[0] = LowPass(FramePrev[0], LineAnt[0], Temporal);
+
+    /* Fist line has no top neightbour. Only left one for each pixel and
+     * last frame */
+    for (X = 1; X < W; X++)
+    {
+        PixelAnt = LowPass(PixelAnt, Frame[X], Horizontal);
+        LineAnt[X] = PixelAnt;
+        FrameDest[X] = LowPass(FramePrev[X], LineAnt[X], Temporal);
+    }
+
+    for (Y = 1; Y < H; Y++)
+    {
+	sLineOffs += sStride, pLineOffs += pStride, dLineOffs += dStride;
+        /* First pixel on each line doesn't have previous pixel */
+        PixelAnt = Frame[sLineOffs];
+        LineAnt[0] = LowPass(LineAnt[0], PixelAnt, Vertical);
+        FrameDest[dLineOffs] = LowPass(FramePrev[pLineOffs], LineAnt[0], Temporal);
+
+        for (X = 1; X < W; X++)
+        {
+            /* The rest are normal */
+            PixelAnt = LowPass(PixelAnt, Frame[sLineOffs+X], Horizontal);
+            LineAnt[X] = LowPass(LineAnt[X], PixelAnt, Vertical);
+            FrameDest[dLineOffs+X] = LowPass(FramePrev[pLineOffs+X], LineAnt[X], Temporal);
+        }
+    }
+}
+
+
+
+uint8_t  ADMVideoMPD3Dlow::setup(void)
+{
+ double LumSpac, LumTmp, ChromSpac, ChromTmp;
+
+        LumSpac = _param->param1;
+        LumTmp = _param->param3;
+
+        ChromSpac = _param->param2;
+        ChromTmp = LumTmp * ChromSpac / LumSpac;
+
+        PrecalcCoefs((int *)Coefs[0], LumSpac);
+        PrecalcCoefs((int *)Coefs[1], LumTmp);
+        PrecalcCoefs((int *)Coefs[2], ChromSpac);
+        PrecalcCoefs((int *)Coefs[3], ChromTmp);
+
+	aprintf("\n Param : %lf %lf %lf \n",
+		_param->param1,
+		_param->param2,
+		_param->param3);
+
+	_last=0xFFFFFFF;
+
+	return 1;
+}
+//--------------------------------------------------------
+ADMVideoMPD3Dlow::ADMVideoMPD3Dlow(
+									AVDMGenericVideoStream *in,CONFcouple *couples)
+
+{
+uint32_t page;
+
+  Line=new uint8_t [in->getInfo()->width];
+  memcpy(&_info,in->getInfo(),sizeof(_info));
+
+	page=_info.width*_info.height;
+
+ // _stored=new uint8_t[(page*3)>>1];
+ // _uncompressed=new uint8_t[ (page*3)>>1];
+ 	_stored=new ADMImage(_info.width,_info.height);
+	_uncompressed=new ADMImage(_info.width,_info.height);
+
+  _info.encoding=1;
+  _in=in;
+  if(couples)
+  {
+			_param=NEW(MPD3D_PARAM);
+			GET(param1);
+			GET(param2);
+			GET(param3);
+	}
+	else
+	{
+			_param=NEW( MPD3D_PARAM);
+			_param->param1=PARAM1_DEFAULT;
+			_param->param2=PARAM2_DEFAULT;
+			_param->param3=PARAM3_DEFAULT;
+	}
+	setup();
+
+}
+
+
+uint8_t	ADMVideoMPD3Dlow::getCoupledConf( CONFcouple **couples)
+{
+
+			ADM_assert(_param);
+			*couples=new CONFcouple(3);
+ 			//(*couples)->setCouple((char *)"param",*_param);
+#define CSET(x)  (*couples)->setCouple((char *)#x,(_param->x))
+			CSET(param1);
+			CSET(param2);
+			CSET(param3);
+			return 1;
+
+}
+//                     1
+//		Get in range in 121 + coeff matrix
+//                     1
+//
+// If the value is too far away we ignore it
+// else we blend
+
+uint8_t ADMVideoMPD3Dlow::getFrameNumberNoAlloc(uint32_t frame,
+				uint32_t *len,
+   				ADMImage *data,
+				uint32_t *flags)
+{
+UNUSED_ARG(flags);
+
+	int cw= _info.width>>1;
+	int ch= _info.height>>1;
+        int W = _info.width;
+	int H  = _info.height;
+	uint32_t dlen,dflags;
+
+  		if(frame> _info.nb_frames-1) return 0;
+		*len=(W*H*3)>>1;
+		// First and last frame we don"t modify.
+		if(!frame || (frame!=_last+1))
+			{
+				aprintf("D3D: First /last frame\n");
+				 if(!_in->getFrameNumberNoAlloc(frame, &dlen,data,&dflags))
+				 {
+					 	return 0;
+				 }
+				// store for future use
+				memcpy(_stored->data,data->data,*len);
+				_last=frame;
+				
+				return 1;
+			}
+			ADM_assert(frame<_info.nb_frames);
+			aprintf("D3D: next frame\n");
+			// read uncompressed frame
+	 		if(!_in->getFrameNumberNoAlloc(frame, &dlen,_uncompressed,&dflags))
+				 {
+					 	return 0;
+				 }
+
+		uint8_t *c,*d,*p;
+
+		d=YPLANE(data);
+		c=YPLANE(_uncompressed);
+		p=YPLANE(_stored);
+//
+
+   	deNoise(c,p, d,
+		Line, W, H,
+                W,W,W,
+               	Coefs[0] + 256,
+                Coefs[0] + 256,
+                Coefs[1] + 256);
+
+	uint32_t page=W*H;
+		d=UPLANE(data);
+		c=UPLANE(_uncompressed);
+		p=UPLANE(_stored);
+
+	deNoise(c,p, d,
+		Line, cw, ch,
+                cw,cw,cw,
+               	Coefs[2] + 256,
+                Coefs[2] + 256,
+                Coefs[3] + 256);
+
+	page=page>>2;		
+		d=VPLANE(data);
+		c=VPLANE(_uncompressed);
+		p=VPLANE(_stored);
+
+	deNoise(c,p, d,
+		Line, cw, ch,
+                cw,cw,cw,
+               	Coefs[2] + 256,
+              	Coefs[2] + 256,
+                Coefs[3] + 256);
+
+
+	_last=frame;
+	memcpy(YPLANE(_stored),YPLANE(data),W*H);
+	memcpy(UPLANE(_stored),UPLANE(data),(W*H)>>2);
+	memcpy(VPLANE(_stored),VPLANE(data),(W*H)>>2);
+	data->copyInfo(_uncompressed);
+	return 1;
+
+
+}
+
+#define ABS(A) ( (A) > 0 ? (A) : -(A) )
+
+void ADMVideoMPD3Dlow::PrecalcCoefs(int *Ct, double Dist25)
+{
+ int i;
+    double Gamma, Simil, C;
+    double d;
+    Gamma = log(0.25) / log(1.0 - Dist25/255.0);
+
+    for (i = -256; i <= 255; i++)
+    {
+    	if(i>0) d=(double)i/255.;
+		else d=(double)-i/255.;
+        Simil = 1.0 - d;
+//        Ct[256+i] = lround(pow(Simil, Gamma) * (double)i);
+ 	C= (double)i;
+        C *= pow(Simil, Gamma);
+
+  	Ct[256+i] = (int)((C<0) ? (C-0.5) : (C+0.5));
+
+    }
+
+
+}
+
+

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMPLD3Dlow.h (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMPLD3Dlow.h)

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am	2007-01-11 08:07:07 UTC (rev 2703)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am	2007-01-11 19:18:08 UTC (rev 2704)
@@ -7,6 +7,10 @@
 #INCLUDES = $(all_includes) 
 
 libADM_videoFilter_a_SOURCES =  \
+ ADM_vidMPLD3D.cpp \
+ ADM_vidMPLD3Dlow.cpp \
+ ADM_lavpp_deint.cpp \
+ ADM_vidKernelDeint.cpp \
  ADM_vidMcDeint.cpp \
  ADM_vidFade.cpp \
  ADM_vidResampleFPS.cpp \



From mean at mail.berlios.de  Thu Jan 11 21:41:20 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 11 Jan 2007 21:41:20 +0100
Subject: [Avidemux-svn-commit] r2705 - in
	branches/avidemux_2.4_branch/avidemux:
	ADM_userInterfaces/ADM_GTK/ADM_dialog
	ADM_userInterfaces/ADM_NONE/ADM_dialog
	ADM_userInterfaces/ADM_QT4/ADM_dialog ADM_video ADM_videoFilter
Message-ID: <200701112041.l0BKfKgj003752@sheep.berlios.de>

Author: mean
Date: 2007-01-11 21:41:19 +0100 (Thu, 11 Jan 2007)
New Revision: 2705

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDenoise.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDenoise.h
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidForcedPP.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidForcedPP.h
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMSharpen.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMSharpen_param.h
Removed:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_dnr.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_msharpen.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDenoise.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDenoise.h
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidForcedPP.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidForcedPP.h
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMSharpen.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMSharpen_param.h
Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am
Log:
more dialogFactory

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_dnr.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_dnr.cpp	2007-01-11 19:18:08 UTC (rev 2704)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_dnr.cpp	2007-01-11 20:41:19 UTC (rev 2705)
@@ -1,211 +0,0 @@
-
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <unistd.h>
-#include <string.h>
-#include <stdio.h>
-
-#include <gdk/gdkkeysyms.h>
-#include <gtk/gtk.h>
-
-
-#include <gdk/gdkkeysyms.h>
-#include <gtk/gtk.h>
-# include <config.h>
-
-#include "default.h"
-
-#include "ADM_toolkit_gtk/ADM_gladeSupport.h"
-#include "ADM_toolkit_gtk/toolkit_gtk.h"
-#include "ADM_toolkit_gtk/toolkit_gtk_include.h"
-
-
-static GtkWidget	*create_dialog1 (void);
-
-#define GETSPIN(x,y)  y= gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(lookup_widget(dialog,#x)))
-#define SETSPIN(x,y)  gtk_spin_button_set_value(GTK_SPIN_BUTTON((lookup_widget(dialog,#x))),(gfloat)y)
-
-uint8_t DIA_dnr(uint32_t *llock,uint32_t *lthresh, uint32_t *clock,
-			uint32_t *cthresh, uint32_t *scene)
-{
-GtkWidget *dialog;
-
-	uint8_t ret=0;
-
-	dialog=create_dialog1();
-	gtk_register_dialog(dialog);
-	//gtk_transient(dialog);
-	SETSPIN(spin_lumalock,*llock);
-	SETSPIN(spin_lumathresh,*lthresh);
-	SETSPIN(spin_chromalock,*clock);
-	SETSPIN(spin_chromathresh,*cthresh);
-	SETSPIN(spin_scene,*scene);
-
-	ret=0;
-	if(gtk_dialog_run(GTK_DIALOG(dialog))==GTK_RESPONSE_OK)
-	{
-		GETSPIN(spin_lumalock,*llock);
-		GETSPIN(spin_lumathresh,*lthresh);
-		GETSPIN(spin_chromalock,*clock);
-		GETSPIN(spin_chromathresh,*cthresh);
-		GETSPIN(spin_scene,*scene);
-			ret=1;
-	}
-	gtk_unregister_dialog(dialog);
-	gtk_widget_destroy(dialog);
-
-	return ret;
-
-}
-
-GtkWidget*
-create_dialog1 (void)
-{
-  GtkWidget *dialog1;
-  GtkWidget *dialog_vbox1;
-  GtkWidget *table1;
-  GtkWidget *label1;
-  GtkWidget *label2;
-  GtkWidget *label3;
-  GtkWidget *label4;
-  GtkWidget *label5;
-  GtkObject *spin_lumalock_adj;
-  GtkWidget *spin_lumalock;
-  GtkObject *spin_lumathresh_adj;
-  GtkWidget *spin_lumathresh;
-  GtkObject *spin_chromalock_adj;
-  GtkWidget *spin_chromalock;
-  GtkObject *spin_chromathresh_adj;
-  GtkWidget *spin_chromathresh;
-  GtkObject *spin_scene_adj;
-  GtkWidget *spin_scene;
-  GtkWidget *dialog_action_area1;
-  GtkWidget *cancelbutton1;
-  GtkWidget *okbutton1;
-
-  dialog1 = gtk_dialog_new ();
-  gtk_window_set_title (GTK_WINDOW (dialog1), _("Dynamic Noise Reduction"));
-
-  dialog_vbox1 = GTK_DIALOG (dialog1)->vbox;
-  gtk_widget_show (dialog_vbox1);
-
-  table1 = gtk_table_new (5, 2, FALSE);
-  gtk_widget_show (table1);
-  gtk_box_pack_start (GTK_BOX (dialog_vbox1), table1, TRUE, TRUE, 0);
-
-  label1 = gtk_label_new (_("Luma Lock"));
-  gtk_widget_show (label1);
-  gtk_table_attach (GTK_TABLE (table1), label1, 0, 1, 0, 1,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_label_set_justify (GTK_LABEL (label1), GTK_JUSTIFY_LEFT);
-  gtk_misc_set_alignment (GTK_MISC (label1), 0, 0.5);
-
-  label2 = gtk_label_new (_("Luma Threshold"));
-  gtk_widget_show (label2);
-  gtk_table_attach (GTK_TABLE (table1), label2, 0, 1, 1, 2,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_label_set_justify (GTK_LABEL (label2), GTK_JUSTIFY_LEFT);
-  gtk_misc_set_alignment (GTK_MISC (label2), 0, 0.5);
-
-  label3 = gtk_label_new (_("Chroma Lock"));
-  gtk_widget_show (label3);
-  gtk_table_attach (GTK_TABLE (table1), label3, 0, 1, 2, 3,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_label_set_justify (GTK_LABEL (label3), GTK_JUSTIFY_LEFT);
-  gtk_misc_set_alignment (GTK_MISC (label3), 0, 0.5);
-
-  label4 = gtk_label_new (_("Chroma Threshold"));
-  gtk_widget_show (label4);
-  gtk_table_attach (GTK_TABLE (table1), label4, 0, 1, 3, 4,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_label_set_justify (GTK_LABEL (label4), GTK_JUSTIFY_LEFT);
-  gtk_misc_set_alignment (GTK_MISC (label4), 0, 0.5);
-
-  label5 = gtk_label_new (_("Scene change detect"));
-  gtk_widget_show (label5);
-  gtk_table_attach (GTK_TABLE (table1), label5, 0, 1, 4, 5,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_label_set_justify (GTK_LABEL (label5), GTK_JUSTIFY_LEFT);
-  gtk_misc_set_alignment (GTK_MISC (label5), 0, 0.5);
-
-  spin_lumalock_adj = gtk_adjustment_new (1, 0, 255, 1, 10, 10);
-  spin_lumalock = gtk_spin_button_new (GTK_ADJUSTMENT (spin_lumalock_adj), 1, 0);
-  gtk_widget_show (spin_lumalock);
-  gtk_table_attach (GTK_TABLE (table1), spin_lumalock, 1, 2, 0, 1,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (spin_lumalock), TRUE);
-
-  spin_lumathresh_adj = gtk_adjustment_new (1, 0, 255, 1, 10, 10);
-  spin_lumathresh = gtk_spin_button_new (GTK_ADJUSTMENT (spin_lumathresh_adj), 1, 0);
-  gtk_widget_show (spin_lumathresh);
-  gtk_table_attach (GTK_TABLE (table1), spin_lumathresh, 1, 2, 1, 2,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (spin_lumathresh), TRUE);
-
-  spin_chromalock_adj = gtk_adjustment_new (1, 0, 255, 1, 10, 10);
-  spin_chromalock = gtk_spin_button_new (GTK_ADJUSTMENT (spin_chromalock_adj), 1, 0);
-  gtk_widget_show (spin_chromalock);
-  gtk_table_attach (GTK_TABLE (table1), spin_chromalock, 1, 2, 2, 3,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (spin_chromalock), TRUE);
-
-  spin_chromathresh_adj = gtk_adjustment_new (1, 0, 255, 1, 10, 10);
-  spin_chromathresh = gtk_spin_button_new (GTK_ADJUSTMENT (spin_chromathresh_adj), 1, 0);
-  gtk_widget_show (spin_chromathresh);
-  gtk_table_attach (GTK_TABLE (table1), spin_chromathresh, 1, 2, 3, 4,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (spin_chromathresh), TRUE);
-
-  spin_scene_adj = gtk_adjustment_new (1, 0, 100, 1, 10, 10);
-  spin_scene = gtk_spin_button_new (GTK_ADJUSTMENT (spin_scene_adj), 1, 0);
-  gtk_widget_show (spin_scene);
-  gtk_table_attach (GTK_TABLE (table1), spin_scene, 1, 2, 4, 5,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (spin_scene), TRUE);
-
-  dialog_action_area1 = GTK_DIALOG (dialog1)->action_area;
-  gtk_widget_show (dialog_action_area1);
-  gtk_button_box_set_layout (GTK_BUTTON_BOX (dialog_action_area1), GTK_BUTTONBOX_END);
-
-  cancelbutton1 = gtk_button_new_from_stock ("gtk-cancel");
-  gtk_widget_show (cancelbutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), cancelbutton1, GTK_RESPONSE_CANCEL);
-  GTK_WIDGET_SET_FLAGS (cancelbutton1, GTK_CAN_DEFAULT);
-
-  okbutton1 = gtk_button_new_from_stock ("gtk-ok");
-  gtk_widget_show (okbutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), okbutton1, GTK_RESPONSE_OK);
-  GTK_WIDGET_SET_FLAGS (okbutton1, GTK_CAN_DEFAULT);
-
-  /* Store pointers to all widgets, for use by lookup_widget(). */
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog1, "dialog1");
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_vbox1, "dialog_vbox1");
-  GLADE_HOOKUP_OBJECT (dialog1, table1, "table1");
-  GLADE_HOOKUP_OBJECT (dialog1, label1, "label1");
-  GLADE_HOOKUP_OBJECT (dialog1, label2, "label2");
-  GLADE_HOOKUP_OBJECT (dialog1, label3, "label3");
-  GLADE_HOOKUP_OBJECT (dialog1, label4, "label4");
-  GLADE_HOOKUP_OBJECT (dialog1, label5, "label5");
-  GLADE_HOOKUP_OBJECT (dialog1, spin_lumalock, "spin_lumalock");
-  GLADE_HOOKUP_OBJECT (dialog1, spin_lumathresh, "spin_lumathresh");
-  GLADE_HOOKUP_OBJECT (dialog1, spin_chromalock, "spin_chromalock");
-  GLADE_HOOKUP_OBJECT (dialog1, spin_chromathresh, "spin_chromathresh");
-  GLADE_HOOKUP_OBJECT (dialog1, spin_scene, "spin_scene");
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_action_area1, "dialog_action_area1");
-  GLADE_HOOKUP_OBJECT (dialog1, cancelbutton1, "cancelbutton1");
-  GLADE_HOOKUP_OBJECT (dialog1, okbutton1, "okbutton1");
-
-  return dialog1;
-}
-
-

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_msharpen.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_msharpen.cpp	2007-01-11 19:18:08 UTC (rev 2704)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_msharpen.cpp	2007-01-11 20:41:19 UTC (rev 2705)
@@ -1,202 +0,0 @@
-//
-// C++ Implementation: DIA_Msmooth
-//
-// Description: 
-//
-//
-// Author: mean <fixounet at free.fr>, (C) 2004
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-//
-// C++ Implementation: DIA_decimate
-//
-// Description: 
-//
-//
-// Author: mean <fixounet at free.fr>, (C) 2004
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-//
-// C++ Implementation: DIA_dectel
-//
-// Description: 
-//
-//
-// Author: mean <fixounet at free.fr>, (C) 2004
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-
-
-#include <config.h>
-
-
-#include <string.h>
-#include <stdio.h>
-
-#include <gdk/gdkkeysyms.h>
-#include <gtk/gtk.h>
-
-
-#include <gdk/gdkkeysyms.h>
-#include <gtk/gtk.h>
-# include <math.h>
-
-#include "default.h"
-#include "ADM_toolkit_gtk/ADM_gladeSupport.h"
-#include "ADM_toolkit_gtk/toolkit_gtk.h"
-#include "ADM_toolkit_gtk/toolkit_gtk_include.h"
-#include "ADM_toolkit/toolkit.hxx"
-#include "default.h"
-
-#include "ADM_video/ADM_vidMSharpen_param.h"
-static GtkWidget        *create_dialog1 (void);
-
-#define CHECK_GET(x,y) {param->y=gtk_toggle_button_get_active( GTK_TOGGLE_BUTTON(WID(x)));}
-#define CHECK_SET(x,y) {gtk_toggle_button_set_active( GTK_TOGGLE_BUTTON(WID(x)),param->y);}     
-uint8_t DIA_getMSharpen(MSHARPEN_PARAM *param);
-uint8_t DIA_getMSharpen(MSHARPEN_PARAM *param)
-{
-GtkWidget *dialog;
-int ret=0;
-        dialog=create_dialog1();
-        
-        // Update
-        
-        CHECK_SET(checkbuttonMask,mask);
-        CHECK_SET(checkbuttonHQ,highq);
-        
-        gtk_range_set_value (GTK_RANGE(WID(hscaleThresh)),(gdouble)param->threshold);
-        gtk_range_set_value (GTK_RANGE(WID(hscaleStrength)),(gdouble)param->strength);
-        
-        gtk_register_dialog(dialog);
-        if(gtk_dialog_run(GTK_DIALOG(dialog))==GTK_RESPONSE_OK)
-        {
-          GtkAdjustment *adj;   
-
-                adj=gtk_range_get_adjustment (GTK_RANGE(WID(hscaleThresh)));
-                param->threshold=(uint32_t)GTK_ADJUSTMENT(adj)->value;
-        
-                adj=gtk_range_get_adjustment (GTK_RANGE(WID(hscaleStrength)));
-                param->strength=(uint32_t)GTK_ADJUSTMENT(adj)->value;
-
-                CHECK_GET(checkbuttonHQ,highq);
-                CHECK_GET(checkbuttonMask,mask);
-               
-
-                ret=1;
-        
-        }
-        gtk_unregister_dialog(dialog);
-        gtk_widget_destroy(dialog);
-        return ret;
-
-}
-
-//__________________________________
-
-GtkWidget*
-create_dialog1 (void)
-{
-  GtkWidget *dialog1;
-  GtkWidget *dialog_vbox1;
-  GtkWidget *table1;
-  GtkWidget *checkbuttonMask;
-  GtkWidget *checkbuttonHQ;
-  GtkWidget *label1;
-  GtkWidget *label2;
-  GtkWidget *hscaleThresh;
-  GtkWidget *hscaleStrength;
-  GtkWidget *dialog_action_area1;
-  GtkWidget *cancelbutton1;
-  GtkWidget *okbutton1;
-
-  dialog1 = gtk_dialog_new ();
-  gtk_window_set_title (GTK_WINDOW (dialog1), _("Donal Graft MSharpen"));
-
-  dialog_vbox1 = GTK_DIALOG (dialog1)->vbox;
-  gtk_widget_show (dialog_vbox1);
-
-  table1 = gtk_table_new (3, 2, FALSE);
-  gtk_widget_show (table1);
-  gtk_box_pack_start (GTK_BOX (dialog_vbox1), table1, TRUE, TRUE, 0);
-
-  checkbuttonMask = gtk_check_button_new_with_mnemonic (_("Show Mask"));
-  gtk_widget_show (checkbuttonMask);
-  gtk_table_attach (GTK_TABLE (table1), checkbuttonMask, 1, 2, 0, 1,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-
-  checkbuttonHQ = gtk_check_button_new_with_mnemonic (_("HighQ"));
-  gtk_widget_show (checkbuttonHQ);
-  gtk_table_attach (GTK_TABLE (table1), checkbuttonHQ, 0, 1, 0, 1,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-
-  label1 = gtk_label_new (_("Threshold"));
-  gtk_widget_show (label1);
-  gtk_table_attach (GTK_TABLE (table1), label1, 0, 1, 1, 2,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_label_set_justify (GTK_LABEL (label1), GTK_JUSTIFY_LEFT);
-  gtk_misc_set_alignment (GTK_MISC (label1), 0, 0.5);
-
-  label2 = gtk_label_new (_("Strength"));
-  gtk_widget_show (label2);
-  gtk_table_attach (GTK_TABLE (table1), label2, 0, 1, 2, 3,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_label_set_justify (GTK_LABEL (label2), GTK_JUSTIFY_LEFT);
-  gtk_misc_set_alignment (GTK_MISC (label2), 0, 0.5);
-
-  hscaleThresh = gtk_hscale_new (GTK_ADJUSTMENT (gtk_adjustment_new (1, 1, 255, 1, 1, 0)));
-  gtk_widget_show (hscaleThresh);
-  gtk_table_attach (GTK_TABLE (table1), hscaleThresh, 1, 2, 1, 2,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (GTK_FILL), 0, 0);
-  gtk_scale_set_digits (GTK_SCALE (hscaleThresh), 0);
-
-  hscaleStrength = gtk_hscale_new (GTK_ADJUSTMENT (gtk_adjustment_new (1, 1, 255, 1, 1, 0)));
-  gtk_widget_show (hscaleStrength);
-  gtk_table_attach (GTK_TABLE (table1), hscaleStrength, 1, 2, 2, 3,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (GTK_FILL), 0, 0);
-  gtk_scale_set_digits (GTK_SCALE (hscaleStrength), 0);
-
-  dialog_action_area1 = GTK_DIALOG (dialog1)->action_area;
-  gtk_widget_show (dialog_action_area1);
-  gtk_button_box_set_layout (GTK_BUTTON_BOX (dialog_action_area1), GTK_BUTTONBOX_END);
-
-  cancelbutton1 = gtk_button_new_from_stock ("gtk-cancel");
-  gtk_widget_show (cancelbutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), cancelbutton1, GTK_RESPONSE_CANCEL);
-  GTK_WIDGET_SET_FLAGS (cancelbutton1, GTK_CAN_DEFAULT);
-
-  okbutton1 = gtk_button_new_from_stock ("gtk-ok");
-  gtk_widget_show (okbutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), okbutton1, GTK_RESPONSE_OK);
-  GTK_WIDGET_SET_FLAGS (okbutton1, GTK_CAN_DEFAULT);
-
-  /* Store pointers to all widgets, for use by lookup_widget(). */
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog1, "dialog1");
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_vbox1, "dialog_vbox1");
-  GLADE_HOOKUP_OBJECT (dialog1, table1, "table1");
-  GLADE_HOOKUP_OBJECT (dialog1, checkbuttonMask, "checkbuttonMask");
-  GLADE_HOOKUP_OBJECT (dialog1, checkbuttonHQ, "checkbuttonHQ");
-  GLADE_HOOKUP_OBJECT (dialog1, label1, "label1");
-  GLADE_HOOKUP_OBJECT (dialog1, label2, "label2");
-  GLADE_HOOKUP_OBJECT (dialog1, hscaleThresh, "hscaleThresh");
-  GLADE_HOOKUP_OBJECT (dialog1, hscaleStrength, "hscaleStrength");
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_action_area1, "dialog_action_area1");
-  GLADE_HOOKUP_OBJECT (dialog1, cancelbutton1, "cancelbutton1");
-  GLADE_HOOKUP_OBJECT (dialog1, okbutton1, "okbutton1");
-
-  return dialog1;
-}
-
-

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am	2007-01-11 19:18:08 UTC (rev 2704)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am	2007-01-11 20:41:19 UTC (rev 2705)
@@ -10,7 +10,7 @@
 
 libADM_dialog_a_SOURCES = DIA_audio.cpp DIA_vcodec.cpp DIA_acodec.cpp \
 	DIA_audiocodec.cpp DIA_properties.cpp DIA_mjpeg.cpp DIA_about.cpp DIA_recent.cpp \
-	DIA_indexer.cpp DIA_resize.cpp DIA_dnr.cpp DIA_working.cpp \
+	DIA_indexer.cpp DIA_resize.cpp DIA_working.cpp \
 	DIA_working.h DIA_busy.cpp DIA_busy.h DIA_exLame.cpp DIA_pipe.cpp DIA_mpeg2opt.cpp \
 	DIA_d3d.cpp DIA_postproc.cpp DIA_enter.cpp DIA_enter.h DIA_xvcd.cpp DIA_muxer.cpp \
 	DIA_xvid.cpp DIA_crop.cpp DIA_color.cpp DIA_encoding.cpp DIA_SVCD.cpp DIA_prefs.cpp \
@@ -18,7 +18,7 @@
 	DIA_dectel.cpp DIA_decimate.cpp DIA_pause.cpp \
 	DIA_DVDff.cpp DIA_lavdecoder.cpp DIA_lame.cpp DIA_calculator.cpp DIA_equalizer.cpp \
 	DIA_vobsub.cpp DIA_x264.cpp DIA_ocr.cpp  DIA_hue.cpp DIA_eq2.cpp \
-	DIA_dgbob.cpp DIA_msharpen.cpp DIA_asharp.cpp DIA_dmx.cpp DIA_idx_pg.cpp DIA_gototime.cpp \
+	DIA_dgbob.cpp DIA_asharp.cpp DIA_dmx.cpp DIA_idx_pg.cpp DIA_gototime.cpp \
 	DIA_audioTrack.cpp DIA_cnr2.cpp DIA_resizeWiz.cpp DIA_jobs.cpp DIA_jobs_save.cpp DIA_mosaic.cpp \
 	DIA_deblend.cpp DIA_v2v.cpp DIA_tdeint.cpp DIA_builtin.cpp DIA_mpdelogo.cpp DIA_vorbis.cpp \
         DIA_chromaShift.cpp \
@@ -44,7 +44,7 @@
 DIA_DVDff.cpp        DIA_color.cpp         DIA_eq2.cpp          DIA_mosaic.cpp      DIA_resizeWiz.h \
 DIA_coloryuv.cpp      DIA_equalizer.cpp    DIA_mpdelogo.cpp    DIA_rotate.cpp \
 DIA_SVCD.cpp         DIA_contrast.cpp      DIA_exLame.cpp       DIA_mpeg2opt.cpp    DIA_srt.cpp \
-DIA_about.cpp        DIA_conv.cpp          DIA_msharpen.cpp    DIA_tdeint.cpp \
+DIA_about.cpp        DIA_conv.cpp          DIA_tdeint.cpp \
 DIA_acodec.cpp       DIA_crop.cpp          DIA_gototime.cpp     DIA_muxer.cpp       DIA_v2v.cpp \
 DIA_animated.cpp     DIA_d3d.cpp           DIA_hue.cpp          DIA_ocr.cpp         DIA_vcodec.cpp \
 DIA_asharp.cpp       DIA_deblend.cpp       DIA_idx_pg.cpp       DIA_partial.cpp     DIA_vobsub.cpp \
@@ -54,7 +54,7 @@
 DIA_jobs_save.cpp    DIA_prefs.cpp       DIA_x264.cpp \
 DIA_builtin.cpp      DIA_dgbob.cpp         DIA_preview.cpp     DIA_xvcd.cpp \
 DIA_busy.cpp         DIA_dmx.cpp           DIA_lame.cpp         DIA_properties.cpp  DIA_xvid.cpp \
-DIA_busy.h           DIA_dnr.cpp           DIA_lavcodec.cpp     DIA_quota.cpp       DIA_xvid4.cpp \
+DIA_busy.h           DIA_lavcodec.cpp     DIA_quota.cpp       DIA_xvid4.cpp \
 DIA_calculator.cpp   DIA_encoding.cpp      DIA_lavdecoder.cpp   DIA_recent.cpp \
 DIA_chromaShift.cpp  DIA_encoding.h        DIA_lavpp_deint.cpp  DIA_requant.cpp DIA_ass.cpp
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp	2007-01-11 19:18:08 UTC (rev 2704)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp	2007-01-11 20:41:19 UTC (rev 2705)
@@ -46,7 +46,6 @@
 #include "ADM_audiofilter/audioencoder_lame_param.h"
 #include "ADM_encoder/adm_encmjpeg_param.h"
 #include "ADM_video/ADM_vidMosaic_param.h"
-#include "ADM_video/ADM_vidMSharpen_param.h"
 #include "ADM_video/ADM_vidMSmooth_param.h"
 #include "ADM_video/ADM_vidPartial_param.h"
 #include "ADM_video/ADM_vidTDeint_param.h"
@@ -106,7 +105,6 @@
 uint8_t DIA_getHue(Hue_Param *param, ADMImage *image){return 0;}
 uint8_t DIA_getHue(Hue_Param *param, AVDMGenericVideoStream *in){return 0;}
 uint8_t DIA_getMPdelogo(MPDELOGO_PARAM *param,AVDMGenericVideoStream *in){return 0;}
-uint8_t DIA_getMSharpen(MSHARPEN_PARAM *param){return 0;}
 uint8_t DIA_getMSmooth(MSMOOTH_PARAM *param){return 0;}
 uint8_t DIA_getPartial(PARTIAL_CONFIG *param,AVDMGenericVideoStream *son,AVDMGenericVideoStream *previous){return 0;}
 uint8_t DIA_mjpegCodecSetting(COMPRES_PARAMS *param){return 0;}

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp	2007-01-11 19:18:08 UTC (rev 2704)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp	2007-01-11 20:41:19 UTC (rev 2705)
@@ -46,7 +46,6 @@
 #include "ADM_audiofilter/audioencoder_lame_param.h"
 #include "ADM_encoder/adm_encmjpeg_param.h"
 #include "ADM_video/ADM_vidMosaic_param.h"
-#include "ADM_video/ADM_vidMSharpen_param.h"
 #include "ADM_video/ADM_vidMSmooth_param.h"
 #include "ADM_video/ADM_vidPartial_param.h"
 #include "ADM_video/ADM_vidTDeint_param.h"
@@ -106,7 +105,6 @@
 uint8_t DIA_getHue(Hue_Param *param, ADMImage *image){return 0;}
 uint8_t DIA_getHue(Hue_Param *param, AVDMGenericVideoStream *in){return 0;}
 uint8_t DIA_getMPdelogo(MPDELOGO_PARAM *param,AVDMGenericVideoStream *in){return 0;}
-uint8_t DIA_getMSharpen(MSHARPEN_PARAM *param){return 0;}
 uint8_t DIA_getMSmooth(MSMOOTH_PARAM *param){return 0;}
 uint8_t DIA_getPartial(PARTIAL_CONFIG *param,AVDMGenericVideoStream *son,AVDMGenericVideoStream *previous){return 0;}
 uint8_t DIA_mjpegCodecSetting(COMPRES_PARAMS *param){return 0;}

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDenoise.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDenoise.cpp	2007-01-11 19:18:08 UTC (rev 2704)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDenoise.cpp	2007-01-11 20:41:19 UTC (rev 2705)
@@ -1,394 +0,0 @@
-/***************************************************************************
-                          ADM_vidDenoise.cpp  -  description
-                             -------------------
-    begin                : Mon Nov 25 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
-    
-    Denoiser inspired from DNR in transcode
-    Ported to YV12 and simplified
-    
-   Original code  Copyright (C) Gerhard Monzel - November 2001
- 
-    
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <ADM_assert.h>
-#include <math.h>
-
-#include "config.h"
-#include "fourcc.h"
-#include "avio.hxx"
-#include "config.h"
-#include "avi_vars.h"
-
-
-#include "ADM_toolkit/toolkit.hxx"
-#include "ADM_editor/ADM_edit.hxx"
-#include "ADM_video/ADM_genvideo.hxx"
-#include "ADM_video/ADM_vidDenoise.h"
-#include "ADM_filter/video_filters.h"
-
-
-static FILTER_PARAM denoiseParam={5,{"lumaLock","lumaThreshold","chromaLock","chromaThreshold",
-					"sceneChange"}};
-
-
-SCRIPT_CREATE(denoise_script,ADMVideoDenoise,denoiseParam);
-
-uint8_t distMatrix[256][256];
-uint32_t fixMul[16];
-
-//static uint8_t matrixReady=0;
-//static uint8_t doOnePix(uint8_t *in,uint8_t *out,uint8_t *lock,uint8_t *nb);
-
-BUILD_CREATE(denoise_create,ADMVideoDenoise);
-char *ADMVideoDenoise::printConf( void )
-{
- 	static char buf[50];
-
-  ADM_assert(_param); 	
- 	sprintf((char *)buf," Denoise : Lum :%02ld/:%02ld / Chm :%02ld/%02ld",
-  								_param->lumaLock,
-          				_param->lumaThreshold,
-              		_param->chromaLock,
-                	_param->chromaThreshold);
-        return buf;
-}
-void buildDistMatrix( void );
-void buildDistMatrix( void )
-{
-int d;	
-	for(uint32_t y=255;y>0;y--)
-	for(uint32_t x=255;x>0;x--)
-	{
-		  d=x-y;
-		  if(d<0) d=-d;
-		  distMatrix[x][y]=d;
-		
-	}
-
-	 for(int i=1;i<16;i++)
-                        {
-                                        fixMul[i]=(1<<16)/i;
-                        }
-
-}
-
-//_______________________________________________________________
-
-ADMVideoDenoise::ADMVideoDenoise(
-									AVDMGenericVideoStream *in,CONFcouple *couples)
-{
-
-
-  	_in=in;		
-   	memcpy(&_info,_in->getInfo(),sizeof(_info));  			 	
-    uint32_t page;
-    
-  _info.encoding=1;
-  
-  page= _in->getInfo()->width*_in->getInfo()->height;
-  
-//  _uncompressed=new uint8_t [page];
-  _uncompressed=new ADMImage(_in->getInfo()->width,_in->getInfo()->height);
-  ADM_assert(_uncompressed);
-  
- // _locked=new uint8_t [page];
-  _locked=new ADMImage(_in->getInfo()->width,_in->getInfo()->height);
-  ADM_assert(_locked);
- 
-//	_lockcount=new uint8_t [page];
-
-
-  
-   _lockcount=new ADMImage(_in->getInfo()->width,_in->getInfo()->height);
-  memset(YPLANE(_lockcount),0,page);  
-  memset(UPLANE(_lockcount),0,page>>2);  
-  memset(VPLANE(_lockcount),0,page>>2);  
-        
-  _param=NULL;
-  
-  if(couples)
-  	{
-			_param=NEW(NOISE_PARAM);
-			GET(lumaLock);
-			GET(lumaThreshold);
-			GET(chromaLock);
-			GET(chromaThreshold);
-			GET(sceneChange);
-		 }
-	else
-		{
-			  #define XXX 1
-			  _param=NEW(NOISE_PARAM);
-			  _param->lumaLock=  4*XXX;
-			  _param->lumaThreshold= 10*XXX;
-			  _param->chromaLock=  8*XXX;
-			  _param->chromaThreshold= 16*XXX;
-        _param->sceneChange=  30*XXX;
-			}
-  	  _lastFrame=0xfffffff0;	
-}
-
-
-uint8_t	ADMVideoDenoise::getCoupledConf( CONFcouple **couples)
-{
-
-			ADM_assert(_param);
-			*couples=new CONFcouple(5);
-
-#define CSET(x)  (*couples)->setCouple((char *)#x,(_param->x))
-	CSET(lumaLock);
-	CSET(lumaThreshold);
-	CSET(chromaLock);
-	CSET(chromaThreshold);
-	CSET(sceneChange);
-
-	return 1;
-
-}
-ADMVideoDenoise::~ADMVideoDenoise()
-{
- 	
-	delete  _uncompressed;
- 	delete  _locked;
-  	delete  _lockcount;
-  DELETE(_param);
-  
-  _uncompressed=_locked=_lockcount=NULL;
-}
-
-//
-//	Remove y and v just keep U and expand it
-//
-uint8_t ADMVideoDenoise::getFrameNumberNoAlloc(uint32_t frame,
-				uint32_t *len,
-   				ADMImage *data,
-				uint32_t *flags)
-{
-   //uint32_t x,w;
-  	uint32_t page; 
-   		ADM_assert(_param);
-		ADM_assert(frame<_info.nb_frames);
-								
-			
-       		if(!_in->getFrameNumberNoAlloc(frame, len,_uncompressed,flags)) return 0;
-
-		
-		page=_info.width*_info.height;  
-		*len=(page*3)>>1;           
-
-	if((_lastFrame+1)!=frame) // async jump
-	{
-			// just copy it 
-			memcpy(YPLANE(data),YPLANE(_uncompressed),page);
-			memcpy(UPLANE(data),UPLANE(_uncompressed),page>>2);
-			memcpy(VPLANE(data),VPLANE(_uncompressed),page>>2);
-			
-			memcpy(YPLANE(_locked),YPLANE(_uncompressed),page);
-			memcpy(UPLANE(_locked),UPLANE(_uncompressed),page>>2);
-			memcpy(VPLANE(_locked),VPLANE(_uncompressed),page>>2);
-			
-			_lastFrame=frame;
-			return 1;
-	}          
-	_lastFrame=frame;
-          
-          // copy chroma for now
-        
-         
-          
-          //
-          //uint32_t count=0;
-          //uint32_t cell=page*4; // size of luma
-          uint8_t *in,*out,*lock,*nb;
-          uint8_t *uin,*uout,*ulock,*unb;
-          uint8_t *vin,*vout,*vlock,*vnb;
-          
-          
-          //uint32_t d;
-          // init all
-          
-          // luma
-          nb=YPLANE(_lockcount);
-          lock=YPLANE(_locked);
-          in=YPLANE(_uncompressed);
-          out=YPLANE(data);
-          // u
-          unb=UPLANE(_lockcount);
-          ulock=UPLANE(_locked);
-          uin=UPLANE(_uncompressed);
-          uout=UPLANE(data);
-          // v
-          vnb=VPLANE(_lockcount);
-          vlock=VPLANE(_locked);
-          vin=VPLANE(_uncompressed);
-          vout=VPLANE(data);
-          
-          
-          uint32_t xx,yy/*,dl*/,du,dv;
-          uint32_t locked=0;
-          for(yy=_info.height>>1;yy>0;yy--)
-          {
-	          for(xx=_info.width>>1;xx>0;xx--)          
-  	        {
-			du=distMatrix[*uin][*ulock];	
-			dv=distMatrix[*vin][*vlock];		
-						
-			// if chroma is locked , we try to lock luma
-			if( (du<_param->chromaLock)
-				 && (dv<_param->chromaLock))
-			 {  
-				*uout=*ulock;
- 				*vout=*vlock;
-
-#define PIX(z) 		doOnePix(in+z,out+z,lock+z,nb+z) 
-				locked+=PIX(0)+	PIX(1)+ PIX(_info.width)+PIX(_info.width+1);
-			}
-			else
-			 // if chroma is blended, we blend luma
-#undef PIX								  
-#define PIX(z) 		doBlend(in+z,out+z,lock+z,nb+z)									 
-				if( (du<_param->chromaThreshold)
-					 && (dv<_param->chromaThreshold))
-				{
-			 		PIX(0);
-				    	PIX(1);
-				     	PIX(_info.width);
-				     	PIX(_info.width+1);	
-				      *uout=*ulock=(*uin+*uin)>>1;
- 					*vout=*vlock=(*vin+*vin)>>1;
-				}
-#undef PIX											
-										
-			else
-			{
-#define PIX(z) *(out+z)=*(lock+z)=*(in+z);*(nb+z)=0			
-											
-				PIX(0);
-				PIX(1);
-				PIX(_info.width);
-				PIX(_info.width+1);		
-				*uout=*ulock=*uin;
- 				*vout=*vlock=*vin;
-				
-#undef PIX		
-			}
-								  
-											                        				                        
-			uin++;uout++;ulock++;unb++;   
-			vin++;vout++;vlock++;vnb++;   
-			in++;out++;lock++;nb++;   
-			in++;out++;lock++;nb++;   
-							
-		}
-            // 
-            in+=_info.width;
-            out+=_info.width;
-            lock+=_info.width;
-            nb+=_info.width;            						
-	};
-          
-          if(locked>((page*3)>>2)) // if more than 75% pixel not locked -> scene change
-          {
-			memcpy(YPLANE(data),YPLANE(_uncompressed),page);
-			memcpy(UPLANE(data),UPLANE(_uncompressed),page>>2);
-			memcpy(VPLANE(data),VPLANE(_uncompressed),page>>2);
-			
-			memcpy(YPLANE(_locked),YPLANE(_uncompressed),page);
-			memcpy(UPLANE(_locked),UPLANE(_uncompressed),page>>2);
-			memcpy(VPLANE(_locked),VPLANE(_uncompressed),page>>2);
-	}
-      data->copyInfo(_uncompressed);  
-      return 1;
-}
-
-//
-//	0 copy
-//  1 lock
-//  2 threshold
-//
-uint8_t ADMVideoDenoise::doOnePix(uint8_t *in,uint8_t *out,uint8_t *lock,uint8_t *nb)
-{
-unsigned int d;
-		d=distMatrix[*(in)][*(lock)]; 
-		if(d<_param->lumaLock)         
-		{								                
-			if(*(nb)>30)  // out of scope -> copy new                   
-			{  	// too much copy ->                              
-				*(nb)=0;                       
-				*(out)=(*(in)+*(lock))>>1;
-				*(lock)=*(out);    	
-				return DN_COPY;      
-			}                                 
-			else                               
-			{                                   
-				*(out)=*(lock);		
-				*nb += 1; // *(nb)++;	
-				return DN_LOCK;		
-			}                  
-		}                     
-		else if(d< _param->lumaThreshold) 
-			{                                  
-				 *(nb)=0;                           
-				*(out)=(*(in)+*(lock))>>1;	
-				return DN_BLEND;
-			}
-			else   // too big delta
-			{    
-				 *(nb)=0; 
-				*(out)=*(in);	  
-				*(lock)=*(in);    
-				return DN_COPY;
-			}                     
-					                           
-			ADM_assert(0);
-			return 0;
-
-}
-uint8_t ADMVideoDenoise::doBlend(uint8_t *in,uint8_t *out,uint8_t *lock,uint8_t *nb)
-{
-unsigned int d;
-		   d=distMatrix[*(in)][*(lock)]; 
-		   *nb=0;
-		   
-			if(d<_param->lumaThreshold)         
-			{
-					*(out)=(*(in)+*(lock))>>1;					
-			}
-			else
-			*out=*in;
-			return 0;
-	
-}
-extern uint8_t DIA_dnr(uint32_t *llock,uint32_t *lthresh, uint32_t *clock,
-			uint32_t *cthresh, uint32_t *scene);
-
-
-uint8_t ADMVideoDenoise::configure(AVDMGenericVideoStream * instream)
-{
-  UNUSED_ARG(instream);
-
-    if(DIA_dnr(	&(_param->lumaThreshold),
-    				&(_param->lumaLock),
-				&(_param->chromaThreshold),
-				&(_param->chromaLock),
-				&(_param->sceneChange)
-               						)) return 1;
-
-	return 0;
-}
-
-// EOF

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDenoise.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDenoise.h	2007-01-11 19:18:08 UTC (rev 2704)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDenoise.h	2007-01-11 20:41:19 UTC (rev 2705)
@@ -1,55 +0,0 @@
-/***************************************************************************
-                          ADM_vidDenoise.h  -  description
-                             -------------------
-    begin                : Mon Nov 25 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
- #define DN_COPY 3
- #define DN_LOCK 0
- #define DN_BLEND 1
-  
- typedef struct
- {
-	  uint32_t lumaThreshold,lumaLock;
-	  uint32_t chromaThreshold,chromaLock;
-	  uint32_t sceneChange;
-	}NOISE_PARAM;
- 
-  class  ADMVideoDenoise:public AVDMGenericVideoStream
- {
-
- protected:
-
-      					ADMImage	*_locked;
-        				ADMImage	*_lockcount;
-   			virtual 	char 		*printConf(void);
-        				NOISE_PARAM	*_param;
-        				uint32_t	_lastFrame;
-        				uint8_t 	doOnePix(uint8_t *in,uint8_t *out,
-        							uint8_t *lock,uint8_t *nb);
-         				uint8_t 	doBlend(uint8_t *in,uint8_t *out,
-        							uint8_t *lock,uint8_t *nb);
-
- public:
-
-
-							ADMVideoDenoise(  AVDMGenericVideoStream *in,CONFcouple *setup);
-  			virtual 			~ADMVideoDenoise();
-		        virtual uint8_t 		getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-          								ADMImage *data,uint32_t *flags);
-			virtual uint8_t 		configure( AVDMGenericVideoStream *instream) ;
-
-			virtual uint8_t			getCoupledConf( CONFcouple **couples);
- }     ;
-

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidForcedPP.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidForcedPP.cpp	2007-01-11 19:18:08 UTC (rev 2704)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidForcedPP.cpp	2007-01-11 20:41:19 UTC (rev 2705)
@@ -1,213 +0,0 @@
-//
-// C++ Implementation: ADM_vidForcedPP
-//
-// Description: 
-//
-//	Force postprocessing assuming constant quant & image type
-//	Uselefull on some badly authored DVD for example
-//
-// Author: mean <fixounet at free.fr>, (C) 2004
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <ADM_assert.h>
-#include <math.h>
-#include <math.h>
-#include <iconv.h>
-#include "config.h"
-
-
-#include "fourcc.h"
-#include "avio.hxx"
-
-#include "avi_vars.h"
-
-#include "ADM_toolkit/toolkit.hxx"
-#include "ADM_editor/ADM_edit.hxx"
-#include "ADM_video/ADM_genvideo.hxx"
-
-#include "ADM_osSupport/ADM_debugID.h"
-#define MODULE_NAME MODULE_FILTER
-#include "ADM_osSupport/ADM_debug.h"
-
-
-
-#include "ADM_vidForcedPP.h"
-#include "DIA_enter.h"
-#include "ADM_filter/video_filters.h"
-
-
-static FILTER_PARAM ppParam={3,{"postProcType","postProcStrength","forcedQuant"}};
-
-
-SCRIPT_CREATE(forcedpp_script,ADMVideoForcedPP,ppParam);
-BUILD_CREATE(forcedpp_create,ADMVideoForcedPP);
-
-extern int DIA_getMPParams( uint32_t *pplevel, uint32_t *ppstrength,uint32_t *swap);
-
-uint8_t ADMVideoForcedPP::configure( AVDMGenericVideoStream *instream)
-{
-	_in=instream;
-	uint32_t postproc, strength,uv;
-	int forced;
-		postproc=_param->postProcType;
-		strength=_param->postProcStrength;
-		forced=_param->forcedQuant;
-		uv=0;
-		if( DIA_getMPParams( &postproc,&strength,&uv))
-		{
-
-				if( DIA_GetIntegerValue(&forced,2,31, "Quant Value","Enter forced Q:"))
-				{
-					_param->postProcType=postproc;
-					_param->postProcStrength=strength;
-					_param->forcedQuant=forced;
-					updatePostProc(&_postproc );				
-					return 1;
-				}
-		}
-	return 0;	
- 	
-}
-uint8_t	ADMVideoForcedPP::getCoupledConf( CONFcouple **couples)
-{
-
-			*couples=new CONFcouple(3);
-
-			CSET(postProcType);
-			CSET(postProcStrength);
-			CSET(forcedQuant);
-
-		return 1;	
-}
-char *ADMVideoForcedPP::printConf( void )
-{
- 	static char buf[50];
- 	
- 	sprintf((char *)buf," Forced pp : %lu %lu",_param->postProcType,_param->postProcStrength);
-        return buf;
-}
-
-ADMVideoForcedPP::~ADMVideoForcedPP()
-{
-	if(_uncompressed)
- 		delete _uncompressed;
-	if(_postproc.ppContext)
-		deletePostProc(&_postproc);
-
- 	_uncompressed=NULL;
-}
-
-
- ADMVideoForcedPP::ADMVideoForcedPP( AVDMGenericVideoStream *in,CONFcouple *couples)
-{
-		printf("Adding forced PP filter\n");
-		_uncompressed=NULL;
-		_in=in;
-		ADM_assert(in);
-		if(!couples)
-		{
-			
-			_param=NEW(PP_CONF);
-	    		_param->postProcType=5; // Bff=0 / 1=tff
-	    		_param->postProcStrength=5;
-			_param->forcedQuant=10;
-			
-	    	}
-		else
-		{
-			_param=NEW(PP_CONF);
-			GET(postProcType);
-			GET(postProcStrength);
-			GET(forcedQuant);
-			
-						
-		}
-		ADM_assert(in);
-		
-		memcpy(&_info,_in->getInfo(),sizeof(_info));	
-		
-	    	initPostProc(&_postproc,_info.width,_info.height);
-		_postproc.postProcType=_param->postProcType;
-		_postproc.postProcStrength=_param->postProcStrength;
-		_postproc.forcedQuant=_param->forcedQuant;
-		updatePostProc(&_postproc);	    	
-	    	
-	    	//_uncompressed=new uint8_t[3*_info.width*_info.height];	
-		_uncompressed=new ADMImage(_info.width,_info.height);	
-		
-
-}
-uint8_t ADMVideoForcedPP::getFrameNumberNoAlloc(uint32_t frame,
-							uint32_t *len,
-							ADMImage *data,
-							uint32_t *flags)
-{
-		uint32_t page=_info.width*_info.height;
-		
-		*len=(page*3)>>1;
-		if(frame>=_info.nb_frames) return 0;		
-		
-		if(!(_postproc.postProcType && _postproc.postProcStrength) )
-		{
-			// disabled
-			if(!_in->getFrameNumberNoAlloc(frame, len,data,flags)) return 0;
-				
-			return 1;
-		
-		}
-			// we do postproc !
-			// keep
-			uint8_t *iBuff[3],*oBuff[3];
-			int strideTab[3],strideTab2[3];			
-				
-				
-			if(!_in->getFrameNumberNoAlloc(frame, len,_uncompressed,flags))
-			 		return 0;
-
-			oBuff[0]=YPLANE(data);
-                        oBuff[1]=VPLANE(data);
-                        oBuff[2]=UPLANE(data);
-
-				
-			iBuff[0]=YPLANE(_uncompressed);
-		 	iBuff[1]=VPLANE(_uncompressed);
- 		 	iBuff[2]=UPLANE(_uncompressed);
-				
-				
-		        strideTab[0]=strideTab2[0]=_info.width;
-			strideTab[1]=strideTab2[1]=_info.width>>1;
-			strideTab[2]=strideTab2[2]=_info.width>>1;
-	
-			int type;
-			if(_uncompressed->flags&AVI_KEY_FRAME)
-					type=1;
-			else if(_uncompressed->flags & AVI_B_FRAME)
-					type=3;
-				else
-					type=2;
-		 	pp_postprocess(
-		      		iBuff,
-		        	strideTab,
-		        	oBuff,
-		        	strideTab2,
-				_info.width,
-		        	_info.height,
-		        	NULL,
-		          	0,
-		         	_postproc.ppMode,
-		          	_postproc.ppContext,
-		          	type); // I ?
-			  	
-			
-		
-			data->copyInfo(_uncompressed);	
-			//printf("Type:%d\n",type);
-	return 1;
-}
-

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidForcedPP.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidForcedPP.h	2007-01-11 19:18:08 UTC (rev 2704)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidForcedPP.h	2007-01-11 20:41:19 UTC (rev 2705)
@@ -1,44 +0,0 @@
-//
-// C++ Interface: ADM_vidForcedPP
-//
-// Description: 
-//
-//
-// Author: mean <fixounet at free.fr>, (C) 2004
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-
-#ifndef ADM_FORCEDPP
-#define ADM_FORCEDPP
-#include "ADM_pp.h"
-
-typedef struct  PP_CONF
-{
-	uint32_t			postProcType;
-	uint32_t			postProcStrength;
-	uint32_t			forcedQuant;
-}PP_CONF;
-
-class  ADMVideoForcedPP:public AVDMGenericVideoStream
- {
-
- protected:
-        virtual char 		*printConf(void) ;
-	PP_CONF			*_param;
-	ADM_PP			_postproc;
-           
-
- public:
- 		
-  			ADMVideoForcedPP(  AVDMGenericVideoStream *in,CONFcouple *setup);
-  			~ADMVideoForcedPP();
-	virtual uint8_t getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-						ADMImage *data,uint32_t *flags);
-	virtual uint8_t	getCoupledConf( CONFcouple **couples)		;
-	virtual uint8_t configure( AVDMGenericVideoStream *instream);
-							
-};
-
-#endif

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMSharpen.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMSharpen.cpp	2007-01-11 19:18:08 UTC (rev 2704)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMSharpen.cpp	2007-01-11 20:41:19 UTC (rev 2705)
@@ -1,779 +0,0 @@
-/***************************************************************************
-                          ADM_vidMSharpen  -  description
-                             -------------------
-    
-    email                : fixounet at free.fr
-
-    Port of Donal Graft Msharpen which is (c) Donald Graft
-    http://www.neuron2.net
-    http://puschpull.org/avisynth/decomb_reference_manual.html
-
-        It is a bit less efficient as we do hz & vz blur separately
-        The formula has been changed a bit from 1 1 1 to 1 2 1
-        for speed aspect & MMX  
-        Mean
-
- ***************************************************************************/
-/*
-	Msharpen plugin for Avisynth -- performs detail-preserving smoothing.
-
-	Copyright (C) 2003 Donald A. Graft
-
-	This program is free software; you can redistribute it and/or modify
-	it under the terms of the GNU General Public License as published by
-	the Free Software Foundation.
-
-	This program is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-	GNU General Public License for more details.
-
-	You should have received a copy of the GNU General Public License
-	along with this program; if not, write to the Free Software
-	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-*/
-
-#include "config.h"
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <ADM_assert.h>
-
-#include "config.h"
-#include "fourcc.h"
-#include "avio.hxx"
-#include "avi_vars.h"
-
-#include "ADM_toolkit/toolkit.hxx"
-#include "ADM_editor/ADM_edit.hxx"
-#include "ADM_video/ADM_genvideo.hxx"
-#include"ADM_video/ADM_vidField.h"
-#include"ADM_video/ADM_cache.h"
-
-#include "ADM_osSupport/ADM_debugID.h"
-#define MODULE_NAME MODULE_FILTER
-#include "ADM_osSupport/ADM_debug.h"
-
-#include "ADM_osSupport/ADM_cpuCap.h"
-#include "ADM_filter/video_filters.h"
-
-#include "ADM_video/ADM_vidMSharpen_param.h"
-
-class Msharpen : public AVDMGenericVideoStream
-{
-private:
-	MSHARPEN_PARAM	*_param;
-	VideoCache	*vidCache;
-        ADMImage        *blurrImg,*work;
-
-        uint32_t        invstrength;
-
-        void detect_edges(ADMImage *src, ADMImage *dst, unsigned char *dstp, int plane);
-        void blur_plane(ADMImage *src, ADMImage *blur, unsigned char *blurp, int plane) ;
-        void detect_edges_HiQ(ADMImage *src, ADMImage *dst, unsigned char *dstp, int plane);
-        void apply_filter(ADMImage *src,ADMImage *blur, ADMImage *dst, unsigned char *dstp, int plane) ;
-public:    
-
-			Msharpen(AVDMGenericVideoStream *in,CONFcouple *couples)   ;
-			~Msharpen();
-
-
-				 
-	char 		*printConf( void );
-	uint8_t 	configure(AVDMGenericVideoStream *in);
-	uint8_t		getCoupledConf( CONFcouple **couples);
-	uint8_t 	getFrameNumberNoAlloc(uint32_t frame, uint32_t *len, ADMImage *data,uint32_t *flags);
-};
-
-BUILD_CREATE(msharpen_create,Msharpen);
-static FILTER_PARAM msharpenParam={4,{"mask", "highq","threshold", "strength"}};
-
-
-SCRIPT_CREATE(msharpen_script,Msharpen,msharpenParam);
-//_______________________________________________
-
-Msharpen::Msharpen(AVDMGenericVideoStream *in,CONFcouple *couples)
-
-{
-	_in=in;		
-   	memcpy(&_info,_in->getInfo(),sizeof(_info));    
-  	_info.encoding=1;
-	_uncompressed=NULL;		
-  	_info.encoding=1;
-
-
-	_param=new MSHARPEN_PARAM;
-	//
-	if(couples)
-		{
-			GET(mask);
-			GET(highq);
-			GET(strength);	
-			GET(threshold);	
-		}
-		else // Default
-  		{
-			_param->mask=0;       // Show mask
-			_param->highq=1;
-			_param->strength=100;	
-			_param->threshold=15;	
-		}
-                
-		invstrength=255-_param->strength;	
-		blurrImg=new ADMImage(_info.width,_info.height);
-                work=new ADMImage(_info.width,_info.height);
-    		vidCache=new VideoCache(5,in);
-}
-//________________________________________________________
-uint8_t	Msharpen::getCoupledConf( CONFcouple **couples)
-{
-	*couples=NULL;
-	*couples=new CONFcouple(4);
-#define CSET(x)  (*couples)->setCouple((char *)#x,(_param->x))
-		CSET(mask);
-		CSET(highq);
-		CSET(strength);	
-		CSET(threshold);	
-	return 1;
-}
-//________________________________________________________
-Msharpen::~Msharpen(void)
-{
-
-	if(vidCache) delete vidCache;
-	if(_param) delete _param;
-	if(blurrImg) delete blurrImg;
-        if(work) delete work;
-	vidCache=NULL;
-	_param=NULL;
-	blurrImg=NULL;
-        work=NULL;
-}
-extern uint8_t DIA_getMSharpen(MSHARPEN_PARAM *param);
-//________________________________________________________
-uint8_t Msharpen::configure(AVDMGenericVideoStream *in)
-{
-uint8_t r=0;
-	_in=in;
-	ADM_assert(_param);
-	if(r= DIA_getMSharpen(_param))
-        invstrength=255-_param->strength;       
-	return r;
-}
-
-//________________________________________________________
-char *Msharpen::printConf( void )
-{
- 	static char buf[50];
-
-	ADM_assert(_param);
- 	sprintf((char *)buf," Donald Graft Msharpen Strength:%d Threshold:%d",_param->strength,_param->threshold);
-        return buf;
-}
-	
-//________________________________________________________
-uint8_t Msharpen::getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-				ADMImage *data,uint32_t *flags)
-{
-ADMImage *src,*blur,*dst;
-/*
-	PVideoFrame src = child->GetFrame(n, env);
-	PVideoFrame blur = env->NewVideoFrame(vi);
-	PVideoFrame dst = env->NewVideoFrame(vi);
-*/
-unsigned char *blurp;
-unsigned char *dstp;
-	dst=data;
-	if(frame>=_info.nb_frames) return 0;
-	src=vidCache->getImage(frame);
-	blur=blurrImg;
-	{
-		for (int i=0;i<3;i++)
-		{
-		
-			//unsigned char *blurp = blur->GetWritePtr(plane);
-			switch(i)
-			{
-				case 0:blurp=YPLANE(blur);break;
-				case 1:blurp=UPLANE(blur);break;
-				case 2:blurp=VPLANE(blur);break;
-			}
-			blur_plane(src, blur, blurp ,i);
-
-		//	unsigned char *dstp = dst->GetWritePtr(plane);
-			switch(i)
-			{
-				case 0:dstp=YPLANE(dst);break;
-				case 1:dstp=UPLANE(dst);break;
-				case 2:dstp=VPLANE(dst);break;
-			}
-
-			detect_edges(blur, dst, dstp, i);
-			if (_param->highq == true)
-				detect_edges_HiQ(blur, dst, dstp, i);
-
-			if (!_param->mask) apply_filter(src, blur, dst, dstp, i);
-		}
-	}
-
-	vidCache->unlockAll();
-	return 1;
-}
-
-/**********************************
- * MMX / ISSE by Klaus Post and Milan Cutka.
- *
- * Delivers same result as YUY2, except planes
- *  are processed independently.
- *********************************/
-
-void Msharpen::blur_plane(ADMImage *src, ADMImage *blur, unsigned char *blurp, int plane) 
-{
-/*
-  uint64_t mask1 = 0x00001C711C711C71LL;
-  uint64_t mask2 = 0x1C711C711C710000LL;
-  uint64_t mask3 = 0x0000200000002000LL;
-  uint64_t mask4 = 0x0000000000ff0000LL;
-
-  const unsigned char *srcp = src->GetReadPtr(plane);
-	const unsigned char *srcp_saved = srcp;
-	unsigned char *blurp_saved = blurp;
-  int src_pitch = src->GetPitch(plane);
-  int blur_pitch = blur->GetPitch(plane);
-  int h = src->GetHeight(plane);
-  int w = src->GetRowSize(plane);
-*/
-const unsigned char *srcp,*srcpn,*srcpp; 
-const unsigned char *srcp_saved ;
-unsigned char *wk,*wk_saved;
-unsigned char *blurp_saved ;
-int src_pitch;
-int blur_pitch;
-int h;
-int w ;
-int wh ,ww,hh;
- 	blurp_saved=blurp;
-	switch(plane)
-		{
-			case 0:
-				srcp_saved=srcp=YPLANE(src);        
-                                wk_saved=wk=YPLANE(work);
-				ww=_info.width;
-				hh=_info.height;
-				break;
-			case 1:
-				srcp_saved=srcp=UPLANE(src);
-                                wk_saved=wk=UPLANE(work);
-				ww=_info.width>>1;
-				hh=_info.height>>1;
-				break;
-			case 2:
-				srcp_saved=srcp=VPLANE(src);
-                                wk_saved=wk=VPLANE(work);
-				ww=_info.width>>1;
-				hh=_info.height>>1;
-				break;
-		}
-		src_pitch=ww;
-		blur_pitch=ww;
-		w=ww;
-		h=hh;
- 
-  
-  wk+=blur_pitch;
-  srcpp=srcp;
-  srcp+=src_pitch,
-  srcpn=srcp+src_pitch;
-  int val;
-
-  // Vertical only for now      
-#if (defined( ARCH_X86)  || defined(ARCH_X86_64))
-  if(CpuCaps::hasMMX())
-  {
-  int off;
-#ifdef GCC_2_95_X
-        __asm__(
-                        ".align 16\n"
-                        "pxor  %mm7,%mm7\n"
-                : : );
-#else
-        __asm__(
-                        ".align 16\n"
-                        "pxor  %%mm7,%%mm7\n"
-                : : );
-#endif
-                        
-  for (int y=1; y<h-1 ;y++) 
-  {               
-        for (int x =  (w>>3);x>0; x--)
-                {
-                        off=x<<3;                        
-                        __asm__(
-                        ".align 16\n"                      
-                        "movq  (%0),%%mm0\n"
-                        "movq  %%mm0,%%mm6\n"
-                        "punpckhbw %%mm7,%%mm0\n" // High part extended to 16 bits
-                        "punpcklbw %%mm7,%%mm6\n" // low part ditto
-                        
-                        "movq  (%1),%%mm1\n"
-                        "movq  %%mm1,%%mm5\n"
-                        "punpckhbw %%mm7,%%mm1\n"
-                        "punpcklbw %%mm7,%%mm5\n"
-                        
-                        "movq  (%2),%%mm2\n"
-                        "movq  %%mm2,%%mm4\n"
-                        "punpckhbw %%mm7,%%mm2\n"
-                        "punpcklbw %%mm7,%%mm4\n"
-                        
-                        "paddw %%mm1,%%mm0\n"
-                        "paddw %%mm5,%%mm6\n"
-                        
-                        "paddw %%mm1,%%mm2\n"
-                        "paddw %%mm5,%%mm4\n"
-                        
-                        "paddw %%mm0,%%mm2\n"
-                        "paddw %%mm6,%%mm4\n"
-                        "psrlw $2, %%mm4\n"
-                        "psrlw $2, %%mm2\n"
-                        "packuswb %%mm2,%%mm4\n"
-                        "movq %%mm4,(%3)\n" //
-                        
-                        : : "r" (srcpn+off),
-                           "r" (srcp+off), "r" (srcpp+off), "r" (wk+off)
-                        );
-                }                        
-        srcp+=src_pitch;
-        srcpp+=src_pitch;
-        srcpn+=src_pitch;
-        wk+=src_pitch;     
-  }
-  __asm__("emms\n");
- }
- else
-#endif      
-  {
-  for (int y=1; y<h-1 ;y++) 
-  {       
-
-        for(int x=0;x<w;x++)
-        {
-                val=srcp[x]+srcpn[x]+srcpp[x]+srcp[x];
-                wk[x]=(val)>>2;
-        } 
-        srcp+=src_pitch;
-        srcpp+=src_pitch;
-        srcpn+=src_pitch;
-        wk+=src_pitch;     
-  }
-  }
-  //************ Horizontal****************
-  blurp=blurp_saved;
-  srcp=wk_saved;
-  for (int y=1; y<h-1 ;y++) 
-  {         
-        for(int x=1;x<w-1;x++)
-        {
-                val=srcp[x-1]+srcp[x]+srcp[x+1]+srcp[x];
-                blurp[x]=val>>2;
-        } 
-        srcp+=src_pitch;
-        srcpp+=src_pitch;
-        srcpn+=src_pitch;
-        blurp+=src_pitch;     
-  }
-  //******************
-        /* Fix up blur frame borders. */
-        srcp = srcp_saved;
-        blurp = blurp_saved;
-        memcpy(blurp, srcp, w);
-        memcpy(blurp + (h-1)*blur_pitch, srcp + (h-1)*src_pitch, w);
-        for (int y = 0; y < h; y++)
-        {
-                blurp[0] = srcp[0];
-                blurp[w-1] = srcp[w-1];
-                srcp += src_pitch;
-                blurp += blur_pitch;
-        }
-
-}
-#if 0
-    __asm {
-      mov esi, srcp  // esi=srcpp
-      mov ecx, blurp
-      mov ebx, src_pitch
-      mov edi, esi 
-      mov edx, esi 
-      add edi, ebx // edi=srcp+pitch=srcp
-      add edx, ebx 
-      add edx, ebx  //edx=srcp+2*pitch=srcpn
-      xor eax, eax
-      movq mm7,mask1 // mm7 mask1
-      movq mm6,mask2 // mm6 mask2
-     align 16
-xloop:
-      movd mm0,[esi+eax]  //srcpp[x}
-      pxor mm5,mm5
-       movd mm1,[edi+eax] //srcp[x}
-      movd mm2,[edx+eax]  // srcpn   
-      punpcklbw mm0,mm5  // mm0 low srcpp
-      punpcklbw mm1,mm5   // mm1 low srcp
-      movq mm3, mm0
-      punpcklbw mm2,mm5   // mm2 low srcn
-      movq mm4, mm1
-      movq mm5, mm2
-      paddw mm0,mm1     // srcp+srcpp
-      paddw mm3,mm4   // 2*srcp+srcpp
-      paddw mm0,mm2    // 2*srcp+srcpp+srcn
-      paddw mm3,mm5   // idem
-      pmaddwd mm0,mm7
-       movq mm5,[mask3]
-      pmaddwd mm3,mm6
-       pshufw mm1,mm0, 11101110b  // Move upper to lower
-      pshufw mm4,mm3, 11101110b   
-       paddd mm0,mm1
-      paddd mm3,mm4
-       paddd mm0, mm5
-      paddd mm3, mm5
-       psrld mm0,16
-      pand mm3,[mask4]
-      psrld mm3,8
-      por mm0,mm3
-      movd [eax+ecx],mm0  // blurp[i]
-      add eax,2
-      cmp eax,[w]
-      jle xloop;
-    }
-    srcp += src_pitch;
-    blurp += blur_pitch;
-//      __asm emms;
-#endif
- 
-
-//***************************************************
-void Msharpen::detect_edges(ADMImage *src, ADMImage *dst, unsigned char *dstp, int plane) 
-{
-  static uint64_t m255=0xffffffffffffffffLL;
-  static uint64_t threshold64;
-  int ww,hh;
-
-  threshold64=_param->threshold;
-  if(!threshold64) threshold64=1;
-  threshold64=threshold64+(threshold64<<8)+(threshold64<<16)+(threshold64<<24)+(threshold64<<32)+(threshold64<<40)+(threshold64<<48)+(threshold64<<56);
-/*
-  const unsigned char *srcp = src->GetReadPtr(plane);
-  int src_pitch = src->GetPitch(plane);
-  int dst_pitch = dst->GetPitch(plane);
-  const unsigned char *srcpn = srcp+src_pitch;
-  int h = src->GetHeight(plane);
-  int w = src->GetRowSize(plane);
-*/
-  const unsigned char *srcp,*srcp_saved; 
-  int src_pitch ;
-  int dst_pitch ; 
-  const unsigned char *srcpn; 
-  int h ;
-  int w ;
-  unsigned char *dstp_saved = dstp;
-
-  switch(plane)
-	{
-		case 0: srcp=YPLANE(src);
-			ww=_info.width;
-			hh=_info.height;
-			break;
-		case 2:
-		case 1:
-			if(plane==1) 	
-				srcp=UPLANE(src);
-			else
-				srcp=VPLANE(src);
-			ww=_info.width>>1;
-			hh=_info.height>>1;
-			break;
-		default:
-			ADM_assert(0);
-	}
-	src_pitch=ww;
-	dst_pitch=ww;
-	w=ww;
-	h=hh;
-	srcpn=srcp+src_pitch;
-	srcp_saved=srcp;
-
- int p,n,c;
- for (int y=0;y<h-1;y++)
-  {
-   for(int xx=1;xx<w-1;xx++)
-        {
-                p=srcp[xx+1];
-                n=srcpn[xx+1];
-                c=srcpn[xx-1];
-                
-                if(abs(n-p)>_param->threshold || abs(c-p)>_param->threshold) dstp[xx+1]=0xff;
-                                else dstp[xx+1]=0;
-                
-        }
-   srcp+=src_pitch;
-   srcpn+=src_pitch;
-   dstp+=dst_pitch;
-  }
-  if (_param->mask) {
-    dstp=dstp_saved;
-    memset(dstp_saved+(h-1)*dst_pitch,0,w);  // Not used, if not returning mask
-    for (int y=0;y<h;dstp+=dst_pitch,y++) {
-      dstp[0]=0;
-      dstp[1]=0;
-      dstp[w-1]=0;
-      dstp[w-2]=0;
-    }
-  }
-}
-#if 0
-unsigned char *dstpend=dstp+w-1;
-   __asm 
-    {
-     mov esi,[srcp]
-     inc esi
-     mov ecx,[srcpn]
-     inc ecx
-     mov edx,[srcpn]
-     dec edx
-     mov edi,[dstp]
-     inc edi
-     mov eax,[dstpend]
-     movq mm6,[threshold64]
-     pxor mm5,mm5
-     movq mm4,[m255]
-     align 16
-    diag1:
-     movq mm2,[ecx]
-      movq mm1,[esi]
-     movq mm3,[edx]
-
-     //abs(mm1-mm2)
-      movq mm7,mm1
-     pminub mm1,mm2  //srcpn+1 - srcp+1
-      pmaxub mm2,mm7
-     psubusb mm2,mm1
-      movq mm1,[esi]
-     psubusb mm2,mm6
-     
-     //abs(mm1-mm3)
-      movq mm7,mm1
-     pminub mm1,mm3 // srcp+1 srcp-1
-      pmaxub mm3,mm7
-     psubusb mm3,mm1
-     psubusb mm3,mm6
-
-     por     mm2,mm3
-     pcmpeqb mm2,mm5
-     pxor    mm2,mm4
-     movq    [edi],mm2
-     
-     add esi,8
-     add ecx,8
-     add edx,8
-     add edi,8
-     cmp edi,eax
-     jl  diag1
-
-   }
-__asm emms;
-#endif
-//***************************************************
-void Msharpen::detect_edges_HiQ(ADMImage *src, ADMImage *dst, unsigned char *dstp, int plane) 
-{
-  // Vertical detail detection
-/*
-  const unsigned char *srcp = src->GetReadPtr(plane);
-	const unsigned char *srcp_saved = srcp;
-  const unsigned char *srcpn;
-	unsigned char *dstp_saved = dstp;
-  int src_pitch = src->GetPitch(plane);
-  int dst_pitch = dst->GetPitch(plane);
-  int h = src->GetHeight(plane);
-  int w = src->GetRowSize(plane);
-*/
-
-  int b1,b2;
-  int ww,hh;
- const unsigned char *srcp,*srcp_saved; 
-  int src_pitch ;
-  int dst_pitch ; 
-  const unsigned char *srcpn; 
-  int h ;
-  int w ;
-  unsigned char *dstp_saved = dstp;
-
-  switch(plane)
-	{
-		case 0: srcp=YPLANE(src);
-			ww=_info.width;
-			hh=_info.height;
-			break;
-		case 2:
-		case 1:
-			if(plane==1) 	
-				srcp=UPLANE(src);
-			else
-				srcp=VPLANE(src);
-			ww=_info.width>>1;
-			hh=_info.height>>1;
-			break;
-		default:
-			ADM_assert(0);
-	}
-	src_pitch=ww;
-	dst_pitch=ww;
-	w=ww;
-	h=hh;
-	srcpn=srcp+src_pitch;
-	srcp_saved=srcp;
-
-  for (int x=0;x<w;x++)
-  {
-    srcp=srcp_saved;
-    srcpn=srcp+src_pitch;
-    dstp=dstp_saved;
-    b1=srcp[x];
-    for (int y=0;y<h-1;dstp+=dst_pitch,srcp+=src_pitch,srcpn+=src_pitch,y++)
-    {
-      b2=srcpn[x];
-      if (abs(b1-b2)>=_param->threshold)
-        dstp[x]=255;
-      b1=b2;
-    }
-  }
-  
-  // Horizontal detail detection
-  srcp=srcp_saved;
-  dstp=dstp_saved;
-  for (int y=0;y<h;dstp+=dst_pitch,srcp+=src_pitch,y++)
-  {
-    b1=srcp[0]; //MEANX srcp[x]
-    for (int x=0;x<w-1;x++)
-    {
-      b2=srcp[x+1];
-      if (abs(b1-b2)>=_param->threshold)
-        dstp[x]=255;
-      b1=b2;
-    }
-  }
-  // Fix up detail map borders
-  dstp = dstp_saved;
-  memset(dstp,0,w);
-  memset(dstp+dst_pitch,0,w);
-  memset(dstp+(h-2)*dst_pitch,0,w);
-  memset(dstp+(h-1)*dst_pitch,0,w);
-  for (int y=0;y<h;dstp+=dst_pitch,y++)
-  {
-    dstp[0]=0;
-    dstp[1]=0;
-    dstp[w-1]=0;
-    dstp[w-2]=0;
-  }
-}
-//***************************************************
-void Msharpen::apply_filter(ADMImage *src,ADMImage *blur, ADMImage *dst, unsigned char *dstp, int plane) 
-{
-  // TODO: MMX / ISSE
-/*
-  const unsigned char *srcp = src->GetReadPtr(plane);
-  const unsigned char *blurp = blur->GetReadPtr(plane);
-  const unsigned char *srcp_saved = srcp;
-  unsigned char *dstp_saved = dstp;
-  const unsigned char *blurp_saved = blurp;
-  int src_pitch = src->GetPitch(plane);
-  int blur_pitch = blur->GetPitch(plane);
-  int dst_pitch = dst->GetPitch(plane);
-  int h = src->GetHeight(plane);
-  int w = src->GetRowSize(plane);
- */
-  const unsigned char *srcp ;
-  const unsigned char *blurp ;
-  const unsigned char *srcp_saved; 
-  unsigned char *dstp_saved ;
-  const unsigned char *blurp_saved ;
-  int src_pitch;
-  int blur_pitch;
-  int dst_pitch;
-  int h;
-  int w;
-  int ww,hh; 
-
-  switch(plane)
-	{
-		case 0:
-			 srcp=YPLANE(src);
-			 blurp=YPLANE(blur);
-			 ww=_info.width;
-			 hh=_info.height;
-			 break;
-		case 1:
-		case 2:
-			if(plane==1)
-			{
-			 srcp=UPLANE(src);
-			 blurp=UPLANE(blur);
-			}
-			else
-			{
-			 srcp=VPLANE(src);
-			 blurp=VPLANE(blur);
-			}
-			 ww=_info.width>>1;
-			 hh=_info.height>>1;
-			break;
-	}
-
-	w=ww;
-	h=hh;
-	blur_pitch=ww;
-	dst_pitch=ww;
-	src_pitch=ww;
-	srcp_saved=srcp;
-	blurp_saved=blurp;
-	dstp_saved=dstp;
-	
-  memcpy(dstp,srcp,w);
-  memcpy(dstp+(h-1)*dst_pitch,srcp+(h-1)*src_pitch,w);
-  for (int y=0;y<h;srcp+=src_pitch,dstp+=dst_pitch,y++)
-  {
-    dstp[0]=srcp[0];
-    dstp[w-1]=srcp[w-1];
-  }
-  
-  // Now sharpen the edge areas and we're done
-  srcp=srcp_saved+src_pitch;
-  dstp=dstp_saved+dst_pitch;
-  blurp=blurp+dst_pitch;
-  int b4;
-  for (int y=1;y<h-1;srcp+=src_pitch,dstp+=dst_pitch,blurp+=blur_pitch,y++)
-  {
-    for (int x=1;x<w-1;)
-    {
-      if (*(int*)(dstp+x)==0) 
-      {
-        *(int*)(dstp+x)=*(int*)(srcp+x);
-        x+=4;
-        continue;
-      }
-      if (dstp[x])
-      {                                     
-        b4=4*int(srcp[x])-3*int(blurp[x]);
-        if (b4<0) b4=0; else if (b4>255) b4=255;
-        dstp[x]=(_param->strength*b4+invstrength*srcp[x])>>8;
-      }
-      else
-        dstp[x]=srcp[x];
-      x++; 
-    }  
-    dstp[w-1]=srcp[w-1]; 
-  }   
-}
-//***************************************************
-
-
-
-
-

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMSharpen_param.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMSharpen_param.h	2007-01-11 19:18:08 UTC (rev 2704)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMSharpen_param.h	2007-01-11 20:41:19 UTC (rev 2705)
@@ -1,7 +0,0 @@
-typedef struct MSHARPEN_PARAM
-{
-	uint32_t  mask;
-	uint32_t  highq;
-	uint32_t  threshold;
-        uint32_t  strength;
-};

Modified: branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am	2007-01-11 19:18:08 UTC (rev 2704)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am	2007-01-11 20:41:19 UTC (rev 2705)
@@ -15,7 +15,6 @@
  ADM_vidPartial.cpp \
  ADM_vidFont.cpp \
  ADM_vidSRT.cpp \
- ADM_vidDenoise.cpp \
 	ADM_vidFlipV.cpp \
  ADM_vidStabilize.cpp \
  ADM_vidContrast.cpp \
@@ -57,7 +56,6 @@
  ADM_vidSRTload.cpp \
  ADM_vidlavdeint.cpp \
 	ADM_mpdetc.cpp \
- ADM_vidForcedPP.cpp \
  ADM_vidDecTelecide.cpp \
  ADM_vidDecTelecide.h ADM_cache.cpp \
  ADM_vidDecDec.cpp \
@@ -70,7 +68,6 @@
  ADM_vidHue.cpp \
  ADM_vidEq2.cpp \
  ADM_vidDGbob.cpp \
- ADM_vidMSharpen.cpp \
  ADM_vidAsharp.cpp \
  ADM_vidCNR2.cpp \
   ADM_vidDelta.cpp \
@@ -98,8 +95,8 @@
 ADM_genvideo.hxx ADM_vidDeinterlace.cpp  ADM_vidPartial.cpp \
 ADM_vidDeinterlace.h  ADM_vidPartial.h \
 ADM_vidDelta.cpp  ADM_vidPartial_param.h \
-ADM_guiCrop.cpp  ADM_vidDenoise.cpp  ADM_vidPulldown.cpp \
-ADM_vidDenoise.h  ADM_vidPulldown.h \
+ADM_guiCrop.cpp    ADM_vidPulldown.cpp \
+ ADM_vidPulldown.h \
 ADM_guiResize.cpp  ADM_vidDropOut.cpp  ADM_vidRaw.cpp \
 ADM_interlaced.cpp ADM_vidDropOut.h  \
 ADM_interlaced.h ADM_vidEq2.cpp  ADM_vidResize.cpp \
@@ -120,8 +117,8 @@
 ADM_vidAsharp.cpp   ADM_vidStabilize.cpp \
 ADM_vidFont.cpp ADM_vidStabilize.h \
 ADM_vidBlend.cpp ADM_vidFont.h ADM_vidSwapFields.cpp \
-ADM_vidBlendRemoval.cpp  ADM_vidForcedPP.cpp ADM_vidSwapFields.h \
-ADM_vidBlendRemoval_param.h  ADM_vidForcedPP.h ADM_vidSwapSmart.cpp \
+ADM_vidBlendRemoval.cpp  ADM_vidSwapFields.h \
+ADM_vidBlendRemoval_param.h  ADM_vidSwapSmart.cpp \
 ADM_vidCNR2.cpp  ADM_vidHardIvtcRemoval.cpp  ADM_vidSwapSmart.h \
 ADM_vidCNR2_param.h  ADM_vidHue.cpp  ADM_vidTDeint_param.h \
 ADM_vidCached.cpp  ADM_vidHue.h  ADM_vidTdeint.cpp \
@@ -140,8 +137,8 @@
 ADM_vidCommonFilter.h  ADM_vidMPLResize.cpp  ADM_vidVobsub.cpp \
 ADM_vidContrast.cpp  ADM_vidMPdelogo.cpp ADM_vidWirl.cpp \
 ADM_vidContrast.h  ADM_vidMPdelogo.h ADM_vidlavdeint.cpp \
-ADM_vidConvolution.cpp ADM_vidMSharpen.cpp ADM_vidlavdeint.h \
-ADM_vidConvolution.hxx ADM_vidMSharpen_param.h ADM_vobsubinfo.cpp \
+ADM_vidConvolution.cpp  ADM_vidlavdeint.h \
+ADM_vidConvolution.hxx  ADM_vobsubinfo.cpp \
 ADM_vidCrop.cpp  ADM_vidMSmooth_param.h  ADM_vobsubinfo.h \
 ADM_vidDGbob.cpp ASM_vidDenoise.cpp \
 ADM_vidDGbob_param.h   \
@@ -153,6 +150,6 @@
 INCLUDES = $(all_includes) -I../ADM_libraries -I../ADM_libraries/ADM_utilities -I../ADM_libraries/ADM_lavutil \
 			 $(FREETYPE_CFLAGS) $(ALTIVEC_SWITCH) -I../ADM_userInterfaces/ADM_commonUI -I../ADM_inputs
 noinst_HEADERS = ADM_vidlavdeint.h ADM_mpdetc.h \
-					ADM_vidForcedPP.h  ADM_cache.h ADM_vidDecTel_param.h ADM_vidDecDec_param.h \
+					  ADM_cache.h ADM_vidDecTel_param.h ADM_vidDecDec_param.h \
 					ADM_vidMSmooth_param.h ADM_vidEqualizer.h ADM_vobsubinfo.h ADM_vidVobSub.h \
 		ADM_vidEq2.h ADM_vidASS.h

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDenoise.cpp (from rev 2545, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDenoise.cpp)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDenoise.cpp	2006-11-04 15:58:52 UTC (rev 2545)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDenoise.cpp	2007-01-11 20:41:19 UTC (rev 2705)
@@ -0,0 +1,402 @@
+/***************************************************************************
+                          ADM_vidDenoise.cpp  -  description
+                             -------------------
+    begin                : Mon Nov 25 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+    
+    Denoiser inspired from DNR in transcode
+    Ported to YV12 and simplified
+    
+   Original code  Copyright (C) Gerhard Monzel - November 2001
+ 
+    
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ADM_assert.h>
+#include <math.h>
+
+#include "config.h"
+#include "fourcc.h"
+#include "avio.hxx"
+#include "config.h"
+#include "avi_vars.h"
+
+
+#include "ADM_toolkit/toolkit.hxx"
+#include "ADM_editor/ADM_edit.hxx"
+#include "ADM_video/ADM_genvideo.hxx"
+#include "ADM_vidDenoise.h"
+#include "ADM_filter/video_filters.h"
+
+
+#include "ADM_userInterfaces/ADM_commonUI/DIA_factory.h"
+
+static FILTER_PARAM denoiseParam={5,{"lumaLock","lumaThreshold","chromaLock","chromaThreshold",
+					"sceneChange"}};
+
+
+SCRIPT_CREATE(denoise_script,ADMVideoDenoise,denoiseParam);
+
+uint8_t distMatrix[256][256];
+uint32_t fixMul[16];
+
+//static uint8_t matrixReady=0;
+//static uint8_t doOnePix(uint8_t *in,uint8_t *out,uint8_t *lock,uint8_t *nb);
+
+BUILD_CREATE(denoise_create,ADMVideoDenoise);
+char *ADMVideoDenoise::printConf( void )
+{
+ 	static char buf[50];
+
+  ADM_assert(_param); 	
+ 	sprintf((char *)buf," Denoise : Lum :%02ld/:%02ld / Chm :%02ld/%02ld",
+  								_param->lumaLock,
+          				_param->lumaThreshold,
+              		_param->chromaLock,
+                	_param->chromaThreshold);
+        return buf;
+}
+void buildDistMatrix( void );
+void buildDistMatrix( void )
+{
+int d;	
+	for(uint32_t y=255;y>0;y--)
+	for(uint32_t x=255;x>0;x--)
+	{
+		  d=x-y;
+		  if(d<0) d=-d;
+		  distMatrix[x][y]=d;
+		
+	}
+
+	 for(int i=1;i<16;i++)
+                        {
+                                        fixMul[i]=(1<<16)/i;
+                        }
+
+}
+
+//_______________________________________________________________
+
+ADMVideoDenoise::ADMVideoDenoise(
+									AVDMGenericVideoStream *in,CONFcouple *couples)
+{
+
+
+  	_in=in;		
+   	memcpy(&_info,_in->getInfo(),sizeof(_info));  			 	
+    uint32_t page;
+    
+  _info.encoding=1;
+  
+  page= _in->getInfo()->width*_in->getInfo()->height;
+  
+//  _uncompressed=new uint8_t [page];
+  _uncompressed=new ADMImage(_in->getInfo()->width,_in->getInfo()->height);
+  ADM_assert(_uncompressed);
+  
+ // _locked=new uint8_t [page];
+  _locked=new ADMImage(_in->getInfo()->width,_in->getInfo()->height);
+  ADM_assert(_locked);
+ 
+//	_lockcount=new uint8_t [page];
+
+
+  
+   _lockcount=new ADMImage(_in->getInfo()->width,_in->getInfo()->height);
+  memset(YPLANE(_lockcount),0,page);  
+  memset(UPLANE(_lockcount),0,page>>2);  
+  memset(VPLANE(_lockcount),0,page>>2);  
+        
+  _param=NULL;
+  
+  if(couples)
+  	{
+			_param=NEW(NOISE_PARAM);
+			GET(lumaLock);
+			GET(lumaThreshold);
+			GET(chromaLock);
+			GET(chromaThreshold);
+			GET(sceneChange);
+		 }
+	else
+		{
+			  #define XXX 1
+			  _param=NEW(NOISE_PARAM);
+			  _param->lumaLock=  4*XXX;
+			  _param->lumaThreshold= 10*XXX;
+			  _param->chromaLock=  8*XXX;
+			  _param->chromaThreshold= 16*XXX;
+        _param->sceneChange=  30*XXX;
+			}
+  	  _lastFrame=0xfffffff0;	
+}
+
+
+uint8_t	ADMVideoDenoise::getCoupledConf( CONFcouple **couples)
+{
+
+			ADM_assert(_param);
+			*couples=new CONFcouple(5);
+
+#define CSET(x)  (*couples)->setCouple((char *)#x,(_param->x))
+	CSET(lumaLock);
+	CSET(lumaThreshold);
+	CSET(chromaLock);
+	CSET(chromaThreshold);
+	CSET(sceneChange);
+
+	return 1;
+
+}
+ADMVideoDenoise::~ADMVideoDenoise()
+{
+ 	
+	delete  _uncompressed;
+ 	delete  _locked;
+  	delete  _lockcount;
+  DELETE(_param);
+  
+  _uncompressed=_locked=_lockcount=NULL;
+}
+
+//
+//	Remove y and v just keep U and expand it
+//
+uint8_t ADMVideoDenoise::getFrameNumberNoAlloc(uint32_t frame,
+				uint32_t *len,
+   				ADMImage *data,
+				uint32_t *flags)
+{
+   //uint32_t x,w;
+  	uint32_t page; 
+   		ADM_assert(_param);
+		ADM_assert(frame<_info.nb_frames);
+								
+			
+       		if(!_in->getFrameNumberNoAlloc(frame, len,_uncompressed,flags)) return 0;
+
+		
+		page=_info.width*_info.height;  
+		*len=(page*3)>>1;           
+
+	if((_lastFrame+1)!=frame) // async jump
+	{
+			// just copy it 
+			memcpy(YPLANE(data),YPLANE(_uncompressed),page);
+			memcpy(UPLANE(data),UPLANE(_uncompressed),page>>2);
+			memcpy(VPLANE(data),VPLANE(_uncompressed),page>>2);
+			
+			memcpy(YPLANE(_locked),YPLANE(_uncompressed),page);
+			memcpy(UPLANE(_locked),UPLANE(_uncompressed),page>>2);
+			memcpy(VPLANE(_locked),VPLANE(_uncompressed),page>>2);
+			
+			_lastFrame=frame;
+			return 1;
+	}          
+	_lastFrame=frame;
+          
+          // copy chroma for now
+        
+         
+          
+          //
+          //uint32_t count=0;
+          //uint32_t cell=page*4; // size of luma
+          uint8_t *in,*out,*lock,*nb;
+          uint8_t *uin,*uout,*ulock,*unb;
+          uint8_t *vin,*vout,*vlock,*vnb;
+          
+          
+          //uint32_t d;
+          // init all
+          
+          // luma
+          nb=YPLANE(_lockcount);
+          lock=YPLANE(_locked);
+          in=YPLANE(_uncompressed);
+          out=YPLANE(data);
+          // u
+          unb=UPLANE(_lockcount);
+          ulock=UPLANE(_locked);
+          uin=UPLANE(_uncompressed);
+          uout=UPLANE(data);
+          // v
+          vnb=VPLANE(_lockcount);
+          vlock=VPLANE(_locked);
+          vin=VPLANE(_uncompressed);
+          vout=VPLANE(data);
+          
+          
+          uint32_t xx,yy/*,dl*/,du,dv;
+          uint32_t locked=0;
+          for(yy=_info.height>>1;yy>0;yy--)
+          {
+	          for(xx=_info.width>>1;xx>0;xx--)          
+  	        {
+			du=distMatrix[*uin][*ulock];	
+			dv=distMatrix[*vin][*vlock];		
+						
+			// if chroma is locked , we try to lock luma
+			if( (du<_param->chromaLock)
+				 && (dv<_param->chromaLock))
+			 {  
+				*uout=*ulock;
+ 				*vout=*vlock;
+
+#define PIX(z) 		doOnePix(in+z,out+z,lock+z,nb+z) 
+				locked+=PIX(0)+	PIX(1)+ PIX(_info.width)+PIX(_info.width+1);
+			}
+			else
+			 // if chroma is blended, we blend luma
+#undef PIX								  
+#define PIX(z) 		doBlend(in+z,out+z,lock+z,nb+z)									 
+				if( (du<_param->chromaThreshold)
+					 && (dv<_param->chromaThreshold))
+				{
+			 		PIX(0);
+				    	PIX(1);
+				     	PIX(_info.width);
+				     	PIX(_info.width+1);	
+				      *uout=*ulock=(*uin+*uin)>>1;
+ 					*vout=*vlock=(*vin+*vin)>>1;
+				}
+#undef PIX											
+										
+			else
+			{
+#define PIX(z) *(out+z)=*(lock+z)=*(in+z);*(nb+z)=0			
+											
+				PIX(0);
+				PIX(1);
+				PIX(_info.width);
+				PIX(_info.width+1);		
+				*uout=*ulock=*uin;
+ 				*vout=*vlock=*vin;
+				
+#undef PIX		
+			}
+								  
+											                        				                        
+			uin++;uout++;ulock++;unb++;   
+			vin++;vout++;vlock++;vnb++;   
+			in++;out++;lock++;nb++;   
+			in++;out++;lock++;nb++;   
+							
+		}
+            // 
+            in+=_info.width;
+            out+=_info.width;
+            lock+=_info.width;
+            nb+=_info.width;            						
+	};
+          
+          if(locked>((page*3)>>2)) // if more than 75% pixel not locked -> scene change
+          {
+			memcpy(YPLANE(data),YPLANE(_uncompressed),page);
+			memcpy(UPLANE(data),UPLANE(_uncompressed),page>>2);
+			memcpy(VPLANE(data),VPLANE(_uncompressed),page>>2);
+			
+			memcpy(YPLANE(_locked),YPLANE(_uncompressed),page);
+			memcpy(UPLANE(_locked),UPLANE(_uncompressed),page>>2);
+			memcpy(VPLANE(_locked),VPLANE(_uncompressed),page>>2);
+	}
+      data->copyInfo(_uncompressed);  
+      return 1;
+}
+
+//
+//	0 copy
+//  1 lock
+//  2 threshold
+//
+uint8_t ADMVideoDenoise::doOnePix(uint8_t *in,uint8_t *out,uint8_t *lock,uint8_t *nb)
+{
+unsigned int d;
+		d=distMatrix[*(in)][*(lock)]; 
+		if(d<_param->lumaLock)         
+		{								                
+			if(*(nb)>30)  // out of scope -> copy new                   
+			{  	// too much copy ->                              
+				*(nb)=0;                       
+				*(out)=(*(in)+*(lock))>>1;
+				*(lock)=*(out);    	
+				return DN_COPY;      
+			}                                 
+			else                               
+			{                                   
+				*(out)=*(lock);		
+				*nb += 1; // *(nb)++;	
+				return DN_LOCK;		
+			}                  
+		}                     
+		else if(d< _param->lumaThreshold) 
+			{                                  
+				 *(nb)=0;                           
+				*(out)=(*(in)+*(lock))>>1;	
+				return DN_BLEND;
+			}
+			else   // too big delta
+			{    
+				 *(nb)=0; 
+				*(out)=*(in);	  
+				*(lock)=*(in);    
+				return DN_COPY;
+			}                     
+					                           
+			ADM_assert(0);
+			return 0;
+
+}
+uint8_t ADMVideoDenoise::doBlend(uint8_t *in,uint8_t *out,uint8_t *lock,uint8_t *nb)
+{
+unsigned int d;
+		   d=distMatrix[*(in)][*(lock)]; 
+		   *nb=0;
+		   
+			if(d<_param->lumaThreshold)         
+			{
+					*(out)=(*(in)+*(lock))>>1;					
+			}
+			else
+			*out=*in;
+			return 0;
+	
+}
+extern uint8_t DIA_dnr(uint32_t *llock,uint32_t *lthresh, uint32_t *clock,
+			uint32_t *cthresh, uint32_t *scene);
+
+
+uint8_t ADMVideoDenoise::configure(AVDMGenericVideoStream * instream)
+{
+  UNUSED_ARG(instream);
+  
+#define PX(x) &(_param->x)
+  
+    diaElemUInteger   lumaLock(PX(lumaLock),_("Luma Lock"),0,255);
+    diaElemUInteger   chromaLock(PX(chromaLock),_("Chroma  Lock"),0,255);
+    diaElemUInteger   lumaThreshold(PX(lumaThreshold),_("Luma Threshold"),0,255);
+    diaElemUInteger   chromaThreshold(PX(chromaThreshold),_("Chroma Threshold"),0,255);
+    
+    diaElemUInteger   sceneChange(PX(sceneChange),_("Scene Change"),0,100);
+    
+    
+    
+       diaElem *elems[5]={&lumaLock,&chromaLock,&lumaThreshold,&chromaThreshold,&sceneChange};
+  
+   return diaFactoryRun("Denoise",5,elems);
+}
+
+// EOF

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDenoise.h (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDenoise.h)

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidForcedPP.cpp (from rev 2530, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidForcedPP.cpp)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidForcedPP.cpp	2006-11-01 11:17:21 UTC (rev 2530)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidForcedPP.cpp	2007-01-11 20:41:19 UTC (rev 2705)
@@ -0,0 +1,232 @@
+//
+// C++ Implementation: ADM_vidForcedPP
+//
+// Description: 
+//
+//	Force postprocessing assuming constant quant & image type
+//	Uselefull on some badly authored DVD for example
+//
+// Author: mean <fixounet at free.fr>, (C) 2004
+//
+// Copyright: See COPYING file that comes with this distribution
+//
+//
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ADM_assert.h>
+#include <math.h>
+#include <math.h>
+#include <iconv.h>
+#include "config.h"
+
+
+#include "fourcc.h"
+#include "avio.hxx"
+
+#include "avi_vars.h"
+
+#include "ADM_toolkit/toolkit.hxx"
+#include "ADM_editor/ADM_edit.hxx"
+#include "ADM_video/ADM_genvideo.hxx"
+
+#include "ADM_osSupport/ADM_debugID.h"
+#define MODULE_NAME MODULE_FILTER
+#include "ADM_osSupport/ADM_debug.h"
+
+
+
+#include "ADM_vidForcedPP.h"
+#include "DIA_enter.h"
+#include "ADM_filter/video_filters.h"
+
+#include "ADM_userInterfaces/ADM_commonUI/DIA_factory.h"
+
+static FILTER_PARAM ppParam={3,{"postProcType","postProcStrength","forcedQuant"}};
+
+
+SCRIPT_CREATE(forcedpp_script,ADMVideoForcedPP,ppParam);
+BUILD_CREATE(forcedpp_create,ADMVideoForcedPP);
+
+extern int DIA_getMPParams( uint32_t *pplevel, uint32_t *ppstrength,uint32_t *swap);
+
+uint8_t ADMVideoForcedPP::configure( AVDMGenericVideoStream *instream)
+{
+	_in=instream;
+        
+        #define PX(x) &(_param->x)
+  
+        
+    diaElemUInteger   postProcStrength(PX(postProcStrength),_("Filter Strength"),0,5);
+    diaElemUInteger   quant(PX(forcedQuant),_("Quantizer"),1,31);
+    //diaElemToggle     swapuv(PX(swapuv),_("Swap U&V"));
+    
+    uint32_t hzd,vzd,dring;
+    
+#define DOME(x,y) if(_param->postProcType & x) y=1;else y=0;
+    
+    DOME(1,hzd);
+    DOME(2,vzd);
+    DOME(4,dring);
+    
+     diaElemToggle     fhzd(&hzd,_("Horizontal Deblocking"));
+     diaElemToggle     fvzd(&vzd,_("Vertical Deblocking"));
+     diaElemToggle     fdring(&dring,_("Deringing"));
+    
+    
+    
+      diaElem *elems[5]={&postProcStrength,&quant,&fhzd
+                        ,&fvzd,&fdring};
+
+   if(diaFactoryRun("Forced PostProcessing",5,elems))
+  {
+#undef DOME
+#define DOME(x,y) if(y) _param->postProcType |=x;
+    _param->postProcType =0;
+    DOME(1,hzd);
+    DOME(2,vzd);
+    DOME(4,dring);
+    updatePostProc(&_postproc );	
+    return 1;
+  }
+  return 0;	
+ 	
+}
+uint8_t	ADMVideoForcedPP::getCoupledConf( CONFcouple **couples)
+{
+
+			*couples=new CONFcouple(3);
+
+			CSET(postProcType);
+			CSET(postProcStrength);
+			CSET(forcedQuant);
+
+		return 1;	
+}
+char *ADMVideoForcedPP::printConf( void )
+{
+ 	static char buf[50];
+ 	
+ 	sprintf((char *)buf," Forced pp : %lu %lu",_param->postProcType,_param->postProcStrength);
+        return buf;
+}
+
+ADMVideoForcedPP::~ADMVideoForcedPP()
+{
+	if(_uncompressed)
+ 		delete _uncompressed;
+	if(_postproc.ppContext)
+		deletePostProc(&_postproc);
+
+ 	_uncompressed=NULL;
+}
+
+
+ ADMVideoForcedPP::ADMVideoForcedPP( AVDMGenericVideoStream *in,CONFcouple *couples)
+{
+		printf("Adding forced PP filter\n");
+		_uncompressed=NULL;
+		_in=in;
+		ADM_assert(in);
+		if(!couples)
+		{
+			
+			_param=NEW(PP_CONF);
+	    		_param->postProcType=7; // all
+	    		_param->postProcStrength=5;
+			_param->forcedQuant=10;
+			
+	    	}
+		else
+		{
+			_param=NEW(PP_CONF);
+			GET(postProcType);
+			GET(postProcStrength);
+			GET(forcedQuant);
+			
+						
+		}
+		ADM_assert(in);
+		
+		memcpy(&_info,_in->getInfo(),sizeof(_info));	
+		
+	    	initPostProc(&_postproc,_info.width,_info.height);
+		_postproc.postProcType=_param->postProcType;
+		_postproc.postProcStrength=_param->postProcStrength;
+		_postproc.forcedQuant=_param->forcedQuant;
+		updatePostProc(&_postproc);	    	
+	    	
+	    	//_uncompressed=new uint8_t[3*_info.width*_info.height];	
+		_uncompressed=new ADMImage(_info.width,_info.height);	
+		
+
+}
+uint8_t ADMVideoForcedPP::getFrameNumberNoAlloc(uint32_t frame,
+							uint32_t *len,
+							ADMImage *data,
+							uint32_t *flags)
+{
+		uint32_t page=_info.width*_info.height;
+		
+		*len=(page*3)>>1;
+		if(frame>=_info.nb_frames) return 0;		
+		
+		if(!(_postproc.postProcType && _postproc.postProcStrength) )
+		{
+			// disabled
+			if(!_in->getFrameNumberNoAlloc(frame, len,data,flags)) return 0;
+				
+			return 1;
+		
+		}
+			// we do postproc !
+			// keep
+			uint8_t *iBuff[3],*oBuff[3];
+			int strideTab[3],strideTab2[3];			
+				
+				
+			if(!_in->getFrameNumberNoAlloc(frame, len,_uncompressed,flags))
+			 		return 0;
+
+			oBuff[0]=YPLANE(data);
+                        oBuff[1]=VPLANE(data);
+                        oBuff[2]=UPLANE(data);
+
+				
+			iBuff[0]=YPLANE(_uncompressed);
+		 	iBuff[1]=VPLANE(_uncompressed);
+ 		 	iBuff[2]=UPLANE(_uncompressed);
+				
+				
+		        strideTab[0]=strideTab2[0]=_info.width;
+			strideTab[1]=strideTab2[1]=_info.width>>1;
+			strideTab[2]=strideTab2[2]=_info.width>>1;
+	
+			int type;
+			if(_uncompressed->flags&AVI_KEY_FRAME)
+					type=1;
+			else if(_uncompressed->flags & AVI_B_FRAME)
+					type=3;
+				else
+					type=2;
+		 	pp_postprocess(
+		      		iBuff,
+		        	strideTab,
+		        	oBuff,
+		        	strideTab2,
+				_info.width,
+		        	_info.height,
+		        	NULL,
+		          	0,
+		         	_postproc.ppMode,
+		          	_postproc.ppContext,
+		          	type); // I ?
+			  	
+			
+		
+			data->copyInfo(_uncompressed);	
+			//printf("Type:%d\n",type);
+	return 1;
+}
+

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidForcedPP.h (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidForcedPP.h)

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMSharpen.cpp (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMSharpen.cpp)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMSharpen.cpp	2006-10-31 15:59:58 UTC (rev 2489)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMSharpen.cpp	2007-01-11 20:41:19 UTC (rev 2705)
@@ -0,0 +1,797 @@
+/***************************************************************************
+                          ADM_vidMSharpen  -  description
+                             -------------------
+    
+    email                : fixounet at free.fr
+
+    Port of Donal Graft Msharpen which is (c) Donald Graft
+    http://www.neuron2.net
+    http://puschpull.org/avisynth/decomb_reference_manual.html
+
+        It is a bit less efficient as we do hz & vz blur separately
+        The formula has been changed a bit from 1 1 1 to 1 2 1
+        for speed aspect & MMX  
+        Mean
+
+ ***************************************************************************/
+/*
+	Msharpen plugin for Avisynth -- performs detail-preserving smoothing.
+
+	Copyright (C) 2003 Donald A. Graft
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program; if not, write to the Free Software
+	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#include "config.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ADM_assert.h>
+
+#include "config.h"
+#include "fourcc.h"
+#include "avio.hxx"
+#include "avi_vars.h"
+
+#include "ADM_toolkit/toolkit.hxx"
+#include "ADM_editor/ADM_edit.hxx"
+#include "ADM_video/ADM_genvideo.hxx"
+#include"ADM_video/ADM_vidField.h"
+#include"ADM_video/ADM_cache.h"
+
+#include "ADM_osSupport/ADM_debugID.h"
+#define MODULE_NAME MODULE_FILTER
+#include "ADM_osSupport/ADM_debug.h"
+
+#include "ADM_osSupport/ADM_cpuCap.h"
+#include "ADM_filter/video_filters.h"
+
+#include "ADM_vidMSharpen_param.h"
+
+#include "ADM_userInterfaces/ADM_commonUI/DIA_factory.h"
+
+class Msharpen : public AVDMGenericVideoStream
+{
+private:
+	MSHARPEN_PARAM	*_param;
+	VideoCache	*vidCache;
+        ADMImage        *blurrImg,*work;
+
+        uint32_t        invstrength;
+
+        void detect_edges(ADMImage *src, ADMImage *dst, unsigned char *dstp, int plane);
+        void blur_plane(ADMImage *src, ADMImage *blur, unsigned char *blurp, int plane) ;
+        void detect_edges_HiQ(ADMImage *src, ADMImage *dst, unsigned char *dstp, int plane);
+        void apply_filter(ADMImage *src,ADMImage *blur, ADMImage *dst, unsigned char *dstp, int plane) ;
+public:    
+
+			Msharpen(AVDMGenericVideoStream *in,CONFcouple *couples)   ;
+			~Msharpen();
+
+
+				 
+	char 		*printConf( void );
+	uint8_t 	configure(AVDMGenericVideoStream *in);
+	uint8_t		getCoupledConf( CONFcouple **couples);
+	uint8_t 	getFrameNumberNoAlloc(uint32_t frame, uint32_t *len, ADMImage *data,uint32_t *flags);
+};
+
+BUILD_CREATE(msharpen_create,Msharpen);
+static FILTER_PARAM msharpenParam={4,{"mask", "highq","threshold", "strength"}};
+
+
+SCRIPT_CREATE(msharpen_script,Msharpen,msharpenParam);
+//_______________________________________________
+
+Msharpen::Msharpen(AVDMGenericVideoStream *in,CONFcouple *couples)
+
+{
+	_in=in;		
+   	memcpy(&_info,_in->getInfo(),sizeof(_info));    
+  	_info.encoding=1;
+	_uncompressed=NULL;		
+  	_info.encoding=1;
+
+
+	_param=new MSHARPEN_PARAM;
+	//
+	if(couples)
+		{
+			GET(mask);
+			GET(highq);
+			GET(strength);	
+			GET(threshold);	
+		}
+		else // Default
+  		{
+			_param->mask=0;       // Show mask
+			_param->highq=1;
+			_param->strength=100;	
+			_param->threshold=15;	
+		}
+                
+		invstrength=255-_param->strength;	
+		blurrImg=new ADMImage(_info.width,_info.height);
+                work=new ADMImage(_info.width,_info.height);
+    		vidCache=new VideoCache(5,in);
+}
+//________________________________________________________
+uint8_t	Msharpen::getCoupledConf( CONFcouple **couples)
+{
+	*couples=NULL;
+	*couples=new CONFcouple(4);
+#define CSET(x)  (*couples)->setCouple((char *)#x,(_param->x))
+		CSET(mask);
+		CSET(highq);
+		CSET(strength);	
+		CSET(threshold);	
+	return 1;
+}
+//________________________________________________________
+Msharpen::~Msharpen(void)
+{
+
+	if(vidCache) delete vidCache;
+	if(_param) delete _param;
+	if(blurrImg) delete blurrImg;
+        if(work) delete work;
+	vidCache=NULL;
+	_param=NULL;
+	blurrImg=NULL;
+        work=NULL;
+}
+extern uint8_t DIA_getMSharpen(MSHARPEN_PARAM *param);
+//________________________________________________________
+uint8_t Msharpen::configure(AVDMGenericVideoStream *in)
+{
+uint8_t r=0;
+	_in=in;
+	ADM_assert(_param);
+
+#define PX(x) &(_param->x)
+  
+        
+    diaElemToggle    mask(PX(mask),_("Mask"));
+    diaElemToggle    highq(PX(highq),_("High Q"));
+    
+    diaElemUInteger   threshold(PX(threshold),_("Threshold"),1,255);
+    diaElemUInteger   strength(PX(strength),_("Strength"),1,255);
+    
+    
+  diaElem *elems[4]={&mask,&highq,&threshold,&strength};
+
+  if(diaFactoryRun("MSharpen",4,elems))
+  {
+         invstrength=255-_param->strength;
+         return 1;
+  }
+  return 0;
+}
+
+//________________________________________________________
+char *Msharpen::printConf( void )
+{
+ 	static char buf[50];
+
+	ADM_assert(_param);
+ 	sprintf((char *)buf," Donald Graft Msharpen Strength:%d Threshold:%d",_param->strength,_param->threshold);
+        return buf;
+}
+	
+//________________________________________________________
+uint8_t Msharpen::getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
+				ADMImage *data,uint32_t *flags)
+{
+ADMImage *src,*blur,*dst;
+/*
+	PVideoFrame src = child->GetFrame(n, env);
+	PVideoFrame blur = env->NewVideoFrame(vi);
+	PVideoFrame dst = env->NewVideoFrame(vi);
+*/
+unsigned char *blurp;
+unsigned char *dstp;
+	dst=data;
+	if(frame>=_info.nb_frames) return 0;
+	src=vidCache->getImage(frame);
+	blur=blurrImg;
+	{
+		for (int i=0;i<3;i++)
+		{
+		
+			//unsigned char *blurp = blur->GetWritePtr(plane);
+			switch(i)
+			{
+				case 0:blurp=YPLANE(blur);break;
+				case 1:blurp=UPLANE(blur);break;
+				case 2:blurp=VPLANE(blur);break;
+			}
+			blur_plane(src, blur, blurp ,i);
+
+		//	unsigned char *dstp = dst->GetWritePtr(plane);
+			switch(i)
+			{
+				case 0:dstp=YPLANE(dst);break;
+				case 1:dstp=UPLANE(dst);break;
+				case 2:dstp=VPLANE(dst);break;
+			}
+
+			detect_edges(blur, dst, dstp, i);
+			if (_param->highq == true)
+				detect_edges_HiQ(blur, dst, dstp, i);
+
+			if (!_param->mask) apply_filter(src, blur, dst, dstp, i);
+		}
+	}
+
+	vidCache->unlockAll();
+	return 1;
+}
+
+/**********************************
+ * MMX / ISSE by Klaus Post and Milan Cutka.
+ *
+ * Delivers same result as YUY2, except planes
+ *  are processed independently.
+ *********************************/
+
+void Msharpen::blur_plane(ADMImage *src, ADMImage *blur, unsigned char *blurp, int plane) 
+{
+/*
+  uint64_t mask1 = 0x00001C711C711C71LL;
+  uint64_t mask2 = 0x1C711C711C710000LL;
+  uint64_t mask3 = 0x0000200000002000LL;
+  uint64_t mask4 = 0x0000000000ff0000LL;
+
+  const unsigned char *srcp = src->GetReadPtr(plane);
+	const unsigned char *srcp_saved = srcp;
+	unsigned char *blurp_saved = blurp;
+  int src_pitch = src->GetPitch(plane);
+  int blur_pitch = blur->GetPitch(plane);
+  int h = src->GetHeight(plane);
+  int w = src->GetRowSize(plane);
+*/
+const unsigned char *srcp,*srcpn,*srcpp; 
+const unsigned char *srcp_saved ;
+unsigned char *wk,*wk_saved;
+unsigned char *blurp_saved ;
+int src_pitch;
+int blur_pitch;
+int h;
+int w ;
+int wh ,ww,hh;
+ 	blurp_saved=blurp;
+	switch(plane)
+		{
+			case 0:
+				srcp_saved=srcp=YPLANE(src);        
+                                wk_saved=wk=YPLANE(work);
+				ww=_info.width;
+				hh=_info.height;
+				break;
+			case 1:
+				srcp_saved=srcp=UPLANE(src);
+                                wk_saved=wk=UPLANE(work);
+				ww=_info.width>>1;
+				hh=_info.height>>1;
+				break;
+			case 2:
+				srcp_saved=srcp=VPLANE(src);
+                                wk_saved=wk=VPLANE(work);
+				ww=_info.width>>1;
+				hh=_info.height>>1;
+				break;
+		}
+		src_pitch=ww;
+		blur_pitch=ww;
+		w=ww;
+		h=hh;
+ 
+  
+  wk+=blur_pitch;
+  srcpp=srcp;
+  srcp+=src_pitch,
+  srcpn=srcp+src_pitch;
+  int val;
+
+  // Vertical only for now      
+#if (defined( ARCH_X86)  || defined(ARCH_X86_64))
+  if(CpuCaps::hasMMX())
+  {
+  int off;
+#ifdef GCC_2_95_X
+        __asm__(
+                        ".align 16\n"
+                        "pxor  %mm7,%mm7\n"
+                : : );
+#else
+        __asm__(
+                        ".align 16\n"
+                        "pxor  %%mm7,%%mm7\n"
+                : : );
+#endif
+                        
+  for (int y=1; y<h-1 ;y++) 
+  {               
+        for (int x =  (w>>3);x>0; x--)
+                {
+                        off=x<<3;                        
+                        __asm__(
+                        ".align 16\n"                      
+                        "movq  (%0),%%mm0\n"
+                        "movq  %%mm0,%%mm6\n"
+                        "punpckhbw %%mm7,%%mm0\n" // High part extended to 16 bits
+                        "punpcklbw %%mm7,%%mm6\n" // low part ditto
+                        
+                        "movq  (%1),%%mm1\n"
+                        "movq  %%mm1,%%mm5\n"
+                        "punpckhbw %%mm7,%%mm1\n"
+                        "punpcklbw %%mm7,%%mm5\n"
+                        
+                        "movq  (%2),%%mm2\n"
+                        "movq  %%mm2,%%mm4\n"
+                        "punpckhbw %%mm7,%%mm2\n"
+                        "punpcklbw %%mm7,%%mm4\n"
+                        
+                        "paddw %%mm1,%%mm0\n"
+                        "paddw %%mm5,%%mm6\n"
+                        
+                        "paddw %%mm1,%%mm2\n"
+                        "paddw %%mm5,%%mm4\n"
+                        
+                        "paddw %%mm0,%%mm2\n"
+                        "paddw %%mm6,%%mm4\n"
+                        "psrlw $2, %%mm4\n"
+                        "psrlw $2, %%mm2\n"
+                        "packuswb %%mm2,%%mm4\n"
+                        "movq %%mm4,(%3)\n" //
+                        
+                        : : "r" (srcpn+off),
+                           "r" (srcp+off), "r" (srcpp+off), "r" (wk+off)
+                        );
+                }                        
+        srcp+=src_pitch;
+        srcpp+=src_pitch;
+        srcpn+=src_pitch;
+        wk+=src_pitch;     
+  }
+  __asm__("emms\n");
+ }
+ else
+#endif      
+  {
+  for (int y=1; y<h-1 ;y++) 
+  {       
+
+        for(int x=0;x<w;x++)
+        {
+                val=srcp[x]+srcpn[x]+srcpp[x]+srcp[x];
+                wk[x]=(val)>>2;
+        } 
+        srcp+=src_pitch;
+        srcpp+=src_pitch;
+        srcpn+=src_pitch;
+        wk+=src_pitch;     
+  }
+  }
+  //************ Horizontal****************
+  blurp=blurp_saved;
+  srcp=wk_saved;
+  for (int y=1; y<h-1 ;y++) 
+  {         
+        for(int x=1;x<w-1;x++)
+        {
+                val=srcp[x-1]+srcp[x]+srcp[x+1]+srcp[x];
+                blurp[x]=val>>2;
+        } 
+        srcp+=src_pitch;
+        srcpp+=src_pitch;
+        srcpn+=src_pitch;
+        blurp+=src_pitch;     
+  }
+  //******************
+        /* Fix up blur frame borders. */
+        srcp = srcp_saved;
+        blurp = blurp_saved;
+        memcpy(blurp, srcp, w);
+        memcpy(blurp + (h-1)*blur_pitch, srcp + (h-1)*src_pitch, w);
+        for (int y = 0; y < h; y++)
+        {
+                blurp[0] = srcp[0];
+                blurp[w-1] = srcp[w-1];
+                srcp += src_pitch;
+                blurp += blur_pitch;
+        }
+
+}
+#if 0
+    __asm {
+      mov esi, srcp  // esi=srcpp
+      mov ecx, blurp
+      mov ebx, src_pitch
+      mov edi, esi 
+      mov edx, esi 
+      add edi, ebx // edi=srcp+pitch=srcp
+      add edx, ebx 
+      add edx, ebx  //edx=srcp+2*pitch=srcpn
+      xor eax, eax
+      movq mm7,mask1 // mm7 mask1
+      movq mm6,mask2 // mm6 mask2
+     align 16
+xloop:
+      movd mm0,[esi+eax]  //srcpp[x}
+      pxor mm5,mm5
+       movd mm1,[edi+eax] //srcp[x}
+      movd mm2,[edx+eax]  // srcpn   
+      punpcklbw mm0,mm5  // mm0 low srcpp
+      punpcklbw mm1,mm5   // mm1 low srcp
+      movq mm3, mm0
+      punpcklbw mm2,mm5   // mm2 low srcn
+      movq mm4, mm1
+      movq mm5, mm2
+      paddw mm0,mm1     // srcp+srcpp
+      paddw mm3,mm4   // 2*srcp+srcpp
+      paddw mm0,mm2    // 2*srcp+srcpp+srcn
+      paddw mm3,mm5   // idem
+      pmaddwd mm0,mm7
+       movq mm5,[mask3]
+      pmaddwd mm3,mm6
+       pshufw mm1,mm0, 11101110b  // Move upper to lower
+      pshufw mm4,mm3, 11101110b   
+       paddd mm0,mm1
+      paddd mm3,mm4
+       paddd mm0, mm5
+      paddd mm3, mm5
+       psrld mm0,16
+      pand mm3,[mask4]
+      psrld mm3,8
+      por mm0,mm3
+      movd [eax+ecx],mm0  // blurp[i]
+      add eax,2
+      cmp eax,[w]
+      jle xloop;
+    }
+    srcp += src_pitch;
+    blurp += blur_pitch;
+//      __asm emms;
+#endif
+ 
+
+//***************************************************
+void Msharpen::detect_edges(ADMImage *src, ADMImage *dst, unsigned char *dstp, int plane) 
+{
+  static uint64_t m255=0xffffffffffffffffLL;
+  static uint64_t threshold64;
+  int ww,hh;
+
+  threshold64=_param->threshold;
+  if(!threshold64) threshold64=1;
+  threshold64=threshold64+(threshold64<<8)+(threshold64<<16)+(threshold64<<24)+(threshold64<<32)+(threshold64<<40)+(threshold64<<48)+(threshold64<<56);
+/*
+  const unsigned char *srcp = src->GetReadPtr(plane);
+  int src_pitch = src->GetPitch(plane);
+  int dst_pitch = dst->GetPitch(plane);
+  const unsigned char *srcpn = srcp+src_pitch;
+  int h = src->GetHeight(plane);
+  int w = src->GetRowSize(plane);
+*/
+  const unsigned char *srcp,*srcp_saved; 
+  int src_pitch ;
+  int dst_pitch ; 
+  const unsigned char *srcpn; 
+  int h ;
+  int w ;
+  unsigned char *dstp_saved = dstp;
+
+  switch(plane)
+	{
+		case 0: srcp=YPLANE(src);
+			ww=_info.width;
+			hh=_info.height;
+			break;
+		case 2:
+		case 1:
+			if(plane==1) 	
+				srcp=UPLANE(src);
+			else
+				srcp=VPLANE(src);
+			ww=_info.width>>1;
+			hh=_info.height>>1;
+			break;
+		default:
+			ADM_assert(0);
+	}
+	src_pitch=ww;
+	dst_pitch=ww;
+	w=ww;
+	h=hh;
+	srcpn=srcp+src_pitch;
+	srcp_saved=srcp;
+
+ int p,n,c;
+ for (int y=0;y<h-1;y++)
+  {
+   for(int xx=1;xx<w-1;xx++)
+        {
+                p=srcp[xx+1];
+                n=srcpn[xx+1];
+                c=srcpn[xx-1];
+                
+                if(abs(n-p)>_param->threshold || abs(c-p)>_param->threshold) dstp[xx+1]=0xff;
+                                else dstp[xx+1]=0;
+                
+        }
+   srcp+=src_pitch;
+   srcpn+=src_pitch;
+   dstp+=dst_pitch;
+  }
+  if (_param->mask) {
+    dstp=dstp_saved;
+    memset(dstp_saved+(h-1)*dst_pitch,0,w);  // Not used, if not returning mask
+    for (int y=0;y<h;dstp+=dst_pitch,y++) {
+      dstp[0]=0;
+      dstp[1]=0;
+      dstp[w-1]=0;
+      dstp[w-2]=0;
+    }
+  }
+}
+#if 0
+unsigned char *dstpend=dstp+w-1;
+   __asm 
+    {
+     mov esi,[srcp]
+     inc esi
+     mov ecx,[srcpn]
+     inc ecx
+     mov edx,[srcpn]
+     dec edx
+     mov edi,[dstp]
+     inc edi
+     mov eax,[dstpend]
+     movq mm6,[threshold64]
+     pxor mm5,mm5
+     movq mm4,[m255]
+     align 16
+    diag1:
+     movq mm2,[ecx]
+      movq mm1,[esi]
+     movq mm3,[edx]
+
+     //abs(mm1-mm2)
+      movq mm7,mm1
+     pminub mm1,mm2  //srcpn+1 - srcp+1
+      pmaxub mm2,mm7
+     psubusb mm2,mm1
+      movq mm1,[esi]
+     psubusb mm2,mm6
+     
+     //abs(mm1-mm3)
+      movq mm7,mm1
+     pminub mm1,mm3 // srcp+1 srcp-1
+      pmaxub mm3,mm7
+     psubusb mm3,mm1
+     psubusb mm3,mm6
+
+     por     mm2,mm3
+     pcmpeqb mm2,mm5
+     pxor    mm2,mm4
+     movq    [edi],mm2
+     
+     add esi,8
+     add ecx,8
+     add edx,8
+     add edi,8
+     cmp edi,eax
+     jl  diag1
+
+   }
+__asm emms;
+#endif
+//***************************************************
+void Msharpen::detect_edges_HiQ(ADMImage *src, ADMImage *dst, unsigned char *dstp, int plane) 
+{
+  // Vertical detail detection
+/*
+  const unsigned char *srcp = src->GetReadPtr(plane);
+	const unsigned char *srcp_saved = srcp;
+  const unsigned char *srcpn;
+	unsigned char *dstp_saved = dstp;
+  int src_pitch = src->GetPitch(plane);
+  int dst_pitch = dst->GetPitch(plane);
+  int h = src->GetHeight(plane);
+  int w = src->GetRowSize(plane);
+*/
+
+  int b1,b2;
+  int ww,hh;
+ const unsigned char *srcp,*srcp_saved; 
+  int src_pitch ;
+  int dst_pitch ; 
+  const unsigned char *srcpn; 
+  int h ;
+  int w ;
+  unsigned char *dstp_saved = dstp;
+
+  switch(plane)
+	{
+		case 0: srcp=YPLANE(src);
+			ww=_info.width;
+			hh=_info.height;
+			break;
+		case 2:
+		case 1:
+			if(plane==1) 	
+				srcp=UPLANE(src);
+			else
+				srcp=VPLANE(src);
+			ww=_info.width>>1;
+			hh=_info.height>>1;
+			break;
+		default:
+			ADM_assert(0);
+	}
+	src_pitch=ww;
+	dst_pitch=ww;
+	w=ww;
+	h=hh;
+	srcpn=srcp+src_pitch;
+	srcp_saved=srcp;
+
+  for (int x=0;x<w;x++)
+  {
+    srcp=srcp_saved;
+    srcpn=srcp+src_pitch;
+    dstp=dstp_saved;
+    b1=srcp[x];
+    for (int y=0;y<h-1;dstp+=dst_pitch,srcp+=src_pitch,srcpn+=src_pitch,y++)
+    {
+      b2=srcpn[x];
+      if (abs(b1-b2)>=_param->threshold)
+        dstp[x]=255;
+      b1=b2;
+    }
+  }
+  
+  // Horizontal detail detection
+  srcp=srcp_saved;
+  dstp=dstp_saved;
+  for (int y=0;y<h;dstp+=dst_pitch,srcp+=src_pitch,y++)
+  {
+    b1=srcp[0]; //MEANX srcp[x]
+    for (int x=0;x<w-1;x++)
+    {
+      b2=srcp[x+1];
+      if (abs(b1-b2)>=_param->threshold)
+        dstp[x]=255;
+      b1=b2;
+    }
+  }
+  // Fix up detail map borders
+  dstp = dstp_saved;
+  memset(dstp,0,w);
+  memset(dstp+dst_pitch,0,w);
+  memset(dstp+(h-2)*dst_pitch,0,w);
+  memset(dstp+(h-1)*dst_pitch,0,w);
+  for (int y=0;y<h;dstp+=dst_pitch,y++)
+  {
+    dstp[0]=0;
+    dstp[1]=0;
+    dstp[w-1]=0;
+    dstp[w-2]=0;
+  }
+}
+//***************************************************
+void Msharpen::apply_filter(ADMImage *src,ADMImage *blur, ADMImage *dst, unsigned char *dstp, int plane) 
+{
+  // TODO: MMX / ISSE
+/*
+  const unsigned char *srcp = src->GetReadPtr(plane);
+  const unsigned char *blurp = blur->GetReadPtr(plane);
+  const unsigned char *srcp_saved = srcp;
+  unsigned char *dstp_saved = dstp;
+  const unsigned char *blurp_saved = blurp;
+  int src_pitch = src->GetPitch(plane);
+  int blur_pitch = blur->GetPitch(plane);
+  int dst_pitch = dst->GetPitch(plane);
+  int h = src->GetHeight(plane);
+  int w = src->GetRowSize(plane);
+ */
+  const unsigned char *srcp ;
+  const unsigned char *blurp ;
+  const unsigned char *srcp_saved; 
+  unsigned char *dstp_saved ;
+  const unsigned char *blurp_saved ;
+  int src_pitch;
+  int blur_pitch;
+  int dst_pitch;
+  int h;
+  int w;
+  int ww,hh; 
+
+  switch(plane)
+	{
+		case 0:
+			 srcp=YPLANE(src);
+			 blurp=YPLANE(blur);
+			 ww=_info.width;
+			 hh=_info.height;
+			 break;
+		case 1:
+		case 2:
+			if(plane==1)
+			{
+			 srcp=UPLANE(src);
+			 blurp=UPLANE(blur);
+			}
+			else
+			{
+			 srcp=VPLANE(src);
+			 blurp=VPLANE(blur);
+			}
+			 ww=_info.width>>1;
+			 hh=_info.height>>1;
+			break;
+	}
+
+	w=ww;
+	h=hh;
+	blur_pitch=ww;
+	dst_pitch=ww;
+	src_pitch=ww;
+	srcp_saved=srcp;
+	blurp_saved=blurp;
+	dstp_saved=dstp;
+	
+  memcpy(dstp,srcp,w);
+  memcpy(dstp+(h-1)*dst_pitch,srcp+(h-1)*src_pitch,w);
+  for (int y=0;y<h;srcp+=src_pitch,dstp+=dst_pitch,y++)
+  {
+    dstp[0]=srcp[0];
+    dstp[w-1]=srcp[w-1];
+  }
+  
+  // Now sharpen the edge areas and we're done
+  srcp=srcp_saved+src_pitch;
+  dstp=dstp_saved+dst_pitch;
+  blurp=blurp+dst_pitch;
+  int b4;
+  for (int y=1;y<h-1;srcp+=src_pitch,dstp+=dst_pitch,blurp+=blur_pitch,y++)
+  {
+    for (int x=1;x<w-1;)
+    {
+      if (*(int*)(dstp+x)==0) 
+      {
+        *(int*)(dstp+x)=*(int*)(srcp+x);
+        x+=4;
+        continue;
+      }
+      if (dstp[x])
+      {                                     
+        b4=4*int(srcp[x])-3*int(blurp[x]);
+        if (b4<0) b4=0; else if (b4>255) b4=255;
+        dstp[x]=(_param->strength*b4+invstrength*srcp[x])>>8;
+      }
+      else
+        dstp[x]=srcp[x];
+      x++; 
+    }  
+    dstp[w-1]=srcp[w-1]; 
+  }   
+}
+//***************************************************
+
+
+
+
+

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMSharpen_param.h (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMSharpen_param.h)

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am	2007-01-11 19:18:08 UTC (rev 2704)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am	2007-01-11 20:41:19 UTC (rev 2705)
@@ -7,6 +7,9 @@
 #INCLUDES = $(all_includes) 
 
 libADM_videoFilter_a_SOURCES =  \
+ ADM_vidForcedPP.cpp \
+ ADM_vidMSharpen.cpp \
+ ADM_vidDenoise.cpp \
  ADM_vidMPLD3D.cpp \
  ADM_vidMPLD3Dlow.cpp \
  ADM_lavpp_deint.cpp \



From mean at mail.berlios.de  Fri Jan 12 07:47:01 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 12 Jan 2007 07:47:01 +0100
Subject: [Avidemux-svn-commit] r2706 -
	branches/avidemux_2.4_branch/avidemux/ADM_codecs
Message-ID: <200701120647.l0C6l1aj028965@sheep.berlios.de>

Author: mean
Date: 2007-01-12 07:47:00 +0100 (Fri, 12 Jan 2007)
New Revision: 2706

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_codecs.cpp
Log:
added 3iv2 as mpeg4 fourcc

Modified: branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_codecs.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_codecs.cpp	2007-01-11 20:41:19 UTC (rev 2705)
+++ branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_codecs.cpp	2007-01-12 06:47:00 UTC (rev 2706)
@@ -90,6 +90,7 @@
   CHECK ("XVID");
   CHECK ("BLZ0");
   CHECK ("M4S2");
+  CHECK ("3IV2");
 
   return divx4;
 



From mean at mail.berlios.de  Fri Jan 12 07:50:08 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 12 Jan 2007 07:50:08 +0100
Subject: [Avidemux-svn-commit] r2707 -
	branches/avidemux_2.3_branch/avidemux/ADM_codecs
Message-ID: <200701120650.l0C6o8eC029155@sheep.berlios.de>

Author: mean
Date: 2007-01-12 07:50:08 +0100 (Fri, 12 Jan 2007)
New Revision: 2707

Modified:
   branches/avidemux_2.3_branch/avidemux/ADM_codecs/ADM_codecs.cpp
Log:
added 3iv2 as mpeg4 fourcc (2.3)

Modified: branches/avidemux_2.3_branch/avidemux/ADM_codecs/ADM_codecs.cpp
===================================================================
--- branches/avidemux_2.3_branch/avidemux/ADM_codecs/ADM_codecs.cpp	2007-01-12 06:47:00 UTC (rev 2706)
+++ branches/avidemux_2.3_branch/avidemux/ADM_codecs/ADM_codecs.cpp	2007-01-12 06:50:08 UTC (rev 2707)
@@ -92,6 +92,7 @@
   CHECK ("XVID");
   CHECK ("BLZ0");
   CHECK ("M4S2");
+  CHECK ("3IV2");
 
   return divx4;
 



From mean at mail.berlios.de  Fri Jan 12 08:15:15 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 12 Jan 2007 08:15:15 +0100
Subject: [Avidemux-svn-commit] r2708 - in
	branches/avidemux_2.4_branch/avidemux:
	ADM_userInterfaces/ADM_GTK/ADM_dialog
	ADM_userInterfaces/ADM_NONE/ADM_dialog
	ADM_userInterfaces/ADM_QT4/ADM_dialog ADM_video ADM_videoFilter
Message-ID: <200701120715.l0C7FFm6001034@sheep.berlios.de>

Author: mean
Date: 2007-01-12 08:15:14 +0100 (Fri, 12 Jan 2007)
New Revision: 2708

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDGbob.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDGbob_param.h
Removed:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_dgbob.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDGbob.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDGbob_param.h
Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am
Log:
dgbob switched to dialogFactory

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_dgbob.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_dgbob.cpp	2007-01-12 06:50:08 UTC (rev 2707)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_dgbob.cpp	2007-01-12 07:15:14 UTC (rev 2708)
@@ -1,244 +0,0 @@
-//
-// C++ Implementation: DIA_decimate
-//
-// Description: 
-//
-//
-// Author: mean <fixounet at free.fr>, (C) 2004
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-//
-// C++ Implementation: DIA_dectel
-//
-// Description: 
-//
-//
-// Author: mean <fixounet at free.fr>, (C) 2004
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-
-
-#include <config.h>
-
-#include <sys/types.h>
-#include <sys/stat.h>
-
-
-#include <gdk/gdkkeysyms.h>
-#include <gtk/gtk.h>
-
-
-#include <gdk/gdkkeysyms.h>
-#include <gtk/gtk.h>
-# include <math.h>
-
-#include "default.h"
-#include "ADM_toolkit_gtk/ADM_gladeSupport.h"
-#include "ADM_toolkit_gtk/toolkit_gtk.h"
-#include "ADM_toolkit_gtk/toolkit_gtk_include.h"
-#include "ADM_toolkit/toolkit.hxx"
-
-#include "ADM_video/ADM_vidDGbob_param.h"
-
-#define MENU_SET(x,y) { gtk_option_menu_set_history (GTK_OPTION_MENU(WID(x)),param->y);}
-#define MENU_GET(x,y) { param->y        = getRangeInMenu(WID(x));}
-
-#define CHECK_GET(x,y) {param->y=gtk_toggle_button_get_active( GTK_TOGGLE_BUTTON(WID(x)));}
-#define CHECK_SET(x,y) {gtk_toggle_button_set_active( GTK_TOGGLE_BUTTON(WID(x)),param->y);}
-
-
-static GtkWidget        *create_dialog1 (void);
-
-uint8_t DIA_getDGbob(DGBobparam *param)
-{
-GtkWidget *dialog;
-GtkAdjustment *adj;
-
-int ret=0;
-        dialog=create_dialog1();
-        
-        // Update
-        MENU_SET(optionmenu1,mode);
-        CHECK_SET(checkbutton1,ap);
-        if(param->order)  RADIO_SET(radiobutton2,1);
-                else     RADIO_SET(radiobutton1,1);
-         gtk_range_set_value (GTK_RANGE(WID(hscale1)),(gdouble)param->thresh);
-        // run
-        gtk_register_dialog(dialog);
-        if(gtk_dialog_run(GTK_DIALOG(dialog))==GTK_RESPONSE_OK)
-        {
-                MENU_GET(optionmenu1,mode);
-                CHECK_GET(checkbutton1,ap);       
-                param->order= RADIO_GET(radiobutton2);                
-                adj=gtk_range_get_adjustment (GTK_RANGE(WID(hscale1)));
-                param->thresh=GTK_ADJUSTMENT(adj)->value;
-                ret=1;
-        }
-        gtk_unregister_dialog(dialog);
-        gtk_widget_destroy(dialog);
-        return ret;
-}
-
-
-GtkWidget*
-create_dialog1 (void)
-{
-  GtkWidget *dialog1;
-  GtkWidget *dialog_vbox1;
-  GtkWidget *table1;
-  GtkWidget *label1;
-  GtkWidget *label2;
-  GtkWidget *label3;
-  GtkWidget *label4;
-  GtkWidget *hbox1;
-  GtkWidget *radiobutton1;
-  GSList *radiobutton1_group = NULL;
-  GtkWidget *radiobutton2;
-  GtkWidget *optionmenu1;
-  GtkWidget *menu1;
-  GtkWidget *mode_0;
-  GtkWidget *one;
-  GtkWidget *double1;
-  GtkWidget *hscale1;
-  GtkWidget *checkbutton1;
-  GtkWidget *dialog_action_area1;
-  GtkWidget *cancelbutton1;
-  GtkWidget *okbutton1;
-
-  dialog1 = gtk_dialog_new ();
-  gtk_window_set_title (GTK_WINDOW (dialog1), _("DGbob"));
-
-  dialog_vbox1 = GTK_DIALOG (dialog1)->vbox;
-  gtk_widget_show (dialog_vbox1);
-
-  table1 = gtk_table_new (4, 2, FALSE);
-  gtk_widget_show (table1);
-  gtk_box_pack_start (GTK_BOX (dialog_vbox1), table1, TRUE, TRUE, 0);
-
-  label1 = gtk_label_new (_("Field Order"));
-  gtk_widget_show (label1);
-  gtk_table_attach (GTK_TABLE (table1), label1, 0, 1, 0, 1,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_label_set_justify (GTK_LABEL (label1), GTK_JUSTIFY_LEFT);
-  gtk_misc_set_alignment (GTK_MISC (label1), 0, 0.5);
-
-  label2 = gtk_label_new (_("Mode"));
-  gtk_widget_show (label2);
-  gtk_table_attach (GTK_TABLE (table1), label2, 0, 1, 1, 2,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_label_set_justify (GTK_LABEL (label2), GTK_JUSTIFY_LEFT);
-  gtk_misc_set_alignment (GTK_MISC (label2), 0, 0.5);
-
-  label3 = gtk_label_new (_("Threshold"));
-  gtk_widget_show (label3);
-  gtk_table_attach (GTK_TABLE (table1), label3, 0, 1, 2, 3,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_label_set_justify (GTK_LABEL (label3), GTK_JUSTIFY_LEFT);
-  gtk_misc_set_alignment (GTK_MISC (label3), 0, 0.5);
-
-  label4 = gtk_label_new (_("Extra check"));
-  gtk_widget_show (label4);
-  gtk_table_attach (GTK_TABLE (table1), label4, 0, 1, 3, 4,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_label_set_justify (GTK_LABEL (label4), GTK_JUSTIFY_LEFT);
-  gtk_misc_set_alignment (GTK_MISC (label4), 0, 0.5);
-
-  hbox1 = gtk_hbox_new (FALSE, 0);
-  gtk_widget_show (hbox1);
-  gtk_table_attach (GTK_TABLE (table1), hbox1, 1, 2, 0, 1,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (GTK_FILL), 0, 0);
-
-  radiobutton1 = gtk_radio_button_new_with_mnemonic (NULL, _("BFF"));
-  gtk_widget_show (radiobutton1);
-  gtk_box_pack_start (GTK_BOX (hbox1), radiobutton1, FALSE, FALSE, 0);
-  gtk_radio_button_set_group (GTK_RADIO_BUTTON (radiobutton1), radiobutton1_group);
-  radiobutton1_group = gtk_radio_button_get_group (GTK_RADIO_BUTTON (radiobutton1));
-
-  radiobutton2 = gtk_radio_button_new_with_mnemonic (NULL, _("TFF"));
-  gtk_widget_show (radiobutton2);
-  gtk_box_pack_start (GTK_BOX (hbox1), radiobutton2, FALSE, FALSE, 0);
-  gtk_radio_button_set_group (GTK_RADIO_BUTTON (radiobutton2), radiobutton1_group);
-  radiobutton1_group = gtk_radio_button_get_group (GTK_RADIO_BUTTON (radiobutton2));
-
-  optionmenu1 = gtk_option_menu_new ();
-  gtk_widget_show (optionmenu1);
-  gtk_table_attach (GTK_TABLE (table1), optionmenu1, 1, 2, 1, 2,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-
-  menu1 = gtk_menu_new ();
-
-  mode_0 = gtk_menu_item_new_with_mnemonic (_("Keep fps and frame #"));
-  gtk_widget_show (mode_0);
-  gtk_container_add (GTK_CONTAINER (menu1), mode_0);
-
-  one = gtk_menu_item_new_with_mnemonic (_("Double fps and frame #"));
-  gtk_widget_show (one);
-  gtk_container_add (GTK_CONTAINER (menu1), one);
-
-  double1 = gtk_menu_item_new_with_mnemonic (_("Double frame # (slow mo)"));
-  gtk_widget_show (double1);
-  gtk_container_add (GTK_CONTAINER (menu1), double1);
-
-  gtk_option_menu_set_menu (GTK_OPTION_MENU (optionmenu1), menu1);
-
-  hscale1 = gtk_hscale_new (GTK_ADJUSTMENT (gtk_adjustment_new (12, 0, 255, 1, 1, 1)));
-  gtk_widget_show (hscale1);
-  gtk_table_attach (GTK_TABLE (table1), hscale1, 1, 2, 2, 3,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (GTK_FILL), 0, 0);
-
-  checkbutton1 = gtk_check_button_new_with_mnemonic (_("(avoid using it)"));
-  gtk_widget_show (checkbutton1);
-  gtk_table_attach (GTK_TABLE (table1), checkbutton1, 1, 2, 3, 4,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-
-  dialog_action_area1 = GTK_DIALOG (dialog1)->action_area;
-  gtk_widget_show (dialog_action_area1);
-  gtk_button_box_set_layout (GTK_BUTTON_BOX (dialog_action_area1), GTK_BUTTONBOX_END);
-
-  cancelbutton1 = gtk_button_new_from_stock ("gtk-cancel");
-  gtk_widget_show (cancelbutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), cancelbutton1, GTK_RESPONSE_CANCEL);
-  GTK_WIDGET_SET_FLAGS (cancelbutton1, GTK_CAN_DEFAULT);
-
-  okbutton1 = gtk_button_new_from_stock ("gtk-ok");
-  gtk_widget_show (okbutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), okbutton1, GTK_RESPONSE_OK);
-  GTK_WIDGET_SET_FLAGS (okbutton1, GTK_CAN_DEFAULT);
-
-  /* Store pointers to all widgets, for use by lookup_widget(). */
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog1, "dialog1");
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_vbox1, "dialog_vbox1");
-  GLADE_HOOKUP_OBJECT (dialog1, table1, "table1");
-  GLADE_HOOKUP_OBJECT (dialog1, label1, "label1");
-  GLADE_HOOKUP_OBJECT (dialog1, label2, "label2");
-  GLADE_HOOKUP_OBJECT (dialog1, label3, "label3");
-  GLADE_HOOKUP_OBJECT (dialog1, label4, "label4");
-  GLADE_HOOKUP_OBJECT (dialog1, hbox1, "hbox1");
-  GLADE_HOOKUP_OBJECT (dialog1, radiobutton1, "radiobutton1");
-  GLADE_HOOKUP_OBJECT (dialog1, radiobutton2, "radiobutton2");
-  GLADE_HOOKUP_OBJECT (dialog1, optionmenu1, "optionmenu1");
-  GLADE_HOOKUP_OBJECT (dialog1, menu1, "menu1");
-  GLADE_HOOKUP_OBJECT (dialog1, mode_0, "mode_0");
-  GLADE_HOOKUP_OBJECT (dialog1, one, "one");
-  GLADE_HOOKUP_OBJECT (dialog1, double1, "double1");
-  GLADE_HOOKUP_OBJECT (dialog1, hscale1, "hscale1");
-  GLADE_HOOKUP_OBJECT (dialog1, checkbutton1, "checkbutton1");
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_action_area1, "dialog_action_area1");
-  GLADE_HOOKUP_OBJECT (dialog1, cancelbutton1, "cancelbutton1");
-  GLADE_HOOKUP_OBJECT (dialog1, okbutton1, "okbutton1");
-
-  return dialog1;
-}
-

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am	2007-01-12 06:50:08 UTC (rev 2707)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am	2007-01-12 07:15:14 UTC (rev 2708)
@@ -18,7 +18,7 @@
 	DIA_dectel.cpp DIA_decimate.cpp DIA_pause.cpp \
 	DIA_DVDff.cpp DIA_lavdecoder.cpp DIA_lame.cpp DIA_calculator.cpp DIA_equalizer.cpp \
 	DIA_vobsub.cpp DIA_x264.cpp DIA_ocr.cpp  DIA_hue.cpp DIA_eq2.cpp \
-	DIA_dgbob.cpp DIA_asharp.cpp DIA_dmx.cpp DIA_idx_pg.cpp DIA_gototime.cpp \
+	DIA_asharp.cpp DIA_dmx.cpp DIA_idx_pg.cpp DIA_gototime.cpp \
 	DIA_audioTrack.cpp DIA_cnr2.cpp DIA_resizeWiz.cpp DIA_jobs.cpp DIA_jobs_save.cpp DIA_mosaic.cpp \
 	DIA_deblend.cpp DIA_v2v.cpp DIA_tdeint.cpp DIA_builtin.cpp DIA_mpdelogo.cpp DIA_vorbis.cpp \
         DIA_chromaShift.cpp \
@@ -52,7 +52,7 @@
 DIA_audioTrack.cpp   DIA_dectel.cpp        DIA_indexer.cpp      DIA_pipe.cpp        DIA_working.cpp \
 DIA_audiocodec.cpp   DIA_defaultAudio.cpp  DIA_jobs.cpp         DIA_postproc.cpp    DIA_working.h \
 DIA_jobs_save.cpp    DIA_prefs.cpp       DIA_x264.cpp \
-DIA_builtin.cpp      DIA_dgbob.cpp         DIA_preview.cpp     DIA_xvcd.cpp \
+DIA_builtin.cpp      DIA_preview.cpp     DIA_xvcd.cpp \
 DIA_busy.cpp         DIA_dmx.cpp           DIA_lame.cpp         DIA_properties.cpp  DIA_xvid.cpp \
 DIA_busy.h           DIA_lavcodec.cpp     DIA_quota.cpp       DIA_xvid4.cpp \
 DIA_calculator.cpp   DIA_encoding.cpp      DIA_lavdecoder.cpp   DIA_recent.cpp \

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp	2007-01-12 06:50:08 UTC (rev 2707)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp	2007-01-12 07:15:14 UTC (rev 2708)
@@ -42,7 +42,6 @@
 #include "ADM_video/ADM_vidDecDec_param.h"
 #include "ADM_video/ADM_vidDecTel_param.h"
 #include "ADM_audiofilter/audioencoder_lame_param.h"
-#include "ADM_video/ADM_vidDGbob_param.h"
 #include "ADM_audiofilter/audioencoder_lame_param.h"
 #include "ADM_encoder/adm_encmjpeg_param.h"
 #include "ADM_video/ADM_vidMosaic_param.h"
@@ -98,7 +97,6 @@
 uint8_t DIA_getASharp(ASHARP_PARAM *param, AVDMGenericVideoStream *in){return 0;}
 uint8_t DIA_getDecombDecimate(DECIMATE_PARAM *param){return 0;}
 uint8_t DIA_getDecombTelecide(TelecideParam *param){return 0;}
-uint8_t DIA_getDGbob(DGBobparam *param){return 0;}
 uint8_t DIA_getEQ2Param(Eq2_Param *param, AVDMGenericVideoStream *in){return 0;}
 uint8_t DIA_getEqualizer(EqualizerParam *param, ADMImage *image){return 0;}
 uint8_t DIA_getEqualizer(EqualizerParam *param, AVDMGenericVideoStream *in){return 0;}

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp	2007-01-12 06:50:08 UTC (rev 2707)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp	2007-01-12 07:15:14 UTC (rev 2708)
@@ -42,7 +42,6 @@
 #include "ADM_video/ADM_vidDecDec_param.h"
 #include "ADM_video/ADM_vidDecTel_param.h"
 #include "ADM_audiofilter/audioencoder_lame_param.h"
-#include "ADM_video/ADM_vidDGbob_param.h"
 #include "ADM_audiofilter/audioencoder_lame_param.h"
 #include "ADM_encoder/adm_encmjpeg_param.h"
 #include "ADM_video/ADM_vidMosaic_param.h"
@@ -98,7 +97,6 @@
 uint8_t DIA_getASharp(ASHARP_PARAM *param, AVDMGenericVideoStream *in){return 0;}
 uint8_t DIA_getDecombDecimate(DECIMATE_PARAM *param){return 0;}
 uint8_t DIA_getDecombTelecide(TelecideParam *param){return 0;}
-uint8_t DIA_getDGbob(DGBobparam *param){return 0;}
 uint8_t DIA_getEQ2Param(Eq2_Param *param, AVDMGenericVideoStream *in){return 0;}
 uint8_t DIA_getEqualizer(EqualizerParam *param, ADMImage *image){return 0;}
 uint8_t DIA_getEqualizer(EqualizerParam *param, AVDMGenericVideoStream *in){return 0;}

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDGbob.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDGbob.cpp	2007-01-12 06:50:08 UTC (rev 2707)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDGbob.cpp	2007-01-12 07:15:14 UTC (rev 2708)
@@ -1,538 +0,0 @@
-/*
-	DGBob() plugin for Avisynth -- Smart bob filter. This filter splits
-	each field of the source into its own frame and then adaptively
-	creates the missing lines either by interpolating the current field
-	or by using the previous field's data. The filter attempts with some
-	success to mitigate the flutter that bobbing produces.
-
-	Copyright (C) 2003 Donald A. Graft
-
-	This program is free software; you can redistribute it and/or modify
-	it under the terms of the GNU General Public License as published by
-	the Free Software Foundation.
-
-	This program is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-	GNU General Public License for more details.
-
-	You should have received a copy of the GNU General Public License
-	along with this program; if not, write to the Free Software
-	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-*/
-
-
-#include "config.h"
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <ADM_assert.h>
-
-#include "config.h"
-#include "fourcc.h"
-#include "avio.hxx"
-#include "avi_vars.h"
-
-#include "ADM_toolkit/toolkit.hxx"
-#include "ADM_editor/ADM_edit.hxx"
-#include "ADM_video/ADM_genvideo.hxx"
-#include"ADM_video/ADM_vidField.h"
-#include"ADM_video/ADM_cache.h"
-
-#include "ADM_osSupport/ADM_debugID.h"
-#define MODULE_NAME MODULE_FILTER
-#include "ADM_osSupport/ADM_debug.h"
-#include "ADM_filter/video_filters.h"
-
-#include "ADM_vidDGbob_param.h"
-class DGbob : public AVDMGenericVideoStream
-{
-       
-        DGBobparam      *_param;        
-        
-        VideoCache      *vidCache;
-       
-        void            update(void); 
-public:
-                                
-                        DGbob(AVDMGenericVideoStream *in,CONFcouple *couples);    
-                        ~DGbob(void);
-        uint8_t         getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-                                ADMImage *data,uint32_t *flags);
-        
-        char            *printConf( void );
-        uint8_t         configure(AVDMGenericVideoStream *in);
-        uint8_t         getCoupledConf( CONFcouple **couples);
-};
-
-static FILTER_PARAM dgbobParam={4,{"order","mode","thresh","ap"}};
-
-BUILD_CREATE(dgbob_create,DGbob);
-SCRIPT_CREATE(dgbob_script,DGbob,dgbobParam);
-
-/*************************************/
-extern uint8_t DIA_getDGbob(DGBobparam *param);
-uint8_t DGbob::configure(AVDMGenericVideoStream *in)
-{
-        _in=in;
-        if(DIA_getDGbob(_param))
-        {        
-                update();
-                return 1;
-        }
-        return 0;
-        
-}
-
-char *DGbob::printConf( void )
-{
-        static char buf[50];
-
-        //ADM_assert(_param);
-        sprintf((char *)buf," DGBob mode:%d order:%d thresh:%d\n",_param->mode,_param->order,_param->thresh);
-        return buf;
-}
-
-
-DGbob::DGbob(AVDMGenericVideoStream *in,CONFcouple *couples)              
-
-{
-                
-                int count = 0;
-                char buf[80];
-                unsigned int *p;
-
-                _in=in;         
-                memcpy(&_info,_in->getInfo(),sizeof(_info));    
-                _info.encoding=1;
-                _uncompressed=NULL;             
-                _info.encoding=1;
-                _info.fps1000*=2;
-                _info.nb_frames*=2;
-                
-                                
-                vidCache=new VideoCache(7,in);
-                _param= new DGBobparam;
-                if(couples)
-                {
-                        GET(order);
-                        GET(mode);
-                        GET(thresh);
-                        GET(ap);
-                }
-                else
-                {
-                        _param->order=1;
-                        _param->mode=0;
-                        _param->thresh=12;
-                        _param->ap=0;
-                }
-                update();
-}
-void DGbob::update(void)
-{
-                memcpy(&_info,_in->getInfo(),sizeof(_info));    
-                _info.encoding=1;
-                switch(_param->mode)
-                {
-                        case 0:
-                                break;
-                        case 1:
-                                _info.fps1000*=2;
-                                _info.nb_frames*=2;
-                                break;
-                        case 2:
-                                _info.nb_frames*=2;
-                                break;
-                        default: ADM_assert(0);
-
-                }
-             
-}
-//________________________________________________________
-uint8_t DGbob::getCoupledConf( CONFcouple **couples)
-{
-        *couples=NULL;
-        *couples=new CONFcouple(4);
-#define CSET(x)  (*couples)->setCouple((char *)#x,(_param->x))
-        
-        CSET(order);
-        CSET(mode);
-        CSET(thresh);
-        CSET(ap);
-
-        return 1;
-}
-//________________________________________________________
-DGbob::~DGbob(void)
-{
-                
-                if(vidCache) delete vidCache;                
-                vidCache=NULL;   
-                if(_param) delete _param;
-                _param=NULL;                             
-}
-uint8_t DGbob::getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-                                ADMImage *data,uint32_t *flags)
-{
-        ADMImage *src,*prv,*prvprv,*nxt,*nxtnxt,*dst;
-	uint32_t n,num_frames;
-
-        num_frames=_in->getInfo()->nb_frames;   // ??
-
-	if (_param->mode == 0) n = frame;
-	else n = frame/2;
-
-        src=vidCache->getImage(n);
-        prv=vidCache->getImage(n > 0 ? n - 1 :0 );
-        prvprv=vidCache->getImage(n > 1 ? n - 2 : 0);
-        nxt=vidCache->getImage(n < num_frames - 1 ? n + 1 : num_frames - 1);
-        nxtnxt=vidCache->getImage(n < num_frames - 2 ? n + 2 : num_frames - 1);
-
-
-/*
-	PVideoFrame src = child->GetFrame(n, env);
-	PVideoFrame prv = child->GetFrame(n > 0 ? n - 1 : 0, env);
-	PVideoFrame prvprv = child->GetFrame(n > 1 ? n - 2 : 0, env);
-	PVideoFrame nxt = child->GetFrame(n < vi.num_frames - 1 ? n + 1 : vi.num_frames - 1, env);
-	PVideoFrame nxtnxt = child->GetFrame(n < vi.num_frames - 2 ? n + 2 : vi.num_frames - 1, env);
-    PVideoFrame dst = env->NewVideoFrame(vi);
-*/
-    const unsigned char *srcp, *srcp_saved, *srcpp, *srcpn;
-	const unsigned char *prvp, *prvpp, *prvpn, *prvprvp, *prvprvpp, *prvprvpn;
-	const unsigned char *nxtp, *nxtpp, *nxtpn, *nxtnxtp, *nxtnxtpp, *nxtnxtpn;
-    unsigned char *dstp, *dstp_saved;
- 
-    int src_pitch, dst_pitch, w, h;
-	int x, y, z, v1, v2, D = _param->thresh, T = 6, AP = 30;
-	int plane;
-
-        uint32_t ww,hh;
-	// Try making D a function of the average value of the comparands in
-	// order to make the margin larger in darker areas, where we can't see as
-	// much combing.
-
-	// Force deinterlacing of the first and last frames.
-	if (n == 0 || n == num_frames - 1) D = 0;
-        dst=data;
-	for (z = 0; z < 3; z++)
-	{
-/*
-		if (z == 0) plane = PLANAR_Y;
-		else if (z == 1) plane = PLANAR_U;
-		else plane = PLANAR_V;
-
-*/
-                switch(z)
-                {
-                        case 0:
-                                ww=_info.width;
-                                hh=_info.height;
-                                srcp_saved = srcp = YPLANE(src);                                
-                                dstp_saved = dstp = YPLANE(dst);
-                                src_pitch = ww;
-                                dst_pitch = ww;
-                                w = ww;
-                                h = hh;
-                                break;
-                        case 1:
-                        case 2:
-                                ww=_info.width>>1;
-                                hh=_info.height>>1;
-                                if(z==1)
-                                {
-                                        srcp_saved = srcp = UPLANE(src);
-                                        dstp_saved = dstp = UPLANE(dst);
-                                }
-                                else
-                                {
-                                        srcp_saved = srcp = VPLANE(src);
-                                        dstp_saved = dstp = VPLANE(dst);
-                                }
-                                src_pitch = ww;
-                                dst_pitch = ww;
-                                w = ww;
-                                h = hh;
-                                break;
-                }
-/*
-		srcp_saved = srcp = src->GetReadPtr(plane);
-		src_pitch = src->GetPitch(plane);
-		dstp_saved = dstp = dst->GetWritePtr(plane);
-		dst_pitch = dst->GetPitch(plane);
-		w = dst->GetRowSize(plane);
-		h = dst->GetHeight(plane);
-*/
-		if ((_param->mode > 0) && (frame & 1))
-		{
-			// Process odd-numbered frames.
-			// Copy field from current frame.
-			srcp = srcp_saved +_param->order * src_pitch;
-			dstp = dstp_saved +_param->order * dst_pitch;
-			for (y = 0; y < h; y+=2)
-			{
-				memcpy(dstp, srcp, w);
-				srcp += 2*src_pitch;
-				dstp += 2*dst_pitch;
-			}
-			// Copy through the line that will be missed below.
-			memcpy(dstp_saved + (1-_param->order)*(h-1)*dst_pitch, srcp_saved + (1-_param->order)*(h-1)*src_pitch, w);
-			/* For the other field choose adaptively between using the previous field
-			   or the interpolant from the current field. */
-                        
-			//prvp = prv->GetReadPtr(plane) + src_pitch + order*src_pitch;
-                        switch(z)
-                        {
-                                case 0:prvp = YPLANE(prv) + src_pitch + _param->order*src_pitch;break;
-                                case 1:prvp = UPLANE(prv) + src_pitch + _param->order*src_pitch;break;
-                                case 2:prvp = VPLANE(prv) + src_pitch + _param->order*src_pitch;break;
-                        }
-			prvpp = prvp - src_pitch;
-			prvpn = prvp + src_pitch;
-			//prvprvp = prvprv->GetReadPtr(plane) + src_pitch + order*src_pitch;
-                         switch(z)
-                        {
-                                case 0:prvprvp = YPLANE(prvprv) + src_pitch + _param->order*src_pitch;break;
-                                case 1:prvprvp = UPLANE(prvprv) + src_pitch + _param->order*src_pitch;break;
-                                case 2:prvprvp = VPLANE(prvprv) + src_pitch + _param->order*src_pitch;break;
-                        }
-
-			prvprvpp = prvprvp - src_pitch;
-			prvprvpn = prvprvp + src_pitch;
-
-			//nxtp = nxt->GetReadPtr(plane) + src_pitch + order*src_pitch;
-                        switch(z)
-                        {
-                                case 0:nxtp = YPLANE(nxt) + src_pitch + _param->order*src_pitch;break;
-                                case 1:nxtp = UPLANE(nxt) + src_pitch + _param->order*src_pitch;break;
-                                case 2:nxtp = VPLANE(nxt) + src_pitch + _param->order*src_pitch;break;
-                        }
-
-			nxtpp = nxtp - src_pitch;
-			nxtpn = nxtp + src_pitch;
-			//nxtnxtp = nxtnxt->GetReadPtr(plane) + src_pitch + order*src_pitch;
-                        switch(z)
-                        {
-                                case 0:nxtnxtp = YPLANE(nxtnxt) + src_pitch + _param->order*src_pitch;break;
-                                case 1:nxtnxtp = UPLANE(nxtnxt) + src_pitch + _param->order*src_pitch;break;
-                                case 2:nxtnxtp = VPLANE(nxtnxt) + src_pitch + _param->order*src_pitch;break;
-                        }
-			nxtnxtpp = nxtnxtp - src_pitch;
-			nxtnxtpn = nxtnxtp + src_pitch;
-			srcp =  srcp_saved + src_pitch + _param->order*src_pitch;
-			srcpp = srcp - src_pitch;
-			srcpn = srcp + src_pitch;
-			dstp =  dstp_saved + dst_pitch + _param->order*dst_pitch;
-			for (y = 0; y < h - 2; y+=2)
-			{
-				for (x = 0; x < w; x++)
-				{
-					if (
-						abs(srcp[x] - nxtp[x]) < D
-//						&& abs(srcp[x] - nxtnxtp[x]) < D
-//						&& abs(prvp[x] - nxtp[x]) < D
-						&& abs(srcpn[x] - prvprvpn[x]) < D
-						&& abs(srcpp[x] - prvprvpp[x]) < D
-						&& abs(srcpn[x] - nxtnxtpn[x]) < D
-						&& abs(srcpp[x] - nxtnxtpp[x]) < D
-						&& abs(srcpn[x] - prvpn[x]) < D
-						&& abs(srcpp[x] - prvpp[x]) < D
-						&& abs(srcpn[x] - nxtpn[x]) < D
-						&& abs(srcpp[x] - nxtpp[x]) < D
-					   )
-					{
-						if (_param->ap == true)
-						{
-							v1 = (int) srcp[x] - AP;
-							if (v1 < 0) v1 = 0; 
-							v2 = (int) srcp[x] + AP;
-							if (v2 > 235) v2 = 235; 
-							if ((v1 > srcpp[x] && v1 > srcpn[x]) || (v2 < srcpp[x] && v2 < srcpn[x]))
-							{
-								dstp[x] = ((int)srcpp[x] + srcpn[x]) >> 1;
-//								if (x & 1) dstp[x] = 100; else dstp[x] = 235;
-							}
-							else
-							{
-								dstp[x] = srcp[x];
-//								if (x & 1) dstp[x] = 100; else dstp[x] = 235;
-							}
-						}
-						else
-						{
-							dstp[x] = srcp[x];
-//							if (x & 1) dstp[x] = 100; else dstp[x] = 235;
-						}
-					}
-					else
-					{
-						v1 = (int) srcp[x] - T;
-						if (v1 < 0) v1 = 0; 
-						v2 = (int) srcp[x] + T;
-						if (v2 > 235) v2 = 235; 
-						if ((v1 > srcpp[x] && v1 > srcpn[x]) || (v2 < srcpp[x] && v2 < srcpn[x]))
-						{
-							dstp[x] = ((int)srcpp[x] + srcpn[x]) >> 1;
-						}
-						else
-						{
-							dstp[x] = srcp[x];
-//							if (x & 1) dstp[x] = 128; else dstp[x] = 235;
-						}
-					}
-				}
-				prvp    += 2*src_pitch;
-				prvpp    += 2*src_pitch;
-				prvpn    += 2*src_pitch;
-				prvprvpp    += 2*src_pitch;
-				prvprvpn    += 2*src_pitch;
-				nxtp    += 2*src_pitch;
-				nxtpp    += 2*src_pitch;
-				nxtpn    += 2*src_pitch;
-				nxtnxtpp    += 2*src_pitch;
-				nxtnxtpn    += 2*src_pitch;
-				srcp    += 2*src_pitch;
-				srcpp   += 2*src_pitch;
-				srcpn   += 2*src_pitch;
-				dstp    += 2*dst_pitch;
-			}
-		}
-		else
-		{
-			// Process even-numbered frames.
-			// Copy field from current frame.
-			srcp = srcp_saved + (1-_param->order) * src_pitch;
-			dstp = dstp_saved + (1-_param->order) * dst_pitch;
-			for (y = 0; y < h; y+=2)
-			{
-				memcpy(dstp, srcp, w);
-				srcp += 2*src_pitch;
-				dstp += 2*dst_pitch;
-			}
-			// Copy through the line that will be missed below.
-			memcpy(dstp_saved + _param->order*(h-1)*dst_pitch, srcp_saved + _param->order*(h-1)*src_pitch, w);
-			/* For the other field choose adaptively between using the previous field
-			   or the interpolant from the current field. */
-			//prvp = prv->GetReadPtr(plane) + src_pitch + (1-order)*src_pitch;
-                        switch(z)
-                        {
-                                case 0:prvp = YPLANE(prv) + src_pitch + (1-_param->order)*src_pitch;break;
-                                case 1:prvp = UPLANE(prv) + src_pitch + (1-_param->order)*src_pitch;break;
-                                case 2:prvp = VPLANE(prv) + src_pitch + (1-_param->order)*src_pitch;break;
-                        }
-			prvpp = prvp - src_pitch;
-			prvpn = prvp + src_pitch;
-			// prvprvp = prvprv->GetReadPtr(plane) + src_pitch + (1-order)*src_pitch;
-                        switch(z)
-                        {
-                                case 0:prvprvp = YPLANE(prvprv) + src_pitch + (1-_param->order)*src_pitch;break;
-                                case 1:prvprvp = UPLANE(prvprv) + src_pitch + (1-_param->order)*src_pitch;break;
-                                case 2:prvprvp = VPLANE(prvprv) + src_pitch + (1-_param->order)*src_pitch;break;
-                        }
-                        
-			prvprvpp = prvprvp - src_pitch;
-			prvprvpn = prvprvp + src_pitch;
-			//nxtp = nxt->GetReadPtr(plane) + src_pitch + (1-order)*src_pitch;
-                        switch(z)
-                        {
-                                case 0:nxtp = YPLANE(nxt) + src_pitch + (1-_param->order)*src_pitch;break;
-                                case 1:nxtp = UPLANE(nxt) + src_pitch + (1-_param->order)*src_pitch;break;
-                                case 2:nxtp = VPLANE(nxt) + src_pitch + (1-_param->order)*src_pitch;break;
-                        }
-			nxtpp = nxtp - src_pitch;
-			nxtpn = nxtp + src_pitch;
-			//nxtnxtp = nxtnxt->GetReadPtr(plane) + src_pitch + (1-order)*src_pitch;
-                         switch(z)
-                        {
-                                case 0:nxtnxtp = YPLANE(nxtnxt) + src_pitch + (1-_param->order)*src_pitch;break;
-                                case 1:nxtnxtp = UPLANE(nxtnxt) + src_pitch + (1-_param->order)*src_pitch;break;
-                                case 2:nxtnxtp = VPLANE(nxtnxt) + src_pitch + (1-_param->order)*src_pitch;break;
-                        }
-			nxtnxtpp = nxtnxtp - src_pitch;
-			nxtnxtpn = nxtnxtp + src_pitch;
-			srcp =  srcp_saved + src_pitch + (1-_param->order)*src_pitch;
-			srcpp = srcp - src_pitch;
-			srcpn = srcp + src_pitch;
-			dstp =  dstp_saved + dst_pitch + (1-_param->order)*dst_pitch;
-			for (y = 0; y < h - 2; y+=2)
-			{
-				for (x = 0; x < w; x++)
-				{
-					if (
-						abs(srcp[x] - prvp[x]) < D
-//						&& abs(srcp[x] - prvprvp[x]) < D
-//						&& abs(prvp[x] - nxtp[x]) < D
-						&& abs(srcpn[x] - prvprvpn[x]) < D
-						&& abs(srcpp[x] - prvprvpp[x]) < D
-						&& abs(srcpn[x] - nxtnxtpn[x]) < D
-						&& abs(srcpp[x] - nxtnxtpp[x]) < D
-						&& abs(srcpn[x] - prvpn[x]) < D
-						&& abs(srcpp[x] - prvpp[x]) < D
-						&& abs(srcpn[x] - nxtpn[x]) < D
-						&& abs(srcpp[x] - nxtpp[x]) < D
-					   )
-					{
-						if (_param->ap == true)
-						{
-							v1 = (int) prvp[x] - AP;
-							if (v1 < 0) v1 = 0; 
-							v2 = (int) prvp[x] + AP;
-							if (v2 > 235) v2 = 235; 
-							if ((v1 > srcpp[x] && v1 > srcpn[x]) ||	(v2 < srcpp[x] && v2 < srcpn[x]))
-							{
-								dstp[x] = ((int)srcpp[x] + srcpn[x]) >> 1;
-//								if (x & 1) dstp[x] = 100; else dstp[x] = 235;
-							}
-							else
-							{
-								dstp[x] = prvp[x];
-//								if (x & 1) dstp[x] = 128; else dstp[x] = 235;
-							}
-						}
-						else
-						{
-							dstp[x] = prvp[x];
-//							if (x & 1) dstp[x] = 128; else dstp[x] = 235;
-						}
-					}
-					else
-					{
-						v1 = (int) prvp[x] - T;
-						if (v1 < 0) v1 = 0; 
-						v2 = (int) prvp[x] + T;
-						if (v2 > 235) v2 = 235; 
-						if ((v1 > srcpp[x] && v1 > srcpn[x]) ||	(v2 < srcpp[x] && v2 < srcpn[x]))
-						{
-							dstp[x] = ((int)srcpp[x] + srcpn[x]) >> 1;
-						}
-						else
-						{
-							dstp[x] = prvp[x];
-//							if (x & 1) pp[x] = 128; else dstp[x] = 235;
-						}
-					}
-				}
-				prvp    += 2*src_pitch;
-				prvpp    += 2*src_pitch;
-				prvpn    += 2*src_pitch;
-				prvprvpp    += 2*src_pitch;
-				prvprvpn    += 2*src_pitch;
-				nxtp    += 2*src_pitch;
-				nxtpp    += 2*src_pitch;
-				nxtpn    += 2*src_pitch;
-				nxtnxtpp    += 2*src_pitch;
-				nxtnxtpn    += 2*src_pitch;
-				srcp    += 2*src_pitch;
-				srcpp   += 2*src_pitch;
-				srcpn   += 2*src_pitch;
-				dstp    += 2*dst_pitch;
-			}
-		}
-	}
-        vidCache->unlockAll();
-	return 1;
-}
-//EOF
-
-
-

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDGbob_param.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDGbob_param.h	2007-01-12 06:50:08 UTC (rev 2707)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDGbob_param.h	2007-01-12 07:15:14 UTC (rev 2708)
@@ -1,12 +0,0 @@
-
-#ifndef DGBOB_PARAM
-#define DGBOB_PARAM
-typedef struct DGBobparam
-{
-        uint32_t  thresh;// low=more flickering, less jaggie
-        uint32_t  order; //0 : Bottom field first, 1 top field first        
-        uint32_t  mode;  // 0 keep # of frames, 1 *2 fps & *2 frame, 2  #*2, fps*150% slow motion
-        uint32_t  ap;    // Extra artifact check, better not to use
-}DGBobparam;
-
-#endif

Modified: branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am	2007-01-12 06:50:08 UTC (rev 2707)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am	2007-01-12 07:15:14 UTC (rev 2708)
@@ -67,7 +67,6 @@
  ADM_vidVobSubRender.cpp \
  ADM_vidHue.cpp \
  ADM_vidEq2.cpp \
- ADM_vidDGbob.cpp \
  ADM_vidAsharp.cpp \
  ADM_vidCNR2.cpp \
   ADM_vidDelta.cpp \
@@ -140,8 +139,7 @@
 ADM_vidConvolution.cpp  ADM_vidlavdeint.h \
 ADM_vidConvolution.hxx  ADM_vobsubinfo.cpp \
 ADM_vidCrop.cpp  ADM_vidMSmooth_param.h  ADM_vobsubinfo.h \
-ADM_vidDGbob.cpp ASM_vidDenoise.cpp \
-ADM_vidDGbob_param.h   \
+ASM_vidDenoise.cpp \
 ADM_vidDecDec.cpp  ADM_vidMosaic.cpp swscale_internal.h \
 ADM_vidTdeint_util.txt ADM_vidASS.h ADM_vidASS.cpp \
 ADM_vidAss_Params.h mmx_macros.h

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDGbob.cpp (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDGbob.cpp)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDGbob.cpp	2006-10-31 15:59:58 UTC (rev 2489)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDGbob.cpp	2007-01-12 07:15:14 UTC (rev 2708)
@@ -0,0 +1,558 @@
+/*
+	DGBob() plugin for Avisynth -- Smart bob filter. This filter splits
+	each field of the source into its own frame and then adaptively
+	creates the missing lines either by interpolating the current field
+	or by using the previous field's data. The filter attempts with some
+	success to mitigate the flutter that bobbing produces.
+
+	Copyright (C) 2003 Donald A. Graft
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program; if not, write to the Free Software
+	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+
+#include "config.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ADM_assert.h>
+
+#include "config.h"
+#include "fourcc.h"
+#include "avio.hxx"
+#include "avi_vars.h"
+
+#include "ADM_toolkit/toolkit.hxx"
+#include "ADM_editor/ADM_edit.hxx"
+#include "ADM_video/ADM_genvideo.hxx"
+#include"ADM_video/ADM_vidField.h"
+#include"ADM_video/ADM_cache.h"
+
+#include "ADM_osSupport/ADM_debugID.h"
+#define MODULE_NAME MODULE_FILTER
+#include "ADM_osSupport/ADM_debug.h"
+#include "ADM_filter/video_filters.h"
+
+#include "ADM_vidDGbob_param.h"
+
+#include "ADM_userInterfaces/ADM_commonUI/DIA_factory.h"
+
+class DGbob : public AVDMGenericVideoStream
+{
+       
+        DGBobparam      *_param;        
+        
+        VideoCache      *vidCache;
+       
+        void            update(void); 
+public:
+                                
+                        DGbob(AVDMGenericVideoStream *in,CONFcouple *couples);    
+                        ~DGbob(void);
+        uint8_t         getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
+                                ADMImage *data,uint32_t *flags);
+        
+        char            *printConf( void );
+        uint8_t         configure(AVDMGenericVideoStream *in);
+        uint8_t         getCoupledConf( CONFcouple **couples);
+};
+
+static FILTER_PARAM dgbobParam={4,{"order","mode","thresh","ap"}};
+
+BUILD_CREATE(dgbob_create,DGbob);
+SCRIPT_CREATE(dgbob_script,DGbob,dgbobParam);
+
+/*************************************/
+extern uint8_t DIA_getDGbob(DGBobparam *param);
+uint8_t DGbob::configure(AVDMGenericVideoStream *in)
+{
+        _in=in;
+#define PX(x) &(_param->x)
+  
+     diaMenuEntry menuField[2]={{0,_("Top"),NULL},
+                             {1,_("Bottom"),NULL}
+                          };
+  
+     diaMenuEntry menuMode[3]={{0,_("Keep nb of frames and FPS"),NULL},
+                            {1,_("Double nb of frames and FPS"),NULL},
+                            {2,_("Double nb of frames (slow motion)"),NULL}
+                          };
+                          
+    diaElemMenu     menu1(PX(order),_("Field Order"), 2,menuField);
+    diaElemMenu     menu2(PX(mode),_("Mode"), 3,menuMode);
+    diaElemUInteger threshold(PX(thresh),_("Threshold"),0,255);
+    diaElemToggle  extra(PX(ap),_("Extra"),_("Extra check, avoid using it"));
+    
+      diaElem *elems[4]={&menu1,&menu2,&threshold ,&extra};
+   if(diaFactoryRun("DGBob",4,elems))
+  {
+                update();
+                return 1;
+        }
+        return 0;
+        
+}
+
+char *DGbob::printConf( void )
+{
+        static char buf[50];
+
+        //ADM_assert(_param);
+        sprintf((char *)buf," DGBob mode:%d order:%d thresh:%d\n",_param->mode,_param->order,_param->thresh);
+        return buf;
+}
+
+
+DGbob::DGbob(AVDMGenericVideoStream *in,CONFcouple *couples)              
+
+{
+                
+                int count = 0;
+                char buf[80];
+                unsigned int *p;
+
+                _in=in;         
+                memcpy(&_info,_in->getInfo(),sizeof(_info));    
+                _info.encoding=1;
+                _uncompressed=NULL;             
+                _info.encoding=1;
+                _info.fps1000*=2;
+                _info.nb_frames*=2;
+                
+                                
+                vidCache=new VideoCache(7,in);
+                _param= new DGBobparam;
+                if(couples)
+                {
+                        GET(order);
+                        GET(mode);
+                        GET(thresh);
+                        GET(ap);
+                }
+                else
+                {
+                        _param->order=1;
+                        _param->mode=0;
+                        _param->thresh=12;
+                        _param->ap=0;
+                }
+                update();
+}
+void DGbob::update(void)
+{
+                memcpy(&_info,_in->getInfo(),sizeof(_info));    
+                _info.encoding=1;
+                switch(_param->mode)
+                {
+                        case 0:
+                                break;
+                        case 1:
+                                _info.fps1000*=2;
+                                _info.nb_frames*=2;
+                                break;
+                        case 2:
+                                _info.nb_frames*=2;
+                                break;
+                        default: ADM_assert(0);
+
+                }
+             
+}
+//________________________________________________________
+uint8_t DGbob::getCoupledConf( CONFcouple **couples)
+{
+        *couples=NULL;
+        *couples=new CONFcouple(4);
+#define CSET(x)  (*couples)->setCouple((char *)#x,(_param->x))
+        
+        CSET(order);
+        CSET(mode);
+        CSET(thresh);
+        CSET(ap);
+
+        return 1;
+}
+//________________________________________________________
+DGbob::~DGbob(void)
+{
+                
+                if(vidCache) delete vidCache;                
+                vidCache=NULL;   
+                if(_param) delete _param;
+                _param=NULL;                             
+}
+uint8_t DGbob::getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
+                                ADMImage *data,uint32_t *flags)
+{
+        ADMImage *src,*prv,*prvprv,*nxt,*nxtnxt,*dst;
+	uint32_t n,num_frames;
+
+        num_frames=_in->getInfo()->nb_frames;   // ??
+
+	if (_param->mode == 0) n = frame;
+	else n = frame/2;
+
+        src=vidCache->getImage(n);
+        prv=vidCache->getImage(n > 0 ? n - 1 :0 );
+        prvprv=vidCache->getImage(n > 1 ? n - 2 : 0);
+        nxt=vidCache->getImage(n < num_frames - 1 ? n + 1 : num_frames - 1);
+        nxtnxt=vidCache->getImage(n < num_frames - 2 ? n + 2 : num_frames - 1);
+
+
+/*
+	PVideoFrame src = child->GetFrame(n, env);
+	PVideoFrame prv = child->GetFrame(n > 0 ? n - 1 : 0, env);
+	PVideoFrame prvprv = child->GetFrame(n > 1 ? n - 2 : 0, env);
+	PVideoFrame nxt = child->GetFrame(n < vi.num_frames - 1 ? n + 1 : vi.num_frames - 1, env);
+	PVideoFrame nxtnxt = child->GetFrame(n < vi.num_frames - 2 ? n + 2 : vi.num_frames - 1, env);
+    PVideoFrame dst = env->NewVideoFrame(vi);
+*/
+    const unsigned char *srcp, *srcp_saved, *srcpp, *srcpn;
+	const unsigned char *prvp, *prvpp, *prvpn, *prvprvp, *prvprvpp, *prvprvpn;
+	const unsigned char *nxtp, *nxtpp, *nxtpn, *nxtnxtp, *nxtnxtpp, *nxtnxtpn;
+    unsigned char *dstp, *dstp_saved;
+ 
+    int src_pitch, dst_pitch, w, h;
+	int x, y, z, v1, v2, D = _param->thresh, T = 6, AP = 30;
+	int plane;
+
+        uint32_t ww,hh;
+	// Try making D a function of the average value of the comparands in
+	// order to make the margin larger in darker areas, where we can't see as
+	// much combing.
+
+	// Force deinterlacing of the first and last frames.
+	if (n == 0 || n == num_frames - 1) D = 0;
+        dst=data;
+	for (z = 0; z < 3; z++)
+	{
+/*
+		if (z == 0) plane = PLANAR_Y;
+		else if (z == 1) plane = PLANAR_U;
+		else plane = PLANAR_V;
+
+*/
+                switch(z)
+                {
+                        case 0:
+                                ww=_info.width;
+                                hh=_info.height;
+                                srcp_saved = srcp = YPLANE(src);                                
+                                dstp_saved = dstp = YPLANE(dst);
+                                src_pitch = ww;
+                                dst_pitch = ww;
+                                w = ww;
+                                h = hh;
+                                break;
+                        case 1:
+                        case 2:
+                                ww=_info.width>>1;
+                                hh=_info.height>>1;
+                                if(z==1)
+                                {
+                                        srcp_saved = srcp = UPLANE(src);
+                                        dstp_saved = dstp = UPLANE(dst);
+                                }
+                                else
+                                {
+                                        srcp_saved = srcp = VPLANE(src);
+                                        dstp_saved = dstp = VPLANE(dst);
+                                }
+                                src_pitch = ww;
+                                dst_pitch = ww;
+                                w = ww;
+                                h = hh;
+                                break;
+                }
+/*
+		srcp_saved = srcp = src->GetReadPtr(plane);
+		src_pitch = src->GetPitch(plane);
+		dstp_saved = dstp = dst->GetWritePtr(plane);
+		dst_pitch = dst->GetPitch(plane);
+		w = dst->GetRowSize(plane);
+		h = dst->GetHeight(plane);
+*/
+		if ((_param->mode > 0) && (frame & 1))
+		{
+			// Process odd-numbered frames.
+			// Copy field from current frame.
+			srcp = srcp_saved +_param->order * src_pitch;
+			dstp = dstp_saved +_param->order * dst_pitch;
+			for (y = 0; y < h; y+=2)
+			{
+				memcpy(dstp, srcp, w);
+				srcp += 2*src_pitch;
+				dstp += 2*dst_pitch;
+			}
+			// Copy through the line that will be missed below.
+			memcpy(dstp_saved + (1-_param->order)*(h-1)*dst_pitch, srcp_saved + (1-_param->order)*(h-1)*src_pitch, w);
+			/* For the other field choose adaptively between using the previous field
+			   or the interpolant from the current field. */
+                        
+			//prvp = prv->GetReadPtr(plane) + src_pitch + order*src_pitch;
+                        switch(z)
+                        {
+                                case 0:prvp = YPLANE(prv) + src_pitch + _param->order*src_pitch;break;
+                                case 1:prvp = UPLANE(prv) + src_pitch + _param->order*src_pitch;break;
+                                case 2:prvp = VPLANE(prv) + src_pitch + _param->order*src_pitch;break;
+                        }
+			prvpp = prvp - src_pitch;
+			prvpn = prvp + src_pitch;
+			//prvprvp = prvprv->GetReadPtr(plane) + src_pitch + order*src_pitch;
+                         switch(z)
+                        {
+                                case 0:prvprvp = YPLANE(prvprv) + src_pitch + _param->order*src_pitch;break;
+                                case 1:prvprvp = UPLANE(prvprv) + src_pitch + _param->order*src_pitch;break;
+                                case 2:prvprvp = VPLANE(prvprv) + src_pitch + _param->order*src_pitch;break;
+                        }
+
+			prvprvpp = prvprvp - src_pitch;
+			prvprvpn = prvprvp + src_pitch;
+
+			//nxtp = nxt->GetReadPtr(plane) + src_pitch + order*src_pitch;
+                        switch(z)
+                        {
+                                case 0:nxtp = YPLANE(nxt) + src_pitch + _param->order*src_pitch;break;
+                                case 1:nxtp = UPLANE(nxt) + src_pitch + _param->order*src_pitch;break;
+                                case 2:nxtp = VPLANE(nxt) + src_pitch + _param->order*src_pitch;break;
+                        }
+
+			nxtpp = nxtp - src_pitch;
+			nxtpn = nxtp + src_pitch;
+			//nxtnxtp = nxtnxt->GetReadPtr(plane) + src_pitch + order*src_pitch;
+                        switch(z)
+                        {
+                                case 0:nxtnxtp = YPLANE(nxtnxt) + src_pitch + _param->order*src_pitch;break;
+                                case 1:nxtnxtp = UPLANE(nxtnxt) + src_pitch + _param->order*src_pitch;break;
+                                case 2:nxtnxtp = VPLANE(nxtnxt) + src_pitch + _param->order*src_pitch;break;
+                        }
+			nxtnxtpp = nxtnxtp - src_pitch;
+			nxtnxtpn = nxtnxtp + src_pitch;
+			srcp =  srcp_saved + src_pitch + _param->order*src_pitch;
+			srcpp = srcp - src_pitch;
+			srcpn = srcp + src_pitch;
+			dstp =  dstp_saved + dst_pitch + _param->order*dst_pitch;
+			for (y = 0; y < h - 2; y+=2)
+			{
+				for (x = 0; x < w; x++)
+				{
+					if (
+						abs(srcp[x] - nxtp[x]) < D
+//						&& abs(srcp[x] - nxtnxtp[x]) < D
+//						&& abs(prvp[x] - nxtp[x]) < D
+						&& abs(srcpn[x] - prvprvpn[x]) < D
+						&& abs(srcpp[x] - prvprvpp[x]) < D
+						&& abs(srcpn[x] - nxtnxtpn[x]) < D
+						&& abs(srcpp[x] - nxtnxtpp[x]) < D
+						&& abs(srcpn[x] - prvpn[x]) < D
+						&& abs(srcpp[x] - prvpp[x]) < D
+						&& abs(srcpn[x] - nxtpn[x]) < D
+						&& abs(srcpp[x] - nxtpp[x]) < D
+					   )
+					{
+						if (_param->ap == true)
+						{
+							v1 = (int) srcp[x] - AP;
+							if (v1 < 0) v1 = 0; 
+							v2 = (int) srcp[x] + AP;
+							if (v2 > 235) v2 = 235; 
+							if ((v1 > srcpp[x] && v1 > srcpn[x]) || (v2 < srcpp[x] && v2 < srcpn[x]))
+							{
+								dstp[x] = ((int)srcpp[x] + srcpn[x]) >> 1;
+//								if (x & 1) dstp[x] = 100; else dstp[x] = 235;
+							}
+							else
+							{
+								dstp[x] = srcp[x];
+//								if (x & 1) dstp[x] = 100; else dstp[x] = 235;
+							}
+						}
+						else
+						{
+							dstp[x] = srcp[x];
+//							if (x & 1) dstp[x] = 100; else dstp[x] = 235;
+						}
+					}
+					else
+					{
+						v1 = (int) srcp[x] - T;
+						if (v1 < 0) v1 = 0; 
+						v2 = (int) srcp[x] + T;
+						if (v2 > 235) v2 = 235; 
+						if ((v1 > srcpp[x] && v1 > srcpn[x]) || (v2 < srcpp[x] && v2 < srcpn[x]))
+						{
+							dstp[x] = ((int)srcpp[x] + srcpn[x]) >> 1;
+						}
+						else
+						{
+							dstp[x] = srcp[x];
+//							if (x & 1) dstp[x] = 128; else dstp[x] = 235;
+						}
+					}
+				}
+				prvp    += 2*src_pitch;
+				prvpp    += 2*src_pitch;
+				prvpn    += 2*src_pitch;
+				prvprvpp    += 2*src_pitch;
+				prvprvpn    += 2*src_pitch;
+				nxtp    += 2*src_pitch;
+				nxtpp    += 2*src_pitch;
+				nxtpn    += 2*src_pitch;
+				nxtnxtpp    += 2*src_pitch;
+				nxtnxtpn    += 2*src_pitch;
+				srcp    += 2*src_pitch;
+				srcpp   += 2*src_pitch;
+				srcpn   += 2*src_pitch;
+				dstp    += 2*dst_pitch;
+			}
+		}
+		else
+		{
+			// Process even-numbered frames.
+			// Copy field from current frame.
+			srcp = srcp_saved + (1-_param->order) * src_pitch;
+			dstp = dstp_saved + (1-_param->order) * dst_pitch;
+			for (y = 0; y < h; y+=2)
+			{
+				memcpy(dstp, srcp, w);
+				srcp += 2*src_pitch;
+				dstp += 2*dst_pitch;
+			}
+			// Copy through the line that will be missed below.
+			memcpy(dstp_saved + _param->order*(h-1)*dst_pitch, srcp_saved + _param->order*(h-1)*src_pitch, w);
+			/* For the other field choose adaptively between using the previous field
+			   or the interpolant from the current field. */
+			//prvp = prv->GetReadPtr(plane) + src_pitch + (1-order)*src_pitch;
+                        switch(z)
+                        {
+                                case 0:prvp = YPLANE(prv) + src_pitch + (1-_param->order)*src_pitch;break;
+                                case 1:prvp = UPLANE(prv) + src_pitch + (1-_param->order)*src_pitch;break;
+                                case 2:prvp = VPLANE(prv) + src_pitch + (1-_param->order)*src_pitch;break;
+                        }
+			prvpp = prvp - src_pitch;
+			prvpn = prvp + src_pitch;
+			// prvprvp = prvprv->GetReadPtr(plane) + src_pitch + (1-order)*src_pitch;
+                        switch(z)
+                        {
+                                case 0:prvprvp = YPLANE(prvprv) + src_pitch + (1-_param->order)*src_pitch;break;
+                                case 1:prvprvp = UPLANE(prvprv) + src_pitch + (1-_param->order)*src_pitch;break;
+                                case 2:prvprvp = VPLANE(prvprv) + src_pitch + (1-_param->order)*src_pitch;break;
+                        }
+                        
+			prvprvpp = prvprvp - src_pitch;
+			prvprvpn = prvprvp + src_pitch;
+			//nxtp = nxt->GetReadPtr(plane) + src_pitch + (1-order)*src_pitch;
+                        switch(z)
+                        {
+                                case 0:nxtp = YPLANE(nxt) + src_pitch + (1-_param->order)*src_pitch;break;
+                                case 1:nxtp = UPLANE(nxt) + src_pitch + (1-_param->order)*src_pitch;break;
+                                case 2:nxtp = VPLANE(nxt) + src_pitch + (1-_param->order)*src_pitch;break;
+                        }
+			nxtpp = nxtp - src_pitch;
+			nxtpn = nxtp + src_pitch;
+			//nxtnxtp = nxtnxt->GetReadPtr(plane) + src_pitch + (1-order)*src_pitch;
+                         switch(z)
+                        {
+                                case 0:nxtnxtp = YPLANE(nxtnxt) + src_pitch + (1-_param->order)*src_pitch;break;
+                                case 1:nxtnxtp = UPLANE(nxtnxt) + src_pitch + (1-_param->order)*src_pitch;break;
+                                case 2:nxtnxtp = VPLANE(nxtnxt) + src_pitch + (1-_param->order)*src_pitch;break;
+                        }
+			nxtnxtpp = nxtnxtp - src_pitch;
+			nxtnxtpn = nxtnxtp + src_pitch;
+			srcp =  srcp_saved + src_pitch + (1-_param->order)*src_pitch;
+			srcpp = srcp - src_pitch;
+			srcpn = srcp + src_pitch;
+			dstp =  dstp_saved + dst_pitch + (1-_param->order)*dst_pitch;
+			for (y = 0; y < h - 2; y+=2)
+			{
+				for (x = 0; x < w; x++)
+				{
+					if (
+						abs(srcp[x] - prvp[x]) < D
+//						&& abs(srcp[x] - prvprvp[x]) < D
+//						&& abs(prvp[x] - nxtp[x]) < D
+						&& abs(srcpn[x] - prvprvpn[x]) < D
+						&& abs(srcpp[x] - prvprvpp[x]) < D
+						&& abs(srcpn[x] - nxtnxtpn[x]) < D
+						&& abs(srcpp[x] - nxtnxtpp[x]) < D
+						&& abs(srcpn[x] - prvpn[x]) < D
+						&& abs(srcpp[x] - prvpp[x]) < D
+						&& abs(srcpn[x] - nxtpn[x]) < D
+						&& abs(srcpp[x] - nxtpp[x]) < D
+					   )
+					{
+						if (_param->ap == true)
+						{
+							v1 = (int) prvp[x] - AP;
+							if (v1 < 0) v1 = 0; 
+							v2 = (int) prvp[x] + AP;
+							if (v2 > 235) v2 = 235; 
+							if ((v1 > srcpp[x] && v1 > srcpn[x]) ||	(v2 < srcpp[x] && v2 < srcpn[x]))
+							{
+								dstp[x] = ((int)srcpp[x] + srcpn[x]) >> 1;
+//								if (x & 1) dstp[x] = 100; else dstp[x] = 235;
+							}
+							else
+							{
+								dstp[x] = prvp[x];
+//								if (x & 1) dstp[x] = 128; else dstp[x] = 235;
+							}
+						}
+						else
+						{
+							dstp[x] = prvp[x];
+//							if (x & 1) dstp[x] = 128; else dstp[x] = 235;
+						}
+					}
+					else
+					{
+						v1 = (int) prvp[x] - T;
+						if (v1 < 0) v1 = 0; 
+						v2 = (int) prvp[x] + T;
+						if (v2 > 235) v2 = 235; 
+						if ((v1 > srcpp[x] && v1 > srcpn[x]) ||	(v2 < srcpp[x] && v2 < srcpn[x]))
+						{
+							dstp[x] = ((int)srcpp[x] + srcpn[x]) >> 1;
+						}
+						else
+						{
+							dstp[x] = prvp[x];
+//							if (x & 1) pp[x] = 128; else dstp[x] = 235;
+						}
+					}
+				}
+				prvp    += 2*src_pitch;
+				prvpp    += 2*src_pitch;
+				prvpn    += 2*src_pitch;
+				prvprvpp    += 2*src_pitch;
+				prvprvpn    += 2*src_pitch;
+				nxtp    += 2*src_pitch;
+				nxtpp    += 2*src_pitch;
+				nxtpn    += 2*src_pitch;
+				nxtnxtpp    += 2*src_pitch;
+				nxtnxtpn    += 2*src_pitch;
+				srcp    += 2*src_pitch;
+				srcpp   += 2*src_pitch;
+				srcpn   += 2*src_pitch;
+				dstp    += 2*dst_pitch;
+			}
+		}
+	}
+        vidCache->unlockAll();
+	return 1;
+}
+//EOF
+
+
+

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDGbob_param.h (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDGbob_param.h)

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am	2007-01-12 06:50:08 UTC (rev 2707)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am	2007-01-12 07:15:14 UTC (rev 2708)
@@ -7,6 +7,7 @@
 #INCLUDES = $(all_includes) 
 
 libADM_videoFilter_a_SOURCES =  \
+ ADM_vidDGbob.cpp \
  ADM_vidForcedPP.cpp \
  ADM_vidMSharpen.cpp \
  ADM_vidDenoise.cpp \



From mean at mail.berlios.de  Fri Jan 12 19:54:09 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 12 Jan 2007 19:54:09 +0100
Subject: [Avidemux-svn-commit] r2709 - in
	branches/avidemux_2.4_branch/avidemux: . ADM_audiofilter
	ADM_filter ADM_userInterfaces/ADM_GTK/ADM_dialog
	ADM_userInterfaces/ADM_commonUI
Message-ID: <200701121854.l0CIs94V011083@sheep.berlios.de>

Author: mean
Date: 2007-01-12 19:54:07 +0100 (Fri, 12 Jan 2007)
New Revision: 2709

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_builtin.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_resizeWiz.cpp
Removed:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_audiocodec.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_builtin.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_d3d.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_resizeWiz.cpp
Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_audiofilter/audiodeng_buildfilters.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_filter/vidVCD.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_filter/vidVCD.h
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_resizeWiz.h
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/Makefile.am
   branches/avidemux_2.4_branch/avidemux/gtk_gui.cpp
   branches/avidemux_2.4_branch/avidemux/gui_autodrive.cpp
Log:
more dialogFactory + psp full res profile (not working)

Modified: branches/avidemux_2.4_branch/avidemux/ADM_audiofilter/audiodeng_buildfilters.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_audiofilter/audiodeng_buildfilters.cpp	2007-01-12 07:15:14 UTC (rev 2708)
+++ branches/avidemux_2.4_branch/avidemux/ADM_audiofilter/audiodeng_buildfilters.cpp	2007-01-12 18:54:07 UTC (rev 2709)
@@ -49,7 +49,6 @@
 
 extern void UI_setAProcessToggleStatus( uint8_t status );
 extern uint8_t DIA_audioCodec( AUDIOENCODER *codec );
-extern int DIA_audioEncoder(int *pmode, int *pbitrate,const char *title);
 extern void UI_setAudioCodec( int i);
 uint32_t audioFilterGetNbEncoder(void);
 const char* audioFilterGetIndexedName(uint32_t i);

Modified: branches/avidemux_2.4_branch/avidemux/ADM_filter/vidVCD.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_filter/vidVCD.cpp	2007-01-12 07:15:14 UTC (rev 2708)
+++ branches/avidemux_2.4_branch/avidemux/ADM_filter/vidVCD.cpp	2007-01-12 18:54:07 UTC (rev 2709)
@@ -72,12 +72,11 @@
 static targetFmt SVCD={480, 720, 576, 480};
 static targetFmt DVD={720, 720, 576, 480};
 static targetFmt DVDHD1={352, 720, 576, 480};
-#if 0
-static targetFmt PSP={368, 368, 208, 208};
-#else
 static targetFmt PSP={320, 320, 240, 240};
-#endif
-targetFmt *allFormats[5]={&VCD,&SVCD,&DVD,&DVDHD1,&PSP};
+static targetFmt PSPH264={480, 480, 272, 272};
+/* Dont forget to update DIA_resizeWiz if you change something here */
+
+targetFmt *allFormats[6]={&VCD,&SVCD,&DVD,&DVDHD1,&PSP,&PSPH264};
 extern AVDMGenericVideoStream *createResampleFps(AVDMGenericVideoStream *in,uint32_t targetfps1000);
 #define ARME(x) format=RESWIZ_##x;
 
@@ -98,25 +97,22 @@
 uint32_t fps1000;
 
     ARME (PSP);
-    r= computeResize();
-    if(!r) return r;
-#if 0 // Not needed with recent firmware
-    // Now change framerate to 29.96
-    info=getLastVideoFilter()->getInfo();
-    fps1000=info->fps1000;
-    if(identMovieType(fps1000) != FRAME_NTSC)
-    {
-      CONFcouple *couple;
-      
-      videofilters[nb_active_filter].filter = createResampleFps (getLastVideoFilter (), 29970);
-      videofilters[nb_active_filter].tag = VF_RESAMPLE_FPS;
-      videofilters[nb_active_filter].filter->getCoupledConf (&couple);
-      videofilters[nb_active_filter].conf = couple;;
-      nb_active_filter++;
-    }
-#endif    
-    return r;
+    return computeResize();
 }
+/**
+    \fn     setPSPFullRes (void)
+    \brief  Setup  video size & fps to be compatible with PSP FULL SCREEN
+*/
+uint8_t setPSPFullRes (void)
+{
+uint8_t r=0;
+ADV_Info *info;
+uint32_t fps1000;
+
+    ARME (PSP_FULLRES);
+    return computeResize();
+}
+
 uint8_t setSVCD (void)
 {
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_filter/vidVCD.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_filter/vidVCD.h	2007-01-12 07:15:14 UTC (rev 2708)
+++ branches/avidemux_2.4_branch/avidemux/ADM_filter/vidVCD.h	2007-01-12 18:54:07 UTC (rev 2709)
@@ -22,6 +22,7 @@
 uint8_t setSVCD( void );
 uint8_t setVCD( void );
 uint8_t setPSP(void);
+uint8_t setPSPFullRes(void);
 uint8_t setDVD( void );
 uint8_t setHalfD1( void );
 

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_audiocodec.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_audiocodec.cpp	2007-01-12 07:15:14 UTC (rev 2708)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_audiocodec.cpp	2007-01-12 18:54:07 UTC (rev 2709)
@@ -1,203 +0,0 @@
-/*
- * DO NOT EDIT THIS FILE - it is generated by Glade.
- */
-
-#include "config.h"
-
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <unistd.h>
-#include <string.h>
-#include <stdio.h>
-#include <stdlib.h>
-
-#include <gdk/gdkkeysyms.h>
-#include <gtk/gtk.h>
-
-#include <ADM_assert.h>
-
-#include "fourcc.h"
-#include "ADM_audio/aviaudio.hxx"
-#include "ADM_audiofilter/audioprocess.hxx"
-#include "ADM_toolkit_gtk/toolkit_gtk.h"
-#include "ADM_audiofilter/audioeng_buildfilters.h"
-#include "ADM_toolkit_gtk/ADM_gladeSupport.h"
-
-
-#define GLADE_HOOKUP_OBJECT(component,widget,name) \
-  g_object_set_data_full (G_OBJECT (component), name, \
-    gtk_widget_ref (widget), (GDestroyNotify) gtk_widget_unref)
-
-#define GLADE_HOOKUP_OBJECT_NO_REF(component,widget,name) \
-  g_object_set_data (G_OBJECT (component), name, widget)
-
-static GtkWidget	*create_dialog1 (void);
-  
-#define NB_BITRATE (sizeof(BTR)/sizeof(int))
-
-static int BTR[] = {		// see interface.c if you change this !
-		48,
-		56,
-		64,
-		80,
-    		96,
-    		112,
-    		128,
-   		 160,
-    		192,
-   		 224,
-		 384
-};
-int DIA_audioEncoder(int *pmode, int *pbitrate,const char *title)
-{
-GtkWidget *dialog;
-int ret=0;
-
-	UNUSED_ARG(title);
-	dialog=create_dialog1();
-//	gtk_transient(dialog);		
-        gtk_register_dialog(dialog);
-	for(uint32_t i=0;i<NB_BITRATE;i++)
-		if(*pbitrate==BTR[i])
-			{
-				// set 
-				gtk_option_menu_set_history(GTK_OPTION_MENU(lookup_widget(dialog,"optionmenu1")), i);
-			}	
-			
-			
-	switch(*pmode)
-	{
-		case ADM_STEREO: 
-					gtk_option_menu_set_history(GTK_OPTION_MENU(lookup_widget(dialog,"optionmenu2")),0);		
-					break;
-		case ADM_JSTEREO: 
-					gtk_option_menu_set_history(GTK_OPTION_MENU(lookup_widget(dialog,"optionmenu2")),1);		
-					break;					
-	}			
-	if(GTK_RESPONSE_OK==gtk_dialog_run(GTK_DIALOG(dialog)))			
-	{
-					if(getRangeInMenu(lookup_widget(dialog,"optionmenu2"))==1)
-							*pmode=ADM_JSTEREO;
-					else
-							*pmode=ADM_STEREO;
-					*pbitrate=BTR[getRangeInMenu(lookup_widget(dialog,"optionmenu1"))];
-					ret=1;
-																						
-	}
-	gtk_unregister_dialog(dialog);
-	gtk_widget_destroy(dialog);
-	return ret;	    
-
-}
-  
-GtkWidget	*create_dialog1 (void)
-{
-  GtkWidget *dialog1;
-  GtkWidget *dialog_vbox1;
-  GtkWidget *vbox1;
-  GtkWidget *label1;
-  GtkWidget *optionmenu1;
-  GtkWidget *menu2;
- // GtkWidget *_48_khz1;
-  GtkWidget *label2;
-  GtkWidget *optionmenu2;
-  GtkWidget *menu1;
-  GtkWidget *stereo1;
-  GtkWidget *joint_stereo1;
-  GtkWidget *dialog_action_area1;
-  GtkWidget *cancelbutton1;
-  GtkWidget *okbutton1;
-
-  dialog1 = gtk_dialog_new ();
-  gtk_window_set_title (GTK_WINDOW (dialog1), _("Audio settings"));
-
-  dialog_vbox1 = GTK_DIALOG (dialog1)->vbox;
-  gtk_widget_show (dialog_vbox1);
-
-  vbox1 = gtk_vbox_new (FALSE, 0);
-  gtk_widget_show (vbox1);
-  gtk_box_pack_start (GTK_BOX (dialog_vbox1), vbox1, TRUE, TRUE, 0);
-
-  label1 = gtk_label_new (_("Bitrate"));
-  gtk_widget_show (label1);
-  gtk_box_pack_start (GTK_BOX (vbox1), label1, FALSE, FALSE, 0);
-  gtk_label_set_justify (GTK_LABEL (label1), GTK_JUSTIFY_LEFT);
-
-  optionmenu1 = gtk_option_menu_new ();
-  gtk_widget_show (optionmenu1);
-  gtk_box_pack_start (GTK_BOX (vbox1), optionmenu1, FALSE, FALSE, 0);
-
-  menu2 = gtk_menu_new ();
-/*
-  _48_khz1 = gtk_menu_item_new_with_mnemonic (_("48 khz"));
-  gtk_widget_show (_48_khz1);
-  gtk_container_add (GTK_CONTAINER (menu2), _48_khz1);
-  
-
-*/
-	GtkWidget **fq=(GtkWidget **)ADM_alloc(sizeof(GtkWidget *)*NB_BITRATE);
-	char string[100];
-	for(unsigned int i=0;i<NB_BITRATE;i++)
-	{
-		sprintf(string,"%d kbits",BTR[i]);
-		fq[i]=gtk_menu_item_new_with_mnemonic (string);
-		gtk_widget_show (fq[i]);
-		gtk_container_add (GTK_CONTAINER (menu2), fq[i]);
-	}
-  gtk_option_menu_set_menu (GTK_OPTION_MENU (optionmenu1), menu2);
-  
-  label2 = gtk_label_new (_("Mode (ignored for mono)"));
-  gtk_widget_show (label2);
-  gtk_box_pack_start (GTK_BOX (vbox1), label2, FALSE, FALSE, 0);
-  gtk_label_set_justify (GTK_LABEL (label2), GTK_JUSTIFY_LEFT);
-
-  optionmenu2 = gtk_option_menu_new ();
-  gtk_widget_show (optionmenu2);
-  gtk_box_pack_start (GTK_BOX (vbox1), optionmenu2, FALSE, FALSE, 0);
-
-  menu1 = gtk_menu_new ();
-
-  stereo1 = gtk_menu_item_new_with_mnemonic (_("Stereo"));
-  gtk_widget_show (stereo1);
-  gtk_container_add (GTK_CONTAINER (menu1), stereo1);
-
-  joint_stereo1 = gtk_menu_item_new_with_mnemonic (_("Joint Stereo"));
-  gtk_widget_show (joint_stereo1);
-  gtk_container_add (GTK_CONTAINER (menu1), joint_stereo1);
-
-  gtk_option_menu_set_menu (GTK_OPTION_MENU (optionmenu2), menu1);
-
-  dialog_action_area1 = GTK_DIALOG (dialog1)->action_area;
-  gtk_widget_show (dialog_action_area1);
-  gtk_button_box_set_layout (GTK_BUTTON_BOX (dialog_action_area1), GTK_BUTTONBOX_END);
-
-  cancelbutton1 = gtk_button_new_from_stock ("gtk-cancel");
-  gtk_widget_show (cancelbutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), cancelbutton1, GTK_RESPONSE_CANCEL);
-  GTK_WIDGET_SET_FLAGS (cancelbutton1, GTK_CAN_DEFAULT);
-
-  okbutton1 = gtk_button_new_from_stock ("gtk-ok");
-  gtk_widget_show (okbutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), okbutton1, GTK_RESPONSE_OK);
-  GTK_WIDGET_SET_FLAGS (okbutton1, GTK_CAN_DEFAULT);
-
-  /* Store pointers to all widgets, for use by lookup_widget(). */
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog1, "dialog1");
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_vbox1, "dialog_vbox1");
-  GLADE_HOOKUP_OBJECT (dialog1, vbox1, "vbox1");
-  GLADE_HOOKUP_OBJECT (dialog1, label1, "label1");
-  GLADE_HOOKUP_OBJECT (dialog1, optionmenu1, "optionmenu1");
-  GLADE_HOOKUP_OBJECT (dialog1, menu2, "menu2");
-  //GLADE_HOOKUP_OBJECT (dialog1, _48_khz1, "_48_khz1");
-  GLADE_HOOKUP_OBJECT (dialog1, label2, "label2");
-  GLADE_HOOKUP_OBJECT (dialog1, optionmenu2, "optionmenu2");
-  GLADE_HOOKUP_OBJECT (dialog1, menu1, "menu1");
-  GLADE_HOOKUP_OBJECT (dialog1, stereo1, "stereo1");
-  GLADE_HOOKUP_OBJECT (dialog1, joint_stereo1, "joint_stereo1");
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_action_area1, "dialog_action_area1");
-  GLADE_HOOKUP_OBJECT (dialog1, cancelbutton1, "cancelbutton1");
-  GLADE_HOOKUP_OBJECT (dialog1, okbutton1, "okbutton1");
-
-  return dialog1;
-}
-

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_builtin.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_builtin.cpp	2007-01-12 07:15:14 UTC (rev 2708)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_builtin.cpp	2007-01-12 18:54:07 UTC (rev 2709)
@@ -1,388 +0,0 @@
-//
-/**/
-/***************************************************************************
-                          DIA_hue
-                             -------------------
-
-                           Ui for hue & sat
-
-    begin                : 08 Apr 2005
-    copyright            : (C) 2004/5 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-
-
-#include <config.h>
-
-
-#include <string.h>
-#include <stdio.h>
-
-#include <gdk/gdkkeysyms.h>
-#include <gtk/gtk.h>
-
-
-#include <gdk/gdkkeysyms.h>
-#include <gtk/gtk.h>
-# include <math.h>
-
-
-#include "default.h"
-#include "ADM_toolkit_gtk/ADM_gladeSupport.h"
-#include "ADM_toolkit_gtk/toolkit_gtk.h"
-#include "ADM_toolkit_gtk/toolkit_gtk_include.h"
-#include "ADM_toolkit/toolkit.hxx"
-#include "default.h"
-#include "ADM_assert.h"
-static GtkWidget *create_dialog1 (void);
-#define CHECK_SET(x) {gtk_toggle_button_set_active( GTK_TOGGLE_BUTTON(WID(x)),1);}
-uint8_t DIA_builtin(void)
-{
-GtkWidget *dialog;
-        dialog=create_dialog1();
-
-#ifdef USE_ALTIVEC
-        CHECK_SET(checkbutton1)
-#endif
-#ifdef USE_MP3
-        CHECK_SET(checkbutton2)
-#endif
-#ifdef USE_AC3
-        CHECK_SET(checkbutton3)
-#endif
-#ifdef USE_XVID_4
-        CHECK_SET(checkbutton4)
-#endif
-#ifdef USE_X264
-        CHECK_SET(checkbutton5)
-#endif
-#ifdef USE_FREETYPE
-        CHECK_SET(checkbutton6)
-#endif
-#ifdef USE_ESD
-        CHECK_SET(checkbutton7)
-#endif
-#ifdef USE_ARTS
-        CHECK_SET(checkbutton8)
-#endif
-#ifdef USE_VORBIS
-        CHECK_SET(checkbutton9)
-#endif
-#ifdef CYG_MANGLING
-        CHECK_SET(checkbutton10)
-#endif
-#ifdef USE_FAAC
-        CHECK_SET(checkbutton11)
-#endif
-#ifdef USE_FAAD
-        CHECK_SET(checkbutton12)
-#endif
-#ifdef USE_LIBDCA
-        CHECK_SET(checkbutton13)
-#endif
-
-
-        gtk_register_dialog(dialog);
-        gtk_dialog_run(GTK_DIALOG(dialog));
-
-        gtk_unregister_dialog(dialog);
-        gtk_widget_destroy(dialog);
-        return 1;
-
-}
-
-GtkWidget*
-create_dialog1 (void)
-{
-  GtkWidget *dialog1;
-  GtkWidget *dialog_vbox1;
-  GtkWidget *vbox1;
-  GtkWidget *vbox2;
-  GtkWidget *label1;
-  GtkWidget *hseparator1;
-  GtkWidget *table2;
-  GtkWidget *label6;
-  GtkWidget *label8;
-  GtkWidget *label9;
-  GtkWidget *label10;
-  GtkWidget *label2;
-  GtkWidget *label3;
-  GtkWidget *label4;
-  GtkWidget *label11;
-  GtkWidget *label7;
-  GtkWidget *label5;
-  GtkWidget *checkbutton1;
-  GtkWidget *checkbutton2;
-  GtkWidget *checkbutton3;
-  GtkWidget *checkbutton4;
-  GtkWidget *checkbutton5;
-  GtkWidget *checkbutton6;
-  GtkWidget *checkbutton7;
-  GtkWidget *checkbutton8;
-  GtkWidget *checkbutton9;
-  GtkWidget *checkbutton10;
-  GtkWidget *label12;
-  GtkWidget *label13;
-  GtkWidget *checkbutton11;
-  GtkWidget *checkbutton12;
-  GtkWidget *label14;
-  GtkWidget *checkbutton13;
-  GtkWidget *dialog_action_area1;
-  GtkWidget *closebutton1;
-
-  dialog1 = gtk_dialog_new ();
-  gtk_window_set_title (GTK_WINDOW (dialog1), _("Builtin support for"));
-  gtk_window_set_type_hint (GTK_WINDOW (dialog1), GDK_WINDOW_TYPE_HINT_DIALOG);
-
-  dialog_vbox1 = GTK_DIALOG (dialog1)->vbox;
-  gtk_widget_show (dialog_vbox1);
-
-  vbox1 = gtk_vbox_new (FALSE, 0);
-  gtk_widget_show (vbox1);
-  gtk_box_pack_start (GTK_BOX (dialog_vbox1), vbox1, TRUE, TRUE, 0);
-
-  vbox2 = gtk_vbox_new (FALSE, 0);
-  gtk_widget_show (vbox2);
-  gtk_box_pack_start (GTK_BOX (vbox1), vbox2, TRUE, TRUE, 0);
-
-  label1 = gtk_label_new (_("If an option is not checked, it means\nyou must RECOMPILE avidemux to have\nsupport for it!"));
-  gtk_widget_show (label1);
-  gtk_box_pack_start (GTK_BOX (vbox2), label1, FALSE, FALSE, 0);
-  gtk_label_set_justify (GTK_LABEL (label1), GTK_JUSTIFY_FILL);
-
-  hseparator1 = gtk_hseparator_new ();
-  gtk_widget_show (hseparator1);
-  gtk_box_pack_start (GTK_BOX (vbox2), hseparator1, TRUE, TRUE, 0);
-
-  table2 = gtk_table_new (13, 2, FALSE);
-  gtk_widget_show (table2);
-  gtk_box_pack_start (GTK_BOX (vbox1), table2, TRUE, TRUE, 0);
-
-  label6 = gtk_label_new (_("X264"));
-  gtk_widget_show (label6);
-  gtk_table_attach (GTK_TABLE (table2), label6, 0, 1, 4, 5,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_misc_set_alignment (GTK_MISC (label6), 0, 0.5);
-
-  label8 = gtk_label_new (_("ESD"));
-  gtk_widget_show (label8);
-  gtk_table_attach (GTK_TABLE (table2), label8, 0, 1, 6, 7,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_misc_set_alignment (GTK_MISC (label8), 0, 0.5);
-
-  label9 = gtk_label_new (_("Arts"));
-  gtk_widget_show (label9);
-  gtk_table_attach (GTK_TABLE (table2), label9, 0, 1, 7, 8,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_misc_set_alignment (GTK_MISC (label9), 0, 0.5);
-
-  label10 = gtk_label_new (_("Vorbis"));
-  gtk_widget_show (label10);
-  gtk_table_attach (GTK_TABLE (table2), label10, 0, 1, 8, 9,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_misc_set_alignment (GTK_MISC (label10), 0, 0.5);
-
-  label2 = gtk_label_new (_("Altivec"));
-  gtk_widget_show (label2);
-  gtk_table_attach (GTK_TABLE (table2), label2, 0, 1, 0, 1,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_misc_set_alignment (GTK_MISC (label2), 0, 0.5);
-
-  label3 = gtk_label_new (_("Mad"));
-  gtk_widget_show (label3);
-  gtk_table_attach (GTK_TABLE (table2), label3, 0, 1, 1, 2,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_misc_set_alignment (GTK_MISC (label3), 0, 0.5);
-
-  label4 = gtk_label_new (_("A52"));
-  gtk_widget_show (label4);
-  gtk_table_attach (GTK_TABLE (table2), label4, 0, 1, 2, 3,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_misc_set_alignment (GTK_MISC (label4), 0, 0.5);
-
-  label11 = gtk_label_new (_("Win32"));
-  gtk_widget_show (label11);
-  gtk_table_attach (GTK_TABLE (table2), label11, 0, 1, 9, 10,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_misc_set_alignment (GTK_MISC (label11), 0, 0.5);
-
-  label7 = gtk_label_new (_("Freetype"));
-  gtk_widget_show (label7);
-  gtk_table_attach (GTK_TABLE (table2), label7, 0, 1, 5, 6,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_misc_set_alignment (GTK_MISC (label7), 0, 0.5);
-
-  label5 = gtk_label_new (_("Xvid"));
-  gtk_widget_show (label5);
-  gtk_table_attach (GTK_TABLE (table2), label5, 0, 1, 3, 4,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_misc_set_alignment (GTK_MISC (label5), 0, 0.5);
-
-  checkbutton1 = gtk_check_button_new_with_mnemonic ("");
-  gtk_widget_show (checkbutton1);
-  gtk_table_attach (GTK_TABLE (table2), checkbutton1, 1, 2, 0, 1,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-
-  checkbutton2 = gtk_check_button_new_with_mnemonic ("");
-  gtk_widget_show (checkbutton2);
-  gtk_table_attach (GTK_TABLE (table2), checkbutton2, 1, 2, 1, 2,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-
-  checkbutton3 = gtk_check_button_new_with_mnemonic ("");
-  gtk_widget_show (checkbutton3);
-  gtk_table_attach (GTK_TABLE (table2), checkbutton3, 1, 2, 2, 3,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-
-  checkbutton4 = gtk_check_button_new_with_mnemonic ("");
-  gtk_widget_show (checkbutton4);
-  gtk_table_attach (GTK_TABLE (table2), checkbutton4, 1, 2, 3, 4,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-
-  checkbutton5 = gtk_check_button_new_with_mnemonic ("");
-  gtk_widget_show (checkbutton5);
-  gtk_table_attach (GTK_TABLE (table2), checkbutton5, 1, 2, 4, 5,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-
-  checkbutton6 = gtk_check_button_new_with_mnemonic ("");
-  gtk_widget_show (checkbutton6);
-  gtk_table_attach (GTK_TABLE (table2), checkbutton6, 1, 2, 5, 6,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-
-  checkbutton7 = gtk_check_button_new_with_mnemonic ("");
-  gtk_widget_show (checkbutton7);
-  gtk_table_attach (GTK_TABLE (table2), checkbutton7, 1, 2, 6, 7,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-
-  checkbutton8 = gtk_check_button_new_with_mnemonic ("");
-  gtk_widget_show (checkbutton8);
-  gtk_table_attach (GTK_TABLE (table2), checkbutton8, 1, 2, 7, 8,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-
-  checkbutton9 = gtk_check_button_new_with_mnemonic ("");
-  gtk_widget_show (checkbutton9);
-  gtk_table_attach (GTK_TABLE (table2), checkbutton9, 1, 2, 8, 9,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-
-  checkbutton10 = gtk_check_button_new_with_mnemonic ("");
-  gtk_widget_show (checkbutton10);
-  gtk_table_attach (GTK_TABLE (table2), checkbutton10, 1, 2, 9, 10,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-
-  label12 = gtk_label_new (_("FAAC"));
-  gtk_widget_show (label12);
-  gtk_table_attach (GTK_TABLE (table2), label12, 0, 1, 10, 11,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_misc_set_alignment (GTK_MISC (label12), 0, 0.5);
-
-  label13 = gtk_label_new (_("FAAD"));
-  gtk_widget_show (label13);
-  gtk_table_attach (GTK_TABLE (table2), label13, 0, 1, 11, 12,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_misc_set_alignment (GTK_MISC (label13), 0, 0.5);
-
-  checkbutton11 = gtk_check_button_new_with_mnemonic ("");
-  gtk_widget_show (checkbutton11);
-  gtk_table_attach (GTK_TABLE (table2), checkbutton11, 1, 2, 10, 11,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-
-  checkbutton12 = gtk_check_button_new_with_mnemonic ("");
-  gtk_widget_show (checkbutton12);
-  gtk_table_attach (GTK_TABLE (table2), checkbutton12, 1, 2, 11, 12,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-
-  label14 = gtk_label_new (_("libDCA/libDTS"));
-  gtk_widget_show (label14);
-  gtk_table_attach (GTK_TABLE (table2), label14, 0, 1, 12, 13,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_misc_set_alignment (GTK_MISC (label14), 0, 0.5);
-
-  checkbutton13 = gtk_check_button_new_with_mnemonic ("");
-  gtk_widget_show (checkbutton13);
-  gtk_table_attach (GTK_TABLE (table2), checkbutton13, 1, 2, 12, 13,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-
-  dialog_action_area1 = GTK_DIALOG (dialog1)->action_area;
-  gtk_widget_show (dialog_action_area1);
-  gtk_button_box_set_layout (GTK_BUTTON_BOX (dialog_action_area1), GTK_BUTTONBOX_END);
-
-  closebutton1 = gtk_button_new_from_stock ("gtk-close");
-  gtk_widget_show (closebutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), closebutton1, GTK_RESPONSE_CLOSE);
-  GTK_WIDGET_SET_FLAGS (closebutton1, GTK_CAN_DEFAULT);
-
-  /* Store pointers to all widgets, for use by lookup_widget(). */
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog1, "dialog1");
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_vbox1, "dialog_vbox1");
-  GLADE_HOOKUP_OBJECT (dialog1, vbox1, "vbox1");
-  GLADE_HOOKUP_OBJECT (dialog1, vbox2, "vbox2");
-  GLADE_HOOKUP_OBJECT (dialog1, label1, "label1");
-  GLADE_HOOKUP_OBJECT (dialog1, hseparator1, "hseparator1");
-  GLADE_HOOKUP_OBJECT (dialog1, table2, "table2");
-  GLADE_HOOKUP_OBJECT (dialog1, label6, "label6");
-  GLADE_HOOKUP_OBJECT (dialog1, label8, "label8");
-  GLADE_HOOKUP_OBJECT (dialog1, label9, "label9");
-  GLADE_HOOKUP_OBJECT (dialog1, label10, "label10");
-  GLADE_HOOKUP_OBJECT (dialog1, label2, "label2");
-  GLADE_HOOKUP_OBJECT (dialog1, label3, "label3");
-  GLADE_HOOKUP_OBJECT (dialog1, label4, "label4");
-  GLADE_HOOKUP_OBJECT (dialog1, label11, "label11");
-  GLADE_HOOKUP_OBJECT (dialog1, label7, "label7");
-  GLADE_HOOKUP_OBJECT (dialog1, label5, "label5");
-  GLADE_HOOKUP_OBJECT (dialog1, checkbutton1, "checkbutton1");
-  GLADE_HOOKUP_OBJECT (dialog1, checkbutton2, "checkbutton2");
-  GLADE_HOOKUP_OBJECT (dialog1, checkbutton3, "checkbutton3");
-  GLADE_HOOKUP_OBJECT (dialog1, checkbutton4, "checkbutton4");
-  GLADE_HOOKUP_OBJECT (dialog1, checkbutton5, "checkbutton5");
-  GLADE_HOOKUP_OBJECT (dialog1, checkbutton6, "checkbutton6");
-  GLADE_HOOKUP_OBJECT (dialog1, checkbutton7, "checkbutton7");
-  GLADE_HOOKUP_OBJECT (dialog1, checkbutton8, "checkbutton8");
-  GLADE_HOOKUP_OBJECT (dialog1, checkbutton9, "checkbutton9");
-  GLADE_HOOKUP_OBJECT (dialog1, checkbutton10, "checkbutton10");
-  GLADE_HOOKUP_OBJECT (dialog1, label12, "label12");
-  GLADE_HOOKUP_OBJECT (dialog1, label13, "label13");
-  GLADE_HOOKUP_OBJECT (dialog1, checkbutton11, "checkbutton11");
-  GLADE_HOOKUP_OBJECT (dialog1, checkbutton12, "checkbutton12");
-  GLADE_HOOKUP_OBJECT (dialog1, label14, "label14");
-  GLADE_HOOKUP_OBJECT (dialog1, checkbutton13, "checkbutton13");
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_action_area1, "dialog_action_area1");
-  GLADE_HOOKUP_OBJECT (dialog1, closebutton1, "closebutton1");
-
-  return dialog1;
-}
-

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_d3d.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_d3d.cpp	2007-01-12 07:15:14 UTC (rev 2708)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_d3d.cpp	2007-01-12 18:54:07 UTC (rev 2709)
@@ -1,174 +0,0 @@
-
-
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <unistd.h>
-#include <string.h>
-#include <stdio.h>
-
-#include <gdk/gdkkeysyms.h>
-#include <gtk/gtk.h>
-
-
-#include <gdk/gdkkeysyms.h>
-#include <gtk/gtk.h>
-#include "config.h"
-#include "default.h"
-#include "ADM_toolkit_gtk/ADM_gladeSupport.h"
-#include "ADM_toolkit_gtk/toolkit_gtk.h"
-#include "ADM_toolkit_gtk/toolkit_gtk_include.h"
-
-# include <config.h>
-static GtkWidget	*create_d3doption (void);
-uint8_t DIA_d3d(double *luma,double *chroma,double *temporal);
-uint8_t DIA_d3d(double *luma,double *chroma,double *temporal)
-{
-	GtkWidget *dialog;
-
-	char str[100];
-	uint8_t ret=0;
-
-	gint r;
-
-#define FILL_ENTRY(widget_name,value) 		{sprintf(str,"%f",*value);r=-1;   \
-gtk_editable_delete_text(GTK_EDITABLE(lookup_widget(dialog,#widget_name)), 0,-1);\
-gtk_editable_insert_text(GTK_EDITABLE(lookup_widget(dialog,#widget_name)), str, strlen(str), &r);}
-
-	dialog=create_d3doption();
-//	gtk_transient(dialog);
-        gtk_register_dialog(dialog);
-
-	FILL_ENTRY(entry1,luma);
-	FILL_ENTRY(entry2,chroma);
-	FILL_ENTRY(entry3,temporal);
-
-
-
-	ret=0;
-	if(gtk_dialog_run(GTK_DIALOG(dialog))==GTK_RESPONSE_OK)
-	{
-
-		gchar *s;
-#define READ_ENTRY(widget_name)   gtk_editable_get_chars(GTK_EDITABLE (lookup_widget(dialog,#widget_name)), 0, -1);
-
-			s=READ_ENTRY(entry1);;
-			*luma=(double)atof(s);
-			s=READ_ENTRY(entry2);;
-			*chroma=(double)atoi(s);
-			s=READ_ENTRY(entry3);;
-			*temporal=(double)atoi(s);
-			ret=1;
-	}
-        gtk_unregister_dialog(dialog);
-	gtk_widget_destroy(dialog);
-
-	return ret;
-
-}
-
-
-
-
-
-
-
-
-
-GtkWidget	*create_d3doption (void)
-{
-  GtkWidget *d3doption;
-  GtkWidget *dialog_vbox1;
-  GtkWidget *table1;
-  GtkWidget *label1;
-  GtkWidget *label2;
-  GtkWidget *label3;
-  GtkWidget *entry1;
-  GtkWidget *entry2;
-  GtkWidget *entry3;
-  GtkWidget *dialog_action_area1;
-  GtkWidget *cancelbutton1;
-  GtkWidget *okbutton1;
-
-  d3doption = gtk_dialog_new ();
-  gtk_window_set_title (GTK_WINDOW (d3doption), _("dialog1"));
-
-  dialog_vbox1 = GTK_DIALOG (d3doption)->vbox;
-  gtk_widget_show (dialog_vbox1);
-
-  table1 = gtk_table_new (3, 2, FALSE);
-  gtk_widget_show (table1);
-  gtk_box_pack_start (GTK_BOX (dialog_vbox1), table1, TRUE, TRUE, 0);
-
-  label1 = gtk_label_new (_("Spatial Luma Thresh"));
-  gtk_widget_show (label1);
-  gtk_table_attach (GTK_TABLE (table1), label1, 0, 1, 0, 1,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_label_set_justify (GTK_LABEL (label1), GTK_JUSTIFY_LEFT);
-  gtk_misc_set_alignment (GTK_MISC (label1), 0, 0.5);
-
-  label2 = gtk_label_new (_("Spatial Chroma Thresh"));
-  gtk_widget_show (label2);
-  gtk_table_attach (GTK_TABLE (table1), label2, 0, 1, 1, 2,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_label_set_justify (GTK_LABEL (label2), GTK_JUSTIFY_LEFT);
-  gtk_misc_set_alignment (GTK_MISC (label2), 0, 0.5);
-
-  label3 = gtk_label_new (_("Temporal Thresh"));
-  gtk_widget_show (label3);
-  gtk_table_attach (GTK_TABLE (table1), label3, 0, 1, 2, 3,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_label_set_justify (GTK_LABEL (label3), GTK_JUSTIFY_LEFT);
-  gtk_misc_set_alignment (GTK_MISC (label3), 0, 0.5);
-
-  entry1 = gtk_entry_new ();
-  gtk_widget_show (entry1);
-  gtk_table_attach (GTK_TABLE (table1), entry1, 1, 2, 0, 1,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-
-  entry2 = gtk_entry_new ();
-  gtk_widget_show (entry2);
-  gtk_table_attach (GTK_TABLE (table1), entry2, 1, 2, 1, 2,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-
-  entry3 = gtk_entry_new ();
-  gtk_widget_show (entry3);
-  gtk_table_attach (GTK_TABLE (table1), entry3, 1, 2, 2, 3,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-
-  dialog_action_area1 = GTK_DIALOG (d3doption)->action_area;
-  gtk_widget_show (dialog_action_area1);
-  gtk_button_box_set_layout (GTK_BUTTON_BOX (dialog_action_area1), GTK_BUTTONBOX_END);
-
-  cancelbutton1 = gtk_button_new_from_stock ("gtk-cancel");
-  gtk_widget_show (cancelbutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (d3doption), cancelbutton1, GTK_RESPONSE_CANCEL);
-  GTK_WIDGET_SET_FLAGS (cancelbutton1, GTK_CAN_DEFAULT);
-
-  okbutton1 = gtk_button_new_from_stock ("gtk-ok");
-  gtk_widget_show (okbutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (d3doption), okbutton1, GTK_RESPONSE_OK);
-  GTK_WIDGET_SET_FLAGS (okbutton1, GTK_CAN_DEFAULT);
-
-  /* Store pointers to all widgets, for use by lookup_widget(). */
-  GLADE_HOOKUP_OBJECT_NO_REF (d3doption, d3doption, "d3doption");
-  GLADE_HOOKUP_OBJECT_NO_REF (d3doption, dialog_vbox1, "dialog_vbox1");
-  GLADE_HOOKUP_OBJECT (d3doption, table1, "table1");
-  GLADE_HOOKUP_OBJECT (d3doption, label1, "label1");
-  GLADE_HOOKUP_OBJECT (d3doption, label2, "label2");
-  GLADE_HOOKUP_OBJECT (d3doption, label3, "label3");
-  GLADE_HOOKUP_OBJECT (d3doption, entry1, "entry1");
-  GLADE_HOOKUP_OBJECT (d3doption, entry2, "entry2");
-  GLADE_HOOKUP_OBJECT (d3doption, entry3, "entry3");
-  GLADE_HOOKUP_OBJECT_NO_REF (d3doption, dialog_action_area1, "dialog_action_area1");
-  GLADE_HOOKUP_OBJECT (d3doption, cancelbutton1, "cancelbutton1");
-  GLADE_HOOKUP_OBJECT (d3doption, okbutton1, "okbutton1");
-
-  return d3doption;
-}
-

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_resizeWiz.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_resizeWiz.cpp	2007-01-12 07:15:14 UTC (rev 2708)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_resizeWiz.cpp	2007-01-12 18:54:07 UTC (rev 2709)
@@ -1,186 +0,0 @@
-
-/***************************************************************************
-                         DIA_resizeWiz
-                             -------------------
-
-                           Ui for hue & sat
-    copyright            : (C) 2004/5 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-
-
-#include <config.h>
-#include <math.h>
-#include <string.h>
-#include <stdio.h>
-
-#include <gdk/gdkkeysyms.h>
-#include <gtk/gtk.h>
-#include <gdk/gdkkeysyms.h>
-#include <gtk/gtk.h>
-#include "default.h"
-
-#include "ADM_toolkit_gtk/ADM_gladeSupport.h"
-#include "ADM_toolkit_gtk/toolkit_gtk.h"
-#include "ADM_toolkit_gtk/toolkit_gtk_include.h"
-#include "ADM_toolkit/toolkit.hxx"
-#include "ADM_assert.h"
-
-#include "DIA_resizeWiz.h"
-
-static GtkWidget       *create_dialog1 (void);
-
-uint8_t DIA_resizeWiz(RESWIZ_FORMAT *format, RESWIZ_AR *source, RESWIZ_AR *destination)
-{
-uint8_t r=0;
-GtkWidget *dialog=create_dialog1();
-        
-        
-
-        // Initialize
-#define COMBINE(x,y) gtk_combo_box_set_active(GTK_COMBO_BOX(WID(x)),(int)*y)
-
-                COMBINE(comboboxSource,source);
-                COMBINE(comboboxFinal,destination);
-                COMBINE(comboboxTarget,format);
-
-        gtk_register_dialog(dialog);
-        if(gtk_dialog_run(GTK_DIALOG(dialog))==GTK_RESPONSE_OK)
-        {
-                r=1;
-#undef COMBINE
-#define COMBINE(x) gtk_combo_box_get_active(GTK_COMBO_BOX(WID(x)));
-                *format=(RESWIZ_FORMAT) COMBINE(comboboxTarget);
-                *source=(RESWIZ_AR)     COMBINE(comboboxSource);
-                *destination=(RESWIZ_AR)COMBINE(comboboxFinal);
-
-        }
-
-
-        gtk_unregister_dialog(dialog);
-        gtk_widget_destroy(dialog);
-        return r;
-}
-
-
-GtkWidget*
-        create_dialog1 (void)
-{
-    GtkWidget *dialog1;
-    GtkWidget *dialog_vbox1;
-    GtkWidget *table1;
-    GtkWidget *label1;
-    GtkWidget *label2;
-    GtkWidget *comboboxSource;
-    GtkWidget *label3;
-    GtkWidget *comboboxFinal;
-    GtkWidget *comboboxTarget;
-    GtkWidget *dialog_action_area1;
-    GtkWidget *cancelbutton1;
-    GtkWidget *okbutton1;
-
-    dialog1 = gtk_dialog_new ();
-    gtk_window_set_title (GTK_WINDOW (dialog1), _("Resize for VCD/SVCD/...."));
-    gtk_window_set_type_hint (GTK_WINDOW (dialog1), GDK_WINDOW_TYPE_HINT_DIALOG);
-
-    dialog_vbox1 = GTK_DIALOG (dialog1)->vbox;
-    gtk_widget_show (dialog_vbox1);
-
-    table1 = gtk_table_new (3, 2, FALSE);
-    gtk_widget_show (table1);
-    gtk_box_pack_start (GTK_BOX (dialog_vbox1), table1, TRUE, TRUE, 0);
-
-    label1 = gtk_label_new (_("Target type : "));
-    gtk_widget_show (label1);
-    gtk_table_attach (GTK_TABLE (table1), label1, 0, 1, 0, 1,
-                      (GtkAttachOptions) (GTK_FILL),
-                      (GtkAttachOptions) (0), 0, 0);
-    gtk_misc_set_alignment (GTK_MISC (label1), 0, 0.5);
-
-    label2 = gtk_label_new (_("Source Aspect Ratio :"));
-    gtk_widget_show (label2);
-    gtk_table_attach (GTK_TABLE (table1), label2, 0, 1, 1, 2,
-                      (GtkAttachOptions) (GTK_FILL),
-                      (GtkAttachOptions) (0), 0, 0);
-    gtk_misc_set_alignment (GTK_MISC (label2), 0, 0.5);
-
-    comboboxSource = gtk_combo_box_new_text ();
-    gtk_widget_show (comboboxSource);
-    gtk_table_attach (GTK_TABLE (table1), comboboxSource, 1, 2, 1, 2,
-                      (GtkAttachOptions) (GTK_FILL),
-                      (GtkAttachOptions) (GTK_FILL), 0, 0);
-    gtk_container_set_border_width (GTK_CONTAINER (comboboxSource), 1);
-    gtk_combo_box_append_text (GTK_COMBO_BOX (comboboxSource), _("1:1"));
-    gtk_combo_box_append_text (GTK_COMBO_BOX (comboboxSource), _("4:3"));
-    gtk_combo_box_append_text (GTK_COMBO_BOX (comboboxSource), _("16:9"));
-
-    label3 = gtk_label_new (_("Destination Aspect Ratio :"));
-    gtk_widget_show (label3);
-    gtk_table_attach (GTK_TABLE (table1), label3, 0, 1, 2, 3,
-                      (GtkAttachOptions) (GTK_FILL),
-                      (GtkAttachOptions) (0), 0, 0);
-    gtk_misc_set_alignment (GTK_MISC (label3), 0, 0.5);
-
-    comboboxFinal = gtk_combo_box_new_text ();
-    gtk_widget_show (comboboxFinal);
-    gtk_table_attach (GTK_TABLE (table1), comboboxFinal, 1, 2, 2, 3,
-                      (GtkAttachOptions) (GTK_FILL),
-                      (GtkAttachOptions) (GTK_FILL), 0, 0);
-    gtk_container_set_border_width (GTK_CONTAINER (comboboxFinal), 1);
-    gtk_combo_box_append_text (GTK_COMBO_BOX (comboboxFinal), _("1:1"));
-    gtk_combo_box_append_text (GTK_COMBO_BOX (comboboxFinal), _("4:3"));
-    gtk_combo_box_append_text (GTK_COMBO_BOX (comboboxFinal), _("16:9"));
-
-    comboboxTarget = gtk_combo_box_new_text ();
-    gtk_widget_show (comboboxTarget);
-    gtk_table_attach (GTK_TABLE (table1), comboboxTarget, 1, 2, 0, 1,
-                      (GtkAttachOptions) (GTK_FILL),
-                      (GtkAttachOptions) (GTK_FILL), 0, 0);
-    gtk_container_set_border_width (GTK_CONTAINER (comboboxTarget), 1);
-    gtk_combo_box_append_text (GTK_COMBO_BOX (comboboxTarget), _("VCD"));
-    gtk_combo_box_append_text (GTK_COMBO_BOX (comboboxTarget), _("SVCD"));
-    gtk_combo_box_append_text (GTK_COMBO_BOX (comboboxTarget), _("DVD"));
-    gtk_combo_box_append_text (GTK_COMBO_BOX (comboboxTarget), _("DVD, half D1"));
-    gtk_combo_box_append_text (GTK_COMBO_BOX (comboboxTarget), _("PSP"));
-
-    dialog_action_area1 = GTK_DIALOG (dialog1)->action_area;
-    gtk_widget_show (dialog_action_area1);
-    gtk_button_box_set_layout (GTK_BUTTON_BOX (dialog_action_area1), GTK_BUTTONBOX_END);
-
-    cancelbutton1 = gtk_button_new_from_stock ("gtk-cancel");
-    gtk_widget_show (cancelbutton1);
-    gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), cancelbutton1, GTK_RESPONSE_CANCEL);
-    GTK_WIDGET_SET_FLAGS (cancelbutton1, GTK_CAN_DEFAULT);
-
-    okbutton1 = gtk_button_new_from_stock ("gtk-ok");
-    gtk_widget_show (okbutton1);
-    gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), okbutton1, GTK_RESPONSE_OK);
-    GTK_WIDGET_SET_FLAGS (okbutton1, GTK_CAN_DEFAULT);
-
-    /* Store pointers to all widgets, for use by lookup_widget(). */
-    GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog1, "dialog1");
-    GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_vbox1, "dialog_vbox1");
-    GLADE_HOOKUP_OBJECT (dialog1, table1, "table1");
-    GLADE_HOOKUP_OBJECT (dialog1, label1, "label1");
-    GLADE_HOOKUP_OBJECT (dialog1, label2, "label2");
-    GLADE_HOOKUP_OBJECT (dialog1, comboboxSource, "comboboxSource");
-    GLADE_HOOKUP_OBJECT (dialog1, label3, "label3");
-    GLADE_HOOKUP_OBJECT (dialog1, comboboxFinal, "comboboxFinal");
-    GLADE_HOOKUP_OBJECT (dialog1, comboboxTarget, "comboboxTarget");
-    GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_action_area1, "dialog_action_area1");
-    GLADE_HOOKUP_OBJECT (dialog1, cancelbutton1, "cancelbutton1");
-    GLADE_HOOKUP_OBJECT (dialog1, okbutton1, "okbutton1");
-
-    return dialog1;
-}
-

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am	2007-01-12 07:15:14 UTC (rev 2708)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am	2007-01-12 18:54:07 UTC (rev 2709)
@@ -9,18 +9,18 @@
 libADM_dialog_a_METASOURCES = AUTO
 
 libADM_dialog_a_SOURCES = DIA_audio.cpp DIA_vcodec.cpp DIA_acodec.cpp \
-	DIA_audiocodec.cpp DIA_properties.cpp DIA_mjpeg.cpp DIA_about.cpp DIA_recent.cpp \
+	DIA_properties.cpp DIA_mjpeg.cpp DIA_about.cpp DIA_recent.cpp \
 	DIA_indexer.cpp DIA_resize.cpp DIA_working.cpp \
 	DIA_working.h DIA_busy.cpp DIA_busy.h DIA_exLame.cpp DIA_pipe.cpp DIA_mpeg2opt.cpp \
-	DIA_d3d.cpp DIA_postproc.cpp DIA_enter.cpp DIA_enter.h DIA_xvcd.cpp DIA_muxer.cpp \
+	DIA_postproc.cpp DIA_enter.cpp DIA_enter.h DIA_xvcd.cpp DIA_muxer.cpp \
 	DIA_xvid.cpp DIA_crop.cpp DIA_color.cpp DIA_encoding.cpp DIA_SVCD.cpp DIA_prefs.cpp \
 	DIA_requant.cpp DIA_xvid4.cpp DIA_lavcodec.cpp \
 	DIA_dectel.cpp DIA_decimate.cpp DIA_pause.cpp \
 	DIA_DVDff.cpp DIA_lavdecoder.cpp DIA_lame.cpp DIA_calculator.cpp DIA_equalizer.cpp \
 	DIA_vobsub.cpp DIA_x264.cpp DIA_ocr.cpp  DIA_hue.cpp DIA_eq2.cpp \
 	DIA_asharp.cpp DIA_dmx.cpp DIA_idx_pg.cpp DIA_gototime.cpp \
-	DIA_audioTrack.cpp DIA_cnr2.cpp DIA_resizeWiz.cpp DIA_jobs.cpp DIA_jobs_save.cpp DIA_mosaic.cpp \
-	DIA_deblend.cpp DIA_v2v.cpp DIA_tdeint.cpp DIA_builtin.cpp DIA_mpdelogo.cpp DIA_vorbis.cpp \
+	DIA_audioTrack.cpp DIA_cnr2.cpp DIA_jobs.cpp DIA_jobs_save.cpp DIA_mosaic.cpp \
+	DIA_deblend.cpp DIA_v2v.cpp DIA_tdeint.cpp DIA_mpdelogo.cpp DIA_vorbis.cpp \
         DIA_chromaShift.cpp \
         \
         DIA_preview.cpp \
@@ -40,19 +40,19 @@
 
 EXTRA_DIST =  DIA_enter.cpp     \
 DIA_mcdeint.cpp     DIA_resize.cpp \
-DIA_cnr2.cpp          DIA_enter.h          DIA_mjpeg.cpp       DIA_resizeWiz.cpp \
-DIA_DVDff.cpp        DIA_color.cpp         DIA_eq2.cpp          DIA_mosaic.cpp      DIA_resizeWiz.h \
+DIA_cnr2.cpp          DIA_enter.h          DIA_mjpeg.cpp       \
+DIA_DVDff.cpp        DIA_color.cpp         DIA_eq2.cpp          DIA_mosaic.cpp      \
 DIA_coloryuv.cpp      DIA_equalizer.cpp    DIA_mpdelogo.cpp    DIA_rotate.cpp \
 DIA_SVCD.cpp         DIA_contrast.cpp      DIA_exLame.cpp       DIA_mpeg2opt.cpp    DIA_srt.cpp \
 DIA_about.cpp        DIA_conv.cpp          DIA_tdeint.cpp \
 DIA_acodec.cpp       DIA_crop.cpp          DIA_gototime.cpp     DIA_muxer.cpp       DIA_v2v.cpp \
-DIA_animated.cpp     DIA_d3d.cpp           DIA_hue.cpp          DIA_ocr.cpp         DIA_vcodec.cpp \
+DIA_animated.cpp     DIA_hue.cpp          DIA_ocr.cpp         DIA_vcodec.cpp \
 DIA_asharp.cpp       DIA_deblend.cpp       DIA_idx_pg.cpp       DIA_partial.cpp     DIA_vobsub.cpp \
 DIA_audio.cpp        DIA_decimate.cpp      DIA_idx_pg.h         DIA_pause.cpp       DIA_vorbis.cpp \
 DIA_audioTrack.cpp   DIA_dectel.cpp        DIA_indexer.cpp      DIA_pipe.cpp        DIA_working.cpp \
-DIA_audiocodec.cpp   DIA_defaultAudio.cpp  DIA_jobs.cpp         DIA_postproc.cpp    DIA_working.h \
+DIA_defaultAudio.cpp  DIA_jobs.cpp         DIA_postproc.cpp    DIA_working.h \
 DIA_jobs_save.cpp    DIA_prefs.cpp       DIA_x264.cpp \
-DIA_builtin.cpp      DIA_preview.cpp     DIA_xvcd.cpp \
+DIA_preview.cpp     DIA_xvcd.cpp \
 DIA_busy.cpp         DIA_dmx.cpp           DIA_lame.cpp         DIA_properties.cpp  DIA_xvid.cpp \
 DIA_busy.h           DIA_lavcodec.cpp     DIA_quota.cpp       DIA_xvid4.cpp \
 DIA_calculator.cpp   DIA_encoding.cpp      DIA_lavdecoder.cpp   DIA_recent.cpp \

Copied: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_builtin.cpp (from rev 2531, branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_builtin.cpp)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_builtin.cpp	2006-11-01 13:12:19 UTC (rev 2531)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_builtin.cpp	2007-01-12 18:54:07 UTC (rev 2709)
@@ -0,0 +1,138 @@
+//
+/**/
+/***************************************************************************
+                          DIA_hue
+                             -------------------
+
+                           Ui for hue & sat
+
+    begin                : 08 Apr 2005
+    copyright            : (C) 2004/5 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+
+
+#include <config.h>
+
+
+#include <string.h>
+#include <stdio.h>
+# include <math.h>
+
+
+#include "default.h"
+#include "default.h"
+#include "ADM_assert.h"
+
+#include "DIA_factory.h"
+#define CHECK_SET(x) {gtk_toggle_button_set_active( GTK_TOGGLE_BUTTON(WID(x)),1);}
+/**
+    \fn DIA_builtin(void)
+    \brief Display component that are built in. They are detected at configure time.
+
+*/
+
+uint8_t DIA_builtin(void)
+{
+  uint32_t altivec=0,mad=0,a52dec=0,xvid4=0,X264=0,freetype=0,esd=0,arts=0,vorbis=0,win32=0;
+  uint32_t faac=0,faad=0,dca=0,aften=0;
+  
+#ifdef USE_ALTIVEC
+        altivec=1;
+#endif
+#ifdef USE_MP3
+        mad=1;
+#endif
+#ifdef USE_AC3
+        a52dec=1;
+#endif
+#ifdef USE_XVID_4
+        xvid4=1;
+#endif
+#ifdef USE_X264
+        X264=1;
+#endif
+#ifdef USE_FREETYPE
+        freetype=1;
+#endif
+#ifdef USE_ESD
+        esd=1;
+#endif
+#ifdef USE_ARTS
+        arts=1;
+#endif
+#ifdef USE_VORBIS
+        vorbis=1;
+#endif
+#ifdef CYG_MANGLING
+        win32=1;
+#endif
+#ifdef USE_FAAC
+        faac=1;
+#endif
+#ifdef USE_FAAD
+        faad=1;
+#endif
+#ifdef USE_LIBDCA
+        dca=1;
+#endif
+
+#ifdef USE_AFTEN
+        aften=1;
+#endif
+
+        
+#define CREATE_TOGGLE(x)  diaElemToggle     t##x(&x,_("Option "#x));
+    
+    
+    CREATE_TOGGLE(mad)
+    CREATE_TOGGLE(a52dec)
+    CREATE_TOGGLE(xvid4)
+    CREATE_TOGGLE(X264)
+    CREATE_TOGGLE(freetype)
+    CREATE_TOGGLE(esd)
+    CREATE_TOGGLE(arts)
+    CREATE_TOGGLE(vorbis)
+    CREATE_TOGGLE(faac)
+    CREATE_TOGGLE(faad)
+    
+    CREATE_TOGGLE(dca)
+    CREATE_TOGGLE(altivec)
+    CREATE_TOGGLE(win32)
+    CREATE_TOGGLE(aften)
+    
+      diaElem *elems[]={
+#undef CREATE_TOGGLE
+#define CREATE_TOGGLE(x) &(t##x),
+    CREATE_TOGGLE(mad)
+    CREATE_TOGGLE(a52dec)
+    CREATE_TOGGLE(xvid4)
+    CREATE_TOGGLE(X264)
+    CREATE_TOGGLE(freetype)
+    CREATE_TOGGLE(esd)
+    CREATE_TOGGLE(arts)
+    CREATE_TOGGLE(vorbis)
+    CREATE_TOGGLE(faac)
+    CREATE_TOGGLE(faad)
+    
+    CREATE_TOGGLE(aften)
+    CREATE_TOGGLE(dca)
+    CREATE_TOGGLE(altivec)
+    CREATE_TOGGLE(win32)
+      
+      };
+    diaFactoryRun("Component built in",sizeof(elems)/sizeof(diaElem *),elems);
+
+    return 1;
+
+}

Copied: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_resizeWiz.cpp (from rev 2531, branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_resizeWiz.cpp)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_resizeWiz.cpp	2006-11-01 13:12:19 UTC (rev 2531)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_resizeWiz.cpp	2007-01-12 18:54:07 UTC (rev 2709)
@@ -0,0 +1,74 @@
+
+/***************************************************************************
+                         DIA_resizeWiz
+                             -------------------
+
+                           Ui for hue & sat
+    copyright            : (C) 2004/5 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+
+
+#include <config.h>
+#include <math.h>
+#include <string.h>
+#include <stdio.h>
+
+#include "default.h"
+
+#include "ADM_assert.h"
+
+#include "DIA_resizeWiz.h"
+#include "DIA_factory.h"
+
+
+uint8_t DIA_resizeWiz(RESWIZ_FORMAT *format, RESWIZ_AR *source, RESWIZ_AR *destination)
+{
+uint8_t r=0;
+#define ONELINE(x,y) {RESWIZ_##x,_(y),NULL}
+            diaMenuEntry menuFTarget[6]={
+                             ONELINE(VCD,"VCD"),
+                             ONELINE(SVCD,"SVCD"),
+                             ONELINE(DVD,"DVD"),
+                             ONELINE(DVD_HD1,"DVD Half D1"),
+                             ONELINE(PSP,"PSP"),
+                             ONELINE(PSP_FULLRES,"PSP Full Res"),
+                          };
+             diaMenuEntry menuFAspect[3]={
+               {RESWIZ_AR_1_1,"1:1",NULL},
+               {RESWIZ_AR_4_3,"4:3",NULL},
+               {RESWIZ_AR_16_9,"16:9",NULL}
+                          };
+  
+  
+                          
+    uint32_t tformat=(uint32_t )*format;
+    uint32_t tsource=(uint32_t )*source;
+    uint32_t tdestination=(uint32_t )*destination;
+                          
+    diaElemMenu     menu1(&tformat,_("Target type"), 6,menuFTarget);
+    diaElemMenu     menu2(&tsource,_("Source aspect ratio"), 3,menuFAspect);
+    diaElemMenu     menu3(&tdestination,_("Dest. aspect ratio"), 3,menuFAspect);
+    
+    
+    
+      diaElem *elems[3]={&menu1,&menu2,&menu3};
+    if(diaFactoryRun("Resize Type",3,elems))
+    {
+       *format=(RESWIZ_FORMAT) tformat;
+       *source=(RESWIZ_AR) tsource;
+       *destination=(RESWIZ_AR) tdestination;
+      return 1; 
+    }
+    return 0;
+}

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_resizeWiz.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_resizeWiz.h	2007-01-12 07:15:14 UTC (rev 2708)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_resizeWiz.h	2007-01-12 18:54:07 UTC (rev 2709)
@@ -26,8 +26,10 @@
         RESWIZ_SVCD,
         RESWIZ_DVD,
         RESWIZ_DVD_HD1,
-        RESWIZ_PSP
+        RESWIZ_PSP,
+        RESWIZ_PSP_FULLRES,
         
+        
 };
 
 typedef enum RESWIZ_AR

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/Makefile.am	2007-01-12 07:15:14 UTC (rev 2708)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/Makefile.am	2007-01-12 18:54:07 UTC (rev 2709)
@@ -1,6 +1,6 @@
 noinst_LIBRARIES = libADM_CommonUI.a 
 libADM_CommonUI_a_METASOURCES = AUTO
-libADM_CommonUI_a_SOURCES = GUI_sdlRender.cpp  GUI_xvRender.cpp 
+libADM_CommonUI_a_SOURCES = GUI_sdlRender.cpp  GUI_xvRender.cpp  DIA_resizeWiz.cpp DIA_builtin.cpp
 
 INCLUDES = $(all_includes) $(GTK_CFLAGS) $(XML_CFLAGS)  $(FREETYPE_CFLAGS) -DADM_SUBVERSION=@ADM_SUBVERSION@ \
 		-I./../../ADM_libraries/ADM_utilities \

Modified: branches/avidemux_2.4_branch/avidemux/gtk_gui.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/gtk_gui.cpp	2007-01-12 07:15:14 UTC (rev 2708)
+++ branches/avidemux_2.4_branch/avidemux/gtk_gui.cpp	2007-01-12 18:54:07 UTC (rev 2709)
@@ -2074,8 +2074,6 @@
    }
    ADM_dealloc(longname);
 }
-//---------------------
-extern int DIA_audioEncoder(int *pmode, int *pbitrate,const char *title);
 /**---------------------------------------------------
 		Pipe to toolame
 -------------------------------------------------------**/

Modified: branches/avidemux_2.4_branch/avidemux/gui_autodrive.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/gui_autodrive.cpp	2007-01-12 07:15:14 UTC (rev 2708)
+++ branches/avidemux_2.4_branch/avidemux/gui_autodrive.cpp	2007-01-12 18:54:07 UTC (rev 2709)
@@ -59,7 +59,14 @@
                 case ACT_AUTO_PSP:
                 case ACT_AUTO_PSP_H264:
                     // Resize
+                  if(action==ACT_AUTO_PSP_H264)
+                  {
+                    if(!setPSPFullRes()) return 0;
+                  }
+                  else
+                  {
                     if(!setPSP()) return 0;
+                  }
                     // Video codec
                     switch(action)
                     {



From mean at mail.berlios.de  Fri Jan 12 19:58:46 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 12 Jan 2007 19:58:46 +0100
Subject: [Avidemux-svn-commit] r2710 -
	branches/avidemux_2.4_branch/avidemux/ADM_videoFilter
Message-ID: <200701121858.l0CIwkrV011561@sheep.berlios.de>

Author: mean
Date: 2007-01-12 19:58:45 +0100 (Fri, 12 Jan 2007)
New Revision: 2710

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMPLD3D.cpp
Log:
oops

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMPLD3D.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMPLD3D.cpp	2007-01-12 18:54:07 UTC (rev 2709)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMPLD3D.cpp	2007-01-12 18:58:45 UTC (rev 2710)
@@ -31,7 +31,7 @@
 #include "ADM_toolkit/toolkit.hxx"
 #include "ADM_editor/ADM_edit.hxx"
 #include "ADM_video/ADM_genvideo.hxx"
-#include "ADM_video/ADM_vidMPLD3D.h"
+#include "ADM_vidMPLD3D.h"
 
 #include "ADM_osSupport/ADM_debugID.h"
 #define MODULE_NAME MODULE_FILTER



From mean at mail.berlios.de  Fri Jan 12 20:00:30 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 12 Jan 2007 20:00:30 +0100
Subject: [Avidemux-svn-commit] r2711 -
	branches/avidemux_2.4_branch/avidemux/ADM_videoFilter
Message-ID: <200701121900.l0CJ0U4a012017@sheep.berlios.de>

Author: mean
Date: 2007-01-12 20:00:30 +0100 (Fri, 12 Jan 2007)
New Revision: 2711

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMPLD3Dlow.h
Log:
oops

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMPLD3Dlow.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMPLD3Dlow.h	2007-01-12 18:58:45 UTC (rev 2710)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMPLD3Dlow.h	2007-01-12 19:00:30 UTC (rev 2711)
@@ -21,7 +21,7 @@
 #ifndef __D3DLOW__
 #define __D3DLOW__
 #include "ADM_video/ADM_vidCached.h"
-#include "ADM_video/ADM_vidMPLD3D.h"
+#include "ADM_vidMPLD3D.h"
 
 class  ADMVideoMPD3Dlow:public AVDMGenericVideoStream
  {



From mean at mail.berlios.de  Fri Jan 12 20:23:20 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 12 Jan 2007 20:23:20 +0100
Subject: [Avidemux-svn-commit] r2712 - in
	branches/avidemux_2.4_branch/avidemux:
	ADM_userInterfaces/ADM_GTK/ADM_dialog
	ADM_userInterfaces/ADM_NONE/ADM_dialog
	ADM_userInterfaces/ADM_QT4/ADM_dialog ADM_video ADM_videoFilter
Message-ID: <200701121923.l0CJNKF7014037@sheep.berlios.de>

Author: mean
Date: 2007-01-12 20:23:19 +0100 (Fri, 12 Jan 2007)
New Revision: 2712

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidBlendRemoval.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidBlendRemoval_param.h
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidHardIvtcRemoval.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMosaic.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMosaic_param.h
Removed:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_deblend.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_mosaic.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidBlendRemoval.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidBlendRemoval_param.h
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidHardIvtcRemoval.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMosaic.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMosaic_param.h
Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am
Log:
more dialogFactory

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_deblend.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_deblend.cpp	2007-01-12 19:00:30 UTC (rev 2711)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_deblend.cpp	2007-01-12 19:23:19 UTC (rev 2712)
@@ -1,224 +0,0 @@
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <unistd.h>
-#include <string.h>
-#include <stdio.h>
-
-#include <gdk/gdkkeysyms.h>
-#include <gtk/gtk.h>
-
-
-#include <gdk/gdkkeysyms.h>
-#include <gtk/gtk.h>
-# include <math.h>
-# include "config.h"
-#include "default.h"
-#include "ADM_toolkit_gtk/ADM_gladeSupport.h"
-#include "ADM_toolkit_gtk/toolkit_gtk.h"
-#include "ADM_toolkit_gtk/toolkit_gtk_include.h"
-#include "ADM_toolkit/toolkit.hxx"
-
-#include "ADM_video/ADM_vidBlendRemoval_param.h"
-
-static GtkWidget       *create_dialog1 (void);
-
-#define SPIN_GET(x,y) {mosaic->y= gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(WID(x))) ;}
-#define SPIN_SET(x,y)  {gtk_spin_button_set_value(GTK_SPIN_BUTTON(WID(x)),(gfloat)mosaic->y) ;}
-
-
-
-uint8_t  DIA_blendRemoval(BLEND_REMOVER_PARAM *mosaic)
-{
-  GtkWidget *dialog;
-  uint8_t ret=0;
-
-        dialog=create_dialog1();
-        gtk_register_dialog(dialog);
-        
-        SPIN_SET(spinbuttonTreshold,threshold);
-        SPIN_SET(spinbuttonNoise,noise);
-        SPIN_SET(spinbuttonIdentical,identical);
-        gtk_toggle_button_set_active( GTK_TOGGLE_BUTTON(WID(checkbuttonShow)),mosaic->show);
-
-        if(gtk_dialog_run(GTK_DIALOG(dialog))==GTK_RESPONSE_OK)
-                {
-                        ret=1;
-                        SPIN_GET(spinbuttonTreshold,threshold);
-                        SPIN_GET(spinbuttonNoise,noise);
-                        SPIN_GET(spinbuttonIdentical,identical);
-                        mosaic->show=gtk_toggle_button_get_active( GTK_TOGGLE_BUTTON(WID(checkbuttonShow)));
-                }
-        gtk_unregister_dialog(dialog);
-        gtk_widget_destroy(dialog);
-        return ret;
-
-}
-
-
-GtkWidget *create_dialog1 (void)
-{
-  GtkWidget *dialog1;
-  GtkWidget *dialog_vbox1;
-  GtkWidget *table1;
-  GtkWidget *label1;
-  GtkWidget *label2;
-  GtkWidget *label3;
-  GtkWidget *label4;
-  GtkWidget *label5;
-  GtkWidget *label6;
-  GtkWidget *label7;
-  GtkWidget *label8;
-  GtkObject *spinbuttonTreshold_adj;
-  GtkWidget *spinbuttonTreshold;
-  GtkObject *spinbuttonNoise_adj;
-  GtkWidget *spinbuttonNoise;
-  GtkObject *spinbuttonIdentical_adj;
-  GtkWidget *spinbuttonIdentical;
-  GtkWidget *checkbuttonShow;
-  GtkWidget *dialog_action_area1;
-  GtkWidget *cancelbutton1;
-  GtkWidget *okbutton1;
-  GtkTooltips *tooltips;
-
-  tooltips = gtk_tooltips_new ();
-
-  dialog1 = gtk_dialog_new ();
-  gtk_window_set_title (GTK_WINDOW (dialog1), _("Blend removal / Hard pulldown removal"));
-  gtk_window_set_type_hint (GTK_WINDOW (dialog1), GDK_WINDOW_TYPE_HINT_DIALOG);
-
-  dialog_vbox1 = GTK_DIALOG (dialog1)->vbox;
-  gtk_widget_show (dialog_vbox1);
-
-  table1 = gtk_table_new (4, 3, FALSE);
-  gtk_widget_show (table1);
-  gtk_box_pack_start (GTK_BOX (dialog_vbox1), table1, TRUE, TRUE, 0);
-
-  label1 = gtk_label_new (_("%"));
-  gtk_widget_show (label1);
-  gtk_table_attach (GTK_TABLE (table1), label1, 2, 3, 0, 1,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_misc_set_alignment (GTK_MISC (label1), 0, 0.5);
-
-  label2 = gtk_label_new (_("%"));
-  gtk_widget_show (label2);
-  gtk_table_attach (GTK_TABLE (table1), label2, 2, 3, 1, 2,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_misc_set_alignment (GTK_MISC (label2), 0, 0.5);
-
-  label3 = gtk_label_new (_("%"));
-  gtk_widget_show (label3);
-  gtk_table_attach (GTK_TABLE (table1), label3, 2, 3, 2, 3,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_misc_set_alignment (GTK_MISC (label3), 0, 0.5);
-
-  label4 = gtk_label_new (_(" "));
-  gtk_widget_show (label4);
-  gtk_table_attach (GTK_TABLE (table1), label4, 2, 3, 3, 4,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_misc_set_alignment (GTK_MISC (label4), 0, 0.5);
-
-  label5 = gtk_label_new (_("Threshold :"));
-  gtk_widget_show (label5);
-  gtk_table_attach (GTK_TABLE (table1), label5, 0, 1, 0, 1,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_misc_set_alignment (GTK_MISC (label5), 0, 0.5);
-
-  label6 = gtk_label_new (_("Noise threshold :"));
-  gtk_widget_show (label6);
-  gtk_table_attach (GTK_TABLE (table1), label6, 0, 1, 1, 2,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_misc_set_alignment (GTK_MISC (label6), 0, 0.5);
-
-  label7 = gtk_label_new (_("Identical threshold :"));
-  gtk_widget_show (label7);
-  gtk_table_attach (GTK_TABLE (table1), label7, 0, 1, 2, 3,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_misc_set_alignment (GTK_MISC (label7), 0, 0.5);
-
-  label8 = gtk_label_new (_("Show metrics"));
-  gtk_widget_show (label8);
-  gtk_table_attach (GTK_TABLE (table1), label8, 0, 1, 3, 4,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_misc_set_alignment (GTK_MISC (label8), 0, 0.5);
-
-  spinbuttonTreshold_adj = gtk_adjustment_new (1, 1, 99, 1, 10, 10);
-  spinbuttonTreshold = gtk_spin_button_new (GTK_ADJUSTMENT (spinbuttonTreshold_adj), 1, 0);
-  gtk_widget_show (spinbuttonTreshold);
-  gtk_table_attach (GTK_TABLE (table1), spinbuttonTreshold, 1, 2, 0, 1,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_tooltips_set_tip (tooltips, spinbuttonTreshold, _("If the image is closer than treshold, is it considered valid, smaller means more false detection"), NULL);
-  gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (spinbuttonTreshold), TRUE);
-
-  spinbuttonNoise_adj = gtk_adjustment_new (1, 1, 99, 1, 10, 10);
-  spinbuttonNoise = gtk_spin_button_new (GTK_ADJUSTMENT (spinbuttonNoise_adj), 1, 0);
-  gtk_widget_show (spinbuttonNoise);
-  gtk_table_attach (GTK_TABLE (table1), spinbuttonNoise, 1, 2, 1, 2,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_tooltips_set_tip (tooltips, spinbuttonNoise, _("If pixels are closer than noise threshold, they are considered identical"), NULL);
-  gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (spinbuttonNoise), TRUE);
-
-  spinbuttonIdentical_adj = gtk_adjustment_new (1, 1, 99, 1, 10, 10);
-  spinbuttonIdentical = gtk_spin_button_new (GTK_ADJUSTMENT (spinbuttonIdentical_adj), 1, 0);
-  gtk_widget_show (spinbuttonIdentical);
-  gtk_table_attach (GTK_TABLE (table1), spinbuttonIdentical, 1, 2, 2, 3,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_tooltips_set_tip (tooltips, spinbuttonIdentical, _("If the picture are less than identical threshold, they are considered identical"), NULL);
-  gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (spinbuttonIdentical), TRUE);
-
-  checkbuttonShow = gtk_check_button_new_with_mnemonic ("");
-  gtk_widget_show (checkbuttonShow);
-  gtk_table_attach (GTK_TABLE (table1), checkbuttonShow, 1, 2, 3, 4,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_tooltips_set_tip (tooltips, checkbuttonShow, _("Show metrics in picture (debug only)"), NULL);
-
-  dialog_action_area1 = GTK_DIALOG (dialog1)->action_area;
-  gtk_widget_show (dialog_action_area1);
-  gtk_button_box_set_layout (GTK_BUTTON_BOX (dialog_action_area1), GTK_BUTTONBOX_END);
-
-  cancelbutton1 = gtk_button_new_from_stock ("gtk-cancel");
-  gtk_widget_show (cancelbutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), cancelbutton1, GTK_RESPONSE_CANCEL);
-  GTK_WIDGET_SET_FLAGS (cancelbutton1, GTK_CAN_DEFAULT);
-
-  okbutton1 = gtk_button_new_from_stock ("gtk-ok");
-  gtk_widget_show (okbutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), okbutton1, GTK_RESPONSE_OK);
-  GTK_WIDGET_SET_FLAGS (okbutton1, GTK_CAN_DEFAULT);
-
-  /* Store pointers to all widgets, for use by lookup_widget(). */
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog1, "dialog1");
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_vbox1, "dialog_vbox1");
-  GLADE_HOOKUP_OBJECT (dialog1, table1, "table1");
-  GLADE_HOOKUP_OBJECT (dialog1, label1, "label1");
-  GLADE_HOOKUP_OBJECT (dialog1, label2, "label2");
-  GLADE_HOOKUP_OBJECT (dialog1, label3, "label3");
-  GLADE_HOOKUP_OBJECT (dialog1, label4, "label4");
-  GLADE_HOOKUP_OBJECT (dialog1, label5, "label5");
-  GLADE_HOOKUP_OBJECT (dialog1, label6, "label6");
-  GLADE_HOOKUP_OBJECT (dialog1, label7, "label7");
-  GLADE_HOOKUP_OBJECT (dialog1, label8, "label8");
-  GLADE_HOOKUP_OBJECT (dialog1, spinbuttonTreshold, "spinbuttonTreshold");
-  GLADE_HOOKUP_OBJECT (dialog1, spinbuttonNoise, "spinbuttonNoise");
-  GLADE_HOOKUP_OBJECT (dialog1, spinbuttonIdentical, "spinbuttonIdentical");
-  GLADE_HOOKUP_OBJECT (dialog1, checkbuttonShow, "checkbuttonShow");
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_action_area1, "dialog_action_area1");
-  GLADE_HOOKUP_OBJECT (dialog1, cancelbutton1, "cancelbutton1");
-  GLADE_HOOKUP_OBJECT (dialog1, okbutton1, "okbutton1");
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, tooltips, "tooltips");
-
-  return dialog1;
-}
-
-

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_mosaic.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_mosaic.cpp	2007-01-12 19:00:30 UTC (rev 2711)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_mosaic.cpp	2007-01-12 19:23:19 UTC (rev 2712)
@@ -1,180 +0,0 @@
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <unistd.h>
-#include <string.h>
-#include <stdio.h>
-
-#include <gdk/gdkkeysyms.h>
-#include <gtk/gtk.h>
-
-
-#include <gdk/gdkkeysyms.h>
-#include <gtk/gtk.h>
-# include <math.h>
-# include "config.h"
-#include "default.h"
-#include "ADM_toolkit_gtk/ADM_gladeSupport.h"
-#include "ADM_toolkit_gtk/toolkit_gtk.h"
-#include "ADM_toolkit_gtk/toolkit_gtk_include.h"
-#include "ADM_toolkit/toolkit.hxx"
-
-#include "ADM_video/ADM_vidMosaic_param.h"
-
-static GtkWidget       *create_dialog1 (void);
-
-#define SPIN_GET(x,y) {mosaic->y= gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(WID(x))) ;}
-#define SPIN_SET(x,y)  {gtk_spin_button_set_value(GTK_SPIN_BUTTON(WID(x)),(gfloat)mosaic->y) ;}
-
-
-
-uint8_t  DIA_mosaic(MOSAIC_PARAMS *mosaic)
-{
-  GtkWidget *dialog;
-  uint8_t ret=0;
-
-        dialog=create_dialog1();
-        gtk_register_dialog(dialog);
-        
-        SPIN_SET(spinbuttonHz,hz);
-        SPIN_SET(spinbuttonVz,vz);
-        SPIN_SET(spinbuttonShrink,shrink);
-        gtk_toggle_button_set_active( GTK_TOGGLE_BUTTON(WID(checkbuttonShow)),mosaic->show);
-
-        if(gtk_dialog_run(GTK_DIALOG(dialog))==GTK_RESPONSE_OK)
-                {
-                       ret=1;
-                        SPIN_GET(spinbuttonHz,hz);
-                        SPIN_GET(spinbuttonVz,vz);
-                        SPIN_GET(spinbuttonShrink,shrink);
-                        mosaic->show=gtk_toggle_button_get_active( GTK_TOGGLE_BUTTON(WID(checkbuttonShow)));
-                }
-        gtk_unregister_dialog(dialog);
-        gtk_widget_destroy(dialog);
-        return ret;
-
-}
-
-GtkWidget*
-create_dialog1 (void)
-{
-  GtkWidget *dialog1;
-  GtkWidget *dialog_vbox1;
-  GtkWidget *table1;
-  GtkWidget *label1;
-  GtkWidget *label2;
-  GtkWidget *label3;
-  GtkWidget *label4;
-  GtkObject *spinbuttonHz_adj;
-  GtkWidget *spinbuttonHz;
-  GtkObject *spinbuttonVz_adj;
-  GtkWidget *spinbuttonVz;
-  GtkObject *spinbuttonShrink_adj;
-  GtkWidget *spinbuttonShrink;
-  GtkWidget *checkbuttonShow;
-  GtkWidget *dialog_action_area1;
-  GtkWidget *cancelbutton1;
-  GtkWidget *okbutton1;
-
-  dialog1 = gtk_dialog_new ();
-  gtk_window_set_title (GTK_WINDOW (dialog1), _("Mosaic"));
-  gtk_window_set_type_hint (GTK_WINDOW (dialog1), GDK_WINDOW_TYPE_HINT_DIALOG);
-
-  dialog_vbox1 = GTK_DIALOG (dialog1)->vbox;
-  gtk_widget_show (dialog_vbox1);
-
-  table1 = gtk_table_new (4, 2, FALSE);
-  gtk_widget_show (table1);
-  gtk_box_pack_start (GTK_BOX (dialog_vbox1), table1, TRUE, TRUE, 0);
-
-  label1 = gtk_label_new (_("Horizontal stacking :"));
-  gtk_widget_show (label1);
-  gtk_table_attach (GTK_TABLE (table1), label1, 0, 1, 0, 1,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_misc_set_alignment (GTK_MISC (label1), 0, 0.5);
-
-  label2 = gtk_label_new (_("Vertical stacking : "));
-  gtk_widget_show (label2);
-  gtk_table_attach (GTK_TABLE (table1), label2, 0, 1, 1, 2,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_misc_set_alignment (GTK_MISC (label2), 0, 0.5);
-
-  label3 = gtk_label_new (_("Shrink factor :"));
-  gtk_widget_show (label3);
-  gtk_table_attach (GTK_TABLE (table1), label3, 0, 1, 2, 3,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_misc_set_alignment (GTK_MISC (label3), 0, 0.5);
-
-  label4 = gtk_label_new (_("Show frame # :"));
-  gtk_widget_show (label4);
-  gtk_table_attach (GTK_TABLE (table1), label4, 0, 1, 3, 4,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_misc_set_alignment (GTK_MISC (label4), 0, 0.5);
-
-  spinbuttonHz_adj = gtk_adjustment_new (3, 1, 10, 1, 2, 2);
-  spinbuttonHz = gtk_spin_button_new (GTK_ADJUSTMENT (spinbuttonHz_adj), 1, 0);
-  gtk_widget_show (spinbuttonHz);
-  gtk_table_attach (GTK_TABLE (table1), spinbuttonHz, 1, 2, 0, 1,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (spinbuttonHz), TRUE);
-
-  spinbuttonVz_adj = gtk_adjustment_new (3, 1, 10, 1, 2, 2);
-  spinbuttonVz = gtk_spin_button_new (GTK_ADJUSTMENT (spinbuttonVz_adj), 1, 0);
-  gtk_widget_show (spinbuttonVz);
-  gtk_table_attach (GTK_TABLE (table1), spinbuttonVz, 1, 2, 1, 2,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (spinbuttonVz), TRUE);
-
-  spinbuttonShrink_adj = gtk_adjustment_new (3, 1, 10, 1, 2, 2);
-  spinbuttonShrink = gtk_spin_button_new (GTK_ADJUSTMENT (spinbuttonShrink_adj), 1, 0);
-  gtk_widget_show (spinbuttonShrink);
-  gtk_table_attach (GTK_TABLE (table1), spinbuttonShrink, 1, 2, 2, 3,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (spinbuttonShrink), TRUE);
-
-  checkbuttonShow = gtk_check_button_new_with_mnemonic ("");
-  gtk_widget_show (checkbuttonShow);
-  gtk_table_attach (GTK_TABLE (table1), checkbuttonShow, 1, 2, 3, 4,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-
-  dialog_action_area1 = GTK_DIALOG (dialog1)->action_area;
-  gtk_widget_show (dialog_action_area1);
-  gtk_button_box_set_layout (GTK_BUTTON_BOX (dialog_action_area1), GTK_BUTTONBOX_END);
-
-  cancelbutton1 = gtk_button_new_from_stock ("gtk-cancel");
-  gtk_widget_show (cancelbutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), cancelbutton1, GTK_RESPONSE_CANCEL);
-  GTK_WIDGET_SET_FLAGS (cancelbutton1, GTK_CAN_DEFAULT);
-
-  okbutton1 = gtk_button_new_from_stock ("gtk-ok");
-  gtk_widget_show (okbutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), okbutton1, GTK_RESPONSE_OK);
-  GTK_WIDGET_SET_FLAGS (okbutton1, GTK_CAN_DEFAULT);
-
-  /* Store pointers to all widgets, for use by lookup_widget(). */
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog1, "dialog1");
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_vbox1, "dialog_vbox1");
-  GLADE_HOOKUP_OBJECT (dialog1, table1, "table1");
-  GLADE_HOOKUP_OBJECT (dialog1, label1, "label1");
-  GLADE_HOOKUP_OBJECT (dialog1, label2, "label2");
-  GLADE_HOOKUP_OBJECT (dialog1, label3, "label3");
-  GLADE_HOOKUP_OBJECT (dialog1, label4, "label4");
-  GLADE_HOOKUP_OBJECT (dialog1, spinbuttonHz, "spinbuttonHz");
-  GLADE_HOOKUP_OBJECT (dialog1, spinbuttonVz, "spinbuttonVz");
-  GLADE_HOOKUP_OBJECT (dialog1, spinbuttonShrink, "spinbuttonShrink");
-  GLADE_HOOKUP_OBJECT (dialog1, checkbuttonShow, "checkbuttonShow");
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_action_area1, "dialog_action_area1");
-  GLADE_HOOKUP_OBJECT (dialog1, cancelbutton1, "cancelbutton1");
-  GLADE_HOOKUP_OBJECT (dialog1, okbutton1, "okbutton1");
-
-  return dialog1;
-}
-
-

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am	2007-01-12 19:00:30 UTC (rev 2711)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am	2007-01-12 19:23:19 UTC (rev 2712)
@@ -19,8 +19,8 @@
 	DIA_DVDff.cpp DIA_lavdecoder.cpp DIA_lame.cpp DIA_calculator.cpp DIA_equalizer.cpp \
 	DIA_vobsub.cpp DIA_x264.cpp DIA_ocr.cpp  DIA_hue.cpp DIA_eq2.cpp \
 	DIA_asharp.cpp DIA_dmx.cpp DIA_idx_pg.cpp DIA_gototime.cpp \
-	DIA_audioTrack.cpp DIA_cnr2.cpp DIA_jobs.cpp DIA_jobs_save.cpp DIA_mosaic.cpp \
-	DIA_deblend.cpp DIA_v2v.cpp DIA_tdeint.cpp DIA_mpdelogo.cpp DIA_vorbis.cpp \
+	DIA_audioTrack.cpp DIA_cnr2.cpp DIA_jobs.cpp DIA_jobs_save.cpp  \
+	DIA_v2v.cpp DIA_tdeint.cpp DIA_mpdelogo.cpp DIA_vorbis.cpp \
         DIA_chromaShift.cpp \
         \
         DIA_preview.cpp \
@@ -41,13 +41,13 @@
 EXTRA_DIST =  DIA_enter.cpp     \
 DIA_mcdeint.cpp     DIA_resize.cpp \
 DIA_cnr2.cpp          DIA_enter.h          DIA_mjpeg.cpp       \
-DIA_DVDff.cpp        DIA_color.cpp         DIA_eq2.cpp          DIA_mosaic.cpp      \
+DIA_DVDff.cpp        DIA_color.cpp         DIA_eq2.cpp          \
 DIA_coloryuv.cpp      DIA_equalizer.cpp    DIA_mpdelogo.cpp    DIA_rotate.cpp \
 DIA_SVCD.cpp         DIA_contrast.cpp      DIA_exLame.cpp       DIA_mpeg2opt.cpp    DIA_srt.cpp \
 DIA_about.cpp        DIA_conv.cpp          DIA_tdeint.cpp \
 DIA_acodec.cpp       DIA_crop.cpp          DIA_gototime.cpp     DIA_muxer.cpp       DIA_v2v.cpp \
 DIA_animated.cpp     DIA_hue.cpp          DIA_ocr.cpp         DIA_vcodec.cpp \
-DIA_asharp.cpp       DIA_deblend.cpp       DIA_idx_pg.cpp       DIA_partial.cpp     DIA_vobsub.cpp \
+DIA_asharp.cpp       DIA_idx_pg.cpp       DIA_partial.cpp     DIA_vobsub.cpp \
 DIA_audio.cpp        DIA_decimate.cpp      DIA_idx_pg.h         DIA_pause.cpp       DIA_vorbis.cpp \
 DIA_audioTrack.cpp   DIA_dectel.cpp        DIA_indexer.cpp      DIA_pipe.cpp        DIA_working.cpp \
 DIA_defaultAudio.cpp  DIA_jobs.cpp         DIA_postproc.cpp    DIA_working.h \

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp	2007-01-12 19:00:30 UTC (rev 2711)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp	2007-01-12 19:23:19 UTC (rev 2712)
@@ -38,13 +38,11 @@
 #include "ADM_audiofilter/audiofilter_normalize_param.h"
 #include "ADM_video/ADM_vidCNR2_param.h"
 #include "ADM_video/ADM_vidColorYuv_param.h"
-#include "ADM_video/ADM_vidBlendRemoval_param.h"
 #include "ADM_video/ADM_vidDecDec_param.h"
 #include "ADM_video/ADM_vidDecTel_param.h"
 #include "ADM_audiofilter/audioencoder_lame_param.h"
 #include "ADM_audiofilter/audioencoder_lame_param.h"
 #include "ADM_encoder/adm_encmjpeg_param.h"
-#include "ADM_video/ADM_vidMosaic_param.h"
 #include "ADM_video/ADM_vidMSmooth_param.h"
 #include "ADM_video/ADM_vidPartial_param.h"
 #include "ADM_video/ADM_vidTDeint_param.h"
@@ -91,7 +89,6 @@
 uint8_t DIA_ass(ASSParams *param){return 0;}
 #endif
 uint8_t DIA_rotate(AVDMGenericVideoStream *astream,ROTATE_PARAM *param){return 0;}
-uint8_t  DIA_blendRemoval(BLEND_REMOVER_PARAM *mosaic){return 0;}
 uint8_t DIA_cnr2(CNR2Param *param){return 0;}
 uint8_t DIA_DVDffParam(COMPRES_PARAMS *incoming){return 0;}
 uint8_t DIA_getASharp(ASHARP_PARAM *param, AVDMGenericVideoStream *in){return 0;}
@@ -106,7 +103,6 @@
 uint8_t DIA_getMSmooth(MSMOOTH_PARAM *param){return 0;}
 uint8_t DIA_getPartial(PARTIAL_CONFIG *param,AVDMGenericVideoStream *son,AVDMGenericVideoStream *previous){return 0;}
 uint8_t DIA_mjpegCodecSetting(COMPRES_PARAMS *param){return 0;}
-uint8_t  DIA_mosaic(MOSAIC_PARAMS *mosaic){return 0;}
 uint8_t DIA_pipe(char **cmd,char **param){return 0;}
 uint8_t DIA_requant(COMPRES_PARAMS *incoming){return 0;}
 uint8_t  DIA_setUserMuxParam( int *mode, int *param, int *muxsize){return 0;}

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp	2007-01-12 19:00:30 UTC (rev 2711)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp	2007-01-12 19:23:19 UTC (rev 2712)
@@ -38,13 +38,11 @@
 #include "ADM_audiofilter/audiofilter_normalize_param.h"
 #include "ADM_video/ADM_vidCNR2_param.h"
 #include "ADM_video/ADM_vidColorYuv_param.h"
-#include "ADM_video/ADM_vidBlendRemoval_param.h"
 #include "ADM_video/ADM_vidDecDec_param.h"
 #include "ADM_video/ADM_vidDecTel_param.h"
 #include "ADM_audiofilter/audioencoder_lame_param.h"
 #include "ADM_audiofilter/audioencoder_lame_param.h"
 #include "ADM_encoder/adm_encmjpeg_param.h"
-#include "ADM_video/ADM_vidMosaic_param.h"
 #include "ADM_video/ADM_vidMSmooth_param.h"
 #include "ADM_video/ADM_vidPartial_param.h"
 #include "ADM_video/ADM_vidTDeint_param.h"
@@ -91,7 +89,6 @@
 uint8_t DIA_ass(ASSParams *param){return 0;}
 #endif
 uint8_t DIA_rotate(AVDMGenericVideoStream *astream,ROTATE_PARAM *param){return 0;}
-uint8_t  DIA_blendRemoval(BLEND_REMOVER_PARAM *mosaic){return 0;}
 uint8_t DIA_cnr2(CNR2Param *param){return 0;}
 uint8_t DIA_DVDffParam(COMPRES_PARAMS *incoming){return 0;}
 uint8_t DIA_getASharp(ASHARP_PARAM *param, AVDMGenericVideoStream *in){return 0;}
@@ -106,7 +103,6 @@
 uint8_t DIA_getMSmooth(MSMOOTH_PARAM *param){return 0;}
 uint8_t DIA_getPartial(PARTIAL_CONFIG *param,AVDMGenericVideoStream *son,AVDMGenericVideoStream *previous){return 0;}
 uint8_t DIA_mjpegCodecSetting(COMPRES_PARAMS *param){return 0;}
-uint8_t  DIA_mosaic(MOSAIC_PARAMS *mosaic){return 0;}
 uint8_t DIA_pipe(char **cmd,char **param){return 0;}
 uint8_t DIA_requant(COMPRES_PARAMS *incoming){return 0;}
 uint8_t  DIA_setUserMuxParam( int *mode, int *param, int *muxsize){return 0;}

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidBlendRemoval.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidBlendRemoval.cpp	2007-01-12 19:00:30 UTC (rev 2711)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidBlendRemoval.cpp	2007-01-12 19:23:19 UTC (rev 2712)
@@ -1,256 +0,0 @@
-/***************************************************************************
-                         
-        Blending remover
-
-        A B C D E -> A AB B 
-
-    copyright            : (C) 2005 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include "config.h"
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <ADM_assert.h>
-
-#include "config.h"
-#include "fourcc.h"
-#include "avio.hxx"
-#include "default.h"
-#include "math.h"
-
-#include "ADM_toolkit/toolkit.hxx"
-#include "ADM_editor/ADM_edit.hxx"
-#include "ADM_video/ADM_genvideo.hxx"
-
-#include "ADM_osSupport/ADM_debugID.h"
-#define MODULE_NAME MODULE_FILTER
-#include "ADM_osSupport/ADM_debug.h"
-#include "ADM_video/ADM_cache.h"
-#include "ADM_filter/video_filters.h"
-#include "DIA_enter.h"
-#include "ADM_osSupport/ADM_cpuCap.h"
-
-#include "ADM_vidBlendRemoval_param.h"
-#define MUL 1
-// Set it to 2 for post separate field
-
-
-
-class vidBlendRemoval:public AVDMGenericVideoStream
-{
-
-protected:
-  virtual char *printConf (void);
-  VideoCache *vidCache;
-  BLEND_REMOVER_PARAM *_param;
-  uint32_t              _lastRemoved;
-  ADMImage              *rebuild;
-public:
-
-                        vidBlendRemoval (AVDMGenericVideoStream * in, CONFcouple * setup);
-        virtual         ~vidBlendRemoval ();
-  virtual uint8_t getFrameNumberNoAlloc (uint32_t frame, uint32_t * len,
-                                         ADMImage * data, uint32_t * flags);
-  uint8_t configure (AVDMGenericVideoStream * instream);
-  virtual uint8_t getCoupledConf (CONFcouple ** couples);
-
-};
-
-static FILTER_PARAM field_unblend_template =
-  { 4,"threshold","show","noise","identical"};
-
-BUILD_CREATE (blendremove_create, vidBlendRemoval);
-SCRIPT_CREATE (blendremove_script, vidBlendRemoval, field_unblend_template);
-//*************************************
-uint8_t vidBlendRemoval::configure (AVDMGenericVideoStream * in)
-{
-        if(DIA_blendRemoval(_param))
-        {
-                _lastRemoved=0xFFFFFFF;
-                return 1;
-        }
-        return 0;
-}
-/*************************************/
-char *vidBlendRemoval::printConf (void)
-{
-  static char buf[50];
-  sprintf ((char *) buf, " Blend Removal Thresh:%d Noise:%d Ident:%d",_param->threshold,_param->noise,_param->identical);
-  return buf;
-}
-
-#define MAX_BLOCKS 50
-/*************************************/
-vidBlendRemoval::vidBlendRemoval (AVDMGenericVideoStream * in, CONFcouple * couples)
-{
-
-  _in = in;
-  memcpy (&_info, _in->getInfo (), sizeof (_info));
-  _info.encoding = 1;
-  vidCache = new VideoCache (10, in);
-  _uncompressed=new ADMImage(_info.width,_info.height);
-  rebuild=new ADMImage(_info.width,_info.height);
-
- _param=new BLEND_REMOVER_PARAM;
- _lastRemoved=0xFFFF;
- if(couples)
- {
-#undef GET
-#define GET(x) couples->getCouple(#x,&(_param->x))
-      GET (threshold);
-      GET (show);
-      GET (noise);
-      GET (identical);
-  }
-  else
-  {
-        _param->threshold=10;
-        _param->show=0;
-        _param->noise=5;
-        _param->identical=2;
-  }
-}
-//____________________________________________________________________
-vidBlendRemoval::~vidBlendRemoval ()
-{
-
-  delete vidCache;
-  vidCache = NULL;
-  delete _uncompressed;
-  _uncompressed=NULL;
-  delete _param;
-  _param=NULL;
-  delete rebuild;
-  rebuild=NULL;
-}
-
-
-
-
-
-uint8_t vidBlendRemoval::getFrameNumberNoAlloc (uint32_t inframe,
-                                uint32_t * len,
-                                ADMImage * data, uint32_t * flags)
-{
-
-	
-	ADMImage *srcP,*srcN,*src,*final,*display;
-        float distMerged, distN,distP,distM,distR,skip=0;
-        char txt[255];
-
-        
-        if(inframe<1 || inframe>inframe>_info.nb_frames-2 )
-        {
-                skip=1;
-        }
-        if(inframe && _lastRemoved==inframe-1)
-        {
-                skip=1;
-        }
-        
-        if(skip)
-        {
-                data->duplicate(vidCache->getImage(inframe));
-                vidCache->unlockAll();
-                return 1;
-        }
-        
-        
-
-        srcP=vidCache->getImage(inframe-1);
-        src=vidCache->getImage(inframe);
-        srcN=vidCache->getImage(inframe+1);
-        if(!srcP || !src || !srcN)
-        {
-                data->duplicate(vidCache->getImage(inframe));
-                vidCache->unlockAll();
-                return 1;
-        }
-       
-        rebuild->merge(srcP,srcN);
-        
-        distP=ADMImage::lumaDiff(src,srcN,_param->noise);
-        distN=ADMImage::lumaDiff(src,srcP,_param->noise);
-        distM=ADMImage::lumaDiff(src,rebuild,_param->noise);
-        
-        
-        
-        
-        double medium;
-
-         if(distN>1&&distP>1)
-        {
-                if(distP>distN) medium=distN;
-                          else  medium=distP;
-                  //medium=min(distM,distR);
-                 
-                 medium/=100;
-                 distN/=medium;
-                 distP/=medium;
-                 distM/=medium;
-         
-         }
-        
-        medium=medium/(_info.width*_info.height);
-        medium*=1000;
-        if(distM<_param->threshold && medium>_param->identical) // medium is how close pictures are, too close, we discard
-        {
-                data->duplicate(srcP);
-                _lastRemoved=inframe;
-                if(_param->show )
-                {
-                        sprintf(txt,"Dupe");
-                        drawString(data,2,5,txt);      
-                }
-        }
-        else
-                data->duplicate(src);
-        if(_param->show)
-        {
-                display=data;
-
-                sprintf(txt," N %02.1f",distN);
-                drawString(display,2,0,txt);
-
-                sprintf(txt," P %02.1f",distP);
-                drawString(display,2,1,txt);
-
-                sprintf(txt," M %02.1f",distM);
-                drawString(display,2,2,txt);
-
-                sprintf(txt," %% %02.1f",medium);
-                drawString(display,2,3,txt);
-        }
-
-
-          
-        vidCache->unlockAll();
-	return 1;
-}
-uint8_t vidBlendRemoval::getCoupledConf (CONFcouple ** couples)
-{
-
-  ADM_assert (_param);
-  *couples = new CONFcouple (4);
-#undef CSET
-#define CSET(x)  (*couples)->setCouple(#x,(_param->x))
-  CSET (threshold);
-  CSET (show);
-  CSET (noise);
-  CSET (identical);
-  
-  return 1;
-}
-
-
-//EOF

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidBlendRemoval_param.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidBlendRemoval_param.h	2007-01-12 19:00:30 UTC (rev 2711)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidBlendRemoval_param.h	2007-01-12 19:23:19 UTC (rev 2712)
@@ -1,22 +0,0 @@
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-
-#ifndef BLEND_REMOVAL_PARAM_H
-#define BLEND_REMOVAL_PARAM_H
-
-typedef struct BLEND_REMOVER_PARAM
-{
-        uint32_t threshold;
-        uint32_t noise;
-        uint32_t show;
-        uint32_t identical;
-}BLEND_REMOVER_PARAM;
-uint8_t  DIA_blendRemoval(BLEND_REMOVER_PARAM *mosaic);
-#endif

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidHardIvtcRemoval.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidHardIvtcRemoval.cpp	2007-01-12 19:00:30 UTC (rev 2711)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidHardIvtcRemoval.cpp	2007-01-12 19:23:19 UTC (rev 2712)
@@ -1,477 +0,0 @@
-/***************************************************************************
-                         
-        Hard ivtc removal for image
-
-        A B C D E -> A BC CD D E
-
-    copyright            : (C) 2005 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include "config.h"
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <ADM_assert.h>
-
-#include "config.h"
-#include "fourcc.h"
-#include "avio.hxx"
-#include "default.h"
-#include "math.h"
-
-#include "ADM_toolkit/toolkit.hxx"
-#include "ADM_editor/ADM_edit.hxx"
-#include "ADM_video/ADM_genvideo.hxx"
-
-#include "ADM_osSupport/ADM_debugID.h"
-#define MODULE_NAME MODULE_FILTER
-#include "ADM_osSupport/ADM_debug.h"
-#include "ADM_video/ADM_cache.h"
-#include "ADM_filter/video_filters.h"
-#include "DIA_enter.h"
-#include "ADM_osSupport/ADM_cpuCap.h"
-
-
-#define MUL 1
-// Set it to 2 for post separate field
-
-#include "ADM_vidBlendRemoval_param.h"
-
-#define PROGRESSIVE  0x00000001
-#define MAGIC_NUMBER (0xdeadbeef)
-#define IN_PATTERN   0x00000002
-
-extern uint8_t PutHintingData(unsigned char *video, unsigned int hint);
-
-class vidHardPDRemoval:public AVDMGenericVideoStream
-{
-
-protected:
-  virtual char *printConf (void);
-  VideoCache *vidCache;
-  BLEND_REMOVER_PARAM *_param;
-  uint32_t              _lastRemoved;
-  ADMImage              *cand1,*cand2,*rebuild;
-public:
-
-                        vidHardPDRemoval (AVDMGenericVideoStream * in, CONFcouple * setup);
-        virtual         ~vidHardPDRemoval ();
-  virtual uint8_t getFrameNumberNoAlloc (uint32_t frame, uint32_t * len,
-                                         ADMImage * data, uint32_t * flags);
-  uint8_t configure (AVDMGenericVideoStream * instream);
-  virtual uint8_t getCoupledConf (CONFcouple ** couples);
-
-};
-
-static FILTER_PARAM field_unblend_template =
-  { 4,"threshold","show","noise","identical"};
-
-BUILD_CREATE (hardivtc_create, vidHardPDRemoval);
-SCRIPT_CREATE (hardivtc_script, vidHardPDRemoval, field_unblend_template);
-//*************************************
-uint8_t vidHardPDRemoval::configure (AVDMGenericVideoStream * in)
-{
-        if(DIA_blendRemoval(_param))
-        {
-                _lastRemoved=0xFFFFFFF;
-                return 1;
-        }
-        return 0;
-}
-/*************************************/
-char *vidHardPDRemoval::printConf (void)
-{
-  static char buf[50];
-  sprintf ((char *) buf, " Field Unblend Thresh:%d Noise:%d",_param->threshold,_param->noise);
-  return buf;
-}
-static void hint(ADMImage *img)
-{
-       unsigned int hint;
-
-                 hint= PROGRESSIVE;
-                
-                 hint |= IN_PATTERN;
-                
-                PutHintingData(YPLANE(img), hint);  
-
-}
-#define MAX_BLOCKS 50
-/*************************************/
-vidHardPDRemoval::vidHardPDRemoval (AVDMGenericVideoStream * in, CONFcouple * couples)
-{
-
-  _in = in;
-  memcpy (&_info, _in->getInfo (), sizeof (_info));
-  _info.encoding = 1;
-  vidCache = new VideoCache (10, in);
-  _uncompressed=new ADMImage(_info.width,_info.height);
-  cand1=new ADMImage(_info.width,_info.height);
-  cand2=new ADMImage(_info.width,_info.height);
-  rebuild=new ADMImage(_info.width,_info.height);
-
- _param=new BLEND_REMOVER_PARAM;
- _lastRemoved=0xFFFFFFF;
- if(couples)
- {
-#undef GET
-#define GET(x) couples->getCouple(#x,&(_param->x))
-      GET (threshold);
-      GET (show);
-      GET (noise);
-      GET (identical);
-  }
-  else
-  {
-        _param->threshold=10;
-        _param->show=0;
-        _param->noise=5;
-        _param->identical=2;
-  }
-}
-//____________________________________________________________________
-vidHardPDRemoval::~vidHardPDRemoval ()
-{
-
-  delete vidCache;
-  vidCache = NULL;
-  delete _uncompressed;
-  _uncompressed=NULL;
-  delete _param;
-  _param=NULL;
-  delete cand1;
-  delete cand2;
-  delete rebuild;
-  cand1=NULL;
-  cand2=NULL;
-  rebuild=NULL;
-}
-
-
-
-
-/*
-
-                src=blend of srcP and R         => src= 1/2(srcP+R)
-                                                   2*src-srcP=R
-
-                srcN=blend of srcNN and R       => srcN=1/2 (srcNN+R)
-                                                        2*srcN-srcNN=R
-
-*/
-
-static uint8_t tinyRestore(uint8_t *dst, uint8_t *srcP, uint8_t *src,uint8_t *srcN,uint8_t *srcNN,uint32_t w, uint32_t h)
-{
-
-
-uint8_t *s,*sp,*sn,*snn,*d1;
-int a1,a2,a3,a4,sum,delta;
-
-        sp=srcP;
-        s=src;
-        sn=srcN;
-        snn=srcNN;
-        
-        d1=dst;
-
-          for(int y=0;y<h;y++)
-                for(int x=0;x<w;x++)
-                {
-                        a1=*sp;
-                        a2=*s;
-                        a3=*sn;
-                        a4=*snn;
-
-                        sum=2*a2+2*a3-a1-a4;
-                        sum=sum/2;
-                        
-                        a1=sum;                        
-
-                        if(a1<0) a1=0;
-                        if(a1>255) a1=255;
-                        *d1=a1;
-
-                        s++;
-                        sp++;
-                        sn++;
-                        snn++;
-                        d1++;
-                }
-        return 1;
-}
-#if defined (ARCH_X86 ) || defined (ARCH_X86_64 )
-static uint8_t tinyRestoreMMX(uint8_t *dst, uint8_t *srcP, uint8_t *src,uint8_t *srcN,uint8_t *srcNN,uint32_t w, uint32_t h)
-{
-
-
-uint8_t *s,*sp,*sn,*snn,*d1;
-int a1,a2,a3,a4,sum,delta,l,ll;
-
-        sp=srcP;
-        s=src;
-        sn=srcN;
-        snn=srcNN;
-        
-        d1=dst;
-
-        l=w*h;
-        ll=l>>2;
-#ifdef GCC_2_95_X
-        __asm__(
-                         "pxor %mm7,%mm7"
-                ::
-                 );
-#else
-        __asm__(
-                         "pxor %%mm7,%%mm7"
-                ::
-                 );
-#endif
-        for(int x=0;x<ll;x++)
-                {
-                        __asm__(
-                        "movd           (%0),%%mm0 \n"
-                        "movd           (%1),%%mm1 \n"
-                        "movd           (%2),%%mm2 \n"
-                        "movd           (%3),%%mm3 \n"
-                        "punpcklbw      %%mm7,%%mm0 \n"
-                        "punpcklbw      %%mm7,%%mm1 \n"
-                        "punpcklbw      %%mm7,%%mm2 \n"
-                        "punpcklbw      %%mm7,%%mm3 \n"  //sum=2*m1+2*m2-m0-m3;
-                        
-                        "paddw          %%mm2,%%mm1 \n"
-                        "paddw          %%mm1,%%mm1 \n"
-                        "paddw          %%mm3,%%mm0 \n"
-                        
-                        "psubusw        %%mm0,%%mm1 \n" // mm1=sum
-                        "psraw          $1,%%mm1 \n"    //2 
-                        "packuswb       %%mm1,  %%mm1\n"
-                        "movd           %%mm1,(%4) \n"
-
-                : : "r" (sp),"r" (s),"r"(sn),"r"(snn),"r"(d1)
-                );
-
-                        s+=4;
-                        sp+=4;
-                        sn+=4;
-                        snn+=4;
-                        d1+=4;
-                }
-        if(l&3) tinyRestore(d1, sp, s,sn,snn,l&3, 1);
-        return 1;
-}
-#endif
-
-static uint8_t    restore(ADMImage *tgt,ADMImage *srcP,ADMImage *src,ADMImage *srcN,ADMImage *srcNN)
-{
-int delta;
-uint32_t ww,hh;
-uint8_t *s1,*s2,*d1;
-int a1,a2,t1;
-
-#if defined (ARCH_X86 ) || defined (ARCH_X86_64 )
-        if(CpuCaps::hasMMX())
-        {
-              tinyRestoreMMX(YPLANE(tgt),YPLANE(srcP),YPLANE(src),YPLANE(srcN),YPLANE(srcNN),tgt->_width,tgt->_height);
-              tinyRestoreMMX(UPLANE(tgt),UPLANE(srcP),UPLANE(src),UPLANE(srcN),UPLANE(srcNN),tgt->_width>>1,tgt->_height>>1);
-              tinyRestoreMMX(VPLANE(tgt),VPLANE(srcP),VPLANE(src),VPLANE(srcN),VPLANE(srcNN),tgt->_width>>1,tgt->_height>>1);
-              return 1;
-        }
-#endif
-
-        tinyRestore(YPLANE(tgt),YPLANE(srcP),YPLANE(src),YPLANE(srcN),YPLANE(srcNN),tgt->_width,tgt->_height);
-        tinyRestore(UPLANE(tgt),UPLANE(srcP),UPLANE(src),UPLANE(srcN),UPLANE(srcNN),tgt->_width>>1,tgt->_height>>1);
-        tinyRestore(VPLANE(tgt),VPLANE(srcP),VPLANE(src),VPLANE(srcN),VPLANE(srcNN),tgt->_width>>1,tgt->_height>>1);
-        return 1;
-
-
-}
-
-uint8_t vidHardPDRemoval::getFrameNumberNoAlloc (uint32_t inframe,
-                                uint32_t * len,
-                                ADMImage * data, uint32_t * flags)
-{
-
-	
-	ADMImage *srcP,*srcN,*srcNN,*src,*final,*display;
-        float distMerged, distN,distP,distM,distR,skip=0;
-        char txt[255];
-
-        
-        if(inframe<1 || inframe>inframe>_info.nb_frames-3 )
-        {
-                skip=1;
-        }
-        if(inframe>_lastRemoved+1 && inframe<_lastRemoved+5 )
-        {
-                skip=1;
-        }
-        
-        if(skip)
-        {
-                data->duplicate(vidCache->getImage(inframe));
-                hint(data);
-                vidCache->unlockAll();
-                return 1;
-        }
-        
-        if(_lastRemoved==inframe-1)
-        {
-                data->duplicate(rebuild);
-                hint(data);
-                if(_param->show&&inframe)
-                {
-                        sprintf(txt," Telecined 2");
-                        drawString(data,2,4,txt);
-                }
-                
-                return 1;
-        }
-
-        //data->duplicate(rebuild);
-
-        srcP=vidCache->getImage(inframe-1);
-        src=vidCache->getImage(inframe);
-        srcN=vidCache->getImage(inframe+1);
-        srcNN=vidCache->getImage(inframe+2);
-
-        if(!src || !srcP || !srcN || !srcNN)
-        {
-                data->duplicate(vidCache->getImage(inframe));
-                vidCache->unlockAll();
-                return 1;
-        }
-        
-        // Let's rebuild the pseudo R, where we have A AR RB B
-        // If then we got R1 very close to R2, and that AR is very close to src
-        // Decide it is hard telecined (frame blending)
-#if 1
-        restore(rebuild,srcP,src,srcN,srcNN);
-#else
-        cand1->substract(src,srcP);
-        cand2->substract(srcN,srcNN);
-        rebuild->merge(cand1,cand2);
-#endif  
-#if 0
-        data->duplicate(rebuild);
-        vidCache->unlockAll();
-        return 1;
-#endif
-
-        // And remerge...
-        cand1->merge(srcP,rebuild);
-        cand2->merge(srcNN,rebuild);
-        
-        distP=ADMImage::lumaDiff(cand1,src,_param->noise);
-        distN=ADMImage::lumaDiff(cand2,srcN,_param->noise);
-        distM=ADMImage::lumaDiff(src,srcP,_param->noise);
-        distR=ADMImage::lumaDiff(src,srcN,_param->noise);
-        
-        
-        
-        double medium;
-
-         if(distM>1&&distR>1)
-        {
-                if(distM>distR) medium=distR;
-                          else  medium=distM;
-                  //medium=min(distM,distR);
-                 
-                 medium/=100;
-                 distN/=medium;
-                 distP/=medium;
-                 distR/=medium;
-         
-         }
-
-        medium=medium/(_info.width*_info.height);
-        medium*=1000;
-
-        if(medium<_param->identical)
-        {
-                 data->duplicate(src);
-                 vidCache->unlockAll();
-                if(_param->show)
-                {
-                        sprintf(txt," %% %02.1f : Identical",medium);
-                        drawString(data,2,3,txt);
-
-                }
-                return 1;
-        }
-        double mn;
-
-        if(inframe == _lastRemoved+5)
-        {
-                distN=(distN*7)/10;
-                distP=(distP*7)/10;
-                
-        }
-                //data->duplicate(src); 
-        if(distN<_param->threshold && distP<_param->threshold)
-        {
-                data->duplicate(rebuild);
-                hint(data);
-                _lastRemoved=inframe;
-                if(_param->show && inframe == _lastRemoved+5)
-                {
-                        sprintf(txt," Fav");
-                        drawString(data,2,5,txt);      
-                }
-        }
-        else
-                data->duplicate(src);
-        if(_param->show)
-        {
-                display=data;
-
-                sprintf(txt," N %02.1f",distN);
-                drawString(display,2,0,txt);
-
-                sprintf(txt," P %02.1f",distP);
-                drawString(display,2,1,txt);
-
-                sprintf(txt," R %02.1f",distR);
-                drawString(display,2,2,txt);
-
-                sprintf(txt," %% %02.1f",medium);
-                drawString(display,2,3,txt);
-
-                if(_lastRemoved==inframe)
-                {
-                        sprintf(txt," Telecined 1",distP);
-                        drawString(display,2,4,txt);
-                }
-        }
-
-
-          
-        vidCache->unlockAll();
-	return 1;
-}
-uint8_t vidHardPDRemoval::getCoupledConf (CONFcouple ** couples)
-{
-
-  ADM_assert (_param);
-  *couples = new CONFcouple (4);
-#undef CSET
-#define CSET(x)  (*couples)->setCouple(#x,(_param->x))
-  CSET (threshold);
-  CSET (show);
-  CSET (noise);
-  CSET (identical);
-  
-  return 1;
-}
-
-
-//EOF

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMosaic.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMosaic.cpp	2007-01-12 19:00:30 UTC (rev 2711)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMosaic.cpp	2007-01-12 19:23:19 UTC (rev 2712)
@@ -1,300 +0,0 @@
-/***************************************************************************
-                          
-        Mosaic filter
-                Put x*y images & resize them
-    copyright            : (C) 2005 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include "config.h"
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <math.h>
-#include <ADM_assert.h>
-
-#include "fourcc.h"
-#include "avio.hxx"
-#include "avi_vars.h"
-
-#include "ADM_toolkit/toolkit.hxx"
-#include "ADM_editor/ADM_edit.hxx"
-#include "ADM_video/ADM_genvideo.hxx"
-#include "ADM_video/ADM_vidCommonFilter.h"
-
-
-
-
-#if (defined( ARCH_X86)  || defined(ARCH_X86_64))
-extern "C" {
-#include "ADM_lavcodec/avcodec.h"
-}
-#endif
-
-#include "ADM_lavutil/avutil.h"
-#include "../ADM_libswscale/swscale.h"
-#include "ADM_osSupport/ADM_cpuCap.h"
-#include "ADM_filter/video_filters.h"
-
-#include "ADM_video/ADM_cache.h"
-#include "DIA_enter.h"
-
-#include "ADM_vidMosaic_param.h"
-
-extern uint8_t  DIA_mosaic(MOSAIC_PARAMS *mosaic);
-
-class  ADMVideoMosaic:public AVDMGenericVideoStream
- {
-
- protected:
-                                MOSAIC_PARAMS   *_param;
-                                SwsContext      *_context;
-                                uint8_t         reset(void);
-                                uint8_t         clean( void );
-                                VideoCache     *vidCache;
-                                uint32_t       tinyW,tinyH;
- public:
-
-                                ADMVideoMosaic(  AVDMGenericVideoStream *in,CONFcouple *setup);
-                                ADMVideoMosaic(        AVDMGenericVideoStream *in,uint32_t x,uint32_t y);
-                                virtual                 ~ADMVideoMosaic();
-          virtual               uint8_t getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-                                                                ADMImage *data,uint32_t *flags);
-                                uint8_t configure( AVDMGenericVideoStream *instream);
-        virtual                 char    *printConf(void) ;
-
-          virtual uint8_t       getCoupledConf( CONFcouple **couples);
-
-
- }     ;
-static FILTER_PARAM mosaicParam={4,{"hz","vz","shrink","show"}};
-
-BUILD_CREATE(mosaic_create,ADMVideoMosaic);
-SCRIPT_CREATE(mosaic_script,ADMVideoMosaic,mosaicParam);
-
-
-
-uint8_t ADMVideoMosaic::configure(AVDMGenericVideoStream * instream)
-{
-    UNUSED_ARG(instream);
-
-    if(  DIA_mosaic(_param)) 
-    {
-        reset();
-        return 1;
-    }
-    return 0;
-
-}
-
-//
-//  
-//
-uint8_t ADMVideoMosaic::clean(void)
-{
-                if(_context)
-                {
-                        sws_freeContext(_context);
-                }
-                _context=NULL;
-                if(_uncompressed) delete _uncompressed;
-                _uncompressed=NULL;
-                if(vidCache) delete vidCache;
-                vidCache=NULL;
-                return 1;
-}
-
-uint8_t ADMVideoMosaic::reset(void)
-{
-SwsFilter                  *srcFilter=NULL;
-SwsFilter                  *dstFilter=NULL;
-int                       flags=0;
-
-                clean();
-                flags=SWS_BICUBIC;
-
-
-#if (defined( ARCH_X86)  || defined(ARCH_X86_64))
-                
-                #define ADD(x,y) if( CpuCaps::has##x()) flags|=SWS_CPU_CAPS_##y;
-                ADD(MMX,MMX);           
-                ADD(3DNOW,3DNOW);
-                ADD(MMXEXT,MMX2);
-#endif  
-        
-        
-
-        memcpy(&_info,_in->getInfo(),sizeof(_info));
-       
-
-      
-
-        tinyW=_info.width;
-        tinyH=_info.height;
-        
-        tinyW/=_param->shrink;
-        tinyH/=_param->shrink;
-
-        if(tinyW&1) tinyW++;
-        if(tinyH&1) tinyH++;
-        
-
-        _info.width=tinyW*_param->hz;
-        _info.height=tinyH*_param->vz;
-
-
-        _uncompressed=new ADMImage(_info.width,_info.height);
-        vidCache=new VideoCache(_param->vz*_param->hz*2,_in);
-        //_info.nb_frames=_info.nb_frames/(_param->vz*_param->hz);
-
-  _context=sws_getContext(
-                        _in->getInfo()->width,_in->getInfo()->height,
-                        PIX_FMT_YUV420P,
-                        tinyW,
-                        tinyH,
-                        PIX_FMT_YUV420P,
-                        flags, srcFilter, dstFilter,NULL);
-
-        if(!_context) return 0;
-        return 1;
-
-
-}
-char *ADMVideoMosaic::printConf( void )
-{
-        static char buf[50];
-
-        sprintf((char *)buf," Mosaic : %d hz, %d vz, %d shrink factor",
-                                _in->getInfo()->width,
-                                _param->hz,_param->vz,_param->shrink);
-        return buf;
-}
-//_______________________________________________________________
-ADMVideoMosaic::ADMVideoMosaic(
-                                                                        AVDMGenericVideoStream *in,CONFcouple *couples)
-{
-
-        _in=in;
-        memcpy(&_info,_in->getInfo(),sizeof(_info));
-        _param=NEW(MOSAIC_PARAMS);
-
-        if(couples)
-        {
-
-                GET(hz);
-                GET(vz);
-                GET(shrink);
-                GET(show);
-        
-        }
-        else
-        {
-                _param->hz=3;
-                _param->vz =3;
-                _param->shrink = 3;
-                _param->show=1;
-        }
-
-        _context=NULL;
-       vidCache=NULL;
-
-        reset();
-        _info.encoding=1;
-
-}
-
-
-uint8_t ADMVideoMosaic::getCoupledConf( CONFcouple **couples)
-{
-
-                        ADM_assert(_param);
-                        *couples=new CONFcouple(4);
-
-#define CSET(x)  (*couples)->setCouple((char *)#x,(_param->x))
-        CSET(hz);
-        CSET(vz);
-        CSET(shrink);
-        CSET(show);
-                        return 1;
-
-}
-// ___ destructor_____________
-ADMVideoMosaic::~ADMVideoMosaic()
-{
-        clean();
-        DELETE(_param);
-
-}
-
-//
-//      Basically ask a uncompressed frame from editor and ask
-//              GUI to decompress it .
-//
-
-uint8_t ADMVideoMosaic::getFrameNumberNoAlloc(uint32_t frame,
-                                uint32_t *len,
-                                ADMImage *data,
-                                uint32_t *flags)
-{
-                        if(frame>=_info.nb_frames) 
-                        {
-                                printf("Filter : out of bound!\n");
-                                return 0;
-                        }
-        
-                        ADM_assert(_param);
-
-ADMImage *curImage;
-char txt[256];
-
-                        for(int y=0;y<_param->vz;y++)
-                          for(int x=0;x<_param->hz;x++)
-                        {
-                          curImage=vidCache->getImage(frame+y*_param->hz+x);
-                          if(!curImage) continue;
-
-                          if(_param->show)
-                          {
-                                sprintf(txt," %02d",frame+x+y*_param->hz);
-                                drawString(curImage,2,0,txt);
-                          }
-
-                          
-                          uint8_t *src[3];
-                          uint8_t *dst[3];
-                          int ssrc[3];
-                          int ddst[3];
-
-                          uint32_t page;
-
-                          page=_in->getInfo()->width*_in->getInfo()->height;
-                          src[0]=YPLANE(curImage);
-                          src[1]=UPLANE(curImage);
-                          src[2]=VPLANE(curImage);
-
-                          ssrc[0]=_in->getInfo()->width;
-                          ssrc[1]=ssrc[2]=_in->getInfo()->width>>1;
-
-                          page=_info.width*tinyH;
-                          
-                          dst[0]=YPLANE(data)+page*y+tinyW*x;
-                          dst[1]=UPLANE(data)+((page*y)/4)+((tinyW*x)/2);
-                          dst[2]=VPLANE(data)+((page*y)/4)+((tinyW*x)/2);
-                          ddst[0]=_info.width;
-                          ddst[1]=ddst[2]=_info.width>>1;
-
-                          sws_scale(_context,src,ssrc,0,_in->getInfo()->height,dst,ddst);
-                        }
-                        vidCache->unlockAll();
-        return 1;
-}
-

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMosaic_param.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMosaic_param.h	2007-01-12 19:00:30 UTC (rev 2711)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMosaic_param.h	2007-01-12 19:23:19 UTC (rev 2712)
@@ -1,12 +0,0 @@
-
-#ifndef MOSAIC_PARAMS_H
-#define MOSAIC_PARAMS_H
-typedef struct MOSAIC_PARAMS
-{
-        uint32_t hz;
-        uint32_t vz;
-        uint32_t shrink;
-        uint32_t show;
-}MOSAIC_PARAMS;
-#endif
-

Modified: branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am	2007-01-12 19:00:30 UTC (rev 2711)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am	2007-01-12 19:23:19 UTC (rev 2712)
@@ -71,9 +71,6 @@
  ADM_vidCNR2.cpp \
   ADM_vidDelta.cpp \
  ADM_vidUnblend.cpp \
- ADM_vidHardIvtcRemoval.cpp \
-  ADM_vidMosaic.cpp \
- ADM_vidBlendRemoval.cpp \
  ADM_vidTdeint.cpp \
  ADM_vidMPdelogo.cpp \
  ADM_guiCrop.cpp \
@@ -86,7 +83,7 @@
 				
 
 
-EXTRA_DIST =  ADM_cache.cpp  ADM_vidDecDec_param.h ADM_vidMosaic_param.h \
+EXTRA_DIST =  ADM_cache.cpp  ADM_vidDecDec_param.h \
 ADM_cache.h  ADM_vidDecTel_param.h \
 ADM_confCouple.h ADM_vidDecTelecide.cpp  ADM_vidNull.cpp \
 ADM_confCouples.cpp  ADM_vidDecTelecide.h  ADM_vidPalShift.cpp \
@@ -116,9 +113,9 @@
 ADM_vidAsharp.cpp   ADM_vidStabilize.cpp \
 ADM_vidFont.cpp ADM_vidStabilize.h \
 ADM_vidBlend.cpp ADM_vidFont.h ADM_vidSwapFields.cpp \
-ADM_vidBlendRemoval.cpp  ADM_vidSwapFields.h \
-ADM_vidBlendRemoval_param.h  ADM_vidSwapSmart.cpp \
-ADM_vidCNR2.cpp  ADM_vidHardIvtcRemoval.cpp  ADM_vidSwapSmart.h \
+ADM_vidSwapFields.h \
+ADM_vidSwapSmart.cpp \
+ADM_vidCNR2.cpp  ADM_vidSwapSmart.h \
 ADM_vidCNR2_param.h  ADM_vidHue.cpp  ADM_vidTDeint_param.h \
 ADM_vidCached.cpp  ADM_vidHue.h  ADM_vidTdeint.cpp \
 ADM_vidCached.h  ADM_vidIVTC.cpp ADM_vidTelecide.cpp \
@@ -140,7 +137,7 @@
 ADM_vidConvolution.hxx  ADM_vobsubinfo.cpp \
 ADM_vidCrop.cpp  ADM_vidMSmooth_param.h  ADM_vobsubinfo.h \
 ASM_vidDenoise.cpp \
-ADM_vidDecDec.cpp  ADM_vidMosaic.cpp swscale_internal.h \
+ADM_vidDecDec.cpp  swscale_internal.h \
 ADM_vidTdeint_util.txt ADM_vidASS.h ADM_vidASS.cpp \
 ADM_vidAss_Params.h mmx_macros.h
 

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidBlendRemoval.cpp (from rev 2530, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidBlendRemoval.cpp)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidBlendRemoval.cpp	2006-11-01 11:17:21 UTC (rev 2530)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidBlendRemoval.cpp	2007-01-12 19:23:19 UTC (rev 2712)
@@ -0,0 +1,270 @@
+/***************************************************************************
+                         
+        Blending remover
+
+        A B C D E -> A AB B 
+
+    copyright            : (C) 2005 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "config.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ADM_assert.h>
+
+#include "config.h"
+#include "fourcc.h"
+#include "avio.hxx"
+#include "default.h"
+#include "math.h"
+
+#include "ADM_toolkit/toolkit.hxx"
+#include "ADM_editor/ADM_edit.hxx"
+#include "ADM_video/ADM_genvideo.hxx"
+
+#include "ADM_osSupport/ADM_debugID.h"
+#define MODULE_NAME MODULE_FILTER
+#include "ADM_osSupport/ADM_debug.h"
+#include "ADM_video/ADM_cache.h"
+#include "ADM_filter/video_filters.h"
+#include "DIA_enter.h"
+#include "ADM_osSupport/ADM_cpuCap.h"
+#include "ADM_userInterfaces/ADM_commonUI/DIA_factory.h"
+#include "ADM_vidBlendRemoval_param.h"
+#define MUL 1
+// Set it to 2 for post separate field
+
+
+
+class vidBlendRemoval:public AVDMGenericVideoStream
+{
+
+protected:
+  virtual char *printConf (void);
+  VideoCache *vidCache;
+  BLEND_REMOVER_PARAM *_param;
+  uint32_t              _lastRemoved;
+  ADMImage              *rebuild;
+public:
+
+                        vidBlendRemoval (AVDMGenericVideoStream * in, CONFcouple * setup);
+        virtual         ~vidBlendRemoval ();
+  virtual uint8_t getFrameNumberNoAlloc (uint32_t frame, uint32_t * len,
+                                         ADMImage * data, uint32_t * flags);
+  uint8_t configure (AVDMGenericVideoStream * instream);
+  virtual uint8_t getCoupledConf (CONFcouple ** couples);
+
+};
+
+static FILTER_PARAM field_unblend_template =
+  { 4,"threshold","show","noise","identical"};
+
+BUILD_CREATE (blendremove_create, vidBlendRemoval);
+SCRIPT_CREATE (blendremove_script, vidBlendRemoval, field_unblend_template);
+//*************************************
+uint8_t vidBlendRemoval::configure (AVDMGenericVideoStream * in)
+{
+  
+   _in=in;
+    
+#define PX(x) &(_param->x)
+        
+    diaElemUInteger   thresh(PX(threshold),_("threshold"),0,99,
+        _("If value is smaller than threshold it is considered valid."
+            " Smaller value might mean more false positive"));
+    diaElemUInteger   noise(PX(noise),_("noise"),0,99,_("If pixel are closer than noise, they are considered to be the same"));
+    diaElemUInteger   identical(PX(identical),_("identical"),0,99,_("If metric is less than identical, images are considered identical"));
+    diaElemToggle     show(PX(show),_("identical"),_("Show metric in image (debug)"));
+    
+       diaElem *elems[]={&thresh,&noise,&identical,&show};
+  
+   if(  diaFactoryRun("Blend Removal",sizeof(elems)/sizeof(diaElem *),elems))
+   {
+        _lastRemoved=0xFFFFFFF;
+        return 1;
+    }
+        return 0;
+}
+/*************************************/
+char *vidBlendRemoval::printConf (void)
+{
+  static char buf[50];
+  sprintf ((char *) buf, " Blend Removal Thresh:%d Noise:%d Ident:%d",_param->threshold,_param->noise,_param->identical);
+  return buf;
+}
+
+#define MAX_BLOCKS 50
+/*************************************/
+vidBlendRemoval::vidBlendRemoval (AVDMGenericVideoStream * in, CONFcouple * couples)
+{
+
+  _in = in;
+  memcpy (&_info, _in->getInfo (), sizeof (_info));
+  _info.encoding = 1;
+  vidCache = new VideoCache (10, in);
+  _uncompressed=new ADMImage(_info.width,_info.height);
+  rebuild=new ADMImage(_info.width,_info.height);
+
+ _param=new BLEND_REMOVER_PARAM;
+ _lastRemoved=0xFFFF;
+ if(couples)
+ {
+#undef GET
+#define GET(x) couples->getCouple(#x,&(_param->x))
+      GET (threshold);
+      GET (show);
+      GET (noise);
+      GET (identical);
+  }
+  else
+  {
+        _param->threshold=10;
+        _param->show=0;
+        _param->noise=5;
+        _param->identical=2;
+  }
+}
+//____________________________________________________________________
+vidBlendRemoval::~vidBlendRemoval ()
+{
+
+  delete vidCache;
+  vidCache = NULL;
+  delete _uncompressed;
+  _uncompressed=NULL;
+  delete _param;
+  _param=NULL;
+  delete rebuild;
+  rebuild=NULL;
+}
+
+
+
+
+
+uint8_t vidBlendRemoval::getFrameNumberNoAlloc (uint32_t inframe,
+                                uint32_t * len,
+                                ADMImage * data, uint32_t * flags)
+{
+
+	
+	ADMImage *srcP,*srcN,*src,*final,*display;
+        float distMerged, distN,distP,distM,distR,skip=0;
+        char txt[255];
+
+        
+        if(inframe<1 || inframe>inframe>_info.nb_frames-2 )
+        {
+                skip=1;
+        }
+        if(inframe && _lastRemoved==inframe-1)
+        {
+                skip=1;
+        }
+        
+        if(skip)
+        {
+                data->duplicate(vidCache->getImage(inframe));
+                vidCache->unlockAll();
+                return 1;
+        }
+        
+        
+
+        srcP=vidCache->getImage(inframe-1);
+        src=vidCache->getImage(inframe);
+        srcN=vidCache->getImage(inframe+1);
+        if(!srcP || !src || !srcN)
+        {
+                data->duplicate(vidCache->getImage(inframe));
+                vidCache->unlockAll();
+                return 1;
+        }
+       
+        rebuild->merge(srcP,srcN);
+        
+        distP=ADMImage::lumaDiff(src,srcN,_param->noise);
+        distN=ADMImage::lumaDiff(src,srcP,_param->noise);
+        distM=ADMImage::lumaDiff(src,rebuild,_param->noise);
+        
+        
+        
+        
+        double medium;
+
+         if(distN>1&&distP>1)
+        {
+                if(distP>distN) medium=distN;
+                          else  medium=distP;
+                  //medium=min(distM,distR);
+                 
+                 medium/=100;
+                 distN/=medium;
+                 distP/=medium;
+                 distM/=medium;
+         
+         }
+        
+        medium=medium/(_info.width*_info.height);
+        medium*=1000;
+        if(distM<_param->threshold && medium>_param->identical) // medium is how close pictures are, too close, we discard
+        {
+                data->duplicate(srcP);
+                _lastRemoved=inframe;
+                if(_param->show )
+                {
+                        sprintf(txt,"Dupe");
+                        drawString(data,2,5,txt);      
+                }
+        }
+        else
+                data->duplicate(src);
+        if(_param->show)
+        {
+                display=data;
+
+                sprintf(txt," N %02.1f",distN);
+                drawString(display,2,0,txt);
+
+                sprintf(txt," P %02.1f",distP);
+                drawString(display,2,1,txt);
+
+                sprintf(txt," M %02.1f",distM);
+                drawString(display,2,2,txt);
+
+                sprintf(txt," %% %02.1f",medium);
+                drawString(display,2,3,txt);
+        }
+
+
+          
+        vidCache->unlockAll();
+	return 1;
+}
+uint8_t vidBlendRemoval::getCoupledConf (CONFcouple ** couples)
+{
+
+  ADM_assert (_param);
+  *couples = new CONFcouple (4);
+#undef CSET
+#define CSET(x)  (*couples)->setCouple(#x,(_param->x))
+  CSET (threshold);
+  CSET (show);
+  CSET (noise);
+  CSET (identical);
+  
+  return 1;
+}
+
+
+//EOF

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidBlendRemoval_param.h (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidBlendRemoval_param.h)

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidHardIvtcRemoval.cpp (from rev 2530, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidHardIvtcRemoval.cpp)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidHardIvtcRemoval.cpp	2006-11-01 11:17:21 UTC (rev 2530)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidHardIvtcRemoval.cpp	2007-01-12 19:23:19 UTC (rev 2712)
@@ -0,0 +1,490 @@
+/***************************************************************************
+                         
+        Hard ivtc removal for image
+
+        A B C D E -> A BC CD D E
+
+    copyright            : (C) 2005 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "config.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ADM_assert.h>
+
+#include "config.h"
+#include "fourcc.h"
+#include "avio.hxx"
+#include "default.h"
+#include "math.h"
+
+#include "ADM_toolkit/toolkit.hxx"
+#include "ADM_editor/ADM_edit.hxx"
+#include "ADM_video/ADM_genvideo.hxx"
+
+#include "ADM_osSupport/ADM_debugID.h"
+#define MODULE_NAME MODULE_FILTER
+#include "ADM_osSupport/ADM_debug.h"
+#include "ADM_video/ADM_cache.h"
+#include "ADM_filter/video_filters.h"
+#include "DIA_enter.h"
+#include "ADM_osSupport/ADM_cpuCap.h"
+#include "ADM_userInterfaces/ADM_commonUI/DIA_factory.h"
+
+#define MUL 1
+// Set it to 2 for post separate field
+
+#include "ADM_vidBlendRemoval_param.h"
+
+#define PROGRESSIVE  0x00000001
+#define MAGIC_NUMBER (0xdeadbeef)
+#define IN_PATTERN   0x00000002
+
+extern uint8_t PutHintingData(unsigned char *video, unsigned int hint);
+
+class vidHardPDRemoval:public AVDMGenericVideoStream
+{
+
+protected:
+  virtual char *printConf (void);
+  VideoCache *vidCache;
+  BLEND_REMOVER_PARAM *_param;
+  uint32_t              _lastRemoved;
+  ADMImage              *cand1,*cand2,*rebuild;
+public:
+
+                        vidHardPDRemoval (AVDMGenericVideoStream * in, CONFcouple * setup);
+        virtual         ~vidHardPDRemoval ();
+  virtual uint8_t getFrameNumberNoAlloc (uint32_t frame, uint32_t * len,
+                                         ADMImage * data, uint32_t * flags);
+  uint8_t configure (AVDMGenericVideoStream * instream);
+  virtual uint8_t getCoupledConf (CONFcouple ** couples);
+
+};
+
+static FILTER_PARAM field_unblend_template =
+  { 4,"threshold","show","noise","identical"};
+
+BUILD_CREATE (hardivtc_create, vidHardPDRemoval);
+SCRIPT_CREATE (hardivtc_script, vidHardPDRemoval, field_unblend_template);
+//*************************************
+uint8_t vidHardPDRemoval::configure (AVDMGenericVideoStream * in)
+{
+       _in=in;
+    
+#define PX(x) &(_param->x)
+        
+    diaElemUInteger   thresh(PX(threshold),_("threshold"),0,99,
+        _("If value is smaller than threshold it is considered valid."
+            " Smaller value might mean more false positive"));
+    diaElemUInteger   noise(PX(noise),_("noise"),0,99,_("If pixel are closer than noise, they are considered to be the same"));
+    diaElemUInteger   identical(PX(identical),_("identical"),0,99,_("If metric is less than identical, images are considered identical"));
+    diaElemToggle     show(PX(show),_("identical"),_("Show metric in image (debug)"));
+    
+       diaElem *elems[]={&thresh,&noise,&identical,&show};
+  
+   if(  diaFactoryRun("Hard ivtc removal",sizeof(elems)/sizeof(diaElem *),elems))
+   {
+        _lastRemoved=0xFFFFFFF;
+        return 1;
+    }
+        return 0;
+}
+/*************************************/
+char *vidHardPDRemoval::printConf (void)
+{
+  static char buf[50];
+  sprintf ((char *) buf, " Field Unblend Thresh:%d Noise:%d",_param->threshold,_param->noise);
+  return buf;
+}
+static void hint(ADMImage *img)
+{
+       unsigned int hint;
+
+                 hint= PROGRESSIVE;
+                
+                 hint |= IN_PATTERN;
+                
+                PutHintingData(YPLANE(img), hint);  
+
+}
+#define MAX_BLOCKS 50
+/*************************************/
+vidHardPDRemoval::vidHardPDRemoval (AVDMGenericVideoStream * in, CONFcouple * couples)
+{
+
+  _in = in;
+  memcpy (&_info, _in->getInfo (), sizeof (_info));
+  _info.encoding = 1;
+  vidCache = new VideoCache (10, in);
+  _uncompressed=new ADMImage(_info.width,_info.height);
+  cand1=new ADMImage(_info.width,_info.height);
+  cand2=new ADMImage(_info.width,_info.height);
+  rebuild=new ADMImage(_info.width,_info.height);
+
+ _param=new BLEND_REMOVER_PARAM;
+ _lastRemoved=0xFFFFFFF;
+ if(couples)
+ {
+#undef GET
+#define GET(x) couples->getCouple(#x,&(_param->x))
+      GET (threshold);
+      GET (show);
+      GET (noise);
+      GET (identical);
+  }
+  else
+  {
+        _param->threshold=10;
+        _param->show=0;
+        _param->noise=5;
+        _param->identical=2;
+  }
+}
+//____________________________________________________________________
+vidHardPDRemoval::~vidHardPDRemoval ()
+{
+
+  delete vidCache;
+  vidCache = NULL;
+  delete _uncompressed;
+  _uncompressed=NULL;
+  delete _param;
+  _param=NULL;
+  delete cand1;
+  delete cand2;
+  delete rebuild;
+  cand1=NULL;
+  cand2=NULL;
+  rebuild=NULL;
+}
+
+
+
+
+/*
+
+                src=blend of srcP and R         => src= 1/2(srcP+R)
+                                                   2*src-srcP=R
+
+                srcN=blend of srcNN and R       => srcN=1/2 (srcNN+R)
+                                                        2*srcN-srcNN=R
+
+*/
+
+static uint8_t tinyRestore(uint8_t *dst, uint8_t *srcP, uint8_t *src,uint8_t *srcN,uint8_t *srcNN,uint32_t w, uint32_t h)
+{
+
+
+uint8_t *s,*sp,*sn,*snn,*d1;
+int a1,a2,a3,a4,sum,delta;
+
+        sp=srcP;
+        s=src;
+        sn=srcN;
+        snn=srcNN;
+        
+        d1=dst;
+
+          for(int y=0;y<h;y++)
+                for(int x=0;x<w;x++)
+                {
+                        a1=*sp;
+                        a2=*s;
+                        a3=*sn;
+                        a4=*snn;
+
+                        sum=2*a2+2*a3-a1-a4;
+                        sum=sum/2;
+                        
+                        a1=sum;                        
+
+                        if(a1<0) a1=0;
+                        if(a1>255) a1=255;
+                        *d1=a1;
+
+                        s++;
+                        sp++;
+                        sn++;
+                        snn++;
+                        d1++;
+                }
+        return 1;
+}
+#if defined (ARCH_X86 ) || defined (ARCH_X86_64 )
+static uint8_t tinyRestoreMMX(uint8_t *dst, uint8_t *srcP, uint8_t *src,uint8_t *srcN,uint8_t *srcNN,uint32_t w, uint32_t h)
+{
+
+
+uint8_t *s,*sp,*sn,*snn,*d1;
+int a1,a2,a3,a4,sum,delta,l,ll;
+
+        sp=srcP;
+        s=src;
+        sn=srcN;
+        snn=srcNN;
+        
+        d1=dst;
+
+        l=w*h;
+        ll=l>>2;
+#ifdef GCC_2_95_X
+        __asm__(
+                         "pxor %mm7,%mm7"
+                ::
+                 );
+#else
+        __asm__(
+                         "pxor %%mm7,%%mm7"
+                ::
+                 );
+#endif
+        for(int x=0;x<ll;x++)
+                {
+                        __asm__(
+                        "movd           (%0),%%mm0 \n"
+                        "movd           (%1),%%mm1 \n"
+                        "movd           (%2),%%mm2 \n"
+                        "movd           (%3),%%mm3 \n"
+                        "punpcklbw      %%mm7,%%mm0 \n"
+                        "punpcklbw      %%mm7,%%mm1 \n"
+                        "punpcklbw      %%mm7,%%mm2 \n"
+                        "punpcklbw      %%mm7,%%mm3 \n"  //sum=2*m1+2*m2-m0-m3;
+                        
+                        "paddw          %%mm2,%%mm1 \n"
+                        "paddw          %%mm1,%%mm1 \n"
+                        "paddw          %%mm3,%%mm0 \n"
+                        
+                        "psubusw        %%mm0,%%mm1 \n" // mm1=sum
+                        "psraw          $1,%%mm1 \n"    //2 
+                        "packuswb       %%mm1,  %%mm1\n"
+                        "movd           %%mm1,(%4) \n"
+
+                : : "r" (sp),"r" (s),"r"(sn),"r"(snn),"r"(d1)
+                );
+
+                        s+=4;
+                        sp+=4;
+                        sn+=4;
+                        snn+=4;
+                        d1+=4;
+                }
+        if(l&3) tinyRestore(d1, sp, s,sn,snn,l&3, 1);
+        return 1;
+}
+#endif
+
+static uint8_t    restore(ADMImage *tgt,ADMImage *srcP,ADMImage *src,ADMImage *srcN,ADMImage *srcNN)
+{
+int delta;
+uint32_t ww,hh;
+uint8_t *s1,*s2,*d1;
+int a1,a2,t1;
+
+#if defined (ARCH_X86 ) || defined (ARCH_X86_64 )
+        if(CpuCaps::hasMMX())
+        {
+              tinyRestoreMMX(YPLANE(tgt),YPLANE(srcP),YPLANE(src),YPLANE(srcN),YPLANE(srcNN),tgt->_width,tgt->_height);
+              tinyRestoreMMX(UPLANE(tgt),UPLANE(srcP),UPLANE(src),UPLANE(srcN),UPLANE(srcNN),tgt->_width>>1,tgt->_height>>1);
+              tinyRestoreMMX(VPLANE(tgt),VPLANE(srcP),VPLANE(src),VPLANE(srcN),VPLANE(srcNN),tgt->_width>>1,tgt->_height>>1);
+              return 1;
+        }
+#endif
+
+        tinyRestore(YPLANE(tgt),YPLANE(srcP),YPLANE(src),YPLANE(srcN),YPLANE(srcNN),tgt->_width,tgt->_height);
+        tinyRestore(UPLANE(tgt),UPLANE(srcP),UPLANE(src),UPLANE(srcN),UPLANE(srcNN),tgt->_width>>1,tgt->_height>>1);
+        tinyRestore(VPLANE(tgt),VPLANE(srcP),VPLANE(src),VPLANE(srcN),VPLANE(srcNN),tgt->_width>>1,tgt->_height>>1);
+        return 1;
+
+
+}
+
+uint8_t vidHardPDRemoval::getFrameNumberNoAlloc (uint32_t inframe,
+                                uint32_t * len,
+                                ADMImage * data, uint32_t * flags)
+{
+
+	
+	ADMImage *srcP,*srcN,*srcNN,*src,*final,*display;
+        float distMerged, distN,distP,distM,distR,skip=0;
+        char txt[255];
+
+        
+        if(inframe<1 || inframe>inframe>_info.nb_frames-3 )
+        {
+                skip=1;
+        }
+        if(inframe>_lastRemoved+1 && inframe<_lastRemoved+5 )
+        {
+                skip=1;
+        }
+        
+        if(skip)
+        {
+                data->duplicate(vidCache->getImage(inframe));
+                hint(data);
+                vidCache->unlockAll();
+                return 1;
+        }
+        
+        if(_lastRemoved==inframe-1)
+        {
+                data->duplicate(rebuild);
+                hint(data);
+                if(_param->show&&inframe)
+                {
+                        sprintf(txt," Telecined 2");
+                        drawString(data,2,4,txt);
+                }
+                
+                return 1;
+        }
+
+        //data->duplicate(rebuild);
+
+        srcP=vidCache->getImage(inframe-1);
+        src=vidCache->getImage(inframe);
+        srcN=vidCache->getImage(inframe+1);
+        srcNN=vidCache->getImage(inframe+2);
+
+        if(!src || !srcP || !srcN || !srcNN)
+        {
+                data->duplicate(vidCache->getImage(inframe));
+                vidCache->unlockAll();
+                return 1;
+        }
+        
+        // Let's rebuild the pseudo R, where we have A AR RB B
+        // If then we got R1 very close to R2, and that AR is very close to src
+        // Decide it is hard telecined (frame blending)
+#if 1
+        restore(rebuild,srcP,src,srcN,srcNN);
+#else
+        cand1->substract(src,srcP);
+        cand2->substract(srcN,srcNN);
+        rebuild->merge(cand1,cand2);
+#endif  
+#if 0
+        data->duplicate(rebuild);
+        vidCache->unlockAll();
+        return 1;
+#endif
+
+        // And remerge...
+        cand1->merge(srcP,rebuild);
+        cand2->merge(srcNN,rebuild);
+        
+        distP=ADMImage::lumaDiff(cand1,src,_param->noise);
+        distN=ADMImage::lumaDiff(cand2,srcN,_param->noise);
+        distM=ADMImage::lumaDiff(src,srcP,_param->noise);
+        distR=ADMImage::lumaDiff(src,srcN,_param->noise);
+        
+        
+        
+        double medium;
+
+         if(distM>1&&distR>1)
+        {
+                if(distM>distR) medium=distR;
+                          else  medium=distM;
+                  //medium=min(distM,distR);
+                 
+                 medium/=100;
+                 distN/=medium;
+                 distP/=medium;
+                 distR/=medium;
+         
+         }
+
+        medium=medium/(_info.width*_info.height);
+        medium*=1000;
+
+        if(medium<_param->identical)
+        {
+                 data->duplicate(src);
+                 vidCache->unlockAll();
+                if(_param->show)
+                {
+                        sprintf(txt," %% %02.1f : Identical",medium);
+                        drawString(data,2,3,txt);
+
+                }
+                return 1;
+        }
+        double mn;
+
+        if(inframe == _lastRemoved+5)
+        {
+                distN=(distN*7)/10;
+                distP=(distP*7)/10;
+                
+        }
+                //data->duplicate(src); 
+        if(distN<_param->threshold && distP<_param->threshold)
+        {
+                data->duplicate(rebuild);
+                hint(data);
+                _lastRemoved=inframe;
+                if(_param->show && inframe == _lastRemoved+5)
+                {
+                        sprintf(txt," Fav");
+                        drawString(data,2,5,txt);      
+                }
+        }
+        else
+                data->duplicate(src);
+        if(_param->show)
+        {
+                display=data;
+
+                sprintf(txt," N %02.1f",distN);
+                drawString(display,2,0,txt);
+
+                sprintf(txt," P %02.1f",distP);
+                drawString(display,2,1,txt);
+
+                sprintf(txt," R %02.1f",distR);
+                drawString(display,2,2,txt);
+
+                sprintf(txt," %% %02.1f",medium);
+                drawString(display,2,3,txt);
+
+                if(_lastRemoved==inframe)
+                {
+                        sprintf(txt," Telecined 1",distP);
+                        drawString(display,2,4,txt);
+                }
+        }
+
+
+          
+        vidCache->unlockAll();
+	return 1;
+}
+uint8_t vidHardPDRemoval::getCoupledConf (CONFcouple ** couples)
+{
+
+  ADM_assert (_param);
+  *couples = new CONFcouple (4);
+#undef CSET
+#define CSET(x)  (*couples)->setCouple(#x,(_param->x))
+  CSET (threshold);
+  CSET (show);
+  CSET (noise);
+  CSET (identical);
+  
+  return 1;
+}
+
+
+//EOF

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMosaic.cpp (from rev 2530, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMosaic.cpp)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMosaic.cpp	2006-11-01 11:17:21 UTC (rev 2530)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMosaic.cpp	2007-01-12 19:23:19 UTC (rev 2712)
@@ -0,0 +1,310 @@
+/***************************************************************************
+                          
+        Mosaic filter
+                Put x*y images & resize them
+    copyright            : (C) 2005 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "config.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <math.h>
+#include <ADM_assert.h>
+
+#include "fourcc.h"
+#include "avio.hxx"
+#include "avi_vars.h"
+
+#include "ADM_toolkit/toolkit.hxx"
+#include "ADM_editor/ADM_edit.hxx"
+#include "ADM_video/ADM_genvideo.hxx"
+#include "ADM_video/ADM_vidCommonFilter.h"
+
+#include "ADM_userInterfaces/ADM_commonUI/DIA_factory.h"
+
+
+#if (defined( ARCH_X86)  || defined(ARCH_X86_64))
+extern "C" {
+#include "ADM_lavcodec/avcodec.h"
+}
+#endif
+
+#include "ADM_lavutil/avutil.h"
+#include "../ADM_libswscale/swscale.h"
+#include "ADM_osSupport/ADM_cpuCap.h"
+#include "ADM_filter/video_filters.h"
+
+#include "ADM_video/ADM_cache.h"
+#include "DIA_enter.h"
+
+#include "ADM_vidMosaic_param.h"
+
+extern uint8_t  DIA_mosaic(MOSAIC_PARAMS *mosaic);
+
+class  ADMVideoMosaic:public AVDMGenericVideoStream
+ {
+
+ protected:
+                                MOSAIC_PARAMS   *_param;
+                                SwsContext      *_context;
+                                uint8_t         reset(void);
+                                uint8_t         clean( void );
+                                VideoCache     *vidCache;
+                                uint32_t       tinyW,tinyH;
+ public:
+
+                                ADMVideoMosaic(  AVDMGenericVideoStream *in,CONFcouple *setup);
+                                ADMVideoMosaic(        AVDMGenericVideoStream *in,uint32_t x,uint32_t y);
+                                virtual                 ~ADMVideoMosaic();
+          virtual               uint8_t getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
+                                                                ADMImage *data,uint32_t *flags);
+                                uint8_t configure( AVDMGenericVideoStream *instream);
+        virtual                 char    *printConf(void) ;
+
+          virtual uint8_t       getCoupledConf( CONFcouple **couples);
+
+
+ }     ;
+static FILTER_PARAM mosaicParam={4,{"hz","vz","shrink","show"}};
+
+BUILD_CREATE(mosaic_create,ADMVideoMosaic);
+SCRIPT_CREATE(mosaic_script,ADMVideoMosaic,mosaicParam);
+
+
+
+uint8_t ADMVideoMosaic::configure(AVDMGenericVideoStream * instream)
+{
+    UNUSED_ARG(instream);
+
+#define PX(x) &(_param->x)
+        
+    diaElemUInteger   hz(PX(hz),_("Horizontal Stacking"),0,10);
+    diaElemUInteger   vz(PX(vz),_("Vertical Stacking"),0,10);
+    diaElemUInteger   shrink(PX(shrink),_("Shrink Factor"),0,10);
+    diaElemToggle     show(PX(show),_("Show frame"));
+    
+    
+       diaElem *elems[]={&hz,&vz,&shrink,&show};
+  
+   if(  diaFactoryRun("Mosaic",sizeof(elems)/sizeof(diaElem *),elems))
+   {
+        reset();
+        return 1;
+    }
+    return 0;
+
+}
+
+//
+//  
+//
+uint8_t ADMVideoMosaic::clean(void)
+{
+                if(_context)
+                {
+                        sws_freeContext(_context);
+                }
+                _context=NULL;
+                if(_uncompressed) delete _uncompressed;
+                _uncompressed=NULL;
+                if(vidCache) delete vidCache;
+                vidCache=NULL;
+                return 1;
+}
+
+uint8_t ADMVideoMosaic::reset(void)
+{
+SwsFilter                  *srcFilter=NULL;
+SwsFilter                  *dstFilter=NULL;
+int                       flags=0;
+
+                clean();
+                flags=SWS_BICUBIC;
+
+
+#if (defined( ARCH_X86)  || defined(ARCH_X86_64))
+                
+                #define ADD(x,y) if( CpuCaps::has##x()) flags|=SWS_CPU_CAPS_##y;
+                ADD(MMX,MMX);           
+                ADD(3DNOW,3DNOW);
+                ADD(MMXEXT,MMX2);
+#endif  
+        
+        
+
+        memcpy(&_info,_in->getInfo(),sizeof(_info));
+       
+
+      
+
+        tinyW=_info.width;
+        tinyH=_info.height;
+        
+        tinyW/=_param->shrink;
+        tinyH/=_param->shrink;
+
+        if(tinyW&1) tinyW++;
+        if(tinyH&1) tinyH++;
+        
+
+        _info.width=tinyW*_param->hz;
+        _info.height=tinyH*_param->vz;
+
+
+        _uncompressed=new ADMImage(_info.width,_info.height);
+        vidCache=new VideoCache(_param->vz*_param->hz*2,_in);
+        //_info.nb_frames=_info.nb_frames/(_param->vz*_param->hz);
+
+  _context=sws_getContext(
+                        _in->getInfo()->width,_in->getInfo()->height,
+                        PIX_FMT_YUV420P,
+                        tinyW,
+                        tinyH,
+                        PIX_FMT_YUV420P,
+                        flags, srcFilter, dstFilter,NULL);
+
+        if(!_context) return 0;
+        return 1;
+
+
+}
+char *ADMVideoMosaic::printConf( void )
+{
+        static char buf[50];
+
+        sprintf((char *)buf," Mosaic : %d hz, %d vz, %d shrink factor",
+                                _in->getInfo()->width,
+                                _param->hz,_param->vz,_param->shrink);
+        return buf;
+}
+//_______________________________________________________________
+ADMVideoMosaic::ADMVideoMosaic(
+                                                                        AVDMGenericVideoStream *in,CONFcouple *couples)
+{
+
+        _in=in;
+        memcpy(&_info,_in->getInfo(),sizeof(_info));
+        _param=NEW(MOSAIC_PARAMS);
+
+        if(couples)
+        {
+
+                GET(hz);
+                GET(vz);
+                GET(shrink);
+                GET(show);
+        
+        }
+        else
+        {
+                _param->hz=3;
+                _param->vz =3;
+                _param->shrink = 3;
+                _param->show=1;
+        }
+
+        _context=NULL;
+       vidCache=NULL;
+
+        reset();
+        _info.encoding=1;
+
+}
+
+
+uint8_t ADMVideoMosaic::getCoupledConf( CONFcouple **couples)
+{
+
+                        ADM_assert(_param);
+                        *couples=new CONFcouple(4);
+
+#define CSET(x)  (*couples)->setCouple((char *)#x,(_param->x))
+        CSET(hz);
+        CSET(vz);
+        CSET(shrink);
+        CSET(show);
+                        return 1;
+
+}
+// ___ destructor_____________
+ADMVideoMosaic::~ADMVideoMosaic()
+{
+        clean();
+        DELETE(_param);
+
+}
+
+//
+//      Basically ask a uncompressed frame from editor and ask
+//              GUI to decompress it .
+//
+
+uint8_t ADMVideoMosaic::getFrameNumberNoAlloc(uint32_t frame,
+                                uint32_t *len,
+                                ADMImage *data,
+                                uint32_t *flags)
+{
+                        if(frame>=_info.nb_frames) 
+                        {
+                                printf("Filter : out of bound!\n");
+                                return 0;
+                        }
+        
+                        ADM_assert(_param);
+
+ADMImage *curImage;
+char txt[256];
+
+                        for(int y=0;y<_param->vz;y++)
+                          for(int x=0;x<_param->hz;x++)
+                        {
+                          curImage=vidCache->getImage(frame+y*_param->hz+x);
+                          if(!curImage) continue;
+
+                          if(_param->show)
+                          {
+                                sprintf(txt," %02d",frame+x+y*_param->hz);
+                                drawString(curImage,2,0,txt);
+                          }
+
+                          
+                          uint8_t *src[3];
+                          uint8_t *dst[3];
+                          int ssrc[3];
+                          int ddst[3];
+
+                          uint32_t page;
+
+                          page=_in->getInfo()->width*_in->getInfo()->height;
+                          src[0]=YPLANE(curImage);
+                          src[1]=UPLANE(curImage);
+                          src[2]=VPLANE(curImage);
+
+                          ssrc[0]=_in->getInfo()->width;
+                          ssrc[1]=ssrc[2]=_in->getInfo()->width>>1;
+
+                          page=_info.width*tinyH;
+                          
+                          dst[0]=YPLANE(data)+page*y+tinyW*x;
+                          dst[1]=UPLANE(data)+((page*y)/4)+((tinyW*x)/2);
+                          dst[2]=VPLANE(data)+((page*y)/4)+((tinyW*x)/2);
+                          ddst[0]=_info.width;
+                          ddst[1]=ddst[2]=_info.width>>1;
+
+                          sws_scale(_context,src,ssrc,0,_in->getInfo()->height,dst,ddst);
+                        }
+                        vidCache->unlockAll();
+        return 1;
+}
+

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMosaic_param.h (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMosaic_param.h)

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am	2007-01-12 19:00:30 UTC (rev 2711)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am	2007-01-12 19:23:19 UTC (rev 2712)
@@ -7,6 +7,9 @@
 #INCLUDES = $(all_includes) 
 
 libADM_videoFilter_a_SOURCES =  \
+ ADM_vidMosaic.cpp \
+ ADM_vidBlendRemoval.cpp  \
+ ADM_vidHardIvtcRemoval.cpp \
  ADM_vidDGbob.cpp \
  ADM_vidForcedPP.cpp \
  ADM_vidMSharpen.cpp \



From mean at mail.berlios.de  Sat Jan 13 11:49:02 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 13 Jan 2007 11:49:02 +0100
Subject: [Avidemux-svn-commit] r2713 -
	branches/avidemux_2.4_branch/avidemux/ADM_video
Message-ID: <200701131049.l0DAn2HU020078@sheep.berlios.de>

Author: mean
Date: 2007-01-13 11:49:01 +0100 (Sat, 13 Jan 2007)
New Revision: 2713

Removed:
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_guiCrop.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_separateField.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidChangeFPS.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidChangeFPS.h
Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidCrop.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am
Log:
cleanup

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_guiCrop.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_guiCrop.cpp	2007-01-12 19:23:19 UTC (rev 2712)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_guiCrop.cpp	2007-01-13 10:49:01 UTC (rev 2713)
@@ -1,58 +0,0 @@
-/***************************************************************************
-                          ADM_guiCrop.cpp  -  description
-                             -------------------
-    begin                : Sun Mar 24 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include "config.h"
- 
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
-
-#include <time.h>
-#include <sys/time.h>
-
-#include <ADM_assert.h>
-
-#include "fourcc.h"
-#include "avio.hxx"
-#include "config.h"
-#include "avi_vars.h"
-#ifdef HAVE_ENCODER
-
-
-#include "ADM_editor/ADM_edit.hxx"
-#include "ADM_video/ADM_genvideo.hxx"
-#include "ADM_video/ADM_vidCommonFilter.h"
-
-#include "ADM_colorspace/colorspace.h"
-extern int DIA_getCropParams(	char *name,CROP_PARAMS *param,AVDMGenericVideoStream *in);
-uint8_t AVDMVideoStreamCrop::configure( AVDMGenericVideoStream *instream)
-
-{
-		uint8_t r;
-		uint32_t w,h;
-    	if(r = (DIA_getCropParams("Crop Settings",_param,instream )))
-    	{
-			w=_param->left+_param->right;
-			h=_param->top+_param->bottom;
-			ADM_assert(w<instream->getInfo()->width);
-			ADM_assert(h<instream->getInfo()->height);
-			_info.width=instream->getInfo()->width-w;
-			_info.height=instream->getInfo()->height-h;
-		}
-		return r;
-}
-#endif

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_separateField.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_separateField.cpp	2007-01-12 19:23:19 UTC (rev 2712)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_separateField.cpp	2007-01-13 10:49:01 UTC (rev 2713)
@@ -1,3 +0,0 @@
-/*
-
-*/
\ No newline at end of file

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidChangeFPS.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidChangeFPS.cpp	2007-01-12 19:23:19 UTC (rev 2712)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidChangeFPS.cpp	2007-01-13 10:49:01 UTC (rev 2713)
@@ -1,212 +0,0 @@
-/***************************************************************************
-                          ADM_vidChangeFPS.h  -  description
-                             -------------------
-    begin                : Sat Jan 22 2005
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <math.h>
-#include <ADM_assert.h>
-
-#include "config.h"
-#include "fourcc.h"
-#include "avio.hxx"
-#include "config.h"
-#include "avi_vars.h"
-#ifdef HAVE_ENCODER
-
-
-#include "ADM_toolkit/toolkit.hxx"
-#include "DIA_enter.h"
-#include "ADM_editor/ADM_edit.hxx"
-#include "ADM_video/ADM_genvideo.hxx"
-#include "ADM_video/ADM_vidChangeFPS.h"
-#include "ADM_filter/video_filters.h"
-
-
-static FILTER_PARAM chfpsParam={2,{"newfps","precision"}};
-
-SCRIPT_CREATE(chfps_script,ADMVideoChangeFPS,chfpsParam);
-BUILD_CREATE(chfps_create,ADMVideoChangeFPS);
-
-void dump_frames_array(uint32_t* frames_array) {
-	printf("dump_frames_array: %d frames\n", frames_array[0]);
-	for(uint32_t i=0; i<frames_array[0];i++) {
-		//printf("dump_frames_array: frame %d correspond to old frame %d\n", i, frames_array[i+1]);
-	}
-}
-
-ADMVideoChangeFPS::ADMVideoChangeFPS(AVDMGenericVideoStream* in, CONFcouple* couples) {
-	frames_array = NULL;
-	
-	_in = in;
-	memcpy(&_info, _in->getInfo(), sizeof(_info));
-	
-	if(couples) {
-		printf("ChangeFPS (Construct): have new config, rebuilding frames_array\n");
-		
-		_param=NEW(CHFPS_PARAMS);
-		
-		GET(newfps);
-		GET(precision);
-		
-		buildFramesArray();
-		
-		_info.fps1000  = _param->newfps;
-		_info.nb_frames = frames_array[0];
-		
-		dump_frames_array(frames_array);
-	}
-	else {
-		printf("ChangeFPS (Construct): no couples, building default frames_array\n");
-		
-		_param=NEW(CHFPS_PARAMS);
-		
-		_param->newfps    = _in->getInfo()->fps1000;
-		_param->precision = 1000;
-		
-		frames_array = new uint32_t[_in->getInfo()->nb_frames+1];
-		
-		uint32_t i;
-		
-		for(i=0; i < _in->getInfo()->nb_frames; i++) {
-			frames_array[i+1] = i;
-		}
-		
-		frames_array[0] = i;
-		
-		dump_frames_array(frames_array);
-	}
-	
-	_info.encoding = 1;
-	_uncompressed  = new ADMImage(_in->getInfo()->width, _in->getInfo()->height);
-	
-	ADM_assert(_uncompressed);    	  	
-}
-
-ADMVideoChangeFPS::~ADMVideoChangeFPS() {
-	delete _uncompressed;
-	DELETE(_param);
-	_uncompressed = NULL;
-	if(frames_array != NULL) {
-		delete [] frames_array;
-                frames_array=NULL;
-	}
-}
-
-uint8_t ADMVideoChangeFPS::getFrameNumberNoAlloc(uint32_t frame, uint32_t* len, ADMImage* data, uint32_t* flags) 
-{
-	if(frame>=_info.nb_frames) return 0;
-	//printf("ChangeFPS (getFrame): %d->%d\n", frame, frames_array[frame+1]);
-	return _in->getFrameNumberNoAlloc(frames_array[frame+1],len,data,flags);
-}
-
-uint8_t ADMVideoChangeFPS::configure(AVDMGenericVideoStream* instream) {
-	UNUSED_ARG(instream);
-	
-	int prec = (int)log10((double)_param->precision);
-	
-	float newfps=(float)_param->newfps/1000.;
-	
-	memcpy(&_info,_in->getInfo(),sizeof(_info));
-	
-	GUI_getIntegerValue(&prec, 1, 8, "Precision");
-	DIA_GetFloatValue(&newfps, 1., (float)_info.fps1000/500., "New FPS", "New FPS");
-	
-	_param->newfps    =(uint32_t)floor( (float)newfps*1000.); 
-	_param->precision = (uint32_t)floor(pow(10, prec));
-	
-	printf("ChangeFPS (configure): have new config, rebuilding frames_array\n");
-	
-	buildFramesArray();
-	
-	_info.fps1000  = _param->newfps;
-	_info.nb_frames = frames_array[0];
-	
-	dump_frames_array(frames_array);
-	
-	return 1;
-}
-
-uint8_t	ADMVideoChangeFPS::getCoupledConf( CONFcouple **couples) {
-	ADM_assert(_param);
-	*couples = new CONFcouple(2);
-	
-	CSET(newfps);
-	CSET(precision);
-	
-	return 1;
-}
-
-char* ADMVideoChangeFPS::printConf() {
- 	static char buf[50];
- 	sprintf(buf," Change FPS %ffps->%ffps", (float)_in->getInfo()->fps1000/1000., (float)_param->newfps/1000.);
-        return buf;
-}
-
-void ADMVideoChangeFPS::buildFramesArray() {
-	uint32_t i, cur_frame, new_frames, ratio, d_fps;
-	uint32_t old_fps, new_fps, precision, frames;
-	bool change_frame;
-	
-	if(frames_array != NULL) {
-		delete [] frames_array;
-	}
-	
-	frames    = _in->getInfo()->nb_frames;
-	old_fps   = _in->getInfo()->fps1000;
-	new_fps   = _param->newfps;
-	precision = _param->precision;
-	
-	printf("ChangeFPS (buildFramesArray): olp fps=%d, new fps=%d, frames=%d, precision=%d\n", old_fps, new_fps, frames, precision);
-	
-	if(new_fps < old_fps) {
-		frames_array = new uint32_t[frames+1];
-	}
-	else {
-		frames_array = new uint32_t[frames*2+1];
-	}
-	
-	new_frames = 0;
-	d_fps      = (new_fps > old_fps) ? new_fps - old_fps: old_fps - new_fps;
-	ratio      = (uint32_t)(double)((double)old_fps*(double)precision/(double)d_fps);
-	
-	change_frame = false;
-	
-	for(cur_frame=0; cur_frame < frames; cur_frame++) {
-		for(i=cur_frame*precision; i < (cur_frame+1)*precision; i++) {
-			if((i%ratio) == 0) {
-				change_frame = true;
-				break;
-			}
-		}
-		
-		if(new_fps < old_fps) {
-			if(!change_frame) {
-				frames_array[++new_frames] = cur_frame;
-			}
-		}
-		else {
-			frames_array[++new_frames] = cur_frame;
-			if(change_frame) {
-				frames_array[++new_frames] = cur_frame;
-			}
-		}
-		
-		change_frame = false;
-	}
-	
-	frames_array[0] = new_frames;
-}
-#endif

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidChangeFPS.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidChangeFPS.h	2007-01-12 19:23:19 UTC (rev 2712)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidChangeFPS.h	2007-01-13 10:49:01 UTC (rev 2713)
@@ -1,34 +0,0 @@
-/***************************************************************************
-                          ADM_vidChangeFPS.h  -  description
-                             -------------------
-    begin                : Sat Jan 22 2005
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifndef _CHANGEFPS_H
-#define _CHANGEFPS_H
-
-class  ADMVideoChangeFPS:public AVDMGenericVideoStream {
-public:
-	ADMVideoChangeFPS(AVDMGenericVideoStream* in, CONFcouple* couples);
-	virtual ~ADMVideoChangeFPS();
-	virtual uint8_t getFrameNumberNoAlloc(uint32_t frame, uint32_t* len, ADMImage* data, uint32_t* flags);
-	virtual uint8_t configure(AVDMGenericVideoStream* instream);
-	virtual uint8_t getCoupledConf(CONFcouple **couples)		;
-
-protected:
-	AVDMGenericVideoStream* _in;
-	virtual char* printConf();
-	virtual void buildFramesArray();
-	
-	CHFPS_PARAMS *_param;
-	uint32_t* frames_array;
-};
-#endif

Modified: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidCrop.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidCrop.cpp	2007-01-12 19:23:19 UTC (rev 2712)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidCrop.cpp	2007-01-13 10:49:01 UTC (rev 2713)
@@ -186,4 +186,21 @@
 			return 1;
 
 }
+extern int DIA_getCropParams(	char *name,CROP_PARAMS *param,AVDMGenericVideoStream *in);
+uint8_t AVDMVideoStreamCrop::configure( AVDMGenericVideoStream *instream)
+
+{
+		uint8_t r;
+		uint32_t w,h;
+    	if(r = (DIA_getCropParams("Crop Settings",_param,instream )))
+    	{
+			w=_param->left+_param->right;
+			h=_param->top+_param->bottom;
+			ADM_assert(w<instream->getInfo()->width);
+			ADM_assert(h<instream->getInfo()->height);
+			_info.width=instream->getInfo()->width-w;
+			_info.height=instream->getInfo()->height-h;
+		}
+		return r;
+}
 #endif

Modified: branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am	2007-01-12 19:23:19 UTC (rev 2712)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am	2007-01-13 10:49:01 UTC (rev 2713)
@@ -63,7 +63,6 @@
  ADM_vidEqualizer.cpp \
  ADM_vidVobsub.cpp \
  ADM_vobsubinfo.cpp \
- ADM_vidChangeFPS.cpp \
  ADM_vidVobSubRender.cpp \
  ADM_vidHue.cpp \
  ADM_vidEq2.cpp \
@@ -73,7 +72,6 @@
  ADM_vidUnblend.cpp \
  ADM_vidTdeint.cpp \
  ADM_vidMPdelogo.cpp \
- ADM_guiCrop.cpp \
  ADM_vidColorYuv.cpp  \
  ADM_guiResize.cpp \
  ADM_vidAnimated.cpp \
@@ -91,7 +89,7 @@
 ADM_genvideo.hxx ADM_vidDeinterlace.cpp  ADM_vidPartial.cpp \
 ADM_vidDeinterlace.h  ADM_vidPartial.h \
 ADM_vidDelta.cpp  ADM_vidPartial_param.h \
-ADM_guiCrop.cpp    ADM_vidPulldown.cpp \
+ADM_vidPulldown.cpp \
  ADM_vidPulldown.h \
 ADM_guiResize.cpp  ADM_vidDropOut.cpp  ADM_vidRaw.cpp \
 ADM_interlaced.cpp ADM_vidDropOut.h  \
@@ -103,7 +101,7 @@
 ADM_resizebis.cpp   ADM_vidSRT.cpp \
 ADM_resizebis.hxx    ADM_vidSRT.h \
 ADM_resizeter.cpp  ADM_vidField.h  ADM_vidSRTRender.cpp \
-ADM_separateField.cpp  ADM_vidFieldUnblend.cpp ADM_vidSRTload.cpp \
+ADM_vidFieldUnblend.cpp ADM_vidSRTload.cpp \
 ADM_vidASharp_param.h  ADM_vidFieldUtil.cpp  ADM_vidSalt.cpp \
 ADM_vidFieldUtil.h  ADM_vidSalt.h \
 ADM_vidFields.cpp ADM_vidSeparateField.cpp \
@@ -119,8 +117,8 @@
 ADM_vidCNR2_param.h  ADM_vidHue.cpp  ADM_vidTDeint_param.h \
 ADM_vidCached.cpp  ADM_vidHue.h  ADM_vidTdeint.cpp \
 ADM_vidCached.h  ADM_vidIVTC.cpp ADM_vidTelecide.cpp \
-ADM_vidChangeFPS.cpp ADM_vidIVTC.h ADM_vidTelecide.h \
-ADM_vidChangeFPS.h ADM_vidTempSmooth.cpp \
+ADM_vidIVTC.h ADM_vidTelecide.h \
+ADM_vidTempSmooth.cpp \
 ADM_vidChroma.cpp  ADM_vidTempSmooth.h \
 ADM_vidChroma.h  ADM_vidLargeMedian.cpp  ADM_vidUVSwap.cpp \
 ADM_vidChromaShift.cpp ADM_vidLargeMedian.h  ADM_vidUVSwap.h \



From mean at mail.berlios.de  Sat Jan 13 12:10:27 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 13 Jan 2007 12:10:27 +0100
Subject: [Avidemux-svn-commit] r2714 - in
	branches/avidemux_2.4_branch/avidemux:
	ADM_userInterfaces/ADM_GTK ADM_video ADM_videoFilter
Message-ID: <200701131110.l0DBARNJ021436@sheep.berlios.de>

Author: mean
Date: 2007-01-13 12:10:25 +0100 (Sat, 13 Jan 2007)
New Revision: 2714

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidChroma.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidChroma.h
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidConvolution.hxx
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidFlipV.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidFlipV.h
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidLargeMedian.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidLargeMedian.h
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidLuma.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidLuma.h
Removed:
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidChroma.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidChroma.h
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidConvolution.hxx
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFlipV.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFlipV.h
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidLargeMedian.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidLargeMedian.h
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidLuma.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidLuma.h
Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/adm_ocr.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_genvideo.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidEq2.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidHue.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidVobSubRender.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidVobsub.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidFastConvolution.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidResampleFPS.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am
Log:
cleanup

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/adm_ocr.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/adm_ocr.cpp	2007-01-13 10:49:01 UTC (rev 2713)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/adm_ocr.cpp	2007-01-13 11:10:25 UTC (rev 2714)
@@ -50,13 +50,11 @@
 #include "../ADM_GTK/ADM_toolkit_gtk/toolkit_gtk_include.h"
 #include "ADM_editor/ADM_edit.hxx"
 #include "ADM_video/ADM_genvideo.hxx"
-#include "ADM_video/ADM_vidFlipV.h"
 #include "ADM_filter/video_filters.h"
 
 #include "ADM_toolkit/toolkit.hxx"
 #include "ADM_editor/ADM_edit.hxx"
 #include "ADM_video/ADM_genvideo.hxx"
-#include "ADM_video/ADM_vidFlipV.h"
 #include "ADM_filter/video_filters.h"
 
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_genvideo.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_genvideo.cpp	2007-01-13 10:49:01 UTC (rev 2713)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_genvideo.cpp	2007-01-13 11:10:25 UTC (rev 2714)
@@ -35,7 +35,6 @@
 #include "ADM_editor/ADM_edit.hxx"
 #include "ADM_video/ADM_genvideo.hxx"
 
-#include"ADM_video/ADM_vidConvolution.hxx"
 #include"ADM_video/ADM_vidCommonFilter.h"
 uint8_t AVDMGenericVideoStream::getPixel(int32_t x,int32_t y,uint8_t *data)
 {

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidChroma.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidChroma.cpp	2007-01-13 10:49:01 UTC (rev 2713)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidChroma.cpp	2007-01-13 11:10:25 UTC (rev 2714)
@@ -1,202 +0,0 @@
-/***************************************************************************
-                          ADM_vidChroma.cpp  -  description
-                             -------------------
-    begin                : Wed Aug 28 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <ADM_assert.h>
-
-#include "config.h"
-#include "fourcc.h"
-#include "avio.hxx"
-#include "config.h"
-#include "avi_vars.h"
-
-
-#include "ADM_toolkit/toolkit.hxx"
-#include "ADM_editor/ADM_edit.hxx"
-#include "ADM_video/ADM_genvideo.hxx"
-#include "ADM_video/ADM_vidChroma.h"
-#include "ADM_filter/video_filters.h"
-
-
-static FILTER_PARAM nullParam={0,{""}};
-
-
-SCRIPT_CREATE(chromaU_script,ADMVideoChromaU,nullParam);
-SCRIPT_CREATE(chromaV_script,ADMVideoChromaV,nullParam);
-
-BUILD_CREATE(chromaU_create,ADMVideoChromaU);
-BUILD_CREATE(chromaV_create,ADMVideoChromaV);
-
-
-char *ADMVideoChromaU::printConf( void )
-{
- 	static char buf[50];
- 	
- 	sprintf((char *)buf," chroma u only");
-        return buf;
-}
-
-//_______________________________________________________________
-
-ADMVideoChromaU::ADMVideoChromaU(
-									AVDMGenericVideoStream *in,CONFcouple *setup)
-{
-    UNUSED_ARG(setup);
-
-	_in=in;		
-	memcpy(&_info,_in->getInfo(),sizeof(_info));  			 	
-	_info.encoding=1;
-	
-  	  	
-}
-ADMVideoChromaU::~ADMVideoChromaU()
-{
- 	
-	
- 	
-}
-
-//
-//	Remove y and v just keep U and expand it
-//
-   uint8_t ADMVideoChromaU::getFrameNumberNoAlloc(uint32_t frame,
-				uint32_t *len,
-   				ADMImage *data,
-				uint32_t *flags)
-{				
-uint32_t w,x;
-uint32_t page;
-		ADM_assert(frame<_info.nb_frames);
-       		if(!_in->getFrameNumberNoAlloc(frame, len,data,flags)) return 0;
-		
-		page= _info.width*_info.height;
-		*len=(page*3)>>1;
-
-
-		// now expand  u
-		uint8_t *y,*v,*y2;
-
-		y=YPLANE(data);
-		y2=y+_info.width;
-		v=UPLANE(data);
-		for(w= _info.height>>1;w>0;w--)
-		{
-			for(x= _info.width>>1;x>0;x--)
-			{
-				*y=*v;
-				*y2=*v;
-				*(y+1)=*v;
-				*(y2+1)=*v;
-				v++;
-				y+=2;
-				y2+=2;
-			}
-                	y+=_info.width;
-			y2+=_info.width;
-       		 }
-
-		 // Remove chroma u & v
-		 memset(UPLANE(data),0x80,page>>2);
-		 memset(VPLANE(data),0x80,page>>2);
-}
-
-//---______________________________________________---------v--------------
-//---______________________________________________---------v--------------
-//---______________________________________________---------v--------------
-//---______________________________________________---------v--------------
-//---______________________________________________---------v--------------
-//---______________________________________________---------v--------------
-//---______________________________________________---------v--------------
-//---______________________________________________---------v--------------
-
-
-
-
-char *ADMVideoChromaV::printConf( void )
-{
- 	static char buf[50];
-
- 	sprintf((char *)buf," chroma v only");
-        return buf;
-}
-
-//_______________________________________________________________
-
-ADMVideoChromaV::ADMVideoChromaV(
-									AVDMGenericVideoStream *in,CONFcouple *setup)
-{
-    UNUSED_ARG(setup);
-
-	_in=in;
-	memcpy(&_info,_in->getInfo(),sizeof(_info));
-	_info.encoding=1;
- 
-
-}
-ADMVideoChromaV::~ADMVideoChromaV()
-{
-
-	
-
-}
-
-//
-//	Remove y and v just keep U and expand it
-//
-   uint8_t ADMVideoChromaV::getFrameNumberNoAlloc(uint32_t frame,
-				uint32_t *len,
-   				ADMImage *data,
-				uint32_t *flags)
-{
-uint32_t w,x;
-uint32_t page;
-		ADM_assert(frame<_info.nb_frames);
-       		if(!_in->getFrameNumberNoAlloc(frame, len,data,flags)) return 0;
-		
-		page= _info.width*_info.height;
-		*len=(page*3)>>1;
-
-
-		// now expand  u
-		uint8_t *y,*v,*y2;
-
-		y=YPLANE(data);
-		y2=y+_info.width;
-		v=VPLANE(data);
-		for(w= _info.height>>1;w>0;w--)
-		{
-			for(x= _info.width>>1;x>0;x--)
-			{
-				*y=*v;
-				*y2=*v;
-				*(y+1)=*v;
-				*(y2+1)=*v;
-				v++;
-				y+=2;
-				y2+=2;
-			}
-                	y+=_info.width;
-			y2+=_info.width;
-       		 }
-
-		 // Remove chroma u & v
-		 memset(UPLANE(data),0x80,page>>2);
-		 memset(VPLANE(data),0x80,page>>2);
-}
-

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidChroma.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidChroma.h	2007-01-13 10:49:01 UTC (rev 2713)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidChroma.h	2007-01-13 11:10:25 UTC (rev 2714)
@@ -1,59 +0,0 @@
-/***************************************************************************
-                          ADM_vidChroma.h  -  description
-                             -------------------
-    begin                : Wed Aug 28 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#ifndef CHROMA_
-#define CHROMA_
-
- class  ADMVideoChromaU:public AVDMGenericVideoStream
- {
-
- protected:
-
-
-           virtual char 									*printConf(void);
-			
-			
-
- public:
- 		
-  					ADMVideoChromaU(  AVDMGenericVideoStream *in,CONFcouple *setup);  	          							
-  					virtual ~ADMVideoChromaU();
-		          virtual uint8_t getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-			  		ADMImage *data,uint32_t *flags);
-				uint8_t configure( AVDMGenericVideoStream *instream) { UNUSED_ARG(instream); return 1;}
-							
- }     ;
-
- class  ADMVideoChromaV:public AVDMGenericVideoStream
- {
-
- protected:
-
-
-           virtual char 									*printConf(void);
-			uint8_t											_reverse;
-
- public:
- 		
-  					ADMVideoChromaV(  AVDMGenericVideoStream *in,CONFcouple *setup);
-  					virtual ~ADMVideoChromaV();
-		          virtual uint8_t getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,											ADMImage *data,uint32_t *flags);
-					uint8_t configure( AVDMGenericVideoStream *instream) { UNUSED_ARG(instream); return 1;}
-							
- }     ;
-
-#endif

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidConvolution.hxx
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidConvolution.hxx	2007-01-13 10:49:01 UTC (rev 2713)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidConvolution.hxx	2007-01-13 11:10:25 UTC (rev 2714)
@@ -1,178 +0,0 @@
-/***************************************************************************
-                          ADM_vidConvolution.hxx  -  description
-                             -------------------
-    begin                : Wed Apr 10 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
- #ifndef __CONVPARAM__
- #define __CONVPARAM__
- typedef struct CONV_PARAM
- {
-        uint32_t luma;
-        uint32_t chroma;
-  }CONV_PARAM;
- #endif
-class  AVDMVideoConvolution:public AVDMGenericVideoStream
- {
-
- protected:
-
-                 uint8_t		*_U,*_V;
-    virtual	 uint8_t       		convolutionKernel(int32_t x,int32_t y,uint8_t *out)=0;
-           	virtual char 		*printConf(void);
-
- public:
-
-
-                                      AVDMVideoConvolution(  AVDMGenericVideoStream *in,CONFcouple *setup);
-
-                virtual               ~AVDMVideoConvolution();
-                virtual uint8_t       getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-                                                                        ADMImage *data,uint32_t *flags);
-                virtual uint8_t       configure( AVDMGenericVideoStream *instream) { UNUSED_ARG(instream); return 0;};
-
- }     ;
-
-
-   class  AVDMVideoSharpen:public AVDMVideoConvolution
- {
-   protected:
-                    uint8_t  convolutionKernel(int32_t x,int32_t y,uint8_t *data);
- public:
-            virtual char *printConf(void);
-                          AVDMVideoSharpen(  AVDMGenericVideoStream *in,CONFcouple *setup)
-                                          : AVDMVideoConvolution( 	in,setup) {};;
- }     ;
-   class  AVDMVideoMean:public AVDMVideoConvolution
- {
-   protected:
-                    uint8_t  convolutionKernel(int32_t x,int32_t y,uint8_t *data);
- public:
-            virtual char *printConf(void);
-                    AVDMVideoMean(  AVDMGenericVideoStream *in,CONFcouple *setup)
-                      : AVDMVideoConvolution( in,setup) {};
-
- };
- 
-  class  AVDMVideoMedian:public AVDMVideoConvolution
- {
-   protected:
-                    uint8_t  convolutionKernel(int32_t x,int32_t y,uint8_t *data);
- 	public:
-            virtual char *printConf(void);
-                          AVDMVideoMedian(  AVDMGenericVideoStream *in,CONFcouple *setup)
-                                  : AVDMVideoConvolution( 	in,setup) {};
-
- }     ;
-
-  class  AVDMVideoGaussian:public AVDMVideoConvolution
- {
-   protected:
-                    uint8_t  convolutionKernel(int32_t x,int32_t y,uint8_t *data);
- 	public:
-            virtual char *printConf(void);
-                          AVDMVideoGaussian(  AVDMGenericVideoStream *in,CONFcouple *setup)
-                                        : AVDMVideoConvolution( 	in,setup) {};
- }     ;
-//---------------------------------------------------------
- class  AVDMFastVideoConvolution:public AVDMGenericVideoStream
- {
-
- protected:
-
-	virtual uint8_t doLine(uint8_t *pred, uint8_t *cur, uint8_t *next, uint8_t *out, uint32_t w)
-                      { UNUSED_ARG(pred); UNUSED_ARG(cur); UNUSED_ARG(next); UNUSED_ARG(out); UNUSED_ARG(w); return 0;}
-        
-                CONV_PARAM	*_param;
- public:
-#warning FIXME: string constants cannot be used as char
-                      virtual char     *printConf(void) { return const_cast<char*>("ERROR");};
-
-                                         AVDMFastVideoConvolution(  AVDMGenericVideoStream *in,CONFcouple *setup);
-                      virtual           ~AVDMFastVideoConvolution();
-                      virtual uint8_t   getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-                                                      ADMImage *data,uint32_t *flags);
-                      virtual uint8_t	configure( AVDMGenericVideoStream *instream) ;
-
-                      virtual uint8_t	getCoupledConf( CONFcouple **couples);
-}     ;
-
- class    AVDMFastVideoMean: public AVDMFastVideoConvolution
- {
-        protected:
-            virtual uint8_t doLine(uint8_t  *pred,
-                                  uint8_t *cur,
-                                  uint8_t *next,
-                                  uint8_t *out,
-                                  uint32_t w)   ;
-
-        public:
-
-                              AVDMFastVideoMean(  AVDMGenericVideoStream *in,CONFcouple *setup) :
-                              AVDMFastVideoConvolution(  in,setup) {};
-              virtual char 	*printConf(void);
-
-	}      ;
-
-
-   class    AVDMFastVideoGauss: public AVDMFastVideoConvolution
- {
-    protected:
-              virtual uint8_t 		doLine(uint8_t  *pred,
-                                              uint8_t *cur,
-                                              uint8_t *next,
-                                              uint8_t *out,
-                                              uint32_t w)   ;
-  
-		public:
-
-                                    AVDMFastVideoGauss(  AVDMGenericVideoStream *in,CONFcouple *setup) :
-                                    AVDMFastVideoConvolution(  in,setup) {};
-                    virtual char	*printConf(void);
-
-	}      ;
-     class    AVDMFastVideoSharpen: public AVDMFastVideoConvolution
- {
-        protected:
-            virtual uint8_t 		doLine(uint8_t  *pred,
-                                                uint8_t *cur,
-                                                uint8_t *next,
-                                                uint8_t *out,
-                                                uint32_t w)   ;
-
-          public:
-
-                                      AVDMFastVideoSharpen(  AVDMGenericVideoStream *in,CONFcouple *setup) :
-                                      AVDMFastVideoConvolution(  in,setup) {};
-                              virtual char 		*printConf(void);	
-                      
-  }      ;
-
-  class    AVDMFastVideoMedian: public AVDMFastVideoConvolution
- {
-        protected:
-          virtual uint8_t 	doLine(uint8_t  *pred,
-                                        uint8_t *cur,
-                                        uint8_t *next,
-                                        uint8_t *out,
-                                        uint32_t w)   ;
-
-        public:
-
-                                AVDMFastVideoMedian(  AVDMGenericVideoStream *in,CONFcouple *setup) :
-                                AVDMFastVideoConvolution(  in,setup) {};
-                  virtual char 	*printConf(void);
- }      ;
-
-//EOF
-

Modified: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidEq2.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidEq2.cpp	2007-01-13 10:49:01 UTC (rev 2713)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidEq2.cpp	2007-01-13 11:10:25 UTC (rev 2714)
@@ -35,7 +35,6 @@
 #include "ADM_toolkit/toolkit.hxx"
 #include "ADM_editor/ADM_edit.hxx"
 #include "ADM_video/ADM_genvideo.hxx"
-#include "ADM_video/ADM_vidFlipV.h"
 #include "ADM_filter/video_filters.h"
 #include "DIA_enter.h"
 #include "ADM_video/ADM_cache.h"

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFlipV.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFlipV.cpp	2007-01-13 10:49:01 UTC (rev 2713)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFlipV.cpp	2007-01-13 11:10:25 UTC (rev 2714)
@@ -1,125 +0,0 @@
-/***************************************************************************
-                          ADM_vidFlipV.cpp  -  description
-                             -------------------
-    begin                : Wed Nov 6 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
- #include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <ADM_assert.h>
-
-#include "config.h"
-#include "fourcc.h"
-#include "avio.hxx"
-#include "config.h"
-#include "avi_vars.h"
-#ifdef HAVE_ENCODER
-
-
-#include "ADM_toolkit/toolkit.hxx"
-#include "ADM_editor/ADM_edit.hxx"
-#include "ADM_video/ADM_genvideo.hxx"
-#include "ADM_video/ADM_vidFlipV.h"
-#include "ADM_filter/video_filters.h"
-
-
-static FILTER_PARAM flipParam={0,{""}};
-
-
-SCRIPT_CREATE(flipv_script,ADMVideoFlipV,flipParam);
-BUILD_CREATE(flipv_create,ADMVideoFlipV);
- 
-
-char *ADMVideoFlipV::printConf( void )
-{
- 	static char buf[50];
- 	
- 	sprintf((char *)buf," V-Flip");
-        return buf;
-}
-
-ADMVideoFlipV::ADMVideoFlipV(  AVDMGenericVideoStream *in,CONFcouple *setup)
-{
-    UNUSED_ARG(setup);
- 	_in=in;		
-   	memcpy(&_info,_in->getInfo(),sizeof(_info)); 	
-  	_info.encoding=1;	
-	_uncompressed=new ADMImage(_in->getInfo()->width,_in->getInfo()->height);
-	ADM_assert(_uncompressed);    	  	
-}
-ADMVideoFlipV::~ADMVideoFlipV()
-{
- 	delete  _uncompressed;	
-	_uncompressed=NULL;
-  
-}
-uint8_t ADMVideoFlipV::getFrameNumberNoAlloc(uint32_t frame,
-				uint32_t *len,
-   				ADMImage *data,
-				uint32_t *flags)
-{
-
-	ADM_assert(frame<_info.nb_frames);
-	// read uncompressed frame
-	if(!_in->getFrameNumberNoAlloc(frame, len,_uncompressed,flags)) return 0;
-
-         uint8_t *in,*out;
-         uint32_t stride=_info.width;
-         uint32_t h=_info.height;
-         uint32_t page,qpage;
-        
-
-	  
-         page=stride*h;
-         qpage=page>>2;
-         
-         in=YPLANE(_uncompressed);
-         out=YPLANE(data)+(h-1)*stride;
-         // flip y
-         for(uint32_t y=h;y>0;y--)
-         {
-		 memcpy(out,in,stride);
-		 in+=stride;
-		 out-=stride;
-	}
-	// Flip U & V			         
-        stride>>=1;
-	in=UPLANE(_uncompressed);	
-        out=UPLANE(data)+qpage-stride;
-         // flip u
-         for(uint32_t y=h>>1;y>0;y--)
-         {
-		 memcpy(out,in,stride);
-		 in+=stride;
-		 out-=stride;
-	}
-	in=VPLANE(_uncompressed);
-        out=VPLANE(data)+qpage-stride;
-       
-      
-         // flip u
-         for(uint32_t y=h>>1;y>0;y--)
-         {
-		 memcpy(out,in,stride);
-		 in+=stride;
-		 out-=stride;
-	}   
-	data->copyInfo(_uncompressed);
-	return 1;
-}
-
-
-
-#endif

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFlipV.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFlipV.h	2007-01-13 10:49:01 UTC (rev 2713)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFlipV.h	2007-01-13 11:10:25 UTC (rev 2714)
@@ -1,37 +0,0 @@
-/***************************************************************************
-                          ADM_vidFlipV.h  -  description
-                             -------------------
-    begin                : Wed Nov 6 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifndef FLIP__
-#define FLIP__
-
- class  ADMVideoFlipV:public AVDMGenericVideoStream
- {
-
- protected:
-    		AVDMGenericVideoStream 	*_in;    	
-           virtual char 									*printConf(void);
-          
- public:
- 		
-  					ADMVideoFlipV(  AVDMGenericVideoStream *in,CONFcouple *setup);
-  					virtual ~ADMVideoFlipV();
-		          virtual uint8_t getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-          																	ADMImage *data,uint32_t *flags);
-					virtual uint8_t configure( AVDMGenericVideoStream *instream) { UNUSED_ARG(instream); return 1;};          																	
-
-
- }     ;
-#endif

Modified: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidHue.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidHue.cpp	2007-01-13 10:49:01 UTC (rev 2713)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidHue.cpp	2007-01-13 11:10:25 UTC (rev 2714)
@@ -30,7 +30,6 @@
 #include "ADM_toolkit/toolkit.hxx"
 #include "ADM_editor/ADM_edit.hxx"
 #include "ADM_video/ADM_genvideo.hxx"
-#include "ADM_video/ADM_vidFlipV.h"
 #include "ADM_filter/video_filters.h"
 #include "DIA_enter.h"
 #include "ADM_video/ADM_cache.h"

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidLargeMedian.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidLargeMedian.cpp	2007-01-13 10:49:01 UTC (rev 2713)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidLargeMedian.cpp	2007-01-13 11:10:25 UTC (rev 2714)
@@ -1,311 +0,0 @@
-/***************************************************************************
-                          ADM_vidLargeMedian.cpp  -  description
-                             -------------------
-    begin                : Wed Jan 1 2003
-    copyright            : (C) 2003 by mean
-    email                : fixounet at free.fr
-    
-    Using http://ndevilla.free.fr/median/median/node20.html
-    optimized median search
-    
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <ADM_assert.h>
-
-#include "config.h"
-#include "fourcc.h"
-#include "avio.hxx"
-#include "config.h"
-#include "avi_vars.h"
-#ifdef HAVE_ENCODER
-
-
-#include "ADM_toolkit/toolkit.hxx"
-#include "ADM_editor/ADM_edit.hxx"
-#include "ADM_video/ADM_genvideo.hxx"
-
-#include"ADM_video/ADM_vidLargeMedian.h"
-#include "ADM_filter/video_filters.h"
-
-
-static FILTER_PARAM nullParam={2,{"chroma","luma"}};
-
-
-SCRIPT_CREATE(largeMedian_script,ADMVideoLargeMedian,nullParam);
-BUILD_CREATE(largeMedian_create,ADMVideoLargeMedian);
-
-//_______________________________________________________________
-
-ADMVideoLargeMedian::ADMVideoLargeMedian(
-									AVDMGenericVideoStream *in,CONFcouple *couples)
-{
-
-
-	_in=in;		
-	memcpy(&_info,_in->getInfo(),sizeof(_info));  		
-	_uncompressed=new ADMImage(_in->getInfo()->width,_in->getInfo()->height);
-	ADM_assert(_uncompressed);
-	_info.encoding=1;
-	if(couples==NULL)
-	{
-		_param=NEW( CONV_PARAM);
-		_param->chroma=1;
-		_param->luma=1;
-		printf("\n Creating from null\n");
-	}
-	else
-	{
-			_param=NEW(CONV_PARAM);
-			GET(luma);
-			GET(chroma);
-	}
-
-
-}
-
-uint8_t	ADMVideoLargeMedian::getCoupledConf( CONFcouple **couples)
-{
-
-			ADM_assert(_param);
-			*couples=new CONFcouple(2);
-
-#define CSET(x)  (*couples)->setCouple((char *)#x,(_param->x))
-			CSET(luma);
-			CSET(chroma);
-			return 1;
-
-}
-ADMVideoLargeMedian::~ADMVideoLargeMedian()
-{
-	if(_uncompressed)
- 		delete _uncompressed;
-	_uncompressed=NULL;
-	DELETE(_param);
-}
-char *ADMVideoLargeMedian::printConf(void)
-{
- 		return (char *)"Median (5x5)";; // this one is pure
-}
-//
-//	Basically ask a uncompressed frame from editor and ask
-//		GUI to decompress it .
-//
-
-uint8_t ADMVideoLargeMedian::getFrameNumberNoAlloc(uint32_t frame,
-				uint32_t *len,
-   				ADMImage *data,
-				uint32_t *flags)
-{
-//uint8_t *dst,*dstu,*dstv,*srcu,*srcv;
-uint8_t *x1,*x2,*x3,*x4,*x5,*o1;
-uint32_t stride,page;
-
-	ADM_assert(frame<_info.nb_frames);
-	ADM_assert(_uncompressed);					
-	stride=_info.width;
-	page=(stride*_info.height)>>2;
-																
-	// read uncompressed frame
-	if(!_in->getFrameNumberNoAlloc(frame, len,_uncompressed,flags)) return 0;               
-         
-	if(!_param->luma)
-	{
-		memcpy(YPLANE(data),YPLANE(_uncompressed),page*4);						
-	}
-	else
-	{
-		memcpy(YPLANE(data),YPLANE(_uncompressed),stride*2);
-		memcpy(YPLANE(data)+page*4-stride*2,YPLANE(_uncompressed)+page*4-2*stride,2*stride);          
-	         
-		o1=YPLANE(data)+stride*2;;
-		x1=YPLANE(_uncompressed);
-		x2=x1+stride;
-		x3=x2+stride;
-		x4=x3+stride;
-		x5=x4+stride;
-		// Luma
-		for(int32_t y=2;y<(int32_t)(_info.height)-2;y++)
-		{
-			doLine(x1,x2,x3,x4,x5,o1,stride);
-			x1=x2;
-			x2=x3;
-			x3=x4;
-			x4=x5;
-			x5+=stride; 
-			o1+=stride;                 
-		}
-	}
-					
-      	
-	stride>>=1;
-	if(!_param->chroma)
-	{
-	 	memcpy(UPLANE(data),UPLANE(_uncompressed),page*2);			
-	}	
-	else
-	{
-		// first and last line
-		memcpy(UPLANE(data),UPLANE(_uncompressed),stride*2);
-		memcpy(UPLANE(data)+page-stride*2,UPLANE(_uncompressed)+page-2*stride,2*stride);
-		// chroma u	
-		o1=UPLANE(data)+stride*2;
-		x1=UPLANE(_uncompressed);
-		x2=x1+stride;
-		x3=x2+stride;
-		x4=x3+stride;
-		x5=x4+stride;
-	          
-		for(int32_t y=2;y<(int32_t)(_info.height>>1)-2;y++)
-		{
-			doLine(x1,x2,x3,x4,x5,o1,stride);
-			x1=x2;
-			x2=x3;
-			x3=x4;
-			x4=x5;
-			x5+=stride; 
-			o1+=stride;                 
-		}
-		// chroma V
-		// first and last line
-		memcpy(VPLANE(data),VPLANE(_uncompressed),stride*2);
-		memcpy(VPLANE(data)+page-2*stride,VPLANE(_uncompressed)+page-2*stride,2*stride);          
-	          
-		o1=VPLANE(data)+stride*2;
-		x1=VPLANE(_uncompressed);
-		x2=x1+stride;
-		x3=x2+stride;
-		x4=x3+stride;
-		x5=x4+stride;
-
-	         
-		for(int32_t y=2;y<(int32_t)(_info.height>>1)-2;y++)
-		{
-			doLine(x1,x2,x3,x4,x5,o1,stride);
-			x1=x2;
-			x2=x3;
-			x3=x4;
-			x4=x5;
-			x5+=stride; 
-			o1+=stride;                      
-	      	}
-	}
-	data->copyInfo(_uncompressed);
-	return 1;
-}
-//________________________________________________________________________
-uint8_t ADMVideoLargeMedian::doLine(uint8_t  *pred2,uint8_t  *pred1,
-					uint8_t *cur,
-   					uint8_t *next1,uint8_t *next2,
-   					uint8_t *out,
-                       			uint32_t w)
-                                 
-{
-static uint8_t box[5][5];	
-static uint8_t box2[5][5];	
-
-uint32_t col;
-uint8_t temp;
-uint32_t inbox;
-	
-// prefill box
-	for(uint32_t x=0;x<4;x++)
-		{
-			box[0][x+1]=*(pred2+x);
-			box[1][x+1]=*(pred1+x);
-			box[2][x+1]=*(cur+x);
-			box[3][x+1]=*(next1+x);
-			box[4][x+1]=*(next2+x);			
-		}
-		col=0;
-		*out=*cur;
-		*(out+1)=*(cur+1);
-		*(out+w-1)=*(cur+w-1);		
-		*(out+w-2)=*(cur+w-2);
-		out+=2;
-		next1+=4;
-		next2+=4;
-		pred1+=4;
-		pred2+=4;
-		cur+=4;	
-	while(w>4)
-	{
-		// fill
-			box[0][col]=*pred2++;
-			box[1][col]=*pred1++;
-			box[2][col]=*cur++;
-			box[3][col]=*next1++;
-			box[4][col]=*next2++;
-			col++;
-			col%=5;
-			// copy & sort
-			memcpy(box2,box,5*5);
-			uint8_t *p=(uint8_t *)box2;	
-			inbox=0;	
-#define PIX_SORT(a,b) { if ((a)>(b)) PIX_SWAP((a),(b)); }
-#define PIX_SWAP(a,b) { temp=(a);(a)=(b);(b)=temp; }
-
-			
-    PIX_SORT(p[0], p[1]) ;   PIX_SORT(p[3], p[4]) ;   PIX_SORT(p[2], p[4]) ;
-    PIX_SORT(p[2], p[3]) ;   PIX_SORT(p[6], p[7]) ;   PIX_SORT(p[5], p[7]) ;
-    PIX_SORT(p[5], p[6]) ;   PIX_SORT(p[9], p[10]) ;  PIX_SORT(p[8], p[10]) ;
-    PIX_SORT(p[8], p[9]) ;   PIX_SORT(p[12], p[13]) ; PIX_SORT(p[11], p[13]) ;
-    PIX_SORT(p[11], p[12]) ; PIX_SORT(p[15], p[16]) ; PIX_SORT(p[14], p[16]) ;
-    PIX_SORT(p[14], p[15]) ; PIX_SORT(p[18], p[19]) ; PIX_SORT(p[17], p[19]) ;
-    PIX_SORT(p[17], p[18]) ; PIX_SORT(p[21], p[22]) ; PIX_SORT(p[20], p[22]) ;
-    PIX_SORT(p[20], p[21]) ; PIX_SORT(p[23], p[24]) ; PIX_SORT(p[2], p[5]) ;
-    PIX_SORT(p[3], p[6]) ;   PIX_SORT(p[0], p[6]) ;   PIX_SORT(p[0], p[3]) ;
-    PIX_SORT(p[4], p[7]) ;   PIX_SORT(p[1], p[7]) ;   PIX_SORT(p[1], p[4]) ;
-    PIX_SORT(p[11], p[14]) ; PIX_SORT(p[8], p[14]) ;  PIX_SORT(p[8], p[11]) ;
-    PIX_SORT(p[12], p[15]) ; PIX_SORT(p[9], p[15]) ;  PIX_SORT(p[9], p[12]) ;
-    PIX_SORT(p[13], p[16]) ; PIX_SORT(p[10], p[16]) ; PIX_SORT(p[10], p[13]) ;
-    PIX_SORT(p[20], p[23]) ; PIX_SORT(p[17], p[23]) ; PIX_SORT(p[17], p[20]) ;
-    PIX_SORT(p[21], p[24]) ; PIX_SORT(p[18], p[24]) ; PIX_SORT(p[18], p[21]) ;
-    PIX_SORT(p[19], p[22]) ; PIX_SORT(p[8], p[17]) ;  PIX_SORT(p[9], p[18]) ;
-    PIX_SORT(p[0], p[18]) ;  PIX_SORT(p[0], p[9]) ;   PIX_SORT(p[10], p[19]) ;
-    PIX_SORT(p[1], p[19]) ;  PIX_SORT(p[1], p[10]) ;  PIX_SORT(p[11], p[20]) ;
-    PIX_SORT(p[2], p[20]) ;  PIX_SORT(p[2], p[11]) ;  PIX_SORT(p[12], p[21]) ;
-    PIX_SORT(p[3], p[21]) ;  PIX_SORT(p[3], p[12]) ;  PIX_SORT(p[13], p[22]) ;
-    PIX_SORT(p[4], p[22]) ;  PIX_SORT(p[4], p[13]) ;  PIX_SORT(p[14], p[23]) ;
-    PIX_SORT(p[5], p[23]) ;  PIX_SORT(p[5], p[14]) ;  PIX_SORT(p[15], p[24]) ;
-    PIX_SORT(p[6], p[24]) ;  PIX_SORT(p[6], p[15]) ;  PIX_SORT(p[7], p[16]) ;
-    PIX_SORT(p[7], p[19]) ;  PIX_SORT(p[13], p[21]) ; PIX_SORT(p[15], p[23]) ;
-    PIX_SORT(p[7], p[13]) ;  PIX_SORT(p[7], p[15]) ;  PIX_SORT(p[1], p[9]) ;
-    PIX_SORT(p[3], p[11]) ;  PIX_SORT(p[5], p[17]) ;  PIX_SORT(p[11], p[17]) ;
-    PIX_SORT(p[9], p[17]) ;  PIX_SORT(p[4], p[10]) ;  PIX_SORT(p[6], p[12]) ;
-    PIX_SORT(p[7], p[14]) ;  PIX_SORT(p[4], p[6]) ;   PIX_SORT(p[4], p[7]) ;
-    PIX_SORT(p[12], p[14]) ; PIX_SORT(p[10], p[14]) ; PIX_SORT(p[6], p[7]) ;
-    PIX_SORT(p[10], p[12]) ; PIX_SORT(p[6], p[10]) ;  PIX_SORT(p[6], p[17]) ;
-    PIX_SORT(p[12], p[17]) ; PIX_SORT(p[7], p[17]) ;  PIX_SORT(p[7], p[10]) ;
-    PIX_SORT(p[12], p[18]) ; PIX_SORT(p[7], p[12]) ;  PIX_SORT(p[10], p[18]) ;
-    PIX_SORT(p[12], p[20]) ; PIX_SORT(p[10], p[20]) ; PIX_SORT(p[10], p[12]) ;
-			
-		  
-		  *out++=p[12];
-		  w--;
-	}	
-	
-	return 1;
-}
-
-uint8_t ADMVideoLargeMedian::configure(AVDMGenericVideoStream * instream)
-{
-  return 1; 
-}
-
-
-
-#endif
-
-

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidLargeMedian.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidLargeMedian.h	2007-01-13 10:49:01 UTC (rev 2713)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidLargeMedian.h	2007-01-13 11:10:25 UTC (rev 2714)
@@ -1,53 +0,0 @@
-/***************************************************************************
-                          ADM_vidLargeMedian.h  -  description
-                             -------------------
-    begin                : Wed Jan 1 2003
-    copyright            : (C) 2003 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
- #ifndef  __CONVPARAM__
- #define __CONVPARAM__
- typedef struct CONV_PARAM
- {
-	 	uint32_t luma;
-	  	uint32_t chroma;
-	}CONV_PARAM;
- #endif
-class  ADMVideoLargeMedian:public AVDMGenericVideoStream
- {
-
- protected:
-    		AVDMGenericVideoStream 	*_in;
-    		//uint8_t					*_uncompressed;
-	virtual uint8_t 					doLine(uint8_t  *pred2,
-										uint8_t *pred1,
-   										uint8_t *cur,
-                                          					uint8_t *next1,
-                                           					uint8_t *next2,
-   										uint8_t *out,
-                       								uint32_t w)    ;
-        	CONV_PARAM				*_param;
- public:
- 		        virtual char 	*printConf(void) ;
-  						
-  						ADMVideoLargeMedian(  AVDMGenericVideoStream *in,CONFcouple *setup);
-
-  			virtual 		~ADMVideoLargeMedian();
-		        virtual uint8_t 	getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-									ADMImage *data,uint32_t *flags);
-			virtual uint8_t 	configure( AVDMGenericVideoStream *instream) ;
-			virtual uint8_t 	getCoupledConf( CONFcouple **couples);
-
- }     ;
-
-
-

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidLuma.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidLuma.cpp	2007-01-13 10:49:01 UTC (rev 2713)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidLuma.cpp	2007-01-13 11:10:25 UTC (rev 2714)
@@ -1,98 +0,0 @@
-/***************************************************************************
-                          ADM_vidLuma.cpp  -  description
-                             -------------------
-    begin                : Sat Aug 24 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
- #include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <ADM_assert.h>
-
-#include "config.h"
-#include "fourcc.h"
-#include "avio.hxx"
-#include "config.h"
-#include "avi_vars.h"
-#ifdef HAVE_ENCODER
-
-
-#include "ADM_toolkit/toolkit.hxx"
-#include "ADM_editor/ADM_edit.hxx"
-#include "ADM_video/ADM_genvideo.hxx"
-#include "ADM_video/ADM_vidLuma.h"
-#include "ADM_filter/video_filters.h"
-
-
-static FILTER_PARAM nullParam={0,{""}};
-
-
-SCRIPT_CREATE(luma_script,ADMVideoLuma,nullParam);
-BUILD_CREATE(luma_create,ADMVideoLuma);
-
- 
-
-char *ADMVideoLuma::printConf( void )
-{
- 	static char buf[50];
- 	
- 	sprintf((char *)buf," Luma only");
-        return buf;
-}
-
-ADMVideoLuma::ADMVideoLuma(  AVDMGenericVideoStream *in,CONFcouple *setup)
-{
-
- 	_in=in;		
-   	memcpy(&_info,_in->getInfo(),sizeof(_info));  		
-	
-		if(setup)
-		{
-			 _param=(void *)setup;
-		}	
-			else 			
-		{	// default parameter	
-				_param= NULL;
-		}				
-					 	
-  _info.encoding=1;
-
-  	  	
-}
-ADMVideoLuma::~ADMVideoLuma()
-{
- 	
-}
-uint8_t ADMVideoLuma::getFrameNumberNoAlloc(uint32_t frame,
-				uint32_t *len,
-   				ADMImage *data,
-				uint32_t *flags)
-{
-
-	ADM_assert(frame<_info.nb_frames);
-	// read uncompressed frame
-	if(!_in->getFrameNumberNoAlloc(frame, len,data,flags)) return 0;
-
-	uint32_t sz;
-			
-	sz=_info.width*_info.height;
-	memset(UPLANE(data),128,sz>>2);
-	memset(VPLANE(data),128,sz>>2);
-
-      return 1;
-}
-
-
-
-#endif

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidLuma.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidLuma.h	2007-01-13 10:49:01 UTC (rev 2713)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidLuma.h	2007-01-13 11:10:25 UTC (rev 2714)
@@ -1,38 +0,0 @@
-/***************************************************************************
-                          ADM_vidLuma.h  -  description
-                             -------------------
-    begin                : Sat Aug 24 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#ifndef LUMA__
-#define LUMA__
-
- class  ADMVideoLuma:public AVDMGenericVideoStream
- {
-
- protected:
-
-           virtual char 									*printConf(void);
-			void													*_param;
-
- public:
- 		
-  					ADMVideoLuma(  AVDMGenericVideoStream *in,CONFcouple *setup);
-  					virtual ~ADMVideoLuma();
-		          virtual uint8_t getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-          					ADMImage *data,uint32_t *flags);
-					virtual uint8_t configure( AVDMGenericVideoStream *instream) { UNUSED_ARG(instream); return 1;};          																	
-							
- }     ;
-#endif

Modified: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidVobSubRender.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidVobSubRender.cpp	2007-01-13 10:49:01 UTC (rev 2713)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidVobSubRender.cpp	2007-01-13 11:10:25 UTC (rev 2714)
@@ -61,7 +61,6 @@
 #include "ADM_toolkit/toolkit.hxx"
 #include "ADM_editor/ADM_edit.hxx"
 #include "ADM_video/ADM_genvideo.hxx"
-#include "ADM_video/ADM_vidFlipV.h"
 #include "ADM_filter/video_filters.h"
 
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidVobsub.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidVobsub.cpp	2007-01-13 10:49:01 UTC (rev 2713)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidVobsub.cpp	2007-01-13 11:10:25 UTC (rev 2714)
@@ -37,7 +37,6 @@
 #include "ADM_toolkit/toolkit.hxx"
 #include "ADM_editor/ADM_edit.hxx"
 #include "ADM_video/ADM_genvideo.hxx"
-#include "ADM_video/ADM_vidFlipV.h"
 #include "ADM_filter/video_filters.h"
 
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am	2007-01-13 10:49:01 UTC (rev 2713)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am	2007-01-13 11:10:25 UTC (rev 2714)
@@ -9,20 +9,16 @@
 libADM_video_a_SOURCES = ADM_vidFields.cpp \
  ADM_vidDeintASM.cpp \
  ADM_vidVlad.cpp \
- ADM_vidLargeMedian.cpp \
  ADM_vidSalt.cpp \
  ADM_vidCached.cpp \
  ADM_vidPartial.cpp \
  ADM_vidFont.cpp \
  ADM_vidSRT.cpp \
-	ADM_vidFlipV.cpp \
  ADM_vidStabilize.cpp \
  ADM_vidContrast.cpp \
 	ADM_resizeter.cpp \
- ADM_vidConvolution.cpp \
  ADM_vidCrop.cpp \
  ADM_vidDeinterlace.cpp \
-	ADM_vidLuma.cpp \
  ADM_vidNull.cpp \
  ADM_vidPalShift.cpp \
 	ADM_vidResize.cpp \
@@ -30,7 +26,6 @@
  ADM_vidTempSmooth.cpp \
  ADM_vidUVSwap.cpp \
 	ADM_vidClean.cpp \
- ADM_vidChroma.cpp \
 	ADM_resizebis.cpp \
  ADM_genvideo.cpp \
  ADM_vidRotate.cpp \
@@ -105,8 +100,8 @@
 ADM_vidASharp_param.h  ADM_vidFieldUtil.cpp  ADM_vidSalt.cpp \
 ADM_vidFieldUtil.h  ADM_vidSalt.h \
 ADM_vidFields.cpp ADM_vidSeparateField.cpp \
-ADM_vidAnimated.cpp  ADM_vidFlipV.cpp  ADM_vidSeparateField.h \
-ADM_vidAnimated.h  ADM_vidFlipV.h  \
+ADM_vidAnimated.cpp  ADM_vidSeparateField.h \
+ADM_vidAnimated.h  \
 ADM_vidAnimated_param.h   \
 ADM_vidAsharp.cpp   ADM_vidStabilize.cpp \
 ADM_vidFont.cpp ADM_vidStabilize.h \
@@ -119,11 +114,11 @@
 ADM_vidCached.h  ADM_vidIVTC.cpp ADM_vidTelecide.cpp \
 ADM_vidIVTC.h ADM_vidTelecide.h \
 ADM_vidTempSmooth.cpp \
-ADM_vidChroma.cpp  ADM_vidTempSmooth.h \
-ADM_vidChroma.h  ADM_vidLargeMedian.cpp  ADM_vidUVSwap.cpp \
-ADM_vidChromaShift.cpp ADM_vidLargeMedian.h  ADM_vidUVSwap.h \
-ADM_vidChromaShift.h ADM_vidLuma.cpp ADM_vidUnblend.cpp \
-ADM_vidClean.cpp ADM_vidLuma.h ADM_vidUnblend_param.h \
+ADM_vidTempSmooth.h \
+ADM_vidUVSwap.cpp \
+ADM_vidChromaShift.cpp ADM_vidUVSwap.h \
+ADM_vidChromaShift.h ADM_vidUnblend.cpp \
+ADM_vidClean.cpp ADM_vidUnblend_param.h \
 ADM_vidClean.h ADM_vidVlad.cpp \
 ADM_vidColorYuv.cpp  ADM_vidVlad.h \
 ADM_vidColorYuv.h  ADM_vidVobSub.h \
@@ -131,8 +126,8 @@
 ADM_vidCommonFilter.h  ADM_vidMPLResize.cpp  ADM_vidVobsub.cpp \
 ADM_vidContrast.cpp  ADM_vidMPdelogo.cpp ADM_vidWirl.cpp \
 ADM_vidContrast.h  ADM_vidMPdelogo.h ADM_vidlavdeint.cpp \
-ADM_vidConvolution.cpp  ADM_vidlavdeint.h \
-ADM_vidConvolution.hxx  ADM_vobsubinfo.cpp \
+ADM_vidlavdeint.h \
+ADM_vobsubinfo.cpp \
 ADM_vidCrop.cpp  ADM_vidMSmooth_param.h  ADM_vobsubinfo.h \
 ASM_vidDenoise.cpp \
 ADM_vidDecDec.cpp  swscale_internal.h \

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidChroma.cpp (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidChroma.cpp)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidChroma.cpp	2006-10-31 15:59:58 UTC (rev 2489)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidChroma.cpp	2007-01-13 11:10:25 UTC (rev 2714)
@@ -0,0 +1,202 @@
+/***************************************************************************
+                          ADM_vidChroma.cpp  -  description
+                             -------------------
+    begin                : Wed Aug 28 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ADM_assert.h>
+
+#include "config.h"
+#include "fourcc.h"
+#include "avio.hxx"
+#include "config.h"
+#include "avi_vars.h"
+
+
+#include "ADM_toolkit/toolkit.hxx"
+#include "ADM_editor/ADM_edit.hxx"
+#include "ADM_video/ADM_genvideo.hxx"
+#include "ADM_vidChroma.h"
+#include "ADM_filter/video_filters.h"
+
+
+static FILTER_PARAM nullParam={0,{""}};
+
+
+SCRIPT_CREATE(chromaU_script,ADMVideoChromaU,nullParam);
+SCRIPT_CREATE(chromaV_script,ADMVideoChromaV,nullParam);
+
+BUILD_CREATE(chromaU_create,ADMVideoChromaU);
+BUILD_CREATE(chromaV_create,ADMVideoChromaV);
+
+
+char *ADMVideoChromaU::printConf( void )
+{
+ 	static char buf[50];
+ 	
+ 	sprintf((char *)buf," chroma u only");
+        return buf;
+}
+
+//_______________________________________________________________
+
+ADMVideoChromaU::ADMVideoChromaU(
+									AVDMGenericVideoStream *in,CONFcouple *setup)
+{
+    UNUSED_ARG(setup);
+
+	_in=in;		
+	memcpy(&_info,_in->getInfo(),sizeof(_info));  			 	
+	_info.encoding=1;
+	
+  	  	
+}
+ADMVideoChromaU::~ADMVideoChromaU()
+{
+ 	
+	
+ 	
+}
+
+//
+//	Remove y and v just keep U and expand it
+//
+   uint8_t ADMVideoChromaU::getFrameNumberNoAlloc(uint32_t frame,
+				uint32_t *len,
+   				ADMImage *data,
+				uint32_t *flags)
+{				
+uint32_t w,x;
+uint32_t page;
+		ADM_assert(frame<_info.nb_frames);
+       		if(!_in->getFrameNumberNoAlloc(frame, len,data,flags)) return 0;
+		
+		page= _info.width*_info.height;
+		*len=(page*3)>>1;
+
+
+		// now expand  u
+		uint8_t *y,*v,*y2;
+
+		y=YPLANE(data);
+		y2=y+_info.width;
+		v=UPLANE(data);
+		for(w= _info.height>>1;w>0;w--)
+		{
+			for(x= _info.width>>1;x>0;x--)
+			{
+				*y=*v;
+				*y2=*v;
+				*(y+1)=*v;
+				*(y2+1)=*v;
+				v++;
+				y+=2;
+				y2+=2;
+			}
+                	y+=_info.width;
+			y2+=_info.width;
+       		 }
+
+		 // Remove chroma u & v
+		 memset(UPLANE(data),0x80,page>>2);
+		 memset(VPLANE(data),0x80,page>>2);
+}
+
+//---______________________________________________---------v--------------
+//---______________________________________________---------v--------------
+//---______________________________________________---------v--------------
+//---______________________________________________---------v--------------
+//---______________________________________________---------v--------------
+//---______________________________________________---------v--------------
+//---______________________________________________---------v--------------
+//---______________________________________________---------v--------------
+
+
+
+
+char *ADMVideoChromaV::printConf( void )
+{
+ 	static char buf[50];
+
+ 	sprintf((char *)buf," chroma v only");
+        return buf;
+}
+
+//_______________________________________________________________
+
+ADMVideoChromaV::ADMVideoChromaV(
+									AVDMGenericVideoStream *in,CONFcouple *setup)
+{
+    UNUSED_ARG(setup);
+
+	_in=in;
+	memcpy(&_info,_in->getInfo(),sizeof(_info));
+	_info.encoding=1;
+ 
+
+}
+ADMVideoChromaV::~ADMVideoChromaV()
+{
+
+	
+
+}
+
+//
+//	Remove y and v just keep U and expand it
+//
+   uint8_t ADMVideoChromaV::getFrameNumberNoAlloc(uint32_t frame,
+				uint32_t *len,
+   				ADMImage *data,
+				uint32_t *flags)
+{
+uint32_t w,x;
+uint32_t page;
+		ADM_assert(frame<_info.nb_frames);
+       		if(!_in->getFrameNumberNoAlloc(frame, len,data,flags)) return 0;
+		
+		page= _info.width*_info.height;
+		*len=(page*3)>>1;
+
+
+		// now expand  u
+		uint8_t *y,*v,*y2;
+
+		y=YPLANE(data);
+		y2=y+_info.width;
+		v=VPLANE(data);
+		for(w= _info.height>>1;w>0;w--)
+		{
+			for(x= _info.width>>1;x>0;x--)
+			{
+				*y=*v;
+				*y2=*v;
+				*(y+1)=*v;
+				*(y2+1)=*v;
+				v++;
+				y+=2;
+				y2+=2;
+			}
+                	y+=_info.width;
+			y2+=_info.width;
+       		 }
+
+		 // Remove chroma u & v
+		 memset(UPLANE(data),0x80,page>>2);
+		 memset(VPLANE(data),0x80,page>>2);
+}
+

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidChroma.h (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidChroma.h)

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidConvolution.hxx (from rev 2555, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidConvolution.hxx)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidConvolution.hxx	2006-11-11 14:10:10 UTC (rev 2555)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidConvolution.hxx	2007-01-13 11:10:25 UTC (rev 2714)
@@ -0,0 +1,117 @@
+/***************************************************************************
+                          ADM_vidConvolution.hxx  -  description
+                             -------------------
+    begin                : Wed Apr 10 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+ #ifndef __CONVPARAM__
+ #define __CONVPARAM__
+ typedef struct CONV_PARAM
+ {
+        uint32_t luma;
+        uint32_t chroma;
+  }CONV_PARAM;
+ #endif
+
+//---------------------------------------------------------
+ class  AVDMFastVideoConvolution:public AVDMGenericVideoStream
+ {
+
+ protected:
+
+	virtual uint8_t doLine(uint8_t *pred, uint8_t *cur, uint8_t *next, uint8_t *out, uint32_t w)
+                      { UNUSED_ARG(pred); UNUSED_ARG(cur); UNUSED_ARG(next); UNUSED_ARG(out); UNUSED_ARG(w); return 0;}
+        
+                CONV_PARAM	*_param;
+ public:
+#warning FIXME: string constants cannot be used as char
+                      virtual char     *printConf(void) { return const_cast<char*>("ERROR");};
+
+                                         AVDMFastVideoConvolution(  AVDMGenericVideoStream *in,CONFcouple *setup);
+                      virtual           ~AVDMFastVideoConvolution();
+                      virtual uint8_t   getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
+                                                      ADMImage *data,uint32_t *flags);
+                      virtual uint8_t	configure( AVDMGenericVideoStream *instream) ;
+
+                      virtual uint8_t	getCoupledConf( CONFcouple **couples);
+}     ;
+
+ class    AVDMFastVideoMean: public AVDMFastVideoConvolution
+ {
+        protected:
+            virtual uint8_t doLine(uint8_t  *pred,
+                                  uint8_t *cur,
+                                  uint8_t *next,
+                                  uint8_t *out,
+                                  uint32_t w)   ;
+
+        public:
+
+                              AVDMFastVideoMean(  AVDMGenericVideoStream *in,CONFcouple *setup) :
+                              AVDMFastVideoConvolution(  in,setup) {};
+              virtual char 	*printConf(void);
+
+	}      ;
+
+
+   class    AVDMFastVideoGauss: public AVDMFastVideoConvolution
+ {
+    protected:
+              virtual uint8_t 		doLine(uint8_t  *pred,
+                                              uint8_t *cur,
+                                              uint8_t *next,
+                                              uint8_t *out,
+                                              uint32_t w)   ;
+  
+		public:
+
+                                    AVDMFastVideoGauss(  AVDMGenericVideoStream *in,CONFcouple *setup) :
+                                    AVDMFastVideoConvolution(  in,setup) {};
+                    virtual char	*printConf(void);
+
+	}      ;
+     class    AVDMFastVideoSharpen: public AVDMFastVideoConvolution
+ {
+        protected:
+            virtual uint8_t 		doLine(uint8_t  *pred,
+                                                uint8_t *cur,
+                                                uint8_t *next,
+                                                uint8_t *out,
+                                                uint32_t w)   ;
+
+          public:
+
+                                      AVDMFastVideoSharpen(  AVDMGenericVideoStream *in,CONFcouple *setup) :
+                                      AVDMFastVideoConvolution(  in,setup) {};
+                              virtual char 		*printConf(void);	
+                      
+  }      ;
+
+  class    AVDMFastVideoMedian: public AVDMFastVideoConvolution
+ {
+        protected:
+          virtual uint8_t 	doLine(uint8_t  *pred,
+                                        uint8_t *cur,
+                                        uint8_t *next,
+                                        uint8_t *out,
+                                        uint32_t w)   ;
+
+        public:
+
+                                AVDMFastVideoMedian(  AVDMGenericVideoStream *in,CONFcouple *setup) :
+                                AVDMFastVideoConvolution(  in,setup) {};
+                  virtual char 	*printConf(void);
+ }      ;
+
+//EOF
+

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidFastConvolution.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidFastConvolution.cpp	2007-01-13 10:49:01 UTC (rev 2713)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidFastConvolution.cpp	2007-01-13 11:10:25 UTC (rev 2714)
@@ -24,18 +24,27 @@
 #include "ADM_toolkit/toolkit.hxx"
 #include "ADM_editor/ADM_edit.hxx"
 #include "ADM_video/ADM_genvideo.hxx"
+#include "ADM_video/ADM_genvideo.hxx"
 
-#include"ADM_video/ADM_vidConvolution.hxx"
+#include"ADM_filter/video_filters.h"
 #include "ADM_userInterfaces/ADM_commonUI/DIA_factory.h"
+#include "ADM_vidConvolution.hxx"
 #include <ADM_assert.h>
 
 
 BUILD_CREATE(mean_create,AVDMFastVideoMean);
 BUILD_CREATE(sharpen_create,AVDMFastVideoSharpen);
 BUILD_CREATE(Gaussian_create,AVDMFastVideoGauss);
+BUILD_CREATE(median_create,AVDMFastVideoMedian);
 
+static FILTER_PARAM convParam={2,{"luma","chroma"}};
 
+SCRIPT_CREATE(mean_script,AVDMFastVideoMean,convParam);
+SCRIPT_CREATE(sharpen_script,AVDMFastVideoSharpen,convParam);
+SCRIPT_CREATE(gaussian_script,AVDMFastVideoGauss,convParam);
+SCRIPT_CREATE(median_script,AVDMFastVideoMedian,convParam);
 
+
 uint8_t	AVDMFastVideoConvolution::getCoupledConf( CONFcouple **couples)
 {
 

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidFlipV.cpp (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFlipV.cpp)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFlipV.cpp	2006-10-31 15:59:58 UTC (rev 2489)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidFlipV.cpp	2007-01-13 11:10:25 UTC (rev 2714)
@@ -0,0 +1,125 @@
+/***************************************************************************
+                          ADM_vidFlipV.cpp  -  description
+                             -------------------
+    begin                : Wed Nov 6 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+ #include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ADM_assert.h>
+
+#include "config.h"
+#include "fourcc.h"
+#include "avio.hxx"
+#include "config.h"
+#include "avi_vars.h"
+#ifdef HAVE_ENCODER
+
+
+#include "ADM_toolkit/toolkit.hxx"
+#include "ADM_editor/ADM_edit.hxx"
+#include "ADM_video/ADM_genvideo.hxx"
+#include "ADM_vidFlipV.h"
+#include "ADM_filter/video_filters.h"
+
+
+static FILTER_PARAM flipParam={0,{""}};
+
+
+SCRIPT_CREATE(flipv_script,ADMVideoFlipV,flipParam);
+BUILD_CREATE(flipv_create,ADMVideoFlipV);
+ 
+
+char *ADMVideoFlipV::printConf( void )
+{
+ 	static char buf[50];
+ 	
+ 	sprintf((char *)buf," V-Flip");
+        return buf;
+}
+
+ADMVideoFlipV::ADMVideoFlipV(  AVDMGenericVideoStream *in,CONFcouple *setup)
+{
+    UNUSED_ARG(setup);
+ 	_in=in;		
+   	memcpy(&_info,_in->getInfo(),sizeof(_info)); 	
+  	_info.encoding=1;	
+	_uncompressed=new ADMImage(_in->getInfo()->width,_in->getInfo()->height);
+	ADM_assert(_uncompressed);    	  	
+}
+ADMVideoFlipV::~ADMVideoFlipV()
+{
+ 	delete  _uncompressed;	
+	_uncompressed=NULL;
+  
+}
+uint8_t ADMVideoFlipV::getFrameNumberNoAlloc(uint32_t frame,
+				uint32_t *len,
+   				ADMImage *data,
+				uint32_t *flags)
+{
+
+	ADM_assert(frame<_info.nb_frames);
+	// read uncompressed frame
+	if(!_in->getFrameNumberNoAlloc(frame, len,_uncompressed,flags)) return 0;
+
+         uint8_t *in,*out;
+         uint32_t stride=_info.width;
+         uint32_t h=_info.height;
+         uint32_t page,qpage;
+        
+
+	  
+         page=stride*h;
+         qpage=page>>2;
+         
+         in=YPLANE(_uncompressed);
+         out=YPLANE(data)+(h-1)*stride;
+         // flip y
+         for(uint32_t y=h;y>0;y--)
+         {
+		 memcpy(out,in,stride);
+		 in+=stride;
+		 out-=stride;
+	}
+	// Flip U & V			         
+        stride>>=1;
+	in=UPLANE(_uncompressed);	
+        out=UPLANE(data)+qpage-stride;
+         // flip u
+         for(uint32_t y=h>>1;y>0;y--)
+         {
+		 memcpy(out,in,stride);
+		 in+=stride;
+		 out-=stride;
+	}
+	in=VPLANE(_uncompressed);
+        out=VPLANE(data)+qpage-stride;
+       
+      
+         // flip u
+         for(uint32_t y=h>>1;y>0;y--)
+         {
+		 memcpy(out,in,stride);
+		 in+=stride;
+		 out-=stride;
+	}   
+	data->copyInfo(_uncompressed);
+	return 1;
+}
+
+
+
+#endif

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidFlipV.h (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFlipV.h)

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidLargeMedian.cpp (from rev 2545, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidLargeMedian.cpp)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidLargeMedian.cpp	2006-11-04 15:58:52 UTC (rev 2545)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidLargeMedian.cpp	2007-01-13 11:10:25 UTC (rev 2714)
@@ -0,0 +1,311 @@
+/***************************************************************************
+                          ADM_vidLargeMedian.cpp  -  description
+                             -------------------
+    begin                : Wed Jan 1 2003
+    copyright            : (C) 2003 by mean
+    email                : fixounet at free.fr
+    
+    Using http://ndevilla.free.fr/median/median/node20.html
+    optimized median search
+    
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ADM_assert.h>
+
+#include "config.h"
+#include "fourcc.h"
+#include "avio.hxx"
+#include "config.h"
+#include "avi_vars.h"
+#ifdef HAVE_ENCODER
+
+
+#include "ADM_toolkit/toolkit.hxx"
+#include "ADM_editor/ADM_edit.hxx"
+#include "ADM_video/ADM_genvideo.hxx"
+
+#include"ADM_vidLargeMedian.h"
+#include "ADM_filter/video_filters.h"
+
+
+static FILTER_PARAM nullParam={2,{"chroma","luma"}};
+
+
+SCRIPT_CREATE(largeMedian_script,ADMVideoLargeMedian,nullParam);
+BUILD_CREATE(largeMedian_create,ADMVideoLargeMedian);
+
+//_______________________________________________________________
+
+ADMVideoLargeMedian::ADMVideoLargeMedian(
+									AVDMGenericVideoStream *in,CONFcouple *couples)
+{
+
+
+	_in=in;		
+	memcpy(&_info,_in->getInfo(),sizeof(_info));  		
+	_uncompressed=new ADMImage(_in->getInfo()->width,_in->getInfo()->height);
+	ADM_assert(_uncompressed);
+	_info.encoding=1;
+	if(couples==NULL)
+	{
+		_param=NEW( CONV_PARAM);
+		_param->chroma=1;
+		_param->luma=1;
+		printf("\n Creating from null\n");
+	}
+	else
+	{
+			_param=NEW(CONV_PARAM);
+			GET(luma);
+			GET(chroma);
+	}
+
+
+}
+
+uint8_t	ADMVideoLargeMedian::getCoupledConf( CONFcouple **couples)
+{
+
+			ADM_assert(_param);
+			*couples=new CONFcouple(2);
+
+#define CSET(x)  (*couples)->setCouple((char *)#x,(_param->x))
+			CSET(luma);
+			CSET(chroma);
+			return 1;
+
+}
+ADMVideoLargeMedian::~ADMVideoLargeMedian()
+{
+	if(_uncompressed)
+ 		delete _uncompressed;
+	_uncompressed=NULL;
+	DELETE(_param);
+}
+char *ADMVideoLargeMedian::printConf(void)
+{
+ 		return (char *)"Median (5x5)";; // this one is pure
+}
+//
+//	Basically ask a uncompressed frame from editor and ask
+//		GUI to decompress it .
+//
+
+uint8_t ADMVideoLargeMedian::getFrameNumberNoAlloc(uint32_t frame,
+				uint32_t *len,
+   				ADMImage *data,
+				uint32_t *flags)
+{
+//uint8_t *dst,*dstu,*dstv,*srcu,*srcv;
+uint8_t *x1,*x2,*x3,*x4,*x5,*o1;
+uint32_t stride,page;
+
+	ADM_assert(frame<_info.nb_frames);
+	ADM_assert(_uncompressed);					
+	stride=_info.width;
+	page=(stride*_info.height)>>2;
+																
+	// read uncompressed frame
+	if(!_in->getFrameNumberNoAlloc(frame, len,_uncompressed,flags)) return 0;               
+         
+	if(!_param->luma)
+	{
+		memcpy(YPLANE(data),YPLANE(_uncompressed),page*4);						
+	}
+	else
+	{
+		memcpy(YPLANE(data),YPLANE(_uncompressed),stride*2);
+		memcpy(YPLANE(data)+page*4-stride*2,YPLANE(_uncompressed)+page*4-2*stride,2*stride);          
+	         
+		o1=YPLANE(data)+stride*2;;
+		x1=YPLANE(_uncompressed);
+		x2=x1+stride;
+		x3=x2+stride;
+		x4=x3+stride;
+		x5=x4+stride;
+		// Luma
+		for(int32_t y=2;y<(int32_t)(_info.height)-2;y++)
+		{
+			doLine(x1,x2,x3,x4,x5,o1,stride);
+			x1=x2;
+			x2=x3;
+			x3=x4;
+			x4=x5;
+			x5+=stride; 
+			o1+=stride;                 
+		}
+	}
+					
+      	
+	stride>>=1;
+	if(!_param->chroma)
+	{
+	 	memcpy(UPLANE(data),UPLANE(_uncompressed),page*2);			
+	}	
+	else
+	{
+		// first and last line
+		memcpy(UPLANE(data),UPLANE(_uncompressed),stride*2);
+		memcpy(UPLANE(data)+page-stride*2,UPLANE(_uncompressed)+page-2*stride,2*stride);
+		// chroma u	
+		o1=UPLANE(data)+stride*2;
+		x1=UPLANE(_uncompressed);
+		x2=x1+stride;
+		x3=x2+stride;
+		x4=x3+stride;
+		x5=x4+stride;
+	          
+		for(int32_t y=2;y<(int32_t)(_info.height>>1)-2;y++)
+		{
+			doLine(x1,x2,x3,x4,x5,o1,stride);
+			x1=x2;
+			x2=x3;
+			x3=x4;
+			x4=x5;
+			x5+=stride; 
+			o1+=stride;                 
+		}
+		// chroma V
+		// first and last line
+		memcpy(VPLANE(data),VPLANE(_uncompressed),stride*2);
+		memcpy(VPLANE(data)+page-2*stride,VPLANE(_uncompressed)+page-2*stride,2*stride);          
+	          
+		o1=VPLANE(data)+stride*2;
+		x1=VPLANE(_uncompressed);
+		x2=x1+stride;
+		x3=x2+stride;
+		x4=x3+stride;
+		x5=x4+stride;
+
+	         
+		for(int32_t y=2;y<(int32_t)(_info.height>>1)-2;y++)
+		{
+			doLine(x1,x2,x3,x4,x5,o1,stride);
+			x1=x2;
+			x2=x3;
+			x3=x4;
+			x4=x5;
+			x5+=stride; 
+			o1+=stride;                      
+	      	}
+	}
+	data->copyInfo(_uncompressed);
+	return 1;
+}
+//________________________________________________________________________
+uint8_t ADMVideoLargeMedian::doLine(uint8_t  *pred2,uint8_t  *pred1,
+					uint8_t *cur,
+   					uint8_t *next1,uint8_t *next2,
+   					uint8_t *out,
+                       			uint32_t w)
+                                 
+{
+static uint8_t box[5][5];	
+static uint8_t box2[5][5];	
+
+uint32_t col;
+uint8_t temp;
+uint32_t inbox;
+	
+// prefill box
+	for(uint32_t x=0;x<4;x++)
+		{
+			box[0][x+1]=*(pred2+x);
+			box[1][x+1]=*(pred1+x);
+			box[2][x+1]=*(cur+x);
+			box[3][x+1]=*(next1+x);
+			box[4][x+1]=*(next2+x);			
+		}
+		col=0;
+		*out=*cur;
+		*(out+1)=*(cur+1);
+		*(out+w-1)=*(cur+w-1);		
+		*(out+w-2)=*(cur+w-2);
+		out+=2;
+		next1+=4;
+		next2+=4;
+		pred1+=4;
+		pred2+=4;
+		cur+=4;	
+	while(w>4)
+	{
+		// fill
+			box[0][col]=*pred2++;
+			box[1][col]=*pred1++;
+			box[2][col]=*cur++;
+			box[3][col]=*next1++;
+			box[4][col]=*next2++;
+			col++;
+			col%=5;
+			// copy & sort
+			memcpy(box2,box,5*5);
+			uint8_t *p=(uint8_t *)box2;	
+			inbox=0;	
+#define PIX_SORT(a,b) { if ((a)>(b)) PIX_SWAP((a),(b)); }
+#define PIX_SWAP(a,b) { temp=(a);(a)=(b);(b)=temp; }
+
+			
+    PIX_SORT(p[0], p[1]) ;   PIX_SORT(p[3], p[4]) ;   PIX_SORT(p[2], p[4]) ;
+    PIX_SORT(p[2], p[3]) ;   PIX_SORT(p[6], p[7]) ;   PIX_SORT(p[5], p[7]) ;
+    PIX_SORT(p[5], p[6]) ;   PIX_SORT(p[9], p[10]) ;  PIX_SORT(p[8], p[10]) ;
+    PIX_SORT(p[8], p[9]) ;   PIX_SORT(p[12], p[13]) ; PIX_SORT(p[11], p[13]) ;
+    PIX_SORT(p[11], p[12]) ; PIX_SORT(p[15], p[16]) ; PIX_SORT(p[14], p[16]) ;
+    PIX_SORT(p[14], p[15]) ; PIX_SORT(p[18], p[19]) ; PIX_SORT(p[17], p[19]) ;
+    PIX_SORT(p[17], p[18]) ; PIX_SORT(p[21], p[22]) ; PIX_SORT(p[20], p[22]) ;
+    PIX_SORT(p[20], p[21]) ; PIX_SORT(p[23], p[24]) ; PIX_SORT(p[2], p[5]) ;
+    PIX_SORT(p[3], p[6]) ;   PIX_SORT(p[0], p[6]) ;   PIX_SORT(p[0], p[3]) ;
+    PIX_SORT(p[4], p[7]) ;   PIX_SORT(p[1], p[7]) ;   PIX_SORT(p[1], p[4]) ;
+    PIX_SORT(p[11], p[14]) ; PIX_SORT(p[8], p[14]) ;  PIX_SORT(p[8], p[11]) ;
+    PIX_SORT(p[12], p[15]) ; PIX_SORT(p[9], p[15]) ;  PIX_SORT(p[9], p[12]) ;
+    PIX_SORT(p[13], p[16]) ; PIX_SORT(p[10], p[16]) ; PIX_SORT(p[10], p[13]) ;
+    PIX_SORT(p[20], p[23]) ; PIX_SORT(p[17], p[23]) ; PIX_SORT(p[17], p[20]) ;
+    PIX_SORT(p[21], p[24]) ; PIX_SORT(p[18], p[24]) ; PIX_SORT(p[18], p[21]) ;
+    PIX_SORT(p[19], p[22]) ; PIX_SORT(p[8], p[17]) ;  PIX_SORT(p[9], p[18]) ;
+    PIX_SORT(p[0], p[18]) ;  PIX_SORT(p[0], p[9]) ;   PIX_SORT(p[10], p[19]) ;
+    PIX_SORT(p[1], p[19]) ;  PIX_SORT(p[1], p[10]) ;  PIX_SORT(p[11], p[20]) ;
+    PIX_SORT(p[2], p[20]) ;  PIX_SORT(p[2], p[11]) ;  PIX_SORT(p[12], p[21]) ;
+    PIX_SORT(p[3], p[21]) ;  PIX_SORT(p[3], p[12]) ;  PIX_SORT(p[13], p[22]) ;
+    PIX_SORT(p[4], p[22]) ;  PIX_SORT(p[4], p[13]) ;  PIX_SORT(p[14], p[23]) ;
+    PIX_SORT(p[5], p[23]) ;  PIX_SORT(p[5], p[14]) ;  PIX_SORT(p[15], p[24]) ;
+    PIX_SORT(p[6], p[24]) ;  PIX_SORT(p[6], p[15]) ;  PIX_SORT(p[7], p[16]) ;
+    PIX_SORT(p[7], p[19]) ;  PIX_SORT(p[13], p[21]) ; PIX_SORT(p[15], p[23]) ;
+    PIX_SORT(p[7], p[13]) ;  PIX_SORT(p[7], p[15]) ;  PIX_SORT(p[1], p[9]) ;
+    PIX_SORT(p[3], p[11]) ;  PIX_SORT(p[5], p[17]) ;  PIX_SORT(p[11], p[17]) ;
+    PIX_SORT(p[9], p[17]) ;  PIX_SORT(p[4], p[10]) ;  PIX_SORT(p[6], p[12]) ;
+    PIX_SORT(p[7], p[14]) ;  PIX_SORT(p[4], p[6]) ;   PIX_SORT(p[4], p[7]) ;
+    PIX_SORT(p[12], p[14]) ; PIX_SORT(p[10], p[14]) ; PIX_SORT(p[6], p[7]) ;
+    PIX_SORT(p[10], p[12]) ; PIX_SORT(p[6], p[10]) ;  PIX_SORT(p[6], p[17]) ;
+    PIX_SORT(p[12], p[17]) ; PIX_SORT(p[7], p[17]) ;  PIX_SORT(p[7], p[10]) ;
+    PIX_SORT(p[12], p[18]) ; PIX_SORT(p[7], p[12]) ;  PIX_SORT(p[10], p[18]) ;
+    PIX_SORT(p[12], p[20]) ; PIX_SORT(p[10], p[20]) ; PIX_SORT(p[10], p[12]) ;
+			
+		  
+		  *out++=p[12];
+		  w--;
+	}	
+	
+	return 1;
+}
+
+uint8_t ADMVideoLargeMedian::configure(AVDMGenericVideoStream * instream)
+{
+  return 1; 
+}
+
+
+
+#endif
+
+

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidLargeMedian.h (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidLargeMedian.h)

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidLuma.cpp (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidLuma.cpp)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidLuma.cpp	2006-10-31 15:59:58 UTC (rev 2489)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidLuma.cpp	2007-01-13 11:10:25 UTC (rev 2714)
@@ -0,0 +1,98 @@
+/***************************************************************************
+                          ADM_vidLuma.cpp  -  description
+                             -------------------
+    begin                : Sat Aug 24 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+ #include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ADM_assert.h>
+
+#include "config.h"
+#include "fourcc.h"
+#include "avio.hxx"
+#include "config.h"
+#include "avi_vars.h"
+#ifdef HAVE_ENCODER
+
+
+#include "ADM_toolkit/toolkit.hxx"
+#include "ADM_editor/ADM_edit.hxx"
+#include "ADM_video/ADM_genvideo.hxx"
+#include "ADM_vidLuma.h"
+#include "ADM_filter/video_filters.h"
+
+
+static FILTER_PARAM nullParam={0,{""}};
+
+
+SCRIPT_CREATE(luma_script,ADMVideoLuma,nullParam);
+BUILD_CREATE(luma_create,ADMVideoLuma);
+
+ 
+
+char *ADMVideoLuma::printConf( void )
+{
+ 	static char buf[50];
+ 	
+ 	sprintf((char *)buf," Luma only");
+        return buf;
+}
+
+ADMVideoLuma::ADMVideoLuma(  AVDMGenericVideoStream *in,CONFcouple *setup)
+{
+
+ 	_in=in;		
+   	memcpy(&_info,_in->getInfo(),sizeof(_info));  		
+	
+		if(setup)
+		{
+			 _param=(void *)setup;
+		}	
+			else 			
+		{	// default parameter	
+				_param= NULL;
+		}				
+					 	
+  _info.encoding=1;
+
+  	  	
+}
+ADMVideoLuma::~ADMVideoLuma()
+{
+ 	
+}
+uint8_t ADMVideoLuma::getFrameNumberNoAlloc(uint32_t frame,
+				uint32_t *len,
+   				ADMImage *data,
+				uint32_t *flags)
+{
+
+	ADM_assert(frame<_info.nb_frames);
+	// read uncompressed frame
+	if(!_in->getFrameNumberNoAlloc(frame, len,data,flags)) return 0;
+
+	uint32_t sz;
+			
+	sz=_info.width*_info.height;
+	memset(UPLANE(data),128,sz>>2);
+	memset(VPLANE(data),128,sz>>2);
+
+      return 1;
+}
+
+
+
+#endif

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidLuma.h (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidLuma.h)

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidResampleFPS.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidResampleFPS.cpp	2007-01-13 10:49:01 UTC (rev 2713)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidResampleFPS.cpp	2007-01-13 11:10:25 UTC (rev 2714)
@@ -33,7 +33,6 @@
 #include "ADM_toolkit/toolkit.hxx"
 #include "ADM_editor/ADM_edit.hxx"
 #include "ADM_video/ADM_genvideo.hxx"
-#include "ADM_video/ADM_vidFlipV.h"
 #include "ADM_filter/video_filters.h"
 #include "DIA_enter.h"
 #include "ADM_video/ADM_cache.h"

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am	2007-01-13 10:49:01 UTC (rev 2713)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am	2007-01-13 11:10:25 UTC (rev 2714)
@@ -7,6 +7,10 @@
 #INCLUDES = $(all_includes) 
 
 libADM_videoFilter_a_SOURCES =  \
+ ADM_vidFlipV.cpp \
+ ADM_vidLuma.cpp \
+ ADM_vidLargeMedian.cpp \
+ ADM_vidChroma.cpp \
  ADM_vidMosaic.cpp \
  ADM_vidBlendRemoval.cpp  \
  ADM_vidHardIvtcRemoval.cpp \



From mean at mail.berlios.de  Sat Jan 13 12:31:18 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 13 Jan 2007 12:31:18 +0100
Subject: [Avidemux-svn-commit] r2715 - in
	branches/avidemux_2.4_branch/avidemux: ADM_video ADM_videoFilter
Message-ID: <200701131131.l0DBVIT2024720@sheep.berlios.de>

Author: mean
Date: 2007-01-13 12:31:17 +0100 (Sat, 13 Jan 2007)
New Revision: 2715

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDropOut.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDropOut.h
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidPulldown.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidPulldown.h
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidStabilize.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidStabilize.h
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidUVSwap.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidUVSwap.h
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidVlad.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidVlad.h
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidWhirl.cpp
Removed:
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDropOut.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDropOut.h
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidPulldown.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidPulldown.h
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidStabilize.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidStabilize.h
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidUVSwap.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidUVSwap.h
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidVlad.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidVlad.h
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidWirl.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidlavdeint.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidlavdeint.h
Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidBlendRemoval.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am
Log:
cleanup

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDropOut.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDropOut.cpp	2007-01-13 11:10:25 UTC (rev 2714)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDropOut.cpp	2007-01-13 11:31:17 UTC (rev 2715)
@@ -1,230 +0,0 @@
-/***************************************************************************
-                          ADM_vidDropOut.cpp  -  description
-                             -------------------
-    begin                : Mon Oct 7 2002
-    copyright            : (C) 2002 by Ron Reithoffer 
-    email                : <ron.reithoffer at chello.at>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <ADM_assert.h>
-#include <math.h>
-
-#include "config.h"
-#include "fourcc.h"
-#include "avio.hxx"
-#include "config.h"
-#include "avi_vars.h"
-#ifdef HAVE_ENCODER
-
-
-#include "ADM_toolkit/toolkit.hxx"
-#include "ADM_editor/ADM_edit.hxx"
-#include "ADM_video/ADM_genvideo.hxx"
-#include "ADM_video/ADM_vidDropOut.h"
-#include "ADM_filter/video_filters.h"
-
-
-static FILTER_PARAM dropParam={1,{"threshold"}};
-
-
-SCRIPT_CREATE(dropout_script,ADMVideoDropOut,dropParam);
-
-
-//extern uint8_t distMatrix[256][256];
-extern uint32_t fixMul[16];
-
-BUILD_CREATE(dropout_create,ADMVideoDropOut);
-//_______________________________________________________________
- 
-
-char  *ADMVideoDropOut::printConf(void)
-{
-	static char buf[50];
-
- 	sprintf((char *)buf," DropOut :%ld",*_param);
-        return buf;
-}
-uint8_t  GUI_getIntegerValue(int *valye, int min, int max, char *title);	
-uint8_t ADMVideoDropOut::configure(AVDMGenericVideoStream *instream)
-{
-int i;
-
-	_in=instream;
-	i=(int)*_param;
-	if(GUI_getIntegerValue(&i,1,255,"DropOut Threshold"))
-	{
-		*_param=(uint32_t)i;
-		return 1;
-	}
-	return 0;
-}
-ADMVideoDropOut::~ADMVideoDropOut()
-{
-	DELETE(_param);
-	delete vidCache;
-	vidCache=NULL;
-}
-
-//--------------------------------------------------------	
-ADMVideoDropOut::ADMVideoDropOut(AVDMGenericVideoStream *in,CONFcouple *couples)
-{
-
-  
-	_in=in;
-  	_info.encoding=1;
-	if(couples)
-	{
-  		_param=NEW( uint32_t);
-		couples->getCouple((char *)"threshold",(uint32_t *)_param);
-	}
-	else
-	{
-		_param=NEW( uint32_t);
-		*_param=30;
-	}
-	vidCache=new VideoCache(4,_in);
-	memcpy(&_info,_in->getInfo(),sizeof(_info));
-	
- 
-}
-
-uint8_t	ADMVideoDropOut::getCoupledConf( CONFcouple **couples)
-{
-
-			ADM_assert(_param);
-			*couples=new CONFcouple(1);
-			(*couples)->setCouple((char *)"threshold",(*_param));
-			return 1;
-
-}
-
-//                     1
-//		Get in range in 121 + coeff matrix
-//                     1
-//
-// If the value is too far away we ignore it
-// else we blend
-
-uint8_t ADMVideoDropOut::getFrameNumberNoAlloc(uint32_t frame,
-				uint32_t *len,
-   				ADMImage *data,
-				uint32_t *flags)
-{
-UNUSED_ARG(flags);
-
-uint32_t uvlen;
-uint32_t dlen,dflags;
-
-ADMImage	*_next;
-ADMImage	*_previous;
-ADMImage	*_current;
-
-	//		printf("\n DropOut : %lu\n",frame);
-
-
-
-
-			uvlen=    _info.width*_info.height;
-			*len=uvlen+(uvlen>>1);
-			  if(frame> _info.nb_frames-1) return 0;
-			if(!frame || (frame==_info.nb_frames-1))
-			{
-				_current=vidCache->getImage(frame);
-				if(!_current) return 0;
-				memcpy(YPLANE(data),YPLANE(_current),uvlen);
-				memcpy(UPLANE(data),UPLANE(_current),uvlen>>2);
-				memcpy(VPLANE(data),VPLANE(_current),uvlen>>2);
-				vidCache->unlockAll();
-				return 1;
-			}
-			
-		_current=vidCache->getImage(frame);
-		_previous=vidCache->getImage(frame-1);
-		_next=vidCache->getImage(frame+1);
-		if(!_current || !_previous || !_next)
-		{
-			vidCache->unlockAll();
-			 return 0;	
-		}
-           	// for u & v , no action -> copy it as is
-           	memcpy(UPLANE(data),UPLANE(_current),uvlen>>2);
-		memcpy(VPLANE(data),VPLANE(_current),uvlen>>2);
-
-             uint8_t *inprev,*innext,*incur,*zout;
-
-              inprev=YPLANE(_previous)+1+_info.width;
-              innext=YPLANE(_next)+1+_info.width;
-              incur =YPLANE(_current)+1+_info.width;
-
-              zout=YPLANE(data)+_info.width+1;
-
-              int32_t c0,c1,c2,c3; //,_nextPix,_currPix,_prevPix,cc;
-
-              for(uint32_t y= _info.height-2;y>2;y--)
-              	{
-		  c0=0;
-		  c1=0;
-		  c2=0;
-		  c3=0;
-
-	  	inprev=YPLANE(_previous)	+1+y*_info.width;
-              	innext=YPLANE(_next)		+1+y*_info.width;;
-              	incur =YPLANE(_current)	+1+y*_info.width;;
-
-			// look if the field is more different temporarily than spacially
-
-			    for(uint32_t x= _info.width-1;x>1;x--)
-        		      	{
-
-						c0+=(abs(((*inprev))-( *incur    ))^2);
-						c1+=(abs(((*inprev))-( *innext   ))^2)<<1;
-						c0+=(abs(((*incur ))-( *innext   ))^2);
-
-
-						c2+=(abs(((    *(incur-_info.width*2) ))-( *(incur            )   ))^2)   ;
-						c3+=(abs(((    *(incur-_info.width*2) ))-( *(incur+_info.width*2)   ))^2)<<1;
-						c2+=(abs(((    *(incur            ) ))-( *(incur+_info.width*2)   ))^2)   ;
-
-
-						incur++;
-						innext++;
-						inprev++;
-				}
-
-		// If yes, replace the line by an average of next/previous image
-		inprev=YPLANE(_previous)	+y*_info.width;
-              	innext=YPLANE(_next)		+y*_info.width;;
-              	incur =YPLANE(_current)		+y*_info.width;;
-		zout=YPLANE(data)		+y*_info.width;
-
-		if (c1<c0 &&c3<c2)
-		{
-		    for(uint32_t x= _info.width;x>0;x--)
-       			      	{
-					*zout= ((*(inprev))+(*(innext)))>>1 ;
-					zout++;
-					innext++;
-					inprev++;
-				}
-		}
-		else
-			memcpy(zout,incur,_info.width);
-	}
-	data->copyInfo(_current);
-	vidCache->unlockAll();
-return 1;
-}
-
-
-#endif

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDropOut.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDropOut.h	2007-01-13 11:10:25 UTC (rev 2714)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDropOut.h	2007-01-13 11:31:17 UTC (rev 2715)
@@ -1,41 +0,0 @@
-/***************************************************************************
-                          ADM_vidDropOut.h  -  description
-                             -------------------
-    begin                : Mon Oct 7 2002
-    copyright            : (C) 2002 by mean
-    email                : RON
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifndef __DROPOUT__
-#define __DROPOUT__   
-#include "ADM_video/ADM_cache.h"
- 
-class  ADMVideoDropOut:public AVDMGenericVideoStream
- {
-
- protected:
-
-        virtual char 				*printConf(void) ;
-						VideoCache	*vidCache;
-	 uint32_t				*_param;
- public:
- 					
-  						ADMVideoDropOut(  AVDMGenericVideoStream *in,CONFcouple *setup);
-  						~ADMVideoDropOut();
-		      virtual uint8_t 	getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-          									ADMImage *data,uint32_t *flags);
-
-			virtual uint8_t configure( AVDMGenericVideoStream *instream) ;
-			virtual uint8_t getCoupledConf( CONFcouple **couples);
-
- }     ;
- 
-#endif

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidPulldown.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidPulldown.cpp	2007-01-13 11:10:25 UTC (rev 2714)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidPulldown.cpp	2007-01-13 11:31:17 UTC (rev 2715)
@@ -1,183 +0,0 @@
-/***************************************************************************
-                       Pulldown : Duplicate frame fields to convert
-		       	24 fps to 30 fps movie
-
-			1 2 3 4       1  2  3  4  4
-			1 2 3 4 --> 1  2  2  3  4
-
-
-    begin                : Thu Mar 21 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <ADM_assert.h>
-
-#include "config.h"
-#include "fourcc.h"
-#include "avio.hxx"
-#include "config.h"
-#include "avi_vars.h"
-
-
-#include "ADM_toolkit/toolkit.hxx"
-#include "ADM_editor/ADM_edit.hxx"
-#include "ADM_video/ADM_genvideo.hxx"
-#include "ADM_video/ADM_vidFieldUtil.h"
-#include "ADM_video/ADM_vidPulldown.h"
-#include "ADM_video/ADM_interlaced.h"
-#include "ADM_osSupport/TLK_clock.h"
-#include "ADM_osSupport/ADM_debugID.h"
-#define MODULE_NAME MODULE_FILTER
-#include "ADM_osSupport/ADM_debug.h"
-#include "ADM_filter/video_filters.h"
-
-
-static FILTER_PARAM swapParam={0,{""}};
-SCRIPT_CREATE(pulldown_script,ADMVideoPullDown,swapParam);
-BUILD_CREATE(pulldown_create,ADMVideoPullDown);
-
-char *ADMVideoPullDown::printConf( void )
-{
- 	static char buf[50];
-
- 	sprintf((char *)buf," Pulldown");
-        return buf;
-}
-//_______________________________________________________________
-ADMVideoPullDown::ADMVideoPullDown(
-									AVDMGenericVideoStream *in,CONFcouple *setup)
-{
-UNUSED_ARG(setup);
-  	_in=in;
-   	memcpy(&_info,_in->getInfo(),sizeof(_info));
-	_info.fps1000=(_info.fps1000*5)/4;
-	_info.nb_frames=(_info.nb_frames*5)/4;
-	for(uint32_t i=0;i<5;i++)
-	{
-		_uncompressed[i]=new ADMImage(_info.width,_info.height);
-	}
-	_cacheStart=0xfffffff;
-}
-// ___ destructor_____________
-ADMVideoPullDown::~ADMVideoPullDown()
-{
-	for(uint32_t i=0;i<5;i++)
-	{
- 		delete  _uncompressed[i];
-	}
-}
-
-
-uint8_t ADMVideoPullDown::getFrameNumberNoAlloc(uint32_t frame,
-				uint32_t *len,
-   				ADMImage *data,
-				uint32_t *flags)
-{
-//static Image in,out;
-			if(frame>=_info.nb_frames)
-			{
-				printf("out of bound frame (%lu / %lu)\n",frame,_info.nb_frames);
-				return 0;
-			}
-
-		uint32_t w=_info.width;
-		uint32_t h=_info.height;
-		uint32_t page=w*h;
-		uint32_t i;
-
-		uint32_t target;
-		uint32_t loop=0;
-
-		*len=(page*3)>>1;
-
-cont:
-
-		target=frame-((frame)%5);
-		// got it ?
-		if(_cacheStart==target)
-		{
-			uint32_t index;
-
-			aprintf("Filter: It is in cache...(cachestart=%lu)\n",_cacheStart);
-			index=frame%5;
-			aprintf("getting %lu)\n",index);
-			memcpy(YPLANE(data),YPLANE(_uncompressed[index]),page);
-			memcpy(UPLANE(data),UPLANE(_uncompressed[index]),page>>2);
-			memcpy(VPLANE(data),VPLANE(_uncompressed[index]),page>>2);
-			*flags=0;			
-			return 1;
-		}
-		else
-		{
-			aprintf("Not in cache...\n");
-		}
-		// Else ask the 5 corresponding frame
-		_cacheStart=target;
-		target=(target*4)/5;
-
-		uint32_t dflags,dlen;
-#define GET_FRAME(x,y) if(!_in->getFrameNumberNoAlloc(x, &dlen,_uncompressed[y],&dflags)) \
- {\
-				 	 	printf("Cannot get frame %lu\n",target+i);\
-					 	return 0;     \
-				 }
-
-		GET_FRAME(target+0,0);
-		GET_FRAME(target+1,1);
-		GET_FRAME(target+2,3);
-		GET_FRAME(target+3,4);
-		// copy chroma 1->2
-		memcpy(UPLANE(_uncompressed[2]),UPLANE(_uncompressed[1]),page>>2);
-		memcpy(VPLANE(_uncompressed[2]),VPLANE(_uncompressed[1]),page>>2);
-#define COPY_FIELD \
-		for(uint32_t y=0;y<_info.height>>1;y++) \
-		{ \
-			memcpy(out,in,_info.width); \
-			in+=_info.width<<1; \
-			out+=_info.width<<1; \
-		}
-
-		// now we merge 1 & 3 into 2
-
-		uint8_t *in,*out;
-		in=YPLANE(_uncompressed[1]);
-		out=YPLANE(_uncompressed[2]);
-		COPY_FIELD;
-
-
-		// merge 3->2
-		//
-		//	0 1 x 2 3
-		//      0 1 x 2 3
-		//
-		//  0 1 1 2 3
-		//  0 1 X 2 3
-		in=YPLANE(_uncompressed[3])+w;
-		out=YPLANE(_uncompressed[2])+w;
-		COPY_FIELD;
-		//  0 1 1 2 3
-		//  0 1 2 2 3
-		in=YPLANE(_uncompressed[4])+w;
-		out=YPLANE(_uncompressed[3])+w;
-		//  0 1 1 2 3
-		//  0 1 2 3 3
-		COPY_FIELD;
-		goto cont;
-		return 1;
-}
-
-
-

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidPulldown.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidPulldown.h	2007-01-13 11:10:25 UTC (rev 2714)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidPulldown.h	2007-01-13 11:31:17 UTC (rev 2715)
@@ -1,24 +0,0 @@
-#ifndef VID_PDW_
-#define VID_PDW_
-
- class  ADMVideoPullDown:public AVDMGenericVideoStream
- {
-
- protected:
-
-				ADMImage	*_uncompressed[5];
-     		virtual 	char 		*printConf(void);
-				uint32_t	_cacheStart;
-
- public:
-
-
-  				ADMVideoPullDown(  AVDMGenericVideoStream *in,CONFcouple *setup);
-
-  	virtual 		~ADMVideoPullDown();
-	virtual uint8_t 	getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-          								ADMImage *data,uint32_t *flags);
-	virtual uint8_t configure( AVDMGenericVideoStream *instream) {return 1;};
-
- }     ;
-#endif

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidStabilize.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidStabilize.cpp	2007-01-13 11:10:25 UTC (rev 2714)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidStabilize.cpp	2007-01-13 11:31:17 UTC (rev 2715)
@@ -1,214 +0,0 @@
-/***************************************************************************
-                          ADM_vidStabilize.cpp  -  description
-                             -------------------
-    begin                : Mon Oct 7 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <ADM_assert.h>
-#include <math.h>
-
-#include "config.h"
-#include "fourcc.h"
-#include "avio.hxx"
-#include "config.h"
-#include "avi_vars.h"
-#ifdef HAVE_ENCODER
-
-
-#include "ADM_toolkit/toolkit.hxx"
-#include "ADM_editor/ADM_edit.hxx"
-#include "ADM_video/ADM_genvideo.hxx"
-#include "ADM_video/ADM_vidStabilize.h"
-#include "ADM_filter/video_filters.h"
-
-
-static FILTER_PARAM stabParam={1,{"param"}};
-
-
-SCRIPT_CREATE(stabilize_script,ADMVideoStabilize,stabParam);
-extern uint8_t distMatrix[256][256];
-extern uint32_t fixMul[16];
-
-BUILD_CREATE(stabilize_create,ADMVideoStabilize);
-
-
-
-char 	*ADMVideoStabilize::printConf(void)
-{
-  static char buf[50];
-
- 	sprintf((char *)buf," Stabilize :%ld",*_param);
-        return buf;
-}
-uint8_t  GUI_getIntegerValue(int *valye, int min, int max, char *title);
-uint8_t ADMVideoStabilize::configure(AVDMGenericVideoStream *instream)
-{
-int i;
-			_in=instream;
-			i=(int)*_param;
-			if(GUI_getIntegerValue(&i,1,255,"Stabilize Threshold"))
-			{
-					*_param=(uint32_t)i;
-					return 1;
-			}
-			return 0;
-		    
-	
-}
-//--------------------------------------------------------	
-ADMVideoStabilize::ADMVideoStabilize(AVDMGenericVideoStream *in,CONFcouple *couples)
-{
-  //uint32_t frame;
-  _uncompressed=NULL;
-  _in=in;
-  memcpy(&_info,in->getInfo(),sizeof(_info)); 
- 
-  _info.encoding=1;
-  if(couples)
-  {
-			_param=NEW(uint32_t);
-			ADM_assert(couples->getCouple((char *)"param",_param));
-	}
-	else
-	{
-			_param=NEW( uint32_t);
-			*_param=30;
-	}
-	vidCache=new VideoCache(5,_in);
- 
-}
-ADMVideoStabilize::~ADMVideoStabilize()
-{
- 
- 	DELETE(_param);
-	if(vidCache) delete vidCache;
-	vidCache=NULL;
-}
-
-
-uint8_t	ADMVideoStabilize::getCoupledConf( CONFcouple **couples)
-{
-
-			ADM_assert(_param);
-			*couples=new CONFcouple(1);
- 			(*couples)->setCouple((char *)"param",*_param);
-
-			return 1;
-
-}
-//                     1
-//		Get in range in 121 + coeff matrix
-//                     1
-//
-// If the value is too far away we ignore it
-// else we blend
-
-uint8_t ADMVideoStabilize::getFrameNumberNoAlloc(uint32_t frame,
-				uint32_t *len,
-   				ADMImage *data,
-				uint32_t *flags)
-{
-UNUSED_ARG(flags);
-uint32_t uvlen;
-uint32_t dlen,dflags;
-
-ADMImage	*_next;
-ADMImage	*_previous;  	
-ADMImage	*_current;
-		
-		uvlen=    _info.width*_info.height;
-		*len=uvlen+(uvlen>>1);
-		if(frame> _info.nb_frames-1) return 0;
-		_current=vidCache->getImage(frame);
-		if(!_current) return 0;
-		data->copyInfo(_current);
-		if(!frame || (frame==_info.nb_frames-1))
-		{
-
-			data->duplicate(_current);
-			vidCache->unlockAll();
-			return 1;
-		}	 
-   		_previous=vidCache->getImage(frame-1);		
-		if(!_previous)
-		{
-			vidCache->unlockAll();
-			return 0;
-		}
-   		_next=vidCache->getImage(frame+1);
-		if(!_next)
-		{
-			vidCache->unlockAll();
-			return 0;
-		}
-		
-           // for u & v , no action -> copy it as is
-           memcpy(UPLANE(data),UPLANE(_current),uvlen>>2);
-	   memcpy(VPLANE(data),VPLANE(_current),uvlen>>2);
-
-           uint8_t *inprev,*innext,*incur,*zout;
-              
-              inprev=YPLANE(_previous)+1+_info.width;
-              innext=YPLANE(_next)+1+_info.width;
-              incur =YPLANE(_current)+1+_info.width;
-              
-              zout=YPLANE(data)+_info.width+1;
-              
-             
-              uint8_t *nl,*pl,*nc,*pc;
-              
-              uint16_t c,coeff;
-              uint32_t x;
-              for(uint32_t y= _info.height-1;y>1;y--)
-              	{
-			nl=incur+_info.width;
-			pl=incur-_info.width;
-			nc=incur+1;
-			pc=incur-1;		   
-								   
-		        for(x= _info.width-1;x>1;x--)
-        		{
-	               		c=*incur*4;;
-	                    	coeff=4;
-#define PONDERATE(x,p) if(distMatrix[*incur][x]<*_param)	                      \
-{ c+=x;coeff++;}
-																PONDERATE(*innext,1);
-				PONDERATE(*inprev,1);
-				PONDERATE(*(pc),1);
-				PONDERATE(*(nc),1);
-				PONDERATE(*(nl),1);
-				PONDERATE(*(pl),1);
-													//*zout=(uint8_t)floor(0.49+(c/coeff));
-																ADM_assert(coeff);
-				ADM_assert(coeff<16);
-				*zout=(c*fixMul[coeff])>>16;
-				zout++;
-				incur++;
-				innext++;
-				inprev++;	
-				nl++;pl++;nc++;pc++;	  
-			}
-			zout+=2;
-			incur+=2;
-			innext+=2;
-			inprev+=2;
-		}
-		vidCache->unlockAll();
-		return 1;	
-}
-
-
-#endif

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidStabilize.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidStabilize.h	2007-01-13 11:10:25 UTC (rev 2714)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidStabilize.h	2007-01-13 11:31:17 UTC (rev 2715)
@@ -1,39 +0,0 @@
-/***************************************************************************
-                          ADM_vidStabilize.h  -  description
-                             -------------------
-    begin                : Mon Oct 7 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifndef __STABL__
-#define __STABL__   
-#include "ADM_video/ADM_cache.h" 
- class  ADMVideoStabilize:public AVDMGenericVideoStream
- {
-
- protected:
-    		
-        		uint32_t		*_param;
-        		virtual char 	*printConf(void);
-				VideoCache		*vidCache;
-
-
- public:
-
-						ADMVideoStabilize(  AVDMGenericVideoStream *in,CONFcouple *setup);
-  					 	~ADMVideoStabilize();
-		        virtual uint8_t 	getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-          										ADMImage *data,uint32_t *flags);
-			virtual uint8_t 	configure( AVDMGenericVideoStream *instream);
-			virtual uint8_t	getCoupledConf( CONFcouple **couples)		;
- }     ;
-#endif

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidUVSwap.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidUVSwap.cpp	2007-01-13 11:10:25 UTC (rev 2714)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidUVSwap.cpp	2007-01-13 11:31:17 UTC (rev 2715)
@@ -1,102 +0,0 @@
-/***************************************************************************
-                          ADM_vidUVSwap.cpp  -  description
-                             -------------------
-    begin                : Tue Sep 10 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
- #include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <ADM_assert.h>
-
-#include "config.h"
-#include "fourcc.h"
-#include "avio.hxx"
-#include "config.h"
-#include "avi_vars.h"
-#ifdef HAVE_ENCODER
-
-
-#include "ADM_toolkit/toolkit.hxx"
-#include "ADM_editor/ADM_edit.hxx"
-#include "ADM_video/ADM_genvideo.hxx"
-#include "ADM_video/ADM_vidUVSwap.h"
-#include "ADM_filter/video_filters.h"
-
-
-static FILTER_PARAM nullParam={0,{""}};
-
-
-SCRIPT_CREATE(swapuv_script,ADMVideoUVSwap,nullParam);
-BUILD_CREATE(swapuv_create,ADMVideoUVSwap);
-
-char *ADMVideoUVSwap::printConf( void )
-{
- 	static char buf[50];
-
- 	sprintf((char *)buf," UV Swap");
-        return buf;
-}
-
-ADMVideoUVSwap::ADMVideoUVSwap(  AVDMGenericVideoStream *in,CONFcouple *setup)
-{
-UNUSED_ARG(setup);
-	_buf=NULL;
- 	_in=in;
-   	memcpy(&_info,_in->getInfo(),sizeof(_info));
-
-		
-  _info.encoding=1;
- _buf=new uint8_t [(_info.width*_info.height)>>2];
-
-
-}
-ADMVideoUVSwap::~ADMVideoUVSwap()
-{
-		if(_buf)
-		{
-            		delete []_buf;
-			_buf=NULL;
-		}
-}
-uint8_t ADMVideoUVSwap::getFrameNumberNoAlloc(uint32_t frame,
-				uint32_t *len,
-   				ADMImage *data,
-				uint32_t *flags)
-{
-
-		ADM_assert(frame<_info.nb_frames);
-		// read uncompressed frame
-       		if(!_in->getFrameNumberNoAlloc(frame, len,data,flags)) return 0;
-
-		uint32_t sz;
-		uint8_t *start;
-					
-			sz=_info.width*_info.height;
-			sz>>=2;
-				
-			start=UPLANE(data);
-			memcpy(_buf,start,sz);
-					
-			memcpy(UPLANE(data),VPLANE(data),sz);
-			memcpy(VPLANE(data),_buf,sz);
-			
-
-
-      return 1;
-}
-
-
-
-#endif

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidUVSwap.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidUVSwap.h	2007-01-13 11:10:25 UTC (rev 2714)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidUVSwap.h	2007-01-13 11:31:17 UTC (rev 2715)
@@ -1,37 +0,0 @@
-/***************************************************************************
-                          ADM_vidUVSwap.h  -  description
-                             -------------------
-    begin                : Tue Sep 10 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifndef UVSWAP_
-#define UVSWAP_
-
- class  ADMVideoUVSwap:public AVDMGenericVideoStream
- {
-
- protected:
-
-           virtual 	char					*printConf(void);
-			uint8_t				*_buf;
-
- public:
-
-  						ADMVideoUVSwap(  AVDMGenericVideoStream *in,CONFcouple *setup);
-  			virtual 		~ADMVideoUVSwap();
-		        virtual uint8_t 	getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-          							ADMImage *data,uint32_t *flags);
-			virtual uint8_t 	configure( AVDMGenericVideoStream *instream) { UNUSED_ARG(instream); return 1;};
-
- }     ;
-#endif

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidVlad.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidVlad.cpp	2007-01-13 11:10:25 UTC (rev 2714)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidVlad.cpp	2007-01-13 11:31:17 UTC (rev 2715)
@@ -1,531 +0,0 @@
-/***************************************************************************
-                          ADM_vidVlad.cpp  -  description
-                             -------------------
-    begin                : Fri Jan 3 2003
-    copyright            : (C) 2003 by mean
-    email                : fixounet at free.fr
-    
-    Port from Vlad59 / Jim Casaburi TemporalCleaner from avisynth YV12
-    
-    Luma only
-   	Patch by Daniel Glockner 
-    
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <ADM_assert.h>
-
-#include "config.h"
-#include "fourcc.h"
-#include "avio.hxx"
-#include "config.h"
-#include "avi_vars.h"
-#include "admmangle.h"
-
-#include "ADM_toolkit/toolkit.hxx"
-#include "ADM_editor/ADM_edit.hxx"
-#include "ADM_video/ADM_genvideo.hxx"
-#include "ADM_video/ADM_vidVlad.h"
-#include "ADM_filter/video_filters.h"
-#include "ADM_osSupport/ADM_cpuCap.h"
-
-
-
-#if  defined(ARCH_X86_64)
-#define COUNTER long int
-#else
-#define COUNTER int
-#endif
-
-#if defined( ARCH_X86)  || defined(ARCH_X86_64)
-static void ProcessCPlane_mmxe(unsigned char *source,
-				   unsigned char *prev,
-				   unsigned char* dest,
-				   unsigned char* mask,
-				   int width, int height,
-				   uint64_t  threshold);
-static void ProcessYPlane_mmxe( unsigned char *source,
-				    unsigned char *prev,
-				    unsigned char* dest,
-				    unsigned char* mask,
-				    long  int width, long int height,
-				    uint64_t  threshold);
-#endif
-static void ProcessCPlane_C(unsigned char *source,
-				   unsigned char *prev,
-				   unsigned char* dest,
-				   unsigned char* mask,
-				   int width, int height,
-				   uint64_t  threshold);
-static void ProcessYPlane_C( unsigned char *source,
-				    unsigned char *prev,
-				    unsigned char* dest,
-				    unsigned char* mask,
-				    long  int width, long int height,
-				    uint64_t  threshold);
-
-#define EXPAND(x) { x=x+(x<<8)+(x<<16)+(x<<24)+(x<<32)+(x<<40) \
-										+(x<<48)+(x<<56);}
-static FILTER_PARAM vladParam={2,{"ythresholdMask","cthresholdMask"}};
-
-
-SCRIPT_CREATE(vladsmooth_script,AVDMVideoVlad,vladParam);
-BUILD_CREATE(vladsmooth_create,AVDMVideoVlad);
-
-
-char *AVDMVideoVlad::printConf(void)
-{
-	static char buf[50];
- 	
-	sprintf((char *)buf," Temporal Cleaner : Y: %02lu / c: %02lu",_param->ythresholdMask,
-				_param->cthresholdMask	);
-        return buf;
-}
-
-
-uint8_t AVDMVideoVlad::configure( AVDMGenericVideoStream *instream)
-{
-UNUSED_ARG(instream);
-int i,j;
-		i=_param->ythresholdMask;
-		j=_param->cthresholdMask;
-	  	if(GUI_getIntegerValue(&i,0,255,"Luma Temporal  Threshold"))
-		{			
-			if(GUI_getIntegerValue(&j,0,255,"Chroma Temporal  Threshold"))
-			{
-				_param->ythresholdMask=i;
-				_param->cthresholdMask=j;
-		 		ythresholdMask = (uint64_t)_param->ythresholdMask;
-	   			cthresholdMask = (uint64_t)_param->cthresholdMask;	   
-
-				EXPAND(	ythresholdMask);
-				EXPAND(	cthresholdMask);					
-				return 1;				
-			}		
-		}
-		return 0;
-}     											
-AVDMVideoVlad::AVDMVideoVlad(  AVDMGenericVideoStream *in,CONFcouple *couples)
-		
-
-{
-	_in=in;
-	memcpy(&_info,_in->getInfo(),sizeof(_info));
-	num_frame=0xFFFF0000;
-	if(couples)
-	{
-		_param=NEW(VLAD_PARAM);
-		GET(ythresholdMask);
-		GET(cthresholdMask);
-	}
-	else
-	{
-		_param=NEW(VLAD_PARAM);
-		ADM_assert(_param);
-	  _param->ythresholdMask=5;
- 	  _param->cthresholdMask=0;
-   }
-    	_mask=new uint8_t[_info.width*_info.height/4];
-  	memset(_mask,0,	_info.width*_info.height/4);
-	  
-	   ythresholdMask=0;
-	   ythresholdMask = (uint64_t)_param->ythresholdMask;
-	   cthresholdMask = (uint64_t)_param->cthresholdMask;	   
-
-		EXPAND(	ythresholdMask);
-		EXPAND(	cthresholdMask);
-	vidCache=new VideoCache(2,in);
-
-	ProcessYPlane = ProcessYPlane_C;
-	ProcessCPlane = ProcessCPlane_C;
-#if defined( ARCH_X86)  || defined(ARCH_X86_64)
-#if 0
-// Check
-	if(CpuCaps::hasMMXEXT() && (_info.width&7) == 0)
-	{
-		ProcessYPlane = ProcessYPlane_mmxe;
-		ProcessCPlane = ProcessCPlane_mmxe;
-	}
-#endif	
-#endif
-}
-
-
-uint8_t	AVDMVideoVlad::getCoupledConf( CONFcouple **couples)
-{
-
-			ADM_assert(_param);
-			*couples=new CONFcouple(2);
-
-#define CSET(x)  (*couples)->setCouple((char *)#x,(_param->x))
-	CSET(ythresholdMask);
-	CSET(cthresholdMask);
-	return 1;
-
-}
-AVDMVideoVlad::~AVDMVideoVlad()
-{
-		delete [] _mask;
-		DELETE(_param);
-		delete vidCache;
-}  									
-
-void ProcessYPlane_C( unsigned char *source,
-				    unsigned char *prev,
-				    unsigned char* dest,
-				    unsigned char* mask, 
-				    long  int width, long int height,
-				    uint64_t  threshold)
-{
-	int thp=threshold&0xff;
-	int thn=-thp;
-	
-	width >>= 1;
-
-	for (int y = height >> 1; --y >= 0;)
-	{
-		int x2 = -width;
-		int x = x2*2;
-
-		source += 4*width;
-		prev += 4*width;
-		dest += 4*width;
-		mask += width;
-
-		do {
-			int yc,yp;
-			int m = 0;
-			yc=source[x*2];
-			yp=prev[x*2];
-			if(thn<=yc-yp && yc-yp<=thp) {
-				yc=(yc+yp+1)>>1;
-				m=1;
-			}
-			source[x*2]=dest[x*2]=yc;
-
-			yc=source[x*2+1];
-			yp=prev[x*2+1];
-			if(thn<=yc-yp && yc-yp<=thp) {
-				yc=(yc+yp+1)>>1;
-				m++;
-			}
-			source[x*2+1]=dest[x*2+1]=yc;
-
-			x++;
-
-			yc=source[x2*2];
-			yp=prev[x2*2];
-			if(thn<=yc-yp && yc-yp<=thp) {
-				yc=(yc+yp+1)>>1;
-				m++;
-			}
-			source[x2*2]=dest[x2*2]=yc;
-
-			yc=source[x2*2+1];
-			yp=prev[x2*2+1];
-			if(thn<=yc-yp && yc-yp<=thp) {
-			  yc=(yc+yp+1)>>1;
-			  m++;
-			}
-			source[x2*2+1]=dest[x2*2+1]=yc;
-
-			mask[x2]=m;
-		} while(++x2 < 0);
-	}
-}
-
-void ProcessCPlane_C( unsigned char *source,
-				    unsigned char *prev,
-				    unsigned char* dest,
-				    unsigned char* mask, 
-				    int width, int height,
-				    uint64_t  threshold)
-{
-	int thp = threshold&0xff;
-	int thn = -thp;
-	long int i = width*height;
-	
-	source += i;
-	prev += i;
-	dest += i;
-	mask += i;
-	i = -i;
-	
-	do {
-		int cc,cp;
-		cc=source[i];
-		cp=prev[i];
-		if(thn<=cc-cp && cc-cp<=thp && mask[i]>3) {
-			cc=(cc+cp+1)>>1;
-		}
-		source[i]=dest[i]=cc;
-	} while(++i < 0);
-}
-
-#if defined( ARCH_X86)  || defined(ARCH_X86_64)
-void ProcessYPlane_mmxe( unsigned char *source,
-				    unsigned char *prev,
-				    unsigned char* dest,
-				    unsigned char* mask, 
-				    long  int width, long int height,
-				    uint64_t  threshold)
-{
-	COUNTER tmp,tmp2;
-	long int  h2, w8;
-
-	w8 = -(width >> 3);
-	width >>= 1;
-
-__asm__ __volatile__(
-			"movq (%0),%%mm6 \n\t"
-			:
-			: "r"(&threshold)
-		);
-	
-	for (h2 = height >> 1; --h2 >= 0;)
-	{
-		source += 4*width;
-		prev += 4*width;
-		dest += 4*width;
-		mask += width;
-
-#define REG_source "%2"
-#define REG_dest "%3"
-#define REG_prev "%4"
-#define REG_mask "%5"
-#define REG_counter "%0"
-#define REG_counter2 "%1"
-	  
-__asm__ __volatile__(
-"prefetchnta ("REG_source","REG_counter",8) \n\t"
-"prefetchnta ("REG_prev","REG_counter",8) \n\t"
-".p2align 4\n\t"
-"pxor %%mm7,%%mm7\n\t"
-"HLine%=:  \n\t"
-
-"prefetchnta ("REG_source","REG_counter2",8) \n\t"
-"prefetchnta ("REG_prev","REG_counter2",8) \n\t"
-
-"movq ("REG_source","REG_counter",8),%%mm0 \n\t"   // mm0 <- lsource+(size/8)*8
-"movq ("REG_prev","REG_counter",8),%%mm1 \n\t"     // mm1 <- lprev+(size/8)*8
-"movq %%mm0,%%mm2 \n\t"               // mm2 <- mm0  source
-"movq %%mm1,%%mm3 \n\t"               // mm3 <-mm1   oold
-"psubusb %%mm1,%%mm0 \n\t"            // mm0=mm0-mm1
-"psubusb %%mm2,%%mm1 \n\t"            // mm1=mm1-mm2
-"por %%mm1,%%mm0 \n\t"                // mm0=mm0 or mm1
-"pavgb %%mm2,%%mm3 \n\t"              // mm3= 'mm2+mm3"/2
-" \n\t"                               // mm0=mm6-mm0 diff to threshold
-"psubusb %%mm6,%%mm0 \n\t"  // >0 ?
-"pcmpeqb %%mm7,%%mm0 \n\t"
-" \n\t"
-"movq %%mm0,%%mm4 \n\t"               // masked diff >m4
-" \n\t"
-"pand %%mm0,%%mm3 \n\t"               // mm0=old and mask diff
-"pandn %%mm2,%%mm0 \n\t"              // mm1= source and invert diff
-"por %%mm3,%%mm0 \n\t"                // m0 = mix
-"movq %%mm0,("REG_dest","REG_counter",8) \n\t"   // store to des+ecx*8
-"movq %%mm0,("REG_source","REG_counter",8) \n\t" // store to mask+ecx*8
-
-"movq ("REG_source","REG_counter2",8),%%mm0 \n\t"  // mm0 <- lsource+(size/8)*8
-"movq ("REG_prev","REG_counter2",8),%%mm1 \n\t"    // mm1 <- lprev+(size/8)*8
-
-"prefetchnta 8("REG_source","REG_counter",8) \n\t"
-"prefetchnta 8("REG_prev","REG_counter",8) \n\t"
-"add $1,"REG_counter" \n\t"
-
-"movq %%mm0,%%mm2 \n\t"               // mm2 <- mm0  source
-"movq %%mm1,%%mm3 \n\t"               // mm3 <- mm1  oold
-"psubusb %%mm1,%%mm0 \n\t"            // mm0=mm0-mm1
-"psubusb %%mm2,%%mm1 \n\t"            // mm1=mm1-mm2
-"por %%mm1,%%mm0 \n\t"                // mm0=mm0 or mm1
-"pavgb %%mm2,%%mm3 \n\t"              // mm3= 'mm2+mm3"/2
-" \n\t"                               // mm0=mm6-mm0 diff to threshold
-"psubusb %%mm6,%%mm0 \n\t"  // >0 ?
-"pcmpeqb %%mm7,%%mm0 \n\t"
-" \n\t"
-
-"pand %%mm0,%%mm4 \n\t"
-"movq %%mm4,%%mm1 \n\t"               // masked diff -> mm1
-"psrlw $8,%%mm4 \n\t"                 // shift
-"pand %%mm4,%%mm1 \n\t"               // if right & left triggered
-"packuswb %%mm1,%%mm1 \n\t"           // packed to 4 bytes
-"movd %%mm1,("REG_mask","REG_counter2",4) \n\t"     // store mask m4->mask+ecx*4
-
-" \n\t"
-"pand %%mm0,%%mm3 \n\t"               // mm3 = old and mask diff
-"pandn %%mm2,%%mm0 \n\t"              // mm0 = source and invert diff
-"por %%mm3,%%mm0 \n\t"                // mm0 = mix
-"movq %%mm0,("REG_dest","REG_counter2",8) \n\t"   // store to des+ecx*8
-"movq %%mm0,("REG_source","REG_counter2",8) \n\t" // store to mask+ecx*8
-
-
-"add $1,"REG_counter2" \n\t"          // add 1 to ecv
-"jnz HLine%="                         // while !=0
- : "=r"(tmp), "=r"(tmp2)
- : "r"(source), "r"(dest), "r"(prev),
-   "r"(mask)
-   , "0"(2*w8), "1"(w8)
- );
-
-	}
- __asm__ __volatile__("emms \n\t");
-}
-
-
-//#pragma -O0
-
-void ProcessCPlane_mmxe(unsigned char *source,
-				   unsigned char *prev, 
-				   unsigned char* dest, 
-				   unsigned char* mask, 
-				   int width, int height,
-				   uint64_t  threshold)
-{
-	long int w8;
-	COUNTER tmp;
-
-	w8 = width*height;
-	source += w8;
-	dest += w8;
-	prev += w8;
-	mask += w8;
-	w8 = -(w8>>3);
-
-__asm__ __volatile__(
-			"movq (%0),%%mm6 \n\t"
-			:
-			: "r"(&threshold)
-		);
-	
-__asm__ __volatile__ (
-"prefetchnta ("REG_source","REG_counter",8) \n\t"
-"prefetchnta ("REG_prev","REG_counter",8) \n\t"
-"prefetchnta ("REG_mask","REG_counter",8) \n\t"
-".p2align 4\n\t"
-"pxor %%mm7,%%mm7\n\t"
-"Lfoo%=:  \n\t"
-"prefetchnta 8("REG_source","REG_counter",8) \n\t"
-"prefetchnta 8("REG_prev","REG_counter",8) \n\t"
-"prefetchnta 8("REG_mask","REG_counter",8) \n\t"
-"movq ("REG_source","REG_counter",8),%%mm0 \n\t"
-"movq ("REG_prev","REG_counter",8),%%mm1 \n\t"
-"movq %%mm0,%%mm2 \n\t"
-"movq %%mm1,%%mm3 \n\t"
-"psubusb %%mm1,%%mm0 \n\t"
-"psubusb %%mm2,%%mm1 \n\t"
-"por %%mm1,%%mm0 \n\t"
-"pavgb %%mm2,%%mm3 \n\t"
-" \n\t"
-"psubusb %%mm6,%%mm0 \n\t"
-"pcmpeqb %%mm7,%%mm0 \n\t"
-" \n\t"
-"pand ("REG_mask","REG_counter",8),%%mm0 \n\t"
-" \n\t"
-"pand %%mm0,%%mm3 \n\t"
-"pandn %%mm2,%%mm0 \n\t"
-"por %%mm3,%%mm0 \n\t"
-"movq %%mm0,("REG_dest","REG_counter",8) \n\t"
-"movq %%mm0,("REG_source","REG_counter",8) \n\t"
-"add $1,"REG_counter" \n\t"
-"jnz Lfoo%= \n\t"
- : "=r"(tmp)
- : "0"(w8), "r"(source), "r"(dest), "r"(prev),
-   "r"(mask)
- 
- );
-	__asm__ __volatile__("emms \n\t");
-}
-#endif
-
-//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
-//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
-//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
-//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
-uint8_t AVDMVideoVlad::getFrameNumberNoAlloc(uint32_t frame,
-				uint32_t *len,
-   				ADMImage *data,
-				uint32_t *flags)
-{
-	
-	uint32_t page=_info.width*_info.height;
-	ADMImage *cur,*prev;
-	
-		if(frame>(_info.nb_frames-1)) return 0;
-		
-		*len=(page*3)>>1;
-		
-		if(frame)
-		{
-		 	prev=vidCache->getImage(frame-1);
-			if(!prev)
-				return 0;
-		}
-		
-		cur=vidCache->getImage(frame);
-		if(!cur)
-		{
-			vidCache->unlockAll();
-			return 0;
-		}
-		data->copyInfo(cur);
-		if(!frame)
-		{
-			
-			data->duplicate(cur);
-			vidCache->unlockAll();
-			return 1  ;
-		}
-		
-		
-			  
-		ProcessYPlane (YPLANE(cur),
-				YPLANE(prev),     	
-				YPLANE(data), 
-				_mask, 
-				_info.width, 
-		       		_info.height,
-				ythresholdMask);
-		if (0==_param->cthresholdMask)
-		{
-			//memcpy(data->data+page,_uncompressed->data+page,page>>1);
-			memcpy(UPLANE(data),UPLANE(cur),page>>2);
-			memcpy(VPLANE(data),VPLANE(cur),page>>2);
-		}
-		else
-		{
-			
-				ProcessCPlane (UPLANE(cur),
-							UPLANE(prev),     	
-							UPLANE(data), 
-							_mask, 
-							_info.width>>1, 
-							_info.height>>1,
-							cthresholdMask);       
-				
-			
-				ProcessCPlane (VPLANE(cur),
-							VPLANE(prev),     	
-							VPLANE(data), 
-							_mask, 
-							_info.width>>1, 
-							_info.height>>1,
-							cthresholdMask);       				
-			
-			}
-		
-		vidCache->unlockAll();
-		return 1;
-
-}
-
-

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidVlad.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidVlad.h	2007-01-13 11:10:25 UTC (rev 2714)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidVlad.h	2007-01-13 11:31:17 UTC (rev 2715)
@@ -1,62 +0,0 @@
-/***************************************************************************
-                          ADM_vidVlad.h  -  description
-                             -------------------
-    begin                : Fri Jan 3 2003
-    copyright            : (C) 2003 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifndef __VLAD__
-#define __VLAD__   
-#include "ADM_video/ADM_cache.h" 
-typedef struct VLAD_PARAM
-{
-	uint32_t ythresholdMask;
-	uint32_t cthresholdMask;
-}VLAD_PARAM;
- class  AVDMVideoVlad:public AVDMGenericVideoStream
- {
-
- protected:
-
-        			VLAD_PARAM	*_param;
-        			virtual char 	*printConf(void);
-	      			uint8_t		*_mask;
-	      			VideoCache	*vidCache;
-	      			
-        			uint64_t		ythresholdMask;
-				uint64_t 		cthresholdMask;
-				uint32_t 		num_frame;
-				void (*ProcessCPlane)(unsigned char *source,
-				                      unsigned char *prev,
-				                      unsigned char* dest,
-				                      unsigned char* mask,
-				                      int width, int height,
-				                      uint64_t  threshold);
-				void (*ProcessYPlane)(unsigned char *source,
-				                      unsigned char *prev,
-				                      unsigned char* dest,
-				                      unsigned char* mask,
-				                      long int width,
-				                      long int height,
-				                      uint64_t  threshold);
- public:
-
-
-						AVDMVideoVlad(  AVDMGenericVideoStream *in,CONFcouple *setup);
-  					 	~AVDMVideoVlad();
-		        virtual uint8_t 	getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-          							ADMImage *data,uint32_t *flags);
-
-			virtual uint8_t 	configure( AVDMGenericVideoStream *instream);
-			virtual uint8_t	getCoupledConf( CONFcouple **couples)		;
- }     ;
-#endif

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidWirl.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidWirl.cpp	2007-01-13 11:10:25 UTC (rev 2714)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidWirl.cpp	2007-01-13 11:31:17 UTC (rev 2715)
@@ -1,204 +0,0 @@
-
-/***************************************************************************
-                          ADM_vidWhirl.cpp  -  description
-                             -------------------
-    begin                : Fri Jan 3 2003
-    copyright            : (C) 2003 by mean
-    email                : fixounet at free.fr
-    
-    
-   Whrilpool like effect
-    
-    
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <math.h>
-#include <ADM_assert.h>
-
-#include "config.h"
-#include "fourcc.h"
-#include "avio.hxx"
-#include "config.h"
-#include "avi_vars.h"
-
-//#define LOOP
-#include "admmangle.h"
-
-#include "ADM_toolkit/toolkit.hxx"
-#include "ADM_editor/ADM_edit.hxx"
-#include "ADM_video/ADM_genvideo.hxx"
-#include "ADM_video/ADM_vidVlad.h"
-#include "ADM_filter/video_filters.h"
-
-static void Process(uint8_t *src,uint8_t *data, uint32_t width, uint32_t height,double frac);
-
-
-static FILTER_PARAM whirlParam={0,{"ythresholdMask","cthresholdMask"}};
-
-#define STEP_SIZE 150
-static int COS_CALCED[3600];
-static int SIN_CALCED[3600];
-class  AVDMVideoWhirl:public AVDMGenericVideoStream
- {
-
- protected:
-
-        			
-        			virtual 	char *printConf(void);
-						
- public:
-
-
-						AVDMVideoWhirl(  AVDMGenericVideoStream *in,CONFcouple *setup);
-  					 	AVDMVideoWhirl();
-		        virtual uint8_t 	getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-          							ADMImage *data,uint32_t *flags);
-
-			virtual uint8_t 	configure( AVDMGenericVideoStream *instream);
-			
- }     ;
- 
-SCRIPT_CREATE(whirl_script,AVDMVideoWhirl,whirlParam);
-BUILD_CREATE(whirl_create,AVDMVideoWhirl);
-
-char *AVDMVideoWhirl::printConf(void)
-{
-	static char buf[50];
- 	
-	sprintf((char *)buf," Whril");
-        return buf;
-}
-
-
-uint8_t AVDMVideoWhirl::configure( AVDMGenericVideoStream *instream)
-{
-		
-		return 1;
-}     											
-AVDMVideoWhirl::AVDMVideoWhirl(  AVDMGenericVideoStream *in,CONFcouple *couples)
-		
-
-{
-	_in=in;
-	memcpy(&_info,_in->getInfo(),sizeof(_info));
-	_uncompressed= new ADMImage(_info.width,_info.height);
-	
-	#define TWOPI (2*3.1415)
-	double angle;
-	for(int i=0;i<3600;i++)
-	{
-		angle=(double)i;
-		angle/=TWOPI;
-		angle/=10.;
-		COS_CALCED[i]=(int)floor(0.49+65536.*cos(angle));
-		SIN_CALCED[i]=(int)floor(0.49+65536.*sin(angle));
-		
-	}
-}
-
-
-AVDMVideoWhirl::AVDMVideoWhirl()
-{
-	delete _uncompressed;
-}  
-
-
-uint8_t AVDMVideoWhirl::getFrameNumberNoAlloc(uint32_t frame,
-				uint32_t *len,
-   				ADMImage *data,
-				uint32_t *flags)
-{
-	
-	uint32_t page=_info.width*_info.height;
-	ADMImage *cur,*prev;
-	double frac;
-	
-		if(frame>STEP_SIZE)
-			frac=1;
-		else
-			frac=(double)frame/(double)STEP_SIZE;
-		if(frame>(_info.nb_frames-1)) return 0;
-		
-		*len=(page*3)>>1;
-		if(!_in->getFrameNumberNoAlloc(frame,len,_uncompressed,flags)) return 0;
-		
-		data->copyInfo(_uncompressed);
-		Process(YPLANE(_uncompressed),YPLANE(data),_info.width,_info.height,frac);
-		Process(UPLANE(_uncompressed),UPLANE(data),_info.width>>1,_info.height>>1,frac);
-		Process(VPLANE(_uncompressed),VPLANE(data),_info.width>>1,_info.height>>1,frac);
-		
-		return 1;
-
-}
-#define invlen(x) x
-void Process(uint8_t *src,uint8_t *data, uint32_t width, uint32_t height,double frac)
-{
-int	dprime,d;
-int 	pointx,pointy;
-int	fx,fy;
-int	alpha,beta;
-
-uint8_t *wr;
-double angle;
-int 	iang;
-
-	wr=data;
-	frac=10*frac*180./width;
-	for(uint32_t y=0;y<height;y++)
-	{
-	for(uint32_t x=0;x<width;x++)
-	{
-		pointx=x-(width>>1);
-		pointy=y-(height>>1);
-		if(!pointx && !pointy)
-		{
-			// center continue
-			*wr++=*(src+((width*height+width)>>1));
-			continue;
-		}
-		
-		dprime=pointx*pointx+pointy*pointy;
-		dprime=(int)floor(0.49+sqrt(dprime));
-
-//		dprime=abs(pointx)+abs(pointy);		
-		d=invlen(dprime);
-		// rotate 
-		
-		iang=(int)floor((double)d*frac);
-		iang%=3600;
-		
-		alpha=COS_CALCED[iang];
-		beta=SIN_CALCED[iang];
-		
-		fx=alpha*pointx+beta*pointy;
-		fy=-beta*pointx+alpha*pointy;
-		// expand
-		fx=fx>>16;
-		fy=fy>>16;
-		// put back to original
-		pointx=fx+(width>>1);
-		pointy=fy+(height>>1);
-		
-		// Clamp
-		if(pointx<0) pointx=0;
-		if(pointx>width-1) pointx=width-1;
-		if(pointy<0) pointy=0;
-		if(pointy>height-1) pointy=height-1;
-		
-		*(wr++)=*(src+pointx+width*pointy);
-		
-	
-	}
-	}
-}

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidlavdeint.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidlavdeint.cpp	2007-01-13 11:10:25 UTC (rev 2714)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidlavdeint.cpp	2007-01-13 11:31:17 UTC (rev 2715)
@@ -1,123 +0,0 @@
-//
-//
-// C++ Implementation: ADM_vidlavdeint
-//
-// Description: 
-//		Wrapper for libavcode deinterlacer
-//
-// Author: mean <fixounet at free.fr>, (C) 2003
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <ADM_assert.h>
-#include "ADM_lavcodec.h"
-
-#include "config.h"
-#include "fourcc.h"
-#include "avio.hxx"
-#include "config.h"
-#include "avi_vars.h"
-
-
-
-#include "ADM_toolkit/toolkit.hxx"
-#include "ADM_editor/ADM_edit.hxx"
-#include "ADM_video/ADM_genvideo.hxx"
-#include "ADM_video/ADM_vidlavdeint.h"
-//static void decimate(uint8_t *src,uint8_t *target, uint32_t linessrc, uint32_t width);
-#include "ADM_filter/video_filters.h"
-
-
-static FILTER_PARAM nullParam={0,{""}};
-
-
-SCRIPT_CREATE(lavdeint_script,AVDMVideoLavDeint,nullParam);
-BUILD_CREATE(lavdeint_create,AVDMVideoLavDeint);
-
-
-char *AVDMVideoLavDeint::printConf( void )
-{
- 	static char buf[50];
-
- 	sprintf((char *)buf," Lavcodec deinterlacer");
-        return buf;
-}
-
-//_______________________________________________________________
-AVDMVideoLavDeint::AVDMVideoLavDeint(
-									AVDMGenericVideoStream *in,CONFcouple *setup)
-{
-UNUSED_ARG(setup);
-  	_in=in;
-   	memcpy(&_info,_in->getInfo(),sizeof(_info));
-	_uncompressed=new ADMImage(_info.width,_info.height);
-
-
-}
-
-// ___ destructor_____________
-AVDMVideoLavDeint::~AVDMVideoLavDeint()
-{
- 	delete  _uncompressed;
-	_uncompressed=NULL;
-
-}
-
-//
-//	Basically ask a uncompressed frame from editor and ask
-//		GUI to decompress it .
-//
-
-uint8_t AVDMVideoLavDeint::getFrameNumberNoAlloc(uint32_t frame,
-				uint32_t *len,
-   				ADMImage *data,
-				uint32_t *flags)
-{
-//static Image in,out;
-		if(frame>=_info.nb_frames) return 0;
-
-
-		// read uncompressed frame
-       		if(!_in->getFrameNumberNoAlloc(frame, len,_uncompressed,flags)) return 0;
-		data->copyInfo(_uncompressed);
-		// if not %4 -> skip
-		if((_info.width&03) || (_info.height & 3))
-		{
-			printf("\n WIDTH & HEIGHT must be multiple of 4!!\n");
-
-			data->duplicate(_uncompressed);
-			return 1;
-		}
-		// and deinterlace it
-		AVPicture src;
-  		AVPicture dest;
-		uint32_t page=_info.width*_info.height;
-		
-		src.data[0]=YPLANE(_uncompressed);
-		src.data[1]=UPLANE(_uncompressed);
-		src.data[2]=VPLANE(_uncompressed);
-  
-		dest.data[0]=YPLANE(data);
-		dest.data[1]=UPLANE(data);
-		dest.data[2]=VPLANE(data);
-		
-		src.linesize[0]=dest.linesize[0]=_info.width;
-		src.linesize[1]=dest.linesize[1]=_info.width>>1;
-		src.linesize[2]=dest.linesize[2]=_info.width>>1;
-  
-		if (avpicture_deinterlace(&dest,&src,PIX_FMT_YUV420P,_info.width,_info.height)<0)
-		{
-			printf("Error in avpicture deinterlace!\n");
-			return 0;
-		} 	
-
-
-      return 1;
-}
-
-

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidlavdeint.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidlavdeint.h	2007-01-13 11:10:25 UTC (rev 2714)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidlavdeint.h	2007-01-13 11:31:17 UTC (rev 2715)
@@ -1,34 +0,0 @@
-//
-//
-// C++ Interface: ADM_vidlavdeint
-//
-// Description: 
-//
-//
-// Author: mean <fixounet at free.fr>, (C) 2003
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-
-class  AVDMVideoLavDeint:public AVDMGenericVideoStream
- {
-
- protected:
-
-
-        virtual char 		*printConf(void) ;
-
- public:
-  				AVDMVideoLavDeint(  AVDMGenericVideoStream *in,CONFcouple *setup);
-  				~AVDMVideoLavDeint();
-	virtual uint8_t 	getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-          						ADMImage *data,uint32_t *flags);
-
-			virtual uint8_t 	configure( AVDMGenericVideoStream *instream) 
-								{return 0;};
-
-
- }     ;
-
- 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am	2007-01-13 11:10:25 UTC (rev 2714)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am	2007-01-13 11:31:17 UTC (rev 2715)
@@ -8,13 +8,11 @@
 
 libADM_video_a_SOURCES = ADM_vidFields.cpp \
  ADM_vidDeintASM.cpp \
- ADM_vidVlad.cpp \
  ADM_vidSalt.cpp \
  ADM_vidCached.cpp \
  ADM_vidPartial.cpp \
  ADM_vidFont.cpp \
  ADM_vidSRT.cpp \
- ADM_vidStabilize.cpp \
  ADM_vidContrast.cpp \
 	ADM_resizeter.cpp \
  ADM_vidCrop.cpp \
@@ -24,14 +22,12 @@
 	ADM_vidResize.cpp \
  ADM_vidTelecide.cpp \
  ADM_vidTempSmooth.cpp \
- ADM_vidUVSwap.cpp \
 	ADM_vidClean.cpp \
 	ADM_resizebis.cpp \
  ADM_genvideo.cpp \
  ADM_vidRotate.cpp \
  ADM_vidRotate.h \
-	ADM_vidDropOut.cpp \
- ADM_vidDropOut.h ADM_vidResize25.cpp \
+ ADM_vidResize25.cpp \
  ADM_vidSwapFields.cpp \
 	ADM_vidSwapFields.h ADM_vidSeparateField.cpp \
  ADM_vidFieldUtil.cpp \
@@ -44,17 +40,15 @@
 	ADM_vidMPLResize.cpp \
  ADM_vidIVTC.cpp \
  ADM_vidIVTC.h ADM_interlaced.cpp \
-	ADM_interlaced.h ADM_vidPulldown.h ADM_vidPulldown.cpp \
+	ADM_interlaced.h \
  ADM_vidBlend.cpp \
  ADM_vidRaw.cpp \
 	ADM_vidSRTRender.cpp \
  ADM_vidSRTload.cpp \
- ADM_vidlavdeint.cpp \
 	ADM_mpdetc.cpp \
  ADM_vidDecTelecide.cpp \
  ADM_vidDecTelecide.h ADM_cache.cpp \
  ADM_vidDecDec.cpp \
- ADM_vidWirl.cpp \
  ADM_vidEqualizer.cpp \
  ADM_vidVobsub.cpp \
  ADM_vobsubinfo.cpp \
@@ -84,10 +78,8 @@
 ADM_genvideo.hxx ADM_vidDeinterlace.cpp  ADM_vidPartial.cpp \
 ADM_vidDeinterlace.h  ADM_vidPartial.h \
 ADM_vidDelta.cpp  ADM_vidPartial_param.h \
-ADM_vidPulldown.cpp \
- ADM_vidPulldown.h \
-ADM_guiResize.cpp  ADM_vidDropOut.cpp  ADM_vidRaw.cpp \
-ADM_interlaced.cpp ADM_vidDropOut.h  \
+ADM_guiResize.cpp   ADM_vidRaw.cpp \
+ADM_interlaced.cpp  \
 ADM_interlaced.h ADM_vidEq2.cpp  ADM_vidResize.cpp \
 ADM_vidEq2.h  ADM_vidResize25.cpp \
 ADM_vidEqualizer.cpp  ADM_vidReverse.cpp \
@@ -103,8 +95,8 @@
 ADM_vidAnimated.cpp  ADM_vidSeparateField.h \
 ADM_vidAnimated.h  \
 ADM_vidAnimated_param.h   \
-ADM_vidAsharp.cpp   ADM_vidStabilize.cpp \
-ADM_vidFont.cpp ADM_vidStabilize.h \
+ADM_vidAsharp.cpp   \
+ADM_vidFont.cpp \
 ADM_vidBlend.cpp ADM_vidFont.h ADM_vidSwapFields.cpp \
 ADM_vidSwapFields.h \
 ADM_vidSwapSmart.cpp \
@@ -115,18 +107,16 @@
 ADM_vidIVTC.h ADM_vidTelecide.h \
 ADM_vidTempSmooth.cpp \
 ADM_vidTempSmooth.h \
-ADM_vidUVSwap.cpp \
-ADM_vidChromaShift.cpp ADM_vidUVSwap.h \
+ADM_vidChromaShift.cpp \
 ADM_vidChromaShift.h ADM_vidUnblend.cpp \
 ADM_vidClean.cpp ADM_vidUnblend_param.h \
-ADM_vidClean.h ADM_vidVlad.cpp \
-ADM_vidColorYuv.cpp  ADM_vidVlad.h \
+ADM_vidClean.h \
+ADM_vidColorYuv.cpp  \
 ADM_vidColorYuv.h  ADM_vidVobSub.h \
 ADM_vidColorYuv_param.h  ADM_vidVobSubRender.cpp \
 ADM_vidCommonFilter.h  ADM_vidMPLResize.cpp  ADM_vidVobsub.cpp \
-ADM_vidContrast.cpp  ADM_vidMPdelogo.cpp ADM_vidWirl.cpp \
-ADM_vidContrast.h  ADM_vidMPdelogo.h ADM_vidlavdeint.cpp \
-ADM_vidlavdeint.h \
+ADM_vidContrast.cpp  ADM_vidMPdelogo.cpp \
+ADM_vidContrast.h  ADM_vidMPdelogo.h \
 ADM_vobsubinfo.cpp \
 ADM_vidCrop.cpp  ADM_vidMSmooth_param.h  ADM_vobsubinfo.h \
 ASM_vidDenoise.cpp \
@@ -137,7 +127,7 @@
 ####### kdevelop will overwrite this part!!! (end)############
 INCLUDES = $(all_includes) -I../ADM_libraries -I../ADM_libraries/ADM_utilities -I../ADM_libraries/ADM_lavutil \
 			 $(FREETYPE_CFLAGS) $(ALTIVEC_SWITCH) -I../ADM_userInterfaces/ADM_commonUI -I../ADM_inputs
-noinst_HEADERS = ADM_vidlavdeint.h ADM_mpdetc.h \
+noinst_HEADERS = ADM_mpdetc.h \
 					  ADM_cache.h ADM_vidDecTel_param.h ADM_vidDecDec_param.h \
 					ADM_vidMSmooth_param.h ADM_vidEqualizer.h ADM_vobsubinfo.h ADM_vidVobSub.h \
 		ADM_vidEq2.h ADM_vidASS.h

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidBlendRemoval.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidBlendRemoval.cpp	2007-01-13 11:10:25 UTC (rev 2714)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidBlendRemoval.cpp	2007-01-13 11:31:17 UTC (rev 2715)
@@ -84,7 +84,7 @@
             " Smaller value might mean more false positive"));
     diaElemUInteger   noise(PX(noise),_("noise"),0,99,_("If pixel are closer than noise, they are considered to be the same"));
     diaElemUInteger   identical(PX(identical),_("identical"),0,99,_("If metric is less than identical, images are considered identical"));
-    diaElemToggle     show(PX(show),_("identical"),_("Show metric in image (debug)"));
+    diaElemToggle     show(PX(show),_("show"),_("Show metric in image (debug)"));
     
        diaElem *elems[]={&thresh,&noise,&identical,&show};
   

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDropOut.cpp (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDropOut.cpp)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDropOut.cpp	2006-10-31 15:59:58 UTC (rev 2489)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDropOut.cpp	2007-01-13 11:31:17 UTC (rev 2715)
@@ -0,0 +1,226 @@
+/***************************************************************************
+                          ADM_vidDropOut.cpp  -  description
+                             -------------------
+    begin                : Mon Oct 7 2002
+    copyright            : (C) 2002 by Ron Reithoffer 
+    email                : <ron.reithoffer at chello.at>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ADM_assert.h>
+#include <math.h>
+
+#include "config.h"
+#include "fourcc.h"
+#include "avio.hxx"
+#include "config.h"
+#include "avi_vars.h"
+#ifdef HAVE_ENCODER
+
+
+#include "ADM_toolkit/toolkit.hxx"
+#include "ADM_editor/ADM_edit.hxx"
+#include "ADM_video/ADM_genvideo.hxx"
+#include "ADM_vidDropOut.h"
+#include "ADM_filter/video_filters.h"
+#include "ADM_userInterfaces/ADM_commonUI/DIA_factory.h"
+
+static FILTER_PARAM dropParam={1,{"threshold"}};
+
+
+SCRIPT_CREATE(dropout_script,ADMVideoDropOut,dropParam);
+
+
+//extern uint8_t distMatrix[256][256];
+extern uint32_t fixMul[16];
+
+BUILD_CREATE(dropout_create,ADMVideoDropOut);
+//_______________________________________________________________
+ 
+
+char  *ADMVideoDropOut::printConf(void)
+{
+	static char buf[50];
+
+ 	sprintf((char *)buf," DropOut :%ld",*_param);
+        return buf;
+}
+uint8_t  GUI_getIntegerValue(int *valye, int min, int max, char *title);	
+uint8_t ADMVideoDropOut::configure(AVDMGenericVideoStream *instream)
+{
+	_in=instream;
+        
+         diaElemUInteger chroma(_param,_("DropOut Threshold"),1,255);    
+         diaElem *elems[]={&chroma};
+  
+    return diaFactoryRun("Drop Out",sizeof(elems)/sizeof(diaElem *),elems);
+}
+ADMVideoDropOut::~ADMVideoDropOut()
+{
+	DELETE(_param);
+	delete vidCache;
+	vidCache=NULL;
+}
+
+//--------------------------------------------------------	
+ADMVideoDropOut::ADMVideoDropOut(AVDMGenericVideoStream *in,CONFcouple *couples)
+{
+
+  
+	_in=in;
+  	_info.encoding=1;
+	if(couples)
+	{
+  		_param=NEW( uint32_t);
+		couples->getCouple((char *)"threshold",(uint32_t *)_param);
+	}
+	else
+	{
+		_param=NEW( uint32_t);
+		*_param=30;
+	}
+	vidCache=new VideoCache(4,_in);
+	memcpy(&_info,_in->getInfo(),sizeof(_info));
+	
+ 
+}
+
+uint8_t	ADMVideoDropOut::getCoupledConf( CONFcouple **couples)
+{
+
+			ADM_assert(_param);
+			*couples=new CONFcouple(1);
+			(*couples)->setCouple((char *)"threshold",(*_param));
+			return 1;
+
+}
+
+//                     1
+//		Get in range in 121 + coeff matrix
+//                     1
+//
+// If the value is too far away we ignore it
+// else we blend
+
+uint8_t ADMVideoDropOut::getFrameNumberNoAlloc(uint32_t frame,
+				uint32_t *len,
+   				ADMImage *data,
+				uint32_t *flags)
+{
+UNUSED_ARG(flags);
+
+uint32_t uvlen;
+uint32_t dlen,dflags;
+
+ADMImage	*_next;
+ADMImage	*_previous;
+ADMImage	*_current;
+
+	//		printf("\n DropOut : %lu\n",frame);
+
+
+
+
+			uvlen=    _info.width*_info.height;
+			*len=uvlen+(uvlen>>1);
+			  if(frame> _info.nb_frames-1) return 0;
+			if(!frame || (frame==_info.nb_frames-1))
+			{
+				_current=vidCache->getImage(frame);
+				if(!_current) return 0;
+				memcpy(YPLANE(data),YPLANE(_current),uvlen);
+				memcpy(UPLANE(data),UPLANE(_current),uvlen>>2);
+				memcpy(VPLANE(data),VPLANE(_current),uvlen>>2);
+				vidCache->unlockAll();
+				return 1;
+			}
+			
+		_current=vidCache->getImage(frame);
+		_previous=vidCache->getImage(frame-1);
+		_next=vidCache->getImage(frame+1);
+		if(!_current || !_previous || !_next)
+		{
+			vidCache->unlockAll();
+			 return 0;	
+		}
+           	// for u & v , no action -> copy it as is
+           	memcpy(UPLANE(data),UPLANE(_current),uvlen>>2);
+		memcpy(VPLANE(data),VPLANE(_current),uvlen>>2);
+
+             uint8_t *inprev,*innext,*incur,*zout;
+
+              inprev=YPLANE(_previous)+1+_info.width;
+              innext=YPLANE(_next)+1+_info.width;
+              incur =YPLANE(_current)+1+_info.width;
+
+              zout=YPLANE(data)+_info.width+1;
+
+              int32_t c0,c1,c2,c3; //,_nextPix,_currPix,_prevPix,cc;
+
+              for(uint32_t y= _info.height-2;y>2;y--)
+              	{
+		  c0=0;
+		  c1=0;
+		  c2=0;
+		  c3=0;
+
+	  	inprev=YPLANE(_previous)	+1+y*_info.width;
+              	innext=YPLANE(_next)		+1+y*_info.width;;
+              	incur =YPLANE(_current)	+1+y*_info.width;;
+
+			// look if the field is more different temporarily than spacially
+
+			    for(uint32_t x= _info.width-1;x>1;x--)
+        		      	{
+
+						c0+=(abs(((*inprev))-( *incur    ))^2);
+						c1+=(abs(((*inprev))-( *innext   ))^2)<<1;
+						c0+=(abs(((*incur ))-( *innext   ))^2);
+
+
+						c2+=(abs(((    *(incur-_info.width*2) ))-( *(incur            )   ))^2)   ;
+						c3+=(abs(((    *(incur-_info.width*2) ))-( *(incur+_info.width*2)   ))^2)<<1;
+						c2+=(abs(((    *(incur            ) ))-( *(incur+_info.width*2)   ))^2)   ;
+
+
+						incur++;
+						innext++;
+						inprev++;
+				}
+
+		// If yes, replace the line by an average of next/previous image
+		inprev=YPLANE(_previous)	+y*_info.width;
+              	innext=YPLANE(_next)		+y*_info.width;;
+              	incur =YPLANE(_current)		+y*_info.width;;
+		zout=YPLANE(data)		+y*_info.width;
+
+		if (c1<c0 &&c3<c2)
+		{
+		    for(uint32_t x= _info.width;x>0;x--)
+       			      	{
+					*zout= ((*(inprev))+(*(innext)))>>1 ;
+					zout++;
+					innext++;
+					inprev++;
+				}
+		}
+		else
+			memcpy(zout,incur,_info.width);
+	}
+	data->copyInfo(_current);
+	vidCache->unlockAll();
+return 1;
+}
+
+
+#endif

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDropOut.h (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDropOut.h)

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidPulldown.cpp (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidPulldown.cpp)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidPulldown.cpp	2006-10-31 15:59:58 UTC (rev 2489)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidPulldown.cpp	2007-01-13 11:31:17 UTC (rev 2715)
@@ -0,0 +1,183 @@
+/***************************************************************************
+                       Pulldown : Duplicate frame fields to convert
+		       	24 fps to 30 fps movie
+
+			1 2 3 4       1  2  3  4  4
+			1 2 3 4 --> 1  2  2  3  4
+
+
+    begin                : Thu Mar 21 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ADM_assert.h>
+
+#include "config.h"
+#include "fourcc.h"
+#include "avio.hxx"
+#include "config.h"
+#include "avi_vars.h"
+
+
+#include "ADM_toolkit/toolkit.hxx"
+#include "ADM_editor/ADM_edit.hxx"
+#include "ADM_video/ADM_genvideo.hxx"
+#include "ADM_video/ADM_vidFieldUtil.h"
+#include "ADM_vidPulldown.h"
+#include "ADM_video/ADM_interlaced.h"
+#include "ADM_osSupport/TLK_clock.h"
+#include "ADM_osSupport/ADM_debugID.h"
+#define MODULE_NAME MODULE_FILTER
+#include "ADM_osSupport/ADM_debug.h"
+#include "ADM_filter/video_filters.h"
+
+
+static FILTER_PARAM swapParam={0,{""}};
+SCRIPT_CREATE(pulldown_script,ADMVideoPullDown,swapParam);
+BUILD_CREATE(pulldown_create,ADMVideoPullDown);
+
+char *ADMVideoPullDown::printConf( void )
+{
+ 	static char buf[50];
+
+ 	sprintf((char *)buf," Pulldown");
+        return buf;
+}
+//_______________________________________________________________
+ADMVideoPullDown::ADMVideoPullDown(
+									AVDMGenericVideoStream *in,CONFcouple *setup)
+{
+UNUSED_ARG(setup);
+  	_in=in;
+   	memcpy(&_info,_in->getInfo(),sizeof(_info));
+	_info.fps1000=(_info.fps1000*5)/4;
+	_info.nb_frames=(_info.nb_frames*5)/4;
+	for(uint32_t i=0;i<5;i++)
+	{
+		_uncompressed[i]=new ADMImage(_info.width,_info.height);
+	}
+	_cacheStart=0xfffffff;
+}
+// ___ destructor_____________
+ADMVideoPullDown::~ADMVideoPullDown()
+{
+	for(uint32_t i=0;i<5;i++)
+	{
+ 		delete  _uncompressed[i];
+	}
+}
+
+
+uint8_t ADMVideoPullDown::getFrameNumberNoAlloc(uint32_t frame,
+				uint32_t *len,
+   				ADMImage *data,
+				uint32_t *flags)
+{
+//static Image in,out;
+			if(frame>=_info.nb_frames)
+			{
+				printf("out of bound frame (%lu / %lu)\n",frame,_info.nb_frames);
+				return 0;
+			}
+
+		uint32_t w=_info.width;
+		uint32_t h=_info.height;
+		uint32_t page=w*h;
+		uint32_t i;
+
+		uint32_t target;
+		uint32_t loop=0;
+
+		*len=(page*3)>>1;
+
+cont:
+
+		target=frame-((frame)%5);
+		// got it ?
+		if(_cacheStart==target)
+		{
+			uint32_t index;
+
+			aprintf("Filter: It is in cache...(cachestart=%lu)\n",_cacheStart);
+			index=frame%5;
+			aprintf("getting %lu)\n",index);
+			memcpy(YPLANE(data),YPLANE(_uncompressed[index]),page);
+			memcpy(UPLANE(data),UPLANE(_uncompressed[index]),page>>2);
+			memcpy(VPLANE(data),VPLANE(_uncompressed[index]),page>>2);
+			*flags=0;			
+			return 1;
+		}
+		else
+		{
+			aprintf("Not in cache...\n");
+		}
+		// Else ask the 5 corresponding frame
+		_cacheStart=target;
+		target=(target*4)/5;
+
+		uint32_t dflags,dlen;
+#define GET_FRAME(x,y) if(!_in->getFrameNumberNoAlloc(x, &dlen,_uncompressed[y],&dflags)) \
+ {\
+				 	 	printf("Cannot get frame %lu\n",target+i);\
+					 	return 0;     \
+				 }
+
+		GET_FRAME(target+0,0);
+		GET_FRAME(target+1,1);
+		GET_FRAME(target+2,3);
+		GET_FRAME(target+3,4);
+		// copy chroma 1->2
+		memcpy(UPLANE(_uncompressed[2]),UPLANE(_uncompressed[1]),page>>2);
+		memcpy(VPLANE(_uncompressed[2]),VPLANE(_uncompressed[1]),page>>2);
+#define COPY_FIELD \
+		for(uint32_t y=0;y<_info.height>>1;y++) \
+		{ \
+			memcpy(out,in,_info.width); \
+			in+=_info.width<<1; \
+			out+=_info.width<<1; \
+		}
+
+		// now we merge 1 & 3 into 2
+
+		uint8_t *in,*out;
+		in=YPLANE(_uncompressed[1]);
+		out=YPLANE(_uncompressed[2]);
+		COPY_FIELD;
+
+
+		// merge 3->2
+		//
+		//	0 1 x 2 3
+		//      0 1 x 2 3
+		//
+		//  0 1 1 2 3
+		//  0 1 X 2 3
+		in=YPLANE(_uncompressed[3])+w;
+		out=YPLANE(_uncompressed[2])+w;
+		COPY_FIELD;
+		//  0 1 1 2 3
+		//  0 1 2 2 3
+		in=YPLANE(_uncompressed[4])+w;
+		out=YPLANE(_uncompressed[3])+w;
+		//  0 1 1 2 3
+		//  0 1 2 3 3
+		COPY_FIELD;
+		goto cont;
+		return 1;
+}
+
+
+

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidPulldown.h (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidPulldown.h)

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidStabilize.cpp (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidStabilize.cpp)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidStabilize.cpp	2006-10-31 15:59:58 UTC (rev 2489)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidStabilize.cpp	2007-01-13 11:31:17 UTC (rev 2715)
@@ -0,0 +1,212 @@
+/***************************************************************************
+                          ADM_vidStabilize.cpp  -  description
+                             -------------------
+    begin                : Mon Oct 7 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ADM_assert.h>
+#include <math.h>
+
+#include "config.h"
+#include "fourcc.h"
+#include "avio.hxx"
+#include "config.h"
+#include "avi_vars.h"
+#ifdef HAVE_ENCODER
+
+
+#include "ADM_toolkit/toolkit.hxx"
+#include "ADM_editor/ADM_edit.hxx"
+#include "ADM_video/ADM_genvideo.hxx"
+#include "ADM_vidStabilize.h"
+#include "ADM_filter/video_filters.h"
+
+#include "ADM_userInterfaces/ADM_commonUI/DIA_factory.h"
+
+static FILTER_PARAM stabParam={1,{"param"}};
+
+
+SCRIPT_CREATE(stabilize_script,ADMVideoStabilize,stabParam);
+extern uint8_t distMatrix[256][256];
+extern uint32_t fixMul[16];
+
+BUILD_CREATE(stabilize_create,ADMVideoStabilize);
+
+
+
+char 	*ADMVideoStabilize::printConf(void)
+{
+  static char buf[50];
+
+ 	sprintf((char *)buf," Stabilize :%ld",*_param);
+        return buf;
+}
+uint8_t  GUI_getIntegerValue(int *valye, int min, int max, char *title);
+uint8_t ADMVideoStabilize::configure(AVDMGenericVideoStream *instream)
+{
+int i;
+	_in=instream;
+        
+         diaElemUInteger chroma(_param,_("DropOut Threshold"),1,255);    
+         diaElem *elems[]={&chroma};
+  
+    return diaFactoryRun("Stabilize",sizeof(elems)/sizeof(diaElem *),elems);
+	
+}
+//--------------------------------------------------------	
+ADMVideoStabilize::ADMVideoStabilize(AVDMGenericVideoStream *in,CONFcouple *couples)
+{
+  //uint32_t frame;
+  _uncompressed=NULL;
+  _in=in;
+  memcpy(&_info,in->getInfo(),sizeof(_info)); 
+ 
+  _info.encoding=1;
+  if(couples)
+  {
+			_param=NEW(uint32_t);
+			ADM_assert(couples->getCouple((char *)"param",_param));
+	}
+	else
+	{
+			_param=NEW( uint32_t);
+			*_param=30;
+	}
+	vidCache=new VideoCache(5,_in);
+ 
+}
+ADMVideoStabilize::~ADMVideoStabilize()
+{
+ 
+ 	DELETE(_param);
+	if(vidCache) delete vidCache;
+	vidCache=NULL;
+}
+
+
+uint8_t	ADMVideoStabilize::getCoupledConf( CONFcouple **couples)
+{
+
+			ADM_assert(_param);
+			*couples=new CONFcouple(1);
+ 			(*couples)->setCouple((char *)"param",*_param);
+
+			return 1;
+
+}
+//                     1
+//		Get in range in 121 + coeff matrix
+//                     1
+//
+// If the value is too far away we ignore it
+// else we blend
+
+uint8_t ADMVideoStabilize::getFrameNumberNoAlloc(uint32_t frame,
+				uint32_t *len,
+   				ADMImage *data,
+				uint32_t *flags)
+{
+UNUSED_ARG(flags);
+uint32_t uvlen;
+uint32_t dlen,dflags;
+
+ADMImage	*_next;
+ADMImage	*_previous;  	
+ADMImage	*_current;
+		
+		uvlen=    _info.width*_info.height;
+		*len=uvlen+(uvlen>>1);
+		if(frame> _info.nb_frames-1) return 0;
+		_current=vidCache->getImage(frame);
+		if(!_current) return 0;
+		data->copyInfo(_current);
+		if(!frame || (frame==_info.nb_frames-1))
+		{
+
+			data->duplicate(_current);
+			vidCache->unlockAll();
+			return 1;
+		}	 
+   		_previous=vidCache->getImage(frame-1);		
+		if(!_previous)
+		{
+			vidCache->unlockAll();
+			return 0;
+		}
+   		_next=vidCache->getImage(frame+1);
+		if(!_next)
+		{
+			vidCache->unlockAll();
+			return 0;
+		}
+		
+           // for u & v , no action -> copy it as is
+           memcpy(UPLANE(data),UPLANE(_current),uvlen>>2);
+	   memcpy(VPLANE(data),VPLANE(_current),uvlen>>2);
+
+           uint8_t *inprev,*innext,*incur,*zout;
+              
+              inprev=YPLANE(_previous)+1+_info.width;
+              innext=YPLANE(_next)+1+_info.width;
+              incur =YPLANE(_current)+1+_info.width;
+              
+              zout=YPLANE(data)+_info.width+1;
+              
+             
+              uint8_t *nl,*pl,*nc,*pc;
+              
+              uint16_t c,coeff;
+              uint32_t x;
+              for(uint32_t y= _info.height-1;y>1;y--)
+              	{
+			nl=incur+_info.width;
+			pl=incur-_info.width;
+			nc=incur+1;
+			pc=incur-1;		   
+								   
+		        for(x= _info.width-1;x>1;x--)
+        		{
+	               		c=*incur*4;;
+	                    	coeff=4;
+#define PONDERATE(x,p) if(distMatrix[*incur][x]<*_param)	                      \
+{ c+=x;coeff++;}
+																PONDERATE(*innext,1);
+				PONDERATE(*inprev,1);
+				PONDERATE(*(pc),1);
+				PONDERATE(*(nc),1);
+				PONDERATE(*(nl),1);
+				PONDERATE(*(pl),1);
+													//*zout=(uint8_t)floor(0.49+(c/coeff));
+																ADM_assert(coeff);
+				ADM_assert(coeff<16);
+				*zout=(c*fixMul[coeff])>>16;
+				zout++;
+				incur++;
+				innext++;
+				inprev++;	
+				nl++;pl++;nc++;pc++;	  
+			}
+			zout+=2;
+			incur+=2;
+			innext+=2;
+			inprev+=2;
+		}
+		vidCache->unlockAll();
+		return 1;	
+}
+
+
+#endif

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidStabilize.h (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidStabilize.h)

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidUVSwap.cpp (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidUVSwap.cpp)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidUVSwap.cpp	2006-10-31 15:59:58 UTC (rev 2489)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidUVSwap.cpp	2007-01-13 11:31:17 UTC (rev 2715)
@@ -0,0 +1,102 @@
+/***************************************************************************
+                          ADM_vidUVSwap.cpp  -  description
+                             -------------------
+    begin                : Tue Sep 10 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+ #include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ADM_assert.h>
+
+#include "config.h"
+#include "fourcc.h"
+#include "avio.hxx"
+#include "config.h"
+#include "avi_vars.h"
+#ifdef HAVE_ENCODER
+
+
+#include "ADM_toolkit/toolkit.hxx"
+#include "ADM_editor/ADM_edit.hxx"
+#include "ADM_video/ADM_genvideo.hxx"
+#include "ADM_vidUVSwap.h"
+#include "ADM_filter/video_filters.h"
+
+
+static FILTER_PARAM nullParam={0,{""}};
+
+
+SCRIPT_CREATE(swapuv_script,ADMVideoUVSwap,nullParam);
+BUILD_CREATE(swapuv_create,ADMVideoUVSwap);
+
+char *ADMVideoUVSwap::printConf( void )
+{
+ 	static char buf[50];
+
+ 	sprintf((char *)buf," UV Swap");
+        return buf;
+}
+
+ADMVideoUVSwap::ADMVideoUVSwap(  AVDMGenericVideoStream *in,CONFcouple *setup)
+{
+UNUSED_ARG(setup);
+	_buf=NULL;
+ 	_in=in;
+   	memcpy(&_info,_in->getInfo(),sizeof(_info));
+
+		
+  _info.encoding=1;
+ _buf=new uint8_t [(_info.width*_info.height)>>2];
+
+
+}
+ADMVideoUVSwap::~ADMVideoUVSwap()
+{
+		if(_buf)
+		{
+            		delete []_buf;
+			_buf=NULL;
+		}
+}
+uint8_t ADMVideoUVSwap::getFrameNumberNoAlloc(uint32_t frame,
+				uint32_t *len,
+   				ADMImage *data,
+				uint32_t *flags)
+{
+
+		ADM_assert(frame<_info.nb_frames);
+		// read uncompressed frame
+       		if(!_in->getFrameNumberNoAlloc(frame, len,data,flags)) return 0;
+
+		uint32_t sz;
+		uint8_t *start;
+					
+			sz=_info.width*_info.height;
+			sz>>=2;
+				
+			start=UPLANE(data);
+			memcpy(_buf,start,sz);
+					
+			memcpy(UPLANE(data),VPLANE(data),sz);
+			memcpy(VPLANE(data),_buf,sz);
+			
+
+
+      return 1;
+}
+
+
+
+#endif

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidUVSwap.h (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidUVSwap.h)

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidVlad.cpp (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidVlad.cpp)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidVlad.cpp	2006-10-31 15:59:58 UTC (rev 2489)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidVlad.cpp	2007-01-13 11:31:17 UTC (rev 2715)
@@ -0,0 +1,530 @@
+/***************************************************************************
+                          ADM_vidVlad.cpp  -  description
+                             -------------------
+    begin                : Fri Jan 3 2003
+    copyright            : (C) 2003 by mean
+    email                : fixounet at free.fr
+    
+    Port from Vlad59 / Jim Casaburi TemporalCleaner from avisynth YV12
+    
+    Luma only
+   	Patch by Daniel Glockner 
+    
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ADM_assert.h>
+
+#include "config.h"
+#include "fourcc.h"
+#include "avio.hxx"
+#include "config.h"
+#include "avi_vars.h"
+#include "admmangle.h"
+
+#include "ADM_toolkit/toolkit.hxx"
+#include "ADM_editor/ADM_edit.hxx"
+#include "ADM_video/ADM_genvideo.hxx"
+#include "ADM_vidVlad.h"
+#include "ADM_filter/video_filters.h"
+#include "ADM_osSupport/ADM_cpuCap.h"
+
+#include "ADM_userInterfaces/ADM_commonUI/DIA_factory.h"
+
+#if  defined(ARCH_X86_64)
+#define COUNTER long int
+#else
+#define COUNTER int
+#endif
+
+#if defined( ARCH_X86)  || defined(ARCH_X86_64)
+static void ProcessCPlane_mmxe(unsigned char *source,
+				   unsigned char *prev,
+				   unsigned char* dest,
+				   unsigned char* mask,
+				   int width, int height,
+				   uint64_t  threshold);
+static void ProcessYPlane_mmxe( unsigned char *source,
+				    unsigned char *prev,
+				    unsigned char* dest,
+				    unsigned char* mask,
+				    long  int width, long int height,
+				    uint64_t  threshold);
+#endif
+static void ProcessCPlane_C(unsigned char *source,
+				   unsigned char *prev,
+				   unsigned char* dest,
+				   unsigned char* mask,
+				   int width, int height,
+				   uint64_t  threshold);
+static void ProcessYPlane_C( unsigned char *source,
+				    unsigned char *prev,
+				    unsigned char* dest,
+				    unsigned char* mask,
+				    long  int width, long int height,
+				    uint64_t  threshold);
+
+#define EXPAND(x) { x=x+(x<<8)+(x<<16)+(x<<24)+(x<<32)+(x<<40) \
+										+(x<<48)+(x<<56);}
+static FILTER_PARAM vladParam={2,{"ythresholdMask","cthresholdMask"}};
+
+
+SCRIPT_CREATE(vladsmooth_script,AVDMVideoVlad,vladParam);
+BUILD_CREATE(vladsmooth_create,AVDMVideoVlad);
+
+
+char *AVDMVideoVlad::printConf(void)
+{
+	static char buf[50];
+ 	
+	sprintf((char *)buf," Temporal Cleaner : Y: %02lu / c: %02lu",_param->ythresholdMask,
+				_param->cthresholdMask	);
+        return buf;
+}
+
+
+uint8_t AVDMVideoVlad::configure( AVDMGenericVideoStream *instream)
+{
+UNUSED_ARG(instream);
+int i,j;
+
+   diaElemUInteger luma(&(_param->ythresholdMask),_("Luma Temporal Threshold"),0,255);
+   diaElemUInteger chroma(&(_param->cthresholdMask),_("Chroma Temporal Threshold"),0,255);
+    
+    diaElem *elems[]={&luma,&chroma};
+  
+    if(diaFactoryRun("Temporal Cleaner",sizeof(elems)/sizeof(diaElem *),elems))
+    {
+      ythresholdMask = (uint64_t)_param->ythresholdMask;
+      cthresholdMask = (uint64_t)_param->cthresholdMask;	   
+
+      EXPAND(	ythresholdMask);
+      EXPAND(	cthresholdMask);	
+      return 1;
+    }
+    return 0;
+}
+AVDMVideoVlad::AVDMVideoVlad(  AVDMGenericVideoStream *in,CONFcouple *couples)
+		
+
+{
+	_in=in;
+	memcpy(&_info,_in->getInfo(),sizeof(_info));
+	num_frame=0xFFFF0000;
+	if(couples)
+	{
+		_param=NEW(VLAD_PARAM);
+		GET(ythresholdMask);
+		GET(cthresholdMask);
+	}
+	else
+	{
+		_param=NEW(VLAD_PARAM);
+		ADM_assert(_param);
+	  _param->ythresholdMask=5;
+ 	  _param->cthresholdMask=0;
+   }
+    	_mask=new uint8_t[_info.width*_info.height/4];
+  	memset(_mask,0,	_info.width*_info.height/4);
+	  
+	   ythresholdMask=0;
+	   ythresholdMask = (uint64_t)_param->ythresholdMask;
+	   cthresholdMask = (uint64_t)_param->cthresholdMask;	   
+
+		EXPAND(	ythresholdMask);
+		EXPAND(	cthresholdMask);
+	vidCache=new VideoCache(2,in);
+
+	ProcessYPlane = ProcessYPlane_C;
+	ProcessCPlane = ProcessCPlane_C;
+#if defined( ARCH_X86)  || defined(ARCH_X86_64)
+#if 0
+// Check
+	if(CpuCaps::hasMMXEXT() && (_info.width&7) == 0)
+	{
+		ProcessYPlane = ProcessYPlane_mmxe;
+		ProcessCPlane = ProcessCPlane_mmxe;
+	}
+#endif	
+#endif
+}
+
+
+uint8_t	AVDMVideoVlad::getCoupledConf( CONFcouple **couples)
+{
+
+			ADM_assert(_param);
+			*couples=new CONFcouple(2);
+
+#define CSET(x)  (*couples)->setCouple((char *)#x,(_param->x))
+	CSET(ythresholdMask);
+	CSET(cthresholdMask);
+	return 1;
+
+}
+AVDMVideoVlad::~AVDMVideoVlad()
+{
+		delete [] _mask;
+		DELETE(_param);
+		delete vidCache;
+}  									
+
+void ProcessYPlane_C( unsigned char *source,
+				    unsigned char *prev,
+				    unsigned char* dest,
+				    unsigned char* mask, 
+				    long  int width, long int height,
+				    uint64_t  threshold)
+{
+	int thp=threshold&0xff;
+	int thn=-thp;
+	
+	width >>= 1;
+
+	for (int y = height >> 1; --y >= 0;)
+	{
+		int x2 = -width;
+		int x = x2*2;
+
+		source += 4*width;
+		prev += 4*width;
+		dest += 4*width;
+		mask += width;
+
+		do {
+			int yc,yp;
+			int m = 0;
+			yc=source[x*2];
+			yp=prev[x*2];
+			if(thn<=yc-yp && yc-yp<=thp) {
+				yc=(yc+yp+1)>>1;
+				m=1;
+			}
+			source[x*2]=dest[x*2]=yc;
+
+			yc=source[x*2+1];
+			yp=prev[x*2+1];
+			if(thn<=yc-yp && yc-yp<=thp) {
+				yc=(yc+yp+1)>>1;
+				m++;
+			}
+			source[x*2+1]=dest[x*2+1]=yc;
+
+			x++;
+
+			yc=source[x2*2];
+			yp=prev[x2*2];
+			if(thn<=yc-yp && yc-yp<=thp) {
+				yc=(yc+yp+1)>>1;
+				m++;
+			}
+			source[x2*2]=dest[x2*2]=yc;
+
+			yc=source[x2*2+1];
+			yp=prev[x2*2+1];
+			if(thn<=yc-yp && yc-yp<=thp) {
+			  yc=(yc+yp+1)>>1;
+			  m++;
+			}
+			source[x2*2+1]=dest[x2*2+1]=yc;
+
+			mask[x2]=m;
+		} while(++x2 < 0);
+	}
+}
+
+void ProcessCPlane_C( unsigned char *source,
+				    unsigned char *prev,
+				    unsigned char* dest,
+				    unsigned char* mask, 
+				    int width, int height,
+				    uint64_t  threshold)
+{
+	int thp = threshold&0xff;
+	int thn = -thp;
+	long int i = width*height;
+	
+	source += i;
+	prev += i;
+	dest += i;
+	mask += i;
+	i = -i;
+	
+	do {
+		int cc,cp;
+		cc=source[i];
+		cp=prev[i];
+		if(thn<=cc-cp && cc-cp<=thp && mask[i]>3) {
+			cc=(cc+cp+1)>>1;
+		}
+		source[i]=dest[i]=cc;
+	} while(++i < 0);
+}
+
+#if defined( ARCH_X86)  || defined(ARCH_X86_64)
+void ProcessYPlane_mmxe( unsigned char *source,
+				    unsigned char *prev,
+				    unsigned char* dest,
+				    unsigned char* mask, 
+				    long  int width, long int height,
+				    uint64_t  threshold)
+{
+	COUNTER tmp,tmp2;
+	long int  h2, w8;
+
+	w8 = -(width >> 3);
+	width >>= 1;
+
+__asm__ __volatile__(
+			"movq (%0),%%mm6 \n\t"
+			:
+			: "r"(&threshold)
+		);
+	
+	for (h2 = height >> 1; --h2 >= 0;)
+	{
+		source += 4*width;
+		prev += 4*width;
+		dest += 4*width;
+		mask += width;
+
+#define REG_source "%2"
+#define REG_dest "%3"
+#define REG_prev "%4"
+#define REG_mask "%5"
+#define REG_counter "%0"
+#define REG_counter2 "%1"
+	  
+__asm__ __volatile__(
+"prefetchnta ("REG_source","REG_counter",8) \n\t"
+"prefetchnta ("REG_prev","REG_counter",8) \n\t"
+".p2align 4\n\t"
+"pxor %%mm7,%%mm7\n\t"
+"HLine%=:  \n\t"
+
+"prefetchnta ("REG_source","REG_counter2",8) \n\t"
+"prefetchnta ("REG_prev","REG_counter2",8) \n\t"
+
+"movq ("REG_source","REG_counter",8),%%mm0 \n\t"   // mm0 <- lsource+(size/8)*8
+"movq ("REG_prev","REG_counter",8),%%mm1 \n\t"     // mm1 <- lprev+(size/8)*8
+"movq %%mm0,%%mm2 \n\t"               // mm2 <- mm0  source
+"movq %%mm1,%%mm3 \n\t"               // mm3 <-mm1   oold
+"psubusb %%mm1,%%mm0 \n\t"            // mm0=mm0-mm1
+"psubusb %%mm2,%%mm1 \n\t"            // mm1=mm1-mm2
+"por %%mm1,%%mm0 \n\t"                // mm0=mm0 or mm1
+"pavgb %%mm2,%%mm3 \n\t"              // mm3= 'mm2+mm3"/2
+" \n\t"                               // mm0=mm6-mm0 diff to threshold
+"psubusb %%mm6,%%mm0 \n\t"  // >0 ?
+"pcmpeqb %%mm7,%%mm0 \n\t"
+" \n\t"
+"movq %%mm0,%%mm4 \n\t"               // masked diff >m4
+" \n\t"
+"pand %%mm0,%%mm3 \n\t"               // mm0=old and mask diff
+"pandn %%mm2,%%mm0 \n\t"              // mm1= source and invert diff
+"por %%mm3,%%mm0 \n\t"                // m0 = mix
+"movq %%mm0,("REG_dest","REG_counter",8) \n\t"   // store to des+ecx*8
+"movq %%mm0,("REG_source","REG_counter",8) \n\t" // store to mask+ecx*8
+
+"movq ("REG_source","REG_counter2",8),%%mm0 \n\t"  // mm0 <- lsource+(size/8)*8
+"movq ("REG_prev","REG_counter2",8),%%mm1 \n\t"    // mm1 <- lprev+(size/8)*8
+
+"prefetchnta 8("REG_source","REG_counter",8) \n\t"
+"prefetchnta 8("REG_prev","REG_counter",8) \n\t"
+"add $1,"REG_counter" \n\t"
+
+"movq %%mm0,%%mm2 \n\t"               // mm2 <- mm0  source
+"movq %%mm1,%%mm3 \n\t"               // mm3 <- mm1  oold
+"psubusb %%mm1,%%mm0 \n\t"            // mm0=mm0-mm1
+"psubusb %%mm2,%%mm1 \n\t"            // mm1=mm1-mm2
+"por %%mm1,%%mm0 \n\t"                // mm0=mm0 or mm1
+"pavgb %%mm2,%%mm3 \n\t"              // mm3= 'mm2+mm3"/2
+" \n\t"                               // mm0=mm6-mm0 diff to threshold
+"psubusb %%mm6,%%mm0 \n\t"  // >0 ?
+"pcmpeqb %%mm7,%%mm0 \n\t"
+" \n\t"
+
+"pand %%mm0,%%mm4 \n\t"
+"movq %%mm4,%%mm1 \n\t"               // masked diff -> mm1
+"psrlw $8,%%mm4 \n\t"                 // shift
+"pand %%mm4,%%mm1 \n\t"               // if right & left triggered
+"packuswb %%mm1,%%mm1 \n\t"           // packed to 4 bytes
+"movd %%mm1,("REG_mask","REG_counter2",4) \n\t"     // store mask m4->mask+ecx*4
+
+" \n\t"
+"pand %%mm0,%%mm3 \n\t"               // mm3 = old and mask diff
+"pandn %%mm2,%%mm0 \n\t"              // mm0 = source and invert diff
+"por %%mm3,%%mm0 \n\t"                // mm0 = mix
+"movq %%mm0,("REG_dest","REG_counter2",8) \n\t"   // store to des+ecx*8
+"movq %%mm0,("REG_source","REG_counter2",8) \n\t" // store to mask+ecx*8
+
+
+"add $1,"REG_counter2" \n\t"          // add 1 to ecv
+"jnz HLine%="                         // while !=0
+ : "=r"(tmp), "=r"(tmp2)
+ : "r"(source), "r"(dest), "r"(prev),
+   "r"(mask)
+   , "0"(2*w8), "1"(w8)
+ );
+
+	}
+ __asm__ __volatile__("emms \n\t");
+}
+
+
+//#pragma -O0
+
+void ProcessCPlane_mmxe(unsigned char *source,
+				   unsigned char *prev, 
+				   unsigned char* dest, 
+				   unsigned char* mask, 
+				   int width, int height,
+				   uint64_t  threshold)
+{
+	long int w8;
+	COUNTER tmp;
+
+	w8 = width*height;
+	source += w8;
+	dest += w8;
+	prev += w8;
+	mask += w8;
+	w8 = -(w8>>3);
+
+__asm__ __volatile__(
+			"movq (%0),%%mm6 \n\t"
+			:
+			: "r"(&threshold)
+		);
+	
+__asm__ __volatile__ (
+"prefetchnta ("REG_source","REG_counter",8) \n\t"
+"prefetchnta ("REG_prev","REG_counter",8) \n\t"
+"prefetchnta ("REG_mask","REG_counter",8) \n\t"
+".p2align 4\n\t"
+"pxor %%mm7,%%mm7\n\t"
+"Lfoo%=:  \n\t"
+"prefetchnta 8("REG_source","REG_counter",8) \n\t"
+"prefetchnta 8("REG_prev","REG_counter",8) \n\t"
+"prefetchnta 8("REG_mask","REG_counter",8) \n\t"
+"movq ("REG_source","REG_counter",8),%%mm0 \n\t"
+"movq ("REG_prev","REG_counter",8),%%mm1 \n\t"
+"movq %%mm0,%%mm2 \n\t"
+"movq %%mm1,%%mm3 \n\t"
+"psubusb %%mm1,%%mm0 \n\t"
+"psubusb %%mm2,%%mm1 \n\t"
+"por %%mm1,%%mm0 \n\t"
+"pavgb %%mm2,%%mm3 \n\t"
+" \n\t"
+"psubusb %%mm6,%%mm0 \n\t"
+"pcmpeqb %%mm7,%%mm0 \n\t"
+" \n\t"
+"pand ("REG_mask","REG_counter",8),%%mm0 \n\t"
+" \n\t"
+"pand %%mm0,%%mm3 \n\t"
+"pandn %%mm2,%%mm0 \n\t"
+"por %%mm3,%%mm0 \n\t"
+"movq %%mm0,("REG_dest","REG_counter",8) \n\t"
+"movq %%mm0,("REG_source","REG_counter",8) \n\t"
+"add $1,"REG_counter" \n\t"
+"jnz Lfoo%= \n\t"
+ : "=r"(tmp)
+ : "0"(w8), "r"(source), "r"(dest), "r"(prev),
+   "r"(mask)
+ 
+ );
+	__asm__ __volatile__("emms \n\t");
+}
+#endif
+
+//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
+//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
+//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
+//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
+uint8_t AVDMVideoVlad::getFrameNumberNoAlloc(uint32_t frame,
+				uint32_t *len,
+   				ADMImage *data,
+				uint32_t *flags)
+{
+	
+	uint32_t page=_info.width*_info.height;
+	ADMImage *cur,*prev;
+	
+		if(frame>(_info.nb_frames-1)) return 0;
+		
+		*len=(page*3)>>1;
+		
+		if(frame)
+		{
+		 	prev=vidCache->getImage(frame-1);
+			if(!prev)
+				return 0;
+		}
+		
+		cur=vidCache->getImage(frame);
+		if(!cur)
+		{
+			vidCache->unlockAll();
+			return 0;
+		}
+		data->copyInfo(cur);
+		if(!frame)
+		{
+			
+			data->duplicate(cur);
+			vidCache->unlockAll();
+			return 1  ;
+		}
+		
+		
+			  
+		ProcessYPlane (YPLANE(cur),
+				YPLANE(prev),     	
+				YPLANE(data), 
+				_mask, 
+				_info.width, 
+		       		_info.height,
+				ythresholdMask);
+		if (0==_param->cthresholdMask)
+		{
+			//memcpy(data->data+page,_uncompressed->data+page,page>>1);
+			memcpy(UPLANE(data),UPLANE(cur),page>>2);
+			memcpy(VPLANE(data),VPLANE(cur),page>>2);
+		}
+		else
+		{
+			
+				ProcessCPlane (UPLANE(cur),
+							UPLANE(prev),     	
+							UPLANE(data), 
+							_mask, 
+							_info.width>>1, 
+							_info.height>>1,
+							cthresholdMask);       
+				
+			
+				ProcessCPlane (VPLANE(cur),
+							VPLANE(prev),     	
+							VPLANE(data), 
+							_mask, 
+							_info.width>>1, 
+							_info.height>>1,
+							cthresholdMask);       				
+			
+			}
+		
+		vidCache->unlockAll();
+		return 1;
+
+}
+
+

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidVlad.h (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidVlad.h)

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidWhirl.cpp (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidWirl.cpp)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidWirl.cpp	2006-10-31 15:59:58 UTC (rev 2489)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidWhirl.cpp	2007-01-13 11:31:17 UTC (rev 2715)
@@ -0,0 +1,203 @@
+
+/***************************************************************************
+                          ADM_vidWhirl.cpp  -  description
+                             -------------------
+    begin                : Fri Jan 3 2003
+    copyright            : (C) 2003 by mean
+    email                : fixounet at free.fr
+    
+    
+   Whrilpool like effect
+    
+    
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <math.h>
+#include <ADM_assert.h>
+
+#include "config.h"
+#include "fourcc.h"
+#include "avio.hxx"
+#include "config.h"
+#include "avi_vars.h"
+
+//#define LOOP
+#include "admmangle.h"
+
+#include "ADM_toolkit/toolkit.hxx"
+#include "ADM_editor/ADM_edit.hxx"
+#include "ADM_video/ADM_genvideo.hxx"
+#include "ADM_filter/video_filters.h"
+
+static void Process(uint8_t *src,uint8_t *data, uint32_t width, uint32_t height,double frac);
+
+
+static FILTER_PARAM whirlParam={0,{"ythresholdMask","cthresholdMask"}};
+
+#define STEP_SIZE 150
+static int COS_CALCED[3600];
+static int SIN_CALCED[3600];
+class  AVDMVideoWhirl:public AVDMGenericVideoStream
+ {
+
+ protected:
+
+        			
+        			virtual 	char *printConf(void);
+						
+ public:
+
+
+						AVDMVideoWhirl(  AVDMGenericVideoStream *in,CONFcouple *setup);
+  					 	AVDMVideoWhirl();
+		        virtual uint8_t 	getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
+          							ADMImage *data,uint32_t *flags);
+
+			virtual uint8_t 	configure( AVDMGenericVideoStream *instream);
+			
+ }     ;
+ 
+SCRIPT_CREATE(whirl_script,AVDMVideoWhirl,whirlParam);
+BUILD_CREATE(whirl_create,AVDMVideoWhirl);
+
+char *AVDMVideoWhirl::printConf(void)
+{
+	static char buf[50];
+ 	
+	sprintf((char *)buf," Whril");
+        return buf;
+}
+
+
+uint8_t AVDMVideoWhirl::configure( AVDMGenericVideoStream *instream)
+{
+		
+		return 1;
+}     											
+AVDMVideoWhirl::AVDMVideoWhirl(  AVDMGenericVideoStream *in,CONFcouple *couples)
+		
+
+{
+	_in=in;
+	memcpy(&_info,_in->getInfo(),sizeof(_info));
+	_uncompressed= new ADMImage(_info.width,_info.height);
+	
+	#define TWOPI (2*3.1415)
+	double angle;
+	for(int i=0;i<3600;i++)
+	{
+		angle=(double)i;
+		angle/=TWOPI;
+		angle/=10.;
+		COS_CALCED[i]=(int)floor(0.49+65536.*cos(angle));
+		SIN_CALCED[i]=(int)floor(0.49+65536.*sin(angle));
+		
+	}
+}
+
+
+AVDMVideoWhirl::AVDMVideoWhirl()
+{
+	delete _uncompressed;
+}  
+
+
+uint8_t AVDMVideoWhirl::getFrameNumberNoAlloc(uint32_t frame,
+				uint32_t *len,
+   				ADMImage *data,
+				uint32_t *flags)
+{
+	
+	uint32_t page=_info.width*_info.height;
+	ADMImage *cur,*prev;
+	double frac;
+	
+		if(frame>STEP_SIZE)
+			frac=1;
+		else
+			frac=(double)frame/(double)STEP_SIZE;
+		if(frame>(_info.nb_frames-1)) return 0;
+		
+		*len=(page*3)>>1;
+		if(!_in->getFrameNumberNoAlloc(frame,len,_uncompressed,flags)) return 0;
+		
+		data->copyInfo(_uncompressed);
+		Process(YPLANE(_uncompressed),YPLANE(data),_info.width,_info.height,frac);
+		Process(UPLANE(_uncompressed),UPLANE(data),_info.width>>1,_info.height>>1,frac);
+		Process(VPLANE(_uncompressed),VPLANE(data),_info.width>>1,_info.height>>1,frac);
+		
+		return 1;
+
+}
+#define invlen(x) x
+void Process(uint8_t *src,uint8_t *data, uint32_t width, uint32_t height,double frac)
+{
+int	dprime,d;
+int 	pointx,pointy;
+int	fx,fy;
+int	alpha,beta;
+
+uint8_t *wr;
+double angle;
+int 	iang;
+
+	wr=data;
+	frac=10*frac*180./width;
+	for(uint32_t y=0;y<height;y++)
+	{
+	for(uint32_t x=0;x<width;x++)
+	{
+		pointx=x-(width>>1);
+		pointy=y-(height>>1);
+		if(!pointx && !pointy)
+		{
+			// center continue
+			*wr++=*(src+((width*height+width)>>1));
+			continue;
+		}
+		
+		dprime=pointx*pointx+pointy*pointy;
+		dprime=(int)floor(0.49+sqrt(dprime));
+
+//		dprime=abs(pointx)+abs(pointy);		
+		d=invlen(dprime);
+		// rotate 
+		
+		iang=(int)floor((double)d*frac);
+		iang%=3600;
+		
+		alpha=COS_CALCED[iang];
+		beta=SIN_CALCED[iang];
+		
+		fx=alpha*pointx+beta*pointy;
+		fy=-beta*pointx+alpha*pointy;
+		// expand
+		fx=fx>>16;
+		fy=fy>>16;
+		// put back to original
+		pointx=fx+(width>>1);
+		pointy=fy+(height>>1);
+		
+		// Clamp
+		if(pointx<0) pointx=0;
+		if(pointx>width-1) pointx=width-1;
+		if(pointy<0) pointy=0;
+		if(pointy>height-1) pointy=height-1;
+		
+		*(wr++)=*(src+pointx+width*pointy);
+		
+	
+	}
+	}
+}

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am	2007-01-13 11:10:25 UTC (rev 2714)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am	2007-01-13 11:31:17 UTC (rev 2715)
@@ -7,6 +7,12 @@
 #INCLUDES = $(all_includes) 
 
 libADM_videoFilter_a_SOURCES =  \
+ ADM_vidUVSwap.cpp \
+ ADM_vidStabilize.cpp \
+ ADM_vidDropOut.cpp \
+ ADM_vidVlad.cpp \ 
+ ADM_vidWhirl.cpp \
+ ADM_vidPulldown.cpp \
  ADM_vidFlipV.cpp \
  ADM_vidLuma.cpp \
  ADM_vidLargeMedian.cpp \



From mean at mail.berlios.de  Sat Jan 13 12:32:10 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 13 Jan 2007 12:32:10 +0100
Subject: [Avidemux-svn-commit] r2716 -
	branches/avidemux_2.4_branch/avidemux/ADM_video
Message-ID: <200701131132.l0DBWAhm027413@sheep.berlios.de>

Author: mean
Date: 2007-01-13 12:32:09 +0100 (Sat, 13 Jan 2007)
New Revision: 2716

Removed:
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidConvolution.cpp
Log:
cleanup

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidConvolution.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidConvolution.cpp	2007-01-13 11:31:17 UTC (rev 2715)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidConvolution.cpp	2007-01-13 11:32:09 UTC (rev 2716)
@@ -1,321 +0,0 @@
-/***************************************************************************
-                          ADM_vidConvolution.cpp  -  description
-                             -------------------
-
-       General convolution filter
-
-    begin                : Wed Apr 10 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <ADM_assert.h>
-
-#include "config.h"
-#include "fourcc.h"
-#include "avio.hxx"
-#include "config.h"
-#include "avi_vars.h"
-#ifdef HAVE_ENCODER
-
-
-#include "ADM_toolkit/toolkit.hxx"
-#include "ADM_editor/ADM_edit.hxx"
-#include "ADM_video/ADM_genvideo.hxx"
-
-#include"ADM_video/ADM_vidConvolution.hxx"
-#include "ADM_filter/video_filters.h"
-
-
-static FILTER_PARAM convParam={2,{"luma","chroma"}};
-SCRIPT_CREATE(median_script,AVDMFastVideoMedian,convParam);
-SCRIPT_CREATE(mean_script,AVDMFastVideoMean,convParam);
-SCRIPT_CREATE(sharpen_script,AVDMVideoSharpen,convParam);
-SCRIPT_CREATE(gaussian_script,AVDMVideoGaussian,convParam);
-
-
-BUILD_CREATE(median_create,AVDMFastVideoMedian);
-uint8_t  DIA_getLumaChroma(uint32_t *doLuma, uint32_t *doChroma);
- char *AVDMVideoConvolution::printConf(void)
-{
-    ADM_assert(0); // this one is pure
-}
-
-//_______________________________________________________________
-
-AVDMVideoConvolution::AVDMVideoConvolution(
-                                                                        AVDMGenericVideoStream *in,CONFcouple *setup)
-{
-    UNUSED_ARG(setup);
-
-    _in=in;		
-    memcpy(&_info,_in->getInfo(),sizeof(_info));  		
-    _uncompressed=new ADMImage(_in->getInfo()->width,_in->getInfo()->height);
-    ADM_assert(_uncompressed);
-    _U=new uint8_t [_in->getInfo()->width*_in->getInfo()->height];
-    ADM_assert(_U);
-    _V=new uint8_t [_in->getInfo()->width*_in->getInfo()->height];
-    ADM_assert(_V);
-    _info.encoding=1;
-}
-
-
-
-AVDMVideoConvolution::~AVDMVideoConvolution()
-{
-    delete _uncompressed;
-    delete [] _U;
-    delete [] _V;
-
-  _uncompressed=NULL;
-  _U=_V=NULL;
-}
-
-//
-//	Basically ask a uncompressed frame from editor and ask
-//		GUI to decompress it .
-//
-
-uint8_t AVDMVideoConvolution::getFrameNumberNoAlloc(uint32_t frame,
-                      uint32_t *len,
-                      ADMImage *data,
-                      uint32_t *flags)
-{
-uint8_t *dst,*dstu,*dstv,*srcu,*srcv;
-
-                ADM_assert(frame<_info.nb_frames);
-                ADM_assert(_uncompressed);
-                        // read uncompressed frame
-                if(!_in->getFrameNumberNoAlloc(frame, len,_uncompressed,flags)) return 0;
-
-                srcu=_uncompressed->data+( _info.height * _info.width);
-                srcv=srcu+(( _info.height * _info.width)>>2);
-                // expand u & v in buffers
-                dstu=_U;
-                dstv=_V;
-                dst=data->data;
-                for(int32_t y=(int32_t)_info.height>>1;y>0;y--)
-                {
-                      for(int32_t x=(int32_t)_info.width>>1;x>0;x--)
-                      {
-                                          *(dstu+1)=*dstu= *(dstu+1+_info.width)=*(dstu+_info.width)=*srcu++;
-                                          *(dstv+1)=*dstv=*(dstv+1+_info.width)=*(dstv+_info.width)=*srcv++;
-                                          dstu+=2;
-                                          dstv+=2;
-
-                        }
-                      dstu+=_info.width;
-                      dstv+=_info.width;
-                }
-
-
-              // Luma
-              for(int32_t y=0;y<(int32_t)_info.height;y++)
-              {
-                for(int32_t x=0;x<(int32_t)_info.width;x++)
-                {
-                                        *dst++=convolutionKernel(x,y,_uncompressed->data);
-
-                }
-              }
-
-                // Chroma u & v
-                dstu=data->data+( _info.height * _info.width);
-                dstv=dstu+(( _info.height * _info.width)>>2)  ;
-
-              for(int32_t y=0;y<(int32_t)_info.height>>1;y++)
-              {
-                for(int32_t x=0;x<(int32_t)_info.width>>1;x++)
-                 {
-                                *dstu++=(convolutionKernel(2*x,2*y,_U)+convolutionKernel(2*x+1,2*y,_U)+
-                                                convolutionKernel(2*x,2*y+1,_U)+convolutionKernel(2*x,2*y+1,_U))>>2;
-                                        
-                                *dstv++=(convolutionKernel(2*x,2*y,_V)+convolutionKernel(2*x+1,2*y,_V)+
-                                        convolutionKernel(2*x,2*y+1,_V)+convolutionKernel(2*x,2*y+1,_V))>>2;
-
-                }
-              }
-//
-            *flags=0;
-            *len= _info.width*_info.height+(_info.width*_info.height>>1); 
-            data->copyInfo(_uncompressed);
-      return 1;
-}
-
-
-
-//_____________________ sharpen__________________
-uint8_t  AVDMVideoSharpen:: convolutionKernel(int32_t x,int32_t y,uint8_t *data )
-{
-//         -1 -2 -1
-//         -2 16 -2 *1/16
-//         -1 -2 -1
-
-   int32_t o=0;
-
-#define GetPixel(x,y) getPixel(x,y,data)
-           /*
-       		o=GetPixel(x-1,y)+GetPixel(x+1,y)+GetPixel(x,y-1)+GetPixel(x,y+1);
-              o<<=1;
-              o+=GetPixel(x+1,y+1)+GetPixel(x-1,y+1)+GetPixel(x+1,y-1)+GetPixel(x-1,y-1);
-              o=(GetPixel(x,y)*12)-o;
-              o>>=4;
-
-              o>>=1;
-              if(o>128) o=128;
-              if(o<-128) o=-128;
-
-              o=GetPixel(x,y)+o;
-              */
-
-               	o+=GetPixel(x,y-1);
-               	o+=GetPixel(x-1,y);
-                 	o+=GetPixel(x+1,y);	
-                	o+=GetPixel(x,y+1);
-
-              o=(4*GetPixel(x,y))-o;
-
-              o>>=2;
-              // 0.66
-              o=o+3*GetPixel(x,y);
-              o=o/3;
-              // we now have 1.66 value
-              // *5/3
-
-              if(o<0) o=0;
-              if(o>255) o=255;
-
-              return ((uint8_t) o);
-
-
-}
-char *AVDMVideoSharpen::printConf(void)
-{
-  return (char *)"Sharpen";; // this one is pure
-}
-
-
-
- //________________Mean _____________________
-
-uint8_t  AVDMVideoMean:: convolutionKernel(int32_t x,int32_t y,uint8_t *data )
-{
-
-//    1 1 1
-//    1 1 1
-//    1 1 1
-   int32_t o=0;
-
-#define GetPixel(x,y) getPixel(x,y,data)
-
-      for(int32_t xx=-1;xx<2;xx++)
-      {
-        o+=GetPixel(x+xx,y-1);
-        o+=GetPixel(x+xx,y);
-        o+=GetPixel(x+xx,y+1);
-      }
-      o=o/9;
-      return ((uint8_t) o);
-}
-
-char *AVDMVideoMean::printConf(void)
-{
-          return (char *)"Mean";; // this one is pure
-}
-
-
-
- //________________ Median _____________________
-
-uint8_t  AVDMVideoMedian:: convolutionKernel(int32_t x,int32_t y,uint8_t *data )
-{
-
-
-   int32_t o=0,i=0;
-   static uint8_t tab[9];
-
-#define GetPixel(x,y) getPixel(x,y,data)
-
-      for(int32_t xx=-1;xx<2;xx++)
-      {
-          tab[i++]=GetPixel(x+xx,y-1);
-          tab[i++]=GetPixel(x+xx,y);
-          tab[i++]=GetPixel(x+xx,y+1);
-        }
-        // sort tab
-
-          for(uint32_t bo=0;bo<9;bo++)
-          {
-                  for(o=bo;o<9;o++)
-                  {
-                          if( tab[bo]>tab[o])
-                          {
-                                  i=tab[bo];
-                                  tab[bo]=tab[o];
-                                  tab[o]=i;
-                          }
-                  }
-            }
-        return tab[4];
-}
-
-char *AVDMVideoMedian::printConf(void)
-{
-      return (char *)"Median";; // this one is pure
-}
-
-
-
-
- //________________ Gaussian smooth _____________________
-
-uint8_t  AVDMVideoGaussian:: convolutionKernel(int32_t x,int32_t y,uint8_t *data )
-{
-
-//         6 10 10
-//         10 16 10 *1/80
-//          6 10 6
-
-   int32_t o=0;
-
-#define GetPixel(x,y) getPixel(x,y,data)
-      o=  10*GetPixel(x,y-1);
-      o+=  16*GetPixel(x,y);
-      o+=  10*GetPixel(x,y+1);
-
-      o+=6*GetPixel(x+1,y-1);
-      o+=10*GetPixel(x+1,y);
-      o+=6*GetPixel(x+1,y+1);
-
-      o+=6*GetPixel(x-1,y-1);
-      o+=10*GetPixel(x-1,y);
-      o+=6*GetPixel(x-1,y+1);
-
-      o+=40;
-      o>>=3;
-      o/=10;
-
-    return (uint8_t)(o);
-}
-
-char *AVDMVideoGaussian::printConf(void)
-{
-      return (char *)"Gaussian Smooth";; // this one is pure
-}
-
-
-
-#endif
-
-



From mean at mail.berlios.de  Sat Jan 13 12:39:38 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 13 Jan 2007 12:39:38 +0100
Subject: [Avidemux-svn-commit] r2717 -
	branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory
Message-ID: <200701131139.l0DBdcjO008524@sheep.berlios.de>

Author: mean
Date: 2007-01-13 12:39:36 +0100 (Sat, 13 Jan 2007)
New Revision: 2717

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/DIA_dialogFactory.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/FAC_float.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/FAC_integer.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/FAC_menu.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/FAC_toggle.cpp
Log:
Jakub enhancement

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/DIA_dialogFactory.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/DIA_dialogFactory.cpp	2007-01-13 11:32:09 UTC (rev 2716)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/DIA_dialogFactory.cpp	2007-01-13 11:39:36 UTC (rev 2717)
@@ -69,10 +69,17 @@
   GtkWidget *table1;
   
   gtk_window_set_title (GTK_WINDOW (dialog),title );
+  gtk_window_set_resizable (GTK_WINDOW (dialog), FALSE);
+  gtk_container_set_border_width (GTK_CONTAINER (dialog), 6);
+  gtk_dialog_set_has_separator (GTK_DIALOG (dialog), FALSE);
   dialog_vbox1 = GTK_DIALOG (dialog)->vbox;
+  gtk_box_set_spacing (GTK_BOX(dialog_vbox1), 12);
   gtk_widget_show (dialog_vbox1);
   
   table1 = gtk_table_new (nb, 2, FALSE);
+  gtk_table_set_col_spacings (GTK_TABLE (table1), 12);
+  gtk_table_set_row_spacings (GTK_TABLE (table1), 6);
+  gtk_container_set_border_width (GTK_CONTAINER (table1), 6);
   gtk_widget_show (table1);
   gtk_box_pack_start (GTK_BOX (dialog_vbox1), table1, TRUE, TRUE, 0);
   
@@ -81,14 +88,15 @@
     addLine(elems[i],dialog,table1,i);
     
   }
-  // Add ok & cancel button
-  GtkWidget *cancelbutton1,*okbutton1;
-  
+  // Add a Close button
+  GtkWidget *okbutton1;
+  GtkWidget *cancelbutton1;
+
   cancelbutton1 = gtk_button_new_from_stock ("gtk-cancel");
   gtk_widget_show (cancelbutton1);
   gtk_dialog_add_action_widget (GTK_DIALOG (dialog), cancelbutton1, GTK_RESPONSE_CANCEL);
   GTK_WIDGET_SET_FLAGS (cancelbutton1, GTK_CAN_DEFAULT);
-
+  
   okbutton1 = gtk_button_new_from_stock ("gtk-ok");
   gtk_widget_show (okbutton1);
   gtk_dialog_add_action_widget (GTK_DIALOG (dialog), okbutton1, GTK_RESPONSE_OK);

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/FAC_float.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/FAC_float.cpp	2007-01-13 11:32:09 UTC (rev 2716)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/FAC_float.cpp	2007-01-13 11:39:36 UTC (rev 2717)
@@ -51,11 +51,12 @@
   GtkObject *adj;
   GtkWidget *label;
   
-  label = gtk_label_new (paramTitle);
+  label = gtk_label_new_with_mnemonic (paramTitle);
+  gtk_misc_set_alignment (GTK_MISC (label), 0.0, 0.5);
   gtk_widget_show(label);
   
   gtk_table_attach (GTK_TABLE (opaque), label, 0, 1, line, line+1,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                    (GtkAttachOptions) (GTK_FILL),
                     (GtkAttachOptions) (0), 0, 0);
   
   ELEM_TYPE_FLOAT val=*(ELEM_TYPE_FLOAT *)param;
@@ -70,8 +71,8 @@
                     (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
                     (GtkAttachOptions) (0), 0, 0);
   
+  gtk_label_set_mnemonic_widget (GTK_LABEL(label), widget);
   
-  
   myWidget=(void *)widget;
   
 }

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/FAC_integer.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/FAC_integer.cpp	2007-01-13 11:32:09 UTC (rev 2716)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/FAC_integer.cpp	2007-01-13 11:39:36 UTC (rev 2717)
@@ -50,11 +50,12 @@
   GtkObject *adj;
   GtkWidget *label;
   
-  label = gtk_label_new (paramTitle);
+  label = gtk_label_new_with_mnemonic (paramTitle);
+  gtk_misc_set_alignment (GTK_MISC (label), 0.0, 0.5);
   gtk_widget_show(label);
   
   gtk_table_attach (GTK_TABLE (opaque), label, 0, 1, line, line+1,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                    (GtkAttachOptions) (GTK_FILL),
                     (GtkAttachOptions) (0), 0, 0);
   
   int32_t val=*(int32_t *)param;
@@ -69,8 +70,8 @@
                     (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
                     (GtkAttachOptions) (0), 0, 0);
   
+  gtk_label_set_mnemonic_widget (GTK_LABEL(label), widget);
   
-  
   myWidget=(void *)widget;
   
 }
@@ -106,11 +107,12 @@
   GtkObject *adj;
   GtkWidget *label;
   
-  label = gtk_label_new (paramTitle);
+  label = gtk_label_new_with_mnemonic (paramTitle);
+  gtk_misc_set_alignment (GTK_MISC (label), 0.0, 0.5);
   gtk_widget_show(label);
   
   gtk_table_attach (GTK_TABLE (opaque), label, 0, 1, line, line+1,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                    (GtkAttachOptions) (GTK_FILL),
                     (GtkAttachOptions) (0), 0, 0);
   
   uint32_t val=*(uint32_t *)param;
@@ -125,8 +127,8 @@
                     (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
                     (GtkAttachOptions) (0), 0, 0);
   
+  gtk_label_set_mnemonic_widget (GTK_LABEL(label), widget);
   
-  
   myWidget=(void *)widget;
   
 }

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/FAC_menu.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/FAC_menu.cpp	2007-01-13 11:32:09 UTC (rev 2716)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/FAC_menu.cpp	2007-01-13 11:39:36 UTC (rev 2717)
@@ -53,11 +53,12 @@
   GtkWidget *combo;
   
   
-  label = gtk_label_new (paramTitle);
+  label = gtk_label_new_with_mnemonic (paramTitle);
+  gtk_misc_set_alignment (GTK_MISC (label), 0.0, 0.5);
   gtk_widget_show(label);
   
   gtk_table_attach (GTK_TABLE (opaque), label, 0, 1, line, line+1,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                    (GtkAttachOptions) (GTK_FILL),
                     (GtkAttachOptions) (0), 0, 0);
   
   combo = gtk_combo_box_new_text ();
@@ -66,6 +67,8 @@
                     (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
                     (GtkAttachOptions) (0), 0, 0);
   
+  gtk_label_set_mnemonic_widget (GTK_LABEL(label), combo);
+  
   for(int i=0;i<nbMenu;i++)
   {
     gtk_combo_box_append_text (GTK_COMBO_BOX (combo),this->menu[i].text);

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/FAC_toggle.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/FAC_toggle.cpp	2007-01-13 11:32:09 UTC (rev 2716)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/FAC_toggle.cpp	2007-01-13 11:39:36 UTC (rev 2717)
@@ -45,21 +45,12 @@
 void diaElemToggle::setMe(void *dialog, void *opaque,uint32_t line)
 {
   GtkWidget *widget;
-  GtkWidget *label;
   
-  
-  label = gtk_label_new (paramTitle);
-  gtk_widget_show(label);
-  
-  gtk_table_attach (GTK_TABLE (opaque), label, 0, 1, line, line+1,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  
-  widget = gtk_check_button_new_with_mnemonic ("");
+  widget = gtk_check_button_new_with_mnemonic (paramTitle);
   gtk_widget_show (widget);
   myWidget=(void *)widget;
   
-  gtk_table_attach (GTK_TABLE (opaque), widget, 1, 2, line, line+1,
+  gtk_table_attach (GTK_TABLE (opaque), widget, 0, 2, line, line+1,
                     (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
                     (GtkAttachOptions) (0), 0, 0);
   gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (widget), *(uint32_t *)param);



From mean at mail.berlios.de  Sat Jan 13 12:40:21 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 13 Jan 2007 12:40:21 +0100
Subject: [Avidemux-svn-commit] r2718 -
	branches/avidemux_2.4_branch/avidemux/ADM_videoFilter
Message-ID: <200701131140.l0DBeLk1010643@sheep.berlios.de>

Author: mean
Date: 2007-01-13 12:40:19 +0100 (Sat, 13 Jan 2007)
New Revision: 2718

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_lavpp_deint.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidAddBorder.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidBSmear.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDGbob.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDenoise.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidFade.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidFastConvolution.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidFlux.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidForcedPP.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidHardIvtcRemoval.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidKernelDeint.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMPLD3D.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMPLD3Dlow.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMSharpen.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMcDeint.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMosaic.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMsmooth.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidResampleFPS.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidSoften.cpp
Log:
more cleanup

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_lavpp_deint.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_lavpp_deint.cpp	2007-01-13 11:39:36 UTC (rev 2717)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_lavpp_deint.cpp	2007-01-13 11:40:19 UTC (rev 2718)
@@ -103,20 +103,20 @@
   
   
    diaMenuEntry menuField[6]={{PP_BM_NONE,        _("None"),NULL},
-                             {PP_BM_LINEAR_BLEND, _("Linear Blend"),NULL},
-                             {PP_BM_LINEAR_INTER, _("Linear Interpolate"),NULL},
-                             {PP_BM_CUBIC_INTER, _("Cubic Interpolate"),NULL},
-                             {PP_BM_MEDIAN_INTER, _("Median Interpolate"),NULL},
+                             {PP_BM_LINEAR_BLEND, _("Linear blend"),NULL},
+                             {PP_BM_LINEAR_INTER, _("Linear interpolate"),NULL},
+                             {PP_BM_CUBIC_INTER, _("Cubic interpolate"),NULL},
+                             {PP_BM_MEDIAN_INTER, _("Median interpolate"),NULL},
                              {PP_BM_FFMPEG_DEINT, _("FFmpeg deint"),NULL},
                           };
   
     
-    diaElemMenu     menu1(PX(deintType),_("Deinterlacing"), 6,menuField);
-    diaElemToggle   autolevel(PX(autolevel),_("Autolevel"));
+    diaElemMenu     menu1(PX(deintType),_("_Deinterlacing:"), 6,menuField);
+    diaElemToggle   autolevel(PX(autolevel),_("_Autolevel"));
     
     diaElem *elems[2]={&menu1,&autolevel};
   
-   if(diaFactoryRun("Lavcodec deinterlacer",2,elems))
+   if(diaFactoryRun("libavcodec deinterlacer",2,elems))
   {
     setup();
     return 1; 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidAddBorder.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidAddBorder.cpp	2007-01-13 11:39:36 UTC (rev 2717)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidAddBorder.cpp	2007-01-13 11:40:19 UTC (rev 2718)
@@ -221,17 +221,17 @@
           width=_in->getInfo()->width;
           height=_in->getInfo()->height;
           
-          diaElemUInteger dleft(&left,"Left",       0,width);
-          diaElemUInteger dright(&right,"Right",    0,width);
-          diaElemUInteger dtop(&(top),"Top",          0,height);
-          diaElemUInteger dbottom(&(bottom),"Bottom", 0,height);
+          diaElemUInteger dleft(&left,"_Left border:",       0,width);
+          diaElemUInteger dright(&right,"_Right border:",    0,width);
+          diaElemUInteger dtop(&(top),"_Top border:",          0,height);
+          diaElemUInteger dbottom(&(bottom),"_Bottom border:", 0,height);
             
           diaElem *elems[4]={&dleft,&dright,&dtop,&dbottom};
-          if(diaFactoryRun("Add border",4,elems))
+          if(diaFactoryRun("Add Borders",4,elems))
           {
             if((left&1) || (right&1)|| (top&1) || (bottom&1))
             {
-              GUI_Error_HIG("Incorrect parameters","All parameters must be even and within range"); 
+              GUI_Error_HIG("Incorrect parameters","All parameters must be even and within range."); 
               continue;
             }
             else

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidBSmear.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidBSmear.cpp	2007-01-13 11:39:36 UTC (rev 2717)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidBSmear.cpp	2007-01-13 11:40:19 UTC (rev 2718)
@@ -198,10 +198,10 @@
           width=_in->getInfo()->width;
           height=_in->getInfo()->height;
           
-          diaElemUInteger dleft(&left,"Left",       0,width);
-          diaElemUInteger dright(&right,"Right",    0,width);
-          diaElemUInteger dtop(&(top),"Top",          0,height);
-          diaElemUInteger dbottom(&(bottom),"Bottom", 0,height);
+          diaElemUInteger dleft(&left,"_Left border:",       0,width);
+          diaElemUInteger dright(&right,"_Right border:",    0,width);
+          diaElemUInteger dtop(&(top),"_Top border:",          0,height);
+          diaElemUInteger dbottom(&(bottom),"_Bottom border:", 0,height);
             
           diaElem *elems[4]={&dleft,&dright,&dtop,&dbottom};
           if(diaFactoryRun("Blacken Borders",4,elems))
@@ -209,7 +209,7 @@
             if((left&1) || (right&1)|| (top&1) || (bottom&1) ||
                      (top+bottom>=height)|| (left+right>width))
             {
-              GUI_Error_HIG("Incorrect parameters","All parameters must be even and within range"); 
+              GUI_Error_HIG("Incorrect parameters","All parameters must be even and within range."); 
               continue;
             }
             else

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDGbob.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDGbob.cpp	2007-01-13 11:39:36 UTC (rev 2717)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDGbob.cpp	2007-01-13 11:40:19 UTC (rev 2718)
@@ -84,15 +84,15 @@
                              {1,_("Bottom"),NULL}
                           };
   
-     diaMenuEntry menuMode[3]={{0,_("Keep nb of frames and FPS"),NULL},
-                            {1,_("Double nb of frames and FPS"),NULL},
+     diaMenuEntry menuMode[3]={{0,_("Keep nb of frames and fps"),NULL},
+                            {1,_("Double nb of frames and fps"),NULL},
                             {2,_("Double nb of frames (slow motion)"),NULL}
                           };
                           
-    diaElemMenu     menu1(PX(order),_("Field Order"), 2,menuField);
-    diaElemMenu     menu2(PX(mode),_("Mode"), 3,menuMode);
-    diaElemUInteger threshold(PX(thresh),_("Threshold"),0,255);
-    diaElemToggle  extra(PX(ap),_("Extra"),_("Extra check, avoid using it"));
+    diaElemMenu     menu1(PX(order),_("_Field order:"), 2,menuField);
+    diaElemMenu     menu2(PX(mode),_("_Mode:"), 3,menuMode);
+    diaElemUInteger threshold(PX(thresh),_("_Threshold:"),0,255);
+    diaElemToggle  extra(PX(ap),_("_Extra"),_("Extra check, avoid using it"));
     
       diaElem *elems[4]={&menu1,&menu2,&threshold ,&extra};
    if(diaFactoryRun("DGBob",4,elems))

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDenoise.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDenoise.cpp	2007-01-13 11:39:36 UTC (rev 2717)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDenoise.cpp	2007-01-13 11:40:19 UTC (rev 2718)
@@ -385,12 +385,12 @@
   
 #define PX(x) &(_param->x)
   
-    diaElemUInteger   lumaLock(PX(lumaLock),_("Luma Lock"),0,255);
-    diaElemUInteger   chromaLock(PX(chromaLock),_("Chroma  Lock"),0,255);
-    diaElemUInteger   lumaThreshold(PX(lumaThreshold),_("Luma Threshold"),0,255);
-    diaElemUInteger   chromaThreshold(PX(chromaThreshold),_("Chroma Threshold"),0,255);
+    diaElemUInteger   lumaLock(PX(lumaLock),_("_Luma lock:"),0,255);
+    diaElemUInteger   chromaLock(PX(chromaLock),_("C_hroma lock:"),0,255);
+    diaElemUInteger   lumaThreshold(PX(lumaThreshold),_("L_uma threshold:"),0,255);
+    diaElemUInteger   chromaThreshold(PX(chromaThreshold),_("Ch_roma threshold:"),0,255);
     
-    diaElemUInteger   sceneChange(PX(sceneChange),_("Scene Change"),0,100);
+    diaElemUInteger   sceneChange(PX(sceneChange),_("_Scene change:"),0,100);
     
     
     

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidFade.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidFade.cpp	2007-01-13 11:39:36 UTC (rev 2717)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidFade.cpp	2007-01-13 11:40:19 UTC (rev 2718)
@@ -69,10 +69,10 @@
   
 while(1)
 {
-    diaElemMenu     menu(&(param.inOut),_("Fade Type"), 2,menuE);
-    diaElemUInteger start(&(param.startFade),_("Start frame"),0,mx);
-    diaElemUInteger end(&(param.endFade),_("End frame"),0,mx);
-    diaElemToggle   black(&(param.toBlack),_("Fade to black"));
+    diaElemMenu     menu(&(param.inOut),_("_Fade type:"), 2,menuE);
+    diaElemUInteger start(&(param.startFade),_("_Start frame:"),0,mx);
+    diaElemUInteger end(&(param.endFade),_("_End frame:"),0,mx);
+    diaElemToggle   black(&(param.toBlack),_("Fade to _black"));
     
     diaElem *elems[4]={&menu,&start,&end,&black};
   

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidFastConvolution.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidFastConvolution.cpp	2007-01-13 11:39:36 UTC (rev 2717)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidFastConvolution.cpp	2007-01-13 11:40:19 UTC (rev 2718)
@@ -465,8 +465,8 @@
 {
   
   //return DIA_getLumaChroma(&(_param->luma),&(_param->chroma)) ; 
-  diaElemToggle luma(&(_param->luma),"Process luma","Process luma plane");
-  diaElemToggle chroma(&(_param->chroma),"Process chroma");
+  diaElemToggle luma(&(_param->luma),"_Process luma","Process luma plane");
+  diaElemToggle chroma(&(_param->chroma),"P_rocess chroma");
   
   diaElem *elems[2]={&luma,&chroma};
   

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidFlux.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidFlux.cpp	2007-01-13 11:39:36 UTC (rev 2717)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidFlux.cpp	2007-01-13 11:40:19 UTC (rev 2718)
@@ -130,12 +130,12 @@
     temporal=_param->temporal_threshold;
     spatial=_param->spatial_threshold;
 
-    diaElemInteger Gtemporal(&temporal,"Temporal  Threshold",0,255);
-    diaElemInteger Gspatial(&spatial,"Spatial  Threshold",0,255);
+    diaElemInteger Gtemporal(&temporal,"_Temporal threshold:",0,255);
+    diaElemInteger Gspatial(&spatial,"_Spatial threshold:",0,255);
 	  
     diaElem *elems[2]={&Gtemporal,&Gspatial};
   
-    r=diaFactoryRun("Flux Smooth",2,elems);
+    r=diaFactoryRun("FluxSmooth",2,elems);
     if(r)
     {
        _param->temporal_threshold=temporal;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidForcedPP.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidForcedPP.cpp	2007-01-13 11:39:36 UTC (rev 2717)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidForcedPP.cpp	2007-01-13 11:40:19 UTC (rev 2718)
@@ -58,8 +58,8 @@
         #define PX(x) &(_param->x)
   
         
-    diaElemUInteger   postProcStrength(PX(postProcStrength),_("Filter Strength"),0,5);
-    diaElemUInteger   quant(PX(forcedQuant),_("Quantizer"),1,31);
+    diaElemUInteger   postProcStrength(PX(postProcStrength),_("_Filter strength:"),0,5);
+    diaElemUInteger   quant(PX(forcedQuant),_("_Quantizer:"),1,31);
     //diaElemToggle     swapuv(PX(swapuv),_("Swap U&V"));
     
     uint32_t hzd,vzd,dring;
@@ -70,16 +70,16 @@
     DOME(2,vzd);
     DOME(4,dring);
     
-     diaElemToggle     fhzd(&hzd,_("Horizontal Deblocking"));
-     diaElemToggle     fvzd(&vzd,_("Vertical Deblocking"));
-     diaElemToggle     fdring(&dring,_("Deringing"));
+     diaElemToggle     fhzd(&hzd,_("_Horizontal deblocking"));
+     diaElemToggle     fvzd(&vzd,_("_Vertical deblocking"));
+     diaElemToggle     fdring(&dring,_("_Deringing"));
     
     
     
       diaElem *elems[5]={&postProcStrength,&quant,&fhzd
                         ,&fvzd,&fdring};
 
-   if(diaFactoryRun("Forced PostProcessing",5,elems))
+   if(diaFactoryRun("Forced Postprocessing",5,elems))
   {
 #undef DOME
 #define DOME(x,y) if(y) _param->postProcType |=x;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidHardIvtcRemoval.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidHardIvtcRemoval.cpp	2007-01-13 11:39:36 UTC (rev 2717)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidHardIvtcRemoval.cpp	2007-01-13 11:40:19 UTC (rev 2718)
@@ -84,16 +84,16 @@
     
 #define PX(x) &(_param->x)
         
-    diaElemUInteger   thresh(PX(threshold),_("threshold"),0,99,
+    diaElemUInteger   thresh(PX(threshold),_("_Threshold:"),0,99,
         _("If value is smaller than threshold it is considered valid."
             " Smaller value might mean more false positive"));
-    diaElemUInteger   noise(PX(noise),_("noise"),0,99,_("If pixel are closer than noise, they are considered to be the same"));
-    diaElemUInteger   identical(PX(identical),_("identical"),0,99,_("If metric is less than identical, images are considered identical"));
-    diaElemToggle     show(PX(show),_("identical"),_("Show metric in image (debug)"));
+    diaElemUInteger   noise(PX(noise),_("_Noise:"),0,99,_("If pixels are closer than noise, they are considered to be the same"));
+    diaElemUInteger   identical(PX(identical),_("_Identical:"),0,99,_("If metric is less than identical, images are considered identical"));
+    diaElemToggle     show(PX(show),_("_Show metrics"),_("Show metric in image (debug)"));
     
        diaElem *elems[]={&thresh,&noise,&identical,&show};
   
-   if(  diaFactoryRun("Hard ivtc removal",sizeof(elems)/sizeof(diaElem *),elems))
+   if(  diaFactoryRun("Hard IVTC Removal",sizeof(elems)/sizeof(diaElem *),elems))
    {
         _lastRemoved=0xFFFFFFF;
         return 1;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidKernelDeint.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidKernelDeint.cpp	2007-01-13 11:39:36 UTC (rev 2717)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidKernelDeint.cpp	2007-01-13 11:40:19 UTC (rev 2718)
@@ -89,15 +89,15 @@
                           };
   
     
-    diaElemMenu     menu1(PX(order),_("Field Order"), 2,menuField);
-    diaElemUInteger threshold(PX(threshold),_("Threshold"),0,100,_("Smaller means more deinterlacing"));
-    diaElemToggle   sharp(PX(sharp),_("Sharp"),_("Sharper Engine"));
-    diaElemToggle   twoway(PX(twoway),_("Twoway"),_("Extrapolate better (better not to use it)"));
-    diaElemToggle   map(PX(map),_("Map"),_("Show interlaced areas (for test!)"));
+    diaElemMenu     menu1(PX(order),_("_Field order:"), 2,menuField);
+    diaElemUInteger threshold(PX(threshold),_("_Threshold:"),0,100,_("Smaller means more deinterlacing"));
+    diaElemToggle   sharp(PX(sharp),_("_Sharp"),_("_Sharper engine:"));
+    diaElemToggle   twoway(PX(twoway),_("T_woway"),_("Extrapolate better (better not to use it)"));
+    diaElemToggle   map(PX(map),_("_Map"),_("Show interlaced areas (for test!)"));
     
     diaElem *elems[5]={&menu1,&threshold,&sharp,&twoway,&map};
   
-   return  diaFactoryRun("Fade",5,elems);
+   return  diaFactoryRun("KernelDeint",5,elems);
 }
 uint8_t	ADMVideoKernelDeint::getCoupledConf( CONFcouple **couples)
 {

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMPLD3D.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMPLD3D.cpp	2007-01-13 11:39:36 UTC (rev 2717)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMPLD3D.cpp	2007-01-13 11:40:19 UTC (rev 2718)
@@ -71,13 +71,13 @@
         OOP(chroma,param2);
         OOP(temporal,param3);
         
-    diaElemFloat   luma(PX(fluma),_("Luma Spatial Threshold"),0.,100.);
-    diaElemFloat   chroma(PX(fchroma),_("Chroma Spatial Threshold"),0.,100.);
-    diaElemFloat   temporal(PX(ftemporal),_("Temporal Threshold"),0.,100.);
+    diaElemFloat   luma(PX(fluma),_("_Spatial luma strength:"),0.,100.);
+    diaElemFloat   chroma(PX(fchroma),_("S_patial chroma strength:"),0.,100.);
+    diaElemFloat   temporal(PX(ftemporal),_("_Temporal strength:"),0.,100.);
     
        diaElem *elems[3]={&luma,&chroma,&temporal};
   
-   if(  diaFactoryRun("MPlayer D3D",3,elems))
+   if(  diaFactoryRun("MPlayer hqdn3d",3,elems))
         {
 #undef OOP
 #define OOP(x,y) _param->y=(double) f##x

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMPLD3Dlow.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMPLD3Dlow.cpp	2007-01-13 11:39:36 UTC (rev 2717)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMPLD3Dlow.cpp	2007-01-13 11:40:19 UTC (rev 2718)
@@ -71,13 +71,13 @@
         OOP(chroma,param2);
         OOP(temporal,param3);
         
-    diaElemFloat   luma(PX(fluma),_("Luma Spatial Threshold"),0.,100.);
-    diaElemFloat   chroma(PX(fchroma),_("Chroma Spatial Threshold"),0.,100.);
-    diaElemFloat   temporal(PX(ftemporal),_("Temporal Threshold"),0.,100.);
+    diaElemFloat   luma(PX(fluma),_("_Spatial luma strength:"),0.,100.);
+    diaElemFloat   chroma(PX(fchroma),_("S_patial chroma strength:"),0.,100.);
+    diaElemFloat   temporal(PX(ftemporal),_("_Temporal strength:"),0.,100.);
     
        diaElem *elems[3]={&luma,&chroma,&temporal};
   
-   if(  diaFactoryRun("MPlayer D3D",3,elems))
+   if(  diaFactoryRun("MPlayer denoise3d",3,elems))
         {
 #undef OOP
 #define OOP(x,y) _param->y=(double) f##x

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMSharpen.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMSharpen.cpp	2007-01-13 11:39:36 UTC (rev 2717)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMSharpen.cpp	2007-01-13 11:40:19 UTC (rev 2718)
@@ -162,11 +162,11 @@
 #define PX(x) &(_param->x)
   
         
-    diaElemToggle    mask(PX(mask),_("Mask"));
-    diaElemToggle    highq(PX(highq),_("High Q"));
+    diaElemToggle    mask(PX(mask),_("_Mask"));
+    diaElemToggle    highq(PX(highq),_("_High Q"));
     
-    diaElemUInteger   threshold(PX(threshold),_("Threshold"),1,255);
-    diaElemUInteger   strength(PX(strength),_("Strength"),1,255);
+    diaElemUInteger   threshold(PX(threshold),_("_Threshold:"),1,255);
+    diaElemUInteger   strength(PX(strength),_("_Strength:"),1,255);
     
     
   diaElem *elems[4]={&mask,&highq,&threshold,&strength};

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMcDeint.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMcDeint.cpp	2007-01-13 11:39:36 UTC (rev 2717)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMcDeint.cpp	2007-01-13 11:40:19 UTC (rev 2718)
@@ -105,19 +105,19 @@
    diaMenuEntry menuMode[4]={{0,_("Fast"),NULL},
                              {1,_("Medium"),NULL},
                              {2,_("Slow iterative motion search"),NULL},
-                             {3,_("Extra Slow (same as 3+multiple reference frame)"),NULL}
+                             {3,_("Extra slow (same as 3+multiple reference frames)"),NULL}
                           };
    diaMenuEntry menuField[2]={{0,_("Top"),NULL},
                              {1,_("Bottom"),NULL}
                           };
   
-    diaElemMenu     menu1(&(_param->mode),_("Mode"), 4,menuMode);
-    diaElemMenu     menu2(&(_param->initial_parity),_("Field Dominance"), 2,menuField);
-    diaElemUInteger qp(&(_param->qp),_("Qp"),1,60);
+    diaElemMenu     menu1(&(_param->mode),_("_Mode:"), 4,menuMode);
+    diaElemMenu     menu2(&(_param->initial_parity),_("_Field dominance:"), 2,menuField);
+    diaElemUInteger qp(&(_param->qp),_("_Qp:"),1,60);
     
     diaElem *elems[3]={&menu1,&menu2,&qp};
   
-    return  diaFactoryRun("Fade",3,elems);
+    return  diaFactoryRun("mcDeinterlace",3,elems);
 
 }
 uint8_t AVDMVideoMCDeint::getCoupledConf( CONFcouple **couples)

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMosaic.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMosaic.cpp	2007-01-13 11:39:36 UTC (rev 2717)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMosaic.cpp	2007-01-13 11:40:19 UTC (rev 2718)
@@ -89,10 +89,10 @@
 
 #define PX(x) &(_param->x)
         
-    diaElemUInteger   hz(PX(hz),_("Horizontal Stacking"),0,10);
-    diaElemUInteger   vz(PX(vz),_("Vertical Stacking"),0,10);
-    diaElemUInteger   shrink(PX(shrink),_("Shrink Factor"),0,10);
-    diaElemToggle     show(PX(show),_("Show frame"));
+    diaElemUInteger   hz(PX(hz),_("_Horizontal stacking:"),0,10);
+    diaElemUInteger   vz(PX(vz),_("_Vertical stacking:"),0,10);
+    diaElemUInteger   shrink(PX(shrink),_("_Shrink factor:"),0,10);
+    diaElemToggle     show(PX(show),_("Show _frame"));
     
     
        diaElem *elems[]={&hz,&vz,&shrink,&show};

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMsmooth.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMsmooth.cpp	2007-01-13 11:39:36 UTC (rev 2717)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMsmooth.cpp	2007-01-13 11:40:19 UTC (rev 2718)
@@ -192,14 +192,14 @@
 	_in=in;
 	ADM_assert(_param);
         
-        diaElemToggle toggle(&(_param->highq),"High Quality");
-        diaElemToggle mask(&(_param->showmask),"Show Mask");
-        diaElemUInteger threshold(&(_param->threshold),"Threshold",0,100);
-        diaElemUInteger strength(&(_param->strength),"Filter Strength",0,100);
+        diaElemToggle toggle(&(_param->highq),"_High quality");
+        diaElemToggle mask(&(_param->showmask),"Show _mask");
+        diaElemUInteger threshold(&(_param->threshold),"_Threshold:",0,100);
+        diaElemUInteger strength(&(_param->strength),"_Strength:",0,100);
 	  
     diaElem *elems[4]={&toggle,&mask,&threshold,&strength};
   
-    return diaFactoryRun("MSmooth by Donald Graft",4,elems);
+    return diaFactoryRun("MSmooth",4,elems);
 }
 
 //________________________________________________________

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidResampleFPS.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidResampleFPS.cpp	2007-01-13 11:39:36 UTC (rev 2717)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidResampleFPS.cpp	2007-01-13 11:40:19 UTC (rev 2718)
@@ -82,12 +82,12 @@
   
   _in=in;
   
-    diaElemFloat fps(&f,_("New FPS"),1,200.);
-    diaElemToggle blend(&(_param->use_linear),_("Blend"));
+    diaElemFloat fps(&f,_("_New frame rate:"),1,200.);
+    diaElemToggle blend(&(_param->use_linear),_("_Blend"));
     
     diaElem *elems[2]={&fps,&blend};
   
-    if( diaFactoryRun("Resample FPS",2,elems))
+    if( diaFactoryRun("Resample fps",2,elems))
     {
         f*=1000;
       _param->newfps=(uint32_t)floor(f+0.4); 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidSoften.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidSoften.cpp	2007-01-13 11:39:36 UTC (rev 2717)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidSoften.cpp	2007-01-13 11:40:19 UTC (rev 2718)
@@ -65,9 +65,9 @@
 	uint32_t radius;
 	*/
         
-        diaElemUInteger luma(&(_param->luma),_("Luma Treshold"),0,255);
-        diaElemUInteger chroma(&(_param->chroma),_("Chroma Treshold"),0,255);
-        diaElemUInteger radius(&(_param->radius),_("Radius"),1,60);
+        diaElemUInteger luma(&(_param->luma),_("_Luma threshold:"),0,255);
+        diaElemUInteger chroma(&(_param->chroma),_("C_hroma threshold:"),0,255);
+        diaElemUInteger radius(&(_param->radius),_("_Radius:"),1,60);
 	  
     diaElem *elems[3]={&luma,&chroma,&radius};
   



From mean at mail.berlios.de  Sat Jan 13 12:40:54 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 13 Jan 2007 12:40:54 +0100
Subject: [Avidemux-svn-commit] r2719 -
	branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_filters
Message-ID: <200701131140.l0DBes3v012094@sheep.berlios.de>

Author: mean
Date: 2007-01-13 12:40:52 +0100 (Sat, 13 Jan 2007)
New Revision: 2719

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_filters/gui_filtermanager_dialog.cpp
Log:
??

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_filters/gui_filtermanager_dialog.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_filters/gui_filtermanager_dialog.cpp	2007-01-13 11:40:19 UTC (rev 2718)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_filters/gui_filtermanager_dialog.cpp	2007-01-13 11:40:52 UTC (rev 2719)
@@ -125,6 +125,7 @@
   gtk_dialog_set_has_separator (GTK_DIALOG (dialog1), FALSE);
 
   dialog_vbox1 = GTK_DIALOG (dialog1)->vbox;
+  gtk_box_set_spacing (GTK_BOX(dialog_vbox1), 12);
   gtk_widget_show (dialog_vbox1);
 
   vbox3b = gtk_vbox_new (FALSE, 12);
@@ -243,7 +244,7 @@
   treeview1 = gtk_tree_view_new ();
   gtk_widget_show (treeview1);
   gtk_container_add (GTK_CONTAINER (scrolledwindow1), treeview1);
-  gtk_widget_set_size_request (treeview1, -1, 336);
+  gtk_widget_set_size_request (treeview1, 288, 336);
   gtk_tree_view_set_headers_visible (GTK_TREE_VIEW (treeview1), FALSE);
   gtk_tree_view_set_rules_hint (GTK_TREE_VIEW (treeview1), TRUE);
   gtk_tree_view_set_enable_search (GTK_TREE_VIEW (treeview1), FALSE);
@@ -462,6 +463,7 @@
   treeview0 = gtk_tree_view_new ();
   gtk_widget_show (treeview0);
   gtk_container_add (GTK_CONTAINER (scrolledwindow9), treeview0);
+  gtk_widget_set_size_request (treeview0, 288, 336);
   gtk_tree_view_set_headers_visible (GTK_TREE_VIEW (treeview0), FALSE);
   gtk_tree_view_set_rules_hint (GTK_TREE_VIEW (treeview0), TRUE);
   gtk_tree_view_set_enable_search (GTK_TREE_VIEW (treeview0), FALSE);



From mean at mail.berlios.de  Sat Jan 13 13:08:28 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 13 Jan 2007 13:08:28 +0100
Subject: [Avidemux-svn-commit] r2720 - in
	branches/avidemux_2.4_branch/avidemux: . ADM_video ADM_videoFilter
Message-ID: <200701131208.l0DC8Suw013407@sheep.berlios.de>

Author: mean
Date: 2007-01-13 13:08:21 +0100 (Sat, 13 Jan 2007)
New Revision: 2720

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidPalShift.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidPalShift.h
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidPalSmart.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidPalSmart.h
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidReverse.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidSeparateField.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidSeparateField.h
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidSwapFields.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidSwapFields.h
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidSwapSmart.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidSwapSmart.h
Removed:
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidPalShift.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidPalShift.h
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidReverse.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSalt.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSalt.h
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSeparateField.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSeparateField.h
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSwapFields.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSwapFields.h
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSwapSmart.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSwapSmart.h
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidTelecide.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidTelecide.h
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidTempSmooth.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidTempSmooth.h
   branches/avidemux_2.4_branch/avidemux/ADM_video/ASM_vidDenoise.cpp
Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am
   branches/avidemux_2.4_branch/avidemux/Makefile.am
Log:
cleanup

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidPalShift.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidPalShift.cpp	2007-01-13 11:40:52 UTC (rev 2719)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidPalShift.cpp	2007-01-13 12:08:21 UTC (rev 2720)
@@ -1,160 +0,0 @@
-/***************************************************************************
-                          ADM_vidPalShift.cpp  -  description
-                             -------------------
-    begin                : Sat Aug 24 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
- #include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <ADM_assert.h>
-
-#include "config.h"
-#include "fourcc.h"
-#include "avio.hxx"
-#include "config.h"
-#include "avi_vars.h"
-#ifdef HAVE_ENCODER
-
-
-#include "ADM_toolkit/toolkit.hxx"
-#include "ADM_editor/ADM_edit.hxx"
-#include "ADM_video/ADM_genvideo.hxx"
-#include "ADM_video/ADM_vidPalShift.h"
-#include "ADM_filter/video_filters.h"
-
-
-static FILTER_PARAM nullParam={0,{""}};
-
-
-SCRIPT_CREATE(addPALShift_script,ADMVideoPalShift,nullParam);
-BUILD_CREATE(addPALShift_create,ADMVideoPalShift);
-
-
-char *ADMVideoPalShift::printConf( void )
-{
- 	static char buf[50];
- 	
- 	sprintf((char *)buf," PAL field shift");
-        return buf;
-}
-
-ADMVideoPalShift::ADMVideoPalShift(  AVDMGenericVideoStream *in,CONFcouple *setup)
-{
-	UNUSED_ARG(setup);
-	
-
-	_reverse=NULL;
- 	_in=in;		
-	memcpy(&_info,_in->getInfo(),sizeof(_info));  		
-	
-
-	_reverse=new uint8_t;;
-	*_reverse=1;
-	
-  	_info.encoding=1;
-
-	vidCache=new VideoCache(5,in);
-
-
-  	  	
-}
- uint8_t ADMVideoPalShift::configure( AVDMGenericVideoStream *instream) 
-{
-  if(GUI_Question(_("Try reverse ?")))
-	{
-		*_reverse=1;
-	}
-	else
-	{
-		*_reverse=0;
-	}
-	return 1;
-
-} 
-ADMVideoPalShift::~ADMVideoPalShift()
-{
-	delete vidCache;
-	delete _reverse;
-}
-uint8_t ADMVideoPalShift::getFrameNumberNoAlloc(uint32_t frame,
-				uint32_t *len,
-   				ADMImage *data,
-				uint32_t *flags)
-{
-
-uint32_t full,half;
-ADMImage *cur,*next;
-
-		full=_info.width*_info.height;
-		half=full>>2;
-
-		if(frame>=_info.nb_frames) return 0;
-		
-		cur=vidCache->getImage(frame);
-		if(!cur) return 0;
-			
-		// for first or last frame do nothing
-		if(!frame || frame==_info.nb_frames-1)
-		{
-
-			data->duplicate(cur);
-			vidCache->unlockAll();
-			return 1;	
-		}				
-								
-		// copy u & v as they are			
-
-		memcpy(UPLANE(data),UPLANE(cur),half);
-		memcpy(VPLANE(data),VPLANE(cur),half);
-
-		// now copy odd field from framei and even frame from frame i-1		
-		// OR the other way around
-		uint32_t dline=_info.width;
-		
-		next=vidCache->getImage(frame+1);
-		if(!next) return 0;
-
-		//
-		uint8_t *src,*dst,*src2;
-		if(!*_reverse)
-		{
-			src2=YPLANE(cur)+dline;
-			src=YPLANE(next);
-			dst=YPLANE(data);
-		}
-		else
-		{
-			src2=YPLANE(next)+dline;
-			src=YPLANE(cur);
-			dst=YPLANE(data);
-		
-		}
-		for(uint32_t y=(_info.height>>1);y>0;y--)
-		{
-                	memcpy(dst,src, dline);
-			dst+=dline;
-                	memcpy(dst,src2, dline);
-			dst+=dline;
-			src+=dline*2;
-			src2+=dline*2;
-		}
-		
-	vidCache->unlockAll();
-			data->copyInfo(cur);
-      return 1;
-}
-
-
-
-#endif

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidPalShift.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidPalShift.h	2007-01-13 11:40:52 UTC (rev 2719)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidPalShift.h	2007-01-13 12:08:21 UTC (rev 2720)
@@ -1,42 +0,0 @@
-/***************************************************************************
-                          ADM_vidPalShift.h  -  description
-                             -------------------
-    begin                : Sat Aug 24 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifndef PALSHIFT__
-#define PALSHIFT__
-#include "ADM_video/ADM_cache.h" 
- class  ADMVideoPalShift:public AVDMGenericVideoStream
- {
-
- protected:
-    		
-		VideoCache			*vidCache;
-     virtual 	char 				*printConf(void);
-
-		uint8_t				*_reverse;
-
-
- public:
-
-
-  				ADMVideoPalShift(  AVDMGenericVideoStream *in,CONFcouple *setup);
-
-  	virtual 		~ADMVideoPalShift();
-	virtual uint8_t 	getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-          								ADMImage *data,uint32_t *flags);
-	virtual uint8_t configure( AVDMGenericVideoStream *instream) ;
-
- }     ;
-#endif

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidReverse.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidReverse.cpp	2007-01-13 11:40:52 UTC (rev 2719)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidReverse.cpp	2007-01-13 12:08:21 UTC (rev 2720)
@@ -1,120 +0,0 @@
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include "config.h"
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <ADM_assert.h>
-
-#include "config.h"
-#include "fourcc.h"
-#include "avio.hxx"
-#include "avi_vars.h"
-
-#include "ADM_toolkit/toolkit.hxx"
-#include "ADM_editor/ADM_edit.hxx"
-#include "ADM_video/ADM_genvideo.hxx"
-#include"ADM_video/ADM_vidField.h"
-#include"ADM_video/ADM_cache.h"
-
-#include "ADM_osSupport/ADM_debugID.h"
-#define MODULE_NAME MODULE_FILTER
-#include "ADM_osSupport/ADM_debug.h"
-#include "ADM_filter/video_filters.h"
-
-
-class AVDM_Reverse : public AVDMGenericVideoStream
-{
-  VideoCache      *vidCache;
-  public:
-                                
-    AVDM_Reverse(AVDMGenericVideoStream *in,CONFcouple *couples);    
-    ~AVDM_Reverse(void);
-    uint8_t         getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-                                          ADMImage *data,uint32_t *flags);
-        
-    char            *printConf( void );
-    uint8_t         configure(AVDMGenericVideoStream *in);
-    uint8_t         getCoupledConf( CONFcouple **couples);
-};
-
-static FILTER_PARAM reverseParam={0,{""}};
-
-BUILD_CREATE(reverse_create,AVDM_Reverse);
-SCRIPT_CREATE(reverse_script,AVDM_Reverse,reverseParam);
-
-/*************************************/
-
-uint8_t AVDM_Reverse::configure(AVDMGenericVideoStream *in)
-{
-  _in=in;
-  return 1;
-        
-}
-
-char *AVDM_Reverse::printConf( void )
-{
-  static char buf[50];
-
-        //ADM_assert(_param);
-  sprintf((char *)buf," Reverse");
-  return buf;
-}
-
-
-AVDM_Reverse::AVDM_Reverse(AVDMGenericVideoStream *in,CONFcouple *couples)
-
-{
-                
-  int count = 0;
-  char buf[80];
-  unsigned int *p;
-
-  _in=in;         
-  memcpy(&_info,_in->getInfo(),sizeof(_info));    
-  _info.encoding=1;
-  vidCache=new VideoCache(18,in);
-}
-//________________________________________________________
-uint8_t AVDM_Reverse::getCoupledConf( CONFcouple **couples)
-{
-  *couples=NULL;
-  return 1;
-}
-//________________________________________________________
-AVDM_Reverse::~AVDM_Reverse(void)
-{
-                
-  if(vidCache) delete vidCache;                
-  vidCache=NULL;   
-}
-uint8_t AVDM_Reverse::getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-                                     ADMImage *data,uint32_t *flags)
-{
-
-  uint32_t num_frames,tgt;
-  ADMImage *src;
-
-  num_frames=_in->getInfo()->nb_frames;   // ??
-  if(frame>=num_frames) return 0;
-  
-  tgt=num_frames-frame-1;
-
-  src=vidCache->getImage(tgt);
-  if(!src) return 0;
-  data->duplicate(src);
-
-  vidCache->unlockAll();
-  return 1;
-}
-//EOF
-
-
-

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSalt.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSalt.cpp	2007-01-13 11:40:52 UTC (rev 2719)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSalt.cpp	2007-01-13 12:08:21 UTC (rev 2720)
@@ -1 +0,0 @@
-// RMED
\ No newline at end of file

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSalt.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSalt.h	2007-01-13 11:40:52 UTC (rev 2719)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSalt.h	2007-01-13 12:08:21 UTC (rev 2720)
@@ -1 +0,0 @@
-// RMED

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSeparateField.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSeparateField.cpp	2007-01-13 11:40:52 UTC (rev 2719)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSeparateField.cpp	2007-01-13 12:08:21 UTC (rev 2720)
@@ -1,269 +0,0 @@
-/***************************************************************************
-                          Separate Fields.cpp  -  description
-                             -------------------
-Convert a x*y * f fps video into -> x*(y/2)*fps/2 video
-
-Same idea as for avisynth separatefield
-
-
-    begin                : Thu Mar 21 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <ADM_assert.h>
-
-#include "config.h"
-#include "fourcc.h"
-#include "avio.hxx"
-#include "config.h"
-#include "avi_vars.h"
-
-
-#include "ADM_toolkit/toolkit.hxx"
-#include "ADM_editor/ADM_edit.hxx"
-#include "ADM_video/ADM_genvideo.hxx"
-#include "ADM_video/ADM_vidFieldUtil.h"
-#include "ADM_video/ADM_vidSeparateField.h"
-#include "ADM_filter/video_filters.h"
-
-
-static FILTER_PARAM swapParam={0,{""}};
-
-SCRIPT_CREATE(separatefield_script,AVDMVideoSeparateField,swapParam);
-SCRIPT_CREATE(mergefield_script,AVDMVideoMergeField,swapParam);
-SCRIPT_CREATE(stackfield_script,AVDMVideoStackField,swapParam);
-SCRIPT_CREATE(unstackfield_script,AVDMVideoUnStackField,swapParam);
-
-BUILD_CREATE(separatefield_create,AVDMVideoSeparateField);
-BUILD_CREATE(mergefield_create,AVDMVideoMergeField);
-BUILD_CREATE(stackfield_create,AVDMVideoStackField);
-BUILD_CREATE(unstackfield_create,AVDMVideoUnStackField);
-
-char *AVDMVideoSeparateField::printConf( void )
-{
- 	static char buf[50];
-
- 	sprintf((char *)buf," Separate Fields");
-        return buf;
-}
-
-//_______________________________________________________________
-AVDMVideoSeparateField::AVDMVideoSeparateField(
-									AVDMGenericVideoStream *in,CONFcouple *setup)
-{
-UNUSED_ARG(setup);
-  	_in=in;
-   	memcpy(&_info,_in->getInfo(),sizeof(_info));
-	
-
-	_info.height>>=1;
-	_info.fps1000*=2;
-	_info.nb_frames*=2;
-	vidCache=new VideoCache(2,_in);
-
-}
-
-// ___ destructor_____________
-AVDMVideoSeparateField::~AVDMVideoSeparateField()
-{
- 	
-	delete vidCache;
-	vidCache=NULL;
-}
-
-//
-//	Basically ask a uncompressed frame from editor and ask
-//		GUI to decompress it .
-//
-
-uint8_t AVDMVideoSeparateField::getFrameNumberNoAlloc(uint32_t frame,
-				uint32_t *len,
-   				ADMImage *data,
-				uint32_t *flags)
-{
-uint32_t ref;
-ADMImage *ptr;
-		if(frame>=_info.nb_frames) return 0;
-		ref=frame>>1;
-		
-		ptr=vidCache->getImage(ref);
-		if(!ptr) return 0;
-
-		ADM_assert(ptr->data);
-		ADM_assert(data->data);
-		if(frame&1) // odd image
-			 vidFieldKeepOdd(_info.width,_info.height,ptr->data,data->data);
-		else
-			 vidFieldKeepEven(_info.width,_info.height,ptr->data,data->data);
-		data->copyInfo(ptr);	
-		vidCache->unlockAll();
-      return 1;
-}
-//------------------ and merge them ------------------
-
-
-char *AVDMVideoMergeField::printConf( void )
-{
- 	static char buf[50];
-
- 	sprintf((char *)buf," Merge fields");
-        return buf;
-}
-
-//_______________________________________________________________
-AVDMVideoMergeField::AVDMVideoMergeField(
-									AVDMGenericVideoStream *in,CONFcouple *setup)
-{
-UNUSED_ARG(setup);
-  	_in=in;
-   	memcpy(&_info,_in->getInfo(),sizeof(_info));	
-	vidCache=new VideoCache(4,_in);
-	
-
-	_info.height<<=1;
-	_info.fps1000>>=1;
-	_info.nb_frames>>=1;
-
-
-}
-
-// ___ destructor_____________
-AVDMVideoMergeField::~AVDMVideoMergeField()
-{
- 		delete vidCache;
-		vidCache=NULL;
-}
-
-/**
-	Interleave frame*2 and frame*2+1
-*/
-uint8_t AVDMVideoMergeField::getFrameNumberNoAlloc(uint32_t frame,
-				uint32_t *len,
-   				ADMImage *data,
-				uint32_t *flags)
-{
-uint32_t ref,ref2;
-ADMImage *ptr1,*ptr2;
-		if(frame>=_info.nb_frames) return 0;
-
-		ref=frame<<1;
-		ref2=ref+1;
-		ptr1=vidCache->getImage(ref);
-		ptr2=vidCache->getImage(ref+1);
-		
-		if(!ptr1 || !ptr2)
-		{
-			printf("Merge field : cannot read\n");
-			vidCache->unlockAll();
-		 	return 0;
-		}
-		 vidFieldMerge(_info.width,_info.height,ptr1->data,ptr2->data,data->data);
-		 vidCache->unlockAll();
-		
-      return 1;
-}
-//_______________________Stack Fields_______________________
-
-char *AVDMVideoStackField::printConf( void )
-{
- 	static char buf[50];
-
- 	sprintf((char *)buf," Stack fields");
-        return buf;
-}
-
-//_______________________________________________________________
-AVDMVideoStackField::AVDMVideoStackField(	AVDMGenericVideoStream *in,CONFcouple *setup)
-{
-UNUSED_ARG(setup);
-  	_in=in;
-   	memcpy(&_info,_in->getInfo(),sizeof(_info));	
-	_uncompressed=new ADMImage(_info.width,_info.height);	
-
-}
-
-// ___ destructor_____________
-AVDMVideoStackField::AVDMVideoStackField()
-{
- 		delete _uncompressed;
-		_uncompressed=NULL;
-}
-
-/**
-	Interleave frame*2 and frame*2+1
-*/
-uint8_t AVDMVideoStackField::getFrameNumberNoAlloc(uint32_t frame,
-				uint32_t *len,
-   				ADMImage *data,
-				uint32_t *flags)
-{
-uint32_t ref,ref2;
-ADMImage *ptr1,*ptr2;
-		if(frame>=_info.nb_frames) return 0;
-
-		 if(!_in->getFrameNumberNoAlloc(frame, len, _uncompressed, flags)) return 0;
-		 
-		  vidFielStack(_info.width ,_info.height,YPLANE(_uncompressed),YPLANE(data));
-		data->copyInfo(_uncompressed);	
-      return 1;
-}
-
-/****/
-//_______________________Stack Fields_______________________
-
-char *AVDMVideoUnStackField::printConf( void )
-{
-        static char buf[50];
-
-        sprintf((char *)buf," UnStack fields");
-        return buf;
-}
-
-//_______________________________________________________________
-AVDMVideoUnStackField::AVDMVideoUnStackField(       AVDMGenericVideoStream *in,CONFcouple *setup)
-{
-UNUSED_ARG(setup);
-        _in=in;
-        memcpy(&_info,_in->getInfo(),sizeof(_info));    
-        _uncompressed=new ADMImage(_info.width,_info.height);   
-
-}
-
-// ___ destructor_____________
-AVDMVideoUnStackField::AVDMVideoUnStackField()
-{
-                delete _uncompressed;
-                _uncompressed=NULL;
-}
-
-/**
-        Interleave frame*2 and frame*2+1
-*/
-uint8_t AVDMVideoUnStackField::getFrameNumberNoAlloc(uint32_t frame,
-                                uint32_t *len,
-                                ADMImage *data,
-                                uint32_t *flags)
-{
-uint32_t ref,ref2;
-ADMImage *ptr1,*ptr2;
-                if(frame>=_info.nb_frames) return 0;
-
-                 if(!_in->getFrameNumberNoAlloc(frame, len, _uncompressed, flags)) return 0;
-                 
-                  vidFielUnStack(_info.width ,_info.height,YPLANE(_uncompressed),YPLANE(data));
-                data->copyInfo(_uncompressed);  
-      return 1;
-}

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSeparateField.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSeparateField.h	2007-01-13 11:40:52 UTC (rev 2719)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSeparateField.h	2007-01-13 12:08:21 UTC (rev 2720)
@@ -1,74 +0,0 @@
-/*
-
-*/
-#include "ADM_video/ADM_cache.h"
-  class  AVDMVideoSeparateField:public AVDMGenericVideoStream
- {
-
- protected:
-
-        virtual char 				*printConf(void) ;
-						VideoCache	*vidCache;
-
- public:
- 					
-  						AVDMVideoSeparateField(  AVDMGenericVideoStream *in,CONFcouple *setup);
-  						~AVDMVideoSeparateField();
-		      virtual uint8_t 	getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-          									ADMImage *data,uint32_t *flags);
-
-		      virtual uint8_t 	configure( AVDMGenericVideoStream *instream) {return 1;};
-
- }     ;
-   class  AVDMVideoMergeField:public AVDMGenericVideoStream
- {
-
- protected:
-
-				VideoCache	*vidCache;
-       			 virtual char 		*printConf(void) ;
-
- public:
-  						AVDMVideoMergeField(  AVDMGenericVideoStream *in,CONFcouple *setup);
-  						~AVDMVideoMergeField();
-		      virtual uint8_t 	getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-          									ADMImage *data,uint32_t *flags);
-
-			virtual uint8_t configure( AVDMGenericVideoStream *instream) {return 1;};
-
- }     ;
-   class  AVDMVideoStackField:public AVDMGenericVideoStream
- {
-
- protected:
-
-				
-       			 virtual char 		*printConf(void) ;
-
- public:
-  						AVDMVideoStackField(  AVDMGenericVideoStream *in,CONFcouple *setup);
-  						AVDMVideoStackField();
-		      virtual uint8_t 	getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-          									ADMImage *data,uint32_t *flags);
-
-			virtual uint8_t configure( AVDMGenericVideoStream *instream) {return 1;};
-
- }     ;
-   class  AVDMVideoUnStackField:public AVDMGenericVideoStream
- {
-
- protected:
-
-                                
-                         virtual char           *printConf(void) ;
-
- public:
-                                                AVDMVideoUnStackField(  AVDMGenericVideoStream *in,CONFcouple *setup);
-                                                AVDMVideoUnStackField();
-                      virtual uint8_t   getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-                                                                                ADMImage *data,uint32_t *flags);
-
-                        virtual uint8_t configure( AVDMGenericVideoStream *instream) {return 1;};
-
- }     ;
-

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSwapFields.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSwapFields.cpp	2007-01-13 11:40:52 UTC (rev 2719)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSwapFields.cpp	2007-01-13 12:08:21 UTC (rev 2720)
@@ -1,200 +0,0 @@
-/***************************************************************************
-                          Swap Fields.cpp  -  description
-                             -------------------
-Swap each line  (shift up for odd, down for even)
-
-
-    begin                : Thu Mar 21 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <ADM_assert.h>
-
-#include "config.h"
-#include "fourcc.h"
-#include "avio.hxx"
-#include "config.h"
-#include "avi_vars.h"
-#ifdef HAVE_ENCODER
-
-
-#include "ADM_toolkit/toolkit.hxx"
-#include "ADM_editor/ADM_edit.hxx"
-#include "ADM_video/ADM_genvideo.hxx"
-#include "ADM_video/ADM_vidFieldUtil.h"
-#include "ADM_video/ADM_vidSwapFields.h"
-//static void decimate(uint8_t *src,uint8_t *target, uint32_t linessrc, uint32_t width);
-#include "ADM_filter/video_filters.h"
-
-
-static FILTER_PARAM swapParam={0,{""}};
-
-
-
-BUILD_CREATE(swapfield_create,AVDMVideoSwapField);
-BUILD_CREATE(keepeven_create,AVDMVideoKeepEven);
-BUILD_CREATE(keepodd_create,AVDMVideoKeepOdd);
-
-SCRIPT_CREATE(swapfield_script,AVDMVideoSwapField,swapParam);
-SCRIPT_CREATE(keepeven_script,AVDMVideoKeepEven,swapParam);
-SCRIPT_CREATE(keepodd_script,AVDMVideoKeepOdd,swapParam);
-
-char *AVDMVideoSwapField::printConf( void )
-{
- 	static char buf[50];
-
- 	sprintf((char *)buf," Swap fields");
-        return buf;
-}
-char *AVDMVideoKeepEven::printConf( void )
-{
- 	static char buf[50];
-
- 	sprintf((char *)buf," Keep Even Fields");
-        return buf;
-}char *AVDMVideoKeepOdd::printConf( void )
-{
- 	static char buf[50];
-
- 	sprintf((char *)buf," Keep Odd Fields");
-        return buf;
-}
-//_______________________________________________________________
-AVDMVideoSwapField::AVDMVideoSwapField(
-									AVDMGenericVideoStream *in,CONFcouple *setup)
-{
-UNUSED_ARG(setup);
-  	_in=in;
-   	memcpy(&_info,_in->getInfo(),sizeof(_info));
-	_uncompressed=new ADMImage(_info.width,_info.height);
-
-
-}
-//_______________________________________________________________
-AVDMVideoKeepOdd::AVDMVideoKeepOdd(
-									AVDMGenericVideoStream *in,CONFcouple *setup)
-{
-UNUSED_ARG(setup);
-  	_in=in;
-	memcpy(&_info,_in->getInfo(),sizeof(_info));
-	_uncompressed=new ADMImage(_info.width,_info.height);
-	_info.height>>=1;
-
-}
-// ___ destructor_____________
-AVDMVideoSwapField::~AVDMVideoSwapField()
-{
- 	delete  _uncompressed;
-	_uncompressed=NULL;
-
-}
-// ___ destructor_____________
-AVDMVideoKeepOdd::~AVDMVideoKeepOdd()
-{
- 	delete _uncompressed;
-	_uncompressed=NULL;
-
-}
-
-//
-//	Basically ask a uncompressed frame from editor and ask
-//		GUI to decompress it .
-//
-
-uint8_t AVDMVideoSwapField::getFrameNumberNoAlloc(uint32_t frame,
-				uint32_t *len,
-   				ADMImage *data,
-				uint32_t *flags)
-{
-//static Image in,out;
-			if(frame>=_info.nb_frames) return 0;
-
-
-			// read uncompressed frame
-       		if(!_in->getFrameNumberNoAlloc(frame, len,_uncompressed,flags)) return 0;
-
-		uint32_t w=_info.width;
-		uint32_t h=_info.height;
-		uint32_t page=w*h;
-		uint32_t stride;
-
-		// copy u & v
-		memcpy(UPLANE(data),UPLANE(_uncompressed),page>>2);
-		memcpy(VPLANE(data),VPLANE(_uncompressed),page>>2);
-		
-		uint8_t *odd,*even,*target,*target2;
-
-		even=YPLANE(_uncompressed);
-		odd=even+w;
-		target=YPLANE(data);
-		target2=YPLANE(data)+w;
-		stride=2*w;
-
-		h>>=1;
-		for(;h--;h>0)
-		{
-			memcpy(target,odd,w);
-			memcpy(target2,even,w);
-			target+=stride;
-			target2+=stride;
-			odd+=stride;
-			even+=stride;
-		}
-		data->copyInfo(_uncompressed);
-
-      return 1;
-}
-
-uint8_t AVDMVideoKeepOdd::getFrameNumberNoAlloc(uint32_t frame,
-				uint32_t *len,
-   				ADMImage *data,
-				uint32_t *flags)
-{
-//static Image in,out;
-			if(!_in->getFrameNumberNoAlloc(frame, len,_uncompressed,flags)) return 0;
-
-
-		uint32_t w=_info.width;
-		uint32_t h=_info.height;
-
-		vidFieldKeepOdd(  w,  h, YPLANE(_uncompressed),YPLANE(data));
-		data->copyInfo(_uncompressed);
-
-      return 1;
-}
-
-uint8_t AVDMVideoKeepEven::getFrameNumberNoAlloc(uint32_t frame,
-				uint32_t *len,
-   				ADMImage *data,
-				uint32_t *flags)
-{
-//static Image in,out;
-			if(frame>=_info.nb_frames) return 0;
-
-
-			// read uncompressed frame
-       		if(!_in->getFrameNumberNoAlloc(frame, len,_uncompressed,flags)) return 0;
-
-		uint32_t w=_info.width;
-		uint32_t h=_info.height;
-
-
-		data->copyInfo(_uncompressed);
-		vidFieldKeepEven(  w,  h, YPLANE(_uncompressed),YPLANE(data));
-      return 1;
-}
-
-#endif

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSwapFields.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSwapFields.h	2007-01-13 11:40:52 UTC (rev 2719)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSwapFields.h	2007-01-13 12:08:21 UTC (rev 2720)
@@ -1,69 +0,0 @@
-/***************************************************************************
-                          Swap Fields.h  -  description
-                             -------------------
-Swap each line  (shift up for odd, down for even)
-
-
-    begin                : Thu Mar 21 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-
-  class  AVDMVideoSwapField:public AVDMGenericVideoStream
- {
-
- protected:
-    		AVDMGenericVideoStream 	*_in;
-        virtual char 					*printConf(void) ;
-
- public:
-  						AVDMVideoSwapField(  AVDMGenericVideoStream *in,CONFcouple *setup);
-  						~AVDMVideoSwapField();
-		      virtual uint8_t 	getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-          									ADMImage *data,uint32_t *flags);
-			virtual uint8_t	*getBinaryConf( uint16_t *size) { *size=0;return (uint8_t *)0;}
-			virtual uint8_t 	configure( AVDMGenericVideoStream *instream) {return 1;};
-
- }     ;
-  class  AVDMVideoKeepOdd:public AVDMGenericVideoStream
- {
-
- protected:
-    		AVDMGenericVideoStream 	*_in;
-        virtual char 					*printConf(void) ;
-
- public:
-  						AVDMVideoKeepOdd(  AVDMGenericVideoStream *in,CONFcouple *setup);
-  						~AVDMVideoKeepOdd();
-		      virtual uint8_t 	getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-          									ADMImage *data,uint32_t *flags);
-
-			virtual uint8_t 	configure( AVDMGenericVideoStream *instream) {return 1;};
-
- }     ;
-  class  AVDMVideoKeepEven:public AVDMVideoKeepOdd
- {
-
- protected:
-
-       			 virtual char 					*printConf(void) ;
-
- public:
- 			AVDMVideoKeepEven(  AVDMGenericVideoStream *in,CONFcouple *setup) : AVDMVideoKeepOdd(  in,setup) 
-			{}
-
-		      virtual uint8_t 	getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-          							ADMImage *data,uint32_t *flags);
-
- }     ;
-

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSwapSmart.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSwapSmart.cpp	2007-01-13 11:40:52 UTC (rev 2719)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSwapSmart.cpp	2007-01-13 12:08:21 UTC (rev 2720)
@@ -1,143 +0,0 @@
-/***************************************************************************
-                          Swap Fields.cpp  -  description
-                             -------------------
-Swap each line  (shift up for odd, down for even)
-
-
-    begin                : Thu Mar 21 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <ADM_assert.h>
-
-#include "config.h"
-#include "fourcc.h"
-#include "avio.hxx"
-#include "config.h"
-#include "avi_vars.h"
-#ifdef HAVE_ENCODER
-
-
-#include "ADM_toolkit/toolkit.hxx"
-#include "ADM_editor/ADM_edit.hxx"
-#include "ADM_video/ADM_genvideo.hxx"
-#include "ADM_video/ADM_vidSwapSmart.h"
-#include "ADM_video/ADM_interlaced.h"
-
-#include "ADM_osSupport/ADM_debugID.h"
-#define MODULE_NAME MODULE_FILTER
-#include "ADM_osSupport/ADM_debug.h"
-#include "ADM_filter/video_filters.h"
-
-
-static FILTER_PARAM nullParam={0,{""}};
-
-
-SCRIPT_CREATE(swapsmart_script,AVDMVideoSwapSmart,nullParam);
-BUILD_CREATE(swapsmart_create,AVDMVideoSwapSmart);
-
-
-char *AVDMVideoSwapSmart::printConf( void )
-{
- 	static char buf[50];
-
- 	sprintf((char *)buf," Smart Swap fields");
-        return buf;
-}
-
-//_______________________________________________________________
-AVDMVideoSwapSmart::AVDMVideoSwapSmart(
-									AVDMGenericVideoStream *in,CONFcouple *setup)
-{
-UNUSED_ARG(setup);
-  	_in=in;
-   	memcpy(&_info,_in->getInfo(),sizeof(_info));	
-	_uncompressed=new ADMImage(_info.width,_info.height);
-
-
-
-}
-// ___ destructor_____________
-AVDMVideoSwapSmart::~AVDMVideoSwapSmart()
-{
- 	delete  _uncompressed;
-	_uncompressed=NULL;
-
-}
-
-//
-//	Basically ask a uncompressed frame from editor and ask
-//		GUI to decompress it .
-//
-
-uint8_t AVDMVideoSwapSmart::getFrameNumberNoAlloc(uint32_t frame,
-				uint32_t *len,
-   				ADMImage *data,
-				uint32_t *flags)
-{
-//static Image in,out;
-			if(frame>=_info.nb_frames) return 0;
-
-
-			// read uncompressed frame
-       		if(!_in->getFrameNumberNoAlloc(frame, len,data,flags)) return 0;
-
-		uint32_t w=_info.width;
-		uint32_t h=_info.height;
-		uint32_t page=w*h;
-		uint32_t stride;
-
-
-
-		uint8_t *odd,*even,*target,*target2;
-
-		even=YPLANE(data);
-		odd=even+w;
-		target=YPLANE(_uncompressed);
-		target2=_uncompressed->data+w;
-		stride=2*w;
-
-		h>>=1;
-		for(;h--;h>0)
-		{
-			memcpy(target,odd,w);
-			memcpy(target2,even,w);
-			target+=stride;
-			target2+=stride;
-			odd+=stride;
-			even+=stride;
-		}
-		// now we have straight and swapped
-		// which one is better ?
-		uint32_t s,m;
-		s=      ADMVideo_interlaceCount( YPLANE(data),_info.width, _info.height);
-		m=      ADMVideo_interlaceCount( YPLANE(_uncompressed),_info.width, _info.height);
-
-		aprintf(" %lu straight vs %lu swapped => %s\n",s,m,(s*2>m*3?"swapped":"straight"));
-
-		// if swapped <= 66 % straight
-
-		if(s*2>m*3)  // swapped is better
-		{
-			memcpy(YPLANE(data),YPLANE(_uncompressed),page);
-
-		}
-
-      return 1;
-}
-
-
-#endif

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSwapSmart.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSwapSmart.h	2007-01-13 11:40:52 UTC (rev 2719)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSwapSmart.h	2007-01-13 12:08:21 UTC (rev 2720)
@@ -1,36 +0,0 @@
-/***************************************************************************
-                          ADM_vidTelecide.h  -  description
-                             -------------------
-    begin                : Sun Aug 25 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-class  AVDMVideoSwapSmart:public AVDMGenericVideoStream
- {
-
- protected:
-
-
-        virtual char 					*printConf(void) ;
-
- public:
-  						AVDMVideoSwapSmart(  AVDMGenericVideoStream *in,CONFcouple *setup);
-  						~AVDMVideoSwapSmart();
-		      virtual uint8_t 	getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-          									ADMImage *data,uint32_t *flags);
-
-			virtual uint8_t 	configure( AVDMGenericVideoStream *instream) {return 1;};
-				 uint32_t   getMatch( uint8_t *src );
-
- }     ;
-
- 

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidTelecide.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidTelecide.cpp	2007-01-13 11:40:52 UTC (rev 2719)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidTelecide.cpp	2007-01-13 12:08:21 UTC (rev 2720)
@@ -1,259 +0,0 @@
-
-/***************************************************************************
-                          ADM_vidTelecide.cpp  -  description
-                             -------------------
-	Strongly inspired by Donal Graft deinterlacer (decomb)
-
-***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <ADM_assert.h>
-
-#include "config.h"
-#include "fourcc.h"
-#include "avio.hxx"
-#include "config.h"
-#include "avi_vars.h"
-#ifdef HAVE_ENCODER
-//#define EVEN_INTERLEAVE	
-
-#include "ADM_toolkit/toolkit.hxx"
-#include "ADM_editor/ADM_edit.hxx"
-#include "ADM_video/ADM_genvideo.hxx"
-
-#include"ADM_video/ADM_vidDeinterlace.h"
-#include"ADM_video/ADM_vidTelecide.h"
-#include "ADM_filter/video_filters.h"
-
-#define MATCH_THRESH 100
-#define ASM_DEINT
-#define ASM_BLEND
-static FILTER_PARAM nullParam={0,{""}};
-
-
-SCRIPT_CREATE(telecide_script,ADMVideoTelecide,nullParam);
-extern  int32_t _l_w,_l_h;
-extern uint8_t *_l_p,*_l_c,*_l_n;
-extern uint8_t *_l_e,*_l_e2;
-
-BUILD_CREATE(telecide_create,ADMVideoTelecide);
-
-
-char *ADMVideoTelecide::printConf(void)
-{
- 		return (char *)"Pal Smart";;
-}
-
-//_______________________________________________________________
-
-
-ADMVideoTelecide::ADMVideoTelecide(	AVDMGenericVideoStream *in,CONFcouple *setup)
-										: ADMVideoFields(in,setup)
-{
-	vidCache=new VideoCache(4,in);
-	_uncompressed=new ADMImage(_info.width,_info.height);
-  	
-}
-ADMVideoTelecide::~ADMVideoTelecide()
-{
- 	
-	delete vidCache;
-	vidCache=NULL;
-	delete _uncompressed;
-	
-}
-/*
-  	Interleave _uncompressed with in2
-   		even line from in2 odd=0
-      odd  line          odd=1
-*/
-uint8_t ADMVideoTelecide::interleave(	ADMImage *imgsrc, ADMImage *imgdst,uint8_t odd)
-{
- 	uint32_t w=_info.width;
-	uint8_t  *src1,*dst;
-	
-	src1=YPLANE(imgsrc);
-	dst=YPLANE(imgdst);
-	if(odd)
-	{
-		src1+=w;
-		dst+=w;
-	}
-	for(uint32_t y=(_info.height>>1);y>0;y--)
-		{
-        		memcpy(dst,src1,w);
-			src1+=w<<1;
-			dst+=w<<1;
-		}
-	return 1;
-}
-
-//
-//		Try to march fields of a frame with previous  / next until it is not interlaced	
-//
-//
-
-uint8_t ADMVideoTelecide::getFrameNumberNoAlloc(uint32_t frame,
-			uint32_t *len,
-			ADMImage *data,
-			uint32_t *flags)
-{
-uint32_t uvlen;
-uint32_t dummylen;
-uint8_t motion;
-
-uint32_t 	cmatch,nmatch,n2match;
-ADMImage	*cur,*next;
-
-			
-		if(frame>=_info.nb_frames) return 0;			
-		uvlen=    _info.width*_info.height;
-		*len=uvlen+(uvlen>>1);
-		
-		cur=vidCache->getImage(frame);
-		if(!cur) return 0;
-		data->copyInfo(cur);
-		if(!frame || frame==_info.nb_frames-1)
-		{
-
-			data->duplicate(cur);
-			vidCache->unlockAll();
-			return 1;
-		
-		}
-		
-		next=vidCache->getImage(frame-1);
-		if(!next) 
-		{
-			vidCache->unlockAll();
-			return 0;
-		}		
-		
-
-		// for u & v , no action -> copy it as is
-		memcpy(UPLANE(data),UPLANE(cur),uvlen>>2);
-		memcpy(VPLANE(data),VPLANE(cur),uvlen>>2);
-		data->copyInfo(cur);
-
-        	// No interleaving detected
-           	if(!(motion=hasMotion(data)) )
-		{
-			printf("\n Not interlaced !\n");
-			memcpy(YPLANE(data),YPLANE(cur),uvlen);
-			vidCache->unlockAll();
-      			return 1; // over !
-		}
-		// else cmatch is the current match
-		cmatch=getMatch(cur);
-
-/*	------------------------------------------------------------------------------------
-			Try to complete with next frame  fields
------------------------------------------------------------------------------------
-*/
-		// Interleav next in even field
-		
-		interleave(cur,_uncompressed,1);
-		interleave(next,_uncompressed,0);
-		nmatch=getMatch(_uncompressed);
-		
-		interleave(cur,_uncompressed,0);
-		interleave(next,_uncompressed,1);
-		n2match=getMatch(_uncompressed);
-
-		printf(" Cur  : %lu \n",cmatch);
-		printf(" Next : %lu \n",nmatch);
-		printf(" NextP: %lu \n",n2match);
-
-		if((cmatch<nmatch)&&(cmatch<n2match))
-		{
-			printf("\n __ pure interlaced __\n");
-			interleave(cur,_uncompressed,0);
-			interleave(cur,_uncompressed,1);
-			hasMotion(_uncompressed);
-	  		doBlend(_uncompressed,data);			
-			vidCache->unlockAll();
-			return 1;
-		}
-		if( nmatch > n2match)
-		{
-			printf("\n -------Shifted-P is better \n");	
-			if(hasMotion(_uncompressed))
-			{
-				 doBlend(_uncompressed,data);
-				 printf(" but there is still motion \n");
-			}
-			else
-				data->duplicate(_uncompressed);
-
-		}
-		else
-		{
-			printf("\n -------Shifted-O is better \n");
-			interleave(cur,_uncompressed,1);
-			interleave(next,_uncompressed,0);
-			if(hasMotion(_uncompressed))
-			{
-				 doBlend(_uncompressed,data);
-				 printf(" but there is still motion \n");
-			}
-			else
-				data->duplicate(_uncompressed);
-		}
-		// which chroma is better ? from current or from next ?
-		// search for a transition and see if there is also one ?
-		vidCache->unlockAll();				
-		return 1;						
-}
-
-/*
-   	Returns the number of difference (interlacing) found
-
-
-*/
-uint32_t      ADMVideoTelecide::getMatch( ADMImage *image )
-{
-
-			uint32_t m=0,x,y;
-
-			uint8_t *p,*n,*c;
-
-			p=YPLANE(image) ;
-			c=p+ _info.width;
-			n=c+ _info.width;
-			
-			for(y=_info.height>>2;  y >2 ; y--)
-			{
-           			for(x=_info.width;x>0;x--)
-				{
-					if(  (*c-*p)*(*c-*n) >MATCH_THRESH) 
-						m++;
-					p++;c++;n++;
-				}
-				p+=3*_info.width;
-				c+=3*_info.width;
-				n+=3*_info.width;
-
-			}
-
-                 return m;
-}
-
-
-
-#endif
-
-
-
-
-
-

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidTelecide.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidTelecide.h	2007-01-13 11:40:52 UTC (rev 2719)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidTelecide.h	2007-01-13 12:08:21 UTC (rev 2720)
@@ -1,37 +0,0 @@
-/***************************************************************************
-                          ADM_vidTelecide.h  -  description
-                             -------------------
-    begin                : Sun Aug 25 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include "ADM_video/ADM_vidField.h"
-#include "ADM_video/ADM_cache.h"
-class  ADMVideoTelecide:public ADMVideoFields
- {
-
- protected:
-    		uint32_t 		getMatch(ADMImage *image);
-             	uint8_t 		interleave(ADMImage *src1, ADMImage *dst,uint8_t odd);
-              	VideoCache		*vidCache;
- public:
- 		
-  					
-					ADMVideoTelecide(  AVDMGenericVideoStream *in,CONFcouple *setup);
-  			virtual 	~ADMVideoTelecide();
-			virtual uint8_t getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-          					ADMImage *data,uint32_t *flags);
-			 virtual char 	*printConf(void);		
- }     ;
-
-
- 

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidTempSmooth.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidTempSmooth.cpp	2007-01-13 11:40:52 UTC (rev 2719)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidTempSmooth.cpp	2007-01-13 12:08:21 UTC (rev 2720)
@@ -1,288 +0,0 @@
-/***************************************************************************
-                          ADM_vidTempSmooth.cpp  -  description
-                             -------------------
-
-	Temporal smoother
-	Adapted from avisynth
-	
-	For each pixel we check toward radius previous image if
-			u,v are within chroma_threshold
-			y   is within luma_threshold
-
-	if so, we blend them with the average value
-	
-	If more than 50% of pixels differs, it is probably a scene change
-	we refill the "previous" screens with present screen and send it as is.
-
-	That avoid blending when there is fade to black or whatever
-
-	For the moment, only u & v are used. Y will follow later.
-	A radius of 6 seems good.
-
-
-    begin                : Sun Jul 28 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-#if 0
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <ADM_assert.h>
-
-#include "config.h"
-#include "fourcc.h"
-#include "avio.hxx"
-#include "config.h"
-#include "avi_vars.h"
-
-
-#include "ADM_toolkit/toolkit.hxx"
-#include "ADM_editor/ADM_edit.hxx"
-#include "ADM_video/ADM_genvideo.hxx"
-#include "ADM_video/ADM_vidTempSmooth.h"
-BUILD_CREATE(tempsmooth_create,AVDMVideoTempSmooth);
- char *AVDMVideoTempSmooth::printConf(void)
-{
-static char str[100];
-		sprintf(str,"Temp Smooth : R = %02lu, chroma=%01lu,luma %01lu",_param->radius,
-					_param->luma_threshold,_param->chroma_threshold);
- 		return str;
-}
-
-uint8_t AVDMVideoTempSmooth::configure( AVDMGenericVideoStream *instream)
-{
-    UNUSED_ARG(instream);
- 	return 0;
-}
-
-//_______________________________________________________________
-
-AVDMVideoTempSmooth::AVDMVideoTempSmooth(
-									AVDMGenericVideoStream *in,CONFcouple *couples)
-{
-
-   	 _ptr_to_screen=NULL;
-	_screen=NULL;
-  	_in=in;		
-   	memcpy(&_info,_in->getInfo(),sizeof(_info));  		
-	if(couples)
-	{
-		_param=NEW(TEMPSMOOTH_PARAMS);
-		GET(radius);
-		GET(chroma_threshold);
-		GET(luma_threshold);
-	}
-    else
-    		{
-         			_param=NEW( TEMPSMOOTH_PARAMS);
-            		_param->radius=7;
-              	_param->luma_threshold=16;
-              	_param->chroma_threshold=12;
-
-
-        }
-
-					
-  _info.encoding=1;
-
-  	  	
-}
-
-uint8_t	AVDMVideoTempSmooth::getCoupledConf( CONFcouple **couples)
-{
-
-			ADM_assert(_param);
-			*couples=new CONFcouple(3);
-
-#define CSET(x)  (*couples)->setCouple((char *)#x,(_param->x))
-	CSET(radius);
-	CSET(chroma_threshold);
-	CSET(luma_threshold);
-
-			return 1;
-
-}
-AVDMVideoTempSmooth::~AVDMVideoTempSmooth()
-{
-DELETE(_param);
-	if(  _ptr_to_screen) free( _ptr_to_screen);
-	if(_screen) delete [] _screen;
- 	
-}
-
-uint8_t AVDMVideoTempSmooth::getFrameNumberNoAlloc(uint32_t frame,
-				uint32_t *len,
-   				ADMImage *data,
-				uint32_t *flags)
-{
-	uint32_t one_screen;
-	uint8_t *p;
-
-
-		one_screen=  _info.width*_info.height;
-		one_screen+=one_screen>>1;
-
-		if(!_screen) // first time -> allocate and fill the whole stuff
-			{
-
-         			// allocate ptr
-				//_ptr_to_screen=new *uint8_t[_param->_radius];
-				_ptr_to_screen=(uint8_t **)malloc(_param->radius*sizeof(uint8_t *));
-				_screen=new uint8_t[_param->radius*_info.width*_info.height*2];
-
-				p=_screen;
-
-				for(uint32_t i=0;i<_param->radius;i++)
-				{
-                          	
-					_ptr_to_screen[i]=p;
-					p+=one_screen;
-				}
-	        		if(!_in->getFrameNumberNoAlloc(frame, len,_screen,flags)) return 0;
-				// copy it to next ones
-				for(uint32_t i=1;i<_param->radius;i++)
-				{
-					memcpy( _ptr_to_screen[i],_screen,one_screen);
-				}
-
-				// ready !
-				memcpy(data,_screen,one_screen);
-				*len=one_screen;
-				return 1;							
-			}
-       	// now is the generic case
-	// first round rubbing the screens (0 being the most recent...)
-			uint8_t *o;
-			o=_ptr_to_screen[_param->radius-1];
-    			for(uint32_t i=1;i<_param->radius;i++)	
-			{
-			   	_ptr_to_screen[i]=_ptr_to_screen[i-1];
-            		}
-			_ptr_to_screen[0]=o;
-  			if(!_in->getFrameNumberNoAlloc(frame, len,o,flags)) return 0;
-	
-    		// now copy Y  will be dealt with later
-			memcpy(data ,o,     _info.width*_info.height);
-		
-			uint8_t cont1;
-			uint8_t u,v,nu,nv;
-//			uint8_t y1,y2,y3,y4,ny;
-//			uint8_t ny1,ny2,ny3,ny4;
-
-
-			uint32_t  same,diff;
-			int32_t delta,ru,rv;
-//			int32_t ry1,ry2,ry3,ry4;
-
-			uint8_t *out,*outu,*outv,*in,*inu,*inv;
-			uint32_t thres_chroma=		_param->chroma_threshold*_param->chroma_threshold;	
-//          	uint32_t thres_luma=		_param->luma_threshold*_param->luma_threshold;	
-
-			uint8_t **ptr  = (uint8_t **)malloc(_param->radius * sizeof(uint8_t *));
-			uint8_t **ptru = (uint8_t **)malloc(_param->radius * sizeof(uint8_t *));
-			uint8_t **ptrv = (uint8_t **)malloc(_param->radius * sizeof(uint8_t *));
-						ADM_assert(ptr);
-						ADM_assert(ptru);
-						ADM_assert(ptrv);
-
-						for(uint8_t j=1;j<_param->radius;j++)
-						{
-                      		ptr[j]=_ptr_to_screen[j];
-								ptru[j]=ptr[j]+_info.width*_info.height;
-								ptrv[j]=ptru[j]+(_info.width*_info.height>>2);
-
-						}
-
-
-	       same=diff=0;
-
-			out=data;
-			outu= out+_info.width*_info.height;
-			outv=outu+(_info.width*_info.height>>2);;
-
-			inu= o+_info.width*_info.height;
-			inv=inu+(_info.width*_info.height>>2);;
-
-			in=o;
-
-			
-
-       	for(uint32_t z=(_info.height>>1);z>0;z--)
-			{
-       	for(uint32_t x=(_info.width>>1);x>0;x--)
-			{
-	             		cont1=1;						
-
-						ru=u=*inu++;
-						rv=v=*inv++;
-#define IFF(w,t)  delta=n##w-w;delta*=delta; 	if((int32_t)delta<(int32_t)t)
-						for(uint8_t j=1;j<_param->radius;j++)
-						{
-								nu= *(ptru[j]++);
-								nv= *(ptrv[j]++);
-
-								IFF(u,thres_chroma)								
-									{                      	
-                            					IFF(v,thres_chroma)						
-													{
-#define IFFY(x) IFF(y##x,thres_luma) { ry##x## +=ny##x##;cont##x##++;ru+=nu;rv+=nv;}
-														
-															ru+=nu;
-															rv+=nv;
-															cont1++;														
-                                   			}              // end if chroma
-									
-									}                           // end if chroma
-
-                           } // end loop throught radius
-
-					// now check result
-					if(cont1!=1) 	same++; // we got a match!
-
-					if(cont1>1)
-					{					
-						*outu++= ( ru+(cont1>>1))/cont1;			
-						*outv++= ( rv+(cont1>>1))/cont1;
-					}
-					else
-					{
-                   	*outu++=128;          // hig light moving sections
-                   	*outv++=0;
-
-					}
-
-			} // end 140x
-		} // end y
-		*len=one_screen;
-		*flags=0;
-
-		 diff=(_info.width*_info.height>>2)-same;
-		if(diff>same) // scene change !
-		{
-        	printf("scene change detected\n");
-							for(uint32_t i=1;i<_param->radius;i++)
-							{
-								memcpy( _ptr_to_screen[i],o,one_screen);
-							}
-							memcpy(data,o,one_screen);
-
-
-		}
-		printf("same : %08lu diff: %08lu  total %08lu\n",same,diff,same+diff);
-	
-	free(ptr);
-	free(ptru);
-	free(ptrv);
-        return 1;
-}
-#endif

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidTempSmooth.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidTempSmooth.h	2007-01-13 11:40:52 UTC (rev 2719)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidTempSmooth.h	2007-01-13 12:08:21 UTC (rev 2720)
@@ -1,46 +0,0 @@
-/***************************************************************************
-                          ADM_vidTempSmooth.h  -  description
-                             -------------------
-    begin                : Sun Jul 28 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
- typedef struct
- {
-	   	uint32_t radius,chroma_threshold,luma_threshold;
-   }TEMPSMOOTH_PARAMS;
-
-
-    class  AVDMVideoTempSmooth:public AVDMGenericVideoStream
- {
-
- protected:
-
-    			uint8_t						*_unpack;
-           virtual 	char 						*printConf(void);
-    			TEMPSMOOTH_PARAMS				*_param;
-			uint8_t						**_ptr_to_screen;
-			uint8_t						*_screen;
- public:
-
-
-
-						AVDMVideoTempSmooth(  AVDMGenericVideoStream *in,CONFcouple *setup);
-  			virtual 		~AVDMVideoTempSmooth();
-		        virtual uint8_t 	getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-          						ADMImage *data,uint32_t *flags);
-			virtual uint8_t configure( AVDMGenericVideoStream *instream) ;
-			virtual uint8_t	getCoupledConf( CONFcouple **couples)		;
- }     ;
-
- AVDMGenericVideoStream *tempsmooth_create(AVDMGenericVideoStream *in, void *param);

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ASM_vidDenoise.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ASM_vidDenoise.cpp	2007-01-13 11:40:52 UTC (rev 2719)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ASM_vidDenoise.cpp	2007-01-13 12:08:21 UTC (rev 2720)
@@ -1,360 +0,0 @@
-/***************************************************************************
-                          ADM_vidDenoise.cpp  -  description
-                             -------------------
-    begin                : Mon Nov 25 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
-    
-    Denoiser inspired from DNR in transcode
-    Ported to YV12 and simplified
-    
-   Original code  Copyright (C) Gerhard Monzel - November 2001
-
-    
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <ADM_ADM_assert.h>
-#include <ADM_ADM_assert.h>
-#include <math.h>
-
-
-#include "fourcc.h"
-#include "avio.hxx"
-#include "config.h"
-#include "avi_vars.h"
-
-
-#include "ADM_toolkit/toolkit.hxx"
-#include "ADM_editor/ADM_edit.hxx"
-#include "ADM_video/ADM_genvideo.hxx"
-#include "ADM_video/ADM_vidDenoise.h"
-
-uint8_t distMatrix[256][256];
-
-//static uint8_t matrixReady=0;
-//static uint8_t doOnePix(uint8_t *in,uint8_t *out,uint8_t *lock,uint8_t *nb);
-
-
-
-
-
-
-char *ADMVideoDenoise::printConf( void )
-{
- 	static char buf[50];
-
-  ADM_ADM_assert(_param);
- 	sprintf((char *)buf," Denoise : Lum :%02ld/:%02ld / Chm :%02ld/%02ld",
-  								_param->lumaLock,
-          				_param->lumaThreshold,
-              		_param->chromaLock,
-                	_param->chromaThreshold);
-        return buf;
-}
-void buildDistMatrix( void );
-void buildDistMatrix( void )
-{
-int d;	
-	for(uint32_t y=255;y>0;y--)
-	for(uint32_t x=255;x>0;x--)
-	{
-		  d=x-y;
-		  if(d<0) d=-d;
-		  distMatrix[x][y]=d;
-		
-	}
-	
-	
-}
-
-//_______________________________________________________________
-
-ADMVideoDenoise::ADMVideoDenoise(
-									AVDMGenericVideoStream *in,void *setup)
-{
-
-
-  	_in=in;		
-   	memcpy(&_info,_in->getInfo(),sizeof(_info));  			 	
-    uint32_t page;
-    
-  _info.encoding=1;
-  
-  page= 3*_in->getInfo()->width*_in->getInfo()->height;
-  
-  _uncompressed=new uint8_t [page];
-  ADM_ADM_assert(_uncompressed);
-  
-  _locked=new uint8_t [page];
-  ADM_ADM_assert(_locked);
- 
-	_lockcount=new uint8_t [page];
-  ADM_ADM_assert(_lockcount);  
-  
-  memset(_lockcount,0,page);  
-        
-  _param=NULL;
-  
-  if(setup)
-  	{
-				_param=(NOISE_PARAM *)setup;	  	
-		 }
-	else
-		{
-			  #define XXX 1
-			  _param=NEW( NOISE_PARAM);
-			  _param->lumaLock=  4*XXX;
-			  _param->lumaThreshold= 10*XXX;
-			  _param->chromaLock=  8*XXX;
-			  _param->chromaThreshold= 16*XXX;
-        		  _param->sceneChange=  30*XXX;
-			}
-  	  _lastFrame=0xfffffff0;	
-}
-
-ADMVideoDenoise::ADMVideoDenoise(  AVDMGenericVideoStream *in,CONFcouple *couples)
-{
-	_param=NEW(NOISE_PARAM);
-	#define GET(x) ADM_ADM_assert(couples->getCouple((char *)#x,&(_param->x)))
-
-	GET(lumaLock);
-	GET(lumaThreshold);
-	GET(chromaLock);
-	GET(chromaThreshold);
-	GET(sceneChange);
-
-
-	ADMVideoDenoise(in,_param);
-
-
-}
-uint8_t	ADMVideoDenoise::getCoupledConf( CONFcouple **couples)
-{
-
-			ADM_ADM_assert(_param);
-			*couples=new CONFcouple(5);
-
-#define CSET(x)  (*couples)->setCouple((char *)#x,(_param->x))
-	CSET(lumaLock);
-	CSET(lumaThreshold);
-	CSET(chromaLock);
-	CSET(chromaThreshold);
-	CSET(sceneChange);
-
-	return 1;
-
-}
-
-ADMVideoDenoise::~ADMVideoDenoise()
-{
- 	
-	delete [] _uncompressed;
- 	delete [] _locked;
-  delete [] _lockcount;
-  
-  _uncompressed=_locked=_lockcount=NULL;
-}
-
-//
-//	Remove y and v just keep U and expand it
-//
-uint8_t ADMVideoDenoise::getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-          																	uint8_t *data,uint32_t *flags)
-{
-   //uint32_t x,w;
-  	uint32_t page; 
-   		ADM_ADM_assert(_param);
-			ADM_ADM_assert(frame<_info.nb_frames);
-								
-			
-       		if(!_in->getFrameNumberNoAlloc(frame, len,_uncompressed,flags)) return 0;
-       		  *len= _info.width*_info.height+(_info.width*_info.height>>1);       			
-                     
-           //uint32_t sz=_info.width*_info.height;
-
-          if((_lastFrame+1)!=frame) // async jump
-          {
-							// just copy it 
-								memcpy(data,_uncompressed,*len);
-								memcpy(_locked,_uncompressed,*len);
-								_lastFrame=frame;
-								return 1;
-					}          
-				_lastFrame=frame;
-          
-          // copy chroma for now
-          page=  _info.width*_info.height>>2;
-         
-          
-          //
-          //uint32_t count=0;
-          //uint32_t cell=page*4; // size of luma
-          uint8_t *in,*out,*lock,*nb;
-          uint8_t *uin,*uout,*ulock,*unb;
-          uint8_t *vin,*vout,*vlock,*vnb;
-          
-          
-          //uint32_t d;
-          // init all
-          
-          // luma
-          nb=_lockcount;
-          lock=_locked;
-          in=_uncompressed;
-          out=data;
-          // u
-          unb=nb+page*4;
-          ulock=lock+page*4;
-          uin=in+page*4;
-          uout=data+page*4;
-          // v
-          vnb=unb+page;
-          vlock=ulock+page;
-          vin=uin+page;
-          vout=uout+page;
-          
-          
-          uint32_t xx,yy/*,dl*/,du,dv;
-          uint32_t locked=0;
-          for(yy=_info.height>>1;yy>0;yy--)
-          {
-	          for(xx=_info.width>>1;xx>0;xx--)          
-  	        {
-								du=distMatrix[*uin][*ulock];														
-								dv=distMatrix[*vin][*vlock];														
-						
-								// if chroma is locked , we try to lock luma
-								if( (du<_param->chromaLock)
-									 && (dv<_param->chromaLock))
-									 {  
-										 			*uout=*ulock;
- 										 			*vout=*vlock;
-
-#define PIX(z) 		doOnePix(in+z,out+z,lock+z,nb+z)									 
-										 			locked+=PIX(0)+	PIX(1)+ 	PIX(_info.width)+
-										     	PIX(_info.width+1);										      										 
-										}
-										else
-								  // if chroma is blended, we blend luma
-#undef PIX								  
-#define PIX(z) 		doBlend(in+z,out+z,lock+z,nb+z)									 
-									if( (du<_param->chromaThreshold)
-									 && (dv<_param->chromaThreshold))
-										{
-											 		PIX(0);
-										    	PIX(1);
-										     	PIX(_info.width);
-										     	PIX(_info.width+1);															
-										      *uout=*ulock=(*uin+*uin)>>1;
- 										 			*vout=*vlock=(*vin+*vin)>>1;
-										}
-#undef PIX											
-										
-										else
-										{
-#define PIX(z) *(out+z)=*(lock+z)=*(in+z);*(nb+z)=0											
-											
-													PIX(0);
-										    	PIX(1);
-										     	PIX(_info.width);
-										     	PIX(_info.width+1);		
-										 			*uout=*ulock=*uin;
- 										 			*vout=*vlock=*vin;
-											
-#undef PIX											
-										}
-								  
-											                        				                        
-							uin++;uout++;ulock++;unb++;   
-							vin++;vout++;vlock++;vnb++;   
-							in++;out++;lock++;nb++;   
-							in++;out++;lock++;nb++;   
-							
-						}
-            // 
-            in+=_info.width;
-            out+=_info.width;
-            lock+=_info.width;
-            nb+=_info.width;            						
-					};
-          
-          if(locked>page*3) // if more than 75% pixel not locked -> scene change
-          {
-						  	memcpy(data,_uncompressed,*len);
-								memcpy(_locked,_uncompressed,*len);
-					}
-           
-      return 1;
-}
-
-//
-//	0 copy
-//  1 lock
-//  2 threshold
-//
-uint8_t ADMVideoDenoise::doOnePix(uint8_t *in,uint8_t *out,uint8_t *lock,uint8_t *nb)
-{
-unsigned int d;
-							d=distMatrix[*(in)][*(lock)]; 
-							if(d<_param->lumaLock)         
-							{								                
-								if(*(nb)>30)  // out of scope -> copy new                   
-								{  						// too much copy ->                              
-										*(nb)=0;                       
-										*(out)=(*(in)+*(lock))>>1;
-										*(lock)=*(out);    										
-										return DN_COPY;      
-								}                                 
-								else                               
-								{                                   
-									*(out)=*(lock);		
-									*nb += 1; // *(nb)++;	
-									return DN_LOCK;		
-								}                  
-							}                     
-							else if(d< _param->lumaThreshold) 
-							{                                  
-								 *(nb)=0;                           
-									*(out)=(*(in)+*(lock))>>1;	
-									return DN_BLEND;							
-							}
-							else   // too big delta
-							{    
-								 *(nb)=0; 
-									*(out)=*(in);	  
-									*(lock)=*(in);    
-									return DN_COPY;
-							}                     
-					                           
-							ADM_ADM_assert(0);
-							return 0;
-
-}
-uint8_t ADMVideoDenoise::doBlend(uint8_t *in,uint8_t *out,uint8_t *lock,uint8_t *nb)
-{
-unsigned int d;
-		   d=distMatrix[*(in)][*(lock)]; 
-		   *nb=0;
-		   
-			if(d<_param->lumaThreshold)         
-			{
-					*(out)=(*(in)+*(lock))>>1;					
-			}
-			else
-			*out=*in;
-			return 0;
-	
-}
-
-// EOF

Modified: branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am	2007-01-13 11:40:52 UTC (rev 2719)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am	2007-01-13 12:08:21 UTC (rev 2720)
@@ -8,7 +8,6 @@
 
 libADM_video_a_SOURCES = ADM_vidFields.cpp \
  ADM_vidDeintASM.cpp \
- ADM_vidSalt.cpp \
  ADM_vidCached.cpp \
  ADM_vidPartial.cpp \
  ADM_vidFont.cpp \
@@ -18,25 +17,18 @@
  ADM_vidCrop.cpp \
  ADM_vidDeinterlace.cpp \
  ADM_vidNull.cpp \
- ADM_vidPalShift.cpp \
 	ADM_vidResize.cpp \
- ADM_vidTelecide.cpp \
- ADM_vidTempSmooth.cpp \
 	ADM_vidClean.cpp \
 	ADM_resizebis.cpp \
  ADM_genvideo.cpp \
  ADM_vidRotate.cpp \
  ADM_vidRotate.h \
  ADM_vidResize25.cpp \
- ADM_vidSwapFields.cpp \
-	ADM_vidSwapFields.h ADM_vidSeparateField.cpp \
  ADM_vidFieldUtil.cpp \
  ADM_vidFieldUtil.h \
-	ADM_vidSeparateField.h ADM_confCouples.cpp \
+ ADM_confCouples.cpp \
  ADM_confCouple.h ADM_vidCommonFilter.h \
 	ADM_vidChromaShift.h ADM_vidChromaShift.cpp \
- ADM_vidSwapSmart.cpp \
- ADM_vidSwapSmart.h \
 	ADM_vidMPLResize.cpp \
  ADM_vidIVTC.cpp \
  ADM_vidIVTC.h ADM_interlaced.cpp \
@@ -64,7 +56,6 @@
  ADM_vidColorYuv.cpp  \
  ADM_guiResize.cpp \
  ADM_vidAnimated.cpp \
- ADM_vidReverse.cpp  \
  ADM_vidASS.cpp
 
 				
@@ -73,8 +64,8 @@
 EXTRA_DIST =  ADM_cache.cpp  ADM_vidDecDec_param.h \
 ADM_cache.h  ADM_vidDecTel_param.h \
 ADM_confCouple.h ADM_vidDecTelecide.cpp  ADM_vidNull.cpp \
-ADM_confCouples.cpp  ADM_vidDecTelecide.h  ADM_vidPalShift.cpp \
-ADM_genvideo.cpp ADM_vidDeintASM.cpp ADM_vidPalShift.h \
+ADM_confCouples.cpp  ADM_vidDecTelecide.h  \
+ADM_genvideo.cpp ADM_vidDeintASM.cpp \
 ADM_genvideo.hxx ADM_vidDeinterlace.cpp  ADM_vidPartial.cpp \
 ADM_vidDeinterlace.h  ADM_vidPartial.h \
 ADM_vidDelta.cpp  ADM_vidPartial_param.h \
@@ -82,31 +73,27 @@
 ADM_interlaced.cpp  \
 ADM_interlaced.h ADM_vidEq2.cpp  ADM_vidResize.cpp \
 ADM_vidEq2.h  ADM_vidResize25.cpp \
-ADM_vidEqualizer.cpp  ADM_vidReverse.cpp \
+ADM_vidEqualizer.cpp  \
 ADM_mpdetc.cpp ADM_vidEqualizer.h  ADM_vidRotate.cpp \
 ADM_mpdetc.h ADM_vidRotate.h \
 ADM_resizebis.cpp   ADM_vidSRT.cpp \
 ADM_resizebis.hxx    ADM_vidSRT.h \
 ADM_resizeter.cpp  ADM_vidField.h  ADM_vidSRTRender.cpp \
 ADM_vidFieldUnblend.cpp ADM_vidSRTload.cpp \
-ADM_vidASharp_param.h  ADM_vidFieldUtil.cpp  ADM_vidSalt.cpp \
-ADM_vidFieldUtil.h  ADM_vidSalt.h \
-ADM_vidFields.cpp ADM_vidSeparateField.cpp \
-ADM_vidAnimated.cpp  ADM_vidSeparateField.h \
+ADM_vidASharp_param.h  ADM_vidFieldUtil.cpp  \
+ADM_vidFieldUtil.h  \
+ADM_vidFields.cpp \
+ADM_vidAnimated.cpp  \
 ADM_vidAnimated.h  \
 ADM_vidAnimated_param.h   \
 ADM_vidAsharp.cpp   \
 ADM_vidFont.cpp \
-ADM_vidBlend.cpp ADM_vidFont.h ADM_vidSwapFields.cpp \
-ADM_vidSwapFields.h \
-ADM_vidSwapSmart.cpp \
-ADM_vidCNR2.cpp  ADM_vidSwapSmart.h \
+ADM_vidBlend.cpp ADM_vidFont.h \
+ADM_vidCNR2.cpp  \
 ADM_vidCNR2_param.h  ADM_vidHue.cpp  ADM_vidTDeint_param.h \
 ADM_vidCached.cpp  ADM_vidHue.h  ADM_vidTdeint.cpp \
-ADM_vidCached.h  ADM_vidIVTC.cpp ADM_vidTelecide.cpp \
-ADM_vidIVTC.h ADM_vidTelecide.h \
-ADM_vidTempSmooth.cpp \
-ADM_vidTempSmooth.h \
+ADM_vidCached.h  ADM_vidIVTC.cpp \
+ADM_vidIVTC.h \
 ADM_vidChromaShift.cpp \
 ADM_vidChromaShift.h ADM_vidUnblend.cpp \
 ADM_vidClean.cpp ADM_vidUnblend_param.h \
@@ -119,7 +106,6 @@
 ADM_vidContrast.h  ADM_vidMPdelogo.h \
 ADM_vobsubinfo.cpp \
 ADM_vidCrop.cpp  ADM_vidMSmooth_param.h  ADM_vobsubinfo.h \
-ASM_vidDenoise.cpp \
 ADM_vidDecDec.cpp  swscale_internal.h \
 ADM_vidTdeint_util.txt ADM_vidASS.h ADM_vidASS.cpp \
 ADM_vidAss_Params.h mmx_macros.h

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidPalShift.cpp (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidPalShift.cpp)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidPalShift.cpp	2006-10-31 15:59:58 UTC (rev 2489)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidPalShift.cpp	2007-01-13 12:08:21 UTC (rev 2720)
@@ -0,0 +1,158 @@
+/***************************************************************************
+                          ADM_vidPalShift.cpp  -  description
+                             -------------------
+    begin                : Sat Aug 24 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+ #include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ADM_assert.h>
+
+#include "config.h"
+#include "fourcc.h"
+#include "avio.hxx"
+#include "config.h"
+#include "avi_vars.h"
+#ifdef HAVE_ENCODER
+
+
+#include "ADM_toolkit/toolkit.hxx"
+#include "ADM_editor/ADM_edit.hxx"
+#include "ADM_video/ADM_genvideo.hxx"
+#include "ADM_vidPalShift.h"
+#include "ADM_filter/video_filters.h"
+
+#include "ADM_userInterfaces/ADM_commonUI/DIA_factory.h"
+
+static FILTER_PARAM nullParam={0,{""}};
+
+
+SCRIPT_CREATE(addPALShift_script,ADMVideoPalShift,nullParam);
+BUILD_CREATE(addPALShift_create,ADMVideoPalShift);
+
+
+char *ADMVideoPalShift::printConf( void )
+{
+ 	static char buf[50];
+ 	
+ 	sprintf((char *)buf," PAL field shift");
+        return buf;
+}
+
+ADMVideoPalShift::ADMVideoPalShift(  AVDMGenericVideoStream *in,CONFcouple *setup)
+{
+	UNUSED_ARG(setup);
+	
+
+	_reverse=NULL;
+ 	_in=in;		
+	memcpy(&_info,_in->getInfo(),sizeof(_info));  		
+	
+
+	_reverse=new uint32_t;;
+	*_reverse=1;
+	
+  	_info.encoding=1;
+
+	vidCache=new VideoCache(5,in);
+
+
+  	  	
+}
+ uint8_t ADMVideoPalShift::configure( AVDMGenericVideoStream *instream) 
+{
+  
+  diaElemToggle chroma(_reverse,_("Try reverse"));
+    
+    diaElem *elems[]={&chroma};
+  
+    return diaFactoryRun("Pal Shift",sizeof(elems)/sizeof(diaElem *),elems);
+
+} 
+ADMVideoPalShift::~ADMVideoPalShift()
+{
+	delete vidCache;
+	delete _reverse;
+}
+uint8_t ADMVideoPalShift::getFrameNumberNoAlloc(uint32_t frame,
+				uint32_t *len,
+   				ADMImage *data,
+				uint32_t *flags)
+{
+
+uint32_t full,half;
+ADMImage *cur,*next;
+
+		full=_info.width*_info.height;
+		half=full>>2;
+
+		if(frame>=_info.nb_frames) return 0;
+		
+		cur=vidCache->getImage(frame);
+		if(!cur) return 0;
+			
+		// for first or last frame do nothing
+		if(!frame || frame==_info.nb_frames-1)
+		{
+
+			data->duplicate(cur);
+			vidCache->unlockAll();
+			return 1;	
+		}				
+								
+		// copy u & v as they are			
+
+		memcpy(UPLANE(data),UPLANE(cur),half);
+		memcpy(VPLANE(data),VPLANE(cur),half);
+
+		// now copy odd field from framei and even frame from frame i-1		
+		// OR the other way around
+		uint32_t dline=_info.width;
+		
+		next=vidCache->getImage(frame+1);
+		if(!next) return 0;
+
+		//
+		uint8_t *src,*dst,*src2;
+		if(!*_reverse)
+		{
+			src2=YPLANE(cur)+dline;
+			src=YPLANE(next);
+			dst=YPLANE(data);
+		}
+		else
+		{
+			src2=YPLANE(next)+dline;
+			src=YPLANE(cur);
+			dst=YPLANE(data);
+		
+		}
+		for(uint32_t y=(_info.height>>1);y>0;y--)
+		{
+                	memcpy(dst,src, dline);
+			dst+=dline;
+                	memcpy(dst,src2, dline);
+			dst+=dline;
+			src+=dline*2;
+			src2+=dline*2;
+		}
+		
+	vidCache->unlockAll();
+			data->copyInfo(cur);
+      return 1;
+}
+
+
+
+#endif

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidPalShift.h (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidPalShift.h)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidPalShift.h	2006-10-31 15:59:58 UTC (rev 2489)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidPalShift.h	2007-01-13 12:08:21 UTC (rev 2720)
@@ -0,0 +1,42 @@
+/***************************************************************************
+                          ADM_vidPalShift.h  -  description
+                             -------------------
+    begin                : Sat Aug 24 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef PALSHIFT__
+#define PALSHIFT__
+#include "ADM_video/ADM_cache.h" 
+ class  ADMVideoPalShift:public AVDMGenericVideoStream
+ {
+
+ protected:
+    		
+		VideoCache			*vidCache;
+     virtual 	char 				*printConf(void);
+
+		uint32_t			*_reverse;
+
+
+ public:
+
+
+  				ADMVideoPalShift(  AVDMGenericVideoStream *in,CONFcouple *setup);
+
+  	virtual 		~ADMVideoPalShift();
+	virtual uint8_t 	getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
+          								ADMImage *data,uint32_t *flags);
+	virtual uint8_t configure( AVDMGenericVideoStream *instream) ;
+
+ }     ;
+#endif

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidPalSmart.cpp (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidTelecide.cpp)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidTelecide.cpp	2006-10-31 15:59:58 UTC (rev 2489)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidPalSmart.cpp	2007-01-13 12:08:21 UTC (rev 2720)
@@ -0,0 +1,259 @@
+
+/***************************************************************************
+                          ADM_vidTelecide.cpp  -  description
+                             -------------------
+	Strongly inspired by Donal Graft deinterlacer (decomb)
+
+***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ADM_assert.h>
+
+#include "config.h"
+#include "fourcc.h"
+#include "avio.hxx"
+#include "config.h"
+#include "avi_vars.h"
+#ifdef HAVE_ENCODER
+//#define EVEN_INTERLEAVE	
+
+#include "ADM_toolkit/toolkit.hxx"
+#include "ADM_editor/ADM_edit.hxx"
+#include "ADM_video/ADM_genvideo.hxx"
+
+#include"ADM_video/ADM_vidDeinterlace.h"
+#include"ADM_vidPalSmart.h"
+#include "ADM_filter/video_filters.h"
+
+#define MATCH_THRESH 100
+#define ASM_DEINT
+#define ASM_BLEND
+static FILTER_PARAM nullParam={0,{""}};
+
+
+SCRIPT_CREATE(telecide_script,ADMVideoTelecide,nullParam);
+extern  int32_t _l_w,_l_h;
+extern uint8_t *_l_p,*_l_c,*_l_n;
+extern uint8_t *_l_e,*_l_e2;
+
+BUILD_CREATE(telecide_create,ADMVideoTelecide);
+
+
+char *ADMVideoTelecide::printConf(void)
+{
+ 		return (char *)"Pal Smart";;
+}
+
+//_______________________________________________________________
+
+
+ADMVideoTelecide::ADMVideoTelecide(	AVDMGenericVideoStream *in,CONFcouple *setup)
+										: ADMVideoFields(in,setup)
+{
+	vidCache=new VideoCache(4,in);
+	_uncompressed=new ADMImage(_info.width,_info.height);
+  	
+}
+ADMVideoTelecide::~ADMVideoTelecide()
+{
+ 	
+	delete vidCache;
+	vidCache=NULL;
+	delete _uncompressed;
+	
+}
+/*
+  	Interleave _uncompressed with in2
+   		even line from in2 odd=0
+      odd  line          odd=1
+*/
+uint8_t ADMVideoTelecide::interleave(	ADMImage *imgsrc, ADMImage *imgdst,uint8_t odd)
+{
+ 	uint32_t w=_info.width;
+	uint8_t  *src1,*dst;
+	
+	src1=YPLANE(imgsrc);
+	dst=YPLANE(imgdst);
+	if(odd)
+	{
+		src1+=w;
+		dst+=w;
+	}
+	for(uint32_t y=(_info.height>>1);y>0;y--)
+		{
+        		memcpy(dst,src1,w);
+			src1+=w<<1;
+			dst+=w<<1;
+		}
+	return 1;
+}
+
+//
+//		Try to march fields of a frame with previous  / next until it is not interlaced	
+//
+//
+
+uint8_t ADMVideoTelecide::getFrameNumberNoAlloc(uint32_t frame,
+			uint32_t *len,
+			ADMImage *data,
+			uint32_t *flags)
+{
+uint32_t uvlen;
+uint32_t dummylen;
+uint8_t motion;
+
+uint32_t 	cmatch,nmatch,n2match;
+ADMImage	*cur,*next;
+
+			
+		if(frame>=_info.nb_frames) return 0;			
+		uvlen=    _info.width*_info.height;
+		*len=uvlen+(uvlen>>1);
+		
+		cur=vidCache->getImage(frame);
+		if(!cur) return 0;
+		data->copyInfo(cur);
+		if(!frame || frame==_info.nb_frames-1)
+		{
+
+			data->duplicate(cur);
+			vidCache->unlockAll();
+			return 1;
+		
+		}
+		
+		next=vidCache->getImage(frame-1);
+		if(!next) 
+		{
+			vidCache->unlockAll();
+			return 0;
+		}		
+		
+
+		// for u & v , no action -> copy it as is
+		memcpy(UPLANE(data),UPLANE(cur),uvlen>>2);
+		memcpy(VPLANE(data),VPLANE(cur),uvlen>>2);
+		data->copyInfo(cur);
+
+        	// No interleaving detected
+           	if(!(motion=hasMotion(data)) )
+		{
+			printf("\n Not interlaced !\n");
+			memcpy(YPLANE(data),YPLANE(cur),uvlen);
+			vidCache->unlockAll();
+      			return 1; // over !
+		}
+		// else cmatch is the current match
+		cmatch=getMatch(cur);
+
+/*	------------------------------------------------------------------------------------
+			Try to complete with next frame  fields
+-----------------------------------------------------------------------------------
+*/
+		// Interleav next in even field
+		
+		interleave(cur,_uncompressed,1);
+		interleave(next,_uncompressed,0);
+		nmatch=getMatch(_uncompressed);
+		
+		interleave(cur,_uncompressed,0);
+		interleave(next,_uncompressed,1);
+		n2match=getMatch(_uncompressed);
+
+		printf(" Cur  : %lu \n",cmatch);
+		printf(" Next : %lu \n",nmatch);
+		printf(" NextP: %lu \n",n2match);
+
+		if((cmatch<nmatch)&&(cmatch<n2match))
+		{
+			printf("\n __ pure interlaced __\n");
+			interleave(cur,_uncompressed,0);
+			interleave(cur,_uncompressed,1);
+			hasMotion(_uncompressed);
+	  		doBlend(_uncompressed,data);			
+			vidCache->unlockAll();
+			return 1;
+		}
+		if( nmatch > n2match)
+		{
+			printf("\n -------Shifted-P is better \n");	
+			if(hasMotion(_uncompressed))
+			{
+				 doBlend(_uncompressed,data);
+				 printf(" but there is still motion \n");
+			}
+			else
+				data->duplicate(_uncompressed);
+
+		}
+		else
+		{
+			printf("\n -------Shifted-O is better \n");
+			interleave(cur,_uncompressed,1);
+			interleave(next,_uncompressed,0);
+			if(hasMotion(_uncompressed))
+			{
+				 doBlend(_uncompressed,data);
+				 printf(" but there is still motion \n");
+			}
+			else
+				data->duplicate(_uncompressed);
+		}
+		// which chroma is better ? from current or from next ?
+		// search for a transition and see if there is also one ?
+		vidCache->unlockAll();				
+		return 1;						
+}
+
+/*
+   	Returns the number of difference (interlacing) found
+
+
+*/
+uint32_t      ADMVideoTelecide::getMatch( ADMImage *image )
+{
+
+			uint32_t m=0,x,y;
+
+			uint8_t *p,*n,*c;
+
+			p=YPLANE(image) ;
+			c=p+ _info.width;
+			n=c+ _info.width;
+			
+			for(y=_info.height>>2;  y >2 ; y--)
+			{
+           			for(x=_info.width;x>0;x--)
+				{
+					if(  (*c-*p)*(*c-*n) >MATCH_THRESH) 
+						m++;
+					p++;c++;n++;
+				}
+				p+=3*_info.width;
+				c+=3*_info.width;
+				n+=3*_info.width;
+
+			}
+
+                 return m;
+}
+
+
+
+#endif
+
+
+
+
+
+

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidPalSmart.h (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidTelecide.h)

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidReverse.cpp (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidReverse.cpp)

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidSeparateField.cpp (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSeparateField.cpp)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSeparateField.cpp	2006-10-31 15:59:58 UTC (rev 2489)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidSeparateField.cpp	2007-01-13 12:08:21 UTC (rev 2720)
@@ -0,0 +1,269 @@
+/***************************************************************************
+                          Separate Fields.cpp  -  description
+                             -------------------
+Convert a x*y * f fps video into -> x*(y/2)*fps/2 video
+
+Same idea as for avisynth separatefield
+
+
+    begin                : Thu Mar 21 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ADM_assert.h>
+
+#include "config.h"
+#include "fourcc.h"
+#include "avio.hxx"
+#include "config.h"
+#include "avi_vars.h"
+
+
+#include "ADM_toolkit/toolkit.hxx"
+#include "ADM_editor/ADM_edit.hxx"
+#include "ADM_video/ADM_genvideo.hxx"
+#include "ADM_video/ADM_vidFieldUtil.h"
+#include "ADM_vidSeparateField.h"
+#include "ADM_filter/video_filters.h"
+
+
+static FILTER_PARAM swapParam={0,{""}};
+
+SCRIPT_CREATE(separatefield_script,AVDMVideoSeparateField,swapParam);
+SCRIPT_CREATE(mergefield_script,AVDMVideoMergeField,swapParam);
+SCRIPT_CREATE(stackfield_script,AVDMVideoStackField,swapParam);
+SCRIPT_CREATE(unstackfield_script,AVDMVideoUnStackField,swapParam);
+
+BUILD_CREATE(separatefield_create,AVDMVideoSeparateField);
+BUILD_CREATE(mergefield_create,AVDMVideoMergeField);
+BUILD_CREATE(stackfield_create,AVDMVideoStackField);
+BUILD_CREATE(unstackfield_create,AVDMVideoUnStackField);
+
+char *AVDMVideoSeparateField::printConf( void )
+{
+ 	static char buf[50];
+
+ 	sprintf((char *)buf," Separate Fields");
+        return buf;
+}
+
+//_______________________________________________________________
+AVDMVideoSeparateField::AVDMVideoSeparateField(
+									AVDMGenericVideoStream *in,CONFcouple *setup)
+{
+UNUSED_ARG(setup);
+  	_in=in;
+   	memcpy(&_info,_in->getInfo(),sizeof(_info));
+	
+
+	_info.height>>=1;
+	_info.fps1000*=2;
+	_info.nb_frames*=2;
+	vidCache=new VideoCache(2,_in);
+
+}
+
+// ___ destructor_____________
+AVDMVideoSeparateField::~AVDMVideoSeparateField()
+{
+ 	
+	delete vidCache;
+	vidCache=NULL;
+}
+
+//
+//	Basically ask a uncompressed frame from editor and ask
+//		GUI to decompress it .
+//
+
+uint8_t AVDMVideoSeparateField::getFrameNumberNoAlloc(uint32_t frame,
+				uint32_t *len,
+   				ADMImage *data,
+				uint32_t *flags)
+{
+uint32_t ref;
+ADMImage *ptr;
+		if(frame>=_info.nb_frames) return 0;
+		ref=frame>>1;
+		
+		ptr=vidCache->getImage(ref);
+		if(!ptr) return 0;
+
+		ADM_assert(ptr->data);
+		ADM_assert(data->data);
+		if(frame&1) // odd image
+			 vidFieldKeepOdd(_info.width,_info.height,ptr->data,data->data);
+		else
+			 vidFieldKeepEven(_info.width,_info.height,ptr->data,data->data);
+		data->copyInfo(ptr);	
+		vidCache->unlockAll();
+      return 1;
+}
+//------------------ and merge them ------------------
+
+
+char *AVDMVideoMergeField::printConf( void )
+{
+ 	static char buf[50];
+
+ 	sprintf((char *)buf," Merge fields");
+        return buf;
+}
+
+//_______________________________________________________________
+AVDMVideoMergeField::AVDMVideoMergeField(
+									AVDMGenericVideoStream *in,CONFcouple *setup)
+{
+UNUSED_ARG(setup);
+  	_in=in;
+   	memcpy(&_info,_in->getInfo(),sizeof(_info));	
+	vidCache=new VideoCache(4,_in);
+	
+
+	_info.height<<=1;
+	_info.fps1000>>=1;
+	_info.nb_frames>>=1;
+
+
+}
+
+// ___ destructor_____________
+AVDMVideoMergeField::~AVDMVideoMergeField()
+{
+ 		delete vidCache;
+		vidCache=NULL;
+}
+
+/**
+	Interleave frame*2 and frame*2+1
+*/
+uint8_t AVDMVideoMergeField::getFrameNumberNoAlloc(uint32_t frame,
+				uint32_t *len,
+   				ADMImage *data,
+				uint32_t *flags)
+{
+uint32_t ref,ref2;
+ADMImage *ptr1,*ptr2;
+		if(frame>=_info.nb_frames) return 0;
+
+		ref=frame<<1;
+		ref2=ref+1;
+		ptr1=vidCache->getImage(ref);
+		ptr2=vidCache->getImage(ref+1);
+		
+		if(!ptr1 || !ptr2)
+		{
+			printf("Merge field : cannot read\n");
+			vidCache->unlockAll();
+		 	return 0;
+		}
+		 vidFieldMerge(_info.width,_info.height,ptr1->data,ptr2->data,data->data);
+		 vidCache->unlockAll();
+		
+      return 1;
+}
+//_______________________Stack Fields_______________________
+
+char *AVDMVideoStackField::printConf( void )
+{
+ 	static char buf[50];
+
+ 	sprintf((char *)buf," Stack fields");
+        return buf;
+}
+
+//_______________________________________________________________
+AVDMVideoStackField::AVDMVideoStackField(	AVDMGenericVideoStream *in,CONFcouple *setup)
+{
+UNUSED_ARG(setup);
+  	_in=in;
+   	memcpy(&_info,_in->getInfo(),sizeof(_info));	
+	_uncompressed=new ADMImage(_info.width,_info.height);	
+
+}
+
+// ___ destructor_____________
+AVDMVideoStackField::AVDMVideoStackField()
+{
+ 		delete _uncompressed;
+		_uncompressed=NULL;
+}
+
+/**
+	Interleave frame*2 and frame*2+1
+*/
+uint8_t AVDMVideoStackField::getFrameNumberNoAlloc(uint32_t frame,
+				uint32_t *len,
+   				ADMImage *data,
+				uint32_t *flags)
+{
+uint32_t ref,ref2;
+ADMImage *ptr1,*ptr2;
+		if(frame>=_info.nb_frames) return 0;
+
+		 if(!_in->getFrameNumberNoAlloc(frame, len, _uncompressed, flags)) return 0;
+		 
+		  vidFielStack(_info.width ,_info.height,YPLANE(_uncompressed),YPLANE(data));
+		data->copyInfo(_uncompressed);	
+      return 1;
+}
+
+/****/
+//_______________________Stack Fields_______________________
+
+char *AVDMVideoUnStackField::printConf( void )
+{
+        static char buf[50];
+
+        sprintf((char *)buf," UnStack fields");
+        return buf;
+}
+
+//_______________________________________________________________
+AVDMVideoUnStackField::AVDMVideoUnStackField(       AVDMGenericVideoStream *in,CONFcouple *setup)
+{
+UNUSED_ARG(setup);
+        _in=in;
+        memcpy(&_info,_in->getInfo(),sizeof(_info));    
+        _uncompressed=new ADMImage(_info.width,_info.height);   
+
+}
+
+// ___ destructor_____________
+AVDMVideoUnStackField::AVDMVideoUnStackField()
+{
+                delete _uncompressed;
+                _uncompressed=NULL;
+}
+
+/**
+        Interleave frame*2 and frame*2+1
+*/
+uint8_t AVDMVideoUnStackField::getFrameNumberNoAlloc(uint32_t frame,
+                                uint32_t *len,
+                                ADMImage *data,
+                                uint32_t *flags)
+{
+uint32_t ref,ref2;
+ADMImage *ptr1,*ptr2;
+                if(frame>=_info.nb_frames) return 0;
+
+                 if(!_in->getFrameNumberNoAlloc(frame, len, _uncompressed, flags)) return 0;
+                 
+                  vidFielUnStack(_info.width ,_info.height,YPLANE(_uncompressed),YPLANE(data));
+                data->copyInfo(_uncompressed);  
+      return 1;
+}

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidSeparateField.h (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSeparateField.h)

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidSwapFields.cpp (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSwapFields.cpp)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSwapFields.cpp	2006-10-31 15:59:58 UTC (rev 2489)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidSwapFields.cpp	2007-01-13 12:08:21 UTC (rev 2720)
@@ -0,0 +1,200 @@
+/***************************************************************************
+                          Swap Fields.cpp  -  description
+                             -------------------
+Swap each line  (shift up for odd, down for even)
+
+
+    begin                : Thu Mar 21 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ADM_assert.h>
+
+#include "config.h"
+#include "fourcc.h"
+#include "avio.hxx"
+#include "config.h"
+#include "avi_vars.h"
+#ifdef HAVE_ENCODER
+
+
+#include "ADM_toolkit/toolkit.hxx"
+#include "ADM_editor/ADM_edit.hxx"
+#include "ADM_video/ADM_genvideo.hxx"
+#include "ADM_video/ADM_vidFieldUtil.h"
+#include "ADM_vidSwapFields.h"
+//static void decimate(uint8_t *src,uint8_t *target, uint32_t linessrc, uint32_t width);
+#include "ADM_filter/video_filters.h"
+
+
+static FILTER_PARAM swapParam={0,{""}};
+
+
+
+BUILD_CREATE(swapfield_create,AVDMVideoSwapField);
+BUILD_CREATE(keepeven_create,AVDMVideoKeepEven);
+BUILD_CREATE(keepodd_create,AVDMVideoKeepOdd);
+
+SCRIPT_CREATE(swapfield_script,AVDMVideoSwapField,swapParam);
+SCRIPT_CREATE(keepeven_script,AVDMVideoKeepEven,swapParam);
+SCRIPT_CREATE(keepodd_script,AVDMVideoKeepOdd,swapParam);
+
+char *AVDMVideoSwapField::printConf( void )
+{
+ 	static char buf[50];
+
+ 	sprintf((char *)buf," Swap fields");
+        return buf;
+}
+char *AVDMVideoKeepEven::printConf( void )
+{
+ 	static char buf[50];
+
+ 	sprintf((char *)buf," Keep Even Fields");
+        return buf;
+}char *AVDMVideoKeepOdd::printConf( void )
+{
+ 	static char buf[50];
+
+ 	sprintf((char *)buf," Keep Odd Fields");
+        return buf;
+}
+//_______________________________________________________________
+AVDMVideoSwapField::AVDMVideoSwapField(
+									AVDMGenericVideoStream *in,CONFcouple *setup)
+{
+UNUSED_ARG(setup);
+  	_in=in;
+   	memcpy(&_info,_in->getInfo(),sizeof(_info));
+	_uncompressed=new ADMImage(_info.width,_info.height);
+
+
+}
+//_______________________________________________________________
+AVDMVideoKeepOdd::AVDMVideoKeepOdd(
+									AVDMGenericVideoStream *in,CONFcouple *setup)
+{
+UNUSED_ARG(setup);
+  	_in=in;
+	memcpy(&_info,_in->getInfo(),sizeof(_info));
+	_uncompressed=new ADMImage(_info.width,_info.height);
+	_info.height>>=1;
+
+}
+// ___ destructor_____________
+AVDMVideoSwapField::~AVDMVideoSwapField()
+{
+ 	delete  _uncompressed;
+	_uncompressed=NULL;
+
+}
+// ___ destructor_____________
+AVDMVideoKeepOdd::~AVDMVideoKeepOdd()
+{
+ 	delete _uncompressed;
+	_uncompressed=NULL;
+
+}
+
+//
+//	Basically ask a uncompressed frame from editor and ask
+//		GUI to decompress it .
+//
+
+uint8_t AVDMVideoSwapField::getFrameNumberNoAlloc(uint32_t frame,
+				uint32_t *len,
+   				ADMImage *data,
+				uint32_t *flags)
+{
+//static Image in,out;
+			if(frame>=_info.nb_frames) return 0;
+
+
+			// read uncompressed frame
+       		if(!_in->getFrameNumberNoAlloc(frame, len,_uncompressed,flags)) return 0;
+
+		uint32_t w=_info.width;
+		uint32_t h=_info.height;
+		uint32_t page=w*h;
+		uint32_t stride;
+
+		// copy u & v
+		memcpy(UPLANE(data),UPLANE(_uncompressed),page>>2);
+		memcpy(VPLANE(data),VPLANE(_uncompressed),page>>2);
+		
+		uint8_t *odd,*even,*target,*target2;
+
+		even=YPLANE(_uncompressed);
+		odd=even+w;
+		target=YPLANE(data);
+		target2=YPLANE(data)+w;
+		stride=2*w;
+
+		h>>=1;
+		for(;h--;h>0)
+		{
+			memcpy(target,odd,w);
+			memcpy(target2,even,w);
+			target+=stride;
+			target2+=stride;
+			odd+=stride;
+			even+=stride;
+		}
+		data->copyInfo(_uncompressed);
+
+      return 1;
+}
+
+uint8_t AVDMVideoKeepOdd::getFrameNumberNoAlloc(uint32_t frame,
+				uint32_t *len,
+   				ADMImage *data,
+				uint32_t *flags)
+{
+//static Image in,out;
+			if(!_in->getFrameNumberNoAlloc(frame, len,_uncompressed,flags)) return 0;
+
+
+		uint32_t w=_info.width;
+		uint32_t h=_info.height;
+
+		vidFieldKeepOdd(  w,  h, YPLANE(_uncompressed),YPLANE(data));
+		data->copyInfo(_uncompressed);
+
+      return 1;
+}
+
+uint8_t AVDMVideoKeepEven::getFrameNumberNoAlloc(uint32_t frame,
+				uint32_t *len,
+   				ADMImage *data,
+				uint32_t *flags)
+{
+//static Image in,out;
+			if(frame>=_info.nb_frames) return 0;
+
+
+			// read uncompressed frame
+       		if(!_in->getFrameNumberNoAlloc(frame, len,_uncompressed,flags)) return 0;
+
+		uint32_t w=_info.width;
+		uint32_t h=_info.height;
+
+
+		data->copyInfo(_uncompressed);
+		vidFieldKeepEven(  w,  h, YPLANE(_uncompressed),YPLANE(data));
+      return 1;
+}
+
+#endif

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidSwapFields.h (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSwapFields.h)

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidSwapSmart.cpp (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSwapSmart.cpp)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSwapSmart.cpp	2006-10-31 15:59:58 UTC (rev 2489)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidSwapSmart.cpp	2007-01-13 12:08:21 UTC (rev 2720)
@@ -0,0 +1,143 @@
+/***************************************************************************
+                          Swap Fields.cpp  -  description
+                             -------------------
+Swap each line  (shift up for odd, down for even)
+
+
+    begin                : Thu Mar 21 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ADM_assert.h>
+
+#include "config.h"
+#include "fourcc.h"
+#include "avio.hxx"
+#include "config.h"
+#include "avi_vars.h"
+#ifdef HAVE_ENCODER
+
+
+#include "ADM_toolkit/toolkit.hxx"
+#include "ADM_editor/ADM_edit.hxx"
+#include "ADM_video/ADM_genvideo.hxx"
+#include "ADM_vidSwapSmart.h"
+#include "ADM_video/ADM_interlaced.h"
+
+#include "ADM_osSupport/ADM_debugID.h"
+#define MODULE_NAME MODULE_FILTER
+#include "ADM_osSupport/ADM_debug.h"
+#include "ADM_filter/video_filters.h"
+
+
+static FILTER_PARAM nullParam={0,{""}};
+
+
+SCRIPT_CREATE(swapsmart_script,AVDMVideoSwapSmart,nullParam);
+BUILD_CREATE(swapsmart_create,AVDMVideoSwapSmart);
+
+
+char *AVDMVideoSwapSmart::printConf( void )
+{
+ 	static char buf[50];
+
+ 	sprintf((char *)buf," Smart Swap fields");
+        return buf;
+}
+
+//_______________________________________________________________
+AVDMVideoSwapSmart::AVDMVideoSwapSmart(
+									AVDMGenericVideoStream *in,CONFcouple *setup)
+{
+UNUSED_ARG(setup);
+  	_in=in;
+   	memcpy(&_info,_in->getInfo(),sizeof(_info));	
+	_uncompressed=new ADMImage(_info.width,_info.height);
+
+
+
+}
+// ___ destructor_____________
+AVDMVideoSwapSmart::~AVDMVideoSwapSmart()
+{
+ 	delete  _uncompressed;
+	_uncompressed=NULL;
+
+}
+
+//
+//	Basically ask a uncompressed frame from editor and ask
+//		GUI to decompress it .
+//
+
+uint8_t AVDMVideoSwapSmart::getFrameNumberNoAlloc(uint32_t frame,
+				uint32_t *len,
+   				ADMImage *data,
+				uint32_t *flags)
+{
+//static Image in,out;
+			if(frame>=_info.nb_frames) return 0;
+
+
+			// read uncompressed frame
+       		if(!_in->getFrameNumberNoAlloc(frame, len,data,flags)) return 0;
+
+		uint32_t w=_info.width;
+		uint32_t h=_info.height;
+		uint32_t page=w*h;
+		uint32_t stride;
+
+
+
+		uint8_t *odd,*even,*target,*target2;
+
+		even=YPLANE(data);
+		odd=even+w;
+		target=YPLANE(_uncompressed);
+		target2=_uncompressed->data+w;
+		stride=2*w;
+
+		h>>=1;
+		for(;h--;h>0)
+		{
+			memcpy(target,odd,w);
+			memcpy(target2,even,w);
+			target+=stride;
+			target2+=stride;
+			odd+=stride;
+			even+=stride;
+		}
+		// now we have straight and swapped
+		// which one is better ?
+		uint32_t s,m;
+		s=      ADMVideo_interlaceCount( YPLANE(data),_info.width, _info.height);
+		m=      ADMVideo_interlaceCount( YPLANE(_uncompressed),_info.width, _info.height);
+
+		aprintf(" %lu straight vs %lu swapped => %s\n",s,m,(s*2>m*3?"swapped":"straight"));
+
+		// if swapped <= 66 % straight
+
+		if(s*2>m*3)  // swapped is better
+		{
+			memcpy(YPLANE(data),YPLANE(_uncompressed),page);
+
+		}
+
+      return 1;
+}
+
+
+#endif

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidSwapSmart.h (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSwapSmart.h)

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am	2007-01-13 11:40:52 UTC (rev 2719)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am	2007-01-13 12:08:21 UTC (rev 2720)
@@ -7,10 +7,16 @@
 #INCLUDES = $(all_includes) 
 
 libADM_videoFilter_a_SOURCES =  \
+ ADM_vidPalShift.cpp \
+ ADM_vidReverse.cpp \
+ ADM_vidSeparateField.cpp \
+ ADM_vidSwapSmart.cpp \
+ ADM_vidSwapFields.cpp \
+ ADM_vidPalSmart.cpp \
  ADM_vidUVSwap.cpp \
  ADM_vidStabilize.cpp \
  ADM_vidDropOut.cpp \
- ADM_vidVlad.cpp \ 
+ ADM_vidVlad.cpp \
  ADM_vidWhirl.cpp \
  ADM_vidPulldown.cpp \
  ADM_vidFlipV.cpp \

Modified: branches/avidemux_2.4_branch/avidemux/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/Makefile.am	2007-01-13 11:40:52 UTC (rev 2719)
+++ branches/avidemux_2.4_branch/avidemux/Makefile.am	2007-01-13 12:08:21 UTC (rev 2720)
@@ -80,8 +80,8 @@
 ./ADM_audiocodec/libADM_audiocodec.a			\
 ./ADM_audio/libADM_audio.a				\
 ./ADM_script/libADM_script.a				\
+./ADM_videoFilter/libADM_videoFilter.a			\
 ./ADM_video/libADM_video.a				\
-./ADM_videoFilter/libADM_videoFilter.a			\
 ./ADM_colorspace/libADM_colorspace.a			\
 ./ADM_audiodevice/libADM_audiodevice.a			\
 ./ADM_ocr/libADM_ocr.a					\



From mean at mail.berlios.de  Sat Jan 13 17:37:35 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 13 Jan 2007 17:37:35 +0100
Subject: [Avidemux-svn-commit] r2721 - in
	branches/avidemux_2.4_branch/avidemux: .
	ADM_userInterfaces/ADM_GTK/ADM_dialog
	ADM_userInterfaces/ADM_NONE/ADM_dialog
	ADM_userInterfaces/ADM_QT4/ADM_dialog ADM_video ADM_videoFilter
Message-ID: <200701131637.l0DGbZDr027292@sheep.berlios.de>

Author: mean
Date: 2007-01-13 17:37:32 +0100 (Sat, 13 Jan 2007)
New Revision: 2721

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidBlend.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDecDec.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDecDec_param.h
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDecTel_param.h
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDecTelecide.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDecTelecide.h
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDeintASM.cpp
Removed:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_decimate.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidBlend.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDecDec.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDecDec_param.h
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDecTel_param.h
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDecTelecide.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDecTelecide.h
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDeintASM.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDeinterlace.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDeinterlace.h
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidField.h
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFields.cpp
Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_dectel.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidAsharp.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidColorYuv.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidEqualizer.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDGbob.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidFade.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidFastConvolution.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidForcedPP.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMPLD3D.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMSharpen.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMcDeint.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMosaic.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMsmooth.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidPalSmart.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidPalSmart.h
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidReverse.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am
   branches/avidemux_2.4_branch/avidemux/libcheck.sh
Log:
more cleanup

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_decimate.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_decimate.cpp	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_decimate.cpp	2007-01-13 16:37:32 UTC (rev 2721)
@@ -1,306 +0,0 @@
-//
-// C++ Implementation: DIA_decimate
-//
-// Description: 
-//
-//
-// Author: mean <fixounet at free.fr>, (C) 2004
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-//
-// C++ Implementation: DIA_dectel
-//
-// Description: 
-//
-//
-// Author: mean <fixounet at free.fr>, (C) 2004
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-
-
-#include <config.h>
-
-#include <sys/types.h>
-#include <sys/stat.h>
-
-
-#include <gdk/gdkkeysyms.h>
-#include <gtk/gtk.h>
-
-
-#include <gdk/gdkkeysyms.h>
-#include <gtk/gtk.h>
-# include <math.h>
-
-#include "default.h"
-#include "ADM_toolkit_gtk/toolkit_gtk.h"
-#include "ADM_toolkit_gtk/toolkit_gtk_include.h"
-#include "ADM_toolkit/toolkit.hxx"
-
-#include "ADM_video/ADM_vidDecDec_param.h"
-#define MENU_SET(x,y) { gtk_option_menu_set_history (GTK_OPTION_MENU(WID(x)),param->y);}
-#define MENU_GET(x,y) { param->y	= getRangeInMenu(WID(x));}
-static GtkWidget	*create_dialog1 (void);
-#define SPIN_GET(x,y) {param->y= gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(WID(x))) ;}
-
-#define SPIN_SET(x,y)  {gtk_spin_button_set_value(GTK_SPIN_BUTTON(WID(x)),(gfloat)param->y) ;}
-
-uint8_t DIA_getDecombDecimate(DECIMATE_PARAM *param)
-{
-GtkWidget *dialog;
-int ret=0;
-	dialog=create_dialog1();
-	
-	// Update
-	
-	gtk_write_entry_float(WID(entryThresh),param->threshold);
-	gtk_write_entry_float(WID(entry2),param->threshold2);
-	
-	MENU_SET(optionmenu1,mode);
-	MENU_SET(optionmenu2,quality);
-	SPIN_SET(spinbuttonCycle,cycle);
-	
-	gtk_register_dialog(dialog);
-	if(gtk_dialog_run(GTK_DIALOG(dialog))==GTK_RESPONSE_OK)
-	{
-		MENU_GET(optionmenu1,mode);
-		MENU_GET(optionmenu2,quality);
-		SPIN_GET(spinbuttonCycle,cycle);
-		#define RD_ENTRY(x,y) {param->y=gtk_read_entry_float(WID(x));}
-		RD_ENTRY(entryThresh,threshold);
-		RD_ENTRY(entry2,threshold2);
-		ret=1;
-	
-	}
-        gtk_unregister_dialog(dialog);
-	gtk_widget_destroy(dialog);
-	return ret;
-}
-//________________________________________________
-GtkWidget*
-create_dialog1 (void)
-{
-  GtkWidget *dialog1;
-  GtkWidget *dialog_vbox1;
-  GtkWidget *table1;
-  GtkWidget *label1;
-  GtkObject *spinbuttonCycle_adj;
-  GtkWidget *spinbuttonCycle;
-  GtkWidget *label2;
-  GtkWidget *optionmenu1;
-  GtkWidget *menu1;
-  GtkWidget *discard_closer1;
-  GtkWidget *replace_by_interpolate1;
-  GtkWidget *discard_from_longest_dups__anim__s_1;
-  GtkWidget *pulldown_dups_removal1;
-  GtkWidget *label3;
-  GtkWidget *entryThresh;
-  GtkWidget *label4;
-  GtkWidget *entry2;
-  GtkWidget *label5;
-  GtkWidget *optionmenu2;
-  GtkWidget *menu2;
-  GtkWidget *fastest__no_chroma_partial_luma_1;
-  GtkWidget *fast__partial_luma_and_chroma_1;
-  GtkWidget *medium__full_luma_not_chroma_1;
-  GtkWidget *slow__full_luma_and_chroma_1;
-  GtkWidget *dialog_action_area1;
-  GtkWidget *cancelbutton1;
-  GtkWidget *okbutton1;
-
-  dialog1 = gtk_dialog_new ();
-  gtk_window_set_title (GTK_WINDOW (dialog1), _("Decomb Decimate"));
-
-  dialog_vbox1 = GTK_DIALOG (dialog1)->vbox;
-  gtk_widget_show (dialog_vbox1);
-
-  table1 = gtk_table_new (5, 2, FALSE);
-  gtk_widget_show (table1);
-  gtk_box_pack_start (GTK_BOX (dialog_vbox1), table1, TRUE, TRUE, 0);
-
-  label1 = gtk_label_new (_("Cycle"));
-  gtk_widget_show (label1);
-  gtk_table_attach (GTK_TABLE (table1), label1, 0, 1, 0, 1,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_label_set_justify (GTK_LABEL (label1), GTK_JUSTIFY_LEFT);
-  gtk_misc_set_alignment (GTK_MISC (label1), 0, 0.5);
-
-  spinbuttonCycle_adj = gtk_adjustment_new (1, 2, 40, 1, 10, 10);
-  spinbuttonCycle = gtk_spin_button_new (GTK_ADJUSTMENT (spinbuttonCycle_adj), 1, 0);
-  gtk_widget_show (spinbuttonCycle);
-  gtk_table_attach (GTK_TABLE (table1), spinbuttonCycle, 1, 2, 0, 1,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (spinbuttonCycle), TRUE);
-
-  label2 = gtk_label_new (_("Mode"));
-  gtk_widget_show (label2);
-  gtk_table_attach (GTK_TABLE (table1), label2, 0, 1, 1, 2,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_label_set_justify (GTK_LABEL (label2), GTK_JUSTIFY_LEFT);
-  gtk_misc_set_alignment (GTK_MISC (label2), 0, 0.5);
-
-  optionmenu1 = gtk_option_menu_new ();
-  gtk_widget_show (optionmenu1);
-  gtk_table_attach (GTK_TABLE (table1), optionmenu1, 1, 2, 1, 2,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-
-  menu1 = gtk_menu_new ();
-
-  discard_closer1 = gtk_menu_item_new_with_mnemonic (_("Discard Closer"));
-  gtk_widget_show (discard_closer1);
-  gtk_container_add (GTK_CONTAINER (menu1), discard_closer1);
-
-  replace_by_interpolate1 = gtk_menu_item_new_with_mnemonic (_("Replace by interpolate"));
-  gtk_widget_show (replace_by_interpolate1);
-  gtk_container_add (GTK_CONTAINER (menu1), replace_by_interpolate1);
-
-  discard_from_longest_dups__anim__s_1 = gtk_menu_item_new_with_mnemonic (_("Discard from longest dups (anim\303\251s)"));
-  gtk_widget_show (discard_from_longest_dups__anim__s_1);
-  gtk_container_add (GTK_CONTAINER (menu1), discard_from_longest_dups__anim__s_1);
-
-  pulldown_dups_removal1 = gtk_menu_item_new_with_mnemonic (_("Pulldown dups removal"));
-  gtk_widget_show (pulldown_dups_removal1);
-  gtk_container_add (GTK_CONTAINER (menu1), pulldown_dups_removal1);
-
-  gtk_option_menu_set_menu (GTK_OPTION_MENU (optionmenu1), menu1);
-
-  label3 = gtk_label_new (_("Threshold "));
-  gtk_widget_show (label3);
-  gtk_table_attach (GTK_TABLE (table1), label3, 0, 1, 2, 3,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_label_set_justify (GTK_LABEL (label3), GTK_JUSTIFY_LEFT);
-  gtk_misc_set_alignment (GTK_MISC (label3), 0, 0.5);
-
-  entryThresh = gtk_entry_new ();
-  gtk_widget_show (entryThresh);
-  gtk_table_attach (GTK_TABLE (table1), entryThresh, 1, 2, 2, 3,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-
-  label4 = gtk_label_new (_("Threshold2 "));
-  gtk_widget_show (label4);
-  gtk_table_attach (GTK_TABLE (table1), label4, 0, 1, 3, 4,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_label_set_justify (GTK_LABEL (label4), GTK_JUSTIFY_LEFT);
-  gtk_misc_set_alignment (GTK_MISC (label4), 0, 0.5);
-
-  entry2 = gtk_entry_new ();
-  gtk_widget_show (entry2);
-  gtk_table_attach (GTK_TABLE (table1), entry2, 1, 2, 3, 4,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-
-  label5 = gtk_label_new (_("Quality "));
-  gtk_widget_show (label5);
-  gtk_table_attach (GTK_TABLE (table1), label5, 0, 1, 4, 5,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_label_set_justify (GTK_LABEL (label5), GTK_JUSTIFY_LEFT);
-  gtk_misc_set_alignment (GTK_MISC (label5), 0, 0.5);
-
-  optionmenu2 = gtk_option_menu_new ();
-  gtk_widget_show (optionmenu2);
-  gtk_table_attach (GTK_TABLE (table1), optionmenu2, 1, 2, 4, 5,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-
-  menu2 = gtk_menu_new ();
-
-  fastest__no_chroma_partial_luma_1 = gtk_menu_item_new_with_mnemonic (_("Fastest (no chroma,partial luma)"));
-  gtk_widget_show (fastest__no_chroma_partial_luma_1);
-  gtk_container_add (GTK_CONTAINER (menu2), fastest__no_chroma_partial_luma_1);
-
-  fast__partial_luma_and_chroma_1 = gtk_menu_item_new_with_mnemonic (_("Fast (partial luma and chroma)"));
-  gtk_widget_show (fast__partial_luma_and_chroma_1);
-  gtk_container_add (GTK_CONTAINER (menu2), fast__partial_luma_and_chroma_1);
-
-  medium__full_luma_not_chroma_1 = gtk_menu_item_new_with_mnemonic (_("Medium (full luma not chroma)"));
-  gtk_widget_show (medium__full_luma_not_chroma_1);
-  gtk_container_add (GTK_CONTAINER (menu2), medium__full_luma_not_chroma_1);
-
-  slow__full_luma_and_chroma_1 = gtk_menu_item_new_with_mnemonic (_("Slow (full luma and chroma)"));
-  gtk_widget_show (slow__full_luma_and_chroma_1);
-  gtk_container_add (GTK_CONTAINER (menu2), slow__full_luma_and_chroma_1);
-
-  gtk_option_menu_set_menu (GTK_OPTION_MENU (optionmenu2), menu2);
-
-  dialog_action_area1 = GTK_DIALOG (dialog1)->action_area;
-  gtk_widget_show (dialog_action_area1);
-  gtk_button_box_set_layout (GTK_BUTTON_BOX (dialog_action_area1), GTK_BUTTONBOX_END);
-
-  cancelbutton1 = gtk_button_new_from_stock ("gtk-cancel");
-  gtk_widget_show (cancelbutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), cancelbutton1, GTK_RESPONSE_CANCEL);
-  GTK_WIDGET_SET_FLAGS (cancelbutton1, GTK_CAN_DEFAULT);
-
-  okbutton1 = gtk_button_new_from_stock ("gtk-ok");
-  gtk_widget_show (okbutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), okbutton1, GTK_RESPONSE_OK);
-  GTK_WIDGET_SET_FLAGS (okbutton1, GTK_CAN_DEFAULT);
-/*
-  g_signal_connect ((gpointer) discard_closer1, "activate",
-                    G_CALLBACK (on_discard_closer1_activate),
-                    NULL);
-  g_signal_connect ((gpointer) replace_by_interpolate1, "activate",
-                    G_CALLBACK (on_replace_by_interpolate1_activate),
-                    NULL);
-  g_signal_connect ((gpointer) discard_from_longest_dups__anim__s_1, "activate",
-                    G_CALLBACK (on_discard_from_longest_dups__anim__s_1_activate),
-                    NULL);
-  g_signal_connect ((gpointer) pulldown_dups_removal1, "activate",
-                    G_CALLBACK (on_pulldown_dups_removal1_activate),
-                    NULL);
-  g_signal_connect ((gpointer) fastest__no_chroma_partial_luma_1, "activate",
-                    G_CALLBACK (on_fastest__no_chroma_partial_luma_1_activate),
-                    NULL);
-  g_signal_connect ((gpointer) fast__partial_luma_and_chroma_1, "activate",
-                    G_CALLBACK (on_fast__partial_luma_and_chroma_1_activate),
-                    NULL);
-  g_signal_connect ((gpointer) medium__full_luma_not_chroma_1, "activate",
-                    G_CALLBACK (on_medium__full_luma_not_chroma_1_activate),
-                    NULL);
-  g_signal_connect ((gpointer) slow__full_luma_and_chroma_1, "activate",
-                    G_CALLBACK (on_slow__full_luma_and_chroma_1_activate),
-                    NULL);
-*/
-  /* Store pointers to all widgets, for use by lookup_widget(). */
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog1, "dialog1");
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_vbox1, "dialog_vbox1");
-  GLADE_HOOKUP_OBJECT (dialog1, table1, "table1");
-  GLADE_HOOKUP_OBJECT (dialog1, label1, "label1");
-  GLADE_HOOKUP_OBJECT (dialog1, spinbuttonCycle, "spinbuttonCycle");
-  GLADE_HOOKUP_OBJECT (dialog1, label2, "label2");
-  GLADE_HOOKUP_OBJECT (dialog1, optionmenu1, "optionmenu1");
-  GLADE_HOOKUP_OBJECT (dialog1, menu1, "menu1");
-  GLADE_HOOKUP_OBJECT (dialog1, discard_closer1, "discard_closer1");
-  GLADE_HOOKUP_OBJECT (dialog1, replace_by_interpolate1, "replace_by_interpolate1");
-  GLADE_HOOKUP_OBJECT (dialog1, discard_from_longest_dups__anim__s_1, "discard_from_longest_dups__anim__s_1");
-  GLADE_HOOKUP_OBJECT (dialog1, pulldown_dups_removal1, "pulldown_dups_removal1");
-  GLADE_HOOKUP_OBJECT (dialog1, label3, "label3");
-  GLADE_HOOKUP_OBJECT (dialog1, entryThresh, "entryThresh");
-  GLADE_HOOKUP_OBJECT (dialog1, label4, "label4");
-  GLADE_HOOKUP_OBJECT (dialog1, entry2, "entry2");
-  GLADE_HOOKUP_OBJECT (dialog1, label5, "label5");
-  GLADE_HOOKUP_OBJECT (dialog1, optionmenu2, "optionmenu2");
-  GLADE_HOOKUP_OBJECT (dialog1, menu2, "menu2");
-  GLADE_HOOKUP_OBJECT (dialog1, fastest__no_chroma_partial_luma_1, "fastest__no_chroma_partial_luma_1");
-  GLADE_HOOKUP_OBJECT (dialog1, fast__partial_luma_and_chroma_1, "fast__partial_luma_and_chroma_1");
-  GLADE_HOOKUP_OBJECT (dialog1, medium__full_luma_not_chroma_1, "medium__full_luma_not_chroma_1");
-  GLADE_HOOKUP_OBJECT (dialog1, slow__full_luma_and_chroma_1, "slow__full_luma_and_chroma_1");
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_action_area1, "dialog_action_area1");
-  GLADE_HOOKUP_OBJECT (dialog1, cancelbutton1, "cancelbutton1");
-  GLADE_HOOKUP_OBJECT (dialog1, okbutton1, "okbutton1");
-
-  return dialog1;
-}
-

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_dectel.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_dectel.cpp	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_dectel.cpp	2007-01-13 16:37:32 UTC (rev 2721)
@@ -30,7 +30,7 @@
 #include "ADM_toolkit/toolkit.hxx"
 
 
-#include "ADM_video/ADM_vidDecTel_param.h"
+#include "ADM_videoFilter/ADM_vidDecTel_param.h"
 #define MENU_SET(x,y) { gtk_option_menu_set_history (GTK_OPTION_MENU(WID(x)),param->y);}
 #define MENU_GET(x,y) { param->y	= getRangeInMenu(WID(x));}
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am	2007-01-13 16:37:32 UTC (rev 2721)
@@ -15,7 +15,7 @@
 	DIA_postproc.cpp DIA_enter.cpp DIA_enter.h DIA_xvcd.cpp DIA_muxer.cpp \
 	DIA_xvid.cpp DIA_crop.cpp DIA_color.cpp DIA_encoding.cpp DIA_SVCD.cpp DIA_prefs.cpp \
 	DIA_requant.cpp DIA_xvid4.cpp DIA_lavcodec.cpp \
-	DIA_dectel.cpp DIA_decimate.cpp DIA_pause.cpp \
+	DIA_dectel.cpp DIA_pause.cpp \
 	DIA_DVDff.cpp DIA_lavdecoder.cpp DIA_lame.cpp DIA_calculator.cpp DIA_equalizer.cpp \
 	DIA_vobsub.cpp DIA_x264.cpp DIA_ocr.cpp  DIA_hue.cpp DIA_eq2.cpp \
 	DIA_asharp.cpp DIA_dmx.cpp DIA_idx_pg.cpp DIA_gototime.cpp \
@@ -48,7 +48,7 @@
 DIA_acodec.cpp       DIA_crop.cpp          DIA_gototime.cpp     DIA_muxer.cpp       DIA_v2v.cpp \
 DIA_animated.cpp     DIA_hue.cpp          DIA_ocr.cpp         DIA_vcodec.cpp \
 DIA_asharp.cpp       DIA_idx_pg.cpp       DIA_partial.cpp     DIA_vobsub.cpp \
-DIA_audio.cpp        DIA_decimate.cpp      DIA_idx_pg.h         DIA_pause.cpp       DIA_vorbis.cpp \
+DIA_audio.cpp        DIA_idx_pg.h         DIA_pause.cpp       DIA_vorbis.cpp \
 DIA_audioTrack.cpp   DIA_dectel.cpp        DIA_indexer.cpp      DIA_pipe.cpp        DIA_working.cpp \
 DIA_defaultAudio.cpp  DIA_jobs.cpp         DIA_postproc.cpp    DIA_working.h \
 DIA_jobs_save.cpp    DIA_prefs.cpp       DIA_x264.cpp \

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp	2007-01-13 16:37:32 UTC (rev 2721)
@@ -38,8 +38,6 @@
 #include "ADM_audiofilter/audiofilter_normalize_param.h"
 #include "ADM_video/ADM_vidCNR2_param.h"
 #include "ADM_video/ADM_vidColorYuv_param.h"
-#include "ADM_video/ADM_vidDecDec_param.h"
-#include "ADM_video/ADM_vidDecTel_param.h"
 #include "ADM_audiofilter/audioencoder_lame_param.h"
 #include "ADM_audiofilter/audioencoder_lame_param.h"
 #include "ADM_encoder/adm_encmjpeg_param.h"
@@ -92,8 +90,6 @@
 uint8_t DIA_cnr2(CNR2Param *param){return 0;}
 uint8_t DIA_DVDffParam(COMPRES_PARAMS *incoming){return 0;}
 uint8_t DIA_getASharp(ASHARP_PARAM *param, AVDMGenericVideoStream *in){return 0;}
-uint8_t DIA_getDecombDecimate(DECIMATE_PARAM *param){return 0;}
-uint8_t DIA_getDecombTelecide(TelecideParam *param){return 0;}
 uint8_t DIA_getEQ2Param(Eq2_Param *param, AVDMGenericVideoStream *in){return 0;}
 uint8_t DIA_getEqualizer(EqualizerParam *param, ADMImage *image){return 0;}
 uint8_t DIA_getEqualizer(EqualizerParam *param, AVDMGenericVideoStream *in){return 0;}

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp	2007-01-13 16:37:32 UTC (rev 2721)
@@ -38,8 +38,6 @@
 #include "ADM_audiofilter/audiofilter_normalize_param.h"
 #include "ADM_video/ADM_vidCNR2_param.h"
 #include "ADM_video/ADM_vidColorYuv_param.h"
-#include "ADM_video/ADM_vidDecDec_param.h"
-#include "ADM_video/ADM_vidDecTel_param.h"
 #include "ADM_audiofilter/audioencoder_lame_param.h"
 #include "ADM_audiofilter/audioencoder_lame_param.h"
 #include "ADM_encoder/adm_encmjpeg_param.h"
@@ -92,8 +90,6 @@
 uint8_t DIA_cnr2(CNR2Param *param){return 0;}
 uint8_t DIA_DVDffParam(COMPRES_PARAMS *incoming){return 0;}
 uint8_t DIA_getASharp(ASHARP_PARAM *param, AVDMGenericVideoStream *in){return 0;}
-uint8_t DIA_getDecombDecimate(DECIMATE_PARAM *param){return 0;}
-uint8_t DIA_getDecombTelecide(TelecideParam *param){return 0;}
 uint8_t DIA_getEQ2Param(Eq2_Param *param, AVDMGenericVideoStream *in){return 0;}
 uint8_t DIA_getEqualizer(EqualizerParam *param, ADMImage *image){return 0;}
 uint8_t DIA_getEqualizer(EqualizerParam *param, AVDMGenericVideoStream *in){return 0;}

Modified: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidAsharp.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidAsharp.cpp	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidAsharp.cpp	2007-01-13 16:37:32 UTC (rev 2721)
@@ -37,7 +37,6 @@
 #include "ADM_toolkit/toolkit.hxx"
 #include "ADM_editor/ADM_edit.hxx"
 #include "ADM_video/ADM_genvideo.hxx"
-#include"ADM_video/ADM_vidField.h"
 #include"ADM_video/ADM_cache.h"
 
 #include "ADM_osSupport/ADM_debugID.h"

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidBlend.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidBlend.cpp	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidBlend.cpp	2007-01-13 16:37:32 UTC (rev 2721)
@@ -1,187 +0,0 @@
-/***************************************************************************
-                          ADM_vidBlend.cpp  -  description
-                             -------------------
-    begin                : Tue Jan 7 2003
-    copyright            : (C) 2003 by mean
-    email                : fixounet at free.fr
-
-    Slighlty faster ASM deinterlace
-    Blend later
-
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <ADM_assert.h>
-
-#include "config.h"
-#include "fourcc.h"
-#include "avio.hxx"
-#include "config.h"
-#include "avi_vars.h"
-
-
-
-#include "ADM_toolkit/toolkit.hxx"
-#include "ADM_editor/ADM_edit.hxx"
-#include "ADM_video/ADM_genvideo.hxx"
-
-#include"ADM_video/ADM_vidField.h"
-
-#include "admmangle.h"
-
-
- static int32_t _l_w,_l_h;
- static uint8_t *_l_p,*_l_c,*_l_n;
- static uint8_t *_l_e,*_l_e2;
-#define EXPAND(x) (x)+((x)<<16)+((x)<<32) +((x)<<48)
-static uint64_t  __attribute__((used)) _mmTHRESH1=EXPAND((uint64_t )THRES1);
-static uint64_t  __attribute__((used)) full_ones=0xFFFFFFFFFFFFFFFFLL;
-
-
-static void myBlendASM(void);
-
-void ADMVideoFields::blend_C(uint8_t *p,uint8_t *c,
-							uint8_t *n,
-							uint8_t *e,
-							uint8_t *f
-							)
-{
-uint32_t x,y;
- for(y=_info.height-2;y>0;y--)
-           	{
-              for(x=_info.width;x>0;x--)
-              {
-
-                    if(*e)
-                    	{
-                       	*f=(*c>>1) + ((*n+*p)>>2);
-                       //	*f=255;
-
-                       }
-                       else
-                       		*f=*c;
-						//			*f=0;
-
-                       c++;n++;p++;e++;f++;
-                 }
-              }
-}
-#if defined( ARCH_X86)  || defined(ARCH_X86_64)
-void ADMVideoFields::blend_MMX(uint8_t *p,uint8_t *c,
-																							uint8_t *n,
-																							uint8_t *e,
-																							uint8_t *f
-																							)
-{
-      _l_h=_info.height-2;
-			_l_w=_info.width>>2;
-			_l_p=p;
-			_l_c=c;
-			_l_n=n;
-			_l_e=e;
-			_l_e2=f;
-			myBlendASM();
-}
-
-void myBlendASM(void)
-{
-	__asm__ (
-//"StartASM4: \n\t"
-"push 				"REG_di"\n\t"
-"push 				"REG_si"\n\t"
-"push 				"REG_ax"\n\t"
-
-"mov (%0), "REG_ax" \n\t"
-"mov "Mangle(_l_p)", "REG_ax" \n\t"
-"mov "Mangle(_l_c)", "REG_bx" \n\t"
-"mov "Mangle(_l_n)", "REG_cx" \n\t"
-"mov "Mangle(_l_e)", "REG_si" \n\t"
-"mov "Mangle(_l_e2)", "REG_di" \n\t"
-"movq "Mangle(full_ones)",%%mm7 \n\t"
-"pxor	   %%mm6,%%mm6 \n\t"
-
-"DHCOLB%=: \n\t" // loop
-"mov "Mangle(_l_w)", "REG_dx" \n\t"                // loop one line
-
-"DHLineB%=:  \n\t"
-
-"movd ("REG_bx"),%%mm0 \n\t"     // mm0 <- c
-"movd ("REG_ax"),%%mm1 \n\t"     // mm1 <- p
-"movd ("REG_cx"),%%mm2 \n\t"     // mm2 <- n
-"movd ("REG_si"),%%mm3 \n\t"     // mm2 <- e
-
-
-"punpcklbw %%mm6, %%mm0 \n\t"
-"punpcklbw %%mm6, %%mm1 \n\t"
-"punpcklbw %%mm6, %%mm2 \n\t"
-"punpcklbw %%mm6, %%mm3 \n\t"
-"movq      %%mm6, %%mm4 \n\t"
-
-//"movq %%mm3,S0 \n\t"
-
-// make 16 bits mask
-"psllw     $8, %%mm4 \n\t"
-"por	   %%mm4,%%mm3 \n\t"  // mask in m3
-//"movq %%mm3,S1 \n\t"
-//"movq %%mm2,S2 \n\t"
-//"movq %%mm1,S3 \n\t"
-
-
-// compute average of p & n in mm4
-"paddw     %%mm1,%%mm2 \n\t"
-"paddw     %%mm0,%%mm2 \n\t"
-"paddw     %%mm0,%%mm2 \n\t"
-//"movq 	   %%mm2,S4 \n\t"
-
-"psrlw     $2,%%mm2 \n\t"     //mm2 is averafe of p & n & c -> replacement value
-//"movq      %%mm2,S5 \n\t"
-
-"pand     %%mm3,%%mm2 \n\t"
-//"movq     %%mm2,S6 \n\t"
-
-// compute inverse value
-"pxor     %%mm7,%%mm3 \n\t" // inverse mask in m3
-//"movq     %%mm3,S7 \n\t"
-
-"pand     %%mm3,%%mm0 \n\t" // right value in m0
-//"movq     %%mm0,S8 \n\t"
-
-"por     %%mm2,%%mm0 \n\t" // ok, now right
-//"movq     %%mm0,S9 \n\t"
-
-"packuswb  %%mm6, %%mm0 \n\t"          // pack
-//"movq %%mm0,S10 \n\t"
-
-"movd	   %%mm0, ("REG_di") \n\t" // store
-
-//
-//
-// next
-"add       $4,"REG_ax" \n\t"
-"add       $4,"REG_bx" \n\t"
-"add       $4,"REG_cx" \n\t"
-"add       $4,"REG_si" \n\t"
-"add       $4,"REG_di" \n\t"
-"sub       $1,"REG_dx"	\n\t"
-"jne        DHLineB%= \n\t"   // next
-"sub       $1,"Mangle(_l_h)"  \n\t" // next line
-"jne        DHCOLB%= \n\t"
-"pop 				"REG_ax"\n\t"
-"pop 				"REG_si"\n\t"
-"pop 				"REG_di"\n\t"
-" emms       \n\t"
- : /* no output */
- :  "r"(&_mmTHRESH1)
- :   "ebx", "ecx", "edx");
-}
-#endif

Modified: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidColorYuv.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidColorYuv.cpp	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidColorYuv.cpp	2007-01-13 16:37:32 UTC (rev 2721)
@@ -59,7 +59,6 @@
 #include "ADM_toolkit/toolkit.hxx"
 #include "ADM_editor/ADM_edit.hxx"
 #include "ADM_video/ADM_genvideo.hxx"
-#include"ADM_video/ADM_vidField.h"
 
 #include "ADM_osSupport/ADM_debugID.h"
 #define MODULE_NAME MODULE_FILTER

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDecDec.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDecDec.cpp	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDecDec.cpp	2007-01-13 16:37:32 UTC (rev 2721)
@@ -1,1626 +0,0 @@
-/***************************************************************************
-                          ADM_vidDecTelecide  -  description
-                             -------------------
-    
-    email                : fixounet at free.fr
-
-    Port of Donal Graft Decimate which is (c) Donald Graft
-    http://www.neuron2.net
-    http://puschpull.org/avisynth/decomb_reference_manual.html
-
- ***************************************************************************/
-
-/*
-	Decimate plugin for Avisynth -- performs 1-in-N
-	decimation on a stream of progressive frames, which are usually
-	obtained from the output of my Telecide plugin for Avisynth.
-	For each group of N successive frames, this filter deletes the
-	frame that is most similar to its predecessor. Thus, duplicate
-	frames coming out of Telecide can be removed using Decimate. This
-	filter adjusts the frame rate of the clip as
-	appropriate. Selection of the cycle size is selected by specifying
-	a parameter to Decimate() in the Avisynth scipt.
-
-	Copyright (C) 2003 Donald A. Graft
-
-	This program is free software; you can redistribute it and/or modify
-	it under the terms of the GNU General Public License as published by
-	the Free Software Foundation.
-
-	This program is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-	GNU General Public License for more details.
-
-	You should have received a copy of the GNU General Public License
-	along with this program; if not, write to the Free Software
-	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-
-	The author can be contacted at:
-	Donald Graft
-	neuron2 at attbi.com.
-*/
-#include "config.h"
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <ADM_assert.h>
-
-#include "config.h"
-#include "fourcc.h"
-#include "avio.hxx"
-#include "avi_vars.h"
-
-#include "ADM_toolkit/toolkit.hxx"
-#include "ADM_editor/ADM_edit.hxx"
-#include "ADM_video/ADM_genvideo.hxx"
-#include"ADM_video/ADM_vidField.h"
-#include"ADM_video/ADM_cache.h"
-
-#include "ADM_osSupport/ADM_debugID.h"
-#define MODULE_NAME MODULE_FILTER
-#include "ADM_osSupport/ADM_debug.h"
-
-#include "ADM_osSupport/ADM_cpuCap.h"
-#define PROGRESSIVE  0x00000001
-#define MAGIC_NUMBER (0xdeadbeef)
-#define IN_PATTERN   0x00000002
-
-extern uint8_t 	PutHintingData(unsigned char *video, unsigned int hint);
-extern uint8_t 	GetHintingData(unsigned char *video, unsigned int *hint);
-extern void 	BitBlt(uint8_t * dstp, int dst_pitch, const uint8_t* srcp,
-            		int src_pitch, int row_size, int height);
-
-#define DrawString drawString
-
-#ifdef USE_SSE
-	#define DECIMATE_MMX_BUILD_PLANE 1
-	#define DECIMATE_MMX_BUILD	 1
-#endif
-
-#ifdef DECIMATE_MMX_BUILD_PLANE
-static void isse_blend_decimate_plane(uint8_t * dst, uint8_t* src,  uint8_t* src_next, 
-			int w, int h);
-int isse_scenechange_32(const uint8_t *c_plane,const  uint8_t *tplane, int height, int width) ;	
-int isse_scenechange_16(const uint8_t *c_plane,const  uint8_t *tplane, int height, int width) ;
-int isse_scenechange_8(const uint8_t *c_plane,const  uint8_t *tplane, int height, int width) ;
-#endif
-
-
-#define OutputDebugString(x) aprintf("%s\n",x)
-//________________________________
-#define MAX_CYCLE_SIZE 25
-#define MAX_BLOCKS 50
-
-#define GETFRAME(g, fp) \
-{ \
-	int GETFRAMEf; \
-	GETFRAMEf = (g); \
-	if (GETFRAMEf < 0) GETFRAMEf = 0; \
-	if (GETFRAMEf > num_frames_hi - 1) GETFRAMEf = num_frames_hi - 1; \
-	(fp) = vidCache->getImage(GETFRAMEf); \
-}
-//________________________________
-#include "ADM_vidDecDec_param.h"
-#include "ADM_filter/video_filters.h"
-
-
-static FILTER_PARAM decdecParam={5,{"cycle","mode","quality","threshold","threshold2"}};
-
-
-
-
-extern uint8_t DIA_getDecombDecimate(DECIMATE_PARAM *param);
-
-#define BLKSIZE 32
-//________________________________
-/* Decimate 1-in-N implementation. */
-class Decimate : public AVDMGenericVideoStream
-{
-	int 			num_frames_hi;
-	
-	DECIMATE_PARAM 		*_param;
-	
-	int last_request, last_result;
-	bool last_forced;
-	double last_metric;
-	double metrics[MAX_CYCLE_SIZE];
-	double showmetrics[MAX_CYCLE_SIZE];
-	int Dprev[MAX_CYCLE_SIZE];
-	int Dcurr[MAX_CYCLE_SIZE];
-	int Dnext[MAX_CYCLE_SIZE];
-	int Dshow[MAX_CYCLE_SIZE];
-	unsigned int hints[MAX_CYCLE_SIZE];
-	bool hints_invalid;
-	bool all_video_cycle;
-	bool firsttime;
-	int heightY, row_sizeY, pitchY;
-	int heightUV, row_sizeUV, pitchUV;
-	int pitch, row_size, height;
-	int xblocks, yblocks;
-	unsigned int *sum, div;
-	bool debug, show;
-	
-	VideoCache	*vidCache;
-	
-public:
-				
-			Decimate(AVDMGenericVideoStream *in,CONFcouple *couples);    
-			~Decimate(void);
-	uint8_t  	getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-				ADMImage *data,uint32_t *flags);
-
-    	uint8_t   	*GetFrame(int n);
-	void   		DrawShow(ADMImage  *src, int useframe, bool forced, int dropframe,
-		                              double metric, int inframe );
-        void   		FindDuplicate(int frame, int *chosen, double *metric, bool *forced   );
-    	void   		FindDuplicate2(int frame, int *chosen, bool *forced );
-    	void   		FindDuplicateYUY2(int frame, int *chosen, double *metric, bool *force);
-    	void   		FindDuplicate2YUY2(int frame, int *chosen, bool *forced );
-	
-	char 		*printConf( void );
-	uint8_t 	configure(AVDMGenericVideoStream *in);
-	uint8_t		getCoupledConf( CONFcouple **couples);
-};
-
-
-
-BUILD_CREATE(decimate_create,Decimate);
-
-/*
-PClip _child, int _cycle, int _mode, double _threshold, double _threshold2,
-				int _quality, const char * _ovr, bool _show, bool _debug, IScriptEnvironment* env) 
-GenericVideoFilter(_child), cycle(_cycle), mode(_mode), threshold(_threshold),
-threshold2(_threshold2), quality(_quality), ovr(_ovr), show(_show), debug(_debug)
-*/	
-SCRIPT_CREATE(decimate_script,Decimate,decdecParam);
-uint8_t Decimate::configure(AVDMGenericVideoStream *in)
-{
-	_in=in;
-	ADM_assert(_param);
-	return  DIA_getDecombDecimate(_param);
-	
-}
-
-char *Decimate::printConf( void )
-{
- 	static char buf[50];
-
-	ADM_assert(_param);
- 	sprintf((char *)buf," Decomb Decimate cycle:%d",_param->cycle);
-        return buf;
-}
-
-
-Decimate::Decimate(AVDMGenericVideoStream *in,CONFcouple *couples)		
-{
-{
-		
-		int count = 0;
-		char buf[80];
-		unsigned int *p;
-
-		_in=in;		
-   		memcpy(&_info,_in->getInfo(),sizeof(_info));    
-  		_info.encoding=1;
-		_uncompressed=NULL;		
-  		_info.encoding=1;
-		
-		//		
-		// Init here
-		debug=0;
-		show=0;		
-#ifdef USE_SSE	
-		if(CpuCaps::hasSSE())
-		{
-			printf("Decimate:SSE enabled\n");
-		}
-#endif
-		//
-		_param=new DECIMATE_PARAM;
-		if(couples)
-		{
-			GET(cycle);
-			GET(mode);
-			GET(quality);
-			GET(threshold);
-			GET(threshold2);
-			
-		}
-		else // Default
-  		{
-			_param->cycle=5;
-			_param->mode=0;
-			_param->quality=2;
-			_param->threshold=0;
-			_param->threshold2=3.0;
-		}
-		
-		ADM_assert(_param->cycle);
-		vidCache=new VideoCache(_param->cycle*2+1,in);
-		
-		if (_param->mode == 0 || _param->mode == 2 || _param->mode == 3)
-		{
-			num_frames_hi = _info.nb_frames;
-			_info.nb_frames = _info.nb_frames * (_param->cycle - 1) / _param->cycle;
-			_info.fps1000=_info.fps1000*(_param->cycle-1);
-			_info.fps1000=(uint32_t)(_info.fps1000/_param->cycle);
-			
-		}
-		last_request = -1;
-		firsttime = true;
-		sum = (unsigned int *) ADM_alloc(MAX_BLOCKS * MAX_BLOCKS * sizeof(unsigned int));
-		ADM_assert(sum);		
-		all_video_cycle = true;
-
-		if (debug)
-		{
-			char b[80];
-			sprintf(b, "Decimate %s by Donald Graft, Copyright 2003\n", VERSION);
-			OutputDebugString(b);
-		}
-	}
-}
-//________________________________________________________
-uint8_t	Decimate::getCoupledConf( CONFcouple **couples)
-{
-	*couples=NULL;
-	*couples=new CONFcouple(5);
-#define CSET(x)  (*couples)->setCouple((char *)#x,(_param->x))
-	
-	CSET(cycle);
-	CSET(mode);
-	CSET(quality);
-	CSET(threshold);
-	CSET(threshold2);
-
-	return 1;
-}
-//________________________________________________________
-Decimate::~Decimate(void)
-{
-		if (sum != NULL) ADM_dealloc(sum);
-		if(vidCache) delete vidCache;
-		if(_param) delete _param;
-
-		vidCache=NULL;
-		_param=NULL;
-		sum=NULL;
-}
-//________________________________________________________
-void Decimate::DrawShow(ADMImage  *src, int useframe, bool forced, int dropframe,
-						double metric, int inframe)
-{
-	char buf[80];
-	int start = (useframe / _param->cycle) * _param->cycle;
-
-	if (show == true)
-	{
-		sprintf(buf, "Decimate %s", VERSION);
-		DrawString(src, 0, 0, buf);
-		sprintf(buf, "Copyright 2003 Donald Graft");
-		DrawString(src, 0, 1, buf);
-		sprintf(buf,"%d: %3.2f", start, showmetrics[0]);
-		DrawString(src, 0, 3, buf);
-		sprintf(buf,"%d: %3.2f", start + 1, showmetrics[1]);
-		DrawString(src, 0, 4, buf);
-		sprintf(buf,"%d: %3.2f", start + 2, showmetrics[2]);
-		DrawString(src, 0, 5, buf);
-		sprintf(buf,"%d: %3.2f", start + 3, showmetrics[3]);
-		DrawString(src, 0, 6, buf);
-		sprintf(buf,"%d: %3.2f", start + 4, showmetrics[4]);
-		DrawString(src, 0, 7, buf);
-		if (all_video_cycle == false)
-		{
-			sprintf(buf,"in frm %d, use frm %d", inframe, useframe);
-			DrawString(src, 0, 8, buf);
-			if (forced == false)
-				sprintf(buf,"chose %d, dropping", dropframe);
-			else
-				sprintf(buf,"chose %d, dropping, forced!", dropframe);
-			DrawString(src, 0, 9, buf);
-		}
-		else
-		{
-			sprintf(buf,"in frm %d", inframe);
-			DrawString(src, 0, 8, buf);
-			sprintf(buf,"chose %d, decimating all-video cycle", dropframe);
-			DrawString(src, 0, 9, buf);
-		}
-	}
-	if (debug)
-	{
-		if (!(inframe%_param->cycle))
-		{
-			sprintf(buf,"Decimate: %d: %3.2f\n", start, showmetrics[0]);
-			OutputDebugString(buf);
-			sprintf(buf,"Decimate: %d: %3.2f\n", start + 1, showmetrics[1]);
-			OutputDebugString(buf);
-			sprintf(buf,"Decimate: %d: %3.2f\n", start + 2, showmetrics[2]);
-			OutputDebugString(buf);
-			sprintf(buf,"Decimate: %d: %3.2f\n", start + 3, showmetrics[3]);
-			OutputDebugString(buf);
-			sprintf(buf,"Decimate: %d: %3.2f\n", start + 4, showmetrics[4]);
-			OutputDebugString(buf);
-		}
-		if (all_video_cycle == false)
-		{
-			sprintf(buf,"Decimate: in frm %d useframe %d\n", inframe, useframe);
-			OutputDebugString(buf);
-			if (forced == false)
-				sprintf(buf,"Decimate: chose %d, dropping\n", dropframe);
-			else
-				sprintf(buf,"Decimate: chose %d, dropping, forced!\n", dropframe);
-			OutputDebugString(buf);
-		}
-		else
-		{
-			sprintf(buf,"Decimate: in frm %d\n", inframe);
-			OutputDebugString(buf);
-			sprintf(buf,"Decimate: chose %d, decimating all-video cycle\n", dropframe);
-			OutputDebugString(buf);
-		}
-	}
-}
-//______________________________________________________________________
-uint8_t Decimate::getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-				ADMImage *data,uint32_t *flags)
-{
-	int dropframe, useframe, nextfrm, wY, wUV, hY, hUV, x, y, pitchY, pitchUV, dpitchY, dpitchUV;
-	ADMImage  *src, *next, *dst;
-	unsigned char *srcrpY, *nextrpY, *dstwpY;
-	unsigned char *srcrpU, *nextrpU, *dstwpU;
-	unsigned char *srcrpV, *nextrpV, *dstwpV;
-	uint32_t inframe=frame;
-	double metric;
-	char buf[255];
-
-	*len=(_info.width*_info.height*3)>>1;
-	num_frames_hi = _in->getInfo()->nb_frames; /* FIXME MEANX */
-	if (_param->mode == 0)
-	{
-		bool forced = false;
-		int start;
-
-		/* Normal decimation. Remove the frame most similar to its preceding frame. */
-		/* Determine the correct frame to use and get it. */
-		useframe = inframe + inframe / (_param->cycle - 1);
-		start = (useframe /  _param->cycle) * _param->cycle;
-		FindDuplicate((useframe / _param->cycle) * _param->cycle, &dropframe, &metric, &forced);
-		if (useframe >= dropframe) useframe++;
-		GETFRAME(useframe, src);
-		if (show == true)
-		{
-			sprintf(buf, "Decimate %s", VERSION);
-			DrawString(src, 0, 0, buf);
-			sprintf(buf, "Copyright 2003 Donald Graft");
-			DrawString(src, 0, 1, buf);
-			sprintf(buf,"%d: %3.2f", start, showmetrics[0]);
-			DrawString(src, 0, 3, buf);
-			sprintf(buf,"%d: %3.2f", start + 1, showmetrics[1]);
-			DrawString(src, 0, 4, buf);
-			sprintf(buf,"%d: %3.2f", start + 2, showmetrics[2]);
-			DrawString(src, 0, 5, buf);
-			sprintf(buf,"%d: %3.2f", start + 3, showmetrics[3]);
-			DrawString(src, 0, 6, buf);
-			sprintf(buf,"%d: %3.2f", start + 4, showmetrics[4]);
-			DrawString(src, 0, 7, buf);
-			sprintf(buf,"in frm %d, use frm %d", inframe, useframe);
-			DrawString(src, 0, 8, buf);
-			sprintf(buf,"dropping frm %d%s", dropframe, last_forced == true ? ", forced!" : "");
-			DrawString(src, 0, 9, buf);
-		}
-		if (debug)
-		{	
-			if (!(inframe % _param->cycle))
-			{
-				sprintf(buf,"Decimate: %d: %3.2f\n", start, showmetrics[0]);
-				OutputDebugString(buf);
-				sprintf(buf,"Decimate: %d: %3.2f\n", start + 1, showmetrics[1]);
-				OutputDebugString(buf);
-				sprintf(buf,"Decimate: %d: %3.2f\n", start + 2, showmetrics[2]);
-				OutputDebugString(buf);
-				sprintf(buf,"Decimate: %d: %3.2f\n", start + 3, showmetrics[3]);
-				OutputDebugString(buf);
-				sprintf(buf,"Decimate: %d: %3.2f\n", start + 4, showmetrics[4]);
-				OutputDebugString(buf);
-			}
-			sprintf(buf,"Decimate: in frm %d, use frm %d\n", inframe, useframe);
-			OutputDebugString(buf);
-			sprintf(buf,"Decimate: dropping frm %d%s\n", dropframe, last_forced == true ? ", forced!" : "");
-			OutputDebugString(buf);
-		}
-	    //return src;
-	        //memcpy(data,src,*len);
-
-		data->duplicate(src);
-		vidCache->unlockAll();
-		  
-		return 1;
-	}
-	else if (_param->mode == 1)
-	{
-		bool forced = false;
-		int start = (inframe / _param->cycle) * _param->cycle;
-		unsigned int hint, film = 1;
-
-		GETFRAME(inframe, src);
-	    	srcrpY = YPLANE(src); //(unsigned char *) src->GetReadPtr(PLANAR_Y);
-		if (GetHintingData(srcrpY, &hint) == false)
-		{
-			film = hint & PROGRESSIVE;
-//			if (film) OutputDebugString("film\n");
-//			else OutputDebugString("video\n");
-		}
-
-		/* Find the most similar frame as above but replace it with a blend of
-		   the preceding and following frames. */
-		num_frames_hi = _in->getInfo()->nb_frames; /* FIXME MEANX */
-		FindDuplicate((inframe / _param->cycle) * _param->cycle, &dropframe, &metric, &forced);
-		if (!film || inframe != dropframe || (_param->threshold && metric > _param->threshold))
-		{
-			if (show == true)
-			{
-
-				sprintf(buf, "Decimate %s", VERSION);
-				DrawString(src, 0, 0, buf);
-				sprintf(buf, "Copyright 2003 Donald Graft");
-				DrawString(src, 0, 1, buf);
-				sprintf(buf,"%d: %3.2f", start, showmetrics[0]);
-				DrawString(src, 0, 3, buf);
-				sprintf(buf,"%d: %3.2f", start + 1, showmetrics[1]);
-				DrawString(src, 0, 4, buf);
-				sprintf(buf,"%d: %3.2f", start + 2, showmetrics[2]);
-				DrawString(src, 0, 5, buf);
-				sprintf(buf,"%d: %3.2f", start + 3, showmetrics[3]);
-				DrawString(src, 0, 6, buf);
-				sprintf(buf,"%d: %3.2f", start + 4, showmetrics[4]);
-				DrawString(src, 0, 7, buf);
-				sprintf(buf,"infrm %d", inframe);
-				DrawString(src, 0, 8, buf);
-				if (last_forced == false)
-					sprintf(buf,"chose %d, passing through", dropframe);
-				else
-					sprintf(buf,"chose %d, passing through, forced!", dropframe);
-				DrawString(src, 0, 9, buf);
-			}
-			if (debug)
-			{
-				if (!(inframe % _param->cycle))
-				{
-					sprintf(buf,"Decimate: %d: %3.2f\n", start, showmetrics[0]);
-					OutputDebugString(buf);
-					sprintf(buf,"Decimate: %d: %3.2f\n", start + 1, showmetrics[1]);
-					OutputDebugString(buf);
-					sprintf(buf,"Decimate: %d: %3.2f\n", start + 2, showmetrics[2]);
-					OutputDebugString(buf);
-					sprintf(buf,"Decimate: %d: %3.2f\n", start + 3, showmetrics[3]);
-					OutputDebugString(buf);
-					sprintf(buf,"Decimate: %d: %3.2f\n", start + 4, showmetrics[4]);
-					OutputDebugString(buf);
-				}
-				sprintf(buf,"Decimate: in frm %d\n", inframe);
-				OutputDebugString(buf);
-				if (last_forced == false)
-					sprintf(buf,"Decimate: chose %d, passing through\n", dropframe);
-				else
-					sprintf(buf,"Decimate: chose %d, passing through, forced!\n", dropframe);
-				OutputDebugString(buf);
-			}
-			//return src;
-			//memcpy(data,src,*len);
-
-			data->duplicate(src);
-			vidCache->unlockAll();
-			return 1;
-		}
-		if (inframe < _in->getInfo()->nb_frames - 1) /* FIXME MEANX*/
-			nextfrm = inframe + 1;
-		else
-			nextfrm = _in->getInfo()->nb_frames - 1;
-		if (debug)
-		{
-			if (!(inframe % _param->cycle))
-			{
-				sprintf(buf,"Decimate: %d: %3.2f\n", start, showmetrics[0]);
-				OutputDebugString(buf);
-				sprintf(buf,"Decimate: %d: %3.2f\n", start + 1, showmetrics[1]);
-				OutputDebugString(buf);
-				sprintf(buf,"Decimate: %d: %3.2f\n", start + 2, showmetrics[2]);
-				OutputDebugString(buf);
-				sprintf(buf,"Decimate: %d: %3.2f\n", start + 3, showmetrics[3]);
-				OutputDebugString(buf);
-				sprintf(buf,"Decimate: %d: %3.2f\n", start + 4, showmetrics[4]);
-				OutputDebugString(buf);
-			}
-			sprintf(buf,"Decimate: in frm %d\n", inframe);
-			OutputDebugString(buf);
-			if (last_forced == false)
-				sprintf(buf,"Decimate: chose %d, blending %d and %d\n", dropframe, inframe, nextfrm);
-			else
-				sprintf(buf,"Decimate: chose %d, blending %d and %d, forced!\n", dropframe, inframe, nextfrm);
-			OutputDebugString(buf);
-		}
-		GETFRAME(nextfrm, next);
-		dst = data; //env->NewVideoFrame(vi);
-		pitchY = _info.width; //src->GetPitch(PLANAR_Y);
-		dpitchY = _info.width; //dst->GetPitch(PLANAR_Y);
-		wY = _info.width; //src->GetRowSize(PLANAR_Y);
-		hY = _info.height; //src->GetHeight(PLANAR_Y);
-		pitchUV = _info.width>>1;// src->GetPitch(PLANAR_V);
-		dpitchUV =_info.width>>1;// dst->GetPitch(PLANAR_V);
-		wUV = _info.width>>1;//src->GetRowSize(PLANAR_V);
-		hUV = _info.height>>1;//src->GetHeight(PLANAR_V);
-		
-		nextrpY = YPLANE(next); //next->GetReadPtr(PLANAR_Y);
-		dstwpY = YPLANE( dst); //dst->GetWritePtr(PLANAR_Y);
-#ifdef DECIMATE_MMX_BUILD_PLANE
-		if (CpuCaps::hasSSE()) 
-		{
-			isse_blend_decimate_plane(dstwpY, srcrpY, nextrpY, wY, hY);
-		} else {
-#endif
-			for (y = 0; y < hY; y++)
-			{
-				for (x = 0; x < wY; x++)
-				{
-					dstwpY[x] = ((int)srcrpY[x] + (int)nextrpY[x] ) >> 1;  
-				}
-				srcrpY += pitchY;
-				nextrpY += pitchY;
-				dstwpY += dpitchY;
-			}
-#ifdef DECIMATE_MMX_BUILD_PLANE
-		}
-#endif
-		srcrpU =   UPLANE(src);//->GetReadPtr(PLANAR_U);
-		nextrpU =   UPLANE(next);//->GetReadPtr(PLANAR_U);
-		dstwpU =  UPLANE(dst);//->GetWritePtr(PLANAR_U);
-#ifdef DECIMATE_MMX_BUILD_PLANE
-		if (CpuCaps::hasSSE()) 
-		{
-			isse_blend_decimate_plane(dstwpU, srcrpU, nextrpU, wUV, hUV);
-		} else {
-#endif
-			for (y = 0; y < hUV; y++)
-			{
-				for (x = 0; x < wUV; x++)
-				{
-					dstwpU[x] = ((int)srcrpU[x] + (int)nextrpU[x]) >> 1;
-				}
-				srcrpU += pitchUV;
-				nextrpU += pitchUV;
-				dstwpU += dpitchUV;
-			}
-#ifdef DECIMATE_MMX_BUILD_PLANE
-		}
-#endif
-		srcrpV =   VPLANE(src);//->GetReadPtr(PLANAR_V);
-		nextrpV =   VPLANE(next);//->GetReadPtr(PLANAR_V);
-		dstwpV =   VPLANE(dst);//->GetWritePtr(PLANAR_V);
-
-#ifdef DECIMATE_MMX_BUILD_PLANE
-		if (CpuCaps::hasSSE()) { 
-			isse_blend_decimate_plane(dstwpV, srcrpV, nextrpV, wUV, hUV );
-		} else {
-#endif
-			for (y = 0; y < hUV; y++)
-			{
-				for (x = 0; x < wUV; x++)
-				{
-					dstwpV[x] = ((int)srcrpV[x] + + (int)nextrpV[x]) >> 1;
-				}
-				srcrpV += pitchUV;
-				nextrpV += pitchUV;
-				dstwpV += dpitchUV;
-			}
-#ifdef DECIMATE_MMX_BUILD_PLANE
-		}
-#endif
-		if (show == true)
-		{
-
-			sprintf(buf, "Decimate %s", VERSION);
-			DrawString(dst, 0, 0, buf);
-			sprintf(buf, "Copyright 2003 Donald Graft");
-			DrawString(dst, 0, 1, buf);
-			sprintf(buf,"%d: %3.2f", start, showmetrics[0]);
-			DrawString(dst, 0, 3, buf);
-			sprintf(buf,"%d: %3.2f", start + 1, showmetrics[1]);
-			DrawString(dst, 0, 4, buf);
-			sprintf(buf,"%d: %3.2f", start + 2, showmetrics[2]);
-			DrawString(dst, 0, 5, buf);
-			sprintf(buf,"%d: %3.2f", start + 3, showmetrics[3]);
-			DrawString(dst, 0, 6, buf);
-			sprintf(buf,"%d: %3.2f", start + 4, showmetrics[4]);
-			DrawString(dst, 0, 7, buf);
-			sprintf(buf,"infrm %d", inframe);
-			DrawString(dst, 0, 8, buf);
-			if (last_forced == false)
-				sprintf(buf,"chose %d, blending %d and %d",dropframe, inframe, nextfrm);
-			else
-				sprintf(buf,"chose %d, blending %d and %d, forced!", dropframe, inframe, nextfrm);
-			DrawString(dst, 0, 9, buf);
-		}
-		//return dst;
-		//memcpy(data,dst,*len);
-
-		data->duplicate(dst);
-		vidCache->unlockAll();		
-		return 1;
-	}
-	else if (_param->mode == 2)
-	{
-		bool forced = false;
-
-		/* Delete the duplicate in the longest string of duplicates. */
-		useframe = inframe + inframe / (_param->cycle - 1);
-		FindDuplicate2((useframe / _param->cycle) * _param->cycle, &dropframe, &forced);
-		if (useframe >= dropframe) useframe++;
-		GETFRAME(useframe, src);
-		if (show == true)
-		{
-			int start = (useframe / _param->cycle) * _param->cycle;
-
-
-			sprintf(buf, "Decimate %s", VERSION);
-			DrawString(src, 0, 0, buf);
-			sprintf(buf, "Copyright 2003 Donald Graft");
-			DrawString(src, 0, 1, buf);
-			sprintf(buf,"in frm %d, use frm %d", inframe, useframe);
-			DrawString(src, 0, 3, buf);
-			sprintf(buf,"%d: %3.2f (%s)", start, showmetrics[0],
-					Dshow[0] ? "new" : "dup");
-			DrawString(src, 0, 4, buf);
-			sprintf(buf,"%d: %3.2f (%s)", start + 1, showmetrics[1],
-					Dshow[1] ? "new" : "dup");
-			DrawString(src, 0, 5, buf);
-			sprintf(buf,"%d: %3.2f (%s)", start + 2, showmetrics[2],
-					Dshow[2] ? "new" : "dup");
-			DrawString(src, 0, 6, buf);
-			sprintf(buf,"%d: %3.2f (%s)", start + 3, showmetrics[3],
-					Dshow[3] ? "new" : "dup");
-			DrawString(src, 0, 7, buf);
-			sprintf(buf,"%d: %3.2f (%s)", start + 4, showmetrics[4],
-					Dshow[4] ? "new" : "dup");
-			DrawString(src, 0, 8, buf);
-			sprintf(buf,"Dropping frm %d%s", dropframe, last_forced == true ? " forced!" : "");
-			DrawString(src, 0, 9, buf);
-		}
-		if (debug)
-		{	
-			sprintf(buf,"Decimate: inframe %d useframe %d\n", inframe, useframe);
-			OutputDebugString(buf);
-		}
-	    //return src;
-	    	//memcpy(data,src,*len);
-
-		data->duplicate(src);
-		vidCache->unlockAll();
-		return 1;
-	}
-	else if (_param->mode == 3)
-	{
-		bool forced = false;
-
-		/* Decimate by removing a duplicate from film cycles and doing a
-		   blend rate conversion on the video cycles. */
-		if (_param->cycle != 5)//	env->ThrowError("Decimate: mode=3 requires cycle=5");
-		{
-			printf("Decimate: mode=3 requires cycle=5\n");
-			return 0;
-		}
-		useframe = inframe + inframe / (_param->cycle - 1);
-		FindDuplicate((useframe / _param->cycle) * _param->cycle, &dropframe, &metric, &forced);
-		/* Use hints from Telecide about film versus video. Also use the difference
-		   metric of the most similar frame in the cycle; if it exceeds threshold,
-		   assume it's a video cycle. */
-		if (!(inframe % 4))
-		{
-			all_video_cycle = false;
-			if (_param->threshold && metric > _param->threshold)
-			{
-				all_video_cycle = true;
-			}
-			if ((hints_invalid == false) &&
-				(!(hints[0] & PROGRESSIVE) ||
-				 !(hints[1] & PROGRESSIVE) ||
-				 !(hints[2] & PROGRESSIVE) ||
-				 !(hints[3] & PROGRESSIVE) ||
-				 !(hints[4] & PROGRESSIVE)))
-			{
-				all_video_cycle = true;
-			}
-		}
-		if (all_video_cycle == false)
-		{
-			/* It's film, so decimate in the normal way. */
-			if (useframe >= dropframe) useframe++;
-			GETFRAME(useframe, src);
-			DrawShow(src, useframe, forced, dropframe, metric, inframe);			
-			//memcpy(data,src,*len);
-
-			data->duplicate(src);
-		
-			vidCache->unlockAll();		
-			return 1; // return src;
-		}
-		else if ((inframe % 4) == 0)
-		{
-			/* It's a video cycle. Output the first frame of the cycle. */
-			GETFRAME(useframe, src);
-			DrawShow(src, 0, forced, dropframe, metric, inframe);
-			//return src;
-			//memcpy(data,src,*len);
-
-			data->duplicate(src);
-		
-			vidCache->unlockAll();		
-			return 1; // return src;
-		}
-		else if ((inframe % 4) == 3)
-		{
-			/* It's a video cycle. Output the last frame of the cycle. */
-			GETFRAME(useframe+1, src);
-			DrawShow(src, 0, forced, dropframe, metric, inframe);
-			//return src;
-			//memcpy(data,src,*len);
-
-			data->duplicate(src);
-		
-			vidCache->unlockAll();		
-			return 1; // return src;
-		}
-		else if ((inframe % 4) == 1 || (inframe % 4) == 2)
-		{
-			/* It's a video cycle. Make blends for the remaining frames. */
-			if ((inframe % 4) == 1)
-			{
-				GETFRAME(useframe, src);
-				if (useframe < num_frames_hi - 1)
-					nextfrm = useframe + 1;
-				else
-					nextfrm = _in->getInfo()->nb_frames - 1;
-				GETFRAME(nextfrm, next);
-			}
-			else
-			{
-				GETFRAME(useframe + 1, src);
-				nextfrm = useframe;
-				GETFRAME(nextfrm, next);
-			}
-			dst = data; //env->NewVideoFrame(vi);
-			pitchY = _info.width; //src->GetPitch(PLANAR_Y);
-			dpitchY = _info.width; //dst->GetPitch(PLANAR_Y);
-			wY = _info.width; //src->GetRowSize(PLANAR_Y);
-			hY = _info.height; //src->GetHeight(PLANAR_Y);
-			pitchUV = _info.width>>1; //src->GetPitch(PLANAR_V);
-			dpitchUV =_info.width>>1; // dst->GetPitch(PLANAR_V);
-			wUV = _info.width>>1; //src->GetRowSize(PLANAR_V);
-			hUV = _info.height>>1; //src->GetHeight(PLANAR_V);
-			
-			srcrpY = YPLANE( src); //src->GetReadPtr(PLANAR_Y);
-			nextrpY = YPLANE( next); //next->GetReadPtr(PLANAR_Y);
-			dstwpY = YPLANE( dst); //dst->GetWritePtr(PLANAR_Y);
-#ifdef DECIMATE_MMX_BUILD_PLANE
-			if (CpuCaps::hasSSE()) { 
-				isse_blend_decimate_plane(dstwpY, srcrpY, nextrpY, wY, hY);
-			} else {
-#endif
-				for (y = 0; y < hY; y++)
-				{
-					for (x = 0; x < wY; x++)
-					{
-						dstwpY[x] = ((int)srcrpY[x] + (int)nextrpY[x]) >> 1;
-					}
-					srcrpY += pitchY;
-					nextrpY += pitchY;
-					dstwpY += dpitchY;
-				}
-#ifdef DECIMATE_MMX_BUILD_PLANE
-			}
-#endif
-			srcrpU =   UPLANE(src);//->GetReadPtr(PLANAR_U);
-			nextrpU =  UPLANE( next);//->GetReadPtr(PLANAR_U);
-			dstwpU =   UPLANE(dst);//->GetWritePtr(PLANAR_U);
-#ifdef DECIMATE_MMX_BUILD_PLANE
-			if (CpuCaps::hasSSE()) { 
-				isse_blend_decimate_plane(dstwpU, srcrpU, nextrpU, wUV, hUV);
-			} else {
-#endif
-				for (y = 0; y < hUV; y++)
-				{
-					for (x = 0; x < wUV; x++)
-					{
-						dstwpU[x] = ((int)srcrpU[x] + (int)nextrpU[x]) >> 1;
-					}
-					srcrpU += pitchUV;
-					nextrpU += pitchUV;
-					dstwpU += dpitchUV;
-				}
-#ifdef DECIMATE_MMX_BUILD_PLANE
-			}
-#endif
-			srcrpV =   VPLANE(src);//->GetReadPtr(PLANAR_V);
-			nextrpV =  VPLANE( next);//->GetReadPtr(PLANAR_V);
-			dstwpV =   VPLANE(dst);//->GetWritePtr(PLANAR_V);
-#ifdef DECIMATE_MMX_BUILD_PLANE
-			if (CpuCaps::hasSSE()) { 
-				isse_blend_decimate_plane(dstwpV, srcrpV, nextrpV, wUV, hUV);
-			} else {
-#endif
-				for (y = 0; y < hUV; y++)
-				{
-					for (x = 0; x < wUV; x++)
-					{
-						dstwpV[x] = ((int)srcrpV[x] + (int)nextrpV[x]) >> 1;
-					}
-					srcrpV += pitchUV;
-					nextrpV += pitchUV;
-					dstwpV += dpitchUV;
-				}
-#ifdef DECIMATE_MMX_BUILD_PLANE
-			}
-#endif
-			DrawShow(dst, 0, forced, dropframe, metric, inframe);
-			vidCache->unlockAll();
-			//return dst;
-			//memcpy(data,dst,*len);
-
-			data->duplicate(dst);
-			vidCache->unlockAll();		
-			return 1; // return src;			
-		}
-		//return src;
-		//memcpy(data,src,*len);
-
-		data->duplicate(src);
-		vidCache->unlockAll();		
-		return 1; // return src;			
-	}
-	//env->ThrowError("Decimate: invalid mode option (0-3)");
-	printf("Decimate: invalid mode option (0-3)\n");
-	/* Avoid compiler warning. */
-	return 0;
-}
-//____________________________________________________
-void Decimate::FindDuplicate(int frame, int *chosen, double *metric, bool *forced)
-{
-	int f;
-	ADMImage  * store[MAX_CYCLE_SIZE+1];
-	const unsigned char *storepY[MAX_CYCLE_SIZE+1];
-	const unsigned char *storepU[MAX_CYCLE_SIZE+1];
-	const unsigned char *storepV[MAX_CYCLE_SIZE+1];
-	const unsigned char *prevY, *prevU, *prevV, *currY, *currU, *currV;
-	int x, y, lowest_index, div;
-	unsigned int count[MAX_CYCLE_SIZE], lowest;
-	bool found;
-	unsigned int highest_sum=0;
-
-	/* Only recalculate differences when a new set is needed. */
-	if (frame == last_request)
-	{
-		*chosen = last_result;
-		*metric = last_metric;
-		return;
-	}
-	last_request = frame;
-
-	/* Get cycle+1 frames starting at the one before the asked-for one. */
-	for (f = 0; f <= _param->cycle; f++)
-	{
-		GETFRAME(frame + f - 1, store[f]);
-		storepY[f] = YPLANE(store[f]);//->GetReadPtr(PLANAR_Y);
-		hints_invalid = GetHintingData((unsigned char *) storepY[f], &hints[f]);
-		if (_param->quality == 1 || _param->quality == 3)
-		{
-			storepU[f] = UPLANE(store[f]);//->GetReadPtr(PLANAR_U);
-			storepV[f] = VPLANE(store[f]);//->GetReadPtr(PLANAR_V);
-		}
-	}
-
-    pitchY = _info.width; //store[0]->GetPitch(PLANAR_Y);
-    row_sizeY = _info.width; //store[0]->GetRowSize(PLANAR_Y);
-    heightY = _info.height; //store[0]->GetHeight(PLANAR_Y);
-	if (_param->quality == 1 || _param->quality == 3)
-	{
-		pitchUV = _info.width>>1; //store[0]->GetPitch(PLANAR_V);
-		row_sizeUV = _info.width>>1;//store[0]->GetRowSize(PLANAR_V);
-		heightUV = _info.height>>1;//store[0]->GetHeight(PLANAR_V);
-	}
-
-	int use_quality=_param->quality;
-
-
-	switch (use_quality)
-	{
-	case 0: // subsample, luma only
-		div = (BLKSIZE * BLKSIZE / 4) * 219;
-		break;
-	case 1: // subsample, luma and chroma
-		div = (BLKSIZE * BLKSIZE / 4) * 219 + ( (BLKSIZE * BLKSIZE / 8)) * 224;
-		break;
-	case 2: // fully sample, luma only
-		div = (BLKSIZE * BLKSIZE) * 219;
-		break;
-	case 3: // fully sample, luma and chroma
-		div = (BLKSIZE * BLKSIZE) * 219 + ( BLKSIZE * BLKSIZE/2) * 224;
-		break;
-	}
-
-	xblocks = row_sizeY / BLKSIZE;
-	if (row_sizeY % BLKSIZE) xblocks++;
-	yblocks = heightY / BLKSIZE;
-	if (heightY % BLKSIZE) yblocks++;
-
-	/* Compare each frame to its predecessor. */
-	for (f = 1; f <= _param->cycle; f++)
-	{
-		prevY = storepY[f-1];
-		currY = storepY[f];
-		for (y = 0; y < yblocks; y++)
-		{
-			for (x = 0; x < xblocks; x++)
-			{
-				sum[y*xblocks+x] = 0;
-			}
-		}
-		for (y = 0; y < heightY; y++)
-		{
-			for (x = 0; x < row_sizeY;)
-			{
-				sum[(y/BLKSIZE)*xblocks+x/BLKSIZE] += abs((int)currY[x] - (int)prevY[x]);
-				x++;
-				if (_param->quality == 0 || _param->quality == 1)
-				{
-					if (!(x%4)) x += 12;
-				}
-			}
-			prevY += pitchY;
-			currY += pitchY;
-		}
-		if (_param->quality == 1 || _param->quality == 3)
-		{
-			prevU = storepU[f-1];
-			prevV = storepV[f-1];
-			currU = storepU[f];
-			currV = storepV[f];
-			for (y = 0; y < heightUV; y++)
-			{
-				for (x = 0; x < row_sizeUV;)
-				{
-					sum[((2*y)/BLKSIZE)*xblocks+(2*x)/BLKSIZE] += abs((int)currU[x] - (int)prevU[x]);
-					sum[((2*y)/BLKSIZE)*xblocks+(2*x)/BLKSIZE] += abs((int)currV[x] - (int)prevV[x]);
-					x++;
-					if (_param->quality == 1)
-					{
-						if (!(x%4)) x += 12;
-					}
-				}
-				prevU += pitchUV;
-				currU += pitchUV;
-				prevV += pitchUV;
-				currV += pitchUV;
-			}
-		}
-		highest_sum = 0;
-		for (y = 0; y < yblocks; y++)
-		{
-			for (x = 0; x < xblocks; x++)
-			{
-				if (sum[y*xblocks+x] > highest_sum)
-				{
-					highest_sum = sum[y*xblocks+x];
-				}
-			}
-		}
-		count[f-1] = highest_sum;
-		showmetrics[f-1] = (count[f-1] * 100.0) / div;
-	}
-
-	/* Find the frame with the lowest difference count but
-	   don't use the artificial duplicate at frame 0. */
-	if (frame == 0)
-	{
-		lowest = count[1];
-		lowest_index = 1;
-	}
-	else
-	{
-		lowest = count[0];
-		lowest_index = 0;
-	}
-	for (x = 1; x < _param->cycle; x++)
-	{
-		if (count[x] < lowest)
-		{
-			lowest = count[x];
-			lowest_index = x;
-		}
-	}
-	last_result = frame + lowest_index;
-	if (_param->quality == 1 || _param->quality == 3)
-		last_metric = (lowest * 100.0) / div;
-	else
-		last_metric = (lowest * 100.0) / div;
-	*chosen = last_result;
-	*metric = last_metric;
-
-	
-	found = false;
-	last_forced = false;	
-
-}
-//____________________________________________________
-void Decimate::FindDuplicate2(int frame, int *chosen, bool *forced)
-{
-	int f, g, fsum, bsum, highest, highest_index;
-	ADMImage * store[MAX_CYCLE_SIZE+1];
-	const unsigned char *storepY[MAX_CYCLE_SIZE+1];
-	const unsigned char *storepU[MAX_CYCLE_SIZE+1];
-	const unsigned char *storepV[MAX_CYCLE_SIZE+1];
-	const unsigned char *prevY, *prevU, *prevV, *currY, *currU, *currV;
-	int x, y;
-	double lowest;
-	unsigned int lowest_index;
-	char buf[255];
-	unsigned int highest_sum;
-	bool found;
-#define BLKSIZE 32
-
-	/* Only recalculate differences when a new cycle is started. */
-	if (frame == last_request)
-	{
-		*chosen = last_result;
-		*forced = last_forced;
-		return;
-	}
-	last_request = frame;
-
-	if (firsttime == true || frame == 0)
-	{
-		firsttime = false;
-		for (f = 0; f < MAX_CYCLE_SIZE; f++) Dprev[f] = -1;
-		GETFRAME(frame, store[0]);
-		storepY[0] = YPLANE(store[0]);//->GetReadPtr(PLANAR_Y);
-		if (_param->quality == 1 || _param->quality == 3)
-		{
-			storepU[0] = UPLANE(store[0]);//->GetReadPtr(PLANAR_U);
-			storepV[0] = VPLANE(store[0]);//->GetReadPtr(PLANAR_V);
-		}
-
-		for (f = 1; f <= _param->cycle; f++)
-		{
-			GETFRAME(frame + f - 1, store[f]);
-			storepY[f] =YPLANE( store[f]);//->GetReadPtr(PLANAR_Y);
-			if (_param->quality == 1 || _param->quality == 3)
-			{
-				storepU[f] = UPLANE(store[f]);//->GetReadPtr(PLANAR_U);
-				storepV[f] = VPLANE(store[f]);//->GetReadPtr(PLANAR_V);
-			}
-		}
-
-		pitchY = _info.width; //store[0]->GetPitch(PLANAR_Y);
-		row_sizeY = _info.width; //store[0]->GetRowSize(PLANAR_Y);
-		heightY = _info.height; //store[0]->GetHeight(PLANAR_Y);
-		if (_param->quality == 1 || _param->quality == 3)
-		{
-			pitchUV = _info.width>>1; //store[0]->GetPitch(PLANAR_V);
-			row_sizeUV = _info.width>>1; //store[0]->GetRowSize(PLANAR_V);
-			heightUV = _info.height>>1; //store[0]->GetHeight(PLANAR_V);
-		}
-		switch (_param->quality)
-		{
-		case 0: // subsample, luma only
-			div = (BLKSIZE * BLKSIZE / 4) * 219;
-			break;
-		case 1: // subsample, luma and chroma
-			div = (BLKSIZE * BLKSIZE / 4) * 219 + (BLKSIZE * BLKSIZE / 8) * 224;
-			break;
-		case 2: // fully sample, luma only
-			div = (BLKSIZE * BLKSIZE) * 219;
-			break;
-		case 3: // fully sample, luma and chroma
-			div = (BLKSIZE * BLKSIZE) * 219 + (BLKSIZE * BLKSIZE / 2) * 224;
-			break;
-		}
-		xblocks = row_sizeY / BLKSIZE;
-		if (row_sizeY % BLKSIZE) xblocks++;
-		yblocks = heightY / BLKSIZE;
-		if (heightY % BLKSIZE) yblocks++;
-
-		/* Compare each frame to its predecessor. */
-		for (f = 1; f <= _param->cycle; f++)
-		{
-			for (y = 0; y < yblocks; y++)
-			{
-				for (x = 0; x < xblocks; x++)
-				{
-					sum[y*xblocks+x] = 0;
-				}
-			}
-			prevY = storepY[f-1];
-			currY = storepY[f];
-			for (y = 0; y < heightY; y++)
-			{
-				for (x = 0; x < row_sizeY;)
-				{
-					sum[(y/BLKSIZE)*xblocks+x/BLKSIZE] += abs((int)currY[x] - (int)prevY[x]);
-					x++;
-					if (_param->quality == 0 || _param->quality == 1)
-					{
-						if (!(x%4)) x += 12;
-					}
-				}
-				prevY += pitchY;
-				currY += pitchY;
-			}
-			if (_param->quality == 1 || _param->quality == 3)
-			{
-				prevU = storepU[f-1];
-				currU = storepU[f];
-				prevV = storepV[f-1];
-				currV = storepV[f];
-				for (y = 0; y < heightUV; y++)
-				{
-					for (x = 0; x < row_sizeUV;)
-					{
-						sum[((2*y)/BLKSIZE)*xblocks+(2*x)/BLKSIZE] += abs((int)currU[x] - (int)prevU[x]);
-						sum[((2*y)/BLKSIZE)*xblocks+(2*x)/BLKSIZE] += abs((int)currV[x] - (int)prevV[x]);
-						x++;
-						if (_param->quality == 0 || _param->quality == 1)
-						{
-							if (!(x%4)) x += 12;
-						}
-					}
-					prevU += pitchUV;
-					currU += pitchUV;
-					prevV += pitchUV;
-					currV += pitchUV;
-				}
-			}
-			highest_sum = 0;
-			for (y = 0; y < yblocks; y++)
-			{
-				for (x = 0; x < xblocks; x++)
-				{
-					if (sum[y*xblocks+x] > highest_sum)
-					{
-						highest_sum = sum[y*xblocks+x];
-					}
-				}
-			}
-			metrics[f-1] = (highest_sum * 100.0) / div;
-		}
-
-		Dcurr[0] = 1;
-		for (f = 1; f < _param->cycle; f++)
-		{
-			if (metrics[f] < _param->threshold2) Dcurr[f] = 0;
-			else Dcurr[f] = 1;
-		}
-
-		if (debug)
-		{
-			sprintf(buf,"Decimate: %d: %3.2f %3.2f %3.2f %3.2f %3.2f\n",
-					0, metrics[0], metrics[1], metrics[2], metrics[3], metrics[4]);
-			OutputDebugString(buf);
-		}
-	}
- 	else if (frame >= num_frames_hi - 1)
-	{
-		GETFRAME(num_frames_hi - 1, store[0]);
-		storepY[0] = YPLANE(store[0]);//->GetReadPtr(PLANAR_Y);
-		if (_param->quality == 1 || _param->quality == 3)
-		{
-			storepU[0] = UPLANE(store[0]);//->GetReadPtr(PLANAR_U);
-			storepV[0] = VPLANE(store[0]);//->GetReadPtr(PLANAR_V);
-		}
-		for (f = 0; f < MAX_CYCLE_SIZE; f++) Dprev[f] = Dcurr[f];
-		for (f = 0; f < MAX_CYCLE_SIZE; f++) Dcurr[f] = Dnext[f];
-	}
-	else
-	{
-		GETFRAME(frame + _param->cycle - 1, store[0]);
-		storepY[0] = YPLANE(store[0]);//->GetReadPtr(PLANAR_Y);
-		if (_param->quality == 1 || _param->quality == 3)
-		{
-			storepU[0] = UPLANE(store[0]);//->GetReadPtr(PLANAR_U);
-			storepV[0] = VPLANE(store[0]);//->GetReadPtr(PLANAR_V);
-		}
-		for (f = 0; f < MAX_CYCLE_SIZE; f++) Dprev[f] = Dcurr[f];
-		for (f = 0; f < MAX_CYCLE_SIZE; f++) Dcurr[f] = Dnext[f];
-	}
-	for (f = 0; f < MAX_CYCLE_SIZE; f++) Dshow[f] = Dcurr[f];
-	for (f = 0; f < MAX_CYCLE_SIZE; f++) showmetrics[f] = metrics[f];
-
-	for (f = 1; f <= _param->cycle; f++)
-	{
-		GETFRAME(frame + f + _param->cycle - 1, store[f]);
-		storepY[f] =YPLANE( store[f]);//->GetReadPtr(PLANAR_Y);
-		if (_param->quality == 1 || _param->quality == 3)
-		{
-			storepU[f] = UPLANE(store[f]);//->GetReadPtr(PLANAR_U);
-			storepV[f] = VPLANE(store[f]);//->GetReadPtr(PLANAR_V);
-		}
-	}
-
-	/* Compare each frame to its predecessor. */
-	for (f = 1; f <= _param->cycle; f++)
-	{
-		prevY = storepY[f-1];
-		currY = storepY[f];
-		for (y = 0; y < yblocks; y++)
-		{
-			for (x = 0; x < xblocks; x++)
-			{
-				sum[y*xblocks+x] = 0;
-			}
-		}
-		for (y = 0; y < heightY; y++)
-		{
-			for (x = 0; x < row_sizeY;)
-			{
-				sum[(y/BLKSIZE)*xblocks+x/BLKSIZE] += abs((int)currY[x] - (int)prevY[x]);
-				x++;
-				if (_param->quality == 0 || _param->quality == 1)
-				{
-					if (!(x%4)) x += 12;
-				}
-			}
-			prevY += pitchY;
-			currY += pitchY;
-		}
-		if (_param->quality == 1 || _param->quality == 3)
-		{
-			prevU = storepU[f-1];
-			currU = storepU[f];
-			prevV = storepV[f-1];
-			currV = storepV[f];
-			for (y = 0; y < heightUV; y++)
-			{
-				for (x = 0; x < row_sizeUV;)
-				{
-					sum[((2*y)/BLKSIZE)*xblocks+(2*x)/BLKSIZE] += abs((int)currU[x] - (int)prevU[x]);
-					sum[((2*y)/BLKSIZE)*xblocks+(2*x)/BLKSIZE] += abs((int)currV[x] - (int)prevV[x]);
-					x++;
-					if (_param->quality == 0 || _param->quality == 1)
-					{
-						if (!(x%4)) x += 12;
-					}
-				}
-				prevU += pitchUV;
-				currU += pitchUV;
-				prevV += pitchUV;
-				currV += pitchUV;
-			}
-		}
-		highest_sum = 0;
-		for (y = 0; y < yblocks; y++)
-		{
-			for (x = 0; x < xblocks; x++)
-			{
-				if (sum[y*xblocks+x] > highest_sum)
-				{
-					highest_sum = sum[y*xblocks+x];
-				}
-			}
-		}
-		metrics[f-1] = (highest_sum * 100.0) / div;
-	}
-
-	/* Find the frame with the lowest difference count but
-	   don't use the artificial duplicate at frame 0. */
-	if (frame == 0)
-	{
-		lowest = metrics[1];
-		lowest_index = 1;
-	}
-	else
-	{
-		lowest = metrics[0];
-		lowest_index = 0;
-	}
-	for (f = 1; f < _param->cycle; f++)
-	{
-		if (metrics[f] < lowest)
-		{
-			lowest = metrics[f];
-			lowest_index = f;
-		}
-	}
-
-	for (f = 0; f < _param->cycle; f++)
-	{
-		if (metrics[f] < _param->threshold2) Dnext[f] = 0;
-		else Dnext[f] = 1;
-	}
-
-	if (debug)
-	{
-		sprintf(buf,"Decimate: %d: %3.2f %3.2f %3.2f %3.2f %3.2f\n",
-		        frame + 5, metrics[0], metrics[1], metrics[2], metrics[3], metrics[4]);
-		OutputDebugString(buf);
-	}
-
-	if (debug)
-	{
-		sprintf(buf,"Decimate: %d: %d %d %d %d %d\n",
-		        frame, Dcurr[0], Dcurr[1], Dcurr[2], Dcurr[3], Dcurr[4]);
-//		sprintf(buf,"Decimate: %d: %d %d %d %d %d - %d %d %d %d %d - %d %d %d %d %d\n",
-//		        frame, Dprev[0], Dprev[1], Dprev[2], Dprev[3], Dprev[4],
-//					   Dcurr[0], Dcurr[1], Dcurr[2], Dcurr[3], Dcurr[4],
-//					   Dnext[0], Dnext[1], Dnext[2], Dnext[3], Dnext[4]);
-		OutputDebugString(buf);
-	}
-
-	/* Find the longest strings of duplicates and decimate a frame from it. */
-	highest = -1;
-	for (f = 0; f < _param->cycle; f++)
-	{
-		if (Dcurr[f] == 1)
-		{
-			bsum = 0;
-			fsum = 0;
-		}
-		else
-		{
-			bsum = 1;
-			g = f;
-			while (--g >= 0)
-			{
-				if (Dcurr[g] == 0)
-				{
-					bsum++;
-				}
-				else break;
-			}
-			if (g < 0)
-			{
-				g = _param->cycle;
-				while (--g >= 0)
-				{
-					if (Dprev[g] == 0)
-					{
-						bsum++;
-					}
-					else break;
-				}
-			}
-			fsum = 1;
-			g = f;
-			while (++g < _param->cycle)
-			{
-				if (Dcurr[g] == 0)
-				{
-					fsum++;
-				}
-				else break;
-			}
-			if (g >= _param->cycle)
-			{
-				g = -1;
-				while (++g < _param->cycle)
-				{
-					if (Dnext[g] == 0)
-					{
-						fsum++;
-					}
-					else break;
-				}
-			}
-		}
-		if (bsum + fsum > highest)
-		{
-			highest = bsum + fsum;
-			highest_index = f;
-		}
-//		sprintf(buf,"Decimate: bsum %d, fsum %d\n", bsum, fsum);
-//		OutputDebugString(buf);
-	}
-
-	f = highest_index;
-	if (Dcurr[f] == 1)
-	{
-		/* No duplicates were found! Act as if mode=0. */
-		*chosen = last_result = frame + lowest_index;
-	}
-	else
-	{
-		/* Prevent this decimated frame from being considered again. */ 
-		Dcurr[f] = 1;
-		*chosen = last_result = frame + highest_index;
-	}
-	last_forced = false;
-	if (debug)
-	{
-		sprintf(buf,"Decimate: dropping frame %d\n", last_result);
-		OutputDebugString(buf);
-	}
-
-	
-	found = false;
-	
-	if (found == true)
-	{
-		*chosen = last_result ;
-		*forced = last_forced = true;
-		if (debug)
-		{
-			sprintf(buf,"Decimate: overridden drop frame -- drop %d\n", last_result);
-			OutputDebugString(buf);
-		}
-	}
-}
-#ifdef DECIMATE_MMX_BUILD_PLANE
-//
-//
-//
-//
-void isse_blend_decimate_plane(uint8_t * dst, uint8_t* src,  uint8_t* src_next, 
-			int w, int h)
-{
-uint32_t x;
-	if (!h) return;  // Height == 0 - avoid silly crash.
-	
-	x=w>>3; // 8 pixels at a time
-	for(;x>0;x--)
-	{
-	 __asm__( ".align 16\n"
-	 	"movq  (%1), %%mm0 \n"
-		"movq  (%2), %%mm2 \n"
-		"pavgb %%mm0,%%mm1 \n"
-		"movq  %%mm1,(%0) \n"
-
-                   : : "r" (dst), "r" (src), "r" (src_next));
-		
-		dst+=8;
-		src+=8;
-		src_next+=8;
-  	}
-    	__asm__("emms");
-  
-}
-int isse_scenechange_32(const uint8_t *c_plane, const uint8_t *tplane, int height, int width) 
-{
-  int wp=width>>5;
-  int hp=height;
-  int returnvalue=0xbadbad00;
-    
-    __asm__(
-    ".align 16\n"
-    "pxor %%mm6,%%mm6\n"
-    "pxor %%mm7,%%mm7\n"
-    ::);
-    for(uint32_t y=0;y<hp;y++)
-    {
-	for(uint32_t x=0;x<wp;x++)
-	{
-		__asm__(
-    		".align 16\n"
-    		"movq (%0),%%mm0 \n"
-		"movq 8(%0),%%mm2 \n"
-		"movq (%1),%%mm1 \n"
-		"movq 8(%1),%%mm3 \n"
-		"psadbw %%mm1,%%mm0\n"
-		"psadbw %%mm3,%%mm2\n"
-		"paddd %%mm0,%%mm6 \n"
-		"paddd %%mm2,%%mm7 \n"
-		
-		"movq 16(%0),%%mm0 \n"
-		"movq 24(%0),%%mm2 \n"
-		"movq 16(%1),%%mm1 \n"
-		"movq 24(%1),%%mm3 \n"
-		"psadbw %%mm1,%%mm0\n"
-		"psadbw %%mm3,%%mm2\n"
-		"paddd %%mm0,%%mm6 \n"
-		"paddd %%mm2,%%mm7 \n"
-		
-		
-		: : "r" (c_plane) , "r" (tplane)
-		);
-		c_plane+=32;
-		tplane+=32;
-	}    
-    
-    	c_plane+=width-wp*32;
-	tplane+=width-wp*32;
-    }
-    __asm__(
-    ".align 16\n"
-    "paddd %%mm6,%%mm7\n"
-    "movd %%mm7,(%0)\n"
-    "emms \n"
-    : : "r" (&returnvalue)
-    );
-  
-  return returnvalue;
-}
-int isse_scenechange_16(const uint8_t *c_plane, const uint8_t *tplane, int height, int width) 
-{
-  int wp=width>>4;
-  int hp=height;
-  int returnvalue=0xbadbad00;
-    
-    __asm__(
-    ".align 16\n"
-    "pxor %%mm6,%%mm6\n"
-    "pxor %%mm7,%%mm7\n"
-    ::);
-    for(uint32_t y=0;y<hp;y++)
-    {
-	for(uint32_t x=0;x<wp;x++)
-	{
-		__asm__(
-    		".align 16\n"
-    		"movq (%0),%%mm0 \n"
-		"movq 8(%0),%%mm2 \n"
-		"movq (%1),%%mm1 \n"
-		"movq 8(%1),%%mm3 \n"
-		"psadbw %%mm1,%%mm0\n"
-		"psadbw %%mm3,%%mm2\n"
-		"paddd %%mm0,%%mm6 \n"
-		"paddd %%mm2,%%mm7 \n"				
-		
-		
-		: : "r" (c_plane) , "r" (tplane)
-		);
-		c_plane+=16;
-		tplane+=16;
-	}    
-    
-    	c_plane+=width-wp*16;
-	tplane+=width-wp*16;
-    }
-    __asm__(
-    ".align 16\n"
-    "paddd %%mm6,%%mm7\n"
-    "movd %%mm7,(%0)\n"
-    "emms \n"
-    : : "r" (&returnvalue)
-    );
-  
-  return returnvalue;
-}
-int isse_scenechange_8(const uint8_t *c_plane, const uint8_t *tplane, int height, int width) 
-{
-  int wp=width>>3;
-  int hp=height;
-  int returnvalue=0xbadbad00;
-    
-    __asm__(
-    ".align 16\n"
-    "pxor %%mm6,%%mm6\n"
-    "pxor %%mm7,%%mm7\n"
-    ::);
-    for(uint32_t y=0;y<hp;y++)
-    {
-	for(uint32_t x=0;x<wp;x++)
-	{
-		__asm__(
-    		".align 16\n"
-    		"movq (%0),%%mm0 \n"		
-		"movq (%1),%%mm1 \n"		
-		"psadbw %%mm1,%%mm0\n"		
-		"paddd %%mm0,%%mm6 \n"
-		
-		: : "r" (c_plane) , "r" (tplane)
-		);
-		c_plane+=8;
-		tplane+=8;
-	}    
-    
-    	c_plane+=width-wp*8;
-	tplane+=width-wp*8;
-    }
-    __asm__(
-    ".align 16\n"    
-    "movd %%mm6,(%0)\n"
-    "emms \n"
-    : : "r" (&returnvalue)
-    );
-  
-  return returnvalue;
-}
-
-#endif

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDecDec_param.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDecDec_param.h	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDecDec_param.h	2007-01-13 16:37:32 UTC (rev 2721)
@@ -1,16 +0,0 @@
-//
-// C++ Interface: ADM_vidDecDec_param
-//
-// Description: 
-//
-//
-// Author: mean <fixounet at free.fr>, (C) 2004
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-typedef struct DECIMATE_PARAM
-{
-	uint32_t    	cycle, mode, quality;
-	double 		threshold, threshold2;
-};

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDecTel_param.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDecTel_param.h	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDecTel_param.h	2007-01-13 16:37:32 UTC (rev 2721)
@@ -1,34 +0,0 @@
-//
-// C++ Interface: ADM_vidDecTel_param
-//
-// Description: 
-//
-//
-// Author: mean <fixounet at free.fr>, (C) 2004
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-
-
-typedef struct TelecideParam
-{
-	uint32_t 	order;
-	uint32_t 	back;
-	uint32_t	back_saved;
-	uint32_t 	guide;
-	double	 	gthresh;
-	uint32_t 	post;
-	uint32_t 	chroma;
-	double 		vthresh;
-	double		vthresh_saved;
-	double 		bthresh;
-	double 		dthresh;
-	uint32_t 	blend;
-	uint32_t 	nt;
-	uint32_t 	y0;
-	uint32_t 	y1;
-	uint32_t 	hints;
-	uint32_t 	show;
-	uint32_t 	debug;
-};

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDecTelecide.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDecTelecide.cpp	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDecTelecide.cpp	2007-01-13 16:37:32 UTC (rev 2721)
@@ -1,1643 +0,0 @@
-
-/***************************************************************************
-                          ADM_vidDecTelecide  -  description
-                             -------------------
-    
-    email                : fixounet at free.fr
-
-    Port of Donal Graft Telecide which is (c) Donald Graft
-    http://www.neuron2.net
-    http://puschpull.org/avisynth/decomb_reference_manual.html
-
- ***************************************************************************/
-/*
-	Telecide plugin for Avisynth -- recovers original progressive
-	frames from telecined streams. The filter operates by matching
-	fields and automatically adapts to phase/pattern changes.
-
-	Copyright (C) 2003 Donald A. Graft
-
-	This program is free software; you can redistribute it and/or modify
-	it under the terms of the GNU General Public License as published by
-	the Free Software Foundation.
-
-	This program is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-	GNU General Public License for more details.
-
-	You should have received a copy of the GNU General Public License
-	along with this program; if not, write to the Free Software
-	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-*/
-#include "config.h"
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <ADM_assert.h>
-
-#include "config.h"
-#include "fourcc.h"
-#include "avio.hxx"
-#include "avi_vars.h"
-
-#include "ADM_toolkit/toolkit.hxx"
-#include "ADM_editor/ADM_edit.hxx"
-#include "ADM_video/ADM_genvideo.hxx"
-#include"ADM_video/ADM_vidField.h"
-
-#include "ADM_osSupport/ADM_debugID.h"
-#define MODULE_NAME MODULE_FILTER
-#include "ADM_osSupport/ADM_debug.h"
-
-
-
-#include "ADM_vidDecTelecide.h"
-#include "ADM_filter/video_filters.h"
-static FILTER_PARAM decomb_template={16,{"order","back","guide",
-	 	 	"gthresh","post","chroma","vthresh",
-			"bthresh","dthresh","blend",
-			"nt","y0","y1","hints",
-			"show","debug"}};
-BUILD_CREATE(decomb_create,Telecide);
-SCRIPT_CREATE(decomb_script,Telecide,decomb_template);
-extern uint8_t DIA_getDecombTelecide(TelecideParam *param);
-
-uint8_t Telecide::configure(AVDMGenericVideoStream *in)
-{
-	_in=in;
-	return DIA_getDecombTelecide(_param);
-	
-}
-
-char *Telecide::printConf( void )
-{
- 	static char buf[50];
-
-  	ADM_assert(_param); 	
- 	sprintf((char *)buf," Decomb Telecide");
-        return buf;
-}
-
-
-#define PROGRESSIVE  0x00000001
-#define MAGIC_NUMBER (0xdeadbeef)
-#define IN_PATTERN   0x00000002
-
-
-  uint8_t PutHintingData(unsigned char *video, unsigned int hint);
-  uint8_t GetHintingData(unsigned char *video, unsigned int *hint);
-  void BitBlt(uint8_t * dstp, int dst_pitch, const uint8_t* srcp,
-            int src_pitch, int row_size, int height);
-//  void DrawString(ADMImage *dst, int x, int y, const char *s);
- // void DrawStringYUY2(uint8_t *dst, int x, int y, const char *s);
-#define DrawString drawString
-
-uint8_t Telecide::getCoupledConf( CONFcouple **couples)
-{
-
-                        ADM_assert(_param);
-                        *couples=new CONFcouple(16);
-
-#define CSET(x)  (*couples)->setCouple((char *)#x,(_param->x))
-        CSET(order);
-        CSET(back);
-        CSET(chroma);
-        CSET(guide);
-        CSET(gthresh);
-        CSET(post);
-        CSET(vthresh);
-        CSET(bthresh);
-        CSET(dthresh);
-        CSET(blend);
-        CSET(nt);
-        CSET(y0);
-        CSET(y1);
-        CSET(hints);
-        CSET(show);
-        CSET(debug);
-        
-        return 1;
-
-}
-uint8_t PutHintingData(unsigned char *video, unsigned int hint)
-{
-        unsigned char *p;
-        unsigned int i, magic_number = MAGIC_NUMBER;
-        bool error = false;
-
-        p = video;
-        for (i = 0; i < 32; i++)
-        {
-                *p &= ~1; 
-                *p++ |= ((magic_number & (1 << i)) >> i);
-        }
-        for (i = 0; i < 32; i++)
-        {
-                *p &= ~1;
-                *p++ |= ((hint & (1 << i)) >> i);
-        }
-        return error;
-}
-
-uint8_t GetHintingData(unsigned char *video, unsigned int *hint)
-{
-        unsigned char *p;
-        unsigned int i, magic_number = 0;
-        bool error = false;
-
-        p = video;
-        for (i = 0; i < 32; i++)
-        {
-                magic_number |= ((*p++ & 1) << i);
-        }
-        if (magic_number != MAGIC_NUMBER)
-        {
-                error = true;
-        }
-        else
-        {
-                *hint = 0;
-                for (i = 0; i < 32; i++)
-                {
-                        *hint |= ((*p++ & 1) << i);
-                }
-        }
-        return error;
-}
-void BitBlt(uint8_t* dstp, int dst_pitch, const uint8_t* srcp,
-            int src_pitch, int row_size, int height)
-{
-        for(uint32_t y=0;y<height;y++)
-        {
-                memcpy(dstp,srcp,row_size);
-                dstp+=dst_pitch;
-                srcp+=src_pitch;
-        }
-}        
-void Telecide::WriteHints(unsigned char *dst, bool film, bool inpattern)
-        {
-                unsigned int hint;
-
-                if (GetHintingData(dst, &hint) == true) hint = 0;
-                if (film == true) hint |= PROGRESSIVE;
-                else hint &= ~PROGRESSIVE;
-                if (inpattern == true) hint |= IN_PATTERN;
-                else hint &= ~IN_PATTERN;
-                PutHintingData(dst, hint);
-        }
-void Telecide::PutChosen(int frame, unsigned int chosen)
-        {
-                int f;
-
-                f = frame % CACHE_SIZE;
-                if (frame < 0 || frame > _info.nb_frames - 1 || cache[f].frame != frame)
-                        return;
-                cache[f].chosen = chosen;
-        }
-
-        void Telecide::CacheInsert(int frame, unsigned int p, unsigned int pblock,
-                                                                        unsigned int c, unsigned int cblock)
-        {
-                int f;
-
-                f = frame % CACHE_SIZE;
-                if (frame < 0 || frame > _info.nb_frames - 1)
-                        ADM_assert(0);
-                cache[f].frame = frame;
-                cache[f].metrics[P] = p;
-                if (f) cache[f-1].metrics[N] = p;
-                cache[f].metrics[C] = c;
-                cache[f].metrics[PBLOCK] = pblock;
-                cache[f].metrics[CBLOCK] = cblock;
-                cache[f].chosen = 0xff;
-        }
-
-        bool Telecide::CacheQuery(int frame, unsigned int *p, unsigned int *pblock,
-                                                                        unsigned int *c, unsigned int *cblock)
-        {
-                int f;
-
-                f = frame % CACHE_SIZE;
-                if (frame < 0 || frame > _info.nb_frames - 1)
-                {
-                        printf("Frame %d is out! (%d)\n",frame,_info.nb_frames-1);
-                        ADM_assert(0);
-                }
-                if (cache[f].frame != frame)
-                {
-                        return false;
-                }
-                *p = cache[f].metrics[P];
-                *c = cache[f].metrics[C];
-                *pblock = cache[f].metrics[PBLOCK];
-                *cblock = cache[f].metrics[CBLOCK];
-                return true;
-        }
-
-       
-Telecide::Telecide(AVDMGenericVideoStream *in,CONFcouple *couples) 
-{
-
-		int i;		
-		int count;
-		char *d, *dsaved;
-		unsigned int *p, *x;
-		_lastFrame=0xfffffff0;
-		
-   		
-		_in=in;		
-   		memcpy(&_info,_in->getInfo(),sizeof(_info));    
-  		_info.encoding=1;
-		_uncompressed=NULL;
-		vidCache=new VideoCache(12,in);
-				 	
-  		_info.encoding=1;
-
-		
-		pitch = _info.width;
-		dpitch = _info.width;
-		pitchover2 = pitch >> 1;
-		pitchtimes4 = pitch << 2;
-		w = _info.width;
-		h = _info.height;
-		wover2 = w/2;
-		hover2 = h/2;
-		hplus1over2 = (h+1)/2;
-		hminus2= h - 2;
-		_param=NEW(TelecideParam);
-		if(couples)
-		{
-			GET(order);
-			GET(back);
-			GET(chroma);
-			GET(guide);
-			GET(gthresh);
-			GET(post);
-			GET(vthresh);
-			GET(bthresh);
-			GET(dthresh);
-			GET(blend);
-			GET(nt);
-			GET(y0);
-			GET(y1);
-			GET(hints);
-			GET(show);
-			GET(debug);
-		}
-		else // Default
-  		{
-			 	
-			 	_param->order = 1; 		// 0 Field ok, 1 field reverted 0 BFF/1 TFF
-				_param->back = NO_BACK; // 0 Never, 1 when bad, 2 always tried MUST Have post !=0
-				_param->chroma = false;
-				_param->guide = GUIDE_32;// 0 / NONE - 1 GUIDE_32/ivtc-2 GUIDE 22/PAL-3 PAL/NTSC
-				_param->gthresh = 10.0;
-				_param->post = POST_NONE;
-				_param->vthresh = 50.0;
-				_param->bthresh = 50.0;
-				_param->dthresh = 7.0;
-				_param->blend = false;
-				_param->nt = 10;	// Noise tolerance
-				_param->y0 = 0;		// Zone to try (avoid subs)
-				_param->y1 = 0;
-				_param->hints = true;
-				_param->show = false;
-				_param->debug = false; 
-
-		}
-				 
-				
-		tff = (_param->order == 0 ? false : true);	
-
-		_param->back_saved = _param->back;
-
-		// Set up pattern guidance.
-		cache = (struct CACHE_ENTRY *) ADM_alloc(CACHE_SIZE * sizeof(struct CACHE_ENTRY));
-		for (i = 0; i < CACHE_SIZE; i++)
-		{
-			cache[i].frame = 0xffffffff;
-			cache[i].chosen = 0xff;
-		}
-
-		if (_param->guide == GUIDE_32)
-		{
-			// 24fps to 30 fps telecine.
-			cycle = 5;
-		}
-		if (_param->guide == GUIDE_22)
-		{
-			// PAL guidance (expect the current match to be continued).
-			cycle = 2;
-		}
-		else if (_param->guide == GUIDE_32322)
-		{
-			// 25fps to 30 fps telecine.
-			cycle = 6;
-		}
-
-		// Get needed dynamic storage.
-		vmetric = 0;
-		_param->vthresh_saved = _param->vthresh;
-		xblocks = (_info.width+BLKSIZE-1) / BLKSIZE;
-		yblocks = (_info.height+BLKSIZE-1) / BLKSIZE;
-#ifdef WINDOWED_MATCH
-		matchp = (unsigned int *) ADM_alloc(xblocks * yblocks * sizeof(unsigned int));
-		
-		matchc = (unsigned int *) ADM_alloc(xblocks * yblocks * sizeof(unsigned int));
-		
-#endif
-		sump = (unsigned int *) ADM_alloc(xblocks * yblocks * sizeof(unsigned int));
-		
-		sumc = (unsigned int *) ADM_alloc(xblocks * yblocks * sizeof(unsigned int));
-		
-
-		
-}
-//____________________________________________________________________
-Telecide::~Telecide()
-{
-		unsigned int *p;
-
-		if (cache != NULL) ADM_dealloc(cache);
-#ifdef WINDOWED_MATCH
-		if (matchp != NULL) ADM_dealloc(matchp);
-		if (matchc != NULL) ADM_dealloc(matchc);
-#endif
-		if (sump != NULL) ADM_dealloc(sump);
-		if (sumc != NULL) ADM_dealloc(sumc);
-
-		delete vidCache;
-		vidCache=NULL;
-		
-		
-}
-//____________________________________________________________________
-void Telecide::Show(ADMImage *dst, int frame)
-{
-	char use;
-	
-	if (chosen == P) use = 'p';
-	else if (chosen == C) use = 'c';
-	else use = 'n';
-
-	sprintf(buf, "Telecide %s", VERSION);
-	DrawString(dst, 0, 0, buf);
-
-	sprintf(buf, "Copyright 2003 Donald A. Graft");
-	DrawString(dst, 0, 1, buf);
-
-	sprintf(buf,"frame %d:", frame);
-	DrawString(dst, 0, 3, buf);
-
-	sprintf(buf, "matches: %d  %d  %d", p, c, np);
-	DrawString(dst, 0, 4, buf);
-
-	if (_param->post != POST_NONE)
-	{
-		sprintf(buf,"vmetrics: %d  %d  %d [chosen=%d]", pblock, cblock, npblock, vmetric);
-		DrawString(dst, 0, 5, buf);
-	}
-
-	if (_param->guide != GUIDE_NONE)
-	{
-		sprintf(buf, "pattern mismatch=%0.2f%%", mismatch); 
-		DrawString(dst, 0, 5 + (_param->post != POST_NONE), buf);
-	}
-
-	sprintf(buf,"[%s %c]%s %s",
-		found == true ? "forcing" : "using", use,
-		_param->post != POST_NONE ? (film == true ? " [progressive]" : " [interlaced]") : "",
-		_param->guide != GUIDE_NONE ? status : "");
-	DrawString(dst, 0, 5 + (_param->post != POST_NONE) + (_param->guide != GUIDE_NONE), buf);
-}
-//______________________________________________________________
-void Telecide::Debug(int frame)
-{
-	char use;
-
-	if (chosen == P) use = 'p';
-	else if (chosen == C) use = 'c';
-	else use = 'n';
-	sprintf(buf,"Telecide: frame %d: matches: %d %d %d", frame, p, c, np);
-	OutputDebugString(buf);
-	if (_param->post != POST_NONE)
-	{
-		sprintf(buf,"Telecide: frame %d: vmetrics: %d %d %d [chosen=%d]", frame, pblock, cblock, npblock, vmetric);
-		OutputDebugString(buf);
-	}
-	sprintf(buf,"Telecide: frame %d: [%s %c]%s %s", frame, found == true ? "forcing" : "using", use,
-		_param->post != POST_NONE ? (film == true ? " [progressive]" : " [interlaced]") : "",
-		_param->guide != GUIDE_NONE ? status : "");
-	OutputDebugString(buf);
-}
-
-//______________________________________________________________
-uint8_t Telecide::getFrameNumberNoAlloc(uint32_t frame,
-				uint32_t *len,
-   				ADMImage *data,
-				uint32_t *flags)
-{
-ADMImage *fc;
-uint8_t *fcrp;
-uint8_t *fcrpU,*fcrpV;
-
-uint32_t pframe,nframe;
-
-ADMImage *fp;
-uint8_t *fprp;
-uint8_t *fprpU,*fprpV;
-
-ADMImage *fn;
-uint8_t *fnrp;
-uint8_t *fnrpU,*fnrpV;
-
-ADMImage *lc;
-uint8_t *crp;
-uint8_t *crpU,*crpV;
-
-ADMImage *lp;
-uint8_t *prp;
-uint8_t *prpU,*prpV;
-
-ADMImage *dst;
-uint8_t *dstp;
-uint8_t *dstpU,*dstpV;
-
-ADMImage *final;
-uint8_t *finalp;
-uint8_t *finalpU,*finalpV;
-
-
-#define guide _param->guide
-#define order _param->order
-#define back  _param->back
-
-#define back_saved  _param->back_saved
-#define guide       _param->guide
-#define gthresh     _param->gthresh
-#define post        _param->post
-#define chroma      _param->chroma
-#define vthresh     _param->vthresh
-
-#define vthresh_saved _param->vthresh_saved
-#define hints      _param->hints
-#define show       _param->show
-#define debug      _param->debug
-
-#define bthresh      _param->bthresh
-#define dthresh      _param->dthresh
-#define blend        _param->blend
-
-#define nt      _param->nt
-#define y0      _param->y0
-#define y1      _param->y1
-
-        // Get the current frame.
-        if (frame < 0) frame = 0;
-        if (frame > _info.nb_frames - 1) frame = _info.nb_frames - 1;
-        GETFRAME(frame, fc);
-        fcrp = (unsigned char *) fc->GetReadPtr(PLANAR_Y);
-        //if (vi.IsYV12())
-        {
-                fcrpU = (unsigned char *) fc->GetReadPtr(PLANAR_U);
-                fcrpV = (unsigned char *) fc->GetReadPtr(PLANAR_V);
-        }
-
-        // Get the previous frame.
-        pframe = frame == 0 ? 0 : frame - 1;
-        GETFRAME(pframe, fp);
-        fprp = (unsigned char *) fp->GetReadPtr(PLANAR_Y);
-        //if (vi.IsYV12())
-        {
-                fprpU = (unsigned char *) fp->GetReadPtr(PLANAR_U);
-                fprpV = (unsigned char *) fp->GetReadPtr(PLANAR_V);
-        }
-
-        // Get the next frame metrics if we might need them.
-        nframe = frame >= _info.nb_frames - 1 ? _info.nb_frames - 1 : frame + 1;
-        GETFRAME(nframe, fn);
-        fnrp = (unsigned char *) fn->GetReadPtr(PLANAR_Y);
-        //if (vi.IsYV12())
-        {
-                fnrpU = (unsigned char *) fn->GetReadPtr(PLANAR_U);
-                fnrpV = (unsigned char *) fn->GetReadPtr(PLANAR_V);
-        }
-
-        pitch = fc->GetPitch(PLANAR_Y);
-        pitchover2 = pitch >> 1;
-        pitchtimes4 = pitch << 2;
-        w = fc->GetRowSize(PLANAR_Y);
-        h = fc->GetHeight(PLANAR_Y);
-/*
-        if (vi.IsYUY2() && ((w/2) & 1))
-                env->ThrowError("Telecide: width must be a multiple of 2; use Crop");
-        if (vi.IsYV12() && (w & 1))
-                env->ThrowError("Telecide: width must be a multiple of 2; use Crop");
-        if (h & 1)
-                env->ThrowError("Telecide: height must be a multiple of 2; use Crop");
-*/
-        wover2 = w/2;
-        hover2 = h/2;
-        hplus1over2 = (h+1)/2;
-        hminus2= h - 2;
-        //dst = env->NewVideoFrame(vi);
-        dst=data;
-        dpitch = dst->GetPitch(PLANAR_Y);
-
-        // Ensure that the metrics for the frames
-        // after the current frame are in the cache. They will be used for
-        // pattern guidance.
-        if (guide != GUIDE_NONE)
-        {
-                for (y = frame + 1; y <= frame + cycle + 1; y++)
-                {
-                        if (y > _info.nb_frames - 1) break;
-                        if (CacheQuery(y, &p, &pblock, &c, &cblock) == false)
-                        {
-                                GETFRAME(y, lc);
-                                crp = (unsigned char *) lc->GetReadPtr(PLANAR_Y);
-                                //if (vi.IsYV12())
-                                {
-                                        crpU = (unsigned char *) lc->GetReadPtr(PLANAR_U);
-                                        crpV = (unsigned char *) lc->GetReadPtr(PLANAR_V);
-                                }
-                                GETFRAME(y == 0 ? 1 : y - 1, lp);
-                                prp = (unsigned char *) lp->GetReadPtr(PLANAR_Y);
-                                //if (vi.IsYV12())
-                                {
-                                        prpU = (unsigned char *) lp->GetReadPtr(PLANAR_U);
-                                        prpV = (unsigned char *) lp->GetReadPtr(PLANAR_V);
-                                }
-                                CalculateMetrics(y, crp, crpU, crpV, prp, prpU, prpV);
-                        }
-                }
-        }
-
-        /* Check for manual overrides of the field matching. */
-        
-        found = false;
-        film = true;
-        
-        inpattern = false;
-        vthresh = vthresh_saved;
-        back = back_saved;
-#if 0
-        overrides_p = overrides;
-        override = false;
-        if (overrides_p != NULL)
-        {
-                while (*overrides_p < 0xffffffff)
-                {
-                        // If the frame is in range...
-                        if (((unsigned int) frame >= *overrides_p) && ((unsigned int) frame <= *(overrides_p+1)))
-                        {
-                                // and it's a single specifier. 
-                                if (*(overrides_p+3) == 'p' || *(overrides_p+3) == 'c' || *(overrides_p+3) == 'n')
-                                {
-                                        // Get the match specifier and stop parsing.
-                                        switch(*(overrides_p+3))
-                                        {
-                                        case 'p': chosen = P; lowest = cache[frame%CACHE_SIZE].metrics[P]; found = true; break;
-                                        case 'c': chosen = C; lowest = cache[frame%CACHE_SIZE].metrics[C]; found = true; break;
-                                        case 'n': chosen = N; lowest = cache[(frame+1)%CACHE_SIZE].metrics[P]; found = true; break;
-                                        }
-                                }
-                                else if (*(overrides_p+3) == 'b')
-                                {
-                                        back = *(overrides_p+2);
-                                }
-                                else if (*(overrides_p+3) == 'm')
-                                {
-                                        // It's a multiple match specifier.
-                                        found = true;
-                                        // Get the pointer to the specifier string.
-                                        unsigned int *x = (unsigned int *) *(overrides_p+2);
-                                        // Get the index into the specification string.
-                                        // Remember, the count is first followed by the specifiers.
-                                        int ndx = ((frame - *overrides_p) % *x);
-                                        // Point to the specifier string.
-                                        x++;
-                                        // Load the specifier for this frame and stop parsing.
-                                        switch(x[ndx])
-                                        {
-                                        case 'p': chosen = P; lowest = cache[frame%CACHE_SIZE].metrics[P]; break;
-                                        case 'c': chosen = C; lowest = cache[frame%CACHE_SIZE].metrics[C]; break;
-                                        case 'n': chosen = N; lowest = cache[(frame+1)%CACHE_SIZE].metrics[P]; break;
-                                        }
-                                }
-                        }
-                        // Next override line.
-                        overrides_p += 4;
-                }
-        }
-#endif
-        // Get the metrics for the current-previous (p), current-current (c), and current-next (n) match candidates.
-        if (CacheQuery(frame, &p, &pblock, &c, &cblock) == false)
-        {
-                CalculateMetrics(frame, fcrp, fcrpU, fcrpV, fprp, fprpU, fprpV);
-                CacheQuery(frame, &p, &pblock, &c, &cblock);
-        }
-        if (CacheQuery(nframe, &np, &npblock, &nc, &ncblock) == false)
-        {
-                CalculateMetrics(nframe, fnrp, fnrpU, fnrpV, fcrp, fcrpU, fcrpV);
-                CacheQuery(nframe, &np, &npblock, &nc, &ncblock);
-        }
-
-        // Determine the best candidate match.
-        if (found != true)
-        {
-                lowest = c;
-                chosen = C;
-                if (back == ALWAYS_BACK && p < lowest)
-                {
-                        lowest = p;
-                        chosen = P;
-                }
-                if (np < lowest)
-                {
-                        lowest = np;
-                        chosen = N;
-                }
-        }
-        if ((frame == 0 && chosen == P) || (frame == _info.nb_frames - 1 && chosen == N))
-        {
-                chosen = C;
-                lowest = c;
-        }
-
-        // See if we can apply pattern guidance.
-        mismatch = 100.0;
-        if (guide != GUIDE_NONE)
-        {
-                hard = false;
-                if (frame >= cycle && PredictHardYUY2(frame, &predicted, &predicted_metric) == true)
-                {
-                        inpattern = true;
-                        mismatch = 0.0;
-                        hard = true;
-                        if (chosen != predicted)
-                        {
-                                // The chosen frame doesn't match the prediction.
-                                if (predicted_metric == 0) mismatch = 0.0;
-                                else mismatch = (100.0*abs(predicted_metric - lowest))/predicted_metric;
-                                if (mismatch < gthresh)
-                                {
-                                        // It's close enough, so use the predicted one.
-                                        if (found != true)
-                                        {
-                                                chosen = predicted;
-                                                override = true;
-                                        }
-                                }
-                                else
-                                {
-                                        hard = false;
-                                        inpattern = false;
-                                }
-                        }
-                }
-
-                if (hard == false && guide != GUIDE_22)
-                {
-                        int i;
-                        struct PREDICTION *pred = PredictSoftYUY2(frame);
-
-                        if ((frame <= _info.nb_frames - 1 - cycle) &&     (pred[0].metric != 0xffffffff))
-                        {
-                                // Apply pattern guidance.
-                                // If the predicted match metric is within defined percentage of the
-                                // best calculated one, then override the calculated match with the
-                                // predicted match.
-                                i = 0;
-                                while (pred[i].metric != 0xffffffff)
-                                {
-                                        predicted = pred[i].predicted;
-                                        predicted_metric = pred[i].predicted_metric;
-#ifdef DEBUG_PATTERN_GUIDANCE
-                                        sprintf(buf, "%d: predicted = %d\n", frame, predicted);
-                                        OutputDebugString(buf);
-#endif
-                                        if (chosen != predicted)
-                                        {
-                                                // The chosen frame doesn't match the prediction.
-                                                if (predicted_metric == 0) mismatch = 0.0;
-                                                else mismatch = (100.0*abs(predicted_metric - lowest))/predicted_metric;
-                                                if ((int) mismatch <= gthresh)
-                                                {
-                                                        // It's close enough, so use the predicted one.
-                                                        if (found != true)
-                                                        {
-                                                                chosen = predicted;
-                                                                override = true;
-                                                        }
-                                                        inpattern = true;
-                                                        break;
-                                                }
-                                                else
-                                                {
-                                                        // Looks like we're not in a predictable pattern.
-                                                        inpattern = false;
-                                                }
-                                        }
-                                        else
-                                        {
-                                                inpattern = true;
-                                                mismatch = 0.0;
-                                                break;
-                                        }
-                                        i++;
-                                }
-                        }
-                }
-        }
-
-        // Check for overrides of vthresh.
-#if 0
-        overrides_p = overrides;
-        if (overrides_p != NULL)
-        {
-                while (*overrides_p < 0xffffffff)
-                {
-                        // If the frame is in range...
-                        if (((unsigned int) frame >= *overrides_p) && ((unsigned int) frame <= *(overrides_p+1)))
-                        {
-                                if (*(overrides_p+3) == 'v')
-                                {
-                                        vthresh = *(overrides_p+2);
-                                }
-                        }
-                        // Next override line.
-                        overrides_p += 4;
-                }
-        }
-#endif
-        // Check the match for progressive versus interlaced.
-        if (post != POST_NONE)
-        {
-                if (chosen == P) vmetric = pblock;
-                else if (chosen == C) vmetric = cblock;
-                else if (chosen == N) vmetric = npblock;
-
-                if (found == false && back == BACK_ON_COMBED && vmetric > bthresh && p < lowest)
-                {
-                        // Backward match.
-                        vmetric = pblock;
-                        chosen = P;
-                        inpattern = false;
-                        mismatch = 100;
-                }
-                if (vmetric > vthresh)
-                {
-                        // After field matching and pattern guidance the frame is still combed.
-                        film = false;
-                        if (found == false && (post == POST_FULL_NOMATCH || post == POST_FULL_NOMATCH_MAP))
-                        {
-                                chosen = C;
-                                vmetric = cblock;
-                                inpattern = false;
-                                mismatch = 100;
-                        }
-                }
-        }
-        vthresh = vthresh_saved;
-
-        // Setup strings for debug info.
-        if (inpattern == true && override == false) strcpy(status, "[in-pattern]");
-        else if (inpattern == true && override == true) strcpy(status, "[in-pattern*]");
-        else strcpy(status, "[out-of-pattern]");
-
-        // Assemble and output the reconstructed frame according to the final match.
-        dstp = dst->GetWritePtr(PLANAR_Y);
-//    if (vi.IsYV12())
-        {
-                dstpU = dst->GetWritePtr(PLANAR_U);
-                dstpV = dst->GetWritePtr(PLANAR_V);
-        }
-        if (chosen == N)
-        {
-                // The best match was with the next frame.
-                if (tff == true)
-                {
-                        BitBlt(dstp, 2 * dpitch, fnrp, 2 * pitch, w, hover2);
-                        BitBlt(dstp + dpitch, 2 * dpitch, fcrp + pitch, 2 * pitch, w, hover2);
-                        //if (vi.IsYV12())
-                        {
-                                BitBlt(dstpU, dpitch, fnrpU, pitch, w/2, h/4);
-                                BitBlt(dstpV, dpitch, fnrpV, pitch, w/2, h/4);
-                                BitBlt(dstpU + dpitch/2, dpitch, fcrpU + pitch/2, pitch, w/2, h/4);
-                                BitBlt(dstpV + dpitch/2, dpitch, fcrpV + pitch/2, pitch, w/2, h/4);
-                        }
-                }
-                else
-                {
-                        BitBlt(dstp, 2 * dpitch, fcrp, 2 * pitch, w, hplus1over2);
-                        BitBlt(dstp + dpitch, 2 * dpitch, fnrp + pitch, 2 * pitch, w, hover2);
-                        //if (vi.IsYV12())
-                        {
-                                BitBlt(dstpU, dpitch, fcrpU, pitch, w/2, h/4);
-                                BitBlt(dstpV, dpitch, fcrpV, pitch, w/2, h/4);
-                                BitBlt(dstpU + dpitch/2, dpitch, fnrpU + pitch/2, pitch, w/2, h/4);
-                                BitBlt(dstpV + dpitch/2, dpitch, fnrpV + pitch/2, pitch, w/2, h/4);
-                        }
-                }
-        }
-        else if (chosen == C)
-        {
-                // The best match was with the current frame.
-                BitBlt(dstp, 2 * dpitch, fcrp, 2 * pitch, w, hplus1over2);
-                BitBlt(dstp + dpitch, 2 * dpitch, fcrp + pitch, 2 * pitch, w, hover2);
-                //if (vi.IsYV12())
-                {
-                        BitBlt(dstpU, dpitch, fcrpU, pitch, w/2, h/4);
-                        BitBlt(dstpV, dpitch, fcrpV, pitch, w/2, h/4);
-                        BitBlt(dstpU + dpitch/2, dpitch, fcrpU + pitch/2, pitch, w/2, h/4);
-                        BitBlt(dstpV + dpitch/2, dpitch, fcrpV + pitch/2, pitch, w/2, h/4);
-                }
-        }
-        else if (tff == false)
-        {
-                // The best match was with the previous frame.
-                BitBlt(dstp, 2 * dpitch, fprp, 2 * pitch, w, hplus1over2);
-                BitBlt(dstp + dpitch, 2 * dpitch, fcrp + pitch, 2 * pitch, w, hover2);
-               // if (vi.IsYV12())
-                {
-                        BitBlt(dstpU, dpitch, fprpU, pitch, w/2, h/4);
-                        BitBlt(dstpV, dpitch, fprpV, pitch, w/2, h/4);
-                        BitBlt(dstpU + dpitch/2, dpitch, fcrpU + pitch/2, pitch, w/2, h/4);
-                        BitBlt(dstpV + dpitch/2, dpitch, fcrpV + pitch/2, pitch, w/2, h/4);
-                }
-        }
-        else
-        {
-                // The best match was with the previous frame.
-                BitBlt(dstp, 2 * dpitch, fcrp, 2 * pitch, w, hplus1over2);
-                BitBlt(dstp + dpitch, 2 * dpitch, fprp + pitch, 2 * pitch, w, hover2);
-               // if (vi.IsYV12())
-                {
-                        BitBlt(dstpU, dpitch, fcrpU, pitch, w/2, h/4);
-                        BitBlt(dstpV, dpitch, fcrpV, pitch, w/2, h/4);
-                        BitBlt(dstpU + dpitch/2, dpitch, fprpU + pitch/2, pitch, w/2, h/4);
-                        BitBlt(dstpV + dpitch/2, dpitch, fprpV + pitch/2, pitch, w/2, h/4);
-                }
-        }
-        if (guide != GUIDE_NONE) PutChosen(frame, chosen);
-
-        /* Check for manual overrides of the deinterlacing. */
-#if 0
-        overrides_p = overrides;
-        force = 0;
-        if (overrides_p != NULL)
-        {
-                while (*overrides_p < 0xffffffff)
-                {
-                        // Is the frame in range...
-                        if (((unsigned int) frame >= *overrides_p) && ((unsigned int) frame <= *(overrides_p+1)) &&
-                                // and is it a single specifier...
-                                (*(overrides_p+2) == 0) &&
-                                // and is it a deinterlacing specifier?
-                                (*(overrides_p+3) == '+' || *(overrides_p+3) == '-'))
-                        {
-                                // Yes, load the specifier and stop parsing.
-                                overrides_p += 3;
-                                force = *overrides_p;
-                                break;
-                        }
-                        // Next specification record.
-                        overrides_p += 4;
-                }
-        }
-#endif
-        // Do postprocessing if enabled and required for this frame.
-        if (post == POST_NONE || post == POST_METRICS)
-        {
-                if (force == '+') film = false;
-                else if (force == '-') film = true;
-        }
-        else if ((force == '+') ||
-                ((post == POST_FULL || post == POST_FULL_MAP || post == POST_FULL_NOMATCH || post == POST_FULL_NOMATCH_MAP)
-                         && (film == false && force != '-')))
-        {
-                unsigned char *dstpp, *dstpn;
-                int v1, v2, z;
-
-                if (blend == true)
-                {
-                        // Blend mode.
-                        final = data; //env->NewVideoFrame(vi);
-                        // Do first and last lines.
-                        finalp = final->GetWritePtr(PLANAR_Y);
-                        dstp = dst->GetWritePtr(PLANAR_Y);
-                        dstpn = dstp + dpitch;
-                        for (x = 0; x < w; x++)
-                        {
-                                finalp[x] = (((int)dstp[x] + (int)dstpn[x]) >> 1);
-                        }
-                        finalp = final->GetWritePtr(PLANAR_Y) + (h-1)*dpitch;
-                        dstp = dst->GetWritePtr(PLANAR_Y) + (h-1)*dpitch;
-                        dstpp = dstp - dpitch;
-                        for (x = 0; x < w; x++)
-                        {
-                                finalp[x] = (((int)dstp[x] + (int)dstpp[x]) >> 1);
-                        }
-                        // Now do the rest.
-                        dstp = dst->GetWritePtr(PLANAR_Y) + dpitch;
-                        dstpp = dstp - dpitch;
-                        dstpn = dstp + dpitch;
-                        finalp = final->GetWritePtr(PLANAR_Y) + dpitch;
-                        for (y = 1; y < h - 1; y++)
-                        {
-                                for (x = 0; x < w; x++)
-                                {
-                                        v1 = (int) dstp[x] - dthresh;
-                                        if (v1 < 0) v1 = 0; 
-                                        v2 = (int) dstp[x] + dthresh;
-                                        if (v2 > 235) v2 = 235; 
-                                        if ((v1 > dstpp[x] && v1 > dstpn[x]) || (v2 < dstpp[x] && v2 < dstpn[x]))
-                                        {
-                                                if (post == POST_FULL_MAP || post == POST_FULL_NOMATCH_MAP)
-                                                {
-                                                        if (0) //(vi.IsYUY2())
-                                                        {
-                                                                if (x & 1) finalp[x] = 128;
-                                                                else finalp[x] = 235;
-                                                        }
-                                                        else
-                                                        {
-                                                                finalp[x] = 235;
-                                                        }
-                                                }
-                                                else
-                                                        finalp[x] = ((int)dstpp[x] + (int)dstpn[x] + (int)dstp[x] + (int)dstp[x]) >> 2;
-                                        }
-                                        else finalp[x] = dstp[x];
-                                }
-                                finalp += dpitch;
-                                dstp += dpitch;
-                                dstpp += dpitch;
-                                dstpn += dpitch;
-                        }
-
-                      //  if (vi.IsYV12())
-                        {
-                                // Chroma planes.
-                                for (z = 0; z < 2; z++)
-                                {
-                                        if (z == 0)
-                                        {
-                                                // Do first and last lines.
-                                                finalp = final->GetWritePtr(PLANAR_U);
-                                                dstp = dst->GetWritePtr(PLANAR_U);
-                                                dstpn = dstp + dpitch/2;
-                                                for (x = 0; x < wover2; x++)
-                                                {
-                                                        finalp[x] = (((int)dstp[x] + (int)dstpn[x]) >> 1);
-                                                }
-                                                finalp = final->GetWritePtr(PLANAR_U) + (hover2-1)*dpitch/2;
-                                                dstp = dst->GetWritePtr(PLANAR_U) + (hover2-1)*dpitch/2;
-                                                dstpp = dstp - dpitch/2;
-                                                for (x = 0; x < wover2; x++)
-                                                {
-                                                        finalp[x] = (((int)dstp[x] + (int)dstpp[x]) >> 1);
-                                                }
-                                                // Now do the rest.
-                                                finalp = final->GetWritePtr(PLANAR_U) + dpitch/2;
-                                                dstp = dst->GetWritePtr(PLANAR_U) + dpitch/2;
-                                        }
-                                        else
-                                        {
-                                                // Do first and last lines.
-                                                finalp = final->GetWritePtr(PLANAR_V);
-                                                dstp = dst->GetWritePtr(PLANAR_V);
-                                                dstpn = dstp + dpitch/2;
-                                                for (x = 0; x < wover2; x++)
-                                                {
-                                                        finalp[x] = (((int)dstp[x] + (int)dstpn[x]) >> 1);
-                                                }
-                                                finalp = final->GetWritePtr(PLANAR_V) + (hover2-1)*dpitch/2;
-                                                dstp = dst->GetWritePtr(PLANAR_V) + (hover2-1)*dpitch/2;
-                                                dstpp = dstp - dpitch/2;
-                                                for (x = 0; x < wover2; x++)
-                                                {
-                                                        finalp[x] = (((int)dstp[x] + (int)dstpp[x]) >> 1);
-                                                }
-                                                // Now do the rest.
-                                                finalp = final->GetWritePtr(PLANAR_V) + dpitch/2;
-                                                dstp = dst->GetWritePtr(PLANAR_V) + dpitch/2;
-                                        }
-                                        dstpp = dstp - dpitch/2;
-                                        dstpn = dstp + dpitch/2;
-                                        for (y = 1; y < hover2 - 1; y++)
-                                        {
-                                                for (x = 0; x < wover2; x++)
-                                                {
-                                                        v1 = (int) dstp[x] - dthresh;
-                                                        if (v1 < 0) v1 = 0; 
-                                                        v2 = (int) dstp[x] + dthresh;
-                                                        if (v2 > 235) v2 = 235; 
-                                                        if ((v1 > dstpp[x] && v1 > dstpn[x]) || (v2 < dstpp[x] && v2 < dstpn[x]))
-                                                        {
-                                                                if (post == POST_FULL_MAP || post == POST_FULL_NOMATCH_MAP)
-                                                                {
-                                                                        finalp[x] = 128;
-                                                                }
-                                                                else
-                                                                        finalp[x] = ((int)dstpp[x] + (int)dstpn[x] + (int)dstp[x] + (int)dstp[x]) >> 2;
-                                                        }
-                                                        else finalp[x] = dstp[x];
-                                                }
-                                                finalp += dpitch/2;
-                                                dstp += dpitch/2;
-                                                dstpp += dpitch/2;
-                                                dstpn += dpitch/2;
-                                        }
-                                }
-                        }
-                        if (show == true) Show(final, frame);
-                        if (debug == true) Debug(frame);
-                        if (hints == true) WriteHints(final->GetWritePtr(PLANAR_Y), film, inpattern);
-                       // return final;
-                        vidCache->unlockAll();
-                        return 1;
-                }
-
-                // Interpolate mode.
-                // Luma plane.
-                dstp = dst->GetWritePtr(PLANAR_Y) + dpitch;
-                dstpp = dstp - dpitch;
-                dstpn = dstp + dpitch;
-                for (y = 1; y < h - 1; y+=2)
-                {
-                        for (x = 0; x < w; x++)
-                        {
-                                v1 = (int) dstp[x] - dthresh;
-                                if (v1 < 0) v1 = 0; 
-                                v2 = (int) dstp[x] + dthresh;
-                                if (v2 > 235) v2 = 235; 
-                                if ((v1 > dstpp[x] && v1 > dstpn[x]) || (v2 < dstpp[x] && v2 < dstpn[x]))
-                                {
-                                        if (post == POST_FULL_MAP || post == POST_FULL_NOMATCH_MAP)
-                                        {
-                                                if(0) // (vi.IsYUY2())
-                                                {
-                                                        if (x & 1) dstp[x] = 128;
-                                                        else dstp[x] = 235;
-                                                }
-                                                else
-                                                {
-                                                        dstp[x] = 235;
-                                                }
-                                        }
-                                        else
-                                                dstp[x] = (dstpp[x] + dstpn[x]) >> 1;
-                                }
-                        }
-                        dstp += 2*dpitch;
-                        dstpp += 2*dpitch;
-                        dstpn += 2*dpitch;
-                }
-
-               // if (vi.IsYV12())
-                {
-                        // Chroma planes.
-                        for (z = 0; z < 2; z++)
-                        {
-                                if (z == 0) dstp = dst->GetWritePtr(PLANAR_U) + dpitch/2;
-                                else dstp = dst->GetWritePtr(PLANAR_V) + dpitch/2;
-                                dstpp = dstp - dpitch/2;
-                                dstpn = dstp + dpitch/2;
-                                for (y = 1; y < hover2 - 1; y+=2)
-                                {
-                                        for (x = 0; x < wover2; x++)
-                                        {
-                                                v1 = (int) dstp[x] - dthresh;
-                                                if (v1 < 0) v1 = 0; 
-                                                v2 = (int) dstp[x] + dthresh;
-                                                if (v2 > 235) v2 = 235; 
-                                                if ((v1 > dstpp[x] && v1 > dstpn[x]) || (v2 < dstpp[x] && v2 < dstpn[x]))
-                                                {
-                                                        if (post == POST_FULL_MAP || post == POST_FULL_NOMATCH_MAP)
-                                                        {
-                                                                dstp[x] = 128;
-                                                        }
-                                                        else
-                                                                dstp[x] = (dstpp[x] + dstpn[x]) >> 1;
-                                                }
-                                        }
-                                        dstp += dpitch;
-                                        dstpp += dpitch;
-                                        dstpn += dpitch;
-                                }
-                        }
-                }
-        }
-
-        if (show == true) Show(dst, frame);
-        if (debug == true) Debug(frame);
-        if (hints == true) WriteHints(dst->GetWritePtr(PLANAR_Y), film, inpattern);
-        vidCache->unlockAll();
-        //return dst;
-        return 1;
-}
-void Telecide::CalculateMetrics(int frame, unsigned char *fcrp, unsigned char *fcrpU, unsigned char *fcrpV,
-                                                                        unsigned char *fprp, unsigned char *fprpU, unsigned char *fprpV)
-{
-        int x, y, p, c, tmp1, tmp2, skip;
-        bool vc;
-    unsigned char *currbot0, *currbot2, *prevbot0, *prevbot2;
-        unsigned char *prevtop0, *prevtop2, *prevtop4, *currtop0, *currtop2, *currtop4;
-        unsigned char *a0, *a2, *b0, *b2, *b4;
-        unsigned int diff, index;
-#define T 4
-
-        /* Clear the block sums. */
-        for (y = 0; y < yblocks; y++)
-        {
-                for (x = 0; x < xblocks; x++)
-                {
-#ifdef WINDOWED_MATCH
-                        matchp[y*xblocks+x] = 0;
-                        matchc[y*xblocks+x] = 0;
-#endif
-                        sump[y*xblocks+x] = 0;
-                        sumc[y*xblocks+x] = 0;
-                }
-        }
-
-        /* Find the best field match. Subsample the frames for speed. */
-        currbot0  = fcrp + pitch;
-        currbot2  = fcrp + 3 * pitch;
-        currtop0 = fcrp;
-        currtop2 = fcrp + 2 * pitch;
-        currtop4 = fcrp + 4 * pitch;
-        prevbot0  = fprp + pitch;
-        prevbot2  = fprp + 3 * pitch;
-        prevtop0 = fprp;
-        prevtop2 = fprp + 2 * pitch;
-        prevtop4 = fprp + 4 * pitch;
-        if (tff == true)
-        {
-                a0 = prevbot0;
-                a2 = prevbot2;
-                b0 = currtop0;
-                b2 = currtop2;
-                b4 = currtop4;
-        }
-        else
-        {
-                a0 = currbot0;
-                a2 = currbot2;
-                b0 = prevtop0;
-                b2 = prevtop2;
-                b4 = prevtop4;
-        }
-        p = c = 0;
-
-        // Calculate the field match and film/video metrics.
-        //if (vi.IsYV12()) skip = 1;
-        if(1) skip=1;
-        else skip = 1 + (chroma == false);
-        for (y = 0, index = 0; y < h - 4; y+=4)
-        {
-                /* Exclusion band. Good for ignoring subtitles. */
-                if (y0 == y1 || y < y0 || y > y1)
-                {
-                        for (x = 0; x < w;)
-                        {
-                                if (1) //vi.IsYV12())
-                                        index = (y/BLKSIZE)*xblocks + x/BLKSIZE;
-                                else
-                                        index = (y/BLKSIZE)*xblocks + x/BLKSIZE_TIMES2;
-
-                                // Test combination with current frame.
-                                tmp1 = ((long)currbot0[x] + (long)currbot2[x]);
-//                              diff = abs((long)currtop0[x] - (tmp1 >> 1));
-                                diff = abs((((long)currtop0[x] + (long)currtop2[x] + (long)currtop4[x])) - (tmp1 >> 1) - tmp1);
-                                if (diff > nt)
-                                {
-                                        c += diff;
-#ifdef WINDOWED_MATCH
-                                        matchc[index] += diff;
-#endif
-                                }
-
-                                tmp1 = currbot0[x] + T;
-                                tmp2 = currbot0[x] - T;
-                                vc = (tmp1 < currtop0[x] && tmp1 < currtop2[x]) ||
-                                         (tmp2 > currtop0[x] && tmp2 > currtop2[x]);
-                                if (vc)
-                                {
-                                        sumc[index]++;
-                                }
-
-                                // Test combination with previous frame.
-                                tmp1 = ((long)a0[x] + (long)a2[x]);
-                                diff = abs((((long)b0[x] + (long)b2[x] + (long)b4[x])) - (tmp1 >> 1) - tmp1);
-                                if (diff > nt)
-                                {
-                                        p += diff;
-#ifdef WINDOWED_MATCH
-                                        matchp[index] += diff;
-#endif
-                                }
-
-                                tmp1 = a0[x] + T;
-                                tmp2 = a0[x] - T;
-                                vc = (tmp1 < b0[x] && tmp1 < b2[x]) ||
-                                         (tmp2 > b0[x] && tmp2 > b2[x]);
-                                if (vc)
-                                {
-                                        sump[index]++;
-                                }
-
-                                x += skip;
-                                if (!(x&3)) x += 4;
-                        }
-                }
-                currbot0 += pitchtimes4;
-                currbot2 += pitchtimes4;
-                currtop0 += pitchtimes4;
-                currtop2 += pitchtimes4;
-                currtop4 += pitchtimes4;
-                a0               += pitchtimes4;
-                a2               += pitchtimes4;
-                b0               += pitchtimes4;
-                b2               += pitchtimes4;
-                b4               += pitchtimes4;
-        }
-
-       // if (vi.IsYV12() && chroma == true)
-        if ( chroma == true)
-        {
-                int z;
-
-                for (z = 0; z < 2; z++)
-                {
-                        // Do the same for the U plane.
-                        if (z == 0)
-                        {
-                                currbot0  = fcrpU + pitchover2;
-                                currbot2  = fcrpU + 3 * pitchover2;
-                                currtop0 = fcrpU;
-                                currtop2 = fcrpU + 2 * pitchover2;
-                                currtop4 = fcrpU + 4 * pitchover2;
-                                prevbot0  = fprpU + pitchover2;
-                                prevbot2  = fprpU + 3 * pitchover2;
-                                prevtop0 = fprpU;
-                                prevtop2 = fprpU + 2 * pitchover2;
-                                prevtop4 = fprpU + 4 * pitchover2;
-                        }
-                        else
-                        {
-                                currbot0  = fcrpV + pitchover2;
-                                currbot2  = fcrpV + 3 * pitchover2;
-                                currtop0 = fcrpV;
-                                currtop2 = fcrpV + 2 * pitchover2;
-                                currtop4 = fcrpV + 4 * pitchover2;
-                                prevbot0  = fprpV + pitchover2;
-                                prevbot2  = fprpV + 3 * pitchover2;
-                                prevtop0 = fprpV;
-                                prevtop2 = fprpV + 2 * pitchover2;
-                                prevtop4 = fprpV + 4 * pitchover2;
-                        }
-                        if (tff == true)
-                        {
-                                a0 = prevbot0;
-                                a2 = prevbot2;
-                                b0 = currtop0;
-                                b2 = currtop2;
-                                b4 = currtop4;
-                        }
-                        else
-                        {
-                                a0 = currbot0;
-                                a2 = currbot2;
-                                b0 = prevtop0;
-                                b2 = prevtop2;
-                                b4 = prevtop4;
-                        }
-
-                        for (y = 0, index = 0; y < hover2 - 4; y+=4)
-                        {
-                                /* Exclusion band. Good for ignoring subtitles. */
-                                if (y0 == y1 || y < y0/2 || y > y1/2)
-                                {
-                                        for (x = 0; x < wover2;)
-                                        {
-                                                if (1) //vi.IsYV12())
-                                                        index = (y/BLKSIZE)*xblocks + x/BLKSIZE;
-                                                else
-                                                        index = (y/BLKSIZE)*xblocks + x/BLKSIZE_TIMES2;
-
-                                                // Test combination with current frame.
-                                                tmp1 = ((long)currbot0[x] + (long)currbot2[x]);
-                                                diff = abs((((long)currtop0[x] + (long)currtop2[x] + (long)currtop4[x])) - (tmp1 >> 1) - tmp1);
-                                                if (diff > nt)
-                                                {
-                                                        c += diff;
-#ifdef WINDOWED_MATCH
-                                                        matchc[index] += diff;
-#endif
-                                                }
-
-                                                tmp1 = currbot0[x] + T;
-                                                tmp2 = currbot0[x] - T;
-                                                vc = (tmp1 < currtop0[x] && tmp1 < currtop2[x]) ||
-                                                         (tmp2 > currtop0[x] && tmp2 > currtop2[x]);
-                                                if (vc)
-                                                {
-                                                        sumc[index]++;
-                                                }
-
-                                                // Test combination with previous frame.
-                                                tmp1 = ((long)a0[x] + (long)a2[x]);
-                                                diff = abs((((long)b0[x] + (long)b2[x] + (long)b4[x])) - (tmp1 >> 1) - tmp1);
-                                                if (diff > nt)
-                                                {
-                                                        p += diff;
-#ifdef WINDOWED_MATCH
-                                                        matchp[index] += diff;
-#endif
-                                                }
-
-                                                tmp1 = a0[x] + T;
-                                                tmp2 = a0[x] - T;
-                                                vc = (tmp1 < b0[x] && tmp1 < b2[x]) ||
-                                                         (tmp2 > b0[x] && tmp2 > b2[x]);
-                                                if (vc)
-                                                {
-                                                        sump[index]++;
-                                                }
-
-                                                x ++;
-                                                if (!(x&3)) x += 4;
-                                        }
-                                }
-                                currbot0 += 4*pitchover2;
-                                currbot2 += 4*pitchover2;
-                                currtop0 += 4*pitchover2;
-                                currtop2 += 4*pitchover2;
-                                currtop4 += 4*pitchover2;
-                                a0               += 4*pitchover2;
-                                a2               += 4*pitchover2;
-                                b0               += 4*pitchover2;
-                                b2               += 4*pitchover2;
-                                b4               += 4*pitchover2;
-                        }
-                }
-        }
-
-        // Now find the blocks that have the greatest differences.
-#ifdef WINDOWED_MATCH
-        highest_matchp = 0;
-        for (y = 0; y < yblocks; y++)
-        {
-                for (x = 0; x < xblocks; x++)
-                {
-if (frame == 45 && matchp[y * xblocks + x] > 2500)
-{
-        sprintf(buf, "%d/%d = %d\n", x, y, matchp[y * xblocks + x]);
-        OutputDebugString(buf);
-}
-                        if (matchp[y * xblocks + x] > highest_matchp)
-                        {
-                                highest_matchp = matchp[y * xblocks + x];
-                        }
-                }
-        }
-        highest_matchc = 0;
-        for (y = 0; y < yblocks; y++)
-        {
-                for (x = 0; x < xblocks; x++)
-                {
-if (frame == 44 && matchc[y * xblocks + x] > 2500)
-{
-        sprintf(buf, "%d/%d = %d\n", x, y, matchc[y * xblocks + x]);
-        OutputDebugString(buf);
-}
-                        if (matchc[y * xblocks + x] > highest_matchc)
-                        {
-                                highest_matchc = matchc[y * xblocks + x];
-                        }
-                }
-        }
-#endif
-        if (post != POST_NONE)
-        {
-                highest_sump = 0;
-                for (y = 0; y < yblocks; y++)
-                {
-                        for (x = 0; x < xblocks; x++)
-                        {
-                                if (sump[y * xblocks + x] > highest_sump)
-                                {
-                                        highest_sump = sump[y * xblocks + x];
-                                }
-                        }
-                }
-                highest_sumc = 0;
-                for (y = 0; y < yblocks; y++)
-                {
-                        for (x = 0; x < xblocks; x++)
-                        {
-                                if (sumc[y * xblocks + x] > highest_sumc)
-                                {
-                                        highest_sumc = sumc[y * xblocks + x];
-                                }
-                        }
-                }
-        }
-#ifdef WINDOWED_MATCH
-        CacheInsert(frame, highest_matchp, highest_sump, highest_matchc, highest_sumc);
-#else
-        CacheInsert(frame, p, highest_sump, c, highest_sumc);
-#endif
-}
-bool Telecide::PredictHardYUY2(int frame, unsigned int *predicted, unsigned int *predicted_metric)
-        {
-                // Look for pattern in the actual delivered matches of the previous cycle of frames.
-                // If a pattern is found, use that to predict the current match.
-                if (guide == GUIDE_22)
-                {
-                        if (cache[(frame-cycle)%CACHE_SIZE  ].chosen == 0xff ||
-                                cache[(frame-cycle+1)%CACHE_SIZE].chosen == 0xff)
-                                return false;
-                        switch ((cache[(frame-cycle)%CACHE_SIZE  ].chosen << 4) +
-                                        (cache[(frame-cycle+1)%CACHE_SIZE].chosen))
-                        {
-                        case 0x11:
-                                *predicted = C;
-                                *predicted_metric = cache[frame%CACHE_SIZE].metrics[C];
-                                break;
-                        case 0x22:
-                                *predicted = N;
-                                *predicted_metric = cache[frame%CACHE_SIZE].metrics[N];
-                                break;
-                        default: return false;
-                        }
-                }
-                else if (guide == GUIDE_32)
-                {
-                        if (cache[(frame-cycle)%CACHE_SIZE  ].chosen == 0xff ||
-                                cache[(frame-cycle+1)%CACHE_SIZE].chosen == 0xff ||
-                                cache[(frame-cycle+2)%CACHE_SIZE].chosen == 0xff ||
-                                cache[(frame-cycle+3)%CACHE_SIZE].chosen == 0xff ||
-                                cache[(frame-cycle+4)%CACHE_SIZE].chosen == 0xff)
-                                return false;
-
-                        switch ((cache[(frame-cycle)%CACHE_SIZE  ].chosen << 16) +
-                                        (cache[(frame-cycle+1)%CACHE_SIZE].chosen << 12) +
-                                        (cache[(frame-cycle+2)%CACHE_SIZE].chosen <<  8) +
-                                        (cache[(frame-cycle+3)%CACHE_SIZE].chosen <<  4) +
-                                        (cache[(frame-cycle+4)%CACHE_SIZE].chosen))
-                        {
-                        case 0x11122:
-                        case 0x11221:
-                        case 0x12211:
-                        case 0x12221: 
-                        case 0x21122: 
-                        case 0x11222: 
-                                *predicted = C;
-                                *predicted_metric = cache[frame%CACHE_SIZE].metrics[C];
-                                break;
-                        case 0x22111:
-                        case 0x21112:
-                        case 0x22112: 
-                        case 0x22211: 
-                                *predicted = N;
-                                *predicted_metric = cache[frame%CACHE_SIZE].metrics[N];
-                                break;
-                        default: return false;
-                        }
-                }
-                else if (guide == GUIDE_32322)
-                {
-                        if (cache[(frame-cycle)%CACHE_SIZE  ].chosen == 0xff ||
-                                cache[(frame-cycle+1)%CACHE_SIZE].chosen == 0xff ||
-                                cache[(frame-cycle+2)%CACHE_SIZE].chosen == 0xff ||
-                                cache[(frame-cycle+3)%CACHE_SIZE].chosen == 0xff ||
-                                cache[(frame-cycle+4)%CACHE_SIZE].chosen == 0xff ||
-                                cache[(frame-cycle+5)%CACHE_SIZE].chosen == 0xff)
-                                return false;
-
-                        switch ((cache[(frame-cycle)%CACHE_SIZE  ].chosen << 20) +
-                                        (cache[(frame-cycle+1)%CACHE_SIZE].chosen << 16) +
-                                        (cache[(frame-cycle+2)%CACHE_SIZE].chosen << 12) +
-                                        (cache[(frame-cycle+3)%CACHE_SIZE].chosen <<  8) +
-                                        (cache[(frame-cycle+4)%CACHE_SIZE].chosen <<  4) +
-                                        (cache[(frame-cycle+5)%CACHE_SIZE].chosen))
-                        {
-                        case 0x111122:
-                        case 0x111221:
-                        case 0x112211:
-                        case 0x122111:
-                        case 0x111222: 
-                        case 0x112221:
-                        case 0x122211:
-                        case 0x222111: 
-                                *predicted = C;
-                                *predicted_metric = cache[frame%CACHE_SIZE].metrics[C];
-                                break;
-                        case 0x221111:
-                        case 0x211112:
-
-                        case 0x221112: 
-                        case 0x211122: 
-                                *predicted = N;
-                                *predicted_metric = cache[frame%CACHE_SIZE].metrics[N];
-                                break;
-                        default: return false;
-                        }
-                }
-#ifdef DEBUG_PATTERN_GUIDANCE
-                sprintf(buf, "%d: HARD: predicted = %d\n", frame, *predicted);
-                OutputDebugString(buf);
-#endif
-                return true;
-        }
-
-struct PREDICTION *Telecide::PredictSoftYUY2(int frame)
-        {
-                // Use heuristics to look forward for a match.
-                int i, j, y, c, n, phase;
-                unsigned int metric;
-
-                pred[0].metric = 0xffffffff;
-                if (frame < 0 || frame > _info.nb_frames - 1 - cycle) return pred;
-
-                // Look at the next cycle of frames.
-                for (y = frame + 1; y <= frame + cycle; y++)
-                {
-                        // Look for a frame where the current and next match values are
-                        // very close. Those are candidates to predict the phase, because
-                        // that condition should occur only once per cycle. Store the candidate
-                        // phases and predictions in a list sorted by goodness. The list will
-                        // be used by the caller to try the phases in order.
-                        c = cache[y%CACHE_SIZE].metrics[C]; 
-                        n = cache[y%CACHE_SIZE].metrics[N];
-                        if (c == 0) c = 1;
-                        metric = (100 * abs (c - n)) / c;
-                        phase = y % cycle;
-                        if (metric < 5)
-                        {
-                                // Place the new candidate phase in sorted order in the list.
-                                // Find the insertion point.
-                                i = 0;
-                                while (metric > pred[i].metric) i++;
-                                // Find the end-of-list marker.
-                                j = 0;
-                                while (pred[j].metric != 0xffffffff) j++;
-                                // Shift all items below the insertion point down by one to make
-                                // room for the insertion.
-                                j++;
-                                for (; j > i; j--)
-                                {
-                                        pred[j].metric = pred[j-1].metric;
-                                        pred[j].phase = pred[j-1].phase;
-                                        pred[j].predicted = pred[j-1].predicted;
-                                        pred[j].predicted_metric = pred[j-1].predicted_metric;
-                                }
-                                // Insert the new candidate data.
-                                pred[j].metric = metric;
-                                pred[j].phase = phase;
-                                if (guide == GUIDE_32)
-                                {
-                                        switch ((frame % cycle) - phase)
-                                        {
-                                        case -4: pred[j].predicted = N; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[N]; break; 
-                                        case -3: pred[j].predicted = N; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[N]; break; 
-                                        case -2: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
-                                        case -1: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
-                                        case  0: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
-                                        case +1: pred[j].predicted = N; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[N]; break; 
-                                        case +2: pred[j].predicted = N; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[N]; break; 
-                                        case +3: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
-                                        case +4: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
-                                        }
-                                }
-                                else if (guide == GUIDE_32322)
-                                {
-                                        switch ((frame % cycle) - phase)
-                                        {
-                                        case -5: pred[j].predicted = N; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[N]; break; 
-                                        case -4: pred[j].predicted = N; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[N]; break; 
-                                        case -3: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
-                                        case -2: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
-                                        case -1: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
-                                        case  0: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
-                                        case +1: pred[j].predicted = N; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[N]; break; 
-                                        case +2: pred[j].predicted = N; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[N]; break; 
-                                        case +3: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
-                                        case +4: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
-                                        case +5: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
-                                        }
-                                }
-                        }
-#ifdef DEBUG_PATTERN_GUIDANCE
-                        sprintf(buf,"%d: metric = %d phase = %d\n", frame, metric, phase);
-                        OutputDebugString(buf);
-#endif
-                }
-                return pred;
-        }
-

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDecTelecide.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDecTelecide.h	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDecTelecide.h	2007-01-13 16:37:32 UTC (rev 2721)
@@ -1,143 +0,0 @@
-/*
-	Telecide plugin for Avisynth -- recovers original progressive
-	frames from  telecined streams. The filter operates by matching
-	fields and automatically adapts to phase/pattern changes.
-
-	Copyright (C) 2003 Donald A. Graft
-
-	This program is free software; you can redistribute it and/or modify
-	it under the terms of the GNU General Public License as published by
-	the Free Software Foundation.
-
-	This program is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-	GNU General Public License for more details.
-
-	You should have received a copy of the GNU General Public License
-	along with this program; if not, write to the Free Software
-	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-*/
-#include "ADM_video/ADM_cache.h"
-#undef DEBUG_PATTERN_GUIDANCE
-
-#undef WINDOWED_MATCH
-
-#define MAX_CYCLE 6
-#define BLKSIZE 24
-#define BLKSIZE_TIMES2 (2 * BLKSIZE)
-#define GUIDE_NONE 0
-#define GUIDE_32 1
-#define GUIDE_22 2
-#define GUIDE_32322 3
-#define AHEAD 0
-#define BEHIND 1
-#define POST_NONE 0
-#define POST_METRICS 1
-#define POST_FULL 2
-#define POST_FULL_MAP 3
-#define POST_FULL_NOMATCH 4
-#define POST_FULL_NOMATCH_MAP 5
-#define CACHE_SIZE 100000
-#define P 0
-#define C 1
-#define N 2
-#define PBLOCK 3
-#define CBLOCK 4
-
-#define NO_BACK 0
-#define BACK_ON_COMBED 1
-#define ALWAYS_BACK 2
-
-#define OutputDebugString(x) aprintf("%s\n",x)
-typedef uint8_t* PVideoFrame ;
-
-
-struct CACHE_ENTRY
-{
-	unsigned int frame;
-	unsigned int metrics[5];
-	unsigned int chosen;
-};
-
-struct PREDICTION
-{
-	unsigned int metric;
-	unsigned int phase;
-	unsigned int predicted;
-	unsigned int predicted_metric;
-};
-
-#define GETFRAME(g, fp) { int GETFRAMEf; uint32_t len,flags;GETFRAMEf = (g); fp=NULL;if (GETFRAMEf < 0) GETFRAMEf = 0; 	else if (GETFRAMEf >= _info.nb_frames) GETFRAMEf = _info.nb_frames - 1; fp=vidCache->getImage(GETFRAMEf); }
-#include "ADM_video/ADM_vidDecTel_param.h"
-class Telecide : public AVDMGenericVideoStream
-{
-private:
-	TelecideParam *_param;		
-	bool tff;	
-	uint32_t _lastFrame;	
-	int pitch, dpitch, pitchover2, pitchtimes4;
-	int w, h, wover2, hover2, hplus1over2, hminus2;
-	int xblocks, yblocks;
-#ifdef WINDOWED_MATCH
-	unsigned int *matchc, *matchp, highest_matchc, highest_matchp;
-#endif
-	unsigned int *sumc, *sump, highest_sumc, highest_sump;
-	int vmetric;
-	
-	bool film, override, inpattern, found;
-	int force;
-
-	
-	int chosen;
-	unsigned int p, c, pblock, cblock, lowest, predicted, predicted_metric;
-	unsigned int np, nc, npblock, ncblock;
-	float mismatch;
-	int  x, y;
-	
-	bool hard;
-	char status[80];
-
-	// Metrics cache.
-	struct CACHE_ENTRY *cache;
-
-	// Pattern guidance data.
-	int cycle;
-	struct PREDICTION pred[MAX_CYCLE+1];
-
-	// For output message formatting.
-	char buf[255];
-	
-	VideoCache	*vidCache;
-
-public:
-	
-	void CalculateMetrics(int n, unsigned char *crp, unsigned char *crpU, unsigned char *crpV, 
-				unsigned char *prp, unsigned char *prpU, unsigned char *prpV);
-	void Show(ADMImage *dst, int frame);
-	void Debug(int frame);
-
-	       Telecide(AVDMGenericVideoStream *in,CONFcouple *couples);		
-			
-	       ~Telecide();
-
-	void PutChosen(int frame, unsigned int chosen);
-	
-
-	void CacheInsert(int frame, unsigned int p, unsigned int pblock,
-				unsigned int c, unsigned int cblock);
-	
-	bool CacheQuery(int frame, unsigned int *p, unsigned int *pblock,
-				unsigned int *c, unsigned int *cblock);	
-
-	bool PredictHardYUY2(int frame, unsigned int *predicted, unsigned int *predicted_metric) ;
-	
-	struct PREDICTION *PredictSoftYUY2(int frame);
-
-	void WriteHints(unsigned char *dst, bool film, bool inpattern);
-	virtual uint8_t getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-				ADMImage *data,uint32_t *flags);
-	char *printConf( void );
-	uint8_t configure(AVDMGenericVideoStream *in);
-	uint8_t	getCoupledConf( CONFcouple **couples);
-};

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDeintASM.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDeintASM.cpp	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDeintASM.cpp	2007-01-13 16:37:32 UTC (rev 2721)
@@ -1,238 +0,0 @@
-/***************************************************************************
-                          ADM_vidDeintASM.cpp  -  description
-                             -------------------
-    begin                : Tue Jan 7 2003
-    copyright            : (C) 2003 by mean
-    email                : fixounet at free.fr
-
-    Slighlty faster ASM deinterlace
-    Blend later	
-
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <ADM_assert.h>
-
-#include "config.h"
-#include "fourcc.h"
-#include "avio.hxx"
-#include "config.h"
-#include "avi_vars.h"
-
-
-
-#include "ADM_toolkit/toolkit.hxx"
-#include "ADM_editor/ADM_edit.hxx"
-#include "ADM_video/ADM_genvideo.hxx"
-
-#include"ADM_video/ADM_vidField.h"
-
-#if defined( ARCH_X86)  || defined(ARCH_X86_64)
-//	#define DEBUG_DEINT 1
-//	#define MMX_TRACE 1
-	#include "mmx_macros.h"
-#include "admmangle.h"
-
- void myDeintASM(void);
-
- static int32_t _l_w,_l_h,_l_all;
- static uint8_t *_l_p,*_l_c,*_l_n;
- static uint8_t *_l_e,*_l_e2;
-#define EXPAND(x) (x)+((x)<<16)+((x)<<32) +((x)<<48)
-static mmx_t _mmTHRESH1;
-static mmx_t _mmTHRESH2;
-
-#define COMPUTE_MMX \
-punpcklbw_r2r(mm5,mm0);  /*c  expand 4 bytes -> 4 word */ \
-punpcklbw_r2r(mm5,mm1);  /*p*/ \
-punpcklbw_r2r(mm5,mm2); /* n*/ \
-movq_r2r(mm0,mm3);		/* mm3 also c*/ \
-psubw_r2r(mm1,mm0) ; /* mm0=mm0-mm1 =  c-p*/ \
-psubw_r2r(mm2,mm3) ; /* mm3=mm3-mm2 =  c-n*/ \
-psraw_i2r(1,mm0); /* to protect from overflow*/ \
-psraw_i2r(1,mm3);\
-pmullw_r2r(mm0,mm3); /* mm3=(c-p)*(c-n) / 4;*/ \
-movq_r2r(mm3,mm0) ; /* mm0 also c-p*c-n */ \
-pcmpgtw_r2r(mm4,mm3); /* keep only > size*/ \
-pcmpgtw_r2r(mm6,mm0); /* keep only > size*/ \
-packsswb_r2r(mm5,mm0); \
-packsswb_r2r(mm5,mm3);
-
-#endif
-
-void ADMVideoFields::hasMotion_C(uint8_t *p,uint8_t *c,
-								uint8_t *n,
-								uint8_t *e,
-								uint8_t *e2
-								)
-{
-int32_t val,x,y;
-//printf("\nC \n");
-// other line
-       	for(y=_info.height-2;y>0;y--)
-        	{
-               for(x=_info.width;x>0;x--)
-               		{
-                   		val= (*p-*c)*(*n-*c);
-                        if(val>(int32_t)(_param->motion_trigger*_param->motion_trigger))
-                        	{
-                          	*e=0xff;
-                         }
-                         if(val>(int32_t)(_param->blend_trigger*_param->blend_trigger))
-                         	*e2=0xff;
-                         p++;c++;n++;e++;e2++;
-                      }
-           }
-}
-#if defined( ARCH_X86)  || defined(ARCH_X86_64)
-void ADMVideoFields::hasMotion_MMX(uint8_t *p,uint8_t *c,
-									uint8_t *n,
-									uint8_t *e,
-									uint8_t *e2
-									)
-{
-
-
-			 	_mmTHRESH1.uq=EXPAND((uint64_t ) ((_param->motion_trigger*_param->motion_trigger)>>2) );
-				_mmTHRESH2.uq=EXPAND((uint64_t ) ((_param->blend_trigger*_param->blend_trigger)>>2) );
-
-			_l_h=_info.height-2;
-			_l_w=_info.width>>2;
-			_l_all=_l_h*_l_w;
-			_l_p=p;
-			_l_c=c;
-			_l_n=n;
-			_l_e=e;
-			_l_e2=e2;
-//			printf("\n MMX \n");
-
-			pxor_r2r(mm5,mm5);
-			movq_m2r(_mmTHRESH1,mm4);
-			movq_m2r(_mmTHRESH2,mm6);
-			myDeintASM();
-}
-#if !defined(DEBUG_DEINT)
-void myDeintASM(void)
-{
-
-	//printf("\n using  MMX \n");
-
-
-        	{
-
-			__asm__ __volatile__ (
-				"mov "Mangle(_l_c)",	"REG_ax"\n\t"
-				"mov "Mangle(_l_p)",	"REG_bx"\n\t"
-				"mov "Mangle(_l_n)",	"REG_cx"\n\t"
-				"mov "Mangle(_l_all)",	"REG_si"\n\t"
-				"7:"
-				"movd ("REG_ax"),	%%mm0\n\t"
-				"movd ("REG_bx"),	%%mm1\n\t"
-				"movd ("REG_cx"),	%%mm2\n\t"
-				:
-				:
-				: "eax","ebx","ecx","edx","esi" 
-				);
-
-				COMPUTE_MMX;
-
-				/* store result in e, e2 */
-
-			__asm__ __volatile__(
-				"mov 	"Mangle(_l_e)",	"REG_dx"\n\t"
-				"movd	%%mm3,("REG_dx")\n\t"
-
-				"mov 	"Mangle(_l_e2)",	"REG_dx"\n\t"
-				"movd	%%mm0,("REG_dx")\n\t"
-
-				"add 	$4,	"REG_ax"\n\t"
-				"add 	$4,	"REG_bx"\n\t"
-				"add 	$4,	"REG_cx"\n\t"
-				"add 	$4,	"Mangle(_l_e)"\n\t"
-				"add 	$4,	"Mangle(_l_e2)"\n\t"
-				"sub 	$1,	"REG_si"\n\t"
-				"jnz 7b\n\t"
-
-				:
-				:
-				: "eax", "ebx","ecx","edx","esi"
-				);
-	           	}
-	   emms();
-
-}
-#else
-/*************************************************
-***************DEBUG*************************
-**************************************************
-**************************************************/
-
-
-void myDeintASM(void)
-{
-
-int32_t x,y;
-	printf("\n using  MMX debug\n");
-
-       	for(y=_l_h;y>0;y--)
-        	{
-		for(x=_l_w;x>0;x--)
-               		{
-
-			__asm__ __volatile__ (
-				"mov _l_c,	"REG_ax"\n\t"
-				"mov _l_p,	"REG_bx"\n\t"
-				"mov _l_n,	"REG_cx"\n\t"
-				"mov _l_w,	"REG_si"\n\t"
-				"movd ("REG_ax"),	%%mm0\n\t"
-				"movd ("REG_bx"),	%%mm1\n\t"
-				"movd ("REG_cx"),	%%mm2\n\t"
-				:
-				:
-				: "eax", "ebx", "ecx", "edx","esi"
-				);
-			emms();
-				COMPUTE_MMX;
-			emms();
-				/* store result in e, e2 */
-
-			__asm__ __volatile__(
-				"mov 	_l_e,	"REG_dx"\n\t"
-				"movd	%%mm3,("REG_dx")\n\t"
-				//"movd	%%mm3,(%%eax)\n\t"
-
-				"mov 	_l_e2,	"REG_dx"\n\t"
-				"movd	%%mm0,("REG_dx")\n\t"
-
-				:
-				:
-				: "eax","edx","esi"
-				);
-
-			emms();
-
-
-			 _l_e+=4;
-			 _l_e2+=4;
-			 _l_c+=4;
-			 _l_p+=4;
-			 _l_n+=4;
-
-           } // end for x
-	  }
-	   emms();
-}
-
-
-#endif
-#endif

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDeinterlace.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDeinterlace.cpp	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDeinterlace.cpp	2007-01-13 16:37:32 UTC (rev 2721)
@@ -1,114 +0,0 @@
-/***************************************************************************
-                          ADM_vidDeinterlace.cpp  -  description
-                             -------------------
-	Strongly inspired by Donal Graft deinterlacer
- 	Could be using some MMX
-  	Should be faster than the original due to YV12 colorspace
-
-20-Aug-2002 : Ported also the MMX part
-
-    begin                : Sat Apr 20 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <ADM_assert.h>
-
-#include "config.h"
-#include "fourcc.h"
-#include "avio.hxx"
-#include "config.h"
-#include "avi_vars.h"
-#ifdef HAVE_ENCODER
-
-
-
-#include "ADM_toolkit/toolkit.hxx"
-#include "ADM_editor/ADM_edit.hxx"
-#include "ADM_video/ADM_genvideo.hxx"
-
-#include"ADM_video/ADM_vidDeinterlace.h"
-#include "ADM_filter/video_filters.h"
-
-
-static FILTER_PARAM deintParam={2,{"motion_trigger","blend_trigger"}};
-
-
-SCRIPT_CREATE(deinterlace_script,ADMVideoDeinterlace,deintParam);
-BUILD_CREATE(deinterlace_create,ADMVideoDeinterlace);
-//_______________________________________________________________
-
-
-ADMVideoDeinterlace::~ADMVideoDeinterlace()
-{
- 	
-	delete _uncompressed;
-	_uncompressed=NULL;
-}
-ADMVideoDeinterlace::ADMVideoDeinterlace(  AVDMGenericVideoStream *in,CONFcouple *couples)
-		:ADMVideoFields(in,couples)
-{
-
-	_uncompressed=new ADMImage(_info.width,_info.height);
-}
-
-//
-//	Basically ask a uncompressed frame from editor and ask
-//		GUI to decompress it .
-//
-
-uint8_t ADMVideoDeinterlace::getFrameNumberNoAlloc(uint32_t frame,
-				uint32_t *len,
-   				ADMImage *data,
-				uint32_t *flags)
-{
-//uint8_t *dst,*dstu,*dstv,*srcu,*srcv;
-uint32_t uvlen;
-		
-		if(frame>=_info.nb_frames) return 0;
-		
-								
-		// read uncompressed frame
-       		if(!_in->getFrameNumberNoAlloc(frame, len,_uncompressed,flags)) return 0;         	
-		
-		uvlen=    _info.width*_info.height;
-		*len= (uvlen*3)>>1;       			
-
-		// No interleaving detected
-		if(!hasMotion(_uncompressed))
-           	{
-			data->duplicate(_uncompressed);
-			
-		}
-		else
-		{
-			//printf("Blending\n");
-			doBlend(_uncompressed,data);
-			memcpy(UPLANE(data),UPLANE(_uncompressed),uvlen>>2);
-			memcpy(VPLANE(data),VPLANE(_uncompressed),uvlen>>2);
-			data->copyInfo(_uncompressed);
-		}
-		return 1;
-}
-
-
-
-char *ADMVideoDeinterlace::printConf(void)
-{
- 		return (char *)"Deinterlace";;
-}
-
-
-#endif
-

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDeinterlace.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDeinterlace.h	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDeinterlace.h	2007-01-13 16:37:32 UTC (rev 2721)
@@ -1,39 +0,0 @@
-/***************************************************************************
-                          ADM_vidDeinterlace.h  -  description
-                             -------------------
-    begin                : Sat Apr 20 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
- #include "ADM_video/ADM_vidField.h"
-
- class  ADMVideoDeinterlace:public ADMVideoFields
- {
-
- protected:
-    		     							
-
- public:
- 		
-
-						ADMVideoDeinterlace(  AVDMGenericVideoStream *in,CONFcouple *setup);
-
-  			virtual 		~ADMVideoDeinterlace();
-		        virtual uint8_t 	getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-          										ADMImage *data,uint32_t *flags);
-
-			virtual char 	*printConf(void);
-	
- }     ;
-
-
-

Modified: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidEqualizer.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidEqualizer.cpp	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidEqualizer.cpp	2007-01-13 16:37:32 UTC (rev 2721)
@@ -22,7 +22,6 @@
 #include "ADM_toolkit/toolkit.hxx"
 #include "ADM_editor/ADM_edit.hxx"
 #include "ADM_video/ADM_genvideo.hxx"
-#include"ADM_video/ADM_vidField.h"
 
 #include "ADM_osSupport/ADM_debugID.h"
 #define MODULE_NAME MODULE_FILTER

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidField.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidField.h	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidField.h	2007-01-13 16:37:32 UTC (rev 2721)
@@ -1,83 +0,0 @@
-/***************************************************************************
-                          ADM_vidField.h  -  description
-                             -------------------
-    begin                : Sun Jan 12 2003
-    copyright            : (C) 2003 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifndef _VIDFIELD_
-#define _VIDFIELD_
- 
-#define ASM_DEINT
-#define ASM_BLEND
-
-#define THRES1 15*15
-#define THRES2 9*9
-
-typedef struct DEINT_PARAM
-{
-	  uint32_t motion_trigger;
-	  uint32_t blend_trigger;
-
-} DEINT_PARAM;
-
- class  ADMVideoFields:public AVDMGenericVideoStream
- {
-
- protected:
- 		DEINT_PARAM					*_param;
-
-      		uint8_t						*_motionmask;
-        	uint8_t						*_motionmask2;
-           	virtual char 					*printConf(void) { assert(0);return NULL;}
-           	uint8_t 						hasMotion(ADMImage *image);
-		void  							hasMotion_C(uint8_t *p,uint8_t *c,
-											uint8_t *n,
-											uint8_t *e,
-											uint8_t *e2
-											);
-		void  							  hasMotion_MMX(uint8_t *p,uint8_t *c,
-											uint8_t *n,
-											uint8_t *e,
-											uint8_t *e2
-												);
-
-           uint8_t 							doBlend(ADMImage *src,
-	   									ADMImage *dst);
-           void							blend_C(uint8_t *p,uint8_t *c,
-											uint8_t *n,
-											uint8_t *e,
-											uint8_t *f
-											);
-	  void								blend_MMX(uint8_t *p,uint8_t *c,
-													uint8_t *n,
-													uint8_t *e,
-													uint8_t *f
-											);
-
- public:
-
-
-							ADMVideoFields(  AVDMGenericVideoStream *in,CONFcouple *setup);
-  				virtual 		~ADMVideoFields();
-		     		virtual uint8_t 	getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-          									ADMImage *data,uint32_t *flags) 
-								{
-								 UNUSED_ARG(frame); UNUSED_ARG(len); UNUSED_ARG(data);
-								 UNUSED_ARG(flags); assert(0);return 0;
-								 }
-					virtual uint8_t configure( AVDMGenericVideoStream *instream) ;
-
-					virtual uint8_t 	getCoupledConf( CONFcouple **couples);
- }     ;
-
-#endif

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFields.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFields.cpp	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFields.cpp	2007-01-13 16:37:32 UTC (rev 2721)
@@ -1,243 +0,0 @@
-/***************************************************************************
-                          ADM_vidFields.cpp  -  description
-                             -------------------
-    begin                : Sun Jan 12 2003
-    copyright            : (C) 2003 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <ADM_assert.h>
-
-#include "config.h"
-#include "fourcc.h"
-#include "avio.hxx"
-#include "config.h"
-#include "avi_vars.h"
-#ifdef HAVE_ENCODER
-
-
-
-#include "ADM_toolkit/toolkit.hxx"
-#include "ADM_editor/ADM_edit.hxx"
-#include "ADM_video/ADM_genvideo.hxx"
-
-#include"ADM_video/ADM_vidField.h"
-#include "ADM_osSupport/ADM_cpuCap.h"
-//_______________________________________________________________
-
-ADMVideoFields::ADMVideoFields(
-									AVDMGenericVideoStream *in,CONFcouple *couples)
-{
-
-
-  	_in=in;		
-   	memcpy(&_info,_in->getInfo(),sizeof(_info));  		
-	
-					
-	_motionmask=new uint8_t [_in->getInfo()->width*_in->getInfo()->height];
-	ADM_assert(_motionmask);
-	_motionmask2=new uint8_t [_in->getInfo()->width*_in->getInfo()->height];
-	ADM_assert(_motionmask2);
-
-	_info.encoding=1;
-	if(couples)
-	{
-			_param=NEW(DEINT_PARAM);
-			GET(motion_trigger);
-			GET(blend_trigger);
-	}
-	else
-	{
-			_param=new( DEINT_PARAM);
-			_param->blend_trigger=9;
-			_param->motion_trigger=15;
-	}
-}
-
-uint8_t	ADMVideoFields::getCoupledConf( CONFcouple **couples)
-{
-
-			ADM_assert(_param);
-			*couples=new CONFcouple(2);
-
-#define CSET(x)  (*couples)->setCouple((char *)#x,(_param->x))
-	CSET(motion_trigger);
-	CSET(blend_trigger);
-			return 1;
-
-}
-
-ADMVideoFields::~ADMVideoFields()
-{
- 	
-	delete []_motionmask ;
-	delete []_motionmask2;
- 	DELETE(_param);
-	
-}
-//
-//	Return 1 if seen as interleaved
-//		0 is seen as progressiv
-//
-//		Check if in a 8x8 square n, n+1 , n+2 lines differ too much
-//
-uint8_t ADMVideoFields::hasMotion(ADMImage *image)
-{
-    	uint32_t w,h,x,y;
-      	uint8_t *n,*p,*c,*e,*e2;
-	uint8_t *yplane=YPLANE(image);
-       
-
-     	w=_info.width;
-     	h=_info.height;
-
-
-
-      	memset(_motionmask,0,w*h);
-      	memset(_motionmask2,0,w*h);
-
-       // First line
-       	memset(_motionmask,0xff,w);
-          	memset(_motionmask2,0xff,w);
-
-        	p=yplane;
-         	c=p+w;
-          	n=c+w;
-           e=_motionmask+w; 	
-           e2=_motionmask2+w; 	
-  //___________________ C version of motion detection ________________________
-       // other line
-#if (defined( ARCH_X86)  || defined(ARCH_X86_64)) && defined(ASM_DEINT)
-       if(CpuCaps::hasMMX())  
-      	hasMotion_MMX(p,c,n,e,e2);
-       else
-#endif 
-      	 hasMotion_C(p,c,n,e,e2);
-       
-      
-      
-//_______________________________
-           // last line
-           memset(e,0xff,w);
-           memset(e2,0xff,w);
-
-           // Count    how many tagged as !=
-           p=_motionmask;
-           c=p+w;;
-           n=c+w;;
-
-           // 8x8 square
-           uint8_t *box=new uint8_t[ ((h+8)>>3)*((w+8)>>3)]; // ???
-           uint32_t boxx,boxy;
-
-           memset(box,0,  ((h+8)>>3)*((w+8)>>3));
-           for(y=h-2;y>0;y--)
-           	{
-                     boxy=(y>>3)*(w>>3);
-                     for(x=w;x>0;x--)
-                     	{
-                             boxx=boxy+(x>>3);
-                             if( *c&&*p&&*n)
-                             	{
-                                 	box[boxx]++;
-                                }
-                                c++;n++;p++;
-                        }
-              }
-
-              // reached level ?
-              for(x=   ((h+8)>>3)*((w+8)>>3);x>0;x--)
-              {
-                     	if (box[x]>15)
-                      	{
-                          	
-                            	delete [] box;
-                             	return 1;
-                         }
-
-
-                }
-                       	delete [] box;
-                        	return 0;
-
-}
-
-uint8_t ADMVideoFields::doBlend(ADMImage *src,ADMImage *dst)
-{
-   	uint32_t w,h,x; //,y;
-      	uint8_t *n,*p,*c,*e2;
-	uint8_t *f;
-	uint8_t *yplane;
-
-
-	
-     	w=_info.width;
-     	h=_info.height;
-
-	f=YPLANE(dst);
-	yplane=YPLANE(src);
-	p=yplane;	
-	c=yplane;
-	n=c+w;
-	e2=_motionmask2+w; 
-	
-	// First line
-	// always blend
-	for(x=w;x>0;x--)
-	{
-		*f++=(*c+*n)>>1;
-		n++;
-		c++;
-	}
-#if (defined( ARCH_X86)  || defined(ARCH_X86_64)) && defined(ASM_BLEND)
-       if(CpuCaps::hasMMX())               
-              blend_MMX(p,c,n,e2,f);
-        else
-#endif
-              blend_C(p,c,n,e2,f);
-              // Last line
-            for(x=w;x>0;x--)
-            {
-               	*f++=(*c+*p)>>1;
-                	  p++;
-                   c++;
-
-              }
-
-              return 1;
-
-
-
-}
-uint8_t ADMVideoFields::configure( AVDMGenericVideoStream *instream)
-{
-int i,j;
-	_in=instream;
-	i=(int)_param->motion_trigger;
-	j=(int)_param->blend_trigger;
-	if(GUI_getIntegerValue(&i,0,255,"Motion  Threshold"))
-	{
-		if(GUI_getIntegerValue(&j,0,255,"Blend  Threshold"))
-		{
-			_param->motion_trigger=(uint8_t)i;
-			_param->blend_trigger=(uint8_t)j;
-			return 1;
-		}
-	} 
-
-	return 0;    
-}      
-
-
-#endif

Modified: branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am	2007-01-13 16:37:32 UTC (rev 2721)
@@ -6,8 +6,7 @@
 libADM_video_a_METASOURCES = AUTO
 #INCLUDES = $(all_includes) 
 
-libADM_video_a_SOURCES = ADM_vidFields.cpp \
- ADM_vidDeintASM.cpp \
+libADM_video_a_SOURCES = \
  ADM_vidCached.cpp \
  ADM_vidPartial.cpp \
  ADM_vidFont.cpp \
@@ -15,7 +14,6 @@
  ADM_vidContrast.cpp \
 	ADM_resizeter.cpp \
  ADM_vidCrop.cpp \
- ADM_vidDeinterlace.cpp \
  ADM_vidNull.cpp \
 	ADM_vidResize.cpp \
 	ADM_vidClean.cpp \
@@ -33,14 +31,11 @@
  ADM_vidIVTC.cpp \
  ADM_vidIVTC.h ADM_interlaced.cpp \
 	ADM_interlaced.h \
- ADM_vidBlend.cpp \
  ADM_vidRaw.cpp \
 	ADM_vidSRTRender.cpp \
  ADM_vidSRTload.cpp \
 	ADM_mpdetc.cpp \
- ADM_vidDecTelecide.cpp \
- ADM_vidDecTelecide.h ADM_cache.cpp \
- ADM_vidDecDec.cpp \
+ ADM_cache.cpp \
  ADM_vidEqualizer.cpp \
  ADM_vidVobsub.cpp \
  ADM_vobsubinfo.cpp \
@@ -61,13 +56,13 @@
 				
 
 
-EXTRA_DIST =  ADM_cache.cpp  ADM_vidDecDec_param.h \
-ADM_cache.h  ADM_vidDecTel_param.h \
-ADM_confCouple.h ADM_vidDecTelecide.cpp  ADM_vidNull.cpp \
-ADM_confCouples.cpp  ADM_vidDecTelecide.h  \
-ADM_genvideo.cpp ADM_vidDeintASM.cpp \
-ADM_genvideo.hxx ADM_vidDeinterlace.cpp  ADM_vidPartial.cpp \
-ADM_vidDeinterlace.h  ADM_vidPartial.h \
+EXTRA_DIST =  ADM_cache.cpp  \
+ADM_cache.h  \
+ADM_confCouple.h ADM_vidNull.cpp \
+ADM_confCouples.cpp  \
+ADM_genvideo.cpp \
+ADM_genvideo.hxx ADM_vidPartial.cpp \
+ADM_vidPartial.h \
 ADM_vidDelta.cpp  ADM_vidPartial_param.h \
 ADM_guiResize.cpp   ADM_vidRaw.cpp \
 ADM_interlaced.cpp  \
@@ -82,13 +77,12 @@
 ADM_vidFieldUnblend.cpp ADM_vidSRTload.cpp \
 ADM_vidASharp_param.h  ADM_vidFieldUtil.cpp  \
 ADM_vidFieldUtil.h  \
-ADM_vidFields.cpp \
 ADM_vidAnimated.cpp  \
 ADM_vidAnimated.h  \
 ADM_vidAnimated_param.h   \
 ADM_vidAsharp.cpp   \
 ADM_vidFont.cpp \
-ADM_vidBlend.cpp ADM_vidFont.h \
+ADM_vidFont.h \
 ADM_vidCNR2.cpp  \
 ADM_vidCNR2_param.h  ADM_vidHue.cpp  ADM_vidTDeint_param.h \
 ADM_vidCached.cpp  ADM_vidHue.h  ADM_vidTdeint.cpp \
@@ -106,7 +100,7 @@
 ADM_vidContrast.h  ADM_vidMPdelogo.h \
 ADM_vobsubinfo.cpp \
 ADM_vidCrop.cpp  ADM_vidMSmooth_param.h  ADM_vobsubinfo.h \
-ADM_vidDecDec.cpp  swscale_internal.h \
+swscale_internal.h \
 ADM_vidTdeint_util.txt ADM_vidASS.h ADM_vidASS.cpp \
 ADM_vidAss_Params.h mmx_macros.h
 
@@ -114,6 +108,6 @@
 INCLUDES = $(all_includes) -I../ADM_libraries -I../ADM_libraries/ADM_utilities -I../ADM_libraries/ADM_lavutil \
 			 $(FREETYPE_CFLAGS) $(ALTIVEC_SWITCH) -I../ADM_userInterfaces/ADM_commonUI -I../ADM_inputs
 noinst_HEADERS = ADM_mpdetc.h \
-					  ADM_cache.h ADM_vidDecTel_param.h ADM_vidDecDec_param.h \
+					  ADM_cache.h \
 					ADM_vidMSmooth_param.h ADM_vidEqualizer.h ADM_vobsubinfo.h ADM_vidVobSub.h \
 		ADM_vidEq2.h ADM_vidASS.h

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidBlend.cpp (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidBlend.cpp)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidBlend.cpp	2006-10-31 15:59:58 UTC (rev 2489)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidBlend.cpp	2007-01-13 16:37:32 UTC (rev 2721)
@@ -0,0 +1,187 @@
+/***************************************************************************
+                          ADM_vidBlend.cpp  -  description
+                             -------------------
+    begin                : Tue Jan 7 2003
+    copyright            : (C) 2003 by mean
+    email                : fixounet at free.fr
+
+    Slighlty faster ASM deinterlace
+    Blend later
+
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ADM_assert.h>
+
+#include "config.h"
+#include "fourcc.h"
+#include "avio.hxx"
+#include "config.h"
+#include "avi_vars.h"
+
+
+
+#include "ADM_toolkit/toolkit.hxx"
+#include "ADM_editor/ADM_edit.hxx"
+#include "ADM_video/ADM_genvideo.hxx"
+
+#include"ADM_vidField.h"
+
+#include "admmangle.h"
+
+
+ static int32_t _l_w,_l_h;
+ static uint8_t *_l_p,*_l_c,*_l_n;
+ static uint8_t *_l_e,*_l_e2;
+#define EXPAND(x) (x)+((x)<<16)+((x)<<32) +((x)<<48)
+static uint64_t  __attribute__((used)) _mmTHRESH1=EXPAND((uint64_t )THRES1);
+static uint64_t  __attribute__((used)) full_ones=0xFFFFFFFFFFFFFFFFLL;
+
+
+static void myBlendASM(void);
+
+void ADMVideoFields::blend_C(uint8_t *p,uint8_t *c,
+							uint8_t *n,
+							uint8_t *e,
+							uint8_t *f
+							)
+{
+uint32_t x,y;
+ for(y=_info.height-2;y>0;y--)
+           	{
+              for(x=_info.width;x>0;x--)
+              {
+
+                    if(*e)
+                    	{
+                       	*f=(*c>>1) + ((*n+*p)>>2);
+                       //	*f=255;
+
+                       }
+                       else
+                       		*f=*c;
+						//			*f=0;
+
+                       c++;n++;p++;e++;f++;
+                 }
+              }
+}
+#if defined( ARCH_X86)  || defined(ARCH_X86_64)
+void ADMVideoFields::blend_MMX(uint8_t *p,uint8_t *c,
+																							uint8_t *n,
+																							uint8_t *e,
+																							uint8_t *f
+																							)
+{
+      _l_h=_info.height-2;
+			_l_w=_info.width>>2;
+			_l_p=p;
+			_l_c=c;
+			_l_n=n;
+			_l_e=e;
+			_l_e2=f;
+			myBlendASM();
+}
+
+void myBlendASM(void)
+{
+	__asm__ (
+//"StartASM4: \n\t"
+"push 				"REG_di"\n\t"
+"push 				"REG_si"\n\t"
+"push 				"REG_ax"\n\t"
+
+"mov (%0), "REG_ax" \n\t"
+"mov "Mangle(_l_p)", "REG_ax" \n\t"
+"mov "Mangle(_l_c)", "REG_bx" \n\t"
+"mov "Mangle(_l_n)", "REG_cx" \n\t"
+"mov "Mangle(_l_e)", "REG_si" \n\t"
+"mov "Mangle(_l_e2)", "REG_di" \n\t"
+"movq "Mangle(full_ones)",%%mm7 \n\t"
+"pxor	   %%mm6,%%mm6 \n\t"
+
+"DHCOLB%=: \n\t" // loop
+"mov "Mangle(_l_w)", "REG_dx" \n\t"                // loop one line
+
+"DHLineB%=:  \n\t"
+
+"movd ("REG_bx"),%%mm0 \n\t"     // mm0 <- c
+"movd ("REG_ax"),%%mm1 \n\t"     // mm1 <- p
+"movd ("REG_cx"),%%mm2 \n\t"     // mm2 <- n
+"movd ("REG_si"),%%mm3 \n\t"     // mm2 <- e
+
+
+"punpcklbw %%mm6, %%mm0 \n\t"
+"punpcklbw %%mm6, %%mm1 \n\t"
+"punpcklbw %%mm6, %%mm2 \n\t"
+"punpcklbw %%mm6, %%mm3 \n\t"
+"movq      %%mm6, %%mm4 \n\t"
+
+//"movq %%mm3,S0 \n\t"
+
+// make 16 bits mask
+"psllw     $8, %%mm4 \n\t"
+"por	   %%mm4,%%mm3 \n\t"  // mask in m3
+//"movq %%mm3,S1 \n\t"
+//"movq %%mm2,S2 \n\t"
+//"movq %%mm1,S3 \n\t"
+
+
+// compute average of p & n in mm4
+"paddw     %%mm1,%%mm2 \n\t"
+"paddw     %%mm0,%%mm2 \n\t"
+"paddw     %%mm0,%%mm2 \n\t"
+//"movq 	   %%mm2,S4 \n\t"
+
+"psrlw     $2,%%mm2 \n\t"     //mm2 is averafe of p & n & c -> replacement value
+//"movq      %%mm2,S5 \n\t"
+
+"pand     %%mm3,%%mm2 \n\t"
+//"movq     %%mm2,S6 \n\t"
+
+// compute inverse value
+"pxor     %%mm7,%%mm3 \n\t" // inverse mask in m3
+//"movq     %%mm3,S7 \n\t"
+
+"pand     %%mm3,%%mm0 \n\t" // right value in m0
+//"movq     %%mm0,S8 \n\t"
+
+"por     %%mm2,%%mm0 \n\t" // ok, now right
+//"movq     %%mm0,S9 \n\t"
+
+"packuswb  %%mm6, %%mm0 \n\t"          // pack
+//"movq %%mm0,S10 \n\t"
+
+"movd	   %%mm0, ("REG_di") \n\t" // store
+
+//
+//
+// next
+"add       $4,"REG_ax" \n\t"
+"add       $4,"REG_bx" \n\t"
+"add       $4,"REG_cx" \n\t"
+"add       $4,"REG_si" \n\t"
+"add       $4,"REG_di" \n\t"
+"sub       $1,"REG_dx"	\n\t"
+"jne        DHLineB%= \n\t"   // next
+"sub       $1,"Mangle(_l_h)"  \n\t" // next line
+"jne        DHCOLB%= \n\t"
+"pop 				"REG_ax"\n\t"
+"pop 				"REG_si"\n\t"
+"pop 				"REG_di"\n\t"
+" emms       \n\t"
+ : /* no output */
+ :  "r"(&_mmTHRESH1)
+ :   "ebx", "ecx", "edx");
+}
+#endif

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDGbob.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDGbob.cpp	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDGbob.cpp	2007-01-13 16:37:32 UTC (rev 2721)
@@ -36,7 +36,6 @@
 #include "ADM_toolkit/toolkit.hxx"
 #include "ADM_editor/ADM_edit.hxx"
 #include "ADM_video/ADM_genvideo.hxx"
-#include"ADM_video/ADM_vidField.h"
 #include"ADM_video/ADM_cache.h"
 
 #include "ADM_osSupport/ADM_debugID.h"
@@ -74,7 +73,6 @@
 SCRIPT_CREATE(dgbob_script,DGbob,dgbobParam);
 
 /*************************************/
-extern uint8_t DIA_getDGbob(DGBobparam *param);
 uint8_t DGbob::configure(AVDMGenericVideoStream *in)
 {
         _in=in;

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDecDec.cpp (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDecDec.cpp)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDecDec.cpp	2006-10-31 15:59:58 UTC (rev 2489)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDecDec.cpp	2007-01-13 16:37:32 UTC (rev 2721)
@@ -0,0 +1,1663 @@
+/***************************************************************************
+                          ADM_vidDecTelecide  -  description
+                             -------------------
+    
+    email                : fixounet at free.fr
+
+    Port of Donal Graft Decimate which is (c) Donald Graft
+    http://www.neuron2.net
+    http://puschpull.org/avisynth/decomb_reference_manual.html
+
+ ***************************************************************************/
+
+/*
+	Decimate plugin for Avisynth -- performs 1-in-N
+	decimation on a stream of progressive frames, which are usually
+	obtained from the output of my Telecide plugin for Avisynth.
+	For each group of N successive frames, this filter deletes the
+	frame that is most similar to its predecessor. Thus, duplicate
+	frames coming out of Telecide can be removed using Decimate. This
+	filter adjusts the frame rate of the clip as
+	appropriate. Selection of the cycle size is selected by specifying
+	a parameter to Decimate() in the Avisynth scipt.
+
+	Copyright (C) 2003 Donald A. Graft
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program; if not, write to the Free Software
+	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+	The author can be contacted at:
+	Donald Graft
+	neuron2 at attbi.com.
+*/
+#include "config.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ADM_assert.h>
+
+#include "config.h"
+#include "fourcc.h"
+#include "avio.hxx"
+#include "avi_vars.h"
+
+#include "ADM_toolkit/toolkit.hxx"
+#include "ADM_editor/ADM_edit.hxx"
+#include "ADM_video/ADM_genvideo.hxx"
+#include"ADM_vidField.h"
+#include"ADM_video/ADM_cache.h"
+
+#include "ADM_osSupport/ADM_debugID.h"
+#define MODULE_NAME MODULE_FILTER
+#include "ADM_osSupport/ADM_debug.h"
+
+#include "ADM_osSupport/ADM_cpuCap.h"
+#include "ADM_userInterfaces/ADM_commonUI/DIA_factory.h"
+
+
+#define PROGRESSIVE  0x00000001
+#define MAGIC_NUMBER (0xdeadbeef)
+#define IN_PATTERN   0x00000002
+
+extern uint8_t 	PutHintingData(unsigned char *video, unsigned int hint);
+extern uint8_t 	GetHintingData(unsigned char *video, unsigned int *hint);
+extern void 	BitBlt(uint8_t * dstp, int dst_pitch, const uint8_t* srcp,
+            		int src_pitch, int row_size, int height);
+
+#define DrawString drawString
+
+#ifdef USE_SSE
+	#define DECIMATE_MMX_BUILD_PLANE 1
+	#define DECIMATE_MMX_BUILD	 1
+#endif
+
+#ifdef DECIMATE_MMX_BUILD_PLANE
+static void isse_blend_decimate_plane(uint8_t * dst, uint8_t* src,  uint8_t* src_next, 
+			int w, int h);
+int isse_scenechange_32(const uint8_t *c_plane,const  uint8_t *tplane, int height, int width) ;	
+int isse_scenechange_16(const uint8_t *c_plane,const  uint8_t *tplane, int height, int width) ;
+int isse_scenechange_8(const uint8_t *c_plane,const  uint8_t *tplane, int height, int width) ;
+#endif
+
+
+#define OutputDebugString(x) aprintf("%s\n",x)
+//________________________________
+#define MAX_CYCLE_SIZE 25
+#define MAX_BLOCKS 50
+
+#define GETFRAME(g, fp) \
+{ \
+	int GETFRAMEf; \
+	GETFRAMEf = (g); \
+	if (GETFRAMEf < 0) GETFRAMEf = 0; \
+	if (GETFRAMEf > num_frames_hi - 1) GETFRAMEf = num_frames_hi - 1; \
+	(fp) = vidCache->getImage(GETFRAMEf); \
+}
+//________________________________
+#include "ADM_vidDecDec_param.h"
+#include "ADM_filter/video_filters.h"
+
+
+static FILTER_PARAM decdecParam={5,{"cycle","mode","quality","threshold","threshold2"}};
+
+
+
+
+extern uint8_t DIA_getDecombDecimate(DECIMATE_PARAM *param);
+
+#define BLKSIZE 32
+//________________________________
+/* Decimate 1-in-N implementation. */
+class Decimate : public AVDMGenericVideoStream
+{
+	int 			num_frames_hi;
+	
+	DECIMATE_PARAM 		*_param;
+	
+	int last_request, last_result;
+	bool last_forced;
+	double last_metric;
+	double metrics[MAX_CYCLE_SIZE];
+	double showmetrics[MAX_CYCLE_SIZE];
+	int Dprev[MAX_CYCLE_SIZE];
+	int Dcurr[MAX_CYCLE_SIZE];
+	int Dnext[MAX_CYCLE_SIZE];
+	int Dshow[MAX_CYCLE_SIZE];
+	unsigned int hints[MAX_CYCLE_SIZE];
+	bool hints_invalid;
+	bool all_video_cycle;
+	bool firsttime;
+	int heightY, row_sizeY, pitchY;
+	int heightUV, row_sizeUV, pitchUV;
+	int pitch, row_size, height;
+	int xblocks, yblocks;
+	unsigned int *sum, div;
+	bool debug, show;
+	
+	VideoCache	*vidCache;
+	
+public:
+				
+			Decimate(AVDMGenericVideoStream *in,CONFcouple *couples);    
+			~Decimate(void);
+	uint8_t  	getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
+				ADMImage *data,uint32_t *flags);
+
+    	uint8_t   	*GetFrame(int n);
+	void   		DrawShow(ADMImage  *src, int useframe, bool forced, int dropframe,
+		                              double metric, int inframe );
+        void   		FindDuplicate(int frame, int *chosen, double *metric, bool *forced   );
+    	void   		FindDuplicate2(int frame, int *chosen, bool *forced );
+    	void   		FindDuplicateYUY2(int frame, int *chosen, double *metric, bool *force);
+    	void   		FindDuplicate2YUY2(int frame, int *chosen, bool *forced );
+	
+	char 		*printConf( void );
+	uint8_t 	configure(AVDMGenericVideoStream *in);
+	uint8_t		getCoupledConf( CONFcouple **couples);
+};
+
+
+
+BUILD_CREATE(decimate_create,Decimate);
+
+/*
+PClip _child, int _cycle, int _mode, double _threshold, double _threshold2,
+				int _quality, const char * _ovr, bool _show, bool _debug, IScriptEnvironment* env) 
+GenericVideoFilter(_child), cycle(_cycle), mode(_mode), threshold(_threshold),
+threshold2(_threshold2), quality(_quality), ovr(_ovr), show(_show), debug(_debug)
+*/	
+SCRIPT_CREATE(decimate_script,Decimate,decdecParam);
+uint8_t Decimate::configure(AVDMGenericVideoStream *in)
+{
+	_in=in;
+#define PX(x) &(_param->x)
+#define SZT(x) sizeof(x)/sizeof(diaMenuEntry *)
+        
+    ELEM_TYPE_FLOAT t1=(ELEM_TYPE_FLOAT)_param->threshold;
+    ELEM_TYPE_FLOAT t2=(ELEM_TYPE_FLOAT)_param->threshold2;
+
+         diaMenuEntry tMode[]={
+                             {0, _("Discard Closer"),NULL},
+                             {1, _("Replace (interpolate)"),NULL},
+                             {2, _("Discard longer dupe (anim?s)"),NULL},
+                             {3, _("PullDown dupe removal"),NULL}
+                          };
+         diaMenuEntry tQuality[]={
+                             {0, _("Fastest (no chroma, partial luma)"),NULL},
+                             {1, _("Fast (parial luma and chroma)"),NULL},
+                             {2, _("Medium (full luma no chroma)"),NULL},
+                             {3, _("Slow (full luma and chroma)"),NULL}
+                          };
+  
+    
+    diaElemMenu menuMode(PX(mode),_("Mode"), 4,tMode);
+    diaElemMenu menuQuality(PX(quality),_("Quality"), 4,tQuality);
+    diaElemFloat menuThresh1(&t1,_("Threshold 1"),0,100.);
+    diaElemFloat menuThresh2(&t2,_("Threshold 2"),0,100.);
+    diaElemUInteger cycle(PX(cycle),"Cycle",2,40);
+    
+    diaElem *elems[]={&cycle,&menuMode,&menuQuality,&menuThresh1,&menuThresh2};
+    
+  if(diaFactoryRun("Decombe Decimate",5,elems))
+  {
+    _param->threshold=(double )t1;
+    _param->threshold2=(double )t2;
+    return 1; 
+  }
+  return 0;        
+        
+        
+}
+
+char *Decimate::printConf( void )
+{
+ 	static char buf[50];
+
+	ADM_assert(_param);
+ 	sprintf((char *)buf," Decomb Decimate cycle:%d",_param->cycle);
+        return buf;
+}
+
+
+Decimate::Decimate(AVDMGenericVideoStream *in,CONFcouple *couples)		
+{
+{
+		
+		int count = 0;
+		char buf[80];
+		unsigned int *p;
+
+		_in=in;		
+   		memcpy(&_info,_in->getInfo(),sizeof(_info));    
+  		_info.encoding=1;
+		_uncompressed=NULL;		
+  		_info.encoding=1;
+		
+		//		
+		// Init here
+		debug=0;
+		show=0;		
+#ifdef USE_SSE	
+		if(CpuCaps::hasSSE())
+		{
+			printf("Decimate:SSE enabled\n");
+		}
+#endif
+		//
+		_param=new DECIMATE_PARAM;
+		if(couples)
+		{
+			GET(cycle);
+			GET(mode);
+			GET(quality);
+			GET(threshold);
+			GET(threshold2);
+			
+		}
+		else // Default
+  		{
+			_param->cycle=5;
+			_param->mode=0;
+			_param->quality=2;
+			_param->threshold=0;
+			_param->threshold2=3.0;
+		}
+		
+		ADM_assert(_param->cycle);
+		vidCache=new VideoCache(_param->cycle*2+1,in);
+		
+		if (_param->mode == 0 || _param->mode == 2 || _param->mode == 3)
+		{
+			num_frames_hi = _info.nb_frames;
+			_info.nb_frames = _info.nb_frames * (_param->cycle - 1) / _param->cycle;
+			_info.fps1000=_info.fps1000*(_param->cycle-1);
+			_info.fps1000=(uint32_t)(_info.fps1000/_param->cycle);
+			
+		}
+		last_request = -1;
+		firsttime = true;
+		sum = (unsigned int *) ADM_alloc(MAX_BLOCKS * MAX_BLOCKS * sizeof(unsigned int));
+		ADM_assert(sum);		
+		all_video_cycle = true;
+
+		if (debug)
+		{
+			char b[80];
+			sprintf(b, "Decimate %s by Donald Graft, Copyright 2003\n", VERSION);
+			OutputDebugString(b);
+		}
+	}
+}
+//________________________________________________________
+uint8_t	Decimate::getCoupledConf( CONFcouple **couples)
+{
+	*couples=NULL;
+	*couples=new CONFcouple(5);
+#define CSET(x)  (*couples)->setCouple((char *)#x,(_param->x))
+	
+	CSET(cycle);
+	CSET(mode);
+	CSET(quality);
+	CSET(threshold);
+	CSET(threshold2);
+
+	return 1;
+}
+//________________________________________________________
+Decimate::~Decimate(void)
+{
+		if (sum != NULL) ADM_dealloc(sum);
+		if(vidCache) delete vidCache;
+		if(_param) delete _param;
+
+		vidCache=NULL;
+		_param=NULL;
+		sum=NULL;
+}
+//________________________________________________________
+void Decimate::DrawShow(ADMImage  *src, int useframe, bool forced, int dropframe,
+						double metric, int inframe)
+{
+	char buf[80];
+	int start = (useframe / _param->cycle) * _param->cycle;
+
+	if (show == true)
+	{
+		sprintf(buf, "Decimate %s", VERSION);
+		DrawString(src, 0, 0, buf);
+		sprintf(buf, "Copyright 2003 Donald Graft");
+		DrawString(src, 0, 1, buf);
+		sprintf(buf,"%d: %3.2f", start, showmetrics[0]);
+		DrawString(src, 0, 3, buf);
+		sprintf(buf,"%d: %3.2f", start + 1, showmetrics[1]);
+		DrawString(src, 0, 4, buf);
+		sprintf(buf,"%d: %3.2f", start + 2, showmetrics[2]);
+		DrawString(src, 0, 5, buf);
+		sprintf(buf,"%d: %3.2f", start + 3, showmetrics[3]);
+		DrawString(src, 0, 6, buf);
+		sprintf(buf,"%d: %3.2f", start + 4, showmetrics[4]);
+		DrawString(src, 0, 7, buf);
+		if (all_video_cycle == false)
+		{
+			sprintf(buf,"in frm %d, use frm %d", inframe, useframe);
+			DrawString(src, 0, 8, buf);
+			if (forced == false)
+				sprintf(buf,"chose %d, dropping", dropframe);
+			else
+				sprintf(buf,"chose %d, dropping, forced!", dropframe);
+			DrawString(src, 0, 9, buf);
+		}
+		else
+		{
+			sprintf(buf,"in frm %d", inframe);
+			DrawString(src, 0, 8, buf);
+			sprintf(buf,"chose %d, decimating all-video cycle", dropframe);
+			DrawString(src, 0, 9, buf);
+		}
+	}
+	if (debug)
+	{
+		if (!(inframe%_param->cycle))
+		{
+			sprintf(buf,"Decimate: %d: %3.2f\n", start, showmetrics[0]);
+			OutputDebugString(buf);
+			sprintf(buf,"Decimate: %d: %3.2f\n", start + 1, showmetrics[1]);
+			OutputDebugString(buf);
+			sprintf(buf,"Decimate: %d: %3.2f\n", start + 2, showmetrics[2]);
+			OutputDebugString(buf);
+			sprintf(buf,"Decimate: %d: %3.2f\n", start + 3, showmetrics[3]);
+			OutputDebugString(buf);
+			sprintf(buf,"Decimate: %d: %3.2f\n", start + 4, showmetrics[4]);
+			OutputDebugString(buf);
+		}
+		if (all_video_cycle == false)
+		{
+			sprintf(buf,"Decimate: in frm %d useframe %d\n", inframe, useframe);
+			OutputDebugString(buf);
+			if (forced == false)
+				sprintf(buf,"Decimate: chose %d, dropping\n", dropframe);
+			else
+				sprintf(buf,"Decimate: chose %d, dropping, forced!\n", dropframe);
+			OutputDebugString(buf);
+		}
+		else
+		{
+			sprintf(buf,"Decimate: in frm %d\n", inframe);
+			OutputDebugString(buf);
+			sprintf(buf,"Decimate: chose %d, decimating all-video cycle\n", dropframe);
+			OutputDebugString(buf);
+		}
+	}
+}
+//______________________________________________________________________
+uint8_t Decimate::getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
+				ADMImage *data,uint32_t *flags)
+{
+	int dropframe, useframe, nextfrm, wY, wUV, hY, hUV, x, y, pitchY, pitchUV, dpitchY, dpitchUV;
+	ADMImage  *src, *next, *dst;
+	unsigned char *srcrpY, *nextrpY, *dstwpY;
+	unsigned char *srcrpU, *nextrpU, *dstwpU;
+	unsigned char *srcrpV, *nextrpV, *dstwpV;
+	uint32_t inframe=frame;
+	double metric;
+	char buf[255];
+
+	*len=(_info.width*_info.height*3)>>1;
+	num_frames_hi = _in->getInfo()->nb_frames; /* FIXME MEANX */
+	if (_param->mode == 0)
+	{
+		bool forced = false;
+		int start;
+
+		/* Normal decimation. Remove the frame most similar to its preceding frame. */
+		/* Determine the correct frame to use and get it. */
+		useframe = inframe + inframe / (_param->cycle - 1);
+		start = (useframe /  _param->cycle) * _param->cycle;
+		FindDuplicate((useframe / _param->cycle) * _param->cycle, &dropframe, &metric, &forced);
+		if (useframe >= dropframe) useframe++;
+		GETFRAME(useframe, src);
+		if (show == true)
+		{
+			sprintf(buf, "Decimate %s", VERSION);
+			DrawString(src, 0, 0, buf);
+			sprintf(buf, "Copyright 2003 Donald Graft");
+			DrawString(src, 0, 1, buf);
+			sprintf(buf,"%d: %3.2f", start, showmetrics[0]);
+			DrawString(src, 0, 3, buf);
+			sprintf(buf,"%d: %3.2f", start + 1, showmetrics[1]);
+			DrawString(src, 0, 4, buf);
+			sprintf(buf,"%d: %3.2f", start + 2, showmetrics[2]);
+			DrawString(src, 0, 5, buf);
+			sprintf(buf,"%d: %3.2f", start + 3, showmetrics[3]);
+			DrawString(src, 0, 6, buf);
+			sprintf(buf,"%d: %3.2f", start + 4, showmetrics[4]);
+			DrawString(src, 0, 7, buf);
+			sprintf(buf,"in frm %d, use frm %d", inframe, useframe);
+			DrawString(src, 0, 8, buf);
+			sprintf(buf,"dropping frm %d%s", dropframe, last_forced == true ? ", forced!" : "");
+			DrawString(src, 0, 9, buf);
+		}
+		if (debug)
+		{	
+			if (!(inframe % _param->cycle))
+			{
+				sprintf(buf,"Decimate: %d: %3.2f\n", start, showmetrics[0]);
+				OutputDebugString(buf);
+				sprintf(buf,"Decimate: %d: %3.2f\n", start + 1, showmetrics[1]);
+				OutputDebugString(buf);
+				sprintf(buf,"Decimate: %d: %3.2f\n", start + 2, showmetrics[2]);
+				OutputDebugString(buf);
+				sprintf(buf,"Decimate: %d: %3.2f\n", start + 3, showmetrics[3]);
+				OutputDebugString(buf);
+				sprintf(buf,"Decimate: %d: %3.2f\n", start + 4, showmetrics[4]);
+				OutputDebugString(buf);
+			}
+			sprintf(buf,"Decimate: in frm %d, use frm %d\n", inframe, useframe);
+			OutputDebugString(buf);
+			sprintf(buf,"Decimate: dropping frm %d%s\n", dropframe, last_forced == true ? ", forced!" : "");
+			OutputDebugString(buf);
+		}
+	    //return src;
+	        //memcpy(data,src,*len);
+
+		data->duplicate(src);
+		vidCache->unlockAll();
+		  
+		return 1;
+	}
+	else if (_param->mode == 1)
+	{
+		bool forced = false;
+		int start = (inframe / _param->cycle) * _param->cycle;
+		unsigned int hint, film = 1;
+
+		GETFRAME(inframe, src);
+	    	srcrpY = YPLANE(src); //(unsigned char *) src->GetReadPtr(PLANAR_Y);
+		if (GetHintingData(srcrpY, &hint) == false)
+		{
+			film = hint & PROGRESSIVE;
+//			if (film) OutputDebugString("film\n");
+//			else OutputDebugString("video\n");
+		}
+
+		/* Find the most similar frame as above but replace it with a blend of
+		   the preceding and following frames. */
+		num_frames_hi = _in->getInfo()->nb_frames; /* FIXME MEANX */
+		FindDuplicate((inframe / _param->cycle) * _param->cycle, &dropframe, &metric, &forced);
+		if (!film || inframe != dropframe || (_param->threshold && metric > _param->threshold))
+		{
+			if (show == true)
+			{
+
+				sprintf(buf, "Decimate %s", VERSION);
+				DrawString(src, 0, 0, buf);
+				sprintf(buf, "Copyright 2003 Donald Graft");
+				DrawString(src, 0, 1, buf);
+				sprintf(buf,"%d: %3.2f", start, showmetrics[0]);
+				DrawString(src, 0, 3, buf);
+				sprintf(buf,"%d: %3.2f", start + 1, showmetrics[1]);
+				DrawString(src, 0, 4, buf);
+				sprintf(buf,"%d: %3.2f", start + 2, showmetrics[2]);
+				DrawString(src, 0, 5, buf);
+				sprintf(buf,"%d: %3.2f", start + 3, showmetrics[3]);
+				DrawString(src, 0, 6, buf);
+				sprintf(buf,"%d: %3.2f", start + 4, showmetrics[4]);
+				DrawString(src, 0, 7, buf);
+				sprintf(buf,"infrm %d", inframe);
+				DrawString(src, 0, 8, buf);
+				if (last_forced == false)
+					sprintf(buf,"chose %d, passing through", dropframe);
+				else
+					sprintf(buf,"chose %d, passing through, forced!", dropframe);
+				DrawString(src, 0, 9, buf);
+			}
+			if (debug)
+			{
+				if (!(inframe % _param->cycle))
+				{
+					sprintf(buf,"Decimate: %d: %3.2f\n", start, showmetrics[0]);
+					OutputDebugString(buf);
+					sprintf(buf,"Decimate: %d: %3.2f\n", start + 1, showmetrics[1]);
+					OutputDebugString(buf);
+					sprintf(buf,"Decimate: %d: %3.2f\n", start + 2, showmetrics[2]);
+					OutputDebugString(buf);
+					sprintf(buf,"Decimate: %d: %3.2f\n", start + 3, showmetrics[3]);
+					OutputDebugString(buf);
+					sprintf(buf,"Decimate: %d: %3.2f\n", start + 4, showmetrics[4]);
+					OutputDebugString(buf);
+				}
+				sprintf(buf,"Decimate: in frm %d\n", inframe);
+				OutputDebugString(buf);
+				if (last_forced == false)
+					sprintf(buf,"Decimate: chose %d, passing through\n", dropframe);
+				else
+					sprintf(buf,"Decimate: chose %d, passing through, forced!\n", dropframe);
+				OutputDebugString(buf);
+			}
+			//return src;
+			//memcpy(data,src,*len);
+
+			data->duplicate(src);
+			vidCache->unlockAll();
+			return 1;
+		}
+		if (inframe < _in->getInfo()->nb_frames - 1) /* FIXME MEANX*/
+			nextfrm = inframe + 1;
+		else
+			nextfrm = _in->getInfo()->nb_frames - 1;
+		if (debug)
+		{
+			if (!(inframe % _param->cycle))
+			{
+				sprintf(buf,"Decimate: %d: %3.2f\n", start, showmetrics[0]);
+				OutputDebugString(buf);
+				sprintf(buf,"Decimate: %d: %3.2f\n", start + 1, showmetrics[1]);
+				OutputDebugString(buf);
+				sprintf(buf,"Decimate: %d: %3.2f\n", start + 2, showmetrics[2]);
+				OutputDebugString(buf);
+				sprintf(buf,"Decimate: %d: %3.2f\n", start + 3, showmetrics[3]);
+				OutputDebugString(buf);
+				sprintf(buf,"Decimate: %d: %3.2f\n", start + 4, showmetrics[4]);
+				OutputDebugString(buf);
+			}
+			sprintf(buf,"Decimate: in frm %d\n", inframe);
+			OutputDebugString(buf);
+			if (last_forced == false)
+				sprintf(buf,"Decimate: chose %d, blending %d and %d\n", dropframe, inframe, nextfrm);
+			else
+				sprintf(buf,"Decimate: chose %d, blending %d and %d, forced!\n", dropframe, inframe, nextfrm);
+			OutputDebugString(buf);
+		}
+		GETFRAME(nextfrm, next);
+		dst = data; //env->NewVideoFrame(vi);
+		pitchY = _info.width; //src->GetPitch(PLANAR_Y);
+		dpitchY = _info.width; //dst->GetPitch(PLANAR_Y);
+		wY = _info.width; //src->GetRowSize(PLANAR_Y);
+		hY = _info.height; //src->GetHeight(PLANAR_Y);
+		pitchUV = _info.width>>1;// src->GetPitch(PLANAR_V);
+		dpitchUV =_info.width>>1;// dst->GetPitch(PLANAR_V);
+		wUV = _info.width>>1;//src->GetRowSize(PLANAR_V);
+		hUV = _info.height>>1;//src->GetHeight(PLANAR_V);
+		
+		nextrpY = YPLANE(next); //next->GetReadPtr(PLANAR_Y);
+		dstwpY = YPLANE( dst); //dst->GetWritePtr(PLANAR_Y);
+#ifdef DECIMATE_MMX_BUILD_PLANE
+		if (CpuCaps::hasSSE()) 
+		{
+			isse_blend_decimate_plane(dstwpY, srcrpY, nextrpY, wY, hY);
+		} else {
+#endif
+			for (y = 0; y < hY; y++)
+			{
+				for (x = 0; x < wY; x++)
+				{
+					dstwpY[x] = ((int)srcrpY[x] + (int)nextrpY[x] ) >> 1;  
+				}
+				srcrpY += pitchY;
+				nextrpY += pitchY;
+				dstwpY += dpitchY;
+			}
+#ifdef DECIMATE_MMX_BUILD_PLANE
+		}
+#endif
+		srcrpU =   UPLANE(src);//->GetReadPtr(PLANAR_U);
+		nextrpU =   UPLANE(next);//->GetReadPtr(PLANAR_U);
+		dstwpU =  UPLANE(dst);//->GetWritePtr(PLANAR_U);
+#ifdef DECIMATE_MMX_BUILD_PLANE
+		if (CpuCaps::hasSSE()) 
+		{
+			isse_blend_decimate_plane(dstwpU, srcrpU, nextrpU, wUV, hUV);
+		} else {
+#endif
+			for (y = 0; y < hUV; y++)
+			{
+				for (x = 0; x < wUV; x++)
+				{
+					dstwpU[x] = ((int)srcrpU[x] + (int)nextrpU[x]) >> 1;
+				}
+				srcrpU += pitchUV;
+				nextrpU += pitchUV;
+				dstwpU += dpitchUV;
+			}
+#ifdef DECIMATE_MMX_BUILD_PLANE
+		}
+#endif
+		srcrpV =   VPLANE(src);//->GetReadPtr(PLANAR_V);
+		nextrpV =   VPLANE(next);//->GetReadPtr(PLANAR_V);
+		dstwpV =   VPLANE(dst);//->GetWritePtr(PLANAR_V);
+
+#ifdef DECIMATE_MMX_BUILD_PLANE
+		if (CpuCaps::hasSSE()) { 
+			isse_blend_decimate_plane(dstwpV, srcrpV, nextrpV, wUV, hUV );
+		} else {
+#endif
+			for (y = 0; y < hUV; y++)
+			{
+				for (x = 0; x < wUV; x++)
+				{
+					dstwpV[x] = ((int)srcrpV[x] + + (int)nextrpV[x]) >> 1;
+				}
+				srcrpV += pitchUV;
+				nextrpV += pitchUV;
+				dstwpV += dpitchUV;
+			}
+#ifdef DECIMATE_MMX_BUILD_PLANE
+		}
+#endif
+		if (show == true)
+		{
+
+			sprintf(buf, "Decimate %s", VERSION);
+			DrawString(dst, 0, 0, buf);
+			sprintf(buf, "Copyright 2003 Donald Graft");
+			DrawString(dst, 0, 1, buf);
+			sprintf(buf,"%d: %3.2f", start, showmetrics[0]);
+			DrawString(dst, 0, 3, buf);
+			sprintf(buf,"%d: %3.2f", start + 1, showmetrics[1]);
+			DrawString(dst, 0, 4, buf);
+			sprintf(buf,"%d: %3.2f", start + 2, showmetrics[2]);
+			DrawString(dst, 0, 5, buf);
+			sprintf(buf,"%d: %3.2f", start + 3, showmetrics[3]);
+			DrawString(dst, 0, 6, buf);
+			sprintf(buf,"%d: %3.2f", start + 4, showmetrics[4]);
+			DrawString(dst, 0, 7, buf);
+			sprintf(buf,"infrm %d", inframe);
+			DrawString(dst, 0, 8, buf);
+			if (last_forced == false)
+				sprintf(buf,"chose %d, blending %d and %d",dropframe, inframe, nextfrm);
+			else
+				sprintf(buf,"chose %d, blending %d and %d, forced!", dropframe, inframe, nextfrm);
+			DrawString(dst, 0, 9, buf);
+		}
+		//return dst;
+		//memcpy(data,dst,*len);
+
+		data->duplicate(dst);
+		vidCache->unlockAll();		
+		return 1;
+	}
+	else if (_param->mode == 2)
+	{
+		bool forced = false;
+
+		/* Delete the duplicate in the longest string of duplicates. */
+		useframe = inframe + inframe / (_param->cycle - 1);
+		FindDuplicate2((useframe / _param->cycle) * _param->cycle, &dropframe, &forced);
+		if (useframe >= dropframe) useframe++;
+		GETFRAME(useframe, src);
+		if (show == true)
+		{
+			int start = (useframe / _param->cycle) * _param->cycle;
+
+
+			sprintf(buf, "Decimate %s", VERSION);
+			DrawString(src, 0, 0, buf);
+			sprintf(buf, "Copyright 2003 Donald Graft");
+			DrawString(src, 0, 1, buf);
+			sprintf(buf,"in frm %d, use frm %d", inframe, useframe);
+			DrawString(src, 0, 3, buf);
+			sprintf(buf,"%d: %3.2f (%s)", start, showmetrics[0],
+					Dshow[0] ? "new" : "dup");
+			DrawString(src, 0, 4, buf);
+			sprintf(buf,"%d: %3.2f (%s)", start + 1, showmetrics[1],
+					Dshow[1] ? "new" : "dup");
+			DrawString(src, 0, 5, buf);
+			sprintf(buf,"%d: %3.2f (%s)", start + 2, showmetrics[2],
+					Dshow[2] ? "new" : "dup");
+			DrawString(src, 0, 6, buf);
+			sprintf(buf,"%d: %3.2f (%s)", start + 3, showmetrics[3],
+					Dshow[3] ? "new" : "dup");
+			DrawString(src, 0, 7, buf);
+			sprintf(buf,"%d: %3.2f (%s)", start + 4, showmetrics[4],
+					Dshow[4] ? "new" : "dup");
+			DrawString(src, 0, 8, buf);
+			sprintf(buf,"Dropping frm %d%s", dropframe, last_forced == true ? " forced!" : "");
+			DrawString(src, 0, 9, buf);
+		}
+		if (debug)
+		{	
+			sprintf(buf,"Decimate: inframe %d useframe %d\n", inframe, useframe);
+			OutputDebugString(buf);
+		}
+	    //return src;
+	    	//memcpy(data,src,*len);
+
+		data->duplicate(src);
+		vidCache->unlockAll();
+		return 1;
+	}
+	else if (_param->mode == 3)
+	{
+		bool forced = false;
+
+		/* Decimate by removing a duplicate from film cycles and doing a
+		   blend rate conversion on the video cycles. */
+		if (_param->cycle != 5)//	env->ThrowError("Decimate: mode=3 requires cycle=5");
+		{
+			printf("Decimate: mode=3 requires cycle=5\n");
+			return 0;
+		}
+		useframe = inframe + inframe / (_param->cycle - 1);
+		FindDuplicate((useframe / _param->cycle) * _param->cycle, &dropframe, &metric, &forced);
+		/* Use hints from Telecide about film versus video. Also use the difference
+		   metric of the most similar frame in the cycle; if it exceeds threshold,
+		   assume it's a video cycle. */
+		if (!(inframe % 4))
+		{
+			all_video_cycle = false;
+			if (_param->threshold && metric > _param->threshold)
+			{
+				all_video_cycle = true;
+			}
+			if ((hints_invalid == false) &&
+				(!(hints[0] & PROGRESSIVE) ||
+				 !(hints[1] & PROGRESSIVE) ||
+				 !(hints[2] & PROGRESSIVE) ||
+				 !(hints[3] & PROGRESSIVE) ||
+				 !(hints[4] & PROGRESSIVE)))
+			{
+				all_video_cycle = true;
+			}
+		}
+		if (all_video_cycle == false)
+		{
+			/* It's film, so decimate in the normal way. */
+			if (useframe >= dropframe) useframe++;
+			GETFRAME(useframe, src);
+			DrawShow(src, useframe, forced, dropframe, metric, inframe);			
+			//memcpy(data,src,*len);
+
+			data->duplicate(src);
+		
+			vidCache->unlockAll();		
+			return 1; // return src;
+		}
+		else if ((inframe % 4) == 0)
+		{
+			/* It's a video cycle. Output the first frame of the cycle. */
+			GETFRAME(useframe, src);
+			DrawShow(src, 0, forced, dropframe, metric, inframe);
+			//return src;
+			//memcpy(data,src,*len);
+
+			data->duplicate(src);
+		
+			vidCache->unlockAll();		
+			return 1; // return src;
+		}
+		else if ((inframe % 4) == 3)
+		{
+			/* It's a video cycle. Output the last frame of the cycle. */
+			GETFRAME(useframe+1, src);
+			DrawShow(src, 0, forced, dropframe, metric, inframe);
+			//return src;
+			//memcpy(data,src,*len);
+
+			data->duplicate(src);
+		
+			vidCache->unlockAll();		
+			return 1; // return src;
+		}
+		else if ((inframe % 4) == 1 || (inframe % 4) == 2)
+		{
+			/* It's a video cycle. Make blends for the remaining frames. */
+			if ((inframe % 4) == 1)
+			{
+				GETFRAME(useframe, src);
+				if (useframe < num_frames_hi - 1)
+					nextfrm = useframe + 1;
+				else
+					nextfrm = _in->getInfo()->nb_frames - 1;
+				GETFRAME(nextfrm, next);
+			}
+			else
+			{
+				GETFRAME(useframe + 1, src);
+				nextfrm = useframe;
+				GETFRAME(nextfrm, next);
+			}
+			dst = data; //env->NewVideoFrame(vi);
+			pitchY = _info.width; //src->GetPitch(PLANAR_Y);
+			dpitchY = _info.width; //dst->GetPitch(PLANAR_Y);
+			wY = _info.width; //src->GetRowSize(PLANAR_Y);
+			hY = _info.height; //src->GetHeight(PLANAR_Y);
+			pitchUV = _info.width>>1; //src->GetPitch(PLANAR_V);
+			dpitchUV =_info.width>>1; // dst->GetPitch(PLANAR_V);
+			wUV = _info.width>>1; //src->GetRowSize(PLANAR_V);
+			hUV = _info.height>>1; //src->GetHeight(PLANAR_V);
+			
+			srcrpY = YPLANE( src); //src->GetReadPtr(PLANAR_Y);
+			nextrpY = YPLANE( next); //next->GetReadPtr(PLANAR_Y);
+			dstwpY = YPLANE( dst); //dst->GetWritePtr(PLANAR_Y);
+#ifdef DECIMATE_MMX_BUILD_PLANE
+			if (CpuCaps::hasSSE()) { 
+				isse_blend_decimate_plane(dstwpY, srcrpY, nextrpY, wY, hY);
+			} else {
+#endif
+				for (y = 0; y < hY; y++)
+				{
+					for (x = 0; x < wY; x++)
+					{
+						dstwpY[x] = ((int)srcrpY[x] + (int)nextrpY[x]) >> 1;
+					}
+					srcrpY += pitchY;
+					nextrpY += pitchY;
+					dstwpY += dpitchY;
+				}
+#ifdef DECIMATE_MMX_BUILD_PLANE
+			}
+#endif
+			srcrpU =   UPLANE(src);//->GetReadPtr(PLANAR_U);
+			nextrpU =  UPLANE( next);//->GetReadPtr(PLANAR_U);
+			dstwpU =   UPLANE(dst);//->GetWritePtr(PLANAR_U);
+#ifdef DECIMATE_MMX_BUILD_PLANE
+			if (CpuCaps::hasSSE()) { 
+				isse_blend_decimate_plane(dstwpU, srcrpU, nextrpU, wUV, hUV);
+			} else {
+#endif
+				for (y = 0; y < hUV; y++)
+				{
+					for (x = 0; x < wUV; x++)
+					{
+						dstwpU[x] = ((int)srcrpU[x] + (int)nextrpU[x]) >> 1;
+					}
+					srcrpU += pitchUV;
+					nextrpU += pitchUV;
+					dstwpU += dpitchUV;
+				}
+#ifdef DECIMATE_MMX_BUILD_PLANE
+			}
+#endif
+			srcrpV =   VPLANE(src);//->GetReadPtr(PLANAR_V);
+			nextrpV =  VPLANE( next);//->GetReadPtr(PLANAR_V);
+			dstwpV =   VPLANE(dst);//->GetWritePtr(PLANAR_V);
+#ifdef DECIMATE_MMX_BUILD_PLANE
+			if (CpuCaps::hasSSE()) { 
+				isse_blend_decimate_plane(dstwpV, srcrpV, nextrpV, wUV, hUV);
+			} else {
+#endif
+				for (y = 0; y < hUV; y++)
+				{
+					for (x = 0; x < wUV; x++)
+					{
+						dstwpV[x] = ((int)srcrpV[x] + (int)nextrpV[x]) >> 1;
+					}
+					srcrpV += pitchUV;
+					nextrpV += pitchUV;
+					dstwpV += dpitchUV;
+				}
+#ifdef DECIMATE_MMX_BUILD_PLANE
+			}
+#endif
+			DrawShow(dst, 0, forced, dropframe, metric, inframe);
+			vidCache->unlockAll();
+			//return dst;
+			//memcpy(data,dst,*len);
+
+			data->duplicate(dst);
+			vidCache->unlockAll();		
+			return 1; // return src;			
+		}
+		//return src;
+		//memcpy(data,src,*len);
+
+		data->duplicate(src);
+		vidCache->unlockAll();		
+		return 1; // return src;			
+	}
+	//env->ThrowError("Decimate: invalid mode option (0-3)");
+	printf("Decimate: invalid mode option (0-3)\n");
+	/* Avoid compiler warning. */
+	return 0;
+}
+//____________________________________________________
+void Decimate::FindDuplicate(int frame, int *chosen, double *metric, bool *forced)
+{
+	int f;
+	ADMImage  * store[MAX_CYCLE_SIZE+1];
+	const unsigned char *storepY[MAX_CYCLE_SIZE+1];
+	const unsigned char *storepU[MAX_CYCLE_SIZE+1];
+	const unsigned char *storepV[MAX_CYCLE_SIZE+1];
+	const unsigned char *prevY, *prevU, *prevV, *currY, *currU, *currV;
+	int x, y, lowest_index, div;
+	unsigned int count[MAX_CYCLE_SIZE], lowest;
+	bool found;
+	unsigned int highest_sum=0;
+
+	/* Only recalculate differences when a new set is needed. */
+	if (frame == last_request)
+	{
+		*chosen = last_result;
+		*metric = last_metric;
+		return;
+	}
+	last_request = frame;
+
+	/* Get cycle+1 frames starting at the one before the asked-for one. */
+	for (f = 0; f <= _param->cycle; f++)
+	{
+		GETFRAME(frame + f - 1, store[f]);
+		storepY[f] = YPLANE(store[f]);//->GetReadPtr(PLANAR_Y);
+		hints_invalid = GetHintingData((unsigned char *) storepY[f], &hints[f]);
+		if (_param->quality == 1 || _param->quality == 3)
+		{
+			storepU[f] = UPLANE(store[f]);//->GetReadPtr(PLANAR_U);
+			storepV[f] = VPLANE(store[f]);//->GetReadPtr(PLANAR_V);
+		}
+	}
+
+    pitchY = _info.width; //store[0]->GetPitch(PLANAR_Y);
+    row_sizeY = _info.width; //store[0]->GetRowSize(PLANAR_Y);
+    heightY = _info.height; //store[0]->GetHeight(PLANAR_Y);
+	if (_param->quality == 1 || _param->quality == 3)
+	{
+		pitchUV = _info.width>>1; //store[0]->GetPitch(PLANAR_V);
+		row_sizeUV = _info.width>>1;//store[0]->GetRowSize(PLANAR_V);
+		heightUV = _info.height>>1;//store[0]->GetHeight(PLANAR_V);
+	}
+
+	int use_quality=_param->quality;
+
+
+	switch (use_quality)
+	{
+	case 0: // subsample, luma only
+		div = (BLKSIZE * BLKSIZE / 4) * 219;
+		break;
+	case 1: // subsample, luma and chroma
+		div = (BLKSIZE * BLKSIZE / 4) * 219 + ( (BLKSIZE * BLKSIZE / 8)) * 224;
+		break;
+	case 2: // fully sample, luma only
+		div = (BLKSIZE * BLKSIZE) * 219;
+		break;
+	case 3: // fully sample, luma and chroma
+		div = (BLKSIZE * BLKSIZE) * 219 + ( BLKSIZE * BLKSIZE/2) * 224;
+		break;
+	}
+
+	xblocks = row_sizeY / BLKSIZE;
+	if (row_sizeY % BLKSIZE) xblocks++;
+	yblocks = heightY / BLKSIZE;
+	if (heightY % BLKSIZE) yblocks++;
+
+	/* Compare each frame to its predecessor. */
+	for (f = 1; f <= _param->cycle; f++)
+	{
+		prevY = storepY[f-1];
+		currY = storepY[f];
+		for (y = 0; y < yblocks; y++)
+		{
+			for (x = 0; x < xblocks; x++)
+			{
+				sum[y*xblocks+x] = 0;
+			}
+		}
+		for (y = 0; y < heightY; y++)
+		{
+			for (x = 0; x < row_sizeY;)
+			{
+				sum[(y/BLKSIZE)*xblocks+x/BLKSIZE] += abs((int)currY[x] - (int)prevY[x]);
+				x++;
+				if (_param->quality == 0 || _param->quality == 1)
+				{
+					if (!(x%4)) x += 12;
+				}
+			}
+			prevY += pitchY;
+			currY += pitchY;
+		}
+		if (_param->quality == 1 || _param->quality == 3)
+		{
+			prevU = storepU[f-1];
+			prevV = storepV[f-1];
+			currU = storepU[f];
+			currV = storepV[f];
+			for (y = 0; y < heightUV; y++)
+			{
+				for (x = 0; x < row_sizeUV;)
+				{
+					sum[((2*y)/BLKSIZE)*xblocks+(2*x)/BLKSIZE] += abs((int)currU[x] - (int)prevU[x]);
+					sum[((2*y)/BLKSIZE)*xblocks+(2*x)/BLKSIZE] += abs((int)currV[x] - (int)prevV[x]);
+					x++;
+					if (_param->quality == 1)
+					{
+						if (!(x%4)) x += 12;
+					}
+				}
+				prevU += pitchUV;
+				currU += pitchUV;
+				prevV += pitchUV;
+				currV += pitchUV;
+			}
+		}
+		highest_sum = 0;
+		for (y = 0; y < yblocks; y++)
+		{
+			for (x = 0; x < xblocks; x++)
+			{
+				if (sum[y*xblocks+x] > highest_sum)
+				{
+					highest_sum = sum[y*xblocks+x];
+				}
+			}
+		}
+		count[f-1] = highest_sum;
+		showmetrics[f-1] = (count[f-1] * 100.0) / div;
+	}
+
+	/* Find the frame with the lowest difference count but
+	   don't use the artificial duplicate at frame 0. */
+	if (frame == 0)
+	{
+		lowest = count[1];
+		lowest_index = 1;
+	}
+	else
+	{
+		lowest = count[0];
+		lowest_index = 0;
+	}
+	for (x = 1; x < _param->cycle; x++)
+	{
+		if (count[x] < lowest)
+		{
+			lowest = count[x];
+			lowest_index = x;
+		}
+	}
+	last_result = frame + lowest_index;
+	if (_param->quality == 1 || _param->quality == 3)
+		last_metric = (lowest * 100.0) / div;
+	else
+		last_metric = (lowest * 100.0) / div;
+	*chosen = last_result;
+	*metric = last_metric;
+
+	
+	found = false;
+	last_forced = false;	
+
+}
+//____________________________________________________
+void Decimate::FindDuplicate2(int frame, int *chosen, bool *forced)
+{
+	int f, g, fsum, bsum, highest, highest_index;
+	ADMImage * store[MAX_CYCLE_SIZE+1];
+	const unsigned char *storepY[MAX_CYCLE_SIZE+1];
+	const unsigned char *storepU[MAX_CYCLE_SIZE+1];
+	const unsigned char *storepV[MAX_CYCLE_SIZE+1];
+	const unsigned char *prevY, *prevU, *prevV, *currY, *currU, *currV;
+	int x, y;
+	double lowest;
+	unsigned int lowest_index;
+	char buf[255];
+	unsigned int highest_sum;
+	bool found;
+#define BLKSIZE 32
+
+	/* Only recalculate differences when a new cycle is started. */
+	if (frame == last_request)
+	{
+		*chosen = last_result;
+		*forced = last_forced;
+		return;
+	}
+	last_request = frame;
+
+	if (firsttime == true || frame == 0)
+	{
+		firsttime = false;
+		for (f = 0; f < MAX_CYCLE_SIZE; f++) Dprev[f] = -1;
+		GETFRAME(frame, store[0]);
+		storepY[0] = YPLANE(store[0]);//->GetReadPtr(PLANAR_Y);
+		if (_param->quality == 1 || _param->quality == 3)
+		{
+			storepU[0] = UPLANE(store[0]);//->GetReadPtr(PLANAR_U);
+			storepV[0] = VPLANE(store[0]);//->GetReadPtr(PLANAR_V);
+		}
+
+		for (f = 1; f <= _param->cycle; f++)
+		{
+			GETFRAME(frame + f - 1, store[f]);
+			storepY[f] =YPLANE( store[f]);//->GetReadPtr(PLANAR_Y);
+			if (_param->quality == 1 || _param->quality == 3)
+			{
+				storepU[f] = UPLANE(store[f]);//->GetReadPtr(PLANAR_U);
+				storepV[f] = VPLANE(store[f]);//->GetReadPtr(PLANAR_V);
+			}
+		}
+
+		pitchY = _info.width; //store[0]->GetPitch(PLANAR_Y);
+		row_sizeY = _info.width; //store[0]->GetRowSize(PLANAR_Y);
+		heightY = _info.height; //store[0]->GetHeight(PLANAR_Y);
+		if (_param->quality == 1 || _param->quality == 3)
+		{
+			pitchUV = _info.width>>1; //store[0]->GetPitch(PLANAR_V);
+			row_sizeUV = _info.width>>1; //store[0]->GetRowSize(PLANAR_V);
+			heightUV = _info.height>>1; //store[0]->GetHeight(PLANAR_V);
+		}
+		switch (_param->quality)
+		{
+		case 0: // subsample, luma only
+			div = (BLKSIZE * BLKSIZE / 4) * 219;
+			break;
+		case 1: // subsample, luma and chroma
+			div = (BLKSIZE * BLKSIZE / 4) * 219 + (BLKSIZE * BLKSIZE / 8) * 224;
+			break;
+		case 2: // fully sample, luma only
+			div = (BLKSIZE * BLKSIZE) * 219;
+			break;
+		case 3: // fully sample, luma and chroma
+			div = (BLKSIZE * BLKSIZE) * 219 + (BLKSIZE * BLKSIZE / 2) * 224;
+			break;
+		}
+		xblocks = row_sizeY / BLKSIZE;
+		if (row_sizeY % BLKSIZE) xblocks++;
+		yblocks = heightY / BLKSIZE;
+		if (heightY % BLKSIZE) yblocks++;
+
+		/* Compare each frame to its predecessor. */
+		for (f = 1; f <= _param->cycle; f++)
+		{
+			for (y = 0; y < yblocks; y++)
+			{
+				for (x = 0; x < xblocks; x++)
+				{
+					sum[y*xblocks+x] = 0;
+				}
+			}
+			prevY = storepY[f-1];
+			currY = storepY[f];
+			for (y = 0; y < heightY; y++)
+			{
+				for (x = 0; x < row_sizeY;)
+				{
+					sum[(y/BLKSIZE)*xblocks+x/BLKSIZE] += abs((int)currY[x] - (int)prevY[x]);
+					x++;
+					if (_param->quality == 0 || _param->quality == 1)
+					{
+						if (!(x%4)) x += 12;
+					}
+				}
+				prevY += pitchY;
+				currY += pitchY;
+			}
+			if (_param->quality == 1 || _param->quality == 3)
+			{
+				prevU = storepU[f-1];
+				currU = storepU[f];
+				prevV = storepV[f-1];
+				currV = storepV[f];
+				for (y = 0; y < heightUV; y++)
+				{
+					for (x = 0; x < row_sizeUV;)
+					{
+						sum[((2*y)/BLKSIZE)*xblocks+(2*x)/BLKSIZE] += abs((int)currU[x] - (int)prevU[x]);
+						sum[((2*y)/BLKSIZE)*xblocks+(2*x)/BLKSIZE] += abs((int)currV[x] - (int)prevV[x]);
+						x++;
+						if (_param->quality == 0 || _param->quality == 1)
+						{
+							if (!(x%4)) x += 12;
+						}
+					}
+					prevU += pitchUV;
+					currU += pitchUV;
+					prevV += pitchUV;
+					currV += pitchUV;
+				}
+			}
+			highest_sum = 0;
+			for (y = 0; y < yblocks; y++)
+			{
+				for (x = 0; x < xblocks; x++)
+				{
+					if (sum[y*xblocks+x] > highest_sum)
+					{
+						highest_sum = sum[y*xblocks+x];
+					}
+				}
+			}
+			metrics[f-1] = (highest_sum * 100.0) / div;
+		}
+
+		Dcurr[0] = 1;
+		for (f = 1; f < _param->cycle; f++)
+		{
+			if (metrics[f] < _param->threshold2) Dcurr[f] = 0;
+			else Dcurr[f] = 1;
+		}
+
+		if (debug)
+		{
+			sprintf(buf,"Decimate: %d: %3.2f %3.2f %3.2f %3.2f %3.2f\n",
+					0, metrics[0], metrics[1], metrics[2], metrics[3], metrics[4]);
+			OutputDebugString(buf);
+		}
+	}
+ 	else if (frame >= num_frames_hi - 1)
+	{
+		GETFRAME(num_frames_hi - 1, store[0]);
+		storepY[0] = YPLANE(store[0]);//->GetReadPtr(PLANAR_Y);
+		if (_param->quality == 1 || _param->quality == 3)
+		{
+			storepU[0] = UPLANE(store[0]);//->GetReadPtr(PLANAR_U);
+			storepV[0] = VPLANE(store[0]);//->GetReadPtr(PLANAR_V);
+		}
+		for (f = 0; f < MAX_CYCLE_SIZE; f++) Dprev[f] = Dcurr[f];
+		for (f = 0; f < MAX_CYCLE_SIZE; f++) Dcurr[f] = Dnext[f];
+	}
+	else
+	{
+		GETFRAME(frame + _param->cycle - 1, store[0]);
+		storepY[0] = YPLANE(store[0]);//->GetReadPtr(PLANAR_Y);
+		if (_param->quality == 1 || _param->quality == 3)
+		{
+			storepU[0] = UPLANE(store[0]);//->GetReadPtr(PLANAR_U);
+			storepV[0] = VPLANE(store[0]);//->GetReadPtr(PLANAR_V);
+		}
+		for (f = 0; f < MAX_CYCLE_SIZE; f++) Dprev[f] = Dcurr[f];
+		for (f = 0; f < MAX_CYCLE_SIZE; f++) Dcurr[f] = Dnext[f];
+	}
+	for (f = 0; f < MAX_CYCLE_SIZE; f++) Dshow[f] = Dcurr[f];
+	for (f = 0; f < MAX_CYCLE_SIZE; f++) showmetrics[f] = metrics[f];
+
+	for (f = 1; f <= _param->cycle; f++)
+	{
+		GETFRAME(frame + f + _param->cycle - 1, store[f]);
+		storepY[f] =YPLANE( store[f]);//->GetReadPtr(PLANAR_Y);
+		if (_param->quality == 1 || _param->quality == 3)
+		{
+			storepU[f] = UPLANE(store[f]);//->GetReadPtr(PLANAR_U);
+			storepV[f] = VPLANE(store[f]);//->GetReadPtr(PLANAR_V);
+		}
+	}
+
+	/* Compare each frame to its predecessor. */
+	for (f = 1; f <= _param->cycle; f++)
+	{
+		prevY = storepY[f-1];
+		currY = storepY[f];
+		for (y = 0; y < yblocks; y++)
+		{
+			for (x = 0; x < xblocks; x++)
+			{
+				sum[y*xblocks+x] = 0;
+			}
+		}
+		for (y = 0; y < heightY; y++)
+		{
+			for (x = 0; x < row_sizeY;)
+			{
+				sum[(y/BLKSIZE)*xblocks+x/BLKSIZE] += abs((int)currY[x] - (int)prevY[x]);
+				x++;
+				if (_param->quality == 0 || _param->quality == 1)
+				{
+					if (!(x%4)) x += 12;
+				}
+			}
+			prevY += pitchY;
+			currY += pitchY;
+		}
+		if (_param->quality == 1 || _param->quality == 3)
+		{
+			prevU = storepU[f-1];
+			currU = storepU[f];
+			prevV = storepV[f-1];
+			currV = storepV[f];
+			for (y = 0; y < heightUV; y++)
+			{
+				for (x = 0; x < row_sizeUV;)
+				{
+					sum[((2*y)/BLKSIZE)*xblocks+(2*x)/BLKSIZE] += abs((int)currU[x] - (int)prevU[x]);
+					sum[((2*y)/BLKSIZE)*xblocks+(2*x)/BLKSIZE] += abs((int)currV[x] - (int)prevV[x]);
+					x++;
+					if (_param->quality == 0 || _param->quality == 1)
+					{
+						if (!(x%4)) x += 12;
+					}
+				}
+				prevU += pitchUV;
+				currU += pitchUV;
+				prevV += pitchUV;
+				currV += pitchUV;
+			}
+		}
+		highest_sum = 0;
+		for (y = 0; y < yblocks; y++)
+		{
+			for (x = 0; x < xblocks; x++)
+			{
+				if (sum[y*xblocks+x] > highest_sum)
+				{
+					highest_sum = sum[y*xblocks+x];
+				}
+			}
+		}
+		metrics[f-1] = (highest_sum * 100.0) / div;
+	}
+
+	/* Find the frame with the lowest difference count but
+	   don't use the artificial duplicate at frame 0. */
+	if (frame == 0)
+	{
+		lowest = metrics[1];
+		lowest_index = 1;
+	}
+	else
+	{
+		lowest = metrics[0];
+		lowest_index = 0;
+	}
+	for (f = 1; f < _param->cycle; f++)
+	{
+		if (metrics[f] < lowest)
+		{
+			lowest = metrics[f];
+			lowest_index = f;
+		}
+	}
+
+	for (f = 0; f < _param->cycle; f++)
+	{
+		if (metrics[f] < _param->threshold2) Dnext[f] = 0;
+		else Dnext[f] = 1;
+	}
+
+	if (debug)
+	{
+		sprintf(buf,"Decimate: %d: %3.2f %3.2f %3.2f %3.2f %3.2f\n",
+		        frame + 5, metrics[0], metrics[1], metrics[2], metrics[3], metrics[4]);
+		OutputDebugString(buf);
+	}
+
+	if (debug)
+	{
+		sprintf(buf,"Decimate: %d: %d %d %d %d %d\n",
+		        frame, Dcurr[0], Dcurr[1], Dcurr[2], Dcurr[3], Dcurr[4]);
+//		sprintf(buf,"Decimate: %d: %d %d %d %d %d - %d %d %d %d %d - %d %d %d %d %d\n",
+//		        frame, Dprev[0], Dprev[1], Dprev[2], Dprev[3], Dprev[4],
+//					   Dcurr[0], Dcurr[1], Dcurr[2], Dcurr[3], Dcurr[4],
+//					   Dnext[0], Dnext[1], Dnext[2], Dnext[3], Dnext[4]);
+		OutputDebugString(buf);
+	}
+
+	/* Find the longest strings of duplicates and decimate a frame from it. */
+	highest = -1;
+	for (f = 0; f < _param->cycle; f++)
+	{
+		if (Dcurr[f] == 1)
+		{
+			bsum = 0;
+			fsum = 0;
+		}
+		else
+		{
+			bsum = 1;
+			g = f;
+			while (--g >= 0)
+			{
+				if (Dcurr[g] == 0)
+				{
+					bsum++;
+				}
+				else break;
+			}
+			if (g < 0)
+			{
+				g = _param->cycle;
+				while (--g >= 0)
+				{
+					if (Dprev[g] == 0)
+					{
+						bsum++;
+					}
+					else break;
+				}
+			}
+			fsum = 1;
+			g = f;
+			while (++g < _param->cycle)
+			{
+				if (Dcurr[g] == 0)
+				{
+					fsum++;
+				}
+				else break;
+			}
+			if (g >= _param->cycle)
+			{
+				g = -1;
+				while (++g < _param->cycle)
+				{
+					if (Dnext[g] == 0)
+					{
+						fsum++;
+					}
+					else break;
+				}
+			}
+		}
+		if (bsum + fsum > highest)
+		{
+			highest = bsum + fsum;
+			highest_index = f;
+		}
+//		sprintf(buf,"Decimate: bsum %d, fsum %d\n", bsum, fsum);
+//		OutputDebugString(buf);
+	}
+
+	f = highest_index;
+	if (Dcurr[f] == 1)
+	{
+		/* No duplicates were found! Act as if mode=0. */
+		*chosen = last_result = frame + lowest_index;
+	}
+	else
+	{
+		/* Prevent this decimated frame from being considered again. */ 
+		Dcurr[f] = 1;
+		*chosen = last_result = frame + highest_index;
+	}
+	last_forced = false;
+	if (debug)
+	{
+		sprintf(buf,"Decimate: dropping frame %d\n", last_result);
+		OutputDebugString(buf);
+	}
+
+	
+	found = false;
+	
+	if (found == true)
+	{
+		*chosen = last_result ;
+		*forced = last_forced = true;
+		if (debug)
+		{
+			sprintf(buf,"Decimate: overridden drop frame -- drop %d\n", last_result);
+			OutputDebugString(buf);
+		}
+	}
+}
+#ifdef DECIMATE_MMX_BUILD_PLANE
+//
+//
+//
+//
+void isse_blend_decimate_plane(uint8_t * dst, uint8_t* src,  uint8_t* src_next, 
+			int w, int h)
+{
+uint32_t x;
+	if (!h) return;  // Height == 0 - avoid silly crash.
+	
+	x=w>>3; // 8 pixels at a time
+	for(;x>0;x--)
+	{
+	 __asm__( ".align 16\n"
+	 	"movq  (%1), %%mm0 \n"
+		"movq  (%2), %%mm2 \n"
+		"pavgb %%mm0,%%mm1 \n"
+		"movq  %%mm1,(%0) \n"
+
+                   : : "r" (dst), "r" (src), "r" (src_next));
+		
+		dst+=8;
+		src+=8;
+		src_next+=8;
+  	}
+    	__asm__("emms");
+  
+}
+int isse_scenechange_32(const uint8_t *c_plane, const uint8_t *tplane, int height, int width) 
+{
+  int wp=width>>5;
+  int hp=height;
+  int returnvalue=0xbadbad00;
+    
+    __asm__(
+    ".align 16\n"
+    "pxor %%mm6,%%mm6\n"
+    "pxor %%mm7,%%mm7\n"
+    ::);
+    for(uint32_t y=0;y<hp;y++)
+    {
+	for(uint32_t x=0;x<wp;x++)
+	{
+		__asm__(
+    		".align 16\n"
+    		"movq (%0),%%mm0 \n"
+		"movq 8(%0),%%mm2 \n"
+		"movq (%1),%%mm1 \n"
+		"movq 8(%1),%%mm3 \n"
+		"psadbw %%mm1,%%mm0\n"
+		"psadbw %%mm3,%%mm2\n"
+		"paddd %%mm0,%%mm6 \n"
+		"paddd %%mm2,%%mm7 \n"
+		
+		"movq 16(%0),%%mm0 \n"
+		"movq 24(%0),%%mm2 \n"
+		"movq 16(%1),%%mm1 \n"
+		"movq 24(%1),%%mm3 \n"
+		"psadbw %%mm1,%%mm0\n"
+		"psadbw %%mm3,%%mm2\n"
+		"paddd %%mm0,%%mm6 \n"
+		"paddd %%mm2,%%mm7 \n"
+		
+		
+		: : "r" (c_plane) , "r" (tplane)
+		);
+		c_plane+=32;
+		tplane+=32;
+	}    
+    
+    	c_plane+=width-wp*32;
+	tplane+=width-wp*32;
+    }
+    __asm__(
+    ".align 16\n"
+    "paddd %%mm6,%%mm7\n"
+    "movd %%mm7,(%0)\n"
+    "emms \n"
+    : : "r" (&returnvalue)
+    );
+  
+  return returnvalue;
+}
+int isse_scenechange_16(const uint8_t *c_plane, const uint8_t *tplane, int height, int width) 
+{
+  int wp=width>>4;
+  int hp=height;
+  int returnvalue=0xbadbad00;
+    
+    __asm__(
+    ".align 16\n"
+    "pxor %%mm6,%%mm6\n"
+    "pxor %%mm7,%%mm7\n"
+    ::);
+    for(uint32_t y=0;y<hp;y++)
+    {
+	for(uint32_t x=0;x<wp;x++)
+	{
+		__asm__(
+    		".align 16\n"
+    		"movq (%0),%%mm0 \n"
+		"movq 8(%0),%%mm2 \n"
+		"movq (%1),%%mm1 \n"
+		"movq 8(%1),%%mm3 \n"
+		"psadbw %%mm1,%%mm0\n"
+		"psadbw %%mm3,%%mm2\n"
+		"paddd %%mm0,%%mm6 \n"
+		"paddd %%mm2,%%mm7 \n"				
+		
+		
+		: : "r" (c_plane) , "r" (tplane)
+		);
+		c_plane+=16;
+		tplane+=16;
+	}    
+    
+    	c_plane+=width-wp*16;
+	tplane+=width-wp*16;
+    }
+    __asm__(
+    ".align 16\n"
+    "paddd %%mm6,%%mm7\n"
+    "movd %%mm7,(%0)\n"
+    "emms \n"
+    : : "r" (&returnvalue)
+    );
+  
+  return returnvalue;
+}
+int isse_scenechange_8(const uint8_t *c_plane, const uint8_t *tplane, int height, int width) 
+{
+  int wp=width>>3;
+  int hp=height;
+  int returnvalue=0xbadbad00;
+    
+    __asm__(
+    ".align 16\n"
+    "pxor %%mm6,%%mm6\n"
+    "pxor %%mm7,%%mm7\n"
+    ::);
+    for(uint32_t y=0;y<hp;y++)
+    {
+	for(uint32_t x=0;x<wp;x++)
+	{
+		__asm__(
+    		".align 16\n"
+    		"movq (%0),%%mm0 \n"		
+		"movq (%1),%%mm1 \n"		
+		"psadbw %%mm1,%%mm0\n"		
+		"paddd %%mm0,%%mm6 \n"
+		
+		: : "r" (c_plane) , "r" (tplane)
+		);
+		c_plane+=8;
+		tplane+=8;
+	}    
+    
+    	c_plane+=width-wp*8;
+	tplane+=width-wp*8;
+    }
+    __asm__(
+    ".align 16\n"    
+    "movd %%mm6,(%0)\n"
+    "emms \n"
+    : : "r" (&returnvalue)
+    );
+  
+  return returnvalue;
+}
+
+#endif

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDecDec_param.h (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDecDec_param.h)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDecDec_param.h	2006-10-31 15:59:58 UTC (rev 2489)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDecDec_param.h	2007-01-13 16:37:32 UTC (rev 2721)
@@ -0,0 +1,19 @@
+//
+// C++ Interface: ADM_vidDecDec_param
+//
+// Description: 
+//
+//
+// Author: mean <fixounet at free.fr>, (C) 2004
+//
+// Copyright: See COPYING file that comes with this distribution
+//
+//
+typedef struct DECIMATE_PARAM
+{
+	uint32_t    cycle; // Integer 2..40
+        uint32_t    mode;  // 0..3
+        uint32_t    quality; //0..4
+	double      threshold;
+        double      threshold2;
+};

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDecTel_param.h (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDecTel_param.h)

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDecTelecide.cpp (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDecTelecide.cpp)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDecTelecide.cpp	2006-10-31 15:59:58 UTC (rev 2489)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDecTelecide.cpp	2007-01-13 16:37:32 UTC (rev 2721)
@@ -0,0 +1,1644 @@
+
+/***************************************************************************
+                          ADM_vidDecTelecide  -  description
+                             -------------------
+    
+    email                : fixounet at free.fr
+
+    Port of Donal Graft Telecide which is (c) Donald Graft
+    http://www.neuron2.net
+    http://puschpull.org/avisynth/decomb_reference_manual.html
+
+ ***************************************************************************/
+/*
+	Telecide plugin for Avisynth -- recovers original progressive
+	frames from telecined streams. The filter operates by matching
+	fields and automatically adapts to phase/pattern changes.
+
+	Copyright (C) 2003 Donald A. Graft
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program; if not, write to the Free Software
+	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+#include "config.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ADM_assert.h>
+
+#include "config.h"
+#include "fourcc.h"
+#include "avio.hxx"
+#include "avi_vars.h"
+
+#include "ADM_toolkit/toolkit.hxx"
+#include "ADM_editor/ADM_edit.hxx"
+#include "ADM_video/ADM_genvideo.hxx"
+
+
+#include "ADM_osSupport/ADM_debugID.h"
+#define MODULE_NAME MODULE_FILTER
+#include "ADM_osSupport/ADM_debug.h"
+
+
+
+#include "ADM_vidDecTelecide.h"
+#include "ADM_filter/video_filters.h"
+static FILTER_PARAM decomb_template={16,{"order","back","guide",
+	 	 	"gthresh","post","chroma","vthresh",
+			"bthresh","dthresh","blend",
+			"nt","y0","y1","hints",
+			"show","debug"}};
+BUILD_CREATE(decomb_create,Telecide);
+SCRIPT_CREATE(decomb_script,Telecide,decomb_template);
+extern uint8_t DIA_getDecombTelecide(TelecideParam *param);
+
+uint8_t Telecide::configure(AVDMGenericVideoStream *in)
+{
+	_in=in;
+//	return DIA_getDecombTelecide(_param);
+        return 0;
+	
+}
+
+char *Telecide::printConf( void )
+{
+ 	static char buf[50];
+
+  	ADM_assert(_param); 	
+ 	sprintf((char *)buf," Decomb Telecide");
+        return buf;
+}
+
+
+#define PROGRESSIVE  0x00000001
+#define MAGIC_NUMBER (0xdeadbeef)
+#define IN_PATTERN   0x00000002
+
+
+  uint8_t PutHintingData(unsigned char *video, unsigned int hint);
+  uint8_t GetHintingData(unsigned char *video, unsigned int *hint);
+  void BitBlt(uint8_t * dstp, int dst_pitch, const uint8_t* srcp,
+            int src_pitch, int row_size, int height);
+//  void DrawString(ADMImage *dst, int x, int y, const char *s);
+ // void DrawStringYUY2(uint8_t *dst, int x, int y, const char *s);
+#define DrawString drawString
+
+uint8_t Telecide::getCoupledConf( CONFcouple **couples)
+{
+
+                        ADM_assert(_param);
+                        *couples=new CONFcouple(16);
+
+#define CSET(x)  (*couples)->setCouple((char *)#x,(_param->x))
+        CSET(order);
+        CSET(back);
+        CSET(chroma);
+        CSET(guide);
+        CSET(gthresh);
+        CSET(post);
+        CSET(vthresh);
+        CSET(bthresh);
+        CSET(dthresh);
+        CSET(blend);
+        CSET(nt);
+        CSET(y0);
+        CSET(y1);
+        CSET(hints);
+        CSET(show);
+        CSET(debug);
+        
+        return 1;
+
+}
+uint8_t PutHintingData(unsigned char *video, unsigned int hint)
+{
+        unsigned char *p;
+        unsigned int i, magic_number = MAGIC_NUMBER;
+        bool error = false;
+
+        p = video;
+        for (i = 0; i < 32; i++)
+        {
+                *p &= ~1; 
+                *p++ |= ((magic_number & (1 << i)) >> i);
+        }
+        for (i = 0; i < 32; i++)
+        {
+                *p &= ~1;
+                *p++ |= ((hint & (1 << i)) >> i);
+        }
+        return error;
+}
+
+uint8_t GetHintingData(unsigned char *video, unsigned int *hint)
+{
+        unsigned char *p;
+        unsigned int i, magic_number = 0;
+        bool error = false;
+
+        p = video;
+        for (i = 0; i < 32; i++)
+        {
+                magic_number |= ((*p++ & 1) << i);
+        }
+        if (magic_number != MAGIC_NUMBER)
+        {
+                error = true;
+        }
+        else
+        {
+                *hint = 0;
+                for (i = 0; i < 32; i++)
+                {
+                        *hint |= ((*p++ & 1) << i);
+                }
+        }
+        return error;
+}
+void BitBlt(uint8_t* dstp, int dst_pitch, const uint8_t* srcp,
+            int src_pitch, int row_size, int height)
+{
+        for(uint32_t y=0;y<height;y++)
+        {
+                memcpy(dstp,srcp,row_size);
+                dstp+=dst_pitch;
+                srcp+=src_pitch;
+        }
+}        
+void Telecide::WriteHints(unsigned char *dst, bool film, bool inpattern)
+        {
+                unsigned int hint;
+
+                if (GetHintingData(dst, &hint) == true) hint = 0;
+                if (film == true) hint |= PROGRESSIVE;
+                else hint &= ~PROGRESSIVE;
+                if (inpattern == true) hint |= IN_PATTERN;
+                else hint &= ~IN_PATTERN;
+                PutHintingData(dst, hint);
+        }
+void Telecide::PutChosen(int frame, unsigned int chosen)
+        {
+                int f;
+
+                f = frame % CACHE_SIZE;
+                if (frame < 0 || frame > _info.nb_frames - 1 || cache[f].frame != frame)
+                        return;
+                cache[f].chosen = chosen;
+        }
+
+        void Telecide::CacheInsert(int frame, unsigned int p, unsigned int pblock,
+                                                                        unsigned int c, unsigned int cblock)
+        {
+                int f;
+
+                f = frame % CACHE_SIZE;
+                if (frame < 0 || frame > _info.nb_frames - 1)
+                        ADM_assert(0);
+                cache[f].frame = frame;
+                cache[f].metrics[P] = p;
+                if (f) cache[f-1].metrics[N] = p;
+                cache[f].metrics[C] = c;
+                cache[f].metrics[PBLOCK] = pblock;
+                cache[f].metrics[CBLOCK] = cblock;
+                cache[f].chosen = 0xff;
+        }
+
+        bool Telecide::CacheQuery(int frame, unsigned int *p, unsigned int *pblock,
+                                                                        unsigned int *c, unsigned int *cblock)
+        {
+                int f;
+
+                f = frame % CACHE_SIZE;
+                if (frame < 0 || frame > _info.nb_frames - 1)
+                {
+                        printf("Frame %d is out! (%d)\n",frame,_info.nb_frames-1);
+                        ADM_assert(0);
+                }
+                if (cache[f].frame != frame)
+                {
+                        return false;
+                }
+                *p = cache[f].metrics[P];
+                *c = cache[f].metrics[C];
+                *pblock = cache[f].metrics[PBLOCK];
+                *cblock = cache[f].metrics[CBLOCK];
+                return true;
+        }
+
+       
+Telecide::Telecide(AVDMGenericVideoStream *in,CONFcouple *couples) 
+{
+
+		int i;		
+		int count;
+		char *d, *dsaved;
+		unsigned int *p, *x;
+		_lastFrame=0xfffffff0;
+		
+   		
+		_in=in;		
+   		memcpy(&_info,_in->getInfo(),sizeof(_info));    
+  		_info.encoding=1;
+		_uncompressed=NULL;
+		vidCache=new VideoCache(12,in);
+				 	
+  		_info.encoding=1;
+
+		
+		pitch = _info.width;
+		dpitch = _info.width;
+		pitchover2 = pitch >> 1;
+		pitchtimes4 = pitch << 2;
+		w = _info.width;
+		h = _info.height;
+		wover2 = w/2;
+		hover2 = h/2;
+		hplus1over2 = (h+1)/2;
+		hminus2= h - 2;
+		_param=NEW(TelecideParam);
+		if(couples)
+		{
+			GET(order);
+			GET(back);
+			GET(chroma);
+			GET(guide);
+			GET(gthresh);
+			GET(post);
+			GET(vthresh);
+			GET(bthresh);
+			GET(dthresh);
+			GET(blend);
+			GET(nt);
+			GET(y0);
+			GET(y1);
+			GET(hints);
+			GET(show);
+			GET(debug);
+		}
+		else // Default
+  		{
+			 	
+			 	_param->order = 1; 		// 0 Field ok, 1 field reverted 0 BFF/1 TFF
+				_param->back = NO_BACK; // 0 Never, 1 when bad, 2 always tried MUST Have post !=0
+				_param->chroma = false;
+				_param->guide = GUIDE_32;// 0 / NONE - 1 GUIDE_32/ivtc-2 GUIDE 22/PAL-3 PAL/NTSC
+				_param->gthresh = 10.0;
+				_param->post = POST_NONE;
+				_param->vthresh = 50.0;
+				_param->bthresh = 50.0;
+				_param->dthresh = 7.0;
+				_param->blend = false;
+				_param->nt = 10;	// Noise tolerance
+				_param->y0 = 0;		// Zone to try (avoid subs)
+				_param->y1 = 0;
+				_param->hints = true;
+				_param->show = false;
+				_param->debug = false; 
+
+		}
+				 
+				
+		tff = (_param->order == 0 ? false : true);	
+
+		_param->back_saved = _param->back;
+
+		// Set up pattern guidance.
+		cache = (struct CACHE_ENTRY *) ADM_alloc(CACHE_SIZE * sizeof(struct CACHE_ENTRY));
+		for (i = 0; i < CACHE_SIZE; i++)
+		{
+			cache[i].frame = 0xffffffff;
+			cache[i].chosen = 0xff;
+		}
+
+		if (_param->guide == GUIDE_32)
+		{
+			// 24fps to 30 fps telecine.
+			cycle = 5;
+		}
+		if (_param->guide == GUIDE_22)
+		{
+			// PAL guidance (expect the current match to be continued).
+			cycle = 2;
+		}
+		else if (_param->guide == GUIDE_32322)
+		{
+			// 25fps to 30 fps telecine.
+			cycle = 6;
+		}
+
+		// Get needed dynamic storage.
+		vmetric = 0;
+		_param->vthresh_saved = _param->vthresh;
+		xblocks = (_info.width+BLKSIZE-1) / BLKSIZE;
+		yblocks = (_info.height+BLKSIZE-1) / BLKSIZE;
+#ifdef WINDOWED_MATCH
+		matchp = (unsigned int *) ADM_alloc(xblocks * yblocks * sizeof(unsigned int));
+		
+		matchc = (unsigned int *) ADM_alloc(xblocks * yblocks * sizeof(unsigned int));
+		
+#endif
+		sump = (unsigned int *) ADM_alloc(xblocks * yblocks * sizeof(unsigned int));
+		
+		sumc = (unsigned int *) ADM_alloc(xblocks * yblocks * sizeof(unsigned int));
+		
+
+		
+}
+//____________________________________________________________________
+Telecide::~Telecide()
+{
+		unsigned int *p;
+
+		if (cache != NULL) ADM_dealloc(cache);
+#ifdef WINDOWED_MATCH
+		if (matchp != NULL) ADM_dealloc(matchp);
+		if (matchc != NULL) ADM_dealloc(matchc);
+#endif
+		if (sump != NULL) ADM_dealloc(sump);
+		if (sumc != NULL) ADM_dealloc(sumc);
+
+		delete vidCache;
+		vidCache=NULL;
+		
+		
+}
+//____________________________________________________________________
+void Telecide::Show(ADMImage *dst, int frame)
+{
+	char use;
+	
+	if (chosen == P) use = 'p';
+	else if (chosen == C) use = 'c';
+	else use = 'n';
+
+	sprintf(buf, "Telecide %s", VERSION);
+	DrawString(dst, 0, 0, buf);
+
+	sprintf(buf, "Copyright 2003 Donald A. Graft");
+	DrawString(dst, 0, 1, buf);
+
+	sprintf(buf,"frame %d:", frame);
+	DrawString(dst, 0, 3, buf);
+
+	sprintf(buf, "matches: %d  %d  %d", p, c, np);
+	DrawString(dst, 0, 4, buf);
+
+	if (_param->post != POST_NONE)
+	{
+		sprintf(buf,"vmetrics: %d  %d  %d [chosen=%d]", pblock, cblock, npblock, vmetric);
+		DrawString(dst, 0, 5, buf);
+	}
+
+	if (_param->guide != GUIDE_NONE)
+	{
+		sprintf(buf, "pattern mismatch=%0.2f%%", mismatch); 
+		DrawString(dst, 0, 5 + (_param->post != POST_NONE), buf);
+	}
+
+	sprintf(buf,"[%s %c]%s %s",
+		found == true ? "forcing" : "using", use,
+		_param->post != POST_NONE ? (film == true ? " [progressive]" : " [interlaced]") : "",
+		_param->guide != GUIDE_NONE ? status : "");
+	DrawString(dst, 0, 5 + (_param->post != POST_NONE) + (_param->guide != GUIDE_NONE), buf);
+}
+//______________________________________________________________
+void Telecide::Debug(int frame)
+{
+	char use;
+
+	if (chosen == P) use = 'p';
+	else if (chosen == C) use = 'c';
+	else use = 'n';
+	sprintf(buf,"Telecide: frame %d: matches: %d %d %d", frame, p, c, np);
+	OutputDebugString(buf);
+	if (_param->post != POST_NONE)
+	{
+		sprintf(buf,"Telecide: frame %d: vmetrics: %d %d %d [chosen=%d]", frame, pblock, cblock, npblock, vmetric);
+		OutputDebugString(buf);
+	}
+	sprintf(buf,"Telecide: frame %d: [%s %c]%s %s", frame, found == true ? "forcing" : "using", use,
+		_param->post != POST_NONE ? (film == true ? " [progressive]" : " [interlaced]") : "",
+		_param->guide != GUIDE_NONE ? status : "");
+	OutputDebugString(buf);
+}
+
+//______________________________________________________________
+uint8_t Telecide::getFrameNumberNoAlloc(uint32_t frame,
+				uint32_t *len,
+   				ADMImage *data,
+				uint32_t *flags)
+{
+ADMImage *fc;
+uint8_t *fcrp;
+uint8_t *fcrpU,*fcrpV;
+
+uint32_t pframe,nframe;
+
+ADMImage *fp;
+uint8_t *fprp;
+uint8_t *fprpU,*fprpV;
+
+ADMImage *fn;
+uint8_t *fnrp;
+uint8_t *fnrpU,*fnrpV;
+
+ADMImage *lc;
+uint8_t *crp;
+uint8_t *crpU,*crpV;
+
+ADMImage *lp;
+uint8_t *prp;
+uint8_t *prpU,*prpV;
+
+ADMImage *dst;
+uint8_t *dstp;
+uint8_t *dstpU,*dstpV;
+
+ADMImage *final;
+uint8_t *finalp;
+uint8_t *finalpU,*finalpV;
+
+
+#define guide _param->guide
+#define order _param->order
+#define back  _param->back
+
+#define back_saved  _param->back_saved
+#define guide       _param->guide
+#define gthresh     _param->gthresh
+#define post        _param->post
+#define chroma      _param->chroma
+#define vthresh     _param->vthresh
+
+#define vthresh_saved _param->vthresh_saved
+#define hints      _param->hints
+#define show       _param->show
+#define debug      _param->debug
+
+#define bthresh      _param->bthresh
+#define dthresh      _param->dthresh
+#define blend        _param->blend
+
+#define nt      _param->nt
+#define y0      _param->y0
+#define y1      _param->y1
+
+        // Get the current frame.
+        if (frame < 0) frame = 0;
+        if (frame > _info.nb_frames - 1) frame = _info.nb_frames - 1;
+        GETFRAME(frame, fc);
+        fcrp = (unsigned char *) fc->GetReadPtr(PLANAR_Y);
+        //if (vi.IsYV12())
+        {
+                fcrpU = (unsigned char *) fc->GetReadPtr(PLANAR_U);
+                fcrpV = (unsigned char *) fc->GetReadPtr(PLANAR_V);
+        }
+
+        // Get the previous frame.
+        pframe = frame == 0 ? 0 : frame - 1;
+        GETFRAME(pframe, fp);
+        fprp = (unsigned char *) fp->GetReadPtr(PLANAR_Y);
+        //if (vi.IsYV12())
+        {
+                fprpU = (unsigned char *) fp->GetReadPtr(PLANAR_U);
+                fprpV = (unsigned char *) fp->GetReadPtr(PLANAR_V);
+        }
+
+        // Get the next frame metrics if we might need them.
+        nframe = frame >= _info.nb_frames - 1 ? _info.nb_frames - 1 : frame + 1;
+        GETFRAME(nframe, fn);
+        fnrp = (unsigned char *) fn->GetReadPtr(PLANAR_Y);
+        //if (vi.IsYV12())
+        {
+                fnrpU = (unsigned char *) fn->GetReadPtr(PLANAR_U);
+                fnrpV = (unsigned char *) fn->GetReadPtr(PLANAR_V);
+        }
+
+        pitch = fc->GetPitch(PLANAR_Y);
+        pitchover2 = pitch >> 1;
+        pitchtimes4 = pitch << 2;
+        w = fc->GetRowSize(PLANAR_Y);
+        h = fc->GetHeight(PLANAR_Y);
+/*
+        if (vi.IsYUY2() && ((w/2) & 1))
+                env->ThrowError("Telecide: width must be a multiple of 2; use Crop");
+        if (vi.IsYV12() && (w & 1))
+                env->ThrowError("Telecide: width must be a multiple of 2; use Crop");
+        if (h & 1)
+                env->ThrowError("Telecide: height must be a multiple of 2; use Crop");
+*/
+        wover2 = w/2;
+        hover2 = h/2;
+        hplus1over2 = (h+1)/2;
+        hminus2= h - 2;
+        //dst = env->NewVideoFrame(vi);
+        dst=data;
+        dpitch = dst->GetPitch(PLANAR_Y);
+
+        // Ensure that the metrics for the frames
+        // after the current frame are in the cache. They will be used for
+        // pattern guidance.
+        if (guide != GUIDE_NONE)
+        {
+                for (y = frame + 1; y <= frame + cycle + 1; y++)
+                {
+                        if (y > _info.nb_frames - 1) break;
+                        if (CacheQuery(y, &p, &pblock, &c, &cblock) == false)
+                        {
+                                GETFRAME(y, lc);
+                                crp = (unsigned char *) lc->GetReadPtr(PLANAR_Y);
+                                //if (vi.IsYV12())
+                                {
+                                        crpU = (unsigned char *) lc->GetReadPtr(PLANAR_U);
+                                        crpV = (unsigned char *) lc->GetReadPtr(PLANAR_V);
+                                }
+                                GETFRAME(y == 0 ? 1 : y - 1, lp);
+                                prp = (unsigned char *) lp->GetReadPtr(PLANAR_Y);
+                                //if (vi.IsYV12())
+                                {
+                                        prpU = (unsigned char *) lp->GetReadPtr(PLANAR_U);
+                                        prpV = (unsigned char *) lp->GetReadPtr(PLANAR_V);
+                                }
+                                CalculateMetrics(y, crp, crpU, crpV, prp, prpU, prpV);
+                        }
+                }
+        }
+
+        /* Check for manual overrides of the field matching. */
+        
+        found = false;
+        film = true;
+        
+        inpattern = false;
+        vthresh = vthresh_saved;
+        back = back_saved;
+#if 0
+        overrides_p = overrides;
+        override = false;
+        if (overrides_p != NULL)
+        {
+                while (*overrides_p < 0xffffffff)
+                {
+                        // If the frame is in range...
+                        if (((unsigned int) frame >= *overrides_p) && ((unsigned int) frame <= *(overrides_p+1)))
+                        {
+                                // and it's a single specifier. 
+                                if (*(overrides_p+3) == 'p' || *(overrides_p+3) == 'c' || *(overrides_p+3) == 'n')
+                                {
+                                        // Get the match specifier and stop parsing.
+                                        switch(*(overrides_p+3))
+                                        {
+                                        case 'p': chosen = P; lowest = cache[frame%CACHE_SIZE].metrics[P]; found = true; break;
+                                        case 'c': chosen = C; lowest = cache[frame%CACHE_SIZE].metrics[C]; found = true; break;
+                                        case 'n': chosen = N; lowest = cache[(frame+1)%CACHE_SIZE].metrics[P]; found = true; break;
+                                        }
+                                }
+                                else if (*(overrides_p+3) == 'b')
+                                {
+                                        back = *(overrides_p+2);
+                                }
+                                else if (*(overrides_p+3) == 'm')
+                                {
+                                        // It's a multiple match specifier.
+                                        found = true;
+                                        // Get the pointer to the specifier string.
+                                        unsigned int *x = (unsigned int *) *(overrides_p+2);
+                                        // Get the index into the specification string.
+                                        // Remember, the count is first followed by the specifiers.
+                                        int ndx = ((frame - *overrides_p) % *x);
+                                        // Point to the specifier string.
+                                        x++;
+                                        // Load the specifier for this frame and stop parsing.
+                                        switch(x[ndx])
+                                        {
+                                        case 'p': chosen = P; lowest = cache[frame%CACHE_SIZE].metrics[P]; break;
+                                        case 'c': chosen = C; lowest = cache[frame%CACHE_SIZE].metrics[C]; break;
+                                        case 'n': chosen = N; lowest = cache[(frame+1)%CACHE_SIZE].metrics[P]; break;
+                                        }
+                                }
+                        }
+                        // Next override line.
+                        overrides_p += 4;
+                }
+        }
+#endif
+        // Get the metrics for the current-previous (p), current-current (c), and current-next (n) match candidates.
+        if (CacheQuery(frame, &p, &pblock, &c, &cblock) == false)
+        {
+                CalculateMetrics(frame, fcrp, fcrpU, fcrpV, fprp, fprpU, fprpV);
+                CacheQuery(frame, &p, &pblock, &c, &cblock);
+        }
+        if (CacheQuery(nframe, &np, &npblock, &nc, &ncblock) == false)
+        {
+                CalculateMetrics(nframe, fnrp, fnrpU, fnrpV, fcrp, fcrpU, fcrpV);
+                CacheQuery(nframe, &np, &npblock, &nc, &ncblock);
+        }
+
+        // Determine the best candidate match.
+        if (found != true)
+        {
+                lowest = c;
+                chosen = C;
+                if (back == ALWAYS_BACK && p < lowest)
+                {
+                        lowest = p;
+                        chosen = P;
+                }
+                if (np < lowest)
+                {
+                        lowest = np;
+                        chosen = N;
+                }
+        }
+        if ((frame == 0 && chosen == P) || (frame == _info.nb_frames - 1 && chosen == N))
+        {
+                chosen = C;
+                lowest = c;
+        }
+
+        // See if we can apply pattern guidance.
+        mismatch = 100.0;
+        if (guide != GUIDE_NONE)
+        {
+                hard = false;
+                if (frame >= cycle && PredictHardYUY2(frame, &predicted, &predicted_metric) == true)
+                {
+                        inpattern = true;
+                        mismatch = 0.0;
+                        hard = true;
+                        if (chosen != predicted)
+                        {
+                                // The chosen frame doesn't match the prediction.
+                                if (predicted_metric == 0) mismatch = 0.0;
+                                else mismatch = (100.0*abs(predicted_metric - lowest))/predicted_metric;
+                                if (mismatch < gthresh)
+                                {
+                                        // It's close enough, so use the predicted one.
+                                        if (found != true)
+                                        {
+                                                chosen = predicted;
+                                                override = true;
+                                        }
+                                }
+                                else
+                                {
+                                        hard = false;
+                                        inpattern = false;
+                                }
+                        }
+                }
+
+                if (hard == false && guide != GUIDE_22)
+                {
+                        int i;
+                        struct PREDICTION *pred = PredictSoftYUY2(frame);
+
+                        if ((frame <= _info.nb_frames - 1 - cycle) &&     (pred[0].metric != 0xffffffff))
+                        {
+                                // Apply pattern guidance.
+                                // If the predicted match metric is within defined percentage of the
+                                // best calculated one, then override the calculated match with the
+                                // predicted match.
+                                i = 0;
+                                while (pred[i].metric != 0xffffffff)
+                                {
+                                        predicted = pred[i].predicted;
+                                        predicted_metric = pred[i].predicted_metric;
+#ifdef DEBUG_PATTERN_GUIDANCE
+                                        sprintf(buf, "%d: predicted = %d\n", frame, predicted);
+                                        OutputDebugString(buf);
+#endif
+                                        if (chosen != predicted)
+                                        {
+                                                // The chosen frame doesn't match the prediction.
+                                                if (predicted_metric == 0) mismatch = 0.0;
+                                                else mismatch = (100.0*abs(predicted_metric - lowest))/predicted_metric;
+                                                if ((int) mismatch <= gthresh)
+                                                {
+                                                        // It's close enough, so use the predicted one.
+                                                        if (found != true)
+                                                        {
+                                                                chosen = predicted;
+                                                                override = true;
+                                                        }
+                                                        inpattern = true;
+                                                        break;
+                                                }
+                                                else
+                                                {
+                                                        // Looks like we're not in a predictable pattern.
+                                                        inpattern = false;
+                                                }
+                                        }
+                                        else
+                                        {
+                                                inpattern = true;
+                                                mismatch = 0.0;
+                                                break;
+                                        }
+                                        i++;
+                                }
+                        }
+                }
+        }
+
+        // Check for overrides of vthresh.
+#if 0
+        overrides_p = overrides;
+        if (overrides_p != NULL)
+        {
+                while (*overrides_p < 0xffffffff)
+                {
+                        // If the frame is in range...
+                        if (((unsigned int) frame >= *overrides_p) && ((unsigned int) frame <= *(overrides_p+1)))
+                        {
+                                if (*(overrides_p+3) == 'v')
+                                {
+                                        vthresh = *(overrides_p+2);
+                                }
+                        }
+                        // Next override line.
+                        overrides_p += 4;
+                }
+        }
+#endif
+        // Check the match for progressive versus interlaced.
+        if (post != POST_NONE)
+        {
+                if (chosen == P) vmetric = pblock;
+                else if (chosen == C) vmetric = cblock;
+                else if (chosen == N) vmetric = npblock;
+
+                if (found == false && back == BACK_ON_COMBED && vmetric > bthresh && p < lowest)
+                {
+                        // Backward match.
+                        vmetric = pblock;
+                        chosen = P;
+                        inpattern = false;
+                        mismatch = 100;
+                }
+                if (vmetric > vthresh)
+                {
+                        // After field matching and pattern guidance the frame is still combed.
+                        film = false;
+                        if (found == false && (post == POST_FULL_NOMATCH || post == POST_FULL_NOMATCH_MAP))
+                        {
+                                chosen = C;
+                                vmetric = cblock;
+                                inpattern = false;
+                                mismatch = 100;
+                        }
+                }
+        }
+        vthresh = vthresh_saved;
+
+        // Setup strings for debug info.
+        if (inpattern == true && override == false) strcpy(status, "[in-pattern]");
+        else if (inpattern == true && override == true) strcpy(status, "[in-pattern*]");
+        else strcpy(status, "[out-of-pattern]");
+
+        // Assemble and output the reconstructed frame according to the final match.
+        dstp = dst->GetWritePtr(PLANAR_Y);
+//    if (vi.IsYV12())
+        {
+                dstpU = dst->GetWritePtr(PLANAR_U);
+                dstpV = dst->GetWritePtr(PLANAR_V);
+        }
+        if (chosen == N)
+        {
+                // The best match was with the next frame.
+                if (tff == true)
+                {
+                        BitBlt(dstp, 2 * dpitch, fnrp, 2 * pitch, w, hover2);
+                        BitBlt(dstp + dpitch, 2 * dpitch, fcrp + pitch, 2 * pitch, w, hover2);
+                        //if (vi.IsYV12())
+                        {
+                                BitBlt(dstpU, dpitch, fnrpU, pitch, w/2, h/4);
+                                BitBlt(dstpV, dpitch, fnrpV, pitch, w/2, h/4);
+                                BitBlt(dstpU + dpitch/2, dpitch, fcrpU + pitch/2, pitch, w/2, h/4);
+                                BitBlt(dstpV + dpitch/2, dpitch, fcrpV + pitch/2, pitch, w/2, h/4);
+                        }
+                }
+                else
+                {
+                        BitBlt(dstp, 2 * dpitch, fcrp, 2 * pitch, w, hplus1over2);
+                        BitBlt(dstp + dpitch, 2 * dpitch, fnrp + pitch, 2 * pitch, w, hover2);
+                        //if (vi.IsYV12())
+                        {
+                                BitBlt(dstpU, dpitch, fcrpU, pitch, w/2, h/4);
+                                BitBlt(dstpV, dpitch, fcrpV, pitch, w/2, h/4);
+                                BitBlt(dstpU + dpitch/2, dpitch, fnrpU + pitch/2, pitch, w/2, h/4);
+                                BitBlt(dstpV + dpitch/2, dpitch, fnrpV + pitch/2, pitch, w/2, h/4);
+                        }
+                }
+        }
+        else if (chosen == C)
+        {
+                // The best match was with the current frame.
+                BitBlt(dstp, 2 * dpitch, fcrp, 2 * pitch, w, hplus1over2);
+                BitBlt(dstp + dpitch, 2 * dpitch, fcrp + pitch, 2 * pitch, w, hover2);
+                //if (vi.IsYV12())
+                {
+                        BitBlt(dstpU, dpitch, fcrpU, pitch, w/2, h/4);
+                        BitBlt(dstpV, dpitch, fcrpV, pitch, w/2, h/4);
+                        BitBlt(dstpU + dpitch/2, dpitch, fcrpU + pitch/2, pitch, w/2, h/4);
+                        BitBlt(dstpV + dpitch/2, dpitch, fcrpV + pitch/2, pitch, w/2, h/4);
+                }
+        }
+        else if (tff == false)
+        {
+                // The best match was with the previous frame.
+                BitBlt(dstp, 2 * dpitch, fprp, 2 * pitch, w, hplus1over2);
+                BitBlt(dstp + dpitch, 2 * dpitch, fcrp + pitch, 2 * pitch, w, hover2);
+               // if (vi.IsYV12())
+                {
+                        BitBlt(dstpU, dpitch, fprpU, pitch, w/2, h/4);
+                        BitBlt(dstpV, dpitch, fprpV, pitch, w/2, h/4);
+                        BitBlt(dstpU + dpitch/2, dpitch, fcrpU + pitch/2, pitch, w/2, h/4);
+                        BitBlt(dstpV + dpitch/2, dpitch, fcrpV + pitch/2, pitch, w/2, h/4);
+                }
+        }
+        else
+        {
+                // The best match was with the previous frame.
+                BitBlt(dstp, 2 * dpitch, fcrp, 2 * pitch, w, hplus1over2);
+                BitBlt(dstp + dpitch, 2 * dpitch, fprp + pitch, 2 * pitch, w, hover2);
+               // if (vi.IsYV12())
+                {
+                        BitBlt(dstpU, dpitch, fcrpU, pitch, w/2, h/4);
+                        BitBlt(dstpV, dpitch, fcrpV, pitch, w/2, h/4);
+                        BitBlt(dstpU + dpitch/2, dpitch, fprpU + pitch/2, pitch, w/2, h/4);
+                        BitBlt(dstpV + dpitch/2, dpitch, fprpV + pitch/2, pitch, w/2, h/4);
+                }
+        }
+        if (guide != GUIDE_NONE) PutChosen(frame, chosen);
+
+        /* Check for manual overrides of the deinterlacing. */
+#if 0
+        overrides_p = overrides;
+        force = 0;
+        if (overrides_p != NULL)
+        {
+                while (*overrides_p < 0xffffffff)
+                {
+                        // Is the frame in range...
+                        if (((unsigned int) frame >= *overrides_p) && ((unsigned int) frame <= *(overrides_p+1)) &&
+                                // and is it a single specifier...
+                                (*(overrides_p+2) == 0) &&
+                                // and is it a deinterlacing specifier?
+                                (*(overrides_p+3) == '+' || *(overrides_p+3) == '-'))
+                        {
+                                // Yes, load the specifier and stop parsing.
+                                overrides_p += 3;
+                                force = *overrides_p;
+                                break;
+                        }
+                        // Next specification record.
+                        overrides_p += 4;
+                }
+        }
+#endif
+        // Do postprocessing if enabled and required for this frame.
+        if (post == POST_NONE || post == POST_METRICS)
+        {
+                if (force == '+') film = false;
+                else if (force == '-') film = true;
+        }
+        else if ((force == '+') ||
+                ((post == POST_FULL || post == POST_FULL_MAP || post == POST_FULL_NOMATCH || post == POST_FULL_NOMATCH_MAP)
+                         && (film == false && force != '-')))
+        {
+                unsigned char *dstpp, *dstpn;
+                int v1, v2, z;
+
+                if (blend == true)
+                {
+                        // Blend mode.
+                        final = data; //env->NewVideoFrame(vi);
+                        // Do first and last lines.
+                        finalp = final->GetWritePtr(PLANAR_Y);
+                        dstp = dst->GetWritePtr(PLANAR_Y);
+                        dstpn = dstp + dpitch;
+                        for (x = 0; x < w; x++)
+                        {
+                                finalp[x] = (((int)dstp[x] + (int)dstpn[x]) >> 1);
+                        }
+                        finalp = final->GetWritePtr(PLANAR_Y) + (h-1)*dpitch;
+                        dstp = dst->GetWritePtr(PLANAR_Y) + (h-1)*dpitch;
+                        dstpp = dstp - dpitch;
+                        for (x = 0; x < w; x++)
+                        {
+                                finalp[x] = (((int)dstp[x] + (int)dstpp[x]) >> 1);
+                        }
+                        // Now do the rest.
+                        dstp = dst->GetWritePtr(PLANAR_Y) + dpitch;
+                        dstpp = dstp - dpitch;
+                        dstpn = dstp + dpitch;
+                        finalp = final->GetWritePtr(PLANAR_Y) + dpitch;
+                        for (y = 1; y < h - 1; y++)
+                        {
+                                for (x = 0; x < w; x++)
+                                {
+                                        v1 = (int) dstp[x] - dthresh;
+                                        if (v1 < 0) v1 = 0; 
+                                        v2 = (int) dstp[x] + dthresh;
+                                        if (v2 > 235) v2 = 235; 
+                                        if ((v1 > dstpp[x] && v1 > dstpn[x]) || (v2 < dstpp[x] && v2 < dstpn[x]))
+                                        {
+                                                if (post == POST_FULL_MAP || post == POST_FULL_NOMATCH_MAP)
+                                                {
+                                                        if (0) //(vi.IsYUY2())
+                                                        {
+                                                                if (x & 1) finalp[x] = 128;
+                                                                else finalp[x] = 235;
+                                                        }
+                                                        else
+                                                        {
+                                                                finalp[x] = 235;
+                                                        }
+                                                }
+                                                else
+                                                        finalp[x] = ((int)dstpp[x] + (int)dstpn[x] + (int)dstp[x] + (int)dstp[x]) >> 2;
+                                        }
+                                        else finalp[x] = dstp[x];
+                                }
+                                finalp += dpitch;
+                                dstp += dpitch;
+                                dstpp += dpitch;
+                                dstpn += dpitch;
+                        }
+
+                      //  if (vi.IsYV12())
+                        {
+                                // Chroma planes.
+                                for (z = 0; z < 2; z++)
+                                {
+                                        if (z == 0)
+                                        {
+                                                // Do first and last lines.
+                                                finalp = final->GetWritePtr(PLANAR_U);
+                                                dstp = dst->GetWritePtr(PLANAR_U);
+                                                dstpn = dstp + dpitch/2;
+                                                for (x = 0; x < wover2; x++)
+                                                {
+                                                        finalp[x] = (((int)dstp[x] + (int)dstpn[x]) >> 1);
+                                                }
+                                                finalp = final->GetWritePtr(PLANAR_U) + (hover2-1)*dpitch/2;
+                                                dstp = dst->GetWritePtr(PLANAR_U) + (hover2-1)*dpitch/2;
+                                                dstpp = dstp - dpitch/2;
+                                                for (x = 0; x < wover2; x++)
+                                                {
+                                                        finalp[x] = (((int)dstp[x] + (int)dstpp[x]) >> 1);
+                                                }
+                                                // Now do the rest.
+                                                finalp = final->GetWritePtr(PLANAR_U) + dpitch/2;
+                                                dstp = dst->GetWritePtr(PLANAR_U) + dpitch/2;
+                                        }
+                                        else
+                                        {
+                                                // Do first and last lines.
+                                                finalp = final->GetWritePtr(PLANAR_V);
+                                                dstp = dst->GetWritePtr(PLANAR_V);
+                                                dstpn = dstp + dpitch/2;
+                                                for (x = 0; x < wover2; x++)
+                                                {
+                                                        finalp[x] = (((int)dstp[x] + (int)dstpn[x]) >> 1);
+                                                }
+                                                finalp = final->GetWritePtr(PLANAR_V) + (hover2-1)*dpitch/2;
+                                                dstp = dst->GetWritePtr(PLANAR_V) + (hover2-1)*dpitch/2;
+                                                dstpp = dstp - dpitch/2;
+                                                for (x = 0; x < wover2; x++)
+                                                {
+                                                        finalp[x] = (((int)dstp[x] + (int)dstpp[x]) >> 1);
+                                                }
+                                                // Now do the rest.
+                                                finalp = final->GetWritePtr(PLANAR_V) + dpitch/2;
+                                                dstp = dst->GetWritePtr(PLANAR_V) + dpitch/2;
+                                        }
+                                        dstpp = dstp - dpitch/2;
+                                        dstpn = dstp + dpitch/2;
+                                        for (y = 1; y < hover2 - 1; y++)
+                                        {
+                                                for (x = 0; x < wover2; x++)
+                                                {
+                                                        v1 = (int) dstp[x] - dthresh;
+                                                        if (v1 < 0) v1 = 0; 
+                                                        v2 = (int) dstp[x] + dthresh;
+                                                        if (v2 > 235) v2 = 235; 
+                                                        if ((v1 > dstpp[x] && v1 > dstpn[x]) || (v2 < dstpp[x] && v2 < dstpn[x]))
+                                                        {
+                                                                if (post == POST_FULL_MAP || post == POST_FULL_NOMATCH_MAP)
+                                                                {
+                                                                        finalp[x] = 128;
+                                                                }
+                                                                else
+                                                                        finalp[x] = ((int)dstpp[x] + (int)dstpn[x] + (int)dstp[x] + (int)dstp[x]) >> 2;
+                                                        }
+                                                        else finalp[x] = dstp[x];
+                                                }
+                                                finalp += dpitch/2;
+                                                dstp += dpitch/2;
+                                                dstpp += dpitch/2;
+                                                dstpn += dpitch/2;
+                                        }
+                                }
+                        }
+                        if (show == true) Show(final, frame);
+                        if (debug == true) Debug(frame);
+                        if (hints == true) WriteHints(final->GetWritePtr(PLANAR_Y), film, inpattern);
+                       // return final;
+                        vidCache->unlockAll();
+                        return 1;
+                }
+
+                // Interpolate mode.
+                // Luma plane.
+                dstp = dst->GetWritePtr(PLANAR_Y) + dpitch;
+                dstpp = dstp - dpitch;
+                dstpn = dstp + dpitch;
+                for (y = 1; y < h - 1; y+=2)
+                {
+                        for (x = 0; x < w; x++)
+                        {
+                                v1 = (int) dstp[x] - dthresh;
+                                if (v1 < 0) v1 = 0; 
+                                v2 = (int) dstp[x] + dthresh;
+                                if (v2 > 235) v2 = 235; 
+                                if ((v1 > dstpp[x] && v1 > dstpn[x]) || (v2 < dstpp[x] && v2 < dstpn[x]))
+                                {
+                                        if (post == POST_FULL_MAP || post == POST_FULL_NOMATCH_MAP)
+                                        {
+                                                if(0) // (vi.IsYUY2())
+                                                {
+                                                        if (x & 1) dstp[x] = 128;
+                                                        else dstp[x] = 235;
+                                                }
+                                                else
+                                                {
+                                                        dstp[x] = 235;
+                                                }
+                                        }
+                                        else
+                                                dstp[x] = (dstpp[x] + dstpn[x]) >> 1;
+                                }
+                        }
+                        dstp += 2*dpitch;
+                        dstpp += 2*dpitch;
+                        dstpn += 2*dpitch;
+                }
+
+               // if (vi.IsYV12())
+                {
+                        // Chroma planes.
+                        for (z = 0; z < 2; z++)
+                        {
+                                if (z == 0) dstp = dst->GetWritePtr(PLANAR_U) + dpitch/2;
+                                else dstp = dst->GetWritePtr(PLANAR_V) + dpitch/2;
+                                dstpp = dstp - dpitch/2;
+                                dstpn = dstp + dpitch/2;
+                                for (y = 1; y < hover2 - 1; y+=2)
+                                {
+                                        for (x = 0; x < wover2; x++)
+                                        {
+                                                v1 = (int) dstp[x] - dthresh;
+                                                if (v1 < 0) v1 = 0; 
+                                                v2 = (int) dstp[x] + dthresh;
+                                                if (v2 > 235) v2 = 235; 
+                                                if ((v1 > dstpp[x] && v1 > dstpn[x]) || (v2 < dstpp[x] && v2 < dstpn[x]))
+                                                {
+                                                        if (post == POST_FULL_MAP || post == POST_FULL_NOMATCH_MAP)
+                                                        {
+                                                                dstp[x] = 128;
+                                                        }
+                                                        else
+                                                                dstp[x] = (dstpp[x] + dstpn[x]) >> 1;
+                                                }
+                                        }
+                                        dstp += dpitch;
+                                        dstpp += dpitch;
+                                        dstpn += dpitch;
+                                }
+                        }
+                }
+        }
+
+        if (show == true) Show(dst, frame);
+        if (debug == true) Debug(frame);
+        if (hints == true) WriteHints(dst->GetWritePtr(PLANAR_Y), film, inpattern);
+        vidCache->unlockAll();
+        //return dst;
+        return 1;
+}
+void Telecide::CalculateMetrics(int frame, unsigned char *fcrp, unsigned char *fcrpU, unsigned char *fcrpV,
+                                                                        unsigned char *fprp, unsigned char *fprpU, unsigned char *fprpV)
+{
+        int x, y, p, c, tmp1, tmp2, skip;
+        bool vc;
+    unsigned char *currbot0, *currbot2, *prevbot0, *prevbot2;
+        unsigned char *prevtop0, *prevtop2, *prevtop4, *currtop0, *currtop2, *currtop4;
+        unsigned char *a0, *a2, *b0, *b2, *b4;
+        unsigned int diff, index;
+#define T 4
+
+        /* Clear the block sums. */
+        for (y = 0; y < yblocks; y++)
+        {
+                for (x = 0; x < xblocks; x++)
+                {
+#ifdef WINDOWED_MATCH
+                        matchp[y*xblocks+x] = 0;
+                        matchc[y*xblocks+x] = 0;
+#endif
+                        sump[y*xblocks+x] = 0;
+                        sumc[y*xblocks+x] = 0;
+                }
+        }
+
+        /* Find the best field match. Subsample the frames for speed. */
+        currbot0  = fcrp + pitch;
+        currbot2  = fcrp + 3 * pitch;
+        currtop0 = fcrp;
+        currtop2 = fcrp + 2 * pitch;
+        currtop4 = fcrp + 4 * pitch;
+        prevbot0  = fprp + pitch;
+        prevbot2  = fprp + 3 * pitch;
+        prevtop0 = fprp;
+        prevtop2 = fprp + 2 * pitch;
+        prevtop4 = fprp + 4 * pitch;
+        if (tff == true)
+        {
+                a0 = prevbot0;
+                a2 = prevbot2;
+                b0 = currtop0;
+                b2 = currtop2;
+                b4 = currtop4;
+        }
+        else
+        {
+                a0 = currbot0;
+                a2 = currbot2;
+                b0 = prevtop0;
+                b2 = prevtop2;
+                b4 = prevtop4;
+        }
+        p = c = 0;
+
+        // Calculate the field match and film/video metrics.
+        //if (vi.IsYV12()) skip = 1;
+        if(1) skip=1;
+        else skip = 1 + (chroma == false);
+        for (y = 0, index = 0; y < h - 4; y+=4)
+        {
+                /* Exclusion band. Good for ignoring subtitles. */
+                if (y0 == y1 || y < y0 || y > y1)
+                {
+                        for (x = 0; x < w;)
+                        {
+                                if (1) //vi.IsYV12())
+                                        index = (y/BLKSIZE)*xblocks + x/BLKSIZE;
+                                else
+                                        index = (y/BLKSIZE)*xblocks + x/BLKSIZE_TIMES2;
+
+                                // Test combination with current frame.
+                                tmp1 = ((long)currbot0[x] + (long)currbot2[x]);
+//                              diff = abs((long)currtop0[x] - (tmp1 >> 1));
+                                diff = abs((((long)currtop0[x] + (long)currtop2[x] + (long)currtop4[x])) - (tmp1 >> 1) - tmp1);
+                                if (diff > nt)
+                                {
+                                        c += diff;
+#ifdef WINDOWED_MATCH
+                                        matchc[index] += diff;
+#endif
+                                }
+
+                                tmp1 = currbot0[x] + T;
+                                tmp2 = currbot0[x] - T;
+                                vc = (tmp1 < currtop0[x] && tmp1 < currtop2[x]) ||
+                                         (tmp2 > currtop0[x] && tmp2 > currtop2[x]);
+                                if (vc)
+                                {
+                                        sumc[index]++;
+                                }
+
+                                // Test combination with previous frame.
+                                tmp1 = ((long)a0[x] + (long)a2[x]);
+                                diff = abs((((long)b0[x] + (long)b2[x] + (long)b4[x])) - (tmp1 >> 1) - tmp1);
+                                if (diff > nt)
+                                {
+                                        p += diff;
+#ifdef WINDOWED_MATCH
+                                        matchp[index] += diff;
+#endif
+                                }
+
+                                tmp1 = a0[x] + T;
+                                tmp2 = a0[x] - T;
+                                vc = (tmp1 < b0[x] && tmp1 < b2[x]) ||
+                                         (tmp2 > b0[x] && tmp2 > b2[x]);
+                                if (vc)
+                                {
+                                        sump[index]++;
+                                }
+
+                                x += skip;
+                                if (!(x&3)) x += 4;
+                        }
+                }
+                currbot0 += pitchtimes4;
+                currbot2 += pitchtimes4;
+                currtop0 += pitchtimes4;
+                currtop2 += pitchtimes4;
+                currtop4 += pitchtimes4;
+                a0               += pitchtimes4;
+                a2               += pitchtimes4;
+                b0               += pitchtimes4;
+                b2               += pitchtimes4;
+                b4               += pitchtimes4;
+        }
+
+       // if (vi.IsYV12() && chroma == true)
+        if ( chroma == true)
+        {
+                int z;
+
+                for (z = 0; z < 2; z++)
+                {
+                        // Do the same for the U plane.
+                        if (z == 0)
+                        {
+                                currbot0  = fcrpU + pitchover2;
+                                currbot2  = fcrpU + 3 * pitchover2;
+                                currtop0 = fcrpU;
+                                currtop2 = fcrpU + 2 * pitchover2;
+                                currtop4 = fcrpU + 4 * pitchover2;
+                                prevbot0  = fprpU + pitchover2;
+                                prevbot2  = fprpU + 3 * pitchover2;
+                                prevtop0 = fprpU;
+                                prevtop2 = fprpU + 2 * pitchover2;
+                                prevtop4 = fprpU + 4 * pitchover2;
+                        }
+                        else
+                        {
+                                currbot0  = fcrpV + pitchover2;
+                                currbot2  = fcrpV + 3 * pitchover2;
+                                currtop0 = fcrpV;
+                                currtop2 = fcrpV + 2 * pitchover2;
+                                currtop4 = fcrpV + 4 * pitchover2;
+                                prevbot0  = fprpV + pitchover2;
+                                prevbot2  = fprpV + 3 * pitchover2;
+                                prevtop0 = fprpV;
+                                prevtop2 = fprpV + 2 * pitchover2;
+                                prevtop4 = fprpV + 4 * pitchover2;
+                        }
+                        if (tff == true)
+                        {
+                                a0 = prevbot0;
+                                a2 = prevbot2;
+                                b0 = currtop0;
+                                b2 = currtop2;
+                                b4 = currtop4;
+                        }
+                        else
+                        {
+                                a0 = currbot0;
+                                a2 = currbot2;
+                                b0 = prevtop0;
+                                b2 = prevtop2;
+                                b4 = prevtop4;
+                        }
+
+                        for (y = 0, index = 0; y < hover2 - 4; y+=4)
+                        {
+                                /* Exclusion band. Good for ignoring subtitles. */
+                                if (y0 == y1 || y < y0/2 || y > y1/2)
+                                {
+                                        for (x = 0; x < wover2;)
+                                        {
+                                                if (1) //vi.IsYV12())
+                                                        index = (y/BLKSIZE)*xblocks + x/BLKSIZE;
+                                                else
+                                                        index = (y/BLKSIZE)*xblocks + x/BLKSIZE_TIMES2;
+
+                                                // Test combination with current frame.
+                                                tmp1 = ((long)currbot0[x] + (long)currbot2[x]);
+                                                diff = abs((((long)currtop0[x] + (long)currtop2[x] + (long)currtop4[x])) - (tmp1 >> 1) - tmp1);
+                                                if (diff > nt)
+                                                {
+                                                        c += diff;
+#ifdef WINDOWED_MATCH
+                                                        matchc[index] += diff;
+#endif
+                                                }
+
+                                                tmp1 = currbot0[x] + T;
+                                                tmp2 = currbot0[x] - T;
+                                                vc = (tmp1 < currtop0[x] && tmp1 < currtop2[x]) ||
+                                                         (tmp2 > currtop0[x] && tmp2 > currtop2[x]);
+                                                if (vc)
+                                                {
+                                                        sumc[index]++;
+                                                }
+
+                                                // Test combination with previous frame.
+                                                tmp1 = ((long)a0[x] + (long)a2[x]);
+                                                diff = abs((((long)b0[x] + (long)b2[x] + (long)b4[x])) - (tmp1 >> 1) - tmp1);
+                                                if (diff > nt)
+                                                {
+                                                        p += diff;
+#ifdef WINDOWED_MATCH
+                                                        matchp[index] += diff;
+#endif
+                                                }
+
+                                                tmp1 = a0[x] + T;
+                                                tmp2 = a0[x] - T;
+                                                vc = (tmp1 < b0[x] && tmp1 < b2[x]) ||
+                                                         (tmp2 > b0[x] && tmp2 > b2[x]);
+                                                if (vc)
+                                                {
+                                                        sump[index]++;
+                                                }
+
+                                                x ++;
+                                                if (!(x&3)) x += 4;
+                                        }
+                                }
+                                currbot0 += 4*pitchover2;
+                                currbot2 += 4*pitchover2;
+                                currtop0 += 4*pitchover2;
+                                currtop2 += 4*pitchover2;
+                                currtop4 += 4*pitchover2;
+                                a0               += 4*pitchover2;
+                                a2               += 4*pitchover2;
+                                b0               += 4*pitchover2;
+                                b2               += 4*pitchover2;
+                                b4               += 4*pitchover2;
+                        }
+                }
+        }
+
+        // Now find the blocks that have the greatest differences.
+#ifdef WINDOWED_MATCH
+        highest_matchp = 0;
+        for (y = 0; y < yblocks; y++)
+        {
+                for (x = 0; x < xblocks; x++)
+                {
+if (frame == 45 && matchp[y * xblocks + x] > 2500)
+{
+        sprintf(buf, "%d/%d = %d\n", x, y, matchp[y * xblocks + x]);
+        OutputDebugString(buf);
+}
+                        if (matchp[y * xblocks + x] > highest_matchp)
+                        {
+                                highest_matchp = matchp[y * xblocks + x];
+                        }
+                }
+        }
+        highest_matchc = 0;
+        for (y = 0; y < yblocks; y++)
+        {
+                for (x = 0; x < xblocks; x++)
+                {
+if (frame == 44 && matchc[y * xblocks + x] > 2500)
+{
+        sprintf(buf, "%d/%d = %d\n", x, y, matchc[y * xblocks + x]);
+        OutputDebugString(buf);
+}
+                        if (matchc[y * xblocks + x] > highest_matchc)
+                        {
+                                highest_matchc = matchc[y * xblocks + x];
+                        }
+                }
+        }
+#endif
+        if (post != POST_NONE)
+        {
+                highest_sump = 0;
+                for (y = 0; y < yblocks; y++)
+                {
+                        for (x = 0; x < xblocks; x++)
+                        {
+                                if (sump[y * xblocks + x] > highest_sump)
+                                {
+                                        highest_sump = sump[y * xblocks + x];
+                                }
+                        }
+                }
+                highest_sumc = 0;
+                for (y = 0; y < yblocks; y++)
+                {
+                        for (x = 0; x < xblocks; x++)
+                        {
+                                if (sumc[y * xblocks + x] > highest_sumc)
+                                {
+                                        highest_sumc = sumc[y * xblocks + x];
+                                }
+                        }
+                }
+        }
+#ifdef WINDOWED_MATCH
+        CacheInsert(frame, highest_matchp, highest_sump, highest_matchc, highest_sumc);
+#else
+        CacheInsert(frame, p, highest_sump, c, highest_sumc);
+#endif
+}
+bool Telecide::PredictHardYUY2(int frame, unsigned int *predicted, unsigned int *predicted_metric)
+        {
+                // Look for pattern in the actual delivered matches of the previous cycle of frames.
+                // If a pattern is found, use that to predict the current match.
+                if (guide == GUIDE_22)
+                {
+                        if (cache[(frame-cycle)%CACHE_SIZE  ].chosen == 0xff ||
+                                cache[(frame-cycle+1)%CACHE_SIZE].chosen == 0xff)
+                                return false;
+                        switch ((cache[(frame-cycle)%CACHE_SIZE  ].chosen << 4) +
+                                        (cache[(frame-cycle+1)%CACHE_SIZE].chosen))
+                        {
+                        case 0x11:
+                                *predicted = C;
+                                *predicted_metric = cache[frame%CACHE_SIZE].metrics[C];
+                                break;
+                        case 0x22:
+                                *predicted = N;
+                                *predicted_metric = cache[frame%CACHE_SIZE].metrics[N];
+                                break;
+                        default: return false;
+                        }
+                }
+                else if (guide == GUIDE_32)
+                {
+                        if (cache[(frame-cycle)%CACHE_SIZE  ].chosen == 0xff ||
+                                cache[(frame-cycle+1)%CACHE_SIZE].chosen == 0xff ||
+                                cache[(frame-cycle+2)%CACHE_SIZE].chosen == 0xff ||
+                                cache[(frame-cycle+3)%CACHE_SIZE].chosen == 0xff ||
+                                cache[(frame-cycle+4)%CACHE_SIZE].chosen == 0xff)
+                                return false;
+
+                        switch ((cache[(frame-cycle)%CACHE_SIZE  ].chosen << 16) +
+                                        (cache[(frame-cycle+1)%CACHE_SIZE].chosen << 12) +
+                                        (cache[(frame-cycle+2)%CACHE_SIZE].chosen <<  8) +
+                                        (cache[(frame-cycle+3)%CACHE_SIZE].chosen <<  4) +
+                                        (cache[(frame-cycle+4)%CACHE_SIZE].chosen))
+                        {
+                        case 0x11122:
+                        case 0x11221:
+                        case 0x12211:
+                        case 0x12221: 
+                        case 0x21122: 
+                        case 0x11222: 
+                                *predicted = C;
+                                *predicted_metric = cache[frame%CACHE_SIZE].metrics[C];
+                                break;
+                        case 0x22111:
+                        case 0x21112:
+                        case 0x22112: 
+                        case 0x22211: 
+                                *predicted = N;
+                                *predicted_metric = cache[frame%CACHE_SIZE].metrics[N];
+                                break;
+                        default: return false;
+                        }
+                }
+                else if (guide == GUIDE_32322)
+                {
+                        if (cache[(frame-cycle)%CACHE_SIZE  ].chosen == 0xff ||
+                                cache[(frame-cycle+1)%CACHE_SIZE].chosen == 0xff ||
+                                cache[(frame-cycle+2)%CACHE_SIZE].chosen == 0xff ||
+                                cache[(frame-cycle+3)%CACHE_SIZE].chosen == 0xff ||
+                                cache[(frame-cycle+4)%CACHE_SIZE].chosen == 0xff ||
+                                cache[(frame-cycle+5)%CACHE_SIZE].chosen == 0xff)
+                                return false;
+
+                        switch ((cache[(frame-cycle)%CACHE_SIZE  ].chosen << 20) +
+                                        (cache[(frame-cycle+1)%CACHE_SIZE].chosen << 16) +
+                                        (cache[(frame-cycle+2)%CACHE_SIZE].chosen << 12) +
+                                        (cache[(frame-cycle+3)%CACHE_SIZE].chosen <<  8) +
+                                        (cache[(frame-cycle+4)%CACHE_SIZE].chosen <<  4) +
+                                        (cache[(frame-cycle+5)%CACHE_SIZE].chosen))
+                        {
+                        case 0x111122:
+                        case 0x111221:
+                        case 0x112211:
+                        case 0x122111:
+                        case 0x111222: 
+                        case 0x112221:
+                        case 0x122211:
+                        case 0x222111: 
+                                *predicted = C;
+                                *predicted_metric = cache[frame%CACHE_SIZE].metrics[C];
+                                break;
+                        case 0x221111:
+                        case 0x211112:
+
+                        case 0x221112: 
+                        case 0x211122: 
+                                *predicted = N;
+                                *predicted_metric = cache[frame%CACHE_SIZE].metrics[N];
+                                break;
+                        default: return false;
+                        }
+                }
+#ifdef DEBUG_PATTERN_GUIDANCE
+                sprintf(buf, "%d: HARD: predicted = %d\n", frame, *predicted);
+                OutputDebugString(buf);
+#endif
+                return true;
+        }
+
+struct PREDICTION *Telecide::PredictSoftYUY2(int frame)
+        {
+                // Use heuristics to look forward for a match.
+                int i, j, y, c, n, phase;
+                unsigned int metric;
+
+                pred[0].metric = 0xffffffff;
+                if (frame < 0 || frame > _info.nb_frames - 1 - cycle) return pred;
+
+                // Look at the next cycle of frames.
+                for (y = frame + 1; y <= frame + cycle; y++)
+                {
+                        // Look for a frame where the current and next match values are
+                        // very close. Those are candidates to predict the phase, because
+                        // that condition should occur only once per cycle. Store the candidate
+                        // phases and predictions in a list sorted by goodness. The list will
+                        // be used by the caller to try the phases in order.
+                        c = cache[y%CACHE_SIZE].metrics[C]; 
+                        n = cache[y%CACHE_SIZE].metrics[N];
+                        if (c == 0) c = 1;
+                        metric = (100 * abs (c - n)) / c;
+                        phase = y % cycle;
+                        if (metric < 5)
+                        {
+                                // Place the new candidate phase in sorted order in the list.
+                                // Find the insertion point.
+                                i = 0;
+                                while (metric > pred[i].metric) i++;
+                                // Find the end-of-list marker.
+                                j = 0;
+                                while (pred[j].metric != 0xffffffff) j++;
+                                // Shift all items below the insertion point down by one to make
+                                // room for the insertion.
+                                j++;
+                                for (; j > i; j--)
+                                {
+                                        pred[j].metric = pred[j-1].metric;
+                                        pred[j].phase = pred[j-1].phase;
+                                        pred[j].predicted = pred[j-1].predicted;
+                                        pred[j].predicted_metric = pred[j-1].predicted_metric;
+                                }
+                                // Insert the new candidate data.
+                                pred[j].metric = metric;
+                                pred[j].phase = phase;
+                                if (guide == GUIDE_32)
+                                {
+                                        switch ((frame % cycle) - phase)
+                                        {
+                                        case -4: pred[j].predicted = N; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[N]; break; 
+                                        case -3: pred[j].predicted = N; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[N]; break; 
+                                        case -2: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
+                                        case -1: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
+                                        case  0: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
+                                        case +1: pred[j].predicted = N; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[N]; break; 
+                                        case +2: pred[j].predicted = N; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[N]; break; 
+                                        case +3: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
+                                        case +4: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
+                                        }
+                                }
+                                else if (guide == GUIDE_32322)
+                                {
+                                        switch ((frame % cycle) - phase)
+                                        {
+                                        case -5: pred[j].predicted = N; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[N]; break; 
+                                        case -4: pred[j].predicted = N; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[N]; break; 
+                                        case -3: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
+                                        case -2: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
+                                        case -1: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
+                                        case  0: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
+                                        case +1: pred[j].predicted = N; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[N]; break; 
+                                        case +2: pred[j].predicted = N; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[N]; break; 
+                                        case +3: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
+                                        case +4: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
+                                        case +5: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
+                                        }
+                                }
+                        }
+#ifdef DEBUG_PATTERN_GUIDANCE
+                        sprintf(buf,"%d: metric = %d phase = %d\n", frame, metric, phase);
+                        OutputDebugString(buf);
+#endif
+                }
+                return pred;
+        }
+

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDecTelecide.h (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDecTelecide.h)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDecTelecide.h	2006-10-31 15:59:58 UTC (rev 2489)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDecTelecide.h	2007-01-13 16:37:32 UTC (rev 2721)
@@ -0,0 +1,143 @@
+/*
+	Telecide plugin for Avisynth -- recovers original progressive
+	frames from  telecined streams. The filter operates by matching
+	fields and automatically adapts to phase/pattern changes.
+
+	Copyright (C) 2003 Donald A. Graft
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program; if not, write to the Free Software
+	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+#include "ADM_video/ADM_cache.h"
+#undef DEBUG_PATTERN_GUIDANCE
+
+#undef WINDOWED_MATCH
+
+#define MAX_CYCLE 6
+#define BLKSIZE 24
+#define BLKSIZE_TIMES2 (2 * BLKSIZE)
+#define GUIDE_NONE 0
+#define GUIDE_32 1
+#define GUIDE_22 2
+#define GUIDE_32322 3
+#define AHEAD 0
+#define BEHIND 1
+#define POST_NONE 0
+#define POST_METRICS 1
+#define POST_FULL 2
+#define POST_FULL_MAP 3
+#define POST_FULL_NOMATCH 4
+#define POST_FULL_NOMATCH_MAP 5
+#define CACHE_SIZE 100000
+#define P 0
+#define C 1
+#define N 2
+#define PBLOCK 3
+#define CBLOCK 4
+
+#define NO_BACK 0
+#define BACK_ON_COMBED 1
+#define ALWAYS_BACK 2
+
+#define OutputDebugString(x) aprintf("%s\n",x)
+typedef uint8_t* PVideoFrame ;
+
+
+struct CACHE_ENTRY
+{
+	unsigned int frame;
+	unsigned int metrics[5];
+	unsigned int chosen;
+};
+
+struct PREDICTION
+{
+	unsigned int metric;
+	unsigned int phase;
+	unsigned int predicted;
+	unsigned int predicted_metric;
+};
+
+#define GETFRAME(g, fp) { int GETFRAMEf; uint32_t len,flags;GETFRAMEf = (g); fp=NULL;if (GETFRAMEf < 0) GETFRAMEf = 0; 	else if (GETFRAMEf >= _info.nb_frames) GETFRAMEf = _info.nb_frames - 1; fp=vidCache->getImage(GETFRAMEf); }
+#include "ADM_vidDecTel_param.h"
+class Telecide : public AVDMGenericVideoStream
+{
+private:
+	TelecideParam *_param;		
+	bool tff;	
+	uint32_t _lastFrame;	
+	int pitch, dpitch, pitchover2, pitchtimes4;
+	int w, h, wover2, hover2, hplus1over2, hminus2;
+	int xblocks, yblocks;
+#ifdef WINDOWED_MATCH
+	unsigned int *matchc, *matchp, highest_matchc, highest_matchp;
+#endif
+	unsigned int *sumc, *sump, highest_sumc, highest_sump;
+	int vmetric;
+	
+	bool film, override, inpattern, found;
+	int force;
+
+	
+	int chosen;
+	unsigned int p, c, pblock, cblock, lowest, predicted, predicted_metric;
+	unsigned int np, nc, npblock, ncblock;
+	float mismatch;
+	int  x, y;
+	
+	bool hard;
+	char status[80];
+
+	// Metrics cache.
+	struct CACHE_ENTRY *cache;
+
+	// Pattern guidance data.
+	int cycle;
+	struct PREDICTION pred[MAX_CYCLE+1];
+
+	// For output message formatting.
+	char buf[255];
+	
+	VideoCache	*vidCache;
+
+public:
+	
+	void CalculateMetrics(int n, unsigned char *crp, unsigned char *crpU, unsigned char *crpV, 
+				unsigned char *prp, unsigned char *prpU, unsigned char *prpV);
+	void Show(ADMImage *dst, int frame);
+	void Debug(int frame);
+
+	       Telecide(AVDMGenericVideoStream *in,CONFcouple *couples);		
+			
+	       ~Telecide();
+
+	void PutChosen(int frame, unsigned int chosen);
+	
+
+	void CacheInsert(int frame, unsigned int p, unsigned int pblock,
+				unsigned int c, unsigned int cblock);
+	
+	bool CacheQuery(int frame, unsigned int *p, unsigned int *pblock,
+				unsigned int *c, unsigned int *cblock);	
+
+	bool PredictHardYUY2(int frame, unsigned int *predicted, unsigned int *predicted_metric) ;
+	
+	struct PREDICTION *PredictSoftYUY2(int frame);
+
+	void WriteHints(unsigned char *dst, bool film, bool inpattern);
+	virtual uint8_t getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
+				ADMImage *data,uint32_t *flags);
+	char *printConf( void );
+	uint8_t configure(AVDMGenericVideoStream *in);
+	uint8_t	getCoupledConf( CONFcouple **couples);
+};

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDeintASM.cpp (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDeintASM.cpp)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDeintASM.cpp	2006-10-31 15:59:58 UTC (rev 2489)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDeintASM.cpp	2007-01-13 16:37:32 UTC (rev 2721)
@@ -0,0 +1,238 @@
+/***************************************************************************
+                          ADM_vidDeintASM.cpp  -  description
+                             -------------------
+    begin                : Tue Jan 7 2003
+    copyright            : (C) 2003 by mean
+    email                : fixounet at free.fr
+
+    Slighlty faster ASM deinterlace
+    Blend later	
+
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ADM_assert.h>
+
+#include "config.h"
+#include "fourcc.h"
+#include "avio.hxx"
+#include "config.h"
+#include "avi_vars.h"
+
+
+
+#include "ADM_toolkit/toolkit.hxx"
+#include "ADM_editor/ADM_edit.hxx"
+#include "ADM_video/ADM_genvideo.hxx"
+
+#include"ADM_vidField.h"
+
+#if defined( ARCH_X86)  || defined(ARCH_X86_64)
+//	#define DEBUG_DEINT 1
+//	#define MMX_TRACE 1
+	#include "mmx_macros.h"
+#include "admmangle.h"
+
+ void myDeintASM(void);
+
+ static int32_t _l_w,_l_h,_l_all;
+ static uint8_t *_l_p,*_l_c,*_l_n;
+ static uint8_t *_l_e,*_l_e2;
+#define EXPAND(x) (x)+((x)<<16)+((x)<<32) +((x)<<48)
+static mmx_t _mmTHRESH1;
+static mmx_t _mmTHRESH2;
+
+#define COMPUTE_MMX \
+punpcklbw_r2r(mm5,mm0);  /*c  expand 4 bytes -> 4 word */ \
+punpcklbw_r2r(mm5,mm1);  /*p*/ \
+punpcklbw_r2r(mm5,mm2); /* n*/ \
+movq_r2r(mm0,mm3);		/* mm3 also c*/ \
+psubw_r2r(mm1,mm0) ; /* mm0=mm0-mm1 =  c-p*/ \
+psubw_r2r(mm2,mm3) ; /* mm3=mm3-mm2 =  c-n*/ \
+psraw_i2r(1,mm0); /* to protect from overflow*/ \
+psraw_i2r(1,mm3);\
+pmullw_r2r(mm0,mm3); /* mm3=(c-p)*(c-n) / 4;*/ \
+movq_r2r(mm3,mm0) ; /* mm0 also c-p*c-n */ \
+pcmpgtw_r2r(mm4,mm3); /* keep only > size*/ \
+pcmpgtw_r2r(mm6,mm0); /* keep only > size*/ \
+packsswb_r2r(mm5,mm0); \
+packsswb_r2r(mm5,mm3);
+
+#endif
+
+void ADMVideoFields::hasMotion_C(uint8_t *p,uint8_t *c,
+								uint8_t *n,
+								uint8_t *e,
+								uint8_t *e2
+								)
+{
+int32_t val,x,y;
+//printf("\nC \n");
+// other line
+       	for(y=_info.height-2;y>0;y--)
+        	{
+               for(x=_info.width;x>0;x--)
+               		{
+                   		val= (*p-*c)*(*n-*c);
+                        if(val>(int32_t)(_param->motion_trigger*_param->motion_trigger))
+                        	{
+                          	*e=0xff;
+                         }
+                         if(val>(int32_t)(_param->blend_trigger*_param->blend_trigger))
+                         	*e2=0xff;
+                         p++;c++;n++;e++;e2++;
+                      }
+           }
+}
+#if defined( ARCH_X86)  || defined(ARCH_X86_64)
+void ADMVideoFields::hasMotion_MMX(uint8_t *p,uint8_t *c,
+									uint8_t *n,
+									uint8_t *e,
+									uint8_t *e2
+									)
+{
+
+
+			 	_mmTHRESH1.uq=EXPAND((uint64_t ) ((_param->motion_trigger*_param->motion_trigger)>>2) );
+				_mmTHRESH2.uq=EXPAND((uint64_t ) ((_param->blend_trigger*_param->blend_trigger)>>2) );
+
+			_l_h=_info.height-2;
+			_l_w=_info.width>>2;
+			_l_all=_l_h*_l_w;
+			_l_p=p;
+			_l_c=c;
+			_l_n=n;
+			_l_e=e;
+			_l_e2=e2;
+//			printf("\n MMX \n");
+
+			pxor_r2r(mm5,mm5);
+			movq_m2r(_mmTHRESH1,mm4);
+			movq_m2r(_mmTHRESH2,mm6);
+			myDeintASM();
+}
+#if !defined(DEBUG_DEINT)
+void myDeintASM(void)
+{
+
+	//printf("\n using  MMX \n");
+
+
+        	{
+
+			__asm__ __volatile__ (
+				"mov "Mangle(_l_c)",	"REG_ax"\n\t"
+				"mov "Mangle(_l_p)",	"REG_bx"\n\t"
+				"mov "Mangle(_l_n)",	"REG_cx"\n\t"
+				"mov "Mangle(_l_all)",	"REG_si"\n\t"
+				"7:"
+				"movd ("REG_ax"),	%%mm0\n\t"
+				"movd ("REG_bx"),	%%mm1\n\t"
+				"movd ("REG_cx"),	%%mm2\n\t"
+				:
+				:
+				: "eax","ebx","ecx","edx","esi" 
+				);
+
+				COMPUTE_MMX;
+
+				/* store result in e, e2 */
+
+			__asm__ __volatile__(
+				"mov 	"Mangle(_l_e)",	"REG_dx"\n\t"
+				"movd	%%mm3,("REG_dx")\n\t"
+
+				"mov 	"Mangle(_l_e2)",	"REG_dx"\n\t"
+				"movd	%%mm0,("REG_dx")\n\t"
+
+				"add 	$4,	"REG_ax"\n\t"
+				"add 	$4,	"REG_bx"\n\t"
+				"add 	$4,	"REG_cx"\n\t"
+				"add 	$4,	"Mangle(_l_e)"\n\t"
+				"add 	$4,	"Mangle(_l_e2)"\n\t"
+				"sub 	$1,	"REG_si"\n\t"
+				"jnz 7b\n\t"
+
+				:
+				:
+				: "eax", "ebx","ecx","edx","esi"
+				);
+	           	}
+	   emms();
+
+}
+#else
+/*************************************************
+***************DEBUG*************************
+**************************************************
+**************************************************/
+
+
+void myDeintASM(void)
+{
+
+int32_t x,y;
+	printf("\n using  MMX debug\n");
+
+       	for(y=_l_h;y>0;y--)
+        	{
+		for(x=_l_w;x>0;x--)
+               		{
+
+			__asm__ __volatile__ (
+				"mov _l_c,	"REG_ax"\n\t"
+				"mov _l_p,	"REG_bx"\n\t"
+				"mov _l_n,	"REG_cx"\n\t"
+				"mov _l_w,	"REG_si"\n\t"
+				"movd ("REG_ax"),	%%mm0\n\t"
+				"movd ("REG_bx"),	%%mm1\n\t"
+				"movd ("REG_cx"),	%%mm2\n\t"
+				:
+				:
+				: "eax", "ebx", "ecx", "edx","esi"
+				);
+			emms();
+				COMPUTE_MMX;
+			emms();
+				/* store result in e, e2 */
+
+			__asm__ __volatile__(
+				"mov 	_l_e,	"REG_dx"\n\t"
+				"movd	%%mm3,("REG_dx")\n\t"
+				//"movd	%%mm3,(%%eax)\n\t"
+
+				"mov 	_l_e2,	"REG_dx"\n\t"
+				"movd	%%mm0,("REG_dx")\n\t"
+
+				:
+				:
+				: "eax","edx","esi"
+				);
+
+			emms();
+
+
+			 _l_e+=4;
+			 _l_e2+=4;
+			 _l_c+=4;
+			 _l_p+=4;
+			 _l_n+=4;
+
+           } // end for x
+	  }
+	   emms();
+}
+
+
+#endif
+#endif

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidFade.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidFade.cpp	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidFade.cpp	2007-01-13 16:37:32 UTC (rev 2721)
@@ -22,7 +22,6 @@
 #include "ADM_toolkit/toolkit.hxx"
 #include "ADM_editor/ADM_edit.hxx"
 #include "ADM_video/ADM_genvideo.hxx"
-#include"ADM_video/ADM_vidField.h"
 #include"ADM_video/ADM_cache.h"
 
 #include "ADM_osSupport/ADM_debugID.h"

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidFastConvolution.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidFastConvolution.cpp	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidFastConvolution.cpp	2007-01-13 16:37:32 UTC (rev 2721)
@@ -460,7 +460,6 @@
 	*out++=b3;
 	return 1;
 }
-uint8_t  DIA_getLumaChroma(uint32_t *doLuma, uint32_t *doChroma);
 uint8_t AVDMFastVideoConvolution::configure(AVDMGenericVideoStream * instream)
 {
   

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidForcedPP.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidForcedPP.cpp	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidForcedPP.cpp	2007-01-13 16:37:32 UTC (rev 2721)
@@ -49,7 +49,6 @@
 SCRIPT_CREATE(forcedpp_script,ADMVideoForcedPP,ppParam);
 BUILD_CREATE(forcedpp_create,ADMVideoForcedPP);
 
-extern int DIA_getMPParams( uint32_t *pplevel, uint32_t *ppstrength,uint32_t *swap);
 
 uint8_t ADMVideoForcedPP::configure( AVDMGenericVideoStream *instream)
 {

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMPLD3D.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMPLD3D.cpp	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMPLD3D.cpp	2007-01-13 16:37:32 UTC (rev 2721)
@@ -49,7 +49,7 @@
 #define PARAM1_DEFAULT 4.0
 #define PARAM2_DEFAULT 3.0
 #define PARAM3_DEFAULT 6.0
-uint8_t DIA_d3d(double *luma,double *chroma,double *temporal);
+
  char 	*ADMVideoMPD3D::printConf(void)
  {
 	  	static char buf[50];

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMSharpen.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMSharpen.cpp	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMSharpen.cpp	2007-01-13 16:37:32 UTC (rev 2721)
@@ -47,7 +47,6 @@
 #include "ADM_toolkit/toolkit.hxx"
 #include "ADM_editor/ADM_edit.hxx"
 #include "ADM_video/ADM_genvideo.hxx"
-#include"ADM_video/ADM_vidField.h"
 #include"ADM_video/ADM_cache.h"
 
 #include "ADM_osSupport/ADM_debugID.h"
@@ -151,7 +150,6 @@
 	blurrImg=NULL;
         work=NULL;
 }
-extern uint8_t DIA_getMSharpen(MSHARPEN_PARAM *param);
 //________________________________________________________
 uint8_t Msharpen::configure(AVDMGenericVideoStream *in)
 {

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMcDeint.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMcDeint.cpp	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMcDeint.cpp	2007-01-13 16:37:32 UTC (rev 2721)
@@ -89,7 +89,6 @@
 BUILD_CREATE(mcdeint_create,AVDMVideoMCDeint);
 
 static void filter(struct vf_priv_s *p, uint8_t *dst[3], uint8_t *src[3], int dst_stride[3], int src_stride[3], int width, int height);
-uint8_t DIA_mcDeint(MCDEINT_PARAM *param);
 
 
 char *AVDMVideoMCDeint::printConf( void )

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMosaic.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMosaic.cpp	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMosaic.cpp	2007-01-13 16:37:32 UTC (rev 2721)
@@ -46,11 +46,9 @@
 #include "ADM_filter/video_filters.h"
 
 #include "ADM_video/ADM_cache.h"
-#include "DIA_enter.h"
 
 #include "ADM_vidMosaic_param.h"
 
-extern uint8_t  DIA_mosaic(MOSAIC_PARAMS *mosaic);
 
 class  ADMVideoMosaic:public AVDMGenericVideoStream
  {

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMsmooth.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMsmooth.cpp	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMsmooth.cpp	2007-01-13 16:37:32 UTC (rev 2721)
@@ -42,7 +42,6 @@
 #include "ADM_toolkit/toolkit.hxx"
 #include "ADM_editor/ADM_edit.hxx"
 #include "ADM_video/ADM_genvideo.hxx"
-#include"ADM_video/ADM_vidField.h"
 #include"ADM_video/ADM_cache.h"
 
 #include "ADM_osSupport/ADM_debugID.h"
@@ -72,7 +71,7 @@
 
 #include "ADM_video/ADM_vidMSmooth_param.h"
 
-extern uint8_t DIA_getMSmooth(MSMOOTH_PARAM *param);
+
 extern uint8_t 	PutHintingData(unsigned char *video, unsigned int hint);
 extern uint8_t 	GetHintingData(unsigned char *video, unsigned int *hint);
 extern void 	BitBlt(uint8_t * dstp, int dst_pitch, const uint8_t* srcp,

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidPalSmart.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidPalSmart.cpp	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidPalSmart.cpp	2007-01-13 16:37:32 UTC (rev 2721)
@@ -31,7 +31,7 @@
 #include "ADM_editor/ADM_edit.hxx"
 #include "ADM_video/ADM_genvideo.hxx"
 
-#include"ADM_video/ADM_vidDeinterlace.h"
+#include"ADM_vidDeinterlace.h"
 #include"ADM_vidPalSmart.h"
 #include "ADM_filter/video_filters.h"
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidPalSmart.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidPalSmart.h	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidPalSmart.h	2007-01-13 16:37:32 UTC (rev 2721)
@@ -14,7 +14,6 @@
  *   (at your option) any later version.                                   *
  *                                                                         *
  ***************************************************************************/
-#include "ADM_video/ADM_vidField.h"
 #include "ADM_video/ADM_cache.h"
 class  ADMVideoTelecide:public ADMVideoFields
  {

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidReverse.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidReverse.cpp	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidReverse.cpp	2007-01-13 16:37:32 UTC (rev 2721)
@@ -21,7 +21,6 @@
 #include "ADM_toolkit/toolkit.hxx"
 #include "ADM_editor/ADM_edit.hxx"
 #include "ADM_video/ADM_genvideo.hxx"
-#include"ADM_video/ADM_vidField.h"
 #include"ADM_video/ADM_cache.h"
 
 #include "ADM_osSupport/ADM_debugID.h"

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am	2007-01-13 16:37:32 UTC (rev 2721)
@@ -7,6 +7,12 @@
 #INCLUDES = $(all_includes) 
 
 libADM_videoFilter_a_SOURCES =  \
+ ADM_vidBlend.cpp \
+ ADM_vidDeintASM.cpp \
+ ADM_vidDecDec.cpp \
+ ADM_vidDecTelecide.cpp \
+ ADM_vidDeinterlace.cpp \
+ ADM_vidFields.cpp \
  ADM_vidPalShift.cpp \
  ADM_vidReverse.cpp \
  ADM_vidSeparateField.cpp \

Modified: branches/avidemux_2.4_branch/avidemux/libcheck.sh
===================================================================
--- branches/avidemux_2.4_branch/avidemux/libcheck.sh	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/libcheck.sh	2007-01-13 16:37:32 UTC (rev 2721)
@@ -1,7 +1,17 @@
 #!/bin/bash
+echo  "*************************"
 echo "Checking malloc..."
-find . -name "*.a" | xargs nm -AC | grep "malloc\|free"| grep   " U " | grep -v ".* U .*_.*"
+echo  "*************************"
+find . -name "*.a" | xargs nm -AC | grep "malloc\|free"| grep   " U " | grep -v ".* U .*_.*" | grep -v "::"
+echo  "*************************"
 echo "Checking fread/fwrite..."
+echo  "*************************"
 find . -name "*.a" | xargs nm -AC | grep "fread\|fwrite"| grep   " U " | grep -v ".* U .*_.*"
+echo  "*************************"
+echo "Checking fopen/close..."
+echo  "*************************"
+find . -name "*.a" | xargs nm -AC | grep "fopen\|fclose"| grep   " U " | grep -v ".* U .*_.*" | grep -v qf
+echo  "*************************"
 echo "Checking GTK..."
+echo  "*************************"
 find . -name "*.a" | grep -vi gtk | xargs nm -AC | grep "gtk_"| grep   " U " 



From mean at mail.berlios.de  Sat Jan 13 17:38:06 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 13 Jan 2007 17:38:06 +0100
Subject: [Avidemux-svn-commit] r2722 -
	branches/avidemux_2.4_branch/avidemux/ADM_osSupport
Message-ID: <200701131638.l0DGc6xU027397@sheep.berlios.de>

Author: mean
Date: 2007-01-13 17:38:05 +0100 (Sat, 13 Jan 2007)
New Revision: 2722

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_osSupport/ADM_fileio.cpp
Log:
fix for non ascii filename /win32 (not tested)

Modified: branches/avidemux_2.4_branch/avidemux/ADM_osSupport/ADM_fileio.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_osSupport/ADM_fileio.cpp	2007-01-13 16:37:32 UTC (rev 2721)
+++ branches/avidemux_2.4_branch/avidemux/ADM_osSupport/ADM_fileio.cpp	2007-01-13 16:38:05 UTC (rev 2722)
@@ -49,7 +49,18 @@
 }
 FILE  *ADM_fopen (const char *file, const char *mode)
 {
+  FILE *f;
+#ifndef CYG_MANGLING
   return fopen(file,mode); 
+#else
+  
+  
+  gchar *retval = g_locale_from_utf8 (file, -1, NULL, NULL, NULL);
+  f=fopen(retval,mode);
+  g_free (retval);
+  return f;
+  
+#endif
 }
 int    ADM_fclose (FILE *file)
 {



From mean at mail.berlios.de  Sat Jan 13 18:12:56 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 13 Jan 2007 18:12:56 +0100
Subject: [Avidemux-svn-commit] r2723 -
	branches/avidemux_2.4_branch/avidemux/ADM_videoFilter
Message-ID: <200701131712.l0DHCuxC031216@sheep.berlios.de>

Author: mean
Date: 2007-01-13 18:12:56 +0100 (Sat, 13 Jan 2007)
New Revision: 2723

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidField.h
Log:
ops

Added: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidField.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidField.h	2007-01-13 16:38:05 UTC (rev 2722)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidField.h	2007-01-13 17:12:56 UTC (rev 2723)
@@ -0,0 +1,83 @@
+/***************************************************************************
+                          ADM_vidField.h  -  description
+                             -------------------
+    begin                : Sun Jan 12 2003
+    copyright            : (C) 2003 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef _VIDFIELD_
+#define _VIDFIELD_
+ 
+#define ASM_DEINT
+#define ASM_BLEND
+
+#define THRES1 15*15
+#define THRES2 9*9
+
+typedef struct DEINT_PARAM
+{
+	  uint32_t motion_trigger;
+	  uint32_t blend_trigger;
+
+} DEINT_PARAM;
+
+ class  ADMVideoFields:public AVDMGenericVideoStream
+ {
+
+ protected:
+ 		DEINT_PARAM					*_param;
+
+      		uint8_t						*_motionmask;
+        	uint8_t						*_motionmask2;
+           	virtual char 					*printConf(void) { assert(0);return NULL;}
+           	uint8_t 						hasMotion(ADMImage *image);
+		void  							hasMotion_C(uint8_t *p,uint8_t *c,
+											uint8_t *n,
+											uint8_t *e,
+											uint8_t *e2
+											);
+		void  							  hasMotion_MMX(uint8_t *p,uint8_t *c,
+											uint8_t *n,
+											uint8_t *e,
+											uint8_t *e2
+												);
+
+           uint8_t 							doBlend(ADMImage *src,
+	   									ADMImage *dst);
+           void							blend_C(uint8_t *p,uint8_t *c,
+											uint8_t *n,
+											uint8_t *e,
+											uint8_t *f
+											);
+	  void								blend_MMX(uint8_t *p,uint8_t *c,
+													uint8_t *n,
+													uint8_t *e,
+													uint8_t *f
+											);
+
+ public:
+
+
+							ADMVideoFields(  AVDMGenericVideoStream *in,CONFcouple *setup);
+  				virtual 		~ADMVideoFields();
+		     		virtual uint8_t 	getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
+          									ADMImage *data,uint32_t *flags) 
+								{
+								 UNUSED_ARG(frame); UNUSED_ARG(len); UNUSED_ARG(data);
+								 UNUSED_ARG(flags); assert(0);return 0;
+								 }
+					virtual uint8_t configure( AVDMGenericVideoStream *instream) ;
+
+					virtual uint8_t 	getCoupledConf( CONFcouple **couples);
+ }     ;
+
+#endif



From mean at mail.berlios.de  Sat Jan 13 18:13:55 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 13 Jan 2007 18:13:55 +0100
Subject: [Avidemux-svn-commit] r2724 -
	branches/avidemux_2.4_branch/avidemux/ADM_videoFilter
Message-ID: <200701131713.l0DHDttr031334@sheep.berlios.de>

Author: mean
Date: 2007-01-13 18:13:54 +0100 (Sat, 13 Jan 2007)
New Revision: 2724

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDeinterlace.cpp
Log:
oops

Added: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDeinterlace.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDeinterlace.cpp	2007-01-13 17:12:56 UTC (rev 2723)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDeinterlace.cpp	2007-01-13 17:13:54 UTC (rev 2724)
@@ -0,0 +1,115 @@
+/***************************************************************************
+                          ADM_vidDeinterlace.cpp  -  description
+                             -------------------
+	Strongly inspired by Donal Graft deinterlacer
+ 	Could be using some MMX
+  	Should be faster than the original due to YV12 colorspace
+
+20-Aug-2002 : Ported also the MMX part
+
+    begin                : Sat Apr 20 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ADM_assert.h>
+
+#include "config.h"
+#include "fourcc.h"
+#include "avio.hxx"
+#include "config.h"
+#include "avi_vars.h"
+#ifdef HAVE_ENCODER
+
+
+
+#include "ADM_toolkit/toolkit.hxx"
+#include "ADM_editor/ADM_edit.hxx"
+#include "ADM_video/ADM_genvideo.hxx"
+
+#include"ADM_vidDeinterlace.h"
+#include "ADM_filter/video_filters.h"
+
+#include "ADM_userInterfaces/ADM_commonUI/DIA_factory.h"
+
+static FILTER_PARAM deintParam={2,{"motion_trigger","blend_trigger"}};
+
+
+SCRIPT_CREATE(deinterlace_script,ADMVideoDeinterlace,deintParam);
+BUILD_CREATE(deinterlace_create,ADMVideoDeinterlace);
+//_______________________________________________________________
+
+
+ADMVideoDeinterlace::~ADMVideoDeinterlace()
+{
+ 	
+	delete _uncompressed;
+	_uncompressed=NULL;
+}
+ADMVideoDeinterlace::ADMVideoDeinterlace(  AVDMGenericVideoStream *in,CONFcouple *couples)
+		:ADMVideoFields(in,couples)
+{
+
+	_uncompressed=new ADMImage(_info.width,_info.height);
+}
+
+//
+//	Basically ask a uncompressed frame from editor and ask
+//		GUI to decompress it .
+//
+
+uint8_t ADMVideoDeinterlace::getFrameNumberNoAlloc(uint32_t frame,
+				uint32_t *len,
+   				ADMImage *data,
+				uint32_t *flags)
+{
+//uint8_t *dst,*dstu,*dstv,*srcu,*srcv;
+uint32_t uvlen;
+		
+		if(frame>=_info.nb_frames) return 0;
+		
+								
+		// read uncompressed frame
+       		if(!_in->getFrameNumberNoAlloc(frame, len,_uncompressed,flags)) return 0;         	
+		
+		uvlen=    _info.width*_info.height;
+		*len= (uvlen*3)>>1;       			
+
+		// No interleaving detected
+		if(!hasMotion(_uncompressed))
+           	{
+			data->duplicate(_uncompressed);
+			
+		}
+		else
+		{
+			//printf("Blending\n");
+			doBlend(_uncompressed,data);
+			memcpy(UPLANE(data),UPLANE(_uncompressed),uvlen>>2);
+			memcpy(VPLANE(data),VPLANE(_uncompressed),uvlen>>2);
+			data->copyInfo(_uncompressed);
+		}
+		return 1;
+}
+
+
+
+char *ADMVideoDeinterlace::printConf(void)
+{
+ 		return (char *)"Deinterlace";;
+}
+
+
+#endif
+



From mean at mail.berlios.de  Sat Jan 13 18:14:36 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 13 Jan 2007 18:14:36 +0100
Subject: [Avidemux-svn-commit] r2725 -
	branches/avidemux_2.4_branch/avidemux/ADM_videoFilter
Message-ID: <200701131714.l0DHEakZ031380@sheep.berlios.de>

Author: mean
Date: 2007-01-13 18:14:35 +0100 (Sat, 13 Jan 2007)
New Revision: 2725

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDeinterlace.h
Log:
oops

Added: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDeinterlace.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDeinterlace.h	2007-01-13 17:13:54 UTC (rev 2724)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDeinterlace.h	2007-01-13 17:14:35 UTC (rev 2725)
@@ -0,0 +1,39 @@
+/***************************************************************************
+                          ADM_vidDeinterlace.h  -  description
+                             -------------------
+    begin                : Sat Apr 20 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+ #include "ADM_vidField.h"
+
+ class  ADMVideoDeinterlace:public ADMVideoFields
+ {
+
+ protected:
+    		     							
+
+ public:
+ 		
+
+						ADMVideoDeinterlace(  AVDMGenericVideoStream *in,CONFcouple *setup);
+
+  			virtual 		~ADMVideoDeinterlace();
+		        virtual uint8_t 	getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
+          										ADMImage *data,uint32_t *flags);
+
+			virtual char 	*printConf(void);
+	
+ }     ;
+
+
+



From mean at mail.berlios.de  Sat Jan 13 18:15:33 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 13 Jan 2007 18:15:33 +0100
Subject: [Avidemux-svn-commit] r2726 -
	branches/avidemux_2.4_branch/avidemux/ADM_videoFilter
Message-ID: <200701131715.l0DHFX0l031476@sheep.berlios.de>

Author: mean
Date: 2007-01-13 18:15:33 +0100 (Sat, 13 Jan 2007)
New Revision: 2726

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidFields.cpp
Log:
oops

Added: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidFields.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidFields.cpp	2007-01-13 17:14:35 UTC (rev 2725)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidFields.cpp	2007-01-13 17:15:33 UTC (rev 2726)
@@ -0,0 +1,243 @@
+/***************************************************************************
+                          ADM_vidFields.cpp  -  description
+                             -------------------
+    begin                : Sun Jan 12 2003
+    copyright            : (C) 2003 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ADM_assert.h>
+
+#include "config.h"
+#include "fourcc.h"
+#include "avio.hxx"
+#include "config.h"
+#include "avi_vars.h"
+#ifdef HAVE_ENCODER
+
+
+
+#include "ADM_toolkit/toolkit.hxx"
+#include "ADM_editor/ADM_edit.hxx"
+#include "ADM_video/ADM_genvideo.hxx"
+
+#include"ADM_vidField.h"
+#include "ADM_osSupport/ADM_cpuCap.h"
+//_______________________________________________________________
+
+ADMVideoFields::ADMVideoFields(
+									AVDMGenericVideoStream *in,CONFcouple *couples)
+{
+
+
+  	_in=in;		
+   	memcpy(&_info,_in->getInfo(),sizeof(_info));  		
+	
+					
+	_motionmask=new uint8_t [_in->getInfo()->width*_in->getInfo()->height];
+	ADM_assert(_motionmask);
+	_motionmask2=new uint8_t [_in->getInfo()->width*_in->getInfo()->height];
+	ADM_assert(_motionmask2);
+
+	_info.encoding=1;
+	if(couples)
+	{
+			_param=NEW(DEINT_PARAM);
+			GET(motion_trigger);
+			GET(blend_trigger);
+	}
+	else
+	{
+			_param=new( DEINT_PARAM);
+			_param->blend_trigger=9;
+			_param->motion_trigger=15;
+	}
+}
+
+uint8_t	ADMVideoFields::getCoupledConf( CONFcouple **couples)
+{
+
+			ADM_assert(_param);
+			*couples=new CONFcouple(2);
+
+#define CSET(x)  (*couples)->setCouple((char *)#x,(_param->x))
+	CSET(motion_trigger);
+	CSET(blend_trigger);
+			return 1;
+
+}
+
+ADMVideoFields::~ADMVideoFields()
+{
+ 	
+	delete []_motionmask ;
+	delete []_motionmask2;
+ 	DELETE(_param);
+	
+}
+//
+//	Return 1 if seen as interleaved
+//		0 is seen as progressiv
+//
+//		Check if in a 8x8 square n, n+1 , n+2 lines differ too much
+//
+uint8_t ADMVideoFields::hasMotion(ADMImage *image)
+{
+    	uint32_t w,h,x,y;
+      	uint8_t *n,*p,*c,*e,*e2;
+	uint8_t *yplane=YPLANE(image);
+       
+
+     	w=_info.width;
+     	h=_info.height;
+
+
+
+      	memset(_motionmask,0,w*h);
+      	memset(_motionmask2,0,w*h);
+
+       // First line
+       	memset(_motionmask,0xff,w);
+          	memset(_motionmask2,0xff,w);
+
+        	p=yplane;
+         	c=p+w;
+          	n=c+w;
+           e=_motionmask+w; 	
+           e2=_motionmask2+w; 	
+  //___________________ C version of motion detection ________________________
+       // other line
+#if (defined( ARCH_X86)  || defined(ARCH_X86_64)) && defined(ASM_DEINT)
+       if(CpuCaps::hasMMX())  
+      	hasMotion_MMX(p,c,n,e,e2);
+       else
+#endif 
+      	 hasMotion_C(p,c,n,e,e2);
+       
+      
+      
+//_______________________________
+           // last line
+           memset(e,0xff,w);
+           memset(e2,0xff,w);
+
+           // Count    how many tagged as !=
+           p=_motionmask;
+           c=p+w;;
+           n=c+w;;
+
+           // 8x8 square
+           uint8_t *box=new uint8_t[ ((h+8)>>3)*((w+8)>>3)]; // ???
+           uint32_t boxx,boxy;
+
+           memset(box,0,  ((h+8)>>3)*((w+8)>>3));
+           for(y=h-2;y>0;y--)
+           	{
+                     boxy=(y>>3)*(w>>3);
+                     for(x=w;x>0;x--)
+                     	{
+                             boxx=boxy+(x>>3);
+                             if( *c&&*p&&*n)
+                             	{
+                                 	box[boxx]++;
+                                }
+                                c++;n++;p++;
+                        }
+              }
+
+              // reached level ?
+              for(x=   ((h+8)>>3)*((w+8)>>3);x>0;x--)
+              {
+                     	if (box[x]>15)
+                      	{
+                          	
+                            	delete [] box;
+                             	return 1;
+                         }
+
+
+                }
+                       	delete [] box;
+                        	return 0;
+
+}
+
+uint8_t ADMVideoFields::doBlend(ADMImage *src,ADMImage *dst)
+{
+   	uint32_t w,h,x; //,y;
+      	uint8_t *n,*p,*c,*e2;
+	uint8_t *f;
+	uint8_t *yplane;
+
+
+	
+     	w=_info.width;
+     	h=_info.height;
+
+	f=YPLANE(dst);
+	yplane=YPLANE(src);
+	p=yplane;	
+	c=yplane;
+	n=c+w;
+	e2=_motionmask2+w; 
+	
+	// First line
+	// always blend
+	for(x=w;x>0;x--)
+	{
+		*f++=(*c+*n)>>1;
+		n++;
+		c++;
+	}
+#if (defined( ARCH_X86)  || defined(ARCH_X86_64)) && defined(ASM_BLEND)
+       if(CpuCaps::hasMMX())               
+              blend_MMX(p,c,n,e2,f);
+        else
+#endif
+              blend_C(p,c,n,e2,f);
+              // Last line
+            for(x=w;x>0;x--)
+            {
+               	*f++=(*c+*p)>>1;
+                	  p++;
+                   c++;
+
+              }
+
+              return 1;
+
+
+
+}
+uint8_t ADMVideoFields::configure( AVDMGenericVideoStream *instream)
+{
+int i,j;
+	_in=instream;
+	i=(int)_param->motion_trigger;
+	j=(int)_param->blend_trigger;
+	if(GUI_getIntegerValue(&i,0,255,"Motion  Threshold"))
+	{
+		if(GUI_getIntegerValue(&j,0,255,"Blend  Threshold"))
+		{
+			_param->motion_trigger=(uint8_t)i;
+			_param->blend_trigger=(uint8_t)j;
+			return 1;
+		}
+	} 
+
+	return 0;    
+}      
+
+
+#endif



From mean at mail.berlios.de  Sat Jan 13 18:20:04 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 13 Jan 2007 18:20:04 +0100
Subject: [Avidemux-svn-commit] r2727 -
	branches/avidemux_2.4_branch/avidemux/ADM_osSupport
Message-ID: <200701131720.l0DHK4Hr031751@sheep.berlios.de>

Author: mean
Date: 2007-01-13 18:20:04 +0100 (Sat, 13 Jan 2007)
New Revision: 2727

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_osSupport/ADM_debug.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_osSupport/ADM_fileio.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_osSupport/Makefile.am
Log:
win32 fix, cont-ed

Modified: branches/avidemux_2.4_branch/avidemux/ADM_osSupport/ADM_debug.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_osSupport/ADM_debug.cpp	2007-01-13 17:15:33 UTC (rev 2726)
+++ branches/avidemux_2.4_branch/avidemux/ADM_osSupport/ADM_debug.cpp	2007-01-13 17:20:04 UTC (rev 2727)
@@ -31,7 +31,7 @@
 
 // put here the module you want to be verbose (MODULE_xxx + MODULE_yyyy+  ....)
 #ifndef masked
-#define masked  (MODULE_FILTER) //+MODULE_3GP) //(MODULE_AUDIO_EDITOR) MODULE_OGM_AUDIO MODULE_REQUANT MODULE_CODEC
+#define masked  (0) //+MODULE_3GP) //(MODULE_AUDIO_EDITOR) MODULE_OGM_AUDIO MODULE_REQUANT MODULE_CODEC
 #endif
 
 // If the entitty is in masked we actually print the string

Modified: branches/avidemux_2.4_branch/avidemux/ADM_osSupport/ADM_fileio.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_osSupport/ADM_fileio.cpp	2007-01-13 17:15:33 UTC (rev 2726)
+++ branches/avidemux_2.4_branch/avidemux/ADM_osSupport/ADM_fileio.cpp	2007-01-13 17:20:04 UTC (rev 2727)
@@ -22,7 +22,7 @@
 #include <sys/stat.h>
 
 #include <unistd.h>
-    
+#include <glib.h>    
 #include "default.h"
 #include "ADM_misc.h"
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_osSupport/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_osSupport/Makefile.am	2007-01-13 17:15:33 UTC (rev 2726)
+++ branches/avidemux_2.4_branch/avidemux/ADM_osSupport/Makefile.am	2007-01-13 17:20:04 UTC (rev 2727)
@@ -18,5 +18,5 @@
 
 
 ####### kdevelop will overwrite this part!!! (end)############
-INCLUDES = $(all_includes) -I../ADM_libraries -I../ADM_libraries/ADM_utilities -I../ADM_libraries/ADM_lavutil 
+INCLUDES = $(all_includes) -I../ADM_libraries -I../ADM_libraries/ADM_utilities -I../ADM_libraries/ADM_lavutil $(GLIB_CFLAGS)
 noinst_HEADERS =  



From mean at mail.berlios.de  Sun Jan 14 12:34:16 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 14 Jan 2007 12:34:16 +0100
Subject: [Avidemux-svn-commit] r2728 - in
	branches/avidemux_2.4_branch/avidemux:
	ADM_userInterfaces/ADM_GTK/ADM_dialog ADM_videoFilter
Message-ID: <200701141134.l0EBYFxg013212@sheep.berlios.de>

Author: mean
Date: 2007-01-14 12:34:13 +0100 (Sun, 14 Jan 2007)
New Revision: 2728

Removed:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_dectel.cpp
Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDecTel_param.h
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDecTelecide.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidStabilize.cpp
Log:
more dialogFactory

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_dectel.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_dectel.cpp	2007-01-13 17:20:04 UTC (rev 2727)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_dectel.cpp	2007-01-14 11:34:13 UTC (rev 2728)
@@ -1,454 +0,0 @@
-//
-// C++ Implementation: DIA_dectel
-//
-// Description: 
-//
-//
-// Author: mean <fixounet at free.fr>, (C) 2004
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-
-
-#include <config.h>
-
-#include <sys/types.h>
-#include <sys/stat.h>
-
-#include <gdk/gdkkeysyms.h>
-#include <gtk/gtk.h>
-
-
-#include <gdk/gdkkeysyms.h>
-#include <gtk/gtk.h>
-# include <math.h>
-
-#include "default.h"
-#include "ADM_toolkit_gtk/toolkit_gtk.h"
-#include "ADM_toolkit_gtk/toolkit_gtk_include.h"
-#include "ADM_toolkit/toolkit.hxx"
-
-
-#include "ADM_videoFilter/ADM_vidDecTel_param.h"
-#define MENU_SET(x,y) { gtk_option_menu_set_history (GTK_OPTION_MENU(WID(x)),param->y);}
-#define MENU_GET(x,y) { param->y	= getRangeInMenu(WID(x));}
-
-#define CHECK_SET(x,y) {gtk_toggle_button_set_active( GTK_TOGGLE_BUTTON(WID(x)),param->y);}
-#define CHECK_GET(x,y) {param->y=gtk_toggle_button_get_active( GTK_TOGGLE_BUTTON(WID(x)));}
-
-
-static GtkWidget	*create_dialog1 (void);
-
-uint8_t DIA_getDecombTelecide(TelecideParam *param)
-{
-GtkWidget *dialog;
-int ret=0;
-	dialog=create_dialog1();
-	
-	// Update
-	gtk_write_entry_float(WID(entryVthresh),param->vthresh);
-	gtk_write_entry_float(WID(entryBthresh),param->bthresh);
-	gtk_write_entry_float(WID(entryDthresh),param->dthresh);
-	gtk_write_entry_float(WID(entryNT),param->nt);
-	
-	MENU_SET(optionmenuField,order);
-	MENU_SET(optionmenuBack,back);
-	MENU_SET(optionmenuGuide,guide);
-	MENU_SET(optionmenuPost,post);
-	MENU_SET(optionmenuBlend,blend);
-	MENU_SET(optionmenuChroma,chroma);
-        CHECK_SET(checkbuttonShow,show);
-	gtk_register_dialog(dialog);
-	
-	if(gtk_dialog_run(GTK_DIALOG(dialog))==GTK_RESPONSE_OK)
-	{
-		MENU_GET(optionmenuField,order);
-		MENU_GET(optionmenuBack,back);
-		MENU_GET(optionmenuGuide,guide);
-		MENU_GET(optionmenuPost,post);
-		MENU_GET(optionmenuBlend,blend);
-		MENU_GET(optionmenuChroma,chroma);
-                CHECK_GET(checkbuttonShow,show);
-		#define RD_ENTRY(x,y) {param->y=gtk_read_entry_float(WID(x));}
-		RD_ENTRY(entryVthresh,vthresh);
-		RD_ENTRY(entryBthresh,bthresh);
-		RD_ENTRY(entryDthresh,dthresh);
-		RD_ENTRY(entryNT,nt);
-		ret=1;
-	}
-        gtk_unregister_dialog(dialog);
-	gtk_widget_destroy(dialog);
-	return ret;
-}
-
-//________________________________________
-
-GtkWidget*
-create_dialog1 (void)
-{
-  GtkWidget *dialog1;
-  GtkWidget *dialog_vbox1;
-  GtkWidget *table1;
-  GtkWidget *label1;
-  GtkWidget *optionmenuField;
-  GtkWidget *menu1;
-  GtkWidget *bottom_field_first1;
-  GtkWidget *top_field_first1;
-  GtkWidget *label2;
-  GtkWidget *optionmenuBack;
-  GtkWidget *menu2;
-  GtkWidget *never1;
-  GtkWidget *when_forward_is_still_combed1;
-  GtkWidget *always_try1;
-  GtkWidget *optionmenuGuide;
-  GtkWidget *menu3;
-  GtkWidget *no_strategy1;
-  GtkWidget *telecine_3_1;
-  GtkWidget *pal_secam1;
-  GtkWidget *ntsc_converted_from_pal1;
-  GtkWidget *label3;
-  GtkWidget *label4;
-  GtkWidget *optionmenuPost;
-  GtkWidget *menu4;
-  GtkWidget *no_postprocessing1;
-  GtkWidget *item1;
-  GtkWidget *postproc_on_best_match1;
-  GtkWidget *label5;
-  GtkWidget *optionmenuChroma;
-  GtkWidget *menu5;
-  GtkWidget *ignore_chroma_to_decide1;
-  GtkWidget *use_chroma_to_decide1;
-  GtkWidget *label6;
-  GtkWidget *optionmenuBlend;
-  GtkWidget *menu6;
-  GtkWidget *interpolate1;
-  GtkWidget *blend1;
-  GtkWidget *label7;
-  GtkWidget *entryBthresh;
-  GtkWidget *label8;
-  GtkWidget *entryDthresh;
-  GtkWidget *label9;
-  GtkWidget *entryVthresh;
-  GtkWidget *label10;
-  GtkWidget *entryNT;
-  GtkWidget *label11;
-  GtkWidget *checkbuttonShow;
-  GtkWidget *dialog_action_area1;
-  GtkWidget *cancelbutton1;
-  GtkWidget *okbutton1;
-
-  dialog1 = gtk_dialog_new ();
-  gtk_window_set_title (GTK_WINDOW (dialog1), _("Decomb Telecide"));
-  gtk_window_set_type_hint (GTK_WINDOW (dialog1), GDK_WINDOW_TYPE_HINT_DIALOG);
-
-  dialog_vbox1 = GTK_DIALOG (dialog1)->vbox;
-  gtk_widget_show (dialog_vbox1);
-
-  table1 = gtk_table_new (11, 2, FALSE);
-  gtk_widget_show (table1);
-  gtk_box_pack_start (GTK_BOX (dialog_vbox1), table1, TRUE, TRUE, 0);
-
-  label1 = gtk_label_new (_("Field Order"));
-  gtk_widget_show (label1);
-  gtk_table_attach (GTK_TABLE (table1), label1, 0, 1, 0, 1,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_misc_set_alignment (GTK_MISC (label1), 0, 0.5);
-
-  optionmenuField = gtk_option_menu_new ();
-  gtk_widget_show (optionmenuField);
-  gtk_table_attach (GTK_TABLE (table1), optionmenuField, 1, 2, 0, 1,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-
-  menu1 = gtk_menu_new ();
-
-  bottom_field_first1 = gtk_menu_item_new_with_mnemonic (_("Bottom Field First"));
-  gtk_widget_show (bottom_field_first1);
-  gtk_container_add (GTK_CONTAINER (menu1), bottom_field_first1);
-
-  top_field_first1 = gtk_menu_item_new_with_mnemonic (_("Top Field First"));
-  gtk_widget_show (top_field_first1);
-  gtk_container_add (GTK_CONTAINER (menu1), top_field_first1);
-
-  gtk_option_menu_set_menu (GTK_OPTION_MENU (optionmenuField), menu1);
-
-  label2 = gtk_label_new (_("Try backward field"));
-  gtk_widget_show (label2);
-  gtk_table_attach (GTK_TABLE (table1), label2, 0, 1, 1, 2,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_misc_set_alignment (GTK_MISC (label2), 0, 0.5);
-
-  optionmenuBack = gtk_option_menu_new ();
-  gtk_widget_show (optionmenuBack);
-  gtk_table_attach (GTK_TABLE (table1), optionmenuBack, 1, 2, 1, 2,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-
-  menu2 = gtk_menu_new ();
-
-  never1 = gtk_menu_item_new_with_mnemonic (_("Never"));
-  gtk_widget_show (never1);
-  gtk_container_add (GTK_CONTAINER (menu2), never1);
-
-  when_forward_is_still_combed1 = gtk_menu_item_new_with_mnemonic (_("When forward is still combed"));
-  gtk_widget_show (when_forward_is_still_combed1);
-  gtk_container_add (GTK_CONTAINER (menu2), when_forward_is_still_combed1);
-
-  always_try1 = gtk_menu_item_new_with_mnemonic (_("Always try"));
-  gtk_widget_show (always_try1);
-  gtk_container_add (GTK_CONTAINER (menu2), always_try1);
-
-  gtk_option_menu_set_menu (GTK_OPTION_MENU (optionmenuBack), menu2);
-
-  optionmenuGuide = gtk_option_menu_new ();
-  gtk_widget_show (optionmenuGuide);
-  gtk_table_attach (GTK_TABLE (table1), optionmenuGuide, 1, 2, 2, 3,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-
-  menu3 = gtk_menu_new ();
-
-  no_strategy1 = gtk_menu_item_new_with_mnemonic (_("No strategy"));
-  gtk_widget_show (no_strategy1);
-  gtk_container_add (GTK_CONTAINER (menu3), no_strategy1);
-
-  telecine_3_1 = gtk_menu_item_new_with_mnemonic (_("Telecine 3:2"));
-  gtk_widget_show (telecine_3_1);
-  gtk_container_add (GTK_CONTAINER (menu3), telecine_3_1);
-
-  pal_secam1 = gtk_menu_item_new_with_mnemonic (_("Pal/Secam"));
-  gtk_widget_show (pal_secam1);
-  gtk_container_add (GTK_CONTAINER (menu3), pal_secam1);
-
-  ntsc_converted_from_pal1 = gtk_menu_item_new_with_mnemonic (_("NTSC converted from Pal"));
-  gtk_widget_show (ntsc_converted_from_pal1);
-  gtk_container_add (GTK_CONTAINER (menu3), ntsc_converted_from_pal1);
-
-  gtk_option_menu_set_menu (GTK_OPTION_MENU (optionmenuGuide), menu3);
-
-  label3 = gtk_label_new (_("Decomb strategy"));
-  gtk_widget_show (label3);
-  gtk_table_attach (GTK_TABLE (table1), label3, 0, 1, 2, 3,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_misc_set_alignment (GTK_MISC (label3), 0, 0.5);
-
-  label4 = gtk_label_new (_("Postprocessing"));
-  gtk_widget_show (label4);
-  gtk_table_attach (GTK_TABLE (table1), label4, 0, 1, 3, 4,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_misc_set_alignment (GTK_MISC (label4), 0, 0.5);
-
-  optionmenuPost = gtk_option_menu_new ();
-  gtk_widget_show (optionmenuPost);
-  gtk_table_attach (GTK_TABLE (table1), optionmenuPost, 1, 2, 3, 4,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-
-  menu4 = gtk_menu_new ();
-
-  no_postprocessing1 = gtk_menu_item_new_with_mnemonic (_("No postprocessing"));
-  gtk_widget_show (no_postprocessing1);
-  gtk_container_add (GTK_CONTAINER (menu4), no_postprocessing1);
-
-  item1 = gtk_menu_item_new_with_mnemonic (_("No postproc, but compute"));
-  gtk_widget_show (item1);
-  gtk_container_add (GTK_CONTAINER (menu4), item1);
-
-  postproc_on_best_match1 = gtk_menu_item_new_with_mnemonic (_("Postproc on best match"));
-  gtk_widget_show (postproc_on_best_match1);
-  gtk_container_add (GTK_CONTAINER (menu4), postproc_on_best_match1);
-
-  gtk_option_menu_set_menu (GTK_OPTION_MENU (optionmenuPost), menu4);
-
-  label5 = gtk_label_new (_("Chroma"));
-  gtk_widget_show (label5);
-  gtk_table_attach (GTK_TABLE (table1), label5, 0, 1, 4, 5,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_misc_set_alignment (GTK_MISC (label5), 0, 0.5);
-
-  optionmenuChroma = gtk_option_menu_new ();
-  gtk_widget_show (optionmenuChroma);
-  gtk_table_attach (GTK_TABLE (table1), optionmenuChroma, 1, 2, 4, 5,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-
-  menu5 = gtk_menu_new ();
-
-  ignore_chroma_to_decide1 = gtk_menu_item_new_with_mnemonic (_("Ignore chroma to decide"));
-  gtk_widget_show (ignore_chroma_to_decide1);
-  gtk_container_add (GTK_CONTAINER (menu5), ignore_chroma_to_decide1);
-
-  use_chroma_to_decide1 = gtk_menu_item_new_with_mnemonic (_("Use chroma to decide"));
-  gtk_widget_show (use_chroma_to_decide1);
-  gtk_container_add (GTK_CONTAINER (menu5), use_chroma_to_decide1);
-
-  gtk_option_menu_set_menu (GTK_OPTION_MENU (optionmenuChroma), menu5);
-
-  label6 = gtk_label_new (_("Blend or interpolate"));
-  gtk_widget_show (label6);
-  gtk_table_attach (GTK_TABLE (table1), label6, 0, 1, 5, 6,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_misc_set_alignment (GTK_MISC (label6), 0, 0.5);
-
-  optionmenuBlend = gtk_option_menu_new ();
-  gtk_widget_show (optionmenuBlend);
-  gtk_table_attach (GTK_TABLE (table1), optionmenuBlend, 1, 2, 5, 6,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-
-  menu6 = gtk_menu_new ();
-
-  interpolate1 = gtk_menu_item_new_with_mnemonic (_("Interpolate"));
-  gtk_widget_show (interpolate1);
-  gtk_container_add (GTK_CONTAINER (menu6), interpolate1);
-
-  blend1 = gtk_menu_item_new_with_mnemonic (_("Blend"));
-  gtk_widget_show (blend1);
-  gtk_container_add (GTK_CONTAINER (menu6), blend1);
-
-  gtk_option_menu_set_menu (GTK_OPTION_MENU (optionmenuBlend), menu6);
-
-  label7 = gtk_label_new (_("Backward thresh"));
-  gtk_widget_show (label7);
-  gtk_table_attach (GTK_TABLE (table1), label7, 0, 1, 6, 7,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_misc_set_alignment (GTK_MISC (label7), 0, 0.5);
-
-  entryBthresh = gtk_entry_new ();
-  gtk_widget_show (entryBthresh);
-  gtk_table_attach (GTK_TABLE (table1), entryBthresh, 1, 2, 6, 7,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-
-  label8 = gtk_label_new (_("Direct thresh"));
-  gtk_widget_show (label8);
-  gtk_table_attach (GTK_TABLE (table1), label8, 0, 1, 7, 8,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_misc_set_alignment (GTK_MISC (label8), 0, 0.5);
-
-  entryDthresh = gtk_entry_new ();
-  gtk_widget_show (entryDthresh);
-  gtk_table_attach (GTK_TABLE (table1), entryDthresh, 1, 2, 7, 8,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-
-  label9 = gtk_label_new (_("Postproc thresh"));
-  gtk_widget_show (label9);
-  gtk_table_attach (GTK_TABLE (table1), label9, 0, 1, 8, 9,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_misc_set_alignment (GTK_MISC (label9), 0, 0.5);
-
-  entryVthresh = gtk_entry_new ();
-  gtk_widget_show (entryVthresh);
-  gtk_table_attach (GTK_TABLE (table1), entryVthresh, 1, 2, 8, 9,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-
-  label10 = gtk_label_new (_("Noise Threshold"));
-  gtk_widget_show (label10);
-  gtk_table_attach (GTK_TABLE (table1), label10, 0, 1, 9, 10,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_misc_set_alignment (GTK_MISC (label10), 0, 0.5);
-
-  entryNT = gtk_entry_new ();
-  gtk_widget_show (entryNT);
-  gtk_table_attach (GTK_TABLE (table1), entryNT, 1, 2, 9, 10,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-
-  label11 = gtk_label_new (_("Show"));
-  gtk_widget_show (label11);
-  gtk_table_attach (GTK_TABLE (table1), label11, 0, 1, 10, 11,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_misc_set_alignment (GTK_MISC (label11), 0, 0.5);
-
-  checkbuttonShow = gtk_check_button_new_with_mnemonic ("");
-  gtk_widget_show (checkbuttonShow);
-  gtk_table_attach (GTK_TABLE (table1), checkbuttonShow, 1, 2, 10, 11,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-
-  dialog_action_area1 = GTK_DIALOG (dialog1)->action_area;
-  gtk_widget_show (dialog_action_area1);
-  gtk_button_box_set_layout (GTK_BUTTON_BOX (dialog_action_area1), GTK_BUTTONBOX_END);
-
-  cancelbutton1 = gtk_button_new_from_stock ("gtk-cancel");
-  gtk_widget_show (cancelbutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), cancelbutton1, GTK_RESPONSE_CANCEL);
-  GTK_WIDGET_SET_FLAGS (cancelbutton1, GTK_CAN_DEFAULT);
-
-  okbutton1 = gtk_button_new_from_stock ("gtk-ok");
-  gtk_widget_show (okbutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), okbutton1, GTK_RESPONSE_OK);
-  GTK_WIDGET_SET_FLAGS (okbutton1, GTK_CAN_DEFAULT);
-
-
-
-  /* Store pointers to all widgets, for use by lookup_widget(). */
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog1, "dialog1");
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_vbox1, "dialog_vbox1");
-  GLADE_HOOKUP_OBJECT (dialog1, table1, "table1");
-  GLADE_HOOKUP_OBJECT (dialog1, label1, "label1");
-  GLADE_HOOKUP_OBJECT (dialog1, optionmenuField, "optionmenuField");
-  GLADE_HOOKUP_OBJECT (dialog1, menu1, "menu1");
-  GLADE_HOOKUP_OBJECT (dialog1, bottom_field_first1, "bottom_field_first1");
-  GLADE_HOOKUP_OBJECT (dialog1, top_field_first1, "top_field_first1");
-  GLADE_HOOKUP_OBJECT (dialog1, label2, "label2");
-  GLADE_HOOKUP_OBJECT (dialog1, optionmenuBack, "optionmenuBack");
-  GLADE_HOOKUP_OBJECT (dialog1, menu2, "menu2");
-  GLADE_HOOKUP_OBJECT (dialog1, never1, "never1");
-  GLADE_HOOKUP_OBJECT (dialog1, when_forward_is_still_combed1, "when_forward_is_still_combed1");
-  GLADE_HOOKUP_OBJECT (dialog1, always_try1, "always_try1");
-  GLADE_HOOKUP_OBJECT (dialog1, optionmenuGuide, "optionmenuGuide");
-  GLADE_HOOKUP_OBJECT (dialog1, menu3, "menu3");
-  GLADE_HOOKUP_OBJECT (dialog1, no_strategy1, "no_strategy1");
-  GLADE_HOOKUP_OBJECT (dialog1, telecine_3_1, "telecine_3_1");
-  GLADE_HOOKUP_OBJECT (dialog1, pal_secam1, "pal_secam1");
-  GLADE_HOOKUP_OBJECT (dialog1, ntsc_converted_from_pal1, "ntsc_converted_from_pal1");
-  GLADE_HOOKUP_OBJECT (dialog1, label3, "label3");
-  GLADE_HOOKUP_OBJECT (dialog1, label4, "label4");
-  GLADE_HOOKUP_OBJECT (dialog1, optionmenuPost, "optionmenuPost");
-  GLADE_HOOKUP_OBJECT (dialog1, menu4, "menu4");
-  GLADE_HOOKUP_OBJECT (dialog1, no_postprocessing1, "no_postprocessing1");
-  GLADE_HOOKUP_OBJECT (dialog1, item1, "item1");
-  GLADE_HOOKUP_OBJECT (dialog1, postproc_on_best_match1, "postproc_on_best_match1");
-  GLADE_HOOKUP_OBJECT (dialog1, label5, "label5");
-  GLADE_HOOKUP_OBJECT (dialog1, optionmenuChroma, "optionmenuChroma");
-  GLADE_HOOKUP_OBJECT (dialog1, menu5, "menu5");
-  GLADE_HOOKUP_OBJECT (dialog1, ignore_chroma_to_decide1, "ignore_chroma_to_decide1");
-  GLADE_HOOKUP_OBJECT (dialog1, use_chroma_to_decide1, "use_chroma_to_decide1");
-  GLADE_HOOKUP_OBJECT (dialog1, label6, "label6");
-  GLADE_HOOKUP_OBJECT (dialog1, optionmenuBlend, "optionmenuBlend");
-  GLADE_HOOKUP_OBJECT (dialog1, menu6, "menu6");
-  GLADE_HOOKUP_OBJECT (dialog1, interpolate1, "interpolate1");
-  GLADE_HOOKUP_OBJECT (dialog1, blend1, "blend1");
-  GLADE_HOOKUP_OBJECT (dialog1, label7, "label7");
-  GLADE_HOOKUP_OBJECT (dialog1, entryBthresh, "entryBthresh");
-  GLADE_HOOKUP_OBJECT (dialog1, label8, "label8");
-  GLADE_HOOKUP_OBJECT (dialog1, entryDthresh, "entryDthresh");
-  GLADE_HOOKUP_OBJECT (dialog1, label9, "label9");
-  GLADE_HOOKUP_OBJECT (dialog1, entryVthresh, "entryVthresh");
-  GLADE_HOOKUP_OBJECT (dialog1, label10, "label10");
-  GLADE_HOOKUP_OBJECT (dialog1, entryNT, "entryNT");
-  GLADE_HOOKUP_OBJECT (dialog1, label11, "label11");
-  GLADE_HOOKUP_OBJECT (dialog1, checkbuttonShow, "checkbuttonShow");
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_action_area1, "dialog_action_area1");
-  GLADE_HOOKUP_OBJECT (dialog1, cancelbutton1, "cancelbutton1");
-  GLADE_HOOKUP_OBJECT (dialog1, okbutton1, "okbutton1");
-
-  return dialog1;
-}
-
-//EOF

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am	2007-01-13 17:20:04 UTC (rev 2727)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am	2007-01-14 11:34:13 UTC (rev 2728)
@@ -15,7 +15,7 @@
 	DIA_postproc.cpp DIA_enter.cpp DIA_enter.h DIA_xvcd.cpp DIA_muxer.cpp \
 	DIA_xvid.cpp DIA_crop.cpp DIA_color.cpp DIA_encoding.cpp DIA_SVCD.cpp DIA_prefs.cpp \
 	DIA_requant.cpp DIA_xvid4.cpp DIA_lavcodec.cpp \
-	DIA_dectel.cpp DIA_pause.cpp \
+	DIA_pause.cpp \
 	DIA_DVDff.cpp DIA_lavdecoder.cpp DIA_lame.cpp DIA_calculator.cpp DIA_equalizer.cpp \
 	DIA_vobsub.cpp DIA_x264.cpp DIA_ocr.cpp  DIA_hue.cpp DIA_eq2.cpp \
 	DIA_asharp.cpp DIA_dmx.cpp DIA_idx_pg.cpp DIA_gototime.cpp \
@@ -49,7 +49,7 @@
 DIA_animated.cpp     DIA_hue.cpp          DIA_ocr.cpp         DIA_vcodec.cpp \
 DIA_asharp.cpp       DIA_idx_pg.cpp       DIA_partial.cpp     DIA_vobsub.cpp \
 DIA_audio.cpp        DIA_idx_pg.h         DIA_pause.cpp       DIA_vorbis.cpp \
-DIA_audioTrack.cpp   DIA_dectel.cpp        DIA_indexer.cpp      DIA_pipe.cpp        DIA_working.cpp \
+DIA_audioTrack.cpp   DIA_indexer.cpp      DIA_pipe.cpp        DIA_working.cpp \
 DIA_defaultAudio.cpp  DIA_jobs.cpp         DIA_postproc.cpp    DIA_working.h \
 DIA_jobs_save.cpp    DIA_prefs.cpp       DIA_x264.cpp \
 DIA_preview.cpp     DIA_xvcd.cpp \

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDecTel_param.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDecTel_param.h	2007-01-13 17:20:04 UTC (rev 2727)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDecTel_param.h	2007-01-14 11:34:13 UTC (rev 2728)
@@ -13,22 +13,22 @@
 
 typedef struct TelecideParam
 {
-	uint32_t 	order;
-	uint32_t 	back;
+	uint32_t 	order;           /* Field Order 0 BFF, 1TFF */
+	uint32_t 	back;            // Try backward field :0 Never, 1 when bad, 2 always tried MUST Have post !=0
 	uint32_t	back_saved;
-	uint32_t 	guide;
-	double	 	gthresh;
-	uint32_t 	post;
-	uint32_t 	chroma;
-	double 		vthresh;
+	uint32_t 	guide;          // (strategy) See GUIDE_xx 0 / NONE - 1 GUIDE_32/ivtc-2 GUIDE 22/PAL-3 PAL/NTSC
+	double	 	gthresh;        // noise threhold
+	uint32_t 	post;            // See POST_XX
+	uint32_t 	chroma;          // True/false Use chroma to decide
+	double 		vthresh;         // 
 	double		vthresh_saved;
-	double 		bthresh;
-	double 		dthresh;
-	uint32_t 	blend;
+	double 		bthresh;         //
+	double 		dthresh;         // Direct Threshold
+	uint32_t 	blend;           // Blend or interpolate (blend=1/interpolate =0;
 	uint32_t 	nt;
 	uint32_t 	y0;
 	uint32_t 	y1;
-	uint32_t 	hints;
-	uint32_t 	show;
-	uint32_t 	debug;
+	uint32_t 	hints;           // ignore
+	uint32_t 	show;            // Toggle
+	uint32_t 	debug;           // Toggle
 };

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDecTelecide.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDecTelecide.cpp	2007-01-13 17:20:04 UTC (rev 2727)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDecTelecide.cpp	2007-01-14 11:34:13 UTC (rev 2728)
@@ -54,6 +54,8 @@
 
 #include "ADM_vidDecTelecide.h"
 #include "ADM_filter/video_filters.h"
+#include "ADM_userInterfaces/ADM_commonUI/DIA_factory.h"
+
 static FILTER_PARAM decomb_template={16,{"order","back","guide",
 	 	 	"gthresh","post","chroma","vthresh",
 			"bthresh","dthresh","blend",
@@ -66,8 +68,80 @@
 uint8_t Telecide::configure(AVDMGenericVideoStream *in)
 {
 	_in=in;
-//	return DIA_getDecombTelecide(_param);
-        return 0;
+
+        
+	_in=in;
+#define PX(x) &(_param->x)
+#define SZT(x) sizeof(x)/sizeof(diaMenuEntry )
+        
+    ELEM_TYPE_FLOAT vthresh=(ELEM_TYPE_FLOAT)_param->vthresh;
+    ELEM_TYPE_FLOAT bthresh=(ELEM_TYPE_FLOAT)_param->bthresh;
+    ELEM_TYPE_FLOAT dthresh=(ELEM_TYPE_FLOAT)_param->dthresh;
+    ELEM_TYPE_FLOAT gthresh=(ELEM_TYPE_FLOAT)_param->gthresh;
+
+         diaMenuEntry tStrategy[]={
+                             {GUIDE_NONE,   _("No Strategy"),NULL},
+                             {GUIDE_32,     _("3:2 Pulldown"),NULL},
+                             {GUIDE_22,     _("Pal/Secam"),NULL},
+                             {GUIDE_32322,  _("NTSC converted from PAL"),NULL}
+                          };
+                          
+          diaMenuEntry tField[]={
+                             {1,_("Top"),NULL},
+                             {0,_("Bottom"),NULL}
+          };
+          
+          diaMenuEntry tBackward[]={
+                             {NO_BACK,_("Never"),NULL},
+                             {BACK_ON_COMBED,_("If still combed"),NULL},
+                             {ALWAYS_BACK,_("Always"),NULL}
+          };
+          
+          diaMenuEntry tPostproc[]={
+                             {POST_NONE,      _("None"),NULL},
+                             {POST_METRICS,   _("None but compute"),NULL},
+                             {POST_FULL,      _("Postproc on best match"),NULL},
+                             {POST_FULL_MAP,  _("Full map ??"),NULL},
+                             {POST_FULL_NOMATCH,_("Full no match ??"),NULL},
+                             {POST_FULL_NOMATCH_MAP,_("Full nomatch map ??"),NULL}
+          };
+                             
+          
+    diaElemMenu menuMode(PX(guide),   _("Strategy"), SZT(tStrategy),tStrategy);
+    diaElemMenu menuField(PX(order),  _("Field Order"), SZT(tField),tField);
+    diaElemMenu menuPost(PX(post),    _("Post Processing"), SZT(tPostproc),tPostproc);
+    diaElemMenu menuBackward(PX(back),_("Try backward"), SZT(tBackward),tBackward);
+    
+    diaElemFloat direct(&dthresh,_("Direct Threshold"),0,200. );
+    diaElemFloat backward(&bthresh,_("Backward Threshold"),0,200. );
+    diaElemFloat noise(&gthresh,_("Noise Threshold"),0,200. );
+    diaElemFloat post(&vthresh,_("Post Proc Threshold"),0,200. );
+    
+    diaElemToggle chroma(PX(chroma),_("Use Chroma to decide"));
+    diaElemToggle show(PX(show),_("Show info"));
+    diaElemToggle debug(PX(debug),_("Debug"));
+    diaElemToggle blend(PX(blend),_("Blend"));
+    
+    
+    
+    diaElem *elems[]={&menuMode,&menuField,&menuPost,&menuBackward,
+        &direct,&backward,&noise,&post,&blend,
+        &chroma,&show,&debug    };
+    
+  if(diaFactoryRun("Decombe Telecide",12,elems))
+  {
+    
+      _param->vthresh=(double)vthresh;
+      _param->bthresh=(double)bthresh;
+      _param->dthresh=(double)dthresh;
+      _param->gthresh=(double)gthresh;
+
+    return 1; 
+  }
+  return 0;        
+        
+        
+
 	
 }
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidStabilize.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidStabilize.cpp	2007-01-13 17:20:04 UTC (rev 2727)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidStabilize.cpp	2007-01-14 11:34:13 UTC (rev 2728)
@@ -60,7 +60,7 @@
 int i;
 	_in=instream;
         
-         diaElemUInteger chroma(_param,_("DropOut Threshold"),1,255);    
+         diaElemUInteger chroma(_param,_("Stabilize Threshold"),1,255);    
          diaElem *elems[]={&chroma};
   
     return diaFactoryRun("Stabilize",sizeof(elems)/sizeof(diaElem *),elems);



From mean at mail.berlios.de  Sun Jan 14 12:37:31 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 14 Jan 2007 12:37:31 +0100
Subject: [Avidemux-svn-commit] r2729 - branches/avidemux_2.4_branch/avidemux
Message-ID: <200701141137.l0EBbV6Q020490@sheep.berlios.de>

Author: mean
Date: 2007-01-14 12:37:30 +0100 (Sun, 14 Jan 2007)
New Revision: 2729

Modified:
   branches/avidemux_2.4_branch/avidemux/Makefile.am
Log:
respect ADD vs FLAGS

Modified: branches/avidemux_2.4_branch/avidemux/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/Makefile.am	2007-01-14 11:34:13 UTC (rev 2728)
+++ branches/avidemux_2.4_branch/avidemux/Makefile.am	2007-01-14 11:37:30 UTC (rev 2729)
@@ -125,13 +125,13 @@
 ./ADM_ocr/libADM_ocr.a					\
 $(libmpeg2enc_Altivec)
 if ADM_UI_GTK
-avidemux2_gtk_LDADD=$(adm_lib) $(user_interface_gtk) $(adm_postlib)
+avidemux2_gtk_LDADD=$(adm_lib) $(user_interface_gtk) $(adm_postlib) $(all_libraries)  $(SDL_LIBS) $(GTK_LIBS) $(FREETYPE_LIBS) $(FC_LIBS) $(ARTS_LIBS) $(XML_LIBS) $(GLIB_LIBS)
 endif
 
-avidemux2_cli_LDADD=$(adm_lib) $(user_interface_cli) $(adm_postlib) 
+avidemux2_cli_LDADD=$(adm_lib) $(user_interface_cli) $(adm_postlib) $(all_libraries)  $(SDL_LIBS) $(FREETYPE_LIBS) $(FC_LIBS) $(ARTS_LIBS) $(XML_LIBS)  $(GLIB_LIBS)
 
 if ADM_UI_QT4	
-avidemux2_qt4_LDADD=$(adm_lib) $(user_interface_qt4) $(adm_postlib) 
+avidemux2_qt4_LDADD=$(adm_lib) $(user_interface_qt4) $(adm_postlib) $(all_libraries)  $(SDL_LIBS) $(ADM_QTLIBS) $(FREETYPE_LIBS) $(FC_LIBS) $(ARTS_LIBS) $(XML_LIBS) $(GLIB_LIBS)
 endif
 
 
@@ -145,13 +145,13 @@
 
 # the library search path.
 if ADM_UI_GTK
-avidemux2_gtk_LDFLAGS=-Wl,--export-dynamic $(all_libraries)  $(SDL_LIBS) $(GTK_LIBS) $(FREETYPE_LIBS) $(FC_LIBS) $(ARTS_LIBS) $(XML_LIBS) $(GLIB_LIBS)
+avidemux2_gtk_LDFLAGS=-Wl,--export-dynamic 
 endif
 
-avidemux2_cli_LDFLAGS =-Wl,--export-dynamic  $(all_libraries)  $(SDL_LIBS) $(FREETYPE_LIBS) $(FC_LIBS) $(ARTS_LIBS) $(XML_LIBS)  $(GLIB_LIBS)
+avidemux2_cli_LDFLAGS =-Wl,--export-dynamic  
 
 if ADM_UI_QT4	
-avidemux2_qt4_LDFLAGS= -Wl,--export-dynamic $(all_libraries)  $(SDL_LIBS) $(ADM_QTLIBS) $(FREETYPE_LIBS) $(FC_LIBS) $(ARTS_LIBS) $(XML_LIBS) $(GLIB_LIBS)
+avidemux2_qt4_LDFLAGS= -Wl,--export-dynamic 
 endif
 
 noinst_HEADERS = 



From mean at mail.berlios.de  Sun Jan 14 12:48:01 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 14 Jan 2007 12:48:01 +0100
Subject: [Avidemux-svn-commit] r2730 -
	branches/avidemux_2.4_branch/avidemux/ADM_videoFilter
Message-ID: <200701141148.l0EBm1BX003718@sheep.berlios.de>

Author: mean
Date: 2007-01-14 12:48:00 +0100 (Sun, 14 Jan 2007)
New Revision: 2730

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDecTelecide.cpp
Log:
better explanation of dialog menu

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDecTelecide.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDecTelecide.cpp	2007-01-14 11:37:30 UTC (rev 2729)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDecTelecide.cpp	2007-01-14 11:48:00 UTC (rev 2730)
@@ -101,9 +101,9 @@
                              {POST_NONE,      _("None"),NULL},
                              {POST_METRICS,   _("None but compute"),NULL},
                              {POST_FULL,      _("Postproc on best match"),NULL},
-                             {POST_FULL_MAP,  _("Full map ??"),NULL},
-                             {POST_FULL_NOMATCH,_("Full no match ??"),NULL},
-                             {POST_FULL_NOMATCH_MAP,_("Full nomatch map ??"),NULL}
+                             {POST_FULL_MAP,  _("Postproc and show zones(debug)"),NULL},
+                             {POST_FULL_NOMATCH,_("Process image (not fields)"),NULL},
+                             {POST_FULL_NOMATCH_MAP,_("Process image (not fields),debug"),NULL}
           };
                              
           



From mean at mail.berlios.de  Sun Jan 14 14:23:05 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 14 Jan 2007 14:23:05 +0100
Subject: [Avidemux-svn-commit] r2731 - in
	branches/avidemux_2.4_branch/autononreg: . dialogFactory
Message-ID: <200701141323.l0EDN5jk023505@sheep.berlios.de>

Author: mean
Date: 2007-01-14 14:23:04 +0100 (Sun, 14 Jan 2007)
New Revision: 2731

Added:
   branches/avidemux_2.4_branch/autononreg/dialogFactory/
   branches/avidemux_2.4_branch/autononreg/dialogFactory/float.js
   branches/avidemux_2.4_branch/autononreg/dialogFactory/integer.js
   branches/avidemux_2.4_branch/autononreg/dialogFactory/menu.js
   branches/avidemux_2.4_branch/autononreg/dialogFactory/toggle.js
Log:
some dialogFactory test

Added: branches/avidemux_2.4_branch/autononreg/dialogFactory/float.js
===================================================================
--- branches/avidemux_2.4_branch/autononreg/dialogFactory/float.js	2007-01-14 11:48:00 UTC (rev 2730)
+++ branches/avidemux_2.4_branch/autononreg/dialogFactory/float.js	2007-01-14 13:23:04 UTC (rev 2731)
@@ -0,0 +1,10 @@
+//AD  <- These first 4 characters need to be the first 4 characters to identify the ECMAScript file to Avidemux
+var app = new Avidemux();
+var file="/work/samples/2mn.avi";
+var goodfcc="DIV3";
+var fps;
+
+	dialogFactoryFloat();
+
+/* End of test
+*/

Added: branches/avidemux_2.4_branch/autononreg/dialogFactory/integer.js
===================================================================
--- branches/avidemux_2.4_branch/autononreg/dialogFactory/integer.js	2007-01-14 11:48:00 UTC (rev 2730)
+++ branches/avidemux_2.4_branch/autononreg/dialogFactory/integer.js	2007-01-14 13:23:04 UTC (rev 2731)
@@ -0,0 +1,10 @@
+//AD  <- These first 4 characters need to be the first 4 characters to identify the ECMAScript file to Avidemux
+var app = new Avidemux();
+var file="/work/samples/2mn.avi";
+var goodfcc="DIV3";
+var fps;
+
+	dialogFactoryInt();
+
+/* End of test
+*/

Added: branches/avidemux_2.4_branch/autononreg/dialogFactory/menu.js
===================================================================
--- branches/avidemux_2.4_branch/autononreg/dialogFactory/menu.js	2007-01-14 11:48:00 UTC (rev 2730)
+++ branches/avidemux_2.4_branch/autononreg/dialogFactory/menu.js	2007-01-14 13:23:04 UTC (rev 2731)
@@ -0,0 +1,10 @@
+//AD  <- These first 4 characters need to be the first 4 characters to identify the ECMAScript file to Avidemux
+var app = new Avidemux();
+var file="/work/samples/2mn.avi";
+var goodfcc="DIV3";
+var fps;
+
+	dialogFactoryMenu();
+
+/* End of test
+*/

Added: branches/avidemux_2.4_branch/autononreg/dialogFactory/toggle.js
===================================================================
--- branches/avidemux_2.4_branch/autononreg/dialogFactory/toggle.js	2007-01-14 11:48:00 UTC (rev 2730)
+++ branches/avidemux_2.4_branch/autononreg/dialogFactory/toggle.js	2007-01-14 13:23:04 UTC (rev 2731)
@@ -0,0 +1,10 @@
+//AD  <- These first 4 characters need to be the first 4 characters to identify the ECMAScript file to Avidemux
+var app = new Avidemux();
+var file="/work/samples/2mn.avi";
+var goodfcc="DIV3";
+var fps;
+
+	dialogFactoryToggle();
+
+/* End of test
+*/



From mean at mail.berlios.de  Sun Jan 14 17:11:10 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 14 Jan 2007 17:11:10 +0100
Subject: [Avidemux-svn-commit] r2732 - in
	branches/avidemux_2.4_branch/avidemux: ADM_script
	ADM_userInterfaces/ADM_GTK/ADM_dialogFactory
	ADM_userInterfaces/ADM_NONE/ADM_dialog
	ADM_userInterfaces/ADM_QT4/ADM_dialog
	ADM_userInterfaces/ADM_QT4/ADM_dialogFactory ADM_video
	ADM_videoFilter
Message-ID: <200701141611.l0EGBAan005776@sheep.berlios.de>

Author: mean
Date: 2007-01-14 17:11:09 +0100 (Sun, 14 Jan 2007)
New Revision: 2732

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/FAC_integer.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/T_dialogFactory.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMSmooth_param.h
Removed:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/DIA_dialogFactory.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidIVTC.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidIVTC.h
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMSmooth_param.h
Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_script/ADM_JSFunctions.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/FAC_menu.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/FAC_toggle.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/Makefile.am
   branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMsmooth.cpp
Log:
QT4 version of dialogFactory

Modified: branches/avidemux_2.4_branch/avidemux/ADM_script/ADM_JSFunctions.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_script/ADM_JSFunctions.cpp	2007-01-14 13:23:04 UTC (rev 2731)
+++ branches/avidemux_2.4_branch/avidemux/ADM_script/ADM_JSFunctions.cpp	2007-01-14 16:11:09 UTC (rev 2732)
@@ -44,6 +44,8 @@
 #include "ADM_JSGlobal.h"
 #include "ADM_toolkit/filesel.h"
 
+#include "ADM_userInterfaces/ADM_commonUI/DIA_factory.h"
+
 std::vector <std::string> g_vIncludes;
 extern char **environ;
 extern char *script_getVar(char *in, int *r);
@@ -64,7 +66,12 @@
 JSBool systemInclude(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
 JSBool pathOnly(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
 
+JSBool facInt(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
+JSBool facFloat(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
+JSBool facToggle(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
+JSBool facMenu(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
 
+
 static JSFunctionSpec adm_functions[] = {
   /*    name          native          nargs    */
   {"displayError",      displayError,         1},
@@ -79,6 +86,10 @@
   {"exec",          systemExecute,        3},
   {"include",          systemInclude,        1},
   {"pathOnly",          pathOnly,        1},
+  {"dialogFactoryInt",          facInt,        0},
+  {"dialogFactoryFloat",        facFloat,        0},
+  {"dialogFactoryToggle",       facToggle,        0},
+  {"dialogFactoryMenu",         facMenu,        0},
   {0}
 };
 
@@ -445,3 +456,72 @@
   *rval=STRING_TO_JSVAL(JS_NewStringCopyZ(cx,orgName));
   return JS_TRUE;
 }// end systemExecute
+
+JSBool facInt(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+  uint32_t tog=0;
+   diaElemUInteger blend(&tog,_("Uinteger"),0,255);
+    diaElem *elems[]={&blend   };
+    
+  if(diaFactoryRun("Test uinteger",1,elems))
+  {
+    *rval = BOOLEAN_TO_JSVAL(1);
+    printf("Value : %u\n",tog);
+  }else
+    *rval = BOOLEAN_TO_JSVAL(0);
+  
+  return JS_TRUE;
+}
+JSBool facFloat(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+  ELEM_TYPE_FLOAT tog=0;
+   diaElemFloat blend(&tog,_("Float"),0,255);
+    diaElem *elems[]={&blend   };
+    
+  if(diaFactoryRun("Test float",1,elems))
+  {
+    *rval = BOOLEAN_TO_JSVAL(1);
+    printf("Value : %f\n",(float)tog);
+  }else
+    *rval = BOOLEAN_TO_JSVAL(0);
+  
+  
+  return JS_TRUE;
+}
+
+JSBool facToggle(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+  uint32_t tog=0;
+   diaElemToggle blend(&tog,_("Toggle"));
+    diaElem *elems[]={&blend   };
+    
+  if(diaFactoryRun("Test Toggle",1,elems))
+  {
+    *rval = BOOLEAN_TO_JSVAL(1);
+    printf("Value : %u\n",tog);
+  }else
+    *rval = BOOLEAN_TO_JSVAL(0);
+  return JS_TRUE;
+}
+
+JSBool facMenu(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+   uint32_t tog=0;
+   
+    diaMenuEntry menu[]={
+                             {2,   _("No Strategy"),NULL},
+                             {4,     _("3:2 Pulldown"),NULL},
+                             {6,     _("Pal/Secam"),NULL},
+                             {7,  _("NTSC converted from PAL"),NULL}
+                          };
+   diaElemMenu blend(&tog,_("menu"),4,menu);
+    diaElem *elems[]={&blend   };
+    
+  if(diaFactoryRun("Test Menu",1,elems))
+  {
+    *rval = BOOLEAN_TO_JSVAL(1);
+    printf("Value : %u\n",tog);
+  }else
+    *rval = BOOLEAN_TO_JSVAL(0);
+  return JS_TRUE;
+}

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/FAC_menu.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/FAC_menu.cpp	2007-01-14 13:23:04 UTC (rev 2731)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/FAC_menu.cpp	2007-01-14 16:11:09 UTC (rev 2732)
@@ -99,4 +99,8 @@
   *(uint32_t *)param=this->menu[rank].val;
 }
 
+
+
+
+
 //EOF

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp	2007-01-14 13:23:04 UTC (rev 2731)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp	2007-01-14 16:11:09 UTC (rev 2732)
@@ -41,7 +41,6 @@
 #include "ADM_audiofilter/audioencoder_lame_param.h"
 #include "ADM_audiofilter/audioencoder_lame_param.h"
 #include "ADM_encoder/adm_encmjpeg_param.h"
-#include "ADM_video/ADM_vidMSmooth_param.h"
 #include "ADM_video/ADM_vidPartial_param.h"
 #include "ADM_video/ADM_vidTDeint_param.h"
 #include "ADM_video/ADM_vidRotate_param.h"
@@ -96,7 +95,6 @@
 uint8_t DIA_getHue(Hue_Param *param, ADMImage *image){return 0;}
 uint8_t DIA_getHue(Hue_Param *param, AVDMGenericVideoStream *in){return 0;}
 uint8_t DIA_getMPdelogo(MPDELOGO_PARAM *param,AVDMGenericVideoStream *in){return 0;}
-uint8_t DIA_getMSmooth(MSMOOTH_PARAM *param){return 0;}
 uint8_t DIA_getPartial(PARTIAL_CONFIG *param,AVDMGenericVideoStream *son,AVDMGenericVideoStream *previous){return 0;}
 uint8_t DIA_mjpegCodecSetting(COMPRES_PARAMS *param){return 0;}
 uint8_t DIA_pipe(char **cmd,char **param){return 0;}

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp	2007-01-14 13:23:04 UTC (rev 2731)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp	2007-01-14 16:11:09 UTC (rev 2732)
@@ -41,7 +41,6 @@
 #include "ADM_audiofilter/audioencoder_lame_param.h"
 #include "ADM_audiofilter/audioencoder_lame_param.h"
 #include "ADM_encoder/adm_encmjpeg_param.h"
-#include "ADM_video/ADM_vidMSmooth_param.h"
 #include "ADM_video/ADM_vidPartial_param.h"
 #include "ADM_video/ADM_vidTDeint_param.h"
 #include "ADM_video/ADM_vidRotate_param.h"
@@ -96,7 +95,6 @@
 uint8_t DIA_getHue(Hue_Param *param, ADMImage *image){return 0;}
 uint8_t DIA_getHue(Hue_Param *param, AVDMGenericVideoStream *in){return 0;}
 uint8_t DIA_getMPdelogo(MPDELOGO_PARAM *param,AVDMGenericVideoStream *in){return 0;}
-uint8_t DIA_getMSmooth(MSMOOTH_PARAM *param){return 0;}
 uint8_t DIA_getPartial(PARTIAL_CONFIG *param,AVDMGenericVideoStream *son,AVDMGenericVideoStream *previous){return 0;}
 uint8_t DIA_mjpegCodecSetting(COMPRES_PARAMS *param){return 0;}
 uint8_t DIA_pipe(char **cmd,char **param){return 0;}

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/DIA_dialogFactory.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/DIA_dialogFactory.cpp	2007-01-14 13:23:04 UTC (rev 2731)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/DIA_dialogFactory.cpp	2007-01-14 16:11:09 UTC (rev 2732)
@@ -1,40 +0,0 @@
-/***************************************************************************
-  DIA_dialogFactory.cpp
-  (C) 2006 Mean Fixounet at free.fr 
-***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include <config.h>
-
-
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-
-#include "default.h"
-#include "ADM_commonUI/DIA_factory.h"
-#include "ADM_assert.h"
-
-/**
-    \fn diaFactoryRun(const char *title,uint32_t nb,diaElem **elems)
-    \brief  Run a dialog made of nb elems, each elem being described in the **elems
-    @return 0 on failure, 1 on success
-*/
-
-uint8_t diaFactoryRun(const char *title,uint32_t nb,diaElem **elems)
-{
-  return 0;
-  
-}
-
-
-
-//EOF

Added: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/FAC_integer.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/FAC_integer.cpp	2007-01-14 13:23:04 UTC (rev 2731)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/FAC_integer.cpp	2007-01-14 16:11:09 UTC (rev 2732)
@@ -0,0 +1,126 @@
+/***************************************************************************
+  FAC_toggle.cpp
+  Handle dialog factory element : Toggle
+  (C) 2006 Mean Fixounet at free.fr 
+***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include <config.h>
+
+
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <math.h>
+
+#include <QDialog>
+#include <QSpinBox>
+#include <QGridLayout>
+#include <QLabel>
+
+#include "default.h"
+#include "ADM_commonUI/DIA_factory.h"
+#include "ADM_assert.h"
+
+
+
+
+
+
+//********************************************************************
+diaElemInteger::diaElemInteger(int32_t *intValue,const char *toggleTitle, int32_t min, int32_t max,const char *tip)
+  : diaElem(ELEM_TOGGLE)
+{
+  param=(void *)intValue;
+  paramTitle=toggleTitle;
+  this->min=min;
+  this->max=max;
+  this->tip=tip;
+ }
+
+diaElemInteger::~diaElemInteger()
+{
+}
+void diaElemInteger::setMe(void *dialog, void *opaque,uint32_t line)
+{
+  QSpinBox *box=new QSpinBox((QWidget *)dialog);
+  QGridLayout *layout=(QGridLayout*) opaque;
+ myWidget=(void *)box; 
+   
+ box->setMinimum(min);
+ box->setMaximum(max);
+ box->setValue(*(int32_t *)param);
+ 
+ box->show();
+ 
+ QLabel *text=new QLabel( this->paramTitle,(QWidget *)dialog);
+ 
+ layout->addWidget(text,line,0);
+ layout->addWidget(box,line,1);
+ 
+}
+void diaElemInteger::getMe(void)
+{
+  int32_t val;
+ QSpinBox *box=(QSpinBox *)myWidget;
+ val=box->value();
+ if(val<min) val=min;
+ if(val>max) val=max;
+ *(int32_t *)param=val;
+ 
+}
+//******************************************************
+diaElemUInteger::diaElemUInteger(uint32_t *intValue,const char *toggleTitle, uint32_t min, uint32_t max,const char *tip)
+  : diaElem(ELEM_TOGGLE)
+{
+  param=(void *)intValue;
+  paramTitle=toggleTitle;
+  this->min=min;
+  this->max=max;
+  this->tip=tip;
+ }
+ 
+
+diaElemUInteger::~diaElemUInteger()
+{
+  
+}
+void diaElemUInteger::setMe(void *dialog, void *opaque,uint32_t line)
+{
+  QSpinBox *box=new QSpinBox((QWidget *)dialog);
+  QGridLayout *layout=(QGridLayout*) opaque;
+ myWidget=(void *)box; 
+   
+ box->setMinimum(min);
+ box->setMaximum(max);
+ box->setValue(*(uint32_t *)param);
+ 
+ box->show();
+ 
+ QLabel *text=new QLabel( this->paramTitle,(QWidget *)dialog);
+ 
+ layout->addWidget(text,line,0);
+ layout->addWidget(box,line,1);
+}
+void diaElemUInteger::getMe(void)
+{
+   uint32_t val;
+ QSpinBox *box=(QSpinBox *)myWidget;
+ val=box->value();
+ if(val<min) val=min;
+ if(val>max) val=max;
+ *(uint32_t *)param=val;
+
+}
+
+
+
+//EOF

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/FAC_toggle.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/FAC_toggle.cpp	2007-01-14 13:23:04 UTC (rev 2731)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/FAC_toggle.cpp	2007-01-14 16:11:09 UTC (rev 2732)
@@ -18,72 +18,59 @@
 
 #include <string.h>
 #include <stdio.h>
+#include <stdlib.h>
 #include <math.h>
 
+#include <QDialog>
+#include <QMessageBox>
+#include <QGridLayout>
+
 #include "default.h"
 #include "ADM_commonUI/DIA_factory.h"
 #include "ADM_assert.h"
 
-
-
-
+#include <QCheckBox>
 diaElemToggle::diaElemToggle(uint32_t *toggleValue,const char *toggleTitle, const char *tip)
   : diaElem(ELEM_TOGGLE)
 {
+  param=(void *)toggleValue;
+  paramTitle=toggleTitle;
+  this->tip=tip;
+  myWidget=NULL;
 }
 
 diaElemToggle::~diaElemToggle()
 {
-  
+  QCheckBox *box=(QCheckBox *)myWidget;
+ // if(box) delete box;
+  myWidget=NULL;
 }
 void diaElemToggle::setMe(void *dialog, void *opaque,uint32_t l)
 {
+ QCheckBox *box=new QCheckBox(paramTitle,(QWidget *)dialog);
+ QGridLayout *layout=(QGridLayout*) opaque;
+ myWidget=(void *)box; 
+ if( *(uint32_t *)param)
+ {
+    box->setCheckState(Qt::Checked); 
+ }
+ box->show();
+  layout->addWidget(box,l,0);
 }
 void diaElemToggle::getMe(void)
 {
+  QCheckBox *box=(QCheckBox *)myWidget;
+  uint32_t *val=(uint32_t *)param;
+  if(Qt::Checked==box->checkState())
+  {
+    *val=1; 
+  }else
+    *val=0;
 }
 
 
-
 //********************************************************************
-diaElemInteger::diaElemInteger(int32_t *intValue,const char *toggleTitle, int32_t min, int32_t max,const char *tip)
-  : diaElem(ELEM_TOGGLE)
-{
- }
 
-diaElemInteger::~diaElemInteger()
-{
-  
-}
-void diaElemInteger::setMe(void *dialog, void *opaque,uint32_t line)
-{
- 
-}
-void diaElemInteger::getMe(void)
-{
- 
-}
-//******************************************************
-diaElemUInteger::diaElemUInteger(uint32_t *intValue,const char *toggleTitle, uint32_t min, uint32_t max,const char *tip)
-  : diaElem(ELEM_TOGGLE)
-{
- }
-
-diaElemUInteger::~diaElemUInteger()
-{
-  
-}
-void diaElemUInteger::setMe(void *dialog, void *opaque,uint32_t line)
-{
- 
-}
-void diaElemUInteger::getMe(void)
-{
- 
-}
-
-//********************************************************************
-
 diaElemFloat::diaElemFloat(ELEM_TYPE_FLOAT *intValue,const char *toggleTitle, 
                             ELEM_TYPE_FLOAT min, ELEM_TYPE_FLOAT max,const char *tip)
   : diaElem(ELEM_FLOAT)
@@ -104,23 +91,4 @@
 }
 //******************************************************
 
-diaElemMenu::diaElemMenu(uint32_t *intValue,const char *itle, uint32_t nb, 
-               const diaMenuEntry *menu,const char *tip)
-  : diaElem(ELEM_MENU)
-{
-}
-
-diaElemMenu::~diaElemMenu()
-{
-  
-}
-void diaElemMenu::setMe(void *dialog, void *opaque,uint32_t line)
-{
-  
-}
-void diaElemMenu::getMe(void)
-{
- 
-}
-
 //EOF

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/Makefile.am	2007-01-14 13:23:04 UTC (rev 2731)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/Makefile.am	2007-01-14 16:11:09 UTC (rev 2732)
@@ -1,13 +1,14 @@
 
 noinst_LIBRARIES = libADM_dialogFactory.a 
 
-INCLUDES = $(all_includes) $(GTK_CFLAGS) $(XML_CFLAGS)  $(FREETYPE_CFLAGS) -DADM_SUBVERSION=@ADM_SUBVERSION@ \
-		-I../../../ADM_libraries/ADM_utilities \
-		-I../../ADM_commonUI -I../../.. -I../../../ADM_libraries/ADM_lavutil \
-		-I../../../ADM_inputs -I../../../ADM_outputs
-
 libADM_dialogFactory_a_METASOURCES = AUTO
 
-libADM_dialogFactory_a_SOURCES = DIA_dialogFactory.cpp FAC_toggle.cpp
+libADM_dialogFactory_a_SOURCES = AT_dialogFactory.cpp FAC_toggle.cpp FAC_integer.cpp FAC_menu.cpp
 
+INCLUDES = $(all_includes)  $(XML_CFLAGS)  $(FREETYPE_CFLAGS) -DADM_SUBVERSION=@ADM_SUBVERSION@ \
+                -I../../../ADM_libraries/ADM_utilities \
+                -I../../ADM_commonUI -I../../.. -I../../../ADM_libraries/ADM_lavutil \
+                -I../../../ADM_inputs -I../../../ADM_outputs @ADM_QTINCLUDES@
 
+include ../Makefile.adm
+

Copied: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/T_dialogFactory.cpp (from rev 2696, branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/DIA_dialogFactory.cpp)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/DIA_dialogFactory.cpp	2007-01-08 21:29:24 UTC (rev 2696)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/T_dialogFactory.cpp	2007-01-14 16:11:09 UTC (rev 2732)
@@ -0,0 +1,102 @@
+/***************************************************************************
+  DIA_dialogFactory.cpp
+  (C) 2007 Mean Fixounet at free.fr 
+***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include <config.h>
+
+
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <math.h>
+
+#include <QDialog>
+#include <QMessageBox>
+#include <QGridLayout>
+#include <QDialogButtonBox>
+#include <QDialogButtonBox>
+#include <QPushButton>
+
+#include "default.h"
+#include "ADM_commonUI/DIA_factory.h"
+#include "ADM_assert.h"
+
+class factoryWindow : public QDialog
+{
+     Q_OBJECT
+
+ public:
+     factoryWindow();
+ public slots:
+ private slots:
+ private:
+};
+
+
+factoryWindow::factoryWindow()     : QDialog()
+ {
+//     ui.setupUi(this);
+     //connect( (ui.pushButton),SIGNAL(pressed()),this,SLOT(buttonPressed()));
+ }
+
+
+/**
+    \fn diaFactoryRun(const char *title,uint32_t nb,diaElem **elems)
+    \brief  Run a dialog made of nb elems, each elem being described in the **elems
+    @return 0 on failure, 1 on success
+*/
+
+uint8_t diaFactoryRun(const char *title,uint32_t nb,diaElem **elems)
+{
+  factoryWindow dialog;
+  
+  ADM_assert(title);
+  ADM_assert(nb);
+  ADM_assert(elems);
+  
+  dialog.setWindowTitle(title);
+  
+  QGridLayout layout(&dialog);
+  
+  for(int i=0;i<nb;i++)
+  {
+    ADM_assert(elems[i]);
+     elems[i]->setMe( (void *)&dialog,&layout,i); 
+    
+  }
+  // Add buttons
+   QDialogButtonBox buttonBox((QWidget *)&dialog);
+    buttonBox.setStandardButtons(QDialogButtonBox::Ok
+                            | QDialogButtonBox::Cancel);
+     QObject::connect(&buttonBox, SIGNAL(accepted()), &dialog, SLOT(accept()));
+     QObject::connect(&buttonBox, SIGNAL(rejected()), &dialog, SLOT(reject()));
+     layout.addWidget(&buttonBox,nb,0);
+  // run
+  dialog.setLayout(&layout);
+  if(dialog.exec()==QDialog::Accepted)
+  {
+     for(int i=0;i<nb;i++)
+     {
+        ADM_assert(elems[i]);
+        elems[i]->getMe(); 
+    
+      }
+    return 1;
+  }
+  return 0;
+  
+}
+
+
+
+//EOF

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidIVTC.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidIVTC.cpp	2007-01-14 13:23:04 UTC (rev 2731)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidIVTC.cpp	2007-01-14 16:11:09 UTC (rev 2732)
@@ -1,295 +0,0 @@
-/***************************************************************************
-                         Brute force ivtc
-
-	We look at how interlaced the frames are
-	On FILM -> NTSC the pattern should be like
-
-	1  2 3 4 -> 11 22 23 34 44
-
-	23 and 34 being interlaced. We recombine them (y & uv)
-
-	If we cannot decide we drop a frame
-
-	The dubious case is when we got 1st and last frame ilaced
-
-    begin                : Thu Mar 21 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-#if 0
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <ADM_assert.h>
-
-#include "config.h"
-#include "fourcc.h"
-#include "avio.hxx"
-#include "config.h"
-#include "avi_vars.h"
-
-
-#include "ADM_toolkit/toolkit.hxx"
-#include "ADM_editor/ADM_edit.hxx"
-#include "ADM_video/ADM_genvideo.hxx"
-#include "ADM_video/ADM_vidFieldUtil.h"
-#include "ADM_video/ADM_vidIVTC.h"
-#include "ADM_video/ADM_interlaced.h"
-#include "ADM_toolkit/TLK_clock.h"
-#include "ADM_toolkit/ADM_debugID.h"
-#define MODULE_NAME MODULE_FILTER
-#include "ADM_toolkit/ADM_debug.h"
-
-BUILD_CREATE(ivtc_create,ADMVideoIVTC);
-
-// 0 -> Merge
-// 1 -> Chroma forward
-// 2-> Chroma backward
-#define MERGE_FIELDS 0
-char *ADMVideoIVTC::printConf( void )
-{
- 	static char buf[50];
-
- 	sprintf((char *)buf," IVTC");
-        return buf;
-}
-//_______________________________________________________________
-ADMVideoIVTC::ADMVideoIVTC(
-									AVDMGenericVideoStream *in,CONFcouple *setup)
-{
-UNUSED_ARG(setup);
-  	_in=in;
-   	memcpy(&_info,_in->getInfo(),sizeof(_info));
-	_info.fps1000=(_info.fps1000*4)/5;
-	_info.nb_frames=(_info.nb_frames*4)/5;
-	for(uint32_t i=0;i<5;i++)
-	{
-		_uncompressed[i]=new uint8_t[3*_info.width*_info.height];
-	}
-	_cacheStart=0xffffff;
-	_old1=0;
-	_old2=0;
-	_confidence=0;
-	_shifted=0;
-}
-// ___ destructor_____________
-ADMVideoIVTC::~ADMVideoIVTC()
-{
-	for(uint32_t i=0;i<5;i++)
-	{
- 		delete [] _uncompressed[i];
-	}
-}
-
-
-uint8_t ADMVideoIVTC::getFrameNumberNoAlloc(uint32_t frame,
-										uint32_t *len	,
-										uint8_t *data,
-										uint32_t *flags)
-{
-//static Image in,out;
-			if(frame>=_info.nb_frames)
-			{
-				printf("out of bound frame (%lu / %lu)\n",frame,_info.nb_frames);
-				return 0;
-			}
-
-		uint32_t w=_info.width;
-		uint32_t h=_info.height;
-		uint32_t page=w*h;
-		uint32_t i;
-
-		uint32_t target;
-		uint32_t loop=0;
-
-		*len=(page*3)>>1;
-
-cont:
-
-		target=frame-((frame)%4);
-		// got it ?
-		if(_cacheStart==target)
-		{
-			uint32_t index;
-
-			aprintf("Filter: It is in cache...(cachestart=%lu)\n",_cacheStart);
-			index=frame%4;
-			aprintf(" index : %lu skipped : %lu\n",index,_skipped);
-			if(index>=_skipped) index++;
-			aprintf(" index : %lu skipped : %lu\n",index,_skipped);
-			memcpy(data,_uncompressed[index],*len);
-			*flags=0;
-			return 1;
-		}
-		else
-		{
-			aprintf("Not in cache...\n");
-		}
-		ADM_assert(!loop);
-		loop++;
-		// Else ask the 5 corresponding frame
-		_cacheStart=target;
-		target=(target*5)>>2;
-
-		uint32_t dflags,dlen;
-
-		for( i=0;i<5;i++)
-			{
-				
-	 			if(!_in->getFrameNumberNoAlloc(target+i, &dlen,_uncompressed[i],&dflags))
-				 {
-				 	 	printf("Cannot get frame %lu\n",target+i);
-					 	return 0;
-				 }
-
-			}
-		// Now we look up, there must be 2 i-laced and 3 progressive
-		// First try looking the 2 last i-laced we had to see if they are still there
-
-		// if not, we do each one of them and keep the lowest interlaced
-		uint32_t laced[5];
-	// look up the one that as max interlacing
-		int max1=-1;
-		int max2=-1;
-		int max=0;
-		Clock clock;
-		uint32_t k;
-
-		k=clock.getElapsedMS();
-		aprintf("\n confidence : %lu old1 :%lu old2: %lu\n",_confidence,_old1,_old2);
-		if(_confidence>25) _confidence=2; // we reavluate from time to time
-		if(_confidence>5) // just check oldmax1
-		{
-			// if old1 is interlaced, we assume it is ok
-			if(ADMVideo_interlaceCount(_uncompressed[_old1],_info.width,_info.height)>10)
-			{
-				aprintf("\n Seems good %d is interlaced !\n",_old1);
-				max1=_old1;
-				max2=_old2;
-				goto fnd;
-			}
-			else
-			{
-				aprintf(" Does not seems interlaced enough\n");
-			}
-		}
-		// we are not very confident, check it
-		for( i=0;i<5;i++)
-			{
-
-				laced[i]=ADMVideo_interlaceCount(_uncompressed[i],_info.width,_info.height);
-				aprintf(" Frame %d has %lu icing factor\n",target+i,laced[i]);
-			}
-		printf("  bench : %lu\n",clock.getElapsedMS() -k);
-
-
-		for( i=0;i<5;i++)
-			{
-				if(max<laced[i])
-					{
-						max=laced[i];
-						max1=i;
-					}
-			}
-
-
-		max=0;
-		for( i=0;i<5;i++)
-			{
-				if(max<laced[i] && i!=max1)
-					{
-						max=laced[i];
-						max2=i;
-					}
-			}
-
-		if(max1>max2)
-		{
-			int tmp;
-			tmp=max1;
-			max1=max2;
-			max2=tmp;
-		}
-		aprintf("Detect max1: %d max2: %d\n",max1,max2);
-		if(max1==0 && max2==4)
-		{
-			printf("\n warning : dubious case \n");
-		}
-		if((max1==_old1) && (max2==_old2))
-		{
-			_confidence++;
-		}
-		else
-		if((max1==_old1) || (max2==_old2)||(max1==_old2)||(max2==_old1) && _confidence>5)
-		{	// One of them match we keep using it
-			max2=_old2;
-			max1=_old1;
-			aprintf("we use hinted...\n");
-		}
-		else
-		{ // neither match, we reset everything
-			_confidence=0;
-			if(((max1+1!=max2)&&(max2+1!=max1))||max1==-1||max2==-1)
-			{
-				aprintf("max1: %d max2: %d\n",max1,max2);
-				aprintf("out of order fields\n");
-				goto cont;
-			}
-			if(max1>max2)
-				{
-					max1=max2;
-					max2++;
-				}
-			_old1=max1;
-			_old2=max2;
-
-			_confidence=1;
-
-		}
-fnd:
-		aprintf(" Max1 is %d max2 is %d\n",max1,max2);
-
-		// take upper field from max1 and lower field from max2
-
-		uint8_t *in,*out;
-		in=_uncompressed[max2];
-		out=_uncompressed[max1];
-
-		// merge them
-		for(uint32_t y=0;y<_info.height>>1;y++)
-		{
-			memcpy(out,in,_info.width);
-			in+=_info.width<<1;
-			out+=_info.width<<1;
-		}
-
-		// ditto for chroma
-
-
-		in=_uncompressed[max2]+page;
-		out=_uncompressed[max1]+page;
-
-		for(uint32_t y=0;y<_info.height>>2;y++)
-		{
-			memcpy(out,in,_info.width>>1);
-			in+=_info.width;
-			out+=_info.width;
-		}
-		// and copy others
-		_skipped=max2;
-		goto cont;
-		return 1;
-}
-
-
-
-#endif

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidIVTC.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidIVTC.h	2007-01-14 13:23:04 UTC (rev 2731)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidIVTC.h	2007-01-14 16:11:09 UTC (rev 2732)
@@ -1,45 +0,0 @@
-/***************************************************************************
-                          ADM_IVTC.h  -  description
-                             -------------------
-	A brute force IVTC
-
-    begin                : Sat May 23 2003
-    copyright            : (C) 2002/3 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifndef VID_IVTC_
-#define VID_IVTC_
-
- class  ADMVideoIVTC:public AVDMGenericVideoStream
- {
-
- protected:
-    		
-		uint8_t					*_uncompressed[6];
-		uint32_t					_cacheStart;
-     		virtual 	char 			*printConf(void);
-				uint32_t      		getMatch( uint8_t *src );
-		uint32_t					_old1,_old2,_confidence;
-		uint32_t					_skipped;
-		uint32_t					_shifted;
- public:
-
-
-  				ADMVideoIVTC(  AVDMGenericVideoStream *in,CONFcouple *setup);
-
-  	virtual 		~ADMVideoIVTC();
-	virtual uint8_t 	getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-          								ADMImage *data,uint32_t *flags);
-	virtual uint8_t configure( AVDMGenericVideoStream *instream) {return 1;};
-
- }     ;
-#endif

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMSmooth_param.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMSmooth_param.h	2007-01-14 13:23:04 UTC (rev 2731)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMSmooth_param.h	2007-01-14 16:11:09 UTC (rev 2732)
@@ -1,6 +0,0 @@
-typedef struct MSMOOTH_PARAM
-{
-	uint32_t  showmask, highq;
-	uint32_t  threshold, strength;
-
-};

Modified: branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am	2007-01-14 13:23:04 UTC (rev 2731)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am	2007-01-14 16:11:09 UTC (rev 2732)
@@ -28,8 +28,7 @@
  ADM_confCouple.h ADM_vidCommonFilter.h \
 	ADM_vidChromaShift.h ADM_vidChromaShift.cpp \
 	ADM_vidMPLResize.cpp \
- ADM_vidIVTC.cpp \
- ADM_vidIVTC.h ADM_interlaced.cpp \
+ ADM_interlaced.cpp \
 	ADM_interlaced.h \
  ADM_vidRaw.cpp \
 	ADM_vidSRTRender.cpp \
@@ -99,7 +98,7 @@
 ADM_vidContrast.cpp  ADM_vidMPdelogo.cpp \
 ADM_vidContrast.h  ADM_vidMPdelogo.h \
 ADM_vobsubinfo.cpp \
-ADM_vidCrop.cpp  ADM_vidMSmooth_param.h  ADM_vobsubinfo.h \
+ADM_vidCrop.cpp  ADM_vobsubinfo.h \
 swscale_internal.h \
 ADM_vidTdeint_util.txt ADM_vidASS.h ADM_vidASS.cpp \
 ADM_vidAss_Params.h mmx_macros.h
@@ -108,6 +107,6 @@
 INCLUDES = $(all_includes) -I../ADM_libraries -I../ADM_libraries/ADM_utilities -I../ADM_libraries/ADM_lavutil \
 			 $(FREETYPE_CFLAGS) $(ALTIVEC_SWITCH) -I../ADM_userInterfaces/ADM_commonUI -I../ADM_inputs
 noinst_HEADERS = ADM_mpdetc.h \
-					  ADM_cache.h \
-					ADM_vidMSmooth_param.h ADM_vidEqualizer.h ADM_vobsubinfo.h ADM_vidVobSub.h \
-		ADM_vidEq2.h ADM_vidASS.h
+  ADM_cache.h \
+ADM_vidEqualizer.h ADM_vobsubinfo.h ADM_vidVobSub.h \
+ADM_vidEq2.h ADM_vidASS.h

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMSmooth_param.h (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMSmooth_param.h)

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMsmooth.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMsmooth.cpp	2007-01-14 13:23:04 UTC (rev 2731)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMsmooth.cpp	2007-01-14 16:11:09 UTC (rev 2732)
@@ -69,7 +69,7 @@
 	(fp) = vidCache->getImage(GETFRAMEf); \
 }
 
-#include "ADM_video/ADM_vidMSmooth_param.h"
+#include "ADM_vidMSmooth_param.h"
 
 
 extern uint8_t 	PutHintingData(unsigned char *video, unsigned int hint);



From mean at mail.berlios.de  Sun Jan 14 17:21:03 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 14 Jan 2007 17:21:03 +0100
Subject: [Avidemux-svn-commit] r2733 -
	branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory
Message-ID: <200701141621.l0EGL3xS006575@sheep.berlios.de>

Author: mean
Date: 2007-01-14 17:21:02 +0100 (Sun, 14 Jan 2007)
New Revision: 2733

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/FAC_float.cpp
Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/FAC_toggle.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/Makefile.am
Log:
dialogFactory for QT4 : Float

Added: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/FAC_float.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/FAC_float.cpp	2007-01-14 16:11:09 UTC (rev 2732)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/FAC_float.cpp	2007-01-14 16:21:02 UTC (rev 2733)
@@ -0,0 +1,77 @@
+/***************************************************************************
+  FAC_toggle.cpp
+  Handle dialog factory element : Toggle
+  (C) 2006 Mean Fixounet at free.fr 
+***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include <config.h>
+
+
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <math.h>
+
+#include <QDialog>
+#include <QSpinBox>
+#include <QGridLayout>
+#include <QLabel>
+
+#include "default.h"
+#include "ADM_commonUI/DIA_factory.h"
+#include "ADM_assert.h"
+
+
+
+
+//********************************************************************
+diaElemFloat::diaElemFloat(ELEM_TYPE_FLOAT *intValue,const char *toggleTitle, ELEM_TYPE_FLOAT min, ELEM_TYPE_FLOAT max,const char *tip)
+  : diaElem(ELEM_TOGGLE)
+{
+  param=(void *)intValue;
+  paramTitle=toggleTitle;
+  this->min=min;
+  this->max=max;
+  this->tip=tip;
+ }
+
+diaElemFloat::~diaElemFloat()
+{
+}
+void diaElemFloat::setMe(void *dialog, void *opaque,uint32_t line)
+{
+  QDoubleSpinBox *box=new QDoubleSpinBox((QWidget *)dialog);
+  QGridLayout *layout=(QGridLayout*) opaque;
+ myWidget=(void *)box; 
+   
+ box->setMinimum(min);
+ box->setMaximum(max);
+ box->setValue(*(ELEM_TYPE_FLOAT *)param);
+ 
+ box->show();
+ 
+ QLabel *text=new QLabel( this->paramTitle,(QWidget *)dialog);
+ 
+ layout->addWidget(text,line,0);
+ layout->addWidget(box,line,1);
+ 
+}
+void diaElemFloat::getMe(void)
+{
+  double val;
+ QDoubleSpinBox *box=(QDoubleSpinBox *)myWidget;
+ val=box->value();
+ if(val<min) val=min;
+ if(val>max) val=max;
+ *(ELEM_TYPE_FLOAT *)param=val;
+ 
+}
\ No newline at end of file

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/FAC_toggle.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/FAC_toggle.cpp	2007-01-14 16:11:09 UTC (rev 2732)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/FAC_toggle.cpp	2007-01-14 16:21:02 UTC (rev 2733)
@@ -69,26 +69,7 @@
 }
 
 
-//********************************************************************
 
-diaElemFloat::diaElemFloat(ELEM_TYPE_FLOAT *intValue,const char *toggleTitle, 
-                            ELEM_TYPE_FLOAT min, ELEM_TYPE_FLOAT max,const char *tip)
-  : diaElem(ELEM_FLOAT)
-{
-}
-
-diaElemFloat::~diaElemFloat()
-{
-  
-}
-void diaElemFloat::setMe(void *dialog, void *opaque,uint32_t line)
-{
-  
-}
-void diaElemFloat::getMe(void)
-{
- 
-}
 //******************************************************
 
 //EOF

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/Makefile.am	2007-01-14 16:11:09 UTC (rev 2732)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/Makefile.am	2007-01-14 16:21:02 UTC (rev 2733)
@@ -3,8 +3,9 @@
 
 libADM_dialogFactory_a_METASOURCES = AUTO
 
-libADM_dialogFactory_a_SOURCES = AT_dialogFactory.cpp FAC_toggle.cpp FAC_integer.cpp FAC_menu.cpp
+libADM_dialogFactory_a_SOURCES = AT_dialogFactory.cpp FAC_toggle.cpp FAC_integer.cpp FAC_menu.cpp FAC_float.cpp
 
+
 INCLUDES = $(all_includes)  $(XML_CFLAGS)  $(FREETYPE_CFLAGS) -DADM_SUBVERSION=@ADM_SUBVERSION@ \
                 -I../../../ADM_libraries/ADM_utilities \
                 -I../../ADM_commonUI -I../../.. -I../../../ADM_libraries/ADM_lavutil \



From mean at mail.berlios.de  Sun Jan 14 17:21:44 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 14 Jan 2007 17:21:44 +0100
Subject: [Avidemux-svn-commit] r2734 -
	branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory
Message-ID: <200701141621.l0EGLiMa006705@sheep.berlios.de>

Author: mean
Date: 2007-01-14 17:21:44 +0100 (Sun, 14 Jan 2007)
New Revision: 2734

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/FAC_menu.cpp
Log:
menu for QT4

Added: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/FAC_menu.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/FAC_menu.cpp	2007-01-14 16:21:02 UTC (rev 2733)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/FAC_menu.cpp	2007-01-14 16:21:44 UTC (rev 2734)
@@ -0,0 +1,87 @@
+/***************************************************************************
+  FAC_toggle.cpp
+  Handle dialog factory element : Toggle
+  (C) 2006 Mean Fixounet at free.fr 
+***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include <config.h>
+
+
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <math.h>
+
+#include <QDialog>
+#include <QComboBox>
+#include <QLabel>
+#include <QGridLayout>
+
+#include "default.h"
+#include "ADM_commonUI/DIA_factory.h"
+#include "ADM_assert.h"
+
+#include <QCheckBox>
+
+
+
+
+diaElemMenu::diaElemMenu(uint32_t *intValue,const char *itle, uint32_t nb, 
+               const diaMenuEntry *menu,const char *tip)
+  : diaElem(ELEM_MENU)
+{
+  param=(void *)intValue;
+  paramTitle=itle;
+  this->tip=tip;
+  this->menu=menu;
+  this->nbMenu=nb;
+}
+
+diaElemMenu::~diaElemMenu()
+{
+  
+}
+void diaElemMenu::setMe(void *dialog, void *opaque,uint32_t line)
+{
+  QComboBox *combo=new QComboBox( (QWidget *)dialog);
+  QGridLayout *layout=(QGridLayout*) opaque;
+     myWidget=(void *)combo; 
+
+  QLabel *text=new QLabel( this->paramTitle,(QWidget *)dialog);
+  
+  // Fill in combobox
+  int mem=0;
+  const diaMenuEntry *entries=menu;
+  for(int i=0;i<nbMenu;i++)
+  {
+    combo->addItem(entries[i].text);
+    if( *(uint32_t *)param==entries[i].val) mem=i;
+  }
+   combo->setCurrentIndex(mem);
+   layout->addWidget(text,line,0);
+   layout->addWidget(combo,line,1);
+}
+
+void diaElemMenu::getMe(void)
+{
+  QComboBox *combo=(QComboBox *)myWidget;
+  int r;
+  r=combo->currentIndex();
+  ADM_assert(r<nbMenu);
+  *(uint32_t *)param=menu[r].val;
+      
+}
+
+
+
+
+//EOF



From mean at mail.berlios.de  Sun Jan 14 21:39:46 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 14 Jan 2007 21:39:46 +0100
Subject: [Avidemux-svn-commit] r2735 - in
	branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4:
	ADM_dialogFactory ADM_filters
Message-ID: <200701142039.l0EKdk2a005484@sheep.berlios.de>

Author: mean
Date: 2007-01-14 21:39:45 +0100 (Sun, 14 Jan 2007)
New Revision: 2735

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/FAC_toggle.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/Q_mainfilter.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/mainfilter.ui
Log:
more QT4 dialog

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/FAC_toggle.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/FAC_toggle.cpp	2007-01-14 16:21:44 UTC (rev 2734)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/FAC_toggle.cpp	2007-01-14 20:39:45 UTC (rev 2735)
@@ -24,12 +24,13 @@
 #include <QDialog>
 #include <QMessageBox>
 #include <QGridLayout>
+#include <QCheckBox>
 
 #include "default.h"
 #include "ADM_commonUI/DIA_factory.h"
 #include "ADM_assert.h"
 
-#include <QCheckBox>
+
 diaElemToggle::diaElemToggle(uint32_t *toggleValue,const char *toggleTitle, const char *tip)
   : diaElem(ELEM_TOGGLE)
 {

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/Q_mainfilter.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/Q_mainfilter.cpp	2007-01-14 16:21:44 UTC (rev 2734)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/Q_mainfilter.cpp	2007-01-14 20:39:45 UTC (rev 2735)
@@ -33,6 +33,7 @@
 /*******************************************************/
 #define NB_TREE 7
 static int startFilter[NB_TREE];
+static int filterSize[NB_TREE];
 static int max=0;
 /******************************************************/
 extern FILTER_ENTRY allfilters[MAX_FILTER];
@@ -41,7 +42,7 @@
 extern uint32_t nb_active_filter;
 extern const char  *filterGetNameFromTag(VF_FILTERS tag);
 extern ADM_Composer *video_body;
-
+extern AVDMGenericVideoStream *filterCreateFromTag(VF_FILTERS tag,CONFcouple *conf, AVDMGenericVideoStream *in) ;
 /*******************************************************/
 class filtermainWindow : public QDialog
 {
@@ -54,26 +55,87 @@
      void             buildActiveFilterList(void);
      Ui_mainFilterDialog ui;
      
-     QStringList      allList[NB_TREE];
-     QStringListModel allModel[NB_TREE];
+     QListWidget      *allList[NB_TREE];
      
+     
      QStringList      activeList;
      QStringListModel activeModel;
      
      
  public slots:
+        void add(bool b);
+        void remove(bool b);
+        void configure(bool b);
+        void partial(bool b);
  private slots:
  private:
 };
+
 /**
+
+*/
+void filtermainWindow::add( bool b)
+{
+  
+  /* Get selection if any */
+  int tab=ui.tabWidgetSubtitles->currentIndex();
+  ADM_assert(tab>=0 && tab < NB_TREE);
+  /* Now that we have the tab, get the selection */
+   QListWidgetItem *item=allList[tab]->currentItem();
+   if(item)
+   {
+     int itag=item->type()-1000;
+      printf("Tag : %d\n",itag);
+      VF_FILTERS tag=(VF_FILTERS) itag;
+      // Create our filter...
+      
+       CONFcouple *coup;
+        videofilters[nb_active_filter].filter =
+            filterCreateFromTag (tag, NULL, videofilters[nb_active_filter - 1].filter);
+        if(!videofilters[nb_active_filter].filter->
+                    configure (videofilters[nb_active_filter - 1].filter))
+        {
+            delete videofilters[nb_active_filter].filter;
+            return;
+        }
+        videofilters[nb_active_filter].filter->getCoupledConf (&coup);
+        videofilters[nb_active_filter].tag = tag;
+        videofilters[nb_active_filter].conf = coup;
+        nb_active_filter++;
+        buildActiveFilterList();
+   }
+}
+/**
+
+*/
+void filtermainWindow::remove( bool b)
+{
+  printf("remove\n"); 
+}
+/**
+
+*/
+void filtermainWindow::configure( bool b)
+{
+  printf("configure\n"); 
+}
+/**
+
+*/
+void filtermainWindow::partial( bool b)
+{
+  printf("partial\n"); 
+}
+
+/**
         \fn     buildAvailableFilterList(void)
         \brief  build the internal datas needed to handle the list
 */
 void filtermainWindow::buildAvailableFilterList(void)
 {
   int current_tree=-1;
+  int current_raw=0;;
   
-  
   max=0;
   for (uint32_t i = 0; i < nb_video_filter; i++)
     {
@@ -83,22 +145,26 @@
           str+=allfilters[i].name;
           str+=":";//"</b><br>";
           str+=allfilters[i].description;
-          allList[current_tree]+=str;
           max++;
+          current_raw++;
+          QListWidgetItem *item=new QListWidgetItem(str,allList[current_tree],1000+allfilters[i].tag);
+          allList[current_tree]->addItem(item);
+          
         }else 
         {
                 current_tree++;
+                if(current_tree) filterSize[current_tree-1]=current_raw;
                 if(current_tree>=NB_TREE) break;
+                allList[current_tree]->clear();
                 startFilter[current_tree]=i+1;
+                current_raw=0;
+                
         }
     }
    
     
     ADM_assert(NB_TREE==7);
-    for(int i=0;i<NB_TREE;i++)
-    {
-      allModel[i].setStringList(allList[i]);
-    }
+  
 }
   /**
         \fn     buildActiveFilterList(void)
@@ -124,22 +190,30 @@
   */
 filtermainWindow::filtermainWindow()     : QDialog()
  {
+      ui.setupUi(this);
+      
+#define ASSOCIATE(x,y)   allList[x]=ui.listWidget##y
+      ASSOCIATE(0,Transform);
+      ASSOCIATE(1,Interlacing);
+      ASSOCIATE(2,Colors);
+      ASSOCIATE(3,Noise);
+      ASSOCIATE(4,Sharpness);
+      ASSOCIATE(5,Subtitles);
+      ASSOCIATE(6,Misc);
+      
+      
       buildAvailableFilterList();
       buildActiveFilterList();
-      ui.setupUi(this);
       
-    
-    ui.listViewTransform->setModel(&(allModel[0]));
-    ui.listViewInterlacing->setModel(&(allModel[1]));
-    ui.listViewColors->setModel(&(allModel[2]));
-    ui.listViewNoise->setModel(&(allModel[3]));;
-    ui.listViewSharpness->setModel(&(allModel[4]));;
-    ui.listViewSubtitles->setModel(&(allModel[5]));;
-    ui.listViewMisc->setModel(&(allModel[6]));;
       
+      
     ui.listViewActive->setModel(&activeModel);
 
+    connect((ui.toolButtonConfigure),SIGNAL(clicked(bool)),this,SLOT(configure(bool)));
+    connect((ui.toolButtonAdd),SIGNAL(clicked(bool)),this,SLOT(add(bool)));
+    connect((ui.pushButtonRemove),SIGNAL(clicked(bool)),this,SLOT(remove(bool)));
 
+    connect(ui.buttonClose, SIGNAL(clicked(bool)), this, SLOT(accept()));
  }
 /*******************************************************/
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/mainfilter.ui
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/mainfilter.ui	2007-01-14 16:21:44 UTC (rev 2734)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/mainfilter.ui	2007-01-14 20:39:45 UTC (rev 2735)
@@ -6,7 +6,7 @@
     <x>0</x>
     <y>0</y>
     <width>1024</width>
-    <height>682</height>
+    <height>650</height>
    </rect>
   </property>
   <property name="windowTitle" >
@@ -55,10 +55,13 @@
       </spacer>
      </item>
      <item>
-      <widget class="QToolButton" name="toolButton" >
+      <widget class="QToolButton" name="toolButtonAdd" >
        <property name="text" >
-        <string>...</string>
+        <string>Add</string>
        </property>
+       <property name="toolButtonStyle" >
+        <enum>Qt::ToolButtonTextUnderIcon</enum>
+       </property>
       </widget>
      </item>
     </layout>
@@ -129,6 +132,13 @@
       </widget>
      </item>
      <item>
+      <widget class="QPushButton" name="pushButtonRemove" >
+       <property name="text" >
+        <string>Remove</string>
+       </property>
+      </widget>
+     </item>
+     <item>
       <widget class="QToolButton" name="toolButtonPartial" >
        <property name="text" >
         <string>Partial</string>
@@ -177,7 +187,7 @@
         <number>6</number>
        </property>
        <item row="0" column="0" >
-        <widget class="QListView" name="listViewTransform" />
+        <widget class="QListWidget" name="listWidgetTransform" />
        </item>
       </layout>
      </widget>
@@ -193,7 +203,7 @@
         <number>6</number>
        </property>
        <item row="0" column="0" >
-        <widget class="QListView" name="listViewInterlacing" />
+        <widget class="QListWidget" name="listWidgetInterlacing" />
        </item>
       </layout>
      </widget>
@@ -209,7 +219,7 @@
         <number>6</number>
        </property>
        <item row="0" column="0" >
-        <widget class="QListView" name="listViewColors" />
+        <widget class="QListWidget" name="listWidgetColors" />
        </item>
       </layout>
      </widget>
@@ -225,7 +235,7 @@
         <number>6</number>
        </property>
        <item row="0" column="0" >
-        <widget class="QListView" name="listViewNoise" />
+        <widget class="QListWidget" name="listWidgetNoise" />
        </item>
       </layout>
      </widget>
@@ -241,7 +251,7 @@
         <number>6</number>
        </property>
        <item row="0" column="0" >
-        <widget class="QListView" name="listViewSharpness" />
+        <widget class="QListWidget" name="listWidgetSharpness" />
        </item>
       </layout>
      </widget>
@@ -257,7 +267,7 @@
         <number>6</number>
        </property>
        <item row="0" column="0" >
-        <widget class="QListView" name="listViewSubtitles" />
+        <widget class="QListWidget" name="listWidgetSubtitles" />
        </item>
       </layout>
      </widget>
@@ -273,7 +283,7 @@
         <number>6</number>
        </property>
        <item row="0" column="0" >
-        <widget class="QListView" name="listViewMisc" />
+        <widget class="QListWidget" name="listWidgetMisc" />
        </item>
       </layout>
      </widget>



From mean at mail.berlios.de  Mon Jan 15 08:46:57 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Mon, 15 Jan 2007 08:46:57 +0100
Subject: [Avidemux-svn-commit] r2737 -
	branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters
Message-ID: <200701150746.l0F7kvsg004475@sheep.berlios.de>

Author: mean
Date: 2007-01-15 08:46:56 +0100 (Mon, 15 Jan 2007)
New Revision: 2737

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/Q_mainfilter.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/mainfilter.ui
Log:
improved QT4 filter dialog

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/Q_mainfilter.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/Q_mainfilter.cpp	2007-01-14 22:38:57 UTC (rev 2736)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/Q_mainfilter.cpp	2007-01-15 07:46:56 UTC (rev 2737)
@@ -1,8 +1,26 @@
-//
-/*
- * DO NOT EDIT THIS FILE - it is generated by Glade.
- */
+/***************************************************************************
+    copyright            : (C) 2007 by mean
+    email                : fixounet at free.fr
+    
+    * We hide some info the the "type"
+    * I.e.
+    0--1000 : QT4 internal
+    2000-3000: Filters
+    3000-4000  External Filter
+    8000-9000  Active Filter
+    
+    
+ ***************************************************************************/
 
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
 #include "config.h"
 #include <stdio.h>
 #include <stdlib.h>
@@ -36,6 +54,10 @@
 static int filterSize[NB_TREE];
 static int max=0;
 /******************************************************/
+#define ALL_FILTER_BASE       1000
+#define EXTERNAL_FILTER_BASE  2000
+#define ACTIVE_FILTER_BASE    3000
+/******************************************************/
 extern FILTER_ENTRY allfilters[MAX_FILTER];
 extern uint32_t nb_video_filter;
 extern FILTER videofilters[MAX_FILTER];
@@ -58,15 +80,17 @@
      QListWidget      *allList[NB_TREE];
      
      
-     QStringList      activeList;
-     QStringListModel activeModel;
+     QListWidget      *activeList;
      
      
+     
  public slots:
         void add(bool b);
         void remove(bool b);
         void configure(bool b);
         void partial(bool b);
+        void activeDoubleClick( QListWidgetItem  *item);
+        void allDoubleClick( QListWidgetItem  *item);
  private slots:
  private:
 };
@@ -82,18 +106,25 @@
   ADM_assert(tab>=0 && tab < NB_TREE);
   /* Now that we have the tab, get the selection */
    QListWidgetItem *item=allList[tab]->currentItem();
+   VF_FILTERS tag;
    if(item)
    {
-     int itag=item->type()-1000;
+     int itag=item->type();
+     if(itag>=ALL_FILTER_BASE && itag < EXTERNAL_FILTER_BASE)
+     {
+       tag=allfilters[itag-ALL_FILTER_BASE].tag;
+       
+     }else
+     {
+        ADM_assert(0); 
+     }
       printf("Tag : %d\n",itag);
-      VF_FILTERS tag=(VF_FILTERS) itag;
+      
       // Create our filter...
       
        CONFcouple *coup;
-        videofilters[nb_active_filter].filter =
-            filterCreateFromTag (tag, NULL, videofilters[nb_active_filter - 1].filter);
-        if(!videofilters[nb_active_filter].filter->
-                    configure (videofilters[nb_active_filter - 1].filter))
+        videofilters[nb_active_filter].filter = filterCreateFromTag (tag, NULL, videofilters[nb_active_filter - 1].filter);
+        if(!videofilters[nb_active_filter].filter->    configure (videofilters[nb_active_filter - 1].filter))
         {
             delete videofilters[nb_active_filter].filter;
             return;
@@ -106,20 +137,99 @@
    }
 }
 /**
-
+        \fn     remove( bool b)
+        \brief  Remove selected filters from the active window list
 */
 void filtermainWindow::remove( bool b)
 {
-  printf("remove\n"); 
+   /* Get selection if any */
+  /* Now that we have the tab, get the selection */
+   QListWidgetItem *item=activeList->currentItem();
+   if(!item)
+   {
+      printf("No selection\n");
+      return;
+   }
+    
+     int itag=item->type();
+     ADM_assert(itag>ACTIVE_FILTER_BASE);
+     itag-=ACTIVE_FILTER_BASE;
+     /* Filter 0 is the decoder ...*/
+      printf("Rank : %d\n",itag); 
+     ADM_assert(itag);
+     /**/
+      if (videofilters[itag].conf)
+            {
+                    delete videofilters[itag].conf;
+                    videofilters[itag].conf = NULL;
+            }
+        // recreate derivated filters
+        for (uint32_t i = itag ; i < nb_active_filter-1; i++)
+        {
+                    delete videofilters[i ].filter;
+                    videofilters[i ].filter = filterCreateFromTag(videofilters[i+1].tag,
+                                                    videofilters[i+1].conf,
+                                                    videofilters[i - 1].filter);
+                    videofilters[i ].conf = videofilters[i+1].conf;
+                    videofilters[i ].tag = videofilters[i+1].tag;
+        }
+        /* Delete last filter which is now at last filter -1 */
+            delete videofilters[nb_active_filter - 1].filter;
+            videofilters[nb_active_filter - 1].filter = NULL;
+            nb_active_filter--;
+            buildActiveFilterList ();
+  
 }
 /**
-
+        \fn     configure( bool b)
+        \brief  Configure the selected active filter
 */
 void filtermainWindow::configure( bool b)
 {
-  printf("configure\n"); 
+   /* Get selection if any */
+  /* Now that we have the tab, get the selection */
+   QListWidgetItem *item=activeList->currentItem();
+   if(!item)
+   {
+      printf("No selection\n");
+      return;
+   }
+    
+     int itag=item->type();
+     ADM_assert(itag>ACTIVE_FILTER_BASE);
+     itag-=ACTIVE_FILTER_BASE;
+     /* Filter 0 is the decoder ...*/
+      printf("Rank : %d\n",itag); 
+     ADM_assert(itag);
+     /**/
+     
+        if(!videofilters[itag].filter->configure (videofilters[itag - 1].filter)) return;
+        /* Recreate chain if needed , config has changed */
+        CONFcouple *couple;
+        videofilters[itag].filter->getCoupledConf (&couple);
+        videofilters[itag].conf = couple;
+        getFirstVideoFilter ();
+        buildActiveFilterList ();
 }
 /**
+        \fn     filtermainWindow::activeDoubleClick( QListWidgetItem  *item)
+        \brief  One of the active window has been double clicked, call configure
+*/
+void filtermainWindow::activeDoubleClick( QListWidgetItem  *item)
+{
+  
+    configure(0);
+}
+/**
+        \fn     filtermainWindow::activeDoubleClick( QListWidgetItem  *item)
+        \brief  One of the active window has been double clicked, call configure
+*/
+void filtermainWindow::allDoubleClick( QListWidgetItem  *item)
+{
+  
+    add(0);
+}
+/**
 
 */
 void filtermainWindow::partial( bool b)
@@ -144,11 +254,14 @@
           QString str; //="<b>";
           str+=allfilters[i].name;
           str+=":";//"</b><br>";
-          str+=allfilters[i].description;
+//           str+="<b>";
+          str+=allfilters[i].description; // Mem leak ?
+//           str+="</b>";
           max++;
+          
+          QListWidgetItem *item=new QListWidgetItem(str,allList[current_tree],ALL_FILTER_BASE+i);
+          allList[current_tree]->addItem(item);
           current_raw++;
-          QListWidgetItem *item=new QListWidgetItem(str,allList[current_tree],1000+allfilters[i].tag);
-          allList[current_tree]->addItem(item);
           
         }else 
         {
@@ -173,7 +286,7 @@
 void filtermainWindow::buildActiveFilterList(void)
 {
   VF_FILTERS fil;
-  activeList.clear();
+  activeList->clear();
   for (uint32_t i = 1; i < nb_active_filter; i++)
     {
                 QString str;
@@ -181,9 +294,10 @@
 
                  str =filterGetNameFromTag(fil);
                  str+= videofilters[i].filter->printConf ();
-                 activeList+=str;
+                 QListWidgetItem *item=new QListWidgetItem(str,activeList,ACTIVE_FILTER_BASE+i);
+                 activeList->addItem(item);
     }
-    activeModel.setStringList(activeList);
+    
 
 }
   /**
@@ -192,7 +306,7 @@
  {
       ui.setupUi(this);
       
-#define ASSOCIATE(x,y)   allList[x]=ui.listWidget##y
+#define ASSOCIATE(x,y)   allList[x]=ui.listWidget##y;
       ASSOCIATE(0,Transform);
       ASSOCIATE(1,Interlacing);
       ASSOCIATE(2,Colors);
@@ -201,13 +315,18 @@
       ASSOCIATE(5,Subtitles);
       ASSOCIATE(6,Misc);
       
+      activeList=ui.listWidgetActive;
       
       buildAvailableFilterList();
       buildActiveFilterList();
       
       
       
-    ui.listViewActive->setModel(&activeModel);
+    connect(activeList,SIGNAL(itemDoubleClicked(QListWidgetItem *)),this,SLOT(activeDoubleClick(QListWidgetItem *)));
+    for(int i=0;i<NB_TREE;i++)
+    {
+      connect(allList[i],SIGNAL(itemDoubleClicked(QListWidgetItem *)),this,SLOT(allDoubleClick(QListWidgetItem *)));
+    }
 
     connect((ui.toolButtonConfigure),SIGNAL(clicked(bool)),this,SLOT(configure(bool)));
     connect((ui.toolButtonAdd),SIGNAL(clicked(bool)),this,SLOT(add(bool)));

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/mainfilter.ui
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/mainfilter.ui	2007-01-14 22:38:57 UTC (rev 2736)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/mainfilter.ui	2007-01-15 07:46:56 UTC (rev 2737)
@@ -290,7 +290,7 @@
     </widget>
    </item>
    <item row="1" column="1" >
-    <widget class="QListView" name="listViewActive" />
+    <widget class="QListWidget" name="listWidgetActive" />
    </item>
   </layout>
  </widget>



From mean at mail.berlios.de  Mon Jan 15 20:09:59 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Mon, 15 Jan 2007 20:09:59 +0100
Subject: [Avidemux-svn-commit] r2738 - in
	branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4:
	ADM_filters ADM_filters/icons ADM_gui
Message-ID: <200701151909.l0FJ9xrp021547@sheep.berlios.de>

Author: mean
Date: 2007-01-15 20:09:58 +0100 (Mon, 15 Jan 2007)
New Revision: 2738

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/filter.qrc
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/icons/
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/icons/1.png
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/icons/2.png
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/icons/3.png
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/icons/4.png
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/icons/5.png
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/icons/6.png
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/icons/7.png
Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/Makefile.am
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/Q_mainfilter.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/mainfilter.ui
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/Q_gui2.cpp
Log:
Better filter dialog for QT4

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/Makefile.am	2007-01-15 07:46:56 UTC (rev 2737)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/Makefile.am	2007-01-15 19:09:58 UTC (rev 2738)
@@ -1,6 +1,6 @@
 
 noinst_LIBRARIES = libADM_filters.a 
-libADM_filters_a_SOURCES =  filter_none.cpp AQ_mainfilter.cpp
+libADM_filters_a_SOURCES =  filter_none.cpp AQ_mainfilter.cpp filter_rsc.cpp
 
 INCLUDES = $(all_includes)  $(XML_CFLAGS)  $(FREETYPE_CFLAGS) -DADM_SUBVERSION=@ADM_SUBVERSION@ \
 		-I../../../ADM_libraries/ADM_utilities \
@@ -11,6 +11,8 @@
 
 
 include ../Makefile.adm
+filter_rsc.cpp : filter.qrc
+	rcc  $< -o $@   -name filter
 
 
 EXTRA_DIST =  

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/Q_mainfilter.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/Q_mainfilter.cpp	2007-01-15 07:46:56 UTC (rev 2737)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/Q_mainfilter.cpp	2007-01-15 19:09:58 UTC (rev 2738)
@@ -86,6 +86,8 @@
      
  public slots:
         void add(bool b);
+        void up(bool b);
+        void down(bool b);
         void remove(bool b);
         void configure(bool b);
         void partial(bool b);
@@ -96,7 +98,8 @@
 };
 
 /**
-
+        \fn     add( bool b)
+        \brief  Retrieve the selected filter and add it to the active filters
 */
 void filtermainWindow::add( bool b)
 {
@@ -212,6 +215,69 @@
         buildActiveFilterList ();
 }
 /**
+        \fn     up( bool b)
+        \brief  Move selected filter one place up
+*/
+void filtermainWindow::up( bool b)
+{
+   QListWidgetItem *item=activeList->currentItem();
+   if(!item)
+   {
+      printf("No selection\n");
+      return;
+   }
+    
+     int itag=item->type();
+     ADM_assert(itag>ACTIVE_FILTER_BASE);
+     itag-=ACTIVE_FILTER_BASE;
+     /* Filter 0 is the decoder ...*/
+      printf("Rank : %d\n",itag); 
+     ADM_assert(itag);
+     
+     if (itag < 2) return;
+        // swap action parameter & action parameter -1
+        FILTER tmp;
+        memcpy (&tmp, &videofilters[itag - 1], sizeof (FILTER));
+        memcpy (&videofilters[itag - 1],
+            &videofilters[itag], sizeof (FILTER));
+        memcpy (&videofilters[itag], &tmp, sizeof (FILTER));
+        getFirstVideoFilter ();
+        buildActiveFilterList ();   
+}
+/**
+        \fn     down( bool b)
+        \brief  Move selected filter one place down
+*/
+void filtermainWindow::down( bool b)
+{
+   QListWidgetItem *item=activeList->currentItem();
+   if(!item)
+   {
+      printf("No selection\n");
+      return;
+   }
+    
+     int itag=item->type();
+     ADM_assert(itag>ACTIVE_FILTER_BASE);
+     itag-=ACTIVE_FILTER_BASE;
+     /* Filter 0 is the decoder ...*/
+      printf("Rank : %d\n",itag); 
+     ADM_assert(itag);
+     
+    if (((int) itag < (int) (nb_active_filter - 1)) && (itag))
+        {
+            // swap action parameter & action parameter -1
+            FILTER tmp;
+            memcpy (&tmp, &videofilters[itag + 1], sizeof (FILTER));
+            memcpy (&videofilters[itag + 1],
+                        &videofilters[itag], sizeof (FILTER));
+            memcpy (&videofilters[itag], &tmp, sizeof (FILTER));
+            getFirstVideoFilter ();
+             buildActiveFilterList ();   
+        }
+}
+
+/**
         \fn     filtermainWindow::activeDoubleClick( QListWidgetItem  *item)
         \brief  One of the active window has been double clicked, call configure
 */
@@ -239,7 +305,7 @@
 
 /**
         \fn     buildAvailableFilterList(void)
-        \brief  build the internal datas needed to handle the list
+        \brief  build the internal datas needed to handle the list. Need to be called only once.
 */
 void filtermainWindow::buildAvailableFilterList(void)
 {
@@ -331,7 +397,8 @@
     connect((ui.toolButtonConfigure),SIGNAL(clicked(bool)),this,SLOT(configure(bool)));
     connect((ui.toolButtonAdd),SIGNAL(clicked(bool)),this,SLOT(add(bool)));
     connect((ui.pushButtonRemove),SIGNAL(clicked(bool)),this,SLOT(remove(bool)));
-
+    connect((ui.toolButtonUp),SIGNAL(clicked(bool)),this,SLOT(up(bool)));
+    connect((ui.toolButtonDown),SIGNAL(clicked(bool)),this,SLOT(down(bool)));
     connect(ui.buttonClose, SIGNAL(clicked(bool)), this, SLOT(accept()));
  }
 /*******************************************************/

Added: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/filter.qrc
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/filter.qrc	2007-01-15 07:46:56 UTC (rev 2737)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/filter.qrc	2007-01-15 19:09:58 UTC (rev 2738)
@@ -0,0 +1,11 @@
+<RCC>
+    <qresource prefix="/new/prefix1" >
+        <file>icons/1.png</file>
+        <file>icons/2.png</file>
+        <file>icons/3.png</file>
+        <file>icons/4.png</file>
+        <file>icons/5.png</file>
+        <file>icons/6.png</file>
+        <file>icons/7.png</file>
+    </qresource>
+</RCC>

Added: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/icons/1.png
===================================================================
(Binary files differ)


Property changes on: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/icons/1.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/icons/2.png
===================================================================
(Binary files differ)


Property changes on: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/icons/2.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/icons/3.png
===================================================================
(Binary files differ)


Property changes on: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/icons/3.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/icons/4.png
===================================================================
(Binary files differ)


Property changes on: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/icons/4.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/icons/5.png
===================================================================
(Binary files differ)


Property changes on: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/icons/5.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/icons/6.png
===================================================================
(Binary files differ)


Property changes on: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/icons/6.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/icons/7.png
===================================================================
(Binary files differ)


Property changes on: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/icons/7.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/mainfilter.ui
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/mainfilter.ui	2007-01-15 07:46:56 UTC (rev 2737)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/mainfilter.ui	2007-01-15 19:09:58 UTC (rev 2738)
@@ -22,15 +22,18 @@
    <item row="0" column="1" >
     <widget class="QLabel" name="label_2" >
      <property name="text" >
-      <string>Active Filters</string>
+      <string>&lt;big>&lt;b>Active Filters&lt;/b>&lt;/big></string>
      </property>
     </widget>
    </item>
    <item row="0" column="0" >
     <widget class="QLabel" name="label" >
      <property name="text" >
-      <string>Available Filters</string>
+      <string>&lt;big>&lt;b>Available Filters&lt;/b>&lt;/big></string>
      </property>
+     <property name="textFormat" >
+      <enum>Qt::RichText</enum>
+     </property>
     </widget>
    </item>
    <item row="2" column="0" >
@@ -99,6 +102,9 @@
        <property name="text" >
         <string>Close</string>
        </property>
+       <property name="default" >
+        <bool>true</bool>
+       </property>
       </widget>
      </item>
     </layout>
@@ -164,21 +170,24 @@
    <item row="1" column="0" >
     <widget class="QTabWidget" name="tabWidgetSubtitles" >
      <property name="tabPosition" >
-      <enum>QTabWidget::West</enum>
+      <enum>QTabWidget::North</enum>
      </property>
      <property name="tabShape" >
       <enum>QTabWidget::Rounded</enum>
      </property>
      <property name="currentIndex" >
-      <number>6</number>
+      <number>5</number>
      </property>
      <property name="elideMode" >
       <enum>Qt::ElideLeft</enum>
      </property>
      <widget class="QWidget" name="Transform" >
       <attribute name="title" >
-       <string>Page</string>
+       <string>Transfom</string>
       </attribute>
+      <attribute name="icon" >
+       <iconset resource="filter.qrc" >:/new/prefix1/icons/1.png</iconset>
+      </attribute>
       <layout class="QGridLayout" >
        <property name="margin" >
         <number>9</number>
@@ -193,8 +202,14 @@
      </widget>
      <widget class="QWidget" name="Interlacing" >
       <attribute name="title" >
-       <string>Page</string>
+       <string>Interlacing</string>
       </attribute>
+      <attribute name="icon" >
+       <iconset resource="filter.qrc" >:/new/prefix1/icons/2.png</iconset>
+      </attribute>
+      <attribute name="toolTip" >
+       <string>Interlacing</string>
+      </attribute>
       <layout class="QGridLayout" >
        <property name="margin" >
         <number>9</number>
@@ -209,8 +224,11 @@
      </widget>
      <widget class="QWidget" name="Colors" >
       <attribute name="title" >
-       <string>Page</string>
+       <string>Colors</string>
       </attribute>
+      <attribute name="icon" >
+       <iconset resource="filter.qrc" >:/new/prefix1/icons/4.png</iconset>
+      </attribute>
       <layout class="QGridLayout" >
        <property name="margin" >
         <number>9</number>
@@ -225,8 +243,11 @@
      </widget>
      <widget class="QWidget" name="Noise" >
       <attribute name="title" >
-       <string>Page</string>
+       <string>Noise</string>
       </attribute>
+      <attribute name="icon" >
+       <iconset resource="filter.qrc" >:/new/prefix1/icons/5.png</iconset>
+      </attribute>
       <layout class="QGridLayout" >
        <property name="margin" >
         <number>9</number>
@@ -241,8 +262,14 @@
      </widget>
      <widget class="QWidget" name="Subtitles" >
       <attribute name="title" >
-       <string>Page</string>
+       <string>Sharpness</string>
       </attribute>
+      <attribute name="icon" >
+       <iconset resource="filter.qrc" >:/new/prefix1/icons/3.png</iconset>
+      </attribute>
+      <attribute name="toolTip" >
+       <string>Sharpness</string>
+      </attribute>
       <layout class="QGridLayout" >
        <property name="margin" >
         <number>9</number>
@@ -257,8 +284,14 @@
      </widget>
      <widget class="QWidget" name="Sharpness" >
       <attribute name="title" >
-       <string>Page</string>
+       <string>Subtitles</string>
       </attribute>
+      <attribute name="icon" >
+       <iconset resource="filter.qrc" >:/new/prefix1/icons/7.png</iconset>
+      </attribute>
+      <attribute name="toolTip" >
+       <string>Subtitles</string>
+      </attribute>
       <layout class="QGridLayout" >
        <property name="margin" >
         <number>9</number>
@@ -273,8 +306,11 @@
      </widget>
      <widget class="QWidget" name="Misc" >
       <attribute name="title" >
-       <string>Page</string>
+       <string>Misc</string>
       </attribute>
+      <attribute name="icon" >
+       <iconset resource="filter.qrc" >:/new/prefix1/icons/6.png</iconset>
+      </attribute>
       <layout class="QGridLayout" >
        <property name="margin" >
         <number>9</number>
@@ -294,6 +330,8 @@
    </item>
   </layout>
  </widget>
- <resources/>
+ <resources>
+  <include location="filter.qrc" />
+ </resources>
  <connections/>
 </ui>

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/Q_gui2.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/Q_gui2.cpp	2007-01-15 07:46:56 UTC (rev 2737)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/Q_gui2.cpp	2007-01-15 19:09:58 UTC (rev 2738)
@@ -235,6 +235,7 @@
 int UI_RunApp(void)
 {
 Q_INIT_RESOURCE(avidemux);
+Q_INIT_RESOURCE(filter);
    QApplication a( global_argc, global_argv );
    MainWindow * mw = new MainWindow();
     



From mean at mail.berlios.de  Tue Jan 16 20:22:30 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 16 Jan 2007 20:22:30 +0100
Subject: [Avidemux-svn-commit] r2739 - in
	branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK:
	. glade
Message-ID: <200701161922.l0GJMU6s012934@sheep.berlios.de>

Author: mean
Date: 2007-01-16 20:22:29 +0100 (Tue, 16 Jan 2007)
New Revision: 2739

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/glade/
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/glade/gtk2_build.glade
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/glade/prefs.glade
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/glade/project_x264.glade
Log:
added up to date or about glade files

Added: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/glade/gtk2_build.glade
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/glade/gtk2_build.glade	2007-01-15 19:09:58 UTC (rev 2738)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/glade/gtk2_build.glade	2007-01-16 19:22:29 UTC (rev 2739)
@@ -0,0 +1,2536 @@
+<?xml version="1.0" standalone="no"?> <!--*- mode: xml -*-->
+<!DOCTYPE glade-interface SYSTEM "http://glade.gnome.org/glade-2.0.dtd">
+
+<glade-interface>
+
+<widget class="GtkWindow" id="mainWindow">
+  <property name="visible">True</property>
+  <property name="title" translatable="yes">Avidemux</property>
+  <property name="type">GTK_WINDOW_TOPLEVEL</property>
+  <property name="window_position">GTK_WIN_POS_NONE</property>
+  <property name="modal">False</property>
+  <property name="resizable">True</property>
+  <property name="destroy_with_parent">False</property>
+  <property name="icon">avidemux_icon_small.png</property>
+  <property name="decorated">True</property>
+  <property name="skip_taskbar_hint">False</property>
+  <property name="skip_pager_hint">False</property>
+  <property name="type_hint">GDK_WINDOW_TYPE_HINT_NORMAL</property>
+  <property name="gravity">GDK_GRAVITY_NORTH_WEST</property>
+  <property name="focus_on_map">True</property>
+  <property name="urgency_hint">False</property>
+
+  <child>
+    <widget class="GtkVBox" id="vbox1">
+      <property name="visible">True</property>
+      <property name="homogeneous">False</property>
+      <property name="spacing">0</property>
+
+      <child>
+	<widget class="GtkMenuBar" id="menuBar">
+	  <property name="visible">True</property>
+	  <property name="can_focus">True</property>
+	  <property name="pack_direction">GTK_PACK_DIRECTION_LTR</property>
+	  <property name="child_pack_direction">GTK_PACK_DIRECTION_LTR</property>
+
+	  <child>
+	    <widget class="GtkMenuItem" id="menuitem1">
+	      <property name="visible">True</property>
+	      <property name="label" translatable="yes">_File</property>
+	      <property name="use_underline">True</property>
+
+	      <child>
+		<widget class="GtkMenu" id="menuitem1_menu">
+
+		  <child>
+		    <widget class="GtkImageMenuItem" id="open_video1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_Open...</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="O" modifiers="GDK_CONTROL_MASK" signal="activate"/>
+
+		      <child internal-child="image">
+			<widget class="GtkImage" id="image7996">
+			  <property name="visible">True</property>
+			  <property name="stock">gtk-open</property>
+			  <property name="icon_size">1</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkImageMenuItem" id="append_video1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_Append...</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="A" modifiers="GDK_CONTROL_MASK | GDK_MOD1_MASK" signal="activate"/>
+
+		      <child internal-child="image">
+			<widget class="GtkImage" id="image7997">
+			  <property name="visible">True</property>
+			  <property name="stock">gtk-add</property>
+			  <property name="icon_size">1</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkImageMenuItem" id="save_stuff">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_Save</property>
+		      <property name="use_underline">True</property>
+
+		      <child internal-child="image">
+			<widget class="GtkImage" id="image7998">
+			  <property name="visible">True</property>
+			  <property name="stock">gtk-save</property>
+			  <property name="icon_size">1</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+
+		      <child>
+			<widget class="GtkMenu" id="save_stuff_menu">
+
+			  <child>
+			    <widget class="GtkMenuItem" id="save_as_avi1">
+			      <property name="visible">True</property>
+			      <property name="label" translatable="yes">Save _Video...</property>
+			      <property name="use_underline">True</property>
+			      <accelerator key="S" modifiers="GDK_CONTROL_MASK" signal="activate"/>
+			    </widget>
+			  </child>
+
+			  <child>
+			    <widget class="GtkSeparatorMenuItem" id="separator1">
+			      <property name="visible">True</property>
+			    </widget>
+			  </child>
+
+			  <child>
+			    <widget class="GtkMenuItem" id="save_image1">
+			      <property name="visible">True</property>
+			      <property name="label" translatable="yes">Save _BMP Image...</property>
+			      <property name="use_underline">True</property>
+			    </widget>
+			  </child>
+
+			  <child>
+			    <widget class="GtkMenuItem" id="save_jpg_image1">
+			      <property name="visible">True</property>
+			      <property name="label" translatable="yes">Save _JPEG Image...</property>
+			      <property name="use_underline">True</property>
+			    </widget>
+			  </child>
+
+			  <child>
+			    <widget class="GtkMenuItem" id="save_selection_as_jpegs1">
+			      <property name="visible">True</property>
+			      <property name="label" translatable="yes">Save _Selection as JPEG images...</property>
+			      <property name="use_underline">True</property>
+			    </widget>
+			  </child>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkSeparatorMenuItem" id="separator3">
+		      <property name="visible">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkImageMenuItem" id="save_project1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Save _Project</property>
+		      <property name="use_underline">True</property>
+
+		      <child internal-child="image">
+			<widget class="GtkImage" id="image7999">
+			  <property name="visible">True</property>
+			  <property name="stock">gtk-save</property>
+			  <property name="icon_size">1</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkImageMenuItem" id="save_project_as1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Save P_roject As...</property>
+		      <property name="use_underline">True</property>
+
+		      <child internal-child="image">
+			<widget class="GtkImage" id="image8000">
+			  <property name="visible">True</property>
+			  <property name="stock">gtk-save-as</property>
+			  <property name="icon_size">1</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkImageMenuItem" id="run_script1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_Load/Run Project...</property>
+		      <property name="use_underline">True</property>
+
+		      <child internal-child="image">
+			<widget class="GtkImage" id="image8001">
+			  <property name="visible">True</property>
+			  <property name="stock">gtk-execute</property>
+			  <property name="icon_size">1</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="add_to_joblist1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">A_dd to Joblist...</property>
+		      <property name="use_underline">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="joblist1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Show _Joblist</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="J" modifiers="GDK_CONTROL_MASK" signal="activate"/>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkSeparatorMenuItem" id="separator16">
+		      <property name="visible">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkImageMenuItem" id="video_informations1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Proper_ties</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="Return" modifiers="GDK_MOD1_MASK" signal="activate"/>
+
+		      <child internal-child="image">
+			<widget class="GtkImage" id="image8002">
+			  <property name="visible">True</property>
+			  <property name="stock">gtk-properties</property>
+			  <property name="icon_size">1</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="avi_muxer_options1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">AVI _Muxer Options</property>
+		      <property name="use_underline">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkSeparatorMenuItem" id="separator4">
+		      <property name="visible">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkImageMenuItem" id="quit1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_Quit</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="Q" modifiers="GDK_CONTROL_MASK" signal="activate"/>
+
+		      <child internal-child="image">
+			<widget class="GtkImage" id="image8003">
+			  <property name="visible">True</property>
+			  <property name="stock">gtk-quit</property>
+			  <property name="icon_size">1</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+		</widget>
+	      </child>
+	    </widget>
+	  </child>
+
+	  <child>
+	    <widget class="GtkMenuItem" id="menuitem2">
+	      <property name="visible">True</property>
+	      <property name="label" translatable="yes">_Edit</property>
+	      <property name="use_underline">True</property>
+
+	      <child>
+		<widget class="GtkMenu" id="menuitem2_menu">
+
+		  <child>
+		    <widget class="GtkImageMenuItem" id="reset_edits1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_Reset Edits</property>
+		      <property name="use_underline">True</property>
+
+		      <child internal-child="image">
+			<widget class="GtkImage" id="image8004">
+			  <property name="visible">True</property>
+			  <property name="stock">gtk-undo</property>
+			  <property name="icon_size">1</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkSeparatorMenuItem" id="separator5">
+		      <property name="visible">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkImageMenuItem" id="cut1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Cu_t</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="X" modifiers="GDK_CONTROL_MASK" signal="activate"/>
+
+		      <child internal-child="image">
+			<widget class="GtkImage" id="image8005">
+			  <property name="visible">True</property>
+			  <property name="stock">gtk-cut</property>
+			  <property name="icon_size">1</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkImageMenuItem" id="copy1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_Copy</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="C" modifiers="GDK_CONTROL_MASK" signal="activate"/>
+
+		      <child internal-child="image">
+			<widget class="GtkImage" id="image8006">
+			  <property name="visible">True</property>
+			  <property name="stock">gtk-copy</property>
+			  <property name="icon_size">1</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkImageMenuItem" id="paste1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_Paste</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="V" modifiers="GDK_CONTROL_MASK" signal="activate"/>
+
+		      <child internal-child="image">
+			<widget class="GtkImage" id="image8007">
+			  <property name="visible">True</property>
+			  <property name="stock">gtk-paste</property>
+			  <property name="icon_size">1</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkImageMenuItem" id="delete1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_Delete</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="Delete" modifiers="0" signal="activate"/>
+
+		      <child internal-child="image">
+			<widget class="GtkImage" id="image8008">
+			  <property name="visible">True</property>
+			  <property name="stock">gtk-remove</property>
+			  <property name="icon_size">1</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkSeparatorMenuItem" id="separator6">
+		      <property name="visible">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="set_marker_a1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Set Marker _A</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="bracketleft" modifiers="0" signal="activate"/>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="set_marker_b1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Set Marker _B</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="bracketright" modifiers="0" signal="activate"/>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkSeparatorMenuItem" id="separator7">
+		      <property name="visible">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkImageMenuItem" id="preferences1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Pre_ferences</property>
+		      <property name="use_underline">True</property>
+
+		      <child internal-child="image">
+			<widget class="GtkImage" id="image8009">
+			  <property name="visible">True</property>
+			  <property name="stock">gtk-preferences</property>
+			  <property name="icon_size">1</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+		</widget>
+	      </child>
+	    </widget>
+	  </child>
+
+	  <child>
+	    <widget class="GtkMenuItem" id="view1">
+	      <property name="visible">True</property>
+	      <property name="label" translatable="yes">_View</property>
+	      <property name="use_underline">True</property>
+
+	      <child>
+		<widget class="GtkMenu" id="view1_menu">
+
+		  <child>
+		    <widget class="GtkCheckMenuItem" id="toolbar1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_Main Toolbar</property>
+		      <property name="use_underline">True</property>
+		      <property name="active">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkCheckMenuItem" id="sidebar1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_A/V Sidebar</property>
+		      <property name="use_underline">True</property>
+		      <property name="active">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkSeparatorMenuItem" id="separator8">
+		      <property name="visible">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="zoom_1_4">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_Zoom 1:4</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="4" modifiers="GDK_CONTROL_MASK | GDK_SHIFT_MASK" signal="activate"/>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="zoom_1_2">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Z_oom 1:2</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="2" modifiers="GDK_CONTROL_MASK | GDK_SHIFT_MASK" signal="activate"/>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="zoom_1_1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Zoom _1:1</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="1" modifiers="GDK_CONTROL_MASK" signal="activate"/>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="zoom_2_1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Zoom _2:1</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="2" modifiers="GDK_CONTROL_MASK" signal="activate"/>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="zoom_4_1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Zoom _4:1</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="4" modifiers="GDK_CONTROL_MASK" signal="activate"/>
+		    </widget>
+		  </child>
+		</widget>
+	      </child>
+	    </widget>
+	  </child>
+
+	  <child>
+	    <widget class="GtkMenuItem" id="video_1">
+	      <property name="visible">True</property>
+	      <property name="label" translatable="yes">Vi_deo</property>
+	      <property name="use_underline">True</property>
+
+	      <child>
+		<widget class="GtkMenu" id="video_1_menu">
+
+		  <child>
+		    <widget class="GtkMenuItem" id="decoder_options1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_Decoder Options</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="F3" modifiers="0" signal="activate"/>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="set_postprocessing1">
+		      <property name="visible">True</property>
+		      <property name="tooltip" translatable="yes">Select postprocessing level</property>
+		      <property name="label" translatable="yes">_Postprocessing</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="F4" modifiers="0" signal="activate"/>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkSeparatorMenuItem" id="separator9">
+		      <property name="visible">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkCheckMenuItem" id="preview1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">P_review</property>
+		      <property name="use_underline">True</property>
+		      <property name="active">False</property>
+		      <accelerator key="F5" modifiers="0" signal="activate"/>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkCheckMenuItem" id="display_output1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Display _Output</property>
+		      <property name="use_underline">True</property>
+		      <property name="active">False</property>
+		      <accelerator key="F6" modifiers="0" signal="activate"/>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkSeparatorMenuItem" id="separator10">
+		      <property name="visible">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="change_fps">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_Frame Rate</property>
+		      <property name="use_underline">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="videoencoder">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_Encoder</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="V" modifiers="GDK_CONTROL_MASK | GDK_MOD1_MASK" signal="activate"/>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="filters1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Fil_ters</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="F" modifiers="GDK_CONTROL_MASK | GDK_MOD1_MASK" signal="activate"/>
+		    </widget>
+		  </child>
+		</widget>
+	      </child>
+	    </widget>
+	  </child>
+
+	  <child>
+	    <widget class="GtkMenuItem" id="audio1">
+	      <property name="visible">True</property>
+	      <property name="label" translatable="yes">_Audio</property>
+	      <property name="use_underline">True</property>
+
+	      <child>
+		<widget class="GtkMenu" id="audio1_menu">
+
+		  <child>
+		    <widget class="GtkMenuItem" id="main_audio">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_Main Track</property>
+		      <property name="use_underline">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="second_audio_track1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_Second Track</property>
+		      <property name="use_underline">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="build_vbr_time_map1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_Build VBR Time Map</property>
+		      <property name="use_underline">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkSeparatorMenuItem" id="separator11">
+		      <property name="visible">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkImageMenuItem" id="save_audio1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">S_ave...</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="S" modifiers="GDK_CONTROL_MASK | GDK_MOD1_MASK" signal="activate"/>
+
+		      <child internal-child="image">
+			<widget class="GtkImage" id="image8010">
+			  <property name="visible">True</property>
+			  <property name="stock">gtk-save-as</property>
+			  <property name="icon_size">1</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="audio_encoder1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_Encoder</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="A" modifiers="GDK_CONTROL_MASK | GDK_MOD1_MASK" signal="activate"/>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="filters2">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_Filters</property>
+		      <property name="use_underline">True</property>
+		    </widget>
+		  </child>
+		</widget>
+	      </child>
+	    </widget>
+	  </child>
+
+	  <child>
+	    <widget class="GtkMenuItem" id="tools1">
+	      <property name="visible">True</property>
+	      <property name="label" translatable="yes">_Tools</property>
+	      <property name="use_underline">True</property>
+
+	      <child>
+		<widget class="GtkMenu" id="tools1_menu">
+
+		  <child>
+		    <widget class="GtkImageMenuItem" id="calculator1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_Calculator</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="F7" modifiers="0" signal="activate"/>
+
+		      <child internal-child="image">
+			<widget class="GtkImage" id="image8011">
+			  <property name="visible">True</property>
+			  <property name="pixbuf">gnome-calculator_small.xpm</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkSeparatorMenuItem" id="separator12">
+		      <property name="visible">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="rebuild_frames">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_Rebuild Frames (I &amp; B)</property>
+		      <property name="use_underline">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="check_frames">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">C_heck Frames (slow)</property>
+		      <property name="use_underline">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="bitrate_histogram1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_Bitrate Histogram</property>
+		      <property name="use_underline">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="item1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_Scan for Black Frames...</property>
+		      <property name="use_underline">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkSeparatorMenuItem" id="separator13">
+		      <property name="visible">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="v2v">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_VOB -&gt; VobSub</property>
+		      <property name="use_underline">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="ocr_vobsub_2_srt">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_OCR (VobSub -&gt; srt)</property>
+		      <property name="use_underline">True</property>
+		    </widget>
+		  </child>
+		</widget>
+	      </child>
+	    </widget>
+	  </child>
+
+	  <child>
+	    <widget class="GtkMenuItem" id="help1">
+	      <property name="visible">True</property>
+	      <property name="label" translatable="yes">A_uto</property>
+	      <property name="use_underline">True</property>
+
+	      <child>
+		<widget class="GtkMenu" id="help1_menu">
+
+		  <child>
+		    <widget class="GtkMenuItem" id="vcd1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_VCD</property>
+		      <property name="use_underline">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="svcd1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_SVCD</property>
+		      <property name="use_underline">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="dvd1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_DVD</property>
+		      <property name="use_underline">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="psp1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">PSP</property>
+		      <property name="use_underline">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="psp_(h264)1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">PSP (H264)</property>
+		      <property name="use_underline">True</property>
+		      <signal name="activate" handler="on_psp_h264_activate" last_modification_time="Mon, 01 Jan 2007 13:24:11 GMT"/>
+		    </widget>
+		  </child>
+		</widget>
+	      </child>
+	    </widget>
+	  </child>
+
+	  <child>
+	    <widget class="GtkMenuItem" id="go1">
+	      <property name="visible">True</property>
+	      <property name="label" translatable="yes">_Go</property>
+	      <property name="use_underline">True</property>
+
+	      <child>
+		<widget class="GtkMenu" id="go1_menu">
+
+		  <child>
+		    <widget class="GtkImageMenuItem" id="play_video1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_Play/Stop</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="P" modifiers="0" signal="activate"/>
+
+		      <child internal-child="image">
+			<widget class="GtkImage" id="image8012">
+			  <property name="visible">True</property>
+			  <property name="stock">gtk-media-play</property>
+			  <property name="icon_size">1</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkImageMenuItem" id="previous_frame1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">P_revious Frame</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="KP_4" modifiers="0" signal="activate"/>
+
+		      <child internal-child="image">
+			<widget class="GtkImage" id="image8013">
+			  <property name="visible">True</property>
+			  <property name="stock">gtk-media-previous</property>
+			  <property name="icon_size">1</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkImageMenuItem" id="next_frame1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_Next Frame</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="KP_6" modifiers="0" signal="activate"/>
+
+		      <child internal-child="image">
+			<widget class="GtkImage" id="image8014">
+			  <property name="visible">True</property>
+			  <property name="stock">gtk-media-next</property>
+			  <property name="icon_size">1</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkImageMenuItem" id="previous_intra_frame1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Pr_evious Intra Frame</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="KP_2" modifiers="0" signal="activate"/>
+
+		      <child internal-child="image">
+			<widget class="GtkImage" id="image8015">
+			  <property name="visible">True</property>
+			  <property name="stock">gtk-media-rewind</property>
+			  <property name="icon_size">1</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkImageMenuItem" id="next_intra_frame1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Next _Intra Frame</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="KP_8" modifiers="0" signal="activate"/>
+
+		      <child internal-child="image">
+			<widget class="GtkImage" id="image8016">
+			  <property name="visible">True</property>
+			  <property name="stock">gtk-media-forward</property>
+			  <property name="icon_size">1</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="search_previous_black_frame1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Previou_s Black Frame</property>
+		      <property name="use_underline">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="search_next_black_frame1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Ne_xt Black Frame</property>
+		      <property name="use_underline">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkImageMenuItem" id="first_frame1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_First Frame</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="Home" modifiers="0" signal="activate"/>
+
+		      <child internal-child="image">
+			<widget class="GtkImage" id="image8017">
+			  <property name="visible">True</property>
+			  <property name="stock">gtk-goto-first</property>
+			  <property name="icon_size">1</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkImageMenuItem" id="last_frame1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_Last Frame</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="End" modifiers="0" signal="activate"/>
+
+		      <child internal-child="image">
+			<widget class="GtkImage" id="image8018">
+			  <property name="visible">True</property>
+			  <property name="stock">gtk-goto-last</property>
+			  <property name="icon_size">1</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkSeparatorMenuItem" id="separator14">
+		      <property name="visible">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="go_to_marker_a1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Go to Marker _A</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="bracketleft" modifiers="GDK_CONTROL_MASK" signal="activate"/>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="go_to_marker_b1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Go to Marker _B</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="bracketright" modifiers="GDK_CONTROL_MASK" signal="activate"/>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkSeparatorMenuItem" id="separator15">
+		      <property name="visible">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkImageMenuItem" id="jum_to_frame1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_Jump to Frame...</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="F" modifiers="GDK_CONTROL_MASK" signal="activate"/>
+
+		      <child internal-child="image">
+			<widget class="GtkImage" id="image8019">
+			  <property name="visible">True</property>
+			  <property name="stock">gtk-jump-to</property>
+			  <property name="icon_size">1</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkImageMenuItem" id="jump_to_time1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Jump to _Time...</property>
+		      <property name="use_underline">True</property>
+		      <accelerator key="T" modifiers="GDK_CONTROL_MASK" signal="activate"/>
+
+		      <child internal-child="image">
+			<widget class="GtkImage" id="image8020">
+			  <property name="visible">True</property>
+			  <property name="stock">gtk-jump-to</property>
+			  <property name="icon_size">1</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+		</widget>
+	      </child>
+	    </widget>
+	  </child>
+
+	  <child>
+	    <widget class="GtkMenuItem" id="custom1">
+	      <property name="visible">True</property>
+	      <property name="label" translatable="yes">Custom</property>
+	      <property name="use_underline">True</property>
+	    </widget>
+	  </child>
+
+	  <child>
+	    <widget class="GtkMenuItem" id="help2">
+	      <property name="visible">True</property>
+	      <property name="label" translatable="yes">_Help</property>
+	      <property name="use_underline">True</property>
+
+	      <child>
+		<widget class="GtkMenu" id="help2_menu">
+
+		  <child>
+		    <widget class="GtkImageMenuItem" id="about1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_About</property>
+		      <property name="use_underline">True</property>
+
+		      <child internal-child="image">
+			<widget class="GtkImage" id="image8021">
+			  <property name="visible">True</property>
+			  <property name="stock">gtk-about</property>
+			  <property name="icon_size">1</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="show_builtin_support1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Show builtin support</property>
+		      <property name="use_underline">True</property>
+		    </widget>
+		  </child>
+		</widget>
+	      </child>
+	    </widget>
+	  </child>
+	</widget>
+	<packing>
+	  <property name="padding">0</property>
+	  <property name="expand">False</property>
+	  <property name="fill">False</property>
+	</packing>
+      </child>
+
+      <child>
+	<widget class="GtkToolbar" id="toolbar2">
+	  <property name="visible">True</property>
+	  <property name="orientation">GTK_ORIENTATION_HORIZONTAL</property>
+	  <property name="toolbar_style">GTK_TOOLBAR_BOTH_HORIZ</property>
+	  <property name="tooltips">True</property>
+	  <property name="show_arrow">True</property>
+
+	  <child>
+	    <widget class="GtkMenuToolButton" id="menutoolbuttonOpen">
+	      <property name="visible">True</property>
+	      <property name="tooltip" translatable="yes">Open a file</property>
+	      <property name="stock_id">gtk-open</property>
+	      <property name="visible_horizontal">True</property>
+	      <property name="visible_vertical">True</property>
+	      <property name="is_important">True</property>
+	    </widget>
+	    <packing>
+	      <property name="expand">False</property>
+	      <property name="homogeneous">False</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkToolItem" id="toolitem11">
+	      <property name="visible">True</property>
+	      <property name="visible_horizontal">True</property>
+	      <property name="visible_vertical">True</property>
+	      <property name="is_important">False</property>
+	    </widget>
+	    <packing>
+	      <property name="expand">False</property>
+	      <property name="homogeneous">False</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkToolButton" id="toolbuttonSave">
+	      <property name="visible">True</property>
+	      <property name="tooltip" translatable="yes">Save the file</property>
+	      <property name="stock_id">gtk-save</property>
+	      <property name="visible_horizontal">True</property>
+	      <property name="visible_vertical">True</property>
+	      <property name="is_important">True</property>
+	    </widget>
+	    <packing>
+	      <property name="expand">False</property>
+	      <property name="homogeneous">True</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkToolButton" id="toolbuttonInfo">
+	      <property name="visible">True</property>
+	      <property name="tooltip" translatable="yes">Audio/video file information</property>
+	      <property name="stock_id">gtk-properties</property>
+	      <property name="visible_horizontal">True</property>
+	      <property name="visible_vertical">True</property>
+	      <property name="is_important">False</property>
+	    </widget>
+	    <packing>
+	      <property name="expand">False</property>
+	      <property name="homogeneous">True</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkSeparatorToolItem" id="separatortoolitem1">
+	      <property name="visible">True</property>
+	      <property name="draw">True</property>
+	      <property name="visible_horizontal">True</property>
+	      <property name="visible_vertical">True</property>
+	    </widget>
+	    <packing>
+	      <property name="expand">False</property>
+	      <property name="homogeneous">False</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkToolButton" id="toolbuttonCalc">
+	      <property name="visible">True</property>
+	      <property name="tooltip" translatable="yes">Bitrate/size calculator</property>
+	      <property name="label" translatable="yes">Calculator</property>
+	      <property name="use_underline">True</property>
+	      <property name="icon">gnome-calculator.xpm</property>
+	      <property name="visible_horizontal">True</property>
+	      <property name="visible_vertical">True</property>
+	      <property name="is_important">True</property>
+	    </widget>
+	    <packing>
+	      <property name="expand">False</property>
+	      <property name="homogeneous">True</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkSeparatorToolItem" id="separatortoolitem2">
+	      <property name="visible">True</property>
+	      <property name="draw">True</property>
+	      <property name="visible_horizontal">True</property>
+	      <property name="visible_vertical">True</property>
+	    </widget>
+	    <packing>
+	      <property name="expand">False</property>
+	      <property name="homogeneous">False</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkToggleToolButton" id="toggletoolbuttonPreview">
+	      <property name="visible">True</property>
+	      <property name="tooltip" translatable="yes">Preview filtered video in a new window</property>
+	      <property name="label" translatable="yes">Preview</property>
+	      <property name="use_underline">True</property>
+	      <property name="icon">preview.png</property>
+	      <property name="visible_horizontal">True</property>
+	      <property name="visible_vertical">True</property>
+	      <property name="is_important">False</property>
+	      <property name="active">False</property>
+	    </widget>
+	    <packing>
+	      <property name="expand">False</property>
+	      <property name="homogeneous">True</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkToggleToolButton" id="toggletoolbuttonOutput">
+	      <property name="visible">True</property>
+	      <property name="tooltip" translatable="yes">Display filtered output in the main window</property>
+	      <property name="label" translatable="yes">Output</property>
+	      <property name="use_underline">True</property>
+	      <property name="icon">output.png</property>
+	      <property name="visible_horizontal">True</property>
+	      <property name="visible_vertical">True</property>
+	      <property name="is_important">False</property>
+	      <property name="active">False</property>
+	    </widget>
+	    <packing>
+	      <property name="expand">False</property>
+	      <property name="homogeneous">True</property>
+	    </packing>
+	  </child>
+	</widget>
+	<packing>
+	  <property name="padding">0</property>
+	  <property name="expand">False</property>
+	  <property name="fill">False</property>
+	</packing>
+      </child>
+
+      <child>
+	<widget class="GtkVBox" id="vbox10">
+	  <property name="visible">True</property>
+	  <property name="homogeneous">False</property>
+	  <property name="spacing">3</property>
+
+	  <child>
+	    <widget class="GtkHBox" id="hbox14">
+	      <property name="visible">True</property>
+	      <property name="homogeneous">False</property>
+	      <property name="spacing">0</property>
+
+	      <child>
+		<widget class="GtkAlignment" id="alignment19">
+		  <property name="visible">True</property>
+		  <property name="xalign">0.5</property>
+		  <property name="yalign">0.5</property>
+		  <property name="xscale">1</property>
+		  <property name="yscale">1</property>
+		  <property name="top_padding">3</property>
+		  <property name="bottom_padding">0</property>
+		  <property name="left_padding">3</property>
+		  <property name="right_padding">0</property>
+
+		  <child>
+		    <widget class="GtkVBox" id="vbox9">
+		      <property name="visible">True</property>
+		      <property name="homogeneous">False</property>
+		      <property name="spacing">9</property>
+
+		      <child>
+			<widget class="GtkVBox" id="vbox11">
+			  <property name="visible">True</property>
+			  <property name="homogeneous">False</property>
+			  <property name="spacing">0</property>
+
+			  <child>
+			    <widget class="GtkLabel" id="label18">
+			      <property name="visible">True</property>
+			      <property name="label" translatable="yes">&lt;b&gt;Video&lt;/b&gt;</property>
+			      <property name="use_underline">False</property>
+			      <property name="use_markup">True</property>
+			      <property name="justify">GTK_JUSTIFY_LEFT</property>
+			      <property name="wrap">False</property>
+			      <property name="selectable">False</property>
+			      <property name="xalign">0</property>
+			      <property name="yalign">0.5</property>
+			      <property name="xpad">0</property>
+			      <property name="ypad">0</property>
+			      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+			      <property name="width_chars">-1</property>
+			      <property name="single_line_mode">False</property>
+			      <property name="angle">0</property>
+			    </widget>
+			    <packing>
+			      <property name="padding">0</property>
+			      <property name="expand">False</property>
+			      <property name="fill">False</property>
+			    </packing>
+			  </child>
+
+			  <child>
+			    <widget class="GtkAlignment" id="alignment12">
+			      <property name="visible">True</property>
+			      <property name="xalign">0.5</property>
+			      <property name="yalign">0.5</property>
+			      <property name="xscale">1</property>
+			      <property name="yscale">1</property>
+			      <property name="top_padding">3</property>
+			      <property name="bottom_padding">0</property>
+			      <property name="left_padding">12</property>
+			      <property name="right_padding">0</property>
+
+			      <child>
+				<widget class="GtkVBox" id="vbox7">
+				  <property name="visible">True</property>
+				  <property name="homogeneous">False</property>
+				  <property name="spacing">3</property>
+
+				  <child>
+				    <widget class="GtkComboBox" id="comboboxVideo">
+				      <property name="visible">True</property>
+				      <property name="items" translatable="yes">Copy</property>
+				      <property name="add_tearoffs">False</property>
+				      <property name="focus_on_click">True</property>
+				    </widget>
+				    <packing>
+				      <property name="padding">0</property>
+				      <property name="expand">False</property>
+				      <property name="fill">False</property>
+				    </packing>
+				  </child>
+
+				  <child>
+				    <widget class="GtkButton" id="buttonConfV">
+				      <property name="visible">True</property>
+				      <property name="tooltip" translatable="yes">Configure video encoder</property>
+				      <property name="can_focus">True</property>
+				      <property name="label">Configure</property>
+				      <property name="use_underline">True</property>
+				      <property name="relief">GTK_RELIEF_NORMAL</property>
+				      <property name="focus_on_click">True</property>
+				      <accelerator key="F3" modifiers="0" signal="clicked"/>
+				    </widget>
+				    <packing>
+				      <property name="padding">0</property>
+				      <property name="expand">False</property>
+				      <property name="fill">False</property>
+				    </packing>
+				  </child>
+
+				  <child>
+				    <widget class="GtkButton" id="buttonFilters">
+				      <property name="visible">True</property>
+				      <property name="tooltip" translatable="yes">Video filters</property>
+				      <property name="can_focus">True</property>
+				      <property name="label" translatable="yes">Filters</property>
+				      <property name="use_underline">True</property>
+				      <property name="relief">GTK_RELIEF_NORMAL</property>
+				      <property name="focus_on_click">True</property>
+				      <accelerator key="F1" modifiers="0" signal="clicked"/>
+				    </widget>
+				    <packing>
+				      <property name="padding">0</property>
+				      <property name="expand">False</property>
+				      <property name="fill">False</property>
+				    </packing>
+				  </child>
+				</widget>
+			      </child>
+			    </widget>
+			    <packing>
+			      <property name="padding">0</property>
+			      <property name="expand">True</property>
+			      <property name="fill">True</property>
+			    </packing>
+			  </child>
+			</widget>
+			<packing>
+			  <property name="padding">0</property>
+			  <property name="expand">False</property>
+			  <property name="fill">False</property>
+			</packing>
+		      </child>
+
+		      <child>
+			<widget class="GtkVBox" id="vbox12">
+			  <property name="visible">True</property>
+			  <property name="homogeneous">False</property>
+			  <property name="spacing">0</property>
+
+			  <child>
+			    <widget class="GtkLabel" id="label19">
+			      <property name="visible">True</property>
+			      <property name="label" translatable="yes">&lt;b&gt;Audio&lt;/b&gt;</property>
+			      <property name="use_underline">False</property>
+			      <property name="use_markup">True</property>
+			      <property name="justify">GTK_JUSTIFY_LEFT</property>
+			      <property name="wrap">False</property>
+			      <property name="selectable">False</property>
+			      <property name="xalign">0</property>
+			      <property name="yalign">0.5</property>
+			      <property name="xpad">0</property>
+			      <property name="ypad">0</property>
+			      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+			      <property name="width_chars">-1</property>
+			      <property name="single_line_mode">False</property>
+			      <property name="angle">0</property>
+			    </widget>
+			    <packing>
+			      <property name="padding">0</property>
+			      <property name="expand">False</property>
+			      <property name="fill">False</property>
+			    </packing>
+			  </child>
+
+			  <child>
+			    <widget class="GtkAlignment" id="alignment13">
+			      <property name="visible">True</property>
+			      <property name="xalign">0.5</property>
+			      <property name="yalign">0.5</property>
+			      <property name="xscale">1</property>
+			      <property name="yscale">1</property>
+			      <property name="top_padding">3</property>
+			      <property name="bottom_padding">0</property>
+			      <property name="left_padding">12</property>
+			      <property name="right_padding">0</property>
+
+			      <child>
+				<widget class="GtkVBox" id="vbox8">
+				  <property name="visible">True</property>
+				  <property name="homogeneous">False</property>
+				  <property name="spacing">3</property>
+
+				  <child>
+				    <widget class="GtkComboBox" id="comboboxAudio">
+				      <property name="visible">True</property>
+				      <property name="items" translatable="yes">Copy</property>
+				      <property name="add_tearoffs">False</property>
+				      <property name="focus_on_click">True</property>
+				    </widget>
+				    <packing>
+				      <property name="padding">0</property>
+				      <property name="expand">False</property>
+				      <property name="fill">False</property>
+				    </packing>
+				  </child>
+
+				  <child>
+				    <widget class="GtkButton" id="buttonConfA">
+				      <property name="visible">True</property>
+				      <property name="tooltip" translatable="yes">Configure audio encoder</property>
+				      <property name="can_focus">True</property>
+				      <property name="label">Configure</property>
+				      <property name="use_underline">True</property>
+				      <property name="relief">GTK_RELIEF_NORMAL</property>
+				      <property name="focus_on_click">True</property>
+				      <accelerator key="F4" modifiers="0" signal="clicked"/>
+				    </widget>
+				    <packing>
+				      <property name="padding">0</property>
+				      <property name="expand">False</property>
+				      <property name="fill">False</property>
+				    </packing>
+				  </child>
+
+				  <child>
+				    <widget class="GtkButton" id="buttonAudioFilter">
+				      <property name="visible">True</property>
+				      <property name="tooltip" translatable="yes">Audio filters</property>
+				      <property name="can_focus">True</property>
+				      <property name="relief">GTK_RELIEF_NORMAL</property>
+				      <property name="focus_on_click">True</property>
+				      <accelerator key="F2" modifiers="0" signal="clicked"/>
+
+				      <child>
+					<widget class="GtkAlignment" id="alignment16">
+					  <property name="visible">True</property>
+					  <property name="xalign">0.5</property>
+					  <property name="yalign">0.5</property>
+					  <property name="xscale">0</property>
+					  <property name="yscale">0</property>
+					  <property name="top_padding">0</property>
+					  <property name="bottom_padding">0</property>
+					  <property name="left_padding">0</property>
+					  <property name="right_padding">0</property>
+
+					  <child>
+					    <widget class="GtkHBox" id="hbox18">
+					      <property name="visible">True</property>
+					      <property name="homogeneous">False</property>
+					      <property name="spacing">2</property>
+
+					      <child>
+						<widget class="GtkLabel" id="label22">
+						  <property name="visible">True</property>
+						  <property name="label" translatable="yes">Filters</property>
+						  <property name="use_underline">True</property>
+						  <property name="use_markup">False</property>
+						  <property name="justify">GTK_JUSTIFY_LEFT</property>
+						  <property name="wrap">False</property>
+						  <property name="selectable">False</property>
+						  <property name="xalign">0.5</property>
+						  <property name="yalign">0.5</property>
+						  <property name="xpad">0</property>
+						  <property name="ypad">0</property>
+						  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+						  <property name="width_chars">-1</property>
+						  <property name="single_line_mode">False</property>
+						  <property name="angle">0</property>
+						</widget>
+						<packing>
+						  <property name="padding">0</property>
+						  <property name="expand">False</property>
+						  <property name="fill">False</property>
+						</packing>
+					      </child>
+					    </widget>
+					  </child>
+					</widget>
+				      </child>
+				    </widget>
+				    <packing>
+				      <property name="padding">0</property>
+				      <property name="expand">False</property>
+				      <property name="fill">False</property>
+				    </packing>
+				  </child>
+
+				  <child>
+				    <widget class="GtkHBox" id="hbox19">
+				      <property name="visible">True</property>
+				      <property name="homogeneous">False</property>
+				      <property name="spacing">6</property>
+
+				      <child>
+					<widget class="GtkCheckButton" id="CheckButtonTimeshift">
+					  <property name="visible">True</property>
+					  <property name="tooltip" translatable="yes">Enable time shift</property>
+					  <property name="can_focus">True</property>
+					  <property name="label" translatable="yes">Shift:</property>
+					  <property name="use_underline">True</property>
+					  <property name="relief">GTK_RELIEF_NORMAL</property>
+					  <property name="focus_on_click">True</property>
+					  <property name="active">False</property>
+					  <property name="inconsistent">False</property>
+					  <property name="draw_indicator">True</property>
+					</widget>
+					<packing>
+					  <property name="padding">0</property>
+					  <property name="expand">False</property>
+					  <property name="fill">False</property>
+					</packing>
+				      </child>
+
+				      <child>
+					<widget class="GtkSpinButton" id="spinbuttonTimeShift">
+					  <property name="visible">True</property>
+					  <property name="tooltip" translatable="yes">Audio/video time shift (ms)</property>
+					  <property name="can_focus">True</property>
+					  <property name="climb_rate">1</property>
+					  <property name="digits">0</property>
+					  <property name="numeric">True</property>
+					  <property name="update_policy">GTK_UPDATE_ALWAYS</property>
+					  <property name="snap_to_ticks">False</property>
+					  <property name="wrap">False</property>
+					  <property name="adjustment">0 -9999 9999 1 10 10</property>
+					</widget>
+					<packing>
+					  <property name="padding">0</property>
+					  <property name="expand">True</property>
+					  <property name="fill">True</property>
+					</packing>
+				      </child>
+				    </widget>
+				    <packing>
+				      <property name="padding">0</property>
+				      <property name="expand">True</property>
+				      <property name="fill">True</property>
+				    </packing>
+				  </child>
+				</widget>
+			      </child>
+			    </widget>
+			    <packing>
+			      <property name="padding">0</property>
+			      <property name="expand">True</property>
+			      <property name="fill">True</property>
+			    </packing>
+			  </child>
+			</widget>
+			<packing>
+			  <property name="padding">0</property>
+			  <property name="expand">False</property>
+			  <property name="fill">False</property>
+			</packing>
+		      </child>
+
+		      <child>
+			<widget class="GtkVBox" id="vbox13">
+			  <property name="visible">True</property>
+			  <property name="homogeneous">False</property>
+			  <property name="spacing">0</property>
+
+			  <child>
+			    <widget class="GtkLabel" id="label20">
+			      <property name="visible">True</property>
+			      <property name="label" translatable="yes">&lt;b&gt;Format&lt;/b&gt;</property>
+			      <property name="use_underline">False</property>
+			      <property name="use_markup">True</property>
+			      <property name="justify">GTK_JUSTIFY_LEFT</property>
+			      <property name="wrap">False</property>
+			      <property name="selectable">False</property>
+			      <property name="xalign">0</property>
+			      <property name="yalign">0.5</property>
+			      <property name="xpad">0</property>
+			      <property name="ypad">0</property>
+			      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+			      <property name="width_chars">-1</property>
+			      <property name="single_line_mode">False</property>
+			      <property name="angle">0</property>
+			    </widget>
+			    <packing>
+			      <property name="padding">0</property>
+			      <property name="expand">False</property>
+			      <property name="fill">False</property>
+			    </packing>
+			  </child>
+
+			  <child>
+			    <widget class="GtkAlignment" id="alignment14">
+			      <property name="visible">True</property>
+			      <property name="xalign">0.5</property>
+			      <property name="yalign">0.5</property>
+			      <property name="xscale">1</property>
+			      <property name="yscale">1</property>
+			      <property name="top_padding">3</property>
+			      <property name="bottom_padding">0</property>
+			      <property name="left_padding">12</property>
+			      <property name="right_padding">0</property>
+
+			      <child>
+				<widget class="GtkComboBox" id="comboboxFormat">
+				  <property name="visible">True</property>
+				  <property name="items" translatable="yes">AVI
+AVI, unp. VOP
+AVI, dual audio
+OGM
+MPEG video
+MPEG PS A+V
+MPEG TS A+V
+MP4
+PSP</property>
+				  <property name="add_tearoffs">False</property>
+				  <property name="focus_on_click">True</property>
+				</widget>
+			      </child>
+			    </widget>
+			    <packing>
+			      <property name="padding">0</property>
+			      <property name="expand">True</property>
+			      <property name="fill">True</property>
+			    </packing>
+			  </child>
+			</widget>
+			<packing>
+			  <property name="padding">0</property>
+			  <property name="expand">False</property>
+			  <property name="fill">False</property>
+			</packing>
+		      </child>
+		    </widget>
+		  </child>
+		</widget>
+		<packing>
+		  <property name="padding">0</property>
+		  <property name="expand">False</property>
+		  <property name="fill">False</property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkDrawingArea" id="guiDrawing">
+		  <property name="width_request">496</property>
+		  <property name="height_request">288</property>
+		  <property name="visible">True</property>
+		  <property name="sensitive">False</property>
+		</widget>
+		<packing>
+		  <property name="padding">0</property>
+		  <property name="expand">True</property>
+		  <property name="fill">True</property>
+		</packing>
+	      </child>
+	    </widget>
+	    <packing>
+	      <property name="padding">0</property>
+	      <property name="expand">True</property>
+	      <property name="fill">True</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkTable" id="table2">
+	      <property name="border_width">3</property>
+	      <property name="visible">True</property>
+	      <property name="n_rows">3</property>
+	      <property name="n_columns">2</property>
+	      <property name="homogeneous">False</property>
+	      <property name="row_spacing">0</property>
+	      <property name="column_spacing">6</property>
+
+	      <child>
+		<widget class="GtkVBox" id="vbox14">
+		  <property name="visible">True</property>
+		  <property name="homogeneous">False</property>
+		  <property name="spacing">0</property>
+
+		  <child>
+		    <widget class="GtkLabel" id="label21">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">&lt;b&gt;Selection&lt;/b&gt;</property>
+		      <property name="use_underline">False</property>
+		      <property name="use_markup">True</property>
+		      <property name="justify">GTK_JUSTIFY_LEFT</property>
+		      <property name="wrap">False</property>
+		      <property name="selectable">False</property>
+		      <property name="xalign">0</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xpad">0</property>
+		      <property name="ypad">0</property>
+		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		      <property name="width_chars">-1</property>
+		      <property name="single_line_mode">False</property>
+		      <property name="angle">0</property>
+		    </widget>
+		    <packing>
+		      <property name="padding">0</property>
+		      <property name="expand">False</property>
+		      <property name="fill">False</property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkAlignment" id="alignment15">
+		      <property name="visible">True</property>
+		      <property name="xalign">0.5</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xscale">1</property>
+		      <property name="yscale">1</property>
+		      <property name="top_padding">3</property>
+		      <property name="bottom_padding">0</property>
+		      <property name="left_padding">12</property>
+		      <property name="right_padding">0</property>
+
+		      <child>
+			<widget class="GtkTable" id="table1">
+			  <property name="visible">True</property>
+			  <property name="n_rows">2</property>
+			  <property name="n_columns">2</property>
+			  <property name="homogeneous">False</property>
+			  <property name="row_spacing">3</property>
+			  <property name="column_spacing">3</property>
+
+			  <child>
+			    <widget class="GtkLabel" id="labelMarkA">
+			      <property name="visible">True</property>
+			      <property name="can_focus">True</property>
+			      <property name="label" translatable="yes"> 0000000</property>
+			      <property name="use_underline">False</property>
+			      <property name="use_markup">False</property>
+			      <property name="justify">GTK_JUSTIFY_LEFT</property>
+			      <property name="wrap">False</property>
+			      <property name="selectable">True</property>
+			      <property name="xalign">0.5</property>
+			      <property name="yalign">0.5</property>
+			      <property name="xpad">0</property>
+			      <property name="ypad">0</property>
+			      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+			      <property name="width_chars">-1</property>
+			      <property name="single_line_mode">False</property>
+			      <property name="angle">0</property>
+			    </widget>
+			    <packing>
+			      <property name="left_attach">1</property>
+			      <property name="right_attach">2</property>
+			      <property name="top_attach">0</property>
+			      <property name="bottom_attach">1</property>
+			      <property name="x_options">fill</property>
+			      <property name="y_options"></property>
+			    </packing>
+			  </child>
+
+			  <child>
+			    <widget class="GtkLabel" id="labelMarkB">
+			      <property name="visible">True</property>
+			      <property name="can_focus">True</property>
+			      <property name="label" translatable="yes"> 0000000</property>
+			      <property name="use_underline">False</property>
+			      <property name="use_markup">False</property>
+			      <property name="justify">GTK_JUSTIFY_LEFT</property>
+			      <property name="wrap">False</property>
+			      <property name="selectable">True</property>
+			      <property name="xalign">0.5</property>
+			      <property name="yalign">0.5</property>
+			      <property name="xpad">0</property>
+			      <property name="ypad">0</property>
+			      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+			      <property name="width_chars">-1</property>
+			      <property name="single_line_mode">False</property>
+			      <property name="angle">0</property>
+			    </widget>
+			    <packing>
+			      <property name="left_attach">1</property>
+			      <property name="right_attach">2</property>
+			      <property name="top_attach">1</property>
+			      <property name="bottom_attach">2</property>
+			      <property name="x_options">fill</property>
+			      <property name="y_options"></property>
+			    </packing>
+			  </child>
+
+			  <child>
+			    <widget class="GtkButton" id="buttonGotoA">
+			      <property name="height_request">20</property>
+			      <property name="visible">True</property>
+			      <property name="tooltip" translatable="yes">Go to marker A</property>
+			      <property name="label" translatable="yes">A:</property>
+			      <property name="use_underline">True</property>
+			      <property name="relief">GTK_RELIEF_NORMAL</property>
+			      <property name="focus_on_click">True</property>
+			    </widget>
+			    <packing>
+			      <property name="left_attach">0</property>
+			      <property name="right_attach">1</property>
+			      <property name="top_attach">0</property>
+			      <property name="bottom_attach">1</property>
+			      <property name="x_options">fill</property>
+			      <property name="y_options">fill</property>
+			    </packing>
+			  </child>
+
+			  <child>
+			    <widget class="GtkButton" id="buttonGotoB">
+			      <property name="height_request">20</property>
+			      <property name="visible">True</property>
+			      <property name="tooltip" translatable="yes">Go to marker B</property>
+			      <property name="label" translatable="yes">B:</property>
+			      <property name="use_underline">True</property>
+			      <property name="relief">GTK_RELIEF_NORMAL</property>
+			      <property name="focus_on_click">True</property>
+			    </widget>
+			    <packing>
+			      <property name="left_attach">0</property>
+			      <property name="right_attach">1</property>
+			      <property name="top_attach">1</property>
+			      <property name="bottom_attach">2</property>
+			      <property name="x_options">fill</property>
+			      <property name="y_options">fill</property>
+			    </packing>
+			  </child>
+			</widget>
+		      </child>
+		    </widget>
+		    <packing>
+		      <property name="padding">0</property>
+		      <property name="expand">True</property>
+		      <property name="fill">True</property>
+		    </packing>
+		  </child>
+		</widget>
+		<packing>
+		  <property name="left_attach">1</property>
+		  <property name="right_attach">2</property>
+		  <property name="top_attach">1</property>
+		  <property name="bottom_attach">3</property>
+		  <property name="x_options">fill</property>
+		  <property name="y_options">fill</property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkHBox" id="hbox10">
+		  <property name="visible">True</property>
+		  <property name="homogeneous">False</property>
+		  <property name="spacing">0</property>
+
+		  <child>
+		    <widget class="GtkButton" id="buttonPlay">
+		      <property name="visible">True</property>
+		      <property name="tooltip" translatable="yes">Play</property>
+		      <property name="relief">GTK_RELIEF_NONE</property>
+		      <property name="focus_on_click">False</property>
+		      <accelerator key="space" modifiers="0" signal="clicked"/>
+
+		      <child>
+			<widget class="GtkImage" id="image591">
+			  <property name="visible">True</property>
+			  <property name="pixbuf">play.xpm</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		    <packing>
+		      <property name="padding">0</property>
+		      <property name="expand">False</property>
+		      <property name="fill">False</property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkButton" id="buttonStop">
+		      <property name="visible">True</property>
+		      <property name="tooltip" translatable="yes">Stop</property>
+		      <property name="can_focus">True</property>
+		      <property name="relief">GTK_RELIEF_NONE</property>
+		      <property name="focus_on_click">False</property>
+
+		      <child>
+			<widget class="GtkImage" id="image5056">
+			  <property name="visible">True</property>
+			  <property name="pixbuf">stop.xpm</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		    <packing>
+		      <property name="padding">0</property>
+		      <property name="expand">False</property>
+		      <property name="fill">False</property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkButton" id="buttonPrevFrame">
+		      <property name="visible">True</property>
+		      <property name="tooltip" translatable="yes">Previous frame</property>
+		      <property name="relief">GTK_RELIEF_NONE</property>
+		      <property name="focus_on_click">False</property>
+		      <accelerator key="KP_4" modifiers="0" signal="clicked"/>
+
+		      <child>
+			<widget class="GtkImage" id="image593">
+			  <property name="visible">True</property>
+			  <property name="pixbuf">backward.xpm</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		    <packing>
+		      <property name="padding">0</property>
+		      <property name="expand">False</property>
+		      <property name="fill">False</property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkButton" id="buttonNextFrame">
+		      <property name="visible">True</property>
+		      <property name="tooltip" translatable="yes">Next frame</property>
+		      <property name="relief">GTK_RELIEF_NONE</property>
+		      <property name="focus_on_click">False</property>
+		      <accelerator key="KP_6" modifiers="0" signal="clicked"/>
+
+		      <child>
+			<widget class="GtkImage" id="image594">
+			  <property name="visible">True</property>
+			  <property name="pixbuf">forward.xpm</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		    <packing>
+		      <property name="padding">0</property>
+		      <property name="expand">False</property>
+		      <property name="fill">False</property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkButton" id="buttonPrevKFrame">
+		      <property name="visible">True</property>
+		      <property name="tooltip" translatable="yes">Previous keyframe</property>
+		      <property name="relief">GTK_RELIEF_NONE</property>
+		      <property name="focus_on_click">False</property>
+		      <accelerator key="KP_2" modifiers="0" signal="clicked"/>
+
+		      <child>
+			<widget class="GtkImage" id="image595">
+			  <property name="visible">True</property>
+			  <property name="pixbuf">Kbackward.xpm</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		    <packing>
+		      <property name="padding">0</property>
+		      <property name="expand">False</property>
+		      <property name="fill">False</property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkButton" id="buttonNextKFrame">
+		      <property name="visible">True</property>
+		      <property name="tooltip" translatable="yes">Next keyframe</property>
+		      <property name="relief">GTK_RELIEF_NONE</property>
+		      <property name="focus_on_click">False</property>
+		      <accelerator key="KP_8" modifiers="0" signal="clicked"/>
+
+		      <child>
+			<widget class="GtkImage" id="image596">
+			  <property name="visible">True</property>
+			  <property name="pixbuf">Kforward.xpm</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		    <packing>
+		      <property name="padding">0</property>
+		      <property name="expand">False</property>
+		      <property name="fill">False</property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkButton" id="buttonMarkA">
+		      <property name="visible">True</property>
+		      <property name="tooltip" translatable="yes">Selection: start</property>
+		      <property name="can_focus">True</property>
+		      <property name="relief">GTK_RELIEF_NONE</property>
+		      <property name="focus_on_click">False</property>
+
+		      <child>
+			<widget class="GtkImage" id="image2306">
+			  <property name="visible">True</property>
+			  <property name="pixbuf">markA.xpm</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		    <packing>
+		      <property name="padding">0</property>
+		      <property name="expand">False</property>
+		      <property name="fill">False</property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkButton" id="buttonMarkB">
+		      <property name="visible">True</property>
+		      <property name="tooltip" translatable="yes">Selection: end</property>
+		      <property name="can_focus">True</property>
+		      <property name="relief">GTK_RELIEF_NONE</property>
+		      <property name="focus_on_click">False</property>
+
+		      <child>
+			<widget class="GtkImage" id="image2307">
+			  <property name="visible">True</property>
+			  <property name="pixbuf">markB.xpm</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		    <packing>
+		      <property name="padding">0</property>
+		      <property name="expand">False</property>
+		      <property name="fill">False</property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkButton" id="buttonPrevBlack">
+		      <property name="visible">True</property>
+		      <property name="tooltip" translatable="yes">Previous black frame</property>
+		      <property name="can_focus">True</property>
+		      <property name="relief">GTK_RELIEF_NONE</property>
+		      <property name="focus_on_click">False</property>
+
+		      <child>
+			<widget class="GtkImage" id="image2308">
+			  <property name="visible">True</property>
+			  <property name="pixbuf">xpm_prevblack.xpm</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		    <packing>
+		      <property name="padding">0</property>
+		      <property name="expand">False</property>
+		      <property name="fill">False</property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkButton" id="buttonNextBlack">
+		      <property name="visible">True</property>
+		      <property name="tooltip" translatable="yes">Next black frame</property>
+		      <property name="can_focus">True</property>
+		      <property name="relief">GTK_RELIEF_NONE</property>
+		      <property name="focus_on_click">False</property>
+
+		      <child>
+			<widget class="GtkImage" id="image2309">
+			  <property name="visible">True</property>
+			  <property name="pixbuf">xpm_nextblack.xpm</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		    <packing>
+		      <property name="padding">0</property>
+		      <property name="expand">False</property>
+		      <property name="fill">False</property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkButton" id="buttonBegin">
+		      <property name="visible">True</property>
+		      <property name="tooltip" translatable="yes">First frame</property>
+		      <property name="can_focus">True</property>
+		      <property name="relief">GTK_RELIEF_NONE</property>
+		      <property name="focus_on_click">False</property>
+
+		      <child>
+			<widget class="GtkImage" id="image5057">
+			  <property name="visible">True</property>
+			  <property name="pixbuf">begin.xpm</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		    <packing>
+		      <property name="padding">0</property>
+		      <property name="expand">False</property>
+		      <property name="fill">False</property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkButton" id="buttonEnd">
+		      <property name="visible">True</property>
+		      <property name="tooltip" translatable="yes">Last frame</property>
+		      <property name="can_focus">True</property>
+		      <property name="relief">GTK_RELIEF_NONE</property>
+		      <property name="focus_on_click">False</property>
+
+		      <child>
+			<widget class="GtkImage" id="image2245">
+			  <property name="visible">True</property>
+			  <property name="pixbuf">end.xpm</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		    <packing>
+		      <property name="padding">0</property>
+		      <property name="expand">False</property>
+		      <property name="fill">False</property>
+		    </packing>
+		  </child>
+		</widget>
+		<packing>
+		  <property name="left_attach">0</property>
+		  <property name="right_attach">1</property>
+		  <property name="top_attach">1</property>
+		  <property name="bottom_attach">2</property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkHScale" id="sliderNavigate">
+		  <property name="visible">True</property>
+		  <property name="draw_value">True</property>
+		  <property name="value_pos">GTK_POS_LEFT</property>
+		  <property name="digits">1</property>
+		  <property name="update_policy">GTK_UPDATE_CONTINUOUS</property>
+		  <property name="inverted">False</property>
+		  <property name="adjustment">0 0 99.9899978638 0.00999999977648 1 0</property>
+		</widget>
+		<packing>
+		  <property name="left_attach">0</property>
+		  <property name="right_attach">1</property>
+		  <property name="top_attach">0</property>
+		  <property name="bottom_attach">1</property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkHScale" id="hscaleSensitive">
+		  <property name="visible">True</property>
+		  <property name="can_focus">True</property>
+		  <property name="draw_value">False</property>
+		  <property name="value_pos">GTK_POS_RIGHT</property>
+		  <property name="digits">0</property>
+		  <property name="update_policy">GTK_UPDATE_CONTINUOUS</property>
+		  <property name="inverted">False</property>
+		  <property name="adjustment">62.2950819672 0 100 5 5 5</property>
+		</widget>
+		<packing>
+		  <property name="left_attach">1</property>
+		  <property name="right_attach">2</property>
+		  <property name="top_attach">0</property>
+		  <property name="bottom_attach">1</property>
+		  <property name="x_options">fill</property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkHBox" id="hbox16">
+		  <property name="visible">True</property>
+		  <property name="homogeneous">False</property>
+		  <property name="spacing">6</property>
+
+		  <child>
+		    <widget class="GtkLabel" id="label1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Frame: </property>
+		      <property name="use_underline">False</property>
+		      <property name="use_markup">False</property>
+		      <property name="justify">GTK_JUSTIFY_LEFT</property>
+		      <property name="wrap">False</property>
+		      <property name="selectable">False</property>
+		      <property name="xalign">0.5</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xpad">0</property>
+		      <property name="ypad">0</property>
+		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		      <property name="width_chars">-1</property>
+		      <property name="single_line_mode">False</property>
+		      <property name="angle">0</property>
+		    </widget>
+		    <packing>
+		      <property name="padding">0</property>
+		      <property name="expand">False</property>
+		      <property name="fill">False</property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkEntry" id="boxCurFrame">
+		      <property name="visible">True</property>
+		      <property name="tooltip" translatable="yes">Current frame</property>
+		      <property name="can_focus">True</property>
+		      <property name="editable">True</property>
+		      <property name="visibility">True</property>
+		      <property name="max_length">8</property>
+		      <property name="text" translatable="yes">0</property>
+		      <property name="has_frame">True</property>
+		      <property name="invisible_char">*</property>
+		      <property name="activates_default">False</property>
+		      <property name="width_chars">8</property>
+		    </widget>
+		    <packing>
+		      <property name="padding">0</property>
+		      <property name="expand">False</property>
+		      <property name="fill">False</property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkLabel" id="labelTotalFrame">
+		      <property name="visible">True</property>
+		      <property name="can_focus">True</property>
+		      <property name="label" translatable="yes">/0000000</property>
+		      <property name="use_underline">False</property>
+		      <property name="use_markup">False</property>
+		      <property name="justify">GTK_JUSTIFY_LEFT</property>
+		      <property name="wrap">False</property>
+		      <property name="selectable">True</property>
+		      <property name="xalign">0.5</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xpad">5</property>
+		      <property name="ypad">0</property>
+		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		      <property name="width_chars">-1</property>
+		      <property name="single_line_mode">False</property>
+		      <property name="angle">0</property>
+		    </widget>
+		    <packing>
+		      <property name="padding">0</property>
+		      <property name="expand">False</property>
+		      <property name="fill">False</property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkLabel" id="label4">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Time: </property>
+		      <property name="use_underline">False</property>
+		      <property name="use_markup">False</property>
+		      <property name="justify">GTK_JUSTIFY_LEFT</property>
+		      <property name="wrap">False</property>
+		      <property name="selectable">False</property>
+		      <property name="xalign">0.5</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xpad">0</property>
+		      <property name="ypad">0</property>
+		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		      <property name="width_chars">-1</property>
+		      <property name="single_line_mode">False</property>
+		      <property name="angle">0</property>
+		    </widget>
+		    <packing>
+		      <property name="padding">0</property>
+		      <property name="expand">False</property>
+		      <property name="fill">False</property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkEntry" id="boxCurTime">
+		      <property name="visible">True</property>
+		      <property name="tooltip" translatable="yes">Current time</property>
+		      <property name="can_focus">True</property>
+		      <property name="editable">True</property>
+		      <property name="visibility">True</property>
+		      <property name="max_length">0</property>
+		      <property name="text" translatable="yes">00:00:00.000</property>
+		      <property name="has_frame">True</property>
+		      <property name="invisible_char">*</property>
+		      <property name="activates_default">False</property>
+		      <property name="width_chars">13</property>
+		    </widget>
+		    <packing>
+		      <property name="padding">0</property>
+		      <property name="expand">False</property>
+		      <property name="fill">False</property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkLabel" id="labelTotalTime">
+		      <property name="visible">True</property>
+		      <property name="can_focus">True</property>
+		      <property name="label" translatable="yes">/00:00:00,000</property>
+		      <property name="use_underline">False</property>
+		      <property name="use_markup">False</property>
+		      <property name="justify">GTK_JUSTIFY_LEFT</property>
+		      <property name="wrap">False</property>
+		      <property name="selectable">True</property>
+		      <property name="xalign">0.5</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xpad">5</property>
+		      <property name="ypad">0</property>
+		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		      <property name="width_chars">-1</property>
+		      <property name="single_line_mode">False</property>
+		      <property name="angle">0</property>
+		    </widget>
+		    <packing>
+		      <property name="padding">0</property>
+		      <property name="expand">False</property>
+		      <property name="fill">False</property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkLabel" id="labelFrameType">
+		      <property name="visible">True</property>
+		      <property name="can_focus">True</property>
+		      <property name="label" translatable="yes">Frame: ?</property>
+		      <property name="use_underline">False</property>
+		      <property name="use_markup">False</property>
+		      <property name="justify">GTK_JUSTIFY_LEFT</property>
+		      <property name="wrap">False</property>
+		      <property name="selectable">True</property>
+		      <property name="xalign">0.5</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xpad">0</property>
+		      <property name="ypad">0</property>
+		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		      <property name="width_chars">-1</property>
+		      <property name="single_line_mode">False</property>
+		      <property name="angle">0</property>
+		    </widget>
+		    <packing>
+		      <property name="padding">0</property>
+		      <property name="expand">False</property>
+		      <property name="fill">False</property>
+		    </packing>
+		  </child>
+		</widget>
+		<packing>
+		  <property name="left_attach">0</property>
+		  <property name="right_attach">1</property>
+		  <property name="top_attach">2</property>
+		  <property name="bottom_attach">3</property>
+		  <property name="y_options"></property>
+		</packing>
+	      </child>
+	    </widget>
+	    <packing>
+	      <property name="padding">0</property>
+	      <property name="expand">False</property>
+	      <property name="fill">False</property>
+	    </packing>
+	  </child>
+	</widget>
+	<packing>
+	  <property name="padding">0</property>
+	  <property name="expand">True</property>
+	  <property name="fill">True</property>
+	</packing>
+      </child>
+    </widget>
+  </child>
+</widget>
+
+</glade-interface>

Added: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/glade/prefs.glade
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/glade/prefs.glade	2007-01-15 19:09:58 UTC (rev 2738)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/glade/prefs.glade	2007-01-16 19:22:29 UTC (rev 2739)
@@ -0,0 +1,1111 @@
+<?xml version="1.0" standalone="no"?> <!--*- mode: xml -*-->
+<!DOCTYPE glade-interface SYSTEM "http://glade.gnome.org/glade-2.0.dtd">
+
+<glade-interface>
+
+<widget class="GtkDialog" id="Preferences">
+  <property name="border_width">6</property>
+  <property name="visible">True</property>
+  <property name="title" translatable="yes">Preferences</property>
+  <property name="type">GTK_WINDOW_TOPLEVEL</property>
+  <property name="window_position">GTK_WIN_POS_NONE</property>
+  <property name="modal">False</property>
+  <property name="resizable">False</property>
+  <property name="destroy_with_parent">False</property>
+  <property name="decorated">True</property>
+  <property name="skip_taskbar_hint">False</property>
+  <property name="skip_pager_hint">False</property>
+  <property name="type_hint">GDK_WINDOW_TYPE_HINT_DIALOG</property>
+  <property name="gravity">GDK_GRAVITY_NORTH_WEST</property>
+  <property name="focus_on_map">True</property>
+  <property name="urgency_hint">False</property>
+  <property name="has_separator">False</property>
+
+  <child internal-child="vbox">
+    <widget class="GtkVBox" id="dialog-vbox1">
+      <property name="visible">True</property>
+      <property name="homogeneous">False</property>
+      <property name="spacing">0</property>
+
+      <child internal-child="action_area">
+	<widget class="GtkHButtonBox" id="dialog-action_area1">
+	  <property name="visible">True</property>
+	  <property name="layout_style">GTK_BUTTONBOX_END</property>
+
+	  <child>
+	    <widget class="GtkButton" id="okbutton1">
+	      <property name="visible">True</property>
+	      <property name="can_default">True</property>
+	      <property name="can_focus">True</property>
+	      <property name="label">gtk-close</property>
+	      <property name="use_stock">True</property>
+	      <property name="relief">GTK_RELIEF_NORMAL</property>
+	      <property name="focus_on_click">True</property>
+	      <property name="response_id">-7</property>
+	    </widget>
+	  </child>
+	</widget>
+	<packing>
+	  <property name="padding">0</property>
+	  <property name="expand">False</property>
+	  <property name="fill">True</property>
+	  <property name="pack_type">GTK_PACK_END</property>
+	</packing>
+      </child>
+
+      <child>
+	<widget class="GtkNotebook" id="notebook1">
+	  <property name="border_width">6</property>
+	  <property name="visible">True</property>
+	  <property name="can_focus">True</property>
+	  <property name="show_tabs">True</property>
+	  <property name="show_border">True</property>
+	  <property name="tab_pos">GTK_POS_TOP</property>
+	  <property name="scrollable">False</property>
+	  <property name="enable_popup">False</property>
+
+	  <child>
+	    <widget class="GtkVBox" id="vbox12">
+	      <property name="border_width">12</property>
+	      <property name="visible">True</property>
+	      <property name="homogeneous">False</property>
+	      <property name="spacing">6</property>
+
+	      <child>
+		<widget class="GtkHBox" id="hbox3">
+		  <property name="visible">True</property>
+		  <property name="homogeneous">False</property>
+		  <property name="spacing">12</property>
+
+		  <child>
+		    <widget class="GtkLabel" id="label11">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_Message level:</property>
+		      <property name="use_underline">True</property>
+		      <property name="use_markup">False</property>
+		      <property name="justify">GTK_JUSTIFY_LEFT</property>
+		      <property name="wrap">False</property>
+		      <property name="selectable">False</property>
+		      <property name="xalign">0.5</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xpad">0</property>
+		      <property name="ypad">0</property>
+		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		      <property name="width_chars">-1</property>
+		      <property name="single_line_mode">False</property>
+		      <property name="angle">0</property>
+		    </widget>
+		    <packing>
+		      <property name="padding">0</property>
+		      <property name="expand">False</property>
+		      <property name="fill">False</property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkComboBox" id="comboboxMessageLevel">
+		      <property name="visible">True</property>
+		      <property name="items" translatable="yes">No alerts
+Display only error alerts
+Display all alerts</property>
+		      <property name="add_tearoffs">False</property>
+		      <property name="focus_on_click">True</property>
+		    </widget>
+		    <packing>
+		      <property name="padding">0</property>
+		      <property name="expand">True</property>
+		      <property name="fill">True</property>
+		    </packing>
+		  </child>
+		</widget>
+		<packing>
+		  <property name="padding">0</property>
+		  <property name="expand">True</property>
+		  <property name="fill">True</property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkCheckButton" id="checkbuttonSwapAB">
+		  <property name="visible">True</property>
+		  <property name="can_focus">True</property>
+		  <property name="label" translatable="yes">_Swap marks A and B if A &gt; B</property>
+		  <property name="use_underline">True</property>
+		  <property name="relief">GTK_RELIEF_NORMAL</property>
+		  <property name="focus_on_click">True</property>
+		  <property name="active">False</property>
+		  <property name="inconsistent">False</property>
+		  <property name="draw_indicator">True</property>
+		</widget>
+		<packing>
+		  <property name="padding">0</property>
+		  <property name="expand">False</property>
+		  <property name="fill">False</property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkCheckButton" id="checkbuttonSystray">
+		  <property name="visible">True</property>
+		  <property name="can_focus">True</property>
+		  <property name="label" translatable="yes">_Go to systray when encoding</property>
+		  <property name="use_underline">True</property>
+		  <property name="relief">GTK_RELIEF_NORMAL</property>
+		  <property name="focus_on_click">True</property>
+		  <property name="active">False</property>
+		  <property name="inconsistent">False</property>
+		  <property name="draw_indicator">True</property>
+		</widget>
+		<packing>
+		  <property name="padding">0</property>
+		  <property name="expand">False</property>
+		  <property name="fill">False</property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkCheckButton" id="checkbuttonSavePrefs">
+		  <property name="visible">True</property>
+		  <property name="can_focus">True</property>
+		  <property name="label" translatable="yes">S_ave preferences on exit</property>
+		  <property name="use_underline">True</property>
+		  <property name="relief">GTK_RELIEF_NORMAL</property>
+		  <property name="focus_on_click">True</property>
+		  <property name="active">False</property>
+		  <property name="inconsistent">False</property>
+		  <property name="draw_indicator">True</property>
+		</widget>
+		<packing>
+		  <property name="padding">0</property>
+		  <property name="expand">False</property>
+		  <property name="fill">False</property>
+		</packing>
+	      </child>
+	    </widget>
+	    <packing>
+	      <property name="tab_expand">False</property>
+	      <property name="tab_fill">False</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkLabel" id="label21">
+	      <property name="visible">True</property>
+	      <property name="label" translatable="yes">User Interface</property>
+	      <property name="use_underline">False</property>
+	      <property name="use_markup">False</property>
+	      <property name="justify">GTK_JUSTIFY_LEFT</property>
+	      <property name="wrap">False</property>
+	      <property name="selectable">False</property>
+	      <property name="xalign">0.5</property>
+	      <property name="yalign">0.5</property>
+	      <property name="xpad">0</property>
+	      <property name="ypad">0</property>
+	      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+	      <property name="width_chars">-1</property>
+	      <property name="single_line_mode">False</property>
+	      <property name="angle">0</property>
+	    </widget>
+	    <packing>
+	      <property name="type">tab</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkVBox" id="vbox16">
+	      <property name="border_width">12</property>
+	      <property name="visible">True</property>
+	      <property name="homogeneous">False</property>
+	      <property name="spacing">6</property>
+
+	      <child>
+		<widget class="GtkCheckButton" id="checkbuttonAutoindex">
+		  <property name="visible">True</property>
+		  <property name="can_focus">True</property>
+		  <property name="label" translatable="yes">_Automatically index MPEG files</property>
+		  <property name="use_underline">True</property>
+		  <property name="relief">GTK_RELIEF_NORMAL</property>
+		  <property name="focus_on_click">True</property>
+		  <property name="active">False</property>
+		  <property name="inconsistent">False</property>
+		  <property name="draw_indicator">True</property>
+		</widget>
+		<packing>
+		  <property name="padding">0</property>
+		  <property name="expand">False</property>
+		  <property name="fill">False</property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkCheckButton" id="checkbuttonNuvResync">
+		  <property name="visible">True</property>
+		  <property name="can_focus">True</property>
+		  <property name="label" translatable="yes">_Disable NuppelVideo resync</property>
+		  <property name="use_underline">True</property>
+		  <property name="relief">GTK_RELIEF_NORMAL</property>
+		  <property name="focus_on_click">True</property>
+		  <property name="active">False</property>
+		  <property name="inconsistent">False</property>
+		  <property name="draw_indicator">True</property>
+		</widget>
+		<packing>
+		  <property name="padding">0</property>
+		  <property name="expand">False</property>
+		  <property name="fill">False</property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkCheckButton" id="checkbuttonLibavcodec">
+		  <property name="visible">True</property>
+		  <property name="can_focus">True</property>
+		  <property name="label" translatable="yes">_Use libavcodec MPEG decoder</property>
+		  <property name="use_underline">True</property>
+		  <property name="relief">GTK_RELIEF_NORMAL</property>
+		  <property name="focus_on_click">True</property>
+		  <property name="active">False</property>
+		  <property name="inconsistent">False</property>
+		  <property name="draw_indicator">True</property>
+		</widget>
+		<packing>
+		  <property name="padding">0</property>
+		  <property name="expand">False</property>
+		  <property name="fill">False</property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkButton" id="buttonPostprocLevel">
+		  <property name="visible">True</property>
+		  <property name="can_focus">True</property>
+		  <property name="label" translatable="yes">_Set Default Postprocessing Level</property>
+		  <property name="use_underline">True</property>
+		  <property name="relief">GTK_RELIEF_NORMAL</property>
+		  <property name="focus_on_click">True</property>
+		</widget>
+		<packing>
+		  <property name="padding">0</property>
+		  <property name="expand">False</property>
+		  <property name="fill">False</property>
+		</packing>
+	      </child>
+	    </widget>
+	    <packing>
+	      <property name="tab_expand">False</property>
+	      <property name="tab_fill">False</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkLabel" id="label23">
+	      <property name="visible">True</property>
+	      <property name="label" translatable="yes">Input</property>
+	      <property name="use_underline">False</property>
+	      <property name="use_markup">False</property>
+	      <property name="justify">GTK_JUSTIFY_LEFT</property>
+	      <property name="wrap">False</property>
+	      <property name="selectable">False</property>
+	      <property name="xalign">0.5</property>
+	      <property name="yalign">0.5</property>
+	      <property name="xpad">0</property>
+	      <property name="ypad">0</property>
+	      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+	      <property name="width_chars">-1</property>
+	      <property name="single_line_mode">False</property>
+	      <property name="angle">0</property>
+	    </widget>
+	    <packing>
+	      <property name="type">tab</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkVBox" id="vbox14">
+	      <property name="border_width">12</property>
+	      <property name="visible">True</property>
+	      <property name="homogeneous">False</property>
+	      <property name="spacing">6</property>
+
+	      <child>
+		<widget class="GtkHBox" id="hbox4">
+		  <property name="visible">True</property>
+		  <property name="homogeneous">False</property>
+		  <property name="spacing">12</property>
+
+		  <child>
+		    <widget class="GtkLabel" id="label13">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_MPEG auto split (MB):</property>
+		      <property name="use_underline">True</property>
+		      <property name="use_markup">False</property>
+		      <property name="justify">GTK_JUSTIFY_LEFT</property>
+		      <property name="wrap">False</property>
+		      <property name="selectable">False</property>
+		      <property name="xalign">0.5</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xpad">0</property>
+		      <property name="ypad">0</property>
+		      <property name="mnemonic_widget">spinbuttonMPEGSplit</property>
+		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		      <property name="width_chars">-1</property>
+		      <property name="single_line_mode">False</property>
+		      <property name="angle">0</property>
+		    </widget>
+		    <packing>
+		      <property name="padding">0</property>
+		      <property name="expand">False</property>
+		      <property name="fill">False</property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkSpinButton" id="spinbuttonMPEGSplit">
+		      <property name="visible">True</property>
+		      <property name="can_focus">True</property>
+		      <property name="climb_rate">1</property>
+		      <property name="digits">0</property>
+		      <property name="numeric">False</property>
+		      <property name="update_policy">GTK_UPDATE_ALWAYS</property>
+		      <property name="snap_to_ticks">False</property>
+		      <property name="wrap">False</property>
+		      <property name="adjustment">790 400 5000 1 10 10</property>
+		    </widget>
+		    <packing>
+		      <property name="padding">0</property>
+		      <property name="expand">False</property>
+		      <property name="fill">False</property>
+		    </packing>
+		  </child>
+		</widget>
+		<packing>
+		  <property name="padding">0</property>
+		  <property name="expand">False</property>
+		  <property name="fill">False</property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkCheckButton" id="checkbuttonOpenDML">
+		  <property name="visible">True</property>
+		  <property name="can_focus">True</property>
+		  <property name="label" translatable="yes">_Use OpenDML (don't split large AVI files)</property>
+		  <property name="use_underline">True</property>
+		  <property name="relief">GTK_RELIEF_NORMAL</property>
+		  <property name="focus_on_click">True</property>
+		  <property name="active">False</property>
+		  <property name="inconsistent">False</property>
+		  <property name="draw_indicator">True</property>
+		</widget>
+		<packing>
+		  <property name="padding">0</property>
+		  <property name="expand">False</property>
+		  <property name="fill">False</property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkCheckButton" id="checkbuttonReuseLog">
+		  <property name="visible">True</property>
+		  <property name="can_focus">True</property>
+		  <property name="label" translatable="yes">_Reuse 2-pass log</property>
+		  <property name="use_underline">True</property>
+		  <property name="relief">GTK_RELIEF_NORMAL</property>
+		  <property name="focus_on_click">True</property>
+		  <property name="active">False</property>
+		  <property name="inconsistent">False</property>
+		  <property name="draw_indicator">True</property>
+		</widget>
+		<packing>
+		  <property name="padding">0</property>
+		  <property name="expand">False</property>
+		  <property name="fill">False</property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkCheckButton" id="checkbuttonLimit">
+		  <property name="visible">True</property>
+		  <property name="can_focus">True</property>
+		  <property name="label" translatable="yes">Allow non standard audio frequency for DVD output</property>
+		  <property name="use_underline">True</property>
+		  <property name="relief">GTK_RELIEF_NORMAL</property>
+		  <property name="focus_on_click">True</property>
+		  <property name="active">False</property>
+		  <property name="inconsistent">False</property>
+		  <property name="draw_indicator">True</property>
+		</widget>
+		<packing>
+		  <property name="padding">0</property>
+		  <property name="expand">False</property>
+		  <property name="fill">False</property>
+		</packing>
+	      </child>
+	    </widget>
+	    <packing>
+	      <property name="tab_expand">False</property>
+	      <property name="tab_fill">False</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkLabel" id="label22">
+	      <property name="visible">True</property>
+	      <property name="label" translatable="yes">Output</property>
+	      <property name="use_underline">False</property>
+	      <property name="use_markup">False</property>
+	      <property name="justify">GTK_JUSTIFY_LEFT</property>
+	      <property name="wrap">False</property>
+	      <property name="selectable">False</property>
+	      <property name="xalign">0.5</property>
+	      <property name="yalign">0.5</property>
+	      <property name="xpad">0</property>
+	      <property name="ypad">0</property>
+	      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+	      <property name="width_chars">-1</property>
+	      <property name="single_line_mode">False</property>
+	      <property name="angle">0</property>
+	    </widget>
+	    <packing>
+	      <property name="type">tab</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkTable" id="table1">
+	      <property name="border_width">12</property>
+	      <property name="visible">True</property>
+	      <property name="n_rows">4</property>
+	      <property name="n_columns">3</property>
+	      <property name="homogeneous">False</property>
+	      <property name="row_spacing">6</property>
+	      <property name="column_spacing">12</property>
+
+	      <child>
+		<widget class="GtkLabel" id="label18">
+		  <property name="visible">True</property>
+		  <property name="label" translatable="yes">_Audio output:</property>
+		  <property name="use_underline">True</property>
+		  <property name="use_markup">False</property>
+		  <property name="justify">GTK_JUSTIFY_LEFT</property>
+		  <property name="wrap">False</property>
+		  <property name="selectable">False</property>
+		  <property name="xalign">0</property>
+		  <property name="yalign">0.5</property>
+		  <property name="xpad">0</property>
+		  <property name="ypad">0</property>
+		  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		  <property name="width_chars">-1</property>
+		  <property name="single_line_mode">False</property>
+		  <property name="angle">0</property>
+		</widget>
+		<packing>
+		  <property name="left_attach">0</property>
+		  <property name="right_attach">1</property>
+		  <property name="top_attach">0</property>
+		  <property name="bottom_attach">1</property>
+		  <property name="x_options">fill</property>
+		  <property name="y_options"></property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkLabel" id="label19">
+		  <property name="visible">True</property>
+		  <property name="label" translatable="yes">ALSA _device:</property>
+		  <property name="use_underline">True</property>
+		  <property name="use_markup">False</property>
+		  <property name="justify">GTK_JUSTIFY_LEFT</property>
+		  <property name="wrap">False</property>
+		  <property name="selectable">False</property>
+		  <property name="xalign">0</property>
+		  <property name="yalign">0.5</property>
+		  <property name="xpad">0</property>
+		  <property name="ypad">0</property>
+		  <property name="mnemonic_widget">entryALSADevice</property>
+		  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		  <property name="width_chars">-1</property>
+		  <property name="single_line_mode">False</property>
+		  <property name="angle">0</property>
+		</widget>
+		<packing>
+		  <property name="left_attach">0</property>
+		  <property name="right_attach">1</property>
+		  <property name="top_attach">1</property>
+		  <property name="bottom_attach">2</property>
+		  <property name="x_options">fill</property>
+		  <property name="y_options"></property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkComboBox" id="comboboxAudioOutput">
+		  <property name="visible">True</property>
+		  <property name="items" translatable="yes"></property>
+		  <property name="add_tearoffs">False</property>
+		  <property name="focus_on_click">True</property>
+		</widget>
+		<packing>
+		  <property name="left_attach">1</property>
+		  <property name="right_attach">3</property>
+		  <property name="top_attach">0</property>
+		  <property name="bottom_attach">1</property>
+		  <property name="y_options">fill</property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkEntry" id="entryALSADevice">
+		  <property name="visible">True</property>
+		  <property name="can_focus">True</property>
+		  <property name="editable">True</property>
+		  <property name="visibility">True</property>
+		  <property name="max_length">0</property>
+		  <property name="text" translatable="yes"></property>
+		  <property name="has_frame">True</property>
+		  <property name="invisible_char">*</property>
+		  <property name="activates_default">False</property>
+		</widget>
+		<packing>
+		  <property name="left_attach">1</property>
+		  <property name="right_attach">3</property>
+		  <property name="top_attach">1</property>
+		  <property name="bottom_attach">2</property>
+		  <property name="y_options"></property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkRadioButton" id="radiobuttonMaster">
+		  <property name="visible">True</property>
+		  <property name="can_focus">True</property>
+		  <property name="label" translatable="yes">_Master</property>
+		  <property name="use_underline">True</property>
+		  <property name="relief">GTK_RELIEF_NORMAL</property>
+		  <property name="focus_on_click">True</property>
+		  <property name="active">False</property>
+		  <property name="inconsistent">False</property>
+		  <property name="draw_indicator">True</property>
+		</widget>
+		<packing>
+		  <property name="left_attach">2</property>
+		  <property name="right_attach">3</property>
+		  <property name="top_attach">3</property>
+		  <property name="bottom_attach">4</property>
+		  <property name="x_options">fill</property>
+		  <property name="y_options"></property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkRadioButton" id="radiobuttonPCM">
+		  <property name="visible">True</property>
+		  <property name="can_focus">True</property>
+		  <property name="label" translatable="yes">_PCM</property>
+		  <property name="use_underline">True</property>
+		  <property name="relief">GTK_RELIEF_NORMAL</property>
+		  <property name="focus_on_click">True</property>
+		  <property name="active">False</property>
+		  <property name="inconsistent">False</property>
+		  <property name="draw_indicator">True</property>
+		  <property name="group">radiobuttonMaster</property>
+		</widget>
+		<packing>
+		  <property name="left_attach">1</property>
+		  <property name="right_attach">2</property>
+		  <property name="top_attach">3</property>
+		  <property name="bottom_attach">4</property>
+		  <property name="x_options">fill</property>
+		  <property name="y_options"></property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkLabel" id="label20">
+		  <property name="visible">True</property>
+		  <property name="label" translatable="yes">_Volume bar controls:</property>
+		  <property name="use_underline">True</property>
+		  <property name="use_markup">False</property>
+		  <property name="justify">GTK_JUSTIFY_LEFT</property>
+		  <property name="wrap">False</property>
+		  <property name="selectable">False</property>
+		  <property name="xalign">0</property>
+		  <property name="yalign">0.5</property>
+		  <property name="xpad">0</property>
+		  <property name="ypad">0</property>
+		  <property name="mnemonic_widget">radiobuttonPCM</property>
+		  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		  <property name="width_chars">-1</property>
+		  <property name="single_line_mode">False</property>
+		  <property name="angle">0</property>
+		</widget>
+		<packing>
+		  <property name="left_attach">0</property>
+		  <property name="right_attach">1</property>
+		  <property name="top_attach">3</property>
+		  <property name="bottom_attach">4</property>
+		  <property name="x_options">fill</property>
+		  <property name="y_options"></property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkLabel" id="label29">
+		  <property name="visible">True</property>
+		  <property name="label" translatable="yes">Local Playback Downmixing</property>
+		  <property name="use_underline">False</property>
+		  <property name="use_markup">False</property>
+		  <property name="justify">GTK_JUSTIFY_LEFT</property>
+		  <property name="wrap">False</property>
+		  <property name="selectable">False</property>
+		  <property name="xalign">0</property>
+		  <property name="yalign">0.5</property>
+		  <property name="xpad">0</property>
+		  <property name="ypad">0</property>
+		  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		  <property name="width_chars">-1</property>
+		  <property name="single_line_mode">False</property>
+		  <property name="angle">0</property>
+		</widget>
+		<packing>
+		  <property name="left_attach">0</property>
+		  <property name="right_attach">1</property>
+		  <property name="top_attach">2</property>
+		  <property name="bottom_attach">3</property>
+		  <property name="x_options">fill</property>
+		  <property name="y_options"></property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkComboBox" id="comboboxDownMix">
+		  <property name="visible">True</property>
+		  <property name="items" translatable="yes">No downmixing (multichannel)
+Dolby Prologic
+Dolby Prologic 2</property>
+		  <property name="add_tearoffs">False</property>
+		  <property name="focus_on_click">True</property>
+		</widget>
+		<packing>
+		  <property name="left_attach">1</property>
+		  <property name="right_attach">2</property>
+		  <property name="top_attach">2</property>
+		  <property name="bottom_attach">3</property>
+		  <property name="x_options">fill</property>
+		  <property name="y_options">fill</property>
+		</packing>
+	      </child>
+	    </widget>
+	    <packing>
+	      <property name="tab_expand">False</property>
+	      <property name="tab_fill">False</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkLabel" id="label25">
+	      <property name="visible">True</property>
+	      <property name="label" translatable="yes">Audio</property>
+	      <property name="use_underline">False</property>
+	      <property name="use_markup">False</property>
+	      <property name="justify">GTK_JUSTIFY_LEFT</property>
+	      <property name="wrap">False</property>
+	      <property name="selectable">False</property>
+	      <property name="xalign">0.5</property>
+	      <property name="yalign">0.5</property>
+	      <property name="xpad">0</property>
+	      <property name="ypad">0</property>
+	      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+	      <property name="width_chars">-1</property>
+	      <property name="single_line_mode">False</property>
+	      <property name="angle">0</property>
+	    </widget>
+	    <packing>
+	      <property name="type">tab</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkTable" id="table2">
+	      <property name="visible">True</property>
+	      <property name="n_rows">2</property>
+	      <property name="n_columns">2</property>
+	      <property name="homogeneous">False</property>
+	      <property name="row_spacing">0</property>
+	      <property name="column_spacing">0</property>
+
+	      <child>
+		<widget class="GtkHBox" id="hbox5">
+		  <property name="border_width">12</property>
+		  <property name="visible">True</property>
+		  <property name="homogeneous">False</property>
+		  <property name="spacing">12</property>
+
+		  <child>
+		    <widget class="GtkLabel" id="label16">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_Video output:</property>
+		      <property name="use_underline">True</property>
+		      <property name="use_markup">False</property>
+		      <property name="justify">GTK_JUSTIFY_LEFT</property>
+		      <property name="wrap">False</property>
+		      <property name="selectable">False</property>
+		      <property name="xalign">0.5</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xpad">0</property>
+		      <property name="ypad">0</property>
+		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		      <property name="width_chars">-1</property>
+		      <property name="single_line_mode">False</property>
+		      <property name="angle">0</property>
+		    </widget>
+		    <packing>
+		      <property name="padding">0</property>
+		      <property name="expand">False</property>
+		      <property name="fill">False</property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkComboBox" id="comboboxVideoOutput">
+		      <property name="visible">True</property>
+		      <property name="items" translatable="yes"></property>
+		      <property name="add_tearoffs">False</property>
+		      <property name="focus_on_click">True</property>
+		    </widget>
+		    <packing>
+		      <property name="padding">0</property>
+		      <property name="expand">True</property>
+		      <property name="fill">True</property>
+		    </packing>
+		  </child>
+		</widget>
+		<packing>
+		  <property name="left_attach">0</property>
+		  <property name="right_attach">2</property>
+		  <property name="top_attach">0</property>
+		  <property name="bottom_attach">2</property>
+		  <property name="y_options">fill</property>
+		</packing>
+	      </child>
+	    </widget>
+	    <packing>
+	      <property name="tab_expand">False</property>
+	      <property name="tab_fill">False</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkLabel" id="label24">
+	      <property name="visible">True</property>
+	      <property name="label" translatable="yes">Video</property>
+	      <property name="use_underline">False</property>
+	      <property name="use_markup">False</property>
+	      <property name="justify">GTK_JUSTIFY_LEFT</property>
+	      <property name="wrap">False</property>
+	      <property name="selectable">False</property>
+	      <property name="xalign">0.5</property>
+	      <property name="yalign">0.5</property>
+	      <property name="xpad">0</property>
+	      <property name="ypad">0</property>
+	      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+	      <property name="width_chars">-1</property>
+	      <property name="single_line_mode">False</property>
+	      <property name="angle">0</property>
+	    </widget>
+	    <packing>
+	      <property name="type">tab</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkHBox" id="hbox6">
+	      <property name="visible">True</property>
+	      <property name="homogeneous">False</property>
+	      <property name="spacing">0</property>
+
+	      <child>
+		<widget class="GtkLabel" id="label27">
+		  <property name="visible">True</property>
+		  <property name="label" translatable="yes">Enable multithreading : </property>
+		  <property name="use_underline">False</property>
+		  <property name="use_markup">False</property>
+		  <property name="justify">GTK_JUSTIFY_LEFT</property>
+		  <property name="wrap">False</property>
+		  <property name="selectable">False</property>
+		  <property name="xalign">0.5</property>
+		  <property name="yalign">0.5</property>
+		  <property name="xpad">0</property>
+		  <property name="ypad">0</property>
+		  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		  <property name="width_chars">-1</property>
+		  <property name="single_line_mode">False</property>
+		  <property name="angle">0</property>
+		</widget>
+		<packing>
+		  <property name="padding">0</property>
+		  <property name="expand">False</property>
+		  <property name="fill">False</property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkSpinButton" id="spinbuttonThread">
+		  <property name="visible">True</property>
+		  <property name="can_focus">True</property>
+		  <property name="climb_rate">1</property>
+		  <property name="digits">0</property>
+		  <property name="numeric">True</property>
+		  <property name="update_policy">GTK_UPDATE_ALWAYS</property>
+		  <property name="snap_to_ticks">False</property>
+		  <property name="wrap">False</property>
+		  <property name="adjustment">0 0 4 1 10 10</property>
+		</widget>
+		<packing>
+		  <property name="padding">0</property>
+		  <property name="expand">False</property>
+		  <property name="fill">True</property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkLabel" id="label28">
+		  <property name="visible">True</property>
+		  <property name="label" translatable="yes">Threads</property>
+		  <property name="use_underline">False</property>
+		  <property name="use_markup">False</property>
+		  <property name="justify">GTK_JUSTIFY_LEFT</property>
+		  <property name="wrap">False</property>
+		  <property name="selectable">False</property>
+		  <property name="xalign">0.5</property>
+		  <property name="yalign">0.5</property>
+		  <property name="xpad">0</property>
+		  <property name="ypad">0</property>
+		  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		  <property name="width_chars">-1</property>
+		  <property name="single_line_mode">False</property>
+		  <property name="angle">0</property>
+		</widget>
+		<packing>
+		  <property name="padding">0</property>
+		  <property name="expand">False</property>
+		  <property name="fill">False</property>
+		</packing>
+	      </child>
+	    </widget>
+	    <packing>
+	      <property name="tab_expand">False</property>
+	      <property name="tab_fill">True</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkLabel" id="label26">
+	      <property name="visible">True</property>
+	      <property name="label" translatable="yes">MultiThread</property>
+	      <property name="use_underline">False</property>
+	      <property name="use_markup">False</property>
+	      <property name="justify">GTK_JUSTIFY_LEFT</property>
+	      <property name="wrap">False</property>
+	      <property name="selectable">False</property>
+	      <property name="xalign">0.5</property>
+	      <property name="yalign">0.5</property>
+	      <property name="xpad">0</property>
+	      <property name="ypad">0</property>
+	      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+	      <property name="width_chars">-1</property>
+	      <property name="single_line_mode">False</property>
+	      <property name="angle">0</property>
+	    </widget>
+	    <packing>
+	      <property name="type">tab</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkTable" id="table3">
+	      <property name="visible">True</property>
+	      <property name="n_rows">2</property>
+	      <property name="n_columns">2</property>
+	      <property name="homogeneous">False</property>
+	      <property name="row_spacing">0</property>
+	      <property name="column_spacing">0</property>
+
+	      <child>
+		<widget class="GtkLabel" id="label31">
+		  <property name="visible">True</property>
+		  <property name="label" translatable="yes">Load external filters</property>
+		  <property name="use_underline">False</property>
+		  <property name="use_markup">False</property>
+		  <property name="justify">GTK_JUSTIFY_LEFT</property>
+		  <property name="wrap">False</property>
+		  <property name="selectable">False</property>
+		  <property name="xalign">0</property>
+		  <property name="yalign">0.5</property>
+		  <property name="xpad">0</property>
+		  <property name="ypad">0</property>
+		  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		  <property name="width_chars">-1</property>
+		  <property name="single_line_mode">False</property>
+		  <property name="angle">0</property>
+		</widget>
+		<packing>
+		  <property name="left_attach">0</property>
+		  <property name="right_attach">1</property>
+		  <property name="top_attach">0</property>
+		  <property name="bottom_attach">1</property>
+		  <property name="x_options">fill</property>
+		  <property name="y_options"></property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkCheckButton" id="checkbuttonXfilter">
+		  <property name="visible">True</property>
+		  <property name="can_focus">True</property>
+		  <property name="label" translatable="yes"></property>
+		  <property name="use_underline">True</property>
+		  <property name="relief">GTK_RELIEF_NORMAL</property>
+		  <property name="focus_on_click">True</property>
+		  <property name="active">False</property>
+		  <property name="inconsistent">False</property>
+		  <property name="draw_indicator">True</property>
+		</widget>
+		<packing>
+		  <property name="left_attach">1</property>
+		  <property name="right_attach">2</property>
+		  <property name="top_attach">0</property>
+		  <property name="bottom_attach">1</property>
+		  <property name="x_options">fill</property>
+		  <property name="y_options"></property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkLabel" id="label32">
+		  <property name="visible">True</property>
+		  <property name="label" translatable="yes">Path to external filters</property>
+		  <property name="use_underline">False</property>
+		  <property name="use_markup">False</property>
+		  <property name="justify">GTK_JUSTIFY_LEFT</property>
+		  <property name="wrap">False</property>
+		  <property name="selectable">False</property>
+		  <property name="xalign">0</property>
+		  <property name="yalign">0.5</property>
+		  <property name="xpad">0</property>
+		  <property name="ypad">0</property>
+		  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		  <property name="width_chars">-1</property>
+		  <property name="single_line_mode">False</property>
+		  <property name="angle">0</property>
+		</widget>
+		<packing>
+		  <property name="left_attach">0</property>
+		  <property name="right_attach">1</property>
+		  <property name="top_attach">1</property>
+		  <property name="bottom_attach">2</property>
+		  <property name="x_options">fill</property>
+		  <property name="y_options"></property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkHBox" id="hbox7">
+		  <property name="visible">True</property>
+		  <property name="homogeneous">False</property>
+		  <property name="spacing">0</property>
+
+		  <child>
+		    <widget class="GtkEntry" id="entryXfilter">
+		      <property name="visible">True</property>
+		      <property name="can_focus">True</property>
+		      <property name="editable">True</property>
+		      <property name="visibility">True</property>
+		      <property name="max_length">0</property>
+		      <property name="text" translatable="yes"></property>
+		      <property name="has_frame">True</property>
+		      <property name="invisible_char">*</property>
+		      <property name="activates_default">False</property>
+		    </widget>
+		    <packing>
+		      <property name="padding">0</property>
+		      <property name="expand">True</property>
+		      <property name="fill">True</property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkButton" id="buttonXfilter">
+		      <property name="visible">True</property>
+		      <property name="can_focus">True</property>
+		      <property name="relief">GTK_RELIEF_NORMAL</property>
+		      <property name="focus_on_click">True</property>
+
+		      <child>
+			<widget class="GtkImage" id="image1">
+			  <property name="visible">True</property>
+			  <property name="stock">gtk-open</property>
+			  <property name="icon_size">4</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		    <packing>
+		      <property name="padding">0</property>
+		      <property name="expand">False</property>
+		      <property name="fill">False</property>
+		    </packing>
+		  </child>
+		</widget>
+		<packing>
+		  <property name="left_attach">1</property>
+		  <property name="right_attach">2</property>
+		  <property name="top_attach">1</property>
+		  <property name="bottom_attach">2</property>
+		  <property name="y_options">fill</property>
+		</packing>
+	      </child>
+	    </widget>
+	    <packing>
+	      <property name="tab_expand">False</property>
+	      <property name="tab_fill">True</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkLabel" id="label30">
+	      <property name="visible">True</property>
+	      <property name="label" translatable="yes">External filter</property>
+	      <property name="use_underline">False</property>
+	      <property name="use_markup">False</property>
+	      <property name="justify">GTK_JUSTIFY_LEFT</property>
+	      <property name="wrap">False</property>
+	      <property name="selectable">False</property>
+	      <property name="xalign">0.5</property>
+	      <property name="yalign">0.5</property>
+	      <property name="xpad">0</property>
+	      <property name="ypad">0</property>
+	      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+	      <property name="width_chars">-1</property>
+	      <property name="single_line_mode">False</property>
+	      <property name="angle">0</property>
+	    </widget>
+	    <packing>
+	      <property name="type">tab</property>
+	    </packing>
+	  </child>
+	</widget>
+	<packing>
+	  <property name="padding">0</property>
+	  <property name="expand">False</property>
+	  <property name="fill">False</property>
+	</packing>
+      </child>
+    </widget>
+  </child>
+</widget>
+
+</glade-interface>

Added: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/glade/project_x264.glade
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/glade/project_x264.glade	2007-01-15 19:09:58 UTC (rev 2738)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/glade/project_x264.glade	2007-01-16 19:22:29 UTC (rev 2739)
@@ -0,0 +1,582 @@
+<?xml version="1.0" standalone="no"?> <!--*- mode: xml -*-->
+<!DOCTYPE glade-interface SYSTEM "http://glade.gnome.org/glade-2.0.dtd">
+
+<glade-interface>
+
+<widget class="GtkDialog" id="dialog1">
+  <property name="visible">True</property>
+  <property name="title" translatable="yes">X264 Settings</property>
+  <property name="type">GTK_WINDOW_TOPLEVEL</property>
+  <property name="window_position">GTK_WIN_POS_NONE</property>
+  <property name="modal">False</property>
+  <property name="resizable">True</property>
+  <property name="destroy_with_parent">False</property>
+  <property name="has_separator">True</property>
+
+  <child internal-child="vbox">
+    <widget class="GtkVBox" id="dialog-vbox1">
+      <property name="visible">True</property>
+      <property name="homogeneous">False</property>
+      <property name="spacing">0</property>
+
+      <child internal-child="action_area">
+	<widget class="GtkHButtonBox" id="dialog-action_area1">
+	  <property name="visible">True</property>
+	  <property name="layout_style">GTK_BUTTONBOX_END</property>
+
+	  <child>
+	    <widget class="GtkButton" id="cancelbutton1">
+	      <property name="visible">True</property>
+	      <property name="can_default">True</property>
+	      <property name="can_focus">True</property>
+	      <property name="label">gtk-cancel</property>
+	      <property name="use_stock">True</property>
+	      <property name="relief">GTK_RELIEF_NORMAL</property>
+	      <property name="response_id">-6</property>
+	    </widget>
+	  </child>
+
+	  <child>
+	    <widget class="GtkButton" id="okbutton1">
+	      <property name="visible">True</property>
+	      <property name="can_default">True</property>
+	      <property name="can_focus">True</property>
+	      <property name="label">gtk-ok</property>
+	      <property name="use_stock">True</property>
+	      <property name="relief">GTK_RELIEF_NORMAL</property>
+	      <property name="response_id">-5</property>
+	    </widget>
+	  </child>
+	</widget>
+	<packing>
+	  <property name="padding">0</property>
+	  <property name="expand">False</property>
+	  <property name="fill">True</property>
+	  <property name="pack_type">GTK_PACK_END</property>
+	</packing>
+      </child>
+
+      <child>
+	<widget class="GtkVBox" id="vbox1">
+	  <property name="visible">True</property>
+	  <property name="homogeneous">False</property>
+	  <property name="spacing">0</property>
+
+	  <child>
+	    <widget class="GtkFrame" id="frame1">
+	      <property name="visible">True</property>
+	      <property name="label_xalign">0</property>
+	      <property name="label_yalign">0.5</property>
+	      <property name="shadow_type">GTK_SHADOW_ETCHED_IN</property>
+
+	      <child>
+		<widget class="GtkTable" id="table1">
+		  <property name="visible">True</property>
+		  <property name="n_rows">3</property>
+		  <property name="n_columns">2</property>
+		  <property name="homogeneous">False</property>
+		  <property name="row_spacing">0</property>
+		  <property name="column_spacing">0</property>
+
+		  <child>
+		    <widget class="GtkOptionMenu" id="optionmenu1">
+		      <property name="visible">True</property>
+		      <property name="can_focus">True</property>
+		      <property name="history">0</property>
+
+		      <child>
+			<widget class="GtkMenu" id="menu1">
+
+			  <child>
+			    <widget class="GtkMenuItem" id="constant_quantizer1">
+			      <property name="visible">True</property>
+			      <property name="label" translatable="yes">Constant Quantizer</property>
+			      <property name="use_underline">True</property>
+			    </widget>
+			  </child>
+
+			  <child>
+			    <widget class="GtkMenuItem" id="constant_bitrate1">
+			      <property name="visible">True</property>
+			      <property name="label" translatable="yes">Constant Bitrate</property>
+			      <property name="use_underline">True</property>
+			    </widget>
+			  </child>
+
+			  <child>
+			    <widget class="GtkMenuItem" id="2_pass_average_bitrate1">
+			      <property name="visible">True</property>
+			      <property name="label" translatable="yes">2 pass Average Bitrate</property>
+			      <property name="use_underline">True</property>
+			    </widget>
+			  </child>
+			</widget>
+		      </child>
+		    </widget>
+		    <packing>
+		      <property name="left_attach">1</property>
+		      <property name="right_attach">2</property>
+		      <property name="top_attach">0</property>
+		      <property name="bottom_attach">1</property>
+		      <property name="x_options">fill</property>
+		      <property name="y_options"></property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkLabel" id="label2">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Mode :</property>
+		      <property name="use_underline">False</property>
+		      <property name="use_markup">False</property>
+		      <property name="justify">GTK_JUSTIFY_LEFT</property>
+		      <property name="wrap">False</property>
+		      <property name="selectable">False</property>
+		      <property name="xalign">0</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xpad">0</property>
+		      <property name="ypad">0</property>
+		    </widget>
+		    <packing>
+		      <property name="left_attach">0</property>
+		      <property name="right_attach">1</property>
+		      <property name="top_attach">0</property>
+		      <property name="bottom_attach">1</property>
+		      <property name="y_options"></property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkLabel" id="label3">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Quantizer :</property>
+		      <property name="use_underline">False</property>
+		      <property name="use_markup">False</property>
+		      <property name="justify">GTK_JUSTIFY_LEFT</property>
+		      <property name="wrap">False</property>
+		      <property name="selectable">False</property>
+		      <property name="xalign">0</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xpad">0</property>
+		      <property name="ypad">0</property>
+		    </widget>
+		    <packing>
+		      <property name="left_attach">0</property>
+		      <property name="right_attach">1</property>
+		      <property name="top_attach">1</property>
+		      <property name="bottom_attach">2</property>
+		      <property name="y_options"></property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkEntry" id="entryQz">
+		      <property name="visible">True</property>
+		      <property name="can_focus">True</property>
+		      <property name="editable">True</property>
+		      <property name="visibility">True</property>
+		      <property name="max_length">0</property>
+		      <property name="text" translatable="yes"></property>
+		      <property name="has_frame">True</property>
+		      <property name="invisible_char" translatable="yes">*</property>
+		      <property name="activates_default">False</property>
+		    </widget>
+		    <packing>
+		      <property name="left_attach">1</property>
+		      <property name="right_attach">2</property>
+		      <property name="top_attach">1</property>
+		      <property name="bottom_attach">2</property>
+		      <property name="y_options"></property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkHSeparator" id="hseparator1">
+		      <property name="visible">True</property>
+		    </widget>
+		    <packing>
+		      <property name="left_attach">0</property>
+		      <property name="right_attach">1</property>
+		      <property name="top_attach">2</property>
+		      <property name="bottom_attach">3</property>
+		      <property name="x_options">fill</property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkHSeparator" id="hseparator2">
+		      <property name="visible">True</property>
+		    </widget>
+		    <packing>
+		      <property name="left_attach">1</property>
+		      <property name="right_attach">2</property>
+		      <property name="top_attach">2</property>
+		      <property name="bottom_attach">3</property>
+		      <property name="x_options">fill</property>
+		      <property name="y_options">fill</property>
+		    </packing>
+		  </child>
+		</widget>
+	      </child>
+
+	      <child>
+		<widget class="GtkLabel" id="label1">
+		  <property name="visible">True</property>
+		  <property name="label" translatable="yes">&lt;b&gt;Encoding Mode&lt;/b&gt;</property>
+		  <property name="use_underline">False</property>
+		  <property name="use_markup">True</property>
+		  <property name="justify">GTK_JUSTIFY_LEFT</property>
+		  <property name="wrap">False</property>
+		  <property name="selectable">False</property>
+		  <property name="xalign">0.5</property>
+		  <property name="yalign">0.5</property>
+		  <property name="xpad">0</property>
+		  <property name="ypad">0</property>
+		</widget>
+		<packing>
+		  <property name="type">label_item</property>
+		</packing>
+	      </child>
+	    </widget>
+	    <packing>
+	      <property name="padding">0</property>
+	      <property name="expand">True</property>
+	      <property name="fill">True</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkFrame" id="frame2">
+	      <property name="visible">True</property>
+	      <property name="label_xalign">0</property>
+	      <property name="label_yalign">0.5</property>
+	      <property name="shadow_type">GTK_SHADOW_ETCHED_IN</property>
+
+	      <child>
+		<widget class="GtkVBox" id="vbox2">
+		  <property name="visible">True</property>
+		  <property name="homogeneous">False</property>
+		  <property name="spacing">0</property>
+
+		  <child>
+		    <widget class="GtkTable" id="table2">
+		      <property name="visible">True</property>
+		      <property name="n_rows">1</property>
+		      <property name="n_columns">4</property>
+		      <property name="homogeneous">False</property>
+		      <property name="row_spacing">0</property>
+		      <property name="column_spacing">0</property>
+
+		      <child>
+			<widget class="GtkSpinButton" id="spinbuttonQmin">
+			  <property name="visible">True</property>
+			  <property name="can_focus">True</property>
+			  <property name="climb_rate">1</property>
+			  <property name="digits">0</property>
+			  <property name="numeric">True</property>
+			  <property name="update_policy">GTK_UPDATE_ALWAYS</property>
+			  <property name="snap_to_ticks">False</property>
+			  <property name="wrap">False</property>
+			  <property name="adjustment">1 1 50 1 10 10</property>
+			</widget>
+			<packing>
+			  <property name="left_attach">1</property>
+			  <property name="right_attach">2</property>
+			  <property name="top_attach">0</property>
+			  <property name="bottom_attach">1</property>
+			  <property name="x_options">fill</property>
+			  <property name="y_options"></property>
+			</packing>
+		      </child>
+
+		      <child>
+			<widget class="GtkSpinButton" id="spinbuttonQmax">
+			  <property name="visible">True</property>
+			  <property name="can_focus">True</property>
+			  <property name="climb_rate">1</property>
+			  <property name="digits">0</property>
+			  <property name="numeric">True</property>
+			  <property name="update_policy">GTK_UPDATE_ALWAYS</property>
+			  <property name="snap_to_ticks">False</property>
+			  <property name="wrap">False</property>
+			  <property name="adjustment">1 1 50 1 10 10</property>
+			</widget>
+			<packing>
+			  <property name="left_attach">3</property>
+			  <property name="right_attach">4</property>
+			  <property name="top_attach">0</property>
+			  <property name="bottom_attach">1</property>
+			  <property name="x_options">fill</property>
+			  <property name="y_options"></property>
+			</packing>
+		      </child>
+
+		      <child>
+			<widget class="GtkLabel" id="label5">
+			  <property name="visible">True</property>
+			  <property name="label" translatable="yes">Qmin :</property>
+			  <property name="use_underline">False</property>
+			  <property name="use_markup">False</property>
+			  <property name="justify">GTK_JUSTIFY_LEFT</property>
+			  <property name="wrap">False</property>
+			  <property name="selectable">False</property>
+			  <property name="xalign">0</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+			<packing>
+			  <property name="left_attach">0</property>
+			  <property name="right_attach">1</property>
+			  <property name="top_attach">0</property>
+			  <property name="bottom_attach">1</property>
+			  <property name="x_options">expand</property>
+			  <property name="y_options"></property>
+			</packing>
+		      </child>
+
+		      <child>
+			<widget class="GtkLabel" id="label6">
+			  <property name="visible">True</property>
+			  <property name="label" translatable="yes">Qmax :</property>
+			  <property name="use_underline">False</property>
+			  <property name="use_markup">False</property>
+			  <property name="justify">GTK_JUSTIFY_LEFT</property>
+			  <property name="wrap">False</property>
+			  <property name="selectable">False</property>
+			  <property name="xalign">0</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+			<packing>
+			  <property name="left_attach">2</property>
+			  <property name="right_attach">3</property>
+			  <property name="top_attach">0</property>
+			  <property name="bottom_attach">1</property>
+			  <property name="x_options">expand</property>
+			  <property name="y_options"></property>
+			</packing>
+		      </child>
+		    </widget>
+		    <packing>
+		      <property name="padding">0</property>
+		      <property name="expand">True</property>
+		      <property name="fill">True</property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkHBox" id="hbox1">
+		      <property name="visible">True</property>
+		      <property name="homogeneous">False</property>
+		      <property name="spacing">0</property>
+
+		      <child>
+			<widget class="GtkLabel" id="label7">
+			  <property name="visible">True</property>
+			  <property name="label" translatable="yes">Kf Min :</property>
+			  <property name="use_underline">False</property>
+			  <property name="use_markup">False</property>
+			  <property name="justify">GTK_JUSTIFY_LEFT</property>
+			  <property name="wrap">False</property>
+			  <property name="selectable">False</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+			<packing>
+			  <property name="padding">0</property>
+			  <property name="expand">True</property>
+			  <property name="fill">False</property>
+			</packing>
+		      </child>
+
+		      <child>
+			<widget class="GtkSpinButton" id="spinbuttonKfmin">
+			  <property name="visible">True</property>
+			  <property name="can_focus">True</property>
+			  <property name="climb_rate">1</property>
+			  <property name="digits">0</property>
+			  <property name="numeric">True</property>
+			  <property name="update_policy">GTK_UPDATE_ALWAYS</property>
+			  <property name="snap_to_ticks">False</property>
+			  <property name="wrap">False</property>
+			  <property name="adjustment">5 5 5000 1 10 10</property>
+			</widget>
+			<packing>
+			  <property name="padding">0</property>
+			  <property name="expand">False</property>
+			  <property name="fill">True</property>
+			</packing>
+		      </child>
+
+		      <child>
+			<widget class="GtkLabel" id="label8">
+			  <property name="visible">True</property>
+			  <property name="label" translatable="yes">Kf Max :</property>
+			  <property name="use_underline">False</property>
+			  <property name="use_markup">False</property>
+			  <property name="justify">GTK_JUSTIFY_LEFT</property>
+			  <property name="wrap">False</property>
+			  <property name="selectable">False</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+			<packing>
+			  <property name="padding">0</property>
+			  <property name="expand">True</property>
+			  <property name="fill">False</property>
+			</packing>
+		      </child>
+
+		      <child>
+			<widget class="GtkSpinButton" id="spinbuttonKfmax">
+			  <property name="visible">True</property>
+			  <property name="can_focus">True</property>
+			  <property name="climb_rate">1</property>
+			  <property name="digits">0</property>
+			  <property name="numeric">True</property>
+			  <property name="update_policy">GTK_UPDATE_ALWAYS</property>
+			  <property name="snap_to_ticks">False</property>
+			  <property name="wrap">False</property>
+			  <property name="adjustment">5 5 5000 1 10 10</property>
+			</widget>
+			<packing>
+			  <property name="padding">0</property>
+			  <property name="expand">False</property>
+			  <property name="fill">True</property>
+			</packing>
+		      </child>
+		    </widget>
+		    <packing>
+		      <property name="padding">0</property>
+		      <property name="expand">True</property>
+		      <property name="fill">True</property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkHBox" id="hbox2">
+		      <property name="visible">True</property>
+		      <property name="homogeneous">False</property>
+		      <property name="spacing">0</property>
+
+		      <child>
+			<widget class="GtkLabel" id="label9">
+			  <property name="visible">True</property>
+			  <property name="label" translatable="yes"># B Frames :</property>
+			  <property name="use_underline">False</property>
+			  <property name="use_markup">False</property>
+			  <property name="justify">GTK_JUSTIFY_LEFT</property>
+			  <property name="wrap">False</property>
+			  <property name="selectable">False</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+			<packing>
+			  <property name="padding">0</property>
+			  <property name="expand">False</property>
+			  <property name="fill">False</property>
+			</packing>
+		      </child>
+
+		      <child>
+			<widget class="GtkSpinButton" id="spinbuttonBframes">
+			  <property name="visible">True</property>
+			  <property name="can_focus">True</property>
+			  <property name="climb_rate">1</property>
+			  <property name="digits">0</property>
+			  <property name="numeric">True</property>
+			  <property name="update_policy">GTK_UPDATE_ALWAYS</property>
+			  <property name="snap_to_ticks">False</property>
+			  <property name="wrap">False</property>
+			  <property name="adjustment">1 0 4 1 10 10</property>
+			</widget>
+			<packing>
+			  <property name="padding">0</property>
+			  <property name="expand">False</property>
+			  <property name="fill">False</property>
+			</packing>
+		      </child>
+
+		      <child>
+			<widget class="GtkCheckButton" id="checkbuttonCabac">
+			  <property name="visible">True</property>
+			  <property name="can_focus">True</property>
+			  <property name="label" translatable="yes">Cabac</property>
+			  <property name="use_underline">True</property>
+			  <property name="relief">GTK_RELIEF_NORMAL</property>
+			  <property name="active">False</property>
+			  <property name="inconsistent">False</property>
+			  <property name="draw_indicator">True</property>
+			</widget>
+			<packing>
+			  <property name="padding">0</property>
+			  <property name="expand">False</property>
+			  <property name="fill">False</property>
+			</packing>
+		      </child>
+
+		      <child>
+			<widget class="GtkHSeparator" id="hseparator3">
+			  <property name="visible">True</property>
+			</widget>
+			<packing>
+			  <property name="padding">0</property>
+			  <property name="expand">True</property>
+			  <property name="fill">True</property>
+			</packing>
+		      </child>
+		    </widget>
+		    <packing>
+		      <property name="padding">0</property>
+		      <property name="expand">True</property>
+		      <property name="fill">True</property>
+		    </packing>
+		  </child>
+		</widget>
+	      </child>
+
+	      <child>
+		<widget class="GtkLabel" id="label4">
+		  <property name="visible">True</property>
+		  <property name="label" translatable="yes">&lt;b&gt;Settings&lt;/b&gt;</property>
+		  <property name="use_underline">False</property>
+		  <property name="use_markup">True</property>
+		  <property name="justify">GTK_JUSTIFY_LEFT</property>
+		  <property name="wrap">False</property>
+		  <property name="selectable">False</property>
+		  <property name="xalign">0.5</property>
+		  <property name="yalign">0.5</property>
+		  <property name="xpad">0</property>
+		  <property name="ypad">0</property>
+		</widget>
+		<packing>
+		  <property name="type">label_item</property>
+		</packing>
+	      </child>
+	    </widget>
+	    <packing>
+	      <property name="padding">0</property>
+	      <property name="expand">True</property>
+	      <property name="fill">True</property>
+	    </packing>
+	  </child>
+	</widget>
+	<packing>
+	  <property name="padding">0</property>
+	  <property name="expand">True</property>
+	  <property name="fill">True</property>
+	</packing>
+      </child>
+    </widget>
+  </child>
+</widget>
+
+</glade-interface>



From mean at mail.berlios.de  Tue Jan 16 20:23:12 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 16 Jan 2007 20:23:12 +0100
Subject: [Avidemux-svn-commit] r2740 -
	branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog
Message-ID: <200701161923.l0GJNCEi013026@sheep.berlios.de>

Author: mean
Date: 2007-01-16 20:23:12 +0100 (Tue, 16 Jan 2007)
New Revision: 2740

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_prefs.cpp
Log:
partial preferences dialog for external filters

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_prefs.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_prefs.cpp	2007-01-16 19:22:29 UTC (rev 2739)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_prefs.cpp	2007-01-16 19:23:12 UTC (rev 2740)
@@ -225,6 +225,19 @@
         }
         gtk_combo_box_set_active(combo_box,k);
 #endif
+        // _______ External Filter Xfilter__________________
+        uint32_t activeXfilter=0;
+        prefs->get(FILTERS_AUTOLOAD_ACTIVE,&activeXfilter);
+        gtk_toggle_button_set_active( GTK_TOGGLE_BUTTON(WID(checkbuttonXfilter)),activeXfilter);
+        
+         if( prefs->get(FILTERS_AUTOLOAD_PATH, &str) != RC_OK )
+#ifndef CYG_MANGLING
+               str = ADM_strdup("/tmp");
+#else
+               str = ADM_strdup("c:\\");
+#endif
+        gtk_write_entry_string(WID(entryXfilter), str);
+        ADM_dealloc(str);
         //______________________________________________________
         // Callback for button
         gtk_signal_connect(GTK_OBJECT(WID(buttonPostprocLevel)), "clicked",GTK_SIGNAL_FUNC(setpp),   NULL);
@@ -263,7 +276,15 @@
                 render=myVideoDevice[k].type;
                 renderI=(int)render;
                 prefs->set(DEVICE_VIDEODEVICE,renderI);
-        
+                //************* Xfilter
+                activeXfilter=gtk_toggle_button_get_active( GTK_TOGGLE_BUTTON(WID(checkbuttonXfilter)));
+                prefs->set(FILTERS_AUTOLOAD_ACTIVE,activeXfilter);
+                
+                 str=gtk_editable_get_chars(GTK_EDITABLE (WID(entryXfilter)), 0, -1);
+                if(str)
+                        prefs->set(FILTERS_AUTOLOAD_PATH, str);
+                
+                
                 //**************
                 useTray=gtk_toggle_button_get_active( GTK_TOGGLE_BUTTON(WID(checkbuttonSystray)));
                 prefs->set(FEATURE_USE_SYSTRAY,useTray);
@@ -401,6 +422,15 @@
   GtkWidget *spinbuttonThread;
   GtkWidget *label28;
   GtkWidget *label26;
+  GtkWidget *table3;
+  GtkWidget *label31;
+  GtkWidget *checkbuttonXfilter;
+  GtkWidget *label32;
+  GtkWidget *hbox7;
+  GtkWidget *entryXfilter;
+  GtkWidget *buttonXfilter;
+  GtkWidget *image1;
+  GtkWidget *label30;
   GtkWidget *dialog_action_area1;
   GtkWidget *okbutton1;
 
@@ -520,7 +550,6 @@
   gtk_widget_show (label22);
   gtk_notebook_set_tab_label (GTK_NOTEBOOK (notebook1), gtk_notebook_get_nth_page (GTK_NOTEBOOK (notebook1), 2), label22);
 
-#ifdef HAVE_AUDIO
   table1 = gtk_table_new (4, 3, FALSE);
   gtk_widget_show (table1);
   gtk_container_add (GTK_CONTAINER (notebook1), table1);
@@ -555,9 +584,6 @@
   gtk_table_attach (GTK_TABLE (table1), entryALSADevice, 1, 3, 1, 2,
                     (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
                     (GtkAttachOptions) (0), 0, 0);
-#ifndef ALSA_SUPPORT
-gtk_widget_set_sensitive(entryALSADevice, 0);
-#endif
 
   radiobuttonMaster = gtk_radio_button_new_with_mnemonic (NULL, _("_Master"));
   gtk_widget_show (radiobuttonMaster);
@@ -595,10 +621,8 @@
                     (GtkAttachOptions) (GTK_FILL),
                     (GtkAttachOptions) (GTK_FILL), 0, 0);
   gtk_combo_box_append_text (GTK_COMBO_BOX (comboboxDownMix), _("No downmixing (multichannel)"));
-  gtk_combo_box_append_text (GTK_COMBO_BOX (comboboxDownMix), _("Stereo"));
   gtk_combo_box_append_text (GTK_COMBO_BOX (comboboxDownMix), _("Dolby Prologic"));
   gtk_combo_box_append_text (GTK_COMBO_BOX (comboboxDownMix), _("Dolby Prologic 2"));
-#endif
 
   label25 = gtk_label_new (_("Audio"));
   gtk_widget_show (label25);
@@ -621,16 +645,10 @@
   gtk_widget_show (label16);
   gtk_box_pack_start (GTK_BOX (hbox5), label16, FALSE, FALSE, 0);
 
-    label24 = gtk_label_new (_("Video"));
-    gtk_widget_show (label24);
-#ifdef HAVE_AUDIO
-    gtk_notebook_set_tab_label (GTK_NOTEBOOK (notebook1), gtk_notebook_get_nth_page (GTK_NOTEBOOK (notebook1), 4), label24);
-#else
-    gtk_notebook_set_tab_label (GTK_NOTEBOOK (notebook1), gtk_notebook_get_nth_page (GTK_NOTEBOOK (notebook1), 3), label24);
-#endif
   comboboxVideoOutput = gtk_combo_box_new_text ();
   gtk_widget_show (comboboxVideoOutput);
   gtk_box_pack_start (GTK_BOX (hbox5), comboboxVideoOutput, TRUE, TRUE, 0);
+
   label24 = gtk_label_new (_("Video"));
   gtk_widget_show (label24);
   gtk_notebook_set_tab_label (GTK_NOTEBOOK (notebook1), gtk_notebook_get_nth_page (GTK_NOTEBOOK (notebook1), 4), label24);
@@ -649,13 +667,6 @@
   gtk_box_pack_start (GTK_BOX (hbox6), spinbuttonThread, FALSE, TRUE, 0);
   gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (spinbuttonThread), TRUE);
 
-    label26 = gtk_label_new (_("MultiThread"));
-    gtk_widget_show (label26);
-#ifdef HAVE_AUDIO
-    gtk_notebook_set_tab_label (GTK_NOTEBOOK (notebook1), gtk_notebook_get_nth_page (GTK_NOTEBOOK (notebook1), 5), label26);
-#else
-    gtk_notebook_set_tab_label (GTK_NOTEBOOK (notebook1), gtk_notebook_get_nth_page (GTK_NOTEBOOK (notebook1), 4), label26);
-#endif
   label28 = gtk_label_new (_("Threads"));
   gtk_widget_show (label28);
   gtk_box_pack_start (GTK_BOX (hbox6), label28, FALSE, FALSE, 0);
@@ -664,72 +675,65 @@
   gtk_widget_show (label26);
   gtk_notebook_set_tab_label (GTK_NOTEBOOK (notebook1), gtk_notebook_get_nth_page (GTK_NOTEBOOK (notebook1), 5), label26);
 
+  table3 = gtk_table_new (2, 2, FALSE);
+  gtk_widget_show (table3);
+  gtk_container_add (GTK_CONTAINER (notebook1), table3);
+
+  label31 = gtk_label_new (_("Load external filters"));
+  gtk_widget_show (label31);
+  gtk_table_attach (GTK_TABLE (table3), label31, 0, 1, 0, 1,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  gtk_misc_set_alignment (GTK_MISC (label31), 0, 0.5);
+
+  checkbuttonXfilter = gtk_check_button_new_with_mnemonic ("");
+  gtk_widget_show (checkbuttonXfilter);
+  gtk_table_attach (GTK_TABLE (table3), checkbuttonXfilter, 1, 2, 0, 1,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+
+  label32 = gtk_label_new (_("Path to external filters"));
+  gtk_widget_show (label32);
+  gtk_table_attach (GTK_TABLE (table3), label32, 0, 1, 1, 2,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  gtk_misc_set_alignment (GTK_MISC (label32), 0, 0.5);
+
+  hbox7 = gtk_hbox_new (FALSE, 0);
+  gtk_widget_show (hbox7);
+  gtk_table_attach (GTK_TABLE (table3), hbox7, 1, 2, 1, 2,
+                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                    (GtkAttachOptions) (GTK_FILL), 0, 0);
+
+  entryXfilter = gtk_entry_new ();
+  gtk_widget_show (entryXfilter);
+  gtk_box_pack_start (GTK_BOX (hbox7), entryXfilter, TRUE, TRUE, 0);
+
+  buttonXfilter = gtk_button_new ();
+  gtk_widget_show (buttonXfilter);
+  gtk_box_pack_start (GTK_BOX (hbox7), buttonXfilter, FALSE, FALSE, 0);
+
+  image1 = gtk_image_new_from_stock ("gtk-open", GTK_ICON_SIZE_BUTTON);
+  gtk_widget_show (image1);
+  gtk_container_add (GTK_CONTAINER (buttonXfilter), image1);
+
+  label30 = gtk_label_new (_("External filter"));
+  gtk_widget_show (label30);
+  gtk_notebook_set_tab_label (GTK_NOTEBOOK (notebook1), gtk_notebook_get_nth_page (GTK_NOTEBOOK (notebook1), 6), label30);
+
   dialog_action_area1 = GTK_DIALOG (Preferences)->action_area;
   gtk_widget_show (dialog_action_area1);
   gtk_button_box_set_layout (GTK_BUTTON_BOX (dialog_action_area1), GTK_BUTTONBOX_END);
 
-    gtk_label_set_mnemonic_widget (GTK_LABEL (label13), spinbuttonMPEGSplit);
-#ifdef HAVE_AUDIO
-    gtk_label_set_mnemonic_widget (GTK_LABEL (label19), entryALSADevice);
-    gtk_label_set_mnemonic_widget (GTK_LABEL (label20), radiobuttonPCM);
-#endif
   okbutton1 = gtk_button_new_from_stock ("gtk-close");
   gtk_widget_show (okbutton1);
   gtk_dialog_add_action_widget (GTK_DIALOG (Preferences), okbutton1, GTK_RESPONSE_CLOSE);
   GTK_WIDGET_SET_FLAGS (okbutton1, GTK_CAN_DEFAULT);
 
-    /* Store pointers to all widgets, for use by lookup_widget(). */
-    GLADE_HOOKUP_OBJECT_NO_REF (Preferences, Preferences, "Preferences");
-    GLADE_HOOKUP_OBJECT_NO_REF (Preferences, dialog_vbox1, "dialog_vbox1");
-    GLADE_HOOKUP_OBJECT (Preferences, notebook1, "notebook1");
-    GLADE_HOOKUP_OBJECT (Preferences, vbox12, "vbox12");
-    GLADE_HOOKUP_OBJECT (Preferences, hbox3, "hbox3");
-    GLADE_HOOKUP_OBJECT (Preferences, label11, "label11");
-    GLADE_HOOKUP_OBJECT (Preferences, comboboxMessageLevel, "comboboxMessageLevel");
-    GLADE_HOOKUP_OBJECT (Preferences, checkbuttonSwapAB, "checkbuttonSwapAB");
-    GLADE_HOOKUP_OBJECT (Preferences, checkbuttonSystray, "checkbuttonSystray");
-    GLADE_HOOKUP_OBJECT (Preferences, checkbuttonSavePrefs, "checkbuttonSavePrefs");
-    GLADE_HOOKUP_OBJECT (Preferences, label21, "label21");
-    GLADE_HOOKUP_OBJECT (Preferences, vbox16, "vbox16");
-    GLADE_HOOKUP_OBJECT (Preferences, checkbuttonAutoindex, "checkbuttonAutoindex");
-    GLADE_HOOKUP_OBJECT (Preferences, checkbuttonNuvResync, "checkbuttonNuvResync");
-    GLADE_HOOKUP_OBJECT (Preferences, checkbuttonLibavcodec, "checkbuttonLibavcodec");
-    GLADE_HOOKUP_OBJECT (Preferences, buttonPostprocLevel, "buttonPostprocLevel");
-    GLADE_HOOKUP_OBJECT (Preferences, label23, "label23");
-    GLADE_HOOKUP_OBJECT (Preferences, vbox14, "vbox14");
-    GLADE_HOOKUP_OBJECT (Preferences, hbox4, "hbox4");
-    GLADE_HOOKUP_OBJECT (Preferences, label13, "label13");
-    GLADE_HOOKUP_OBJECT (Preferences, spinbuttonMPEGSplit, "spinbuttonMPEGSplit");
-    GLADE_HOOKUP_OBJECT (Preferences, checkbuttonOpenDML, "checkbuttonOpenDML");
-    GLADE_HOOKUP_OBJECT (Preferences, checkbuttonReuseLog, "checkbuttonReuseLog");
-    GLADE_HOOKUP_OBJECT (Preferences, label22, "label22");
-#ifdef HAVE_AUDIO
-    GLADE_HOOKUP_OBJECT (Preferences, table1, "table1");
-    GLADE_HOOKUP_OBJECT (Preferences, label18, "label18");
-    GLADE_HOOKUP_OBJECT (Preferences, label19, "label19");
-    GLADE_HOOKUP_OBJECT (Preferences, comboboxAudioOutput, "comboboxAudioOutput");
-    GLADE_HOOKUP_OBJECT (Preferences, entryALSADevice, "entryALSADevice");
-    GLADE_HOOKUP_OBJECT (Preferences, radiobuttonMaster, "radiobuttonMaster");
-    GLADE_HOOKUP_OBJECT (Preferences, radiobuttonPCM, "radiobuttonPCM");
-    GLADE_HOOKUP_OBJECT (Preferences, label20, "label20");
-    GLADE_HOOKUP_OBJECT (Preferences, label29, "label29");
-    GLADE_HOOKUP_OBJECT (Preferences, comboboxDownMix, "comboboxDownMix");
-    GLADE_HOOKUP_OBJECT (Preferences, label25, "label25");
-#endif
-    GLADE_HOOKUP_OBJECT (Preferences, table2, "table2");
-    GLADE_HOOKUP_OBJECT (Preferences, hbox5, "hbox5");
-    GLADE_HOOKUP_OBJECT (Preferences, label16, "label16");
-    GLADE_HOOKUP_OBJECT (Preferences, comboboxVideoOutput, "comboboxVideoOutput");
-    GLADE_HOOKUP_OBJECT (Preferences, label24, "label24");
-    GLADE_HOOKUP_OBJECT (Preferences, hbox6, "hbox6");
-    GLADE_HOOKUP_OBJECT (Preferences, label27, "label27");
-    GLADE_HOOKUP_OBJECT (Preferences, spinbuttonThread, "spinbuttonThread");
-    GLADE_HOOKUP_OBJECT (Preferences, label28, "label28");
-    GLADE_HOOKUP_OBJECT (Preferences, label26, "label26");
-    GLADE_HOOKUP_OBJECT_NO_REF (Preferences, dialog_action_area1, "dialog_action_area1");
-    GLADE_HOOKUP_OBJECT (Preferences, okbutton1, "okbutton1");
+  gtk_label_set_mnemonic_widget (GTK_LABEL (label13), spinbuttonMPEGSplit);
+  gtk_label_set_mnemonic_widget (GTK_LABEL (label19), entryALSADevice);
+  gtk_label_set_mnemonic_widget (GTK_LABEL (label20), radiobuttonPCM);
 
-
   /* Store pointers to all widgets, for use by lookup_widget(). */
   GLADE_HOOKUP_OBJECT_NO_REF (Preferences, Preferences, "Preferences");
   GLADE_HOOKUP_OBJECT_NO_REF (Preferences, dialog_vbox1, "dialog_vbox1");
@@ -777,6 +781,15 @@
   GLADE_HOOKUP_OBJECT (Preferences, spinbuttonThread, "spinbuttonThread");
   GLADE_HOOKUP_OBJECT (Preferences, label28, "label28");
   GLADE_HOOKUP_OBJECT (Preferences, label26, "label26");
+  GLADE_HOOKUP_OBJECT (Preferences, table3, "table3");
+  GLADE_HOOKUP_OBJECT (Preferences, label31, "label31");
+  GLADE_HOOKUP_OBJECT (Preferences, checkbuttonXfilter, "checkbuttonXfilter");
+  GLADE_HOOKUP_OBJECT (Preferences, label32, "label32");
+  GLADE_HOOKUP_OBJECT (Preferences, hbox7, "hbox7");
+  GLADE_HOOKUP_OBJECT (Preferences, entryXfilter, "entryXfilter");
+  GLADE_HOOKUP_OBJECT (Preferences, buttonXfilter, "buttonXfilter");
+  GLADE_HOOKUP_OBJECT (Preferences, image1, "image1");
+  GLADE_HOOKUP_OBJECT (Preferences, label30, "label30");
   GLADE_HOOKUP_OBJECT_NO_REF (Preferences, dialog_action_area1, "dialog_action_area1");
   GLADE_HOOKUP_OBJECT (Preferences, okbutton1, "okbutton1");
 



From mean at mail.berlios.de  Wed Jan 17 08:02:31 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 17 Jan 2007 08:02:31 +0100
Subject: [Avidemux-svn-commit] r2741 -
	branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/glade
Message-ID: <200701170702.l0H72VYg019605@sheep.berlios.de>

Author: mean
Date: 2007-01-17 08:02:28 +0100 (Wed, 17 Jan 2007)
New Revision: 2741

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/glade/project_x264.glade
Log:
oops

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/glade/project_x264.glade
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/glade/project_x264.glade	2007-01-16 19:23:12 UTC (rev 2740)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/glade/project_x264.glade	2007-01-17 07:02:28 UTC (rev 2741)
@@ -5,12 +5,19 @@
 
 <widget class="GtkDialog" id="dialog1">
   <property name="visible">True</property>
-  <property name="title" translatable="yes">X264 Settings</property>
+  <property name="title" translatable="yes">X264 configuration</property>
   <property name="type">GTK_WINDOW_TOPLEVEL</property>
   <property name="window_position">GTK_WIN_POS_NONE</property>
   <property name="modal">False</property>
   <property name="resizable">True</property>
   <property name="destroy_with_parent">False</property>
+  <property name="decorated">True</property>
+  <property name="skip_taskbar_hint">False</property>
+  <property name="skip_pager_hint">False</property>
+  <property name="type_hint">GDK_WINDOW_TYPE_HINT_DIALOG</property>
+  <property name="gravity">GDK_GRAVITY_NORTH_WEST</property>
+  <property name="focus_on_map">True</property>
+  <property name="urgency_hint">False</property>
   <property name="has_separator">True</property>
 
   <child internal-child="vbox">
@@ -32,6 +39,7 @@
 	      <property name="label">gtk-cancel</property>
 	      <property name="use_stock">True</property>
 	      <property name="relief">GTK_RELIEF_NORMAL</property>
+	      <property name="focus_on_click">True</property>
 	      <property name="response_id">-6</property>
 	    </widget>
 	  </child>
@@ -44,6 +52,7 @@
 	      <property name="label">gtk-ok</property>
 	      <property name="use_stock">True</property>
 	      <property name="relief">GTK_RELIEF_NORMAL</property>
+	      <property name="focus_on_click">True</property>
 	      <property name="response_id">-5</property>
 	    </widget>
 	  </child>
@@ -57,517 +66,2299 @@
       </child>
 
       <child>
-	<widget class="GtkVBox" id="vbox1">
+	<widget class="GtkNotebook" id="notebook1">
 	  <property name="visible">True</property>
-	  <property name="homogeneous">False</property>
-	  <property name="spacing">0</property>
+	  <property name="can_focus">True</property>
+	  <property name="show_tabs">True</property>
+	  <property name="show_border">True</property>
+	  <property name="tab_pos">GTK_POS_TOP</property>
+	  <property name="scrollable">False</property>
+	  <property name="enable_popup">False</property>
 
 	  <child>
-	    <widget class="GtkFrame" id="frame1">
+	    <widget class="GtkTable" id="tableBitrate">
 	      <property name="visible">True</property>
-	      <property name="label_xalign">0</property>
-	      <property name="label_yalign">0.5</property>
-	      <property name="shadow_type">GTK_SHADOW_ETCHED_IN</property>
+	      <property name="n_rows">4</property>
+	      <property name="n_columns">2</property>
+	      <property name="homogeneous">False</property>
+	      <property name="row_spacing">2</property>
+	      <property name="column_spacing">0</property>
 
 	      <child>
-		<widget class="GtkTable" id="table1">
+		<widget class="GtkLabel" id="labelEncodingMode">
 		  <property name="visible">True</property>
-		  <property name="n_rows">3</property>
-		  <property name="n_columns">2</property>
-		  <property name="homogeneous">False</property>
-		  <property name="row_spacing">0</property>
-		  <property name="column_spacing">0</property>
+		  <property name="label" translatable="yes">Encoding Mode:</property>
+		  <property name="use_underline">False</property>
+		  <property name="use_markup">False</property>
+		  <property name="justify">GTK_JUSTIFY_LEFT</property>
+		  <property name="wrap">False</property>
+		  <property name="selectable">False</property>
+		  <property name="xalign">0</property>
+		  <property name="yalign">0.5</property>
+		  <property name="xpad">0</property>
+		  <property name="ypad">0</property>
+		  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		  <property name="width_chars">-1</property>
+		  <property name="single_line_mode">False</property>
+		  <property name="angle">0</property>
+		</widget>
+		<packing>
+		  <property name="left_attach">0</property>
+		  <property name="right_attach">1</property>
+		  <property name="top_attach">0</property>
+		  <property name="bottom_attach">1</property>
+		  <property name="x_padding">5</property>
+		  <property name="y_padding">1</property>
+		  <property name="x_options">fill</property>
+		  <property name="y_options"></property>
+		</packing>
+	      </child>
 
+	      <child>
+		<widget class="GtkEntry" id="entryTarget">
+		  <property name="visible">True</property>
+		  <property name="tooltip" translatable="yes">Entry input for target file size or bitrate</property>
+		  <property name="can_focus">True</property>
+		  <property name="editable">True</property>
+		  <property name="visibility">True</property>
+		  <property name="max_length">0</property>
+		  <property name="text" translatable="yes"></property>
+		  <property name="has_frame">True</property>
+		  <property name="invisible_char">*</property>
+		  <property name="activates_default">False</property>
+		</widget>
+		<packing>
+		  <property name="left_attach">1</property>
+		  <property name="right_attach">2</property>
+		  <property name="top_attach">1</property>
+		  <property name="bottom_attach">2</property>
+		  <property name="x_padding">2</property>
+		  <property name="y_options"></property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkLabel" id="labelQuantizer">
+		  <property name="visible">True</property>
+		  <property name="label" translatable="yes">Quantizer (0-51):</property>
+		  <property name="use_underline">False</property>
+		  <property name="use_markup">False</property>
+		  <property name="justify">GTK_JUSTIFY_LEFT</property>
+		  <property name="wrap">False</property>
+		  <property name="selectable">False</property>
+		  <property name="xalign">0</property>
+		  <property name="yalign">0.5</property>
+		  <property name="xpad">0</property>
+		  <property name="ypad">0</property>
+		  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		  <property name="width_chars">-1</property>
+		  <property name="single_line_mode">False</property>
+		  <property name="angle">0</property>
+		</widget>
+		<packing>
+		  <property name="left_attach">0</property>
+		  <property name="right_attach">1</property>
+		  <property name="top_attach">2</property>
+		  <property name="bottom_attach">3</property>
+		  <property name="x_padding">5</property>
+		  <property name="y_padding">1</property>
+		  <property name="x_options">fill</property>
+		  <property name="y_options"></property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkSpinButton" id="spinbuttonQuantizer">
+		  <property name="visible">True</property>
+		  <property name="tooltip" translatable="yes">Constant Quantizer - Each frame will the same compression. Low numbers equal higher quality while high numbers equal lower quality</property>
+		  <property name="can_focus">True</property>
+		  <property name="climb_rate">1</property>
+		  <property name="digits">0</property>
+		  <property name="numeric">True</property>
+		  <property name="update_policy">GTK_UPDATE_ALWAYS</property>
+		  <property name="snap_to_ticks">False</property>
+		  <property name="wrap">False</property>
+		  <property name="adjustment">4 0 51 1 10 10</property>
+		</widget>
+		<packing>
+		  <property name="left_attach">1</property>
+		  <property name="right_attach">2</property>
+		  <property name="top_attach">2</property>
+		  <property name="bottom_attach">3</property>
+		  <property name="x_padding">1</property>
+		  <property name="y_options"></property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkHButtonBox" id="hbuttonbox1">
+		  <property name="visible">True</property>
+		  <property name="layout_style">GTK_BUTTONBOX_SPREAD</property>
+		  <property name="spacing">0</property>
+
 		  <child>
-		    <widget class="GtkOptionMenu" id="optionmenu1">
+		    <widget class="GtkButton" id="buttonLoadDefaults">
 		      <property name="visible">True</property>
+		      <property name="tooltip" translatable="yes">Load the stored default settings for the codec</property>
+		      <property name="can_default">True</property>
 		      <property name="can_focus">True</property>
-		      <property name="history">0</property>
+		      <property name="label" translatable="yes">Load Defaults</property>
+		      <property name="use_underline">True</property>
+		      <property name="relief">GTK_RELIEF_NORMAL</property>
+		      <property name="focus_on_click">True</property>
+		    </widget>
+		  </child>
 
+		  <child>
+		    <widget class="GtkButton" id="buttonSaveDefaults">
+		      <property name="visible">True</property>
+		      <property name="tooltip" translatable="yes">Save the current codec configuration as the stored default settings</property>
+		      <property name="can_default">True</property>
+		      <property name="can_focus">True</property>
+		      <property name="label" translatable="yes">Save Defaults</property>
+		      <property name="use_underline">True</property>
+		      <property name="relief">GTK_RELIEF_NORMAL</property>
+		      <property name="focus_on_click">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkButton" id="buttonResetDefaults">
+		      <property name="visible">True</property>
+		      <property name="tooltip" translatable="yes">Reload the initial default codec settings</property>
+		      <property name="can_default">True</property>
+		      <property name="can_focus">True</property>
+		      <property name="label" translatable="yes">Reset Defaults</property>
+		      <property name="use_underline">True</property>
+		      <property name="relief">GTK_RELIEF_NORMAL</property>
+		      <property name="focus_on_click">True</property>
+		    </widget>
+		  </child>
+		</widget>
+		<packing>
+		  <property name="left_attach">0</property>
+		  <property name="right_attach">2</property>
+		  <property name="top_attach">3</property>
+		  <property name="bottom_attach">4</property>
+		  <property name="x_padding">40</property>
+		  <property name="y_padding">65</property>
+		  <property name="x_options">fill</property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkLabel" id="labelTarget">
+		  <property name="visible">True</property>
+		  <property name="label" translatable="yes">Target Size:</property>
+		  <property name="use_underline">False</property>
+		  <property name="use_markup">False</property>
+		  <property name="justify">GTK_JUSTIFY_LEFT</property>
+		  <property name="wrap">False</property>
+		  <property name="selectable">False</property>
+		  <property name="xalign">0</property>
+		  <property name="yalign">0.5</property>
+		  <property name="xpad">0</property>
+		  <property name="ypad">0</property>
+		  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		  <property name="width_chars">-1</property>
+		  <property name="single_line_mode">False</property>
+		  <property name="angle">0</property>
+		</widget>
+		<packing>
+		  <property name="left_attach">0</property>
+		  <property name="right_attach">1</property>
+		  <property name="top_attach">1</property>
+		  <property name="bottom_attach">2</property>
+		  <property name="x_padding">5</property>
+		  <property name="x_options">fill</property>
+		  <property name="y_options"></property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkComboBox" id="comboboxMode">
+		  <property name="visible">True</property>
+		  <property name="items" translatable="yes">Single Pass - Quality Quantizer (Constant)
+Single Pass - Bitrate (Average)
+Two Pass - File Size
+Two Pass - Average bitrate</property>
+		  <property name="add_tearoffs">False</property>
+		  <property name="focus_on_click">True</property>
+		</widget>
+		<packing>
+		  <property name="left_attach">1</property>
+		  <property name="right_attach">2</property>
+		  <property name="top_attach">0</property>
+		  <property name="bottom_attach">1</property>
+		  <property name="y_options">fill</property>
+		</packing>
+	      </child>
+	    </widget>
+	    <packing>
+	      <property name="tab_expand">False</property>
+	      <property name="tab_fill">True</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkLabel" id="labelPageBitrate">
+	      <property name="visible">True</property>
+	      <property name="label" translatable="yes">Bitrate</property>
+	      <property name="use_underline">False</property>
+	      <property name="use_markup">False</property>
+	      <property name="justify">GTK_JUSTIFY_LEFT</property>
+	      <property name="wrap">False</property>
+	      <property name="selectable">False</property>
+	      <property name="xalign">0</property>
+	      <property name="yalign">0.5</property>
+	      <property name="xpad">0</property>
+	      <property name="ypad">0</property>
+	      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+	      <property name="width_chars">-1</property>
+	      <property name="single_line_mode">False</property>
+	      <property name="angle">0</property>
+	    </widget>
+	    <packing>
+	      <property name="type">tab</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkVBox" id="vbox5">
+	      <property name="visible">True</property>
+	      <property name="homogeneous">False</property>
+	      <property name="spacing">0</property>
+
+	      <child>
+		<widget class="GtkFrame" id="frame6">
+		  <property name="visible">True</property>
+		  <property name="label_xalign">0</property>
+		  <property name="label_yalign">0.5</property>
+		  <property name="shadow_type">GTK_SHADOW_ETCHED_IN</property>
+
+		  <child>
+		    <widget class="GtkAlignment" id="alignment6">
+		      <property name="visible">True</property>
+		      <property name="xalign">0.5</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xscale">1</property>
+		      <property name="yscale">1</property>
+		      <property name="top_padding">0</property>
+		      <property name="bottom_padding">0</property>
+		      <property name="left_padding">12</property>
+		      <property name="right_padding">0</property>
+
 		      <child>
-			<widget class="GtkMenu" id="menu1">
+			<widget class="GtkVBox" id="vbox6">
+			  <property name="visible">True</property>
+			  <property name="homogeneous">False</property>
+			  <property name="spacing">0</property>
 
 			  <child>
-			    <widget class="GtkMenuItem" id="constant_quantizer1">
+			    <widget class="GtkTable" id="table7">
 			      <property name="visible">True</property>
-			      <property name="label" translatable="yes">Constant Quantizer</property>
-			      <property name="use_underline">True</property>
+			      <property name="n_rows">2</property>
+			      <property name="n_columns">3</property>
+			      <property name="homogeneous">False</property>
+			      <property name="row_spacing">0</property>
+			      <property name="column_spacing">0</property>
+
+			      <child>
+				<widget class="GtkLabel" id="labelPartitionDecision">
+				  <property name="visible">True</property>
+				  <property name="label" translatable="yes">Partition decision</property>
+				  <property name="use_underline">False</property>
+				  <property name="use_markup">False</property>
+				  <property name="justify">GTK_JUSTIFY_LEFT</property>
+				  <property name="wrap">False</property>
+				  <property name="selectable">False</property>
+				  <property name="xalign">0</property>
+				  <property name="yalign">0.5</property>
+				  <property name="xpad">0</property>
+				  <property name="ypad">0</property>
+				  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+				  <property name="width_chars">-1</property>
+				  <property name="single_line_mode">False</property>
+				  <property name="angle">0</property>
+				</widget>
+				<packing>
+				  <property name="left_attach">0</property>
+				  <property name="right_attach">1</property>
+				  <property name="top_attach">0</property>
+				  <property name="bottom_attach">1</property>
+				  <property name="x_padding">5</property>
+				  <property name="y_padding">1</property>
+				  <property name="x_options">fill</property>
+				  <property name="y_options"></property>
+				</packing>
+			      </child>
+
+			      <child>
+				<widget class="GtkLabel" id="labelMethod">
+				  <property name="visible">True</property>
+				  <property name="label" translatable="yes">Method</property>
+				  <property name="use_underline">False</property>
+				  <property name="use_markup">False</property>
+				  <property name="justify">GTK_JUSTIFY_LEFT</property>
+				  <property name="wrap">False</property>
+				  <property name="selectable">False</property>
+				  <property name="xalign">0</property>
+				  <property name="yalign">0.5</property>
+				  <property name="xpad">0</property>
+				  <property name="ypad">0</property>
+				  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+				  <property name="width_chars">-1</property>
+				  <property name="single_line_mode">False</property>
+				  <property name="angle">0</property>
+				</widget>
+				<packing>
+				  <property name="left_attach">0</property>
+				  <property name="right_attach">1</property>
+				  <property name="top_attach">1</property>
+				  <property name="bottom_attach">2</property>
+				  <property name="x_padding">5</property>
+				  <property name="y_padding">1</property>
+				  <property name="x_options">fill</property>
+				  <property name="y_options"></property>
+				</packing>
+			      </child>
+
+			      <child>
+				<widget class="GtkComboBox" id="comboboxPartitionDecision">
+				  <property name="visible">True</property>
+				  <property name="items" translatable="yes">1  - Extremely Low (Fastest)
+2  - Very Low
+3  - Low
+4  - Medium
+5  - High (Default)
+6  - Very High
+6B - Very High (RDO on Bframes)
+7 - Ultra High
+7B - Ultra High (RDO on Bframes)
+</property>
+				  <property name="add_tearoffs">False</property>
+				  <property name="focus_on_click">True</property>
+				</widget>
+				<packing>
+				  <property name="left_attach">1</property>
+				  <property name="right_attach">3</property>
+				  <property name="top_attach">0</property>
+				  <property name="bottom_attach">1</property>
+				  <property name="x_padding">1</property>
+				  <property name="x_options">shrink|fill</property>
+				  <property name="y_options">shrink|fill</property>
+				</packing>
+			      </child>
+
+			      <child>
+				<widget class="GtkComboBox" id="comboboxMethod">
+				  <property name="visible">True</property>
+				  <property name="items" translatable="yes">Diamond search
+Hexagonal search
+Uneven multi hexagon
+Exhaustive search</property>
+				  <property name="add_tearoffs">False</property>
+				  <property name="focus_on_click">True</property>
+				</widget>
+				<packing>
+				  <property name="left_attach">1</property>
+				  <property name="right_attach">3</property>
+				  <property name="top_attach">1</property>
+				  <property name="bottom_attach">2</property>
+				  <property name="x_padding">1</property>
+				  <property name="x_options">fill</property>
+				  <property name="y_options">fill</property>
+				</packing>
+			      </child>
 			    </widget>
+			    <packing>
+			      <property name="padding">0</property>
+			      <property name="expand">False</property>
+			      <property name="fill">True</property>
+			    </packing>
 			  </child>
 
 			  <child>
-			    <widget class="GtkMenuItem" id="constant_bitrate1">
+			    <widget class="GtkTable" id="table11">
 			      <property name="visible">True</property>
-			      <property name="label" translatable="yes">Constant Bitrate</property>
-			      <property name="use_underline">True</property>
-			    </widget>
-			  </child>
+			      <property name="n_rows">2</property>
+			      <property name="n_columns">3</property>
+			      <property name="homogeneous">False</property>
+			      <property name="row_spacing">0</property>
+			      <property name="column_spacing">0</property>
 
-			  <child>
-			    <widget class="GtkMenuItem" id="2_pass_average_bitrate1">
-			      <property name="visible">True</property>
-			      <property name="label" translatable="yes">2 pass Average Bitrate</property>
-			      <property name="use_underline">True</property>
+			      <child>
+				<widget class="GtkSpinButton" id="spinbuttonMaxRefFrames">
+				  <property name="visible">True</property>
+				  <property name="tooltip" translatable="yes">Set how many previous frames can be referenced by a P/B-frame. Numbers above 5 do not seem to improve quality greatly. Numbers are 3 to 5 are recommended</property>
+				  <property name="can_focus">True</property>
+				  <property name="climb_rate">1</property>
+				  <property name="digits">0</property>
+				  <property name="numeric">True</property>
+				  <property name="update_policy">GTK_UPDATE_ALWAYS</property>
+				  <property name="snap_to_ticks">False</property>
+				  <property name="wrap">False</property>
+				  <property name="adjustment">1 0 16 1 10 10</property>
+				</widget>
+				<packing>
+				  <property name="left_attach">1</property>
+				  <property name="right_attach">2</property>
+				  <property name="top_attach">1</property>
+				  <property name="bottom_attach">2</property>
+				  <property name="y_options"></property>
+				</packing>
+			      </child>
+
+			      <child>
+				<widget class="GtkLabel" id="labelMaxRefFrames">
+				  <property name="visible">True</property>
+				  <property name="label" translatable="yes">Max. Ref. frames</property>
+				  <property name="use_underline">False</property>
+				  <property name="use_markup">False</property>
+				  <property name="justify">GTK_JUSTIFY_LEFT</property>
+				  <property name="wrap">False</property>
+				  <property name="selectable">False</property>
+				  <property name="xalign">0</property>
+				  <property name="yalign">0.5</property>
+				  <property name="xpad">0</property>
+				  <property name="ypad">0</property>
+				  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+				  <property name="width_chars">-1</property>
+				  <property name="single_line_mode">False</property>
+				  <property name="angle">0</property>
+				</widget>
+				<packing>
+				  <property name="left_attach">0</property>
+				  <property name="right_attach">1</property>
+				  <property name="top_attach">1</property>
+				  <property name="bottom_attach">2</property>
+				  <property name="x_padding">7</property>
+				  <property name="x_options">fill</property>
+				  <property name="y_options"></property>
+				</packing>
+			      </child>
+
+			      <child>
+				<widget class="GtkLabel" id="labelRange">
+				  <property name="visible">True</property>
+				  <property name="label" translatable="yes">Range</property>
+				  <property name="use_underline">False</property>
+				  <property name="use_markup">False</property>
+				  <property name="justify">GTK_JUSTIFY_LEFT</property>
+				  <property name="wrap">False</property>
+				  <property name="selectable">False</property>
+				  <property name="xalign">0</property>
+				  <property name="yalign">0.5</property>
+				  <property name="xpad">0</property>
+				  <property name="ypad">0</property>
+				  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+				  <property name="width_chars">-1</property>
+				  <property name="single_line_mode">False</property>
+				  <property name="angle">0</property>
+				</widget>
+				<packing>
+				  <property name="left_attach">0</property>
+				  <property name="right_attach">1</property>
+				  <property name="top_attach">0</property>
+				  <property name="bottom_attach">1</property>
+				  <property name="x_padding">7</property>
+				  <property name="x_options">fill</property>
+				  <property name="y_options"></property>
+				</packing>
+			      </child>
+
+			      <child>
+				<widget class="GtkCheckButton" id="checkbuttonChromaME">
+				  <property name="visible">True</property>
+				  <property name="tooltip" translatable="yes">Uses chroma (color) components for motion for compression and helps the quality</property>
+				  <property name="can_focus">True</property>
+				  <property name="label" translatable="yes">Chroma ME</property>
+				  <property name="use_underline">True</property>
+				  <property name="relief">GTK_RELIEF_NORMAL</property>
+				  <property name="focus_on_click">True</property>
+				  <property name="active">True</property>
+				  <property name="inconsistent">False</property>
+				  <property name="draw_indicator">True</property>
+				</widget>
+				<packing>
+				  <property name="left_attach">2</property>
+				  <property name="right_attach">3</property>
+				  <property name="top_attach">0</property>
+				  <property name="bottom_attach">1</property>
+				  <property name="x_padding">15</property>
+				  <property name="x_options">fill</property>
+				  <property name="y_options"></property>
+				</packing>
+			      </child>
+
+			      <child>
+				<widget class="GtkCheckButton" id="checkbuttonMixedRefs">
+				  <property name="visible">True</property>
+				  <property name="tooltip" translatable="yes">Calculate referencing individually based on each partition</property>
+				  <property name="can_focus">True</property>
+				  <property name="label" translatable="yes">Mixed Refs</property>
+				  <property name="use_underline">True</property>
+				  <property name="relief">GTK_RELIEF_NORMAL</property>
+				  <property name="focus_on_click">True</property>
+				  <property name="active">False</property>
+				  <property name="inconsistent">False</property>
+				  <property name="draw_indicator">True</property>
+				</widget>
+				<packing>
+				  <property name="left_attach">2</property>
+				  <property name="right_attach">3</property>
+				  <property name="top_attach">1</property>
+				  <property name="bottom_attach">2</property>
+				  <property name="x_padding">15</property>
+				  <property name="x_options">fill</property>
+				  <property name="y_options"></property>
+				</packing>
+			      </child>
+
+			      <child>
+				<widget class="GtkSpinButton" id="spinbuttonRange">
+				  <property name="visible">True</property>
+				  <property name="tooltip" translatable="yes">Define how many pixels are analysised. The higher the range the more accurate the analysis but the slower the encoding time</property>
+				  <property name="can_focus">True</property>
+				  <property name="climb_rate">1</property>
+				  <property name="digits">0</property>
+				  <property name="numeric">False</property>
+				  <property name="update_policy">GTK_UPDATE_ALWAYS</property>
+				  <property name="snap_to_ticks">False</property>
+				  <property name="wrap">False</property>
+				  <property name="adjustment">16 0 64 1 10 10</property>
+				</widget>
+				<packing>
+				  <property name="left_attach">1</property>
+				  <property name="right_attach">2</property>
+				  <property name="top_attach">0</property>
+				  <property name="bottom_attach">1</property>
+				  <property name="y_options"></property>
+				</packing>
+			      </child>
 			    </widget>
+			    <packing>
+			      <property name="padding">0</property>
+			      <property name="expand">True</property>
+			      <property name="fill">False</property>
+			    </packing>
 			  </child>
 			</widget>
 		      </child>
 		    </widget>
-		    <packing>
-		      <property name="left_attach">1</property>
-		      <property name="right_attach">2</property>
-		      <property name="top_attach">0</property>
-		      <property name="bottom_attach">1</property>
-		      <property name="x_options">fill</property>
-		      <property name="y_options"></property>
-		    </packing>
 		  </child>
 
 		  <child>
-		    <widget class="GtkLabel" id="label2">
+		    <widget class="GtkLabel" id="label24">
 		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Mode :</property>
+		      <property name="label" translatable="yes">&lt;b&gt;Motion Estimation&lt;/b&gt;</property>
 		      <property name="use_underline">False</property>
-		      <property name="use_markup">False</property>
+		      <property name="use_markup">True</property>
 		      <property name="justify">GTK_JUSTIFY_LEFT</property>
 		      <property name="wrap">False</property>
 		      <property name="selectable">False</property>
-		      <property name="xalign">0</property>
+		      <property name="xalign">0.5</property>
 		      <property name="yalign">0.5</property>
 		      <property name="xpad">0</property>
 		      <property name="ypad">0</property>
+		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		      <property name="width_chars">-1</property>
+		      <property name="single_line_mode">False</property>
+		      <property name="angle">0</property>
 		    </widget>
 		    <packing>
-		      <property name="left_attach">0</property>
-		      <property name="right_attach">1</property>
-		      <property name="top_attach">0</property>
-		      <property name="bottom_attach">1</property>
-		      <property name="y_options"></property>
+		      <property name="type">label_item</property>
 		    </packing>
 		  </child>
+		</widget>
+		<packing>
+		  <property name="padding">0</property>
+		  <property name="expand">True</property>
+		  <property name="fill">True</property>
+		</packing>
+	      </child>
 
+	      <child>
+		<widget class="GtkFrame" id="frame7">
+		  <property name="visible">True</property>
+		  <property name="label_xalign">0</property>
+		  <property name="label_yalign">0.5</property>
+		  <property name="shadow_type">GTK_SHADOW_ETCHED_IN</property>
+
 		  <child>
-		    <widget class="GtkLabel" id="label3">
+		    <widget class="GtkAlignment" id="alignment7">
 		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Quantizer :</property>
+		      <property name="xalign">0.5</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xscale">1</property>
+		      <property name="yscale">1</property>
+		      <property name="top_padding">0</property>
+		      <property name="bottom_padding">0</property>
+		      <property name="left_padding">12</property>
+		      <property name="right_padding">0</property>
+
+		      <child>
+			<widget class="GtkVBox" id="vbox7">
+			  <property name="visible">True</property>
+			  <property name="homogeneous">False</property>
+			  <property name="spacing">0</property>
+
+			  <child>
+			    <widget class="GtkHBox" id="hbox2">
+			      <property name="visible">True</property>
+			      <property name="homogeneous">False</property>
+			      <property name="spacing">0</property>
+
+			      <child>
+				<widget class="GtkLabel" id="labelSampleAR">
+				  <property name="visible">True</property>
+				  <property name="label" translatable="yes">Sample A/R </property>
+				  <property name="use_underline">False</property>
+				  <property name="use_markup">False</property>
+				  <property name="justify">GTK_JUSTIFY_LEFT</property>
+				  <property name="wrap">False</property>
+				  <property name="selectable">False</property>
+				  <property name="xalign">0.5</property>
+				  <property name="yalign">0.5</property>
+				  <property name="xpad">0</property>
+				  <property name="ypad">0</property>
+				  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+				  <property name="width_chars">-1</property>
+				  <property name="single_line_mode">False</property>
+				  <property name="angle">0</property>
+				</widget>
+				<packing>
+				  <property name="padding">0</property>
+				  <property name="expand">False</property>
+				  <property name="fill">False</property>
+				</packing>
+			      </child>
+
+			      <child>
+				<widget class="GtkEntry" id="entryAR_Num">
+				  <property name="visible">True</property>
+				  <property name="tooltip" translatable="yes">Enforce the size of a decoded pixel decoded to a certain value. Leave this at 1:1 for non-anamorphic video</property>
+				  <property name="can_focus">True</property>
+				  <property name="editable">True</property>
+				  <property name="visibility">True</property>
+				  <property name="max_length">0</property>
+				  <property name="text" translatable="yes">1</property>
+				  <property name="has_frame">True</property>
+				  <property name="invisible_char">*</property>
+				  <property name="activates_default">False</property>
+				</widget>
+				<packing>
+				  <property name="padding">0</property>
+				  <property name="expand">True</property>
+				  <property name="fill">True</property>
+				</packing>
+			      </child>
+
+			      <child>
+				<widget class="GtkLabel" id="label38">
+				  <property name="visible">True</property>
+				  <property name="label" translatable="yes">:</property>
+				  <property name="use_underline">False</property>
+				  <property name="use_markup">False</property>
+				  <property name="justify">GTK_JUSTIFY_CENTER</property>
+				  <property name="wrap">False</property>
+				  <property name="selectable">False</property>
+				  <property name="xalign">0.5</property>
+				  <property name="yalign">0.5</property>
+				  <property name="xpad">0</property>
+				  <property name="ypad">0</property>
+				  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+				  <property name="width_chars">-1</property>
+				  <property name="single_line_mode">False</property>
+				  <property name="angle">0</property>
+				</widget>
+				<packing>
+				  <property name="padding">2</property>
+				  <property name="expand">False</property>
+				  <property name="fill">False</property>
+				</packing>
+			      </child>
+
+			      <child>
+				<widget class="GtkEntry" id="entryAR_Den">
+				  <property name="visible">True</property>
+				  <property name="tooltip" translatable="yes">Enforce the size of a decoded pixel decoded to a certain value. Leave this at 1:1 for non-anamorphic video</property>
+				  <property name="can_focus">True</property>
+				  <property name="editable">True</property>
+				  <property name="visibility">True</property>
+				  <property name="max_length">0</property>
+				  <property name="text" translatable="yes">1</property>
+				  <property name="has_frame">True</property>
+				  <property name="invisible_char">*</property>
+				  <property name="activates_default">False</property>
+				</widget>
+				<packing>
+				  <property name="padding">0</property>
+				  <property name="expand">True</property>
+				  <property name="fill">True</property>
+				</packing>
+			      </child>
+			    </widget>
+			    <packing>
+			      <property name="padding">0</property>
+			      <property name="expand">True</property>
+			      <property name="fill">True</property>
+			    </packing>
+			  </child>
+
+			  <child>
+			    <widget class="GtkHBox" id="hbox3">
+			      <property name="visible">True</property>
+			      <property name="homogeneous">False</property>
+			      <property name="spacing">0</property>
+
+			      <child>
+				<widget class="GtkCheckButton" id="checkbuttonDeblockingFilter">
+				  <property name="visible">True</property>
+				  <property name="tooltip" translatable="yes">Enable in-loop deblocking to filter the video</property>
+				  <property name="can_focus">True</property>
+				  <property name="label" translatable="yes">Deblocking Filter :</property>
+				  <property name="use_underline">True</property>
+				  <property name="relief">GTK_RELIEF_NORMAL</property>
+				  <property name="focus_on_click">True</property>
+				  <property name="active">True</property>
+				  <property name="inconsistent">False</property>
+				  <property name="draw_indicator">True</property>
+				</widget>
+				<packing>
+				  <property name="padding">0</property>
+				  <property name="expand">False</property>
+				  <property name="fill">False</property>
+				</packing>
+			      </child>
+
+			      <child>
+				<widget class="GtkTable" id="table8">
+				  <property name="visible">True</property>
+				  <property name="n_rows">2</property>
+				  <property name="n_columns">2</property>
+				  <property name="homogeneous">False</property>
+				  <property name="row_spacing">0</property>
+				  <property name="column_spacing">0</property>
+
+				  <child>
+				    <widget class="GtkSpinButton" id="spinbuttonStrength">
+				      <property name="visible">True</property>
+				      <property name="tooltip" translatable="yes">Set the amount of blurring to use for block edges when they are found</property>
+				      <property name="can_focus">True</property>
+				      <property name="climb_rate">1</property>
+				      <property name="digits">0</property>
+				      <property name="numeric">True</property>
+				      <property name="update_policy">GTK_UPDATE_ALWAYS</property>
+				      <property name="snap_to_ticks">False</property>
+				      <property name="wrap">False</property>
+				      <property name="adjustment">0 -6 6 1 10 10</property>
+				    </widget>
+				    <packing>
+				      <property name="left_attach">1</property>
+				      <property name="right_attach">2</property>
+				      <property name="top_attach">0</property>
+				      <property name="bottom_attach">1</property>
+				      <property name="y_options"></property>
+				    </packing>
+				  </child>
+
+				  <child>
+				    <widget class="GtkSpinButton" id="spinbuttonThreshold">
+				      <property name="visible">True</property>
+				      <property name="tooltip" translatable="yes">Define the level for when deblocking is applied</property>
+				      <property name="can_focus">True</property>
+				      <property name="climb_rate">1</property>
+				      <property name="digits">0</property>
+				      <property name="numeric">True</property>
+				      <property name="update_policy">GTK_UPDATE_ALWAYS</property>
+				      <property name="snap_to_ticks">False</property>
+				      <property name="wrap">False</property>
+				      <property name="adjustment">0 -6 6 1 10 10</property>
+				    </widget>
+				    <packing>
+				      <property name="left_attach">1</property>
+				      <property name="right_attach">2</property>
+				      <property name="top_attach">1</property>
+				      <property name="bottom_attach">2</property>
+				      <property name="y_options"></property>
+				    </packing>
+				  </child>
+
+				  <child>
+				    <widget class="GtkLabel" id="labelThreshold">
+				      <property name="visible">True</property>
+				      <property name="label" translatable="yes">&lt;i&gt;Threshold&lt;/i&gt;</property>
+				      <property name="use_underline">False</property>
+				      <property name="use_markup">True</property>
+				      <property name="justify">GTK_JUSTIFY_LEFT</property>
+				      <property name="wrap">False</property>
+				      <property name="selectable">False</property>
+				      <property name="xalign">0</property>
+				      <property name="yalign">0.5</property>
+				      <property name="xpad">0</property>
+				      <property name="ypad">0</property>
+				      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+				      <property name="width_chars">-1</property>
+				      <property name="single_line_mode">False</property>
+				      <property name="angle">0</property>
+				    </widget>
+				    <packing>
+				      <property name="left_attach">0</property>
+				      <property name="right_attach">1</property>
+				      <property name="top_attach">1</property>
+				      <property name="bottom_attach">2</property>
+				      <property name="x_padding">5</property>
+				      <property name="x_options">fill</property>
+				      <property name="y_options"></property>
+				    </packing>
+				  </child>
+
+				  <child>
+				    <widget class="GtkLabel" id="labelStrength">
+				      <property name="visible">True</property>
+				      <property name="label" translatable="yes">&lt;i&gt;Strength&lt;/i&gt;</property>
+				      <property name="use_underline">False</property>
+				      <property name="use_markup">True</property>
+				      <property name="justify">GTK_JUSTIFY_LEFT</property>
+				      <property name="wrap">False</property>
+				      <property name="selectable">False</property>
+				      <property name="xalign">0</property>
+				      <property name="yalign">0.5</property>
+				      <property name="xpad">0</property>
+				      <property name="ypad">0</property>
+				      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+				      <property name="width_chars">-1</property>
+				      <property name="single_line_mode">False</property>
+				      <property name="angle">0</property>
+				    </widget>
+				    <packing>
+				      <property name="left_attach">0</property>
+				      <property name="right_attach">1</property>
+				      <property name="top_attach">0</property>
+				      <property name="bottom_attach">1</property>
+				      <property name="x_padding">5</property>
+				      <property name="x_options">fill</property>
+				      <property name="y_options"></property>
+				    </packing>
+				  </child>
+				</widget>
+				<packing>
+				  <property name="padding">0</property>
+				  <property name="expand">True</property>
+				  <property name="fill">True</property>
+				</packing>
+			      </child>
+			    </widget>
+			    <packing>
+			      <property name="padding">0</property>
+			      <property name="expand">True</property>
+			      <property name="fill">True</property>
+			    </packing>
+			  </child>
+
+			  <child>
+			    <widget class="GtkHBox" id="hbox4">
+			      <property name="visible">True</property>
+			      <property name="homogeneous">False</property>
+			      <property name="spacing">0</property>
+
+			      <child>
+				<widget class="GtkCheckButton" id="checkbuttonCABAC">
+				  <property name="visible">True</property>
+				  <property name="tooltip" translatable="yes">Lossless compression method which usually improves the bitrate usage by 15% (especially on high bitrate). Helps the quality a lot but is slower. </property>
+				  <property name="can_focus">True</property>
+				  <property name="label" translatable="yes">CABAC</property>
+				  <property name="use_underline">True</property>
+				  <property name="relief">GTK_RELIEF_NORMAL</property>
+				  <property name="focus_on_click">True</property>
+				  <property name="active">True</property>
+				  <property name="inconsistent">False</property>
+				  <property name="draw_indicator">True</property>
+				</widget>
+				<packing>
+				  <property name="padding">4</property>
+				  <property name="expand">False</property>
+				  <property name="fill">False</property>
+				</packing>
+			      </child>
+
+			      <child>
+				<widget class="GtkLabel" id="labelTrellis">
+				  <property name="visible">True</property>
+				  <property name="label" translatable="yes">Trellis</property>
+				  <property name="use_underline">False</property>
+				  <property name="use_markup">False</property>
+				  <property name="justify">GTK_JUSTIFY_LEFT</property>
+				  <property name="wrap">False</property>
+				  <property name="selectable">False</property>
+				  <property name="xalign">1</property>
+				  <property name="yalign">0.5</property>
+				  <property name="xpad">0</property>
+				  <property name="ypad">0</property>
+				  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+				  <property name="width_chars">-1</property>
+				  <property name="single_line_mode">False</property>
+				  <property name="angle">0</property>
+				</widget>
+				<packing>
+				  <property name="padding">4</property>
+				  <property name="expand">True</property>
+				  <property name="fill">True</property>
+				</packing>
+			      </child>
+
+			      <child>
+				<widget class="GtkSpinButton" id="spinbuttonTrellis">
+				  <property name="visible">True</property>
+				  <property name="tooltip" translatable="yes">Use rate distortion quantization to find optimal encoding for each block. Level 0 equals disabled, level 1 equals normal and level 2 equals high</property>
+				  <property name="can_focus">True</property>
+				  <property name="climb_rate">1</property>
+				  <property name="digits">0</property>
+				  <property name="numeric">False</property>
+				  <property name="update_policy">GTK_UPDATE_ALWAYS</property>
+				  <property name="snap_to_ticks">False</property>
+				  <property name="wrap">False</property>
+				  <property name="adjustment">1 0 2 1 10 10</property>
+				</widget>
+				<packing>
+				  <property name="padding">1</property>
+				  <property name="expand">False</property>
+				  <property name="fill">True</property>
+				</packing>
+			      </child>
+
+			      <child>
+				<widget class="GtkLabel" id="labelNoiseReduction">
+				  <property name="visible">True</property>
+				  <property name="label" translatable="yes">Noise Reduction</property>
+				  <property name="use_underline">False</property>
+				  <property name="use_markup">False</property>
+				  <property name="justify">GTK_JUSTIFY_LEFT</property>
+				  <property name="wrap">False</property>
+				  <property name="selectable">False</property>
+				  <property name="xalign">0.800000011921</property>
+				  <property name="yalign">0.5</property>
+				  <property name="xpad">0</property>
+				  <property name="ypad">0</property>
+				  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+				  <property name="width_chars">-1</property>
+				  <property name="single_line_mode">False</property>
+				  <property name="angle">0</property>
+				</widget>
+				<packing>
+				  <property name="padding">0</property>
+				  <property name="expand">True</property>
+				  <property name="fill">True</property>
+				</packing>
+			      </child>
+
+			      <child>
+				<widget class="GtkSpinButton" id="spinbuttonNoiseReduction">
+				  <property name="visible">True</property>
+				  <property name="tooltip" translatable="yes">Set the amount of noise reduction</property>
+				  <property name="can_focus">True</property>
+				  <property name="climb_rate">1</property>
+				  <property name="digits">0</property>
+				  <property name="numeric">False</property>
+				  <property name="update_policy">GTK_UPDATE_ALWAYS</property>
+				  <property name="snap_to_ticks">False</property>
+				  <property name="wrap">False</property>
+				  <property name="adjustment">0 0 1000000000 1 10 10</property>
+				</widget>
+				<packing>
+				  <property name="padding">0</property>
+				  <property name="expand">True</property>
+				  <property name="fill">True</property>
+				</packing>
+			      </child>
+			    </widget>
+			    <packing>
+			      <property name="padding">0</property>
+			      <property name="expand">True</property>
+			      <property name="fill">True</property>
+			    </packing>
+			  </child>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkLabel" id="label25">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">&lt;b&gt;Misc. Options&lt;/b&gt;</property>
 		      <property name="use_underline">False</property>
-		      <property name="use_markup">False</property>
+		      <property name="use_markup">True</property>
 		      <property name="justify">GTK_JUSTIFY_LEFT</property>
 		      <property name="wrap">False</property>
 		      <property name="selectable">False</property>
-		      <property name="xalign">0</property>
+		      <property name="xalign">0.5</property>
 		      <property name="yalign">0.5</property>
 		      <property name="xpad">0</property>
 		      <property name="ypad">0</property>
+		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		      <property name="width_chars">-1</property>
+		      <property name="single_line_mode">False</property>
+		      <property name="angle">0</property>
 		    </widget>
 		    <packing>
-		      <property name="left_attach">0</property>
-		      <property name="right_attach">1</property>
-		      <property name="top_attach">1</property>
-		      <property name="bottom_attach">2</property>
-		      <property name="y_options"></property>
+		      <property name="type">label_item</property>
 		    </packing>
 		  </child>
+		</widget>
+		<packing>
+		  <property name="padding">1</property>
+		  <property name="expand">True</property>
+		  <property name="fill">True</property>
+		</packing>
+	      </child>
+	    </widget>
+	    <packing>
+	      <property name="tab_expand">False</property>
+	      <property name="tab_fill">True</property>
+	    </packing>
+	  </child>
 
+	  <child>
+	    <widget class="GtkLabel" id="labelPageMotion&amp;More">
+	      <property name="visible">True</property>
+	      <property name="label" translatable="yes">Motion &amp; Misc</property>
+	      <property name="use_underline">False</property>
+	      <property name="use_markup">False</property>
+	      <property name="justify">GTK_JUSTIFY_LEFT</property>
+	      <property name="wrap">False</property>
+	      <property name="selectable">False</property>
+	      <property name="xalign">0.5</property>
+	      <property name="yalign">0.5</property>
+	      <property name="xpad">0</property>
+	      <property name="ypad">0</property>
+	      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+	      <property name="width_chars">-1</property>
+	      <property name="single_line_mode">False</property>
+	      <property name="angle">0</property>
+	    </widget>
+	    <packing>
+	      <property name="type">tab</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkVBox" id="vbox2">
+	      <property name="visible">True</property>
+	      <property name="homogeneous">False</property>
+	      <property name="spacing">0</property>
+
+	      <child>
+		<widget class="GtkFrame" id="frame4">
+		  <property name="visible">True</property>
+		  <property name="label_xalign">0</property>
+		  <property name="label_yalign">0.5</property>
+		  <property name="shadow_type">GTK_SHADOW_IN</property>
+
 		  <child>
-		    <widget class="GtkEntry" id="entryQz">
+		    <widget class="GtkAlignment" id="alignment4">
 		      <property name="visible">True</property>
-		      <property name="can_focus">True</property>
-		      <property name="editable">True</property>
-		      <property name="visibility">True</property>
-		      <property name="max_length">0</property>
-		      <property name="text" translatable="yes"></property>
-		      <property name="has_frame">True</property>
-		      <property name="invisible_char" translatable="yes">*</property>
-		      <property name="activates_default">False</property>
+		      <property name="xalign">0.5</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xscale">1</property>
+		      <property name="yscale">1</property>
+		      <property name="top_padding">0</property>
+		      <property name="bottom_padding">0</property>
+		      <property name="left_padding">12</property>
+		      <property name="right_padding">0</property>
+
+		      <child>
+			<widget class="GtkVBox" id="vbox3">
+			  <property name="visible">True</property>
+			  <property name="homogeneous">False</property>
+			  <property name="spacing">0</property>
+
+			  <child>
+			    <widget class="GtkCheckButton" id="checkbutton8x8">
+			      <property name="visible">True</property>
+			      <property name="tooltip" translatable="yes">General block breakdown transformation</property>
+			      <property name="can_focus">True</property>
+			      <property name="label" translatable="yes">8x8 Transform</property>
+			      <property name="use_underline">True</property>
+			      <property name="relief">GTK_RELIEF_NORMAL</property>
+			      <property name="focus_on_click">True</property>
+			      <property name="active">True</property>
+			      <property name="inconsistent">False</property>
+			      <property name="draw_indicator">True</property>
+			    </widget>
+			    <packing>
+			      <property name="padding">0</property>
+			      <property name="expand">False</property>
+			      <property name="fill">False</property>
+			    </packing>
+			  </child>
+
+			  <child>
+			    <widget class="GtkCheckButton" id="checkbutton8x8P">
+			      <property name="visible">True</property>
+			      <property name="tooltip" translatable="yes">Improve the P-frame quality</property>
+			      <property name="can_focus">True</property>
+			      <property name="label" translatable="yes">8x8, 8x16 and 16x8 P-frame search</property>
+			      <property name="use_underline">True</property>
+			      <property name="relief">GTK_RELIEF_NORMAL</property>
+			      <property name="focus_on_click">True</property>
+			      <property name="active">True</property>
+			      <property name="inconsistent">False</property>
+			      <property name="draw_indicator">True</property>
+			    </widget>
+			    <packing>
+			      <property name="padding">0</property>
+			      <property name="expand">False</property>
+			      <property name="fill">False</property>
+			    </packing>
+			  </child>
+
+			  <child>
+			    <widget class="GtkCheckButton" id="checkbutton8x8B">
+			      <property name="visible">True</property>
+			      <property name="tooltip" translatable="yes">Improve the B-frame quality</property>
+			      <property name="can_focus">True</property>
+			      <property name="label" translatable="yes">8x8, 8x16 and 16x8 B-frame search</property>
+			      <property name="use_underline">True</property>
+			      <property name="relief">GTK_RELIEF_NORMAL</property>
+			      <property name="focus_on_click">True</property>
+			      <property name="active">True</property>
+			      <property name="inconsistent">False</property>
+			      <property name="draw_indicator">True</property>
+			    </widget>
+			    <packing>
+			      <property name="padding">0</property>
+			      <property name="expand">False</property>
+			      <property name="fill">False</property>
+			    </packing>
+			  </child>
+
+			  <child>
+			    <widget class="GtkCheckButton" id="checkbutton4x4">
+			      <property name="visible">True</property>
+			      <property name="tooltip" translatable="yes">Further improve the P-frame quality</property>
+			      <property name="can_focus">True</property>
+			      <property name="label" translatable="yes">4x4, 4x8 and 8x4 P-frame search</property>
+			      <property name="use_underline">True</property>
+			      <property name="relief">GTK_RELIEF_NORMAL</property>
+			      <property name="focus_on_click">True</property>
+			      <property name="active">False</property>
+			      <property name="inconsistent">False</property>
+			      <property name="draw_indicator">True</property>
+			    </widget>
+			    <packing>
+			      <property name="padding">0</property>
+			      <property name="expand">False</property>
+			      <property name="fill">False</property>
+			    </packing>
+			  </child>
+
+			  <child>
+			    <widget class="GtkCheckButton" id="checkbutton8x8I">
+			      <property name="visible">True</property>
+			      <property name="tooltip" translatable="yes">Enable DCT Intra block search to improve quality</property>
+			      <property name="can_focus">True</property>
+			      <property name="label" translatable="yes">8x8 Intra search</property>
+			      <property name="use_underline">True</property>
+			      <property name="relief">GTK_RELIEF_NORMAL</property>
+			      <property name="focus_on_click">True</property>
+			      <property name="active">True</property>
+			      <property name="inconsistent">False</property>
+			      <property name="draw_indicator">True</property>
+			    </widget>
+			    <packing>
+			      <property name="padding">0</property>
+			      <property name="expand">False</property>
+			      <property name="fill">False</property>
+			    </packing>
+			  </child>
+
+			  <child>
+			    <widget class="GtkCheckButton" id="checkbutton4x4I">
+			      <property name="visible">True</property>
+			      <property name="tooltip" translatable="yes">Further enable DCT Intra block search to improve quality</property>
+			      <property name="can_focus">True</property>
+			      <property name="label" translatable="yes">4x4 Intra search</property>
+			      <property name="use_underline">True</property>
+			      <property name="relief">GTK_RELIEF_NORMAL</property>
+			      <property name="focus_on_click">True</property>
+			      <property name="active">True</property>
+			      <property name="inconsistent">False</property>
+			      <property name="draw_indicator">True</property>
+			    </widget>
+			    <packing>
+			      <property name="padding">0</property>
+			      <property name="expand">False</property>
+			      <property name="fill">False</property>
+			    </packing>
+			  </child>
+			</widget>
+		      </child>
 		    </widget>
-		    <packing>
-		      <property name="left_attach">1</property>
-		      <property name="right_attach">2</property>
-		      <property name="top_attach">1</property>
-		      <property name="bottom_attach">2</property>
-		      <property name="y_options"></property>
-		    </packing>
 		  </child>
 
 		  <child>
-		    <widget class="GtkHSeparator" id="hseparator1">
+		    <widget class="GtkLabel" id="label19">
 		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">&lt;b&gt;Partition Macroblocks&lt;/b&gt;</property>
+		      <property name="use_underline">False</property>
+		      <property name="use_markup">True</property>
+		      <property name="justify">GTK_JUSTIFY_LEFT</property>
+		      <property name="wrap">False</property>
+		      <property name="selectable">False</property>
+		      <property name="xalign">0.5</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xpad">0</property>
+		      <property name="ypad">0</property>
+		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		      <property name="width_chars">-1</property>
+		      <property name="single_line_mode">False</property>
+		      <property name="angle">0</property>
 		    </widget>
 		    <packing>
-		      <property name="left_attach">0</property>
-		      <property name="right_attach">1</property>
-		      <property name="top_attach">2</property>
-		      <property name="bottom_attach">3</property>
-		      <property name="x_options">fill</property>
+		      <property name="type">label_item</property>
 		    </packing>
 		  </child>
+		</widget>
+		<packing>
+		  <property name="padding">0</property>
+		  <property name="expand">True</property>
+		  <property name="fill">True</property>
+		</packing>
+	      </child>
 
+	      <child>
+		<widget class="GtkFrame" id="frame5">
+		  <property name="visible">True</property>
+		  <property name="label_xalign">0</property>
+		  <property name="label_yalign">0.5</property>
+		  <property name="shadow_type">GTK_SHADOW_IN</property>
+
 		  <child>
-		    <widget class="GtkHSeparator" id="hseparator2">
+		    <widget class="GtkAlignment" id="alignment5">
 		      <property name="visible">True</property>
+		      <property name="xalign">0.5</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xscale">1</property>
+		      <property name="yscale">1</property>
+		      <property name="top_padding">0</property>
+		      <property name="bottom_padding">0</property>
+		      <property name="left_padding">12</property>
+		      <property name="right_padding">0</property>
+
+		      <child>
+			<widget class="GtkVBox" id="vbox4">
+			  <property name="visible">True</property>
+			  <property name="homogeneous">False</property>
+			  <property name="spacing">0</property>
+
+			  <child>
+			    <widget class="GtkTable" id="table5">
+			      <property name="visible">True</property>
+			      <property name="n_rows">2</property>
+			      <property name="n_columns">2</property>
+			      <property name="homogeneous">False</property>
+			      <property name="row_spacing">0</property>
+			      <property name="column_spacing">0</property>
+
+			      <child>
+				<widget class="GtkLabel" id="labelBias">
+				  <property name="visible">True</property>
+				  <property name="label" translatable="yes">Bias</property>
+				  <property name="use_underline">False</property>
+				  <property name="use_markup">False</property>
+				  <property name="justify">GTK_JUSTIFY_LEFT</property>
+				  <property name="wrap">False</property>
+				  <property name="selectable">False</property>
+				  <property name="xalign">0</property>
+				  <property name="yalign">0.5</property>
+				  <property name="xpad">0</property>
+				  <property name="ypad">0</property>
+				  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+				  <property name="width_chars">-1</property>
+				  <property name="single_line_mode">False</property>
+				  <property name="angle">0</property>
+				</widget>
+				<packing>
+				  <property name="left_attach">0</property>
+				  <property name="right_attach">1</property>
+				  <property name="top_attach">1</property>
+				  <property name="bottom_attach">2</property>
+				  <property name="x_options">fill</property>
+				  <property name="y_options"></property>
+				</packing>
+			      </child>
+
+			      <child>
+				<widget class="GtkSpinButton" id="spinbuttonBias">
+				  <property name="visible">True</property>
+				  <property name="tooltip" translatable="yes">Increase / decrease probability for how often B-frames are used. Will not violate the maximum consecutive frame limit</property>
+				  <property name="can_focus">True</property>
+				  <property name="climb_rate">1</property>
+				  <property name="digits">0</property>
+				  <property name="numeric">True</property>
+				  <property name="update_policy">GTK_UPDATE_ALWAYS</property>
+				  <property name="snap_to_ticks">False</property>
+				  <property name="wrap">False</property>
+				  <property name="adjustment">0 -100 100 1 10 10</property>
+				</widget>
+				<packing>
+				  <property name="left_attach">1</property>
+				  <property name="right_attach">2</property>
+				  <property name="top_attach">1</property>
+				  <property name="bottom_attach">2</property>
+				  <property name="y_options"></property>
+				</packing>
+			      </child>
+
+			      <child>
+				<widget class="GtkLabel" id="labelMaxConsecutive">
+				  <property name="visible">True</property>
+				  <property name="label" translatable="yes">Max Consecutive</property>
+				  <property name="use_underline">False</property>
+				  <property name="use_markup">False</property>
+				  <property name="justify">GTK_JUSTIFY_LEFT</property>
+				  <property name="wrap">False</property>
+				  <property name="selectable">False</property>
+				  <property name="xalign">0</property>
+				  <property name="yalign">0.5</property>
+				  <property name="xpad">0</property>
+				  <property name="ypad">0</property>
+				  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+				  <property name="width_chars">-1</property>
+				  <property name="single_line_mode">False</property>
+				  <property name="angle">0</property>
+				</widget>
+				<packing>
+				  <property name="left_attach">0</property>
+				  <property name="right_attach">1</property>
+				  <property name="top_attach">0</property>
+				  <property name="bottom_attach">1</property>
+				  <property name="y_options"></property>
+				</packing>
+			      </child>
+
+			      <child>
+				<widget class="GtkSpinButton" id="spinbuttonMaxBFrame">
+				  <property name="visible">True</property>
+				  <property name="tooltip" translatable="yes">Set the maximum number of consecutive B-frames. This defines how many duplicate frames can be droped. Numbers 2 to 5 are recommended. This greatly improves the use of bitrate and quality</property>
+				  <property name="can_focus">True</property>
+				  <property name="climb_rate">1</property>
+				  <property name="digits">0</property>
+				  <property name="numeric">True</property>
+				  <property name="update_policy">GTK_UPDATE_ALWAYS</property>
+				  <property name="snap_to_ticks">False</property>
+				  <property name="wrap">False</property>
+				  <property name="adjustment">3 0 15 1 10 10</property>
+				</widget>
+				<packing>
+				  <property name="left_attach">1</property>
+				  <property name="right_attach">2</property>
+				  <property name="top_attach">0</property>
+				  <property name="bottom_attach">1</property>
+				  <property name="y_options"></property>
+				</packing>
+			      </child>
+			    </widget>
+			    <packing>
+			      <property name="padding">0</property>
+			      <property name="expand">True</property>
+			      <property name="fill">True</property>
+			    </packing>
+			  </child>
+
+			  <child>
+			    <widget class="GtkTable" id="table6">
+			      <property name="visible">True</property>
+			      <property name="n_rows">2</property>
+			      <property name="n_columns">2</property>
+			      <property name="homogeneous">False</property>
+			      <property name="row_spacing">0</property>
+			      <property name="column_spacing">0</property>
+
+			      <child>
+				<widget class="GtkCheckButton" id="checkbuttonBidirME">
+				  <property name="visible">True</property>
+				  <property name="tooltip" translatable="yes">Jointly optimize both Motion Vector's in B-frames. This will improve quality but take more time for encoding</property>
+				  <property name="can_focus">True</property>
+				  <property name="label" translatable="yes">Bidirectional ME</property>
+				  <property name="use_underline">True</property>
+				  <property name="relief">GTK_RELIEF_NORMAL</property>
+				  <property name="focus_on_click">True</property>
+				  <property name="active">False</property>
+				  <property name="inconsistent">False</property>
+				  <property name="draw_indicator">True</property>
+				</widget>
+				<packing>
+				  <property name="left_attach">1</property>
+				  <property name="right_attach">2</property>
+				  <property name="top_attach">0</property>
+				  <property name="bottom_attach">1</property>
+				  <property name="x_options">fill</property>
+				  <property name="y_options"></property>
+				</packing>
+			      </child>
+
+			      <child>
+				<widget class="GtkCheckButton" id="checkbuttonWeighted">
+				  <property name="visible">True</property>
+				  <property name="tooltip" translatable="yes">Enables weighting of B-frames to help fades</property>
+				  <property name="can_focus">True</property>
+				  <property name="label" translatable="yes">Weighted biprediction</property>
+				  <property name="use_underline">True</property>
+				  <property name="relief">GTK_RELIEF_NORMAL</property>
+				  <property name="focus_on_click">True</property>
+				  <property name="active">True</property>
+				  <property name="inconsistent">False</property>
+				  <property name="draw_indicator">True</property>
+				</widget>
+				<packing>
+				  <property name="left_attach">1</property>
+				  <property name="right_attach">2</property>
+				  <property name="top_attach">1</property>
+				  <property name="bottom_attach">2</property>
+				  <property name="x_options">fill</property>
+				  <property name="y_options"></property>
+				</packing>
+			      </child>
+
+			      <child>
+				<widget class="GtkCheckButton" id="checkbuttonAdaptative">
+				  <property name="visible">True</property>
+				  <property name="tooltip" translatable="yes">Use fewer B-frame if needed. This is always recommended. If not enabled, the codec will always use the maximum number of consecutive B-frames</property>
+				  <property name="can_focus">True</property>
+				  <property name="label" translatable="yes">Adaptative DCT</property>
+				  <property name="use_underline">True</property>
+				  <property name="relief">GTK_RELIEF_NORMAL</property>
+				  <property name="focus_on_click">True</property>
+				  <property name="active">True</property>
+				  <property name="inconsistent">False</property>
+				  <property name="draw_indicator">True</property>
+				</widget>
+				<packing>
+				  <property name="left_attach">0</property>
+				  <property name="right_attach">1</property>
+				  <property name="top_attach">1</property>
+				  <property name="bottom_attach">2</property>
+				  <property name="x_padding">4</property>
+				  <property name="x_options">fill</property>
+				  <property name="y_options"></property>
+				</packing>
+			      </child>
+
+			      <child>
+				<widget class="GtkCheckButton" id="checkbuttonBasReference">
+				  <property name="visible">True</property>
+				  <property name="tooltip" translatable="yes">Allow B-frames to make references non-linearly to another B-frame (instead of creating a duplicate copy)</property>
+				  <property name="can_focus">True</property>
+				  <property name="label" translatable="yes">Use as reference</property>
+				  <property name="use_underline">True</property>
+				  <property name="relief">GTK_RELIEF_NORMAL</property>
+				  <property name="focus_on_click">True</property>
+				  <property name="active">False</property>
+				  <property name="inconsistent">False</property>
+				  <property name="draw_indicator">True</property>
+				</widget>
+				<packing>
+				  <property name="left_attach">0</property>
+				  <property name="right_attach">1</property>
+				  <property name="top_attach">0</property>
+				  <property name="bottom_attach">1</property>
+				  <property name="x_padding">5</property>
+				  <property name="x_options">fill</property>
+				  <property name="y_options"></property>
+				</packing>
+			      </child>
+			    </widget>
+			    <packing>
+			      <property name="padding">0</property>
+			      <property name="expand">True</property>
+			      <property name="fill">True</property>
+			    </packing>
+			  </child>
+
+			  <child>
+			    <widget class="GtkHBox" id="hbox1">
+			      <property name="visible">True</property>
+			      <property name="homogeneous">False</property>
+			      <property name="spacing">0</property>
+
+			      <child>
+				<widget class="GtkLabel" id="labelBFrameDirectMode">
+				  <property name="visible">True</property>
+				  <property name="label" translatable="yes">B-Frame Direct Mode:  </property>
+				  <property name="use_underline">False</property>
+				  <property name="use_markup">False</property>
+				  <property name="justify">GTK_JUSTIFY_LEFT</property>
+				  <property name="wrap">False</property>
+				  <property name="selectable">False</property>
+				  <property name="xalign">1</property>
+				  <property name="yalign">0.5</property>
+				  <property name="xpad">0</property>
+				  <property name="ypad">0</property>
+				  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+				  <property name="width_chars">-1</property>
+				  <property name="single_line_mode">False</property>
+				  <property name="angle">0</property>
+				</widget>
+				<packing>
+				  <property name="padding">0</property>
+				  <property name="expand">True</property>
+				  <property name="fill">True</property>
+				</packing>
+			      </child>
+
+			      <child>
+				<widget class="GtkComboBox" id="comboboxDirectMode">
+				  <property name="visible">True</property>
+				  <property name="has_default">True</property>
+				  <property name="items" translatable="yes">Temporal
+Spatial</property>
+				  <property name="add_tearoffs">False</property>
+				  <property name="focus_on_click">True</property>
+				</widget>
+				<packing>
+				  <property name="padding">0</property>
+				  <property name="expand">True</property>
+				  <property name="fill">True</property>
+				</packing>
+			      </child>
+			    </widget>
+			    <packing>
+			      <property name="padding">0</property>
+			      <property name="expand">True</property>
+			      <property name="fill">True</property>
+			    </packing>
+			  </child>
+			</widget>
+		      </child>
 		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkLabel" id="label20">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">&lt;b&gt;B-Frames&lt;/b&gt;</property>
+		      <property name="use_underline">False</property>
+		      <property name="use_markup">True</property>
+		      <property name="justify">GTK_JUSTIFY_LEFT</property>
+		      <property name="wrap">False</property>
+		      <property name="selectable">False</property>
+		      <property name="xalign">0.5</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xpad">0</property>
+		      <property name="ypad">0</property>
+		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		      <property name="width_chars">-1</property>
+		      <property name="single_line_mode">False</property>
+		      <property name="angle">0</property>
+		    </widget>
 		    <packing>
-		      <property name="left_attach">1</property>
-		      <property name="right_attach">2</property>
-		      <property name="top_attach">2</property>
-		      <property name="bottom_attach">3</property>
-		      <property name="x_options">fill</property>
-		      <property name="y_options">fill</property>
+		      <property name="type">label_item</property>
 		    </packing>
 		  </child>
 		</widget>
-	      </child>
-
-	      <child>
-		<widget class="GtkLabel" id="label1">
-		  <property name="visible">True</property>
-		  <property name="label" translatable="yes">&lt;b&gt;Encoding Mode&lt;/b&gt;</property>
-		  <property name="use_underline">False</property>
-		  <property name="use_markup">True</property>
-		  <property name="justify">GTK_JUSTIFY_LEFT</property>
-		  <property name="wrap">False</property>
-		  <property name="selectable">False</property>
-		  <property name="xalign">0.5</property>
-		  <property name="yalign">0.5</property>
-		  <property name="xpad">0</property>
-		  <property name="ypad">0</property>
-		</widget>
 		<packing>
-		  <property name="type">label_item</property>
+		  <property name="padding">1</property>
+		  <property name="expand">True</property>
+		  <property name="fill">True</property>
 		</packing>
 	      </child>
 	    </widget>
 	    <packing>
-	      <property name="padding">0</property>
-	      <property name="expand">True</property>
-	      <property name="fill">True</property>
+	      <property name="tab_expand">False</property>
+	      <property name="tab_fill">True</property>
 	    </packing>
 	  </child>
 
 	  <child>
-	    <widget class="GtkFrame" id="frame2">
+	    <widget class="GtkLabel" id="labelPagePartion&amp;Frame">
 	      <property name="visible">True</property>
-	      <property name="label_xalign">0</property>
-	      <property name="label_yalign">0.5</property>
-	      <property name="shadow_type">GTK_SHADOW_ETCHED_IN</property>
+	      <property name="label" translatable="yes">Partitions &amp; Frames</property>
+	      <property name="use_underline">False</property>
+	      <property name="use_markup">False</property>
+	      <property name="justify">GTK_JUSTIFY_LEFT</property>
+	      <property name="wrap">False</property>
+	      <property name="selectable">False</property>
+	      <property name="xalign">0.5</property>
+	      <property name="yalign">0.5</property>
+	      <property name="xpad">0</property>
+	      <property name="ypad">0</property>
+	      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+	      <property name="width_chars">-1</property>
+	      <property name="single_line_mode">False</property>
+	      <property name="angle">0</property>
+	    </widget>
+	    <packing>
+	      <property name="type">tab</property>
+	    </packing>
+	  </child>
 
+	  <child>
+	    <widget class="GtkVBox" id="vbox1">
+	      <property name="visible">True</property>
+	      <property name="homogeneous">False</property>
+	      <property name="spacing">0</property>
+
 	      <child>
-		<widget class="GtkVBox" id="vbox2">
+		<widget class="GtkFrame" id="frame1">
 		  <property name="visible">True</property>
-		  <property name="homogeneous">False</property>
-		  <property name="spacing">0</property>
+		  <property name="label_xalign">0</property>
+		  <property name="label_yalign">0.5</property>
+		  <property name="shadow_type">GTK_SHADOW_ETCHED_IN</property>
 
 		  <child>
-		    <widget class="GtkTable" id="table2">
+		    <widget class="GtkAlignment" id="alignment1">
 		      <property name="visible">True</property>
-		      <property name="n_rows">1</property>
-		      <property name="n_columns">4</property>
-		      <property name="homogeneous">False</property>
-		      <property name="row_spacing">0</property>
-		      <property name="column_spacing">0</property>
+		      <property name="xalign">0.5</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xscale">1</property>
+		      <property name="yscale">1</property>
+		      <property name="top_padding">0</property>
+		      <property name="bottom_padding">0</property>
+		      <property name="left_padding">12</property>
+		      <property name="right_padding">0</property>
 
 		      <child>
-			<widget class="GtkSpinButton" id="spinbuttonQmin">
+			<widget class="GtkTable" id="table2">
 			  <property name="visible">True</property>
-			  <property name="can_focus">True</property>
-			  <property name="climb_rate">1</property>
-			  <property name="digits">0</property>
-			  <property name="numeric">True</property>
-			  <property name="update_policy">GTK_UPDATE_ALWAYS</property>
-			  <property name="snap_to_ticks">False</property>
-			  <property name="wrap">False</property>
-			  <property name="adjustment">1 1 50 1 10 10</property>
-			</widget>
-			<packing>
-			  <property name="left_attach">1</property>
-			  <property name="right_attach">2</property>
-			  <property name="top_attach">0</property>
-			  <property name="bottom_attach">1</property>
-			  <property name="x_options">fill</property>
-			  <property name="y_options"></property>
-			</packing>
-		      </child>
+			  <property name="n_rows">3</property>
+			  <property name="n_columns">2</property>
+			  <property name="homogeneous">False</property>
+			  <property name="row_spacing">0</property>
+			  <property name="column_spacing">0</property>
 
-		      <child>
-			<widget class="GtkSpinButton" id="spinbuttonQmax">
-			  <property name="visible">True</property>
-			  <property name="can_focus">True</property>
-			  <property name="climb_rate">1</property>
-			  <property name="digits">0</property>
-			  <property name="numeric">True</property>
-			  <property name="update_policy">GTK_UPDATE_ALWAYS</property>
-			  <property name="snap_to_ticks">False</property>
-			  <property name="wrap">False</property>
-			  <property name="adjustment">1 1 50 1 10 10</property>
-			</widget>
-			<packing>
-			  <property name="left_attach">3</property>
-			  <property name="right_attach">4</property>
-			  <property name="top_attach">0</property>
-			  <property name="bottom_attach">1</property>
-			  <property name="x_options">fill</property>
-			  <property name="y_options"></property>
-			</packing>
-		      </child>
+			  <child>
+			    <widget class="GtkSpinButton" id="spinbuttonKeyframeBoost">
+			      <property name="width_request">115</property>
+			      <property name="visible">True</property>
+			      <property name="tooltip" translatable="yes">Set how much &quot;bitrate bonus&quot; a keyframe can get</property>
+			      <property name="can_focus">True</property>
+			      <property name="climb_rate">1</property>
+			      <property name="digits">0</property>
+			      <property name="numeric">True</property>
+			      <property name="update_policy">GTK_UPDATE_ALWAYS</property>
+			      <property name="snap_to_ticks">False</property>
+			      <property name="wrap">False</property>
+			      <property name="adjustment">40 0 100 1 10 10</property>
+			    </widget>
+			    <packing>
+			      <property name="left_attach">1</property>
+			      <property name="right_attach">2</property>
+			      <property name="top_attach">0</property>
+			      <property name="bottom_attach">1</property>
+			      <property name="y_options"></property>
+			    </packing>
+			  </child>
 
-		      <child>
-			<widget class="GtkLabel" id="label5">
-			  <property name="visible">True</property>
-			  <property name="label" translatable="yes">Qmin :</property>
-			  <property name="use_underline">False</property>
-			  <property name="use_markup">False</property>
-			  <property name="justify">GTK_JUSTIFY_LEFT</property>
-			  <property name="wrap">False</property>
-			  <property name="selectable">False</property>
-			  <property name="xalign">0</property>
-			  <property name="yalign">0.5</property>
-			  <property name="xpad">0</property>
-			  <property name="ypad">0</property>
-			</widget>
-			<packing>
-			  <property name="left_attach">0</property>
-			  <property name="right_attach">1</property>
-			  <property name="top_attach">0</property>
-			  <property name="bottom_attach">1</property>
-			  <property name="x_options">expand</property>
-			  <property name="y_options"></property>
-			</packing>
-		      </child>
+			  <child>
+			    <widget class="GtkLabel" id="label10">
+			      <property name="visible">True</property>
+			      <property name="label" translatable="yes">Keyframe boots (%)</property>
+			      <property name="use_underline">False</property>
+			      <property name="use_markup">False</property>
+			      <property name="justify">GTK_JUSTIFY_LEFT</property>
+			      <property name="wrap">False</property>
+			      <property name="selectable">False</property>
+			      <property name="xalign">0</property>
+			      <property name="yalign">0.5</property>
+			      <property name="xpad">0</property>
+			      <property name="ypad">0</property>
+			      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+			      <property name="width_chars">-1</property>
+			      <property name="single_line_mode">False</property>
+			      <property name="angle">0</property>
+			    </widget>
+			    <packing>
+			      <property name="left_attach">0</property>
+			      <property name="right_attach">1</property>
+			      <property name="top_attach">0</property>
+			      <property name="bottom_attach">1</property>
+			      <property name="y_options"></property>
+			    </packing>
+			  </child>
 
-		      <child>
-			<widget class="GtkLabel" id="label6">
-			  <property name="visible">True</property>
-			  <property name="label" translatable="yes">Qmax :</property>
-			  <property name="use_underline">False</property>
-			  <property name="use_markup">False</property>
-			  <property name="justify">GTK_JUSTIFY_LEFT</property>
-			  <property name="wrap">False</property>
-			  <property name="selectable">False</property>
-			  <property name="xalign">0</property>
-			  <property name="yalign">0.5</property>
-			  <property name="xpad">0</property>
-			  <property name="ypad">0</property>
+			  <child>
+			    <widget class="GtkLabel" id="label11">
+			      <property name="visible">True</property>
+			      <property name="label" translatable="yes">B-frame reduction (%)</property>
+			      <property name="use_underline">False</property>
+			      <property name="use_markup">False</property>
+			      <property name="justify">GTK_JUSTIFY_LEFT</property>
+			      <property name="wrap">False</property>
+			      <property name="selectable">False</property>
+			      <property name="xalign">0</property>
+			      <property name="yalign">0.5</property>
+			      <property name="xpad">0</property>
+			      <property name="ypad">0</property>
+			      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+			      <property name="width_chars">-1</property>
+			      <property name="single_line_mode">False</property>
+			      <property name="angle">0</property>
+			    </widget>
+			    <packing>
+			      <property name="left_attach">0</property>
+			      <property name="right_attach">1</property>
+			      <property name="top_attach">1</property>
+			      <property name="bottom_attach">2</property>
+			      <property name="y_options"></property>
+			    </packing>
+			  </child>
+
+			  <child>
+			    <widget class="GtkLabel" id="label12">
+			      <property name="visible">True</property>
+			      <property name="label" translatable="yes">Bitrate variability (%)</property>
+			      <property name="use_underline">False</property>
+			      <property name="use_markup">False</property>
+			      <property name="justify">GTK_JUSTIFY_LEFT</property>
+			      <property name="wrap">False</property>
+			      <property name="selectable">False</property>
+			      <property name="xalign">0</property>
+			      <property name="yalign">0.5</property>
+			      <property name="xpad">0</property>
+			      <property name="ypad">0</property>
+			      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+			      <property name="width_chars">-1</property>
+			      <property name="single_line_mode">False</property>
+			      <property name="angle">0</property>
+			    </widget>
+			    <packing>
+			      <property name="left_attach">0</property>
+			      <property name="right_attach">1</property>
+			      <property name="top_attach">2</property>
+			      <property name="bottom_attach">3</property>
+			      <property name="y_options"></property>
+			    </packing>
+			  </child>
+
+			  <child>
+			    <widget class="GtkSpinButton" id="spinbuttonBframeReduction">
+			      <property name="visible">True</property>
+			      <property name="tooltip" translatable="yes">Set how much bitrate is deducted from a B-frame as compared to the previous P-frame</property>
+			      <property name="can_focus">True</property>
+			      <property name="climb_rate">1</property>
+			      <property name="digits">0</property>
+			      <property name="numeric">True</property>
+			      <property name="update_policy">GTK_UPDATE_ALWAYS</property>
+			      <property name="snap_to_ticks">False</property>
+			      <property name="wrap">False</property>
+			      <property name="adjustment">30 0 100 1 10 10</property>
+			    </widget>
+			    <packing>
+			      <property name="left_attach">1</property>
+			      <property name="right_attach">2</property>
+			      <property name="top_attach">1</property>
+			      <property name="bottom_attach">2</property>
+			      <property name="y_options"></property>
+			    </packing>
+			  </child>
+
+			  <child>
+			    <widget class="GtkSpinButton" id="spinbuttonBitrateVariability">
+			      <property name="visible">True</property>
+			      <property name="tooltip" translatable="yes">Define how much the bitrate can fluctuate over the entire video. 0% results in a constant bitrate stream, while 100% results in a pure quality based bitrate stream</property>
+			      <property name="can_focus">True</property>
+			      <property name="climb_rate">1</property>
+			      <property name="digits">0</property>
+			      <property name="numeric">True</property>
+			      <property name="update_policy">GTK_UPDATE_ALWAYS</property>
+			      <property name="snap_to_ticks">False</property>
+			      <property name="wrap">False</property>
+			      <property name="adjustment">60 0 100 1 10 10</property>
+			    </widget>
+			    <packing>
+			      <property name="left_attach">1</property>
+			      <property name="right_attach">2</property>
+			      <property name="top_attach">2</property>
+			      <property name="bottom_attach">3</property>
+			      <property name="y_options"></property>
+			    </packing>
+			  </child>
 			</widget>
-			<packing>
-			  <property name="left_attach">2</property>
-			  <property name="right_attach">3</property>
-			  <property name="top_attach">0</property>
-			  <property name="bottom_attach">1</property>
-			  <property name="x_options">expand</property>
-			  <property name="y_options"></property>
-			</packing>
 		      </child>
 		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkLabel" id="label7">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">&lt;b&gt;Bitrate&lt;/b&gt;</property>
+		      <property name="use_underline">False</property>
+		      <property name="use_markup">True</property>
+		      <property name="justify">GTK_JUSTIFY_LEFT</property>
+		      <property name="wrap">False</property>
+		      <property name="selectable">False</property>
+		      <property name="xalign">0.5</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xpad">0</property>
+		      <property name="ypad">0</property>
+		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		      <property name="width_chars">-1</property>
+		      <property name="single_line_mode">False</property>
+		      <property name="angle">0</property>
+		    </widget>
 		    <packing>
-		      <property name="padding">0</property>
-		      <property name="expand">True</property>
-		      <property name="fill">True</property>
+		      <property name="type">label_item</property>
 		    </packing>
 		  </child>
+		</widget>
+		<packing>
+		  <property name="padding">1</property>
+		  <property name="expand">True</property>
+		  <property name="fill">True</property>
+		</packing>
+	      </child>
 
+	      <child>
+		<widget class="GtkFrame" id="frame2">
+		  <property name="visible">True</property>
+		  <property name="label_xalign">0</property>
+		  <property name="label_yalign">0.5</property>
+		  <property name="shadow_type">GTK_SHADOW_ETCHED_IN</property>
+
 		  <child>
-		    <widget class="GtkHBox" id="hbox1">
+		    <widget class="GtkAlignment" id="alignment2">
 		      <property name="visible">True</property>
-		      <property name="homogeneous">False</property>
-		      <property name="spacing">0</property>
+		      <property name="xalign">0.5</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xscale">1</property>
+		      <property name="yscale">1</property>
+		      <property name="top_padding">0</property>
+		      <property name="bottom_padding">0</property>
+		      <property name="left_padding">12</property>
+		      <property name="right_padding">0</property>
 
 		      <child>
-			<widget class="GtkLabel" id="label7">
+			<widget class="GtkTable" id="table3">
 			  <property name="visible">True</property>
-			  <property name="label" translatable="yes">Kf Min :</property>
-			  <property name="use_underline">False</property>
-			  <property name="use_markup">False</property>
-			  <property name="justify">GTK_JUSTIFY_LEFT</property>
-			  <property name="wrap">False</property>
-			  <property name="selectable">False</property>
-			  <property name="xalign">0.5</property>
-			  <property name="yalign">0.5</property>
-			  <property name="xpad">0</property>
-			  <property name="ypad">0</property>
-			</widget>
-			<packing>
-			  <property name="padding">0</property>
-			  <property name="expand">True</property>
-			  <property name="fill">False</property>
-			</packing>
-		      </child>
+			  <property name="n_rows">3</property>
+			  <property name="n_columns">2</property>
+			  <property name="homogeneous">False</property>
+			  <property name="row_spacing">0</property>
+			  <property name="column_spacing">0</property>
 
-		      <child>
-			<widget class="GtkSpinButton" id="spinbuttonKfmin">
-			  <property name="visible">True</property>
-			  <property name="can_focus">True</property>
-			  <property name="climb_rate">1</property>
-			  <property name="digits">0</property>
-			  <property name="numeric">True</property>
-			  <property name="update_policy">GTK_UPDATE_ALWAYS</property>
-			  <property name="snap_to_ticks">False</property>
-			  <property name="wrap">False</property>
-			  <property name="adjustment">5 5 5000 1 10 10</property>
-			</widget>
-			<packing>
-			  <property name="padding">0</property>
-			  <property name="expand">False</property>
-			  <property name="fill">True</property>
-			</packing>
-		      </child>
+			  <child>
+			    <widget class="GtkLabel" id="label13">
+			      <property name="visible">True</property>
+			      <property name="label" translatable="yes">Min Qp</property>
+			      <property name="use_underline">False</property>
+			      <property name="use_markup">False</property>
+			      <property name="justify">GTK_JUSTIFY_LEFT</property>
+			      <property name="wrap">False</property>
+			      <property name="selectable">False</property>
+			      <property name="xalign">0</property>
+			      <property name="yalign">0.5</property>
+			      <property name="xpad">0</property>
+			      <property name="ypad">0</property>
+			      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+			      <property name="width_chars">-1</property>
+			      <property name="single_line_mode">False</property>
+			      <property name="angle">0</property>
+			    </widget>
+			    <packing>
+			      <property name="left_attach">0</property>
+			      <property name="right_attach">1</property>
+			      <property name="top_attach">0</property>
+			      <property name="bottom_attach">1</property>
+			      <property name="y_options"></property>
+			    </packing>
+			  </child>
 
-		      <child>
-			<widget class="GtkLabel" id="label8">
-			  <property name="visible">True</property>
-			  <property name="label" translatable="yes">Kf Max :</property>
-			  <property name="use_underline">False</property>
-			  <property name="use_markup">False</property>
-			  <property name="justify">GTK_JUSTIFY_LEFT</property>
-			  <property name="wrap">False</property>
-			  <property name="selectable">False</property>
-			  <property name="xalign">0.5</property>
-			  <property name="yalign">0.5</property>
-			  <property name="xpad">0</property>
-			  <property name="ypad">0</property>
-			</widget>
-			<packing>
-			  <property name="padding">0</property>
-			  <property name="expand">True</property>
-			  <property name="fill">False</property>
-			</packing>
-		      </child>
+			  <child>
+			    <widget class="GtkLabel" id="label14">
+			      <property name="visible">True</property>
+			      <property name="label" translatable="yes">Max Qp</property>
+			      <property name="use_underline">False</property>
+			      <property name="use_markup">False</property>
+			      <property name="justify">GTK_JUSTIFY_LEFT</property>
+			      <property name="wrap">False</property>
+			      <property name="selectable">False</property>
+			      <property name="xalign">0</property>
+			      <property name="yalign">0.5</property>
+			      <property name="xpad">0</property>
+			      <property name="ypad">0</property>
+			      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+			      <property name="width_chars">-1</property>
+			      <property name="single_line_mode">False</property>
+			      <property name="angle">0</property>
+			    </widget>
+			    <packing>
+			      <property name="left_attach">0</property>
+			      <property name="right_attach">1</property>
+			      <property name="top_attach">1</property>
+			      <property name="bottom_attach">2</property>
+			      <property name="y_options"></property>
+			    </packing>
+			  </child>
 
-		      <child>
-			<widget class="GtkSpinButton" id="spinbuttonKfmax">
-			  <property name="visible">True</property>
-			  <property name="can_focus">True</property>
-			  <property name="climb_rate">1</property>
-			  <property name="digits">0</property>
-			  <property name="numeric">True</property>
-			  <property name="update_policy">GTK_UPDATE_ALWAYS</property>
-			  <property name="snap_to_ticks">False</property>
-			  <property name="wrap">False</property>
-			  <property name="adjustment">5 5 5000 1 10 10</property>
+			  <child>
+			    <widget class="GtkLabel" id="label15">
+			      <property name="visible">True</property>
+			      <property name="label" translatable="yes">Max QP Step</property>
+			      <property name="use_underline">False</property>
+			      <property name="use_markup">False</property>
+			      <property name="justify">GTK_JUSTIFY_LEFT</property>
+			      <property name="wrap">False</property>
+			      <property name="selectable">False</property>
+			      <property name="xalign">0</property>
+			      <property name="yalign">0.5</property>
+			      <property name="xpad">0</property>
+			      <property name="ypad">0</property>
+			      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+			      <property name="width_chars">-1</property>
+			      <property name="single_line_mode">False</property>
+			      <property name="angle">0</property>
+			    </widget>
+			    <packing>
+			      <property name="left_attach">0</property>
+			      <property name="right_attach">1</property>
+			      <property name="top_attach">2</property>
+			      <property name="bottom_attach">3</property>
+			      <property name="y_options"></property>
+			    </packing>
+			  </child>
+
+			  <child>
+			    <widget class="GtkSpinButton" id="spinbuttonMinQp">
+			      <property name="width_request">54</property>
+			      <property name="visible">True</property>
+			      <property name="tooltip" translatable="yes">Enforce a minimum quantizer level</property>
+			      <property name="can_focus">True</property>
+			      <property name="climb_rate">1</property>
+			      <property name="digits">0</property>
+			      <property name="numeric">True</property>
+			      <property name="update_policy">GTK_UPDATE_ALWAYS</property>
+			      <property name="snap_to_ticks">False</property>
+			      <property name="wrap">False</property>
+			      <property name="adjustment">10 10 51 1 10 10</property>
+			    </widget>
+			    <packing>
+			      <property name="left_attach">1</property>
+			      <property name="right_attach">2</property>
+			      <property name="top_attach">0</property>
+			      <property name="bottom_attach">1</property>
+			      <property name="y_options"></property>
+			    </packing>
+			  </child>
+
+			  <child>
+			    <widget class="GtkSpinButton" id="spinbuttonMaxQp">
+			      <property name="visible">True</property>
+			      <property name="tooltip" translatable="yes">Enforce a maximum quantizer level</property>
+			      <property name="can_focus">True</property>
+			      <property name="climb_rate">1</property>
+			      <property name="digits">0</property>
+			      <property name="numeric">True</property>
+			      <property name="update_policy">GTK_UPDATE_ALWAYS</property>
+			      <property name="snap_to_ticks">False</property>
+			      <property name="wrap">False</property>
+			      <property name="adjustment">51 10 51 1 10 10</property>
+			    </widget>
+			    <packing>
+			      <property name="left_attach">1</property>
+			      <property name="right_attach">2</property>
+			      <property name="top_attach">1</property>
+			      <property name="bottom_attach">2</property>
+			      <property name="y_options"></property>
+			    </packing>
+			  </child>
+
+			  <child>
+			    <widget class="GtkSpinButton" id="spinbuttonQpStep">
+			      <property name="visible">True</property>
+			      <property name="tooltip" translatable="yes">Define how much the quantizer rate can change between two consecutive frames</property>
+			      <property name="can_focus">True</property>
+			      <property name="climb_rate">1</property>
+			      <property name="digits">0</property>
+			      <property name="numeric">True</property>
+			      <property name="update_policy">GTK_UPDATE_ALWAYS</property>
+			      <property name="snap_to_ticks">False</property>
+			      <property name="wrap">False</property>
+			      <property name="adjustment">4 0 10 1 10 10</property>
+			    </widget>
+			    <packing>
+			      <property name="left_attach">1</property>
+			      <property name="right_attach">2</property>
+			      <property name="top_attach">2</property>
+			      <property name="bottom_attach">3</property>
+			      <property name="y_options"></property>
+			    </packing>
+			  </child>
 			</widget>
-			<packing>
-			  <property name="padding">0</property>
-			  <property name="expand">False</property>
-			  <property name="fill">True</property>
-			</packing>
 		      </child>
 		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkLabel" id="label8">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">&lt;b&gt;Quantization Limits&lt;/b&gt;</property>
+		      <property name="use_underline">False</property>
+		      <property name="use_markup">True</property>
+		      <property name="justify">GTK_JUSTIFY_LEFT</property>
+		      <property name="wrap">False</property>
+		      <property name="selectable">False</property>
+		      <property name="xalign">0.5</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xpad">0</property>
+		      <property name="ypad">0</property>
+		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		      <property name="width_chars">-1</property>
+		      <property name="single_line_mode">False</property>
+		      <property name="angle">0</property>
+		    </widget>
 		    <packing>
-		      <property name="padding">0</property>
-		      <property name="expand">True</property>
-		      <property name="fill">True</property>
+		      <property name="type">label_item</property>
 		    </packing>
 		  </child>
+		</widget>
+		<packing>
+		  <property name="padding">1</property>
+		  <property name="expand">True</property>
+		  <property name="fill">True</property>
+		</packing>
+	      </child>
 
+	      <child>
+		<widget class="GtkFrame" id="frame3">
+		  <property name="visible">True</property>
+		  <property name="label_xalign">0</property>
+		  <property name="label_yalign">0.5</property>
+		  <property name="shadow_type">GTK_SHADOW_ETCHED_IN</property>
+
 		  <child>
-		    <widget class="GtkHBox" id="hbox2">
+		    <widget class="GtkAlignment" id="alignment3">
 		      <property name="visible">True</property>
-		      <property name="homogeneous">False</property>
-		      <property name="spacing">0</property>
+		      <property name="xalign">0.5</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xscale">1</property>
+		      <property name="yscale">1</property>
+		      <property name="top_padding">0</property>
+		      <property name="bottom_padding">0</property>
+		      <property name="left_padding">12</property>
+		      <property name="right_padding">0</property>
 
 		      <child>
-			<widget class="GtkLabel" id="label9">
+			<widget class="GtkTable" id="table4">
 			  <property name="visible">True</property>
-			  <property name="label" translatable="yes"># B Frames :</property>
-			  <property name="use_underline">False</property>
-			  <property name="use_markup">False</property>
-			  <property name="justify">GTK_JUSTIFY_LEFT</property>
-			  <property name="wrap">False</property>
-			  <property name="selectable">False</property>
-			  <property name="xalign">0.5</property>
-			  <property name="yalign">0.5</property>
-			  <property name="xpad">0</property>
-			  <property name="ypad">0</property>
-			</widget>
-			<packing>
-			  <property name="padding">0</property>
-			  <property name="expand">False</property>
-			  <property name="fill">False</property>
-			</packing>
-		      </child>
+			  <property name="n_rows">3</property>
+			  <property name="n_columns">2</property>
+			  <property name="homogeneous">False</property>
+			  <property name="row_spacing">0</property>
+			  <property name="column_spacing">0</property>
 
-		      <child>
-			<widget class="GtkSpinButton" id="spinbuttonBframes">
-			  <property name="visible">True</property>
-			  <property name="can_focus">True</property>
-			  <property name="climb_rate">1</property>
-			  <property name="digits">0</property>
-			  <property name="numeric">True</property>
-			  <property name="update_policy">GTK_UPDATE_ALWAYS</property>
-			  <property name="snap_to_ticks">False</property>
-			  <property name="wrap">False</property>
-			  <property name="adjustment">1 0 4 1 10 10</property>
-			</widget>
-			<packing>
-			  <property name="padding">0</property>
-			  <property name="expand">False</property>
-			  <property name="fill">False</property>
-			</packing>
-		      </child>
+			  <child>
+			    <widget class="GtkLabel" id="label16">
+			      <property name="visible">True</property>
+			      <property name="label" translatable="yes">Scene Cut Threshold</property>
+			      <property name="use_underline">False</property>
+			      <property name="use_markup">False</property>
+			      <property name="justify">GTK_JUSTIFY_LEFT</property>
+			      <property name="wrap">False</property>
+			      <property name="selectable">False</property>
+			      <property name="xalign">0</property>
+			      <property name="yalign">0.5</property>
+			      <property name="xpad">0</property>
+			      <property name="ypad">0</property>
+			      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+			      <property name="width_chars">-1</property>
+			      <property name="single_line_mode">False</property>
+			      <property name="angle">0</property>
+			    </widget>
+			    <packing>
+			      <property name="left_attach">0</property>
+			      <property name="right_attach">1</property>
+			      <property name="top_attach">0</property>
+			      <property name="bottom_attach">1</property>
+			      <property name="y_options"></property>
+			    </packing>
+			  </child>
 
-		      <child>
-			<widget class="GtkCheckButton" id="checkbuttonCabac">
-			  <property name="visible">True</property>
-			  <property name="can_focus">True</property>
-			  <property name="label" translatable="yes">Cabac</property>
-			  <property name="use_underline">True</property>
-			  <property name="relief">GTK_RELIEF_NORMAL</property>
-			  <property name="active">False</property>
-			  <property name="inconsistent">False</property>
-			  <property name="draw_indicator">True</property>
-			</widget>
-			<packing>
-			  <property name="padding">0</property>
-			  <property name="expand">False</property>
-			  <property name="fill">False</property>
-			</packing>
-		      </child>
+			  <child>
+			    <widget class="GtkSpinButton" id="spinbuttonSceneCut">
+			      <property name="width_request">115</property>
+			      <property name="visible">True</property>
+			      <property name="tooltip" translatable="yes">Increase / decrease sensitivity for detecting Scene Changes to compensate for. Improves I-frame usage and helps quality</property>
+			      <property name="can_focus">True</property>
+			      <property name="climb_rate">1</property>
+			      <property name="digits">0</property>
+			      <property name="numeric">True</property>
+			      <property name="update_policy">GTK_UPDATE_ALWAYS</property>
+			      <property name="snap_to_ticks">False</property>
+			      <property name="wrap">False</property>
+			      <property name="adjustment">40 0 100 1 10 10</property>
+			    </widget>
+			    <packing>
+			      <property name="left_attach">1</property>
+			      <property name="right_attach">2</property>
+			      <property name="top_attach">0</property>
+			      <property name="bottom_attach">1</property>
+			      <property name="y_options"></property>
+			    </packing>
+			  </child>
 
-		      <child>
-			<widget class="GtkHSeparator" id="hseparator3">
-			  <property name="visible">True</property>
+			  <child>
+			    <widget class="GtkLabel" id="label17">
+			      <property name="visible">True</property>
+			      <property name="label" translatable="yes">Min IDR frame interval</property>
+			      <property name="use_underline">False</property>
+			      <property name="use_markup">False</property>
+			      <property name="justify">GTK_JUSTIFY_LEFT</property>
+			      <property name="wrap">False</property>
+			      <property name="selectable">False</property>
+			      <property name="xalign">0</property>
+			      <property name="yalign">0.5</property>
+			      <property name="xpad">0</property>
+			      <property name="ypad">0</property>
+			      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+			      <property name="width_chars">-1</property>
+			      <property name="single_line_mode">False</property>
+			      <property name="angle">0</property>
+			    </widget>
+			    <packing>
+			      <property name="left_attach">0</property>
+			      <property name="right_attach">1</property>
+			      <property name="top_attach">1</property>
+			      <property name="bottom_attach">2</property>
+			      <property name="y_options"></property>
+			    </packing>
+			  </child>
+
+			  <child>
+			    <widget class="GtkSpinButton" id="spinbuttonMinIdr">
+			      <property name="visible">True</property>
+			      <property name="tooltip" translatable="yes">Set minimum frame interval between IDR frames. Defines the minimum amount a frame can be reused and referenced by other frames before a new clean one is established</property>
+			      <property name="can_focus">True</property>
+			      <property name="climb_rate">1</property>
+			      <property name="digits">0</property>
+			      <property name="numeric">True</property>
+			      <property name="update_policy">GTK_UPDATE_ALWAYS</property>
+			      <property name="snap_to_ticks">False</property>
+			      <property name="wrap">False</property>
+			      <property name="adjustment">25 0 100 1 10 10</property>
+			    </widget>
+			    <packing>
+			      <property name="left_attach">1</property>
+			      <property name="right_attach">2</property>
+			      <property name="top_attach">1</property>
+			      <property name="bottom_attach">2</property>
+			      <property name="y_options"></property>
+			    </packing>
+			  </child>
+
+			  <child>
+			    <widget class="GtkSpinButton" id="spinbuttonMaxIdr">
+			      <property name="visible">True</property>
+			      <property name="tooltip" translatable="yes">Set maximum frame interval between IDR frames. Defines the maximum amount a frame can be reused and referenced by other frames before a new clean one is established</property>
+			      <property name="can_focus">True</property>
+			      <property name="climb_rate">1</property>
+			      <property name="digits">0</property>
+			      <property name="numeric">True</property>
+			      <property name="update_policy">GTK_UPDATE_ALWAYS</property>
+			      <property name="snap_to_ticks">False</property>
+			      <property name="wrap">False</property>
+			      <property name="adjustment">250 1 1000 1 10 10</property>
+			    </widget>
+			    <packing>
+			      <property name="left_attach">1</property>
+			      <property name="right_attach">2</property>
+			      <property name="top_attach">2</property>
+			      <property name="bottom_attach">3</property>
+			      <property name="y_options"></property>
+			    </packing>
+			  </child>
+
+			  <child>
+			    <widget class="GtkLabel" id="label18">
+			      <property name="visible">True</property>
+			      <property name="label" translatable="yes">Max IDR frame interval</property>
+			      <property name="use_underline">False</property>
+			      <property name="use_markup">False</property>
+			      <property name="justify">GTK_JUSTIFY_LEFT</property>
+			      <property name="wrap">False</property>
+			      <property name="selectable">False</property>
+			      <property name="xalign">0</property>
+			      <property name="yalign">0.5</property>
+			      <property name="xpad">0</property>
+			      <property name="ypad">0</property>
+			      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+			      <property name="width_chars">-1</property>
+			      <property name="single_line_mode">False</property>
+			      <property name="angle">0</property>
+			    </widget>
+			    <packing>
+			      <property name="left_attach">0</property>
+			      <property name="right_attach">1</property>
+			      <property name="top_attach">2</property>
+			      <property name="bottom_attach">3</property>
+			      <property name="y_options"></property>
+			    </packing>
+			  </child>
 			</widget>
-			<packing>
-			  <property name="padding">0</property>
-			  <property name="expand">True</property>
-			  <property name="fill">True</property>
-			</packing>
 		      </child>
 		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkLabel" id="labelMoreEncodingSettings">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">&lt;b&gt;More Rate Settings&lt;/b&gt;</property>
+		      <property name="use_underline">False</property>
+		      <property name="use_markup">True</property>
+		      <property name="justify">GTK_JUSTIFY_LEFT</property>
+		      <property name="wrap">False</property>
+		      <property name="selectable">False</property>
+		      <property name="xalign">0.5</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xpad">0</property>
+		      <property name="ypad">0</property>
+		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		      <property name="width_chars">-1</property>
+		      <property name="single_line_mode">False</property>
+		      <property name="angle">0</property>
+		    </widget>
 		    <packing>
-		      <property name="padding">0</property>
-		      <property name="expand">True</property>
-		      <property name="fill">True</property>
+		      <property name="type">label_item</property>
 		    </packing>
 		  </child>
 		</widget>
-	      </child>
-
-	      <child>
-		<widget class="GtkLabel" id="label4">
-		  <property name="visible">True</property>
-		  <property name="label" translatable="yes">&lt;b&gt;Settings&lt;/b&gt;</property>
-		  <property name="use_underline">False</property>
-		  <property name="use_markup">True</property>
-		  <property name="justify">GTK_JUSTIFY_LEFT</property>
-		  <property name="wrap">False</property>
-		  <property name="selectable">False</property>
-		  <property name="xalign">0.5</property>
-		  <property name="yalign">0.5</property>
-		  <property name="xpad">0</property>
-		  <property name="ypad">0</property>
-		</widget>
 		<packing>
-		  <property name="type">label_item</property>
+		  <property name="padding">1</property>
+		  <property name="expand">True</property>
+		  <property name="fill">True</property>
 		</packing>
 	      </child>
 	    </widget>
 	    <packing>
-	      <property name="padding">0</property>
-	      <property name="expand">True</property>
-	      <property name="fill">True</property>
+	      <property name="tab_expand">False</property>
+	      <property name="tab_fill">True</property>
 	    </packing>
 	  </child>
+
+	  <child>
+	    <widget class="GtkLabel" id="labelPageRateControl">
+	      <property name="visible">True</property>
+	      <property name="label" translatable="yes">Rate Control</property>
+	      <property name="use_underline">False</property>
+	      <property name="use_markup">False</property>
+	      <property name="justify">GTK_JUSTIFY_LEFT</property>
+	      <property name="wrap">False</property>
+	      <property name="selectable">False</property>
+	      <property name="xalign">0.5</property>
+	      <property name="yalign">0.5</property>
+	      <property name="xpad">0</property>
+	      <property name="ypad">0</property>
+	      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+	      <property name="width_chars">-1</property>
+	      <property name="single_line_mode">False</property>
+	      <property name="angle">0</property>
+	    </widget>
+	    <packing>
+	      <property name="type">tab</property>
+	    </packing>
+	  </child>
 	</widget>
 	<packing>
 	  <property name="padding">0</property>



From mean at mail.berlios.de  Wed Jan 17 20:51:33 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 17 Jan 2007 20:51:33 +0100
Subject: [Avidemux-svn-commit] r2742 - in branches/avidemux_2.4_branch:
	autononreg/utils avidemux/ADM_script avidemux/ADM_toolkit
	avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk
	avidemux/ADM_userInterfaces/ADM_NONE/ADM_gui2
	avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui
Message-ID: <200701171951.l0HJpXgb018968@sheep.berlios.de>

Author: mean
Date: 2007-01-17 20:51:32 +0100 (Wed, 17 Jan 2007)
New Revision: 2742

Added:
   branches/avidemux_2.4_branch/autononreg/utils/dirselect.js
Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_script/ADM_JSFunctions.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_toolkit/filesel.h
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk/TLK_filesel.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_gui2/file_none.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/file_qt4.cpp
Log:
added directory selection + corresponding ecmascript

Added: branches/avidemux_2.4_branch/autononreg/utils/dirselect.js
===================================================================
--- branches/avidemux_2.4_branch/autononreg/utils/dirselect.js	2007-01-17 07:02:28 UTC (rev 2741)
+++ branches/avidemux_2.4_branch/autononreg/utils/dirselect.js	2007-01-17 19:51:32 UTC (rev 2742)
@@ -0,0 +1,30 @@
+//AD  <- 
+/*
+	Simple script that scans the orgDir directory
+	and unpack all avi files
+	The resuling file is put in destDir directory
+
+	Using new directorySearch API
+
+*/
+var app = new Avidemux();
+var orgDir;
+var destDir;
+var reg =new RegExp(".$");
+/*
+	This is for unix
+	For windows change to
+	sep="\\";
+	reg2=new RegExp("\\.*\\");
+*/
+var sep="/";
+var extension;
+var target;
+//
+//
+//
+// 	select files from original & target directories
+//
+	orgDir=dirSelect();
+	displayInfo("Selected :"+orgDir);
+

Modified: branches/avidemux_2.4_branch/avidemux/ADM_script/ADM_JSFunctions.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_script/ADM_JSFunctions.cpp	2007-01-17 07:02:28 UTC (rev 2741)
+++ branches/avidemux_2.4_branch/avidemux/ADM_script/ADM_JSFunctions.cpp	2007-01-17 19:51:32 UTC (rev 2742)
@@ -53,6 +53,7 @@
 JSBool displayError(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
 JSBool displayInfo(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
 JSBool fileWriteSelect(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
+JSBool dirSelect(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
 JSBool fileReadSelect(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
 JSBool print(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
 
@@ -78,6 +79,7 @@
   {"displayInfo",       displayInfo,        1},
   {"fileReadSelect",    fileReadSelect,        0},
   {"fileWriteSelect",   fileWriteSelect,        0},
+  {"dirSelect",         dirSelect,        0},
   {"print",             print,        1},
   {"allFilesFrom",      allFilesFrom,        0},
   {"nextFile",          nextFile,        0},
@@ -198,7 +200,18 @@
         ADM_dealloc(name);
         return JS_TRUE;
 }// end fileWriteSelect
-
+JSBool dirSelect(JSContext *cx, JSObject *obj, uintN argc, 
+                                       jsval *argv, jsval *rval)
+{
+        char name[1024];
+        // default return value
+        if(argc != 0)
+                return JS_FALSE;
+        if(!FileSel_SelectDir(_("Select a directory"),name,1023, NULL))
+         return JS_FALSE;
+        *rval=STRING_TO_JSVAL(JS_NewStringCopyZ(cx,name));
+        return JS_TRUE;
+}
 JSBool print(JSContext *cx, JSObject *obj, uintN argc, 
                                        jsval *argv, jsval *rval)
 {// begin print

Modified: branches/avidemux_2.4_branch/avidemux/ADM_toolkit/filesel.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_toolkit/filesel.h	2007-01-17 07:02:28 UTC (rev 2741)
+++ branches/avidemux_2.4_branch/avidemux/ADM_toolkit/filesel.h	2007-01-17 19:51:32 UTC (rev 2742)
@@ -22,6 +22,7 @@
 void GUI_FileSelWrite(const char *label, char * * name);
 
 uint8_t FileSel_SelectRead(const char *title,char *target,uint32_t max, const char *source);
+uint8_t FileSel_SelectDir(const char *title,char *target,uint32_t max, const char *source);
 
 char *ADM_getBaseDir(void);
 char *ADM_getJobDir(void);

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk/TLK_filesel.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk/TLK_filesel.cpp	2007-01-17 07:02:28 UTC (rev 2741)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk/TLK_filesel.cpp	2007-01-17 19:51:32 UTC (rev 2742)
@@ -52,14 +52,13 @@
 static uint8_t          setFilter( GtkWidget *dialog);
 
 /**
-	Select a file
-		Target is the string allocated by caller that will receive the resule, maxlen byte
-		Source is a optionnal last file to replace the selector at the last dir used
-	@Title@ is the title of the dialog window
-	
-	Returns : 0 if error, 1 on success
-	
-
+    \fn FileSel_SelectRead(const char *title,char *target,uint32_t max, const char *source)
+    \brief allow to select a file
+    @return 0 on failure, 1 on success
+    @param title : window title 
+    @param target : where to copy the result (must be allocated by caller)
+    @param max : Max # of bytes that target can hold
+    @param source : where we start from
 */
 uint8_t FileSel_SelectRead(const char *title,char *target,uint32_t max, const char *source)
 {
@@ -142,7 +141,81 @@
 	gtk_widget_destroy(dialog);
 	return ret;
 }
+/**
+    \fn FileSel_SelectDir(const char *title,char *target,uint32_t max, const char *source)
+    \brief allow to select a directory
+    @return 0 on failure, 1 on success
+    @param title : window title 
+    @param target : where to copy the result (must be allocated by caller)
+    @param max : Max # of bytes that target can hold
+    @param source : where we start from
+*/
+uint8_t FileSel_SelectDir(const char *title,char *target,uint32_t max, const char *source)
+{
+	
+GtkWidget *dialog;
+uint8_t ret=0;
+gchar *selected_filename;
+gchar last;
+char *dupe=NULL,*tmpname=NULL;
+DIR *dir=NULL;
+	
+        dialog = gtk_file_chooser_dialog_new ("Open File",
+                                      NULL,
+                                      GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER,
+                                      GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
+                                      GTK_STOCK_OPEN, GTK_RESPONSE_ACCEPT,
+                                      NULL);
+        gtk_window_set_title (GTK_WINDOW (dialog),title);
+        gtk_register_dialog(dialog);
+        /* Set default dir if provided ..*/
+        if(source)
+        {
+                dupe=PathCanonize(source);
+                PathStripName(dupe);
+                if( (dir=opendir(dupe)) )
+                        {
+                                closedir(dir);
+                                gtk_file_chooser_set_filename(GTK_FILE_CHOOSER(dialog),(gchar *)source);
+                        }
+                delete [] dupe;
+        
+        }
+        else	//use pref
+        {
+                if( prefs->get(LASTDIR_READ,(ADM_filename **)&tmpname))
+                {
+                        
+        
+                        dupe=PathCanonize(tmpname);
+                        PathStripName(dupe);
+  
+                        if( (dir=opendir(dupe)) )
+                        {
+                                closedir(dir);
+                                gtk_file_chooser_set_filename(GTK_FILE_CHOOSER(dialog),(gchar *)dupe);
+                        }
+                        delete [] dupe;
+                }
+        }
 
+        if(gtk_dialog_run(GTK_DIALOG(dialog))==GTK_RESPONSE_ACCEPT)
+        {
+          selected_filename= (gchar *) 	gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(dialog));
+          if(strlen(selected_filename))  /* Nothing selected */
+          {
+            /* Check it is a dir ...*/
+            printf("<%s>\n",selected_filename);; 
+            strncpy(target,selected_filename,max);
+            target[max-1]=0;
+            ret=1;
+          }
+        }	
+        gtk_unregister_dialog(dialog);
+        gtk_widget_destroy(dialog);
+        return ret;
+}
+
 void GUI_FileSelWrite(const char *label, SELFILE_CB * cb)
 {				/* Create the selector */
     GUI_FileSel(label, cb, 1);

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_gui2/file_none.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_gui2/file_none.cpp	2007-01-17 07:02:28 UTC (rev 2741)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_gui2/file_none.cpp	2007-01-17 19:51:32 UTC (rev 2742)
@@ -16,7 +16,10 @@
 #include "ADM_toolkit/toolkit.hxx"
 #include "ADM_toolkit/filesel.h"
 
-
+uint8_t FileSel_SelectDir(const char *title,char *target,uint32_t max, const char *source)
+{ 
+  return 0;
+}
 void GUI_FileSelRead(const char *label,SELFILE_CB cb) 
 {}
 void GUI_FileSelWrite(const char *label,SELFILE_CB cb) 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/file_qt4.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/file_qt4.cpp	2007-01-17 07:02:28 UTC (rev 2741)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/file_qt4.cpp	2007-01-17 19:51:32 UTC (rev 2742)
@@ -25,6 +25,13 @@
 extern QWidget *QuiMainWindows;
 static void GUI_FileSelSelect(const char *label, char **name, uint32_t access) ;
 //****************************************************************************************************
+uint8_t FileSel_SelectDir(const char *title,char *target,uint32_t max, const char *source)
+{
+  
+  GUI_Error_HIG("NOT DONE","This function has not been implemented yet.");
+  return 0; 
+}
+//****************************************************************************************************
 void GUI_FileSelRead(const char *label,SELFILE_CB cb) 
 {
   char *name;



From mean at mail.berlios.de  Thu Jan 18 21:29:00 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 18 Jan 2007 21:29:00 +0100
Subject: [Avidemux-svn-commit] r2743 - in
	branches/avidemux_2.4_branch/avidemux:
	ADM_inputs/ADM_mpegdemuxer ADM_toolkit
Message-ID: <200701182029.l0IKT0n9029589@sheep.berlios.de>

Author: mean
Date: 2007-01-18 21:28:59 +0100 (Thu, 18 Jan 2007)
New Revision: 2743

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_probe.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_probe.h
   branches/avidemux_2.4_branch/avidemux/ADM_toolkit/automation.cpp
Log:
pat parser, beginning

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_probe.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_probe.cpp	2007-01-17 19:51:32 UTC (rev 2742)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_probe.cpp	2007-01-18 20:28:59 UTC (rev 2743)
@@ -27,6 +27,7 @@
 
 #include "ADM_toolkit/toolkit.hxx"
 #include "ADM_toolkit/filesel.h"
+#include "fourcc.h"
 #include "DIA_working.h"
 
 
@@ -53,8 +54,8 @@
 static uint8_t dmx_probeTS(char *file,  uint32_t *nbTracks,MPEG_TRACK **tracks);
 static uint8_t dmx_probeTSBruteForce(char *file,  uint32_t *nbTracks,MPEG_TRACK **tracks);
 static uint8_t dmx_probeMSDVR(char *file, uint32_t *nbTracks,MPEG_TRACK **tracks);
+ uint8_t dmx_probeTSPat(const char *file, uint32_t *nbTracks,MPEG_TRACK **tracks);
 
-
 //****************************************************************************************
 uint8_t dmx_probe(char *file, DMX_TYPE  *type, uint32_t *nbTracks,MPEG_TRACK **tracks)
 {
@@ -524,3 +525,101 @@
       fclose(fd);
       return 1;
 }
+/**
+      \fn     dmx_probeTSPat(char *file, uint32_t *nbTracks,MPEG_TRACK **tracks)
+      \brief  Try to extract info from a Mpeg TS file using PAT, PMT etc..
+      @return 1 on success, 0 on failure
+      @param file: File to scan
+      @param *nbTrack : number of track found (out)
+      @param **tracks : contains info about the tracks found (out)
+
+*/
+uint8_t dmx_probeTSPat(char *file, uint32_t *nbTracks,MPEG_TRACK **tracks)
+{
+
+
+  //
+  // Build a dummy track
+MPEG_TRACK dummy[TS_ALL_PID];
+fileParser *parser;
+uint32_t   foundPid=0;
+myPid      allPid[MAX_FOUND_PID];
+uint8_t    buffer[BUFFER_SIZE];
+MpegAudioInfo mpegInfo; 
+
+    dummy[0].pid=0x00; // should no be in use
+    dummy[0].pes=0xE0;
+
+        dmx_demuxerTS demuxer(1,dummy,1);
+        if(!demuxer.open(file))
+        {
+          return 0;
+        }
+    // Set probe to 10 Meg
+      demuxer.setProbeSize(10*1024*1024L);
+      parser=demuxer.getParser();
+      
+      // And start looking for pat...
+
+      uint32_t pid,left,isPayloadStart,cc,val;
+      uint64_t abs;
+      uint8_t packet[188];
+      while(demuxer.readPacket(&pid,&left, &isPayloadStart,&abs,&cc))
+        
+      {
+#if 0
+        parser->read32(left,packet);
+        mixDump(packet,left);
+        continue;
+#endif 
+        parser->read8i(); /* Adaptation field, fixme */
+        if(isPayloadStart && left > 8) 
+        {
+              /* Decode PSI header */
+              uint32_t tableId;
+              uint32_t misc;
+              uint32_t sectionLength;
+              uint32_t tId;
+              uint32_t version;
+              uint32_t sectionNumber;
+              uint32_t lastSectionNumber;
+              
+              tableId=parser->read8i();
+              misc=parser->read16i();
+              tId=parser->read16i();
+              version=parser->read8i();
+              sectionNumber=parser->read8i();
+              lastSectionNumber=parser->read8i();
+               
+              
+              
+              printf("******************************************\n");
+              printf("tableId        : %d\n",tableId);
+              sectionLength=misc&0xFFF;
+              printf("sectionLength  : %d\n",sectionLength);
+              printf("0              : %x\n",misc&0x40);
+              printf("section syntax : %x\n",misc&0x80);
+              printf("Transport ID   : 0x%x\n",tId);
+              printf("Version Number : 0x%x\n",(version>>1)&0x1F);
+              printf("CurrentNext    : 0x%x\n",version&1);
+              
+              printf("Section        : %d\n",sectionNumber);
+              printf("LastSection    : %d\n",lastSectionNumber);
+              
+              
+              left-=8;
+        } // End of if ..payloadStart
+_next:
+        parser->forward(left);
+      }
+      parser=NULL;
+      return 0;
+}
+uint8_t runProbe(char *file)
+{
+  uint32_t nb;
+  return  dmx_probeTSPat(file, &nb,NULL);
+  
+}
+
+/****EOF**/

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_probe.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_probe.h	2007-01-17 19:51:32 UTC (rev 2742)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_probe.h	2007-01-18 20:28:59 UTC (rev 2743)
@@ -19,4 +19,6 @@
 #ifndef DMX_PROBE
 #define DMX_PROBE
 uint8_t dmx_probe(char *file, DMX_TYPE  *type, uint32_t *nbTracks,MPEG_TRACK **tracks);
+// For test
+uint8_t runProbe(char *f);
 #endif

Modified: branches/avidemux_2.4_branch/avidemux/ADM_toolkit/automation.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_toolkit/automation.cpp	2007-01-17 19:51:32 UTC (rev 2742)
+++ branches/avidemux_2.4_branch/avidemux/ADM_toolkit/automation.cpp	2007-01-18 20:28:59 UTC (rev 2743)
@@ -88,7 +88,7 @@
 static int searchReactionTable(char *string);
 static void call_setPP(char *v,char *s);
 static void call_v2v(char *a,char *b,char *c);
-
+static void call_probePat(char *p);
 extern void updateLoaded(void );
 static void save(char*name);
 extern void show_info(char *p);
@@ -114,6 +114,7 @@
 static void setVar(char *in);
 //
 uint8_t trueFalse(char *p);
+extern uint8_t runProbe(char *file);
 //_________________________________________________________________________
 
 
@@ -195,7 +196,8 @@
 
         {"var",                 1       ,"set var (--var myvar=3)", (one_arg_type)setVar},
         {"help",		0,"print this",		call_help},
-        {"quit",		0,"exit avidemux",	call_quit}
+        {"quit",		0,"exit avidemux",	call_quit},
+        {"probePat",		1,"Probe for PAT//PMT..",	(one_arg_type)call_probePat}
 
 
 }  ;
@@ -391,6 +393,10 @@
 		fprintf(stderr,"audio codec \"%s\" unknown.\n",p);
 	}
 }
+void call_probePat(char *p)
+{
+  runProbe(p); 
+}
 void call_videocodec(char *p)
 {
 #warning fixme : Name does not match !



From mean at mail.berlios.de  Fri Jan 19 20:41:22 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 19 Jan 2007 20:41:22 +0100
Subject: [Avidemux-svn-commit] r2744 -
	branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer
Message-ID: <200701191941.l0JJfMJC020504@sheep.berlios.de>

Author: mean
Date: 2007-01-19 20:41:20 +0100 (Fri, 19 Jan 2007)
New Revision: 2744

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_probe.cpp
Log:
more pat/pmt

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_probe.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_probe.cpp	2007-01-18 20:28:59 UTC (rev 2743)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_probe.cpp	2007-01-19 19:41:20 UTC (rev 2744)
@@ -49,12 +49,26 @@
 
 #define MAX_PROBE (10*1024*1024LL) // Scans the 4 first meg
 #define MIN_DETECT (10*1024) // Need this to say the stream is present
+#define MAX_NB_PMT 50
+//****************************************************************************************
+typedef struct MPEG_PMT
+{
+   uint32_t programNumber;
+   uint32_t tid;
+}MPEG_PMT;
+//****************************************************************************************
 
 static uint8_t dmx_probePS(char *file,  uint32_t *nbTracks,MPEG_TRACK **tracks);
 static uint8_t dmx_probeTS(char *file,  uint32_t *nbTracks,MPEG_TRACK **tracks);
 static uint8_t dmx_probeTSBruteForce(char *file,  uint32_t *nbTracks,MPEG_TRACK **tracks);
 static uint8_t dmx_probeMSDVR(char *file, uint32_t *nbTracks,MPEG_TRACK **tracks);
+/* For mpeg TS with PSI only */
+static uint8_t dmx_probePat(dmx_demuxerTS *demuxer, uint32_t *nbPmt,MPEG_PMT *pmts,uint32_t maxPmt);
+static uint8_t dmx_probePMT(dmx_demuxerTS *demuxer, uint32_t pmtId);
+
  uint8_t dmx_probeTSPat(const char *file, uint32_t *nbTracks,MPEG_TRACK **tracks);
+ 
+extern uint32_t mpegTsCRC(uint8_t *data, uint32_t len);
 
 //****************************************************************************************
 uint8_t dmx_probe(char *file, DMX_TYPE  *type, uint32_t *nbTracks,MPEG_TRACK **tracks)
@@ -536,10 +550,6 @@
 */
 uint8_t dmx_probeTSPat(char *file, uint32_t *nbTracks,MPEG_TRACK **tracks)
 {
-
-
-  //
-  // Build a dummy track
 MPEG_TRACK dummy[TS_ALL_PID];
 fileParser *parser;
 uint32_t   foundPid=0;
@@ -557,23 +567,57 @@
         }
     // Set probe to 10 Meg
       demuxer.setProbeSize(10*1024*1024L);
-      parser=demuxer.getParser();
+      uint32_t nbPmt;
+      MPEG_PMT pmts[MAX_NB_PMT];
+
       
+      if(!dmx_probePat(&demuxer,&nbPmt,pmts,MAX_NB_PMT))
+      {
+        printf("[PSI Probe]Cannot find Pat\n"); 
+        parser=NULL;
+        return 0;
+      }
+      printf("Found %d PMT..\n",nbPmt);
+      for(int i=0;i<nbPmt;i++)
+      {
+         dmx_probePMT(&demuxer, pmts[i].tid);
+      }
+}
+uint8_t runProbe(char *file)
+{
+  uint32_t nb;
+  return  dmx_probeTSPat(file, &nb,NULL);
+  
+}
+/**
+      \fn     dmx_probePat(dmx_demuxerTS *demuxer, uint32_t *nbPmt,MPEG_PMT *pmts,uint32_t maxPMT)
+      \brief  Search for PAT and returns PMT info if found
+      @return 1 on success, 0 on failure
+      @param demuxer: mpegTS demuxer (input)
+      @param *nbPmt : number of PMTS found (output)
+      @param *pmts : contains info about the PMT found (out but must be allocated by caller)
+      @param maxPMT : Maximum # of PMT we accept in pmts (in)
+
+*/
+uint8_t dmx_probePat(dmx_demuxerTS *demuxer, uint32_t *nbPmt,MPEG_PMT *pmts,uint32_t maxPmt)
+{
+  
+  uint8_t    buffer[BUFFER_SIZE];
+  fileParser *parser;
+  
+    
+      demuxer->changePid(0,0); // Search PAT
+      parser=demuxer->getParser();
+      
       // And start looking for pat...
 
       uint32_t pid,left,isPayloadStart,cc,val;
       uint64_t abs;
-      uint8_t packet[188];
-      while(demuxer.readPacket(&pid,&left, &isPayloadStart,&abs,&cc))
+      uint8_t packet[TS_PACKET_SIZE];
+      while(demuxer->readPacket(&pid,&left, &isPayloadStart,&abs,&cc))
         
       {
-#if 0
-        parser->read32(left,packet);
-        mixDump(packet,left);
-        continue;
-#endif 
-        parser->read8i(); /* Adaptation field, fixme */
-        if(isPayloadStart && left > 8) 
+        if(isPayloadStart && left > (9+4)) 
         {
               /* Decode PSI header */
               uint32_t tableId;
@@ -583,19 +627,26 @@
               uint32_t version;
               uint32_t sectionNumber;
               uint32_t lastSectionNumber;
+              uint32_t programInfoLength;
+              uint32_t crc,crccomputed;
+              uint64_t startPos,endPos;
               
+              *nbPmt=0;
+              
+              parser->read8i(); /* Pointer field, can be ignored for pat (?) */
+              parser->getpos(&startPos);
               tableId=parser->read8i();
               misc=parser->read16i();
               tId=parser->read16i();
               version=parser->read8i();
               sectionNumber=parser->read8i();
               lastSectionNumber=parser->read8i();
-               
               
-              
+              sectionLength=misc&0xFFF;
+#ifdef PROBE_TS_VERBOSE
               printf("******************************************\n");
               printf("tableId        : %d\n",tableId);
-              sectionLength=misc&0xFFF;
+              
               printf("sectionLength  : %d\n",sectionLength);
               printf("0              : %x\n",misc&0x40);
               printf("section syntax : %x\n",misc&0x80);
@@ -606,20 +657,195 @@
               printf("Section        : %d\n",sectionNumber);
               printf("LastSection    : %d\n",lastSectionNumber);
               
-              
-              left-=8;
+#endif              
+              left-=9;
+              programInfoLength=sectionLength-5;
+              /* Now get the PMT indexes and type */
+              printf("**\n");
+              while(programInfoLength >4 && left>8)
+              {
+                  printf("**\n");
+                  pmts[*nbPmt].programNumber=parser->read16i()&0xFFFF;
+                  pmts[*nbPmt].tid=parser->read16i()&0x1FFF;
+                  printf(" Program Number :%03x\n",pmts[*nbPmt].programNumber);
+                  printf(" PID for this   :%03x\n",pmts[*nbPmt].tid);
+                  if((*nbPmt)<maxPmt)
+                      (*nbPmt)++;
+                  left-=4;
+                  programInfoLength-=4;
+              }
+              printf("program info :%d left:%d\n",programInfoLength,left);
+              /* Now check CRC */
+              parser->getpos(&endPos);
+              if(programInfoLength==4)
+              {
+                parser->getpos(&endPos);
+                //
+                uint32_t size=(uint32_t)(endPos-startPos);
+                uint8_t data[size+1];
+                parser->setpos(startPos);
+                parser->read32(size,data);
+                parser->setpos(endPos);
+                crc=parser->read32i(); 
+                left-=4;
+
+                crccomputed=mpegTsCRC(data,size);
+                if(crc!=crccomputed)
+                {
+                  printf("Incorrect Checksum %x / %x\n",crc,crccomputed); 
+                  *nbPmt=0;
+                }else
+                {
+                  printf("Crc ok %d pmt\n",*nbPmt); 
+                  return 1;
+                }
+                
+              }
+              /*    Re-read the whole block to check its CRC     */
         } // End of if ..payloadStart
 _next:
         parser->forward(left);
       }
-      parser=NULL;
       return 0;
 }
-uint8_t runProbe(char *file)
+/**
+      \fn     dmx_probePat(dmx_demuxerTS *demuxer, uint32_t *nbPmt,MPEG_PMT *pmts,uint32_t maxPMT)
+      \brief  Search for PAT and returns PMT info if found
+      @return 1 on success, 0 on failure
+      @param demuxer: mpegTS demuxer (input)
+      @param *nbPmt : number of PMTS found (output)
+      @param *pmts : contains info about the PMT found (out but must be allocated by caller)
+      @param maxPMT : Maximum # of PMT we accept in pmts (in)
+
+*/
+uint8_t dmx_probePMT(dmx_demuxerTS *demuxer, uint32_t pmtId)
 {
-  uint32_t nb;
-  return  dmx_probeTSPat(file, &nb,NULL);
   
+  uint8_t    buffer[BUFFER_SIZE];
+  fileParser *parser;
+  
+      printf("Searching for PMT, pid=0x%x\n",pmtId);
+      demuxer->changePid(pmtId,pmtId); // Search this PMT
+      parser=demuxer->getParser();
+      demuxer->setPos(0,0);
+      // And start looking for pat...
+
+      uint32_t pid,left,isPayloadStart,cc,val;
+      uint64_t abs;
+      uint8_t packet[TS_PACKET_SIZE];
+      while(demuxer->readPacket(&pid,&left, &isPayloadStart,&abs,&cc))
+        
+      {
+        if(pid!=pmtId) // Not our Pid..
+        {
+          continue;
+        }
+        if(isPayloadStart && left > (9+4)) 
+        {
+              /* Decode PSI header */
+              uint32_t tableId;
+              uint32_t misc;
+              uint32_t sectionLength;
+              uint32_t tId;
+              uint32_t version;
+              uint32_t sectionNumber;
+              uint32_t lastSectionNumber;
+              uint32_t programInfoLength;
+              uint32_t crc,crccomputed;
+              uint64_t startPos,endPos;
+              uint32_t lenToScan;
+              
+              parser->read8i(); /* Pointer field, can be ignored for pat (?) */
+              parser->getpos(&startPos);
+              tableId=parser->read8i();
+              misc=parser->read16i();
+              tId=parser->read16i();
+              version=parser->read8i();
+              sectionNumber=parser->read8i();
+              lastSectionNumber=parser->read8i();
+              
+              sectionLength=misc&0xFFF;
+#ifdef PROBE_TS_VERBOSE
+              printf("******************************************\n");
+              printf("tableId        : %d\n",tableId);
+              
+              printf("sectionLength  : %d\n",sectionLength);
+              printf("0              : %x\n",misc&0x40);
+              printf("section syntax : %x\n",misc&0x80);
+              printf("Transport ID   : 0x%x\n",tId);
+              printf("Version Number : 0x%x\n",(version>>1)&0x1F);
+              printf("CurrentNext    : 0x%x\n",version&1);
+              
+              printf("Section        : %d\n",sectionNumber);
+              printf("LastSection    : %d\n",lastSectionNumber);
+              
+#endif              
+              left-=9;
+              lenToScan=sectionLength-5;
+              /* Now get the PMT content*/
+              printf("**\n");
+              //_________________________________________________________
+              uint32_t pcr;
+              
+              pcr=parser->read16i() & 0x1fff;
+              programInfoLength=parser->read16i() & 0x0FFF;
+              
+              printf("PCR TID       :0x%x\n",pcr);
+              printf("Length        :%d\n",programInfoLength);
+              // Skip descriptors
+              parser->forward(programInfoLength);
+              left-=(4+programInfoLength);
+              lenToScan-=(4+programInfoLength);
+              
+              // Now loop
+               while(lenToScan >4 && left>8)
+              {
+                  uint8_t streamType;
+                  uint32_t pid,esDescLen;
+                  printf("**\n");
+                  streamType=parser->read8i();
+                  pid       =parser->read16i()&0x1FFFF;
+                  esDescLen =parser->read16i()&0x0FFF;
+                  printf("Stream Type :0x%x\n",streamType);
+                  printf("Pid         :0x%x\n",pid);
+                  printf("ES Len      :%d\n",esDescLen);
+                  parser->forward(esDescLen);
+                  left-=(5+esDescLen);
+                  lenToScan-=(5+esDescLen);
+              }
+              //_________________________________________________________
+              /*   And CRC */
+              parser->getpos(&endPos);
+              if(lenToScan==4)
+              {
+                parser->getpos(&endPos);
+                //
+                uint32_t size=(uint32_t)(endPos-startPos);
+                uint8_t data[size+1];
+                parser->setpos(startPos);
+                parser->read32(size,data);
+                parser->setpos(endPos);
+                crc=parser->read32i(); 
+                left-=4;
+
+                crccomputed=mpegTsCRC(data,size);
+                if(crc!=crccomputed)
+                {
+                  printf("Incorrect Checksum %x / %x\n",crc,crccomputed); 
+
+                }else
+                {
+                  printf("Crc ok\n"); 
+                  return 1;
+                }
+                
+              }
+              /*    Re-read the whole block to check its CRC     */
+        } // End of if ..payloadStart
+_next:
+        parser->forward(left);
+      }
+      return 0;
 }
 
 /****EOF**/



From mean at mail.berlios.de  Sat Jan 20 11:44:44 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 20 Jan 2007 11:44:44 +0100
Subject: [Avidemux-svn-commit] r2745 -
	branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer
Message-ID: <200701201044.l0KAiikD011662@sheep.berlios.de>

Author: mean
Date: 2007-01-20 11:44:43 +0100 (Sat, 20 Jan 2007)
New Revision: 2745

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_probe.cpp
Log:
more PAT/PMT/...

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_probe.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_probe.cpp	2007-01-19 19:41:20 UTC (rev 2744)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_probe.cpp	2007-01-20 10:44:43 UTC (rev 2745)
@@ -578,6 +578,7 @@
         return 0;
       }
       printf("Found %d PMT..\n",nbPmt);
+      demuxer.setProbeSize(40*1024*1024L); // We can can increase the probe size
       for(int i=0;i<nbPmt;i++)
       {
          dmx_probePMT(&demuxer, pmts[i].tid);
@@ -590,59 +591,72 @@
   
 }
 /**
-      \fn     dmx_probePat(dmx_demuxerTS *demuxer, uint32_t *nbPmt,MPEG_PMT *pmts,uint32_t maxPMT)
-      \brief  Search for PAT and returns PMT info if found
+      \fn     dmx_searchAndSkipHeader
+      \brief  Search for a given PSI and skip header
       @return 1 on success, 0 on failure
-      @param demuxer: mpegTS demuxer (input)
-      @param *nbPmt : number of PMTS found (output)
-      @param *pmts : contains info about the PMT found (out but must be allocated by caller)
-      @param maxPMT : Maximum # of PMT we accept in pmts (in)
+      @param myPid : Pid of the looked for psi
+      @param demuxer: mpegTS demuxer *(input)
+      @param *currentSec : current section (output)
+      @param *maxSec : #of sections (output)
+      @param *leftbyte : Total #of bytes left in the packet
+      @param *payloadSize : #of bytes of usable payload
 
 */
-uint8_t dmx_probePat(dmx_demuxerTS *demuxer, uint32_t *nbPmt,MPEG_PMT *pmts,uint32_t maxPmt)
+uint8_t dmx_searchAndSkipHeader(uint32_t myPid,dmx_demuxerTS *demuxer,uint32_t *currentSec, uint32_t *maxSec,
+                                    uint32_t *leftbyte,uint32_t *payloadSize)
 {
   
-  uint8_t    buffer[BUFFER_SIZE];
+  uint8_t packet[TS_PACKET_SIZE];
+  uint32_t tableId;
+  uint32_t misc;
+  uint32_t sectionLength;
+  uint32_t tId,pid,left,cc,nbPmt;
+  uint32_t version,isPayloadStart;
+  uint32_t sectionNumber;
+  uint32_t lastSectionNumber;
+  uint32_t programInfoLength;
+  uint32_t crc,crccomputed;
+  uint64_t startPos,endPos,abso;
   fileParser *parser;
-  
-    
-      demuxer->changePid(0,0); // Search PAT
+      demuxer->changePid(myPid,myPid); // Search PAT
       parser=demuxer->getParser();
       
-      // And start looking for pat...
-
-      uint32_t pid,left,isPayloadStart,cc,val;
-      uint64_t abs;
-      uint8_t packet[TS_PACKET_SIZE];
-      while(demuxer->readPacket(&pid,&left, &isPayloadStart,&abs,&cc))
-        
-      {
-        if(isPayloadStart && left > (9+4)) 
+        while(demuxer->readPacket(&pid,&left, &isPayloadStart,&abso,&cc))
         {
-              /* Decode PSI header */
-              uint32_t tableId;
-              uint32_t misc;
-              uint32_t sectionLength;
-              uint32_t tId;
-              uint32_t version;
-              uint32_t sectionNumber;
-              uint32_t lastSectionNumber;
-              uint32_t programInfoLength;
-              uint32_t crc,crccomputed;
-              uint64_t startPos,endPos;
+          if(pid!=myPid)
+          {
+            printf("Wrong Pid %x/%x\n",pid,myPid);
+            parser->forward(left);
+            continue;
+          }
+          if(!isPayloadStart || left <= (9+4))
+          {
+            parser->forward(left);
+            continue;
+          }
+
+          /* Found something that looks good...*/
+            
+            /* Decode PSI header */
+            parser->read8i(); /* Pointer field, can be ignored (?) */
               
-              *nbPmt=0;
-              
-              parser->read8i(); /* Pointer field, can be ignored for pat (?) */
-              parser->getpos(&startPos);
+              parser->getpos(&startPos); /* Memorize beginning */
               tableId=parser->read8i();
-              misc=parser->read16i();
-              tId=parser->read16i();
-              version=parser->read8i();
+              misc=parser->read16i(); // +3
+              tId=parser->read16i();  
+              version=parser->read8i(); // +6
               sectionNumber=parser->read8i();
-              lastSectionNumber=parser->read8i();
+              lastSectionNumber=parser->read8i(); // +8
               
               sectionLength=misc&0xFFF;
+              
+              if(sectionLength<=9 || left <=9)
+              {
+                printf("SectionLength too short :%d\n", sectionLength);
+                 parser->setpos(startPos-1+left); // skip packet
+                 continue;
+              }
+              
 #ifdef PROBE_TS_VERBOSE
               printf("******************************************\n");
               printf("tableId        : %d\n",tableId);
@@ -657,57 +671,85 @@
               printf("Section        : %d\n",sectionNumber);
               printf("LastSection    : %d\n",lastSectionNumber);
               
-#endif              
-              left-=9;
-              programInfoLength=sectionLength-5;
-              /* Now get the PMT indexes and type */
-              printf("**\n");
-              while(programInfoLength >4 && left>8)
+#endif
+              // Check for error FIXME TODO
+              
+              // Check CRC
+              parser->getpos(&endPos); // Here payload begins
+              parser->setpos(startPos);
+              parser->read32(sectionLength-1,packet); // Go back & Read Whole packet +3 for header -4 CRC
+              crc=parser->read32i();
+              crccomputed=mpegTsCRC(packet,sectionLength-1);
+              if(crc!=crccomputed) // Bad CRC, skip packet
               {
+                printf("Bad CRC\n");
+                parser->setpos( startPos+left-1); // skip
+                continue;
+              }
+              // CRC is ok, go back to interesting place
+              printf("CRC OK\n");
+              parser->setpos(endPos);
+              *currentSec=sectionNumber;
+              *maxSec=lastSectionNumber;
+              
+              *leftbyte=left-9;               // Total bytes left in packet
+              *payloadSize=sectionLength-9; // No CRC, No header
+              return 1;
+          } // /while
+      return 0;
+}
+/**
+      \fn     dmx_probePat(dmx_demuxerTS *demuxer, uint32_t *nbPmt,MPEG_PMT *pmts,uint32_t maxPMT)
+      \brief  Search for PAT and returns PMT info if found
+      @return 1 on success, 0 on failure
+      @param demuxer: mpegTS demuxer (input)
+      @param *nbPmt : number of PMTS found (output)
+      @param *pmts : contains info about the PMT found (out but must be allocated by caller)
+      @param maxPMT : Maximum # of PMT we accept in pmts (in)
+
+*/
+uint8_t dmx_probePat(dmx_demuxerTS *demuxer, uint32_t *nbPmt,MPEG_PMT *pmts,uint32_t maxPmt)
+{
+  
+  fileParser *parser;
+  uint32_t curSection,maxSection;
+  uint32_t left,toScan;
+  
+      parser=demuxer->getParser();
+      *nbPmt=0;
+      if(dmx_searchAndSkipHeader(0,demuxer,&curSection, &maxSection,&left,&toScan))
+      {
+        
+              while(toScan >=4 && left>=8)
+              {
                   printf("**\n");
                   pmts[*nbPmt].programNumber=parser->read16i()&0xFFFF;
                   pmts[*nbPmt].tid=parser->read16i()&0x1FFF;
-                  printf(" Program Number :%03x\n",pmts[*nbPmt].programNumber);
-                  printf(" PID for this   :%03x\n",pmts[*nbPmt].tid);
+                  printf(" [PAT]Program Number :%03x\n",pmts[*nbPmt].programNumber);
+                  printf(" [PAT]PID for this   :%03x\n",pmts[*nbPmt].tid);
                   if((*nbPmt)<maxPmt)
                       (*nbPmt)++;
                   left-=4;
-                  programInfoLength-=4;
+                  toScan-=4;
               }
-              printf("program info :%d left:%d\n",programInfoLength,left);
-              /* Now check CRC */
-              parser->getpos(&endPos);
-              if(programInfoLength==4)
-              {
-                parser->getpos(&endPos);
-                //
-                uint32_t size=(uint32_t)(endPos-startPos);
-                uint8_t data[size+1];
-                parser->setpos(startPos);
-                parser->read32(size,data);
-                parser->setpos(endPos);
-                crc=parser->read32i(); 
-                left-=4;
-
-                crccomputed=mpegTsCRC(data,size);
-                if(crc!=crccomputed)
-                {
-                  printf("Incorrect Checksum %x / %x\n",crc,crccomputed); 
-                  *nbPmt=0;
-                }else
-                {
-                  printf("Crc ok %d pmt\n",*nbPmt); 
-                  return 1;
-                }
-                
-              }
-              /*    Re-read the whole block to check its CRC     */
-        } // End of if ..payloadStart
-_next:
-        parser->forward(left);
+              return 1;
+        
       }
       return 0;
 }
+const char *toString(uint32_t type)
+{
+ switch(type)
+ {
+   case 1:case 2: return "Mpeg Video";
+   case 3:case 4: return "Mpeg Audio";
+   case 0x1B: return "H264";
+   case 0x81: return "Private (AC3?)";
+   
+   default: return "???"; 
+ }
+  return "???";
+}
 /**
       \fn     dmx_probePat(dmx_demuxerTS *demuxer, uint32_t *nbPmt,MPEG_PMT *pmts,uint32_t maxPMT)
       \brief  Search for PAT and returns PMT info if found
@@ -721,129 +763,40 @@
 uint8_t dmx_probePMT(dmx_demuxerTS *demuxer, uint32_t pmtId)
 {
   
-  uint8_t    buffer[BUFFER_SIZE];
   fileParser *parser;
+  uint32_t curSection,maxSection;
+  uint32_t left,toScan,programInfo;
   
       printf("Searching for PMT, pid=0x%x\n",pmtId);
-      demuxer->changePid(pmtId,pmtId); // Search this PMT
-      parser=demuxer->getParser();
+      demuxer->changePid(pmtId,pmtId); // change pid as setPos will seek for them
       demuxer->setPos(0,0);
-      // And start looking for pat...
-
-      uint32_t pid,left,isPayloadStart,cc,val;
-      uint64_t abs;
-      uint8_t packet[TS_PACKET_SIZE];
-      while(demuxer->readPacket(&pid,&left, &isPayloadStart,&abs,&cc))
-        
+      parser=demuxer->getParser();
+      if(dmx_searchAndSkipHeader(pmtId,demuxer,&curSection, &maxSection,&left,&toScan))
       {
-        if(pid!=pmtId) // Not our Pid..
-        {
-          continue;
-        }
-        if(isPayloadStart && left > (9+4)) 
-        {
-              /* Decode PSI header */
-              uint32_t tableId;
-              uint32_t misc;
-              uint32_t sectionLength;
-              uint32_t tId;
-              uint32_t version;
-              uint32_t sectionNumber;
-              uint32_t lastSectionNumber;
-              uint32_t programInfoLength;
-              uint32_t crc,crccomputed;
-              uint64_t startPos,endPos;
-              uint32_t lenToScan;
-              
-              parser->read8i(); /* Pointer field, can be ignored for pat (?) */
-              parser->getpos(&startPos);
-              tableId=parser->read8i();
-              misc=parser->read16i();
-              tId=parser->read16i();
-              version=parser->read8i();
-              sectionNumber=parser->read8i();
-              lastSectionNumber=parser->read8i();
-              
-              sectionLength=misc&0xFFF;
-#ifdef PROBE_TS_VERBOSE
-              printf("******************************************\n");
-              printf("tableId        : %d\n",tableId);
-              
-              printf("sectionLength  : %d\n",sectionLength);
-              printf("0              : %x\n",misc&0x40);
-              printf("section syntax : %x\n",misc&0x80);
-              printf("Transport ID   : 0x%x\n",tId);
-              printf("Version Number : 0x%x\n",(version>>1)&0x1F);
-              printf("CurrentNext    : 0x%x\n",version&1);
-              
-              printf("Section        : %d\n",sectionNumber);
-              printf("LastSection    : %d\n",lastSectionNumber);
-              
-#endif              
-              left-=9;
-              lenToScan=sectionLength-5;
-              /* Now get the PMT content*/
-              printf("**\n");
-              //_________________________________________________________
-              uint32_t pcr;
-              
-              pcr=parser->read16i() & 0x1fff;
-              programInfoLength=parser->read16i() & 0x0FFF;
-              
-              printf("PCR TID       :0x%x\n",pcr);
-              printf("Length        :%d\n",programInfoLength);
-              // Skip descriptors
-              parser->forward(programInfoLength);
-              left-=(4+programInfoLength);
-              lenToScan-=(4+programInfoLength);
-              
-              // Now loop
-               while(lenToScan >4 && left>8)
+               printf("[PMT]PCR for it    :x%x\n",parser->read16i()&0x1FFF);
+               programInfo=parser->read16i() & 0x0FFF;
+               printf("[PMT]Program Info  :%d\n",programInfo);
+               parser->forward(programInfo);
+               toScan-=(2+programInfo);
+               left-=(2+programInfo);
+               while(toScan >=5 )
               {
                   uint8_t streamType;
                   uint32_t pid,esDescLen;
                   printf("**\n");
                   streamType=parser->read8i();
-                  pid       =parser->read16i()&0x1FFFF;
+                  pid       =parser->read16i()&0x1FFF;
                   esDescLen =parser->read16i()&0x0FFF;
-                  printf("Stream Type :0x%x\n",streamType);
-                  printf("Pid         :0x%x\n",pid);
-                  printf("ES Len      :%d\n",esDescLen);
+                  printf("[PMT]Stream Type :0x%x (%s)\n",streamType,toString(streamType));
+                  printf("[PMT]Pid         :0x%x\n",pid);
+                  printf("[PMT]ES Len      :%d\n",esDescLen);
+                  
                   parser->forward(esDescLen);
                   left-=(5+esDescLen);
-                  lenToScan-=(5+esDescLen);
+                  toScan-=(5+esDescLen);
+                  printf("[PMT]left %u toscan %u\n",left,toScan);
               }
-              //_________________________________________________________
-              /*   And CRC */
-              parser->getpos(&endPos);
-              if(lenToScan==4)
-              {
-                parser->getpos(&endPos);
-                //
-                uint32_t size=(uint32_t)(endPos-startPos);
-                uint8_t data[size+1];
-                parser->setpos(startPos);
-                parser->read32(size,data);
-                parser->setpos(endPos);
-                crc=parser->read32i(); 
-                left-=4;
-
-                crccomputed=mpegTsCRC(data,size);
-                if(crc!=crccomputed)
-                {
-                  printf("Incorrect Checksum %x / %x\n",crc,crccomputed); 
-
-                }else
-                {
-                  printf("Crc ok\n"); 
-                  return 1;
-                }
-                
-              }
-              /*    Re-read the whole block to check its CRC     */
-        } // End of if ..payloadStart
-_next:
-        parser->forward(left);
+              
       }
       return 0;
 }



From mean at mail.berlios.de  Sat Jan 20 16:16:02 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 20 Jan 2007 16:16:02 +0100
Subject: [Avidemux-svn-commit] r2746 - in
	branches/avidemux_2.4_branch/avidemux:
	ADM_inputs/ADM_mpegdemuxer ADM_toolkit
	ADM_userInterfaces/ADM_GTK/ADM_dialog
	ADM_userInterfaces/ADM_NONE/ADM_dialog
	ADM_userInterfaces/ADM_QT4/ADM_dialog
	ADM_userInterfaces/ADM_commonUI
Message-ID: <200701201516.l0KFG25k003038@sheep.berlios.de>

Author: mean
Date: 2007-01-20 16:15:58 +0100 (Sat, 20 Jan 2007)
New Revision: 2746

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_probeTS.cpp
Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/Makefile.am
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxer.h
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerES.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerEs.h
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerMSDVR.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerMSDVR.h
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerPS.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerPS.h
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerTS.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerTS.h
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_identify.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_identify.h
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer.h
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_io.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_io.h
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_probe.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_probe.h
   branches/avidemux_2.4_branch/avidemux/ADM_toolkit/automation.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_idx_pg.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_indexing.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_indexing.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_idx_pg.h
Log:
use PAT/PMT

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/Makefile.am	2007-01-20 10:44:43 UTC (rev 2745)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/Makefile.am	2007-01-20 15:15:58 UTC (rev 2746)
@@ -6,7 +6,7 @@
 
 libADM_mpegdemuxer_a_METASOURCES = AUTO
 
-libADM_mpegdemuxer_a_SOURCES = dmx_io.cpp dmx_demuxer.cpp dmx_indexer.cpp dmx_demuxerES.cpp dmx_video.cpp dmx_demuxerPS.cpp dmx_identify.cpp dmx_audio.cpp dmx_probe.cpp dmx_demuxerTS.cpp dmx_demuxerMSDVR.cpp dmx_demuxerMSDVR.h
+libADM_mpegdemuxer_a_SOURCES = dmx_io.cpp dmx_demuxer.cpp dmx_indexer.cpp dmx_demuxerES.cpp dmx_video.cpp dmx_demuxerPS.cpp dmx_identify.cpp dmx_audio.cpp dmx_probe.cpp dmx_probeTS.cpp dmx_demuxerTS.cpp dmx_demuxerMSDVR.cpp dmx_demuxerMSDVR.h
 
 
 EXTRA_DIST = dmx_audio.cpp      dmx_demuxerEs.h  \

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxer.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxer.h	2007-01-20 10:44:43 UTC (rev 2745)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxer.h	2007-01-20 15:15:58 UTC (rev 2746)
@@ -33,7 +33,7 @@
 	  		   dmx_demuxer();
 		virtual    ~dmx_demuxer();	       
 		
-		virtual    uint8_t   	open(char *name)=0;
+		virtual    uint8_t   	open(const char *name)=0;
 	        virtual    uint8_t      hasAudio(void) { return 0;}                
 		
 		virtual uint8_t 	forward(uint32_t f)=0;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerES.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerES.cpp	2007-01-20 10:44:43 UTC (rev 2745)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerES.cpp	2007-01-20 15:15:58 UTC (rev 2746)
@@ -40,7 +40,7 @@
         if(parser) delete parser;
         parser=NULL;
 }
-uint8_t dmx_demuxerES::open(char *name)
+uint8_t dmx_demuxerES::open(const char *name)
 {
 FP_TYPE fp=FP_DONT_APPEND;
         if(! parser->open(name,&fp)) return 0;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerEs.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerEs.h	2007-01-20 10:44:43 UTC (rev 2745)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerEs.h	2007-01-20 15:15:58 UTC (rev 2746)
@@ -33,7 +33,7 @@
                            dmx_demuxerES() ;
                 virtual    ~dmx_demuxerES();             
                 
-                     uint8_t      open(char *name);
+                     uint8_t      open(const char *name);
                  
                 
                   uint8_t         forward(uint32_t f);

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerMSDVR.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerMSDVR.cpp	2007-01-20 10:44:43 UTC (rev 2745)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerMSDVR.cpp	2007-01-20 15:15:58 UTC (rev 2746)
@@ -373,7 +373,7 @@
           return 0;
 }
 /***********************************************/
-uint8_t dmx_demuxerMSDVR::open(char *name)
+uint8_t dmx_demuxerMSDVR::open(const char *name)
 {
   int r=5;
   const chunky *id=NULL;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerMSDVR.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerMSDVR.h	2007-01-20 10:44:43 UTC (rev 2745)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerMSDVR.h	2007-01-20 15:15:58 UTC (rev 2746)
@@ -65,7 +65,7 @@
                 dmx_demuxerMSDVR(uint32_t nb,MPEG_TRACK *tracks,uint32_t multi) ;
     virtual    ~dmx_demuxerMSDVR();             
                 
-    uint8_t      open(char *name);
+    uint8_t      open(const char *name);
                  
                 
     uint8_t         forward(uint32_t f);

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerPS.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerPS.cpp	2007-01-20 10:44:43 UTC (rev 2745)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerPS.cpp	2007-01-20 15:15:58 UTC (rev 2746)
@@ -138,7 +138,7 @@
 		_probeSize=sz;
 		return 1;
 }
-uint8_t dmx_demuxerPS::open(char *name)
+uint8_t dmx_demuxerPS::open(const char *name)
 {
 FP_TYPE fp=FP_DONT_APPEND;
         if(_multi) fp=FP_APPEND;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerPS.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerPS.h	2007-01-20 10:44:43 UTC (rev 2745)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerPS.h	2007-01-20 15:15:58 UTC (rev 2746)
@@ -60,7 +60,7 @@
                            dmx_demuxerPS(uint32_t nb,MPEG_TRACK *tracks,uint32_t multi) ;
                 virtual    ~dmx_demuxerPS();             
                 
-                     uint8_t      open(char *name);
+                     uint8_t      open(const char *name);
                  
                 
                   uint8_t         forward(uint32_t f);

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerTS.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerTS.cpp	2007-01-20 10:44:43 UTC (rev 2745)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerTS.cpp	2007-01-20 15:15:58 UTC (rev 2746)
@@ -112,7 +112,7 @@
 		_probeSize=sz;
 		return 1;
 }
-uint8_t dmx_demuxerTS::open(char *name)
+uint8_t dmx_demuxerTS::open(const char *name)
 {
 FP_TYPE fp=FP_DONT_APPEND;
         

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerTS.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerTS.h	2007-01-20 10:44:43 UTC (rev 2745)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerTS.h	2007-01-20 15:15:58 UTC (rev 2746)
@@ -70,7 +70,7 @@
                            dmx_demuxerTS(uint32_t nb,MPEG_TRACK *tracks,uint32_t psi) ;
                 virtual    ~dmx_demuxerTS();             
                 
-                     uint8_t      open(char *name);
+                     uint8_t      open(const char *name);
                  
                   fileParser      *getParser(void) {return parser;}
                   uint8_t         forward(uint32_t f);

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_identify.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_identify.cpp	2007-01-20 10:44:43 UTC (rev 2745)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_identify.cpp	2007-01-20 15:15:58 UTC (rev 2746)
@@ -36,7 +36,7 @@
 
 static uint8_t probeTs(fileParser *parser);
 
-DMX_TYPE dmxIdentify(char *name)
+DMX_TYPE dmxIdentify(const char *name)
 {
 DMX_TYPE ret=DMX_MPG_UNKNOWN;
 uint64_t pos;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_identify.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_identify.h	2007-01-20 10:44:43 UTC (rev 2745)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_identify.h	2007-01-20 15:15:58 UTC (rev 2746)
@@ -13,5 +13,5 @@
         DMX_MPG_TS,
         DMX_MPG_MSDVR
 }DMX_TYPE;
-DMX_TYPE dmxIdentify(char *name);
+DMX_TYPE dmxIdentify(const char *name);
 #endif

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer.cpp	2007-01-20 10:44:43 UTC (rev 2745)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer.cpp	2007-01-20 15:15:58 UTC (rev 2746)
@@ -52,7 +52,7 @@
 static uint8_t gopDump(FILE *fd,dmx_demuxer *demuxer,uint64_t abs,uint64_t rel,uint32_t nbTracks);
 static uint8_t gopUpdate(dmx_demuxer *demuxer);
 uint8_t dumpPts(FILE *fd,dmx_demuxer *demuxer,uint64_t firstPts,uint32_t nbTracks);
-uint8_t dmx_indexer(char *mpeg,char *file);
+uint8_t dmx_indexer(const char *mpeg,char *file);
 
 static const uint32_t FPS[16]={
                 0,                      // 0
@@ -99,7 +99,7 @@
         Index the incoming mpeg file
 
 */
-uint8_t dmx_indexer(char *mpeg,char *file,uint32_t preferedAudio,uint8_t autosync,uint32_t nbTracks,MPEG_TRACK *tracks)
+uint8_t dmx_indexer(const char *mpeg,const char *file,uint32_t preferedAudio,uint8_t autosync,uint32_t nbTracks,MPEG_TRACK *tracks)
 {
         DIA_progressIndexing *work;
         dmx_demuxer *demuxer;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer.h	2007-01-20 10:44:43 UTC (rev 2745)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer.h	2007-01-20 15:15:58 UTC (rev 2746)
@@ -18,6 +18,17 @@
  #ifndef DMX_INDX
  #define DMX_INDX
  
+typedef enum ADM_STREAM_TYPE
+{
+  ADM_STREAM_UNKNOWN=0,
+  ADM_STREAM_MPEG_VIDEO, 
+  ADM_STREAM_MPEG_AUDIO,
+  ADM_STREAM_AC3,
+  ADM_STREAM_DTS,
+  ADM_STREAM_H264,
+  ADM_STREAM_MPEG4
+};
+
 typedef struct MPEG_TRACK
 {
         uint16_t pid;
@@ -25,9 +36,11 @@
         // Only for audio...
         uint32_t channels;
         uint32_t bitrate;
+        // for Both
+        ADM_STREAM_TYPE streamType;
 }MPEG_TRACK;
 
-uint8_t dmx_indexer(char *mpeg,char *file,uint32_t preferedAudio,uint8_t autosync,uint32_t nbTracks,MPEG_TRACK *tracks);
+uint8_t dmx_indexer(const char *mpeg,const char *file,uint32_t preferedAudio,uint8_t autosync,uint32_t nbTracks,MPEG_TRACK *tracks);
         
 
 #endif

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_io.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_io.cpp	2007-01-20 10:44:43 UTC (rev 2745)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_io.cpp	2007-01-20 15:15:58 UTC (rev 2746)
@@ -69,7 +69,7 @@
         If multi is set to probe, return value will be APPEND if there is several files, dont_append if one
         if multi is set to dont_append, file won't be auto appended even if they exist
 */
-uint8_t fileParser::open( char *filename,FP_TYPE *multi )
+uint8_t fileParser::open( const char *filename,FP_TYPE *multi )
 {
         char *dot = NULL;                   // pointer to the last dot in filename
         uint8_t decimals = 0;               // number of decimals

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_io.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_io.h	2007-01-20 10:44:43 UTC (rev 2745)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_io.h	2007-01-20 15:15:58 UTC (rev 2746)
@@ -49,7 +49,7 @@
         public:
                                 fileParser(void);
                                 ~fileParser();                                         
-                        uint8_t  open(char *name,FP_TYPE *multi);
+                        uint8_t  open(const char *name,FP_TYPE *multi);
                         uint8_t  forward(uint64_t u);
                         uint8_t  sync(uint8_t *t );
                         uint8_t  getpos(uint64_t *o);

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_probe.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_probe.cpp	2007-01-20 10:44:43 UTC (rev 2745)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_probe.cpp	2007-01-20 15:15:58 UTC (rev 2746)
@@ -49,29 +49,21 @@
 
 #define MAX_PROBE (10*1024*1024LL) // Scans the 4 first meg
 #define MIN_DETECT (10*1024) // Need this to say the stream is present
-#define MAX_NB_PMT 50
 //****************************************************************************************
 typedef struct MPEG_PMT
 {
-   uint32_t programNumber;
-   uint32_t tid;
+   uint32_t         programNumber;
+   uint32_t         tid;
 }MPEG_PMT;
 //****************************************************************************************
 
-static uint8_t dmx_probePS(char *file,  uint32_t *nbTracks,MPEG_TRACK **tracks);
-static uint8_t dmx_probeTS(char *file,  uint32_t *nbTracks,MPEG_TRACK **tracks);
-static uint8_t dmx_probeTSBruteForce(char *file,  uint32_t *nbTracks,MPEG_TRACK **tracks);
-static uint8_t dmx_probeMSDVR(char *file, uint32_t *nbTracks,MPEG_TRACK **tracks);
-/* For mpeg TS with PSI only */
-static uint8_t dmx_probePat(dmx_demuxerTS *demuxer, uint32_t *nbPmt,MPEG_PMT *pmts,uint32_t maxPmt);
-static uint8_t dmx_probePMT(dmx_demuxerTS *demuxer, uint32_t pmtId);
+static uint8_t dmx_probePS(const char *file,  uint32_t *nbTracks,MPEG_TRACK **tracks);
+extern uint8_t dmx_probeTS(const char *file,  uint32_t *nbTracks,MPEG_TRACK **tracks);
+static uint8_t dmx_probeMSDVR(const char *file, uint32_t *nbTracks,MPEG_TRACK **tracks);
 
- uint8_t dmx_probeTSPat(const char *file, uint32_t *nbTracks,MPEG_TRACK **tracks);
- 
-extern uint32_t mpegTsCRC(uint8_t *data, uint32_t len);
 
 //****************************************************************************************
-uint8_t dmx_probe(char *file, DMX_TYPE  *type, uint32_t *nbTracks,MPEG_TRACK **tracks)
+uint8_t dmx_probe(const char *file, DMX_TYPE  *type, uint32_t *nbTracks,MPEG_TRACK **tracks)
 {
 
         printf("Probing %s for streams...\n",file);
@@ -105,7 +97,7 @@
         }
         return 0;
 }
-uint8_t dmx_probePS(char *file,  uint32_t *nbTracks,MPEG_TRACK **tracks)
+uint8_t dmx_probePS(const char *file,  uint32_t *nbTracks,MPEG_TRACK **tracks)
 {
 uint8_t dummy[10];
 uint64_t seen[256],abs,rel;
@@ -170,6 +162,7 @@
         
         memset(*tracks,0,(audio+1)*sizeof(MPEG_TRACK));
         (*tracks)[0].pes=video;
+        (*tracks)[0].streamType=ADM_STREAM_MPEG_VIDEO;
         audio=1;
 #define DOME {(*tracks)[audio].pes=i;audio++;}
         for(int i=0;i<9;i++) if(seen[i]>MIN_DETECT) DOME;
@@ -178,8 +171,8 @@
         for(int i=0x40;i<0x49;i++) if(seen[i]>MIN_DETECT) DOME;
 
         // Now go a bit deeper and try to extract infos
-        #define BUFFER_SIZE (10*1024)
 
+
         uint8_t buffer[BUFFER_SIZE];
         uint32_t read;
         uint32_t br,fq,offset,pes,chan;
@@ -204,6 +197,7 @@
                                         {
                                                 (*tracks)[i].channels=chan;
                                                 (*tracks)[i].bitrate=(8*br)/1000;
+                                                (*tracks)[i].streamType=ADM_STREAM_AC3;
                                         }
                                 }else
                                 {
@@ -215,6 +209,7 @@
                                         {
                                                 (*tracks)[i].channels=chan;
                                                 (*tracks)[i].bitrate=bitrate;
+                                                (*tracks)[i].streamType=ADM_STREAM_DTS;
                                                 if(syncoff) printf("[probe] There are some %u heading bytes\n",syncoff);
                                         }
 
@@ -226,6 +221,7 @@
                                                          else  (*tracks)[i].channels=1;
                                                 
                                                 (*tracks)[i].bitrate=mpegInfo.bitrate;
+                                                (*tracks)[i].streamType=ADM_STREAM_MPEG_AUDIO;
                                         }
                                 }                
 
@@ -239,159 +235,6 @@
         printf("Found video as %x, and %d audio tracks\n",video,audio-1);
         return 1;
 }
-uint8_t dmx_probeTS(char *file,  uint32_t *nbTracks,MPEG_TRACK **tracks)
-{
-        return dmx_probeTSBruteForce(file,nbTracks,tracks);
-}
-/**************************************
-****************************************************************
-    Brute force pid scanning in mpeg TS file
-    We seek all PES packets and store their PID and PES id
-*****************************************************************/
-#define MAX_FOUND_PID 100
-#define CHECK(x) val=parser->read8i(); left--;if(val!=x) goto _next;
-typedef struct myPid
-{
-  uint32_t pid;
-  uint32_t pes;
-
-}myPid;
-uint8_t dmx_probeTSBruteForce(char *file, uint32_t *nbTracks,MPEG_TRACK **tracks)
-{
-
-  // Brute force indexing
-  //
-  // Build a dummy track
-MPEG_TRACK dummy[TS_ALL_PID];
-fileParser *parser;
-uint32_t   foundPid=0;
-myPid      allPid[MAX_FOUND_PID];
-uint8_t    buffer[BUFFER_SIZE];
-MpegAudioInfo mpegInfo; 
-
-    dummy[0].pid=0x1; // should no be in use
-    dummy[0].pes=0xE0;
-
-        dmx_demuxerTS demuxer(TS_ALL_PID,dummy,0);
-        if(!demuxer.open(file))
-        {
-          return 0;
-        }
-    // Set probe to 10 Meg
-      demuxer.setProbeSize(10*1024*1024L);
-      parser=demuxer.getParser();
-      // And run
-
-      uint32_t pid,left,isPayloadStart,cc,val;
-      uint64_t abs;
-      while(demuxer.readPacket(&pid,&left, &isPayloadStart,&abs,&cc))
-      {
-        if(isPayloadStart)
-        {
-            // Is it a PES type packet
-            // it should then start by 0x0 0x0 0x1 PID
-
-            CHECK(0);
-            CHECK(0);
-            CHECK(1);
-            val=parser->read8i();
-            left--;
-            // Check it does not exist already
-            int present=0;
-            for(int i=0;i<foundPid;i++) if(pid==allPid[i].pid) {present=1;break;}
-            if(!present)
-            {
-              allPid[foundPid].pes=val;
-              allPid[foundPid].pid=pid;
-              foundPid++;
-            }
-            ADM_assert(foundPid<MAX_FOUND_PID);
-        } 
-_next:
-        parser->forward(left);
-      }
-      if(!foundPid)
-      {
-         printf("ProbeTS: No PES packet header found\n");
-         return 0;
-      }
-      //****************************************
-      // Build information from the found Pid
-      //****************************************
-      for(int i=0;i<foundPid;i++) printf("Pid : %04x Pes :%02x \n",allPid[i].pid,allPid[i].pes);
-
-      // Search for a pid for video track
-      //
-      *tracks=new MPEG_TRACK[foundPid];
-      MPEG_TRACK *trk=*tracks;
-      uint32_t vPid=0,vIdx;
-      uint32_t offset,fq,br,chan;
-
-      for(int i=0;i<foundPid;i++)
-      {
-        if(allPid[i].pes>=0xE0 && allPid[i].pes<=0xEA)
-        {
-            vPid=trk[0].pes=allPid[i].pes;
-            trk[0].pid=allPid[i].pid;
-            vIdx=i;
-            break;
-        }
-      }
-      if(!vPid)
-      {
-        delete [] trk;
-        *tracks=0;
-        printf("probeTs: No video track\n");
-        return 0;
-      }
-      // Now build the other audio (?) tracks
-      allPid[vIdx].pid=0;
-      uint32_t start=1,code,id,read;
-      for(int i=0;i<foundPid;i++)
-      {
-        code=allPid[i].pes;
-        id=allPid[i].pid;
-
-        if(!id) continue;
-
-        if((code>=0xC0 && code <= 0xC9) || code==0xbd)
-        {
-            demuxer.changePid(id,code);
-            demuxer.setPos(0,0);
-            read=demuxer.read(buffer,BUFFER_SIZE);
-            if(read!=BUFFER_SIZE) continue;
-            if(code>=0xC0 && code <= 0xC9) // Mpeg audio
-            {
-              if(getMpegFrameInfo(buffer,read,&mpegInfo,NULL,&offset))
-                   {
-                      if(mpegInfo.mode!=3)  trk[start].channels=2;
-                          else  trk[start].channels=1;
- 
-                      trk[start].bitrate=mpegInfo.bitrate;
-                      trk[start].pid=id;
-                      trk[start].pes=code;
-                      start++;
-
-                    }
-            }
-            else // AC3
-            {
-                  if(ADM_AC3GetInfo(buffer,read,&fq,&br,&chan,&offset))
-                  {
-                          trk[start].channels=chan;
-                          trk[start].bitrate=(8*br)/1000;
-                          trk[start].pid=id;
-                          trk[start].pes=0;
-                          start++;
-                  }
-
-            }
-
-        }
-      }
-      *nbTracks=start;
-      return 1;
-}
 /* ****************************************************** */
 #include "ADM_asf/ADM_asfPacket.h"
 #include "ADM_asf/ADM_asf.h"
@@ -401,7 +244,7 @@
 #define MAX_PACKET_PROBE 2000;   // assuming a packet is 8kB we will probe around 15 Meg
 #define DETECT_MIN 7000
 
-uint8_t dmx_probeMSDVR(char *file, uint32_t *nbTracks,MPEG_TRACK **ztracks)
+uint8_t dmx_probeMSDVR(const char *file, uint32_t *nbTracks,MPEG_TRACK **ztracks)
 {
   int r=5;
   const chunky *id=NULL;
@@ -420,6 +263,8 @@
       *ztracks=tracks;
       tracks[0].pes=0xE0;
       tracks[0].pid=1;
+      tracks[0].pid=1;
+      tracks[0].streamType=ADM_STREAM_MPEG_VIDEO;
       // Now check for track up to 5
       
       FILE *fd=NULL;
@@ -510,6 +355,7 @@
           if(getMpegFrameInfo(buffer[i],streamlen[i],&mpegInfo,NULL,&sync))
           {
             tracks[*nbTracks].channels=2;
+            tracks[*nbTracks].streamType=ADM_STREAM_MPEG_AUDIO;
             if(mpegInfo.mode==3) 
               tracks[*nbTracks].channels=1;
             tracks[*nbTracks].bitrate=mpegInfo.bitrate;
@@ -527,6 +373,7 @@
             tracks[*nbTracks].bitrate=(8*br)/1000;
             tracks[*nbTracks].pid=i;
             tracks[*nbTracks].pes=0;
+            tracks[*nbTracks].streamType=ADM_STREAM_AC3;
             *nbTracks=*nbTracks+1;
             continue;
           }
@@ -539,266 +386,4 @@
       fclose(fd);
       return 1;
 }
-/**
-      \fn     dmx_probeTSPat(char *file, uint32_t *nbTracks,MPEG_TRACK **tracks)
-      \brief  Try to extract info from a Mpeg TS file using PAT, PMT etc..
-      @return 1 on success, 0 on failure
-      @param file: File to scan
-      @param *nbTrack : number of track found (out)
-      @param **tracks : contains info about the tracks found (out)
-
-*/
-uint8_t dmx_probeTSPat(char *file, uint32_t *nbTracks,MPEG_TRACK **tracks)
-{
-MPEG_TRACK dummy[TS_ALL_PID];
-fileParser *parser;
-uint32_t   foundPid=0;
-myPid      allPid[MAX_FOUND_PID];
-uint8_t    buffer[BUFFER_SIZE];
-MpegAudioInfo mpegInfo; 
-
-    dummy[0].pid=0x00; // should no be in use
-    dummy[0].pes=0xE0;
-
-        dmx_demuxerTS demuxer(1,dummy,1);
-        if(!demuxer.open(file))
-        {
-          return 0;
-        }
-    // Set probe to 10 Meg
-      demuxer.setProbeSize(10*1024*1024L);
-      uint32_t nbPmt;
-      MPEG_PMT pmts[MAX_NB_PMT];
-
-      
-      if(!dmx_probePat(&demuxer,&nbPmt,pmts,MAX_NB_PMT))
-      {
-        printf("[PSI Probe]Cannot find Pat\n"); 
-        parser=NULL;
-        return 0;
-      }
-      printf("Found %d PMT..\n",nbPmt);
-      demuxer.setProbeSize(40*1024*1024L); // We can can increase the probe size
-      for(int i=0;i<nbPmt;i++)
-      {
-         dmx_probePMT(&demuxer, pmts[i].tid);
-      }
-}
-uint8_t runProbe(char *file)
-{
-  uint32_t nb;
-  return  dmx_probeTSPat(file, &nb,NULL);
-  
-}
-/**
-      \fn     dmx_searchAndSkipHeader
-      \brief  Search for a given PSI and skip header
-      @return 1 on success, 0 on failure
-      @param myPid : Pid of the looked for psi
-      @param demuxer: mpegTS demuxer *(input)
-      @param *currentSec : current section (output)
-      @param *maxSec : #of sections (output)
-      @param *leftbyte : Total #of bytes left in the packet
-      @param *payloadSize : #of bytes of usable payload
-
-*/
-uint8_t dmx_searchAndSkipHeader(uint32_t myPid,dmx_demuxerTS *demuxer,uint32_t *currentSec, uint32_t *maxSec,
-                                    uint32_t *leftbyte,uint32_t *payloadSize)
-{
-  
-  uint8_t packet[TS_PACKET_SIZE];
-  uint32_t tableId;
-  uint32_t misc;
-  uint32_t sectionLength;
-  uint32_t tId,pid,left,cc,nbPmt;
-  uint32_t version,isPayloadStart;
-  uint32_t sectionNumber;
-  uint32_t lastSectionNumber;
-  uint32_t programInfoLength;
-  uint32_t crc,crccomputed;
-  uint64_t startPos,endPos,abso;
-  fileParser *parser;
-      demuxer->changePid(myPid,myPid); // Search PAT
-      parser=demuxer->getParser();
-      
-        while(demuxer->readPacket(&pid,&left, &isPayloadStart,&abso,&cc))
-        {
-          if(pid!=myPid)
-          {
-            printf("Wrong Pid %x/%x\n",pid,myPid);
-            parser->forward(left);
-            continue;
-          }
-          if(!isPayloadStart || left <= (9+4))
-          {
-            parser->forward(left);
-            continue;
-          }
-
-          /* Found something that looks good...*/
-            
-            /* Decode PSI header */
-            parser->read8i(); /* Pointer field, can be ignored (?) */
-              
-              parser->getpos(&startPos); /* Memorize beginning */
-              tableId=parser->read8i();
-              misc=parser->read16i(); // +3
-              tId=parser->read16i();  
-              version=parser->read8i(); // +6
-              sectionNumber=parser->read8i();
-              lastSectionNumber=parser->read8i(); // +8
-              
-              sectionLength=misc&0xFFF;
-              
-              if(sectionLength<=9 || left <=9)
-              {
-                printf("SectionLength too short :%d\n", sectionLength);
-                 parser->setpos(startPos-1+left); // skip packet
-                 continue;
-              }
-              
-#ifdef PROBE_TS_VERBOSE
-              printf("******************************************\n");
-              printf("tableId        : %d\n",tableId);
-              
-              printf("sectionLength  : %d\n",sectionLength);
-              printf("0              : %x\n",misc&0x40);
-              printf("section syntax : %x\n",misc&0x80);
-              printf("Transport ID   : 0x%x\n",tId);
-              printf("Version Number : 0x%x\n",(version>>1)&0x1F);
-              printf("CurrentNext    : 0x%x\n",version&1);
-              
-              printf("Section        : %d\n",sectionNumber);
-              printf("LastSection    : %d\n",lastSectionNumber);
-              
-#endif
-              // Check for error FIXME TODO
-              
-              // Check CRC
-              parser->getpos(&endPos); // Here payload begins
-              parser->setpos(startPos);
-              parser->read32(sectionLength-1,packet); // Go back & Read Whole packet +3 for header -4 CRC
-              crc=parser->read32i();
-              crccomputed=mpegTsCRC(packet,sectionLength-1);
-              if(crc!=crccomputed) // Bad CRC, skip packet
-              {
-                printf("Bad CRC\n");
-                parser->setpos( startPos+left-1); // skip
-                continue;
-              }
-              // CRC is ok, go back to interesting place
-              printf("CRC OK\n");
-              parser->setpos(endPos);
-              *currentSec=sectionNumber;
-              *maxSec=lastSectionNumber;
-              
-              *leftbyte=left-9;               // Total bytes left in packet
-              *payloadSize=sectionLength-9; // No CRC, No header
-              return 1;
-          } // /while
-      return 0;
-}
-/**
-      \fn     dmx_probePat(dmx_demuxerTS *demuxer, uint32_t *nbPmt,MPEG_PMT *pmts,uint32_t maxPMT)
-      \brief  Search for PAT and returns PMT info if found
-      @return 1 on success, 0 on failure
-      @param demuxer: mpegTS demuxer (input)
-      @param *nbPmt : number of PMTS found (output)
-      @param *pmts : contains info about the PMT found (out but must be allocated by caller)
-      @param maxPMT : Maximum # of PMT we accept in pmts (in)
-
-*/
-uint8_t dmx_probePat(dmx_demuxerTS *demuxer, uint32_t *nbPmt,MPEG_PMT *pmts,uint32_t maxPmt)
-{
-  
-  fileParser *parser;
-  uint32_t curSection,maxSection;
-  uint32_t left,toScan;
-  
-      parser=demuxer->getParser();
-      *nbPmt=0;
-      if(dmx_searchAndSkipHeader(0,demuxer,&curSection, &maxSection,&left,&toScan))
-      {
-        
-              while(toScan >=4 && left>=8)
-              {
-                  printf("**\n");
-                  pmts[*nbPmt].programNumber=parser->read16i()&0xFFFF;
-                  pmts[*nbPmt].tid=parser->read16i()&0x1FFF;
-                  printf(" [PAT]Program Number :%03x\n",pmts[*nbPmt].programNumber);
-                  printf(" [PAT]PID for this   :%03x\n",pmts[*nbPmt].tid);
-                  if((*nbPmt)<maxPmt)
-                      (*nbPmt)++;
-                  left-=4;
-                  toScan-=4;
-              }
-              return 1;
-        
-      }
-      return 0;
-}
-const char *toString(uint32_t type)
-{
- switch(type)
- {
-   case 1:case 2: return "Mpeg Video";
-   case 3:case 4: return "Mpeg Audio";
-   case 0x1B: return "H264";
-   case 0x81: return "Private (AC3?)";
-   
-   default: return "???"; 
- }
-  return "???";
-}
-/**
-      \fn     dmx_probePat(dmx_demuxerTS *demuxer, uint32_t *nbPmt,MPEG_PMT *pmts,uint32_t maxPMT)
-      \brief  Search for PAT and returns PMT info if found
-      @return 1 on success, 0 on failure
-      @param demuxer: mpegTS demuxer (input)
-      @param *nbPmt : number of PMTS found (output)
-      @param *pmts : contains info about the PMT found (out but must be allocated by caller)
-      @param maxPMT : Maximum # of PMT we accept in pmts (in)
-
-*/
-uint8_t dmx_probePMT(dmx_demuxerTS *demuxer, uint32_t pmtId)
-{
-  
-  fileParser *parser;
-  uint32_t curSection,maxSection;
-  uint32_t left,toScan,programInfo;
-  
-      printf("Searching for PMT, pid=0x%x\n",pmtId);
-      demuxer->changePid(pmtId,pmtId); // change pid as setPos will seek for them
-      demuxer->setPos(0,0);
-      parser=demuxer->getParser();
-      if(dmx_searchAndSkipHeader(pmtId,demuxer,&curSection, &maxSection,&left,&toScan))
-      {
-               printf("[PMT]PCR for it    :x%x\n",parser->read16i()&0x1FFF);
-               programInfo=parser->read16i() & 0x0FFF;
-               printf("[PMT]Program Info  :%d\n",programInfo);
-               parser->forward(programInfo);
-               toScan-=(2+programInfo);
-               left-=(2+programInfo);
-               while(toScan >=5 )
-              {
-                  uint8_t streamType;
-                  uint32_t pid,esDescLen;
-                  printf("**\n");
-                  streamType=parser->read8i();
-                  pid       =parser->read16i()&0x1FFF;
-                  esDescLen =parser->read16i()&0x0FFF;
-                  printf("[PMT]Stream Type :0x%x (%s)\n",streamType,toString(streamType));
-                  printf("[PMT]Pid         :0x%x\n",pid);
-                  printf("[PMT]ES Len      :%d\n",esDescLen);
-                  
-                  parser->forward(esDescLen);
-                  left-=(5+esDescLen);
-                  toScan-=(5+esDescLen);
-                  printf("[PMT]left %u toscan %u\n",left,toScan);
-              }
-              
-      }
-      return 0;
-}
-
 /****EOF**/

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_probe.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_probe.h	2007-01-20 10:44:43 UTC (rev 2745)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_probe.h	2007-01-20 15:15:58 UTC (rev 2746)
@@ -18,7 +18,8 @@
 
 #ifndef DMX_PROBE
 #define DMX_PROBE
-uint8_t dmx_probe(char *file, DMX_TYPE  *type, uint32_t *nbTracks,MPEG_TRACK **tracks);
+#define BUFFER_SIZE (10*1024)
+uint8_t dmx_probe(const char *file, DMX_TYPE  *type, uint32_t *nbTracks,MPEG_TRACK **tracks);
 // For test
 uint8_t runProbe(char *f);
 #endif

Copied: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_probeTS.cpp (from rev 2745, branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_probe.cpp)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_probe.cpp	2007-01-20 10:44:43 UTC (rev 2745)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_probeTS.cpp	2007-01-20 15:15:58 UTC (rev 2746)
@@ -0,0 +1,573 @@
+/***************************************************************************
+                        Probe for a stream                                              
+                             
+    
+    copyright            : (C) 2005 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "config.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <math.h>
+
+#include "default.h"
+#include <ADM_assert.h>
+
+
+#include "ADM_toolkit/toolkit.hxx"
+#include "ADM_toolkit/filesel.h"
+#include "fourcc.h"
+#include "DIA_working.h"
+
+
+
+#include "ADM_osSupport/ADM_debugID.h"
+#define MODULE_NAME MODULE_MPEG
+#include "ADM_osSupport/ADM_debug.h"
+
+#include "dmx_demuxerPS.h"
+#include "dmx_demuxerTS.h"
+#include "dmx_identify.h"
+#include "dmx_probe.h"
+#include "DIA_busy.h"
+#include "ADM_audio/ADM_mp3info.h"
+#include "ADM_audio/ADM_a52info.h"
+#include "ADM_audio/ADM_dcainfo.h"
+
+
+
+#define MAX_PROBE (10*1024*1024LL) // Scans the 4 first meg
+#define MIN_DETECT (10*1024) // Need this to say the stream is present
+#define MAX_NB_PMT 50
+
+//****************************************************************************************
+typedef struct MPEG_PMT
+{
+   uint32_t         programNumber;
+   uint32_t         tid;
+}MPEG_PMT;
+//****************************************************************************************
+
+uint8_t dmx_probeTS(const char *file,  uint32_t *nbTracks,MPEG_TRACK **tracks);
+//****************************************************************************************
+static uint8_t dmx_probeTSBruteForce(const char *file,  uint32_t *nbTracks,MPEG_TRACK **tracks);
+static uint8_t dmx_probeTSPat(const char *file, uint32_t *nbTracks,MPEG_TRACK **tracks);
+static uint8_t dmx_probePat(dmx_demuxerTS *demuxer, uint32_t *nbPmt,MPEG_PMT *pmts,uint32_t maxPmt);
+static uint8_t dmx_probePMT(dmx_demuxerTS *demuxer, uint32_t pmtId,MPEG_TRACK *pmts,uint32_t *cur, uint32_t max);
+
+
+ 
+extern uint32_t mpegTsCRC(uint8_t *data, uint32_t len);
+
+
+uint8_t dmx_probeTS(const char *file,  uint32_t *nbTracks,MPEG_TRACK **tracks)
+{
+    // Try through PMT/PAT first
+      if(! dmx_probeTSPat(file,nbTracks,tracks))
+      {
+        
+        printf("PAT/PMT Failed, using brute force\n");
+        return dmx_probeTSBruteForce(file,nbTracks,tracks);
+      }
+      return 1;
+}
+/**************************************
+****************************************************************
+    Brute force pid scanning in mpeg TS file
+    We seek all PES packets and store their PID and PES id
+*****************************************************************/
+#define MAX_FOUND_PID 100
+#define CHECK(x) val=parser->read8i(); left--;if(val!=x) goto _next;
+typedef struct myPid
+{
+  uint32_t pid;
+  uint32_t pes;
+
+}myPid;
+uint8_t dmx_probeTSBruteForce(const char *file, uint32_t *nbTracks,MPEG_TRACK **tracks)
+{
+
+  // Brute force indexing
+  //
+  // Build a dummy track
+MPEG_TRACK dummy[TS_ALL_PID];
+fileParser *parser;
+uint32_t   foundPid=0;
+myPid      allPid[MAX_FOUND_PID];
+uint8_t    buffer[BUFFER_SIZE];
+MpegAudioInfo mpegInfo; 
+
+    dummy[0].pid=0x1; // should no be in use
+    dummy[0].pes=0xE0;
+
+        dmx_demuxerTS demuxer(TS_ALL_PID,dummy,0);
+        if(!demuxer.open(file))
+        {
+          return 0;
+        }
+    // Set probe to 10 Meg
+      demuxer.setProbeSize(10*1024*1024L);
+      parser=demuxer.getParser();
+      // And run
+
+      uint32_t pid,left,isPayloadStart,cc,val;
+      uint64_t abs;
+      while(demuxer.readPacket(&pid,&left, &isPayloadStart,&abs,&cc))
+      {
+        if(isPayloadStart)
+        {
+            // Is it a PES type packet
+            // it should then start by 0x0 0x0 0x1 PID
+
+            CHECK(0);
+            CHECK(0);
+            CHECK(1);
+            val=parser->read8i();
+            left--;
+            // Check it does not exist already
+            int present=0;
+            for(int i=0;i<foundPid;i++) if(pid==allPid[i].pid) {present=1;break;}
+            if(!present)
+            {
+              allPid[foundPid].pes=val;
+              allPid[foundPid].pid=pid;
+              foundPid++;
+            }
+            ADM_assert(foundPid<MAX_FOUND_PID);
+        } 
+_next:
+        parser->forward(left);
+      }
+      if(!foundPid)
+      {
+         printf("ProbeTS: No PES packet header found\n");
+         return 0;
+      }
+      //****************************************
+      // Build information from the found Pid
+      //****************************************
+      for(int i=0;i<foundPid;i++) printf("Pid : %04x Pes :%02x \n",allPid[i].pid,allPid[i].pes);
+
+      // Search for a pid for video track
+      //
+      *tracks=new MPEG_TRACK[foundPid];
+      MPEG_TRACK *trk=*tracks;
+      uint32_t vPid=0,vIdx;
+      uint32_t offset,fq,br,chan;
+
+      for(int i=0;i<foundPid;i++)
+      {
+        if(allPid[i].pes>=0xE0 && allPid[i].pes<=0xEA)
+        {
+            vPid=trk[0].pes=allPid[i].pes;
+            trk[0].pid=allPid[i].pid;
+            trk[0].streamType=ADM_STREAM_MPEG_VIDEO;
+            vIdx=i;
+            break;
+        }
+      }
+      if(!vPid)
+      {
+        delete [] trk;
+        *tracks=0;
+        printf("probeTs: No video track\n");
+        return 0;
+      }
+      // Now build the other audio (?) tracks
+      allPid[vIdx].pid=0;
+      uint32_t start=1,code,id,read;
+      for(int i=0;i<foundPid;i++)
+      {
+        code=allPid[i].pes;
+        id=allPid[i].pid;
+
+        if(!id) continue;
+
+        if((code>=0xC0 && code <= 0xC9) || code==0xbd)
+        {
+            demuxer.changePid(id,code);
+            demuxer.setPos(0,0);
+            read=demuxer.read(buffer,BUFFER_SIZE);
+            if(read!=BUFFER_SIZE) continue;
+            if(code>=0xC0 && code <= 0xC9) // Mpeg audio
+            {
+              if(getMpegFrameInfo(buffer,read,&mpegInfo,NULL,&offset))
+                   {
+                      if(mpegInfo.mode!=3)  trk[start].channels=2;
+                          else  trk[start].channels=1;
+ 
+                      trk[start].bitrate=mpegInfo.bitrate;
+                      trk[start].pid=id;
+                      trk[start].pes=code;
+                      trk[start].streamType=ADM_STREAM_MPEG_AUDIO;
+                      start++;
+
+                    }
+            }
+            else // AC3
+            {
+                  if(ADM_AC3GetInfo(buffer,read,&fq,&br,&chan,&offset))
+                  {
+                          trk[start].channels=chan;
+                          trk[start].bitrate=(8*br)/1000;
+                          trk[start].pid=id;
+                          trk[start].pes=0;
+                          trk[start].streamType=ADM_STREAM_AC3;
+                          start++;
+                  }
+
+            }
+
+        }
+      }
+      *nbTracks=start;
+      return 1;
+}
+
+/**
+      \fn     dmx_probeTSPat(char *file, uint32_t *nbTracks,MPEG_TRACK **tracks)
+      \brief  Try to extract info from a Mpeg TS file using PAT, PMT etc..
+      @return 1 on success, 0 on failure
+      @param file: File to scan
+      @param *nbTrack : number of track found (out)
+      @param **tracks : contains info about the tracks found (out)
+
+*/
+uint8_t dmx_probeTSPat(const char *file, uint32_t *nbTracks,MPEG_TRACK **tracks)
+{
+MPEG_TRACK dummy[TS_ALL_PID];
+fileParser *parser;
+uint32_t   foundPid=0;
+myPid      allPid[MAX_FOUND_PID];
+uint8_t    buffer[BUFFER_SIZE];
+MpegAudioInfo mpegInfo; 
+#define MAX_STREAM 50
+#define MAX_NB_TRACK 50
+    dummy[0].pid=0x00; // should no be in use
+    dummy[0].pes=0xE0;
+
+        dmx_demuxerTS demuxer(1,dummy,1);
+        if(!demuxer.open(file))
+        {
+          return 0;
+        }
+    // Set probe to 10 Meg
+      demuxer.setProbeSize(10*1024*1024L);
+      uint32_t nbPmt;
+      MPEG_PMT pmts[MAX_NB_PMT];
+      MPEG_TRACK xtracks[MAX_NB_TRACK];
+      
+      if(!dmx_probePat(&demuxer,&nbPmt,pmts,MAX_NB_PMT))
+      {
+        aprintf("[PSI Probe]Cannot find Pat\n"); 
+        parser=NULL;
+        return 0;
+      }
+      printf("Found %d PMT..\n",nbPmt);
+      demuxer.setProbeSize(40*1024*1024L); // We can can increase the probe size
+      uint32_t cur=0;
+      for(int i=0;i<nbPmt;i++)
+      {
+         dmx_probePMT(&demuxer, pmts[i].tid,xtracks,&cur,MAX_NB_TRACK);
+      }
+      printf("***********************\n");
+      printf("***********************\n");
+      printf("Summary of stream found\n");
+      printf("***********************\n");
+      printf("***********************\n");
+      for(int i=0;i<cur;i++)
+      {
+        printf("Tid : %04x Type :%d %s\n", xtracks[i].pid,xtracks[i].streamType,"?");
+      }
+      printf("******************************\n");
+      printf("******************************\n");
+      printf("End of summary of stream found\n");
+      printf("******************************\n");
+      printf("******************************\n");
+      
+      if(!cur)        return 0;
+      
+      // Search first video track
+      *tracks=new MPEG_TRACK[cur];
+      int found=-1;
+      for(int j=0;j<cur;j++)
+      {
+        ADM_STREAM_TYPE type=xtracks[j].streamType;
+        if(type==ADM_STREAM_MPEG_VIDEO ||  type==ADM_STREAM_MPEG4 || type==ADM_STREAM_H264)
+        {
+          found=j;
+          break;  
+        }
+      }
+      if(found<0)
+      {
+        printf("No video track\n");
+        delete [] *tracks;
+        return 0; 
+      }
+      memcpy(*tracks,&(xtracks[found]),sizeof(MPEG_TRACK));
+      *nbTracks=1;
+      // Now do audio
+      for(int j=0;j<cur;j++)
+      {
+         MPEG_TRACK *t=&(xtracks[j]);
+         ADM_STREAM_TYPE type=t->streamType;
+          if(type!=ADM_STREAM_MPEG_AUDIO && type!=ADM_STREAM_AC3) continue; // Only mpega & AC3 for now
+          switch(type)
+          {
+            case ADM_STREAM_MPEG_AUDIO:
+            case ADM_STREAM_AC3:
+              memcpy(&((*tracks)[*nbTracks]),t,sizeof(MPEG_TRACK));
+              ADM_assert(*nbTracks<cur);
+              (*nbTracks)++;
+              break;
+            
+            default: ADM_assert(0); 
+          }
+      }
+      printf("Found %u tracks\n",*nbTracks);
+      //
+      return 1;
+      
+}
+uint8_t runProbe(const char *file)
+{
+  uint32_t nb;
+  return  dmx_probeTSPat(file, &nb,NULL);
+  
+}
+/**
+      \fn     dmx_searchAndSkipHeader
+      \brief  Search for a given PSI and skip header
+      @return 1 on success, 0 on failure
+      @param myPid : Pid of the looked for psi
+      @param demuxer: mpegTS demuxer *(input)
+      @param *currentSec : current section (output)
+      @param *maxSec : #of sections (output)
+      @param *leftbyte : Total #of bytes left in the packet
+      @param *payloadSize : #of bytes of usable payload
+
+*/
+uint8_t dmx_searchAndSkipHeader(uint32_t myPid,dmx_demuxerTS *demuxer,uint32_t *currentSec, uint32_t *maxSec,
+                                    uint32_t *leftbyte,uint32_t *payloadSize)
+{
+  
+  uint8_t packet[TS_PACKET_SIZE];
+  uint32_t tableId;
+  uint32_t misc;
+  uint32_t sectionLength;
+  uint32_t tId,pid,left,cc,nbPmt;
+  uint32_t version,isPayloadStart;
+  uint32_t sectionNumber;
+  uint32_t lastSectionNumber;
+  uint32_t programInfoLength;
+  uint32_t crc,crccomputed;
+  uint64_t startPos,endPos,abso;
+  fileParser *parser;
+      demuxer->changePid(myPid,myPid); // Search PAT
+      parser=demuxer->getParser();
+      
+        while(demuxer->readPacket(&pid,&left, &isPayloadStart,&abso,&cc))
+        {
+          if(pid!=myPid)
+          {
+            printf("Wrong Pid %x/%x\n",pid,myPid);
+            parser->forward(left);
+            continue;
+          }
+          if(!isPayloadStart || left <= (9+4))
+          {
+            parser->forward(left);
+            continue;
+          }
+
+          /* Found something that looks good...*/
+            
+            /* Decode PSI header */
+            parser->read8i(); /* Pointer field, can be ignored (?) */
+              
+              parser->getpos(&startPos); /* Memorize beginning */
+              tableId=parser->read8i();
+              misc=parser->read16i(); // +3
+              tId=parser->read16i();  
+              version=parser->read8i(); // +6
+              sectionNumber=parser->read8i();
+              lastSectionNumber=parser->read8i(); // +8
+              
+              sectionLength=misc&0xFFF;
+              
+              if(sectionLength<=9 || left <=9)
+              {
+                printf("SectionLength too short :%d\n", sectionLength);
+                 parser->setpos(startPos-1+left); // skip packet
+                 continue;
+              }
+              
+#ifdef PROBE_TS_VERBOSE
+              printf("******************************************\n");
+              printf("tableId        : %d\n",tableId);
+              
+              printf("sectionLength  : %d\n",sectionLength);
+              printf("0              : %x\n",misc&0x40);
+              printf("section syntax : %x\n",misc&0x80);
+              printf("Transport ID   : 0x%x\n",tId);
+              printf("Version Number : 0x%x\n",(version>>1)&0x1F);
+              printf("CurrentNext    : 0x%x\n",version&1);
+              
+              printf("Section        : %d\n",sectionNumber);
+              printf("LastSection    : %d\n",lastSectionNumber);
+              
+#endif
+              // Check for error FIXME TODO
+              
+              // Check CRC
+              parser->getpos(&endPos); // Here payload begins
+              parser->setpos(startPos);
+              parser->read32(sectionLength-1,packet); // Go back & Read Whole packet +3 for header -4 CRC
+              crc=parser->read32i();
+              crccomputed=mpegTsCRC(packet,sectionLength-1);
+              if(crc!=crccomputed) // Bad CRC, skip packet
+              {
+                aprintf("Bad CRC\n");
+                parser->setpos( startPos+left-1); // skip
+                continue;
+              }
+              // CRC is ok, go back to interesting place
+              aprintf("CRC OK\n");
+              parser->setpos(endPos);
+              *currentSec=sectionNumber;
+              *maxSec=lastSectionNumber;
+              
+              *leftbyte=left-9;               // Total bytes left in packet
+              *payloadSize=sectionLength-9; // No CRC, No header
+              return 1;
+          } // /while
+      return 0;
+}
+/**
+      \fn     dmx_probePat(dmx_demuxerTS *demuxer, uint32_t *nbPmt,MPEG_PMT *pmts,uint32_t maxPMT)
+      \brief  Search for PAT and returns PMT info if found
+      @return 1 on success, 0 on failure
+      @param demuxer: mpegTS demuxer (input)
+      @param *nbPmt : number of PMTS found (output)
+      @param *pmts : contains info about the PMT found (out but must be allocated by caller)
+      @param maxPMT : Maximum # of PMT we accept in pmts (in)
+
+*/
+uint8_t dmx_probePat(dmx_demuxerTS *demuxer, uint32_t *nbPmt,MPEG_PMT *pmts,uint32_t maxPmt)
+{
+  
+  fileParser *parser;
+  uint32_t curSection,maxSection;
+  uint32_t left,toScan;
+  
+      parser=demuxer->getParser();
+      *nbPmt=0;
+      if(dmx_searchAndSkipHeader(0,demuxer,&curSection, &maxSection,&left,&toScan))
+      {
+        
+              while(toScan >=4 && left>=8)
+              {
+                  printf("**\n");
+                  pmts[*nbPmt].programNumber=parser->read16i()&0xFFFF;
+                  pmts[*nbPmt].tid=parser->read16i()&0x1FFF;
+                  aprintf(" [PAT]Program Number :%03x\n",pmts[*nbPmt].programNumber);
+                  aprintf(" [PAT]PID for this   :%03x\n",pmts[*nbPmt].tid);
+                  if((*nbPmt)<maxPmt)
+                      (*nbPmt)++;
+                  left-=4;
+                  toScan-=4;
+              }
+              return 1;
+        
+      }
+      return 0;
+}
+const char *dmx_streamType(uint32_t type,ADM_STREAM_TYPE *streamType)
+{
+ switch(type)
+ {
+   case 1:case 2: *streamType=ADM_STREAM_MPEG_VIDEO;return "Mpeg Video";
+   case 3:case 4: *streamType=ADM_STREAM_MPEG_AUDIO;return "Mpeg Audio";
+   case 0x1B: *streamType=ADM_STREAM_H264;return "H264";
+   case 0x81: *streamType=ADM_STREAM_AC3;return "Private (AC3?)";
+ }
+ *streamType=ADM_STREAM_UNKNOWN;
+  return "???";
+}
+/**
+      \fn     dmx_probePat(dmx_demuxerTS *demuxer, uint32_t *nbPmt,MPEG_PMT *pmts,uint32_t maxPMT)
+      \brief  Search for PAT and returns PMT info if found
+      @return 1 on success, 0 on failure
+      @param demuxer: mpegTS demuxer (input)
+      @param *nbPmt : number of PMTS found (output)
+      @param *pmts : contains info about the PMT found (out but must be allocated by caller)
+      @param maxPMT : Maximum # of PMT we accept in pmts (in)
+
+*/
+uint8_t dmx_probePMT(dmx_demuxerTS *demuxer, uint32_t pmtId,MPEG_TRACK *pmts,uint32_t *cur, uint32_t max)
+{
+  
+  fileParser *parser;
+  uint32_t curSection,maxSection;
+  uint32_t left,toScan,programInfo;
+  
+      printf("Searching for PMT, pid=0x%x\n",pmtId);
+      demuxer->changePid(pmtId,pmtId); // change pid as setPos will seek for them
+      demuxer->setPos(0,0);
+      parser=demuxer->getParser();
+      if(dmx_searchAndSkipHeader(pmtId,demuxer,&curSection, &maxSection,&left,&toScan))
+      {
+               aprintf("[PMT]PCR for it    :x%x\n",parser->read16i()&0x1FFF);
+               programInfo=parser->read16i() & 0x0FFF;
+               aprintf("[PMT]Program Info  :%d\n",programInfo);
+               parser->forward(programInfo);
+               toScan-=(2+programInfo);
+               left-=(2+programInfo);
+               while(toScan >=5 )
+              {
+                  uint8_t stream;
+                  uint32_t pid,esDescLen;
+                  const char *idString;
+                  ADM_STREAM_TYPE streamType;
+                  aprintf("**\n");
+                  stream    =parser->read8i();
+                  pid       =parser->read16i()&0x1FFF;
+                  esDescLen =parser->read16i()&0x0FFF;
+                  idString=dmx_streamType(stream,&streamType);
+                  aprintf("[PMT]Stream Type :0x%x (%s)\n",stream,idString);
+                  aprintf("[PMT]Pid         :0x%x\n",pid);
+                  aprintf("[PMT]ES Len      :%d\n",esDescLen);
+                  
+                  parser->forward(esDescLen);
+                  left-=(5+esDescLen);
+                  toScan-=(5+esDescLen);
+                  if(*cur<max)
+                  {
+                    pmts[*cur].pid=pid;
+                    pmts[*cur].streamType=streamType;
+                    pmts[*cur].pes=0x0;
+                    if(streamType==ADM_STREAM_MPEG_AUDIO) pmts[*cur].pes=0xC0;
+                    if(streamType==ADM_STREAM_MPEG_VIDEO) pmts[*cur].pes=0xE0;
+                    
+                    (*cur)++;
+                  }
+                  aprintf("[PMT]left %u toscan %u\n",left,toScan);
+              }
+              
+      }
+      return 0;
+}
+
+/****EOF**/

Modified: branches/avidemux_2.4_branch/avidemux/ADM_toolkit/automation.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_toolkit/automation.cpp	2007-01-20 10:44:43 UTC (rev 2745)
+++ branches/avidemux_2.4_branch/avidemux/ADM_toolkit/automation.cpp	2007-01-20 15:15:58 UTC (rev 2746)
@@ -114,7 +114,7 @@
 static void setVar(char *in);
 //
 uint8_t trueFalse(char *p);
-extern uint8_t runProbe(char *file);
+extern uint8_t runProbe(const char *file);
 //_________________________________________________________________________
 
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_idx_pg.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_idx_pg.cpp	2007-01-20 10:44:43 UTC (rev 2745)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_idx_pg.cpp	2007-01-20 15:15:58 UTC (rev 2746)
@@ -59,7 +59,7 @@
 };
 
 
-DIA_progressIndexing::DIA_progressIndexing(char *name)
+DIA_progressIndexing::DIA_progressIndexing(const char *name)
 {
         dialog=create_dialog1();
         gtk_register_dialog(dialog);

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_indexing.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_indexing.cpp	2007-01-20 10:44:43 UTC (rev 2745)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_indexing.cpp	2007-01-20 15:15:58 UTC (rev 2746)
@@ -15,7 +15,7 @@
 #include "ADM_assert.h" 
 #include "DIA_idx_pg.h"
 
-DIA_progressIndexing::DIA_progressIndexing(char *name)
+DIA_progressIndexing::DIA_progressIndexing(const char *name)
 {}
 DIA_progressIndexing::~DIA_progressIndexing()
 {}

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_indexing.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_indexing.cpp	2007-01-20 10:44:43 UTC (rev 2745)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_indexing.cpp	2007-01-20 15:15:58 UTC (rev 2746)
@@ -15,7 +15,7 @@
 #include "ADM_assert.h" 
 #include "DIA_idx_pg.h"
 
-DIA_progressIndexing::DIA_progressIndexing(char *name)
+DIA_progressIndexing::DIA_progressIndexing(const char *name)
 {}
 DIA_progressIndexing::~DIA_progressIndexing()
 {}

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_idx_pg.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_idx_pg.h	2007-01-20 10:44:43 UTC (rev 2745)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_idx_pg.h	2007-01-20 15:15:58 UTC (rev 2746)
@@ -10,7 +10,7 @@
 		uint32_t	_nextUpdate;
         
 public:
-                        DIA_progressIndexing(char *name);
+                        DIA_progressIndexing(const char *name);
                         ~DIA_progressIndexing();
           uint8_t       update(uint32_t done,uint32_t total, uint32_t nbImage, uint32_t hh, uint32_t mm, uint32_t ss);
           uint8_t        abortRequest(void);



From mean at mail.berlios.de  Sun Jan 21 19:04:30 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 21 Jan 2007 19:04:30 +0100
Subject: [Avidemux-svn-commit] r2747 -
	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat
Message-ID: <200701211804.l0LI4UkP030166@sheep.berlios.de>

Author: mean
Date: 2007-01-21 19:04:24 +0100 (Sun, 21 Jan 2007)
New Revision: 2747

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/ADM_lavformat.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/Makefile.am
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/avformat.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/avi.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/avienc.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/avio.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/avio.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/aviobuf.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/cutils.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/file.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/img2.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/isom.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/isom.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/matroska.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/mov.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/movenc.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/mpeg.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/mpegts.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/mpegtsenc.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/riff.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/rtp.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/rtsp.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/rtspcodes.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/utils.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/wav.c
Log:
update to ffmpeg svn

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/ADM_lavformat.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/ADM_lavformat.cpp	2007-01-20 15:15:58 UTC (rev 2746)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/ADM_lavformat.cpp	2007-01-21 18:04:24 UTC (rev 2747)
@@ -159,8 +159,8 @@
                 case MUXER_PSP:
                         strcpy(oc->title,"Avidemux");
                         strcpy(oc->author,"Avidemux");
-                        c->sample_aspect_ratio.num=4;
-                        c->sample_aspect_ratio.den=3;
+                        c->sample_aspect_ratio.num=1;
+                        c->sample_aspect_ratio.den=1;
                         if(isMpeg4Compatible(info->fcc))
                         {
                                 c->codec_id = CODEC_ID_MPEG4;
@@ -191,8 +191,8 @@
                         }
                         if(MUXER_PSP==_type)
                         {
-                            c->rc_buffer_size=8*1024*224;
-                            c->rc_max_rate=768*1000;
+                            c->rc_buffer_size=0; //8*1024*224;
+                            c->rc_max_rate=0; //768*1000;
                             c->rc_min_rate=0;
                             c->bit_rate=768*1000;
                         }
@@ -438,7 +438,7 @@
             pkt.data= buf;
             pkt.size= len;
             pkt.stream_index=1;
-
+            //pkt.duration=pkt.dts-_lastAudioDts; // Duration
             aprintf("A: sample: %d frame_pts: %d fq: %d\n",(int32_t )sample,(int32_t )pkt.dts,audio_st->codec->sample_rate); 
 
             ret = av_write_frame(oc, &pkt);
@@ -589,7 +589,7 @@
 extern AVInputFormat matroska_demuxer;
 uint8_t lavformat_init(void)
 {
-                mpegps_init();
+//                mpegps_init();
                 movenc_init();
                 av_register_input_format(&matroska_demuxer);
                 register_protocol(&file_protocol);

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/Makefile.am	2007-01-20 15:15:58 UTC (rev 2746)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/Makefile.am	2007-01-21 18:04:24 UTC (rev 2747)
@@ -6,13 +6,13 @@
 
 libADM_lavformat_a_SOURCES =  mpeg.c utils.c avio.c ADM_lavformat.cpp \
 aviobuf.c cutils.c img2.c file.c mpegtsenc.c ADM_muxts.cpp movenc.c \
-avienc.c wav.c mov.c matroska.c isom.c isom.h
+avienc.c wav.c mov.c matroska.c isom.c isom.h riff.c
 
 
 EXTRA_DIST = ADM_lavformat.cpp  ADM_muxts.cpp  avformat.h  avio.h   \
 mpegts.h  rtp.h   rtspcodes.h \
 ADM_lavformat.h    ADM_tscrc.h    avi.h       mov.h   riff.h    rtsp.h \
-isom.c isom.h
+isom.c isom.h riff.c
 
 
 ####### kdevelop will overwrite this part!!! (end)############

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/avformat.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/avformat.h	2007-01-20 15:15:58 UTC (rev 2746)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/avformat.h	2007-01-21 18:04:24 UTC (rev 2747)
@@ -1,3 +1,23 @@
+/*
+ * copyright (c) 2001 Fabrice Bellard
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
 #ifndef AVFORMAT_H
 #define AVFORMAT_H
 
@@ -5,28 +25,20 @@
 extern "C" {
 #endif
 
-#define LIBAVFORMAT_VERSION_INT ((50<<16)+(4<<8)+0)
-#define LIBAVFORMAT_VERSION     50.4.0
+#define LIBAVFORMAT_VERSION_INT ((51<<16)+(8<<8)+0)
+#define LIBAVFORMAT_VERSION     51.8.0
 #define LIBAVFORMAT_BUILD       LIBAVFORMAT_VERSION_INT
 
 #define LIBAVFORMAT_IDENT       "Lavf" AV_STRINGIFY(LIBAVFORMAT_VERSION)
 
 #include <time.h>
 #include <stdio.h>  /* FILE */
-#include "../ADM_lavcodec/avcodec.h"
+#include "avcodec.h"
 
 #include "avio.h"
 
 /* packet functions */
 
-#ifndef MAXINT64
-#define MAXINT64 int64_t_C(0x7fffffffffffffff)
-#endif
-
-#ifndef MININT64
-#define MININT64 int64_t_C(0x8000000000000000)
-#endif
-
 typedef struct AVPacket {
     int64_t pts;                            ///< presentation time stamp in time_base units
     int64_t dts;                            ///< decompression time stamp in time_base units
@@ -79,15 +91,13 @@
    is assumed to be such as 0 <= num < den */
 typedef struct AVFrac {
     int64_t val, num, den;
-} AVFrac;
+} AVFrac attribute_deprecated;
 
-void av_frac_init(AVFrac *f, int64_t val, int64_t num, int64_t den);
-void av_frac_add(AVFrac *f, int64_t incr);
-void av_frac_set(AVFrac *f, int64_t val);
-
 /*************************************************/
 /* input/output formats */
 
+struct AVCodecTag;
+
 struct AVFormatContext;
 
 /* this structure contains the data a format has to probe a file */
@@ -97,7 +107,7 @@
     int buf_size;
 } AVProbeData;
 
-#define AVPROBE_SCORE_MAX 100
+#define AVPROBE_SCORE_MAX 100               ///< max score, half of that is used for file extension based detection
 
 typedef struct AVFormatParameters {
     AVRational time_base;
@@ -106,7 +116,6 @@
     int width;
     int height;
     enum PixelFormat pix_fmt;
-    struct AVImageFormat *image_format;
     int channel; /* used to select dv channel */
     const char *device; /* video, audio or DV device */
     const char *standard; /* tv standard, NTSC, PAL, SECAM */
@@ -116,16 +125,19 @@
                                   mpeg2ts_raw is TRUE */
     int initial_pause:1;       /* do not begin to play the stream
                                   immediately (RTSP only) */
+    int prealloced_context:1;
     enum CodecID video_codec_id;
     enum CodecID audio_codec_id;
 } AVFormatParameters;
 
-#define AVFMT_NOFILE        0x0001 /* no file should be opened */
+//! demuxer will use url_fopen, no opened file should be provided by the caller
+#define AVFMT_NOFILE        0x0001
 #define AVFMT_NEEDNUMBER    0x0002 /* needs '%d' in filename */
 #define AVFMT_SHOW_IDS      0x0008 /* show format stream IDs numbers */
 #define AVFMT_RAWPICTURE    0x0020 /* format wants AVPicture structure for
                                       raw picture data */
 #define AVFMT_GLOBALHEADER  0x0040 /* format wants global header */
+#define AVFMT_NOTIMESTAMPS  0x0080 /* format doesnt need / has any timestamps */
 
 typedef struct AVOutputFormat {
     const char *name;
@@ -145,6 +157,13 @@
     /* currently only used to set pixel format if not YUV420P */
     int (*set_parameters)(struct AVFormatContext *, AVFormatParameters *);
     int (*interleave_packet)(struct AVFormatContext *, AVPacket *out, AVPacket *in, int flush);
+
+    /**
+     * list of supported codec_id-codec_tag pairs, ordered by "better choice first"
+     * the arrays are all CODEC_ID_NONE terminated
+     */
+    const struct AVCodecTag *codec_tag[4];
+
     /* private fields */
     struct AVOutputFormat *next;
 } AVOutputFormat;
@@ -200,6 +219,8 @@
        (RTSP) */
     int (*read_pause)(struct AVFormatContext *);
 
+    const struct AVCodecTag *codec_tag[4];
+
     /* private fields */
     struct AVInputFormat *next;
 } AVInputFormat;
@@ -219,6 +240,9 @@
     AVCodecContext *codec; /* codec context */
     /**
      * real base frame rate of the stream.
+     * this is the lowest framerate with which all timestamps can be
+     * represented accurately (its the least common multiple of all
+     * framerates in the stream), Note, this value is just a guess!
      * for example if the timebase is 1/90000 and all frames have either
      * approximately 3600 or 1800 timer ticks then r_frame_rate will be 50/1
      */
@@ -265,9 +289,12 @@
     AVIndexEntry *index_entries; /* only used if the format does not
                                     support seeking natively */
     int nb_index_entries;
-    int index_entries_allocated_size;
+    unsigned int index_entries_allocated_size;
 
     int64_t nb_frames;                 ///< number of frames in this stream if known or 0
+
+#define MAX_REORDER_DELAY 4
+    int64_t pts_buffer[MAX_REORDER_DELAY+1];
 } AVStream;
 
 #define AVFMTCTX_NOHEADER      0x0001 /* signal that no header is present
@@ -283,7 +310,7 @@
     struct AVOutputFormat *oformat;
     void *priv_data;
     ByteIOContext pb;
-    int nb_streams;
+    unsigned int nb_streams;
     AVStream *streams[MAX_STREAMS];
     char filename[1024]; /* input or output filename */
     /* stream info */
@@ -341,6 +368,11 @@
 
     int flags;
 #define AVFMT_FLAG_GENPTS       0x0001 ///< generate pts if missing even if it requires parsing future frames
+#define AVFMT_FLAG_IGNIDX       0x0002 ///< ignore index
+
+    int loop_input;
+    /* decoding: size of data to probe; encoding unused */
+    unsigned int probesize;
 } AVFormatContext;
 
 typedef struct AVPacketList {
@@ -351,235 +383,15 @@
 extern AVInputFormat *first_iformat;
 extern AVOutputFormat *first_oformat;
 
-/* still image support */
-struct AVInputImageContext;
-typedef struct AVInputImageContext AVInputImageContext;
-
-typedef struct AVImageInfo {
-    enum PixelFormat pix_fmt; /* requested pixel format */
-    int width; /* requested width */
-    int height; /* requested height */
-    int interleaved; /* image is interleaved (e.g. interleaved GIF) */
-    AVPicture pict; /* returned allocated image */
-} AVImageInfo;
-
-/* AVImageFormat.flags field constants */
-#define AVIMAGE_INTERLEAVED 0x0001 /* image format support interleaved output */
-
-typedef struct AVImageFormat {
-    const char *name;
-    const char *extensions;
-    /* tell if a given file has a chance of being parsing by this format */
-    int (*img_probe)(AVProbeData *);
-    /* read a whole image. 'alloc_cb' is called when the image size is
-       known so that the caller can allocate the image. If 'allo_cb'
-       returns non zero, then the parsing is aborted. Return '0' if
-       OK. */
-    int (*img_read)(ByteIOContext *,
-                    int (*alloc_cb)(void *, AVImageInfo *info), void *);
-    /* write the image */
-    int supported_pixel_formats; /* mask of supported formats for output */
-    int (*img_write)(ByteIOContext *, AVImageInfo *);
-    int flags;
-    struct AVImageFormat *next;
-} AVImageFormat;
-
-void av_register_image_format(AVImageFormat *img_fmt);
-AVImageFormat *av_probe_image_format(AVProbeData *pd);
-AVImageFormat *guess_image_format(const char *filename);
 enum CodecID av_guess_image2_codec(const char *filename);
-int av_read_image(ByteIOContext *pb, const char *filename,
-                  AVImageFormat *fmt,
-                  int (*alloc_cb)(void *, AVImageInfo *info), void *opaque);
-int av_write_image(ByteIOContext *pb, AVImageFormat *fmt, AVImageInfo *img);
 
-extern AVImageFormat *first_image_format;
-
-extern AVImageFormat pnm_image_format;
-extern AVImageFormat pbm_image_format;
-extern AVImageFormat pgm_image_format;
-extern AVImageFormat ppm_image_format;
-extern AVImageFormat pam_image_format;
-extern AVImageFormat pgmyuv_image_format;
-extern AVImageFormat yuv_image_format;
-#ifdef CONFIG_ZLIB
-extern AVImageFormat png_image_format;
-#endif
-extern AVImageFormat jpeg_image_format;
-extern AVImageFormat gif_image_format;
-extern AVImageFormat sgi_image_format;
-
 /* XXX: use automatic init with either ELF sections or C file parser */
 /* modules */
 
-/* mpeg.c */
-extern AVInputFormat mpegps_demux;
-int mpegps_init(void);
-
-/* mpegts.c */
-extern AVInputFormat mpegts_demux;
-int mpegts_init(void);
-
-/* rm.c */
-int rm_init(void);
-
-/* crc.c */
-int crc_init(void);
-
-/* img.c */
-int img_init(void);
-
-/* img2.c */
-int img2_init(void);
-
-/* asf.c */
-int asf_init(void);
-
-/* avienc.c */
-int avienc_init(void);
-
-/* avidec.c */
-int avidec_init(void);
-
-/* swf.c */
-int swf_init(void);
-
-/* mov.c */
-int mov_init(void);
-
-/* movenc.c */
-int movenc_init(void);
-
-/* flvenc.c */
-int flvenc_init(void);
-
-/* flvdec.c */
-int flvdec_init(void);
-
-/* jpeg.c */
-int jpeg_init(void);
-
-/* gif.c */
-int gif_init(void);
-
-/* au.c */
-int au_init(void);
-
-/* amr.c */
-int amr_init(void);
-
-/* wav.c */
-int ff_wav_init(void);
-
-/* mmf.c */
-int ff_mmf_init(void);
-
-/* raw.c */
-int pcm_read_seek(AVFormatContext *s,
-                  int stream_index, int64_t timestamp, int flags);
-int raw_init(void);
-
-/* mp3.c */
-int mp3_init(void);
-
-/* yuv4mpeg.c */
-int yuv4mpeg_init(void);
-
-/* ogg2.c */
-int ogg_init(void);
-
-/* ogg.c */
-int libogg_init(void);
-
-/* dv.c */
-int ff_dv_init(void);
-
-/* ffm.c */
-int ffm_init(void);
-
-/* rtsp.c */
-extern AVInputFormat redir_demux;
-int redir_open(AVFormatContext **ic_ptr, ByteIOContext *f);
-
-/* 4xm.c */
-int fourxm_init(void);
-
-/* psxstr.c */
-int str_init(void);
-
-/* idroq.c */
-int roq_init(void);
-
-/* ipmovie.c */
-int ipmovie_init(void);
-
-/* nut.c */
-int nut_init(void);
-
-/* wc3movie.c */
-int wc3_init(void);
-
-/* westwood.c */
-int westwood_init(void);
-
-/* segafilm.c */
-int film_init(void);
-
-/* idcin.c */
-int idcin_init(void);
-
-/* flic.c */
-int flic_init(void);
-
-/* sierravmd.c */
-int vmd_init(void);
-
-/* matroska.c */
-int matroska_init(void);
-
-/* sol.c */
-int sol_init(void);
-
-/* electronicarts.c */
-int ea_init(void);
-
-/* nsvdec.c */
-int nsvdec_init(void);
-
-/* daud.c */
-int daud_init(void);
-
-/* nuv.c */
-int nuv_init(void);
-
-/* aiff.c */
-int ff_aiff_init(void);
-
-/* voc.c */
-int voc_init(void);
-
-/* tta.c */
-int tta_init(void);
-
-/* adts.c */
-int ff_adts_init(void);
-
-/* mm.c */
-int mm_init(void);
-
-/* avs.c */
-int avs_init(void);
-
-/* smacker.c */
-int smacker_init(void);
-
 #include "rtp.h"
 
 #include "rtsp.h"
 
-/* yuv4mpeg.c */
-extern AVOutputFormat yuv4mpegpipe_oformat;
-
 /* utils.c */
 void av_register_input_format(AVInputFormat *format);
 void av_register_output_format(AVOutputFormat *format);
@@ -595,19 +407,10 @@
 
 void av_register_all(void);
 
-typedef struct FifoBuffer {
-    uint8_t *buffer;
-    uint8_t *rptr, *wptr, *end;
-} FifoBuffer;
+/* codec tag <-> codec id */
+enum CodecID av_codec_get_id(const struct AVCodecTag *tags[4], unsigned int tag);
+unsigned int av_codec_get_tag(const struct AVCodecTag *tags[4], enum CodecID id);
 
-int fifo_init(FifoBuffer *f, int size);
-void fifo_free(FifoBuffer *f);
-int fifo_size(FifoBuffer *f, uint8_t *rptr);
-int fifo_read(FifoBuffer *f, uint8_t *buf, int buf_size, uint8_t **rptr_ptr);
-void fifo_write(FifoBuffer *f, uint8_t *buf, int size, uint8_t **wptr_ptr);
-int put_fifo(ByteIOContext *pb, FifoBuffer *f, int buf_size, uint8_t **rptr_ptr);
-void fifo_realloc(FifoBuffer *f, unsigned int size);
-
 /* media file input */
 AVInputFormat *av_find_input_format(const char *short_name);
 AVInputFormat *av_probe_input_format(AVProbeData *pd, int is_opened);
@@ -649,12 +452,15 @@
 int av_add_index_entry(AVStream *st,
                        int64_t pos, int64_t timestamp, int size, int distance, int flags);
 int av_seek_frame_binary(AVFormatContext *s, int stream_index, int64_t target_ts, int flags);
+void av_update_cur_dts(AVFormatContext *s, AVStream *ref_st, int64_t timestamp);
+int64_t av_gen_search(AVFormatContext *s, int stream_index, int64_t target_ts, int64_t pos_min, int64_t pos_max, int64_t pos_limit, int64_t ts_min, int64_t ts_max, int flags, int64_t *ts_ret, int64_t (*read_timestamp)(struct AVFormatContext *, int , int64_t *, int64_t ));
 
 /* media file output */
 int av_set_parameters(AVFormatContext *s, AVFormatParameters *ap);
 int av_write_header(AVFormatContext *s);
 int av_write_frame(AVFormatContext *s, AVPacket *pkt);
 int av_interleaved_write_frame(AVFormatContext *s, AVPacket *pkt);
+int av_interleave_packet_per_dts(AVFormatContext *s, AVPacket *out, AVPacket *pkt, int flush);
 
 int av_write_trailer(AVFormatContext *s);
 
@@ -676,9 +482,9 @@
 
 int find_info_tag(char *arg, int arg_size, const char *tag1, const char *info);
 
-int get_frame_filename(char *buf, int buf_size,
-                       const char *path, int number);
-int filename_number_test(const char *filename);
+int av_get_frame_filename(char *buf, int buf_size,
+                          const char *path, int number);
+int av_filename_number_test(const char *filename);
 
 /* grab specific */
 int video_grab_init(void);
@@ -690,7 +496,7 @@
 
 #ifdef HAVE_AV_CONFIG_H
 
-//#include "os_support.h"
+#include "os_support.h"
 
 int strstart(const char *str, const char *val, const char **ptr);
 int stristart(const char *str, const char *val, const char **ptr);

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/avi.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/avi.h	2007-01-20 15:15:58 UTC (rev 2746)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/avi.h	2007-01-21 18:04:24 UTC (rev 2747)
@@ -1,3 +1,23 @@
+/*
+ * copyright (c) 2001 Fabrice Bellard
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
 #ifndef FFMPEG_AVI_H
 #define FFMPEG_AVI_H
 
@@ -16,28 +36,4 @@
 /* index flags */
 #define AVIIF_INDEX             0x10
 
-offset_t start_tag(ByteIOContext *pb, const char *tag);
-void end_tag(ByteIOContext *pb, offset_t start);
-
-typedef struct CodecTag {
-    int id;
-    unsigned int tag;
-    unsigned int invalid_asf : 1;
-} CodecTag;
-
-void put_bmp_header(ByteIOContext *pb, AVCodecContext *enc, const CodecTag *tags, int for_asf);
-int put_wav_header(ByteIOContext *pb, AVCodecContext *enc);
-int wav_codec_get_id(unsigned int tag, int bps);
-void get_wav_header(ByteIOContext *pb, AVCodecContext *codec, int size);
-
-extern const CodecTag codec_bmp_tags[];
-extern const CodecTag codec_wav_tags[];
-
-unsigned int codec_get_tag(const CodecTag *tags, int id);
-enum CodecID codec_get_id(const CodecTag *tags, unsigned int tag);
-unsigned int codec_get_bmp_tag(int id);
-unsigned int codec_get_wav_tag(int id);
-enum CodecID codec_get_bmp_id(unsigned int tag);
-enum CodecID codec_get_wav_id(unsigned int tag);
-
 #endif /* FFMPEG_AVI_H */

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/avienc.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/avienc.c	2007-01-20 15:15:58 UTC (rev 2746)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/avienc.c	2007-01-21 18:04:24 UTC (rev 2747)
@@ -1,30 +1,33 @@
 /*
- * AVI encoder.
+ * AVI muxer
  * Copyright (c) 2000 Fabrice Bellard.
  *
- * This library is free software; you can redistribute it and/or
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
+ * version 2.1 of the License, or (at your option) any later version.
  *
- * This library is distributed in the hope that it will be useful,
+ * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 #include "avformat.h"
 #include "avi.h"
+#include "riff.h"
 
 /*
  * TODO:
  *  - fill all fields if non streamed (nb_frames for example)
  */
 
-#ifdef CONFIG_MUXERS
+#ifdef CONFIG_AVI_MUXER
 typedef struct AVIIentry {
     unsigned int flags, pos, len;
 } AVIIentry;
@@ -55,245 +58,6 @@
     return &idx->cluster[cl][id];
 }
 
-offset_t start_tag(ByteIOContext *pb, const char *tag)
-{
-    put_tag(pb, tag);
-    put_le32(pb, 0);
-    return url_ftell(pb);
-}
-
-void end_tag(ByteIOContext *pb, offset_t start)
-{
-    offset_t pos;
-
-    pos = url_ftell(pb);
-    url_fseek(pb, start - 4, SEEK_SET);
-    put_le32(pb, (uint32_t)(pos - start));
-    url_fseek(pb, pos, SEEK_SET);
-}
-#endif //CONFIG_MUXERS
-
-/* Note: when encoding, the first matching tag is used, so order is
-   important if multiple tags possible for a given codec. */
-const CodecTag codec_bmp_tags[] = {
-    { CODEC_ID_H264, MKTAG('H', '2', '6', '4') },
-    { CODEC_ID_H264, MKTAG('h', '2', '6', '4') },
-    { CODEC_ID_H264, MKTAG('X', '2', '6', '4') },
-    { CODEC_ID_H264, MKTAG('x', '2', '6', '4') },
-    { CODEC_ID_H264, MKTAG('a', 'v', 'c', '1') },
-    { CODEC_ID_H264, MKTAG('V', 'S', 'S', 'H') },
-
-    { CODEC_ID_H263, MKTAG('H', '2', '6', '3') },
-    { CODEC_ID_H263P, MKTAG('H', '2', '6', '3') },
-    { CODEC_ID_H263I, MKTAG('I', '2', '6', '3') }, /* intel h263 */
-    { CODEC_ID_H261, MKTAG('H', '2', '6', '1') },
-
-    /* added based on MPlayer */
-    { CODEC_ID_H263P, MKTAG('U', '2', '6', '3') },
-    { CODEC_ID_H263P, MKTAG('v', 'i', 'v', '1') },
-
-    { CODEC_ID_MPEG4, MKTAG('F', 'M', 'P', '4')},
-    { CODEC_ID_MPEG4, MKTAG('D', 'I', 'V', 'X'), .invalid_asf = 1 },
-    { CODEC_ID_MPEG4, MKTAG('D', 'X', '5', '0'), .invalid_asf = 1 },
-    { CODEC_ID_MPEG4, MKTAG('X', 'V', 'I', 'D'), .invalid_asf = 1 },
-    { CODEC_ID_MPEG4, MKTAG('M', 'P', '4', 'S') },
-    { CODEC_ID_MPEG4, MKTAG('M', '4', 'S', '2') },
-    { CODEC_ID_MPEG4, MKTAG(0x04, 0, 0, 0) }, /* some broken avi use this */
-
-    /* added based on MPlayer */
-    { CODEC_ID_MPEG4, MKTAG('D', 'I', 'V', '1') },
-    { CODEC_ID_MPEG4, MKTAG('B', 'L', 'Z', '0') },
-    { CODEC_ID_MPEG4, MKTAG('m', 'p', '4', 'v') },
-    { CODEC_ID_MPEG4, MKTAG('U', 'M', 'P', '4') },
-    { CODEC_ID_MPEG4, MKTAG('W', 'V', '1', 'F') },
-
-    { CODEC_ID_MSMPEG4V3, MKTAG('D', 'I', 'V', '3'), .invalid_asf = 1 }, /* default signature when using MSMPEG4 */
-    { CODEC_ID_MSMPEG4V3, MKTAG('M', 'P', '4', '3') },
-
-    /* added based on MPlayer */
-    { CODEC_ID_MSMPEG4V3, MKTAG('M', 'P', 'G', '3') },
-    { CODEC_ID_MSMPEG4V3, MKTAG('D', 'I', 'V', '5') },
-    { CODEC_ID_MSMPEG4V3, MKTAG('D', 'I', 'V', '6') },
-    { CODEC_ID_MSMPEG4V3, MKTAG('D', 'I', 'V', '4') },
-    { CODEC_ID_MSMPEG4V3, MKTAG('A', 'P', '4', '1') },
-    { CODEC_ID_MSMPEG4V3, MKTAG('C', 'O', 'L', '1') },
-    { CODEC_ID_MSMPEG4V3, MKTAG('C', 'O', 'L', '0') },
-
-    { CODEC_ID_MSMPEG4V2, MKTAG('M', 'P', '4', '2') },
-
-    /* added based on MPlayer */
-    { CODEC_ID_MSMPEG4V2, MKTAG('D', 'I', 'V', '2') },
-
-    { CODEC_ID_MSMPEG4V1, MKTAG('M', 'P', 'G', '4') },
-
-    { CODEC_ID_WMV1, MKTAG('W', 'M', 'V', '1') },
-
-    /* added based on MPlayer */
-    { CODEC_ID_WMV2, MKTAG('W', 'M', 'V', '2') },
-    { CODEC_ID_DVVIDEO, MKTAG('d', 'v', 's', 'd') },
-    { CODEC_ID_DVVIDEO, MKTAG('d', 'v', 'h', 'd') },
-    { CODEC_ID_DVVIDEO, MKTAG('d', 'v', 's', 'l') },
-    { CODEC_ID_DVVIDEO, MKTAG('d', 'v', '2', '5') },
-    { CODEC_ID_MPEG1VIDEO, MKTAG('m', 'p', 'g', '1') },
-    { CODEC_ID_MPEG1VIDEO, MKTAG('m', 'p', 'g', '2') },
-    { CODEC_ID_MPEG2VIDEO, MKTAG('m', 'p', 'g', '2') },
-    { CODEC_ID_MPEG1VIDEO, MKTAG('P', 'I', 'M', '1') },
-    { CODEC_ID_MPEG1VIDEO, MKTAG('V', 'C', 'R', '2') },
-    { CODEC_ID_MPEG1VIDEO, 0x10000001 },
-    { CODEC_ID_MPEG2VIDEO, 0x10000002 },
-    { CODEC_ID_MPEG2VIDEO, MKTAG('D', 'V', 'R', ' ') },
-    { CODEC_ID_MJPEG, MKTAG('M', 'J', 'P', 'G') },
-    { CODEC_ID_MJPEG, MKTAG('L', 'J', 'P', 'G') },
-    { CODEC_ID_LJPEG, MKTAG('L', 'J', 'P', 'G') },
-    { CODEC_ID_MJPEG, MKTAG('J', 'P', 'G', 'L') }, /* Pegasus lossless JPEG */
-    { CODEC_ID_HUFFYUV, MKTAG('H', 'F', 'Y', 'U') },
-    { CODEC_ID_FFVHUFF, MKTAG('F', 'F', 'V', 'H') },
-    { CODEC_ID_CYUV, MKTAG('C', 'Y', 'U', 'V') },
-    { CODEC_ID_RAWVIDEO, MKTAG('I', '4', '2', '0') },
-    { CODEC_ID_RAWVIDEO, MKTAG('Y', 'U', 'Y', '2') },
-    { CODEC_ID_RAWVIDEO, MKTAG('Y', '4', '2', '2') },
-    { CODEC_ID_RAWVIDEO, MKTAG('U', 'Y', 'V', 'Y') },
-    { CODEC_ID_RAWVIDEO, MKTAG('I', 'Y', 'U', 'V') },
-    { CODEC_ID_INDEO3, MKTAG('I', 'V', '3', '1') },
-    { CODEC_ID_INDEO3, MKTAG('I', 'V', '3', '2') },
-    { CODEC_ID_VP3, MKTAG('V', 'P', '3', '1') },
-    { CODEC_ID_VP3, MKTAG('V', 'P', '3', '0') },
-    { CODEC_ID_ASV1, MKTAG('A', 'S', 'V', '1') },
-    { CODEC_ID_ASV2, MKTAG('A', 'S', 'V', '2') },
-    { CODEC_ID_VCR1, MKTAG('V', 'C', 'R', '1') },
-    { CODEC_ID_FFV1, MKTAG('F', 'F', 'V', '1') },
-    { CODEC_ID_XAN_WC4, MKTAG('X', 'x', 'a', 'n') },
-    { CODEC_ID_MSRLE, MKTAG('m', 'r', 'l', 'e') },
-    { CODEC_ID_MSRLE, MKTAG(0x1, 0x0, 0x0, 0x0) },
-    { CODEC_ID_MSVIDEO1, MKTAG('M', 'S', 'V', 'C') },
-    { CODEC_ID_MSVIDEO1, MKTAG('m', 's', 'v', 'c') },
-    { CODEC_ID_MSVIDEO1, MKTAG('C', 'R', 'A', 'M') },
-    { CODEC_ID_MSVIDEO1, MKTAG('c', 'r', 'a', 'm') },
-    { CODEC_ID_MSVIDEO1, MKTAG('W', 'H', 'A', 'M') },
-    { CODEC_ID_MSVIDEO1, MKTAG('w', 'h', 'a', 'm') },
-    { CODEC_ID_CINEPAK, MKTAG('c', 'v', 'i', 'd') },
-    { CODEC_ID_TRUEMOTION1, MKTAG('D', 'U', 'C', 'K') },
-    { CODEC_ID_MSZH, MKTAG('M', 'S', 'Z', 'H') },
-    { CODEC_ID_ZLIB, MKTAG('Z', 'L', 'I', 'B') },
-    { CODEC_ID_SNOW, MKTAG('S', 'N', 'O', 'W') },
-    { CODEC_ID_4XM, MKTAG('4', 'X', 'M', 'V') },
-    { CODEC_ID_FLV1, MKTAG('F', 'L', 'V', '1') },
-    { CODEC_ID_SVQ1, MKTAG('s', 'v', 'q', '1') },
-    { CODEC_ID_TSCC, MKTAG('t', 's', 'c', 'c') },
-    { CODEC_ID_ULTI, MKTAG('U', 'L', 'T', 'I') },
-    { CODEC_ID_VIXL, MKTAG('V', 'I', 'X', 'L') },
-    { CODEC_ID_QPEG, MKTAG('Q', 'P', 'E', 'G') },
-    { CODEC_ID_QPEG, MKTAG('Q', '1', '.', '0') },
-    { CODEC_ID_QPEG, MKTAG('Q', '1', '.', '1') },
-    { CODEC_ID_WMV3, MKTAG('W', 'M', 'V', '3') },
-    { CODEC_ID_LOCO, MKTAG('L', 'O', 'C', 'O') },
-    { CODEC_ID_WNV1, MKTAG('W', 'N', 'V', '1') },
-    { CODEC_ID_AASC, MKTAG('A', 'A', 'S', 'C') },
-    { CODEC_ID_INDEO2, MKTAG('R', 'T', '2', '1') },
-    { CODEC_ID_FRAPS, MKTAG('F', 'P', 'S', '1') },
-    { CODEC_ID_THEORA, MKTAG('t', 'h', 'e', 'o') },
-    { CODEC_ID_TRUEMOTION2, MKTAG('T', 'M', '2', '0') },
-    { CODEC_ID_RAWVIDEO, 0 },
-    { 0, 0 },
-};
-
-unsigned int codec_get_tag(const CodecTag *tags, int id)
-{
-    while (tags->id != 0) {
-        if (tags->id == id)
-            return tags->tag;
-        tags++;
-    }
-    return 0;
-}
-
-static unsigned int codec_get_asf_tag(const CodecTag *tags, unsigned int id)
-{
-    while (tags->id != 0) {
-        if (!tags->invalid_asf && tags->id == id)
-            return tags->tag;
-        tags++;
-    }
-    return 0;
-}
-
-enum CodecID codec_get_id(const CodecTag *tags, unsigned int tag)
-{
-    while (tags->id != 0) {
-        if(   toupper((tag >> 0)&0xFF) == toupper((tags->tag >> 0)&0xFF)
-           && toupper((tag >> 8)&0xFF) == toupper((tags->tag >> 8)&0xFF)
-           && toupper((tag >>16)&0xFF) == toupper((tags->tag >>16)&0xFF)
-           && toupper((tag >>24)&0xFF) == toupper((tags->tag >>24)&0xFF))
-            return tags->id;
-        tags++;
-    }
-    return CODEC_ID_NONE;
-}
-
-unsigned int codec_get_bmp_tag(int id)
-{
-    return codec_get_tag(codec_bmp_tags, id);
-}
-
-unsigned int codec_get_wav_tag(int id)
-{
-    return codec_get_tag(codec_wav_tags, id);
-}
-
-enum CodecID codec_get_bmp_id(unsigned int tag)
-{
-    return codec_get_id(codec_bmp_tags, tag);
-}
-
-enum CodecID codec_get_wav_id(unsigned int tag)
-{
-    return codec_get_id(codec_wav_tags, tag);
-}
-
-#ifdef CONFIG_MUXERS
-/* BITMAPINFOHEADER header */
-void put_bmp_header(ByteIOContext *pb, AVCodecContext *enc, const CodecTag *tags, int for_asf)
-{
-    put_le32(pb, 40 + enc->extradata_size); /* size */
-    put_le32(pb, enc->width);
-    put_le32(pb, enc->height);
-    put_le16(pb, 1); /* planes */
-
-    put_le16(pb, enc->bits_per_sample ? enc->bits_per_sample : 24); /* depth */
-    /* compression type */
-    put_le32(pb, for_asf ? (enc->codec_tag ? enc->codec_tag : codec_get_asf_tag(tags, enc->codec_id)) : enc->codec_tag); //
-    put_le32(pb, enc->width * enc->height * 3);
-    put_le32(pb, 0);
-    put_le32(pb, 0);
-    put_le32(pb, 0);
-    put_le32(pb, 0);
-
-    put_buffer(pb, enc->extradata, enc->extradata_size);
-
-    if (enc->extradata_size & 1)
-        put_byte(pb, 0);
-}
-
-void ff_parse_specific_params(AVCodecContext *stream, int *au_rate, int *au_ssize, int *au_scale)
-{
-    int gcd;
-
-    *au_ssize= stream->block_align;
-    if(stream->frame_size && stream->sample_rate){
-        *au_scale=stream->frame_size;
-        *au_rate= stream->sample_rate;
-    }else if(stream->codec_type == CODEC_TYPE_VIDEO){
-        *au_scale= stream->time_base.num;
-        *au_rate = stream->time_base.den;
-    }else{
-        *au_scale= stream->block_align ? stream->block_align*8 : 8;
-        *au_rate = stream->bit_rate;
-    }
-    gcd= ff_gcd(*au_scale, *au_rate);
-    *au_scale /= gcd;
-    *au_rate /= gcd;
-}
-
 static offset_t avi_start_new_riff(AVIContext *avi, ByteIOContext *pb,
                                    const char* riff_tag, const char* list_tag)
 {
@@ -311,8 +75,7 @@
     return loff;
 }
 
-static unsigned char* avi_stream2fourcc(unsigned char* tag, int index,
-                                        enum CodecType type)
+static char* avi_stream2fourcc(char* tag, int index, enum CodecType type)
 {
     tag[0] = '0';
     tag[1] = '0' + index;
@@ -327,6 +90,51 @@
     return tag;
 }
 
+static void avi_write_info_tag(ByteIOContext *pb, const char *tag, const char *str)
+{
+    int len = strlen(str);
+    if (len > 0) {
+        len++;
+        put_tag(pb, tag);
+        put_le32(pb, len);
+        put_strz(pb, str);
+        if (len & 1)
+            put_byte(pb, 0);
+    }
+}
+
+static int avi_write_counters(AVFormatContext* s, int riff_id)
+{
+    ByteIOContext *pb = &s->pb;
+    AVIContext *avi = s->priv_data;
+    int n, au_byterate, au_ssize, au_scale, nb_frames = 0;
+    offset_t file_size;
+    AVCodecContext* stream;
+
+    file_size = url_ftell(pb);
+    for(n = 0; n < s->nb_streams; n++) {
+        assert(avi->frames_hdr_strm[n]);
+        stream = s->streams[n]->codec;
+        url_fseek(pb, avi->frames_hdr_strm[n], SEEK_SET);
+        ff_parse_specific_params(stream, &au_byterate, &au_ssize, &au_scale);
+        if(au_ssize == 0) {
+            put_le32(pb, avi->packet_count[n]);
+        } else {
+            put_le32(pb, avi->audio_strm_length[n] / au_ssize);
+        }
+        if(stream->codec_type == CODEC_TYPE_VIDEO)
+            nb_frames = FFMAX(nb_frames, avi->packet_count[n]);
+    }
+    if(riff_id == 1) {
+        assert(avi->frames_hdr_all);
+        url_fseek(pb, avi->frames_hdr_all, SEEK_SET);
+        put_le32(pb, nb_frames);
+    }
+    url_fseek(pb, file_size, SEEK_SET);
+
+    return 0;
+}
+
 static int avi_write_header(AVFormatContext *s)
 {
     AVIContext *avi = s->priv_data;
@@ -355,7 +163,7 @@
     nb_frames = 0;
 
     if(video_enc){
-        put_le32(pb, (uint32_t)(int64_t_C(1000000) * video_enc->time_base.num / video_enc->time_base.den));
+        put_le32(pb, (uint32_t)(INT64_C(1000000) * video_enc->time_base.num / video_enc->time_base.den));
     } else {
         put_le32(pb, 0);
     }
@@ -371,8 +179,8 @@
     put_le32(pb, s->nb_streams); /* nb streams */
     put_le32(pb, 1024 * 1024); /* suggested buffer size */
     if(video_enc){
-    put_le32(pb, video_enc->width);
-    put_le32(pb, video_enc->height);
+        put_le32(pb, video_enc->width);
+        put_le32(pb, video_enc->height);
     } else {
         put_le32(pb, 0);
         put_le32(pb, 0);
@@ -496,6 +304,29 @@
 
     end_tag(pb, list1);
 
+    list2 = start_tag(pb, "LIST");
+    put_tag(pb, "INFO");
+    avi_write_info_tag(pb, "INAM", s->title);
+    avi_write_info_tag(pb, "IART", s->author);
+    avi_write_info_tag(pb, "ICOP", s->copyright);
+    avi_write_info_tag(pb, "ICMT", s->comment);
+    avi_write_info_tag(pb, "IPRD", s->album);
+    avi_write_info_tag(pb, "IGNR", s->genre);
+    if (s->track) {
+        char str_track[4];
+        snprintf(str_track, 4, "%d", s->track);
+        avi_write_info_tag(pb, "IPRT", str_track);
+    }
+    if(!(s->streams[0]->codec->flags & CODEC_FLAG_BITEXACT))
+        avi_write_info_tag(pb, "ISFT", LIBAVFORMAT_IDENT);
+    end_tag(pb, list2);
+
+    /* some padding for easier tag editing */
+    list2 = start_tag(pb, "JUNK");
+    for (i = 0; i < 1016; i += 4)
+        put_le32(pb, 0);
+    end_tag(pb, list2);
+
     avi->movi_list = start_tag(pb, "LIST");
     put_tag(pb, "movi");
 
@@ -508,12 +339,11 @@
 {
     ByteIOContext *pb = &s->pb;
     AVIContext *avi = s->priv_data;
-    unsigned char tag[5];
-    unsigned char ix_tag[] = "ix00";
+    char tag[5];
+    char ix_tag[] = "ix00";
     int i, j;
 
-    if (url_is_streamed(pb))
-        return -1;
+    assert(!url_is_streamed(pb));
 
     if (avi->riff_id > AVI_MASTER_INDEX_SIZE)
         return -1;
@@ -566,10 +396,9 @@
 {
     ByteIOContext *pb = &s->pb;
     AVIContext *avi = s->priv_data;
-    offset_t file_size, idx_chunk;
-    int i, n, nb_frames, au_byterate, au_ssize, au_scale;
-    AVCodecContext *stream;
-    unsigned char tag[5];
+    offset_t idx_chunk;
+    int i;
+    char tag[5];
 
     if (!url_is_streamed(pb)) {
         AVIIentry* ie = 0, *tie;
@@ -603,27 +432,7 @@
         } while (!empty);
         end_tag(pb, idx_chunk);
 
-        /* Fill in frame/sample counters */
-        file_size = url_ftell(pb);
-        nb_frames = 0;
-        for(n=0;n<s->nb_streams;n++) {
-            if (avi->frames_hdr_strm[n] != 0) {
-                stream = s->streams[n]->codec;
-                url_fseek(pb, avi->frames_hdr_strm[n], SEEK_SET);
-                ff_parse_specific_params(stream, &au_byterate, &au_ssize, &au_scale);
-                if (au_ssize == 0) {
-                    put_le32(pb, stream->frame_number);
-                    nb_frames += stream->frame_number;
-                } else {
-                    put_le32(pb, avi->audio_strm_length[n] / au_ssize);
-                }
-            }
-       }
-       if (avi->frames_hdr_all != 0) {
-           url_fseek(pb, avi->frames_hdr_all, SEEK_SET);
-           put_le32(pb, nb_frames);
-       }
-       url_fseek(pb, file_size, SEEK_SET);
+        avi_write_counters(s, avi->riff_id);
     }
     return 0;
 }
@@ -638,7 +447,7 @@
     AVCodecContext *enc= s->streams[stream_index]->codec;
     int size= pkt->size;
 
-//    av_log(s, AV_LOG_DEBUG, "%lld %d %d\n", pkt->dts, avi->packet_count[stream_index], stream_index);
+//    av_log(s, AV_LOG_DEBUG, "%"PRId64" %d %d\n", pkt->dts, avi->packet_count[stream_index], stream_index);
     while(enc->block_align==0 && pkt->dts != AV_NOPTS_VALUE && pkt->dts > avi->packet_count[stream_index]){
         AVPacket empty_packet;
 
@@ -647,7 +456,7 @@
         empty_packet.data= NULL;
         empty_packet.stream_index= stream_index;
         avi_write_packet(s, &empty_packet);
-//        av_log(s, AV_LOG_DEBUG, "dup %lld %d\n", pkt->dts, avi->packet_count[stream_index]);
+//        av_log(s, AV_LOG_DEBUG, "dup %"PRId64" %d\n", pkt->dts, avi->packet_count[stream_index]);
     }
     avi->packet_count[stream_index]++;
 
@@ -710,37 +519,38 @@
     int i, j, n, nb_frames;
     offset_t file_size;
 
-    if (!url_is_streamed(pb))
-    {
-    if (avi->riff_id == 1) {
-        end_tag(pb, avi->movi_list);
-        res = avi_write_idx1(s);
-        end_tag(pb, avi->riff_start);
-    } else {
-        avi_write_ix(s);
-        end_tag(pb, avi->movi_list);
-        end_tag(pb, avi->riff_start);
+    if (!url_is_streamed(pb)){
+        if (avi->riff_id == 1) {
+            end_tag(pb, avi->movi_list);
+            res = avi_write_idx1(s);
+            end_tag(pb, avi->riff_start);
+        } else {
+            avi_write_ix(s);
+            end_tag(pb, avi->movi_list);
+            end_tag(pb, avi->riff_start);
 
-        file_size = url_ftell(pb);
-        url_fseek(pb, avi->odml_list - 8, SEEK_SET);
-        put_tag(pb, "LIST"); /* Making this AVI OpenDML one */
-        url_fskip(pb, 16);
+            file_size = url_ftell(pb);
+            url_fseek(pb, avi->odml_list - 8, SEEK_SET);
+            put_tag(pb, "LIST"); /* Making this AVI OpenDML one */
+            url_fskip(pb, 16);
 
-        for (n=nb_frames=0;n<s->nb_streams;n++) {
-             AVCodecContext *stream = s->streams[n]->codec;
-             if (stream->codec_type == CODEC_TYPE_VIDEO) {
-                 if (nb_frames < stream->frame_number)
-                     nb_frames = stream->frame_number;
-             } else {
-                 if (stream->codec_id == CODEC_ID_MP2 || stream->codec_id == CODEC_ID_MP3) {
-                     nb_frames += stream->frame_number;
+            for (n=nb_frames=0;n<s->nb_streams;n++) {
+                AVCodecContext *stream = s->streams[n]->codec;
+                if (stream->codec_type == CODEC_TYPE_VIDEO) {
+                    if (nb_frames < avi->packet_count[n])
+                        nb_frames = avi->packet_count[n];
+                } else {
+                    if (stream->codec_id == CODEC_ID_MP2 || stream->codec_id == CODEC_ID_MP3) {
+                        nb_frames += avi->packet_count[n];
+                    }
                 }
             }
+            put_le32(pb, nb_frames);
+            url_fseek(pb, file_size, SEEK_SET);
+
+            avi_write_counters(s, avi->riff_id);
         }
-        put_le32(pb, nb_frames);
-        url_fseek(pb, file_size, SEEK_SET);
     }
-    }
     put_flush_packet(pb);
 
     for (i=0; i<MAX_STREAMS; i++) {
@@ -754,7 +564,7 @@
     return res;
 }
 
-static AVOutputFormat avi_oformat = {
+AVOutputFormat avi_muxer = {
     "avi",
     "avi format",
     "video/x-msvideo",
@@ -765,11 +575,6 @@
     avi_write_header,
     avi_write_packet,
     avi_write_trailer,
+    .codec_tag= {codec_bmp_tags, codec_wav_tags},
 };
-
-int avienc_init(void)
-{
-    av_register_output_format(&avi_oformat);
-    return 0;
-}
-#endif //CONFIG_MUXERS
+#endif //CONFIG_AVI_MUXER

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/avio.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/avio.c	2007-01-20 15:15:58 UTC (rev 2746)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/avio.c	2007-01-21 18:04:24 UTC (rev 2747)
@@ -2,19 +2,21 @@
  * Unbuffered io for ffmpeg system
  * Copyright (c) 2001 Fabrice Bellard
  *
- * This library is free software; you can redistribute it and/or
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
+ * version 2.1 of the License, or (at your option) any later version.
  *
- * This library is distributed in the hope that it will be useful,
+ * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 #include "avformat.h"
 
@@ -58,7 +60,7 @@
     } else {
         *q = '\0';
     }
-    
+
     up = first_protocol;
     while (up != NULL) {
         if (!strcmp(proto_str, up->name))
@@ -68,11 +70,14 @@
     err = -ENOENT;
     goto fail;
  found:
-    uc = av_malloc(sizeof(URLContext) + strlen(filename));
+    uc = av_malloc(sizeof(URLContext) + strlen(filename) + 1);
     if (!uc) {
         err = -ENOMEM;
         goto fail;
     }
+#if LIBAVFORMAT_VERSION_INT >= (52<<16)
+    uc->filename = (char *) &uc[1];
+#endif
     strcpy(uc->filename, filename);
     uc->prot = up;
     uc->flags = flags;
@@ -100,7 +105,7 @@
     return ret;
 }
 
-#ifdef CONFIG_ENCODERS
+#if defined(CONFIG_MUXERS) || defined(CONFIG_PROTOCOLS)
 int url_write(URLContext *h, unsigned char *buf, int size)
 {
     int ret;
@@ -108,11 +113,11 @@
         return AVERROR_IO;
     /* avoid sending too big packets */
     if (h->max_packet_size && size > h->max_packet_size)
-        return AVERROR_IO; 
+        return AVERROR_IO;
     ret = h->prot->url_write(h, buf, size);
     return ret;
 }
-#endif //CONFIG_ENCODERS
+#endif //CONFIG_MUXERS || CONFIG_PROTOCOLS
 
 offset_t url_seek(URLContext *h, offset_t pos, int whence)
 {
@@ -145,18 +150,21 @@
 offset_t url_filesize(URLContext *h)
 {
     offset_t pos, size;
-    
-    pos = url_seek(h, 0, SEEK_CUR);
-    size = url_seek(h, -1, SEEK_END)+1;
-    url_seek(h, pos, SEEK_SET);
+
+    size= url_seek(h, 0, AVSEEK_SIZE);
+    if(size<0){
+        pos = url_seek(h, 0, SEEK_CUR);
+        size = url_seek(h, -1, SEEK_END)+1;
+        url_seek(h, pos, SEEK_SET);
+    }
     return size;
 }
 
-/* 
+/*
  * Return the maximum packet size associated to packetized file
  * handle. If the file is not packetized (stream like http or file on
  * disk), then 0 is returned.
- * 
+ *
  * @param h file handle
  * @return maximum packet size in bytes
  */
@@ -176,11 +184,11 @@
     return 0;
 }
 
-/** 
+/**
  * The callback is called in blocking functions to test regulary if
  * asynchronous interruption is needed. -EINTR is returned in this
  * case by the interrupted function. 'NULL' means no interrupt
- * callback is given.  
+ * callback is given.
  */
 void url_set_interrupt_cb(URLInterruptCB *interrupt_cb)
 {

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/avio.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/avio.h	2007-01-20 15:15:58 UTC (rev 2746)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/avio.h	2007-01-21 18:04:24 UTC (rev 2747)
@@ -1,3 +1,23 @@
+/*
+ * unbuffered io for ffmpeg system
+ * copyright (c) 2001 Fabrice Bellard
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
 #ifndef AVIO_H
 #define AVIO_H
 
@@ -13,7 +33,11 @@
     int is_streamed;  /* true if streamed (no seek possible), default = false */
     int max_packet_size;  /* if non zero, the stream is packetized with this max packet size */
     void *priv_data;
+#if LIBAVFORMAT_VERSION_INT >= (52<<16)
+    char *filename; /* specified filename */
+#else
     char filename[1]; /* specified filename */
+#endif
 };
 
 typedef struct URLContext URLContext;
@@ -49,6 +73,13 @@
 /* not implemented */
 int url_poll(URLPollEntry *poll_table, int n, int timeout);
 
+/**
+ * passing this as the "whence" parameter to a seek function causes it to
+ * return the filesize without seeking anywhere, supporting this is optional
+ * if its not supprted then the seek function will return <0
+ */
+#define AVSEEK_SIZE 0x10000
+
 typedef struct URLProtocol {
     const char *name;
     int (*url_open)(URLContext *h, const char *filename, int flags);
@@ -99,6 +130,7 @@
 void put_be64(ByteIOContext *s, uint64_t val);
 void put_le32(ByteIOContext *s, unsigned int val);
 void put_be32(ByteIOContext *s, unsigned int val);
+void put_le24(ByteIOContext *s, unsigned int val);
 void put_be24(ByteIOContext *s, unsigned int val);
 void put_le16(ByteIOContext *s, unsigned int val);
 void put_be16(ByteIOContext *s, unsigned int val);
@@ -127,6 +159,7 @@
 int get_buffer(ByteIOContext *s, unsigned char *buf, int size);
 int get_partial_buffer(ByteIOContext *s, unsigned char *buf, int size);
 int get_byte(ByteIOContext *s);
+unsigned int get_le24(ByteIOContext *s);
 unsigned int get_le32(ByteIOContext *s);
 uint64_t get_le64(ByteIOContext *s);
 unsigned int get_le16(ByteIOContext *s);
@@ -158,7 +191,6 @@
 
 unsigned long get_checksum(ByteIOContext *s);
 void init_checksum(ByteIOContext *s, unsigned long (*update_checksum)(unsigned long c, const uint8_t *p, unsigned int len), unsigned long checksum);
-unsigned long update_adler32(unsigned long adler, const uint8_t *buf, unsigned int len);
 
 /* file.c */
 extern URLProtocol file_protocol;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/aviobuf.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/aviobuf.c	2007-01-20 15:15:58 UTC (rev 2746)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/aviobuf.c	2007-01-21 18:04:24 UTC (rev 2747)
@@ -2,19 +2,21 @@
  * Buffered I/O for ffmpeg system
  * Copyright (c) 2000,2001 Fabrice Bellard
  *
- * This library is free software; you can redistribute it and/or
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
+ * version 2.1 of the License, or (at your option) any later version.
  *
- * This library is distributed in the hope that it will be useful,
+ * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 #include "avformat.h"
 #include "avio.h"
@@ -22,6 +24,8 @@
 
 #define IO_BUFFER_SIZE 32768
 
+static void fill_buffer(ByteIOContext *s);
+
 int init_put_byte(ByteIOContext *s,
                   unsigned char *buffer,
                   int buffer_size,
@@ -50,11 +54,13 @@
     s->is_streamed = 0;
     s->max_packet_size = 0;
     s->update_checksum= NULL;
+    if(!read_packet && !write_flag){
+        s->pos = buffer_size;
+        s->buf_end = s->buffer + buffer_size;
+    }
     return 0;
 }
 
-
-#ifdef CONFIG_MUXERS
 static void flush_buffer(ByteIOContext *s)
 {
     if (s->buf_ptr > s->buffer) {
@@ -104,61 +110,47 @@
     flush_buffer(s);
     s->must_flush = 0;
 }
-#endif //CONFIG_MUXERS
 
 offset_t url_fseek(ByteIOContext *s, offset_t offset, int whence)
 {
     offset_t offset1;
+    offset_t pos= s->pos - (s->write_flag ? 0 : (s->buf_end - s->buffer));
 
     if (whence != SEEK_CUR && whence != SEEK_SET)
         return -EINVAL;
 
-#ifdef CONFIG_MUXERS
-    if (s->write_flag) {
-        if (whence == SEEK_CUR) {
-            offset1 = s->pos + (s->buf_ptr - s->buffer);
-            if (offset == 0)
-                return offset1;
-            offset += offset1;
-        }
-        offset1 = offset - s->pos;
-        if (!s->must_flush &&
-            offset1 >= 0 && offset1 < (s->buf_end - s->buffer)) {
-            /* can do the seek inside the buffer */
-            s->buf_ptr = s->buffer + offset1;
-        } else {
-            if (!s->seek)
-                return -EPIPE;
+    if (whence == SEEK_CUR) {
+        offset1 = pos + (s->buf_ptr - s->buffer);
+        if (offset == 0)
+            return offset1;
+        offset += offset1;
+    }
+    offset1 = offset - pos;
+    if (!s->must_flush &&
+        offset1 >= 0 && offset1 < (s->buf_end - s->buffer)) {
+        /* can do the seek inside the buffer */
+        s->buf_ptr = s->buffer + offset1;
+    } else if(s->is_streamed && !s->write_flag &&
+              offset1 >= 0 && offset1 < (s->buf_end - s->buffer) + (1<<16)){
+        while(s->pos < offset && !s->eof_reached)
+            fill_buffer(s);
+        s->buf_ptr = s->buf_end + offset - s->pos;
+    } else {
+#if defined(CONFIG_MUXERS) || defined(CONFIG_NETWORK)
+        if (s->write_flag) {
             flush_buffer(s);
             s->must_flush = 1;
-            s->buf_ptr = s->buffer;
-            s->seek(s->opaque, offset, SEEK_SET);
-            s->pos = offset;
-        }
-    } else
-#endif //CONFIG_MUXERS
-    {
-        if (whence == SEEK_CUR) {
-            offset1 = s->pos - (s->buf_end - s->buffer) + (s->buf_ptr - s->buffer);
-            if (offset == 0)
-                return offset1;
-            offset += offset1;
-        }
-        offset1 = offset - (s->pos - (s->buf_end - s->buffer));
-        if (offset1 >= 0 && offset1 <= (s->buf_end - s->buffer)) {
-            /* can do the seek inside the buffer */
-            s->buf_ptr = s->buffer + offset1;
-        } else {
-            if (!s->seek)
-                return -EPIPE;
-            s->buf_ptr = s->buffer;
+        } else
+#endif /* defined(CONFIG_MUXERS) || defined(CONFIG_NETWORK) */
+        {
             s->buf_end = s->buffer;
-            if (s->seek(s->opaque, offset, SEEK_SET) == (offset_t)-EPIPE)
-                return -EPIPE;
-            s->pos = offset;
         }
-        s->eof_reached = 0;
+        s->buf_ptr = s->buffer;
+        if (!s->seek || s->seek(s->opaque, offset, SEEK_SET) == (offset_t)-EPIPE)
+            return -EPIPE;
+        s->pos = offset;
     }
+    s->eof_reached = 0;
     return offset;
 }
 
@@ -178,8 +170,11 @@
 
     if (!s->seek)
         return -EPIPE;
-    size = s->seek(s->opaque, -1, SEEK_END) + 1;
-    s->seek(s->opaque, s->pos, SEEK_SET);
+    size = s->seek(s->opaque, 0, AVSEEK_SIZE);
+    if(size<0){
+        size = s->seek(s->opaque, -1, SEEK_END) + 1;
+        s->seek(s->opaque, s->pos, SEEK_SET);
+    }
     return size;
 }
 
@@ -193,7 +188,6 @@
     return s->error;
 }
 
-#ifdef CONFIG_MUXERS
 void put_le32(ByteIOContext *s, unsigned int val)
 {
     put_byte(s, val);
@@ -242,6 +236,12 @@
     put_byte(s, val);
 }
 
+void put_le24(ByteIOContext *s, unsigned int val)
+{
+    put_le16(s, val & 0xffff);
+    put_byte(s, val >> 16);
+}
+
 void put_be24(ByteIOContext *s, unsigned int val)
 {
     put_be16(s, val >> 8);
@@ -254,7 +254,6 @@
         put_byte(s, *tag++);
     }
 }
-#endif //CONFIG_MUXERS
 
 /* Input stream */
 
@@ -295,7 +294,7 @@
 void init_checksum(ByteIOContext *s, unsigned long (*update_checksum)(unsigned long c, const uint8_t *p, unsigned int len), unsigned long checksum){
     s->update_checksum= update_checksum;
     if(s->update_checksum){
-        s->checksum= s->update_checksum(checksum, NULL, 0);
+        s->checksum= checksum;
         s->checksum_ptr= s->buf_ptr;
     }
 }
@@ -399,6 +398,14 @@
     return val;
 }
 
+unsigned int get_le24(ByteIOContext *s)
+{
+    unsigned int val;
+    val = get_le16(s);
+    val |= get_byte(s) << 16;
+    return val;
+}
+
 unsigned int get_le32(ByteIOContext *s)
 {
     unsigned int val;
@@ -616,7 +623,9 @@
     return s->max_packet_size;
 }
 
-#ifdef CONFIG_MUXERS
+/* url_open_dyn_buf and url_close_dyn_buf are used in rtp.c to send a response
+ * back to the server even if CONFIG_MUXERS is not set. */
+#if defined(CONFIG_MUXERS) || defined(CONFIG_NETWORK)
 /* buffer handling */
 int url_open_buf(ByteIOContext *s, uint8_t *buf, int buf_size, int flags)
 {
@@ -779,4 +788,4 @@
     av_free(d);
     return size;
 }
-#endif //CONFIG_MUXERS
+#endif /* CONFIG_MUXERS || CONFIG_NETWORK */

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/cutils.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/cutils.c	2007-01-20 15:15:58 UTC (rev 2746)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/cutils.c	2007-01-21 18:04:24 UTC (rev 2747)
@@ -2,19 +2,21 @@
  * Various simple utilities for ffmpeg system
  * Copyright (c) 2000, 2001, 2002 Fabrice Bellard
  *
- * This library is free software; you can redistribute it and/or
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
+ * version 2.1 of the License, or (at your option) any later version.
  *
- * This library is distributed in the hope that it will be useful,
+ * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 #include "avformat.h"
 
@@ -59,7 +61,7 @@
     p = str;
     q = val;
     while (*q != '\0') {
-	if (toupper(*(const unsigned char *)p) != toupper(*(const unsigned char *)q))
+        if (toupper(*(const unsigned char *)p) != toupper(*(const unsigned char *)q))
             return 0;
         p++;
         q++;
@@ -74,7 +76,7 @@
  * 1 then it is clamped to buf_size - 1.
  * NOTE: this function does what strncpy should have done to be
  * useful. NEVER use strncpy.
- * 
+ *
  * @param buf destination buffer
  * @param buf_size size of destination buffer
  * @param str source string
@@ -101,7 +103,7 @@
 {
     int len;
     len = strlen(buf);
-    if (len < buf_size) 
+    if (len < buf_size)
         pstrcpy(buf + len, buf_size - len, s);
     return buf;
 }
@@ -139,7 +141,7 @@
         y--;
     }
 
-    t = 86400 * 
+    t = 86400 *
         (d + (153 * m - 457) / 5 + 365 * y + y / 4 - y / 100 + y / 400 - 719469);
 
     t += 3600 * tm->tm_hour + 60 * tm->tm_min + tm->tm_sec;
@@ -150,10 +152,10 @@
 #define ISLEAP(y) (((y) % 4 == 0) && (((y) % 100) != 0 || ((y) % 400) == 0))
 #define LEAPS_COUNT(y) ((y)/4 - (y)/100 + (y)/400)
 
-/* this is our own gmtime_r. it differs from its POSIX counterpart in a 
+/* this is our own gmtime_r. it differs from its POSIX counterpart in a
    couple of places, though. */
 struct tm *brktimegm(time_t secs, struct tm *tm)
-{   
+{
     int days, y, ny, m;
     int md[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
 
@@ -166,13 +168,13 @@
     /* oh well, may be someone some day will invent a formula for this stuff */
     y = 1970; /* start "guessing" */
     while (days >= (ISLEAP(y)?366:365)) {
-	ny = (y + days/366);
-	days -= (ny - y) * 365 + LEAPS_COUNT(ny - 1) - LEAPS_COUNT(y - 1);
-	y = ny;
+        ny = (y + days/366);
+        days -= (ny - y) * 365 + LEAPS_COUNT(ny - 1) - LEAPS_COUNT(y - 1);
+        y = ny;
     }
     md[1] = ISLEAP(y)?29:28;
     for (m=0; days >= md[m]; m++)
-	 days -= md[m];
+         days -= md[m];
 
     tm->tm_year = y;  /* unlike gmtime_r we store complete year here */
     tm->tm_mon = m+1; /* unlike gmtime_r tm_mon is from 1 to 12 */
@@ -208,7 +210,7 @@
 }
 
 /* small strptime for ffmpeg */
-const char *small_strptime(const char *p, const char *fmt, 
+const char *small_strptime(const char *p, const char *fmt,
                            struct tm *dt)
 {
     int c, val;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/file.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/file.c	2007-01-20 15:15:58 UTC (rev 2746)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/file.c	2007-01-21 18:04:24 UTC (rev 2747)
@@ -2,33 +2,26 @@
  * Buffered file io for ffmpeg system
  * Copyright (c) 2001 Fabrice Bellard
  *
- * This library is free software; you can redistribute it and/or
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
+ * version 2.1 of the License, or (at your option) any later version.
  *
- * This library is distributed in the hope that it will be useful,
+ * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 #include "avformat.h"
 #include <fcntl.h>
-#ifdef CYG_MANGLING
-#define CONFIG_WIN32
-#endif
-#ifndef CONFIG_WIN32
 #include <unistd.h>
-#include <sys/ioctl.h>
 #include <sys/time.h>
-#else
-#include <io.h>
-#define open(fname,oflag,pmode) _open(fname,oflag,pmode)
-#endif /* CONFIG_WIN32 */
 
 
 /* standard file protocol */
@@ -47,7 +40,7 @@
     } else {
         access = O_RDONLY;
     }
-#if defined(CONFIG_WIN32) || defined(CONFIG_OS2) || defined(__CYGWIN__)
+#if defined(__MINGW32__) || defined(CONFIG_OS2) || defined(__CYGWIN__)
     access |= O_BINARY;
 #endif
     fd = open(filename, access, 0666);
@@ -73,11 +66,7 @@
 static offset_t file_seek(URLContext *h, offset_t pos, int whence)
 {
     int fd = (size_t)h->priv_data;
-#if defined(CONFIG_WIN32) && !defined(__CYGWIN__) 
-    return _lseeki64(fd, pos, whence);
-#else
     return lseek(fd, pos, whence);
-#endif
 }
 
 static int file_close(URLContext *h)
@@ -106,7 +95,7 @@
     } else {
         fd = 0;
     }
-#if defined(CONFIG_WIN32) || defined(CONFIG_OS2) || defined(__CYGWIN__)
+#if defined(__MINGW32__) || defined(CONFIG_OS2) || defined(__CYGWIN__)
     setmode(fd, O_BINARY);
 #endif
     h->priv_data = (void *)(size_t)fd;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/img2.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/img2.c	2007-01-20 15:15:58 UTC (rev 2746)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/img2.c	2007-01-21 18:04:24 UTC (rev 2747)
@@ -3,25 +3,24 @@
  * Copyright (c) 2000, 2001, 2002 Fabrice Bellard.
  * Copyright (c) 2004 Michael Niedermayer
  *
- * This library is free software; you can redistribute it and/or
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
+ * version 2.1 of the License, or (at your option) any later version.
  *
- * This library is distributed in the hope that it will be useful,
+ * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 #include "avformat.h"
 
-/* XXX: this is a hack */
-int loop_input; //MEANX
-
 typedef struct {
     int img_first;
     int img_last;
@@ -51,6 +50,10 @@
     { CODEC_ID_MPEG4     , "mpg4-img"},
     { CODEC_ID_FFV1      , "ffv1-img"},
     { CODEC_ID_RAWVIDEO  , "y"},
+    { CODEC_ID_BMP       , "bmp"},
+    { CODEC_ID_GIF       , "gif"},
+    { CODEC_ID_TARGA     , "tga"},
+    { CODEC_ID_TIFF      , "tiff"},
     {0, NULL}
 };
 
@@ -98,7 +101,7 @@
 }
 
 /* return -1 if no image found */
-static int find_image_range(int *pfirst_index, int *plast_index, 
+static int find_image_range(int *pfirst_index, int *plast_index,
                             const char *path)
 {
     char buf[1024];
@@ -106,8 +109,8 @@
 
     /* find the first image */
     for(first_index = 0; first_index < 5; first_index++) {
-        if (get_frame_filename(buf, sizeof(buf), path, first_index) < 0){
-            *pfirst_index = 
+        if (av_get_frame_filename(buf, sizeof(buf), path, first_index) < 0){
+            *pfirst_index =
             *plast_index = 1;
             return 0;
         }
@@ -116,7 +119,7 @@
     }
     if (first_index == 5)
         goto fail;
-    
+
     /* find the last image */
     last_index = first_index;
     for(;;) {
@@ -126,8 +129,8 @@
                 range1 = 1;
             else
                 range1 = 2 * range;
-            if (get_frame_filename(buf, sizeof(buf), path, 
-                                   last_index + range1) < 0)
+            if (av_get_frame_filename(buf, sizeof(buf), path,
+                                      last_index + range1) < 0)
                 goto fail;
             if (!url_exist(buf))
                 break;
@@ -151,10 +154,13 @@
 
 static int image_probe(AVProbeData *p)
 {
-    if (filename_number_test(p->filename) >= 0 && av_str2id(img_tags, p->filename))
-        return AVPROBE_SCORE_MAX;
-    else
-        return 0;
+    if (p->filename && av_str2id(img_tags, p->filename)) {
+        if (av_filename_number_test(p->filename))
+            return AVPROBE_SCORE_MAX;
+        else
+            return AVPROBE_SCORE_MAX/2;
+    }
+    return 0;
 }
 
 enum CodecID av_guess_image2_codec(const char *filename){
@@ -177,7 +183,7 @@
     pstrcpy(s->path, sizeof(s->path), s1->filename);
     s->img_number = 0;
     s->img_count = 0;
-    
+
     /* find format */
     if (s1->iformat->flags & AVFMT_NOFILE)
         s->is_pipe = 0;
@@ -185,28 +191,18 @@
         s->is_pipe = 1;
         st->need_parsing= 1;
     }
-        
-    if (!ap || !ap->time_base.num) {
+
+    if (!ap->time_base.num) {
         av_set_pts_info(st, 60, 1, 25);
     } else {
         av_set_pts_info(st, 60, ap->time_base.num, ap->time_base.den);
     }
-#if 0 
-#warning BROKEN
-#warning BROKEN
-#warning BROKEN
-#warning BROKEN
-#warning BROKEN
-#warning BROKEN
-#warning BROKEN
-#warning BROKEN
-#warning BROKEN
-#warning BROKEN
-    if(ap && ap->width && ap->height){
-        st->codec.width = ap->width;
-        st->codec.height= ap->height;
+
+    if(ap->width && ap->height){
+        st->codec->width = ap->width;
+        st->codec->height= ap->height;
     }
-    
+
     if (!s->is_pipe) {
         if (find_image_range(&first_index, &last_index, s->path) < 0)
             return AVERROR_IO;
@@ -217,20 +213,20 @@
         st->start_time = 0;
         st->duration = last_index - first_index + 1;
     }
-    
+
     if(ap->video_codec_id){
-        st->codec.codec_type = CODEC_TYPE_VIDEO;
-        st->codec.codec_id = ap->video_codec_id;
+        st->codec->codec_type = CODEC_TYPE_VIDEO;
+        st->codec->codec_id = ap->video_codec_id;
     }else if(ap->audio_codec_id){
-        st->codec.codec_type = CODEC_TYPE_AUDIO;
-        st->codec.codec_id = ap->audio_codec_id;
+        st->codec->codec_type = CODEC_TYPE_AUDIO;
+        st->codec->codec_id = ap->audio_codec_id;
     }else{
-        st->codec.codec_type = CODEC_TYPE_VIDEO;
-        st->codec.codec_id = av_str2id(img_tags, s->path);
+        st->codec->codec_type = CODEC_TYPE_VIDEO;
+        st->codec->codec_id = av_str2id(img_tags, s->path);
     }
-    if(st->codec.codec_type == CODEC_TYPE_VIDEO && ap->pix_fmt != PIX_FMT_NONE)
-        st->codec.pix_fmt = ap->pix_fmt;
-#endif
+    if(st->codec->codec_type == CODEC_TYPE_VIDEO && ap->pix_fmt != PIX_FMT_NONE)
+        st->codec->pix_fmt = ap->pix_fmt;
+
     return 0;
 }
 
@@ -241,26 +237,26 @@
     int i;
     int size[3]={0}, ret[3]={0};
     ByteIOContext f1[3], *f[3]= {&f1[0], &f1[1], &f1[2]};
-    AVCodecContext *codec= &s1->streams[0]->codec;
+    AVCodecContext *codec= s1->streams[0]->codec;
 
     if (!s->is_pipe) {
         /* loop over input */
-        if (loop_input && s->img_number > s->img_last) {
+        if (s1->loop_input && s->img_number > s->img_last) {
             s->img_number = s->img_first;
         }
-        if (get_frame_filename(filename, sizeof(filename),
-                               s->path, s->img_number)<0 && s->img_number > 1)
+        if (av_get_frame_filename(filename, sizeof(filename),
+                                  s->path, s->img_number)<0 && s->img_number > 1)
             return AVERROR_IO;
         for(i=0; i<3; i++){
             if (url_fopen(f[i], filename, URL_RDONLY) < 0)
                 return AVERROR_IO;
-            size[i]= url_filesize(url_fileno(f[i]));
-            
+            size[i]= url_fsize(f[i]);
+
             if(codec->codec_id != CODEC_ID_RAWVIDEO)
                 break;
             filename[ strlen(filename) - 1 ]= 'U' + i;
         }
-        
+
         if(codec->codec_id == CODEC_ID_RAWVIDEO && !codec->width)
             infer_size(&codec->width, &codec->height, size[0]);
     } else {
@@ -300,6 +296,7 @@
     return 0;
 }
 
+#ifdef CONFIG_MUXERS
 /******************************************************/
 /* image output */
 
@@ -315,7 +312,7 @@
         img->is_pipe = 0;
     else
         img->is_pipe = 1;
-        
+
     return 0;
 }
 
@@ -324,17 +321,17 @@
     VideoData *img = s->priv_data;
     ByteIOContext pb1[3], *pb[3]= {&pb1[0], &pb1[1], &pb1[2]};
     char filename[1024];
-    AVCodecContext *codec= &s->streams[ pkt->stream_index ]->codec;
+    AVCodecContext *codec= s->streams[ pkt->stream_index ]->codec;
     int i;
 
     if (!img->is_pipe) {
-        if (get_frame_filename(filename, sizeof(filename), 
-                               img->path, img->img_number) < 0 && img->img_number>1)
+        if (av_get_frame_filename(filename, sizeof(filename),
+                                  img->path, img->img_number) < 0 && img->img_number>1)
             return AVERROR_IO;
         for(i=0; i<3; i++){
             if (url_fopen(pb[i], filename, URL_WRONLY) < 0)
                 return AVERROR_IO;
-        
+
             if(codec->codec_id != CODEC_ID_RAWVIDEO)
                 break;
             filename[ strlen(filename) - 1 ]= 'U' + i;
@@ -342,7 +339,7 @@
     } else {
         pb[0] = &s->pb;
     }
-    
+
     if(codec->codec_id == CODEC_ID_RAWVIDEO){
         int ysize = codec->width * codec->height;
         put_buffer(pb[0], pkt->data        , ysize);
@@ -369,9 +366,11 @@
     return 0;
 }
 
-/* input */
+#endif /* CONFIG_MUXERS */
 
-static AVInputFormat image2_iformat = {
+/* input */
+#ifdef CONFIG_IMAGE2_DEMUXER
+AVInputFormat image2_demuxer = {
     "image2",
     "image2 sequence",
     sizeof(VideoData),
@@ -383,8 +382,9 @@
     NULL,
     AVFMT_NOFILE,
 };
-
-static AVInputFormat image2pipe_iformat = {
+#endif
+#ifdef CONFIG_IMAGE2PIPE_DEMUXER
+AVInputFormat image2pipe_demuxer = {
     "image2pipe",
     "piped image2 sequence",
     sizeof(VideoData),
@@ -394,11 +394,11 @@
     img_read_close,
     NULL,
 };
+#endif
 
-
 /* output */
-
-static AVOutputFormat image2_oformat = {
+#ifdef CONFIG_IMAGE2_MUXER
+AVOutputFormat image2_muxer = {
     "image2",
     "image2 sequence",
     "",
@@ -411,8 +411,9 @@
     img_write_trailer,
     AVFMT_NOFILE,
 };
-
-static AVOutputFormat image2pipe_oformat = {
+#endif
+#ifdef CONFIG_IMAGE2PIPE_MUXER
+AVOutputFormat image2pipe_muxer = {
     "image2pipe",
     "piped image2 sequence",
     "",
@@ -424,14 +425,4 @@
     img_write_packet,
     img_write_trailer,
 };
-
-int img2_init(void)
-{
-    av_register_input_format(&image2_iformat);
-    av_register_output_format(&image2_oformat);
-
-    av_register_input_format(&image2pipe_iformat);
-    av_register_output_format(&image2pipe_oformat);
-    
-    return 0;
-}
+#endif

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/isom.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/isom.c	2007-01-20 15:15:58 UTC (rev 2746)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/isom.c	2007-01-21 18:04:24 UTC (rev 2747)
@@ -4,18 +4,20 @@
  * Copyright (c) 2002 Francois Revol <revol at free.fr>
  * Copyright (c) 2006 Baptiste Coudurier <baptiste.coudurier at free.fr>
  *
- * This library is free software; you can redistribute it and/or
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
+ * version 2.1 of the License, or (at your option) any later version.
  *
- * This library is distributed in the hope that it will be useful,
+ * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
+ * License along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
@@ -24,7 +26,7 @@
 #include "isom.h"
 
 /* http://gpac.sourceforge.net/tutorial/mediatypes.htm */
-const CodecTag ff_mov_obj_type[] = {
+const AVCodecTag ff_mov_obj_type[] = {
     { CODEC_ID_MPEG4     ,  32 },
     { CODEC_ID_H264      ,  33 },
     { CODEC_ID_AAC       ,  64 },
@@ -37,13 +39,13 @@
     { CODEC_ID_AAC       , 102 }, /* MPEG2 AAC Main */
     { CODEC_ID_AAC       , 103 }, /* MPEG2 AAC Low */
     { CODEC_ID_AAC       , 104 }, /* MPEG2 AAC SSR */
-    { CODEC_ID_MP3       , 107 }, // MEANX Compatibility with xine was 105
+    { CODEC_ID_MP3       , 105 },
     { CODEC_ID_MPEG1VIDEO, 106 },
     { CODEC_ID_MP2       , 107 },
     { CODEC_ID_MJPEG     , 108 },
     { CODEC_ID_PCM_S16LE , 224 },
     { CODEC_ID_VORBIS    , 221 },
-//MEANX    { CODEC_ID_QCELP     , 225 },
+    { CODEC_ID_QCELP     , 225 },
     { CODEC_ID_AC3       , 226 },
     { CODEC_ID_PCM_ALAW  , 227 },
     { CODEC_ID_PCM_MULAW , 228 },

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/isom.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/isom.h	2007-01-20 15:15:58 UTC (rev 2746)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/isom.h	2007-01-21 18:04:24 UTC (rev 2747)
@@ -1,3 +1,26 @@
+/*
+ * ISO Media common code
+ * copyright (c) 2001 Fabrice Bellard.
+ * copyright (c) 2002 Francois Revol <revol at free.fr>
+ * copyright (c) 2006 Baptiste Coudurier <baptiste.coudurier at free.fr>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
 #ifndef FFMPEG_ISOM_H
 #define FFMPEG_ISOM_H
 
@@ -2,3 +25,3 @@
 /* isom.c */
-extern const CodecTag ff_mov_obj_type[];
+extern const AVCodecTag ff_mov_obj_type[];
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/matroska.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/matroska.c	2007-01-20 15:15:58 UTC (rev 2746)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/matroska.c	2007-01-21 18:04:24 UTC (rev 2747)
@@ -2,18 +2,20 @@
  * Matroska file demuxer (no muxer yet)
  * Copyright (c) 2003-2004 The ffmpeg Project
  *
- * This library is free software; you can redistribute it and/or
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
+ * version 2.1 of the License, or (at your option) any later version.
  *
- * This library is distributed in the hope that it will be useful,
+ * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
+ * License along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
@@ -67,6 +69,7 @@
 /* IDs in the info master */
 #define MATROSKA_ID_TIMECODESCALE 0x2AD7B1
 #define MATROSKA_ID_DURATION   0x4489
+#define MATROSKA_ID_TITLE      0x7BA9
 #define MATROSKA_ID_WRITINGAPP 0x5741
 #define MATROSKA_ID_MUXINGAPP  0x4D80
 #define MATROSKA_ID_DATEUTC    0x4461
@@ -107,6 +110,8 @@
 
 /* IDs in the trackaudio master */
 #define MATROSKA_ID_AUDIOSAMPLINGFREQ 0xB5
+#define MATROSKA_ID_AUDIOOUTSAMPLINGFREQ 0x78B5
+
 #define MATROSKA_ID_AUDIOBITDEPTH 0x6264
 #define MATROSKA_ID_AUDIOCHANNELS 0x9F
 
@@ -171,6 +176,7 @@
   MATROSKA_TRACK_ENABLED = (1<<0),
   MATROSKA_TRACK_DEFAULT = (1<<1),
   MATROSKA_TRACK_LACING  = (1<<2),
+  MATROSKA_TRACK_REAL_V  = (1<<4),
   MATROSKA_TRACK_SHIFT   = (1<<16)
 } MatroskaTrackFlags;
 
@@ -217,8 +223,10 @@
     {"A_AC3"            , CODEC_ID_AC3},
     {"A_DTS"            , CODEC_ID_DTS},
     {"A_VORBIS"         , CODEC_ID_VORBIS},
-    {"A_AAC/MPEG2/"     , CODEC_ID_AAC},
-    {"A_AAC/MPEG4/"     , CODEC_ID_AAC},
+    {"A_AAC"            , CODEC_ID_AAC},
+    {"A_FLAC"           , CODEC_ID_FLAC},
+    {"A_WAVPACK4"       , CODEC_ID_WAVPACK},
+    {"A_TTA1"           , CODEC_ID_TTA},
     {NULL               , CODEC_ID_NONE}
 /* TODO: AC3-9/10 (?), Real, Musepack, Quicktime */
 };
@@ -269,6 +277,7 @@
 
     int channels,
         bitdepth,
+        internal_samplerate,
         samplerate;
     //..
 } MatroskaAudioTrack;
@@ -627,10 +636,6 @@
         *num= av_int2flt(get_be32(pb));
     } else if(size==8){
         *num= av_int2dbl(get_be64(pb));
-    } else if(size==10){
-        av_log(matroska->ctx, AV_LOG_ERROR,
-               "FIXME! 10-byte floats unimplemented\n");
-        return AVERROR_UNKNOWN;
     } else{
         offset_t pos = url_ftell(pb);
         av_log(matroska->ctx, AV_LOG_ERROR,
@@ -986,8 +991,7 @@
                 av_realloc(matroska->packets, (matroska->num_packets - 1) *
                            sizeof(AVPacket *));
         } else {
-            av_free(matroska->packets);
-            matroska->packets = NULL;
+            av_freep(&matroska->packets);
         }
         matroska->num_packets--;
         return 0;
@@ -1097,6 +1101,16 @@
                 break;
             }
 
+            case MATROSKA_ID_TITLE: {
+                char *text;
+                if ((res = ebml_read_utf8(matroska, &id, &text)) < 0)
+                    break;
+                strncpy(matroska->ctx->title, text,
+                        sizeof(matroska->ctx->title)-1);
+                av_free(text);
+                break;
+            }
+
             case MATROSKA_ID_WRITINGAPP: {
                 char *text;
                 if ((res = ebml_read_utf8(matroska, &id, &text)) < 0)
@@ -1423,10 +1437,20 @@
                             if ((res = ebml_read_float(matroska, &id,
                                                        &num)) < 0)
                                 break;
+                            audiotrack->internal_samplerate =
                             audiotrack->samplerate = num;
                             break;
                         }
 
+                        case MATROSKA_ID_AUDIOOUTSAMPLINGFREQ: {
+                            double num;
+                            if ((res = ebml_read_float(matroska, &id,
+                                                       &num)) < 0)
+                                break;
+                            audiotrack->samplerate = num;
+                            break;
+                        }
+
                             /* bitdepth */
                         case MATROSKA_ID_AUDIOBITDEPTH: {
                             uint64_t num;
@@ -1667,7 +1691,7 @@
                     switch (id) {
                         /* one single index entry ('point') */
                         case MATROSKA_ID_CUETIME: {
-                            int64_t time;
+                            uint64_t time;
                             if ((res = ebml_read_uint(matroska, &id,
                                                       &time)) < 0)
                                 break;
@@ -1920,7 +1944,7 @@
                         /* check ID */
                         if (!(id = ebml_peek_id (matroska,
                                                  &matroska->level_up)))
-                            break;
+                            goto finish;
                         if (id != seek_id) {
                             av_log(matroska->ctx, AV_LOG_INFO,
                                    "We looked for ID=0x%x but got "
@@ -1932,7 +1956,7 @@
 
                         /* read master + parse */
                         if ((res = ebml_read_master(matroska, &id)) < 0)
-                            break;
+                            goto finish;
                         switch (id) {
                             case MATROSKA_ID_CUES:
                                 if (!(res = matroska_parse_index(matroska)) ||
@@ -1949,8 +1973,6 @@
                                 }
                                 break;
                         }
-                        if (res < 0)
-                            break;
 
                     finish:
                         /* remove dummy level */
@@ -1999,7 +2021,38 @@
     return res;
 }
 
+#define ARRAY_SIZE(x)  (sizeof(x)/sizeof(*x))
+
 static int
+matroska_aac_profile (char *codec_id)
+{
+    static const char *aac_profiles[] = {
+        "MAIN", "LC", "SSR"
+    };
+    int profile;
+
+    for (profile=0; profile<ARRAY_SIZE(aac_profiles); profile++)
+        if (strstr(codec_id, aac_profiles[profile]))
+            break;
+    return profile + 1;
+}
+
+static int
+matroska_aac_sri (int samplerate)
+{
+    static const int aac_sample_rates[] = {
+        96000, 88200, 64000, 48000, 44100, 32000,
+        24000, 22050, 16000, 12000, 11025,  8000,
+    };
+    int sri;
+
+    for (sri=0; sri<ARRAY_SIZE(aac_sample_rates); sri++)
+        if (aac_sample_rates[sri] == samplerate)
+            break;
+    return sri;
+}
+
+static int
 matroska_read_header (AVFormatContext    *s,
                       AVFormatParameters *ap)
 {
@@ -2133,19 +2186,17 @@
         }
     }
 
-    if (res < 0)
-        return res;
-
     /* Have we found a cluster? */
-    if (res == 1) {
+    if (ebml_peek_id(matroska, NULL) == MATROSKA_ID_CLUSTER) {
         int i, j;
-        enum CodecID codec_id= CODEC_ID_NONE;
         MatroskaTrack *track;
         AVStream *st;
 
         for (i = 0; i < matroska->num_tracks; i++) {
-            void *extradata = NULL;
+            enum CodecID codec_id = CODEC_ID_NONE;
+            uint8_t *extradata = NULL;
             int extradata_size = 0;
+            int extradata_offset = 0;
             track = matroska->tracks[i];
 
             /* libavformat does not really support subtitles.
@@ -2155,7 +2206,8 @@
                 continue;
 
             for(j=0; codec_tags[j].str; j++){
-                if(!strcmp(codec_tags[j].str, track->codec_id)){
+                if(!strncmp(codec_tags[j].str, track->codec_id,
+                            strlen(codec_tags[j].str))){
                     codec_id= codec_tags[j].id;
                     break;
                 }
@@ -2194,6 +2246,50 @@
 
             }
 
+            else if (codec_id == CODEC_ID_AAC && !track->codec_priv_size) {
+                MatroskaAudioTrack *audiotrack = (MatroskaAudioTrack *) track;
+                int profile = matroska_aac_profile(track->codec_id);
+                int sri = matroska_aac_sri(audiotrack->internal_samplerate);
+                extradata = av_malloc(5);
+                if (extradata == NULL)
+                    return AVERROR_NOMEM;
+                extradata[0] = (profile << 3) | ((sri&0x0E) >> 1);
+                extradata[1] = ((sri&0x01) << 7) | (audiotrack->channels<<3);
+                if (strstr(track->codec_id, "SBR")) {
+                    sri = matroska_aac_sri(audiotrack->samplerate);
+                    extradata[2] = 0x56;
+                    extradata[3] = 0xE5;
+                    extradata[4] = 0x80 | (sri<<3);
+                    extradata_size = 5;
+                } else {
+                    extradata_size = 2;
+                }
+            }
+
+            else if (codec_id == CODEC_ID_TTA) {
+                MatroskaAudioTrack *audiotrack = (MatroskaAudioTrack *) track;
+                ByteIOContext b;
+                extradata_size = 30;
+                extradata = av_mallocz(extradata_size);
+                if (extradata == NULL)
+                    return AVERROR_NOMEM;
+                init_put_byte(&b, extradata, extradata_size, 1,
+                              NULL, NULL, NULL, NULL);
+                put_buffer(&b, (uint8_t *) "TTA1", 4);
+                put_le16(&b, 1);
+                put_le16(&b, audiotrack->channels);
+                put_le16(&b, audiotrack->bitdepth);
+                put_le32(&b, audiotrack->samplerate);
+                put_le32(&b, matroska->ctx->duration * audiotrack->samplerate);
+            }
+
+            else if (codec_id == CODEC_ID_RV10 || codec_id == CODEC_ID_RV20 ||
+                     codec_id == CODEC_ID_RV30 || codec_id == CODEC_ID_RV40) {
+                extradata_offset = 26;
+                track->codec_priv_size -= extradata_offset;
+                track->flags |= MATROSKA_TRACK_REAL_V;
+            }
+
             if (codec_id == CODEC_ID_NONE) {
                 av_log(matroska->ctx, AV_LOG_INFO,
                        "Unknown/unsupported CodecID %s.\n",
@@ -2210,6 +2306,10 @@
 
             st->codec->codec_id = codec_id;
 
+            if (track->default_duration)
+                av_reduce(&st->codec->time_base.num, &st->codec->time_base.den,
+                          track->default_duration, 1000000000, 30000);
+
             if(extradata){
                 st->codec->extradata = extradata;
                 st->codec->extradata_size = extradata_size;
@@ -2218,7 +2318,7 @@
                 if(st->codec->extradata == NULL)
                     return AVERROR_NOMEM;
                 st->codec->extradata_size = track->codec_priv_size;
-                memcpy(st->codec->extradata, track->codec_priv,
+                memcpy(st->codec->extradata,track->codec_priv+extradata_offset,
                        track->codec_priv_size);
             }
 
@@ -2250,9 +2350,10 @@
 
             /* What do we do with private data? E.g. for Vorbis. */
         }
+        res = 0;
     }
 
-    return 0;
+    return res;
 }
 
 static int
@@ -2268,14 +2369,22 @@
     return -1;
 }
 
+static inline int
+rv_offset(uint8_t *data, int slice, int slices)
+{
+    return AV_RL32(data+8*slice+4) + 8*slices;
+}
+
 static int
 matroska_parse_blockgroup (MatroskaDemuxContext *matroska,
                            uint64_t              cluster_time)
 {
     int res = 0;
     uint32_t id;
-    AVPacket *pkt;
+    AVPacket *pkt = NULL;
     int is_keyframe = PKT_FLAG_KEY, last_num_packets = matroska->num_packets;
+    uint64_t duration = AV_NOPTS_VALUE;
+    int track = -1;
 
     av_log(matroska->ctx, AV_LOG_DEBUG, "parsing blockgroup...\n");
 
@@ -2297,7 +2406,7 @@
                 int size;
                 int16_t block_time;
                 uint32_t *lace_size = NULL;
-                int n, track, flags, laces = 0;
+                int n, flags, laces = 0;
                 uint64_t num;
                 int64_t pos= url_ftell(&matroska->ctx->pb);
 
@@ -2305,7 +2414,7 @@
                     break;
                 origdata = data;
 
-                /* first byte(s): blocknum */
+                /* first byte(s): tracknum */
                 if ((n = matroska_ebmlnum_uint(data, size, &num)) < 0) {
                     av_log(matroska->ctx, AV_LOG_ERROR,
                            "EBML block data error\n");
@@ -2416,32 +2525,49 @@
                 }
 
                 if (res == 0) {
+                    int real_v = matroska->tracks[track]->flags & MATROSKA_TRACK_REAL_V;
                     for (n = 0; n < laces; n++) {
                         uint64_t timecode = AV_NOPTS_VALUE;
+                        int slice, slices = 1;
 
-                        pkt = av_mallocz(sizeof(AVPacket));
-                        /* XXX: prevent data copy... */
-                        if (av_new_packet(pkt,lace_size[n]) < 0) {
-                            res = AVERROR_NOMEM;
-                            break;
+                        if (real_v) {
+                            slices = *data++ + 1;
+                            lace_size[n]--;
                         }
                         if (cluster_time != (uint64_t)-1 && n == 0) {
                             if (cluster_time + block_time >= 0)
-                                timecode = cluster_time + block_time;
+                                timecode = (cluster_time + block_time) * matroska->time_scale;
                         }
                         /* FIXME: duration */
 
-                        memcpy(pkt->data, data, lace_size[n]);
-                        data += lace_size[n];
-                        if (n == 0)
-                            pkt->flags = is_keyframe;
-                        pkt->stream_index =
-                            matroska->tracks[track]->stream_index;
+                        for (slice=0; slice<slices; slice++) {
+                            int slice_size, slice_offset = 0;
+                            if (real_v)
+                                slice_offset = rv_offset(data, slice, slices);
+                            if (slice+1 == slices)
+                                slice_size = lace_size[n] - slice_offset;
+                            else
+                                slice_size = rv_offset(data, slice+1, slices) - slice_offset;
+                            pkt = av_mallocz(sizeof(AVPacket));
+                            /* XXX: prevent data copy... */
+                            if (av_new_packet(pkt, slice_size) < 0) {
+                                res = AVERROR_NOMEM;
+                                n = laces-1;
+                                break;
+                            }
+                            memcpy (pkt->data, data+slice_offset, slice_size);
 
-                        pkt->pts = timecode;
-                        pkt->pos= pos;
+                            if (n == 0)
+                                pkt->flags = is_keyframe;
+                            pkt->stream_index =
+                                matroska->tracks[track]->stream_index;
 
-                        matroska_queue_packet(matroska, pkt);
+                            pkt->pts = timecode;
+                            pkt->pos = pos;
+
+                            matroska_queue_packet(matroska, pkt);
+                        }
+                        data += lace_size[n];
                     }
                 }
 
@@ -2451,11 +2577,8 @@
             }
 
             case MATROSKA_ID_BLOCKDURATION: {
-                uint64_t num;
-                if ((res = ebml_read_uint(matroska, &id, &num)) < 0)
+                if ((res = ebml_read_uint(matroska, &id, &duration)) < 0)
                     break;
-                av_log(matroska->ctx, AV_LOG_INFO,
-                       "FIXME: implement support for BlockDuration\n");
                 break;
             }
 
@@ -2484,6 +2607,14 @@
         }
     }
 
+    if (pkt)
+    {
+        if (duration != AV_NOPTS_VALUE)
+            pkt->duration = duration;
+        else if (track >= 0 && track < matroska->num_tracks)
+            pkt->duration = matroska->tracks[track]->default_duration / matroska->time_scale;
+    }
+
     return res;
 }
 
@@ -2599,12 +2730,9 @@
     MatroskaDemuxContext *matroska = s->priv_data;
     int n = 0;
 
-    if (matroska->writing_app)
-        av_free(matroska->writing_app);
-    if (matroska->muxing_app)
-        av_free(matroska->muxing_app);
-    if (matroska->index)
-        av_free(matroska->index);
+    av_free(matroska->writing_app);
+    av_free(matroska->muxing_app);
+    av_free(matroska->index);
 
     if (matroska->packets != NULL) {
         for (n = 0; n < matroska->num_packets; n++) {
@@ -2616,22 +2744,15 @@
 
     for (n = 0; n < matroska->num_tracks; n++) {
         MatroskaTrack *track = matroska->tracks[n];
-        if (track->codec_id)
-            av_free(track->codec_id);
-        if (track->codec_name)
-            av_free(track->codec_name);
-        if (track->codec_priv)
-            av_free(track->codec_priv);
-        if (track->name)
-            av_free(track->name);
-        if (track->language)
-            av_free(track->language);
+        av_free(track->codec_id);
+        av_free(track->codec_name);
+        av_free(track->codec_priv);
+        av_free(track->name);
+        av_free(track->language);
 
         av_free(track);
     }
 
-    memset(matroska, 0, sizeof(MatroskaDemuxContext));
-
     return 0;
 }
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/mov.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/mov.c	2007-01-20 15:15:58 UTC (rev 2746)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/mov.c	2007-01-21 18:04:24 UTC (rev 2747)
@@ -1,19 +1,21 @@
 /*
- * MOV decoder.
+ * MOV demuxer
  * Copyright (c) 2001 Fabrice Bellard.
  *
- * This library is free software; you can redistribute it and/or
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
+ * version 2.1 of the License, or (at your option) any later version.
  *
- * This library is distributed in the hope that it will be useful,
+ * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
+ * License along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
@@ -24,7 +26,7 @@
 #include "avformat.h"
 #include "riff.h"
 #include "isom.h"
-// MEANX #include "dv.h"
+#include "dv.h"
 
 #ifdef CONFIG_ZLIB
 #include <zlib.h>
@@ -58,13 +60,13 @@
  * QuickTime is a trademark of Apple (AFAIK :))
  */
 
-// MEANX #include "qtpalette.h"
+#include "qtpalette.h"
 
 
 #undef NDEBUG
 #include <assert.h>
 
-static const CodecTag mov_video_tags[] = {
+static const AVCodecTag mov_video_tags[] = {
 /*  { CODEC_ID_, MKTAG('c', 'v', 'i', 'd') }, *//* Cinepak */
 /*  { CODEC_ID_H263, MKTAG('r', 'a', 'w', ' ') }, *//* Uncompressed RGB */
 /*  { CODEC_ID_H263, MKTAG('Y', 'u', 'v', '2') }, *//* Uncompressed YUV422 */
@@ -79,7 +81,7 @@
     { CODEC_ID_MJPEGB, MKTAG('m', 'j', 'p', 'b') }, /* Motion-JPEG (format B) */
     { CODEC_ID_MJPEG, MKTAG('A', 'V', 'D', 'J') }, /* MJPEG with alpha-channel (AVID JFIF meridien compressed) */
 /*    { CODEC_ID_MJPEG, MKTAG('A', 'V', 'R', 'n') }, *//* MJPEG with alpha-channel (AVID ABVB/Truevision NuVista) */
-/*    { CODEC_ID_GIF, MKTAG('g', 'i', 'f', ' ') }, *//* embedded gif files as frames (usually one "click to play movie" frame) */
+    { CODEC_ID_GIF, MKTAG('g', 'i', 'f', ' ') }, /* embedded gif files as frames (usually one "click to play movie" frame) */
 /* Sorenson video */
     { CODEC_ID_SVQ1, MKTAG('S', 'V', 'Q', '1') }, /* Sorenson Video v1 */
     { CODEC_ID_SVQ1, MKTAG('s', 'v', 'q', '1') }, /* Sorenson Video v1 */
@@ -100,6 +102,7 @@
     { CODEC_ID_8BPS, MKTAG('8', 'B', 'P', 'S') }, /* Planar RGB (8BPS) */
     { CODEC_ID_SMC, MKTAG('s', 'm', 'c', ' ') }, /* Apple Graphics (SMC) */
     { CODEC_ID_QTRLE, MKTAG('r', 'l', 'e', ' ') }, /* Apple Animation (RLE) */
+    { CODEC_ID_MSRLE, MKTAG('W', 'R', 'L', 'E') },
     { CODEC_ID_QDRAW, MKTAG('q', 'd', 'r', 'w') }, /* QuickDraw */
     { CODEC_ID_H264, MKTAG('a', 'v', 'c', '1') }, /* AVC-1/H.264 */
     { CODEC_ID_MPEG2VIDEO, MKTAG('h', 'd', 'v', '2') }, /* MPEG2 produced by Sony HD camera */
@@ -115,11 +118,16 @@
     { CODEC_ID_DVVIDEO, MKTAG('d', 'v', '5', 'n') }, /* DVCPRO50 NTSC produced by FCP */
     { CODEC_ID_DVVIDEO, MKTAG('A', 'V', 'd', 'v') }, /* AVID DV */
     //{ CODEC_ID_JPEG2000, MKTAG('m', 'j', 'p', '2') }, /* JPEG 2000 produced by FCP */
+    { CODEC_ID_TARGA, MKTAG('t', 'g', 'a', ' ') }, /* Truevision Targa */
+    { CODEC_ID_TIFF, MKTAG('t', 'i', 'f', 'f') }, /* TIFF embedded in MOV */
     { CODEC_ID_RAWVIDEO, MKTAG('2', 'v', 'u', 'y') }, /* UNCOMPRESSED 8BIT 4:2:2 */
+    { CODEC_ID_VC1,  MKTAG('v', 'c', '-', '1') }, /* SMPTE RP 2025 */
+    { CODEC_ID_WMV3, MKTAG('v', 'c', '-', '1') }, /* SMPTE RP 2025 */
+    { CODEC_ID_PNG,  MKTAG('p', 'n', 'g', ' ') },
     { CODEC_ID_NONE, 0 },
 };
 
-static const CodecTag mov_audio_tags[] = {
+static const AVCodecTag mov_audio_tags[] = {
     { CODEC_ID_PCM_S32BE, MKTAG('i', 'n', '3', '2') },
     { CODEC_ID_PCM_S24BE, MKTAG('i', 'n', '2', '4') },
     { CODEC_ID_PCM_S16BE, MKTAG('N', 'O', 'N', 'E') }, /* uncompressed */
@@ -147,6 +155,7 @@
     { CODEC_ID_QDM2,MKTAG('Q', 'D', 'M', '2') }, /* QDM2 */
     { CODEC_ID_DVAUDIO, MKTAG('v', 'd', 'v', 'a') },
     { CODEC_ID_DVAUDIO, MKTAG('d', 'v', 'c', 'a') },
+    { CODEC_ID_PCM_S16LE, MKTAG('l', 'p', 'c', 'm') },
     { CODEC_ID_NONE, 0 },
 };
 
@@ -257,7 +266,6 @@
 } MOVStreamContext;
 
 typedef struct MOVContext {
-    int mp4; /* set to 1 as soon as we are sure that the file is an .mp4 file (even some header parsing depends on this) */
     AVFormatContext *fc;
     int time_scale;
     int64_t duration; /* duration of the longest track */
@@ -279,8 +287,9 @@
     AVPaletteControl palette_control;
     MOV_mdat_atom_t *mdat_list;
     int mdat_count;
-    // MEANX DVDemuxContext *dv_demux;
+    DVDemuxContext *dv_demux;
     AVFormatContext *dv_fctx;
+    int isom; /* 1 if file is ISO Media (mp4/3gp) */
 } MOVContext;
 
 
@@ -299,14 +308,6 @@
     uint32_t type;
     mov_parse_function func;
 } MOVParseTableEntry;
-#if 0 //MEANx
-static int mov_read_leaf(MOVContext *c, ByteIOContext *pb, MOV_atom_t atom)
-{
-    if (atom.size>1)
-        url_fskip(pb, atom.size);
-/*        url_seek(pb, atom_offset+atom.size, SEEK_SET); */
-    return 0;
-}
 
 static int mov_read_default(MOVContext *c, ByteIOContext *pb, MOV_atom_t atom)
 {
@@ -397,7 +398,6 @@
 static int mov_read_hdlr(MOVContext *c, ByteIOContext *pb, MOV_atom_t atom)
 {
     AVStream *st = c->fc->streams[c->fc->nb_streams-1];
-    int len = 0;
     uint32_t type;
     uint32_t ctype;
 
@@ -410,32 +410,25 @@
 
     dprintf("ctype= %c%c%c%c (0x%08lx)\n", *((char *)&ctype), ((char *)&ctype)[1], ((char *)&ctype)[2], ((char *)&ctype)[3], (long) ctype);
     dprintf("stype= %c%c%c%c\n", *((char *)&type), ((char *)&type)[1], ((char *)&type)[2], ((char *)&type)[3]);
-    if(ctype == MKTAG('m', 'h', 'l', 'r')) /* MOV */
-        c->mp4 = 0;
-    else if(ctype == 0)
-        c->mp4 = 1;
+    if(!ctype)
+        c->isom = 1;
     if(type == MKTAG('v', 'i', 'd', 'e'))
         st->codec->codec_type = CODEC_TYPE_VIDEO;
     else if(type == MKTAG('s', 'o', 'u', 'n'))
         st->codec->codec_type = CODEC_TYPE_AUDIO;
+    else if(type == MKTAG('m', '1', 'a', ' '))
+        st->codec->codec_id = CODEC_ID_MP2;
+    else if(type == MKTAG('s', 'u', 'b', 'p')) {
+        st->codec->codec_type = CODEC_TYPE_SUBTITLE;
+        st->codec->codec_id = CODEC_ID_DVD_SUBTITLE;
+    }
     get_be32(pb); /* component  manufacture */
     get_be32(pb); /* component flags */
     get_be32(pb); /* component flags mask */
 
     if(atom.size <= 24)
         return 0; /* nothing left to read */
-    /* XXX: MP4 uses a C string, not a pascal one */
-    /* component name */
 
-    if(c->mp4) {
-        /* .mp4: C string */
-        while(get_byte(pb) && (++len < (atom.size - 24)));
-    } else {
-        /* .mov: PASCAL string */
-        len = get_byte(pb);
-        url_fskip(pb, len);
-    }
-
     url_fskip(pb, atom.size - (url_ftell(pb) - atom.offset));
     return 0;
 }
@@ -490,12 +483,12 @@
         len = mov_mp4_read_descr(pb, &tag);
         if (tag == MP4DecSpecificDescrTag) {
             dprintf("Specific MPEG4 header len=%d\n", len);
-            st->codec->extradata = (uint8_t*) av_mallocz(len + FF_INPUT_BUFFER_PADDING_SIZE);
+            st->codec->extradata = av_mallocz(len + FF_INPUT_BUFFER_PADDING_SIZE);
             if (st->codec->extradata) {
                 get_buffer(pb, st->codec->extradata, len);
                 st->codec->extradata_size = len;
                 /* from mplayer */
-                if ((*(uint8_t *)st->codec->extradata >> 3) == 29) {
+                if ((*st->codec->extradata >> 3) == 29) {
                     st->codec->codec_id = CODEC_ID_MP3ON4;
                 }
             }
@@ -526,26 +519,9 @@
 {
     uint32_t type = get_le32(pb);
 
-    /* from mplayer */
-    switch (type) {
-    case MKTAG('i', 's', 'o', 'm'):
-    case MKTAG('m', 'p', '4', '1'):
-    case MKTAG('m', 'p', '4', '2'):
-    case MKTAG('3', 'g', 'p', '1'):
-    case MKTAG('3', 'g', 'p', '2'):
-    case MKTAG('3', 'g', '2', 'a'):
-    case MKTAG('3', 'g', 'p', '3'):
-    case MKTAG('3', 'g', 'p', '4'):
-    case MKTAG('3', 'g', 'p', '5'):
-    case MKTAG('m', 'm', 'p', '4'): /* Mobile MP4 */
-    case MKTAG('M', '4', 'A', ' '): /* Apple iTunes AAC-LC Audio */
-    case MKTAG('M', '4', 'P', ' '): /* Apple iTunes AAC-LC Protected Audio */
-    case MKTAG('m', 'j', 'p', '2'): /* Motion Jpeg 2000 */
-        c->mp4 = 1;
-    case MKTAG('q', 't', ' ', ' '):
-    default:
-        av_log(c->fc, AV_LOG_DEBUG, "ISO: File Type Major Brand: %.4s\n",(char *)&type);
-    }
+    if (type != MKTAG('q','t',' ',' '))
+        c->isom = 1;
+    av_log(c->fc, AV_LOG_DEBUG, "ISO: File Type Major Brand: %.4s\n",(char *)&type);
     get_be32(pb); /* minor version */
     url_fskip(pb, atom.size - 8);
     return 0;
@@ -644,12 +620,12 @@
     // this should be fixed and just SMI header should be passed
     av_free(st->codec->extradata);
     st->codec->extradata_size = 0x5a + atom.size;
-    st->codec->extradata = (uint8_t*) av_mallocz(st->codec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);
+    st->codec->extradata = av_mallocz(st->codec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);
 
     if (st->codec->extradata) {
         strcpy(st->codec->extradata, "SVQ3"); // fake
         get_buffer(pb, st->codec->extradata + 0x5a, atom.size);
-        dprintf("Reading SMI %"PRId64"  %s\n", atom.size, (char*)st->codec->extradata + 0x5a);
+        dprintf("Reading SMI %"PRId64"  %s\n", atom.size, st->codec->extradata + 0x5a);
     } else
         url_fskip(pb, atom.size);
 
@@ -685,12 +661,12 @@
 
     av_free(st->codec->extradata);
     st->codec->extradata_size = 36;
-    st->codec->extradata = (uint8_t*) av_mallocz(st->codec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);
+    st->codec->extradata = av_mallocz(st->codec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);
 
     if (st->codec->extradata) {
         strcpy(st->codec->extradata + 4, "alac"); // fake
         get_buffer(pb, st->codec->extradata + 8, 36 - 8);
-        dprintf("Reading alac %d  %s\n", st->codec->extradata_size, (char*)st->codec->extradata);
+        dprintf("Reading alac %d  %s\n", st->codec->extradata_size, st->codec->extradata);
     } else
         url_fskip(pb, atom.size);
     return 0;
@@ -707,7 +683,7 @@
         // pass all frma atom to codec, needed at least for QDM2
         av_free(st->codec->extradata);
         st->codec->extradata_size = atom.size;
-        st->codec->extradata = (uint8_t*) av_mallocz(st->codec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);
+        st->codec->extradata = av_mallocz(st->codec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);
 
         if (st->codec->extradata) {
             get_buffer(pb, st->codec->extradata, atom.size);
@@ -730,7 +706,7 @@
     av_free(st->codec->extradata);
 
     st->codec->extradata_size = atom.size + 8;
-    st->codec->extradata = (uint8_t*) av_mallocz(st->codec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);
+    st->codec->extradata = av_mallocz(st->codec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);
 
     /* pass all jp2h atom to codec */
     if (st->codec->extradata) {
@@ -751,7 +727,7 @@
     av_free(st->codec->extradata);
 
     st->codec->extradata_size = atom.size;
-    st->codec->extradata = (uint8_t*) av_mallocz(st->codec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);
+    st->codec->extradata = av_mallocz(st->codec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);
 
     if (st->codec->extradata) {
         get_buffer(pb, st->codec->extradata, atom.size);
@@ -776,7 +752,7 @@
         return -1;
 
     sc->chunk_count = entries;
-    sc->chunk_offsets = (int64_t*) av_malloc(entries * sizeof(int64_t));
+    sc->chunk_offsets = av_malloc(entries * sizeof(int64_t));
     if (!sc->chunk_offsets)
         return -1;
     if (atom.type == MKTAG('s', 't', 'c', 'o')) {
@@ -837,9 +813,10 @@
 
         st->codec->codec_tag = format;
         id = codec_get_id(mov_audio_tags, format);
-        if (id > 0) {
+        if (st->codec->codec_type != CODEC_TYPE_VIDEO && id > 0) {
             st->codec->codec_type = CODEC_TYPE_AUDIO;
-        } else if (format && format != MKTAG('m', 'p', '4', 's')) { /* skip old asf mpeg4 tag */
+        } else if (st->codec->codec_type != CODEC_TYPE_AUDIO && /* do not overwrite codec type */
+                   format && format != MKTAG('m', 'p', '4', 's')) { /* skip old asf mpeg4 tag */
             id = codec_get_id(mov_video_tags, format);
             if (id <= 0)
                 id = codec_get_id(codec_bmp_tags, format);
@@ -977,34 +954,38 @@
             case CODEC_ID_PCM_S16BE:
                 if (st->codec->bits_per_sample == 8)
                     st->codec->codec_id = CODEC_ID_PCM_S8;
+                else if (st->codec->bits_per_sample == 24)
+                    st->codec->codec_id = CODEC_ID_PCM_S24BE;
                 break;
             default:
                 break;
             }
 
+            //Read QT version 1 fields. In version 0 theese dont exist
+            dprintf("version =%d, isom =%d\n",version,c->isom);
+            if(!c->isom) {
+                if(version==1) {
+                    sc->sample_size_v1.den = get_be32(pb); /* samples per packet */
+                    get_be32(pb); /* bytes per packet */
+                    sc->sample_size_v1.num = get_be32(pb); /* bytes per frame */
+                    get_be32(pb); /* bytes per sample */
+                } else if(version==2) {
+                    get_be32(pb); /* sizeof struct only */
+                    st->codec->sample_rate = av_int2dbl(get_be64(pb)); /* float 64 */
+                    st->codec->channels = get_be32(pb);
+                    get_be32(pb); /* always 0x7F000000 */
+                    get_be32(pb); /* bits per channel if sound is uncompressed */
+                    get_be32(pb); /* lcpm format specific flag */
+                    get_be32(pb); /* bytes per audio packet if constant */
+                    get_be32(pb); /* lpcm frames per audio packet if constant */
+                }
+            }
+
             bits_per_sample = av_get_bits_per_sample(st->codec->codec_id);
             if (bits_per_sample) {
                 st->codec->bits_per_sample = bits_per_sample;
                 sc->sample_size = (bits_per_sample >> 3) * st->codec->channels;
             }
-
-            //Read QT version 1 fields. In version 0 theese dont exist
-            dprintf("version =%d mp4=%d\n",version,c->mp4);
-            if(version==1) {
-                sc->sample_size_v1.den = get_be32(pb); /* samples per packet */
-                get_be32(pb); /* bytes per packet */
-                sc->sample_size_v1.num = get_be32(pb); /* bytes per frame */
-                get_be32(pb); /* bytes per sample */
-            } else if(version==2) {
-                get_be32(pb); /* sizeof struct only */
-                st->codec->sample_rate = av_int2dbl(get_be64(pb)); /* float 64 */
-                st->codec->channels = get_be32(pb);
-                get_be32(pb); /* always 0x7F000000 */
-                get_be32(pb); /* bits per channel if sound is uncompressed */
-                get_be32(pb); /* lcpm format specific flag */
-                get_be32(pb); /* bytes per audio packet if constant */
-                get_be32(pb); /* lpcm frames per audio packet if constant */
-            }
         } else {
             /* other codec type, just skip (rtp, mp4s, tmcd ...) */
             url_fskip(pb, size - (url_ftell(pb) - start_pos));
@@ -1035,7 +1016,7 @@
         st->codec->width= 0; /* let decoder init width/height */
         st->codec->height= 0;
         break;
-#ifdef CONFIG_FAAD
+#ifdef CONFIG_LIBFAAD
     case CODEC_ID_AAC:
 #endif
 #ifdef CONFIG_VORBIS_DECODER
@@ -1065,6 +1046,10 @@
         st->codec->sample_rate= 8000;
         st->codec->channels= 1; /* really needed */
         break;
+    case CODEC_ID_MP2:
+        st->codec->codec_type = CODEC_TYPE_AUDIO; /* force type after stsd for m1a hdlr */
+        st->need_parsing = 1;
+        break;
     default:
         break;
     }
@@ -1090,7 +1075,7 @@
 av_log(NULL, AV_LOG_DEBUG, "track[%i].stsc.entries = %i\n", c->fc->nb_streams-1, entries);
 #endif
     sc->sample_to_chunk_sz = entries;
-    sc->sample_to_chunk = (MOV_sample_to_chunk_tbl*) av_malloc(entries * sizeof(MOV_sample_to_chunk_tbl));
+    sc->sample_to_chunk = av_malloc(entries * sizeof(MOV_sample_to_chunk_tbl));
     if (!sc->sample_to_chunk)
         return -1;
     for(i=0; i<entries; i++) {
@@ -1119,7 +1104,7 @@
 #ifdef DEBUG
     av_log(NULL, AV_LOG_DEBUG, "keyframe_count = %ld\n", sc->keyframe_count);
 #endif
-    sc->keyframes = (long*) av_malloc(entries * sizeof(long));
+    sc->keyframes = av_malloc(entries * sizeof(long));
     if (!sc->keyframes)
         return -1;
     for(i=0; i<entries; i++) {
@@ -1154,7 +1139,7 @@
 #ifdef DEBUG
     av_log(NULL, AV_LOG_DEBUG, "sample_size = %ld sample_count = %ld\n", sc->sample_size, sc->sample_count);
 #endif
-    sc->sample_sizes = (long*) av_malloc(entries * sizeof(long));
+    sc->sample_sizes = av_malloc(entries * sizeof(long));
     if (!sc->sample_sizes)
         return -1;
     for(i=0; i<entries; i++) {
@@ -1254,7 +1239,7 @@
 
     st = av_new_stream(c->fc, c->fc->nb_streams);
     if (!st) return -2;
-    sc = (MOVStreamContext*) av_mallocz(sizeof(MOVStreamContext));
+    sc = av_mallocz(sizeof(MOVStreamContext));
     if (!sc) {
         av_free(st);
         return -1;
@@ -1334,15 +1319,9 @@
     return err;
 }
 
-
-#ifdef CONFIG_ZLIB
-static int null_read_packet(void *opaque, uint8_t *buf, int buf_size)
-{
-    return -1;
-}
-
 static int mov_read_cmov(MOVContext *c, ByteIOContext *pb, MOV_atom_t atom)
 {
+#ifdef CONFIG_ZLIB
     ByteIOContext ctx;
     uint8_t *cmov_data;
     uint8_t *moov_data; /* uncompressed data */
@@ -1362,10 +1341,10 @@
     moov_len = get_be32(pb); /* uncompressed size */
     cmov_len = atom.size - 6 * 4;
 
-    cmov_data = (uint8_t *) av_malloc(cmov_len);
+    cmov_data = av_malloc(cmov_len);
     if (!cmov_data)
         return -1;
-    moov_data = (uint8_t *) av_malloc(moov_len);
+    moov_data = av_malloc(moov_len);
     if (!moov_data) {
         av_free(cmov_data);
         return -1;
@@ -1373,9 +1352,8 @@
     get_buffer(pb, cmov_data, cmov_len);
     if(uncompress (moov_data, (uLongf *) &moov_len, (const Bytef *)cmov_data, cmov_len) != Z_OK)
         return -1;
-    if(init_put_byte(&ctx, moov_data, moov_len, 0, NULL, null_read_packet, NULL, NULL) != 0)
+    if(init_put_byte(&ctx, moov_data, moov_len, 0, NULL, NULL, NULL, NULL) != 0)
         return -1;
-    ctx.buf_end = ctx.buffer + moov_len;
     atom.type = MKTAG( 'm', 'o', 'o', 'v' );
     atom.offset = 0;
     atom.size = moov_len;
@@ -1385,10 +1363,12 @@
     ret = mov_read_default(c, &ctx, atom);
     av_free(moov_data);
     av_free(cmov_data);
-
     return ret;
-}
+#else
+    av_log(c->fc, AV_LOG_ERROR, "this file requires zlib support compiled in\n");
+    return -1;
 #endif
+}
 
 /* edit list atom */
 static int mov_read_elst(MOVContext *c, ByteIOContext *pb, MOV_atom_t atom)
@@ -1411,84 +1391,37 @@
 static const MOVParseTableEntry mov_default_parse_table[] = {
 /* mp4 atoms */
 { MKTAG( 'c', 'o', '6', '4' ), mov_read_stco },
-{ MKTAG( 'c', 'p', 'r', 't' ), mov_read_default },
-{ MKTAG( 'c', 'r', 'h', 'd' ), mov_read_default },
 { MKTAG( 'c', 't', 't', 's' ), mov_read_ctts }, /* composition time to sample */
-{ MKTAG( 'd', 'i', 'n', 'f' ), mov_read_default }, /* data information */
-{ MKTAG( 'd', 'p', 'n', 'd' ), mov_read_leaf },
-{ MKTAG( 'd', 'r', 'e', 'f' ), mov_read_leaf },
 { MKTAG( 'e', 'd', 't', 's' ), mov_read_default },
 { MKTAG( 'e', 'l', 's', 't' ), mov_read_elst },
 { MKTAG( 'e', 'n', 'd', 'a' ), mov_read_enda },
-{ MKTAG( 'f', 'r', 'e', 'e' ), mov_read_leaf },
 { MKTAG( 'f', 't', 'y', 'p' ), mov_read_ftyp },
 { MKTAG( 'h', 'd', 'l', 'r' ), mov_read_hdlr },
-{ MKTAG( 'h', 'i', 'n', 't' ), mov_read_leaf },
-{ MKTAG( 'h', 'm', 'h', 'd' ), mov_read_leaf },
-{ MKTAG( 'i', 'o', 'd', 's' ), mov_read_leaf },
 { MKTAG( 'j', 'p', '2', 'h' ), mov_read_jp2h },
 { MKTAG( 'm', 'd', 'a', 't' ), mov_read_mdat },
 { MKTAG( 'm', 'd', 'h', 'd' ), mov_read_mdhd },
 { MKTAG( 'm', 'd', 'i', 'a' ), mov_read_default },
 { MKTAG( 'm', 'i', 'n', 'f' ), mov_read_default },
 { MKTAG( 'm', 'o', 'o', 'v' ), mov_read_moov },
-{ MKTAG( 'm', 'p', '4', 'a' ), mov_read_default },
-{ MKTAG( 'm', 'p', '4', 's' ), mov_read_default },
-{ MKTAG( 'm', 'p', '4', 'v' ), mov_read_default },
-{ MKTAG( 'm', 'p', 'o', 'd' ), mov_read_leaf },
 { MKTAG( 'm', 'v', 'h', 'd' ), mov_read_mvhd },
-{ MKTAG( 'n', 'm', 'h', 'd' ), mov_read_leaf },
-{ MKTAG( 'o', 'd', 'h', 'd' ), mov_read_default },
-{ MKTAG( 's', 'd', 'h', 'd' ), mov_read_default },
-{ MKTAG( 's', 'k', 'i', 'p' ), mov_read_leaf },
-{ MKTAG( 's', 'm', 'h', 'd' ), mov_read_leaf }, /* sound media info header */
 { MKTAG( 'S', 'M', 'I', ' ' ), mov_read_smi }, /* Sorenson extension ??? */
 { MKTAG( 'a', 'l', 'a', 'c' ), mov_read_alac }, /* alac specific atom */
 { MKTAG( 'a', 'v', 'c', 'C' ), mov_read_avcC },
 { MKTAG( 's', 't', 'b', 'l' ), mov_read_default },
 { MKTAG( 's', 't', 'c', 'o' ), mov_read_stco },
-{ MKTAG( 's', 't', 'd', 'p' ), mov_read_default },
 { MKTAG( 's', 't', 's', 'c' ), mov_read_stsc },
 { MKTAG( 's', 't', 's', 'd' ), mov_read_stsd }, /* sample description */
-{ MKTAG( 's', 't', 's', 'h' ), mov_read_default },
 { MKTAG( 's', 't', 's', 's' ), mov_read_stss }, /* sync sample */
 { MKTAG( 's', 't', 's', 'z' ), mov_read_stsz }, /* sample size */
 { MKTAG( 's', 't', 't', 's' ), mov_read_stts },
 { MKTAG( 't', 'k', 'h', 'd' ), mov_read_tkhd }, /* track header */
 { MKTAG( 't', 'r', 'a', 'k' ), mov_read_trak },
-{ MKTAG( 't', 'r', 'e', 'f' ), mov_read_default }, /* not really */
-{ MKTAG( 'u', 'd', 't', 'a' ), mov_read_leaf },
-{ MKTAG( 'u', 'r', 'l', ' ' ), mov_read_leaf },
-{ MKTAG( 'u', 'r', 'n', ' ' ), mov_read_leaf },
-{ MKTAG( 'u', 'u', 'i', 'd' ), mov_read_leaf },
-{ MKTAG( 'v', 'm', 'h', 'd' ), mov_read_leaf }, /* video media info header */
 { MKTAG( 'w', 'a', 'v', 'e' ), mov_read_wave },
-/* extra mp4 */
-{ MKTAG( 'M', 'D', 'E', 'S' ), mov_read_leaf },
-/* QT atoms */
-{ MKTAG( 'c', 'h', 'a', 'p' ), mov_read_leaf },
-{ MKTAG( 'c', 'l', 'i', 'p' ), mov_read_default },
-{ MKTAG( 'c', 'r', 'g', 'n' ), mov_read_leaf },
 { MKTAG( 'c', 't', 'a', 'b' ), mov_read_ctab },
 { MKTAG( 'e', 's', 'd', 's' ), mov_read_esds },
-{ MKTAG( 'k', 'm', 'a', 't' ), mov_read_leaf },
-{ MKTAG( 'm', 'a', 't', 't' ), mov_read_default },
-{ MKTAG( 'r', 'd', 'r', 'f' ), mov_read_leaf },
-{ MKTAG( 'r', 'm', 'd', 'a' ), mov_read_default },
-{ MKTAG( 'r', 'm', 'd', 'r' ), mov_read_leaf },
-{ MKTAG( 'r', 'm', 'r', 'a' ), mov_read_default },
-{ MKTAG( 's', 'c', 'p', 't' ), mov_read_leaf },
-{ MKTAG( 's', 's', 'r', 'c' ), mov_read_leaf },
-{ MKTAG( 's', 'y', 'n', 'c' ), mov_read_leaf },
-{ MKTAG( 't', 'c', 'm', 'd' ), mov_read_leaf },
 { MKTAG( 'w', 'i', 'd', 'e' ), mov_read_wide }, /* place holder */
-//{ MKTAG( 'r', 'm', 'q', 'u' ), mov_read_leaf },
-#ifdef CONFIG_ZLIB
 { MKTAG( 'c', 'm', 'o', 'v' ), mov_read_cmov },
-#else
-{ MKTAG( 'c', 'm', 'o', 'v' ), mov_read_leaf },
-#endif
-{ 0L, mov_read_leaf }
+{ 0L, NULL }
 };
 
 static void mov_free_stream_context(MOVStreamContext *sc)
@@ -1514,7 +1447,7 @@
         /* ignore invalid offset */
         if ((offset + 8) > (unsigned int)p->buf_size)
             return score;
-        tag = LE_32(p->buf + offset + 4);
+        tag = AV_RL32(p->buf + offset + 4);
         switch(tag) {
         /* check for obvious tags */
         case MKTAG( 'j', 'P', ' ', ' ' ): /* jpeg 2000 signature */
@@ -1532,7 +1465,7 @@
         case MKTAG( 'f', 't', 'y', 'p' ):
         case MKTAG( 's', 'k', 'i', 'p' ):
         case MKTAG( 'u', 'u', 'i', 'd' ):
-            offset = BE_32(p->buf+offset) + offset;
+            offset = AV_RB32(p->buf+offset) + offset;
             /* if we only find those cause probedata is too small at least rate them */
             score = AVPROBE_SCORE_MAX - 50;
             break;
@@ -1573,7 +1506,7 @@
                         stss_index++;
                 }
                 sample_size = sc->sample_size > 0 ? sc->sample_size : sc->sample_sizes[current_sample];
-                dprintf("AVIndex stream %d, sample %d, offset %llx, dts %lld, size %d, distance %d, keyframe %d\n",
+                dprintf("AVIndex stream %d, sample %d, offset %"PRIx64", dts %"PRId64", size %d, distance %d, keyframe %d\n",
                         st->index, current_sample, current_offset, current_dts, sample_size, distance, keyframe);
                 av_add_index_entry(st, current_offset, current_dts, sample_size, distance, keyframe ? AVINDEX_KEYFRAME : 0);
                 current_offset += sample_size;
@@ -1618,7 +1551,7 @@
                 /* check for last chunk */
                 if (chunk_size == INT_MAX)
                     for (j = 0; j < mov->mdat_count; j++) {
-                        dprintf("mdat %d, offset %llx, size %lld, current offset %llx\n",
+                        dprintf("mdat %d, offset %"PRIx64", size %"PRId64", current offset %"PRIx64"\n",
                                 j, mov->mdat_list[j].offset, mov->mdat_list[j].size, current_offset);
                         if (mov->mdat_list[j].offset <= current_offset && mov->mdat_list[j].offset + mov->mdat_list[j].size > current_offset)
                             chunk_size = mov->mdat_list[j].offset + mov->mdat_list[j].size - current_offset;
@@ -1644,7 +1577,7 @@
                     }
                 }
             }
-            dprintf("AVIndex stream %d, chunk %d, offset %llx, dts %lld, size %d, duration %d\n",
+            dprintf("AVIndex stream %d, chunk %d, offset %"PRIx64", dts %"PRId64", size %d, duration %d\n",
                     st->index, i, current_offset, current_dts, chunk_size, chunk_duration);
             assert(chunk_duration % sc->time_rate == 0);
             current_dts += chunk_duration / sc->time_rate;
@@ -1728,7 +1661,7 @@
             AVIndexEntry *current_sample = &s->streams[i]->index_entries[msc->current_sample];
             int64_t dts = av_rescale(current_sample->timestamp * (int64_t)msc->time_rate, AV_TIME_BASE, msc->time_scale);
 
-            dprintf("stream %d, sample %ld, dts %lld\n", i, msc->current_sample, dts);
+            dprintf("stream %d, sample %ld, dts %"PRId64"\n", i, msc->current_sample, dts);
             if (dts < best_dts) {
                 sample = current_sample;
                 best_dts = dts;
@@ -1741,7 +1674,7 @@
     /* must be done just before reading, to avoid infinite loop on sample */
     sc->current_sample++;
     if (sample->pos >= url_fsize(&s->pb)) {
-        av_log(mov->fc, AV_LOG_ERROR, "stream %d, offset 0x%llx: partial file\n", sc->ffindex, sample->pos);
+        av_log(mov->fc, AV_LOG_ERROR, "stream %d, offset 0x%"PRIx64": partial file\n", sc->ffindex, sample->pos);
         return -1;
     }
 #ifdef CONFIG_DV_DEMUXER
@@ -1776,7 +1709,7 @@
     }
     pkt->flags |= sample->flags & AVINDEX_KEYFRAME ? PKT_FLAG_KEY : 0;
     pkt->pos = sample->pos;
-    dprintf("stream %d, pts %lld, dts %lld, pos 0x%llx, duration %d\n", pkt->stream_index, pkt->pts, pkt->dts, pkt->pos, pkt->duration);
+    dprintf("stream %d, pts %"PRId64", dts %"PRId64", pos 0x%"PRIx64", duration %d\n", pkt->stream_index, pkt->pts, pkt->dts, pkt->pos, pkt->duration);
     return 0;
 }
 
@@ -1787,7 +1720,7 @@
     int i;
 
     sample = av_index_search_timestamp(st, timestamp, flags);
-    dprintf("stream %d, timestamp %lld, sample %d\n", st->index, timestamp, sample);
+    dprintf("stream %d, timestamp %"PRId64", sample %d\n", st->index, timestamp, sample);
     if (sample < 0) /* not sure what to do */
         return -1;
     sc->current_sample = sample;
@@ -1867,4 +1800,3 @@
     mov_read_close,
     mov_read_seek,
 };
-#endif //MEANX

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/movenc.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/movenc.c	2007-01-20 15:15:58 UTC (rev 2746)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/movenc.c	2007-01-21 18:04:24 UTC (rev 2747)
@@ -1,23 +1,26 @@
 /*
- * MOV, 3GP, MP4 encoder.
+ * MOV, 3GP, MP4 muxer
  * Copyright (c) 2003 Thomas Raivio.
  * Copyright (c) 2004 Gildas Bazin <gbazin at videolan dot org>.
  *
- * This library is free software; you can redistribute it and/or
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
+ * version 2.1 of the License, or (at your option) any later version.
  *
- * This library is distributed in the hope that it will be useful,
+ * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
+ * License along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
-#include "config.h" //MEANX
+#include "config.h" 
+#define MEANX_PUT_MP3_IN_MP4A //MEANX
 #include "avformat.h"
 #include "riff.h"
 #include "avio.h"
@@ -43,6 +46,7 @@
     char         key_frame;
     unsigned int entries;
     int64_t      cts;
+    int64_t      dts;
 } MOVIentry;
 
 typedef struct MOVIndex {
@@ -52,7 +56,6 @@
     long        time;
     int64_t     trackDuration;
     long        sampleCount;
-    long        sampleDuration;
     long        sampleSize;
     int         hasKeyframes;
     int         hasBframes;
@@ -64,6 +67,7 @@
     int         vosLen;
     uint8_t     *vosData;
     MOVIentry   *cluster;
+    int         audio_vbr;
 } MOVTrack;
 
 typedef struct MOVContext {
@@ -320,7 +324,7 @@
     return updateSize (pb, pos);
 }
 
-static const CodecTag codec_movaudio_tags[] = {
+static const AVCodecTag codec_movaudio_tags[] = {
     { CODEC_ID_PCM_MULAW, MKTAG('u', 'l', 'a', 'w') },
     { CODEC_ID_PCM_ALAW, MKTAG('a', 'l', 'a', 'w') },
     { CODEC_ID_ADPCM_IMA_QT, MKTAG('i', 'm', 'a', '4') },
@@ -336,7 +340,7 @@
     { CODEC_ID_PCM_S32BE, MKTAG('i', 'n', '3', '2') },
     { CODEC_ID_PCM_S32LE, MKTAG('i', 'n', '3', '2') },
     //{ CODEC_ID_MP3, MKTAG('.', 'm', 'p', '3') },
-// MEANX
+   // MEANX
 #ifdef MEANX_PUT_MP3_IN_MP4A
     { CODEC_ID_MP3, MKTAG( 'm', 'p', '4','a') },
 #else
@@ -350,13 +354,10 @@
 static int mov_write_audio_tag(ByteIOContext *pb, MOVTrack* track)
 {
     offset_t pos = url_ftell(pb);
-    int vbr=  track->mode == MODE_MOV &&
-        (track->enc->codec_id == CODEC_ID_AAC ||
-         track->enc->codec_id == CODEC_ID_MP3 ||
-         track->enc->codec_id == CODEC_ID_AMR_NB);
-    int version = vbr ||
-        track->enc->codec_id == CODEC_ID_PCM_S32LE ||
-        track->enc->codec_id == CODEC_ID_PCM_S24LE;
+    int version = track->mode == MODE_MOV &&
+        (track->audio_vbr ||
+         track->enc->codec_id == CODEC_ID_PCM_S32LE ||
+         track->enc->codec_id == CODEC_ID_PCM_S24LE);
 
     put_be32(pb, 0); /* size */
     put_le32(pb, track->tag); // store it byteswapped
@@ -373,14 +374,12 @@
     /* FIXME 8 bit for 'raw ' in mov */
     put_be16(pb, 16); /* Reserved */
 
-    put_be16(pb, vbr ? 0xfffe : 0); /* compression ID */
+    put_be16(pb, track->mode == MODE_MOV && track->audio_vbr ? -2 : 0); /* compression ID */
     put_be16(pb, 0); /* packet size (= 0) */
     put_be16(pb, track->timescale); /* Time scale */
     put_be16(pb, 0); /* Reserved */
 
     if(version == 1) { /* SoundDescription V1 extended info */
-        if (vbr)
-            track->sampleSize = 0;
         put_be32(pb, track->enc->frame_size); /* Samples per packet */
         put_be32(pb, track->sampleSize / track->enc->channels); /* Bytes per packet */
         put_be32(pb, track->sampleSize); /* Bytes per frame */
@@ -394,13 +393,14 @@
         track->enc->codec_id == CODEC_ID_PCM_S32LE))
         mov_write_wave_tag(pb, track);
     else if(track->enc->codec_id == CODEC_ID_AAC
-//MEANX
+ //MEANX
 #ifdef MEANX_PUT_MP3_IN_MP4A
    || track->enc->codec_id == CODEC_ID_MP3
 #endif
 //MEANX
-	    
-		    )
+ 
+    
+    )
         mov_write_esds_tag(pb, track);
     else if(track->enc->codec_id == CODEC_ID_AMR_NB)
         mov_write_amr_tag(pb, track);
@@ -498,7 +498,7 @@
     put_tag(pb, "avcC");
     if (track->vosLen > 6) {
         /* check for h264 start code */
-        if (BE_32(track->vosData) == 0x00000001) {
+        if (AV_RB32(track->vosData) == 0x00000001) {
             uint8_t *buf, *end;
             uint32_t sps_size=0, pps_size=0;
             uint8_t *sps=0, *pps=0;
@@ -511,7 +511,7 @@
             while (buf < end) {
                 unsigned int size;
                 uint8_t nal_type;
-                size = BE_32(buf);
+                size = AV_RB32(buf);
                 nal_type = buf[4] & 0x1f;
                 if (nal_type == 7) { /* SPS */
                     sps = buf + 4;
@@ -544,7 +544,7 @@
     return updateSize(pb, pos);
 }
 
-static const CodecTag codec_movvideo_tags[] = {
+static const AVCodecTag codec_movvideo_tags[] = {
     { CODEC_ID_SVQ1, MKTAG('S', 'V', 'Q', '1') },
     { CODEC_ID_SVQ3, MKTAG('S', 'V', 'Q', '3') },
     { CODEC_ID_MPEG4, MKTAG('m', 'p', '4', 'v') },
@@ -718,18 +718,46 @@
     return atom_size;
 }
 
-/* TODO: */
 /* Time to sample atom */
 static int mov_write_stts_tag(ByteIOContext *pb, MOVTrack* track)
 {
-    put_be32(pb, 0x18); /* size */
+    Time2Sample *stts_entries;
+    uint32_t entries = -1;
+    uint32_t atom_size;
+    int i;
+
+    if (track->enc->codec_type == CODEC_TYPE_AUDIO && !track->audio_vbr) {
+        stts_entries = av_malloc(sizeof(*stts_entries)); /* one entry */
+        stts_entries[0].count = track->sampleCount;
+        stts_entries[0].duration = 1;
+        entries = 1;
+    } else {
+        stts_entries = av_malloc(track->entry * sizeof(*stts_entries)); /* worst case */
+        for (i=0; i<track->entry; i++) {
+            int64_t duration = i + 1 == track->entry ?
+                track->trackDuration - track->cluster[i].dts + track->cluster[0].dts : /* readjusting */
+                track->cluster[i+1].dts - track->cluster[i].dts;
+            if (i && duration == stts_entries[entries].duration) {
+                stts_entries[entries].count++; /* compress */
+            } else {
+                entries++;
+                stts_entries[entries].duration = duration;
+                stts_entries[entries].count = 1;
+            }
+        }
+        entries++; /* last one */
+    }
+    atom_size = 16 + (entries * 8);
+    put_be32(pb, atom_size); /* size */
     put_tag(pb, "stts");
     put_be32(pb, 0); /* version & flags */
-    put_be32(pb, 1); /* entry count */
-
-    put_be32(pb, track->sampleCount); /* sample count */
-    put_be32(pb, track->sampleDuration); /* sample duration */
-    return 0x18;
+    put_be32(pb, entries); /* entry count */
+    for (i=0; i<entries; i++) {
+        put_be32(pb, stts_entries[i].count);
+        put_be32(pb, stts_entries[i].duration);
+    }
+    av_free(stts_entries);
+    return atom_size;
 }
 
 static int mov_write_dref_tag(ByteIOContext *pb)
@@ -942,8 +970,7 @@
 
     put_be32(pb, av_rescale_rnd(track->trackDuration, globalTimescale, track->timescale, AV_ROUND_UP)); /* duration   ... doesn't seem to effect psp */
 
-    // MEANX NO! put_be32(pb, track->cluster[0].cts); /* first pts is cts since dts is 0 */
-
+    //MEANX NO put_be32(pb, track->cluster[0].cts); /* first pts is cts since dts is 0 */
     put_be32(pb, 0x00000000);
     // /MEANX
 
@@ -1218,19 +1245,25 @@
     return updateSize(pb, pos);
 }
 
+static int utf8len(uint8_t *b){
+    int len=0;
+    int val;
+    while(*b){
+        GET_UTF8(val, *b++, return -1;)
+        len++;
+    }
+    return len;
+}
 
-static size_t ascii_to_wc (ByteIOContext *pb, char *b, size_t n)
+static int ascii_to_wc (ByteIOContext *pb, uint8_t *b)
 {
-    size_t i;
-    unsigned char c;
-    for (i = 0; i < n - 1; i++) {
-        c = b[i];
-        if (! (0x20 <= c && c <= 0x7f ))
-            c = 0x3f;  /* '?' */
-        put_be16(pb, c);
+    int val;
+    while(*b){
+        GET_UTF8(val, *b++, return -1;)
+        put_be16(pb, val);
     }
     put_be16(pb, 0x00);
-    return 2*n;
+    return 0;
 }
 
 static uint16_t language_code (const char *str)
@@ -1268,31 +1301,37 @@
         size += 12;
 
         // Encoder
-        len = strlen(LIBAVCODEC_IDENT)+1;
+        len = utf8len(LIBAVCODEC_IDENT)+1;
+        if(len<=0)
+            goto not_utf8;
         put_be16(pb, len*2+10);             /* size */
         put_be32(pb, 0x04);                 /* type */
         put_be16(pb, language_code("eng")); /* language */
         put_be16(pb, 0x01);                 /* ? */
-        ascii_to_wc(pb, LIBAVCODEC_IDENT, len);
+        ascii_to_wc(pb, LIBAVCODEC_IDENT);
         size += len*2+10;
 
         // Title
-        len = strlen(s->title)+1;
+        len = utf8len(s->title)+1;
+        if(len<=0)
+            goto not_utf8;
         put_be16(pb, len*2+10);             /* size */
         put_be32(pb, 0x01);                 /* type */
         put_be16(pb, language_code("eng")); /* language */
         put_be16(pb, 0x01);                 /* ? */
-        ascii_to_wc (pb, s->title, len);
+        ascii_to_wc (pb, s->title);
         size += len*2+10;
 
         // Date
 //        snprintf(dt,32,"%04d/%02d/%02d %02d:%02d:%02d",t_st->tm_year+1900,t_st->tm_mon+1,t_st->tm_mday,t_st->tm_hour,t_st->tm_min,t_st->tm_sec);
-        len = strlen("2006/04/01 11:11:11")+1;
+        len = utf8len("2006/04/01 11:11:11")+1;
+        if(len<=0)
+            goto not_utf8;
         put_be16(pb, len*2+10);    /* size */
         put_be32(pb, 0x03);        /* type */
         put_be16(pb, language_code("und")); /* language */
         put_be16(pb, 0x01);        /* ? */
-        ascii_to_wc (pb, "2006/04/01 11:11:11", len);
+        ascii_to_wc (pb, "2006/04/01 11:11:11");
         size += len*2+10;
 
         // size
@@ -1305,6 +1344,9 @@
     }
 
     return size;
+not_utf8:
+    av_log(s, AV_LOG_ERROR, "not utf8\n");
+    return -1;
 }
 
 static int mov_write_moov_tag(ByteIOContext *pb, MOVContext *mov,
@@ -1319,8 +1361,6 @@
     for (i=0; i<mov->nb_streams; i++) {
         if(mov->tracks[i].entry <= 0) continue;
 
-        mov->tracks[i].trackDuration =
-            (int64_t)mov->tracks[i].sampleCount * mov->tracks[i].sampleDuration;
         mov->tracks[i].time = mov->time;
         mov->tracks[i].trackID = i+1;
     }
@@ -1336,7 +1376,7 @@
     if (mov->mode == MODE_PSP)
         mov_write_uuidusmt_tag(pb, s);
     else
-    mov_write_udta_tag(pb, mov, s);
+        mov_write_udta_tag(pb, mov, s);
 
     return updateSize(pb, pos);
 }
@@ -1481,19 +1521,26 @@
         if(st->codec->codec_type == CODEC_TYPE_VIDEO){
             track->tag = mov_find_video_codec_tag(s, track);
             track->timescale = st->codec->time_base.den;
-            track->sampleDuration = st->codec->time_base.num;
             av_set_pts_info(st, 64, 1, st->codec->time_base.den);
         }else if(st->codec->codec_type == CODEC_TYPE_AUDIO){
             track->tag = mov_find_audio_codec_tag(s, track);
             track->timescale = st->codec->sample_rate;
-            track->sampleDuration = st->codec->frame_size;
             av_set_pts_info(st, 64, 1, st->codec->sample_rate);
-            track->sampleSize = (av_get_bits_per_sample(st->codec->codec_id) >> 3) * st->codec->channels;
+            switch(track->enc->codec_id){
+            case CODEC_ID_MP3:
+            case CODEC_ID_AAC:
+            case CODEC_ID_AMR_NB:
+            case CODEC_ID_AMR_WB:
+                track->audio_vbr = 1;
+                break;
+            default:
+                track->sampleSize = (av_get_bits_per_sample(st->codec->codec_id) >> 3) * st->codec->channels;
+            }
+            if (!st->codec->frame_size) {
+                av_log(s, AV_LOG_ERROR, "track %d: codec frame size is not set\n", i);
+                return -1;
+            }
         }
-        if (!track->sampleDuration) {
-            av_log(s, AV_LOG_ERROR, "track %d: sample duration is not set\n", i);
-            return -1;
-        }
     }
 
     mov_write_mdat_tag(pb, mov);
@@ -1561,6 +1608,9 @@
     trk->cluster[trk->entry].samplesInChunk = samplesInChunk;
     trk->cluster[trk->entry].size = size;
     trk->cluster[trk->entry].entries = samplesInChunk;
+    trk->cluster[trk->entry].dts = pkt->dts;
+    trk->trackDuration = pkt->dts - trk->cluster[0].dts + pkt->duration;
+
     if(enc->codec_type == CODEC_TYPE_VIDEO) {
         if (pkt->dts != pkt->pts)
             trk->hasBframes = 1;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/mpeg.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/mpeg.c	2007-01-20 15:15:58 UTC (rev 2746)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/mpeg.c	2007-01-21 18:04:24 UTC (rev 2747)
@@ -1,23 +1,26 @@
 /*
- * MPEG1/2 mux/demux
+ * MPEG1/2 muxer and demuxer
  * Copyright (c) 2000, 2001, 2002 Fabrice Bellard.
  *
- * This library is free software; you can redistribute it and/or
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
+ * version 2.1 of the License, or (at your option) any later version.
  *
- * This library is distributed in the hope that it will be useful,
+ * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
+ * License along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 #include "avformat.h"
 #include "bitstream.h"
+#include "fifo.h"
 
 #define MAX_PAYLOAD_SIZE 4096
 //#define DEBUG_SEEK
@@ -35,7 +38,7 @@
 } PacketDesc;
 
 typedef struct {
-    FifoBuffer fifo;
+    AVFifoBuffer fifo;
     uint8_t id;
     int max_buffer_size; /* in bytes */
     int buffer_index;
@@ -45,7 +48,7 @@
     int packet_number;
     uint8_t lpcm_header[3];
     int lpcm_align;
-    uint8_t *fifo_iframe_ptr;
+    int bytes_to_iframe;
     int align_iframe;
     int64_t vobu_start_pts;
 } StreamInfo;
@@ -108,11 +111,11 @@
 static const int lpcm_freq_tab[4] = { 48000, 96000, 44100, 32000 };
 
 #ifdef CONFIG_MUXERS
-static AVOutputFormat mpeg1system_mux;
-static AVOutputFormat mpeg1vcd_mux;
-static AVOutputFormat mpeg2vob_mux;
-static AVOutputFormat mpeg2svcd_mux;
-static AVOutputFormat mpeg2dvd_mux;
+AVOutputFormat mpeg1system_muxer;
+AVOutputFormat mpeg1vcd_muxer;
+AVOutputFormat mpeg2vob_muxer;
+AVOutputFormat mpeg2svcd_muxer;
+AVOutputFormat mpeg2dvd_muxer;
 
 static int put_pack_header(AVFormatContext *ctx,
                            uint8_t *buf, int64_t timestamp)
@@ -330,10 +333,10 @@
     int video_bitrate;
 
     s->packet_number = 0;
-    s->is_vcd = (ctx->oformat == &mpeg1vcd_mux);
-    s->is_svcd = (ctx->oformat == &mpeg2svcd_mux);
-    s->is_mpeg2 = (ctx->oformat == &mpeg2vob_mux || ctx->oformat == &mpeg2svcd_mux || ctx->oformat == &mpeg2dvd_mux);
-    s->is_dvd = (ctx->oformat == &mpeg2dvd_mux);
+    s->is_vcd = (ctx->oformat == &mpeg1vcd_muxer);
+    s->is_svcd = (ctx->oformat == &mpeg2svcd_muxer);
+    s->is_mpeg2 = (ctx->oformat == &mpeg2vob_muxer || ctx->oformat == &mpeg2svcd_muxer || ctx->oformat == &mpeg2dvd_muxer);
+    s->is_dvd = (ctx->oformat == &mpeg2dvd_muxer);
 
     if(ctx->packet_size)
         s->packet_size = ctx->packet_size;
@@ -412,7 +415,7 @@
         default:
             return -1;
         }
-        fifo_init(&stream->fifo, 16);
+        av_fifo_init(&stream->fifo, 16);
     }
     bitrate = 0;
     audio_bitrate = 0;
@@ -708,14 +711,7 @@
             }
         } else if (s->is_dvd) {
             if (stream->align_iframe || s->packet_number == 0){
-                int bytes_to_iframe;
-                int PES_bytes_to_fill;
-                if (stream->fifo_iframe_ptr >= stream->fifo.rptr) {
-                    bytes_to_iframe = stream->fifo_iframe_ptr - stream->fifo.rptr;
-                } else {
-                    bytes_to_iframe = (stream->fifo.end - stream->fifo.rptr) + (stream->fifo_iframe_ptr - stream->fifo.buffer);
-                }
-                PES_bytes_to_fill = s->packet_size - size - 10;
+                int PES_bytes_to_fill = s->packet_size - size - 10;
 
                 if (pts != AV_NOPTS_VALUE) {
                     if (dts != pts)
@@ -724,7 +720,7 @@
                         PES_bytes_to_fill -= 5;
                 }
 
-                if (bytes_to_iframe == 0 || s->packet_number == 0) {
+                if (stream->bytes_to_iframe == 0 || s->packet_number == 0) {
                     size = put_system_header(ctx, buf_ptr, 0);
                     buf_ptr += size;
                     size = buf_ptr - buffer;
@@ -751,8 +747,8 @@
                     s->last_scr= scr;
                     buf_ptr += size;
                     /* GOP Start */
-                } else if (bytes_to_iframe < PES_bytes_to_fill) {
-                    pad_packet_bytes = PES_bytes_to_fill - bytes_to_iframe;
+                } else if (stream->bytes_to_iframe < PES_bytes_to_fill) {
+                    pad_packet_bytes = PES_bytes_to_fill - stream->bytes_to_iframe;
                 }
             }
         } else {
@@ -824,7 +820,7 @@
             startcode = 0x100 + id;
         }
 
-        stuffing_size = payload_size - fifo_size(&stream->fifo, stream->fifo.rptr);
+        stuffing_size = payload_size - av_fifo_size(&stream->fifo);
 
         // first byte doesnt fit -> reset pts/dts + stuffing
         if(payload_size <= trailer_size && pts != AV_NOPTS_VALUE){
@@ -951,8 +947,9 @@
         }
 
         /* output data */
-        if(put_fifo(&ctx->pb, &stream->fifo, payload_size - stuffing_size, &stream->fifo.rptr) < 0)
+        if(av_fifo_generic_read(&stream->fifo, payload_size - stuffing_size, &put_buffer, &ctx->pb) < 0)
             return -1;
+        stream->bytes_to_iframe -= payload_size - stuffing_size;
     }else{
         payload_size=
         stuffing_size= 0;
@@ -1065,7 +1062,7 @@
     for(i=0; i<ctx->nb_streams; i++){
         AVStream *st = ctx->streams[i];
         StreamInfo *stream = st->priv_data;
-        const int avail_data=  fifo_size(&stream->fifo, stream->fifo.rptr);
+        const int avail_data=  av_fifo_size(&stream->fifo);
         const int space= stream->max_buffer_size - stream->buffer_index;
         int rel_space= 1024*space / stream->max_buffer_size;
         PacketDesc *next_pkt= stream->premux_packet;
@@ -1125,7 +1122,7 @@
     st = ctx->streams[best_i];
     stream = st->priv_data;
 
-    assert(fifo_size(&stream->fifo, stream->fifo.rptr) > 0);
+    assert(av_fifo_size(&stream->fifo) > 0);
 
     assert(avail_space >= s->packet_size || ignore_constraints);
 
@@ -1141,7 +1138,7 @@
 //av_log(ctx, AV_LOG_DEBUG, "dts:%f pts:%f scr:%f stream:%d\n", timestamp_packet->dts/90000.0, timestamp_packet->pts/90000.0, scr/90000.0, best_i);
         es_size= flush_packet(ctx, best_i, timestamp_packet->pts, timestamp_packet->dts, scr, trailer_size);
     }else{
-        assert(fifo_size(&stream->fifo, stream->fifo.rptr) == trailer_size);
+        assert(av_fifo_size(&stream->fifo) == trailer_size);
         es_size= flush_packet(ctx, best_i, AV_NOPTS_VALUE, AV_NOPTS_VALUE, scr, trailer_size);
     }
 
@@ -1204,11 +1201,11 @@
         stream->predecode_packet= pkt_desc;
     stream->next_packet= &pkt_desc->next;
 
-    fifo_realloc(&stream->fifo, fifo_size(&stream->fifo, NULL) + size + 1);
+    av_fifo_realloc(&stream->fifo, av_fifo_size(&stream->fifo) + size + 1);
 
     if (s->is_dvd){
         if (is_iframe && (s->packet_number == 0 || (pts - stream->vobu_start_pts >= 36000))) { // min VOBU length 0.4 seconds (mpucoder)
-            stream->fifo_iframe_ptr = stream->fifo.wptr;
+            stream->bytes_to_iframe = av_fifo_size(&stream->fifo);
             stream->align_iframe = 1;
             stream->vobu_start_pts = pts;
         } else {
@@ -1216,7 +1213,7 @@
         }
     }
 
-    fifo_write(&stream->fifo, buf, size, &stream->fifo.wptr);
+    av_fifo_write(&stream->fifo, buf, size);
 
     for(;;){
         int ret= output_packet(ctx, 0);
@@ -1248,8 +1245,8 @@
     for(i=0;i<ctx->nb_streams;i++) {
         stream = ctx->streams[i]->priv_data;
 
-        assert(fifo_size(&stream->fifo, stream->fifo.rptr) == 0);
-        fifo_free(&stream->fifo);
+        assert(av_fifo_size(&stream->fifo) == 0);
+        av_fifo_free(&stream->fifo);
     }
     return 0;
 }
@@ -1260,33 +1257,60 @@
 
 #define MAX_SYNC_SIZE 100000
 
+static int cdxa_probe(AVProbeData *p)
+{
+    /* check file header */
+    if (p->buf_size <= 32)
+        return 0;
+    if (p->buf[0] == 'R' && p->buf[1] == 'I' &&
+        p->buf[2] == 'F' && p->buf[3] == 'F' &&
+        p->buf[8] == 'C' && p->buf[9] == 'D' &&
+        p->buf[10] == 'X' && p->buf[11] == 'A')
+        return AVPROBE_SCORE_MAX;
+    else
+        return 0;
+}
+
 static int mpegps_probe(AVProbeData *p)
 {
     uint32_t code= -1;
-    int sys=0, pspack=0, priv1=0, vid=0;
+    int sys=0, pspack=0, priv1=0, vid=0, audio=0;
     int i;
+    int score=0;
 
+    score = cdxa_probe(p);
+    if (score > 0) return score;
+
+    /* Search for MPEG stream */
     for(i=0; i<p->buf_size; i++){
         code = (code<<8) + p->buf[i];
         if ((code & 0xffffff00) == 0x100) {
-            switch(code){
-            case SYSTEM_HEADER_START_CODE:    sys++; break;
-            case         PRIVATE_STREAM_1:  priv1++; break;
-            case          PACK_START_CODE: pspack++; break;
-            case       (VIDEO_ID + 0x100):    vid++; break;
-            }
+            if(code == SYSTEM_HEADER_START_CODE) sys++;
+            else if(code == PRIVATE_STREAM_1)    priv1++;
+            else if(code == PACK_START_CODE)     pspack++;
+            else if((code & 0xf0) == VIDEO_ID)   vid++;
+            else if((code & 0xe0) == AUDIO_ID)   audio++;
         }
     }
+
+    if(vid || audio)            /* invalid VDR files nd short PES streams */
+        score= AVPROBE_SCORE_MAX/4;
+
+//av_log(NULL, AV_LOG_ERROR, "%d %d %d %d %d\n", sys, priv1, pspack,vid, audio);
     if(sys && sys*9 <= pspack*10)
         return AVPROBE_SCORE_MAX/2+2; // +1 for .mpg
-    if((priv1 || vid) && (priv1+vid)*9 <= pspack*10)
+    if((priv1 || vid || audio) && (priv1+vid+audio)*9 <= pspack*10)
         return AVPROBE_SCORE_MAX/2+2; // +1 for .mpg
-    return 0;
+    if((!!vid ^ !!audio) && (audio+vid > 1) && !sys && !pspack) /* PES stream */
+        return AVPROBE_SCORE_MAX/2+2;
+
+    //02-Penguin.flac has sys:0 priv1:0 pspack:0 vid:0 audio:1
+    return score;
 }
 
 
 typedef struct MpegDemuxContext {
-    int header_state;
+    int32_t header_state;
     unsigned char psm_es_type[256];
 } MpegDemuxContext;
 
@@ -1317,7 +1341,7 @@
 }
 
 static int find_next_start_code(ByteIOContext *pb, int *size_ptr,
-                                uint32_t *header_state)
+                                int32_t *header_state)
 {
     unsigned int state, v;
     int val, n;
@@ -1421,15 +1445,18 @@
 {
     MpegDemuxContext *m = s->priv_data;
     int len, size, startcode, c, flags, header_len;
-    int64_t pts, dts, last_pos;
+    int64_t pts, dts;
+    int64_t last_sync= url_ftell(&s->pb);
 
-    last_pos = -1;
+ error_redo:
+        url_fseek(&s->pb, last_sync, SEEK_SET);
  redo:
         /* next start code (should be immediately after) */
         m->header_state = 0xff;
         size = MAX_SYNC_SIZE;
         startcode = find_next_start_code(&s->pb, &size, &m->header_state);
-    //printf("startcode=%x pos=0x%Lx\n", startcode, url_ftell(&s->pb));
+        last_sync = url_ftell(&s->pb);
+    //printf("startcode=%x pos=0x%"PRIx64"\n", startcode, url_ftell(&s->pb));
     if (startcode < 0)
         return AVERROR_IO;
     if (startcode == PACK_START_CODE)
@@ -1457,12 +1484,12 @@
         *ppos = url_ftell(&s->pb) - 4;
     }
     len = get_be16(&s->pb);
-    pts = AV_NOPTS_VALUE;
+    pts =
     dts = AV_NOPTS_VALUE;
     /* stuffing */
     for(;;) {
         if (len < 1)
-            goto redo;
+            goto error_redo;
         c = get_byte(&s->pb);
         len--;
         /* XXX: for mpeg1, should test only bit 7 */
@@ -1471,72 +1498,59 @@
     }
     if ((c & 0xc0) == 0x40) {
         /* buffer scale & size */
-        if (len < 2)
-            goto redo;
         get_byte(&s->pb);
         c = get_byte(&s->pb);
         len -= 2;
     }
-    if ((c & 0xf0) == 0x20) {
-        if (len < 4)
-            goto redo;
+    if ((c & 0xe0) == 0x20) {
         dts = pts = get_pts(&s->pb, c);
         len -= 4;
-    } else if ((c & 0xf0) == 0x30) {
-        if (len < 9)
-            goto redo;
-        pts = get_pts(&s->pb, c);
-        dts = get_pts(&s->pb, -1);
-        len -= 9;
+        if (c & 0x10){
+            dts = get_pts(&s->pb, -1);
+            len -= 5;
+        }
     } else if ((c & 0xc0) == 0x80) {
         /* mpeg 2 PES */
+#if 0 /* some streams have this field set for no apparent reason */
         if ((c & 0x30) != 0) {
             /* Encrypted multiplex not handled */
             goto redo;
         }
+#endif
         flags = get_byte(&s->pb);
         header_len = get_byte(&s->pb);
         len -= 2;
         if (header_len > len)
-            goto redo;
-        if ((flags & 0xc0) == 0x80) {
+            goto error_redo;
+        len -= header_len;
+        if (flags & 0x80) {
             dts = pts = get_pts(&s->pb, -1);
-            if (header_len < 5)
-                goto redo;
             header_len -= 5;
-            len -= 5;
-        } if ((flags & 0xc0) == 0xc0) {
-            pts = get_pts(&s->pb, -1);
-            dts = get_pts(&s->pb, -1);
-            if (header_len < 10)
-                goto redo;
-            header_len -= 10;
-            len -= 10;
+            if (flags & 0x40) {
+                dts = get_pts(&s->pb, -1);
+                header_len -= 5;
+            }
         }
-        len -= header_len;
-        while (header_len > 0) {
-            get_byte(&s->pb);
-            header_len--;
-        }
+        if(header_len < 0)
+            goto error_redo;
+        url_fskip(&s->pb, header_len);
     }
     else if( c!= 0xf )
         goto redo;
 
     if (startcode == PRIVATE_STREAM_1 && !m->psm_es_type[startcode & 0xff]) {
-        if (len < 1)
-            goto redo;
         startcode = get_byte(&s->pb);
         len--;
         if (startcode >= 0x80 && startcode <= 0xbf) {
             /* audio: skip header */
-            if (len < 3)
-                goto redo;
             get_byte(&s->pb);
             get_byte(&s->pb);
             get_byte(&s->pb);
             len -= 3;
         }
     }
+    if(len<0)
+        goto error_redo;
     if(dts != AV_NOPTS_VALUE && ppos){
         int i;
         for(i=0; i<s->nb_streams; i++){
@@ -1600,8 +1614,15 @@
             goto skip;
         }
     } else if (startcode >= 0x1e0 && startcode <= 0x1ef) {
+        static const unsigned char avs_seqh[4] = { 0, 0, 1, 0xb0 };
+        unsigned char buf[8];
+        get_buffer(&s->pb, buf, 8);
+        url_fseek(&s->pb, -8, SEEK_CUR);
+        if(!memcmp(buf, avs_seqh, 4) && (buf[6] != 0 || buf[7] != 1))
+            codec_id = CODEC_ID_CAVS;
+        else
+            codec_id = CODEC_ID_MPEG2VIDEO;
         type = CODEC_TYPE_VIDEO;
-        codec_id = CODEC_ID_MPEG2VIDEO;
     } else if (startcode >= 0x1c0 && startcode <= 0x1df) {
         type = CODEC_TYPE_AUDIO;
         codec_id = CODEC_ID_MP2;
@@ -1676,7 +1697,7 @@
 
     pos = *ppos;
 #ifdef DEBUG_SEEK
-    printf("read_dts: pos=0x%llx next=%d -> ", pos, find_next);
+    printf("read_dts: pos=0x%"PRIx64" next=%d -> ", pos, find_next);
 #endif
     url_fseek(&s->pb, pos, SEEK_SET);
     for(;;) {
@@ -1694,14 +1715,14 @@
         url_fskip(&s->pb, len);
     }
 #ifdef DEBUG_SEEK
-    printf("pos=0x%llx dts=0x%llx %0.3f\n", pos, dts, dts / 90000.0);
+    printf("pos=0x%"PRIx64" dts=0x%"PRIx64" %0.3f\n", pos, dts, dts / 90000.0);
 #endif
     *ppos = pos;
     return dts;
 }
 
-#ifdef CONFIG_MUXERS
-static AVOutputFormat mpeg1system_mux = {
+#ifdef CONFIG_MPEG1SYSTEM_MUXER
+AVOutputFormat mpeg1system_muxer = {
     "mpeg",
     "MPEG1 System format",
     "video/mpeg",
@@ -1713,8 +1734,9 @@
     mpeg_mux_write_packet,
     mpeg_mux_end,
 };
-
-static AVOutputFormat mpeg1vcd_mux = {
+#endif
+#ifdef CONFIG_MPEG1VCD_MUXER
+AVOutputFormat mpeg1vcd_muxer = {
     "vcd",
     "MPEG1 System format (VCD)",
     "video/mpeg",
@@ -1726,8 +1748,9 @@
     mpeg_mux_write_packet,
     mpeg_mux_end,
 };
-
-static AVOutputFormat mpeg2vob_mux = {
+#endif
+#ifdef CONFIG_MPEG2VOB_MUXER
+AVOutputFormat mpeg2vob_muxer = {
     "vob",
     "MPEG2 PS format (VOB)",
     "video/mpeg",
@@ -1739,9 +1762,11 @@
     mpeg_mux_write_packet,
     mpeg_mux_end,
 };
+#endif
 
 /* Same as mpeg2vob_mux except that the pack size is 2324 */
-static AVOutputFormat mpeg2svcd_mux = {
+#ifdef CONFIG_MPEG2SVCD_MUXER
+AVOutputFormat mpeg2svcd_muxer = {
     "svcd",
     "MPEG2 PS format (VOB)",
     "video/mpeg",
@@ -1753,9 +1778,11 @@
     mpeg_mux_write_packet,
     mpeg_mux_end,
 };
+#endif
 
 /*  Same as mpeg2vob_mux except the 'is_dvd' flag is set to produce NAV pkts */
-static AVOutputFormat mpeg2dvd_mux = {
+#ifdef CONFIG_MPEG2DVD_MUXER
+AVOutputFormat mpeg2dvd_muxer = {
     "dvd",
     "MPEG2 PS format (DVD VOB)",
     "video/mpeg",
@@ -1767,10 +1794,10 @@
     mpeg_mux_write_packet,
     mpeg_mux_end,
 };
+#endif
 
-#endif //CONFIG_MUXERS
-
-AVInputFormat mpegps_demux = {
+#ifdef CONFIG_MPEGPS_DEMUXER
+AVInputFormat mpegps_demuxer = {
     "mpeg",
     "MPEG PS format",
     sizeof(MpegDemuxContext),
@@ -1782,16 +1809,4 @@
     mpegps_read_dts,
     .flags = AVFMT_SHOW_IDS,
 };
-
-int mpegps_init(void)
-{
-#ifdef CONFIG_MUXERS
-    av_register_output_format(&mpeg1system_mux);
-    av_register_output_format(&mpeg1vcd_mux);
-    av_register_output_format(&mpeg2vob_mux);
-    av_register_output_format(&mpeg2svcd_mux);
-    av_register_output_format(&mpeg2dvd_mux);
-#endif //CONFIG_MUXERS
-    av_register_input_format(&mpegps_demux);
-    return 0;
-}
+#endif

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/mpegts.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/mpegts.h	2007-01-20 15:15:58 UTC (rev 2746)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/mpegts.h	2007-01-21 18:04:24 UTC (rev 2747)
@@ -2,22 +2,25 @@
  * MPEG2 transport stream defines
  * Copyright (c) 2003 Fabrice Bellard.
  *
- * This library is free software; you can redistribute it and/or
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
+ * version 2.1 of the License, or (at your option) any later version.
  *
- * This library is distributed in the hope that it will be useful,
+ * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
 #define TS_FEC_PACKET_SIZE 204
+#define TS_DVHS_PACKET_SIZE 192
 #define TS_PACKET_SIZE 188
 #define NB_PID_MAX 8192
 #define MAX_SECTION_SIZE 4096
@@ -28,9 +31,12 @@
 
 /* table ids */
 #define PAT_TID   0x00
-#define PMT_TID   0x02 
+#define PMT_TID   0x02
 #define SDT_TID   0x42
 
+/* descriptor ids */
+#define DVB_SUBT_DESCID             0x59
+
 #define STREAM_TYPE_VIDEO_MPEG1     0x01
 #define STREAM_TYPE_VIDEO_MPEG2     0x02
 #define STREAM_TYPE_AUDIO_MPEG1     0x03
@@ -44,8 +50,10 @@
 #define STREAM_TYPE_AUDIO_AC3       0x81
 #define STREAM_TYPE_AUDIO_DTS       0x8a
 
+#define STREAM_TYPE_SUBTITLE_DVB    0x100
+
 unsigned int mpegts_crc32(const uint8_t *data, int len);
-extern AVOutputFormat mpegts_mux;
+extern AVOutputFormat mpegts_muxer;
 
 typedef struct MpegTSContext MpegTSContext;
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/mpegtsenc.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/mpegtsenc.c	2007-01-20 15:15:58 UTC (rev 2746)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/mpegtsenc.c	2007-01-21 18:04:24 UTC (rev 2747)
@@ -1,84 +1,29 @@
 /*
- * MPEG2 transport stream (aka DVB) mux
+ * MPEG2 transport stream (aka DVB) muxer
  * Copyright (c) 2003 Fabrice Bellard.
  *
- * This library is free software; you can redistribute it and/or
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
+ * version 2.1 of the License, or (at your option) any later version.
  *
- * This library is distributed in the hope that it will be useful,
+ * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 #include "avformat.h"
-
+#include "crc.h"
 #include "mpegts.h"
 
 /* write DVB SI sections */
 
-static const uint32_t crc_table[256] = {
-        0x00000000, 0x04c11db7, 0x09823b6e, 0x0d4326d9, 0x130476dc, 0x17c56b6b,
-        0x1a864db2, 0x1e475005, 0x2608edb8, 0x22c9f00f, 0x2f8ad6d6, 0x2b4bcb61,
-        0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd, 0x4c11db70, 0x48d0c6c7,
-        0x4593e01e, 0x4152fda9, 0x5f15adac, 0x5bd4b01b, 0x569796c2, 0x52568b75,
-        0x6a1936c8, 0x6ed82b7f, 0x639b0da6, 0x675a1011, 0x791d4014, 0x7ddc5da3,
-        0x709f7b7a, 0x745e66cd, 0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039,
-        0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5, 0xbe2b5b58, 0xbaea46ef,
-        0xb7a96036, 0xb3687d81, 0xad2f2d84, 0xa9ee3033, 0xa4ad16ea, 0xa06c0b5d,
-        0xd4326d90, 0xd0f37027, 0xddb056fe, 0xd9714b49, 0xc7361b4c, 0xc3f706fb,
-        0xceb42022, 0xca753d95, 0xf23a8028, 0xf6fb9d9f, 0xfbb8bb46, 0xff79a6f1,
-        0xe13ef6f4, 0xe5ffeb43, 0xe8bccd9a, 0xec7dd02d, 0x34867077, 0x30476dc0,
-        0x3d044b19, 0x39c556ae, 0x278206ab, 0x23431b1c, 0x2e003dc5, 0x2ac12072,
-        0x128e9dcf, 0x164f8078, 0x1b0ca6a1, 0x1fcdbb16, 0x018aeb13, 0x054bf6a4,
-        0x0808d07d, 0x0cc9cdca, 0x7897ab07, 0x7c56b6b0, 0x71159069, 0x75d48dde,
-        0x6b93dddb, 0x6f52c06c, 0x6211e6b5, 0x66d0fb02, 0x5e9f46bf, 0x5a5e5b08,
-        0x571d7dd1, 0x53dc6066, 0x4d9b3063, 0x495a2dd4, 0x44190b0d, 0x40d816ba,
-        0xaca5c697, 0xa864db20, 0xa527fdf9, 0xa1e6e04e, 0xbfa1b04b, 0xbb60adfc,
-        0xb6238b25, 0xb2e29692, 0x8aad2b2f, 0x8e6c3698, 0x832f1041, 0x87ee0df6,
-        0x99a95df3, 0x9d684044, 0x902b669d, 0x94ea7b2a, 0xe0b41de7, 0xe4750050,
-        0xe9362689, 0xedf73b3e, 0xf3b06b3b, 0xf771768c, 0xfa325055, 0xfef34de2,
-        0xc6bcf05f, 0xc27dede8, 0xcf3ecb31, 0xcbffd686, 0xd5b88683, 0xd1799b34,
-        0xdc3abded, 0xd8fba05a, 0x690ce0ee, 0x6dcdfd59, 0x608edb80, 0x644fc637,
-        0x7a089632, 0x7ec98b85, 0x738aad5c, 0x774bb0eb, 0x4f040d56, 0x4bc510e1,
-        0x46863638, 0x42472b8f, 0x5c007b8a, 0x58c1663d, 0x558240e4, 0x51435d53,
-        0x251d3b9e, 0x21dc2629, 0x2c9f00f0, 0x285e1d47, 0x36194d42, 0x32d850f5,
-        0x3f9b762c, 0x3b5a6b9b, 0x0315d626, 0x07d4cb91, 0x0a97ed48, 0x0e56f0ff,
-        0x1011a0fa, 0x14d0bd4d, 0x19939b94, 0x1d528623, 0xf12f560e, 0xf5ee4bb9,
-        0xf8ad6d60, 0xfc6c70d7, 0xe22b20d2, 0xe6ea3d65, 0xeba91bbc, 0xef68060b,
-        0xd727bbb6, 0xd3e6a601, 0xdea580d8, 0xda649d6f, 0xc423cd6a, 0xc0e2d0dd,
-        0xcda1f604, 0xc960ebb3, 0xbd3e8d7e, 0xb9ff90c9, 0xb4bcb610, 0xb07daba7,
-        0xae3afba2, 0xaafbe615, 0xa7b8c0cc, 0xa379dd7b, 0x9b3660c6, 0x9ff77d71,
-        0x92b45ba8, 0x9675461f, 0x8832161a, 0x8cf30bad, 0x81b02d74, 0x857130c3,
-        0x5d8a9099, 0x594b8d2e, 0x5408abf7, 0x50c9b640, 0x4e8ee645, 0x4a4ffbf2,
-        0x470cdd2b, 0x43cdc09c, 0x7b827d21, 0x7f436096, 0x7200464f, 0x76c15bf8,
-        0x68860bfd, 0x6c47164a, 0x61043093, 0x65c52d24, 0x119b4be9, 0x155a565e,
-        0x18197087, 0x1cd86d30, 0x029f3d35, 0x065e2082, 0x0b1d065b, 0x0fdc1bec,
-        0x3793a651, 0x3352bbe6, 0x3e119d3f, 0x3ad08088, 0x2497d08d, 0x2056cd3a,
-        0x2d15ebe3, 0x29d4f654, 0xc5a92679, 0xc1683bce, 0xcc2b1d17, 0xc8ea00a0,
-        0xd6ad50a5, 0xd26c4d12, 0xdf2f6bcb, 0xdbee767c, 0xe3a1cbc1, 0xe760d676,
-        0xea23f0af, 0xeee2ed18, 0xf0a5bd1d, 0xf464a0aa, 0xf9278673, 0xfde69bc4,
-        0x89b8fd09, 0x8d79e0be, 0x803ac667, 0x84fbdbd0, 0x9abc8bd5, 0x9e7d9662,
-        0x933eb0bb, 0x97ffad0c, 0xafb010b1, 0xab710d06, 0xa6322bdf, 0xa2f33668,
-        0xbcb4666d, 0xb8757bda, 0xb5365d03, 0xb1f740b4
-};
-
-unsigned int mpegts_crc32(const uint8_t *data, int len)
-{
-    register int i;
-    unsigned int crc = 0xffffffff;
-
-    for (i=0; i<len; i++)
-        crc = (crc << 8) ^ crc_table[((crc >> 24) ^ *data++) & 0xff];
-
-    return crc;
-}
-
 /*********************************************/
 /* mpegts section writer */
 
@@ -90,7 +35,7 @@
 } MpegTSSection;
 
 /* NOTE: 4 bytes must be left at the end for the crc32 */
-void mpegts_write_section(MpegTSSection *s, uint8_t *buf, int len)
+static void mpegts_write_section(MpegTSSection *s, uint8_t *buf, int len)
 {
     unsigned int crc;
     unsigned char packet[TS_PACKET_SIZE];
@@ -98,7 +43,7 @@
     unsigned char *q;
     int first, b, len1, left;
 
-    crc = mpegts_crc32(buf, len - 4);
+    crc = bswap_32(av_crc(av_crc04C11DB7, -1, buf, len - 4));
     buf[len - 4] = (crc >> 24) & 0xff;
     buf[len - 3] = (crc >> 16) & 0xff;
     buf[len - 2] = (crc >> 8) & 0xff;
@@ -145,7 +90,7 @@
     *q_ptr = q;
 }
 
-int mpegts_write_section1(MpegTSSection *s, int tid, int id,
+static int mpegts_write_section1(MpegTSSection *s, int tid, int id,
                           int version, int sec_num, int last_sec_num,
                           uint8_t *buf, int len)
 {
@@ -717,7 +662,7 @@
     return 0;
 }
 
-AVOutputFormat mpegts_mux = {
+AVOutputFormat mpegts_muxer = {
     "mpegts",
     "MPEG2 transport stream format",
     "video/x-mpegts",

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/riff.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/riff.h	2007-01-20 15:15:58 UTC (rev 2746)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/riff.h	2007-01-21 18:04:24 UTC (rev 2747)
@@ -1,3 +1,30 @@
+/*
+ * RIFF codec tags
+ * copyright (c) 2000 Fabrice Bellard
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file riff.h
+ * internal header for RIFF based (de)muxers
+ * do NOT include this in end user applications
+ */
+
 #ifndef FF_RIFF_H
 #define FF_RIFF_H
 
@@ -4,27 +31,25 @@
 offset_t start_tag(ByteIOContext *pb, const char *tag);
 void end_tag(ByteIOContext *pb, offset_t start);
 
-typedef struct CodecTag {
+typedef struct AVCodecTag {
     int id;
     unsigned int tag;
-    unsigned int invalid_asf : 1;
-} CodecTag;
+} AVCodecTag;
 
-void put_bmp_header(ByteIOContext *pb, AVCodecContext *enc, const CodecTag *tags, int for_asf);
+void put_bmp_header(ByteIOContext *pb, AVCodecContext *enc, const AVCodecTag *tags, int for_asf);
 int put_wav_header(ByteIOContext *pb, AVCodecContext *enc);
 int wav_codec_get_id(unsigned int tag, int bps);
 void get_wav_header(ByteIOContext *pb, AVCodecContext *codec, int size);
 
-extern const CodecTag codec_bmp_tags[];
-extern const CodecTag codec_wav_tags[];
+extern const AVCodecTag codec_bmp_tags[];
+extern const AVCodecTag codec_wav_tags[];
 
-unsigned int codec_get_tag(const CodecTag *tags, int id);
-enum CodecID codec_get_id(const CodecTag *tags, unsigned int tag);
-unsigned int codec_get_bmp_tag(int id);
-unsigned int codec_get_wav_tag(int id);
-enum CodecID codec_get_bmp_id(unsigned int tag);
-enum CodecID codec_get_wav_id(unsigned int tag);
-unsigned int codec_get_asf_tag(const CodecTag *tags, unsigned int id);
+unsigned int codec_get_tag(const AVCodecTag *tags, int id);
+enum CodecID codec_get_id(const AVCodecTag *tags, unsigned int tag);
+unsigned int codec_get_bmp_tag(int id) attribute_deprecated; //use av_codec_get_tag
+unsigned int codec_get_wav_tag(int id) attribute_deprecated; //use av_codec_get_tag
+enum CodecID codec_get_bmp_id(unsigned int tag) attribute_deprecated; //use av_codec_get_id
+enum CodecID codec_get_wav_id(unsigned int tag) attribute_deprecated; //use av_codec_get_id
 void ff_parse_specific_params(AVCodecContext *stream, int *au_rate, int *au_ssize, int *au_scale);
 
 #endif

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/rtp.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/rtp.h	2007-01-20 15:15:58 UTC (rev 2746)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/rtp.h	2007-01-21 18:04:24 UTC (rev 2747)
@@ -2,39 +2,25 @@
  * RTP definitions
  * Copyright (c) 2002 Fabrice Bellard.
  *
- * This library is free software; you can redistribute it and/or
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
+ * version 2.1 of the License, or (at your option) any later version.
  *
- * This library is distributed in the hope that it will be useful,
+ * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 #ifndef RTP_H
 #define RTP_H
 
-enum RTPPayloadType {
-    RTP_PT_ULAW = 0,
-    RTP_PT_GSM = 3,
-    RTP_PT_G723 = 4,
-    RTP_PT_ALAW = 8,
-    RTP_PT_S16BE_STEREO = 10,
-    RTP_PT_S16BE_MONO = 11,
-    RTP_PT_MPEGAUDIO = 14,
-    RTP_PT_JPEG = 26,
-    RTP_PT_H261 = 31,
-    RTP_PT_MPEGVIDEO = 32,
-    RTP_PT_MPEG2TS = 33,
-    RTP_PT_H263 = 34, /* old H263 encapsulation */
-    RTP_PT_PRIVATE = 96,
-};
-
 #define RTP_MIN_PACKET_LENGTH 12
 #define RTP_MAX_PACKET_LENGTH 1500 /* XXX: suppress this define */
 
@@ -43,14 +29,14 @@
 int rtp_get_payload_type(AVCodecContext *codec);
 
 typedef struct RTPDemuxContext RTPDemuxContext;
-
-RTPDemuxContext *rtp_parse_open(AVFormatContext *s1, AVStream *st, int payload_type);
-int rtp_parse_packet(RTPDemuxContext *s, AVPacket *pkt, 
+typedef struct rtp_payload_data_s rtp_payload_data_s;
+RTPDemuxContext *rtp_parse_open(AVFormatContext *s1, AVStream *st, URLContext *rtpc, int payload_type, rtp_payload_data_s *rtp_payload_data);
+int rtp_parse_packet(RTPDemuxContext *s, AVPacket *pkt,
                      const uint8_t *buf, int len);
 void rtp_parse_close(RTPDemuxContext *s);
 
-extern AVOutputFormat rtp_mux;
-extern AVInputFormat rtp_demux;
+extern AVOutputFormat rtp_muxer;
+extern AVInputFormat rtp_demuxer;
 
 int rtp_get_local_port(URLContext *h);
 int rtp_set_remote_url(URLContext *h, const char *uri);
@@ -58,4 +44,75 @@
 
 extern URLProtocol rtp_protocol;
 
+#define RTP_PT_PRIVATE 96
+#define RTP_VERSION 2
+#define RTP_MAX_SDES 256   /* maximum text length for SDES */
+
+/* RTCP paquets use 0.5 % of the bandwidth */
+#define RTCP_TX_RATIO_NUM 5
+#define RTCP_TX_RATIO_DEN 1000
+
+/* Structure listing usefull vars to parse RTP packet payload*/
+typedef struct rtp_payload_data_s
+{
+    int sizelength;
+    int indexlength;
+    int indexdeltalength;
+    int profile_level_id;
+    int streamtype;
+    int objecttype;
+    char *mode;
+
+    /* mpeg 4 AU headers */
+    struct AUHeaders {
+        int size;
+        int index;
+        int cts_flag;
+        int cts;
+        int dts_flag;
+        int dts;
+        int rap_flag;
+        int streamstate;
+    } *au_headers;
+    int nb_au_headers;
+    int au_headers_length_bytes;
+    int cur_au_index;
+} rtp_payload_data_t;
+
+typedef struct AVRtpPayloadType_s
+{
+    int pt;
+    const char enc_name[50]; /* XXX: why 50 ? */
+    enum CodecType codec_type;
+    enum CodecID codec_id;
+    int clock_rate;
+    int audio_channels;
+} AVRtpPayloadType_t;
+
+#if 0
+typedef enum {
+  RTCP_SR   = 200,
+  RTCP_RR   = 201,
+  RTCP_SDES = 202,
+  RTCP_BYE  = 203,
+  RTCP_APP  = 204
+} rtcp_type_t;
+
+typedef enum {
+  RTCP_SDES_END    =  0,
+  RTCP_SDES_CNAME  =  1,
+  RTCP_SDES_NAME   =  2,
+  RTCP_SDES_EMAIL  =  3,
+  RTCP_SDES_PHONE  =  4,
+  RTCP_SDES_LOC    =  5,
+  RTCP_SDES_TOOL   =  6,
+  RTCP_SDES_NOTE   =  7,
+  RTCP_SDES_PRIV   =  8,
+  RTCP_SDES_IMG    =  9,
+  RTCP_SDES_DOOR   = 10,
+  RTCP_SDES_SOURCE = 11
+} rtcp_sdes_type_t;
+#endif
+
+extern AVRtpPayloadType_t AVRtpPayloadTypes[];
 #endif /* RTP_H */

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/rtsp.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/rtsp.h	2007-01-20 15:15:58 UTC (rev 2746)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/rtsp.h	2007-01-21 18:04:24 UTC (rev 2747)
@@ -2,19 +2,21 @@
  * RTSP definitions
  * Copyright (c) 2002 Fabrice Bellard.
  *
- * This library is free software; you can redistribute it and/or
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
+ * version 2.1 of the License, or (at your option) any later version.
  *
- * This library is distributed in the hope that it will be useful,
+ * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 #ifndef RTSP_H
 #define RTSP_H
@@ -35,6 +37,10 @@
 #define RTSP_DEFAULT_PORT   554
 #define RTSP_MAX_TRANSPORTS 8
 #define RTSP_TCP_MAX_PACKET_SIZE 1472
+#define RTSP_DEFAULT_NB_AUDIO_CHANNELS 2
+#define RTSP_DEFAULT_AUDIO_SAMPLERATE 44100
+#define RTSP_RTP_PORT_MIN 5000
+#define RTSP_RTP_PORT_MAX 10000
 
 typedef struct RTSPTransportField {
     int interleaved_min, interleaved_max;  /* interleave ids, if TCP transport */
@@ -51,7 +57,7 @@
     enum RTSPStatusCode status_code; /* response code from server */
     int nb_transports;
     /* in AV_TIME_BASE unit, AV_NOPTS_VALUE if not used */
-    int64_t range_start, range_end; 
+    int64_t range_start, range_end;
     RTSPTransportField transports[RTSP_MAX_TRANSPORTS];
     int seq; /* sequence number */
     char session_id[512];
@@ -70,7 +76,7 @@
     char transport_option[512];
 } RTSPActionServerSetup;
 
-typedef int FFRTSPCallback(enum RTSPCallbackAction action, 
+typedef int FFRTSPCallback(enum RTSPCallbackAction action,
                            const char *session_id,
                            char *buf, int buf_size,
                            void *arg);
@@ -84,7 +90,7 @@
 extern int rtsp_rtp_port_min;
 extern int rtsp_rtp_port_max;
 extern FFRTSPCallback *ff_rtsp_callback;
-extern AVInputFormat rtsp_demux;
+extern AVInputFormat rtsp_demuxer;
 
 int rtsp_pause(AVFormatContext *s);
 int rtsp_resume(AVFormatContext *s);

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/rtspcodes.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/rtspcodes.h	2007-01-20 15:15:58 UTC (rev 2746)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/rtspcodes.h	2007-01-21 18:04:24 UTC (rev 2747)
@@ -1,3 +1,23 @@
+/*
+ * RTSP definitions
+ * copyright (c) 2002 Fabrice Bellard
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
 DEF(200, RTSP_STATUS_OK, "OK")
 DEF(405, RTSP_STATUS_METHOD, "Method Not Allowed")
 DEF(453, RTSP_STATUS_BANDWIDTH, "Not Enough Bandwidth")

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/utils.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/utils.c	2007-01-20 15:15:58 UTC (rev 2746)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/utils.c	2007-01-21 18:04:24 UTC (rev 2747)
@@ -2,21 +2,25 @@
  * Various utilities for ffmpeg system
  * Copyright (c) 2000, 2001, 2002 Fabrice Bellard
  *
- * This library is free software; you can redistribute it and/or
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
+ * version 2.1 of the License, or (at your option) any later version.
  *
- * This library is distributed in the hope that it will be useful,
+ * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
+ * License along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 #include "avformat.h"
+#include "allformats.h"
+#include "opt.h"
 
 #undef NDEBUG
 #include <assert.h>
@@ -26,12 +30,13 @@
  * Various utility functions for using ffmpeg library.
  */
 
+static void av_frac_init(AVFrac *f, int64_t val, int64_t num, int64_t den);
+static void av_frac_add(AVFrac *f, int64_t incr);
+
 /** head of registered input format linked list. */
 AVInputFormat *first_iformat = NULL;
 /** head of registered output format linked list. */
 AVOutputFormat *first_oformat = NULL;
-/** head of registered image format linked list. */
-AVImageFormat *first_image_format = NULL;
 
 void av_register_input_format(AVInputFormat *format)
 {
@@ -85,17 +90,13 @@
     int score_max, score;
 
     /* specific test for image sequences */
+#ifdef CONFIG_IMAGE2_MUXER
     if (!short_name && filename &&
-        filename_number_test(filename) >= 0 &&
+        av_filename_number_test(filename) &&
         av_guess_image2_codec(filename) != CODEC_ID_NONE) {
         return guess_format("image2", NULL, NULL);
     }
-    if (!short_name && filename &&
-        filename_number_test(filename) >= 0 &&
-        guess_image_format(filename)) {
-        return guess_format("image", NULL, NULL);
-    }
-
+#endif
     /* find the proper file type */
     fmt_found = NULL;
     score_max = 0;
@@ -146,9 +147,11 @@
     if(type == CODEC_TYPE_VIDEO){
         enum CodecID codec_id= CODEC_ID_NONE;
 
+#ifdef CONFIG_IMAGE2_MUXER
         if(!strcmp(fmt->name, "image2") || !strcmp(fmt->name, "image2pipe")){
             codec_id= av_guess_image2_codec(filename);
         }
+#endif
         if(codec_id == CODEC_ID_NONE)
             codec_id= fmt->video_codec;
         return codec_id;
@@ -191,7 +194,7 @@
  */
 int av_new_packet(AVPacket *pkt, int size)
 {
-    void *data;
+    uint8_t *data;
     if((unsigned)size > (unsigned)size + FF_INPUT_BUFFER_PADDING_SIZE)
         return AVERROR_NOMEM;
     data = av_malloc(size + FF_INPUT_BUFFER_PADDING_SIZE);
@@ -253,156 +256,23 @@
     return 0;
 }
 
-/* fifo handling */
-
-int fifo_init(FifoBuffer *f, int size)
-{
-    f->buffer = av_malloc(size);
-    if (!f->buffer)
-        return -1;
-    f->end = f->buffer + size;
-    f->wptr = f->rptr = f->buffer;
-    return 0;
-}
-
-void fifo_free(FifoBuffer *f)
-{
-    av_free(f->buffer);
-}
-
-int fifo_size(FifoBuffer *f, uint8_t *rptr)
-{
-    int size;
-
-    if(!rptr)
-        rptr= f->rptr;
-
-    if (f->wptr >= rptr) {
-        size = f->wptr - rptr;
-    } else {
-        size = (f->end - rptr) + (f->wptr - f->buffer);
-    }
-    return size;
-}
-
 /**
- * Get data from the fifo (returns -1 if not enough data).
+ * Allocate the payload of a packet and intialized its fields to default values.
+ *
+ * @param filename possible numbered sequence string
+ * @return 1 if a valid numbered sequence string, 0 otherwise.
  */
-int fifo_read(FifoBuffer *f, uint8_t *buf, int buf_size, uint8_t **rptr_ptr)
+int av_filename_number_test(const char *filename)
 {
-    uint8_t *rptr;
-    int size, len;
-
-    if(!rptr_ptr)
-        rptr_ptr= &f->rptr;
-    rptr = *rptr_ptr;
-
-    if (f->wptr >= rptr) {
-        size = f->wptr - rptr;
-    } else {
-        size = (f->end - rptr) + (f->wptr - f->buffer);
-    }
-
-    if (size < buf_size)
-        return -1;
-    while (buf_size > 0) {
-        len = f->end - rptr;
-        if (len > buf_size)
-            len = buf_size;
-        memcpy(buf, rptr, len);
-        buf += len;
-        rptr += len;
-        if (rptr >= f->end)
-            rptr = f->buffer;
-        buf_size -= len;
-    }
-    *rptr_ptr = rptr;
-    return 0;
-}
-
-/**
- * Resizes a FIFO.
- */
-void fifo_realloc(FifoBuffer *f, unsigned int new_size){
-    unsigned int old_size= f->end - f->buffer;
-
-    if(old_size < new_size){
-        uint8_t *old= f->buffer;
-
-        f->buffer= av_realloc(f->buffer, new_size);
-
-        f->rptr += f->buffer - old;
-        f->wptr += f->buffer - old;
-
-        if(f->wptr < f->rptr){
-            memmove(f->rptr + new_size - old_size, f->rptr, f->buffer + old_size - f->rptr);
-            f->rptr += new_size - old_size;
-        }
-        f->end= f->buffer + new_size;
-    }
-}
-
-void fifo_write(FifoBuffer *f, uint8_t *buf, int size, uint8_t **wptr_ptr)
-{
-    int len;
-    uint8_t *wptr;
-
-    if(!wptr_ptr)
-        wptr_ptr= &f->wptr;
-    wptr = *wptr_ptr;
-
-    while (size > 0) {
-        len = f->end - wptr;
-        if (len > size)
-            len = size;
-        memcpy(wptr, buf, len);
-        wptr += len;
-        if (wptr >= f->end)
-            wptr = f->buffer;
-        buf += len;
-        size -= len;
-    }
-    *wptr_ptr = wptr;
-}
-
-/* get data from the fifo (return -1 if not enough data) */
-int put_fifo(ByteIOContext *pb, FifoBuffer *f, int buf_size, uint8_t **rptr_ptr)
-{
-    uint8_t *rptr = *rptr_ptr;
-    int size, len;
-
-    if (f->wptr >= rptr) {
-        size = f->wptr - rptr;
-    } else {
-        size = (f->end - rptr) + (f->wptr - f->buffer);
-    }
-
-    if (size < buf_size)
-        return -1;
-    while (buf_size > 0) {
-        len = f->end - rptr;
-        if (len > buf_size)
-            len = buf_size;
-        put_buffer(pb, rptr, len);
-        rptr += len;
-        if (rptr >= f->end)
-            rptr = f->buffer;
-        buf_size -= len;
-    }
-    *rptr_ptr = rptr;
-    return 0;
-}
-
-int filename_number_test(const char *filename)
-{
     char buf[1024];
-    if(!filename)
-        return -1;
-    return get_frame_filename(buf, sizeof(buf), filename, 1);
+    return filename && (av_get_frame_filename(buf, sizeof(buf), filename, 1)>=0);
 }
 
 /**
  * Guess file format.
+ *
+ * @param is_opened whether the file is already opened, determines whether
+ *                  demuxers with or without AVFMT_NOFILE are probed
  */
 AVInputFormat *av_probe_input_format(AVProbeData *pd, int is_opened)
 {
@@ -412,7 +282,7 @@
     fmt = NULL;
     score_max = 0;
     for(fmt1 = first_iformat; fmt1 != NULL; fmt1 = fmt1->next) {
-        if (!is_opened && !(fmt1->flags & AVFMT_NOFILE))
+        if (!is_opened == !(fmt1->flags & AVFMT_NOFILE))
             continue;
         score = 0;
         if (fmt1->read_probe) {
@@ -444,13 +314,45 @@
     else return "NULL";
 }
 
-static const AVClass av_format_context_class = { "AVFormatContext", format_to_name };
+#define OFFSET(x) offsetof(AVFormatContext,x)
+#define DEFAULT 0 //should be NAN but it doesnt work as its not a constant in glibc as required by ANSI/ISO C
+//these names are too long to be readable
+#define E AV_OPT_FLAG_ENCODING_PARAM
+#define D AV_OPT_FLAG_DECODING_PARAM
 
+static const AVOption options[]={
+{"probesize", NULL, OFFSET(probesize), FF_OPT_TYPE_INT, 32000, 32, INT_MAX, D}, /* 32000 from mpegts.c: 1.0 second at 24Mbit/s */
+{"muxrate", "set mux rate", OFFSET(mux_rate), FF_OPT_TYPE_INT, DEFAULT, 0, INT_MAX, E},
+{"packetsize", "set packet size", OFFSET(packet_size), FF_OPT_TYPE_INT, DEFAULT, 0, INT_MAX, E},
+{"fflags", NULL, OFFSET(flags), FF_OPT_TYPE_FLAGS, DEFAULT, INT_MIN, INT_MAX, D|E, "fflags"},
+{"ignidx", "ignore index", 0, FF_OPT_TYPE_CONST, AVFMT_FLAG_IGNIDX, INT_MIN, INT_MAX, D, "fflags"},
+{"genpts", "generate pts", 0, FF_OPT_TYPE_CONST, AVFMT_FLAG_GENPTS, INT_MIN, INT_MAX, D, "fflags"},
+{"track", " set the track number", OFFSET(track), FF_OPT_TYPE_INT, DEFAULT, 0, INT_MAX, E},
+{"year", "set the year", OFFSET(year), FF_OPT_TYPE_INT, DEFAULT, INT_MIN, INT_MAX, E},
+{NULL},
+};
+
+#undef E
+#undef D
+#undef DEFAULT
+
+static const AVClass av_format_context_class = { "AVFormatContext", format_to_name, options };
+
+static void avformat_get_context_defaults(AVFormatContext *s)
+{
+    memset(s, 0, sizeof(AVFormatContext));
+
+    s->av_class = &av_format_context_class;
+
+    av_opt_set_defaults(s);
+}
+
 AVFormatContext *av_alloc_format_context(void)
 {
     AVFormatContext *ic;
-    ic = av_mallocz(sizeof(AVFormatContext));
+    ic = av_malloc(sizeof(AVFormatContext));
     if (!ic) return ic;
+    avformat_get_context_defaults(ic);
     ic->av_class = &av_format_context_class;
     return ic;
 }
@@ -472,7 +374,10 @@
         memset(ap, 0, sizeof(default_ap));
     }
 
-    ic = av_alloc_format_context();
+    if(!ap->prealloced_context)
+        ic = av_alloc_format_context();
+    else
+        ic = *ic_ptr;
     if (!ic) {
         err = AVERROR_NOMEM;
         goto fail;
@@ -499,7 +404,7 @@
     if (err < 0)
         goto fail;
 
-    if (pb)
+    if (pb && !ic->data_offset)
         ic->data_offset = url_ftell(&ic->pb);
 
     *ic_ptr = ic;
@@ -515,7 +420,7 @@
 
 /** Size of probe buffer, for guessing file type from file contents. */
 #define PROBE_BUF_MIN 2048
-#define PROBE_BUF_MAX 131072
+#define PROBE_BUF_MAX (1<<20)
 
 /**
  * Open a media file as input. The codec are not opened. Only the file
@@ -594,7 +499,7 @@
 
     /* XXX: suppress this hack for redirectors */
 #ifdef CONFIG_NETWORK
-    if (fmt == &redir_demux) {
+    if (fmt == &redir_demuxer) {
         err = redir_open(ic_ptr, pb);
         url_fclose(pb);
         return err;
@@ -603,7 +508,7 @@
 
     /* check filename in case of an image number is expected */
     if (fmt->flags & AVFMT_NEEDNUMBER) {
-        if (filename_number_test(filename) < 0) {
+        if (!av_filename_number_test(filename)) {
             err = AVERROR_NUMEXPECTED;
             goto fail;
         }
@@ -648,50 +553,17 @@
     int frame_size;
 
     if (enc->frame_size <= 1) {
-        /* specific hack for pcm codecs because no frame size is
-           provided */
-        switch(enc->codec_id) {
-#if 0 //MEANX		
-        case CODEC_ID_PCM_S32LE:
-        case CODEC_ID_PCM_S32BE:
-        case CODEC_ID_PCM_U32LE:
-        case CODEC_ID_PCM_U32BE:
+        int bits_per_sample = av_get_bits_per_sample(enc->codec_id);
+
+        if (bits_per_sample) {
             if (enc->channels == 0)
                 return -1;
-            frame_size = size / (4 * enc->channels);
-            break;
-        case CODEC_ID_PCM_S24LE:
-        case CODEC_ID_PCM_S24BE:
-        case CODEC_ID_PCM_U24LE:
-        case CODEC_ID_PCM_U24BE:
-        case CODEC_ID_PCM_S24DAUD:
-            if (enc->channels == 0)
-                return -1;
-            frame_size = size / (3 * enc->channels);
-            break;
-#endif //MEANX	    
-        case CODEC_ID_PCM_S16LE:
-        case CODEC_ID_PCM_S16BE:
-        case CODEC_ID_PCM_U16LE:
-        case CODEC_ID_PCM_U16BE:
-            if (enc->channels == 0)
-                return -1;
-            frame_size = size / (2 * enc->channels);
-            break;
-        case CODEC_ID_PCM_S8:
-        case CODEC_ID_PCM_U8:
-        case CODEC_ID_PCM_MULAW:
-        case CODEC_ID_PCM_ALAW:
-            if (enc->channels == 0)
-                return -1;
-            frame_size = size / (enc->channels);
-            break;
-        default:
+            frame_size = (size << 3) / (bits_per_sample * enc->channels);
+        } else {
             /* used for example by ADPCM codecs */
             if (enc->bit_rate == 0)
                 return -1;
             frame_size = (size * 8 * enc->sample_rate) / enc->bit_rate;
-            break;
         }
     } else {
         frame_size = enc->frame_size;
@@ -805,7 +677,7 @@
         else                     st->cur_dts = 0;
     }
 
-//    av_log(NULL, AV_LOG_DEBUG, "IN delayed:%d pts:%lld, dts:%lld cur_dts:%lld st:%d pc:%p\n", presentation_delayed, pkt->pts, pkt->dts, st->cur_dts, pkt->stream_index, pc);
+//    av_log(NULL, AV_LOG_DEBUG, "IN delayed:%d pts:%"PRId64", dts:%"PRId64" cur_dts:%"PRId64" st:%d pc:%p\n", presentation_delayed, pkt->pts, pkt->dts, st->cur_dts, pkt->stream_index, pc);
     /* interpolate PTS and DTS if they are not present */
     if (presentation_delayed) {
         /* DTS = decompression time stamp */
@@ -831,11 +703,11 @@
            by knowing the futur */
     } else if(pkt->pts != AV_NOPTS_VALUE || pkt->dts != AV_NOPTS_VALUE || pkt->duration){
         if(pkt->pts != AV_NOPTS_VALUE && pkt->duration){
-            int64_t old_diff= ABS(st->cur_dts - pkt->duration - pkt->pts);
-            int64_t new_diff= ABS(st->cur_dts - pkt->pts);
+            int64_t old_diff= FFABS(st->cur_dts - pkt->duration - pkt->pts);
+            int64_t new_diff= FFABS(st->cur_dts - pkt->pts);
             if(old_diff < new_diff && old_diff < (pkt->duration>>3)){
                 pkt->pts += pkt->duration;
-//                av_log(NULL, AV_LOG_DEBUG, "id:%d old:%Ld new:%Ld dur:%d cur:%Ld size:%d\n", pkt->stream_index, old_diff, new_diff, pkt->duration, st->cur_dts, pkt->size);
+//                av_log(NULL, AV_LOG_DEBUG, "id:%d old:%"PRId64" new:%"PRId64" dur:%d cur:%"PRId64" size:%d\n", pkt->stream_index, old_diff, new_diff, pkt->duration, st->cur_dts, pkt->size);
             }
         }
 
@@ -855,7 +727,7 @@
         }
         st->cur_dts += pkt->duration;
     }
-//    av_log(NULL, AV_LOG_DEBUG, "OUTdelayed:%d pts:%lld, dts:%lld cur_dts:%lld\n", presentation_delayed, pkt->pts, pkt->dts, st->cur_dts);
+//    av_log(NULL, AV_LOG_DEBUG, "OUTdelayed:%d pts:%"PRId64", dts:%"PRId64" cur_dts:%"PRId64"\n", presentation_delayed, pkt->pts, pkt->dts, st->cur_dts);
 
     /* update flags */
     if (pc) {
@@ -895,7 +767,7 @@
                 *pkt = s->cur_pkt;
                 compute_pkt_fields(s, st, NULL, pkt);
                 s->cur_st = NULL;
-                return 0;
+                break;
             } else if (s->cur_len > 0 && st->discard < AVDISCARD_ALL) {
                 len = av_parser_parse(st->parser, st->codec, &pkt->data, &pkt->size,
                                       s->cur_ptr, s->cur_len,
@@ -915,7 +787,7 @@
                     pkt->dts = st->parser->dts;
                     pkt->destruct = av_destruct_packet_nofree;
                     compute_pkt_fields(s, st, st->parser, pkt);
-                    return 0;
+                    break;
                 }
             } else {
                 /* free packet */
@@ -945,6 +817,12 @@
             }
 
             st = s->streams[s->cur_pkt.stream_index];
+            if(st->codec->debug & FF_DEBUG_PTS)
+                av_log(s, AV_LOG_DEBUG, "av_read_packet stream=%d, pts=%"PRId64", dts=%"PRId64", size=%d\n",
+                    s->cur_pkt.stream_index,
+                    s->cur_pkt.pts,
+                    s->cur_pkt.dts,
+                    s->cur_pkt.size);
 
             s->cur_st = st;
             s->cur_ptr = s->cur_pkt.data;
@@ -960,6 +838,14 @@
             }
         }
     }
+    if(st->codec->debug & FF_DEBUG_PTS)
+        av_log(s, AV_LOG_DEBUG, "av_read_frame_internal stream=%d, pts=%"PRId64", dts=%"PRId64", size=%d\n",
+            pkt->stream_index,
+            pkt->pts,
+            pkt->dts,
+            pkt->size);
+
+    return 0;
 }
 
 /**
@@ -1121,7 +1007,7 @@
  * @param timestamp new dts expressed in time_base of param ref_st
  * @param ref_st reference stream giving time_base of param timestamp
  */
-static void av_update_cur_dts(AVFormatContext *s, AVStream *ref_st, int64_t timestamp){
+void av_update_cur_dts(AVFormatContext *s, AVStream *ref_st, int64_t timestamp){
     int i;
 
     for(i = 0; i < s->nb_streams; i++) {
@@ -1277,8 +1163,7 @@
     AVInputFormat *avif= s->iformat;
     int64_t pos_min, pos_max, pos, pos_limit;
     int64_t ts_min, ts_max, ts;
-    int64_t start_pos, filesize;
-    int index, no_change;
+    int index;
     AVStream *st;
 
     if (stream_index < 0)
@@ -1326,9 +1211,36 @@
         }
     }
 
+    pos= av_gen_search(s, stream_index, target_ts, pos_min, pos_max, pos_limit, ts_min, ts_max, flags, &ts, avif->read_timestamp);
+    if(pos<0)
+        return -1;
+
+    /* do the seek */
+    url_fseek(&s->pb, pos, SEEK_SET);
+
+    av_update_cur_dts(s, st, ts);
+
+    return 0;
+}
+
+/**
+ * Does a binary search using read_timestamp().
+ * this isnt supposed to be called directly by a user application, but by demuxers
+ * @param target_ts target timestamp in the time base of the given stream
+ * @param stream_index stream number
+ */
+int64_t av_gen_search(AVFormatContext *s, int stream_index, int64_t target_ts, int64_t pos_min, int64_t pos_max, int64_t pos_limit, int64_t ts_min, int64_t ts_max, int flags, int64_t *ts_ret, int64_t (*read_timestamp)(struct AVFormatContext *, int , int64_t *, int64_t )){
+    int64_t pos, ts;
+    int64_t start_pos, filesize;
+    int no_change;
+
+#ifdef DEBUG_SEEK
+    av_log(s, AV_LOG_DEBUG, "gen_seek: %d %"PRId64"\n", stream_index, target_ts);
+#endif
+
     if(ts_min == AV_NOPTS_VALUE){
         pos_min = s->data_offset;
-        ts_min = avif->read_timestamp(s, stream_index, &pos_min, INT64_MAX);
+        ts_min = read_timestamp(s, stream_index, &pos_min, INT64_MAX);
         if (ts_min == AV_NOPTS_VALUE)
             return -1;
     }
@@ -1339,7 +1251,7 @@
         pos_max = filesize - 1;
         do{
             pos_max -= step;
-            ts_max = avif->read_timestamp(s, stream_index, &pos_max, pos_max + step);
+            ts_max = read_timestamp(s, stream_index, &pos_max, pos_max + step);
             step += step;
         }while(ts_max == AV_NOPTS_VALUE && pos_max >= step);
         if (ts_max == AV_NOPTS_VALUE)
@@ -1347,7 +1259,7 @@
 
         for(;;){
             int64_t tmp_pos= pos_max + 1;
-            int64_t tmp_ts= avif->read_timestamp(s, stream_index, &tmp_pos, INT64_MAX);
+            int64_t tmp_ts= read_timestamp(s, stream_index, &tmp_pos, INT64_MAX);
             if(tmp_ts == AV_NOPTS_VALUE)
                 break;
             ts_max= tmp_ts;
@@ -1391,7 +1303,7 @@
             pos= pos_limit;
         start_pos= pos;
 
-        ts = avif->read_timestamp(s, stream_index, &pos, INT64_MAX); //may pass pos_limit instead of -1
+        ts = read_timestamp(s, stream_index, &pos, INT64_MAX); //may pass pos_limit instead of -1
         if(pos == pos_max)
             no_change++;
         else
@@ -1415,18 +1327,14 @@
     ts  = (flags & AVSEEK_FLAG_BACKWARD) ?  ts_min :  ts_max;
 #ifdef DEBUG_SEEK
     pos_min = pos;
-    ts_min = avif->read_timestamp(s, stream_index, &pos_min, INT64_MAX);
+    ts_min = read_timestamp(s, stream_index, &pos_min, INT64_MAX);
     pos_min++;
-    ts_max = avif->read_timestamp(s, stream_index, &pos_min, INT64_MAX);
+    ts_max = read_timestamp(s, stream_index, &pos_min, INT64_MAX);
     av_log(s, AV_LOG_DEBUG, "pos=0x%"PRIx64" %"PRId64"<=%"PRId64"<=%"PRId64"\n",
            pos, ts_min, target_ts, ts_max);
 #endif
-    /* do the seek */
-    url_fseek(&s->pb, pos, SEEK_SET);
-
-    av_update_cur_dts(s, st, ts);
-
-    return 0;
+    *ts_ret= ts;
+    return pos;
 }
 
 static int av_seek_frame_byte(AVFormatContext *s, int stream_index, int64_t pos, int flags){
@@ -1564,8 +1472,8 @@
     int i;
     AVStream *st;
 
-    start_time = MAXINT64;
-    end_time = MININT64;
+    start_time = INT64_MAX;
+    end_time = INT64_MIN;
     for(i = 0;i < ic->nb_streams; i++) {
         st = ic->streams[i];
         if (st->start_time != AV_NOPTS_VALUE) {
@@ -1580,9 +1488,9 @@
             }
         }
     }
-    if (start_time != MAXINT64) {
+    if (start_time != INT64_MAX) {
         ic->start_time = start_time;
-        if (end_time != MININT64) {
+        if (end_time != INT64_MIN) {
             ic->duration = end_time - start_time;
             if (ic->file_size > 0) {
                 /* compute the bit rate */
@@ -1758,8 +1666,9 @@
     }
     ic->file_size = file_size;
 
-    //MEANX if ((ic->iformat == &mpegps_demux || ic->iformat == &mpegts_demux) && file_size && !ic->pb.is_streamed) {
-    if ((ic->iformat == &mpegps_demux ) && file_size && !ic->pb.is_streamed) {
+    if ((!strcmp(ic->iformat->name, "mpeg") ||
+         !strcmp(ic->iformat->name, "mpegts")) &&
+        file_size && !ic->pb.is_streamed) {
         /* get accurate estimate from the PTSes */
         av_estimate_timings_from_pts(ic);
     } else if (av_has_timings(ic)) {
@@ -1849,8 +1758,14 @@
 #define MAX_READ_SIZE        5000000
 
 /* maximum duration until we stop analysing the stream */
-#define MAX_STREAM_DURATION  ((int)(AV_TIME_BASE * 2.0))
+#define MAX_STREAM_DURATION  ((int)(AV_TIME_BASE * 3.0))
 
+#define MAX_STD_TIMEBASES (60*12+5)
+static int get_std_framerate(int i){
+    if(i<60*12) return i*1001;
+    else        return ((int[]){24,30,60,12,15})[i-60*12]*1000*12;
+}
+
 /**
  * Read the beginning of a media file to get stream information. This
  * is useful for file formats with no headers such as MPEG. This
@@ -1868,8 +1783,8 @@
     AVPacket pkt1, *pkt;
     AVPacketList *pktl=NULL, **ppktl;
     int64_t last_dts[MAX_STREAMS];
-    int64_t duration_sum[MAX_STREAMS];
     int duration_count[MAX_STREAMS]={0};
+    double duration_error[MAX_STREAMS][MAX_STD_TIMEBASES]={{0}}; //FIXME malloc()?
 
     for(i=0;i<ic->nb_streams;i++) {
         st = ic->streams[i];
@@ -1890,7 +1805,6 @@
 
     for(i=0;i<MAX_STREAMS;i++){
         last_dts[i]= AV_NOPTS_VALUE;
-        duration_sum[i]= INT64_MAX;
     }
 
     count = 0;
@@ -1918,13 +1832,12 @@
                 ret = count;
                 break;
             }
-        } else {
-            /* we did not get all the codec info, but we read too much data */
-            if (read_size >= MAX_READ_SIZE) {
-                ret = count;
-                break;
-            }
         }
+        /* we did not get all the codec info, but we read too much data */
+        if (read_size >= MAX_READ_SIZE) {
+            ret = count;
+            break;
+        }
 
         /* NOTE: a new stream can be added there if no header in file
            (AVFMTCTX_NOHEADER) */
@@ -1938,11 +1851,10 @@
                     char buf[256];
                     avcodec_string(buf, sizeof(buf), st->codec, 0);
                     av_log(ic, AV_LOG_INFO, "Could not find codec parameters (%s)\n", buf);
-                    break;
+                } else {
+                    ret = 0;
                 }
             }
-            if (i == ic->nb_streams)
-                ret = 0;
             break;
         }
 
@@ -1961,14 +1873,15 @@
 
         /* duplicate the packet */
         if (av_dup_packet(pkt) < 0) {
-                ret = AVERROR_NOMEM;
-                break;
+            ret = AVERROR_NOMEM;
+            break;
         }
 
         read_size += pkt->size;
 
         st = ic->streams[pkt->stream_index];
-        st->codec_info_duration += pkt->duration;
+        if(st->codec_info_nb_frames>1) //FIXME move codec_info_nb_frames and codec_info_duration from AVStream into this func
+            st->codec_info_duration += pkt->duration;
         if (pkt->duration != 0)
             st->codec_info_nb_frames++;
 
@@ -1978,25 +1891,33 @@
             int64_t duration= pkt->dts - last;
 
             if(pkt->dts != AV_NOPTS_VALUE && last != AV_NOPTS_VALUE && duration>0){
-                if(duration*duration_count[index]*10/9 < duration_sum[index]){
-                    duration_sum[index]= duration;
-                    duration_count[index]=1;
-                }else{
-                    int factor= av_rescale(duration, duration_count[index], duration_sum[index]);
-                    duration_sum[index] += duration;
-                    duration_count[index]+= factor;
+                double dur= duration * av_q2d(st->time_base);
+
+//                if(st->codec->codec_type == CODEC_TYPE_VIDEO)
+//                    av_log(NULL, AV_LOG_ERROR, "%f\n", dur);
+                if(duration_count[index] < 2)
+                    memset(duration_error, 0, sizeof(duration_error));
+                for(i=1; i<MAX_STD_TIMEBASES; i++){
+                    int framerate= get_std_framerate(i);
+                    int ticks= lrintf(dur*framerate/(1001*12));
+                    double error= dur - ticks*1001*12/(double)framerate;
+                    duration_error[index][i] += error*error;
                 }
+                duration_count[index]++;
+
                 if(st->codec_info_nb_frames == 0 && 0)
                     st->codec_info_duration += duration;
             }
-            last_dts[pkt->stream_index]= pkt->dts;
+            if(last == AV_NOPTS_VALUE || duration_count[index]<=1)
+                last_dts[pkt->stream_index]= pkt->dts;
         }
         if(st->parser && st->parser->parser->split && !st->codec->extradata){
             int i= st->parser->parser->split(st->codec, pkt->data, pkt->size);
             if(i){
                 st->codec->extradata_size= i;
-                st->codec->extradata= av_malloc(st->codec->extradata_size);
+                st->codec->extradata= av_malloc(st->codec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);
                 memcpy(st->codec->extradata, pkt->data, st->codec->extradata_size);
+                memset(st->codec->extradata + i, 0, FF_INPUT_BUFFER_PADDING_SIZE);
             }
         }
 
@@ -2039,58 +1960,34 @@
             if(st->codec->codec_id == CODEC_ID_RAWVIDEO && !st->codec->codec_tag && !st->codec->bits_per_sample)
                 st->codec->codec_tag= avcodec_pix_fmt_to_codec_tag(st->codec->pix_fmt);
 
-            if(duration_count[i] && st->codec->time_base.num*101LL <= st->codec->time_base.den &&
-               st->time_base.num*duration_sum[i]/duration_count[i]*101LL > st->time_base.den){
-                int64_t num, den, error, best_error;
+            if(duration_count[i]
+               && (st->codec->time_base.num*101LL <= st->codec->time_base.den || st->codec->codec_id == CODEC_ID_MPEG2VIDEO) /*&&
+               //FIXME we should not special case mpeg2, but this needs testing with non mpeg2 ...
+               st->time_base.num*duration_sum[i]/duration_count[i]*101LL > st->time_base.den*/){
+                double best_error= 2*av_q2d(st->time_base);
+                best_error= best_error*best_error*duration_count[i]*1000*12*30;
 
-                num= st->time_base.den*duration_count[i];
-                den= st->time_base.num*duration_sum[i];
-
-                best_error= INT64_MAX;
-                for(j=1; j<60*12; j++){
-                    error= ABS(1001*12*num - 1001*j*den);
+                for(j=1; j<MAX_STD_TIMEBASES; j++){
+                    double error= duration_error[i][j] * get_std_framerate(j);
+//                    if(st->codec->codec_type == CODEC_TYPE_VIDEO)
+//                        av_log(NULL, AV_LOG_ERROR, "%f %f\n", get_std_framerate(j) / 12.0/1001, error);
                     if(error < best_error){
                         best_error= error;
-                        av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den, j, 12, INT_MAX);
+                        av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den, get_std_framerate(j), 12*1001, INT_MAX);
                     }
                 }
-                for(j=24; j<=30; j+=6){
-                    error= ABS(1001*12*num - 1000*12*j*den);
-                    if(error < best_error){
-                        best_error= error;
-                        av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den, j*1000, 1001, INT_MAX);
-                    }
-                }
             }
 
-            /* set real frame rate info */
-            /* compute the real frame rate for telecine */
-            if ((st->codec->codec_id == CODEC_ID_MPEG1VIDEO ||
-                 st->codec->codec_id == CODEC_ID_MPEG2VIDEO) &&
-                st->codec->sub_id == 2) {
-                if (st->codec_info_nb_frames >= 20) {
-                    float coded_frame_rate, est_frame_rate;
-                    est_frame_rate = ((double)st->codec_info_nb_frames * AV_TIME_BASE) /
-                        (double)st->codec_info_duration ;
-                    coded_frame_rate = 1.0/av_q2d(st->codec->time_base);
-#if 0
-                    printf("telecine: coded_frame_rate=%0.3f est_frame_rate=%0.3f\n",
-                           coded_frame_rate, est_frame_rate);
-#endif
-                    /* if we detect that it could be a telecine, we
-                       signal it. It would be better to do it at a
-                       higher level as it can change in a film */
-                    if (coded_frame_rate >= 24.97 &&
-                        (est_frame_rate >= 23.5 && est_frame_rate < 24.5)) {
-                        st->r_frame_rate = (AVRational){24000, 1001};
-                    }
+            if (!st->r_frame_rate.num){
+                if(    st->codec->time_base.den * (int64_t)st->time_base.num
+                    <= st->codec->time_base.num * (int64_t)st->time_base.den){
+                    st->r_frame_rate.num = st->codec->time_base.den;
+                    st->r_frame_rate.den = st->codec->time_base.num;
+                }else{
+                    st->r_frame_rate.num = st->time_base.den;
+                    st->r_frame_rate.den = st->time_base.num;
                 }
             }
-            /* if no real frame rate, use the codec one */
-            if (!st->r_frame_rate.num){
-                st->r_frame_rate.num = st->codec->time_base.den;
-                st->r_frame_rate.den = st->codec->time_base.num;
-            }
         }
     }
 
@@ -2170,6 +2067,7 @@
             av_parser_close(st->parser);
         }
         av_free(st->index_entries);
+        av_free(st->codec->extradata);
         av_free(st->codec);
         av_free(st);
     }
@@ -2198,6 +2096,7 @@
 AVStream *av_new_stream(AVFormatContext *s, int id)
 {
     AVStream *st;
+    int i;
 
     if (s->nb_streams >= MAX_STREAMS)
         return NULL;
@@ -2220,6 +2119,8 @@
     /* default pts settings is MPEG like */
     av_set_pts_info(st, 33, 1, 90000);
     st->last_IP_pts = AV_NOPTS_VALUE;
+    for(i=0; i<MAX_REORDER_DELAY+1; i++)
+        st->pts_buffer[i]= AV_NOPTS_VALUE;
 
     s->streams[s->nb_streams++] = st;
     return st;
@@ -2283,6 +2184,12 @@
         }
     }
 
+    if (!s->priv_data && s->oformat->priv_data_size > 0) {
+        s->priv_data = av_mallocz(s->oformat->priv_data_size);
+        if (!s->priv_data)
+            return AVERROR_NOMEM;
+    }
+
     if(s->oformat->write_header){
         ret = s->oformat->write_header(s);
         if (ret < 0)
@@ -2315,10 +2222,10 @@
 
 //FIXME merge with compute_pkt_fields
 static int compute_pkt_fields2(AVStream *st, AVPacket *pkt){
-    int b_frames = FFMAX(st->codec->has_b_frames, st->codec->max_b_frames);
-    int num, den, frame_size;
+    int delay = FFMAX(st->codec->has_b_frames, !!st->codec->max_b_frames);
+    int num, den, frame_size, i;
 
-//    av_log(NULL, AV_LOG_DEBUG, "av_write_frame: pts:%lld dts:%lld cur_dts:%lld b:%d size:%d st:%d\n", pkt->pts, pkt->dts, st->cur_dts, b_frames, pkt->size, pkt->stream_index);
+//    av_log(st->codec, AV_LOG_DEBUG, "av_write_frame: pts:%"PRId64" dts:%"PRId64" cur_dts:%"PRId64" b:%d size:%d st:%d\n", pkt->pts, pkt->dts, st->cur_dts, delay, pkt->size, pkt->stream_index);
 
 /*    if(pkt->pts == AV_NOPTS_VALUE && pkt->dts == AV_NOPTS_VALUE)
         return -1;*/
@@ -2332,7 +2239,7 @@
     }
 
     //XXX/FIXME this is a temporary hack until all encoders output pts
-    if((pkt->pts == 0 || pkt->pts == AV_NOPTS_VALUE) && pkt->dts == AV_NOPTS_VALUE && !b_frames){
+    if((pkt->pts == 0 || pkt->pts == AV_NOPTS_VALUE) && pkt->dts == AV_NOPTS_VALUE && !delay){
         pkt->dts=
 //        pkt->pts= st->cur_dts;
         pkt->pts= st->pts.val;
@@ -2340,17 +2247,13 @@
 
     //calculate dts from pts
     if(pkt->pts != AV_NOPTS_VALUE && pkt->dts == AV_NOPTS_VALUE){
-        if(b_frames){
-            if(st->last_IP_pts == AV_NOPTS_VALUE){
-                st->last_IP_pts= -pkt->duration;
-            }
-            if(st->last_IP_pts < pkt->pts){
-                pkt->dts= st->last_IP_pts;
-                st->last_IP_pts= pkt->pts;
-            }else
-                pkt->dts= pkt->pts;
-        }else
-            pkt->dts= pkt->pts;
+        st->pts_buffer[0]= pkt->pts;
+        for(i=1; i<delay+1 && st->pts_buffer[i] == AV_NOPTS_VALUE; i++)
+            st->pts_buffer[i]= (i-delay-1) * pkt->duration;
+        for(i=0; i<delay && st->pts_buffer[i] > st->pts_buffer[i+1]; i++)
+            FFSWAP(int64_t, st->pts_buffer[i], st->pts_buffer[i+1]);
+
+        pkt->dts= st->pts_buffer[0];
     }
 
     if(st->cur_dts && st->cur_dts != AV_NOPTS_VALUE && st->cur_dts >= pkt->dts){
@@ -2362,7 +2265,7 @@
         return -1;
     }
 
-//    av_log(NULL, AV_LOG_DEBUG, "av_write_frame: pts2:%lld dts2:%lld\n", pkt->pts, pkt->dts);
+//    av_log(NULL, AV_LOG_DEBUG, "av_write_frame: pts2:%"PRId64" dts2:%"PRId64"\n", pkt->pts, pkt->dts);
     st->cur_dts= pkt->dts;
     st->pts.val= pkt->dts;
 
@@ -2392,8 +2295,10 @@
 //    if(pkt->dts < 0)
 //        pkt->dts= 0;  //this happens for low_delay=0 and b frames, FIXME, needs further invstigation about what we should do here
 
-    pkt->pts &= pts_mask;
-    pkt->dts &= pts_mask;
+    if (pkt->pts != AV_NOPTS_VALUE)
+        pkt->pts &= pts_mask;
+    if (pkt->dts != AV_NOPTS_VALUE)
+        pkt->dts &= pts_mask;
 }
 
 /**
@@ -2410,7 +2315,7 @@
     int ret;
 
     ret=compute_pkt_fields2(s->streams[pkt->stream_index], pkt);
-    if(ret<0)
+    if(ret<0 && !(s->oformat->flags & AVFMT_NOTIMESTAMPS))
         return ret;
 
     truncate_ts(s->streams[pkt->stream_index], pkt);
@@ -2422,11 +2327,20 @@
 }
 
 /**
- * interleave_packet implementation which will interleave per DTS.
- * packets with pkt->destruct == av_destruct_packet will be freed inside this function.
- * so they cannot be used after it, note calling av_free_packet() on them is still safe
+ * Interleave a packet per DTS in an output media file.
+ *
+ * Packets with pkt->destruct == av_destruct_packet will be freed inside this function,
+ * so they cannot be used after it, note calling av_free_packet() on them is still safe.
+ *
+ * @param s media file handle
+ * @param out the interleaved packet will be output here
+ * @param in the input packet
+ * @param flush 1 if no further packets are available as input and all
+ *              remaining packets should be output
+ * @return 1 if a packet was output, 0 if no packet could be output,
+ *         < 0 if an error occured
  */
-static int av_interleave_packet_per_dts(AVFormatContext *s, AVPacket *out, AVPacket *pkt, int flush){
+int av_interleave_packet_per_dts(AVFormatContext *s, AVPacket *out, AVPacket *pkt, int flush){
     AVPacketList *pktl, **next_point, *this_pktl;
     int stream_count=0;
     int streams[MAX_STREAMS];
@@ -2459,7 +2373,7 @@
     memset(streams, 0, sizeof(streams));
     pktl= s->packet_buffer;
     while(pktl){
-//av_log(s, AV_LOG_DEBUG, "show st:%d dts:%lld\n", pktl->pkt.stream_index, pktl->pkt.dts);
+//av_log(s, AV_LOG_DEBUG, "show st:%d dts:%"PRId64"\n", pktl->pkt.stream_index, pktl->pkt.dts);
         if(streams[ pktl->pkt.stream_index ] == 0)
             stream_count++;
         streams[ pktl->pkt.stream_index ]++;
@@ -2516,8 +2430,8 @@
     if(st->codec->codec_type == CODEC_TYPE_AUDIO && pkt->size==0)
         return 0;
 
-//av_log(NULL, AV_LOG_DEBUG, "av_interleaved_write_frame %d %Ld %Ld\n", pkt->size, pkt->dts, pkt->pts);
-    if(compute_pkt_fields2(st, pkt) < 0)
+//av_log(NULL, AV_LOG_DEBUG, "av_interleaved_write_frame %d %"PRId64" %"PRId64"\n", pkt->size, pkt->dts, pkt->pts);
+    if(compute_pkt_fields2(st, pkt) < 0 && !(s->oformat->flags & AVFMT_NOTIMESTAMPS))
         return -1;
 
     if(pkt->dts == AV_NOPTS_VALUE)
@@ -2647,6 +2561,7 @@
             av_log(NULL, AV_LOG_INFO, "(%s)", st->language);
         }
         av_log(NULL, AV_LOG_DEBUG, ", %d/%d", st->time_base.num/g, st->time_base.den/g);
+        av_log(NULL, AV_LOG_INFO, ": %s", buf);
         if(st->codec->codec_type == CODEC_TYPE_VIDEO){
             if(st->r_frame_rate.den && st->r_frame_rate.num)
                 av_log(NULL, AV_LOG_INFO, ", %5.2f fps(r)", av_q2d(st->r_frame_rate));
@@ -2655,7 +2570,7 @@
             else
                 av_log(NULL, AV_LOG_INFO, ", %5.2f fps(c)", 1/av_q2d(st->codec->time_base));
         }
-        av_log(NULL, AV_LOG_INFO, ": %s\n", buf);
+        av_log(NULL, AV_LOG_INFO, "\n");
     }
 }
 
@@ -2850,7 +2765,7 @@
         if (duration)
             return 0;
         else
-            return now * int64_t_C(1000000);
+            return now * INT64_C(1000000);
     }
 
     if (duration) {
@@ -2927,12 +2842,18 @@
 
 /**
  * Returns in 'buf' the path with '%d' replaced by number.
- *
+
  * Also handles the '%0nd' format where 'n' is the total number
- * of digits and '%%'. Return 0 if OK, and -1 if format error.
+ * of digits and '%%'.
+ *
+ * @param buf destination buffer
+ * @param buf_size destination buffer size
+ * @param path numbered sequence string
+ * @number frame number
+ * @return 0 if OK, -1 if format error.
  */
-int get_frame_filename(char *buf, int buf_size,
-                       const char *path, int number)
+int av_get_frame_filename(char *buf, int buf_size,
+                          const char *path, int number)
 {
     const char *p;
     char *q, buf1[20], c;
@@ -3148,7 +3069,7 @@
  * @param num must be >= 0
  * @param den must be >= 1
  */
-void av_frac_init(AVFrac *f, int64_t val, int64_t num, int64_t den)
+static void av_frac_init(AVFrac *f, int64_t val, int64_t num, int64_t den)
 {
     num += (den >> 1);
     if (num >= den) {
@@ -3161,32 +3082,17 @@
 }
 
 /**
- * Set f to (val + 0.5).
- */
-void av_frac_set(AVFrac *f, int64_t val)
-{
-    f->val = val;
-    f->num = f->den >> 1;
-}
-
-/**
  * Fractionnal addition to f: f = f + (incr / f->den).
  *
  * @param f fractional number
  * @param incr increment, can be positive or negative
  */
-void av_frac_add(AVFrac *f, int64_t incr)
+static void av_frac_add(AVFrac *f, int64_t incr)
 {
     int64_t num, den;
 
     num = f->num + incr;
     den = f->den;
-    ///MEANX
-    if(!den)
-    {
-		return;
-    }
-    ///MEANX
     if (num < 0) {
         f->val += num / den;
         num = num % den;
@@ -3200,93 +3106,3 @@
     }
     f->num = num;
 }
-
-/**
- * register a new image format
- * @param img_fmt Image format descriptor
- */
-void av_register_image_format(AVImageFormat *img_fmt)
-{
-    AVImageFormat **p;
-
-    p = &first_image_format;
-    while (*p != NULL) p = &(*p)->next;
-    *p = img_fmt;
-    img_fmt->next = NULL;
-}
-
-/**
- * Guesses image format based on data in the image.
- */
-AVImageFormat *av_probe_image_format(AVProbeData *pd)
-{
-    AVImageFormat *fmt1, *fmt;
-    int score, score_max;
-
-    fmt = NULL;
-    score_max = 0;
-    for(fmt1 = first_image_format; fmt1 != NULL; fmt1 = fmt1->next) {
-        if (fmt1->img_probe) {
-            score = fmt1->img_probe(pd);
-            if (score > score_max) {
-                score_max = score;
-                fmt = fmt1;
-            }
-        }
-    }
-    return fmt;
-}
-
-/**
- * Guesses image format based on file name extensions.
- */
-AVImageFormat *guess_image_format(const char *filename)
-{
-    AVImageFormat *fmt1;
-
-    for(fmt1 = first_image_format; fmt1 != NULL; fmt1 = fmt1->next) {
-        if (fmt1->extensions && match_ext(filename, fmt1->extensions))
-            return fmt1;
-    }
-    return NULL;
-}
-
-/**
- * Read an image from a stream.
- * @param gb byte stream containing the image
- * @param fmt image format, NULL if probing is required
- */
-int av_read_image(ByteIOContext *pb, const char *filename,
-                  AVImageFormat *fmt,
-                  int (*alloc_cb)(void *, AVImageInfo *info), void *opaque)
-{
-    uint8_t buf[PROBE_BUF_MIN];
-    AVProbeData probe_data, *pd = &probe_data;
-    offset_t pos;
-    int ret;
-
-    if (!fmt) {
-        pd->filename = filename;
-        pd->buf = buf;
-        pos = url_ftell(pb);
-        pd->buf_size = get_buffer(pb, buf, PROBE_BUF_MIN);
-        url_fseek(pb, pos, SEEK_SET);
-        fmt = av_probe_image_format(pd);
-    }
-    if (!fmt)
-        return AVERROR_NOFMT;
-    ret = fmt->img_read(pb, alloc_cb, opaque);
-    return ret;
-}
-
-/**
- * Write an image to a stream.
- * @param pb byte stream for the image output
- * @param fmt image format
- * @param img image data and informations
- */
-int av_write_image(ByteIOContext *pb, AVImageFormat *fmt, AVImageInfo *img)
-{
-    return fmt->img_write(pb, img);
-}
-

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/wav.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/wav.c	2007-01-20 15:15:58 UTC (rev 2746)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/wav.c	2007-01-21 18:04:24 UTC (rev 2747)
@@ -1,205 +1,33 @@
 /*
- * WAV encoder and decoder
+ * WAV muxer and demuxer
  * Copyright (c) 2001, 2002 Fabrice Bellard.
  *
- * This library is free software; you can redistribute it and/or
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
+ * version 2.1 of the License, or (at your option) any later version.
  *
- * This library is distributed in the hope that it will be useful,
+ * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 #include "avformat.h"
-#include "avi.h"
+#include "allformats.h"
+#include "riff.h"
 
-const CodecTag codec_wav_tags[] = {
-    { CODEC_ID_MP2, 0x50 },
-    { CODEC_ID_MP3, 0x55 },
-    { CODEC_ID_AC3, 0x2000 },
-    { CODEC_ID_DTS, 0x2001 },
-    { CODEC_ID_PCM_S16LE, 0x01 },
-    { CODEC_ID_PCM_U8, 0x01 }, /* must come after s16le in this list */
-    { CODEC_ID_PCM_S24LE, 0x01 },
-    { CODEC_ID_PCM_S32LE, 0x01 },
-    { CODEC_ID_PCM_ALAW, 0x06 },
-    { CODEC_ID_PCM_MULAW, 0x07 },
-    { CODEC_ID_ADPCM_MS, 0x02 },
-    { CODEC_ID_ADPCM_IMA_WAV, 0x11 },
-    { CODEC_ID_ADPCM_YAMAHA, 0x20 },
-    { CODEC_ID_ADPCM_G726, 0x45 },
-    { CODEC_ID_ADPCM_IMA_DK4, 0x61 },  /* rogue format number */
-    { CODEC_ID_ADPCM_IMA_DK3, 0x62 },  /* rogue format number */
-    { CODEC_ID_WMAV1, 0x160 },
-    { CODEC_ID_WMAV2, 0x161 },
-    { CODEC_ID_AAC, 0x706d },
-    { CODEC_ID_VORBIS, ('V'<<8)+'o' }, //HACK/FIXME, does vorbis in WAV/AVI have an (in)official id?
-    { CODEC_ID_SONIC, 0x2048 },
-    { CODEC_ID_SONIC_LS, 0x2048 },
-    { CODEC_ID_ADPCM_CT, 0x200 },
-    { CODEC_ID_ADPCM_SWF, ('S'<<8)+'F' },
-    { 0, 0 },
-};
-
-#ifdef CONFIG_MUXERS
-/* WAVEFORMATEX header */
-/* returns the size or -1 on error */
-int put_wav_header(ByteIOContext *pb, AVCodecContext *enc)
-{
-    int bps, blkalign, bytespersec;
-    int hdrsize = 18;
-
-    if(!enc->codec_tag)
-       enc->codec_tag = codec_get_tag(codec_wav_tags, enc->codec_id);
-    if(!enc->codec_tag)
-        return -1;
-
-    put_le16(pb, enc->codec_tag);
-    put_le16(pb, enc->channels);
-    put_le32(pb, enc->sample_rate);
-    if (enc->codec_id == CODEC_ID_PCM_U8 ||
-        enc->codec_id == CODEC_ID_PCM_ALAW ||
-        enc->codec_id == CODEC_ID_PCM_MULAW) {
-        bps = 8;
-    } else if (enc->codec_id == CODEC_ID_MP2 || enc->codec_id == CODEC_ID_MP3) {
-        bps = 0;
-    } else if (enc->codec_id == CODEC_ID_ADPCM_IMA_WAV || enc->codec_id == CODEC_ID_ADPCM_MS || enc->codec_id == CODEC_ID_ADPCM_G726 || enc->codec_id == CODEC_ID_ADPCM_YAMAHA) { //
-        bps = 4;
-    } else if (enc->codec_id == CODEC_ID_PCM_S24LE) {
-        bps = 24;
-    } else if (enc->codec_id == CODEC_ID_PCM_S32LE) {
-        bps = 32;
-    } else {
-        bps = 16;
-    }
-
-    if (enc->codec_id == CODEC_ID_MP2 || enc->codec_id == CODEC_ID_MP3) {
-        blkalign = enc->frame_size; //this is wrong, but seems many demuxers dont work if this is set correctly
-        //blkalign = 144 * enc->bit_rate/enc->sample_rate;
-    } else if (enc->codec_id == CODEC_ID_ADPCM_G726) { //
-        blkalign = 1;
-    } else if (enc->block_align != 0) { /* specified by the codec */
-        blkalign = enc->block_align;
-    } else
-        blkalign = enc->channels*bps >> 3;
-    if (enc->codec_id == CODEC_ID_PCM_U8 ||
-        enc->codec_id == CODEC_ID_PCM_S24LE ||
-        enc->codec_id == CODEC_ID_PCM_S32LE ||
-        enc->codec_id == CODEC_ID_PCM_S16LE) {
-        bytespersec = enc->sample_rate * blkalign;
-    } else {
-        bytespersec = enc->bit_rate / 8;
-    }
-    put_le32(pb, bytespersec); /* bytes per second */
-    put_le16(pb, blkalign); /* block align */
-    put_le16(pb, bps); /* bits per sample */
-    if (enc->codec_id == CODEC_ID_MP3) {
-        put_le16(pb, 12); /* wav_extra_size */
-        hdrsize += 12;
-        put_le16(pb, 1); /* wID */
-        put_le32(pb, 2); /* fdwFlags */
-        put_le16(pb, 1152); /* nBlockSize */
-        put_le16(pb, 1); /* nFramesPerBlock */
-        put_le16(pb, 1393); /* nCodecDelay */
-    } else if (enc->codec_id == CODEC_ID_MP2) {
-        put_le16(pb, 22); /* wav_extra_size */
-        hdrsize += 22;
-        put_le16(pb, 2);  /* fwHeadLayer */
-        put_le32(pb, enc->bit_rate); /* dwHeadBitrate */
-        put_le16(pb, enc->channels == 2 ? 1 : 8); /* fwHeadMode */
-        put_le16(pb, 0);  /* fwHeadModeExt */
-        put_le16(pb, 1);  /* wHeadEmphasis */
-        put_le16(pb, 16); /* fwHeadFlags */
-        put_le32(pb, 0);  /* dwPTSLow */
-        put_le32(pb, 0);  /* dwPTSHigh */
-    } else if (enc->codec_id == CODEC_ID_ADPCM_IMA_WAV) {
-        put_le16(pb, 2); /* wav_extra_size */
-        hdrsize += 2;
-        put_le16(pb, ((enc->block_align - 4 * enc->channels) / (4 * enc->channels)) * 8 + 1); /* wSamplesPerBlock */
-    } else if(enc->extradata_size){
-        put_le16(pb, enc->extradata_size);
-        put_buffer(pb, enc->extradata, enc->extradata_size);
-        hdrsize += enc->extradata_size;
-        if(hdrsize&1){
-            hdrsize++;
-            put_byte(pb, 0);
-        }
-    } else {
-        hdrsize -= 2;
-    }
-
-    return hdrsize;
-}
-#endif //CONFIG_MUXERS
-
-/* We could be given one of the three possible structures here:
- * WAVEFORMAT, PCMWAVEFORMAT or WAVEFORMATEX. Each structure
- * is an expansion of the previous one with the fields added
- * at the bottom. PCMWAVEFORMAT adds 'WORD wBitsPerSample' and
- * WAVEFORMATEX adds 'WORD  cbSize' and basically makes itself
- * an openended structure.
- */
-void get_wav_header(ByteIOContext *pb, AVCodecContext *codec, int size)
-{
-    int id;
-
-    id = get_le16(pb);
-    codec->codec_type = CODEC_TYPE_AUDIO;
-    codec->codec_tag = id;
-    codec->channels = get_le16(pb);
-    codec->sample_rate = get_le32(pb);
-    codec->bit_rate = get_le32(pb) * 8;
-    codec->block_align = get_le16(pb);
-    if (size == 14) {  /* We're dealing with plain vanilla WAVEFORMAT */
-        codec->bits_per_sample = 8;
-    }else
-        codec->bits_per_sample = get_le16(pb);
-    codec->codec_id = wav_codec_get_id(id, codec->bits_per_sample);
-
-    if (size > 16) {  /* We're obviously dealing with WAVEFORMATEX */
-        codec->extradata_size = get_le16(pb);
-        if (codec->extradata_size > 0) {
-            if (codec->extradata_size > size - 18)
-                codec->extradata_size = size - 18;
-            codec->extradata = av_mallocz(codec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);
-            get_buffer(pb, codec->extradata, codec->extradata_size);
-        } else
-            codec->extradata_size = 0;
-
-        /* It is possible for the chunk to contain garbage at the end */
-        if (size - codec->extradata_size - 18 > 0)
-            url_fskip(pb, size - codec->extradata_size - 18);
-    }
-}
-
-
-int wav_codec_get_id(unsigned int tag, int bps)
-{
-    int id;
-    id = codec_get_id(codec_wav_tags, tag);
-    if (id <= 0)
-        return id;
-    /* handle specific u8 codec */
-    if (id == CODEC_ID_PCM_S16LE && bps == 8)
-        id = CODEC_ID_PCM_U8;
-    if (id == CODEC_ID_PCM_S16LE && bps == 24)
-        id = CODEC_ID_PCM_S24LE;
-    if (id == CODEC_ID_PCM_S16LE && bps == 32)
-        id = CODEC_ID_PCM_S32LE;
-    return id;
-}
-
-#ifdef CONFIG_MUXERS
 typedef struct {
     offset_t data;
+    offset_t data_end;
 } WAVContext;
 
+#ifdef CONFIG_MUXERS
 static int wav_write_header(AVFormatContext *s)
 {
     WAVContext *wav = s->priv_data;
@@ -299,6 +127,7 @@
     unsigned int tag;
     ByteIOContext *pb = &s->pb;
     AVStream *st;
+    WAVContext *wav = s->priv_data;
 
     /* check RIFF header */
     tag = get_le32(pb);
@@ -326,6 +155,7 @@
     size = find_tag(pb, MKTAG('d', 'a', 't', 'a'));
     if (size < 0)
         return -1;
+    wav->data_end= url_ftell(pb) + size;
     return 0;
 }
 
@@ -334,19 +164,30 @@
 static int wav_read_packet(AVFormatContext *s,
                            AVPacket *pkt)
 {
-    int ret, size;
+    int ret, size, left;
     AVStream *st;
+    WAVContext *wav = s->priv_data;
 
     if (url_feof(&s->pb))
         return AVERROR_IO;
     st = s->streams[0];
 
+    left= wav->data_end - url_ftell(&s->pb);
+    if(left <= 0){
+        left = find_tag(&(s->pb), MKTAG('d', 'a', 't', 'a'));
+        if (left < 0) {
+            return AVERROR_IO;
+        }
+        wav->data_end= url_ftell(&s->pb) + left;
+    }
+
     size = MAX_SIZE;
     if (st->codec->block_align > 1) {
         if (size < st->codec->block_align)
             size = st->codec->block_align;
         size = (size / st->codec->block_align) * st->codec->block_align;
     }
+    size= FFMIN(size, left);
     if (av_new_packet(pkt, size))
         return AVERROR_IO;
     pkt->stream_index = 0;
@@ -381,24 +222,24 @@
     default:
         break;
     }
-    // meanx return pcm_read_seek(s, stream_index, timestamp, flags);
-        return -1;
+    return pcm_read_seek(s, stream_index, timestamp, flags);
 }
 
-
-static AVInputFormat wav_iformat = {
+#ifdef CONFIG_WAV_DEMUXER
+AVInputFormat wav_demuxer = {
     "wav",
     "wav format",
-    0,
+    sizeof(WAVContext),
     wav_probe,
     wav_read_header,
     wav_read_packet,
     wav_read_close,
     wav_read_seek,
+    .codec_tag= {codec_wav_tags},
 };
-
-#ifdef CONFIG_MUXERS
-static AVOutputFormat wav_oformat = {
+#endif
+#ifdef CONFIG_WAV_MUXER
+AVOutputFormat wav_muxer = {
     "wav",
     "wav format",
     "audio/x-wav",
@@ -409,14 +250,6 @@
     wav_write_header,
     wav_write_packet,
     wav_write_trailer,
+    .codec_tag= {codec_wav_tags},
 };
-#endif //CONFIG_MUXERS
-
-int ff_wav_init(void)
-{
-    av_register_input_format(&wav_iformat);
-#ifdef CONFIG_MUXERS
-    av_register_output_format(&wav_oformat);
-#endif //CONFIG_MUXERS
-    return 0;
-}
+#endif



From mean at mail.berlios.de  Sun Jan 21 19:04:59 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 21 Jan 2007 19:04:59 +0100
Subject: [Avidemux-svn-commit] r2748 -
	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil
Message-ID: <200701211804.l0LI4x16030321@sheep.berlios.de>

Author: mean
Date: 2007-01-21 19:04:51 +0100 (Sun, 21 Jan 2007)
New Revision: 2748

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/fifo.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/fifo.h
Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/Makefile.am
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/adler32.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/adler32.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/avutil.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/bswap.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/common.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/crc.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/crc.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/integer.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/integer.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/internal.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/intfloat_readwrite.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/intfloat_readwrite.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/lls.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/lls.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/log.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/log.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/mathematics.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/mathematics.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/md5.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/md5.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/mem.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/rational.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/rational.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/x86_cpu.h
Log:
update to ffmpeg svn

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/Makefile.am	2007-01-21 18:04:24 UTC (rev 2747)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/Makefile.am	2007-01-21 18:04:51 UTC (rev 2748)
@@ -10,7 +10,8 @@
 EXTRA_DIST = avutil.h  common.h  integer.h   \
 mathematics.h  rational.h \
 bswap.h crc.h   intfloat_readwrite.h  md5.h    x86_cpu.h log.c \
-lls.h adler32.h adler32.c mem.c internal.h log.h lls.c
+lls.h adler32.h adler32.c mem.c internal.h log.h lls.c \
+fifo.c crc.c 
 
 
 ####### kdevelop will overwrite this part!!! (end)############

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/adler32.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/adler32.c	2007-01-21 18:04:24 UTC (rev 2747)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/adler32.c	2007-01-21 18:04:51 UTC (rev 2748)
@@ -1,6 +1,24 @@
 /* adler32.c -- compute the Adler-32 checksum of a data stream
+ * This is a modified version based on adler32.c from the zlib library.
+ *
  * Copyright (C) 1995 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
+ *
+ * This software is provided 'as-is', without any express or implied
+ * warranty.  In no event will the authors be held liable for any damages
+ * arising from the use of this software.
+ *
+ * Permission is granted to anyone to use this software for any purpose,
+ * including commercial applications, and to alter it and redistribute it
+ * freely, subject to the following restrictions:
+ *
+ * 1. The origin of this software must not be misrepresented; you must not
+ *    claim that you wrote the original software. If you use this software
+ *    in a product, an acknowledgment in the product documentation would be
+ *    appreciated but is not required.
+ * 2. Altered source versions must be plainly marked as such, and must not be
+ *    misrepresented as being the original software.
+ * 3. This notice may not be removed or altered from any source distribution.
+ *
  */
 
 #include "common.h"

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/adler32.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/adler32.h	2007-01-21 18:04:24 UTC (rev 2747)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/adler32.h	2007-01-21 18:04:51 UTC (rev 2748)
@@ -1,3 +1,23 @@
+/*
+ * copyright (c) 2006 Mans Rullgard
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
 #ifndef ADLER32_H
 #define ADLER32_H
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/avutil.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/avutil.h	2007-01-21 18:04:24 UTC (rev 2747)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/avutil.h	2007-01-21 18:04:51 UTC (rev 2748)
@@ -1,18 +1,20 @@
 /*
  * copyright (c) 2006 Michael Niedermayer <michaelni at gmx.at>
  *
- * This library is free software; you can redistribute it and/or
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
+ * version 2.1 of the License, or (at your option) any later version.
  *
- * This library is distributed in the hope that it will be useful,
+ * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
+ * License along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
@@ -33,11 +35,12 @@
 	#define ASMALIGN(ZEROBITS) ".align 1<<" #ZEROBITS "\n\t" 
 /* /MEANX
  */
+
 #define AV_STRINGIFY(s)         AV_TOSTRING(s)
 #define AV_TOSTRING(s) #s
 
-#define LIBAVUTIL_VERSION_INT   ((49<<16)+(0<<8)+0)
-#define LIBAVUTIL_VERSION       49.0.0
+#define LIBAVUTIL_VERSION_INT   ((49<<16)+(2<<8)+0)
+#define LIBAVUTIL_VERSION       49.2.0
 #define LIBAVUTIL_BUILD         LIBAVUTIL_VERSION_INT
 
 #define LIBAVUTIL_IDENT         "Lavu" AV_STRINGIFY(LIBAVUTIL_VERSION)
@@ -80,7 +83,7 @@
     PIX_FMT_YUV410P,   ///< Planar YUV 4:1:0,  9bpp, (1 Cr & Cb sample per 4x4 Y samples)
     PIX_FMT_YUV411P,   ///< Planar YUV 4:1:1, 12bpp, (1 Cr & Cb sample per 4x1 Y samples)
     PIX_FMT_RGB565,    ///< Packed RGB 5:6:5, 16bpp, (msb)   5R 6G 5B(lsb), in cpu endianness
-    PIX_FMT_RGB555,    ///< Packed RGB 5:5:5, 16bpp, (msb)1A 5R 5G 5B(lsb), in cpu endianness most significant bit to 1
+    PIX_FMT_RGB555,    ///< Packed RGB 5:5:5, 16bpp, (msb)1A 5R 5G 5B(lsb), in cpu endianness most significant bit to 0
     PIX_FMT_GRAY8,     ///<        Y        ,  8bpp
     PIX_FMT_MONOWHITE, ///<        Y        ,  1bpp, 1 is white
     PIX_FMT_MONOBLACK, ///<        Y        ,  1bpp, 0 is black
@@ -106,10 +109,9 @@
 
     PIX_FMT_RGB32_1,   ///< Packed RGB 8:8:8, 32bpp, (msb)8R 8G 8B 8A(lsb), in cpu endianness
     PIX_FMT_BGR32_1,   ///< Packed RGB 8:8:8, 32bpp, (msb)8B 8G 8R 8A(lsb), in cpu endianness
-  
+
     PIX_FMT_GRAY16BE,  ///<        Y        , 16bpp, big-endian
     PIX_FMT_GRAY16LE,  ///<        Y        , 16bpp, little-endian
-
     PIX_FMT_NB,        ///< number of pixel formats, DO NOT USE THIS if you want to link with shared libav* because the number of formats might differ between versions
 };
 
@@ -118,11 +120,13 @@
 #define PIX_FMT_BGRA PIX_FMT_BGR32_1
 #define PIX_FMT_ARGB PIX_FMT_RGB32
 #define PIX_FMT_ABGR PIX_FMT_BGR32
+#define PIX_FMT_GRAY16 PIX_FMT_GRAY16BE
 #else
 #define PIX_FMT_RGBA PIX_FMT_BGR32
 #define PIX_FMT_BGRA PIX_FMT_RGB32
 #define PIX_FMT_ARGB PIX_FMT_BGR32_1
 #define PIX_FMT_ABGR PIX_FMT_RGB32_1
+#define PIX_FMT_GRAY16 PIX_FMT_GRAY16LE
 #endif
 
 #if LIBAVUTIL_VERSION_INT < (50<<16)

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/bswap.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/bswap.h	2007-01-21 18:04:24 UTC (rev 2747)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/bswap.h	2007-01-21 18:04:51 UTC (rev 2748)
@@ -1,3 +1,23 @@
+/*
+ * copyright (c) 2006 Michael Niedermayer <michaelni at gmx.at>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
 /**
  * @file bswap.h
  * byte swap.
@@ -16,8 +36,8 @@
 #  define LEGACY_REGS "=q"
 #endif
 
-#if defined(ARCH_X86) || defined(ARCH_X86_64)
-static always_inline uint16_t bswap_16(uint16_t x)
+#if defined(ARCH_X86)
+static av_always_inline uint16_t bswap_16(uint16_t x)
 {
   __asm("rorw $8, %0"   :
         LEGACY_REGS (x) :
@@ -25,7 +45,7 @@
     return x;
 }
 
-static always_inline uint32_t bswap_32(uint32_t x)
+static av_always_inline uint32_t bswap_32(uint32_t x)
 {
 #if __CPU__ != 386
  __asm("bswap   %0":
@@ -62,12 +82,12 @@
 
 #elif defined(ARCH_SH4)
 
-static always_inline uint16_t bswap_16(uint16_t x) {
+static av_always_inline uint16_t bswap_16(uint16_t x) {
         __asm__("swap.b %0,%0":"=r"(x):"0"(x));
         return x;
 }
 
-static always_inline uint32_t bswap_32(uint32_t x) {
+static av_always_inline uint32_t bswap_32(uint32_t x) {
         __asm__(
         "swap.b %0,%0\n"
         "swap.w %0,%0\n"
@@ -90,12 +110,12 @@
 }
 #else
 
-static always_inline uint16_t bswap_16(uint16_t x){
+static av_always_inline uint16_t bswap_16(uint16_t x){
     return (x>>8) | (x<<8);
 }
 
 #ifdef ARCH_ARM
-static always_inline uint32_t bswap_32(uint32_t x){
+static av_always_inline uint32_t bswap_32(uint32_t x){
     uint32_t t;
     __asm__ (
       "eor %1, %0, %0, ror #16 \n\t"
@@ -106,7 +126,7 @@
     return x;
 }
 #else
-static always_inline uint32_t bswap_32(uint32_t x){
+static av_always_inline uint32_t bswap_32(uint32_t x){
     x= ((x<<8)&0xFF00FF00) | ((x>>8)&0x00FF00FF);
     return (x>>16) | (x<<16);
 }
@@ -129,7 +149,7 @@
     return r.ll;
 #endif
 }
-#endif  /* !ARCH_X86 */
+#endif  /* defined(ARCH_X86) */
 
 #endif  /* !HAVE_BYTESWAP_H */
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/common.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/common.h	2007-01-21 18:04:24 UTC (rev 2747)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/common.h	2007-01-21 18:04:51 UTC (rev 2748)
@@ -1,3 +1,23 @@
+/*
+ * copyright (c) 2006 Michael Niedermayer <michaelni at gmx.at>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
 /**
  * @file common.h
  * common internal and external api header.
@@ -6,9 +26,7 @@
 #ifndef COMMON_H
 #define COMMON_H
 
-#ifndef M_PI
-#define M_PI    3.14159265358979323846
-#endif
+#include <inttypes.h>
 
 #ifdef HAVE_AV_CONFIG_H
 /* only include the following when compiling package */
@@ -27,155 +45,45 @@
 #    include <math.h>
 #endif /* HAVE_AV_CONFIG_H */
 
-/* Suppress restrict if it was not defined in config.h.  */
-#ifndef restrict
-#    define restrict
-#endif
-
-#ifndef always_inline
+#ifndef av_always_inline
 #if defined(__GNUC__) && (__GNUC__ > 3 || __GNUC__ == 3 && __GNUC_MINOR__ > 0)
-#    define always_inline __attribute__((always_inline)) inline
+#    define av_always_inline __attribute__((always_inline)) inline
 #else
-#    define always_inline inline
+#    define av_always_inline inline
 #endif
 #endif
 
-#ifndef attribute_used
-#if defined(__GNUC__) && (__GNUC__ > 3 || __GNUC__ == 3 && __GNUC_MINOR__ > 0)
-#    define attribute_used __attribute__((used))
-#else
-#    define attribute_used
-#endif
-#endif
+#ifdef HAVE_AV_CONFIG_H
+#    include "internal.h"
+#endif /* HAVE_AV_CONFIG_H */
 
-#ifndef attribute_unused
+#ifndef attribute_deprecated
 #if defined(__GNUC__) && (__GNUC__ > 3 || __GNUC__ == 3 && __GNUC_MINOR__ > 0)
-#    define attribute_unused __attribute__((unused))
+#    define attribute_deprecated __attribute__((deprecated))
 #else
-#    define attribute_unused
+#    define attribute_deprecated
 #endif
 #endif
 
-#ifndef EMULATE_INTTYPES
-#   include <inttypes.h>
-#else
-    typedef signed char  int8_t;
-    typedef signed short int16_t;
-    typedef signed int   int32_t;
-    typedef unsigned char  uint8_t;
-    typedef unsigned short uint16_t;
-    typedef unsigned int   uint32_t;
-    typedef signed long long   int64_t;
-    typedef unsigned long long uint64_t;
-#endif /* EMULATE_INTTYPES */
-
-#ifndef PRId64
-#define PRId64 "lld"
+#ifndef INT64_C
+#define INT64_C(c)     (c ## LL)
+#define UINT64_C(c)    (c ## ULL)
 #endif
 
-#ifndef PRIu64
-#define PRIu64 "llu"
-#endif
-
-#ifndef PRIx64
-#define PRIx64 "llx"
-#endif
-
-#ifndef PRId32
-#define PRId32 "d"
-#endif
-
-#ifndef PRIdFAST16
-#define PRIdFAST16 PRId32
-#endif
-
-#ifndef PRIdFAST32
-#define PRIdFAST32 PRId32
-#endif
-
-#ifndef INT16_MIN
-#define INT16_MIN       (-0x7fff-1)
-#endif
-
-#ifndef INT16_MAX
-#define INT16_MAX       0x7fff
-#endif
-
-#ifndef INT32_MIN
-#define INT32_MIN       (-0x7fffffff-1)
-#endif
-
-#ifndef INT32_MAX
-#define INT32_MAX       0x7fffffff
-#endif
-
-#ifndef UINT32_MAX
-#define UINT32_MAX      0xffffffff
-#endif
-
-#ifndef INT64_MIN
-#define INT64_MIN       (-0x7fffffffffffffffLL-1)
-#endif
-
-#ifndef INT64_MAX
-#define INT64_MAX int64_t_C(9223372036854775807)
-#endif
-
-#ifndef UINT64_MAX
-#define UINT64_MAX uint64_t_C(0xFFFFFFFFFFFFFFFF)
-#endif
-
-#ifdef EMULATE_FAST_INT
-typedef signed char int_fast8_t;
-typedef signed int  int_fast16_t;
-typedef signed int  int_fast32_t;
-typedef unsigned char uint_fast8_t;
-typedef unsigned int  uint_fast16_t;
-typedef unsigned int  uint_fast32_t;
-typedef uint64_t      uint_fast64_t;
-#endif
-
-#ifndef INT_BIT
-#    if INT_MAX != 2147483647
-#        define INT_BIT 64
-#    else
-#        define INT_BIT 32
-#    endif
-#endif
-
-#ifndef int64_t_C
-#define int64_t_C(c)     (c ## LL)
-#define uint64_t_C(c)    (c ## ULL)
-#endif
-
-#if defined(__MINGW32__) && !defined(BUILD_AVUTIL) && defined(BUILD_SHARED_AV)
-#  define FF_IMPORT_ATTR __declspec(dllimport)
-#else
-#  define FF_IMPORT_ATTR
-#endif
-
-
-#ifdef HAVE_AV_CONFIG_H
-/* only include the following when compiling package */
-#    include "internal.h"
-#endif
-
 //rounded divison & shift
 #define RSHIFT(a,b) ((a) > 0 ? ((a) + ((1<<(b))>>1))>>(b) : ((a) + ((1<<(b))>>1)-1)>>(b))
 /* assume b>0 */
 #define ROUNDED_DIV(a,b) (((a)>0 ? (a) + ((b)>>1) : (a) - ((b)>>1))/(b))
-/* MEANX */
-#ifdef ABS
-#undef ABS
-#endif
-/* MEANX */
-#define ABS(a) ((a) >= 0 ? (a) : (-(a)))
+#define FFABS(a) ((a) >= 0 ? (a) : (-(a)))
+#define FFSIGN(a) ((a) > 0 ? 1 : -1)
 
 #define FFMAX(a,b) ((a) > (b) ? (a) : (b))
 #define FFMIN(a,b) ((a) > (b) ? (b) : (a))
 
+#define FFSWAP(type,a,b) do{type SWAP_tmp= b; b= a; a= SWAP_tmp;}while(0)
+
 /* misc math functions */
-extern FF_IMPORT_ATTR const uint8_t ff_log2_tab[256];
+extern const uint8_t ff_log2_tab[256];
 
 static inline int av_log2(unsigned int v)
 {
@@ -212,7 +120,21 @@
 /* median of 3 */
 static inline int mid_pred(int a, int b, int c)
 {
-#if 0
+#ifdef HAVE_CMOV
+    int i=b;
+    asm volatile(
+        "cmp    %2, %1 \n\t"
+        "cmovg  %1, %0 \n\t"
+        "cmovg  %2, %1 \n\t"
+        "cmp    %3, %1 \n\t"
+        "cmovl  %3, %1 \n\t"
+        "cmp    %1, %0 \n\t"
+        "cmovg  %1, %0 \n\t"
+        :"+&r"(i), "+&r"(a)
+        :"r"(b), "r"(c)
+    );
+    return i;
+#elif 0
     int t= (a-b)&((a-b)>>31);
     a-=t;
     b+=t;
@@ -241,7 +163,7 @@
  * @param a value to clip
  * @param amin minimum value of the clip range
  * @param amax maximum value of the clip range
- * @return cliped value
+ * @return clipped value
  */
 static inline int clip(int a, int amin, int amax)
 {
@@ -253,7 +175,7 @@
 /**
  * clip a signed integer value into the 0-255 range
  * @param a value to clip
- * @return cliped value
+ * @return clipped value
  */
 static inline uint8_t clip_uint8(int a)
 {
@@ -278,7 +200,19 @@
 #define MKTAG(a,b,c,d) (a | (b << 8) | (c << 16) | (d << 24))
 #define MKBETAG(a,b,c,d) (d | (c << 8) | (b << 16) | (a << 24))
 
-
+/*!
+ * \def GET_UTF8(val, GET_BYTE, ERROR)
+ * converts a utf-8 character (up to 4 bytes long) to its 32-bit ucs-4 encoded form
+ * \param val is the output and should be of type uint32_t. It holds the converted
+ * ucs-4 character and should be a left value.
+ * \param GET_BYTE gets utf-8 encoded bytes from any proper source. It can be
+ * a function or a statement whose return value or evaluated value is of type
+ * uint8_t. It will be executed up to 4 times for values in the valid utf-8 range,
+ * and up to 7 times in the general case.
+ * \param ERROR action that should be taken when an invalid utf-8 byte is returned
+ * from GET_BYTE. It should be a statement that jumps out of the macro,
+ * like exit(), goto, return, break, or continue.
+ */
 #define GET_UTF8(val, GET_BYTE, ERROR)\
     val= GET_BYTE;\
     {\
@@ -294,7 +228,43 @@
         }\
     }
 
-#if defined(ARCH_X86) || defined(ARCH_X86_64) || defined(ARCH_POWERPC)
+/*!
+ * \def PUT_UTF8(val, tmp, PUT_BYTE)
+ * converts a 32-bit unicode character to its utf-8 encoded form (up to 4 bytes long).
+ * \param val is an input only argument and should be of type uint32_t. It holds
+ * a ucs4 encoded unicode character that is to be converted to utf-8. If
+ * val is given as a function it's executed only once.
+ * \param tmp is a temporary variable and should be of type uint8_t. It
+ * represents an intermediate value during conversion that is to be
+ * outputted by PUT_BYTE.
+ * \param PUT_BYTE writes the converted utf-8 bytes to any proper destination.
+ * It could be a function or a statement, and uses tmp as the input byte.
+ * For example, PUT_BYTE could be "*output++ = tmp;" PUT_BYTE will be
+ * executed up to 4 times for values in the valid utf-8 range and up to
+ * 7 times in the general case, depending on the length of the converted
+ * unicode character.
+ */
+#define PUT_UTF8(val, tmp, PUT_BYTE)\
+    {\
+        int bytes, shift;\
+        uint32_t in = val;\
+        if (in < 0x80) {\
+            tmp = in;\
+            PUT_BYTE\
+        } else {\
+            bytes = (av_log2(in) + 4) / 5;\
+            shift = (bytes - 1) * 6;\
+            tmp = (256 - (256 >> bytes)) | (in >> shift);\
+            PUT_BYTE\
+            while (shift >= 6) {\
+                shift -= 6;\
+                tmp = 0x80 | ((in >> shift) & 0x3f);\
+                PUT_BYTE\
+            }\
+        }\
+    }
+
+#if defined(ARCH_X86) || defined(ARCH_POWERPC)
 #if defined(ARCH_X86_64)
 static inline uint64_t read_time(void)
 {
@@ -304,7 +274,7 @@
         );
         return (d << 32) | (a & 0xffffffff);
 }
-#elif defined(ARCH_X86)
+#elif defined(ARCH_X86_32)
 static inline long long read_time(void)
 {
         long long l;
@@ -349,7 +319,7 @@
       tcount++;\
   }else\
       tskip_count++;\
-  if(256*256*256*64%(tcount+tskip_count)==0){\
+  if(((tcount+tskip_count)&(tcount+tskip_count-1))==0){\
       av_log(NULL, AV_LOG_DEBUG, "%"PRIu64" dezicycles in %s, %d runs, %d skips\n", tsum*10/tcount, id, tcount, tskip_count);\
   }\
 }
@@ -359,8 +329,20 @@
 #endif
 
 /* memory */
+
+#ifdef __GNUC__
+  #define DECLARE_ALIGNED(n,t,v)       t v __attribute__ ((aligned (n)))
+#else
+  #define DECLARE_ALIGNED(n,t,v)      __declspec(align(n)) t v
+#endif
+
+/* memory */
 void *av_malloc(unsigned int size);
 void *av_realloc(void *ptr, unsigned int size);
 void av_free(void *ptr);
 
+void *av_mallocz(unsigned int size);
+char *av_strdup(const char *s);
+void av_freep(void *ptr);
+
 #endif /* COMMON_H */

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/crc.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/crc.c	2007-01-21 18:04:24 UTC (rev 2747)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/crc.c	2007-01-21 18:04:51 UTC (rev 2748)
@@ -1,3 +1,23 @@
+/*
+ * copyright (c) 2006 Michael Niedermayer <michaelni at gmx.at>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
 #include "common.h"
 #include "crc.h"
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/crc.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/crc.h	2007-01-21 18:04:24 UTC (rev 2747)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/crc.h	2007-01-21 18:04:51 UTC (rev 2748)
@@ -1,3 +1,23 @@
+/*
+ * copyright (c) 2006 Michael Niedermayer <michaelni at gmx.at>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
 #ifndef CRC_H
 #define CRC_H
 

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/fifo.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/fifo.c	2007-01-21 18:04:24 UTC (rev 2747)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/fifo.c	2007-01-21 18:04:51 UTC (rev 2748)
@@ -0,0 +1,114 @@
+/*
+ * A very simple circular buffer FIFO implementation
+ * Copyright (c) 2000, 2001, 2002 Fabrice Bellard
+ * Copyright (c) 2006 Roman Shaposhnik
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+#include "common.h"
+#include "fifo.h"
+
+int av_fifo_init(AVFifoBuffer *f, int size)
+{
+    f->wptr = f->rptr =
+    f->buffer = av_malloc(size);
+    f->end = f->buffer + size;
+    if (!f->buffer)
+        return -1;
+    return 0;
+}
+
+void av_fifo_free(AVFifoBuffer *f)
+{
+    av_free(f->buffer);
+}
+
+int av_fifo_size(AVFifoBuffer *f)
+{
+    int size = f->wptr - f->rptr;
+    if (size < 0)
+        size += f->end - f->buffer;
+    return size;
+}
+
+/**
+ * Get data from the fifo (returns -1 if not enough data).
+ */
+int av_fifo_read(AVFifoBuffer *f, uint8_t *buf, int buf_size)
+{
+    return av_fifo_generic_read(f, buf_size, NULL, buf);
+}
+
+/**
+ * Resizes a FIFO.
+ */
+void av_fifo_realloc(AVFifoBuffer *f, unsigned int new_size) {
+    unsigned int old_size= f->end - f->buffer;
+
+    if(old_size < new_size){
+        int len= av_fifo_size(f);
+        AVFifoBuffer f2;
+
+        av_fifo_init(&f2, new_size);
+        av_fifo_read(f, f2.buffer, len);
+        f2.wptr += len;
+        av_free(f->buffer);
+        *f= f2;
+    }
+}
+
+void av_fifo_write(AVFifoBuffer *f, const uint8_t *buf, int size)
+{
+    do {
+        int len = FFMIN(f->end - f->wptr, size);
+        memcpy(f->wptr, buf, len);
+        f->wptr += len;
+        if (f->wptr >= f->end)
+            f->wptr = f->buffer;
+        buf += len;
+        size -= len;
+    } while (size > 0);
+}
+
+
+/** get data from the fifo (return -1 if not enough data) */
+int av_fifo_generic_read(AVFifoBuffer *f, int buf_size, void (*func)(void*, void*, int), void* dest)
+{
+    int size = av_fifo_size(f);
+
+    if (size < buf_size)
+        return -1;
+    do {
+        int len = FFMIN(f->end - f->rptr, buf_size);
+        if(func) func(dest, f->rptr, len);
+        else{
+            memcpy(dest, f->rptr, len);
+            dest = (uint8_t*)dest + len;
+        }
+        av_fifo_drain(f, len);
+        buf_size -= len;
+    } while (buf_size > 0);
+    return 0;
+}
+
+/** discard data from the fifo */
+void av_fifo_drain(AVFifoBuffer *f, int size)
+{
+    f->rptr += size;
+    if (f->rptr >= f->end)
+        f->rptr -= f->end - f->buffer;
+}

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/fifo.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/fifo.h	2007-01-21 18:04:24 UTC (rev 2747)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/fifo.h	2007-01-21 18:04:51 UTC (rev 2748)
@@ -0,0 +1,25 @@
+#ifndef FIFO_H
+#define FIFO_H
+
+typedef struct AVFifoBuffer {
+    uint8_t *buffer;
+    uint8_t *rptr, *wptr, *end;
+} AVFifoBuffer;
+
+int av_fifo_init(AVFifoBuffer *f, int size);
+void av_fifo_free(AVFifoBuffer *f);
+int av_fifo_size(AVFifoBuffer *f);
+int av_fifo_read(AVFifoBuffer *f, uint8_t *buf, int buf_size);
+int av_fifo_generic_read(AVFifoBuffer *f, int buf_size, void (*func)(void*, void*, int), void* dest);
+void av_fifo_write(AVFifoBuffer *f, const uint8_t *buf, int size);
+void av_fifo_realloc(AVFifoBuffer *f, unsigned int size);
+void av_fifo_drain(AVFifoBuffer *f, int size);
+
+static inline uint8_t av_fifo_peek(AVFifoBuffer *f, int offs)
+{
+    uint8_t *ptr = f->rptr + offs;
+    if (ptr >= f->end)
+        ptr -= f->end - f->buffer;
+    return *ptr;
+}
+#endif /* FIFO_H */

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/integer.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/integer.c	2007-01-21 18:04:24 UTC (rev 2747)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/integer.c	2007-01-21 18:04:51 UTC (rev 2748)
@@ -2,18 +2,20 @@
  * arbitrary precision integers
  * Copyright (c) 2004 Michael Niedermayer <michaelni at gmx.at>
  *
- * This library is free software; you can redistribute it and/or
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
+ * version 2.1 of the License, or (at your option) any later version.
  *
- * This library is distributed in the hope that it will be useful,
+ * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
+ * License along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  *
  */

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/integer.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/integer.h	2007-01-21 18:04:24 UTC (rev 2747)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/integer.h	2007-01-21 18:04:51 UTC (rev 2748)
@@ -2,18 +2,20 @@
  * arbitrary precision integers
  * Copyright (c) 2004 Michael Niedermayer <michaelni at gmx.at>
  *
- * This library is free software; you can redistribute it and/or
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
+ * version 2.1 of the License, or (at your option) any later version.
  *
- * This library is distributed in the hope that it will be useful,
+ * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
+ * License along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  *
  */

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/internal.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/internal.h	2007-01-21 18:04:24 UTC (rev 2747)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/internal.h	2007-01-21 18:04:51 UTC (rev 2748)
@@ -1,3 +1,23 @@
+/*
+ * copyright (c) 2006 Michael Niedermayer <michaelni at gmx.at>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
 /**
  * @file internal.h
  * common internal api header.
@@ -6,36 +26,110 @@
 #ifndef INTERNAL_H
 #define INTERNAL_H
 
+#ifndef attribute_used
+#if defined(__GNUC__) && (__GNUC__ > 3 || __GNUC__ == 3 && __GNUC_MINOR__ > 0)
+#    define attribute_used __attribute__((used))
+#else
+#    define attribute_used
+#endif
+#endif
+
+#ifndef attribute_unused
+#if defined(__GNUC__)
+#    define attribute_unused __attribute__((unused))
+#else
+#    define attribute_unused
+#endif
+#endif
+
+#ifndef M_PI
+#define M_PI    3.14159265358979323846
+#endif
+
+#ifndef PRId64
+#define PRId64 "lld"
+#endif
+
+#ifndef PRIu64
+#define PRIu64 "llu"
+#endif
+
+#ifndef PRIx64
+#define PRIx64 "llx"
+#endif
+
+#ifndef PRIX64
+#define PRIX64 "llX"
+#endif
+
+#ifndef PRId32
+#define PRId32 "d"
+#endif
+
+#ifndef PRIdFAST16
+#define PRIdFAST16 PRId32
+#endif
+
+#ifndef PRIdFAST32
+#define PRIdFAST32 PRId32
+#endif
+
+#ifndef INT16_MIN
+#define INT16_MIN       (-0x7fff-1)
+#endif
+
+#ifndef INT16_MAX
+#define INT16_MAX       0x7fff
+#endif
+
+#ifndef INT32_MIN
+#define INT32_MIN       (-0x7fffffff-1)
+#endif
+
+#ifndef INT32_MAX
+#define INT32_MAX       0x7fffffff
+#endif
+
+#ifndef UINT32_MAX
+#define UINT32_MAX      0xffffffff
+#endif
+
+#ifndef INT64_MIN
+#define INT64_MIN       (-0x7fffffffffffffffLL-1)
+#endif
+
+#ifndef INT64_MAX
+#define INT64_MAX INT64_C(9223372036854775807)
+#endif
+
+#ifndef UINT64_MAX
+#define UINT64_MAX UINT64_C(0xFFFFFFFFFFFFFFFF)
+#endif
+
+#ifndef INT_BIT
+#    if INT_MAX != 2147483647
+#        define INT_BIT 64
+#    else
+#        define INT_BIT 32
+#    endif
+#endif
+
 #if ( defined(__PIC__) || defined(__pic__) ) && ! defined(PIC)
 #    define PIC
 #endif
 
-#    ifndef ENODATA
-#        define ENODATA  61
-#    endif
+#ifndef ENODATA
+#    define ENODATA  61
+#endif
 
+#include "intreadwrite.h"
 #include "bswap.h"
 
 #include <stddef.h>
 #ifndef offsetof
-# define offsetof(T,F) ((unsigned int)((char *)&((T *)0)->F))
+#    define offsetof(T,F) ((unsigned int)((char *)&((T *)0)->F))
 #endif
 
-#define AVOPTION_CODEC_BOOL(name, help, field) \
-    { name, help, offsetof(AVCodecContext, field), FF_OPT_TYPE_BOOL }
-#define AVOPTION_CODEC_DOUBLE(name, help, field, minv, maxv, defval) \
-    { name, help, offsetof(AVCodecContext, field), FF_OPT_TYPE_DOUBLE, minv, maxv, defval }
-#define AVOPTION_CODEC_FLAG(name, help, field, flag, defval) \
-    { name, help, offsetof(AVCodecContext, field), FF_OPT_TYPE_FLAG, flag, 0, defval }
-#define AVOPTION_CODEC_INT(name, help, field, minv, maxv, defval) \
-    { name, help, offsetof(AVCodecContext, field), FF_OPT_TYPE_INT, minv, maxv, defval }
-#define AVOPTION_CODEC_STRING(name, help, field, str, val) \
-    { name, help, offsetof(AVCodecContext, field), FF_OPT_TYPE_STRING, .defval = val, .defstr = str }
-#define AVOPTION_CODEC_RCOVERRIDE(name, help, field) \
-    { name, help, offsetof(AVCodecContext, field), FF_OPT_TYPE_RCOVERRIDE, .defval = 0, .defstr = NULL }
-#define AVOPTION_SUB(ptr) { .name = NULL, .help = (const char*)ptr }
-#define AVOPTION_END() AVOPTION_SUB(NULL)
-
 #ifdef __MINGW32__
 #    ifdef _DEBUG
 #        define DEBUG
@@ -46,79 +140,88 @@
 
 #    ifdef CONFIG_WINCE
 #        define perror(a)
+#        define abort()
 #    endif
 
 /* __MINGW32__ end */
 #elif defined (CONFIG_OS2)
 /* OS/2 EMX */
 
-#include <float.h>
+#    include <float.h>
 
 #endif /* !__MINGW32__ && CONFIG_OS2 */
 
-#    ifdef USE_FASTMEMCPY
-#        include "fastmemcpy.h"
-#    endif
+#ifdef USE_FASTMEMCPY
+#    include "libvo/fastmemcpy.h"
+#endif
 
 // Use rip-relative addressing if compiling PIC code on x86-64.
-#    if defined(__MINGW32__) || defined(__CYGWIN__) || \
-        defined(__OS2__) || (defined (__OpenBSD__) && !defined(__ELF__))
-#        if defined(ARCH_X86_64) && defined(PIC)
-#            define MANGLE(a) "_" #a"(%%rip)"
-#        else
-#            define MANGLE(a) "_" #a
-#        endif
+#if defined(__MINGW32__) || defined(__CYGWIN__) || \
+    defined(__OS2__) || (defined (__OpenBSD__) && !defined(__ELF__))
+#    if defined(ARCH_X86_64) && defined(PIC)
+#        define MANGLE(a) "_" #a"(%%rip)"
 #    else
-#        if defined(ARCH_X86_64) && defined(PIC)
-#            define MANGLE(a) #a"(%%rip)"
-#        elif defined(CONFIG_DARWIN)
-#            define MANGLE(a) "_" #a
-#        else
-#            define MANGLE(a) #a
-#        endif
+#        define MANGLE(a) "_" #a
 #    endif
+#else
+#    if defined(ARCH_X86_64) && defined(PIC)
+#        define MANGLE(a) #a"(%%rip)"
+#    elif defined(CONFIG_DARWIN)
+#        define MANGLE(a) "_" #a
+#    else
+#        define MANGLE(a) #a
+#    endif
+#endif
 
 /* debug stuff */
 
-#    if !defined(DEBUG) && !defined(NDEBUG)
-#        define NDEBUG
-#    endif
-#    include <assert.h>
+#if !defined(DEBUG) && !defined(NDEBUG)
+#    define NDEBUG
+#endif
+#include <assert.h>
 
 /* dprintf macros */
-#    ifdef DEBUG
-#        define dprintf(fmt,...) av_log(NULL, AV_LOG_DEBUG, fmt, __VA_ARGS__)
-#    else
-#        define dprintf(fmt,...)
-#    endif
+#ifdef DEBUG
+#    define dprintf(fmt,...) av_log(NULL, AV_LOG_DEBUG, fmt, __VA_ARGS__)
+#else
+#    define dprintf(fmt,...)
+#endif
 
-#    ifdef CONFIG_WINCE
-#            define abort()
-#    endif
+#define av_abort()      do { av_log(NULL, AV_LOG_ERROR, "Abort at %s:%d\n", __FILE__, __LINE__); abort(); } while (0)
 
-#    define av_abort()      do { av_log(NULL, AV_LOG_ERROR, "Abort at %s:%d\n", __FILE__, __LINE__); abort(); } while (0)
+/* math */
 
-extern const uint32_t inverse[256];
+extern const uint32_t ff_inverse[256];
 
-#if defined(ARCH_X86) || defined(ARCH_X86_64)
+#if defined(ARCH_X86)
 #    define FASTDIV(a,b) \
     ({\
         int ret,dmy;\
         asm volatile(\
             "mull %3"\
             :"=d"(ret),"=a"(dmy)\
-            :"1"(a),"g"(inverse[b])\
+            :"1"(a),"g"(ff_inverse[b])\
             );\
         ret;\
     })
+#elif defined(ARCH_ARMV4L)
+#    define FASTDIV(a,b) \
+    ({\
+        int ret,dmy;\
+        asm volatile(\
+            "umull %1, %0, %2, %3"\
+            :"=&r"(ret),"=&r"(dmy)\
+            :"r"(a),"r"(ff_inverse[b])\
+            );\
+        ret;\
+    })
 #elif defined(CONFIG_FASTDIV)
-#    define FASTDIV(a,b)   ((uint32_t)((((uint64_t)a)*inverse[b])>>32))
+#    define FASTDIV(a,b)   ((uint32_t)((((uint64_t)a)*ff_inverse[b])>>32))
 #else
 #    define FASTDIV(a,b)   ((a)/(b))
 #endif
 
-/* math */
-extern FF_IMPORT_ATTR const uint8_t ff_sqrt_tab[128];
+extern const uint8_t ff_sqrt_tab[128];
 
 static inline int ff_sqrt(int a)
 {
@@ -138,7 +241,7 @@
     return ret;
 }
 
-#if defined(ARCH_X86) || defined(ARCH_X86_64)
+#if defined(ARCH_X86)
 #define MASK_ABS(mask, level)\
             asm volatile(\
                 "cdq                    \n\t"\
@@ -152,7 +255,7 @@
             level= (level^mask)-mask;
 #endif
 
-#if __CPU__ >= 686 && !defined(RUNTIME_CPUDETECT)
+#ifdef HAVE_CMOV
 #define COPY3_IF_LT(x,y,a,b,c,d)\
 asm volatile (\
     "cmpl %0, %3        \n\t"\
@@ -198,10 +301,10 @@
 /* XXX: add ISOC specific test to avoid specific BSD testing. */
 /* better than nothing implementation. */
 /* btw, rintf() is existing on fbsd too -- alex */
-static always_inline long int lrintf(float x)
+static av_always_inline long int lrintf(float x)
 {
 #ifdef __MINGW32__
-#  ifdef ARCH_X86
+#  ifdef ARCH_X86_32
     int32_t i;
     asm volatile(
         "fistpl %0\n\t"
@@ -211,7 +314,7 @@
 #  else
     /* XXX: incorrect, but make it compile */
     return (int)(x + (x < 0 ? -0.5 : 0.5));
-#  endif /* ARCH_X86 */
+#  endif /* ARCH_X86_32 */
 #else
     return (int)(rint(x));
 #endif /* __MINGW32__ */

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/intfloat_readwrite.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/intfloat_readwrite.c	2007-01-21 18:04:24 UTC (rev 2747)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/intfloat_readwrite.c	2007-01-21 18:04:51 UTC (rev 2748)
@@ -3,18 +3,20 @@
  *
  * Copyright (c) 2005 Michael Niedermayer <michaelni at gmx.at>
  *
- * This library is free software; you can redistribute it and/or
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
+ * version 2.1 of the License, or (at your option) any later version.
  *
- * This library is distributed in the hope that it will be useful,
+ * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
+ * License along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
@@ -27,7 +29,7 @@
 #include "intfloat_readwrite.h"
 
 double av_int2dbl(int64_t v){
-    if(v+v > 0xFFELLU<<52)
+    if(v+v > 0xFFEULL<<52)
         return 0.0/0.0;
     return ldexp(((v&((1LL<<52)-1)) + (1LL<<52)) * (v>>63|1), (v>>52&0x7FF)-1075);
 }

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/intfloat_readwrite.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/intfloat_readwrite.h	2007-01-21 18:04:24 UTC (rev 2747)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/intfloat_readwrite.h	2007-01-21 18:04:51 UTC (rev 2748)
@@ -1,3 +1,23 @@
+/*
+ * copyright (c) 2005 Michael Niedermayer <michaelni at gmx.at>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
 #ifndef INTFLOAT_READWRITE_H
 #define INTFLOAT_READWRITE_H
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/lls.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/lls.c	2007-01-21 18:04:24 UTC (rev 2747)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/lls.c	2007-01-21 18:04:51 UTC (rev 2748)
@@ -3,18 +3,20 @@
  *
  * Copyright (c) 2006 Michael Niedermayer <michaelni at gmx.at>
  *
- * This library is free software; you can redistribute it and/or
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
+ * version 2.1 of the License, or (at your option) any later version.
  *
- * This library is distributed in the hope that it will be useful,
+ * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
+ * License along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  */
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/lls.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/lls.h	2007-01-21 18:04:24 UTC (rev 2747)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/lls.h	2007-01-21 18:04:51 UTC (rev 2748)
@@ -3,18 +3,20 @@
  *
  * Copyright (c) 2006 Michael Niedermayer <michaelni at gmx.at>
  *
- * This library is free software; you can redistribute it and/or
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
+ * version 2.1 of the License, or (at your option) any later version.
  *
- * This library is distributed in the hope that it will be useful,
+ * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
+ * License along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  */
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/log.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/log.c	2007-01-21 18:04:24 UTC (rev 2747)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/log.c	2007-01-21 18:04:51 UTC (rev 2748)
@@ -2,18 +2,20 @@
  * log functions
  * Copyright (c) 2003 Michel Bardiaux
  *
- * This library is free software; you can redistribute it and/or
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
+ * version 2.1 of the License, or (at your option) any later version.
  *
- * This library is distributed in the hope that it will be useful,
+ * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
+ * License along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
@@ -26,7 +28,7 @@
 
 int av_log_level = AV_LOG_INFO;
 
-static void av_log_default_callback(void* ptr, int level, const char* fmt, va_list vl)
+void av_log_default_callback(void* ptr, int level, const char* fmt, va_list vl)
 {
     static int print_prefix=1;
     AVClass* avc= ptr ? *(AVClass**)ptr : NULL;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/log.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/log.h	2007-01-21 18:04:24 UTC (rev 2747)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/log.h	2007-01-21 18:04:51 UTC (rev 2748)
@@ -1,3 +1,23 @@
+/*
+ * copyright (c) 2006 Michael Niedermayer <michaelni at gmx.at>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
 #ifndef LOG_H
 #define LOG_H
 
@@ -13,7 +33,7 @@
                                         or AVFormatContext, which begin with an AVClass.
                                         Needed because av_log is in libavcodec and has no visibility
                                         of AVIn/OutputFormat */
-    struct AVOption *option;
+    const struct AVOption *option;
 };
 
 /* av_log API */
@@ -35,6 +55,7 @@
 extern int av_log_get_level(void);
 extern void av_log_set_level(int);
 extern void av_log_set_callback(void (*)(void*, int, const char*, va_list));
+extern void av_log_default_callback(void* ptr, int level, const char* fmt, va_list vl);
 #else
 extern void (*av_vlog)(void*, int, const char*, va_list);
 #endif

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/mathematics.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/mathematics.c	2007-01-21 18:04:24 UTC (rev 2747)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/mathematics.c	2007-01-21 18:04:51 UTC (rev 2748)
@@ -1,18 +1,20 @@
 /*
  * Copyright (c) 2005 Michael Niedermayer <michaelni at gmx.at>
  *
- * This library is free software; you can redistribute it and/or
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
+ * version 2.1 of the License, or (at your option) any later version.
  *
- * This library is distributed in the hope that it will be useful,
+ * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
+ * License along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
@@ -129,7 +131,7 @@
                 if((double)a * (double)b / (double)c > (1LL<<63))
                     continue;
 
-                if(d!=e) printf("%Ld*%Ld/%Ld= %Ld=%Ld\n", a, b, c, d, e);
+                if(d!=e) printf("%"PRId64"*%"PRId64"/%"PRId64"= %"PRId64"=%"PRId64"\n", a, b, c, d, e);
             }
         }
     }

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/mathematics.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/mathematics.h	2007-01-21 18:04:24 UTC (rev 2747)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/mathematics.h	2007-01-21 18:04:51 UTC (rev 2748)
@@ -1,3 +1,23 @@
+/*
+ * copyright (c) 2005 Michael Niedermayer <michaelni at gmx.at>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
 #ifndef MATHEMATICS_H
 #define MATHEMATICS_H
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/md5.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/md5.c	2007-01-21 18:04:24 UTC (rev 2747)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/md5.c	2007-01-21 18:04:51 UTC (rev 2748)
@@ -2,18 +2,20 @@
  * Copyright (C) 2006 Michael Niedermayer (michaelni at gmx.at)
  * Copyright (C) 2003-2005 by Christopher R. Hertel (crh at ubiqx.mn.org)
  *
- * This library is free software; you can redistribute it and/or
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
+ * version 2.1 of the License, or (at your option) any later version.
  *
- * This library is distributed in the hope that it will be useful,
+ * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
+ * License along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  *
  * References:
@@ -174,11 +176,11 @@
     uint8_t in[1000];
 
     for(i=0; i<1000; i++) in[i]= i*i;
-    av_md5_sum( (uint8_t*)&md5val, in,  1000); printf("%lld\n", md5val);
-    av_md5_sum( (uint8_t*)&md5val, in,  63); printf("%lld\n", md5val);
-    av_md5_sum( (uint8_t*)&md5val, in,  64); printf("%lld\n", md5val);
-    av_md5_sum( (uint8_t*)&md5val, in,  65); printf("%lld\n", md5val);
+    av_md5_sum( (uint8_t*)&md5val, in,  1000); printf("%"PRId64"\n", md5val);
+    av_md5_sum( (uint8_t*)&md5val, in,  63); printf("%"PRId64"\n", md5val);
+    av_md5_sum( (uint8_t*)&md5val, in,  64); printf("%"PRId64"\n", md5val);
+    av_md5_sum( (uint8_t*)&md5val, in,  65); printf("%"PRId64"\n", md5val);
     for(i=0; i<1000; i++) in[i]= i % 127;
-    av_md5_sum( (uint8_t*)&md5val, in,  999); printf("%lld\n", md5val);
+    av_md5_sum( (uint8_t*)&md5val, in,  999); printf("%"PRId64"\n", md5val);
 }
 #endif

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/md5.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/md5.h	2007-01-21 18:04:24 UTC (rev 2747)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/md5.h	2007-01-21 18:04:51 UTC (rev 2748)
@@ -1,3 +1,23 @@
+/*
+ * copyright (c) 2006 Michael Niedermayer <michaelni at gmx.at>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
 #ifndef MD5_H
 #define MD5_H
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/mem.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/mem.c	2007-01-21 18:04:24 UTC (rev 2747)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/mem.c	2007-01-21 18:04:51 UTC (rev 2748)
@@ -2,18 +2,20 @@
  * default memory allocator for libavutil
  * Copyright (c) 2002 Fabrice Bellard.
  *
- * This library is free software; you can redistribute it and/or
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
+ * version 2.1 of the License, or (at your option) any later version.
  *
- * This library is distributed in the hope that it will be useful,
+ * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
+ * License along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
@@ -45,7 +47,7 @@
 void *av_malloc(unsigned int size)
 {
     void *ptr;
-#ifdef MEMALIGN_HACK
+#ifdef CONFIG_MEMALIGN_HACK
     long diff;
 #endif
 
@@ -53,7 +55,7 @@
     if(size > (INT_MAX-16) )
         return NULL;
 
-#ifdef MEMALIGN_HACK
+#ifdef CONFIG_MEMALIGN_HACK
     ptr = malloc(size+16);
     if(!ptr)
         return ptr;
@@ -101,7 +103,7 @@
  */
 void *av_realloc(void *ptr, unsigned int size)
 {
-#ifdef MEMALIGN_HACK
+#ifdef CONFIG_MEMALIGN_HACK
     int diff;
 #endif
 
@@ -109,7 +111,7 @@
     if(size > (INT_MAX-16) )
         return NULL;
 
-#ifdef MEMALIGN_HACK
+#ifdef CONFIG_MEMALIGN_HACK
     //FIXME this isn't aligned correctly, though it probably isn't needed
     if(!ptr) return av_malloc(size);
     diff= ((char*)ptr)[-1];
@@ -128,10 +130,42 @@
 {
     /* XXX: this test should not be needed on most libcs */
     if (ptr)
-#ifdef MEMALIGN_HACK
+#ifdef CONFIG_MEMALIGN_HACK
         free(ptr - ((char*)ptr)[-1]);
 #else
         free(ptr);
 #endif
 }
 
+/**
+ * Frees memory and sets the pointer to NULL.
+ * @param arg pointer to the pointer which should be freed
+ */
+void av_freep(void *arg)
+{
+    void **ptr= (void**)arg;
+    av_free(*ptr);
+    *ptr = NULL;
+}
+
+void *av_mallocz(unsigned int size)
+{
+    void *ptr;
+
+    ptr = av_malloc(size);
+    if (ptr)
+        memset(ptr, 0, size);
+    return ptr;
+}
+
+char *av_strdup(const char *s)
+{
+    char *ptr;
+    int len;
+    len = strlen(s) + 1;
+    ptr = av_malloc(len);
+    if (ptr)
+        memcpy(ptr, s, len);
+    return ptr;
+}
+

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/rational.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/rational.c	2007-01-21 18:04:24 UTC (rev 2747)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/rational.c	2007-01-21 18:04:51 UTC (rev 2748)
@@ -2,18 +2,20 @@
  * Rational numbers
  * Copyright (c) 2003 Michael Niedermayer <michaelni at gmx.at>
  *
- * This library is free software; you can redistribute it and/or
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
+ * version 2.1 of the License, or (at your option) any later version.
  *
- * This library is distributed in the hope that it will be useful,
+ * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
+ * License along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  *
  */
@@ -34,29 +36,38 @@
 int av_reduce(int *dst_nom, int *dst_den, int64_t nom, int64_t den, int64_t max){
     AVRational a0={0,1}, a1={1,0};
     int sign= (nom<0) ^ (den<0);
-    int64_t gcd= ff_gcd(ABS(nom), ABS(den));
+    int64_t gcd= ff_gcd(FFABS(nom), FFABS(den));
 
-    nom = ABS(nom)/gcd;
-    den = ABS(den)/gcd;
+    if(gcd){
+        nom = FFABS(nom)/gcd;
+        den = FFABS(den)/gcd;
+    }
     if(nom<=max && den<=max){
         a1= (AVRational){nom, den};
         den=0;
     }
 
     while(den){
-        int64_t x       = nom / den;
+        uint64_t x      = nom / den;
         int64_t next_den= nom - den*x;
         int64_t a2n= x*a1.num + a0.num;
         int64_t a2d= x*a1.den + a0.den;
 
-        if(a2n > max || a2d > max) break;
+        if(a2n > max || a2d > max){
+            if(a1.num) x= (max - a0.num) / a1.num;
+            if(a1.den) x= FFMIN(x, (max - a0.den) / a1.den);
 
+            if (den*(2*x*a1.den + a0.den) > nom*a1.den)
+                a1 = (AVRational){x*a1.num + a0.num, x*a1.den + a0.den};
+            break;
+        }
+
         a0= a1;
         a1= (AVRational){a2n, a2d};
         nom= den;
         den= next_den;
     }
-    assert(ff_gcd(a1.num, a1.den) == 1);
+    assert(ff_gcd(a1.num, a1.den) <= 1U);
 
     *dst_nom = sign ? -a1.num : a1.num;
     *dst_den = a1.den;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/rational.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/rational.h	2007-01-21 18:04:24 UTC (rev 2747)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/rational.h	2007-01-21 18:04:51 UTC (rev 2748)
@@ -2,18 +2,20 @@
  * Rational numbers
  * Copyright (c) 2003 Michael Niedermayer <michaelni at gmx.at>
  *
- * This library is free software; you can redistribute it and/or
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
+ * version 2.1 of the License, or (at your option) any later version.
  *
- * This library is distributed in the hope that it will be useful,
+ * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
+ * License along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  *
  */

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/x86_cpu.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/x86_cpu.h	2007-01-21 18:04:24 UTC (rev 2747)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/x86_cpu.h	2007-01-21 18:04:51 UTC (rev 2748)
@@ -1,3 +1,23 @@
+/*
+ * copyright (c) 2006 Michael Niedermayer <michaelni at gmx.at>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
 #ifndef AVUTIL_X86CPU_H
 #define AVUTIL_X86CPU_H
 
@@ -15,6 +35,7 @@
 #  define REGBP   rbp
 #  define REGa    rax
 #  define REGb    rbx
+#  define REGc    rcx
 #  define REGSP   rsp
 
 #else
@@ -32,6 +53,7 @@
 #  define REGBP   ebp
 #  define REGa    eax
 #  define REGb    ebx
+#  define REGc    ecx
 #  define REGSP   esp
 #endif
 



From mean at mail.berlios.de  Sun Jan 21 19:19:14 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 21 Jan 2007 19:19:14 +0100
Subject: [Avidemux-svn-commit] r2750 - in branches/avidemux_2.4_branch: .
	addons/tsscan avidemux/ADM_audio avidemux/ADM_audiocodec
	avidemux/ADM_codecs avidemux/ADM_encoder
	avidemux/ADM_inputs/ADM_matroska avidemux/ADM_osSupport
	avidemux/ADM_video
Message-ID: <200701211819.l0LIJEiT020665@sheep.berlios.de>

Author: mean
Date: 2007-01-21 19:19:12 +0100 (Sun, 21 Jan 2007)
New Revision: 2750

Removed:
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSoften.try
   branches/avidemux_2.4_branch/gtk2_build.glade
Modified:
   branches/avidemux_2.4_branch/addons/tsscan/tsscan.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_audio/Makefile.am
   branches/avidemux_2.4_branch/avidemux/ADM_audiocodec/ADM_codecimaadpcm.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_audiocodec/ADM_codecwma.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_x264.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_encoder/ADM_encCodecDesc.h
   branches/avidemux_2.4_branch/avidemux/ADM_encoder/adm_encConfig.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_matroska/Makefile.am
   branches/avidemux_2.4_branch/avidemux/ADM_osSupport/ADM_memsupport.cpp
   branches/avidemux_2.4_branch/configure.in.in
Log:
update to ffmpeg svn

Modified: branches/avidemux_2.4_branch/addons/tsscan/tsscan.cpp
===================================================================
--- branches/avidemux_2.4_branch/addons/tsscan/tsscan.cpp	2007-01-21 18:06:06 UTC (rev 2749)
+++ branches/avidemux_2.4_branch/addons/tsscan/tsscan.cpp	2007-01-21 18:19:12 UTC (rev 2750)
@@ -146,6 +146,7 @@
 		}
 		if(isPMT(pid))
 			{
+				printf("PMT Id: 0x%x\n",pid);
 				decodePMT();
 				continue;
 			}

Modified: branches/avidemux_2.4_branch/avidemux/ADM_audio/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_audio/Makefile.am	2007-01-21 18:06:06 UTC (rev 2749)
+++ branches/avidemux_2.4_branch/avidemux/ADM_audio/Makefile.am	2007-01-21 18:19:12 UTC (rev 2750)
@@ -1,7 +1,7 @@
 ####### kdevelop will overwrite this part!!! (begin)##########
 noinst_LIBRARIES = libADM_audio.a
 
-INCLUDES = $(all_includes) -I../ADM_libraries -I../ADM_libraries/ADM_utilities
+INCLUDES = $(all_includes) -I../ADM_libraries -I../ADM_libraries/ADM_utilities -I../ADM_libraries/ADM_lavutil
 
 libADM_audio_a_METASOURCES = AUTO
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_audiocodec/ADM_codecimaadpcm.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_audiocodec/ADM_codecimaadpcm.cpp	2007-01-21 18:06:06 UTC (rev 2749)
+++ branches/avidemux_2.4_branch/avidemux/ADM_audiocodec/ADM_codecimaadpcm.cpp	2007-01-21 18:19:12 UTC (rev 2750)
@@ -21,8 +21,8 @@
 #include <string.h>
 
 #include "config.h"
-#define always_inline inline
 #include "default.h"
+#include "common.h"
 #include "bswap.h"
 #include "ADM_assert.h"
 #include "ADM_audio/aviaudio.hxx"

Modified: branches/avidemux_2.4_branch/avidemux/ADM_audiocodec/ADM_codecwma.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_audiocodec/ADM_codecwma.cpp	2007-01-21 18:06:06 UTC (rev 2749)
+++ branches/avidemux_2.4_branch/avidemux/ADM_audiocodec/ADM_codecwma.cpp	2007-01-21 18:19:12 UTC (rev 2750)
@@ -66,7 +66,7 @@
         _context->codec_id = CODEC_ID_QDM2;
             else ADM_assert(0);
 
-    _context->extradata=(void *)d;
+    _context->extradata=(uint8_t *)d;
     _context->extradata_size=(int)l;
     printf(" Using %ld bytes of extra header data\n",l);
     mixDump((uint8_t *)_context->extradata,_context->extradata_size);

Modified: branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_x264.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_x264.cpp	2007-01-21 18:06:06 UTC (rev 2749)
+++ branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_x264.cpp	2007-01-21 18:19:12 UTC (rev 2750)
@@ -137,6 +137,16 @@
   MES(  _4x4I,  I4x4);
   param.i_log_level=X264_LOG_INFO;
   
+  /*
+     int         i_vbv_max_bitrate;
+        int         i_vbv_buffer_size;
+        float       f_vbv_buffer_init;
+
+  */
+  printf("VBV_max_br         :%d\n", param.rc.i_vbv_max_bitrate);
+  printf("vbv_buffer_size    :%d\n", param.rc.i_vbv_buffer_size);
+  printf("f_vbv_buffer_init  :%f\n", param.rc.f_vbv_buffer_init);
+  
   if(zparam->globalHeader)
       param.b_repeat_headers=0;
   else

Modified: branches/avidemux_2.4_branch/avidemux/ADM_encoder/ADM_encCodecDesc.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_encoder/ADM_encCodecDesc.h	2007-01-21 18:06:06 UTC (rev 2749)
+++ branches/avidemux_2.4_branch/avidemux/ADM_encoder/ADM_encCodecDesc.h	2007-01-21 18:19:12 UTC (rev 2750)
@@ -619,7 +619,7 @@
 };
 /**************************************/
 ADM_x264Param x264ExtraPSP = {
-0,//     uint32_t  globalHeader;
+1,//     uint32_t  globalHeader;
 0,//     uint32_t  nbThreads;
 NULL,//     char      *logfile;
 //     //
@@ -655,12 +655,12 @@
 4,//     uint32_t PartitionDecision;
 32, //Range
 1,//     uint32_t Method;
-4,//     uint32_t AR_Num;
-3,//     uint32_t AR_Den;
+1,//     uint32_t AR_Num;
+1,//     uint32_t AR_Den;
 1,//     uint32_t DeblockingFilter;
 0,//     int32_t  Strength;
 0,//     int32_t  Threshold;
-0,//     uint32_t CABAC;
+1,//     uint32_t CABAC;
 0,//     uint32_t Trellis;
 1, //        ChromaME
 0, // Mixed Ref

Modified: branches/avidemux_2.4_branch/avidemux/ADM_encoder/adm_encConfig.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_encoder/adm_encConfig.cpp	2007-01-21 18:06:06 UTC (rev 2749)
+++ branches/avidemux_2.4_branch/avidemux/ADM_encoder/adm_encConfig.cpp	2007-01-21 18:19:12 UTC (rev 2750)
@@ -956,7 +956,9 @@
 */
 void setPSP_X264Preset(void)
 {
+  
  memcpy(&x264Extra,&x264ExtraPSP,sizeof(x264ExtraPSP)); 
+ printf("Cabac :%u\n",x264Extra.CABAC);
 }
 #endif
 uint8_t oplug_mpegStore(void)

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_matroska/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_matroska/Makefile.am	2007-01-21 18:06:06 UTC (rev 2749)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_matroska/Makefile.am	2007-01-21 18:19:12 UTC (rev 2750)
@@ -1,7 +1,9 @@
 noinst_LIBRARIES = libADM_matroska.a
 
-INCLUDES = $(all_includes)  -I../../ADM_libraries -I../../ADM_libraries/ADM_utilities   -I../../ADM_libraries/ADM_lavutil
+INCLUDES = $(all_includes)  -I../../ADM_libraries -I../../ADM_libraries/ADM_utilities   -I../../ADM_libraries/ADM_lavutil -I../../ADM_libraries/ADM_lavcodec
 
+
+
 libADM_matroska_a_METASOURCES = AUTO
 
 libADM_matroska_a_SOURCES = ADM_mkv.cpp ADM_mkv_audio.cpp

Modified: branches/avidemux_2.4_branch/avidemux/ADM_osSupport/ADM_memsupport.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_osSupport/ADM_memsupport.cpp	2007-01-21 18:06:06 UTC (rev 2749)
+++ branches/avidemux_2.4_branch/avidemux/ADM_osSupport/ADM_memsupport.cpp	2007-01-21 18:19:12 UTC (rev 2750)
@@ -154,11 +154,39 @@
 //********************************
 // lavcodec wrapper
 //********************************
+extern "C"
+{
 void *av_malloc(unsigned int size)
 {
  	return ADM_alloc(size);
 }
+void av_freep(void *arg)
+{
+    void **ptr= (void**)arg;
+    av_free(*ptr);
+    *ptr = NULL;
+}
 
+void *av_mallocz(unsigned int size)
+{
+    void *ptr;
+
+    ptr = av_malloc(size);
+    if (ptr)
+        memset(ptr, 0, size);
+    return ptr;
+}
+}
+char *av_strdup(const char *s)
+{
+    char *ptr;
+    int len;
+    len = strlen(s) + 1;
+    ptr = (char *)av_malloc(len);
+    if (ptr)
+        memcpy(ptr, s, len);
+    return ptr;
+}
 /**
  * av_realloc semantics (same as glibc): if ptr is NULL and size > 0,
  * identical to malloc(size). If size is zero, it is identical to

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSoften.try
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSoften.try	2007-01-21 18:06:06 UTC (rev 2749)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSoften.try	2007-01-21 18:19:12 UTC (rev 2750)
@@ -1,230 +0,0 @@
-//
-// C++ Implementation: Soften
-//
-// Description: 
-//
-// See .h file
-//
-// Author: mean <fixounet at free.fr>, (C) 2004
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-
-//
-//	This is the very unoptimized version
-//	could use some stuff and some mmx too
-//
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <assert.h>
-#include <assert.h>
-#include <math.h>
-#include <math.h>
-#include <iconv.h>
-#include "config.h"
-
-
-#include "fourcc.h"
-#include "avio.hxx"
-
-#include "avi_vars.h"
-
-#include "ADM_toolkit/toolkit.hxx"
-#include "ADM_editor/ADM_edit.hxx"
-#include "ADM_video/ADM_genvideo.hxx"
-
-#include "ADM_toolkit/ADM_debugID.h"
-#define MODULE_NAME MODULE_FILTER
-#include "ADM_toolkit/ADM_debug.h"
-
-
-
-#include "ADM_vidSoften.h"
-#include "ADM_dialog/DIA_enter.h"
-
-BUILD_CREATE(soften_create,ADMVideoMaskedSoften);
-
-extern uint8_t distMatrix[256][256];
-extern uint32_t fixMul[16];
-
-
-uint8_t ADMVideoMaskedSoften::configure( AVDMGenericVideoStream *instream)
-{
-	_in=instream;
-	int radius;
-	
-		radius=_param->radius;
-		if(DIA_GetIntegerValue(&radius,2,60, "Radius","Radius:"))
-			_param->radius=radius;
-			
-		radius=_param->luma;
-		if(DIA_GetIntegerValue(&radius,0,255, "Luma Threshold","Luma Threshold:"))
-			_param->luma=radius;
-		
-		radius=_param->chroma;
-		if(DIA_GetIntegerValue(&radius,0,255, "Chroma Threshold","Chroma Threshold:"))
-			_param->chroma=radius;
-					
-		
-	return 1;	
- 	
-}
-uint8_t	ADMVideoMaskedSoften::getCoupledConf( CONFcouple **couples)
-{
-
-			*couples=new CONFcouple(3);
-
-			CSET(radius);
-			CSET(luma);
-			CSET(chroma);
-
-		return 1;	
-}
-char *ADMVideoMaskedSoften::printConf( void )
-{
- 	static char buf[50];
- 	
- 	sprintf((char *)buf," Soften : radius: %lu l:%lu c:%lu\n", 
-		_param->radius,_param->luma, _param->chroma);
-        return buf;
-}
-
-ADMVideoMaskedSoften::~ADMVideoMaskedSoften()
-{
-	if(_uncompressed)
- 		delete []_uncompressed;	
- 	_uncompressed=NULL;
-}
-
-
- ADMVideoMaskedSoften::ADMVideoMaskedSoften( AVDMGenericVideoStream *in,CONFcouple *couples)
-{
-		
-		_uncompressed=NULL;
-		_in=in;
-		assert(in);
-		if(!couples)
-		{
-			
-			_param=NEW(MaskedSoften_CONF);
-	    		_param->radius=3; 
-	    		_param->luma=5;
-			_param->chroma=5;
-			
-	    	}
-		else
-		{
-			_param=NEW(MaskedSoften_CONF);
-			GET(radius);
-			GET(luma);
-			GET(chroma);
-			
-						
-		}
-		assert(in);
-		
-		memcpy(&_info,_in->getInfo(),sizeof(_info));	
-			    	
-	    	_uncompressed=new uint8_t[3*_info.width*_info.height];	
-		
-
-}
-uint8_t ADMVideoMaskedSoften::getFrameNumberNoAlloc(uint32_t frame,
-							uint32_t *len,
-							uint8_t *data,
-							uint32_t *flags)
-{
-		uint32_t page=_info.width*_info.height;
-		int32_t radius=_param->radius;
-		uint32_t offset;
-		
-		int blockx,blocky;
-		
-		*len=(page*3)>>1;
-		if(frame>=_info.nb_frames) return 0;		
-		
-				
-		if(!_in->getFrameNumberNoAlloc(frame, len,_uncompressed,flags))
-				 		return 0;
-
-		// do luma only ATM
-		// copy chroma
-		memcpy(data+page,_uncompressed+page,page>>1);
-		
-		// for luma, the radius first lines /last lines are unchanged
-		memcpy(data,_uncompressed,radius*_info.width);
-		
-		offset=page-_info.width*radius-1;
-		
-		memcpy(data+offset,
-			_uncompressed+offset,
-			radius*_info.width);
-
-		uint8_t *src,*dst;
-		uint32_t val,cur,coef;
-		
-		// We use a intermediate buffer to maximize cache
-		// effectiveness
-		// Each line is replaced by the oldest one
-		//
-		//	0	4
-		//	1	1
-		//	2  ->	2
-		
-		
-		uint32_t modulo=0;
-		uint32_t line=2*radius+1;
-		
-		uint8_t matrix[line][line];
-		
-		
-		
-		for(uint32_t x=radius;x<_info.width-radius;x++)
-		{
-			printf("X:%lu\n",x);
-			src=_uncompressed+radius*_info.width+radius;
-			dst=data+radius*_info.width+radius;
-			for(uint32_t i=0;i<line;i++)
-			{
-				memcpy(matrix[i],_uncompressed+x-radius+i*_info.width,line);
-			}
-			modulo=0;
-			for(uint32_t y=radius;y<_info.height-radius;y++)
-			{
-				uint8_t *cmp;
-				coef=0;
-				val=0;			
-				cmp=matrix[0];
-				for(blocky=line*line;blocky>0;blocky--)
-				{
-					cur=*cmp++;
-					if( distMatrix[cur][*src]<=_param->luma)
-					{
-							coef++;
-							val+=cur;
-					}	
-				}
-				assert(coef);
-				//printf("Coeff:%d\n",coef);
-				val=(val+(coef>>1))/coef;
-				*dst=val;
-				dst+=_info.width;
-				src+=_info.width;
-				// replace the oldest line
-				memcpy(matrix[modulo],
-						_uncompressed+x-radius+
-						(radius+y+1)*_info.width,
-						line);
-				modulo++;
-				modulo%=line;
-			}
-		
-		}
-		//delete [] matrix;
-			
-	return 1;
-}
-

Modified: branches/avidemux_2.4_branch/configure.in.in
===================================================================
--- branches/avidemux_2.4_branch/configure.in.in	2007-01-21 18:06:06 UTC (rev 2749)
+++ branches/avidemux_2.4_branch/configure.in.in	2007-01-21 18:19:12 UTC (rev 2750)
@@ -356,6 +356,7 @@
 AC_DEFINE(USE_MJPEG,1,[MJPEG])
 AC_DEFINE(AMR_NB,1,[AMR_NB])
 AC_DEFINE(CONFIG_AMR_NB,1,[AMR_NB])
+AC_DEFINE(CONFIG_DVVIDEO_ENCODER,1,[DV encoder])
 dnl AC_DEFINE(USE_MP3,0,[libmad])
 dnl AC_DEFINE(USE_MPEG,0,[libmpeg3])
 dnl AC_DEFINE(OSS_SUPPORT,0,[OSS])

Deleted: branches/avidemux_2.4_branch/gtk2_build.glade
===================================================================
--- branches/avidemux_2.4_branch/gtk2_build.glade	2007-01-21 18:06:06 UTC (rev 2749)
+++ branches/avidemux_2.4_branch/gtk2_build.glade	2007-01-21 18:19:12 UTC (rev 2750)
@@ -1,1831 +0,0 @@
-<?xml version="1.0" standalone="no"?> <!--*- mode: xml -*-->
-<!DOCTYPE glade-interface SYSTEM "http://glade.gnome.org/glade-2.0.dtd">
-
-<glade-interface>
-
-<widget class="GtkWindow" id="mainWindow">
-  <property name="visible">True</property>
-  <property name="title" translatable="yes">Avidemux2</property>
-  <property name="type">GTK_WINDOW_TOPLEVEL</property>
-  <property name="window_position">GTK_WIN_POS_NONE</property>
-  <property name="modal">False</property>
-  <property name="resizable">True</property>
-  <property name="destroy_with_parent">False</property>
-  <property name="icon">about.xpm</property>
-
-  <child>
-    <widget class="GtkVBox" id="vbox1">
-      <property name="visible">True</property>
-      <property name="homogeneous">False</property>
-      <property name="spacing">0</property>
-
-      <child>
-	<widget class="GtkMenuBar" id="menuBar">
-	  <property name="visible">True</property>
-	  <property name="can_focus">True</property>
-
-	  <child>
-	    <widget class="GtkMenuItem" id="menuitem1">
-	      <property name="visible">True</property>
-	      <property name="label" translatable="yes">_File</property>
-	      <property name="use_underline">True</property>
-
-	      <child>
-		<widget class="GtkMenu" id="menuitem1_menu">
-
-		  <child>
-		    <widget class="GtkImageMenuItem" id="open_video1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Open Video...</property>
-		      <property name="use_underline">True</property>
-		      <accelerator key="O" modifiers="GDK_CONTROL_MASK" signal="activate"/>
-
-		      <child internal-child="image">
-			<widget class="GtkImage" id="image1092">
-			  <property name="visible">True</property>
-			  <property name="stock">gtk-open</property>
-			  <property name="icon_size">1</property>
-			  <property name="xalign">0.5</property>
-			  <property name="yalign">0.5</property>
-			  <property name="xpad">0</property>
-			  <property name="ypad">0</property>
-			</widget>
-		      </child>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkImageMenuItem" id="append_video1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Append Video...</property>
-		      <property name="use_underline">True</property>
-		      <accelerator key="A" modifiers="GDK_CONTROL_MASK" signal="activate"/>
-
-		      <child internal-child="image">
-			<widget class="GtkImage" id="image1093">
-			  <property name="visible">True</property>
-			  <property name="stock">gtk-add</property>
-			  <property name="icon_size">1</property>
-			  <property name="xalign">0.5</property>
-			  <property name="yalign">0.5</property>
-			  <property name="xpad">0</property>
-			  <property name="ypad">0</property>
-			</widget>
-		      </child>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="separator1">
-		      <property name="visible">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="save_stuff">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Save</property>
-		      <property name="use_underline">True</property>
-
-		      <child>
-			<widget class="GtkMenu" id="save_stuff_menu">
-
-			  <child>
-			    <widget class="GtkMenuItem" id="save_as_avi1">
-			      <property name="visible">True</property>
-			      <property name="label" translatable="yes">Save Video...</property>
-			      <property name="use_underline">True</property>
-			      <accelerator key="S" modifiers="GDK_CONTROL_MASK" signal="activate"/>
-			    </widget>
-			  </child>
-
-			  <child>
-			    <widget class="GtkMenuItem" id="save_raw_video_stream1">
-			      <property name="visible">True</property>
-			      <property name="label" translatable="yes">Save _Raw Video Stream...</property>
-			      <property name="use_underline">True</property>
-			    </widget>
-			  </child>
-
-			  <child>
-			    <widget class="GtkMenuItem" id="save_as_dual_audio_avi1">
-			      <property name="visible">True</property>
-			      <property name="label" translatable="yes">Save As _Dual Audio AVI...</property>
-			      <property name="use_underline">True</property>
-			    </widget>
-			  </child>
-
-			  <child>
-			    <widget class="GtkMenuItem" id="save_image1">
-			      <property name="visible">True</property>
-			      <property name="label" translatable="yes">Save Image...</property>
-			      <property name="use_underline">True</property>
-			      <accelerator key="M" modifiers="GDK_CONTROL_MASK" signal="activate"/>
-			    </widget>
-			  </child>
-
-			  <child>
-			    <widget class="GtkMenuItem" id="save_audio1">
-			      <property name="visible">True</property>
-			      <property name="label" translatable="yes">Save _Audio...</property>
-			      <property name="use_underline">True</property>
-			    </widget>
-			  </child>
-
-			  <child>
-			    <widget class="GtkMenuItem" id="pipe_audio_to1">
-			      <property name="visible">True</property>
-			      <property name="label" translatable="yes">_Pipe Audio to</property>
-			      <property name="use_underline">True</property>
-
-			      <child>
-				<widget class="GtkMenu" id="pipe_audio_to1_menu">
-
-				  <child>
-				    <widget class="GtkMenuItem" id="to_toolame1">
-				      <property name="visible">True</property>
-				      <property name="label" translatable="yes">tooLAME...</property>
-				      <property name="use_underline">True</property>
-				    </widget>
-				  </child>
-
-				  <child>
-				    <widget class="GtkMenuItem" id="to_lame1">
-				      <property name="visible">True</property>
-				      <property name="label" translatable="yes">LAME...</property>
-				      <property name="use_underline">True</property>
-				    </widget>
-				  </child>
-
-				  <child>
-				    <widget class="GtkMenuItem" id="to_other1">
-				      <property name="visible">True</property>
-				      <property name="label" translatable="yes">Other...</property>
-				      <property name="use_underline">True</property>
-				    </widget>
-				  </child>
-				</widget>
-			      </child>
-			    </widget>
-			  </child>
-			</widget>
-		      </child>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="separator2">
-		      <property name="visible">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="avi_muxer_options1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">AVI Muxer Options...</property>
-		      <property name="use_underline">True</property>
-		      <accelerator key="U" modifiers="GDK_CONTROL_MASK" signal="activate"/>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="separator11">
-		      <property name="visible">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkImageMenuItem" id="video_informations1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Video Informations...</property>
-		      <property name="use_underline">True</property>
-		      <accelerator key="I" modifiers="GDK_CONTROL_MASK" signal="activate"/>
-
-		      <child internal-child="image">
-			<widget class="GtkImage" id="image1094">
-			  <property name="visible">True</property>
-			  <property name="stock">gtk-dialog-question</property>
-			  <property name="icon_size">1</property>
-			  <property name="xalign">0.5</property>
-			  <property name="yalign">0.5</property>
-			  <property name="xpad">0</property>
-			  <property name="ypad">0</property>
-			</widget>
-		      </child>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="separator7">
-		      <property name="visible">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="separatormenuitem1">
-		      <property name="visible">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkImageMenuItem" id="quit1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Quit</property>
-		      <property name="use_underline">True</property>
-
-		      <child internal-child="image">
-			<widget class="GtkImage" id="image1095">
-			  <property name="visible">True</property>
-			  <property name="stock">gtk-quit</property>
-			  <property name="icon_size">1</property>
-			  <property name="xalign">0.5</property>
-			  <property name="yalign">0.5</property>
-			  <property name="xpad">0</property>
-			  <property name="ypad">0</property>
-			</widget>
-		      </child>
-		    </widget>
-		  </child>
-		</widget>
-	      </child>
-	    </widget>
-	  </child>
-
-	  <child>
-	    <widget class="GtkMenuItem" id="play_1">
-	      <property name="visible">True</property>
-	      <property name="label" translatable="yes">_Play </property>
-	      <property name="use_underline">True</property>
-
-	      <child>
-		<widget class="GtkMenu" id="play_1_menu">
-
-		  <child>
-		    <widget class="GtkMenuItem" id="play_video1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Play Video</property>
-		      <property name="use_underline">True</property>
-		      <accelerator key="P" modifiers="0" signal="activate"/>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="decoder_options1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Decoder Options...</property>
-		      <property name="use_underline">True</property>
-		      <accelerator key="P" modifiers="GDK_CONTROL_MASK" signal="activate"/>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="separator9">
-		      <property name="visible">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkImageMenuItem" id="next_frame1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Next Frame</property>
-		      <property name="use_underline">True</property>
-		      <accelerator key="6" modifiers="0" signal="activate"/>
-
-		      <child internal-child="image">
-			<widget class="GtkImage" id="image1096">
-			  <property name="visible">True</property>
-			  <property name="stock">gtk-go-forward</property>
-			  <property name="icon_size">1</property>
-			  <property name="xalign">0.5</property>
-			  <property name="yalign">0.5</property>
-			  <property name="xpad">0</property>
-			  <property name="ypad">0</property>
-			</widget>
-		      </child>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkImageMenuItem" id="previous_frame1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Previous Frame</property>
-		      <property name="use_underline">True</property>
-		      <accelerator key="4" modifiers="0" signal="activate"/>
-
-		      <child internal-child="image">
-			<widget class="GtkImage" id="image1097">
-			  <property name="visible">True</property>
-			  <property name="stock">gtk-undo</property>
-			  <property name="icon_size">1</property>
-			  <property name="xalign">0.5</property>
-			  <property name="yalign">0.5</property>
-			  <property name="xpad">0</property>
-			  <property name="ypad">0</property>
-			</widget>
-		      </child>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkImageMenuItem" id="next_intra_frame1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Next Intra Frame</property>
-		      <property name="use_underline">True</property>
-		      <accelerator key="8" modifiers="0" signal="activate"/>
-
-		      <child internal-child="image">
-			<widget class="GtkImage" id="image1098">
-			  <property name="visible">True</property>
-			  <property name="stock">gtk-goto-last</property>
-			  <property name="icon_size">1</property>
-			  <property name="xalign">0.5</property>
-			  <property name="yalign">0.5</property>
-			  <property name="xpad">0</property>
-			  <property name="ypad">0</property>
-			</widget>
-		      </child>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkImageMenuItem" id="previous_intra_frame1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Previous Intra Frame</property>
-		      <property name="use_underline">True</property>
-		      <accelerator key="2" modifiers="0" signal="activate"/>
-
-		      <child internal-child="image">
-			<widget class="GtkImage" id="image1099">
-			  <property name="visible">True</property>
-			  <property name="stock">gtk-goto-first</property>
-			  <property name="icon_size">1</property>
-			  <property name="xalign">0.5</property>
-			  <property name="yalign">0.5</property>
-			  <property name="xpad">0</property>
-			  <property name="ypad">0</property>
-			</widget>
-		      </child>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="search_next_black_frame1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Search _Next Black Frame</property>
-		      <property name="use_underline">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="search_previous_black_frame1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Search _Previous Black Frame</property>
-		      <property name="use_underline">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkImageMenuItem" id="jum_to_frame1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Jump to Frame...</property>
-		      <property name="use_underline">True</property>
-		      <accelerator key="G" modifiers="GDK_CONTROL_MASK" signal="activate"/>
-
-		      <child internal-child="image">
-			<widget class="GtkImage" id="image1100">
-			  <property name="visible">True</property>
-			  <property name="stock">gtk-jump-to</property>
-			  <property name="icon_size">1</property>
-			  <property name="xalign">0.5</property>
-			  <property name="yalign">0.5</property>
-			  <property name="xpad">0</property>
-			  <property name="ypad">0</property>
-			</widget>
-		      </child>
-		    </widget>
-		  </child>
-		</widget>
-	      </child>
-	    </widget>
-	  </child>
-
-	  <child>
-	    <widget class="GtkMenuItem" id="menuitem2">
-	      <property name="visible">True</property>
-	      <property name="label" translatable="yes">_Edit</property>
-	      <property name="use_underline">True</property>
-
-	      <child>
-		<widget class="GtkMenu" id="menuitem2_menu">
-
-		  <child>
-		    <widget class="GtkImageMenuItem" id="cut1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Cut</property>
-		      <property name="use_underline">True</property>
-
-		      <child internal-child="image">
-			<widget class="GtkImage" id="image1101">
-			  <property name="visible">True</property>
-			  <property name="stock">gtk-cut</property>
-			  <property name="icon_size">1</property>
-			  <property name="xalign">0.5</property>
-			  <property name="yalign">0.5</property>
-			  <property name="xpad">0</property>
-			  <property name="ypad">0</property>
-			</widget>
-		      </child>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkImageMenuItem" id="copy1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Copy</property>
-		      <property name="use_underline">True</property>
-
-		      <child internal-child="image">
-			<widget class="GtkImage" id="image1102">
-			  <property name="visible">True</property>
-			  <property name="stock">gtk-copy</property>
-			  <property name="icon_size">1</property>
-			  <property name="xalign">0.5</property>
-			  <property name="yalign">0.5</property>
-			  <property name="xpad">0</property>
-			  <property name="ypad">0</property>
-			</widget>
-		      </child>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="paste1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Paste</property>
-		      <property name="use_underline">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkImageMenuItem" id="delete1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Delete</property>
-		      <property name="use_underline">True</property>
-
-		      <child internal-child="image">
-			<widget class="GtkImage" id="image1103">
-			  <property name="visible">True</property>
-			  <property name="stock">gtk-delete</property>
-			  <property name="icon_size">1</property>
-			  <property name="xalign">0.5</property>
-			  <property name="yalign">0.5</property>
-			  <property name="xpad">0</property>
-			  <property name="ypad">0</property>
-			</widget>
-		      </child>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="separator5">
-		      <property name="visible">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="set_marker_a1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Set Marker A</property>
-		      <property name="use_underline">True</property>
-		      <accelerator key="bracketleft" modifiers="0" signal="activate"/>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="set_marker_b1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Set Marker B</property>
-		      <property name="use_underline">True</property>
-		      <accelerator key="bracketright" modifiers="0" signal="activate"/>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="separator4">
-		      <property name="visible">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="go_to_marker_a1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Go to Marker A</property>
-		      <property name="use_underline">True</property>
-		      <accelerator key="bracketleft" modifiers="GDK_CONTROL_MASK" signal="activate"/>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="go_to_marker_b1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Go to Marker B</property>
-		      <property name="use_underline">True</property>
-		      <accelerator key="bracketright" modifiers="GDK_CONTROL_MASK" signal="activate"/>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="separator10">
-		      <property name="visible">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="load_edit_list1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Load Edit List...</property>
-		      <property name="use_underline">True</property>
-		      <accelerator key="L" modifiers="GDK_MOD1_MASK" signal="activate"/>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="save_edit_list1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Save Edit List...</property>
-		      <property name="use_underline">True</property>
-		      <accelerator key="S" modifiers="GDK_MOD1_MASK" signal="activate"/>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="separator13">
-		      <property name="visible">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkImageMenuItem" id="reset_edits1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">_Reset Edits</property>
-		      <property name="use_underline">True</property>
-
-		      <child internal-child="image">
-			<widget class="GtkImage" id="image1104">
-			  <property name="visible">True</property>
-			  <property name="stock">gtk-undo</property>
-			  <property name="icon_size">1</property>
-			  <property name="xalign">0.5</property>
-			  <property name="yalign">0.5</property>
-			  <property name="xpad">0</property>
-			  <property name="ypad">0</property>
-			</widget>
-		      </child>
-		    </widget>
-		  </child>
-		</widget>
-	      </child>
-	    </widget>
-	  </child>
-
-	  <child>
-	    <widget class="GtkMenuItem" id="audio_source1">
-	      <property name="visible">True</property>
-	      <property name="label" translatable="yes">Audio</property>
-	      <property name="use_underline">True</property>
-
-	      <child>
-		<widget class="GtkMenu" id="audio_source1_menu">
-
-		  <child>
-		    <widget class="GtkMenuItem" id="source1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Source</property>
-		      <property name="use_underline">True</property>
-
-		      <child>
-			<widget class="GtkMenu" id="source1_menu">
-
-			  <child>
-			    <widget class="GtkMenuItem" id="current_video1">
-			      <property name="visible">True</property>
-			      <property name="label" translatable="yes">_Current Video</property>
-			      <property name="use_underline">True</property>
-			      <accelerator key="D" modifiers="GDK_CONTROL_MASK" signal="activate"/>
-			    </widget>
-			  </child>
-
-			  <child>
-			    <widget class="GtkMenuItem" id="external_mpeg">
-			      <property name="visible">True</property>
-			      <property name="label" translatable="yes">External _MPEG (MP2/MP3)...</property>
-			      <property name="use_underline">True</property>
-			      <accelerator key="E" modifiers="GDK_CONTROL_MASK" signal="activate"/>
-			    </widget>
-			  </child>
-
-			  <child>
-			    <widget class="GtkMenuItem" id="external_wav1">
-			      <property name="visible">True</property>
-			      <property name="label" translatable="yes">External _WAV...</property>
-			      <property name="use_underline">True</property>
-			      <accelerator key="W" modifiers="GDK_CONTROL_MASK" signal="activate"/>
-			    </widget>
-			  </child>
-
-			  <child>
-			    <widget class="GtkMenuItem" id="external_ac1">
-			      <property name="visible">True</property>
-			      <property name="label" translatable="yes">External _AC3...</property>
-			      <property name="use_underline">True</property>
-			      <accelerator key="3" modifiers="GDK_CONTROL_MASK" signal="activate"/>
-			    </widget>
-			  </child>
-
-			  <child>
-			    <widget class="GtkMenuItem" id="none1">
-			      <property name="visible">True</property>
-			      <property name="label" translatable="yes">_None</property>
-			      <property name="use_underline">True</property>
-			      <accelerator key="N" modifiers="GDK_CONTROL_MASK" signal="activate"/>
-			    </widget>
-			  </child>
-			</widget>
-		      </child>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="separator12">
-		      <property name="visible">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="build_vbr_time_map1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">_Build VBR Time Map</property>
-		      <property name="use_underline">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="audio_device1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">_Audio Device</property>
-		      <property name="use_underline">True</property>
-
-		      <child>
-			<widget class="GtkMenu" id="audio_device1_menu">
-
-			  <child>
-			    <widget class="GtkRadioMenuItem" id="oss">
-			      <property name="visible">True</property>
-			      <property name="label" translatable="yes">_OSS</property>
-			      <property name="use_underline">True</property>
-			      <property name="active">True</property>
-			    </widget>
-			  </child>
-
-			  <child>
-			    <widget class="GtkRadioMenuItem" id="arts1">
-			      <property name="visible">True</property>
-			      <property name="label" translatable="yes">a_Rts</property>
-			      <property name="use_underline">True</property>
-			      <property name="active">True</property>
-			      <property name="group">oss</property>
-			    </widget>
-			  </child>
-
-			  <child>
-			    <widget class="GtkRadioMenuItem" id="alsa1">
-			      <property name="visible">True</property>
-			      <property name="label" translatable="yes">_ALSA</property>
-			      <property name="use_underline">True</property>
-			      <property name="active">True</property>
-			      <property name="group">oss</property>
-			    </widget>
-			  </child>
-
-			  <child>
-			    <widget class="GtkRadioMenuItem" id="none2">
-			      <property name="visible">True</property>
-			      <property name="label" translatable="yes">_None</property>
-			      <property name="use_underline">True</property>
-			      <property name="active">True</property>
-			      <property name="group">oss</property>
-			    </widget>
-			  </child>
-			</widget>
-		      </child>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="second_audio_track1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">_Second Audio Track</property>
-		      <property name="use_underline">True</property>
-
-		      <child>
-			<widget class="GtkMenu" id="second_audio_track1_menu">
-
-			  <child>
-			    <widget class="GtkMenuItem" id="mp3_file1">
-			      <property name="visible">True</property>
-			      <property name="label" translatable="yes">_MP3 File...</property>
-			      <property name="use_underline">True</property>
-			    </widget>
-			  </child>
-
-			  <child>
-			    <widget class="GtkMenuItem" id="ac3_file1">
-			      <property name="visible">True</property>
-			      <property name="label" translatable="yes">_AC3 File...</property>
-			      <property name="use_underline">True</property>
-			    </widget>
-			  </child>
-			</widget>
-		      </child>
-		    </widget>
-		  </child>
-		</widget>
-	      </child>
-	    </widget>
-	  </child>
-
-	  <child>
-	    <widget class="GtkMenuItem" id="misc1">
-	      <property name="visible">True</property>
-	      <property name="label" translatable="yes">_Misc</property>
-	      <property name="use_underline">True</property>
-
-	      <child>
-		<widget class="GtkMenu" id="misc1_menu">
-
-		  <child>
-		    <widget class="GtkMenuItem" id="preferences1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">_Preferences...</property>
-		      <property name="use_underline">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="check_frames">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">_Check Frames (slow)</property>
-		      <property name="use_underline">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="bitrate_histogram1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">_Bitrate Histogram...</property>
-		      <property name="use_underline">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="cut_wizard1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Cut _Wizard...</property>
-		      <property name="use_underline">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="select_log_file1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Select _Log File...</property>
-		      <property name="use_underline">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="rebuild_frames">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">_Rebuild Frames (I &amp; B)...</property>
-		      <property name="use_underline">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="change_fps">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Change _fps...</property>
-		      <property name="use_underline">True</property>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkMenuItem" id="index_mpeg1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">_Index MPEG...</property>
-		      <property name="use_underline">True</property>
-		    </widget>
-		  </child>
-		</widget>
-	      </child>
-	    </widget>
-	  </child>
-
-	  <child>
-	    <widget class="GtkMenuItem" id="about1">
-	      <property name="visible">True</property>
-	      <property name="label" translatable="yes">_About</property>
-	      <property name="use_underline">True</property>
-	    </widget>
-	  </child>
-	</widget>
-	<packing>
-	  <property name="padding">0</property>
-	  <property name="expand">False</property>
-	  <property name="fill">False</property>
-	</packing>
-      </child>
-
-      <child>
-	<widget class="GtkHandleBox" id="handlebox2">
-	  <property name="visible">True</property>
-	  <property name="shadow_type">GTK_SHADOW_NONE</property>
-	  <property name="handle_position">GTK_POS_LEFT</property>
-	  <property name="snap_edge">GTK_POS_TOP</property>
-
-	  <child>
-	    <widget class="GtkToolbar" id="toolbar1">
-	      <property name="visible">True</property>
-	      <property name="orientation">GTK_ORIENTATION_HORIZONTAL</property>
-	      <property name="toolbar_style">GTK_TOOLBAR_BOTH</property>
-	      <property name="tooltips">True</property>
-
-	      <child>
-		<widget class="GtkButton" id="buttonOpen">
-		  <property name="visible">True</property>
-		  <property name="tooltip" translatable="yes">Open video</property>
-		  <property name="can_default">True</property>
-		  <property name="label">gtk-open</property>
-		  <property name="use_stock">True</property>
-		  <property name="relief">GTK_RELIEF_NORMAL</property>
-		</widget>
-	      </child>
-
-	      <child>
-		<widget class="GtkButton" id="buttonSaveAvi">
-		  <property name="visible">True</property>
-		  <property name="tooltip" translatable="yes">Save video</property>
-		  <property name="can_default">True</property>
-		  <property name="label">gtk-save</property>
-		  <property name="use_stock">True</property>
-		  <property name="relief">GTK_RELIEF_NORMAL</property>
-		</widget>
-	      </child>
-
-	      <child>
-		<widget class="GtkButton" id="buttonInfo">
-		  <property name="visible">True</property>
-		  <property name="tooltip" translatable="yes">Audio/video file information</property>
-		  <property name="can_default">True</property>
-		  <property name="relief">GTK_RELIEF_NORMAL</property>
-
-		  <child>
-		    <widget class="GtkAlignment" id="alignment11">
-		      <property name="visible">True</property>
-		      <property name="xalign">0.5</property>
-		      <property name="yalign">0.5</property>
-		      <property name="xscale">0</property>
-		      <property name="yscale">0</property>
-
-		      <child>
-			<widget class="GtkHBox" id="hbox15">
-			  <property name="visible">True</property>
-			  <property name="homogeneous">False</property>
-			  <property name="spacing">2</property>
-
-			  <child>
-			    <widget class="GtkImage" id="image634">
-			      <property name="visible">True</property>
-			      <property name="stock">gtk-dialog-question</property>
-			      <property name="icon_size">4</property>
-			      <property name="xalign">0.5</property>
-			      <property name="yalign">0.5</property>
-			      <property name="xpad">0</property>
-			      <property name="ypad">0</property>
-			    </widget>
-			    <packing>
-			      <property name="padding">0</property>
-			      <property name="expand">False</property>
-			      <property name="fill">False</property>
-			    </packing>
-			  </child>
-
-			  <child>
-			    <widget class="GtkLabel" id="label15">
-			      <property name="visible">True</property>
-			      <property name="label" translatable="yes">Info</property>
-			      <property name="use_underline">True</property>
-			      <property name="use_markup">False</property>
-			      <property name="justify">GTK_JUSTIFY_LEFT</property>
-			      <property name="wrap">False</property>
-			      <property name="selectable">False</property>
-			      <property name="xalign">0.5</property>
-			      <property name="yalign">0.5</property>
-			      <property name="xpad">0</property>
-			      <property name="ypad">0</property>
-			    </widget>
-			    <packing>
-			      <property name="padding">0</property>
-			      <property name="expand">False</property>
-			      <property name="fill">False</property>
-			    </packing>
-			  </child>
-			</widget>
-		      </child>
-		    </widget>
-		  </child>
-		</widget>
-	      </child>
-
-	      <child>
-		<widget class="GtkButton" id="buttonRecent">
-		  <property name="visible">True</property>
-		  <property name="tooltip" translatable="yes">Recent files</property>
-		  <property name="can_default">True</property>
-		  <property name="relief">GTK_RELIEF_NORMAL</property>
-
-		  <child>
-		    <widget class="GtkAlignment" id="alignment10">
-		      <property name="visible">True</property>
-		      <property name="xalign">0.5</property>
-		      <property name="yalign">0.5</property>
-		      <property name="xscale">0</property>
-		      <property name="yscale">0</property>
-
-		      <child>
-			<widget class="GtkHBox" id="hbox13">
-			  <property name="visible">True</property>
-			  <property name="homogeneous">False</property>
-			  <property name="spacing">2</property>
-
-			  <child>
-			    <widget class="GtkImage" id="image633">
-			      <property name="visible">True</property>
-			      <property name="stock">gtk-open</property>
-			      <property name="icon_size">4</property>
-			      <property name="xalign">0.5</property>
-			      <property name="yalign">0.5</property>
-			      <property name="xpad">0</property>
-			      <property name="ypad">0</property>
-			    </widget>
-			    <packing>
-			      <property name="padding">0</property>
-			      <property name="expand">False</property>
-			      <property name="fill">False</property>
-			    </packing>
-			  </child>
-
-			  <child>
-			    <widget class="GtkLabel" id="label14">
-			      <property name="visible">True</property>
-			      <property name="label" translatable="yes">Recent</property>
-			      <property name="use_underline">True</property>
-			      <property name="use_markup">False</property>
-			      <property name="justify">GTK_JUSTIFY_LEFT</property>
-			      <property name="wrap">False</property>
-			      <property name="selectable">False</property>
-			      <property name="xalign">0.5</property>
-			      <property name="yalign">0.5</property>
-			      <property name="xpad">0</property>
-			      <property name="ypad">0</property>
-			    </widget>
-			    <packing>
-			      <property name="padding">0</property>
-			      <property name="expand">False</property>
-			      <property name="fill">False</property>
-			    </packing>
-			  </child>
-			</widget>
-		      </child>
-		    </widget>
-		  </child>
-		</widget>
-	      </child>
-	    </widget>
-	  </child>
-	</widget>
-	<packing>
-	  <property name="padding">0</property>
-	  <property name="expand">False</property>
-	  <property name="fill">False</property>
-	</packing>
-      </child>
-
-      <child>
-	<widget class="GtkHBox" id="hbox14">
-	  <property name="visible">True</property>
-	  <property name="homogeneous">False</property>
-	  <property name="spacing">0</property>
-
-	  <child>
-	    <widget class="GtkHandleBox" id="handlebox1">
-	      <property name="visible">True</property>
-	      <property name="shadow_type">GTK_SHADOW_NONE</property>
-	      <property name="handle_position">GTK_POS_TOP</property>
-	      <property name="snap_edge">GTK_POS_TOP</property>
-
-	      <child>
-		<widget class="GtkVBox" id="vbox2">
-		  <property name="visible">True</property>
-		  <property name="homogeneous">False</property>
-		  <property name="spacing">0</property>
-
-		  <child>
-		    <widget class="GtkButton" id="buttonFilters">
-		      <property name="visible">True</property>
-		      <property name="tooltip" translatable="yes">Video filters</property>
-		      <property name="can_focus">True</property>
-		      <property name="label" translatable="yes">V Filter  [F1]</property>
-		      <property name="use_underline">True</property>
-		      <property name="relief">GTK_RELIEF_NORMAL</property>
-		      <accelerator key="F1" modifiers="0" signal="clicked"/>
-		    </widget>
-		    <packing>
-		      <property name="padding">0</property>
-		      <property name="expand">False</property>
-		      <property name="fill">False</property>
-		    </packing>
-		  </child>
-
-		  <child>
-		    <widget class="GtkButton" id="buttonAudioFilter">
-		      <property name="visible">True</property>
-		      <property name="tooltip" translatable="yes">Audio filters</property>
-		      <property name="can_focus">True</property>
-		      <property name="label" translatable="yes">A Filter  [F2]</property>
-		      <property name="use_underline">True</property>
-		      <property name="relief">GTK_RELIEF_NORMAL</property>
-		      <accelerator key="F2" modifiers="0" signal="clicked"/>
-		    </widget>
-		    <packing>
-		      <property name="padding">0</property>
-		      <property name="expand">False</property>
-		      <property name="fill">False</property>
-		    </packing>
-		  </child>
-
-		  <child>
-		    <widget class="GtkButton" id="buttonVCodec">
-		      <property name="visible">True</property>
-		      <property name="tooltip" translatable="yes">Video codec</property>
-		      <property name="can_focus">True</property>
-		      <property name="label" translatable="yes">V Codec [F3]</property>
-		      <property name="use_underline">True</property>
-		      <property name="relief">GTK_RELIEF_NORMAL</property>
-		      <accelerator key="F3" modifiers="0" signal="clicked"/>
-		    </widget>
-		    <packing>
-		      <property name="padding">0</property>
-		      <property name="expand">False</property>
-		      <property name="fill">False</property>
-		    </packing>
-		  </child>
-
-		  <child>
-		    <widget class="GtkButton" id="buttonACodec">
-		      <property name="visible">True</property>
-		      <property name="tooltip" translatable="yes">Audio codec</property>
-		      <property name="can_focus">True</property>
-		      <property name="label" translatable="yes">A Codec [F4]</property>
-		      <property name="use_underline">True</property>
-		      <property name="relief">GTK_RELIEF_NORMAL</property>
-		      <accelerator key="F4" modifiers="0" signal="clicked"/>
-		    </widget>
-		    <packing>
-		      <property name="padding">0</property>
-		      <property name="expand">False</property>
-		      <property name="fill">False</property>
-		    </packing>
-		  </child>
-
-		  <child>
-		    <widget class="GtkToggleButton" id="togglebuttonVideo">
-		      <property name="visible">True</property>
-		      <property name="tooltip" translatable="yes">Process video</property>
-		      <property name="can_focus">True</property>
-		      <property name="label" translatable="yes">V Process[F5]</property>
-		      <property name="use_underline">True</property>
-		      <property name="relief">GTK_RELIEF_NORMAL</property>
-		      <property name="active">False</property>
-		      <property name="inconsistent">False</property>
-		      <accelerator key="F1" modifiers="0" signal="clicked"/>
-		      <accelerator key="F5" modifiers="0" signal="clicked"/>
-		    </widget>
-		    <packing>
-		      <property name="padding">0</property>
-		      <property name="expand">False</property>
-		      <property name="fill">False</property>
-		    </packing>
-		  </child>
-
-		  <child>
-		    <widget class="GtkToggleButton" id="togglebuttonAudio">
-		      <property name="visible">True</property>
-		      <property name="tooltip" translatable="yes">Process audio</property>
-		      <property name="can_focus">True</property>
-		      <property name="label" translatable="yes">A Process[F6]</property>
-		      <property name="use_underline">True</property>
-		      <property name="relief">GTK_RELIEF_NORMAL</property>
-		      <property name="active">False</property>
-		      <property name="inconsistent">False</property>
-		      <accelerator key="F2" modifiers="0" signal="clicked"/>
-		      <accelerator key="F6" modifiers="0" signal="clicked"/>
-		    </widget>
-		    <packing>
-		      <property name="padding">0</property>
-		      <property name="expand">False</property>
-		      <property name="fill">False</property>
-		    </packing>
-		  </child>
-
-		  <child>
-		    <widget class="GtkToggleButton" id="togglebuttonPreview">
-		      <property name="visible">True</property>
-		      <property name="tooltip" translatable="yes">Open a preview window</property>
-		      <property name="can_focus">True</property>
-		      <property name="label" translatable="yes">Preview   [F7]</property>
-		      <property name="use_underline">True</property>
-		      <property name="relief">GTK_RELIEF_NORMAL</property>
-		      <property name="active">False</property>
-		      <property name="inconsistent">False</property>
-		      <accelerator key="F7" modifiers="0" signal="clicked"/>
-		    </widget>
-		    <packing>
-		      <property name="padding">0</property>
-		      <property name="expand">False</property>
-		      <property name="fill">False</property>
-		    </packing>
-		  </child>
-
-		  <child>
-		    <widget class="GtkToggleButton" id="toggleOutput">
-		      <property name="visible">True</property>
-		      <property name="tooltip" translatable="yes">Display output video (playback only)</property>
-		      <property name="can_focus">True</property>
-		      <property name="label" translatable="yes">Output    [F8]</property>
-		      <property name="use_underline">True</property>
-		      <property name="relief">GTK_RELIEF_NORMAL</property>
-		      <property name="active">False</property>
-		      <property name="inconsistent">False</property>
-		      <accelerator key="F8" modifiers="0" signal="clicked"/>
-		    </widget>
-		    <packing>
-		      <property name="padding">0</property>
-		      <property name="expand">False</property>
-		      <property name="fill">False</property>
-		    </packing>
-		  </child>
-		</widget>
-	      </child>
-	    </widget>
-	    <packing>
-	      <property name="padding">0</property>
-	      <property name="expand">False</property>
-	      <property name="fill">False</property>
-	    </packing>
-	  </child>
-
-	  <child>
-	    <widget class="GtkDrawingArea" id="guiDrawing">
-	      <property name="width_request">512</property>
-	      <property name="height_request">280</property>
-	      <property name="visible">True</property>
-	      <property name="sensitive">False</property>
-	    </widget>
-	    <packing>
-	      <property name="padding">0</property>
-	      <property name="expand">True</property>
-	      <property name="fill">True</property>
-	    </packing>
-	  </child>
-	</widget>
-	<packing>
-	  <property name="padding">0</property>
-	  <property name="expand">False</property>
-	  <property name="fill">False</property>
-	</packing>
-      </child>
-
-      <child>
-	<widget class="GtkHScale" id="sliderNavigate">
-	  <property name="height_request">24</property>
-	  <property name="visible">True</property>
-	  <property name="draw_value">True</property>
-	  <property name="value_pos">GTK_POS_LEFT</property>
-	  <property name="digits">1</property>
-	  <property name="update_policy">GTK_UPDATE_CONTINUOUS</property>
-	  <property name="inverted">False</property>
-	  <property name="adjustment">0 0 99.99 0.01 1 0</property>
-	</widget>
-	<packing>
-	  <property name="padding">0</property>
-	  <property name="expand">True</property>
-	  <property name="fill">False</property>
-	</packing>
-      </child>
-
-      <child>
-	<widget class="GtkHBox" id="hbox17">
-	  <property name="visible">True</property>
-	  <property name="homogeneous">False</property>
-	  <property name="spacing">0</property>
-
-	  <child>
-	    <widget class="GtkVBox" id="vbox3">
-	      <property name="visible">True</property>
-	      <property name="homogeneous">False</property>
-	      <property name="spacing">0</property>
-
-	      <child>
-		<widget class="GtkHandleBox" id="handlebox3">
-		  <property name="visible">True</property>
-		  <property name="shadow_type">GTK_SHADOW_NONE</property>
-		  <property name="handle_position">GTK_POS_LEFT</property>
-		  <property name="snap_edge">GTK_POS_TOP</property>
-
-		  <child>
-		    <widget class="GtkHBox" id="hbox10">
-		      <property name="height_request">24</property>
-		      <property name="visible">True</property>
-		      <property name="homogeneous">False</property>
-		      <property name="spacing">0</property>
-
-		      <child>
-			<widget class="GtkButton" id="buttonPlay">
-			  <property name="visible">True</property>
-			  <property name="tooltip" translatable="yes">Start/stop playback</property>
-			  <property name="relief">GTK_RELIEF_NORMAL</property>
-			  <accelerator key="space" modifiers="0" signal="clicked"/>
-
-			  <child>
-			    <widget class="GtkImage" id="image591">
-			      <property name="visible">True</property>
-			      <property name="pixbuf">play.xpm</property>
-			      <property name="xalign">0.5</property>
-			      <property name="yalign">0.5</property>
-			      <property name="xpad">0</property>
-			      <property name="ypad">0</property>
-			    </widget>
-			  </child>
-			</widget>
-			<packing>
-			  <property name="padding">0</property>
-			  <property name="expand">False</property>
-			  <property name="fill">False</property>
-			</packing>
-		      </child>
-
-		      <child>
-			<widget class="GtkButton" id="buttonStop">
-			  <property name="visible">True</property>
-			  <property name="tooltip" translatable="yes">Stop</property>
-			  <property name="relief">GTK_RELIEF_NORMAL</property>
-			  <accelerator key="P" modifiers="0" signal="clicked"/>
-
-			  <child>
-			    <widget class="GtkImage" id="image592">
-			      <property name="visible">True</property>
-			      <property name="pixbuf">stop.xpm</property>
-			      <property name="xalign">0.5</property>
-			      <property name="yalign">0.5</property>
-			      <property name="xpad">0</property>
-			      <property name="ypad">0</property>
-			    </widget>
-			  </child>
-			</widget>
-			<packing>
-			  <property name="padding">0</property>
-			  <property name="expand">False</property>
-			  <property name="fill">False</property>
-			</packing>
-		      </child>
-
-		      <child>
-			<widget class="GtkButton" id="buttonPrevFrame">
-			  <property name="visible">True</property>
-			  <property name="tooltip" translatable="yes">Previous frame [4]</property>
-			  <property name="relief">GTK_RELIEF_NORMAL</property>
-			  <accelerator key="KP_4" modifiers="0" signal="clicked"/>
-
-			  <child>
-			    <widget class="GtkImage" id="image593">
-			      <property name="visible">True</property>
-			      <property name="pixbuf">backward.xpm</property>
-			      <property name="xalign">0.5</property>
-			      <property name="yalign">0.5</property>
-			      <property name="xpad">0</property>
-			      <property name="ypad">0</property>
-			    </widget>
-			  </child>
-			</widget>
-			<packing>
-			  <property name="padding">0</property>
-			  <property name="expand">False</property>
-			  <property name="fill">False</property>
-			</packing>
-		      </child>
-
-		      <child>
-			<widget class="GtkButton" id="buttonNextFrame">
-			  <property name="visible">True</property>
-			  <property name="tooltip" translatable="yes">Next frame [6]</property>
-			  <property name="relief">GTK_RELIEF_NORMAL</property>
-			  <accelerator key="KP_6" modifiers="0" signal="clicked"/>
-
-			  <child>
-			    <widget class="GtkImage" id="image594">
-			      <property name="visible">True</property>
-			      <property name="pixbuf">forward.xpm</property>
-			      <property name="xalign">0.5</property>
-			      <property name="yalign">0.5</property>
-			      <property name="xpad">0</property>
-			      <property name="ypad">0</property>
-			    </widget>
-			  </child>
-			</widget>
-			<packing>
-			  <property name="padding">0</property>
-			  <property name="expand">False</property>
-			  <property name="fill">False</property>
-			</packing>
-		      </child>
-
-		      <child>
-			<widget class="GtkButton" id="buttonPrevKFrame">
-			  <property name="visible">True</property>
-			  <property name="tooltip" translatable="yes">Previous keyframe[2]</property>
-			  <property name="relief">GTK_RELIEF_NORMAL</property>
-			  <accelerator key="KP_2" modifiers="0" signal="clicked"/>
-
-			  <child>
-			    <widget class="GtkImage" id="image595">
-			      <property name="visible">True</property>
-			      <property name="pixbuf">Kbackward.xpm</property>
-			      <property name="xalign">0.5</property>
-			      <property name="yalign">0.5</property>
-			      <property name="xpad">0</property>
-			      <property name="ypad">0</property>
-			    </widget>
-			  </child>
-			</widget>
-			<packing>
-			  <property name="padding">0</property>
-			  <property name="expand">False</property>
-			  <property name="fill">False</property>
-			</packing>
-		      </child>
-
-		      <child>
-			<widget class="GtkButton" id="buttonNextKFrame">
-			  <property name="visible">True</property>
-			  <property name="tooltip" translatable="yes">Next keyframe[8]</property>
-			  <property name="relief">GTK_RELIEF_NORMAL</property>
-			  <accelerator key="KP_8" modifiers="0" signal="clicked"/>
-
-			  <child>
-			    <widget class="GtkImage" id="image596">
-			      <property name="visible">True</property>
-			      <property name="pixbuf">Kforward.xpm</property>
-			      <property name="xalign">0.5</property>
-			      <property name="yalign">0.5</property>
-			      <property name="xpad">0</property>
-			      <property name="ypad">0</property>
-			    </widget>
-			  </child>
-			</widget>
-			<packing>
-			  <property name="padding">0</property>
-			  <property name="expand">False</property>
-			  <property name="fill">False</property>
-			</packing>
-		      </child>
-
-		      <child>
-			<widget class="GtkButton" id="buttonMarkA">
-			  <property name="visible">True</property>
-			  <property name="tooltip" translatable="yes">Selection: start</property>
-			  <property name="relief">GTK_RELIEF_NORMAL</property>
-
-			  <child>
-			    <widget class="GtkImage" id="image597">
-			      <property name="visible">True</property>
-			      <property name="pixbuf">markA.xpm</property>
-			      <property name="xalign">0.5</property>
-			      <property name="yalign">0.5</property>
-			      <property name="xpad">0</property>
-			      <property name="ypad">0</property>
-			    </widget>
-			  </child>
-			</widget>
-			<packing>
-			  <property name="padding">0</property>
-			  <property name="expand">False</property>
-			  <property name="fill">False</property>
-			</packing>
-		      </child>
-
-		      <child>
-			<widget class="GtkButton" id="buttonMarkB">
-			  <property name="visible">True</property>
-			  <property name="tooltip" translatable="yes">Selection: end</property>
-			  <property name="relief">GTK_RELIEF_NORMAL</property>
-
-			  <child>
-			    <widget class="GtkImage" id="image598">
-			      <property name="visible">True</property>
-			      <property name="pixbuf">markB.xpm</property>
-			      <property name="xalign">0.5</property>
-			      <property name="yalign">0.5</property>
-			      <property name="xpad">0</property>
-			      <property name="ypad">0</property>
-			    </widget>
-			  </child>
-			</widget>
-			<packing>
-			  <property name="padding">0</property>
-			  <property name="expand">False</property>
-			  <property name="fill">False</property>
-			</packing>
-		      </child>
-
-		      <child>
-			<widget class="GtkButton" id="buttonBegin">
-			  <property name="visible">True</property>
-			  <property name="tooltip" translatable="yes">First frame</property>
-			  <property name="relief">GTK_RELIEF_NORMAL</property>
-			  <accelerator key="Home" modifiers="0" signal="clicked"/>
-
-			  <child>
-			    <widget class="GtkImage" id="image599">
-			      <property name="visible">True</property>
-			      <property name="pixbuf">begin.xpm</property>
-			      <property name="xalign">0.5</property>
-			      <property name="yalign">0.5</property>
-			      <property name="xpad">0</property>
-			      <property name="ypad">0</property>
-			    </widget>
-			  </child>
-			</widget>
-			<packing>
-			  <property name="padding">0</property>
-			  <property name="expand">False</property>
-			  <property name="fill">False</property>
-			</packing>
-		      </child>
-
-		      <child>
-			<widget class="GtkButton" id="buttonEnd">
-			  <property name="visible">True</property>
-			  <property name="tooltip" translatable="yes">Last frame</property>
-			  <property name="relief">GTK_RELIEF_NORMAL</property>
-			  <accelerator key="End" modifiers="0" signal="clicked"/>
-
-			  <child>
-			    <widget class="GtkImage" id="image600">
-			      <property name="visible">True</property>
-			      <property name="pixbuf">end.xpm</property>
-			      <property name="xalign">0.5</property>
-			      <property name="yalign">0.5</property>
-			      <property name="xpad">0</property>
-			      <property name="ypad">0</property>
-			    </widget>
-			  </child>
-			</widget>
-			<packing>
-			  <property name="padding">0</property>
-			  <property name="expand">False</property>
-			  <property name="fill">False</property>
-			</packing>
-		      </child>
-
-		      <child>
-			<widget class="GtkButton" id="buttonPrevBlack">
-			  <property name="visible">True</property>
-			  <property name="tooltip" translatable="yes">Previous black frame</property>
-			  <property name="relief">GTK_RELIEF_NORMAL</property>
-
-			  <child>
-			    <widget class="GtkImage" id="image601">
-			      <property name="visible">True</property>
-			      <property name="pixbuf">xpm_prevblack.xpm</property>
-			      <property name="xalign">0.5</property>
-			      <property name="yalign">0.5</property>
-			      <property name="xpad">0</property>
-			      <property name="ypad">0</property>
-			    </widget>
-			  </child>
-			</widget>
-			<packing>
-			  <property name="padding">0</property>
-			  <property name="expand">False</property>
-			  <property name="fill">False</property>
-			</packing>
-		      </child>
-
-		      <child>
-			<widget class="GtkButton" id="buttonNextBlack">
-			  <property name="visible">True</property>
-			  <property name="tooltip" translatable="yes">Next black frame</property>
-			  <property name="relief">GTK_RELIEF_NORMAL</property>
-
-			  <child>
-			    <widget class="GtkImage" id="image602">
-			      <property name="visible">True</property>
-			      <property name="pixbuf">xpm_nextblack.xpm</property>
-			      <property name="xalign">0.5</property>
-			      <property name="yalign">0.5</property>
-			      <property name="xpad">0</property>
-			      <property name="ypad">0</property>
-			    </widget>
-			  </child>
-			</widget>
-			<packing>
-			  <property name="padding">0</property>
-			  <property name="expand">False</property>
-			  <property name="fill">False</property>
-			</packing>
-		      </child>
-		    </widget>
-		  </child>
-		</widget>
-		<packing>
-		  <property name="padding">0</property>
-		  <property name="expand">True</property>
-		  <property name="fill">False</property>
-		</packing>
-	      </child>
-
-	      <child>
-		<widget class="GtkHBox" id="hbox16">
-		  <property name="border_width">3</property>
-		  <property name="visible">True</property>
-		  <property name="homogeneous">False</property>
-		  <property name="spacing">5</property>
-
-		  <child>
-		    <widget class="GtkLabel" id="label1">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Frame: </property>
-		      <property name="use_underline">False</property>
-		      <property name="use_markup">False</property>
-		      <property name="justify">GTK_JUSTIFY_LEFT</property>
-		      <property name="wrap">False</property>
-		      <property name="selectable">False</property>
-		      <property name="xalign">0.5</property>
-		      <property name="yalign">0.5</property>
-		      <property name="xpad">0</property>
-		      <property name="ypad">0</property>
-		    </widget>
-		    <packing>
-		      <property name="padding">0</property>
-		      <property name="expand">False</property>
-		      <property name="fill">False</property>
-		    </packing>
-		  </child>
-
-		  <child>
-		    <widget class="GtkEntry" id="boxCurFrame">
-		      <property name="visible">True</property>
-		      <property name="tooltip" translatable="yes">Current frame</property>
-		      <property name="can_focus">True</property>
-		      <property name="editable">True</property>
-		      <property name="visibility">True</property>
-		      <property name="max_length">8</property>
-		      <property name="text" translatable="yes">0</property>
-		      <property name="has_frame">True</property>
-		      <property name="invisible_char" translatable="yes">*</property>
-		      <property name="activates_default">False</property>
-		      <property name="width_chars">8</property>
-		    </widget>
-		    <packing>
-		      <property name="padding">0</property>
-		      <property name="expand">False</property>
-		      <property name="fill">False</property>
-		    </packing>
-		  </child>
-
-		  <child>
-		    <widget class="GtkLabel" id="labelTotalFrame">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">/0000000</property>
-		      <property name="use_underline">False</property>
-		      <property name="use_markup">False</property>
-		      <property name="justify">GTK_JUSTIFY_LEFT</property>
-		      <property name="wrap">False</property>
-		      <property name="selectable">False</property>
-		      <property name="xalign">0.5</property>
-		      <property name="yalign">0.5</property>
-		      <property name="xpad">5</property>
-		      <property name="ypad">0</property>
-		    </widget>
-		    <packing>
-		      <property name="padding">0</property>
-		      <property name="expand">False</property>
-		      <property name="fill">False</property>
-		    </packing>
-		  </child>
-
-		  <child>
-		    <widget class="GtkLabel" id="label4">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Time: </property>
-		      <property name="use_underline">False</property>
-		      <property name="use_markup">False</property>
-		      <property name="justify">GTK_JUSTIFY_LEFT</property>
-		      <property name="wrap">False</property>
-		      <property name="selectable">False</property>
-		      <property name="xalign">0.5</property>
-		      <property name="yalign">0.5</property>
-		      <property name="xpad">0</property>
-		      <property name="ypad">0</property>
-		    </widget>
-		    <packing>
-		      <property name="padding">0</property>
-		      <property name="expand">False</property>
-		      <property name="fill">False</property>
-		    </packing>
-		  </child>
-
-		  <child>
-		    <widget class="GtkEntry" id="boxCurTime">
-		      <property name="visible">True</property>
-		      <property name="tooltip" translatable="yes">Current time</property>
-		      <property name="can_focus">True</property>
-		      <property name="editable">True</property>
-		      <property name="visibility">True</property>
-		      <property name="max_length">0</property>
-		      <property name="text" translatable="yes">00:00:00.000</property>
-		      <property name="has_frame">True</property>
-		      <property name="invisible_char" translatable="yes">*</property>
-		      <property name="activates_default">False</property>
-		      <property name="width_chars">13</property>
-		    </widget>
-		    <packing>
-		      <property name="padding">0</property>
-		      <property name="expand">False</property>
-		      <property name="fill">False</property>
-		    </packing>
-		  </child>
-
-		  <child>
-		    <widget class="GtkLabel" id="labelTotalTime">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">/00:00:00,000</property>
-		      <property name="use_underline">False</property>
-		      <property name="use_markup">False</property>
-		      <property name="justify">GTK_JUSTIFY_LEFT</property>
-		      <property name="wrap">False</property>
-		      <property name="selectable">False</property>
-		      <property name="xalign">0.5</property>
-		      <property name="yalign">0.5</property>
-		      <property name="xpad">5</property>
-		      <property name="ypad">0</property>
-		    </widget>
-		    <packing>
-		      <property name="padding">0</property>
-		      <property name="expand">False</property>
-		      <property name="fill">False</property>
-		    </packing>
-		  </child>
-
-		  <child>
-		    <widget class="GtkLabel" id="labelFrameType">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Frame: ?</property>
-		      <property name="use_underline">False</property>
-		      <property name="use_markup">False</property>
-		      <property name="justify">GTK_JUSTIFY_LEFT</property>
-		      <property name="wrap">False</property>
-		      <property name="selectable">False</property>
-		      <property name="xalign">0.5</property>
-		      <property name="yalign">0.5</property>
-		      <property name="xpad">0</property>
-		      <property name="ypad">0</property>
-		    </widget>
-		    <packing>
-		      <property name="padding">0</property>
-		      <property name="expand">False</property>
-		      <property name="fill">False</property>
-		    </packing>
-		  </child>
-		</widget>
-		<packing>
-		  <property name="padding">0</property>
-		  <property name="expand">True</property>
-		  <property name="fill">False</property>
-		</packing>
-	      </child>
-	    </widget>
-	    <packing>
-	      <property name="padding">0</property>
-	      <property name="expand">True</property>
-	      <property name="fill">True</property>
-	    </packing>
-	  </child>
-
-	  <child>
-	    <widget class="GtkFrame" id="frame1">
-	      <property name="border_width">3</property>
-	      <property name="visible">True</property>
-	      <property name="label_xalign">0</property>
-	      <property name="label_yalign">0.5</property>
-	      <property name="shadow_type">GTK_SHADOW_ETCHED_IN</property>
-
-	      <child>
-		<widget class="GtkVBox" id="vbox4">
-		  <property name="border_width">3</property>
-		  <property name="visible">True</property>
-		  <property name="homogeneous">False</property>
-		  <property name="spacing">0</property>
-
-		  <child>
-		    <widget class="GtkLabel" id="labelMarkA">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">A: 0000000</property>
-		      <property name="use_underline">False</property>
-		      <property name="use_markup">False</property>
-		      <property name="justify">GTK_JUSTIFY_LEFT</property>
-		      <property name="wrap">False</property>
-		      <property name="selectable">False</property>
-		      <property name="xalign">0.5</property>
-		      <property name="yalign">0.5</property>
-		      <property name="xpad">0</property>
-		      <property name="ypad">0</property>
-		    </widget>
-		    <packing>
-		      <property name="padding">0</property>
-		      <property name="expand">False</property>
-		      <property name="fill">False</property>
-		    </packing>
-		  </child>
-
-		  <child>
-		    <widget class="GtkLabel" id="labelMarkB">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">B: 0000000</property>
-		      <property name="use_underline">False</property>
-		      <property name="use_markup">False</property>
-		      <property name="justify">GTK_JUSTIFY_LEFT</property>
-		      <property name="wrap">False</property>
-		      <property name="selectable">False</property>
-		      <property name="xalign">0.5</property>
-		      <property name="yalign">0.5</property>
-		      <property name="xpad">0</property>
-		      <property name="ypad">0</property>
-		    </widget>
-		    <packing>
-		      <property name="padding">0</property>
-		      <property name="expand">False</property>
-		      <property name="fill">False</property>
-		    </packing>
-		  </child>
-		</widget>
-	      </child>
-
-	      <child>
-		<widget class="GtkLabel" id="label16">
-		  <property name="visible">True</property>
-		  <property name="label" translatable="yes">Selection</property>
-		  <property name="use_underline">False</property>
-		  <property name="use_markup">False</property>
-		  <property name="justify">GTK_JUSTIFY_LEFT</property>
-		  <property name="wrap">False</property>
-		  <property name="selectable">False</property>
-		  <property name="xalign">0.5</property>
-		  <property name="yalign">0.5</property>
-		  <property name="xpad">0</property>
-		  <property name="ypad">0</property>
-		</widget>
-		<packing>
-		  <property name="type">label_item</property>
-		</packing>
-	      </child>
-	    </widget>
-	    <packing>
-	      <property name="padding">0</property>
-	      <property name="expand">True</property>
-	      <property name="fill">True</property>
-	    </packing>
-	  </child>
-	</widget>
-	<packing>
-	  <property name="padding">0</property>
-	  <property name="expand">True</property>
-	  <property name="fill">True</property>
-	</packing>
-      </child>
-    </widget>
-  </child>
-</widget>
-
-</glade-interface>



From mean at mail.berlios.de  Sun Jan 21 19:22:14 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 21 Jan 2007 19:22:14 +0100
Subject: [Avidemux-svn-commit] r2751 -
	branches/avidemux_2.4_branch/avidemux/ADM_codecs
Message-ID: <200701211822.l0LIMEp7020810@sheep.berlios.de>

Author: mean
Date: 2007-01-21 19:22:14 +0100 (Sun, 21 Jan 2007)
New Revision: 2751

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_ffmp43.cpp
Log:
update to ffmpeg svn

Modified: branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_ffmp43.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_ffmp43.cpp	2007-01-21 18:19:12 UTC (rev 2750)
+++ branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_ffmp43.cpp	2007-01-21 18:22:14 UTC (rev 2751)
@@ -418,10 +418,11 @@
       return 0;
     }
     clonePic (&_frame, out);
+    #if 0
     printf("Frame bitstream order : %u, display order %u Incoming :%u outgoing :%u\n",_frame.coded_picture_number,_frame.display_picture_number,
          in->demuxerFrameNo,out->demuxerFrameno);
     printf("in flags :%x out flags :%x\n",in->flags, out->flags);
-  
+ #endif 
   return 1;
 }
 
@@ -450,7 +451,7 @@
   printf ("Using %d bytes of extradata for MPEG4 decoder\n", l);
   
   _refCopy = 1;			// YUV420 only
-  _context->extradata = (void *) d;
+  _context->extradata = (uint8_t *) d;
   _context->extradata_size = (int) l;
   decoderMultiThread ();
   //  _context->flags|=FF_DEBUG_VIS_MV;
@@ -459,7 +460,7 @@
 decoderFFDV::decoderFFDV (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,
 	   h)
 {
-  _context->extradata = (void *) d;
+  _context->extradata = (uint8_t *) d;
   _context->extradata_size = (int) l;
   WRAP_Open (CODEC_ID_DVVIDEO);
 
@@ -487,7 +488,7 @@
     got_picture = 0;
 
   LOWDELAY();
-  _context->extradata = (void *) extraData;
+  _context->extradata = (uint8_t *) extraData;
   _context->extradata_size = (int) extraLen;
   WRAP_Open (CODEC_ID_SVQ3);
 }
@@ -506,7 +507,7 @@
 decoderFF_ffhuff::decoderFF_ffhuff (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,
 	   h)
 {
-  _context->extradata = (void *) d;
+  _context->extradata = (uint8_t *) d;
   _context->extradata_size = (int) l;
   printf ("FFhuff: We have :%d bytes of extra data\n", l);
   WRAP_Open (CODEC_ID_FFVHUFF);
@@ -517,7 +518,7 @@
 {
   _lowDelay=lowdelay;
   _refCopy = 1;			// YUV420 only
-  _context->extradata = (void *) d;
+  _context->extradata = (uint8_t *) d;
   _context->extradata_size = (int) l;
   if(lowdelay)
     LOWDELAY();
@@ -528,7 +529,7 @@
 decoderFFhuff::decoderFFhuff (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,
 	   h)
 {
-  _context->extradata = (void *) d;
+  _context->extradata = (uint8_t *) d;
   _context->extradata_size = (int) l;
 
   WRAP_Open (CODEC_ID_HUFFYUV);
@@ -536,7 +537,7 @@
 decoderFFWMV2::decoderFFWMV2 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,
 	   h)
 {
-  _context->extradata = (void *) d;
+  _context->extradata = (uint8_t *) d;
   _context->extradata_size = (int) l;
 
   WRAP_Open (CODEC_ID_WMV2);
@@ -545,7 +546,7 @@
 decoderFFWMV1::decoderFFWMV1 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,
 	   h)
 {
-  _context->extradata = (void *) d;
+  _context->extradata = (uint8_t *) d;
   _context->extradata_size = (int) l;
 
   WRAP_Open (CODEC_ID_WMV1);
@@ -555,7 +556,7 @@
 decoderFFWMV3::decoderFFWMV3 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,
 	   h)
 {
-  _context->extradata = (void *) d;
+  _context->extradata = (uint8_t *) d;
   _context->extradata_size = (int) l;
 
   WRAP_Open (CODEC_ID_WMV3);
@@ -564,7 +565,7 @@
 decoderFFcyuv::decoderFFcyuv (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,
 	   h)
 {
-  _context->extradata = (void *) d;
+  _context->extradata = (uint8_t *) d;
   _context->extradata_size = (int) l;
 
   WRAP_Open (CODEC_ID_CYUV);
@@ -576,7 +577,7 @@
 decoderFFTheora::decoderFFTheora (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,
 	   h)
 {
-  _context->extradata = (void *) d;
+  _context->extradata = (uint8_t *) d;
   _context->extradata_size = (int) l;
   WRAP_Open (CODEC_ID_THEORA);
 }



From mean at mail.berlios.de  Sun Jan 21 19:27:24 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 21 Jan 2007 19:27:24 +0100
Subject: [Avidemux-svn-commit] r2752 -
	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil
Message-ID: <200701211827.l0LIRO67021031@sheep.berlios.de>

Author: mean
Date: 2007-01-21 19:27:24 +0100 (Sun, 21 Jan 2007)
New Revision: 2752

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/intreadwrite.h
Log:
new file

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/intreadwrite.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/intreadwrite.h	2007-01-21 18:22:14 UTC (rev 2751)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/intreadwrite.h	2007-01-21 18:27:24 UTC (rev 2752)
@@ -0,0 +1,65 @@
+#ifndef INTREADWRITE_H
+#define INTREADWRITE_H
+
+#ifdef __GNUC__
+
+struct unaligned_64 { uint64_t l; } __attribute__((packed));
+struct unaligned_32 { uint32_t l; } __attribute__((packed));
+struct unaligned_16 { uint16_t l; } __attribute__((packed));
+
+#define LD16(a) (((const struct unaligned_16 *) (a))->l)
+#define LD32(a) (((const struct unaligned_32 *) (a))->l)
+#define LD64(a) (((const struct unaligned_64 *) (a))->l)
+
+#define ST16(a, b) (((struct unaligned_16 *) (a))->l) = (b)
+#define ST32(a, b) (((struct unaligned_32 *) (a))->l) = (b)
+
+#else /* __GNUC__ */
+
+#define LD16(a) (*((uint16_t*)(a)))
+#define LD32(a) (*((uint32_t*)(a)))
+#define LD64(a) (*((uint64_t*)(a)))
+
+#define ST16(a, b) *((uint16_t*)(a)) = (b)
+#define ST32(a, b) *((uint32_t*)(a)) = (b)
+
+#endif /* !__GNUC__ */
+
+/* endian macros */
+#define AV_RB8(x)  (((uint8_t*)(x))[0])
+#define AV_WB8(p, i, d)  { ((uint8_t*)(p))[(i)] = (d); }
+
+#define AV_RB16(x) ((((uint8_t*)(x))[0] << 8) | ((uint8_t*)(x))[1])
+#define AV_WB16(p, i, d) { \
+                    ((uint8_t*)(p))[(i)+1] = (d); \
+                    ((uint8_t*)(p))[(i)] = (d)>>8; }
+
+#define AV_RB32(x) ((((uint8_t*)(x))[0] << 24) | \
+                   (((uint8_t*)(x))[1] << 16) | \
+                   (((uint8_t*)(x))[2] << 8) | \
+                    ((uint8_t*)(x))[3])
+#define AV_WB32(p, i, d) { \
+                    ((uint8_t*)(p))[(i)+3] = (d); \
+                    ((uint8_t*)(p))[(i)+2] = (d)>>8; \
+                    ((uint8_t*)(p))[(i)+1] = (d)>>16; \
+                    ((uint8_t*)(p))[(i)] = (d)>>24; }
+
+#define AV_RL8(x)  AV_RB8(x)
+#define AV_WL8(p, i, d)  AV_WB8(p, i, d)
+
+#define AV_RL16(x) ((((uint8_t*)(x))[1] << 8) | ((uint8_t*)(x))[0])
+#define AV_WL16(p, i, d) { \
+                    ((uint8_t*)(p))[(i)] = (d); \
+                    ((uint8_t*)(p))[(i)+1] = (d)>>8; }
+
+#define AV_RL32(x) ((((uint8_t*)(x))[3] << 24) | \
+                   (((uint8_t*)(x))[2] << 16) | \
+                   (((uint8_t*)(x))[1] << 8) | \
+                    ((uint8_t*)(x))[0])
+#define AV_WL32(p, i, d) { \
+                    ((uint8_t*)(p))[(i)] = (d); \
+                    ((uint8_t*)(p))[(i)+1] = (d)>>8; \
+                    ((uint8_t*)(p))[(i)+2] = (d)>>16; \
+                    ((uint8_t*)(p))[(i)+3] = (d)>>24; }
+
+#endif /* INTREADWRITE_H */



From mean at mail.berlios.de  Sun Jan 21 19:28:25 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 21 Jan 2007 19:28:25 +0100
Subject: [Avidemux-svn-commit] r2753 -
	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec
Message-ID: <200701211828.l0LISPtM021071@sheep.berlios.de>

Author: mean
Date: 2007-01-21 19:28:25 +0100 (Sun, 21 Jan 2007)
New Revision: 2753

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/parser.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/ratecontrol.h
Log:
new files

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/parser.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/parser.h	2007-01-21 18:27:24 UTC (rev 2752)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/parser.h	2007-01-21 18:28:25 UTC (rev 2753)
@@ -0,0 +1,63 @@
+/*
+ * AVCodecParser prototypes and definitions
+ * Copyright (c) 2003 Fabrice Bellard.
+ * Copyright (c) 2003 Michael Niedermayer.
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef FFMPEG_PARSER_H
+#define FFMPEG_PARSER_H
+
+typedef struct ParseContext{
+    uint8_t *buffer;
+    int index;
+    int last_index;
+    unsigned int buffer_size;
+    uint32_t state;             ///< contains the last few bytes in MSB order
+    int frame_start_found;
+    int overread;               ///< the number of bytes which where irreversibly read from the next frame
+    int overread_index;         ///< the index into ParseContext.buffer of the overreaded bytes
+} ParseContext;
+
+struct MpegEncContext;
+
+typedef struct ParseContext1{
+    ParseContext pc;
+/* XXX/FIXME PC1 vs. PC */
+    /* MPEG2 specific */
+    AVRational frame_rate;
+    int progressive_sequence;
+    int width, height;
+
+    /* XXX: suppress that, needed by MPEG4 */
+    struct MpegEncContext *enc;
+    int first_picture;
+} ParseContext1;
+
+#define END_NOT_FOUND (-100)
+
+int ff_combine_frame(ParseContext *pc, int next, uint8_t **buf, int *buf_size);
+int ff_mpeg4video_split(AVCodecContext *avctx, const uint8_t *buf,
+                        int buf_size);
+void ff_parse_close(AVCodecParserContext *s);
+void ff_parse1_close(AVCodecParserContext *s);
+
+/* h263dec.c */
+int ff_mpeg4_find_frame_end(ParseContext *pc, const uint8_t *buf, int buf_size);
+
+#endif /* !FFMPEG_PARSER_H */

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/ratecontrol.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/ratecontrol.h	2007-01-21 18:27:24 UTC (rev 2752)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/ratecontrol.h	2007-01-21 18:28:25 UTC (rev 2753)
@@ -0,0 +1,103 @@
+/*
+ * Ratecontrol
+ * Copyright (c) 2000, 2001, 2002 Fabrice Bellard.
+ * Copyright (c) 2002-2004 Michael Niedermayer
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_RATECONTROL_H
+#define AVCODEC_RATECONTROL_H
+
+/**
+ * @file ratecontrol.h
+ * ratecontrol header.
+ */
+
+#include "eval.h"
+
+typedef struct Predictor{
+    double coeff;
+    double count;
+    double decay;
+} Predictor;
+
+typedef struct RateControlEntry{
+    int pict_type;
+    float qscale;
+    int mv_bits;
+    int i_tex_bits;
+    int p_tex_bits;
+    int misc_bits;
+    int header_bits;
+    uint64_t expected_bits;
+    int new_pict_type;
+    float new_qscale;
+    int mc_mb_var_sum;
+    int mb_var_sum;
+    int i_count;
+    int skip_count;
+    int f_code;
+    int b_code;
+}RateControlEntry;
+
+/**
+ * rate control context.
+ */
+typedef struct RateControlContext{
+    FILE *stats_file;
+    int num_entries;              ///< number of RateControlEntries
+    RateControlEntry *entry;
+    double buffer_index;          ///< amount of bits in the video/audio buffer
+    Predictor pred[5];
+    double short_term_qsum;       ///< sum of recent qscales
+    double short_term_qcount;     ///< count of recent qscales
+    double pass1_rc_eq_output_sum;///< sum of the output of the rc equation, this is used for normalization
+    double pass1_wanted_bits;     ///< bits which should have been outputed by the pass1 code (including complexity init)
+    double last_qscale;
+    double last_qscale_for[5];    ///< last qscale for a specific pict type, used for max_diff & ipb factor stuff
+    int last_mc_mb_var_sum;
+    int last_mb_var_sum;
+    uint64_t i_cplx_sum[5];
+    uint64_t p_cplx_sum[5];
+    uint64_t mv_bits_sum[5];
+    uint64_t qscale_sum[5];
+    int frame_count[5];
+    int last_non_b_pict_type;
+
+    void *non_lavc_opaque;        ///< context for non lavc rc code (for example xvid)
+    float dry_run_qscale;         ///< for xvid rc
+    int last_picture_number;      ///< for xvid rc
+    AVEvalExpr * rc_eq_eval;
+}RateControlContext;
+
+struct MpegEncContext;
+
+/* rate control */
+int ff_rate_control_init(struct MpegEncContext *s);
+float ff_rate_estimate_qscale(struct MpegEncContext *s, int dry_run);
+void ff_write_pass1_stats(struct MpegEncContext *s);
+void ff_rate_control_uninit(struct MpegEncContext *s);
+int ff_vbv_update(struct MpegEncContext *s, int frame_size);
+void ff_get_2pass_fcode(struct MpegEncContext *s);
+
+int ff_xvid_rate_control_init(struct MpegEncContext *s);
+void ff_xvid_rate_control_uninit(struct MpegEncContext *s);
+float ff_xvid_rate_estimate_qscale(struct MpegEncContext *s, int dry_run);
+
+#endif /* AVCODEC_RATECONTROL_H */
+



From mean at mail.berlios.de  Sun Jan 21 19:29:18 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 21 Jan 2007 19:29:18 +0100
Subject: [Avidemux-svn-commit] r2754 -
	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec
Message-ID: <200701211829.l0LITICj021129@sheep.berlios.de>

Author: mean
Date: 2007-01-21 19:29:17 +0100 (Sun, 21 Jan 2007)
New Revision: 2754

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/eval.h
Log:
new files 

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/eval.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/eval.h	2007-01-21 18:28:25 UTC (rev 2753)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/eval.h	2007-01-21 18:29:17 UTC (rev 2754)
@@ -0,0 +1,84 @@
+/*
+ * simple arithmetic expression evaluator
+ *
+ * Copyright (c) 2002 Michael Niedermayer <michaelni at gmx.at>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file eval.h
+ * eval header.
+ */
+
+#ifndef AVCODEC_EVAL_H
+#define AVCODEC_EVAL_H
+
+#if LIBAVCODEC_VERSION_INT < ((52<<16)+(0<<8)+0)
+double ff_eval(char *s, double *const_value, const char **const_name,
+               double (**func1)(void *, double), const char **func1_name,
+               double (**func2)(void *, double, double), char **func2_name,
+               void *opaque);
+#endif
+
+/**
+ * Parses and evaluates an expression.
+ * Note, this is significantly slower than ff_parse_eval()
+ * @param s expression as a zero terminated string for example "1+2^3+5*5+sin(2/3)"
+ * @param func1 NULL terminated array of function pointers for functions which take 1 argument
+ * @param func2 NULL terminated array of function pointers for functions which take 2 arguments
+ * @param const_name NULL terminated array of zero terminated strings of constant identifers for example {"PI", "E", 0}
+ * @param func1_name NULL terminated array of zero terminated strings of func1 identifers
+ * @param func2_name NULL terminated array of zero terminated strings of func2 identifers
+ * @param error pointer to a char* which is set to an error message if something goes wrong
+ * @param const_value a zero terminated array of values for the identifers from const_name
+ * @param opaque a pointer which will be passed to all functions from func1 and func2
+ * @return the value of the expression
+ */
+double ff_eval2(char *s, double *const_value, const char **const_name,
+               double (**func1)(void *, double), const char **func1_name,
+               double (**func2)(void *, double, double), char **func2_name,
+               void *opaque, char **error);
+
+typedef struct ff_expr_s AVEvalExpr;
+
+/**
+ * Parses a expression.
+ * @param s expression as a zero terminated string for example "1+2^3+5*5+sin(2/3)"
+ * @param func1 NULL terminated array of function pointers for functions which take 1 argument
+ * @param func2 NULL terminated array of function pointers for functions which take 2 arguments
+ * @param const_name NULL terminated array of zero terminated strings of constant identifers for example {"PI", "E", 0}
+ * @param func1_name NULL terminated array of zero terminated strings of func1 identifers
+ * @param func2_name NULL terminated array of zero terminated strings of func2 identifers
+ * @param error pointer to a char* which is set to an error message if something goes wrong
+ * @return AVEvalExpr which must be freed with ff_eval_free by the user when its not needed anymore
+ *         NULL if anything went wrong
+ */
+AVEvalExpr * ff_parse(char *s, const char **const_name,
+               double (**func1)(void *, double), const char **func1_name,
+               double (**func2)(void *, double, double), char **func2_name,
+               char **error);
+/**
+ * Evaluates a previously parsed expression.
+ * @param const_value a zero terminated array of values for the identifers from ff_parse const_name
+ * @param opaque a pointer which will be passed to all functions from func1 and func2
+ * @return the value of the expression
+ */
+double ff_parse_eval(AVEvalExpr * e, double *const_value, void *opaque);
+void ff_eval_free(AVEvalExpr * e);
+
+#endif /* AVCODEC_EVAL_H */



From mean at mail.berlios.de  Sun Jan 21 19:31:01 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 21 Jan 2007 19:31:01 +0100
Subject: [Avidemux-svn-commit] r2755 -
	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec
Message-ID: <200701211831.l0LIV1JV021256@sheep.berlios.de>

Author: mean
Date: 2007-01-21 19:31:01 +0100 (Sun, 21 Jan 2007)
New Revision: 2755

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/bytestream.h
Log:
new file

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/bytestream.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/bytestream.h	2007-01-21 18:29:17 UTC (rev 2754)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/bytestream.h	2007-01-21 18:31:01 UTC (rev 2755)
@@ -0,0 +1,89 @@
+/*
+ * Bytestream functions
+ * copyright (c) 2006 Baptiste Coudurier <baptiste.coudurier at free.fr>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef FFMPEG_BYTESTREAM_H
+#define FFMPEG_BYTESTREAM_H
+
+static av_always_inline unsigned int bytestream_get_le32(uint8_t **b)
+{
+    (*b) += 4;
+    return AV_RL32(*b - 4);
+}
+
+static av_always_inline unsigned int bytestream_get_le16(uint8_t **b)
+{
+    (*b) += 2;
+    return AV_RL16(*b - 2);
+}
+
+static av_always_inline unsigned int bytestream_get_byte(uint8_t **b)
+{
+    (*b)++;
+    return (*b)[-1];
+}
+
+static av_always_inline unsigned int bytestream_get_buffer(uint8_t **b, uint8_t *dst, unsigned int size)
+{
+    memcpy(dst, *b, size);
+    (*b) += size;
+    return size;
+}
+
+static av_always_inline void bytestream_put_be32(uint8_t **b, const unsigned int value)
+{
+    *(*b)++ = value >> 24;
+    *(*b)++ = value >> 16;
+    *(*b)++ = value >> 8;
+    *(*b)++ = value;
+};
+
+static av_always_inline void bytestream_put_be16(uint8_t **b, const unsigned int value)
+{
+    *(*b)++ = value >> 8;
+    *(*b)++ = value;
+}
+
+static av_always_inline void bytestream_put_le32(uint8_t **b, const unsigned int value)
+{
+    *(*b)++ = value;
+    *(*b)++ = value >> 8;
+    *(*b)++ = value >> 16;
+    *(*b)++ = value >> 24;
+}
+
+static av_always_inline void bytestream_put_le16(uint8_t **b, const unsigned int value)
+{
+    *(*b)++ = value;
+    *(*b)++ = value >> 8;
+}
+
+static av_always_inline void bytestream_put_byte(uint8_t **b, const unsigned int value)
+{
+    *(*b)++ = value;
+}
+
+static av_always_inline void bytestream_put_buffer(uint8_t **b, const uint8_t *src, unsigned int size)
+{
+    memcpy(*b, src, size);
+    (*b) += size;
+}
+
+#endif /* FFMPEG_BYTESTREAM_H */



From mean at mail.berlios.de  Sun Jan 21 19:32:13 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 21 Jan 2007 19:32:13 +0100
Subject: [Avidemux-svn-commit] r2756 -
	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec
Message-ID: <200701211832.l0LIWDqe021338@sheep.berlios.de>

Author: mean
Date: 2007-01-21 19:32:13 +0100 (Sun, 21 Jan 2007)
New Revision: 2756

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/mathops.h
Log:
new file

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/mathops.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/mathops.h	2007-01-21 18:31:01 UTC (rev 2755)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/mathops.h	2007-01-21 18:32:13 UTC (rev 2756)
@@ -0,0 +1,69 @@
+/*
+ * simple math operations
+ * Copyright (c) 2001, 2002 Fabrice Bellard.
+ * Copyright (c) 2006 Michael Niedermayer <michaelni at gmx.at> et al
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+#ifndef MATHOPS_H
+#define MATHOPS_H
+
+#ifdef ARCH_X86_32
+
+#include "i386/mathops.h"
+
+#elif defined(ARCH_ARMV4L)
+
+#include "armv4l/mathops.h"
+
+#elif defined(ARCH_PPC)
+
+#include "ppc/mathops.h"
+
+#endif
+
+/* generic implementation */
+
+#ifndef MULL
+#   define MULL(a,b) (((int64_t)(a) * (int64_t)(b)) >> FRAC_BITS)
+#endif
+
+#ifndef MULH
+//gcc 3.4 creates an incredibly bloated mess out of this
+//#    define MULH(a,b) (((int64_t)(a) * (int64_t)(b))>>32)
+
+static av_always_inline int MULH(int a, int b){
+    return ((int64_t)(a) * (int64_t)(b))>>32;
+}
+#endif
+
+#ifndef MUL64
+#   define MUL64(a,b) ((int64_t)(a) * (int64_t)(b))
+#endif
+
+/* signed 16x16 -> 32 multiply add accumulate */
+#ifndef MAC16
+#   define MAC16(rt, ra, rb) rt += (ra) * (rb)
+#endif
+
+/* signed 16x16 -> 32 multiply */
+#ifndef MUL16
+#   define MUL16(ra, rb) ((ra) * (rb))
+#endif
+
+#endif //MATHOPS_H
+



From mean at mail.berlios.de  Sun Jan 21 19:34:04 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 21 Jan 2007 19:34:04 +0100
Subject: [Avidemux-svn-commit] r2757 -
	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec
Message-ID: <200701211834.l0LIY4dr021420@sheep.berlios.de>

Author: mean
Date: 2007-01-21 19:34:00 +0100 (Sun, 21 Jan 2007)
New Revision: 2757

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/vp5.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/vp56.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/vp56.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/vp56data.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/vp56data.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/vp5data.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/vp6.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/vp6data.h
Log:
new files

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/vp5.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/vp5.c	2007-01-21 18:32:13 UTC (rev 2756)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/vp5.c	2007-01-21 18:34:00 UTC (rev 2757)
@@ -0,0 +1,290 @@
+/**
+ * @file vp5.c
+ * VP5 compatible video decoder
+ *
+ * Copyright (C) 2006  Aurelien Jacobs <aurel at gnuage.org>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <stdlib.h>
+#include <string.h>
+
+#include "avcodec.h"
+#include "dsputil.h"
+#include "bitstream.h"
+#include "mpegvideo.h"
+
+#include "vp56.h"
+#include "vp56data.h"
+#include "vp5data.h"
+
+
+static int vp5_parse_header(vp56_context_t *s, uint8_t *buf, int buf_size,
+                            int *golden_frame)
+{
+    vp56_range_coder_t *c = &s->c;
+    int rows, cols;
+
+    vp56_init_range_decoder(&s->c, buf, buf_size);
+    s->frames[VP56_FRAME_CURRENT].key_frame = !vp56_rac_get(c);
+    vp56_rac_get(c);
+    vp56_init_dequant(s, vp56_rac_gets(c, 6));
+    if (s->frames[VP56_FRAME_CURRENT].key_frame)
+    {
+        vp56_rac_gets(c, 8);
+        if(vp56_rac_gets(c, 5) > 5)
+            return 0;
+        vp56_rac_gets(c, 2);
+        if (vp56_rac_get(c)) {
+            av_log(s->avctx, AV_LOG_ERROR, "interlacing not supported\n");
+            return 0;
+        }
+        rows = vp56_rac_gets(c, 8);  /* number of stored macroblock rows */
+        cols = vp56_rac_gets(c, 8);  /* number of stored macroblock cols */
+        vp56_rac_gets(c, 8);  /* number of displayed macroblock rows */
+        vp56_rac_gets(c, 8);  /* number of displayed macroblock cols */
+        vp56_rac_gets(c, 2);
+        if (16*cols != s->avctx->coded_width ||
+            16*rows != s->avctx->coded_height) {
+            avcodec_set_dimensions(s->avctx, 16*cols, 16*rows);
+            return 2;
+        }
+    }
+    return 1;
+}
+
+/* Gives very similar result than the vp6 version except in a few cases */
+static int vp5_adjust(int v, int t)
+{
+    int s2, s1 = v >> 31;
+    v ^= s1;
+    v -= s1;
+    v *= v < 2*t;
+    v -= t;
+    s2 = v >> 31;
+    v ^= s2;
+    v -= s2;
+    v = t - v;
+    v += s1;
+    v ^= s1;
+    return v;
+}
+
+static void vp5_parse_vector_adjustment(vp56_context_t *s, vp56_mv_t *vect)
+{
+    vp56_range_coder_t *c = &s->c;
+    int comp, di;
+
+    for (comp=0; comp<2; comp++) {
+        int delta = 0;
+        if (vp56_rac_get_prob(c, s->vector_model_dct[comp])) {
+            int sign = vp56_rac_get_prob(c, s->vector_model_sig[comp]);
+            di  = vp56_rac_get_prob(c, s->vector_model_pdi[comp][0]);
+            di |= vp56_rac_get_prob(c, s->vector_model_pdi[comp][1]) << 1;
+            delta = vp56_rac_get_tree(c, vp56_pva_tree,
+                                      s->vector_model_pdv[comp]);
+            delta = di | (delta << 2);
+            delta = (delta ^ -sign) + sign;
+        }
+        if (!comp)
+            vect->x = delta;
+        else
+            vect->y = delta;
+    }
+}
+
+static void vp5_parse_vector_models(vp56_context_t *s)
+{
+    vp56_range_coder_t *c = &s->c;
+    int comp, node;
+
+    for (comp=0; comp<2; comp++) {
+        if (vp56_rac_get_prob(c, vp5_vmc_pct[comp][0]))
+            s->vector_model_dct[comp] = vp56_rac_gets_nn(c, 7);
+        if (vp56_rac_get_prob(c, vp5_vmc_pct[comp][1]))
+            s->vector_model_sig[comp] = vp56_rac_gets_nn(c, 7);
+        if (vp56_rac_get_prob(c, vp5_vmc_pct[comp][2]))
+            s->vector_model_pdi[comp][0] = vp56_rac_gets_nn(c, 7);
+        if (vp56_rac_get_prob(c, vp5_vmc_pct[comp][3]))
+            s->vector_model_pdi[comp][1] = vp56_rac_gets_nn(c, 7);
+    }
+
+    for (comp=0; comp<2; comp++)
+        for (node=0; node<7; node++)
+            if (vp56_rac_get_prob(c, vp5_vmc_pct[comp][4 + node]))
+                s->vector_model_pdv[comp][node] = vp56_rac_gets_nn(c, 7);
+}
+
+static void vp5_parse_coeff_models(vp56_context_t *s)
+{
+    vp56_range_coder_t *c = &s->c;
+    uint8_t def_prob[11];
+    int node, cg, ctx;
+    int ct;    /* code type */
+    int pt;    /* plane type (0 for Y, 1 for U or V) */
+
+    memset(def_prob, 0x80, sizeof(def_prob));
+
+    for (pt=0; pt<2; pt++)
+        for (node=0; node<11; node++)
+            if (vp56_rac_get_prob(c, vp5_dccv_pct[pt][node])) {
+                def_prob[node] = vp56_rac_gets_nn(c, 7);
+                s->coeff_model_dccv[pt][node] = def_prob[node];
+            } else if (s->frames[VP56_FRAME_CURRENT].key_frame) {
+                s->coeff_model_dccv[pt][node] = def_prob[node];
+            }
+
+    for (ct=0; ct<3; ct++)
+        for (pt=0; pt<2; pt++)
+            for (cg=0; cg<6; cg++)
+                for (node=0; node<11; node++)
+                    if (vp56_rac_get_prob(c, vp5_ract_pct[ct][pt][cg][node])) {
+                        def_prob[node] = vp56_rac_gets_nn(c, 7);
+                        s->coeff_model_ract[pt][ct][cg][node] = def_prob[node];
+                    } else if (s->frames[VP56_FRAME_CURRENT].key_frame) {
+                        s->coeff_model_ract[pt][ct][cg][node] = def_prob[node];
+                    }
+
+    /* coeff_model_dcct is a linear combination of coeff_model_dccv */
+    for (pt=0; pt<2; pt++)
+        for (ctx=0; ctx<36; ctx++)
+            for (node=0; node<5; node++)
+                s->coeff_model_dcct[pt][ctx][node] = clip(((s->coeff_model_dccv[pt][node] * vp5_dccv_lc[node][ctx][0] + 128) >> 8) + vp5_dccv_lc[node][ctx][1], 1, 254);
+
+    /* coeff_model_acct is a linear combination of coeff_model_ract */
+    for (ct=0; ct<3; ct++)
+        for (pt=0; pt<2; pt++)
+            for (cg=0; cg<3; cg++)
+                for (ctx=0; ctx<6; ctx++)
+                    for (node=0; node<5; node++)
+                        s->coeff_model_acct[pt][ct][cg][ctx][node] = clip(((s->coeff_model_ract[pt][ct][cg][node] * vp5_ract_lc[ct][cg][node][ctx][0] + 128) >> 8) + vp5_ract_lc[ct][cg][node][ctx][1], 1, 254);
+}
+
+static void vp5_parse_coeff(vp56_context_t *s)
+{
+    vp56_range_coder_t *c = &s->c;
+    uint8_t *permute = s->scantable.permutated;
+    uint8_t *model, *model2;
+    int coeff, sign, coeff_idx;
+    int b, i, cg, idx, ctx, ctx_last;
+    int pt = 0;    /* plane type (0 for Y, 1 for U or V) */
+
+    for (b=0; b<6; b++) {
+        int ct = 1;    /* code type */
+
+        if (b > 3) pt = 1;
+
+        ctx = 6*s->coeff_ctx[vp56_b6to4[b]][0]
+              + s->above_blocks[s->above_block_idx[b]].not_null_dc;
+        model = s->coeff_model_dccv[pt];
+        model2 = s->coeff_model_dcct[pt][ctx];
+
+        for (coeff_idx=0; coeff_idx<64; ) {
+            if (vp56_rac_get_prob(c, model2[0])) {
+                if (vp56_rac_get_prob(c, model2[2])) {
+                    if (vp56_rac_get_prob(c, model2[3])) {
+                        s->coeff_ctx[vp56_b6to4[b]][coeff_idx] = 4;
+                        idx = vp56_rac_get_tree(c, vp56_pc_tree, model);
+                        sign = vp56_rac_get(c);
+                        coeff = vp56_coeff_bias[idx];
+                        for (i=vp56_coeff_bit_length[idx]; i>=0; i--)
+                            coeff += vp56_rac_get_prob(c, vp56_coeff_parse_table[idx][i]) << i;
+                    } else {
+                        if (vp56_rac_get_prob(c, model2[4])) {
+                            coeff = 3 + vp56_rac_get_prob(c, model[5]);
+                            s->coeff_ctx[vp56_b6to4[b]][coeff_idx] = 3;
+                        } else {
+                            coeff = 2;
+                            s->coeff_ctx[vp56_b6to4[b]][coeff_idx] = 2;
+                        }
+                        sign = vp56_rac_get(c);
+                    }
+                    ct = 2;
+                } else {
+                    ct = 1;
+                    s->coeff_ctx[vp56_b6to4[b]][coeff_idx] = 1;
+                    sign = vp56_rac_get(c);
+                    coeff = 1;
+                }
+                coeff = (coeff ^ -sign) + sign;
+                if (coeff_idx)
+                    coeff *= s->dequant_ac;
+                s->block_coeff[b][permute[coeff_idx]] = coeff;
+            } else {
+                if (ct && !vp56_rac_get_prob(c, model2[1]))
+                    break;
+                ct = 0;
+                s->coeff_ctx[vp56_b6to4[b]][coeff_idx] = 0;
+            }
+
+            cg = vp5_coeff_groups[++coeff_idx];
+            ctx = s->coeff_ctx[vp56_b6to4[b]][coeff_idx];
+            model = s->coeff_model_ract[pt][ct][cg];
+            model2 = cg > 2 ? model : s->coeff_model_acct[pt][ct][cg][ctx];
+        }
+
+        ctx_last = FFMIN(s->coeff_ctx_last[vp56_b6to4[b]], 24);
+        s->coeff_ctx_last[vp56_b6to4[b]] = coeff_idx;
+        if (coeff_idx < ctx_last)
+            for (i=coeff_idx; i<=ctx_last; i++)
+                s->coeff_ctx[vp56_b6to4[b]][i] = 5;
+        s->above_blocks[s->above_block_idx[b]].not_null_dc = s->coeff_ctx[vp56_b6to4[b]][0];
+    }
+}
+
+static void vp5_default_models_init(vp56_context_t *s)
+{
+    int i;
+
+    for (i=0; i<2; i++) {
+        s->vector_model_sig[i] = 0x80;
+        s->vector_model_dct[i] = 0x80;
+        s->vector_model_pdi[i][0] = 0x55;
+        s->vector_model_pdi[i][1] = 0x80;
+    }
+    memcpy(s->mb_types_stats, vp56_def_mb_types_stats, sizeof(s->mb_types_stats));
+    memset(s->vector_model_pdv, 0x80, sizeof(s->vector_model_pdv));
+}
+
+static int vp5_decode_init(AVCodecContext *avctx)
+{
+    vp56_context_t *s = avctx->priv_data;
+
+    vp56_init(s, avctx, 1);
+    s->vp56_coord_div = vp5_coord_div;
+    s->parse_vector_adjustment = vp5_parse_vector_adjustment;
+    s->adjust = vp5_adjust;
+    s->parse_coeff = vp5_parse_coeff;
+    s->default_models_init = vp5_default_models_init;
+    s->parse_vector_models = vp5_parse_vector_models;
+    s->parse_coeff_models = vp5_parse_coeff_models;
+    s->parse_header = vp5_parse_header;
+
+    return 0;
+}
+
+AVCodec vp5_decoder = {
+    "vp5",
+    CODEC_TYPE_VIDEO,
+    CODEC_ID_VP5,
+    sizeof(vp56_context_t),
+    vp5_decode_init,
+    NULL,
+    vp56_free,
+    vp56_decode_frame,
+};

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/vp56.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/vp56.c	2007-01-21 18:32:13 UTC (rev 2756)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/vp56.c	2007-01-21 18:34:00 UTC (rev 2757)
@@ -0,0 +1,665 @@
+/**
+ * @file vp56.c
+ * VP5 and VP6 compatible video decoder (common features)
+ *
+ * Copyright (C) 2006  Aurelien Jacobs <aurel at gnuage.org>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include "avcodec.h"
+
+#include "vp56.h"
+#include "vp56data.h"
+
+
+void vp56_init_dequant(vp56_context_t *s, int quantizer)
+{
+    s->quantizer = quantizer;
+    s->dequant_dc = vp56_dc_dequant[quantizer] << 2;
+    s->dequant_ac = vp56_ac_dequant[quantizer] << 2;
+}
+
+static int vp56_get_vectors_predictors(vp56_context_t *s, int row, int col,
+                                       vp56_frame_t ref_frame)
+{
+    int nb_pred = 0;
+    vp56_mv_t vect[2] = {{0,0}, {0,0}};
+    int pos, offset;
+    vp56_mv_t mvp;
+
+    for (pos=0; pos<12; pos++) {
+        mvp.x = col + vp56_candidate_predictor_pos[pos][0];
+        mvp.y = row + vp56_candidate_predictor_pos[pos][1];
+        if (mvp.x < 0 || mvp.x >= s->mb_width ||
+            mvp.y < 0 || mvp.y >= s->mb_height)
+            continue;
+        offset = mvp.x + s->mb_width*mvp.y;
+
+        if (vp56_reference_frame[s->macroblocks[offset].type] != ref_frame)
+            continue;
+        if ((s->macroblocks[offset].mv.x == vect[0].x &&
+             s->macroblocks[offset].mv.y == vect[0].y) ||
+            (s->macroblocks[offset].mv.x == 0 &&
+             s->macroblocks[offset].mv.y == 0))
+            continue;
+
+        vect[nb_pred++] = s->macroblocks[offset].mv;
+        if (nb_pred > 1) {
+            nb_pred = -1;
+            break;
+        }
+        s->vector_candidate_pos = pos;
+    }
+
+    s->vector_candidate[0] = vect[0];
+    s->vector_candidate[1] = vect[1];
+
+    return nb_pred+1;
+}
+
+static void vp56_parse_mb_type_models(vp56_context_t *s)
+{
+    vp56_range_coder_t *c = &s->c;
+    int i, ctx, type;
+
+    for (ctx=0; ctx<3; ctx++) {
+        if (vp56_rac_get_prob(c, 174)) {
+            int idx = vp56_rac_gets(c, 4);
+            memcpy(s->mb_types_stats[ctx],vp56_pre_def_mb_type_stats[idx][ctx],
+                   sizeof(s->mb_types_stats[ctx]));
+        }
+        if (vp56_rac_get_prob(c, 254)) {
+            for (type=0; type<10; type++) {
+                for(i=0; i<2; i++) {
+                    if (vp56_rac_get_prob(c, 205)) {
+                        int delta, sign = vp56_rac_get(c);
+
+                        delta = vp56_rac_get_tree(c, vp56_pmbtm_tree,
+                                                  vp56_mb_type_model_model);
+                        if (!delta)
+                            delta = 4 * vp56_rac_gets(c, 7);
+                        s->mb_types_stats[ctx][type][i] += (delta ^ -sign) + sign;
+                    }
+                }
+            }
+        }
+    }
+
+    /* compute MB type probability tables based on previous MB type */
+    for (ctx=0; ctx<3; ctx++) {
+        int p[10];
+
+        for (type=0; type<10; type++)
+            p[type] = 100 * s->mb_types_stats[ctx][type][1];
+
+        for (type=0; type<10; type++) {
+            int p02, p34, p0234, p17, p56, p89, p5689, p156789;
+
+            /* conservative MB type probability */
+            s->mb_type_model[ctx][type][0] = 255 - (255 * s->mb_types_stats[ctx][type][0]) / (1 + s->mb_types_stats[ctx][type][0] + s->mb_types_stats[ctx][type][1]);
+
+            p[type] = 0;    /* same MB type => weight is null */
+
+            /* binary tree parsing probabilities */
+            p02 = p[0] + p[2];
+            p34 = p[3] + p[4];
+            p0234 = p02 + p34;
+            p17 = p[1] + p[7];
+            p56 = p[5] + p[6];
+            p89 = p[8] + p[9];
+            p5689 = p56 + p89;
+            p156789 = p17 + p5689;
+
+            s->mb_type_model[ctx][type][1] = 1 + 255 * p0234/(1+p0234+p156789);
+            s->mb_type_model[ctx][type][2] = 1 + 255 * p02  / (1+p0234);
+            s->mb_type_model[ctx][type][3] = 1 + 255 * p17  / (1+p156789);
+            s->mb_type_model[ctx][type][4] = 1 + 255 * p[0] / (1+p02);
+            s->mb_type_model[ctx][type][5] = 1 + 255 * p[3] / (1+p34);
+            s->mb_type_model[ctx][type][6] = 1 + 255 * p[1] / (1+p17);
+            s->mb_type_model[ctx][type][7] = 1 + 255 * p56  / (1+p5689);
+            s->mb_type_model[ctx][type][8] = 1 + 255 * p[5] / (1+p56);
+            s->mb_type_model[ctx][type][9] = 1 + 255 * p[8] / (1+p89);
+
+            /* restore initial value */
+            p[type] = 100 * s->mb_types_stats[ctx][type][1];
+        }
+    }
+}
+
+static vp56_mb_t vp56_parse_mb_type(vp56_context_t *s,
+                                    vp56_mb_t prev_type, int ctx)
+{
+    uint8_t *mb_type_model = s->mb_type_model[ctx][prev_type];
+    vp56_range_coder_t *c = &s->c;
+
+    if (vp56_rac_get_prob(c, mb_type_model[0]))
+        return prev_type;
+    else
+        return vp56_rac_get_tree(c, vp56_pmbt_tree, mb_type_model);
+}
+
+static void vp56_decode_4mv(vp56_context_t *s, int row, int col)
+{
+    vp56_mv_t mv = {0,0};
+    int type[4];
+    int b;
+
+    /* parse each block type */
+    for (b=0; b<4; b++) {
+        type[b] = vp56_rac_gets(&s->c, 2);
+        if (type[b])
+            type[b]++;  /* only returns 0, 2, 3 or 4 (all INTER_PF) */
+    }
+
+    /* get vectors */
+    for (b=0; b<4; b++) {
+        switch (type[b]) {
+            case VP56_MB_INTER_NOVEC_PF:
+                s->mv[b] = (vp56_mv_t) {0,0};
+                break;
+            case VP56_MB_INTER_DELTA_PF:
+                s->parse_vector_adjustment(s, &s->mv[b]);
+                break;
+            case VP56_MB_INTER_V1_PF:
+                s->mv[b] = s->vector_candidate[0];
+                break;
+            case VP56_MB_INTER_V2_PF:
+                s->mv[b] = s->vector_candidate[1];
+                break;
+        }
+        mv.x += s->mv[b].x;
+        mv.y += s->mv[b].y;
+    }
+
+    /* this is the one selected for the whole MB for prediction */
+    s->macroblocks[row * s->mb_width + col].mv = s->mv[3];
+
+    /* chroma vectors are average luma vectors */
+    if (s->avctx->codec->id == CODEC_ID_VP5) {
+        s->mv[4].x = s->mv[5].x = RSHIFT(mv.x,2);
+        s->mv[4].y = s->mv[5].y = RSHIFT(mv.y,2);
+    } else {
+        s->mv[4] = s->mv[5] = (vp56_mv_t) {mv.x/4, mv.y/4};
+    }
+}
+
+static vp56_mb_t vp56_decode_mv(vp56_context_t *s, int row, int col)
+{
+    vp56_mv_t *mv, vect = {0,0};
+    int ctx, b;
+
+    ctx = vp56_get_vectors_predictors(s, row, col, VP56_FRAME_PREVIOUS);
+    s->mb_type = vp56_parse_mb_type(s, s->mb_type, ctx);
+    s->macroblocks[row * s->mb_width + col].type = s->mb_type;
+
+    switch (s->mb_type) {
+        case VP56_MB_INTER_V1_PF:
+            mv = &s->vector_candidate[0];
+            break;
+
+        case VP56_MB_INTER_V2_PF:
+            mv = &s->vector_candidate[1];
+            break;
+
+        case VP56_MB_INTER_V1_GF:
+            vp56_get_vectors_predictors(s, row, col, VP56_FRAME_GOLDEN);
+            mv = &s->vector_candidate[0];
+            break;
+
+        case VP56_MB_INTER_V2_GF:
+            vp56_get_vectors_predictors(s, row, col, VP56_FRAME_GOLDEN);
+            mv = &s->vector_candidate[1];
+            break;
+
+        case VP56_MB_INTER_DELTA_PF:
+            s->parse_vector_adjustment(s, &vect);
+            mv = &vect;
+            break;
+
+        case VP56_MB_INTER_DELTA_GF:
+            vp56_get_vectors_predictors(s, row, col, VP56_FRAME_GOLDEN);
+            s->parse_vector_adjustment(s, &vect);
+            mv = &vect;
+            break;
+
+        case VP56_MB_INTER_4V:
+            vp56_decode_4mv(s, row, col);
+            return s->mb_type;
+
+        default:
+            mv = &vect;
+            break;
+    }
+
+    s->macroblocks[row*s->mb_width + col].mv = *mv;
+
+    /* same vector for all blocks */
+    for (b=0; b<6; b++)
+        s->mv[b] = *mv;
+
+    return s->mb_type;
+}
+
+static void vp56_add_predictors_dc(vp56_context_t *s, vp56_frame_t ref_frame)
+{
+    int idx = s->scantable.permutated[0];
+    int i;
+
+    for (i=0; i<6; i++) {
+        vp56_ref_dc_t *ab = &s->above_blocks[s->above_block_idx[i]];
+        vp56_ref_dc_t *lb = &s->left_block[vp56_b6to4[i]];
+        int count = 0;
+        int dc = 0;
+
+        if (ref_frame == lb->ref_frame) {
+            dc += lb->dc_coeff;
+            count++;
+        }
+        if (ref_frame == ab->ref_frame) {
+            dc += ab->dc_coeff;
+            count++;
+        }
+        if (s->avctx->codec->id == CODEC_ID_VP5) {
+            if (count < 2 && ref_frame == ab[-1].ref_frame) {
+                dc += ab[-1].dc_coeff;
+                count++;
+            }
+            if (count < 2 && ref_frame == ab[1].ref_frame) {
+                dc += ab[1].dc_coeff;
+                count++;
+            }
+        }
+        if (count == 0)
+            dc = s->prev_dc[vp56_b6to3[i]][ref_frame];
+        else if (count == 2)
+            dc /= 2;
+
+        s->block_coeff[i][idx] += dc;
+        s->prev_dc[vp56_b6to3[i]][ref_frame] = s->block_coeff[i][idx];
+        ab->dc_coeff = s->block_coeff[i][idx];
+        ab->ref_frame = ref_frame;
+        lb->dc_coeff = s->block_coeff[i][idx];
+        lb->ref_frame = ref_frame;
+        s->block_coeff[i][idx] *= s->dequant_dc;
+    }
+}
+
+static void vp56_edge_filter(vp56_context_t *s, uint8_t *yuv,
+                             int pix_inc, int line_inc, int t)
+{
+    int pix2_inc = 2 * pix_inc;
+    int i, v;
+
+    for (i=0; i<12; i++) {
+        v = (yuv[-pix2_inc] + 3*(yuv[0]-yuv[-pix_inc]) - yuv[pix_inc] + 4) >>3;
+        v = s->adjust(v, t);
+        yuv[-pix_inc] = clip_uint8(yuv[-pix_inc] + v);
+        yuv[0] = clip_uint8(yuv[0] - v);
+        yuv += line_inc;
+    }
+}
+
+static void vp56_deblock_filter(vp56_context_t *s, uint8_t *yuv,
+                                int stride, int dx, int dy)
+{
+    int t = vp56_filter_threshold[s->quantizer];
+    if (dx)  vp56_edge_filter(s, yuv +         10-dx ,      1, stride, t);
+    if (dy)  vp56_edge_filter(s, yuv + stride*(10-dy), stride,      1, t);
+}
+
+static void vp56_mc(vp56_context_t *s, int b, uint8_t *src,
+                    int stride, int x, int y)
+{
+    int plane = vp56_b6to3[b];
+    uint8_t *dst= s->frames[VP56_FRAME_CURRENT].data[plane]+s->block_offset[b];
+    uint8_t *src_block;
+    int src_offset;
+    int overlap_offset = 0;
+    int mask = s->vp56_coord_div[b] - 1;
+    int deblock_filtering = s->deblock_filtering;
+    int dx;
+    int dy;
+
+    if (s->avctx->skip_loop_filter >= AVDISCARD_ALL ||
+        (s->avctx->skip_loop_filter >= AVDISCARD_NONKEY
+         && !s->frames[VP56_FRAME_CURRENT].key_frame))
+        deblock_filtering = 0;
+
+    dx = s->mv[b].x / s->vp56_coord_div[b];
+    dy = s->mv[b].y / s->vp56_coord_div[b];
+
+    if (b >= 4) {
+        x /= 2;
+        y /= 2;
+    }
+    x += dx - 2;
+    y += dy - 2;
+
+    if (x<0 || x+12>=s->plane_width[plane] ||
+        y<0 || y+12>=s->plane_height[plane]) {
+        ff_emulated_edge_mc(s->edge_emu_buffer,
+                            src + s->block_offset[b] + (dy-2)*stride + (dx-2),
+                            stride, 12, 12, x, y,
+                            s->plane_width[plane],
+                            s->plane_height[plane]);
+        src_block = s->edge_emu_buffer;
+        src_offset = 2 + 2*stride;
+    } else if (deblock_filtering) {
+        /* only need a 12x12 block, but there is no such dsp function, */
+        /* so copy a 16x12 block */
+        s->dsp.put_pixels_tab[0][0](s->edge_emu_buffer,
+                                    src + s->block_offset[b] + (dy-2)*stride + (dx-2),
+                                    stride, 12);
+        src_block = s->edge_emu_buffer;
+        src_offset = 2 + 2*stride;
+    } else {
+        src_block = src;
+        src_offset = s->block_offset[b] + dy*stride + dx;
+    }
+
+    if (deblock_filtering)
+        vp56_deblock_filter(s, src_block, stride, dx&7, dy&7);
+
+    if (s->mv[b].x & mask)
+        overlap_offset += (s->mv[b].x > 0) ? 1 : -1;
+    if (s->mv[b].y & mask)
+        overlap_offset += (s->mv[b].y > 0) ? stride : -stride;
+
+    if (overlap_offset) {
+        if (s->filter)
+            s->filter(s, dst, src_block, src_offset, src_offset+overlap_offset,
+                      stride, s->mv[b], mask, s->filter_selection, b<4);
+        else
+            s->dsp.put_no_rnd_pixels_l2[1](dst, src_block+src_offset,
+                                           src_block+src_offset+overlap_offset,
+                                           stride, 8);
+    } else {
+        s->dsp.put_pixels_tab[1][0](dst, src_block+src_offset, stride, 8);
+    }
+}
+
+static void vp56_decode_mb(vp56_context_t *s, int row, int col)
+{
+    AVFrame *frame_current, *frame_ref;
+    vp56_mb_t mb_type;
+    vp56_frame_t ref_frame;
+    int b, plan, off;
+
+    if (s->frames[VP56_FRAME_CURRENT].key_frame)
+        mb_type = VP56_MB_INTRA;
+    else
+        mb_type = vp56_decode_mv(s, row, col);
+    ref_frame = vp56_reference_frame[mb_type];
+
+    memset(s->block_coeff, 0, sizeof(s->block_coeff));
+
+    s->parse_coeff(s);
+
+    vp56_add_predictors_dc(s, ref_frame);
+
+    frame_current = &s->frames[VP56_FRAME_CURRENT];
+    frame_ref = &s->frames[ref_frame];
+
+    switch (mb_type) {
+        case VP56_MB_INTRA:
+            for (b=0; b<6; b++) {
+                plan = vp56_b6to3[b];
+                s->dsp.idct_put(frame_current->data[plan] + s->block_offset[b],
+                                s->stride[plan], s->block_coeff[b]);
+            }
+            break;
+
+        case VP56_MB_INTER_NOVEC_PF:
+        case VP56_MB_INTER_NOVEC_GF:
+            for (b=0; b<6; b++) {
+                plan = vp56_b6to3[b];
+                off = s->block_offset[b];
+                s->dsp.put_pixels_tab[1][0](frame_current->data[plan] + off,
+                                            frame_ref->data[plan] + off,
+                                            s->stride[plan], 8);
+                s->dsp.idct_add(frame_current->data[plan] + off,
+                                s->stride[plan], s->block_coeff[b]);
+            }
+            break;
+
+        case VP56_MB_INTER_DELTA_PF:
+        case VP56_MB_INTER_V1_PF:
+        case VP56_MB_INTER_V2_PF:
+        case VP56_MB_INTER_DELTA_GF:
+        case VP56_MB_INTER_4V:
+        case VP56_MB_INTER_V1_GF:
+        case VP56_MB_INTER_V2_GF:
+            for (b=0; b<6; b++) {
+                int x_off = b==1 || b==3 ? 8 : 0;
+                int y_off = b==2 || b==3 ? 8 : 0;
+                plan = vp56_b6to3[b];
+                vp56_mc(s, b, frame_ref->data[plan], s->stride[plan],
+                        16*col+x_off, 16*row+y_off);
+                s->dsp.idct_add(frame_current->data[plan] + s->block_offset[b],
+                                s->stride[plan], s->block_coeff[b]);
+            }
+            break;
+    }
+}
+
+static int vp56_size_changed(AVCodecContext *avctx, vp56_context_t *s)
+{
+    int stride = s->frames[VP56_FRAME_CURRENT].linesize[0];
+    int i;
+
+    s->plane_width[0] = s->avctx->coded_width;
+    s->plane_width[1] = s->plane_width[2] = s->avctx->coded_width/2;
+    s->plane_height[0] = s->avctx->coded_height;
+    s->plane_height[1] = s->plane_height[2] = s->avctx->coded_height/2;
+
+    for (i=0; i<3; i++)
+        s->stride[i] = s->flip * s->frames[VP56_FRAME_CURRENT].linesize[i];
+
+    s->mb_width = (s->avctx->coded_width+15) / 16;
+    s->mb_height = (s->avctx->coded_height+15) / 16;
+
+    if (s->mb_width > 1000 || s->mb_height > 1000) {
+        av_log(avctx, AV_LOG_ERROR, "picture too big\n");
+        return -1;
+    }
+
+    s->above_blocks = av_realloc(s->above_blocks,
+                                 (4*s->mb_width+6) * sizeof(*s->above_blocks));
+    s->macroblocks = av_realloc(s->macroblocks,
+                                s->mb_width*s->mb_height*sizeof(*s->macroblocks));
+    av_free(s->edge_emu_buffer_alloc);
+    s->edge_emu_buffer_alloc = av_malloc(16*stride);
+    s->edge_emu_buffer = s->edge_emu_buffer_alloc;
+    if (s->flip < 0)
+        s->edge_emu_buffer += 15 * stride;
+
+    return 0;
+}
+
+int vp56_decode_frame(AVCodecContext *avctx, void *data, int *data_size,
+                      uint8_t *buf, int buf_size)
+{
+    vp56_context_t *s = avctx->priv_data;
+    AVFrame *const p = &s->frames[VP56_FRAME_CURRENT];
+    AVFrame *picture = data;
+    int mb_row, mb_col, mb_row_flip, mb_offset = 0;
+    int block, y, uv, stride_y, stride_uv;
+    int golden_frame = 0;
+    int res;
+
+    res = s->parse_header(s, buf, buf_size, &golden_frame);
+    if (!res)
+        return -1;
+
+    p->reference = 1;
+    if (avctx->get_buffer(avctx, p) < 0) {
+        av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n");
+        return -1;
+    }
+
+    if (res == 2)
+        if (vp56_size_changed(avctx, s)) {
+            avctx->release_buffer(avctx, p);
+            return -1;
+        }
+
+    if (p->key_frame) {
+        p->pict_type = FF_I_TYPE;
+        s->default_models_init(s);
+        for (block=0; block<s->mb_height*s->mb_width; block++)
+            s->macroblocks[block].type = VP56_MB_INTRA;
+    } else {
+        p->pict_type = FF_P_TYPE;
+        vp56_parse_mb_type_models(s);
+        s->parse_vector_models(s);
+        s->mb_type = VP56_MB_INTER_NOVEC_PF;
+    }
+
+    s->parse_coeff_models(s);
+
+    memset(s->prev_dc, 0, sizeof(s->prev_dc));
+    s->prev_dc[1][VP56_FRAME_CURRENT] = 128;
+    s->prev_dc[2][VP56_FRAME_CURRENT] = 128;
+
+    for (block=0; block < 4*s->mb_width+6; block++) {
+        s->above_blocks[block].ref_frame = -1;
+        s->above_blocks[block].dc_coeff = 0;
+        s->above_blocks[block].not_null_dc = 0;
+    }
+    s->above_blocks[2*s->mb_width + 2].ref_frame = 0;
+    s->above_blocks[3*s->mb_width + 4].ref_frame = 0;
+
+    stride_y  = p->linesize[0];
+    stride_uv = p->linesize[1];
+
+    if (s->flip < 0)
+        mb_offset = 7;
+
+    /* main macroblocks loop */
+    for (mb_row=0; mb_row<s->mb_height; mb_row++) {
+        if (s->flip < 0)
+            mb_row_flip = s->mb_height - mb_row - 1;
+        else
+            mb_row_flip = mb_row;
+
+        for (block=0; block<4; block++) {
+            s->left_block[block].ref_frame = -1;
+            s->left_block[block].dc_coeff = 0;
+            s->left_block[block].not_null_dc = 0;
+            memset(s->coeff_ctx[block], 0, 64*sizeof(s->coeff_ctx[block][0]));
+        }
+        memset(s->coeff_ctx_last, 24, sizeof(s->coeff_ctx_last));
+
+        s->above_block_idx[0] = 1;
+        s->above_block_idx[1] = 2;
+        s->above_block_idx[2] = 1;
+        s->above_block_idx[3] = 2;
+        s->above_block_idx[4] = 2*s->mb_width + 2 + 1;
+        s->above_block_idx[5] = 3*s->mb_width + 4 + 1;
+
+        s->block_offset[s->frbi] = (mb_row_flip*16 + mb_offset) * stride_y;
+        s->block_offset[s->srbi] = s->block_offset[s->frbi] + 8*stride_y;
+        s->block_offset[1] = s->block_offset[0] + 8;
+        s->block_offset[3] = s->block_offset[2] + 8;
+        s->block_offset[4] = (mb_row_flip*8 + mb_offset) * stride_uv;
+        s->block_offset[5] = s->block_offset[4];
+
+        for (mb_col=0; mb_col<s->mb_width; mb_col++) {
+            vp56_decode_mb(s, mb_row, mb_col);
+
+            for (y=0; y<4; y++) {
+                s->above_block_idx[y] += 2;
+                s->block_offset[y] += 16;
+            }
+
+            for (uv=4; uv<6; uv++) {
+                s->above_block_idx[uv] += 1;
+                s->block_offset[uv] += 8;
+            }
+        }
+    }
+
+    if (s->frames[VP56_FRAME_PREVIOUS].data[0]
+        && (s->frames[VP56_FRAME_PREVIOUS].data[0]
+            != s->frames[VP56_FRAME_GOLDEN].data[0])) {
+        avctx->release_buffer(avctx, &s->frames[VP56_FRAME_PREVIOUS]);
+    }
+    if (p->key_frame || golden_frame) {
+        if (s->frames[VP56_FRAME_GOLDEN].data[0])
+            avctx->release_buffer(avctx, &s->frames[VP56_FRAME_GOLDEN]);
+        s->frames[VP56_FRAME_GOLDEN] = *p;
+    }
+    s->frames[VP56_FRAME_PREVIOUS] = *p;
+
+    *picture = *p;
+    *data_size = sizeof(AVPicture);
+
+    return buf_size;
+}
+
+void vp56_init(vp56_context_t *s, AVCodecContext *avctx, int flip)
+{
+    int i;
+
+    s->avctx = avctx;
+    avctx->pix_fmt = PIX_FMT_YUV420P;
+
+    if (s->avctx->idct_algo == FF_IDCT_AUTO)
+        s->avctx->idct_algo = FF_IDCT_VP3;
+    dsputil_init(&s->dsp, s->avctx);
+    ff_init_scantable(s->dsp.idct_permutation, &s->scantable,ff_zigzag_direct);
+
+    avcodec_set_dimensions(s->avctx, 0, 0);
+
+    for (i=0; i<3; i++)
+        s->frames[i].data[0] = NULL;
+    s->edge_emu_buffer_alloc = NULL;
+
+    s->above_blocks = NULL;
+    s->macroblocks = NULL;
+    s->quantizer = -1;
+    s->deblock_filtering = 1;
+
+    s->filter = NULL;
+
+    if (flip) {
+        s->flip = -1;
+        s->frbi = 2;
+        s->srbi = 0;
+    } else {
+        s->flip = 1;
+        s->frbi = 0;
+        s->srbi = 2;
+    }
+}
+
+int vp56_free(AVCodecContext *avctx)
+{
+    vp56_context_t *s = avctx->priv_data;
+
+    av_free(s->above_blocks);
+    av_free(s->macroblocks);
+    av_free(s->edge_emu_buffer_alloc);
+    if (s->frames[VP56_FRAME_GOLDEN].data[0]
+        && (s->frames[VP56_FRAME_PREVIOUS].data[0]
+            != s->frames[VP56_FRAME_GOLDEN].data[0]))
+        avctx->release_buffer(avctx, &s->frames[VP56_FRAME_GOLDEN]);
+    if (s->frames[VP56_FRAME_PREVIOUS].data[0])
+        avctx->release_buffer(avctx, &s->frames[VP56_FRAME_PREVIOUS]);
+    return 0;
+}

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/vp56.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/vp56.h	2007-01-21 18:32:13 UTC (rev 2756)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/vp56.h	2007-01-21 18:34:00 UTC (rev 2757)
@@ -0,0 +1,252 @@
+/**
+ * @file vp56.h
+ * VP5 and VP6 compatible video decoder (common features)
+ *
+ * Copyright (C) 2006  Aurelien Jacobs <aurel at gnuage.org>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef VP56_H
+#define VP56_H
+
+#include "vp56data.h"
+#include "dsputil.h"
+#include "mpegvideo.h"
+
+
+typedef struct vp56_context vp56_context_t;
+typedef struct vp56_mv vp56_mv_t;
+
+typedef void (*vp56_parse_vector_adjustment_t)(vp56_context_t *s,
+                                               vp56_mv_t *vect);
+typedef int (*vp56_adjust_t)(int v, int t);
+typedef void (*vp56_filter_t)(vp56_context_t *s, uint8_t *dst, uint8_t *src,
+                              int offset1, int offset2, int stride,
+                              vp56_mv_t mv, int mask, int select, int luma);
+typedef void (*vp56_parse_coeff_t)(vp56_context_t *s);
+typedef void (*vp56_default_models_init_t)(vp56_context_t *s);
+typedef void (*vp56_parse_vector_models_t)(vp56_context_t *s);
+typedef void (*vp56_parse_coeff_models_t)(vp56_context_t *s);
+typedef int (*vp56_parse_header_t)(vp56_context_t *s, uint8_t *buf,
+                                   int buf_size, int *golden_frame);
+
+typedef struct {
+    int high;
+    int bits;
+    const uint8_t *buffer;
+    unsigned long code_word;
+} vp56_range_coder_t;
+
+typedef struct {
+    uint8_t not_null_dc;
+    vp56_frame_t ref_frame;
+    DCTELEM dc_coeff;
+} vp56_ref_dc_t;
+
+struct vp56_mv {
+    int x;
+    int y;
+};
+
+typedef struct {
+    uint8_t type;
+    vp56_mv_t mv;
+} vp56_macroblock_t;
+
+struct vp56_context {
+    AVCodecContext *avctx;
+    DSPContext dsp;
+    ScanTable scantable;
+    AVFrame frames[3];
+    uint8_t *edge_emu_buffer_alloc;
+    uint8_t *edge_emu_buffer;
+    vp56_range_coder_t c;
+    vp56_range_coder_t cc;
+    vp56_range_coder_t *ccp;
+    int sub_version;
+
+    /* frame info */
+    int plane_width[3];
+    int plane_height[3];
+    int mb_width;   /* number of horizontal MB */
+    int mb_height;  /* number of vertical MB */
+    int block_offset[6];
+
+    int quantizer;
+    uint16_t dequant_dc;
+    uint16_t dequant_ac;
+
+    /* DC predictors management */
+    vp56_ref_dc_t *above_blocks;
+    vp56_ref_dc_t left_block[4];
+    int above_block_idx[6];
+    DCTELEM prev_dc[3][3];    /* [plan][ref_frame] */
+
+    /* blocks / macroblock */
+    vp56_mb_t mb_type;
+    vp56_macroblock_t *macroblocks;
+    DECLARE_ALIGNED_16(DCTELEM, block_coeff[6][64]);
+    uint8_t coeff_reorder[64];       /* used in vp6 only */
+    uint8_t coeff_index_to_pos[64];  /* used in vp6 only */
+
+    /* motion vectors */
+    vp56_mv_t mv[6];  /* vectors for each block in MB */
+    vp56_mv_t vector_candidate[2];
+    int vector_candidate_pos;
+
+    /* filtering hints */
+    int filter_header;               /* used in vp6 only */
+    int deblock_filtering;
+    int filter_selection;
+    int filter_mode;
+    int max_vector_length;
+    int sample_variance_threshold;
+
+    /* AC models */
+    uint8_t vector_model_sig[2];           /* delta sign */
+    uint8_t vector_model_dct[2];           /* delta coding types */
+    uint8_t vector_model_pdi[2][2];        /* predefined delta init */
+    uint8_t vector_model_pdv[2][7];        /* predefined delta values */
+    uint8_t vector_model_fdv[2][8];        /* 8 bit delta value definition */
+    uint8_t mb_type_model[3][10][10];      /* model for decoding MB type */
+    uint8_t coeff_model_dccv[2][11];       /* DC coeff value */
+    uint8_t coeff_model_ract[2][3][6][11]; /* Run/AC coding type and AC coeff value */
+    uint8_t coeff_model_acct[2][3][3][6][5];/* vp5 only AC coding type for coding group < 3 */
+    uint8_t coeff_model_dcct[2][36][5];    /* DC coeff coding type */
+    uint8_t coeff_model_runv[2][14];       /* run value (vp6 only) */
+    uint8_t mb_types_stats[3][10][2];      /* contextual, next MB type stats */
+    uint8_t coeff_ctx[4][64];              /* used in vp5 only */
+    uint8_t coeff_ctx_last[4];             /* used in vp5 only */
+
+    /* upside-down flipping hints */
+    int flip;  /* are we flipping ? */
+    int frbi;  /* first row block index in MB */
+    int srbi;  /* second row block index in MB */
+    int stride[3];  /* stride for each plan */
+
+    const uint8_t *vp56_coord_div;
+    vp56_parse_vector_adjustment_t parse_vector_adjustment;
+    vp56_adjust_t adjust;
+    vp56_filter_t filter;
+    vp56_parse_coeff_t parse_coeff;
+    vp56_default_models_init_t default_models_init;
+    vp56_parse_vector_models_t parse_vector_models;
+    vp56_parse_coeff_models_t parse_coeff_models;
+    vp56_parse_header_t parse_header;
+};
+
+
+void vp56_init(vp56_context_t *s, AVCodecContext *avctx, int flip);
+int vp56_free(AVCodecContext *avctx);
+void vp56_init_dequant(vp56_context_t *s, int quantizer);
+int vp56_decode_frame(AVCodecContext *avctx, void *data, int *data_size,
+                      uint8_t *buf, int buf_size);
+
+
+/**
+ * vp56 specific range coder implementation
+ */
+
+static inline void vp56_init_range_decoder(vp56_range_coder_t *c,
+                                           const uint8_t *buf, int buf_size)
+{
+    c->high = 255;
+    c->bits = 8;
+    c->buffer = buf;
+    c->code_word = *c->buffer++ << 8;
+    c->code_word |= *c->buffer++;
+}
+
+static inline int vp56_rac_get_prob(vp56_range_coder_t *c, uint8_t prob)
+{
+    unsigned int low = 1 + (((c->high - 1) * prob) / 256);
+    unsigned int low_shift = low << 8;
+    int bit = c->code_word >= low_shift;
+
+    if (bit) {
+        c->high -= low;
+        c->code_word -= low_shift;
+    } else {
+        c->high = low;
+    }
+
+    /* normalize */
+    while (c->high < 128) {
+        c->high <<= 1;
+        c->code_word <<= 1;
+        if (--c->bits == 0) {
+            c->bits = 8;
+            c->code_word |= *c->buffer++;
+        }
+    }
+    return bit;
+}
+
+static inline int vp56_rac_get(vp56_range_coder_t *c)
+{
+    /* equiprobable */
+    int low = (c->high + 1) >> 1;
+    unsigned int low_shift = low << 8;
+    int bit = c->code_word >= low_shift;
+    if (bit) {
+        c->high = (c->high - low) << 1;
+        c->code_word -= low_shift;
+    } else {
+        c->high = low << 1;
+    }
+
+    /* normalize */
+    c->code_word <<= 1;
+    if (--c->bits == 0) {
+        c->bits = 8;
+        c->code_word |= *c->buffer++;
+    }
+    return bit;
+}
+
+static inline int vp56_rac_gets(vp56_range_coder_t *c, int bits)
+{
+    int value = 0;
+
+    while (bits--) {
+        value = (value << 1) | vp56_rac_get(c);
+    }
+
+    return value;
+}
+
+static inline int vp56_rac_gets_nn(vp56_range_coder_t *c, int bits)
+{
+    int v = vp56_rac_gets(c, 7) << 1;
+    return v + !v;
+}
+
+static inline int vp56_rac_get_tree(vp56_range_coder_t *c,
+                                    const vp56_tree_t *tree,
+                                    const uint8_t *probs)
+{
+    while (tree->val > 0) {
+        if (vp56_rac_get_prob(c, probs[tree->prob_idx]))
+            tree += tree->val;
+        else
+            tree++;
+    }
+    return -tree->val;
+}
+
+#endif /* VP56_H */

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/vp56data.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/vp56data.c	2007-01-21 18:32:13 UTC (rev 2756)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/vp56data.c	2007-01-21 18:34:00 UTC (rev 2757)
@@ -0,0 +1,66 @@
+/**
+ * @file vp56data.c
+ * VP5 and VP6 compatible video decoder (common data)
+ *
+ * Copyright (C) 2006  Aurelien Jacobs <aurel at gnuage.org>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include "vp56data.h"
+
+const uint8_t vp56_b6to3[] = { 0, 0, 0, 0, 1, 2 };
+const uint8_t vp56_b6to4[] = { 0, 0, 1, 1, 2, 3 };
+
+const uint8_t vp56_coeff_parse_table[6][11] = {
+    { 159,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
+    { 145, 165,   0,   0,   0,   0,   0,   0,   0,   0,   0 },
+    { 140, 148, 173,   0,   0,   0,   0,   0,   0,   0,   0 },
+    { 135, 140, 155, 176,   0,   0,   0,   0,   0,   0,   0 },
+    { 130, 134, 141, 157, 180,   0,   0,   0,   0,   0,   0 },
+    { 129, 130, 133, 140, 153, 177, 196, 230, 243, 254, 254 },
+};
+
+const uint8_t vp56_def_mb_types_stats[3][10][2] = {
+    { {  69, 42 }, {   1,  2 }, {  1,   7 }, {  44, 42 }, {  6, 22 },
+      {   1,  3 }, {   0,  2 }, {  1,   5 }, {   0,  1 }, {  0,  0 }, },
+    { { 229,  8 }, {   1,  1 }, {  0,   8 }, {   0,  0 }, {  0,  0 },
+      {   1,  2 }, {   0,  1 }, {  0,   0 }, {   1,  1 }, {  0,  0 }, },
+    { { 122, 35 }, {   1,  1 }, {  1,   6 }, {  46, 34 }, {  0,  0 },
+      {   1,  2 }, {   0,  1 }, {  0,   1 }, {   1,  1 }, {  0,  0 }, },
+};
+
+const vp56_tree_t vp56_pva_tree[] = {
+    { 8, 0},
+    { 4, 1},
+    { 2, 2}, {-0}, {-1},
+    { 2, 3}, {-2}, {-3},
+    { 4, 4},
+    { 2, 5}, {-4}, {-5},
+    { 2, 6}, {-6}, {-7},
+};
+
+const vp56_tree_t vp56_pc_tree[] = {
+    { 4, 6},
+    { 2, 7}, {-0}, {-1},
+    { 4, 8},
+    { 2, 9}, {-2}, {-3},
+    { 2,10}, {-4}, {-5},
+};
+
+const uint8_t vp56_coeff_bias[] = { 5, 7, 11, 19, 35, 67 };
+const uint8_t vp56_coeff_bit_length[] = { 0, 1, 2, 3, 4, 10 };

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/vp56data.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/vp56data.h	2007-01-21 18:32:13 UTC (rev 2756)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/vp56data.h	2007-01-21 18:34:00 UTC (rev 2757)
@@ -0,0 +1,248 @@
+/**
+ * @file vp56data.h
+ * VP5 and VP6 compatible video decoder (common data)
+ *
+ * Copyright (C) 2006  Aurelien Jacobs <aurel at gnuage.org>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef VP56DATA_H
+#define VP56DATA_H
+
+#include "common.h"
+
+typedef enum {
+    VP56_FRAME_CURRENT  = 0,
+    VP56_FRAME_PREVIOUS = 1,
+    VP56_FRAME_GOLDEN   = 2,
+} vp56_frame_t;
+
+typedef enum {
+    VP56_MB_INTER_NOVEC_PF = 0,  /**< Inter MB, no vector, from previous frame */
+    VP56_MB_INTRA          = 1,  /**< Intra MB */
+    VP56_MB_INTER_DELTA_PF = 2,  /**< Inter MB, above/left vector + delta, from previous frame */
+    VP56_MB_INTER_V1_PF    = 3,  /**< Inter MB, first vector, from previous frame */
+    VP56_MB_INTER_V2_PF    = 4,  /**< Inter MB, second vector, from previous frame */
+    VP56_MB_INTER_NOVEC_GF = 5,  /**< Inter MB, no vector, from golden frame */
+    VP56_MB_INTER_DELTA_GF = 6,  /**< Inter MB, above/left vector + delta, from golden frame */
+    VP56_MB_INTER_4V       = 7,  /**< Inter MB, 4 vectors, from previous frame */
+    VP56_MB_INTER_V1_GF    = 8,  /**< Inter MB, first vector, from golden frame */
+    VP56_MB_INTER_V2_GF    = 9,  /**< Inter MB, second vector, from golden frame */
+} vp56_mb_t;
+
+typedef struct {
+  int8_t val;
+  int8_t prob_idx;
+} vp56_tree_t;
+
+extern const uint8_t vp56_b6to3[];
+extern const uint8_t vp56_b6to4[];
+extern const uint8_t vp56_coeff_parse_table[6][11];
+extern const uint8_t vp56_def_mb_types_stats[3][10][2];
+extern const vp56_tree_t vp56_pva_tree[];
+extern const vp56_tree_t vp56_pc_tree[];
+extern const uint8_t vp56_coeff_bias[];
+extern const uint8_t vp56_coeff_bit_length[];
+
+static const vp56_frame_t vp56_reference_frame[] = {
+    VP56_FRAME_PREVIOUS,  /* VP56_MB_INTER_NOVEC_PF */
+    VP56_FRAME_CURRENT,   /* VP56_MB_INTRA */
+    VP56_FRAME_PREVIOUS,  /* VP56_MB_INTER_DELTA_PF */
+    VP56_FRAME_PREVIOUS,  /* VP56_MB_INTER_V1_PF */
+    VP56_FRAME_PREVIOUS,  /* VP56_MB_INTER_V2_PF */
+    VP56_FRAME_GOLDEN,    /* VP56_MB_INTER_NOVEC_GF */
+    VP56_FRAME_GOLDEN,    /* VP56_MB_INTER_DELTA_GF */
+    VP56_FRAME_PREVIOUS,  /* VP56_MB_INTER_4V */
+    VP56_FRAME_GOLDEN,    /* VP56_MB_INTER_V1_GF */
+    VP56_FRAME_GOLDEN,    /* VP56_MB_INTER_V2_GF */
+};
+
+static const uint8_t vp56_ac_dequant[64] = {
+    94, 92, 90, 88, 86, 82, 78, 74,
+    70, 66, 62, 58, 54, 53, 52, 51,
+    50, 49, 48, 47, 46, 45, 44, 43,
+    42, 40, 39, 37, 36, 35, 34, 33,
+    32, 31, 30, 29, 28, 27, 26, 25,
+    24, 23, 22, 21, 20, 19, 18, 17,
+    16, 15, 14, 13, 12, 11, 10,  9,
+     8,  7,  6,  5,  4,  3,  2,  1,
+};
+
+static const uint8_t vp56_dc_dequant[64] = {
+    47, 47, 47, 47, 45, 43, 43, 43,
+    43, 43, 42, 41, 41, 40, 40, 40,
+    40, 35, 35, 35, 35, 33, 33, 33,
+    33, 32, 32, 32, 27, 27, 26, 26,
+    25, 25, 24, 24, 23, 23, 19, 19,
+    19, 19, 18, 18, 17, 16, 16, 16,
+    16, 16, 15, 11, 11, 11, 10, 10,
+     9,  8,  7,  5,  3,  3,  2,  2,
+};
+
+static const uint8_t vp56_pre_def_mb_type_stats[16][3][10][2] = {
+  { { {   9, 15 }, {  32, 25 }, {  7,  19 }, {   9, 21 }, {  1, 12 },
+      {  14, 12 }, {   3, 18 }, { 14,  23 }, {   3, 10 }, {  0,  4 }, },
+    { {  41, 22 }, {   1,  0 }, {  1,  31 }, {   0,  0 }, {  0,  0 },
+      {   0,  1 }, {   1,  7 }, {  0,   1 }, {  98, 25 }, {  4, 10 }, },
+    { {   2,  3 }, {   2,  3 }, {  0,   2 }, {   0,  2 }, {  0,  0 },
+      {  11,  4 }, {   1,  4 }, {  0,   2 }, {   3,  2 }, {  0,  4 }, }, },
+  { { {  48, 39 }, {   1,  2 }, { 11,  27 }, {  29, 44 }, {  7, 27 },
+      {   1,  4 }, {   0,  3 }, {  1,   6 }, {   1,  2 }, {  0,  0 }, },
+    { { 123, 37 }, {   6,  4 }, {  1,  27 }, {   0,  0 }, {  0,  0 },
+      {   5,  8 }, {   1,  7 }, {  0,   1 }, {  12, 10 }, {  0,  2 }, },
+    { {  49, 46 }, {   3,  4 }, {  7,  31 }, {  42, 41 }, {  0,  0 },
+      {   2,  6 }, {   1,  7 }, {  1,   4 }, {   2,  4 }, {  0,  1 }, }, },
+  { { {  21, 32 }, {   1,  2 }, {  4,  10 }, {  32, 43 }, {  6, 23 },
+      {   2,  3 }, {   1, 19 }, {  1,   6 }, {  12, 21 }, {  0,  7 }, },
+    { {  26, 14 }, {  14, 12 }, {  0,  24 }, {   0,  0 }, {  0,  0 },
+      {  55, 17 }, {   1,  9 }, {  0,  36 }, {   5,  7 }, {  1,  3 }, },
+    { {  26, 25 }, {   1,  1 }, {  2,  10 }, {  67, 39 }, {  0,  0 },
+      {   1,  1 }, {   0, 14 }, {  0,   2 }, {  31, 26 }, {  1,  6 }, }, },
+  { { {  69, 83 }, {   0,  0 }, {  0,   2 }, {  10, 29 }, {  3, 12 },
+      {   0,  1 }, {   0,  3 }, {  0,   3 }, {   2,  2 }, {  0,  0 }, },
+    { { 209,  5 }, {   0,  0 }, {  0,  27 }, {   0,  0 }, {  0,  0 },
+      {   0,  1 }, {   0,  1 }, {  0,   1 }, {   0,  0 }, {  0,  0 }, },
+    { { 103, 46 }, {   1,  2 }, {  2,  10 }, {  33, 42 }, {  0,  0 },
+      {   1,  4 }, {   0,  3 }, {  0,   1 }, {   1,  3 }, {  0,  0 }, }, },
+  { { {  11, 20 }, {   1,  4 }, { 18,  36 }, {  43, 48 }, { 13, 35 },
+      {   0,  2 }, {   0,  5 }, {  3,  12 }, {   1,  2 }, {  0,  0 }, },
+    { {   2,  5 }, {   4,  5 }, {  0, 121 }, {   0,  0 }, {  0,  0 },
+      {   0,  3 }, {   2,  4 }, {  1,   4 }, {   2,  2 }, {  0,  1 }, },
+    { {  14, 31 }, {   9, 13 }, { 14,  54 }, {  22, 29 }, {  0,  0 },
+      {   2,  6 }, {   4, 18 }, {  6,  13 }, {   1,  5 }, {  0,  1 }, }, },
+  { { {  70, 44 }, {   0,  1 }, {  2,  10 }, {  37, 46 }, {  8, 26 },
+      {   0,  2 }, {   0,  2 }, {  0,   2 }, {   0,  1 }, {  0,  0 }, },
+    { { 175,  5 }, {   0,  1 }, {  0,  48 }, {   0,  0 }, {  0,  0 },
+      {   0,  2 }, {   0,  1 }, {  0,   2 }, {   0,  1 }, {  0,  0 }, },
+    { {  85, 39 }, {   0,  0 }, {  1,   9 }, {  69, 40 }, {  0,  0 },
+      {   0,  1 }, {   0,  3 }, {  0,   1 }, {   2,  3 }, {  0,  0 }, }, },
+  { { {   8, 15 }, {   0,  1 }, {  8,  21 }, {  74, 53 }, { 22, 42 },
+      {   0,  1 }, {   0,  2 }, {  0,   3 }, {   1,  2 }, {  0,  0 }, },
+    { {  83,  5 }, {   2,  3 }, {  0, 102 }, {   0,  0 }, {  0,  0 },
+      {   1,  3 }, {   0,  2 }, {  0,   1 }, {   0,  0 }, {  0,  0 }, },
+    { {  31, 28 }, {   0,  0 }, {  3,  14 }, { 130, 34 }, {  0,  0 },
+      {   0,  1 }, {   0,  3 }, {  0,   1 }, {   3,  3 }, {  0,  1 }, }, },
+  { { { 141, 42 }, {   0,  0 }, {  1,   4 }, {  11, 24 }, {  1, 11 },
+      {   0,  1 }, {   0,  1 }, {  0,   2 }, {   0,  0 }, {  0,  0 }, },
+    { { 233,  6 }, {   0,  0 }, {  0,   8 }, {   0,  0 }, {  0,  0 },
+      {   0,  1 }, {   0,  1 }, {  0,   0 }, {   0,  1 }, {  0,  0 }, },
+    { { 171, 25 }, {   0,  0 }, {  1,   5 }, {  25, 21 }, {  0,  0 },
+      {   0,  1 }, {   0,  1 }, {  0,   0 }, {   0,  0 }, {  0,  0 }, }, },
+  { { {   8, 19 }, {   4, 10 }, { 24,  45 }, {  21, 37 }, {  9, 29 },
+      {   0,  3 }, {   1,  7 }, { 11,  25 }, {   0,  2 }, {  0,  1 }, },
+    { {  34, 16 }, { 112, 21 }, {  1,  28 }, {   0,  0 }, {  0,  0 },
+      {   6,  8 }, {   1,  7 }, {  0,   3 }, {   2,  5 }, {  0,  2 }, },
+    { {  17, 21 }, {  68, 29 }, {  6,  15 }, {  13, 22 }, {  0,  0 },
+      {   6, 12 }, {   3, 14 }, {  4,  10 }, {   1,  7 }, {  0,  3 }, }, },
+  { { {  46, 42 }, {   0,  1 }, {  2,  10 }, {  54, 51 }, { 10, 30 },
+      {   0,  2 }, {   0,  2 }, {  0,   1 }, {   0,  1 }, {  0,  0 }, },
+    { { 159, 35 }, {   2,  2 }, {  0,  25 }, {   0,  0 }, {  0,  0 },
+      {   3,  6 }, {   0,  5 }, {  0,   1 }, {   4,  4 }, {  0,  1 }, },
+    { {  51, 39 }, {   0,  1 }, {  2,  12 }, {  91, 44 }, {  0,  0 },
+      {   0,  2 }, {   0,  3 }, {  0,   1 }, {   2,  3 }, {  0,  1 }, }, },
+  { { {  28, 32 }, {   0,  0 }, {  3,  10 }, {  75, 51 }, { 14, 33 },
+      {   0,  1 }, {   0,  2 }, {  0,   1 }, {   1,  2 }, {  0,  0 }, },
+    { {  75, 39 }, {   5,  7 }, {  2,  48 }, {   0,  0 }, {  0,  0 },
+      {   3, 11 }, {   2, 16 }, {  1,   4 }, {   7, 10 }, {  0,  2 }, },
+    { {  81, 25 }, {   0,  0 }, {  2,   9 }, { 106, 26 }, {  0,  0 },
+      {   0,  1 }, {   0,  1 }, {  0,   1 }, {   1,  1 }, {  0,  0 }, }, },
+  { { { 100, 46 }, {   0,  1 }, {  3,   9 }, {  21, 37 }, {  5, 20 },
+      {   0,  1 }, {   0,  2 }, {  1,   2 }, {   0,  1 }, {  0,  0 }, },
+    { { 212, 21 }, {   0,  1 }, {  0,   9 }, {   0,  0 }, {  0,  0 },
+      {   1,  2 }, {   0,  2 }, {  0,   0 }, {   2,  2 }, {  0,  0 }, },
+    { { 140, 37 }, {   0,  1 }, {  1,   8 }, {  24, 33 }, {  0,  0 },
+      {   1,  2 }, {   0,  2 }, {  0,   1 }, {   1,  2 }, {  0,  0 }, }, },
+  { { {  27, 29 }, {   0,  1 }, {  9,  25 }, {  53, 51 }, { 12, 34 },
+      {   0,  1 }, {   0,  3 }, {  1,   5 }, {   0,  2 }, {  0,  0 }, },
+    { {   4,  2 }, {   0,  0 }, {  0, 172 }, {   0,  0 }, {  0,  0 },
+      {   0,  1 }, {   0,  2 }, {  0,   0 }, {   2,  0 }, {  0,  0 }, },
+    { {  14, 23 }, {   1,  3 }, { 11,  53 }, {  90, 31 }, {  0,  0 },
+      {   0,  3 }, {   1,  5 }, {  2,   6 }, {   1,  2 }, {  0,  0 }, }, },
+  { { {  80, 38 }, {   0,  0 }, {  1,   4 }, {  69, 33 }, {  5, 16 },
+      {   0,  1 }, {   0,  1 }, {  0,   0 }, {   0,  1 }, {  0,  0 }, },
+    { { 187, 22 }, {   1,  1 }, {  0,  17 }, {   0,  0 }, {  0,  0 },
+      {   3,  6 }, {   0,  4 }, {  0,   1 }, {   4,  4 }, {  0,  1 }, },
+    { { 123, 29 }, {   0,  0 }, {  1,   7 }, {  57, 30 }, {  0,  0 },
+      {   0,  1 }, {   0,  1 }, {  0,   1 }, {   0,  1 }, {  0,  0 }, }, },
+  { { {  16, 20 }, {   0,  0 }, {  2,   8 }, { 104, 49 }, { 15, 33 },
+      {   0,  1 }, {   0,  1 }, {  0,   1 }, {   1,  1 }, {  0,  0 }, },
+    { { 133,  6 }, {   1,  2 }, {  1,  70 }, {   0,  0 }, {  0,  0 },
+      {   0,  2 }, {   0,  4 }, {  0,   3 }, {   1,  1 }, {  0,  0 }, },
+    { {  13, 14 }, {   0,  0 }, {  4,  20 }, { 175, 20 }, {  0,  0 },
+      {   0,  1 }, {   0,  1 }, {  0,   1 }, {   1,  1 }, {  0,  0 }, }, },
+  { { { 194, 16 }, {   0,  0 }, {  1,   1 }, {   1,  9 }, {  1,  3 },
+      {   0,  0 }, {   0,  1 }, {  0,   1 }, {   0,  0 }, {  0,  0 }, },
+    { { 251,  1 }, {   0,  0 }, {  0,   2 }, {   0,  0 }, {  0,  0 },
+      {   0,  0 }, {   0,  0 }, {  0,   0 }, {   0,  0 }, {  0,  0 }, },
+    { { 202, 23 }, {   0,  0 }, {  1,   3 }, {   2,  9 }, {  0,  0 },
+      {   0,  1 }, {   0,  1 }, {  0,   1 }, {   0,  0 }, {  0,  0 }, }, },
+};
+
+static const uint8_t vp56_filter_threshold[] = {
+    14, 14, 13, 13, 12, 12, 10, 10,
+    10, 10,  8,  8,  8,  8,  8,  8,
+     8,  8,  8,  8,  8,  8,  8,  8,
+     8,  8,  8,  8,  8,  8,  8,  8,
+     8,  8,  8,  8,  7,  7,  7,  7,
+     7,  7,  6,  6,  6,  6,  6,  6,
+     5,  5,  5,  5,  4,  4,  4,  4,
+     4,  4,  4,  3,  3,  3,  3,  2,
+};
+
+static const uint8_t vp56_mb_type_model_model[] = {
+    171, 83, 199, 140, 125, 104,
+};
+
+static const vp56_tree_t vp56_pmbtm_tree[] = {
+    { 4, 0},
+    { 2, 1}, {-8}, {-4},
+    { 8, 2},
+    { 6, 3},
+    { 4, 4},
+    { 2, 5}, {-24}, {-20}, {-16}, {-12}, {-0},
+};
+
+static const vp56_tree_t vp56_pmbt_tree[] = {
+    { 8, 1},
+    { 4, 2},
+    { 2, 4}, {-VP56_MB_INTER_NOVEC_PF}, {-VP56_MB_INTER_DELTA_PF},
+    { 2, 5}, {-VP56_MB_INTER_V1_PF},    {-VP56_MB_INTER_V2_PF},
+    { 4, 3},
+    { 2, 6}, {-VP56_MB_INTRA},          {-VP56_MB_INTER_4V},
+    { 4, 7},
+    { 2, 8}, {-VP56_MB_INTER_NOVEC_GF}, {-VP56_MB_INTER_DELTA_GF},
+    { 2, 9}, {-VP56_MB_INTER_V1_GF},    {-VP56_MB_INTER_V2_GF},
+};
+
+/* relative pos of surrounding blocks, from closest to farthest */
+static const int8_t vp56_candidate_predictor_pos[12][2] = {
+    {  0, -1 },
+    { -1,  0 },
+    { -1, -1 },
+    {  1, -1 },
+    {  0, -2 },
+    { -2,  0 },
+    { -2, -1 },
+    { -1, -2 },
+    {  1, -2 },
+    {  2, -1 },
+    { -2, -2 },
+    {  2, -2 },
+};
+
+#endif /* VP56DATA */

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/vp5data.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/vp5data.h	2007-01-21 18:32:13 UTC (rev 2756)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/vp5data.h	2007-01-21 18:34:00 UTC (rev 2757)
@@ -0,0 +1,173 @@
+/**
+ * @file vp5data.h
+ * VP5 compatible video decoder
+ *
+ * Copyright (C) 2006  Aurelien Jacobs <aurel at gnuage.org>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef VP5DATA_H
+#define VP5DATA_H
+
+static const uint8_t vp5_coeff_groups[] = {
+    -1, 0, 1, 1, 2, 1, 1, 2,
+     2, 1, 1, 2, 2, 2, 1, 2,
+     2, 2, 2, 2, 1, 1, 2, 2,
+     3, 3, 4, 3, 4, 4, 4, 3,
+     3, 3, 3, 3, 4, 3, 3, 3,
+     4, 4, 4, 4, 4, 3, 3, 4,
+     4, 4, 3, 4, 4, 4, 4, 4,
+     4, 4, 5, 5, 5, 5, 5, 5,
+};
+
+static const uint8_t vp5_vmc_pct[2][11] = {
+    { 243, 220, 251, 253, 237, 232, 241, 245, 247, 251, 253 },
+    { 235, 211, 246, 249, 234, 231, 248, 249, 252, 252, 254 },
+};
+
+static const uint8_t vp5_dccv_pct[2][11] = {
+    { 146, 197, 181, 207, 232, 243, 238, 251, 244, 250, 249 },
+    { 179, 219, 214, 240, 250, 254, 244, 254, 254, 254, 254 },
+};
+
+static const uint8_t vp5_ract_pct[3][2][6][11] = {
+    { { { 227, 246, 230, 247, 244, 254, 254, 254, 254, 254, 254 },
+        { 202, 254, 209, 231, 231, 249, 249, 253, 254, 254, 254 },
+        { 206, 254, 225, 242, 241, 251, 253, 254, 254, 254, 254 },
+        { 235, 254, 241, 253, 252, 254, 254, 254, 254, 254, 254 },
+        { 234, 254, 248, 254, 254, 254, 254, 254, 254, 254, 254 },
+        { 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254 } },
+      { { 240, 254, 248, 254, 254, 254, 254, 254, 254, 254, 254 },
+        { 238, 254, 240, 253, 254, 254, 254, 254, 254, 254, 254 },
+        { 244, 254, 251, 254, 254, 254, 254, 254, 254, 254, 254 },
+        { 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254 },
+        { 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254 },
+        { 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254 } } },
+    { { { 206, 203, 227, 239, 247, 254, 253, 254, 254, 254, 254 },
+        { 207, 199, 220, 236, 243, 252, 252, 254, 254, 254, 254 },
+        { 212, 219, 230, 243, 244, 253, 252, 254, 254, 254, 254 },
+        { 236, 237, 247, 252, 253, 254, 254, 254, 254, 254, 254 },
+        { 240, 240, 248, 254, 254, 254, 254, 254, 254, 254, 254 },
+        { 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254 } },
+      { { 230, 233, 249, 254, 254, 254, 254, 254, 254, 254, 254 },
+        { 238, 238, 250, 254, 254, 254, 254, 254, 254, 254, 254 },
+        { 248, 251, 254, 254, 254, 254, 254, 254, 254, 254, 254 },
+        { 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254 },
+        { 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254 },
+        { 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254 } } },
+    { { { 225, 239, 227, 231, 244, 253, 243, 254, 254, 253, 254 },
+        { 232, 234, 224, 228, 242, 249, 242, 252, 251, 251, 254 },
+        { 235, 249, 238, 240, 251, 254, 249, 254, 253, 253, 254 },
+        { 249, 253, 251, 250, 254, 254, 254, 254, 254, 254, 254 },
+        { 251, 250, 249, 254, 254, 254, 254, 254, 254, 254, 254 },
+        { 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254 } },
+      { { 243, 244, 250, 250, 254, 254, 254, 254, 254, 254, 254 },
+        { 249, 248, 250, 253, 254, 254, 254, 254, 254, 254, 254 },
+        { 253, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254 },
+        { 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254 },
+        { 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254 },
+        { 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254 } } },
+};
+
+static const int16_t vp5_dccv_lc[5][36][2] = {
+    { {154,  61}, {141,  54}, { 90,  45}, { 54,  34}, { 54,  13}, {128, 109},
+      {136,  54}, {148,  45}, { 92,  41}, { 54,  33}, { 51,  15}, { 87, 113},
+      { 87,  44}, { 97,  40}, { 67,  36}, { 46,  29}, { 41,  15}, { 64,  80},
+      { 59,  33}, { 61,  31}, { 51,  28}, { 44,  22}, { 33,  12}, { 49,  63},
+      { 69,  12}, { 59,  16}, { 46,  14}, { 31,  13}, { 26,   6}, { 92,  26},
+      {128, 108}, { 77, 119}, { 54,  84}, { 26,  71}, { 87,  19}, { 95, 155} },
+    { {154,   4}, {182,   0}, {159,  -8}, {128,  -5}, {143,  -5}, {187,  55},
+      {182,   0}, {228,  -3}, {187,  -7}, {174,  -9}, {189, -11}, {169,  79},
+      {161,  -9}, {192,  -8}, {187,  -9}, {169, -10}, {136,  -9}, {184,  40},
+      {164, -11}, {179, -10}, {174, -10}, {161, -10}, {115,  -7}, {197,  20},
+      {195, -11}, {195, -11}, {146, -10}, {110,  -6}, { 95,  -4}, {195,  39},
+      {182,  55}, {172,  77}, {177,  37}, {169,  29}, {172,  52}, { 92, 162} },
+    { {174,  80}, {164,  80}, { 95,  80}, { 46,  66}, { 56,  24}, { 36, 193},
+      {164,  80}, {166,  77}, {105,  76}, { 49,  68}, { 46,  31}, { 49, 186},
+      { 97,  78}, {110,  74}, { 72,  72}, { 44,  60}, { 33,  30}, { 69, 131},
+      { 61,  61}, { 69,  63}, { 51,  57}, { 31,  48}, { 26,  27}, { 64,  89},
+      { 67,  23}, { 51,  32}, { 36,  33}, { 26,  28}, { 20,  12}, { 44,  68},
+      { 26, 197}, { 41, 189}, { 61, 129}, { 28, 103}, { 49,  52}, {-12, 245} },
+    { {102, 141}, { 79, 166}, { 72, 162}, { 97, 125}, {179,   4}, {307,   0},
+      { 72, 168}, { 69, 175}, { 84, 160}, {105, 127}, {148,  34}, {310,   0},
+      { 84, 151}, { 82, 161}, { 87, 153}, { 87, 135}, {115,  51}, {317,   0},
+      { 97, 125}, {102, 131}, {105, 125}, { 87, 122}, { 84,  64}, { 54, 184},
+      {166,  18}, {146,  43}, {125,  51}, { 90,  64}, { 95,   7}, { 38, 154},
+      {294,   0}, { 13, 225}, { 10, 225}, { 67, 168}, {  0, 167}, {161,  94} },
+    { {172,  76}, {172,  75}, {136,  80}, { 64,  98}, { 74,  67}, {315,   0},
+      {169,  76}, {207,  56}, {164,  66}, { 97,  80}, { 67,  72}, {328,   0},
+      {136,  80}, {187,  53}, {154,  62}, { 72,  85}, { -2, 105}, {305,   0},
+      { 74,  91}, {128,  64}, {113,  64}, { 61,  77}, { 41,  75}, {259,   0},
+      { 46,  84}, { 51,  81}, { 28,  89}, { 31,  78}, { 23,  77}, {202,   0},
+      {323,   0}, {323,   0}, {300,   0}, {236,   0}, {195,   0}, {328,   0} },
+};
+
+static const int16_t vp5_ract_lc[3][3][5][6][2] = {
+    { { { {276,  0}, {238,  0}, {195,  0}, {156,  0}, {113,  0}, {274,  0} },
+        { {  0,  1}, {  0,  1}, {  0,  1}, {  0,  1}, {  0,  1}, {  0,  1} },
+        { {192, 59}, {182, 50}, {141, 48}, {110, 40}, { 92, 19}, {125,128} },
+        { {169, 87}, {169, 83}, {184, 62}, {220, 16}, {184,  0}, {264,  0} },
+        { {212, 40}, {212, 36}, {169, 49}, {174, 27}, {  8,120}, {182, 71} } },
+      { { {259, 10}, {197, 19}, {143, 22}, {123, 16}, {110,  8}, {133, 88} },
+        { {  0,  1}, {256,  0}, {  0,  1}, {  0,  1}, {  0,  1}, {  0,  1} },
+        { {207, 46}, {187, 50}, { 97, 83}, { 23,100}, { 41, 56}, { 56,188} },
+        { {166, 90}, {146,108}, {161, 88}, {136, 95}, {174,  0}, {266,  0} },
+        { {264,  7}, {243, 18}, {184, 43}, {-14,154}, { 20,112}, { 20,199} } },
+      { { {230, 26}, {197, 22}, {159, 20}, {146, 12}, {136,  4}, { 54,162} },
+        { {  0,  1}, {  0,  1}, {  0,  1}, {  0,  1}, {  0,  1}, {  0,  1} },
+        { {192, 59}, {156, 72}, { 84,101}, { 49,101}, { 79, 47}, { 79,167} },
+        { {138,115}, {136,116}, {166, 80}, {238,  0}, {195,  0}, {261,  0} },
+        { {225, 33}, {205, 42}, {159, 61}, { 79, 96}, { 92, 66}, { 28,195} } },
+    }, {
+      { { {200, 37}, {197, 18}, {159, 13}, {143,  7}, {102,  5}, {123,126} },
+        { {197,  3}, {220, -9}, {210,-12}, {187, -6}, {151, -2}, {174, 80} },
+        { {200, 53}, {187, 47}, {159, 40}, {118, 38}, {100, 18}, {141,111} },
+        { {179, 78}, {166, 86}, {197, 50}, {207, 27}, {187,  0}, {115,139} },
+        { {218, 34}, {220, 29}, {174, 46}, {128, 61}, { 54, 89}, {187, 65} } },
+      { { {238, 14}, {197, 18}, {125, 26}, { 90, 25}, { 82, 13}, {161, 86} },
+        { {189,  1}, {205, -2}, {156, -4}, {143, -4}, {146, -4}, {172, 72} },
+        { {230, 31}, {192, 45}, {102, 76}, { 38, 85}, { 56, 41}, { 64,173} },
+        { {166, 91}, {141,111}, {128,116}, {118,109}, {177,  0}, { 23,222} },
+        { {253, 14}, {236, 21}, {174, 49}, { 33,118}, { 44, 93}, { 23,187} } },
+      { { {218, 28}, {179, 28}, {118, 35}, { 95, 30}, { 72, 24}, {128,108} },
+        { {187,  1}, {174, -1}, {125, -1}, {110, -1}, {108, -1}, {202, 52} },
+        { {197, 53}, {146, 75}, { 46,118}, { 33,103}, { 64, 50}, {118,126} },
+        { {138,114}, {128,122}, {161, 86}, {243, -6}, {195,  0}, { 38,210} },
+        { {215, 39}, {179, 58}, { 97,101}, { 95, 85}, { 87, 70}, { 69,152} } },
+    }, {
+      { { {236, 24}, {205, 18}, {172, 12}, {154,  6}, {125,  1}, {169, 75} },
+        { {187,  4}, {230, -2}, {228, -4}, {236, -4}, {241, -2}, {192, 66} },
+        { {200, 46}, {187, 42}, {159, 34}, {136, 25}, {105, 10}, {179, 62} },
+        { {207, 55}, {192, 63}, {192, 54}, {195, 36}, {177,  1}, {143, 98} },
+        { {225, 27}, {207, 34}, {200, 30}, {131, 57}, { 97, 60}, {197, 45} } },
+      { { {271,  8}, {218, 13}, {133, 19}, { 90, 19}, { 72,  7}, {182, 51} },
+        { {179,  1}, {225, -1}, {154, -2}, {110, -1}, { 92,  0}, {195, 41} },
+        { {241, 26}, {189, 40}, { 82, 64}, { 33, 60}, { 67, 17}, {120, 94} },
+        { {192, 68}, {151, 94}, {146, 90}, {143, 72}, {161,  0}, {113,128} },
+        { {256, 12}, {218, 29}, {166, 48}, { 44, 99}, { 31, 87}, {148, 78} } },
+      { { {238, 20}, {184, 22}, {113, 27}, { 90, 22}, { 74,  9}, {192, 37} },
+        { {184,  0}, {215, -1}, {141, -1}, { 97,  0}, { 49,  0}, {264, 13} },
+        { {182, 51}, {138, 61}, { 95, 63}, { 54, 59}, { 64, 25}, {200, 45} },
+        { {179, 75}, {156, 87}, {174, 65}, {177, 44}, {174,  0}, {164, 85} },
+        { {195, 45}, {148, 65}, {105, 79}, { 95, 72}, { 87, 60}, {169, 63} } },
+    }
+};
+
+static const uint8_t vp5_coord_div[] = { 2, 2, 2, 2, 4, 4 };
+
+#endif /* VP5DATA_H */

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/vp6.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/vp6.c	2007-01-21 18:32:13 UTC (rev 2756)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/vp6.c	2007-01-21 18:34:00 UTC (rev 2757)
@@ -0,0 +1,556 @@
+/**
+ * @file vp6.c
+ * VP6 compatible video decoder
+ *
+ * Copyright (C) 2006  Aurelien Jacobs <aurel at gnuage.org>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *
+ * The VP6F decoder accept an optional 1 byte extradata. It is composed of:
+ *  - upper 4bits: difference between encoded width and visible width
+ *  - lower 4bits: difference between encoded height and visible height
+ */
+
+#include <stdlib.h>
+
+#include "avcodec.h"
+#include "dsputil.h"
+#include "bitstream.h"
+#include "mpegvideo.h"
+
+#include "vp56.h"
+#include "vp56data.h"
+#include "vp6data.h"
+
+
+static int vp6_parse_header(vp56_context_t *s, uint8_t *buf, int buf_size,
+                            int *golden_frame)
+{
+    vp56_range_coder_t *c = &s->c;
+    int parse_filter_info = 0;
+    int coeff_offset = 0;
+    int vrt_shift = 0;
+    int sub_version;
+    int rows, cols;
+    int res = 1;
+    int separated_coeff = buf[0] & 1;
+
+    s->frames[VP56_FRAME_CURRENT].key_frame = !(buf[0] & 0x80);
+    vp56_init_dequant(s, (buf[0] >> 1) & 0x3F);
+
+    if (s->frames[VP56_FRAME_CURRENT].key_frame) {
+        sub_version = buf[1] >> 3;
+        if (sub_version > 8)
+            return 0;
+        s->filter_header = buf[1] & 0x06;
+        if (buf[1] & 1) {
+            av_log(s->avctx, AV_LOG_ERROR, "interlacing not supported\n");
+            return 0;
+        }
+        if (separated_coeff || !s->filter_header) {
+            coeff_offset = AV_RB16(buf+2) - 2;
+            buf += 2;
+            buf_size -= 2;
+        }
+
+        rows = buf[2];  /* number of stored macroblock rows */
+        cols = buf[3];  /* number of stored macroblock cols */
+        /* buf[4] is number of displayed macroblock rows */
+        /* buf[5] is number of displayed macroblock cols */
+
+        if (16*cols != s->avctx->coded_width ||
+            16*rows != s->avctx->coded_height) {
+            avcodec_set_dimensions(s->avctx, 16*cols, 16*rows);
+            if (s->avctx->extradata_size == 1) {
+                s->avctx->width  -= s->avctx->extradata[0] >> 4;
+                s->avctx->height -= s->avctx->extradata[0] & 0x0F;
+            }
+            res = 2;
+        }
+
+        vp56_init_range_decoder(c, buf+6, buf_size-6);
+        vp56_rac_gets(c, 2);
+
+        parse_filter_info = s->filter_header;
+        if (sub_version < 8)
+            vrt_shift = 5;
+        s->sub_version = sub_version;
+    } else {
+        if (!s->sub_version)
+            return 0;
+
+        if (separated_coeff || !s->filter_header) {
+            coeff_offset = AV_RB16(buf+1) - 2;
+            buf += 2;
+            buf_size -= 2;
+        }
+        vp56_init_range_decoder(c, buf+1, buf_size-1);
+
+        *golden_frame = vp56_rac_get(c);
+        if (s->filter_header) {
+            s->deblock_filtering = vp56_rac_get(c);
+            if (s->deblock_filtering)
+                vp56_rac_get(c);
+            if (s->sub_version > 7)
+                parse_filter_info = vp56_rac_get(c);
+        }
+    }
+
+    if (parse_filter_info) {
+        if (vp56_rac_get(c)) {
+            s->filter_mode = 2;
+            s->sample_variance_threshold = vp56_rac_gets(c, 5) << vrt_shift;
+            s->max_vector_length = 2 << vp56_rac_gets(c, 3);
+        } else if (vp56_rac_get(c)) {
+            s->filter_mode = 1;
+        } else {
+            s->filter_mode = 0;
+        }
+        if (s->sub_version > 7)
+            s->filter_selection = vp56_rac_gets(c, 4);
+        else
+            s->filter_selection = 16;
+    }
+
+    vp56_rac_get(c);
+
+    if (coeff_offset) {
+        vp56_init_range_decoder(&s->cc, buf+coeff_offset,
+                                buf_size-coeff_offset);
+        s->ccp = &s->cc;
+    } else {
+        s->ccp = &s->c;
+    }
+
+    return res;
+}
+
+static void vp6_coeff_order_table_init(vp56_context_t *s)
+{
+    int i, pos, idx = 1;
+
+    s->coeff_index_to_pos[0] = 0;
+    for (i=0; i<16; i++)
+        for (pos=1; pos<64; pos++)
+            if (s->coeff_reorder[pos] == i)
+                s->coeff_index_to_pos[idx++] = pos;
+}
+
+static void vp6_default_models_init(vp56_context_t *s)
+{
+    s->vector_model_dct[0] = 0xA2;
+    s->vector_model_dct[1] = 0xA4;
+    s->vector_model_sig[0] = 0x80;
+    s->vector_model_sig[1] = 0x80;
+
+    memcpy(s->mb_types_stats, vp56_def_mb_types_stats, sizeof(s->mb_types_stats));
+    memcpy(s->vector_model_fdv, vp6_def_fdv_vector_model, sizeof(s->vector_model_fdv));
+    memcpy(s->vector_model_pdv, vp6_def_pdv_vector_model, sizeof(s->vector_model_pdv));
+    memcpy(s->coeff_model_runv, vp6_def_runv_coeff_model, sizeof(s->coeff_model_runv));
+    memcpy(s->coeff_reorder, vp6_def_coeff_reorder, sizeof(s->coeff_reorder));
+
+    vp6_coeff_order_table_init(s);
+}
+
+static void vp6_parse_vector_models(vp56_context_t *s)
+{
+    vp56_range_coder_t *c = &s->c;
+    int comp, node;
+
+    for (comp=0; comp<2; comp++) {
+        if (vp56_rac_get_prob(c, vp6_sig_dct_pct[comp][0]))
+            s->vector_model_dct[comp] = vp56_rac_gets_nn(c, 7);
+        if (vp56_rac_get_prob(c, vp6_sig_dct_pct[comp][1]))
+            s->vector_model_sig[comp] = vp56_rac_gets_nn(c, 7);
+    }
+
+    for (comp=0; comp<2; comp++)
+        for (node=0; node<7; node++)
+            if (vp56_rac_get_prob(c, vp6_pdv_pct[comp][node]))
+                s->vector_model_pdv[comp][node] = vp56_rac_gets_nn(c, 7);
+
+    for (comp=0; comp<2; comp++)
+        for (node=0; node<8; node++)
+            if (vp56_rac_get_prob(c, vp6_fdv_pct[comp][node]))
+                s->vector_model_fdv[comp][node] = vp56_rac_gets_nn(c, 7);
+}
+
+static void vp6_parse_coeff_models(vp56_context_t *s)
+{
+    vp56_range_coder_t *c = &s->c;
+    int def_prob[11];
+    int node, cg, ctx, pos;
+    int ct;    /* code type */
+    int pt;    /* plane type (0 for Y, 1 for U or V) */
+
+    memset(def_prob, 0x80, sizeof(def_prob));
+
+    for (pt=0; pt<2; pt++)
+        for (node=0; node<11; node++)
+            if (vp56_rac_get_prob(c, vp6_dccv_pct[pt][node])) {
+                def_prob[node] = vp56_rac_gets_nn(c, 7);
+                s->coeff_model_dccv[pt][node] = def_prob[node];
+            } else if (s->frames[VP56_FRAME_CURRENT].key_frame) {
+                s->coeff_model_dccv[pt][node] = def_prob[node];
+            }
+
+    if (vp56_rac_get(c)) {
+        for (pos=1; pos<64; pos++)
+            if (vp56_rac_get_prob(c, vp6_coeff_reorder_pct[pos]))
+                s->coeff_reorder[pos] = vp56_rac_gets(c, 4);
+        vp6_coeff_order_table_init(s);
+    }
+
+    for (cg=0; cg<2; cg++)
+        for (node=0; node<14; node++)
+            if (vp56_rac_get_prob(c, vp6_runv_pct[cg][node]))
+                s->coeff_model_runv[cg][node] = vp56_rac_gets_nn(c, 7);
+
+    for (ct=0; ct<3; ct++)
+        for (pt=0; pt<2; pt++)
+            for (cg=0; cg<6; cg++)
+                for (node=0; node<11; node++)
+                    if (vp56_rac_get_prob(c, vp6_ract_pct[ct][pt][cg][node])) {
+                        def_prob[node] = vp56_rac_gets_nn(c, 7);
+                        s->coeff_model_ract[pt][ct][cg][node] = def_prob[node];
+                    } else if (s->frames[VP56_FRAME_CURRENT].key_frame) {
+                        s->coeff_model_ract[pt][ct][cg][node] = def_prob[node];
+                    }
+
+    /* coeff_model_dcct is a linear combination of coeff_model_dccv */
+    for (pt=0; pt<2; pt++)
+        for (ctx=0; ctx<3; ctx++)
+            for (node=0; node<5; node++)
+                s->coeff_model_dcct[pt][ctx][node] = clip(((s->coeff_model_dccv[pt][node] * vp6_dccv_lc[ctx][node][0] + 128) >> 8) + vp6_dccv_lc[ctx][node][1], 1, 255);
+}
+
+static void vp6_parse_vector_adjustment(vp56_context_t *s, vp56_mv_t *vect)
+{
+    vp56_range_coder_t *c = &s->c;
+    int comp;
+
+    *vect = (vp56_mv_t) {0,0};
+    if (s->vector_candidate_pos < 2)
+        *vect = s->vector_candidate[0];
+
+    for (comp=0; comp<2; comp++) {
+        int i, delta = 0;
+
+        if (vp56_rac_get_prob(c, s->vector_model_dct[comp])) {
+            static const uint8_t prob_order[] = {0, 1, 2, 7, 6, 5, 4};
+            for (i=0; i<sizeof(prob_order); i++) {
+                int j = prob_order[i];
+                delta |= vp56_rac_get_prob(c, s->vector_model_fdv[comp][j])<<j;
+            }
+            if (delta & 0xF0)
+                delta |= vp56_rac_get_prob(c, s->vector_model_fdv[comp][3])<<3;
+            else
+                delta |= 8;
+        } else {
+            delta = vp56_rac_get_tree(c, vp56_pva_tree,
+                                      s->vector_model_pdv[comp]);
+        }
+
+        if (delta && vp56_rac_get_prob(c, s->vector_model_sig[comp]))
+            delta = -delta;
+
+        if (!comp)
+            vect->x += delta;
+        else
+            vect->y += delta;
+    }
+}
+
+static void vp6_parse_coeff(vp56_context_t *s)
+{
+    vp56_range_coder_t *c = s->ccp;
+    uint8_t *permute = s->scantable.permutated;
+    uint8_t *model, *model2, *model3;
+    int coeff, sign, coeff_idx;
+    int b, i, cg, idx, ctx;
+    int pt = 0;    /* plane type (0 for Y, 1 for U or V) */
+
+    for (b=0; b<6; b++) {
+        int ct = 1;    /* code type */
+        int run = 1;
+
+        if (b > 3) pt = 1;
+
+        ctx = s->left_block[vp56_b6to4[b]].not_null_dc
+              + s->above_blocks[s->above_block_idx[b]].not_null_dc;
+        model = s->coeff_model_dccv[pt];
+        model2 = s->coeff_model_dcct[pt][ctx];
+
+        for (coeff_idx=0; coeff_idx<64; ) {
+            if ((coeff_idx>1 && ct==0) || vp56_rac_get_prob(c, model2[0])) {
+                /* parse a coeff */
+                if (coeff_idx == 0) {
+                    s->left_block[vp56_b6to4[b]].not_null_dc = 1;
+                    s->above_blocks[s->above_block_idx[b]].not_null_dc = 1;
+                }
+
+                if (vp56_rac_get_prob(c, model2[2])) {
+                    if (vp56_rac_get_prob(c, model2[3])) {
+                        idx = vp56_rac_get_tree(c, vp56_pc_tree, model);
+                        coeff = vp56_coeff_bias[idx];
+                        for (i=vp56_coeff_bit_length[idx]; i>=0; i--)
+                            coeff += vp56_rac_get_prob(c, vp56_coeff_parse_table[idx][i]) << i;
+                    } else {
+                        if (vp56_rac_get_prob(c, model2[4]))
+                            coeff = 3 + vp56_rac_get_prob(c, model[5]);
+                        else
+                            coeff = 2;
+                    }
+                    ct = 2;
+                } else {
+                    ct = 1;
+                    coeff = 1;
+                }
+                sign = vp56_rac_get(c);
+                coeff = (coeff ^ -sign) + sign;
+                if (coeff_idx)
+                    coeff *= s->dequant_ac;
+                idx = s->coeff_index_to_pos[coeff_idx];
+                s->block_coeff[b][permute[idx]] = coeff;
+                run = 1;
+            } else {
+                /* parse a run */
+                ct = 0;
+                if (coeff_idx == 0) {
+                    s->left_block[vp56_b6to4[b]].not_null_dc = 0;
+                    s->above_blocks[s->above_block_idx[b]].not_null_dc = 0;
+                } else {
+                    if (!vp56_rac_get_prob(c, model2[1]))
+                        break;
+
+                    model3 = s->coeff_model_runv[coeff_idx >= 6];
+                    run = vp56_rac_get_tree(c, vp6_pcr_tree, model3);
+                    if (!run)
+                        for (run=9, i=0; i<6; i++)
+                            run += vp56_rac_get_prob(c, model3[i+8]) << i;
+                }
+            }
+
+            cg = vp6_coeff_groups[coeff_idx+=run];
+            model = model2 = s->coeff_model_ract[pt][ct][cg];
+        }
+    }
+}
+
+static int vp6_adjust(int v, int t)
+{
+    int V = v, s = v >> 31;
+    V ^= s;
+    V -= s;
+    if (V-t-1 >= (unsigned)(t-1))
+        return v;
+    V = 2*t - V;
+    V += s;
+    V ^= s;
+    return V;
+}
+
+static int vp6_block_variance(uint8_t *src, int stride)
+{
+    int sum = 0, square_sum = 0;
+    int y, x;
+
+    for (y=0; y<8; y+=2) {
+        for (x=0; x<8; x+=2) {
+            sum += src[x];
+            square_sum += src[x]*src[x];
+        }
+        src += 2*stride;
+    }
+    return (16*square_sum - sum*sum) >> 8;
+}
+
+static void vp6_filter_hv2(vp56_context_t *s, uint8_t *dst, uint8_t *src,
+                           int stride, int delta, int16_t weight)
+{
+    s->dsp.put_pixels_tab[1][0](dst, src, stride, 8);
+    s->dsp.biweight_h264_pixels_tab[3](dst, src+delta, stride, 2,
+                                       8-weight, weight, 0);
+}
+
+static void vp6_filter_hv4(uint8_t *dst, uint8_t *src, int stride,
+                           int delta, const int16_t *weights)
+{
+    int x, y;
+
+    for (y=0; y<8; y++) {
+        for (x=0; x<8; x++) {
+            dst[x] = clip_uint8((  src[x-delta  ] * weights[0]
+                                 + src[x        ] * weights[1]
+                                 + src[x+delta  ] * weights[2]
+                                 + src[x+2*delta] * weights[3] + 64) >> 7);
+        }
+        src += stride;
+        dst += stride;
+    }
+}
+
+static void vp6_filter_diag2(vp56_context_t *s, uint8_t *dst, uint8_t *src,
+                             int stride, int h_weight, int v_weight)
+{
+    uint8_t *tmp = s->edge_emu_buffer+16;
+    int x, xmax;
+
+    s->dsp.put_pixels_tab[1][0](tmp, src, stride, 8);
+    s->dsp.biweight_h264_pixels_tab[3](tmp, src+1, stride, 2,
+                                       8-h_weight, h_weight, 0);
+    /* we need a 8x9 block to do vertical filter, so compute one more line */
+    for (x=8*stride, xmax=x+8; x<xmax; x++)
+        tmp[x] = (src[x]*(8-h_weight) + src[x+1]*h_weight + 4) >> 3;
+
+    s->dsp.put_pixels_tab[1][0](dst, tmp, stride, 8);
+    s->dsp.biweight_h264_pixels_tab[3](dst, tmp+stride, stride, 2,
+                                       8-v_weight, v_weight, 0);
+}
+
+static void vp6_filter_diag4(uint8_t *dst, uint8_t *src, int stride,
+                             const int16_t *h_weights,const int16_t *v_weights)
+{
+    int x, y;
+    int tmp[8*11];
+    int *t = tmp;
+
+    src -= stride;
+
+    for (y=0; y<11; y++) {
+        for (x=0; x<8; x++) {
+            t[x] = clip_uint8((  src[x-1] * h_weights[0]
+                               + src[x  ] * h_weights[1]
+                               + src[x+1] * h_weights[2]
+                               + src[x+2] * h_weights[3] + 64) >> 7);
+        }
+        src += stride;
+        t += 8;
+    }
+
+    t = tmp + 8;
+    for (y=0; y<8; y++) {
+        for (x=0; x<8; x++) {
+            dst[x] = clip_uint8((  t[x-8 ] * v_weights[0]
+                                 + t[x   ] * v_weights[1]
+                                 + t[x+8 ] * v_weights[2]
+                                 + t[x+16] * v_weights[3] + 64) >> 7);
+        }
+        dst += stride;
+        t += 8;
+    }
+}
+
+static void vp6_filter(vp56_context_t *s, uint8_t *dst, uint8_t *src,
+                       int offset1, int offset2, int stride,
+                       vp56_mv_t mv, int mask, int select, int luma)
+{
+    int filter4 = 0;
+    int x8 = mv.x & mask;
+    int y8 = mv.y & mask;
+
+    if (luma) {
+        x8 *= 2;
+        y8 *= 2;
+        filter4 = s->filter_mode;
+        if (filter4 == 2) {
+            if (s->max_vector_length &&
+                (FFABS(mv.x) > s->max_vector_length ||
+                 FFABS(mv.y) > s->max_vector_length)) {
+                filter4 = 0;
+            } else if (s->sample_variance_threshold
+                       && (vp6_block_variance(src+offset1, stride)
+                           < s->sample_variance_threshold)) {
+                filter4 = 0;
+            }
+        }
+    }
+
+    if ((y8 && (offset2-offset1)*s->flip<0) || (!y8 && offset1 > offset2)) {
+        offset1 = offset2;
+    }
+
+    if (filter4) {
+        if (!y8) {                      /* left or right combine */
+            vp6_filter_hv4(dst, src+offset1, stride, 1,
+                           vp6_block_copy_filter[select][x8]);
+        } else if (!x8) {               /* above or below combine */
+            vp6_filter_hv4(dst, src+offset1, stride, stride,
+                           vp6_block_copy_filter[select][y8]);
+        } else if ((mv.x^mv.y) >> 31) { /* lower-left or upper-right combine */
+            vp6_filter_diag4(dst, src+offset1-1, stride,
+                             vp6_block_copy_filter[select][x8],
+                             vp6_block_copy_filter[select][y8]);
+        } else {                        /* lower-right or upper-left combine */
+            vp6_filter_diag4(dst, src+offset1, stride,
+                             vp6_block_copy_filter[select][x8],
+                             vp6_block_copy_filter[select][y8]);
+        }
+    } else {
+        if (!y8) {                      /* left or right combine */
+            vp6_filter_hv2(s, dst, src+offset1, stride, 1, x8);
+        } else if (!x8) {               /* above or below combine */
+            vp6_filter_hv2(s, dst, src+offset1, stride, stride, y8);
+        } else if ((mv.x^mv.y) >> 31) { /* lower-left or upper-right combine */
+            vp6_filter_diag2(s, dst, src+offset1-1, stride, x8, y8);
+        } else {                        /* lower-right or upper-left combine */
+            vp6_filter_diag2(s, dst, src+offset1, stride, x8, y8);
+        }
+    }
+}
+
+static int vp6_decode_init(AVCodecContext *avctx)
+{
+    vp56_context_t *s = avctx->priv_data;
+
+    vp56_init(s, avctx, avctx->codec->id == CODEC_ID_VP6);
+    s->vp56_coord_div = vp6_coord_div;
+    s->parse_vector_adjustment = vp6_parse_vector_adjustment;
+    s->adjust = vp6_adjust;
+    s->filter = vp6_filter;
+    s->parse_coeff = vp6_parse_coeff;
+    s->default_models_init = vp6_default_models_init;
+    s->parse_vector_models = vp6_parse_vector_models;
+    s->parse_coeff_models = vp6_parse_coeff_models;
+    s->parse_header = vp6_parse_header;
+
+    return 0;
+}
+
+AVCodec vp6_decoder = {
+    "vp6",
+    CODEC_TYPE_VIDEO,
+    CODEC_ID_VP6,
+    sizeof(vp56_context_t),
+    vp6_decode_init,
+    NULL,
+    vp56_free,
+    vp56_decode_frame,
+};
+
+/* flash version, not flipped upside-down */
+AVCodec vp6f_decoder = {
+    "vp6f",
+    CODEC_TYPE_VIDEO,
+    CODEC_ID_VP6F,
+    sizeof(vp56_context_t),
+    vp6_decode_init,
+    NULL,
+    vp56_free,
+    vp56_decode_frame,
+};

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/vp6data.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/vp6data.h	2007-01-21 18:32:13 UTC (rev 2756)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/vp6data.h	2007-01-21 18:34:00 UTC (rev 2757)
@@ -0,0 +1,300 @@
+/**
+ * @file vp6data.h
+ * VP6 compatible video decoder
+ *
+ * Copyright (C) 2006  Aurelien Jacobs <aurel at gnuage.org>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef VP6DATA_H
+#define VP6DATA_H
+
+#include "vp56data.h"
+
+static const uint8_t vp6_def_fdv_vector_model[2][8] = {
+    { 247, 210, 135, 68, 138, 220, 239, 246 },
+    { 244, 184, 201, 44, 173, 221, 239, 253 },
+};
+
+static const uint8_t vp6_def_pdv_vector_model[2][7] = {
+    { 225, 146, 172, 147, 214,  39, 156 },
+    { 204, 170, 119, 235, 140, 230, 228 },
+};
+
+static const uint8_t vp6_def_coeff_reorder[] = {
+     0,  0,  1,  1,  1,  2,  2,  2,
+     2,  2,  2,  3,  3,  4,  4,  4,
+     5,  5,  5,  5,  6,  6,  7,  7,
+     7,  7,  7,  8,  8,  9,  9,  9,
+     9,  9,  9, 10, 10, 11, 11, 11,
+    11, 11, 11, 12, 12, 12, 12, 12,
+    12, 13, 13, 13, 13, 13, 14, 14,
+    14, 14, 15, 15, 15, 15, 15, 15,
+};
+
+static const uint8_t vp6_def_runv_coeff_model[2][14] = {
+    { 198, 197, 196, 146, 198, 204, 169, 142, 130, 136, 149, 149, 191, 249 },
+    { 135, 201, 181, 154,  98, 117, 132, 126, 146, 169, 184, 240, 246, 254 },
+};
+
+static const uint8_t vp6_sig_dct_pct[2][2] = {
+    { 237, 246 },
+    { 231, 243 },
+};
+
+static const uint8_t vp6_pdv_pct[2][7] = {
+    { 253, 253, 254, 254, 254, 254, 254 },
+    { 245, 253, 254, 254, 254, 254, 254 },
+};
+
+static const uint8_t vp6_fdv_pct[2][8] = {
+    { 254, 254, 254, 254, 254, 250, 250, 252 },
+    { 254, 254, 254, 254, 254, 251, 251, 254 },
+};
+
+static const uint8_t vp6_dccv_pct[2][11] = {
+    { 146, 255, 181, 207, 232, 243, 238, 251, 244, 250, 249 },
+    { 179, 255, 214, 240, 250, 255, 244, 255, 255, 255, 255 },
+};
+
+static const uint8_t vp6_coeff_reorder_pct[] =  {
+    255, 132, 132, 159, 153, 151, 161, 170,
+    164, 162, 136, 110, 103, 114, 129, 118,
+    124, 125, 132, 136, 114, 110, 142, 135,
+    134, 123, 143, 126, 153, 183, 166, 161,
+    171, 180, 179, 164, 203, 218, 225, 217,
+    215, 206, 203, 217, 229, 241, 248, 243,
+    253, 255, 253, 255, 255, 255, 255, 255,
+    255, 255, 255, 255, 255, 255, 255, 255,
+};
+
+static const uint8_t vp6_runv_pct[2][14] = {
+  { 219, 246, 238, 249, 232, 239, 249, 255, 248, 253, 239, 244, 241, 248 },
+  { 198, 232, 251, 253, 219, 241, 253, 255, 248, 249, 244, 238, 251, 255 },
+};
+
+static const uint8_t vp6_ract_pct[3][2][6][11] = {
+  { { { 227, 246, 230, 247, 244, 255, 255, 255, 255, 255, 255 },
+      { 255, 255, 209, 231, 231, 249, 249, 253, 255, 255, 255 },
+      { 255, 255, 225, 242, 241, 251, 253, 255, 255, 255, 255 },
+      { 255, 255, 241, 253, 252, 255, 255, 255, 255, 255, 255 },
+      { 255, 255, 248, 255, 255, 255, 255, 255, 255, 255, 255 },
+      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 } },
+    { { 240, 255, 248, 255, 255, 255, 255, 255, 255, 255, 255 },
+      { 255, 255, 240, 253, 255, 255, 255, 255, 255, 255, 255 },
+      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 } } },
+  { { { 206, 203, 227, 239, 247, 255, 253, 255, 255, 255, 255 },
+      { 207, 199, 220, 236, 243, 252, 252, 255, 255, 255, 255 },
+      { 212, 219, 230, 243, 244, 253, 252, 255, 255, 255, 255 },
+      { 236, 237, 247, 252, 253, 255, 255, 255, 255, 255, 255 },
+      { 240, 240, 248, 255, 255, 255, 255, 255, 255, 255, 255 },
+      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 } },
+    { { 230, 233, 249, 255, 255, 255, 255, 255, 255, 255, 255 },
+      { 238, 238, 250, 255, 255, 255, 255, 255, 255, 255, 255 },
+      { 248, 251, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 } } },
+  { { { 225, 239, 227, 231, 244, 253, 243, 255, 255, 253, 255 },
+      { 232, 234, 224, 228, 242, 249, 242, 252, 251, 251, 255 },
+      { 235, 249, 238, 240, 251, 255, 249, 255, 253, 253, 255 },
+      { 249, 253, 251, 250, 255, 255, 255, 255, 255, 255, 255 },
+      { 251, 250, 249, 255, 255, 255, 255, 255, 255, 255, 255 },
+      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 } },
+    { { 243, 244, 250, 250, 255, 255, 255, 255, 255, 255, 255 },
+      { 249, 248, 250, 253, 255, 255, 255, 255, 255, 255, 255 },
+      { 253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 } } }
+};
+
+static const int vp6_dccv_lc[3][5][2] = {
+  { { 122, 133 }, { 0, 1 }, { 78,  171 }, { 139, 117 }, { 168, 79 } },
+  { { 133,  51 }, { 0, 1 }, { 169,  71 }, { 214,  44 }, { 210, 38 } },
+  { { 142, -16 }, { 0, 1 }, { 221, -30 }, { 246,  -3 }, { 203, 17 } },
+};
+
+static const uint8_t vp6_coeff_groups[] = {
+    0, 0, 1, 1, 1, 2, 2, 2,
+    2, 2, 2, 3, 3, 3, 3, 3,
+    3, 3, 3, 3, 3, 3, 4, 4,
+    4, 4, 4, 4, 4, 4, 4, 4,
+    4, 4, 4, 4, 4, 5, 5, 5,
+    5, 5, 5, 5, 5, 5, 5, 5,
+    5, 5, 5, 5, 5, 5, 5, 5,
+    5, 5, 5, 5, 5, 5, 5, 5,
+};
+
+static const int16_t vp6_block_copy_filter[17][8][4] = {
+  { {   0, 128,   0,   0  },  /* 0 */
+    {  -3, 122,   9,   0  },
+    {  -4, 109,  24,  -1  },
+    {  -5,  91,  45,  -3  },
+    {  -4,  68,  68,  -4  },
+    {  -3,  45,  91,  -5  },
+    {  -1,  24, 109,  -4  },
+    {   0,   9, 122,  -3  } },
+  { {   0, 128,   0,   0  },  /* 1 */
+    {  -4, 124,   9,  -1  },
+    {  -5, 110,  25,  -2  },
+    {  -6,  91,  46,  -3  },
+    {  -5,  69,  69,  -5  },
+    {  -3,  46,  91,  -6  },
+    {  -2,  25, 110,  -5  },
+    {  -1,   9, 124,  -4  } },
+  { {   0, 128,   0,   0  },  /* 2 */
+    {  -4, 123,  10,  -1  },
+    {  -6, 110,  26,  -2  },
+    {  -7,  92,  47,  -4  },
+    {  -6,  70,  70,  -6  },
+    {  -4,  47,  92,  -7  },
+    {  -2,  26, 110,  -6  },
+    {  -1,  10, 123,  -4  } },
+  { {   0, 128,   0,   0  },  /* 3 */
+    {  -5, 124,  10,  -1  },
+    {  -7, 110,  27,  -2  },
+    {  -7,  91,  48,  -4  },
+    {  -6,  70,  70,  -6  },
+    {  -4,  48,  92,  -8  },
+    {  -2,  27, 110,  -7  },
+    {  -1,  10, 124,  -5  } },
+  { {   0, 128,   0,   0  },  /* 4 */
+    {  -6, 124,  11,  -1  },
+    {  -8, 111,  28,  -3  },
+    {  -8,  92,  49,  -5  },
+    {  -7,  71,  71,  -7  },
+    {  -5,  49,  92,  -8  },
+    {  -3,  28, 111,  -8  },
+    {  -1,  11, 124,  -6  } },
+  { {  0,  128,   0,   0  },  /* 5 */
+    {  -6, 123,  12,  -1  },
+    {  -9, 111,  29,  -3  },
+    {  -9,  93,  50,  -6  },
+    {  -8,  72,  72,  -8  },
+    {  -6,  50,  93,  -9  },
+    {  -3,  29, 111,  -9  },
+    {  -1,  12, 123,  -6  } },
+  { {   0, 128,   0,   0  },  /* 6 */
+    {  -7, 124,  12,  -1  },
+    { -10, 111,  30,  -3  },
+    { -10,  93,  51,  -6  },
+    {  -9,  73,  73,  -9  },
+    {  -6,  51,  93, -10  },
+    {  -3,  30, 111, -10  },
+    {  -1,  12, 124,  -7  } },
+  { {   0, 128,   0,   0  },  /* 7 */
+    {  -7, 123,  13,  -1  },
+    { -11, 112,  31,  -4  },
+    { -11,  94,  52,  -7  },
+    { -10,  74,  74, -10  },
+    {  -7,  52,  94, -11  },
+    {  -4,  31, 112, -11  },
+    {  -1,  13, 123,  -7  } },
+  { {   0, 128,   0,  0  },  /* 8 */
+    {  -8, 124,  13,  -1  },
+    { -12, 112,  32,  -4  },
+    { -12,  94,  53,  -7  },
+    { -10,  74,  74, -10  },
+    {  -7,  53,  94, -12  },
+    {  -4,  32, 112, -12  },
+    {  -1,  13, 124,  -8  } },
+  { {   0, 128,   0,   0  },  /* 9 */
+    {  -9, 124,  14,  -1  },
+    { -13, 112,  33,  -4  },
+    { -13,  95,  54,  -8  },
+    { -11,  75,  75, -11  },
+    {  -8,  54,  95, -13  },
+    {  -4,  33, 112, -13  },
+    {  -1,  14, 124,  -9  } },
+  { {   0, 128,   0,   0  },  /* 10 */
+    {  -9, 123,  15,  -1  },
+    { -14, 113,  34,  -5  },
+    { -14,  95,  55,  -8  },
+    { -12,  76,  76, -12  },
+    {  -8,  55,  95, -14  },
+    {  -5,  34, 112, -13  },
+    {  -1,  15, 123,  -9  } },
+  { {   0, 128,   0,   0  },  /* 11 */
+    { -10, 124,  15,  -1  },
+    { -14, 113,  34,  -5  },
+    { -15,  96,  56,  -9  },
+    { -13,  77,  77, -13  },
+    {  -9,  56,  96, -15  },
+    {  -5,  34, 113, -14  },
+    {  -1,  15, 124, -10  } },
+  { {   0, 128,   0,   0  },  /* 12 */
+    { -10, 123,  16,  -1  },
+    { -15, 113,  35,  -5  },
+    { -16,  98,  56, -10  },
+    { -14,  78,  78, -14  },
+    { -10,  56,  98, -16  },
+    {  -5,  35, 113, -15  },
+    {  -1,  16, 123, -10  } },
+  { {   0, 128,   0,   0  },  /* 13 */
+    { -11, 124,  17,  -2  },
+    { -16, 113,  36,  -5  },
+    { -17,  98,  57, -10  },
+    { -14,  78,  78, -14  },
+    { -10,  57,  98, -17  },
+    {  -5,  36, 113, -16  },
+    {  -2,  17, 124, -11  } },
+  { {   0, 128,   0,   0  },  /* 14 */
+    { -12, 125,  17,  -2  },
+    { -17, 114,  37,  -6  },
+    { -18,  99,  58, -11  },
+    { -15,  79,  79, -15  },
+    { -11,  58,  99, -18  },
+    {  -6,  37, 114, -17  },
+    {  -2,  17, 125, -12  } },
+  { {   0, 128,   0,   0  },  /* 15 */
+    { -12, 124,  18,  -2  },
+    { -18, 114,  38,  -6  },
+    { -19,  99,  59, -11  },
+    { -16,  80,  80, -16  },
+    { -11,  59,  99, -19  },
+    {  -6,  38, 114, -18  },
+    {  -2,  18, 124, -12  } },
+  { {   0, 128,   0,   0  },  /* 16 */
+    {  -4, 118,  16,  -2  },
+    {  -7, 106,  34,  -5  },
+    {  -8,  90,  53,  -7  },
+    {  -8,  72,  72,  -8  },
+    {  -7,  53,  90,  -8  },
+    {  -5,  34, 106,  -7  },
+    {  -2,  16, 118,  -4  } },
+};
+
+static const vp56_tree_t vp6_pcr_tree[] = {
+    { 8, 0},
+    { 4, 1},
+    { 2, 2}, {-1}, {-2},
+    { 2, 3}, {-3}, {-4},
+    { 8, 4},
+    { 4, 5},
+    { 2, 6}, {-5}, {-6},
+    { 2, 7}, {-7}, {-8},
+             {-0},
+};
+
+static const uint8_t vp6_coord_div[] = { 4, 4, 4, 4, 8, 8 };
+
+#endif /* VP6DATA_H */



From mean at mail.berlios.de  Sun Jan 21 19:44:47 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 21 Jan 2007 19:44:47 +0100
Subject: [Avidemux-svn-commit] r2758 -
	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec
Message-ID: <200701211844.l0LIilSJ022165@sheep.berlios.de>

Author: mean
Date: 2007-01-21 19:44:46 +0100 (Sun, 21 Jan 2007)
New Revision: 2758

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/indeo2.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/indeo2data.h
Log:
new files

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/indeo2.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/indeo2.c	2007-01-21 18:34:00 UTC (rev 2757)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/indeo2.c	2007-01-21 18:44:46 UTC (rev 2758)
@@ -0,0 +1,221 @@
+/*
+ * Intel Indeo 2 codec
+ * Copyright (c) 2005 Konstantin Shishkov
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+/**
+ * @file indeo2.c
+ * Intel Indeo 2 decoder.
+ */
+#define ALT_BITSTREAM_READER_LE
+#include "avcodec.h"
+#include "bitstream.h"
+#include "indeo2data.h"
+
+typedef struct Ir2Context{
+    AVCodecContext *avctx;
+    AVFrame picture;
+    GetBitContext gb;
+    int decode_delta;
+} Ir2Context;
+
+#define CODE_VLC_BITS 14
+static VLC ir2_vlc;
+
+/* Indeo 2 codes are in range 0x01..0x7F and 0x81..0x90 */
+static inline int ir2_get_code(GetBitContext *gb)
+{
+    return get_vlc2(gb, ir2_vlc.table, CODE_VLC_BITS, 1) + 1;
+}
+
+static int ir2_decode_plane(Ir2Context *ctx, int width, int height, uint8_t *dst, int stride,
+                             const uint8_t *table)
+{
+    int i;
+    int j;
+    int out = 0;
+    int c;
+    int t;
+
+    if(width&1)
+        return -1;
+
+    /* first line contain absolute values, other lines contain deltas */
+    while (out < width){
+        c = ir2_get_code(&ctx->gb);
+        if(c >= 0x80) { /* we have a run */
+            c -= 0x7F;
+            if(out + c*2 > width)
+                return -1;
+            for (i = 0; i < c * 2; i++)
+                dst[out++] = 0x80;
+        } else { /* copy two values from table */
+            dst[out++] = table[c * 2];
+            dst[out++] = table[(c * 2) + 1];
+        }
+    }
+    dst += stride;
+
+    for (j = 1; j < height; j++){
+        out = 0;
+        while (out < width){
+            c = ir2_get_code(&ctx->gb);
+            if(c >= 0x80) { /* we have a skip */
+                c -= 0x7F;
+                if(out + c*2 > width)
+                    return -1;
+                for (i = 0; i < c * 2; i++) {
+                    dst[out] = dst[out - stride];
+                    out++;
+                }
+            } else { /* add two deltas from table */
+                t = dst[out - stride] + (table[c * 2] - 128);
+                t= clip_uint8(t);
+                dst[out] = t;
+                out++;
+                t = dst[out - stride] + (table[(c * 2) + 1] - 128);
+                t= clip_uint8(t);
+                dst[out] = t;
+                out++;
+            }
+        }
+        dst += stride;
+    }
+    return 0;
+}
+
+static int ir2_decode_plane_inter(Ir2Context *ctx, int width, int height, uint8_t *dst, int stride,
+                             const uint8_t *table)
+{
+    int j;
+    int out = 0;
+    int c;
+    int t;
+
+    if(width&1)
+        return -1;
+
+    for (j = 0; j < height; j++){
+        out = 0;
+        while (out < width){
+            c = ir2_get_code(&ctx->gb);
+            if(c >= 0x80) { /* we have a skip */
+                c -= 0x7F;
+                out += c * 2;
+            } else { /* add two deltas from table */
+                t = dst[out] + (((table[c * 2] - 128)*3) >> 2);
+                t= clip_uint8(t);
+                dst[out] = t;
+                out++;
+                t = dst[out] + (((table[(c * 2) + 1] - 128)*3) >> 2);
+                t= clip_uint8(t);
+                dst[out] = t;
+                out++;
+            }
+        }
+        dst += stride;
+    }
+    return 0;
+}
+
+static int ir2_decode_frame(AVCodecContext *avctx,
+                        void *data, int *data_size,
+                        uint8_t *buf, int buf_size)
+{
+    Ir2Context * const s = avctx->priv_data;
+    AVFrame *picture = data;
+    AVFrame * const p= (AVFrame*)&s->picture;
+    int start;
+
+    if(p->data[0])
+        avctx->release_buffer(avctx, p);
+
+    p->reference = 1;
+    p->buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE;
+    if (avctx->reget_buffer(avctx, p)) {
+        av_log(s->avctx, AV_LOG_ERROR, "reget_buffer() failed\n");
+        return -1;
+    }
+
+    s->decode_delta = buf[18];
+
+    /* decide whether frame uses deltas or not */
+#ifndef ALT_BITSTREAM_READER_LE
+    for (i = 0; i < buf_size; i++)
+        buf[i] = ff_reverse[buf[i]];
+#endif
+    start = 48; /* hardcoded for now */
+
+    init_get_bits(&s->gb, buf + start, buf_size - start);
+
+    if (s->decode_delta) { /* intraframe */
+        ir2_decode_plane(s, avctx->width, avctx->height,
+                         s->picture.data[0], s->picture.linesize[0], ir2_luma_table);
+        /* swapped U and V */
+        ir2_decode_plane(s, avctx->width >> 2, avctx->height >> 2,
+                         s->picture.data[2], s->picture.linesize[2], ir2_luma_table);
+        ir2_decode_plane(s, avctx->width >> 2, avctx->height >> 2,
+                         s->picture.data[1], s->picture.linesize[1], ir2_luma_table);
+    } else { /* interframe */
+        ir2_decode_plane_inter(s, avctx->width, avctx->height,
+                         s->picture.data[0], s->picture.linesize[0], ir2_luma_table);
+        /* swapped U and V */
+        ir2_decode_plane_inter(s, avctx->width >> 2, avctx->height >> 2,
+                         s->picture.data[2], s->picture.linesize[2], ir2_luma_table);
+        ir2_decode_plane_inter(s, avctx->width >> 2, avctx->height >> 2,
+                         s->picture.data[1], s->picture.linesize[1], ir2_luma_table);
+    }
+
+    *picture= *(AVFrame*)&s->picture;
+    *data_size = sizeof(AVPicture);
+
+    return buf_size;
+}
+
+static int ir2_decode_init(AVCodecContext *avctx){
+    Ir2Context * const ic = avctx->priv_data;
+
+    ic->avctx = avctx;
+
+    avctx->pix_fmt= PIX_FMT_YUV410P;
+
+    if (!ir2_vlc.table)
+        init_vlc(&ir2_vlc, CODE_VLC_BITS, IR2_CODES,
+                 &ir2_codes[0][1], 4, 2,
+#ifdef ALT_BITSTREAM_READER_LE
+                 &ir2_codes[0][0], 4, 2, INIT_VLC_USE_STATIC | INIT_VLC_LE);
+#else
+                 &ir2_codes[0][0], 4, 2, INIT_VLC_USE_STATIC);
+#endif
+
+    return 0;
+}
+
+AVCodec indeo2_decoder = {
+    "indeo2",
+    CODEC_TYPE_VIDEO,
+    CODEC_ID_INDEO2,
+    sizeof(Ir2Context),
+    ir2_decode_init,
+    NULL,
+    NULL,
+    ir2_decode_frame,
+    CODEC_CAP_DR1,
+};

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/indeo2data.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/indeo2data.h	2007-01-21 18:34:00 UTC (rev 2757)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/indeo2data.h	2007-01-21 18:44:46 UTC (rev 2758)
@@ -0,0 +1,134 @@
+/*
+ * Intel Indeo 2 codec
+ * copyright (c) 2005 Konstantin Shishkov
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#define IR2_CODES 143
+static const uint16_t ir2_codes[IR2_CODES][2] = {
+#ifdef ALT_BITSTREAM_READER_LE
+{0x0000,  3}, {0x0004,  3}, {0x0006,  3}, {0x0001,  5},
+{0x0009,  5}, {0x0019,  5}, {0x000D,  5}, {0x001D,  5},
+{0x0023,  6}, {0x0013,  6}, {0x0033,  6}, {0x000B,  6},
+{0x002B,  6}, {0x001B,  6}, {0x0007,  8}, {0x0087,  8},
+{0x0027,  8}, {0x00A7,  8}, {0x0067,  8}, {0x00E7,  8},
+{0x0097,  8}, {0x0057,  8}, {0x0037,  8}, {0x00B7,  8},
+{0x00F7,  8}, {0x000F,  9}, {0x008F,  9}, {0x018F,  9},
+{0x014F,  9}, {0x00CF,  9}, {0x002F,  9}, {0x012F,  9},
+{0x01AF,  9}, {0x006F,  9}, {0x00EF,  9}, {0x01EF,  9},
+{0x001F, 10}, {0x021F, 10}, {0x011F, 10}, {0x031F, 10},
+{0x009F, 10}, {0x029F, 10}, {0x019F, 10}, {0x039F, 10},
+{0x005F, 10}, {0x025F, 10}, {0x015F, 10}, {0x035F, 10},
+{0x00DF, 10}, {0x02DF, 10}, {0x01DF, 10}, {0x03DF, 10},
+{0x003F, 13}, {0x103F, 13}, {0x083F, 13}, {0x183F, 13},
+{0x043F, 13}, {0x143F, 13}, {0x0C3F, 13}, {0x1C3F, 13},
+{0x023F, 13}, {0x123F, 13}, {0x0A3F, 13}, {0x1A3F, 13},
+{0x063F, 13}, {0x163F, 13}, {0x0E3F, 13}, {0x1E3F, 13},
+{0x013F, 13}, {0x113F, 13}, {0x093F, 13}, {0x193F, 13},
+{0x053F, 13}, {0x153F, 13}, {0x0D3F, 13}, {0x1D3F, 13},
+{0x033F, 13}, {0x133F, 13}, {0x0B3F, 13}, {0x1B3F, 13},
+{0x073F, 13}, {0x173F, 13}, {0x0F3F, 13}, {0x1F3F, 13},
+{0x00BF, 13}, {0x10BF, 13}, {0x08BF, 13}, {0x18BF, 13},
+{0x04BF, 13}, {0x14BF, 13}, {0x0CBF, 13}, {0x1CBF, 13},
+{0x02BF, 13}, {0x12BF, 13}, {0x0ABF, 13}, {0x1ABF, 13},
+{0x06BF, 13}, {0x16BF, 13}, {0x0EBF, 13}, {0x1EBF, 13},
+{0x01BF, 13}, {0x11BF, 13}, {0x09BF, 13}, {0x19BF, 13},
+{0x05BF, 13}, {0x15BF, 13}, {0x0DBF, 13}, {0x1DBF, 13},
+{0x03BF, 13}, {0x13BF, 13}, {0x0BBF, 13}, {0x1BBF, 13},
+{0x07BF, 13}, {0x17BF, 13}, {0x0FBF, 13}, {0x1FBF, 13},
+{0x007F, 14}, {0x207F, 14}, {0x107F, 14}, {0x307F, 14},
+{0x087F, 14}, {0x287F, 14}, {0x187F, 14}, {0x387F, 14},
+{0x047F, 14}, {0x247F, 14}, {0x147F, 14}, {0x0002,  3},
+{0x0011,  5}, {0x0005,  5}, {0x0015,  5}, {0x0003,  6},
+{0x003B,  6}, {0x0047,  8}, {0x00C7,  8}, {0x0017,  8},
+{0x00D7,  8}, {0x0077,  8}, {0x010F,  9}, {0x004F,  9},
+{0x01CF,  9}, {0x00AF,  9}, {0x016F,  9},
+#else
+    {0x0000,  3}, {0x0001,  3}, {0x0003,  3}, {0x0010,  5},
+    {0x0012,  5}, {0x0013,  5}, {0x0016,  5}, {0x0017,  5},
+    {0x0031,  6}, {0x0032,  6}, {0x0033,  6}, {0x0034,  6},
+    {0x0035,  6}, {0x0036,  6}, {0x00E0,  8}, {0x00E1,  8},
+    {0x00E4,  8}, {0x00E5,  8}, {0x00E6,  8}, {0x00E7,  8},
+    {0x00E9,  8}, {0x00EA,  8}, {0x00EC,  8}, {0x00ED,  8},
+    {0x00EF,  8}, {0x01E0,  9}, {0x01E2,  9}, {0x01E3,  9},
+    {0x01E5,  9}, {0x01E6,  9}, {0x01E8,  9}, {0x01E9,  9},
+    {0x01EB,  9}, {0x01EC,  9}, {0x01EE,  9}, {0x01EF,  9},
+    {0x03E0, 10}, {0x03E1, 10}, {0x03E2, 10}, {0x03E3, 10},
+    {0x03E4, 10}, {0x03E5, 10}, {0x03E6, 10}, {0x03E7, 10},
+    {0x03E8, 10}, {0x03E9, 10}, {0x03EA, 10}, {0x03EB, 10},
+    {0x03EC, 10}, {0x03ED, 10}, {0x03EE, 10}, {0x03EF, 10},
+    {0x1F80, 13}, {0x1F81, 13}, {0x1F82, 13}, {0x1F83, 13},
+    {0x1F84, 13}, {0x1F85, 13}, {0x1F86, 13}, {0x1F87, 13},
+    {0x1F88, 13}, {0x1F89, 13}, {0x1F8A, 13}, {0x1F8B, 13},
+    {0x1F8C, 13}, {0x1F8D, 13}, {0x1F8E, 13}, {0x1F8F, 13},
+    {0x1F90, 13}, {0x1F91, 13}, {0x1F92, 13}, {0x1F93, 13},
+    {0x1F94, 13}, {0x1F95, 13}, {0x1F96, 13}, {0x1F97, 13},
+    {0x1F98, 13}, {0x1F99, 13}, {0x1F9A, 13}, {0x1F9B, 13},
+    {0x1F9C, 13}, {0x1F9D, 13}, {0x1F9E, 13}, {0x1F9F, 13},
+    {0x1FA0, 13}, {0x1FA1, 13}, {0x1FA2, 13}, {0x1FA3, 13},
+    {0x1FA4, 13}, {0x1FA5, 13}, {0x1FA6, 13}, {0x1FA7, 13},
+    {0x1FA8, 13}, {0x1FA9, 13}, {0x1FAA, 13}, {0x1FAB, 13},
+    {0x1FAC, 13}, {0x1FAD, 13}, {0x1FAE, 13}, {0x1FAF, 13},
+    {0x1FB0, 13}, {0x1FB1, 13}, {0x1FB2, 13}, {0x1FB3, 13},
+    {0x1FB4, 13}, {0x1FB5, 13}, {0x1FB6, 13}, {0x1FB7, 13},
+    {0x1FB8, 13}, {0x1FB9, 13}, {0x1FBA, 13}, {0x1FBB, 13},
+    {0x1FBC, 13}, {0x1FBD, 13}, {0x1FBE, 13}, {0x1FBF, 13},
+    {0x3F80, 14}, {0x3F81, 14}, {0x3F82, 14}, {0x3F83, 14},
+    {0x3F84, 14}, {0x3F85, 14}, {0x3F86, 14}, {0x3F87, 14},
+    {0x3F88, 14}, {0x3F89, 14}, {0x3F8A, 14}, {0x0002,  3},
+    {0x0011,  5}, {0x0014,  5}, {0x0015,  5}, {0x0030,  6},
+    {0x0037,  6}, {0x00E2,  8}, {0x00E3,  8}, {0x00E8,  8},
+    {0x00EB,  8}, {0x00EE,  8}, {0x01E1,  9}, {0x01E4,  9},
+    {0x01E7,  9}, {0x01EA,  9}, {0x01ED,  9}
+#endif
+};
+
+static const uint8_t ir2_luma_table[256] = {
+ 0x80, 0x80, 0x84, 0x84, 0x7C, 0x7C, 0x7F, 0x85,
+ 0x81, 0x7B, 0x85, 0x7F, 0x7B, 0x81, 0x8C, 0x8C,
+ 0x74, 0x74, 0x83, 0x8D, 0x7D, 0x73, 0x8D, 0x83,
+ 0x73, 0x7D, 0x77, 0x89, 0x89, 0x77, 0x89, 0x77,
+ 0x77, 0x89, 0x8C, 0x95, 0x74, 0x6B, 0x95, 0x8C,
+ 0x6B, 0x74, 0x7C, 0x90, 0x84, 0x70, 0x90, 0x7C,
+ 0x70, 0x84, 0x96, 0x96, 0x6A, 0x6A, 0x82, 0x98,
+ 0x7E, 0x68, 0x98, 0x82, 0x68, 0x7E, 0x97, 0xA2,
+ 0x69, 0x5E, 0xA2, 0x97, 0x5E, 0x69, 0xA2, 0xA2,
+ 0x5E, 0x5E, 0x8B, 0xA3, 0x75, 0x5D, 0xA3, 0x8B,
+ 0x5D, 0x75, 0x71, 0x95, 0x8F, 0x6B, 0x95, 0x71,
+ 0x6B, 0x8F, 0x78, 0x9D, 0x88, 0x63, 0x9D, 0x78,
+ 0x63, 0x88, 0x7F, 0xA7, 0x81, 0x59, 0xA7, 0x7F,
+ 0x59, 0x81, 0xA4, 0xB1, 0x5C, 0x4F, 0xB1, 0xA4,
+ 0x4F, 0x5C, 0x96, 0xB1, 0x6A, 0x4F, 0xB1, 0x96,
+ 0x4F, 0x6A, 0xB2, 0xB2, 0x4E, 0x4E, 0x65, 0x9B,
+ 0x9B, 0x65, 0x9B, 0x65, 0x65, 0x9B, 0x89, 0xB4,
+ 0x77, 0x4C, 0xB4, 0x89, 0x4C, 0x77, 0x6A, 0xA3,
+ 0x96, 0x5D, 0xA3, 0x6A, 0x5D, 0x96, 0x73, 0xAC,
+ 0x8D, 0x54, 0xAC, 0x73, 0x54, 0x8D, 0xB4, 0xC3,
+ 0x4C, 0x3D, 0xC3, 0xB4, 0x3D, 0x4C, 0xA4, 0xC3,
+ 0x5C, 0x3D, 0xC3, 0xA4, 0x3D, 0x5C, 0xC4, 0xC4,
+ 0x3C, 0x3C, 0x96, 0xC6, 0x6A, 0x3A, 0xC6, 0x96,
+ 0x3A, 0x6A, 0x7C, 0xBA, 0x84, 0x46, 0xBA, 0x7C,
+ 0x46, 0x84, 0x5B, 0xAB, 0xA5, 0x55, 0xAB, 0x5B,
+ 0x55, 0xA5, 0x63, 0xB4, 0x9D, 0x4C, 0xB4, 0x63,
+ 0x4C, 0x9D, 0x86, 0xCA, 0x7A, 0x36, 0xCA, 0x86,
+ 0x36, 0x7A, 0xB6, 0xD7, 0x4A, 0x29, 0xD7, 0xB6,
+ 0x29, 0x4A, 0xC8, 0xD7, 0x38, 0x29, 0xD7, 0xC8,
+ 0x29, 0x38, 0xA4, 0xD8, 0x5C, 0x28, 0xD8, 0xA4,
+ 0x28, 0x5C, 0x6C, 0xC1, 0x94, 0x3F, 0xC1, 0x6C,
+ 0x3F, 0x94, 0xD9, 0xD9, 0x27, 0x27, 0x80, 0x80
+};



From mean at mail.berlios.de  Sun Jan 21 19:45:20 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 21 Jan 2007 19:45:20 +0100
Subject: [Avidemux-svn-commit] r2759 -
	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec
Message-ID: <200701211845.l0LIjKXt022265@sheep.berlios.de>

Author: mean
Date: 2007-01-21 19:45:20 +0100 (Sun, 21 Jan 2007)
New Revision: 2759

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/smacker.c
Log:
new files

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/smacker.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/smacker.c	2007-01-21 18:44:46 UTC (rev 2758)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/smacker.c	2007-01-21 18:45:20 UTC (rev 2759)
@@ -0,0 +1,723 @@
+/*
+ * Smacker decoder
+ * Copyright (c) 2006 Konstantin Shishkov
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+/**
+ * @file smacker.c
+ * Smacker decoder
+ */
+
+/*
+ * Based on http://wiki.multimedia.cx/index.php?title=Smacker
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+
+#include "common.h"
+#include "avcodec.h"
+
+#define ALT_BITSTREAM_READER_LE
+#include "bitstream.h"
+
+#define SMKTREE_BITS 9
+#define SMK_NODE 0x80000000
+
+/*
+ * Decoder context
+ */
+typedef struct SmackVContext {
+    AVCodecContext *avctx;
+    AVFrame pic;
+
+    int *mmap_tbl, *mclr_tbl, *full_tbl, *type_tbl;
+    int mmap_last[3], mclr_last[3], full_last[3], type_last[3];
+} SmackVContext;
+
+/**
+ * Context used for code reconstructing
+ */
+typedef struct HuffContext {
+    int length;
+    int maxlength;
+    int current;
+    uint32_t *bits;
+    int *lengths;
+    int *values;
+} HuffContext;
+
+/* common parameters used for decode_bigtree */
+typedef struct DBCtx {
+    VLC *v1, *v2;
+    int *recode1, *recode2;
+    int escapes[3];
+    int *last;
+    int lcur;
+} DBCtx;
+
+/* possible runs of blocks */
+static const int block_runs[64] = {
+      1,    2,    3,    4,    5,    6,    7,    8,
+      9,   10,   11,   12,   13,   14,   15,   16,
+     17,   18,   19,   20,   21,   22,   23,   24,
+     25,   26,   27,   28,   29,   30,   31,   32,
+     33,   34,   35,   36,   37,   38,   39,   40,
+     41,   42,   43,   44,   45,   46,   47,   48,
+     49,   50,   51,   52,   53,   54,   55,   56,
+     57,   58,   59,  128,  256,  512, 1024, 2048 };
+
+enum SmkBlockTypes {
+    SMK_BLK_MONO = 0,
+    SMK_BLK_FULL = 1,
+    SMK_BLK_SKIP = 2,
+    SMK_BLK_FILL = 3 };
+
+/**
+ * Decode local frame tree
+ */
+static int smacker_decode_tree(GetBitContext *gb, HuffContext *hc, uint32_t prefix, int length)
+{
+    if(!get_bits1(gb)){ //Leaf
+        if(hc->current >= 256){
+            av_log(NULL, AV_LOG_ERROR, "Tree size exceeded!\n");
+            return -1;
+        }
+        if(length){
+            hc->bits[hc->current] = prefix;
+            hc->lengths[hc->current] = length;
+        } else {
+            hc->bits[hc->current] = 0;
+            hc->lengths[hc->current] = 0;
+        }
+        hc->values[hc->current] = get_bits(gb, 8);
+        hc->current++;
+        if(hc->maxlength < length)
+            hc->maxlength = length;
+        return 0;
+    } else { //Node
+        int r;
+        length++;
+        r = smacker_decode_tree(gb, hc, prefix, length);
+        if(r)
+            return r;
+        return smacker_decode_tree(gb, hc, prefix | (1 << (length - 1)), length);
+    }
+}
+
+/**
+ * Decode header tree
+ */
+static int smacker_decode_bigtree(GetBitContext *gb, HuffContext *hc, DBCtx *ctx)
+{
+    if(!get_bits1(gb)){ //Leaf
+        int val, i1, i2, b1, b2;
+        if(hc->current >= hc->length){
+            av_log(NULL, AV_LOG_ERROR, "Tree size exceeded!\n");
+            return -1;
+        }
+        b1 = get_bits_count(gb);
+        i1 = get_vlc2(gb, ctx->v1->table, SMKTREE_BITS, 3);
+        b1 = get_bits_count(gb) - b1;
+        b2 = get_bits_count(gb);
+        i2 = get_vlc2(gb, ctx->v2->table, SMKTREE_BITS, 3);
+        b2 = get_bits_count(gb) - b2;
+        val = ctx->recode1[i1] | (ctx->recode2[i2] << 8);
+        if(val == ctx->escapes[0]) {
+            ctx->last[0] = hc->current;
+            val = 0;
+        } else if(val == ctx->escapes[1]) {
+            ctx->last[1] = hc->current;
+            val = 0;
+        } else if(val == ctx->escapes[2]) {
+            ctx->last[2] = hc->current;
+            val = 0;
+        }
+
+        hc->values[hc->current++] = val;
+        return 1;
+    } else { //Node
+        int r = 0, t;
+
+        t = hc->current++;
+        r = smacker_decode_bigtree(gb, hc, ctx);
+        if(r < 0)
+            return r;
+        hc->values[t] = SMK_NODE | r;
+        r++;
+        r += smacker_decode_bigtree(gb, hc, ctx);
+        return r;
+    }
+}
+
+/**
+ * Store large tree as FFmpeg's vlc codes
+ */
+static int smacker_decode_header_tree(SmackVContext *smk, GetBitContext *gb, int **recodes, int *last, int size)
+{
+    int res;
+    HuffContext huff;
+    HuffContext tmp1, tmp2;
+    VLC vlc[2];
+    int escapes[3];
+    DBCtx ctx;
+
+    if(size >= UINT_MAX>>4){ // (((size + 3) >> 2) + 3) << 2 must not overflow
+        av_log(smk->avctx, AV_LOG_ERROR, "size too large\n");
+        return -1;
+    }
+
+    tmp1.length = 256;
+    tmp1.maxlength = 0;
+    tmp1.current = 0;
+    tmp1.bits = av_mallocz(256 * 4);
+    tmp1.lengths = av_mallocz(256 * sizeof(int));
+    tmp1.values = av_mallocz(256 * sizeof(int));
+
+    tmp2.length = 256;
+    tmp2.maxlength = 0;
+    tmp2.current = 0;
+    tmp2.bits = av_mallocz(256 * 4);
+    tmp2.lengths = av_mallocz(256 * sizeof(int));
+    tmp2.values = av_mallocz(256 * sizeof(int));
+
+    memset(&vlc[0], 0, sizeof(VLC));
+    memset(&vlc[1], 0, sizeof(VLC));
+
+    if(get_bits1(gb)) {
+        smacker_decode_tree(gb, &tmp1, 0, 0);
+        get_bits1(gb);
+        res = init_vlc(&vlc[0], SMKTREE_BITS, tmp1.length,
+                    tmp1.lengths, sizeof(int), sizeof(int),
+                    tmp1.bits, sizeof(uint32_t), sizeof(uint32_t), INIT_VLC_LE);
+        if(res < 0) {
+            av_log(smk->avctx, AV_LOG_ERROR, "Cannot build VLC table\n");
+            return -1;
+        }
+    } else {
+        av_log(smk->avctx, AV_LOG_ERROR, "Skipping low bytes tree\n");
+    }
+    if(get_bits1(gb)){
+        smacker_decode_tree(gb, &tmp2, 0, 0);
+        get_bits1(gb);
+        res = init_vlc(&vlc[1], SMKTREE_BITS, tmp2.length,
+                    tmp2.lengths, sizeof(int), sizeof(int),
+                    tmp2.bits, sizeof(uint32_t), sizeof(uint32_t), INIT_VLC_LE);
+        if(res < 0) {
+            av_log(smk->avctx, AV_LOG_ERROR, "Cannot build VLC table\n");
+            return -1;
+        }
+    } else {
+        av_log(smk->avctx, AV_LOG_ERROR, "Skipping high bytes tree\n");
+    }
+
+    escapes[0]  = get_bits(gb, 8);
+    escapes[0] |= get_bits(gb, 8) << 8;
+    escapes[1]  = get_bits(gb, 8);
+    escapes[1] |= get_bits(gb, 8) << 8;
+    escapes[2]  = get_bits(gb, 8);
+    escapes[2] |= get_bits(gb, 8) << 8;
+
+    last[0] = last[1] = last[2] = -1;
+
+    ctx.escapes[0] = escapes[0];
+    ctx.escapes[1] = escapes[1];
+    ctx.escapes[2] = escapes[2];
+    ctx.v1 = &vlc[0];
+    ctx.v2 = &vlc[1];
+    ctx.recode1 = tmp1.values;
+    ctx.recode2 = tmp2.values;
+    ctx.last = last;
+
+    huff.length = ((size + 3) >> 2) + 3;
+    huff.maxlength = 0;
+    huff.current = 0;
+    huff.values = av_mallocz(huff.length * sizeof(int));
+
+    smacker_decode_bigtree(gb, &huff, &ctx);
+    get_bits1(gb);
+    if(ctx.last[0] == -1) ctx.last[0] = huff.current++;
+    if(ctx.last[1] == -1) ctx.last[1] = huff.current++;
+    if(ctx.last[2] == -1) ctx.last[2] = huff.current++;
+
+    *recodes = huff.values;
+
+    if(vlc[0].table)
+        free_vlc(&vlc[0]);
+    if(vlc[1].table)
+        free_vlc(&vlc[1]);
+    av_free(tmp1.bits);
+    av_free(tmp1.lengths);
+    av_free(tmp1.values);
+    av_free(tmp2.bits);
+    av_free(tmp2.lengths);
+    av_free(tmp2.values);
+
+    return 0;
+}
+
+static int decode_header_trees(SmackVContext *smk) {
+    GetBitContext gb;
+    int mmap_size, mclr_size, full_size, type_size;
+
+    mmap_size = AV_RL32(smk->avctx->extradata);
+    mclr_size = AV_RL32(smk->avctx->extradata + 4);
+    full_size = AV_RL32(smk->avctx->extradata + 8);
+    type_size = AV_RL32(smk->avctx->extradata + 12);
+
+    init_get_bits(&gb, smk->avctx->extradata + 16, (smk->avctx->extradata_size - 16) * 8);
+
+    if(!get_bits1(&gb)) {
+        av_log(smk->avctx, AV_LOG_INFO, "Skipping MMAP tree\n");
+        smk->mmap_tbl = av_malloc(sizeof(int) * 2);
+        smk->mmap_tbl[0] = 0;
+        smk->mmap_last[0] = smk->mmap_last[1] = smk->mmap_last[2] = 1;
+    } else {
+        smacker_decode_header_tree(smk, &gb, &smk->mmap_tbl, smk->mmap_last, mmap_size);
+    }
+    if(!get_bits(&gb, 1)) {
+        av_log(smk->avctx, AV_LOG_INFO, "Skipping MCLR tree\n");
+        smk->mclr_tbl = av_malloc(sizeof(int) * 2);
+        smk->mclr_tbl[0] = 0;
+        smk->mclr_last[0] = smk->mclr_last[1] = smk->mclr_last[2] = 1;
+    } else {
+        smacker_decode_header_tree(smk, &gb, &smk->mclr_tbl, smk->mclr_last, mclr_size);
+    }
+    if(!get_bits(&gb, 1)) {
+        av_log(smk->avctx, AV_LOG_INFO, "Skipping FULL tree\n");
+        smk->full_tbl = av_malloc(sizeof(int) * 2);
+        smk->full_tbl[0] = 0;
+        smk->full_last[0] = smk->full_last[1] = smk->full_last[2] = 1;
+    } else {
+        smacker_decode_header_tree(smk, &gb, &smk->full_tbl, smk->full_last, full_size);
+    }
+    if(!get_bits(&gb, 1)) {
+        av_log(smk->avctx, AV_LOG_INFO, "Skipping TYPE tree\n");
+        smk->type_tbl = av_malloc(sizeof(int) * 2);
+        smk->type_tbl[0] = 0;
+        smk->type_last[0] = smk->type_last[1] = smk->type_last[2] = 1;
+    } else {
+        smacker_decode_header_tree(smk, &gb, &smk->type_tbl, smk->type_last, type_size);
+    }
+
+    return 0;
+}
+
+static av_always_inline void last_reset(int *recode, int *last) {
+    recode[last[0]] = recode[last[1]] = recode[last[2]] = 0;
+}
+
+/* get code and update history */
+static av_always_inline int smk_get_code(GetBitContext *gb, int *recode, int *last) {
+    register int *table = recode;
+    int v, b;
+
+    b = get_bits_count(gb);
+    while(*table & SMK_NODE) {
+        if(get_bits1(gb))
+            table += (*table) & (~SMK_NODE);
+        table++;
+    }
+    v = *table;
+    b = get_bits_count(gb) - b;
+
+    if(v != recode[last[0]]) {
+        recode[last[2]] = recode[last[1]];
+        recode[last[1]] = recode[last[0]];
+        recode[last[0]] = v;
+    }
+    return v;
+}
+
+static int decode_frame(AVCodecContext *avctx, void *data, int *data_size, uint8_t *buf, int buf_size)
+{
+    SmackVContext * const smk = (SmackVContext *)avctx->priv_data;
+    uint8_t *out;
+    uint32_t *pal;
+    GetBitContext gb;
+    int blocks, blk, bw, bh;
+    int i;
+    int stride;
+
+    if(buf_size == 769)
+        return 0;
+    if(smk->pic.data[0])
+            avctx->release_buffer(avctx, &smk->pic);
+
+    smk->pic.reference = 1;
+    smk->pic.buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE;
+    if(avctx->reget_buffer(avctx, &smk->pic) < 0){
+        av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n");
+        return -1;
+    }
+
+    /* make the palette available on the way out */
+    out = buf + 1;
+    pal = (uint32_t*)smk->pic.data[1];
+    smk->pic.palette_has_changed = buf[0] & 1;
+    smk->pic.key_frame = !!(buf[0] & 2);
+    if(smk->pic.key_frame)
+        smk->pic.pict_type = FF_I_TYPE;
+    else
+        smk->pic.pict_type = FF_P_TYPE;
+
+    for(i = 0; i < 256; i++) {
+        int r, g, b;
+        r = *out++;
+        g = *out++;
+        b = *out++;
+        *pal++ = (r << 16) | (g << 8) | b;
+    }
+
+    last_reset(smk->mmap_tbl, smk->mmap_last);
+    last_reset(smk->mclr_tbl, smk->mclr_last);
+    last_reset(smk->full_tbl, smk->full_last);
+    last_reset(smk->type_tbl, smk->type_last);
+    init_get_bits(&gb, buf + 769, (buf_size - 769) * 8);
+
+    blk = 0;
+    bw = avctx->width >> 2;
+    bh = avctx->height >> 2;
+    blocks = bw * bh;
+    out = smk->pic.data[0];
+    stride = smk->pic.linesize[0];
+    while(blk < blocks) {
+        int type, run, mode;
+        uint16_t pix;
+
+        type = smk_get_code(&gb, smk->type_tbl, smk->type_last);
+        run = block_runs[(type >> 2) & 0x3F];
+        switch(type & 3){
+        case SMK_BLK_MONO:
+            while(run-- && blk < blocks){
+                int clr, map;
+                int hi, lo;
+                clr = smk_get_code(&gb, smk->mclr_tbl, smk->mclr_last);
+                map = smk_get_code(&gb, smk->mmap_tbl, smk->mmap_last);
+                out = smk->pic.data[0] + (blk / bw) * (stride * 4) + (blk % bw) * 4;
+                hi = clr >> 8;
+                lo = clr & 0xFF;
+                for(i = 0; i < 4; i++) {
+                    if(map & 1) out[0] = hi; else out[0] = lo;
+                    if(map & 2) out[1] = hi; else out[1] = lo;
+                    if(map & 4) out[2] = hi; else out[2] = lo;
+                    if(map & 8) out[3] = hi; else out[3] = lo;
+                    map >>= 4;
+                    out += stride;
+                }
+                blk++;
+            }
+            break;
+        case SMK_BLK_FULL:
+            mode = 0;
+            if(avctx->codec_tag == MKTAG('S', 'M', 'K', '4')) { // In case of Smacker v4 we have three modes
+                if(get_bits1(&gb)) mode = 1;
+                else if(get_bits1(&gb)) mode = 2;
+            }
+            while(run-- && blk < blocks){
+                out = smk->pic.data[0] + (blk / bw) * (stride * 4) + (blk % bw) * 4;
+                switch(mode){
+                case 0:
+                    for(i = 0; i < 4; i++) {
+                        pix = smk_get_code(&gb, smk->full_tbl, smk->full_last);
+                        out[2] = pix & 0xFF;
+                        out[3] = pix >> 8;
+                        pix = smk_get_code(&gb, smk->full_tbl, smk->full_last);
+                        out[0] = pix & 0xFF;
+                        out[1] = pix >> 8;
+                        out += stride;
+                    }
+                    break;
+                case 1:
+                    pix = smk_get_code(&gb, smk->full_tbl, smk->full_last);
+                    out[0] = out[1] = pix & 0xFF;
+                    out[2] = out[3] = pix >> 8;
+                    out += stride;
+                    out[0] = out[1] = pix & 0xFF;
+                    out[2] = out[3] = pix >> 8;
+                    out += stride;
+                    pix = smk_get_code(&gb, smk->full_tbl, smk->full_last);
+                    out[0] = out[1] = pix & 0xFF;
+                    out[2] = out[3] = pix >> 8;
+                    out += stride;
+                    out[0] = out[1] = pix & 0xFF;
+                    out[2] = out[3] = pix >> 8;
+                    out += stride;
+                    break;
+                case 2:
+                    for(i = 0; i < 2; i++) {
+                        uint16_t pix1, pix2;
+                        pix1 = smk_get_code(&gb, smk->full_tbl, smk->full_last);
+                        pix2 = smk_get_code(&gb, smk->full_tbl, smk->full_last);
+                        out[0] = pix1 & 0xFF; out[1] = pix1 >> 8;
+                        out[2] = pix2 & 0xFF; out[3] = pix2 >> 8;
+                        out += stride;
+                        out[0] = pix1 & 0xFF; out[1] = pix1 >> 8;
+                        out[2] = pix2 & 0xFF; out[3] = pix2 >> 8;
+                        out += stride;
+                    }
+                    break;
+                }
+                blk++;
+            }
+            break;
+        case SMK_BLK_SKIP:
+            while(run-- && blk < blocks)
+                blk++;
+            break;
+        case SMK_BLK_FILL:
+            mode = type >> 8;
+            while(run-- && blk < blocks){
+                uint32_t col;
+                out = smk->pic.data[0] + (blk / bw) * (stride * 4) + (blk % bw) * 4;
+                col = mode * 0x01010101;
+                for(i = 0; i < 4; i++) {
+                    *((uint32_t*)out) = col;
+                    out += stride;
+                }
+                blk++;
+            }
+            break;
+        }
+
+    }
+
+    *data_size = sizeof(AVFrame);
+    *(AVFrame*)data = smk->pic;
+
+    /* always report that the buffer was completely consumed */
+    return buf_size;
+}
+
+
+
+/*
+ *
+ * Init smacker decoder
+ *
+ */
+static int decode_init(AVCodecContext *avctx)
+{
+    SmackVContext * const c = (SmackVContext *)avctx->priv_data;
+
+    c->avctx = avctx;
+    avctx->has_b_frames = 0;
+
+    c->pic.data[0] = NULL;
+
+    if (avcodec_check_dimensions(avctx, avctx->width, avctx->height) < 0) {
+        return 1;
+    }
+
+    avctx->pix_fmt = PIX_FMT_PAL8;
+
+
+    /* decode huffman trees from extradata */
+    if(avctx->extradata_size < 16){
+        av_log(avctx, AV_LOG_ERROR, "Extradata missing!\n");
+        return -1;
+    }
+
+    decode_header_trees(c);
+
+
+    return 0;
+}
+
+
+
+/*
+ *
+ * Uninit smacker decoder
+ *
+ */
+static int decode_end(AVCodecContext *avctx)
+{
+    SmackVContext * const smk = (SmackVContext *)avctx->priv_data;
+
+    av_freep(&smk->mmap_tbl);
+    av_freep(&smk->mclr_tbl);
+    av_freep(&smk->full_tbl);
+    av_freep(&smk->type_tbl);
+
+    if (smk->pic.data[0])
+        avctx->release_buffer(avctx, &smk->pic);
+
+    return 0;
+}
+
+
+static int smka_decode_init(AVCodecContext *avctx)
+{
+    return 0;
+}
+
+/**
+ * Decode Smacker audio data
+ */
+static int smka_decode_frame(AVCodecContext *avctx, void *data, int *data_size, uint8_t *buf, int buf_size)
+{
+    GetBitContext gb;
+    HuffContext h[4];
+    VLC vlc[4];
+    int16_t *samples = data;
+    int val;
+    int i, res;
+    int unp_size;
+    int bits, stereo;
+    int pred[2] = {0, 0};
+
+    unp_size = AV_RL32(buf);
+
+    init_get_bits(&gb, buf + 4, (buf_size - 4) * 8);
+
+    if(!get_bits1(&gb)){
+        av_log(avctx, AV_LOG_INFO, "Sound: no data\n");
+        *data_size = 0;
+        return 1;
+    }
+    stereo = get_bits1(&gb);
+    bits = get_bits1(&gb);
+
+    memset(vlc, 0, sizeof(VLC) * 4);
+    memset(h, 0, sizeof(HuffContext) * 4);
+    // Initialize
+    for(i = 0; i < (1 << (bits + stereo)); i++) {
+        h[i].length = 256;
+        h[i].maxlength = 0;
+        h[i].current = 0;
+        h[i].bits = av_mallocz(256 * 4);
+        h[i].lengths = av_mallocz(256 * sizeof(int));
+        h[i].values = av_mallocz(256 * sizeof(int));
+        get_bits1(&gb);
+        smacker_decode_tree(&gb, &h[i], 0, 0);
+        get_bits1(&gb);
+        if(h[i].current > 1) {
+            res = init_vlc(&vlc[i], SMKTREE_BITS, h[i].length,
+                    h[i].lengths, sizeof(int), sizeof(int),
+                    h[i].bits, sizeof(uint32_t), sizeof(uint32_t), INIT_VLC_LE);
+            if(res < 0) {
+                av_log(avctx, AV_LOG_ERROR, "Cannot build VLC table\n");
+                return -1;
+            }
+        }
+    }
+    if(bits) { //decode 16-bit data
+        pred[0]  = get_bits(&gb, 8);
+        pred[0] |= get_bits(&gb, 8);
+        *samples++ = pred[0];
+        if(stereo) {
+            pred[1]  = get_bits(&gb, 8);
+            pred[1] |= get_bits(&gb, 8);
+            *samples++ = pred[1];
+        }
+        for(i = 0; i < unp_size / 2; i++) {
+            if(i & stereo) {
+                if(vlc[2].table)
+                    res = get_vlc2(&gb, vlc[2].table, SMKTREE_BITS, 3);
+                else
+                    res = 0;
+                val  = h[2].values[res];
+                if(vlc[3].table)
+                    res = get_vlc2(&gb, vlc[3].table, SMKTREE_BITS, 3);
+                else
+                    res = 0;
+                val |= h[3].values[res] << 8;
+                pred[1] += (int16_t)val;
+                *samples++ = pred[1];
+            } else {
+                if(vlc[0].table)
+                    res = get_vlc2(&gb, vlc[0].table, SMKTREE_BITS, 3);
+                else
+                    res = 0;
+                val  = h[0].values[res];
+                if(vlc[1].table)
+                    res = get_vlc2(&gb, vlc[1].table, SMKTREE_BITS, 3);
+                else
+                    res = 0;
+                val |= h[1].values[res] << 8;
+                pred[0] += val;
+                *samples++ = pred[0];
+            }
+        }
+    } else { //8-bit data
+        pred[0] = get_bits(&gb, 8);
+        *samples++ = (pred[0] - 0x80) << 8;
+        if(stereo) {
+            pred[1] = get_bits(&gb, 8);
+            *samples++ = (pred[1] - 0x80) << 8;
+        }
+        for(i = 0; i < unp_size; i++) {
+            if(i & stereo){
+                if(vlc[1].table)
+                    res = get_vlc2(&gb, vlc[1].table, SMKTREE_BITS, 3);
+                else
+                    res = 0;
+                pred[1] += (int8_t)h[1].values[res];
+                *samples++ = (pred[1] - 0x80) << 8;
+            } else {
+                if(vlc[0].table)
+                    res = get_vlc2(&gb, vlc[0].table, SMKTREE_BITS, 3);
+                else
+                    res = 0;
+                pred[0] += (int8_t)h[0].values[res];
+                *samples++ = (pred[0] - 0x80) << 8;
+            }
+        }
+        unp_size *= 2;
+    }
+
+    for(i = 0; i < 4; i++) {
+        if(vlc[i].table)
+            free_vlc(&vlc[i]);
+        if(h[i].bits)
+            av_free(h[i].bits);
+        if(h[i].lengths)
+            av_free(h[i].lengths);
+        if(h[i].values)
+            av_free(h[i].values);
+    }
+
+    *data_size = unp_size;
+    return buf_size;
+}
+
+AVCodec smacker_decoder = {
+    "smackvid",
+    CODEC_TYPE_VIDEO,
+    CODEC_ID_SMACKVIDEO,
+    sizeof(SmackVContext),
+    decode_init,
+    NULL,
+    decode_end,
+    decode_frame
+};
+
+AVCodec smackaud_decoder = {
+    "smackaud",
+    CODEC_TYPE_AUDIO,
+    CODEC_ID_SMACKAUDIO,
+    0,
+    smka_decode_init,
+    NULL,
+    NULL,
+    smka_decode_frame
+};
+



From mean at mail.berlios.de  Sun Jan 21 19:46:09 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 21 Jan 2007 19:46:09 +0100
Subject: [Avidemux-svn-commit] r2760 -
	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec
Message-ID: <200701211846.l0LIk9Yh022376@sheep.berlios.de>

Author: mean
Date: 2007-01-21 19:46:01 +0100 (Sun, 21 Jan 2007)
New Revision: 2760

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/opt.c
Log:
new files

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/opt.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/opt.c	2007-01-21 18:45:20 UTC (rev 2759)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/opt.c	2007-01-21 18:46:01 UTC (rev 2760)
@@ -0,0 +1,381 @@
+/*
+ * AVOptions
+ * Copyright (c) 2005 Michael Niedermayer <michaelni at gmx.at>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+/**
+ * @file opt.c
+ * AVOptions
+ * @author Michael Niedermayer <michaelni at gmx.at>
+ */
+
+#include "avcodec.h"
+#include "opt.h"
+#include "eval.h"
+
+//FIXME order them and do a bin search
+static AVOption *find_opt(void *v, const char *name, const char *unit){
+    AVClass *c= *(AVClass**)v; //FIXME silly way of storing AVClass
+    AVOption *o= c->option;
+
+    for(;o && o->name; o++){
+        if(!strcmp(o->name, name) && (!unit || !strcmp(o->unit, unit)) )
+            return o;
+    }
+    return NULL;
+}
+
+AVOption *av_next_option(void *obj, AVOption *last){
+    if(last && last[1].name) return ++last;
+    else if(last)            return NULL;
+    else                     return (*(AVClass**)obj)->option;
+}
+
+static AVOption *av_set_number(void *obj, const char *name, double num, int den, int64_t intnum){
+    AVOption *o= find_opt(obj, name, NULL);
+    void *dst;
+    if(!o || o->offset<=0)
+        return NULL;
+
+    if(o->max*den < num*intnum || o->min*den > num*intnum) {
+        av_log(NULL, AV_LOG_ERROR, "Value %lf for parameter '%s' out of range.\n", num, name);
+        return NULL;
+    }
+
+    dst= ((uint8_t*)obj) + o->offset;
+
+    switch(o->type){
+    case FF_OPT_TYPE_FLAGS:
+    case FF_OPT_TYPE_INT:   *(int       *)dst= lrintf(num/den)*intnum; break;
+    case FF_OPT_TYPE_INT64: *(int64_t   *)dst= lrintf(num/den)*intnum; break;
+    case FF_OPT_TYPE_FLOAT: *(float     *)dst= num*intnum/den;         break;
+    case FF_OPT_TYPE_DOUBLE:*(double    *)dst= num*intnum/den;         break;
+    case FF_OPT_TYPE_RATIONAL:
+        if((int)num == num) *(AVRational*)dst= (AVRational){num*intnum, den};
+        else                *(AVRational*)dst= av_d2q(num*intnum/den, 1<<24);
+    default:
+        return NULL;
+    }
+    return o;
+}
+
+static AVOption *set_all_opt(void *v, const char *unit, double d){
+    AVClass *c= *(AVClass**)v; //FIXME silly way of storing AVClass
+    AVOption *o= c->option;
+    AVOption *ret=NULL;
+
+    for(;o && o->name; o++){
+        if(o->type != FF_OPT_TYPE_CONST && o->unit && !strcmp(o->unit, unit)){
+            double tmp= d;
+            if(o->type == FF_OPT_TYPE_FLAGS)
+                tmp= av_get_int(v, o->name, NULL) | (int64_t)d;
+
+            av_set_number(v, o->name, tmp, 1, 1);
+            ret= o;
+        }
+    }
+    return ret;
+}
+
+static double const_values[]={
+    M_PI,
+    M_E,
+    FF_QP2LAMBDA,
+    0
+};
+
+static const char *const_names[]={
+    "PI",
+    "E",
+    "QP2LAMBDA",
+    0
+};
+
+AVOption *av_set_string(void *obj, const char *name, const char *val){
+    AVOption *o= find_opt(obj, name, NULL);
+    if(o && o->offset==0 && o->type == FF_OPT_TYPE_CONST && o->unit){
+        return set_all_opt(obj, o->unit, o->default_val);
+    }
+    if(!o || !val || o->offset<=0)
+        return NULL;
+    if(o->type != FF_OPT_TYPE_STRING){
+        for(;;){
+            int i;
+            char buf[256];
+            int cmd=0;
+            double d;
+            char *error = NULL;
+
+            if(*val == '+' || *val == '-')
+                cmd= *(val++);
+
+            for(i=0; i<sizeof(buf)-1 && val[i] && val[i]!='+' && val[i]!='-'; i++)
+                buf[i]= val[i];
+            buf[i]=0;
+            val+= i;
+
+            d = ff_eval2(buf, const_values, const_names, NULL, NULL, NULL, NULL, NULL, &error);
+            if(isnan(d)) {
+                AVOption *o_named= find_opt(obj, buf, o->unit);
+                if(o_named && o_named->type == FF_OPT_TYPE_CONST)
+                    d= o_named->default_val;
+                else if(!strcmp(buf, "default")) d= o->default_val;
+                else if(!strcmp(buf, "max"    )) d= o->max;
+                else if(!strcmp(buf, "min"    )) d= o->min;
+                else {
+                    if (!error)
+                        av_log(NULL, AV_LOG_ERROR, "Unable to parse option value \"%s\": %s\n", val, error);
+                    return NULL;
+                }
+            }
+            if(o->type == FF_OPT_TYPE_FLAGS){
+                if     (cmd=='+') d= av_get_int(obj, name, NULL) | (int64_t)d;
+                else if(cmd=='-') d= av_get_int(obj, name, NULL) &~(int64_t)d;
+            }else if(cmd=='-')
+                d= -d;
+
+            av_set_number(obj, name, d, 1, 1);
+            if(!*val)
+                return o;
+        }
+        return NULL;
+    }
+
+    memcpy(((uint8_t*)obj) + o->offset, val, sizeof(val));
+    return o;
+}
+
+AVOption *av_set_double(void *obj, const char *name, double n){
+    return av_set_number(obj, name, n, 1, 1);
+}
+
+AVOption *av_set_q(void *obj, const char *name, AVRational n){
+    return av_set_number(obj, name, n.num, n.den, 1);
+}
+
+AVOption *av_set_int(void *obj, const char *name, int64_t n){
+    return av_set_number(obj, name, 1, 1, n);
+}
+
+/**
+ *
+ * @param buf a buffer which is used for returning non string values as strings, can be NULL
+ * @param buf_len allocated length in bytes of buf
+ */
+const char *av_get_string(void *obj, const char *name, AVOption **o_out, char *buf, int buf_len){
+    AVOption *o= find_opt(obj, name, NULL);
+    void *dst;
+    if(!o || o->offset<=0)
+        return NULL;
+    if(o->type != FF_OPT_TYPE_STRING && (!buf || !buf_len))
+        return NULL;
+
+    dst= ((uint8_t*)obj) + o->offset;
+    if(o_out) *o_out= o;
+
+    if(o->type == FF_OPT_TYPE_STRING)
+        return dst;
+
+    switch(o->type){
+    case FF_OPT_TYPE_FLAGS:     snprintf(buf, buf_len, "0x%08X",*(int    *)dst);break;
+    case FF_OPT_TYPE_INT:       snprintf(buf, buf_len, "%d" , *(int    *)dst);break;
+    case FF_OPT_TYPE_INT64:     snprintf(buf, buf_len, "%"PRId64, *(int64_t*)dst);break;
+    case FF_OPT_TYPE_FLOAT:     snprintf(buf, buf_len, "%f" , *(float  *)dst);break;
+    case FF_OPT_TYPE_DOUBLE:    snprintf(buf, buf_len, "%f" , *(double *)dst);break;
+    case FF_OPT_TYPE_RATIONAL:  snprintf(buf, buf_len, "%d/%d", ((AVRational*)dst)->num, ((AVRational*)dst)->den);break;
+    default: return NULL;
+    }
+    return buf;
+}
+
+static int av_get_number(void *obj, const char *name, AVOption **o_out, double *num, int *den, int64_t *intnum){
+    AVOption *o= find_opt(obj, name, NULL);
+    void *dst;
+    if(!o || o->offset<=0)
+        goto error;
+
+    dst= ((uint8_t*)obj) + o->offset;
+
+    if(o_out) *o_out= o;
+
+    switch(o->type){
+    case FF_OPT_TYPE_FLAGS:
+    case FF_OPT_TYPE_INT:       *intnum= *(int    *)dst;return 0;
+    case FF_OPT_TYPE_INT64:     *intnum= *(int64_t*)dst;return 0;
+    case FF_OPT_TYPE_FLOAT:     *num=    *(float  *)dst;return 0;
+    case FF_OPT_TYPE_DOUBLE:    *num=    *(double *)dst;return 0;
+    case FF_OPT_TYPE_RATIONAL:  *intnum= ((AVRational*)dst)->num;
+                                *den   = ((AVRational*)dst)->den;
+                                                        return 0;
+    }
+error:
+    *den=*intnum=0;
+    return -1;
+}
+
+double av_get_double(void *obj, const char *name, AVOption **o_out){
+    int64_t intnum=1;
+    double num=1;
+    int den=1;
+
+    av_get_number(obj, name, o_out, &num, &den, &intnum);
+    return num*intnum/den;
+}
+
+AVRational av_get_q(void *obj, const char *name, AVOption **o_out){
+    int64_t intnum=1;
+    double num=1;
+    int den=1;
+
+    av_get_number(obj, name, o_out, &num, &den, &intnum);
+    if(num == 1.0 && (int)intnum == intnum)
+        return (AVRational){intnum, den};
+    else
+        return av_d2q(num*intnum/den, 1<<24);
+}
+
+int64_t av_get_int(void *obj, const char *name, AVOption **o_out){
+    int64_t intnum=1;
+    double num=1;
+    int den=1;
+
+    av_get_number(obj, name, o_out, &num, &den, &intnum);
+    return num*intnum/den;
+}
+
+static void opt_list(void *obj, void *av_log_obj, char *unit)
+{
+    AVOption *opt=NULL;
+
+    while((opt= av_next_option(obj, opt))){
+        if(!(opt->flags & (AV_OPT_FLAG_ENCODING_PARAM|AV_OPT_FLAG_DECODING_PARAM)))
+            continue;
+
+        /* Don't print CONST's on level one.
+         * Don't print anything but CONST's on level two.
+         * Only print items from the requested unit.
+         */
+        if (!unit && opt->type==FF_OPT_TYPE_CONST)
+            continue;
+        else if (unit && opt->type!=FF_OPT_TYPE_CONST)
+            continue;
+        else if (unit && opt->type==FF_OPT_TYPE_CONST && strcmp(unit, opt->unit))
+            continue;
+        else if (unit && opt->type == FF_OPT_TYPE_CONST)
+            av_log(av_log_obj, AV_LOG_INFO, "   %-15s ", opt->name);
+        else
+            av_log(av_log_obj, AV_LOG_INFO, "-%-17s ", opt->name);
+
+        switch( opt->type )
+        {
+            case FF_OPT_TYPE_FLAGS:
+                av_log( av_log_obj, AV_LOG_INFO, "%-7s ", "<flags>" );
+                break;
+            case FF_OPT_TYPE_INT:
+                av_log( av_log_obj, AV_LOG_INFO, "%-7s ", "<int>" );
+                break;
+            case FF_OPT_TYPE_INT64:
+                av_log( av_log_obj, AV_LOG_INFO, "%-7s ", "<int64>" );
+                break;
+            case FF_OPT_TYPE_DOUBLE:
+                av_log( av_log_obj, AV_LOG_INFO, "%-7s ", "<double>" );
+                break;
+            case FF_OPT_TYPE_FLOAT:
+                av_log( av_log_obj, AV_LOG_INFO, "%-7s ", "<float>" );
+                break;
+            case FF_OPT_TYPE_STRING:
+                av_log( av_log_obj, AV_LOG_INFO, "%-7s ", "<string>" );
+                break;
+            case FF_OPT_TYPE_RATIONAL:
+                av_log( av_log_obj, AV_LOG_INFO, "%-7s ", "<rational>" );
+                break;
+            case FF_OPT_TYPE_CONST:
+            default:
+                av_log( av_log_obj, AV_LOG_INFO, "%-7s ", "" );
+                break;
+        }
+        av_log(av_log_obj, AV_LOG_INFO, "%c", (opt->flags & AV_OPT_FLAG_ENCODING_PARAM) ? 'E' : '.');
+        av_log(av_log_obj, AV_LOG_INFO, "%c", (opt->flags & AV_OPT_FLAG_DECODING_PARAM) ? 'D' : '.');
+        av_log(av_log_obj, AV_LOG_INFO, "%c", (opt->flags & AV_OPT_FLAG_VIDEO_PARAM   ) ? 'V' : '.');
+        av_log(av_log_obj, AV_LOG_INFO, "%c", (opt->flags & AV_OPT_FLAG_AUDIO_PARAM   ) ? 'A' : '.');
+        av_log(av_log_obj, AV_LOG_INFO, "%c", (opt->flags & AV_OPT_FLAG_SUBTITLE_PARAM) ? 'S' : '.');
+
+        if(opt->help)
+            av_log(av_log_obj, AV_LOG_INFO, " %s", opt->help);
+        av_log(av_log_obj, AV_LOG_INFO, "\n");
+        if (opt->unit && opt->type != FF_OPT_TYPE_CONST) {
+            opt_list(obj, av_log_obj, opt->unit);
+        }
+    }
+}
+
+int av_opt_show(void *obj, void *av_log_obj){
+    if(!obj)
+        return -1;
+
+    av_log(av_log_obj, AV_LOG_INFO, "%s AVOptions:\n", (*(AVClass**)obj)->class_name);
+
+    opt_list(obj, av_log_obj, NULL);
+
+    return 0;
+}
+
+/** Set the values of the AVCodecContext or AVFormatContext structure.
+ * They are set to the defaults specified in the according AVOption options
+ * array default_val field.
+ *
+ * @param s AVCodecContext or AVFormatContext for which the defaults will be set
+ */
+void av_opt_set_defaults(void *s)
+{
+    AVOption *opt = NULL;
+    while ((opt = av_next_option(s, opt)) != NULL) {
+        switch(opt->type) {
+            case FF_OPT_TYPE_CONST:
+                /* Nothing to be done here */
+            break;
+            case FF_OPT_TYPE_FLAGS:
+            case FF_OPT_TYPE_INT: {
+                int val;
+                val = opt->default_val;
+                av_set_int(s, opt->name, val);
+            }
+            break;
+            case FF_OPT_TYPE_FLOAT: {
+                double val;
+                val = opt->default_val;
+                av_set_double(s, opt->name, val);
+            }
+            break;
+            case FF_OPT_TYPE_RATIONAL: {
+                AVRational val;
+                val = av_d2q(opt->default_val, INT_MAX);
+                av_set_q(s, opt->name, val);
+            }
+            break;
+            case FF_OPT_TYPE_STRING:
+                /* Cannot set default for string as default_val is of type * double */
+            break;
+            default:
+                av_log(s, AV_LOG_DEBUG, "AVOption type %d of option %s not implemented yet\n", opt->type, opt->name);
+        }
+    }
+}
+



From mean at mail.berlios.de  Sun Jan 21 19:47:14 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 21 Jan 2007 19:47:14 +0100
Subject: [Avidemux-svn-commit] r2761 -
	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat
Message-ID: <200701211847.l0LIlEdG022501@sheep.berlios.de>

Author: mean
Date: 2007-01-21 19:47:13 +0100 (Sun, 21 Jan 2007)
New Revision: 2761

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/allformats.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/allformats.h
Log:
new files

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/allformats.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/allformats.c	2007-01-21 18:46:01 UTC (rev 2760)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/allformats.c	2007-01-21 18:47:13 UTC (rev 2761)
@@ -0,0 +1,186 @@
+/*
+ * Register all the formats and protocols
+ * Copyright (c) 2000, 2001, 2002 Fabrice Bellard
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+#include "avformat.h"
+#include "allformats.h"
+
+#define REGISTER_MUXER(X,x) \
+          if(ENABLE_##X##_MUXER)   av_register_output_format(&x##_muxer)
+#define REGISTER_DEMUXER(X,x) \
+          if(ENABLE_##X##_DEMUXER) av_register_input_format(&x##_demuxer)
+#define REGISTER_MUXDEMUX(X,x)  REGISTER_MUXER(X,x); REGISTER_DEMUXER(X,x)
+
+/* If you do not call this function, then you can select exactly which
+   formats you want to support */
+
+/**
+ * Initialize libavcodec and register all the codecs and formats.
+ */
+void av_register_all(void)
+{
+    static int inited = 0;
+
+    if (inited != 0)
+        return;
+    inited = 1;
+
+    avcodec_init();
+    avcodec_register_all();
+
+    REGISTER_DEMUXER (AAC, aac);
+    REGISTER_MUXDEMUX(AC3, ac3);
+    REGISTER_MUXER   (ADTS, adts);
+    REGISTER_MUXDEMUX(AIFF, aiff);
+    REGISTER_MUXDEMUX(AMR, amr);
+    REGISTER_MUXDEMUX(ASF, asf);
+    REGISTER_MUXER   (ASF_STREAM, asf_stream);
+    REGISTER_MUXDEMUX(AU, au);
+#if defined(CONFIG_AUDIO_OSS) || defined(CONFIG_AUDIO_BEOS)
+    REGISTER_MUXDEMUX(AUDIO, audio);
+#endif
+    REGISTER_MUXDEMUX(AVI, avi);
+#ifdef CONFIG_AVISYNTH
+    av_register_input_format(&avisynth_demuxer);
+#endif
+    REGISTER_DEMUXER (AVS, avs);
+    REGISTER_MUXER   (CRC, crc);
+    REGISTER_DEMUXER (DAUD, daud);
+#ifdef CONFIG_DC1394
+    REGISTER_DEMUXER (DC1394, dc1394);
+#endif
+    REGISTER_DEMUXER (DSICIN, dsicin);
+    REGISTER_DEMUXER (DTS, dts);
+    REGISTER_MUXDEMUX(DV, dv);
+#ifdef CONFIG_DV1394
+    REGISTER_DEMUXER (DV1394, dv1394);
+#endif
+    REGISTER_DEMUXER (EA, ea);
+    REGISTER_MUXDEMUX(FFM, ffm);
+    REGISTER_MUXDEMUX(FLAC, flac);
+    REGISTER_DEMUXER (FLIC, flic);
+    REGISTER_MUXDEMUX(FLV, flv);
+    REGISTER_DEMUXER (FOURXM, fourxm);
+    REGISTER_MUXER   (FRAMECRC, framecrc);
+    REGISTER_MUXDEMUX(GIF, gif);
+    REGISTER_DEMUXER (GXF, gxf);
+#ifdef CONFIG_GPL
+    REGISTER_MUXER   (GXF, gxf);
+#endif
+    REGISTER_MUXDEMUX(H261, h261);
+    REGISTER_MUXDEMUX(H263, h263);
+    REGISTER_MUXDEMUX(H264, h264);
+    REGISTER_DEMUXER (IDCIN, idcin);
+    REGISTER_MUXDEMUX(IMAGE2, image2);
+    REGISTER_MUXDEMUX(IMAGE2PIPE, image2pipe);
+    REGISTER_DEMUXER (INGENIENT, ingenient);
+    REGISTER_DEMUXER (IPMOVIE, ipmovie);
+    REGISTER_MUXDEMUX(M4V, m4v);
+    REGISTER_DEMUXER (MATROSKA, matroska);
+    REGISTER_MUXDEMUX(MJPEG, mjpeg);
+    REGISTER_DEMUXER (MM, mm);
+    REGISTER_MUXDEMUX(MMF, mmf);
+    REGISTER_MUXDEMUX(MOV, mov);
+    REGISTER_MUXER   (MP2, mp2);
+    REGISTER_MUXDEMUX(MP3, mp3);
+    REGISTER_MUXER   (MP4, mp4);
+    REGISTER_DEMUXER (MPC, mpc);
+    REGISTER_MUXER   (MPEG1SYSTEM, mpeg1system);
+    REGISTER_MUXER   (MPEG1VCD, mpeg1vcd);
+    REGISTER_MUXER   (MPEG1VIDEO, mpeg1video);
+    REGISTER_MUXER   (MPEG2DVD, mpeg2dvd);
+    REGISTER_MUXER   (MPEG2SVCD, mpeg2svcd);
+    REGISTER_MUXER   (MPEG2VIDEO, mpeg2video);
+    REGISTER_MUXER   (MPEG2VOB, mpeg2vob);
+    REGISTER_DEMUXER (MPEGPS, mpegps);
+    REGISTER_MUXDEMUX(MPEGTS, mpegts);
+    REGISTER_DEMUXER (MPEGVIDEO, mpegvideo);
+    REGISTER_MUXER   (MPJPEG, mpjpeg);
+    REGISTER_DEMUXER (MTV, mtv);
+    REGISTER_DEMUXER (MXF, mxf);
+    REGISTER_DEMUXER (NSV, nsv);
+    REGISTER_MUXER   (NULL, null);
+    REGISTER_DEMUXER (NUT, nut);
+#ifdef CONFIG_LIBNUT
+    REGISTER_MUXER   (NUT, nut);
+#endif
+    REGISTER_DEMUXER (NUV, nuv);
+    REGISTER_DEMUXER (OGG, ogg);
+#ifdef CONFIG_LIBOGG
+    REGISTER_MUXER   (OGG, ogg);
+#endif
+    REGISTER_MUXDEMUX(PCM_ALAW,  pcm_alaw);
+    REGISTER_MUXDEMUX(PCM_MULAW, pcm_mulaw);
+    REGISTER_MUXDEMUX(PCM_S16BE, pcm_s16be);
+    REGISTER_MUXDEMUX(PCM_S16LE, pcm_s16le);
+    REGISTER_MUXDEMUX(PCM_S8,    pcm_s8);
+    REGISTER_MUXDEMUX(PCM_U16BE, pcm_u16be);
+    REGISTER_MUXDEMUX(PCM_U16LE, pcm_u16le);
+    REGISTER_MUXDEMUX(PCM_U8,    pcm_u8);
+    REGISTER_MUXER   (PSP, psp);
+    REGISTER_MUXDEMUX(RAWVIDEO, rawvideo);
+    REGISTER_MUXDEMUX(RM, rm);
+    REGISTER_DEMUXER (ROQ, roq);
+#ifdef CONFIG_NETWORK
+    REGISTER_DEMUXER (REDIR, redir);
+    REGISTER_MUXER   (RTP, rtp);
+    REGISTER_DEMUXER (RTSP, rtsp);
+    REGISTER_DEMUXER (SDP, sdp);
+    av_register_rtp_dynamic_payload_handlers();
+#endif
+    REGISTER_DEMUXER (SEGAFILM, segafilm);
+    REGISTER_DEMUXER (SHORTEN, shorten);
+    REGISTER_DEMUXER (SMACKER, smacker);
+    REGISTER_DEMUXER (SOL, sol);
+    REGISTER_DEMUXER (STR, str);
+    REGISTER_MUXDEMUX(SWF, swf);
+    REGISTER_MUXER   (TG2, tg2);
+    REGISTER_MUXER   (TGP, tgp);
+    REGISTER_DEMUXER (TIERTEXSEQ, tiertexseq);
+    REGISTER_DEMUXER (TTA, tta);
+#ifdef CONFIG_VIDEO4LINUX2
+    REGISTER_DEMUXER (V4L2, v4l2);
+#endif
+#if defined(CONFIG_VIDEO4LINUX) || defined(CONFIG_BKTR)
+    REGISTER_DEMUXER (VIDEO_GRAB_DEVICE, video_grab_device);
+#endif
+    REGISTER_DEMUXER (VMD, vmd);
+    REGISTER_MUXDEMUX(VOC, voc);
+    REGISTER_MUXDEMUX(WAV, wav);
+    REGISTER_DEMUXER (WC3, wc3);
+    REGISTER_DEMUXER (WSAUD, wsaud);
+    REGISTER_DEMUXER (WSVQA, wsvqa);
+    REGISTER_DEMUXER (WV, wv);
+#ifdef CONFIG_X11GRAB
+    REGISTER_DEMUXER (X11_GRAB_DEVICE, x11_grab_device);
+#endif
+    REGISTER_MUXDEMUX(YUV4MPEGPIPE, yuv4mpegpipe);
+
+#ifdef CONFIG_PROTOCOLS
+    /* file protocols */
+    register_protocol(&file_protocol);
+    register_protocol(&pipe_protocol);
+#ifdef CONFIG_NETWORK
+    register_protocol(&udp_protocol);
+    register_protocol(&rtp_protocol);
+    register_protocol(&tcp_protocol);
+    register_protocol(&http_protocol);
+#endif
+#endif
+}

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/allformats.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/allformats.h	2007-01-21 18:46:01 UTC (rev 2760)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/allformats.h	2007-01-21 18:47:13 UTC (rev 2761)
@@ -0,0 +1,178 @@
+/*
+ * Register all the formats and protocols.
+ * copyright (c) 2000, 2001, 2002 Fabrice Bellard
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef ALLFORMATS_H
+#define ALLFORMATS_H
+
+extern AVInputFormat fourxm_demuxer;
+extern AVOutputFormat adts_muxer;
+extern AVInputFormat aiff_demuxer;
+extern AVOutputFormat aiff_muxer;
+extern AVInputFormat amr_demuxer;
+extern AVOutputFormat amr_muxer;
+extern AVInputFormat asf_demuxer;
+extern AVOutputFormat asf_muxer;
+extern AVOutputFormat asf_stream_muxer;
+extern AVInputFormat au_demuxer;
+extern AVOutputFormat au_muxer;
+extern AVInputFormat audio_demuxer;
+extern AVOutputFormat audio_muxer;
+extern AVInputFormat avi_demuxer;
+extern AVOutputFormat avi_muxer;
+extern AVInputFormat avisynth_demuxer;
+extern AVInputFormat avs_demuxer;
+extern AVOutputFormat crc_muxer;
+extern AVOutputFormat framecrc_muxer;
+extern AVInputFormat daud_demuxer;
+extern AVInputFormat dc1394_demuxer;
+extern AVInputFormat dsicin_demuxer;
+extern AVInputFormat dv1394_demuxer;
+extern AVInputFormat dv_demuxer;
+extern AVOutputFormat dv_muxer;
+extern AVInputFormat ea_demuxer;
+extern AVInputFormat ffm_demuxer;
+extern AVOutputFormat ffm_muxer;
+extern AVInputFormat flic_demuxer;
+extern AVInputFormat flv_demuxer;
+extern AVOutputFormat flv_muxer;
+extern AVOutputFormat gif_muxer;
+extern AVInputFormat gif_demuxer;
+extern AVInputFormat video_grab_device_demuxer;
+extern AVInputFormat gxf_demuxer;
+extern AVOutputFormat gxf_muxer;
+extern AVInputFormat idcin_demuxer;
+extern AVInputFormat roq_demuxer;
+extern AVInputFormat image2_demuxer;
+extern AVInputFormat image2pipe_demuxer;
+extern AVOutputFormat image2_muxer;
+extern AVOutputFormat image2pipe_muxer;
+extern AVInputFormat image_demuxer;
+extern AVInputFormat imagepipe_demuxer;
+extern AVOutputFormat image_muxer;
+extern AVOutputFormat imagepipe_muxer;
+extern AVInputFormat ipmovie_demuxer;
+extern AVInputFormat matroska_demuxer;
+extern AVInputFormat mm_demuxer;
+extern AVInputFormat mmf_demuxer;
+extern AVOutputFormat mmf_muxer;
+extern AVInputFormat mov_demuxer;
+extern AVOutputFormat mov_muxer;
+extern AVOutputFormat tgp_muxer;
+extern AVOutputFormat mp4_muxer;
+extern AVOutputFormat psp_muxer;
+extern AVOutputFormat tg2_muxer;
+extern AVInputFormat mp3_demuxer;
+extern AVOutputFormat mp2_muxer;
+extern AVOutputFormat mp3_muxer;
+extern AVInputFormat mpc_demuxer;
+extern AVOutputFormat mpeg1system_muxer;
+extern AVOutputFormat mpeg1vcd_muxer;
+extern AVOutputFormat mpeg2vob_muxer;
+extern AVOutputFormat mpeg2svcd_muxer;
+extern AVOutputFormat mpeg2dvd_muxer;
+extern AVInputFormat mpegps_demuxer;
+extern AVInputFormat mpegts_demuxer;
+extern AVOutputFormat mpegts_muxer;
+extern AVOutputFormat mpjpeg_muxer;
+extern AVInputFormat mtv_demuxer;
+extern AVInputFormat mxf_demuxer;
+extern AVInputFormat nsv_demuxer;
+extern AVInputFormat nut_demuxer;
+extern AVOutputFormat nut_muxer;
+extern AVInputFormat nuv_demuxer;
+extern AVInputFormat ogg_demuxer;
+extern AVOutputFormat ogg_muxer;
+extern AVInputFormat str_demuxer;
+extern AVInputFormat shorten_demuxer;
+extern AVInputFormat flac_demuxer;
+extern AVOutputFormat flac_muxer;
+extern AVInputFormat ac3_demuxer;
+extern AVOutputFormat ac3_muxer;
+extern AVInputFormat dts_demuxer;
+extern AVInputFormat aac_demuxer;
+extern AVInputFormat h261_demuxer;
+extern AVOutputFormat h261_muxer;
+extern AVInputFormat h263_demuxer;
+extern AVOutputFormat h263_muxer;
+extern AVInputFormat m4v_demuxer;
+extern AVOutputFormat m4v_muxer;
+extern AVInputFormat h264_demuxer;
+extern AVOutputFormat h264_muxer;
+extern AVInputFormat mpegvideo_demuxer;
+extern AVOutputFormat mpeg1video_muxer;
+extern AVOutputFormat mpeg2video_muxer;
+extern AVInputFormat mjpeg_demuxer;
+extern AVInputFormat ingenient_demuxer;
+extern AVOutputFormat mjpeg_muxer;
+extern AVInputFormat pcm_s16le_demuxer;
+extern AVOutputFormat pcm_s16le_muxer;
+extern AVInputFormat pcm_s16be_demuxer;
+extern AVOutputFormat pcm_s16be_muxer;
+extern AVInputFormat pcm_u16le_demuxer;
+extern AVOutputFormat pcm_u16le_muxer;
+extern AVInputFormat pcm_u16be_demuxer;
+extern AVOutputFormat pcm_u16be_muxer;
+extern AVInputFormat pcm_s8_demuxer;
+extern AVOutputFormat pcm_s8_muxer;
+extern AVInputFormat pcm_u8_demuxer;
+extern AVOutputFormat pcm_u8_muxer;
+extern AVInputFormat pcm_mulaw_demuxer;
+extern AVOutputFormat pcm_mulaw_muxer;
+extern AVInputFormat pcm_alaw_demuxer;
+extern AVOutputFormat pcm_alaw_muxer;
+extern AVInputFormat rawvideo_demuxer;
+extern AVOutputFormat rawvideo_muxer;
+extern AVOutputFormat null_muxer;
+extern AVInputFormat rm_demuxer;
+extern AVOutputFormat rm_muxer;
+extern AVInputFormat sdp_demuxer;
+extern AVInputFormat redir_demuxer;
+extern AVInputFormat segafilm_demuxer;
+extern AVInputFormat vmd_demuxer;
+extern AVInputFormat smacker_demuxer;
+extern AVInputFormat sol_demuxer;
+extern AVInputFormat swf_demuxer;
+extern AVOutputFormat swf_muxer;
+extern AVInputFormat tta_demuxer;
+extern AVInputFormat v4l2_demuxer;
+extern AVInputFormat voc_demuxer;
+extern AVOutputFormat voc_muxer;
+extern AVInputFormat wav_demuxer;
+extern AVOutputFormat wav_muxer;
+extern AVInputFormat wc3_demuxer;
+extern AVInputFormat wsaud_demuxer;
+extern AVInputFormat wsvqa_demuxer;
+extern AVInputFormat wv_demuxer;
+extern AVOutputFormat yuv4mpegpipe_muxer;
+extern AVInputFormat yuv4mpegpipe_demuxer;
+extern AVInputFormat tiertexseq_demuxer;
+extern AVInputFormat x11_grab_device_demuxer;
+
+/* raw.c */
+int pcm_read_seek(AVFormatContext *s,
+                  int stream_index, int64_t timestamp, int flags);
+
+/* rtsp.c */
+int redir_open(AVFormatContext **ic_ptr, ByteIOContext *f);
+/* rtp.c */
+void av_register_rtp_dynamic_payload_handlers();
+
+#endif



From mean at mail.berlios.de  Sun Jan 21 19:48:01 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 21 Jan 2007 19:48:01 +0100
Subject: [Avidemux-svn-commit] r2762 -
	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat
Message-ID: <200701211848.l0LIm1IS022556@sheep.berlios.de>

Author: mean
Date: 2007-01-21 19:48:01 +0100 (Sun, 21 Jan 2007)
New Revision: 2762

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/dv.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/qtpalette.h
Log:
new files

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/dv.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/dv.h	2007-01-21 18:47:13 UTC (rev 2761)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/dv.h	2007-01-21 18:48:01 UTC (rev 2762)
@@ -0,0 +1,37 @@
+/*
+ * General DV muxer/demuxer
+ * Copyright (c) 2003 Roman Shaposhnik
+ *
+ * Many thanks to Dan Dennedy <dan at dennedy.org> for providing wealth
+ * of DV technical info.
+ *
+ * Raw DV format
+ * Copyright (c) 2002 Fabrice Bellard.
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+typedef struct DVDemuxContext DVDemuxContext;
+DVDemuxContext* dv_init_demux(AVFormatContext* s);
+int dv_get_packet(DVDemuxContext*, AVPacket *);
+int dv_produce_packet(DVDemuxContext*, AVPacket*, uint8_t*, int);
+void dv_offset_reset(DVDemuxContext *c, int64_t frame_offset);
+
+typedef struct DVMuxContext DVMuxContext;
+DVMuxContext* dv_init_mux(AVFormatContext* s);
+int dv_assemble_frame(DVMuxContext *c, AVStream*, const uint8_t*, int, uint8_t**);
+void dv_delete_mux(DVMuxContext*);

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/qtpalette.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/qtpalette.h	2007-01-21 18:47:13 UTC (rev 2761)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/qtpalette.h	2007-01-21 18:48:01 UTC (rev 2762)
@@ -0,0 +1,295 @@
+/*
+ * Default Palettes for Quicktime Files
+ *  Automatically generated from a utility derived from XAnim:
+ *  http://xanim.va.pubnix.com/home.html
+ */
+
+#ifndef QTPALETTE_H
+#define QTPALETTE_H
+
+unsigned char ff_qt_default_palette_4[4 * 4] = {
+  0x93, 0x65, 0x5E, 0x00,
+  0xFF, 0xFF, 0xFF, 0x00,
+  0xDF, 0xD0, 0xAB, 0x00,
+  0x00, 0x00, 0x00, 0x00
+};
+
+unsigned char ff_qt_default_palette_16[16 * 4] = {
+  0xFF, 0xFB, 0xFF, 0x00,
+  0xEF, 0xD9, 0xBB, 0x00,
+  0xE8, 0xC9, 0xB1, 0x00,
+  0x93, 0x65, 0x5E, 0x00,
+  0xFC, 0xDE, 0xE8, 0x00,
+  0x9D, 0x88, 0x91, 0x00,
+  0xFF, 0xFF, 0xFF, 0x00,
+  0xFF, 0xFF, 0xFF, 0x00,
+  0xFF, 0xFF, 0xFF, 0x00,
+  0x47, 0x48, 0x37, 0x00,
+  0x7A, 0x5E, 0x55, 0x00,
+  0xDF, 0xD0, 0xAB, 0x00,
+  0xFF, 0xFB, 0xF9, 0x00,
+  0xE8, 0xCA, 0xC5, 0x00,
+  0x8A, 0x7C, 0x77, 0x00,
+  0x00, 0x00, 0x00, 0x00
+};
+
+unsigned char ff_qt_default_palette_256[256 * 4] = {
+  /*   0, 0x00 */  0xFF, 0xFF, 0xFF, 0x00,
+  /*   1, 0x01 */  0xFF, 0xFF, 0xCC, 0x00,
+  /*   2, 0x02 */  0xFF, 0xFF, 0x99, 0x00,
+  /*   3, 0x03 */  0xFF, 0xFF, 0x66, 0x00,
+  /*   4, 0x04 */  0xFF, 0xFF, 0x33, 0x00,
+  /*   5, 0x05 */  0xFF, 0xFF, 0x00, 0x00,
+  /*   6, 0x06 */  0xFF, 0xCC, 0xFF, 0x00,
+  /*   7, 0x07 */  0xFF, 0xCC, 0xCC, 0x00,
+  /*   8, 0x08 */  0xFF, 0xCC, 0x99, 0x00,
+  /*   9, 0x09 */  0xFF, 0xCC, 0x66, 0x00,
+  /*  10, 0x0A */  0xFF, 0xCC, 0x33, 0x00,
+  /*  11, 0x0B */  0xFF, 0xCC, 0x00, 0x00,
+  /*  12, 0x0C */  0xFF, 0x99, 0xFF, 0x00,
+  /*  13, 0x0D */  0xFF, 0x99, 0xCC, 0x00,
+  /*  14, 0x0E */  0xFF, 0x99, 0x99, 0x00,
+  /*  15, 0x0F */  0xFF, 0x99, 0x66, 0x00,
+  /*  16, 0x10 */  0xFF, 0x99, 0x33, 0x00,
+  /*  17, 0x11 */  0xFF, 0x99, 0x00, 0x00,
+  /*  18, 0x12 */  0xFF, 0x66, 0xFF, 0x00,
+  /*  19, 0x13 */  0xFF, 0x66, 0xCC, 0x00,
+  /*  20, 0x14 */  0xFF, 0x66, 0x99, 0x00,
+  /*  21, 0x15 */  0xFF, 0x66, 0x66, 0x00,
+  /*  22, 0x16 */  0xFF, 0x66, 0x33, 0x00,
+  /*  23, 0x17 */  0xFF, 0x66, 0x00, 0x00,
+  /*  24, 0x18 */  0xFF, 0x33, 0xFF, 0x00,
+  /*  25, 0x19 */  0xFF, 0x33, 0xCC, 0x00,
+  /*  26, 0x1A */  0xFF, 0x33, 0x99, 0x00,
+  /*  27, 0x1B */  0xFF, 0x33, 0x66, 0x00,
+  /*  28, 0x1C */  0xFF, 0x33, 0x33, 0x00,
+  /*  29, 0x1D */  0xFF, 0x33, 0x00, 0x00,
+  /*  30, 0x1E */  0xFF, 0x00, 0xFF, 0x00,
+  /*  31, 0x1F */  0xFF, 0x00, 0xCC, 0x00,
+  /*  32, 0x20 */  0xFF, 0x00, 0x99, 0x00,
+  /*  33, 0x21 */  0xFF, 0x00, 0x66, 0x00,
+  /*  34, 0x22 */  0xFF, 0x00, 0x33, 0x00,
+  /*  35, 0x23 */  0xFF, 0x00, 0x00, 0x00,
+  /*  36, 0x24 */  0xCC, 0xFF, 0xFF, 0x00,
+  /*  37, 0x25 */  0xCC, 0xFF, 0xCC, 0x00,
+  /*  38, 0x26 */  0xCC, 0xFF, 0x99, 0x00,
+  /*  39, 0x27 */  0xCC, 0xFF, 0x66, 0x00,
+  /*  40, 0x28 */  0xCC, 0xFF, 0x33, 0x00,
+  /*  41, 0x29 */  0xCC, 0xFF, 0x00, 0x00,
+  /*  42, 0x2A */  0xCC, 0xCC, 0xFF, 0x00,
+  /*  43, 0x2B */  0xCC, 0xCC, 0xCC, 0x00,
+  /*  44, 0x2C */  0xCC, 0xCC, 0x99, 0x00,
+  /*  45, 0x2D */  0xCC, 0xCC, 0x66, 0x00,
+  /*  46, 0x2E */  0xCC, 0xCC, 0x33, 0x00,
+  /*  47, 0x2F */  0xCC, 0xCC, 0x00, 0x00,
+  /*  48, 0x30 */  0xCC, 0x99, 0xFF, 0x00,
+  /*  49, 0x31 */  0xCC, 0x99, 0xCC, 0x00,
+  /*  50, 0x32 */  0xCC, 0x99, 0x99, 0x00,
+  /*  51, 0x33 */  0xCC, 0x99, 0x66, 0x00,
+  /*  52, 0x34 */  0xCC, 0x99, 0x33, 0x00,
+  /*  53, 0x35 */  0xCC, 0x99, 0x00, 0x00,
+  /*  54, 0x36 */  0xCC, 0x66, 0xFF, 0x00,
+  /*  55, 0x37 */  0xCC, 0x66, 0xCC, 0x00,
+  /*  56, 0x38 */  0xCC, 0x66, 0x99, 0x00,
+  /*  57, 0x39 */  0xCC, 0x66, 0x66, 0x00,
+  /*  58, 0x3A */  0xCC, 0x66, 0x33, 0x00,
+  /*  59, 0x3B */  0xCC, 0x66, 0x00, 0x00,
+  /*  60, 0x3C */  0xCC, 0x33, 0xFF, 0x00,
+  /*  61, 0x3D */  0xCC, 0x33, 0xCC, 0x00,
+  /*  62, 0x3E */  0xCC, 0x33, 0x99, 0x00,
+  /*  63, 0x3F */  0xCC, 0x33, 0x66, 0x00,
+  /*  64, 0x40 */  0xCC, 0x33, 0x33, 0x00,
+  /*  65, 0x41 */  0xCC, 0x33, 0x00, 0x00,
+  /*  66, 0x42 */  0xCC, 0x00, 0xFF, 0x00,
+  /*  67, 0x43 */  0xCC, 0x00, 0xCC, 0x00,
+  /*  68, 0x44 */  0xCC, 0x00, 0x99, 0x00,
+  /*  69, 0x45 */  0xCC, 0x00, 0x66, 0x00,
+  /*  70, 0x46 */  0xCC, 0x00, 0x33, 0x00,
+  /*  71, 0x47 */  0xCC, 0x00, 0x00, 0x00,
+  /*  72, 0x48 */  0x99, 0xFF, 0xFF, 0x00,
+  /*  73, 0x49 */  0x99, 0xFF, 0xCC, 0x00,
+  /*  74, 0x4A */  0x99, 0xFF, 0x99, 0x00,
+  /*  75, 0x4B */  0x99, 0xFF, 0x66, 0x00,
+  /*  76, 0x4C */  0x99, 0xFF, 0x33, 0x00,
+  /*  77, 0x4D */  0x99, 0xFF, 0x00, 0x00,
+  /*  78, 0x4E */  0x99, 0xCC, 0xFF, 0x00,
+  /*  79, 0x4F */  0x99, 0xCC, 0xCC, 0x00,
+  /*  80, 0x50 */  0x99, 0xCC, 0x99, 0x00,
+  /*  81, 0x51 */  0x99, 0xCC, 0x66, 0x00,
+  /*  82, 0x52 */  0x99, 0xCC, 0x33, 0x00,
+  /*  83, 0x53 */  0x99, 0xCC, 0x00, 0x00,
+  /*  84, 0x54 */  0x99, 0x99, 0xFF, 0x00,
+  /*  85, 0x55 */  0x99, 0x99, 0xCC, 0x00,
+  /*  86, 0x56 */  0x99, 0x99, 0x99, 0x00,
+  /*  87, 0x57 */  0x99, 0x99, 0x66, 0x00,
+  /*  88, 0x58 */  0x99, 0x99, 0x33, 0x00,
+  /*  89, 0x59 */  0x99, 0x99, 0x00, 0x00,
+  /*  90, 0x5A */  0x99, 0x66, 0xFF, 0x00,
+  /*  91, 0x5B */  0x99, 0x66, 0xCC, 0x00,
+  /*  92, 0x5C */  0x99, 0x66, 0x99, 0x00,
+  /*  93, 0x5D */  0x99, 0x66, 0x66, 0x00,
+  /*  94, 0x5E */  0x99, 0x66, 0x33, 0x00,
+  /*  95, 0x5F */  0x99, 0x66, 0x00, 0x00,
+  /*  96, 0x60 */  0x99, 0x33, 0xFF, 0x00,
+  /*  97, 0x61 */  0x99, 0x33, 0xCC, 0x00,
+  /*  98, 0x62 */  0x99, 0x33, 0x99, 0x00,
+  /*  99, 0x63 */  0x99, 0x33, 0x66, 0x00,
+  /* 100, 0x64 */  0x99, 0x33, 0x33, 0x00,
+  /* 101, 0x65 */  0x99, 0x33, 0x00, 0x00,
+  /* 102, 0x66 */  0x99, 0x00, 0xFF, 0x00,
+  /* 103, 0x67 */  0x99, 0x00, 0xCC, 0x00,
+  /* 104, 0x68 */  0x99, 0x00, 0x99, 0x00,
+  /* 105, 0x69 */  0x99, 0x00, 0x66, 0x00,
+  /* 106, 0x6A */  0x99, 0x00, 0x33, 0x00,
+  /* 107, 0x6B */  0x99, 0x00, 0x00, 0x00,
+  /* 108, 0x6C */  0x66, 0xFF, 0xFF, 0x00,
+  /* 109, 0x6D */  0x66, 0xFF, 0xCC, 0x00,
+  /* 110, 0x6E */  0x66, 0xFF, 0x99, 0x00,
+  /* 111, 0x6F */  0x66, 0xFF, 0x66, 0x00,
+  /* 112, 0x70 */  0x66, 0xFF, 0x33, 0x00,
+  /* 113, 0x71 */  0x66, 0xFF, 0x00, 0x00,
+  /* 114, 0x72 */  0x66, 0xCC, 0xFF, 0x00,
+  /* 115, 0x73 */  0x66, 0xCC, 0xCC, 0x00,
+  /* 116, 0x74 */  0x66, 0xCC, 0x99, 0x00,
+  /* 117, 0x75 */  0x66, 0xCC, 0x66, 0x00,
+  /* 118, 0x76 */  0x66, 0xCC, 0x33, 0x00,
+  /* 119, 0x77 */  0x66, 0xCC, 0x00, 0x00,
+  /* 120, 0x78 */  0x66, 0x99, 0xFF, 0x00,
+  /* 121, 0x79 */  0x66, 0x99, 0xCC, 0x00,
+  /* 122, 0x7A */  0x66, 0x99, 0x99, 0x00,
+  /* 123, 0x7B */  0x66, 0x99, 0x66, 0x00,
+  /* 124, 0x7C */  0x66, 0x99, 0x33, 0x00,
+  /* 125, 0x7D */  0x66, 0x99, 0x00, 0x00,
+  /* 126, 0x7E */  0x66, 0x66, 0xFF, 0x00,
+  /* 127, 0x7F */  0x66, 0x66, 0xCC, 0x00,
+  /* 128, 0x80 */  0x66, 0x66, 0x99, 0x00,
+  /* 129, 0x81 */  0x66, 0x66, 0x66, 0x00,
+  /* 130, 0x82 */  0x66, 0x66, 0x33, 0x00,
+  /* 131, 0x83 */  0x66, 0x66, 0x00, 0x00,
+  /* 132, 0x84 */  0x66, 0x33, 0xFF, 0x00,
+  /* 133, 0x85 */  0x66, 0x33, 0xCC, 0x00,
+  /* 134, 0x86 */  0x66, 0x33, 0x99, 0x00,
+  /* 135, 0x87 */  0x66, 0x33, 0x66, 0x00,
+  /* 136, 0x88 */  0x66, 0x33, 0x33, 0x00,
+  /* 137, 0x89 */  0x66, 0x33, 0x00, 0x00,
+  /* 138, 0x8A */  0x66, 0x00, 0xFF, 0x00,
+  /* 139, 0x8B */  0x66, 0x00, 0xCC, 0x00,
+  /* 140, 0x8C */  0x66, 0x00, 0x99, 0x00,
+  /* 141, 0x8D */  0x66, 0x00, 0x66, 0x00,
+  /* 142, 0x8E */  0x66, 0x00, 0x33, 0x00,
+  /* 143, 0x8F */  0x66, 0x00, 0x00, 0x00,
+  /* 144, 0x90 */  0x33, 0xFF, 0xFF, 0x00,
+  /* 145, 0x91 */  0x33, 0xFF, 0xCC, 0x00,
+  /* 146, 0x92 */  0x33, 0xFF, 0x99, 0x00,
+  /* 147, 0x93 */  0x33, 0xFF, 0x66, 0x00,
+  /* 148, 0x94 */  0x33, 0xFF, 0x33, 0x00,
+  /* 149, 0x95 */  0x33, 0xFF, 0x00, 0x00,
+  /* 150, 0x96 */  0x33, 0xCC, 0xFF, 0x00,
+  /* 151, 0x97 */  0x33, 0xCC, 0xCC, 0x00,
+  /* 152, 0x98 */  0x33, 0xCC, 0x99, 0x00,
+  /* 153, 0x99 */  0x33, 0xCC, 0x66, 0x00,
+  /* 154, 0x9A */  0x33, 0xCC, 0x33, 0x00,
+  /* 155, 0x9B */  0x33, 0xCC, 0x00, 0x00,
+  /* 156, 0x9C */  0x33, 0x99, 0xFF, 0x00,
+  /* 157, 0x9D */  0x33, 0x99, 0xCC, 0x00,
+  /* 158, 0x9E */  0x33, 0x99, 0x99, 0x00,
+  /* 159, 0x9F */  0x33, 0x99, 0x66, 0x00,
+  /* 160, 0xA0 */  0x33, 0x99, 0x33, 0x00,
+  /* 161, 0xA1 */  0x33, 0x99, 0x00, 0x00,
+  /* 162, 0xA2 */  0x33, 0x66, 0xFF, 0x00,
+  /* 163, 0xA3 */  0x33, 0x66, 0xCC, 0x00,
+  /* 164, 0xA4 */  0x33, 0x66, 0x99, 0x00,
+  /* 165, 0xA5 */  0x33, 0x66, 0x66, 0x00,
+  /* 166, 0xA6 */  0x33, 0x66, 0x33, 0x00,
+  /* 167, 0xA7 */  0x33, 0x66, 0x00, 0x00,
+  /* 168, 0xA8 */  0x33, 0x33, 0xFF, 0x00,
+  /* 169, 0xA9 */  0x33, 0x33, 0xCC, 0x00,
+  /* 170, 0xAA */  0x33, 0x33, 0x99, 0x00,
+  /* 171, 0xAB */  0x33, 0x33, 0x66, 0x00,
+  /* 172, 0xAC */  0x33, 0x33, 0x33, 0x00,
+  /* 173, 0xAD */  0x33, 0x33, 0x00, 0x00,
+  /* 174, 0xAE */  0x33, 0x00, 0xFF, 0x00,
+  /* 175, 0xAF */  0x33, 0x00, 0xCC, 0x00,
+  /* 176, 0xB0 */  0x33, 0x00, 0x99, 0x00,
+  /* 177, 0xB1 */  0x33, 0x00, 0x66, 0x00,
+  /* 178, 0xB2 */  0x33, 0x00, 0x33, 0x00,
+  /* 179, 0xB3 */  0x33, 0x00, 0x00, 0x00,
+  /* 180, 0xB4 */  0x00, 0xFF, 0xFF, 0x00,
+  /* 181, 0xB5 */  0x00, 0xFF, 0xCC, 0x00,
+  /* 182, 0xB6 */  0x00, 0xFF, 0x99, 0x00,
+  /* 183, 0xB7 */  0x00, 0xFF, 0x66, 0x00,
+  /* 184, 0xB8 */  0x00, 0xFF, 0x33, 0x00,
+  /* 185, 0xB9 */  0x00, 0xFF, 0x00, 0x00,
+  /* 186, 0xBA */  0x00, 0xCC, 0xFF, 0x00,
+  /* 187, 0xBB */  0x00, 0xCC, 0xCC, 0x00,
+  /* 188, 0xBC */  0x00, 0xCC, 0x99, 0x00,
+  /* 189, 0xBD */  0x00, 0xCC, 0x66, 0x00,
+  /* 190, 0xBE */  0x00, 0xCC, 0x33, 0x00,
+  /* 191, 0xBF */  0x00, 0xCC, 0x00, 0x00,
+  /* 192, 0xC0 */  0x00, 0x99, 0xFF, 0x00,
+  /* 193, 0xC1 */  0x00, 0x99, 0xCC, 0x00,
+  /* 194, 0xC2 */  0x00, 0x99, 0x99, 0x00,
+  /* 195, 0xC3 */  0x00, 0x99, 0x66, 0x00,
+  /* 196, 0xC4 */  0x00, 0x99, 0x33, 0x00,
+  /* 197, 0xC5 */  0x00, 0x99, 0x00, 0x00,
+  /* 198, 0xC6 */  0x00, 0x66, 0xFF, 0x00,
+  /* 199, 0xC7 */  0x00, 0x66, 0xCC, 0x00,
+  /* 200, 0xC8 */  0x00, 0x66, 0x99, 0x00,
+  /* 201, 0xC9 */  0x00, 0x66, 0x66, 0x00,
+  /* 202, 0xCA */  0x00, 0x66, 0x33, 0x00,
+  /* 203, 0xCB */  0x00, 0x66, 0x00, 0x00,
+  /* 204, 0xCC */  0x00, 0x33, 0xFF, 0x00,
+  /* 205, 0xCD */  0x00, 0x33, 0xCC, 0x00,
+  /* 206, 0xCE */  0x00, 0x33, 0x99, 0x00,
+  /* 207, 0xCF */  0x00, 0x33, 0x66, 0x00,
+  /* 208, 0xD0 */  0x00, 0x33, 0x33, 0x00,
+  /* 209, 0xD1 */  0x00, 0x33, 0x00, 0x00,
+  /* 210, 0xD2 */  0x00, 0x00, 0xFF, 0x00,
+  /* 211, 0xD3 */  0x00, 0x00, 0xCC, 0x00,
+  /* 212, 0xD4 */  0x00, 0x00, 0x99, 0x00,
+  /* 213, 0xD5 */  0x00, 0x00, 0x66, 0x00,
+  /* 214, 0xD6 */  0x00, 0x00, 0x33, 0x00,
+  /* 215, 0xD7 */  0xEE, 0x00, 0x00, 0x00,
+  /* 216, 0xD8 */  0xDD, 0x00, 0x00, 0x00,
+  /* 217, 0xD9 */  0xBB, 0x00, 0x00, 0x00,
+  /* 218, 0xDA */  0xAA, 0x00, 0x00, 0x00,
+  /* 219, 0xDB */  0x88, 0x00, 0x00, 0x00,
+  /* 220, 0xDC */  0x77, 0x00, 0x00, 0x00,
+  /* 221, 0xDD */  0x55, 0x00, 0x00, 0x00,
+  /* 222, 0xDE */  0x44, 0x00, 0x00, 0x00,
+  /* 223, 0xDF */  0x22, 0x00, 0x00, 0x00,
+  /* 224, 0xE0 */  0x11, 0x00, 0x00, 0x00,
+  /* 225, 0xE1 */  0x00, 0xEE, 0x00, 0x00,
+  /* 226, 0xE2 */  0x00, 0xDD, 0x00, 0x00,
+  /* 227, 0xE3 */  0x00, 0xBB, 0x00, 0x00,
+  /* 228, 0xE4 */  0x00, 0xAA, 0x00, 0x00,
+  /* 229, 0xE5 */  0x00, 0x88, 0x00, 0x00,
+  /* 230, 0xE6 */  0x00, 0x77, 0x00, 0x00,
+  /* 231, 0xE7 */  0x00, 0x55, 0x00, 0x00,
+  /* 232, 0xE8 */  0x00, 0x44, 0x00, 0x00,
+  /* 233, 0xE9 */  0x00, 0x22, 0x00, 0x00,
+  /* 234, 0xEA */  0x00, 0x11, 0x00, 0x00,
+  /* 235, 0xEB */  0x00, 0x00, 0xEE, 0x00,
+  /* 236, 0xEC */  0x00, 0x00, 0xDD, 0x00,
+  /* 237, 0xED */  0x00, 0x00, 0xBB, 0x00,
+  /* 238, 0xEE */  0x00, 0x00, 0xAA, 0x00,
+  /* 239, 0xEF */  0x00, 0x00, 0x88, 0x00,
+  /* 240, 0xF0 */  0x00, 0x00, 0x77, 0x00,
+  /* 241, 0xF1 */  0x00, 0x00, 0x55, 0x00,
+  /* 242, 0xF2 */  0x00, 0x00, 0x44, 0x00,
+  /* 243, 0xF3 */  0x00, 0x00, 0x22, 0x00,
+  /* 244, 0xF4 */  0x00, 0x00, 0x11, 0x00,
+  /* 245, 0xF5 */  0xEE, 0xEE, 0xEE, 0x00,
+  /* 246, 0xF6 */  0xDD, 0xDD, 0xDD, 0x00,
+  /* 247, 0xF7 */  0xBB, 0xBB, 0xBB, 0x00,
+  /* 248, 0xF8 */  0xAA, 0xAA, 0xAA, 0x00,
+  /* 249, 0xF9 */  0x88, 0x88, 0x88, 0x00,
+  /* 250, 0xFA */  0x77, 0x77, 0x77, 0x00,
+  /* 251, 0xFB */  0x55, 0x55, 0x55, 0x00,
+  /* 252, 0xFC */  0x44, 0x44, 0x44, 0x00,
+  /* 253, 0xFD */  0x22, 0x22, 0x22, 0x00,
+  /* 254, 0xFE */  0x11, 0x11, 0x11, 0x00,
+  /* 255, 0xFF */  0x00, 0x00, 0x00, 0x00
+};
+
+#endif



From mean at mail.berlios.de  Sun Jan 21 19:48:39 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 21 Jan 2007 19:48:39 +0100
Subject: [Avidemux-svn-commit] r2763 -
	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat
Message-ID: <200701211848.l0LImdWj022642@sheep.berlios.de>

Author: mean
Date: 2007-01-21 19:48:39 +0100 (Sun, 21 Jan 2007)
New Revision: 2763

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/riff.c
Log:
new files

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/riff.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/riff.c	2007-01-21 18:48:01 UTC (rev 2762)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/riff.c	2007-01-21 18:48:39 UTC (rev 2763)
@@ -0,0 +1,484 @@
+/*
+ * RIFF codec tags
+ * Copyright (c) 2000 Fabrice Bellard.
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "avformat.h"
+#include "avcodec.h"
+#include "riff.h"
+#include "allformats.h" // for asf_muxer
+
+/* Note: when encoding, the first matching tag is used, so order is
+   important if multiple tags possible for a given codec. */
+const AVCodecTag codec_bmp_tags[] = {
+    { CODEC_ID_H264, MKTAG('H', '2', '6', '4') },
+    { CODEC_ID_H264, MKTAG('h', '2', '6', '4') },
+    { CODEC_ID_H264, MKTAG('X', '2', '6', '4') },
+    { CODEC_ID_H264, MKTAG('x', '2', '6', '4') },
+    { CODEC_ID_H264, MKTAG('a', 'v', 'c', '1') },
+    { CODEC_ID_H264, MKTAG('V', 'S', 'S', 'H') },
+
+    { CODEC_ID_H263, MKTAG('H', '2', '6', '3') },
+    { CODEC_ID_H263P, MKTAG('H', '2', '6', '3') },
+    { CODEC_ID_H263I, MKTAG('I', '2', '6', '3') }, /* intel h263 */
+    { CODEC_ID_H261, MKTAG('H', '2', '6', '1') },
+
+    /* added based on MPlayer */
+    { CODEC_ID_H263P, MKTAG('U', '2', '6', '3') },
+    { CODEC_ID_H263P, MKTAG('v', 'i', 'v', '1') },
+
+    { CODEC_ID_MPEG4, MKTAG('F', 'M', 'P', '4') },
+    { CODEC_ID_MPEG4, MKTAG('D', 'I', 'V', 'X') },
+    { CODEC_ID_MPEG4, MKTAG('D', 'X', '5', '0') },
+    { CODEC_ID_MPEG4, MKTAG('X', 'V', 'I', 'D') },
+    { CODEC_ID_MPEG4, MKTAG('M', 'P', '4', 'S') },
+    { CODEC_ID_MPEG4, MKTAG('M', '4', 'S', '2') },
+    { CODEC_ID_MPEG4, MKTAG(0x04, 0, 0, 0) }, /* some broken avi use this */
+
+    /* added based on MPlayer */
+    { CODEC_ID_MPEG4, MKTAG('D', 'I', 'V', '1') },
+    { CODEC_ID_MPEG4, MKTAG('B', 'L', 'Z', '0') },
+    { CODEC_ID_MPEG4, MKTAG('m', 'p', '4', 'v') },
+    { CODEC_ID_MPEG4, MKTAG('U', 'M', 'P', '4') },
+    { CODEC_ID_MPEG4, MKTAG('W', 'V', '1', 'F') },
+    { CODEC_ID_MPEG4, MKTAG('S', 'E', 'D', 'G') },
+
+    { CODEC_ID_MPEG4, MKTAG('R', 'M', 'P', '4') },
+
+    { CODEC_ID_MSMPEG4V3, MKTAG('D', 'I', 'V', '3') }, /* default signature when using MSMPEG4 */
+    { CODEC_ID_MSMPEG4V3, MKTAG('M', 'P', '4', '3') },
+
+    /* added based on MPlayer */
+    { CODEC_ID_MSMPEG4V3, MKTAG('M', 'P', 'G', '3') },
+    { CODEC_ID_MSMPEG4V3, MKTAG('D', 'I', 'V', '5') },
+    { CODEC_ID_MSMPEG4V3, MKTAG('D', 'I', 'V', '6') },
+    { CODEC_ID_MSMPEG4V3, MKTAG('D', 'I', 'V', '4') },
+    { CODEC_ID_MSMPEG4V3, MKTAG('A', 'P', '4', '1') },
+    { CODEC_ID_MSMPEG4V3, MKTAG('C', 'O', 'L', '1') },
+    { CODEC_ID_MSMPEG4V3, MKTAG('C', 'O', 'L', '0') },
+
+    { CODEC_ID_MSMPEG4V2, MKTAG('M', 'P', '4', '2') },
+
+    /* added based on MPlayer */
+    { CODEC_ID_MSMPEG4V2, MKTAG('D', 'I', 'V', '2') },
+
+    { CODEC_ID_MSMPEG4V1, MKTAG('M', 'P', 'G', '4') },
+
+    { CODEC_ID_WMV1, MKTAG('W', 'M', 'V', '1') },
+
+    /* added based on MPlayer */
+    { CODEC_ID_WMV2, MKTAG('W', 'M', 'V', '2') },
+    { CODEC_ID_DVVIDEO, MKTAG('d', 'v', 's', 'd') },
+    { CODEC_ID_DVVIDEO, MKTAG('d', 'v', 'h', 'd') },
+    { CODEC_ID_DVVIDEO, MKTAG('d', 'v', 's', 'l') },
+    { CODEC_ID_DVVIDEO, MKTAG('d', 'v', '2', '5') },
+    { CODEC_ID_MPEG1VIDEO, MKTAG('m', 'p', 'g', '1') },
+    { CODEC_ID_MPEG1VIDEO, MKTAG('m', 'p', 'g', '2') },
+    { CODEC_ID_MPEG2VIDEO, MKTAG('m', 'p', 'g', '2') },
+    { CODEC_ID_MPEG2VIDEO, MKTAG('M', 'P', 'E', 'G') },
+    { CODEC_ID_MPEG1VIDEO, MKTAG('P', 'I', 'M', '1') },
+    { CODEC_ID_MPEG1VIDEO, MKTAG('V', 'C', 'R', '2') },
+    { CODEC_ID_MPEG1VIDEO, 0x10000001 },
+    { CODEC_ID_MPEG2VIDEO, 0x10000002 },
+    { CODEC_ID_MPEG2VIDEO, MKTAG('D', 'V', 'R', ' ') },
+    { CODEC_ID_MJPEG, MKTAG('M', 'J', 'P', 'G') },
+    { CODEC_ID_MJPEG, MKTAG('L', 'J', 'P', 'G') },
+    { CODEC_ID_LJPEG, MKTAG('L', 'J', 'P', 'G') },
+    { CODEC_ID_MJPEG, MKTAG('J', 'P', 'G', 'L') }, /* Pegasus lossless JPEG */
+    { CODEC_ID_MJPEG, MKTAG('M', 'J', 'L', 'S') }, /* JPEG-LS custom FOURCC for avi - decoder */
+    { CODEC_ID_JPEGLS, MKTAG('M', 'J', 'L', 'S') }, /* JPEG-LS custom FOURCC for avi - encoder */
+    { CODEC_ID_HUFFYUV, MKTAG('H', 'F', 'Y', 'U') },
+    { CODEC_ID_FFVHUFF, MKTAG('F', 'F', 'V', 'H') },
+    { CODEC_ID_CYUV, MKTAG('C', 'Y', 'U', 'V') },
+    { CODEC_ID_RAWVIDEO, 0 },
+    { CODEC_ID_RAWVIDEO, MKTAG('I', '4', '2', '0') },
+    { CODEC_ID_RAWVIDEO, MKTAG('Y', 'U', 'Y', '2') },
+    { CODEC_ID_RAWVIDEO, MKTAG('Y', '4', '2', '2') },
+    { CODEC_ID_RAWVIDEO, MKTAG('Y', 'V', '1', '2') },
+    { CODEC_ID_RAWVIDEO, MKTAG('U', 'Y', 'V', 'Y') },
+    { CODEC_ID_RAWVIDEO, MKTAG('I', 'Y', 'U', 'V') },
+    { CODEC_ID_RAWVIDEO, MKTAG('Y', '8', '0', '0') },
+    { CODEC_ID_INDEO3, MKTAG('I', 'V', '3', '1') },
+    { CODEC_ID_INDEO3, MKTAG('I', 'V', '3', '2') },
+    { CODEC_ID_VP3, MKTAG('V', 'P', '3', '1') },
+    { CODEC_ID_VP3, MKTAG('V', 'P', '3', '0') },
+    { CODEC_ID_VP5, MKTAG('V', 'P', '5', '0') },
+    { CODEC_ID_VP6, MKTAG('V', 'P', '6', '0') },
+    { CODEC_ID_VP6, MKTAG('V', 'P', '6', '1') },
+    { CODEC_ID_VP6, MKTAG('V', 'P', '6', '2') },
+    { CODEC_ID_ASV1, MKTAG('A', 'S', 'V', '1') },
+    { CODEC_ID_ASV2, MKTAG('A', 'S', 'V', '2') },
+    { CODEC_ID_VCR1, MKTAG('V', 'C', 'R', '1') },
+    { CODEC_ID_FFV1, MKTAG('F', 'F', 'V', '1') },
+    { CODEC_ID_XAN_WC4, MKTAG('X', 'x', 'a', 'n') },
+    { CODEC_ID_MSRLE, MKTAG('m', 'r', 'l', 'e') },
+    { CODEC_ID_MSRLE, MKTAG(0x1, 0x0, 0x0, 0x0) },
+    { CODEC_ID_MSVIDEO1, MKTAG('M', 'S', 'V', 'C') },
+    { CODEC_ID_MSVIDEO1, MKTAG('m', 's', 'v', 'c') },
+    { CODEC_ID_MSVIDEO1, MKTAG('C', 'R', 'A', 'M') },
+    { CODEC_ID_MSVIDEO1, MKTAG('c', 'r', 'a', 'm') },
+    { CODEC_ID_MSVIDEO1, MKTAG('W', 'H', 'A', 'M') },
+    { CODEC_ID_MSVIDEO1, MKTAG('w', 'h', 'a', 'm') },
+    { CODEC_ID_CINEPAK, MKTAG('c', 'v', 'i', 'd') },
+    { CODEC_ID_TRUEMOTION1, MKTAG('D', 'U', 'C', 'K') },
+    { CODEC_ID_MSZH, MKTAG('M', 'S', 'Z', 'H') },
+    { CODEC_ID_ZLIB, MKTAG('Z', 'L', 'I', 'B') },
+    { CODEC_ID_SNOW, MKTAG('S', 'N', 'O', 'W') },
+    { CODEC_ID_4XM, MKTAG('4', 'X', 'M', 'V') },
+    { CODEC_ID_FLV1, MKTAG('F', 'L', 'V', '1') },
+    { CODEC_ID_FLASHSV, MKTAG('F', 'S', 'V', '1') },
+    { CODEC_ID_VP6F, MKTAG('V', 'P', '6', 'F') },
+    { CODEC_ID_SVQ1, MKTAG('s', 'v', 'q', '1') },
+    { CODEC_ID_TSCC, MKTAG('t', 's', 'c', 'c') },
+    { CODEC_ID_ULTI, MKTAG('U', 'L', 'T', 'I') },
+    { CODEC_ID_VIXL, MKTAG('V', 'I', 'X', 'L') },
+    { CODEC_ID_QPEG, MKTAG('Q', 'P', 'E', 'G') },
+    { CODEC_ID_QPEG, MKTAG('Q', '1', '.', '0') },
+    { CODEC_ID_QPEG, MKTAG('Q', '1', '.', '1') },
+    { CODEC_ID_WMV3, MKTAG('W', 'M', 'V', '3') },
+    { CODEC_ID_VC1, MKTAG('W', 'V', 'C', '1') },
+    { CODEC_ID_LOCO, MKTAG('L', 'O', 'C', 'O') },
+    { CODEC_ID_WNV1, MKTAG('W', 'N', 'V', '1') },
+    { CODEC_ID_AASC, MKTAG('A', 'A', 'S', 'C') },
+    { CODEC_ID_INDEO2, MKTAG('R', 'T', '2', '1') },
+    { CODEC_ID_FRAPS, MKTAG('F', 'P', 'S', '1') },
+    { CODEC_ID_THEORA, MKTAG('t', 'h', 'e', 'o') },
+    { CODEC_ID_TRUEMOTION2, MKTAG('T', 'M', '2', '0') },
+    { CODEC_ID_CSCD, MKTAG('C', 'S', 'C', 'D') },
+    { CODEC_ID_ZMBV, MKTAG('Z', 'M', 'B', 'V') },
+    { CODEC_ID_KMVC, MKTAG('K', 'M', 'V', 'C') },
+    { CODEC_ID_CAVS, MKTAG('C', 'A', 'V', 'S') },
+    { CODEC_ID_JPEG2000, MKTAG('M', 'J', '2', 'C') },
+    { CODEC_ID_VMNC, MKTAG('V', 'M', 'n', 'c') },
+    { CODEC_ID_NONE, 0 },
+};
+
+const AVCodecTag codec_wav_tags[] = {
+    { CODEC_ID_MP2, 0x50 },
+    { CODEC_ID_MP3, 0x55 },
+    { CODEC_ID_AC3, 0x2000 },
+    { CODEC_ID_DTS, 0x2001 },
+    { CODEC_ID_PCM_S16LE, 0x01 },
+    { CODEC_ID_PCM_U8, 0x01 }, /* must come after s16le in this list */
+    { CODEC_ID_PCM_S24LE, 0x01 },
+    { CODEC_ID_PCM_S32LE, 0x01 },
+    { CODEC_ID_PCM_ALAW, 0x06 },
+    { CODEC_ID_PCM_MULAW, 0x07 },
+    { CODEC_ID_ADPCM_MS, 0x02 },
+    { CODEC_ID_ADPCM_IMA_WAV, 0x11 },
+    { CODEC_ID_ADPCM_YAMAHA, 0x20 },
+    { CODEC_ID_ADPCM_G726, 0x45 },
+    { CODEC_ID_ADPCM_IMA_DK4, 0x61 },  /* rogue format number */
+    { CODEC_ID_ADPCM_IMA_DK3, 0x62 },  /* rogue format number */
+    { CODEC_ID_WMAV1, 0x160 },
+    { CODEC_ID_WMAV2, 0x161 },
+    { CODEC_ID_AAC, 0x706d },
+    { CODEC_ID_AAC, 0xff },
+    { CODEC_ID_VORBIS, ('V'<<8)+'o' }, //HACK/FIXME, does vorbis in WAV/AVI have an (in)official id?
+    { CODEC_ID_SONIC, 0x2048 },
+    { CODEC_ID_SONIC_LS, 0x2048 },
+    { CODEC_ID_ADPCM_CT, 0x200 },
+    { CODEC_ID_ADPCM_SWF, ('S'<<8)+'F' },
+    { CODEC_ID_TRUESPEECH, 0x22 },
+    { CODEC_ID_FLAC, 0xF1AC },
+    { CODEC_ID_IMC, 0x401 },
+
+    /* FIXME: All of the IDs below are not 16 bit and thus illegal. */
+    // for NuppelVideo (nuv.c)
+    { CODEC_ID_PCM_S16LE, MKTAG('R', 'A', 'W', 'A') },
+    { CODEC_ID_MP3, MKTAG('L', 'A', 'M', 'E') },
+    { CODEC_ID_MP3, MKTAG('M', 'P', '3', ' ') },
+    { 0, 0 },
+};
+
+unsigned int codec_get_tag(const AVCodecTag *tags, int id)
+{
+    while (tags->id != CODEC_ID_NONE) {
+        if (tags->id == id)
+            return tags->tag;
+        tags++;
+    }
+    return 0;
+}
+
+enum CodecID codec_get_id(const AVCodecTag *tags, unsigned int tag)
+{
+    while (tags->id != CODEC_ID_NONE) {
+        if(   toupper((tag >> 0)&0xFF) == toupper((tags->tag >> 0)&0xFF)
+           && toupper((tag >> 8)&0xFF) == toupper((tags->tag >> 8)&0xFF)
+           && toupper((tag >>16)&0xFF) == toupper((tags->tag >>16)&0xFF)
+           && toupper((tag >>24)&0xFF) == toupper((tags->tag >>24)&0xFF))
+            return tags->id;
+        tags++;
+    }
+    return CODEC_ID_NONE;
+}
+
+unsigned int av_codec_get_tag(const AVCodecTag *tags[4], enum CodecID id)
+{
+    int i;
+    for(i=0; i<4 && tags[i]; i++){
+        int tag= codec_get_tag(tags[i], id);
+        if(tag) return tag;
+    }
+    return 0;
+}
+
+enum CodecID av_codec_get_id(const AVCodecTag *tags[4], unsigned int tag)
+{
+    int i;
+    for(i=0; i<4 && tags[i]; i++){
+        enum CodecID id= codec_get_id(tags[i], tag);
+        if(id!=CODEC_ID_NONE) return id;
+    }
+    return CODEC_ID_NONE;
+}
+
+unsigned int codec_get_bmp_tag(int id)
+{
+    return codec_get_tag(codec_bmp_tags, id);
+}
+
+unsigned int codec_get_wav_tag(int id)
+{
+    return codec_get_tag(codec_wav_tags, id);
+}
+
+enum CodecID codec_get_bmp_id(unsigned int tag)
+{
+    return codec_get_id(codec_bmp_tags, tag);
+}
+
+enum CodecID codec_get_wav_id(unsigned int tag)
+{
+    return codec_get_id(codec_wav_tags, tag);
+}
+
+#ifdef CONFIG_MUXERS
+offset_t start_tag(ByteIOContext *pb, const char *tag)
+{
+    put_tag(pb, tag);
+    put_le32(pb, 0);
+    return url_ftell(pb);
+}
+
+void end_tag(ByteIOContext *pb, offset_t start)
+{
+    offset_t pos;
+
+    pos = url_ftell(pb);
+    url_fseek(pb, start - 4, SEEK_SET);
+    put_le32(pb, (uint32_t)(pos - start));
+    url_fseek(pb, pos, SEEK_SET);
+}
+
+/* WAVEFORMATEX header */
+/* returns the size or -1 on error */
+int put_wav_header(ByteIOContext *pb, AVCodecContext *enc)
+{
+    int bps, blkalign, bytespersec;
+    int hdrsize = 18;
+
+    if(!enc->codec_tag || enc->codec_tag > 0xffff)
+       enc->codec_tag = codec_get_tag(codec_wav_tags, enc->codec_id);
+    if(!enc->codec_tag || enc->codec_tag > 0xffff)
+        return -1;
+
+    put_le16(pb, enc->codec_tag);
+    put_le16(pb, enc->channels);
+    put_le32(pb, enc->sample_rate);
+    if (enc->codec_id == CODEC_ID_PCM_U8 ||
+        enc->codec_id == CODEC_ID_PCM_ALAW ||
+        enc->codec_id == CODEC_ID_PCM_MULAW) {
+        bps = 8;
+    } else if (enc->codec_id == CODEC_ID_MP2 || enc->codec_id == CODEC_ID_MP3) {
+        bps = 0;
+    } else if (enc->codec_id == CODEC_ID_ADPCM_IMA_WAV || enc->codec_id == CODEC_ID_ADPCM_MS || enc->codec_id == CODEC_ID_ADPCM_G726 || enc->codec_id == CODEC_ID_ADPCM_YAMAHA) { //
+        bps = 4;
+    } else if (enc->codec_id == CODEC_ID_PCM_S24LE) {
+        bps = 24;
+    } else if (enc->codec_id == CODEC_ID_PCM_S32LE) {
+        bps = 32;
+    } else {
+        bps = 16;
+    }
+
+    if (enc->codec_id == CODEC_ID_MP2 || enc->codec_id == CODEC_ID_MP3) {
+        blkalign = enc->frame_size; //this is wrong, but seems many demuxers dont work if this is set correctly
+        //blkalign = 144 * enc->bit_rate/enc->sample_rate;
+    } else if (enc->codec_id == CODEC_ID_ADPCM_G726) { //
+        blkalign = 1;
+    } else if (enc->block_align != 0) { /* specified by the codec */
+        blkalign = enc->block_align;
+    } else
+        blkalign = enc->channels*bps >> 3;
+    if (enc->codec_id == CODEC_ID_PCM_U8 ||
+        enc->codec_id == CODEC_ID_PCM_S24LE ||
+        enc->codec_id == CODEC_ID_PCM_S32LE ||
+        enc->codec_id == CODEC_ID_PCM_S16LE) {
+        bytespersec = enc->sample_rate * blkalign;
+    } else {
+        bytespersec = enc->bit_rate / 8;
+    }
+    put_le32(pb, bytespersec); /* bytes per second */
+    put_le16(pb, blkalign); /* block align */
+    put_le16(pb, bps); /* bits per sample */
+    if (enc->codec_id == CODEC_ID_MP3) {
+        put_le16(pb, 12); /* wav_extra_size */
+        hdrsize += 12;
+        put_le16(pb, 1); /* wID */
+        put_le32(pb, 2); /* fdwFlags */
+        put_le16(pb, 1152); /* nBlockSize */
+        put_le16(pb, 1); /* nFramesPerBlock */
+        put_le16(pb, 1393); /* nCodecDelay */
+    } else if (enc->codec_id == CODEC_ID_MP2) {
+        put_le16(pb, 22); /* wav_extra_size */
+        hdrsize += 22;
+        put_le16(pb, 2);  /* fwHeadLayer */
+        put_le32(pb, enc->bit_rate); /* dwHeadBitrate */
+        put_le16(pb, enc->channels == 2 ? 1 : 8); /* fwHeadMode */
+        put_le16(pb, 0);  /* fwHeadModeExt */
+        put_le16(pb, 1);  /* wHeadEmphasis */
+        put_le16(pb, 16); /* fwHeadFlags */
+        put_le32(pb, 0);  /* dwPTSLow */
+        put_le32(pb, 0);  /* dwPTSHigh */
+    } else if (enc->codec_id == CODEC_ID_ADPCM_IMA_WAV) {
+        put_le16(pb, 2); /* wav_extra_size */
+        hdrsize += 2;
+        put_le16(pb, ((enc->block_align - 4 * enc->channels) / (4 * enc->channels)) * 8 + 1); /* wSamplesPerBlock */
+    } else if(enc->extradata_size){
+        put_le16(pb, enc->extradata_size);
+        put_buffer(pb, enc->extradata, enc->extradata_size);
+        hdrsize += enc->extradata_size;
+        if(hdrsize&1){
+            hdrsize++;
+            put_byte(pb, 0);
+        }
+    } else {
+        hdrsize -= 2;
+    }
+
+    return hdrsize;
+}
+
+/* BITMAPINFOHEADER header */
+void put_bmp_header(ByteIOContext *pb, AVCodecContext *enc, const AVCodecTag *tags, int for_asf)
+{
+    put_le32(pb, 40 + enc->extradata_size); /* size */
+    put_le32(pb, enc->width);
+    put_le32(pb, enc->height);
+    put_le16(pb, 1); /* planes */
+
+    put_le16(pb, enc->bits_per_sample ? enc->bits_per_sample : 24); /* depth */
+    /* compression type */
+
+    // MEANX we dont need that
+        assert(0);
+/*    put_le32(pb, for_asf ? (enc->codec_tag ? enc->codec_tag : av_codec_get_tag(asf_muxer.codec_tag, enc->codec_id)) : enc->codec_tag); //*/
+    put_le32(pb, enc->width * enc->height * 3);
+    put_le32(pb, 0);
+    put_le32(pb, 0);
+    put_le32(pb, 0);
+    put_le32(pb, 0);
+
+    put_buffer(pb, enc->extradata, enc->extradata_size);
+
+    if (enc->extradata_size & 1)
+        put_byte(pb, 0);
+}
+#endif //CONFIG_MUXERS
+
+#ifdef CONFIG_DEMUXERS
+/* We could be given one of the three possible structures here:
+ * WAVEFORMAT, PCMWAVEFORMAT or WAVEFORMATEX. Each structure
+ * is an expansion of the previous one with the fields added
+ * at the bottom. PCMWAVEFORMAT adds 'WORD wBitsPerSample' and
+ * WAVEFORMATEX adds 'WORD  cbSize' and basically makes itself
+ * an openended structure.
+ */
+void get_wav_header(ByteIOContext *pb, AVCodecContext *codec, int size)
+{
+    int id;
+
+    id = get_le16(pb);
+    codec->codec_type = CODEC_TYPE_AUDIO;
+    codec->codec_tag = id;
+    codec->channels = get_le16(pb);
+    codec->sample_rate = get_le32(pb);
+    codec->bit_rate = get_le32(pb) * 8;
+    codec->block_align = get_le16(pb);
+    if (size == 14) {  /* We're dealing with plain vanilla WAVEFORMAT */
+        codec->bits_per_sample = 8;
+    }else
+        codec->bits_per_sample = get_le16(pb);
+    codec->codec_id = wav_codec_get_id(id, codec->bits_per_sample);
+
+    if (size > 16) {  /* We're obviously dealing with WAVEFORMATEX */
+        codec->extradata_size = get_le16(pb);
+        if (codec->extradata_size > 0) {
+            if (codec->extradata_size > size - 18)
+                codec->extradata_size = size - 18;
+            codec->extradata = av_mallocz(codec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);
+            get_buffer(pb, codec->extradata, codec->extradata_size);
+        } else
+            codec->extradata_size = 0;
+
+        /* It is possible for the chunk to contain garbage at the end */
+        if (size - codec->extradata_size - 18 > 0)
+            url_fskip(pb, size - codec->extradata_size - 18);
+    }
+}
+
+
+int wav_codec_get_id(unsigned int tag, int bps)
+{
+    int id;
+    id = codec_get_id(codec_wav_tags, tag);
+    if (id <= 0)
+        return id;
+    /* handle specific u8 codec */
+    if (id == CODEC_ID_PCM_S16LE && bps == 8)
+        id = CODEC_ID_PCM_U8;
+    if (id == CODEC_ID_PCM_S16LE && bps == 24)
+        id = CODEC_ID_PCM_S24LE;
+    if (id == CODEC_ID_PCM_S16LE && bps == 32)
+        id = CODEC_ID_PCM_S32LE;
+    return id;
+}
+#endif // CONFIG_DEMUXERS
+
+void ff_parse_specific_params(AVCodecContext *stream, int *au_rate, int *au_ssize, int *au_scale)
+{
+    int gcd;
+
+    *au_ssize= stream->block_align;
+    if(stream->frame_size && stream->sample_rate){
+        *au_scale=stream->frame_size;
+        *au_rate= stream->sample_rate;
+    }else if(stream->codec_type == CODEC_TYPE_VIDEO){
+        *au_scale= stream->time_base.num;
+        *au_rate = stream->time_base.den;
+    }else{
+        *au_scale= stream->block_align ? stream->block_align*8 : 8;
+        *au_rate = stream->bit_rate;
+    }
+    gcd= ff_gcd(*au_scale, *au_rate);
+    *au_scale /= gcd;
+    *au_rate /= gcd;
+}



From mean at mail.berlios.de  Sun Jan 21 20:22:18 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 21 Jan 2007 20:22:18 +0100
Subject: [Avidemux-svn-commit] r2764 -
	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat
Message-ID: <200701211922.l0LJMIVJ024833@sheep.berlios.de>

Author: mean
Date: 2007-01-21 20:22:18 +0100 (Sun, 21 Jan 2007)
New Revision: 2764

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/ADM_lavformat.cpp
Log:
new audio timebase for mov/mp4

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/ADM_lavformat.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/ADM_lavformat.cpp	2007-01-21 18:48:39 UTC (rev 2763)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/ADM_lavformat.cpp	2007-01-21 19:22:18 UTC (rev 2764)
@@ -426,14 +426,21 @@
         int ret;
         AVPacket pkt;
         double f;
+        int64_t timeInUs;
 
            if(!audio_st) return 0;
            if(!len) return 1;
             av_init_packet(&pkt);
 
+            timeInUs=(int64_t)sample2time_us(sample);
+            /* Rescale to ?? */
+            f=timeInUs;
+            f/=1000000.; // In ms seconds 
+            f*=_audioFq;
+            
+            
+            pkt.dts=pkt.pts=(int)f;
 
-            pkt.dts=pkt.pts=(int64_t)sample2time_us(sample);
-
             pkt.flags |= PKT_FLAG_KEY; 
             pkt.data= buf;
             pkt.size= len;
@@ -442,7 +449,7 @@
             aprintf("A: sample: %d frame_pts: %d fq: %d\n",(int32_t )sample,(int32_t )pkt.dts,audio_st->codec->sample_rate); 
 
             ret = av_write_frame(oc, &pkt);
-            _lastAudioDts=pkt.dts;
+            _lastAudioDts=timeInUs;
             if(ret) 
             {
                         printf("Error writing audio packet\n");



From mean at mail.berlios.de  Mon Jan 22 07:47:18 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Mon, 22 Jan 2007 07:47:18 +0100
Subject: [Avidemux-svn-commit] r2765 - in
	branches/avidemux_2.4_branch/avidemux: . ADM_codecs
	ADM_encoder ADM_userInterfaces/ADM_GTK/ADM_dialog
Message-ID: <200701220647.l0M6lIeF015830@sheep.berlios.de>

Author: mean
Date: 2007-01-22 07:47:17 +0100 (Mon, 22 Jan 2007)
New Revision: 2765

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_x264.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_encoder/ADM_encCodecDesc.h
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_x264.cpp
   branches/avidemux_2.4_branch/avidemux/gui_autodrive.cpp
Log:
bitrate fix + psp fix

Modified: branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_x264.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_x264.cpp	2007-01-21 19:22:18 UTC (rev 2764)
+++ branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_x264.cpp	2007-01-22 06:47:17 UTC (rev 2765)
@@ -356,7 +356,7 @@
 #else
   param.rc.b_cbr = 1;
 #endif
-  param.rc.i_bitrate = val / 1000;
+  param.rc.i_bitrate = val ;
 //  param.rc.i_rc_buffer_size=val/1000;
 //  param.rc.i_rc_init_buffer=(val/1000)>>1;
   return preamble (fps1000, zparam);

Modified: branches/avidemux_2.4_branch/avidemux/ADM_encoder/ADM_encCodecDesc.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_encoder/ADM_encCodecDesc.h	2007-01-21 19:22:18 UTC (rev 2764)
+++ branches/avidemux_2.4_branch/avidemux/ADM_encoder/ADM_encCodecDesc.h	2007-01-22 06:47:17 UTC (rev 2765)
@@ -632,15 +632,15 @@
 4,//     uint32_t  QpStep;
 //     //
 1, //     uint32_t maxRefScene
-40,//     uint32_t  SceneCut;
+0,//     uint32_t  SceneCut;
 25,//     uint32_t  MinIdr;
 250,//     uint32_t  MaxIdr;
 //     //
-1,//     uint32_t  _8x8;
-1,//     uint32_t   _8x8P;
-1,//     uint32_t   _8x8B;
+0,//     uint32_t  _8x8;
+0,//     uint32_t   _8x8P;
+0,//     uint32_t   _8x8B;
 0,//     uint32_t   _4x4;
-1,//     uint32_t   _8X8I;
+0,//     uint32_t   _8X8I;
 0,//     uint32_t   _4x4I;
 //     //
 0,//     uint32_t  MaxBFrame;
@@ -653,16 +653,16 @@
 0,//     uint32_t DirectMode;
 //     //
 4,//     uint32_t PartitionDecision;
-32, //Range
+4,//              Range
 1,//     uint32_t Method;
 1,//     uint32_t AR_Num;
 1,//     uint32_t AR_Den;
-1,//     uint32_t DeblockingFilter;
+0,//     uint32_t DeblockingFilter;
 0,//     int32_t  Strength;
 0,//     int32_t  Threshold;
 1,//     uint32_t CABAC;
 0,//     uint32_t Trellis;
-1, //        ChromaME
+0, //        ChromaME
 0, // Mixed Ref
 0, //NoiseReduction
 30 // level IDC for psp  

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_x264.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_x264.cpp	2007-01-21 19:22:18 UTC (rev 2764)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_x264.cpp	2007-01-22 06:47:17 UTC (rev 2765)
@@ -109,7 +109,7 @@
           switch(generic.mode)
           {
             case COMPRESS_CBR:
-              generic.bitrate=b*1000;
+              generic.bitrate=b;
               break;
 
             case COMPRESS_2PASS:              
@@ -148,7 +148,7 @@
   {
     case COMPRESS_CBR:
         COMBO(2);
-      b=generic.bitrate/1000;
+      b=generic.bitrate;
       ENTRY_SET(Target,b);     
       gtk_label_set_text(GTK_LABEL(WID(labelTarget)),"Target bitrate (kb/s):");
       DISABLE(spinbuttonQuantizer);

Modified: branches/avidemux_2.4_branch/avidemux/gui_autodrive.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/gui_autodrive.cpp	2007-01-21 19:22:18 UTC (rev 2764)
+++ branches/avidemux_2.4_branch/avidemux/gui_autodrive.cpp	2007-01-22 06:47:17 UTC (rev 2765)
@@ -45,6 +45,7 @@
 
 uint8_t A_autoDrive(Action action)
 {
+  uint32_t fq;
         //
         if(!currentaudiostream)
         {
@@ -83,6 +84,7 @@
                             }
                             // Set mode & bitrate 
                             setVideoEncoderSettings(COMPRESS_CBR,768,0,NULL);
+                            fq=24000;
                           }
                           break;
                     case ACT_AUTO_PSP_H264:
@@ -92,6 +94,7 @@
                           setPSP_X264Preset(); 
                           setVideoEncoderSettings(COMPRESS_CBR,768,0,NULL);
 #endif
+                          fq=48000;
                     }
                     break;
                     
@@ -99,7 +102,7 @@
                           ADM_assert(0);
                     }
                     // Audio Codec
-                    if((currentaudiostream->getInfo()->frequency==PSP_AUDIO_FQ)&&
+                    if((currentaudiostream->getInfo()->frequency==fq)&&
                         (currentaudiostream->getInfo()->channels==2)&&
                         (currentaudiostream->getInfo()->encoding==WAV_AAC))
                     {
@@ -114,9 +117,9 @@
                                         _( "You don't have FAAC!.\nIt is needed to create PSP compatible video."));
 #endif
                                     // ? Needed ?
-                          if(currentaudiostream->getInfo()->frequency!=PSP_AUDIO_FQ)
+                          if(currentaudiostream->getInfo()->frequency!=fq)
                           {
-                              audioFilterResample(PSP_AUDIO_FQ);
+                              audioFilterResample(fq);
                           }
                           audioFilter_SetBitrate(128);
                       }



From mean at mail.berlios.de  Mon Jan 22 20:23:29 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Mon, 22 Jan 2007 20:23:29 +0100
Subject: [Avidemux-svn-commit] r2766 - in
	branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces:
	ADM_GTK/ADM_dialog ADM_NONE/ADM_dialog ADM_QT4/ADM_dialog
	ADM_commonUI
Message-ID: <200701221923.l0MJNTJk030473@sheep.berlios.de>

Author: mean
Date: 2007-01-22 20:23:29 +0100 (Mon, 22 Jan 2007)
New Revision: 2766

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_postproc.cpp
Removed:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_postproc.cpp
Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/Makefile.am
Log:
dialogFactory for postproc

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_postproc.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_postproc.cpp	2007-01-22 06:47:17 UTC (rev 2765)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_postproc.cpp	2007-01-22 19:23:29 UTC (rev 2766)
@@ -1,181 +0,0 @@
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <unistd.h>
-#include <string.h>
-#include <stdio.h>
-
-#include <gdk/gdkkeysyms.h>
-#include <gtk/gtk.h>
-
-
-#include <gdk/gdkkeysyms.h>
-#include <gtk/gtk.h>
-# include <math.h>
-# include <config.h>
-
-#include "default.h"
-#include "ADM_toolkit_gtk/ADM_gladeSupport.h"
-#include "ADM_toolkit_gtk/toolkit_gtk.h"
-#include "ADM_toolkit_gtk/toolkit_gtk_include.h"
-
-
-static GtkWidget	*create_dialog1 (void);
-
-
-int DIA_getMPParams( uint32_t *pplevel, uint32_t *ppstrength,uint32_t *swap)
-{
-	GtkWidget *dialog;
-	GtkAdjustment *pp_adj;
-	int ret=0;
-
-	dialog=create_dialog1();
-//	gtk_transient(dialog);
-        gtk_register_dialog(dialog);
-#define SET_TOG(x,y) { if(*pplevel & x)  gtk_toggle_button_set_active( GTK_TOGGLE_BUTTON(y),1);    else \
-                                     gtk_toggle_button_set_active( GTK_TOGGLE_BUTTON(y),0); }
-#define GET_TOG(x,y) { if( gtk_toggle_button_get_active( GTK_TOGGLE_BUTTON(y)))   \
-                                *pplevel+=x;     }
-#define WID(x) lookup_widget(dialog,#x)
-
-		pp_adj=gtk_range_get_adjustment (GTK_RANGE (WID(hscale1)));
-
- 		gtk_adjustment_set_value( GTK_ADJUSTMENT(pp_adj),*ppstrength);
-    		SET_TOG(1, WID(Horizontal));
-    		SET_TOG(2,  WID(Vertical));
-     		SET_TOG(4,  WID(Dering));
-		gtk_toggle_button_set_active( GTK_TOGGLE_BUTTON(WID(SwapUV)),*swap);
-
-
-
-	if(gtk_dialog_run(GTK_DIALOG(dialog))==GTK_RESPONSE_OK)
-	{
-
-	         *ppstrength=   (int)floor(GTK_ADJUSTMENT( pp_adj) ->value);
-        	*pplevel=0;
-    		GET_TOG(1, WID(Horizontal));
-    		GET_TOG(2,  WID(Vertical));
-     		GET_TOG(4,  WID(Dering));
-		*swap=gtk_toggle_button_get_active( GTK_TOGGLE_BUTTON(WID(SwapUV)));
-		ret=1;
-	}
-        gtk_unregister_dialog(dialog);
-	gtk_widget_destroy(dialog);
-
-	return ret;
-}
-
-
-GtkWidget*
-create_dialog1 (void)
-{
-  GtkWidget *dialog1;
-  GtkWidget *dialog_vbox1;
-  GtkWidget *vbox1;
-  GtkWidget *Horizontal;
-  GtkWidget *Vertical;
-  GtkWidget *Dering;
-  GtkWidget *vbox2;
-  GtkWidget *SwapUV;
-  GtkWidget *alignment1;
-  GtkWidget *hbox1;
-  GtkWidget *image1;
-  GtkWidget *label2;
-  GtkWidget *label1;
-  GtkWidget *hscale1;
-  GtkWidget *dialog_action_area1;
-  GtkWidget *cancelbutton1;
-  GtkWidget *okbutton1;
-
-  dialog1 = gtk_dialog_new ();
-  gtk_window_set_title (GTK_WINDOW (dialog1), _("Mplayer PostProc options"));
-
-  dialog_vbox1 = GTK_DIALOG (dialog1)->vbox;
-  gtk_widget_show (dialog_vbox1);
-
-  vbox1 = gtk_vbox_new (FALSE, 0);
-  gtk_widget_show (vbox1);
-  gtk_box_pack_start (GTK_BOX (dialog_vbox1), vbox1, TRUE, TRUE, 0);
-
-  Horizontal = gtk_check_button_new_with_mnemonic (_("Horizontal Deblocking"));
-  gtk_widget_show (Horizontal);
-  gtk_box_pack_start (GTK_BOX (vbox1), Horizontal, FALSE, FALSE, 0);
-
-  Vertical = gtk_check_button_new_with_mnemonic (_("Vertical Deblocking"));
-  gtk_widget_show (Vertical);
-  gtk_box_pack_start (GTK_BOX (vbox1), Vertical, FALSE, FALSE, 0);
-
-  Dering = gtk_check_button_new_with_mnemonic (_("Deringing"));
-  gtk_widget_show (Dering);
-  gtk_box_pack_start (GTK_BOX (vbox1), Dering, FALSE, FALSE, 0);
-
-  vbox2 = gtk_vbox_new (FALSE, 0);
-  gtk_widget_show (vbox2);
-  gtk_box_pack_start (GTK_BOX (vbox1), vbox2, TRUE, TRUE, 0);
-
-  SwapUV = gtk_check_button_new ();
-  gtk_widget_show (SwapUV);
-  gtk_box_pack_start (GTK_BOX (vbox2), SwapUV, FALSE, FALSE, 0);
-
-  alignment1 = gtk_alignment_new (0.5, 0.5, 0, 0);
-  gtk_widget_show (alignment1);
-  gtk_container_add (GTK_CONTAINER (SwapUV), alignment1);
-
-  hbox1 = gtk_hbox_new (FALSE, 2);
-  gtk_widget_show (hbox1);
-  gtk_container_add (GTK_CONTAINER (alignment1), hbox1);
-
-  image1 = gtk_image_new_from_stock ("gtk-refresh", GTK_ICON_SIZE_BUTTON);
-  gtk_widget_show (image1);
-  gtk_box_pack_start (GTK_BOX (hbox1), image1, FALSE, FALSE, 0);
-
-  label2 = gtk_label_new_with_mnemonic (_("Swap U & V"));
-  gtk_widget_show (label2);
-  gtk_box_pack_start (GTK_BOX (hbox1), label2, FALSE, FALSE, 0);
-  gtk_label_set_justify (GTK_LABEL (label2), GTK_JUSTIFY_LEFT);
-
-  label1 = gtk_label_new (_("Filter Strength"));
-  gtk_widget_show (label1);
-  gtk_box_pack_start (GTK_BOX (vbox2), label1, FALSE, FALSE, 0);
-  gtk_label_set_justify (GTK_LABEL (label1), GTK_JUSTIFY_LEFT);
-
-  hscale1 = gtk_hscale_new (GTK_ADJUSTMENT (gtk_adjustment_new (5, 0, 5, 1, 1, 0)));
-  gtk_widget_show (hscale1);
-  gtk_box_pack_start (GTK_BOX (vbox1), hscale1, TRUE, TRUE, 0);
-  gtk_scale_set_digits (GTK_SCALE (hscale1), 0);
-
-  dialog_action_area1 = GTK_DIALOG (dialog1)->action_area;
-  gtk_widget_show (dialog_action_area1);
-  gtk_button_box_set_layout (GTK_BUTTON_BOX (dialog_action_area1), GTK_BUTTONBOX_END);
-
-  cancelbutton1 = gtk_button_new_from_stock ("gtk-cancel");
-  gtk_widget_show (cancelbutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), cancelbutton1, GTK_RESPONSE_CANCEL);
-  GTK_WIDGET_SET_FLAGS (cancelbutton1, GTK_CAN_DEFAULT);
-
-  okbutton1 = gtk_button_new_from_stock ("gtk-ok");
-  gtk_widget_show (okbutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), okbutton1, GTK_RESPONSE_OK);
-  GTK_WIDGET_SET_FLAGS (okbutton1, GTK_CAN_DEFAULT);
-
-  /* Store pointers to all widgets, for use by lookup_widget(). */
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog1, "dialog1");
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_vbox1, "dialog_vbox1");
-  GLADE_HOOKUP_OBJECT (dialog1, vbox1, "vbox1");
-  GLADE_HOOKUP_OBJECT (dialog1, Horizontal, "Horizontal");
-  GLADE_HOOKUP_OBJECT (dialog1, Vertical, "Vertical");
-  GLADE_HOOKUP_OBJECT (dialog1, Dering, "Dering");
-  GLADE_HOOKUP_OBJECT (dialog1, vbox2, "vbox2");
-  GLADE_HOOKUP_OBJECT (dialog1, SwapUV, "SwapUV");
-  GLADE_HOOKUP_OBJECT (dialog1, alignment1, "alignment1");
-  GLADE_HOOKUP_OBJECT (dialog1, hbox1, "hbox1");
-  GLADE_HOOKUP_OBJECT (dialog1, image1, "image1");
-  GLADE_HOOKUP_OBJECT (dialog1, label2, "label2");
-  GLADE_HOOKUP_OBJECT (dialog1, label1, "label1");
-  GLADE_HOOKUP_OBJECT (dialog1, hscale1, "hscale1");
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_action_area1, "dialog_action_area1");
-  GLADE_HOOKUP_OBJECT (dialog1, cancelbutton1, "cancelbutton1");
-  GLADE_HOOKUP_OBJECT (dialog1, okbutton1, "okbutton1");
-
-  return dialog1;
-}
-

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am	2007-01-22 06:47:17 UTC (rev 2765)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am	2007-01-22 19:23:29 UTC (rev 2766)
@@ -12,7 +12,7 @@
 	DIA_properties.cpp DIA_mjpeg.cpp DIA_about.cpp DIA_recent.cpp \
 	DIA_indexer.cpp DIA_resize.cpp DIA_working.cpp \
 	DIA_working.h DIA_busy.cpp DIA_busy.h DIA_exLame.cpp DIA_pipe.cpp DIA_mpeg2opt.cpp \
-	DIA_postproc.cpp DIA_enter.cpp DIA_enter.h DIA_xvcd.cpp DIA_muxer.cpp \
+	DIA_enter.cpp DIA_enter.h DIA_xvcd.cpp DIA_muxer.cpp \
 	DIA_xvid.cpp DIA_crop.cpp DIA_color.cpp DIA_encoding.cpp DIA_SVCD.cpp DIA_prefs.cpp \
 	DIA_requant.cpp DIA_xvid4.cpp DIA_lavcodec.cpp \
 	DIA_pause.cpp \
@@ -50,7 +50,7 @@
 DIA_asharp.cpp       DIA_idx_pg.cpp       DIA_partial.cpp     DIA_vobsub.cpp \
 DIA_audio.cpp        DIA_idx_pg.h         DIA_pause.cpp       DIA_vorbis.cpp \
 DIA_audioTrack.cpp   DIA_indexer.cpp      DIA_pipe.cpp        DIA_working.cpp \
-DIA_defaultAudio.cpp  DIA_jobs.cpp         DIA_postproc.cpp    DIA_working.h \
+DIA_defaultAudio.cpp  DIA_jobs.cpp        DIA_working.h \
 DIA_jobs_save.cpp    DIA_prefs.cpp       DIA_x264.cpp \
 DIA_preview.cpp     DIA_xvcd.cpp \
 DIA_busy.cpp         DIA_dmx.cpp           DIA_lame.cpp         DIA_properties.cpp  DIA_xvid.cpp \

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp	2007-01-22 06:47:17 UTC (rev 2765)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp	2007-01-22 19:23:29 UTC (rev 2766)
@@ -74,7 +74,6 @@
   			 int *shiftvalue, int *drc,int *freqvalue,FILMCONV *filmconv,CHANNEL_CONF *channel) {return 0;}
 
 int DIA_getCropParams(  char *name,CROP_PARAMS *param,AVDMGenericVideoStream *in){return 0;}
-int DIA_getMPParams( uint32_t *pplevel, uint32_t *ppstrength,uint32_t *swap){return 0;}
 #ifdef USE_XX_XVID 
 #include "xvid.h"
 int  DIA_getXvidCompressParams(COMPRESSION_MODE * mode, uint32_t * qz,

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp	2007-01-22 06:47:17 UTC (rev 2765)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp	2007-01-22 19:23:29 UTC (rev 2766)
@@ -74,7 +74,6 @@
   			 int *shiftvalue, int *drc,int *freqvalue,FILMCONV *filmconv,CHANNEL_CONF *channel) {return 0;}
 
 int DIA_getCropParams(  char *name,CROP_PARAMS *param,AVDMGenericVideoStream *in){return 0;}
-int DIA_getMPParams( uint32_t *pplevel, uint32_t *ppstrength,uint32_t *swap){return 0;}
 #ifdef USE_XX_XVID 
 #include "xvid.h"
 int  DIA_getXvidCompressParams(COMPRESSION_MODE * mode, uint32_t * qz,

Added: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_postproc.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_postproc.cpp	2007-01-22 06:47:17 UTC (rev 2765)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_postproc.cpp	2007-01-22 19:23:29 UTC (rev 2766)
@@ -0,0 +1,71 @@
+//
+// C++ Implementation: ADM_vidForcedPP
+//
+// Description: 
+//
+//	Force postprocessing assuming constant quant & image type
+//	Uselefull on some badly authored DVD for example
+//
+// Author: mean <fixounet at free.fr>, (C) 2004
+//
+// Copyright: See COPYING file that comes with this distribution
+//
+//
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ADM_assert.h>
+#include <math.h>
+#include <math.h>
+#include <iconv.h>
+#include "config.h"
+
+
+#include "fourcc.h"
+#include "avio.hxx"
+
+#include "avi_vars.h"
+
+#include "ADM_toolkit/toolkit.hxx"
+
+#include "ADM_userInterfaces/ADM_commonUI/DIA_factory.h"
+
+int DIA_getMPParams( uint32_t *pplevel, uint32_t *ppstrength,uint32_t *swap)
+{
+        
+
+#define PX(x) x
+        
+    diaElemUInteger   postProcStrength(PX(ppstrength),_("_Filter strength:"),0,5);
+    diaElemToggle     swapuv(PX(swap),_("Swap U&V"));
+    
+    uint32_t hzd,vzd,dring;
+    
+#define DOME(x,y) if(*pplevel & x) y=1;else y=0;
+    
+    DOME(1,hzd);
+    DOME(2,vzd);
+    DOME(4,dring);
+    
+     diaElemToggle     fhzd(&hzd,_("_Horizontal deblocking"));
+     diaElemToggle     fvzd(&vzd,_("_Vertical deblocking"));
+     diaElemToggle     fdring(&dring,_("_Deringing"));
+    
+    
+    
+      diaElem *elems[5]={&postProcStrength,&swapuv,&fhzd
+                        ,&fvzd,&fdring};
+
+   if(diaFactoryRun("Postprocessing",5,elems))
+  {
+#undef DOME
+#define DOME(x,y) if(y) *pplevel |=x;
+    *pplevel=0;
+    DOME(1,hzd);
+    DOME(2,vzd);
+    DOME(4,dring);
+    return 1;
+  }
+  return 0;	
+}

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/Makefile.am	2007-01-22 06:47:17 UTC (rev 2765)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/Makefile.am	2007-01-22 19:23:29 UTC (rev 2766)
@@ -1,7 +1,8 @@
 noinst_LIBRARIES = libADM_CommonUI.a 
 libADM_CommonUI_a_METASOURCES = AUTO
-libADM_CommonUI_a_SOURCES = GUI_sdlRender.cpp  GUI_xvRender.cpp  DIA_resizeWiz.cpp DIA_builtin.cpp
+libADM_CommonUI_a_SOURCES = GUI_sdlRender.cpp  GUI_xvRender.cpp  DIA_resizeWiz.cpp DIA_builtin.cpp DIA_postproc.cpp
 
+
 INCLUDES = $(all_includes) $(GTK_CFLAGS) $(XML_CFLAGS)  $(FREETYPE_CFLAGS) -DADM_SUBVERSION=@ADM_SUBVERSION@ \
 		-I./../../ADM_libraries/ADM_utilities \
 		-I./../ADM_commonUI -I../.... -I../..../ADM_libraries/ADM_lavutil \



From mean at mail.berlios.de  Mon Jan 22 20:41:04 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Mon, 22 Jan 2007 20:41:04 +0100
Subject: [Avidemux-svn-commit] r2767 - in
	branches/avidemux_2.4_branch/avidemux: .
	ADM_userInterfaces/ADM_GTK/ADM_dialog
	ADM_userInterfaces/ADM_NONE/ADM_dialog
	ADM_userInterfaces/ADM_QT4/ADM_dialog
	ADM_userInterfaces/ADM_commonUI
Message-ID: <200701221941.l0MJf4fP031941@sheep.berlios.de>

Author: mean
Date: 2007-01-22 20:41:03 +0100 (Mon, 22 Jan 2007)
New Revision: 2767

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_enter.cpp
Removed:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_enter.cpp
Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/alert_none.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/alert_qt4.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/Makefile.am
   branches/avidemux_2.4_branch/avidemux/Makefile.am
Log:
dialog factory for DIA_enter

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_enter.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_enter.cpp	2007-01-22 19:23:29 UTC (rev 2766)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_enter.cpp	2007-01-22 19:41:03 UTC (rev 2767)
@@ -1,343 +0,0 @@
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <unistd.h>
-#include <string.h>
-#include <stdio.h>
-
-#include <gdk/gdkkeysyms.h>
-#include <gtk/gtk.h>
-
-
-#include <gdk/gdkkeysyms.h>
-#include <gtk/gtk.h>
-# include <math.h>
-# include "config.h"
-#include "default.h"
-#include "ADM_toolkit_gtk/ADM_gladeSupport.h"
-#include "ADM_toolkit_gtk/toolkit_gtk.h"
-#include "ADM_toolkit_gtk/toolkit_gtk_include.h"
-
-
-#include "DIA_enter.h"
-static GtkWidget        *create_dialog3 (void);
-static GtkWidget	*create_dialog1 (void);
-static GtkWidget	*create_dialog2 (int mmin, int mmax);
-
-uint8_t  		GUI_getIntegerValue(int *valye, int min, int max, const char *title)
-{
-	return DIA_GetIntegerValue(valye,min,max,title,title);
-}
-uint8_t  DIA_GetIntegerValue(int *value, int min, int max, const char *title, const char *legend)
-{
-
-    	int d;
-    	char *str;
-    	char string[250];
-      	char s[250];
-      	sprintf(s,"%s (%d -- %d)",legend,min,max);
-
-	GtkWidget *dialog;
-	int ret=-1;
-
-	while(ret==-1)
-	{
-		dialog=create_dialog2(min,max);
-		gtk_register_dialog(dialog);
-                gtk_widget_grab_focus (WID(spinbutton1));
-                gtk_widget_grab_default(WID(okbutton1));
-		sprintf(string,"%d",*value);
-
-        	//gtk_entry_set_text(GTK_ENTRY(lookup_widget(dialog,"entry1")),string);
-		gtk_window_set_title (GTK_WINDOW (dialog), title);
-		gtk_label_set_text(GTK_LABEL(lookup_widget(dialog,"label1")),s);
-
-		gtk_spin_button_set_value(GTK_SPIN_BUTTON(WID(spinbutton1)),(gfloat)*value) ;
-		
-		if(gtk_dialog_run(GTK_DIALOG(dialog))==GTK_RESPONSE_OK)
-		{
-			d = (uint32_t) gtk_spin_button_get_value_as_int(
-								GTK_SPIN_BUTTON(WID(spinbutton1)));
-  			if((d>=min) && ( d<=max))
-     				{
-           	 	 	*value=d;
-              			ret= 1;
-	         		}
-			else
-				ret=-1;
-		}
-		else
-			ret=0;
-                gtk_unregister_dialog(dialog);
-                gtk_widget_destroy(dialog);
-	};
-	return ret;
-}
-
-uint8_t  DIA_GetFloatValue(float *value, float min, float max, const char *title, const char *legend)
-{
-
-
-	float d;
-    	char *str;
-    	char string[250];
-      	char s[250];
-        	sprintf(s,"%s (%f -- %f)",legend,min,max);
-
-	GtkWidget *dialog;
-	int ret=-1;
-
-	while(ret==-1)
-	{
-		dialog=create_dialog1();
-		gtk_register_dialog(dialog);
-		sprintf(string,"%f",*value);
-
-        	gtk_entry_set_text(GTK_ENTRY(lookup_widget(dialog,"entry1")),string);
-		gtk_window_set_title (GTK_WINDOW (dialog), title);
-		gtk_label_set_text(GTK_LABEL(lookup_widget(dialog,"legend")),s);
-
-		if(gtk_dialog_run(GTK_DIALOG(dialog))==GTK_RESPONSE_OK)
-		{
-
-  			str = gtk_editable_get_chars(GTK_EDITABLE(lookup_widget(dialog,"entry1")), 0, -1);
-	  		d = atof(str);
-    			if((d>=min) && ( d<=max))
-     				{
-           	 	 	*value=d;
-              			ret= 1;
-	         		}
-			else
-				ret=-1;
-		}
-		else
-			ret=0;
-	gtk_unregister_dialog(dialog);
-	gtk_widget_destroy(dialog);
-	};
-	return ret;
-}
-
-//***************************************************
-uint8_t  DIA_enterString_HIG(const char *title, const char *second, char **outname)
-{
-        int ret=0;
-        GtkWidget *dialog;
-        
-
-        char *alertstring;
-        *outname=NULL;
-     
-        alertstring = g_strconcat("<span size=\"larger\" weight=\"bold\">", title, "</span>\n\n", NULL);
-                
-
-        dialog=create_dialog3();
-        gtk_label_set_text(GTK_LABEL(WID(label1)), alertstring);
-        g_free(alertstring);
-
-        gtk_label_set_text(GTK_LABEL(WID(label2)), second);
-
-        gtk_label_set_use_markup(GTK_LABEL(WID(label1)), TRUE);
-        gtk_register_dialog(dialog);
-
-        if(gtk_dialog_run(GTK_DIALOG(dialog))==GTK_RESPONSE_OK)
-        {
-                ret=1;
-                *outname=ADM_strdup( gtk_editable_get_chars(GTK_EDITABLE ((WID(entry1))), 0, -1));
-        }
-        gtk_unregister_dialog(dialog);
-        gtk_widget_destroy(dialog);
-        UI_purge();
-        return ret;
-}
-//***************************************************
-GtkWidget	*create_dialog1 (void)
-{
-  GtkWidget *dialog1;
-  GtkWidget *dialog_vbox1;
-  GtkWidget *vbox1;
-  GtkWidget *legend;
-  GtkWidget *entry1;
-  GtkWidget *dialog_action_area1;
-  GtkWidget *cancelbutton1;
-  GtkWidget *okbutton1;
-
-  dialog1 = gtk_dialog_new ();
-  gtk_window_set_title (GTK_WINDOW (dialog1), _("Title"));
-
-  dialog_vbox1 = GTK_DIALOG (dialog1)->vbox;
-  gtk_widget_show (dialog_vbox1);
-
-  vbox1 = gtk_vbox_new (FALSE, 0);
-  gtk_widget_show (vbox1);
-  gtk_box_pack_start (GTK_BOX (dialog_vbox1), vbox1, FALSE, FALSE, 0);
-
-  legend = gtk_label_new (_("label1"));
-  gtk_widget_show (legend);
-  gtk_box_pack_start (GTK_BOX (vbox1), legend, FALSE, FALSE, 0);
-  gtk_label_set_justify (GTK_LABEL (legend), GTK_JUSTIFY_LEFT);
-
-  entry1 = gtk_entry_new ();
-  gtk_widget_show (entry1);
-  gtk_box_pack_start (GTK_BOX (vbox1), entry1, FALSE, FALSE, 0);
-
-  dialog_action_area1 = GTK_DIALOG (dialog1)->action_area;
-  gtk_widget_show (dialog_action_area1);
-  gtk_button_box_set_layout (GTK_BUTTON_BOX (dialog_action_area1), GTK_BUTTONBOX_END);
-
-  cancelbutton1 = gtk_button_new_from_stock ("gtk-cancel");
-  gtk_widget_show (cancelbutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), cancelbutton1, GTK_RESPONSE_CANCEL);
-  GTK_WIDGET_SET_FLAGS (cancelbutton1, GTK_CAN_DEFAULT);
-
-  okbutton1 = gtk_button_new_from_stock ("gtk-ok");
-  gtk_widget_show (okbutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), okbutton1, GTK_RESPONSE_OK);
-  GTK_WIDGET_SET_FLAGS (okbutton1, GTK_CAN_DEFAULT);
-
-  /* Store pointers to all widgets, for use by lookup_widget(). */
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog1, "dialog1");
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_vbox1, "dialog_vbox1");
-  GLADE_HOOKUP_OBJECT (dialog1, vbox1, "vbox1");
-  GLADE_HOOKUP_OBJECT (dialog1, legend, "legend");
-  GLADE_HOOKUP_OBJECT (dialog1, entry1, "entry1");
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_action_area1, "dialog_action_area1");
-  GLADE_HOOKUP_OBJECT (dialog1, cancelbutton1, "cancelbutton1");
-  GLADE_HOOKUP_OBJECT (dialog1, okbutton1, "okbutton1");
-
-  return dialog1;
-}
-
-GtkWidget	*create_dialog2 (int mmin, int mmax)
-{
-  GtkWidget *dialog1;
-  GtkWidget *dialog_vbox1;
-  GtkWidget *vbox1;
-  GtkWidget *label1;
-  GtkObject *spinbutton1_adj;
-  GtkWidget *spinbutton1;
-  GtkWidget *dialog_action_area1;
-  GtkWidget *cancelbutton1;
-  GtkWidget *okbutton1;
-
-  dialog1 = gtk_dialog_new ();
-  gtk_window_set_title (GTK_WINDOW (dialog1), _("dialog1"));
-
-  dialog_vbox1 = GTK_DIALOG (dialog1)->vbox;
-  gtk_widget_show (dialog_vbox1);
-
-  vbox1 = gtk_vbox_new (FALSE, 0);
-  gtk_widget_show (vbox1);
-  gtk_box_pack_start (GTK_BOX (dialog_vbox1), vbox1, TRUE, TRUE, 0);
-
-  label1 = gtk_label_new (_("label1"));
-  gtk_widget_show (label1);
-  gtk_box_pack_start (GTK_BOX (vbox1), label1, FALSE, FALSE, 0);
-  gtk_label_set_justify (GTK_LABEL (label1), GTK_JUSTIFY_LEFT);
-
-  spinbutton1_adj = gtk_adjustment_new (1, mmin, mmax, 1, 10, 10);
-  spinbutton1 = gtk_spin_button_new (GTK_ADJUSTMENT (spinbutton1_adj), 1, 0);
-  gtk_widget_show (spinbutton1);
-  gtk_box_pack_start (GTK_BOX (vbox1), spinbutton1, FALSE, FALSE, 0);
-  gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (spinbutton1), TRUE);
-  GTK_WIDGET_UNSET_FLAGS (spinbutton1, GTK_CAN_DEFAULT);
-
-  dialog_action_area1 = GTK_DIALOG (dialog1)->action_area;
-  gtk_widget_show (dialog_action_area1);
-  gtk_button_box_set_layout (GTK_BUTTON_BOX (dialog_action_area1), GTK_BUTTONBOX_END);
-
-  cancelbutton1 = gtk_button_new_from_stock ("gtk-cancel");
-  gtk_widget_show (cancelbutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), cancelbutton1, GTK_RESPONSE_CANCEL);
-  GTK_WIDGET_SET_FLAGS (cancelbutton1, GTK_CAN_DEFAULT);
-
-  okbutton1 = gtk_button_new_from_stock ("gtk-ok");
-  gtk_widget_show (okbutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), okbutton1, GTK_RESPONSE_OK);
-  GTK_WIDGET_SET_FLAGS (okbutton1, GTK_CAN_DEFAULT);
-
-  /* Store pointers to all widgets, for use by lookup_widget(). */
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog1, "dialog1");
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_vbox1, "dialog_vbox1");
-  GLADE_HOOKUP_OBJECT (dialog1, vbox1, "vbox1");
-  GLADE_HOOKUP_OBJECT (dialog1, label1, "label1");
-  GLADE_HOOKUP_OBJECT (dialog1, spinbutton1, "spinbutton1");
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_action_area1, "dialog_action_area1");
-  GLADE_HOOKUP_OBJECT (dialog1, cancelbutton1, "cancelbutton1");
-  GLADE_HOOKUP_OBJECT (dialog1, okbutton1, "okbutton1");
-
-  gtk_widget_grab_focus (okbutton1);
-  gtk_widget_grab_default (okbutton1);
-  return dialog1;
-}
-
-
-GtkWidget *create_dialog3 (void)
-{
-  GtkWidget *dialog3;
-  GtkWidget *dialog_vbox1;
-  GtkWidget *vbox1;
-  GtkWidget *label1;
-  GtkWidget *hbox1;
-  GtkWidget *label2;
-  GtkWidget *entry1;
-  GtkWidget *dialog_action_area1;
-  GtkWidget *cancelbutton1;
-  GtkWidget *okbutton1;
-
-  dialog3 = gtk_dialog_new ();
-  gtk_window_set_type_hint (GTK_WINDOW (dialog3), GDK_WINDOW_TYPE_HINT_DIALOG);
-
-  dialog_vbox1 = GTK_DIALOG (dialog3)->vbox;
-  gtk_widget_show (dialog_vbox1);
-
-  vbox1 = gtk_vbox_new (FALSE, 0);
-  gtk_widget_show (vbox1);
-  gtk_box_pack_start (GTK_BOX (dialog_vbox1), vbox1, TRUE, TRUE, 0);
-
-  label1 = gtk_label_new (_("label1"));
-  gtk_widget_show (label1);
-  gtk_box_pack_start (GTK_BOX (vbox1), label1, TRUE, TRUE, 0);
-
-  hbox1 = gtk_hbox_new (FALSE, 0);
-  gtk_widget_show (hbox1);
-  gtk_box_pack_start (GTK_BOX (vbox1), hbox1, TRUE, TRUE, 0);
-
-  label2 = gtk_label_new (_("label2"));
-  gtk_widget_show (label2);
-  gtk_box_pack_start (GTK_BOX (hbox1), label2, FALSE, FALSE, 0);
-
-  entry1 = gtk_entry_new ();
-  gtk_widget_show (entry1);
-  gtk_box_pack_start (GTK_BOX (hbox1), entry1, TRUE, TRUE, 0);
-  GTK_WIDGET_SET_FLAGS (entry1, GTK_CAN_DEFAULT);
-
-  dialog_action_area1 = GTK_DIALOG (dialog3)->action_area;
-  gtk_widget_show (dialog_action_area1);
-  gtk_button_box_set_layout (GTK_BUTTON_BOX (dialog_action_area1), GTK_BUTTONBOX_END);
-
-  cancelbutton1 = gtk_button_new_from_stock ("gtk-cancel");
-  gtk_widget_show (cancelbutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog3), cancelbutton1, GTK_RESPONSE_CANCEL);
-  GTK_WIDGET_SET_FLAGS (cancelbutton1, GTK_CAN_DEFAULT);
-
-  okbutton1 = gtk_button_new_from_stock ("gtk-ok");
-  gtk_widget_show (okbutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog3), okbutton1, GTK_RESPONSE_OK);
-  GTK_WIDGET_SET_FLAGS (okbutton1, GTK_CAN_DEFAULT);
-
-  /* Store pointers to all widgets, for use by lookup_widget(). */
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog3, dialog3, "dialog3");
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog3, dialog_vbox1, "dialog_vbox1");
-  GLADE_HOOKUP_OBJECT (dialog3, vbox1, "vbox1");
-  GLADE_HOOKUP_OBJECT (dialog3, label1, "label1");
-  GLADE_HOOKUP_OBJECT (dialog3, hbox1, "hbox1");
-  GLADE_HOOKUP_OBJECT (dialog3, label2, "label2");
-  GLADE_HOOKUP_OBJECT (dialog3, entry1, "entry1");
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog3, dialog_action_area1, "dialog_action_area1");
-  GLADE_HOOKUP_OBJECT (dialog3, cancelbutton1, "cancelbutton1");
-  GLADE_HOOKUP_OBJECT (dialog3, okbutton1, "okbutton1");
-
-  gtk_widget_grab_default (okbutton1);
-  return dialog3;
-}
-

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am	2007-01-22 19:23:29 UTC (rev 2766)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am	2007-01-22 19:41:03 UTC (rev 2767)
@@ -12,7 +12,7 @@
 	DIA_properties.cpp DIA_mjpeg.cpp DIA_about.cpp DIA_recent.cpp \
 	DIA_indexer.cpp DIA_resize.cpp DIA_working.cpp \
 	DIA_working.h DIA_busy.cpp DIA_busy.h DIA_exLame.cpp DIA_pipe.cpp DIA_mpeg2opt.cpp \
-	DIA_enter.cpp DIA_enter.h DIA_xvcd.cpp DIA_muxer.cpp \
+	DIA_xvcd.cpp DIA_muxer.cpp \
 	DIA_xvid.cpp DIA_crop.cpp DIA_color.cpp DIA_encoding.cpp DIA_SVCD.cpp DIA_prefs.cpp \
 	DIA_requant.cpp DIA_xvid4.cpp DIA_lavcodec.cpp \
 	DIA_pause.cpp \
@@ -38,9 +38,9 @@
 
 
 
-EXTRA_DIST =  DIA_enter.cpp     \
+EXTRA_DIST =  \
 DIA_mcdeint.cpp     DIA_resize.cpp \
-DIA_cnr2.cpp          DIA_enter.h          DIA_mjpeg.cpp       \
+DIA_cnr2.cpp          DIA_mjpeg.cpp       \
 DIA_DVDff.cpp        DIA_color.cpp         DIA_eq2.cpp          \
 DIA_coloryuv.cpp      DIA_equalizer.cpp    DIA_mpdelogo.cpp    DIA_rotate.cpp \
 DIA_SVCD.cpp         DIA_contrast.cpp      DIA_exLame.cpp       DIA_mpeg2opt.cpp    DIA_srt.cpp \

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp	2007-01-22 19:23:29 UTC (rev 2766)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp	2007-01-22 19:41:03 UTC (rev 2767)
@@ -113,11 +113,7 @@
 int DIA_defaultSettings(ADM_audioEncoderDescriptor *descriptor){return 0;}
 uint8_t getFFCompressParams (COMPRES_PARAMS * incoming) {return 0;}
 uint8_t DIA_quota(char *) {return 0;}
-uint8_t  DIA_GetFloatValue(float *value, float min, float max, const char *title, const char *legend){return 0;}
-uint8_t  DIA_GetIntegerValue(int *value, int min, int max, const char *title, const char *legend){return 0;}
 
-uint8_t  DIA_enterString_HIG(const char *title, const char *second, char **outname){return 0;}
-
 uint8_t  DIA_job_select(char **jobname, char **filename) {return 0;}
 uint8_t DIA_audioTrack(AudioSource *source, uint32_t *track,uint32_t nbTrack, audioInfo *infos){return 0;}
 const char * GUI_getCustomScript(uint32_t nb) {return 0;}

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/alert_none.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/alert_none.cpp	2007-01-22 19:23:29 UTC (rev 2766)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/alert_none.cpp	2007-01-22 19:41:03 UTC (rev 2767)
@@ -242,15 +242,6 @@
   
   return 0; 
 }
-uint8_t  GUI_getIntegerValue(int *valye, int min, int max, const char *title)
-{
- boxStart();
-  boxAdd("INTEGERVALUE stub");
-  boxAdd(title);
-  boxEnd();
-  
-  return 0; 
-}
 
 uint8_t		isQuiet(void)
 {

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp	2007-01-22 19:23:29 UTC (rev 2766)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp	2007-01-22 19:41:03 UTC (rev 2767)
@@ -113,11 +113,7 @@
 int DIA_defaultSettings(ADM_audioEncoderDescriptor *descriptor){return 0;}
 uint8_t getFFCompressParams (COMPRES_PARAMS * incoming) {return 0;}
 uint8_t DIA_quota(char *) {return 0;}
-uint8_t  DIA_GetFloatValue(float *value, float min, float max, const char *title, const char *legend){return 0;}
-uint8_t  DIA_GetIntegerValue(int *value, int min, int max, const char *title, const char *legend){return 0;}
 
-uint8_t  DIA_enterString_HIG(const char *title, const char *second, char **outname){return 0;}
-
 uint8_t  DIA_job_select(char **jobname, char **filename) {return 0;}
 uint8_t DIA_audioTrack(AudioSource *source, uint32_t *track,uint32_t nbTrack, audioInfo *infos){return 0;}
 const char * GUI_getCustomScript(uint32_t nb) {return 0;}

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/alert_qt4.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/alert_qt4.cpp	2007-01-22 19:23:29 UTC (rev 2766)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/alert_qt4.cpp	2007-01-22 19:41:03 UTC (rev 2767)
@@ -228,13 +228,6 @@
   return 0; 
 }
 //****************************************************************************************************
-uint8_t  GUI_getIntegerValue(int *valye, int min, int max, const char *title)
-{
- 
-  
-  return 0; 
-}
-//****************************************************************************************************
 uint8_t		isQuiet(void)
 {
     return beQuiet;

Added: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_enter.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_enter.cpp	2007-01-22 19:23:29 UTC (rev 2766)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_enter.cpp	2007-01-22 19:41:03 UTC (rev 2767)
@@ -0,0 +1,79 @@
+/***************************************************************************
+                          DIA_enter.cpp
+  
+  (C) Mean 2007 fixounet at free.fr
+
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "config.h"
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <string.h>
+#include <stdio.h>
+# include <math.h>
+# include "config.h"
+#include "default.h"
+
+#include "ADM_assert.h"
+
+#include "DIA_enter.h"
+#include "DIA_factory.h"
+
+uint8_t  		GUI_getIntegerValue(int *valye, int min, int max, const char *title)
+{
+	return DIA_GetIntegerValue(valye,min,max,title,title);
+}
+/**
+      \fn DIA_GetIntegerValue( 
+      \brief Popup a window asking for a value between min & max (int)
+      @return 1 on success, 0 on failure
+
+*/
+
+uint8_t  DIA_GetIntegerValue(int *value, int min, int max, const char *title, const char *legend)
+{
+
+    int32_t val=*value;;
+     
+    diaElemInteger     fval(&val,legend,min,max);
+    
+      diaElem *elems[1]={&fval};
+
+   if(diaFactoryRun(title,1,elems))
+  {
+    *value=(int)val;
+    return 1;
+  }
+  return 0;	
+}
+/**
+      \fn DIA_GetFloatValue
+      \brief Popup a window asking for a value between min & max
+      @return 1 on success, 0 on failure
+
+*/
+uint8_t  DIA_GetFloatValue(float *value, float min, float max, const char *title, const char *legend)
+{
+  ELEM_TYPE_FLOAT val=*value;;
+     
+    diaElemFloat     fval(&val,legend,min,max);
+    
+      diaElem *elems[1]={&fval};
+
+   if(diaFactoryRun(title,1,elems))
+  {
+    *value=(float)val;
+    return 1;
+  }
+  return 0;	
+}
+

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/Makefile.am	2007-01-22 19:23:29 UTC (rev 2766)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/Makefile.am	2007-01-22 19:41:03 UTC (rev 2767)
@@ -1,6 +1,6 @@
 noinst_LIBRARIES = libADM_CommonUI.a 
 libADM_CommonUI_a_METASOURCES = AUTO
-libADM_CommonUI_a_SOURCES = GUI_sdlRender.cpp  GUI_xvRender.cpp  DIA_resizeWiz.cpp DIA_builtin.cpp DIA_postproc.cpp
+libADM_CommonUI_a_SOURCES = GUI_sdlRender.cpp  GUI_xvRender.cpp  DIA_resizeWiz.cpp DIA_builtin.cpp DIA_postproc.cpp DIA_enter.cpp
 
 
 INCLUDES = $(all_includes) $(GTK_CFLAGS) $(XML_CFLAGS)  $(FREETYPE_CFLAGS) -DADM_SUBVERSION=@ADM_SUBVERSION@ \

Modified: branches/avidemux_2.4_branch/avidemux/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/Makefile.am	2007-01-22 19:23:29 UTC (rev 2766)
+++ branches/avidemux_2.4_branch/avidemux/Makefile.am	2007-01-22 19:41:03 UTC (rev 2767)
@@ -28,6 +28,7 @@
 user_interface_cli = ./ADM_userInterfaces/ADM_NONE/ADM_gui2/libADM_gui2.a	\
 		./ADM_userInterfaces/ADM_NONE/ADM_dialog/libADM_dialog.a	\
 		./ADM_userInterfaces/ADM_NONE/ADM_dialogFactory/libADM_dialogFactory.a	\
+		./ADM_userInterfaces/ADM_commonUI/libADM_CommonUI.a	\
 		./ADM_userInterfaces/ADM_NONE/ADM_filters/libADM_filters.a 
 		
 		



From mean at mail.berlios.de  Tue Jan 23 20:39:50 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 23 Jan 2007 20:39:50 +0100
Subject: [Avidemux-svn-commit] r2768 - in
	branches/avidemux_2.4_branch/avidemux: ADM_audiofilter
	ADM_userInterfaces/ADM_GTK/ADM_dialog
	ADM_userInterfaces/ADM_NONE/ADM_dialog
	ADM_userInterfaces/ADM_QT4/ADM_dialog
	ADM_userInterfaces/ADM_commonUI
Message-ID: <200701231939.l0NJdoQq016924@sheep.berlios.de>

Author: mean
Date: 2007-01-23 20:39:49 +0100 (Tue, 23 Jan 2007)
New Revision: 2768

Removed:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_defaultAudio.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_lame.cpp
Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_audiofilter/audioencoder_config.h
   branches/avidemux_2.4_branch/avidemux/ADM_audiofilter/audioencoder_faac.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_audiofilter/audioencoder_lame.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/Makefile.am
Log:
dialog for lame/default audio moved to dialogFactory

Modified: branches/avidemux_2.4_branch/avidemux/ADM_audiofilter/audioencoder_config.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_audiofilter/audioencoder_config.h	2007-01-22 19:41:03 UTC (rev 2767)
+++ branches/avidemux_2.4_branch/avidemux/ADM_audiofilter/audioencoder_config.h	2007-01-23 19:39:49 UTC (rev 2768)
@@ -7,8 +7,8 @@
 #include "audioencoder_vorbis_param.h"
 #include "audioencoder_aften_param.h"
 
-extern int DIA_getVorbisSettings(ADM_audioEncoderDescriptor *descriptor);
-extern int DIA_getLameSettings(ADM_audioEncoderDescriptor *descriptor);
+
+
 extern int DIA_defaultSettings(ADM_audioEncoderDescriptor *descriptor);
 /**** Copy ****/
 
@@ -23,6 +23,7 @@
   NULL
 };
 /**** FAAC ****/
+#ifdef USE_FAAC
 FAAC_encoderParam aacParam={128};
 ADM_audioEncoderDescriptor aacDescriptor=
 {
@@ -34,6 +35,7 @@
         sizeof(aacParam),
         &aacParam
 };
+#endif
 /**** LAME ****/
 LAME_encoderParam lameParam=
 {
@@ -41,6 +43,8 @@
   ADM_STEREO,
   2
 };
+#ifdef HAVE_LIBMP3LAME
+extern int DIA_getLameSettings(ADM_audioEncoderDescriptor *descriptor);
 ADM_audioEncoderDescriptor  lameDescriptor=
 {
   AUDIOENC_MP3,
@@ -51,6 +55,7 @@
   sizeof(lameParam),
   &lameParam
 };
+#endif
 /**** TWOLAME ****/
 TWOLAME_encoderParam twolameParam=
 {
@@ -89,6 +94,8 @@
 };
 
 /************** Vorbis **************/
+#ifdef USE_VORBIS
+extern int DIA_getVorbisSettings(ADM_audioEncoderDescriptor *descriptor);
 VORBIS_encoderParam vorbisParam=
 {
   ADM_VORBIS_VBR,
@@ -105,6 +112,7 @@
   sizeof(vorbisParam),
   &vorbisParam
 };
+#endif
 /********** PCM **************/
 ADM_audioEncoderDescriptor  pcmDescriptor=
 {
@@ -147,17 +155,23 @@
 ADM_audioEncoderDescriptor *allDescriptors[]=
 {
       &copyDescriptor,
+#ifdef USE_FAAC
       &aacDescriptor,
+#endif
       &twolameDescriptor,
       &lavcodecAC3Descriptor,
       &lavcodecMP2Descriptor,
+#ifdef USE_VORBIS
       &vorbisDescriptor ,
+#endif      
       &pcmDescriptor,
-      &lpcmDescriptor,
+      &lpcmDescriptor
 #ifdef USE_AFTEN
-      &aftenDescriptor,
-#endif      
-      &lameDescriptor
+      ,&aftenDescriptor
+#endif
+#ifdef HAVE_LIBMP3LAME
+      ,&lameDescriptor
+#endif
 };
 #define NB_AUDIO_DESCRIPTOR (sizeof(allDescriptors)/sizeof(ADM_audioEncoderDescriptor *))
 #endif

Modified: branches/avidemux_2.4_branch/avidemux/ADM_audiofilter/audioencoder_faac.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_audiofilter/audioencoder_faac.cpp	2007-01-22 19:41:03 UTC (rev 2767)
+++ branches/avidemux_2.4_branch/avidemux/ADM_audiofilter/audioencoder_faac.cpp	2007-01-23 19:39:49 UTC (rev 2768)
@@ -82,6 +82,7 @@
 faacEncConfigurationPtr cfg;
 int ret=0;
 
+    printf("[FAAC] Incoming Fq :%u\n",_wavheader->frequency);
      _handle = faacEncOpen(_wavheader->frequency,
                                  _wavheader->channels,
                                  &samples_input,
@@ -220,6 +221,5 @@
         tmphead+=_chunk;
         return 1;
 }
-
 #endif		
 // EOF

Modified: branches/avidemux_2.4_branch/avidemux/ADM_audiofilter/audioencoder_lame.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_audiofilter/audioencoder_lame.cpp	2007-01-22 19:41:03 UTC (rev 2767)
+++ branches/avidemux_2.4_branch/avidemux/ADM_audiofilter/audioencoder_lame.cpp	2007-01-23 19:39:49 UTC (rev 2768)
@@ -189,6 +189,67 @@
         *len=nbout;
         return 1;
 }
+/**
+      \fn DIA_getLameSettings
+      \brief Dialog to set lame settings
+      @return 1 on success, 0 on failure
 
-
+*/
+#include "ADM_userInterfaces/ADM_commonUI/DIA_factory.h"
+int DIA_getLameSettings(ADM_audioEncoderDescriptor *descriptor)
+  {
+    int ret=0;
+    char string[400];
+    uint32_t mmode,ppreset;
+#define SZT(x) sizeof(x)/sizeof(diaMenuEntry )
+#define PX(x) &(lameParam->x)
+    
+    
+    LAME_encoderParam *lameParam;
+    ADM_assert(sizeof(LAME_encoderParam)==descriptor->paramSize);
+  
+    lameParam=(LAME_encoderParam*)descriptor->param;
+    mmode=lameParam->mode;
+    ppreset=lameParam->preset;
+    diaMenuEntry channelMode[]={
+                             {ADM_STEREO,      _("Stereo"),NULL},
+                             {ADM_JSTEREO,   _("Joint stereo"),NULL},
+                             {ADM_MONO,      _("Mono"),NULL}};
+          
+    diaElemMenu menuMode(&mmode,   _("Channel Mode"), SZT(channelMode),channelMode);
+    
+    diaMenuEntry encodingMode[]={
+                             {ADM_LAME_PRESET_CBR,      _("CBR"),NULL},
+                             {ADM_LAME_PRESET_ABR,   _("ABR"),NULL},
+                             {ADM_LAME_PRESET_EXTREME,      _("Extreme"),NULL}}; 
+    diaElemMenu Mode(&ppreset,   _("Mode"), SZT(encodingMode),encodingMode);
+#define BITRATE(x) {x,_(#x)}
+    diaMenuEntry bitrateM[]={
+                              BITRATE(56),
+                              BITRATE(64),
+                              BITRATE(80),
+                              BITRATE(96),
+                              BITRATE(112),
+                              BITRATE(128),
+                              BITRATE(160),
+                              BITRATE(192),
+                              BITRATE(224)
+                          };
+    diaElemMenu bitrate(&(descriptor->bitrate),   _("Bitrate"), SZT(bitrateM),bitrateM);
+    
+    
+    
+    
+    diaElemUInteger quality(PX(quality),_("Quality"),0,9);
+  
+      diaElem *elems[]={&menuMode,&Mode,&quality,&bitrate};
+    
+  if( diaFactoryRun("Lame Settings",4,elems))
+  {
+    lameParam->mode=(ADM_mode)mmode; 
+    lameParam->preset=(ADM_LAME_PRESET)ppreset;
+    return 1;
+  }
+  return 0;
+}  
 #endif

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_defaultAudio.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_defaultAudio.cpp	2007-01-22 19:41:03 UTC (rev 2767)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_defaultAudio.cpp	2007-01-23 19:39:49 UTC (rev 2768)
@@ -1,144 +0,0 @@
-/*
- * DO NOT EDIT THIS FILE - it is generated by Glade.
- */
-# include <config.h>
-
-#include <stdio.h>
-#include <stdlib.h>
-
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <unistd.h>
-#include <string.h>
-
-
-#include <gdk/gdkkeysyms.h>
-#include <gtk/gtk.h>
-#include "ADM_assert.h"
-#include "default.h"
-#include "ADM_toolkit_gtk/ADM_gladeSupport.h"
-#include "ADM_toolkit_gtk/toolkit_gtk.h"
-#include "ADM_toolkit_gtk/toolkit_gtk_include.h"
-
-#include "ADM_assert.h" 
-
-
-#include "ADM_audiofilter/audioeng_buildfilters.h"
-#include "ADM_audiofilter/audioencoder.h"
-#include "ADM_audiofilter/audioencoder_lame_param.h"
-
-
-#define NB_BITRATE 11
-static int BTR[] = {		// see interface.c if you change this !
-		48,
-		56,
-		64,
-		80,
-    		96,
-    		112,
-    		128,
-   		 160,
-    		192,
-   		 224,
-		 384
-};
-  
-
-
- static GtkWidget	*create_dialog1 (void);
- 
- int DIA_defaultSettings(ADM_audioEncoderDescriptor *descriptor)
-  {
-  GtkWidget *dialog;
-  
-  int ret=0;
-  char string[400];
-  GtkComboBox *combo_box;
-
-    dialog=create_dialog1();
-    gtk_window_set_title (GTK_WINDOW (dialog), descriptor->name);
-    gtk_register_dialog(dialog);
-
-        // ******** Set mode****************
-        // *******  set bitrate ************
-        combo_box=GTK_COMBO_BOX(WID(comboboxBitrate));
-        gtk_combo_box_remove_text(combo_box,0);
-        
-        for(unsigned int i=0;i<NB_BITRATE;i++)
-        {
-            sprintf(string,"%d kbits",BTR[i]);
-            gtk_combo_box_append_text(combo_box,string);
-            if(descriptor->bitrate==BTR[i])
-              gtk_combo_box_set_active(combo_box,i);
-        }
-        if(GTK_RESPONSE_OK==gtk_dialog_run(GTK_DIALOG(dialog)))
-        {
-          combo_box=GTK_COMBO_BOX(WID(comboboxBitrate));
-          descriptor->bitrate=BTR[gtk_combo_box_get_active(combo_box)];
-        }
-        gtk_unregister_dialog(dialog);
-        gtk_widget_destroy(dialog);
-        return ret;
-  }
-
-//___________ glade stuff below ____________
-
-  GtkWidget*
-      create_dialog1 (void)
-  {
-    GtkWidget *dialog1;
-    GtkWidget *dialog_vbox1;
-    GtkWidget *hbox1;
-    GtkWidget *label1;
-    GtkWidget *comboboxBitrate;
-    GtkWidget *dialog_action_area1;
-    GtkWidget *cancelbutton1;
-    GtkWidget *okbutton1;
-
-    dialog1 = gtk_dialog_new ();
-    gtk_window_set_title (GTK_WINDOW (dialog1), _("Audio Encoder Settings"));
-    gtk_window_set_type_hint (GTK_WINDOW (dialog1), GDK_WINDOW_TYPE_HINT_DIALOG);
-
-    dialog_vbox1 = GTK_DIALOG (dialog1)->vbox;
-    gtk_widget_show (dialog_vbox1);
-
-    hbox1 = gtk_hbox_new (FALSE, 0);
-    gtk_widget_show (hbox1);
-    gtk_box_pack_start (GTK_BOX (dialog_vbox1), hbox1, FALSE, TRUE, 0);
-
-    label1 = gtk_label_new (_("<b>Bitrate :</b>"));
-    gtk_widget_show (label1);
-    gtk_box_pack_start (GTK_BOX (hbox1), label1, FALSE, FALSE, 0);
-    gtk_label_set_use_markup (GTK_LABEL (label1), TRUE);
-
-    comboboxBitrate = gtk_combo_box_new_text ();
-    gtk_widget_show (comboboxBitrate);
-    gtk_box_pack_start (GTK_BOX (hbox1), comboboxBitrate, TRUE, TRUE, 0);
-
-    dialog_action_area1 = GTK_DIALOG (dialog1)->action_area;
-    gtk_widget_show (dialog_action_area1);
-    gtk_button_box_set_layout (GTK_BUTTON_BOX (dialog_action_area1), GTK_BUTTONBOX_END);
-
-    cancelbutton1 = gtk_button_new_from_stock ("gtk-cancel");
-    gtk_widget_show (cancelbutton1);
-    gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), cancelbutton1, GTK_RESPONSE_CANCEL);
-    GTK_WIDGET_SET_FLAGS (cancelbutton1, GTK_CAN_DEFAULT);
-
-    okbutton1 = gtk_button_new_from_stock ("gtk-ok");
-    gtk_widget_show (okbutton1);
-    gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), okbutton1, GTK_RESPONSE_OK);
-    GTK_WIDGET_SET_FLAGS (okbutton1, GTK_CAN_DEFAULT);
-
-    /* Store pointers to all widgets, for use by lookup_widget(). */
-    GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog1, "dialog1");
-    GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_vbox1, "dialog_vbox1");
-    GLADE_HOOKUP_OBJECT (dialog1, hbox1, "hbox1");
-    GLADE_HOOKUP_OBJECT (dialog1, label1, "label1");
-    GLADE_HOOKUP_OBJECT (dialog1, comboboxBitrate, "comboboxBitrate");
-    GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_action_area1, "dialog_action_area1");
-    GLADE_HOOKUP_OBJECT (dialog1, cancelbutton1, "cancelbutton1");
-    GLADE_HOOKUP_OBJECT (dialog1, okbutton1, "okbutton1");
-
-    return dialog1;
-  }
-

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_lame.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_lame.cpp	2007-01-22 19:41:03 UTC (rev 2767)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_lame.cpp	2007-01-23 19:39:49 UTC (rev 2768)
@@ -1,249 +0,0 @@
-/*
- * DO NOT EDIT THIS FILE - it is generated by Glade.
- */
-# include <config.h>
-
-#include <stdio.h>
-#include <stdlib.h>
-
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <unistd.h>
-#include <string.h>
-
-
-#include <gdk/gdkkeysyms.h>
-#include <gtk/gtk.h>
-#include "ADM_assert.h"
-#include "default.h"
-#include "ADM_toolkit_gtk/ADM_gladeSupport.h"
-#include "ADM_toolkit_gtk/toolkit_gtk.h"
-#include "ADM_toolkit_gtk/toolkit_gtk_include.h"
-
-#include "ADM_assert.h" 
-
-
-#include "ADM_audiofilter/audioeng_buildfilters.h"
-#include "ADM_audiofilter/audioencoder.h"
-#include "ADM_audiofilter/audioencoder_lame_param.h"
-
-
-#define NB_BITRATE 11
-static int BTR[] = {		// see interface.c if you change this !
-		48,
-		56,
-		64,
-		80,
-    		96,
-    		112,
-    		128,
-   		 160,
-    		192,
-   		 224,
-		 384
-};
-  
-
-
- static GtkWidget	*create_dialog1 (void);
- 
- int DIA_getLameSettings(ADM_audioEncoderDescriptor *descriptor)
-  {
-  GtkWidget *dialog;
-  
-  int ret=0;
-  char string[400];
-  GtkComboBox *combo_box;
-
-  LAME_encoderParam *lameParam;
-  ADM_assert(sizeof(LAME_encoderParam)==descriptor->paramSize);
-  
-  lameParam=(LAME_encoderParam*)descriptor->param;
-  
-    dialog=create_dialog1();
-    gtk_register_dialog(dialog);
-
-        // ******** Set mode****************
-        int mindex;
-        mindex=1;
-        switch(lameParam->mode)
-        {
-            case ADM_MONO:mindex=0;break;
-            default:
-            case ADM_STEREO:mindex=1;break;
-            case ADM_JSTEREO:mindex=2;break;	
-        }
-        combo_box=GTK_COMBO_BOX(WID(comboboxMode));
-        gtk_combo_box_set_active(combo_box,mindex);
-        // *******  set bitrate ************
-        combo_box=GTK_COMBO_BOX(WID(comboboxBitrate));
-        gtk_combo_box_remove_text(combo_box,0);
-        
-        for(unsigned int i=0;i<NB_BITRATE;i++)
-        {
-            sprintf(string,"%d kbits",BTR[i]);
-            gtk_combo_box_append_text(combo_box,string);
-            if(descriptor->bitrate==BTR[i])
-              gtk_combo_box_set_active(combo_box,i);
-        }
-        // ******** Set preset ********
-        combo_box=GTK_COMBO_BOX(WID(comboboxPreset));
-        gtk_combo_box_remove_text(combo_box,0);
-        for(unsigned int i=0;i<3;i++)
-        {
-          gtk_combo_box_append_text(combo_box,presetDefinition[i].name);
-          if(lameParam->preset==presetDefinition[i].preset)
-            gtk_combo_box_set_active(combo_box,i);
-        }
-        // ********* Quality ******
-        gtk_spin_button_set_value(GTK_SPIN_BUTTON(WID(spinbuttonQuality)),(gfloat)lameParam->quality) ;
-
-        if(GTK_RESPONSE_OK==gtk_dialog_run(GTK_DIALOG(dialog)))
-        {
-          combo_box=GTK_COMBO_BOX(WID(comboboxBitrate));
-          descriptor->bitrate=BTR[gtk_combo_box_get_active(combo_box)];
-          
-          combo_box=GTK_COMBO_BOX(WID(comboboxPreset));
-          lameParam->preset=presetDefinition[gtk_combo_box_get_active(combo_box)].preset;
-              
-          combo_box=GTK_COMBO_BOX(WID(comboboxMode));
-          switch(gtk_combo_box_get_active(combo_box))
-          {
-            case 0: lameParam->mode=ADM_MONO;break;
-            case 1: lameParam->mode=ADM_STEREO;break;
-            case 2: lameParam->mode=ADM_JSTEREO;break;
-            default : ADM_assert(0);
-          }
-          lameParam->quality=gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(WID(spinbuttonQuality))) ;
-          
-        }
-        gtk_unregister_dialog(dialog);
-        gtk_widget_destroy(dialog);
-        return ret;
-  }
-
-//___________ glade stuff below ____________
-
-  GtkWidget*
-      create_dialog1 (void)
-  {
-    GtkWidget *dialog1;
-    GtkWidget *dialog_vbox1;
-    GtkWidget *table1;
-    GtkObject *spinbuttonQuality_adj;
-    GtkWidget *spinbuttonQuality;
-    GtkWidget *comboboxMode;
-    GtkWidget *comboboxBitrate;
-    GtkWidget *comboboxPreset;
-    GtkWidget *label1;
-    GtkWidget *label2;
-    GtkWidget *label3;
-    GtkWidget *label4;
-    GtkWidget *dialog_action_area1;
-    GtkWidget *cancelbutton1;
-    GtkWidget *okbutton1;
-
-    dialog1 = gtk_dialog_new ();
-    gtk_window_set_title (GTK_WINDOW (dialog1), _("Lame Encoder Settings"));
-    gtk_window_set_type_hint (GTK_WINDOW (dialog1), GDK_WINDOW_TYPE_HINT_DIALOG);
-
-    dialog_vbox1 = GTK_DIALOG (dialog1)->vbox;
-    gtk_widget_show (dialog_vbox1);
-
-    table1 = gtk_table_new (4, 2, FALSE);
-    gtk_widget_show (table1);
-    gtk_box_pack_start (GTK_BOX (dialog_vbox1), table1, TRUE, TRUE, 0);
-
-    spinbuttonQuality_adj = gtk_adjustment_new (1, 0, 9, 1, 10, 10);
-    spinbuttonQuality = gtk_spin_button_new (GTK_ADJUSTMENT (spinbuttonQuality_adj), 1, 0);
-    gtk_widget_show (spinbuttonQuality);
-    gtk_table_attach (GTK_TABLE (table1), spinbuttonQuality, 1, 2, 3, 4,
-                      (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                      (GtkAttachOptions) (0), 0, 0);
-
-    comboboxMode = gtk_combo_box_new_text ();
-    gtk_widget_show (comboboxMode);
-    gtk_table_attach (GTK_TABLE (table1), comboboxMode, 1, 2, 0, 1,
-                      (GtkAttachOptions) (GTK_EXPAND | GTK_SHRINK | GTK_FILL),
-                      (GtkAttachOptions) (GTK_FILL), 0, 0);
-    gtk_combo_box_append_text (GTK_COMBO_BOX (comboboxMode), _("Mono"));
-    gtk_combo_box_append_text (GTK_COMBO_BOX (comboboxMode), _("Stereo"));
-    gtk_combo_box_append_text (GTK_COMBO_BOX (comboboxMode), _("Joint-Stereo"));
-
-    comboboxBitrate = gtk_combo_box_new_text ();
-    gtk_widget_show (comboboxBitrate);
-    gtk_table_attach (GTK_TABLE (table1), comboboxBitrate, 1, 2, 1, 2,
-                      (GtkAttachOptions) (GTK_SHRINK | GTK_FILL),
-                      (GtkAttachOptions) (GTK_FILL), 0, 0);
-
-    comboboxPreset = gtk_combo_box_new_text ();
-    gtk_widget_show (comboboxPreset);
-    gtk_table_attach (GTK_TABLE (table1), comboboxPreset, 1, 2, 2, 3,
-                      (GtkAttachOptions) (GTK_SHRINK | GTK_FILL),
-                      (GtkAttachOptions) (GTK_FILL), 0, 0);
-
-    label1 = gtk_label_new (_("<b>Channel Mode:</b>"));
-    gtk_widget_show (label1);
-    gtk_table_attach (GTK_TABLE (table1), label1, 0, 1, 0, 1,
-                      (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                      (GtkAttachOptions) (0), 0, 0);
-    gtk_label_set_use_markup (GTK_LABEL (label1), TRUE);
-    gtk_misc_set_alignment (GTK_MISC (label1), 0, 0.5);
-
-    label2 = gtk_label_new (_("<b>Bitrate:</b>"));
-    gtk_widget_show (label2);
-    gtk_table_attach (GTK_TABLE (table1), label2, 0, 1, 1, 2,
-                      (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                      (GtkAttachOptions) (0), 0, 0);
-    gtk_label_set_use_markup (GTK_LABEL (label2), TRUE);
-    gtk_misc_set_alignment (GTK_MISC (label2), 0, 0.5);
-
-    label3 = gtk_label_new (_("<b>Mode:</b>"));
-    gtk_widget_show (label3);
-    gtk_table_attach (GTK_TABLE (table1), label3, 0, 1, 2, 3,
-                      (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                      (GtkAttachOptions) (0), 0, 0);
-    gtk_label_set_use_markup (GTK_LABEL (label3), TRUE);
-    gtk_misc_set_alignment (GTK_MISC (label3), 0, 0.5);
-
-    label4 = gtk_label_new (_("<b>Quality:</b>"));
-    gtk_widget_show (label4);
-    gtk_table_attach (GTK_TABLE (table1), label4, 0, 1, 3, 4,
-                      (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                      (GtkAttachOptions) (0), 0, 0);
-    gtk_label_set_use_markup (GTK_LABEL (label4), TRUE);
-    gtk_misc_set_alignment (GTK_MISC (label4), 0, 0.5);
-
-    dialog_action_area1 = GTK_DIALOG (dialog1)->action_area;
-    gtk_widget_show (dialog_action_area1);
-    gtk_button_box_set_layout (GTK_BUTTON_BOX (dialog_action_area1), GTK_BUTTONBOX_END);
-
-    cancelbutton1 = gtk_button_new_from_stock ("gtk-cancel");
-    gtk_widget_show (cancelbutton1);
-    gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), cancelbutton1, GTK_RESPONSE_CANCEL);
-    GTK_WIDGET_SET_FLAGS (cancelbutton1, GTK_CAN_DEFAULT);
-
-    okbutton1 = gtk_button_new_from_stock ("gtk-ok");
-    gtk_widget_show (okbutton1);
-    gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), okbutton1, GTK_RESPONSE_OK);
-    GTK_WIDGET_SET_FLAGS (okbutton1, GTK_CAN_DEFAULT);
-
-    /* Store pointers to all widgets, for use by lookup_widget(). */
-    GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog1, "dialog1");
-    GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_vbox1, "dialog_vbox1");
-    GLADE_HOOKUP_OBJECT (dialog1, table1, "table1");
-    GLADE_HOOKUP_OBJECT (dialog1, spinbuttonQuality, "spinbuttonQuality");
-    GLADE_HOOKUP_OBJECT (dialog1, comboboxMode, "comboboxMode");
-    GLADE_HOOKUP_OBJECT (dialog1, comboboxBitrate, "comboboxBitrate");
-    GLADE_HOOKUP_OBJECT (dialog1, comboboxPreset, "comboboxPreset");
-    GLADE_HOOKUP_OBJECT (dialog1, label1, "label1");
-    GLADE_HOOKUP_OBJECT (dialog1, label2, "label2");
-    GLADE_HOOKUP_OBJECT (dialog1, label3, "label3");
-    GLADE_HOOKUP_OBJECT (dialog1, label4, "label4");
-    GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_action_area1, "dialog_action_area1");
-    GLADE_HOOKUP_OBJECT (dialog1, cancelbutton1, "cancelbutton1");
-    GLADE_HOOKUP_OBJECT (dialog1, okbutton1, "okbutton1");
-
-    return dialog1;
-  }
-

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am	2007-01-22 19:41:03 UTC (rev 2767)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am	2007-01-23 19:39:49 UTC (rev 2768)
@@ -16,7 +16,7 @@
 	DIA_xvid.cpp DIA_crop.cpp DIA_color.cpp DIA_encoding.cpp DIA_SVCD.cpp DIA_prefs.cpp \
 	DIA_requant.cpp DIA_xvid4.cpp DIA_lavcodec.cpp \
 	DIA_pause.cpp \
-	DIA_DVDff.cpp DIA_lavdecoder.cpp DIA_lame.cpp DIA_calculator.cpp DIA_equalizer.cpp \
+	DIA_DVDff.cpp DIA_lavdecoder.cpp DIA_calculator.cpp DIA_equalizer.cpp \
 	DIA_vobsub.cpp DIA_x264.cpp DIA_ocr.cpp  DIA_hue.cpp DIA_eq2.cpp \
 	DIA_asharp.cpp DIA_dmx.cpp DIA_idx_pg.cpp DIA_gototime.cpp \
 	DIA_audioTrack.cpp DIA_cnr2.cpp DIA_jobs.cpp DIA_jobs_save.cpp  \
@@ -31,7 +31,6 @@
 	DIA_coloryuv.cpp \
 	DIA_quota.cpp \
 	DIA_animated.cpp \
-	DIA_defaultAudio.cpp \
 	DIA_partial.cpp \
 	DIA_ass.cpp DIA_bitrateHisto.cpp
 
@@ -53,7 +52,7 @@
 DIA_defaultAudio.cpp  DIA_jobs.cpp        DIA_working.h \
 DIA_jobs_save.cpp    DIA_prefs.cpp       DIA_x264.cpp \
 DIA_preview.cpp     DIA_xvcd.cpp \
-DIA_busy.cpp         DIA_dmx.cpp           DIA_lame.cpp         DIA_properties.cpp  DIA_xvid.cpp \
+DIA_busy.cpp         DIA_dmx.cpp           DIA_properties.cpp  DIA_xvid.cpp \
 DIA_busy.h           DIA_lavcodec.cpp     DIA_quota.cpp       DIA_xvid4.cpp \
 DIA_calculator.cpp   DIA_encoding.cpp      DIA_lavdecoder.cpp   DIA_recent.cpp \
 DIA_chromaShift.cpp  DIA_encoding.h        DIA_lavpp_deint.cpp  DIA_requant.cpp DIA_ass.cpp

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp	2007-01-22 19:41:03 UTC (rev 2767)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp	2007-01-23 19:39:49 UTC (rev 2768)
@@ -109,8 +109,6 @@
 
 //******************************
 int DIA_getVorbisSettings(ADM_audioEncoderDescriptor *descriptor) {return 0;}
-int DIA_getLameSettings(ADM_audioEncoderDescriptor *descriptor){return 0;}
-int DIA_defaultSettings(ADM_audioEncoderDescriptor *descriptor){return 0;}
 uint8_t getFFCompressParams (COMPRES_PARAMS * incoming) {return 0;}
 uint8_t DIA_quota(char *) {return 0;}
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp	2007-01-22 19:41:03 UTC (rev 2767)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp	2007-01-23 19:39:49 UTC (rev 2768)
@@ -109,8 +109,6 @@
 
 //******************************
 int DIA_getVorbisSettings(ADM_audioEncoderDescriptor *descriptor) {return 0;}
-int DIA_getLameSettings(ADM_audioEncoderDescriptor *descriptor){return 0;}
-int DIA_defaultSettings(ADM_audioEncoderDescriptor *descriptor){return 0;}
 uint8_t getFFCompressParams (COMPRES_PARAMS * incoming) {return 0;}
 uint8_t DIA_quota(char *) {return 0;}
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/Makefile.am	2007-01-22 19:41:03 UTC (rev 2767)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/Makefile.am	2007-01-23 19:39:49 UTC (rev 2768)
@@ -1,6 +1,8 @@
 noinst_LIBRARIES = libADM_CommonUI.a 
 libADM_CommonUI_a_METASOURCES = AUTO
-libADM_CommonUI_a_SOURCES = GUI_sdlRender.cpp  GUI_xvRender.cpp  DIA_resizeWiz.cpp DIA_builtin.cpp DIA_postproc.cpp DIA_enter.cpp
+libADM_CommonUI_a_SOURCES = GUI_sdlRender.cpp  GUI_xvRender.cpp  \
+DIA_resizeWiz.cpp DIA_builtin.cpp DIA_postproc.cpp DIA_enter.cpp \
+DIA_audioconfig.cpp
 
 
 INCLUDES = $(all_includes) $(GTK_CFLAGS) $(XML_CFLAGS)  $(FREETYPE_CFLAGS) -DADM_SUBVERSION=@ADM_SUBVERSION@ \



From mean at mail.berlios.de  Tue Jan 23 20:40:31 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 23 Jan 2007 20:40:31 +0100
Subject: [Avidemux-svn-commit] r2769 -
	branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI
Message-ID: <200701231940.l0NJeVWT017004@sheep.berlios.de>

Author: mean
Date: 2007-01-23 20:40:31 +0100 (Tue, 23 Jan 2007)
New Revision: 2769

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_audioconfig.cpp
Log:
new file

Added: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_audioconfig.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_audioconfig.cpp	2007-01-23 19:39:49 UTC (rev 2768)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_audioconfig.cpp	2007-01-23 19:40:31 UTC (rev 2769)
@@ -0,0 +1,67 @@
+/***************************************************************************
+                          DIA_audioConfig.cpp
+  
+  (C) Mean 2007 fixounet at free.fr
+
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "config.h"
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <string.h>
+#include <stdio.h>
+# include <math.h>
+# include "config.h"
+#include "default.h"
+
+#include "ADM_assert.h"
+
+#include "DIA_factory.h"
+#include "../../ADM_audiofilter/audioprocess.hxx"
+#include "../../ADM_audiofilter/audioeng_process.h"
+#include "../../ADM_audiofilter/audioencoder.h"
+
+/**
+      \fn DIA_defaultSettings
+      \brief Dialog to set lame settings
+      @return 1 on success, 0 on failure
+
+*/
+#include "ADM_userInterfaces/ADM_commonUI/DIA_factory.h"
+int DIA_defaultSettings(ADM_audioEncoderDescriptor *descriptor)
+  {
+    int ret=0;
+    char string[400];
+    uint32_t mmode,ppreset;
+#define SZT(x) sizeof(x)/sizeof(diaMenuEntry )
+#define BITRATE(x) {x,_(#x)}
+    diaMenuEntry bitrateM[]={
+                              BITRATE(56),
+                              BITRATE(64),
+                              BITRATE(80),
+                              BITRATE(96),
+                              BITRATE(112),
+                              BITRATE(128),
+                              BITRATE(160),
+                              BITRATE(192),
+                              BITRATE(224),
+                              BITRATE(384)
+                          };
+    diaElemMenu bitrate(&(descriptor->bitrate),   _("Bitrate"), SZT(bitrateM),bitrateM);
+  
+      diaElem *elems[]={&bitrate};
+    
+  return ( diaFactoryRun("Audio Settings",1,elems));
+
+} 
+//EOF 
+



From mean at mail.berlios.de  Wed Jan 24 08:43:37 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 24 Jan 2007 08:43:37 +0100
Subject: [Avidemux-svn-commit] r2770 - in
	branches/avidemux_2.4_branch/avidemux: ADM_audiofilter
	ADM_userInterfaces/ADM_GTK/ADM_dialog
	ADM_userInterfaces/ADM_NONE/ADM_dialog
	ADM_userInterfaces/ADM_QT4/ADM_dialog
Message-ID: <200701240743.l0O7hb1S014983@sheep.berlios.de>

Author: mean
Date: 2007-01-24 08:43:36 +0100 (Wed, 24 Jan 2007)
New Revision: 2770

Removed:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_vorbis.cpp
Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_audiofilter/audioencoder_vorbis.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp
Log:
vorbis switched to dialogFactory

Modified: branches/avidemux_2.4_branch/avidemux/ADM_audiofilter/audioencoder_vorbis.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_audiofilter/audioencoder_vorbis.cpp	2007-01-23 19:40:31 UTC (rev 2769)
+++ branches/avidemux_2.4_branch/avidemux/ADM_audiofilter/audioencoder_vorbis.cpp	2007-01-24 07:43:36 UTC (rev 2770)
@@ -240,5 +240,66 @@
   return 0;
 	
 }
+/**
+      \fn DIA_getLameSettings
+      \brief Dialog to set lame settings
+      @return 1 on success, 0 on failure
+
+*/
+#include "ADM_userInterfaces/ADM_commonUI/DIA_factory.h"
+int DIA_getVorbisSettings(ADM_audioEncoderDescriptor *descriptor)
+  {
+    int ret=0;
+    char string[400];
+    uint32_t mmode,ppreset;
+    ELEM_TYPE_FLOAT qqual;
+#define SZT(x) sizeof(x)/sizeof(diaMenuEntry )
+#define PX(x) &(lameParam->x)
+    
+    
+   VORBIS_encoderParam *vorbisParam;
+  ADM_assert(sizeof(VORBIS_encoderParam)==descriptor->paramSize);
+  vorbisParam=(VORBIS_encoderParam*)descriptor->param;
+  
+    mmode=vorbisParam->mode;
+    qqual=(ELEM_TYPE_FLOAT)vorbisParam->quality;
+    
+    diaMenuEntry channelMode[]={
+                             {ADM_VORBIS_VBR,      _("VBR"),NULL},
+                             {ADM_VORBIS_QUALITY,   _("Quality Based"),NULL}};
+          
+    diaElemMenu menuMode(&mmode,   _("Mode"), SZT(channelMode),channelMode);
+    
+#define BITRATE(x) {x,_(#x)}
+    diaMenuEntry bitrateM[]={
+                              BITRATE(56),
+                              BITRATE(64),
+                              BITRATE(80),
+                              BITRATE(96),
+                              BITRATE(112),
+                              BITRATE(128),
+                              BITRATE(160),
+                              BITRATE(192),
+                              BITRATE(224)
+                          };
+    diaElemMenu bitrate(&(descriptor->bitrate),   _("Bitrate"), SZT(bitrateM),bitrateM);
+    
+    diaElemFloat quality(&qqual,_("Quality"),-1.,10.);
+    
+    
+    
+  
+      diaElem *elems[]={&menuMode,&bitrate,&quality};
+    
+  if( diaFactoryRun("Vorbis Settings",3,elems))
+  {
+    vorbisParam->mode=(ADM_VORBIS_MODE)mmode;
+    vorbisParam->quality=(float)qqual;
+    
+    return 1;
+  }
+  return 0;
+}  
+
 #endif		
 // EOF

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_vorbis.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_vorbis.cpp	2007-01-23 19:40:31 UTC (rev 2769)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_vorbis.cpp	2007-01-24 07:43:36 UTC (rev 2770)
@@ -1,259 +0,0 @@
-
-#include <config.h>
-
-#include <stdio.h>
-#include <stdlib.h>
-
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <unistd.h>
-#include <string.h>
-
-
-#include <gdk/gdkkeysyms.h>
-#include <gtk/gtk.h>
-#include "ADM_assert.h"
-#include "default.h"
-#include "ADM_toolkit_gtk/ADM_gladeSupport.h"
-#include "ADM_toolkit_gtk/toolkit_gtk.h"
-#include "ADM_toolkit_gtk/toolkit_gtk_include.h"
-
-#include "ADM_assert.h" 
-
-
-#include "ADM_audiofilter/audioeng_buildfilters.h"
-#include "ADM_audiofilter/audioencoder.h"
-#include "ADM_audiofilter/audioencoder_vorbis_param.h"
-
-
-
-#define NB_BITRATE 11
-static int BTR[] = {
-		48,
-		56,
-		64,
-		80,
-    		96,
-    		112,
-    		128,
-   		 160,
-    		192,
-   		 224,
-		 384
-};
-  
-static GtkWidget	*create_dialog1 (void);
-#define CHECK_HAS_CHANGED 100
-int DIA_getVorbisSettings(ADM_audioEncoderDescriptor *descriptor)
-{
-  GtkWidget *dialog;
-  
-  int ret=0;
-  char string[400];
-  GtkComboBox *combo_box;
-
-  VORBIS_encoderParam *vorbisParam;
-  ADM_assert(sizeof(VORBIS_encoderParam)==descriptor->paramSize);
-  
-  vorbisParam=(VORBIS_encoderParam*)descriptor->param;
-  
-  dialog=create_dialog1();
-  gtk_register_dialog(dialog);
-
-  //set initial value
-  // *******  set bitrate ************
-  combo_box=GTK_COMBO_BOX(WID(comboboxBitrate));
-  gtk_combo_box_remove_text(combo_box,0);
-        
-  for(unsigned int i=0;i<NB_BITRATE;i++)
-  {
-    sprintf(string,"%d kbits",BTR[i]);
-    gtk_combo_box_append_text(combo_box,string);
-    if(descriptor->bitrate==BTR[i])
-      gtk_combo_box_set_active(combo_box,i);
-  }
-  // set quality
-  gtk_spin_button_set_value(GTK_SPIN_BUTTON(WID(spinbuttonQuality)),(gfloat)vorbisParam->quality) ;
-
-  //
-  int cbr=0;
-  if(vorbisParam->mode==ADM_VORBIS_CBR) 
-  {
-    RADIO_SET(radiobuttonCBR,1);
-    cbr=1;
-  }
-  else
-  {
-      RADIO_SET(radiobuttonVBR,1);
-  }
-
-  gtk_widget_set_sensitive(WID(comboboxBitrate),cbr);
-  gtk_widget_set_sensitive(WID(spinbuttonQuality),cbr^1);
-#define ASSOCIATE(x)   gtk_dialog_add_action_widget (GTK_DIALOG (dialog), WID(x),CHECK_HAS_CHANGED)
-  ASSOCIATE(radiobuttonVBR);
-  ASSOCIATE(radiobuttonCBR);
-
-  int run=1;
-  while(run)
-  {
-  switch(gtk_dialog_run(GTK_DIALOG(dialog)))
-  {
-    case GTK_RESPONSE_OK:
-    combo_box=GTK_COMBO_BOX(WID(comboboxBitrate));
-    descriptor->bitrate=BTR[gtk_combo_box_get_active(combo_box)];
-    vorbisParam->quality=gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(WID(spinbuttonQuality))) ;
-    run=0;
-    cbr=RADIO_GET(radiobuttonCBR);
-    if(cbr)
-    {
-      vorbisParam->mode=ADM_VORBIS_CBR;
-      combo_box=GTK_COMBO_BOX(WID(comboboxBitrate));
-      descriptor->bitrate=BTR[gtk_combo_box_get_active(combo_box)];
-    }else
-    {
-      vorbisParam->mode=ADM_VORBIS_VBR;
-      vorbisParam->quality=gtk_spin_button_get_value(GTK_SPIN_BUTTON(WID(spinbuttonQuality))) ;
-    }
-    break;
-    case CHECK_HAS_CHANGED:
-    {
-      cbr=RADIO_GET(radiobuttonCBR);
-
-      gtk_widget_set_sensitive(WID(comboboxBitrate),cbr);
-      gtk_widget_set_sensitive(WID(spinbuttonQuality),cbr^1);
-    }
-      break;
-    default:
-      run=0;
-      break;
-  }
-  }
-      
-  gtk_unregister_dialog(dialog);
-  gtk_widget_destroy(dialog);
-  return ret;
-  }
-
-  
-  //*******************************************
-
-
-  GtkWidget*
-      create_dialog1 (void)
-  {
-    GtkWidget *dialog1;
-    GtkWidget *dialog_vbox1;
-    GtkWidget *table1;
-    GtkWidget *label1;
-    GtkWidget *label2;
-    GtkWidget *label3;
-    GtkWidget *vbox1;
-    GtkWidget *radiobuttonCBR;
-    GSList *radiobuttonCBR_group = NULL;
-    GtkWidget *radiobuttonVBR;
-    GtkWidget *comboboxBitrate;
-    GtkObject *spinbuttonQuality_adj;
-    GtkWidget *spinbuttonQuality;
-    GtkWidget *dialog_action_area1;
-    GtkWidget *cancelbutton1;
-    GtkWidget *okbutton1;
-
-    dialog1 = gtk_dialog_new ();
-    gtk_window_set_title (GTK_WINDOW (dialog1), _("Vorbis encoder settings"));
-    gtk_window_set_type_hint (GTK_WINDOW (dialog1), GDK_WINDOW_TYPE_HINT_DIALOG);
-
-    dialog_vbox1 = GTK_DIALOG (dialog1)->vbox;
-    gtk_widget_show (dialog_vbox1);
-
-    table1 = gtk_table_new (3, 2, FALSE);
-    gtk_widget_show (table1);
-    gtk_box_pack_start (GTK_BOX (dialog_vbox1), table1, TRUE, TRUE, 0);
-
-    label1 = gtk_label_new (_("<b>Mode :</b>"));
-    gtk_widget_show (label1);
-    gtk_table_attach (GTK_TABLE (table1), label1, 0, 1, 0, 1,
-                      (GtkAttachOptions) (GTK_FILL),
-                      (GtkAttachOptions) (0), 0, 0);
-    gtk_label_set_use_markup (GTK_LABEL (label1), TRUE);
-    gtk_misc_set_alignment (GTK_MISC (label1), 0, 0.5);
-
-    label2 = gtk_label_new (_("<b>Bitrate :</b>"));
-    gtk_widget_show (label2);
-    gtk_table_attach (GTK_TABLE (table1), label2, 0, 1, 1, 2,
-                      (GtkAttachOptions) (GTK_FILL),
-                      (GtkAttachOptions) (0), 0, 0);
-    gtk_label_set_use_markup (GTK_LABEL (label2), TRUE);
-    gtk_misc_set_alignment (GTK_MISC (label2), 0, 0.5);
-
-    label3 = gtk_label_new (_("<b>Quality :</b>"));
-    gtk_widget_show (label3);
-    gtk_table_attach (GTK_TABLE (table1), label3, 0, 1, 2, 3,
-                      (GtkAttachOptions) (GTK_FILL),
-                      (GtkAttachOptions) (0), 0, 0);
-    gtk_label_set_use_markup (GTK_LABEL (label3), TRUE);
-    gtk_misc_set_alignment (GTK_MISC (label3), 0, 0.5);
-
-    vbox1 = gtk_vbox_new (FALSE, 0);
-    gtk_widget_show (vbox1);
-    gtk_table_attach (GTK_TABLE (table1), vbox1, 1, 2, 0, 1,
-                      (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                      (GtkAttachOptions) (GTK_FILL), 0, 0);
-
-    radiobuttonCBR = gtk_radio_button_new_with_mnemonic (NULL, _("CBR (bitrate based)"));
-    gtk_widget_show (radiobuttonCBR);
-    gtk_box_pack_start (GTK_BOX (vbox1), radiobuttonCBR, FALSE, FALSE, 0);
-    gtk_radio_button_set_group (GTK_RADIO_BUTTON (radiobuttonCBR), radiobuttonCBR_group);
-    radiobuttonCBR_group = gtk_radio_button_get_group (GTK_RADIO_BUTTON (radiobuttonCBR));
-
-    radiobuttonVBR = gtk_radio_button_new_with_mnemonic (NULL, _("VBR (Quality based)"));
-    gtk_widget_show (radiobuttonVBR);
-    gtk_box_pack_start (GTK_BOX (vbox1), radiobuttonVBR, FALSE, FALSE, 0);
-    gtk_radio_button_set_group (GTK_RADIO_BUTTON (radiobuttonVBR), radiobuttonCBR_group);
-    radiobuttonCBR_group = gtk_radio_button_get_group (GTK_RADIO_BUTTON (radiobuttonVBR));
-
-    comboboxBitrate = gtk_combo_box_new_text ();
-    gtk_widget_show (comboboxBitrate);
-    gtk_table_attach (GTK_TABLE (table1), comboboxBitrate, 1, 2, 1, 2,
-                      (GtkAttachOptions) (GTK_FILL),
-                      (GtkAttachOptions) (GTK_FILL), 0, 0);
-
-    spinbuttonQuality_adj = gtk_adjustment_new (-1, -1, 10, 1, 1, 1);
-    spinbuttonQuality = gtk_spin_button_new (GTK_ADJUSTMENT (spinbuttonQuality_adj), 1, 1);
-    gtk_widget_show (spinbuttonQuality);
-    gtk_table_attach (GTK_TABLE (table1), spinbuttonQuality, 1, 2, 2, 3,
-                      (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                      (GtkAttachOptions) (0), 0, 0);
-
-    dialog_action_area1 = GTK_DIALOG (dialog1)->action_area;
-    gtk_widget_show (dialog_action_area1);
-    gtk_button_box_set_layout (GTK_BUTTON_BOX (dialog_action_area1), GTK_BUTTONBOX_END);
-
-    cancelbutton1 = gtk_button_new_from_stock ("gtk-cancel");
-    gtk_widget_show (cancelbutton1);
-    gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), cancelbutton1, GTK_RESPONSE_CANCEL);
-    GTK_WIDGET_SET_FLAGS (cancelbutton1, GTK_CAN_DEFAULT);
-
-    okbutton1 = gtk_button_new_from_stock ("gtk-ok");
-    gtk_widget_show (okbutton1);
-    gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), okbutton1, GTK_RESPONSE_OK);
-    GTK_WIDGET_SET_FLAGS (okbutton1, GTK_CAN_DEFAULT);
-
-    /* Store pointers to all widgets, for use by lookup_widget(). */
-    GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog1, "dialog1");
-    GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_vbox1, "dialog_vbox1");
-    GLADE_HOOKUP_OBJECT (dialog1, table1, "table1");
-    GLADE_HOOKUP_OBJECT (dialog1, label1, "label1");
-    GLADE_HOOKUP_OBJECT (dialog1, label2, "label2");
-    GLADE_HOOKUP_OBJECT (dialog1, label3, "label3");
-    GLADE_HOOKUP_OBJECT (dialog1, vbox1, "vbox1");
-    GLADE_HOOKUP_OBJECT (dialog1, radiobuttonCBR, "radiobuttonCBR");
-    GLADE_HOOKUP_OBJECT (dialog1, radiobuttonVBR, "radiobuttonVBR");
-    GLADE_HOOKUP_OBJECT (dialog1, comboboxBitrate, "comboboxBitrate");
-    GLADE_HOOKUP_OBJECT (dialog1, spinbuttonQuality, "spinbuttonQuality");
-    GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_action_area1, "dialog_action_area1");
-    GLADE_HOOKUP_OBJECT (dialog1, cancelbutton1, "cancelbutton1");
-    GLADE_HOOKUP_OBJECT (dialog1, okbutton1, "okbutton1");
-
-    return dialog1;
-  }
-

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am	2007-01-23 19:40:31 UTC (rev 2769)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am	2007-01-24 07:43:36 UTC (rev 2770)
@@ -20,7 +20,7 @@
 	DIA_vobsub.cpp DIA_x264.cpp DIA_ocr.cpp  DIA_hue.cpp DIA_eq2.cpp \
 	DIA_asharp.cpp DIA_dmx.cpp DIA_idx_pg.cpp DIA_gototime.cpp \
 	DIA_audioTrack.cpp DIA_cnr2.cpp DIA_jobs.cpp DIA_jobs_save.cpp  \
-	DIA_v2v.cpp DIA_tdeint.cpp DIA_mpdelogo.cpp DIA_vorbis.cpp \
+	DIA_v2v.cpp DIA_tdeint.cpp DIA_mpdelogo.cpp \
         DIA_chromaShift.cpp \
         \
         DIA_preview.cpp \
@@ -47,7 +47,7 @@
 DIA_acodec.cpp       DIA_crop.cpp          DIA_gototime.cpp     DIA_muxer.cpp       DIA_v2v.cpp \
 DIA_animated.cpp     DIA_hue.cpp          DIA_ocr.cpp         DIA_vcodec.cpp \
 DIA_asharp.cpp       DIA_idx_pg.cpp       DIA_partial.cpp     DIA_vobsub.cpp \
-DIA_audio.cpp        DIA_idx_pg.h         DIA_pause.cpp       DIA_vorbis.cpp \
+DIA_audio.cpp        DIA_idx_pg.h         DIA_pause.cpp       \
 DIA_audioTrack.cpp   DIA_indexer.cpp      DIA_pipe.cpp        DIA_working.cpp \
 DIA_defaultAudio.cpp  DIA_jobs.cpp        DIA_working.h \
 DIA_jobs_save.cpp    DIA_prefs.cpp       DIA_x264.cpp \

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp	2007-01-23 19:40:31 UTC (rev 2769)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp	2007-01-24 07:43:36 UTC (rev 2770)
@@ -108,7 +108,6 @@
 uint8_t DIA_xvid4(COMPRES_PARAMS *incoming){return 0;}
 
 //******************************
-int DIA_getVorbisSettings(ADM_audioEncoderDescriptor *descriptor) {return 0;}
 uint8_t getFFCompressParams (COMPRES_PARAMS * incoming) {return 0;}
 uint8_t DIA_quota(char *) {return 0;}
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp	2007-01-23 19:40:31 UTC (rev 2769)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp	2007-01-24 07:43:36 UTC (rev 2770)
@@ -108,7 +108,6 @@
 uint8_t DIA_xvid4(COMPRES_PARAMS *incoming){return 0;}
 
 //******************************
-int DIA_getVorbisSettings(ADM_audioEncoderDescriptor *descriptor) {return 0;}
 uint8_t getFFCompressParams (COMPRES_PARAMS * incoming) {return 0;}
 uint8_t DIA_quota(char *) {return 0;}
 



From mean at mail.berlios.de  Wed Jan 24 20:32:47 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 24 Jan 2007 20:32:47 +0100
Subject: [Avidemux-svn-commit] r2771 - branches/avidemux_2.4_branch
Message-ID: <200701241932.l0OJWl6U025016@sheep.berlios.de>

Author: mean
Date: 2007-01-24 20:32:46 +0100 (Wed, 24 Jan 2007)
New Revision: 2771

Modified:
   branches/avidemux_2.4_branch/configure.in.in
Log:
fix build on 32 bits

Modified: branches/avidemux_2.4_branch/configure.in.in
===================================================================
--- branches/avidemux_2.4_branch/configure.in.in	2007-01-24 07:43:36 UTC (rev 2770)
+++ branches/avidemux_2.4_branch/configure.in.in	2007-01-24 19:32:46 UTC (rev 2771)
@@ -1152,6 +1152,7 @@
                 AC_DEFINE(HAVE_MMX,1,[post proc])       
                 AC_DEFINE(FPM_INTEL,1,[Mad ])       
 		AC_DEFINE(RUNTIME_CPUDETECT,1,"Let ffmpeg decide which is faster")		
+		AC_DEFINE(ARCH_X86_32,1,"X86_32  assembly")
                 use_mmx=1
 		echo "X86 is ON"
 		;;



From mean at mail.berlios.de  Wed Jan 24 20:43:02 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 24 Jan 2007 20:43:02 +0100
Subject: [Avidemux-svn-commit] r2772 -
	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/i386
Message-ID: <200701241943.l0OJh2vb025606@sheep.berlios.de>

Author: mean
Date: 2007-01-24 20:43:01 +0100 (Wed, 24 Jan 2007)
New Revision: 2772

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/i386/mathops.h
Log:
new file

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/i386/mathops.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/i386/mathops.h	2007-01-24 19:32:46 UTC (rev 2771)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/i386/mathops.h	2007-01-24 19:43:01 UTC (rev 2772)
@@ -0,0 +1,41 @@
+/*
+ * simple math operations
+ * Copyright (c) 2006 Michael Niedermayer <michaelni at gmx.at> et al
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifdef FRAC_BITS
+#   define MULL(ra, rb) \
+        ({ int rt, dummy; asm (\
+            "imull %3               \n\t"\
+            "shrdl %4, %%edx, %%eax \n\t"\
+            : "=a"(rt), "=d"(dummy)\
+            : "a" (ra), "rm" (rb), "i"(FRAC_BITS));\
+         rt; })
+#endif
+
+#define MULH(ra, rb) \
+    ({ int rt, dummy;\
+     asm ("imull %3\n\t" : "=d"(rt), "=a"(dummy): "a" (ra), "rm" (rb));\
+     rt; })
+
+#define MUL64(ra, rb) \
+    ({ int64_t rt;\
+     asm ("imull %2\n\t" : "=A"(rt) : "a" (ra), "g" (rb));\
+     rt; })
+



From mean at mail.berlios.de  Wed Jan 24 20:53:08 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 24 Jan 2007 20:53:08 +0100
Subject: [Avidemux-svn-commit] r2773 -
	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec
Message-ID: <200701241953.l0OJr8G8026174@sheep.berlios.de>

Author: mean
Date: 2007-01-24 20:53:07 +0100 (Wed, 24 Jan 2007)
New Revision: 2773

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/Makefile.am
Log:
register starvation fix

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/Makefile.am	2007-01-24 19:43:01 UTC (rev 2772)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/Makefile.am	2007-01-24 19:53:07 UTC (rev 2773)
@@ -38,7 +38,7 @@
 endif
 EXTEND_AMR=	amr_float/interf_dec.c amr_float/sp_dec.c \
 		amr_float/interf_enc.c amr_float/sp_enc.c
-MYCFLAGS= -I.. -DHAVE_AV_CONFIG_H $(X_MMX_FLAGS) -O3 -Iamr_float -I../.. -I$(LAVUTIL) -Drestrict=__restrict__
+MYCFLAGS= -I.. -DHAVE_AV_CONFIG_H $(X_MMX_FLAGS) -O3 -Iamr_float -I../.. -I$(LAVUTIL) -Drestrict=__restrict__ -fomit-frame-pointer
 # for SSE we need special compil flags
 fft_sse.o:i386/fft_sse.c
 	$(CC) -o $@ $< -c $(MYCFLAGS) $(CFLAGS) $(all_includes) -I..   -msse -I$(LAVUTIL) -I../../..



From mean at mail.berlios.de  Thu Jan 25 08:35:46 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 25 Jan 2007 08:35:46 +0100
Subject: [Avidemux-svn-commit] r2774 - in
	branches/avidemux_2.4_branch/avidemux: . ADM_editor
	ADM_userInterfaces/ADM_GTK/ADM_dialog
	ADM_userInterfaces/ADM_NONE/ADM_dialog
	ADM_userInterfaces/ADM_QT4/ADM_dialog
Message-ID: <200701250735.l0P7ZksS024335@sheep.berlios.de>

Author: mean
Date: 2007-01-25 08:35:45 +0100 (Thu, 25 Jan 2007)
New Revision: 2774

Removed:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_conv.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_dmx.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_indexer.cpp
Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_editor/ADM_edit.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp
   branches/avidemux_2.4_branch/avidemux/main.cpp
Log:
cleanup + locales for win32

Modified: branches/avidemux_2.4_branch/avidemux/ADM_editor/ADM_edit.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_editor/ADM_edit.cpp	2007-01-24 19:53:07 UTC (rev 2773)
+++ branches/avidemux_2.4_branch/avidemux/ADM_editor/ADM_edit.cpp	2007-01-25 07:35:45 UTC (rev 2774)
@@ -1447,7 +1447,6 @@
 //    Try indexing the file, return 1 if file successfully indexed 
 //              0 else
 //_________________________________________
-extern uint8_t DIA_dmx(char *file,DMX_TYPE format,uint32_t nbTracks, MPEG_TRACK *tracks, uint32_t *selectedTracks);
 //
 uint8_t         ADM_Composer::tryIndexing(char *name,char *idxname)
 {

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_conv.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_conv.cpp	2007-01-24 19:53:07 UTC (rev 2773)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_conv.cpp	2007-01-25 07:35:45 UTC (rev 2774)
@@ -1,127 +0,0 @@
-/***************************************************************************
-                          ADM_guiConv.cpp  -  description
-                             -------------------
-    begin                : Sun Nov 24 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include "config.h"
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
-#include <gtk/gtk.h>
-#include <time.h>
-#include <sys/time.h>
-#include <math.h>
-#include <ADM_assert.h>
-
-#include "fourcc.h"
-#include "avio.hxx"
-
-#include "avi_vars.h"
-#include "ADM_toolkit_gtk/toolkit_gtk_include.h"
-#include "ADM_toolkit_gtk/toolkit_gtk.h"
-
-static GtkWidget	*create_dialog1 (void);
-
-#define STOGGLE(x)     gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (lookup_widget(dialog,#x)), TRUE)
-#define GTOGGLE(x)     gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (lookup_widget(dialog,#x)))
-uint8_t  DIA_getLumaChroma(uint32_t *doLuma, uint32_t *doChroma);
-uint8_t  DIA_getLumaChroma(uint32_t *doLuma, uint32_t *doChroma)
-{
-    GtkWidget *dialog;
-    uint8_t ret=0;
-
-    dialog=create_dialog1();
-
-    if(*doLuma) STOGGLE(luma);
-    if(*doChroma) STOGGLE(chroma);
-
-    gtk_register_dialog(dialog);
-    if(gtk_dialog_run(GTK_DIALOG(dialog))==GTK_RESPONSE_OK)
-    {
-
-            *doLuma	= GTOGGLE(luma);
-            *doChroma   = GTOGGLE(chroma);
-            ret=1;
-
-    }
-    gtk_unregister_dialog(dialog);
-    gtk_widget_destroy(dialog);
-    return ret;
-
-}
-
-
-
-
-
-
-GtkWidget	*create_dialog1 (void)
-{
-  GtkWidget *dialog1;
-  GtkWidget *dialog_vbox1;
-  GtkWidget *vbox1;
-  GtkWidget *luma;
-  GtkWidget *chroma;
-  GtkWidget *dialog_action_area1;
-  GtkWidget *cancelbutton1;
-  GtkWidget *okbutton1;
-
-  dialog1 = gtk_dialog_new ();
-  gtk_window_set_title (GTK_WINDOW (dialog1), _("Convolution settings"));
-
-  dialog_vbox1 = GTK_DIALOG (dialog1)->vbox;
-  gtk_widget_show (dialog_vbox1);
-
-  vbox1 = gtk_vbox_new (FALSE, 0);
-  gtk_widget_show (vbox1);
-  gtk_box_pack_start (GTK_BOX (dialog_vbox1), vbox1, TRUE, TRUE, 0);
-
-  luma = gtk_check_button_new_with_mnemonic (_("Luma"));
-  gtk_widget_show (luma);
-  gtk_box_pack_start (GTK_BOX (vbox1), luma, FALSE, FALSE, 0);
-
-  chroma = gtk_check_button_new_with_mnemonic (_("Chroma"));
-  gtk_widget_show (chroma);
-  gtk_box_pack_start (GTK_BOX (vbox1), chroma, FALSE, FALSE, 0);
-
-  dialog_action_area1 = GTK_DIALOG (dialog1)->action_area;
-  gtk_widget_show (dialog_action_area1);
-  gtk_button_box_set_layout (GTK_BUTTON_BOX (dialog_action_area1), GTK_BUTTONBOX_END);
-
-  cancelbutton1 = gtk_button_new_from_stock ("gtk-cancel");
-  gtk_widget_show (cancelbutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), cancelbutton1, GTK_RESPONSE_CANCEL);
-  GTK_WIDGET_SET_FLAGS (cancelbutton1, GTK_CAN_DEFAULT);
-
-  okbutton1 = gtk_button_new_from_stock ("gtk-ok");
-  gtk_widget_show (okbutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), okbutton1, GTK_RESPONSE_OK);
-  GTK_WIDGET_SET_FLAGS (okbutton1, GTK_CAN_DEFAULT);
-
-  /* Store pointers to all widgets, for use by lookup_widget(). */
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog1, "dialog1");
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_vbox1, "dialog_vbox1");
-  GLADE_HOOKUP_OBJECT (dialog1, vbox1, "vbox1");
-  GLADE_HOOKUP_OBJECT (dialog1, luma, "luma");
-  GLADE_HOOKUP_OBJECT (dialog1, chroma, "chroma");
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_action_area1, "dialog_action_area1");
-  GLADE_HOOKUP_OBJECT (dialog1, cancelbutton1, "cancelbutton1");
-  GLADE_HOOKUP_OBJECT (dialog1, okbutton1, "okbutton1");
-
-  return dialog1;
-}
-
-

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_dmx.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_dmx.cpp	2007-01-24 19:53:07 UTC (rev 2773)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_dmx.cpp	2007-01-25 07:35:45 UTC (rev 2774)
@@ -1,271 +0,0 @@
-/***************************************************************************
-                          DIA_dmx.cpp  -  description
-                             -------------------     
-        2nd gen indexer
-                             
-    
-    copyright            : (C) 2005 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <unistd.h>
-#include <string.h>
-#include <stdio.h>
-
-#include <gdk/gdkkeysyms.h>
-#include <gtk/gtk.h>
-
-#include "config.h"
-#include "default.h"
-#include "ADM_toolkit_gtk/toolkit_gtk.h"
-#include "ADM_toolkit_gtk/toolkit_gtk_include.h"
-#include "ADM_toolkit/toolkit.hxx"
-
-#include "ADM_toolkit_gtk/ADM_gladeSupport.h"
-
-#include "ADM_toolkit/toolkit.hxx"
-//___________________________________
-
-
-#include "ADM_video/ADM_genvideo.hxx"
-#include "ADM_encoder/ADM_vidEncode.hxx"
-#include "ADM_encoder/adm_encoder.h"
-
-#include "ADM_toolkit/filesel.h"
-#include "ADM_mpegdemuxer/dmx_identify.h"
-#include "ADM_mpegdemuxer/dmx_demuxer.h"
-
-static GtkWidget *create_dialog1 (void);
-/****************************************************************/
-uint8_t DIA_dmx(char *file,DMX_TYPE format,uint32_t nbTracks, MPEG_TRACK *tracks, uint32_t *selectedTracks)
-{
-GtkWidget *dialog,*optionmenu=NULL,*menu=NULL,*_1;
-uint8_t ret=0;
-char *fmt;
-char str[512];
-        dialog=create_dialog1();
-        gtk_register_dialog(dialog);
-
-        optionmenu=WID(optionmenuAudio);
-        // Fill entry
-        gtk_label_set_text(GTK_LABEL(WID(labelFile)),file);
-        switch(format)
-        {
-                case DMX_MPG_PS:
-                        gtk_label_set_text(GTK_LABEL(WID(labelType)),"Program Stream");
-                        break;
-                case DMX_MPG_TS:
-                        gtk_label_set_text(GTK_LABEL(WID(labelType)),"Transport Stream");
-                        break;
-
-                default: ADM_assert(0);
-        }
-        sprintf(str,"%x (%x)",tracks[0].pes,tracks[0].pid);
-        gtk_label_set_text(GTK_LABEL(WID(labelVideoStream)),str);
-        
-        // Build option menu
-        menu = gtk_menu_new ();
-        uint32_t pes;
-        for(uint32_t i=1;i<nbTracks;i++)
-        {
-                sprintf(str,"???");
-                pes=tracks[i].pes;
-                if(pes<9) sprintf(str,"%d: AC3 :%x channels:%d bitrate:%d kbps",i,pes,tracks[i].channels,tracks[i].bitrate);
-                if(pes>=0xC0 && pes<0xC9) sprintf(str,"%d: MP2  :%x channels:%d bitrate:%d kbps",
-                                                i,pes,tracks[i].channels,tracks[i].bitrate);
-                if(pes>=0xA0 && pes<0xA9) sprintf(str,"%d: LPCM :%x",i,pes);
-                
-                _1 = gtk_image_menu_item_new_with_mnemonic (str);
-                gtk_widget_show (_1);
-                gtk_container_add (GTK_CONTAINER (menu), _1);
-        }
-                        
-        
-        gtk_option_menu_set_menu (GTK_OPTION_MENU (optionmenu), menu);
-        //
-
-        if(gtk_dialog_run(GTK_DIALOG(dialog))==GTK_RESPONSE_OK)
-        {
-                        *selectedTracks=getRangeInMenu(optionmenu);
-                        ret=1;
-
-        }
-        gtk_unregister_dialog(dialog);
-        gtk_widget_destroy(dialog);
-        
-        return ret;
-}
-/****************************************************************/
-GtkWidget *create_dialog1 (void)
-{
-  GtkWidget *dialog1;
-  GtkWidget *dialog_vbox1;
-  GtkWidget *vbox1;
-  GtkWidget *frame1;
-  GtkWidget *table1;
-  GtkWidget *label2;
-  GtkWidget *label3;
-  GtkWidget *label4;
-  GtkWidget *labelFile;
-  GtkWidget *labelType;
-  GtkWidget *labelVideoStream;
-  GtkWidget *label1;
-  GtkWidget *frame2;
-  GtkWidget *hbox1;
-  GtkWidget *label9;
-  GtkWidget *optionmenuAudio;
-  GtkWidget *label8;
-  GtkWidget *hseparator1;
-  GtkWidget *dialog_action_area1;
-  GtkWidget *cancelbutton1;
-  GtkWidget *okbutton1;
-
-  dialog1 = gtk_dialog_new ();
-  gtk_window_set_title (GTK_WINDOW (dialog1), _("Mpeg, Select audio"));
-
-  dialog_vbox1 = GTK_DIALOG (dialog1)->vbox;
-  gtk_widget_show (dialog_vbox1);
-
-  vbox1 = gtk_vbox_new (FALSE, 0);
-  gtk_widget_show (vbox1);
-  gtk_box_pack_start (GTK_BOX (dialog_vbox1), vbox1, TRUE, TRUE, 0);
-
-  frame1 = gtk_frame_new (NULL);
-  gtk_widget_show (frame1);
-  gtk_box_pack_start (GTK_BOX (vbox1), frame1, TRUE, TRUE, 0);
-
-  table1 = gtk_table_new (3, 2, FALSE);
-  gtk_widget_show (table1);
-  gtk_container_add (GTK_CONTAINER (frame1), table1);
-
-  label2 = gtk_label_new (_("File :"));
-  gtk_widget_show (label2);
-  gtk_table_attach (GTK_TABLE (table1), label2, 0, 1, 0, 1,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_label_set_justify (GTK_LABEL (label2), GTK_JUSTIFY_LEFT);
-  gtk_misc_set_alignment (GTK_MISC (label2), 0, 0.5);
-
-  label3 = gtk_label_new (_("Type :"));
-  gtk_widget_show (label3);
-  gtk_table_attach (GTK_TABLE (table1), label3, 0, 1, 1, 2,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_label_set_justify (GTK_LABEL (label3), GTK_JUSTIFY_LEFT);
-  gtk_misc_set_alignment (GTK_MISC (label3), 0, 0.5);
-
-  label4 = gtk_label_new (_("Video stream :"));
-  gtk_widget_show (label4);
-  gtk_table_attach (GTK_TABLE (table1), label4, 0, 1, 2, 3,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_label_set_justify (GTK_LABEL (label4), GTK_JUSTIFY_LEFT);
-  gtk_misc_set_alignment (GTK_MISC (label4), 0, 0.5);
-
-  labelFile = gtk_label_new (_("label5"));
-  gtk_widget_show (labelFile);
-  gtk_table_attach (GTK_TABLE (table1), labelFile, 1, 2, 0, 1,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_label_set_justify (GTK_LABEL (labelFile), GTK_JUSTIFY_LEFT);
-  gtk_misc_set_alignment (GTK_MISC (labelFile), 0, 0.5);
-
-  labelType = gtk_label_new (_("label6"));
-  gtk_widget_show (labelType);
-  gtk_table_attach (GTK_TABLE (table1), labelType, 1, 2, 1, 2,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_label_set_justify (GTK_LABEL (labelType), GTK_JUSTIFY_LEFT);
-  gtk_misc_set_alignment (GTK_MISC (labelType), 0, 0.5);
-
-  labelVideoStream = gtk_label_new (_("label7"));
-  gtk_widget_show (labelVideoStream);
-  gtk_table_attach (GTK_TABLE (table1), labelVideoStream, 1, 2, 2, 3,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_label_set_justify (GTK_LABEL (labelVideoStream), GTK_JUSTIFY_LEFT);
-  gtk_misc_set_alignment (GTK_MISC (labelVideoStream), 0, 0.5);
-
-  label1 = gtk_label_new (_("<b>Input file</b>"));
-  gtk_widget_show (label1);
-  gtk_frame_set_label_widget (GTK_FRAME (frame1), label1);
-  gtk_label_set_use_markup (GTK_LABEL (label1), TRUE);
-  gtk_label_set_justify (GTK_LABEL (label1), GTK_JUSTIFY_LEFT);
-
-  frame2 = gtk_frame_new (NULL);
-  gtk_widget_show (frame2);
-  gtk_box_pack_start (GTK_BOX (vbox1), frame2, TRUE, TRUE, 0);
-
-  hbox1 = gtk_hbox_new (FALSE, 0);
-  gtk_widget_show (hbox1);
-  gtk_container_add (GTK_CONTAINER (frame2), hbox1);
-
-  label9 = gtk_label_new (_("Detected Audio :"));
-  gtk_widget_show (label9);
-  gtk_box_pack_start (GTK_BOX (hbox1), label9, FALSE, FALSE, 0);
-  gtk_label_set_justify (GTK_LABEL (label9), GTK_JUSTIFY_LEFT);
-
-  optionmenuAudio = gtk_option_menu_new ();
-  gtk_widget_show (optionmenuAudio);
-  gtk_box_pack_start (GTK_BOX (hbox1), optionmenuAudio, FALSE, FALSE, 0);
-
-  label8 = gtk_label_new (_("<b>Audio</b>"));
-  gtk_widget_show (label8);
-  gtk_frame_set_label_widget (GTK_FRAME (frame2), label8);
-  gtk_label_set_use_markup (GTK_LABEL (label8), TRUE);
-  gtk_label_set_justify (GTK_LABEL (label8), GTK_JUSTIFY_LEFT);
-
-  hseparator1 = gtk_hseparator_new ();
-  gtk_widget_show (hseparator1);
-  gtk_box_pack_start (GTK_BOX (vbox1), hseparator1, TRUE, TRUE, 0);
-
-  dialog_action_area1 = GTK_DIALOG (dialog1)->action_area;
-  gtk_widget_show (dialog_action_area1);
-  gtk_button_box_set_layout (GTK_BUTTON_BOX (dialog_action_area1), GTK_BUTTONBOX_END);
-
-  cancelbutton1 = gtk_button_new_from_stock ("gtk-cancel");
-  gtk_widget_show (cancelbutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), cancelbutton1, GTK_RESPONSE_CANCEL);
-  GTK_WIDGET_SET_FLAGS (cancelbutton1, GTK_CAN_DEFAULT);
-
-  okbutton1 = gtk_button_new_from_stock ("gtk-ok");
-  gtk_widget_show (okbutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), okbutton1, GTK_RESPONSE_OK);
-  GTK_WIDGET_SET_FLAGS (okbutton1, GTK_CAN_DEFAULT);
-
-  /* Store pointers to all widgets, for use by lookup_widget(). */
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog1, "dialog1");
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_vbox1, "dialog_vbox1");
-  GLADE_HOOKUP_OBJECT (dialog1, vbox1, "vbox1");
-  GLADE_HOOKUP_OBJECT (dialog1, frame1, "frame1");
-  GLADE_HOOKUP_OBJECT (dialog1, table1, "table1");
-  GLADE_HOOKUP_OBJECT (dialog1, label2, "label2");
-  GLADE_HOOKUP_OBJECT (dialog1, label3, "label3");
-  GLADE_HOOKUP_OBJECT (dialog1, label4, "label4");
-  GLADE_HOOKUP_OBJECT (dialog1, labelFile, "labelFile");
-  GLADE_HOOKUP_OBJECT (dialog1, labelType, "labelType");
-  GLADE_HOOKUP_OBJECT (dialog1, labelVideoStream, "labelVideoStream");
-  GLADE_HOOKUP_OBJECT (dialog1, label1, "label1");
-  GLADE_HOOKUP_OBJECT (dialog1, frame2, "frame2");
-  GLADE_HOOKUP_OBJECT (dialog1, hbox1, "hbox1");
-  GLADE_HOOKUP_OBJECT (dialog1, label9, "label9");
-  GLADE_HOOKUP_OBJECT (dialog1, optionmenuAudio, "optionmenuAudio");
-  GLADE_HOOKUP_OBJECT (dialog1, label8, "label8");
-  GLADE_HOOKUP_OBJECT (dialog1, hseparator1, "hseparator1");
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_action_area1, "dialog_action_area1");
-  GLADE_HOOKUP_OBJECT (dialog1, cancelbutton1, "cancelbutton1");
-  GLADE_HOOKUP_OBJECT (dialog1, okbutton1, "okbutton1");
-
-  return dialog1;
-}
-

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_indexer.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_indexer.cpp	2007-01-24 19:53:07 UTC (rev 2773)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_indexer.cpp	2007-01-25 07:35:45 UTC (rev 2774)
@@ -1 +0,0 @@
-// Empty

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am	2007-01-24 19:53:07 UTC (rev 2773)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am	2007-01-25 07:35:45 UTC (rev 2774)
@@ -10,7 +10,7 @@
 
 libADM_dialog_a_SOURCES = DIA_audio.cpp DIA_vcodec.cpp DIA_acodec.cpp \
 	DIA_properties.cpp DIA_mjpeg.cpp DIA_about.cpp DIA_recent.cpp \
-	DIA_indexer.cpp DIA_resize.cpp DIA_working.cpp \
+	DIA_resize.cpp DIA_working.cpp \
 	DIA_working.h DIA_busy.cpp DIA_busy.h DIA_exLame.cpp DIA_pipe.cpp DIA_mpeg2opt.cpp \
 	DIA_xvcd.cpp DIA_muxer.cpp \
 	DIA_xvid.cpp DIA_crop.cpp DIA_color.cpp DIA_encoding.cpp DIA_SVCD.cpp DIA_prefs.cpp \
@@ -18,7 +18,7 @@
 	DIA_pause.cpp \
 	DIA_DVDff.cpp DIA_lavdecoder.cpp DIA_calculator.cpp DIA_equalizer.cpp \
 	DIA_vobsub.cpp DIA_x264.cpp DIA_ocr.cpp  DIA_hue.cpp DIA_eq2.cpp \
-	DIA_asharp.cpp DIA_dmx.cpp DIA_idx_pg.cpp DIA_gototime.cpp \
+	DIA_asharp.cpp  DIA_idx_pg.cpp DIA_gototime.cpp \
 	DIA_audioTrack.cpp DIA_cnr2.cpp DIA_jobs.cpp DIA_jobs_save.cpp  \
 	DIA_v2v.cpp DIA_tdeint.cpp DIA_mpdelogo.cpp \
         DIA_chromaShift.cpp \
@@ -27,7 +27,6 @@
         DIA_contrast.cpp \
         DIA_srt.cpp \
         DIA_rotate.cpp \
-        DIA_conv.cpp \
 	DIA_coloryuv.cpp \
 	DIA_quota.cpp \
 	DIA_animated.cpp \
@@ -43,16 +42,16 @@
 DIA_DVDff.cpp        DIA_color.cpp         DIA_eq2.cpp          \
 DIA_coloryuv.cpp      DIA_equalizer.cpp    DIA_mpdelogo.cpp    DIA_rotate.cpp \
 DIA_SVCD.cpp         DIA_contrast.cpp      DIA_exLame.cpp       DIA_mpeg2opt.cpp    DIA_srt.cpp \
-DIA_about.cpp        DIA_conv.cpp          DIA_tdeint.cpp \
+DIA_about.cpp        DIA_tdeint.cpp \
 DIA_acodec.cpp       DIA_crop.cpp          DIA_gototime.cpp     DIA_muxer.cpp       DIA_v2v.cpp \
 DIA_animated.cpp     DIA_hue.cpp          DIA_ocr.cpp         DIA_vcodec.cpp \
 DIA_asharp.cpp       DIA_idx_pg.cpp       DIA_partial.cpp     DIA_vobsub.cpp \
 DIA_audio.cpp        DIA_idx_pg.h         DIA_pause.cpp       \
-DIA_audioTrack.cpp   DIA_indexer.cpp      DIA_pipe.cpp        DIA_working.cpp \
+DIA_audioTrack.cpp   DIA_pipe.cpp        DIA_working.cpp \
 DIA_defaultAudio.cpp  DIA_jobs.cpp        DIA_working.h \
 DIA_jobs_save.cpp    DIA_prefs.cpp       DIA_x264.cpp \
 DIA_preview.cpp     DIA_xvcd.cpp \
-DIA_busy.cpp         DIA_dmx.cpp           DIA_properties.cpp  DIA_xvid.cpp \
+DIA_busy.cpp         DIA_properties.cpp  DIA_xvid.cpp \
 DIA_busy.h           DIA_lavcodec.cpp     DIA_quota.cpp       DIA_xvid4.cpp \
 DIA_calculator.cpp   DIA_encoding.cpp      DIA_lavdecoder.cpp   DIA_recent.cpp \
 DIA_chromaShift.cpp  DIA_encoding.h        DIA_lavpp_deint.cpp  DIA_requant.cpp DIA_ass.cpp

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp	2007-01-24 19:53:07 UTC (rev 2773)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp	2007-01-25 07:35:45 UTC (rev 2774)
@@ -144,7 +144,6 @@
 uint8_t DIA_dnr(uint32_t *llock,uint32_t *lthresh, uint32_t *clock,
 			uint32_t *cthresh, uint32_t *scene) {return 0;}
 			
-uint8_t  DIA_getLumaChroma(uint32_t *doLuma, uint32_t *doChroma) {return 0;}
 uint8_t DIA_srt(ADMImage *source, SUBCONF *param) {return 0;}			
 			
 			

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp	2007-01-24 19:53:07 UTC (rev 2773)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp	2007-01-25 07:35:45 UTC (rev 2774)
@@ -142,7 +142,6 @@
 uint8_t DIA_dnr(uint32_t *llock,uint32_t *lthresh, uint32_t *clock,
 			uint32_t *cthresh, uint32_t *scene) {return 0;}
 			
-uint8_t  DIA_getLumaChroma(uint32_t *doLuma, uint32_t *doChroma) {return 0;}
 uint8_t DIA_srt(ADMImage *source, SUBCONF *param) {return 0;}			
 			
 			

Modified: branches/avidemux_2.4_branch/avidemux/main.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/main.cpp	2007-01-24 19:53:07 UTC (rev 2773)
+++ branches/avidemux_2.4_branch/avidemux/main.cpp	2007-01-25 07:35:45 UTC (rev 2774)
@@ -119,8 +119,8 @@
     printf(" FreeBSD   : Anish Mistry, amistry at am-productions.biz\n");
 
 
-#if defined( ARCH_X86)  
-      printf("Compiled for X86 Arch.\n");
+#if defined(ARCH_X86_32)
+      printf("Compiled for X86_32 Arch.\n");
 #endif
 #if defined(ARCH_X86_64)
       printf("Compiled for X86_64 Arch.\n");
@@ -133,7 +133,11 @@
 #endif
 #ifdef HAVE_GETTEXT
   char *local=setlocale (LC_ALL, "");
+#ifndef CYG_MANGLING
   bindtextdomain ("avidemux", ADMLOCALE);
+#else
+  bindtextdomain ("avidemux", "./share/locale");
+#endif
   bind_textdomain_codeset ("avidemux", "UTF-8");
   
   if(local)



From mean at mail.berlios.de  Thu Jan 25 20:42:40 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 25 Jan 2007 20:42:40 +0100
Subject: [Avidemux-svn-commit] r2776 -
	branches/avidemux_2.4_branch/avidemux/ADM_libraries
Message-ID: <200701251942.l0PJge8Q003019@sheep.berlios.de>

Author: mean
Date: 2007-01-25 20:42:40 +0100 (Thu, 25 Jan 2007)
New Revision: 2776

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/Makefile.am
Log:
oop

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/Makefile.am	2007-01-25 19:32:06 UTC (rev 2775)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/Makefile.am	2007-01-25 19:42:40 UTC (rev 2776)
@@ -1,4 +1,6 @@
 SUBDIRS= ADM_lavcodec   ADM_lavutil  ADM_libass  ADM_libMpeg2Dec  ADM_libswscale  ADM_lvemux  ADM_utilities   \
-	 ADM_lavformat  ADM_liba52   ADM_libMad  ADM_libmpeg2enc  ADM_libtwolame  ADM_mplex   ADM_xvidratectl
+	 ADM_lavformat  ADM_liba52   ADM_libMad  ADM_libmpeg2enc  ADM_libtwolame  ADM_mplex   ADM_xvidratectl \
+	 ADM_smjs
+	  
 
 



From mean at mail.berlios.de  Thu Jan 25 20:43:29 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 25 Jan 2007 20:43:29 +0100
Subject: [Avidemux-svn-commit] r2777 -
	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs
Message-ID: <200701251943.l0PJhTSO003085@sheep.berlios.de>

Author: mean
Date: 2007-01-25 20:43:28 +0100 (Thu, 25 Jan 2007)
New Revision: 2777

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsopcode.tbl
Log:
new file

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsopcode.tbl
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsopcode.tbl	2007-01-25 19:42:40 UTC (rev 2776)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsopcode.tbl	2007-01-25 19:43:28 UTC (rev 2777)
@@ -0,0 +1,396 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code, released
+ * March 31, 1998.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1998
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+/*
+ * JavaScript operation bytecodes.  If you need to allocate a bytecode, look
+ * for a name of the form JSOP_UNUSED* and claim it.  Otherwise, always add at
+ * the end of the table.
+ *
+ * Includers must define an OPDEF macro of the following form:
+ *
+ * #define OPDEF(op,val,name,image,length,nuses,ndefs,prec,format) ...
+ *
+ * Selected arguments can be expanded in initializers.  The op argument is
+ * expanded followed by comma in the JSOp enum (jsopcode.h), e.g.  The value
+ * field must be dense for now, because jsopcode.c uses an OPDEF() expansion
+ * inside the js_CodeSpec[] initializer.
+ *
+ * Field        Description
+ * op           Bytecode name, which is the JSOp enumerator name
+ * value        Bytecode value, which is the JSOp enumerator value
+ * name         C string containing name for disassembler
+ * image        C string containing "image" for pretty-printer, null if ugly
+ * length       Number of bytes including any immediate operands
+ * nuses        Number of stack slots consumed by bytecode, -1 if variadic
+ * ndefs        Number of stack slots produced by bytecode
+ * prec         Operator precedence, zero if not an operator
+ * format       Bytecode plus immediate operand encoding format
+ *
+ * This file is best viewed with 128 columns:
+12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678
+ */
+
+/* legend: op         val name          image       len use def prec  format */
+
+/* Longstanding JavaScript bytecodes. */
+OPDEF(JSOP_NOP,       0,  "nop",        NULL,         1,  0,  0,  0,  JOF_BYTE)
+OPDEF(JSOP_PUSH,      1,  "push",       NULL,         1,  0,  1,  0,  JOF_BYTE)
+OPDEF(JSOP_POPV,      2,  "popv",       NULL,         1,  1,  0,  0,  JOF_BYTE)
+OPDEF(JSOP_ENTERWITH, 3,  "enterwith",  NULL,         1,  1,  1,  0,  JOF_BYTE)
+OPDEF(JSOP_LEAVEWITH, 4,  "leavewith",  NULL,         1,  1,  0,  0,  JOF_BYTE)
+OPDEF(JSOP_RETURN,    5,  "return",     NULL,         1,  1,  0,  0,  JOF_BYTE)
+OPDEF(JSOP_GOTO,      6,  "goto",       NULL,         3,  0,  0,  0,  JOF_JUMP)
+OPDEF(JSOP_IFEQ,      7,  "ifeq",       NULL,         3,  1,  0,  0,  JOF_JUMP|JOF_DETECTING)
+OPDEF(JSOP_IFNE,      8,  "ifne",       NULL,         3,  1,  0,  0,  JOF_JUMP)
+
+/* Get the arguments object for the current, lightweight function activation. */
+OPDEF(JSOP_ARGUMENTS, 9, js_arguments_str, js_arguments_str, 1, 0, 1, 12, JOF_BYTE)
+
+/* ECMA-compliant for-in loop with argument or local variable loop control. */
+OPDEF(JSOP_FORARG,    10, "forarg",     NULL,         3,  0,  1,  0,  JOF_QARG|JOF_NAME|JOF_FOR)
+OPDEF(JSOP_FORVAR,    11, "forvar",     NULL,         3,  0,  1,  0,  JOF_QVAR|JOF_NAME|JOF_FOR)
+
+/* More longstanding bytecodes. */
+OPDEF(JSOP_DUP,       12, "dup",        NULL,         1,  1,  2,  0,  JOF_BYTE)
+OPDEF(JSOP_DUP2,      13, "dup2",       NULL,         1,  2,  4,  0,  JOF_BYTE)
+OPDEF(JSOP_SETCONST,  14, "setconst",   NULL,         3,  1,  1,  1,  JOF_CONST|JOF_NAME|JOF_SET|JOF_ASSIGNING)
+OPDEF(JSOP_BITOR,     15, "bitor",      "|",          1,  2,  1,  2,  JOF_BYTE|JOF_LEFTASSOC)
+OPDEF(JSOP_BITXOR,    16, "bitxor",     "^",          1,  2,  1,  3,  JOF_BYTE|JOF_LEFTASSOC)
+OPDEF(JSOP_BITAND,    17, "bitand",     "&",          1,  2,  1,  4,  JOF_BYTE|JOF_LEFTASSOC)
+OPDEF(JSOP_EQ,        18, "eq",         "==",         1,  2,  1,  5,  JOF_BYTE|JOF_LEFTASSOC|JOF_DETECTING)
+OPDEF(JSOP_NE,        19, "ne",         "!=",         1,  2,  1,  5,  JOF_BYTE|JOF_LEFTASSOC|JOF_DETECTING)
+OPDEF(JSOP_LT,        20, "lt",         "<",          1,  2,  1,  6,  JOF_BYTE|JOF_LEFTASSOC)
+OPDEF(JSOP_LE,        21, "le",         "<=",         1,  2,  1,  6,  JOF_BYTE|JOF_LEFTASSOC)
+OPDEF(JSOP_GT,        22, "gt",         ">",          1,  2,  1,  6,  JOF_BYTE|JOF_LEFTASSOC)
+OPDEF(JSOP_GE,        23, "ge",         ">=",         1,  2,  1,  6,  JOF_BYTE|JOF_LEFTASSOC)
+OPDEF(JSOP_LSH,       24, "lsh",        "<<",         1,  2,  1,  7,  JOF_BYTE|JOF_LEFTASSOC)
+OPDEF(JSOP_RSH,       25, "rsh",        ">>",         1,  2,  1,  7,  JOF_BYTE|JOF_LEFTASSOC)
+OPDEF(JSOP_URSH,      26, "ursh",       ">>>",        1,  2,  1,  7,  JOF_BYTE|JOF_LEFTASSOC)
+OPDEF(JSOP_ADD,       27, "add",        "+",          1,  2,  1,  8,  JOF_BYTE|JOF_LEFTASSOC)
+OPDEF(JSOP_SUB,       28, "sub",        "-",          1,  2,  1,  8,  JOF_BYTE|JOF_LEFTASSOC)
+OPDEF(JSOP_MUL,       29, "mul",        "*",          1,  2,  1,  9,  JOF_BYTE|JOF_LEFTASSOC)
+OPDEF(JSOP_DIV,       30, "div",        "/",          1,  2,  1,  9,  JOF_BYTE|JOF_LEFTASSOC)
+OPDEF(JSOP_MOD,       31, "mod",        "%",          1,  2,  1,  9,  JOF_BYTE|JOF_LEFTASSOC)
+OPDEF(JSOP_NOT,       32, "not",        "!",          1,  1,  1, 10,  JOF_BYTE|JOF_DETECTING)
+OPDEF(JSOP_BITNOT,    33, "bitnot",     "~",          1,  1,  1, 10,  JOF_BYTE)
+OPDEF(JSOP_NEG,       34, "neg",        "-",          1,  1,  1, 10,  JOF_BYTE)
+OPDEF(JSOP_NEW,       35, js_new_str,   NULL,         3, -1,  1, 10,  JOF_UINT16)
+OPDEF(JSOP_DELNAME,   36, "delname",    NULL,         3,  0,  1, 10,  JOF_CONST|JOF_NAME|JOF_DEL)
+OPDEF(JSOP_DELPROP,   37, "delprop",    NULL,         3,  1,  1, 10,  JOF_CONST|JOF_PROP|JOF_DEL)
+OPDEF(JSOP_DELELEM,   38, "delelem",    NULL,         1,  2,  1, 10,  JOF_BYTE |JOF_ELEM|JOF_DEL)
+OPDEF(JSOP_TYPEOF,    39, js_typeof_str,NULL,         1,  1,  1, 10,  JOF_BYTE|JOF_DETECTING)
+OPDEF(JSOP_VOID,      40, js_void_str,  NULL,         1,  1,  1, 10,  JOF_BYTE)
+OPDEF(JSOP_INCNAME,   41, "incname",    NULL,         3,  0,  1, 10,  JOF_CONST|JOF_NAME|JOF_INC)
+OPDEF(JSOP_INCPROP,   42, "incprop",    NULL,         3,  1,  1, 10,  JOF_CONST|JOF_PROP|JOF_INC)
+OPDEF(JSOP_INCELEM,   43, "incelem",    NULL,         1,  2,  1, 10,  JOF_BYTE |JOF_ELEM|JOF_INC)
+OPDEF(JSOP_DECNAME,   44, "decname",    NULL,         3,  0,  1, 10,  JOF_CONST|JOF_NAME|JOF_DEC)
+OPDEF(JSOP_DECPROP,   45, "decprop",    NULL,         3,  1,  1, 10,  JOF_CONST|JOF_PROP|JOF_DEC)
+OPDEF(JSOP_DECELEM,   46, "decelem",    NULL,         1,  2,  1, 10,  JOF_BYTE |JOF_ELEM|JOF_DEC)
+OPDEF(JSOP_NAMEINC,   47, "nameinc",    NULL,         3,  0,  1, 10,  JOF_CONST|JOF_NAME|JOF_INC|JOF_POST)
+OPDEF(JSOP_PROPINC,   48, "propinc",    NULL,         3,  1,  1, 10,  JOF_CONST|JOF_PROP|JOF_INC|JOF_POST)
+OPDEF(JSOP_ELEMINC,   49, "eleminc",    NULL,         1,  2,  1, 10,  JOF_BYTE |JOF_ELEM|JOF_INC|JOF_POST)
+OPDEF(JSOP_NAMEDEC,   50, "namedec",    NULL,         3,  0,  1, 10,  JOF_CONST|JOF_NAME|JOF_DEC|JOF_POST)
+OPDEF(JSOP_PROPDEC,   51, "propdec",    NULL,         3,  1,  1, 10,  JOF_CONST|JOF_PROP|JOF_DEC|JOF_POST)
+OPDEF(JSOP_ELEMDEC,   52, "elemdec",    NULL,         1,  2,  1, 10,  JOF_BYTE |JOF_ELEM|JOF_DEC|JOF_POST)
+OPDEF(JSOP_GETPROP,   53, "getprop",    NULL,         3,  1,  1, 11,  JOF_CONST|JOF_PROP)
+OPDEF(JSOP_SETPROP,   54, "setprop",    NULL,         3,  2,  1,  1,  JOF_CONST|JOF_PROP|JOF_SET|JOF_ASSIGNING|JOF_DETECTING)
+OPDEF(JSOP_GETELEM,   55, "getelem",    NULL,         1,  2,  1, 11,  JOF_BYTE |JOF_ELEM|JOF_LEFTASSOC)
+OPDEF(JSOP_SETELEM,   56, "setelem",    NULL,         1,  3,  1,  1,  JOF_BYTE |JOF_ELEM|JOF_SET|JOF_ASSIGNING|JOF_DETECTING)
+OPDEF(JSOP_PUSHOBJ,   57, "pushobj",    NULL,         1,  0,  1,  0,  JOF_BYTE)
+OPDEF(JSOP_CALL,      58, "call",       NULL,         3, -1,  1, 11,  JOF_UINT16)
+OPDEF(JSOP_NAME,      59, "name",       NULL,         3,  0,  1, 12,  JOF_CONST|JOF_NAME)
+OPDEF(JSOP_NUMBER,    60, "number",     NULL,         3,  0,  1, 12,  JOF_CONST)
+OPDEF(JSOP_STRING,    61, "string",     NULL,         3,  0,  1, 12,  JOF_CONST)
+OPDEF(JSOP_ZERO,      62, "zero",       "0",          1,  0,  1, 12,  JOF_BYTE)
+OPDEF(JSOP_ONE,       63, "one",        "1",          1,  0,  1, 12,  JOF_BYTE)
+OPDEF(JSOP_NULL,      64, js_null_str,  js_null_str,  1,  0,  1, 12,  JOF_BYTE)
+OPDEF(JSOP_THIS,      65, js_this_str,  js_this_str,  1,  0,  1, 12,  JOF_BYTE)
+OPDEF(JSOP_FALSE,     66, js_false_str, js_false_str, 1,  0,  1, 12,  JOF_BYTE)
+OPDEF(JSOP_TRUE,      67, js_true_str,  js_true_str,  1,  0,  1, 12,  JOF_BYTE)
+OPDEF(JSOP_OR,        68, "or",         NULL,         3,  1,  0,  0,  JOF_JUMP|JOF_DETECTING)
+OPDEF(JSOP_AND,       69, "and",        NULL,         3,  1,  0,  0,  JOF_JUMP|JOF_DETECTING)
+
+/* The switch bytecodes have variable length. */
+OPDEF(JSOP_TABLESWITCH,  70, "tableswitch",  NULL,   -1,  1,  0,  0,  JOF_TABLESWITCH|JOF_DETECTING)
+OPDEF(JSOP_LOOKUPSWITCH, 71, "lookupswitch", NULL,   -1,  1,  0,  0,  JOF_LOOKUPSWITCH|JOF_DETECTING)
+
+/* New, infallible/transitive identity ops. */
+OPDEF(JSOP_NEW_EQ,    72, "eq",         NULL,         1,  2,  1,  5,  JOF_BYTE|JOF_DETECTING)
+OPDEF(JSOP_NEW_NE,    73, "ne",         NULL,         1,  2,  1,  5,  JOF_BYTE|JOF_DETECTING)
+
+/* Lexical closure constructor. */
+OPDEF(JSOP_CLOSURE,   74, "closure",    NULL,         3,  0,  0,  0,  JOF_CONST)
+
+/* Export and import ops. */
+OPDEF(JSOP_EXPORTALL, 75, "exportall",  NULL,         1,  0,  0,  0,  JOF_BYTE)
+OPDEF(JSOP_EXPORTNAME,76, "exportname", NULL,         3,  0,  0,  0,  JOF_CONST|JOF_NAME)
+OPDEF(JSOP_IMPORTALL, 77, "importall",  NULL,         1,  1,  0,  0,  JOF_BYTE)
+OPDEF(JSOP_IMPORTPROP,78, "importprop", NULL,         3,  1,  0,  0,  JOF_CONST|JOF_PROP|JOF_IMPORT)
+OPDEF(JSOP_IMPORTELEM,79, "importelem", NULL,         1,  2,  0,  0,  JOF_BYTE |JOF_ELEM|JOF_IMPORT)
+
+/* Push object literal. */
+OPDEF(JSOP_OBJECT,    80, "object",     NULL,         3,  0,  1, 12,  JOF_CONST)
+
+/* Pop value and discard it. */
+OPDEF(JSOP_POP,       81, "pop",        NULL,         1,  1,  0,  0,  JOF_BYTE)
+
+/* Convert value to number, for unary +. */
+OPDEF(JSOP_POS,       82, "pos",        "+",          1,  1,  1, 10,  JOF_BYTE)
+
+/* Trap into debugger for breakpoint, etc. */
+OPDEF(JSOP_TRAP,      83, "trap",       NULL,         1,  0,  0,  0,  JOF_BYTE)
+
+/* Fast get/set ops for function arguments and local variables. */
+OPDEF(JSOP_GETARG,    84, "getarg",     NULL,         3,  0,  1, 12,  JOF_QARG |JOF_NAME)
+OPDEF(JSOP_SETARG,    85, "setarg",     NULL,         3,  1,  1,  1,  JOF_QARG |JOF_NAME|JOF_SET|JOF_ASSIGNING)
+OPDEF(JSOP_GETVAR,    86, "getvar",     NULL,         3,  0,  1, 12,  JOF_QVAR |JOF_NAME)
+OPDEF(JSOP_SETVAR,    87, "setvar",     NULL,         3,  1,  1,  1,  JOF_QVAR |JOF_NAME|JOF_SET|JOF_ASSIGNING|JOF_DETECTING)
+
+/* Push unsigned 16-bit int constant. */
+OPDEF(JSOP_UINT16,    88, "uint16",     NULL,         3,  0,  1, 12,  JOF_UINT16)
+
+/* Object and array literal support. */
+OPDEF(JSOP_NEWINIT,   89, "newinit",    NULL,         1,  2,  1, 10,  JOF_BYTE)
+OPDEF(JSOP_ENDINIT,   90, "endinit",    NULL,         1,  0,  0,  0,  JOF_BYTE)
+OPDEF(JSOP_INITPROP,  91, "initprop",   NULL,         3,  1,  0,  0,  JOF_CONST|JOF_PROP|JOF_DETECTING)
+OPDEF(JSOP_INITELEM,  92, "initelem",   NULL,         1,  2,  0,  0,  JOF_BYTE |JOF_ELEM|JOF_DETECTING)
+OPDEF(JSOP_DEFSHARP,  93, "defsharp",   NULL,         3,  0,  0,  0,  JOF_UINT16)
+OPDEF(JSOP_USESHARP,  94, "usesharp",   NULL,         3,  0,  1,  0,  JOF_UINT16)
+
+/* Fast inc/dec ops for args and local vars. */
+OPDEF(JSOP_INCARG,    95, "incarg",     NULL,         3,  0,  1, 10,  JOF_QARG |JOF_NAME|JOF_INC)
+OPDEF(JSOP_INCVAR,    96, "incvar",     NULL,         3,  0,  1, 10,  JOF_QVAR |JOF_NAME|JOF_INC)
+OPDEF(JSOP_DECARG,    97, "decarg",     NULL,         3,  0,  1, 10,  JOF_QARG |JOF_NAME|JOF_DEC)
+OPDEF(JSOP_DECVAR,    98, "decvar",     NULL,         3,  0,  1, 10,  JOF_QVAR |JOF_NAME|JOF_DEC)
+OPDEF(JSOP_ARGINC,    99, "arginc",     NULL,         3,  0,  1, 10,  JOF_QARG |JOF_NAME|JOF_INC|JOF_POST)
+OPDEF(JSOP_VARINC,    100,"varinc",     NULL,         3,  0,  1, 10,  JOF_QVAR |JOF_NAME|JOF_INC|JOF_POST)
+OPDEF(JSOP_ARGDEC,    101,"argdec",     NULL,         3,  0,  1, 10,  JOF_QARG |JOF_NAME|JOF_DEC|JOF_POST)
+OPDEF(JSOP_VARDEC,    102,"vardec",     NULL,         3,  0,  1, 10,  JOF_QVAR |JOF_NAME|JOF_DEC|JOF_POST)
+
+/* ECMA-compliant for/in ops. */
+OPDEF(JSOP_TOOBJECT,  103,"toobject",   NULL,         1,  1,  1,  0,  JOF_BYTE)
+OPDEF(JSOP_FORNAME,   104,"forname",    NULL,         3,  0,  1,  0,  JOF_CONST|JOF_NAME|JOF_FOR)
+OPDEF(JSOP_FORPROP,   105,"forprop",    NULL,         3,  1,  1,  0,  JOF_CONST|JOF_PROP|JOF_FOR)
+OPDEF(JSOP_FORELEM,   106,"forelem",    NULL,         1,  2,  4,  0,  JOF_BYTE |JOF_ELEM|JOF_FOR)
+OPDEF(JSOP_POP2,      107,"pop2",       NULL,         1,  2,  0,  0,  JOF_BYTE)
+
+/* ECMA-compliant assignment ops. */
+OPDEF(JSOP_BINDNAME,  108,"bindname",   NULL,         3,  0,  1,  0,  JOF_CONST|JOF_NAME|JOF_SET|JOF_ASSIGNING)
+OPDEF(JSOP_SETNAME,   109,"setname",    NULL,         3,  2,  1,  1,  JOF_CONST|JOF_NAME|JOF_SET|JOF_ASSIGNING|JOF_DETECTING)
+
+/* Exception handling ops. */
+OPDEF(JSOP_THROW,     110,"throw",      NULL,         1,  1,  0,  0,  JOF_BYTE)
+
+/* 'in' and 'instanceof' ops. */
+OPDEF(JSOP_IN,        111,js_in_str,    js_in_str,    1,  2,  1,  6,  JOF_BYTE|JOF_LEFTASSOC)
+OPDEF(JSOP_INSTANCEOF,112,js_instanceof_str,js_instanceof_str,1,2,1,6,JOF_BYTE|JOF_LEFTASSOC)
+
+/* debugger op */
+OPDEF(JSOP_DEBUGGER,  113,"debugger",   NULL,         1,  0,  0,  0,  JOF_BYTE)
+
+/* gosub/retsub for finally handling */
+OPDEF(JSOP_GOSUB,     114,"gosub",      NULL,         3,  0,  0,  0,  JOF_JUMP)
+OPDEF(JSOP_RETSUB,    115,"retsub",     NULL,         1,  0,  0,  0,  JOF_BYTE)
+
+/* More exception handling ops. */
+OPDEF(JSOP_EXCEPTION, 116,"exception",  NULL,         1,  0,  1,  0,  JOF_BYTE)
+OPDEF(JSOP_SETSP,     117,"setsp",      NULL,         3,  0,  0,  0,  JOF_UINT16)
+
+/*
+ * ECMA-compliant switch statement ops.
+ * CONDSWITCH is a decompilable NOP; CASE is ===, POP, jump if true, re-push
+ * lval if false; and DEFAULT is POP lval and GOTO.
+ */
+OPDEF(JSOP_CONDSWITCH,118,"condswitch", NULL,         1,  0,  0,  0,  JOF_BYTE)
+OPDEF(JSOP_CASE,      119,"case",       NULL,         3,  1,  0,  0,  JOF_JUMP)
+OPDEF(JSOP_DEFAULT,   120,"default",    NULL,         3,  1,  0,  0,  JOF_JUMP)
+
+/*
+ * ECMA-compliant call to eval op
+ */
+OPDEF(JSOP_EVAL,      121,"eval",       NULL,         3, -1,  1, 11,  JOF_UINT16)
+
+/*
+ * ECMA-compliant helper for 'for (x[i] in o)' loops.
+ */
+OPDEF(JSOP_ENUMELEM,  122,"enumelem",   NULL,         1,  3,  0,  1,  JOF_BYTE |JOF_SET|JOF_ASSIGNING)
+
+/*
+ * Getter and setter prefix bytecodes.  These modify the next bytecode, either
+ * an assignment or a property initializer code, which then defines a property
+ * getter or setter.
+ */
+OPDEF(JSOP_GETTER,    123,js_getter_str,NULL,         1,  0,  0,  0,  JOF_BYTE)
+OPDEF(JSOP_SETTER,    124,js_setter_str,NULL,         1,  0,  0,  0,  JOF_BYTE)
+
+/*
+ * Prolog bytecodes for defining function, var, and const names.
+ */
+OPDEF(JSOP_DEFFUN,    125,"deffun",     NULL,         3,  0,  0,  0,  JOF_CONST|JOF_DECLARING)
+OPDEF(JSOP_DEFCONST,  126,"defconst",   NULL,         3,  0,  0,  0,  JOF_CONST|JOF_DECLARING)
+OPDEF(JSOP_DEFVAR,    127,"defvar",     NULL,         3,  0,  0,  0,  JOF_CONST|JOF_DECLARING)
+
+/* Auto-clone (if needed due to re-parenting) and push an anonymous function. */
+OPDEF(JSOP_ANONFUNOBJ,  128, "anonfunobj",  NULL,     3,  0,  1, 12,  JOF_CONST)
+
+/* ECMA ed. 3 named function expression. */
+OPDEF(JSOP_NAMEDFUNOBJ, 129, "namedfunobj", NULL,     3,  0,  1, 12,  JOF_CONST)
+
+/*
+ * Like JSOP_INITPROP, but specialized to make a DontDelete property for ECMA
+ * Edition 3 catch variables.
+ */
+OPDEF(JSOP_INITCATCHVAR,130, "initcatchvar",NULL,     3,  1,  0,  0,  JOF_CONST)
+
+/* ECMA-mandated parenthesization opcode, which nulls the reference base register, obj; see jsinterp.c. */
+OPDEF(JSOP_GROUP,       131, "group",       NULL,     1,  0,  0,  0,  JOF_BYTE)
+
+/* Host object extension: given 'o.item(i) = j', the left-hand side compiles JSOP_SETCALL, rather than JSOP_CALL. */
+OPDEF(JSOP_SETCALL,     132, "setcall",     NULL,     3, -1,  2, 11,  JOF_UINT16|JOF_SET|JOF_ASSIGNING)
+
+/*
+ * Exception handling no-ops, for more economical byte-coding than SRC_TRYFIN
+ * srcnote-annotated JSOP_NOPs.
+ */
+OPDEF(JSOP_TRY,         133,"try",        NULL,       1,  0,  0,  0,  JOF_BYTE)
+OPDEF(JSOP_FINALLY,     134,"finally",    NULL,       1,  0,  0,  0,  JOF_BYTE)
+
+/*
+ * Swap the top two stack elements.
+ * N.B. JSOP_SWAP doesn't swap the corresponding pc stack generating pcs, as
+ * they're not needed for the current use of preserving the top-of-stack return
+ * value when popping scopes while returning from catch blocks.
+ */
+OPDEF(JSOP_SWAP,        135,"swap",       NULL,       1,  2,  2,  0,  JOF_BYTE)
+
+/*
+ * Bytecodes that avoid making an arguments object in most cases:
+ * JSOP_ARGSUB gets arguments[i] from fp->argv, iff i is in [0, fp->argc-1].
+ * JSOP_ARGCNT returns fp->argc.
+ */
+OPDEF(JSOP_ARGSUB,      136,"argsub",     NULL,       3,  0,  1, 12,  JOF_QARG |JOF_NAME)
+OPDEF(JSOP_ARGCNT,      137,"argcnt",     NULL,       1,  0,  1, 12,  JOF_BYTE)
+
+/*
+ * Define a local function object as a local variable.
+ * The local variable's slot number is the first immediate two-byte operand.
+ * The function object's atom index is the second immediate operand.
+ */
+OPDEF(JSOP_DEFLOCALFUN, 138,"deflocalfun",NULL,       5,  0,  0,  0,  JOF_INDEXCONST|JOF_DECLARING)
+
+/* Extended jumps. */
+OPDEF(JSOP_GOTOX,         139,"gotox",    NULL,       5,  0,  0,  0,  JOF_JUMPX)
+OPDEF(JSOP_IFEQX,         140,"ifeqx",    NULL,       5,  1,  0,  0,  JOF_JUMPX|JOF_DETECTING)
+OPDEF(JSOP_IFNEX,         141,"ifnex",    NULL,       5,  1,  0,  0,  JOF_JUMPX)
+OPDEF(JSOP_ORX,           142,"orx",      NULL,       5,  1,  0,  0,  JOF_JUMPX|JOF_DETECTING)
+OPDEF(JSOP_ANDX,          143,"andx",     NULL,       5,  1,  0,  0,  JOF_JUMPX|JOF_DETECTING)
+OPDEF(JSOP_GOSUBX,        144,"gosubx",   NULL,       5,  0,  0,  0,  JOF_JUMPX)
+OPDEF(JSOP_CASEX,         145,"casex",    NULL,       5,  1,  0,  0,  JOF_JUMPX)
+OPDEF(JSOP_DEFAULTX,      146,"defaultx", NULL,       5,  1,  0,  0,  JOF_JUMPX)
+OPDEF(JSOP_TABLESWITCHX,  147,"tableswitchx",NULL,   -1,  1,  0,  0,  JOF_TABLESWITCHX|JOF_DETECTING)
+OPDEF(JSOP_LOOKUPSWITCHX, 148,"lookupswitchx",NULL,  -1,  1,  0,  0,  JOF_LOOKUPSWITCHX|JOF_DETECTING)
+
+/* Placeholders for a real jump opcode set during backpatch chain fixup. */
+OPDEF(JSOP_BACKPATCH,     149,"backpatch",NULL,       3,  0,  0,  0,  JOF_JUMP|JOF_BACKPATCH)
+OPDEF(JSOP_BACKPATCH_POP, 150,"backpatch_pop",NULL,   3,  1,  0,  0,  JOF_JUMP|JOF_BACKPATCH)
+
+/* Set cx->throwing where cx->exception was already set, to trigger rethrow. */
+OPDEF(JSOP_THROWING,      151,"throwing", NULL,       1,  0,  0,  0,  JOF_BYTE)
+
+/* Set and get return value pseudo-register in stack frame. */
+OPDEF(JSOP_SETRVAL,       152,"setrval",  NULL,       1,  1,  0,  0,  JOF_BYTE)
+OPDEF(JSOP_RETRVAL,       153,"retrval",  NULL,       1,  0,  0,  0,  JOF_BYTE)
+
+/* Optimized global variable ops (we don't bother doing a JSOP_FORGVAR op). */
+OPDEF(JSOP_GETGVAR,       154,"getgvar",  NULL,       3,  0,  1, 12,  JOF_CONST|JOF_NAME)
+OPDEF(JSOP_SETGVAR,       155,"setgvar",  NULL,       3,  1,  1,  1,  JOF_CONST|JOF_NAME|JOF_SET|JOF_ASSIGNING|JOF_DETECTING)
+OPDEF(JSOP_INCGVAR,       156,"incgvar",  NULL,       3,  0,  1, 10,  JOF_CONST|JOF_NAME|JOF_INC)
+OPDEF(JSOP_DECGVAR,       157,"decgvar",  NULL,       3,  0,  1, 10,  JOF_CONST|JOF_NAME|JOF_DEC)
+OPDEF(JSOP_GVARINC,       158,"gvarinc",  NULL,       3,  0,  1, 10,  JOF_CONST|JOF_NAME|JOF_INC|JOF_POST)
+OPDEF(JSOP_GVARDEC,       159,"gvardec",  NULL,       3,  0,  1, 10,  JOF_CONST|JOF_NAME|JOF_DEC|JOF_POST)
+
+/* Regular expression literal requiring special "fork on exec" handling. */
+OPDEF(JSOP_REGEXP,        160,"regexp",   NULL,       3,  0,  1, 12,  JOF_CONST)
+
+/* XML (ECMA-357, a.k.a. "E4X") support. */
+OPDEF(JSOP_DEFXMLNS,      161,"defxmlns",   NULL,     1,  1,  0,  0,  JOF_BYTE)
+OPDEF(JSOP_ANYNAME,       162,"anyname",    NULL,     1,  0,  1, 12,  JOF_BYTE|JOF_XMLNAME)
+OPDEF(JSOP_QNAMEPART,     163,"qnamepart",  NULL,     3,  0,  1, 12,  JOF_CONST|JOF_XMLNAME)
+OPDEF(JSOP_QNAMECONST,    164,"qnameconst", NULL,     3,  1,  1, 12,  JOF_CONST|JOF_XMLNAME)
+OPDEF(JSOP_QNAME,         165,"qname",      NULL,     1,  2,  1,  0,  JOF_BYTE|JOF_XMLNAME)
+OPDEF(JSOP_TOATTRNAME,    166,"toattrname", NULL,     1,  1,  1, 12,  JOF_BYTE|JOF_XMLNAME)
+OPDEF(JSOP_TOATTRVAL,     167,"toattrval",  NULL,     1,  1,  1, 12,  JOF_BYTE)
+OPDEF(JSOP_ADDATTRNAME,   168,"addattrname",NULL,     1,  2,  1,  8,  JOF_BYTE)
+OPDEF(JSOP_ADDATTRVAL,    169,"addattrval", NULL,     1,  2,  1,  8,  JOF_BYTE)
+OPDEF(JSOP_BINDXMLNAME,   170,"bindxmlname",NULL,     1,  1,  2,  0,  JOF_BYTE|JOF_XMLNAME|JOF_SET|JOF_ASSIGNING)
+OPDEF(JSOP_SETXMLNAME,    171,"setxmlname", NULL,     1,  3,  1,  1,  JOF_BYTE|JOF_XMLNAME|JOF_SET|JOF_ASSIGNING|JOF_DETECTING)
+OPDEF(JSOP_XMLNAME,       172,"xmlname",    NULL,     1,  1,  1, 12,  JOF_BYTE|JOF_XMLNAME)
+OPDEF(JSOP_DESCENDANTS,   173,"descendants",NULL,     1,  2,  1, 11,  JOF_BYTE)
+OPDEF(JSOP_FILTER,        174,"filter",     NULL,     3,  1,  1, 11,  JOF_JUMP)
+OPDEF(JSOP_ENDFILTER,     175,"endfilter",  NULL,     1,  1,  0,  0,  JOF_BYTE)
+OPDEF(JSOP_TOXML,         176,"toxml",      NULL,     1,  1,  1, 12,  JOF_BYTE)
+OPDEF(JSOP_TOXMLLIST,     177,"toxmllist",  NULL,     1,  1,  1, 12,  JOF_BYTE)
+OPDEF(JSOP_XMLTAGEXPR,    178,"xmltagexpr", NULL,     1,  1,  1,  0,  JOF_BYTE)
+OPDEF(JSOP_XMLELTEXPR,    179,"xmleltexpr", NULL,     1,  1,  1,  0,  JOF_BYTE)
+OPDEF(JSOP_XMLOBJECT,     180,"xmlobject",  NULL,     3,  0,  1, 12,  JOF_CONST)
+OPDEF(JSOP_XMLCDATA,      181,"xmlcdata",   NULL,     3,  0,  1, 12,  JOF_CONST)
+OPDEF(JSOP_XMLCOMMENT,    182,"xmlcomment", NULL,     3,  0,  1, 12,  JOF_CONST)
+OPDEF(JSOP_XMLPI,         183,"xmlpi",      NULL,     3,  1,  1, 12,  JOF_CONST)
+OPDEF(JSOP_GETMETHOD,     184,"getmethod",  NULL,     3,  1,  1, 11,  JOF_CONST|JOF_PROP)
+OPDEF(JSOP_GETFUNNS,      185,"getfunns",   NULL,     1,  0,  1, 12,  JOF_BYTE)
+OPDEF(JSOP_FOREACH,       186,"foreach",    NULL,     1,  0,  0,  0,  JOF_BYTE)
+OPDEF(JSOP_DELDESC,       187,"deldesc",    NULL,     1,  2,  1, 10,  JOF_BYTE |JOF_ELEM|JOF_DEL)
+
+/*
+ * Opcodes for extended literal addressing, using unsigned 24-bit immediate
+ * operands to hold integer operands (JSOP_UINT24), extended atom indexes in
+ * script->atomMap (JSOP_LITERAL, JSOP_FINDNAME), and ops prefixed by such
+ * atom index immediates (JSOP_LITOPX).  See jsemit.c, EmitAtomIndexOp.
+ */
+OPDEF(JSOP_UINT24,        188,"uint24",     NULL,     4,  0,  1, 12,  JOF_UINT24)
+OPDEF(JSOP_LITERAL,       189,"literal",    NULL,     4,  0,  1, 12,  JOF_UINT24)
+OPDEF(JSOP_FINDNAME,      190,"findname",   NULL,     4,  0,  2,  0,  JOF_UINT24)
+OPDEF(JSOP_LITOPX,        191,"litopx",     NULL,     5,  0,  0, 12,  JOF_LITOPX)
+
+/*
+ * Opcodes to help the decompiler deal with XML.
+ */
+OPDEF(JSOP_STARTXML,      192,"startxml",    NULL,    1,  0,  0,  0,  JOF_BYTE)
+OPDEF(JSOP_STARTXMLEXPR,  193,"startxmlexpr",NULL,    1,  0,  0,  0,  JOF_BYTE)
+OPDEF(JSOP_SETMETHOD,     194,"setmethod",   NULL,    3,  2,  1,  1,  JOF_CONST|JOF_PROP)



From mean at mail.berlios.de  Thu Jan 25 21:06:07 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 25 Jan 2007 21:06:07 +0100
Subject: [Avidemux-svn-commit] r2778 - in
	branches/avidemux_2.4_branch/avidemux: ADM_libraries/ADM_smjs
	ADM_script
Message-ID: <200701252006.l0PK67GG004656@sheep.berlios.de>

Author: mean
Date: 2007-01-25 21:06:06 +0100 (Thu, 25 Jan 2007)
New Revision: 2778

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/Makefile.am
   branches/avidemux_2.4_branch/avidemux/ADM_script/ADM_JSGlobal.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_script/ADM_JSGlobal.h
Log:
threadsafe spidermonkey is not mandatory

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/Makefile.am	2007-01-25 19:43:28 UTC (rev 2777)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/Makefile.am	2007-01-25 20:06:06 UTC (rev 2778)
@@ -46,4 +46,4 @@
 
 EXTRA_DIST = 
 
-INCLUDES =  $(all_includes) -DXP_UNIX -DSVR4 -DSYSV -D_BSD_SOURCE -DPOSIX_SOURCE -DHAVE_LOCALTIME_R -DHAVE_VA_COPY -DVA_COPY=va_copy -DJS_THREADSAFE -I/usr/include/nspr
+INCLUDES =  $(all_includes) -DXP_UNIX -DSVR4 -DSYSV -D_BSD_SOURCE -DPOSIX_SOURCE -DHAVE_LOCALTIME_R -DHAVE_VA_COPY -DVA_COPY=va_copy 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_script/ADM_JSGlobal.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_script/ADM_JSGlobal.cpp	2007-01-25 19:43:28 UTC (rev 2777)
+++ branches/avidemux_2.4_branch/avidemux/ADM_script/ADM_JSGlobal.cpp	2007-01-25 20:06:06 UTC (rev 2778)
@@ -83,7 +83,9 @@
 
 void SpidermonkeyDestroy()
 {// begin SpidermonkeyDestroy
+#ifdef ADM_JS_THREADSAFE
 	JS_SetContextThread(g_pCx);
+#endif
 	JS_DestroyContext(g_pCx);
 	JS_DestroyRuntime(g_pRt);
 }// end SpidermonkeyDestroy
@@ -98,8 +100,10 @@
         http://archive.gingerall.cz/archives/public/sablot2004/msg00117.html
         */
         // Notify the Spidermonkey that we'll be processing in a thread
+#ifdef ADM_JS_THREADSAFE
         JS_SetContextThread(g_pCx);
         JS_BeginRequest(g_pCx);
+#endif
         bool ret = false;
         const char *pScriptFile = static_cast<const char *>(pData);
         ret = parseECMAScript(pScriptFile);
@@ -110,9 +114,11 @@
                 actual_workbench_file = ADM_strdup(pScriptFile);
         }
         // Notify Spidermonkey that our thread processing has finished
+#ifdef ADM_JS_THREADSAFE
         JS_EndRequest(g_pCx);
         JS_ClearContextThread(g_pCx);
         pthread_mutex_unlock(&g_pSpiderMonkeyMutex);
+#endif
         return NULL;
 }// end StartThreadSpidermonkey
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_script/ADM_JSGlobal.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_script/ADM_JSGlobal.h	2007-01-25 19:43:28 UTC (rev 2777)
+++ branches/avidemux_2.4_branch/avidemux/ADM_script/ADM_JSGlobal.h	2007-01-25 20:06:06 UTC (rev 2778)
@@ -42,7 +42,7 @@
         JS_ConvertStub,  JS_FinalizeStub }
 #endif
         ;
-#if 0
+#if !defined(ADM_JS_THREADSAFE)
 #define enterLock() {}
 #define leaveLock() {}
 #else



From mean at mail.berlios.de  Thu Jan 25 21:07:42 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 25 Jan 2007 21:07:42 +0100
Subject: [Avidemux-svn-commit] r2779 - branches/avidemux_2.4_branch
Message-ID: <200701252007.l0PK7gTN004846@sheep.berlios.de>

Author: mean
Date: 2007-01-25 21:07:42 +0100 (Thu, 25 Jan 2007)
New Revision: 2779

Modified:
   branches/avidemux_2.4_branch/configure.in.in
Log:
threadsafe spidermonkey is not mandatory

Modified: branches/avidemux_2.4_branch/configure.in.in
===================================================================
--- branches/avidemux_2.4_branch/configure.in.in	2007-01-25 20:06:06 UTC (rev 2778)
+++ branches/avidemux_2.4_branch/configure.in.in	2007-01-25 20:07:42 UTC (rev 2779)
@@ -450,18 +450,6 @@
 if test "x$have_xml2" = "xyes"; then
 AC_DEFINE(USE_LIBXML2,1,[LibXML2 is available])
 fi
-dnl ______________ nspr _____________
-AC_CHECK_HEADER(nspr/nspr.h,,have_nspr=no)
-if test "x$have_nspr" = "xno"; then
-        AC_MSG_WARN(I did not find nspr/nspr.h.)
-        AC_MSG_ERROR([** Please install it**])
-fi
-AC_CHECK_LIB(nspr4,PR_JoinThreadPool,,have_nspr=no )
-if test "x$have_nspr" = "xno"; then
-        AC_MSG_WARN(I did not find libnspr4 )
-        AC_MSG_ERROR([** Please install it**])
-fi
-
 dnl __________________divx______________
 dnl __________________Aften ______________
 



From mean at mail.berlios.de  Fri Jan 26 19:11:38 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 26 Jan 2007 19:11:38 +0100
Subject: [Avidemux-svn-commit] r2780 - in
	branches/avidemux_2.4_branch/avidemux/ADM_libraries:
	ADM_lavformat ADM_smjs
Message-ID: <200701261811.l0QIBc3J004896@sheep.berlios.de>

Author: mean
Date: 2007-01-26 19:11:35 +0100 (Fri, 26 Jan 2007)
New Revision: 2780

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/ADM_lavformat.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jstypes.h
Log:
 win32 fix

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/ADM_lavformat.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/ADM_lavformat.cpp	2007-01-25 20:07:42 UTC (rev 2779)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/ADM_lavformat.cpp	2007-01-26 18:11:35 UTC (rev 2780)
@@ -19,7 +19,7 @@
  ***************************************************************************/
 
 #include "config.h"
-
+#define WIN32_CLASH
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jstypes.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jstypes.h	2007-01-25 20:07:42 UTC (rev 2779)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jstypes.h	2007-01-26 18:11:35 UTC (rev 2780)
@@ -124,8 +124,10 @@
 #define JS_STATIC_DLL_CALLBACK(__x) static __x
 
 #endif
-
+/* MEANX
 #ifdef _WIN32
+*/
+#if 0
 #  if defined(__MWERKS__) || defined(__GNUC__)
 #    define JS_IMPORT_API(__x)      __x
 #  else
@@ -135,7 +137,7 @@
 #    define JS_IMPORT_API(__x)      JS_EXPORT_API (__x)
 #endif
 
-#if defined(_WIN32) && !defined(__MWERKS__)
+#if 0 // MEANX defined(_WIN32) && !defined(__MWERKS__)
 #    define JS_IMPORT_DATA(__x)      __declspec(dllimport) __x
 #else
 #    define JS_IMPORT_DATA(__x)     JS_EXPORT_DATA (__x)
@@ -158,7 +160,7 @@
 #define JS_FRIEND_API(t)    JS_PUBLIC_API(t)
 #define JS_FRIEND_DATA(t)   JS_PUBLIC_DATA(t)
 
-#ifdef _WIN32
+#if 0 //MEANXdef _WIN32
 #   define JS_INLINE __inline
 #elif defined(__GNUC__)
 #   define JS_INLINE



From mean at mail.berlios.de  Fri Jan 26 19:51:14 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 26 Jan 2007 19:51:14 +0100
Subject: [Avidemux-svn-commit] r2781 - in
	branches/avidemux_2.4_branch/avidemux: ADM_libraries/ADM_smjs
	ADM_osSupport
Message-ID: <200701261851.l0QIpEDY027221@sheep.berlios.de>

Author: mean
Date: 2007-01-26 19:51:13 +0100 (Fri, 26 Jan 2007)
New Revision: 2781

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/Makefile.am
   branches/avidemux_2.4_branch/avidemux/ADM_osSupport/ADM_misc.h
   branches/avidemux_2.4_branch/avidemux/ADM_osSupport/win32.cpp
Log:
win32 fixes

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/Makefile.am	2007-01-26 18:11:35 UTC (rev 2780)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/Makefile.am	2007-01-26 18:51:13 UTC (rev 2781)
@@ -46,4 +46,4 @@
 
 EXTRA_DIST = 
 
-INCLUDES =  $(all_includes) -DXP_UNIX -DSVR4 -DSYSV -D_BSD_SOURCE -DPOSIX_SOURCE -DHAVE_LOCALTIME_R -DHAVE_VA_COPY -DVA_COPY=va_copy 
+INCLUDES =  $(all_includes) -DXP_UNIX -DSVR4 -DSYSV -D_BSD_SOURCE -DPOSIX_SOURCE -DHAVE_VA_COPY -DVA_COPY=va_copy 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_osSupport/ADM_misc.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_osSupport/ADM_misc.h	2007-01-26 18:11:35 UTC (rev 2780)
+++ branches/avidemux_2.4_branch/avidemux/ADM_osSupport/ADM_misc.h	2007-01-26 18:51:13 UTC (rev 2781)
@@ -55,6 +55,8 @@
 #ifdef CYG_MANGLING
 #ifndef HAVE_STRUCT_TIMESPEC
 #define HAVE_STRUCT_TIMESPEC
+extern "C"
+{
 	typedef struct timespec
 	{
 		time_t tv_sec;
@@ -62,6 +64,7 @@
 	};
 
 	void gettimeofday(struct timeval *p, void *tz);
+	};
 	#define timezone int
 	#define TIMZ int
 #endif

Modified: branches/avidemux_2.4_branch/avidemux/ADM_osSupport/win32.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_osSupport/win32.cpp	2007-01-26 18:11:35 UTC (rev 2780)
+++ branches/avidemux_2.4_branch/avidemux/ADM_osSupport/win32.cpp	2007-01-26 18:51:13 UTC (rev 2781)
@@ -3,6 +3,7 @@
 #include <stdlib.h>
 #include <math.h>
 #include "default.h" 
+#include "ADM_misc.h"
 
 
 #ifdef CYG_MANGLING



From mean at mail.berlios.de  Sat Jan 27 19:18:28 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 27 Jan 2007 19:18:28 +0100
Subject: [Avidemux-svn-commit] r2782 - in
	branches/avidemux_2.4_branch/avidemux: ADM_editor
	ADM_inputs/ADM_mpegdemuxer
Message-ID: <200701271818.l0RIISHO015967@sheep.berlios.de>

Author: mean
Date: 2007-01-27 19:18:28 +0100 (Sat, 27 Jan 2007)
New Revision: 2782

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_editor/ADM_edIdentify.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_audio.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxer.h
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_probeTS.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_video.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_video.h
Log:
preparatory work to support more payload in mpeg TS

Modified: branches/avidemux_2.4_branch/avidemux/ADM_editor/ADM_edIdentify.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_editor/ADM_edIdentify.cpp	2007-01-26 18:51:13 UTC (rev 2781)
+++ branches/avidemux_2.4_branch/avidemux/ADM_editor/ADM_edIdentify.cpp	2007-01-27 18:18:28 UTC (rev 2782)
@@ -209,7 +209,7 @@
                 *type=ECMAScript_FileType;
                 return 1;
         }
-        if(fourCC::check(id,(uint8_t *)"ADMX"))
+        if(fourCC::check(id,(uint8_t *)"ADMY") ||fourCC::check(id,(uint8_t *)"ADMX") )
         {
                 printf (" \n New mpeg index file detected..\n");
                 *type=NewMpeg_FileType;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_audio.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_audio.cpp	2007-01-26 18:51:13 UTC (rev 2781)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_audio.cpp	2007-01-27 18:18:28 UTC (rev 2782)
@@ -85,18 +85,26 @@
   uint32_t aPid, vPid, aPes,mainAudio;
   uint32_t nbGop, nbFrame,nbAudioStream;
   int multi;
-
+  char payload[MAX_LINE];
+  uint32_t oldIndex=0;
+  
+  
  file=fopen(name,"rt");
  if(!file) return 0;
 
   printf ("\n  opening dmx file for audio track : %s\n", name);
   fgets (string, MAX_LINE, file);	// File header
-  if (strncmp (string, "ADMX", 4))
+  if (strncmp (string, "ADMY", 4))
     {
-      fclose (file);
-      printf ("This is not a mpeg index G2\n");
-      ADM_assert (0);
+       if (strncmp (string, "ADMX", 4))
+       {
+          fclose (file);
+          printf ("This is not a mpeg index G2\n");
+          ADM_assert (0);
+       }
+       oldIndex=1;
     }
+    
 
 
   fgets (string, MAX_LINE, file);
@@ -125,7 +133,12 @@
 
   fgets (string, MAX_LINE, file);
   sscanf (string, "Picture  : %u x %u %u fps\n", &w, &h, &fps);	// width...
-
+  if(!oldIndex)
+  {
+   fgets (string, MAX_LINE, file);
+   payload[0]=0;
+   sscanf (string, "Payload  : %s\n",payload);	// FIXME ! overflow possible
+  }
   fgets (string, MAX_LINE, file);
   sscanf (string, "Nb Gop   : %u \n", &nbGop);	// width...
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxer.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxer.h	2007-01-26 18:51:13 UTC (rev 2781)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxer.h	2007-01-27 18:18:28 UTC (rev 2782)
@@ -22,6 +22,15 @@
  
 #define ADM_NO_PTS 0xFFFFFFFFFFFFFFFFLL
 #include "dmx_indexer.h"
+
+typedef enum dmx_payloadType
+{
+  DMX_PAYLOAD_ERROR=0,
+  DMX_PAYLOAD_MPEG2=1,
+  DMX_PAYLOAD_MPEG4,
+  DMX_PAYLOAD_H264
+};
+
 class dmx_demuxer
  {
 	  protected : 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer.cpp	2007-01-26 18:51:13 UTC (rev 2781)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer.cpp	2007-01-27 18:18:28 UTC (rev 2782)
@@ -115,8 +115,8 @@
         uint8_t  mpegTypeChar;
         uint32_t multi=0;
         uint64_t firstPicPTS=ADM_NO_PTS;
+        dmx_payloadType payloadType=DMX_PAYLOAD_MPEG2;
         
-        
 
 
         mpegType=dmxIdentify(realname);
@@ -141,8 +141,15 @@
                                 dmx=new dmx_demuxerTS(nbTracks,tracks,0);
                                 demuxer=dmx;
                                 mpegTypeChar='T';
+                                switch(tracks[0].streamType)
+                                {
+                                  case ADM_STREAM_H264:       payloadType=DMX_PAYLOAD_H264;break;
+                                  case ADM_STREAM_MPEG4:      payloadType=DMX_PAYLOAD_MPEG4;break;
+                                  case ADM_STREAM_MPEG_VIDEO: payloadType=DMX_PAYLOAD_MPEG2;break;
+                                default: ADM_assert(0);
                                 break;
                                 }
+                                }
                 case DMX_MPG_ES:
                                 demuxer=new dmx_demuxerES;
                                 mpegTypeChar='E';
@@ -179,12 +186,13 @@
                         delete [] realname;
                         return 0;
         }
-        qfprintf(out,"ADMX0003\n");
+        qfprintf(out,"ADMY0003\n");
         qfprintf(out,"Type     : %c\n",mpegTypeChar); // ES for now
         qfprintf(out,"File     : %s\n",realname);
         qfprintf(out,"Append   : %d\n",multi);
         qfprintf(out,"Image    : %c\n",'P'); // Progressive
         qfprintf(out,"Picture  : %04lu x %04lu %05lu fps\n",0,0,0); // width...
+        qfprintf(out,"Payload  : %c%c%c%c\n",'M','P','E','G'); // width...
         qfprintf(out,"Nb Gop   : %08lu \n",0); // width...
         qfprintf(out,"Nb Images: %010lu \n",0); // width...
         qfprintf(out,"Nb Audio : %02lu\n",nbTracks-1); 
@@ -406,12 +414,25 @@
 
         // Now dump the delta PTS
         // *****************Update header*************
-        qfprintf(out,"ADMX0003\n");
+        qfprintf(out,"ADMY0003\n");
         qfprintf(out,"Type     : %c\n",mpegTypeChar); // ES for now
         qfprintf(out,"File     : %s\n",realname);
         qfprintf(out,"Append   : %d\n",multi);
         qfprintf(out,"Image    : %c\n",type); // Progressive
         qfprintf(out,"Picture  : %04lu x %04lu %05lu fps\n",imageW,imageH,imageFps); // width...
+        switch(payloadType)
+        {
+          case DMX_PAYLOAD_MPEG2:
+                            qfprintf(out,"Payload  : MPEG"); // MPEG,MP_4,H264
+                            break;
+          case DMX_PAYLOAD_MPEG4:
+                            qfprintf(out,"Payload  : MP_4"); // MPEG,MP_4,H264
+                            break;
+          case DMX_PAYLOAD_H264:
+                            qfprintf(out,"Payload  : H264"); // MPEG,MP_4,H264
+                            break;
+          default: ADM_assert(0);
+        }                            
         qfprintf(out,"Nb Gop   : %08lu \n",nbGop); // width...
         qfprintf(out,"Nb Images: %010lu \n",nbImage); // width...
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_probeTS.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_probeTS.cpp	2007-01-26 18:51:13 UTC (rev 2781)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_probeTS.cpp	2007-01-27 18:18:28 UTC (rev 2782)
@@ -70,6 +70,13 @@
  
 extern uint32_t mpegTsCRC(uint8_t *data, uint32_t len);
 
+uint8_t runProbe(const char *file)
+{
+  uint32_t nb;
+  MPEG_TRACK *t;
+  return  dmx_probeTSPat(file, &nb,&t);
+  
+}
 
 uint8_t dmx_probeTS(const char *file,  uint32_t *nbTracks,MPEG_TRACK **tracks)
 {
@@ -341,12 +348,6 @@
       return 1;
       
 }
-uint8_t runProbe(const char *file)
-{
-  uint32_t nb;
-  return  dmx_probeTSPat(file, &nb,NULL);
-  
-}
 /**
       \fn     dmx_searchAndSkipHeader
       \brief  Search for a given PSI and skip header
@@ -407,9 +408,9 @@
               
               sectionLength=misc&0xFFF;
               
-              if(sectionLength<=9 || left <=9)
+              if(sectionLength<=9 || sectionLength >= (left-4-4) || left<9)
               {
-                printf("SectionLength too short :%d\n", sectionLength);
+                printf("SectionLength too short :%d,left %d\n", sectionLength,left);
                  parser->setpos(startPos-1+left); // skip packet
                  continue;
               }

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_video.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_video.cpp	2007-01-26 18:51:13 UTC (rev 2781)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_video.cpp	2007-01-27 18:18:28 UTC (rev 2782)
@@ -195,10 +195,12 @@
                 char     realname[1024];
                 uint32_t dummy;
                 uint32_t vPid,vTsId;
+                char     payload[MAX_LINE+1];
                 
                 char string[MAX_LINE+1]; //,str[1024];;
                 uint8_t interlac=0;
                 int multi;
+                uint32_t oldIndex=0;
                         
                 printf("\n  opening d2v file : %s\n",name);
                 file=fopen(name,"rt");
@@ -209,11 +211,15 @@
                         }
                 
                 fgets(string,MAX_LINE,file);        // File header
-                if(strncmp(string,"ADMX",4))
+                if(strncmp(string,"ADMY",4))
                 {
+                    if(strncmp(string,"ADMX",4)) // Older index file ?
+                    {
                         fclose(file);
                         printf("This is not a mpeg index G2\n");
                          return 0;
+                    }
+                    oldIndex=1;
                 }
         
                 
@@ -246,6 +252,37 @@
                 fgets(string,MAX_LINE,file);
                 sscanf(string,"Picture  : %u x %u %u fps\n",&w,&h,&fps); // width...
 
+                payload[0]=0;
+                if(!oldIndex)
+                {
+                    fgets(string,MAX_LINE,file);
+                    sscanf (string, "Payload  : %s\n",payload);	// FIXME ! overflow possible
+                    if(!strncmp(payload,"MPEG",4))
+                    {
+                          _payloadType=DMX_PAYLOAD_MPEG2;
+                    }else
+                    {
+                      if(!strncmp(payload,"H264",4))
+                      {
+                            _payloadType=DMX_PAYLOAD_H264;
+                      }else
+                      {
+                        if(!strncmp(payload,"MP_4",4))
+                        {
+                              _payloadType=DMX_PAYLOAD_MPEG4;
+                        }else
+                        {
+                          ADM_assert(0); 
+                        }
+                        
+                      }
+                    }
+                }else
+                {
+                  _payloadType=DMX_PAYLOAD_MPEG2;
+                }
+                
+                
                 fgets(string,MAX_LINE,file);
                 sscanf(string,"Nb Gop   : %u \n",&_nbGop); // width...
 
@@ -476,7 +513,14 @@
                         _videostream.fccType=fourCC::get((uint8_t *)"vids");
                         _video_bih.biBitCount=24;
       
-                        _videostream.fccHandler=_video_bih.biCompression=fourCC::get((uint8_t *)"MPEG");;
+                        switch(_payloadType)
+                        {
+                          case DMX_PAYLOAD_MPEG2:_videostream.fccHandler=_video_bih.biCompression=fourCC::get((uint8_t *)"MPEG");;break;
+                          case DMX_PAYLOAD_MPEG4:_videostream.fccHandler=_video_bih.biCompression=fourCC::get((uint8_t *)"DX50");;break;
+                          case DMX_PAYLOAD_H264:_videostream.fccHandler=_video_bih.biCompression=fourCC::get((uint8_t *)"H264");;break;
+                          default: ADM_assert(0);
+                        }
+                        
       
                         _videostream.dwInitialFrames= 0;
                         _videostream.dwStart= 0;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_video.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_video.h	2007-01-26 18:51:13 UTC (rev 2781)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_video.h	2007-01-27 18:18:28 UTC (rev 2782)
@@ -19,6 +19,7 @@
  class dmxHeader : public vidHeader
 {
 protected:
+        dmx_payloadType         _payloadType;
         uint8_t                 asyncJump(uint32_t frame)       ;
         uint8_t                 getFrameMpeg(uint32_t framenum,uint8_t *ptr,uint32_t* framelen,
                                                                                                 uint32_t *flags);



From mean at mail.berlios.de  Sun Jan 28 11:16:12 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 28 Jan 2007 11:16:12 +0100
Subject: [Avidemux-svn-commit] r2783 -
	branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer
Message-ID: <200701281016.l0SAGCag017728@sheep.berlios.de>

Author: mean
Date: 2007-01-28 11:16:12 +0100 (Sun, 28 Jan 2007)
New Revision: 2783

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer_internal.h
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer_mpeg2.cpp
Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/Makefile.am
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer.cpp
Log:
cleanup/split for indexer

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/Makefile.am	2007-01-27 18:18:28 UTC (rev 2782)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/Makefile.am	2007-01-28 10:16:12 UTC (rev 2783)
@@ -6,7 +6,10 @@
 
 libADM_mpegdemuxer_a_METASOURCES = AUTO
 
-libADM_mpegdemuxer_a_SOURCES = dmx_io.cpp dmx_demuxer.cpp dmx_indexer.cpp dmx_demuxerES.cpp dmx_video.cpp dmx_demuxerPS.cpp dmx_identify.cpp dmx_audio.cpp dmx_probe.cpp dmx_probeTS.cpp dmx_demuxerTS.cpp dmx_demuxerMSDVR.cpp dmx_demuxerMSDVR.h
+libADM_mpegdemuxer_a_SOURCES = dmx_io.cpp dmx_demuxer.cpp dmx_indexer.cpp dmx_demuxerES.cpp \
+dmx_video.cpp dmx_demuxerPS.cpp dmx_identify.cpp dmx_audio.cpp dmx_probe.cpp \
+dmx_probeTS.cpp dmx_demuxerTS.cpp dmx_demuxerMSDVR.cpp dmx_demuxerMSDVR.h \
+dmx_indexer_mpeg2.cpp
 
 
 EXTRA_DIST = dmx_audio.cpp      dmx_demuxerEs.h  \

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer.cpp	2007-01-27 18:18:28 UTC (rev 2782)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer.cpp	2007-01-28 10:16:12 UTC (rev 2783)
@@ -46,75 +46,40 @@
 #define MODULE_NAME MODULE_MPEG
 #include "ADM_osSupport/ADM_debug.h"
 
-//#define SHOW_PTS
+#include "dmx_indexer_internal.h"
 
-static uint8_t Push(uint32_t ftype,dmx_demuxer *demuxer,uint64_t abs,uint64_t rel);
-static uint8_t gopDump(FILE *fd,dmx_demuxer *demuxer,uint64_t abs,uint64_t rel,uint32_t nbTracks);
-static uint8_t gopUpdate(dmx_demuxer *demuxer);
-uint8_t dumpPts(FILE *fd,dmx_demuxer *demuxer,uint64_t firstPts,uint32_t nbTracks);
-uint8_t dmx_indexer(const char *mpeg,char *file);
 
-static const uint32_t FPS[16]={
-                0,                      // 0
-                23976,          // 1 (23.976 fps) - FILM
-                24000,          // 2 (24.000 fps)
-                25000,          // 3 (25.000 fps) - PAL
-                29970,          // 4 (29.970 fps) - NTSC
-                30000,          // 5 (30.000 fps)
-                50000,          // 6 (50.000 fps) - PAL noninterlaced
-                59940,          // 7 (59.940 fps) - NTSC noninterlaced
-                60000,          // 8 (60.000 fps)
-                0,                      // 9
-                0,                      // 10
-                0,                      // 11
-                0,                      // 12
-                0,                      // 13
-                0,                      // 14
-                0                       // 15
-        };
-typedef struct IndFrame
-{
-	uint32_t type;
-	uint32_t size;
-	uint64_t abs;
-	uint64_t rel;
-	
-}IndFrame;
 
-typedef struct TimeStamp
-{
-        uint16_t hh,mm,ss,ff;
-}TimeStamp;
-static const char Type[5]={'X','I','P','B','P'};
 
-#define MAX_PUSHED 200
+static uint32_t computeTimeDifference(TimeStamp *f,TimeStamp *l);
 
-static uint32_t nbPushed,nbGop,nbImage;
-static TimeStamp firstStamp,lastStamp;
+uint8_t dmx_indexer(const char *mpeg,char *file);
 
-static IndFrame frames[MAX_PUSHED];
-static uint32_t computeTimeDifference(TimeStamp *f,TimeStamp *l);
+/**
+        \fn    dmx_indexer
+        \brief Create index file    
+        @param mpeg Name of the file to index
+        @param file Name of the index file to create
+        @param preferedAudio Default audio track
+        @param nbTracks # of tracks, including video
+        @param tracks track descriptor
+        @return 1 on success, 0 on failure
 
-/*
-        Index the incoming mpeg file
+    The incoming file can be mpeg PS/TS/ES or ASF.
+    The payload can be mostly mpeg2, with some work done to support later mpeg4/H264 in TS mostly
 
 */
 uint8_t dmx_indexer(const char *mpeg,const char *file,uint32_t preferedAudio,uint8_t autosync,uint32_t nbTracks,MPEG_TRACK *tracks)
 {
         DIA_progressIndexing *work;
         dmx_demuxer *demuxer;
-        uint64_t syncAbs,syncRel;
-        uint64_t lastAbs,lastRel;
-        uint64_t pts,dts;
-        uint64_t olddts=ADM_NO_PTS;
-        uint8_t streamid;   
-        uint32_t lastRefPic=0;             
+
         char *realname=PathCanonize(mpeg);
         FILE *out;        
         DMX_TYPE mpegType;
         uint8_t  mpegTypeChar;
         uint32_t multi=0;
-        uint64_t firstPicPTS=ADM_NO_PTS;
+        
         dmx_payloadType payloadType=DMX_PAYLOAD_MPEG2;
         
 
@@ -209,198 +174,82 @@
         qfprintf(out,"\n");
         qfprintf(out,"# NGop NImg nbImg type:abs:rel:size ...\n"); 
 
-        uint8_t  firstGop=1;
+        
         uint8_t  grabbing=0,seq_found=0;
-        uint32_t imageW=0, imageH=0, imageAR=0, imageFps=0;
+        
         uint32_t total_frame=0,val;
 
-        uint32_t temporal_ref,ftype;
+        
 
         work=new DIA_progressIndexing(mpeg);
 
-        nbPushed=0;
-        nbGop=0;
-        nbImage=0;
-        grabbing=0;
-        uint64_t sSize=demuxer->getSize();
         printf("*********Indexing started (%d audio tracks)***********\n",nbTracks);
-        while(1)
+        runData run;
+        
+        memset(&run,0,sizeof(runData));
+        
+        run.totalFileSize=demuxer->getSize();
+        run.demuxer=demuxer;
+        run.work=work;
+        run.nbTrack=nbTracks;
+        run.fd=out;
+        run.firstPicPTS=ADM_NO_PTS;
+        
+        switch(payloadType)
         {
-                                if(!demuxer->sync(&streamid,&syncAbs,&syncRel,&pts,&dts)) break;   
-                                
-                                //aprintf("\t\tSync : %x at %"LLX"\n",streamid,syncAbs);
-                                               /* if(work->update(syncAbs>>16,demuxer->getSize()>>16))
-                                                {
-                                                        // abort;
-                                                        goto stop_found;
-                                                }*/
-                                if((sSize>>16)>50)
-                                {
-                                      work->update(syncAbs>>16,demuxer->getSize()>>16,nbImage,
-                                              lastStamp.hh,lastStamp.mm,lastStamp.ss);
-                                }else
-                                {
-                                      work->update(syncAbs,demuxer->getSize(),nbImage,
-                                               lastStamp.hh,lastStamp.mm,lastStamp.ss);
-                                }
-//uint32_t done,uint32_t total, uint32_t nbImage, uint32_t hh, uint32_t mm, uint32_t ss);
-                                if(work->isAborted()) break;
-                                switch(streamid)
-                                        {
-                                        /* Useless apparently
-                                                        case 0xB9: // sequence end
-                                                        printf("\n End seq\n");
-                                                        goto stop_found;
-                                                        break;
-                                        */
-                                        case 0xB3: // sequence start
-                                                aprintf("Seq %d\n",nbGop);
-                                                if(grabbing) continue;
-                                                grabbing=1;    
-                                                
-                                                gopDump(out,demuxer,syncAbs,syncRel,nbTracks);                        
-                                                if(seq_found)
-                                                {
-                                                        demuxer->forward(8);
-                                                        break;
-                                                }
-                                                // Our firt frame is here
-                                                // Important to initialize the mpeg decoder !
-                                                frames[0].abs=syncAbs;
-                                                frames[0].rel=syncRel;
-                                                //
-                                                seq_found=1;
-                                                val=demuxer->read32i();
-                                                imageW=val>>20;
-                                                imageW=((imageW+15)&~15);
-                                                imageH= (((val>>8) & 0xfff)+15)& ~15;
-						imageAR=(val>>4)&0xf;
-                                                imageFps= FPS[val & 0xf];
-                                                demuxer->forward(4);
-                                                break;
-                                        case 0xb8: // GOP
-                                                aprintf("GOP %d\n",nbGop);
-#ifdef SHOW_PTS
-                                                if(pts!=ADM_NO_PTS)
-                                                {
-                                                qfprintf(out,"# %lu\n",pts/90);
-                                                }
-#endif
-                                                uint32_t gop;   
-                                                if(!seq_found) continue;
-                                                if(grabbing) 
-                                                {         
-                                                        gopUpdate(demuxer);                                                 
-                                                        continue;
-                                                }
-                                                gopDump(out,demuxer,syncAbs,syncRel,nbTracks);                        
-                                                gopUpdate(demuxer);
-                                                firstGop=0;                                                
-                                                break;
-                                        case 0x00 : // picture
-                                               
-                                                 aprintf("pic \n");
-                                                if(!seq_found)
-                                                { 
-                                                        continue;
-                                                        printf("No sequence start yet, skipping..\n");
-                                                }
-                                                if(firstPicPTS==ADM_NO_PTS && pts!=ADM_NO_PTS)
-                                                        firstPicPTS=pts;
-                                                grabbing=0;
-                                                total_frame++;
-                                                val=demuxer->read16i();
-                                                temporal_ref=val>>6;
-                                                ftype=7 & (val>>3);
-                                                //aprintf("Temporal ref:%lu\n",temporal_ref);
-                                                // skip illegal values
-                                                if(ftype<1 || ftype>3)
-                                                {
-                                                         printf("[Indexer]Met illegal pic at %"LLX" + %"LLX"\n",
-                                                                        syncAbs,syncRel);
-                                                         continue;
-                                                }
-#define USING dts
-                                                if(USING!=ADM_NO_PTS)
-                                                {
-                                                        if(olddts!=ADM_NO_PTS )
-                                                        {                
-                                                                if(USING>=olddts)
-                                                                {
-                                                                uint64_t delta,deltaRef;
-                                                                        delta=USING-olddts;
-                                                                        
-                                                                        delta/=90;
-                                                                      //  printf("Delta :%llu ms\n",delta);
-                                                                        // compute what we should be using
-                                                                        deltaRef=nbPushed+nbImage-lastRefPic;
-                                                                        // in ms
-                                                                        deltaRef=(deltaRef*1000*1000)/imageFps;
-                                                                        if(abs(delta-deltaRef)>MIN_DELTA_PTS)
-                                                                        {
-                                                                                printf("Discontinuity %llu %llu!\n",delta,deltaRef);
-                                                                        }
-                                                                } 
-                                                        }
-                                                        olddts=USING;
-                                                        lastRefPic=nbPushed+nbImage;
-                                                }
-                                                
-                                                
-                                                Push(ftype,demuxer,syncAbs,syncRel);
-                                             
-                                                break;
-                                        default:
-                                           break;
-                                        }
-                }
-stop_found:
-          demuxer->getPos(&lastAbs,&lastRel);
-          if(nbPushed)  gopDump(out,demuxer,lastAbs,lastRel,nbTracks);
+          case DMX_PAYLOAD_MPEG2:
+                            mainLoopMpeg2(&run);
+                            endLoopMpeg2(&run);
+                            break;
+          case DMX_PAYLOAD_MPEG4:
+          case DMX_PAYLOAD_H264:
+          default: ADM_assert(0);
+        }                
+        
+              
+        printf("*********Indexing Ended (%d audio tracks)***********\n",nbTracks);
 
-         dumpPts(out,demuxer,firstPicPTS,nbTracks);
-
-         switch(imageAR)
+         switch(run.imageAR)
          {
            case 1: 	qfprintf(out,"# Video Aspect Ratio : %s\n", "1:1" );break;
            case 2: 	qfprintf(out,"# Video Aspect Ratio : %s\n", "4:3" );break;
            case 3: 	qfprintf(out,"# Video Aspect Ratio : %s\n", "16:9" );break;
            default:
-              printf("imageAR=%u\n",imageAR);
+              printf("imageAR=%u\n",run.imageAR);
               GUI_Error_HIG(_("Can't determine aspect ratio"),NULL);
 	}
 
         /* Now update......... */
           fseeko(out,0,SEEK_SET);
         // Update if needed
-        uint32_t compfps,delta=computeTimeDifference(&firstStamp,&lastStamp);
+        uint32_t compfps,delta=computeTimeDifference(&(run.firstStamp),&(run.lastStamp));
 
         delta=delta/1000; // in second
         if(delta)
         {
-                 compfps= (1000*nbImage)/delta;    // 3 Million images should be enough, no overflow                
+                 compfps= (1000*run.nbImage)/delta;    // 3 Million images should be enough, no overflow                
         }
         else
         {
-                compfps=imageFps;
+                compfps=run.imageFPS;
         }
 
         // Detect film (i.e. NTSC with computed fps close to 24)
-        if(imageFps==29970 || imageFps==30000)
+        if(run.imageFPS==29970 || run.imageFPS==30000)
         {
-                if(compfps>23800 && compfps < 24200) imageFps=23976;
+                if(compfps>23800 && compfps < 24200) run.imageFPS=23976;
         }
         // Detect interlaced vs progressive
         // If field encoded, the average fps is about twice as theoritical fps
         char type='P';
         float err;
 
-        err=imageFps*2;
+        err=run.imageFPS*2;
         err-=compfps;
         err*=100;
-        err/=imageFps*2;
+        err/=run.imageFPS*2;
         if(err<0) err=-err;
-        printf("%lu :%lu / %lu , %f\n",imageFps,imageFps*2,compfps,err);
+        printf("%lu :%lu / %lu , %f\n",run.imageFPS,run.imageFPS*2,compfps,err);
 
         if(err<10) 
         {
@@ -419,168 +268,35 @@
         qfprintf(out,"File     : %s\n",realname);
         qfprintf(out,"Append   : %d\n",multi);
         qfprintf(out,"Image    : %c\n",type); // Progressive
-        qfprintf(out,"Picture  : %04lu x %04lu %05lu fps\n",imageW,imageH,imageFps); // width...
+        qfprintf(out,"Picture  : %04lu x %04lu %05lu fps\n",run.imageW,run.imageH,run.imageFPS); // width...
         switch(payloadType)
         {
           case DMX_PAYLOAD_MPEG2:
-                            qfprintf(out,"Payload  : MPEG"); // MPEG,MP_4,H264
+                            qfprintf(out,"Payload  : MPEG\n"); // MPEG,MP_4,H264
                             break;
           case DMX_PAYLOAD_MPEG4:
-                            qfprintf(out,"Payload  : MP_4"); // MPEG,MP_4,H264
+                            qfprintf(out,"Payload  : MP_4\n"); // MPEG,MP_4,H264
                             break;
           case DMX_PAYLOAD_H264:
-                            qfprintf(out,"Payload  : H264"); // MPEG,MP_4,H264
+                            qfprintf(out,"Payload  : H264\n"); // MPEG,MP_4,H264
                             break;
           default: ADM_assert(0);
         }                            
-        qfprintf(out,"Nb Gop   : %08lu \n",nbGop); // width...
-        qfprintf(out,"Nb Images: %010lu \n",nbImage); // width...
+        qfprintf(out,"Nb Gop   : %08lu \n",run.nbGop); // width...
+        qfprintf(out,"Nb Images: %010lu \n",run.nbImage); // width...
 
         qfclose(out);
         delete work;  
 
         printf("*********Indexing stopped***********\n");
-        printf("Found       :%lu gop\n",nbGop);
-        printf("Found       :%lu image\n",nbImage);                
+        printf("Found       :%lu gop\n",run.nbGop);
+        printf("Found       :%lu image\n",run.nbImage);                
         printf("Average fps :%lu /1000 fps\n",compfps);
 
           delete demuxer;
           delete [] realname;
           return 1;
 }
-/**** Push a frame
-There is a +- 2 correction when we switch gop
-as in the frame header we read 2 bytes
-Between frames, the error is self cancelling.
-
-**/
-uint8_t Push(uint32_t ftype,dmx_demuxer *demuxer,uint64_t abs,uint64_t rel)
-{
-                                            
-        frames[nbPushed].type=ftype;
-        
-        if(nbPushed)
-        {                
-                frames[nbPushed-1].size=demuxer->elapsed();
-                if(nbPushed==1) frames[nbPushed-1].size-=2;
-                frames[nbPushed].abs=abs;
-                frames[nbPushed].rel=rel;        
-                demuxer->stamp();
-        
-        }
-        //aprintf("\tpushed %d %"LLX"\n",nbPushed,abs);
-        nbPushed++;
-        
-        ADM_assert(nbPushed<MAX_PUSHED);
-        return 1;
-
-}
-uint8_t dumpPts(FILE *fd,dmx_demuxer *demuxer,uint64_t firstPts,uint32_t nbTracks)
-{
-uint64_t stats[nbTracks],p;
-double d;
-
-        if(!demuxer->getAllPTS(stats)) return 0;
-        qfprintf(fd,"# Video 1st PTS : %07u\n",firstPts);
-        if(firstPts==ADM_NO_PTS) return 1;
-        for(int i=1;i<nbTracks;i++)
-        {
-                p=stats[i];
-                if(p==ADM_NO_PTS)
-                {
-                        qfprintf(fd,"# track %d no pts\n",i);
-                }
-                else
-                {
-                        
-                        d=firstPts; // it is in 90 khz tick
-                        d-=stats[i];
-                        d/=90.;
-                        qfprintf(fd,"# track %d PTS : %07u ",i,stats[i]);
-                        qfprintf(fd," delta=%04d ms\n",(int)d);
-                }
-
-        }
-        return 1;
-}
-/*** Pop the whold gop ***/
-uint8_t gopDump(FILE *fd,dmx_demuxer *demuxer,uint64_t abs,uint64_t rel,uint32_t nbTracks)
-{
-        if(!nbPushed && !nbImage) demuxer->stamp();
-        if(!nbPushed) return 1;
-
-uint64_t stats[nbTracks];
-
-        frames[nbPushed-1].size=demuxer->elapsed()+2;
-        qfprintf(fd,"V %03u %06u %02u ",nbGop,nbImage,nbPushed);
-
-        // For each picture Type : abs position : relat position : size
-        for(uint32_t i=0;i<nbPushed;i++) 
-        {
-
-                qfprintf(fd,"%c:%08"LLX",%05x",
-                        Type[frames[i].type],
-                        frames[i].abs,
-                        frames[i].rel);
-                qfprintf(fd,",%05x ",
-                        frames[i].size);
-        }
-        
-        qfprintf(fd,"\n");
-
-        // audio if any
-        //*******************************************
-        // Nb image abs_pos audio seen
-        // The Nb image is used to compute a drift
-        //*******************************************
-        if(demuxer->hasAudio() & nbTracks>1)
-        {
-                demuxer->getStats(stats);
-                
-                qfprintf(fd,"A %u %"LLX" ",nbImage,abs);
-                for(uint32_t i=1;i<nbTracks;i++)
-                {
-                        qfprintf(fd,":%"LLX" ",stats[i]);
-                }
-                qfprintf(fd,"\n");
-                
-        }
-        // Print some gop stamp infos, does not hurt
-        qfprintf(fd,"# Timestamp %02d:%02d:%02d,%03d\n",lastStamp.hh,lastStamp.mm,lastStamp.ss,lastStamp.ff);
-        nbGop++;
-        nbImage+=nbPushed;
-        nbPushed=0;
-                
-        frames[0].abs=abs;
-        frames[0].rel=rel;
-        demuxer->stamp();
-        return 1;
-        
-}
-uint8_t gopUpdate(dmx_demuxer *demuxer)
-{
-uint32_t a1,a2,a3,a4;
-uint32_t hh,mm,ss,ff;
-TimeStamp *ts;
-
-        a1=demuxer->read8i();
-        a2=demuxer->read8i();
-        a3=demuxer->read8i();
-        a4=demuxer->read8i();
-        hh=(a1>>2)&0x1f;
-        mm=((a1&3)<<4)+(a2>>4);
-        ss=((a2&7)<<3)+(a3>>5);
-        ff=((a3&0x1f)<<1)+(a4>>7);
-        if(!nbGop)  ts=&firstStamp;
-                else ts=&lastStamp;
-        
-        ts->hh=hh;
-        ts->mm=mm;
-        ts->ss=ss;
-        ts->ff=ff;
-        if(!nbGop) memcpy(&lastStamp,&firstStamp,sizeof(firstStamp));
-        return 1;
-}
 uint32_t computeTimeDifference(TimeStamp *f,TimeStamp *l)
 {
         uint32_t h,m,s,ms,r=0,result=0;
@@ -606,4 +322,5 @@
         return result;
 
 }
+
 //

Added: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer_internal.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer_internal.h	2007-01-27 18:18:28 UTC (rev 2782)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer_internal.h	2007-01-28 10:16:12 UTC (rev 2783)
@@ -0,0 +1,73 @@
+/***************************************************************************
+                        3nd gen indexer                                                 
+                             
+    
+    copyright            : (C) 2005 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef DMX_INDEXER_INTERNAL_H
+#define DMX_INDEXER_INTERNAL_H
+
+#define MAX_PUSHED 200
+
+
+typedef struct TimeStamp
+{
+        uint16_t hh,mm,ss,ff;
+}TimeStamp;
+
+
+typedef struct IndFrame
+{
+	uint32_t type;
+	uint32_t size;
+	uint64_t abs;
+	uint64_t rel;
+	
+}IndFrame;
+
+typedef struct runData
+{
+  
+      FILE     *fd;
+      uint64_t totalFileSize; 
+      uint32_t grabbing;        /* Dont start a new image, still in the old one eg SEQ_START+GOP+1st image */
+      uint32_t totalFrame;
+      uint32_t nbImage;
+      uint32_t nbPushed,nbGop;
+      
+      uint32_t nbTrack;
+      uint32_t seq_found;     /* Sequence start found */
+      
+      uint32_t lastRefPic;
+      
+      uint32_t imageW,imageH,imageFPS,imageAR;
+      
+      
+      uint64_t firstPicPTS;
+      
+      IndFrame *frames;
+      
+      
+      TimeStamp firstStamp,lastStamp; /* Time code hh:mm:ss */
+      
+      dmx_demuxer *demuxer;
+      DIA_progressIndexing *work;
+}runData;
+
+/* * For mpeg2 payload * */
+uint8_t mainLoopMpeg2(runData *run);
+void endLoopMpeg2(runData *run);
+#endif
+//EOF
+
+

Added: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer_mpeg2.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer_mpeg2.cpp	2007-01-27 18:18:28 UTC (rev 2782)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer_mpeg2.cpp	2007-01-28 10:16:12 UTC (rev 2783)
@@ -0,0 +1,367 @@
+/***************************************************************************
+                        2nd gen indexer                                                 
+                             
+    
+    copyright            : (C) 2005 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "config.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <math.h>
+
+#include "default.h"
+#include <ADM_assert.h>
+
+
+#include "ADM_toolkit/toolkit.hxx"
+#include "ADM_toolkit/filesel.h"
+#include "ADM_osSupport/ADM_quota.h"
+#include "DIA_idx_pg.h"
+
+
+
+#include "ADM_osSupport/ADM_debugID.h"
+#define MODULE_NAME MODULE_MPEG
+#include "ADM_osSupport/ADM_debug.h"
+#include "dmx_demuxerEs.h"
+#include "dmx_demuxerPS.h"
+#include "dmx_demuxerTS.h"
+#include "dmx_demuxerMSDVR.h"
+#include "dmx_identify.h"
+
+#define MIN_DELTA_PTS 150 // autofix in ms
+#include "ADM_osSupport/ADM_debugID.h"
+#define MODULE_NAME MODULE_MPEG
+#include "ADM_osSupport/ADM_debug.h"
+
+#include "dmx_indexer_internal.h"
+
+static const char Type[5]={'X','I','P','B','P'};
+
+static const uint32_t FPS[16]={
+                0,                      // 0
+                23976,          // 1 (23.976 fps) - FILM
+                24000,          // 2 (24.000 fps)
+                25000,          // 3 (25.000 fps) - PAL
+                29970,          // 4 (29.970 fps) - NTSC
+                30000,          // 5 (30.000 fps)
+                50000,          // 6 (50.000 fps) - PAL noninterlaced
+                59940,          // 7 (59.940 fps) - NTSC noninterlaced
+                60000,          // 8 (60.000 fps)
+                0,                      // 9
+                0,                      // 10
+                0,                      // 11
+                0,                      // 12
+                0,                      // 13
+                0,                      // 14
+                0                       // 15
+        };
+
+
+
+
+
+static uint8_t Push(runData *run,uint32_t ftype,uint64_t abs,uint64_t rel);
+static uint8_t gopDump(runData *run,uint64_t abs,uint64_t rel,uint32_t nbTracks);
+static uint8_t gopUpdate(runData *run);
+uint8_t dumpPts(FILE *fd,dmx_demuxer *demuxer,uint64_t firstPts,uint32_t nbTracks);
+/**** Push a frame
+There is a +- 2 correction when we switch gop
+as in the frame header we read 2 bytes
+Between frames, the error is self cancelling.
+
+**/
+uint8_t Push(runData *run,uint32_t ftype,uint64_t abs,uint64_t rel)
+{
+                                            
+        run->frames[run->nbPushed].type=ftype;
+        
+        if(run->nbPushed)
+        {                
+                run->frames[run->nbPushed-1].size=run->demuxer->elapsed();
+                if(run->nbPushed==1) run->frames[run->nbPushed-1].size-=2;
+                run->frames[run->nbPushed].abs=abs;
+                run->frames[run->nbPushed].rel=rel;        
+                run->demuxer->stamp();
+        
+        }
+        //aprintf("\tpushed %d %"LLX"\n",nbPushed,abs);
+        run->nbPushed++;
+        
+        ADM_assert(run->nbPushed<MAX_PUSHED);
+        return 1;
+
+}
+uint8_t dumpPts(FILE *fd,dmx_demuxer *demuxer,uint64_t firstPts,uint32_t nbTracks)
+{
+uint64_t stats[nbTracks],p;
+double d;
+
+        if(!demuxer->getAllPTS(stats)) return 0;
+        qfprintf(fd,"# Video 1st PTS : %07u\n",firstPts);
+        if(firstPts==ADM_NO_PTS) return 1;
+        for(int i=1;i<nbTracks;i++)
+        {
+                p=stats[i];
+                if(p==ADM_NO_PTS)
+                {
+                        qfprintf(fd,"# track %d no pts\n",i);
+                }
+                else
+                {
+                        
+                        d=firstPts; // it is in 90 khz tick
+                        d-=stats[i];
+                        d/=90.;
+                        qfprintf(fd,"# track %d PTS : %07u ",i,stats[i]);
+                        qfprintf(fd," delta=%04d ms\n",(int)d);
+                }
+
+        }
+        return 1;
+}
+/*** Pop the whold gop ***/
+uint8_t gopDump(runData *run,uint64_t abs,uint64_t rel,uint32_t nbTracks)
+{
+  dmx_demuxer *demuxer=run->demuxer;
+        if(!run->nbPushed && !run->nbImage) demuxer->stamp();
+        if(!run->nbPushed) return 1;
+
+uint64_t stats[nbTracks];
+
+        run->frames[run->nbPushed-1].size=demuxer->elapsed()+2;
+        qfprintf(run->fd,"V %03u %06u %02u ",run->nbGop,run->nbImage,run->nbPushed);
+
+        // For each picture Type : abs position : relat position : size
+        for(uint32_t i=0;i<run->nbPushed;i++) 
+        {
+
+                qfprintf(run->fd,"%c:%08"LLX",%05x",
+                        Type[run->frames[i].type],
+                        run->frames[i].abs,
+                        run->frames[i].rel);
+                qfprintf(run->fd,",%05x ",
+                        run->frames[i].size);
+        }
+        
+        qfprintf(run->fd,"\n");
+
+        // audio if any
+        //*******************************************
+        // Nb image abs_pos audio seen
+        // The Nb image is used to compute a drift
+        //*******************************************
+        if(demuxer->hasAudio() & nbTracks>1)
+        {
+                demuxer->getStats(stats);
+                
+                qfprintf(run->fd,"A %u %"LLX" ",run->nbImage,abs);
+                for(uint32_t i=1;i<nbTracks;i++)
+                {
+                        qfprintf(run->fd,":%"LLX" ",stats[i]);
+                }
+                qfprintf(run->fd,"\n");
+                
+        }
+        // Print some gop stamp infos, does not hurt
+        qfprintf(run->fd,"# Timestamp %02d:%02d:%02d,%03d\n",run->lastStamp.hh,run->lastStamp.mm,run->lastStamp.ss,run->lastStamp.ff);
+        run->nbGop++;
+        run->nbImage+=run->nbPushed;
+        run->nbPushed=0;
+                
+        run->frames[0].abs=abs;
+        run->frames[0].rel=rel;
+        demuxer->stamp();
+        return 1;
+        
+}
+uint8_t gopUpdate(runData *run)
+{
+uint32_t a1,a2,a3,a4;
+uint32_t hh,mm,ss,ff;
+TimeStamp *ts;
+dmx_demuxer *demuxer=run->demuxer;
+
+        a1=demuxer->read8i();
+        a2=demuxer->read8i();
+        a3=demuxer->read8i();
+        a4=demuxer->read8i();
+        hh=(a1>>2)&0x1f;
+        mm=((a1&3)<<4)+(a2>>4);
+        ss=((a2&7)<<3)+(a3>>5);
+        ff=((a3&0x1f)<<1)+(a4>>7);
+        if(!run->nbGop)  ts=&(run->firstStamp);
+                else ts=&(run->lastStamp);
+        
+        ts->hh=hh;
+        ts->mm=mm;
+        ts->ss=ss;
+        ts->ff=ff;
+        if(!run->nbGop) memcpy(&(run->lastStamp),&(run->firstStamp),sizeof(run->firstStamp));
+        return 1;
+}
+/********************************************************************************************/
+/********************************************************************************************/
+/********************************************************************************************/
+/********************************************************************************************/
+/**
+        \fn mainLoopMpeg2
+        \brief Main indexing function for mpeg1/mpeg2 payLoad
+*/
+uint8_t mainLoopMpeg2(runData *run)
+{
+dmx_demuxer *demuxer=run->demuxer;
+uint64_t syncAbs,syncRel;
+uint8_t streamid;   
+uint32_t temporal_ref,ftype,val;
+uint64_t pts,dts;
+
+      run->frames=new IndFrame[MAX_PUSHED];
+
+      while(1)
+      {
+
+              if(!demuxer->sync(&streamid,&syncAbs,&syncRel,&pts,&dts)) return 0;   
+              if((run->totalFileSize>>16)>50)
+              {
+                    run->work->update(syncAbs>>16,run->totalFileSize>>16,
+                               run->nbImage,run->lastStamp.hh,run->lastStamp.mm,run->lastStamp.ss);
+              }else
+              {
+                    run->work->update(syncAbs,run->totalFileSize,run->nbImage,
+                            run->lastStamp.hh,run->lastStamp.mm,run->lastStamp.ss);
+              }
+              if(run->work->isAborted()) return 0;
+              switch(streamid)
+                      {
+                      case 0xB3: // sequence start
+                              aprintf("Seq %d\n",run->nbGop);
+                              if(run->grabbing) continue;
+                              run->grabbing=1;    
+                              
+                              gopDump(run,syncAbs,syncRel,run->nbTrack);
+                              if(run->seq_found)
+                              {
+                                      demuxer->forward(8);  // Ignore
+                                      continue;
+                              }
+                              // Our firt frame is here
+                              // Important to initialize the mpeg decoder !
+                              run->frames[0].abs=syncAbs;
+                              run->frames[0].rel=syncRel;
+                              //
+                              run->seq_found=1;
+                              val=demuxer->read32i();
+                              run->imageW=val>>20;
+                              run->imageW=((run->imageW+15)&~15);
+                              run->imageH= (((val>>8) & 0xfff)+15)& ~15;
+                              run->imageAR=(val>>4)&0xf;
+                              run->imageFPS= FPS[val & 0xf];
+                              demuxer->forward(4);
+                              break;
+                      case 0xb8: // GOP
+                              aprintf("GOP %d\n",run->nbGop);
+#ifdef SHOW_PTS
+                              if(pts!=ADM_NO_PTS)
+                              {
+                              qfprintf(run->fd,"# %lu\n",pts/90);
+                              }
+#endif
+                              uint32_t gop;   
+                              if(!run->seq_found) continue;
+                              if(run->grabbing) 
+                              {         
+                                      gopUpdate(run);
+                                      continue;;
+                              }
+                              gopDump(run,syncAbs,syncRel,run->nbTrack);
+                              gopUpdate(run);
+                              
+                              break;
+                      case 0x00 : // picture
+                            
+                              aprintf("pic \n");
+                              if(!run->seq_found)
+                              { 
+                                      continue;
+                                      printf("No sequence start yet, skipping..\n");
+                              }
+                              if(run->firstPicPTS==ADM_NO_PTS && pts!=ADM_NO_PTS)
+                                      run->firstPicPTS=pts;
+                              run->grabbing=0;
+                              run->totalFrame++;
+                              val=demuxer->read16i();
+                              temporal_ref=val>>6;
+                              ftype=7 & (val>>3);
+                              //aprintf("Temporal ref:%lu\n",temporal_ref);
+                              // skip illegal values
+                              if(ftype<1 || ftype>3)
+                              {
+                                      printf("[Indexer]Met illegal pic at %"LLX" + %"LLX"\n",
+                                                      syncAbs,syncRel);
+                                      continue;
+                              }
+#define USING dts
+#if 0
+                              if(USING!=ADM_NO_PTS)
+                              {
+                                      if(olddts!=ADM_NO_PTS )
+                                      {                
+                                              if(USING>=olddts)
+                                              {
+                                              uint64_t delta,deltaRef;
+                                                      delta=USING-olddts;
+                                                      
+                                                      delta/=90;
+                                                    //  printf("Delta :%llu ms\n",delta);
+                                                      // compute what we should be using
+                                                      deltaRef=nbPushed+nbImage-run->lastRefPic;
+                                                      // in ms
+                                                      deltaRef=(deltaRef*1000*1000)/run->imageFPS;
+                                                      if(abs(delta-deltaRef)>MIN_DELTA_PTS)
+                                                      {
+                                                              printf("Discontinuity %llu %llu!\n",delta,deltaRef);
+                                                      }
+                                              } 
+                                      }
+                                      olddts=USING;
+                                      run->lastRefPic=nbPushed+nbImage;
+                              }
+#endif
+                              
+                              Push(run,ftype,syncAbs,syncRel);
+                          
+                              break;
+                      default:
+                        break;
+                      }
+      }
+                      return 1; 
+}
+/**
+      \fn endLoopMpeg2
+      \brief do cleanup and purge non processed data at the end of the mpeg2 stream
+*/
+void endLoopMpeg2(runData *run)
+{
+  uint64_t lastAbs,lastRel;
+          run->demuxer->getPos(&lastAbs,&lastRel);
+          if(run->nbPushed)  gopDump(run,lastAbs,lastRel,run->nbTrack);
+          dumpPts(run->fd,run->demuxer,run->firstPicPTS,run->nbTrack); 
+          
+          if(run->frames) delete [] run->frames;
+          run->frames=NULL;
+}
+//



From mean at mail.berlios.de  Sun Jan 28 17:29:30 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 28 Jan 2007 17:29:30 +0100
Subject: [Avidemux-svn-commit] r2784 -
	branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer
Message-ID: <200701281629.l0SGTUmD015561@sheep.berlios.de>

Author: mean
Date: 2007-01-28 17:29:29 +0100 (Sun, 28 Jan 2007)
New Revision: 2784

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer_internal.h
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer_mpeg2.cpp
Log:
more cleanup for indexer

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer.cpp	2007-01-28 10:16:12 UTC (rev 2783)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer.cpp	2007-01-28 16:29:29 UTC (rev 2784)
@@ -184,28 +184,36 @@
         work=new DIA_progressIndexing(mpeg);
 
         printf("*********Indexing started (%d audio tracks)***********\n",nbTracks);
-        runData run;
+        dmx_runData run;
         
-        memset(&run,0,sizeof(runData));
+        memset(&run,0,sizeof(dmx_runData));
         
         run.totalFileSize=demuxer->getSize();
         run.demuxer=demuxer;
         run.work=work;
         run.nbTrack=nbTracks;
         run.fd=out;
-        run.firstPicPTS=ADM_NO_PTS;
         
+        dmx_videoIndexer *idxer=NULL;
+        
         switch(payloadType)
         {
           case DMX_PAYLOAD_MPEG2:
-                            mainLoopMpeg2(&run);
-                            endLoopMpeg2(&run);
+                  {
+                            idxer=new dmx_videoIndexerMpeg2(&run);
                             break;
+                  }
           case DMX_PAYLOAD_MPEG4:
           case DMX_PAYLOAD_H264:
           default: ADM_assert(0);
         }                
         
+        idxer->run();
+        idxer->cleanup();
+        
+        delete idxer;
+        idxer=NULL;
+        
               
         printf("*********Indexing Ended (%d audio tracks)***********\n",nbTracks);
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer_internal.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer_internal.h	2007-01-28 10:16:12 UTC (rev 2783)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer_internal.h	2007-01-28 16:29:29 UTC (rev 2784)
@@ -34,39 +34,79 @@
 	uint64_t rel;
 	
 }IndFrame;
-
-typedef struct runData
+/*****************************************/
+typedef struct dmx_runData
 {
   
       FILE     *fd;
+      dmx_demuxer *demuxer;
+      DIA_progressIndexing *work;
+
       uint64_t totalFileSize; 
-      uint32_t grabbing;        /* Dont start a new image, still in the old one eg SEQ_START+GOP+1st image */
       uint32_t totalFrame;
       uint32_t nbImage;
-      uint32_t nbPushed,nbGop;
-      
+      uint32_t nbPushed,nbGop;      
       uint32_t nbTrack;
-      uint32_t seq_found;     /* Sequence start found */
-      
-      uint32_t lastRefPic;
-      
       uint32_t imageW,imageH,imageFPS,imageAR;
-      
-      
-      uint64_t firstPicPTS;
-      
-      IndFrame *frames;
-      
-      
       TimeStamp firstStamp,lastStamp; /* Time code hh:mm:ss */
       
-      dmx_demuxer *demuxer;
-      DIA_progressIndexing *work;
-}runData;
+}dmx_runData;
 
-/* * For mpeg2 payload * */
-uint8_t mainLoopMpeg2(runData *run);
-void endLoopMpeg2(runData *run);
+/*********************************************************************************************/
+/* Base Class for indexer , depending of the payload type, new derivated classes are created */
+/*********************************************************************************************/
+class dmx_videoIndexer
+{
+protected:
+   FILE                 *_fd;
+   uint64_t             _totalFileSize; 
+   uint32_t             _nbTrack;
+   dmx_demuxer          *_demuxer;
+   DIA_progressIndexing *_work;
+   IndFrame             *_frames;
+   dmx_runData          *_run;
+   
+public:
+          dmx_videoIndexer(dmx_runData *run)
+          {
+              _run=run;
+          }
+  virtual uint8_t  run(void)=0;
+  virtual void     cleanup(void)=0;
+  virtual           ~dmx_videoIndexer() 
+              {
+                  if(_frames)
+                  {
+                    delete [] _frames;
+                    _frames=NULL; 
+                  }
+              }
+};
+/**************************************************/
+/* Class to index mpeg2 payload in ES/PS/TS/MSDVR */
+/**************************************************/
+class dmx_videoIndexerMpeg2 :public dmx_videoIndexer
+{
+protected:
+          uint64_t firstPicPTS;
+          uint32_t grabbing;
+          uint32_t seq_found;
+          
+          
+          uint8_t gopDump(uint64_t abs,uint64_t rel);
+          uint8_t gopUpdate(void);
+          uint8_t dumpPts(uint64_t firstPts);
+          uint8_t Push(uint32_t ftype,uint64_t abs,uint64_t rel);
+public:
+                  dmx_videoIndexerMpeg2(dmx_runData *run);
+ 
+          uint8_t run(void);
+          void    cleanup(void);
+  virtual         ~dmx_videoIndexerMpeg2();
+             
+};
+/********************************************************/
+
 #endif
 //EOF
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer_mpeg2.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer_mpeg2.cpp	2007-01-28 10:16:12 UTC (rev 2783)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer_mpeg2.cpp	2007-01-28 16:29:29 UTC (rev 2784)
@@ -70,209 +70,89 @@
         };
 
 
-
-
-
-static uint8_t Push(runData *run,uint32_t ftype,uint64_t abs,uint64_t rel);
-static uint8_t gopDump(runData *run,uint64_t abs,uint64_t rel,uint32_t nbTracks);
-static uint8_t gopUpdate(runData *run);
-uint8_t dumpPts(FILE *fd,dmx_demuxer *demuxer,uint64_t firstPts,uint32_t nbTracks);
-/**** Push a frame
-There is a +- 2 correction when we switch gop
-as in the frame header we read 2 bytes
-Between frames, the error is self cancelling.
-
-**/
-uint8_t Push(runData *run,uint32_t ftype,uint64_t abs,uint64_t rel)
+dmx_videoIndexerMpeg2::dmx_videoIndexerMpeg2(dmx_runData *run) : dmx_videoIndexer(run)
 {
-                                            
-        run->frames[run->nbPushed].type=ftype;
-        
-        if(run->nbPushed)
-        {                
-                run->frames[run->nbPushed-1].size=run->demuxer->elapsed();
-                if(run->nbPushed==1) run->frames[run->nbPushed-1].size-=2;
-                run->frames[run->nbPushed].abs=abs;
-                run->frames[run->nbPushed].rel=rel;        
-                run->demuxer->stamp();
-        
-        }
-        //aprintf("\tpushed %d %"LLX"\n",nbPushed,abs);
-        run->nbPushed++;
-        
-        ADM_assert(run->nbPushed<MAX_PUSHED);
-        return 1;
-
+  _frames=new IndFrame[MAX_PUSHED];
+  firstPicPTS=ADM_NO_PTS;
+  seq_found=0;
+  grabbing=0;
+  
 }
-uint8_t dumpPts(FILE *fd,dmx_demuxer *demuxer,uint64_t firstPts,uint32_t nbTracks)
+dmx_videoIndexerMpeg2::~dmx_videoIndexerMpeg2()
 {
-uint64_t stats[nbTracks],p;
-double d;
-
-        if(!demuxer->getAllPTS(stats)) return 0;
-        qfprintf(fd,"# Video 1st PTS : %07u\n",firstPts);
-        if(firstPts==ADM_NO_PTS) return 1;
-        for(int i=1;i<nbTracks;i++)
-        {
-                p=stats[i];
-                if(p==ADM_NO_PTS)
-                {
-                        qfprintf(fd,"# track %d no pts\n",i);
-                }
-                else
-                {
-                        
-                        d=firstPts; // it is in 90 khz tick
-                        d-=stats[i];
-                        d/=90.;
-                        qfprintf(fd,"# track %d PTS : %07u ",i,stats[i]);
-                        qfprintf(fd," delta=%04d ms\n",(int)d);
-                }
-
-        }
-        return 1;
+          if(_frames) delete [] _frames;
+          _frames=NULL;
 }
-/*** Pop the whold gop ***/
-uint8_t gopDump(runData *run,uint64_t abs,uint64_t rel,uint32_t nbTracks)
+/**
+      \fn cleanup
+      \brief do cleanup and purge non processed data at the end of the mpeg2 stream
+*/
+void dmx_videoIndexerMpeg2::cleanup(void)
 {
-  dmx_demuxer *demuxer=run->demuxer;
-        if(!run->nbPushed && !run->nbImage) demuxer->stamp();
-        if(!run->nbPushed) return 1;
-
-uint64_t stats[nbTracks];
-
-        run->frames[run->nbPushed-1].size=demuxer->elapsed()+2;
-        qfprintf(run->fd,"V %03u %06u %02u ",run->nbGop,run->nbImage,run->nbPushed);
-
-        // For each picture Type : abs position : relat position : size
-        for(uint32_t i=0;i<run->nbPushed;i++) 
-        {
-
-                qfprintf(run->fd,"%c:%08"LLX",%05x",
-                        Type[run->frames[i].type],
-                        run->frames[i].abs,
-                        run->frames[i].rel);
-                qfprintf(run->fd,",%05x ",
-                        run->frames[i].size);
-        }
-        
-        qfprintf(run->fd,"\n");
-
-        // audio if any
-        //*******************************************
-        // Nb image abs_pos audio seen
-        // The Nb image is used to compute a drift
-        //*******************************************
-        if(demuxer->hasAudio() & nbTracks>1)
-        {
-                demuxer->getStats(stats);
-                
-                qfprintf(run->fd,"A %u %"LLX" ",run->nbImage,abs);
-                for(uint32_t i=1;i<nbTracks;i++)
-                {
-                        qfprintf(run->fd,":%"LLX" ",stats[i]);
-                }
-                qfprintf(run->fd,"\n");
-                
-        }
-        // Print some gop stamp infos, does not hurt
-        qfprintf(run->fd,"# Timestamp %02d:%02d:%02d,%03d\n",run->lastStamp.hh,run->lastStamp.mm,run->lastStamp.ss,run->lastStamp.ff);
-        run->nbGop++;
-        run->nbImage+=run->nbPushed;
-        run->nbPushed=0;
-                
-        run->frames[0].abs=abs;
-        run->frames[0].rel=rel;
-        demuxer->stamp();
-        return 1;
-        
+  uint64_t lastAbs,lastRel;
+          _run->demuxer->getPos(&lastAbs,&lastRel);
+          if(_run->nbPushed)  gopDump(lastAbs,lastRel);
+          dumpPts(firstPicPTS); 
+          
 }
-uint8_t gopUpdate(runData *run)
-{
-uint32_t a1,a2,a3,a4;
-uint32_t hh,mm,ss,ff;
-TimeStamp *ts;
-dmx_demuxer *demuxer=run->demuxer;
 
-        a1=demuxer->read8i();
-        a2=demuxer->read8i();
-        a3=demuxer->read8i();
-        a4=demuxer->read8i();
-        hh=(a1>>2)&0x1f;
-        mm=((a1&3)<<4)+(a2>>4);
-        ss=((a2&7)<<3)+(a3>>5);
-        ff=((a3&0x1f)<<1)+(a4>>7);
-        if(!run->nbGop)  ts=&(run->firstStamp);
-                else ts=&(run->lastStamp);
-        
-        ts->hh=hh;
-        ts->mm=mm;
-        ts->ss=ss;
-        ts->ff=ff;
-        if(!run->nbGop) memcpy(&(run->lastStamp),&(run->firstStamp),sizeof(run->firstStamp));
-        return 1;
-}
-/********************************************************************************************/
-/********************************************************************************************/
-/********************************************************************************************/
-/********************************************************************************************/
 /**
-        \fn mainLoopMpeg2
-        \brief Main indexing function for mpeg1/mpeg2 payLoad
+      \fn run 
+      \brief main indexing loop for mpeg2 payload
 */
-uint8_t mainLoopMpeg2(runData *run)
+uint8_t   dmx_videoIndexerMpeg2::run  (void)
 {
-dmx_demuxer *demuxer=run->demuxer;
+dmx_demuxer *demuxer=_run->demuxer;
 uint64_t syncAbs,syncRel;
 uint8_t streamid;   
 uint32_t temporal_ref,ftype,val;
 uint64_t pts,dts;
 
-      run->frames=new IndFrame[MAX_PUSHED];
+      
 
       while(1)
       {
 
               if(!demuxer->sync(&streamid,&syncAbs,&syncRel,&pts,&dts)) return 0;   
-              if((run->totalFileSize>>16)>50)
+              if((_run->totalFileSize>>16)>50)
               {
-                    run->work->update(syncAbs>>16,run->totalFileSize>>16,
-                               run->nbImage,run->lastStamp.hh,run->lastStamp.mm,run->lastStamp.ss);
+                    _run->work->update(syncAbs>>16,_run->totalFileSize>>16,
+                               _run->nbImage,_run->lastStamp.hh,_run->lastStamp.mm,_run->lastStamp.ss);
               }else
               {
-                    run->work->update(syncAbs,run->totalFileSize,run->nbImage,
-                            run->lastStamp.hh,run->lastStamp.mm,run->lastStamp.ss);
+                    _run->work->update(syncAbs,_run->totalFileSize,_run->nbImage,
+                            _run->lastStamp.hh,_run->lastStamp.mm,_run->lastStamp.ss);
               }
-              if(run->work->isAborted()) return 0;
+              if(_run->work->isAborted()) return 0;
               switch(streamid)
                       {
                       case 0xB3: // sequence start
-                              aprintf("Seq %d\n",run->nbGop);
-                              if(run->grabbing) continue;
-                              run->grabbing=1;    
+                              aprintf("Seq %d\n",_run->nbGop);
+                              if(grabbing) continue;
+                              grabbing=1;    
                               
-                              gopDump(run,syncAbs,syncRel,run->nbTrack);
-                              if(run->seq_found)
+                              gopDump(syncAbs,syncRel);
+                              if(seq_found)
                               {
                                       demuxer->forward(8);  // Ignore
                                       continue;
                               }
                               // Our firt frame is here
                               // Important to initialize the mpeg decoder !
-                              run->frames[0].abs=syncAbs;
-                              run->frames[0].rel=syncRel;
+                              _frames[0].abs=syncAbs;
+                              _frames[0].rel=syncRel;
                               //
-                              run->seq_found=1;
+                              seq_found=1;
                               val=demuxer->read32i();
-                              run->imageW=val>>20;
-                              run->imageW=((run->imageW+15)&~15);
-                              run->imageH= (((val>>8) & 0xfff)+15)& ~15;
-                              run->imageAR=(val>>4)&0xf;
-                              run->imageFPS= FPS[val & 0xf];
+                              _run->imageW=val>>20;
+                              _run->imageW=((_run->imageW+15)&~15);
+                              _run->imageH= (((val>>8) & 0xfff)+15)& ~15;
+                              _run->imageAR=(val>>4)&0xf;
+                              _run->imageFPS= FPS[val & 0xf];
                               demuxer->forward(4);
                               break;
                       case 0xb8: // GOP
-                              aprintf("GOP %d\n",run->nbGop);
+                              aprintf("GOP %d\n",_run->nbGop);
 #ifdef SHOW_PTS
                               if(pts!=ADM_NO_PTS)
                               {
@@ -280,28 +160,28 @@
                               }
 #endif
                               uint32_t gop;   
-                              if(!run->seq_found) continue;
-                              if(run->grabbing) 
+                              if(!seq_found) continue;
+                              if(grabbing) 
                               {         
-                                      gopUpdate(run);
+                                      gopUpdate();
                                       continue;;
                               }
-                              gopDump(run,syncAbs,syncRel,run->nbTrack);
-                              gopUpdate(run);
+                              gopDump(syncAbs,syncRel);
+                              gopUpdate();
                               
                               break;
                       case 0x00 : // picture
                             
                               aprintf("pic \n");
-                              if(!run->seq_found)
+                              if(!seq_found)
                               { 
                                       continue;
                                       printf("No sequence start yet, skipping..\n");
                               }
-                              if(run->firstPicPTS==ADM_NO_PTS && pts!=ADM_NO_PTS)
-                                      run->firstPicPTS=pts;
-                              run->grabbing=0;
-                              run->totalFrame++;
+                              if(firstPicPTS==ADM_NO_PTS && pts!=ADM_NO_PTS)
+                                      firstPicPTS=pts;
+                              grabbing=0;
+                              _run->totalFrame++;
                               val=demuxer->read16i();
                               temporal_ref=val>>6;
                               ftype=7 & (val>>3);
@@ -341,7 +221,7 @@
                               }
 #endif
                               
-                              Push(run,ftype,syncAbs,syncRel);
+                              Push(ftype,syncAbs,syncRel);
                           
                               break;
                       default:
@@ -350,18 +230,166 @@
       }
                       return 1; 
 }
+
+
+
+/**** Push a frame
+There is a +- 2 correction when we switch gop
+as in the frame header we read 2 bytes
+Between frames, the error is self cancelling.
+
+**/
 /**
-      \fn endLoopMpeg2
-      \brief do cleanup and purge non processed data at the end of the mpeg2 stream
+      \fn Push
+      \brief Add a frame to the current gop
+
 */
-void endLoopMpeg2(runData *run)
+uint8_t dmx_videoIndexerMpeg2::Push(uint32_t ftype,uint64_t abs,uint64_t rel)
 {
-  uint64_t lastAbs,lastRel;
-          run->demuxer->getPos(&lastAbs,&lastRel);
-          if(run->nbPushed)  gopDump(run,lastAbs,lastRel,run->nbTrack);
-          dumpPts(run->fd,run->demuxer,run->firstPicPTS,run->nbTrack); 
-          
-          if(run->frames) delete [] run->frames;
-          run->frames=NULL;
+                                            
+        _frames[_run->nbPushed].type=ftype;
+        
+        if(_run->nbPushed)
+        {                
+                _frames[_run->nbPushed-1].size=_run->demuxer->elapsed();
+                if(_run->nbPushed==1) _frames[_run->nbPushed-1].size-=2;
+                _frames[_run->nbPushed].abs=abs;
+                _frames[_run->nbPushed].rel=rel;        
+                _run->demuxer->stamp();
+        
+        }
+        //aprintf("\tpushed %d %"LLX"\n",nbPushed,abs);
+        _run->nbPushed++;
+        
+        ADM_assert(_run->nbPushed<MAX_PUSHED);
+        return 1;
+
 }
+/**
+    \fn dumpPts
+    \brief
+
+*/
+uint8_t dmx_videoIndexerMpeg2::dumpPts(uint64_t firstPts)
+{
+uint64_t stats[_run->nbTrack],p;
+double d;
+dmx_demuxer *demuxer=_run->demuxer;
+
+        if(!demuxer->getAllPTS(stats)) return 0;
+        qfprintf(_run->fd,"# Video 1st PTS : %07u\n",firstPts);
+        if(firstPts==ADM_NO_PTS) return 1;
+        for(int i=1;i<_run->nbTrack;i++)
+        {
+                p=stats[i];
+                if(p==ADM_NO_PTS)
+                {
+                        qfprintf(_run->fd,"# track %d no pts\n",i);
+                }
+                else
+                {
+                        
+                        d=firstPts; // it is in 90 khz tick
+                        d-=stats[i];
+                        d/=90.;
+                        qfprintf(_run->fd,"# track %d PTS : %07u ",i,stats[i]);
+                        qfprintf(_run->fd," delta=%04d ms\n",(int)d);
+                }
+
+        }
+        return 1;
+}
+/**
+      \fn       gopDump
+      \brief    Dump the content of a gop into the index file
+*/
+uint8_t dmx_videoIndexerMpeg2::gopDump(uint64_t abs,uint64_t rel)
+{
+  dmx_demuxer *demuxer=_run->demuxer;
+        if(!_run->nbPushed && !_run->nbImage) demuxer->stamp();
+        if(!_run->nbPushed) return 1;
+
+uint64_t stats[_run->nbTrack];
+
+        _frames[_run->nbPushed-1].size=demuxer->elapsed()+2;
+        qfprintf(_run->fd,"V %03u %06u %02u ",_run->nbGop,_run->nbImage,_run->nbPushed);
+
+        // For each picture Type : abs position : relat position : size
+        for(uint32_t i=0;i<_run->nbPushed;i++) 
+        {
+
+                qfprintf(_run->fd,"%c:%08"LLX",%05x",
+                        Type[_frames[i].type],
+                        _frames[i].abs,
+                        _frames[i].rel);
+                qfprintf(_run->fd,",%05x ",
+                        _frames[i].size);
+        }
+        
+        qfprintf(_run->fd,"\n");
+
+        // audio if any
+        //*******************************************
+        // Nb image abs_pos audio seen
+        // The Nb image is used to compute a drift
+        //*******************************************
+        if(demuxer->hasAudio() & _run->nbTrack>1)
+        {
+                demuxer->getStats(stats);
+                
+                qfprintf(_run->fd,"A %u %"LLX" ",_run->nbImage,abs);
+                for(uint32_t i=1;i<_run->nbTrack;i++)
+                {
+                        qfprintf(_run->fd,":%"LLX" ",stats[i]);
+                }
+                qfprintf(_run->fd,"\n");
+                
+        }
+        // Print some gop stamp infos, does not hurt
+        qfprintf(_run->fd,"# Timestamp %02d:%02d:%02d,%03d\n",
+                 _run->lastStamp.hh,_run->lastStamp.mm,_run->lastStamp.ss,_run->lastStamp.ff);
+        _run->nbGop++;
+        _run->nbImage+=_run->nbPushed;
+        _run->nbPushed=0;
+                
+        _frames[0].abs=abs;
+        _frames[0].rel=rel;
+        demuxer->stamp();
+        return 1;
+        
+}
+/**
+      \fn gopUpdate( 
+      \brief Update the timecode hh:mm:ss.xx inside a gop header
+*/
+uint8_t dmx_videoIndexerMpeg2::gopUpdate(void)
+{
+uint32_t a1,a2,a3,a4;
+uint32_t hh,mm,ss,ff;
+TimeStamp *ts;
+dmx_demuxer *demuxer=_run->demuxer;
+
+        a1=demuxer->read8i();
+        a2=demuxer->read8i();
+        a3=demuxer->read8i();
+        a4=demuxer->read8i();
+        hh=(a1>>2)&0x1f;
+        mm=((a1&3)<<4)+(a2>>4);
+        ss=((a2&7)<<3)+(a3>>5);
+        ff=((a3&0x1f)<<1)+(a4>>7);
+        if(!_run->nbGop)  ts=&(_run->firstStamp);
+                else ts=&(_run->lastStamp);
+        
+        ts->hh=hh;
+        ts->mm=mm;
+        ts->ss=ss;
+        ts->ff=ff;
+        if(!_run->nbGop) memcpy(&(_run->lastStamp),&(_run->firstStamp),sizeof(_run->firstStamp));
+        return 1;
+}
+/********************************************************************************************/
+/********************************************************************************************/
+/********************************************************************************************/
+/********************************************************************************************/
+
 //



From mean at mail.berlios.de  Tue Jan 30 08:18:39 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 30 Jan 2007 08:18:39 +0100
Subject: [Avidemux-svn-commit] r2785 - in
	branches/avidemux_2.4_branch/avidemux: ADM_codecs ADM_encoder
Message-ID: <200701300718.l0U7IdUl031550@sheep.berlios.de>

Author: mean
Date: 2007-01-30 08:18:38 +0100 (Tue, 30 Jan 2007)
New Revision: 2785

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_ffmpeg.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_ffmpeg.h
   branches/avidemux_2.4_branch/avidemux/ADM_encoder/ADM_encCodecDesc.h
   branches/avidemux_2.4_branch/avidemux/ADM_encoder/ADM_vidEncode.hxx
   branches/avidemux_2.4_branch/avidemux/ADM_encoder/adm_encConfig.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_encoder/adm_encffmpeg.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_encoder/adm_encffmpeg.h
Log:
DV codec output, first part

Modified: branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_ffmpeg.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_ffmpeg.cpp	2007-01-28 16:29:29 UTC (rev 2784)
+++ branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_ffmpeg.cpp	2007-01-30 07:18:38 UTC (rev 2785)
@@ -346,6 +346,11 @@
     case FF_SNOW:
       WRAP_Open (CODEC_ID_SNOW);
       break;
+      
+    case FF_DV:
+      WRAP_Open (CODEC_ID_DVVIDEO);
+      break;
+
     default:
       ADM_assert (0);
     }

Modified: branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_ffmpeg.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_ffmpeg.h	2007-01-28 16:29:29 UTC (rev 2784)
+++ branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_ffmpeg.h	2007-01-30 07:18:38 UTC (rev 2785)
@@ -34,6 +34,7 @@
   FF_MPEG2 = 9,
   FF_SNOW = 10,
   FF_FFHUFF = 11,
+  FF_DV=12,
 } FF_CODEC_ID;
 
 /*

Modified: branches/avidemux_2.4_branch/avidemux/ADM_encoder/ADM_encCodecDesc.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_encoder/ADM_encCodecDesc.h	2007-01-28 16:29:29 UTC (rev 2784)
+++ branches/avidemux_2.4_branch/avidemux/ADM_encoder/ADM_encCodecDesc.h	2007-01-30 07:18:38 UTC (rev 2785)
@@ -114,6 +114,23 @@
   sizeof (ffmpeg4Extra),
   getFFCompressParams
 };
+COMPRES_PARAMS ffmpegDV = {
+  CodecDV,
+  "DV",
+  "DV",
+  "DV",
+  COMPRESS_CQ,
+  4,
+  1500,
+  700,
+  1000, // AVG
+  ADM_ENC_CAP_CBR + ADM_ENC_CAP_CQ + ADM_ENC_CAP_2PASS,
+  ADM_EXTRA_PARAM,
+  &ffmpeg4Extra,
+  sizeof (ffmpeg4Extra),
+  NULL
+};
+
 COMPRES_PARAMS ffmpegSnow = {
   CodecSnow,
   "Snow (lavc)",
@@ -707,6 +724,7 @@
   &VCDCodec,
   &SVCDCodec,
   &DVDCodec,
+  &ffmpegDV,
   &RequantCodec,
 #ifdef USE_XVID_4
   &Xvid4Codec,

Modified: branches/avidemux_2.4_branch/avidemux/ADM_encoder/ADM_vidEncode.hxx
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_encoder/ADM_vidEncode.hxx	2007-01-28 16:29:29 UTC (rev 2784)
+++ branches/avidemux_2.4_branch/avidemux/ADM_encoder/ADM_vidEncode.hxx	2007-01-30 07:18:38 UTC (rev 2785)
@@ -43,6 +43,7 @@
 #endif
   CodecYV12,
   CodecRequant,
+  CodecDV,
   CodecDummy
 };
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_encoder/adm_encConfig.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_encoder/adm_encConfig.cpp	2007-01-28 16:29:29 UTC (rev 2784)
+++ branches/avidemux_2.4_branch/avidemux/ADM_encoder/adm_encConfig.cpp	2007-01-30 07:18:38 UTC (rev 2785)
@@ -700,6 +700,9 @@
     case CodecFFV1:
       e = new EncoderFFMPEGFFV1 (&ffmpegFFV1);
       break;
+    case CodecDV:
+        e = new EncoderFFMPEGDV (&ffmpegDV);
+      break;
     case CodecSnow:
       e = new EncodeFFMPEGSNow (&ffmpegSnow);
       break;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_encoder/adm_encffmpeg.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_encoder/adm_encffmpeg.cpp	2007-01-28 16:29:29 UTC (rev 2784)
+++ branches/avidemux_2.4_branch/avidemux/ADM_encoder/adm_encffmpeg.cpp	2007-01-30 07:18:38 UTC (rev 2785)
@@ -222,7 +222,48 @@
 
 }
 
+//*********************DV **********************************************
+EncoderFFMPEGDV::EncoderFFMPEGDV (COMPRES_PARAMS * config):
+EncoderFFMPEG (FF_DV, config)
+{
+  _id = FF_DV;
+  _frametogo = 0;
 
+
+}
+uint8_t
+EncoderFFMPEGDV::hasExtraHeaderData (uint32_t * l, uint8_t ** data)
+{
+  *l = 0;
+  *data = NULL;
+  return 0;
+
+}
+uint8_t
+EncoderFFMPEGDV::configure (AVDMGenericVideoStream * instream)
+{
+  ADM_assert (instream);
+  ADV_Info *info;
+
+
+
+  info = instream->getInfo ();
+  _fps = info->fps1000;
+  _w = info->width;
+  _h = info->height;
+  _vbuffer = new ADMImage (_w, _h);
+  ADM_assert (_vbuffer);
+  _in = instream;
+
+  _codec = new ffmpegEncoderCQ (_w, _h, _id);
+  _codec->init (_param.qz, _fps, 0);
+  _state=enc_CQ;
+  return 1;
+
+
+
+}
+
 //************************* SNOW **************************
 // return codec name as seen in avi header
 //
@@ -231,6 +272,9 @@
 {
   switch (_id)
     {
+    case FF_DV:
+        return "dvsd";
+        break;
     case FF_FFHUFF:
       return "FFVH";
       break;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_encoder/adm_encffmpeg.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_encoder/adm_encffmpeg.h	2007-01-28 16:29:29 UTC (rev 2784)
+++ branches/avidemux_2.4_branch/avidemux/ADM_encoder/adm_encffmpeg.h	2007-01-30 07:18:38 UTC (rev 2785)
@@ -252,4 +252,50 @@
   virtual uint8_t hasExtraHeaderData (uint32_t * l, uint8_t ** data);
 
 };
+
+
+    
+class EncoderFFMPEGDV:public EncoderFFMPEG
+{
+
+protected:
+
+
+public:
+  EncoderFFMPEGDV (COMPRES_PARAMS * config);
+  ~EncoderFFMPEGDV ()
+  {
+    stop ();
+  };				// can be called twice if needed ..
+  virtual uint8_t isDualPass (void)
+  {
+    return 0;
+  };
+  virtual uint8_t configure (AVDMGenericVideoStream * instream);
+  virtual uint8_t setLogFile (const char *p, uint32_t fr)
+  {
+    UNUSED_ARG (p);
+    UNUSED_ARG (fr);
+    return 1;
+  };
+  virtual uint8_t startPass2 (void)
+  {
+    return 1;
+  };
+  virtual uint8_t startPass1 (void)
+  {
+    return 1;
+  };
+  virtual const char *getDisplayName (void)
+  {
+    return "FFMPEG DV";
+  }
+  virtual const char *getFCCHandler (void)
+  {
+    return "DVDS";
+  }
+  virtual uint8_t hasExtraHeaderData (uint32_t * l, uint8_t ** data);
+
+};
+
 #endif



From mean at mail.berlios.de  Tue Jan 30 21:05:17 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 30 Jan 2007 21:05:17 +0100
Subject: [Avidemux-svn-commit] r2786 - in
	branches/avidemux_2.4_branch/avidemux: ADM_codecs ADM_encoder
	ADM_inputs/ADM_3gp ADM_libraries/ADM_lavformat
Message-ID: <200701302005.l0UK5Hrg012010@sheep.berlios.de>

Author: mean
Date: 2007-01-30 21:05:15 +0100 (Tue, 30 Jan 2007)
New Revision: 2786

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_codec.h
   branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_codecs.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_ffmpeg.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_encoder/adm_encffmpeg.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_encoder/adm_encffmpeg.h
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_3gp/ADM_3gp.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/ADM_lavformat.cpp
Log:
DV as ouput part 2

Modified: branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_codec.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_codec.h	2007-01-30 07:18:38 UTC (rev 2785)
+++ branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_codec.h	2007-01-30 20:05:15 UTC (rev 2786)
@@ -130,6 +130,8 @@
 uint8_t isMpeg4Compatible (uint32_t fourcc);
 uint8_t isH264Compatible (uint32_t fourcc);
 uint8_t isMSMpeg4Compatible (uint32_t fourcc);
+uint8_t isDVCompatible (uint32_t fourcc);
+
 /*----------------------------------------------------------*/
 class encoder
 {

Modified: branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_codecs.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_codecs.cpp	2007-01-30 07:18:38 UTC (rev 2785)
+++ branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_codecs.cpp	2007-01-30 20:05:15 UTC (rev 2786)
@@ -157,7 +157,24 @@
 
 #undef CHECK
 }
+uint8_t
+isDVCompatible (uint32_t fourcc)
+{
+#define CHECK(x) if(fourCC::check(fourcc,(uint8_t *)x)) \
+						{dv=1; }
 
+  uint8_t dv = 0;
+
+  CHECK ("dvsd");
+  CHECK ("DVDS");
+  CHECK ("dvpp");
+
+  return dv;
+
+#undef CHECK
+}
+
+
 uint8_t
   decoders::uncompress (ADMCompressedImage * in, ADMImage * out)
 {

Modified: branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_ffmpeg.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_ffmpeg.cpp	2007-01-30 07:18:38 UTC (rev 2785)
+++ branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_ffmpeg.cpp	2007-01-30 20:05:15 UTC (rev 2786)
@@ -348,6 +348,8 @@
       break;
       
     case FF_DV:
+      if(_context->width!=720 || _context->height!=576) 
+            return 0; // should be caught by upper layers before going here...
       WRAP_Open (CODEC_ID_DVVIDEO);
       break;
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_encoder/adm_encffmpeg.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_encoder/adm_encffmpeg.cpp	2007-01-30 07:18:38 UTC (rev 2785)
+++ branches/avidemux_2.4_branch/avidemux/ADM_encoder/adm_encffmpeg.cpp	2007-01-30 20:05:15 UTC (rev 2786)
@@ -251,10 +251,16 @@
   _fps = info->fps1000;
   _w = info->width;
   _h = info->height;
+  
   _vbuffer = new ADMImage (_w, _h);
   ADM_assert (_vbuffer);
   _in = instream;
 
+  if(_w!=720 || _h!=576 || _fps!=25000)
+  {
+    GUI_Error_HIG(_("Incompatible settings"),_("At the moment, the DV codec only accepts 720*576 at 25"));
+    return 0;
+  }
   _codec = new ffmpegEncoderCQ (_w, _h, _id);
   _codec->init (_param.qz, _fps, 0);
   _state=enc_CQ;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_encoder/adm_encffmpeg.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_encoder/adm_encffmpeg.h	2007-01-30 07:18:38 UTC (rev 2785)
+++ branches/avidemux_2.4_branch/avidemux/ADM_encoder/adm_encffmpeg.h	2007-01-30 20:05:15 UTC (rev 2786)
@@ -292,7 +292,7 @@
   }
   virtual const char *getFCCHandler (void)
   {
-    return "DVDS";
+    return "dvsd";
   }
   virtual uint8_t hasExtraHeaderData (uint32_t * l, uint8_t ** data);
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_3gp/ADM_3gp.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_3gp/ADM_3gp.cpp	2007-01-30 07:18:38 UTC (rev 2785)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_3gp/ADM_3gp.cpp	2007-01-30 20:05:15 UTC (rev 2786)
@@ -69,6 +69,7 @@
 #include "fourcc.h"
 #include "ADM_3gp/ADM_3gp.h"
 #include "ADM_toolkit/toolkit.hxx"
+#include "ADM_codecs/ADM_codec.h"
 
 #include "ADM_osSupport/ADM_debugID.h"
 #define MODULE_NAME MODULE_3GP
@@ -117,8 +118,7 @@
 	if(frame>= (uint32_t)_videostream.dwLength) return 0;
 #warning FIXME : UGLY
 	if(fourCC::check(_videostream.fccHandler,(uint8_t *)"MJPG")
-        || fourCC::check(_videostream.fccHandler,(uint8_t *)"DVDS") // Fixme should be done on the fly
-        )
+        || isDVCompatible(_videostream.fccHandler)) // Fixme should be done on the fly
 	{
 		*flags=AVI_KEY_FRAME;
 	}
@@ -928,6 +928,7 @@
 				printf("tkhd : %ld %ld\n",_lastW,_lastH);
 				break;
                         case MKFCCR('d','v','c',' ') : //'dvc ':
+                        case MKFCCR('d','v','p','p') : //'dvpp':
 /*
                                 tom.skipBytes(24);
                                 wh=tom.read32();

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/ADM_lavformat.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/ADM_lavformat.cpp	2007-01-30 07:18:38 UTC (rev 2785)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/ADM_lavformat.cpp	2007-01-30 20:05:15 UTC (rev 2786)
@@ -45,6 +45,7 @@
 #include "ADM_editor/ADM_Video.h"
 
 #include "ADM_lavformat.h"
+#include "fourcc.h"
 
 
 #include "ADM_osSupport/ADM_debugID.h"
@@ -177,11 +178,16 @@
                                 }
                                 else
                                 {
-                                         c->codec_id = CODEC_ID_MPEG4; // Default value
-                                        printf("Ooops, cant mux that...\n");
-                                        printf("Ooops, cant mux that...\n");
-                                        printf("Ooops, cant mux that...\n");
-                                        //return 0;
+                                        if(isDVCompatible(info->fcc))
+                                        {
+                                          c->codec_id = CODEC_ID_DVVIDEO;
+                                        }else
+                                        {
+                                          c->codec_id = CODEC_ID_MPEG4; // Default value
+                                          printf("Ooops, cant mux that...\n");
+                                          printf("Ooops, cant mux that...\n");
+                                          printf("Ooops, cant mux that...\n");
+                                        }
                                 }
                         }
                         if(videoExtraDataSize)



From mean at mail.berlios.de  Wed Jan 31 19:09:30 2007
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 31 Jan 2007 19:09:30 +0100
Subject: [Avidemux-svn-commit] r2787 - in
	branches/avidemux_2.4_branch/avidemux: ADM_codecs
	ADM_inputs/ADM_3gp ADM_libraries/ADM_lavformat
Message-ID: <200701311809.l0VI9U2A009758@sheep.berlios.de>

Author: mean
Date: 2007-01-31 19:09:29 +0100 (Wed, 31 Jan 2007)
New Revision: 2787

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_codecs.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_3gp/ADM_3gp.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/ADM_lavformat.cpp
Log:
DV output final, fix mp3 in mp4 also

Modified: branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_codecs.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_codecs.cpp	2007-01-30 20:05:15 UTC (rev 2786)
+++ branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_codecs.cpp	2007-01-31 18:09:29 UTC (rev 2787)
@@ -214,9 +214,7 @@
     }
 
 #ifdef USE_FFMPEG
-  if (fourCC::check (fcc, (uint8_t *) "dvsd")
-      || fourCC::check (fcc, (uint8_t *) "DVDS")
-      || fourCC::check (fcc, (uint8_t *) "CDVC"))
+  if (isDVCompatible(fcc))//"CDVC"))
     {
 
       return (decoders *) (new decoderFFDV (w, h, extraLen, extraData));

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_3gp/ADM_3gp.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_3gp/ADM_3gp.cpp	2007-01-30 20:05:15 UTC (rev 2786)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_3gp/ADM_3gp.cpp	2007-01-31 18:09:29 UTC (rev 2787)
@@ -1079,7 +1079,7 @@
 			case MKFCCR('e','s','d','s'): //'esds':
 					// in case of mpeg4 we only take
 					// the mpeg4 vol header
-					
+					printf("Esds atom found\n");
 
 					tom.skipBytes(4);
 					tag=0xff;
@@ -1101,6 +1101,7 @@
                                                                 {
                                                                   switch(objectTypeIndication)
                                                                   {
+                                                                      case 0x69:ADIO.encoding=WAV_MP3;break;
                                                                       case 0x6b:ADIO.encoding=WAV_MP3;break;
                                                                       case 0x6d:ADIO.encoding=WAV_MP3;break;
                                                                       case 226:ADIO.encoding=WAV_AC3;break;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/ADM_lavformat.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/ADM_lavformat.cpp	2007-01-30 20:05:15 UTC (rev 2786)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/ADM_lavformat.cpp	2007-01-31 18:09:29 UTC (rev 2787)
@@ -459,6 +459,7 @@
             if(ret) 
             {
                         printf("Error writing audio packet\n");
+                        printf("pts %llu dts %llu\n",pkt.pts,pkt.dts);
                         return 0;
             }
             return 1;



