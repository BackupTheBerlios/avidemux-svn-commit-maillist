<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r5185 - in	branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass:	. ADM_libAss ADM_libass
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2009-August/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r5185%20-%20in%0A%09branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass%3A%0A%09.%20ADM_libAss%20ADM_libass&In-Reply-To=%3C200908010755.n717tQxn016415%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002398.html">
   <LINK REL="Next"  HREF="002400.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r5185 - in	branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass:	. ADM_libAss ADM_libass</H1>
    <B>mean at BerliOS</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r5185%20-%20in%0A%09branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass%3A%0A%09.%20ADM_libAss%20ADM_libass&In-Reply-To=%3C200908010755.n717tQxn016415%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r5185 - in	branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass:	. ADM_libAss ADM_libass">mean at mail.berlios.de
       </A><BR>
    <I>Sat Aug  1 09:55:26 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="002398.html">[Avidemux-svn-commit] r5184 - in	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs:	ADM_GTK/src ADM_QT4/src
</A></li>
        <LI>Next message: <A HREF="002400.html">[Avidemux-svn-commit] r5186 -	branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2399">[ date ]</a>
              <a href="thread.html#2399">[ thread ]</a>
              <a href="subject.html#2399">[ subject ]</a>
              <a href="author.html#2399">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2009-08-01 09:55:22 +0200 (Sat, 01 Aug 2009)
New Revision: 5185

Added:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass.c
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_bitmap.c
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_bitmap.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_cache.c
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_cache.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_cache_template.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_drawing.c
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_drawing.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_font.c
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_font.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_fontconfig.c
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_fontconfig.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_library.c
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_library.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_render.c
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_types.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_utils.c
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_utils.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/config.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/libass.sym
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/readme
Removed:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass.c
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_bitmap.c
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_bitmap.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_cache.c
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_cache.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_font.c
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_font.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_fontconfig.c
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_fontconfig.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_library.c
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_library.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_render.c
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_types.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_utils.c
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_utils.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/help_mp.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/mputils.c
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/mputils.h
Modified:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_vidASS.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_vidASS.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/CMakeLists.txt
Log:
[ass] Update

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/CMakeLists.txt	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/CMakeLists.txt	2009-08-01 07:55:22 UTC (rev 5185)
@@ -0,0 +1,32 @@
+# Does not seem to work without fontconfig....
+
+INCLUDE(admCheckFontConfig)
+INCLUDE(admCheckFreeType)
+checkFontConfig()
+checkFreeType()
+IF(USE_FREETYPE)
+
+        SET(ADM_LIB ADM_libass)
+
+        SET(${ADM_LIB}_SRCS 
+        ass_bitmap.c  ass.c  ass_cache.c  ass_drawing.c  ass_font.c    ass_library.c  ass_render.c  ass_utils.c
+        )
+    IF (FONTCONFIG_FOUND)
+        ADD_DEFINITIONS(${FONTCONFIG_CFLAGS} &quot;-DHAVE_FONTCONFIG=1&quot; &quot;-DCONFIG_FONTCONFIG=1&quot;)
+        SET(${ADM_LIB}_SRCS  ${${ADM_LIB}_SRCS} ass_fontconfig.c)
+    ENDIF (FONTCONFIG_FOUND)
+        ADD_LIBRARY(${ADM_LIB} STATIC ${${ADM_LIB}_SRCS})
+        ADD_DEFINITIONS(${FREETYPE2_CFLAGS} &quot;-I${LIBICONV_INCLUDE_DIR}&quot;)
+
+     
+
+
+        ADD_DEFINITIONS(&quot;-DCONFIG_LIBPNG=1&quot;)
+        ADD_DEFINITIONS(&quot;-DCONFIG_FREETYPE=1&quot;)
+
+        IF (UNIX)
+	        ADD_TARGET_CFLAGS(${ADM_LIB} -fPIC)
+        ENDIF (UNIX)
+
+ENDIF(USE_FREETYPE)
+

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass.c	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass.c	2009-08-01 07:55:22 UTC (rev 5185)
@@ -0,0 +1,1237 @@
+/*
+ * Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+ *
+ * This file is part of libass.
+ *
+ * libass is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libass is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with libass; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include &quot;config.h&quot;
+
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;assert.h&gt;
+#include &lt;errno.h&gt;
+#include &lt;sys/types.h&gt;
+#include &lt;sys/stat.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;inttypes.h&gt;
+
+#ifdef CONFIG_ICONV
+#include &lt;iconv.h&gt;
+#endif
+
+#include &quot;ass.h&quot;
+#include &quot;ass_utils.h&quot;
+#include &quot;ass_library.h&quot;
+
+typedef enum { PST_UNKNOWN =
+        0, PST_INFO, PST_STYLES, PST_EVENTS, PST_FONTS } parser_state_t;
+
+struct parser_priv {
+    parser_state_t state;
+    char *fontname;
+    char *fontdata;
+    int fontdata_size;
+    int fontdata_used;
+};
+
+#define ASS_STYLES_ALLOC 20
+#define ASS_EVENTS_ALLOC 200
+
+void ass_free_track(ass_track_t *track)
+{
+    int i;
+
+    if (track-&gt;parser_priv) {
+        if (track-&gt;parser_priv-&gt;fontname)
+            free(track-&gt;parser_priv-&gt;fontname);
+        if (track-&gt;parser_priv-&gt;fontdata)
+            free(track-&gt;parser_priv-&gt;fontdata);
+        free(track-&gt;parser_priv);
+    }
+    if (track-&gt;style_format)
+        free(track-&gt;style_format);
+    if (track-&gt;event_format)
+        free(track-&gt;event_format);
+    if (track-&gt;styles) {
+        for (i = 0; i &lt; track-&gt;n_styles; ++i)
+            ass_free_style(track, i);
+        free(track-&gt;styles);
+    }
+    if (track-&gt;events) {
+        for (i = 0; i &lt; track-&gt;n_events; ++i)
+            ass_free_event(track, i);
+        free(track-&gt;events);
+    }
+    free(track-&gt;name);
+    free(track);
+}
+
+/// \brief Allocate a new style struct
+/// \param track track
+/// \return style id
+int ass_alloc_style(ass_track_t *track)
+{
+    int sid;
+
+    assert(track-&gt;n_styles &lt;= track-&gt;max_styles);
+
+    if (track-&gt;n_styles == track-&gt;max_styles) {
+        track-&gt;max_styles += ASS_STYLES_ALLOC;
+        track-&gt;styles =
+            (ass_style_t *) realloc(track-&gt;styles,
+                                    sizeof(ass_style_t) *
+                                    track-&gt;max_styles);
+    }
+
+    sid = track-&gt;n_styles++;
+    memset(track-&gt;styles + sid, 0, sizeof(ass_style_t));
+    return sid;
+}
+
+/// \brief Allocate a new event struct
+/// \param track track
+/// \return event id
+int ass_alloc_event(ass_track_t *track)
+{
+    int eid;
+
+    assert(track-&gt;n_events &lt;= track-&gt;max_events);
+
+    if (track-&gt;n_events == track-&gt;max_events) {
+        track-&gt;max_events += ASS_EVENTS_ALLOC;
+        track-&gt;events =
+            (ass_event_t *) realloc(track-&gt;events,
+                                    sizeof(ass_event_t) *
+                                    track-&gt;max_events);
+    }
+
+    eid = track-&gt;n_events++;
+    memset(track-&gt;events + eid, 0, sizeof(ass_event_t));
+    return eid;
+}
+
+void ass_free_event(ass_track_t *track, int eid)
+{
+    ass_event_t *event = track-&gt;events + eid;
+    if (event-&gt;Name)
+        free(event-&gt;Name);
+    if (event-&gt;Effect)
+        free(event-&gt;Effect);
+    if (event-&gt;Text)
+        free(event-&gt;Text);
+    if (event-&gt;render_priv)
+        free(event-&gt;render_priv);
+}
+
+void ass_free_style(ass_track_t *track, int sid)
+{
+    ass_style_t *style = track-&gt;styles + sid;
+    if (style-&gt;Name)
+        free(style-&gt;Name);
+    if (style-&gt;FontName)
+        free(style-&gt;FontName);
+}
+
+// ==============================================================================================
+
+static void skip_spaces(char **str)
+{
+    char *p = *str;
+    while ((*p == ' ') || (*p == '\t'))
+        ++p;
+    *str = p;
+}
+
+static void rskip_spaces(char **str, char *limit)
+{
+    char *p = *str;
+    while ((p &gt;= limit) &amp;&amp; ((*p == ' ') || (*p == '\t')))
+        --p;
+    *str = p;
+}
+
+/**
+ * \brief find style by name
+ * \param track track
+ * \param name style name
+ * \return index in track-&gt;styles
+ * Returnes 0 if no styles found =&gt; expects at least 1 style.
+ * Parsing code always adds &quot;Default&quot; style in the end.
+ */
+static int lookup_style(ass_track_t *track, char *name)
+{
+    int i;
+    if (*name == '*')
+        ++name;                 // FIXME: what does '*' really mean ?
+    for (i = track-&gt;n_styles - 1; i &gt;= 0; --i) {
+        // FIXME: mb strcasecmp ?
+        if (strcmp(track-&gt;styles[i].Name, name) == 0)
+            return i;
+    }
+    i = track-&gt;default_style;
+    ass_msg(track-&gt;library, MSGL_WARN,
+            &quot;[%p]: Warning: no style named '%s' found, using '%s'&quot;,
+            track, name, track-&gt;styles[i].Name);
+    return i;                   // use the first style
+}
+
+static uint32_t string2color(ass_library_t *library, char *p)
+{
+    uint32_t tmp;
+    (void) strtocolor(library, &amp;p, &amp;tmp);
+    return tmp;
+}
+
+static long long string2timecode(ass_library_t *library, char *p)
+{
+    unsigned h, m, s, ms;
+    long long tm;
+    int res = sscanf(p, &quot;%1d:%2d:%2d.%2d&quot;, &amp;h, &amp;m, &amp;s, &amp;ms);
+    if (res &lt; 4) {
+        ass_msg(library, MSGL_WARN, &quot;Bad timestamp&quot;);
+        return 0;
+    }
+    tm = ((h * 60 + m) * 60 + s) * 1000 + ms * 10;
+    return tm;
+}
+
+/**
+ * \brief converts numpad-style align to align.
+ */
+static int numpad2align(int val)
+{
+    int res, v;
+    v = (val - 1) / 3;          // 0, 1 or 2 for vertical alignment
+    if (v != 0)
+        v = 3 - v;
+    res = ((val - 1) % 3) + 1;  // horizontal alignment
+    res += v * 4;
+    return res;
+}
+
+#define NEXT(str,token) \
+	token = next_token(&amp;str); \
+	if (!token) break;
+
+#define ANYVAL(name,func) \
+	} else if (strcasecmp(tname, #name) == 0) { \
+		target-&gt;name = func(token); \
+		ass_msg(track-&gt;library, MSGL_DBG2, &quot;%s = %s&quot;, #name, token);
+
+#define STRVAL(name) \
+	} else if (strcasecmp(tname, #name) == 0) { \
+		if (target-&gt;name != NULL) free(target-&gt;name); \
+		target-&gt;name = strdup(token); \
+		ass_msg(track-&gt;library, MSGL_DBG2, &quot;%s = %s&quot;, #name, token);
+
+#define COLORVAL(name) \
+	} else if (strcasecmp(tname, #name) == 0) { \
+		target-&gt;name = string2color(track-&gt;library, token); \
+		ass_msg(track-&gt;library, MSGL_DBG2, &quot;%s = %s&quot;, #name, token);
+
+#define INTVAL(name) ANYVAL(name,atoi)
+#define FPVAL(name) ANYVAL(name,atof)
+#define TIMEVAL(name) \
+	} else if (strcasecmp(tname, #name) == 0) { \
+		target-&gt;name = string2timecode(track-&gt;library, token); \
+		ass_msg(track-&gt;library, MSGL_DBG2, &quot;%s = %s&quot;, #name, token);
+
+#define STYLEVAL(name) \
+	} else if (strcasecmp(tname, #name) == 0) { \
+		target-&gt;name = lookup_style(track, token); \
+		ass_msg(track-&gt;library, MSGL_DBG2, &quot;%s = %s&quot;, #name, token);
+
+#define ALIAS(alias,name) \
+	if (strcasecmp(tname, #alias) == 0) {tname = #name;}
+
+static char *next_token(char **str)
+{
+    char *p = *str;
+    char *start;
+    skip_spaces(&amp;p);
+    if (*p == '\0') {
+        *str = p;
+        return 0;
+    }
+    start = p;                  // start of the token
+    for (; (*p != '\0') &amp;&amp; (*p != ','); ++p) {
+    }
+    if (*p == '\0') {
+        *str = p;               // eos found, str will point to '\0' at exit
+    } else {
+        *p = '\0';
+        *str = p + 1;           // ',' found, str will point to the next char (beginning of the next token)
+    }
+    --p;                        // end of current token
+    rskip_spaces(&amp;p, start);
+    if (p &lt; start)
+        p = start;              // empty token
+    else
+        ++p;                    // the first space character, or '\0'
+    *p = '\0';
+    return start;
+}
+
+/**
+ * \brief Parse the tail of Dialogue line
+ * \param track track
+ * \param event parsed data goes here
+ * \param str string to parse, zero-terminated
+ * \param n_ignored number of format options to skip at the beginning
+*/
+static int process_event_tail(ass_track_t *track, ass_event_t *event,
+                              char *str, int n_ignored)
+{
+    char *token;
+    char *tname;
+    char *p = str;
+    int i;
+    ass_event_t *target = event;
+
+    char *format = strdup(track-&gt;event_format);
+    char *q = format;           // format scanning pointer
+
+    if (track-&gt;n_styles == 0) {
+        // add &quot;Default&quot; style to the end
+        // will be used if track does not contain a default style (or even does not contain styles at all)
+        int sid = ass_alloc_style(track);
+        track-&gt;styles[sid].Name = strdup(&quot;Default&quot;);
+        track-&gt;styles[sid].FontName = strdup(&quot;Arial&quot;);
+    }
+
+    for (i = 0; i &lt; n_ignored; ++i) {
+        NEXT(q, tname);
+    }
+
+    while (1) {
+        NEXT(q, tname);
+        if (strcasecmp(tname, &quot;Text&quot;) == 0) {
+            char *last;
+            event-&gt;Text = strdup(p);
+            if (*event-&gt;Text != 0) {
+                last = event-&gt;Text + strlen(event-&gt;Text) - 1;
+                if (last &gt;= event-&gt;Text &amp;&amp; *last == '\r')
+                    *last = 0;
+            }
+            ass_msg(track-&gt;library, MSGL_DBG2, &quot;Text = %s&quot;, event-&gt;Text);
+            event-&gt;Duration -= event-&gt;Start;
+            free(format);
+            return 0;           // &quot;Text&quot; is always the last
+        }
+        NEXT(p, token);
+
+        ALIAS(End, Duration)    // temporarily store end timecode in event-&gt;Duration
+        if (0) {            // cool ;)
+            INTVAL(Layer)
+            STYLEVAL(Style)
+            STRVAL(Name)
+            STRVAL(Effect)
+            INTVAL(MarginL)
+            INTVAL(MarginR)
+            INTVAL(MarginV)
+            TIMEVAL(Start)
+            TIMEVAL(Duration)
+        }
+    }
+    free(format);
+    return 1;
+}
+
+/**
+ * \brief Parse command line style overrides (--ass-force-style option)
+ * \param track track to apply overrides to
+ * The format for overrides is [StyleName.]Field=Value
+ */
+void ass_process_force_style(ass_track_t *track)
+{
+    char **fs, *eq, *dt, *style, *tname, *token;
+    ass_style_t *target;
+    int sid;
+    char **list = track-&gt;library-&gt;style_overrides;
+
+    if (!list)
+        return;
+
+    for (fs = list; *fs; ++fs) {
+        eq = strrchr(*fs, '=');
+        if (!eq)
+            continue;
+        *eq = '\0';
+        token = eq + 1;
+
+        if (!strcasecmp(*fs, &quot;PlayResX&quot;))
+            track-&gt;PlayResX = atoi(token);
+        else if (!strcasecmp(*fs, &quot;PlayResY&quot;))
+            track-&gt;PlayResY = atoi(token);
+        else if (!strcasecmp(*fs, &quot;Timer&quot;))
+            track-&gt;Timer = atof(token);
+        else if (!strcasecmp(*fs, &quot;WrapStyle&quot;))
+            track-&gt;WrapStyle = atoi(token);
+        else if (!strcasecmp(*fs, &quot;ScaledBorderAndShadow&quot;))
+            track-&gt;ScaledBorderAndShadow = parse_bool(token);
+
+        dt = strrchr(*fs, '.');
+        if (dt) {
+            *dt = '\0';
+            style = *fs;
+            tname = dt + 1;
+        } else {
+            style = NULL;
+            tname = *fs;
+        }
+        for (sid = 0; sid &lt; track-&gt;n_styles; ++sid) {
+            if (style == NULL
+                || strcasecmp(track-&gt;styles[sid].Name, style) == 0) {
+                target = track-&gt;styles + sid;
+                if (0) {
+                    STRVAL(FontName)
+                    COLORVAL(PrimaryColour)
+                    COLORVAL(SecondaryColour)
+                    COLORVAL(OutlineColour)
+                    COLORVAL(BackColour)
+                    FPVAL(FontSize)
+                    INTVAL(Bold)
+                    INTVAL(Italic)
+                    INTVAL(Underline)
+                    INTVAL(StrikeOut)
+                    FPVAL(Spacing)
+                    INTVAL(Angle)
+                    INTVAL(BorderStyle)
+                    INTVAL(Alignment)
+                    INTVAL(MarginL)
+                    INTVAL(MarginR)
+                    INTVAL(MarginV)
+                    INTVAL(Encoding)
+                    FPVAL(ScaleX)
+                    FPVAL(ScaleY)
+                    FPVAL(Outline)
+                    FPVAL(Shadow)
+                }
+            }
+        }
+        *eq = '=';
+        if (dt)
+            *dt = '.';
+    }
+}
+
+/**
+ * \brief Parse the Style line
+ * \param track track
+ * \param str string to parse, zero-terminated
+ * Allocates a new style struct.
+*/
+static int process_style(ass_track_t *track, char *str)
+{
+
+    char *token;
+    char *tname;
+    char *p = str;
+    char *format;
+    char *q;                    // format scanning pointer
+    int sid;
+    ass_style_t *style;
+    ass_style_t *target;
+
+    if (!track-&gt;style_format) {
+        // no style format header
+        // probably an ancient script version
+        if (track-&gt;track_type == TRACK_TYPE_SSA)
+            track-&gt;style_format =
+                strdup
+                (&quot;Name, Fontname, Fontsize, PrimaryColour, SecondaryColour,&quot;
+                 &quot;TertiaryColour, BackColour, Bold, Italic, BorderStyle, Outline,&quot;
+                 &quot;Shadow, Alignment, MarginL, MarginR, MarginV, AlphaLevel, Encoding&quot;);
+        else
+            track-&gt;style_format =
+                strdup
+                (&quot;Name, Fontname, Fontsize, PrimaryColour, SecondaryColour,&quot;
+                 &quot;OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut,&quot;
+                 &quot;ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow,&quot;
+                 &quot;Alignment, MarginL, MarginR, MarginV, Encoding&quot;);
+    }
+
+    q = format = strdup(track-&gt;style_format);
+
+    ass_msg(track-&gt;library, MSGL_V, &quot;[%p] Style: %s&quot;, track, str);
+
+    sid = ass_alloc_style(track);
+
+    style = track-&gt;styles + sid;
+    target = style;
+// fill style with some default values
+    style-&gt;ScaleX = 100.;
+    style-&gt;ScaleY = 100.;
+
+    while (1) {
+        NEXT(q, tname);
+        NEXT(p, token);
+
+//              ALIAS(TertiaryColour,OutlineColour) // ignore TertiaryColour; it appears only in SSA, and is overridden by BackColour
+
+        if (0) {                // cool ;)
+            STRVAL(Name)
+            if ((strcmp(target-&gt;Name, &quot;Default&quot;) == 0)
+                || (strcmp(target-&gt;Name, &quot;*Default&quot;) == 0))
+            track-&gt;default_style = sid;
+            STRVAL(FontName)
+            COLORVAL(PrimaryColour)
+            COLORVAL(SecondaryColour)
+            COLORVAL(OutlineColour) // TertiaryColor
+            COLORVAL(BackColour)
+            // SSA uses BackColour for both outline and shadow
+            // this will destroy SSA's TertiaryColour, but i'm not going to use it anyway
+            if (track-&gt;track_type == TRACK_TYPE_SSA)
+                target-&gt;OutlineColour = target-&gt;BackColour;
+            FPVAL(FontSize)
+            INTVAL(Bold)
+            INTVAL(Italic)
+            INTVAL(Underline)
+            INTVAL(StrikeOut)
+            FPVAL(Spacing)
+            INTVAL(Angle)
+            INTVAL(BorderStyle)
+            INTVAL(Alignment)
+            if (track-&gt;track_type == TRACK_TYPE_ASS)
+                target-&gt;Alignment = numpad2align(target-&gt;Alignment);
+            INTVAL(MarginL)
+            INTVAL(MarginR)
+            INTVAL(MarginV)
+            INTVAL(Encoding)
+            FPVAL(ScaleX)
+            FPVAL(ScaleY)
+            FPVAL(Outline)
+            FPVAL(Shadow)
+        }
+    }
+    style-&gt;ScaleX /= 100.;
+    style-&gt;ScaleY /= 100.;
+    style-&gt;Bold = !!style-&gt;Bold;
+    style-&gt;Italic = !!style-&gt;Italic;
+    style-&gt;Underline = !!style-&gt;Underline;
+    if (!style-&gt;Name)
+        style-&gt;Name = strdup(&quot;Default&quot;);
+    if (!style-&gt;FontName)
+        style-&gt;FontName = strdup(&quot;Arial&quot;);
+    // skip '@' at the start of the font name
+    if (*style-&gt;FontName == '@') {
+        p = style-&gt;FontName;
+        style-&gt;FontName = strdup(p + 1);
+        free(p);
+    }
+    free(format);
+    return 0;
+
+}
+
+static int process_styles_line(ass_track_t *track, char *str)
+{
+    if (!strncmp(str, &quot;Format:&quot;, 7)) {
+        char *p = str + 7;
+        skip_spaces(&amp;p);
+        track-&gt;style_format = strdup(p);
+        ass_msg(track-&gt;library, MSGL_DBG2, &quot;Style format: %s&quot;,
+               track-&gt;style_format);
+    } else if (!strncmp(str, &quot;Style:&quot;, 6)) {
+        char *p = str + 6;
+        skip_spaces(&amp;p);
+        process_style(track, p);
+    }
+    return 0;
+}
+
+static int process_info_line(ass_track_t *track, char *str)
+{
+    if (!strncmp(str, &quot;PlayResX:&quot;, 9)) {
+        track-&gt;PlayResX = atoi(str + 9);
+    } else if (!strncmp(str, &quot;PlayResY:&quot;, 9)) {
+        track-&gt;PlayResY = atoi(str + 9);
+    } else if (!strncmp(str, &quot;Timer:&quot;, 6)) {
+        track-&gt;Timer = atof(str + 6);
+    } else if (!strncmp(str, &quot;WrapStyle:&quot;, 10)) {
+        track-&gt;WrapStyle = atoi(str + 10);
+    } else if (!strncmp(str, &quot;ScaledBorderAndShadow:&quot;, 22)) {
+        track-&gt;ScaledBorderAndShadow = parse_bool(str + 22);
+    }
+    return 0;
+}
+
+static void event_format_fallback(ass_track_t *track)
+{
+    track-&gt;parser_priv-&gt;state = PST_EVENTS;
+    if (track-&gt;track_type == TRACK_TYPE_SSA)
+        track-&gt;event_format = strdup(&quot;Format: Marked, Start, End, Style, &quot;
+            &quot;Name, MarginL, MarginR, MarginV, Effect, Text&quot;);
+    else
+        track-&gt;event_format = strdup(&quot;Format: Layer, Start, End, Style, &quot;
+            &quot;Actor, MarginL, MarginR, MarginV, Effect, Text&quot;);
+    ass_msg(track-&gt;library, MSGL_V,
+            &quot;No event format found, using fallback&quot;);
+}
+
+static int process_events_line(ass_track_t *track, char *str)
+{
+    if (!strncmp(str, &quot;Format:&quot;, 7)) {
+        char *p = str + 7;
+        skip_spaces(&amp;p);
+        track-&gt;event_format = strdup(p);
+        ass_msg(track-&gt;library, MSGL_DBG2, &quot;Event format: %s&quot;, track-&gt;event_format);
+    } else if (!strncmp(str, &quot;Dialogue:&quot;, 9)) {
+        // This should never be reached for embedded subtitles.
+        // They have slightly different format and are parsed in ass_process_chunk,
+        // called directly from demuxer
+        int eid;
+        ass_event_t *event;
+
+        str += 9;
+        skip_spaces(&amp;str);
+
+        eid = ass_alloc_event(track);
+        event = track-&gt;events + eid;
+
+        // We can't parse events with event_format
+        if (!track-&gt;event_format)
+            event_format_fallback(track);
+
+        process_event_tail(track, event, str, 0);
+    } else {
+        ass_msg(track-&gt;library, MSGL_V, &quot;Not understood: '%s'&quot;, str);
+    }
+    return 0;
+}
+
+// Copied from mkvtoolnix
+static unsigned char *decode_chars(unsigned char c1, unsigned char c2,
+                                   unsigned char c3, unsigned char c4,
+                                   unsigned char *dst, int cnt)
+{
+    uint32_t value;
+    unsigned char bytes[3];
+    int i;
+
+    value =
+        ((c1 - 33) &lt;&lt; 18) + ((c2 - 33) &lt;&lt; 12) + ((c3 - 33) &lt;&lt; 6) + (c4 -
+                                                                    33);
+    bytes[2] = value &amp; 0xff;
+    bytes[1] = (value &amp; 0xff00) &gt;&gt; 8;
+    bytes[0] = (value &amp; 0xff0000) &gt;&gt; 16;
+
+    for (i = 0; i &lt; cnt; ++i)
+        *dst++ = bytes[i];
+    return dst;
+}
+
+static int decode_font(ass_track_t *track)
+{
+    unsigned char *p;
+    unsigned char *q;
+    int i;
+    int size;                   // original size
+    int dsize;                  // decoded size
+    unsigned char *buf = 0;
+
+    ass_msg(track-&gt;library, MSGL_V, &quot;Font: %d bytes encoded data&quot;,
+            track-&gt;parser_priv-&gt;fontdata_used);
+    size = track-&gt;parser_priv-&gt;fontdata_used;
+    if (size % 4 == 1) {
+        ass_msg(track-&gt;library, MSGL_ERR, &quot;Bad encoded data size&quot;);
+        goto error_decode_font;
+    }
+    buf = malloc(size / 4 * 3 + 2);
+    q = buf;
+    for (i = 0, p = (unsigned char *) track-&gt;parser_priv-&gt;fontdata;
+         i &lt; size / 4; i++, p += 4) {
+        q = decode_chars(p[0], p[1], p[2], p[3], q, 3);
+    }
+    if (size % 4 == 2) {
+        q = decode_chars(p[0], p[1], 0, 0, q, 1);
+    } else if (size % 4 == 3) {
+        q = decode_chars(p[0], p[1], p[2], 0, q, 2);
+    }
+    dsize = q - buf;
+    assert(dsize &lt;= size / 4 * 3 + 2);
+
+    if (track-&gt;library-&gt;extract_fonts) {
+        ass_add_font(track-&gt;library, track-&gt;parser_priv-&gt;fontname,
+                     (char *) buf, dsize);
+        buf = 0;
+    }
+
+  error_decode_font:
+    if (buf)
+        free(buf);
+    free(track-&gt;parser_priv-&gt;fontname);
+    free(track-&gt;parser_priv-&gt;fontdata);
+    track-&gt;parser_priv-&gt;fontname = 0;
+    track-&gt;parser_priv-&gt;fontdata = 0;
+    track-&gt;parser_priv-&gt;fontdata_size = 0;
+    track-&gt;parser_priv-&gt;fontdata_used = 0;
+    return 0;
+}
+
+static int process_fonts_line(ass_track_t *track, char *str)
+{
+    int len;
+
+    if (!strncmp(str, &quot;fontname:&quot;, 9)) {
+        char *p = str + 9;
+        skip_spaces(&amp;p);
+        if (track-&gt;parser_priv-&gt;fontname) {
+            decode_font(track);
+        }
+        track-&gt;parser_priv-&gt;fontname = strdup(p);
+        ass_msg(track-&gt;library, MSGL_V, &quot;Fontname: %s&quot;,
+               track-&gt;parser_priv-&gt;fontname);
+        return 0;
+    }
+
+    if (!track-&gt;parser_priv-&gt;fontname) {
+        ass_msg(track-&gt;library, MSGL_V, &quot;Not understood: '%s'&quot;, str);
+        return 0;
+    }
+
+    len = strlen(str);
+    if (len &gt; 80) {
+        ass_msg(track-&gt;library, MSGL_WARN, &quot;Font line too long: %d, %s&quot;,
+                len, str);
+        return 0;
+    }
+    if (track-&gt;parser_priv-&gt;fontdata_used + len &gt;
+        track-&gt;parser_priv-&gt;fontdata_size) {
+        track-&gt;parser_priv-&gt;fontdata_size += 100 * 1024;
+        track-&gt;parser_priv-&gt;fontdata =
+            realloc(track-&gt;parser_priv-&gt;fontdata,
+                    track-&gt;parser_priv-&gt;fontdata_size);
+    }
+    memcpy(track-&gt;parser_priv-&gt;fontdata + track-&gt;parser_priv-&gt;fontdata_used,
+           str, len);
+    track-&gt;parser_priv-&gt;fontdata_used += len;
+
+    return 0;
+}
+
+/**
+ * \brief Parse a header line
+ * \param track track
+ * \param str string to parse, zero-terminated
+*/
+static int process_line(ass_track_t *track, char *str)
+{
+    if (!strncasecmp(str, &quot;[Script Info]&quot;, 13)) {
+        track-&gt;parser_priv-&gt;state = PST_INFO;
+    } else if (!strncasecmp(str, &quot;[V4 Styles]&quot;, 11)) {
+        track-&gt;parser_priv-&gt;state = PST_STYLES;
+        track-&gt;track_type = TRACK_TYPE_SSA;
+    } else if (!strncasecmp(str, &quot;[V4+ Styles]&quot;, 12)) {
+        track-&gt;parser_priv-&gt;state = PST_STYLES;
+        track-&gt;track_type = TRACK_TYPE_ASS;
+    } else if (!strncasecmp(str, &quot;[Events]&quot;, 8)) {
+        track-&gt;parser_priv-&gt;state = PST_EVENTS;
+    } else if (!strncasecmp(str, &quot;[Fonts]&quot;, 7)) {
+        track-&gt;parser_priv-&gt;state = PST_FONTS;
+    } else {
+        switch (track-&gt;parser_priv-&gt;state) {
+        case PST_INFO:
+            process_info_line(track, str);
+            break;
+        case PST_STYLES:
+            process_styles_line(track, str);
+            break;
+        case PST_EVENTS:
+            process_events_line(track, str);
+            break;
+        case PST_FONTS:
+            process_fonts_line(track, str);
+            break;
+        default:
+            break;
+        }
+    }
+
+    // there is no explicit end-of-font marker in ssa/ass
+    if ((track-&gt;parser_priv-&gt;state != PST_FONTS)
+        &amp;&amp; (track-&gt;parser_priv-&gt;fontname))
+        decode_font(track);
+
+    return 0;
+}
+
+static int process_text(ass_track_t *track, char *str)
+{
+    char *p = str;
+    while (1) {
+        char *q;
+        while (1) {
+            if ((*p == '\r') || (*p == '\n'))
+                ++p;
+            else if (p[0] == '\xef' &amp;&amp; p[1] == '\xbb' &amp;&amp; p[2] == '\xbf')
+                p += 3;         // U+FFFE (BOM)
+            else
+                break;
+        }
+        for (q = p; ((*q != '\0') &amp;&amp; (*q != '\r') &amp;&amp; (*q != '\n')); ++q) {
+        };
+        if (q == p)
+            break;
+        if (*q != '\0')
+            *(q++) = '\0';
+        process_line(track, p);
+        if (*q == '\0')
+            break;
+        p = q;
+    }
+    return 0;
+}
+
+/**
+ * \brief Process a chunk of subtitle stream data.
+ * \param track track
+ * \param data string to parse
+ * \param size length of data
+*/
+void ass_process_data(ass_track_t *track, char *data, int size)
+{
+    char *str = malloc(size + 1);
+
+    memcpy(str, data, size);
+    str[size] = '\0';
+
+    ass_msg(track-&gt;library, MSGL_V, &quot;Event: %s&quot;, str);
+    process_text(track, str);
+    free(str);
+}
+
+/**
+ * \brief Process CodecPrivate section of subtitle stream
+ * \param track track
+ * \param data string to parse
+ * \param size length of data
+ CodecPrivate section contains [Stream Info] and [V4+ Styles] ([V4 Styles] for SSA) sections
+*/
+void ass_process_codec_private(ass_track_t *track, char *data, int size)
+{
+    ass_process_data(track, data, size);
+
+    // probably an mkv produced by ancient mkvtoolnix
+    // such files don't have [Events] and Format: headers
+    if (!track-&gt;event_format)
+        event_format_fallback(track);
+
+    ass_process_force_style(track);
+}
+
+static int check_duplicate_event(ass_track_t *track, int ReadOrder)
+{
+    int i;
+    for (i = 0; i &lt; track-&gt;n_events - 1; ++i)   // ignoring last event, it is the one we are comparing with
+        if (track-&gt;events[i].ReadOrder == ReadOrder)
+            return 1;
+    return 0;
+}
+
+/**
+ * \brief Process a chunk of subtitle stream data. In Matroska, this contains exactly 1 event (or a commentary).
+ * \param track track
+ * \param data string to parse
+ * \param size length of data
+ * \param timecode starting time of the event (milliseconds)
+ * \param duration duration of the event (milliseconds)
+*/
+void ass_process_chunk(ass_track_t *track, char *data, int size,
+                       long long timecode, long long duration)
+{
+    char *str;
+    int eid;
+    char *p;
+    char *token;
+    ass_event_t *event;
+
+    if (!track-&gt;event_format) {
+        ass_msg(track-&gt;library, MSGL_WARN, &quot;Event format header missing&quot;);
+        return;
+    }
+
+    str = malloc(size + 1);
+    memcpy(str, data, size);
+    str[size] = '\0';
+    ass_msg(track-&gt;library, MSGL_V, &quot;Event at %&quot; PRId64 &quot;, +%&quot; PRId64 &quot;: %s&quot;,
+           (int64_t) timecode, (int64_t) duration, str);
+
+    eid = ass_alloc_event(track);
+    event = track-&gt;events + eid;
+
+    p = str;
+
+    do {
+        NEXT(p, token);
+        event-&gt;ReadOrder = atoi(token);
+        if (check_duplicate_event(track, event-&gt;ReadOrder))
+            break;
+
+        NEXT(p, token);
+        event-&gt;Layer = atoi(token);
+
+        process_event_tail(track, event, p, 3);
+
+        event-&gt;Start = timecode;
+        event-&gt;Duration = duration;
+
+        free(str);
+        return;
+//              dump_events(tid);
+    } while (0);
+    // some error
+    ass_free_event(track, eid);
+    track-&gt;n_events--;
+    free(str);
+}
+
+#ifdef CONFIG_ICONV
+/** \brief recode buffer to utf-8
+ * constraint: codepage != 0
+ * \param data pointer to text buffer
+ * \param size buffer size
+ * \return a pointer to recoded buffer, caller is responsible for freeing it
+**/
+static char *sub_recode(ass_library_t *library, char *data, size_t size,
+                        char *codepage)
+{
+    iconv_t icdsc;
+    char *tocp = &quot;UTF-8&quot;;
+    char *outbuf;
+    assert(codepage);
+
+    {
+        const char *cp_tmp = codepage;
+#ifdef CONFIG_ENCA
+        char enca_lang[3], enca_fallback[100];
+        if (sscanf(codepage, &quot;enca:%2s:%99s&quot;, enca_lang, enca_fallback) == 2
+            || sscanf(codepage, &quot;ENCA:%2s:%99s&quot;, enca_lang,
+                      enca_fallback) == 2) {
+            cp_tmp =
+                ass_guess_buffer_cp(library, (unsigned char *) data, size,
+                                    enca_lang, enca_fallback);
+        }
+#endif
+        if ((icdsc = iconv_open(tocp, cp_tmp)) != (iconv_t) (-1)) {
+            ass_msg(library, MSGL_V, &quot;Opened iconv descriptor&quot;);
+        } else
+            ass_msg(library, MSGL_ERR, &quot;Error opening iconv descriptor&quot;);
+    }
+
+    {
+        size_t osize = size;
+        size_t ileft = size;
+        size_t oleft = size - 1;
+        char *ip;
+        char *op;
+        size_t rc;
+        int clear = 0;
+
+        outbuf = malloc(osize);
+        ip = data;
+        op = outbuf;
+
+        while (1) {
+            if (ileft)
+                rc = iconv(icdsc, &amp;ip, &amp;ileft, &amp;op, &amp;oleft);
+            else {              // clear the conversion state and leave
+                clear = 1;
+                rc = iconv(icdsc, NULL, NULL, &amp;op, &amp;oleft);
+            }
+            if (rc == (size_t) (-1)) {
+                if (errno == E2BIG) {
+                    size_t offset = op - outbuf;
+                    outbuf = (char *) realloc(outbuf, osize + size);
+                    op = outbuf + offset;
+                    osize += size;
+                    oleft += size;
+                } else {
+                    ass_msg(library, MSGL_WARN, &quot;Error recoding file&quot;);
+                    return NULL;
+                }
+            } else if (clear)
+                break;
+        }
+        outbuf[osize - oleft - 1] = 0;
+    }
+
+    if (icdsc != (iconv_t) (-1)) {
+        (void) iconv_close(icdsc);
+        icdsc = (iconv_t) (-1);
+        ass_msg(library, MSGL_V, &quot;Closed iconv descriptor&quot;);
+    }
+
+    return outbuf;
+}
+#endif                          // ICONV
+
+/**
+ * \brief read file contents into newly allocated buffer
+ * \param fname file name
+ * \param bufsize out: file size
+ * \return pointer to file contents. Caller is responsible for its deallocation.
+ */
+static char *read_file(ass_library_t *library, char *fname, size_t *bufsize)
+{
+    int res;
+    long sz;
+    long bytes_read;
+    char *buf;
+
+    FILE *fp = fopen(fname, &quot;rb&quot;);
+    if (!fp) {
+        ass_msg(library, MSGL_WARN,
+                &quot;ass_read_file(%s): fopen failed&quot;, fname);
+        return 0;
+    }
+    res = fseek(fp, 0, SEEK_END);
+    if (res == -1) {
+        ass_msg(library, MSGL_WARN,
+                &quot;ass_read_file(%s): fseek failed&quot;, fname);
+        fclose(fp);
+        return 0;
+    }
+
+    sz = ftell(fp);
+    rewind(fp);
+
+    if (sz &gt; 10 * 1024 * 1024) {
+        ass_msg(library, MSGL_INFO,
+               &quot;ass_read_file(%s): Refusing to load subtitles &quot;
+               &quot;larger than 10MiB&quot;, fname);
+        fclose(fp);
+        return 0;
+    }
+
+    ass_msg(library, MSGL_V, &quot;File size: %ld&quot;, sz);
+
+    buf = malloc(sz + 1);
+    assert(buf);
+    bytes_read = 0;
+    do {
+        res = fread(buf + bytes_read, 1, sz - bytes_read, fp);
+        if (res &lt;= 0) {
+            ass_msg(library, MSGL_INFO, &quot;Read failed, %d: %s&quot;, errno,
+                    strerror(errno));
+            fclose(fp);
+            free(buf);
+            return 0;
+        }
+        bytes_read += res;
+    } while (sz - bytes_read &gt; 0);
+    buf[sz] = '\0';
+    fclose(fp);
+
+    if (bufsize)
+        *bufsize = sz;
+    return buf;
+}
+
+/*
+ * \param buf pointer to subtitle text in utf-8
+ */
+static ass_track_t *parse_memory(ass_library_t *library, char *buf)
+{
+    ass_track_t *track;
+    int i;
+
+    track = ass_new_track(library);
+
+    // process header
+    process_text(track, buf);
+
+    // external SSA/ASS subs does not have ReadOrder field
+    for (i = 0; i &lt; track-&gt;n_events; ++i)
+        track-&gt;events[i].ReadOrder = i;
+
+    // there is no explicit end-of-font marker in ssa/ass
+    if (track-&gt;parser_priv-&gt;fontname)
+        decode_font(track);
+
+    if (track-&gt;track_type == TRACK_TYPE_UNKNOWN) {
+        ass_free_track(track);
+        return 0;
+    }
+
+    ass_process_force_style(track);
+
+    return track;
+}
+
+/**
+ * \brief Read subtitles from memory.
+ * \param library libass library object
+ * \param buf pointer to subtitles text
+ * \param bufsize size of buffer
+ * \param codepage recode buffer contents from given codepage
+ * \return newly allocated track
+*/
+ass_track_t *ass_read_memory(ass_library_t *library, char *buf,
+                             size_t bufsize, char *codepage)
+{
+    ass_track_t *track;
+    int need_free = 0;
+
+    if (!buf)
+        return 0;
+
+#ifdef CONFIG_ICONV
+    if (codepage)
+        buf = sub_recode(library, buf, bufsize, codepage);
+    if (!buf)
+        return 0;
+    else
+        need_free = 1;
+#endif
+    track = parse_memory(library, buf);
+    if (need_free)
+        free(buf);
+    if (!track)
+        return 0;
+
+    ass_msg(library, MSGL_INFO, &quot;Added subtitle file: &quot;
+            &quot;&lt;memory&gt; (%d styles, %d events)&quot;,
+            track-&gt;n_styles, track-&gt;n_events);
+    return track;
+}
+
+static char *read_file_recode(ass_library_t *library, char *fname,
+                              char *codepage, size_t *size)
+{
+    char *buf;
+    size_t bufsize;
+
+    buf = read_file(library, fname, &amp;bufsize);
+    if (!buf)
+        return 0;
+#ifdef CONFIG_ICONV
+    if (codepage) {
+        char *tmpbuf = sub_recode(library, buf, bufsize, codepage);
+        free(buf);
+        buf = tmpbuf;
+    }
+    if (!buf)
+        return 0;
+#endif
+    *size = bufsize;
+    return buf;
+}
+
+/**
+ * \brief Read subtitles from file.
+ * \param library libass library object
+ * \param fname file name
+ * \param codepage recode buffer contents from given codepage
+ * \return newly allocated track
+*/
+ass_track_t *ass_read_file(ass_library_t *library, char *fname,
+                           char *codepage)
+{
+    char *buf;
+    ass_track_t *track;
+    size_t bufsize;
+
+    buf = read_file_recode(library, fname, codepage, &amp;bufsize);
+    if (!buf)
+        return 0;
+    track = parse_memory(library, buf);
+    free(buf);
+    if (!track)
+        return 0;
+
+    track-&gt;name = strdup(fname);
+
+    ass_msg(library, MSGL_INFO,
+            &quot;Added subtitle file: '%s' (%d styles, %d events)&quot;,
+            fname, track-&gt;n_styles, track-&gt;n_events);
+
+    return track;
+}
+
+/**
+ * \brief read styles from file into already initialized track
+ */
+int ass_read_styles(ass_track_t *track, char *fname, char *codepage)
+{
+    char *buf;
+    parser_state_t old_state;
+    size_t sz;
+
+    buf = read_file(track-&gt;library, fname, &amp;sz);
+    if (!buf)
+        return 1;
+#ifdef CONFIG_ICONV
+    if (codepage) {
+        char *tmpbuf;
+        tmpbuf = sub_recode(track-&gt;library, buf, sz, codepage);
+        free(buf);
+        buf = tmpbuf;
+    }
+    if (!buf)
+        return 0;
+#endif
+
+    old_state = track-&gt;parser_priv-&gt;state;
+    track-&gt;parser_priv-&gt;state = PST_STYLES;
+    process_text(track, buf);
+    track-&gt;parser_priv-&gt;state = old_state;
+
+    return 0;
+}
+
+long long ass_step_sub(ass_track_t *track, long long now, int movement)
+{
+    int i;
+
+    if (movement == 0)
+        return 0;
+    if (track-&gt;n_events == 0)
+        return 0;
+
+    if (movement &lt; 0)
+        for (i = 0;
+             (i &lt; track-&gt;n_events)
+             &amp;&amp;
+             ((long long) (track-&gt;events[i].Start +
+                           track-&gt;events[i].Duration) &lt;= now); ++i) {
+    } else
+        for (i = track-&gt;n_events - 1;
+             (i &gt;= 0) &amp;&amp; ((long long) (track-&gt;events[i].Start) &gt; now);
+             --i) {
+        }
+
+    // -1 and n_events are ok
+    assert(i &gt;= -1);
+    assert(i &lt;= track-&gt;n_events);
+    i += movement;
+    if (i &lt; 0)
+        i = 0;
+    if (i &gt;= track-&gt;n_events)
+        i = track-&gt;n_events - 1;
+    return ((long long) track-&gt;events[i].Start) - now;
+}
+
+ass_track_t *ass_new_track(ass_library_t *library)
+{
+    ass_track_t *track = calloc(1, sizeof(ass_track_t));
+    track-&gt;library = library;
+    track-&gt;ScaledBorderAndShadow = 1;
+    track-&gt;parser_priv = calloc(1, sizeof(parser_priv_t));
+    return track;
+}

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass.h	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass.h	2009-08-01 07:55:22 UTC (rev 5185)
@@ -0,0 +1,371 @@
+/*
+ * Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+ *
+ * This file is part of libass.
+ *
+ * libass is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libass is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with libass; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef LIBASS_ASS_H
+#define LIBASS_ASS_H
+
+#include &lt;stdio.h&gt;
+#include &lt;stdarg.h&gt;
+#include &quot;ass_types.h&quot;
+
+#define LIBASS_VERSION 0x00907000
+
+/*
+ * A linked list of images produced by an ass renderer.
+ *
+ * These images have to be rendered in-order for the correct screen
+ * composition.  The libass renderer clips these bitmaps to the frame size.
+ * w/h can be zero, in this case the bitmap should not be rendered at all.
+ * The last bitmap row is not guaranteed to be padded up to stride size,
+ * e.g. in the worst case a bitmap has the size stride * (h - 1) + w.
+ */
+typedef struct ass_image {
+    int w, h;                   // Bitmap width/height
+    int stride;                 // Bitmap stride
+    unsigned char *bitmap;      // 1bpp stride*h alpha buffer
+                                // Note: the last row may not be padded to
+                                // bitmap stride!
+    uint32_t color;             // Bitmap color and alpha, RGBA
+    int dst_x, dst_y;           // Bitmap placement inside the video frame
+
+    struct ass_image *next;   // Next image, or NULL
+} ass_image_t;
+
+/*
+ * Hintint type. (see ass_set_hinting below)
+ *
+ * FreeType's native hinter is still buggy sometimes and it is recommended
+ * to use the light autohinter, ASS_HINTING_LIGHT, instead.  For best
+ * compatibility with problematic fonts, disable hinting.
+ */
+typedef enum {
+    ASS_HINTING_NONE = 0,
+    ASS_HINTING_LIGHT,
+    ASS_HINTING_NORMAL,
+    ASS_HINTING_NATIVE
+} ass_hinting_t;
+
+/**
+ * \brief Initialize the library.
+ * \return library handle or NULL if failed
+ */
+ass_library_t *ass_library_init(void);
+
+/**
+ * \brief Finalize the library
+ * \param priv library handle
+ */
+void ass_library_done(ass_library_t *);
+
+/**
+ * \brief Set private font directory.
+ * It is used for saving embedded fonts and also in font lookup.
+ *
+ * \param priv library handle
+ * \param fonts_dir private directory for font extraction
+ */
+void ass_set_fonts_dir(ass_library_t *priv, const char *fonts_dir);
+
+/**
+ * \brief Whether fonts should be extracted from track data.
+ * \param priv library handle
+ * \param extract whether to extract fonts
+ */
+void ass_set_extract_fonts(ass_library_t *priv, int extract);
+
+/**
+ * \brief Register style overrides with a library instance.
+ * The overrides should have the form [Style.]Param=Value, e.g.
+ *   SomeStyle.Font=Arial
+ *   ScaledBorderAndShadow=yes
+ *
+ * \param priv library handle
+ * \param list NULL-terminated list of strings
+ */
+void ass_set_style_overrides(ass_library_t *priv, char **list);
+
+/**
+ * \brief Explicitly process style overrides for a track.
+ * \param track track handle
+ */
+void ass_process_force_style(ass_track_t *track);
+
+/**
+ * \brief Register a callback for debug/info messages.
+ * If a callback is registered, it is called for every message emitted by
+ * libass.  The callback receives a format string and a list of arguments,
+ * to be used for the printf family of functions. Additionally, a log level
+ * from 0 (FATAL errors) to 7 (verbose DEBUG) is passed.  Usually, level 5
+ * should be used by applications.
+ * If no callback is set, all messages level &lt; 5 are printed to stderr,
+ * prefixed with [ass].
+ *
+ * \param priv library handle
+ * \param msg_cb pointer to callback function
+ * \param data additional data, will be passed to callback
+ */
+void ass_set_message_cb(ass_library_t *priv, void (*msg_cb)
+                        (int level, const char *fmt, va_list args, void *data),
+                        void *data);
+
+/**
+ * \brief Initialize the renderer.
+ * \param priv library handle
+ * \return renderer handle or NULL if failed
+ */
+ass_renderer_t *ass_renderer_init(ass_library_t *);
+
+/**
+ * \brief Finalize the renderer.
+ * \param priv renderer handle
+ */
+void ass_renderer_done(ass_renderer_t *priv);
+
+/**
+ * \brief Set the frame size in pixels, including margins.
+ * \param priv renderer handle
+ * \param w width
+ * \param h height
+ */
+void ass_set_frame_size(ass_renderer_t *priv, int w, int h);
+
+/**
+ * \brief Set frame margins.  These values may be negative if pan-and-scan
+ * is used.
+ * \param priv renderer handle
+ * \param t top margin
+ * \param b bottom margin
+ * \param l left margin
+ * \param r right margin
+ */
+void ass_set_margins(ass_renderer_t *priv, int t, int b, int l, int r);
+
+/**
+ * \brief Whether margins should be used for placing regular events.
+ * \param priv renderer handle
+ * \param use whether to use the margins
+ */
+void ass_set_use_margins(ass_renderer_t *priv, int use);
+
+/**
+ * \brief Set aspect ratio parameters.
+ * \param priv renderer handle
+ * \param ar physical aspect ratio
+ * \param par pixel ratio, e.g. width / height of the video
+ */
+void ass_set_aspect_ratio(ass_renderer_t *priv, double ar, double par);
+
+/**
+ * \brief Set a fixed font scaling factor.
+ * \param priv renderer handle
+ * \param font_scale scaling factor, default is 1.0
+ */
+void ass_set_font_scale(ass_renderer_t *priv, double font_scale);
+
+/**
+ * \brief Set font hinting method.
+ * \param priv renderer handle
+ * \param ht hinting method
+ */
+void ass_set_hinting(ass_renderer_t *priv, ass_hinting_t ht);
+
+/**
+ * \brief Set line spacing. Will not be scaled with frame size.
+ * \param priv renderer handle
+ * \param line_spacing line spacing in pixels
+ */
+void ass_set_line_spacing(ass_renderer_t *priv, double line_spacing);
+
+/**
+ * \brief Set font lookup defaults.
+ * \param fc whether to use fontconfig
+ * \param config path to fontconfig configuration file, or NULL.  Only relevant
+ * if fontconfig is used.
+ * \param update whether fontconfig cache should be built/updated now.  Only
+ * relevant if fontconfig is used.
+ */
+void ass_set_fonts(ass_renderer_t *priv, const char *default_font,
+                   const char *default_family, int fc, const char *config,
+                   int update);
+
+/**
+ * \brief Update/build font cache.  This needs to be called if it was
+ * disabled when ass_set_fonts was set.
+ *
+ * \param priv renderer handle
+ * \return success
+ */
+int ass_fonts_update(ass_renderer_t *priv);
+
+/**
+ * \brief Set hard cache limits.  Do not set, or set to zero, for reasonable
+ * defaults.
+ *
+ * \param priv renderer handle
+ * \param glyph_max maximum number of cached glyphs
+ * \param bitmap_max_size maximum bitmap cache size (in MB)
+ */
+void ass_set_cache_limits(ass_renderer_t *priv, int glyph_max,
+                          int bitmap_max_size);
+
+/**
+ * \brief Render a frame, producing a list of ass_image_t.
+ * \param priv renderer handle
+ * \param track subtitle track
+ * \param now video timestamp in milliseconds
+ * \param detect_change will be set to 1 if a change occured compared
+ * to the last invocation
+ */
+ass_image_t *ass_render_frame(ass_renderer_t *priv, ass_track_t *track,
+                              long long now, int *detect_change);
+
+
+/*
+ * The following functions operate on track objects and do not need
+ * an ass_renderer
+ */
+
+/**
+ * \brief Allocate a new empty track object.
+ * \param library handle
+ * \return pointer to empty track
+ */
+ass_track_t *ass_new_track(ass_library_t *);
+
+/**
+ * \brief Deallocate track and all its child objects (styles and events).
+ * \param track track to deallocate
+ */
+void ass_free_track(ass_track_t *track);
+
+/**
+ * \brief Allocate new style.
+ * \param track track
+ * \return newly allocated style id
+ */
+int ass_alloc_style(ass_track_t *track);
+
+/**
+ * \brief Allocate new event.
+ * \param track track
+ * \return newly allocated event id
+ */
+int ass_alloc_event(ass_track_t *track);
+
+/**
+ * \brief Delete a style.
+ * \param track track
+ * \param sid style id
+ * Deallocates style data. Does not modify track-&gt;n_styles.
+ */
+void ass_free_style(ass_track_t *track, int sid);
+
+/**
+ * \brief Delete an event.
+ * \param track track
+ * \param eid event id
+ * Deallocates event data. Does not modify track-&gt;n_events.
+ */
+void ass_free_event(ass_track_t *track, int eid);
+
+/**
+ * \brief Parse a chunk of subtitle stream data.
+ * \param track track
+ * \param data string to parse
+ * \param size length of data
+ */
+void ass_process_data(ass_track_t *track, char *data, int size);
+
+/**
+ * \brief Parse Codec Private section of subtitle stream.
+ * \param track target track
+ * \param data string to parse
+ * \param size length of data
+ */
+void ass_process_codec_private(ass_track_t *track, char *data, int size);
+
+/**
+ * \brief Parse a chunk of subtitle stream data. In Matroska,
+ * this contains exactly 1 event (or a commentary).
+ * \param track track
+ * \param data string to parse
+ * \param size length of data
+ * \param timecode starting time of the event (milliseconds)
+ * \param duration duration of the event (milliseconds)
+ */
+void ass_process_chunk(ass_track_t *track, char *data, int size,
+                       long long timecode, long long duration);
+
+/**
+ * \brief Read subtitles from file.
+ * \param library library handle
+ * \param fname file name
+ * \param codepage encoding (iconv format)
+ * \return newly allocated track
+*/
+ass_track_t *ass_read_file(ass_library_t *library, char *fname,
+                           char *codepage);
+
+/**
+ * \brief Read subtitles from memory.
+ * \param library library handle
+ * \param buf pointer to subtitles text
+ * \param bufsize size of buffer
+ * \param codepage encoding (iconv format)
+ * \return newly allocated track
+*/
+ass_track_t *ass_read_memory(ass_library_t *library, char *buf,
+                             size_t bufsize, char *codepage);
+/**
+ * \brief Read styles from file into already initialized track.
+ * \param fname file name
+ * \param codepage encoding (iconv format)
+ * \return 0 on success
+ */
+int ass_read_styles(ass_track_t *track, char *fname, char *codepage);
+
+/**
+ * \brief Add a memory font.
+ * \param library library handle
+ * \param name attachment name
+ * \param data binary font data
+ * \param data_size data size
+*/
+void ass_add_font(ass_library_t *library, char *name, char *data,
+                  int data_size);
+
+/**
+ * \brief Remove all fonts stored in an ass_library object.
+ * \param library library handle
+ */
+void ass_clear_fonts(ass_library_t *library);
+
+/**
+ * \brief Calculates timeshift from now to the start of some other subtitle
+ * event, depending on movement parameter.
+ * \param track subtitle track
+ * \param now current time in milliseconds
+ * \param movement how many events to skip from the one currently displayed
+ * +2 means &quot;the one after the next&quot;, -1 means &quot;previous&quot;
+ * \return timeshift in milliseconds
+ */
+long long ass_step_sub(ass_track_t *track, long long now, int movement);
+
+#endif /* LIBASS_ASS_H */

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_bitmap.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_bitmap.c	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_bitmap.c	2009-08-01 07:55:22 UTC (rev 5185)
@@ -0,0 +1,540 @@
+/*
+ * Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+ *
+ * This file is part of libass.
+ *
+ * libass is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libass is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with libass; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;math.h&gt;
+#include &lt;assert.h&gt;
+#include &lt;ft2build.h&gt;
+#include FT_GLYPH_H
+
+#include &quot;ass_utils.h&quot;
+#include &quot;ass_bitmap.h&quot;
+
+struct ass_synth_priv {
+    int tmp_w, tmp_h;
+    unsigned short *tmp;
+
+    int g_r;
+    int g_w;
+
+    unsigned *g;
+    unsigned *gt2;
+
+    double radius;
+};
+
+static const unsigned int maxcolor = 255;
+static const unsigned base = 256;
+
+static int generate_tables(ass_synth_priv_t *priv, double radius)
+{
+    double A = log(1.0 / base) / (radius * radius * 2);
+    int mx, i;
+    double volume_diff, volume_factor = 0;
+    unsigned volume;
+
+    if (priv-&gt;radius == radius)
+        return 0;
+    else
+        priv-&gt;radius = radius;
+
+    priv-&gt;g_r = ceil(radius);
+    priv-&gt;g_w = 2 * priv-&gt;g_r + 1;
+
+    if (priv-&gt;g_r) {
+        priv-&gt;g = realloc(priv-&gt;g, priv-&gt;g_w * sizeof(unsigned));
+        priv-&gt;gt2 = realloc(priv-&gt;gt2, 256 * priv-&gt;g_w * sizeof(unsigned));
+        if (priv-&gt;g == NULL || priv-&gt;gt2 == NULL) {
+            return -1;
+        }
+    }
+
+    if (priv-&gt;g_r) {
+        // gaussian curve with volume = 256
+        for (volume_diff = 10000000; volume_diff &gt; 0.0000001;
+             volume_diff *= 0.5) {
+            volume_factor += volume_diff;
+            volume = 0;
+            for (i = 0; i &lt; priv-&gt;g_w; ++i) {
+                priv-&gt;g[i] =
+                    (unsigned) (exp(A * (i - priv-&gt;g_r) * (i - priv-&gt;g_r)) *
+                                volume_factor + .5);
+                volume += priv-&gt;g[i];
+            }
+            if (volume &gt; 256)
+                volume_factor -= volume_diff;
+        }
+        volume = 0;
+        for (i = 0; i &lt; priv-&gt;g_w; ++i) {
+            priv-&gt;g[i] =
+                (unsigned) (exp(A * (i - priv-&gt;g_r) * (i - priv-&gt;g_r)) *
+                            volume_factor + .5);
+            volume += priv-&gt;g[i];
+        }
+
+        // gauss table:
+        for (mx = 0; mx &lt; priv-&gt;g_w; mx++) {
+            for (i = 0; i &lt; 256; i++) {
+                priv-&gt;gt2[mx + i * priv-&gt;g_w] = i * priv-&gt;g[mx];
+            }
+        }
+    }
+
+    return 0;
+}
+
+static void resize_tmp(ass_synth_priv_t *priv, int w, int h)
+{
+    if (priv-&gt;tmp_w &gt;= w &amp;&amp; priv-&gt;tmp_h &gt;= h)
+        return;
+    if (priv-&gt;tmp_w == 0)
+        priv-&gt;tmp_w = 64;
+    if (priv-&gt;tmp_h == 0)
+        priv-&gt;tmp_h = 64;
+    while (priv-&gt;tmp_w &lt; w)
+        priv-&gt;tmp_w *= 2;
+    while (priv-&gt;tmp_h &lt; h)
+        priv-&gt;tmp_h *= 2;
+    if (priv-&gt;tmp)
+        free(priv-&gt;tmp);
+    priv-&gt;tmp = malloc((priv-&gt;tmp_w + 1) * priv-&gt;tmp_h * sizeof(short));
+}
+
+ass_synth_priv_t *ass_synth_init(double radius)
+{
+    ass_synth_priv_t *priv = calloc(1, sizeof(ass_synth_priv_t));
+    generate_tables(priv, radius);
+    return priv;
+}
+
+void ass_synth_done(ass_synth_priv_t *priv)
+{
+    if (priv-&gt;tmp)
+        free(priv-&gt;tmp);
+    if (priv-&gt;g)
+        free(priv-&gt;g);
+    if (priv-&gt;gt2)
+        free(priv-&gt;gt2);
+    free(priv);
+}
+
+static bitmap_t *alloc_bitmap(int w, int h)
+{
+    bitmap_t *bm;
+    bm = calloc(1, sizeof(bitmap_t));
+    bm-&gt;buffer = malloc(w * h);
+    bm-&gt;w = w;
+    bm-&gt;h = h;
+    bm-&gt;left = bm-&gt;top = 0;
+    return bm;
+}
+
+void ass_free_bitmap(bitmap_t *bm)
+{
+    if (bm) {
+        if (bm-&gt;buffer)
+            free(bm-&gt;buffer);
+        free(bm);
+    }
+}
+
+static bitmap_t *copy_bitmap(const bitmap_t *src)
+{
+    bitmap_t *dst = alloc_bitmap(src-&gt;w, src-&gt;h);
+    dst-&gt;left = src-&gt;left;
+    dst-&gt;top = src-&gt;top;
+    memcpy(dst-&gt;buffer, src-&gt;buffer, src-&gt;w * src-&gt;h);
+    return dst;
+}
+
+static int check_glyph_area(ass_library_t *library, FT_Glyph glyph)
+{
+    FT_BBox bbox;
+    long long dx, dy;
+    FT_Glyph_Get_CBox(glyph, FT_GLYPH_BBOX_TRUNCATE, &amp;bbox);
+    dx = bbox.xMax - bbox.xMin;
+    dy = bbox.yMax - bbox.yMin;
+    if (dx * dy &gt; 8000000) {
+        ass_msg(library, MSGL_WARN, &quot;Glyph bounding box too large: %dx%dpx&quot;,
+               (int) dx, (int) dy);
+        return 1;
+    } else
+        return 0;
+}
+
+static bitmap_t *glyph_to_bitmap_internal(ass_library_t *library,
+                                          FT_Glyph glyph, int bord)
+{
+    FT_BitmapGlyph bg;
+    FT_Bitmap *bit;
+    bitmap_t *bm;
+    int w, h;
+    unsigned char *src;
+    unsigned char *dst;
+    int i;
+    int error;
+
+    if (check_glyph_area(library, glyph))
+        return 0;
+    error = FT_Glyph_To_Bitmap(&amp;glyph, FT_RENDER_MODE_NORMAL, 0, 0);
+    if (error) {
+        ass_msg(library, MSGL_WARN, &quot;FT_Glyph_To_Bitmap error %d&quot;,
+               error);
+        return 0;
+    }
+
+    bg = (FT_BitmapGlyph) glyph;
+    bit = &amp;(bg-&gt;bitmap);
+    if (bit-&gt;pixel_mode != FT_PIXEL_MODE_GRAY) {
+        ass_msg(library, MSGL_WARN, &quot;Unsupported pixel mode: %d&quot;,
+               (int) (bit-&gt;pixel_mode));
+        FT_Done_Glyph(glyph);
+        return 0;
+    }
+
+    w = bit-&gt;width;
+    h = bit-&gt;rows;
+    bm = alloc_bitmap(w + 2 * bord, h + 2 * bord);
+    memset(bm-&gt;buffer, 0, bm-&gt;w * bm-&gt;h);
+    bm-&gt;left = bg-&gt;left - bord;
+    bm-&gt;top = -bg-&gt;top - bord;
+
+    src = bit-&gt;buffer;
+    dst = bm-&gt;buffer + bord + bm-&gt;w * bord;
+    for (i = 0; i &lt; h; ++i) {
+        memcpy(dst, src, w);
+        src += bit-&gt;pitch;
+        dst += bm-&gt;w;
+    }
+
+    FT_Done_Glyph(glyph);
+    return bm;
+}
+
+/**
+ * \brief fix outline bitmap and generate shadow bitmap
+ * Two things are done here:
+ * 1. Glyph bitmap is subtracted from outline bitmap. This way looks much better in some cases.
+ * 2. Shadow bitmap is created as a sum of glyph and outline bitmaps.
+ */
+static bitmap_t *fix_outline_and_shadow(bitmap_t *bm_g, bitmap_t *bm_o)
+{
+    int x, y;
+    const int l = bm_o-&gt;left &gt; bm_g-&gt;left ? bm_o-&gt;left : bm_g-&gt;left;
+    const int t = bm_o-&gt;top &gt; bm_g-&gt;top ? bm_o-&gt;top : bm_g-&gt;top;
+    const int r =
+        bm_o-&gt;left + bm_o-&gt;w &lt;
+        bm_g-&gt;left + bm_g-&gt;w ? bm_o-&gt;left + bm_o-&gt;w : bm_g-&gt;left + bm_g-&gt;w;
+    const int b =
+        bm_o-&gt;top + bm_o-&gt;h &lt;
+        bm_g-&gt;top + bm_g-&gt;h ? bm_o-&gt;top + bm_o-&gt;h : bm_g-&gt;top + bm_g-&gt;h;
+
+    bitmap_t *bm_s = copy_bitmap(bm_o);
+
+    unsigned char *g =
+        bm_g-&gt;buffer + (t - bm_g-&gt;top) * bm_g-&gt;w + (l - bm_g-&gt;left);
+    unsigned char *o =
+        bm_o-&gt;buffer + (t - bm_o-&gt;top) * bm_o-&gt;w + (l - bm_o-&gt;left);
+    unsigned char *s =
+        bm_s-&gt;buffer + (t - bm_s-&gt;top) * bm_s-&gt;w + (l - bm_s-&gt;left);
+
+    for (y = 0; y &lt; b - t; ++y) {
+        for (x = 0; x &lt; r - l; ++x) {
+            unsigned char c_g, c_o;
+            c_g = g[x];
+            c_o = o[x];
+            o[x] = (c_o &gt; (3 * c_g) / 5) ? c_o - (3 * c_g) / 5 : 0;
+            s[x] = (c_o &lt; 0xFF - c_g) ? c_o + c_g : 0xFF;
+        }
+        g += bm_g-&gt;w;
+        o += bm_o-&gt;w;
+        s += bm_s-&gt;w;
+    }
+
+    assert(bm_s);
+    return bm_s;
+}
+
+/**
+ * \brief Shift a bitmap by the fraction of a pixel in x and y direction
+ * expressed in 26.6 fixed point
+ */
+static void shift_bitmap(unsigned char *buf, int w, int h, int shift_x,
+                         int shift_y)
+{
+    int x, y, b;
+
+    // Shift in x direction
+    if (shift_x &gt; 0) {
+        for (y = 0; y &lt; h; y++) {
+            for (x = w - 1; x &gt; 0; x--) {
+                b = (buf[x + y * w - 1] * shift_x) &gt;&gt; 6;
+                buf[x + y * w - 1] -= b;
+                buf[x + y * w] += b;
+            }
+        }
+    } else if (shift_x &lt; 0) {
+        shift_x = -shift_x;
+        for (y = 0; y &lt; h; y++) {
+            for (x = 0; x &lt; w - 1; x++) {
+                b = (buf[x + y * w + 1] * shift_x) &gt;&gt; 6;
+                buf[x + y * w + 1] -= b;
+                buf[x + y * w] += b;
+            }
+        }
+    }
+
+    // Shift in y direction
+    if (shift_y &gt; 0) {
+        for (x = 0; x &lt; w; x++) {
+            for (y = h - 1; y &gt; 0; y--) {
+                b = (buf[x + (y - 1) * w] * shift_y) &gt;&gt; 6;
+                buf[x + (y - 1) * w] -= b;
+                buf[x + y * w] += b;
+            }
+        }
+    } else if (shift_y &lt; 0) {
+        shift_y = -shift_y;
+        for (x = 0; x &lt; w; x++) {
+            for (y = 0; y &lt; h - 1; y++) {
+                b = (buf[x + (y + 1) * w] * shift_y) &gt;&gt; 6;
+                buf[x + (y + 1) * w] -= b;
+                buf[x + y * w] += b;
+            }
+        }
+    }
+}
+
+/*
+ * Gaussian blur.  An fast pure C implementation from MPlayer.
+ */
+static void ass_gauss_blur(unsigned char *buffer, unsigned short *tmp2,
+                           int width, int height, int stride, int *m2,
+                           int r, int mwidth)
+{
+
+    int x, y;
+
+    unsigned char *s = buffer;
+    unsigned short *t = tmp2 + 1;
+    for (y = 0; y &lt; height; y++) {
+        memset(t - 1, 0, (width + 1) * sizeof(short));
+
+        for (x = 0; x &lt; r; x++) {
+            const int src = s[x];
+            if (src) {
+                register unsigned short *dstp = t + x - r;
+                int mx;
+                unsigned *m3 = (unsigned *) (m2 + src * mwidth);
+                for (mx = r - x; mx &lt; mwidth; mx++) {
+                    dstp[mx] += m3[mx];
+                }
+            }
+        }
+
+        for (; x &lt; width - r; x++) {
+            const int src = s[x];
+            if (src) {
+                register unsigned short *dstp = t + x - r;
+                int mx;
+                unsigned *m3 = (unsigned *) (m2 + src * mwidth);
+                for (mx = 0; mx &lt; mwidth; mx++) {
+                    dstp[mx] += m3[mx];
+                }
+            }
+        }
+
+        for (; x &lt; width; x++) {
+            const int src = s[x];
+            if (src) {
+                register unsigned short *dstp = t + x - r;
+                int mx;
+                const int x2 = r + width - x;
+                unsigned *m3 = (unsigned *) (m2 + src * mwidth);
+                for (mx = 0; mx &lt; x2; mx++) {
+                    dstp[mx] += m3[mx];
+                }
+            }
+        }
+
+        s += stride;
+        t += width + 1;
+    }
+
+    t = tmp2;
+    for (x = 0; x &lt; width; x++) {
+        for (y = 0; y &lt; r; y++) {
+            unsigned short *srcp = t + y * (width + 1) + 1;
+            int src = *srcp;
+            if (src) {
+                register unsigned short *dstp = srcp - 1 + width + 1;
+                const int src2 = (src + 128) &gt;&gt; 8;
+                unsigned *m3 = (unsigned *) (m2 + src2 * mwidth);
+
+                int mx;
+                *srcp = 128;
+                for (mx = r - 1; mx &lt; mwidth; mx++) {
+                    *dstp += m3[mx];
+                    dstp += width + 1;
+                }
+            }
+        }
+        for (; y &lt; height - r; y++) {
+            unsigned short *srcp = t + y * (width + 1) + 1;
+            int src = *srcp;
+            if (src) {
+                register unsigned short *dstp = srcp - 1 - r * (width + 1);
+                const int src2 = (src + 128) &gt;&gt; 8;
+                unsigned *m3 = (unsigned *) (m2 + src2 * mwidth);
+
+                int mx;
+                *srcp = 128;
+                for (mx = 0; mx &lt; mwidth; mx++) {
+                    *dstp += m3[mx];
+                    dstp += width + 1;
+                }
+            }
+        }
+        for (; y &lt; height; y++) {
+            unsigned short *srcp = t + y * (width + 1) + 1;
+            int src = *srcp;
+            if (src) {
+                const int y2 = r + height - y;
+                register unsigned short *dstp = srcp - 1 - r * (width + 1);
+                const int src2 = (src + 128) &gt;&gt; 8;
+                unsigned *m3 = (unsigned *) (m2 + src2 * mwidth);
+
+                int mx;
+                *srcp = 128;
+                for (mx = 0; mx &lt; y2; mx++) {
+                    *dstp += m3[mx];
+                    dstp += width + 1;
+                }
+            }
+        }
+        t++;
+    }
+
+    t = tmp2;
+    s = buffer;
+    for (y = 0; y &lt; height; y++) {
+        for (x = 0; x &lt; width; x++) {
+            s[x] = t[x] &gt;&gt; 8;
+        }
+        s += stride;
+        t += width + 1;
+    }
+}
+
+/**
+ * \brief Blur with [[1,2,1]. [2,4,2], [1,2,1]] kernel
+ * This blur is the same as the one employed by vsfilter.
+ */
+static void be_blur(unsigned char *buf, int w, int h)
+{
+    unsigned int x, y;
+    unsigned int old_sum, new_sum;
+
+    for (y = 0; y &lt; h; y++) {
+        old_sum = 2 * buf[y * w];
+        for (x = 0; x &lt; w - 1; x++) {
+            new_sum = buf[y * w + x] + buf[y * w + x + 1];
+            buf[y * w + x] = (old_sum + new_sum) &gt;&gt; 2;
+            old_sum = new_sum;
+        }
+    }
+
+    for (x = 0; x &lt; w; x++) {
+        old_sum = 2 * buf[x];
+        for (y = 0; y &lt; h - 1; y++) {
+            new_sum = buf[y * w + x] + buf[(y + 1) * w + x];
+            buf[y * w + x] = (old_sum + new_sum) &gt;&gt; 2;
+            old_sum = new_sum;
+        }
+    }
+}
+
+int glyph_to_bitmap(ass_library_t *library, ass_synth_priv_t *priv_blur,
+                    FT_Glyph glyph, FT_Glyph outline_glyph,
+                    bitmap_t **bm_g, bitmap_t **bm_o, bitmap_t **bm_s,
+                    int be, double blur_radius, FT_Vector shadow_offset)
+{
+    blur_radius *= 2;
+    int bbord = be &gt; 0 ? sqrt(2 * be) : 0;
+    int gbord = blur_radius &gt; 0.0 ? blur_radius + 1 : 0;
+    int bord = FFMAX(bbord, gbord);
+    if (bord == 0 &amp;&amp; (shadow_offset.x || shadow_offset.y))
+        bord = 1;
+
+    assert(bm_g &amp;&amp; bm_o &amp;&amp; bm_s);
+
+    *bm_g = *bm_o = *bm_s = 0;
+
+    if (glyph)
+        *bm_g = glyph_to_bitmap_internal(library, glyph, bord);
+    if (!*bm_g)
+        return 1;
+
+    if (outline_glyph) {
+        *bm_o = glyph_to_bitmap_internal(library, outline_glyph, bord);
+        if (!*bm_o) {
+            return 1;
+        }
+    }
+
+    // Apply box blur (multiple passes, if requested)
+    while (be--) {
+        if (*bm_o)
+            be_blur((*bm_o)-&gt;buffer, (*bm_o)-&gt;w, (*bm_o)-&gt;h);
+        else
+            be_blur((*bm_g)-&gt;buffer, (*bm_g)-&gt;w, (*bm_g)-&gt;h);
+    }
+
+    // Apply gaussian blur
+    if (blur_radius &gt; 0.0) {
+        if (*bm_o)
+            resize_tmp(priv_blur, (*bm_o)-&gt;w, (*bm_o)-&gt;h);
+        else
+            resize_tmp(priv_blur, (*bm_g)-&gt;w, (*bm_g)-&gt;h);
+        generate_tables(priv_blur, blur_radius);
+        if (*bm_o)
+            ass_gauss_blur((*bm_o)-&gt;buffer, priv_blur-&gt;tmp,
+                           (*bm_o)-&gt;w, (*bm_o)-&gt;h, (*bm_o)-&gt;w,
+                           (int *) priv_blur-&gt;gt2, priv_blur-&gt;g_r,
+                           priv_blur-&gt;g_w);
+        else
+            ass_gauss_blur((*bm_g)-&gt;buffer, priv_blur-&gt;tmp,
+                           (*bm_g)-&gt;w, (*bm_g)-&gt;h, (*bm_g)-&gt;w,
+                           (int *) priv_blur-&gt;gt2, priv_blur-&gt;g_r,
+                           priv_blur-&gt;g_w);
+    }
+
+    if (*bm_o)
+        *bm_s = fix_outline_and_shadow(*bm_g, *bm_o);
+    else
+        *bm_s = copy_bitmap(*bm_g);
+
+    shift_bitmap((*bm_s)-&gt;buffer, (*bm_s)-&gt;w,(*bm_s)-&gt;h,
+                 shadow_offset.x, shadow_offset.y);
+
+    assert(bm_s);
+    return 0;
+}

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_bitmap.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_bitmap.h	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_bitmap.h	2009-08-01 07:55:22 UTC (rev 5185)
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+ *
+ * This file is part of libass.
+ *
+ * libass is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libass is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with libass; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef LIBASS_BITMAP_H
+#define LIBASS_BITMAP_H
+
+#include &lt;ft2build.h&gt;
+#include FT_GLYPH_H
+
+#include &quot;ass.h&quot;
+
+typedef struct ass_synth_priv ass_synth_priv_t;
+
+ass_synth_priv_t *ass_synth_init(double);
+void ass_synth_done(ass_synth_priv_t *priv);
+
+typedef struct {
+    int left, top;
+    int w, h;                   // width, height
+    unsigned char *buffer;      // w x h buffer
+} bitmap_t;
+
+/**
+ * \brief perform glyph rendering
+ * \param glyph original glyph
+ * \param outline_glyph &quot;border&quot; glyph, produced from original by FreeType's glyph stroker
+ * \param bm_g out: pointer to the bitmap of original glyph is returned here
+ * \param bm_o out: pointer to the bitmap of outline (border) glyph is returned here
+ * \param bm_g out: pointer to the bitmap of glyph shadow is returned here
+ * \param be 1 = produces blurred bitmaps, 0 = normal bitmaps
+ */
+int glyph_to_bitmap(ass_library_t *library, ass_synth_priv_t *priv_blur,
+                    FT_Glyph glyph, FT_Glyph outline_glyph,
+                    bitmap_t **bm_g, bitmap_t **bm_o, bitmap_t **bm_s,
+                    int be, double blur_radius, FT_Vector shadow_offset);
+
+void ass_free_bitmap(bitmap_t *bm);
+
+#endif                          /* LIBASS_BITMAP_H */

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_cache.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_cache.c	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_cache.c	2009-08-01 07:55:22 UTC (rev 5185)
@@ -0,0 +1,380 @@
+/*
+ * Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+ *
+ * This file is part of libass.
+ *
+ * libass is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libass is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with libass; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include &quot;config.h&quot;
+
+#include &lt;inttypes.h&gt;
+#include &lt;ft2build.h&gt;
+#include FT_FREETYPE_H
+#include FT_GLYPH_H
+
+#include &lt;assert.h&gt;
+
+#include &quot;ass_utils.h&quot;
+#include &quot;ass.h&quot;
+#include &quot;ass_fontconfig.h&quot;
+#include &quot;ass_font.h&quot;
+#include &quot;ass_bitmap.h&quot;
+#include &quot;ass_cache.h&quot;
+
+static unsigned hashmap_hash(void *buf, size_t len)
+{
+    return fnv_32a_buf(buf, len, FNV1_32A_INIT);
+}
+
+static int hashmap_key_compare(void *a, void *b, size_t size)
+{
+    return memcmp(a, b, size) == 0;
+}
+
+static void hashmap_item_dtor(void *key, size_t key_size, void *value,
+                              size_t value_size)
+{
+    free(key);
+    free(value);
+}
+
+hashmap_t *hashmap_init(ass_library_t *library, size_t key_size,
+                        size_t value_size, int nbuckets,
+                        hashmap_item_dtor_t item_dtor,
+                        hashmap_key_compare_t key_compare,
+                        hashmap_hash_t hash)
+{
+    hashmap_t *map = calloc(1, sizeof(hashmap_t));
+    map-&gt;library = library;
+    map-&gt;nbuckets = nbuckets;
+    map-&gt;key_size = key_size;
+    map-&gt;value_size = value_size;
+    map-&gt;root = calloc(nbuckets, sizeof(hashmap_item_p));
+    map-&gt;item_dtor = item_dtor ? item_dtor : hashmap_item_dtor;
+    map-&gt;key_compare = key_compare ? key_compare : hashmap_key_compare;
+    map-&gt;hash = hash ? hash : hashmap_hash;
+    return map;
+}
+
+void hashmap_done(hashmap_t *map)
+{
+    int i;
+    // print stats
+    if (map-&gt;count &gt; 0 || map-&gt;hit_count + map-&gt;miss_count &gt; 0)
+        ass_msg(map-&gt;library, MSGL_V,
+               &quot;cache statistics: \n  total accesses: %d\n  hits: %d\n  &quot;
+               &quot;misses: %d\n  object count: %d&quot;,
+               map-&gt;hit_count + map-&gt;miss_count, map-&gt;hit_count,
+               map-&gt;miss_count, map-&gt;count);
+
+    for (i = 0; i &lt; map-&gt;nbuckets; ++i) {
+        hashmap_item_t *item = map-&gt;root[i];
+        while (item) {
+            hashmap_item_t *next = item-&gt;next;
+            map-&gt;item_dtor(item-&gt;key, map-&gt;key_size, item-&gt;value,
+                           map-&gt;value_size);
+            free(item);
+            item = next;
+        }
+    }
+    free(map-&gt;root);
+    free(map);
+}
+
+// does nothing if key already exists
+void *hashmap_insert(hashmap_t *map, void *key, void *value)
+{
+    unsigned hash = map-&gt;hash(key, map-&gt;key_size);
+    hashmap_item_t **next = map-&gt;root + (hash % map-&gt;nbuckets);
+    while (*next) {
+        if (map-&gt;key_compare(key, (*next)-&gt;key, map-&gt;key_size))
+            return (*next)-&gt;value;
+        next = &amp;((*next)-&gt;next);
+        assert(next);
+    }
+    (*next) = malloc(sizeof(hashmap_item_t));
+    (*next)-&gt;key = malloc(map-&gt;key_size);
+    (*next)-&gt;value = malloc(map-&gt;value_size);
+    memcpy((*next)-&gt;key, key, map-&gt;key_size);
+    memcpy((*next)-&gt;value, value, map-&gt;value_size);
+    (*next)-&gt;next = 0;
+
+    map-&gt;count++;
+    return (*next)-&gt;value;
+}
+
+void *hashmap_find(hashmap_t *map, void *key)
+{
+    unsigned hash = map-&gt;hash(key, map-&gt;key_size);
+    hashmap_item_t *item = map-&gt;root[hash % map-&gt;nbuckets];
+    while (item) {
+        if (map-&gt;key_compare(key, item-&gt;key, map-&gt;key_size)) {
+            map-&gt;hit_count++;
+            return item-&gt;value;
+        }
+        item = item-&gt;next;
+    }
+    map-&gt;miss_count++;
+    return 0;
+}
+
+//---------------------------------
+// font cache
+
+static unsigned font_desc_hash(void *buf, size_t len)
+{
+    ass_font_desc_t *desc = buf;
+    unsigned hval;
+    hval = fnv_32a_str(desc-&gt;family, FNV1_32A_INIT);
+    hval = fnv_32a_buf(&amp;desc-&gt;bold, sizeof(desc-&gt;bold), hval);
+    hval = fnv_32a_buf(&amp;desc-&gt;italic, sizeof(desc-&gt;italic), hval);
+    return hval;
+}
+
+static int font_compare(void *key1, void *key2, size_t key_size)
+{
+    ass_font_desc_t *a = key1;
+    ass_font_desc_t *b = key2;
+    if (strcmp(a-&gt;family, b-&gt;family) != 0)
+        return 0;
+    if (a-&gt;bold != b-&gt;bold)
+        return 0;
+    if (a-&gt;italic != b-&gt;italic)
+        return 0;
+    if (a-&gt;treat_family_as_pattern != b-&gt;treat_family_as_pattern)
+        return 0;
+    return 1;
+}
+
+static void font_hash_dtor(void *key, size_t key_size, void *value,
+                           size_t value_size)
+{
+    ass_font_free(value);
+    free(key);
+}
+
+ass_font_t *ass_font_cache_find(hashmap_t *font_cache,
+                                ass_font_desc_t *desc)
+{
+    return hashmap_find(font_cache, desc);
+}
+
+/**
+ * \brief Add a face struct to cache.
+ * \param font font struct
+*/
+void *ass_font_cache_add(hashmap_t *font_cache, ass_font_t *font)
+{
+    return hashmap_insert(font_cache, &amp;(font-&gt;desc), font);
+}
+
+hashmap_t *ass_font_cache_init(ass_library_t *library)
+{
+    hashmap_t *font_cache;
+    font_cache = hashmap_init(library, sizeof(ass_font_desc_t),
+                              sizeof(ass_font_t),
+                              1000,
+                              font_hash_dtor, font_compare, font_desc_hash);
+    return font_cache;
+}
+
+void ass_font_cache_done(hashmap_t *font_cache)
+{
+    hashmap_done(font_cache);
+}
+
+
+// Create hash/compare functions for bitmap and glyph
+#define CREATE_HASH_FUNCTIONS
+#include &quot;ass_cache_template.h&quot;
+#define CREATE_COMPARISON_FUNCTIONS
+#include &quot;ass_cache_template.h&quot;
+
+//---------------------------------
+// bitmap cache
+
+static void bitmap_hash_dtor(void *key, size_t key_size, void *value,
+                             size_t value_size)
+{
+    bitmap_hash_val_t *v = value;
+    if (v-&gt;bm)
+        ass_free_bitmap(v-&gt;bm);
+    if (v-&gt;bm_o)
+        ass_free_bitmap(v-&gt;bm_o);
+    if (v-&gt;bm_s)
+        ass_free_bitmap(v-&gt;bm_s);
+    free(key);
+    free(value);
+}
+
+void *cache_add_bitmap(hashmap_t *bitmap_cache, bitmap_hash_key_t *key,
+                       bitmap_hash_val_t *val)
+{
+    // Note: this is only an approximation
+    if (val-&gt;bm_o)
+        bitmap_cache-&gt;cache_size += val-&gt;bm_o-&gt;w * val-&gt;bm_o-&gt;h * 3;
+    else
+        bitmap_cache-&gt;cache_size += val-&gt;bm-&gt;w * val-&gt;bm-&gt;h * 3;
+
+    return hashmap_insert(bitmap_cache, key, val);
+}
+
+/**
+ * \brief Get a bitmap from bitmap cache.
+ * \param key hash key
+ * \return requested hash val or 0 if not found
+*/
+bitmap_hash_val_t *cache_find_bitmap(hashmap_t *bitmap_cache,
+                                     bitmap_hash_key_t *key)
+{
+    return hashmap_find(bitmap_cache, key);
+}
+
+hashmap_t *ass_bitmap_cache_init(ass_library_t *library)
+{
+    hashmap_t *bitmap_cache;
+    bitmap_cache = hashmap_init(library,
+                                sizeof(bitmap_hash_key_t),
+                                sizeof(bitmap_hash_val_t),
+                                0xFFFF + 13,
+                                bitmap_hash_dtor, bitmap_compare,
+                                bitmap_hash);
+    return bitmap_cache;
+}
+
+void ass_bitmap_cache_done(hashmap_t *bitmap_cache)
+{
+    hashmap_done(bitmap_cache);
+}
+
+hashmap_t *ass_bitmap_cache_reset(hashmap_t *bitmap_cache)
+{
+    ass_library_t *lib = bitmap_cache-&gt;library;
+
+    ass_bitmap_cache_done(bitmap_cache);
+    return ass_bitmap_cache_init(lib);
+}
+
+//---------------------------------
+// glyph cache
+
+static void glyph_hash_dtor(void *key, size_t key_size, void *value,
+                            size_t value_size)
+{
+    glyph_hash_val_t *v = value;
+    if (v-&gt;glyph)
+        FT_Done_Glyph(v-&gt;glyph);
+    if (v-&gt;outline_glyph)
+        FT_Done_Glyph(v-&gt;outline_glyph);
+    free(key);
+    free(value);
+}
+
+void *cache_add_glyph(hashmap_t *glyph_cache, glyph_hash_key_t *key,
+                      glyph_hash_val_t *val)
+{
+    return hashmap_insert(glyph_cache, key, val);
+}
+
+/**
+ * \brief Get a glyph from glyph cache.
+ * \param key hash key
+ * \return requested hash val or 0 if not found
+*/
+glyph_hash_val_t *cache_find_glyph(hashmap_t *glyph_cache,
+                                   glyph_hash_key_t *key)
+{
+    return hashmap_find(glyph_cache, key);
+}
+
+hashmap_t *ass_glyph_cache_init(ass_library_t *library)
+{
+    hashmap_t *glyph_cache;
+    glyph_cache = hashmap_init(library, sizeof(glyph_hash_key_t),
+                               sizeof(glyph_hash_val_t),
+                               0xFFFF + 13,
+                               glyph_hash_dtor, glyph_compare, glyph_hash);
+    return glyph_cache;
+}
+
+void ass_glyph_cache_done(hashmap_t *glyph_cache)
+{
+    hashmap_done(glyph_cache);
+}
+
+hashmap_t *ass_glyph_cache_reset(hashmap_t *glyph_cache)
+{
+    ass_library_t *lib = glyph_cache-&gt;library;
+
+    ass_glyph_cache_done(glyph_cache);
+    return ass_glyph_cache_init(lib);
+}
+
+
+//---------------------------------
+// composite cache
+
+static void composite_hash_dtor(void *key, size_t key_size, void *value,
+                                size_t value_size)
+{
+    composite_hash_val_t *v = value;
+    free(v-&gt;a);
+    free(v-&gt;b);
+    free(key);
+    free(value);
+}
+
+void *cache_add_composite(hashmap_t *composite_cache,
+                          composite_hash_key_t *key,
+                          composite_hash_val_t *val)
+{
+    return hashmap_insert(composite_cache, key, val);
+}
+
+/**
+ * \brief Get a composite bitmap from composite cache.
+ * \param key hash key
+ * \return requested hash val or 0 if not found
+*/
+composite_hash_val_t *cache_find_composite(hashmap_t *composite_cache,
+                                           composite_hash_key_t *key)
+{
+    return hashmap_find(composite_cache, key);
+}
+
+hashmap_t *ass_composite_cache_init(ass_library_t *library)
+{
+    hashmap_t *composite_cache;
+    composite_cache = hashmap_init(library, sizeof(composite_hash_key_t),
+                                   sizeof(composite_hash_val_t),
+                                   0xFFFF + 13,
+                                   composite_hash_dtor, composite_compare,
+                                   composite_hash);
+    return composite_cache;
+}
+
+void ass_composite_cache_done(hashmap_t *composite_cache)
+{
+    hashmap_done(composite_cache);
+}
+
+hashmap_t *ass_composite_cache_reset(hashmap_t *composite_cache)
+{
+    ass_library_t *lib = composite_cache-&gt;library;
+
+    ass_composite_cache_done(composite_cache);
+    return ass_composite_cache_init(lib);
+}

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_cache.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_cache.h	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_cache.h	2009-08-01 07:55:22 UTC (rev 5185)
@@ -0,0 +1,119 @@
+/*
+ * Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+ *
+ * This file is part of libass.
+ *
+ * libass is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libass is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with libass; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef LIBASS_CACHE_H
+#define LIBASS_CACHE_H
+
+#include &quot;ass.h&quot;
+#include &quot;ass_font.h&quot;
+#include &quot;ass_bitmap.h&quot;
+
+typedef void (*hashmap_item_dtor_t) (void *key, size_t key_size,
+                                     void *value, size_t value_size);
+typedef int (*hashmap_key_compare_t) (void *key1, void *key2,
+                                      size_t key_size);
+typedef unsigned (*hashmap_hash_t) (void *key, size_t key_size);
+
+typedef struct hashmap_item {
+    void *key;
+    void *value;
+    struct hashmap_item *next;
+} hashmap_item_t;
+typedef hashmap_item_t *hashmap_item_p;
+
+typedef struct {
+    int nbuckets;
+    size_t key_size, value_size;
+    hashmap_item_p *root;
+    hashmap_item_dtor_t item_dtor;      // a destructor for hashmap key/value pairs
+    hashmap_key_compare_t key_compare;
+    hashmap_hash_t hash;
+    size_t cache_size;
+    // stats
+    int hit_count;
+    int miss_count;
+    int count;
+    ass_library_t *library;
+} hashmap_t;
+
+hashmap_t *hashmap_init(ass_library_t *library, size_t key_size,
+                        size_t value_size, int nbuckets,
+                        hashmap_item_dtor_t item_dtor,
+                        hashmap_key_compare_t key_compare,
+                        hashmap_hash_t hash);
+void hashmap_done(hashmap_t *map);
+void *hashmap_insert(hashmap_t *map, void *key, void *value);
+void *hashmap_find(hashmap_t *map, void *key);
+
+hashmap_t *ass_font_cache_init(ass_library_t *library);
+ass_font_t *ass_font_cache_find(hashmap_t *, ass_font_desc_t *desc);
+void *ass_font_cache_add(hashmap_t *, ass_font_t *font);
+void ass_font_cache_done(hashmap_t *);
+
+// Create definitions for bitmap_hash_key and glyph_hash_key
+#define CREATE_STRUCT_DEFINITIONS
+#include &quot;ass_cache_template.h&quot;
+
+typedef struct {
+    bitmap_t *bm;               // the actual bitmaps
+    bitmap_t *bm_o;
+    bitmap_t *bm_s;
+} bitmap_hash_val_t;
+
+hashmap_t *ass_bitmap_cache_init(ass_library_t *library);
+void *cache_add_bitmap(hashmap_t *, bitmap_hash_key_t *key,
+                       bitmap_hash_val_t *val);
+bitmap_hash_val_t *cache_find_bitmap(hashmap_t *bitmap_cache,
+                                     bitmap_hash_key_t *key);
+hashmap_t *ass_bitmap_cache_reset(hashmap_t *bitmap_cache);
+void ass_bitmap_cache_done(hashmap_t *bitmap_cache);
+
+
+typedef struct {
+    unsigned char *a;
+    unsigned char *b;
+} composite_hash_val_t;
+
+hashmap_t *ass_composite_cache_init(ass_library_t *library);
+void *cache_add_composite(hashmap_t *, composite_hash_key_t *key,
+                          composite_hash_val_t *val);
+composite_hash_val_t *cache_find_composite(hashmap_t *composite_cache,
+                                           composite_hash_key_t *key);
+hashmap_t *ass_composite_cache_reset(hashmap_t *composite_cache);
+void ass_composite_cache_done(hashmap_t *composite_cache);
+
+
+typedef struct {
+    FT_Glyph glyph;
+    FT_Glyph outline_glyph;
+    FT_BBox bbox_scaled;        // bbox after scaling, but before rotation
+    FT_Vector advance;          // 26.6, advance distance to the next bitmap in line
+    int asc, desc;              // ascender/descender of a drawing
+} glyph_hash_val_t;
+
+hashmap_t *ass_glyph_cache_init(ass_library_t *library);
+void *cache_add_glyph(hashmap_t *, glyph_hash_key_t *key,
+                      glyph_hash_val_t *val);
+glyph_hash_val_t *cache_find_glyph(hashmap_t *glyph_cache,
+                                   glyph_hash_key_t *key);
+hashmap_t *ass_glyph_cache_reset(hashmap_t *glyph_cache);
+void ass_glyph_cache_done(hashmap_t *glyph_cache);
+
+#endif                          /* LIBASS_CACHE_H */

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_cache_template.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_cache_template.h	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_cache_template.h	2009-08-01 07:55:22 UTC (rev 5185)
@@ -0,0 +1,117 @@
+#ifdef CREATE_STRUCT_DEFINITIONS
+#undef CREATE_STRUCT_DEFINITIONS
+#define START(funcname, structname) \
+    typedef struct structname {
+#define GENERIC(type, member) \
+        type member;
+#define FTVECTOR(member) \
+        FT_Vector member;
+#define BITMAPHASHKEY(member) \
+        bitmap_hash_key_t member;
+#define END(typedefnamename) \
+    } typedefnamename;
+
+#elif defined(CREATE_COMPARISON_FUNCTIONS)
+#undef CREATE_COMPARISON_FUNCTIONS
+#define START(funcname, structname) \
+    static int funcname##_compare(void *key1, void *key2, size_t key_size) \
+    { \
+        struct structname *a = key1; \
+        struct structname *b = key2; \
+        return // conditions follow
+#define GENERIC(type, member) \
+            a-&gt;member == b-&gt;member &amp;&amp;
+#define FTVECTOR(member) \
+            a-&gt;member.x == b-&gt;member.x &amp;&amp; a-&gt;member.y == b-&gt;member.y &amp;&amp;
+#define BITMAPHASHKEY(member) \
+            bitmap_compare(&amp;a-&gt;member, &amp;b-&gt;member, sizeof(a-&gt;member)) &amp;&amp;
+#define END(typedefname) \
+            1; \
+    }
+
+#elif defined(CREATE_HASH_FUNCTIONS)
+#undef CREATE_HASH_FUNCTIONS
+#define START(funcname, structname) \
+    static unsigned funcname##_hash(void *buf, size_t len) \
+    { \
+        struct structname *p = buf; \
+        unsigned hval = FNV1_32A_INIT;
+#define GENERIC(type, member) \
+        hval = fnv_32a_buf(&amp;p-&gt;member, sizeof(p-&gt;member), hval);
+#define FTVECTOR(member) GENERIC(, member.x); GENERIC(, member.y);
+#define BITMAPHASHKEY(member) { \
+        unsigned temp = bitmap_hash(&amp;p-&gt;member, sizeof(p-&gt;member)); \
+        hval = fnv_32a_buf(&amp;temp, sizeof(temp), hval); \
+        }
+#define END(typedefname) \
+        return hval; \
+    }
+
+#else
+#error missing defines
+#endif
+
+
+
+// describes a bitmap; bitmaps with equivalents structs are considered identical
+START(bitmap, bipmap_hash_key)
+    GENERIC(char, bitmap) // bool : true = bitmap, false = outline
+    GENERIC(ass_font_t *, font)
+    GENERIC(double, size) // font size
+    GENERIC(uint32_t, ch) // character code
+    FTVECTOR(outline) // border width, 16.16 fixed point value
+    GENERIC(int, bold)
+    GENERIC(int, italic)
+    GENERIC(char, be) // blur edges
+    GENERIC(double, blur) // gaussian blur
+    GENERIC(unsigned, scale_x) // 16.16
+    GENERIC(unsigned, scale_y) // 16.16
+    GENERIC(int, frx) // signed 16.16
+    GENERIC(int, fry) // signed 16.16
+    GENERIC(int, frz) // signed 16.16
+    GENERIC(int, fax) // signed 16.16
+    GENERIC(int, fay) // signed 16.16
+    // shift vector that was added to glyph before applying rotation
+    // = 0, if frx = fry = frx = 0
+    // = (glyph base point) - (rotation origin), otherwise
+    GENERIC(int, shift_x)
+    GENERIC(int, shift_y)
+    FTVECTOR(advance) // subpixel shift vector
+    FTVECTOR(shadow_offset) // shadow subpixel shift
+    GENERIC(unsigned, drawing_hash) // hashcode of a drawing
+END(bitmap_hash_key_t)
+
+// describes an outline glyph
+START(glyph, glyph_hash_key)
+    GENERIC(ass_font_t *, font)
+    GENERIC(double, size) // font size
+    GENERIC(uint32_t, ch) // character code
+    GENERIC(int, bold)
+    GENERIC(int, italic)
+    GENERIC(unsigned, scale_x) // 16.16
+    GENERIC(unsigned, scale_y) // 16.16
+    FTVECTOR(outline) // border width, 16.16
+    GENERIC(unsigned, drawing_hash) // hashcode of a drawing
+    GENERIC(unsigned, flags)    // glyph decoration flags
+END(glyph_hash_key_t)
+
+// Cache for composited bitmaps
+START(composite, composite_hash_key)
+    GENERIC(int, aw)
+    GENERIC(int, ah)
+    GENERIC(int, bw)
+    GENERIC(int, bh)
+    GENERIC(int, ax)
+    GENERIC(int, ay)
+    GENERIC(int, bx)
+    GENERIC(int, by)
+    BITMAPHASHKEY(a)
+    BITMAPHASHKEY(b)
+END(composite_hash_key_t)
+
+
+#undef START
+#undef GENERIC
+#undef FTVECTOR
+#undef BITMAPHASHKEY
+#undef END

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_drawing.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_drawing.c	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_drawing.c	2009-08-01 07:55:22 UTC (rev 5185)
@@ -0,0 +1,484 @@
+/*
+ * Copyright (C) 2009 Grigori Goronzy &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">greg at geekmind.org</A>&gt;
+ *
+ * This file is part of libass.
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include &lt;ft2build.h&gt;
+#include FT_GLYPH_H
+#include FT_OUTLINE_H
+#include FT_BBOX_H
+#include &lt;math.h&gt;
+
+#include &quot;ass_utils.h&quot;
+#include &quot;ass_font.h&quot;
+#include &quot;ass_drawing.h&quot;
+
+#define CURVE_ACCURACY 64.0
+#define GLYPH_INITIAL_POINTS 100
+#define GLYPH_INITIAL_CONTOURS 5
+
+/*
+ * \brief Get and prepare a FreeType glyph
+ */
+static void drawing_make_glyph(ass_drawing_t *drawing, void *fontconfig_priv,
+                               ass_font_t *font, ass_hinting_t hint)
+{
+    FT_OutlineGlyph glyph;
+
+    // This is hacky...
+    glyph = (FT_OutlineGlyph) ass_font_get_glyph(fontconfig_priv, font,
+                                                 (uint32_t) ' ', hint, 0);
+
+    FT_Outline_Done(drawing-&gt;ftlibrary, &amp;glyph-&gt;outline);
+    FT_Outline_New(drawing-&gt;ftlibrary, GLYPH_INITIAL_POINTS,
+                   GLYPH_INITIAL_CONTOURS, &amp;glyph-&gt;outline);
+
+    glyph-&gt;outline.n_contours = 0;
+    glyph-&gt;outline.n_points = 0;
+    glyph-&gt;root.advance.x = glyph-&gt;root.advance.y = 0;
+    drawing-&gt;glyph = glyph;
+}
+
+/*
+ * \brief Add a single point to a contour.
+ */
+static inline void drawing_add_point(ass_drawing_t *drawing,
+                                     FT_Vector *point)
+{
+    FT_Outline *ol = &amp;drawing-&gt;glyph-&gt;outline;
+
+    if (ol-&gt;n_points &gt;= drawing-&gt;max_points) {
+        drawing-&gt;max_points *= 2;
+        ol-&gt;points = realloc(ol-&gt;points, sizeof(FT_Vector) *
+                             drawing-&gt;max_points);
+        ol-&gt;tags = realloc(ol-&gt;tags, drawing-&gt;max_points);
+    }
+
+    ol-&gt;points[ol-&gt;n_points].x = point-&gt;x;
+    ol-&gt;points[ol-&gt;n_points].y = point-&gt;y;
+    ol-&gt;tags[ol-&gt;n_points] = 1;
+    ol-&gt;n_points++;
+}
+
+/*
+ * \brief Close a contour and check glyph size overflow.
+ */
+static inline void drawing_close_shape(ass_drawing_t *drawing)
+{
+    FT_Outline *ol = &amp;drawing-&gt;glyph-&gt;outline;
+
+    if (ol-&gt;n_contours &gt;= drawing-&gt;max_contours) {
+        drawing-&gt;max_contours *= 2;
+        ol-&gt;contours = realloc(ol-&gt;contours, sizeof(short) *
+                               drawing-&gt;max_contours);
+    }
+
+    ol-&gt;contours[ol-&gt;n_contours] = ol-&gt;n_points - 1;
+    ol-&gt;n_contours++;
+}
+
+/*
+ * \brief Prepare drawing for parsing.  This just sets a few parameters.
+ */
+static void drawing_prepare(ass_drawing_t *drawing)
+{
+    // Scaling parameters
+    drawing-&gt;point_scale_x = drawing-&gt;scale_x *
+                             64.0 / (1 &lt;&lt; (drawing-&gt;scale - 1));
+    drawing-&gt;point_scale_y = drawing-&gt;scale_y *
+                             64.0 / (1 &lt;&lt; (drawing-&gt;scale - 1));
+}
+
+/*
+ * \brief Finish a drawing.  This only sets the horizontal advance according
+ * to the glyph's bbox at the moment.
+ */
+static void drawing_finish(ass_drawing_t *drawing, int raw_mode)
+{
+    int i, offset;
+    FT_BBox bbox;
+    FT_Outline *ol = &amp;drawing-&gt;glyph-&gt;outline;
+
+    // Close the last contour
+    drawing_close_shape(drawing);
+
+#if 0
+    // Dump points
+    for (i = 0; i &lt; ol-&gt;n_points; i++) {
+        printf(&quot;point (%d, %d)\n&quot;, (int) ol-&gt;points[i].x,
+               (int) ol-&gt;points[i].y);
+    }
+
+    // Dump contours
+    for (i = 0; i &lt; ol-&gt;n_contours; i++)
+        printf(&quot;contour %d\n&quot;, ol-&gt;contours[i]);
+#endif
+
+    ass_msg(drawing-&gt;library, MSGL_V,
+            &quot;Parsed drawing with %d points and %d contours&quot;, ol-&gt;n_points,
+            ol-&gt;n_contours);
+
+    if (raw_mode)
+        return;
+
+    FT_Outline_Get_CBox(&amp;drawing-&gt;glyph-&gt;outline, &amp;bbox);
+    drawing-&gt;glyph-&gt;root.advance.x = d6_to_d16(bbox.xMax - bbox.xMin);
+
+    drawing-&gt;desc = double_to_d6(-drawing-&gt;pbo * drawing-&gt;scale_y);
+    drawing-&gt;asc = bbox.yMax - bbox.yMin + drawing-&gt;desc;
+
+    // Place it onto the baseline
+    offset = (bbox.yMax - bbox.yMin) + double_to_d6(-drawing-&gt;pbo *
+                                                    drawing-&gt;scale_y);
+    for (i = 0; i &lt; ol-&gt;n_points; i++)
+        ol-&gt;points[i].y += offset;
+}
+
+/*
+ * \brief Check whether a number of items on the list is available
+ */
+static int token_check_values(ass_drawing_token_t *token, int i, int type)
+{
+    int j;
+    for (j = 0; j &lt; i; j++) {
+        if (!token || token-&gt;type != type) return 0;
+        token = token-&gt;next;
+    }
+
+    return 1;
+}
+
+/*
+ * \brief Tokenize a drawing string into a list of ass_drawing_token_t
+ * This also expands points for closing b-splines
+ */
+static ass_drawing_token_t *drawing_tokenize(char *str)
+{
+    char *p = str;
+    int i, val, type = -1, is_set = 0;
+    FT_Vector point = {0, 0};
+
+    ass_drawing_token_t *root = NULL, *tail = NULL, *spline_start = NULL;
+
+    while (*p) {
+        if (*p == 'c' &amp;&amp; spline_start) {
+            // Close b-splines: add the first three points of the b-spline
+            // back to the end
+            if (token_check_values(spline_start-&gt;next, 2, TOKEN_B_SPLINE)) {
+                for (i = 0; i &lt; 3; i++) {
+                    tail-&gt;next = calloc(1, sizeof(ass_drawing_token_t));
+                    tail-&gt;next-&gt;prev = tail;
+                    tail = tail-&gt;next;
+                    tail-&gt;type = TOKEN_B_SPLINE;
+                    tail-&gt;point = spline_start-&gt;point;
+                    spline_start = spline_start-&gt;next;
+                }
+                spline_start = NULL;
+            }
+        } else if (!is_set &amp;&amp; mystrtoi(&amp;p, &amp;val)) {
+            point.x = val;
+            is_set = 1;
+            p--;
+        } else if (is_set == 1 &amp;&amp; mystrtoi(&amp;p, &amp;val)) {
+            point.y = val;
+            is_set = 2;
+            p--;
+        } else if (*p == 'm')
+            type = TOKEN_MOVE;
+        else if (*p == 'n')
+            type = TOKEN_MOVE_NC;
+        else if (*p == 'l')
+            type = TOKEN_LINE;
+        else if (*p == 'b')
+            type = TOKEN_CUBIC_BEZIER;
+        else if (*p == 'q')
+            type = TOKEN_CONIC_BEZIER;
+        else if (*p == 's')
+            type = TOKEN_B_SPLINE;
+        // We're simply ignoring TOKEN_EXTEND_B_SPLINE here.
+        // This is not harmful at all, since it can be ommitted with
+        // similar result (the spline is extended anyway).
+
+        if (type != -1 &amp;&amp; is_set == 2) {
+            if (root) {
+                tail-&gt;next = calloc(1, sizeof(ass_drawing_token_t));
+                tail-&gt;next-&gt;prev = tail;
+                tail = tail-&gt;next;
+            } else
+                root = tail = calloc(1, sizeof(ass_drawing_token_t));
+            tail-&gt;type = type;
+            tail-&gt;point = point;
+            is_set = 0;
+            if (type == TOKEN_B_SPLINE &amp;&amp; !spline_start)
+                spline_start = tail-&gt;prev;
+        }
+        p++;
+    }
+
+#if 0
+    // Check tokens
+    ass_drawing_token_t *t = root;
+    while(t) {
+        printf(&quot;token %d point (%d, %d)\n&quot;, t-&gt;type, t-&gt;point.x, t-&gt;point.y);
+        t = t-&gt;next;
+    }
+#endif
+
+    return root;
+}
+
+/*
+ * \brief Free a list of tokens
+ */
+static void drawing_free_tokens(ass_drawing_token_t *token)
+{
+    while (token) {
+        ass_drawing_token_t *at = token;
+        token = token-&gt;next;
+        free(at);
+    }
+}
+
+/*
+ * \brief Translate and scale a point coordinate according to baseline
+ * offset and scale.
+ */
+static inline void translate_point(ass_drawing_t *drawing, FT_Vector *point)
+{
+    point-&gt;x = drawing-&gt;point_scale_x * point-&gt;x;
+    point-&gt;y = drawing-&gt;point_scale_y * -point-&gt;y;
+}
+
+/*
+ * \brief Evaluate a curve into lines
+ * This curve evaluator is also used in VSFilter (RTS.cpp); it's a simple
+ * implementation of the De Casteljau algorithm.
+ */
+static void drawing_evaluate_curve(ass_drawing_t *drawing,
+                                   ass_drawing_token_t *token, char spline,
+                                   int started)
+{
+    double cx3, cx2, cx1, cx0, cy3, cy2, cy1, cy0;
+    double t, h, max_accel, max_accel1, max_accel2;
+    FT_Vector cur = {0, 0};
+
+    cur = token-&gt;point;
+    translate_point(drawing, &amp;cur);
+    int x0 = cur.x;
+    int y0 = cur.y;
+    token = token-&gt;next;
+    cur = token-&gt;point;
+    translate_point(drawing, &amp;cur);
+    int x1 = cur.x;
+    int y1 = cur.y;
+    token = token-&gt;next;
+    cur = token-&gt;point;
+    translate_point(drawing, &amp;cur);
+    int x2 = cur.x;
+    int y2 = cur.y;
+    token = token-&gt;next;
+    cur = token-&gt;point;
+    translate_point(drawing, &amp;cur);
+    int x3 = cur.x;
+    int y3 = cur.y;
+
+    if (spline) {
+        // 1   [-1 +3 -3 +1]
+        // - * [+3 -6 +3  0]
+        // 6   [-3  0 +3  0]
+        //	   [+1 +4 +1  0]
+
+        double div6 = 1.0/6.0;
+
+        cx3 = div6*(-  x0+3*x1-3*x2+x3);
+        cx2 = div6*( 3*x0-6*x1+3*x2);
+        cx1 = div6*(-3*x0	   +3*x2);
+        cx0 = div6*(   x0+4*x1+1*x2);
+
+        cy3 = div6*(-  y0+3*y1-3*y2+y3);
+        cy2 = div6*( 3*y0-6*y1+3*y2);
+        cy1 = div6*(-3*y0     +3*y2);
+        cy0 = div6*(   y0+4*y1+1*y2);
+    } else {
+        // [-1 +3 -3 +1]
+        // [+3 -6 +3  0]
+        // [-3 +3  0  0]
+        // [+1  0  0  0]
+
+        cx3 = -  x0+3*x1-3*x2+x3;
+        cx2 =  3*x0-6*x1+3*x2;
+        cx1 = -3*x0+3*x1;
+        cx0 =    x0;
+
+        cy3 = -  y0+3*y1-3*y2+y3;
+        cy2 =  3*y0-6*y1+3*y2;
+        cy1 = -3*y0+3*y1;
+        cy0 =    y0;
+    }
+
+    max_accel1 = fabs(2 * cy2) + fabs(6 * cy3);
+    max_accel2 = fabs(2 * cx2) + fabs(6 * cx3);
+
+    max_accel = FFMAX(max_accel1, max_accel2);
+    h = 1.0;
+
+    if (max_accel &gt; CURVE_ACCURACY)
+        h = sqrt(CURVE_ACCURACY / max_accel);
+
+    if (!started) {
+        cur.x = cx0;
+        cur.y = cy0;
+        drawing_add_point(drawing, &amp;cur);
+    }
+
+    for (t = 0; t &lt; 1.0; t += h) {
+        cur.x = cx0 + t * (cx1 + t * (cx2 + t * cx3));
+        cur.y = cy0 + t * (cy1 + t * (cy2 + t * cy3));
+        drawing_add_point(drawing, &amp;cur);
+    }
+
+    cur.x = cx0 + cx1 + cx2 + cx3;
+    cur.y = cy0 + cy1 + cy2 + cy3;
+    drawing_add_point(drawing, &amp;cur);
+}
+
+/*
+ * \brief Create and initialize a new drawing and return it
+ */
+ass_drawing_t *ass_drawing_new(void *fontconfig_priv, ass_font_t *font,
+                               ass_hinting_t hint, FT_Library lib)
+{
+    ass_drawing_t* drawing;
+
+    drawing = calloc(1, sizeof(*drawing));
+    drawing-&gt;text = calloc(1, DRAWING_INITIAL_SIZE);
+    drawing-&gt;size = DRAWING_INITIAL_SIZE;
+
+    drawing-&gt;ftlibrary = lib;
+    drawing-&gt;library = font-&gt;library;
+    drawing_make_glyph(drawing, fontconfig_priv, font, hint);
+
+    drawing-&gt;scale_x = 1.;
+    drawing-&gt;scale_y = 1.;
+    drawing-&gt;max_contours = GLYPH_INITIAL_CONTOURS;
+    drawing-&gt;max_points = GLYPH_INITIAL_POINTS;
+
+    return drawing;
+}
+
+/*
+ * \brief Free a drawing
+ */
+void ass_drawing_free(ass_drawing_t* drawing)
+{
+    FT_Done_Glyph((FT_Glyph) drawing-&gt;glyph);
+    free(drawing-&gt;text);
+    free(drawing);
+}
+
+/*
+ * \brief Add one ASCII character to the drawing text buffer
+ */
+void ass_drawing_add_char(ass_drawing_t* drawing, char symbol)
+{
+    drawing-&gt;text[drawing-&gt;i++] = symbol;
+    drawing-&gt;text[drawing-&gt;i] = 0;
+
+    if (drawing-&gt;i + 1 &gt;= drawing-&gt;size) {
+        drawing-&gt;size *= 2;
+        drawing-&gt;text = realloc(drawing-&gt;text, drawing-&gt;size);
+    }
+}
+
+/*
+ * \brief Create a hashcode for the drawing
+ * XXX: To avoid collisions a better hash algorithm might be useful.
+ */
+void ass_drawing_hash(ass_drawing_t* drawing)
+{
+    drawing-&gt;hash = fnv_32a_str(drawing-&gt;text, FNV1_32A_INIT);
+}
+
+/*
+ * \brief Convert token list to outline.  Calls the line and curve evaluators.
+ */
+FT_OutlineGlyph *ass_drawing_parse(ass_drawing_t *drawing, int raw_mode)
+{
+    int started = 0;
+    ass_drawing_token_t *token;
+    FT_Vector pen = {0, 0};
+
+    drawing-&gt;tokens = drawing_tokenize(drawing-&gt;text);
+    drawing_prepare(drawing);
+
+    token = drawing-&gt;tokens;
+    while (token) {
+        // Draw something according to current command
+        switch (token-&gt;type) {
+        case TOKEN_MOVE_NC:
+            pen = token-&gt;point;
+            translate_point(drawing, &amp;pen);
+            token = token-&gt;next;
+            break;
+        case TOKEN_MOVE:
+            pen = token-&gt;point;
+            translate_point(drawing, &amp;pen);
+            if (started) {
+                drawing_close_shape(drawing);
+                started = 0;
+            }
+            token = token-&gt;next;
+            break;
+        case TOKEN_LINE: {
+            FT_Vector to;
+            to = token-&gt;point;
+            translate_point(drawing, &amp;to);
+            if (!started) drawing_add_point(drawing, &amp;pen);
+            drawing_add_point(drawing, &amp;to);
+            started = 1;
+            token = token-&gt;next;
+            break;
+        }
+        case TOKEN_CUBIC_BEZIER:
+            if (token_check_values(token, 3, TOKEN_CUBIC_BEZIER) &amp;&amp;
+                token-&gt;prev) {
+                drawing_evaluate_curve(drawing, token-&gt;prev, 0, started);
+                token = token-&gt;next;
+                token = token-&gt;next;
+                token = token-&gt;next;
+                started = 1;
+            } else
+                token = token-&gt;next;
+            break;
+        case TOKEN_B_SPLINE:
+            if (token_check_values(token, 3, TOKEN_B_SPLINE) &amp;&amp;
+                token-&gt;prev) {
+                drawing_evaluate_curve(drawing, token-&gt;prev, 1, started);
+                token = token-&gt;next;
+                started = 1;
+            } else
+                token = token-&gt;next;
+            break;
+        default:
+            token = token-&gt;next;
+            break;
+        }
+    }
+
+    drawing_finish(drawing, raw_mode);
+    drawing_free_tokens(drawing-&gt;tokens);
+    return &amp;drawing-&gt;glyph;
+}

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_drawing.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_drawing.h	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_drawing.h	2009-08-01 07:55:22 UTC (rev 5185)
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2009 Grigori Goronzy &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">greg at geekmind.org</A>&gt;
+ *
+ * This file is part of libass.
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef LIBASS_DRAWING_H
+#define LIBASS_DRAWING_H
+
+#include &lt;ft2build.h&gt;
+#include FT_GLYPH_H
+
+#include &quot;ass.h&quot;
+
+#define DRAWING_INITIAL_SIZE 256
+
+typedef enum {
+    TOKEN_MOVE,
+    TOKEN_MOVE_NC,
+    TOKEN_LINE,
+    TOKEN_CUBIC_BEZIER,
+    TOKEN_CONIC_BEZIER,
+    TOKEN_B_SPLINE,
+    TOKEN_EXTEND_SPLINE,
+    TOKEN_CLOSE
+} ass_token_type_t;
+
+typedef struct ass_drawing_token {
+    ass_token_type_t type;
+    FT_Vector point;
+    struct ass_drawing_token *next;
+    struct ass_drawing_token *prev;
+} ass_drawing_token_t;
+
+typedef struct {
+    char *text; // drawing string
+    int i;      // text index
+    int scale;  // scale (1-64) for subpixel accuracy
+    double pbo; // drawing will be shifted in y direction by this amount
+    double scale_x;     // FontScaleX
+    double scale_y;     // FontScaleY
+    int asc;            // ascender
+    int desc;           // descender
+    FT_OutlineGlyph glyph;  // the &quot;fake&quot; glyph created for later rendering
+    int hash;           // hash value (for caching)
+
+    // private
+    FT_Library ftlibrary;   // FT library instance, needed for font ops
+    ass_library_t *library;
+    int size;           // current buffer size
+    ass_drawing_token_t *tokens;    // tokenized drawing
+    int max_points;     // current maximum size
+    int max_contours;
+    double point_scale_x;
+    double point_scale_y;
+} ass_drawing_t;
+
+ass_drawing_t *ass_drawing_new(void *fontconfig_priv, ass_font_t *font,
+                               ass_hinting_t hint, FT_Library lib);
+void ass_drawing_free(ass_drawing_t* drawing);
+void ass_drawing_add_char(ass_drawing_t* drawing, char symbol);
+void ass_drawing_hash(ass_drawing_t* drawing);
+FT_OutlineGlyph *ass_drawing_parse(ass_drawing_t *drawing, int raw_mode);
+
+#endif /* LIBASS_DRAWING_H */

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_font.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_font.c	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_font.c	2009-08-01 07:55:22 UTC (rev 5185)
@@ -0,0 +1,495 @@
+/*
+ * Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+ *
+ * This file is part of libass.
+ *
+ * libass is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libass is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with libass; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include &quot;config.h&quot;
+
+#include &lt;inttypes.h&gt;
+#include &lt;ft2build.h&gt;
+#include FT_FREETYPE_H
+#include FT_SYNTHESIS_H
+#include FT_GLYPH_H
+#include FT_TRUETYPE_TABLES_H
+
+#include &quot;ass.h&quot;
+#include &quot;ass_library.h&quot;
+#include &quot;ass_font.h&quot;
+#include &quot;ass_bitmap.h&quot;
+#include &quot;ass_cache.h&quot;
+#include &quot;ass_fontconfig.h&quot;
+#include &quot;ass_utils.h&quot;
+
+/**
+ * Select Microfost Unicode CharMap, if the font has one.
+ * Otherwise, let FreeType decide.
+ */
+static void charmap_magic(ass_library_t *library, FT_Face face)
+{
+    int i;
+    for (i = 0; i &lt; face-&gt;num_charmaps; ++i) {
+        FT_CharMap cmap = face-&gt;charmaps[i];
+        unsigned pid = cmap-&gt;platform_id;
+        unsigned eid = cmap-&gt;encoding_id;
+        if (pid == 3 /*microsoft */
+            &amp;&amp; (eid == 1 /*unicode bmp */
+                || eid == 10 /*full unicode */ )) {
+            FT_Set_Charmap(face, cmap);
+            return;
+        }
+    }
+
+    if (!face-&gt;charmap) {
+        if (face-&gt;num_charmaps == 0) {
+            ass_msg(library, MSGL_WARN, &quot;Font face with no charmaps&quot;);
+            return;
+        }
+        ass_msg(library, MSGL_WARN,
+                &quot;No charmap autodetected, trying the first one&quot;);
+        FT_Set_Charmap(face, face-&gt;charmaps[0]);
+        return;
+    }
+}
+
+static void update_transform(ass_font_t *font)
+{
+    int i;
+    FT_Matrix m;
+    m.xx = double_to_d16(font-&gt;scale_x);
+    m.yy = double_to_d16(font-&gt;scale_y);
+    m.xy = m.yx = 0;
+    for (i = 0; i &lt; font-&gt;n_faces; ++i)
+        FT_Set_Transform(font-&gt;faces[i], &amp;m, &amp;font-&gt;v);
+}
+
+/**
+ * \brief find a memory font by name
+ */
+static int find_font(ass_library_t *library, char *name)
+{
+    int i;
+    for (i = 0; i &lt; library-&gt;num_fontdata; ++i)
+        if (strcasecmp(name, library-&gt;fontdata[i].name) == 0)
+            return i;
+    return -1;
+}
+
+static void face_set_size(FT_Face face, double size);
+
+static void buggy_font_workaround(FT_Face face)
+{
+    // Some fonts have zero Ascender/Descender fields in 'hhea' table.
+    // In this case, get the information from 'os2' table or, as
+    // a last resort, from face.bbox.
+    if (face-&gt;ascender + face-&gt;descender == 0 || face-&gt;height == 0) {
+        TT_OS2 *os2 = FT_Get_Sfnt_Table(face, ft_sfnt_os2);
+        if (os2) {
+            face-&gt;ascender = os2-&gt;sTypoAscender;
+            face-&gt;descender = os2-&gt;sTypoDescender;
+            face-&gt;height = face-&gt;ascender - face-&gt;descender;
+        } else {
+            face-&gt;ascender = face-&gt;bbox.yMax;
+            face-&gt;descender = face-&gt;bbox.yMin;
+            face-&gt;height = face-&gt;ascender - face-&gt;descender;
+        }
+    }
+}
+
+/**
+ * \brief Select a face with the given charcode and add it to ass_font_t
+ * \return index of the new face in font-&gt;faces, -1 if failed
+ */
+static int add_face(void *fc_priv, ass_font_t *font, uint32_t ch)
+{
+    char *path;
+    int index;
+    FT_Face face;
+    int error;
+    int mem_idx;
+
+    if (font-&gt;n_faces == ASS_FONT_MAX_FACES)
+        return -1;
+
+    path =
+        fontconfig_select(font-&gt;library, fc_priv, font-&gt;desc.family,
+                          font-&gt;desc.treat_family_as_pattern,
+                          font-&gt;desc.bold, font-&gt;desc.italic, &amp;index, ch);
+    if (!path)
+        return -1;
+
+    mem_idx = find_font(font-&gt;library, path);
+    if (mem_idx &gt;= 0) {
+        error =
+            FT_New_Memory_Face(font-&gt;ftlibrary,
+                               (unsigned char *) font-&gt;library-&gt;
+                               fontdata[mem_idx].data,
+                               font-&gt;library-&gt;fontdata[mem_idx].size, 0,
+                               &amp;face);
+        if (error) {
+            ass_msg(font-&gt;library, MSGL_WARN,
+                    &quot;Error opening memory font: '%s'&quot;, path);
+            free(path);
+            return -1;
+        }
+    } else {
+        error = FT_New_Face(font-&gt;ftlibrary, path, index, &amp;face);
+        if (error) {
+            ass_msg(font-&gt;library, MSGL_WARN,
+                    &quot;Error opening font: '%s', %d&quot;, path, index);
+            free(path);
+            return -1;
+        }
+    }
+    charmap_magic(font-&gt;library, face);
+    buggy_font_workaround(face);
+
+    font-&gt;faces[font-&gt;n_faces++] = face;
+    update_transform(font);
+    face_set_size(face, font-&gt;size);
+    free(path);
+    return font-&gt;n_faces - 1;
+}
+
+/**
+ * \brief Create a new ass_font_t according to &quot;desc&quot; argument
+ */
+ass_font_t *ass_font_new(void *font_cache, ass_library_t *library,
+                         FT_Library ftlibrary, void *fc_priv,
+                         ass_font_desc_t *desc)
+{
+    int error;
+    ass_font_t *fontp;
+    ass_font_t font;
+
+    fontp = ass_font_cache_find((hashmap_t *) font_cache, desc);
+    if (fontp)
+        return fontp;
+
+    font.library = library;
+    font.ftlibrary = ftlibrary;
+    font.n_faces = 0;
+    font.desc.family = strdup(desc-&gt;family);
+    font.desc.treat_family_as_pattern = desc-&gt;treat_family_as_pattern;
+    font.desc.bold = desc-&gt;bold;
+    font.desc.italic = desc-&gt;italic;
+
+    font.scale_x = font.scale_y = 1.;
+    font.v.x = font.v.y = 0;
+    font.size = 0.;
+
+    error = add_face(fc_priv, &amp;font, 0);
+    if (error == -1) {
+        free(font.desc.family);
+        return 0;
+    } else
+        return ass_font_cache_add((hashmap_t *) font_cache, &amp;font);
+}
+
+/**
+ * \brief Set font transformation matrix and shift vector
+ **/
+void ass_font_set_transform(ass_font_t *font, double scale_x,
+                            double scale_y, FT_Vector *v)
+{
+    font-&gt;scale_x = scale_x;
+    font-&gt;scale_y = scale_y;
+    if (v) {
+        font-&gt;v.x = v-&gt;x;
+        font-&gt;v.y = v-&gt;y;
+    }
+    update_transform(font);
+}
+
+static void face_set_size(FT_Face face, double size)
+{
+#if (FREETYPE_MAJOR &gt; 2) || ((FREETYPE_MAJOR == 2) &amp;&amp; (FREETYPE_MINOR &gt; 1))
+    TT_HoriHeader *hori = FT_Get_Sfnt_Table(face, ft_sfnt_hhea);
+    TT_OS2 *os2 = FT_Get_Sfnt_Table(face, ft_sfnt_os2);
+    double mscale = 1.;
+    FT_Size_RequestRec rq;
+    FT_Size_Metrics *m = &amp;face-&gt;size-&gt;metrics;
+    // VSFilter uses metrics from TrueType OS/2 table
+    // The idea was borrowed from asa (<A HREF="http://asa.diac24.net">http://asa.diac24.net</A>)
+    if (hori &amp;&amp; os2) {
+        int hori_height = hori-&gt;Ascender - hori-&gt;Descender;
+        int os2_height = os2-&gt;usWinAscent + os2-&gt;usWinDescent;
+        if (hori_height &amp;&amp; os2_height)
+            mscale = (double) hori_height / os2_height;
+    }
+    memset(&amp;rq, 0, sizeof(rq));
+    rq.type = FT_SIZE_REQUEST_TYPE_REAL_DIM;
+    rq.width = 0;
+    rq.height = double_to_d6(size * mscale);
+    rq.horiResolution = rq.vertResolution = 0;
+    FT_Request_Size(face, &amp;rq);
+    m-&gt;ascender /= mscale;
+    m-&gt;descender /= mscale;
+    m-&gt;height /= mscale;
+#else
+    FT_Set_Char_Size(face, 0, double_to_d6(size), 0, 0);
+#endif
+}
+
+/**
+ * \brief Set font size
+ **/
+void ass_font_set_size(ass_font_t *font, double size)
+{
+    int i;
+    if (font-&gt;size != size) {
+        font-&gt;size = size;
+        for (i = 0; i &lt; font-&gt;n_faces; ++i)
+            face_set_size(font-&gt;faces[i], size);
+    }
+}
+
+/**
+ * \brief Get maximal font ascender and descender.
+ * \param ch character code
+ * The values are extracted from the font face that provides glyphs for the given character
+ **/
+void ass_font_get_asc_desc(ass_font_t *font, uint32_t ch, int *asc,
+                           int *desc)
+{
+    int i;
+    for (i = 0; i &lt; font-&gt;n_faces; ++i) {
+        FT_Face face = font-&gt;faces[i];
+        TT_OS2 *os2 = FT_Get_Sfnt_Table(face, ft_sfnt_os2);
+        if (FT_Get_Char_Index(face, ch)) {
+            int y_scale = face-&gt;size-&gt;metrics.y_scale;
+            if (os2) {
+                *asc = FT_MulFix(os2-&gt;usWinAscent, y_scale);
+                *desc = FT_MulFix(os2-&gt;usWinDescent, y_scale);
+            } else {
+                *asc = FT_MulFix(face-&gt;ascender, y_scale);
+                *desc = FT_MulFix(-face-&gt;descender, y_scale);
+            }
+            return;
+        }
+    }
+
+    *asc = *desc = 0;
+}
+
+/*
+ * Strike a glyph with a horizontal line; it's possible to underline it
+ * and/or strike through it.  For the line's position and size, truetype
+ * tables are consulted.  Obviously this relies on the data in the tables
+ * being accurate.
+ *
+ */
+static int ass_strike_outline_glyph(FT_Face face, ass_font_t *font,
+                                    FT_Glyph glyph, int under, int through)
+{
+    TT_OS2 *os2 = FT_Get_Sfnt_Table(face, ft_sfnt_os2);
+    TT_Postscript *ps = FT_Get_Sfnt_Table(face, ft_sfnt_post);
+    FT_Outline *ol = &amp;((FT_OutlineGlyph) glyph)-&gt;outline;
+    int bear, advance, y_scale, i;
+
+    // Grow outline
+    i = (under ? 4 : 0) + (through ? 4 : 0);
+    ol-&gt;points = realloc(ol-&gt;points, sizeof(FT_Vector) *
+                         (ol-&gt;n_points + i));
+    ol-&gt;tags = realloc(ol-&gt;tags, ol-&gt;n_points + i);
+    i = !!under + !!through;
+    ol-&gt;contours = realloc(ol-&gt;contours, sizeof(short) *
+                           (ol-&gt;n_contours + i));
+
+    // If the bearing is negative, the glyph starts left of the current
+    // pen position
+    bear = FFMIN(face-&gt;glyph-&gt;metrics.horiBearingX, 0);
+    // We're adding half a pixel to avoid small gaps
+    advance = d16_to_d6(glyph-&gt;advance.x) + 32;
+    y_scale = face-&gt;size-&gt;metrics.y_scale;
+
+    // Add points to the outline
+    if (under &amp;&amp; ps) {
+        int pos, size;
+        pos = FT_MulFix(ps-&gt;underlinePosition, y_scale * font-&gt;scale_y);
+        size = FT_MulFix(ps-&gt;underlineThickness,
+                         y_scale * font-&gt;scale_y / 2);
+
+        if (pos &gt; 0 || size &lt;= 0)
+            return 0;
+
+        FT_Vector points[4] = {
+            {.x = bear,      .y = pos + size},
+            {.x = advance,   .y = pos + size},
+            {.x = advance,   .y = pos - size},
+            {.x = bear,      .y = pos - size},
+        };
+
+        for (i = 0; i &lt; 4; i++) {
+            ol-&gt;points[ol-&gt;n_points] = points[i];
+            ol-&gt;tags[ol-&gt;n_points++] = 1;
+        }
+        ol-&gt;contours[ol-&gt;n_contours++] = ol-&gt;n_points - 1;
+    }
+
+    if (through &amp;&amp; os2) {
+        int pos, size;
+        pos = FT_MulFix(os2-&gt;yStrikeoutPosition, y_scale * font-&gt;scale_y);
+        size = FT_MulFix(os2-&gt;yStrikeoutSize, y_scale * font-&gt;scale_y / 2);
+
+        if (pos &lt; 0 || size &lt;= 0)
+            return 0;
+
+        FT_Vector points[4] = {
+            {.x = bear,      .y = pos + size},
+            {.x = advance,   .y = pos + size},
+            {.x = advance,   .y = pos - size},
+            {.x = bear,      .y = pos - size},
+        };
+
+        for (i = 0; i &lt; 4; i++) {
+            ol-&gt;points[ol-&gt;n_points] = points[i];
+            ol-&gt;tags[ol-&gt;n_points++] = 1;
+        }
+
+        ol-&gt;contours[ol-&gt;n_contours++] = ol-&gt;n_points - 1;
+    }
+
+    return 1;
+}
+
+/**
+ * \brief Get a glyph
+ * \param ch character code
+ **/
+FT_Glyph ass_font_get_glyph(void *fontconfig_priv, ass_font_t *font,
+                            uint32_t ch, ass_hinting_t hinting, int deco)
+{
+    int error;
+    int index = 0;
+    int i;
+    FT_Glyph glyph;
+    FT_Face face = 0;
+    int flags = 0;
+
+    if (ch &lt; 0x20)
+        return 0;
+    if (font-&gt;n_faces == 0)
+        return 0;
+
+    for (i = 0; i &lt; font-&gt;n_faces; ++i) {
+        face = font-&gt;faces[i];
+        index = FT_Get_Char_Index(face, ch);
+        if (index)
+            break;
+    }
+
+#ifdef CONFIG_FONTCONFIG
+    if (index == 0) {
+        int face_idx;
+        ass_msg(font-&gt;library, MSGL_INFO,
+                &quot;Glyph 0x%X not found, selecting one more &quot;
+                &quot;font for (%s, %d, %d)&quot;, ch, font-&gt;desc.family,
+                font-&gt;desc.bold, font-&gt;desc.italic);
+        face_idx = add_face(fontconfig_priv, font, ch);
+        if (face_idx &gt;= 0) {
+            face = font-&gt;faces[face_idx];
+            index = FT_Get_Char_Index(face, ch);
+            if (index == 0) {
+                ass_msg(font-&gt;library, MSGL_ERR,
+                        &quot;Glyph 0x%X not found in font for (%s, %d, %d)&quot;,
+                        ch, font-&gt;desc.family, font-&gt;desc.bold,
+                        font-&gt;desc.italic);
+            }
+        }
+    }
+#endif
+
+    switch (hinting) {
+    case ASS_HINTING_NONE:
+        flags = FT_LOAD_NO_HINTING;
+        break;
+    case ASS_HINTING_LIGHT:
+        flags = FT_LOAD_FORCE_AUTOHINT | FT_LOAD_TARGET_LIGHT;
+        break;
+    case ASS_HINTING_NORMAL:
+        flags = FT_LOAD_FORCE_AUTOHINT;
+        break;
+    case ASS_HINTING_NATIVE:
+        flags = 0;
+        break;
+    }
+
+    error = FT_Load_Glyph(face, index, FT_LOAD_NO_BITMAP | flags);
+    if (error) {
+        ass_msg(font-&gt;library, MSGL_WARN, &quot;Error loading glyph, index %d&quot;,
+                index);
+        return 0;
+    }
+#if (FREETYPE_MAJOR &gt; 2) || \
+    ((FREETYPE_MAJOR == 2) &amp;&amp; (FREETYPE_MINOR &gt;= 2)) || \
+    ((FREETYPE_MAJOR == 2) &amp;&amp; (FREETYPE_MINOR == 1) &amp;&amp; (FREETYPE_PATCH &gt;= 10))
+// FreeType &gt;= 2.1.10 required
+    if (!(face-&gt;style_flags &amp; FT_STYLE_FLAG_ITALIC) &amp;&amp;
+        (font-&gt;desc.italic &gt; 55)) {
+        FT_GlyphSlot_Oblique(face-&gt;glyph);
+    }
+#endif
+    error = FT_Get_Glyph(face-&gt;glyph, &amp;glyph);
+    if (error) {
+        ass_msg(font-&gt;library, MSGL_WARN, &quot;Error loading glyph, index %d&quot;,
+                index);
+        return 0;
+    }
+
+    ass_strike_outline_glyph(face, font, glyph, deco &amp; DECO_UNDERLINE,
+                             deco &amp; DECO_STRIKETHROUGH);
+
+    return glyph;
+}
+
+/**
+ * \brief Get kerning for the pair of glyphs.
+ **/
+FT_Vector ass_font_get_kerning(ass_font_t *font, uint32_t c1, uint32_t c2)
+{
+    FT_Vector v = { 0, 0 };
+    int i;
+
+    for (i = 0; i &lt; font-&gt;n_faces; ++i) {
+        FT_Face face = font-&gt;faces[i];
+        int i1 = FT_Get_Char_Index(face, c1);
+        int i2 = FT_Get_Char_Index(face, c2);
+        if (i1 &amp;&amp; i2) {
+            if (FT_HAS_KERNING(face))
+                FT_Get_Kerning(face, i1, i2, FT_KERNING_DEFAULT, &amp;v);
+            return v;
+        }
+        if (i1 || i2)           // these glyphs are from different font faces, no kerning information
+            return v;
+    }
+    return v;
+}
+
+/**
+ * \brief Deallocate ass_font_t
+ **/
+void ass_font_free(ass_font_t *font)
+{
+    int i;
+    for (i = 0; i &lt; font-&gt;n_faces; ++i)
+        if (font-&gt;faces[i])
+            FT_Done_Face(font-&gt;faces[i]);
+    if (font-&gt;desc.family)
+        free(font-&gt;desc.family);
+    free(font);
+}

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_font.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_font.h	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_font.h	2009-08-01 07:55:22 UTC (rev 5185)
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+ *
+ * This file is part of libass.
+ *
+ * libass is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libass is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with libass; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef LIBASS_FONT_H
+#define LIBASS_FONT_H
+
+#include &lt;stdint.h&gt;
+#include &lt;ft2build.h&gt;
+#include FT_GLYPH_H
+#include &quot;ass.h&quot;
+#include &quot;ass_types.h&quot;
+
+#define ASS_FONT_MAX_FACES 10
+#define DECO_UNDERLINE 1
+#define DECO_STRIKETHROUGH 2
+
+typedef struct {
+    char *family;
+    unsigned bold;
+    unsigned italic;
+    int treat_family_as_pattern;
+} ass_font_desc_t;
+
+typedef struct {
+    ass_font_desc_t desc;
+    ass_library_t *library;
+    FT_Library ftlibrary;
+    FT_Face faces[ASS_FONT_MAX_FACES];
+    int n_faces;
+    double scale_x, scale_y;    // current transform
+    FT_Vector v;                // current shift
+    double size;
+} ass_font_t;
+
+// FIXME: passing the hashmap via a void pointer is very ugly.
+ass_font_t *ass_font_new(void *font_cache, ass_library_t *library,
+                         FT_Library ftlibrary, void *fc_priv,
+                         ass_font_desc_t *desc);
+void ass_font_set_transform(ass_font_t *font, double scale_x,
+                            double scale_y, FT_Vector *v);
+void ass_font_set_size(ass_font_t *font, double size);
+void ass_font_get_asc_desc(ass_font_t *font, uint32_t ch, int *asc,
+                           int *desc);
+FT_Glyph ass_font_get_glyph(void *fontconfig_priv, ass_font_t *font,
+                            uint32_t ch, ass_hinting_t hinting, int flags);
+FT_Vector ass_font_get_kerning(ass_font_t *font, uint32_t c1, uint32_t c2);
+void ass_font_free(ass_font_t *font);
+
+#endif                          /* LIBASS_FONT_H */

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_fontconfig.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_fontconfig.c	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_fontconfig.c	2009-08-01 07:55:22 UTC (rev 5185)
@@ -0,0 +1,575 @@
+/*
+ * Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+ *
+ * This file is part of libass.
+ *
+ * libass is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libass is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with libass; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include &quot;config.h&quot;
+
+#include &lt;stdlib.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;assert.h&gt;
+#include &lt;string.h&gt;
+#include &lt;sys/types.h&gt;
+#include &lt;sys/stat.h&gt;
+#include &lt;inttypes.h&gt;
+#include &lt;ft2build.h&gt;
+#include FT_FREETYPE_H
+
+#include &quot;ass_utils.h&quot;
+#include &quot;ass.h&quot;
+#include &quot;ass_library.h&quot;
+#include &quot;ass_fontconfig.h&quot;
+
+#ifdef CONFIG_FONTCONFIG
+#include &lt;fontconfig/fontconfig.h&gt;
+#include &lt;fontconfig/fcfreetype.h&gt;
+#endif
+
+struct fc_instance {
+#ifdef CONFIG_FONTCONFIG
+    FcConfig *config;
+#endif
+    char *family_default;
+    char *path_default;
+    int index_default;
+};
+
+#ifdef CONFIG_FONTCONFIG
+
+// 4yo fontconfig does not have these.
+// They are only needed for debug output, anyway.
+#ifndef FC_FULLNAME
+#define FC_FULLNAME &quot;fullname&quot;
+#endif
+#ifndef FC_EMBOLDEN
+#define FC_EMBOLDEN &quot;embolden&quot;
+#endif
+
+/**
+ * \brief Low-level font selection.
+ * \param priv private data
+ * \param family font family
+ * \param treat_family_as_pattern treat family as fontconfig pattern
+ * \param bold font weight value
+ * \param italic font slant value
+ * \param index out: font index inside a file
+ * \param code: the character that should be present in the font, can be 0
+ * \return font file path
+*/
+static char *_select_font(ass_library_t *library, fc_instance_t *priv,
+                          const char *family, int treat_family_as_pattern,
+                          unsigned bold, unsigned italic, int *index,
+                          uint32_t code)
+{
+    FcBool rc;
+    FcResult result;
+    FcPattern *pat = NULL, *rpat = NULL;
+    int r_index, r_slant, r_weight;
+    FcChar8 *r_family, *r_style, *r_file, *r_fullname;
+    FcBool r_outline, r_embolden;
+    FcCharSet *r_charset;
+    FcFontSet *fset = NULL;
+    int curf;
+    char *retval = NULL;
+    int family_cnt = 0;
+
+    *index = 0;
+
+    if (treat_family_as_pattern)
+        pat = FcNameParse((const FcChar8 *) family);
+    else
+        pat = FcPatternCreate();
+
+    if (!pat)
+        goto error;
+
+    if (!treat_family_as_pattern) {
+        FcPatternAddString(pat, FC_FAMILY, (const FcChar8 *) family);
+
+        // In SSA/ASS fonts are sometimes referenced by their &quot;full name&quot;,
+        // which is usually a concatenation of family name and font
+        // style (ex. Ottawa Bold). Full name is available from
+        // FontConfig pattern element FC_FULLNAME, but it is never
+        // used for font matching.
+        // Therefore, I'm removing words from the end of the name one
+        // by one, and adding shortened names to the pattern. It seems
+        // that the first value (full name in this case) has
+        // precedence in matching.
+        // An alternative approach could be to reimplement FcFontSort
+        // using FC_FULLNAME instead of FC_FAMILY.
+        family_cnt = 1;
+        {
+            char *s = strdup(family);
+            char *p = s + strlen(s);
+            while (--p &gt; s)
+                if (*p == ' ' || *p == '-') {
+                    *p = '\0';
+                    FcPatternAddString(pat, FC_FAMILY, (const FcChar8 *) s);
+                    ++family_cnt;
+                }
+            free(s);
+        }
+    }
+    FcPatternAddBool(pat, FC_OUTLINE, FcTrue);
+    FcPatternAddInteger(pat, FC_SLANT, italic);
+    FcPatternAddInteger(pat, FC_WEIGHT, bold);
+
+    FcDefaultSubstitute(pat);
+
+    rc = FcConfigSubstitute(priv-&gt;config, pat, FcMatchPattern);
+    if (!rc)
+        goto error;
+
+    fset = FcFontSort(priv-&gt;config, pat, FcTrue, NULL, &amp;result);
+    if (!fset)
+        goto error;
+
+    for (curf = 0; curf &lt; fset-&gt;nfont; ++curf) {
+        FcPattern *curp = fset-&gt;fonts[curf];
+
+        result = FcPatternGetBool(curp, FC_OUTLINE, 0, &amp;r_outline);
+        if (result != FcResultMatch)
+            continue;
+        if (r_outline != FcTrue)
+            continue;
+        if (!code)
+            break;
+        result = FcPatternGetCharSet(curp, FC_CHARSET, 0, &amp;r_charset);
+        if (result != FcResultMatch)
+            continue;
+        if (FcCharSetHasChar(r_charset, code))
+            break;
+    }
+
+    if (curf &gt;= fset-&gt;nfont)
+        goto error;
+
+#if (FC_VERSION &gt;= 20297)
+    if (!treat_family_as_pattern) {
+        // Remove all extra family names from original pattern.
+        // After this, FcFontRenderPrepare will select the most relevant family
+        // name in case there are more than one of them.
+        for (; family_cnt &gt; 1; --family_cnt)
+            FcPatternRemove(pat, FC_FAMILY, family_cnt - 1);
+    }
+#endif
+
+    rpat = FcFontRenderPrepare(priv-&gt;config, pat, fset-&gt;fonts[curf]);
+    if (!rpat)
+        goto error;
+
+    result = FcPatternGetInteger(rpat, FC_INDEX, 0, &amp;r_index);
+    if (result != FcResultMatch)
+        goto error;
+    *index = r_index;
+
+    result = FcPatternGetString(rpat, FC_FILE, 0, &amp;r_file);
+    if (result != FcResultMatch)
+        goto error;
+    retval = strdup((const char *) r_file);
+
+    result = FcPatternGetString(rpat, FC_FAMILY, 0, &amp;r_family);
+    if (result != FcResultMatch)
+        r_family = NULL;
+
+    result = FcPatternGetString(rpat, FC_FULLNAME, 0, &amp;r_fullname);
+    if (result != FcResultMatch)
+        r_fullname = NULL;
+
+    if (!treat_family_as_pattern &amp;&amp;
+        !(r_family &amp;&amp; strcasecmp((const char *) r_family, family) == 0) &amp;&amp;
+        !(r_fullname &amp;&amp; strcasecmp((const char *) r_fullname, family) == 0))
+        ass_msg(library, MSGL_WARN,
+               &quot;fontconfig: Selected font is not the requested one: &quot;
+               &quot;'%s' != '%s'&quot;,
+               (const char *) (r_fullname ? r_fullname : r_family), family);
+
+    result = FcPatternGetString(rpat, FC_STYLE, 0, &amp;r_style);
+    if (result != FcResultMatch)
+        r_style = NULL;
+
+    result = FcPatternGetInteger(rpat, FC_SLANT, 0, &amp;r_slant);
+    if (result != FcResultMatch)
+        r_slant = 0;
+
+    result = FcPatternGetInteger(rpat, FC_WEIGHT, 0, &amp;r_weight);
+    if (result != FcResultMatch)
+        r_weight = 0;
+
+    result = FcPatternGetBool(rpat, FC_EMBOLDEN, 0, &amp;r_embolden);
+    if (result != FcResultMatch)
+        r_embolden = 0;
+
+    ass_msg(library, MSGL_V,
+           &quot;Font info: family '%s', style '%s', fullname '%s',&quot;
+           &quot; slant %d, weight %d%s&quot;, (const char *) r_family,
+           (const char *) r_style, (const char *) r_fullname, r_slant,
+           r_weight, r_embolden ? &quot;, embolden&quot; : &quot;&quot;);
+
+  error:
+    if (pat)
+        FcPatternDestroy(pat);
+    if (rpat)
+        FcPatternDestroy(rpat);
+    if (fset)
+        FcFontSetDestroy(fset);
+    return retval;
+}
+
+/**
+ * \brief Find a font. Use default family or path if necessary.
+ * \param priv_ private data
+ * \param family font family
+ * \param treat_family_as_pattern treat family as fontconfig pattern
+ * \param bold font weight value
+ * \param italic font slant value
+ * \param index out: font index inside a file
+ * \param code: the character that should be present in the font, can be 0
+ * \return font file path
+*/
+char *fontconfig_select(ass_library_t *library, fc_instance_t *priv,
+                        const char *family, int treat_family_as_pattern,
+                        unsigned bold, unsigned italic, int *index,
+                        uint32_t code)
+{
+    char *res = 0;
+    if (!priv-&gt;config) {
+        *index = priv-&gt;index_default;
+        return priv-&gt;path_default;
+    }
+    if (family &amp;&amp; *family)
+        res =
+            _select_font(library, priv, family, treat_family_as_pattern,
+                         bold, italic, index, code);
+    if (!res &amp;&amp; priv-&gt;family_default) {
+        res =
+            _select_font(library, priv, priv-&gt;family_default, 0, bold,
+                         italic, index, code);
+        if (res)
+            ass_msg(library, MSGL_WARN, &quot;fontconfig_select: Using default &quot;
+                    &quot;font family: (%s, %d, %d) -&gt; %s, %d&quot;,
+                    family, bold, italic, res, *index);
+    }
+    if (!res &amp;&amp; priv-&gt;path_default) {
+        res = priv-&gt;path_default;
+        *index = priv-&gt;index_default;
+        ass_msg(library, MSGL_WARN, &quot;fontconfig_select: Using default font: &quot;
+                &quot;(%s, %d, %d) -&gt; %s, %d&quot;, family, bold, italic,
+                res, *index);
+    }
+    if (!res) {
+        res = _select_font(library, priv, &quot;Arial&quot;, 0, bold, italic,
+                           index, code);
+        if (res)
+            ass_msg(library, MSGL_WARN, &quot;fontconfig_select: Using 'Arial' &quot;
+                    &quot;font family: (%s, %d, %d) -&gt; %s, %d&quot;, family, bold,
+                    italic, res, *index);
+    }
+    if (res)
+        ass_msg(library, MSGL_V,
+                &quot;fontconfig_select: (%s, %d, %d) -&gt; %s, %d&quot;, family, bold,
+                italic, res, *index);
+    return res;
+}
+
+#if (FC_VERSION &lt; 20402)
+static char *validate_fname(char *name)
+{
+    char *fname;
+    char *p;
+    char *q;
+    unsigned code;
+    int sz = strlen(name);
+
+    q = fname = malloc(sz + 1);
+    p = name;
+    while (*p) {
+        code = ass_utf8_get_char(&amp;p);
+        if (code == 0)
+            break;
+        if ((code &gt; 0x7F) ||
+            (code == '\\') ||
+            (code == '/') ||
+            (code == ':') ||
+            (code == '*') ||
+            (code == '?') ||
+            (code == '&lt;') ||
+            (code == '&gt;') || (code == '|') || (code == 0)) {
+            *q++ = '_';
+        } else {
+            *q++ = code;
+        }
+        if (p - name &gt; sz)
+            break;
+    }
+    *q = 0;
+    return fname;
+}
+#endif
+
+/**
+ * \brief Process memory font.
+ * \param priv private data
+ * \param library library object
+ * \param ftlibrary freetype library object
+ * \param idx index of the processed font in library-&gt;fontdata
+ * With FontConfig &gt;= 2.4.2, builds a font pattern in memory via FT_New_Memory_Face/FcFreeTypeQueryFace.
+ * With older FontConfig versions, save the font to ~/.mplayer/fonts.
+*/
+static void process_fontdata(fc_instance_t *priv, ass_library_t *library,
+                             FT_Library ftlibrary, int idx)
+{
+    int rc;
+    const char *name = library-&gt;fontdata[idx].name;
+    const char *data = library-&gt;fontdata[idx].data;
+    int data_size = library-&gt;fontdata[idx].size;
+
+#if (FC_VERSION &lt; 20402)
+    struct stat st;
+    char *fname;
+    const char *fonts_dir = library-&gt;fonts_dir;
+    char buf[1000];
+    FILE *fp = NULL;
+
+    if (!fonts_dir)
+        return;
+    rc = stat(fonts_dir, &amp;st);
+    if (rc) {
+        int res;
+#ifndef __MINGW32__
+        res = mkdir(fonts_dir, 0700);
+#else
+        res = mkdir(fonts_dir);
+#endif
+        if (res) {
+            ass_msg(library, MSGL_WARN, &quot;Failed to create directory '%s'&quot;,
+                    fonts_dir);
+        }
+    } else if (!S_ISDIR(st.st_mode)) {
+        ass_msg(library, MSGL_WARN, &quot;Not a directory: '%s'&quot;, fonts_dir);
+    }
+
+    fname = validate_fname((char *) name);
+
+    snprintf(buf, 1000, &quot;%s/%s&quot;, fonts_dir, fname);
+    free(fname);
+
+    fp = fopen(buf, &quot;wb&quot;);
+    if (!fp)
+        return;
+
+    fwrite(data, data_size, 1, fp);
+    fclose(fp);
+
+#else                           // (FC_VERSION &gt;= 20402)
+    FT_Face face;
+    FcPattern *pattern;
+    FcFontSet *fset;
+    FcBool res;
+    int face_index, num_faces = 1;
+
+    for (face_index = 0; face_index &lt; num_faces; ++face_index) {
+        rc = FT_New_Memory_Face(ftlibrary, (unsigned char *) data,
+                                data_size, face_index, &amp;face);
+        if (rc) {
+            ass_msg(library, MSGL_WARN, &quot;Error opening memory font: %s&quot;,
+                   name);
+            return;
+        }
+        num_faces = face-&gt;num_faces;
+
+        pattern =
+            FcFreeTypeQueryFace(face, (unsigned char *) name, 0,
+                                FcConfigGetBlanks(priv-&gt;config));
+        if (!pattern) {
+            ass_msg(library, MSGL_WARN, &quot;%s failed&quot;, &quot;FcFreeTypeQueryFace&quot;);
+            FT_Done_Face(face);
+            return;
+        }
+
+        fset = FcConfigGetFonts(priv-&gt;config, FcSetSystem);     // somehow it failes when asked for FcSetApplication
+        if (!fset) {
+            ass_msg(library, MSGL_WARN, &quot;%s failed&quot;, &quot;FcConfigGetFonts&quot;);
+            FT_Done_Face(face);
+            return;
+        }
+
+        res = FcFontSetAdd(fset, pattern);
+        if (!res) {
+            ass_msg(library, MSGL_WARN, &quot;%s failed&quot;, &quot;FcFontSetAdd&quot;);
+            FT_Done_Face(face);
+            return;
+        }
+
+        FT_Done_Face(face);
+    }
+#endif
+}
+
+/**
+ * \brief Init fontconfig.
+ * \param library libass library object
+ * \param ftlibrary freetype library object
+ * \param family default font family
+ * \param path default font path
+ * \param fc whether fontconfig should be used
+ * \param config path to a fontconfig configuration file, or NULL
+ * \param update whether the fontconfig cache should be built/updated
+ * \return pointer to fontconfig private data
+*/
+fc_instance_t *fontconfig_init(ass_library_t *library,
+                               FT_Library ftlibrary, const char *family,
+                               const char *path, int fc, const char *config,
+                               int update)
+{
+    int rc;
+    fc_instance_t *priv = calloc(1, sizeof(fc_instance_t));
+    const char *dir = library-&gt;fonts_dir;
+    int i;
+
+    if (!fc) {
+        ass_msg(library, MSGL_WARN,
+               &quot;Fontconfig disabled, only default font will be used.&quot;);
+        goto exit;
+    }
+
+    priv-&gt;config = FcConfigCreate();
+    rc = FcConfigParseAndLoad(priv-&gt;config, (unsigned char *) config, FcTrue);
+    if (!rc) {
+        ass_msg(library, MSGL_WARN, &quot;No usable fontconfig configuration &quot;
+                &quot;file found, using fallback.&quot;);
+        FcConfigDestroy(priv-&gt;config);
+        priv-&gt;config = FcInitLoadConfig();
+        rc++;
+    }
+    if (rc &amp;&amp; update) {
+        FcConfigBuildFonts(priv-&gt;config);
+    }
+
+    if (!rc || !priv-&gt;config) {
+        ass_msg(library, MSGL_FATAL,
+                &quot;No valid fontconfig configuration found!&quot;);
+        FcConfigDestroy(priv-&gt;config);
+        goto exit;
+    }
+
+    for (i = 0; i &lt; library-&gt;num_fontdata; ++i)
+        process_fontdata(priv, library, ftlibrary, i);
+
+    if (dir) {
+        if (FcDirCacheValid((const FcChar8 *) dir) == FcFalse) {
+            ass_msg(library, MSGL_INFO, &quot;Updating font cache&quot;);
+            if (FcGetVersion() &gt;= 20390 &amp;&amp; FcGetVersion() &lt; 20400)
+                ass_msg(library, MSGL_WARN, &quot;Beta versions of fontconfig&quot;
+                        &quot;are not supported. Update before reporting any bugs&quot;);
+            // FontConfig &gt;= 2.4.0 updates cache automatically in FcConfigAppFontAddDir()
+            if (FcGetVersion() &lt; 20390) {
+                FcFontSet *fcs;
+                FcStrSet *fss;
+                fcs = FcFontSetCreate();
+                fss = FcStrSetCreate();
+                rc = FcStrSetAdd(fss, (const FcChar8 *) dir);
+                if (!rc) {
+                    ass_msg(library, MSGL_WARN, &quot;%s failed&quot;, &quot;FcStrSetAdd&quot;);
+                    goto ErrorFontCache;
+                }
+
+                rc = FcDirScan(fcs, fss, NULL,
+                               FcConfigGetBlanks(priv-&gt;config),
+                               (const FcChar8 *) dir, FcFalse);
+                if (!rc) {
+                    ass_msg(library, MSGL_WARN, &quot;%s failed&quot;, &quot;FcDirScan&quot;);
+                    goto ErrorFontCache;
+                }
+
+                rc = FcDirSave(fcs, fss, (const FcChar8 *) dir);
+                if (!rc) {
+                    ass_msg(library, MSGL_WARN, &quot;%s failed&quot;, &quot;FcDirSave&quot;);
+                    goto ErrorFontCache;
+                }
+              ErrorFontCache:
+                ;
+            }
+        }
+
+        rc = FcConfigAppFontAddDir(priv-&gt;config, (const FcChar8 *) dir);
+        if (!rc) {
+            ass_msg(library, MSGL_WARN, &quot;%s failed&quot;, &quot;FcConfigAppFontAddDir&quot;);
+        }
+    }
+
+    priv-&gt;family_default = family ? strdup(family) : NULL;
+exit:
+    priv-&gt;path_default = path ? strdup(path) : NULL;
+    priv-&gt;index_default = 0;
+
+    return priv;
+}
+
+int fontconfig_update(fc_instance_t *priv)
+{
+        return FcConfigBuildFonts(priv-&gt;config);
+}
+
+#else                           /* CONFIG_FONTCONFIG */
+
+char *fontconfig_select(ass_library_t *library, fc_instance_t *priv,
+                        const char *family, int treat_family_as_pattern,
+                        unsigned bold, unsigned italic, int *index,
+                        uint32_t code)
+{
+    *index = priv-&gt;index_default;
+    return priv-&gt;path_default;
+}
+
+fc_instance_t *fontconfig_init(ass_library_t *library,
+                               FT_Library ftlibrary, const char *family,
+                               const char *path, int fc, const char *config,
+                               int update)
+{
+    fc_instance_t *priv;
+
+    ass_msg(library, MSGL_WARN,
+        &quot;Fontconfig disabled, only default font will be used.&quot;);
+
+    priv = calloc(1, sizeof(fc_instance_t));
+
+    priv-&gt;path_default = strdup(path);
+    priv-&gt;index_default = 0;
+    return priv;
+}
+
+int fontconfig_update(fc_instance_t *priv)
+{
+    // Do nothing
+    return 1;
+}
+
+#endif
+
+void fontconfig_done(fc_instance_t *priv)
+{
+    if (priv &amp;&amp; priv-&gt;config)
+        FcConfigDestroy(priv-&gt;config);
+    if (priv &amp;&amp; priv-&gt;path_default)
+        free(priv-&gt;path_default);
+    if (priv &amp;&amp; priv-&gt;family_default)
+        free(priv-&gt;family_default);
+    if (priv)
+        free(priv);
+}

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_fontconfig.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_fontconfig.h	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_fontconfig.h	2009-08-01 07:55:22 UTC (rev 5185)
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+ *
+ * This file is part of libass.
+ *
+ * libass is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libass is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with libass; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef LIBASS_FONTCONFIG_H
+#define LIBASS_FONTCONFIG_H
+
+#include &lt;stdint.h&gt;
+#include &quot;ass_types.h&quot;
+#include &quot;ass.h&quot;
+#include &lt;ft2build.h&gt;
+#include FT_FREETYPE_H
+
+#ifdef CONFIG_FONTCONFIG
+#include &lt;fontconfig/fontconfig.h&gt;
+#endif
+
+typedef struct fc_instance fc_instance_t;
+
+fc_instance_t *fontconfig_init(ass_library_t *library,
+                               FT_Library ftlibrary, const char *family,
+                               const char *path, int fc, const char *config,
+                               int update);
+char *fontconfig_select(ass_library_t *library, fc_instance_t *priv,
+                        const char *family, int treat_family_as_pattern,
+                        unsigned bold, unsigned italic, int *index,
+                        uint32_t code);
+void fontconfig_done(fc_instance_t *priv);
+int fontconfig_update(fc_instance_t *priv);
+
+#endif                          /* LIBASS_FONTCONFIG_H */

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_library.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_library.c	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_library.c	2009-08-01 07:55:22 UTC (rev 5185)
@@ -0,0 +1,147 @@
+/*
+ * Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+ *
+ * This file is part of libass.
+ *
+ * libass is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libass is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with libass; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include &lt;inttypes.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;stdarg.h&gt;
+
+#include &quot;ass.h&quot;
+#include &quot;ass_library.h&quot;
+#include &quot;ass_utils.h&quot;
+
+static void ass_msg_handler(int level, const char *fmt, va_list va, void *data)
+{
+    if (level &gt; MSGL_INFO)
+        return;
+    fprintf(stderr, &quot;[ass] &quot;);
+    vfprintf(stderr, fmt, va);
+    fprintf(stderr, &quot;\n&quot;);
+}
+
+ass_library_t *ass_library_init(void)
+{
+    ass_library_t* lib = calloc(1, sizeof(ass_library_t));
+    lib-&gt;msg_callback = ass_msg_handler;
+
+    return lib;
+}
+
+void ass_library_done(ass_library_t *priv)
+{
+    if (priv) {
+        ass_set_fonts_dir(priv, NULL);
+        ass_set_style_overrides(priv, NULL);
+        ass_clear_fonts(priv);
+        free(priv);
+    }
+}
+
+void ass_set_fonts_dir(ass_library_t *priv, const char *fonts_dir)
+{
+    if (priv-&gt;fonts_dir)
+        free(priv-&gt;fonts_dir);
+
+    priv-&gt;fonts_dir = fonts_dir ? strdup(fonts_dir) : 0;
+}
+
+void ass_set_extract_fonts(ass_library_t *priv, int extract)
+{
+    priv-&gt;extract_fonts = !!extract;
+}
+
+void ass_set_style_overrides(ass_library_t *priv, char **list)
+{
+    char **p;
+    char **q;
+    int cnt;
+
+    if (priv-&gt;style_overrides) {
+        for (p = priv-&gt;style_overrides; *p; ++p)
+            free(*p);
+        free(priv-&gt;style_overrides);
+    }
+
+    if (!list)
+        return;
+
+    for (p = list, cnt = 0; *p; ++p, ++cnt) {
+    }
+
+    priv-&gt;style_overrides = malloc((cnt + 1) * sizeof(char *));
+    for (p = list, q = priv-&gt;style_overrides; *p; ++p, ++q)
+        *q = strdup(*p);
+    priv-&gt;style_overrides[cnt] = NULL;
+}
+
+static void grow_array(void **array, int nelem, size_t elsize)
+{
+    if (!(nelem &amp; 31))
+        *array = realloc(*array, (nelem + 32) * elsize);
+}
+
+void ass_add_font(ass_library_t *priv, char *name, char *data, int size)
+{
+    int idx = priv-&gt;num_fontdata;
+    if (!name || !data || !size)
+        return;
+    grow_array((void **) &amp;priv-&gt;fontdata, priv-&gt;num_fontdata,
+               sizeof(*priv-&gt;fontdata));
+
+    priv-&gt;fontdata[idx].name = strdup(name);
+
+    priv-&gt;fontdata[idx].data = malloc(size);
+    memcpy(priv-&gt;fontdata[idx].data, data, size);
+
+    priv-&gt;fontdata[idx].size = size;
+
+    priv-&gt;num_fontdata++;
+}
+
+void ass_clear_fonts(ass_library_t *priv)
+{
+    int i;
+    for (i = 0; i &lt; priv-&gt;num_fontdata; ++i) {
+        free(priv-&gt;fontdata[i].name);
+        free(priv-&gt;fontdata[i].data);
+    }
+    free(priv-&gt;fontdata);
+    priv-&gt;fontdata = NULL;
+    priv-&gt;num_fontdata = 0;
+}
+
+/*
+ * Register a message callback function with libass.  Without setting one,
+ * a default handler is used which prints everything with MSGL_INFO or
+ * higher to the standard output.
+ *
+ * \param msg_cb the callback function
+ * \param data additional data that will be passed to the callback
+ */
+void ass_set_message_cb(ass_library_t *priv,
+                        void (*msg_cb)(int, const char *, va_list, void *),
+                        void *data)
+{
+    if (msg_cb) {
+        priv-&gt;msg_callback = msg_cb;
+        priv-&gt;msg_callback_data = data;
+    }
+}

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_library.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_library.h	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_library.h	2009-08-01 07:55:22 UTC (rev 5185)
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+ *
+ * This file is part of libass.
+ *
+ * libass is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libass is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with libass; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef LIBASS_LIBRARY_H
+#define LIBASS_LIBRARY_H
+
+#include &lt;stdarg.h&gt;
+
+typedef struct {
+    char *name;
+    char *data;
+    int size;
+} ass_fontdata_t;
+
+struct ass_library {
+    char *fonts_dir;
+    int extract_fonts;
+    char **style_overrides;
+
+    ass_fontdata_t *fontdata;
+    int num_fontdata;
+    void (*msg_callback)(int, const char *, va_list, void *);
+    void *msg_callback_data;
+};
+
+#endif                          /* LIBASS_LIBRARY_H */

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_render.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_render.c	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_render.c	2009-08-01 07:55:22 UTC (rev 5185)
@@ -0,0 +1,3615 @@
+/*
+ * Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+ *
+ * This file is part of libass.
+ *
+ * libass is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libass is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with libass; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include &quot;config.h&quot;
+
+#include &lt;assert.h&gt;
+#include &lt;math.h&gt;
+#include &lt;inttypes.h&gt;
+#include &lt;ft2build.h&gt;
+#include FT_FREETYPE_H
+#include FT_STROKER_H
+#include FT_GLYPH_H
+#include FT_SYNTHESIS_H
+
+#include &quot;ass.h&quot;
+#include &quot;ass_font.h&quot;
+#include &quot;ass_bitmap.h&quot;
+#include &quot;ass_cache.h&quot;
+#include &quot;ass_utils.h&quot;
+#include &quot;ass_fontconfig.h&quot;
+#include &quot;ass_library.h&quot;
+#include &quot;ass_drawing.h&quot;
+
+#define MAX_GLYPHS_INITIAL 1024
+#define MAX_LINES_INITIAL 64
+#define BLUR_MAX_RADIUS 100.0
+#define MAX_BE 127
+#define SUBPIXEL_MASK 63
+#define SUBPIXEL_ACCURACY 7    // d6 mask for subpixel accuracy adjustment
+#define GLYPH_CACHE_MAX 1000
+#define BITMAP_CACHE_MAX_SIZE 50 * 1048576;
+
+typedef struct {
+    double xMin;
+    double xMax;
+    double yMin;
+    double yMax;
+} double_bbox_t;
+
+typedef struct {
+    double x;
+    double y;
+} double_vector_t;
+
+typedef struct free_list {
+    void *object;
+    struct free_list *next;
+} free_list_t;
+
+typedef struct {
+    int frame_width;
+    int frame_height;
+    double font_size_coeff;     // font size multiplier
+    double line_spacing;        // additional line spacing (in frame pixels)
+    int top_margin;             // height of top margin. Everything except toptitles is shifted down by top_margin.
+    int bottom_margin;          // height of bottom margin. (frame_height - top_margin - bottom_margin) is original video height.
+    int left_margin;
+    int right_margin;
+    int use_margins;            // 0 - place all subtitles inside original frame
+    // 1 - use margins for placing toptitles and subtitles
+    double aspect;              // frame aspect ratio, d_width / d_height.
+    double pixel_ratio;         // pixel ratio of the source image
+    ass_hinting_t hinting;
+
+    char *default_font;
+    char *default_family;
+} ass_settings_t;
+
+// a rendered event
+typedef struct {
+    ass_image_t *imgs;
+    int top, height;
+    int detect_collisions;
+    int shift_direction;
+    ass_event_t *event;
+} event_images_t;
+
+typedef enum { EF_NONE = 0, EF_KARAOKE, EF_KARAOKE_KF, EF_KARAOKE_KO
+} effect_t;
+
+// describes a glyph
+// glyph_info_t and text_info_t are used for text centering and word-wrapping operations
+typedef struct {
+    unsigned symbol;
+    FT_Glyph glyph;
+    FT_Glyph outline_glyph;
+    bitmap_t *bm;               // glyph bitmap
+    bitmap_t *bm_o;             // outline bitmap
+    bitmap_t *bm_s;             // shadow bitmap
+    FT_BBox bbox;
+    FT_Vector pos;
+    char linebreak;             // the first (leading) glyph of some line ?
+    uint32_t c[4];              // colors
+    FT_Vector advance;          // 26.6
+    effect_t effect_type;
+    int effect_timing;          // time duration of current karaoke word
+    // after process_karaoke_effects: distance in pixels from the glyph origin.
+    // part of the glyph to the left of it is displayed in a different color.
+    int effect_skip_timing;     // delay after the end of last karaoke word
+    int asc, desc;              // font max ascender and descender
+//      int height;
+    int be;                     // blur edges
+    double blur;                // gaussian blur
+    double shadow_x;
+    double shadow_y;
+    double frx, fry, frz;       // rotation
+    double fax, fay;            // text shearing
+
+    bitmap_hash_key_t hash_key;
+} glyph_info_t;
+
+typedef struct {
+    double asc, desc;
+} line_info_t;
+
+typedef struct {
+    glyph_info_t *glyphs;
+    int length;
+    line_info_t *lines;
+    int n_lines;
+    double height;
+    int max_glyphs;
+    int max_lines;
+} text_info_t;
+
+
+// Renderer state.
+// Values like current font face, color, screen position, clipping and so on are stored here.
+typedef struct {
+    ass_event_t *event;
+    ass_style_t *style;
+
+    ass_font_t *font;
+    char *font_path;
+    double font_size;
+    int flags;                  // decoration flags (underline/strike-through)
+
+    FT_Stroker stroker;
+    int alignment;              // alignment overrides go here; if zero, style value will be used
+    double frx, fry, frz;
+    double fax, fay;            // text shearing
+    enum { EVENT_NORMAL,        // &quot;normal&quot; top-, sub- or mid- title
+        EVENT_POSITIONED,       // happens after pos(,), margins are ignored
+        EVENT_HSCROLL,          // &quot;Banner&quot; transition effect, text_width is unlimited
+        EVENT_VSCROLL           // &quot;Scroll up&quot;, &quot;Scroll down&quot; transition effects
+    } evt_type;
+    double pos_x, pos_y;        // position
+    double org_x, org_y;        // origin
+    char have_origin;           // origin is explicitly defined; if 0, get_base_point() is used
+    double scale_x, scale_y;
+    double hspacing;            // distance between letters, in pixels
+    double border_x;              // outline width
+    double border_y;
+    uint32_t c[4];              // colors(Primary, Secondary, so on) in RGBA
+    int clip_x0, clip_y0, clip_x1, clip_y1;
+    char clip_mode;             // 1 = iclip
+    char detect_collisions;
+    uint32_t fade;              // alpha from \fad
+    char be;                    // blur edges
+    double blur;                // gaussian blur
+    double shadow_x;
+    double shadow_y;
+    int drawing_mode;           // not implemented; when != 0 text is discarded, except for style override tags
+    ass_drawing_t *drawing;     // current drawing
+    ass_drawing_t *clip_drawing;// clip vector
+    int clip_drawing_mode;      // 0 = regular clip, 1 = inverse clip
+
+    effect_t effect_type;
+    int effect_timing;
+    int effect_skip_timing;
+
+    enum { SCROLL_LR,           // left-to-right
+        SCROLL_RL,
+        SCROLL_TB,              // top-to-bottom
+        SCROLL_BT
+    } scroll_direction;         // for EVENT_HSCROLL, EVENT_VSCROLL
+    int scroll_shift;
+
+    // face properties
+    char *family;
+    unsigned bold;
+    unsigned italic;
+    int treat_family_as_pattern;
+
+} render_context_t;
+
+typedef struct {
+    hashmap_t *font_cache;
+    hashmap_t *glyph_cache;
+    hashmap_t *bitmap_cache;
+    hashmap_t *composite_cache;
+    size_t glyph_max;
+    size_t bitmap_max_size;
+} cache_store_t;
+
+struct ass_renderer {
+    ass_library_t *library;
+    FT_Library ftlibrary;
+    fc_instance_t *fontconfig_priv;
+    ass_settings_t settings;
+    int render_id;
+    ass_synth_priv_t *synth_priv;
+
+    ass_image_t *images_root;   // rendering result is stored here
+    ass_image_t *prev_images_root;
+
+    event_images_t *eimg;       // temporary buffer for sorting rendered events
+    int eimg_size;              // allocated buffer size
+
+    // frame-global data
+    int width, height;          // screen dimensions
+    int orig_height;            // frame height ( = screen height - margins )
+    int orig_width;             // frame width ( = screen width - margins )
+    int orig_height_nocrop;     // frame height ( = screen height - margins + cropheight)
+    int orig_width_nocrop;      // frame width ( = screen width - margins + cropwidth)
+    ass_track_t *track;
+    long long time;             // frame's timestamp, ms
+    double font_scale;
+    double font_scale_x;        // x scale applied to all glyphs to preserve text aspect ratio
+    double border_scale;
+
+    render_context_t state;
+    text_info_t text_info;
+    cache_store_t cache;
+
+    free_list_t *free_head;
+    free_list_t *free_tail;
+};
+
+struct render_priv {
+    int top, height;
+    int render_id;
+};
+
+static void ass_lazy_track_init(ass_renderer_t *render_priv)
+{
+    ass_track_t *track = render_priv-&gt;track;
+
+    if (track-&gt;PlayResX &amp;&amp; track-&gt;PlayResY)
+        return;
+    if (!track-&gt;PlayResX &amp;&amp; !track-&gt;PlayResY) {
+        ass_msg(render_priv-&gt;library, MSGL_WARN,
+               &quot;Neither PlayResX nor PlayResY defined. Assuming 384x288&quot;);
+        track-&gt;PlayResX = 384;
+        track-&gt;PlayResY = 288;
+    } else {
+        if (!track-&gt;PlayResY &amp;&amp; track-&gt;PlayResX == 1280) {
+            track-&gt;PlayResY = 1024;
+            ass_msg(render_priv-&gt;library, MSGL_WARN,
+                   &quot;PlayResY undefined, setting to %d&quot;, track-&gt;PlayResY);
+        } else if (!track-&gt;PlayResY) {
+            track-&gt;PlayResY = track-&gt;PlayResX * 3 / 4;
+            ass_msg(render_priv-&gt;library, MSGL_WARN,
+                   &quot;PlayResY undefined, setting to %d&quot;, track-&gt;PlayResY);
+        } else if (!track-&gt;PlayResX &amp;&amp; track-&gt;PlayResY == 1024) {
+            track-&gt;PlayResX = 1280;
+            ass_msg(render_priv-&gt;library, MSGL_WARN,
+                   &quot;PlayResX undefined, setting to %d&quot;, track-&gt;PlayResX);
+        } else if (!track-&gt;PlayResX) {
+            track-&gt;PlayResX = track-&gt;PlayResY * 4 / 3;
+            ass_msg(render_priv-&gt;library, MSGL_WARN,
+                   &quot;PlayResX undefined, setting to %d&quot;, track-&gt;PlayResX);
+        }
+    }
+}
+
+ass_renderer_t *ass_renderer_init(ass_library_t *library)
+{
+    int error;
+    FT_Library ft;
+    ass_renderer_t *priv = 0;
+    int vmajor, vminor, vpatch;
+
+    error = FT_Init_FreeType(&amp;ft);
+    if (error) {
+        ass_msg(library, MSGL_FATAL, &quot;%s failed&quot;, &quot;FT_Init_FreeType&quot;);
+        goto ass_init_exit;
+    }
+
+    FT_Library_Version(ft, &amp;vmajor, &amp;vminor, &amp;vpatch);
+    ass_msg(library, MSGL_V, &quot;FreeType library version: %d.%d.%d&quot;,
+           vmajor, vminor, vpatch);
+    ass_msg(library, MSGL_V, &quot;FreeType headers version: %d.%d.%d&quot;,
+           FREETYPE_MAJOR, FREETYPE_MINOR, FREETYPE_PATCH);
+
+    priv = calloc(1, sizeof(ass_renderer_t));
+    if (!priv) {
+        FT_Done_FreeType(ft);
+        goto ass_init_exit;
+    }
+
+    priv-&gt;synth_priv = ass_synth_init(BLUR_MAX_RADIUS);
+
+    priv-&gt;library = library;
+    priv-&gt;ftlibrary = ft;
+    // images_root and related stuff is zero-filled in calloc
+
+    priv-&gt;cache.font_cache = ass_font_cache_init(library);
+    priv-&gt;cache.bitmap_cache = ass_bitmap_cache_init(library);
+    priv-&gt;cache.composite_cache = ass_composite_cache_init(library);
+    priv-&gt;cache.glyph_cache = ass_glyph_cache_init(library);
+    priv-&gt;cache.glyph_max = GLYPH_CACHE_MAX;
+    priv-&gt;cache.bitmap_max_size = BITMAP_CACHE_MAX_SIZE;
+
+    priv-&gt;text_info.max_glyphs = MAX_GLYPHS_INITIAL;
+    priv-&gt;text_info.max_lines = MAX_LINES_INITIAL;
+    priv-&gt;text_info.glyphs =
+        calloc(MAX_GLYPHS_INITIAL, sizeof(glyph_info_t));
+    priv-&gt;text_info.lines = calloc(MAX_LINES_INITIAL, sizeof(line_info_t));
+
+  ass_init_exit:
+    if (priv)
+        ass_msg(library, MSGL_INFO, &quot;Init&quot;);
+    else
+        ass_msg(library, MSGL_ERR, &quot;Init failed&quot;);
+
+    return priv;
+}
+
+void ass_set_cache_limits(ass_renderer_t *render_priv, int glyph_max,
+                          int bitmap_max)
+{
+    render_priv-&gt;cache.glyph_max = glyph_max ? glyph_max : GLYPH_CACHE_MAX;
+    render_priv-&gt;cache.bitmap_max_size = bitmap_max ? 1048576 * bitmap_max :
+                                         BITMAP_CACHE_MAX_SIZE;
+}
+
+static void free_list_clear(ass_renderer_t *render_priv)
+{
+    if (render_priv-&gt;free_head) {
+        free_list_t *item = render_priv-&gt;free_head;
+        while(item) {
+            free_list_t *oi = item;
+            free(item-&gt;object);
+            item = item-&gt;next;
+            free(oi);
+        }
+        render_priv-&gt;free_head = NULL;
+    }
+}
+
+static void ass_free_images(ass_image_t *img);
+
+void ass_renderer_done(ass_renderer_t *render_priv)
+{
+    ass_font_cache_done(render_priv-&gt;cache.font_cache);
+    ass_bitmap_cache_done(render_priv-&gt;cache.bitmap_cache);
+    ass_composite_cache_done(render_priv-&gt;cache.composite_cache);
+    ass_glyph_cache_done(render_priv-&gt;cache.glyph_cache);
+
+    ass_free_images(render_priv-&gt;images_root);
+    ass_free_images(render_priv-&gt;prev_images_root);
+
+    if (render_priv-&gt;state.stroker) {
+        FT_Stroker_Done(render_priv-&gt;state.stroker);
+        render_priv-&gt;state.stroker = 0;
+    }
+    if (render_priv &amp;&amp; render_priv-&gt;ftlibrary)
+        FT_Done_FreeType(render_priv-&gt;ftlibrary);
+    if (render_priv &amp;&amp; render_priv-&gt;fontconfig_priv)
+        fontconfig_done(render_priv-&gt;fontconfig_priv);
+    if (render_priv &amp;&amp; render_priv-&gt;synth_priv)
+        ass_synth_done(render_priv-&gt;synth_priv);
+    if (render_priv &amp;&amp; render_priv-&gt;eimg)
+        free(render_priv-&gt;eimg);
+    free(render_priv-&gt;text_info.glyphs);
+    free(render_priv-&gt;text_info.lines);
+
+    free(render_priv-&gt;settings.default_font);
+    free(render_priv-&gt;settings.default_family);
+
+    free_list_clear(render_priv);
+    free(render_priv);
+}
+
+/**
+ * \brief Create a new ass_image_t
+ * Parameters are the same as ass_image_t fields.
+ */
+static ass_image_t *my_draw_bitmap(unsigned char *bitmap, int bitmap_w,
+                                   int bitmap_h, int stride, int dst_x,
+                                   int dst_y, uint32_t color)
+{
+    ass_image_t *img = calloc(1, sizeof(ass_image_t));
+
+    img-&gt;w = bitmap_w;
+    img-&gt;h = bitmap_h;
+    img-&gt;stride = stride;
+    img-&gt;bitmap = bitmap;
+    img-&gt;color = color;
+    img-&gt;dst_x = dst_x;
+    img-&gt;dst_y = dst_y;
+
+    return img;
+}
+
+static double x2scr_pos(ass_renderer_t *render_priv, double x);
+static double y2scr_pos(ass_renderer_t *render_priv, double y);
+
+typedef struct {
+    int x0;
+    int y0;
+    int x1;
+    int y1;
+} rect_t;
+
+/*
+ * \brief Convert bitmap glyphs into ass_image_t list with inverse clipping
+ *
+ * Inverse clipping with the following strategy:
+ * - find rectangle from (x0, y0) to (cx0, y1)
+ * - find rectangle from (cx0, y0) to (cx1, cy0)
+ * - find rectangle from (cx0, cy1) to (cx1, y1)
+ * - find rectangle from (cx1, y0) to (x1, y1)
+ * These rectangles can be invalid and in this case are discarded.
+ * Afterwards, they are clipped against the screen coordinates.
+ * In an additional pass, the rectangles need to be split up left/right for
+ * karaoke effects.  This can result in a lot of bitmaps (6 to be exact).
+ */
+static ass_image_t **render_glyph_i(ass_renderer_t *render_priv,
+                                    bitmap_t *bm, int dst_x, int dst_y,
+                                    uint32_t color, uint32_t color2, int brk,
+                                    ass_image_t **tail)
+{
+    int i, j, x0, y0, x1, y1, cx0, cy0, cx1, cy1, sx, sy, zx, zy;
+    rect_t r[4];
+    ass_image_t *img;
+
+    dst_x += bm-&gt;left;
+    dst_y += bm-&gt;top;
+
+    // we still need to clip against screen boundaries
+    zx = x2scr_pos(render_priv, 0);
+    zy = y2scr_pos(render_priv, 0);
+    sx = x2scr_pos(render_priv, render_priv-&gt;track-&gt;PlayResX);
+    sy = y2scr_pos(render_priv, render_priv-&gt;track-&gt;PlayResY);
+
+    x0 = 0;
+    y0 = 0;
+    x1 = bm-&gt;w;
+    y1 = bm-&gt;h;
+    cx0 = render_priv-&gt;state.clip_x0 - dst_x;
+    cy0 = render_priv-&gt;state.clip_y0 - dst_y;
+    cx1 = render_priv-&gt;state.clip_x1 - dst_x;
+    cy1 = render_priv-&gt;state.clip_y1 - dst_y;
+
+    // calculate rectangles and discard invalid ones while we're at it.
+    i = 0;
+    r[i].x0 = x0;
+    r[i].y0 = y0;
+    r[i].x1 = (cx0 &gt; x1) ? x1 : cx0;
+    r[i].y1 = y1;
+    if (r[i].x1 &gt; r[i].x0 &amp;&amp; r[i].y1 &gt; r[i].y0) i++;
+    r[i].x0 = (cx0 &lt; 0) ? x0 : cx0;
+    r[i].y0 = y0;
+    r[i].x1 = (cx1 &gt; x1) ? x1 : cx1;
+    r[i].y1 = (cy0 &gt; y1) ? y1 : cy0;
+    if (r[i].x1 &gt; r[i].x0 &amp;&amp; r[i].y1 &gt; r[i].y0) i++;
+    r[i].x0 = (cx0 &lt; 0) ? x0 : cx0;
+    r[i].y0 = (cy1 &lt; 0) ? y0 : cy1;
+    r[i].x1 = (cx1 &gt; x1) ? x1 : cx1;
+    r[i].y1 = y1;
+    if (r[i].x1 &gt; r[i].x0 &amp;&amp; r[i].y1 &gt; r[i].y0) i++;
+    r[i].x0 = (cx1 &lt; 0) ? x0 : cx1;
+    r[i].y0 = y0;
+    r[i].x1 = x1;
+    r[i].y1 = y1;
+    if (r[i].x1 &gt; r[i].x0 &amp;&amp; r[i].y1 &gt; r[i].y0) i++;
+
+    // clip each rectangle to screen coordinates
+    for (j = 0; j &lt; i; j++) {
+        r[j].x0 = (r[j].x0 + dst_x &lt; zx) ? zx - dst_x : r[j].x0;
+        r[j].y0 = (r[j].y0 + dst_y &lt; zy) ? zy - dst_y : r[j].y0;
+        r[j].x1 = (r[j].x1 + dst_x &gt; sx) ? sx - dst_x : r[j].x1;
+        r[j].y1 = (r[j].y1 + dst_y &gt; sy) ? sy - dst_y : r[j].y1;
+    }
+
+    // draw the rectangles
+    for (j = 0; j &lt; i; j++) {
+        int lbrk = brk;
+        // kick out rectangles that are invalid now
+        if (r[j].x1 &lt;= r[j].x0 || r[j].y1 &lt;= r[j].y0)
+            continue;
+        // split up into left and right for karaoke, if needed
+        if (lbrk &gt; r[j].x0) {
+            if (lbrk &gt; r[j].x1) lbrk = r[j].x1;
+            img = my_draw_bitmap(bm-&gt;buffer + r[j].y0 * bm-&gt;w + r[j].x0,
+                lbrk - r[j].x0, r[j].y1 - r[j].y0,
+                bm-&gt;w, dst_x + r[j].x0, dst_y + r[j].y0, color);
+            *tail = img;
+            tail = &amp;img-&gt;next;
+        }
+        if (lbrk &lt; r[j].x1) {
+            if (lbrk &lt; r[j].x0) lbrk = r[j].x0;
+            img = my_draw_bitmap(bm-&gt;buffer + r[j].y0 * bm-&gt;w + lbrk,
+                r[j].x1 - lbrk, r[j].y1 - r[j].y0,
+                bm-&gt;w, dst_x + lbrk, dst_y + r[j].y0, color2);
+            *tail = img;
+            tail = &amp;img-&gt;next;
+        }
+    }
+
+    return tail;
+}
+
+/**
+ * \brief convert bitmap glyph into ass_image_t struct(s)
+ * \param bit freetype bitmap glyph, FT_PIXEL_MODE_GRAY
+ * \param dst_x bitmap x coordinate in video frame
+ * \param dst_y bitmap y coordinate in video frame
+ * \param color first color, RGBA
+ * \param color2 second color, RGBA
+ * \param brk x coordinate relative to glyph origin, color is used to the left of brk, color2 - to the right
+ * \param tail pointer to the last image's next field, head of the generated list should be stored here
+ * \return pointer to the new list tail
+ * Performs clipping. Uses my_draw_bitmap for actual bitmap convertion.
+ */
+static ass_image_t **render_glyph(ass_renderer_t *render_priv,
+                                  bitmap_t *bm, int dst_x, int dst_y,
+                                  uint32_t color, uint32_t color2, int brk,
+                                  ass_image_t **tail)
+{
+    // Inverse clipping in use?
+    if (render_priv-&gt;state.clip_mode)
+        return render_glyph_i(render_priv, bm, dst_x, dst_y, color, color2,
+                              brk, tail);
+
+    // brk is relative to dst_x
+    // color = color left of brk
+    // color2 = color right of brk
+    int b_x0, b_y0, b_x1, b_y1; // visible part of the bitmap
+    int clip_x0, clip_y0, clip_x1, clip_y1;
+    int tmp;
+    ass_image_t *img;
+
+    dst_x += bm-&gt;left;
+    dst_y += bm-&gt;top;
+    brk -= bm-&gt;left;
+
+    // clipping
+    clip_x0 = FFMINMAX(render_priv-&gt;state.clip_x0, 0, render_priv-&gt;width);
+    clip_y0 = FFMINMAX(render_priv-&gt;state.clip_y0, 0, render_priv-&gt;height);
+    clip_x1 = FFMINMAX(render_priv-&gt;state.clip_x1, 0, render_priv-&gt;width);
+    clip_y1 = FFMINMAX(render_priv-&gt;state.clip_y1, 0, render_priv-&gt;height);
+    b_x0 = 0;
+    b_y0 = 0;
+    b_x1 = bm-&gt;w;
+    b_y1 = bm-&gt;h;
+
+    tmp = dst_x - clip_x0;
+    if (tmp &lt; 0) {
+        ass_msg(render_priv-&gt;library, MSGL_DBG2, &quot;clip left&quot;);
+        b_x0 = -tmp;
+    }
+    tmp = dst_y - clip_y0;
+    if (tmp &lt; 0) {
+        ass_msg(render_priv-&gt;library, MSGL_DBG2, &quot;clip top&quot;);
+        b_y0 = -tmp;
+    }
+    tmp = clip_x1 - dst_x - bm-&gt;w;
+    if (tmp &lt; 0) {
+        ass_msg(render_priv-&gt;library, MSGL_DBG2, &quot;clip right&quot;);
+        b_x1 = bm-&gt;w + tmp;
+    }
+    tmp = clip_y1 - dst_y - bm-&gt;h;
+    if (tmp &lt; 0) {
+        ass_msg(render_priv-&gt;library, MSGL_DBG2, &quot;clip bottom&quot;);
+        b_y1 = bm-&gt;h + tmp;
+    }
+
+    if ((b_y0 &gt;= b_y1) || (b_x0 &gt;= b_x1))
+        return tail;
+
+    if (brk &gt; b_x0) {           // draw left part
+        if (brk &gt; b_x1)
+            brk = b_x1;
+        img = my_draw_bitmap(bm-&gt;buffer + bm-&gt;w * b_y0 + b_x0,
+                             brk - b_x0, b_y1 - b_y0, bm-&gt;w,
+                             dst_x + b_x0, dst_y + b_y0, color);
+        *tail = img;
+        tail = &amp;img-&gt;next;
+    }
+    if (brk &lt; b_x1) {           // draw right part
+        if (brk &lt; b_x0)
+            brk = b_x0;
+        img = my_draw_bitmap(bm-&gt;buffer + bm-&gt;w * b_y0 + brk,
+                             b_x1 - brk, b_y1 - b_y0, bm-&gt;w,
+                             dst_x + brk, dst_y + b_y0, color2);
+        *tail = img;
+        tail = &amp;img-&gt;next;
+    }
+    return tail;
+}
+
+/**
+ * \brief Replace the bitmap buffer in ass_image_t with a copy
+ * \param img ass_image_t to operate on
+ * \return pointer to old bitmap buffer
+ */
+static unsigned char *clone_bitmap_buffer(ass_image_t *img)
+{
+    unsigned char *old_bitmap = img-&gt;bitmap;
+    int size = img-&gt;stride * (img-&gt;h - 1) + img-&gt;w;
+    img-&gt;bitmap = malloc(size);
+    memcpy(img-&gt;bitmap, old_bitmap, size);
+    return old_bitmap;
+}
+
+/**
+ * \brief Calculate overlapping area of two consecutive bitmaps and in case they
+ * overlap, composite them together
+ * Mainly useful for translucent glyphs and especially borders, to avoid the
+ * luminance adding up where they overlap (which looks ugly)
+ */
+static void
+render_overlap(ass_renderer_t *render_priv, ass_image_t **last_tail,
+               ass_image_t **tail, bitmap_hash_key_t *last_hash,
+               bitmap_hash_key_t *hash)
+{
+    int left, top, bottom, right;
+    int old_left, old_top, w, h, cur_left, cur_top;
+    int x, y, opos, cpos;
+    char m;
+    composite_hash_key_t hk;
+    composite_hash_val_t *hv;
+    composite_hash_val_t chv;
+    int ax = (*last_tail)-&gt;dst_x;
+    int ay = (*last_tail)-&gt;dst_y;
+    int aw = (*last_tail)-&gt;w;
+    int as = (*last_tail)-&gt;stride;
+    int ah = (*last_tail)-&gt;h;
+    int bx = (*tail)-&gt;dst_x;
+    int by = (*tail)-&gt;dst_y;
+    int bw = (*tail)-&gt;w;
+    int bs = (*tail)-&gt;stride;
+    int bh = (*tail)-&gt;h;
+    unsigned char *a;
+    unsigned char *b;
+
+    if ((*last_tail)-&gt;bitmap == (*tail)-&gt;bitmap)
+        return;
+
+    if ((*last_tail)-&gt;color != (*tail)-&gt;color)
+        return;
+
+    // Calculate overlap coordinates
+    left = (ax &gt; bx) ? ax : bx;
+    top = (ay &gt; by) ? ay : by;
+    right = ((ax + aw) &lt; (bx + bw)) ? (ax + aw) : (bx + bw);
+    bottom = ((ay + ah) &lt; (by + bh)) ? (ay + ah) : (by + bh);
+    if ((right &lt;= left) || (bottom &lt;= top))
+        return;
+    old_left = left - ax;
+    old_top = top - ay;
+    w = right - left;
+    h = bottom - top;
+    cur_left = left - bx;
+    cur_top = top - by;
+
+    // Query cache
+    memset(&amp;hk, 0, sizeof(hk));
+    memcpy(&amp;hk.a, last_hash, sizeof(*last_hash));
+    memcpy(&amp;hk.b, hash, sizeof(*hash));
+    hk.aw = aw;
+    hk.ah = ah;
+    hk.bw = bw;
+    hk.bh = bh;
+    hk.ax = ax;
+    hk.ay = ay;
+    hk.bx = bx;
+    hk.by = by;
+    hv = cache_find_composite(render_priv-&gt;cache.composite_cache, &amp;hk);
+    if (hv) {
+        (*last_tail)-&gt;bitmap = hv-&gt;a;
+        (*tail)-&gt;bitmap = hv-&gt;b;
+        return;
+    }
+    // Allocate new bitmaps and copy over data
+    a = clone_bitmap_buffer(*last_tail);
+    b = clone_bitmap_buffer(*tail);
+
+    // Composite overlapping area
+    for (y = 0; y &lt; h; y++)
+        for (x = 0; x &lt; w; x++) {
+            opos = (old_top + y) * (as) + (old_left + x);
+            cpos = (cur_top + y) * (bs) + (cur_left + x);
+            m = (a[opos] &gt; b[cpos]) ? a[opos] : b[cpos];
+            (*last_tail)-&gt;bitmap[opos] = 0;
+            (*tail)-&gt;bitmap[cpos] = m;
+        }
+
+    // Insert bitmaps into the cache
+    chv.a = (*last_tail)-&gt;bitmap;
+    chv.b = (*tail)-&gt;bitmap;
+    cache_add_composite(render_priv-&gt;cache.composite_cache, &amp;hk, &amp;chv);
+}
+
+static void free_list_add(ass_renderer_t *render_priv, void *object)
+{
+    if (!render_priv-&gt;free_head) {
+        render_priv-&gt;free_head = calloc(1, sizeof(free_list_t));
+        render_priv-&gt;free_head-&gt;object = object;
+        render_priv-&gt;free_tail = render_priv-&gt;free_head;
+    } else {
+        free_list_t *l = calloc(1, sizeof(free_list_t));
+        l-&gt;object = object;
+        render_priv-&gt;free_tail-&gt;next = l;
+        render_priv-&gt;free_tail = render_priv-&gt;free_tail-&gt;next;
+    }
+}
+
+/**
+ * Iterate through a list of bitmaps and blend with clip vector, if
+ * applicable. The blended bitmaps are added to a free list which is freed
+ * at the start of a new frame.
+ */
+static void blend_vector_clip(ass_renderer_t *render_priv,
+                              ass_image_t *head)
+{
+    FT_Glyph glyph;
+    FT_BitmapGlyph clip_bm;
+    ass_image_t *cur;
+    ass_drawing_t *drawing = render_priv-&gt;state.clip_drawing;
+    int error;
+
+    if (!drawing)
+        return;
+
+    // Rasterize it
+    FT_Glyph_Copy((FT_Glyph) drawing-&gt;glyph, &amp;glyph);
+    error = FT_Glyph_To_Bitmap(&amp;glyph, FT_RENDER_MODE_NORMAL, 0, 1);
+    if (error) {
+        ass_msg(render_priv-&gt;library, MSGL_V,
+            &quot;Clip vector rasterization failed: %d. Skipping.&quot;, error);
+        goto blend_vector_exit;
+    }
+    clip_bm = (FT_BitmapGlyph) glyph;
+    clip_bm-&gt;top = -clip_bm-&gt;top;
+
+    assert(clip_bm-&gt;bitmap.pitch &gt;= 0);
+
+    // Iterate through bitmaps and blend/clip them
+    for (cur = head; cur; cur = cur-&gt;next) {
+        int left, top, right, bottom, apos, bpos, y, x, w, h;
+        int ax, ay, aw, ah, as;
+        int bx, by, bw, bh, bs;
+        int aleft, atop, bleft, btop;
+        unsigned char *abuffer, *bbuffer, *nbuffer;
+
+        abuffer = cur-&gt;bitmap;
+        bbuffer = clip_bm-&gt;bitmap.buffer;
+        ax = cur-&gt;dst_x;
+        ay = cur-&gt;dst_y;
+        aw = cur-&gt;w;
+        ah = cur-&gt;h;
+        as = cur-&gt;stride;
+        bx = clip_bm-&gt;left;
+        by = clip_bm-&gt;top;
+        bw = clip_bm-&gt;bitmap.width;
+        bh = clip_bm-&gt;bitmap.rows;
+        bs = clip_bm-&gt;bitmap.pitch;
+
+        // Calculate overlap coordinates
+        left = (ax &gt; bx) ? ax : bx;
+        top = (ay &gt; by) ? ay : by;
+        right = ((ax + aw) &lt; (bx + bw)) ? (ax + aw) : (bx + bw);
+        bottom = ((ay + ah) &lt; (by + bh)) ? (ay + ah) : (by + bh);
+        aleft = left - ax;
+        atop = top - ay;
+        w = right - left;
+        h = bottom - top;
+        bleft = left - bx;
+        btop = top - by;
+
+        if (render_priv-&gt;state.clip_drawing_mode) {
+            // Inverse clip
+            if (ax + aw &lt; bx || ay + ah &lt; by || ax &gt; bx + bw ||
+                ay &gt; by + bh) {
+                continue;
+            }
+
+            // Allocate new buffer and add to free list
+            nbuffer = malloc(as * ah);
+            free_list_add(render_priv, nbuffer);
+
+            // Blend together
+            memcpy(nbuffer, abuffer, as * ah);
+            for (y = 0; y &lt; h; y++)
+                for (x = 0; x &lt; w; x++) {
+                    apos = (atop + y) * as + aleft + x;
+                    bpos = (btop + y) * bs + bleft + x;
+                    nbuffer[apos] = FFMAX(0, abuffer[apos] - bbuffer[bpos]);
+                }
+        } else {
+            // Regular clip
+            if (ax + aw &lt; bx || ay + ah &lt; by || ax &gt; bx + bw ||
+                ay &gt; by + bh) {
+                cur-&gt;w = cur-&gt;h = 0;
+                continue;
+            }
+
+            // Allocate new buffer and add to free list
+            nbuffer = calloc(as, ah);
+            free_list_add(render_priv, nbuffer);
+
+            // Blend together
+            for (y = 0; y &lt; h; y++)
+                for (x = 0; x &lt; w; x++) {
+                    apos = (atop + y) * as + aleft + x;
+                    bpos = (btop + y) * bs + bleft + x;
+                    nbuffer[apos] = (abuffer[apos] * bbuffer[bpos] + 255) &gt;&gt; 8;
+                }
+        }
+        cur-&gt;bitmap = nbuffer;
+    }
+
+    // Free clip vector and its bitmap, we don't need it anymore
+    FT_Done_Glyph(glyph);
+blend_vector_exit:
+    ass_drawing_free(render_priv-&gt;state.clip_drawing);
+    render_priv-&gt;state.clip_drawing = 0;
+}
+
+/**
+ * \brief Convert text_info_t struct to ass_image_t list
+ * Splits glyphs in halves when needed (for \kf karaoke).
+ */
+static ass_image_t *render_text(ass_renderer_t *render_priv, int dst_x,
+                                int dst_y)
+{
+    int pen_x, pen_y;
+    int i;
+    bitmap_t *bm;
+    ass_image_t *head;
+    ass_image_t **tail = &head;
+    ass_image_t **last_tail = 0;
+    ass_image_t **here_tail = 0;
+    bitmap_hash_key_t *last_hash = 0;
+    text_info_t *text_info = &amp;render_priv-&gt;text_info;
+
+    for (i = 0; i &lt; text_info-&gt;length; ++i) {
+        glyph_info_t *info = text_info-&gt;glyphs + i;
+        if ((info-&gt;symbol == 0) || (info-&gt;symbol == '\n') || !info-&gt;bm_s
+            || (info-&gt;shadow_x == 0 &amp;&amp; info-&gt;shadow_y == 0))
+            continue;
+
+        pen_x =
+            dst_x + (info-&gt;pos.x &gt;&gt; 6) +
+            (int) (info-&gt;shadow_x * render_priv-&gt;border_scale);
+        pen_y =
+            dst_y + (info-&gt;pos.y &gt;&gt; 6) +
+            (int) (info-&gt;shadow_y * render_priv-&gt;border_scale);
+        bm = info-&gt;bm_s;
+
+        here_tail = tail;
+        tail =
+            render_glyph(render_priv, bm, pen_x, pen_y, info-&gt;c[3], 0,
+                         1000000, tail);
+        if (last_tail &amp;&amp; tail != here_tail &amp;&amp; ((info-&gt;c[3] &amp; 0xff) &gt; 0))
+            render_overlap(render_priv, last_tail, here_tail, last_hash,
+                           &amp;info-&gt;hash_key);
+        last_tail = here_tail;
+        last_hash = &amp;info-&gt;hash_key;
+    }
+
+    last_tail = 0;
+    for (i = 0; i &lt; text_info-&gt;length; ++i) {
+        glyph_info_t *info = text_info-&gt;glyphs + i;
+        if ((info-&gt;symbol == 0) || (info-&gt;symbol == '\n') || !info-&gt;bm_o)
+            continue;
+
+        pen_x = dst_x + (info-&gt;pos.x &gt;&gt; 6);
+        pen_y = dst_y + (info-&gt;pos.y &gt;&gt; 6);
+        bm = info-&gt;bm_o;
+
+        if ((info-&gt;effect_type == EF_KARAOKE_KO)
+            &amp;&amp; (info-&gt;effect_timing &lt;= (info-&gt;bbox.xMax &gt;&gt; 6))) {
+            // do nothing
+        } else {
+            here_tail = tail;
+            tail =
+                render_glyph(render_priv, bm, pen_x, pen_y, info-&gt;c[2],
+                             0, 1000000, tail);
+            if (last_tail &amp;&amp; tail != here_tail &amp;&amp; ((info-&gt;c[2] &amp; 0xff) &gt; 0))
+                render_overlap(render_priv, last_tail, here_tail,
+                               last_hash, &amp;info-&gt;hash_key);
+            last_tail = here_tail;
+            last_hash = &amp;info-&gt;hash_key;
+        }
+    }
+    for (i = 0; i &lt; text_info-&gt;length; ++i) {
+        glyph_info_t *info = text_info-&gt;glyphs + i;
+        if ((info-&gt;symbol == 0) || (info-&gt;symbol == '\n') || !info-&gt;bm)
+            continue;
+
+        pen_x = dst_x + (info-&gt;pos.x &gt;&gt; 6);
+        pen_y = dst_y + (info-&gt;pos.y &gt;&gt; 6);
+        bm = info-&gt;bm;
+
+        if ((info-&gt;effect_type == EF_KARAOKE)
+            || (info-&gt;effect_type == EF_KARAOKE_KO)) {
+            if (info-&gt;effect_timing &gt; (info-&gt;bbox.xMax &gt;&gt; 6))
+                tail =
+                    render_glyph(render_priv, bm, pen_x, pen_y,
+                                 info-&gt;c[0], 0, 1000000, tail);
+            else
+                tail =
+                    render_glyph(render_priv, bm, pen_x, pen_y,
+                                 info-&gt;c[1], 0, 1000000, tail);
+        } else if (info-&gt;effect_type == EF_KARAOKE_KF) {
+            tail =
+                render_glyph(render_priv, bm, pen_x, pen_y, info-&gt;c[0],
+                             info-&gt;c[1], info-&gt;effect_timing, tail);
+        } else
+            tail =
+                render_glyph(render_priv, bm, pen_x, pen_y, info-&gt;c[0],
+                             0, 1000000, tail);
+    }
+
+    *tail = 0;
+    blend_vector_clip(render_priv, head);
+
+    return head;
+}
+
+/**
+ * \brief Mapping between script and screen coordinates
+ */
+static double x2scr(ass_renderer_t *render_priv, double x)
+{
+    return x * render_priv-&gt;orig_width_nocrop /
+        render_priv-&gt;track-&gt;PlayResX +
+        FFMAX(render_priv-&gt;settings.left_margin, 0);
+}
+static double x2scr_pos(ass_renderer_t *render_priv, double x)
+{
+    return x * render_priv-&gt;orig_width / render_priv-&gt;track-&gt;PlayResX +
+        render_priv-&gt;settings.left_margin;
+}
+
+/**
+ * \brief Mapping between script and screen coordinates
+ */
+static double y2scr(ass_renderer_t *render_priv, double y)
+{
+    return y * render_priv-&gt;orig_height_nocrop /
+        render_priv-&gt;track-&gt;PlayResY +
+        FFMAX(render_priv-&gt;settings.top_margin, 0);
+}
+static double y2scr_pos(ass_renderer_t *render_priv, double y)
+{
+    return y * render_priv-&gt;orig_height / render_priv-&gt;track-&gt;PlayResY +
+        render_priv-&gt;settings.top_margin;
+}
+
+// the same for toptitles
+static double y2scr_top(ass_renderer_t *render_priv, double y)
+{
+    if (render_priv-&gt;settings.use_margins)
+        return y * render_priv-&gt;orig_height_nocrop /
+            render_priv-&gt;track-&gt;PlayResY;
+    else
+        return y * render_priv-&gt;orig_height_nocrop /
+            render_priv-&gt;track-&gt;PlayResY +
+            FFMAX(render_priv-&gt;settings.top_margin, 0);
+}
+
+// the same for subtitles
+static double y2scr_sub(ass_renderer_t *render_priv, double y)
+{
+    if (render_priv-&gt;settings.use_margins)
+        return y * render_priv-&gt;orig_height_nocrop /
+            render_priv-&gt;track-&gt;PlayResY +
+            FFMAX(render_priv-&gt;settings.top_margin,
+                  0) + FFMAX(render_priv-&gt;settings.bottom_margin, 0);
+    else
+        return y * render_priv-&gt;orig_height_nocrop /
+            render_priv-&gt;track-&gt;PlayResY +
+            FFMAX(render_priv-&gt;settings.top_margin, 0);
+}
+
+static void compute_string_bbox(text_info_t *info, double_bbox_t *bbox)
+{
+    int i;
+
+    if (info-&gt;length &gt; 0) {
+        bbox-&gt;xMin = 32000;
+        bbox-&gt;xMax = -32000;
+        bbox-&gt;yMin = -1 * info-&gt;lines[0].asc + d6_to_double(info-&gt;glyphs[0].pos.y);
+        bbox-&gt;yMax = info-&gt;height - info-&gt;lines[0].asc +
+                     d6_to_double(info-&gt;glyphs[0].pos.y);
+
+        for (i = 0; i &lt; info-&gt;length; ++i) {
+            double s = d6_to_double(info-&gt;glyphs[i].pos.x);
+            double e = s + d6_to_double(info-&gt;glyphs[i].advance.x);
+            bbox-&gt;xMin = FFMIN(bbox-&gt;xMin, s);
+            bbox-&gt;xMax = FFMAX(bbox-&gt;xMax, e);
+        }
+    } else
+        bbox-&gt;xMin = bbox-&gt;xMax = bbox-&gt;yMin = bbox-&gt;yMax = 0.;
+}
+
+
+/**
+ * \brief Check if starting part of (*p) matches sample. If true, shift p to the first symbol after the matching part.
+ */
+static inline int mystrcmp(char **p, const char *sample)
+{
+    int len = strlen(sample);
+    if (strncmp(*p, sample, len) == 0) {
+        (*p) += len;
+        return 1;
+    } else
+        return 0;
+}
+
+static void change_font_size(ass_renderer_t *render_priv, double sz)
+{
+    double size = sz * render_priv-&gt;font_scale;
+
+    if (size &lt; 1)
+        size = 1;
+    else if (size &gt; render_priv-&gt;height * 2)
+        size = render_priv-&gt;height * 2;
+
+    ass_font_set_size(render_priv-&gt;state.font, size);
+
+    render_priv-&gt;state.font_size = sz;
+}
+
+/**
+ * \brief Change current font, using setting from render_priv-&gt;state.
+ */
+static void update_font(ass_renderer_t *render_priv)
+{
+    unsigned val;
+    ass_font_desc_t desc;
+    desc.family = strdup(render_priv-&gt;state.family);
+    desc.treat_family_as_pattern =
+        render_priv-&gt;state.treat_family_as_pattern;
+
+    val = render_priv-&gt;state.bold;
+    // 0 = normal, 1 = bold, &gt;1 = exact weight
+    if (val == 1 || val == -1)
+        val = 200;              // bold
+    else if (val &lt;= 0)
+        val = 80;               // normal
+    desc.bold = val;
+
+    val = render_priv-&gt;state.italic;
+    if (val == 1 || val == -1)
+        val = 110;              // italic
+    else if (val &lt;= 0)
+        val = 0;                // normal
+    desc.italic = val;
+
+    render_priv-&gt;state.font =
+        ass_font_new(render_priv-&gt;cache.font_cache, render_priv-&gt;library,
+                     render_priv-&gt;ftlibrary, render_priv-&gt;fontconfig_priv,
+                     &amp;desc);
+    free(desc.family);
+
+    if (render_priv-&gt;state.font)
+        change_font_size(render_priv, render_priv-&gt;state.font_size);
+}
+
+/**
+ * \brief Change border width
+ * negative value resets border to style value
+ */
+static void change_border(ass_renderer_t *render_priv, double border_x,
+                          double border_y)
+{
+    int bord;
+    if (!render_priv-&gt;state.font)
+        return;
+
+    if (border_x &lt; 0 &amp;&amp; border_y &lt; 0) {
+        if (render_priv-&gt;state.style-&gt;BorderStyle == 1)
+            border_x = border_y = render_priv-&gt;state.style-&gt;Outline;
+        else
+            border_x = border_y = 1.;
+    }
+
+    render_priv-&gt;state.border_x = border_x;
+    render_priv-&gt;state.border_y = border_y;
+
+    bord = 64 * border_x * render_priv-&gt;border_scale;
+    if (bord &gt; 0 &amp;&amp; border_x == border_y) {
+        if (!render_priv-&gt;state.stroker) {
+            int error;
+#if (FREETYPE_MAJOR &gt; 2) || ((FREETYPE_MAJOR == 2) &amp;&amp; (FREETYPE_MINOR &gt; 1))
+            error =
+                FT_Stroker_New(render_priv-&gt;ftlibrary,
+                               &amp;render_priv-&gt;state.stroker);
+#else                           // &lt; 2.2
+            error =
+                FT_Stroker_New(render_priv-&gt;state.font-&gt;faces[0]-&gt;
+                               memory, &amp;render_priv-&gt;state.stroker);
+#endif
+            if (error) {
+                ass_msg(render_priv-&gt;library, MSGL_V,
+                        &quot;failed to get stroker&quot;);
+                render_priv-&gt;state.stroker = 0;
+            }
+        }
+        if (render_priv-&gt;state.stroker)
+            FT_Stroker_Set(render_priv-&gt;state.stroker, bord,
+                           FT_STROKER_LINECAP_ROUND,
+                           FT_STROKER_LINEJOIN_ROUND, 0);
+    } else {
+        FT_Stroker_Done(render_priv-&gt;state.stroker);
+        render_priv-&gt;state.stroker = 0;
+    }
+}
+
+#define _r(c)  ((c)&gt;&gt;24)
+#define _g(c)  (((c)&gt;&gt;16)&amp;0xFF)
+#define _b(c)  (((c)&gt;&gt;8)&amp;0xFF)
+#define _a(c)  ((c)&amp;0xFF)
+
+/**
+ * \brief Calculate a weighted average of two colors
+ * calculates c1*(1-a) + c2*a, but separately for each component except alpha
+ */
+static void change_color(uint32_t *var, uint32_t new, double pwr)
+{
+    (*var) = ((uint32_t) (_r(*var) * (1 - pwr) + _r(new) * pwr) &lt;&lt; 24) +
+        ((uint32_t) (_g(*var) * (1 - pwr) + _g(new) * pwr) &lt;&lt; 16) +
+        ((uint32_t) (_b(*var) * (1 - pwr) + _b(new) * pwr) &lt;&lt; 8) + _a(*var);
+}
+
+// like change_color, but for alpha component only
+static void change_alpha(uint32_t *var, uint32_t new, double pwr)
+{
+    *var =
+        (_r(*var) &lt;&lt; 24) + (_g(*var) &lt;&lt; 16) + (_b(*var) &lt;&lt; 8) +
+        (_a(*var) * (1 - pwr) + _a(new) * pwr);
+}
+
+/**
+ * \brief Multiply two alpha values
+ * \param a first value
+ * \param b second value
+ * \return result of multiplication
+ * Parameters and result are limited by 0xFF.
+ */
+static uint32_t mult_alpha(uint32_t a, uint32_t b)
+{
+    return 0xFF - (0xFF - a) * (0xFF - b) / 0xFF;
+}
+
+/**
+ * \brief Calculate alpha value by piecewise linear function
+ * Used for \fad, \fade implementation.
+ */
+static unsigned
+interpolate_alpha(long long now,
+                  long long t1, long long t2, long long t3, long long t4,
+                  unsigned a1, unsigned a2, unsigned a3)
+{
+    unsigned a;
+    double cf;
+    if (now &lt;= t1) {
+        a = a1;
+    } else if (now &gt;= t4) {
+        a = a3;
+    } else if (now &lt; t2) {      // and &gt; t1
+        cf = ((double) (now - t1)) / (t2 - t1);
+        a = a1 * (1 - cf) + a2 * cf;
+    } else if (now &gt; t3) {
+        cf = ((double) (now - t3)) / (t4 - t3);
+        a = a2 * (1 - cf) + a3 * cf;
+    } else {                    // t2 &lt;= now &lt;= t3
+        a = a2;
+    }
+
+    return a;
+}
+
+#define skip_to(x) while ((*p != (x)) &amp;&amp; (*p != '}') &amp;&amp; (*p != 0)) { ++p;}
+#define skip(x) if (*p == (x)) ++p; else { return p; }
+#define skipopt(x) if (*p == (x)) { ++p; }
+
+/**
+ * Parse a vector clip into an outline, using the proper scaling
+ * parameters.  Translate it to correct for screen borders, if needed.
+ */
+static char *parse_vector_clip(ass_renderer_t *render_priv, char *p)
+{
+    int scale = 1;
+    int res = 0;
+    ass_drawing_t *drawing;
+    render_priv-&gt;state.clip_drawing = ass_drawing_new(
+        render_priv-&gt;fontconfig_priv,
+        render_priv-&gt;state.font,
+        render_priv-&gt;settings.hinting,
+        render_priv-&gt;ftlibrary);
+    drawing = render_priv-&gt;state.clip_drawing;
+    skipopt('(');
+    res = mystrtoi(&amp;p, &amp;scale);
+    skipopt(',')
+    if (!res)
+        scale = 1;
+    drawing-&gt;scale = scale;
+    drawing-&gt;scale_x = render_priv-&gt;font_scale_x * render_priv-&gt;font_scale;
+    drawing-&gt;scale_y = render_priv-&gt;font_scale;
+    while (*p != ')' &amp;&amp; *p != '}' &amp;&amp; p != 0)
+        ass_drawing_add_char(drawing, *p++);
+    skipopt(')');
+    ass_drawing_parse(drawing, 1);
+    // We need to translate the clip according to screen borders
+    if (render_priv-&gt;settings.left_margin != 0 ||
+        render_priv-&gt;settings.top_margin != 0) {
+        FT_Vector trans = {
+            .x = int_to_d6(render_priv-&gt;settings.left_margin),
+            .y = -int_to_d6(render_priv-&gt;settings.top_margin),
+        };
+        FT_Outline_Translate(&amp;drawing-&gt;glyph-&gt;outline, trans.x, trans.y);
+    }
+    ass_msg(render_priv-&gt;library, MSGL_DBG2,
+            &quot;Parsed vector clip: scale %d, scales (%f, %f) string [%s]\n&quot;,
+            scale, drawing-&gt;scale_x, drawing-&gt;scale_y, drawing-&gt;text);
+
+    return p;
+}
+
+static void reset_render_context(ass_renderer_t *);
+
+/**
+ * \brief Parse style override tag.
+ * \param p string to parse
+ * \param pwr multiplier for some tag effects (comes from \t tags)
+ */
+static char *parse_tag(ass_renderer_t *render_priv, char *p, double pwr)
+{
+    skip_to('\\');
+    skip('\\');
+    if ((*p == '}') || (*p == 0))
+        return p;
+
+    // New tags introduced in vsfilter 2.39
+    if (mystrcmp(&amp;p, &quot;xbord&quot;)) {
+        double val;
+        if (mystrtod(&amp;p, &amp;val))
+            val = render_priv-&gt;state.border_x * (1 - pwr) + val * pwr;
+        else
+            val = -1.;
+        change_border(render_priv, val, render_priv-&gt;state.border_y);
+    } else if (mystrcmp(&amp;p, &quot;ybord&quot;)) {
+        double val;
+        if (mystrtod(&amp;p, &amp;val))
+            val = render_priv-&gt;state.border_y * (1 - pwr) + val * pwr;
+        else
+            val = -1.;
+        change_border(render_priv, render_priv-&gt;state.border_x, val);
+    } else if (mystrcmp(&amp;p, &quot;xshad&quot;)) {
+        double val;
+        if (mystrtod(&amp;p, &amp;val))
+            val = render_priv-&gt;state.shadow_x * (1 - pwr) + val * pwr;
+        else
+            val = 0.;
+        render_priv-&gt;state.shadow_x = val;
+    } else if (mystrcmp(&amp;p, &quot;yshad&quot;)) {
+        double val;
+        if (mystrtod(&amp;p, &amp;val))
+            val = render_priv-&gt;state.shadow_y * (1 - pwr) + val * pwr;
+        else
+            val = 0.;
+        render_priv-&gt;state.shadow_y = val;
+    } else if (mystrcmp(&amp;p, &quot;fax&quot;)) {
+        double val;
+        if (mystrtod(&amp;p, &amp;val))
+            render_priv-&gt;state.fax =
+                val * pwr + render_priv-&gt;state.fax * (1 - pwr);
+        else
+            render_priv-&gt;state.fax = 0.;
+    } else if (mystrcmp(&amp;p, &quot;fay&quot;)) {
+        double val;
+        if (mystrtod(&amp;p, &amp;val))
+            render_priv-&gt;state.fay =
+                val * pwr + render_priv-&gt;state.fay * (1 - pwr);
+        else
+            render_priv-&gt;state.fay = 0.;
+    } else if (mystrcmp(&amp;p, &quot;iclip&quot;)) {
+        int x0, y0, x1, y1;
+        int res = 1;
+        char *start = p;
+        skipopt('(');
+        res &amp;= mystrtoi(&amp;p, &amp;x0);
+        skipopt(',');
+        res &amp;= mystrtoi(&amp;p, &amp;y0);
+        skipopt(',');
+        res &amp;= mystrtoi(&amp;p, &amp;x1);
+        skipopt(',');
+        res &amp;= mystrtoi(&amp;p, &amp;y1);
+        skipopt(')');
+        if (res) {
+            render_priv-&gt;state.clip_x0 =
+                render_priv-&gt;state.clip_x0 * (1 - pwr) + x0 * pwr;
+            render_priv-&gt;state.clip_x1 =
+                render_priv-&gt;state.clip_x1 * (1 - pwr) + x1 * pwr;
+            render_priv-&gt;state.clip_y0 =
+                render_priv-&gt;state.clip_y0 * (1 - pwr) + y0 * pwr;
+            render_priv-&gt;state.clip_y1 =
+                render_priv-&gt;state.clip_y1 * (1 - pwr) + y1 * pwr;
+            render_priv-&gt;state.clip_mode = 1;
+        } else if (!render_priv-&gt;state.clip_drawing) {
+            p = parse_vector_clip(render_priv, start);
+            render_priv-&gt;state.clip_drawing_mode = 1;
+        } else
+            render_priv-&gt;state.clip_mode = 0;
+    } else if (mystrcmp(&amp;p, &quot;blur&quot;)) {
+        double val;
+        if (mystrtod(&amp;p, &amp;val)) {
+            val = render_priv-&gt;state.blur * (1 - pwr) + val * pwr;
+            val = (val &lt; 0) ? 0 : val;
+            val = (val &gt; BLUR_MAX_RADIUS) ? BLUR_MAX_RADIUS : val;
+            render_priv-&gt;state.blur = val;
+        } else
+            render_priv-&gt;state.blur = 0.0;
+        // ASS standard tags
+    } else if (mystrcmp(&amp;p, &quot;fsc&quot;)) {
+        char tp = *p++;
+        double val;
+        if (tp == 'x') {
+            if (mystrtod(&amp;p, &amp;val)) {
+                val /= 100;
+                render_priv-&gt;state.scale_x =
+                    render_priv-&gt;state.scale_x * (1 - pwr) + val * pwr;
+            } else
+                render_priv-&gt;state.scale_x =
+                    render_priv-&gt;state.style-&gt;ScaleX;
+        } else if (tp == 'y') {
+            if (mystrtod(&amp;p, &amp;val)) {
+                val /= 100;
+                render_priv-&gt;state.scale_y =
+                    render_priv-&gt;state.scale_y * (1 - pwr) + val * pwr;
+            } else
+                render_priv-&gt;state.scale_y =
+                    render_priv-&gt;state.style-&gt;ScaleY;
+        }
+    } else if (mystrcmp(&amp;p, &quot;fsp&quot;)) {
+        double val;
+        if (mystrtod(&amp;p, &amp;val))
+            render_priv-&gt;state.hspacing =
+                render_priv-&gt;state.hspacing * (1 - pwr) + val * pwr;
+        else
+            render_priv-&gt;state.hspacing = render_priv-&gt;state.style-&gt;Spacing;
+    } else if (mystrcmp(&amp;p, &quot;fs&quot;)) {
+        double val;
+        if (mystrtod(&amp;p, &amp;val))
+            val = render_priv-&gt;state.font_size * (1 - pwr) + val * pwr;
+        else
+            val = render_priv-&gt;state.style-&gt;FontSize;
+        if (render_priv-&gt;state.font)
+            change_font_size(render_priv, val);
+    } else if (mystrcmp(&amp;p, &quot;bord&quot;)) {
+        double val;
+        if (mystrtod(&amp;p, &amp;val)) {
+            if (render_priv-&gt;state.border_x == render_priv-&gt;state.border_y)
+                val = render_priv-&gt;state.border_x * (1 - pwr) + val * pwr;
+        } else
+            val = -1.;          // reset to default
+        change_border(render_priv, val, val);
+    } else if (mystrcmp(&amp;p, &quot;move&quot;)) {
+        double x1, x2, y1, y2;
+        long long t1, t2, delta_t, t;
+        double x, y;
+        double k;
+        skip('(');
+        mystrtod(&amp;p, &amp;x1);
+        skip(',');
+        mystrtod(&amp;p, &amp;y1);
+        skip(',');
+        mystrtod(&amp;p, &amp;x2);
+        skip(',');
+        mystrtod(&amp;p, &amp;y2);
+        if (*p == ',') {
+            skip(',');
+            mystrtoll(&amp;p, &amp;t1);
+            skip(',');
+            mystrtoll(&amp;p, &amp;t2);
+            ass_msg(render_priv-&gt;library, MSGL_DBG2,
+                   &quot;movement6: (%f, %f) -&gt; (%f, %f), (%&quot; PRId64 &quot; .. %&quot;
+                   PRId64 &quot;)\n&quot;, x1, y1, x2, y2, (int64_t) t1,
+                   (int64_t) t2);
+        } else {
+            t1 = 0;
+            t2 = render_priv-&gt;state.event-&gt;Duration;
+            ass_msg(render_priv-&gt;library, MSGL_DBG2,
+                   &quot;movement: (%f, %f) -&gt; (%f, %f)&quot;, x1, y1, x2, y2);
+        }
+        skip(')');
+        delta_t = t2 - t1;
+        t = render_priv-&gt;time - render_priv-&gt;state.event-&gt;Start;
+        if (t &lt; t1)
+            k = 0.;
+        else if (t &gt; t2)
+            k = 1.;
+        else
+            k = ((double) (t - t1)) / delta_t;
+        x = k * (x2 - x1) + x1;
+        y = k * (y2 - y1) + y1;
+        if (render_priv-&gt;state.evt_type != EVENT_POSITIONED) {
+            render_priv-&gt;state.pos_x = x;
+            render_priv-&gt;state.pos_y = y;
+            render_priv-&gt;state.detect_collisions = 0;
+            render_priv-&gt;state.evt_type = EVENT_POSITIONED;
+        }
+    } else if (mystrcmp(&amp;p, &quot;frx&quot;)) {
+        double val;
+        if (mystrtod(&amp;p, &amp;val)) {
+            val *= M_PI / 180;
+            render_priv-&gt;state.frx =
+                val * pwr + render_priv-&gt;state.frx * (1 - pwr);
+        } else
+            render_priv-&gt;state.frx = 0.;
+    } else if (mystrcmp(&amp;p, &quot;fry&quot;)) {
+        double val;
+        if (mystrtod(&amp;p, &amp;val)) {
+            val *= M_PI / 180;
+            render_priv-&gt;state.fry =
+                val * pwr + render_priv-&gt;state.fry * (1 - pwr);
+        } else
+            render_priv-&gt;state.fry = 0.;
+    } else if (mystrcmp(&amp;p, &quot;frz&quot;) || mystrcmp(&amp;p, &quot;fr&quot;)) {
+        double val;
+        if (mystrtod(&amp;p, &amp;val)) {
+            val *= M_PI / 180;
+            render_priv-&gt;state.frz =
+                val * pwr + render_priv-&gt;state.frz * (1 - pwr);
+        } else
+            render_priv-&gt;state.frz =
+                M_PI * render_priv-&gt;state.style-&gt;Angle / 180.;
+    } else if (mystrcmp(&amp;p, &quot;fn&quot;)) {
+        char *start = p;
+        char *family;
+        skip_to('\\');
+        if (p &gt; start) {
+            family = malloc(p - start + 1);
+            strncpy(family, start, p - start);
+            family[p - start] = '\0';
+        } else
+            family = strdup(render_priv-&gt;state.style-&gt;FontName);
+        if (render_priv-&gt;state.family)
+            free(render_priv-&gt;state.family);
+        render_priv-&gt;state.family = family;
+        update_font(render_priv);
+    } else if (mystrcmp(&amp;p, &quot;alpha&quot;)) {
+        uint32_t val;
+        int i;
+        if (strtocolor(render_priv-&gt;library, &amp;p, &amp;val)) {
+            unsigned char a = val &gt;&gt; 24;
+            for (i = 0; i &lt; 4; ++i)
+                change_alpha(&amp;render_priv-&gt;state.c[i], a, pwr);
+        } else {
+            change_alpha(&amp;render_priv-&gt;state.c[0],
+                         render_priv-&gt;state.style-&gt;PrimaryColour, pwr);
+            change_alpha(&amp;render_priv-&gt;state.c[1],
+                         render_priv-&gt;state.style-&gt;SecondaryColour, pwr);
+            change_alpha(&amp;render_priv-&gt;state.c[2],
+                         render_priv-&gt;state.style-&gt;OutlineColour, pwr);
+            change_alpha(&amp;render_priv-&gt;state.c[3],
+                         render_priv-&gt;state.style-&gt;BackColour, pwr);
+        }
+        // FIXME: simplify
+    } else if (mystrcmp(&amp;p, &quot;an&quot;)) {
+        int val;
+        if (mystrtoi(&amp;p, &amp;val) &amp;&amp; val) {
+            int v = (val - 1) / 3;      // 0, 1 or 2 for vertical alignment
+            ass_msg(render_priv-&gt;library, MSGL_DBG2, &quot;an %d&quot;, val);
+            if (v != 0)
+                v = 3 - v;
+            val = ((val - 1) % 3) + 1;  // horizontal alignment
+            val += v * 4;
+            ass_msg(render_priv-&gt;library, MSGL_DBG2, &quot;align %d&quot;, val);
+            render_priv-&gt;state.alignment = val;
+        } else
+            render_priv-&gt;state.alignment =
+                render_priv-&gt;state.style-&gt;Alignment;
+    } else if (mystrcmp(&amp;p, &quot;a&quot;)) {
+        int val;
+        if (mystrtoi(&amp;p, &amp;val) &amp;&amp; val)
+            render_priv-&gt;state.alignment = val;
+        else
+            render_priv-&gt;state.alignment =
+                render_priv-&gt;state.style-&gt;Alignment;
+    } else if (mystrcmp(&amp;p, &quot;pos&quot;)) {
+        double v1, v2;
+        skip('(');
+        mystrtod(&amp;p, &amp;v1);
+        skip(',');
+        mystrtod(&amp;p, &amp;v2);
+        skip(')');
+        ass_msg(render_priv-&gt;library, MSGL_DBG2, &quot;pos(%f, %f)&quot;, v1, v2);
+        if (render_priv-&gt;state.evt_type == EVENT_POSITIONED) {
+            ass_msg(render_priv-&gt;library, MSGL_V, &quot;Subtitle has a new \\pos &quot;
+                   &quot;after \\move or \\pos, ignoring&quot;);
+        } else {
+            render_priv-&gt;state.evt_type = EVENT_POSITIONED;
+            render_priv-&gt;state.detect_collisions = 0;
+            render_priv-&gt;state.pos_x = v1;
+            render_priv-&gt;state.pos_y = v2;
+        }
+    } else if (mystrcmp(&amp;p, &quot;fad&quot;)) {
+        int a1, a2, a3;
+        long long t1, t2, t3, t4;
+        if (*p == 'e')
+            ++p;                // either \fad or \fade
+        skip('(');
+        mystrtoi(&amp;p, &amp;a1);
+        skip(',');
+        mystrtoi(&amp;p, &amp;a2);
+        if (*p == ')') {
+            // 2-argument version (\fad, according to specs)
+            // a1 and a2 are fade-in and fade-out durations
+            t1 = 0;
+            t4 = render_priv-&gt;state.event-&gt;Duration;
+            t2 = a1;
+            t3 = t4 - a2;
+            a1 = 0xFF;
+            a2 = 0;
+            a3 = 0xFF;
+        } else {
+            // 6-argument version (\fade)
+            // a1 and a2 (and a3) are opacity values
+            skip(',');
+            mystrtoi(&amp;p, &amp;a3);
+            skip(',');
+            mystrtoll(&amp;p, &amp;t1);
+            skip(',');
+            mystrtoll(&amp;p, &amp;t2);
+            skip(',');
+            mystrtoll(&amp;p, &amp;t3);
+            skip(',');
+            mystrtoll(&amp;p, &amp;t4);
+        }
+        skip(')');
+        render_priv-&gt;state.fade =
+            interpolate_alpha(render_priv-&gt;time -
+                              render_priv-&gt;state.event-&gt;Start, t1, t2,
+                              t3, t4, a1, a2, a3);
+    } else if (mystrcmp(&amp;p, &quot;org&quot;)) {
+        int v1, v2;
+        skip('(');
+        mystrtoi(&amp;p, &amp;v1);
+        skip(',');
+        mystrtoi(&amp;p, &amp;v2);
+        skip(')');
+        ass_msg(render_priv-&gt;library, MSGL_DBG2, &quot;org(%d, %d)&quot;, v1, v2);
+        if (!render_priv-&gt;state.have_origin) {
+            render_priv-&gt;state.org_x = v1;
+            render_priv-&gt;state.org_y = v2;
+            render_priv-&gt;state.have_origin = 1;
+            render_priv-&gt;state.detect_collisions = 0;
+        }
+    } else if (mystrcmp(&amp;p, &quot;t&quot;)) {
+        double v[3];
+        int v1, v2;
+        double v3;
+        int cnt;
+        long long t1, t2, t, delta_t;
+        double k;
+        skip('(');
+        for (cnt = 0; cnt &lt; 3; ++cnt) {
+            if (*p == '\\')
+                break;
+            v[cnt] = strtod(p, &amp;p);
+            skip(',');
+        }
+        if (cnt == 3) {
+            v1 = v[0];
+            v2 = (v[1] &lt; v1) ? render_priv-&gt;state.event-&gt;Duration : v[1];
+            v3 = v[2];
+        } else if (cnt == 2) {
+            v1 = v[0];
+            v2 = (v[1] &lt; v1) ? render_priv-&gt;state.event-&gt;Duration : v[1];
+            v3 = 1.;
+        } else if (cnt == 1) {
+            v1 = 0;
+            v2 = render_priv-&gt;state.event-&gt;Duration;
+            v3 = v[0];
+        } else {                // cnt == 0
+            v1 = 0;
+            v2 = render_priv-&gt;state.event-&gt;Duration;
+            v3 = 1.;
+        }
+        render_priv-&gt;state.detect_collisions = 0;
+        t1 = v1;
+        t2 = v2;
+        delta_t = v2 - v1;
+        if (v3 &lt; 0.)
+            v3 = 0.;
+        t = render_priv-&gt;time - render_priv-&gt;state.event-&gt;Start;        // FIXME: move to render_context
+        if (t &lt;= t1)
+            k = 0.;
+        else if (t &gt;= t2)
+            k = 1.;
+        else {
+            assert(delta_t != 0.);
+            k = pow(((double) (t - t1)) / delta_t, v3);
+        }
+        while (*p == '\\')
+            p = parse_tag(render_priv, p, k);   // maybe k*pwr ? no, specs forbid nested \t's
+        skip_to(')');           // in case there is some unknown tag or a comment
+        skip(')');
+    } else if (mystrcmp(&amp;p, &quot;clip&quot;)) {
+        char *start = p;
+        int x0, y0, x1, y1;
+        int res = 1;
+        skipopt('(');
+        res &amp;= mystrtoi(&amp;p, &amp;x0);
+        skipopt(',');
+        res &amp;= mystrtoi(&amp;p, &amp;y0);
+        skipopt(',');
+        res &amp;= mystrtoi(&amp;p, &amp;x1);
+        skipopt(',');
+        res &amp;= mystrtoi(&amp;p, &amp;y1);
+        skipopt(')');
+        if (res) {
+            render_priv-&gt;state.clip_x0 =
+                render_priv-&gt;state.clip_x0 * (1 - pwr) + x0 * pwr;
+            render_priv-&gt;state.clip_x1 =
+                render_priv-&gt;state.clip_x1 * (1 - pwr) + x1 * pwr;
+            render_priv-&gt;state.clip_y0 =
+                render_priv-&gt;state.clip_y0 * (1 - pwr) + y0 * pwr;
+            render_priv-&gt;state.clip_y1 =
+                render_priv-&gt;state.clip_y1 * (1 - pwr) + y1 * pwr;
+        // Might be a vector clip
+        } else if (!render_priv-&gt;state.clip_drawing) {
+            p = parse_vector_clip(render_priv, start);
+            render_priv-&gt;state.clip_drawing_mode = 0;
+        } else {
+            render_priv-&gt;state.clip_x0 = 0;
+            render_priv-&gt;state.clip_y0 = 0;
+            render_priv-&gt;state.clip_x1 = render_priv-&gt;track-&gt;PlayResX;
+            render_priv-&gt;state.clip_y1 = render_priv-&gt;track-&gt;PlayResY;
+        }
+    } else if (mystrcmp(&amp;p, &quot;c&quot;)) {
+        uint32_t val;
+        if (!strtocolor(render_priv-&gt;library, &amp;p, &amp;val))
+            val = render_priv-&gt;state.style-&gt;PrimaryColour;
+        ass_msg(render_priv-&gt;library, MSGL_DBG2, &quot;color: %X&quot;, val);
+        change_color(&amp;render_priv-&gt;state.c[0], val, pwr);
+    } else if ((*p &gt;= '1') &amp;&amp; (*p &lt;= '4') &amp;&amp; (++p)
+               &amp;&amp; (mystrcmp(&amp;p, &quot;c&quot;) || mystrcmp(&amp;p, &quot;a&quot;))) {
+        char n = *(p - 2);
+        int cidx = n - '1';
+        char cmd = *(p - 1);
+        uint32_t val;
+        assert((n &gt;= '1') &amp;&amp; (n &lt;= '4'));
+        if (!strtocolor(render_priv-&gt;library, &amp;p, &amp;val))
+            switch (n) {
+            case '1':
+                val = render_priv-&gt;state.style-&gt;PrimaryColour;
+                break;
+            case '2':
+                val = render_priv-&gt;state.style-&gt;SecondaryColour;
+                break;
+            case '3':
+                val = render_priv-&gt;state.style-&gt;OutlineColour;
+                break;
+            case '4':
+                val = render_priv-&gt;state.style-&gt;BackColour;
+                break;
+            default:
+                val = 0;
+                break;          // impossible due to assert; avoid compilation warning
+            }
+        switch (cmd) {
+        case 'c':
+            change_color(render_priv-&gt;state.c + cidx, val, pwr);
+            break;
+        case 'a':
+            change_alpha(render_priv-&gt;state.c + cidx, val &gt;&gt; 24, pwr);
+            break;
+        default:
+            ass_msg(render_priv-&gt;library, MSGL_WARN, &quot;Bad command: %c%c&quot;,
+                    n, cmd);
+            break;
+        }
+        ass_msg(render_priv-&gt;library, MSGL_DBG2, &quot;single c/a at %f: %c%c = %X&quot;,
+               pwr, n, cmd, render_priv-&gt;state.c[cidx]);
+    } else if (mystrcmp(&amp;p, &quot;r&quot;)) {
+        reset_render_context(render_priv);
+    } else if (mystrcmp(&amp;p, &quot;be&quot;)) {
+        int val;
+        if (mystrtoi(&amp;p, &amp;val)) {
+            // Clamp to a safe upper limit, since high values need excessive CPU
+            val = (val &lt; 0) ? 0 : val;
+            val = (val &gt; MAX_BE) ? MAX_BE : val;
+            render_priv-&gt;state.be = val;
+        } else
+            render_priv-&gt;state.be = 0;
+    } else if (mystrcmp(&amp;p, &quot;b&quot;)) {
+        int b;
+        if (mystrtoi(&amp;p, &amp;b)) {
+            if (pwr &gt;= .5)
+                render_priv-&gt;state.bold = b;
+        } else
+            render_priv-&gt;state.bold = render_priv-&gt;state.style-&gt;Bold;
+        update_font(render_priv);
+    } else if (mystrcmp(&amp;p, &quot;i&quot;)) {
+        int i;
+        if (mystrtoi(&amp;p, &amp;i)) {
+            if (pwr &gt;= .5)
+                render_priv-&gt;state.italic = i;
+        } else
+            render_priv-&gt;state.italic = render_priv-&gt;state.style-&gt;Italic;
+        update_font(render_priv);
+    } else if (mystrcmp(&amp;p, &quot;kf&quot;) || mystrcmp(&amp;p, &quot;K&quot;)) {
+        int val = 0;
+        mystrtoi(&amp;p, &amp;val);
+        render_priv-&gt;state.effect_type = EF_KARAOKE_KF;
+        if (render_priv-&gt;state.effect_timing)
+            render_priv-&gt;state.effect_skip_timing +=
+                render_priv-&gt;state.effect_timing;
+        render_priv-&gt;state.effect_timing = val * 10;
+    } else if (mystrcmp(&amp;p, &quot;ko&quot;)) {
+        int val = 0;
+        mystrtoi(&amp;p, &amp;val);
+        render_priv-&gt;state.effect_type = EF_KARAOKE_KO;
+        if (render_priv-&gt;state.effect_timing)
+            render_priv-&gt;state.effect_skip_timing +=
+                render_priv-&gt;state.effect_timing;
+        render_priv-&gt;state.effect_timing = val * 10;
+    } else if (mystrcmp(&amp;p, &quot;k&quot;)) {
+        int val = 0;
+        mystrtoi(&amp;p, &amp;val);
+        render_priv-&gt;state.effect_type = EF_KARAOKE;
+        if (render_priv-&gt;state.effect_timing)
+            render_priv-&gt;state.effect_skip_timing +=
+                render_priv-&gt;state.effect_timing;
+        render_priv-&gt;state.effect_timing = val * 10;
+    } else if (mystrcmp(&amp;p, &quot;shad&quot;)) {
+        double val;
+        if (mystrtod(&amp;p, &amp;val)) {
+            if (render_priv-&gt;state.shadow_x == render_priv-&gt;state.shadow_y)
+                val = render_priv-&gt;state.shadow_x * (1 - pwr) + val * pwr;
+        } else
+            val = 0.;
+        render_priv-&gt;state.shadow_x = render_priv-&gt;state.shadow_y = val;
+    } else if (mystrcmp(&amp;p, &quot;s&quot;)) {
+        int val;
+        if (mystrtoi(&amp;p, &amp;val) &amp;&amp; val)
+            render_priv-&gt;state.flags |= DECO_STRIKETHROUGH;
+        else
+            render_priv-&gt;state.flags &amp;= ~DECO_STRIKETHROUGH;
+    } else if (mystrcmp(&amp;p, &quot;u&quot;)) {
+        int val;
+        if (mystrtoi(&amp;p, &amp;val) &amp;&amp; val)
+            render_priv-&gt;state.flags |= DECO_UNDERLINE;
+        else
+            render_priv-&gt;state.flags &amp;= ~DECO_UNDERLINE;
+    } else if (mystrcmp(&amp;p, &quot;pbo&quot;)) {
+        double val = 0;
+        if (mystrtod(&amp;p, &amp;val))
+            render_priv-&gt;state.drawing-&gt;pbo = val;
+    } else if (mystrcmp(&amp;p, &quot;p&quot;)) {
+        int val;
+        if (!mystrtoi(&amp;p, &amp;val))
+            val = 0;
+        if (val)
+            render_priv-&gt;state.drawing-&gt;scale = val;
+        render_priv-&gt;state.drawing_mode = !!val;
+    }
+
+    return p;
+
+#undef skip
+#undef skipopt
+#undef skip_to
+}
+
+/**
+ * \brief Get next ucs4 char from string, parsing and executing style overrides
+ * \param str string pointer
+ * \return ucs4 code of the next char
+ * On return str points to the unparsed part of the string
+ */
+static unsigned get_next_char(ass_renderer_t *render_priv, char **str)
+{
+    char *p = *str;
+    unsigned chr;
+    if (*p == '{') {            // '\0' goes here
+        p++;
+        while (1) {
+            p = parse_tag(render_priv, p, 1.);
+            if (*p == '}') {    // end of tag
+                p++;
+                if (*p == '{') {
+                    p++;
+                    continue;
+                } else
+                    break;
+            } else if (*p != '\\')
+                ass_msg(render_priv-&gt;library, MSGL_V,
+                        &quot;Unable to parse: '%s'&quot;, p);
+            if (*p == 0)
+                break;
+        }
+    }
+    if (*p == '\t') {
+        ++p;
+        *str = p;
+        return ' ';
+    }
+    if (*p == '\\') {
+        if ((*(p + 1) == 'N')
+            || ((*(p + 1) == 'n')
+                &amp;&amp; (render_priv-&gt;track-&gt;WrapStyle == 2))) {
+            p += 2;
+            *str = p;
+            return '\n';
+        } else if ((*(p + 1) == 'n') || (*(p + 1) == 'h')) {
+            p += 2;
+            *str = p;
+            return ' ';
+        }
+    }
+    chr = ass_utf8_get_char((char **) &amp;p);
+    *str = p;
+    return chr;
+}
+
+static void
+apply_transition_effects(ass_renderer_t *render_priv, ass_event_t *event)
+{
+    int v[4];
+    int cnt;
+    char *p = event-&gt;Effect;
+
+    if (!p || !*p)
+        return;
+
+    cnt = 0;
+    while (cnt &lt; 4 &amp;&amp; (p = strchr(p, ';'))) {
+        v[cnt++] = atoi(++p);
+    }
+
+    if (strncmp(event-&gt;Effect, &quot;Banner;&quot;, 7) == 0) {
+        int delay;
+        if (cnt &lt; 1) {
+            ass_msg(render_priv-&gt;library, MSGL_V,
+                    &quot;Error parsing effect: '%s'&quot;, event-&gt;Effect);
+            return;
+        }
+        if (cnt &gt;= 2 &amp;&amp; v[1] == 0)      // right-to-left
+            render_priv-&gt;state.scroll_direction = SCROLL_RL;
+        else                    // left-to-right
+            render_priv-&gt;state.scroll_direction = SCROLL_LR;
+
+        delay = v[0];
+        if (delay == 0)
+            delay = 1;          // ?
+        render_priv-&gt;state.scroll_shift =
+            (render_priv-&gt;time - render_priv-&gt;state.event-&gt;Start) / delay;
+        render_priv-&gt;state.evt_type = EVENT_HSCROLL;
+        return;
+    }
+
+    if (strncmp(event-&gt;Effect, &quot;Scroll up;&quot;, 10) == 0) {
+        render_priv-&gt;state.scroll_direction = SCROLL_BT;
+    } else if (strncmp(event-&gt;Effect, &quot;Scroll down;&quot;, 12) == 0) {
+        render_priv-&gt;state.scroll_direction = SCROLL_TB;
+    } else {
+        ass_msg(render_priv-&gt;library, MSGL_V,
+                &quot;Unknown transition effect: '%s'&quot;, event-&gt;Effect);
+        return;
+    }
+    // parse scroll up/down parameters
+    {
+        int delay;
+        int y0, y1;
+        if (cnt &lt; 3) {
+            ass_msg(render_priv-&gt;library, MSGL_V,
+                    &quot;Error parsing effect: '%s'&quot;, event-&gt;Effect);
+            return;
+        }
+        delay = v[2];
+        if (delay == 0)
+            delay = 1;          // ?
+        render_priv-&gt;state.scroll_shift =
+            (render_priv-&gt;time - render_priv-&gt;state.event-&gt;Start) / delay;
+        if (v[0] &lt; v[1]) {
+            y0 = v[0];
+            y1 = v[1];
+        } else {
+            y0 = v[1];
+            y1 = v[0];
+        }
+        if (y1 == 0)
+            y1 = render_priv-&gt;track-&gt;PlayResY;  // y0=y1=0 means fullscreen scrolling
+        render_priv-&gt;state.clip_y0 = y0;
+        render_priv-&gt;state.clip_y1 = y1;
+        render_priv-&gt;state.evt_type = EVENT_VSCROLL;
+        render_priv-&gt;state.detect_collisions = 0;
+    }
+
+}
+
+/**
+ * \brief partially reset render_context to style values
+ * Works like {\r}: resets some style overrides
+ */
+static void reset_render_context(ass_renderer_t *render_priv)
+{
+    render_priv-&gt;state.c[0] = render_priv-&gt;state.style-&gt;PrimaryColour;
+    render_priv-&gt;state.c[1] = render_priv-&gt;state.style-&gt;SecondaryColour;
+    render_priv-&gt;state.c[2] = render_priv-&gt;state.style-&gt;OutlineColour;
+    render_priv-&gt;state.c[3] = render_priv-&gt;state.style-&gt;BackColour;
+    render_priv-&gt;state.flags =
+        (render_priv-&gt;state.style-&gt;Underline ? DECO_UNDERLINE : 0) |
+        (render_priv-&gt;state.style-&gt;StrikeOut ? DECO_STRIKETHROUGH : 0);
+    render_priv-&gt;state.font_size = render_priv-&gt;state.style-&gt;FontSize;
+
+    free(render_priv-&gt;state.family);
+    render_priv-&gt;state.family = NULL;
+    render_priv-&gt;state.family = strdup(render_priv-&gt;state.style-&gt;FontName);
+    render_priv-&gt;state.treat_family_as_pattern =
+        render_priv-&gt;state.style-&gt;treat_fontname_as_pattern;
+    render_priv-&gt;state.bold = render_priv-&gt;state.style-&gt;Bold;
+    render_priv-&gt;state.italic = render_priv-&gt;state.style-&gt;Italic;
+    update_font(render_priv);
+
+    change_border(render_priv, -1., -1.);
+    render_priv-&gt;state.scale_x = render_priv-&gt;state.style-&gt;ScaleX;
+    render_priv-&gt;state.scale_y = render_priv-&gt;state.style-&gt;ScaleY;
+    render_priv-&gt;state.hspacing = render_priv-&gt;state.style-&gt;Spacing;
+    render_priv-&gt;state.be = 0;
+    render_priv-&gt;state.blur = 0.0;
+    render_priv-&gt;state.shadow_x = render_priv-&gt;state.style-&gt;Shadow;
+    render_priv-&gt;state.shadow_y = render_priv-&gt;state.style-&gt;Shadow;
+    render_priv-&gt;state.frx = render_priv-&gt;state.fry = 0.;
+    render_priv-&gt;state.frz = M_PI * render_priv-&gt;state.style-&gt;Angle / 180.;
+    render_priv-&gt;state.fax = render_priv-&gt;state.fay = 0.;
+
+    // FIXME: does not reset unsupported attributes.
+}
+
+/**
+ * \brief Start new event. Reset render_priv-&gt;state.
+ */
+static void
+init_render_context(ass_renderer_t *render_priv, ass_event_t *event)
+{
+    render_priv-&gt;state.event = event;
+    render_priv-&gt;state.style = render_priv-&gt;track-&gt;styles + event-&gt;Style;
+
+    reset_render_context(render_priv);
+
+    render_priv-&gt;state.evt_type = EVENT_NORMAL;
+    render_priv-&gt;state.alignment = render_priv-&gt;state.style-&gt;Alignment;
+    render_priv-&gt;state.pos_x = 0;
+    render_priv-&gt;state.pos_y = 0;
+    render_priv-&gt;state.org_x = 0;
+    render_priv-&gt;state.org_y = 0;
+    render_priv-&gt;state.have_origin = 0;
+    render_priv-&gt;state.clip_x0 = 0;
+    render_priv-&gt;state.clip_y0 = 0;
+    render_priv-&gt;state.clip_x1 = render_priv-&gt;track-&gt;PlayResX;
+    render_priv-&gt;state.clip_y1 = render_priv-&gt;track-&gt;PlayResY;
+    render_priv-&gt;state.detect_collisions = 1;
+    render_priv-&gt;state.fade = 0;
+    render_priv-&gt;state.drawing_mode = 0;
+    render_priv-&gt;state.effect_type = EF_NONE;
+    render_priv-&gt;state.effect_timing = 0;
+    render_priv-&gt;state.effect_skip_timing = 0;
+    render_priv-&gt;state.drawing =
+        ass_drawing_new(render_priv-&gt;fontconfig_priv,
+                        render_priv-&gt;state.font,
+                        render_priv-&gt;settings.hinting,
+                        render_priv-&gt;ftlibrary);
+
+    apply_transition_effects(render_priv, event);
+}
+
+static void free_render_context(ass_renderer_t *render_priv)
+{
+    free(render_priv-&gt;state.family);
+    ass_drawing_free(render_priv-&gt;state.drawing);
+
+    render_priv-&gt;state.family = NULL;
+    render_priv-&gt;state.drawing = NULL;
+}
+
+// Calculate the cbox of a series of points
+static void
+get_contour_cbox(FT_BBox *box, FT_Vector *points, int start, int end)
+{
+    box-&gt;xMin = box-&gt;yMin = INT_MAX;
+    box-&gt;xMax = box-&gt;yMax = INT_MIN;
+    int i;
+
+    for (i = start; i &lt; end; i++) {
+        box-&gt;xMin = (points[i].x &lt; box-&gt;xMin) ? points[i].x : box-&gt;xMin;
+        box-&gt;xMax = (points[i].x &gt; box-&gt;xMax) ? points[i].x : box-&gt;xMax;
+        box-&gt;yMin = (points[i].y &lt; box-&gt;yMin) ? points[i].y : box-&gt;yMin;
+        box-&gt;yMax = (points[i].y &gt; box-&gt;yMax) ? points[i].y : box-&gt;yMax;
+    }
+}
+
+/**
+ * \brief Fix-up stroker result for huge borders by removing the contours from
+ * the outline that are harmful.
+*/
+static void fix_freetype_stroker(FT_OutlineGlyph glyph, int border_x,
+                                 int border_y)
+{
+    int nc = glyph-&gt;outline.n_contours;
+    int begin, stop;
+    char modified = 0;
+    char *valid_cont;
+    int start = 0;
+    int end = -1;
+    FT_BBox *boxes = calloc(nc, sizeof(FT_BBox));
+    int i, j;
+
+    // Create a list of cboxes of the contours
+    for (i = 0; i &lt; nc; i++) {
+        start = end + 1;
+        end = glyph-&gt;outline.contours[i];
+        get_contour_cbox(&amp;boxes[i], glyph-&gt;outline.points, start, end);
+    }
+
+    // if a) contour's cbox is contained in another contours cbox
+    //    b) contour's height or width is smaller than the border*2
+    // the contour can be safely removed.
+    valid_cont = calloc(1, nc);
+    for (i = 0; i &lt; nc; i++) {
+        valid_cont[i] = 1;
+        for (j = 0; j &lt; nc; j++) {
+            if (i == j)
+                continue;
+            if (boxes[i].xMin &gt;= boxes[j].xMin &amp;&amp;
+                boxes[i].xMax &lt;= boxes[j].xMax &amp;&amp;
+                boxes[i].yMin &gt;= boxes[j].yMin &amp;&amp;
+                boxes[i].yMax &lt;= boxes[j].yMax) {
+                int width = boxes[i].xMax - boxes[i].xMin;
+                int height = boxes[i].yMax - boxes[i].yMin;
+                if (width &lt; border_x * 2 || height &lt; border_y * 2) {
+                    valid_cont[i] = 0;
+                    modified = 1;
+                    break;
+                }
+            }
+        }
+    }
+
+    // Zero-out contours that can be removed; much simpler than copying
+    if (modified) {
+        for (i = 0; i &lt; nc; i++) {
+            if (valid_cont[i])
+                continue;
+            begin = (i == 0) ? 0 : glyph-&gt;outline.contours[i - 1] + 1;
+            stop = glyph-&gt;outline.contours[i];
+            for (j = begin; j &lt;= stop; j++) {
+                glyph-&gt;outline.points[j].x = 0;
+                glyph-&gt;outline.points[j].y = 0;
+                glyph-&gt;outline.tags[j] = 0;
+            }
+        }
+    }
+
+    free(boxes);
+    free(valid_cont);
+}
+
+/*
+ * Stroke an outline glyph in x/y direction.  Applies various fixups to get
+ * around limitations of the FreeType stroker.
+ */
+static void stroke_outline_glyph(ass_renderer_t *render_priv,
+                                 FT_OutlineGlyph *glyph, int sx, int sy)
+{
+    if (sx &lt;= 0 &amp;&amp; sy &lt;= 0)
+        return;
+
+    fix_freetype_stroker(*glyph, sx, sy);
+
+    // Borders are equal; use the regular stroker
+    if (sx == sy &amp;&amp; render_priv-&gt;state.stroker) {
+        int error;
+        error = FT_Glyph_StrokeBorder((FT_Glyph *) glyph,
+                                      render_priv-&gt;state.stroker, 0, 1);
+        if (error)
+            ass_msg(render_priv-&gt;library, MSGL_WARN,
+                    &quot;FT_Glyph_Stroke error: %d&quot;, error);
+
+    // &quot;Stroke&quot; with the outline emboldener in two passes.
+    // The outlines look uglier, but the emboldening never adds any points
+    } else {
+        int i;
+        FT_Outline *ol = &amp;(*glyph)-&gt;outline;
+        FT_Outline nol;
+        FT_Outline_New(render_priv-&gt;ftlibrary, ol-&gt;n_points,
+                       ol-&gt;n_contours, &amp;nol);
+        FT_Outline_Copy(ol, &amp;nol);
+
+        FT_Outline_Embolden(ol, sx * 2);
+        FT_Outline_Translate(ol, -sx, -sx);
+        FT_Outline_Embolden(&amp;nol, sy * 2);
+        FT_Outline_Translate(&amp;nol, -sy, -sy);
+
+        for (i = 0; i &lt; ol-&gt;n_points; i++)
+            ol-&gt;points[i].y = nol.points[i].y;
+
+        FT_Outline_Done(render_priv-&gt;ftlibrary, &amp;nol);
+    }
+}
+
+/**
+ * \brief Get normal and outline (border) glyphs
+ * \param symbol ucs4 char
+ * \param info out: struct filled with extracted data
+ * Tries to get both glyphs from cache.
+ * If they can't be found, gets a glyph from font face, generates outline with FT_Stroker,
+ * and add them to cache.
+ * The glyphs are returned in info-&gt;glyph and info-&gt;outline_glyph
+ */
+static void
+get_outline_glyph(ass_renderer_t *render_priv, int symbol,
+                  glyph_info_t *info, ass_drawing_t *drawing)
+{
+    glyph_hash_val_t *val;
+    glyph_hash_key_t key;
+    memset(&amp;key, 0, sizeof(key));
+
+    if (drawing-&gt;hash) {
+        key.scale_x = double_to_d16(render_priv-&gt;state.scale_x);
+        key.scale_y = double_to_d16(render_priv-&gt;state.scale_y);
+        key.outline.x = render_priv-&gt;state.border_x * 0xFFFF;
+        key.outline.y = render_priv-&gt;state.border_y * 0xFFFF;
+        key.drawing_hash = drawing-&gt;hash;
+    } else {
+        key.font = render_priv-&gt;state.font;
+        key.size = render_priv-&gt;state.font_size;
+        key.ch = symbol;
+        key.bold = render_priv-&gt;state.bold;
+        key.italic = render_priv-&gt;state.italic;
+        key.scale_x = double_to_d16(render_priv-&gt;state.scale_x);
+        key.scale_y = double_to_d16(render_priv-&gt;state.scale_y);
+        key.outline.x = render_priv-&gt;state.border_x * 0xFFFF;
+        key.outline.y = render_priv-&gt;state.border_y * 0xFFFF;
+        key.flags = render_priv-&gt;state.flags;
+    }
+    memset(info, 0, sizeof(glyph_info_t));
+
+    val = cache_find_glyph(render_priv-&gt;cache.glyph_cache, &amp;key);
+    if (val) {
+        FT_Glyph_Copy(val-&gt;glyph, &amp;info-&gt;glyph);
+        if (val-&gt;outline_glyph)
+            FT_Glyph_Copy(val-&gt;outline_glyph, &amp;info-&gt;outline_glyph);
+        info-&gt;bbox = val-&gt;bbox_scaled;
+        info-&gt;advance.x = val-&gt;advance.x;
+        info-&gt;advance.y = val-&gt;advance.y;
+        if (drawing-&gt;hash) {
+            drawing-&gt;asc = val-&gt;asc;
+            drawing-&gt;desc = val-&gt;desc;
+        }
+    } else {
+        glyph_hash_val_t v;
+        if (drawing-&gt;hash) {
+            ass_drawing_parse(drawing, 0);
+            FT_Glyph_Copy((FT_Glyph) drawing-&gt;glyph, &amp;info-&gt;glyph);
+        } else {
+            info-&gt;glyph =
+                ass_font_get_glyph(render_priv-&gt;fontconfig_priv,
+                                   render_priv-&gt;state.font, symbol,
+                                   render_priv-&gt;settings.hinting,
+                                   render_priv-&gt;state.flags);
+        }
+        if (!info-&gt;glyph)
+            return;
+        info-&gt;advance.x = d16_to_d6(info-&gt;glyph-&gt;advance.x);
+        info-&gt;advance.y = d16_to_d6(info-&gt;glyph-&gt;advance.y);
+        FT_Glyph_Get_CBox(info-&gt;glyph, FT_GLYPH_BBOX_SUBPIXELS, &amp;info-&gt;bbox);
+
+        if (render_priv-&gt;state.border_x &gt; 0 ||
+            render_priv-&gt;state.border_y &gt; 0) {
+
+            FT_Glyph_Copy(info-&gt;glyph, &amp;info-&gt;outline_glyph);
+            stroke_outline_glyph(render_priv,
+                                 (FT_OutlineGlyph *) &amp;info-&gt;outline_glyph,
+                                 double_to_d6(render_priv-&gt;state.border_x *
+                                              render_priv-&gt;border_scale),
+                                 double_to_d6(render_priv-&gt;state.border_y *
+                                              render_priv-&gt;border_scale));
+        }
+
+        memset(&amp;v, 0, sizeof(v));
+        FT_Glyph_Copy(info-&gt;glyph, &amp;v.glyph);
+        if (info-&gt;outline_glyph)
+            FT_Glyph_Copy(info-&gt;outline_glyph, &amp;v.outline_glyph);
+        v.advance = info-&gt;advance;
+        v.bbox_scaled = info-&gt;bbox;
+        if (drawing-&gt;hash) {
+            v.asc = drawing-&gt;asc;
+            v.desc = drawing-&gt;desc;
+        }
+        cache_add_glyph(render_priv-&gt;cache.glyph_cache, &amp;key, &amp;v);
+    }
+}
+
+static void transform_3d(FT_Vector shift, FT_Glyph *glyph,
+                         FT_Glyph *glyph2, double frx, double fry,
+                         double frz, double fax, double fay, double scale);
+
+/**
+ * \brief Get bitmaps for a glyph
+ * \param info glyph info
+ * Tries to get glyph bitmaps from bitmap cache.
+ * If they can't be found, they are generated by rotating and rendering the glyph.
+ * After that, bitmaps are added to the cache.
+ * They are returned in info-&gt;bm (glyph), info-&gt;bm_o (outline) and info-&gt;bm_s (shadow).
+ */
+static void
+get_bitmap_glyph(ass_renderer_t *render_priv, glyph_info_t *info)
+{
+    bitmap_hash_val_t *val;
+    bitmap_hash_key_t *key = &amp;info-&gt;hash_key;
+
+    val = cache_find_bitmap(render_priv-&gt;cache.bitmap_cache, key);
+
+    if (val) {
+        info-&gt;bm = val-&gt;bm;
+        info-&gt;bm_o = val-&gt;bm_o;
+        info-&gt;bm_s = val-&gt;bm_s;
+    } else {
+        FT_Vector shift;
+        bitmap_hash_val_t hash_val;
+        int error;
+        info-&gt;bm = info-&gt;bm_o = info-&gt;bm_s = 0;
+        if (info-&gt;glyph &amp;&amp; info-&gt;symbol != '\n' &amp;&amp; info-&gt;symbol != 0) {
+            // calculating rotation shift vector (from rotation origin to the glyph basepoint)
+            shift.x = info-&gt;hash_key.shift_x;
+            shift.y = info-&gt;hash_key.shift_y;
+            // apply rotation
+            transform_3d(shift, &amp;info-&gt;glyph, &amp;info-&gt;outline_glyph,
+                         info-&gt;frx, info-&gt;fry, info-&gt;frz, info-&gt;fax,
+                         info-&gt;fay, render_priv-&gt;font_scale);
+
+            // subpixel shift
+            if (info-&gt;glyph)
+                FT_Outline_Translate(
+                    &amp;((FT_OutlineGlyph) info-&gt;glyph)-&gt;outline,
+                    info-&gt;hash_key.advance.x,
+                    -info-&gt;hash_key.advance.y);
+            if (info-&gt;outline_glyph)
+                FT_Outline_Translate(
+                    &amp;((FT_OutlineGlyph) info-&gt;outline_glyph)-&gt;outline,
+                    info-&gt;hash_key.advance.x,
+                    -info-&gt;hash_key.advance.y);
+
+            // render glyph
+            error = glyph_to_bitmap(render_priv-&gt;library,
+                                    render_priv-&gt;synth_priv,
+                                    info-&gt;glyph, info-&gt;outline_glyph,
+                                    &amp;info-&gt;bm, &amp;info-&gt;bm_o,
+                                    &amp;info-&gt;bm_s, info-&gt;be,
+                                    info-&gt;blur * render_priv-&gt;border_scale,
+                                    info-&gt;hash_key.shadow_offset);
+            if (error)
+                info-&gt;symbol = 0;
+
+            // add bitmaps to cache
+            hash_val.bm_o = info-&gt;bm_o;
+            hash_val.bm = info-&gt;bm;
+            hash_val.bm_s = info-&gt;bm_s;
+            cache_add_bitmap(render_priv-&gt;cache.bitmap_cache,
+                             &amp;(info-&gt;hash_key), &amp;hash_val);
+        }
+    }
+    // deallocate glyphs
+    if (info-&gt;glyph)
+        FT_Done_Glyph(info-&gt;glyph);
+    if (info-&gt;outline_glyph)
+        FT_Done_Glyph(info-&gt;outline_glyph);
+}
+
+/**
+ * This function goes through text_info and calculates text parameters.
+ * The following text_info fields are filled:
+ *   height
+ *   lines[].height
+ *   lines[].asc
+ *   lines[].desc
+ */
+static void measure_text(ass_renderer_t *render_priv)
+{
+    text_info_t *text_info = &amp;render_priv-&gt;text_info;
+    int cur_line = 0;
+    double max_asc = 0., max_desc = 0.;
+    glyph_info_t *last = NULL;
+    int i;
+    int empty_line = 1;
+    text_info-&gt;height = 0.;
+    for (i = 0; i &lt; text_info-&gt;length + 1; ++i) {
+        if ((i == text_info-&gt;length) || text_info-&gt;glyphs[i].linebreak) {
+            if (empty_line &amp;&amp; cur_line &gt; 0 &amp;&amp; last &amp;&amp; i &lt; text_info-&gt;length) {
+                max_asc = d6_to_double(last-&gt;asc) / 2.0;
+                max_desc = d6_to_double(last-&gt;desc) / 2.0;
+            }
+            text_info-&gt;lines[cur_line].asc = max_asc;
+            text_info-&gt;lines[cur_line].desc = max_desc;
+            text_info-&gt;height += max_asc + max_desc;
+            cur_line++;
+            max_asc = max_desc = 0.;
+            empty_line = 1;
+        } else
+            empty_line = 0;
+        if (i &lt; text_info-&gt;length) {
+            glyph_info_t *cur = text_info-&gt;glyphs + i;
+            if (d6_to_double(cur-&gt;asc) &gt; max_asc)
+                max_asc = d6_to_double(cur-&gt;asc);
+            if (d6_to_double(cur-&gt;desc) &gt; max_desc)
+                max_desc = d6_to_double(cur-&gt;desc);
+            if (cur-&gt;symbol != '\n' &amp;&amp; cur-&gt;symbol != 0)
+                last = cur;
+        }
+    }
+    text_info-&gt;height +=
+        (text_info-&gt;n_lines -
+         1) * render_priv-&gt;settings.line_spacing;
+}
+
+/**
+ * \brief rearrange text between lines
+ * \param max_text_width maximal text line width in pixels
+ * The algo is similar to the one in libvo/sub.c:
+ * 1. Place text, wrapping it when current line is full
+ * 2. Try moving words from the end of a line to the beginning of the next one while it reduces
+ * the difference in lengths between this two lines.
+ * The result may not be optimal, but usually is good enough.
+ */
+static void
+wrap_lines_smart(ass_renderer_t *render_priv, double max_text_width)
+{
+    int i;
+    glyph_info_t *cur, *s1, *e1, *s2, *s3, *w;
+    int last_space;
+    int break_type;
+    int exit;
+    double pen_shift_x;
+    double pen_shift_y;
+    int cur_line;
+    text_info_t *text_info = &amp;render_priv-&gt;text_info;
+
+    last_space = -1;
+    text_info-&gt;n_lines = 1;
+    break_type = 0;
+    s1 = text_info-&gt;glyphs;     // current line start
+    for (i = 0; i &lt; text_info-&gt;length; ++i) {
+        int break_at;
+        double s_offset, len;
+        cur = text_info-&gt;glyphs + i;
+        break_at = -1;
+        s_offset = d6_to_double(s1-&gt;bbox.xMin + s1-&gt;pos.x);
+        len = d6_to_double(cur-&gt;bbox.xMax + cur-&gt;pos.x) - s_offset;
+
+        if (cur-&gt;symbol == '\n') {
+            break_type = 2;
+            break_at = i;
+            ass_msg(render_priv-&gt;library, MSGL_DBG2,
+                    &quot;forced line break at %d&quot;, break_at);
+        }
+
+        if ((len &gt;= max_text_width)
+            &amp;&amp; (render_priv-&gt;track-&gt;WrapStyle != 2)) {
+            break_type = 1;
+            break_at = last_space;
+            if (break_at == -1)
+                break_at = i - 1;
+            if (break_at == -1)
+                break_at = 0;
+            ass_msg(render_priv-&gt;library, MSGL_DBG2, &quot;overfill at %d&quot;, i);
+            ass_msg(render_priv-&gt;library, MSGL_DBG2, &quot;line break at %d&quot;,
+                    break_at);
+        }
+
+        if (break_at != -1) {
+            // need to use one more line
+            // marking break_at+1 as start of a new line
+            int lead = break_at + 1;    // the first symbol of the new line
+            if (text_info-&gt;n_lines &gt;= text_info-&gt;max_lines) {
+                // Raise maximum number of lines
+                text_info-&gt;max_lines *= 2;
+                text_info-&gt;lines = realloc(text_info-&gt;lines,
+                                           sizeof(line_info_t) *
+                                           text_info-&gt;max_lines);
+            }
+            if (lead &lt; text_info-&gt;length)
+                text_info-&gt;glyphs[lead].linebreak = break_type;
+            last_space = -1;
+            s1 = text_info-&gt;glyphs + lead;
+            s_offset = d6_to_double(s1-&gt;bbox.xMin + s1-&gt;pos.x);
+            text_info-&gt;n_lines++;
+        }
+
+        if (cur-&gt;symbol == ' ')
+            last_space = i;
+
+        // make sure the hard linebreak is not forgotten when
+        // there was a new soft linebreak just inserted
+        if (cur-&gt;symbol == '\n' &amp;&amp; break_type == 1)
+            i--;
+    }
+#define DIFF(x,y) (((x) &lt; (y)) ? (y - x) : (x - y))
+    exit = 0;
+    while (!exit) {
+        exit = 1;
+        w = s3 = text_info-&gt;glyphs;
+        s1 = s2 = 0;
+        for (i = 0; i &lt;= text_info-&gt;length; ++i) {
+            cur = text_info-&gt;glyphs + i;
+            if ((i == text_info-&gt;length) || cur-&gt;linebreak) {
+                s1 = s2;
+                s2 = s3;
+                s3 = cur;
+                if (s1 &amp;&amp; (s2-&gt;linebreak == 1)) {       // have at least 2 lines, and linebreak is 'soft'
+                    double l1, l2, l1_new, l2_new;
+
+                    w = s2;
+                    do {
+                        --w;
+                    } while ((w &gt; s1) &amp;&amp; (w-&gt;symbol == ' '));
+                    while ((w &gt; s1) &amp;&amp; (w-&gt;symbol != ' ')) {
+                        --w;
+                    }
+                    e1 = w;
+                    while ((e1 &gt; s1) &amp;&amp; (e1-&gt;symbol == ' ')) {
+                        --e1;
+                    }
+                    if (w-&gt;symbol == ' ')
+                        ++w;
+
+                    l1 = d6_to_double(((s2 - 1)-&gt;bbox.xMax + (s2 - 1)-&gt;pos.x) -
+                        (s1-&gt;bbox.xMin + s1-&gt;pos.x));
+                    l2 = d6_to_double(((s3 - 1)-&gt;bbox.xMax + (s3 - 1)-&gt;pos.x) -
+                        (s2-&gt;bbox.xMin + s2-&gt;pos.x));
+                    l1_new = d6_to_double(
+                        (e1-&gt;bbox.xMax + e1-&gt;pos.x) -
+                        (s1-&gt;bbox.xMin + s1-&gt;pos.x));
+                    l2_new = d6_to_double(
+                        ((s3 - 1)-&gt;bbox.xMax + (s3 - 1)-&gt;pos.x) -
+                        (w-&gt;bbox.xMin + w-&gt;pos.x));
+
+                    if (DIFF(l1_new, l2_new) &lt; DIFF(l1, l2)) {
+                        w-&gt;linebreak = 1;
+                        s2-&gt;linebreak = 0;
+                        exit = 0;
+                    }
+                }
+            }
+            if (i == text_info-&gt;length)
+                break;
+        }
+
+    }
+    assert(text_info-&gt;n_lines &gt;= 1);
+#undef DIFF
+
+    measure_text(render_priv);
+
+    pen_shift_x = 0.;
+    pen_shift_y = 0.;
+    cur_line = 1;
+    for (i = 0; i &lt; text_info-&gt;length; ++i) {
+        cur = text_info-&gt;glyphs + i;
+        if (cur-&gt;linebreak) {
+            double height =
+                text_info-&gt;lines[cur_line - 1].desc +
+                text_info-&gt;lines[cur_line].asc;
+            cur_line++;
+            pen_shift_x = d6_to_double(-cur-&gt;pos.x);
+            pen_shift_y += height + render_priv-&gt;settings.line_spacing;
+            ass_msg(render_priv-&gt;library, MSGL_DBG2,
+                   &quot;shifting from %d to %d by (%f, %f)&quot;, i,
+                   text_info-&gt;length - 1, pen_shift_x, pen_shift_y);
+        }
+        cur-&gt;pos.x += double_to_d6(pen_shift_x);
+        cur-&gt;pos.y += double_to_d6(pen_shift_y);
+    }
+}
+
+/**
+ * \brief determine karaoke effects
+ * Karaoke effects cannot be calculated during parse stage (get_next_char()),
+ * so they are done in a separate step.
+ * Parse stage: when karaoke style override is found, its parameters are stored in the next glyph's
+ * (the first glyph of the karaoke word)'s effect_type and effect_timing.
+ * This function:
+ * 1. sets effect_type for all glyphs in the word (_karaoke_ word)
+ * 2. sets effect_timing for all glyphs to x coordinate of the border line between the left and right karaoke parts
+ * (left part is filled with PrimaryColour, right one - with SecondaryColour).
+ */
+static void process_karaoke_effects(ass_renderer_t *render_priv)
+{
+    glyph_info_t *cur, *cur2;
+    glyph_info_t *s1, *e1;      // start and end of the current word
+    glyph_info_t *s2;           // start of the next word
+    int i;
+    int timing;                 // current timing
+    int tm_start, tm_end;       // timings at start and end of the current word
+    int tm_current;
+    double dt;
+    int x;
+    int x_start, x_end;
+
+    tm_current = render_priv-&gt;time - render_priv-&gt;state.event-&gt;Start;
+    timing = 0;
+    s1 = s2 = 0;
+    for (i = 0; i &lt;= render_priv-&gt;text_info.length; ++i) {
+        cur = render_priv-&gt;text_info.glyphs + i;
+        if ((i == render_priv-&gt;text_info.length)
+            || (cur-&gt;effect_type != EF_NONE)) {
+            s1 = s2;
+            s2 = cur;
+            if (s1) {
+                e1 = s2 - 1;
+                tm_start = timing + s1-&gt;effect_skip_timing;
+                tm_end = tm_start + s1-&gt;effect_timing;
+                timing = tm_end;
+                x_start = 1000000;
+                x_end = -1000000;
+                for (cur2 = s1; cur2 &lt;= e1; ++cur2) {
+                    x_start = FFMIN(x_start, d6_to_int(cur2-&gt;bbox.xMin + cur2-&gt;pos.x));
+                    x_end = FFMAX(x_end, d6_to_int(cur2-&gt;bbox.xMax + cur2-&gt;pos.x));
+                }
+
+                dt = (tm_current - tm_start);
+                if ((s1-&gt;effect_type == EF_KARAOKE)
+                    || (s1-&gt;effect_type == EF_KARAOKE_KO)) {
+                    if (dt &gt; 0)
+                        x = x_end + 1;
+                    else
+                        x = x_start;
+                } else if (s1-&gt;effect_type == EF_KARAOKE_KF) {
+                    dt /= (tm_end - tm_start);
+                    x = x_start + (x_end - x_start) * dt;
+                } else {
+                    ass_msg(render_priv-&gt;library, MSGL_ERR,
+                            &quot;Unknown effect type&quot;);
+                    continue;
+                }
+
+                for (cur2 = s1; cur2 &lt;= e1; ++cur2) {
+                    cur2-&gt;effect_type = s1-&gt;effect_type;
+                    cur2-&gt;effect_timing = x - d6_to_int(cur2-&gt;pos.x);
+                }
+            }
+        }
+    }
+}
+
+/**
+ * \brief Calculate base point for positioning and rotation
+ * \param bbox text bbox
+ * \param alignment alignment
+ * \param bx, by out: base point coordinates
+ */
+static void get_base_point(double_bbox_t *bbox, int alignment, double *bx, double *by)
+{
+    const int halign = alignment &amp; 3;
+    const int valign = alignment &amp; 12;
+    if (bx)
+        switch (halign) {
+        case HALIGN_LEFT:
+            *bx = bbox-&gt;xMin;
+            break;
+        case HALIGN_CENTER:
+            *bx = (bbox-&gt;xMax + bbox-&gt;xMin) / 2.0;
+            break;
+        case HALIGN_RIGHT:
+            *bx = bbox-&gt;xMax;
+            break;
+        }
+    if (by)
+        switch (valign) {
+        case VALIGN_TOP:
+            *by = bbox-&gt;yMin;
+            break;
+        case VALIGN_CENTER:
+            *by = (bbox-&gt;yMax + bbox-&gt;yMin) / 2.0;
+            break;
+        case VALIGN_SUB:
+            *by = bbox-&gt;yMax;
+            break;
+        }
+}
+
+/**
+ * \brief Apply transformation to outline points of a glyph
+ * Applies rotations given by frx, fry and frz and projects the points back
+ * onto the screen plane.
+ */
+static void
+transform_3d_points(FT_Vector shift, FT_Glyph glyph, double frx,
+                    double fry, double frz, double fax, double fay,
+                    double scale)
+{
+    double sx = sin(frx);
+    double sy = sin(fry);
+    double sz = sin(frz);
+    double cx = cos(frx);
+    double cy = cos(fry);
+    double cz = cos(frz);
+    FT_Outline *outline = &amp;((FT_OutlineGlyph) glyph)-&gt;outline;
+    FT_Vector *p = outline-&gt;points;
+    double x, y, z, xx, yy, zz;
+    int i, dist;
+
+    dist = 20000 * scale;
+    for (i = 0; i &lt; outline-&gt;n_points; i++) {
+        x = (double) p[i].x + shift.x + (-fax * p[i].y);
+        y = (double) p[i].y + shift.y + (-fay * p[i].x);
+        z = 0.;
+
+        xx = x * cz + y * sz;
+        yy = -(x * sz - y * cz);
+        zz = z;
+
+        x = xx;
+        y = yy * cx + zz * sx;
+        z = yy * sx - zz * cx;
+
+        xx = x * cy + z * sy;
+        yy = y;
+        zz = x * sy - z * cy;
+
+        zz = FFMAX(zz, 1000 - dist);
+
+        x = (xx * dist) / (zz + dist);
+        y = (yy * dist) / (zz + dist);
+        p[i].x = x - shift.x + 0.5;
+        p[i].y = y - shift.y + 0.5;
+    }
+}
+
+/**
+ * \brief Apply 3d transformation to several objects
+ * \param shift FreeType vector
+ * \param glyph FreeType glyph
+ * \param glyph2 FreeType glyph
+ * \param frx x-axis rotation angle
+ * \param fry y-axis rotation angle
+ * \param frz z-axis rotation angle
+ * Rotates both glyphs by frx, fry and frz. Shift vector is added before rotation and subtracted after it.
+ */
+static void
+transform_3d(FT_Vector shift, FT_Glyph *glyph, FT_Glyph *glyph2,
+             double frx, double fry, double frz, double fax, double fay,
+             double scale)
+{
+    frx = -frx;
+    frz = -frz;
+    if (frx != 0. || fry != 0. || frz != 0. || fax != 0. || fay != 0.) {
+        if (glyph &amp;&amp; *glyph)
+            transform_3d_points(shift, *glyph, frx, fry, frz,
+                                fax, fay, scale);
+
+        if (glyph2 &amp;&amp; *glyph2)
+            transform_3d_points(shift, *glyph2, frx, fry, frz,
+                                fax, fay, scale);
+    }
+}
+
+
+/**
+ * \brief Main ass rendering function, glues everything together
+ * \param event event to render
+ * \param event_images struct containing resulting images, will also be initialized
+ * Process event, appending resulting ass_image_t's to images_root.
+ */
+static int
+ass_render_event(ass_renderer_t *render_priv, ass_event_t *event,
+                 event_images_t *event_images)
+{
+    char *p;
+    FT_UInt previous;
+    FT_UInt num_glyphs;
+    FT_Vector pen;
+    unsigned code;
+    double_bbox_t bbox;
+    int i, j;
+    int MarginL, MarginR, MarginV;
+    int last_break;
+    int alignment, halign, valign;
+    double device_x = 0;
+    double device_y = 0;
+    text_info_t *text_info = &amp;render_priv-&gt;text_info;
+    ass_drawing_t *drawing;
+
+    if (event-&gt;Style &gt;= render_priv-&gt;track-&gt;n_styles) {
+        ass_msg(render_priv-&gt;library, MSGL_WARN, &quot;No style found&quot;);
+        return 1;
+    }
+    if (!event-&gt;Text) {
+        ass_msg(render_priv-&gt;library, MSGL_WARN, &quot;Empty event&quot;);
+        return 1;
+    }
+
+    init_render_context(render_priv, event);
+
+    drawing = render_priv-&gt;state.drawing;
+    text_info-&gt;length = 0;
+    pen.x = 0;
+    pen.y = 0;
+    previous = 0;
+    num_glyphs = 0;
+    p = event-&gt;Text;
+    // Event parsing.
+    while (1) {
+        // get next char, executing style override
+        // this affects render_context
+        do {
+            code = get_next_char(render_priv, &amp;p);
+            if (render_priv-&gt;state.drawing_mode &amp;&amp; code)
+                ass_drawing_add_char(drawing, (char) code);
+        } while (code &amp;&amp; render_priv-&gt;state.drawing_mode);      // skip everything in drawing mode
+
+        // Parse drawing
+        if (drawing-&gt;i) {
+            drawing-&gt;scale_x = render_priv-&gt;state.scale_x *
+                                     render_priv-&gt;font_scale_x *
+                                     render_priv-&gt;font_scale;
+            drawing-&gt;scale_y = render_priv-&gt;state.scale_y *
+                                     render_priv-&gt;font_scale;
+            ass_drawing_hash(drawing);
+            p--;
+            code = -1;
+        }
+
+        // face could have been changed in get_next_char
+        if (!render_priv-&gt;state.font) {
+            free_render_context(render_priv);
+            return 1;
+        }
+
+        if (code == 0)
+            break;
+
+        if (text_info-&gt;length &gt;= text_info-&gt;max_glyphs) {
+            // Raise maximum number of glyphs
+            text_info-&gt;max_glyphs *= 2;
+            text_info-&gt;glyphs =
+                realloc(text_info-&gt;glyphs,
+                        sizeof(glyph_info_t) * text_info-&gt;max_glyphs);
+        }
+
+        // Add kerning to pen
+        if (previous &amp;&amp; code &amp;&amp; !drawing-&gt;hash) {
+            FT_Vector delta;
+            delta =
+                ass_font_get_kerning(render_priv-&gt;state.font, previous,
+                                     code);
+            pen.x += delta.x * render_priv-&gt;state.scale_x;
+            pen.y += delta.y * render_priv-&gt;state.scale_y;
+        }
+
+        ass_font_set_transform(render_priv-&gt;state.font,
+                               render_priv-&gt;state.scale_x *
+                               render_priv-&gt;font_scale_x,
+                               render_priv-&gt;state.scale_y, NULL);
+
+        get_outline_glyph(render_priv, code,
+                          text_info-&gt;glyphs + text_info-&gt;length, drawing);
+
+        text_info-&gt;glyphs[text_info-&gt;length].pos.x = pen.x;
+        text_info-&gt;glyphs[text_info-&gt;length].pos.y = pen.y;
+
+        pen.x += text_info-&gt;glyphs[text_info-&gt;length].advance.x;
+        pen.x += double_to_d6(render_priv-&gt;state.hspacing *
+                              render_priv-&gt;font_scale);
+        pen.y += text_info-&gt;glyphs[text_info-&gt;length].advance.y;
+        pen.y += render_priv-&gt;state.fay *
+                 text_info-&gt;glyphs[text_info-&gt;length].advance.x;
+
+        previous = code;
+
+        text_info-&gt;glyphs[text_info-&gt;length].symbol = code;
+        text_info-&gt;glyphs[text_info-&gt;length].linebreak = 0;
+        for (i = 0; i &lt; 4; ++i) {
+            uint32_t clr = render_priv-&gt;state.c[i];
+            change_alpha(&amp;clr,
+                         mult_alpha(_a(clr), render_priv-&gt;state.fade), 1.);
+            text_info-&gt;glyphs[text_info-&gt;length].c[i] = clr;
+        }
+        text_info-&gt;glyphs[text_info-&gt;length].effect_type =
+            render_priv-&gt;state.effect_type;
+        text_info-&gt;glyphs[text_info-&gt;length].effect_timing =
+            render_priv-&gt;state.effect_timing;
+        text_info-&gt;glyphs[text_info-&gt;length].effect_skip_timing =
+            render_priv-&gt;state.effect_skip_timing;
+        text_info-&gt;glyphs[text_info-&gt;length].be = render_priv-&gt;state.be;
+        text_info-&gt;glyphs[text_info-&gt;length].blur = render_priv-&gt;state.blur;
+        text_info-&gt;glyphs[text_info-&gt;length].shadow_x =
+            render_priv-&gt;state.shadow_x;
+        text_info-&gt;glyphs[text_info-&gt;length].shadow_y =
+            render_priv-&gt;state.shadow_y;
+        text_info-&gt;glyphs[text_info-&gt;length].frx = render_priv-&gt;state.frx;
+        text_info-&gt;glyphs[text_info-&gt;length].fry = render_priv-&gt;state.fry;
+        text_info-&gt;glyphs[text_info-&gt;length].frz = render_priv-&gt;state.frz;
+        text_info-&gt;glyphs[text_info-&gt;length].fax = render_priv-&gt;state.fax;
+        text_info-&gt;glyphs[text_info-&gt;length].fay = render_priv-&gt;state.fay;
+        if (drawing-&gt;hash) {
+            text_info-&gt;glyphs[text_info-&gt;length].asc = drawing-&gt;asc;
+            text_info-&gt;glyphs[text_info-&gt;length].desc = drawing-&gt;desc;
+        } else {
+            ass_font_get_asc_desc(render_priv-&gt;state.font, code,
+                                  &amp;text_info-&gt;glyphs[text_info-&gt;length].asc,
+                                  &amp;text_info-&gt;glyphs[text_info-&gt;length].desc);
+
+            text_info-&gt;glyphs[text_info-&gt;length].asc *=
+                render_priv-&gt;state.scale_y;
+            text_info-&gt;glyphs[text_info-&gt;length].desc *=
+                render_priv-&gt;state.scale_y;
+        }
+
+        // fill bitmap_hash_key
+        if (!drawing-&gt;hash) {
+            text_info-&gt;glyphs[text_info-&gt;length].hash_key.font =
+                render_priv-&gt;state.font;
+            text_info-&gt;glyphs[text_info-&gt;length].hash_key.size =
+                render_priv-&gt;state.font_size;
+            text_info-&gt;glyphs[text_info-&gt;length].hash_key.bold =
+                render_priv-&gt;state.bold;
+            text_info-&gt;glyphs[text_info-&gt;length].hash_key.italic =
+                render_priv-&gt;state.italic;
+        } else
+            text_info-&gt;glyphs[text_info-&gt;length].hash_key.drawing_hash =
+                drawing-&gt;hash;
+        text_info-&gt;glyphs[text_info-&gt;length].hash_key.ch = code;
+        text_info-&gt;glyphs[text_info-&gt;length].hash_key.outline.x =
+            render_priv-&gt;state.border_x * 0xFFFF;
+        text_info-&gt;glyphs[text_info-&gt;length].hash_key.outline.y =
+            render_priv-&gt;state.border_y * 0xFFFF;
+        text_info-&gt;glyphs[text_info-&gt;length].hash_key.scale_x =
+            render_priv-&gt;state.scale_x * 0xFFFF;
+        text_info-&gt;glyphs[text_info-&gt;length].hash_key.scale_y =
+            render_priv-&gt;state.scale_y * 0xFFFF;
+        text_info-&gt;glyphs[text_info-&gt;length].hash_key.frx =
+            render_priv-&gt;state.frx * 0xFFFF;
+        text_info-&gt;glyphs[text_info-&gt;length].hash_key.fry =
+            render_priv-&gt;state.fry * 0xFFFF;
+        text_info-&gt;glyphs[text_info-&gt;length].hash_key.frz =
+            render_priv-&gt;state.frz * 0xFFFF;
+        text_info-&gt;glyphs[text_info-&gt;length].hash_key.fax =
+            render_priv-&gt;state.fax * 0xFFFF;
+        text_info-&gt;glyphs[text_info-&gt;length].hash_key.fay =
+            render_priv-&gt;state.fay * 0xFFFF;
+        text_info-&gt;glyphs[text_info-&gt;length].hash_key.advance.x = pen.x;
+        text_info-&gt;glyphs[text_info-&gt;length].hash_key.advance.y = pen.y;
+        text_info-&gt;glyphs[text_info-&gt;length].hash_key.be =
+            render_priv-&gt;state.be;
+        text_info-&gt;glyphs[text_info-&gt;length].hash_key.blur =
+            render_priv-&gt;state.blur;
+        text_info-&gt;glyphs[text_info-&gt;length].hash_key.shadow_offset.x =
+            double_to_d6(
+                render_priv-&gt;state.shadow_x * render_priv-&gt;border_scale -
+                (int) (render_priv-&gt;state.shadow_x *
+                render_priv-&gt;border_scale));
+        text_info-&gt;glyphs[text_info-&gt;length].hash_key.shadow_offset.y =
+            double_to_d6(
+                render_priv-&gt;state.shadow_y * render_priv-&gt;border_scale -
+                (int) (render_priv-&gt;state.shadow_y *
+                render_priv-&gt;border_scale));
+
+        text_info-&gt;length++;
+
+        render_priv-&gt;state.effect_type = EF_NONE;
+        render_priv-&gt;state.effect_timing = 0;
+        render_priv-&gt;state.effect_skip_timing = 0;
+
+        if (drawing-&gt;hash) {
+            ass_drawing_free(drawing);
+            drawing = render_priv-&gt;state.drawing =
+                ass_drawing_new(render_priv-&gt;fontconfig_priv,
+                    render_priv-&gt;state.font,
+                    render_priv-&gt;settings.hinting,
+                    render_priv-&gt;ftlibrary);
+        }
+    }
+
+
+    if (text_info-&gt;length == 0) {
+        // no valid symbols in the event; this can be smth like {comment}
+        free_render_context(render_priv);
+        return 1;
+    }
+    // depends on glyph x coordinates being monotonous, so it should be done before line wrap
+    process_karaoke_effects(render_priv);
+
+    // alignments
+    alignment = render_priv-&gt;state.alignment;
+    halign = alignment &amp; 3;
+    valign = alignment &amp; 12;
+
+    MarginL =
+        (event-&gt;MarginL) ? event-&gt;MarginL : render_priv-&gt;state.style-&gt;
+        MarginL;
+    MarginR =
+        (event-&gt;MarginR) ? event-&gt;MarginR : render_priv-&gt;state.style-&gt;
+        MarginR;
+    MarginV =
+        (event-&gt;MarginV) ? event-&gt;MarginV : render_priv-&gt;state.style-&gt;
+        MarginV;
+
+    if (render_priv-&gt;state.evt_type != EVENT_HSCROLL) {
+        double max_text_width;
+
+        // calculate max length of a line
+        max_text_width =
+            x2scr(render_priv,
+                  render_priv-&gt;track-&gt;PlayResX - MarginR) -
+            x2scr(render_priv, MarginL);
+
+        // rearrange text in several lines
+        wrap_lines_smart(render_priv, max_text_width);
+
+        // align text
+        last_break = -1;
+        for (i = 1; i &lt; text_info-&gt;length + 1; ++i) {   // (text_info-&gt;length + 1) is the end of the last line
+            if ((i == text_info-&gt;length)
+                || text_info-&gt;glyphs[i].linebreak) {
+                double width, shift = 0;
+                glyph_info_t *first_glyph =
+                    text_info-&gt;glyphs + last_break + 1;
+                glyph_info_t *last_glyph = text_info-&gt;glyphs + i - 1;
+
+                while ((last_glyph &gt; first_glyph)
+                       &amp;&amp; ((last_glyph-&gt;symbol == '\n')
+                           || (last_glyph-&gt;symbol == 0)))
+                    last_glyph--;
+
+                width = d6_to_double(
+                    last_glyph-&gt;pos.x + last_glyph-&gt;advance.x -
+                    first_glyph-&gt;pos.x);
+                if (halign == HALIGN_LEFT) {    // left aligned, no action
+                    shift = 0;
+                } else if (halign == HALIGN_RIGHT) {    // right aligned
+                    shift = max_text_width - width;
+                } else if (halign == HALIGN_CENTER) {   // centered
+                    shift = (max_text_width - width) / 2.0;
+                }
+                for (j = last_break + 1; j &lt; i; ++j) {
+                    text_info-&gt;glyphs[j].pos.x += double_to_d6(shift);
+                }
+                last_break = i - 1;
+            }
+        }
+    } else {                    // render_priv-&gt;state.evt_type == EVENT_HSCROLL
+        measure_text(render_priv);
+    }
+
+    // determing text bounding box
+    compute_string_bbox(text_info, &amp;bbox);
+
+    // determine device coordinates for text
+
+    // x coordinate for everything except positioned events
+    if (render_priv-&gt;state.evt_type == EVENT_NORMAL ||
+        render_priv-&gt;state.evt_type == EVENT_VSCROLL) {
+        device_x = x2scr(render_priv, MarginL);
+    } else if (render_priv-&gt;state.evt_type == EVENT_HSCROLL) {
+        if (render_priv-&gt;state.scroll_direction == SCROLL_RL)
+            device_x =
+                x2scr(render_priv,
+                      render_priv-&gt;track-&gt;PlayResX -
+                      render_priv-&gt;state.scroll_shift);
+        else if (render_priv-&gt;state.scroll_direction == SCROLL_LR)
+            device_x =
+                x2scr(render_priv,
+                      render_priv-&gt;state.scroll_shift) - (bbox.xMax -
+                                                          bbox.xMin);
+    }
+    // y coordinate for everything except positioned events
+    if (render_priv-&gt;state.evt_type == EVENT_NORMAL ||
+        render_priv-&gt;state.evt_type == EVENT_HSCROLL) {
+        if (valign == VALIGN_TOP) {     // toptitle
+            device_y =
+                y2scr_top(render_priv,
+                          MarginV) + text_info-&gt;lines[0].asc;
+        } else if (valign == VALIGN_CENTER) {   // midtitle
+            double scr_y =
+                y2scr(render_priv, render_priv-&gt;track-&gt;PlayResY / 2.0);
+            device_y = scr_y - (bbox.yMax + bbox.yMin) / 2.0;
+        } else {                // subtitle
+            double scr_y;
+            if (valign != VALIGN_SUB)
+                ass_msg(render_priv-&gt;library, MSGL_V,
+                       &quot;Invalid valign, supposing 0 (subtitle)&quot;);
+            scr_y =
+                y2scr_sub(render_priv,
+                          render_priv-&gt;track-&gt;PlayResY - MarginV);
+            device_y = scr_y;
+            device_y -= text_info-&gt;height;
+            device_y += text_info-&gt;lines[0].asc;
+        }
+    } else if (render_priv-&gt;state.evt_type == EVENT_VSCROLL) {
+        if (render_priv-&gt;state.scroll_direction == SCROLL_TB)
+            device_y =
+                y2scr(render_priv,
+                      render_priv-&gt;state.clip_y0 +
+                      render_priv-&gt;state.scroll_shift) - (bbox.yMax -
+                                                          bbox.yMin);
+        else if (render_priv-&gt;state.scroll_direction == SCROLL_BT)
+            device_y =
+                y2scr(render_priv,
+                      render_priv-&gt;state.clip_y1 -
+                      render_priv-&gt;state.scroll_shift);
+    }
+    // positioned events are totally different
+    if (render_priv-&gt;state.evt_type == EVENT_POSITIONED) {
+        double base_x = 0;
+        double base_y = 0;
+        ass_msg(render_priv-&gt;library, MSGL_DBG2, &quot;positioned event at %f, %f&quot;,
+               render_priv-&gt;state.pos_x, render_priv-&gt;state.pos_y);
+        get_base_point(&amp;bbox, alignment, &amp;base_x, &amp;base_y);
+        device_x =
+            x2scr_pos(render_priv, render_priv-&gt;state.pos_x) - base_x;
+        device_y =
+            y2scr_pos(render_priv, render_priv-&gt;state.pos_y) - base_y;
+    }
+    // fix clip coordinates (they depend on alignment)
+    if (render_priv-&gt;state.evt_type == EVENT_NORMAL ||
+        render_priv-&gt;state.evt_type == EVENT_HSCROLL ||
+        render_priv-&gt;state.evt_type == EVENT_VSCROLL) {
+        render_priv-&gt;state.clip_x0 =
+            x2scr(render_priv, render_priv-&gt;state.clip_x0);
+        render_priv-&gt;state.clip_x1 =
+            x2scr(render_priv, render_priv-&gt;state.clip_x1);
+        if (valign == VALIGN_TOP) {
+            render_priv-&gt;state.clip_y0 =
+                y2scr_top(render_priv, render_priv-&gt;state.clip_y0);
+            render_priv-&gt;state.clip_y1 =
+                y2scr_top(render_priv, render_priv-&gt;state.clip_y1);
+        } else if (valign == VALIGN_CENTER) {
+            render_priv-&gt;state.clip_y0 =
+                y2scr(render_priv, render_priv-&gt;state.clip_y0);
+            render_priv-&gt;state.clip_y1 =
+                y2scr(render_priv, render_priv-&gt;state.clip_y1);
+        } else if (valign == VALIGN_SUB) {
+            render_priv-&gt;state.clip_y0 =
+                y2scr_sub(render_priv, render_priv-&gt;state.clip_y0);
+            render_priv-&gt;state.clip_y1 =
+                y2scr_sub(render_priv, render_priv-&gt;state.clip_y1);
+        }
+    } else if (render_priv-&gt;state.evt_type == EVENT_POSITIONED) {
+        render_priv-&gt;state.clip_x0 =
+            x2scr_pos(render_priv, render_priv-&gt;state.clip_x0);
+        render_priv-&gt;state.clip_x1 =
+            x2scr_pos(render_priv, render_priv-&gt;state.clip_x1);
+        render_priv-&gt;state.clip_y0 =
+            y2scr_pos(render_priv, render_priv-&gt;state.clip_y0);
+        render_priv-&gt;state.clip_y1 =
+            y2scr_pos(render_priv, render_priv-&gt;state.clip_y1);
+    }
+    // calculate rotation parameters
+    {
+        double_vector_t center;
+
+        if (render_priv-&gt;state.have_origin) {
+            center.x = x2scr(render_priv, render_priv-&gt;state.org_x);
+            center.y = y2scr(render_priv, render_priv-&gt;state.org_y);
+        } else {
+            double bx = 0., by = 0.;
+            get_base_point(&amp;bbox, alignment, &amp;bx, &amp;by);
+            center.x = device_x + bx;
+            center.y = device_y + by;
+        }
+
+        for (i = 0; i &lt; text_info-&gt;length; ++i) {
+            glyph_info_t *info = text_info-&gt;glyphs + i;
+
+            if (info-&gt;hash_key.frx || info-&gt;hash_key.fry
+                || info-&gt;hash_key.frz || info-&gt;hash_key.fax
+                || info-&gt;hash_key.fay) {
+                info-&gt;hash_key.shift_x = info-&gt;pos.x + double_to_d6(device_x - center.x);
+                info-&gt;hash_key.shift_y =
+                    -(info-&gt;pos.y + double_to_d6(device_y - center.y));
+            } else {
+                info-&gt;hash_key.shift_x = 0;
+                info-&gt;hash_key.shift_y = 0;
+            }
+        }
+    }
+
+    // convert glyphs to bitmaps
+    for (i = 0; i &lt; text_info-&gt;length; ++i) {
+        glyph_info_t *g = text_info-&gt;glyphs + i;
+        g-&gt;hash_key.advance.x =
+            double_to_d6(device_x - (int) device_x +
+            d6_to_double(g-&gt;pos.x &amp; SUBPIXEL_MASK)) &amp; ~SUBPIXEL_ACCURACY;
+        g-&gt;hash_key.advance.y =
+            double_to_d6(device_y - (int) device_y +
+            d6_to_double(g-&gt;pos.y &amp; SUBPIXEL_MASK)) &amp; ~SUBPIXEL_ACCURACY;
+        get_bitmap_glyph(render_priv, text_info-&gt;glyphs + i);
+    }
+
+    memset(event_images, 0, sizeof(*event_images));
+    event_images-&gt;top = device_y - text_info-&gt;lines[0].asc;
+    event_images-&gt;height = text_info-&gt;height;
+    event_images-&gt;detect_collisions = render_priv-&gt;state.detect_collisions;
+    event_images-&gt;shift_direction = (valign == VALIGN_TOP) ? 1 : -1;
+    event_images-&gt;event = event;
+    event_images-&gt;imgs = render_text(render_priv, (int) device_x, (int) device_y);
+
+    free_render_context(render_priv);
+
+    return 0;
+}
+
+/**
+ * \brief deallocate image list
+ * \param img list pointer
+ */
+static void ass_free_images(ass_image_t *img)
+{
+    while (img) {
+        ass_image_t *next = img-&gt;next;
+        free(img);
+        img = next;
+    }
+}
+
+static void ass_reconfigure(ass_renderer_t *priv)
+{
+    priv-&gt;render_id++;
+    priv-&gt;cache.glyph_cache =
+        ass_glyph_cache_reset(priv-&gt;cache.glyph_cache);
+    priv-&gt;cache.bitmap_cache =
+        ass_bitmap_cache_reset(priv-&gt;cache.bitmap_cache);
+    priv-&gt;cache.composite_cache =
+        ass_composite_cache_reset(priv-&gt;cache.composite_cache);
+    ass_free_images(priv-&gt;prev_images_root);
+    priv-&gt;prev_images_root = 0;
+}
+
+void ass_set_frame_size(ass_renderer_t *priv, int w, int h)
+{
+    if (priv-&gt;settings.frame_width != w || priv-&gt;settings.frame_height != h) {
+        priv-&gt;settings.frame_width = w;
+        priv-&gt;settings.frame_height = h;
+        if (priv-&gt;settings.aspect == 0.) {
+            priv-&gt;settings.aspect = ((double) w) / h;
+            priv-&gt;settings.pixel_ratio = ((double) w) / h;
+        }
+        ass_reconfigure(priv);
+    }
+}
+
+void ass_set_margins(ass_renderer_t *priv, int t, int b, int l, int r)
+{
+    if (priv-&gt;settings.left_margin != l ||
+        priv-&gt;settings.right_margin != r ||
+        priv-&gt;settings.top_margin != t
+        || priv-&gt;settings.bottom_margin != b) {
+        priv-&gt;settings.left_margin = l;
+        priv-&gt;settings.right_margin = r;
+        priv-&gt;settings.top_margin = t;
+        priv-&gt;settings.bottom_margin = b;
+        ass_reconfigure(priv);
+    }
+}
+
+void ass_set_use_margins(ass_renderer_t *priv, int use)
+{
+    priv-&gt;settings.use_margins = use;
+}
+
+void ass_set_aspect_ratio(ass_renderer_t *priv, double ar, double par)
+{
+    if (priv-&gt;settings.aspect != ar || priv-&gt;settings.pixel_ratio != par) {
+        priv-&gt;settings.aspect = ar;
+        priv-&gt;settings.pixel_ratio = par;
+        ass_reconfigure(priv);
+    }
+}
+
+void ass_set_font_scale(ass_renderer_t *priv, double font_scale)
+{
+    if (priv-&gt;settings.font_size_coeff != font_scale) {
+        priv-&gt;settings.font_size_coeff = font_scale;
+        ass_reconfigure(priv);
+    }
+}
+
+void ass_set_hinting(ass_renderer_t *priv, ass_hinting_t ht)
+{
+    if (priv-&gt;settings.hinting != ht) {
+        priv-&gt;settings.hinting = ht;
+        ass_reconfigure(priv);
+    }
+}
+
+void ass_set_line_spacing(ass_renderer_t *priv, double line_spacing)
+{
+    priv-&gt;settings.line_spacing = line_spacing;
+}
+
+void ass_set_fonts(ass_renderer_t *priv, const char *default_font,
+                   const char *default_family, int fc, const char *config,
+                   int update)
+{
+    free(priv-&gt;settings.default_font);
+    free(priv-&gt;settings.default_family);
+    priv-&gt;settings.default_font = default_font ? strdup(default_font) : 0;
+    priv-&gt;settings.default_family =
+        default_family ? strdup(default_family) : 0;
+
+    if (priv-&gt;fontconfig_priv)
+        fontconfig_done(priv-&gt;fontconfig_priv);
+    priv-&gt;fontconfig_priv =
+        fontconfig_init(priv-&gt;library, priv-&gt;ftlibrary, default_family,
+                        default_font, fc, config, update);
+}
+
+int ass_fonts_update(ass_renderer_t *render_priv)
+{
+    return fontconfig_update(render_priv-&gt;fontconfig_priv);
+}
+
+/**
+ * \brief Start a new frame
+ */
+static int
+ass_start_frame(ass_renderer_t *render_priv, ass_track_t *track,
+                long long now)
+{
+    ass_settings_t *settings_priv = &amp;render_priv-&gt;settings;
+    cache_store_t *cache = &amp;render_priv-&gt;cache;
+
+    if (!render_priv-&gt;settings.frame_width
+        &amp;&amp; !render_priv-&gt;settings.frame_height)
+        return 1;               // library not initialized
+
+    if (render_priv-&gt;library != track-&gt;library)
+        return 1;
+
+    free_list_clear(render_priv);
+
+    if (track-&gt;n_events == 0)
+        return 1;               // nothing to do
+
+    render_priv-&gt;width = settings_priv-&gt;frame_width;
+    render_priv-&gt;height = settings_priv-&gt;frame_height;
+    render_priv-&gt;orig_width =
+        settings_priv-&gt;frame_width - settings_priv-&gt;left_margin -
+        settings_priv-&gt;right_margin;
+    render_priv-&gt;orig_height =
+        settings_priv-&gt;frame_height - settings_priv-&gt;top_margin -
+        settings_priv-&gt;bottom_margin;
+    render_priv-&gt;orig_width_nocrop =
+        settings_priv-&gt;frame_width - FFMAX(settings_priv-&gt;left_margin,
+                                           0) -
+        FFMAX(settings_priv-&gt;right_margin, 0);
+    render_priv-&gt;orig_height_nocrop =
+        settings_priv-&gt;frame_height - FFMAX(settings_priv-&gt;top_margin,
+                                            0) -
+        FFMAX(settings_priv-&gt;bottom_margin, 0);
+    render_priv-&gt;track = track;
+    render_priv-&gt;time = now;
+
+    ass_lazy_track_init(render_priv);
+
+    render_priv-&gt;font_scale = settings_priv-&gt;font_size_coeff *
+        render_priv-&gt;orig_height / render_priv-&gt;track-&gt;PlayResY;
+    if (render_priv-&gt;track-&gt;ScaledBorderAndShadow)
+        render_priv-&gt;border_scale =
+            ((double) render_priv-&gt;orig_height) /
+            render_priv-&gt;track-&gt;PlayResY;
+    else
+        render_priv-&gt;border_scale = 1.;
+
+    // PAR correction
+    render_priv-&gt;font_scale_x = render_priv-&gt;settings.aspect /
+                                render_priv-&gt;settings.pixel_ratio;
+
+    render_priv-&gt;prev_images_root = render_priv-&gt;images_root;
+    render_priv-&gt;images_root = 0;
+
+    if (cache-&gt;bitmap_cache-&gt;cache_size &gt; cache-&gt;bitmap_max_size) {
+        ass_msg(render_priv-&gt;library, MSGL_V,
+                &quot;Hitting hard bitmap cache limit (was: %ld bytes), &quot;
+                &quot;resetting.&quot;, (long) cache-&gt;bitmap_cache-&gt;cache_size);
+        cache-&gt;bitmap_cache = ass_bitmap_cache_reset(cache-&gt;bitmap_cache);
+        cache-&gt;composite_cache = ass_composite_cache_reset(
+            cache-&gt;composite_cache);
+        ass_free_images(render_priv-&gt;prev_images_root);
+        render_priv-&gt;prev_images_root = 0;
+    }
+
+    if (cache-&gt;glyph_cache-&gt;count &gt; cache-&gt;glyph_max) {
+        ass_msg(render_priv-&gt;library, MSGL_V,
+            &quot;Hitting hard glyph cache limit (was: %ld glyphs), resetting.&quot;,
+            (long) cache-&gt;glyph_cache-&gt;count);
+        cache-&gt;glyph_cache = ass_glyph_cache_reset(cache-&gt;glyph_cache);
+    }
+
+    return 0;
+}
+
+static int cmp_event_layer(const void *p1, const void *p2)
+{
+    ass_event_t *e1 = ((event_images_t *) p1)-&gt;event;
+    ass_event_t *e2 = ((event_images_t *) p2)-&gt;event;
+    if (e1-&gt;Layer &lt; e2-&gt;Layer)
+        return -1;
+    if (e1-&gt;Layer &gt; e2-&gt;Layer)
+        return 1;
+    if (e1-&gt;ReadOrder &lt; e2-&gt;ReadOrder)
+        return -1;
+    if (e1-&gt;ReadOrder &gt; e2-&gt;ReadOrder)
+        return 1;
+    return 0;
+}
+
+#define MAX_EVENTS 100
+
+static render_priv_t *get_render_priv(ass_renderer_t *render_priv,
+                                      ass_event_t *event)
+{
+    if (!event-&gt;render_priv)
+        event-&gt;render_priv = calloc(1, sizeof(render_priv_t));
+    // FIXME: check render_id
+    if (render_priv-&gt;render_id != event-&gt;render_priv-&gt;render_id) {
+        memset(event-&gt;render_priv, 0, sizeof(render_priv_t));
+        event-&gt;render_priv-&gt;render_id = render_priv-&gt;render_id;
+    }
+    return event-&gt;render_priv;
+}
+
+typedef struct {
+    int a, b;                   // top and height
+} segment_t;
+
+static int overlap(segment_t *s1, segment_t *s2)
+{
+    if (s1-&gt;a &gt;= s2-&gt;b || s2-&gt;a &gt;= s1-&gt;b)
+        return 0;
+    return 1;
+}
+
+static int cmp_segment(const void *p1, const void *p2)
+{
+    return ((segment_t *) p1)-&gt;a - ((segment_t *) p2)-&gt;a;
+}
+
+static void
+shift_event(ass_renderer_t *render_priv, event_images_t *ei, int shift)
+{
+    ass_image_t *cur = ei-&gt;imgs;
+    while (cur) {
+        cur-&gt;dst_y += shift;
+        // clip top and bottom
+        if (cur-&gt;dst_y &lt; 0) {
+            int clip = -cur-&gt;dst_y;
+            cur-&gt;h -= clip;
+            cur-&gt;bitmap += clip * cur-&gt;stride;
+            cur-&gt;dst_y = 0;
+        }
+        if (cur-&gt;dst_y + cur-&gt;h &gt;= render_priv-&gt;height) {
+            int clip = cur-&gt;dst_y + cur-&gt;h - render_priv-&gt;height;
+            cur-&gt;h -= clip;
+        }
+        if (cur-&gt;h &lt;= 0) {
+            cur-&gt;h = 0;
+            cur-&gt;dst_y = 0;
+        }
+        cur = cur-&gt;next;
+    }
+    ei-&gt;top += shift;
+}
+
+// dir: 1 - move down
+//      -1 - move up
+static int fit_segment(segment_t *s, segment_t *fixed, int *cnt, int dir)
+{
+    int i;
+    int shift = 0;
+
+    if (dir == 1)               // move down
+        for (i = 0; i &lt; *cnt; ++i) {
+            if (s-&gt;b + shift &lt;= fixed[i].a || s-&gt;a + shift &gt;= fixed[i].b)
+                continue;
+            shift = fixed[i].b - s-&gt;a;
+    } else                      // dir == -1, move up
+        for (i = *cnt - 1; i &gt;= 0; --i) {
+            if (s-&gt;b + shift &lt;= fixed[i].a || s-&gt;a + shift &gt;= fixed[i].b)
+                continue;
+            shift = fixed[i].a - s-&gt;b;
+        }
+
+    fixed[*cnt].a = s-&gt;a + shift;
+    fixed[*cnt].b = s-&gt;b + shift;
+    (*cnt)++;
+    qsort(fixed, *cnt, sizeof(segment_t), cmp_segment);
+
+    return shift;
+}
+
+static void
+fix_collisions(ass_renderer_t *render_priv, event_images_t *imgs, int cnt)
+{
+    segment_t used[MAX_EVENTS];
+    int cnt_used = 0;
+    int i, j;
+
+    // fill used[] with fixed events
+    for (i = 0; i &lt; cnt; ++i) {
+        render_priv_t *priv;
+        if (!imgs[i].detect_collisions)
+            continue;
+        priv = get_render_priv(render_priv, imgs[i].event);
+        if (priv-&gt;height &gt; 0) { // it's a fixed event
+            segment_t s;
+            s.a = priv-&gt;top;
+            s.b = priv-&gt;top + priv-&gt;height;
+            if (priv-&gt;height != imgs[i].height) {       // no, it's not
+                ass_msg(render_priv-&gt;library, MSGL_WARN,
+                        &quot;Warning! Event height has changed&quot;);
+                priv-&gt;top = 0;
+                priv-&gt;height = 0;
+            }
+            for (j = 0; j &lt; cnt_used; ++j)
+                if (overlap(&amp;s, used + j)) {    // no, it's not
+                    priv-&gt;top = 0;
+                    priv-&gt;height = 0;
+                }
+            if (priv-&gt;height &gt; 0) {     // still a fixed event
+                used[cnt_used].a = priv-&gt;top;
+                used[cnt_used].b = priv-&gt;top + priv-&gt;height;
+                cnt_used++;
+                shift_event(render_priv, imgs + i, priv-&gt;top - imgs[i].top);
+            }
+        }
+    }
+    qsort(used, cnt_used, sizeof(segment_t), cmp_segment);
+
+    // try to fit other events in free spaces
+    for (i = 0; i &lt; cnt; ++i) {
+        render_priv_t *priv;
+        if (!imgs[i].detect_collisions)
+            continue;
+        priv = get_render_priv(render_priv, imgs[i].event);
+        if (priv-&gt;height == 0) {        // not a fixed event
+            int shift;
+            segment_t s;
+            s.a = imgs[i].top;
+            s.b = imgs[i].top + imgs[i].height;
+            shift =
+                fit_segment(&amp;s, used, &amp;cnt_used, imgs[i].shift_direction);
+            if (shift)
+                shift_event(render_priv, imgs + i, shift);
+            // make it fixed
+            priv-&gt;top = imgs[i].top;
+            priv-&gt;height = imgs[i].height;
+        }
+
+    }
+}
+
+/**
+ * \brief compare two images
+ * \param i1 first image
+ * \param i2 second image
+ * \return 0 if identical, 1 if different positions, 2 if different content
+ */
+static int ass_image_compare(ass_image_t *i1, ass_image_t *i2)
+{
+    if (i1-&gt;w != i2-&gt;w)
+        return 2;
+    if (i1-&gt;h != i2-&gt;h)
+        return 2;
+    if (i1-&gt;stride != i2-&gt;stride)
+        return 2;
+    if (i1-&gt;color != i2-&gt;color)
+        return 2;
+    if (i1-&gt;bitmap != i2-&gt;bitmap)
+        return 2;
+    if (i1-&gt;dst_x != i2-&gt;dst_x)
+        return 1;
+    if (i1-&gt;dst_y != i2-&gt;dst_y)
+        return 1;
+    return 0;
+}
+
+/**
+ * \brief compare current and previous image list
+ * \param priv library handle
+ * \return 0 if identical, 1 if different positions, 2 if different content
+ */
+static int ass_detect_change(ass_renderer_t *priv)
+{
+    ass_image_t *img, *img2;
+    int diff;
+
+    img = priv-&gt;prev_images_root;
+    img2 = priv-&gt;images_root;
+    diff = 0;
+    while (img &amp;&amp; diff &lt; 2) {
+        ass_image_t *next, *next2;
+        next = img-&gt;next;
+        if (img2) {
+            int d = ass_image_compare(img, img2);
+            if (d &gt; diff)
+                diff = d;
+            next2 = img2-&gt;next;
+        } else {
+            // previous list is shorter
+            diff = 2;
+            break;
+        }
+        img = next;
+        img2 = next2;
+    }
+
+    // is the previous list longer?
+    if (img2)
+        diff = 2;
+
+    return diff;
+}
+
+/**
+ * \brief render a frame
+ * \param priv library handle
+ * \param track track
+ * \param now current video timestamp (ms)
+ * \param detect_change a value describing how the new images differ from the previous ones will be written here:
+ *        0 if identical, 1 if different positions, 2 if different content.
+ *        Can be NULL, in that case no detection is performed.
+ */
+ass_image_t *ass_render_frame(ass_renderer_t *priv, ass_track_t *track,
+                              long long now, int *detect_change)
+{
+    int i, cnt, rc;
+    event_images_t *last;
+    ass_image_t **tail;
+
+    // init frame
+    rc = ass_start_frame(priv, track, now);
+    if (rc != 0)
+        return 0;
+
+    // render events separately
+    cnt = 0;
+    for (i = 0; i &lt; track-&gt;n_events; ++i) {
+        ass_event_t *event = track-&gt;events + i;
+        if ((event-&gt;Start &lt;= now)
+            &amp;&amp; (now &lt; (event-&gt;Start + event-&gt;Duration))) {
+            if (cnt &gt;= priv-&gt;eimg_size) {
+                priv-&gt;eimg_size += 100;
+                priv-&gt;eimg =
+                    realloc(priv-&gt;eimg,
+                            priv-&gt;eimg_size * sizeof(event_images_t));
+            }
+            rc = ass_render_event(priv, event, priv-&gt;eimg + cnt);
+            if (!rc)
+                ++cnt;
+        }
+    }
+
+    // sort by layer
+    qsort(priv-&gt;eimg, cnt, sizeof(event_images_t), cmp_event_layer);
+
+    // call fix_collisions for each group of events with the same layer
+    last = priv-&gt;eimg;
+    for (i = 1; i &lt; cnt; ++i)
+        if (last-&gt;event-&gt;Layer != priv-&gt;eimg[i].event-&gt;Layer) {
+            fix_collisions(priv, last, priv-&gt;eimg + i - last);
+            last = priv-&gt;eimg + i;
+        }
+    if (cnt &gt; 0)
+        fix_collisions(priv, last, priv-&gt;eimg + cnt - last);
+
+    // concat lists
+    tail = &amp;priv-&gt;images_root;
+    for (i = 0; i &lt; cnt; ++i) {
+        ass_image_t *cur = priv-&gt;eimg[i].imgs;
+        while (cur) {
+            *tail = cur;
+            tail = &amp;cur-&gt;next;
+            cur = cur-&gt;next;
+        }
+    }
+
+    if (detect_change)
+        *detect_change = ass_detect_change(priv);
+
+    // free the previous image list
+    ass_free_images(priv-&gt;prev_images_root);
+    priv-&gt;prev_images_root = 0;
+
+    return priv-&gt;images_root;
+}

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_types.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_types.h	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_types.h	2009-08-01 07:55:22 UTC (rev 5185)
@@ -0,0 +1,125 @@
+/*
+ * Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+ *
+ * This file is part of libass.
+ *
+ * libass is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libass is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with libass; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef LIBASS_TYPES_H
+#define LIBASS_TYPES_H
+
+#include &lt;stdint.h&gt;
+
+#define VALIGN_SUB 0
+#define VALIGN_CENTER 8
+#define VALIGN_TOP 4
+#define HALIGN_LEFT 1
+#define HALIGN_CENTER 2
+#define HALIGN_RIGHT 3
+
+/* Opaque objects internally used by libass.  Contents are private. */
+typedef struct ass_renderer ass_renderer_t;
+typedef struct render_priv render_priv_t;
+typedef struct parser_priv parser_priv_t;
+typedef struct ass_library ass_library_t;
+
+/* ASS Style: line */
+typedef struct ass_style {
+    char *Name;
+    char *FontName;
+    double FontSize;
+    uint32_t PrimaryColour;
+    uint32_t SecondaryColour;
+    uint32_t OutlineColour;
+    uint32_t BackColour;
+    int Bold;
+    int Italic;
+    int Underline;
+    int StrikeOut;
+    double ScaleX;
+    double ScaleY;
+    double Spacing;
+    int Angle;
+    int BorderStyle;
+    double Outline;
+    double Shadow;
+    int Alignment;
+    int MarginL;
+    int MarginR;
+    int MarginV;
+    int Encoding;
+    int treat_fontname_as_pattern;
+} ass_style_t;
+
+/*
+ * ass_event_t corresponds to a single Dialogue line;
+ * text is stored as-is, style overrides will be parsed later.
+ */
+typedef struct ass_event {
+    long long Start;            // ms
+    long long Duration;         // ms
+
+    int ReadOrder;
+    int Layer;
+    int Style;
+    char *Name;
+    int MarginL;
+    int MarginR;
+    int MarginV;
+    char *Effect;
+    char *Text;
+
+    render_priv_t *render_priv;
+} ass_event_t;
+
+/*
+ * ass track represent either an external script or a matroska subtitle stream
+ * (no real difference between them); it can be used in rendering after the
+ * headers are parsed (i.e. events format line read).
+ */
+typedef struct ass_track {
+    int n_styles;           // amount used
+    int max_styles;         // amount allocated
+    int n_events;
+    int max_events;
+    ass_style_t *styles;    // array of styles, max_styles length, n_styles used
+    ass_event_t *events;    // the same as styles
+
+    char *style_format;     // style format line (everything after &quot;Format: &quot;)
+    char *event_format;     // event format line
+
+    enum {
+        TRACK_TYPE_UNKNOWN = 0,
+        TRACK_TYPE_ASS,
+        TRACK_TYPE_SSA
+    } track_type;
+
+    // Script header fields
+    int PlayResX;
+    int PlayResY;
+    double Timer;
+    int WrapStyle;
+    char ScaledBorderAndShadow;
+
+
+    int default_style;      // index of default style
+    char *name;             // file name in case of external subs, 0 for streams
+
+    ass_library_t *library;
+    parser_priv_t *parser_priv;
+} ass_track_t;
+
+#endif /* LIBASS_TYPES_H */

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_utils.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_utils.c	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_utils.c	2009-08-01 07:55:22 UTC (rev 5185)
@@ -0,0 +1,206 @@
+/*
+ * Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+ *
+ * This file is part of libass.
+ *
+ * libass is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libass is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with libass; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include &quot;config.h&quot;
+
+#include &lt;stdlib.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;inttypes.h&gt;
+#include &lt;ft2build.h&gt;
+#include FT_GLYPH_H
+
+#include &quot;ass_library.h&quot;
+#include &quot;ass.h&quot;
+#include &quot;ass_utils.h&quot;
+
+int mystrtoi(char **p, int *res)
+{
+    double temp_res;
+    char *start = *p;
+    temp_res = strtod(*p, p);
+    *res = (int) (temp_res + (temp_res &gt; 0 ? 0.5 : -0.5));
+    if (*p != start)
+        return 1;
+    else
+        return 0;
+}
+
+int mystrtoll(char **p, long long *res)
+{
+    double temp_res;
+    char *start = *p;
+    temp_res = strtod(*p, p);
+    *res = (int) (temp_res + (temp_res &gt; 0 ? 0.5 : -0.5));
+    if (*p != start)
+        return 1;
+    else
+        return 0;
+}
+
+int mystrtou32(char **p, int base, uint32_t *res)
+{
+    char *start = *p;
+    *res = strtoll(*p, p, base);
+    if (*p != start)
+        return 1;
+    else
+        return 0;
+}
+
+int mystrtod(char **p, double *res)
+{
+    char *start = *p;
+    *res = strtod(*p, p);
+    if (*p != start)
+        return 1;
+    else
+        return 0;
+}
+
+int strtocolor(ass_library_t *library, char **q, uint32_t *res)
+{
+    uint32_t color = 0;
+    int result;
+    char *p = *q;
+
+    if (*p == '&amp;')
+        ++p;
+    else
+        ass_msg(library, MSGL_DBG2, &quot;suspicious color format: \&quot;%s\&quot;\n&quot;, p);
+
+    if (*p == 'H' || *p == 'h') {
+        ++p;
+        result = mystrtou32(&amp;p, 16, &amp;color);
+    } else {
+        result = mystrtou32(&amp;p, 0, &amp;color);
+    }
+
+    {
+        unsigned char *tmp = (unsigned char *) (&amp;color);
+        unsigned char b;
+        b = tmp[0];
+        tmp[0] = tmp[3];
+        tmp[3] = b;
+        b = tmp[1];
+        tmp[1] = tmp[2];
+        tmp[2] = b;
+    }
+    if (*p == '&amp;')
+        ++p;
+    *q = p;
+
+    *res = color;
+    return result;
+}
+
+// Return a boolean value for a string
+char parse_bool(char *str)
+{
+    while (*str == ' ' || *str == '\t')
+        str++;
+    if (!strncasecmp(str, &quot;yes&quot;, 3))
+        return 1;
+    else if (strtol(str, NULL, 10) &gt; 0)
+        return 1;
+    return 0;
+}
+
+void ass_msg(ass_library_t *priv, int lvl, char *fmt, ...)
+{
+    va_list va;
+    va_start(va, fmt);
+    priv-&gt;msg_callback(lvl, fmt, va, priv-&gt;msg_callback_data);
+    va_end(va);
+}
+
+unsigned ass_utf8_get_char(char **str)
+{
+    uint8_t *strp = (uint8_t *) * str;
+    unsigned c = *strp++;
+    unsigned mask = 0x80;
+    int len = -1;
+    while (c &amp; mask) {
+        mask &gt;&gt;= 1;
+        len++;
+    }
+    if (len &lt;= 0 || len &gt; 4)
+        goto no_utf8;
+    c &amp;= mask - 1;
+    while ((*strp &amp; 0xc0) == 0x80) {
+        if (len-- &lt;= 0)
+            goto no_utf8;
+        c = (c &lt;&lt; 6) | (*strp++ &amp; 0x3f);
+    }
+    if (len)
+        goto no_utf8;
+    *str = (char *) strp;
+    return c;
+
+  no_utf8:
+    strp = (uint8_t *) * str;
+    c = *strp++;
+    *str = (char *) strp;
+    return c;
+}
+
+#ifdef CONFIG_ENCA
+void *ass_guess_buffer_cp(ass_library_t *library, unsigned char *buffer,
+                          int buflen, char *preferred_language,
+                          char *fallback)
+{
+    const char **languages;
+    size_t langcnt;
+    EncaAnalyser analyser;
+    EncaEncoding encoding;
+    char *detected_sub_cp = NULL;
+    int i;
+
+    languages = enca_get_languages(&amp;langcnt);
+    ass_msg(library, MSGL_V, &quot;ENCA supported languages&quot;);
+    for (i = 0; i &lt; langcnt; i++) {
+        ass_msg(library, MSGL_V, &quot;lang %s&quot;, languages[i]);
+    }
+
+    for (i = 0; i &lt; langcnt; i++) {
+        const char *tmp;
+
+        if (strcasecmp(languages[i], preferred_language) != 0)
+            continue;
+        analyser = enca_analyser_alloc(languages[i]);
+        encoding = enca_analyse_const(analyser, buffer, buflen);
+        tmp = enca_charset_name(encoding.charset, ENCA_NAME_STYLE_ICONV);
+        if (tmp &amp;&amp; encoding.charset != ENCA_CS_UNKNOWN) {
+            detected_sub_cp = strdup(tmp);
+            ass_msg(library, MSGL_INFO, &quot;ENCA detected charset: %s&quot;, tmp);
+        }
+        enca_analyser_free(analyser);
+    }
+
+    free(languages);
+
+    if (!detected_sub_cp) {
+        detected_sub_cp = strdup(fallback);
+        ass_msg(library, MSGL_INFO,
+               &quot;ENCA detection failed: fallback to %s&quot;, fallback);
+    }
+
+    return detected_sub_cp;
+}
+#endif

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_utils.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_utils.h	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_utils.h	2009-08-01 07:55:22 UTC (rev 5185)
@@ -0,0 +1,129 @@
+/*
+ * Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+ *
+ * This file is part of libass.
+ *
+ * libass is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libass is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with libass; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef LIBASS_UTILS_H
+#define LIBASS_UTILS_H
+
+#include &lt;stdio.h&gt;
+#include &lt;stdarg.h&gt;
+#include &lt;stdint.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;assert.h&gt;
+
+#ifdef CONFIG_ENCA
+#include &lt;enca.h&gt;
+#endif
+
+#include &quot;ass.h&quot;
+
+#define MSGL_FATAL 0
+#define MSGL_ERR 1
+#define MSGL_WARN 2
+#define MSGL_INFO 4
+#define MSGL_V 6
+#define MSGL_DBG2 7
+
+#define FFMAX(a,b) ((a) &gt; (b) ? (a) : (b))
+#define FFMIN(a,b) ((a) &gt; (b) ? (b) : (a))
+#define FFMINMAX(c,a,b) FFMIN(FFMAX(c, a), b)
+
+int mystrtoi(char **p, int *res);
+int mystrtoll(char **p, long long *res);
+int mystrtou32(char **p, int base, uint32_t *res);
+int mystrtod(char **p, double *res);
+int strtocolor(ass_library_t *library, char **q, uint32_t *res);
+char parse_bool(char *str);
+unsigned ass_utf8_get_char(char **str);
+void ass_msg(ass_library_t *priv, int lvl, char *fmt, ...);
+#ifdef CONFIG_ENCA
+void *ass_guess_buffer_cp(ass_library_t *library, unsigned char *buffer,
+                          int buflen, char *preferred_language,
+                          char *fallback);
+#endif
+
+static inline int d6_to_int(int x)
+{
+    return (x + 32) &gt;&gt; 6;
+}
+static inline int d16_to_int(int x)
+{
+    return (x + 32768) &gt;&gt; 16;
+}
+static inline int int_to_d6(int x)
+{
+    return x &lt;&lt; 6;
+}
+static inline int int_to_d16(int x)
+{
+    return x &lt;&lt; 16;
+}
+static inline int d16_to_d6(int x)
+{
+    return (x + 512) &gt;&gt; 10;
+}
+static inline int d6_to_d16(int x)
+{
+    return x &lt;&lt; 10;
+}
+static inline double d6_to_double(int x)
+{
+    return x / 64.;
+}
+static inline int double_to_d6(double x)
+{
+    return (int) (x * 64);
+}
+static inline double d16_to_double(int x)
+{
+    return ((double) x) / 0x10000;
+}
+static inline int double_to_d16(double x)
+{
+    return (int) (x * 0x10000);
+}
+
+#define FNV1_32A_INIT (unsigned)0x811c9dc5
+
+static inline unsigned fnv_32a_buf(void *buf, size_t len, unsigned hval)
+{
+    unsigned char *bp = buf;
+    unsigned char *be = bp + len;
+    while (bp &lt; be) {
+        hval ^= (unsigned) *bp++;
+        hval +=
+            (hval &lt;&lt; 1) + (hval &lt;&lt; 4) + (hval &lt;&lt; 7) + (hval &lt;&lt; 8) +
+            (hval &lt;&lt; 24);
+    }
+    return hval;
+}
+static inline unsigned fnv_32a_str(char *str, unsigned hval)
+{
+    unsigned char *s = (unsigned char *) str;
+    while (*s) {
+        hval ^= (unsigned) *s++;
+        hval +=
+            (hval &lt;&lt; 1) + (hval &lt;&lt; 4) + (hval &lt;&lt; 7) + (hval &lt;&lt; 8) +
+            (hval &lt;&lt; 24);
+    }
+    return hval;
+}
+
+#endif                          /* LIBASS_UTILS_H */

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/config.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/config.h	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/config.h	2009-08-01 07:55:22 UTC (rev 5185)
@@ -0,0 +1 @@
+#include &quot;ADM_coreConfig.h&quot;

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/libass.sym
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/libass.sym	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/libass.sym	2009-08-01 07:55:22 UTC (rev 5185)
@@ -0,0 +1,35 @@
+ass_library_init
+ass_library_done
+ass_set_fonts_dir
+ass_set_extract_fonts
+ass_set_style_overrides
+ass_renderer_init
+ass_renderer_done
+ass_set_frame_size
+ass_set_margins
+ass_set_use_margins
+ass_set_aspect_ratio
+ass_set_font_scale
+ass_set_hinting
+ass_set_line_spacing
+ass_set_fonts
+ass_render_frame
+ass_new_track
+ass_free_track
+ass_alloc_style
+ass_alloc_event
+ass_free_style
+ass_free_event
+ass_process_data
+ass_process_codec_private
+ass_process_chunk
+ass_read_file
+ass_read_memory
+ass_read_styles
+ass_add_font
+ass_clear_fonts
+ass_step_sub
+ass_process_force_style
+ass_set_message_cb
+ass_fonts_update
+ass_set_cache_limits

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/readme
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/readme	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/readme	2009-08-01 07:55:22 UTC (rev 5185)
@@ -0,0 +1,2 @@
+checkout <A HREF="http://repo.or.cz/w/libass.git">http://repo.or.cz/w/libass.git</A>
+done august first 8h36 AM, paris time, last commit      Do not round karaoke timing coordinates  

Deleted: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/CMakeLists.txt	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/CMakeLists.txt	2009-08-01 07:55:22 UTC (rev 5185)
@@ -1,19 +0,0 @@
-INCLUDE(admCheckFontConfig)
-checkFontConfig()
-
-SET(ADM_LIB ADM_libass)
-
-SET(${ADM_LIB}_SRCS 
-ass_bitmap.c  ass.c  ass_cache.c  ass_fontconfig.c  ass_library.c   ass_render.c  ass_utils.c  mputils.c
-ass_font.c)
-
-ADD_LIBRARY(${ADM_LIB} STATIC ${${ADM_LIB}_SRCS})
-ADD_DEFINITIONS(${FREETYPE2_CFLAGS} &quot;-I${LIBICONV_INCLUDE_DIR}&quot;)
-
-IF (FONTCONFIG_FOUND)
-	ADD_DEFINITIONS(${FONTCONFIG_CFLAGS} &quot;-DHAVE_FONTCONFIG=1&quot;)
-ENDIF (FONTCONFIG_FOUND)
-
-IF (UNIX)
-	ADD_TARGET_CFLAGS(${ADM_LIB} -fPIC)
-ENDIF (UNIX)
\ No newline at end of file

Deleted: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass.c	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass.c	2009-08-01 07:55:22 UTC (rev 5185)
@@ -1,1092 +0,0 @@
-// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
-// vim:ts=8:sw=8:noet:ai:
-/*
-  Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
-*/
-
-//#include &quot;config.h&quot;
-
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-#include &lt;assert.h&gt;
-#include &lt;errno.h&gt;
-#include &lt;sys/types.h&gt;
-#include &lt;sys/stat.h&gt;
-#include &lt;unistd.h&gt;
-#include &lt;inttypes.h&gt;
-
-#ifdef USE_ICONV
-#include &lt;iconv.h&gt;
-#endif
-
-#include &quot;ass.h&quot;
-#include &quot;ass_utils.h&quot;
-#include &quot;ass_library.h&quot;
-#include &quot;mputils.h&quot;
-
-typedef enum {PST_UNKNOWN = 0, PST_INFO, PST_STYLES, PST_EVENTS, PST_FONTS} parser_state_t;
-
-struct parser_priv_s {
-	parser_state_t state;
-	char* fontname;
-	char* fontdata;
-	int fontdata_size;
-	int fontdata_used;
-};
-
-#define ASS_STYLES_ALLOC 20
-#define ASS_EVENTS_ALLOC 200
-
-void ass_free_track(ass_track_t* track) {
-	int i;
-	
-	if (track-&gt;parser_priv) {
-		if (track-&gt;parser_priv-&gt;fontname)
-			free(track-&gt;parser_priv-&gt;fontname);
-		if (track-&gt;parser_priv-&gt;fontdata)
-			free(track-&gt;parser_priv-&gt;fontdata);
-		free(track-&gt;parser_priv);
-	}
-	if (track-&gt;style_format)
-		free(track-&gt;style_format);
-	if (track-&gt;event_format)
-		free(track-&gt;event_format);
-	if (track-&gt;styles) {
-		for (i = 0; i &lt; track-&gt;n_styles; ++i)
-			ass_free_style(track, i);
-		free(track-&gt;styles);
-	}
-	if (track-&gt;events) {
-		for (i = 0; i &lt; track-&gt;n_events; ++i)
-			ass_free_event(track, i);
-		free(track-&gt;events);
-	}
-}
-
-/// \brief Allocate a new style struct
-/// \param track track
-/// \return style id
-int ass_alloc_style(ass_track_t* track) {
-	int sid;
-	
-	assert(track-&gt;n_styles &lt;= track-&gt;max_styles);
-
-	if (track-&gt;n_styles == track-&gt;max_styles) {
-		track-&gt;max_styles += ASS_STYLES_ALLOC;
-		track-&gt;styles = (ass_style_t*)realloc(track-&gt;styles, sizeof(ass_style_t)*track-&gt;max_styles);
-	}
-	
-	sid = track-&gt;n_styles++;
-	memset(track-&gt;styles + sid, 0, sizeof(ass_style_t));
-	return sid;
-}
-
-/// \brief Allocate a new event struct
-/// \param track track
-/// \return event id
-int ass_alloc_event(ass_track_t* track) {
-	int eid;
-	
-	assert(track-&gt;n_events &lt;= track-&gt;max_events);
-
-	if (track-&gt;n_events == track-&gt;max_events) {
-		track-&gt;max_events += ASS_EVENTS_ALLOC;
-		track-&gt;events = (ass_event_t*)realloc(track-&gt;events, sizeof(ass_event_t)*track-&gt;max_events);
-	}
-	
-	eid = track-&gt;n_events++;
-	memset(track-&gt;events + eid, 0, sizeof(ass_event_t));
-	return eid;
-}
-
-void ass_free_event(ass_track_t* track, int eid) {
-	ass_event_t* event = track-&gt;events + eid;
-	if (event-&gt;Name)
-		free(event-&gt;Name);
-	if (event-&gt;Effect)
-		free(event-&gt;Effect);
-	if (event-&gt;Text)
-		free(event-&gt;Text);
-	if (event-&gt;render_priv)
-		free(event-&gt;render_priv);
-}
-
-void ass_free_style(ass_track_t* track, int sid) {
-	ass_style_t* style = track-&gt;styles + sid;
-	if (style-&gt;Name)
-		free(style-&gt;Name);
-	if (style-&gt;FontName)
-		free(style-&gt;FontName);
-}
-
-// ==============================================================================================
-
-static void skip_spaces(char** str) {
-	char* p = *str;
-	while ((*p==' ') || (*p=='\t'))
-		++p;
-	*str = p;
-}
-
-static void rskip_spaces(char** str, char* limit) {
-	char* p = *str;
-	while ((p &gt;= limit) &amp;&amp; ((*p==' ') || (*p=='\t')))
-		--p;
-	*str = p;
-}
-
-/**
- * \brief find style by name
- * \param track track
- * \param name style name
- * \return index in track-&gt;styles
- * Returnes 0 if no styles found =&gt; expects at least 1 style.
- * Parsing code always adds &quot;Default&quot; style in the end.
- */
-static int lookup_style(ass_track_t* track, char* name) {
-	int i;
-	if (*name == '*') ++name; // FIXME: what does '*' really mean ?
-	for (i=0; i&lt;track-&gt;n_styles; ++i) {
-		// FIXME: mb strcasecmp ?
-		if (strcmp(track-&gt;styles[i].Name, name) == 0)
-			return i;
-	}
-	i = track-&gt;default_style;
-	mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_NoStyleNamedXFoundUsingY, track, name, track-&gt;styles[i].Name);
-	return i; // use the first style
-}
-
-static uint32_t string2color(char* p) {
-	uint32_t tmp;
-	(void)strtocolor(&amp;p, &amp;tmp);
-	return tmp;
-}
-
-static long long string2timecode(char* p) {
-	unsigned h, m, s, ms;
-	long long tm;
-	int res = sscanf(p, &quot;%1d:%2d:%2d.%2d&quot;, &amp;h, &amp;m, &amp;s, &amp;ms);
-	if (res &lt; 4) {
-		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_BadTimestamp);
-		return 0;
-	}
-	tm = ((h * 60 + m) * 60 + s) * 1000 + ms * 10;
-	return tm;
-}
-
-/**
- * \brief converts numpad-style align to align.
- */
-static int numpad2align(int val) {
-	int res, v;
-	v = (val - 1) / 3; // 0, 1 or 2 for vertical alignment
-	if (v != 0) v = 3 - v;
-	res = ((val - 1) % 3) + 1; // horizontal alignment
-	res += v*4;
-	return res;
-}
-
-#define NEXT(str,token) \
-	token = next_token(&amp;str); \
-	if (!token) break;
-
-#define ANYVAL(name,func) \
-	} else if (strcasecmp(tname, #name) == 0) { \
-		target-&gt;name = func(token); \
-		mp_msg(MSGT_ASS, MSGL_DBG2, &quot;%s = %s\n&quot;, #name, token);
-
-#define STRVAL(name) \
-	} else if (strcasecmp(tname, #name) == 0) { \
-		if (target-&gt;name != NULL) free(target-&gt;name); \
-		target-&gt;name = strdup(token); \
-		mp_msg(MSGT_ASS, MSGL_DBG2, &quot;%s = %s\n&quot;, #name, token);
-		
-#define COLORVAL(name) ANYVAL(name,string2color)
-#define INTVAL(name) ANYVAL(name,atoi)
-#define FPVAL(name) ANYVAL(name,atof)
-#define TIMEVAL(name) ANYVAL(name,string2timecode)
-#define STYLEVAL(name) \
-	} else if (strcasecmp(tname, #name) == 0) { \
-		target-&gt;name = lookup_style(track, token); \
-		mp_msg(MSGT_ASS, MSGL_DBG2, &quot;%s = %s\n&quot;, #name, token);
-
-#define ALIAS(alias,name) \
-	if (strcasecmp(tname, #alias) == 0) {tname = #name;}
-
-static char* next_token(char** str) {
-	char* p = *str;
-	char* start;
-	skip_spaces(&amp;p);
-	if (*p == '\0') {
-		*str = p;
-		return 0;
-	}
-	start = p; // start of the token
-	for (; (*p != '\0') &amp;&amp; (*p != ','); ++p) {}
-	if (*p == '\0') {
-		*str = p; // eos found, str will point to '\0' at exit
-	} else {
-		*p = '\0';
-		*str = p + 1; // ',' found, str will point to the next char (beginning of the next token)
-	}
-	--p; // end of current token
-	rskip_spaces(&amp;p, start);
-	if (p &lt; start)
-		p = start; // empty token
-	else
-		++p; // the first space character, or '\0'
-	*p = '\0';
-	return start;
-}
-/**
- * \brief Parse the tail of Dialogue line
- * \param track track
- * \param event parsed data goes here
- * \param str string to parse, zero-terminated
- * \param n_ignored number of format options to skip at the beginning
-*/ 
-static int process_event_tail(ass_track_t* track, ass_event_t* event, char* str, int n_ignored)
-{
-	char* token;
-	char* tname;
-	char* p = str;
-	int i;
-	ass_event_t* target = event;
-
-	char* format = strdup(track-&gt;event_format);
-	char* q = format; // format scanning pointer
-
-	if (track-&gt;n_styles == 0) {
-		// add &quot;Default&quot; style to the end
-		// will be used if track does not contain a default style (or even does not contain styles at all)
-		int sid = ass_alloc_style(track);
-		track-&gt;styles[sid].Name = strdup(&quot;Default&quot;);
-		track-&gt;styles[sid].FontName = strdup(&quot;Arial&quot;);
-	}
-
-	for (i = 0; i &lt; n_ignored; ++i) {
-		NEXT(q, tname);
-	}
-
-	while (1) {
-		NEXT(q, tname);
-		if (strcasecmp(tname, &quot;Text&quot;) == 0) {
-			char* last;
-			event-&gt;Text = strdup(p);
-			if (*event-&gt;Text != 0) {
-				last = event-&gt;Text + strlen(event-&gt;Text) - 1;
-				if (last &gt;= event-&gt;Text &amp;&amp; *last == '\r')
-					*last = 0;
-			}
-			mp_msg(MSGT_ASS, MSGL_DBG2, &quot;Text = %s\n&quot;, event-&gt;Text);
-			event-&gt;Duration -= event-&gt;Start;
-			free(format);
-			return 0; // &quot;Text&quot; is always the last
-		}
-		NEXT(p, token);
-
-		ALIAS(End,Duration) // temporarily store end timecode in event-&gt;Duration
-		if (0) { // cool ;)
-			INTVAL(Layer)
-			STYLEVAL(Style)
-			STRVAL(Name)
-			STRVAL(Effect)
-			INTVAL(MarginL)
-			INTVAL(MarginR)
-			INTVAL(MarginV)
-			TIMEVAL(Start)
-			TIMEVAL(Duration)
-		}
-	}
-	free(format);
-	return 1;
-}
-
-/**
- * \brief Parse command line style overrides (--ass-force-style option)
- * \param track track to apply overrides to
- * The format for overrides is [StyleName.]Field=Value
- */
-void process_force_style(ass_track_t* track) {
-	char **fs, *eq, *dt, *style, *tname, *token;
-	ass_style_t* target;
-	int sid;
-	char** list = track-&gt;library-&gt;style_overrides;
-	
-	if (!list) return;
-	
-	for (fs = list; *fs; ++fs) {
-		eq = strrchr(*fs, '=');
-		if (!eq)
-			continue;
-		*eq = '\0';
-		token = eq + 1;
-
-		dt = strrchr(*fs, '.');
-		if (dt) {
-			*dt = '\0';
-			style = *fs;
-			tname = dt + 1;
-		} else {
-			style = NULL;
-			tname = *fs;
-		}
-		for (sid = 0; sid &lt; track-&gt;n_styles; ++sid) {
-			if (style == NULL || strcasecmp(track-&gt;styles[sid].Name, style) == 0) {
-				target = track-&gt;styles + sid;
-				if (0) {
-					STRVAL(FontName)
-					COLORVAL(PrimaryColour)
-					COLORVAL(SecondaryColour)
-					COLORVAL(OutlineColour)
-					COLORVAL(BackColour)
-					FPVAL(FontSize)
-					INTVAL(Bold)
-					INTVAL(Italic)
-					INTVAL(Underline)
-					INTVAL(StrikeOut)
-					FPVAL(Spacing)
-					INTVAL(Angle)
-					INTVAL(BorderStyle)
-					INTVAL(Alignment)
-					INTVAL(MarginL)
-					INTVAL(MarginR)
-					INTVAL(MarginV)
-					INTVAL(Encoding)
-					FPVAL(ScaleX)
-					FPVAL(ScaleY)
-					FPVAL(Outline)
-					FPVAL(Shadow)
-				}
-			}
-		}
-		*eq = '=';
-		if (dt) *dt = '.';
-	}
-}
-
-/**
- * \brief Parse the Style line
- * \param track track
- * \param str string to parse, zero-terminated
- * Allocates a new style struct.
-*/ 
-static int process_style(ass_track_t* track, char *str)
-{
-
-	char* token;
-	char* tname;
-	char* p = str;
-	char* format;
-	char* q; // format scanning pointer
-	int sid;
-	ass_style_t* style;
-	ass_style_t* target;
-
-	if (!track-&gt;style_format) {
-		// no style format header
-		// probably an ancient script version
-		if (track-&gt;track_type == TRACK_TYPE_SSA)
-			track-&gt;style_format = strdup(&quot;Name, Fontname, Fontsize, PrimaryColour, SecondaryColour,&quot;
-					&quot;TertiaryColour, BackColour, Bold, Italic, BorderStyle, Outline,&quot;
-					&quot;Shadow, Alignment, MarginL, MarginR, MarginV, AlphaLevel, Encoding&quot;);
-		else
-			track-&gt;style_format = strdup(&quot;Name, Fontname, Fontsize, PrimaryColour, SecondaryColour,&quot;
-					&quot;OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut,&quot;
-					&quot;ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow,&quot;
-					&quot;Alignment, MarginL, MarginR, MarginV, Encoding&quot;);
-	}
-
-	q = format = strdup(track-&gt;style_format);
-	
-	mp_msg(MSGT_ASS, MSGL_V, &quot;[%p] Style: %s\n&quot;, track, str);
-	
-	sid = ass_alloc_style(track);
-
-	style = track-&gt;styles + sid;
-	target = style;
-// fill style with some default values
-	style-&gt;ScaleX = 100.;
-	style-&gt;ScaleY = 100.;
-	
-	while (1) {
-		NEXT(q, tname);
-		NEXT(p, token);
-		
-//		ALIAS(TertiaryColour,OutlineColour) // ignore TertiaryColour; it appears only in SSA, and is overridden by BackColour
-			
-		if (0) { // cool ;)
-			STRVAL(Name)
-				if ((strcmp(target-&gt;Name, &quot;Default&quot;)==0) || (strcmp(target-&gt;Name, &quot;*Default&quot;)==0))
-					track-&gt;default_style = sid;
-			STRVAL(FontName)
-			COLORVAL(PrimaryColour)
-			COLORVAL(SecondaryColour)
-			COLORVAL(OutlineColour) // TertiaryColor
-			COLORVAL(BackColour)
-				// SSA uses BackColour for both outline and shadow
-				// this will destroy SSA's TertiaryColour, but i'm not going to use it anyway
-				if (track-&gt;track_type == TRACK_TYPE_SSA)
-					target-&gt;OutlineColour = target-&gt;BackColour;
-			FPVAL(FontSize)
-			INTVAL(Bold)
-			INTVAL(Italic)
-			INTVAL(Underline)
-			INTVAL(StrikeOut)
-			FPVAL(Spacing)
-			INTVAL(Angle)
-			INTVAL(BorderStyle)
-			INTVAL(Alignment)
-				if (track-&gt;track_type == TRACK_TYPE_ASS)
-					target-&gt;Alignment = numpad2align(target-&gt;Alignment);
-			INTVAL(MarginL)
-			INTVAL(MarginR)
-			INTVAL(MarginV)
-			INTVAL(Encoding)
-			FPVAL(ScaleX)
-			FPVAL(ScaleY)
-			FPVAL(Outline)
-			FPVAL(Shadow)
-		}
-	}
-	style-&gt;ScaleX /= 100.;
-	style-&gt;ScaleY /= 100.;
-	style-&gt;Bold = !!style-&gt;Bold;
-	style-&gt;Italic = !!style-&gt;Italic;
-	style-&gt;Underline = !!style-&gt;Underline;
-	if (!style-&gt;Name)
-		style-&gt;Name = strdup(&quot;Default&quot;);
-	if (!style-&gt;FontName)
-		style-&gt;FontName = strdup(&quot;Arial&quot;);
-	free(format);
-	return 0;
-	
-}
-
-static int process_styles_line(ass_track_t* track, char *str)
-{
-	if (!strncmp(str,&quot;Format:&quot;, 7)) {
-		char* p = str + 7;
-		skip_spaces(&amp;p);
-		track-&gt;style_format = strdup(p);
-		mp_msg(MSGT_ASS, MSGL_DBG2, &quot;Style format: %s\n&quot;, track-&gt;style_format);
-	} else if (!strncmp(str,&quot;Style:&quot;, 6)) {
-		char* p = str + 6;
-		skip_spaces(&amp;p);
-		process_style(track, p);
-	}
-	return 0;
-}
-
-static int process_info_line(ass_track_t* track, char *str)
-{
-	if (!strncmp(str, &quot;PlayResX:&quot;, 9)) {
-		track-&gt;PlayResX = atoi(str + 9);
-	} else if (!strncmp(str,&quot;PlayResY:&quot;, 9)) {
-		track-&gt;PlayResY = atoi(str + 9);
-	} else if (!strncmp(str,&quot;Timer:&quot;, 6)) {
-		track-&gt;Timer = atof(str + 6);
-	} else if (!strncmp(str,&quot;WrapStyle:&quot;, 10)) {
-		track-&gt;WrapStyle = atoi(str + 10);
-	}
-	return 0;
-}
-
-static int process_events_line(ass_track_t* track, char *str)
-{
-	if (!strncmp(str, &quot;Format:&quot;, 7)) {
-		char* p = str + 7;
-		skip_spaces(&amp;p);
-		track-&gt;event_format = strdup(p);
-		mp_msg(MSGT_ASS, MSGL_DBG2, &quot;Event format: %s\n&quot;, track-&gt;event_format);
-	} else if (!strncmp(str, &quot;Dialogue:&quot;, 9)) {
-		// This should never be reached for embedded subtitles.
-		// They have slightly different format and are parsed in ass_process_chunk,
-		// called directly from demuxer
-		int eid;
-		ass_event_t* event;
-		
-		str += 9;
-		skip_spaces(&amp;str);
-
-		eid = ass_alloc_event(track);
-		event = track-&gt;events + eid;
-
-		process_event_tail(track, event, str, 0);
-	} else {
-		mp_msg(MSGT_ASS, MSGL_V, &quot;Not understood: %s  \n&quot;, str);
-	}
-	return 0;
-}
-
-// Copied from mkvtoolnix
-static unsigned char* decode_chars(unsigned char c1, unsigned char c2,
-		unsigned char c3, unsigned char c4, unsigned char* dst, int cnt)
-{
-	uint32_t value;
-	unsigned char bytes[3];
-	int i;
-
-	value = ((c1 - 33) &lt;&lt; 18) + ((c2 - 33) &lt;&lt; 12) + ((c3 - 33) &lt;&lt; 6) + (c4 - 33);
-	bytes[2] = value &amp; 0xff;
-	bytes[1] = (value &amp; 0xff00) &gt;&gt; 8;
-	bytes[0] = (value &amp; 0xff0000) &gt;&gt; 16;
-
-	for (i = 0; i &lt; cnt; ++i)
-		*dst++ = bytes[i];
-	return dst;
-}
-
-static int decode_font(ass_track_t* track)
-{
-	unsigned char* p;
-	unsigned char* q;
-	int i;
-	int size; // original size
-	int dsize; // decoded size
-	unsigned char* buf = 0;
-
-	mp_msg(MSGT_ASS, MSGL_V, &quot;font: %d bytes encoded data \n&quot;, track-&gt;parser_priv-&gt;fontdata_used);
-	size = track-&gt;parser_priv-&gt;fontdata_used;
-	if (size % 4 == 1) {
-		mp_msg(MSGT_ASS, MSGL_ERR, MSGTR_LIBASS_BadEncodedDataSize);
-		goto error_decode_font;
-	}
-	buf = malloc(size / 4 * 3 + 2);
-	q = buf;
-	for (i = 0, p = (unsigned char*)track-&gt;parser_priv-&gt;fontdata; i &lt; size / 4; i++, p+=4) {
-		q = decode_chars(p[0], p[1], p[2], p[3], q, 3);
-	}
-	if (size % 4 == 2) {
-		q = decode_chars(p[0], p[1], 0, 0, q, 1);
-	} else if (size % 4 == 3) {
-		q = decode_chars(p[0], p[1], p[2], 0, q, 2);
-	}
-	dsize = q - buf;
-	assert(dsize &lt;= size / 4 * 3 + 2);
-	
-	if (track-&gt;library-&gt;extract_fonts) {
-		ass_add_font(track-&gt;library, track-&gt;parser_priv-&gt;fontname, (char*)buf, dsize);
-		buf = 0;
-	}
-
-error_decode_font:
-	if (buf) free(buf);
-	free(track-&gt;parser_priv-&gt;fontname);
-	free(track-&gt;parser_priv-&gt;fontdata);
-	track-&gt;parser_priv-&gt;fontname = 0;
-	track-&gt;parser_priv-&gt;fontdata = 0;
-	track-&gt;parser_priv-&gt;fontdata_size = 0;
-	track-&gt;parser_priv-&gt;fontdata_used = 0;
-	return 0;
-}
-
-static int process_fonts_line(ass_track_t* track, char *str)
-{
-	int len;
-
-	if (!strncmp(str, &quot;fontname:&quot;, 9)) {
-		char* p = str + 9;
-		skip_spaces(&amp;p);
-		if (track-&gt;parser_priv-&gt;fontname) {
-			decode_font(track);
-		}
-		track-&gt;parser_priv-&gt;fontname = strdup(p);
-		mp_msg(MSGT_ASS, MSGL_V, &quot;fontname: %s\n&quot;, track-&gt;parser_priv-&gt;fontname);
-		return 0;
-	}
-	
-	if (!track-&gt;parser_priv-&gt;fontname) {
-		mp_msg(MSGT_ASS, MSGL_V, &quot;Not understood: %s  \n&quot;, str);
-		return 0;
-	}
-
-	len = strlen(str);
-	if (len &gt; 80) {
-		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FontLineTooLong, len, str);
-		return 0;
-	}
-	if (track-&gt;parser_priv-&gt;fontdata_used + len &gt; track-&gt;parser_priv-&gt;fontdata_size) {
-		track-&gt;parser_priv-&gt;fontdata_size += 100 * 1024;
-		track-&gt;parser_priv-&gt;fontdata = realloc(track-&gt;parser_priv-&gt;fontdata, track-&gt;parser_priv-&gt;fontdata_size);
-	}
-	memcpy(track-&gt;parser_priv-&gt;fontdata + track-&gt;parser_priv-&gt;fontdata_used, str, len);
-	track-&gt;parser_priv-&gt;fontdata_used += len;
-	
-	return 0;
-}
-
-/**
- * \brief Parse a header line
- * \param track track
- * \param str string to parse, zero-terminated
-*/ 
-static int process_line(ass_track_t* track, char *str)
-{
-	if (strstr(str, &quot;[Script Info]&quot;)) { // FIXME: strstr to skip possible BOM at the beginning of the script
-		track-&gt;parser_priv-&gt;state = PST_INFO;
-	} else if (!strncmp(str, &quot;[V4 Styles]&quot;, 11)) {
-		track-&gt;parser_priv-&gt;state = PST_STYLES;
-		track-&gt;track_type = TRACK_TYPE_SSA;
-	} else if (!strncmp(str, &quot;[V4+ Styles]&quot;, 12)) {
-		track-&gt;parser_priv-&gt;state = PST_STYLES;
-		track-&gt;track_type = TRACK_TYPE_ASS;
-	} else if (!strncmp(str, &quot;[Events]&quot;, 8)) {
-		track-&gt;parser_priv-&gt;state = PST_EVENTS;
-	} else if (!strncmp(str, &quot;[Fonts]&quot;, 7)) {
-		track-&gt;parser_priv-&gt;state = PST_FONTS;
-	} else {
-		switch (track-&gt;parser_priv-&gt;state) {
-		case PST_INFO:
-			process_info_line(track, str);
-			break;
-		case PST_STYLES:
-			process_styles_line(track, str);
-			break;
-		case PST_EVENTS:
-			process_events_line(track, str);
-			break;
-		case PST_FONTS:
-			process_fonts_line(track, str);
-			break;
-		default:
-			break;
-		}
-	}
-
-	// there is no explicit end-of-font marker in ssa/ass
-	if ((track-&gt;parser_priv-&gt;state != PST_FONTS) &amp;&amp; (track-&gt;parser_priv-&gt;fontname))
-		decode_font(track);
-
-	return 0;
-}
-
-static int process_text(ass_track_t* track, char* str)
-{
-	char* p = str;
-	while(1) {
-		char* q;
-		for (;((*p=='\r')||(*p=='\n'));++p) {}
-		for (q=p; ((*q!='\0')&amp;&amp;(*q!='\r')&amp;&amp;(*q!='\n')); ++q) {};
-		if (q==p)
-			break;
-		if (*q != '\0')
-			*(q++) = '\0';
-		process_line(track, p);
-		if (*q == '\0')
-			break;
-		p = q;
-	}
-	return 0;
-}
-
-/**
- * \brief Process CodecPrivate section of subtitle stream
- * \param track track
- * \param data string to parse
- * \param size length of data
- CodecPrivate section contains [Stream Info] and [V4+ Styles] ([V4 Styles] for SSA) sections
-*/ 
-void ass_process_codec_private(ass_track_t* track, char *data, int size)
-{
-	char* str = malloc(size + 1);
-
-	memcpy(str, data, size);
-	str[size] = '\0';
-
-	process_text(track, str);
-	free(str);
-
-	if (!track-&gt;event_format) {
-		// probably an mkv produced by ancient mkvtoolnix
-		// such files don't have [Events] and Format: headers
-		track-&gt;parser_priv-&gt;state = PST_EVENTS;
-		if (track-&gt;track_type == TRACK_TYPE_SSA)
-			track-&gt;event_format = strdup(&quot;Format: Marked, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text&quot;);
-		else
-			track-&gt;event_format = strdup(&quot;Format: Layer, Start, End, Style, Actor, MarginL, MarginR, MarginV, Effect, Text&quot;);
-	}
-
-	process_force_style(track);
-}
-
-static int check_duplicate_event(ass_track_t* track, int ReadOrder)
-{
-	int i;
-	for (i = 0; i&lt;track-&gt;n_events - 1; ++i) // ignoring last event, it is the one we are comparing with
-		if (track-&gt;events[i].ReadOrder == ReadOrder)
-			return 1;
-	return 0;
-}
-
-/**
- * \brief Process a chunk of subtitle stream data. In matroska, this containes exactly 1 event (or a commentary)
- * \param track track
- * \param data string to parse
- * \param size length of data
- * \param timecode starting time of the event (milliseconds)
- * \param duration duration of the event (milliseconds)
-*/ 
-void ass_process_chunk(ass_track_t* track, char *data, int size, long long timecode, long long duration)
-{
-	char* str;
-	int eid;
-	char* p;
-	char* token;
-	ass_event_t* event;
-
-	if (!track-&gt;event_format) {
-		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_EventFormatHeaderMissing);
-		return;
-	}
-	
-	str = malloc(size + 1);
-	memcpy(str, data, size);
-	str[size] = '\0';
-	mp_msg(MSGT_ASS, MSGL_V, &quot;event at %&quot; PRId64 &quot;, +%&quot; PRId64 &quot;: %s  \n&quot;, (int64_t)timecode, (int64_t)duration, str);
-
-	eid = ass_alloc_event(track);
-	event = track-&gt;events + eid;
-
-	p = str;
-	
-	do { 
-		NEXT(p, token);
-		event-&gt;ReadOrder = atoi(token);
-		if (check_duplicate_event(track, event-&gt;ReadOrder))
-			break;
-
-		NEXT(p, token);
-		event-&gt;Layer = atoi(token);
-
-		process_event_tail(track, event, p, 3);
-
-		event-&gt;Start = timecode;
-		event-&gt;Duration = duration;
-		
-		free(str);
-		return;
-//		dump_events(tid);
-	} while (0);
-	// some error
-	ass_free_event(track, eid);
-	track-&gt;n_events--;
-	free(str);
-}
-
-#ifdef USE_ICONV
-/** \brief recode buffer to utf-8
- * constraint: codepage != 0
- * \param data pointer to text buffer
- * \param size buffer size
- * \return a pointer to recoded buffer, caller is responsible for freeing it
-**/
-static char* sub_recode(char* data, size_t size, char* codepage)
-{
-	static iconv_t icdsc = (iconv_t)(-1);
-	char* tocp = &quot;UTF-8&quot;;
-	char* outbuf;
-	assert(codepage);
-
-	{
-		char* cp_tmp = codepage ? strdup(codepage) : 0;
-#ifdef HAVE_ENCA
-		char enca_lang[3], enca_fallback[100];
-		if (sscanf(codepage, &quot;enca:%2s:%99s&quot;, enca_lang, enca_fallback) == 2
-				|| sscanf(codepage, &quot;ENCA:%2s:%99s&quot;, enca_lang, enca_fallback) == 2) {
-			cp_tmp = guess_buffer_cp((unsigned char*)data, size, enca_lang, enca_fallback);
-		}
-#endif
-		if ((icdsc = iconv_open (tocp, cp_tmp)) != (iconv_t)(-1)){
-			mp_msg(MSGT_ASS,MSGL_V,&quot;LIBSUB: opened iconv descriptor.\n&quot;);
-		} else
-			mp_msg(MSGT_ASS,MSGL_ERR,MSGTR_LIBASS_ErrorOpeningIconvDescriptor);
-#ifdef HAVE_ENCA
-		if (cp_tmp) free(cp_tmp);
-#endif
-	}
-
-	{
-		size_t osize = size;
-		size_t ileft = size;
-		size_t oleft = size - 1;
-		char* ip;
-		char* op;
-		size_t rc;
-		
-		outbuf = malloc(size);
-		ip = data;
-		op = outbuf;
-		
-		while (ileft) {
-			rc = iconv(icdsc, &amp;ip, &amp;ileft, &amp;op, &amp;oleft);
-			if (rc == (size_t)(-1)) {
-				if (errno == E2BIG) {
-					int offset = op - outbuf;
-					outbuf = (char*)realloc(outbuf, osize + size);
-					op = outbuf + offset;
-					osize += size;
-					oleft += size;
-				} else {
-					mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_ErrorRecodingFile);
-					return NULL;
-				}
-			}
-		}
-		outbuf[osize - oleft - 1] = 0;
-	}
-
-	if (icdsc != (iconv_t)(-1)) {
-		(void)iconv_close(icdsc);
-		icdsc = (iconv_t)(-1);
-		mp_msg(MSGT_ASS,MSGL_V,&quot;LIBSUB: closed iconv descriptor.\n&quot;);
-	}
-	
-	return outbuf;
-}
-#endif // ICONV
-
-/**
- * \brief read file contents into newly allocated buffer
- * \param fname file name
- * \param bufsize out: file size
- * \return pointer to file contents. Caller is responsible for its deallocation.
- */
-static char* read_file(char* fname, size_t *bufsize)
-{
-	int res;
-	long sz;
-	long bytes_read;
-	char* buf;
-
-	FILE* fp = fopen(fname, &quot;rb&quot;);
-	if (!fp) {
-		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FopenFailed, fname);
-		return 0;
-	}
-	res = fseek(fp, 0, SEEK_END);
-	if (res == -1) {
-		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FseekFailed, fname);
-		fclose(fp);
-		return 0;
-	}
-	
-	sz = ftell(fp);
-	rewind(fp);
-
-	if (sz &gt; 10*1024*1024) {
-		mp_msg(MSGT_ASS, MSGL_INFO, MSGTR_LIBASS_RefusingToLoadSubtitlesLargerThan10M, fname);
-		fclose(fp);
-		return 0;
-	}
-	
-	mp_msg(MSGT_ASS, MSGL_V, &quot;file size: %ld\n&quot;, sz);
-	
-	buf = malloc(sz + 1);
-	assert(buf);
-	bytes_read = 0;
-	do {
-		res = fread(buf + bytes_read, 1, sz - bytes_read, fp);
-		if (res &lt;= 0) {
-			mp_msg(MSGT_ASS, MSGL_INFO, MSGTR_LIBASS_ReadFailed, errno, strerror(errno));
-			fclose(fp);
-			free(buf);
-			return 0;
-		}
-		bytes_read += res;
-	} while (sz - bytes_read &gt; 0);
-	buf[sz] = '\0';
-	fclose(fp);
-	
-	if (bufsize)
-		*bufsize = sz;
-	return buf;
-}
-
-/*
- * \param buf pointer to subtitle text in utf-8
- */
-static ass_track_t* parse_memory(ass_library_t* library, char* buf)
-{
-	ass_track_t* track;
-	int i;
-	
-	track = ass_new_track(library);
-	
-	// process header
-	process_text(track, buf);
-
-	// external SSA/ASS subs does not have ReadOrder field
-	for (i = 0; i &lt; track-&gt;n_events; ++i)
-		track-&gt;events[i].ReadOrder = i;
-
-	// there is no explicit end-of-font marker in ssa/ass
-	if (track-&gt;parser_priv-&gt;fontname)
-		decode_font(track);
-
-	if (track-&gt;track_type == TRACK_TYPE_UNKNOWN) {
-		ass_free_track(track);
-		return 0;
-	}
-
-	process_force_style(track);
-
-	return track;
-}
-
-/**
- * \brief Read subtitles from memory.
- * \param library libass library object
- * \param buf pointer to subtitles text
- * \param bufsize size of buffer
- * \param codepage recode buffer contents from given codepage
- * \return newly allocated track
-*/ 
-ass_track_t* ass_read_memory(ass_library_t* library, char* buf, size_t bufsize, char* codepage)
-{
-	ass_track_t* track;
-	int need_free = 0;
-	
-	if (!buf)
-		return 0;
-	
-#ifdef USE_ICONV
-	if (codepage)
-		buf = sub_recode(buf, bufsize, codepage);
-	if (!buf)
-		return 0;
-	else
-		need_free = 1;
-#endif
-	track = parse_memory(library, buf);
-	if (need_free)
-		free(buf);
-	if (!track)
-		return 0;
-
-	mp_msg(MSGT_ASS, MSGL_INFO, MSGTR_LIBASS_AddedSubtitleFileMemory, track-&gt;n_styles, track-&gt;n_events);
-	return track;
-}
-
-char* read_file_recode(char* fname, char* codepage, int* size)
-{
-	char* buf;
-	size_t bufsize;
-	
-	buf = read_file(fname, &amp;bufsize);
-	if (!buf)
-		return 0;
-#ifdef USE_ICONV
-	if (codepage) {
-		 char* tmpbuf = sub_recode(buf, bufsize, codepage);
-		 free(buf);
-		 buf = tmpbuf;
-	}
-	if (!buf)
-		return 0;
-#endif
-	*size = bufsize;
-	return buf;
-}
-
-/**
- * \brief Read subtitles from file.
- * \param library libass library object
- * \param fname file name
- * \param codepage recode buffer contents from given codepage
- * \return newly allocated track
-*/ 
-ass_track_t* ass_read_file(ass_library_t* library, char* fname, char* codepage)
-{
-	char* buf;
-	ass_track_t* track;
-	size_t bufsize;
-
-	buf = read_file_recode(fname, codepage, &amp;bufsize);
-	if (!buf)
-		return 0;
-	track = parse_memory(library, buf);
-	free(buf);
-	if (!track)
-		return 0;
-	
-	track-&gt;name = strdup(fname);
-
-	mp_msg(MSGT_ASS, MSGL_INFO, MSGTR_LIBASS_AddedSubtitleFileFname, fname, track-&gt;n_styles, track-&gt;n_events);
-	
-//	dump_events(forced_tid);
-	return track;
-}
-
-/**
- * \brief read styles from file into already initialized track
- */
-int ass_read_styles(ass_track_t* track, char* fname, char* codepage)
-{
-	char* buf;
-	parser_state_t old_state;
-	size_t sz;
-
-	buf = read_file(fname, &amp;sz);
-	if (!buf)
-		return 1;
-#ifdef USE_ICONV
-	if (codepage) {
-		char* tmpbuf;
-		tmpbuf = sub_recode(buf, sz, codepage);
-		free(buf);
-		buf = tmpbuf;
-	}
-	if (!buf)
-		return 0;
-#endif
-
-	old_state = track-&gt;parser_priv-&gt;state;
-	track-&gt;parser_priv-&gt;state = PST_STYLES;
-	process_text(track, buf);
-	track-&gt;parser_priv-&gt;state = old_state;
-
-	return 0;
-}
-
-long long ass_step_sub(ass_track_t* track, long long now, int movement) {
-	int i;
-
-	if (movement == 0) return 0;
-	if (track-&gt;n_events == 0) return 0;
-	
-	if (movement &lt; 0)
-		for (i = 0; (i &lt; track-&gt;n_events) &amp;&amp; ((long long)(track-&gt;events[i].Start + track-&gt;events[i].Duration) &lt;= now); ++i) {}
-	else
-		for (i = track-&gt;n_events - 1; (i &gt;= 0) &amp;&amp; ((long long)(track-&gt;events[i].Start) &gt; now); --i) {}
-	
-	// -1 and n_events are ok
-	assert(i &gt;= -1); assert(i &lt;= track-&gt;n_events);
-	i += movement;
-	if (i &lt; 0) i = 0;
-	if (i &gt;= track-&gt;n_events) i = track-&gt;n_events - 1;
-	return ((long long)track-&gt;events[i].Start) - now;
-}
-
-ass_track_t* ass_new_track(ass_library_t* library) {
-	ass_track_t* track = calloc(1, sizeof(ass_track_t));
-	track-&gt;library = library;
-	track-&gt;parser_priv = calloc(1, sizeof(parser_priv_t));
-	return track;
-}
-

Deleted: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass.h	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass.h	2009-08-01 07:55:22 UTC (rev 5185)
@@ -1,209 +0,0 @@
-// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
-// vim:ts=8:sw=8:noet:ai:
-/*
-  Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
-*/
-
-#ifndef ASS_H
-#define ASS_H
-
-#include &quot;ass_types.h&quot;
-
-/// Libass renderer object. Contents are private.
-typedef struct ass_renderer_s ass_renderer_t;
-
-/// a linked list of images produced by ass renderer
-typedef struct ass_image_s {
-	int w, h; // bitmap width/height
-	int stride; // bitmap stride
-	unsigned char* bitmap; // 1bpp stride*h alpha buffer
-	uint32_t color; // RGBA
-	int dst_x, dst_y; // bitmap placement inside the video frame
-
-	struct ass_image_s* next; // linked list
-} ass_image_t;
-
-/// Hinting type
-typedef enum {ASS_HINTING_NONE = 0,
-	      ASS_HINTING_LIGHT,
-	      ASS_HINTING_NORMAL,
-	      ASS_HINTING_NATIVE
-} ass_hinting_t;
-
-/**
- * \brief initialize the library
- * \return library handle or NULL if failed
- */
-ass_library_t* ass_library_init(void);
-
-/**
- * \brief finalize the library
- * \param priv library handle
- */
-void ass_library_done(ass_library_t*);
-
-/**
- * \brief set private font directory
- * It is used for saving embedded fonts and also in font lookup.
- */
-void ass_set_fonts_dir(ass_library_t* priv, const char* fonts_dir);
-
-void ass_set_extract_fonts(ass_library_t* priv, int extract);
-
-void ass_set_style_overrides(ass_library_t* priv, char** list);
-
-/**
- * \brief initialize the renderer
- * \param priv library handle
- * \return renderer handle or NULL if failed
- */
-ass_renderer_t* ass_renderer_init(ass_library_t*);
-
-/**
- * \brief finalize the renderer
- * \param priv renderer handle
- */
-void ass_renderer_done(ass_renderer_t* priv);
-
-void ass_set_frame_size(ass_renderer_t* priv, int w, int h);
-void ass_set_margins(ass_renderer_t* priv, int t, int b, int l, int r);
-void ass_set_use_margins(ass_renderer_t* priv, int use);
-void ass_set_aspect_ratio(ass_renderer_t* priv, double ar);
-void ass_set_font_scale(ass_renderer_t* priv, double font_scale);
-void ass_set_hinting(ass_renderer_t* priv, ass_hinting_t ht);
-void ass_set_line_spacing(ass_renderer_t* priv, double line_spacing);
-
-/**
- * \brief set font lookup defaults
- */
-int  ass_set_fonts(ass_renderer_t* priv, const char* default_font, const char* default_family);
-
-/**
- * \brief render a frame, producing a list of ass_image_t
- * \param priv library
- * \param track subtitle track
- * \param now video timestamp in milliseconds
- */
-ass_image_t* ass_render_frame(ass_renderer_t *priv, ass_track_t* track, long long now, int* detect_change);
-
-
-// The following functions operate on track objects and do not need an ass_renderer //
-
-/**
- * \brief allocate a new empty track object
- * \return pointer to empty track
- */
-ass_track_t* ass_new_track(ass_library_t*);
-
-/**
- * \brief deallocate track and all its child objects (styles and events)
- * \param track track to deallocate
- */
-void ass_free_track(ass_track_t* track);
-
-/**
- * \brief allocate new style
- * \param track track
- * \return newly allocated style id
- */
-int ass_alloc_style(ass_track_t* track);
-
-/**
- * \brief allocate new event
- * \param track track
- * \return newly allocated event id
- */
-int ass_alloc_event(ass_track_t* track);
-
-/**
- * \brief delete a style
- * \param track track
- * \param sid style id
- * Deallocates style data. Does not modify track-&gt;n_styles.
- */
-void ass_free_style(ass_track_t* track, int sid);
-
-/**
- * \brief delete an event
- * \param track track
- * \param eid event id
- * Deallocates event data. Does not modify track-&gt;n_events.
- */
-void ass_free_event(ass_track_t* track, int eid);
-
-/**
- * \brief Process Codec Private section of subtitle stream
- * \param track target track
- * \param data string to parse
- * \param size length of data
- */
-void ass_process_codec_private(ass_track_t* track, char *data, int size);
-
-/**
- * \brief Process a chunk of subtitle stream data. In matroska, this containes exactly 1 event (or a commentary)
- * \param track track
- * \param data string to parse
- * \param size length of data
- * \param timecode starting time of the event (milliseconds)
- * \param duration duration of the event (milliseconds)
-*/
-void ass_process_chunk(ass_track_t* track, char *data, int size, long long timecode, long long duration);
-
-char* read_file_recode(char* fname, char* codepage, int* size);
-
-/**
- * \brief Read subtitles from file.
- * \param fname file name
- * \return newly allocated track
-*/
-ass_track_t* ass_read_file(ass_library_t* library, char* fname, char* codepage);
-
-/**
- * \brief Read subtitles from memory.
- * \param library libass library object
- * \param buf pointer to subtitles text
- * \param bufsize size of buffer
- * \param codepage recode buffer contents from given codepage
- * \return newly allocated track
-*/ 
-ass_track_t* ass_read_memory(ass_library_t* library, char* buf, size_t bufsize, char* codepage);
-/**
- * \brief read styles from file into already initialized track
- * \return 0 on success
- */
-int ass_read_styles(ass_track_t* track, char* fname, char* codepage);
-
-/**
- * \brief Add a memory font.
- * \param name attachment name
- * \param data binary font data
- * \param data_size data size
-*/
-void ass_add_font(ass_library_t* library, char* name, char* data, int data_size);
-
-/**
- * \brief Calculates timeshift from now to the start of some other subtitle event, depending on movement parameter
- * \param track subtitle track
- * \param now current time, ms
- * \param movement how many events to skip from the one currently displayed
- * +2 means &quot;the one after the next&quot;, -1 means &quot;previous&quot;
- * \return timeshift, ms
- */
-long long ass_step_sub(ass_track_t* track, long long now, int movement);
-
-#endif
-

Deleted: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_bitmap.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_bitmap.c	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_bitmap.c	2009-08-01 07:55:22 UTC (rev 5185)
@@ -1,272 +0,0 @@
-// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
-// vim:ts=8:sw=8:noet:ai:
-/*
-  Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
-*/
-
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-#include &lt;math.h&gt;
-#include &lt;assert.h&gt;
-#include &lt;ft2build.h&gt;
-#include FT_GLYPH_H
-
-#include &quot;mputils.h&quot;
-#include &quot;ass_bitmap.h&quot;
-
-struct ass_synth_priv_s {
-	int tmp_w, tmp_h;
-	unsigned short* tmp;
-
-	int g_r;
-	int g_w;
-
-	unsigned *g;
-	unsigned *gt2;
-};
-
-static const unsigned int maxcolor = 255;
-static const unsigned base = 256;
-static const double blur_radius = 1.5;
-
-static int generate_tables(ass_synth_priv_t* priv, double radius)
-{
-	double A = log(1.0/base)/(radius*radius*2);
-	int mx, i;
-	double volume_diff, volume_factor = 0;
-	unsigned volume;
-
-	priv-&gt;g_r = ceil(radius);
-	priv-&gt;g_w = 2*priv-&gt;g_r+1;
-
-	if (priv-&gt;g_r) {
-		priv-&gt;g = malloc(priv-&gt;g_w * sizeof(unsigned));
-		priv-&gt;gt2 = malloc(256 * priv-&gt;g_w * sizeof(unsigned));
-		if (priv-&gt;g==NULL || priv-&gt;gt2==NULL) {
-			return -1;
-		}
-	}
-
-	if (priv-&gt;g_r) {
-		// gaussian curve with volume = 256
-		for (volume_diff=10000000; volume_diff&gt;0.0000001; volume_diff*=0.5){
-			volume_factor+= volume_diff;
-			volume=0;
-			for (i = 0; i&lt;priv-&gt;g_w; ++i) {
-				priv-&gt;g[i] = (unsigned)(exp(A * (i-priv-&gt;g_r)*(i-priv-&gt;g_r)) * volume_factor + .5);
-				volume+= priv-&gt;g[i];
-			}
-			if(volume&gt;256) volume_factor-= volume_diff;
-		}
-		volume=0;
-		for (i = 0; i&lt;priv-&gt;g_w; ++i) {
-			priv-&gt;g[i] = (unsigned)(exp(A * (i-priv-&gt;g_r)*(i-priv-&gt;g_r)) * volume_factor + .5);
-			volume+= priv-&gt;g[i];
-		}
-
-		// gauss table:
-		for(mx=0;mx&lt;priv-&gt;g_w;mx++){
-			for(i=0;i&lt;256;i++){
-				priv-&gt;gt2[mx+i*priv-&gt;g_w] = i*priv-&gt;g[mx];
-			}
-		}
-	}
-
-	return 0;
-}
-
-static void resize_tmp(ass_synth_priv_t* priv, int w, int h)
-{
-	if (priv-&gt;tmp_w &gt;= w &amp;&amp; priv-&gt;tmp_h &gt;= h)
-		return;
-	if (priv-&gt;tmp_w == 0)
-		priv-&gt;tmp_w = 64;
-	if (priv-&gt;tmp_h == 0)
-		priv-&gt;tmp_h = 64;
-	while (priv-&gt;tmp_w &lt; w) priv-&gt;tmp_w *= 2;
-	while (priv-&gt;tmp_h &lt; h) priv-&gt;tmp_h *= 2;
-	if (priv-&gt;tmp)
-		free(priv-&gt;tmp);
-	priv-&gt;tmp = malloc((priv-&gt;tmp_w + 1) * priv-&gt;tmp_h * sizeof(short));
-}
-
-ass_synth_priv_t* ass_synth_init(void)
-{
-	ass_synth_priv_t* priv = calloc(1, sizeof(ass_synth_priv_t));
-	generate_tables(priv, blur_radius);
-	return priv;
-}
-
-void ass_synth_done(ass_synth_priv_t* priv)
-{
-	if (priv-&gt;tmp)
-		free(priv-&gt;tmp);
-	if (priv-&gt;g)
-		free(priv-&gt;g);
-	if (priv-&gt;gt2)
-		free(priv-&gt;gt2);
-	free(priv);
-}
-
-static bitmap_t* alloc_bitmap(int w, int h)
-{
-	bitmap_t* bm;
-	bm = calloc(1, sizeof(bitmap_t));
-	bm-&gt;buffer = malloc(w*h);
-	bm-&gt;w = w;
-	bm-&gt;h = h;
-	bm-&gt;left = bm-&gt;top = 0;
-	return bm;
-}
-
-void ass_free_bitmap(bitmap_t* bm)
-{
-	if (bm) {
-		if (bm-&gt;buffer) free(bm-&gt;buffer);
-		free(bm);
-	}
-}
-
-static bitmap_t* copy_bitmap(const bitmap_t* src)
-{
-	bitmap_t* dst = alloc_bitmap(src-&gt;w, src-&gt;h);
-	dst-&gt;left = src-&gt;left;
-	dst-&gt;top = src-&gt;top;
-	memcpy(dst-&gt;buffer, src-&gt;buffer, src-&gt;w * src-&gt;h);
-	return dst;
-}
-
-static bitmap_t* glyph_to_bitmap_internal(FT_Glyph glyph, int bord)
-{
-	FT_BitmapGlyph bg;
-	FT_Bitmap* bit;
-	bitmap_t* bm;
-	int w, h;
-	unsigned char* src;
-	unsigned char* dst;
-	int i;
-	int error;
-
-	error = FT_Glyph_To_Bitmap(&amp;glyph, FT_RENDER_MODE_NORMAL, 0, 0);
-	if (error) {
-		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FT_Glyph_To_BitmapError, error);
-		return 0;
-	}
-
-	bg = (FT_BitmapGlyph)glyph;
-	bit = &amp;(bg-&gt;bitmap);
-	if (bit-&gt;pixel_mode != FT_PIXEL_MODE_GRAY) {
-		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_UnsupportedPixelMode, (int)(bit-&gt;pixel_mode));
-		FT_Done_Glyph(glyph);
-		return 0;
-	}
-
-	w = bit-&gt;width;
-	h = bit-&gt;rows;
-	bm = alloc_bitmap(w + 2*bord, h + 2*bord);
-	memset(bm-&gt;buffer, 0, bm-&gt;w * bm-&gt;h);
-	bm-&gt;left = bg-&gt;left - bord;
-	bm-&gt;top = - bg-&gt;top - bord;
-
-	src = bit-&gt;buffer;
-	dst = bm-&gt;buffer + bord + bm-&gt;w * bord;
-	for (i = 0; i &lt; h; ++i) {
-		memcpy(dst, src, w);
-		src += bit-&gt;pitch;
-		dst += bm-&gt;w;
-	}
-
-	return bm;
-}
-
-/**
- * \brief fix outline bitmap and generate shadow bitmap
- * Two things are done here:
- * 1. Glyph bitmap is subtracted from outline bitmap. This way looks much better in some cases.
- * 2. Shadow bitmap is created as a sum of glyph and outline bitmaps.
- */
-static bitmap_t* fix_outline_and_shadow(bitmap_t* bm_g, bitmap_t* bm_o)
-{
-	int x, y;
-	const int l = bm_o-&gt;left &gt; bm_g-&gt;left ? bm_o-&gt;left : bm_g-&gt;left;
-	const int t = bm_o-&gt;top &gt; bm_g-&gt;top ? bm_o-&gt;top : bm_g-&gt;top;
-	const int r = bm_o-&gt;left + bm_o-&gt;w &lt; bm_g-&gt;left + bm_g-&gt;w ? bm_o-&gt;left + bm_o-&gt;w : bm_g-&gt;left + bm_g-&gt;w;
-	const int b = bm_o-&gt;top + bm_o-&gt;h &lt; bm_g-&gt;top + bm_g-&gt;h ? bm_o-&gt;top + bm_o-&gt;h : bm_g-&gt;top + bm_g-&gt;h;
-
-	bitmap_t* bm_s = copy_bitmap(bm_o);
-
-	unsigned char* g = bm_g-&gt;buffer + (t - bm_g-&gt;top) * bm_g-&gt;w + (l - bm_g-&gt;left);
-	unsigned char* o = bm_o-&gt;buffer + (t - bm_o-&gt;top) * bm_o-&gt;w + (l - bm_o-&gt;left);
-	unsigned char* s = bm_s-&gt;buffer + (t - bm_s-&gt;top) * bm_s-&gt;w + (l - bm_s-&gt;left);
-	
-	for (y = 0; y &lt; b - t; ++y) {
-		for (x = 0; x &lt; r - l; ++x) {
-			unsigned char c_g, c_o;
-			c_g = g[x];
-			c_o = o[x];
-			o[x] = (c_o &gt; c_g) ? c_o : 0;
-			s[x] = (c_o &lt; 0xFF - c_g) ? c_o + c_g : 0xFF;
-		}
-		g += bm_g-&gt;w;
-		o += bm_o-&gt;w;
-		s += bm_s-&gt;w;
-	}
-
-	assert(bm_s);
-	return bm_s;
-}
-
-int glyph_to_bitmap(ass_synth_priv_t* priv, FT_Glyph glyph, FT_Glyph outline_glyph,
-		bitmap_t** bm_g, bitmap_t** bm_o, bitmap_t** bm_s, int be)
-{
-	const int bord = be ? ceil(blur_radius) : 0;
-
-	assert(bm_g &amp;&amp; bm_o &amp;&amp; bm_s);
-
-	*bm_g = *bm_o = *bm_s = 0;
-
-	if (glyph)
-		*bm_g = glyph_to_bitmap_internal(glyph, bord);
-	if (!*bm_g)
-		return 1;
-
-	if (outline_glyph) {
-		*bm_o = glyph_to_bitmap_internal(outline_glyph, bord);
-		if (!*bm_o) {
-			ass_free_bitmap(*bm_g);
-			return 1;
-		}
-	}
-	if (*bm_o)
-		resize_tmp(priv, (*bm_o)-&gt;w, (*bm_o)-&gt;h);
-	resize_tmp(priv, (*bm_g)-&gt;w, (*bm_g)-&gt;h);
-	
-	if (be) {
-		blur((*bm_g)-&gt;buffer, priv-&gt;tmp, (*bm_g)-&gt;w, (*bm_g)-&gt;h, (*bm_g)-&gt;w, (int*)priv-&gt;gt2, priv-&gt;g_r, priv-&gt;g_w);
-		if (*bm_o)
-			blur((*bm_o)-&gt;buffer, priv-&gt;tmp, (*bm_o)-&gt;w, (*bm_o)-&gt;h, (*bm_o)-&gt;w, (int*)priv-&gt;gt2, priv-&gt;g_r, priv-&gt;g_w);
-	}
-
-	if (*bm_o)
-		*bm_s = fix_outline_and_shadow(*bm_g, *bm_o);
-	else
-		*bm_s = copy_bitmap(*bm_g);
-
-	assert(bm_s);
-	return 0;
-}
-

Deleted: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_bitmap.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_bitmap.h	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_bitmap.h	2009-08-01 07:55:22 UTC (rev 5185)
@@ -1,49 +0,0 @@
-// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
-// vim:ts=8:sw=8:noet:ai:
-/*
-  Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
-*/
-
-#ifndef ASS_BITMAP_H
-#define ASS_BITMAP_H
-
-typedef struct ass_synth_priv_s ass_synth_priv_t;
-
-ass_synth_priv_t* ass_synth_init(void);
-void ass_synth_done(ass_synth_priv_t* priv);
-
-typedef struct bitmap_s {
-	int left, top;
-	int w, h; // width, height
-	unsigned char* buffer; // w x h buffer
-} bitmap_t;
-
-/**
- * \brief perform glyph rendering
- * \param glyph original glyph
- * \param outline_glyph &quot;border&quot; glyph, produced from original by FreeType's glyph stroker
- * \param bm_g out: pointer to the bitmap of original glyph is returned here
- * \param bm_o out: pointer to the bitmap of outline (border) glyph is returned here
- * \param bm_g out: pointer to the bitmap of glyph shadow is returned here
- * \param be 1 = produces blurred bitmaps, 0 = normal bitmaps
- */
-int glyph_to_bitmap(ass_synth_priv_t* priv, FT_Glyph glyph, FT_Glyph outline_glyph, bitmap_t** bm_g, bitmap_t** bm_o, bitmap_t** bm_s, int be);
-
-void ass_free_bitmap(bitmap_t* bm);
-
-#endif
-

Deleted: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_cache.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_cache.c	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_cache.c	2009-08-01 07:55:22 UTC (rev 5185)
@@ -1,324 +0,0 @@
-// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
-// vim:ts=8:sw=8:noet:ai:
-/*
-  Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
-*/
-
-//#include &quot;config.h&quot;
-
-#include &lt;inttypes.h&gt;
-#include &lt;ft2build.h&gt;
-#include FT_FREETYPE_H
-#include FT_GLYPH_H
-
-#include &lt;assert.h&gt;
-
-#include &quot;mputils.h&quot;
-#include &quot;ass.h&quot;
-#include &quot;ass_fontconfig.h&quot;
-#include &quot;ass_font.h&quot;
-#include &quot;ass_bitmap.h&quot;
-#include &quot;ass_cache.h&quot;
-
-
-typedef struct hashmap_item_s {
-	void* key;
-	void* value;
-	struct hashmap_item_s* next;
-} hashmap_item_t;
-typedef hashmap_item_t* hashmap_item_p;
-
-struct hashmap_s {
-	int nbuckets;
-	size_t key_size, value_size;
-	hashmap_item_p* root;
-	hashmap_item_dtor_t item_dtor; // a destructor for hashmap key/value pairs
-	hashmap_key_compare_t key_compare;
-	hashmap_hash_t hash;
-	// stats
-	int hit_count;
-	int miss_count;
-	int count;
-};
-
-#define FNV1_32A_INIT (unsigned)0x811c9dc5
-
-static inline unsigned fnv_32a_buf(void* buf, size_t len, unsigned hval)
-{
-	unsigned char *bp = buf;
-	unsigned char *be = bp + len;
-	while (bp &lt; be) {
-		hval ^= (unsigned)*bp++;
-		hval += (hval&lt;&lt;1) + (hval&lt;&lt;4) + (hval&lt;&lt;7) + (hval&lt;&lt;8) + (hval&lt;&lt;24);
-	}
-	return hval;
-}
-static inline unsigned fnv_32a_str(char* str, unsigned hval)
-{
-	unsigned char* s = (unsigned char*)str;
-	while (*s) {
-		hval ^= (unsigned)*s++;
-		hval += (hval&lt;&lt;1) + (hval&lt;&lt;4) + (hval&lt;&lt;7) + (hval&lt;&lt;8) + (hval&lt;&lt;24);
-	}
-	return hval;
-}
-
-static unsigned hashmap_hash(void* buf, size_t len)
-{
-	return fnv_32a_buf(buf, len, FNV1_32A_INIT);
-}
-
-static int hashmap_key_compare(void* a, void* b, size_t size)
-{
-	return (memcmp(a, b, size) == 0);
-}
-
-static void hashmap_item_dtor(void* key, size_t key_size, void* value, size_t value_size)
-{
-	free(key);
-	free(value);
-}
-
-hashmap_t* hashmap_init(size_t key_size, size_t value_size, int nbuckets,
-			hashmap_item_dtor_t item_dtor, hashmap_key_compare_t key_compare,
-			hashmap_hash_t hash)
-{
-	hashmap_t* map = calloc(1, sizeof(hashmap_t));
-	map-&gt;nbuckets = nbuckets;
-	map-&gt;key_size = key_size;
-	map-&gt;value_size = value_size;
-	map-&gt;root = calloc(nbuckets, sizeof(hashmap_item_p));
-	map-&gt;item_dtor = item_dtor ? item_dtor : hashmap_item_dtor;
-	map-&gt;key_compare = key_compare ? key_compare : hashmap_key_compare;
-	map-&gt;hash = hash ? hash : hashmap_hash;
-	return map;
-}
-
-void hashmap_done(hashmap_t* map)
-{
-	int i;
-	// print stats
-	if (map-&gt;count &gt; 0 || map-&gt;hit_count + map-&gt;miss_count &gt; 0)
-		mp_msg(MSGT_ASS, MSGL_V, &quot;cache statistics: \n  total accesses: %d\n  hits: %d\n  misses: %d\n  object count: %d\n&quot;,
-		       map-&gt;hit_count + map-&gt;miss_count, map-&gt;hit_count, map-&gt;miss_count, map-&gt;count);
-	
-	for (i = 0; i &lt; map-&gt;nbuckets; ++i) {
-		hashmap_item_t* item = map-&gt;root[i];
-		while (item) {
-			hashmap_item_t* next = item-&gt;next;
-			map-&gt;item_dtor(item-&gt;key, map-&gt;key_size, item-&gt;value, map-&gt;value_size);
-			free(item);
-			item = next;
-		}
-	}
-	free(map-&gt;root);
-	free(map);
-}
-
-// does nothing if key already exists
-void* hashmap_insert(hashmap_t* map, void* key, void* value)
-{
-	unsigned hash = map-&gt;hash(key, map-&gt;key_size);
-	hashmap_item_t** next = map-&gt;root + (hash % map-&gt;nbuckets);
-	while (*next) {
-		if (map-&gt;key_compare(key, (*next)-&gt;key, map-&gt;key_size))
-			return (*next)-&gt;value;
-		next = &amp;((*next)-&gt;next);
-		assert(next);
-	}
-	(*next) = malloc(sizeof(hashmap_item_t));
-	(*next)-&gt;key = malloc(map-&gt;key_size);
-	(*next)-&gt;value = malloc(map-&gt;value_size);
-	memcpy((*next)-&gt;key, key, map-&gt;key_size);
-	memcpy((*next)-&gt;value, value, map-&gt;value_size);
-	(*next)-&gt;next = 0;
-
-	map-&gt;count ++;
-	return (*next)-&gt;value;
-}
-
-void* hashmap_find(hashmap_t* map, void* key)
-{
-	unsigned hash = map-&gt;hash(key, map-&gt;key_size);
-	hashmap_item_t* item = map-&gt;root[hash % map-&gt;nbuckets];
-	while (item) {
-		if (map-&gt;key_compare(key, item-&gt;key, map-&gt;key_size)) {
-			map-&gt;hit_count++;
-			return item-&gt;value;
-		}
-		item = item-&gt;next;
-	}
-	map-&gt;miss_count++;
-	return 0;
-}
-
-//---------------------------------
-// font cache
-
-hashmap_t* font_cache;
-
-static unsigned font_desc_hash(void* buf, size_t len)
-{
-	ass_font_desc_t* desc = buf;
-	unsigned hval;
-	hval = fnv_32a_str(desc-&gt;family, FNV1_32A_INIT);
-	hval = fnv_32a_buf(&amp;desc-&gt;bold, sizeof(desc-&gt;bold), hval);
-	hval = fnv_32a_buf(&amp;desc-&gt;italic, sizeof(desc-&gt;italic), hval);
-	return hval;
-}
-
-static int font_compare(void* key1, void* key2, size_t key_size) {
-	ass_font_desc_t* a = key1;
-	ass_font_desc_t* b = key2;
-	if (strcmp(a-&gt;family, b-&gt;family) != 0)
-		return 0;
-	if (a-&gt;bold != b-&gt;bold)
-		return 0;
-	if (a-&gt;italic != b-&gt;italic)
-		return 0;
-	return 1;
-}
-
-static void font_hash_dtor(void* key, size_t key_size, void* value, size_t value_size)
-{
-	ass_font_free(value);
-	free(key);
-}
-
-ass_font_t* ass_font_cache_find(ass_font_desc_t* desc)
-{
-	return hashmap_find(font_cache, desc);
-}
-
-/**
- * \brief Add a face struct to cache.
- * \param font font struct
-*/
-void* ass_font_cache_add(ass_font_t* font)
-{
-	return hashmap_insert(font_cache, &amp;(font-&gt;desc), font);
-}
-
-void ass_font_cache_init(void)
-{
-	font_cache = hashmap_init(sizeof(ass_font_desc_t),
-				  sizeof(ass_font_t),
-				  1000,
-				  font_hash_dtor, font_compare, font_desc_hash);
-}
-
-void ass_font_cache_done(void)
-{
-	hashmap_done(font_cache);
-}
-
-//---------------------------------
-// bitmap cache
-
-hashmap_t* bitmap_cache;
-
-static void bitmap_hash_dtor(void* key, size_t key_size, void* value, size_t value_size)
-{
-	bitmap_hash_val_t* v = value;
-	if (v-&gt;bm) ass_free_bitmap(v-&gt;bm);
-	if (v-&gt;bm_o) ass_free_bitmap(v-&gt;bm_o);
-	if (v-&gt;bm_s) ass_free_bitmap(v-&gt;bm_s);
-	free(key);
-	free(value);
-}
-
-void* cache_add_bitmap(bitmap_hash_key_t* key, bitmap_hash_val_t* val)
-{
-	return hashmap_insert(bitmap_cache, key, val);
-}
-
-/**
- * \brief Get a bitmap from bitmap cache.
- * \param key hash key
- * \return requested hash val or 0 if not found
-*/ 
-bitmap_hash_val_t* cache_find_bitmap(bitmap_hash_key_t* key)
-{
-	return hashmap_find(bitmap_cache, key);
-}
-
-void ass_bitmap_cache_init(void)
-{
-	bitmap_cache = hashmap_init(sizeof(bitmap_hash_key_t),
-				   sizeof(bitmap_hash_val_t),
-				   0xFFFF + 13,
-				   bitmap_hash_dtor, NULL, NULL);
-}
-
-void ass_bitmap_cache_done(void)
-{
-	hashmap_done(bitmap_cache);
-}
-
-void ass_bitmap_cache_reset(void)
-{
-	ass_bitmap_cache_done();
-	ass_bitmap_cache_init();
-}
-
-//---------------------------------
-// glyph cache
-
-hashmap_t* glyph_cache;
-
-static void glyph_hash_dtor(void* key, size_t key_size, void* value, size_t value_size)
-{
-	glyph_hash_val_t* v = value;
-	if (v-&gt;glyph) FT_Done_Glyph(v-&gt;glyph);
-	if (v-&gt;outline_glyph) FT_Done_Glyph(v-&gt;outline_glyph);
-	free(key);
-	free(value);
-}
-
-void* cache_add_glyph(glyph_hash_key_t* key, glyph_hash_val_t* val)
-{
-	return hashmap_insert(glyph_cache, key, val);
-}
-
-/**
- * \brief Get a glyph from glyph cache.
- * \param key hash key
- * \return requested hash val or 0 if not found
-*/ 
-glyph_hash_val_t* cache_find_glyph(glyph_hash_key_t* key)
-{
-	return hashmap_find(glyph_cache, key);
-}
-
-void ass_glyph_cache_init(void)
-{
-	glyph_cache = hashmap_init(sizeof(glyph_hash_key_t),
-				   sizeof(glyph_hash_val_t),
-				   0xFFFF + 13,
-				   glyph_hash_dtor, NULL, NULL);
-}
-
-void ass_glyph_cache_done(void)
-{
-	hashmap_done(glyph_cache);
-}
-
-void ass_glyph_cache_reset(void)
-{
-	ass_glyph_cache_done();
-	ass_glyph_cache_init();
-}

Deleted: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_cache.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_cache.h	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_cache.h	2009-08-01 07:55:22 UTC (rev 5185)
@@ -1,98 +0,0 @@
-// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
-// vim:ts=8:sw=8:noet:ai:
-/*
-  Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
-*/
-
-#ifndef ASS_CACHE_H
-#define ASS_CACHE_H
-
-void ass_font_cache_init(void);
-ass_font_t* ass_font_cache_find(ass_font_desc_t* desc);
-void* ass_font_cache_add(ass_font_t* font);
-void ass_font_cache_done(void);
-
-
-// describes a bitmap; bitmaps with equivalents structs are considered identical
-typedef struct bitmap_hash_key_s {
-	char bitmap; // bool : true = bitmap, false = outline
-	ass_font_t* font;
-	double size; // font size
-	uint32_t ch; // character code
-	unsigned outline; // border width, 16.16 fixed point value
-	int bold, italic;
-	char be; // blur edges
-
-	unsigned scale_x, scale_y; // 16.16
-	int frx, fry, frz; // signed 16.16
-	int shift_x, shift_y; // shift vector that was added to glyph before applying rotation
-	                      // = 0, if frx = fry = frx = 0
-	                      // = (glyph base point) - (rotation origin), otherwise
-	
-	FT_Vector advance; // subpixel shift vector
-} bitmap_hash_key_t;
-
-typedef struct bitmap_hash_val_s {
-	bitmap_t* bm; // the actual bitmaps
-	bitmap_t* bm_o;
-	bitmap_t* bm_s;
-} bitmap_hash_val_t;
-
-void ass_bitmap_cache_init(void);
-void* cache_add_bitmap(bitmap_hash_key_t* key, bitmap_hash_val_t* val);
-bitmap_hash_val_t* cache_find_bitmap(bitmap_hash_key_t* key);
-void ass_bitmap_cache_reset(void);
-void ass_bitmap_cache_done(void);
-
-// describes an outline glyph
-typedef struct glyph_hash_key_s {
-	ass_font_t* font;
-	double size; // font size
-	uint32_t ch; // character code
-	int bold, italic;
-	unsigned scale_x, scale_y; // 16.16
-	FT_Vector advance; // subpixel shift vector
-	unsigned outline; // border width, 16.16
-} glyph_hash_key_t;
-
-typedef struct glyph_hash_val_s {
-	FT_Glyph glyph;
-	FT_Glyph outline_glyph;
-	FT_BBox bbox_scaled; // bbox after scaling, but before rotation
-	FT_Vector advance; // 26.6, advance distance to the next bitmap in line
-} glyph_hash_val_t;
-
-void ass_glyph_cache_init(void);
-void* cache_add_glyph(glyph_hash_key_t* key, glyph_hash_val_t* val);
-glyph_hash_val_t* cache_find_glyph(glyph_hash_key_t* key);
-void ass_glyph_cache_reset(void);
-void ass_glyph_cache_done(void);
-
-typedef struct hashmap_s hashmap_t; 
-typedef void (*hashmap_item_dtor_t)(void* key, size_t key_size, void* value, size_t value_size);
-typedef int (*hashmap_key_compare_t)(void* key1, void* key2, size_t key_size);
-typedef unsigned (*hashmap_hash_t)(void* key, size_t key_size);
-
-hashmap_t* hashmap_init(size_t key_size, size_t value_size, int nbuckets,
-			hashmap_item_dtor_t item_dtor, hashmap_key_compare_t key_compare,
-			hashmap_hash_t hash);
-void hashmap_done(hashmap_t* map);
-void* hashmap_insert(hashmap_t* map, void* key, void* value);
-void* hashmap_find(hashmap_t* map, void* key);
-
-#endif
-

Deleted: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_font.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_font.c	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_font.c	2009-08-01 07:55:22 UTC (rev 5185)
@@ -1,370 +0,0 @@
-// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
-// vim:ts=8:sw=8:noet:ai:
-/*
-  Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
-*/
-
-//#include &quot;config.h&quot;
-
-#include &lt;inttypes.h&gt;
-#include &lt;ft2build.h&gt;
-#include FT_FREETYPE_H
-#include FT_SYNTHESIS_H
-#include FT_GLYPH_H
-#include FT_TRUETYPE_TABLES_H
-
-#include &quot;ass.h&quot;
-#include &quot;ass_library.h&quot;
-#include &quot;ass_font.h&quot;
-#include &quot;ass_bitmap.h&quot;
-#include &quot;ass_cache.h&quot;
-#include &quot;ass_fontconfig.h&quot;
-#include &quot;ass_utils.h&quot;
-#include &quot;mputils.h&quot;
-
-/**
- * Select Microfost Unicode CharMap, if the font has one.
- * Otherwise, let FreeType decide.
- */
-static void charmap_magic(FT_Face face)
-{
-	int i;
-	for (i = 0; i &lt; face-&gt;num_charmaps; ++i) {
-		FT_CharMap cmap = face-&gt;charmaps[i];
-		unsigned pid = cmap-&gt;platform_id;
-		unsigned eid = cmap-&gt;encoding_id;
-		if (pid == 3 /*microsoft*/ &amp;&amp; (eid == 1 /*unicode bmp*/ || eid == 10 /*full unicode*/)) {
-			FT_Set_Charmap(face, cmap);
-			return;
-		}
-	}
-
-	if (!face-&gt;charmap) {
-		if (face-&gt;num_charmaps == 0) {
-			mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_NoCharmaps);
-			return;
-		}
-		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_NoCharmapAutodetected);
-		FT_Set_Charmap(face, face-&gt;charmaps[0]);
-		return;
-	}
-}
-
-static void update_transform(ass_font_t* font)
-{
-	int i;
-	FT_Matrix m;
-	m.xx = double_to_d16(font-&gt;scale_x);
-	m.yy = double_to_d16(font-&gt;scale_y);
-	m.xy = m.yx = 0;
-	for (i = 0; i &lt; font-&gt;n_faces; ++i)
-		FT_Set_Transform(font-&gt;faces[i], &amp;m, &amp;font-&gt;v);
-}
-
-/**
- * \brief find a memory font by name
- */
-static int find_font(ass_library_t* library, char* name)
-{
-	int i;
-	for (i = 0; i &lt; library-&gt;num_fontdata; ++i)
-		if (strcasecmp(name, library-&gt;fontdata[i].name) == 0)
-			return i;
-	return -1;
-}
-
-static void face_set_size(FT_Face face, double size);
-
-static void buggy_font_workaround(FT_Face face)
-{
-	// Some fonts have zero Ascender/Descender fields in 'hhea' table.
-	// In this case, get the information from 'os2' table or, as
-	// a last resort, from face.bbox.
-	if (face-&gt;ascender + face-&gt;descender == 0 || face-&gt;height == 0) {
-		TT_OS2 *os2 = FT_Get_Sfnt_Table(face, ft_sfnt_os2);
-		if (os2) {
-			face-&gt;ascender = os2-&gt;sTypoAscender;
-			face-&gt;descender = os2-&gt;sTypoDescender;
-			face-&gt;height = face-&gt;ascender - face-&gt;descender;
-		} else {
-			face-&gt;ascender = face-&gt;bbox.yMax;
-			face-&gt;descender = face-&gt;bbox.yMin;
-			face-&gt;height = face-&gt;ascender - face-&gt;descender;
-		}
-	}
-}
-
-/**
- * \brief Select a face with the given charcode and add it to ass_font_t
- * \return index of the new face in font-&gt;faces, -1 if failed
- */
-static int add_face(void* fc_priv, ass_font_t* font, uint32_t ch)
-{
-	char* path;
-	int index;
-	FT_Face face;
-	int error;
-	int mem_idx;
-	
-	if (font-&gt;n_faces == ASS_FONT_MAX_FACES)
-		return -1;
-	
-	path = fontconfig_select(fc_priv, font-&gt;desc.family, font-&gt;desc.bold,
-					      font-&gt;desc.italic, &amp;index, ch);
-
-	mem_idx = find_font(font-&gt;library, path);
-	if (mem_idx &gt;= 0) {
-		error = FT_New_Memory_Face(font-&gt;ftlibrary, (unsigned char*)font-&gt;library-&gt;fontdata[mem_idx].data,
-					   font-&gt;library-&gt;fontdata[mem_idx].size, 0, &amp;face);
-		if (error) {
-			mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_ErrorOpeningMemoryFont, path);
-			return -1;
-		}
-	} else {
-		error = FT_New_Face(font-&gt;ftlibrary, path, index, &amp;face);
-		if (error) {
-			mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_ErrorOpeningFont, path, index);
-			return -1;
-		}
-	}
-	charmap_magic(face);
-	buggy_font_workaround(face);
-	
-	font-&gt;faces[font-&gt;n_faces++] = face;
-	update_transform(font);
-	face_set_size(face, font-&gt;size);
-	return font-&gt;n_faces - 1;
-}
-
-/**
- * \brief Create a new ass_font_t according to &quot;desc&quot; argument
- */
-ass_font_t* ass_font_new(ass_library_t* library, FT_Library ftlibrary, void* fc_priv, ass_font_desc_t* desc)
-{
-	int error;
-	ass_font_t* fontp;
-	ass_font_t font;
-
-	fontp = ass_font_cache_find(desc);
-	if (fontp)
-		return fontp;
-	
-	font.library = library;
-	font.ftlibrary = ftlibrary;
-	font.n_faces = 0;
-	font.desc.family = strdup(desc-&gt;family);
-	font.desc.bold = desc-&gt;bold;
-	font.desc.italic = desc-&gt;italic;
-
-	font.scale_x = font.scale_y = 1.;
-	font.v.x = font.v.y = 0;
-	font.size = 0.;
-
-	error = add_face(fc_priv, &amp;font, 0);
-	if (error == -1) {
-		free(font.desc.family);
-		return 0;
-	} else
-		return ass_font_cache_add(&amp;font);
-}
-
-/**
- * \brief Set font transformation matrix and shift vector
- **/
-void ass_font_set_transform(ass_font_t* font, double scale_x, double scale_y, FT_Vector* v)
-{
-	font-&gt;scale_x = scale_x;
-	font-&gt;scale_y = scale_y;
-	font-&gt;v.x = v-&gt;x;
-	font-&gt;v.y = v-&gt;y;
-	update_transform(font);
-}
-
-static void face_set_size(FT_Face face, double size)
-{
-#if (FREETYPE_MAJOR &gt; 2) || ((FREETYPE_MAJOR == 2) &amp;&amp; (FREETYPE_MINOR &gt; 1))
-	TT_HoriHeader *hori = FT_Get_Sfnt_Table(face, ft_sfnt_hhea);
-	TT_OS2 *os2 = FT_Get_Sfnt_Table(face, ft_sfnt_os2);
-	double mscale = 1.;
-	FT_Size_RequestRec rq;
-	FT_Size_Metrics *m = &amp;face-&gt;size-&gt;metrics;
-	// VSFilter uses metrics from TrueType OS/2 table
-	// The idea was borrowed from asa (<A HREF="http://asa.diac24.net">http://asa.diac24.net</A>)
-	if (hori &amp;&amp; os2) {
-		int hori_height = hori-&gt;Ascender - hori-&gt;Descender;
-		int os2_height = os2-&gt;usWinAscent + os2-&gt;usWinDescent;
-		if (hori_height &amp;&amp; os2_height)
-			mscale = (double)hori_height / os2_height;
-	}
-	memset(&amp;rq, 0, sizeof(rq));
-	rq.type = FT_SIZE_REQUEST_TYPE_REAL_DIM;
-	rq.width = 0;
-	rq.height = double_to_d6(size * mscale);
-	rq.horiResolution = rq.vertResolution = 0;
-	FT_Request_Size(face, &amp;rq);
-	m-&gt;ascender /= mscale;
-	m-&gt;descender /= mscale;
-	m-&gt;height /= mscale;
-#else
-	FT_Set_Char_Size(face, 0, double_to_d6(size), 0, 0);
-#endif
-}
-
-/**
- * \brief Set font size
- **/
-void ass_font_set_size(ass_font_t* font, double size)
-{
-	int i;
-	if (font-&gt;size != size) {
-		font-&gt;size = size;
-		for (i = 0; i &lt; font-&gt;n_faces; ++i)
-			face_set_size(font-&gt;faces[i], size);
-	}
-}
-
-/**
- * \brief Get maximal font ascender and descender.
- * \param ch character code
- * The values are extracted from the font face that provides glyphs for the given character
- **/
-void ass_font_get_asc_desc(ass_font_t* font, uint32_t ch, int* asc, int* desc)
-{
-	int i;
-	for (i = 0; i &lt; font-&gt;n_faces; ++i) {
-		FT_Face face = font-&gt;faces[i];
-		if (FT_Get_Char_Index(face, ch)) {
-			int v, v2;
-			v = face-&gt;size-&gt;metrics.ascender;
-			v2 = FT_MulFix(face-&gt;bbox.yMax, face-&gt;size-&gt;metrics.y_scale);
-			*asc = (v &gt; v2 * 0.9) ? v : v2;
-				
-			v = - face-&gt;size-&gt;metrics.descender;
-			v2 = - FT_MulFix(face-&gt;bbox.yMin, face-&gt;size-&gt;metrics.y_scale);
-			*desc = (v &gt; v2 * 0.9) ? v : v2;
-			return;
-		}
-	}
-	
-	*asc = *desc = 0;
-}
-
-/**
- * \brief Get a glyph
- * \param ch character code
- **/
-FT_Glyph ass_font_get_glyph(void* fontconfig_priv, ass_font_t* font, uint32_t ch, ass_hinting_t hinting)
-{
-	int error;
-	int index = 0;
-	int i;
-	FT_Glyph glyph;
-	FT_Face face = 0;
-	int flags = 0;
-
-	if (ch &lt; 0x20)
-		return 0;
-	if (font-&gt;n_faces == 0)
-		return 0;
-
-	for (i = 0; i &lt; font-&gt;n_faces; ++i) {
-		face = font-&gt;faces[i];
-		index = FT_Get_Char_Index(face, ch);
-		if (index)
-			break;
-	}
-
-#ifdef HAVE_FONTCONFIG
-	if (index == 0) {
-		int face_idx;
-		mp_msg(MSGT_ASS, MSGL_INFO, MSGTR_LIBASS_GlyphNotFoundReselectingFont,
-		       ch, font-&gt;desc.family, font-&gt;desc.bold, font-&gt;desc.italic);
-		face_idx = add_face(fontconfig_priv, font, ch);
-		face = font-&gt;faces[face_idx];
-		index = FT_Get_Char_Index(face, ch);
-		if (index == 0) {
-			mp_msg(MSGT_ASS, MSGL_ERR, MSGTR_LIBASS_GlyphNotFound,
-			       ch, font-&gt;desc.family, font-&gt;desc.bold, font-&gt;desc.italic);
-		}
-	}
-#endif
-
-	switch (hinting) {
-	case ASS_HINTING_NONE: flags = FT_LOAD_NO_HINTING; break;
-	case ASS_HINTING_LIGHT: flags = FT_LOAD_FORCE_AUTOHINT | FT_LOAD_TARGET_LIGHT; break;
-	case ASS_HINTING_NORMAL: flags = FT_LOAD_FORCE_AUTOHINT; break;
-	case ASS_HINTING_NATIVE: flags = 0; break;
-	}
-	
-	error = FT_Load_Glyph(face, index, FT_LOAD_NO_BITMAP | flags);
-	if (error) {
-		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_ErrorLoadingGlyph);
-		return 0;
-	}
-	
-#if (FREETYPE_MAJOR &gt; 2) || \
-    ((FREETYPE_MAJOR == 2) &amp;&amp; (FREETYPE_MINOR &gt;= 2)) || \
-    ((FREETYPE_MAJOR == 2) &amp;&amp; (FREETYPE_MINOR == 1) &amp;&amp; (FREETYPE_PATCH &gt;= 10))
-// FreeType &gt;= 2.1.10 required
-	if (!(face-&gt;style_flags &amp; FT_STYLE_FLAG_ITALIC) &amp;&amp; 
-			(font-&gt;desc.italic &gt; 55)) {
-		FT_GlyphSlot_Oblique(face-&gt;glyph);
-	}
-#endif
-	error = FT_Get_Glyph(face-&gt;glyph, &amp;glyph);
-	if (error) {
-		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_ErrorLoadingGlyph);
-		return 0;
-	}
-	
-	return glyph;
-}
-
-/**
- * \brief Get kerning for the pair of glyphs.
- **/
-FT_Vector ass_font_get_kerning(ass_font_t* font, uint32_t c1, uint32_t c2)
-{
-	FT_Vector v = {0, 0};
-	int i;
-
-	for (i = 0; i &lt; font-&gt;n_faces; ++i) {
-		FT_Face face = font-&gt;faces[i];
-		int i1 = FT_Get_Char_Index(face, c1);
-		int i2 = FT_Get_Char_Index(face, c2);
-		if (i1 &amp;&amp; i2) {
-			if (FT_HAS_KERNING(face))
-				FT_Get_Kerning(face, i1, i2, FT_KERNING_DEFAULT, &amp;v);
-			return v;
-		}
-		if (i1 || i2) // these glyphs are from different font faces, no kerning information
-			return v;
-	}
-	return v;
-}
-
-/**
- * \brief Deallocate ass_font_t
- **/
-void ass_font_free(ass_font_t* font)
-{
-	int i;
-	for (i = 0; i &lt; font-&gt;n_faces; ++i)
-		if (font-&gt;faces[i]) FT_Done_Face(font-&gt;faces[i]);
-	if (font-&gt;desc.family) free(font-&gt;desc.family);
-	free(font);
-}

Deleted: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_font.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_font.h	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_font.h	2009-08-01 07:55:22 UTC (rev 5185)
@@ -1,51 +0,0 @@
-// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
-// vim:ts=8:sw=8:noet:ai:
-/*
-  Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
-*/
-
-#ifndef ASS_FONT_H
-#define ASS_FONT_H
-
-typedef struct ass_font_desc_s {
-	char* family;
-	unsigned bold;
-	unsigned italic;
-} ass_font_desc_t;
-
-#define ASS_FONT_MAX_FACES 10
-
-typedef struct ass_font_s {
-	ass_font_desc_t desc;
-	ass_library_t* library;
-	FT_Library ftlibrary;
-	FT_Face faces[ASS_FONT_MAX_FACES];
-	int n_faces;
-	double scale_x, scale_y; // current transform
-	FT_Vector v; // current shift
-	double size;
-} ass_font_t;
-
-ass_font_t* ass_font_new(ass_library_t* library, FT_Library ftlibrary, void* fc_priv, ass_font_desc_t* desc);
-void ass_font_set_transform(ass_font_t* font, double scale_x, double scale_y, FT_Vector* v);
-void ass_font_set_size(ass_font_t* font, double size);
-void ass_font_get_asc_desc(ass_font_t* font, uint32_t ch, int* asc, int* desc);
-FT_Glyph ass_font_get_glyph(void* fontconfig_priv, ass_font_t* font, uint32_t ch, ass_hinting_t hinting);
-FT_Vector ass_font_get_kerning(ass_font_t* font, uint32_t c1, uint32_t c2);
-void ass_font_free(ass_font_t* font);
-
-#endif

Deleted: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_fontconfig.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_fontconfig.c	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_fontconfig.c	2009-08-01 07:55:22 UTC (rev 5185)
@@ -1,413 +0,0 @@
-// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
-// vim:ts=8:sw=8:noet:ai:
-/*
-  Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
-*/
-
-//#include &quot;config.h&quot;
-
-#include &lt;stdlib.h&gt;
-#include &lt;stdio.h&gt;
-#include &lt;assert.h&gt;
-#include &lt;string.h&gt;
-#include &lt;sys/types.h&gt;
-#include &lt;sys/stat.h&gt;
-#include &lt;inttypes.h&gt;
-#include &lt;ft2build.h&gt;
-#include FT_FREETYPE_H
-
-#include &quot;mputils.h&quot;
-#include &quot;ass.h&quot;
-#include &quot;ass_library.h&quot;
-#include &quot;ass_fontconfig.h&quot;
-
-#ifdef HAVE_FONTCONFIG
-#include &lt;fontconfig/fontconfig.h&gt;
-#include &lt;fontconfig/fcfreetype.h&gt;
-#endif
-
-struct fc_instance_s {
-#ifdef HAVE_FONTCONFIG
-	FcConfig* config;
-#endif
-	char* family_default;
-	char* path_default;
-	int index_default;
-};
-
-#ifdef HAVE_FONTCONFIG
-/**
- * \brief Low-level font selection.
- * \param priv private data
- * \param family font family
- * \param bold font weight value
- * \param italic font slant value
- * \param index out: font index inside a file
- * \param code: the character that should be present in the font, can be 0
- * \return font file path
-*/ 
-static char* _select_font(fc_instance_t* priv, const char* family, unsigned bold, unsigned italic, int* index,
-			  uint32_t code)
-{
-	FcBool rc;
-	FcResult result;
-	FcPattern *pat = 0, *rpat;
-	int val_i;
-	FcChar8* val_s;
-	FcBool val_b;
-	FcCharSet* val_cs;
-	FcFontSet* fset = 0;
-	int curf;
-	char* retval = 0;
-	
-	*index = 0;
-
-	pat = FcPatternCreate();
-	if (!pat)
-		goto error;
-	
-	FcPatternAddString(pat, FC_FAMILY, (const FcChar8*)family);
-	FcPatternAddBool(pat, FC_OUTLINE, FcTrue);
-	FcPatternAddInteger(pat, FC_SLANT, italic);
-	FcPatternAddInteger(pat, FC_WEIGHT, bold);
-
-	FcDefaultSubstitute(pat);
-	
-	rc = FcConfigSubstitute(priv-&gt;config, pat, FcMatchPattern);
-	if (!rc)
-		goto error;
-
-	fset = FcFontSort(priv-&gt;config, pat, FcTrue, NULL, &amp;result);
-
-	for (curf = 0; curf &lt; fset-&gt;nfont; ++curf) {
-		rpat = fset-&gt;fonts[curf];
-		
-		result = FcPatternGetBool(rpat, FC_OUTLINE, 0, &amp;val_b);
-		if (result != FcResultMatch)
-			continue;
-		if (val_b != FcTrue)
-			continue;
-		if (!code)
-			break;
-		result = FcPatternGetCharSet(rpat, FC_CHARSET, 0, &amp;val_cs);
-		if (result != FcResultMatch)
-			continue;
-		if (FcCharSetHasChar(val_cs, code))
-			break;
-	}
-
-	if (curf &gt;= fset-&gt;nfont)
-		goto error;
-
-	rpat = fset-&gt;fonts[curf];
-	
-	result = FcPatternGetInteger(rpat, FC_INDEX, 0, &amp;val_i);
-	if (result != FcResultMatch)
-		goto error;
-	*index = val_i;
-
-	result = FcPatternGetString(rpat, FC_FAMILY, 0, &amp;val_s);
-	if (result != FcResultMatch)
-		goto error;
-
-	if (strcasecmp((const char*)val_s, family) != 0)
-		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_SelectedFontFamilyIsNotTheRequestedOne,
-				(const char*)val_s, family);
-
-	result = FcPatternGetString(rpat, FC_FILE, 0, &amp;val_s);
-	if (result != FcResultMatch)
-		goto error;
-	
-	retval = strdup((const char*)val_s);
- error:
-	if (pat) FcPatternDestroy(pat);
-	if (fset) FcFontSetDestroy(fset);
-	return retval;
-}
-
-/**
- * \brief Find a font. Use default family or path if necessary.
- * \param priv_ private data
- * \param family font family
- * \param bold font weight value
- * \param italic font slant value
- * \param index out: font index inside a file
- * \param code: the character that should be present in the font, can be 0
- * \return font file path
-*/ 
-char* fontconfig_select(fc_instance_t* priv, const char* family, unsigned bold, unsigned italic, int* index,
-			uint32_t code)
-{
-	char* res = 0;
-	if (family &amp;&amp; *family)
-		res = _select_font(priv, family, bold, italic, index, code);
-	if (!res &amp;&amp; priv-&gt;family_default) {
-		res = _select_font(priv, priv-&gt;family_default, bold, italic, index, code);
-		if (res)
-			mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_UsingDefaultFontFamily, 
-					family, bold, italic, res, *index);
-	}
-	if (!res &amp;&amp; priv-&gt;path_default) {
-		res = priv-&gt;path_default;
-		*index = priv-&gt;index_default;
-		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_UsingDefaultFont, 
-		       family, bold, italic, res, *index);
-	}
-	if (!res) {
-		res = _select_font(priv, &quot;Arial&quot;, bold, italic, index, code);
-		if (res)
-			mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_UsingArialFontFamily, 
-					family, bold, italic, res, *index);
-	}
-	if (res)
-		mp_msg(MSGT_ASS, MSGL_V, &quot;fontconfig_select: (%s, %d, %d) -&gt; %s, %d\n&quot;, 
-				family, bold, italic, res, *index);
-	return res;
-}
-
-#if (FC_VERSION &lt; 20402)
-static char* validate_fname(char* name)
-{
-	char* fname;
-	char* p;
-	char* q;
-	unsigned code;
-	int sz = strlen(name);
-
-	q = fname = malloc(sz + 1);
-	p = name;
-	while (*p) {
-		code = utf8_get_char(&amp;p);
-		if (code == 0)
-			break;
-		if (	(code &gt; 0x7F) ||
-			(code == '\\') ||
-			(code == '/') ||
-			(code == ':') ||
-			(code == '*') ||
-			(code == '?') ||
-			(code == '&lt;') ||
-			(code == '&gt;') ||
-			(code == '|') ||
-			(code == 0))
-		{
-			*q++ = '_';
-		} else {
-			*q++ = code;
-		}
-		if (p - name &gt; sz)
-			break;
-	}
-	*q = 0;
-	return fname;
-}
-#endif
-
-/**
- * \brief Process memory font.
- * \param priv private data
- * \param library library object
- * \param ftlibrary freetype library object
- * \param idx index of the processed font in library-&gt;fontdata
- * With FontConfig &gt;= 2.4.2, builds a font pattern in memory via FT_New_Memory_Face/FcFreeTypeQueryFace.
- * With older FontConfig versions, save the font to ~/.mplayer/fonts.
-*/ 
-static void process_fontdata(fc_instance_t* priv, ass_library_t* library, FT_Library ftlibrary, int idx)
-{
-	int rc;
-	const char* name = library-&gt;fontdata[idx].name;
-	const char* data = library-&gt;fontdata[idx].data;
-	int data_size = library-&gt;fontdata[idx].size;
-
-#if (FC_VERSION &lt; 20402)
-	struct stat st;
-	char* fname;
-	const char* fonts_dir = library-&gt;fonts_dir;
-	char buf[1000];
-	FILE* fp = 0;
-
-	if (!fonts_dir)
-		return;
-	rc = stat(fonts_dir, &amp;st);
-	if (rc) {
-		int res;
-#ifndef __MINGW32__
-		res = mkdir(fonts_dir, 0700);
-#else
-		res = mkdir(fonts_dir);
-#endif
-		if (res) {
-			mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FailedToCreateDirectory, fonts_dir);
-		}
-	} else if (!S_ISDIR(st.st_mode)) {
-		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_NotADirectory, fonts_dir);
-	}
-	
-	fname = validate_fname((char*)name);
-
-	snprintf(buf, 1000, &quot;%s/%s&quot;, fonts_dir, fname);
-	free(fname);
-
-	fp = fopen(buf, &quot;wb&quot;);
-	if (!fp) return;
-
-	fwrite(data, data_size, 1, fp);
-	fclose(fp);
-
-#else // (FC_VERSION &gt;= 20402)
-	FT_Face face;
-	FcPattern* pattern;
-	FcFontSet* fset;
-	FcBool res;
-
-	rc = FT_New_Memory_Face(ftlibrary, (unsigned char*)data, data_size, 0, &amp;face);
-	if (rc) {
-		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_ErrorOpeningMemoryFont, name);
-		return;
-	}
-
-	pattern = FcFreeTypeQueryFace(face, (unsigned char*)name, 0, FcConfigGetBlanks(priv-&gt;config));
-	if (!pattern) {
-		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FunctionCallFailed, &quot;FcFreeTypeQueryFace&quot;);
-		FT_Done_Face(face);
-		return;
-	}
-
-	fset = FcConfigGetFonts(priv-&gt;config, FcSetSystem); // somehow it failes when asked for FcSetApplication
-	if (!fset) {
-		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FunctionCallFailed, &quot;FcConfigGetFonts&quot;);
-		FT_Done_Face(face);
-		return;
-	}
-
-	res = FcFontSetAdd(fset, pattern);
-	if (!res) {
-		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FunctionCallFailed, &quot;FcFontSetAdd&quot;);
-		FT_Done_Face(face);
-		return;
-	}
-
-	FT_Done_Face(face);
-#endif
-}
-
-/**
- * \brief Init fontconfig.
- * \param library libass library object
- * \param ftlibrary freetype library object
- * \param family default font family
- * \param path default font path
- * \return pointer to fontconfig private data
-*/ 
-fc_instance_t* fontconfig_init(ass_library_t* library, FT_Library ftlibrary, const char* family, const char* path)
-{
-	int rc;
-	fc_instance_t* priv = calloc(1, sizeof(fc_instance_t));
-	const char* dir = library-&gt;fonts_dir;
-	int i;
-	
-	rc = FcInit();
-	assert(rc);
-
-	priv-&gt;config = FcConfigGetCurrent();
-	if (!priv-&gt;config) {
-		mp_msg(MSGT_ASS, MSGL_FATAL, MSGTR_LIBASS_FcInitLoadConfigAndFontsFailed);
-		return 0;
-	}
-
-	for (i = 0; i &lt; library-&gt;num_fontdata; ++i)
-		process_fontdata(priv, library, ftlibrary, i);
-
-	if (FcDirCacheValid((const FcChar8 *)dir) == FcFalse)
-	{
-		mp_msg(MSGT_ASS, MSGL_INFO, MSGTR_LIBASS_UpdatingFontCache);
-		if (FcGetVersion() &gt;= 20390 &amp;&amp; FcGetVersion() &lt; 20400)
-			mp_msg(MSGT_ASS, MSGL_WARN,
-			       MSGTR_LIBASS_BetaVersionsOfFontconfigAreNotSupported);
-		// FontConfig &gt;= 2.4.0 updates cache automatically in FcConfigAppFontAddDir()
-		if (FcGetVersion() &lt; 20390) {
-			FcFontSet* fcs;
-			FcStrSet* fss;
-			fcs = FcFontSetCreate();
-			fss = FcStrSetCreate();
-			rc = FcStrSetAdd(fss, (const FcChar8*)dir);
-			if (!rc) {
-				mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FcStrSetAddFailed);
-				goto ErrorFontCache;
-			}
-
-			rc = FcDirScan(fcs, fss, NULL, FcConfigGetBlanks(priv-&gt;config), (const FcChar8 *)dir, FcFalse);
-			if (!rc) {
-				mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FcDirScanFailed);
-				goto ErrorFontCache;
-			}
-
-			rc = FcDirSave(fcs, fss, (const FcChar8 *)dir);
-			if (!rc) {
-				mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FcDirSave);
-				goto ErrorFontCache;
-			}
-		ErrorFontCache:
-			;
-		}
-	}
-
-	rc = FcConfigAppFontAddDir(priv-&gt;config, (const FcChar8*)dir);
-	if (!rc) {
-		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FcConfigAppFontAddDirFailed);
-	}
-
-	priv-&gt;family_default = family ? strdup(family) : 0;
-	priv-&gt;path_default = path ? strdup(path) : 0;
-	priv-&gt;index_default = 0;
-
-	return priv;
-}
-
-#else // HAVE_FONTCONFIG
-
-char* fontconfig_select(fc_instance_t* priv, const char* family, unsigned bold, unsigned italic, int* index,
-			uint32_t code)
-{
-	*index = priv-&gt;index_default;
-	return priv-&gt;path_default;
-}
-
-fc_instance_t* fontconfig_init(ass_library_t* library, FT_Library ftlibrary, const char* family, const char* path)
-{
-	fc_instance_t* priv;
-
-	mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FontconfigDisabledDefaultFontWillBeUsed);
-	
-	priv = calloc(1, sizeof(fc_instance_t));
-	
-	priv-&gt;path_default = strdup(path);
-	priv-&gt;index_default = 0;
-	return priv;
-}
-
-#endif
-
-void fontconfig_done(fc_instance_t* priv)
-{
-	// don't call FcFini() here, library can still be used by some code
-	if (priv &amp;&amp; priv-&gt;path_default) free(priv-&gt;path_default);
-	if (priv &amp;&amp; priv-&gt;family_default) free(priv-&gt;family_default);
-	if (priv) free(priv);
-}
-
-

Deleted: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_fontconfig.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_fontconfig.h	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_fontconfig.h	2009-08-01 07:55:22 UTC (rev 5185)
@@ -1,35 +0,0 @@
-// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
-// vim:ts=8:sw=8:noet:ai:
-/*
-  Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
-*/
-
-#ifndef ASS_FONTCONFIG_H
-#define ASS_FONTCONFIG_H
-
-#ifdef HAVE_FONTCONFIG
-#include &lt;fontconfig/fontconfig.h&gt;
-#endif
-
-typedef struct fc_instance_s fc_instance_t;
-
-fc_instance_t* fontconfig_init(ass_library_t* library, FT_Library ftlibrary, const char* family, const char* path);
-char* fontconfig_select(fc_instance_t* priv, const char* family, unsigned bold, unsigned italic, int* index, uint32_t code);
-void fontconfig_done(fc_instance_t* priv);
-
-#endif
-

Deleted: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_library.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_library.c	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_library.c	2009-08-01 07:55:22 UTC (rev 5185)
@@ -1,93 +0,0 @@
-// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
-// vim:ts=8:sw=8:noet:ai:
-/*
-  Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
-*/
-
-#include &lt;inttypes.h&gt;
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-
-#include &quot;ass.h&quot;
-#include &quot;ass_library.h&quot;
-
-
-ass_library_t* ass_library_init(void)
-{
-	return calloc(1, sizeof(ass_library_t));
-}
-
-void ass_library_done(ass_library_t* priv)
-{
-	if (priv) {
-		ass_set_fonts_dir(priv, NULL);
-		ass_set_style_overrides(priv, NULL);
-		free(priv);
-	}
-}
-
-void ass_set_fonts_dir(ass_library_t* priv, const char* fonts_dir)
-{
-	if (priv-&gt;fonts_dir)
-		free(priv-&gt;fonts_dir);
-
-	priv-&gt;fonts_dir = fonts_dir ? strdup(fonts_dir) : 0;
-}
-
-void ass_set_extract_fonts(ass_library_t* priv, int extract)
-{
-	priv-&gt;extract_fonts = !!extract;
-}
-
-void ass_set_style_overrides(ass_library_t* priv, char** list)
-{
-	char** p;
-	char** q;
-	int cnt;
-	
-	if (priv-&gt;style_overrides) {
-		for (p = priv-&gt;style_overrides; *p; ++p)
-			free(*p);
-		free(priv-&gt;style_overrides);
-	}
-	
-	if (!list) return;
-
-	for (p = list, cnt = 0; *p; ++p, ++cnt) {}
-
-	priv-&gt;style_overrides = malloc((cnt + 1) * sizeof(char*));
-	for (p = list, q = priv-&gt;style_overrides; *p; ++p, ++q)
-		*q = strdup(*p);
-	priv-&gt;style_overrides[cnt] = NULL;
-}
-
-static void grow_array(void **array, int nelem, size_t elsize)
-{
-	if (!(nelem &amp; 31))
-		*array = realloc(*array, (nelem + 32) * elsize);
-}
-
-void ass_add_font(ass_library_t* priv, char* name, char* data, int size)
-{
-	grow_array((void**)&amp;priv-&gt;fontdata, priv-&gt;num_fontdata, sizeof(*priv-&gt;fontdata));
-	priv-&gt;fontdata[priv-&gt;num_fontdata].name = name;
-	priv-&gt;fontdata[priv-&gt;num_fontdata].data = data;
-	priv-&gt;fontdata[priv-&gt;num_fontdata].size = size;
-	priv-&gt;num_fontdata ++;
-}
-

Deleted: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_library.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_library.h	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_library.h	2009-08-01 07:55:22 UTC (rev 5185)
@@ -1,40 +0,0 @@
-// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
-// vim:ts=8:sw=8:noet:ai:
-/*
-  Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
-*/
-
-#ifndef ASS_LIBRARY_H
-#define ASS_LIBRARY_H
-
-typedef struct ass_fontdata_s {
-	char* name;
-	char* data;
-	int size;
-} ass_fontdata_t;
-
-struct ass_library_s {
-	char* fonts_dir;
-	int extract_fonts;
-	char** style_overrides;
-
-	ass_fontdata_t* fontdata;
-	int num_fontdata;
-};
-
-#endif
-

Deleted: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_render.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_render.c	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_render.c	2009-08-01 07:55:22 UTC (rev 5185)
@@ -1,2399 +0,0 @@
-// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
-// vim:ts=8:sw=8:noet:ai:
-/*
-  Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
-*/
-
-//#include &quot;config.h&quot;
-
-#include &lt;assert.h&gt;
-#include &lt;math.h&gt;
-#include &lt;inttypes.h&gt;
-#include &lt;ft2build.h&gt;
-#include FT_FREETYPE_H
-#include FT_STROKER_H
-#include FT_GLYPH_H
-#include FT_SYNTHESIS_H
-
-#include &quot;mputils.h&quot;
-
-#include &quot;ass.h&quot;
-#include &quot;ass_font.h&quot;
-#include &quot;ass_bitmap.h&quot;
-#include &quot;ass_cache.h&quot;
-#include &quot;ass_utils.h&quot;
-#include &quot;ass_fontconfig.h&quot;
-#include &quot;ass_library.h&quot;
-
-#define MAX_GLYPHS 1000
-#define MAX_LINES 100
-
-static int last_render_id = 0;
-
-typedef struct ass_settings_s {
-	int frame_width;
-	int frame_height;
-	double font_size_coeff; // font size multiplier
-	double line_spacing; // additional line spacing (in frame pixels)
-	int top_margin; // height of top margin. Everything except toptitles is shifted down by top_margin.
-	int bottom_margin; // height of bottom margin. (frame_height - top_margin - bottom_margin) is original video height.
-	int left_margin;
-	int right_margin;
-	int use_margins; // 0 - place all subtitles inside original frame
-	                 // 1 - use margins for placing toptitles and subtitles
-	double aspect; // frame aspect ratio, d_width / d_height.
-	ass_hinting_t hinting;
-
-	char* default_font;
-	char* default_family;
-} ass_settings_t;
-
-// a rendered event
-typedef struct event_images_s {
-	ass_image_t* imgs;
-	int top, height;
-	int detect_collisions;
-	int shift_direction;
-	ass_event_t* event;
-} event_images_t;
-
-struct ass_renderer_s {
-	ass_library_t* library;
-	FT_Library ftlibrary;
-	fc_instance_t* fontconfig_priv;
-	ass_settings_t settings;
-	int render_id;
-	ass_synth_priv_t* synth_priv;
-
-	ass_image_t* images_root; // rendering result is stored here
-	ass_image_t* prev_images_root;
-
-	event_images_t* eimg; // temporary buffer for sorting rendered events
-	int eimg_size; // allocated buffer size
-};
-
-typedef enum {EF_NONE = 0, EF_KARAOKE, EF_KARAOKE_KF, EF_KARAOKE_KO} effect_t;
-
-// describes a glyph
-// glyph_info_t and text_info_t are used for text centering and word-wrapping operations
-typedef struct glyph_info_s {
-	unsigned symbol;
-	FT_Glyph glyph;
-	FT_Glyph outline_glyph;
-	bitmap_t* bm; // glyph bitmap
-	bitmap_t* bm_o; // outline bitmap
-	bitmap_t* bm_s; // shadow bitmap
-	FT_BBox bbox;
-	FT_Vector pos;
-	char linebreak; // the first (leading) glyph of some line ?
-	uint32_t c[4]; // colors
-	FT_Vector advance; // 26.6
-	effect_t effect_type;
-	int effect_timing; // time duration of current karaoke word
-	                   // after process_karaoke_effects: distance in pixels from the glyph origin.
-	                   // part of the glyph to the left of it is displayed in a different color.
-	int effect_skip_timing; // delay after the end of last karaoke word
-	int asc, desc; // font max ascender and descender
-//	int height;
-	int be; // blur edges
-	int shadow;
-	double frx, fry, frz; // rotation
-	
-	bitmap_hash_key_t hash_key;
-} glyph_info_t;
-
-typedef struct line_info_s {
-	int asc, desc;
-} line_info_t;
-
-typedef struct text_info_s {
-	glyph_info_t* glyphs;
-	int length;
-	line_info_t lines[MAX_LINES];
-	int n_lines;
-	int height;
-} text_info_t;
-
-
-// Renderer state.
-// Values like current font face, color, screen position, clipping and so on are stored here.
-typedef struct render_context_s {
-	ass_event_t* event;
-	ass_style_t* style;
-	
-	ass_font_t* font;
-	char* font_path;
-	double font_size;
-	
-	FT_Stroker stroker;
-	int alignment; // alignment overrides go here; if zero, style value will be used
-	double frx, fry, frz;
-	enum {	EVENT_NORMAL, // &quot;normal&quot; top-, sub- or mid- title
-		EVENT_POSITIONED, // happens after pos(,), margins are ignored
-		EVENT_HSCROLL, // &quot;Banner&quot; transition effect, text_width is unlimited
-		EVENT_VSCROLL // &quot;Scroll up&quot;, &quot;Scroll down&quot; transition effects
-		} evt_type;
-	int pos_x, pos_y; // position
-	int org_x, org_y; // origin
-	char have_origin; // origin is explicitly defined; if 0, get_base_point() is used
-	double scale_x, scale_y;
-	double hspacing; // distance between letters, in pixels
-	double border; // outline width
-	uint32_t c[4]; // colors(Primary, Secondary, so on) in RGBA
-	int clip_x0, clip_y0, clip_x1, clip_y1;
-	char detect_collisions;
-	uint32_t fade; // alpha from \fad
-	char be; // blur edges
-	int shadow;
-
-	effect_t effect_type;
-	int effect_timing;
-	int effect_skip_timing;
-
-	enum { SCROLL_LR, // left-to-right
-	       SCROLL_RL,
-	       SCROLL_TB, // top-to-bottom
-	       SCROLL_BT
-	       } scroll_direction; // for EVENT_HSCROLL, EVENT_VSCROLL
-	int scroll_shift;
-
-	// face properties
-	char* family;
-	unsigned bold;
-	unsigned italic;
-	
-} render_context_t;
-
-// frame-global data
-typedef struct frame_context_s {
-	ass_renderer_t* ass_priv;
-	int width, height; // screen dimensions
-	int orig_height; // frame height ( = screen height - margins )
-	int orig_width; // frame width ( = screen width - margins )
-	ass_track_t* track;
-	long long time; // frame's timestamp, ms
-	double font_scale;
-	double font_scale_x; // x scale applied to all glyphs to preserve text aspect ratio
-	double border_scale;
-} frame_context_t;
-
-static ass_renderer_t* ass_renderer;
-static ass_settings_t* global_settings;
-static text_info_t text_info;
-static render_context_t render_context;
-static frame_context_t frame_context;
-
-struct render_priv_s {
-	int top, height;
-	int render_id;
-};
-
-static void ass_lazy_track_init(void)
-{
-	ass_track_t* track = frame_context.track;
-	if (track-&gt;PlayResX &amp;&amp; track-&gt;PlayResY)
-		return;
-	if (!track-&gt;PlayResX &amp;&amp; !track-&gt;PlayResY) {
-		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_NeitherPlayResXNorPlayResYDefined);
-		track-&gt;PlayResX = 384;
-		track-&gt;PlayResY = 288;
-	} else {
-		double orig_aspect = (global_settings-&gt;aspect * frame_context.height * frame_context.orig_width) /
-			frame_context.orig_height / frame_context.width;
-		if (!track-&gt;PlayResY) {
-			track-&gt;PlayResY = track-&gt;PlayResX / orig_aspect + .5;
-			mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_PlayResYUndefinedSettingY, track-&gt;PlayResY);
-		} else if (!track-&gt;PlayResX) {
-			track-&gt;PlayResX = track-&gt;PlayResY * orig_aspect + .5;
-			mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_PlayResXUndefinedSettingX, track-&gt;PlayResX);
-		}
-	}
-}
-
-ass_renderer_t* ass_renderer_init(ass_library_t* library)
-{
-	int error;
-	FT_Library ft;
-	ass_renderer_t* priv = 0;
-	
-	memset(&amp;render_context, 0, sizeof(render_context));
-	memset(&amp;frame_context, 0, sizeof(frame_context));
-	memset(&amp;text_info, 0, sizeof(text_info));
-
-	error = FT_Init_FreeType( &amp;ft );
-	if ( error ) { 
-		mp_msg(MSGT_ASS, MSGL_FATAL, MSGTR_LIBASS_FT_Init_FreeTypeFailed);
-		goto ass_init_exit;
-	}
-
-	priv = calloc(1, sizeof(ass_renderer_t));
-	if (!priv) {
-		FT_Done_FreeType(ft);
-		goto ass_init_exit;
-	}
-
-	priv-&gt;synth_priv = ass_synth_init();
-
-	priv-&gt;library = library;
-	priv-&gt;ftlibrary = ft;
-	// images_root and related stuff is zero-filled in calloc
-	
-	ass_font_cache_init();
-	ass_bitmap_cache_init();
-	ass_glyph_cache_init();
-
-	text_info.glyphs = calloc(MAX_GLYPHS, sizeof(glyph_info_t));
-	
-ass_init_exit:
-	if (priv) mp_msg(MSGT_ASS, MSGL_INFO, MSGTR_LIBASS_Init);
-	else mp_msg(MSGT_ASS, MSGL_ERR, MSGTR_LIBASS_InitFailed);
-
-	return priv;
-}
-
-void ass_renderer_done(ass_renderer_t* priv)
-{
-	ass_font_cache_done();
-	ass_bitmap_cache_done();
-	ass_glyph_cache_done();
-	if (render_context.stroker) {
-		FT_Stroker_Done(render_context.stroker);
-		render_context.stroker = 0;
-	}
-	if (priv &amp;&amp; priv-&gt;ftlibrary) FT_Done_FreeType(priv-&gt;ftlibrary);
-	if (priv &amp;&amp; priv-&gt;fontconfig_priv) fontconfig_done(priv-&gt;fontconfig_priv);
-	if (priv &amp;&amp; priv-&gt;synth_priv) ass_synth_done(priv-&gt;synth_priv);
-	if (priv &amp;&amp; priv-&gt;eimg) free(priv-&gt;eimg);
-	if (priv) free(priv);
-	if (text_info.glyphs) free(text_info.glyphs);
-}
-
-/**
- * \brief Create a new ass_image_t
- * Parameters are the same as ass_image_t fields.
- */
-static ass_image_t* my_draw_bitmap(unsigned char* bitmap, int bitmap_w, int bitmap_h, int stride, int dst_x, int dst_y, uint32_t color)
-{
-	ass_image_t* img = calloc(1, sizeof(ass_image_t));
-	
-	img-&gt;w = bitmap_w;
-	img-&gt;h = bitmap_h;
-	img-&gt;stride = stride;
-	img-&gt;bitmap = bitmap;
-	img-&gt;color = color;
-	img-&gt;dst_x = dst_x;
-	img-&gt;dst_y = dst_y;
-
-	return img;
-}
-
-/**
- * \brief convert bitmap glyph into ass_image_t struct(s)
- * \param bit freetype bitmap glyph, FT_PIXEL_MODE_GRAY
- * \param dst_x bitmap x coordinate in video frame
- * \param dst_y bitmap y coordinate in video frame
- * \param color first color, RGBA
- * \param color2 second color, RGBA
- * \param brk x coordinate relative to glyph origin, color is used to the left of brk, color2 - to the right
- * \param tail pointer to the last image's next field, head of the generated list should be stored here
- * \return pointer to the new list tail
- * Performs clipping. Uses my_draw_bitmap for actual bitmap convertion.
- */
-static ass_image_t** render_glyph(bitmap_t* bm, int dst_x, int dst_y, uint32_t color, uint32_t color2, int brk, ass_image_t** tail)
-{
-	// brk is relative to dst_x
-	// color = color left of brk
-	// color2 = color right of brk
-	int b_x0, b_y0, b_x1, b_y1; // visible part of the bitmap
-	int clip_x0, clip_y0, clip_x1, clip_y1;
-	int tmp;
-	ass_image_t* img;
-
-	dst_x += bm-&gt;left;
-	dst_y += bm-&gt;top;
-	brk -= bm-&gt;left;
-	
-	// clipping
-	clip_x0 = render_context.clip_x0;
-	clip_y0 = render_context.clip_y0;
-	clip_x1 = render_context.clip_x1;
-	clip_y1 = render_context.clip_y1;
-	b_x0 = 0;
-	b_y0 = 0;
-	b_x1 = bm-&gt;w;
-	b_y1 = bm-&gt;h;
-	
-	tmp = dst_x - clip_x0;
-	if (tmp &lt; 0) {
-		mp_msg(MSGT_ASS, MSGL_DBG2, &quot;clip left\n&quot;);
-		b_x0 = - tmp;
-	}
-	tmp = dst_y - clip_y0;
-	if (tmp &lt; 0) {
-		mp_msg(MSGT_ASS, MSGL_DBG2, &quot;clip top\n&quot;);
-		b_y0 = - tmp;
-	}
-	tmp = clip_x1 - dst_x - bm-&gt;w;
-	if (tmp &lt; 0) {
-		mp_msg(MSGT_ASS, MSGL_DBG2, &quot;clip right\n&quot;);
-		b_x1 = bm-&gt;w + tmp;
-	}
-	tmp = clip_y1 - dst_y - bm-&gt;h;
-	if (tmp &lt; 0) {
-		mp_msg(MSGT_ASS, MSGL_DBG2, &quot;clip bottom\n&quot;);
-		b_y1 = bm-&gt;h + tmp;
-	}
-	
-	if ((b_y0 &gt;= b_y1) || (b_x0 &gt;= b_x1))
-		return tail;
-
-	if (brk &gt; b_x0) { // draw left part
-		if (brk &gt; b_x1) brk = b_x1;
-		img = my_draw_bitmap(bm-&gt;buffer + bm-&gt;w * b_y0 + b_x0, 
-			brk - b_x0, b_y1 - b_y0, bm-&gt;w,
-			dst_x + b_x0, dst_y + b_y0, color);
-		*tail = img;
-		tail = &amp;img-&gt;next;
-	}
-	if (brk &lt; b_x1) { // draw right part
-		if (brk &lt; b_x0) brk = b_x0;
-		img = my_draw_bitmap(bm-&gt;buffer + bm-&gt;w * b_y0 + brk, 
-			b_x1 - brk, b_y1 - b_y0, bm-&gt;w,
-			dst_x + brk, dst_y + b_y0, color2);
-		*tail = img;
-		tail = &amp;img-&gt;next;
-	}
-	return tail;
-}
-
-/**
- * \brief Convert text_info_t struct to ass_image_t list
- * Splits glyphs in halves when needed (for \kf karaoke).
- */
-static ass_image_t* render_text(text_info_t* text_info, int dst_x, int dst_y)
-{
-	int pen_x, pen_y;
-	int i;
-	bitmap_t* bm;
-	ass_image_t* head;
-	ass_image_t** tail = &head;
-
-	for (i = 0; i &lt; text_info-&gt;length; ++i) {
-		glyph_info_t* info = text_info-&gt;glyphs + i;
-		if ((info-&gt;symbol == 0) || (info-&gt;symbol == '\n') || !info-&gt;bm_s || (info-&gt;shadow == 0))
-			continue;
-
-		pen_x = dst_x + info-&gt;pos.x + info-&gt;shadow;
-		pen_y = dst_y + info-&gt;pos.y + info-&gt;shadow;
-		bm = info-&gt;bm_s;
-
-		tail = render_glyph(bm, pen_x, pen_y, info-&gt;c[3], 0, 1000000, tail);
-	}
-
-	for (i = 0; i &lt; text_info-&gt;length; ++i) {
-		glyph_info_t* info = text_info-&gt;glyphs + i;
-		if ((info-&gt;symbol == 0) || (info-&gt;symbol == '\n') || !info-&gt;bm_o)
-			continue;
-
-		pen_x = dst_x + info-&gt;pos.x;
-		pen_y = dst_y + info-&gt;pos.y;
-		bm = info-&gt;bm_o;
-		
-		if ((info-&gt;effect_type == EF_KARAOKE_KO) &amp;&amp; (info-&gt;effect_timing &lt;= info-&gt;bbox.xMax)) {
-			// do nothing
-		} else
-			tail = render_glyph(bm, pen_x, pen_y, info-&gt;c[2], 0, 1000000, tail);
-	}
-	for (i = 0; i &lt; text_info-&gt;length; ++i) {
-		glyph_info_t* info = text_info-&gt;glyphs + i;
-		if ((info-&gt;symbol == 0) || (info-&gt;symbol == '\n') || !info-&gt;bm)
-			continue;
-
-		pen_x = dst_x + info-&gt;pos.x;
-		pen_y = dst_y + info-&gt;pos.y;
-		bm = info-&gt;bm;
-
-		if ((info-&gt;effect_type == EF_KARAOKE) || (info-&gt;effect_type == EF_KARAOKE_KO)) {
-			if (info-&gt;effect_timing &gt; info-&gt;bbox.xMax)
-				tail = render_glyph(bm, pen_x, pen_y, info-&gt;c[0], 0, 1000000, tail);
-			else
-				tail = render_glyph(bm, pen_x, pen_y, info-&gt;c[1], 0, 1000000, tail);
-		} else if (info-&gt;effect_type == EF_KARAOKE_KF) {
-			tail = render_glyph(bm, pen_x, pen_y, info-&gt;c[0], info-&gt;c[1], info-&gt;effect_timing, tail);
-		} else
-			tail = render_glyph(bm, pen_x, pen_y, info-&gt;c[0], 0, 1000000, tail);
-	}
-
-	*tail = 0;
-	return head;
-}
-
-/**
- * \brief Mapping between script and screen coordinates
- */
-static int x2scr(int x) {
-	return x*frame_context.orig_width / frame_context.track-&gt;PlayResX + global_settings-&gt;left_margin;
-}
-/**
- * \brief Mapping between script and screen coordinates
- */
-static int y2scr(int y) {
-	return y * frame_context.orig_height / frame_context.track-&gt;PlayResY + global_settings-&gt;top_margin;
-}
-// the same for toptitles
-static int y2scr_top(int y) {
-	if (global_settings-&gt;use_margins)
-		return y * frame_context.orig_height / frame_context.track-&gt;PlayResY;
-	else
-		return y * frame_context.orig_height / frame_context.track-&gt;PlayResY + global_settings-&gt;top_margin;
-}
-// the same for subtitles
-static int y2scr_sub(int y) {
-	if (global_settings-&gt;use_margins)
-		return y * frame_context.orig_height / frame_context.track-&gt;PlayResY +
-		       global_settings-&gt;top_margin + global_settings-&gt;bottom_margin;
-	else
-		return y * frame_context.orig_height / frame_context.track-&gt;PlayResY + global_settings-&gt;top_margin;
-}
-
-static void compute_string_bbox( text_info_t* info, FT_BBox *abbox ) {
-	FT_BBox bbox;
-	int i;
-	
-	if (text_info.length &gt; 0) {
-		bbox.xMin = 32000;
-		bbox.xMax = -32000;
-		bbox.yMin = - d6_to_int(text_info.lines[0].asc) + text_info.glyphs[0].pos.y;
-		bbox.yMax = d6_to_int(text_info.height - text_info.lines[0].asc) + text_info.glyphs[0].pos.y;
-
-		for (i = 0; i &lt; text_info.length; ++i) {
-			int s = text_info.glyphs[i].pos.x;
-			int e = s + d6_to_int(text_info.glyphs[i].advance.x);
-			bbox.xMin = FFMIN(bbox.xMin, s);
-			bbox.xMax = FFMAX(bbox.xMax, e);
-		}
-	} else
-		bbox.xMin = bbox.xMax = bbox.yMin = bbox.yMax = 0;
-
-	/* return string bbox */
-	*abbox = bbox;
-}
-
-
-/**
- * \brief Check if starting part of (*p) matches sample. If true, shift p to the first symbol after the matching part.
- */
-static inline int mystrcmp(char** p, const char* sample) {
-	int len = strlen(sample);
-	if (strncmp(*p, sample, len) == 0) {
-		(*p) += len;
-		return 1;
-	} else
-		return 0;
-}
-
-static void change_font_size(double sz)
-{
-	double size = sz * frame_context.font_scale;
-
-	if (size &lt; 1)
-		size = 1;
-	else if (size &gt; frame_context.height * 2)
-		size = frame_context.height * 2;
-
-	ass_font_set_size(render_context.font, size);
-
-	render_context.font_size = sz;
-}
-
-/**
- * \brief Change current font, using setting from render_context.
- */
-static void update_font(void)
-{
-	unsigned val;
-	ass_renderer_t* priv = frame_context.ass_priv;
-	ass_font_desc_t desc;
-	desc.family = strdup(render_context.family);
-
-	val = render_context.bold;
-	// 0 = normal, 1 = bold, &gt;1 = exact weight
-	if (val == 0) val = 80; // normal
-	else if (val == 1) val = 200; // bold
-	desc.bold = val;
-
-	val = render_context.italic;
-	if (val == 0) val = 0; // normal
-	else if (val == 1) val = 110; //italic
-	desc.italic = val;
-
-	render_context.font = ass_font_new(priv-&gt;library, priv-&gt;ftlibrary, priv-&gt;fontconfig_priv, &amp;desc);
-	free(desc.family);
-	
-	if (render_context.font)
-		change_font_size(render_context.font_size);
-}
-
-/**
- * \brief Change border width
- * negative value resets border to style value
- */
-static void change_border(double border)
-{
-	int b;
-	if (!render_context.font) return;
-
-	if (border &lt; 0) {
-		if (render_context.style-&gt;BorderStyle == 1) {
-			if (render_context.style-&gt;Outline == 0 &amp;&amp; render_context.style-&gt;Shadow &gt; 0)
-				border = 1.;
-			else
-				border = render_context.style-&gt;Outline;
-		} else
-			border = 1.;
-	}
-	render_context.border = border;
-
-	b = 64 * border * frame_context.border_scale;
-	if (b &gt; 0) {
-		if (!render_context.stroker) {
-			int error;
-#if (FREETYPE_MAJOR &gt; 2) || ((FREETYPE_MAJOR == 2) &amp;&amp; (FREETYPE_MINOR &gt; 1))
-			error = FT_Stroker_New( ass_renderer-&gt;ftlibrary, &amp;render_context.stroker );
-#else // &lt; 2.2
-			error = FT_Stroker_New( render_context.font-&gt;faces[0]-&gt;memory, &amp;render_context.stroker );
-#endif
-			if (error) {
-				mp_msg(MSGT_ASS, MSGL_V, &quot;failed to get stroker\n&quot;);
-				render_context.stroker = 0;
-			}
-		}
-		if (render_context.stroker)
-			FT_Stroker_Set( render_context.stroker, b,
-					FT_STROKER_LINECAP_ROUND,
-					FT_STROKER_LINEJOIN_ROUND,
-					0 );
-	} else {
-		FT_Stroker_Done(render_context.stroker);
-		render_context.stroker = 0;
-	}
-}
-
-#define _r(c)  ((c)&gt;&gt;24)
-#define _g(c)  (((c)&gt;&gt;16)&amp;0xFF)
-#define _b(c)  (((c)&gt;&gt;8)&amp;0xFF)
-#define _a(c)  ((c)&amp;0xFF)
-
-/**
- * \brief Calculate a weighted average of two colors
- * calculates c1*(1-a) + c2*a, but separately for each component except alpha
- */
-static void change_color(uint32_t* var, uint32_t new, double pwr)
-{
-	(*var)= ((uint32_t)(_r(*var) * (1 - pwr) + _r(new) * pwr) &lt;&lt; 24) +
-		((uint32_t)(_g(*var) * (1 - pwr) + _g(new) * pwr) &lt;&lt; 16) +
-		((uint32_t)(_b(*var) * (1 - pwr) + _b(new) * pwr) &lt;&lt; 8) +
-		_a(*var);
-}
-
-// like change_color, but for alpha component only
-static void change_alpha(uint32_t* var, uint32_t new, double pwr)
-{
-	*var = (_r(*var) &lt;&lt; 24) + (_g(*var) &lt;&lt; 16) + (_b(*var) &lt;&lt; 8) + (_a(*var) * (1 - pwr) + _a(new) * pwr);
-}
-
-/**
- * \brief Multiply two alpha values
- * \param a first value
- * \param b second value
- * \return result of multiplication
- * Parameters and result are limited by 0xFF.
- */
-static uint32_t mult_alpha(uint32_t a, uint32_t b)
-{
-	return 0xFF - (0xFF - a) * (0xFF - b) / 0xFF;
-}
-
-/**
- * \brief Calculate alpha value by piecewise linear function
- * Used for \fad, \fade implementation.
- */
-static unsigned interpolate_alpha(long long now, 
-		long long t1, long long t2, long long t3, long long t4,
-		unsigned a1, unsigned a2, unsigned a3)
-{
-	unsigned a;
-	double cf;
-	if (now &lt;= t1) {
-		a = a1;
-	} else if (now &gt;= t4) {
-		a = a3;
-	} else if (now &lt; t2) { // and &gt; t1
-		cf = ((double)(now - t1)) / (t2 - t1);
-		a = a1 * (1 - cf) + a2 * cf;
-	} else if (now &gt; t3) {
-		cf = ((double)(now - t3)) / (t4 - t3);
-		a = a2 * (1 - cf) + a3 * cf;
-	} else { // t2 &lt;= now &lt;= t3
-		a = a2;
-	}
-
-	return a;
-}
-
-static void reset_render_context(void);
-
-/**
- * \brief Parse style override tag.
- * \param p string to parse
- * \param pwr multiplier for some tag effects (comes from \t tags)
- */
-static char* parse_tag(char* p, double pwr) {
-#define skip_all(x) if (*p == (x)) ++p; else { \
-	while ((*p != (x)) &amp;&amp; (*p != '}') &amp;&amp; (*p != 0)) {++p;} }
-#define skip(x) if (*p == (x)) ++p; else { return p; }
-	
-	skip_all('\\');
-	if ((*p == '}') || (*p == 0))
-		return p;
-
-	if (mystrcmp(&amp;p, &quot;fsc&quot;)) {
-		char tp = *p++;
-		double val;
-		if (tp == 'x') {
-			if (mystrtod(&amp;p, &amp;val)) {
-				val /= 100;
-				render_context.scale_x = render_context.scale_x * ( 1 - pwr) + val * pwr;
-			} else
-				render_context.scale_x = render_context.style-&gt;ScaleX;
-		} else if (tp == 'y') {
-			if (mystrtod(&amp;p, &amp;val)) {
-				val /= 100;
-				render_context.scale_y = render_context.scale_y * ( 1 - pwr) + val * pwr;
-			} else
-				render_context.scale_y = render_context.style-&gt;ScaleY;
-		}
-	} else if (mystrcmp(&amp;p, &quot;fsp&quot;)) {
-		double val;
-		if (mystrtod(&amp;p, &amp;val))
-			render_context.hspacing = render_context.hspacing * ( 1 - pwr ) + val * pwr;
-		else
-			render_context.hspacing = render_context.style-&gt;Spacing;
-	} else if (mystrcmp(&amp;p, &quot;fs&quot;)) {
-		double val;
-		if (mystrtod(&amp;p, &amp;val))
-			val = render_context.font_size * ( 1 - pwr ) + val * pwr;
-		else
-			val = render_context.style-&gt;FontSize;
-		if (render_context.font)
-			change_font_size(val);
-	} else if (mystrcmp(&amp;p, &quot;bord&quot;)) {
-		double val;
-		if (mystrtod(&amp;p, &amp;val))
-			val = render_context.border * ( 1 - pwr ) + val * pwr;
-		else
-			val = -1.; // reset to default
-		change_border(val);
-	} else if (mystrcmp(&amp;p, &quot;move&quot;)) {
-		int x1, x2, y1, y2;
-		long long t1, t2, delta_t, t;
-		int x, y;
-		double k;
-		skip('(');
-		x1 = strtol(p, &amp;p, 10);
-		skip(',');
-		y1 = strtol(p, &amp;p, 10);
-		skip(',');
-		x2 = strtol(p, &amp;p, 10);
-		skip(',');
-		y2 = strtol(p, &amp;p, 10);
-		if (*p == ',') {
-			skip(',');
-			t1 = strtoll(p, &amp;p, 10);
-			skip(',');
-			t2 = strtoll(p, &amp;p, 10);
-			mp_msg(MSGT_ASS, MSGL_DBG2, &quot;movement6: (%d, %d) -&gt; (%d, %d), (%&quot; PRId64 &quot; .. %&quot; PRId64 &quot;)\n&quot;, 
-				x1, y1, x2, y2, (int64_t)t1, (int64_t)t2);
-		} else {
-			t1 = 0;
-			t2 = render_context.event-&gt;Duration;
-			mp_msg(MSGT_ASS, MSGL_DBG2, &quot;movement: (%d, %d) -&gt; (%d, %d)\n&quot;, x1, y1, x2, y2);
-		}
-		skip(')');
-		delta_t = t2 - t1;
-		t = frame_context.time - render_context.event-&gt;Start;
-		if (t &lt; t1)
-			k = 0.;
-		else if (t &gt; t2)
-			k = 1.;
-		else k = ((double)(t - t1)) / delta_t;
-		x = k * (x2 - x1) + x1;
-		y = k * (y2 - y1) + y1;
-		render_context.pos_x = x;
-		render_context.pos_y = y;
-		render_context.detect_collisions = 0;
-		render_context.evt_type = EVENT_POSITIONED;
-	} else if (mystrcmp(&amp;p, &quot;frx&quot;)) {
-		double val;
-		if (mystrtod(&amp;p, &amp;val)) {
-			val *= M_PI / 180;
-			render_context.frx = val * pwr + render_context.frx * (1-pwr);
-		} else
-			render_context.frx = 0.;
-	} else if (mystrcmp(&amp;p, &quot;fry&quot;)) {
-		double val;
-		if (mystrtod(&amp;p, &amp;val)) {
-			val *= M_PI / 180;
-			render_context.fry = val * pwr + render_context.fry * (1-pwr);
-		} else
-			render_context.fry = 0.;
-	} else if (mystrcmp(&amp;p, &quot;frz&quot;) || mystrcmp(&amp;p, &quot;fr&quot;)) {
-		double val;
-		if (mystrtod(&amp;p, &amp;val)) {
-			val *= M_PI / 180;
-			render_context.frz = val * pwr + render_context.frz * (1-pwr);
-		} else
-			render_context.frz = M_PI * render_context.style-&gt;Angle / 180.;
-	} else if (mystrcmp(&amp;p, &quot;fn&quot;)) {
-		char* start = p;
-		char* family;
-		skip_all('\\');
-		if (p &gt; start) {
-			family = malloc(p - start + 1);
-			strncpy(family, start, p - start);
-			family[p - start] = '\0';
-		} else
-			family = strdup(render_context.style-&gt;FontName);
-		if (render_context.family)
-			free(render_context.family);
-		render_context.family = family;
-		update_font();
-	} else if (mystrcmp(&amp;p, &quot;alpha&quot;)) {
-		uint32_t val;
-		int i;
-		if (strtocolor(&amp;p, &amp;val)) {
-			unsigned char a = val &gt;&gt; 24;
-			for (i = 0; i &lt; 4; ++i)
-				change_alpha(&amp;render_context.c[i], a, pwr);
-		} else {
-			change_alpha(&amp;render_context.c[0], render_context.style-&gt;PrimaryColour, pwr);
-			change_alpha(&amp;render_context.c[1], render_context.style-&gt;SecondaryColour, pwr);
-			change_alpha(&amp;render_context.c[2], render_context.style-&gt;OutlineColour, pwr);
-			change_alpha(&amp;render_context.c[3], render_context.style-&gt;BackColour, pwr);
-		}
-		// FIXME: simplify
-	} else if (mystrcmp(&amp;p, &quot;an&quot;)) {
-		int val;
-		if (mystrtoi(&amp;p, 10, &amp;val) &amp;&amp; val) {
-			int v = (val - 1) / 3; // 0, 1 or 2 for vertical alignment
-			mp_msg(MSGT_ASS, MSGL_DBG2, &quot;an %d\n&quot;, val);
-			if (v != 0) v = 3 - v;
-			val = ((val - 1) % 3) + 1; // horizontal alignment
-			val += v*4;
-			mp_msg(MSGT_ASS, MSGL_DBG2, &quot;align %d\n&quot;, val);
-			render_context.alignment = val;
-		} else
-			render_context.alignment = render_context.style-&gt;Alignment;
-	} else if (mystrcmp(&amp;p, &quot;a&quot;)) {
-		int val;
-		if (mystrtoi(&amp;p, 10, &amp;val) &amp;&amp; val)
-			render_context.alignment = val;
-		else
-			render_context.alignment = render_context.style-&gt;Alignment;
-	} else if (mystrcmp(&amp;p, &quot;pos&quot;)) {
-		int v1, v2;
-		skip('(');
-		v1 = strtol(p, &amp;p, 10);
-		skip(',');
-		v2 = strtol(p, &amp;p, 10);
-		skip(')');
-		mp_msg(MSGT_ASS, MSGL_DBG2, &quot;pos(%d, %d)\n&quot;, v1, v2);
-		render_context.evt_type = EVENT_POSITIONED;
-		render_context.detect_collisions = 0;
-		render_context.pos_x = v1;
-		render_context.pos_y = v2;
-	} else if (mystrcmp(&amp;p, &quot;fad&quot;)) {
-		int a1, a2, a3;
-		long long t1, t2, t3, t4;
-		if (*p == 'e') ++p; // either \fad or \fade
-		skip('(');
-		a1 = strtol(p, &amp;p, 10);
-		skip(',');
-		a2 = strtol(p, &amp;p, 10);
-		if (*p == ')') {
-			// 2-argument version (\fad, according to specs)
-			// a1 and a2 are fade-in and fade-out durations
-			t1 = 0;
-			t4 = render_context.event-&gt;Duration;
-			t2 = a1;
-			t3 = t4 - a2;
-			a1 = 0xFF;
-			a2 = 0;
-			a3 = 0xFF;
-		} else {
-			// 6-argument version (\fade)
-			// a1 and a2 (and a3) are opacity values
-			skip(',');
-			a3 = strtol(p, &amp;p, 10);
-			skip(',');
-			t1 = strtoll(p, &amp;p, 10);
-			skip(',');
-			t2 = strtoll(p, &amp;p, 10);
-			skip(',');
-			t3 = strtoll(p, &amp;p, 10);
-			skip(',');
-			t4 = strtoll(p, &amp;p, 10);
-		}
-		skip(')');
-		render_context.fade = interpolate_alpha(frame_context.time - render_context.event-&gt;Start, t1, t2, t3, t4, a1, a2, a3);
-	} else if (mystrcmp(&amp;p, &quot;org&quot;)) {
-		int v1, v2;
-		skip('(');
-		v1 = strtol(p, &amp;p, 10);
-		skip(',');
-		v2 = strtol(p, &amp;p, 10);
-		skip(')');
-		mp_msg(MSGT_ASS, MSGL_DBG2, &quot;org(%d, %d)\n&quot;, v1, v2);
-		//				render_context.evt_type = EVENT_POSITIONED;
-		render_context.org_x = v1;
-		render_context.org_y = v2;
-		render_context.have_origin = 1;
-	} else if (mystrcmp(&amp;p, &quot;t&quot;)) {
-		double v[3];
-		int v1, v2;
-		double v3;
-		int cnt;
-		long long t1, t2, t, delta_t;
-		double k;
-		skip('(');
-		for (cnt = 0; cnt &lt; 3; ++cnt) {
-			if (*p == '\\')
-				break;
-			v[cnt] = strtod(p, &amp;p);
-			skip(',');
-		}
-		if (cnt == 3) {
-			v1 = v[0]; v2 = v[1]; v3 = v[2];
-		} else if (cnt == 2) {
-			v1 = v[0]; v2 = v[1]; v3 = 1.;
-		} else if (cnt == 1) {
-			v1 = 0; v2 = render_context.event-&gt;Duration; v3 = v[0];
-		} else { // cnt == 0
-			v1 = 0; v2 = render_context.event-&gt;Duration; v3 = 1.;
-		}
-		render_context.detect_collisions = 0;
-		t1 = v1;
-		t2 = v2;
-		delta_t = v2 - v1;
-		if (v3 &lt; 0.)
-			v3 = 0.;
-		t = frame_context.time - render_context.event-&gt;Start; // FIXME: move to render_context
-		if (t &lt;= t1)
-			k = 0.;
-		else if (t &gt;= t2)
-			k = 1.;
-		else {
-			assert(delta_t != 0.);
-			k = pow(((double)(t - t1)) / delta_t, v3);
-		}
-		while (*p == '\\')
-			p = parse_tag(p, k); // maybe k*pwr ? no, specs forbid nested \t's 
-		skip_all(')'); // FIXME: better skip(')'), but much more tags support required
-	} else if (mystrcmp(&amp;p, &quot;clip&quot;)) {
-		int x0, y0, x1, y1;
-		int res = 1;
-		skip('(');
-		res &amp;= mystrtoi(&amp;p, 10, &amp;x0);
-		skip(',');
-		res &amp;= mystrtoi(&amp;p, 10, &amp;y0);
-		skip(',');
-		res &amp;= mystrtoi(&amp;p, 10, &amp;x1);
-		skip(',');
-		res &amp;= mystrtoi(&amp;p, 10, &amp;y1);
-		skip(')');
-		if (res) {
-			render_context.clip_x0 = render_context.clip_x0 * (1-pwr) + x0 * pwr;
-			render_context.clip_x1 = render_context.clip_x1 * (1-pwr) + x1 * pwr;
-			render_context.clip_y0 = render_context.clip_y0 * (1-pwr) + y0 * pwr;
-			render_context.clip_y1 = render_context.clip_y1 * (1-pwr) + y1 * pwr;
-		} else {
-			render_context.clip_x0 = 0;
-			render_context.clip_y0 = 0;
-			render_context.clip_x1 = frame_context.track-&gt;PlayResX;
-			render_context.clip_y1 = frame_context.track-&gt;PlayResY;
-		}
-	} else if (mystrcmp(&amp;p, &quot;c&quot;)) {
-		uint32_t val;
-		if (!strtocolor(&amp;p, &amp;val))
-			val = render_context.style-&gt;PrimaryColour;
-		mp_msg(MSGT_ASS, MSGL_DBG2, &quot;color: %X\n&quot;, val);
-		change_color(&amp;render_context.c[0], val, pwr);
-	} else if ((*p &gt;= '1') &amp;&amp; (*p &lt;= '4') &amp;&amp; (++p) &amp;&amp; (mystrcmp(&amp;p, &quot;c&quot;) || mystrcmp(&amp;p, &quot;a&quot;))) {
-		char n = *(p-2);
-		int cidx = n - '1';
-		char cmd = *(p-1);
-		uint32_t val;
-		assert((n &gt;= '1') &amp;&amp; (n &lt;= '4'));
-		if (!strtocolor(&amp;p, &amp;val))
-			switch(n) {
-				case '1': val = render_context.style-&gt;PrimaryColour; break;
-				case '2': val = render_context.style-&gt;SecondaryColour; break;
-				case '3': val = render_context.style-&gt;OutlineColour; break;
-				case '4': val = render_context.style-&gt;BackColour; break;
-				default : val = 0; break; // impossible due to assert; avoid compilation warning
-			}
-		switch (cmd) {
-			case 'c': change_color(render_context.c + cidx, val, pwr); break;
-			case 'a': change_alpha(render_context.c + cidx, val &gt;&gt; 24, pwr); break;
-			default: mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_BadCommand, n, cmd); break;
-		}
-		mp_msg(MSGT_ASS, MSGL_DBG2, &quot;single c/a at %f: %c%c = %X   \n&quot;, pwr, n, cmd, render_context.c[cidx]);
-	} else if (mystrcmp(&amp;p, &quot;r&quot;)) {
-		reset_render_context();
-	} else if (mystrcmp(&amp;p, &quot;be&quot;)) {
-		int val;
-		if (mystrtoi(&amp;p, 10, &amp;val))
-			render_context.be = val ? 1 : 0;
-		else
-			render_context.be = 0;
-	} else if (mystrcmp(&amp;p, &quot;b&quot;)) {
-		int b;
-		if (mystrtoi(&amp;p, 10, &amp;b)) {
-			if (pwr &gt;= .5)
-				render_context.bold = b;
-		} else
-			render_context.bold = render_context.style-&gt;Bold;
-		update_font();
-	} else if (mystrcmp(&amp;p, &quot;i&quot;)) {
-		int i;
-		if (mystrtoi(&amp;p, 10, &amp;i)) {
-			if (pwr &gt;= .5)
-				render_context.italic = i;
-		} else
-			render_context.italic = render_context.style-&gt;Italic;
-		update_font();
-	} else if (mystrcmp(&amp;p, &quot;kf&quot;) || mystrcmp(&amp;p, &quot;K&quot;)) {
-		int val = strtol(p, &amp;p, 10);
-		render_context.effect_type = EF_KARAOKE_KF;
-		if (render_context.effect_timing)
-			render_context.effect_skip_timing += render_context.effect_timing;
-		render_context.effect_timing = val * 10;
-	} else if (mystrcmp(&amp;p, &quot;ko&quot;)) {
-		int val = strtol(p, &amp;p, 10);
-		render_context.effect_type = EF_KARAOKE_KO;
-		if (render_context.effect_timing)
-			render_context.effect_skip_timing += render_context.effect_timing;
-		render_context.effect_timing = val * 10;
-	} else if (mystrcmp(&amp;p, &quot;k&quot;)) {
-		int val = strtol(p, &amp;p, 10);
-		render_context.effect_type = EF_KARAOKE;
-		if (render_context.effect_timing)
-			render_context.effect_skip_timing += render_context.effect_timing;
-		render_context.effect_timing = val * 10;
-	} else if (mystrcmp(&amp;p, &quot;shad&quot;)) {
-		int val;
-		if (mystrtoi(&amp;p, 10, &amp;val))
-			render_context.shadow = val;
-		else
-			render_context.shadow = render_context.style-&gt;Shadow;
-	}
-
-	return p;
-
-#undef skip
-#undef skip_all
-}
-
-/**
- * \brief Get next ucs4 char from string, parsing and executing style overrides
- * \param str string pointer
- * \return ucs4 code of the next char
- * On return str points to the unparsed part of the string
- */
-static unsigned get_next_char(char** str)
-{
-	char* p = *str;
-	unsigned chr;
-	if (*p == '{') { // '\0' goes here
-		p++;
-		while (1) {
-			p = parse_tag(p, 1.);
-			if (*p == '}') { // end of tag
-				p++;
-				if (*p == '{') {
-					p++;
-					continue;
-				} else
-					break;
-			} else if (*p != '\\')
-				mp_msg(MSGT_ASS, MSGL_V, &quot;Unable to parse: \&quot;%s\&quot; \n&quot;, p);
-			if (*p == 0)
-				break;
-		}
-	}
-	if (*p == '\t') {
-		++p;
-		*str = p;
-		return ' ';
-	}
-	if (*p == '\\') {
-		if ((*(p+1) == 'N') || ((*(p+1) == 'n') &amp;&amp; (frame_context.track-&gt;WrapStyle == 2))) {
-			p += 2;
-			*str = p;
-			return '\n';
-		} else if (*(p+1) == 'n') {
-			p += 2;
-			*str = p;
-			return ' ';
-		}
-	}
-	chr = utf8_get_char(&amp;p);
-	*str = p;
-	return chr;
-}
-
-static void apply_transition_effects(ass_event_t* event)
-{
-	int v[4];
-	int cnt;
-	char* p = event-&gt;Effect;
-
-	if (!p || !*p) return;
-
-	cnt = 0;
-	while (cnt &lt; 4 &amp;&amp; (p = strchr(p, ';'))) {
-		v[cnt++] = atoi(++p);
-	}
-	
-	if (strncmp(event-&gt;Effect, &quot;Banner;&quot;, 7) == 0) {
-		int delay;
-		if (cnt &lt; 1) {
-			mp_msg(MSGT_ASS, MSGL_V, &quot;Error parsing effect: %s \n&quot;, event-&gt;Effect);
-			return;
-		}
-		if (cnt &gt;= 2 &amp;&amp; v[1] == 0) // right-to-left
-			render_context.scroll_direction = SCROLL_RL;
-		else // left-to-right
-			render_context.scroll_direction = SCROLL_LR;
-
-		delay = v[0];
-		if (delay == 0) delay = 1; // ?
-		render_context.scroll_shift = (frame_context.time - render_context.event-&gt;Start) / delay;
-		render_context.evt_type = EVENT_HSCROLL;
-		return;
-	}
-
-	if (strncmp(event-&gt;Effect, &quot;Scroll up;&quot;, 10) == 0) {
-		render_context.scroll_direction = SCROLL_BT;
-	} else if (strncmp(event-&gt;Effect, &quot;Scroll down;&quot;, 12) == 0) {
-		render_context.scroll_direction = SCROLL_TB;
-	} else {
-		mp_msg(MSGT_ASS, MSGL_V, &quot;Unknown transition effect: %s \n&quot;, event-&gt;Effect);
-		return;
-	}
-	// parse scroll up/down parameters
-	{
-		int delay;
-		int y0, y1;
-		if (cnt &lt; 3) {
-			mp_msg(MSGT_ASS, MSGL_V, &quot;Error parsing effect: %s \n&quot;, event-&gt;Effect);
-			return;
-		}
-		delay = v[2];
-		if (delay == 0) delay = 1; // ?
-		render_context.scroll_shift = (frame_context.time - render_context.event-&gt;Start) / delay;
-		if (v[0] &lt; v[1]) {
-			y0 = v[0]; y1 = v[1];
-		} else {
-			y0 = v[1]; y1 = v[0];
-		}
-		if (y1 == 0)
-			y1 = frame_context.track-&gt;PlayResY; // y0=y1=0 means fullscreen scrolling
-		render_context.clip_y0 = y0;
-		render_context.clip_y1 = y1;
-		render_context.evt_type = EVENT_VSCROLL;
-		render_context.detect_collisions = 0;
-	}
-
-}
-
-/**
- * \brief partially reset render_context to style values
- * Works like {\r}: resets some style overrides
- */
-static void reset_render_context(void)
-{
-	render_context.c[0] = render_context.style-&gt;PrimaryColour;
-	render_context.c[1] = render_context.style-&gt;SecondaryColour;
-	render_context.c[2] = render_context.style-&gt;OutlineColour;
-	render_context.c[3] = render_context.style-&gt;BackColour;
-	render_context.font_size = render_context.style-&gt;FontSize;
-
-	if (render_context.family)
-		free(render_context.family);
-	render_context.family = strdup(render_context.style-&gt;FontName);
-	render_context.bold = render_context.style-&gt;Bold;
-	render_context.italic = render_context.style-&gt;Italic;
-	update_font();
-
-	change_border(-1.);
-	render_context.scale_x = render_context.style-&gt;ScaleX;
-	render_context.scale_y = render_context.style-&gt;ScaleY;
-	render_context.hspacing = render_context.style-&gt;Spacing;
-	render_context.be = 0;
-	render_context.shadow = render_context.style-&gt;Shadow;
-	render_context.frx = render_context.fry = 0.;
-	render_context.frz = M_PI * render_context.style-&gt;Angle / 180.;
-
-	// FIXME: does not reset unsupported attributes.
-}
-
-/**
- * \brief Start new event. Reset render_context.
- */
-static void init_render_context(ass_event_t* event)
-{
-	render_context.event = event;
-	render_context.style = frame_context.track-&gt;styles + event-&gt;Style;
-
-	reset_render_context();
-
-	render_context.evt_type = EVENT_NORMAL;
-	render_context.alignment = render_context.style-&gt;Alignment;
-	render_context.pos_x = 0;
-	render_context.pos_y = 0;
-	render_context.org_x = 0;
-	render_context.org_y = 0;
-	render_context.have_origin = 0;
-	render_context.clip_x0 = 0;
-	render_context.clip_y0 = 0;
-	render_context.clip_x1 = frame_context.track-&gt;PlayResX;
-	render_context.clip_y1 = frame_context.track-&gt;PlayResY;
-	render_context.detect_collisions = 1;
-	render_context.fade = 0;
-	render_context.effect_type = EF_NONE;
-	render_context.effect_timing = 0;
-	render_context.effect_skip_timing = 0;
-	
-	apply_transition_effects(event);
-}
-
-static void free_render_context(void)
-{
-}
-
-/**
- * \brief Get normal and outline (border) glyphs
- * \param symbol ucs4 char
- * \param info out: struct filled with extracted data
- * \param advance subpixel shift vector used for cache lookup
- * Tries to get both glyphs from cache.
- * If they can't be found, gets a glyph from font face, generates outline with FT_Stroker,
- * and add them to cache.
- * The glyphs are returned in info-&gt;glyph and info-&gt;outline_glyph
- */
-static void get_outline_glyph(int symbol, glyph_info_t* info, FT_Vector* advance)
-{
-	int error;
-	glyph_hash_val_t* val;
-	glyph_hash_key_t key;
-	key.font = render_context.font;
-	key.size = render_context.font_size;
-	key.ch = symbol;
-	key.scale_x = (render_context.scale_x * 0xFFFF);
-	key.scale_y = (render_context.scale_y * 0xFFFF);
-	key.advance = *advance;
-	key.bold = render_context.bold;
-	key.italic = render_context.italic;
-	key.outline = render_context.border * 0xFFFF;
-
-	info-&gt;glyph = info-&gt;outline_glyph = 0;
-
-	val = cache_find_glyph(&amp;key);
-	if (val) {
-		FT_Glyph_Copy(val-&gt;glyph, &amp;info-&gt;glyph);
-		if (val-&gt;outline_glyph)
-			FT_Glyph_Copy(val-&gt;outline_glyph, &amp;info-&gt;outline_glyph);
-		info-&gt;bbox = val-&gt;bbox_scaled;
-		info-&gt;advance.x = val-&gt;advance.x;
-		info-&gt;advance.y = val-&gt;advance.y;
-	} else {
-		glyph_hash_val_t v;
-		info-&gt;glyph = ass_font_get_glyph(frame_context.ass_priv-&gt;fontconfig_priv, render_context.font, symbol, global_settings-&gt;hinting);
-		if (!info-&gt;glyph)
-			return;
-		info-&gt;advance.x = d16_to_d6(info-&gt;glyph-&gt;advance.x);
-		info-&gt;advance.y = d16_to_d6(info-&gt;glyph-&gt;advance.y);
-		FT_Glyph_Get_CBox( info-&gt;glyph, FT_GLYPH_BBOX_PIXELS, &amp;info-&gt;bbox);
-
-		if (render_context.stroker) {
-			info-&gt;outline_glyph = info-&gt;glyph;
-			error = FT_Glyph_StrokeBorder( &amp;(info-&gt;outline_glyph), render_context.stroker, 0 , 0 ); // don't destroy original
-			if (error) {
-				mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FT_Glyph_Stroke_Error, error);
-			}
-		}
-
-		memset(&amp;v, 0, sizeof(v));
-		FT_Glyph_Copy(info-&gt;glyph, &amp;v.glyph);
-		if (info-&gt;outline_glyph)
-			FT_Glyph_Copy(info-&gt;outline_glyph, &amp;v.outline_glyph);
-		v.advance = info-&gt;advance;
-		v.bbox_scaled = info-&gt;bbox;
-		cache_add_glyph(&amp;key, &amp;v);
-	}
-}
-
-static void transform_3d(FT_Vector shift, FT_Glyph* glyph, FT_Glyph* glyph2, double frx, double fry, double frz);
-
-/**
- * \brief Get bitmaps for a glyph
- * \param info glyph info
- * Tries to get glyph bitmaps from bitmap cache.
- * If they can't be found, they are generated by rotating and rendering the glyph.
- * After that, bitmaps are added to the cache.
- * They are returned in info-&gt;bm (glyph), info-&gt;bm_o (outline) and info-&gt;bm_s (shadow).
- */
-static void get_bitmap_glyph(glyph_info_t* info)
-{
-	bitmap_hash_val_t* val;
-	bitmap_hash_key_t* key = &amp;info-&gt;hash_key;
-	
-	val = cache_find_bitmap(key);
-/* 	val = 0; */
-	
-	if (val) {
-		info-&gt;bm = val-&gt;bm;
-		info-&gt;bm_o = val-&gt;bm_o;
-		info-&gt;bm_s = val-&gt;bm_s;
-	} else {
-		FT_Vector shift;
-		bitmap_hash_val_t hash_val;
-		int error;
-		info-&gt;bm = info-&gt;bm_o = info-&gt;bm_s = 0;
-		if (info-&gt;glyph &amp;&amp; info-&gt;symbol != '\n' &amp;&amp; info-&gt;symbol != 0) {
-			// calculating rotation shift vector (from rotation origin to the glyph basepoint)
-			shift.x = int_to_d6(info-&gt;hash_key.shift_x);
-			shift.y = int_to_d6(info-&gt;hash_key.shift_y);
-			// apply rotation
-			transform_3d(shift, &amp;info-&gt;glyph, &amp;info-&gt;outline_glyph, info-&gt;frx, info-&gt;fry, info-&gt;frz);
-
-			// render glyph
-			error = glyph_to_bitmap(ass_renderer-&gt;synth_priv,
-					info-&gt;glyph, info-&gt;outline_glyph,
-					&amp;info-&gt;bm, &amp;info-&gt;bm_o,
-					&amp;info-&gt;bm_s, info-&gt;be);
-			if (error)
-				info-&gt;symbol = 0;
-
-			// add bitmaps to cache
-			hash_val.bm_o = info-&gt;bm_o;
-			hash_val.bm = info-&gt;bm;
-			hash_val.bm_s = info-&gt;bm_s;
-			cache_add_bitmap(&amp;(info-&gt;hash_key), &amp;hash_val);
-		}
-	}
-	// deallocate glyphs
-	if (info-&gt;glyph)
-		FT_Done_Glyph(info-&gt;glyph);
-	if (info-&gt;outline_glyph)
-		FT_Done_Glyph(info-&gt;outline_glyph);
-}
-
-/**
- * This function goes through text_info and calculates text parameters.
- * The following text_info fields are filled:
- *   height
- *   lines[].height
- *   lines[].asc
- *   lines[].desc
- */
-static void measure_text(void)
-{
-	int cur_line = 0, max_asc = 0, max_desc = 0;
-	int i;
-	text_info.height = 0;
-	for (i = 0; i &lt; text_info.length + 1; ++i) {
-		if ((i == text_info.length) || text_info.glyphs[i].linebreak) {
-			text_info.lines[cur_line].asc = max_asc;
-			text_info.lines[cur_line].desc = max_desc;
-			text_info.height += max_asc + max_desc;
-			cur_line ++;
-			max_asc = max_desc = 0;
-		}
-		if (i &lt; text_info.length) {
-			glyph_info_t* cur = text_info.glyphs + i;
-			if (cur-&gt;asc &gt; max_asc)
-				max_asc = cur-&gt;asc;
-			if (cur-&gt;desc &gt; max_desc)
-				max_desc = cur-&gt;desc;
-		}
-	}
-	text_info.height += (text_info.n_lines - 1) * double_to_d6(global_settings-&gt;line_spacing);
-}
-
-/**
- * \brief rearrange text between lines
- * \param max_text_width maximal text line width in pixels
- * The algo is similar to the one in libvo/sub.c:
- * 1. Place text, wrapping it when current line is full
- * 2. Try moving words from the end of a line to the beginning of the next one while it reduces
- * the difference in lengths between this two lines.
- * The result may not be optimal, but usually is good enough.
- */
-static void wrap_lines_smart(int max_text_width)
-{
-	int i, j;
-	glyph_info_t *cur, *s1, *e1, *s2, *s3, *w;
-	int last_space;
-	int break_type;
-	int exit;
-	int pen_shift_x;
-	int pen_shift_y;
-	int cur_line;
-
-	last_space = -1;
-	text_info.n_lines = 1;
-	break_type = 0;
-	s1 = text_info.glyphs; // current line start
-	for (i = 0; i &lt; text_info.length; ++i) {
-		int break_at, s_offset, len;
-		cur = text_info.glyphs + i;
-		break_at = -1;
-		s_offset = s1-&gt;bbox.xMin + s1-&gt;pos.x;
-		len = (cur-&gt;bbox.xMax + cur-&gt;pos.x) - s_offset;
-
-		if (cur-&gt;symbol == '\n') {
-			break_type = 2;
-			break_at = i;
-			mp_msg(MSGT_ASS, MSGL_DBG2, &quot;forced line break at %d\n&quot;, break_at);
-		}
-		
-		if (len &gt;= max_text_width) {
-			break_type = 1;
-			break_at = last_space;
-			if (break_at == -1)
-				break_at = i - 1;
-			if (break_at == -1)
-				break_at = 0;
-			mp_msg(MSGT_ASS, MSGL_DBG2, &quot;overfill at %d\n&quot;, i);
-			mp_msg(MSGT_ASS, MSGL_DBG2, &quot;line break at %d\n&quot;, break_at);
-		}
-
-		if (break_at != -1) {
-			// need to use one more line
-			// marking break_at+1 as start of a new line
-			int lead = break_at + 1; // the first symbol of the new line
-			if (text_info.n_lines &gt;= MAX_LINES) {
-				// to many lines ! 
-				// no more linebreaks
-				for (j = lead; j &lt; text_info.length; ++j)
-					text_info.glyphs[j].linebreak = 0;
-				break;
-			}
-			if (lead &lt; text_info.length)
-				text_info.glyphs[lead].linebreak = break_type;
-			last_space = -1;
-			s1 = text_info.glyphs + lead;
-			s_offset = s1-&gt;bbox.xMin + s1-&gt;pos.x;
-			text_info.n_lines ++;
-		}
-		
-		if (cur-&gt;symbol == ' ')
-			last_space = i;
-
-		// make sure the hard linebreak is not forgotten when
-		// there was a new soft linebreak just inserted
-		if (cur-&gt;symbol == '\n' &amp;&amp; break_type == 1)
-			i--;
-	}
-#define DIFF(x,y) (((x) &lt; (y)) ? (y - x) : (x - y))
-	exit = 0;
-	while (!exit) {
-		exit = 1;
-		w = s3 = text_info.glyphs;
-		s1 = s2 = 0;
-		for (i = 0; i &lt;= text_info.length; ++i) {
-			cur = text_info.glyphs + i;
-			if ((i == text_info.length) || cur-&gt;linebreak) {
-				s1 = s2;
-				s2 = s3;
-				s3 = cur;
-				if (s1 &amp;&amp; (s2-&gt;linebreak == 1)) { // have at least 2 lines, and linebreak is 'soft'
-					int l1, l2, l1_new, l2_new;
-
-					w = s2;
-					do { --w; } while ((w &gt; s1) &amp;&amp; (w-&gt;symbol == ' '));
-					while ((w &gt; s1) &amp;&amp; (w-&gt;symbol != ' ')) { --w; }
-					e1 = w;
-					while ((e1 &gt; s1) &amp;&amp; (e1-&gt;symbol == ' ')) { --e1; }
-					if (w-&gt;symbol == ' ') ++w;
-
-					l1 = ((s2-1)-&gt;bbox.xMax + (s2-1)-&gt;pos.x) - (s1-&gt;bbox.xMin + s1-&gt;pos.x);
-					l2 = ((s3-1)-&gt;bbox.xMax + (s3-1)-&gt;pos.x) - (s2-&gt;bbox.xMin + s2-&gt;pos.x);
-					l1_new = (e1-&gt;bbox.xMax + e1-&gt;pos.x) - (s1-&gt;bbox.xMin + s1-&gt;pos.x);
-					l2_new = ((s3-1)-&gt;bbox.xMax + (s3-1)-&gt;pos.x) - (w-&gt;bbox.xMin + w-&gt;pos.x);
-
-					if (DIFF(l1_new, l2_new) &lt; DIFF(l1, l2)) {
-						w-&gt;linebreak = 1;
-						s2-&gt;linebreak = 0;
-						exit = 0;
-					}
-				}
-			}
-			if (i == text_info.length)
-				break;
-		}
-		
-	}
-	assert(text_info.n_lines &gt;= 1);
-#undef DIFF
-	
-	measure_text();
-
-	pen_shift_x = 0;
-	pen_shift_y = 0;
-	cur_line = 1;
-	for (i = 0; i &lt; text_info.length; ++i) {
-		cur = text_info.glyphs + i;
-		if (cur-&gt;linebreak) {
-			int height = text_info.lines[cur_line - 1].desc + text_info.lines[cur_line].asc;
-			cur_line ++;
-			pen_shift_x = - cur-&gt;pos.x;
-			pen_shift_y += d6_to_int(height + double_to_d6(global_settings-&gt;line_spacing));
-			mp_msg(MSGT_ASS, MSGL_DBG2, &quot;shifting from %d to %d by (%d, %d)\n&quot;, i, text_info.length - 1, pen_shift_x, pen_shift_y);
-		}
-		cur-&gt;pos.x += pen_shift_x;
-		cur-&gt;pos.y += pen_shift_y;
-	}
-}
-
-/**
- * \brief determine karaoke effects
- * Karaoke effects cannot be calculated during parse stage (get_next_char()),
- * so they are done in a separate step.
- * Parse stage: when karaoke style override is found, its parameters are stored in the next glyph's 
- * (the first glyph of the karaoke word)'s effect_type and effect_timing.
- * This function:
- * 1. sets effect_type for all glyphs in the word (_karaoke_ word)
- * 2. sets effect_timing for all glyphs to x coordinate of the border line between the left and right karaoke parts
- * (left part is filled with PrimaryColour, right one - with SecondaryColour).
- */
-static void process_karaoke_effects(void)
-{
-	glyph_info_t *cur, *cur2;
-	glyph_info_t *s1, *e1; // start and end of the current word
-	glyph_info_t *s2; // start of the next word
-	int i;
-	int timing; // current timing
-	int tm_start, tm_end; // timings at start and end of the current word
-	int tm_current;
-	double dt;
-	int x;
-	int x_start, x_end;
-
-	tm_current = frame_context.time - render_context.event-&gt;Start;
-	timing = 0;
-	s1 = s2 = 0;
-	for (i = 0; i &lt;= text_info.length; ++i) {
-		cur = text_info.glyphs + i;
-		if ((i == text_info.length) || (cur-&gt;effect_type != EF_NONE)) {
-			s1 = s2;
-			s2 = cur;
-			if (s1) {
-				e1 = s2 - 1;
-				tm_start = timing + s1-&gt;effect_skip_timing;
-				tm_end = tm_start + s1-&gt;effect_timing;
-				timing = tm_end;
-				x_start = 1000000;
-				x_end = -1000000;
-				for (cur2 = s1; cur2 &lt;= e1; ++cur2) {
-					x_start = FFMIN(x_start, cur2-&gt;bbox.xMin + cur2-&gt;pos.x);
-					x_end = FFMAX(x_end, cur2-&gt;bbox.xMax + cur2-&gt;pos.x);
-				}
-
-				dt = (tm_current - tm_start);
-				if ((s1-&gt;effect_type == EF_KARAOKE) || (s1-&gt;effect_type == EF_KARAOKE_KO)) {
-					if (dt &gt; 0)
-						x = x_end + 1;
-					else
-						x = x_start;
-				} else if (s1-&gt;effect_type == EF_KARAOKE_KF) {
-					dt /= (tm_end - tm_start);
-					x = x_start + (x_end - x_start) * dt;
-				} else {
-					mp_msg(MSGT_ASS, MSGL_ERR, MSGTR_LIBASS_UnknownEffectType_InternalError);
-					continue;
-				}
-
-				for (cur2 = s1; cur2 &lt;= e1; ++cur2) {
-					cur2-&gt;effect_type = s1-&gt;effect_type;
-					cur2-&gt;effect_timing = x - cur2-&gt;pos.x;
-				}
-			}
-		}
-	}
-}
-
-/**
- * \brief Calculate base point for positioning and rotation
- * \param bbox text bbox
- * \param alignment alignment
- * \param bx, by out: base point coordinates
- */
-static void get_base_point(FT_BBox bbox, int alignment, int* bx, int* by)
-{
-	const int halign = alignment &amp; 3;
-	const int valign = alignment &amp; 12;
-	if (bx)
-		switch(halign) {
-		case HALIGN_LEFT:
-			*bx = bbox.xMin;
-			break;
-		case HALIGN_CENTER:
-			*bx = (bbox.xMax + bbox.xMin) / 2;
-			break;
-		case HALIGN_RIGHT:
-			*bx = bbox.xMax;
-			break;
-		}
-	if (by)
-		switch(valign) {
-		case VALIGN_TOP:
-			*by = bbox.yMin;
-			break;
-		case VALIGN_CENTER:
-			*by = (bbox.yMax + bbox.yMin) / 2;
-			break;
-		case VALIGN_SUB:
-			*by = bbox.yMax;
-			break;
-		}
-}
-
-/**
- * \brief Multiply 4-vector by 4-matrix
- * \param a 4-vector
- * \param m 4-matrix]
- * \param b out: 4-vector
- * Calculates a * m and stores result in b
- */
-static inline void transform_point_3d(double *a, double *m, double *b)
-{
-	b[0] = a[0] * m[0] + a[1] * m[4] + a[2] * m[8] +  a[3] * m[12];
-	b[1] = a[0] * m[1] + a[1] * m[5] + a[2] * m[9] +  a[3] * m[13];
-	b[2] = a[0] * m[2] + a[1] * m[6] + a[2] * m[10] + a[3] * m[14];
-	b[3] = a[0] * m[3] + a[1] * m[7] + a[2] * m[11] + a[3] * m[15];
-}
-
-/**
- * \brief Apply 3d transformation to a vector
- * \param v FreeType vector (2d)
- * \param m 4-matrix
- * Transforms v by m, projects the result back to the screen plane
- * Result is returned in v.
- */
-static inline void transform_vector_3d(FT_Vector* v, double *m) {
-	const double camera = 2500 * frame_context.border_scale; // camera distance
-	double a[4], b[4];
-	a[0] = d6_to_double(v-&gt;x);
-	a[1] = d6_to_double(v-&gt;y);
-	a[2] = 0.;
-	a[3] = 1.;
-	transform_point_3d(a, m, b);
-	/* Apply perspective projection with the following matrix:
-	   2500     0     0     0
-	      0  2500     0     0
-	      0     0     0     0
-	      0     0     8     2500
-	   where 2500 is camera distance, 8 - z-axis scale.
-	   Camera is always located in (org_x, org_y, -2500). This means
-	   that different subtitle events can be displayed at the same time
-	   using different cameras. */
-	b[0] *= camera;
-	b[1] *= camera;
-	b[3] = 8 * b[2] + camera;
-	if (b[3] &lt; 0.001 &amp;&amp; b[3] &gt; -0.001)
-		b[3] = b[3] &lt; 0. ? -0.001 : 0.001;
-	v-&gt;x = double_to_d6(b[0] / b[3]);
-	v-&gt;y = double_to_d6(b[1] / b[3]);
-}
-
-/**
- * \brief Apply 3d transformation to a glyph
- * \param glyph FreeType glyph
- * \param m 4-matrix
- * Transforms glyph by m, projects the result back to the screen plane
- * Result is returned in glyph.
- */
-static inline void transform_glyph_3d(FT_Glyph glyph, double *m, FT_Vector shift) {
-	int i;
-	FT_Outline* outline = &amp;((FT_OutlineGlyph)glyph)-&gt;outline;
-	FT_Vector* p = outline-&gt;points;
-
-	for (i=0; i&lt;outline-&gt;n_points; i++) {
-		p[i].x += shift.x;
-		p[i].y += shift.y;
-		transform_vector_3d(p + i, m);
-		p[i].x -= shift.x;
-		p[i].y -= shift.y;
-	}
-
-	//transform_vector_3d(&amp;glyph-&gt;advance, m);
-}
-
-/**
- * \brief Apply 3d transformation to several objects
- * \param shift FreeType vector
- * \param glyph FreeType glyph
- * \param glyph2 FreeType glyph
- * \param frx x-axis rotation angle
- * \param fry y-axis rotation angle
- * \param frz z-axis rotation angle
- * Rotates both glyphs by frx, fry and frz. Shift vector is added before rotation and subtracted after it.
- */
-static void transform_3d(FT_Vector shift, FT_Glyph* glyph, FT_Glyph* glyph2, double frx, double fry, double frz)
-{
-	fry = - fry; // FreeType's y axis goes in the opposite direction
-	if (frx != 0. || fry != 0. || frz != 0.) {
-		double m[16];
-		double sx = sin(frx);
-		double sy = sin(fry);
- 		double sz = sin(frz);
-		double cx = cos(frx);
-		double cy = cos(fry);
-		double cz = cos(frz);
-		m[0] = cy * cz;            m[1] = cy*sz;              m[2]  = -sy;    m[3] = 0.0;
-		m[4] = -cx*sz + sx*sy*cz;  m[5] = cx*cz + sx*sy*sz;   m[6]  = sx*cy;  m[7] = 0.0;
-		m[8] = sx*sz + cx*sy*cz;   m[9] = -sx*cz + cx*sy*sz;  m[10] = cx*cy;  m[11] = 0.0;
-		m[12] = 0.0;               m[13] = 0.0;               m[14] = 0.0;    m[15] = 1.0;
-
-		if (glyph &amp;&amp; *glyph)
-			transform_glyph_3d(*glyph, m, shift);
-
-		if (glyph2 &amp;&amp; *glyph2)
-			transform_glyph_3d(*glyph2, m, shift);
-	}
-}
-
-/**
- * \brief Main ass rendering function, glues everything together
- * \param event event to render
- * Process event, appending resulting ass_image_t's to images_root.
- */
-static int ass_render_event(ass_event_t* event, event_images_t* event_images)
-{
-	char* p;
-	FT_UInt previous; 
-	FT_UInt num_glyphs;
-	FT_Vector pen;
-	unsigned code;
-	FT_BBox bbox;
-	int i, j;
-	FT_Vector shift;
-	int MarginL, MarginR, MarginV;
-	int last_break;
-	int alignment, halign, valign;
-	int device_x = 0, device_y = 0;
-
-	if (event-&gt;Style &gt;= frame_context.track-&gt;n_styles) {
-		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_NoStyleFound);
-		return 1;
-	}
-	if (!event-&gt;Text) {
-		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_EmptyEvent);
-		return 1;
-	}
-
-	init_render_context(event);
-
-	text_info.length = 0;
-	pen.x = 0;
-	pen.y = 0;
-	previous = 0;
-	num_glyphs = 0;
-	p = event-&gt;Text;
-	// Event parsing.
-	while (1) {
-		// get next char, executing style override
-		// this affects render_context
-		code = get_next_char(&amp;p);
-		
-		// face could have been changed in get_next_char
-		if (!render_context.font) {
-			free_render_context();
-			return 1;
-		}
-
-		if (code == 0)
-			break;
-
-		if (text_info.length &gt;= MAX_GLYPHS) {
-			mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_MAX_GLYPHS_Reached, 
-					(int)(event - frame_context.track-&gt;events), event-&gt;Start, event-&gt;Duration, event-&gt;Text);
-			break;
-		}
-
-		if ( previous &amp;&amp; code ) {
-			FT_Vector delta;
-			delta = ass_font_get_kerning(render_context.font, previous, code);
-			pen.x += delta.x * render_context.scale_x;
-			pen.y += delta.y * render_context.scale_y;
-		}
-
-		shift.x = pen.x &amp; 63;
-		shift.y = pen.y &amp; 63;
-
-		ass_font_set_transform(render_context.font,
-				       render_context.scale_x * frame_context.font_scale_x,
-				       render_context.scale_y,
-				       &amp;shift );
-
-		get_outline_glyph(code, text_info.glyphs + text_info.length, &amp;shift);
-		
-		text_info.glyphs[text_info.length].pos.x = pen.x &gt;&gt; 6;
-		text_info.glyphs[text_info.length].pos.y = pen.y &gt;&gt; 6;
-		
-		pen.x += text_info.glyphs[text_info.length].advance.x;
-		pen.x += double_to_d6(render_context.hspacing);
-		pen.y += text_info.glyphs[text_info.length].advance.y;
-		
-		previous = code;
-
-		text_info.glyphs[text_info.length].symbol = code;
-		text_info.glyphs[text_info.length].linebreak = 0;
-		for (i = 0; i &lt; 4; ++i) {
-			uint32_t clr = render_context.c[i];
-			change_alpha(&amp;clr, mult_alpha(_a(clr), render_context.fade), 1.);
-			text_info.glyphs[text_info.length].c[i] = clr;
-		}
-		text_info.glyphs[text_info.length].effect_type = render_context.effect_type;
-		text_info.glyphs[text_info.length].effect_timing = render_context.effect_timing;
-		text_info.glyphs[text_info.length].effect_skip_timing = render_context.effect_skip_timing;
-		text_info.glyphs[text_info.length].be = render_context.be;
-		text_info.glyphs[text_info.length].shadow = render_context.shadow;
-		text_info.glyphs[text_info.length].frx = render_context.frx;
-		text_info.glyphs[text_info.length].fry = render_context.fry;
-		text_info.glyphs[text_info.length].frz = render_context.frz;
-		ass_font_get_asc_desc(render_context.font, code,
-				      &amp;text_info.glyphs[text_info.length].asc,
-				      &amp;text_info.glyphs[text_info.length].desc);
-		text_info.glyphs[text_info.length].asc *= render_context.scale_y;
-		text_info.glyphs[text_info.length].desc *= render_context.scale_y;
-
-		// fill bitmap_hash_key
-		text_info.glyphs[text_info.length].hash_key.font = render_context.font;
-		text_info.glyphs[text_info.length].hash_key.size = render_context.font_size;
-		text_info.glyphs[text_info.length].hash_key.outline = render_context.border * 0xFFFF;
-		text_info.glyphs[text_info.length].hash_key.scale_x = render_context.scale_x * 0xFFFF;
-		text_info.glyphs[text_info.length].hash_key.scale_y = render_context.scale_y * 0xFFFF;
-		text_info.glyphs[text_info.length].hash_key.frx = render_context.frx * 0xFFFF;
-		text_info.glyphs[text_info.length].hash_key.fry = render_context.fry * 0xFFFF;
-		text_info.glyphs[text_info.length].hash_key.frz = render_context.frz * 0xFFFF;
-		text_info.glyphs[text_info.length].hash_key.bold = render_context.bold;
-		text_info.glyphs[text_info.length].hash_key.italic = render_context.italic;
-		text_info.glyphs[text_info.length].hash_key.ch = code;
-		text_info.glyphs[text_info.length].hash_key.advance = shift;
-		text_info.glyphs[text_info.length].hash_key.be = render_context.be;
-
-		text_info.length++;
-
-		render_context.effect_type = EF_NONE;
-		render_context.effect_timing = 0;
-		render_context.effect_skip_timing = 0;
-	}
-	
-	if (text_info.length == 0) {
-		// no valid symbols in the event; this can be smth like {comment}
-		free_render_context();
-		return 1;
-	}
-	
-	// depends on glyph x coordinates being monotonous, so it should be done before line wrap
-	process_karaoke_effects();
-	
-	// alignments
-	alignment = render_context.alignment;
-	halign = alignment &amp; 3;
-	valign = alignment &amp; 12;
-
-	MarginL = (event-&gt;MarginL) ? event-&gt;MarginL : render_context.style-&gt;MarginL; 
-	MarginR = (event-&gt;MarginR) ? event-&gt;MarginR : render_context.style-&gt;MarginR; 
-	MarginV = (event-&gt;MarginV) ? event-&gt;MarginV : render_context.style-&gt;MarginV;
-
-	if (render_context.evt_type != EVENT_HSCROLL) {
-		int max_text_width;
-
-		// calculate max length of a line
-		max_text_width = x2scr(frame_context.track-&gt;PlayResX - MarginR) - x2scr(MarginL);
-
-		// rearrange text in several lines
-		wrap_lines_smart(max_text_width);
-
-		// align text
-		last_break = -1;
-		for (i = 1; i &lt; text_info.length + 1; ++i) { // (text_info.length + 1) is the end of the last line
-			if ((i == text_info.length) || text_info.glyphs[i].linebreak) {
-				int width, shift = 0;
-				glyph_info_t* first_glyph = text_info.glyphs + last_break + 1;
-				glyph_info_t* last_glyph = text_info.glyphs + i - 1;
-
-				while ((last_glyph &gt; first_glyph) &amp;&amp; ((last_glyph-&gt;symbol == '\n') || (last_glyph-&gt;symbol == 0)))
-					last_glyph --;
-
-				width = last_glyph-&gt;pos.x + d6_to_int(last_glyph-&gt;advance.x) - first_glyph-&gt;pos.x;
-				if (halign == HALIGN_LEFT) { // left aligned, no action
-					shift = 0;
-				} else if (halign == HALIGN_RIGHT) { // right aligned
-					shift = max_text_width - width;
-				} else if (halign == HALIGN_CENTER) { // centered
-					shift = (max_text_width - width) / 2;
-				}
-				for (j = last_break + 1; j &lt; i; ++j) {
-					text_info.glyphs[j].pos.x += shift;
-				}
-				last_break = i - 1;
-			}
-		}
-	} else { // render_context.evt_type == EVENT_HSCROLL
-		measure_text();
-	}
-	
-	// determing text bounding box
-	compute_string_bbox(&amp;text_info, &amp;bbox);
-	
-	// determine device coordinates for text
-	
-	// x coordinate for everything except positioned events
-	if (render_context.evt_type == EVENT_NORMAL ||
-	    render_context.evt_type == EVENT_VSCROLL) {
-		device_x = x2scr(MarginL);
-	} else if (render_context.evt_type == EVENT_HSCROLL) {
-		if (render_context.scroll_direction == SCROLL_RL)
-			device_x = x2scr(frame_context.track-&gt;PlayResX - render_context.scroll_shift);
-		else if (render_context.scroll_direction == SCROLL_LR)
-			device_x = x2scr(render_context.scroll_shift) - (bbox.xMax - bbox.xMin);
-	}
-
-	// y coordinate for everything except positioned events
-	if (render_context.evt_type == EVENT_NORMAL ||
-	    render_context.evt_type == EVENT_HSCROLL) {
-		if (valign == VALIGN_TOP) { // toptitle
-			device_y = y2scr_top(MarginV) + d6_to_int(text_info.lines[0].asc);
-		} else if (valign == VALIGN_CENTER) { // midtitle
-			int scr_y = y2scr(frame_context.track-&gt;PlayResY / 2);
-			device_y = scr_y - (bbox.yMax - bbox.yMin) / 2;
-		} else { // subtitle
-			int scr_y;
-			if (valign != VALIGN_SUB)
-				mp_msg(MSGT_ASS, MSGL_V, &quot;Invalid valign, supposing 0 (subtitle)\n&quot;);
-			scr_y = y2scr_sub(frame_context.track-&gt;PlayResY - MarginV);
-			device_y = scr_y;
-			device_y -= d6_to_int(text_info.height);
-			device_y += d6_to_int(text_info.lines[0].asc);
-		}
-	} else if (render_context.evt_type == EVENT_VSCROLL) {
-		if (render_context.scroll_direction == SCROLL_TB)
-			device_y = y2scr(render_context.clip_y0 + render_context.scroll_shift) - (bbox.yMax - bbox.yMin);
-		else if (render_context.scroll_direction == SCROLL_BT)
-			device_y = y2scr(render_context.clip_y1 - render_context.scroll_shift);
-	}
-
-	// positioned events are totally different
-	if (render_context.evt_type == EVENT_POSITIONED) {
-		int base_x = 0;
-		int base_y = 0;
-		mp_msg(MSGT_ASS, MSGL_DBG2, &quot;positioned event at %d, %d\n&quot;, render_context.pos_x, render_context.pos_y);
-		get_base_point(bbox, alignment, &amp;base_x, &amp;base_y);
-		device_x = x2scr(render_context.pos_x) - base_x;
-		device_y = y2scr(render_context.pos_y) - base_y;
-	}
-	
-	// fix clip coordinates (they depend on alignment)
-	render_context.clip_x0 = x2scr(render_context.clip_x0);
-	render_context.clip_x1 = x2scr(render_context.clip_x1);
-	if (render_context.evt_type == EVENT_NORMAL ||
-	    render_context.evt_type == EVENT_HSCROLL ||
-	    render_context.evt_type == EVENT_VSCROLL) {
-		if (valign == VALIGN_TOP) {
-			render_context.clip_y0 = y2scr_top(render_context.clip_y0);
-			render_context.clip_y1 = y2scr_top(render_context.clip_y1);
-		} else if (valign == VALIGN_CENTER) {
-			render_context.clip_y0 = y2scr(render_context.clip_y0);
-			render_context.clip_y1 = y2scr(render_context.clip_y1);
-		} else if (valign == VALIGN_SUB) {
-			render_context.clip_y0 = y2scr_sub(render_context.clip_y0);
-			render_context.clip_y1 = y2scr_sub(render_context.clip_y1);
-		}
-	} else if (render_context.evt_type == EVENT_POSITIONED) {
-		render_context.clip_y0 = y2scr(render_context.clip_y0);
-		render_context.clip_y1 = y2scr(render_context.clip_y1);
-	}
-
-	// calculate rotation parameters
-	{
-		FT_Vector center;
-		
-		if (render_context.have_origin) {
-			center.x = x2scr(render_context.org_x);
-			center.y = y2scr(render_context.org_y);
-		} else {
-			int bx, by;
-			get_base_point(bbox, alignment, &amp;bx, &amp;by);
-			center.x = device_x + bx;
-			center.y = device_y + by;
-		}
-
-		for (i = 0; i &lt; text_info.length; ++i) {
-			glyph_info_t* info = text_info.glyphs + i;
-
-			if (info-&gt;hash_key.frx || info-&gt;hash_key.fry || info-&gt;hash_key.frz) {
-				info-&gt;hash_key.shift_x = info-&gt;pos.x + device_x - center.x;
-				info-&gt;hash_key.shift_y = - (info-&gt;pos.y + device_y - center.y);
-			} else {
-				info-&gt;hash_key.shift_x = 0;
-				info-&gt;hash_key.shift_y = 0;
-			}
-		}
-	}
-
-	// convert glyphs to bitmaps
-	for (i = 0; i &lt; text_info.length; ++i)
-		get_bitmap_glyph(text_info.glyphs + i);
-
-	event_images-&gt;top = device_y - d6_to_int(text_info.lines[0].asc);
-	event_images-&gt;height = d6_to_int(text_info.height);
-	event_images-&gt;detect_collisions = render_context.detect_collisions;
-	event_images-&gt;shift_direction = (valign == VALIGN_TOP) ? 1 : -1;
-	event_images-&gt;event = event;
-	event_images-&gt;imgs = render_text(&amp;text_info, device_x, device_y);
-
-	free_render_context();
-	
-	return 0;
-}
-
-/**
- * \brief deallocate image list
- * \param img list pointer
- */
-void ass_free_images(ass_image_t* img)
-{
-	while (img) {
-		ass_image_t* next = img-&gt;next;
-		free(img);
-		img = next;
-	}
-}
-
-static void ass_reconfigure(ass_renderer_t* priv)
-{
-	priv-&gt;render_id = ++last_render_id;
-	ass_glyph_cache_reset();
-	ass_bitmap_cache_reset();
-	ass_free_images(priv-&gt;prev_images_root);
-	priv-&gt;prev_images_root = 0;
-}
-
-void ass_set_frame_size(ass_renderer_t* priv, int w, int h)
-{
-	if (priv-&gt;settings.frame_width != w || priv-&gt;settings.frame_height != h) {
-		priv-&gt;settings.frame_width = w;
-		priv-&gt;settings.frame_height = h;
-		if (priv-&gt;settings.aspect == 0.)
-			priv-&gt;settings.aspect = ((double)w) / h;
-		ass_reconfigure(priv);
-	}
-}
-
-void ass_set_margins(ass_renderer_t* priv, int t, int b, int l, int r)
-{
-	if (priv-&gt;settings.left_margin != l ||
-	    priv-&gt;settings.right_margin != r ||
-	    priv-&gt;settings.top_margin != t ||
-	    priv-&gt;settings.bottom_margin != b) {
-		priv-&gt;settings.left_margin = l;
-		priv-&gt;settings.right_margin = r;
-		priv-&gt;settings.top_margin = t;
-		priv-&gt;settings.bottom_margin = b;
-		ass_reconfigure(priv);
-	}
-}
-
-void ass_set_use_margins(ass_renderer_t* priv, int use)
-{
-	priv-&gt;settings.use_margins = use;
-}
-
-void ass_set_aspect_ratio(ass_renderer_t* priv, double ar)
-{
-	if (priv-&gt;settings.aspect != ar) {
-		priv-&gt;settings.aspect = ar;
-		ass_reconfigure(priv);
-	}
-}
-
-void ass_set_font_scale(ass_renderer_t* priv, double font_scale)
-{
-	if (priv-&gt;settings.font_size_coeff != font_scale) {
-		priv-&gt;settings.font_size_coeff = font_scale;
-		ass_reconfigure(priv);
-	}
-}
-
-void ass_set_hinting(ass_renderer_t* priv, ass_hinting_t ht)
-{
-	if (priv-&gt;settings.hinting != ht) {
-		priv-&gt;settings.hinting = ht;
-		ass_reconfigure(priv);
-	}
-}
-
-void ass_set_line_spacing(ass_renderer_t* priv, double line_spacing)
-{
-	priv-&gt;settings.line_spacing = line_spacing;
-}
-
-int ass_set_fonts(ass_renderer_t* priv, const char* default_font, const char* default_family)
-{
-	if (priv-&gt;settings.default_font)
-		free(priv-&gt;settings.default_font);
-	if (priv-&gt;settings.default_family)
-		free(priv-&gt;settings.default_family);
-
-	priv-&gt;settings.default_font = default_font ? strdup(default_font) : 0;
-	priv-&gt;settings.default_family = default_family ? strdup(default_family) : 0;
-
-	if (priv-&gt;fontconfig_priv)
-		fontconfig_done(priv-&gt;fontconfig_priv);
-	priv-&gt;fontconfig_priv = fontconfig_init(priv-&gt;library, priv-&gt;ftlibrary, default_family, default_font);
-
-	return !!priv-&gt;fontconfig_priv;
-}
-
-/**
- * \brief Start a new frame
- */
-static int ass_start_frame(ass_renderer_t *priv, ass_track_t* track, long long now)
-{
-	ass_renderer = priv;
-	global_settings = &amp;priv-&gt;settings;
-
-	if (!priv-&gt;settings.frame_width &amp;&amp; !priv-&gt;settings.frame_height)
-		return 1; // library not initialized
-	
-	frame_context.ass_priv = priv;
-	frame_context.width = global_settings-&gt;frame_width;
-	frame_context.height = global_settings-&gt;frame_height;
-	frame_context.orig_width = global_settings-&gt;frame_width - global_settings-&gt;left_margin - global_settings-&gt;right_margin;
-	frame_context.orig_height = global_settings-&gt;frame_height - global_settings-&gt;top_margin - global_settings-&gt;bottom_margin;
-	frame_context.track = track;
-	frame_context.time = now;
-
-	ass_lazy_track_init();
-	
-	frame_context.font_scale = global_settings-&gt;font_size_coeff *
-	                           frame_context.orig_height / frame_context.track-&gt;PlayResY;
-	frame_context.border_scale = ((double)frame_context.orig_height) / frame_context.track-&gt;PlayResY;
-
-	if (frame_context.orig_width * track-&gt;PlayResY == frame_context.orig_height * track-&gt;PlayResX)
-		frame_context.font_scale_x = 1.;
-	else
-		frame_context.font_scale_x = ((double)(frame_context.orig_width * track-&gt;PlayResY)) / (frame_context.orig_height * track-&gt;PlayResX);
-
-	priv-&gt;prev_images_root = priv-&gt;images_root;
-	priv-&gt;images_root = 0;
-
-	return 0;
-}
-
-static int cmp_event_layer(const void* p1, const void* p2)
-{
-	ass_event_t* e1 = ((event_images_t*)p1)-&gt;event;
-	ass_event_t* e2 = ((event_images_t*)p2)-&gt;event;
-	if (e1-&gt;Layer &lt; e2-&gt;Layer)
-		return -1;
-	if (e1-&gt;Layer &gt; e2-&gt;Layer)
-		return 1;
-	if (e1-&gt;ReadOrder &lt; e2-&gt;ReadOrder)
-		return -1;
-	if (e1-&gt;ReadOrder &gt; e2-&gt;ReadOrder)
-		return 1;
-	return 0;
-}
-
-#define MAX_EVENTS 100
-
-static render_priv_t* get_render_priv(ass_event_t* event)
-{
-	if (!event-&gt;render_priv)
-		event-&gt;render_priv = calloc(1, sizeof(render_priv_t));
-	// FIXME: check render_id
-	if (ass_renderer-&gt;render_id != event-&gt;render_priv-&gt;render_id) {
-		memset(event-&gt;render_priv, 0, sizeof(render_priv_t));
-		event-&gt;render_priv-&gt;render_id = ass_renderer-&gt;render_id;
-	}
-	return event-&gt;render_priv;
-}
-
-typedef struct segment_s {
-	int a, b; // top and height
-} segment_t;
-
-static int overlap(segment_t* s1, segment_t* s2)
-{
-	if (s1-&gt;a &gt;= s2-&gt;b || s2-&gt;a &gt;= s1-&gt;b)
-		return 0;
-	return 1;
-}
-
-static int cmp_segment(const void* p1, const void* p2)
-{
-	return ((segment_t*)p1)-&gt;a - ((segment_t*)p2)-&gt;a;
-}
-
-static void shift_event(event_images_t* ei, int shift)
-{
-	ass_image_t* cur = ei-&gt;imgs;
-	while (cur) {
-		cur-&gt;dst_y += shift;
-		// clip top and bottom
-		if (cur-&gt;dst_y &lt; 0) {
-			int clip = - cur-&gt;dst_y;
-			cur-&gt;h -= clip;
-			cur-&gt;bitmap += clip * cur-&gt;stride;
-			cur-&gt;dst_y = 0;
-		}
-		if (cur-&gt;dst_y + cur-&gt;h &gt;= frame_context.height) {
-			int clip = cur-&gt;dst_y + cur-&gt;h - frame_context.height;
-			cur-&gt;h -= clip;
-		}
-		if (cur-&gt;h &lt;= 0) {
-			cur-&gt;h = 0;
-			cur-&gt;dst_y = 0;
-		}
-		cur = cur-&gt;next;
-	}
-	ei-&gt;top += shift;
-}
-
-// dir: 1 - move down
-//      -1 - move up
-static int fit_segment(segment_t* s, segment_t* fixed, int* cnt, int dir)
-{
-	int i;
-	int shift = 0;
-
-	if (dir == 1) // move down
-		for (i = 0; i &lt; *cnt; ++i) {
-			if (s-&gt;b + shift &lt;= fixed[i].a || s-&gt;a + shift &gt;= fixed[i].b)
-				continue;
-			shift = fixed[i].b - s-&gt;a;
-		}
-	else // dir == -1, move up
-		for (i = *cnt-1; i &gt;= 0; --i) {
-			if (s-&gt;b + shift &lt;= fixed[i].a || s-&gt;a + shift &gt;= fixed[i].b)
-				continue;
-			shift = fixed[i].a - s-&gt;b;
-		}
-
-	fixed[*cnt].a = s-&gt;a + shift;
-	fixed[*cnt].b = s-&gt;b + shift;
-	(*cnt)++;
-	qsort(fixed, *cnt, sizeof(segment_t), cmp_segment);
-	
-	return shift;
-}
-
-static void fix_collisions(event_images_t* imgs, int cnt)
-{
-	segment_t used[MAX_EVENTS];
-	int cnt_used = 0;
-	int i, j;
-
-	// fill used[] with fixed events
-	for (i = 0; i &lt; cnt; ++i) {
-		render_priv_t* priv;
-		if (!imgs[i].detect_collisions) continue;
-		priv = get_render_priv(imgs[i].event);
-		if (priv-&gt;height &gt; 0) { // it's a fixed event
-			segment_t s;
-			s.a = priv-&gt;top;
-			s.b = priv-&gt;top + priv-&gt;height;
-			if (priv-&gt;height != imgs[i].height) { // no, it's not
-				mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_EventHeightHasChanged);
-				priv-&gt;top = 0;
-				priv-&gt;height = 0;
-			}
-			for (j = 0; j &lt; cnt_used; ++j)
-				if (overlap(&amp;s, used + j)) { // no, it's not
-					priv-&gt;top = 0;
-					priv-&gt;height = 0;
-				}
-			if (priv-&gt;height &gt; 0) { // still a fixed event
-				used[cnt_used].a = priv-&gt;top;
-				used[cnt_used].b = priv-&gt;top + priv-&gt;height;
-				cnt_used ++;
-				shift_event(imgs + i, priv-&gt;top - imgs[i].top);
-			}
-		}
-	}
-	qsort(used, cnt_used, sizeof(segment_t), cmp_segment);
-
-	// try to fit other events in free spaces
-	for (i = 0; i &lt; cnt; ++i) {
-		render_priv_t* priv;
-		if (!imgs[i].detect_collisions) continue;
-		priv = get_render_priv(imgs[i].event);
-		if (priv-&gt;height == 0) { // not a fixed event
-			int shift;
-			segment_t s;
-			s.a = imgs[i].top;
-			s.b = imgs[i].top + imgs[i].height;
-			shift = fit_segment(&amp;s, used, &amp;cnt_used, imgs[i].shift_direction);
-			if (shift) shift_event(imgs + i, shift);
-			// make it fixed
-			priv-&gt;top = imgs[i].top;
-			priv-&gt;height = imgs[i].height;
-		}
-		
-	}
-}
-
-/**
- * \brief compare two images
- * \param i1 first image
- * \param i2 second image
- * \return 0 if identical, 1 if different positions, 2 if different content
- */
-int ass_image_compare(ass_image_t *i1, ass_image_t *i2)
-{
-	if (i1-&gt;w != i2-&gt;w) return 2;
-	if (i1-&gt;h != i2-&gt;h) return 2;
-	if (i1-&gt;stride != i2-&gt;stride) return 2;
-	if (i1-&gt;color != i2-&gt;color) return 2;
-	if (i1-&gt;bitmap != i2-&gt;bitmap)
-		return 2;
-	if (i1-&gt;dst_x != i2-&gt;dst_x) return 1;
-	if (i1-&gt;dst_y != i2-&gt;dst_y) return 1;
-	return 0;
-}
-
-/**
- * \brief compare current and previous image list
- * \param priv library handle
- * \return 0 if identical, 1 if different positions, 2 if different content
- */
-int ass_detect_change(ass_renderer_t *priv)
-{
-	ass_image_t* img, *img2;
-	int diff;
-
-	img = priv-&gt;prev_images_root;
-	img2 = priv-&gt;images_root;
-	diff = 0;
-	while (img &amp;&amp; diff &lt; 2) {
-		ass_image_t* next, *next2;
-		next = img-&gt;next;
-		if (img2) {
-			int d = ass_image_compare(img, img2);
-			if (d &gt; diff) diff = d;
-			next2 = img2-&gt;next;
-		} else {
-			// previous list is shorter
-			diff = 2;
-			break;
-		}
-		img = next;
-		img2 = next2;
-	}
-
-	// is the previous list longer?
-	if (img2)
-		diff = 2;
-
-	return diff;
-}
-
-/**
- * \brief render a frame
- * \param priv library handle
- * \param track track
- * \param now current video timestamp (ms)
- * \param detect_change a value describing how the new images differ from the previous ones will be written here:
- *        0 if identical, 1 if different positions, 2 if different content.
- *        Can be NULL, in that case no detection is performed.
- */
-ass_image_t* ass_render_frame(ass_renderer_t *priv, ass_track_t* track, long long now, int* detect_change)
-{
-	int i, cnt, rc;
-	event_images_t* last;
-	ass_image_t** tail;
-	
-	// init frame
-	rc = ass_start_frame(priv, track, now);
-	if (rc != 0)
-		return 0;
-
-	// render events separately
-	cnt = 0;
-	for (i = 0; i &lt; track-&gt;n_events; ++i) {
-		ass_event_t* event = track-&gt;events + i;
-		if ( (event-&gt;Start &lt;= now) &amp;&amp; (now &lt; (event-&gt;Start + event-&gt;Duration)) ) {
-			if (cnt &gt;= priv-&gt;eimg_size) {
-				priv-&gt;eimg_size += 100;
-				priv-&gt;eimg = realloc(priv-&gt;eimg, priv-&gt;eimg_size * sizeof(event_images_t));
-			}
-			rc = ass_render_event(event, priv-&gt;eimg + cnt);
-			if (!rc) ++cnt;
-		}
-	}
-
-	// sort by layer
-	qsort(priv-&gt;eimg, cnt, sizeof(event_images_t), cmp_event_layer);
-
-	// call fix_collisions for each group of events with the same layer
-	last = priv-&gt;eimg;
-	for (i = 1; i &lt; cnt; ++i)
-		if (last-&gt;event-&gt;Layer != priv-&gt;eimg[i].event-&gt;Layer) {
-			fix_collisions(last, priv-&gt;eimg + i - last);
-			last = priv-&gt;eimg + i;
-		}
-	if (cnt &gt; 0)
-		fix_collisions(last, priv-&gt;eimg + cnt - last);
-
-	// concat lists
-	tail = &amp;ass_renderer-&gt;images_root;
-	for (i = 0; i &lt; cnt; ++i) {
-		ass_image_t* cur = priv-&gt;eimg[i].imgs;
-		while (cur) {
-			*tail = cur;
-			tail = &amp;cur-&gt;next;
-			cur = cur-&gt;next;
-		}
-	}
-
-	if (detect_change)
-		*detect_change = ass_detect_change(priv);
-	
-	// free the previous image list
-	ass_free_images(priv-&gt;prev_images_root);
-	priv-&gt;prev_images_root = 0;
-
-	return ass_renderer-&gt;images_root;
-}
-

Deleted: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_types.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_types.h	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_types.h	2009-08-01 07:55:22 UTC (rev 5185)
@@ -1,114 +0,0 @@
-// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
-// vim:ts=8:sw=8:noet:ai:
-/*
-  Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
-*/
-
-#ifndef ASS_TYPES_H
-#define ASS_TYPES_H
-
-#define VALIGN_SUB 0
-#define VALIGN_CENTER 8
-#define VALIGN_TOP 4
-#define HALIGN_LEFT 1
-#define HALIGN_CENTER 2
-#define HALIGN_RIGHT 3
-
-/// ass Style: line
-typedef struct ass_style_s {
-	char* Name;
-	char* FontName;
-	double FontSize;
-	uint32_t PrimaryColour;
-	uint32_t SecondaryColour;
-	uint32_t OutlineColour;
-	uint32_t BackColour;
-	int Bold;
-	int Italic;
-	int Underline;
-	int StrikeOut;
-	double ScaleX;
-	double ScaleY;
-	double Spacing;
-	int Angle;
-	int BorderStyle;
-	double Outline;
-	double Shadow;
-	int Alignment;
-	int MarginL;
-	int MarginR;
-	int MarginV;
-//        int AlphaLevel;
-	int Encoding;
-} ass_style_t;
-
-typedef struct render_priv_s render_priv_t;
-
-/// ass_event_t corresponds to a single Dialogue line
-/// Text is stored as-is, style overrides will be parsed later
-typedef struct ass_event_s {
-	long long Start; // ms
-	long long Duration; // ms
-
-	int ReadOrder;
-	int Layer;
-	int Style;
-	char* Name;
-	int MarginL;
-	int MarginR;
-	int MarginV;
-	char* Effect;
-	char* Text;
-
-	render_priv_t* render_priv;
-} ass_event_t;
-
-typedef struct parser_priv_s parser_priv_t;
-
-typedef struct ass_library_s ass_library_t;
-
-/// ass track represent either an external script or a matroska subtitle stream (no real difference between them)
-/// it can be used in rendering after the headers are parsed (i.e. events format line read)
-typedef struct ass_track_s {
-	int n_styles; // amount used
-	int max_styles; // amount allocated
-	int n_events;
-	int max_events;
-	ass_style_t* styles; // array of styles, max_styles length, n_styles used
-	ass_event_t* events; // the same as styles
-
-	char* style_format; // style format line (everything after &quot;Format: &quot;)
-	char* event_format; // event format line
-
-	enum {TRACK_TYPE_UNKNOWN = 0, TRACK_TYPE_ASS, TRACK_TYPE_SSA} track_type;
-	
-	// script header fields
-	int PlayResX;
-	int PlayResY;
-	double Timer;
-	int WrapStyle;
-
-	
-	int default_style; // index of default style
-	char* name; // file name in case of external subs, 0 for streams
-
-	ass_library_t* library;
-	parser_priv_t* parser_priv;
-} ass_track_t;
-
-#endif
-

Deleted: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_utils.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_utils.c	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_utils.c	2009-08-01 07:55:22 UTC (rev 5185)
@@ -1,81 +0,0 @@
-// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
-// vim:ts=8:sw=8:noet:ai:
-/*
-  Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
-*/
-
-//#include &quot;config.h&quot;
-
-#include &lt;stdlib.h&gt;
-#include &lt;inttypes.h&gt;
-
-#include &quot;mputils.h&quot;
-#include &quot;ass_utils.h&quot;
-
-int mystrtoi(char** p, int base, int* res)
-{
-	char* start = *p;
-	*res = strtol(*p, p, base);
-	if (*p != start) return 1;
-	else return 0;
-}
-
-int mystrtou32(char** p, int base, uint32_t* res)
-{
-	char* start = *p;
-	*res = strtoll(*p, p, base);
-	if (*p != start) return 1;
-	else return 0;
-}
-
-int mystrtod(char** p, double* res)
-{
-	char* start = *p;
-	*res = strtod(*p, p);
-	if (*p != start) return 1;
-	else return 0;
-}
-
-int strtocolor(char** q, uint32_t* res)
-{
-	uint32_t color = 0;
-	int result;
-	char* p = *q;
-	
-	if (*p == '&amp;') ++p; 
-	else mp_msg(MSGT_ASS, MSGL_DBG2, &quot;suspicious color format: \&quot;%s\&quot;\n&quot;, p);
-	
-	if (*p == 'H' || *p == 'h') { 
-		++p;
-		result = mystrtou32(&amp;p, 16, &amp;color);
-	} else {
-		result = mystrtou32(&amp;p, 0, &amp;color);
-	}
-	
-	{
-		unsigned char* tmp = (unsigned char*)(&amp;color);
-		unsigned char b;
-		b = tmp[0]; tmp[0] = tmp[3]; tmp[3] = b;
-		b = tmp[1]; tmp[1] = tmp[2]; tmp[2] = b;
-	}
-	if (*p == '&amp;') ++p;
-	*q = p;
-
-	*res = color;
-	return result;
-}
-

Deleted: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_utils.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_utils.h	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_utils.h	2009-08-01 07:55:22 UTC (rev 5185)
@@ -1,61 +0,0 @@
-// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
-// vim:ts=8:sw=8:noet:ai:
-/*
-  Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
-*/
-
-#ifndef ASS_UTILS_H
-#define ASS_UTILS_H
-
-int mystrtoi(char** p, int base, int* res);
-int mystrtou32(char** p, int base, uint32_t* res);
-int mystrtod(char** p, double* res);
-int strtocolor(char** q, uint32_t* res);
-
-static inline int d6_to_int(int x) {
-	return (x + 32) &gt;&gt; 6;
-}
-static inline int d16_to_int(int x) {
-	return (x + 32768) &gt;&gt; 16;
-}
-static inline int int_to_d6(int x) {
-	return x &lt;&lt; 6;
-}
-static inline int int_to_d16(int x) {
-	return x &lt;&lt; 16;
-}
-static inline int d16_to_d6(int x) {
-	return (x + 512) &gt;&gt; 10;
-}
-static inline int d6_to_d16(int x) {
-	return x &lt;&lt; 10;
-}
-static inline double d6_to_double(int x) {
-	return x / 64.;
-}
-static inline int double_to_d6(double x) {
-	return (int)(x * 64);
-}
-static inline double d16_to_double(int x) {
-	return ((double)x) / 0x10000;
-}
-static inline int double_to_d16(double x) {
-	return (int)(x * 0x10000);
-}
-
-#endif
-

Deleted: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/help_mp.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/help_mp.h	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/help_mp.h	2009-08-01 07:55:22 UTC (rev 5185)
@@ -1,55 +0,0 @@
-#ifndef __LIBASS_HELP_MP_H__
-#define __LIBASS_HELP_MP_H__
-#define MSGTR_LIBASS_FT_Glyph_To_BitmapError &quot;[ass] FT_Glyph_To_Bitmap error %d \n&quot;
-#define MSGTR_LIBASS_UnsupportedPixelMode &quot;[ass] Unsupported pixel mode: %d\n&quot;
-#define MSGTR_LIBASS_NoStyleNamedXFoundUsingY &quot;[ass] [%p] Warning: no style named '%s' found, using '%s'\n&quot;
-#define MSGTR_LIBASS_BadTimestamp &quot;[ass] bad timestamp\n&quot;
-#define MSGTR_LIBASS_BadEncodedDataSize &quot;[ass] bad encoded data size\n&quot;
-#define MSGTR_LIBASS_FontLineTooLong &quot;[ass] Font line too long: %d, %s\n&quot;
-#define MSGTR_LIBASS_EventFormatHeaderMissing &quot;[ass] Event format header missing\n&quot;
-#define MSGTR_LIBASS_ErrorOpeningIconvDescriptor &quot;[ass] error opening iconv descriptor.\n&quot;
-#define MSGTR_LIBASS_ErrorRecodingFile &quot;[ass] error recoding file.\n&quot;
-#define MSGTR_LIBASS_FopenFailed &quot;[ass] ass_read_file(%s): fopen failed\n&quot;
-#define MSGTR_LIBASS_FseekFailed &quot;[ass] ass_read_file(%s): fseek failed\n&quot;
-#define MSGTR_LIBASS_RefusingToLoadSubtitlesLargerThan10M &quot;[ass] ass_read_file(%s): Refusing to load subtitles larger than 10M\n&quot;
-#define MSGTR_LIBASS_ReadFailed &quot;Read failed, %d: %s\n&quot;
-#define MSGTR_LIBASS_AddedSubtitleFileMemory &quot;[ass] Added subtitle file: &lt;memory&gt; (%d styles, %d events)\n&quot;
-#define MSGTR_LIBASS_AddedSubtitleFileFname &quot;[ass] Added subtitle file: %s (%d styles, %d events)\n&quot;
-#define MSGTR_LIBASS_FailedToCreateDirectory &quot;[ass] Failed to create directory %s\n&quot;
-#define MSGTR_LIBASS_NotADirectory &quot;[ass] Not a directory: %s\n&quot;
-#define MSGTR_LIBASS_TooManyFonts &quot;[ass] Too many fonts\n&quot;
-#define MSGTR_LIBASS_ErrorOpeningFont &quot;[ass] Error opening font: %s, %d\n&quot;
-#define MSGTR_LIBASS_SelectedFontFamilyIsNotTheRequestedOne &quot;[ass] fontconfig: Selected font family is not the requested one: '%s' != '%s'\n&quot;
-#define MSGTR_LIBASS_UsingDefaultFontFamily &quot;[ass] fontconfig_select: Using default font family: (%s, %d, %d) -&gt; %s, %d\n&quot;
-#define MSGTR_LIBASS_UsingDefaultFont &quot;[ass] fontconfig_select: Using default font: (%s, %d, %d) -&gt; %s, %d\n&quot;
-#define MSGTR_LIBASS_UsingArialFontFamily &quot;[ass] fontconfig_select: Using 'Arial' font family: (%s, %d, %d) -&gt; %s, %d\n&quot;
-#define MSGTR_LIBASS_FcInitLoadConfigAndFontsFailed &quot;[ass] FcInitLoadConfigAndFonts failed.\n&quot;
-#define MSGTR_LIBASS_UpdatingFontCache &quot;[ass] Updating font cache.\n&quot;
-#define MSGTR_LIBASS_BetaVersionsOfFontconfigAreNotSupported &quot;[ass] Beta versions of fontconfig are not supported.\n[ass] Update before reporting any bugs.\n&quot;
-#define MSGTR_LIBASS_FcStrSetAddFailed &quot;[ass] FcStrSetAdd failed.\n&quot;
-#define MSGTR_LIBASS_FcDirScanFailed &quot;[ass] FcDirScan failed.\n&quot;
-#define MSGTR_LIBASS_FcDirSave &quot;[ass] FcDirSave failed.\n&quot;
-#define MSGTR_LIBASS_FcConfigAppFontAddDirFailed &quot;[ass] FcConfigAppFontAddDir failed\n&quot;
-#define MSGTR_LIBASS_FontconfigDisabledDefaultFontWillBeUsed &quot;[ass] Fontconfig disabled, only default font will be used.\n&quot;
-#define MSGTR_LIBASS_FunctionCallFailed &quot;[ass] %s failed\n&quot;
-#define MSGTR_LIBASS_NeitherPlayResXNorPlayResYDefined &quot;[ass] Neither PlayResX nor PlayResY defined. Assuming 384x288.\n&quot;
-#define MSGTR_LIBASS_PlayResYUndefinedSettingY &quot;[ass] PlayResY undefined, setting %d.\n&quot;
-#define MSGTR_LIBASS_PlayResXUndefinedSettingX &quot;[ass] PlayResX undefined, setting %d.\n&quot;
-#define MSGTR_LIBASS_FT_Init_FreeTypeFailed &quot;[ass] FT_Init_FreeType failed.\n&quot;
-#define MSGTR_LIBASS_Init &quot;[ass] Init\n&quot;
-#define MSGTR_LIBASS_InitFailed &quot;[ass] Init failed.\n&quot;
-#define MSGTR_LIBASS_BadCommand &quot;[ass] Bad command: %c%c\n&quot;
-#define MSGTR_LIBASS_ErrorLoadingGlyph  &quot;[ass] Error loading glyph.\n&quot;
-#define MSGTR_LIBASS_FT_Glyph_Stroke_Error &quot;[ass] FT_Glyph_Stroke error %d \n&quot;
-#define MSGTR_LIBASS_UnknownEffectType_InternalError &quot;[ass] Unknown effect type (internal error)\n&quot;
-#define MSGTR_LIBASS_NoStyleFound &quot;[ass] No style found!\n&quot;
-#define MSGTR_LIBASS_EmptyEvent &quot;[ass] Empty event!\n&quot;
-#define MSGTR_LIBASS_MAX_GLYPHS_Reached &quot;[ass] MAX_GLYPHS reached: event %d, start = %llu, duration = %llu\n Text = %s\n&quot;
-#define MSGTR_LIBASS_EventHeightHasChanged &quot;[ass] Warning! Event height has changed!  \n&quot;
-#define MSGTR_LIBASS_GlyphNotFoundReselectingFont &quot;[ass] Glyph 0x%X not found, reselecting font for (%s, %d, %d)\n&quot;
-#define MSGTR_LIBASS_GlyphNotFound &quot;[ass] Glyph 0x%X not found in font for (%s, %d, %d)\n&quot;
-#define MSGTR_LIBASS_ErrorOpeningMemoryFont &quot;[ass] Error opening memory font: %s\n&quot;
-#define MSGTR_LIBASS_NoCharmaps &quot;[ass] font face with no charmaps\n&quot;
-#define MSGTR_LIBASS_NoCharmapAutodetected &quot;[ass] no charmap autodetected, trying the first one\n&quot;
-#endif
-

Deleted: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/mputils.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/mputils.c	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/mputils.c	2009-08-01 07:55:22 UTC (rev 5185)
@@ -1,218 +0,0 @@
-//#include &quot;config.h&quot;
-
-#include &quot;mputils.h&quot;
-
-#include &lt;stdio.h&gt;
-#include &lt;stdarg.h&gt;
-#include &lt;stdint.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-#include &lt;assert.h&gt;
-
-#ifdef HAVE_ENCA
-#include &lt;enca.h&gt;
-#endif
-
-void my_mp_msg(int lvl, char *lvl_str, char *fmt, ...) {
-	va_list va;
-	if(lvl &gt; MSGL_V) return;
-	printf(&quot;[ass] **%s**: &quot;, lvl_str);
-	va_start(va, fmt);
-	vprintf(fmt, va);
-	va_end(va);
-}
-
-unsigned utf8_get_char(char **str) {
-  uint8_t *strp = (uint8_t *)*str;
-  unsigned c = *strp++;
-  unsigned mask = 0x80;
-  int len = -1;
-  while (c &amp; mask) {
-    mask &gt;&gt;= 1;
-    len++;
-  }
-  if (len &lt;= 0 || len &gt; 4)
-    goto no_utf8;
-  c &amp;= mask - 1;
-  while ((*strp &amp; 0xc0) == 0x80) {
-    if (len-- &lt;= 0)
-      goto no_utf8;
-    c = (c &lt;&lt; 6) | (*strp++ &amp; 0x3f);
-  }
-  if (len)
-    goto no_utf8;
-  *str = (char *)strp;
-  return c;
-
-no_utf8:
-  strp = (uint8_t *)*str;
-  c = *strp++;
-  *str = (char *)strp;
-  return c;
-}
-
-// gaussian blur
-void blur(
-	unsigned char *buffer,
-	unsigned short *tmp2,
-	int width,
-	int height,
-	int stride,
-	int *m2,
-	int r,
-	int mwidth) {
-
-    int x, y;
-
-    unsigned char  *s = buffer;
-    unsigned short *t = tmp2+1;
-    for(y=0; y&lt;height; y++){
-	memset(t-1, 0, (width+1)*sizeof(short));
-
-	for(x=0; x&lt;r; x++){
-	    const int src= s[x];
-	    if(src){
-		register unsigned short *dstp= t + x-r;
-		int mx;
-		unsigned *m3= m2 + src*mwidth;
-		for(mx=r-x; mx&lt;mwidth; mx++){
-		    dstp[mx]+= m3[mx];
-		}
-	    }
-	}
-
-	for(; x&lt;width-r; x++){
-	    const int src= s[x];
-	    if(src){
-		register unsigned short *dstp= t + x-r;
-		int mx;
-		unsigned *m3= m2 + src*mwidth;
-		for(mx=0; mx&lt;mwidth; mx++){
-		    dstp[mx]+= m3[mx];
-		}
-	    }
-	}
-
-	for(; x&lt;width; x++){
-	    const int src= s[x];
-	    if(src){
-		register unsigned short *dstp= t + x-r;
-		int mx;
-		const int x2= r+width -x;
-		unsigned *m3= m2 + src*mwidth;
-		for(mx=0; mx&lt;x2; mx++){
-		    dstp[mx]+= m3[mx];
-		}
-	    }
-	}
-
-	s+= stride;
-	t+= width + 1;
-    }
-
-    t = tmp2;
-    for(x=0; x&lt;width; x++){
-	for(y=0; y&lt;r; y++){
-	    unsigned short *srcp= t + y*(width+1) + 1;
-	    int src= *srcp;
-	    if(src){
-		register unsigned short *dstp= srcp - 1 + width+1;
-		const int src2= (src + 128)&gt;&gt;8;
-		unsigned *m3= m2 + src2*mwidth;
-
-		int mx;
-		*srcp= 128;
-		for(mx=r-1; mx&lt;mwidth; mx++){
-		    *dstp += m3[mx];
-		    dstp+= width+1;
-		}
-	    }
-	}
-	for(; y&lt;height-r; y++){
-	    unsigned short *srcp= t + y*(width+1) + 1;
-	    int src= *srcp;
-	    if(src){
-		register unsigned short *dstp= srcp - 1 - r*(width+1);
-		const int src2= (src + 128)&gt;&gt;8;
-		unsigned *m3= m2 + src2*mwidth;
-
-		int mx;
-		*srcp= 128;
-		for(mx=0; mx&lt;mwidth; mx++){
-		    *dstp += m3[mx];
-		    dstp+= width+1;
-		}
-	    }
-	}
-	for(; y&lt;height; y++){
-	    unsigned short *srcp= t + y*(width+1) + 1;
-	    int src= *srcp;
-	    if(src){
-		const int y2=r+height-y;
-		register unsigned short *dstp= srcp - 1 - r*(width+1);
-		const int src2= (src + 128)&gt;&gt;8;
-		unsigned *m3= m2 + src2*mwidth;
-
-		int mx;
-		*srcp= 128;
-		for(mx=0; mx&lt;y2; mx++){
-		    *dstp += m3[mx];
-		    dstp+= width+1;
-		}
-	    }
-	}
-	t++;
-    }
-
-    t = tmp2;
-    s = buffer;
-    for(y=0; y&lt;height; y++){
-	for(x=0; x&lt;width; x++){
-	    s[x]= t[x]&gt;&gt;8;
-	}
-	s+= stride;
-	t+= width + 1;
-    }
-}
-
-#ifdef HAVE_ENCA
-void* guess_buffer_cp(unsigned char* buffer, int buflen, char *preferred_language, char *fallback)
-{
-    const char **languages;
-    size_t langcnt;
-    EncaAnalyser analyser;
-    EncaEncoding encoding;
-    char *detected_sub_cp = NULL;
-    int i;
-
-    languages = enca_get_languages(&amp;langcnt);
-    mp_msg(MSGT_ASS, MSGL_V, &quot;ENCA supported languages: &quot;);
-    for (i = 0; i &lt; langcnt; i++) {
-	mp_msg(MSGT_ASS, MSGL_V, &quot;%s &quot;, languages[i]);
-    }
-    mp_msg(MSGT_ASS, MSGL_V, &quot;\n&quot;);
-    
-    for (i = 0; i &lt; langcnt; i++) {
-	const char *tmp;
-	
-	if (strcasecmp(languages[i], preferred_language) != 0) continue;
-	analyser = enca_analyser_alloc(languages[i]);
-	encoding = enca_analyse_const(analyser, buffer, buflen);
-	tmp = enca_charset_name(encoding.charset, ENCA_NAME_STYLE_ICONV);
-	if (tmp &amp;&amp; encoding.charset != ENCA_CS_UNKNOWN) {
-	    detected_sub_cp = strdup(tmp);
-	    mp_msg(MSGT_ASS, MSGL_INFO, &quot;ENCA detected charset: %s\n&quot;, tmp);
-	}
-	enca_analyser_free(analyser);
-    }
-    
-    free(languages);
-
-    if (!detected_sub_cp) {
-	detected_sub_cp = strdup(fallback);
-	mp_msg(MSGT_ASS, MSGL_INFO, &quot;ENCA detection failed: fallback to %s\n&quot;, fallback);
-    }
-
-    return detected_sub_cp;
-}
-#endif

Deleted: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/mputils.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/mputils.h	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/mputils.h	2009-08-01 07:55:22 UTC (rev 5185)
@@ -1,35 +0,0 @@
-#ifndef __MPUTILS_H__
-#define __MPUTILS_H__
-
-#include &quot;help_mp.h&quot;
-
-unsigned utf8_get_char(char **str);
-
-void my_mp_msg(int lvl, char *lvl_str, char *fmt, ...);
-
-#ifdef __VISUALC__
-static void mp_msg(int mod, int level, const char *fmt, ...) {
-	// MSVC doesn't like the # used all around for mp_msg, so it breaks va_arg
-}
-#else
-#define mp_msg(mod, level, args...) my_mp_msg(level, #level, args)
-#endif
-
-#define MSGT_ASS 43
-
-#define MSGL_FATAL 0
-#define MSGL_ERR 1
-#define MSGL_WARN 2
-#define MSGL_INFO 4
-#define MSGL_V 6
-#define MSGL_DBG2 7
-
-void blur(unsigned char *buffer, unsigned short *tmp2, int width, int height,
-          int stride, int *m2, int r, int mwidth);
-
-void* guess_buffer_cp(unsigned char* buffer, int buflen, char *preferred_language, char *fallback);
-
-#define FFMAX(a,b) ((a) &gt; (b) ? (a) : (b))
-#define FFMIN(a,b) ((a) &gt; (b) ? (b) : (a))
-
-#endif

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_vidASS.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_vidASS.cpp	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_vidASS.cpp	2009-08-01 07:55:22 UTC (rev 5185)
@@ -174,7 +174,10 @@
         ass_set_margins(_ass_rend, _params-&gt;top_margin, _params-&gt;bottom_margin, 0, 0);
         ass_set_use_margins(_ass_rend, use_margins);
         ass_set_font_scale(_ass_rend, _params-&gt;font_scale);
-        ass_set_fonts(_ass_rend, NULL, &quot;Sans&quot;);
+        ass_set_fonts(_ass_rend, NULL, &quot;Sans&quot;,
+                false, // No fontconfig
+                NULL,
+                false);
         //~ ass_set_aspect_ratio(_ass_rend, ((double)_info.width) / ((double)_info.height));
 #if ASS_HAS_GLOBAL
         if(_ass_track) 

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_vidASS.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_vidASS.h	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_vidASS.h	2009-08-01 07:55:22 UTC (rev 5185)
@@ -14,7 +14,7 @@
 
 extern &quot;C&quot;
 {
-#include &quot;ADM_libass/ass.h&quot;
+#include &quot;ADM_libAss/ass.h&quot;
 }
 #include &quot;ADM_vidAss_Params.h&quot; 
 class ADMVideoSubASS : public AVDMGenericVideoStream 

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/CMakeLists.txt	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/CMakeLists.txt	2009-08-01 07:55:22 UTC (rev 5185)
@@ -2,7 +2,7 @@
 checkFreeType()
 
 IF (USE_FREETYPE)
-	ADD_SUBDIRECTORY(ADM_libass)
+	ADD_SUBDIRECTORY(ADM_libAss)
 
 	INCLUDE(vf_plugin)
 	SET(ADM_vf_ssa_SRCS ADM_vidASS.cpp)


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002398.html">[Avidemux-svn-commit] r5184 - in	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs:	ADM_GTK/src ADM_QT4/src
</A></li>
	<LI>Next message: <A HREF="002400.html">[Avidemux-svn-commit] r5186 -	branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2399">[ date ]</a>
              <a href="thread.html#2399">[ thread ]</a>
              <a href="subject.html#2399">[ subject ]</a>
              <a href="author.html#2399">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
