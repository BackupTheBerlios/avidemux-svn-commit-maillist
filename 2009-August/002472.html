<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r5259 -	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2009-August/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r5259%20-%0A%09branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf&In-Reply-To=%3C200908211532.n7LFWwjJ027630%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002471.html">
   <LINK REL="Next"  HREF="002473.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r5259 -	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf</H1>
    <B>mean at BerliOS</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r5259%20-%0A%09branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf&In-Reply-To=%3C200908211532.n7LFWwjJ027630%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r5259 -	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf">mean at mail.berlios.de
       </A><BR>
    <I>Fri Aug 21 17:32:58 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="002471.html">[Avidemux-svn-commit] r5258 -	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs
</A></li>
        <LI>Next message: <A HREF="002473.html">[Avidemux-svn-commit] r5260 -	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Flv
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2472">[ date ]</a>
              <a href="thread.html#2472">[ thread ]</a>
              <a href="subject.html#2472">[ subject ]</a>
              <a href="author.html#2472">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2009-08-21 17:32:56 +0200 (Fri, 21 Aug 2009)
New Revision: 5259

Added:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfHeaders.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfAudio.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfPacket.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/CMakeLists.txt
Log:
[Asf/Demuxer] Incomplete asf demuxer

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf.cpp	2009-08-21 15:32:55 UTC (rev 5258)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf.cpp	2009-08-21 15:32:56 UTC (rev 5259)
@@ -29,9 +29,6 @@
 #define aprintf(...) {}
 #endif
 
-static const uint8_t asf_audio[16]={0x40,0x9e,0x69,0xf8,0x4d,0x5b,0xcf,0x11,0xa8,0xfd,0x00,0x80,0x5f,0x5c,0x44,0x2b};
-static const uint8_t asf_video[16]={0xc0,0xef,0x19,0xbc,0x4d,0x5b,0xcf,0x11,0xa8,0xfd,0x00,0x80,0x5f,0x5c,0x44,0x2b};
-
 /**
     \fn getAudioInfo
 */
@@ -309,11 +306,7 @@
             delete bit;
             if(delta&lt;230)
             {
-              printf(&quot;Very suspicious\n&quot;);
-              printf(&quot;Very suspicious\n&quot;);
-              printf(&quot;Very suspicious\n&quot;);
-              printf(&quot;Very suspicious\n&quot;);
-              printf(&quot;Very suspicious\n&quot;);
+              printf(&quot;[ASF] Very suspicious delta :%&quot;LU&quot;\n&quot;,delta);
             }
             continue; 
           }
@@ -364,449 +357,4 @@
     __________________________________________________________
 */
 
-/** *****************************************
-    \fn getHeaders
-    \brief Read Headers to collect information 
-********************************************/
-uint8_t asfHeader::getHeaders(void)
-{
-  uint32_t i=0,nbSubChunk,hi,lo;
-  const chunky *id;
-  uint8_t gid[16];
-  uint32_t mn=0,mx=0;
-  asfChunk chunk(_fd);
-  // The first header is header chunk
-  chunk.nextChunk();
-  id=chunk.chunkId();
-  if(id-&gt;id!=ADM_CHUNK_HEADER_CHUNK)
-  {
-    printf(&quot;[ASF] expected header chunk\n&quot;); 
-    return 0;
-  }
-  printf(&quot;[ASF] getting headers\n&quot;);
-  chunk.dump();
-  nbSubChunk=chunk.read32();
-  printf(&quot;NB subchunk :%u\n&quot;,nbSubChunk);
-  chunk.read8();
-  chunk.read8();
-  for(i=0;i&lt;nbSubChunk;i++)
-  {
-    asfChunk *s=new asfChunk(_fd);
-    uint32_t skip;
-    s-&gt;nextChunk();
-    printf(&quot;***************\n&quot;);  
-    id=s-&gt;chunkId();
-    s-&gt;dump();
-    switch(id-&gt;id)
-    {
-#if 0      
-      case ADM_CHUNK_HEADER_EXTENSION_CHUNK:
-      {
-        s-&gt;skip(16); // Clock type extension ????
-        printf(&quot;?? %d\n&quot;,s-&gt;read16());
-        printf(&quot;?? %d\n&quot;,s-&gt;read32());
-          
-        uint32_t streamNameCount;
-        uint32_t payloadCount;
-          
-          asfChunk *u=new asfChunk(_fd);
-          for(int zzz=0;zzz&lt;8;zzz++)
-          {
-              u-&gt;nextChunk();
-              u-&gt;dump();
-              id=u-&gt;chunkId();
-              if(id-&gt;id==ADM_CHUNK_EXTENDED_STREAM_PROP)
-              {
-                  s-&gt;skip(8); // start time 
-                  s-&gt;skip(8); // end time
-                  printf(&quot;Bitrate         %u :\n&quot;,u-&gt;read32());
-                  printf(&quot;Buffer Size     %u :\n&quot;,u-&gt;read32());
-                  printf(&quot;BFill           %u :\n&quot;,u-&gt;read32());
-                  printf(&quot;Alt Bitrate     %u :\n&quot;,u-&gt;read32());
-                  printf(&quot;Alt Bsize       %u :\n&quot;,u-&gt;read32());
-                  printf(&quot;Alt Bfullness   %u :\n&quot;,u-&gt;read32());
-                  printf(&quot;Max object Size %u :\n&quot;,u-&gt;read32());
-                  printf(&quot;Flags           0x%x :\n&quot;,u-&gt;read32());
-                  printf(&quot;Stream no       %u :\n&quot;,u-&gt;read16());
-                  printf(&quot;Stream lang     %u :\n&quot;,u-&gt;read16());
-                  printf(&quot;Stream time/fra %lu :\n&quot;,u-&gt;read64());
-                  streamNameCount=u-&gt;read16();
-                  payloadCount=u-&gt;read16();
-                  printf(&quot;Stream Nm Count %u :\n&quot;,streamNameCount);
-                  printf(&quot;Payload count   %u :\n&quot;,payloadCount);
-                  for(int stream=0;stream&lt;streamNameCount;stream++)
-                  {
-                    u-&gt;read16();
-                    skip=u-&gt;read16();
-                    u-&gt;skip(skip);
-                  }
-                  uint32_t size;
-                  for(int payload=0;payload&lt;payloadCount;payload++)
-                  {
-                    for(int pp=0;pp&lt;16;pp++) printf(&quot;0x%02x,&quot;,u-&gt;read8());
-                    printf(&quot;\n&quot;);
-                    skip=u-&gt;read16();
-                    size=u-&gt;read32();
-                    u-&gt;skip(size);
-                    printf(&quot;Extra Data : %d, skipd %d\n&quot;,size,skip);
-                  }
-                  printf(&quot;We are at %x\n&quot;,ftello(_fd));
-                }
-                u-&gt;skipChunk();
-          }
-          delete u;
-      }
-      break;
-#endif      
-      case ADM_CHUNK_FILE_HEADER_CHUNK:
-        {
-            // Client GID
-            printf(&quot;Client        :&quot;);
-            for(int z=0;z&lt;16;z++) printf(&quot;:%02x&quot;,s-&gt;read8());
-            printf(&quot;\n&quot;);
-            printf(&quot;File size     : %08lx\n&quot;,s-&gt;read64());
-            printf(&quot;Creation time : %08lx\n&quot;,s-&gt;read64());
-            printf(&quot;Number of pack: %08lx\n&quot;,s-&gt;read64());
-            printf(&quot;Timestamp 1   : %08lx\n&quot;,s-&gt;read64());
-            _duration=s-&gt;read64();
-            printf(&quot;Timestamp 2   : %08lx\n&quot;,_duration);
-            printf(&quot;Timestamp 3   : %04x\n&quot;,s-&gt;read32());
-            printf(&quot;Preload       : %04x\n&quot;,s-&gt;read32());
-            printf(&quot;Flags         : %04x\n&quot;,s-&gt;read32());
-            mx=s-&gt;read32();
-            mn=s-&gt;read32();
-            if(mx!=mn)
-            {
-              printf(&quot;Variable packet size!!\n&quot;);
-              delete s;
-              return 0; 
-            }
-            _packetSize=mx;
-            printf(&quot;Min size      : %04x\n&quot;,mx);
-            printf(&quot;Max size      : %04x\n&quot;,mn);
-            printf(&quot;Uncompres.size: %04x\n&quot;,s-&gt;read32());
-          }
-          break;
-      case ADM_CHUNK_STREAM_HEADER_CHUNK:
-      {
-         // Client GID
-        uint32_t audiovideo=0; // video=1, audio=2, 0=unknown
-        uint32_t sid;
-        s-&gt;read(gid,16);
-        printf(&quot;Type            :&quot;);
-        for(int z=0;z&lt;16;z++) printf(&quot;0x%02x,&quot;,gid[z]);
-        if(!memcmp(gid,asf_video,16))
-        {
-          printf(&quot;(video)&quot;);
-          audiovideo=1;
-        } else
-        {
-          if(!memcmp(gid,asf_audio,16))
-          {
-            printf(&quot;(audio)&quot;); 
-            audiovideo=2;
-          } else printf(&quot;(? ? ? ?)&quot;); 
-        }
-        printf(&quot;\nConceal       :&quot;);
-        for(int z=0;z&lt;16;z++) printf(&quot;:%02x&quot;,s-&gt;read8());
-        printf(&quot;\n&quot;);
-        printf(&quot;Reserved    : %08&quot;LLX&quot;\n&quot;,s-&gt;read64());
-        printf(&quot;Total Size  : %04&quot;LX&quot;\n&quot;,s-&gt;read32());
-        printf(&quot;Size        : %04&quot;LX&quot;\n&quot;,s-&gt;read32());
-        sid=s-&gt;read16();
-        printf(&quot;Stream nb   : %04d\n&quot;,sid);
-        printf(&quot;Reserved    : %04&quot;LX&quot;\n&quot;,s-&gt;read32());
-        switch(audiovideo)
-        {
-          case 1: // Video
-          {
-                    _videoStreamId=sid;
-                    if(!loadVideo(s))
-                    {
-                      delete s;
-                      return 0; 
-                    }
-                    break;
-          }
-              break;
-          case 2: // audio
-          {
-            asfAudioTrak *trk=&amp;(_allAudioTracks[_nbAudioTrack]);
-            ADM_assert(_nbAudioTrack&lt;ASF_MAX_AUDIO_TRACK);
-            trk-&gt;streamIndex=sid;
-            s-&gt;read((uint8_t *)&amp;(trk-&gt;wavHeader),sizeof(WAVHeader));
-            printf(&quot;[Asf] Encoding for audio 0x%x\n&quot;,trk-&gt;wavHeader.encoding);
-		#ifdef ADM_BIG_ENDIAN
-			Endian_WavHeader(&amp;(trk-&gt;wavHeader));
-		#endif
-
-            trk-&gt;extraDataLen=s-&gt;read16();
-            printf(&quot;Extension :%u bytes\n&quot;,trk-&gt;extraDataLen);
-            if(trk-&gt;extraDataLen)
-            {
-              trk-&gt;extraData=new uint8_t[trk-&gt;extraDataLen];
-              s-&gt;read(trk-&gt;extraData,trk-&gt;extraDataLen);
-            }
-              printf(&quot;#block in group   :%d\n&quot;,s-&gt;read8());
-              printf(&quot;#byte in group    :%d\n&quot;,s-&gt;read16());
-              printf(&quot;Align1            :%d\n&quot;,s-&gt;read16());
-              printf(&quot;Align2            :%d\n&quot;,s-&gt;read16());
-              _nbAudioTrack++;
-            
-          }
-          break;
-          default:break; 
-          
-        }
-      }
-      break;
-       default:
-         break;
-    }
-    s-&gt;skipChunk();
-    delete s;
-  }
-  printf(&quot;End of headers\n&quot;);
-  return 1;
-}
-/**
-    \fn loadVideo
-*/
-
-uint8_t asfHeader::loadVideo(asfChunk *s)
-{
-  uint32_t w,h,x;
-            w=s-&gt;read32();
-            h=s-&gt;read32();
-            s-&gt;read8();
-            x=s-&gt;read16();
-            _isvideopresent=1;
-
-            memset(&amp;_mainaviheader,0,sizeof(_mainaviheader));
-            _mainaviheader.dwWidth=w;
-            _mainaviheader.dwHeight=h;
-            _video_bih.biWidth=w;
-            _video_bih.biHeight=h;
-            printf(&quot;Pic Width  %04d\n&quot;,w);
-            printf(&quot;Pic Height %04d\n&quot;,h);
-            printf(&quot; BMP size  %04d (%04d)\n&quot;,x,(int)sizeof(ADM_BITMAPINFOHEADER));
-            s-&gt;read((uint8_t *)&amp;_video_bih,sizeof(ADM_BITMAPINFOHEADER));
-
-		#ifdef ADM_BIG_ENDIAN
-			Endian_BitMapInfo(&amp;_video_bih);
-		#endif
-
-            _videostream.dwScale=1000;
-            _videostream.dwRate=30000;
-
-            _videostream.fccHandler=_video_bih.biCompression;
-            printf(&quot;Codec : &lt;%s&gt; (%04x)\n&quot;,
-                    fourCC::tostring(_video_bih.biCompression),_video_bih.biCompression);
-            if(fourCC::check(_video_bih.biCompression,(uint8_t *)&quot;DVR &quot;))
-            {
-              // It is MS DVR, fail so that the mpeg2 indexer can take it from here
-              _videostream.fccHandler=_video_bih.biCompression=fourCC::get((uint8_t *)&quot;MPEG&quot;);
-              printf(&quot;This is MSDVR, not ASF\n&quot;);
-              return 0; 
-            }
-            printBih(&amp;_video_bih);
-            if(x&gt;sizeof(ADM_BITMAPINFOHEADER))
-            {
-              _videoExtraLen=x-sizeof(ADM_BITMAPINFOHEADER);
-              _videoExtraData=new uint8_t[_videoExtraLen];
-              s-&gt;read(_videoExtraData,_videoExtraLen);
-            }
-            return 1;
-}
-/**
-    \fn      buildIndex
-    \brief   Scan the file to build an index
-    
-    Header Chunk
-            Chunk
-            Chunk
-            Chunk
-            
-    Data chunk
-            Chunk
-            Chunk
-            
-    We skip the 1st one, and just read the header of the 2nd one
-    
-*/
-uint8_t asfHeader::buildIndex(void)
-{
-  uint32_t fSize;
-  const chunky *id;
-  uint32_t chunkFound;
-  uint32_t r=5;
-  uint32_t len;
-  
-  fseeko(_fd,0,SEEK_END);
-  fSize=ftello(_fd);
-  fseeko(_fd,0,SEEK_SET);
-  
-  asfChunk h(_fd);
-  printf(&quot;[ASF] ********** Building index **********\n&quot;);
-  printf(&quot;[ASF] Searching data\n&quot;);
-  while(r--)
-  {
-    h.nextChunk();    // Skip headers
-    id=h.chunkId();
-    h.dump();
-    if(id-&gt;id==ADM_CHUNK_DATA_CHUNK) break;
-    h.skipChunk();
-  }
-  if(id-&gt;id!=ADM_CHUNK_DATA_CHUNK) return 0;
-  // Remove leftover from DATA_chunk
- // Unknown	GUID	16
-//       Number of packets	UINT64	8
-//       Unknown	UINT8	1
-//       Unknown	UINT8	1
-//   
-  h.read32();
-  h.read32();
-  h.read32();
-  h.read32();
-  _nbPackets=(uint32_t) h.read64();
-  h.read16();
-  
-  len=h.chunkLen-16-8-2-24;
-  
-  printf(&quot;[ASF] nbPacket  : %u\n&quot;,_nbPackets);
-  printf(&quot;[ASF] len to go : %u\n&quot;,len);
-  printf(&quot;[ASF] scanning data\n&quot;);
-  _dataStartOffset=ftello(_fd);
-  
-  // Here we go
-  //DIA_working *working=new DIA_working(&quot;indexing asf&quot;);
-  asfPacket *aPacket=new asfPacket(_fd,_nbPackets,_packetSize,
-                                   &amp;readQueue,_dataStartOffset);
-  uint32_t packet=1;
-#define MAXIMAGE (_nbPackets)
-  uint32_t sequence=1;
-  uint32_t ceilImage=MAXIMAGE;
-
-  nbImage=0;
-  
-  len=0;
-  asfIndex indexEntry;
-  memset(&amp;indexEntry,0,sizeof(indexEntry));
-  bool first=true;
-  while(packet&lt;_nbPackets)
-  {
-    while(!readQueue.isEmpty())
-    {
-      asfBit *bit=NULL;
-      
-      ADM_assert(readQueue.pop((void**)&amp;bit));
-      uint64_t dts=bit-&gt;dts;
-      if(bit-&gt;stream==_videoStreamId)
-      {
-          aprintf(&quot;&gt;found packet of size %d seq %d, while curseq =%d\n&quot;,bit-&gt;len,bit-&gt;sequence,curSeq);
-          if(bit-&gt;sequence!=sequence || first==true)
-          {
-            if(first==false)
-            {
-                indexEntry.frameLen=len;
-                _index.push_back(indexEntry);
-            }
-            first=false;
-            aprintf(&quot;New sequence\n&quot;);
-            if( ((sequence+1)&amp;0xff)!=(bit-&gt;sequence&amp;0xff))
-            {
-                printf(&quot;!!!!!!!!!!!! non continuous sequence %u %u\n&quot;,sequence,bit-&gt;sequence); 
-    #if 0         
-                // Let's insert a couple of null frame
-                int32_t delta,start,end;
-                
-                start=256+bit-&gt;sequence-sequence-1;
-                start&amp;=0xff;
-                printf(&quot;!!!!!!!!!!!! Delta %d\n&quot;,start);
-                
-                for(int filler=0;filler&lt;start;filler++)
-                {
-                  tmpIndex[++nbImage].frameLen=0;
-                }
-    #endif            
-            }
-            
-            
-            indexEntry.frameLen=0;
-            indexEntry.segNb=bit-&gt;sequence;
-            indexEntry.packetNb=bit-&gt;packet;
-            indexEntry.flags=bit-&gt;flags;
-            indexEntry.dts=dts;
-            indexEntry.pts=ADM_NO_PTS;
-
-            for(int z=0;z&lt;_nbAudioTrack;z++)
-            {
-              indexEntry.audioSeen[z]=_allAudioTracks[z].length;
-              indexEntry.audioDts[z]=_allAudioTracks[z].lastDts;
-            }
-            readQueue.pushBack(bit);
-    
-            sequence=bit-&gt;sequence;
-            len=0;
-            continue;
-          }
-          len+=bit-&gt;len;
-      } // End of video stream Id
-      else  // Audio ?
-      {
-        int found=0;
-        for(int i=0;i&lt;_nbAudioTrack &amp;&amp; !found;i++)
-        {
-          if(bit-&gt;stream == _allAudioTracks[i].streamIndex)
-          {
-            
-            _allAudioTracks[i].length+=bit-&gt;len;
-            _allAudioTracks[i].lastDts=bit-&gt;dts;
-            
-            found=1;
-          }
-        }
-        if(!found) 
-        {
-          printf(&quot;Unmapped stream %u\n&quot;,bit-&gt;stream); 
-        }
-      }
-     delete[] bit-&gt;data;
-     delete bit;
-    }
-    //working-&gt;update(packet,_nbPackets);
-
-    packet++;
-    aPacket-&gt;nextPacket(0xff); // All packets
-    aPacket-&gt;skipPacket();
-  }
-  delete aPacket;
-  //delete working;
-  /* Compact index */
-  
-  fseeko(_fd,_dataStartOffset,SEEK_SET);
-  printf(&quot;[ASF] %u images found\n&quot;,nbImage);
-  printf(&quot;[ASF] ******** End of buildindex *******\n&quot;);
-
-  nbImage=_index.size();;
-
-  _videostream.dwLength=_mainaviheader.dwTotalFrames=nbImage;
-  if(!nbImage) return 0;
-  
-  // Update fps
-  // In fact it is an average fps
-  //
-  float f=_index[nbImage-1].dts;
-   f/=nbImage; // average duration of 1 image in us
-    if(f&lt;10) f=10;
-   f=1000000.*1000./f;
-  uint32_t avgFps=(uint32_t) f;
-    printf(&quot;[Asf] Average fps=%d\n&quot;,avgFps);
-  
-  _videostream.dwScale=1000;
-  _videostream.dwRate=(uint32_t)avgFps;;
-
-  return 1;
-  
-}
 //EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf.h	2009-08-21 15:32:55 UTC (rev 5258)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf.h	2009-08-21 15:32:56 UTC (rev 5259)
@@ -150,6 +150,7 @@
     uint8_t                 getHeaders( void);
     uint8_t                 buildIndex(void);
     uint8_t                 loadVideo(asfChunk *s);
+    bool                    loadAudio(asfChunk *s,uint32_t sid);
     
     ADM_queue               readQueue;
     uint32_t                curSeq;

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfAudio.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfAudio.cpp	2009-08-21 15:32:55 UTC (rev 5258)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfAudio.cpp	2009-08-21 15:32:56 UTC (rev 5259)
@@ -65,7 +65,6 @@
                           &amp;readQueue,_dataStart);
     
     printf(&quot;[asfAudio] Length %u\n&quot;,getLength());
-  
 }
 
 uint64_t  asfAudioAccess::getPos(void)
@@ -121,7 +120,7 @@
     {
         if(dts_us&gt;=(*idx)[i].audioDts[_myRank] &amp;&amp; dts_us&lt;(*idx)[i+1].audioDts[_myRank])
         {
-            return setPos( (*idx)[i].packetNb);
+            return _packet-&gt;goToPacket( (*idx)[i].packetNb);
         }
     }
     return false;
@@ -148,8 +147,8 @@
       // still same sequence ...add
       memcpy(dest,bit-&gt;data,bit-&gt;len);
       *len=bit-&gt;len;
-      *dts=bit-&gt;dts;
-	  delete[] bit-&gt;data;
+      *dts=ADM_NO_PTS;
+      delete[] bit-&gt;data;
       delete bit;
       return 1;
     }
@@ -160,7 +159,8 @@
       printf(&quot;[ASF] Audio Packet Error\n&quot;);
       return 0; 
     }
-    _packet-&gt;skipPacket();
+    
+   // _packet-&gt;skipPacket();
   }
   
   return 0; 

Copied: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfHeaders.cpp (from rev 5258, branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf.cpp	2009-08-21 15:32:55 UTC (rev 5258)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfHeaders.cpp	2009-08-21 15:32:56 UTC (rev 5259)
@@ -0,0 +1,489 @@
+/** *************************************************************************
+    \file ADM_asf.cpp
+    \brief ASF/WMV demuxer
+    copyright            : (C) 2006/2009 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include &quot;ADM_default.h&quot;
+#include &quot;ADM_Video.h&quot;
+#include &quot;ADM_assert.h&quot;
+
+#include &quot;fourcc.h&quot;
+#include &quot;DIA_coreToolkit.h&quot;
+#include &quot;ADM_asf.h&quot;
+#include &quot;ADM_asfPacket.h&quot;
+
+#if 0
+#define aprintf printf
+#else
+#define aprintf(...) {}
+#endif
+
+static const uint8_t asf_audio[16]={0x40,0x9e,0x69,0xf8,0x4d,0x5b,0xcf,0x11,0xa8,0xfd,0x00,0x80,0x5f,0x5c,0x44,0x2b};
+static const uint8_t asf_video[16]={0xc0,0xef,0x19,0xbc,0x4d,0x5b,0xcf,0x11,0xa8,0xfd,0x00,0x80,0x5f,0x5c,0x44,0x2b};
+
+/** *****************************************
+    \fn getHeaders
+    \brief Read Headers to collect information 
+********************************************/
+uint8_t asfHeader::getHeaders(void)
+{
+  uint32_t i=0,nbSubChunk,hi,lo;
+  const chunky *id;
+  uint8_t gid[16];
+  uint32_t mn=0,mx=0;
+  asfChunk chunk(_fd);
+  // The first header is header chunk
+  chunk.nextChunk();
+  id=chunk.chunkId();
+  if(id-&gt;id!=ADM_CHUNK_HEADER_CHUNK)
+  {
+    printf(&quot;[ASF] expected header chunk\n&quot;); 
+    return 0;
+  }
+  printf(&quot;[ASF] getting headers\n&quot;);
+  chunk.dump();
+  nbSubChunk=chunk.read32();
+  printf(&quot;NB subchunk :%u\n&quot;,nbSubChunk);
+  chunk.read8();
+  chunk.read8();
+  for(i=0;i&lt;nbSubChunk;i++)
+  {
+    asfChunk *s=new asfChunk(_fd);
+    uint32_t skip;
+    s-&gt;nextChunk();
+    printf(&quot;***************\n&quot;);  
+    id=s-&gt;chunkId();
+    s-&gt;dump();
+    switch(id-&gt;id)
+    {
+#if 0      
+      case ADM_CHUNK_HEADER_EXTENSION_CHUNK:
+      {
+        s-&gt;skip(16); // Clock type extension ????
+        printf(&quot;?? %d\n&quot;,s-&gt;read16());
+        printf(&quot;?? %d\n&quot;,s-&gt;read32());
+          
+        uint32_t streamNameCount;
+        uint32_t payloadCount;
+          
+          asfChunk *u=new asfChunk(_fd);
+          for(int zzz=0;zzz&lt;8;zzz++)
+          {
+              u-&gt;nextChunk();
+              u-&gt;dump();
+              id=u-&gt;chunkId();
+              if(id-&gt;id==ADM_CHUNK_EXTENDED_STREAM_PROP)
+              {
+                  s-&gt;skip(8); // start time 
+                  s-&gt;skip(8); // end time
+                  printf(&quot;Bitrate         %u :\n&quot;,u-&gt;read32());
+                  printf(&quot;Buffer Size     %u :\n&quot;,u-&gt;read32());
+                  printf(&quot;BFill           %u :\n&quot;,u-&gt;read32());
+                  printf(&quot;Alt Bitrate     %u :\n&quot;,u-&gt;read32());
+                  printf(&quot;Alt Bsize       %u :\n&quot;,u-&gt;read32());
+                  printf(&quot;Alt Bfullness   %u :\n&quot;,u-&gt;read32());
+                  printf(&quot;Max object Size %u :\n&quot;,u-&gt;read32());
+                  printf(&quot;Flags           0x%x :\n&quot;,u-&gt;read32());
+                  printf(&quot;Stream no       %u :\n&quot;,u-&gt;read16());
+                  printf(&quot;Stream lang     %u :\n&quot;,u-&gt;read16());
+                  printf(&quot;Stream time/fra %lu :\n&quot;,u-&gt;read64());
+                  streamNameCount=u-&gt;read16();
+                  payloadCount=u-&gt;read16();
+                  printf(&quot;Stream Nm Count %u :\n&quot;,streamNameCount);
+                  printf(&quot;Payload count   %u :\n&quot;,payloadCount);
+                  for(int stream=0;stream&lt;streamNameCount;stream++)
+                  {
+                    u-&gt;read16();
+                    skip=u-&gt;read16();
+                    u-&gt;skip(skip);
+                  }
+                  uint32_t size;
+                  for(int payload=0;payload&lt;payloadCount;payload++)
+                  {
+                    for(int pp=0;pp&lt;16;pp++) printf(&quot;0x%02x,&quot;,u-&gt;read8());
+                    printf(&quot;\n&quot;);
+                    skip=u-&gt;read16();
+                    size=u-&gt;read32();
+                    u-&gt;skip(size);
+                    printf(&quot;Extra Data : %d, skipd %d\n&quot;,size,skip);
+                  }
+                  printf(&quot;We are at %x\n&quot;,ftello(_fd));
+                }
+                u-&gt;skipChunk();
+          }
+          delete u;
+      }
+      break;
+#endif      
+      case ADM_CHUNK_FILE_HEADER_CHUNK:
+        {
+            // Client GID
+            printf(&quot;Client        :&quot;);
+            for(int z=0;z&lt;16;z++) printf(&quot;:%02x&quot;,s-&gt;read8());
+            printf(&quot;\n&quot;);
+            printf(&quot;File size     : %08lx\n&quot;,s-&gt;read64());
+            printf(&quot;Creation time : %08lx\n&quot;,s-&gt;read64());
+            printf(&quot;Number of pack: %08lx\n&quot;,s-&gt;read64());
+            printf(&quot;Timestamp 1   : %08lx\n&quot;,s-&gt;read64());
+            _duration=s-&gt;read64();
+            printf(&quot;Timestamp 2   : %08lx\n&quot;,_duration);
+            printf(&quot;Timestamp 3   : %04x\n&quot;,s-&gt;read32());
+            printf(&quot;Preload       : %04x\n&quot;,s-&gt;read32());
+            printf(&quot;Flags         : %04x\n&quot;,s-&gt;read32());
+            mx=s-&gt;read32();
+            mn=s-&gt;read32();
+            if(mx!=mn)
+            {
+              printf(&quot;Variable packet size!!\n&quot;);
+              delete s;
+              return 0; 
+            }
+            _packetSize=mx;
+            printf(&quot;Min size      : %04x\n&quot;,mx);
+            printf(&quot;Max size      : %04x\n&quot;,mn);
+            printf(&quot;Uncompres.size: %04x\n&quot;,s-&gt;read32());
+          }
+          break;
+      case ADM_CHUNK_STREAM_HEADER_CHUNK:
+      {
+         // Client GID
+        uint32_t audiovideo=0; // video=1, audio=2, 0=unknown
+        uint32_t sid;
+        s-&gt;read(gid,16);
+        printf(&quot;Type            :&quot;);
+        for(int z=0;z&lt;16;z++) printf(&quot;0x%02x,&quot;,gid[z]);
+        if(!memcmp(gid,asf_video,16))
+        {
+          printf(&quot;(video)&quot;);
+          audiovideo=1;
+        } else
+        {
+          if(!memcmp(gid,asf_audio,16))
+          {
+            printf(&quot;(audio)&quot;); 
+            audiovideo=2;
+          } else printf(&quot;(? ? ? ?)&quot;); 
+        }
+        printf(&quot;\nConceal       :&quot;);
+        for(int z=0;z&lt;16;z++) printf(&quot;:%02x&quot;,s-&gt;read8());
+        printf(&quot;\n&quot;);
+        printf(&quot;Reserved    : %08&quot;LLX&quot;\n&quot;,s-&gt;read64());
+        printf(&quot;Total Size  : %04&quot;LX&quot;\n&quot;,s-&gt;read32());
+        printf(&quot;Size        : %04&quot;LX&quot;\n&quot;,s-&gt;read32());
+        sid=s-&gt;read16();
+        printf(&quot;Stream nb   : %04d\n&quot;,sid);
+        printf(&quot;Reserved    : %04&quot;LX&quot;\n&quot;,s-&gt;read32());
+        switch(audiovideo)
+        {
+          case 1: // Video
+          {
+                    _videoStreamId=sid;
+                    if(!loadVideo(s))
+                    {
+                      delete s;
+                      return 0; 
+                    }
+                    break;
+          }
+              break;
+          case 2: // audio
+          {
+            loadAudio(s,sid);
+          
+            
+          }
+          break;
+          default:break; 
+          
+        }
+      }
+      break;
+       default:
+         break;
+    }
+    s-&gt;skipChunk();
+    delete s;
+  }
+  printf(&quot;End of headers\n&quot;);
+  return 1;
+}
+/**
+    \fn loadAudio
+*/
+
+bool asfHeader::loadAudio(asfChunk *s,uint32_t sid)
+{
+  asfAudioTrak *trk=&amp;(_allAudioTracks[_nbAudioTrack]);
+    ADM_assert(_nbAudioTrack&lt;ASF_MAX_AUDIO_TRACK);
+    trk-&gt;streamIndex=sid;
+    s-&gt;read((uint8_t *)&amp;(trk-&gt;wavHeader),sizeof(WAVHeader));
+    printf(&quot;[Asf] Encoding for audio 0x%x\n&quot;,trk-&gt;wavHeader.encoding);
+#ifdef ADM_BIG_ENDIAN
+    Endian_WavHeader(&amp;(trk-&gt;wavHeader));
+#endif
+
+    trk-&gt;extraDataLen=s-&gt;read16();
+    printf(&quot;Extension :%u bytes\n&quot;,trk-&gt;extraDataLen);
+    if(trk-&gt;extraDataLen)
+    {
+      trk-&gt;extraData=new uint8_t[trk-&gt;extraDataLen];
+      s-&gt;read(trk-&gt;extraData,trk-&gt;extraDataLen);
+    }
+      printf(&quot;#block in group   :%d\n&quot;,s-&gt;read8());
+      printf(&quot;#byte in group    :%d\n&quot;,s-&gt;read16());
+      printf(&quot;Align1            :%d\n&quot;,s-&gt;read16());
+      printf(&quot;Align2            :%d\n&quot;,s-&gt;read16());
+      _nbAudioTrack++;
+    return true;
+}
+/**
+    \fn loadVideo
+*/
+
+uint8_t asfHeader::loadVideo(asfChunk *s)
+{
+  uint32_t w,h,x;
+            w=s-&gt;read32();
+            h=s-&gt;read32();
+            s-&gt;read8();
+            x=s-&gt;read16();
+            _isvideopresent=1;
+
+            memset(&amp;_mainaviheader,0,sizeof(_mainaviheader));
+            _mainaviheader.dwWidth=w;
+            _mainaviheader.dwHeight=h;
+            _video_bih.biWidth=w;
+            _video_bih.biHeight=h;
+            printf(&quot;Pic Width  %04d\n&quot;,w);
+            printf(&quot;Pic Height %04d\n&quot;,h);
+            printf(&quot; BMP size  %04d (%04d)\n&quot;,x,(int)sizeof(ADM_BITMAPINFOHEADER));
+            s-&gt;read((uint8_t *)&amp;_video_bih,sizeof(ADM_BITMAPINFOHEADER));
+
+		#ifdef ADM_BIG_ENDIAN
+			Endian_BitMapInfo(&amp;_video_bih);
+		#endif
+
+            _videostream.dwScale=1000;
+            _videostream.dwRate=30000;
+
+            _videostream.fccHandler=_video_bih.biCompression;
+            printf(&quot;Codec : &lt;%s&gt; (%04x)\n&quot;,
+                    fourCC::tostring(_video_bih.biCompression),_video_bih.biCompression);
+            if(fourCC::check(_video_bih.biCompression,(uint8_t *)&quot;DVR &quot;))
+            {
+              // It is MS DVR, fail so that the mpeg2 indexer can take it from here
+              _videostream.fccHandler=_video_bih.biCompression=fourCC::get((uint8_t *)&quot;MPEG&quot;);
+              printf(&quot;This is MSDVR, not ASF\n&quot;);
+              return 0; 
+            }
+            printBih(&amp;_video_bih);
+            if(x&gt;sizeof(ADM_BITMAPINFOHEADER))
+            {
+              _videoExtraLen=x-sizeof(ADM_BITMAPINFOHEADER);
+              _videoExtraData=new uint8_t[_videoExtraLen];
+              s-&gt;read(_videoExtraData,_videoExtraLen);
+            }
+            return 1;
+}
+/**
+    \fn      buildIndex
+    \brief   Scan the file to build an index
+    
+    Header Chunk
+            Chunk
+            Chunk
+            Chunk
+            
+    Data chunk
+            Chunk
+            Chunk
+            
+    We skip the 1st one, and just read the header of the 2nd one
+    
+*/
+uint8_t asfHeader::buildIndex(void)
+{
+  uint32_t fSize;
+  const chunky *id;
+  uint32_t chunkFound;
+  uint32_t r=5;
+  uint32_t len;
+  
+  fseeko(_fd,0,SEEK_END);
+  fSize=ftello(_fd);
+  fseeko(_fd,0,SEEK_SET);
+  
+  asfChunk h(_fd);
+  printf(&quot;[ASF] ********** Building index **********\n&quot;);
+  printf(&quot;[ASF] Searching data\n&quot;);
+  while(r--)
+  {
+    h.nextChunk();    // Skip headers
+    id=h.chunkId();
+    h.dump();
+    if(id-&gt;id==ADM_CHUNK_DATA_CHUNK) break;
+    h.skipChunk();
+  }
+  if(id-&gt;id!=ADM_CHUNK_DATA_CHUNK) return 0;
+  // Remove leftover from DATA_chunk
+ // Unknown	GUID	16
+//       Number of packets	UINT64	8
+//       Unknown	UINT8	1
+//       Unknown	UINT8	1
+//   
+  h.read32();
+  h.read32();
+  h.read32();
+  h.read32();
+  _nbPackets=(uint32_t) h.read64();
+  h.read16();
+  
+  len=h.chunkLen-16-8-2-24;
+  
+  printf(&quot;[ASF] nbPacket  : %u\n&quot;,_nbPackets);
+  printf(&quot;[ASF] len to go : %u\n&quot;,len);
+  printf(&quot;[ASF] scanning data\n&quot;);
+  _dataStartOffset=ftello(_fd);
+  
+  // Here we go
+  //DIA_working *working=new DIA_working(&quot;indexing asf&quot;);
+  asfPacket *aPacket=new asfPacket(_fd,_nbPackets,_packetSize,
+                                   &amp;readQueue,_dataStartOffset);
+  uint32_t packet=1;
+#define MAXIMAGE (_nbPackets)
+  uint32_t sequence=1;
+  uint32_t ceilImage=MAXIMAGE;
+
+  nbImage=0;
+  
+  len=0;
+  asfIndex indexEntry;
+  memset(&amp;indexEntry,0,sizeof(indexEntry));
+  bool first=true;
+  while(packet&lt;_nbPackets)
+  {
+    while(!readQueue.isEmpty())
+    {
+      asfBit *bit=NULL;
+      
+      ADM_assert(readQueue.pop((void**)&amp;bit));
+      uint64_t dts=bit-&gt;dts;
+      if(bit-&gt;stream==_videoStreamId)
+      {
+          aprintf(&quot;&gt;found packet of size %d seq %d, while curseq =%d\n&quot;,bit-&gt;len,bit-&gt;sequence,curSeq);
+          if(bit-&gt;sequence!=sequence || first==true)
+          {
+            if(first==false)
+            {
+                indexEntry.frameLen=len;
+                _index.push_back(indexEntry);
+            }
+            first=false;
+            aprintf(&quot;New sequence\n&quot;);
+            if( ((sequence+1)&amp;0xff)!=(bit-&gt;sequence&amp;0xff))
+            {
+                printf(&quot;!!!!!!!!!!!! non continuous sequence %u %u\n&quot;,sequence,bit-&gt;sequence); 
+    #if 0         
+                // Let's insert a couple of null frame
+                int32_t delta,start,end;
+                
+                start=256+bit-&gt;sequence-sequence-1;
+                start&amp;=0xff;
+                printf(&quot;!!!!!!!!!!!! Delta %d\n&quot;,start);
+                
+                for(int filler=0;filler&lt;start;filler++)
+                {
+                  tmpIndex[++nbImage].frameLen=0;
+                }
+    #endif            
+            }
+            
+            
+            indexEntry.frameLen=0;
+            indexEntry.segNb=bit-&gt;sequence;
+            indexEntry.packetNb=bit-&gt;packet;
+            indexEntry.flags=bit-&gt;flags;
+            indexEntry.dts=dts;
+            indexEntry.pts=ADM_NO_PTS;
+
+            for(int z=0;z&lt;_nbAudioTrack;z++)
+            {
+              indexEntry.audioSeen[z]=_allAudioTracks[z].length;
+              indexEntry.audioDts[z]=_allAudioTracks[z].lastDts;
+            }
+            readQueue.pushBack(bit);
+    
+            sequence=bit-&gt;sequence;
+            len=0;
+            continue;
+          }
+          len+=bit-&gt;len;
+      } // End of video stream Id
+      else  // Audio ?
+      {
+        int found=0;
+        for(int i=0;i&lt;_nbAudioTrack &amp;&amp; !found;i++)
+        {
+          if(bit-&gt;stream == _allAudioTracks[i].streamIndex)
+          {
+            
+            _allAudioTracks[i].length+=bit-&gt;len;
+            _allAudioTracks[i].lastDts=bit-&gt;dts;
+            
+            found=1;
+          }
+        }
+        if(!found) 
+        {
+          printf(&quot;Unmapped stream %u\n&quot;,bit-&gt;stream); 
+        }
+      }
+     delete[] bit-&gt;data;
+     delete bit;
+    }
+    //working-&gt;update(packet,_nbPackets);
+
+    packet++;
+    aPacket-&gt;nextPacket(0xff); // All packets
+    aPacket-&gt;skipPacket();
+  }
+  delete aPacket;
+  //delete working;
+  /* Compact index */
+  
+  fseeko(_fd,_dataStartOffset,SEEK_SET);
+  printf(&quot;[ASF] %u images found\n&quot;,nbImage);
+  printf(&quot;[ASF] ******** End of buildindex *******\n&quot;);
+
+  nbImage=_index.size();;
+
+  _videostream.dwLength=_mainaviheader.dwTotalFrames=nbImage;
+  if(!nbImage) return 0;
+  
+  // Update fps
+  // In fact it is an average fps
+  //
+  float f=_index[nbImage-1].dts;
+   f/=nbImage; // average duration of 1 image in us
+    if(f&lt;10) f=10;
+   f=1000000.*1000./f;
+  uint32_t avgFps=(uint32_t) f;
+    printf(&quot;[Asf] Average fps=%d\n&quot;,avgFps);
+  
+  _videostream.dwScale=1000;
+  _videostream.dwRate=(uint32_t)avgFps;;
+
+  return 1;
+  
+}
\ No newline at end of file

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfPacket.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfPacket.cpp	2009-08-21 15:32:55 UTC (rev 5258)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfPacket.cpp	2009-08-21 15:32:56 UTC (rev 5259)
@@ -67,6 +67,7 @@
    uint32_t offset=_startDataOffset+packet*pakSize;
    fseeko(_fd,offset,SEEK_SET);
    currentPacket=packet;
+   purge();
    return 1;
  }
  /*

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/CMakeLists.txt	2009-08-21 15:32:55 UTC (rev 5258)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/CMakeLists.txt	2009-08-21 15:32:56 UTC (rev 5259)
@@ -5,6 +5,7 @@
         ADM_asf.cpp  
         ADM_asfPacket.cpp
         ADM_asfPlugin.cpp
+        ADM_asfHeaders.cpp
 )
 
 ADD_LIBRARY(ADM_dm_asf SHARED ${ADM_asf_SRCS})


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002471.html">[Avidemux-svn-commit] r5258 -	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs
</A></li>
	<LI>Next message: <A HREF="002473.html">[Avidemux-svn-commit] r5260 -	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Flv
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2472">[ date ]</a>
              <a href="thread.html#2472">[ thread ]</a>
              <a href="subject.html#2472">[ subject ]</a>
              <a href="author.html#2472">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
