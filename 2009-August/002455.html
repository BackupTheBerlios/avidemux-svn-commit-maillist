<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r5242 - in	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers:	. Asf
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2009-August/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r5242%20-%20in%0A%09branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers%3A%0A%09.%20Asf&In-Reply-To=%3C200908141729.n7EHTJHm032641%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002454.html">
   <LINK REL="Next"  HREF="002456.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r5242 - in	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers:	. Asf</H1>
    <B>mean at BerliOS</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r5242%20-%20in%0A%09branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers%3A%0A%09.%20Asf&In-Reply-To=%3C200908141729.n7EHTJHm032641%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r5242 - in	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers:	. Asf">mean at mail.berlios.de
       </A><BR>
    <I>Fri Aug 14 19:29:19 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="002454.html">[Avidemux-svn-commit] r5241 - in	branches/avidemux_2.5_branch_gruntster:	avidemux/ADM_audiocodec plugins/ADM_audioDecoders/ADM_ad_ac3	plugins/ADM_audioDecoders/ADM_ad_faad	plugins/ADM_audioDecoders/ADM_ad_mad	plugins/ADM_audioDecoders/ADM_ad_opencore_amrnb	plugins/ADM_audioDecoders/ADM_ad_opencore_amrwb	plugins/ADM_audioDecoders/ADM_ad_vorbis
</A></li>
        <LI>Next message: <A HREF="002456.html">[Avidemux-svn-commit] r5243 -	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreDemuxerMpeg/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2455">[ date ]</a>
              <a href="thread.html#2455">[ thread ]</a>
              <a href="subject.html#2455">[ subject ]</a>
              <a href="author.html#2455">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2009-08-14 19:29:18 +0200 (Fri, 14 Aug 2009)
New Revision: 5242

Added:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfChunk.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfIo.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfPacket.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfPacket.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf_audio.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/CMakeLists.txt
Log:
[Demuxer] Raw import of asf demuxer from 2.5

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf.cpp	2009-08-12 18:12:50 UTC (rev 5241)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf.cpp	2009-08-14 17:29:18 UTC (rev 5242)
@@ -0,0 +1,777 @@
+/***************************************************************************
+    copyright            : (C) 2006 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &quot;config.h&quot;
+
+#include &lt;math.h&gt;
+
+#include &quot;ADM_default.h&quot;
+#include &quot;ADM_editor/ADM_Video.h&quot;
+#include &quot;ADM_assert.h&quot;
+
+#include &quot;fourcc.h&quot;
+#include &quot;DIA_coreToolkit.h&quot;
+//#include &quot;DIA_working.h&quot;
+#include &quot;ADM_asf.h&quot;
+#include &quot;ADM_asfPacket.h&quot;
+
+#include &quot;ADM_osSupport/ADM_debugID.h&quot;
+#define MODULE_NAME MODULE_ASF
+#include &quot;ADM_osSupport/ADM_debug.h&quot;
+
+static const uint8_t asf_audio[16]={0x40,0x9e,0x69,0xf8,0x4d,0x5b,0xcf,0x11,0xa8,0xfd,0x00,0x80,0x5f,0x5c,0x44,0x2b};
+static const uint8_t asf_video[16]={0xc0,0xef,0x19,0xbc,0x4d,0x5b,0xcf,0x11,0xa8,0xfd,0x00,0x80,0x5f,0x5c,0x44,0x2b};
+
+
+WAVHeader *asfHeader::getAudioInfo(void )
+{
+  if(!_curAudio) return NULL;
+  return _curAudio-&gt;getInfo();
+}
+/*
+    __________________________________________________________
+*/
+
+uint8_t asfHeader::getAudioStream(AVDMGenericAudioStream **audio)
+{
+ 
+  *audio=_curAudio;
+  return 1; 
+}
+/*
+    __________________________________________________________
+*/
+
+void asfHeader::Dump(void)
+{
+ 
+  printf(&quot;*********** ASF INFO***********\n&quot;);
+}
+/*
+    __________________________________________________________
+*/
+
+uint8_t asfHeader::close(void)
+{
+	if (_fd) 
+		fclose(_fd);
+
+	_fd=NULL;
+
+  if(_videoExtraData)
+  {
+    delete [] _videoExtraData;
+    _videoExtraData=NULL; 
+  }
+  if(myName)
+  {
+    delete myName;
+    myName=NULL; 
+  }
+  if(_extraData)
+  {
+    delete [] _extraData;
+    _extraData=NULL; 
+  }
+  if(_index)
+  {
+    delete [] _index; 
+  }
+  _index=NULL;
+  if(_packet)
+    delete _packet;
+  _packet=NULL;
+  
+  for(int i=0;i&lt;_nbAudioTrack;i++)
+  {
+    asfAudioTrak *trk=&amp;(_allAudioTracks[i]);
+    if(trk-&gt;extraData) delete [] trk-&gt;extraData;
+    trk-&gt;extraData=NULL;
+  }
+}
+uint8_t       asfHeader::getExtraHeaderData(uint32_t *len, uint8_t **data)
+{
+  *len=_extraDataLen;
+  *data=_extraData;
+  return 1; 
+}
+/*
+    __________________________________________________________
+*/
+
+ asfHeader::asfHeader( void ) : vidHeader()
+{
+  _fd=NULL;
+  _videoIndex=-1;
+  myName=NULL;
+  _extraDataLen=0;
+  _extraData=NULL;
+  _packetSize=0;
+  _videoStreamId=0;
+  nbImage=0;
+  _index=NULL;
+  _packet=NULL;
+  _curAudio=NULL;
+  _nbPackets=0;
+  printf(&quot;%u\n&quot;,sizeof(_allAudioTracks));
+  memset(&amp;(_allAudioTracks[0]),0,sizeof(_allAudioTracks));
+
+  _nbAudioTrack=0;
+  _currentAudioStream=0;
+}
+/*
+    __________________________________________________________
+*/
+
+ asfHeader::~asfHeader(  )
+{
+  close();
+}
+/*
+    __________________________________________________________
+*/
+
+uint8_t asfHeader::open(const char *name)
+{
+  _fd=fopen(name,&quot;rb&quot;);
+  if(!_fd)
+  {
+    GUI_Error_HIG(&quot;File Error.&quot;,&quot;Cannot open file\n&quot;);
+    return 0; 
+  }
+  myName=ADM_strdup(name);
+  if(!getHeaders())
+  {
+    return 0; 
+  }
+  buildIndex();
+  fseeko(_fd,_dataStartOffset,SEEK_SET);
+  _packet=new asfPacket(_fd,_nbPackets,_packetSize,&amp;readQueue,_dataStartOffset);
+  curSeq=1;
+  if(_nbAudioTrack)
+  {
+    _curAudio=new asfAudio(this,_currentAudioStream);
+  }
+  return 1;
+}
+/*
+    __________________________________________________________
+*/
+
+ 
+/*
+    __________________________________________________________
+*/
+
+  uint8_t  asfHeader::setFlag(uint32_t frame,uint32_t flags)
+{
+  ADM_assert(frame&lt;nbImage);
+  _index[frame].flags=flags;
+  return 1; 
+}
+/*
+    __________________________________________________________
+*/
+
+uint32_t asfHeader::getFlags(uint32_t frame,uint32_t *flags)
+{
+  if(frame&gt;=nbImage) return 0;
+  if(!frame) *flags=AVI_KEY_FRAME;
+  else 
+      *flags=_index[frame].flags;
+  return 1; 
+}
+/*
+    __________________________________________________________
+*/
+
+uint8_t  asfHeader::getFrameNoAlloc(uint32_t framenum,ADMCompressedImage *img)
+{
+  img-&gt;dataLength=0;
+  img-&gt;flags=AVI_KEY_FRAME;
+  if(framenum&gt;=nbImage)
+  {
+    printf(&quot;[ASF] Going out of bound %u %u\n&quot;,framenum, nbImage);
+    return 0;
+  }
+  if(!_index[framenum].frameLen)
+  {
+    return 1; // Empty frame 
+  }
+  // In case curSeq is stored as one byte..
+  curSeq&amp;=0xff;
+  //
+  uint32_t len=0;
+  aprintf(&quot;Framenum %u len: %u curSeq %u frameSeq=%u packetnb=%u \n&quot;,
+         framenum,_index[framenum].frameLen,curSeq,
+         _index[framenum].segNb,_index[framenum].packetNb);
+  // Seeking ?
+  if(_index[framenum].segNb!=curSeq)
+  {
+    printf(&quot;Seeking.. curseq:%u wanted seq:%u\n&quot;,curSeq,_index[framenum].segNb);
+    if(!_packet-&gt;goToPacket(_index[framenum].packetNb))
+    {
+      printf(&quot;[ASF] Cannot seek to frame %u\n&quot;,framenum);
+      return 0; 
+    }
+    _packet-&gt;purge();
+    curSeq=_index[framenum].segNb;
+    printf(&quot;Seeking starting at seq=%u\n&quot;,curSeq);
+  }
+  
+  
+  len=0;
+  uint32_t delta;
+  while(1)
+  {
+   
+    
+    
+    while(!readQueue.isEmpty())
+    {
+      asfBit *bit;
+      ADM_assert(readQueue.pop((void**)&amp;bit));
+      aprintf(&quot;&gt;found packet of size %d seq %d, while curseq =%d wanted seg=%u current offset=%u\n&quot;,bit-&gt;len,bit-&gt;sequence,curSeq,_index[framenum].segNb,len);
+      // Here it is tricky
+      // if len==0 we are reading the first part of our frame
+      // The packet may starts with segments from the previous frame
+      // discard them
+      // Delta is just a security as it should be slightly &gt;10
+      delta=256+bit-&gt;sequence-_index[framenum].segNb;
+      delta &amp;=0xff;
+      if(!len) // Starting a new frame
+      {
+          if(_index[framenum].segNb != bit-&gt;sequence )
+          {
+            aprintf(&quot;Dropping seq=%u too old for %u delta %d\n&quot;,
+                  bit-&gt;sequence,_index[framenum].segNb,delta);
+            delete[] bit-&gt;data;
+            delete bit;
+            if(delta&lt;230)
+            {
+              printf(&quot;Very suspicious\n&quot;);
+              printf(&quot;Very suspicious\n&quot;);
+              printf(&quot;Very suspicious\n&quot;);
+              printf(&quot;Very suspicious\n&quot;);
+              printf(&quot;Very suspicious\n&quot;);
+            }
+            continue; 
+          }
+          // We have found our first chunk
+          curSeq=bit-&gt;sequence;
+          memcpy(img-&gt;data,bit-&gt;data,bit-&gt;len);
+          len=bit-&gt;len;
+          delete[] bit-&gt;data;
+          delete bit;
+          continue;
+      }
+      // Continuing a frame
+      // If the seq number is different it is the beginning of a new frame
+      if(bit-&gt;sequence!=curSeq )
+      {
+        aprintf(&quot;New sequence %u-&gt;%u while loading %u frame\n&quot;,curSeq,bit-&gt;sequence,framenum);
+        img-&gt;dataLength=len;
+        readQueue.pushBack(bit); // don't delete it, we will use it later...
+        curSeq=bit-&gt;sequence;
+        goto gotcha;
+      }
+      // still same sequence ...add
+      memcpy(img-&gt;data+len,bit-&gt;data,bit-&gt;len);
+      len+=bit-&gt;len;
+	  delete[] bit-&gt;data;
+      delete bit;
+    }
+    if(!_packet-&gt;nextPacket(_videoStreamId))
+    {
+      printf(&quot;[ASF] Packet Error\n&quot;);
+      return 0; 
+    }
+    _packet-&gt;skipPacket();
+  }
+gotcha:
+  
+  img-&gt;dataLength=len;
+  if(len!=_index[framenum].frameLen)
+  {
+    printf(&quot;[ASF] Frame=%u :-&gt; Mismatch found len : %u expected %u\n&quot;,framenum,len, _index[framenum].frameLen);
+  }
+  aprintf(&quot;&gt;&gt;Len %d seq %d\n&quot;,len,curSeq);
+  return 1; 
+}
+/*
+    __________________________________________________________
+*/
+
+/*******************************************
+  Read Headers to collect information 
+********************************************/
+uint8_t asfHeader::getHeaders(void)
+{
+  uint32_t i=0,nbSubChunk,hi,lo;
+  const chunky *id;
+  uint8_t gid[16];
+  uint32_t mn=0,mx=0;
+  asfChunk chunk(_fd);
+  // The first header is header chunk
+  chunk.nextChunk();
+  id=chunk.chunkId();
+  if(id-&gt;id!=ADM_CHUNK_HEADER_CHUNK)
+  {
+    printf(&quot;[ASF] expected header chunk\n&quot;); 
+    return 0;
+  }
+  printf(&quot;[ASF] getting headers\n&quot;);
+  chunk.dump();
+  nbSubChunk=chunk.read32();
+  printf(&quot;NB subchunk :%u\n&quot;,nbSubChunk);
+  chunk.read8();
+  chunk.read8();
+  for(i=0;i&lt;nbSubChunk;i++)
+  {
+    asfChunk *s=new asfChunk(_fd);
+    uint32_t skip;
+    s-&gt;nextChunk();
+    printf(&quot;***************\n&quot;);  
+    id=s-&gt;chunkId();
+    s-&gt;dump();
+    switch(id-&gt;id)
+    {
+#if 0      
+      case ADM_CHUNK_HEADER_EXTENSION_CHUNK:
+      {
+        s-&gt;skip(16); // Clock type extension ????
+        printf(&quot;?? %d\n&quot;,s-&gt;read16());
+        printf(&quot;?? %d\n&quot;,s-&gt;read32());
+          
+        uint32_t streamNameCount;
+        uint32_t payloadCount;
+          
+          asfChunk *u=new asfChunk(_fd);
+          for(int zzz=0;zzz&lt;8;zzz++)
+          {
+              u-&gt;nextChunk();
+              u-&gt;dump();
+              id=u-&gt;chunkId();
+              if(id-&gt;id==ADM_CHUNK_EXTENDED_STREAM_PROP)
+              {
+                  s-&gt;skip(8); // start time 
+                  s-&gt;skip(8); // end time
+                  printf(&quot;Bitrate         %u :\n&quot;,u-&gt;read32());
+                  printf(&quot;Buffer Size     %u :\n&quot;,u-&gt;read32());
+                  printf(&quot;BFill           %u :\n&quot;,u-&gt;read32());
+                  printf(&quot;Alt Bitrate     %u :\n&quot;,u-&gt;read32());
+                  printf(&quot;Alt Bsize       %u :\n&quot;,u-&gt;read32());
+                  printf(&quot;Alt Bfullness   %u :\n&quot;,u-&gt;read32());
+                  printf(&quot;Max object Size %u :\n&quot;,u-&gt;read32());
+                  printf(&quot;Flags           0x%x :\n&quot;,u-&gt;read32());
+                  printf(&quot;Stream no       %u :\n&quot;,u-&gt;read16());
+                  printf(&quot;Stream lang     %u :\n&quot;,u-&gt;read16());
+                  printf(&quot;Stream time/fra %lu :\n&quot;,u-&gt;read64());
+                  streamNameCount=u-&gt;read16();
+                  payloadCount=u-&gt;read16();
+                  printf(&quot;Stream Nm Count %u :\n&quot;,streamNameCount);
+                  printf(&quot;Payload count   %u :\n&quot;,payloadCount);
+                  for(int stream=0;stream&lt;streamNameCount;stream++)
+                  {
+                    u-&gt;read16();
+                    skip=u-&gt;read16();
+                    u-&gt;skip(skip);
+                  }
+                  uint32_t size;
+                  for(int payload=0;payload&lt;payloadCount;payload++)
+                  {
+                    for(int pp=0;pp&lt;16;pp++) printf(&quot;0x%02x,&quot;,u-&gt;read8());
+                    printf(&quot;\n&quot;);
+                    skip=u-&gt;read16();
+                    size=u-&gt;read32();
+                    u-&gt;skip(size);
+                    printf(&quot;Extra Data : %d, skipd %d\n&quot;,size,skip);
+                  }
+                  printf(&quot;We are at %x\n&quot;,ftello(_fd));
+                }
+                u-&gt;skipChunk();
+          }
+          delete u;
+      }
+      break;
+#endif      
+      case ADM_CHUNK_FILE_HEADER_CHUNK:
+        {
+            // Client GID
+            printf(&quot;Client        :&quot;);
+            for(int z=0;z&lt;16;z++) printf(&quot;:%02x&quot;,s-&gt;read8());
+            printf(&quot;\n&quot;);
+            printf(&quot;File size     : %08lx\n&quot;,s-&gt;read64());
+            printf(&quot;Creation time : %08lx\n&quot;,s-&gt;read64());
+            printf(&quot;Number of pack: %08lx\n&quot;,s-&gt;read64());
+            printf(&quot;Timestamp 1   : %08lx\n&quot;,s-&gt;read64());
+            _duration=s-&gt;read64();
+            printf(&quot;Timestamp 2   : %08lx\n&quot;,_duration);
+            printf(&quot;Timestamp 3   : %04x\n&quot;,s-&gt;read32());
+            printf(&quot;Preload       : %04x\n&quot;,s-&gt;read32());
+            printf(&quot;Flags         : %04x\n&quot;,s-&gt;read32());
+            mx=s-&gt;read32();
+            mn=s-&gt;read32();
+            if(mx!=mn)
+            {
+              printf(&quot;Variable packet size!!\n&quot;);
+              delete s;
+              return 0; 
+            }
+            _packetSize=mx;
+            printf(&quot;Min size      : %04x\n&quot;,mx);
+            printf(&quot;Max size      : %04x\n&quot;,mn);
+            printf(&quot;Uncompres.size: %04x\n&quot;,s-&gt;read32());
+          }
+          break;
+      case ADM_CHUNK_STREAM_HEADER_CHUNK:
+      {
+         // Client GID
+        uint32_t audiovideo=0; // video=1, audio=2, 0=unknown
+        uint32_t sid;
+        s-&gt;read(gid,16);
+        printf(&quot;Type            :&quot;);
+        for(int z=0;z&lt;16;z++) printf(&quot;0x%02x,&quot;,gid[z]);
+        if(!memcmp(gid,asf_video,16))
+        {
+          printf(&quot;(video)&quot;);
+          audiovideo=1;
+        } else
+        {
+          if(!memcmp(gid,asf_audio,16))
+          {
+            printf(&quot;(audio)&quot;); 
+            audiovideo=2;
+          } else printf(&quot;(? ? ? ?)&quot;); 
+        }
+        printf(&quot;\nConceal       :&quot;);
+        for(int z=0;z&lt;16;z++) printf(&quot;:%02x&quot;,s-&gt;read8());
+        printf(&quot;\n&quot;);
+        printf(&quot;Reserved    : %08x\n&quot;,s-&gt;read64());
+        printf(&quot;Total Size  : %04x\n&quot;,s-&gt;read32());
+        printf(&quot;Size        : %04x\n&quot;,s-&gt;read32());
+        sid=s-&gt;read16();
+        printf(&quot;Stream nb   : %04x\n&quot;,sid);
+        printf(&quot;Reserved    : %04x\n&quot;,s-&gt;read32());
+        switch(audiovideo)
+        {
+          case 1: // Video
+          {
+                    _videoStreamId=sid;
+                    if(!loadVideo(s))
+                    {
+                      delete s;
+                      return 0; 
+                    }
+                    break;
+          }
+              break;
+          case 2: // audio
+          {
+            asfAudioTrak *trk=&amp;(_allAudioTracks[_nbAudioTrack]);
+            ADM_assert(_nbAudioTrack&lt;ASF_MAX_AUDIO_TRACK);
+            trk-&gt;streamIndex=sid;
+            s-&gt;read((uint8_t *)&amp;(trk-&gt;wavHeader),sizeof(WAVHeader));
+
+		#ifdef ADM_BIG_ENDIAN
+			Endian_WavHeader(&amp;(trk-&gt;wavHeader));
+		#endif
+
+            trk-&gt;extraDataLen=s-&gt;read16();
+            printf(&quot;Extension :%u bytes\n&quot;,trk-&gt;extraDataLen);
+            if(trk-&gt;extraDataLen)
+            {
+              trk-&gt;extraData=new uint8_t[trk-&gt;extraDataLen];
+              s-&gt;read(trk-&gt;extraData,trk-&gt;extraDataLen);
+            }
+              printf(&quot;#block in group   :%d\n&quot;,s-&gt;read8());
+              printf(&quot;#byte in group    :%d\n&quot;,s-&gt;read16());
+              printf(&quot;Align1            :%d\n&quot;,s-&gt;read16());
+              printf(&quot;Align2            :%d\n&quot;,s-&gt;read16());
+              _nbAudioTrack++;
+            
+          }
+          break;
+          default:break; 
+          
+        }
+      }
+      break;
+       default:
+         break;
+    }
+    s-&gt;skipChunk();
+    delete s;
+  }
+  printf(&quot;End of headers\n&quot;);
+  return 1;
+}
+uint8_t    asfHeader::changeAudioStream(uint32_t newstream)
+{
+  ADM_assert(_currentAudioStream&lt;_nbAudioTrack);
+  _currentAudioStream=newstream;
+  return 1;
+}
+uint32_t    asfHeader::getCurrentAudioStreamNumber(void)
+{
+  return _currentAudioStream;
+}
+uint8_t     asfHeader::getAudioStreamsInfo(uint32_t *nbStreams, audioInfo **infos)
+{
+    *nbStreams=_nbAudioTrack;
+    if(_nbAudioTrack)
+    {
+      *infos=new audioInfo[_nbAudioTrack];
+      for(int i=0;i&lt;_nbAudioTrack;i++)
+      {
+        WAV2AudioInfo(&amp;(_allAudioTracks[i].wavHeader),&amp;((*infos)[i]));
+      }
+    }
+    return 1;
+}
+uint8_t asfHeader::loadVideo(asfChunk *s)
+{
+  uint32_t w,h,x;
+            w=s-&gt;read32();
+            h=s-&gt;read32();
+            s-&gt;read8();
+            x=s-&gt;read16();
+            _isvideopresent=1;
+
+            memset(&amp;_mainaviheader,0,sizeof(_mainaviheader));
+            _mainaviheader.dwWidth=w;
+            _mainaviheader.dwHeight=h;
+            _video_bih.biWidth=w;
+            _video_bih.biHeight=h;
+            printf(&quot;Pic Width  %04d\n&quot;,w);
+            printf(&quot;Pic Height %04d\n&quot;,h);
+            printf(&quot; BMP size  %04d (%04d)\n&quot;,x,sizeof(ADM_BITMAPINFOHEADER));
+            s-&gt;read((uint8_t *)&amp;_video_bih,sizeof(ADM_BITMAPINFOHEADER));
+
+		#ifdef ADM_BIG_ENDIAN
+			Endian_BitMapInfo(&amp;_video_bih);
+		#endif
+
+            _videostream.dwScale=1000;
+            _videostream.dwRate=30000;
+
+            _videostream.fccHandler=_video_bih.biCompression;
+            printf(&quot;Codec : &lt;%s&gt; (%04x)\n&quot;,
+                    fourCC::tostring(_video_bih.biCompression),_video_bih.biCompression);
+            if(fourCC::check(_video_bih.biCompression,(uint8_t *)&quot;DVR &quot;))
+            {
+              // It is MS DVR, fail so that the mpeg2 indexer can take it from here
+              _videostream.fccHandler=_video_bih.biCompression=fourCC::get((uint8_t *)&quot;MPEG&quot;);
+              printf(&quot;This is MSDVR, not ASF\n&quot;);
+              return 0; 
+            }
+            printBih(&amp;_video_bih);
+            if(x&gt;sizeof(ADM_BITMAPINFOHEADER))
+            {
+              _extraDataLen=x-sizeof(ADM_BITMAPINFOHEADER);
+              _extraData=new uint8_t[_extraDataLen];
+              s-&gt;read(_extraData,_extraDataLen);
+            }
+            return 1;
+}
+/*
+    Scan the file to build an index
+    
+    Header Chunk
+            Chunk
+            Chunk
+            Chunk
+            
+    Data chunk
+            Chunk
+            Chunk
+            
+    We skip the 1st one, and just read the header of the 2nd one
+    
+*/
+uint8_t asfHeader::buildIndex(void)
+{
+  uint32_t fSize;
+  const chunky *id;
+  uint32_t chunkFound;
+  uint32_t r=5;
+  uint32_t len;
+  
+  fseeko(_fd,0,SEEK_END);
+  fSize=ftello(_fd);
+  fseeko(_fd,0,SEEK_SET);
+  
+  asfChunk h(_fd);
+  printf(&quot;[ASF] ********** Building index **********\n&quot;);
+  printf(&quot;[ASF] Searching data\n&quot;);
+  while(r--)
+  {
+    h.nextChunk();    // Skip headers
+    id=h.chunkId();
+    h.dump();
+    if(id-&gt;id==ADM_CHUNK_DATA_CHUNK) break;
+    h.skipChunk();
+  }
+  if(id-&gt;id!=ADM_CHUNK_DATA_CHUNK) return 0;
+  // Remove leftover from DATA_chunk
+ // Unknown	GUID	16
+//       Number of packets	UINT64	8
+//       Unknown	UINT8	1
+//       Unknown	UINT8	1
+//   
+  h.read32();
+  h.read32();
+  h.read32();
+  h.read32();
+  _nbPackets=(uint32_t) h.read64();
+  h.read16();
+  
+  len=h.chunkLen-16-8-2-24;
+  
+  printf(&quot;[ASF] nbPacket  : %u\n&quot;,_nbPackets);
+  printf(&quot;[ASF] len to go : %u\n&quot;,len);
+  printf(&quot;[ASF] scanning data\n&quot;);
+  _dataStartOffset=ftello(_fd);
+  
+  // Here we go
+  //DIA_working *working=new DIA_working(&quot;indexing asf&quot;);
+  asfPacket *aPacket=new asfPacket(_fd,_nbPackets,_packetSize,
+                                   &amp;readQueue,_dataStartOffset);
+  uint32_t packet=1;
+#define MAXIMAGE (_nbPackets)
+  uint32_t sequence=1;
+  uint32_t ceilImage=MAXIMAGE;
+
+  nbImage=0;
+  asfIndex *tmpIndex=new asfIndex[ceilImage];
+  memset(tmpIndex,0,sizeof(asfIndex)*ceilImage);
+  len=0;
+  tmpIndex[0].segNb=1;
+  while(packet&lt;_nbPackets)
+  {
+    while(!readQueue.isEmpty())
+    {
+      asfBit *bit=NULL;
+      ADM_assert(readQueue.pop((void**)&amp;bit));
+      if(nbImage&gt;=ceilImage-1)
+      {  // Expand if our first guess was too small
+           uint32_t newceil=ceilImage*2;
+           asfIndex *tmptmpIndex=new asfIndex[newceil];
+           memset(tmptmpIndex,0,sizeof(asfIndex)*newceil);
+           memcpy(tmptmpIndex,tmpIndex,sizeof(asfIndex)*ceilImage);
+           delete [] tmpIndex;
+           tmpIndex=tmptmpIndex;
+           ceilImage=newceil;
+      }
+      if(bit-&gt;stream==_videoStreamId)
+      {
+          aprintf(&quot;&gt;found packet of size %d seq %d, while curseq =%d\n&quot;,bit-&gt;len,bit-&gt;sequence,curSeq);
+          if(bit-&gt;sequence!=sequence)
+          {
+            tmpIndex[nbImage].frameLen=len;
+            aprintf(&quot;New sequence\n&quot;);
+            if( ((sequence+1)&amp;0xff)!=(bit-&gt;sequence&amp;0xff))
+            {
+                printf(&quot;!!!!!!!!!!!! non continuous sequence %u %u\n&quot;,sequence,bit-&gt;sequence); 
+    #if 1         
+                // Let's insert a couple of null frame
+                int32_t delta,start,end;
+                
+                start=256+bit-&gt;sequence-sequence-1;
+                start&amp;=0xff;
+                printf(&quot;!!!!!!!!!!!! Delta %d\n&quot;,start);
+                
+                for(int filler=0;filler&lt;start;filler++)
+                {
+                  tmpIndex[++nbImage].frameLen=0;
+                }
+    #endif            
+            }
+            nbImage++;
+            ADM_assert(nbImage&lt;ceilImage);
+            tmpIndex[nbImage].frameLen=0;
+            tmpIndex[nbImage].segNb=bit-&gt;sequence;
+            tmpIndex[nbImage].packetNb=bit-&gt;packet;
+            tmpIndex[nbImage].flags=bit-&gt;flags;
+
+            for(int z=0;z&lt;_nbAudioTrack;z++)
+            {
+              tmpIndex[nbImage].audioSeen[z]=_allAudioTracks[z].length;
+            }
+            readQueue.pushBack(bit);
+    
+            sequence=bit-&gt;sequence;
+            len=0;
+            continue;
+          }
+          len+=bit-&gt;len;
+      } // End of video stream Id
+      else  // Audio ?
+      {
+        int found=0;
+        for(int i=0;i&lt;_nbAudioTrack &amp;&amp; !found;i++)
+        {
+          if(bit-&gt;stream == _allAudioTracks[i].streamIndex)
+          {
+            
+            _allAudioTracks[i].length+=bit-&gt;len;
+            found=1;
+          }
+        }
+        if(!found) 
+        {
+          printf(&quot;Unmapped stream %u\n&quot;,bit-&gt;stream); 
+        }
+      }
+     delete[] bit-&gt;data;
+     delete bit;
+    }
+    //working-&gt;update(packet,_nbPackets);
+
+    packet++;
+    aPacket-&gt;nextPacket(0xff); // All packets
+    aPacket-&gt;skipPacket();
+  }
+  delete aPacket;
+  //delete working;
+  /* Compact index */
+  _index=new asfIndex[nbImage];
+  memcpy(_index,tmpIndex,sizeof(asfIndex)*nbImage);
+  delete [] tmpIndex;
+  
+  fseeko(_fd,_dataStartOffset,SEEK_SET);
+  printf(&quot;[ASF] %u images found\n&quot;,nbImage);
+  printf(&quot;[ASF] ******** End of buildindex *******\n&quot;);
+  _videostream.dwLength=_mainaviheader.dwTotalFrames=nbImage;
+  if(!nbImage) return 0;
+  
+  // Update fps
+  // In fact it is an average fps
+  // FIXME
+  float f=nbImage;
+  uint32_t ps;
+  
+  f*=1000.*1000.*10000.;
+  f=f/_duration;
+  ps=(uint32_t)f;
+  // Round up to the closed 0.5 = 500
+  ps=(ps+490)/500;
+  ps*=500;
+  
+  _videostream.dwScale=1000;
+  _videostream.dwRate=ps;
+
+  return 1;
+  
+}
+//EOF

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf.h	2009-08-12 18:12:50 UTC (rev 5241)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf.h	2009-08-14 17:29:18 UTC (rev 5242)
@@ -0,0 +1,201 @@
+/***************************************************************************
+                          ADM_pics.h  -  description
+                             -------------------
+    begin                : Mon Jun 3 2002
+    copyright            : (C) 2002 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+ 
+
+
+#ifndef ADM_ASF_H
+#define ADM_ASF_H
+
+#include &quot;ADM_editor/ADM_Video.h&quot;
+#include &quot;ADM_audio/aviaudio.hxx&quot;
+
+#include &quot;ADM_osSupport/ADM_queue.h&quot;
+#include &quot;ADM_asfPacket.h&quot;
+
+#define ASF_MAX_AUDIO_TRACK 8
+
+typedef struct 
+{
+  uint32_t packetNb;
+  uint32_t frameLen;
+  uint32_t segNb;
+  uint32_t flags;
+  uint32_t audioSeen[ASF_MAX_AUDIO_TRACK];
+}asfIndex;
+
+typedef enum 
+{
+  ADM_CHUNK_HEADER_CHUNK ,
+  ADM_CHUNK_FILE_HEADER_CHUNK,
+  ADM_CHUNK_NO_AUDIO_CONCEAL,
+  ADM_CHUNK_STREAM_HEADER_CHUNK,
+  ADM_CHUNK_STREAM_GROUP_ID,
+  ADM_CHUNK_DATA_CHUNK,
+  ADM_CHUNK_HEADER_EXTENSION_CHUNK,
+  ADM_CHUNK_CLOCK_TYPE_EX,
+  ADM_CHUNK_LANGUAGE_LIST_EX,
+  ADM_CHUNK_EXTENDED_STREAM_PROP,
+  ADM_CHUNK_UNKNOWN_CHUNK
+}ADM_KNOWN_CHUNK;
+typedef struct 
+{
+  const char *name;
+  uint32_t len;
+  uint8_t val[16];
+  ADM_KNOWN_CHUNK id; 
+}chunky;
+class asfChunk
+{
+  protected:
+    FILE        *_fd;
+    
+    
+  public:
+  uint32_t  _chunkStart;
+            asfChunk(FILE *f);
+            ~asfChunk();
+  uint8_t   dump(void);
+  uint8_t   guId[16];
+  uint64_t  chunkLen;
+  
+  uint8_t   readChunkPayload(uint8_t *data, uint32_t *dataLen);
+  uint8_t   nextChunk(int shortChunk=0);
+  uint8_t   skipChunk(void);
+  uint64_t  read64(void);
+  uint32_t  read32(void);
+  uint32_t  read16(void);
+  uint8_t   read8(void);
+  uint8_t   read(uint8_t *where, uint32_t how);
+  const chunky    *chunkId(void);
+  uint8_t   skip(uint32_t skip);
+};
+
+typedef struct 
+{
+  uint32_t     streamIndex;
+  uint32_t     extraDataLen;
+  uint8_t      *extraData;
+  uint32_t     nbPackets;
+  uint32_t     length;
+  WAVHeader    wavHeader;
+  
+}asfAudioTrak;
+
+class asfAudio : public AVDMGenericAudioStream
+{
+  protected:
+    uint32_t                _myRank;
+    uint32_t                _extraDataLen;
+    uint8_t                 *_extraData;
+    char                    *myName;
+    uint32_t                _streamId;
+    uint32_t                _dataStart;
+    asfPacket               *_packet;
+    FILE                    *_fd;
+    ADM_queue               readQueue;
+    uint32_t                _packetSize;
+    class asfHeader         *_father;
+    asfAudioTrak            *_track;
+  public:
+                                asfAudio(asfHeader *father,uint32_t rank);
+    virtual                     ~asfAudio();
+    virtual uint32_t            read(uint32_t len,uint8_t *buffer);
+    virtual uint8_t             goTo(uint32_t newoffset);
+    virtual uint8_t             getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples);
+    virtual uint8_t             goToTime(uint32_t mstime);
+    virtual uint8_t             extraData(uint32_t *l,uint8_t **d);
+};
+
+
+
+class asfHeader         :public vidHeader
+{
+  protected:
+    uint8_t                 getHeaders( void);
+    uint8_t                 buildIndex(void);
+    uint8_t                 loadVideo(asfChunk *s);
+    
+    ADM_queue               readQueue;
+    uint32_t                curSeq;
+    asfPacket               *_packet;
+    uint32_t                _currentAudioStream;
+    uint64_t                _duration;  // Duration 100 ns
+  protected:
+                                
+    FILE                    *_fd;
+
+    int32_t                 _videoIndex;
+    uint32_t                _extraDataLen;
+    uint8_t                 *_extraData;
+    
+    
+    uint32_t                _videoStreamId;
+    
+  public: // Shared with audio track
+    char                    *myName;
+    
+    uint32_t                nbImage;
+    asfIndex                *_index;
+    uint32_t                _packetSize;
+    uint32_t                _dataStartOffset;
+    uint32_t                _nbAudioTrack;
+    asfAudio                *_curAudio;
+    asfAudioTrak             _allAudioTracks[ASF_MAX_AUDIO_TRACK];
+    uint32_t                 _nbPackets;
+    
+    // / Shared
+  public:
+
+
+    virtual   void          Dump(void);
+    virtual   uint8_t       getExtraHeaderData(uint32_t *len, uint8_t **data);
+             asfHeader( void );
+    virtual  ~asfHeader(  ) ;
+// AVI io
+    virtual uint8_t  open(const char *name);
+    virtual uint8_t  close(void) ;
+  //__________________________
+  //  Info
+  //__________________________
+
+  //__________________________
+  //  Audio
+  //__________________________
+
+    virtual   WAVHeader *getAudioInfo(void ) ;
+    virtual uint8_t getAudioStream(AVDMGenericAudioStream **audio);
+
+
+// Frames
+  //__________________________
+  //  video
+  //__________________________
+
+    virtual uint8_t  setFlag(uint32_t frame,uint32_t flags);
+    virtual uint32_t getFlags(uint32_t frame,uint32_t *flags);
+    virtual uint8_t  getFrameNoAlloc(uint32_t framenum,ADMCompressedImage *img)	;
+    //
+    //  Multiple audio channels
+    //
+    uint8_t           changeAudioStream(uint32_t newstream);
+    uint32_t          getCurrentAudioStreamNumber(void) ;
+    uint8_t           getAudioStreamsInfo(uint32_t *nbStreams, audioInfo **infos);
+
+};
+#endif
+
+

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfChunk.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfChunk.cpp	2009-08-12 18:12:50 UTC (rev 5241)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfChunk.cpp	2009-08-14 17:29:18 UTC (rev 5242)
@@ -0,0 +1,207 @@
+/***************************************************************************
+    copyright            : (C) 2006 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &quot;config.h&quot;
+
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+
+#include &lt;string.h&gt;
+
+#include &lt;math.h&gt;
+
+#include &quot;ADM_default.h&quot;
+#include &quot;ADM_editor/ADM_Video.h&quot;
+#include &quot;ADM_assert.h&quot;
+
+#include &quot;fourcc.h&quot;
+
+
+#include &quot;ADM_asf.h&quot;
+
+// <A HREF="http://www.thozie.de/dnn/AVIMaster.aspx?PageContentID=4">http://www.thozie.de/dnn/AVIMaster.aspx?PageContentID=4</A>
+
+static const chunky mychunks[]=
+{
+  {&quot;Header Chunk&quot;,0,    {0x30,0x26,0xb2,0x75,0x8e,0x66,0xcf,0x11,0xa6,0xd9,0x00,0xaa,0x00,0x62,0xce,0x6c},ADM_CHUNK_HEADER_CHUNK},
+  {&quot;File Header&quot;,0,  {0xa1,0xdc,0xab,0x8c,0x47,0xa9,0xcf,0x11,0x8e,0xe4,0x00,0xc0,0x0c,0x20,0x53,0x65},ADM_CHUNK_FILE_HEADER_CHUNK},
+  {&quot;No audio conceal&quot;,0,
+  {0x40,0x52,0xd1,0x86,0x1d,0x31,0xd0,0x11,0xa3,0xa4,0x00,0xa0,0xc9,0x03,0x48,0xf6},ADM_CHUNK_NO_AUDIO_CONCEAL},
+  {&quot;Stream Header&quot;,0,   {0x91,0x07,0xdc,0xb7,0xb7,0xa9,0xcf,0x11,0x8e,0xe6,0x00,0xc0,0x0c,0x20,0x53,0x65},ADM_CHUNK_STREAM_HEADER_CHUNK},
+  {&quot;Stream Group Id&quot;,0, {0xce,0x75,0xf8,0x7b,0x8d,0x46,0xd1,0x11,0x8d,0x82,0x00,0x60,0x97,0xc9,0xa2,0xb2},ADM_CHUNK_STREAM_GROUP_ID},
+  {&quot;Data Chunk&quot;,0,      {0x36,0x26,0xb2,0x75,0x8e,0x66,0xcf,0x11,0xa6,0xd9,0x00,0xaa,0x00,0x62,0xce,0x6c},ADM_CHUNK_DATA_CHUNK},
+  {&quot;Header Extension&quot;,0,
+    {0Xb5,0x03,0xbf,0x5f,0x2e,0xa9,0xcf,0x11,0x8e,0xe3,0x00,0xc0,0x0c,0x20,0x53,0x65},
+              ADM_CHUNK_HEADER_EXTENSION_CHUNK},
+  {&quot;Clock Type  Ext&quot;,0,
+  {0x11,0xd2,0xd3,0xab,0xba,0xa9,0xcf,0x11,0x8e,0xe6,0x00,0xc0,0x0c,0x20,0x53,0x65},ADM_CHUNK_CLOCK_TYPE_EX},
+  {&quot;Language List Ext&quot;,0,
+  {0xa9,0x46,0x43,0x7c,0xe0,0xef,0xfc,0x4b,0xb2,0x29,0x39,0x3e,0xde,0x41,0x5c,0x85},ADM_CHUNK_LANGUAGE_LIST_EX},
+  {&quot;Compatibility List Ex&quot;,0,
+  {0x5d,0x8b,0xf1,0x26,0x84,0x45,0xec,0x47,0x9f,0x5f,0x0e,0x65,0x1f,0x04,0x52,0xc9},ADM_CHUNK_UNKNOWN_CHUNK},
+  {&quot;Padding&quot;,0,
+  {0x74,0xd4,0x06,0x18,0xdf,0xca,0x09,0x45,0xa4,0xba,0x9a,0xab,0xcb,0x96,0xaa,0xe8},ADM_CHUNK_UNKNOWN_CHUNK},
+  {&quot;Padding2&quot;,0,
+  {0x94,0x1c,0x23,0x44,0x98,0x94,0xd1,0x49,0xa1,0x41,0x1d,0x13,0x4e,0x45,0x70,0x54},ADM_CHUNK_UNKNOWN_CHUNK},
+
+  {&quot;Extended Stream Property&quot;,0,
+  {0xcb,0xa5,0xe6,0x14,0x72,0xc6,0x32,0x43,0x83,0x99,0xa9,0x69,0x52,0x06,0x5b,0x5a},ADM_CHUNK_EXTENDED_STREAM_PROP},
+  {&quot;MetaData Object&quot;,0,
+  {0xea,0xcb,0xf8,0xc5,0xaf,0x5b,0x77,0x48,0x84,0x67,0xaa,0x8c,0x44,0xfa,0x4c,0xca},ADM_CHUNK_UNKNOWN_CHUNK},
+  
+  {&quot;zz&quot;,0,{0x30,0x26,0xb2,0x75,0x8e,0x66,0xcf,0x11,0xa6,0xd9,0x00,0xaa,0x00,0x62,0xce,0x6c},ADM_CHUNK_HEADER_CHUNK}
+  
+};
+static const chunky nochunk=
+{&quot;Unknown&quot;,0,{0x10,0x20,0x30,0x40,0xde,0xad,0xde,0xad,0xbe,0xef,0xbe,0xef,0x00,0x62,0xce,0x6c},ADM_CHUNK_UNKNOWN_CHUNK};
+
+
+ asfChunk::asfChunk(FILE *f)
+{
+  _fd=f;
+  _chunkStart=ftello(f);;
+  printf(&quot;Chunk created at %x\n&quot;,_chunkStart);
+  ADM_assert(_fd);
+  chunkLen=0;
+}
+ asfChunk::~asfChunk()
+{
+}
+uint8_t   asfChunk::readChunkPayload(uint8_t *data, uint32_t *dataLen)
+{
+  uint32_t remaining;
+  
+  remaining=ftello(_fd);
+  remaining-=_chunkStart;
+  remaining=chunkLen-remaining;
+  fread(data,remaining,1,_fd);
+  *dataLen=remaining;
+  return 1;
+}
+uint8_t   asfChunk::skip(uint32_t skip)
+{
+  fseeko(_fd,skip,SEEK_CUR);
+  return 1; 
+}
+uint8_t   asfChunk::nextChunk(int shortChunk)
+{
+  uint32_t low,high;
+  
+  if(_chunkStart)
+  {
+    
+    fseeko(_fd,_chunkStart+ chunkLen,SEEK_SET);
+  }
+  
+  _chunkStart=ftello(_fd);
+  fread(guId,16,1,_fd);
+  if(shortChunk)
+  {
+    low=read16()+16;
+    high=0;
+  } 
+  else
+  {
+    low=read32();
+    high=read32();
+  }
+  chunkLen=high;
+  chunkLen&lt;&lt;=32;
+  chunkLen+=low;
+  
+  printf(&quot;Next chunk from %x +%u to %x\n&quot;,_chunkStart,chunkLen,chunkLen+_chunkStart);
+  
+  return 1;
+  
+}
+uint8_t   asfChunk::skipChunk(void)
+{
+  uint32_t go;
+  go=_chunkStart+ chunkLen;
+  printf(&quot;Pos %x\n&quot;,ftello(_fd));
+  fseeko(_fd,go,SEEK_SET);
+  printf(&quot;Skipping to %x\n&quot;,go);
+  
+  return 1; 
+}
+uint64_t  asfChunk::read64(void)
+{
+  uint64_t lo,hi;
+  lo=read32();
+  hi=read32();
+  return lo+(hi&lt;&lt;32); 
+  
+}
+uint32_t   asfChunk::read32(void)
+{
+  uint8_t c[4];
+  
+  fread(c,4,1,_fd);
+  
+  return c[0]+(c[1]&lt;&lt;8)+(c[2]&lt;&lt;16)+(c[3]&lt;&lt;24);
+  
+}
+uint32_t   asfChunk::read16(void)
+{
+  uint8_t c[2];
+  
+  fread(c,2,1,_fd);
+  
+  return c[0]+(c[1]&lt;&lt;8);
+  
+}
+
+uint8_t   asfChunk::read8(void)
+{
+  uint8_t c[1];
+  
+  fread(c,1,1,_fd);
+  
+  return c[0];
+  
+}
+uint8_t   asfChunk::read(uint8_t *where, uint32_t how)
+{
+ 
+  if(1!=fread(where,how,1,_fd))
+  {
+    printf(&quot;[AsfChunk] Read error\n&quot;);
+    return 0; 
+  }
+  return 1;
+
+  
+}
+uint8_t   asfChunk::dump(void)
+{
+  const chunky *id;
+  id=chunkId();
+  printf(&quot;Chunk type  : &lt;&lt;&lt;&lt;%s&gt;&gt;&gt;&gt;\n&quot;,id-&gt;name);
+  printf(&quot;Chunk Start : %x\n&quot;,_chunkStart);
+  printf(&quot;Chunk Len   : %lu\n&quot;,(uint32_t)chunkLen);
+  for(int i=0;i&lt;16;i++) printf(&quot;%02x &quot;,guId[i]);
+  printf(&quot;\n&quot;);
+  return 1;
+  
+}
+const chunky *asfChunk::chunkId(void)
+{
+  int mx=sizeof(mychunks)/sizeof(chunky);
+  for(int i=0;i&lt;sizeof(mychunks)/sizeof(chunky);i++)
+  {
+    if(!memcmp(mychunks[i].val,guId,16)) return &amp;mychunks[i];
+  }
+  return &nochunk;
+  
+}
+

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfIo.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfIo.h	2009-08-12 18:12:50 UTC (rev 5241)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfIo.h	2009-08-14 17:29:18 UTC (rev 5242)
@@ -0,0 +1,35 @@
+  uint64_t  asfPacket::read64(void)
+      {
+        uint64_t lo,hi;
+        lo=read32();
+        hi=read32();
+        _offset+=8;
+        ADM_assert(_offset&lt;=pakSize);
+        return lo+(hi&lt;&lt;32); 
+        
+      }
+      uint32_t   asfPacket::read32(void)
+      {
+        uint8_t c[4];
+        fread(c,4,1,_fd);
+        _offset+=4;
+        ADM_assert(_offset&lt;=pakSize);
+        return c[0]+(c[1]&lt;&lt;8)+(c[2]&lt;&lt;16)+(c[3]&lt;&lt;24);
+      }
+      uint32_t   asfPacket::read16(void)
+      {
+        uint8_t c[2];
+        fread(c,2,1,_fd);
+        _offset+=2;
+        ADM_assert(_offset&lt;=pakSize);
+        return c[0]+(c[1]&lt;&lt;8);
+      }
+      
+      uint8_t   asfPacket::read8(void)
+      {
+        uint8_t c[1];
+        fread(c,1,1,_fd);
+        _offset++;
+        ADM_assert(_offset&lt;=pakSize);
+        return c[0];
+      }

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfPacket.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfPacket.cpp	2009-08-12 18:12:50 UTC (rev 5241)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfPacket.cpp	2009-08-14 17:29:18 UTC (rev 5242)
@@ -0,0 +1,407 @@
+/***************************************************************************
+    copyright            : (C) 2006 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &quot;config.h&quot;
+
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+
+#include &lt;string.h&gt;
+
+#include &lt;math.h&gt;
+
+#include &quot;ADM_default.h&quot;
+#include &quot;ADM_editor/ADM_Video.h&quot;
+#include &quot;ADM_assert.h&quot;
+
+#include &quot;fourcc.h&quot;
+
+
+#include &quot;ADM_asfPacket.h&quot;
+
+#include &quot;ADM_osSupport/ADM_debugID.h&quot;
+#define MODULE_NAME MODULE_ASF
+#include &quot;ADM_osSupport/ADM_debug.h&quot;
+
+ 
+asfPacket::asfPacket(FILE *f,uint32_t nb,uint32_t pSize,ADM_queue *q,uint32_t startDataOffset)
+ {
+   _fd=f;
+   pakSize=pSize;
+   ADM_assert(pakSize);
+   packetStart=ftello(f);;
+   aprintf(&quot;Packet created at %x\n&quot;,packetStart);
+   ADM_assert(_fd);
+   queue=q;
+   ADM_assert(q);
+   currentPacket=0;
+   _nbPackets=nb;
+   _startDataOffset=startDataOffset;
+ }
+ asfPacket::~asfPacket()
+ {
+	 purge();
+ }
+ uint8_t   asfPacket::readChunkPayload(uint8_t *data, uint32_t *dataLen)
+ {
+   uint32_t remaining;
+   *dataLen=0;
+   ADM_assert(0);
+   purge();
+   return 1;
+  
+ }
+ 
+ uint8_t asfPacket::goToPacket(uint32_t packet)
+ {
+   uint32_t offset=_startDataOffset+packet*pakSize;
+   fseeko(_fd,offset,SEEK_SET);
+   currentPacket=packet;
+   return 1;
+ }
+ /*
+      Read ASF packet &amp; segments 
+ 
+    Flags are bitwise OR of:
+   
+ 0x40 Explicit packet size specified word16  0X60 Means word32
+ 0x20 Explicit packet size specified byte
+   
+ 0x10 16-bit padding size specified  0x18 means word32
+ 0x08 8-bit padding size specified
+   
+ 0x04 sequence coded in word16
+ 0x02 sequence coded in byte
+ 0x01 More than one segment
+ 
+ 
+ Docs from <A HREF="http://avifile.sourceforge.net/asf-1.0.htm">http://avifile.sourceforge.net/asf-1.0.htm</A>
+  completed by mplayer code
+  
+ 
+ */
+uint8_t   asfPacket::nextPacket(uint8_t streamWanted)
+{
+   uint32_t atime,aduration,nbSeg,segType=0x80;
+   uint32_t sequenceLen,len,streamId;
+   int32_t   packetLen=0;
+   uint32_t  paddingLen;
+   uint8_t   flags;
+    
+   packetStart=ftello(_fd);
+#ifdef ADM_DEBUG
+   uint32_t round=packetStart-_startDataOffset;
+   if(round % pakSize)
+   {
+     printf(&quot;[ASF PACKET] we are starting a new packet at 0x%x\n&quot;,packetStart); 
+     printf(&quot;[ASF PACKET]but data starts at  0x%x\n&quot;,_startDataOffset);
+     printf(&quot;[ASF PACKET]and offset is not a multiple of length = %d\n&quot;,pakSize);
+     ADM_assert(0);
+     
+   }
+#endif
+   _offset=0;
+   if(read8()!=0x82) 
+   {
+     printf(&quot;[ASF PACKET]At pos %x \n&quot;,ftello(_fd));
+     printf(&quot;[ASF PACKET]not a 82 packet\n&quot;);
+     printf(&quot;[ASF PACKET]not a 82 packet\n&quot;);
+     printf(&quot;[ASF PACKET]not a 82 packet\n&quot;);
+     return 0;
+   }
+   
+   aprintf(&quot;============== New packet ===============\n&quot;);
+   read16();          // Always 0 ????
+   flags=read8();
+   segmentId=read8();
+   packetLen=0;
+   paddingLen=0;
+   
+
+   // Read packetLen
+   packetLen=readVCL(flags&gt;&gt;5);
+   // Sequence len
+   sequenceLen=readVCL(flags&gt;&gt;1);
+   // Read padding size (padding):
+   paddingLen=readVCL(flags&gt;&gt;3);
+   
+   aprintf(&quot;paddingLen :         %d\n&quot;,paddingLen);
+   
+// Explicit (absolute) packet size	    
+   if(((flags&gt;&gt;5)&amp;3))
+   {
+     printf(&quot;## Explicit packet size %d\n&quot;,packetLen);
+     if(packetLen&gt;pakSize) printf(&quot;**************Len &gt; packet size!! (%d /%d)\n&quot;,packetLen,pakSize);
+   } 
+   if(!packetLen)
+   {
+     // Padding (relative) size
+     packetLen=pakSize-_offset;
+     packetLen=packetLen-paddingLen;
+   }
+
+   
+  
+   atime=read32(); // Send time
+   aduration=read16(); // Duration
+   
+   if(flags &amp;1) // Multiseg
+   {
+     uint8_t r=read8();
+     nbSeg=r&amp;0x3f;
+     segType=r&gt;&gt;6;
+   }
+   else
+   {
+     nbSeg=1; 
+   }
+#ifdef ASF_VERBOSE   
+   printf(&quot;-----------------------\n&quot;);
+   printf(&quot;Flags     :           0X%x&quot;,flags);
+   
+   if(flags &amp; 0x40) printf(&quot; Packet Len Specified  &quot;);
+   if(flags &amp; 0x10) printf(&quot; Padding 16bits &quot;);
+   if(flags &amp; 0x8) printf(&quot; Padding 8bits &quot;);
+   if(flags &amp; 0x1) printf(&quot; Multiseg &quot;);
+   printf(&quot;\n&quot;);
+   printf(&quot;SegmentId :           %d\n&quot;,segmentId);
+   printf(&quot;sequenceLen :         %d\n&quot;,sequenceLen);
+   
+   
+   printf(&quot;packetLen :           %d\n&quot;,packetLen);
+   printf(&quot;Send      :           %d\n&quot;,atime);
+   printf(&quot;Duration  :           %d\n&quot;,aduration);
+   printf(&quot;# of seg  :           %d %x\n&quot;,nbSeg,segType);
+#endif
+   // Now read Segments....
+   //
+   uint32_t sequence, offset,replica,r;
+   int32_t remaining;
+   uint32_t payloadLen;
+   uint32_t keyframe;
+   for(int seg=0;seg&lt;nbSeg;seg++)
+   {
+     r=read8(); // Read stream Id
+     if(r&amp;0x80) keyframe=AVI_KEY_FRAME;
+     else       keyframe=0;
+     streamId=r&amp;0x7f;
+     aprintf(&quot;&gt;&gt;&gt;&gt;&gt;Stream Id : %x&lt;&lt;&lt;&lt;&lt;\n&quot;,streamId);
+     if(r&amp;0x80) 
+     {
+       aprintf(&quot;KeyFrame\n&quot;);
+     }
+     sequence=readVCL(segmentId&gt;&gt;4);
+     offset=readVCL(segmentId&gt;&gt;2);
+     replica=readVCL(segmentId);
+     aprintf(&quot;replica                %d\n&quot;,replica);
+     // Skip replica data_len
+     skip(replica);
+     
+     payloadLen=0;
+     if(flags &amp;1)  // multi seg
+     {
+       payloadLen=readVCL(segType);
+       if(payloadLen)
+        aprintf(&quot;##len                    %d\n&quot;,payloadLen);
+       
+     }
+     remaining=pakSize-_offset;
+     remaining=remaining-paddingLen;
+     aprintf(&quot;Remaining %d asked %d\n&quot;,remaining,payloadLen);
+     if(remaining&lt;=0) 
+     {
+       printf(&quot;** Err: No data left (%d)\n&quot;,remaining); 
+     }
+     if(!payloadLen)
+     {
+       payloadLen=remaining;
+     }
+     if(remaining&lt;payloadLen)
+     {
+       printf(&quot;** WARNING too big %d %d\n&quot;, remaining,packetLen);
+       payloadLen=remaining;
+     }
+#ifdef ASF_VERBOSE     
+     printf(&quot;This segment %d bytes, %d /%d\n&quot;,packetLen,seg,nbSeg);
+     printf(&quot;Offset                 %d\n&quot;,offset);
+     printf(&quot;sequence               %d\n&quot;,sequence);
+     printf(&quot;Grouping               %d\n&quot;,replica==1);
+     printf(&quot;payloadLen             %d\n&quot;,payloadLen);
+#endif
+     // Frag
+     if(replica==1) // Grouping
+     {
+       // Each tiny packet starts with 
+       // 1 byte = packet Len
+       // Data and we read them until &quot;payloadLen&quot; is comsumed
+       while(payloadLen&gt;0)
+       {
+         uint8_t l=read8();
+         payloadLen--;
+         if(l&gt;payloadLen)
+         {
+           
+           printf(&quot;oops exceeding %d/%d\n&quot;,l,payloadLen);
+           if(streamId==streamWanted || streamWanted==0xff)
+           {
+             pushPacket(keyframe,currentPacket,offset,sequence,payloadLen,streamId);
+             
+           }else
+           {
+            skip(payloadLen);
+           }
+           break;
+         }
+         skip(l);
+         payloadLen-=l;
+       }
+       
+     }else
+     { // else we read &quot;payloadLen&quot; bytes and put them at offset &quot;offset&quot;
+       if(streamId==streamWanted|| streamWanted==0xff)
+       {
+         pushPacket(keyframe,currentPacket,offset,sequence,payloadLen,streamId);    
+       }else
+        skip(payloadLen);
+       aprintf(&quot;Reading %d bytes\n&quot;,payloadLen);
+     }
+     
+   }
+   // Do some sanity check
+   if(_offset+paddingLen!=pakSize)
+   {
+     printf(&quot;!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! %d %d\n&quot;,_offset,paddingLen);
+   }
+   currentPacket++;
+   return 1;
+  
+ }
+ /*
+    Push a packet down the queue
+    The packet could be a complete one or a fragement
+    To know that, either look at the offset field which will be != for fragements
+    Or look if the sequence number is increasing
+ 
+ */
+
+ uint8_t asfPacket::pushPacket(uint32_t keyframe,uint32_t packetnb,uint32_t offset,uint32_t sequence,uint32_t payloadLen,uint32_t stream)
+ {
+   asfBit *bit=new asfBit;
+   aprintf(&quot;Pushing packet stream=%d len=%d seq=%d\n&quot;,stream,payloadLen,sequence);
+   bit-&gt;sequence=sequence;
+   bit-&gt;offset=offset;
+   bit-&gt;len=payloadLen;
+   bit-&gt;data=new uint8_t[payloadLen];
+   bit-&gt;stream=stream;
+   bit-&gt;packet=packetnb;
+   bit-&gt;flags=keyframe;
+
+   if(!read(bit-&gt;data,bit-&gt;len))
+   {
+		delete[] bit-&gt;data;
+		delete bit;
+		return 0; 
+   }
+
+   queue-&gt;push((void *)bit);
+   return 1;
+ }
+ 
+ uint32_t asfPacket::readVCL(uint32_t bitwise)
+ {
+   uint32_t r;
+   switch(bitwise&amp;3)
+   {
+     case 3: r=read32();break;  // dword
+     case 2: r=read16();break;  // word
+     case 1: r=read8();break;   // byte
+     default: r=0;
+   }
+   return r;
+ }
+
+ uint8_t   asfPacket::skipPacket(void)
+ {
+   uint32_t go;
+   go=packetStart+ pakSize;
+   aprintf(&quot;Pos %x\n&quot;,ftello(_fd));
+   fseeko(_fd,go,SEEK_SET);
+   aprintf(&quot;Skipping to %x\n&quot;,go);
+  
+   return 1; 
+ }
+ uint8_t   asfPacket::read(uint8_t *where, uint32_t how)
+ {
+ 
+   if(1!=fread(where,how,1,_fd))
+   {
+     printf(&quot;[AsfPacket] Read error\n&quot;);
+     return 0; 
+   }
+   _offset+=how;
+   ADM_assert(_offset&lt;=pakSize);
+
+   return 1;
+
+  
+ }
+ uint8_t   asfPacket::skip( uint32_t how)
+ {
+   fseeko(_fd,how,SEEK_CUR);
+   _offset+=how;
+   ADM_assert(_offset&lt;=pakSize);
+
+   return 1;
+ }
+ //****************************
+ uint8_t   asfPacket::dump(void)
+ {
+  
+   return 1;
+  
+ }
+ //****************************
+ uint8_t asfPacket::purge(void)
+ {
+    // Flush queue
+   while(!queue-&gt;isEmpty())
+   {
+     asfBit *bit;
+     ADM_assert(queue-&gt;pop((void**)&amp;bit));
+     delete[] bit-&gt;data;
+     delete bit;
+   }
+   return 1; 
+ }
+ //****************************
+ uint8_t   asfPacket::packTo(uint8_t *buffer,uint32_t *len)
+ {
+   *len=0;
+   while(!queue-&gt;isEmpty())
+   {
+     asfBit *bit;
+     ADM_assert(queue-&gt;pop((void**)&amp;bit));
+     memcpy(buffer,bit-&gt;data,bit-&gt;len);
+     *len+=bit-&gt;len;
+     delete[] bit-&gt;data;
+     delete bit;
+   }
+   return 1;
+ }
+ 
+ 
+#ifndef ASF_INLINE
+#include &quot;ADM_asfIo.h&quot;
+#endif
+
+ //EOF

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfPacket.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfPacket.h	2009-08-12 18:12:50 UTC (rev 5241)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfPacket.h	2009-08-14 17:29:18 UTC (rev 5242)
@@ -0,0 +1,77 @@
+
+/***************************************************************************
+    copyright            : (C) 2006 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+
+#ifndef ASF_PACKET_H
+#define ASF_PACKET_H
+
+#include &quot;ADM_osSupport/ADM_queue.h&quot;
+
+typedef struct 
+{
+  uint32_t sequence;
+  uint32_t offset;
+  uint32_t len;
+  uint32_t stream;
+  uint32_t packet;
+  uint32_t flags;
+  uint8_t  *data;
+}asfBit;
+
+class asfPacket
+{
+  protected:
+    uint32_t        readVCL(uint32_t bitwise);
+    uint8_t         pushPacket(uint32_t flags,uint32_t packetnb,
+                                uint32_t offset,uint32_t sequence,uint32_t payloadLen,uint32_t stream);
+    uint8_t         skip( uint32_t how);
+    FILE            *_fd;
+    uint32_t        packetStart;
+    uint8_t         segmentId;
+    uint32_t        pakSize;
+    ADM_queue       *queue;
+    uint32_t        _offset;
+    uint32_t        currentPacket;
+    uint32_t        _startDataOffset;
+    uint32_t        _nbPackets;
+  public:
+    
+    asfPacket(FILE *f,uint32_t nbElem,uint32_t pSize,ADM_queue *q,uint32_t startDataOffset);
+    ~asfPacket();
+    uint8_t   dump(void);
+    
+    uint8_t   goToPacket(uint32_t packet);
+  
+    uint8_t   readChunkPayload(uint8_t *data, uint32_t *dataLen);
+    uint8_t   nextPacket(uint8_t streamWanted);
+    uint8_t   skipPacket(void);
+    
+    uint32_t  getPos(void);
+    uint32_t  getPayloadLen(void);
+#ifdef ASF_INLINE
+    #include &quot;ADM_asfIo.h&quot;
+#else    
+    uint64_t  read64(void);
+    uint32_t  read32(void);
+    uint32_t  read16(void);
+    uint8_t   read8(void);
+#endif    
+    uint8_t   read(uint8_t *where, uint32_t how);
+    uint8_t   purge(void);
+    uint8_t   packTo(uint8_t *buffer,uint32_t *len);
+};
+
+#endif
+

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf_audio.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf_audio.cpp	2009-08-12 18:12:50 UTC (rev 5241)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf_audio.cpp	2009-08-14 17:29:18 UTC (rev 5242)
@@ -0,0 +1,192 @@
+/***************************************************************************
+    copyright            : (C) 2006 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &quot;config.h&quot;
+
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+
+#include &lt;string.h&gt;
+
+#include &lt;math.h&gt;
+
+#include &quot;ADM_default.h&quot;
+#include &quot;ADM_editor/ADM_Video.h&quot;
+#include &quot;ADM_assert.h&quot;
+
+#include &quot;fourcc.h&quot;
+
+
+#include &quot;ADM_asf.h&quot;
+
+
+/*
+    __________________________________________________________
+*/
+
+asfAudio::~asfAudio()
+{
+	printf(&quot;[asfAudio] Destroying track\n&quot;);
+
+	fclose(_fd);
+	_fd = NULL;
+
+	delete _wavheader;
+	delete _packet;
+
+	_wavheader = NULL;
+	_packet = NULL;
+}
+/*
+    __________________________________________________________
+*/
+                               
+asfAudio::asfAudio(asfHeader *father,uint32_t myRank)
+{
+  printf(&quot;[asfAudio] Creating track\n&quot;);
+    _myRank=myRank;
+    _father=father;
+    _track=&amp;(_father-&gt;_allAudioTracks[myRank]);
+    
+    _wavheader=new WAVHeader;
+    memcpy(_wavheader,&amp;(_track-&gt;wavHeader),sizeof(WAVHeader));
+    _extraDataLen=_track-&gt;extraDataLen;
+    _extraData= _track-&gt;extraData;
+    _length=_track-&gt;length;
+    _streamId=_track-&gt;streamIndex;
+    _dataStart=_father-&gt;_dataStartOffset;
+    _fd=fopen(_father-&gt;myName,&quot;rb&quot;);
+    ADM_assert(_fd);
+    fseeko(_fd,_dataStart,SEEK_SET);
+    _packetSize=_father-&gt;_packetSize;
+    _packet=new asfPacket(_fd,_father-&gt;_nbPackets,_packetSize,
+                          &amp;readQueue,_dataStart);
+    _destroyable=1;
+    printf(&quot;[asfAudio] Length %u\n&quot;,_length);
+  
+}
+/*
+    __________________________________________________________
+*/
+
+uint32_t            asfAudio::read(uint32_t len,uint8_t *buffer)
+{
+  uint32_t lan,samples;
+  if(!getPacket(      buffer,    &amp;lan, &amp;samples)) return 0;
+  return lan;
+}
+/*
+    __________________________________________________________
+*/
+
+uint8_t   asfAudio::goTo(uint32_t newoffset)
+{
+  // Look into the index until we find the audio
+  // just after the wanted value
+  for(int i=0;i&lt;_father-&gt;nbImage;i++)
+  {
+    if(!_father-&gt;_index[i].audioSeen[_myRank]) continue;
+    if(_father-&gt;_index[i].audioSeen[_myRank]&gt;=newoffset)
+    {
+      // Flush queue
+      _packet-&gt;purge();
+      // Seek
+      if(!_packet-&gt;goToPacket(_father-&gt;_index[i].packetNb))
+      {
+        printf(&quot;[asfAudio] Cannot seek to frame %u\n&quot;,i);
+        return 0; 
+      }
+      printf(&quot;[asfAudio]For audio %u, seeking to packet %u\n&quot;,newoffset,_father-&gt;_index[i].packetNb);
+      _packet-&gt;nextPacket(_streamId);
+      _packet-&gt;skipPacket();
+      return 1;
+    }
+  }
+  printf(&quot;[asfAudio] Seek failed for offset=%u\n&quot;,newoffset);
+  return 1; 
+}
+/*
+    __________________________________________________________
+*/
+
+uint8_t   asfAudio::goToTime(uint32_t newoffset)
+{
+  // Compute the linear version
+  float f;
+  uint32_t val;
+  
+  f=newoffset;
+  f*=_wavheader-&gt;byterate;
+  
+  val=(uint32_t)((f+459.)/1000.);
+  goTo(val);
+  return 1; 
+}
+/*
+    __________________________________________________________
+*/
+
+uint8_t   asfAudio::extraData(uint32_t *l,uint8_t **d)
+{
+  if(_extraData)
+  {
+    *l=_extraDataLen;
+    *d=_extraData;  
+  }
+  else
+  {
+    *l=0;
+    *d=NULL; 
+  }
+  return 1;
+}
+/*
+    __________________________________________________________
+*/
+
+uint8_t  asfAudio::getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples)
+{
+  *len=0;
+  uint32_t delta;
+  uint8_t r;
+  while(1)
+  {
+   
+    while(!readQueue.isEmpty())
+    {
+      asfBit *bit;
+      ADM_assert(readQueue.pop((void**)&amp;bit));
+      printf(&quot;Audio found packet of size %d seq %d\n&quot;,bit-&gt;len,bit-&gt;sequence);
+      
+      // still same sequence ...add
+      memcpy(dest,bit-&gt;data,bit-&gt;len);
+      *len=bit-&gt;len;
+#warning FIXME      
+      *samples=384; // ?
+	  delete[] bit-&gt;data;
+      delete bit;
+      return 1;
+    }
+    r=_packet-&gt;nextPacket(_streamId);
+    _packet-&gt;skipPacket();
+    if(!r)
+    {
+      printf(&quot;[ASF] Audio Packet Error\n&quot;);
+      return 0; 
+    }
+    _packet-&gt;skipPacket();
+  }
+  
+  return 0; 
+}
+//EOF

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/CMakeLists.txt	2009-08-12 18:12:50 UTC (rev 5241)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/CMakeLists.txt	2009-08-14 17:29:18 UTC (rev 5242)
@@ -0,0 +1,4 @@
+SET(ADM_asf_SRCS 
+	ADM_asf_audio.cpp  ADM_asfChunk.cpp  ADM_asf.cpp  ADM_asfPacket.cpp)
+
+ADD_ADM_LIB_ALL_TARGETS(ADM_asf ${ADM_asf_SRCS})
\ No newline at end of file


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002454.html">[Avidemux-svn-commit] r5241 - in	branches/avidemux_2.5_branch_gruntster:	avidemux/ADM_audiocodec plugins/ADM_audioDecoders/ADM_ad_ac3	plugins/ADM_audioDecoders/ADM_ad_faad	plugins/ADM_audioDecoders/ADM_ad_mad	plugins/ADM_audioDecoders/ADM_ad_opencore_amrnb	plugins/ADM_audioDecoders/ADM_ad_opencore_amrwb	plugins/ADM_audioDecoders/ADM_ad_vorbis
</A></li>
	<LI>Next message: <A HREF="002456.html">[Avidemux-svn-commit] r5243 -	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreDemuxerMpeg/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2455">[ date ]</a>
              <a href="thread.html#2455">[ thread ]</a>
              <a href="subject.html#2455">[ subject ]</a>
              <a href="author.html#2455">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
