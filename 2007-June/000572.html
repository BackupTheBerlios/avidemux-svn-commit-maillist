<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r3292 -	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2007-June/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r3292%20-%0A%09branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs&In-Reply-To=%3C200706231431.l5NEVJYk024418%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000571.html">
   <LINK REL="Next"  HREF="000573.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r3292 -	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs</H1>
    <B>mean at BerliOS</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r3292%20-%0A%09branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs&In-Reply-To=%3C200706231431.l5NEVJYk024418%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r3292 -	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs">mean at mail.berlios.de
       </A><BR>
    <I>Sat Jun 23 16:31:19 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000571.html">[Avidemux-svn-commit] r3291 -	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs
</A></li>
        <LI>Next message: <A HREF="000573.html">[Avidemux-svn-commit] r3293 -	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#572">[ date ]</a>
              <a href="thread.html#572">[ thread ]</a>
              <a href="subject.html#572">[ subject ]</a>
              <a href="author.html#572">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2007-06-23 16:31:16 +0200 (Sat, 23 Jun 2007)
New Revision: 3292

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/CMakeLists.txt
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsapi.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsarena.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsarray.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsatom.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsautocfg.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jscntxt.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jscntxt.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsdbgapi.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsdtoa.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsemit.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsfun.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsgc.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsgc.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsinterp.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jslibmath.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jslock.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jslock.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsnum.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsobj.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsobj.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsopcode.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsparse.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsregexp.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsscan.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsscope.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsscope.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsscript.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsstr.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jstypes.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsxml.c
Log:
update smjs to .1

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/CMakeLists.txt
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/CMakeLists.txt	2007-06-23 13:55:23 UTC (rev 3291)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/CMakeLists.txt	2007-06-23 14:31:16 UTC (rev 3292)
@@ -18,8 +18,9 @@
 	add_definitions(-DXP_UNIX -DSVR4 -DSYSV -D_BSD_SOURCE -DPOSIX_SOURCE -DHAVE_VA_COPY -DVA_COPY=va_copy)
 ENDIF(WIN32)
 
-add_definitions(-DNDEBUG -DTRIMMED -DEXPORT_JS_API  -DJS_USE_SAFE_ARENA -D_IEEE_LIBM)
+add_definitions(-DNDEBUG -DTRIMMED -DEXPORT_JS_API  -DJS_USE_SAFE_ARENA -D_IEEE_LIBMi)
+#-DJS_THREADSAFE)
 	add_definitions(-Dmalloc=ADM_alloc)
 	add_definitions(-Drealloc=ADM_realloc)
 	add_definitions(-Dfree=ADM_dezalloc)
-	add_definitions(-Dcalloc=ADM_calloc)
+	add_definitions(-Dcalloc=ADM_calloc -I/usr/include/nspr)

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsapi.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsapi.c	2007-06-23 13:55:23 UTC (rev 3291)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsapi.c	2007-06-23 14:31:16 UTC (rev 3292)
@@ -1064,7 +1064,7 @@
 JS_PUBLIC_API(const char *)
 JS_GetImplementationVersion(void)
 {
-    return &quot;JavaScript-C 1.6 2006-11-19&quot;;
+    return &quot;JavaScript-C 1.6.1 2007-04-01&quot;;
 }
 
 
@@ -1663,12 +1663,7 @@
 JS_PUBLIC_API(void)
 JS_ClearNewbornRoots(JSContext *cx)
 {
-    uintN i;
-
-    for (i = 0; i &lt; GCX_NTYPES; i++)
-        cx-&gt;newborn[i] = NULL;
-    cx-&gt;lastAtom = NULL;
-    cx-&gt;lastInternalResult = JSVAL_NULL;
+    JS_CLEAR_WEAK_ROOTS(&amp;cx-&gt;weakRoots);
 }
 
 JS_PUBLIC_API(JSBool)
@@ -2397,7 +2392,7 @@
         return NULL;
     if (!DefineProperty(cx, obj, name, OBJECT_TO_JSVAL(nobj), NULL, NULL, attrs,
                         0, 0)) {
-        cx-&gt;newborn[GCX_OBJECT] = NULL;
+        cx-&gt;weakRoots.newborn[GCX_OBJECT] = NULL;
         return NULL;
     }
     return nobj;
@@ -3168,16 +3163,13 @@
         /* Native case: just mark the next property to visit. */
         sprop = (JSScopeProperty *) JSVAL_TO_PRIVATE(v);
         if (sprop)
-            MARK_SCOPE_PROPERTY(sprop);
+            MARK_SCOPE_PROPERTY(cx, sprop);
     } else {
         /* Non-native case: mark each id in the JSIdArray private. */
         ida = (JSIdArray *) JSVAL_TO_PRIVATE(v);
         for (i = 0, n = ida-&gt;length; i &lt; n; i++) {
             id = ida-&gt;vector[i];
-            if (JSID_IS_ATOM(id))
-                GC_MARK_ATOM(cx, JSID_TO_ATOM(id), arg);
-            else if (JSID_IS_OBJECT(id))
-                GC_MARK(cx, JSID_TO_OBJECT(id), &quot;id&quot;, arg);
+            MARK_ID(cx, id);
         }
     }
     return 0;
@@ -3234,8 +3226,8 @@
     iterobj-&gt;slots[JSSLOT_ITER_INDEX] = INT_TO_JSVAL(index);
     return iterobj;
 
-bad:
-    cx-&gt;newborn[GCX_OBJECT] = NULL;
+  bad:
+    cx-&gt;weakRoots.newborn[GCX_OBJECT] = NULL;
     return NULL;
 }
 
@@ -3685,7 +3677,7 @@
 #define LAST_FRAME_CHECKS(cx,result)                                          \
     JS_BEGIN_MACRO                                                            \
         if (!(cx)-&gt;fp) {                                                      \
-            (cx)-&gt;lastInternalResult = JSVAL_NULL;                            \
+            (cx)-&gt;weakRoots.lastInternalResult = JSVAL_NULL;                  \
             LAST_FRAME_EXCEPTION_CHECK(cx, result);                           \
         }                                                                     \
     JS_END_MACRO

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsarena.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsarena.c	2007-06-23 13:55:23 UTC (rev 3291)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsarena.c	2007-06-23 14:31:16 UTC (rev 3292)
@@ -106,28 +106,16 @@
  * that (jsuword)(a + 1) is on a pointer boundary.
  *
  * By how much must we pad?  Let M be the alignment modulus for pool and P
- * the modulus for a pointer.  Given M &gt;= P, the greatest distance between a
- * pointer aligned on an M boundary and one aligned on a P boundary is M-P.
- * If M and P are powers of two, then M-P = (pool-&gt;mask - POINTER_MASK).
+ * the modulus for a pointer.  Given M &gt;= P, the base of an oversized arena
+ * that satisfies M is well-aligned for P.
  *
- * How much extra padding might spill over unused into the remainder of the
- * allocation, in the worst case (where M &gt; P)?
+ * On the other hand, if M &lt; P, we must include enough space in the header
+ * size to align the back-pointer on a P boundary so that it can be found by
+ * subtracting P from a-&gt;base.  This means a-&gt;base must be on a P boundary,
+ * even though subsequent allocations from a may be aligned on a lesser (M)
+ * boundary.  Given powers of two M and P as above, the extra space needed
+ * when M &lt; P is P-M or POINTER_MASK - pool-&gt;mask.
  *
- * If we add M-P to the nominal back-pointer address and then round down to
- * align on a P boundary, we will use at most M-P bytes of padding, and at
- * least P (M &gt; P =&gt; M &gt;= 2P; M == 2P gives the least padding, P).  So if we
- * use P bytes of padding, then we will overallocate a by P+M-1 bytes, as we
- * also add M-1 to the estimated size in case malloc returns an odd pointer.
- * a-&gt;limit must include this overestimation to satisfy a-&gt;avail in [a-&gt;base,
- * a-&gt;limit].
- *
- * Similarly, if pool-&gt;mask is less than POINTER_MASK, we must include enough
- * space in the header size to align the back-pointer on a P boundary so that
- * it can be found by subtracting P from a-&gt;base.  This means a-&gt;base must be
- * on a P boundary, even though subsequent allocations from a may be aligned
- * on a lesser (M) boundary.  Given powers of two M and P as above, the extra
- * space needed when P &gt; M is P-M or POINTER_MASK - pool-&gt;mask.
- *
  * The size of a header including padding is given by the HEADER_SIZE macro,
  * below, for any pool (for any value of M).
  *
@@ -143,7 +131,7 @@
 #define HEADER_SIZE(pool)       (sizeof(JSArena **)                           \
                                  + (((pool)-&gt;mask &lt; POINTER_MASK)             \
                                     ? POINTER_MASK - (pool)-&gt;mask             \
-                                    : (pool)-&gt;mask - POINTER_MASK))
+                                    : 0))
 #define HEADER_BASE_MASK(pool)  ((pool)-&gt;mask | POINTER_MASK)
 #define PTR_TO_HEADER(pool,p)   (JS_ASSERT(((jsuword)(p)                      \
                                             &amp; HEADER_BASE_MASK(pool))         \
@@ -253,7 +241,7 @@
 
     JS_ASSERT(a-&gt;base == (jsuword)p);
     boff = JS_UPTRDIFF(a-&gt;base, a);
-    aoff = size + incr;
+    aoff = JS_ARENA_ALIGN(pool, size + incr);
     JS_ASSERT(aoff &gt; pool-&gt;arenasize);
     extra = HEADER_SIZE(pool);                  /* oversized header holds ap */
     hdrsz = sizeof *a + extra + pool-&gt;mask;     /* header and alignment slop */
@@ -282,7 +270,7 @@
 
     a-&gt;base = ((jsuword)a + hdrsz) &amp; ~HEADER_BASE_MASK(pool);
     a-&gt;limit = (jsuword)a + gross;
-    a-&gt;avail = JS_ARENA_ALIGN(pool, a-&gt;base + aoff);
+    a-&gt;avail = a-&gt;base + aoff;
     JS_ASSERT(a-&gt;base &lt;= a-&gt;avail &amp;&amp; a-&gt;avail &lt;= a-&gt;limit);
 
     /* Check whether realloc aligned differently, and copy if necessary. */

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsarray.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsarray.c	2007-06-23 13:55:23 UTC (rev 3291)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsarray.c	2007-06-23 14:31:16 UTC (rev 3292)
@@ -1531,8 +1531,16 @@
         start = js_DoubleToInteger(start);
         if (start &lt; 0) {
             start += length;
-            i = (start &lt; 0) ? 0 : (jsuint)start;
+            if (start &lt; 0) {
+                if (isLast)
+                    goto not_found;
+                i = 0;
+            } else {
+                i = (jsuint)start;
+            }
         } else if (start &gt;= length) {
+            if (!isLast)
+                goto not_found;
             i = length - 1;
         } else {
             i = (jsuint)start;
@@ -1894,7 +1902,7 @@
     if (!obj)
         return NULL;
     if (!InitArrayObject(cx, obj, length, vector)) {
-        cx-&gt;newborn[GCX_OBJECT] = NULL;
+        cx-&gt;weakRoots.newborn[GCX_OBJECT] = NULL;
         return NULL;
     }
     return obj;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsatom.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsatom.c	2007-06-23 13:55:23 UTC (rev 3291)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsatom.c	2007-06-23 14:31:16 UTC (rev 3292)
@@ -534,7 +534,7 @@
 
     atom = (JSAtom *)he;
     atom-&gt;flags |= flags;
-    cx-&gt;lastAtom = atom;
+    cx-&gt;weakRoots.lastAtom = atom;
 out:
     JS_UNLOCK(&amp;state-&gt;lock,cx);
     return atom;
@@ -625,7 +625,7 @@
 
     atom = (JSAtom *)he;
     atom-&gt;flags |= flags;
-    cx-&gt;lastAtom = atom;
+    cx-&gt;weakRoots.lastAtom = atom;
 out:
     JS_UNLOCK(&amp;state-&gt;lock,cx);
     return atom;
@@ -696,7 +696,7 @@
 
     atom = (JSAtom *)he;
     atom-&gt;flags |= flags &amp; (ATOM_PINNED | ATOM_INTERNED | ATOM_HIDDEN);
-    cx-&gt;lastAtom = atom;
+    cx-&gt;weakRoots.lastAtom = atom;
 out:
     JS_UNLOCK(&amp;state-&gt;lock,cx);
     return atom;
@@ -921,8 +921,8 @@
 }
 
 #ifdef DEBUG
-jsrefcount js_atom_map_count;
-jsrefcount js_atom_map_hash_table_count;
+static jsrefcount js_atom_map_count;
+static jsrefcount js_atom_map_hash_table_count;
 #endif
 
 JS_FRIEND_API(JSBool)

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsautocfg.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsautocfg.h	2007-06-23 13:55:23 UTC (rev 3291)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsautocfg.h	2007-06-23 14:31:16 UTC (rev 3292)
@@ -1,57 +1,51 @@
 #ifndef js_cpucfg___
 #define js_cpucfg___
 
-#include &quot;../../../config.h&quot;
+/* AUTOMATICALLY GENERATED - DO NOT EDIT */
 
-
-#ifdef ADM_BIG_ENDIAN
-#undef   IS_LITTLE_ENDIAN 
-#define  IS_BIG_ENDIAN 1
-#else
 #define IS_LITTLE_ENDIAN 1
 #undef  IS_BIG_ENDIAN
-#endif
 
 #define JS_BYTES_PER_BYTE   1L
 #define JS_BYTES_PER_SHORT  2L
 #define JS_BYTES_PER_INT    4L
 #define JS_BYTES_PER_INT64  8L
-#define JS_BYTES_PER_LONG   8L
+#define JS_BYTES_PER_LONG   4L
 #define JS_BYTES_PER_FLOAT  4L
 #define JS_BYTES_PER_DOUBLE 8L
-#define JS_BYTES_PER_WORD   8L
+#define JS_BYTES_PER_WORD   4L
 #define JS_BYTES_PER_DWORD  8L
 
 #define JS_BITS_PER_BYTE    8L
 #define JS_BITS_PER_SHORT   16L
 #define JS_BITS_PER_INT     32L
 #define JS_BITS_PER_INT64   64L
-#define JS_BITS_PER_LONG    64L
+#define JS_BITS_PER_LONG    32L
 #define JS_BITS_PER_FLOAT   32L
 #define JS_BITS_PER_DOUBLE  64L
-#define JS_BITS_PER_WORD    64L
+#define JS_BITS_PER_WORD    32L
 
 #define JS_BITS_PER_BYTE_LOG2   3L
 #define JS_BITS_PER_SHORT_LOG2  4L
 #define JS_BITS_PER_INT_LOG2    5L
 #define JS_BITS_PER_INT64_LOG2  6L
-#define JS_BITS_PER_LONG_LOG2   6L
+#define JS_BITS_PER_LONG_LOG2   5L
 #define JS_BITS_PER_FLOAT_LOG2  5L
 #define JS_BITS_PER_DOUBLE_LOG2 6L
-#define JS_BITS_PER_WORD_LOG2   6L
+#define JS_BITS_PER_WORD_LOG2   5L
 
 #define JS_ALIGN_OF_SHORT   2L
 #define JS_ALIGN_OF_INT     4L
-#define JS_ALIGN_OF_LONG    8L
-#define JS_ALIGN_OF_INT64   8L
+#define JS_ALIGN_OF_LONG    4L
+#define JS_ALIGN_OF_INT64   4L
 #define JS_ALIGN_OF_FLOAT   4L
-#define JS_ALIGN_OF_DOUBLE  8L
-#define JS_ALIGN_OF_POINTER 8L
-#define JS_ALIGN_OF_WORD    8L
+#define JS_ALIGN_OF_DOUBLE  4L
+#define JS_ALIGN_OF_POINTER 4L
+#define JS_ALIGN_OF_WORD    4L
 
-#define JS_BYTES_PER_WORD_LOG2   3L
+#define JS_BYTES_PER_WORD_LOG2   2L
 #define JS_BYTES_PER_DWORD_LOG2  3L
-#define JS_WORDS_PER_DWORD_LOG2  0L
+#define JS_WORDS_PER_DWORD_LOG2  1L
 
 #define JS_STACK_GROWTH_DIRECTION (-1)
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jscntxt.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jscntxt.c	2007-06-23 13:55:23 UTC (rev 3291)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jscntxt.c	2007-06-23 14:31:16 UTC (rev 3292)
@@ -60,6 +60,7 @@
 #include &quot;jsobj.h&quot;
 #include &quot;jsopcode.h&quot;
 #include &quot;jsscan.h&quot;
+#include &quot;jsscope.h&quot;
 #include &quot;jsscript.h&quot;
 #include &quot;jsstr.h&quot;
 
@@ -942,9 +943,12 @@
 
 error:
     if (reportp-&gt;messageArgs) {
-        i = 0;
-        while (reportp-&gt;messageArgs[i])
-            JS_free(cx, (void *)reportp-&gt;messageArgs[i++]);
+        /* free the arguments only if we allocated them */
+        if (charArgs) {
+            i = 0;
+            while (reportp-&gt;messageArgs[i])
+                JS_free(cx, (void *)reportp-&gt;messageArgs[i++]);
+        }
         JS_free(cx, (void *)reportp-&gt;messageArgs);
         reportp-&gt;messageArgs = NULL;
     }

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jscntxt.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jscntxt.h	2007-06-23 13:55:23 UTC (rev 3291)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jscntxt.h	2007-06-23 14:31:16 UTC (rev 3292)
@@ -234,10 +234,16 @@
     /* Optional hook to find principals for an object in this runtime. */
     JSObjectPrincipalsFinder findObjectPrincipals;
 
-    /* Shared scope property tree, and allocator for its nodes. */
+    /*
+     * Shared scope property tree, and arena-pool for allocating its nodes.
+     * The propertyRemovals counter is incremented for every js_ClearScope,
+     * and for each js_RemoveScopeProperty that frees a slot in an object.
+     * See js_NativeGet and js_NativeSet in jsobj.c.
+     */
     JSDHashTable        propertyTreeHash;
     JSScopeProperty     *propertyFreeList;
     JSArenaPool         propertyArenaPool;
+    int32               propertyRemovals;
 
     /* Script filename table. */
     struct JSHashTable  *scriptFilenameTable;
@@ -383,30 +389,36 @@
     jsval               value;
     JSObject            *object;
     JSTempValueMarker   marker;
+    JSScopeProperty     *sprop;
+    JSWeakRoots         *weakRoots;
     jsval               *array;
 } JSTempValueUnion;
 
 /*
  * Context-linked stack of temporary GC roots.
  *
- * If count is -1, then u.value contains the single value to root.
- * If count is -2, then u.marker holds a mark hook that is executed to mark
- * the values.
+ * If count is -1, then u.value contains the single value or GC-thing to root.
+ * If count is -2, then u.marker holds a mark hook called to mark the values.
+ * If count is -3, then u.sprop points to the property tree node to mark.
+ * If count is -4, then u.weakRoots points to saved weak roots.
  * If count &gt;= 0, then u.array points to a stack-allocated vector of jsvals.
  *
  * To root a single GC-thing pointer, which need not be tagged and stored as a
- * jsval, use JS_PUSH_SINGLE_TEMP_ROOT.  The (jsval)(val) cast works because a
- * GC-thing is aligned on a 0 mod 8 boundary, and object has the 0 jsval tag.
- * So any GC-thing may be tagged as if it were an object and untagged, if it's
- * then used only as an opaque pointer until discriminated by other means than
- * tag bits (this is how the GC mark function uses its |thing| parameter -- it
- * consults GC-thing flags stored separately from the thing to decide the type
- * of thing).
+ * jsval, use JS_PUSH_TEMP_ROOT_GCTHING. The macro reinterprets an arbitrary
+ * GC-thing as jsval. It works because a GC-thing is aligned on a 0 mod 8
+ * boundary, and object has the 0 jsval tag. So any GC-thing may be tagged as
+ * if it were an object and untagged, if it's then used only as an opaque
+ * pointer until discriminated by other means than tag bits (this is how the
+ * GC mark function uses its |thing| parameter -- it consults GC-thing flags
+ * stored separately from the thing to decide the type of thing).
  *
- * Alternatively, if a single pointer to rooted JSObject * is required, use
- * JS_PUSH_TEMP_ROOT_OBJECT(cx, NULL, &amp;tvr). Then &amp;tvr.u.object gives the
- * necessary pointer, which puns tvr.u.value safely because object tag bits
- * are all zeroes.
+ * JS_PUSH_TEMP_ROOT_OBJECT and JS_PUSH_TEMP_ROOT_STRING are type-safe
+ * alternatives to JS_PUSH_TEMP_ROOT_GCTHING for JSObject and JSString. They
+ * also provide a simple way to get a single pointer to rooted JSObject or
+ * JSString via JS_PUSH_TEMP_ROOT_(OBJECT|STRTING)(cx, NULL, &amp;tvr). Then
+ * &amp;tvr.u.object or tvr.u.string gives the necessary pointer, which puns
+ * tvr.u.value safely because JSObject * and JSString * are GC-things and, as
+ * such, their tag bits are all zeroes.
  *
  * If you need to protect a result value that flows out of a C function across
  * several layers of other functions, use the js_LeaveLocalRootScopeWithResult
@@ -418,6 +430,11 @@
     JSTempValueUnion    u;
 };
 
+#define JSTVU_SINGLE        (-1)
+#define JSTVU_MARKER        (-2)
+#define JSTVU_SPROP         (-3)
+#define JSTVU_WEAK_ROOTS    (-4)
+
 #define JS_PUSH_TEMP_ROOT_COMMON(cx,tvr)                                      \
     JS_BEGIN_MACRO                                                            \
         JS_ASSERT((cx)-&gt;tempValueRooters != (tvr));                           \
@@ -427,33 +444,48 @@
 
 #define JS_PUSH_SINGLE_TEMP_ROOT(cx,val,tvr)                                  \
     JS_BEGIN_MACRO                                                            \
+        (tvr)-&gt;count = JSTVU_SINGLE;                                          \
+        (tvr)-&gt;u.value = val;                                                 \
         JS_PUSH_TEMP_ROOT_COMMON(cx, tvr);                                    \
-        (tvr)-&gt;count = -1;                                                    \
-        (tvr)-&gt;u.value = (val);                                               \
     JS_END_MACRO
 
 #define JS_PUSH_TEMP_ROOT(cx,cnt,arr,tvr)                                     \
     JS_BEGIN_MACRO                                                            \
-        JS_PUSH_TEMP_ROOT_COMMON(cx, tvr);                                    \
         JS_ASSERT((ptrdiff_t)(cnt) &gt;= 0);                                     \
         (tvr)-&gt;count = (ptrdiff_t)(cnt);                                      \
         (tvr)-&gt;u.array = (arr);                                               \
+        JS_PUSH_TEMP_ROOT_COMMON(cx, tvr);                                    \
     JS_END_MACRO
 
 #define JS_PUSH_TEMP_ROOT_MARKER(cx,marker_,tvr)                              \
     JS_BEGIN_MACRO                                                            \
+        (tvr)-&gt;count = JSTVU_MARKER;                                          \
+        (tvr)-&gt;u.marker = (marker_);                                          \
         JS_PUSH_TEMP_ROOT_COMMON(cx, tvr);                                    \
-        (tvr)-&gt;count = -2;                                                    \
-        (tvr)-&gt;u.marker = (marker_);                                          \
     JS_END_MACRO
 
 #define JS_PUSH_TEMP_ROOT_OBJECT(cx,obj,tvr)                                  \
     JS_BEGIN_MACRO                                                            \
+        (tvr)-&gt;count = JSTVU_SINGLE;                                          \
+        (tvr)-&gt;u.object = (obj);                                              \
         JS_PUSH_TEMP_ROOT_COMMON(cx, tvr);                                    \
-        (tvr)-&gt;count = -1;                                                    \
-        (tvr)-&gt;u.object = (obj);                                              \
     JS_END_MACRO
 
+#define JS_PUSH_TEMP_ROOT_STRING(cx,str,tvr)                                  \
+    JS_BEGIN_MACRO                                                            \
+        (tvr)-&gt;count = JSTVU_SINGLE;                                          \
+        (tvr)-&gt;u.string = (str);                                              \
+        JS_PUSH_TEMP_ROOT_COMMON(cx, tvr);                                    \
+    JS_END_MACRO
+
+#define JS_PUSH_TEMP_ROOT_GCTHING(cx,thing,tvr)                               \
+    JS_BEGIN_MACRO                                                            \
+        JS_ASSERT(JSVAL_IS_OBJECT((jsval)thing));                             \
+        (tvr)-&gt;count = JSTVU_SINGLE;                                          \
+        (tvr)-&gt;u.gcthing = (thing);                                           \
+        JS_PUSH_TEMP_ROOT_COMMON(cx, tvr);                                    \
+    JS_END_MACRO
+
 #define JS_POP_TEMP_ROOT(cx,tvr)                                              \
     JS_BEGIN_MACRO                                                            \
         JS_ASSERT((cx)-&gt;tempValueRooters == (tvr));                           \
@@ -468,6 +500,20 @@
         JS_POP_TEMP_ROOT(cx, &amp;tvr);                                           \
     JS_END_MACRO
 
+#define JS_PUSH_TEMP_ROOT_SPROP(cx,sprop_,tvr)                                \
+    JS_BEGIN_MACRO                                                            \
+        (tvr)-&gt;count = JSTVU_SPROP;                                           \
+        (tvr)-&gt;u.sprop = (sprop_);                                            \
+        JS_PUSH_TEMP_ROOT_COMMON(cx, tvr);                                    \
+    JS_END_MACRO
+
+#define JS_PUSH_TEMP_ROOT_WEAK_COPY(cx,weakRoots_,tvr)                        \
+    JS_BEGIN_MACRO                                                            \
+        (tvr)-&gt;count = JSTVU_WEAK_ROOTS;                                      \
+        (tvr)-&gt;u.weakRoots = (weakRoots_);                                    \
+        JS_PUSH_TEMP_ROOT_COMMON(cx, tvr);                                    \
+    JS_END_MACRO
+
 struct JSContext {
     JSCList             links;
 
@@ -495,15 +541,9 @@
     /* Top-level object and pointer to top stack frame's scope chain. */
     JSObject            *globalObject;
 
-    /* Most recently created things by type, members of the GC's root set. */
-    JSGCThing           *newborn[GCX_NTYPES];
+    /* Storage to root recently allocated GC things and script result. */
+    JSWeakRoots         weakRoots;
 
-    /* Atom root for the last-looked-up atom on this context. */
-    JSAtom              *lastAtom;
-
-    /* Root for the result of the most recent js_InternalInvoke call. */
-    jsval               lastInternalResult;
-
     /* Regular expression class statics (XXX not shared globally). */
     JSRegExpStatics     regExpStatics;
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsdbgapi.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsdbgapi.c	2007-06-23 13:55:23 UTC (rev 3291)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsdbgapi.c	2007-06-23 14:31:16 UTC (rev 3292)
@@ -246,17 +246,24 @@
     JSPropertyOp        setter;
     JSWatchPointHandler handler;
     void                *closure;
-    jsrefcount          nrefs;
+    uintN               flags;
 } JSWatchPoint;
 
-#define HoldWatchPoint(wp) ((wp)-&gt;nrefs++)
+#define JSWP_LIVE       0x1             /* live because set and not cleared */
+#define JSWP_HELD       0x2             /* held while running handler/setter */
 
 static JSBool
-DropWatchPoint(JSContext *cx, JSWatchPoint *wp)
+DropWatchPoint(JSContext *cx, JSWatchPoint *wp, uintN flag)
 {
+    JSBool ok;
     JSScopeProperty *sprop;
+    JSObject *pobj;
+    JSProperty *prop;
+    JSPropertyOp setter;
 
-    if (--wp-&gt;nrefs != 0)
+    ok = JS_TRUE;
+    wp-&gt;flags &amp;= ~flag;
+    if (wp-&gt;flags != 0)
         return JS_TRUE;
 
     /*
@@ -265,16 +272,38 @@
      */
     JS_REMOVE_LINK(&amp;wp-&gt;links);
     sprop = wp-&gt;sprop;
-    if (!js_GetWatchedSetter(cx-&gt;runtime, NULL, sprop)) {
-        sprop = js_ChangeNativePropertyAttrs(cx, wp-&gt;object, sprop,
-                                             0, sprop-&gt;attrs,
-                                             sprop-&gt;getter, wp-&gt;setter);
-        if (!sprop)
-            return JS_FALSE;
+
+    /*
+     * If js_ChangeNativePropertyAttrs fails, propagate failure after removing
+     * wp-&gt;closure's root and freeing wp.
+     */
+    setter = js_GetWatchedSetter(cx-&gt;runtime, NULL, sprop);
+    if (!setter) {
+        ok = js_LookupProperty(cx, wp-&gt;object, sprop-&gt;id, &amp;pobj, &amp;prop);
+
+        /*
+         * If the property wasn't found on wp-&gt;object or didn't exist, then
+         * someone else has dealt with this sprop, and we don't need to change
+         * the property attributes.
+         */
+        if (ok &amp;&amp; prop) {
+            if (pobj == wp-&gt;object) {
+                JS_ASSERT(OBJ_SCOPE(pobj)-&gt;object == pobj);
+
+                sprop = js_ChangeScopePropertyAttrs(cx, OBJ_SCOPE(pobj), sprop,
+                                                    0, sprop-&gt;attrs,
+                                                    sprop-&gt;getter,
+                                                    wp-&gt;setter);
+                if (!sprop)
+                    ok = JS_FALSE;
+            }
+            OBJ_DROP_PROPERTY(cx, pobj, prop);
+        }
     }
+
     js_RemoveRoot(cx-&gt;runtime, &amp;wp-&gt;closure);
     JS_free(cx, wp);
-    return JS_TRUE;
+    return ok;
 }
 
 void
@@ -287,7 +316,7 @@
     for (wp = (JSWatchPoint *)rt-&gt;watchPointList.next;
          wp != (JSWatchPoint *)&amp;rt-&gt;watchPointList;
          wp = (JSWatchPoint *)wp-&gt;links.next) {
-        MARK_SCOPE_PROPERTY(wp-&gt;sprop);
+        MARK_SCOPE_PROPERTY(cx, wp-&gt;sprop);
         if (wp-&gt;sprop-&gt;attrs &amp; JSPROP_SETTER)
             JS_MarkGCThing(cx, wp-&gt;setter, &quot;wp-&gt;setter&quot;, NULL);
     }
@@ -348,7 +377,10 @@
          wp != (JSWatchPoint *)&amp;rt-&gt;watchPointList;
          wp = (JSWatchPoint *)wp-&gt;links.next) {
         sprop = wp-&gt;sprop;
-        if (wp-&gt;object == obj &amp;&amp; SPROP_USERID(sprop) == id) {
+        if (wp-&gt;object == obj &amp;&amp; SPROP_USERID(sprop) == id &amp;&amp;
+            !(wp-&gt;flags &amp; JSWP_HELD)) {
+            wp-&gt;flags |= JSWP_HELD;
+
             JS_LOCK_OBJ(cx, obj);
             propid = ID_TO_VALUE(sprop-&gt;id);
             userid = (sprop-&gt;flags &amp; SPROP_HAS_SHORTID)
@@ -356,10 +388,11 @@
                      : propid;
             scope = OBJ_SCOPE(obj);
             JS_UNLOCK_OBJ(cx, obj);
-            HoldWatchPoint(wp);
+
+            /* NB: wp is held, so we can safely dereference it still. */
             ok = wp-&gt;handler(cx, obj, propid,
                              SPROP_HAS_VALID_SLOT(sprop, scope)
-                             ? OBJ_GET_SLOT(cx, obj, wp-&gt;sprop-&gt;slot)
+                             ? OBJ_GET_SLOT(cx, obj, sprop-&gt;slot)
                              : JSVAL_VOID,
                              vp, wp-&gt;closure);
             if (ok) {
@@ -402,7 +435,7 @@
                 } else {
                     argv = JS_malloc(cx, nslots * sizeof(jsval));
                     if (!argv) {
-                        DropWatchPoint(cx, wp);
+                        DropWatchPoint(cx, wp, JSWP_HELD);
                         return JS_FALSE;
                     }
                 }
@@ -430,11 +463,10 @@
                 if (argv != smallv)
                     JS_free(cx, argv);
             }
-            return DropWatchPoint(cx, wp);
+            return DropWatchPoint(cx, wp, JSWP_HELD) &amp;&amp; ok;
         }
     }
-    JS_ASSERT(0);       /* XXX can't happen */
-    return JS_FALSE;
+    return JS_TRUE;
 }
 
 JSBool JS_DLL_CALLBACK
@@ -589,21 +621,26 @@
         wp-&gt;object = obj;
         JS_ASSERT(sprop-&gt;setter != js_watch_set || pobj != obj);
         wp-&gt;setter = sprop-&gt;setter;
-        wp-&gt;nrefs = 1;
+        wp-&gt;flags = JSWP_LIVE;
 
         /* XXXbe nest in obj lock here */
         sprop = js_ChangeNativePropertyAttrs(cx, obj, sprop, 0, sprop-&gt;attrs,
                                              sprop-&gt;getter, watcher);
         if (!sprop) {
-            /* Self-link wp-&gt;links so DropWatchPoint can JS_REMOVE_LINK it. */
+            /* Self-link so DropWatchPoint can JS_REMOVE_LINK it. */
             JS_INIT_CLIST(&amp;wp-&gt;links);
-            DropWatchPoint(cx, wp);
+            DropWatchPoint(cx, wp, JSWP_LIVE);
             ok = JS_FALSE;
             goto out;
         }
         wp-&gt;sprop = sprop;
 
-        /* Now that wp is fully initialized, append it to rt's wp list. */
+        /*
+         * Now that wp is fully initialized, append it to rt's wp list.
+         * Because obj is locked we know that no other thread could have added
+         * a watchpoint for (obj, propid).
+         */
+        JS_ASSERT(!FindWatchPoint(rt, OBJ_SCOPE(obj), propid));
         JS_APPEND_LINK(&amp;wp-&gt;links, &amp;rt-&gt;watchPointList);
     }
     wp-&gt;handler = handler;
@@ -630,7 +667,7 @@
                 *handlerp = wp-&gt;handler;
             if (closurep)
                 *closurep = wp-&gt;closure;
-            return DropWatchPoint(cx, wp);
+            return DropWatchPoint(cx, wp, JSWP_LIVE);
         }
     }
     if (handlerp)
@@ -651,7 +688,7 @@
          wp != (JSWatchPoint *)&amp;rt-&gt;watchPointList;
          wp = next) {
         next = (JSWatchPoint *)wp-&gt;links.next;
-        if (wp-&gt;object == obj &amp;&amp; !DropWatchPoint(cx, wp))
+        if (wp-&gt;object == obj &amp;&amp; !DropWatchPoint(cx, wp, JSWP_LIVE))
             return JS_FALSE;
     }
     return JS_TRUE;
@@ -668,7 +705,7 @@
          wp != (JSWatchPoint *)&amp;rt-&gt;watchPointList;
          wp = next) {
         next = (JSWatchPoint *)wp-&gt;links.next;
-        if (!DropWatchPoint(cx, wp))
+        if (!DropWatchPoint(cx, wp, JSWP_LIVE))
             return JS_FALSE;
     }
     return JS_TRUE;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsdtoa.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsdtoa.c	2007-06-23 13:55:23 UTC (rev 3291)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsdtoa.c	2007-06-23 14:31:16 UTC (rev 3292)
@@ -1360,16 +1360,16 @@
               case 'i':
               case 'I':
                 if (match(&amp;s,&quot;nfinity&quot;)) {
-                    word0(rv) = 0x7ff00000;
-                    word1(rv) = 0;
+                    set_word0(rv, 0x7ff00000);
+                    set_word1(rv, 0);
                     goto ret;
                     }
                 break;
               case 'n':
               case 'N':
                 if (match(&amp;s, &quot;an&quot;)) {
-                    word0(rv) = NAN_WORD0;
-                    word1(rv) = NAN_WORD1;
+                    set_word0(rv, NAN_WORD0);
+                    set_word1(rv, NAN_WORD1);
                     goto ret;
                     }
               }
@@ -1439,8 +1439,8 @@
                 rv = HUGE_VAL;
 #else
                 /* Can't trust HUGE_VAL */
-                word0(rv) = Exp_mask;
-                word1(rv) = 0;
+                set_word0(rv, Exp_mask);
+                set_word1(rv, 0);
 #endif
                 if (bd0)
                     goto retfree;
@@ -1864,6 +1864,7 @@
     Bfree(bs);
     Bfree(bd0);
     Bfree(delta);
+    RELEASE_DTOA_LOCK();
     *err = JS_DTOA_ENOMEM;
     return 0;
 }
@@ -2970,6 +2971,8 @@
             if (!b) {
               nomem1:
                 Bfree(b);
+                RELEASE_DTOA_LOCK();
+                free(buffer);
                 return NULL;
             }
             do {
@@ -3004,6 +3007,8 @@
                 if (mlo != mhi)
                     Bfree(mlo);
                 Bfree(mhi);
+                RELEASE_DTOA_LOCK();
+                free(buffer);
                 return NULL;
             }
             JS_ASSERT(e &lt; 0);

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsemit.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsemit.c	2007-06-23 13:55:23 UTC (rev 3291)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsemit.c	2007-06-23 14:31:16 UTC (rev 3292)
@@ -805,7 +805,9 @@
                       case JSOP_DEFAULT:      op = JSOP_DEFAULTX; break;
                       case JSOP_TABLESWITCH:  op = JSOP_TABLESWITCHX; break;
                       case JSOP_LOOKUPSWITCH: op = JSOP_LOOKUPSWITCHX; break;
-                      default:                JS_ASSERT(0);
+                      default:
+                        ReportStatementTooLarge(cx, cg);
+                        return JS_FALSE;
                     }
                     *pc = (jsbytecode) op;
 
@@ -1651,11 +1653,16 @@
     if (atomIndex &gt;= JS_BIT(16)) {
         mode = (js_CodeSpec[op].format &amp; JOF_MODEMASK);
         if (op != JSOP_SETNAME) {
-            prefixOp = (mode == JOF_NAME)
+            prefixOp = ((mode != JOF_NAME &amp;&amp; mode != JOF_PROP) ||
+#if JS_HAS_XML_SUPPORT
+                        op == JSOP_GETMETHOD ||
+                        op == JSOP_SETMETHOD ||
+#endif
+                        op == JSOP_SETCONST)
+                       ? JSOP_LITOPX
+                       : (mode == JOF_NAME)
                        ? JSOP_FINDNAME
-                       : (mode == JOF_PROP)
-                       ? JSOP_LITERAL
-                       : JSOP_LITOPX;
+                       : JSOP_LITERAL;
             off = js_EmitN(cx, cg, prefixOp, 3);
             if (off &lt; 0)
                 return JS_FALSE;
@@ -1683,7 +1690,19 @@
           case JSOP_BINDNAME:   return JS_TRUE;
           case JSOP_SETNAME:    op = JSOP_SETELEM; break;
           case JSOP_SETPROP:    op = JSOP_SETELEM; break;
-          default:              JS_ASSERT(mode == 0); break;
+#if JS_HAS_EXPORT_IMPORT
+          case JSOP_EXPORTNAME:
+            ReportStatementTooLarge(cx, cg);
+            return JS_FALSE;
+#endif
+          default:
+#if JS_HAS_XML_SUPPORT
+            JS_ASSERT(mode == 0 || op == JSOP_SETCONST ||
+                      op == JSOP_GETMETHOD || op == JSOP_SETMETHOD);
+#else
+            JS_ASSERT(mode == 0 || op == JSOP_SETCONST);
+#endif
+            break;
         }
 
         return js_Emit1(cx, cg, op) &gt;= 0;
@@ -2489,6 +2508,15 @@
             tableLength = (uint32)(high - low + 1);
             if (tableLength &gt;= JS_BIT(16) || tableLength &gt; 2 * caseCount)
                 switchOp = JSOP_LOOKUPSWITCH;
+        } else if (switchOp == JSOP_LOOKUPSWITCH) {
+            /*
+             * Lookup switch supports only atom indexes below 64K limit.
+             * Conservatively estimate the maximum possible index during
+             * switch generation and use conditional switch if it exceeds
+             * the limit.
+             */
+            if (caseCount + cg-&gt;atomList.count &gt; JS_BIT(16))
+                switchOp = JSOP_CONDSWITCH;
         }
     }
 
@@ -4088,7 +4116,7 @@
          */
         pn2 = pn-&gt;pn_left;
         JS_ASSERT(pn2-&gt;pn_type != TOK_RP);
-        atomIndex = (jsatomid) -1; /* Suppress warning. */
+        atomIndex = (jsatomid) -1;
         switch (pn2-&gt;pn_type) {
           case TOK_NAME:
             if (!LookupArgOrVar(cx, &amp;cg-&gt;treeContext, pn2))
@@ -4141,6 +4169,10 @@
 #if JS_HAS_GETTER_SETTER
         if (op == JSOP_GETTER || op == JSOP_SETTER) {
             /* We'll emit these prefix bytecodes after emitting the r.h.s. */
+            if (atomIndex != (jsatomid) -1 &amp;&amp; atomIndex &gt;= JS_BIT(16)) {
+                ReportStatementTooLarge(cx, cg);
+                return JS_FALSE;
+            }
         } else
 #endif
         /* If += or similar, dup the left operand and get its value. */
@@ -4706,6 +4738,11 @@
 #if JS_HAS_GETTER_SETTER
             op = pn2-&gt;pn_op;
             if (op == JSOP_GETTER || op == JSOP_SETTER) {
+                if (pn3-&gt;pn_type != TOK_NUMBER &amp;&amp;
+                    ALE_INDEX(ale) &gt;= JS_BIT(16)) {
+                    ReportStatementTooLarge(cx, cg);
+                    return JS_FALSE;
+                }
                 if (js_Emit1(cx, cg, op) &lt; 0)
                     return JS_FALSE;
             }

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsfun.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsfun.c	2007-06-23 13:55:23 UTC (rev 3291)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsfun.c	2007-06-23 14:31:16 UTC (rev 3292)
@@ -248,7 +248,7 @@
     /* Link the new object to fp so it can get actual argument values. */
     argsobj = js_NewObject(cx, &amp;js_ArgumentsClass, NULL, NULL);
     if (!argsobj || !JS_SetPrivate(cx, argsobj, fp)) {
-        cx-&gt;newborn[GCX_OBJECT] = NULL;
+        cx-&gt;weakRoots.newborn[GCX_OBJECT] = NULL;
         return NULL;
     }
     fp-&gt;argsobj = argsobj;
@@ -565,7 +565,7 @@
     /* Create the call object and link it to its stack frame. */
     callobj = js_NewObject(cx, &amp;js_CallClass, NULL, parent);
     if (!callobj || !JS_SetPrivate(cx, callobj, fp)) {
-        cx-&gt;newborn[GCX_OBJECT] = NULL;
+        cx-&gt;weakRoots.newborn[GCX_OBJECT] = NULL;
         return NULL;
     }
     fp-&gt;callobj = callobj;
@@ -1094,7 +1094,7 @@
                  * root until then to protect pval in case it is figuratively
                  * up in the air, with no strong refs protecting it.
                  */
-                cx-&gt;newborn[GCX_OBJECT] = JSVAL_TO_GCTHING(pval);
+                cx-&gt;weakRoots.newborn[GCX_OBJECT] = JSVAL_TO_GCTHING(pval);
                 parentProto = JSVAL_TO_OBJECT(pval);
             }
         }
@@ -1125,7 +1125,7 @@
          */
         if (!js_SetClassPrototype(cx, obj, proto,
                                   JSPROP_ENUMERATE | JSPROP_PERMANENT)) {
-            cx-&gt;newborn[GCX_OBJECT] = NULL;
+            cx-&gt;weakRoots.newborn[GCX_OBJECT] = NULL;
             return JS_FALSE;
         }
         *objp = obj;
@@ -1233,6 +1233,20 @@
         goto bad;
     }
 
+    if (xdr-&gt;mode == JSXDR_DECODE) {
+        fun-&gt;interpreted = JS_TRUE;
+        fun-&gt;flags = (uint8) flagsword;
+        fun-&gt;nregexps = (uint16) (flagsword &gt;&gt; 16);
+
+        *objp = fun-&gt;object;
+        if (atomstr) {
+            /* XXX only if this was a top-level function! */
+            fun-&gt;atom = js_AtomizeString(cx, atomstr, 0);
+            if (!fun-&gt;atom)
+                goto bad;
+        }
+    }
+
     /* do arguments and local vars */
     if (fun-&gt;object) {
         n = fun-&gt;nargs + fun-&gt;nvars;
@@ -1338,21 +1352,8 @@
     if (!js_XDRScript(xdr, &amp;fun-&gt;u.script, NULL))
         goto bad;
 
-    if (xdr-&gt;mode == JSXDR_DECODE) {
-        fun-&gt;interpreted = JS_TRUE;
-        fun-&gt;flags = (uint8) flagsword;
-        fun-&gt;nregexps = (uint16) (flagsword &gt;&gt; 16);
-
-        *objp = fun-&gt;object;
-        if (atomstr) {
-            /* XXX only if this was a top-level function! */
-            fun-&gt;atom = js_AtomizeString(cx, atomstr, 0);
-            if (!fun-&gt;atom)
-                goto bad;
-        }
-
+    if (xdr-&gt;mode == JSXDR_DECODE)
         js_CallNewScriptHook(cx, fun-&gt;u.script, fun);
-    }
 
 out:
     JS_POP_TEMP_ROOT(cx, &amp;tvr);
@@ -2020,7 +2021,7 @@
     return proto;
 
 bad:
-    cx-&gt;newborn[GCX_OBJECT] = NULL;
+    cx-&gt;weakRoots.newborn[GCX_OBJECT] = NULL;
     return NULL;
 }
 
@@ -2065,7 +2066,7 @@
 
     /*
      * Allocate fun after allocating funobj so slot allocation in js_NewObject
-     * does not wipe out fun from cx-&gt;newborn[GCX_PRIVATE].
+     * does not wipe out fun from newborn[GCX_PRIVATE].
      */
     fun = (JSFunction *) js_NewGCThing(cx, GCX_PRIVATE, sizeof(JSFunction));
     if (!fun)
@@ -2087,7 +2088,7 @@
 
     /* Link fun to funobj and vice versa. */
     if (!js_LinkFunctionObject(cx, fun, funobj)) {
-        cx-&gt;newborn[GCX_OBJECT] = NULL;
+        cx-&gt;weakRoots.newborn[GCX_OBJECT] = NULL;
         fun = NULL;
     }
 
@@ -2108,7 +2109,7 @@
         return NULL;
     fun = (JSFunction *) JS_GetPrivate(cx, funobj);
     if (!js_LinkFunctionObject(cx, fun, newfunobj)) {
-        cx-&gt;newborn[GCX_OBJECT] = NULL;
+        cx-&gt;weakRoots.newborn[GCX_OBJECT] = NULL;
         return NULL;
     }
     return newfunobj;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsgc.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsgc.c	2007-06-23 13:55:23 UTC (rev 3291)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsgc.c	2007-06-23 14:31:16 UTC (rev 3292)
@@ -648,8 +648,8 @@
     lrs = cx-&gt;localRootStack;
     if (lrs) {
         /*
-         * If we're in a local root scope, don't set cx-&gt;newborn[type] at all,
-         * to avoid entraining garbage from it for an unbounded amount of time
+         * If we're in a local root scope, don't set newborn[type] at all, to
+         * avoid entraining garbage from it for an unbounded amount of time
          * on this context.  A caller will leave the local root scope and pop
          * this reference, allowing thing to be GC'd if it has no other refs.
          * See JS_EnterLocalRootScope and related APIs.
@@ -670,7 +670,7 @@
          * No local root scope, so we're stuck with the old, fragile model of
          * depending on a pigeon-hole newborn per type per context.
          */
-        cx-&gt;newborn[flags &amp; GCF_TYPEMASK] = thing;
+        cx-&gt;weakRoots.newborn[flags &amp; GCF_TYPEMASK] = thing;
     }
 
     /* We can't fail now, so update flags and rt-&gt;gc{,Private}Bytes. */
@@ -682,7 +682,7 @@
 
     /*
      * Clear thing before unlocking in case a GC run is about to scan it,
-     * finding it via cx-&gt;newborn[].
+     * finding it via newborn[].
      */
     thing-&gt;next = NULL;
     thing-&gt;flagp = NULL;
@@ -1506,11 +1506,7 @@
 void
 js_ForceGC(JSContext *cx, uintN gcflags)
 {
-    uintN i;
-
-    for (i = 0; i &lt; GCX_NTYPES; i++)
-        cx-&gt;newborn[i] = NULL;
-    cx-&gt;lastAtom = NULL;
+    JS_CLEAR_WEAK_ROOTS(&amp;cx-&gt;weakRoots);
     cx-&gt;runtime-&gt;gcPoke = JS_TRUE;
     js_GC(cx, gcflags);
     JS_ArenaFinish();
@@ -1527,6 +1523,23 @@
         }                                                                     \
     JS_END_MACRO
 
+static void
+MarkWeakRoots(JSContext *cx, JSWeakRoots *wr)
+{
+    uintN i;
+    void *thing;
+
+    for (i = 0; i &lt; GCX_NTYPES; i++)
+        GC_MARK(cx, wr-&gt;newborn[i], gc_typenames[i], NULL);
+    if (wr-&gt;lastAtom)
+        GC_MARK_ATOM(cx, wr-&gt;lastAtom, NULL);
+    if (JSVAL_IS_GCTHING(wr-&gt;lastInternalResult)) {
+        thing = JSVAL_TO_GCTHING(wr-&gt;lastInternalResult);
+        if (thing)
+            GC_MARK(cx, thing, &quot;lastInternalResult&quot;, NULL);
+    }
+}
+
 void
 js_GC(JSContext *cx, uintN gcflags)
 {
@@ -1780,18 +1793,17 @@
 
         /* Mark other roots-by-definition in acx. */
         GC_MARK(cx, acx-&gt;globalObject, &quot;global object&quot;, NULL);
-        for (i = 0; i &lt; GCX_NTYPES; i++)
-            GC_MARK(cx, acx-&gt;newborn[i], gc_typenames[i], NULL);
-        if (acx-&gt;lastAtom)
-            GC_MARK_ATOM(cx, acx-&gt;lastAtom, NULL);
-        if (JSVAL_IS_GCTHING(acx-&gt;lastInternalResult)) {
-            thing = JSVAL_TO_GCTHING(acx-&gt;lastInternalResult);
-            if (thing)
-                GC_MARK(cx, thing, &quot;lastInternalResult&quot;, NULL);
+        MarkWeakRoots(cx, &amp;acx-&gt;weakRoots);
+#if JS_HAS_EXCEPTIONS
+        if (acx-&gt;throwing) {
+            if (JSVAL_IS_GCTHING(acx-&gt;exception)) {
+                GC_MARK(cx, JSVAL_TO_GCTHING(acx-&gt;exception), &quot;exception&quot;,
+                        NULL);
+            }
+        } else {
+            /* Avoid keeping GC-ed junk stored in JSContext.exception. */
+            acx-&gt;exception = JSVAL_NULL;
         }
-#if JS_HAS_EXCEPTIONS
-        if (acx-&gt;throwing &amp;&amp; JSVAL_IS_GCTHING(acx-&gt;exception))
-            GC_MARK(cx, JSVAL_TO_GCTHING(acx-&gt;exception), &quot;exception&quot;, NULL);
 #endif
 #if JS_HAS_LVALUE_RETURN
         if (acx-&gt;rval2set &amp;&amp; JSVAL_IS_GCTHING(acx-&gt;rval2))
@@ -1807,14 +1819,23 @@
         if (acx-&gt;localRootStack)
             js_MarkLocalRoots(cx, acx-&gt;localRootStack);
         for (tvr = acx-&gt;tempValueRooters; tvr; tvr = tvr-&gt;down) {
-            if (tvr-&gt;count == -1) {
+            switch (tvr-&gt;count) {
+              case JSTVU_SINGLE:
                 if (JSVAL_IS_GCTHING(tvr-&gt;u.value)) {
                     GC_MARK(cx, JSVAL_TO_GCTHING(tvr-&gt;u.value),
                             &quot;tvr-&gt;u.value&quot;, NULL);
                 }
-            } else if (tvr-&gt;count == -2) {
+                break;
+              case JSTVU_MARKER:
                 tvr-&gt;u.marker(cx, tvr);
-            } else {
+                break;
+              case JSTVU_SPROP:
+                MARK_SCOPE_PROPERTY(cx, tvr-&gt;u.sprop);
+                break;
+              case JSTVU_WEAK_ROOTS:
+                MarkWeakRoots(cx, tvr-&gt;u.weakRoots);
+                break;
+              default:
                 JS_ASSERT(tvr-&gt;count &gt;= 0);
                 GC_MARK_JSVALS(cx, tvr-&gt;count, tvr-&gt;u.array, &quot;tvr-&gt;u.array&quot;);
             }
@@ -1979,11 +2000,30 @@
         JS_UNLOCK_GC(rt);
 #endif
 
+    /* Execute JSGC_END callback outside the lock. */
     if (rt-&gt;gcCallback) {
-        if (gcflags &amp; GC_ALREADY_LOCKED)
+        JSWeakRoots savedWeakRoots;
+        JSTempValueRooter tvr;
+
+        if (gcflags &amp; GC_ALREADY_LOCKED) {
+            /*
+             * We allow JSGC_END implementation to force a full GC or allocate
+             * new GC things. Thus we must protect the weak roots from GC or
+             * overwrites if GC is the last ditch which GC_ALREADY_LOCKED
+             * indicates.
+             */
+            savedWeakRoots = cx-&gt;weakRoots;
+            JS_PUSH_TEMP_ROOT_WEAK_COPY(cx, &amp;savedWeakRoots, &amp;tvr);
+            JS_KEEP_ATOMS(rt);
             JS_UNLOCK_GC(rt);
+        }
+
         (void) rt-&gt;gcCallback(cx, JSGC_END);
-        if (gcflags &amp; GC_ALREADY_LOCKED)
+
+        if (gcflags &amp; GC_ALREADY_LOCKED) {
             JS_LOCK_GC(rt);
+            JS_UNKEEP_ATOMS(rt);
+            JS_POP_TEMP_ROOT(cx, &amp;tvr);
+        }
     }
 }

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsgc.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsgc.h	2007-06-23 13:55:23 UTC (rev 3291)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsgc.h	2007-06-23 14:31:16 UTC (rev 3292)
@@ -45,6 +45,7 @@
 #include &quot;jsprvtd.h&quot;
 #include &quot;jspubtd.h&quot;
 #include &quot;jsdhash.h&quot;
+#include &quot;jsutil.h&quot;
 
 JS_BEGIN_EXTERN_C
 
@@ -259,6 +260,22 @@
 
 #endif /* JS_GCMETER */
 
+typedef struct JSWeakRoots {
+    /* Most recently created things by type, members of the GC's root set. */
+    JSGCThing           *newborn[GCX_NTYPES];
+
+    /* Atom root for the last-looked-up atom on this context. */
+    JSAtom              *lastAtom;
+
+    /* Root for the result of the most recent js_InternalInvoke call. */
+    jsval               lastInternalResult;
+} JSWeakRoots;
+
+#if 0
+JS_STATIC_ASSERT(JSVAL_NULL == 0);
+#endif
+#define JS_CLEAR_WEAK_ROOTS(wr) (memset((wr), 0, sizeof(JSWeakRoots)))
+
 #ifdef DEBUG_notme
 #define TOO_MUCH_GC 1
 #endif

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsinterp.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsinterp.c	2007-06-23 13:55:23 UTC (rev 3291)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsinterp.c	2007-06-23 14:31:16 UTC (rev 3292)
@@ -900,12 +900,13 @@
      */
     if (JSVAL_IS_PRIMITIVE(v)) {
 #if JS_HAS_NO_SUCH_METHOD
+        jsval roots[3];
+        JSTempValueRooter tvr;
         jsid id;
+        JSBool reportNotAFunction;
         jsbytecode *pc;
         jsatomid atomIndex;
-        JSAtom *atom;
         JSObject *argsobj;
-        JSArena *a;
 
         if (!fp-&gt;script || (flags &amp; JSINVOKE_INTERNAL))
             goto bad;
@@ -929,24 +930,34 @@
             goto out2;
         thisp = frame.thisp;
 
+        /* From here on, control must flow through label no_such_method_out. */
+        memset(roots, 0, sizeof roots);
+        JS_PUSH_TEMP_ROOT(cx, sizeof roots / sizeof roots[0], roots, &amp;tvr);
+
+        reportNotAFunction = JS_FALSE;
         id = ATOM_TO_JSID(cx-&gt;runtime-&gt;atomState.noSuchMethodAtom);
+#if JS_HAS_XML_SUPPORT
         if (OBJECT_IS_XML(cx, thisp)) {
             JSXMLObjectOps *ops;
 
             ops = (JSXMLObjectOps *) thisp-&gt;map-&gt;ops;
-            thisp = ops-&gt;getMethod(cx, thisp, id, &amp;v);
+            thisp = ops-&gt;getMethod(cx, thisp, id, &amp;roots[2]);
             if (!thisp) {
                 ok = JS_FALSE;
-                goto out2;
+                goto no_such_method_out;
             }
             vp[1] = OBJECT_TO_JSVAL(thisp);
-        } else {
-            ok = OBJ_GET_PROPERTY(cx, thisp, id, &amp;v);
+        } else
+#endif
+        {
+            ok = OBJ_GET_PROPERTY(cx, thisp, id, &amp;roots[2]);
+            if (!ok)
+                goto no_such_method_out;
         }
-        if (!ok)
-            goto out2;
-        if (JSVAL_IS_PRIMITIVE(v))
-            goto bad;
+        if (JSVAL_IS_PRIMITIVE(roots[2])) {
+            reportNotAFunction = JS_TRUE;
+            goto no_such_method_out;
+        }
 
         pc = (jsbytecode *) vp[-(intN)fp-&gt;script-&gt;depth];
         switch ((JSOp) *pc) {
@@ -956,53 +967,30 @@
           case JSOP_GETMETHOD:
 #endif
             atomIndex = GET_ATOM_INDEX(pc);
-            atom = js_GetAtom(cx, &amp;fp-&gt;script-&gt;atomMap, atomIndex);
+            roots[0] = ATOM_KEY(js_GetAtom(cx, &amp;fp-&gt;script-&gt;atomMap,
+                                           atomIndex));
             argsobj = js_NewArrayObject(cx, argc, vp + 2);
             if (!argsobj) {
                 ok = JS_FALSE;
-                goto out2;
+                goto no_such_method_out;
             }
-
-            sp = vp + 4;
-            if (argc &lt; 2) {
-                a = cx-&gt;stackPool.current;
-                if ((jsuword)sp &gt; a-&gt;limit) {
-                    /*
-                     * Arguments must be contiguous, and must include argv[-1]
-                     * and argv[-2], so allocate more stack, advance sp, and
-                     * set newsp[1] to thisp (vp[1]).  The other argv elements
-                     * will be set below, using negative indexing from sp.
-                     */
-                    newsp = js_AllocRawStack(cx, 4, NULL);
-                    if (!newsp) {
-                        ok = JS_FALSE;
-                        goto out2;
-                    }
-                    newsp[1] = OBJECT_TO_JSVAL(thisp);
-                    sp = newsp + 4;
-                } else if ((jsuword)sp &gt; a-&gt;avail) {
-                    /*
-                     * Inline, optimized version of JS_ARENA_ALLOCATE to claim
-                     * the small number of words not already allocated as part
-                     * of the caller's operand stack.
-                     */
-                    JS_ArenaCountAllocation(&amp;cx-&gt;stackPool,
-                                            (jsuword)sp - a-&gt;avail);
-                    a-&gt;avail = (jsuword)sp;
-                }
-            }
-
-            sp[-4] = v;
-            JS_ASSERT(sp[-3] == OBJECT_TO_JSVAL(thisp));
-            sp[-2] = ATOM_KEY(atom);
-            sp[-1] = OBJECT_TO_JSVAL(argsobj);
-            fp-&gt;sp = sp;
-            argc = 2;
+            roots[1] = OBJECT_TO_JSVAL(argsobj);
+            ok = js_InternalInvoke(cx, thisp, roots[2],
+                                   flags | JSINVOKE_INTERNAL, 2, roots, &amp;vp[0]);
+            if (ok)
+                frame.rval = *vp;
             break;
 
           default:
-            goto bad;
+            reportNotAFunction = JS_TRUE;
+            break;
         }
+
+      no_such_method_out:
+        JS_POP_TEMP_ROOT(cx, &amp;tvr);
+        if (reportNotAFunction)
+            goto bad;
+        goto out2;
 #else
         goto bad;
 #endif
@@ -1287,7 +1275,7 @@
 
         /*
          * Store *rval in the a scoped local root if a scope is open, else in
-         * the cx-&gt;lastInternalResult pigeon-hole GC root, solely so users of
+         * the lastInternalResult pigeon-hole GC root, solely so users of
          * js_InternalInvoke and its direct and indirect (js_ValueToString for
          * example) callers do not need to manage roots for local, temporary
          * references to such results.
@@ -1298,7 +1286,7 @@
                 if (js_PushLocalRoot(cx, cx-&gt;localRootStack, *rval) &lt; 0)
                     ok = JS_FALSE;
             } else {
-                cx-&gt;lastInternalResult = *rval;
+                cx-&gt;weakRoots.lastInternalResult = *rval;
             }
         }
     }
@@ -1316,7 +1304,18 @@
 js_InternalGetOrSet(JSContext *cx, JSObject *obj, jsid id, jsval fval,
                     JSAccessMode mode, uintN argc, jsval *argv, jsval *rval)
 {
+    int stackDummy;
+
     /*
+     * js_InternalInvoke could result in another try to get or set the same id
+     * again, see bug 355497.
+     */
+    if (!JS_CHECK_STACK_SIZE(cx, stackDummy)) {
+        JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
+                             JSMSG_OVER_RECURSED);
+        return JS_FALSE;
+    }
+    /*
      * Check general (not object-ops/class-specific) access from the running
      * script to obj.id only if id has a scripted getter or setter that we're
      * about to invoke.  If we don't check this case, nothing else will -- no
@@ -1891,7 +1890,7 @@
         }
 #endif
 
-        if (interruptHandler) {
+        if (interruptHandler &amp;&amp; op != JSOP_PUSHOBJ) {
             SAVE_SP(fp);
             switch (interruptHandler(cx, script, pc, &amp;rval,
                                      rt-&gt;interruptHandlerData)) {
@@ -1989,7 +1988,7 @@
                 void *hookData = ifp-&gt;hookData;
 
                 if (hookData) {
-                    JSInterpreterHook hook = cx-&gt;runtime-&gt;callHook;
+                    JSInterpreterHook hook = rt-&gt;callHook;
                     if (hook) {
                         hook(cx, fp, JS_FALSE, &amp;ok, hookData);
                         LOAD_INTERRUPT_HANDLER(rt);
@@ -2314,7 +2313,7 @@
                 /*
                  * Rewrite the iterator so we know to do the next case.
                  * Do this before calling the enumerator, which could
-                 * displace cx-&gt;newborn and cause GC.
+                 * displace newborn and cause GC.
                  */
                 *vp = OBJECT_TO_JSVAL(propobj);
 
@@ -2564,15 +2563,42 @@
             goto out;                                                         \
     JS_END_MACRO
 
+#define NATIVE_GET(cx,obj,pobj,sprop,vp)                                      \
+    JS_BEGIN_MACRO                                                            \
+        if (SPROP_HAS_STUB_GETTER(sprop)) {                                   \
+            /* Fast path for Object instance properties. */                   \
+            JS_ASSERT((sprop)-&gt;slot != SPROP_INVALID_SLOT ||                  \
+                      !SPROP_HAS_STUB_SETTER(sprop));                         \
+            *vp = ((sprop)-&gt;slot != SPROP_INVALID_SLOT)                       \
+                  ? LOCKED_OBJ_GET_SLOT(pobj, (sprop)-&gt;slot)                  \
+                  : JSVAL_VOID;                                               \
+        } else {                                                              \
+            SAVE_SP(fp);                                                      \
+            ok = js_NativeGet(cx, obj, pobj, sprop, vp);                      \
+            if (!ok)                                                          \
+                goto out;                                                     \
+        }                                                                     \
+    JS_END_MACRO
+
+#define NATIVE_SET(cx,obj,sprop,vp)                                           \
+    JS_BEGIN_MACRO                                                            \
+        if (SPROP_HAS_STUB_SETTER(sprop) &amp;&amp;                                   \
+            (sprop)-&gt;slot != SPROP_INVALID_SLOT) {                            \
+            /* Fast path for Object instance properties. */                   \
+            LOCKED_OBJ_SET_SLOT(obj, (sprop)-&gt;slot, *vp);                     \
+        } else {                                                              \
+            SAVE_SP(fp);                                                      \
+            ok = js_NativeSet(cx, obj, sprop, vp);                            \
+            if (!ok)                                                          \
+                goto out;                                                     \
+        }                                                                     \
+    JS_END_MACRO
+
 /*
- * Direct callers, i.e. those who do not wrap CACHED_GET and CACHED_SET calls
- * in PROPERTY_OP or ELEMENT_OP macro calls must SAVE_SP(fp); beforehand, just
- * in case a getter or setter function is invoked.  CACHED_GET and CACHED_SET
- * use cx, obj, id, and rval from their caller's lexical environment.
+ * CACHED_GET and CACHED_SET use cx, obj, id, and rval from their callers'
+ * environments.
  */
-#define CACHED_GET(call)        CACHED_GET_VP(call, &amp;rval)
-
-#define CACHED_GET_VP(call,vp)                                                \
+#define CACHED_GET(call)                                                      \
     JS_BEGIN_MACRO                                                            \
         if (!OBJ_IS_NATIVE(obj)) {                                            \
             ok = call;                                                        \
@@ -2580,17 +2606,8 @@
             JS_LOCK_OBJ(cx, obj);                                             \
             PROPERTY_CACHE_TEST(&amp;rt-&gt;propertyCache, obj, id, sprop);          \
             if (sprop) {                                                      \
-                JSScope *scope_ = OBJ_SCOPE(obj);                             \
-                slot = (uintN)sprop-&gt;slot;                                    \
-                *(vp) = (slot != SPROP_INVALID_SLOT)                          \
-                        ? LOCKED_OBJ_GET_SLOT(obj, slot)                      \
-                        : JSVAL_VOID;                                         \
-                JS_UNLOCK_SCOPE(cx, scope_);                                  \
-                ok = SPROP_GET(cx, sprop, obj, obj, vp);                      \
-                JS_LOCK_SCOPE(cx, scope_);                                    \
-                if (ok &amp;&amp; SPROP_HAS_VALID_SLOT(sprop, scope_))                \
-                    LOCKED_OBJ_SET_SLOT(obj, slot, *(vp));                    \
-                JS_UNLOCK_SCOPE(cx, scope_);                                  \
+                NATIVE_GET(cx, obj, obj, sprop, &amp;rval);                       \
+                JS_UNLOCK_OBJ(cx, obj);                                       \
             } else {                                                          \
                 JS_UNLOCK_OBJ(cx, obj);                                       \
                 ok = call;                                                    \
@@ -2610,14 +2627,8 @@
             if (sprop &amp;&amp;                                                      \
                 !(sprop-&gt;attrs &amp; JSPROP_READONLY) &amp;&amp;                          \
                 (scope_ = OBJ_SCOPE(obj), !SCOPE_IS_SEALED(scope_))) {        \
+                NATIVE_SET(cx, obj, sprop, &amp;rval);                            \
                 JS_UNLOCK_SCOPE(cx, scope_);                                  \
-                ok = SPROP_SET(cx, sprop, obj, obj, &amp;rval);                   \
-                JS_LOCK_SCOPE(cx, scope_);                                    \
-                if (ok &amp;&amp; SPROP_HAS_VALID_SLOT(sprop, scope_)) {              \
-                    LOCKED_OBJ_SET_SLOT(obj, sprop-&gt;slot, rval);              \
-                    GC_POKE(cx, JSVAL_NULL);  /* XXX second arg ignored */    \
-                }                                                             \
-                JS_UNLOCK_SCOPE(cx, scope_);                                  \
             } else {                                                          \
                 JS_UNLOCK_OBJ(cx, obj);                                       \
                 ok = call;                                                    \
@@ -3132,7 +3143,7 @@
             LOAD_BRANCH_CALLBACK(cx);
             LOAD_INTERRUPT_HANDLER(rt);
             if (!ok) {
-                cx-&gt;newborn[GCX_OBJECT] = NULL;
+                cx-&gt;weakRoots.newborn[GCX_OBJECT] = NULL;
                 goto out;
             }
 
@@ -3554,10 +3565,10 @@
                 SAVE_SP(&amp;newifp-&gt;frame);
 
                 /* Call the debugger hook if present. */
-                hook = cx-&gt;runtime-&gt;callHook;
+                hook = rt-&gt;callHook;
                 if (hook) {
                     newifp-&gt;hookData = hook(cx, &amp;newifp-&gt;frame, JS_TRUE, 0,
-                                            cx-&gt;runtime-&gt;callHookData);
+                                            rt-&gt;callHookData);
                     LOAD_INTERRUPT_HANDLER(rt);
                 }
 
@@ -3666,26 +3677,11 @@
                 ok = OBJ_GET_PROPERTY(cx, obj, id, &amp;rval);
                 if (!ok)
                     goto out;
-                PUSH_OPND(rval);
-                break;
-            }
-
-            /* Get and push the obj[id] property's value. */
-            sprop = (JSScopeProperty *)prop;
-            slot = (uintN)sprop-&gt;slot;
-            rval = (slot != SPROP_INVALID_SLOT)
-                   ? LOCKED_OBJ_GET_SLOT(obj2, slot)
-                   : JSVAL_VOID;
-            JS_UNLOCK_OBJ(cx, obj2);
-            ok = SPROP_GET(cx, sprop, obj, obj2, &amp;rval);
-            JS_LOCK_OBJ(cx, obj2);
-            if (!ok) {
+            } else {
+                sprop = (JSScopeProperty *)prop;
+                NATIVE_GET(cx, obj, obj2, sprop, &amp;rval);
                 OBJ_DROP_PROPERTY(cx, obj2, prop);
-                goto out;
             }
-            if (SPROP_HAS_VALID_SLOT(sprop, OBJ_SCOPE(obj2)))
-                LOCKED_OBJ_SET_SLOT(obj2, slot, rval);
-            OBJ_DROP_PROPERTY(cx, obj2, prop);
             PUSH_OPND(rval);
             break;
 
@@ -4217,6 +4213,7 @@
             if (!ok)
                 goto out;
             PUSH_OPND(rval);
+            obj = NULL;
             break;
 
           case JSOP_ARGSUB:
@@ -4385,8 +4382,6 @@
           {
             uintN flags;
 
-            atomIndex = GET_ATOM_INDEX(pc);
-            atom = js_GetAtom(cx, &amp;script-&gt;atomMap, atomIndex);
             obj = ATOM_TO_OBJECT(atom);
             fun = (JSFunction *) JS_GetPrivate(cx, obj);
             id = ATOM_TO_JSID(fun-&gt;atom);
@@ -4620,7 +4615,7 @@
             /* Restore fp-&gt;scopeChain now that obj is defined in parent. */
             fp-&gt;scopeChain = obj2;
             if (!ok) {
-                cx-&gt;newborn[GCX_OBJECT] = NULL;
+                cx-&gt;weakRoots.newborn[GCX_OBJECT] = NULL;
                 goto out;
             }
 
@@ -4695,7 +4690,7 @@
             /* Restore fp-&gt;scopeChain now that obj is defined in fp-&gt;varobj. */
             fp-&gt;scopeChain = obj2;
             if (!ok) {
-                cx-&gt;newborn[GCX_OBJECT] = NULL;
+                cx-&gt;weakRoots.newborn[GCX_OBJECT] = NULL;
                 goto out;
             }
 
@@ -4827,7 +4822,7 @@
             JS_ASSERT(sp - fp-&gt;spbase &gt;= 1);
             lval = FETCH_OPND(-1);
             JS_ASSERT(JSVAL_IS_OBJECT(lval));
-            cx-&gt;newborn[GCX_OBJECT] = JSVAL_TO_GCTHING(lval);
+            cx-&gt;weakRoots.newborn[GCX_OBJECT] = JSVAL_TO_GCTHING(lval);
             break;
 
           case JSOP_INITPROP:
@@ -4910,6 +4905,8 @@
             if (!JSVAL_IS_OBJECT(rval)) {
                 char numBuf[12];
                 JS_snprintf(numBuf, sizeof numBuf, &quot;%u&quot;, (unsigned) i);
+
+                SAVE_SP(fp);
                 JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
                                      JSMSG_BAD_SHARP_USE, numBuf);
                 ok = JS_FALSE;
@@ -5396,6 +5393,7 @@
           END_LITOPX_CASE
 
           case JSOP_GETFUNNS:
+            SAVE_SP(fp);
             ok = js_GetFunctionNamespace(cx, &amp;rval);
             if (!ok)
                 goto out;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jslibmath.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jslibmath.h	2007-06-23 13:55:23 UTC (rev 3291)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jslibmath.h	2007-06-23 14:31:16 UTC (rev 3292)
@@ -55,7 +55,7 @@
  */
 
 #if defined(_WIN32) &amp;&amp; !defined(__MWERKS__)
-#define JS_USE_FDLIBM_MATH 1
+/* MEANX #define JS_USE_FDLIBM_MATH 1*/
 
 #elif defined(SUNOS4)
 #define JS_USE_FDLIBM_MATH 1
@@ -70,7 +70,7 @@
 #define JS_USE_FDLIBM_MATH 1
 
 #elif defined(linux)
-#define JS_USE_FDLIBM_MATH 1
+/* MEANX #define JS_USE_FDLIBM_MATH 1 */
 
 #elif defined(OSF1)
 /* Want to use some fdlibm functions but fdlibm broken on OSF1/alpha. */
@@ -83,7 +83,7 @@
 #define JS_USE_FDLIBM_MATH 0
 #endif
 
-#if 1 //MEANX !JS_USE_FDLIBM_MATH
+#if !JS_USE_FDLIBM_MATH
 
 /*
  * Use system provided math routines.

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jslock.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jslock.c	2007-06-23 13:55:23 UTC (rev 3291)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jslock.c	2007-06-23 14:31:16 UTC (rev 3292)
@@ -1193,6 +1193,15 @@
     JSScope *scope;
 
     JS_ASSERT(OBJ_IS_NATIVE(obj));
+
+    /*
+     * We must test whether the GC is calling and return without mutating any
+     * state, especially cx-&gt;lockedSealedScope.  Note asymmetry with respect to
+     * js_UnlockObj, which is a thin-layer on top of js_UnlockScope.
+     */
+    if (CX_THREAD_IS_RUNNING_GC(cx))
+        return;
+
     for (;;) {
         scope = OBJ_SCOPE(obj);
         if (SCOPE_IS_SEALED(scope) &amp;&amp; scope-&gt;object == obj &amp;&amp;
@@ -1251,7 +1260,7 @@
      * a thin or fat lock to cope with shared (concurrent) ownership.
      */
     if (scope-&gt;ownercx) {
-        JS_ASSERT(scope-&gt;ownercx == cx);
+        JS_ASSERT(scope-&gt;ownercx == cx || scope-&gt;ownercx-&gt;thread == cx-&gt;thread);
         return JS_TRUE;
     }
     return CurrentThreadId() == Thin_RemoveWait(ReadWord(scope-&gt;lock.owner));

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jslock.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jslock.h	2007-06-23 13:55:23 UTC (rev 3291)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jslock.h	2007-06-23 14:31:16 UTC (rev 3292)
@@ -181,6 +181,9 @@
         JS_LOCK_RUNTIME_VOID(_rt, e);                                         \
     JS_END_MACRO
 
+/* FIXME: bug 353962 hackaround */
+#define JS_USE_ONLY_NSPR_LOCKS  1
+
 #if defined(JS_USE_ONLY_NSPR_LOCKS) ||                                        \
     !( (defined(_WIN32) &amp;&amp; defined(_M_IX86)) ||                               \
        (defined(__GNUC__) &amp;&amp; defined(__i386__)) ||                            \

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsnum.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsnum.c	2007-06-23 13:55:23 UTC (rev 3291)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsnum.c	2007-06-23 14:31:16 UTC (rev 3292)
@@ -680,7 +680,7 @@
     if (!obj)
         return NULL;
     if (!js_NewNumberValue(cx, d, &amp;v)) {
-        cx-&gt;newborn[GCX_OBJECT] = NULL;
+        cx-&gt;weakRoots.newborn[GCX_OBJECT] = NULL;
         return NULL;
     }
     OBJ_SET_SLOT(cx, obj, JSSLOT_PRIVATE, v);

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsobj.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsobj.c	2007-06-23 13:55:23 UTC (rev 3291)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsobj.c	2007-06-23 14:31:16 UTC (rev 3292)
@@ -2185,7 +2185,7 @@
 
 out:
     JS_POP_TEMP_ROOT(cx, &amp;tvr);
-    cx-&gt;newborn[GCX_OBJECT] = (JSGCThing *) obj;
+    cx-&gt;weakRoots.newborn[GCX_OBJECT] = (JSGCThing *) obj;
     return obj;
 
 bad:
@@ -2314,7 +2314,7 @@
     return obj;
 
 bad:
-    cx-&gt;newborn[GCX_OBJECT] = NULL;
+    cx-&gt;weakRoots.newborn[GCX_OBJECT] = NULL;
     obj = NULL;
     goto out;
 }
@@ -3042,13 +3042,106 @@
 }
 
 JSBool
+js_NativeGet(JSContext *cx, JSObject *obj, JSObject *pobj,
+             JSScopeProperty *sprop, jsval *vp)
+{
+    JSScope *scope;
+    uint32 slot;
+    int32 sample;
+    JSTempValueRooter tvr;
+    JSBool ok;
+
+    JS_ASSERT(OBJ_IS_NATIVE(pobj));
+    JS_ASSERT(JS_IS_OBJ_LOCKED(cx, pobj));
+    scope = OBJ_SCOPE(pobj);
+    JS_ASSERT(scope-&gt;object == pobj);
+
+    slot = sprop-&gt;slot;
+    *vp = (slot != SPROP_INVALID_SLOT)
+          ? LOCKED_OBJ_GET_SLOT(pobj, slot)
+          : JSVAL_VOID;
+    if (SPROP_HAS_STUB_GETTER(sprop))
+        return JS_TRUE;
+
+    sample = cx-&gt;runtime-&gt;propertyRemovals;
+    JS_UNLOCK_SCOPE(cx, scope);
+    JS_PUSH_TEMP_ROOT_SPROP(cx, sprop, &amp;tvr);
+    ok = SPROP_GET(cx, sprop, obj, pobj, vp);
+    JS_POP_TEMP_ROOT(cx, &amp;tvr);
+    if (!ok)
+        return JS_FALSE;
+
+    JS_LOCK_SCOPE(cx, scope);
+    JS_ASSERT(scope-&gt;object == pobj);
+    if (SLOT_IN_SCOPE(slot, scope) &amp;&amp;
+        (JS_LIKELY(cx-&gt;runtime-&gt;propertyRemovals == sample) ||
+         SCOPE_GET_PROPERTY(scope, sprop-&gt;id) == sprop)) {
+        LOCKED_OBJ_SET_SLOT(pobj, slot, *vp);
+    }
+
+    return JS_TRUE;
+}
+
+JSBool
+js_NativeSet(JSContext *cx, JSObject *obj, JSScopeProperty *sprop, jsval *vp)
+{
+    JSScope *scope;
+    uint32 slot;
+    jsval pval;
+    int32 sample;
+    JSTempValueRooter tvr;
+    JSBool ok;
+
+    JS_ASSERT(OBJ_IS_NATIVE(obj));
+    JS_ASSERT(JS_IS_OBJ_LOCKED(cx, obj));
+    scope = OBJ_SCOPE(obj);
+    JS_ASSERT(scope-&gt;object == obj);
+
+    slot = sprop-&gt;slot;
+    if (slot != SPROP_INVALID_SLOT) {
+        pval = LOCKED_OBJ_GET_SLOT(obj, slot);
+
+        /* If sprop has a stub setter, keep scope locked and just store *vp. */
+        if (SPROP_HAS_STUB_SETTER(sprop))
+            goto set_slot;
+    } else {
+        /*
+         * Allow API consumers to create shared properties with stub setters.
+         * Such properties lack value storage, so setting them is like writing
+         * to /dev/null.
+         */
+        if (SPROP_HAS_STUB_SETTER(sprop))
+            return JS_TRUE;
+        pval = JSVAL_VOID;
+    }
+
+    sample = cx-&gt;runtime-&gt;propertyRemovals;
+    JS_UNLOCK_SCOPE(cx, scope);
+    JS_PUSH_TEMP_ROOT_SPROP(cx, sprop, &amp;tvr);
+    ok = SPROP_SET(cx, sprop, obj, obj, vp);
+    JS_POP_TEMP_ROOT(cx, &amp;tvr);
+    if (!ok)
+        return JS_FALSE;
+
+    JS_LOCK_SCOPE(cx, scope);
+    JS_ASSERT(scope-&gt;object == obj);
+    if (SLOT_IN_SCOPE(slot, scope) &amp;&amp;
+        (JS_LIKELY(cx-&gt;runtime-&gt;propertyRemovals == sample) ||
+         SCOPE_GET_PROPERTY(scope, sprop-&gt;id) == sprop)) {
+  set_slot:
+        GC_POKE(cx, pval);
+        LOCKED_OBJ_SET_SLOT(obj, slot, *vp);
+    }
+
+    return JS_TRUE;
+}
+
+JSBool
 js_GetProperty(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
 {
     JSObject *obj2;
     JSProperty *prop;
-    JSScope *scope;
     JSScopeProperty *sprop;
-    uint32 slot;
 
     /*
      * Handle old bug that took empty string as zero index.  Also convert
@@ -3113,33 +3206,12 @@
         return OBJ_GET_PROPERTY(cx, obj2, id, vp);
     }
 
-    /* Unlock obj2 before calling getter, relock after to avoid deadlock. */
-    scope = OBJ_SCOPE(obj2);
     sprop = (JSScopeProperty *) prop;
-    slot = sprop-&gt;slot;
-    if (slot != SPROP_INVALID_SLOT) {
-        JS_ASSERT(slot &lt; obj2-&gt;map-&gt;freeslot);
-        *vp = LOCKED_OBJ_GET_SLOT(obj2, slot);
-
-        /* If sprop has a stub getter, we're done. */
-        if (!sprop-&gt;getter)
-            goto out;
-    } else {
-        *vp = JSVAL_VOID;
-    }
-
-    JS_UNLOCK_SCOPE(cx, scope);
-    if (!SPROP_GET(cx, sprop, obj, obj2, vp))
+    if (!js_NativeGet(cx, obj, obj2, sprop, vp))
         return JS_FALSE;
-    JS_LOCK_SCOPE(cx, scope);
 
-    if (SPROP_HAS_VALID_SLOT(sprop, scope)) {
-        LOCKED_OBJ_SET_SLOT(obj2, slot, *vp);
-        PROPERTY_CACHE_FILL(&amp;cx-&gt;runtime-&gt;propertyCache, obj2, id, sprop);
-    }
-
-out:
-    JS_UNLOCK_SCOPE(cx, scope);
+    PROPERTY_CACHE_FILL(&amp;cx-&gt;runtime-&gt;propertyCache, obj2, id, sprop);
+    JS_UNLOCK_OBJ(cx, obj2);
     return JS_TRUE;
 }
 
@@ -3154,8 +3226,6 @@
     intN shortid;
     JSClass *clasp;
     JSPropertyOp getter, setter;
-    jsval pval;
-    uint32 slot;
 
     /*
      * Handle old bug that took empty string as zero index.  Also convert
@@ -3214,8 +3284,13 @@
             JS_UNLOCK_SCOPE(cx, scope);
 
             /* Don't clone a shared prototype property. */
-            if (attrs &amp; JSPROP_SHARED)
+            if (attrs &amp; JSPROP_SHARED) {
+                if (SPROP_HAS_STUB_SETTER(sprop) &amp;&amp;
+                    !(sprop-&gt;attrs &amp; JSPROP_GETTER)) {
+                    return JS_TRUE;
+                }
                 return SPROP_SET(cx, sprop, obj, pobj, vp);
+            }
 
             /* Restore attrs to the ECMA default for new properties. */
             attrs = JSPROP_ENUMERATE;
@@ -3283,37 +3358,8 @@
         PROPERTY_CACHE_FILL(&amp;cx-&gt;runtime-&gt;propertyCache, obj, id, sprop);
     }
 
-    /* Get the current property value from its slot. */
-    slot = sprop-&gt;slot;
-    if (slot != SPROP_INVALID_SLOT) {
-        JS_ASSERT(slot &lt; obj-&gt;map-&gt;freeslot);
-        pval = LOCKED_OBJ_GET_SLOT(obj, slot);
-
-        /* If sprop has a stub setter, keep scope locked and just store *vp. */
-        if (!sprop-&gt;setter)
-            goto set_slot;
-    }
-
-    /* Avoid deadlock by unlocking obj's scope while calling sprop's setter. */
-    JS_UNLOCK_SCOPE(cx, scope);
-
-    /* Let the setter modify vp before copying from it to obj-&gt;slots[slot]. */
-    if (!SPROP_SET(cx, sprop, obj, obj, vp))
+    if (!js_NativeSet(cx, obj, sprop, vp))
         return JS_FALSE;
-
-    /* Relock obj's scope until we are done with sprop. */
-    JS_LOCK_SCOPE(cx, scope);
-
-    /*
-     * Check whether sprop is still around (was not deleted), and whether it
-     * has a slot (it may never have had one, or we may have lost a race with
-     * someone who cleared scope).
-     */
-    if (SPROP_HAS_VALID_SLOT(sprop, scope)) {
-  set_slot:
-        GC_POKE(cx, pval);
-        LOCKED_OBJ_SET_SLOT(obj, slot, *vp);
-    }
     JS_UNLOCK_SCOPE(cx, scope);
     return JS_TRUE;
 
@@ -3755,11 +3801,7 @@
         end = cursor + state-&gt;ida-&gt;length;
         for (; cursor != end; ++cursor) {
             id = *cursor;
-            if (JSID_IS_ATOM(id)) {
-                GC_MARK_ATOM(cx, JSID_TO_ATOM(id), NULL);
-            } else if (JSID_IS_OBJECT(id)) {
-                GC_MARK(cx, JSID_TO_OBJECT(id), &quot;ida-&gt;vector[i]&quot;, NULL);
-            }
+            MARK_ID(cx, id);
         }
     } while ((state = state-&gt;next) != NULL);
 }
@@ -4070,7 +4112,7 @@
              * instance that delegates to this object, or just query the
              * prototype for its class.
              */
-            cx-&gt;newborn[GCX_OBJECT] = JSVAL_TO_GCTHING(v);
+            cx-&gt;weakRoots.newborn[GCX_OBJECT] = JSVAL_TO_GCTHING(v);
         }
     }
     *protop = JSVAL_IS_OBJECT(v) ? JSVAL_TO_OBJECT(v) : NULL;
@@ -4415,44 +4457,7 @@
     for (sprop = SCOPE_LAST_PROP(scope); sprop; sprop = sprop-&gt;parent) {
         if (SCOPE_HAD_MIDDLE_DELETE(scope) &amp;&amp; !SCOPE_HAS_PROPERTY(scope, sprop))
             continue;
-        MARK_SCOPE_PROPERTY(sprop);
-        if (JSID_IS_ATOM(sprop-&gt;id))
-            GC_MARK_ATOM(cx, JSID_TO_ATOM(sprop-&gt;id), arg);
-        else if (JSID_IS_OBJECT(sprop-&gt;id))
-            GC_MARK(cx, JSID_TO_OBJECT(sprop-&gt;id), &quot;id&quot;, arg);
-
-#if JS_HAS_GETTER_SETTER
-        if (sprop-&gt;attrs &amp; (JSPROP_GETTER | JSPROP_SETTER)) {
-#ifdef GC_MARK_DEBUG
-            char buf[64];
-            JSAtom *atom = JSID_TO_ATOM(sprop-&gt;id);
-            const char *id = (atom &amp;&amp; ATOM_IS_STRING(atom))
-                             ? JS_GetStringBytes(ATOM_TO_STRING(atom))
-                             : &quot;unknown&quot;;
-#endif
-
-            if (sprop-&gt;attrs &amp; JSPROP_GETTER) {
-#ifdef GC_MARK_DEBUG
-                JS_snprintf(buf, sizeof buf, &quot;%s %s&quot;,
-                            id, js_getter_str);
-#endif
-                GC_MARK(cx,
-                        JSVAL_TO_GCTHING((jsval) sprop-&gt;getter),
-                        buf,
-                        arg);
-            }
-            if (sprop-&gt;attrs &amp; JSPROP_SETTER) {
-#ifdef GC_MARK_DEBUG
-                JS_snprintf(buf, sizeof buf, &quot;%s %s&quot;,
-                            id, js_setter_str);
-#endif
-                GC_MARK(cx,
-                        JSVAL_TO_GCTHING((jsval) sprop-&gt;setter),
-                        buf,
-                        arg);
-            }
-        }
-#endif /* JS_HAS_GETTER_SETTER */
+        MARK_SCOPE_PROPERTY(cx, sprop);
     }
 
     /* No one runs while the GC is running, so we can use LOCKED_... here. */

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsobj.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsobj.h	2007-06-23 13:55:23 UTC (rev 3291)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsobj.h	2007-06-23 14:31:16 UTC (rev 3292)
@@ -425,7 +425,20 @@
 extern JSObject *
 js_FindVariableScope(JSContext *cx, JSFunction **funp);
 
+/*
+ * NB: js_NativeGet and js_NativeSet are called with the scope containing sprop
+ * (pobj's scope for Get, obj's for Set) locked, and on successful return, that
+ * scope is again locked.  But on failure, both functions return false with the
+ * scope containing sprop unlocked.
+ */
 extern JSBool
+js_NativeGet(JSContext *cx, JSObject *obj, JSObject *pobj,
+             JSScopeProperty *sprop, jsval *vp);
+
+extern JSBool
+js_NativeSet(JSContext *cx, JSObject *obj, JSScopeProperty *sprop, jsval *vp);
+
+extern JSBool
 js_GetProperty(JSContext *cx, JSObject *obj, jsid id, jsval *vp);
 
 extern JSBool

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsopcode.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsopcode.c	2007-06-23 13:55:23 UTC (rev 3291)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsopcode.c	2007-06-23 14:31:16 UTC (rev 3292)
@@ -476,7 +476,7 @@
                 if (t == z) {
                     char numbuf[10];
                     JS_snprintf(numbuf, sizeof numbuf, &quot;0x%x&quot;, c);
-                    JS_ReportErrorFlagsAndNumber(cx, JSREPORT_ERROR,
+                    JS_ReportErrorFlagsAndNumber(sp-&gt;context, JSREPORT_ERROR,
                                                  js_GetErrorMessage, NULL,
                                                  JSMSG_BAD_SURROGATE_CHAR,
                                                  numbuf);

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsparse.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsparse.c	2007-06-23 13:55:23 UTC (rev 3291)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsparse.c	2007-06-23 14:31:16 UTC (rev 3292)
@@ -963,7 +963,16 @@
     pn-&gt;pn_pos.begin = CURRENT_TOKEN(ts).pos.begin;
 
     TREE_CONTEXT_INIT(&amp;funtc);
+
+    /*
+     * Temporarily transfer the owneship of the recycle list to funtc.
+     * See bug 313967.
+     */ 
+    funtc.nodeList = tc-&gt;nodeList;
+    tc-&gt;nodeList = NULL;
     body = FunctionBody(cx, ts, fun, &amp;funtc);
+    tc-&gt;nodeList = funtc.nodeList;
+    funtc.nodeList = NULL;
     if (!body)
         return NULL;
 
@@ -3558,6 +3567,8 @@
     JSTokenType tt;
     JSAtom *startAtom, *endAtom;
 
+    CHECK_RECURSION();
+
     JS_ASSERT(CURRENT_TOKEN(ts).type == TOK_XMLSTAGO);
     pn = NewParseNode(cx, ts, PN_LIST, tc);
     if (!pn)

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsregexp.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsregexp.c	2007-06-23 13:55:23 UTC (rev 3291)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsregexp.c	2007-06-23 14:31:16 UTC (rev 3292)
@@ -1023,6 +1023,11 @@
             localMax = *src++;
             break;
         }
+        if (state-&gt;flags &amp; JSREG_FOLD) {
+            c = JS_MAX(upcase((jschar) localMax), downcase((jschar) localMax));
+            if (c &gt; localMax)
+                localMax = c;
+        }
         if (inRange) {
             if (rangeStart &gt; localMax) {
                 JS_ReportErrorNumber(state-&gt;context,
@@ -1041,11 +1046,6 @@
                 }
             }
         }
-        if (state-&gt;flags &amp; JSREG_FOLD) {
-            c = JS_MAX(upcase((jschar)localMax), downcase((jschar)localMax));
-            if (c &gt; localMax)
-                localMax = c;
-        }
         if (localMax &gt; max)
             max = localMax;
     }
@@ -1966,6 +1966,8 @@
             re = NULL;
             goto out;
         }
+        for (i = 0; i &lt; re-&gt;classCount; i++)
+            re-&gt;classList[i].converted = JS_FALSE;
     } else {
         re-&gt;classList = NULL;
     }
@@ -3322,15 +3324,15 @@
                            JS_PropertyStub, JS_PropertyStub,                  \
                            JSPROP_ENUMERATE, NULL);                           \
     if (!ok) {                                                                \
-        cx-&gt;newborn[GCX_OBJECT] = NULL;                                       \
-        cx-&gt;newborn[GCX_STRING] = NULL;                                       \
+        cx-&gt;weakRoots.newborn[GCX_OBJECT] = NULL;                             \
+        cx-&gt;weakRoots.newborn[GCX_STRING] = NULL;                             \
         goto out;                                                             \
     }                                                                         \
 }
 
         matchstr = js_NewStringCopyN(cx, cp, matchlen, 0);
         if (!matchstr) {
-            cx-&gt;newborn[GCX_OBJECT] = NULL;
+            cx-&gt;weakRoots.newborn[GCX_OBJECT] = NULL;
             ok = JS_FALSE;
             goto out;
         }
@@ -3367,8 +3369,8 @@
                                    res-&gt;moreLength * sizeof(JSSubString));
                 }
                 if (!morepar) {
-                    cx-&gt;newborn[GCX_OBJECT] = NULL;
-                    cx-&gt;newborn[GCX_STRING] = NULL;
+                    cx-&gt;weakRoots.newborn[GCX_OBJECT] = NULL;
+                    cx-&gt;weakRoots.newborn[GCX_STRING] = NULL;
                     ok = JS_FALSE;
                     goto out;
                 }
@@ -3391,8 +3393,8 @@
                 parstr = js_NewStringCopyN(cx, gData.cpbegin + parsub-&gt;index,
                                            parsub-&gt;length, 0);
                 if (!parstr) {
-                    cx-&gt;newborn[GCX_OBJECT] = NULL;
-                    cx-&gt;newborn[GCX_STRING] = NULL;
+                    cx-&gt;weakRoots.newborn[GCX_OBJECT] = NULL;
+                    cx-&gt;weakRoots.newborn[GCX_STRING] = NULL;
                     ok = JS_FALSE;
                     goto out;
                 }
@@ -3401,8 +3403,8 @@
                                        JSPROP_ENUMERATE, NULL);
             }
             if (!ok) {
-                cx-&gt;newborn[GCX_OBJECT] = NULL;
-                cx-&gt;newborn[GCX_STRING] = NULL;
+                cx-&gt;weakRoots.newborn[GCX_OBJECT] = NULL;
+                cx-&gt;weakRoots.newborn[GCX_STRING] = NULL;
                 goto out;
             }
         }
@@ -4152,7 +4154,7 @@
         return NULL;
     re = JS_GetPrivate(cx, obj);
     if (!JS_SetPrivate(cx, clone, re) || !js_SetLastIndex(cx, clone, 0)) {
-        cx-&gt;newborn[GCX_OBJECT] = NULL;
+        cx-&gt;weakRoots.newborn[GCX_OBJECT] = NULL;
         return NULL;
     }
     HOLD_REGEXP(cx, re);

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsscan.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsscan.c	2007-06-23 13:55:23 UTC (rev 3291)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsscan.c	2007-06-23 14:31:16 UTC (rev 3292)
@@ -2079,7 +2079,7 @@
             if (!JS7_ISDEC(c))
                 break;
             n = 10 * n + JS7_UNDEC(c);
-            if (n &gt;= ATOM_INDEX_LIMIT) {
+            if (n &gt;= ((uintN)1 &lt;&lt; 16)) {
                 js_ReportCompileErrorNumber(cx, ts,
                                             JSREPORT_TS | JSREPORT_ERROR,
                                             JSMSG_SHARPVAR_TOO_BIG);

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsscope.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsscope.c	2007-06-23 13:55:23 UTC (rev 3291)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsscope.c	2007-06-23 14:31:16 UTC (rev 3292)
@@ -1,4 +1,5 @@
 /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ * vim: set ts=8 sw=4 et tw=78:
  *
  * ***** BEGIN LICENSE BLOCK *****
  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
@@ -1328,8 +1329,10 @@
     }
 
     /* First, if sprop is unshared and not cleared, free its slot number. */
-    if (SPROP_HAS_VALID_SLOT(sprop, scope))
+    if (SPROP_HAS_VALID_SLOT(sprop, scope)) {
         js_FreeSlot(cx, scope-&gt;object, sprop-&gt;slot);
+        JS_ATOMIC_INCREMENT(&amp;cx-&gt;runtime-&gt;propertyRemovals);
+    }
 
     /* Next, remove id by setting its entry to a removed or free sentinel. */
     if (SPROP_HAD_COLLISION(stored)) {
@@ -1380,8 +1383,69 @@
         free(scope-&gt;table);
     SCOPE_CLR_MIDDLE_DELETE(scope);
     InitMinimalScope(scope);
+    JS_ATOMIC_INCREMENT(&amp;cx-&gt;runtime-&gt;propertyRemovals);
 }
 
+void
+js_MarkId(JSContext *cx, jsid id)
+{
+    if (JSID_IS_ATOM(id))
+        GC_MARK_ATOM(cx, JSID_TO_ATOM(id), &quot;atom id&quot;);
+    else if (JSID_IS_OBJECT(id))
+        GC_MARK(cx, JSID_TO_OBJECT(id), &quot;object id&quot;, NULL);
+    else
+        JS_ASSERT(JSID_IS_INT(id));
+}
+
+#if defined GC_MARK_DEBUG || defined DUMP_SCOPE_STATS
+# include &quot;jsprf.h&quot;
+#endif
+
+void
+js_MarkScopeProperty(JSContext *cx, JSScopeProperty *sprop)
+{
+    sprop-&gt;flags |= SPROP_MARK;
+    MARK_ID(cx, sprop-&gt;id);
+
+#if JS_HAS_GETTER_SETTER
+    if (sprop-&gt;attrs &amp; (JSPROP_GETTER | JSPROP_SETTER)) {
+#ifdef GC_MARK_DEBUG
+        char buf[64];
+        char buf2[11];
+        const char *id;
+
+        if (JSID_IS_ATOM(sprop-&gt;id)) {
+            JSAtom *atom = JSID_TO_ATOM(sprop-&gt;id);
+
+            id = (atom &amp;&amp; ATOM_IS_STRING(atom))
+                 ? JS_GetStringBytes(ATOM_TO_STRING(atom))
+                 : &quot;unknown&quot;;
+        } else if (JSID_IS_INT(sprop-&gt;id)) {
+            JS_snprintf(buf2, sizeof buf2, &quot;%d&quot;, JSID_TO_INT(sprop-&gt;id));
+            id = buf2;
+        } else {
+            id = &quot;&lt;object&gt;&quot;;
+        }
+#endif
+
+        if (sprop-&gt;attrs &amp; JSPROP_GETTER) {
+#ifdef GC_MARK_DEBUG
+            JS_snprintf(buf, sizeof buf, &quot;%s %s&quot;,
+                        id, js_getter_str);
+#endif
+            GC_MARK(cx, JSVAL_TO_GCTHING((jsval) sprop-&gt;getter), buf, NULL);
+        }
+        if (sprop-&gt;attrs &amp; JSPROP_SETTER) {
+#ifdef GC_MARK_DEBUG
+            JS_snprintf(buf, sizeof buf, &quot;%s %s&quot;,
+                        id, js_setter_str);
+#endif
+            GC_MARK(cx, JSVAL_TO_GCTHING((jsval) sprop-&gt;setter), buf, NULL);
+        }
+    }
+#endif /* JS_HAS_GETTER_SETTER */
+}
+
 #ifdef DUMP_SCOPE_STATS
 
 #include &lt;stdio.h&gt;
@@ -1443,8 +1507,6 @@
     return JS_DHASH_NEXT;
 }
 
-#include &quot;jsprf.h&quot;
-
 static void
 DumpSubtree(JSScopeProperty *sprop, int level, FILE *fp)
 {

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsscope.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsscope.h	2007-06-23 13:55:23 UTC (rev 3291)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsscope.h	2007-06-23 14:31:16 UTC (rev 3292)
@@ -1,4 +1,5 @@
 /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ * vim: set ts=8 sw=4 et tw=78:
  *
  * ***** BEGIN LICENSE BLOCK *****
  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
@@ -304,26 +305,26 @@
 
 #define SPROP_INVALID_SLOT              0xffffffff
 
-#define SPROP_HAS_VALID_SLOT(sprop, scope)                                    \
-    ((sprop)-&gt;slot &lt; (scope)-&gt;map.freeslot)
+#define SLOT_IN_SCOPE(slot,scope)         ((slot) &lt; (scope)-&gt;map.freeslot)
+#define SPROP_HAS_VALID_SLOT(sprop,scope) SLOT_IN_SCOPE((sprop)-&gt;slot, scope)
 
 #define SPROP_HAS_STUB_GETTER(sprop)    (!(sprop)-&gt;getter)
 #define SPROP_HAS_STUB_SETTER(sprop)    (!(sprop)-&gt;setter)
 
-#define SPROP_CALL_GETTER(cx,sprop,getter,obj,obj2,vp)                        \
-    (!(getter) ||                                                             \
-     (getter)(cx, OBJ_THIS_OBJECT(cx,obj), SPROP_USERID(sprop), vp))
-#define SPROP_CALL_SETTER(cx,sprop,setter,obj,obj2,vp)                        \
-    (!(setter) ||                                                             \
-     (setter)(cx, OBJ_THIS_OBJECT(cx,obj), SPROP_USERID(sprop), vp))
-
+/*
+ * NB: SPROP_GET must not be called if SPROP_HAS_STUB_GETTER(sprop).
+ */
 #define SPROP_GET(cx,sprop,obj,obj2,vp)                                       \
     (((sprop)-&gt;attrs &amp; JSPROP_GETTER)                                         \
      ? js_InternalGetOrSet(cx, obj, (sprop)-&gt;id,                              \
                            OBJECT_TO_JSVAL((sprop)-&gt;getter), JSACC_READ,      \
                            0, 0, vp)                                          \
-     : SPROP_CALL_GETTER(cx, sprop, (sprop)-&gt;getter, obj, obj2, vp))
+     : (sprop)-&gt;getter(cx, OBJ_THIS_OBJECT(cx,obj), SPROP_USERID(sprop), vp))
 
+/*
+ * NB: SPROP_SET must not be called if (SPROP_HAS_STUB_SETTER(sprop) &amp;&amp;
+ * !(sprop-&gt;attrs &amp; JSPROP_GETTER)).
+ */
 #define SPROP_SET(cx,sprop,obj,obj2,vp)                                       \
     (((sprop)-&gt;attrs &amp; JSPROP_SETTER)                                         \
      ? js_InternalGetOrSet(cx, obj, (sprop)-&gt;id,                              \
@@ -332,7 +333,7 @@
      : ((sprop)-&gt;attrs &amp; JSPROP_GETTER)                                       \
      ? (JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,                    \
                              JSMSG_GETTER_ONLY, NULL), JS_FALSE)              \
-     : SPROP_CALL_SETTER(cx, sprop, (sprop)-&gt;setter, obj, obj2, vp))
+     : (sprop)-&gt;setter(cx, OBJ_THIS_OBJECT(cx,obj), SPROP_USERID(sprop), vp))
 
 /* Macro for common expression to test for shared permanent attributes. */
 #define SPROP_IS_SHARED_PERMANENT(sprop)                                      \
@@ -380,9 +381,21 @@
 extern void
 js_ClearScope(JSContext *cx, JSScope *scope);
 
-#define MARK_SCOPE_PROPERTY(sprop)      ((sprop)-&gt;flags |= SPROP_MARK)
+/*
+ * These macros used to inline short code sequences, but they grew over time.
+ * We retain them for internal backward compatibility, and in case one or both
+ * ever shrink to inline-able size.
+ */
+#define MARK_ID(cx,id)                js_MarkId(cx, id)
+#define MARK_SCOPE_PROPERTY(cx,sprop) js_MarkScopeProperty(cx, sprop)
 
 extern void
+js_MarkId(JSContext *cx, jsid id);
+
+extern void
+js_MarkScopeProperty(JSContext *cx, JSScopeProperty *sprop);
+
+extern void
 js_SweepScopeProperties(JSRuntime *rt);
 
 extern JSBool

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsscript.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsscript.c	2007-06-23 13:55:23 UTC (rev 3291)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsscript.c	2007-06-23 14:31:16 UTC (rev 3292)
@@ -67,20 +67,50 @@
 static const char js_script_exec[] = &quot;Script.prototype.exec&quot;;
 static const char js_script_compile[] = &quot;Script.prototype.compile&quot;;
 
+/*
+ * This routine requires that obj has been locked previously.
+ */
+static jsint
+GetScriptExecDepth(JSContext *cx, JSObject *obj)
+{
+    jsval v;
+
+    JS_ASSERT(JS_IS_OBJ_LOCKED(cx, obj));
+    v = LOCKED_OBJ_GET_SLOT(obj, JSSLOT_START(&amp;js_ScriptClass));
+    return JSVAL_TO_INT(v);
+}
+
+static void
+AdjustScriptExecDepth(JSContext *cx, JSObject *obj, jsint delta)
+{
+    jsint execDepth;
+
+    JS_LOCK_OBJ(cx, obj);
+    execDepth = GetScriptExecDepth(cx, obj);
+    LOCKED_OBJ_SET_SLOT(obj, JSSLOT_START(&amp;js_ScriptClass),
+                        INT_TO_JSVAL(execDepth + delta));
+    JS_UNLOCK_OBJ(cx, obj);
+}
+
 #if JS_HAS_TOSOURCE
 static JSBool
 script_toSource(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
                 jsval *rval)
 {
+    uint32 indent;
     JSScript *script;
     size_t i, j, k, n;
     char buf[16];
     jschar *s, *t;
-    uint32 indent;
     JSString *str;
 
     if (!JS_InstanceOf(cx, obj, &amp;js_ScriptClass, argv))
         return JS_FALSE;
+
+    indent = 0;
+    if (argc &amp;&amp; !js_ValueToECMAUint32(cx, argv[0], &amp;indent))
+        return JS_FALSE;
+
     script = (JSScript *) JS_GetPrivate(cx, obj);
 
     /* Let n count the source string length, j the &quot;front porch&quot; length. */
@@ -91,9 +121,6 @@
         k = 0;
         s = NULL;               /* quell GCC overwarning */
     } else {
-        indent = 0;
-        if (argc &amp;&amp; !js_ValueToECMAUint32(cx, argv[0], &amp;indent))
-            return JS_FALSE;
         str = JS_DecompileScript(cx, script, &quot;Script.prototype.toSource&quot;,
                                  (uintN)indent);
         if (!str)
@@ -133,10 +160,14 @@
 script_toString(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
                 jsval *rval)
 {
+    uint32 indent;
     JSScript *script;
-    uint32 indent;
     JSString *str;
 
+    indent = 0;
+    if (argc &amp;&amp; !js_ValueToECMAUint32(cx, argv[0], &amp;indent))
+        return JS_FALSE;
+
     if (!JS_InstanceOf(cx, obj, &amp;js_ScriptClass, argv))
         return JS_FALSE;
     script = (JSScript *) JS_GetPrivate(cx, obj);
@@ -145,9 +176,6 @@
         return JS_TRUE;
     }
 
-    indent = 0;
-    if (argc &amp;&amp; !js_ValueToECMAUint32(cx, argv[0], &amp;indent))
-        return JS_FALSE;
     str = JS_DecompileScript(cx, script, &quot;Script.prototype.toString&quot;,
                              (uintN)indent);
     if (!str)
@@ -160,13 +188,15 @@
 script_compile(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
                jsval *rval)
 {
-    JSScript *oldscript, *script;
-    JSStackFrame *fp, *caller;
     JSString *str;
     JSObject *scopeobj;
+    jsval v;
+    JSScript *script, *oldscript;
+    JSStackFrame *fp, *caller;
     const char *file;
     uintN line;
     JSPrincipals *principals;
+    jsint execDepth;
 
     /* Make sure obj is a Script object. */
     if (!JS_InstanceOf(cx, obj, &amp;js_ScriptClass, argv))
@@ -176,35 +206,24 @@
     if (argc == 0)
         goto out;
 
-    /* XXX thread safety was completely neglected in this function... */
-    oldscript = (JSScript *) JS_GetPrivate(cx, obj);
-    if (oldscript) {
-        for (fp = cx-&gt;fp; fp; fp = fp-&gt;down) {
-            if (fp-&gt;script == oldscript) {
-                JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
-                                     JSMSG_SELF_MODIFYING_SCRIPT);
-                return JS_FALSE;
-            }
-        }
-    }
-
     /* Otherwise, the first arg is the script source to compile. */
     str = js_ValueToString(cx, argv[0]);
     if (!str)
         return JS_FALSE;
     argv[0] = STRING_TO_JSVAL(str);
 
-    /* Compile using the caller's scope chain, which js_Invoke passes to fp. */
-    fp = cx-&gt;fp;
-    caller = JS_GetScriptedCaller(cx, fp);
-    JS_ASSERT(!caller || fp-&gt;scopeChain == caller-&gt;scopeChain);
-
     scopeobj = NULL;
     if (argc &gt;= 2) {
         if (!js_ValueToObject(cx, argv[1], &amp;scopeobj))
             return JS_FALSE;
         argv[1] = OBJECT_TO_JSVAL(scopeobj);
     }
+
+    /* Compile using the caller's scope chain, which js_Invoke passes to fp. */
+    fp = cx-&gt;fp;
+    caller = JS_GetScriptedCaller(cx, fp);
+    JS_ASSERT(!caller || fp-&gt;scopeChain == caller-&gt;scopeChain);
+
     if (caller) {
         if (!scopeobj)
             scopeobj = caller-&gt;scopeChain;
@@ -239,15 +258,32 @@
     if (!script)
         return JS_FALSE;
 
-    /* Swap script for obj's old script, if any. */
-    if (!JS_SetPrivate(cx, obj, script)) {
-        js_DestroyScript(cx, script);
+    JS_LOCK_OBJ(cx, obj);
+    execDepth = GetScriptExecDepth(cx, obj);
+
+    /*
+     * execDepth must be 0 to allow compilation here, otherwise the JSScript
+     * struct can be released while running.
+     */
+    if (execDepth &gt; 0) {
+        JS_UNLOCK_OBJ(cx, obj);
+        JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
+                             0 /*&quot;JSMSG_COMPILE_EXECED_SCRIPT&quot;*/); /* MEANX */
         return JS_FALSE;
     }
+
+    /* Swap script for obj's old script, if any. */
+    v = LOCKED_OBJ_GET_SLOT(obj, JSSLOT_PRIVATE);
+    oldscript = !JSVAL_IS_VOID(v) ? (JSScript *) JSVAL_TO_PRIVATE(v) : NULL;
+    LOCKED_OBJ_SET_SLOT(obj, JSSLOT_PRIVATE, PRIVATE_TO_JSVAL(script));
+    JS_UNLOCK_OBJ(cx, obj);
+
     if (oldscript)
         js_DestroyScript(cx, oldscript);
 
     script-&gt;object = obj;
+    js_CallNewScriptHook(cx, script, NULL);
+
 out:
     /* Return the object. */
     *rval = OBJECT_TO_JSVAL(obj);
@@ -257,16 +293,13 @@
 static JSBool
 script_exec(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
-    JSScript *script;
     JSObject *scopeobj, *parent;
     JSStackFrame *fp, *caller;
-    JSPrincipals *principals;
+    JSScript *script;
+    JSBool ok;
 
     if (!JS_InstanceOf(cx, obj, &amp;js_ScriptClass, argv))
         return JS_FALSE;
-    script = (JSScript *) JS_GetPrivate(cx, obj);
-    if (!script)
-        return JS_TRUE;
 
     scopeobj = NULL;
     if (argc) {
@@ -324,12 +357,27 @@
     if (!scopeobj)
         return JS_FALSE;
 
+    /* Keep track of nesting depth for the script. */
+    AdjustScriptExecDepth(cx, obj, 1);
+
+    /* Must get to out label after this */
+    script = (JSScript *) JS_GetPrivate(cx, obj);
+    if (!script) {
+        ok = JS_FALSE;
+        goto out;
+    }
+
     /* Belt-and-braces: check that this script object has access to scopeobj. */
-    principals = script-&gt;principals;
-    if (!js_CheckPrincipalsAccess(cx, scopeobj, principals, js_script_exec))
-        return JS_FALSE;
+    ok = js_CheckPrincipalsAccess(cx, scopeobj, script-&gt;principals,
+                                  js_script_exec);
+    if (!ok)
+        goto out;
 
-    return js_Execute(cx, scopeobj, script, caller, JSFRAME_EVAL, rval);
+    ok = js_Execute(cx, scopeobj, script, caller, JSFRAME_EVAL, rval);
+   
+out:
+    AdjustScriptExecDepth(cx, obj, -1); 
+    return ok;
 }
 
 #if JS_HAS_XDR
@@ -725,6 +773,7 @@
     JSString *str;
     void *buf;
     uint32 len;
+    jsval v;
     JSScript *script, *oldscript;
     JSBool ok, hasMagic;
 
@@ -774,13 +823,26 @@
         goto out;
     }
 
-    /* Swap script for obj's old script, if any. */
-    oldscript = (JSScript *) JS_GetPrivate(cx, obj);
-    ok = JS_SetPrivate(cx, obj, script);
-    if (!ok) {
-        JS_free(cx, script);
+    JS_LOCK_OBJ(cx, obj);
+    execDepth = GetScriptExecDepth(cx, obj);
+
+    /*
+     * execDepth must be 0 to allow compilation here, otherwise the JSScript
+     * struct can be released while running.
+     */
+    if (execDepth &gt; 0) {
+        JS_UNLOCK_OBJ(cx, obj);
+        JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
+                             JSMSG_COMPILE_EXECED_SCRIPT);
         goto out;
     }
+
+    /* Swap script for obj's old script, if any. */
+    v = LOCKED_OBJ_GET_SLOT(cx, obj, JSSLOT_PRIVATE);
+    oldscript = !JSVAL_IS_VOID(v) ? (JSScript *) JSVAL_TO_PRIVATE(v) : NULL;
+    LOCKED_OBJ_SET_SLOT(cx, obj, JSSLOT_PRIVATE, PRIVATE_TO_JSVAL(script));
+    JS_UNLOCK_OBJ(cx, obj);
+
     if (oldscript)
         js_DestroyScript(cx, oldscript);
 
@@ -855,7 +917,7 @@
 
 JS_FRIEND_DATA(JSClass) js_ScriptClass = {
     js_Script_str,
-    JSCLASS_HAS_PRIVATE,
+    JSCLASS_HAS_PRIVATE | JSCLASS_HAS_RESERVED_SLOTS(1),
     JS_PropertyStub,  JS_PropertyStub,  JS_PropertyStub,  JS_PropertyStub,
     JS_EnumerateStub, JS_ResolveStub,   JS_ConvertStub,   script_finalize,
     NULL,             NULL,             script_call,      NULL,/*XXXbe xdr*/
@@ -879,6 +941,10 @@
          */
         *rval = OBJECT_TO_JSVAL(obj);
     }
+
+    if (!JS_SetReservedSlot(cx, obj, 0, INT_TO_JSVAL(0)))
+        return JS_FALSE;
+
     return script_compile(cx, obj, argc, argv, rval);
 }
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsstr.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsstr.c	2007-06-23 13:55:23 UTC (rev 3291)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsstr.c	2007-06-23 14:31:16 UTC (rev 3292)
@@ -555,7 +555,7 @@
     str = js_ValueToString(cx, OBJECT_TO_JSVAL(obj));
     if (!str)
         return JS_TRUE;
-    cx-&gt;newborn[GCX_STRING] = (JSGCThing *) str;
+    cx-&gt;weakRoots.newborn[GCX_STRING] = (JSGCThing *) str;
 
     length = JSSTRING_LENGTH(str);
     for (i = 0; i &lt; length; i++) {
@@ -584,7 +584,7 @@
     str = js_ValueToString(cx, OBJECT_TO_JSVAL(obj));
     if (!str)
         return JS_TRUE;
-    cx-&gt;newborn[GCX_STRING] = (JSGCThing *) str;
+    cx-&gt;weakRoots.newborn[GCX_STRING] = (JSGCThing *) str;
 
     slot = JSVAL_TO_INT(id);
     if ((size_t)slot &lt; JSSTRING_LENGTH(str)) {

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jstypes.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jstypes.h	2007-06-23 13:55:23 UTC (rev 3291)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jstypes.h	2007-06-23 14:31:16 UTC (rev 3292)
@@ -124,10 +124,8 @@
 #define JS_STATIC_DLL_CALLBACK(__x) static __x
 
 #endif
-/* MEANX
+
 #ifdef _WIN32
-*/
-#if 0
 #  if defined(__MWERKS__) || defined(__GNUC__)
 #    define JS_IMPORT_API(__x)      __x
 #  else
@@ -137,7 +135,7 @@
 #    define JS_IMPORT_API(__x)      JS_EXPORT_API (__x)
 #endif
 
-#if 0 // MEANX defined(_WIN32) &amp;&amp; !defined(__MWERKS__)
+#if defined(_WIN32) &amp;&amp; !defined(__MWERKS__)
 #    define JS_IMPORT_DATA(__x)      __declspec(dllimport) __x
 #else
 #    define JS_IMPORT_DATA(__x)     JS_EXPORT_DATA (__x)
@@ -160,7 +158,7 @@
 #define JS_FRIEND_API(t)    JS_PUBLIC_API(t)
 #define JS_FRIEND_DATA(t)   JS_PUBLIC_DATA(t)
 
-#if 0 //MEANXdef _WIN32
+#ifdef _WIN32
 #   define JS_INLINE __inline
 #elif defined(__GNUC__)
 #   define JS_INLINE

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsxml.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsxml.c	2007-06-23 13:55:23 UTC (rev 3291)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/jsxml.c	2007-06-23 14:31:16 UTC (rev 3292)
@@ -342,7 +342,7 @@
     }
     obj = js_NewObject(cx, &amp;js_NamespaceClass.base, NULL, NULL);
     if (!obj || !JS_SetPrivate(cx, obj, ns)) {
-        cx-&gt;newborn[GCX_OBJECT] = NULL;
+        cx-&gt;weakRoots.newborn[GCX_OBJECT] = NULL;
         return NULL;
     }
     ns-&gt;object = obj;
@@ -607,7 +607,7 @@
     }
     obj = js_NewObject(cx, &amp;js_QNameClass.base, NULL, NULL);
     if (!obj || !JS_SetPrivate(cx, obj, qn)) {
-        cx-&gt;newborn[GCX_OBJECT] = NULL;
+        cx-&gt;weakRoots.newborn[GCX_OBJECT] = NULL;
         return NULL;
     }
     qn-&gt;object = obj;
@@ -632,7 +632,7 @@
 
     obj = js_NewObject(cx, &amp;js_AttributeNameClass, NULL, NULL);
     if (!obj || !JS_SetPrivate(cx, obj, qn)) {
-        cx-&gt;newborn[GCX_OBJECT] = NULL;
+        cx-&gt;weakRoots.newborn[GCX_OBJECT] = NULL;
         return NULL;
     }
 
@@ -1466,7 +1466,7 @@
                     break;
                 }
             }
-            prefix = NULL;
+            prefix = IS_EMPTY(uri) ? cx-&gt;runtime-&gt;emptyString : NULL;
         }
         localName = str;
     }
@@ -1511,7 +1511,14 @@
     JSXMLNamespace *ns;
     JSXMLQName *qn, *attrjqn;
     JSXMLClass xml_class;
+    int stackDummy;
 
+    if (!JS_CHECK_STACK_SIZE(cx, stackDummy)) {
+        js_ReportCompileErrorNumber(cx, pn, JSREPORT_PN | JSREPORT_ERROR,
+                                    JSMSG_OVER_RECURSED);
+        return NULL;
+    }
+
 #define PN2X_SKIP_CHILD ((JSXML *) 1)
 
     /*
@@ -3542,7 +3549,7 @@
 
     /*
      * Protect nameqn's object and strings from GC by linking list to it
-     * temporarily.  The cx-&gt;newborn[GCX_OBJECT] GC root protects listobj,
+     * temporarily.  The newborn[GCX_OBJECT] GC root protects listobj,
      * which protects list.  Any other object allocations occuring beneath
      * DescendantsHelper use local roots.
      */
@@ -3993,41 +4000,7 @@
     return JS_TRUE;
 }
 
-/*
- * Class compatibility mask flag bits stored in xml_methods[i].extra.  If XML
- * and XMLList are unified (an incompatible change to ECMA-357), then we don't
- * need any of this.
- */
-#define XML_MASK                0x1
-#define XMLLIST_MASK            0x2
-#define GENERIC_MASK            (XML_MASK | XMLLIST_MASK)
-#define CLASS_TO_MASK(c)        (1 + ((c) == JSXML_CLASS_LIST))
-
 static JSBool
-GetFunction(JSContext *cx, JSObject *obj, JSXML *xml, jsid id, jsval *vp)
-{
-    JSFunction *fun;
-
-    do {
-        /* XXXbe really want a separate scope for function::*. */
-        if (!js_GetProperty(cx, obj, id, vp))
-            return JS_FALSE;
-        if (JSVAL_IS_FUNCTION(cx, *vp)) {
-            if (xml &amp;&amp; OBJECT_IS_XML(cx, obj)) {
-                fun = (JSFunction *) JS_GetPrivate(cx, JSVAL_TO_OBJECT(*vp));
-                if (fun-&gt;spare &amp;&amp;
-                    (fun-&gt;spare &amp; CLASS_TO_MASK(xml-&gt;xml_class)) == 0) {
-                    /* XML method called on XMLList or vice versa. */
-                    *vp = JSVAL_VOID;
-                }
-            }
-            break;
-        }
-    } while ((obj = OBJ_GET_PROTO(cx, obj)) != NULL);
-    return JS_TRUE;
-}
-
-static JSBool
 SyncInScopeNamespaces(JSContext *cx, JSXML *xml)
 {
     JSXMLArray *nsarray;
@@ -4047,34 +4020,75 @@
     return JS_TRUE;
 }
 
+static JSBool
+GetNamedProperty(JSContext *cx, JSXML *xml, JSXMLQName* nameqn,
+                 JSBool attributes, JSXML *list)
+{
+    JSXMLArray *array;
+    JSXMLNameMatcher matcher;
+    JSXMLArrayCursor cursor;
+    JSXML *kid;
+    JSBool ok;
+
+    if (!JSXML_HAS_KIDS(xml))
+        return JS_TRUE;
+
+    if (attributes) {
+        array = &amp;xml-&gt;xml_attrs;
+        matcher = MatchAttrName;
+    } else {
+        array = &amp;xml-&gt;xml_kids;
+        matcher = MatchElemName;
+    }
+
+    XMLArrayCursorInit(&amp;cursor, array);
+    while ((kid = (JSXML *) XMLArrayCursorNext(&amp;cursor)) != NULL) {
+        if (matcher(nameqn, kid)) {
+            if (!attributes &amp;&amp; kid-&gt;xml_class == JSXML_CLASS_ELEMENT) {
+                ok = SyncInScopeNamespaces(cx, kid);
+                if (!ok)
+                    goto out;
+            }
+            ok = Append(cx, list, kid);
+            if (!ok)
+                goto out;
+        }
+    }
+    ok = JS_TRUE;
+
+  out:
+    XMLArrayCursorFinish(&amp;cursor);
+    return ok;
+}
+
+static JSBool
+js_GetXMLFunction(JSContext *cx, JSObject *obj, jsid id, jsval *vp);
+
 /* ECMA-357 9.1.1.1 XML [[Get]] and 9.2.1.1 XMLList [[Get]]. */
 static JSBool
 GetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
 {
     JSXML *xml, *list, *kid;
     uint32 index;
-    JSObject *kidobj, *listobj, *nameobj;
+    JSObject *kidobj, *listobj;
     JSXMLQName *nameqn;
     jsid funid;
-    JSBool ok;
+    jsval roots[2];
+    JSTempValueRooter tvr;
+    JSBool attributes;
     JSXMLArrayCursor cursor;
-    jsval kidval;
-    JSXMLArray *array;
-    JSXMLNameMatcher matcher;
 
     xml = (JSXML *) JS_GetInstancePrivate(cx, obj, &amp;js_XMLClass, NULL);
     if (!xml)
         return JS_TRUE;
 
-#ifdef __GNUC__
-    list = NULL;    /* quell GCC overwarning */
-#endif
-
-retry:
-    if (xml-&gt;xml_class == JSXML_CLASS_LIST) {
-        /* ECMA-357 9.2.1.1 starts here. */
-        if (js_IdIsIndex(id, &amp;index)) {
+    if (js_IdIsIndex(id, &amp;index)) {
+        if (xml-&gt;xml_class != JSXML_CLASS_LIST) {
+            *vp = (index == 0) ? OBJECT_TO_JSVAL(obj) : JSVAL_VOID;
+        } else {
             /*
+             * ECMA-357 9.2.1.1 starts here.
+             *
              * Erratum: 9.2 is not completely clear that indexed properties
              * correspond to kids, but that's what it seems to say, and it's
              * what any sane user would want.
@@ -4093,133 +4107,61 @@
             } else {
                 *vp = JSVAL_VOID;
             }
-            return JS_TRUE;
         }
+        return JS_TRUE;
+    }
 
-        nameqn = ToXMLName(cx, id, &amp;funid);
-        if (!nameqn)
-            return JS_FALSE;
-        if (funid)
-            return GetFunction(cx, obj, xml, funid, vp);
+    /*
+     * ECMA-357 9.2.1.1/9.1.1.1 qname case.
+     */
+    nameqn = ToXMLName(cx, id, &amp;funid);
+    if (!nameqn)
+        return JS_FALSE;
+    if (funid)
+        return js_GetXMLFunction(cx, obj, funid, vp);
 
-        /*
-         * Recursion through GetProperty may allocate more list objects, so
-         * we make use of local root scopes here.  Each new allocation will
-         * push the newborn onto the local root stack.
-         */
-        ok = JS_EnterLocalRootScope(cx);
-        if (!ok)
-            return JS_FALSE;
+    roots[0] = OBJECT_TO_JSVAL(nameqn-&gt;object);
+    JS_PUSH_TEMP_ROOT(cx, 1, roots, &amp;tvr);
 
-        /*
-         * NB: nameqn is already protected from GC by cx-&gt;newborn[GCX_OBJECT]
-         * until listobj is created.  After that, a local root keeps listobj
-         * alive, and listobj's private keeps nameqn alive via targetprop.
-         */
-        listobj = js_NewXMLObject(cx, JSXML_CLASS_LIST);
-        if (!listobj) {
-            ok = JS_FALSE;
-        } else {
-            list = (JSXML *) JS_GetPrivate(cx, listobj);
-            list-&gt;xml_target = xml;
+    listobj = js_NewXMLObject(cx, JSXML_CLASS_LIST);
+    if (listobj) {
+        roots[1] = OBJECT_TO_JSVAL(listobj);
+        tvr.count++;
 
+        list = (JSXML *) JS_GetPrivate(cx, listobj);
+        attributes = (OBJ_GET_CLASS(cx, nameqn-&gt;object) ==
+                      &amp;js_AttributeNameClass);
+
+        if (xml-&gt;xml_class == JSXML_CLASS_LIST) {
             XMLArrayCursorInit(&amp;cursor, &amp;xml-&gt;xml_kids);
             while ((kid = (JSXML *) XMLArrayCursorNext(&amp;cursor)) != NULL) {
-                if (kid-&gt;xml_class == JSXML_CLASS_ELEMENT) {
-                    kidobj = js_GetXMLObject(cx, kid);
-                    if (!kidobj) {
-                        ok = JS_FALSE;
-                        break;
-                    }
-                    ok = GetProperty(cx, kidobj, id, &amp;kidval);
-                    if (!ok)
-                        break;
-                    kidobj = JSVAL_TO_OBJECT(kidval);
-                    kid = (JSXML *) JS_GetPrivate(cx, kidobj);
-                    if (JSXML_LENGTH(kid) &gt; 0) {
-                        ok = Append(cx, list, kid);
-                        if (!ok)
-                            break;
-                    }
+                if (kid-&gt;xml_class == JSXML_CLASS_ELEMENT &amp;&amp;
+                    !GetNamedProperty(cx, kid, nameqn, attributes, list)) {
+                    listobj = NULL;
+                    break;
                 }
             }
             XMLArrayCursorFinish(&amp;cursor);
+        } else {
+            if (!GetNamedProperty(cx, xml, nameqn, attributes, list))
+                listobj = NULL;
         }
-    } else {
-        /* ECMA-357 9.1.1.1 starts here. */
-        if (js_IdIsIndex(id, &amp;index)) {
-            obj = ToXMLList(cx, OBJECT_TO_JSVAL(obj));
-            if (!obj)
-                return JS_FALSE;
-            xml = (JSXML *) JS_GetPrivate(cx, obj);
-            goto retry;
-        }
 
-        nameqn = ToXMLName(cx, id, &amp;funid);
-        if (!nameqn)
-            return JS_FALSE;
-        if (funid)
-            return GetFunction(cx, obj, xml, funid, vp);
-        nameobj = nameqn-&gt;object;
-
         /*
-         * Recursion through GetProperty may allocate more list objects, so
-         * we make use of local root scopes here.  Each new allocation will
-         * push the newborn onto the local root stack.
+         * Erratum: ECMA-357 9.1.1.1 misses that [[Append]] sets the given
+         * list's [[TargetProperty]] to the property that is being appended.
+         * This means that any use of the internal [[Get]] property returns
+         * a list which, when used by e.g. [[Insert]] duplicates the last
+         * element matched by id.
+         * See bug 336921.
          */
-        ok = JS_EnterLocalRootScope(cx);
-        if (!ok)
-            return JS_FALSE;
-
-        listobj = js_NewXMLObject(cx, JSXML_CLASS_LIST);
-        if (!listobj) {
-            ok = JS_FALSE;
-        } else {
-            list = (JSXML *) JS_GetPrivate(cx, listobj);
-            list-&gt;xml_target = xml;
-
-            if (JSXML_HAS_KIDS(xml)) {
-                if (OBJ_GET_CLASS(cx, nameobj) == &amp;js_AttributeNameClass) {
-                    array = &amp;xml-&gt;xml_attrs;
-                    matcher = MatchAttrName;
-                } else {
-                    array = &amp;xml-&gt;xml_kids;
-                    matcher = MatchElemName;
-                }
-                XMLArrayCursorInit(&amp;cursor, array);
-                while ((kid = (JSXML *) XMLArrayCursorNext(&amp;cursor)) != NULL) {
-                    if (matcher(nameqn, kid)) {
-                        if (array == &amp;xml-&gt;xml_kids &amp;&amp;
-                            kid-&gt;xml_class == JSXML_CLASS_ELEMENT) {
-                            ok = SyncInScopeNamespaces(cx, kid);
-                            if (!ok)
-                                break;
-                        }
-                        ok = Append(cx, list, kid);
-                        if (!ok)
-                            break;
-                    }
-                }
-                XMLArrayCursorFinish(&amp;cursor);
-            }
-        }
+        list-&gt;xml_target = xml;
+        list-&gt;xml_targetprop = nameqn;
+        *vp = OBJECT_TO_JSVAL(listobj);
     }
 
-    /* Common tail code for list and non-list cases. */
-    JS_LeaveLocalRootScope(cx);
-    if (!ok)
-        return JS_FALSE;
-
-    /*
-     * Erratum: ECMA-357 9.1.1.1 misses that [[Append]] sets the given list's
-     * [[TargetProperty]] to the property that is being appended. This means
-     * that any use of the internal [[Get]] property returns a list which,
-     * when used by e.g. [[Insert]] duplicates the last element matched by id.
-     * See bug 336921.
-     */
-    list-&gt;xml_targetprop = nameqn;
-    *vp = OBJECT_TO_JSVAL(listobj);
-    return JS_TRUE;
+    JS_POP_TEMP_ROOT(cx, &amp;tvr);
+    return listobj != NULL;
 }
 
 static JSXML *
@@ -4367,6 +4309,8 @@
                         ok = GetProperty(cx, rxml-&gt;object, id, &amp;attrval);
                         if (!ok)
                             goto out;
+                        if (JSVAL_IS_PRIMITIVE(attrval)) /* no such attribute */
+                            goto out;
                         attrobj = JSVAL_TO_OBJECT(attrval);
                         attr = (JSXML *) JS_GetPrivate(cx, attrobj);
                         if (JSXML_LENGTH(attr) != 0)
@@ -4458,7 +4402,9 @@
 
                 if (parent) {
                     /* 2(e)(i). */
-                    parentobj = parent-&gt;object;
+                    parentobj = js_GetXMLObject(cx, parent);
+                    if (!parentobj)
+                        goto bad;
                     ok = PutProperty(cx, parentobj, id, vp);
                     if (!ok)
                         goto out;
@@ -5106,18 +5052,25 @@
  * be native.  Therefore, xml_lookupProperty must return a valid JSProperty
  * pointer parameter via *propp to signify &quot;property found&quot;.  Since the only
  * call to xml_lookupProperty is via OBJ_LOOKUP_PROPERTY, and then only from
- * js_FindXMLProperty (in this file) and js_FindProperty (in jsobj.c, called
- * from jsinterp.c), the only time we add a JSScopeProperty here is when an
- * unqualified name or XML name is being accessed.
+ * js_FindXMLProperty (in this file), js_FindProperty (in jsobj.c, called from
+ * jsinterp.c) or from JSOP_IN case in the interpreter, the only time we add a
+ * JSScopeProperty here is when an unqualified name or XML name is being
+ * accessed or when &quot;name in xml&quot; is called.
  *
- * This scope property both speeds up subsequent js_Find*Property calls, and
- * keeps the JSOP_NAME code in js_Interpret happy by giving it an sprop with
- * (getter, setter) == (GetProperty, PutProperty).  We can't use that getter
- * and setter as js_XMLClass's getProperty and setProperty, because doing so
- * would break the XML methods, which are function-valued properties of the
- * XML.prototype object.
+ * This scope property keeps the JSOP_NAME code in js_Interpret happy by
+ * giving it an sprop with (getter, setter) == (GetProperty, PutProperty).
  *
  * NB: xml_deleteProperty must take care to remove any property added here.
+ *
+ * FIXME This clashes with the function namespace implementation which also
+ * uses native properties. Effectively after xml_lookupProperty any property
+ * stored previously using assignments to xml.function::name will be removed.
+ * We partially workaround the problem in js_GetXMLFunction. There we take
+ * advantage of the fact that typically function:: is used to access the
+ * functions from XML.prototype. So when js_GetProperty returns a non-function
+ * property, we assume that it represents the result of GetProperty setter
+ * hiding the function and use an extra prototype chain lookup to recover it.
+ * For a proper solution see bug 355257.
  */
 static JSBool
 xml_lookupProperty(JSContext *cx, JSObject *obj, jsid id, JSObject **objp,
@@ -5375,66 +5328,20 @@
 static JSObject *
 xml_getMethod(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
 {
-    JSXML *xml;
     JSTempValueRooter tvr;
-    jsval roots[2];
-    enum {
-        FUN_ROOT = 0,
-        OBJ_ROOT = 1
-    };
 
     JS_ASSERT(JS_InstanceOf(cx, obj, &amp;js_XMLClass, NULL));
-    xml = (JSXML *) JS_GetPrivate(cx, obj);
-    memset(roots, 0, sizeof(roots));
-    JS_PUSH_TEMP_ROOT(cx, sizeof roots / sizeof *roots, roots, &amp;tvr);
 
-    /* From this point the control must flow through out: or bad: */
-  retry:
-    if (!GetFunction(cx, obj, xml, id, &amp;roots[FUN_ROOT]))
-        goto bad;
-    if (JSVAL_IS_VOID(roots[FUN_ROOT]) &amp;&amp; OBJECT_IS_XML(cx, obj)) {
-        if (xml-&gt;xml_class == JSXML_CLASS_LIST) {
-            if (xml-&gt;xml_kids.length == 1) {
-                xml = XMLARRAY_MEMBER(&amp;xml-&gt;xml_kids, 0, JSXML);
-                if (xml) {
-                    obj = js_GetXMLObject(cx, xml);
-                    if (!obj)
-                        goto bad;
-                    roots[OBJ_ROOT] = OBJECT_TO_JSVAL(obj);
-                    goto retry;
-                }
-            }
-        } else if (HasSimpleContent(xml)) {
-            JSString *str;
-
-            str = js_ValueToString(cx, OBJECT_TO_JSVAL(obj));
-            if (!str)
-                goto bad;
-            if (!js_ValueToObject(cx, STRING_TO_JSVAL(str), &amp;obj))
-                goto bad;
-            roots[OBJ_ROOT] = OBJECT_TO_JSVAL(obj);
-            if (!js_GetProperty(cx, obj, id, &amp;roots[FUN_ROOT]))
-                goto bad;
-        }
-    }
-  out:
-    *vp = roots[FUN_ROOT];
-    if (obj) {
-        /*
-         * If we just POP tvr, then it is possible that nothing roots obj, see
-         * bug 353165. To allow our callers to assume at least weakly rooting
-         * of the result, we root obj via newborn array. Similarly we root the
-         * value of roots[FUNCTION] since getMethod callers have a bad habit
-         * of passing a pointer to unrooted local value as vp.
-         */
-        cx-&gt;newborn[GCX_OBJECT] = (JSGCThing *)obj;
-        cx-&gt;lastInternalResult = roots[FUN_ROOT];
-    }
+    /*
+     * As our callers have a bad habit of passing a pointer to an unrooted
+     * local value as vp, we use a proper root here.
+     */
+    JS_PUSH_SINGLE_TEMP_ROOT(cx, JSVAL_NULL, &amp;tvr);
+    if (!js_GetXMLFunction(cx, obj, id, &amp;tvr.u.value))
+        obj = NULL;
+    *vp = tvr.u.value;
     JS_POP_TEMP_ROOT(cx, &amp;tvr);
     return obj;
-  bad:
-    obj = NULL;
-    goto out;
 }
 
 static JSBool
@@ -5669,6 +5576,40 @@
     return JSVAL_TO_OBJECT(rval);
 }
 
+static JSXML *
+StartNonListXMLMethod(JSContext *cx, JSObject **objp, jsval *argv)
+{
+    JSXML *xml;
+    JSFunction *fun;
+
+    JS_ASSERT(JSVAL_IS_FUNCTION(cx, argv[-2]));
+
+    xml = (JSXML *) JS_GetInstancePrivate(cx, *objp, &amp;js_XMLClass, argv);
+    if (!xml || xml-&gt;xml_class != JSXML_CLASS_LIST)
+        return xml;
+
+    if (xml-&gt;xml_kids.length == 1) {
+        xml = XMLARRAY_MEMBER(&amp;xml-&gt;xml_kids, 0, JSXML);
+        if (xml) {
+            *objp = js_GetXMLObject(cx, xml);
+            if (!*objp)
+                return NULL;
+            argv[-1] = OBJECT_TO_JSVAL(*objp);
+            return xml;
+        }
+    }
+
+    fun = (JSFunction *) JS_GetPrivate(cx, JSVAL_TO_OBJECT(argv[-2]));
+    if (fun) {
+        char numBuf[12];
+        JS_snprintf(numBuf, sizeof numBuf, &quot;%u&quot;, xml-&gt;xml_kids.length);
+        JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
+                             0 /*JSMSG_NON_LIST_XML_METHOD*/, /* MEANX */
+                             JS_GetFunctionName(fun), numBuf);
+    }
+    return NULL;
+}
+
 #define XML_METHOD_PROLOG                                                     \
     JS_BEGIN_MACRO                                                            \
         xml = (JSXML *) JS_GetInstancePrivate(cx, obj, &amp;js_XMLClass, argv);   \
@@ -5676,6 +5617,14 @@
             return JS_FALSE;                                                  \
     JS_END_MACRO
 
+#define NON_LIST_XML_METHOD_PROLOG                                            \
+    JS_BEGIN_MACRO                                                            \
+        xml = StartNonListXMLMethod(cx, &amp;obj, argv);                          \
+        if (!xml)                                                             \
+            return JS_FALSE;                                                  \
+        JS_ASSERT(xml-&gt;xml_class != JSXML_CLASS_LIST);                        \
+    JS_END_MACRO
+
 static JSBool
 xml_addNamespace(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
                  jsval *rval)
@@ -5684,7 +5633,7 @@
     JSObject *nsobj;
     JSXMLNamespace *ns;
 
-    XML_METHOD_PROLOG;
+    NON_LIST_XML_METHOD_PROLOG;
     if (xml-&gt;xml_class != JSXML_CLASS_ELEMENT)
         return JS_TRUE;
     xml = CHECK_COPY_ON_WRITE(cx, xml, obj);
@@ -5712,7 +5661,7 @@
     jsval name, v;
     JSObject *vobj;
 
-    XML_METHOD_PROLOG;
+    NON_LIST_XML_METHOD_PROLOG;
     xml = CHECK_COPY_ON_WRITE(cx, xml, obj);
     if (!xml)
         return JS_FALSE;
@@ -5858,7 +5807,7 @@
     JSXML *xml, *parent;
     uint32 i, n;
 
-    XML_METHOD_PROLOG;
+    NON_LIST_XML_METHOD_PROLOG;
     parent = xml-&gt;parent;
     if (!parent || xml-&gt;xml_class == JSXML_CLASS_ATTRIBUTE) {
         *rval = DOUBLE_TO_JSVAL(cx-&gt;runtime-&gt;jsNaN);
@@ -5967,7 +5916,7 @@
                 break;
         }
         XMLArrayCursorFinish(&amp;cursor);
-        if (kid)
+        if (kid &amp;&amp; !eq)
             return JS_FALSE;
     } else {
         if (!xml_equality(cx, obj, value, &amp;eq))
@@ -6273,7 +6222,7 @@
     JSTempRootedNSArray namespaces;
     JSBool ok;
 
-    XML_METHOD_PROLOG;
+    NON_LIST_XML_METHOD_PROLOG;
 
     InitTempNSArray(cx, &amp;namespaces);
     ok = FindInScopeNamespaces(cx, xml, &amp;namespaces.array) &amp;&amp;
@@ -6290,7 +6239,7 @@
     jsval arg;
     uint32 i;
 
-    XML_METHOD_PROLOG;
+    NON_LIST_XML_METHOD_PROLOG;
     if (!JSXML_HAS_KIDS(xml))
         return JS_TRUE;
 
@@ -6325,7 +6274,7 @@
     jsval arg;
     uint32 i;
 
-    XML_METHOD_PROLOG;
+    NON_LIST_XML_METHOD_PROLOG;
     if (!JSXML_HAS_KIDS(xml))
         return JS_TRUE;
 
@@ -6373,7 +6322,7 @@
 {
     JSXML *xml;
 
-    XML_METHOD_PROLOG;
+    NON_LIST_XML_METHOD_PROLOG;
     *rval = xml-&gt;name ? STRING_TO_JSVAL(xml-&gt;name-&gt;localName) : JSVAL_NULL;
     return JS_TRUE;
 }
@@ -6384,7 +6333,7 @@
     JSXML *xml;
     JSObject *nameobj;
 
-    XML_METHOD_PROLOG;
+    NON_LIST_XML_METHOD_PROLOG;
     if (!xml-&gt;name) {
         *rval = JSVAL_NULL;
     } else {
@@ -6408,11 +6357,8 @@
     JSXMLNamespace *ns;
     JSObject *nsobj;
 
-    XML_METHOD_PROLOG;
-    if (argc == 0 &amp;&amp;
-        (xml-&gt;xml_class == JSXML_CLASS_TEXT ||
-         xml-&gt;xml_class == JSXML_CLASS_COMMENT ||
-         xml-&gt;xml_class == JSXML_CLASS_PROCESSING_INSTRUCTION)) {
+    NON_LIST_XML_METHOD_PROLOG;
+    if (argc == 0 &amp;&amp; !JSXML_HAS_NAME(xml)) {
         *rval = JSVAL_NULL;
         return JS_TRUE;
     }
@@ -6474,8 +6420,8 @@
     uint32 i, n;
     JSXMLNamespace *ns;
 
-    XML_METHOD_PROLOG;
-    if (JSXML_HAS_VALUE(xml) || xml-&gt;xml_class == JSXML_CLASS_LIST)
+    NON_LIST_XML_METHOD_PROLOG;
+    if (JSXML_HAS_VALUE(xml))
         return JS_TRUE;
 
     /* From here, control flow must goto out to finish these arrays. */
@@ -6539,7 +6485,7 @@
     JSXML *xml;
     JSString *str;
 
-    XML_METHOD_PROLOG;
+    NON_LIST_XML_METHOD_PROLOG;
     str = JS_InternString(cx, js_xml_class_str[xml-&gt;xml_class]);
     if (!str)
         return JS_FALSE;
@@ -6747,7 +6693,7 @@
 {
     JSXML *xml;
 
-    XML_METHOD_PROLOG;
+    NON_LIST_XML_METHOD_PROLOG;
     xml = CHECK_COPY_ON_WRITE(cx, xml, obj);
     if (!xml)
         return JS_FALSE;
@@ -6836,7 +6782,7 @@
     JSObject *nsobj;
     JSXMLNamespace *ns;
 
-    XML_METHOD_PROLOG;
+    NON_LIST_XML_METHOD_PROLOG;
     *rval = OBJECT_TO_JSVAL(obj);
     if (xml-&gt;xml_class != JSXML_CLASS_ELEMENT)
         return JS_TRUE;
@@ -6863,7 +6809,7 @@
     JSObject *nameobj;
     JSXMLQName *nameqn;
 
-    XML_METHOD_PROLOG;
+    NON_LIST_XML_METHOD_PROLOG;
     *rval = OBJECT_TO_JSVAL(obj);
     if (xml-&gt;xml_class != JSXML_CLASS_ELEMENT)
         return JS_TRUE;
@@ -6919,6 +6865,9 @@
 xml_setChildren(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
                 jsval *rval)
 {
+    if (!StartNonListXMLMethod(cx, &amp;obj, argv))
+        return JS_FALSE;
+
     if (!PutProperty(cx, obj, ATOM_KEY(cx-&gt;runtime-&gt;atomState.starAtom),
                      &amp;argv[0])) {
         return JS_FALSE;
@@ -6937,7 +6886,7 @@
     JSXMLQName *nameqn;
     JSString *namestr;
 
-    XML_METHOD_PROLOG;
+    NON_LIST_XML_METHOD_PROLOG;
     if (!JSXML_HAS_NAME(xml))
         return JS_TRUE;
 
@@ -6971,7 +6920,7 @@
     uint32 i, n;
     JSXMLNamespace *ns;
 
-    XML_METHOD_PROLOG;
+    NON_LIST_XML_METHOD_PROLOG;
     if (!JSXML_HAS_NAME(xml))
         return JS_TRUE;
 
@@ -7073,11 +7022,9 @@
     JSXMLNamespace *ns;
     jsval qnargv[2];
 
-    XML_METHOD_PROLOG;
-    if (xml-&gt;xml_class != JSXML_CLASS_ELEMENT &amp;&amp;
-        xml-&gt;xml_class != JSXML_CLASS_ATTRIBUTE) {
+    NON_LIST_XML_METHOD_PROLOG;
+    if (!JSXML_HAS_NAME(xml))
         return JS_TRUE;
-    }
 
     xml = CHECK_COPY_ON_WRITE(cx, xml, obj);
     if (!xml || !js_GetXMLQNameObject(cx, xml-&gt;name))
@@ -7237,46 +7184,46 @@
 }
 
 static JSFunctionSpec xml_methods[] = {
-    {&quot;addNamespace&quot;,          xml_addNamespace,          1,0,XML_MASK},
-    {&quot;appendChild&quot;,           xml_appendChild,           1,0,XML_MASK},
-    {js_attribute_str,        xml_attribute,             1,0,GENERIC_MASK},
-    {&quot;attributes&quot;,            xml_attributes,            0,0,GENERIC_MASK},
-    {&quot;child&quot;,                 xml_child,                 1,0,GENERIC_MASK},
-    {&quot;childIndex&quot;,            xml_childIndex,            0,0,XML_MASK},
-    {&quot;children&quot;,              xml_children,              0,0,GENERIC_MASK},
-    {&quot;comments&quot;,              xml_comments,              0,0,GENERIC_MASK},
-    {&quot;contains&quot;,              xml_contains,              1,0,GENERIC_MASK},
-    {&quot;copy&quot;,                  xml_copy,                  0,0,GENERIC_MASK},
-    {&quot;descendants&quot;,           xml_descendants,           1,0,GENERIC_MASK},
-    {&quot;elements&quot;,              xml_elements,              1,0,GENERIC_MASK},
-    {&quot;hasOwnProperty&quot;,        xml_hasOwnProperty,        1,0,GENERIC_MASK},
-    {&quot;hasComplexContent&quot;,     xml_hasComplexContent,     1,0,GENERIC_MASK},
-    {&quot;hasSimpleContent&quot;,      xml_hasSimpleContent,      1,0,GENERIC_MASK},
-    {&quot;inScopeNamespaces&quot;,     xml_inScopeNamespaces,     0,0,XML_MASK},
-    {&quot;insertChildAfter&quot;,      xml_insertChildAfter,      2,0,XML_MASK},
-    {&quot;insertChildBefore&quot;,     xml_insertChildBefore,     2,0,XML_MASK},
-    {js_length_str,           xml_length,                0,0,GENERIC_MASK},
-    {js_localName_str,        xml_localName,             0,0,XML_MASK},
-    {js_name_str,             xml_name,                  0,0,XML_MASK},
-    {js_namespace_str,        xml_namespace,             1,0,XML_MASK},
-    {&quot;namespaceDeclarations&quot;, xml_namespaceDeclarations, 0,0,XML_MASK},
-    {&quot;nodeKind&quot;,              xml_nodeKind,              0,0,XML_MASK},
-    {&quot;normalize&quot;,             xml_normalize,             0,0,GENERIC_MASK},
-    {js_xml_parent_str,       xml_parent,                0,0,GENERIC_MASK},
-    {&quot;processingInstructions&quot;,xml_processingInstructions,1,0,GENERIC_MASK},
-    {&quot;prependChild&quot;,          xml_prependChild,          1,0,XML_MASK},
-    {&quot;propertyIsEnumerable&quot;,  xml_propertyIsEnumerable,  1,0,GENERIC_MASK},
-    {&quot;removeNamespace&quot;,       xml_removeNamespace,       1,0,XML_MASK},
-    {&quot;replace&quot;,               xml_replace,               2,0,XML_MASK},
-    {&quot;setChildren&quot;,           xml_setChildren,           1,0,XML_MASK},
-    {&quot;setLocalName&quot;,          xml_setLocalName,          1,0,XML_MASK},
-    {&quot;setName&quot;,               xml_setName,               1,0,XML_MASK},
-    {&quot;setNamespace&quot;,          xml_setNamespace,          1,0,XML_MASK},
-    {js_text_str,             xml_text,                  0,0,GENERIC_MASK},
-    {js_toString_str,         xml_toString,              0,0,GENERIC_MASK},
-    {js_toXMLString_str,      xml_toXMLString,           0,0,GENERIC_MASK},
-    {js_toSource_str,         xml_toXMLString,           0,0,GENERIC_MASK},
-    {js_valueOf_str,          xml_valueOf,               0,0,GENERIC_MASK},
+    {&quot;addNamespace&quot;,          xml_addNamespace,          1,0,0},
+    {&quot;appendChild&quot;,           xml_appendChild,           1,0,0},
+    {js_attribute_str,        xml_attribute,             1,0,0},
+    {&quot;attributes&quot;,            xml_attributes,            0,0,0},
+    {&quot;child&quot;,                 xml_child,                 1,0,0},
+    {&quot;childIndex&quot;,            xml_childIndex,            0,0,0},
+    {&quot;children&quot;,              xml_children,              0,0,0},
+    {&quot;comments&quot;,              xml_comments,              0,0,0},
+    {&quot;contains&quot;,              xml_contains,              1,0,0},
+    {&quot;copy&quot;,                  xml_copy,                  0,0,0},
+    {&quot;descendants&quot;,           xml_descendants,           1,0,0},
+    {&quot;elements&quot;,              xml_elements,              1,0,0},
+    {&quot;hasOwnProperty&quot;,        xml_hasOwnProperty,        1,0,0},
+    {&quot;hasComplexContent&quot;,     xml_hasComplexContent,     1,0,0},
+    {&quot;hasSimpleContent&quot;,      xml_hasSimpleContent,      1,0,0},
+    {&quot;inScopeNamespaces&quot;,     xml_inScopeNamespaces,     0,0,0},
+    {&quot;insertChildAfter&quot;,      xml_insertChildAfter,      2,0,0},
+    {&quot;insertChildBefore&quot;,     xml_insertChildBefore,     2,0,0},
+    {js_length_str,           xml_length,                0,0,0},
+    {js_localName_str,        xml_localName,             0,0,0},
+    {js_name_str,             xml_name,                  0,0,0},
+    {js_namespace_str,        xml_namespace,             1,0,0},
+    {&quot;namespaceDeclarations&quot;, xml_namespaceDeclarations, 0,0,0},
+    {&quot;nodeKind&quot;,              xml_nodeKind,              0,0,0},
+    {&quot;normalize&quot;,             xml_normalize,             0,0,0},
+    {js_xml_parent_str,       xml_parent,                0,0,0},
+    {&quot;processingInstructions&quot;,xml_processingInstructions,1,0,0},
+    {&quot;prependChild&quot;,          xml_prependChild,          1,0,0},
+    {&quot;propertyIsEnumerable&quot;,  xml_propertyIsEnumerable,  1,0,0},
+    {&quot;removeNamespace&quot;,       xml_removeNamespace,       1,0,0},
+    {&quot;replace&quot;,               xml_replace,               2,0,0},
+    {&quot;setChildren&quot;,           xml_setChildren,           1,0,0},
+    {&quot;setLocalName&quot;,          xml_setLocalName,          1,0,0},
+    {&quot;setName&quot;,               xml_setName,               1,0,0},
+    {&quot;setNamespace&quot;,          xml_setNamespace,          1,0,0},
+    {js_text_str,             xml_text,                  0,0,0},
+    {js_toString_str,         xml_toString,              0,0,0},
+    {js_toXMLString_str,      xml_toXMLString,           0,0,0},
+    {js_toSource_str,         xml_toXMLString,           0,0,0},
+    {js_valueOf_str,          xml_valueOf,               0,0,0},
     {0,0,0,0,0}
 };
 
@@ -7615,7 +7562,7 @@
 
     obj = js_NewObject(cx, &amp;js_XMLClass, NULL, NULL);
     if (!obj || !JS_SetPrivate(cx, obj, xml)) {
-        cx-&gt;newborn[GCX_OBJECT] = NULL;
+        cx-&gt;weakRoots.newborn[GCX_OBJECT] = NULL;
         return NULL;
     }
     METER(xml_stats.xmlobj);
@@ -7689,7 +7636,6 @@
 js_InitXMLClass(JSContext *cx, JSObject *obj)
 {
     JSObject *proto, *pobj, *ctor;
-    JSFunctionSpec *fs;
     JSFunction *fun;
     JSXML *xml;
     JSProperty *prop;
@@ -7702,27 +7648,11 @@
 
     /* Define the XML class constructor and prototype. */
     proto = JS_InitClass(cx, obj, NULL, &amp;js_XMLClass, XML, 1,
-                         NULL, NULL,
+                         NULL, xml_methods,
                          xml_static_props, xml_static_methods);
     if (!proto)
         return NULL;
 
-    /*
-     * XXX Hack alert: expand JS_DefineFunctions here to copy fs-&gt;extra into
-     * fun-&gt;spare, clearing fun-&gt;extra.  No xml_methods require extra local GC
-     * roots allocated after actual arguments on the VM stack, but we need a
-     * way to tell which methods work only on XML objects, which work only on
-     * XMLList objects, and which work on either.
-     */
-    for (fs = xml_methods; fs-&gt;name; fs++) {
-        fun = JS_DefineFunction(cx, proto, fs-&gt;name, fs-&gt;call, fs-&gt;nargs,
-                                fs-&gt;flags);
-        if (!fun)
-            return NULL;
-        fun-&gt;extra = 0;
-        fun-&gt;spare = fs-&gt;extra;
-    }
-
     xml = js_NewXML(cx, JSXML_CLASS_TEXT);
     if (!xml || !JS_SetPrivate(cx, proto, xml))
         return NULL;
@@ -8007,7 +7937,7 @@
 
         obj = js_NewObject(cx, &amp;js_AnyNameClass, NULL, NULL);
         if (!obj || !JS_SetPrivate(cx, obj, qn)) {
-            cx-&gt;newborn[GCX_OBJECT] = NULL;
+            cx-&gt;weakRoots.newborn[GCX_OBJECT] = NULL;
             return JS_FALSE;
         }
         qn-&gt;object = obj;
@@ -8082,6 +8012,53 @@
     return GetProperty(cx, obj, name, vp);
 }
 
+static JSBool
+js_GetXMLFunction(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
+{
+    JSObject *target;
+    JSXML *xml;
+    JSTempValueRooter tvr;
+    JSBool ok;
+
+    JS_ASSERT(OBJECT_IS_XML(cx, obj));
+
+    /* After this point, control must flow through label out: to exit. */
+    JS_PUSH_TEMP_ROOT_OBJECT(cx, NULL, &amp;tvr);
+
+    /*
+     * See comments before xml_lookupProperty about the need for the proto
+     * chain lookup.
+     */
+    target = obj;
+    for (;;) {
+        ok = js_GetProperty(cx, target, id, vp);
+        if (!ok)
+            goto out;
+        if (JSVAL_IS_FUNCTION(cx, *vp)) {
+            ok = JS_TRUE;
+            goto out;
+        }
+        target = OBJ_GET_PROTO(cx, target);
+        if (target == NULL)
+            break;
+        tvr.u.object = target;
+    }
+
+    xml = (JSXML *) JS_GetPrivate(cx, obj);
+    if (HasSimpleContent(xml)) {
+        /* Search in String.prototype to implement 11.2.2.1 Step 3(f). */
+        ok = js_GetClassPrototype(cx, js_String_str, &amp;tvr.u.object);
+        if (!ok)
+            goto out;
+        JS_ASSERT(tvr.u.object);
+        ok = OBJ_GET_PROPERTY(cx, tvr.u.object, id, vp);
+    }
+
+  out:
+    JS_POP_TEMP_ROOT(cx, &amp;tvr);
+    return ok;
+}
+
 JSBool
 js_SetXMLProperty(JSContext *cx, JSObject *obj, jsval name, jsval *vp)
 {


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000571.html">[Avidemux-svn-commit] r3291 -	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs
</A></li>
	<LI>Next message: <A HREF="000573.html">[Avidemux-svn-commit] r3293 -	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#572">[ date ]</a>
              <a href="thread.html#572">[ thread ]</a>
              <a href="subject.html#572">[ subject ]</a>
              <a href="author.html#572">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
