<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r4693 - in branches/avidemux_2.6_branch_mean:	avidemux/ADM_audio avidemux/ADM_audioFilter/include	avidemux/ADM_audioFilter/src avidemux/ADM_audiofilter	avidemux/ADM_editor avidemux/ADM_userInterfaces/ADM_commonUI	plugins/ADM_demuxers/MpegPS
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2009-March/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r4693%20-%20in%20branches/avidemux_2.6_branch_mean%3A%0A%09avidemux/ADM_audio%20avidemux/ADM_audioFilter/include%0A%09avidemux/ADM_audioFilter/src%20avidemux/ADM_audiofilter%0A%09avidemux/ADM_editor%20avidemux/ADM_userInterfaces/ADM_commonUI%0A%09plugins/ADM_demuxers/MpegPS&In-Reply-To=%3C200903150957.n2F9vbCH029668%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001922.html">
   <LINK REL="Next"  HREF="001924.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r4693 - in branches/avidemux_2.6_branch_mean:	avidemux/ADM_audio avidemux/ADM_audioFilter/include	avidemux/ADM_audioFilter/src avidemux/ADM_audiofilter	avidemux/ADM_editor avidemux/ADM_userInterfaces/ADM_commonUI	plugins/ADM_demuxers/MpegPS</H1>
    <B>mean at BerliOS</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r4693%20-%20in%20branches/avidemux_2.6_branch_mean%3A%0A%09avidemux/ADM_audio%20avidemux/ADM_audioFilter/include%0A%09avidemux/ADM_audioFilter/src%20avidemux/ADM_audiofilter%0A%09avidemux/ADM_editor%20avidemux/ADM_userInterfaces/ADM_commonUI%0A%09plugins/ADM_demuxers/MpegPS&In-Reply-To=%3C200903150957.n2F9vbCH029668%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r4693 - in branches/avidemux_2.6_branch_mean:	avidemux/ADM_audio avidemux/ADM_audioFilter/include	avidemux/ADM_audioFilter/src avidemux/ADM_audiofilter	avidemux/ADM_editor avidemux/ADM_userInterfaces/ADM_commonUI	plugins/ADM_demuxers/MpegPS">mean at mail.berlios.de
       </A><BR>
    <I>Sun Mar 15 10:57:37 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001922.html">[Avidemux-svn-commit] r4692 - in branches/avidemux_2.6_branch_mean:	avidemux avidemux/ADM_coreDemuxer/include	avidemux/ADM_coreDemuxer/src cmake
</A></li>
        <LI>Next message: <A HREF="001924.html">[Avidemux-svn-commit] r4694 - in	branches/avidemux_2.6_branch_mean/avidemux:	ADM_audioFilter/include ADM_audioFilter/src ADM_audiofilter
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1923">[ date ]</a>
              <a href="thread.html#1923">[ thread ]</a>
              <a href="subject.html#1923">[ subject ]</a>
              <a href="author.html#1923">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2009-03-15 10:57:35 +0100 (Sun, 15 Mar 2009)
New Revision: 4693

Added:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_SRC.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_conf.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_dolby.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_film2pal.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_limiter.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_limiter_param.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_mixer.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_normalize.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_normalize_param.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter_mixer.cpp
Removed:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_SRC.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_dolby.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_film2pal.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_limiter.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_limiter_param.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_mixer.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_mixer.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_normalize.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_normalize_param.h
Modified:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audio/audiogen.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiodeng_buildfilters.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_buildchain.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edPtsDts.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_audioFilter.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/ADM_ps.cpp
Log:
[Audio] Begin replacing old filterChain with new

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_audio/audiogen.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audio/audiogen.cpp	2009-03-15 09:57:32 UTC (rev 4692)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audio/audiogen.cpp	2009-03-15 09:57:35 UTC (rev 4693)
@@ -532,23 +532,5 @@
 
 }
 #endif
-/**
- * 	\fn ADM_audioCompareChannelMapping
- *  \brief return true if the two channel mapping are identical, false else.
- */
-bool ADM_audioCompareChannelMapping(WAVHeader *wh1, WAVHeader *wh2,CHANNEL_TYPE *map1,CHANNEL_TYPE *map2)
-{
-	if(wh1-&gt;channels != wh2-&gt;channels) return false; // cannot be identical..
-		
-			for (int j = 0; j &lt; wh1-&gt;channels; j++)
-			{
-				if (map1[j] != map2[j]) 
-				{
-					return false;
-					
-				}
-			}
-	return true;
-}
 
 //

Copied: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_SRC.h (from rev 4692, branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_SRC.h)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_SRC.h	2009-03-15 09:57:32 UTC (rev 4692)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_SRC.h	2009-03-15 09:57:35 UTC (rev 4693)
@@ -0,0 +1,30 @@
+/***************************************************************************
+    copyright            : (C) 2006 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef AUDM_AUDIO_SRC_H
+#define AUDM_AUDIO_SRC_H
+#include &quot;ADM_audioResample.h&quot;
+class AUDMAudioFilterSrc : public AUDMAudioFilter
+{
+  protected:
+      uint32_t          targetFrequency;
+      uint32_t          engaged;
+      ADM_resample      resampler; 
+  public:
+
+    ~AUDMAudioFilterSrc();
+    AUDMAudioFilterSrc(AUDMAudioFilter *instream,uint32_t  tgt);
+    uint32_t   fill(uint32_t max,float *output,AUD_Status *status);
+};
+#endif

Copied: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_conf.h (from rev 4692, branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_SRC.h)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_SRC.h	2009-03-15 09:57:32 UTC (rev 4692)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_conf.h	2009-03-15 09:57:35 UTC (rev 4693)
@@ -0,0 +1,49 @@
+/***************************************************************************
+            \file audiofilter_conf.h
+            \brief Manage configuration
+              (c) 2006 Mean , <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef  ADM_audiofilter_conf_h
+#define  ADM_audiofilter_conf_h
+
+#include &quot;ADM_audioFilter.h&quot;
+#include &quot;audiofilter.h&quot;
+#include &quot;audiofilter_mixer.h&quot;
+
+/**
+    \class ADM_AUDIOFILTER_CONFIG
+*/
+class ADM_AUDIOFILTER_CONFIG
+{
+public    :
+
+    ADM_AUDIOFILTER_CONFIG(void)
+        {
+                startTimeInUs=0;
+                shiftInMs=0;
+                mixerEnabled=false;
+                mixerConf=CHANNEL_STEREO;
+
+        }
+
+    uint64_t     startTimeInUs;
+    int32_t      shiftInMs;
+    
+    bool         mixerEnabled;
+    CHANNEL_CONF mixerConf;
+
+
+
+};
+
+#endif
\ No newline at end of file

Copied: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_dolby.h (from rev 4692, branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_dolby.h)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_dolby.h	2009-03-15 09:57:32 UTC (rev 4692)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_dolby.h	2009-03-15 09:57:35 UTC (rev 4693)
@@ -0,0 +1,20 @@
+//
+// C++ Interface: audiofilter_dolby
+//
+// Description: 
+//
+//
+// Author: Mihail Zenkov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">kreator at tut.by</A>&gt;, (C) 2006
+//
+// Copyright: See COPYING file that comes with this distribution
+//
+//
+#ifndef AUDM_DOLBY_H
+#define AUDM_DOLBY_H
+
+extern void DolbyInit();
+extern void DolbySkip(bool on);
+extern float DolbyShiftLeft(float isamp);
+extern float DolbyShiftRight(float isamp);
+
+#endif

Copied: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_film2pal.h (from rev 4692, branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_film2pal.h)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_film2pal.h	2009-03-15 09:57:32 UTC (rev 4692)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_film2pal.h	2009-03-15 09:57:35 UTC (rev 4693)
@@ -0,0 +1,45 @@
+/***************************************************************************
+   
+    copyright            : (C) 2006 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef AUDIO_F_FILM2PAL_H
+#define AUDIO_F_FILM2PAL_H
+
+#include &quot;ADM_audioFilter.h&quot;
+#include &quot;audiofilter_SRC.h&quot;
+#define BLK_SIZE 512
+
+class AUDMAudioFilterFilmChange : public AUDMAudioFilter
+{
+  protected:
+    ADM_resample          resampler;
+  public:
+                          AUDMAudioFilterFilmChange(AUDMAudioFilter *previous,uint32_t from, uint32_t to);
+    virtual                ~AUDMAudioFilterFilmChange();
+    virtual    uint32_t   fill(uint32_t max,float *output,AUD_Status *status);
+};
+class AUDMAudioFilterPal2Film : public AUDMAudioFilterFilmChange
+{
+  protected:
+  public:
+                            AUDMAudioFilterPal2Film(AUDMAudioFilter *previous);
+};
+class AUDMAudioFilterFilm2Pal : public AUDMAudioFilterFilmChange
+{
+  protected:
+  public:
+                            AUDMAudioFilterFilm2Pal(AUDMAudioFilter *previous);
+};
+
+#endif

Copied: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_limiter.h (from rev 4692, branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_limiter.h)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_limiter.h	2009-03-15 09:57:32 UTC (rev 4692)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_limiter.h	2009-03-15 09:57:35 UTC (rev 4693)
@@ -0,0 +1,51 @@
+/***************************************************************************
+   
+    copyright            : (C) 2006 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef AUDIO_F_LIMITER_H
+#define AUDIO_F_LIMITER_H
+
+#include &quot;ADM_audioFilter.h&quot;
+#include &quot;audiofilter_limiter_param.h&quot;
+class AUDMAudioFilterLimiter : public AUDMAudioFilter
+{
+  protected:
+    uint8_t            filled;
+    DRCparam           _param;			
+    float              mCircle[DRC_WINDOW];
+    float              mLevelCircle[DRC_WINDOW];	
+    int                mCircleSize;
+    int                mCirclePos;	
+    float              mRMSSum;
+    float              mThreshold;
+    float              mGain;
+    float              mAttackFactor;
+    float              mDecayFactor;	
+    float              mLastLevel;
+    float              mGainDB;
+    float              AvgCircle(float value);
+    void               Follow(float x, float *outEnv, int maxBack);
+    float              DoCompression(float value, float env);
+    void               drc_cleanup(void);
+#define ONE_CHUNK 1000
+#define DELIM_WINDOW_SIZE ONE_CHUNK/2		 
+    float              follow[DELIM_WINDOW_SIZE];
+    float              value[DELIM_WINDOW_SIZE];
+
+  public:
+                          AUDMAudioFilterLimiter(AUDMAudioFilter *previous, DRCparam *param);
+    virtual                ~AUDMAudioFilterLimiter();
+    virtual    uint32_t   fill(uint32_t max,float *output,AUD_Status *status);
+};
+#endif

Copied: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_limiter_param.h (from rev 4692, branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_limiter_param.h)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_limiter_param.h	2009-03-15 09:57:32 UTC (rev 4692)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_limiter_param.h	2009-03-15 09:57:35 UTC (rev 4693)
@@ -0,0 +1,25 @@
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+
+#ifndef LIMITER_PARAM_H
+#define LIMITER_PARAM_H
+#define DRC_WINDOW 100
+typedef struct 
+{
+  uint32_t mUseGain;
+  double   mFloor;
+  double   mAttackTime;
+  double   mDecayTime;
+  double   mRatio;
+  double   mThresholdDB;
+   // double   mGainDB;  
+}DRCparam;
+
+#endif

Copied: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_mixer.h (from rev 4692, branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_SRC.h)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_SRC.h	2009-03-15 09:57:32 UTC (rev 4692)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_mixer.h	2009-03-15 09:57:35 UTC (rev 4693)
@@ -0,0 +1,33 @@
+/***************************************************************************
+            \file audiofilter_mixer
+            \brief Mixer
+              (c) 2006 Mean , <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef AUDM_AUDIO_MIXER_H
+#define AUDM_AUDIO_MIXER_H
+class AUDMAudioFilterMixer : public AUDMAudioFilter
+{
+    protected:
+        CHANNEL_CONF    _output;
+        CHANNEL_CONF    _input;
+        // output channel mapping
+        CHANNEL_TYPE outputChannelMapping[MAX_CHANNELS];
+    public:
+
+      ~AUDMAudioFilterMixer();
+      AUDMAudioFilterMixer(AUDMAudioFilter *instream,CHANNEL_CONF out);
+      uint32_t   fill(uint32_t max,float *output,AUD_Status *status);
+      // That filter changes its output channel mapping...
+      virtual   CHANNEL_TYPE    *getChannelMapping(void );
+};
+#endif

Copied: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_normalize.h (from rev 4692, branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_normalize.h)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_normalize.h	2009-03-15 09:57:32 UTC (rev 4692)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_normalize.h	2009-03-15 09:57:35 UTC (rev 4693)
@@ -0,0 +1,18 @@
+#ifndef AUDIO_F_NORMALIZE_H
+#define AUDIO_F_NORMALIZE_H
+
+#include &quot;ADM_audioFilter.h&quot;
+class AUDMAudioFilterNormalize : public AUDMAudioFilter
+{
+  protected:
+              float       _ratio;
+              uint32_t    _scanned;
+              uint8_t     preprocess(void);
+  public:
+    // gainDB10 is the gain in DB multiplied by 10
+    // 0 meaning automatic
+                          AUDMAudioFilterNormalize(AUDMAudioFilter *previous,GAINparam *param);
+    virtual                ~AUDMAudioFilterNormalize();
+    virtual    uint32_t   fill(uint32_t max,float *output,AUD_Status *status);
+};
+#endif

Copied: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_normalize_param.h (from rev 4692, branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_normalize_param.h)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_normalize_param.h	2009-03-15 09:57:32 UTC (rev 4692)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_normalize_param.h	2009-03-15 09:57:35 UTC (rev 4693)
@@ -0,0 +1,28 @@
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+
+#ifndef GAIN_PARAM_H
+#define GAIN_PARAM_H
+
+typedef enum 
+{
+  ADM_NO_GAIN,
+  ADM_GAIN_AUTOMATIC,
+  ADM_GAIN_MANUAL
+  
+}ADM_GAINMode;
+
+typedef struct GAINparam
+{
+  ADM_GAINMode mode;
+  int32_t gain10;
+}GAINparam;
+
+#endif

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/CMakeLists.txt	2009-03-15 09:57:32 UTC (rev 4692)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/CMakeLists.txt	2009-03-15 09:57:35 UTC (rev 4693)
@@ -1,6 +1,7 @@
 SET(ADM_audioFilter_SRCS
 audiofilter_bridge.cpp
 audiofilter_access.cpp
+audiofilter_mixer.cpp
 audiofilter.cpp
 )
 ADD_LIBRARY(ADM_audioFilter STATIC ${ADM_audioFilter_SRCS})

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter.cpp	2009-03-15 09:57:32 UTC (rev 4692)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter.cpp	2009-03-15 09:57:35 UTC (rev 4693)
@@ -20,9 +20,14 @@
 #include &quot;audiofilter_bridge.h&quot;
 #include &quot;audiofilter_access.h&quot;
 #include &quot;audiofilter_internal.h&quot;
+#include &quot;audiofilter_conf.h&quot;
 
 VectorOfAudioFilter PlaybackVector;
 extern ADM_Composer *video_body;
+
+//
+static bool ADM_buildFilterChain(VectorOfAudioFilter *vec,ADM_AUDIOFILTER_CONFIG *config);
+static bool ADM_emptyFilterChain(VectorOfAudioFilter *vec);
 /**
         \fn createPlaybackFilter
         \brief Create a float output filter for playback
@@ -31,14 +36,16 @@
 */
 AUDMAudioFilter *createPlaybackFilter(uint64_t startTime,int32_t shift)
 {
-AUDMAudioFilter *nw;
-    ADM_assert(0==PlaybackVector.size());
-    // The First one is always the bridge
-    nw=new AUDMAudioFilter_Bridge(video_body,(uint32_t)( startTime/1000),shift);
-    PlaybackVector.push_back(nw);
-
     //
-int last=PlaybackVector.size();
+    ADM_AUDIOFILTER_CONFIG playback;
+    playback.startTimeInUs=startTime;
+    playback.shiftInMs=shift;
+    playback.mixerEnabled=true;
+    playback.mixerConf=CHANNEL_STEREO;
+    //
+    ADM_buildFilterChain(&amp;PlaybackVector,&amp;playback);
+    //
+    int last=PlaybackVector.size();
     ADM_assert(last);
     return PlaybackVector[last-1];
 }
@@ -50,14 +57,66 @@
 bool            destroyPlaybackFilter(void)
 {
 
-    while(PlaybackVector.size())
+    ADM_emptyFilterChain(&amp;PlaybackVector);
+    return true;
+
+}
+/***********************************************************************/
+/**
+    \fn ADM_buildFilterChain
+    \brief Create a filterchain
+*/
+bool ADM_buildFilterChain(VectorOfAudioFilter *vec,ADM_AUDIOFILTER_CONFIG *config)
+{
+    // make sure the chain is empty...
+    AUDMAudioFilter *last=NULL;
+    ADM_emptyFilterChain(vec);
+    
+    // Bridge
+    AUDMAudioFilter_Bridge *nw=new AUDMAudioFilter_Bridge(video_body,(uint32_t)( config-&gt;startTimeInUs/1000),
+                                                                                config-&gt;shiftInMs);
+    vec-&gt;push_back(nw);
+    last=nw;
+
+    // Mixer
+    if(config-&gt;mixerEnabled)
     {
-        delete PlaybackVector[0];
-        PlaybackVector.erase(PlaybackVector.begin());
-
+        AUDMAudioFilterMixer *mixer=new AUDMAudioFilterMixer(last,config-&gt;mixerConf);
+        vec-&gt;push_back(mixer);
+        last=mixer;
     }
     return true;
-
 }
+/**
+    \fn ADM_emptyFilterChain
+    \brief Destroy a filter chain
+*/
+bool ADM_emptyFilterChain(VectorOfAudioFilter *vec)
+{
+   while(vec-&gt;size())
+    {
+        delete (*vec)[0];
+        vec-&gt;erase(vec-&gt;begin());
+    }
+    return true;
+}
+/**
+ * 	\fn ADM_audioCompareChannelMapping
+ *  \brief return true if the two channel mapping are identical, false else.
+ */
+bool ADM_audioCompareChannelMapping(WAVHeader *wh1, WAVHeader *wh2,CHANNEL_TYPE *map1,CHANNEL_TYPE *map2)
+{
+	if(wh1-&gt;channels != wh2-&gt;channels) return false; // cannot be identical..
+		
+			for (int j = 0; j &lt; wh1-&gt;channels; j++)
+			{
+				if (map1[j] != map2[j]) 
+				{
+					return false;
+					
+				}
+			}
+	return true;
+}
 
 // EOF
\ No newline at end of file

Copied: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter_mixer.cpp (from rev 4692, branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_mixer.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_mixer.cpp	2009-03-15 09:57:32 UTC (rev 4692)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter_mixer.cpp	2009-03-15 09:57:35 UTC (rev 4693)
@@ -0,0 +1,605 @@
+/***************************************************************************
+         Downmixer
+ ***************************************************************************/
+ 
+ 
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include &quot;ADM_default.h&quot;
+
+#include &quot;ADM_audioFilter.h&quot;
+#include &quot;audiofilter_mixer.h&quot;
+#include &quot;audiofilter_dolby.h&quot;
+#include &lt;math.h&gt;
+
+AUDMAudioFilterMixer::AUDMAudioFilterMixer(AUDMAudioFilter *instream,CHANNEL_CONF out):AUDMAudioFilter (instream)
+{
+    _output=out;
+    _previous-&gt;rewind();     // rewind
+    ADM_assert(_output&lt;CHANNEL_LAST);
+    
+    
+    double d;               // Update duration
+    d=_wavHeader.byterate;
+    d/=_wavHeader.channels;
+
+	switch (_output) {
+		case CHANNEL_MONO:
+			_wavHeader.channels = 1;
+			outputChannelMapping[0] = ADM_CH_MONO;
+		break;
+		case CHANNEL_STEREO:
+			_wavHeader.channels = 2;
+			outputChannelMapping[0] = ADM_CH_FRONT_LEFT;
+			outputChannelMapping[1] = ADM_CH_FRONT_RIGHT;
+		break;
+		case CHANNEL_2F_1R:
+			_wavHeader.channels = 3;
+			outputChannelMapping[0] = ADM_CH_FRONT_LEFT;
+			outputChannelMapping[1] = ADM_CH_FRONT_RIGHT;
+			outputChannelMapping[2] = ADM_CH_REAR_CENTER;
+		break;
+		case CHANNEL_3F:
+			_wavHeader.channels = 3;
+			outputChannelMapping[0] = ADM_CH_FRONT_LEFT;
+			outputChannelMapping[1] = ADM_CH_FRONT_RIGHT;
+			outputChannelMapping[2] = ADM_CH_FRONT_CENTER;
+		break;
+		case CHANNEL_3F_1R:
+			_wavHeader.channels = 4;
+			outputChannelMapping[0] = ADM_CH_FRONT_LEFT;
+			outputChannelMapping[1] = ADM_CH_FRONT_RIGHT;
+			outputChannelMapping[2] = ADM_CH_REAR_CENTER;
+			outputChannelMapping[3] = ADM_CH_FRONT_CENTER;
+		break;
+		case CHANNEL_2F_2R:
+			_wavHeader.channels = 4;
+			outputChannelMapping[0] = ADM_CH_FRONT_LEFT;
+			outputChannelMapping[1] = ADM_CH_FRONT_RIGHT;
+			outputChannelMapping[2] = ADM_CH_REAR_LEFT;
+			outputChannelMapping[3] = ADM_CH_REAR_RIGHT;
+		break;
+		case CHANNEL_3F_2R:
+			_wavHeader.channels = 5;
+			outputChannelMapping[0] = ADM_CH_FRONT_LEFT;
+			outputChannelMapping[1] = ADM_CH_FRONT_RIGHT;
+			outputChannelMapping[2] = ADM_CH_REAR_LEFT;
+			outputChannelMapping[3] = ADM_CH_REAR_RIGHT;
+			outputChannelMapping[4] = ADM_CH_FRONT_CENTER;
+		break;
+		case CHANNEL_3F_2R_LFE:
+			_wavHeader.channels = 6;
+			outputChannelMapping[0] = ADM_CH_FRONT_LEFT;
+			outputChannelMapping[1] = ADM_CH_FRONT_RIGHT;
+			outputChannelMapping[2] = ADM_CH_REAR_LEFT;
+			outputChannelMapping[3] = ADM_CH_REAR_RIGHT;
+			outputChannelMapping[4] = ADM_CH_FRONT_CENTER;
+			outputChannelMapping[5] = ADM_CH_LFE;
+		break;
+		case CHANNEL_DOLBY_PROLOGIC:
+		case CHANNEL_DOLBY_PROLOGIC2:
+			_wavHeader.channels = 2;
+			outputChannelMapping[0] = ADM_CH_FRONT_LEFT;
+			outputChannelMapping[1] = ADM_CH_FRONT_RIGHT;
+//			DolbyInit();
+		break;
+	}
+
+    d*=_wavHeader.channels;
+    _wavHeader.byterate = (uint32_t)ceil(d);
+
+
+//    printf(&quot;[mixer]Input channels : %u : %u \n&quot;,_previous-&gt;getInfo()-&gt;channels,input_channels);
+//    printf(&quot;[mixer]Out   channels : %u : %u \n&quot;,_wavHeader.channels,ADM_CH_annel_mixer[_output]);
+
+};
+/**
+ * 	\fn getChannelMapping
+ *  \brief That filter changes the channel mapping, output its own
+ */
+CHANNEL_TYPE    *AUDMAudioFilterMixer::getChannelMapping(void ) 
+{
+		return this-&gt;outputChannelMapping;
+}
+AUDMAudioFilterMixer::~AUDMAudioFilterMixer()
+{
+};
+
+static int MCOPY(float *in,float *out,uint32_t nbSample,uint32_t chan)
+{
+    memcpy(out,in,nbSample*chan*sizeof(float));
+    return nbSample*chan;
+    
+}
+
+static int MNto1(float *in,float *out,uint32_t nbSample,uint32_t chan,CHANNEL_TYPE *chanMap)
+{
+float sum;
+int den=(chan+1)&amp;0xfe;
+    for(int i=0;i&lt;nbSample;i++)
+    {
+        sum=0;
+        for(int j=0;j&lt;chan;j++)
+          sum+=in[j];
+        out[0]=sum/(float)den;
+        out++;
+        in+=chan;
+    }
+    return nbSample;
+    
+}
+
+static int MStereo(float *in,float *out,uint32_t nbSample,uint32_t chan,CHANNEL_TYPE *chanMap)
+{
+	memset(out, 0, sizeof(float) * nbSample * 2);
+
+	for (int i = 0; i &lt; nbSample; i++) {
+		for (int c = 0; c &lt; chan; c++) {
+			switch (chanMap[c]) {
+				case ADM_CH_MONO:
+				case ADM_CH_FRONT_CENTER:
+				case ADM_CH_REAR_CENTER:
+				case ADM_CH_LFE:
+					out[0]  += *in * 0.707;
+					out[1]  += *in * 0.707;
+				break;
+				case ADM_CH_FRONT_LEFT:
+				case ADM_CH_REAR_LEFT:
+				case ADM_CH_SIDE_LEFT:
+					out[0]  += *in;
+				break;
+				case ADM_CH_FRONT_RIGHT:
+				case ADM_CH_REAR_RIGHT:
+				case ADM_CH_SIDE_RIGHT:
+					out[1]  += *in;
+				break;
+			}
+			in++;
+		}
+		out += 2;
+	}
+
+	return nbSample*2;
+}
+
+static int M2F1R(float *in,float *out,uint32_t nbSample,uint32_t chan,CHANNEL_TYPE *chanMap)
+{
+	memset(out, 0, sizeof(float) * nbSample * 3);
+
+	for (int i = 0; i &lt; nbSample; i++) {
+		for (int c = 0; c &lt; chan; c++) {
+			switch (chanMap[c]) {
+				case ADM_CH_MONO:
+				case ADM_CH_FRONT_CENTER:
+					out[0]  += *in * 0.707;
+					out[1]  += *in * 0.707;
+				break;
+				case ADM_CH_FRONT_LEFT:
+					out[0]  += *in;
+				break;
+				case ADM_CH_FRONT_RIGHT:
+					out[1]  += *in;
+				break;
+				case ADM_CH_REAR_LEFT:
+				case ADM_CH_REAR_RIGHT:
+				case ADM_CH_REAR_CENTER:
+					out[2]  += *in;
+				break;
+				case ADM_CH_LFE:
+					out[0]  += *in * 0.595;
+					out[1]  += *in * 0.595;
+					out[2]  += *in * 0.595;
+				break;
+				case ADM_CH_SIDE_LEFT:
+					out[0]  += *in * 0.707;
+					out[2]  += *in * 0.707;
+				break;
+				case ADM_CH_SIDE_RIGHT:
+					out[1]  += *in * 0.707;
+					out[2]  += *in * 0.707;
+				break;
+			}
+			in++;
+		}
+		out += 3;
+	}
+
+	return nbSample * 3;
+}
+
+static int M3F(float *in,float *out,uint32_t nbSample,uint32_t chan,CHANNEL_TYPE *chanMap)
+{
+	memset(out, 0, sizeof(float) * nbSample * 3);
+
+	for (int i = 0; i &lt; nbSample; i++) {
+		for (int c = 0; c &lt; chan; c++) {
+			switch (chanMap[c]) {
+				case ADM_CH_MONO:
+				case ADM_CH_FRONT_CENTER:
+				case ADM_CH_REAR_CENTER:
+					out[2]  += *in;
+				break;
+				case ADM_CH_FRONT_LEFT:
+				case ADM_CH_REAR_LEFT:
+				case ADM_CH_SIDE_LEFT:
+					out[0]  += *in;
+				break;
+				case ADM_CH_FRONT_RIGHT:
+				case ADM_CH_REAR_RIGHT:
+				case ADM_CH_SIDE_RIGHT:
+					out[1]  += *in;
+				break;
+				case ADM_CH_LFE:
+					out[0]  += *in * 0.595;
+					out[1]  += *in * 0.595;
+					out[2]  += *in * 0.595;
+				break;
+			}
+			in++;
+		}
+		out += 3;
+	}
+
+	return nbSample * 3;
+}
+
+static int M3F1R(float *in,float *out,uint32_t nbSample,uint32_t chan,CHANNEL_TYPE *chanMap)
+{
+	memset(out, 0, sizeof(float) * nbSample * 4);
+
+	for (int i = 0; i &lt; nbSample; i++) {
+		for (int c = 0; c &lt; chan; c++) {
+			switch (chanMap[c]) {
+				case ADM_CH_MONO:
+				case ADM_CH_FRONT_CENTER:
+					out[3]  += *in;
+				break;
+				case ADM_CH_REAR_CENTER:
+				case ADM_CH_REAR_LEFT:
+				case ADM_CH_REAR_RIGHT:
+					out[2]  += *in;
+				break;
+				case ADM_CH_FRONT_LEFT:
+					out[0]  += *in;
+				break;
+				case ADM_CH_FRONT_RIGHT:
+					out[1]  += *in;
+				break;
+				case ADM_CH_LFE:
+					out[0]  += *in * 0.5;
+					out[1]  += *in * 0.5;
+					out[2]  += *in * 0.5;
+					out[3]  += *in * 0.5;
+				break;
+				case ADM_CH_SIDE_LEFT:
+					out[0]  += *in * 0.707;
+					out[2]  += *in * 0.707;
+				break;
+				case ADM_CH_SIDE_RIGHT:
+					out[1]  += *in * 0.707;
+					out[2]  += *in * 0.707;
+				break;
+			}
+			in++;
+		}
+		out += 4;
+	}
+
+	return nbSample * 4;
+}
+
+static int M2F2R(float *in,float *out,uint32_t nbSample,uint32_t chan,CHANNEL_TYPE *chanMap)
+{
+	memset(out, 0, sizeof(float) * nbSample * 4);
+
+	for (int i = 0; i &lt; nbSample; i++) {
+		for (int c = 0; c &lt; chan; c++) {
+			switch (chanMap[c]) {
+				case ADM_CH_MONO:
+				case ADM_CH_FRONT_CENTER:
+					out[0]  += *in * 0.707;
+					out[1]  += *in * 0.707;
+				break;
+				case ADM_CH_FRONT_LEFT:
+					out[0]  += *in;
+				break;
+				case ADM_CH_FRONT_RIGHT:
+					out[1]  += *in;
+				break;
+				case ADM_CH_REAR_LEFT:
+					out[2]  += *in;
+				break;
+				case ADM_CH_REAR_RIGHT:
+					out[3]  += *in;
+				break;
+				case ADM_CH_REAR_CENTER:
+					out[2]  += *in * 0.707;
+					out[3]  += *in * 0.707;
+				break;
+				case ADM_CH_LFE:
+					out[0]  += *in * 0.5;
+					out[1]  += *in * 0.5;
+					out[2]  += *in * 0.5;
+					out[3]  += *in * 0.5;
+				break;
+				case ADM_CH_SIDE_LEFT:
+					out[0]  += *in * 0.707;
+					out[2]  += *in * 0.707;
+				break;
+				case ADM_CH_SIDE_RIGHT:
+					out[1]  += *in * 0.707;
+					out[3]  += *in * 0.707;
+				break;
+			}
+			in++;
+		}
+		out += 4;
+	}
+
+	return nbSample * 4;
+}
+
+static int M3F2R(float *in,float *out,uint32_t nbSample,uint32_t chan,CHANNEL_TYPE *chanMap)
+{
+	memset(out, 0, sizeof(float) * nbSample * 5);
+
+	for (int i = 0; i &lt; nbSample; i++) {
+		for (int c = 0; c &lt; chan; c++) {
+			switch (chanMap[c]) {
+				case ADM_CH_MONO:
+				case ADM_CH_FRONT_CENTER:
+					out[4]  += *in;
+				break;
+				case ADM_CH_FRONT_LEFT:
+					out[0]  += *in;
+				break;
+				case ADM_CH_FRONT_RIGHT:
+					out[1]  += *in;
+				break;
+				case ADM_CH_REAR_LEFT:
+					out[2]  += *in;
+				break;
+				case ADM_CH_REAR_RIGHT:
+					out[3]  += *in;
+				break;
+				case ADM_CH_REAR_CENTER:
+					out[2]  += *in * 0.707;
+					out[3]  += *in * 0.707;
+				break;
+				case ADM_CH_LFE:
+					out[0]  += *in * 0.459;
+					out[1]  += *in * 0.459;
+					out[2]  += *in * 0.459;
+					out[3]  += *in * 0.459;
+					out[4]  += *in * 0.459;
+				break;
+				case ADM_CH_SIDE_LEFT:
+					out[0]  += *in * 0.707;
+					out[2]  += *in * 0.707;
+				break;
+				case ADM_CH_SIDE_RIGHT:
+					out[1]  += *in * 0.707;
+					out[3]  += *in * 0.707;
+				break;
+			}
+			in++;
+		}
+		out += 5;
+	}
+
+	return nbSample * 5;
+}
+
+static int M3F2RLFE(float *in,float *out,uint32_t nbSample,uint32_t chan,CHANNEL_TYPE *chanMap)
+{
+	memset(out, 0, sizeof(float) * nbSample * 6);
+
+	for (int i = 0; i &lt; nbSample; i++) {
+		for (int c = 0; c &lt; chan; c++) {
+			switch (chanMap[c]) {
+				case ADM_CH_MONO:
+				case ADM_CH_FRONT_CENTER:
+					out[4]  += *in;
+				break;
+				case ADM_CH_FRONT_LEFT:
+					out[0]  += *in;
+				break;
+				case ADM_CH_FRONT_RIGHT:
+					out[1]  += *in;
+				break;
+				case ADM_CH_REAR_LEFT:
+					out[2]  += *in;
+				break;
+				case ADM_CH_REAR_RIGHT:
+					out[3]  += *in;
+				break;
+				case ADM_CH_REAR_CENTER:
+					out[2]  += *in * 0.707;
+					out[3]  += *in * 0.707;
+				break;
+				case ADM_CH_LFE:
+					out[5]  += *in;
+				break;
+				case ADM_CH_SIDE_LEFT:
+					out[0]  += *in * 0.707;
+					out[2]  += *in * 0.707;
+				break;
+				case ADM_CH_SIDE_RIGHT:
+					out[1]  += *in * 0.707;
+					out[3]  += *in * 0.707;
+				break;
+			}
+			in++;
+		}
+		out += 6;
+	}
+
+	return nbSample * 6;
+}
+
+static int MDolbyProLogic(float *in,float *out,uint32_t nbSample,uint32_t chan,CHANNEL_TYPE *chanMap)
+{
+	memset(out, 0, sizeof(float) * nbSample * 2);
+#if 0
+	for (int i = 0; i &lt; nbSample; i++) {
+		for (int c = 0; c &lt; chan; c++) {
+			switch (chanMap[c]) {
+				case ADM_CH_MONO:
+				case ADM_CH_FRONT_CENTER:
+				case ADM_CH_LFE:
+					out[0]  += *in * 0.707;
+					out[1]  += *in * 0.707;
+				break;
+				case ADM_CH_FRONT_LEFT:
+					out[0]  += *in;
+				break;
+				case ADM_CH_FRONT_RIGHT:
+					out[1]  += *in;
+				break;
+				case ADM_CH_REAR_CENTER:
+				case ADM_CH_REAR_LEFT:
+				case ADM_CH_REAR_RIGHT:
+					out[0]  += DolbyShiftLeft(*in) * 0.707;
+					out[1]  += DolbyShiftRight(*in) * 0.707;
+				break;
+				case ADM_CH_SIDE_LEFT:
+					out[0]  += *in * 0.707;
+					out[0]  += DolbyShiftLeft(*in) * 0.707 * 0.707;
+					out[1]  += DolbyShiftRight(*in) * 0.707 * 0.707;
+				break;
+				case ADM_CH_SIDE_RIGHT:
+					out[1]  += *in * 0.5;
+					out[0]  += DolbyShiftLeft(*in) * 0.707 * 0.707;
+					out[1]  += DolbyShiftRight(*in) * 0.707 * 0.707;
+				break;
+			}
+			in++;
+		}
+		out += 2;
+	}
+#endif
+	return nbSample*2;
+}
+
+static int MDolbyProLogic2(float *in,float *out,uint32_t nbSample,uint32_t chan,CHANNEL_TYPE *chanMap)
+{
+	memset(out, 0, sizeof(float) * nbSample * 2);
+#if 0
+	for (int i = 0; i &lt; nbSample; i++) {
+		for (int c = 0; c &lt; chan; c++) {
+			switch (chanMap[c]) {
+				case ADM_CH_MONO:
+				case ADM_CH_FRONT_CENTER:
+				case ADM_CH_LFE:
+					out[0]  += *in * 0.707;
+					out[1]  += *in * 0.707;
+				break;
+				case ADM_CH_FRONT_LEFT:
+					out[0]  += *in;
+				break;
+				case ADM_CH_FRONT_RIGHT:
+					out[1]  += *in;
+				break;
+				case ADM_CH_REAR_CENTER:
+					out[0]  += DolbyShiftLeft(*in) * 0.707;
+					out[1]  += DolbyShiftRight(*in) * 0.707;
+				break;
+				case ADM_CH_REAR_LEFT:
+					out[0]  += DolbyShiftLeft(*in) * 0.8165;
+					out[1]  += DolbyShiftRight(*in) * 0.5774;
+				break;
+				case ADM_CH_REAR_RIGHT:
+					out[0]  += DolbyShiftLeft(*in) * 0.5774;
+					out[1]  += DolbyShiftRight(*in) * 0.8165;
+				break;
+				case ADM_CH_SIDE_LEFT:
+					out[0]  += *in * 0.707;
+					out[0]  += DolbyShiftLeft(*in) * 0.8165 * 0.707;
+					out[1]  += DolbyShiftRight(*in) * 0.5774 * 0.707;
+				break;
+				case ADM_CH_SIDE_RIGHT:
+					out[1]  += *in * 0.707;
+					out[0]  += DolbyShiftLeft(*in) * 0.5774 * 0.707;
+					out[1]  += DolbyShiftRight(*in) * 0.8165 * 0.707;
+				break;
+			}
+			in++;
+		}
+		out += 2;
+	}
+#endif
+	return nbSample*2;
+}
+
+
+typedef int MIXER(float *in,float *out,uint32_t nbSample,uint32_t chan,CHANNEL_TYPE *chanMap)  ;
+
+static MIXER *matrixCall[CHANNEL_LAST] = {
+NULL, MNto1, MStereo, M2F1R, M3F, M3F1R, M2F2R, M3F2R, M3F2RLFE, MDolbyProLogic, MDolbyProLogic2
+};
+//_____________________________________________
+uint32_t AUDMAudioFilterMixer::fill(uint32_t max,float *output,AUD_Status *status)
+{
+
+    uint32_t rd = 0;
+    uint8_t *in,*out;
+    int nbSampleMax=max/_wavHeader.channels;
+    uint8_t input_channels = _previous-&gt;getInfo()-&gt;channels;
+
+// Fill incoming buffer
+    shrink();
+    fillIncomingBuffer(status);
+    // Block not filled ?
+    if((_tail-_head)&lt;input_channels)
+    {
+      if(*status==AUD_END_OF_STREAM &amp;&amp; _head)
+      {
+        memset(&amp;_incomingBuffer[_head],0,sizeof(float) * input_channels);
+        _tail=_head+input_channels;
+        printf(&quot;[Mixer] Warning asked %u symbols\n&quot;,max);
+      }
+      else
+      {
+        return 0;
+      }
+    }
+    // How many ?
+
+    // Let's go
+    int processed=0;
+    int available=0;
+    if(!nbSampleMax)
+    {
+      printf(&quot;[Mixer] Warning max %u, channels %u\n&quot;,max,input_channels);
+    }
+    available=(_tail-_head)/input_channels; // nb Sample
+    ADM_assert(available);
+    if(available &gt; nbSampleMax) available=nbSampleMax;
+    
+    ADM_assert(available);
+    
+
+    // Now do the downsampling
+	if (_output == CHANNEL_INVALID || true==ADM_audioCompareChannelMapping(&amp;_wavHeader, _previous-&gt;getInfo(),
+			_previous-&gt;getChannelMapping(),outputChannelMapping))
+	{
+		
+		rd= (uint32_t)MCOPY(&amp;_incomingBuffer[_head],output,available,input_channels);
+	} else 
+	{
+		MIXER *call=matrixCall[_output];
+		rd= (uint32_t)call(&amp;_incomingBuffer[_head],output,available,input_channels,_previous-&gt;getChannelMapping());
+	}
+
+    _head+=available*input_channels;
+    return rd;
+    
+}
+

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/CMakeLists.txt	2009-03-15 09:57:32 UTC (rev 4692)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/CMakeLists.txt	2009-03-15 09:57:35 UTC (rev 4693)
@@ -4,7 +4,7 @@
 #	audiofilter_bridge.cpp         
 #        audiofilter_limiter.cpp    
 	audiofilter_buildchain.cpp     
-        audiofilter_mixer.cpp
+#        audiofilter_mixer.cpp
 #	audiofilter_normalize.cpp
 #        audiofilter_dolby.cpp          
 #        audiofilter_SRC.cpp

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiodeng_buildfilters.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiodeng_buildfilters.cpp	2009-03-15 09:57:32 UTC (rev 4692)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiodeng_buildfilters.cpp	2009-03-15 09:57:35 UTC (rev 4693)
@@ -19,8 +19,8 @@
 
 #include &quot;ADM_default.h&quot;
 
-#include &quot;ADM_audiofilter/audiofilter_limiter_param.h&quot;
-#include &quot;ADM_audiofilter/audiofilter_normalize_param.h&quot;
+#include &quot;audiofilter_limiter_param.h&quot;
+#include &quot;audiofilter_normalize_param.h&quot;
 
 #include &quot;ADM_audiofilter/audioeng_buildfilters.h&quot;
 

Deleted: branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_SRC.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_SRC.h	2009-03-15 09:57:32 UTC (rev 4692)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_SRC.h	2009-03-15 09:57:35 UTC (rev 4693)
@@ -1,30 +0,0 @@
-/***************************************************************************
-    copyright            : (C) 2006 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#ifndef AUDM_AUDIO_SRC_H
-#define AUDM_AUDIO_SRC_H
-#include &quot;ADM_audioResample.h&quot;
-class AUDMAudioFilterSrc : public AUDMAudioFilter
-{
-  protected:
-      uint32_t          targetFrequency;
-      uint32_t          engaged;
-      ADM_resample      resampler; 
-  public:
-
-    ~AUDMAudioFilterSrc();
-    AUDMAudioFilterSrc(AUDMAudioFilter *instream,uint32_t  tgt);
-    uint32_t   fill(uint32_t max,float *output,AUD_Status *status);
-};
-#endif

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_buildchain.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_buildchain.cpp	2009-03-15 09:57:32 UTC (rev 4692)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_buildchain.cpp	2009-03-15 09:57:35 UTC (rev 4693)
@@ -21,7 +21,7 @@
 
 #include &quot;audioencoder.h&quot;
 
-#include &quot;ADM_audiofilter/audiofilter_limiter_param.h&quot;
+#include &quot;audiofilter_limiter_param.h&quot;
 #include &quot;audiofilter_normalize_param.h&quot;
 #include &quot;audio_encoderWrapper.h&quot;
 

Deleted: branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_dolby.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_dolby.h	2009-03-15 09:57:32 UTC (rev 4692)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_dolby.h	2009-03-15 09:57:35 UTC (rev 4693)
@@ -1,20 +0,0 @@
-//
-// C++ Interface: audiofilter_dolby
-//
-// Description: 
-//
-//
-// Author: Mihail Zenkov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">kreator at tut.by</A>&gt;, (C) 2006
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-#ifndef AUDM_DOLBY_H
-#define AUDM_DOLBY_H
-
-extern void DolbyInit();
-extern void DolbySkip(bool on);
-extern float DolbyShiftLeft(float isamp);
-extern float DolbyShiftRight(float isamp);
-
-#endif

Deleted: branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_film2pal.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_film2pal.h	2009-03-15 09:57:32 UTC (rev 4692)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_film2pal.h	2009-03-15 09:57:35 UTC (rev 4693)
@@ -1,45 +0,0 @@
-/***************************************************************************
-   
-    copyright            : (C) 2006 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#ifndef AUDIO_F_FILM2PAL_H
-#define AUDIO_F_FILM2PAL_H
-
-#include &quot;ADM_audioFilter.h&quot;
-#include &quot;audiofilter_SRC.h&quot;
-#define BLK_SIZE 512
-
-class AUDMAudioFilterFilmChange : public AUDMAudioFilter
-{
-  protected:
-    ADM_resample          resampler;
-  public:
-                          AUDMAudioFilterFilmChange(AUDMAudioFilter *previous,uint32_t from, uint32_t to);
-    virtual                ~AUDMAudioFilterFilmChange();
-    virtual    uint32_t   fill(uint32_t max,float *output,AUD_Status *status);
-};
-class AUDMAudioFilterPal2Film : public AUDMAudioFilterFilmChange
-{
-  protected:
-  public:
-                            AUDMAudioFilterPal2Film(AUDMAudioFilter *previous);
-};
-class AUDMAudioFilterFilm2Pal : public AUDMAudioFilterFilmChange
-{
-  protected:
-  public:
-                            AUDMAudioFilterFilm2Pal(AUDMAudioFilter *previous);
-};
-
-#endif

Deleted: branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_limiter.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_limiter.h	2009-03-15 09:57:32 UTC (rev 4692)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_limiter.h	2009-03-15 09:57:35 UTC (rev 4693)
@@ -1,51 +0,0 @@
-/***************************************************************************
-   
-    copyright            : (C) 2006 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#ifndef AUDIO_F_LIMITER_H
-#define AUDIO_F_LIMITER_H
-
-#include &quot;ADM_audioFilter.h&quot;
-#include &quot;audiofilter_limiter_param.h&quot;
-class AUDMAudioFilterLimiter : public AUDMAudioFilter
-{
-  protected:
-    uint8_t            filled;
-    DRCparam           _param;			
-    float              mCircle[DRC_WINDOW];
-    float              mLevelCircle[DRC_WINDOW];	
-    int                mCircleSize;
-    int                mCirclePos;	
-    float              mRMSSum;
-    float              mThreshold;
-    float              mGain;
-    float              mAttackFactor;
-    float              mDecayFactor;	
-    float              mLastLevel;
-    float              mGainDB;
-    float              AvgCircle(float value);
-    void               Follow(float x, float *outEnv, int maxBack);
-    float              DoCompression(float value, float env);
-    void               drc_cleanup(void);
-#define ONE_CHUNK 1000
-#define DELIM_WINDOW_SIZE ONE_CHUNK/2		 
-    float              follow[DELIM_WINDOW_SIZE];
-    float              value[DELIM_WINDOW_SIZE];
-
-  public:
-                          AUDMAudioFilterLimiter(AUDMAudioFilter *previous, DRCparam *param);
-    virtual                ~AUDMAudioFilterLimiter();
-    virtual    uint32_t   fill(uint32_t max,float *output,AUD_Status *status);
-};
-#endif

Deleted: branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_limiter_param.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_limiter_param.h	2009-03-15 09:57:32 UTC (rev 4692)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_limiter_param.h	2009-03-15 09:57:35 UTC (rev 4693)
@@ -1,25 +0,0 @@
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-
-#ifndef LIMITER_PARAM_H
-#define LIMITER_PARAM_H
-#define DRC_WINDOW 100
-typedef struct 
-{
-  uint32_t mUseGain;
-  double   mFloor;
-  double   mAttackTime;
-  double   mDecayTime;
-  double   mRatio;
-  double   mThresholdDB;
-   // double   mGainDB;  
-}DRCparam;
-
-#endif

Deleted: branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_mixer.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_mixer.cpp	2009-03-15 09:57:32 UTC (rev 4692)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_mixer.cpp	2009-03-15 09:57:35 UTC (rev 4693)
@@ -1,605 +0,0 @@
-/***************************************************************************
-         Downmixer
- ***************************************************************************/
- 
- 
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include &quot;ADM_default.h&quot;
-
-#include &quot;ADM_audioFilter.h&quot;
-#include &quot;audiofilter_mixer.h&quot;
-#include &quot;audiofilter_dolby.h&quot;
-#include &lt;math.h&gt;
-
-AUDMAudioFilterMixer::AUDMAudioFilterMixer(AUDMAudioFilter *instream,CHANNEL_CONF out):AUDMAudioFilter (instream)
-{
-    _output=out;
-    _previous-&gt;rewind();     // rewind
-    ADM_assert(_output&lt;CHANNEL_LAST);
-    
-    
-    double d;               // Update duration
-    d=_wavHeader.byterate;
-    d/=_wavHeader.channels;
-
-	switch (_output) {
-		case CHANNEL_MONO:
-			_wavHeader.channels = 1;
-			outputChannelMapping[0] = ADM_CH_MONO;
-		break;
-		case CHANNEL_STEREO:
-			_wavHeader.channels = 2;
-			outputChannelMapping[0] = ADM_CH_FRONT_LEFT;
-			outputChannelMapping[1] = ADM_CH_FRONT_RIGHT;
-		break;
-		case CHANNEL_2F_1R:
-			_wavHeader.channels = 3;
-			outputChannelMapping[0] = ADM_CH_FRONT_LEFT;
-			outputChannelMapping[1] = ADM_CH_FRONT_RIGHT;
-			outputChannelMapping[2] = ADM_CH_REAR_CENTER;
-		break;
-		case CHANNEL_3F:
-			_wavHeader.channels = 3;
-			outputChannelMapping[0] = ADM_CH_FRONT_LEFT;
-			outputChannelMapping[1] = ADM_CH_FRONT_RIGHT;
-			outputChannelMapping[2] = ADM_CH_FRONT_CENTER;
-		break;
-		case CHANNEL_3F_1R:
-			_wavHeader.channels = 4;
-			outputChannelMapping[0] = ADM_CH_FRONT_LEFT;
-			outputChannelMapping[1] = ADM_CH_FRONT_RIGHT;
-			outputChannelMapping[2] = ADM_CH_REAR_CENTER;
-			outputChannelMapping[3] = ADM_CH_FRONT_CENTER;
-		break;
-		case CHANNEL_2F_2R:
-			_wavHeader.channels = 4;
-			outputChannelMapping[0] = ADM_CH_FRONT_LEFT;
-			outputChannelMapping[1] = ADM_CH_FRONT_RIGHT;
-			outputChannelMapping[2] = ADM_CH_REAR_LEFT;
-			outputChannelMapping[3] = ADM_CH_REAR_RIGHT;
-		break;
-		case CHANNEL_3F_2R:
-			_wavHeader.channels = 5;
-			outputChannelMapping[0] = ADM_CH_FRONT_LEFT;
-			outputChannelMapping[1] = ADM_CH_FRONT_RIGHT;
-			outputChannelMapping[2] = ADM_CH_REAR_LEFT;
-			outputChannelMapping[3] = ADM_CH_REAR_RIGHT;
-			outputChannelMapping[4] = ADM_CH_FRONT_CENTER;
-		break;
-		case CHANNEL_3F_2R_LFE:
-			_wavHeader.channels = 6;
-			outputChannelMapping[0] = ADM_CH_FRONT_LEFT;
-			outputChannelMapping[1] = ADM_CH_FRONT_RIGHT;
-			outputChannelMapping[2] = ADM_CH_REAR_LEFT;
-			outputChannelMapping[3] = ADM_CH_REAR_RIGHT;
-			outputChannelMapping[4] = ADM_CH_FRONT_CENTER;
-			outputChannelMapping[5] = ADM_CH_LFE;
-		break;
-		case CHANNEL_DOLBY_PROLOGIC:
-		case CHANNEL_DOLBY_PROLOGIC2:
-			_wavHeader.channels = 2;
-			outputChannelMapping[0] = ADM_CH_FRONT_LEFT;
-			outputChannelMapping[1] = ADM_CH_FRONT_RIGHT;
-//			DolbyInit();
-		break;
-	}
-
-    d*=_wavHeader.channels;
-    _wavHeader.byterate = (uint32_t)ceil(d);
-
-
-//    printf(&quot;[mixer]Input channels : %u : %u \n&quot;,_previous-&gt;getInfo()-&gt;channels,input_channels);
-//    printf(&quot;[mixer]Out   channels : %u : %u \n&quot;,_wavHeader.channels,ADM_CH_annel_mixer[_output]);
-
-};
-/**
- * 	\fn getChannelMapping
- *  \brief That filter changes the channel mapping, output its own
- */
-CHANNEL_TYPE    *AUDMAudioFilterMixer::getChannelMapping(void ) 
-{
-		return this-&gt;outputChannelMapping;
-}
-AUDMAudioFilterMixer::~AUDMAudioFilterMixer()
-{
-};
-
-static int MCOPY(float *in,float *out,uint32_t nbSample,uint32_t chan)
-{
-    memcpy(out,in,nbSample*chan*sizeof(float));
-    return nbSample*chan;
-    
-}
-
-static int MNto1(float *in,float *out,uint32_t nbSample,uint32_t chan,CHANNEL_TYPE *chanMap)
-{
-float sum;
-int den=(chan+1)&amp;0xfe;
-    for(int i=0;i&lt;nbSample;i++)
-    {
-        sum=0;
-        for(int j=0;j&lt;chan;j++)
-          sum+=in[j];
-        out[0]=sum/(float)den;
-        out++;
-        in+=chan;
-    }
-    return nbSample;
-    
-}
-
-static int MStereo(float *in,float *out,uint32_t nbSample,uint32_t chan,CHANNEL_TYPE *chanMap)
-{
-	memset(out, 0, sizeof(float) * nbSample * 2);
-
-	for (int i = 0; i &lt; nbSample; i++) {
-		for (int c = 0; c &lt; chan; c++) {
-			switch (chanMap[c]) {
-				case ADM_CH_MONO:
-				case ADM_CH_FRONT_CENTER:
-				case ADM_CH_REAR_CENTER:
-				case ADM_CH_LFE:
-					out[0]  += *in * 0.707;
-					out[1]  += *in * 0.707;
-				break;
-				case ADM_CH_FRONT_LEFT:
-				case ADM_CH_REAR_LEFT:
-				case ADM_CH_SIDE_LEFT:
-					out[0]  += *in;
-				break;
-				case ADM_CH_FRONT_RIGHT:
-				case ADM_CH_REAR_RIGHT:
-				case ADM_CH_SIDE_RIGHT:
-					out[1]  += *in;
-				break;
-			}
-			in++;
-		}
-		out += 2;
-	}
-
-	return nbSample*2;
-}
-
-static int M2F1R(float *in,float *out,uint32_t nbSample,uint32_t chan,CHANNEL_TYPE *chanMap)
-{
-	memset(out, 0, sizeof(float) * nbSample * 3);
-
-	for (int i = 0; i &lt; nbSample; i++) {
-		for (int c = 0; c &lt; chan; c++) {
-			switch (chanMap[c]) {
-				case ADM_CH_MONO:
-				case ADM_CH_FRONT_CENTER:
-					out[0]  += *in * 0.707;
-					out[1]  += *in * 0.707;
-				break;
-				case ADM_CH_FRONT_LEFT:
-					out[0]  += *in;
-				break;
-				case ADM_CH_FRONT_RIGHT:
-					out[1]  += *in;
-				break;
-				case ADM_CH_REAR_LEFT:
-				case ADM_CH_REAR_RIGHT:
-				case ADM_CH_REAR_CENTER:
-					out[2]  += *in;
-				break;
-				case ADM_CH_LFE:
-					out[0]  += *in * 0.595;
-					out[1]  += *in * 0.595;
-					out[2]  += *in * 0.595;
-				break;
-				case ADM_CH_SIDE_LEFT:
-					out[0]  += *in * 0.707;
-					out[2]  += *in * 0.707;
-				break;
-				case ADM_CH_SIDE_RIGHT:
-					out[1]  += *in * 0.707;
-					out[2]  += *in * 0.707;
-				break;
-			}
-			in++;
-		}
-		out += 3;
-	}
-
-	return nbSample * 3;
-}
-
-static int M3F(float *in,float *out,uint32_t nbSample,uint32_t chan,CHANNEL_TYPE *chanMap)
-{
-	memset(out, 0, sizeof(float) * nbSample * 3);
-
-	for (int i = 0; i &lt; nbSample; i++) {
-		for (int c = 0; c &lt; chan; c++) {
-			switch (chanMap[c]) {
-				case ADM_CH_MONO:
-				case ADM_CH_FRONT_CENTER:
-				case ADM_CH_REAR_CENTER:
-					out[2]  += *in;
-				break;
-				case ADM_CH_FRONT_LEFT:
-				case ADM_CH_REAR_LEFT:
-				case ADM_CH_SIDE_LEFT:
-					out[0]  += *in;
-				break;
-				case ADM_CH_FRONT_RIGHT:
-				case ADM_CH_REAR_RIGHT:
-				case ADM_CH_SIDE_RIGHT:
-					out[1]  += *in;
-				break;
-				case ADM_CH_LFE:
-					out[0]  += *in * 0.595;
-					out[1]  += *in * 0.595;
-					out[2]  += *in * 0.595;
-				break;
-			}
-			in++;
-		}
-		out += 3;
-	}
-
-	return nbSample * 3;
-}
-
-static int M3F1R(float *in,float *out,uint32_t nbSample,uint32_t chan,CHANNEL_TYPE *chanMap)
-{
-	memset(out, 0, sizeof(float) * nbSample * 4);
-
-	for (int i = 0; i &lt; nbSample; i++) {
-		for (int c = 0; c &lt; chan; c++) {
-			switch (chanMap[c]) {
-				case ADM_CH_MONO:
-				case ADM_CH_FRONT_CENTER:
-					out[3]  += *in;
-				break;
-				case ADM_CH_REAR_CENTER:
-				case ADM_CH_REAR_LEFT:
-				case ADM_CH_REAR_RIGHT:
-					out[2]  += *in;
-				break;
-				case ADM_CH_FRONT_LEFT:
-					out[0]  += *in;
-				break;
-				case ADM_CH_FRONT_RIGHT:
-					out[1]  += *in;
-				break;
-				case ADM_CH_LFE:
-					out[0]  += *in * 0.5;
-					out[1]  += *in * 0.5;
-					out[2]  += *in * 0.5;
-					out[3]  += *in * 0.5;
-				break;
-				case ADM_CH_SIDE_LEFT:
-					out[0]  += *in * 0.707;
-					out[2]  += *in * 0.707;
-				break;
-				case ADM_CH_SIDE_RIGHT:
-					out[1]  += *in * 0.707;
-					out[2]  += *in * 0.707;
-				break;
-			}
-			in++;
-		}
-		out += 4;
-	}
-
-	return nbSample * 4;
-}
-
-static int M2F2R(float *in,float *out,uint32_t nbSample,uint32_t chan,CHANNEL_TYPE *chanMap)
-{
-	memset(out, 0, sizeof(float) * nbSample * 4);
-
-	for (int i = 0; i &lt; nbSample; i++) {
-		for (int c = 0; c &lt; chan; c++) {
-			switch (chanMap[c]) {
-				case ADM_CH_MONO:
-				case ADM_CH_FRONT_CENTER:
-					out[0]  += *in * 0.707;
-					out[1]  += *in * 0.707;
-				break;
-				case ADM_CH_FRONT_LEFT:
-					out[0]  += *in;
-				break;
-				case ADM_CH_FRONT_RIGHT:
-					out[1]  += *in;
-				break;
-				case ADM_CH_REAR_LEFT:
-					out[2]  += *in;
-				break;
-				case ADM_CH_REAR_RIGHT:
-					out[3]  += *in;
-				break;
-				case ADM_CH_REAR_CENTER:
-					out[2]  += *in * 0.707;
-					out[3]  += *in * 0.707;
-				break;
-				case ADM_CH_LFE:
-					out[0]  += *in * 0.5;
-					out[1]  += *in * 0.5;
-					out[2]  += *in * 0.5;
-					out[3]  += *in * 0.5;
-				break;
-				case ADM_CH_SIDE_LEFT:
-					out[0]  += *in * 0.707;
-					out[2]  += *in * 0.707;
-				break;
-				case ADM_CH_SIDE_RIGHT:
-					out[1]  += *in * 0.707;
-					out[3]  += *in * 0.707;
-				break;
-			}
-			in++;
-		}
-		out += 4;
-	}
-
-	return nbSample * 4;
-}
-
-static int M3F2R(float *in,float *out,uint32_t nbSample,uint32_t chan,CHANNEL_TYPE *chanMap)
-{
-	memset(out, 0, sizeof(float) * nbSample * 5);
-
-	for (int i = 0; i &lt; nbSample; i++) {
-		for (int c = 0; c &lt; chan; c++) {
-			switch (chanMap[c]) {
-				case ADM_CH_MONO:
-				case ADM_CH_FRONT_CENTER:
-					out[4]  += *in;
-				break;
-				case ADM_CH_FRONT_LEFT:
-					out[0]  += *in;
-				break;
-				case ADM_CH_FRONT_RIGHT:
-					out[1]  += *in;
-				break;
-				case ADM_CH_REAR_LEFT:
-					out[2]  += *in;
-				break;
-				case ADM_CH_REAR_RIGHT:
-					out[3]  += *in;
-				break;
-				case ADM_CH_REAR_CENTER:
-					out[2]  += *in * 0.707;
-					out[3]  += *in * 0.707;
-				break;
-				case ADM_CH_LFE:
-					out[0]  += *in * 0.459;
-					out[1]  += *in * 0.459;
-					out[2]  += *in * 0.459;
-					out[3]  += *in * 0.459;
-					out[4]  += *in * 0.459;
-				break;
-				case ADM_CH_SIDE_LEFT:
-					out[0]  += *in * 0.707;
-					out[2]  += *in * 0.707;
-				break;
-				case ADM_CH_SIDE_RIGHT:
-					out[1]  += *in * 0.707;
-					out[3]  += *in * 0.707;
-				break;
-			}
-			in++;
-		}
-		out += 5;
-	}
-
-	return nbSample * 5;
-}
-
-static int M3F2RLFE(float *in,float *out,uint32_t nbSample,uint32_t chan,CHANNEL_TYPE *chanMap)
-{
-	memset(out, 0, sizeof(float) * nbSample * 6);
-
-	for (int i = 0; i &lt; nbSample; i++) {
-		for (int c = 0; c &lt; chan; c++) {
-			switch (chanMap[c]) {
-				case ADM_CH_MONO:
-				case ADM_CH_FRONT_CENTER:
-					out[4]  += *in;
-				break;
-				case ADM_CH_FRONT_LEFT:
-					out[0]  += *in;
-				break;
-				case ADM_CH_FRONT_RIGHT:
-					out[1]  += *in;
-				break;
-				case ADM_CH_REAR_LEFT:
-					out[2]  += *in;
-				break;
-				case ADM_CH_REAR_RIGHT:
-					out[3]  += *in;
-				break;
-				case ADM_CH_REAR_CENTER:
-					out[2]  += *in * 0.707;
-					out[3]  += *in * 0.707;
-				break;
-				case ADM_CH_LFE:
-					out[5]  += *in;
-				break;
-				case ADM_CH_SIDE_LEFT:
-					out[0]  += *in * 0.707;
-					out[2]  += *in * 0.707;
-				break;
-				case ADM_CH_SIDE_RIGHT:
-					out[1]  += *in * 0.707;
-					out[3]  += *in * 0.707;
-				break;
-			}
-			in++;
-		}
-		out += 6;
-	}
-
-	return nbSample * 6;
-}
-
-static int MDolbyProLogic(float *in,float *out,uint32_t nbSample,uint32_t chan,CHANNEL_TYPE *chanMap)
-{
-	memset(out, 0, sizeof(float) * nbSample * 2);
-#if 0
-	for (int i = 0; i &lt; nbSample; i++) {
-		for (int c = 0; c &lt; chan; c++) {
-			switch (chanMap[c]) {
-				case ADM_CH_MONO:
-				case ADM_CH_FRONT_CENTER:
-				case ADM_CH_LFE:
-					out[0]  += *in * 0.707;
-					out[1]  += *in * 0.707;
-				break;
-				case ADM_CH_FRONT_LEFT:
-					out[0]  += *in;
-				break;
-				case ADM_CH_FRONT_RIGHT:
-					out[1]  += *in;
-				break;
-				case ADM_CH_REAR_CENTER:
-				case ADM_CH_REAR_LEFT:
-				case ADM_CH_REAR_RIGHT:
-					out[0]  += DolbyShiftLeft(*in) * 0.707;
-					out[1]  += DolbyShiftRight(*in) * 0.707;
-				break;
-				case ADM_CH_SIDE_LEFT:
-					out[0]  += *in * 0.707;
-					out[0]  += DolbyShiftLeft(*in) * 0.707 * 0.707;
-					out[1]  += DolbyShiftRight(*in) * 0.707 * 0.707;
-				break;
-				case ADM_CH_SIDE_RIGHT:
-					out[1]  += *in * 0.5;
-					out[0]  += DolbyShiftLeft(*in) * 0.707 * 0.707;
-					out[1]  += DolbyShiftRight(*in) * 0.707 * 0.707;
-				break;
-			}
-			in++;
-		}
-		out += 2;
-	}
-#endif
-	return nbSample*2;
-}
-
-static int MDolbyProLogic2(float *in,float *out,uint32_t nbSample,uint32_t chan,CHANNEL_TYPE *chanMap)
-{
-	memset(out, 0, sizeof(float) * nbSample * 2);
-#if 0
-	for (int i = 0; i &lt; nbSample; i++) {
-		for (int c = 0; c &lt; chan; c++) {
-			switch (chanMap[c]) {
-				case ADM_CH_MONO:
-				case ADM_CH_FRONT_CENTER:
-				case ADM_CH_LFE:
-					out[0]  += *in * 0.707;
-					out[1]  += *in * 0.707;
-				break;
-				case ADM_CH_FRONT_LEFT:
-					out[0]  += *in;
-				break;
-				case ADM_CH_FRONT_RIGHT:
-					out[1]  += *in;
-				break;
-				case ADM_CH_REAR_CENTER:
-					out[0]  += DolbyShiftLeft(*in) * 0.707;
-					out[1]  += DolbyShiftRight(*in) * 0.707;
-				break;
-				case ADM_CH_REAR_LEFT:
-					out[0]  += DolbyShiftLeft(*in) * 0.8165;
-					out[1]  += DolbyShiftRight(*in) * 0.5774;
-				break;
-				case ADM_CH_REAR_RIGHT:
-					out[0]  += DolbyShiftLeft(*in) * 0.5774;
-					out[1]  += DolbyShiftRight(*in) * 0.8165;
-				break;
-				case ADM_CH_SIDE_LEFT:
-					out[0]  += *in * 0.707;
-					out[0]  += DolbyShiftLeft(*in) * 0.8165 * 0.707;
-					out[1]  += DolbyShiftRight(*in) * 0.5774 * 0.707;
-				break;
-				case ADM_CH_SIDE_RIGHT:
-					out[1]  += *in * 0.707;
-					out[0]  += DolbyShiftLeft(*in) * 0.5774 * 0.707;
-					out[1]  += DolbyShiftRight(*in) * 0.8165 * 0.707;
-				break;
-			}
-			in++;
-		}
-		out += 2;
-	}
-#endif
-	return nbSample*2;
-}
-
-
-typedef int MIXER(float *in,float *out,uint32_t nbSample,uint32_t chan,CHANNEL_TYPE *chanMap)  ;
-
-static MIXER *matrixCall[CHANNEL_LAST] = {
-NULL, MNto1, MStereo, M2F1R, M3F, M3F1R, M2F2R, M3F2R, M3F2RLFE, MDolbyProLogic, MDolbyProLogic2
-};
-//_____________________________________________
-uint32_t AUDMAudioFilterMixer::fill(uint32_t max,float *output,AUD_Status *status)
-{
-
-    uint32_t rd = 0;
-    uint8_t *in,*out;
-    int nbSampleMax=max/_wavHeader.channels;
-    uint8_t input_channels = _previous-&gt;getInfo()-&gt;channels;
-
-// Fill incoming buffer
-    shrink();
-    fillIncomingBuffer(status);
-    // Block not filled ?
-    if((_tail-_head)&lt;input_channels)
-    {
-      if(*status==AUD_END_OF_STREAM &amp;&amp; _head)
-      {
-        memset(&amp;_incomingBuffer[_head],0,sizeof(float) * input_channels);
-        _tail=_head+input_channels;
-        printf(&quot;[Mixer] Warning asked %u symbols\n&quot;,max);
-      }
-      else
-      {
-        return 0;
-      }
-    }
-    // How many ?
-
-    // Let's go
-    int processed=0;
-    int available=0;
-    if(!nbSampleMax)
-    {
-      printf(&quot;[Mixer] Warning max %u, channels %u\n&quot;,max,input_channels);
-    }
-    available=(_tail-_head)/input_channels; // nb Sample
-    ADM_assert(available);
-    if(available &gt; nbSampleMax) available=nbSampleMax;
-    
-    ADM_assert(available);
-    
-
-    // Now do the downsampling
-	if (_output == CHANNEL_INVALID || true==ADM_audioCompareChannelMapping(&amp;_wavHeader, _previous-&gt;getInfo(),
-			_previous-&gt;getChannelMapping(),outputChannelMapping))
-	{
-		
-		rd= (uint32_t)MCOPY(&amp;_incomingBuffer[_head],output,available,input_channels);
-	} else 
-	{
-		MIXER *call=matrixCall[_output];
-		rd= (uint32_t)call(&amp;_incomingBuffer[_head],output,available,input_channels,_previous-&gt;getChannelMapping());
-	}
-
-    _head+=available*input_channels;
-    return rd;
-    
-}
-

Deleted: branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_mixer.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_mixer.h	2009-03-15 09:57:32 UTC (rev 4692)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_mixer.h	2009-03-15 09:57:35 UTC (rev 4693)
@@ -1,18 +0,0 @@
-#ifndef AUDM_AUDIO_MIXER_H
-#define AUDM_AUDIO_MIXER_H
-class AUDMAudioFilterMixer : public AUDMAudioFilter
-{
-    protected:
-        CHANNEL_CONF    _output;
-        CHANNEL_CONF    _input;
-        // output channel mapping
-        CHANNEL_TYPE outputChannelMapping[MAX_CHANNELS];
-    public:
-
-      ~AUDMAudioFilterMixer();
-      AUDMAudioFilterMixer(AUDMAudioFilter *instream,CHANNEL_CONF out);
-      uint32_t   fill(uint32_t max,float *output,AUD_Status *status);
-      // That filter changes its output channel mapping...
-      virtual   CHANNEL_TYPE    *getChannelMapping(void );
-};
-#endif

Deleted: branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_normalize.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_normalize.h	2009-03-15 09:57:32 UTC (rev 4692)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_normalize.h	2009-03-15 09:57:35 UTC (rev 4693)
@@ -1,18 +0,0 @@
-#ifndef AUDIO_F_NORMALIZE_H
-#define AUDIO_F_NORMALIZE_H
-
-#include &quot;ADM_audioFilter.h&quot;
-class AUDMAudioFilterNormalize : public AUDMAudioFilter
-{
-  protected:
-              float       _ratio;
-              uint32_t    _scanned;
-              uint8_t     preprocess(void);
-  public:
-    // gainDB10 is the gain in DB multiplied by 10
-    // 0 meaning automatic
-                          AUDMAudioFilterNormalize(AUDMAudioFilter *previous,GAINparam *param);
-    virtual                ~AUDMAudioFilterNormalize();
-    virtual    uint32_t   fill(uint32_t max,float *output,AUD_Status *status);
-};
-#endif

Deleted: branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_normalize_param.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_normalize_param.h	2009-03-15 09:57:32 UTC (rev 4692)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_normalize_param.h	2009-03-15 09:57:35 UTC (rev 4693)
@@ -1,28 +0,0 @@
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-
-#ifndef GAIN_PARAM_H
-#define GAIN_PARAM_H
-
-typedef enum 
-{
-  ADM_NO_GAIN,
-  ADM_GAIN_AUTOMATIC,
-  ADM_GAIN_MANUAL
-  
-}ADM_GAINMode;
-
-typedef struct GAINparam
-{
-  ADM_GAINMode mode;
-  int32_t gain10;
-}GAINparam;
-
-#endif

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edPtsDts.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edPtsDts.cpp	2009-03-15 09:57:32 UTC (rev 4692)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edPtsDts.cpp	2009-03-15 09:57:35 UTC (rev 4693)
@@ -1,7 +1,7 @@
 /***************************************************************************
 
     \file ADM_edPtsDts.h
-    \brief Try to guess Pts from Dts
+    \brief Try to guess Pts from Dts. Mostly used for crappy format like avi.
 
     copyright            : (C) 2002/2009 by mean
     email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
@@ -22,6 +22,7 @@
 
 /**
     \fn setPtsEqualDts
+    \brief for Low delay codec, set PTS=DTS, fill the missing values
 */
 bool setPtsEqualDts(vidHeader *hdr,uint64_t timeIncrementUs)
 {
@@ -36,26 +37,40 @@
             printf(&quot;[Editor] GetPtsDts failed for frame %&quot;LU&quot;\n&quot;,i);
             return false;
         }
-        if(pts==ADM_NO_PTS &amp;&amp; dts==ADM_NO_PTS)
+        int k=0;
+        if(pts==ADM_NO_PTS) k+=2;
+        if(dts==ADM_NO_PTS) k+=1;
+        switch(k)
         {
-            if(first!=ADM_NO_PTS)
-            {
-                first+=timeIncrementUs;
-            }
-            continue;
-        }else
-        if(dts!=ADM_NO_PTS &amp;&amp; pts!=ADM_NO_PTS)
-        {
-            if(pts!=dts)
-            {
-                    printf(&quot;[Editor] Pts!=Dts for frame %&quot;LU&quot;\n&quot;,i);
-                    first=pts;
-                    continue;
-            }
-        }else
-            if(pts!=ADM_NO_PTS) first=dts=pts;
-            else
+            case 0 : // Got both
+                if(pts!=dts)
+                            {
+                                    printf(&quot;[Editor] Pts!=Dts for frame %&quot;LU&quot;\n&quot;,i);
+                            }
+                first=pts; // do nothing since we already have both...
+                continue;            
+                break;
+            case 3: // Got none
+                {
+                        if(first!=ADM_NO_PTS)
+                        {
+                            first+=timeIncrementUs; // Say this one = previous + timeIncrement
+                            pts=dts=first;
+                        }else
+                            continue;   // We dont have a previous skip that one
+                }
+                break;
+            case 2 :  // got only pts
+                    first=dts=pts;
+                    break;
+            case 1: // got only dts
                 first=pts=dts;
+                break;
+            default:
+                ADM_assert(0);
+                break;
+        }
+        // update
         if(true!=hdr-&gt;setPtsDts(i,pts,dts))
         {
             printf(&quot;[Editor] SetPtsDts failed for frame %&quot;LU&quot;\n&quot;,i);
@@ -66,6 +81,9 @@
 }
 /**
     \fn setMpeg4PtsFromDts
+    \brief For mpeg4 SP/ASP, recompute PTS DTS using the simple I/P/B frame reordering
+    Works also for mpeg1/2
+    It absolutely NEEDS to have the proper frame type set (PTS/DTS/...)
 */
 bool setMpeg4PtsFromDts(vidHeader *hdr,uint64_t timeIncrementUs)
 {

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_audioFilter.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_audioFilter.cpp	2009-03-15 09:57:32 UTC (rev 4692)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_audioFilter.cpp	2009-03-15 09:57:35 UTC (rev 4693)
@@ -17,7 +17,7 @@
 
 
 #include &quot;DIA_factory.h&quot;
-#include &quot;ADM_audiofilter/audiofilter_normalize_param.h&quot;
+#include &quot;audiofilter_normalize_param.h&quot;
 #include &quot;ADM_audiofilter/audioeng_buildfilters.h&quot;
 /**
     \fn DIA_getAudioFilter

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/ADM_ps.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/ADM_ps.cpp	2009-03-15 09:57:32 UTC (rev 4692)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/ADM_ps.cpp	2009-03-15 09:57:35 UTC (rev 4693)
@@ -322,5 +322,32 @@
     return true;
 }
 
+/**
+    \fn getPtsDts
+*/
+bool    psHeader::getPtsDts(uint32_t frame,uint64_t *pts,uint64_t *dts)
+{
+    if(frame&gt;=ListOfFrames.size()) return false;
+    dmxFrame *pk=ListOfFrames[frame];
 
+    *dts=pk-&gt;dts;
+    *pts=pk-&gt;pts;
+    return true;
+}
+/**
+        \fn setPtsDts
+*/
+bool    psHeader::setPtsDts(uint32_t frame,uint64_t pts,uint64_t dts)
+{
+      if(frame&gt;=ListOfFrames.size()) return false;
+    dmxFrame *pk=ListOfFrames[frame];
+
+    pk-&gt;dts=dts;
+    pk-&gt;pts=pts;
+    return true;
+
+
+}
+
+
 //EOF


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001922.html">[Avidemux-svn-commit] r4692 - in branches/avidemux_2.6_branch_mean:	avidemux avidemux/ADM_coreDemuxer/include	avidemux/ADM_coreDemuxer/src cmake
</A></li>
	<LI>Next message: <A HREF="001924.html">[Avidemux-svn-commit] r4694 - in	branches/avidemux_2.6_branch_mean/avidemux:	ADM_audioFilter/include ADM_audioFilter/src ADM_audiofilter
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1923">[ date ]</a>
              <a href="thread.html#1923">[ thread ]</a>
              <a href="subject.html#1923">[ subject ]</a>
              <a href="author.html#1923">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
