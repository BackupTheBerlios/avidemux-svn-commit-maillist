<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r6757 -	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2010-November/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r6757%20-%0A%09branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS&In-Reply-To=%3C20101113142603.50574480F56%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003937.html">
   <LINK REL="Next"  HREF="003936.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r6757 -	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS</H1>
    <B>mean at mail.berlios.de</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r6757%20-%0A%09branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS&In-Reply-To=%3C20101113142603.50574480F56%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r6757 -	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS">mean at mail.berlios.de
       </A><BR>
    <I>Sat Nov 13 15:26:03 CET 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="003937.html">[Avidemux-svn-commit] r6756 -	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS
</A></li>
        <LI>Next message: <A HREF="003936.html">[Avidemux-svn-commit] r6758 -	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3935">[ date ]</a>
              <a href="thread.html#3935">[ thread ]</a>
              <a href="subject.html#3935">[ subject ]</a>
              <a href="author.html#3935">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2010-11-13 15:26:03 +0100 (Sat, 13 Nov 2010)
New Revision: 6757

Added:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS/ADM_tsIndexMpeg2.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS/ADM_tsIndexVC1.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS/ADM_tsIndex.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS/ADM_tsIndex.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS/ADM_tsIndexH264.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS/CMakeLists.txt
Log:
[TsIndexer] SPlit + add VC1 support (not tested much)

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS/ADM_tsIndex.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS/ADM_tsIndex.cpp	2010-11-13 14:25:59 UTC (rev 6756)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS/ADM_tsIndex.cpp	2010-11-13 14:26:03 UTC (rev 6757)
@@ -35,10 +35,6 @@
                 0,                      // 14
                 0                       // 15
         };
-static const uint32_t  VC1_ar[16][2] = {  // From VLC
-                        { 0, 0}, { 1, 1}, {12,11}, {10,11}, {16,11}, {40,33},
-                        {24,11}, {20,11}, {32,11}, {80,33}, {18,11}, {15,11},
-                        {64,33}, {160,99},{ 0, 0}, { 0, 0}};
 
 
 /**
@@ -137,383 +133,6 @@
         ui-&gt;update( (uint32_t)pos);
 }
 /**
-    \fn runMpeg2
-*/  
-bool TsIndexer::runMpeg2(const char *file,ADM_TS_TRACK *videoTrac)
-{
-uint32_t temporal_ref,val;
-uint8_t buffer[50*1024];
-bool seq_found=false;
-
-TSVideo video;
-indexerData  data;    
-dmxPacketInfo info;
-
-    if(!videoTrac) return false;
-    if(videoTrac[0].trackType!=ADM_TS_MPEG2)
-    {
-        printf(&quot;[Ts Indexer] Only Mpeg2 video supported\n&quot;);
-        return false;
-    }
-    video.pid=videoTrac[0].trackPid;
-
-    memset(&amp;data,0,sizeof(data));
-    data.picStructure=pictureFrame;
-
-    string indexName=string(file);
-    indexName=indexName+string(&quot;.idx2&quot;);
-    index=qfopen(indexName,&quot;wt&quot;);
-
-    if(!index)
-    {
-        printf(&quot;[PsIndex] Cannot create %s\n&quot;,indexName.c_str());
-        return false;
-    }
-    writeSystem(file,true);
-    pkt=new tsPacketLinearTracker(videoTrac-&gt;trackPid, audioTracks);
-
-    FP_TYPE append=FP_APPEND;
-    pkt-&gt;open(file,append);
-    data.pkt=pkt;
-    fullSize=pkt-&gt;getSize();
-    int startCode;
-#define likely(x) x
-#define unlikely(x) x
-      while(1)
-      {
-        startCode=pkt-&gt;findStartCode();
-        if(!pkt-&gt;stillOk()) break;
-
-          switch(startCode)
-                  {
-                  case 0xB3: // sequence start
-                          if(seq_found)
-                          {
-                                  pkt-&gt;getInfo(&amp;info);
-                                  data.frameType=1;
-                                  Mark(&amp;data,&amp;info,4);
-                                  data.state=idx_startAtGopOrSeq;
-                                  pkt-&gt;forward(8);  // Ignore
-                                  continue;
-                          }
-                          //
-                          seq_found=1;
-                          val=pkt-&gt;readi32();
-                          video.w=val&gt;&gt;20;
-                          video.w=((video.w+15)&amp;~15);
-                          video.h= (((val&gt;&gt;8) &amp; 0xfff)+15)&amp; ~15;
-
-                          video.ar = (val &gt;&gt; 4) &amp; 0xf;
-                          video.fps= FPS[val &amp; 0xf];
-                          pkt-&gt;forward(4);
-                          writeVideo(&amp;video,ADM_TS_MPEG2);
-                          writeAudio();
-                          qfprintf(index,&quot;[Data]&quot;);
-                          pkt-&gt;getInfo(&amp;info);
-                          data.frameType=1;
-                          Mark(&amp;data,&amp;info,4+8);
-                          data.state=idx_startAtGopOrSeq;
-                          continue;
-
-                          break;
-                    case 0xB5: //  extension
-                                { 
-                                    uint8_t id=pkt-&gt;readi8()&gt;&gt;4;
-                                    uint8_t two;
-                                    switch(id)
-                                    {
-                                        case 1: // Sequence extension
-                                            val=(val&gt;&gt;3)&amp;1; // gop type progressive, unreliable, not used
-                                            break;
-                                        case 8: // picture coding extension (mpeg2)
-                                        {
-                                            // skip motion vector
-                                            uint8_t picture_structure;
-                                            pkt-&gt;forward(1); // 4*4 bits
-                                            two=pkt-&gt;readi8();
-                                            picture_structure=(two)&amp;3;
-                                            
-                                            //printf(&quot;Picture type %02x struct:%x\n&quot;,two,picture_structure);
-                                            updatePicStructure(video,data,picture_structure);
-                                        }
-                                        default:break;
-                                    }
-                                }
-                                break;
-                  case 0xb8: // GOP
-                          // Update ui
-                            {
-                               updateUI();
-
-                            }
-
-                          if(!seq_found) continue;
-                          if(data.state==idx_startAtGopOrSeq) 
-                          {         
-                                  continue;;
-                          }
-                          pkt-&gt;getInfo(&amp;info);
-                          Mark(&amp;data,&amp;info,4);
-                          data.state=idx_startAtGopOrSeq;
-                          break;
-                  case 0x00 : // picture
-                        {
-                          int type;
-                          if(!seq_found)
-                          { 
-                                  continue;
-                                  printf(&quot;[TsIndexer]No sequence start yet, skipping..\n&quot;);
-                          }
-                          
-                          val=pkt-&gt;readi16();
-                          temporal_ref=val&gt;&gt;6;
-                          type=7 &amp; (val&gt;&gt;3);
-                          if( type&lt;1 ||  type&gt;3)
-                          {
-                                  printf(&quot;[Indexer]Met illegal pic at %&quot;LLX&quot; + %&quot;LX&quot;\n&quot;,
-                                                  info.startAt,info.offset);
-                                  continue;
-                          }
-                          
-                          
-                          if(data.state==idx_startAtGopOrSeq) 
-                          {
-                                  currentFrameType=type;
-                          }else
-                            {
-                                  data.frameType=type;
-                                  pkt-&gt;getInfo(&amp;info);
-                                  Mark(&amp;data,&amp;info,4+2);
-
-
-                            }
-                            data.state=idx_startAtImage;
-                            data.nbPics++;
-                        }
-                          break;
-                  default:
-                    break;
-                  }
-      }
-    
-        printf(&quot;\n&quot;);
-        Mark(&amp;data,&amp;info,2);
-        qfprintf(index,&quot;\n[End]\n&quot;);
-        qfprintf(index,&quot;\n# Found %&quot;LU&quot; images \n&quot;,data.nbPics); // Size
-        qfprintf(index,&quot;# Found %&quot;LU&quot; frame pictures\n&quot;,video.frameCount); // Size
-        qfprintf(index,&quot;# Found %&quot;LU&quot; field pictures\n&quot;,video.fieldCount); // Size
-        qfclose(index);
-        index=NULL;
-        audioTracks=NULL;
-        delete pkt;
-        pkt=NULL;
-        return 1; 
-}
-/**
-    \fn runVC1
-    \brief Index VC1 stream
-*/  
-bool TsIndexer::runVC1(const char *file,ADM_TS_TRACK *videoTrac)
-{
-uint32_t temporal_ref,val;
-uint8_t buffer[50*1024];
-bool seq_found=false;
-
-TSVideo video;
-indexerData  data;    
-dmxPacketInfo info;
-
-
-    if(!videoTrac) return false;
-    if(videoTrac[0].trackType!=ADM_TS_VC1)
-    {
-        printf(&quot;[Ts Indexer] Only VC1 video supported\n&quot;);
-        return false;
-    }
-    video.pid=videoTrac[0].trackPid;
-
-    memset(&amp;data,0,sizeof(data));
-    data.picStructure=pictureFrame;
-    
-    string indexName=string(file);
-    indexName=indexName+string(&quot;.idx2&quot;);
-    index=qfopen(indexName,&quot;wt&quot;);
-
-    if(!index)
-    {
-        printf(&quot;[PsIndex] Cannot create %s\n&quot;,indexName.c_str());
-        return false;
-    }
-    writeSystem(file,true);
-    pkt=new tsPacketLinearTracker(videoTrac-&gt;trackPid, audioTracks);
-
-    FP_TYPE append=FP_APPEND;
-    pkt-&gt;open(file,append);
-    data.pkt=pkt;
-    fullSize=pkt-&gt;getSize();
-    int startCode;
-#define likely(x) x
-#define unlikely(x) x
-      while(1)
-      {
-        startCode=pkt-&gt;findStartCode();
-        if(!pkt-&gt;stillOk()) break;
-
-          switch(startCode)
-                  {
-                  case 0x0f: // sequence start
-                          
-                          if(seq_found)
-                          {
-                              if(data.state==idx_startAtGopOrSeq)       
-                                  continue;;
-                              pkt-&gt;getInfo(&amp;info);
-                              data.frameType=1; // next frame is assumed to be intra
-                              Mark(&amp;data,&amp;info,4); // startcode
-                              data.state=idx_startAtGopOrSeq;
-                              updateUI();
-                              break;
-                          }
-                          // Verify it is high/advanced profile
-                          {
-                          int seqSize=0;
-                          tsGetBits bits(pkt);
-                          if(!bits.peekBits(1)) continue; // simple/main profile
-
-                          if(!decodeVC1Seq(bits,video)) continue;
-
-                          seqSize=bits.getConsumed();
-                          video.extraDataLength=seqSize+4+1;
-                          memcpy(video.extraData+4,bits.data,seqSize);
-                            // Add info so that ffmpeg is happy
-                          video.extraData[0]=0;
-                          video.extraData[1]=0;
-                          video.extraData[2]=1;
-                          video.extraData[3]=0xf;
-                          video.extraData[seqSize+4+0]=0;
-                          seq_found=1;
-                          // Hi Profile
-                          printf(&quot;[VC1] Found seq start with %d x %d video\n&quot;,(int)video.w,(int)video.h);
-                          printf(&quot;[VC1] FPS : %d\n&quot;,(int)video.fps);
-                          printf(&quot;[VC1] sequence header is %d bytes\n&quot;,(int)seqSize);
-                          writeVideo(&amp;video,ADM_TS_VC1);
-                          writeAudio();
-                          qfprintf(index,&quot;[Data]&quot;);
-                          pkt-&gt;getInfo(&amp;info);
-                          data.frameType=1; // Force first frame to be intra
-                          Mark(&amp;data,&amp;info,seqSize+4);
-                          data.state=idx_startAtGopOrSeq;
-                          continue;
-                          }
-                          break;
-                    case 0x0D: //  Picture start
-                        { 
-                          int type;
-                          uint8_t buffer[4];
-                          uint32_t fType,sType;
-                          if(!seq_found)
-                          { 
-                                  continue;
-                                  printf(&quot;[TsIndexer]No sequence start yet, skipping..\n&quot;);
-                          }      
-                          tsGetBits bits(pkt);
-                          if(!decodeVC1Pic(bits,fType,sType)) continue;
-                          updatePicStructure(video,data,sType);
-                          if(data.state==idx_startAtGopOrSeq) 
-                          {
-                                  currentFrameType=fType;
-                          }else
-                            {
-                                  data.frameType=fType;
-                                  pkt-&gt;getInfo(&amp;info);
-                                  Mark(&amp;data,&amp;info,bits.getConsumed());
-                            }
-                            data.state=idx_startAtImage;
-                            data.nbPics++;
-                        }
-                          break;
-                  default:
-                    break;
-                  }
-      }
-    
-        printf(&quot;\n&quot;);
-        Mark(&amp;data,&amp;info,2);
-        qfprintf(index,&quot;\n[End]\n&quot;);
-        qfprintf(index,&quot;\n# Found %&quot;LU&quot; images \n&quot;,data.nbPics); // Size
-        qfprintf(index,&quot;# Found %&quot;LU&quot; frame pictures\n&quot;,video.frameCount); // Size
-        qfprintf(index,&quot;# Found %&quot;LU&quot; field pictures\n&quot;,video.fieldCount); // Size
-        qfclose(index);
-        index=NULL;
-        audioTracks=NULL;
-        delete pkt;
-        pkt=NULL;
-        return 1; 
-}
-/**
-    \fn   Mark
-    \brief update the file
-
-    The offset part is due to the fact that we read 2 bytes from the pic header to know the pic type.
-    So when going from a pic to a pic, it is self cancelling.
-    If the beginning is not a pic, but a gop start for example, we had to add/remove those.
-
-*/
-bool  TsIndexer::Mark(indexerData *data,dmxPacketInfo *info,uint32_t overRead)
-{
-        aprintf(&quot;********************** MARK ******************\n&quot;);
-        uint32_t consumed=pkt-&gt;getConsumed()-overRead;
-        if(data-&gt;nbPics)
-        {
-            int64_t deltaPts,deltaDts;
-
-            if(data-&gt;beginPts==-1 || data-&gt;prevPts==-1) deltaPts=-1;
-                else deltaPts=data-&gt;prevPts-data-&gt;beginPts;
-
-            if(data-&gt;beginDts==-1 || data-&gt;prevDts==-1) deltaDts=-1;
-                else deltaDts=data-&gt;prevDts-data-&gt;beginDts;
-
-            qfprintf(index,&quot; %c%c:%06&quot;LX&quot;:%&quot;LLD&quot;:%&quot;LLD,
-                                    Type[currentFrameType],
-                                    Structure[data-&gt;picStructure&amp;3],
-                                    consumed-beginConsuming,
-                                    deltaPts,deltaDts);
-            beginConsuming=consumed;
-        }else
-        {  // Our first Pic
-            beginConsuming=0;
-            pkt-&gt;setConsumed(overRead);
-        }
-            
-        // If audio, also dump audio
-        if(data-&gt;frameType==1 || data-&gt;frameType==4) // I or IDR
-        {
-            data-&gt;beginPts=info-&gt;pts;
-            data-&gt;beginDts=info-&gt;dts;
-            if(audioTracks)
-            {
-                qfprintf(index,&quot;\nAudio bf:%08&quot;LLX&quot; &quot;,info-&gt;startAt);
-                packetTSStats *s;
-                uint32_t na;
-                pkt-&gt;getStats(&amp;na,&amp;s);      
-                ADM_assert(na==audioTracks-&gt;size());
-                for(int i=0;i&lt;na;i++)
-                {   
-                    packetTSStats *current=s+i;
-                    qfprintf(index,&quot;Pes:%x:%08&quot;LLX&quot;:%&quot;LD&quot;:%&quot;LLD&quot; &quot;,
-                                current-&gt;pid,current-&gt;startAt,current-&gt;startSize,current-&gt;startDts);
-                }                
-            }
-            // start a new line
-            qfprintf(index,&quot;\nVideo at:%08&quot;LLX&quot;:%04&quot;LX&quot; Pts:%08&quot;LLD&quot;:%08&quot;LLD&quot; &quot;,info-&gt;startAt,info-&gt;offset-overRead,info-&gt;pts,info-&gt;dts);
-        }
-        currentFrameType=data-&gt;frameType;
-        data-&gt;prevDts=info-&gt;dts;
-        data-&gt;prevPts=info-&gt;pts;
-    return true;
-}
-
-/**
     \fn writeVideo
     \brief Write Video section of index file
 */
@@ -579,220 +198,101 @@
     }
     return true;
 }
+
+
 /**
-    \fn decodeVc1Seq
-    \brief <A HREF="http://wiki.multimedia.cx/index.php?title=VC-1#Setup_Data_.2F_Sequence_Layer">http://wiki.multimedia.cx/index.php?title=VC-1#Setup_Data_.2F_Sequence_Layer</A>
-#warning we should de-escape it!
-        Large part of this borrowed from VLC
-        Advanced/High profile only
+    \fn dumpUnits
 */
-bool TsIndexer::decodeVC1Seq(tsGetBits &amp;bits,TSVideo &amp;video)
+bool TsIndexer::dumpUnits(indexerData &amp;data,uint64_t nextConsumed,const dmxPacketInfo *nextPacket)
 {
-
-int v;
-int consumed;
-    vc1Context.advanced=true;
-
-#define VX(a,b) v=bits.getBits(a);printf(&quot;[VC1] %d &quot;#b&quot;\n&quot;,v);consumed+=a;
-    VX(2,profile);
-    VX(3,level);
-
-    VX(2,chroma_format);
-    VX(3,Q_frame_rate_unused);
-    VX(5,Q_bit_unused);
-
-    VX(1,postproc_flag);
-
-    VX(12,coded_width);
-    video.w=v*2+2;
-    VX(12,coded_height);
-    video.h=v*2+2;
-
-    VX(1,pulldown_flag);
-    VX(1,interlaced_flag);
-    vc1Context.interlaced=v;
-    VX(1,frame_counter_flag);
-
-    VX(1,interpolation_flag);
-    vc1Context.interpolate=v;
-
-    VX(1,reserved_bit);
-    VX(1,psf);
-
-    VX(1,display_extension);
-    if(v)
-    {
-         VX(14,display_extension_coded_width);
-         VX(14,display_extension_coded_height);
-         VX(1,aspect_ratio_flag);
-     
-
-         if(v)
-         {
-                VX(4,aspect_ratio);
-                switch(v)
-                {
-                    case 15: video.ar=(bits.getBits(8)&lt;&lt;16)+bits.getBits(8);
-                             break;
-                    default:
-                             video.ar=(VC1_ar[v][0]&lt;&lt;16)+(VC1_ar[v][1]&lt;&lt;16);
-                             break;
-                }
-                printf(&quot;[VC1] Aspect ratio %d x %d\n&quot;,video.ar&gt;&gt;8,video.ar&amp;0xff);
-         }
-    
-        VX(1,frame_rate);
-        if(v)
+        // if it contain a SPS or a intra/idr, we start a new line
+        bool mustFlush=false;
+        int n=listOfUnits.size();
+        int picIndex=0;
+        H264Unit *unit=&amp;(listOfUnits[0]);
+        pictureStructure pictStruct=pictureFrame;
+        
+        // if I, IDR or SPS we start a new line
+        for(int i=0;i&lt;n;i++)
         {
-                VX(1,frame_rate32_flag);
-                if(v)
-                {
-                    VX(16,frame_rate32);
-                    float f=v;
-                    f=(f+1)/32;
-                    f*=1000;
-                    video.fps=(uint32_t)f;
-                }else
-                {
-                    float den,num;
-                    VX(8,frame_rate_num)
-                    switch( v )
-                        {
-                        case 1: num = 24000; break;
-                        case 2: num = 25000; break;
-                        case 3: num = 30000; break;
-                        case 4: num = 50000; break;
-                        case 5: num = 60000; break;
-                        case 6: num = 48000; break;
-                        case 7: num = 72000; break;
-                        }
-                    VX(4,frame_rate_den)
-                    switch( v )
-                        {
-                        default:
-                        case 1: den = 1000; break;
-                        case 2: den = 1001; break;
-                        }
-
-                    float f=num*1000;
-                    f/=den;
-                    video.fps=(uint32_t)f;
-                }
-            }else
+            switch(listOfUnits[i].unitType)
             {
-                video.fps=25000;
+                case unitTypeSps: mustFlush=true;;break;
+                case unitTypePic: 
+                            picIndex=i;
+                            if(listOfUnits[i].imageType==1 || listOfUnits[i].imageType==4)
+                            mustFlush=true;
+                            break;
+                case unitTypeSei:
+                            pictStruct=listOfUnits[i].imageStructure;
+                            break;
+                default:
+                        ADM_assert(0);
+                        break;
             }
-            //
-            VX(1,color_flag);
-            if(v){
-                    VX(8,color_prim);
-                    VX(8,transfer_char);
-                    VX(8,matrix_coef);
-                }
-    }
-    VX(1,hrd_param_flag);
-    int leaky=0;
-    if(v)
-    {
-        VX(5,hrd_num_leaky_buckets);
-        leaky=v;
-        VX(4,bitrate_exponent);
-        VX(4,buffer_size_exponent);
-        for(int i = 0; i &lt; leaky; i++) 
+        }
+        dmxPacketInfo *pic=&amp;(listOfUnits[picIndex].packetInfo);
+        dmxPacketInfo *p=&amp;(unit-&gt;packetInfo);
+        H264Unit      *picUnit=&amp;(listOfUnits[picIndex]);
+        if(mustFlush) 
         {
-                bits.getBits(16);
-                bits.getBits(16);
+            if(audioTracks)
+            {
+                qfprintf(index,&quot;\nAudio bf:%08&quot;LLX&quot; &quot;,nextPacket-&gt;startAt);
+                packetTSStats *s;
+                uint32_t na;
+                pkt-&gt;getStats(&amp;na,&amp;s);      
+                ADM_assert(na==audioTracks-&gt;size());
+                for(int i=0;i&lt;na;i++)
+                {   
+                    packetTSStats *current=s+i;
+                    qfprintf(index,&quot;Pes:%x:%08&quot;LLX&quot;:%&quot;LD&quot;:%&quot;LLD&quot; &quot;,
+                                current-&gt;pid,current-&gt;startAt,current-&gt;startSize,current-&gt;startDts);
+                }                
+            }
+            data.beginPts=pic-&gt;pts;
+            data.beginDts=pic-&gt;dts;
+            // start a new line
+            qfprintf(index,&quot;\nVideo at:%08&quot;LLX&quot;:%04&quot;LX&quot; Pts:%08&quot;LLD&quot;:%08&quot;LLD&quot; &quot;,
+                        p-&gt;startAt,p-&gt;offset-unit-&gt;overRead,pic-&gt;pts,pic-&gt;dts);
         }
-    }
-    // Now we need an entry point
-    bits.flush();
-    uint8_t a[4];
-    uint8_t entryPoint[4]={0,0,1,0x0E};
-    for(int i=0;i&lt;4;i++) a[i]=bits.getBits(8);
-    for(int i=0;i&lt;4;i++) printf(&quot;%02x &quot;,a[i]);
-    printf(&quot; as marker\n&quot;);
-    if(memcmp(a,entryPoint,4))
-    {
-        ADM_warning(&quot;Bad entry point&quot;);
-        return false;
-    }
-    VX(6,ep_flags);
-    VX(1,extended_mv);
-    int extended_mv=v;
-    VX(6,ep_flags2);
+       
+        
+            int64_t deltaPts,deltaDts;
 
-    for(int i=0;i&lt;leaky;i++)
-            bits.getBits(8);
-    VX(1,ep_coded_dimension);
-    if(v)
-    {
-         VX(12,ep_coded_width);
-         VX(12,ep_coded_height);
-    }
-    if(extended_mv) VX(1,dmv);
-    VX(1,range_mappy_flags);
-    if(v) VX(3,mappy_flags);
-    VX(1,range_mappuv_flags);
-    if(v) VX(3,mappuv_flags);
-    return true;
+            if(data.beginPts==-1 || pic-&gt;pts==-1) deltaPts=-1;
+                else deltaPts=pic-&gt;pts-data.beginPts;
 
+            if(data.beginDts==-1 || pic-&gt;dts==-1) deltaDts=-1;
+                else deltaDts=pic-&gt;dts-data.beginDts;            
+
+
+            qfprintf(index,&quot; %c%c:%06&quot;LX&quot;:%&quot;LLD&quot;:%&quot;LLD,
+                                    Type[picUnit-&gt;imageType],
+                                    Structure[pictStruct&amp;3],
+                                    nextConsumed-beginConsuming,
+                                    deltaPts,deltaDts);
+        beginConsuming=nextConsumed;
+        listOfUnits.clear();
+        return true;
 }
 /**
-    \fn decodeVC1Pic
-    \brief Decode info from VC1 picture
-    Borrowed a lot from VLC also
-
+    \fn addUnit
 */
-bool TsIndexer::decodeVC1Pic(tsGetBits &amp;bits,uint32_t &amp;frameType,uint32_t &amp;frameStructure)
+bool TsIndexer::addUnit(indexerData &amp;data,int unitType2,const H264Unit &amp;unit,uint32_t overRead)
 {
-    frameStructure=3;
-    bool field=false;
-    if(vc1Context.interlaced)
-    {
-        if(bits.getBits(1))
-        {
-            if(bits.getBits(1))
-               field=true;
-        }
-    }
-    if(field)
-    {
-            int fieldType=bits.getBits(3);
-            frameStructure=1; // Top
-            switch(fieldType)
+        H264Unit myUnit=unit;
+        myUnit.unitType=unitType2;
+        myUnit.overRead=overRead;
+        int n=listOfUnits.size();
+        if(n)
+            if(listOfUnits[n-1].unitType==unitTypePic)
             {
-                case 0: /* II */
-                case 1: /* IP */
-                case 2: /* PI */
-                    frameType=1;
-                    break;
-                case 3: /* PP */
-                    frameType=2;
-                    break;
-                case 4: /* BB */
-                case 5: /* BBi */
-                case 6: /* BiB */
-                case 7: /* BiBi */
-                    frameType=3;
-                    break;
-
+                dumpUnits(data,myUnit.consumedSoFar-overRead,&amp;(unit.packetInfo));
+                updateUI();
             }
-    }else
-    {
-                frameStructure=3; // frame
-                if( !bits.getBits(1))
-                    frameType=2;
-                else if( !bits.getBits(1))
-                    frameType=3;
-                else if( !bits.getBits(1))
-                    frameType=1;
-                else if( !bits.getBits(1))
-                    frameType=3;
-                else
-                    frameType=2;
-    }
-
-    return true;
+        listOfUnits.push_back(myUnit);
+        return true;
 }
 /********************************************************************************************/
 /********************************************************************************************/

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS/ADM_tsIndex.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS/ADM_tsIndex.h	2010-11-13 14:25:59 UTC (rev 6756)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS/ADM_tsIndex.h	2010-11-13 14:26:03 UTC (rev 6757)
@@ -121,7 +121,8 @@
 {
     unitTypeSei=1,
     unitTypePic=2,
-    unitTypeSps=3
+    unitTypeSps=3,
+    unitTypePicInfo=4
 };
 
 /**
@@ -130,12 +131,13 @@
 class TsIndexer
 {
 protected:
-        uint32_t        currentFrameType;
         uint32_t        beginConsuming;
-        indexerState    currentIndexState;
         uint64_t        fullSize;
         Clock           ticktock;
         VC1Context      vc1Context;
+        vector &lt;H264Unit&gt; listOfUnits;
+        H264Unit        thisUnit;
+        bool            decodingImage;
 protected:
         FILE                    *index;
         tsPacketLinearTracker   *pkt;
@@ -158,18 +160,17 @@
         bool    writeVideo(TSVideo *video,ADM_TS_TRACK_TYPE trkType);
         bool    writeAudio(void);
         bool    writeSystem(const char *filename,bool append);
-        bool    Mark(indexerData *data,dmxPacketInfo *s,uint32_t overRead);
-        bool    updatePicStructure(TSVideo &amp;video,indexerData &amp;idata, const uint32_t t)
+        bool    updatePicStructure(TSVideo &amp;video,const uint32_t t)
                         {
                                             switch(t)
                                             {
                                                 case 3: video.frameCount++;
-                                                        idata.picStructure=pictureFrame;
+                                                        thisUnit.imageStructure=pictureFrame;
                                                         break;
-                                                case 1:  idata.picStructure=pictureTopField;
+                                                case 1:  thisUnit.imageStructure=pictureTopField;
                                                          video.fieldCount++;
                                                          break;
-                                                case 2:  idata.picStructure=pictureBottomField;
+                                                case 2:  thisUnit.imageStructure=pictureBottomField;
                                                          video.fieldCount++;
                                                          break;
                                                 default: ADM_warning(&quot;frame type 0 met, this is illegal\n&quot;);

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS/ADM_tsIndexH264.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS/ADM_tsIndexH264.cpp	2010-11-13 14:25:59 UTC (rev 6756)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS/ADM_tsIndexH264.cpp	2010-11-13 14:26:03 UTC (rev 6757)
@@ -17,102 +17,8 @@
  ***************************************************************************/
 #include &quot;ADM_tsIndex.h&quot;
 
-static vector &lt;H264Unit&gt; listOfUnits;
-/**
-    \fn dumpUnits
-*/
-bool TsIndexer::dumpUnits(indexerData &amp;data,uint64_t nextConsumed,const dmxPacketInfo *nextPacket)
-{
-        // if it contain a SPS or a intra/idr, we start a new line
-        bool mustFlush=false;
-        int n=listOfUnits.size();
-        int picIndex=0;
-        H264Unit *unit=&amp;(listOfUnits[0]);
-        pictureStructure pictStruct=pictureFrame;
-        
-        // if I, IDR or SPS we start a new line
-        for(int i=0;i&lt;n;i++)
-        {
-            switch(listOfUnits[i].unitType)
-            {
-                case unitTypeSps: mustFlush=true;;break;
-                case unitTypePic: 
-                            picIndex=i;
-                            if(listOfUnits[i].imageType==1 || listOfUnits[i].imageType==4)
-                            mustFlush=true;
-                            break;
-                case unitTypeSei:
-                            pictStruct=listOfUnits[i].imageStructure;
-                            break;
-                default:
-                        ADM_assert(0);
-                        break;
-            }
-        }
-        dmxPacketInfo *pic=&amp;(listOfUnits[picIndex].packetInfo);
-        dmxPacketInfo *p=&amp;(unit-&gt;packetInfo);
-        H264Unit      *picUnit=&amp;(listOfUnits[picIndex]);
-        if(mustFlush) 
-        {
-            if(audioTracks)
-            {
-                qfprintf(index,&quot;\nAudio bf:%08&quot;LLX&quot; &quot;,nextPacket-&gt;startAt);
-                packetTSStats *s;
-                uint32_t na;
-                pkt-&gt;getStats(&amp;na,&amp;s);      
-                ADM_assert(na==audioTracks-&gt;size());
-                for(int i=0;i&lt;na;i++)
-                {   
-                    packetTSStats *current=s+i;
-                    qfprintf(index,&quot;Pes:%x:%08&quot;LLX&quot;:%&quot;LD&quot;:%&quot;LLD&quot; &quot;,
-                                current-&gt;pid,current-&gt;startAt,current-&gt;startSize,current-&gt;startDts);
-                }                
-            }
-            data.beginPts=pic-&gt;pts;
-            data.beginDts=pic-&gt;dts;
-            // start a new line
-            qfprintf(index,&quot;\nVideo at:%08&quot;LLX&quot;:%04&quot;LX&quot; Pts:%08&quot;LLD&quot;:%08&quot;LLD&quot; &quot;,
-                        p-&gt;startAt,p-&gt;offset-unit-&gt;overRead,pic-&gt;pts,pic-&gt;dts);
-        }
-       
-        
-            int64_t deltaPts,deltaDts;
 
-            if(data.beginPts==-1 || pic-&gt;pts==-1) deltaPts=-1;
-                else deltaPts=pic-&gt;pts-data.beginPts;
-
-            if(data.beginDts==-1 || pic-&gt;dts==-1) deltaDts=-1;
-                else deltaDts=pic-&gt;dts-data.beginDts;            
-
-
-            qfprintf(index,&quot; %c%c:%06&quot;LX&quot;:%&quot;LLD&quot;:%&quot;LLD,
-                                    Type[picUnit-&gt;imageType],
-                                    Structure[pictStruct&amp;3],
-                                    nextConsumed-beginConsuming,
-                                    deltaPts,deltaDts);
-        beginConsuming=nextConsumed;
-        listOfUnits.clear();
-        return true;
-}
 /**
-    \fn addUnit
-*/
-bool TsIndexer::addUnit(indexerData &amp;data,int unitType2,const H264Unit &amp;unit,uint32_t overRead)
-{
-        H264Unit myUnit=unit;
-        myUnit.unitType=unitType2;
-        myUnit.overRead=overRead;
-        int n=listOfUnits.size();
-        if(n)
-            if(listOfUnits[n-1].unitType==unitTypePic)
-            {
-                dumpUnits(data,myUnit.consumedSoFar-overRead,&amp;(unit.packetInfo));
-            }
-        listOfUnits.push_back(myUnit);
-        return true;
-}
-
-/**
         \fn decodeSEI
         \brief decode SEI to get short ref I
         @param recoveryLength # of recovery frame
@@ -190,7 +96,7 @@
 */  
 bool TsIndexer::runH264(const char *file,ADM_TS_TRACK *videoTrac)
 {
-bool    decodingImage=false;
+
 bool    seq_found=false;
 bool    firstSps=true;
 
@@ -199,8 +105,8 @@
 dmxPacketInfo tmpInfo;
 TS_PESpacket SEI_nal(0);
 bool result=false;
-H264Unit thisUnit;
 
+
     beginConsuming=0;
     listOfUnits.clear();
 

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS/ADM_tsIndexMpeg2.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS/ADM_tsIndexMpeg2.cpp	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS/ADM_tsIndexMpeg2.cpp	2010-11-13 14:26:03 UTC (rev 6757)
@@ -0,0 +1,218 @@
+/***************************************************************************
+                        Mpeg2 in PS indexer                                            
+                             
+    VC1: /!\ Escaping not done (yet)
+
+    copyright            : (C) 2005/2009 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &quot;ADM_tsIndex.h&quot;
+
+static const uint32_t FPS[16]={
+                0,                      // 0
+                23976,          // 1 (23.976 fps) - FILM
+                24000,          // 2 (24.000 fps)
+                25000,          // 3 (25.000 fps) - PAL
+                29970,          // 4 (29.970 fps) - NTSC
+                30000,          // 5 (30.000 fps)
+                50000,          // 6 (50.000 fps) - PAL noninterlaced
+                59940,          // 7 (59.940 fps) - NTSC noninterlaced
+                60000,          // 8 (60.000 fps)
+                0,                      // 9
+                0,                      // 10
+                0,                      // 11
+                0,                      // 12
+                0,                      // 13
+                0,                      // 14
+                0                       // 15
+        };
+
+
+/**
+    \fn runMpeg2
+*/  
+bool TsIndexer::runMpeg2(const char *file,ADM_TS_TRACK *videoTrac)
+{
+uint32_t temporal_ref,val;
+uint8_t buffer[50*1024];
+bool seq_found=false;
+H264Unit thisUnit;
+
+beginConsuming=0;
+
+TSVideo video;
+indexerData  data;    
+dmxPacketInfo tmpInfo;
+
+    listOfUnits.clear();
+
+    if(!videoTrac) return false;
+    if(videoTrac[0].trackType!=ADM_TS_MPEG2)
+    {
+        printf(&quot;[Ts Indexer] Only Mpeg2 video supported\n&quot;);
+        return false;
+    }
+    video.pid=videoTrac[0].trackPid;
+
+    memset(&amp;data,0,sizeof(data));
+
+    string indexName=string(file);
+    indexName=indexName+string(&quot;.idx2&quot;);
+    index=qfopen(indexName,&quot;wt&quot;);
+
+    if(!index)
+    {
+        printf(&quot;[PsIndex] Cannot create %s\n&quot;,indexName.c_str());
+        return false;
+    }
+    writeSystem(file,true);
+    pkt=new tsPacketLinearTracker(videoTrac-&gt;trackPid, audioTracks);
+
+    FP_TYPE append=FP_APPEND;
+    pkt-&gt;open(file,append);
+    data.pkt=pkt;
+    fullSize=pkt-&gt;getSize();
+    int startCode;
+    decodingImage=false;
+    
+#define likely(x) x
+#define unlikely(x) x
+      while(1)
+      {
+        startCode=pkt-&gt;findStartCode();
+        if(!pkt-&gt;stillOk()) break;
+
+          switch(startCode)
+                  {
+// B2: User Data
+                  case 0xB3: // sequence start
+                          if(seq_found)
+                          {
+                                decodingImage=false;
+                                pkt-&gt;getInfo(&amp;thisUnit.packetInfo);
+                                thisUnit.consumedSoFar=pkt-&gt;getConsumed();
+                                addUnit(data,unitTypeSps,thisUnit,4);
+                                pkt-&gt;forward(8);  // Ignore
+                                continue;
+                          }
+                          pkt-&gt;setConsumed(4); // reset consumed counter
+                          //
+                          seq_found=1;
+                          val=pkt-&gt;readi32();                    //+4
+                          video.w=val&gt;&gt;20;
+                          video.w=((video.w+15)&amp;~15);
+                          video.h= (((val&gt;&gt;8) &amp; 0xfff)+15)&amp; ~15;
+
+                          video.ar = (val &gt;&gt; 4) &amp; 0xf;
+                          video.fps= FPS[val &amp; 0xf];
+                          pkt-&gt;forward(4);                      //+4
+                          writeVideo(&amp;video,ADM_TS_MPEG2);
+                          writeAudio();
+                          qfprintf(index,&quot;[Data]&quot;);
+
+                          decodingImage=false;
+                          pkt-&gt;getInfo(&amp;thisUnit.packetInfo);
+                          thisUnit.consumedSoFar=pkt-&gt;getConsumed();
+                          addUnit(data,unitTypeSps,thisUnit,4+4+4);
+                          continue;
+                          break;
+#warning FIXME, update pic field info.... It triggers a end-of-pic message as it is
+#if 0
+                    case 0xB5: //  extension
+                                { 
+                                    uint8_t id=pkt-&gt;readi8()&gt;&gt;4;  // +1
+                                    uint8_t two;
+                                    switch(id)
+                                    {
+                                        case 1: // Sequence extension
+                                            val=(val&gt;&gt;3)&amp;1; // gop type progressive, unreliable, not used
+                                            break;
+                                        case 8: // picture coding extension (mpeg2)
+                                        {
+                                            // skip motion vector
+                                            uint8_t picture_structure;
+                                            pkt-&gt;forward(1); // 4*4 bits   // +1
+                                            two=pkt-&gt;readi8();             // +1
+                                            picture_structure=(two)&amp;3;
+                                            
+                                            //printf(&quot;Picture type %02x struct:%x\n&quot;,two,picture_structure);
+                                            updatePicStructure(video,picture_structure);
+                                            pkt-&gt;getInfo(&amp;thisUnit.packetInfo);
+                                            thisUnit.consumedSoFar=pkt-&gt;getConsumed();
+                                            addUnit(data,unitTypePicInfo,thisUnit,4+1+1+1);
+                                        }
+                                        default:break;
+                                    }
+                                }
+                                break;
+#endif
+                  case 0xb8: // GOP
+                          // Update ui                        
+                          if(!seq_found) continue;
+
+                          pkt-&gt;getInfo(&amp;thisUnit.packetInfo);
+                          thisUnit.consumedSoFar=pkt-&gt;getConsumed();
+                          addUnit(data,unitTypeSps,thisUnit,4);
+                          break;
+                  case 0x00 : // picture
+                        {
+                          int type;
+                          if(!seq_found)
+                          { 
+                                  printf(&quot;[TsIndexer]No sequence start yet, skipping..\n&quot;);
+                                  continue;
+                          }
+                          
+                          val=pkt-&gt;readi16();             // +2
+                          
+                          temporal_ref=val&gt;&gt;6;
+                          type=7 &amp; (val&gt;&gt;3);
+                          if( type&lt;1 ||  type&gt;3)
+                          {
+                                  printf(&quot;[Indexer]Met illegal pic at %&quot;LLX&quot; + %&quot;LX&quot;\n&quot;,
+                                                  thisUnit.packetInfo.startAt,thisUnit.packetInfo.offset);
+                                  continue;
+                          }
+                          
+                          pkt-&gt;getInfo(&amp;thisUnit.packetInfo);
+                          thisUnit.consumedSoFar=pkt-&gt;getConsumed();
+                          thisUnit.imageType=type;
+                          addUnit(data,unitTypePic,thisUnit,4+2);
+                          data.nbPics++;
+                        }
+                          break;
+                  default:
+                    break;
+                  }
+      }
+    
+        printf(&quot;\n&quot;);
+        qfprintf(index,&quot;\n[End]\n&quot;);
+        qfprintf(index,&quot;\n# Found %&quot;LU&quot; images \n&quot;,data.nbPics); // Size
+        qfprintf(index,&quot;# Found %&quot;LU&quot; frame pictures\n&quot;,video.frameCount); // Size
+        qfprintf(index,&quot;# Found %&quot;LU&quot; field pictures\n&quot;,video.fieldCount); // Size
+        qfclose(index);
+        index=NULL;
+        audioTracks=NULL;
+        delete pkt;
+        pkt=NULL;
+        return 1; 
+}
+
+/********************************************************************************************/
+/********************************************************************************************/
+/********************************************************************************************/
+/********************************************************************************************/
+
+//
+
+//EOF

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS/ADM_tsIndexVC1.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS/ADM_tsIndexVC1.cpp	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS/ADM_tsIndexVC1.cpp	2010-11-13 14:26:03 UTC (rev 6757)
@@ -0,0 +1,385 @@
+/***************************************************************************
+                        Mpeg2 in PS indexer                                            
+                             
+    VC1: /!\ Escaping not done (yet)
+
+    copyright            : (C) 2005/2009 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &quot;ADM_tsIndex.h&quot;
+
+static const uint32_t  VC1_ar[16][2] = {  // From VLC
+                        { 0, 0}, { 1, 1}, {12,11}, {10,11}, {16,11}, {40,33},
+                        {24,11}, {20,11}, {32,11}, {80,33}, {18,11}, {15,11},
+                        {64,33}, {160,99},{ 0, 0}, { 0, 0}};
+
+
+/**
+    \fn runVC1
+    \brief Index VC1 stream
+*/  
+bool TsIndexer::runVC1(const char *file,ADM_TS_TRACK *videoTrac)
+{
+uint32_t temporal_ref,val;
+uint8_t buffer[50*1024];
+bool seq_found=false;
+
+TSVideo video;
+indexerData  data;    
+dmxPacketInfo info;
+
+
+    if(!videoTrac) return false;
+    if(videoTrac[0].trackType!=ADM_TS_VC1)
+    {
+        printf(&quot;[Ts Indexer] Only VC1 video supported\n&quot;);
+        return false;
+    }
+    video.pid=videoTrac[0].trackPid;
+
+    memset(&amp;data,0,sizeof(data));
+    data.picStructure=pictureFrame;
+    
+    string indexName=string(file);
+    indexName=indexName+string(&quot;.idx2&quot;);
+    index=qfopen(indexName,&quot;wt&quot;);
+
+    if(!index)
+    {
+        printf(&quot;[PsIndex] Cannot create %s\n&quot;,indexName.c_str());
+        return false;
+    }
+    writeSystem(file,true);
+    pkt=new tsPacketLinearTracker(videoTrac-&gt;trackPid, audioTracks);
+
+    FP_TYPE append=FP_APPEND;
+    pkt-&gt;open(file,append);
+    data.pkt=pkt;
+    fullSize=pkt-&gt;getSize();
+    int startCode;
+    decodingImage=false;
+#define likely(x) x
+#define unlikely(x) x
+      while(1)
+      {
+        startCode=pkt-&gt;findStartCode();
+        if(!pkt-&gt;stillOk()) break;
+
+          switch(startCode)
+                  {
+                  case 0x0f: // sequence start
+                          
+                          if(seq_found)
+                          {
+                              pkt-&gt;getInfo(&amp;thisUnit.packetInfo);
+                              thisUnit.consumedSoFar=pkt-&gt;getConsumed();
+                              addUnit(data,unitTypeSps,thisUnit,4);
+                              decodingImage=false;
+                              break;
+                          }
+                          // Verify it is high/advanced profile
+                          {
+                          int seqSize=0;
+                          tsGetBits bits(pkt);
+                          if(!bits.peekBits(1)) continue; // simple/main profile
+
+                          if(!decodeVC1Seq(bits,video)) continue;
+
+                          seqSize=bits.getConsumed();
+                          video.extraDataLength=seqSize+4+1;
+                          memcpy(video.extraData+4,bits.data,seqSize);
+                            // Add info so that ffmpeg is happy
+                          video.extraData[0]=0;
+                          video.extraData[1]=0;
+                          video.extraData[2]=1;
+                          video.extraData[3]=0xf;
+                          video.extraData[seqSize+4+0]=0;
+                          seq_found=1;
+                          // Hi Profile
+                          printf(&quot;[VC1] Found seq start with %d x %d video\n&quot;,(int)video.w,(int)video.h);
+                          printf(&quot;[VC1] FPS : %d\n&quot;,(int)video.fps);
+                          printf(&quot;[VC1] sequence header is %d bytes\n&quot;,(int)seqSize);
+                          writeVideo(&amp;video,ADM_TS_VC1);
+                          writeAudio();
+                          qfprintf(index,&quot;[Data]&quot;);
+                          
+                          pkt-&gt;getInfo(&amp;thisUnit.packetInfo);
+                          thisUnit.consumedSoFar=pkt-&gt;getConsumed();
+                          addUnit(data,unitTypeSps,thisUnit,seqSize+4);
+                          decodingImage=false;
+                          
+                          continue;
+                          }
+                          break;
+                    case 0x0D: //  Picture start
+                        { 
+                          int type;
+                          uint8_t buffer[4];
+                          uint32_t fType,sType;
+                          if(!seq_found)
+                          { 
+                                  continue;
+                                  printf(&quot;[TsIndexer]No sequence start yet, skipping..\n&quot;);
+                          }      
+                          pkt-&gt;getInfo(&amp;thisUnit.packetInfo);
+                          thisUnit.consumedSoFar=pkt-&gt;getConsumed();
+                          
+                          tsGetBits bits(pkt);
+                          if(!decodeVC1Pic(bits,fType,sType)) continue;
+                          thisUnit.imageType=fType;
+                          updatePicStructure(video,sType);
+                          addUnit(data,unitTypePic,thisUnit,4);
+                          decodingImage=true;
+                          data.nbPics++;
+                        }
+                          break;
+                  default:
+                    break;
+                  }
+      }
+    
+        printf(&quot;\n&quot;);
+//        Mark(&amp;data,&amp;info,2);
+        qfprintf(index,&quot;\n[End]\n&quot;);
+        qfprintf(index,&quot;\n# Found %&quot;LU&quot; images \n&quot;,data.nbPics); // Size
+        qfprintf(index,&quot;# Found %&quot;LU&quot; frame pictures\n&quot;,video.frameCount); // Size
+        qfprintf(index,&quot;# Found %&quot;LU&quot; field pictures\n&quot;,video.fieldCount); // Size
+        qfclose(index);
+        index=NULL;
+        audioTracks=NULL;
+        delete pkt;
+        pkt=NULL;
+        return 1; 
+}
+/**
+    \fn decodeVc1Seq
+    \brief <A HREF="http://wiki.multimedia.cx/index.php?title=VC-1#Setup_Data_.2F_Sequence_Layer">http://wiki.multimedia.cx/index.php?title=VC-1#Setup_Data_.2F_Sequence_Layer</A>
+#warning we should de-escape it!
+        Large part of this borrowed from VLC
+        Advanced/High profile only
+*/
+bool TsIndexer::decodeVC1Seq(tsGetBits &amp;bits,TSVideo &amp;video)
+{
+
+int v;
+int consumed;
+    vc1Context.advanced=true;
+
+#define VX(a,b) v=bits.getBits(a);printf(&quot;[VC1] %d &quot;#b&quot;\n&quot;,v);consumed+=a;
+    VX(2,profile);
+    VX(3,level);
+
+    VX(2,chroma_format);
+    VX(3,Q_frame_rate_unused);
+    VX(5,Q_bit_unused);
+
+    VX(1,postproc_flag);
+
+    VX(12,coded_width);
+    video.w=v*2+2;
+    VX(12,coded_height);
+    video.h=v*2+2;
+
+    VX(1,pulldown_flag);
+    VX(1,interlaced_flag);
+    vc1Context.interlaced=v;
+    VX(1,frame_counter_flag);
+
+    VX(1,interpolation_flag);
+    vc1Context.interpolate=v;
+
+    VX(1,reserved_bit);
+    VX(1,psf);
+
+    VX(1,display_extension);
+    if(v)
+    {
+         VX(14,display_extension_coded_width);
+         VX(14,display_extension_coded_height);
+         VX(1,aspect_ratio_flag);
+     
+
+         if(v)
+         {
+                VX(4,aspect_ratio);
+                switch(v)
+                {
+                    case 15: video.ar=(bits.getBits(8)&lt;&lt;16)+bits.getBits(8);
+                             break;
+                    default:
+                             video.ar=(VC1_ar[v][0]&lt;&lt;16)+(VC1_ar[v][1]&lt;&lt;16);
+                             break;
+                }
+                printf(&quot;[VC1] Aspect ratio %d x %d\n&quot;,video.ar&gt;&gt;8,video.ar&amp;0xff);
+         }
+    
+        VX(1,frame_rate);
+        if(v)
+        {
+                VX(1,frame_rate32_flag);
+                if(v)
+                {
+                    VX(16,frame_rate32);
+                    float f=v;
+                    f=(f+1)/32;
+                    f*=1000;
+                    video.fps=(uint32_t)f;
+                }else
+                {
+                    float den,num;
+                    VX(8,frame_rate_num)
+                    switch( v )
+                        {
+                        case 1: num = 24000; break;
+                        case 2: num = 25000; break;
+                        case 3: num = 30000; break;
+                        case 4: num = 50000; break;
+                        case 5: num = 60000; break;
+                        case 6: num = 48000; break;
+                        case 7: num = 72000; break;
+                        }
+                    VX(4,frame_rate_den)
+                    switch( v )
+                        {
+                        default:
+                        case 1: den = 1000; break;
+                        case 2: den = 1001; break;
+                        }
+
+                    float f=num*1000;
+                    f/=den;
+                    video.fps=(uint32_t)f;
+                }
+            }else
+            {
+                video.fps=25000;
+            }
+            //
+            VX(1,color_flag);
+            if(v){
+                    VX(8,color_prim);
+                    VX(8,transfer_char);
+                    VX(8,matrix_coef);
+                }
+    }
+    VX(1,hrd_param_flag);
+    int leaky=0;
+    if(v)
+    {
+        VX(5,hrd_num_leaky_buckets);
+        leaky=v;
+        VX(4,bitrate_exponent);
+        VX(4,buffer_size_exponent);
+        for(int i = 0; i &lt; leaky; i++) 
+        {
+                bits.getBits(16);
+                bits.getBits(16);
+        }
+    }
+    // Now we need an entry point
+    bits.flush();
+    uint8_t a[4];
+    uint8_t entryPoint[4]={0,0,1,0x0E};
+    for(int i=0;i&lt;4;i++) a[i]=bits.getBits(8);
+    for(int i=0;i&lt;4;i++) printf(&quot;%02x &quot;,a[i]);
+    printf(&quot; as marker\n&quot;);
+    if(memcmp(a,entryPoint,4))
+    {
+        ADM_warning(&quot;Bad entry point&quot;);
+        return false;
+    }
+    VX(6,ep_flags);
+    VX(1,extended_mv);
+    int extended_mv=v;
+    VX(6,ep_flags2);
+
+    for(int i=0;i&lt;leaky;i++)
+            bits.getBits(8);
+    VX(1,ep_coded_dimension);
+    if(v)
+    {
+         VX(12,ep_coded_width);
+         VX(12,ep_coded_height);
+    }
+    if(extended_mv) VX(1,dmv);
+    VX(1,range_mappy_flags);
+    if(v) VX(3,mappy_flags);
+    VX(1,range_mappuv_flags);
+    if(v) VX(3,mappuv_flags);
+    return true;
+
+}
+/**
+    \fn decodeVC1Pic
+    \brief Decode info from VC1 picture
+    Borrowed a lot from VLC also
+
+*/
+bool TsIndexer::decodeVC1Pic(tsGetBits &amp;bits,uint32_t &amp;frameType,uint32_t &amp;frameStructure)
+{
+    frameStructure=3;
+    bool field=false;
+    if(vc1Context.interlaced)
+    {
+        if(bits.getBits(1))
+        {
+            if(bits.getBits(1))
+               field=true;
+        }
+    }
+    if(field)
+    {
+            int fieldType=bits.getBits(3);
+            frameStructure=1; // Top
+            switch(fieldType)
+            {
+                case 0: /* II */
+                case 1: /* IP */
+                case 2: /* PI */
+                    frameType=1;
+                    break;
+                case 3: /* PP */
+                    frameType=2;
+                    break;
+                case 4: /* BB */
+                case 5: /* BBi */
+                case 6: /* BiB */
+                case 7: /* BiBi */
+                    frameType=3;
+                    break;
+
+            }
+    }else
+    {
+                frameStructure=3; // frame
+                if( !bits.getBits(1))
+                    frameType=2;
+                else if( !bits.getBits(1))
+                    frameType=3;
+                else if( !bits.getBits(1))
+                    frameType=1;
+                else if( !bits.getBits(1))
+                    frameType=3;
+                else
+                    frameType=2;
+    }
+
+    return true;
+}
+/********************************************************************************************/
+/********************************************************************************************/
+/********************************************************************************************/
+/********************************************************************************************/
+
+//
+
+//EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS/CMakeLists.txt	2010-11-13 14:25:59 UTC (rev 6756)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS/CMakeLists.txt	2010-11-13 14:26:03 UTC (rev 6757)
@@ -4,6 +4,8 @@
 	ADM_tsPlugin.cpp
 	ADM_tsIndex.cpp
 	ADM_tsIndexH264.cpp
+        ADM_tsIndexVC1.cpp
+        ADM_tsIndexMpeg2.cpp
 	ADM_tsReadIndex.cpp
 	ADM_tsAudio.cpp
 	ADM_tsAudioProbe.cpp


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003937.html">[Avidemux-svn-commit] r6756 -	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS
</A></li>
	<LI>Next message: <A HREF="003936.html">[Avidemux-svn-commit] r6758 -	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3935">[ date ]</a>
              <a href="thread.html#3935">[ thread ]</a>
              <a href="subject.html#3935">[ subject ]</a>
              <a href="author.html#3935">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
