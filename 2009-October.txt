From gruntster at mail.berlios.de  Thu Oct  1 08:10:50 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Thu, 1 Oct 2009 08:10:50 +0200
Subject: [Avidemux-svn-commit] r5361 -
	branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264
Message-ID: <200910010610.n916AoNL016672@sheep.berlios.de>

Author: gruntster
Date: 2009-10-01 08:10:45 +0200 (Thu, 01 Oct 2009)
New Revision: 5361

Modified:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/encoder.cpp
Log:
[x264] compilation fix for older API

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/encoder.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/encoder.cpp	2009-09-30 21:25:18 UTC (rev 5360)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/encoder.cpp	2009-10-01 06:10:45 UTC (rev 5361)
@@ -454,7 +454,7 @@
 	_extraData = new uint8_t[X264_MAX_HEADER_SIZE];
 	_extraDataSize = 0;
 
-	x264_encoder_headers(_handle, &nal, &nalCount)
+	x264_encoder_headers(_handle, &nal, &nalCount);
 
 	printf("[x264] Nal count: %d\n", nalCount);
 



From gruntster at mail.berlios.de  Thu Oct  1 21:14:24 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Thu, 1 Oct 2009 21:14:24 +0200
Subject: [Avidemux-svn-commit] r5362 - in
	branches/avidemux_2.5_branch_gruntster: . avidemux
Message-ID: <200910011914.n91JEOSE012964@sheep.berlios.de>

Author: gruntster
Date: 2009-10-01 21:14:16 +0200 (Thu, 01 Oct 2009)
New Revision: 5362

Modified:
   branches/avidemux_2.5_branch_gruntster/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/CMakeLists.txt
Log:
[macosx] build script tweaks by surfer

Modified: branches/avidemux_2.5_branch_gruntster/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/CMakeLists.txt	2009-10-01 06:10:45 UTC (rev 5361)
+++ branches/avidemux_2.5_branch_gruntster/CMakeLists.txt	2009-10-01 19:14:16 UTC (rev 5362)
@@ -76,6 +76,24 @@
 	SET(BIN_DIR bin)
 ENDIF (WIN32)
 
+IF (APPLE)
+	## Add needed Compiler and Linker flags for OSX
+	SET(CMAKE_C_FLAGS:STRING "\"$CMAKE_C_FLAGS\" -flat_namespace -undefined suppress" )
+	SET(CMAKE_CXX_FLAGS:STRING "\"$CMAKE_CXX_FLAGS\" -flat_namespace -undefined suppress" )
+	SET(CMAKE_LDFLAGS:STRING "\"$CMAKE_LD_FLAGS\"" )
+	SET(CMAKE_INSTALL_NAME_DIR "${CMAKE_INSTALL_PREFIX}/lib" )
+
+	IF (${CMAKE_BUILD_TYPE} STREQUAL "Release")
+		SET(CMAKE_C_FLAGS_RELEASE:STRING " $CMAKE_C_FLAGS_RELEASE ")
+		SET(CMAKE_CXX_FLAGS_RELEASE:STRING " $CMAKE_CXX_FLAGS_RELEASE ")
+	ENDIF (${CMAKE_BUILD_TYPE} STREQUAL "Release")
+
+	if (${MAC_SELF_CONTAINED_BUNDLE})
+		MESSAGE(STATUS "Configuring avidemux for fully bundled version. (not yet working correctly)")
+		SET(CMAKE_INSTALL_NAME_DIR "@executable_path/../Libraries" )
+	endif (${MAC_SELF_CONTAINED_BUNDLE})
+ENDIF (APPLE)
+
 ########################################
 # Standard Avidemux defines
 ########################################

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/CMakeLists.txt	2009-10-01 06:10:45 UTC (rev 5361)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/CMakeLists.txt	2009-10-01 19:14:16 UTC (rev 5362)
@@ -479,20 +479,22 @@
 IF (ADM_UI_QT4)
 	SET(ADM_EXES ${ADM_EXES} avidemux2_qt4)
 
-	IF (APPLE)
+	IF (APPLE AND MAC_SELF_CONTAINED_BUNDLE)
 		MakeOSXBundleApp(avidemux2_qt4 ${PROJECT_BINARY_DIR})
-	ENDIF (APPLE)
+	ENDIF (APPLE AND MAC_SELF_CONTAINED_BUNDLE)
 ENDIF (ADM_UI_QT4)
 
 IF (ADM_UI_GTK)
 	SET(ADM_EXES ${ADM_EXES} avidemux2_gtk)
 
-	IF (APPLE)
+	IF (APPLE AND MAC_SELF_CONTAINED_BUNDLE)
 		MakeOSXBundleApp(avidemux2_gtk ${PROJECT_BINARY_DIR})
-	ENDIF (APPLE)
+	ENDIF (APPLE AND MAC_SELF_CONTAINED_BUNDLE)
 ENDIF (ADM_UI_GTK)
 
 IF (APPLE)
+	set_target_properties(${ADM_EXES} PROPERTIES INSTALL_NAME_DIR ${CMAKE_INSTALL_NAME_DIR})
+
 	IF (MAC_BUNDLE_DIR)
 		INSTALL(TARGETS ${ADM_EXES} RUNTIME DESTINATION ${BIN_DIR} BUNDLE DESTINATION ${MAC_BUNDLE_DIR} LIBRARY DESTINATION lib)
 	ELSE (MAC_BUNDLE_DIR)



From mean at mail.berlios.de  Fri Oct  2 07:22:04 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 2 Oct 2009 07:22:04 +0200
Subject: [Avidemux-svn-commit] r5363 - in branches/avidemux_2.6_branch_mean:
	avidemux/common/ADM_filter avidemux/common/ADM_videoFilter2
	avidemux_core/ADM_coreVideoFilter/include
	avidemux_plugins/ADM_videoFilters6/dummy
Message-ID: <200910020522.n925M4b3030453@sheep.berlios.de>

Author: mean
Date: 2009-10-02 07:22:03 +0200 (Fri, 02 Oct 2009)
New Revision: 5363

Added:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_filterCategory.h
Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/filter.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/ADM_pluginLoad.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_vf_plugin.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/dummy/dummyVideoFilter.cpp
Log:
[videoFilter] Add category & UI, begin to remove old video filter code

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/filter.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/filter.cpp	2009-10-01 19:14:16 UTC (rev 5362)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/filter.cpp	2009-10-02 05:22:03 UTC (rev 5363)
@@ -14,6 +14,7 @@
  *   (at your option) any later version.                                   *
  *                                                                         *
  ***************************************************************************/
+#if 0
 #include "ADM_default.h"
 #include <vector>
 #include "fourcc.h"
@@ -474,4 +475,5 @@
                 }
 
 }
+#endif
 // EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/ADM_pluginLoad.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/ADM_pluginLoad.cpp	2009-10-01 19:14:16 UTC (rev 5362)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/ADM_pluginLoad.cpp	2009-10-02 05:22:03 UTC (rev 5363)
@@ -24,10 +24,20 @@
 #else
 #define aprintf(...) {}
 #endif
+/**
+    \struct admVideoFilterInfo
+*/
+typedef struct  
+{
+        const char                  *internalName;
+        const char                  *displayName;
+        const char                  *desc;
+        VF_CATEGORY                 category;   
+}admVideoFilterInfo;
 
-
 /**
- *
+ *  \class ADM_vf_plugin
+ *  \brief Base class for video filter loader
  */
 class ADM_vf_plugin : public ADM_LibWrapper
 {
@@ -35,20 +45,21 @@
 		ADM_vf_CreateFunction		*create;
 		ADM_vf_DeleteFunction		*destroy;
 		ADM_vf_SupportedUI		    *supportedUI;
+        
 		ADM_vf_GetApiVersion		*getApiVersion;
-		ADM_ad_GetPluginVersion	    *getFilterVersion;
-		ADM_ADM_vf_GetString    	*getDesc;
-        ADM_ADM_vf_GetString    	*getInternalName;
-        ADM_ADM_vf_GetString    	*getDisplayName;
-        
-		const char 					*nameOfLibrary;
-        const char                  *internalName;
-        const char                  *displayName;
-        const char                  *desc;
+		ADM_vf_GetPluginVersion	    *getFilterVersion;
+		ADM_vf_GetString    	    *getDesc;
+        ADM_vf_GetString    	    *getInternalName;
+        ADM_vf_GetString    	    *getDisplayName;
+        ADM_vf_getCategory          *getCategory;
 
+        const char 					*nameOfLibrary;
+	
+        admVideoFilterInfo          info;
+
 		ADM_vf_plugin(const char *file) : ADM_LibWrapper()
 		{
-			initialised = (loadLibrary(file) && getSymbols(6,
+			initialised = (loadLibrary(file) && getSymbols(7,
 				&create, "create",
 				&destroy, "destroy",
 				&getApiVersion, "getApiVersion",
@@ -56,7 +67,8 @@
 				&getFilterVersion, "getFilterVersion",
 				&getDesc, "getDesc",
 				&getInternalName, "getInternalName",
-				&getDisplayName, "getDisplayName"
+				&getDisplayName, "getDisplayName",
+                &getCategory,"getCategory"
                 ));
 		};
 };
@@ -69,6 +81,7 @@
 static uint8_t tryLoadingVideoFilterPlugin(const char *file)
 {
 	ADM_vf_plugin *plugin = new ADM_vf_plugin(file);
+    admVideoFilterInfo          *info=NULL;
 
 	if (!plugin->isAvailable())
 	{
@@ -83,19 +96,27 @@
 			ADM_GetFileName(file), plugin->getApiVersion(), VF_API_VERSION);
 		goto Err_ad;
 	}
+    if(!(plugin->supportedUI() & 0xff))
+    {  // FIXME
 
+
+    }
 	// Get infos
 	uint32_t major, minor, patch;
 
 	plugin->getFilterVersion(&major, &minor, &patch);
 	plugin->nameOfLibrary = ADM_strdup(ADM_GetFileName(file));
 
-    plugin->internalName=plugin->getInternalName();
-    plugin->desc=plugin->getDesc();
-    plugin->displayName=plugin->getDisplayName();
+    info=&(plugin->info);
 
+
+    info->internalName=plugin->getInternalName();
+    info->desc=plugin->getDesc();
+    info->displayName=plugin->getDisplayName();
+    info->category=plugin->getCategory();
+
 	printf("[ADM_vf_plugin] Plugin loaded version %d.%d.%d, name %s/%s\n",
-		major, minor, patch, plugin->internalName, plugin->displayName);
+		major, minor, patch, info->internalName, info->displayName);
 
 	ADM_videoFilterPluginsList.push_back(plugin);
 
@@ -129,7 +150,7 @@
     	ADM_vf_plugin *a=ADM_videoFilterPluginsList[filter];
         a->getFilterVersion(major, minor, patch);
 
-        *name=a->displayName;
+        *name=a->info.displayName;
         return 1;
 }
 

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_filterCategory.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_filterCategory.h	2009-10-01 19:14:16 UTC (rev 5362)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_filterCategory.h	2009-10-02 05:22:03 UTC (rev 5363)
@@ -0,0 +1,38 @@
+/***************************************************************************
+                          video_filters.h  -  description
+                             -------------------
+    begin                : Wed Mar 27 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+ #ifndef __VIDEO_FILTERS__CATEGORY__
+ #define  __VIDEO_FILTERS__CATEGORY__
+
+typedef enum
+{
+	VF_TRANSFORM=0,
+	VF_INTERLACING=1,
+	VF_COLORS=2,
+	VF_NOISE=3,
+	VF_SHARPNESS=4,
+	VF_SUBTITLE=5,
+	VF_MISC=6,
+	VF_MAX=7
+}VF_CATEGORY;
+#define VF_INVALID 		  0
+
+#define VF_PARTIAL_FILTER 9
+#define VF_START_TAG 	  10
+
+typedef uint32_t VF_FILTERS ;
+
+ #endif

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_vf_plugin.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_vf_plugin.h	2009-10-01 19:14:16 UTC (rev 5362)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_vf_plugin.h	2009-10-02 05:22:03 UTC (rev 5363)
@@ -5,19 +5,21 @@
 #ifndef ADM_vf_plugin_h
 #define ADM_vf_plugin_h
 #include "ADM_default.h"
+#include "DIA_uiTypes.h"
 #include "ADM_coreVideoFilter.h"
+#include "ADM_filterCategory.h"
 
 #define VF_API_VERSION 1
 /* These are the 6 functions exported by each plugin ...*/
 typedef ADM_coreVideoFilter  *(ADM_vf_CreateFunction)(ADM_coreVideoFilter *previous,CONFcouple *conf);
-typedef void             (ADM_vf_DeleteFunction)(ADM_coreVideoFilter *codec);
-typedef int             (ADM_vf_SupportedUI)(void); //  QT4/GTK / ALL
-typedef uint32_t         (ADM_vf_GetApiVersion)(void);
-typedef bool            (ADM_ad_GetPluginVersion)(uint32_t *major, uint32_t *minor, uint32_t *patch);
-typedef const char       *(ADM_ADM_vf_GetString)(void);
+typedef void              (ADM_vf_DeleteFunction)(ADM_coreVideoFilter *codec);
+typedef int               (ADM_vf_SupportedUI)(void); //  QT4/GTK / ALL
+typedef uint32_t          (ADM_vf_GetApiVersion)(void);
+typedef bool              (ADM_vf_GetPluginVersion)(uint32_t *major, uint32_t *minor, uint32_t *patch);
+typedef const char       *(ADM_vf_GetString)(void);
+typedef VF_CATEGORY       (ADM_vf_getCategory)(void);
 
-
-#define DECLARE_VIDEO_FILTER(Class,Major,Minor,Patch,UI,internalName,displayName,Desc) \
+#define DECLARE_VIDEO_FILTER(Class,Major,Minor,Patch,UI,category,internalName,displayName,Desc) \
 	extern "C" { \
 	ADM_coreVideoFilter *create(ADM_coreVideoFilter *previous,CONFcouple *conf)\
 	{ \
@@ -30,7 +32,7 @@
 	}\
 	int supportedUI(void) \
 	{ \
-		return 0; \
+		return UI; \
 	} \
 	uint32_t getApiVersion(void)\
 	{\
@@ -55,6 +57,10 @@
 	{\
 		return displayName; \
 	}\
+    VF_CATEGORY getCategory(void) \
+    { \
+        return category;\
+    }\
 	}
 
 #endif

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/dummy/dummyVideoFilter.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/dummy/dummyVideoFilter.cpp	2009-10-01 19:14:16 UTC (rev 5362)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/dummy/dummyVideoFilter.cpp	2009-10-02 05:22:03 UTC (rev 5363)
@@ -37,7 +37,8 @@
 // Add the hook to make it valid plugin
 DECLARE_VIDEO_FILTER(   dummyVideoFilter,   // Class
                         1,0,0,              // Version
-                        0,                  // UI
+                        ADM_UI_ALL,         // UI
+                        VF_MISC,            // Category
                         "dummy",            // internal name (must be uniq!)
                         "Dummy",            // Display name
                         "Null filter, it does nothing at all." // Description



From mean at mail.berlios.de  Fri Oct  2 07:22:09 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 2 Oct 2009 07:22:09 +0200
Subject: [Avidemux-svn-commit] r5364 - in
	branches/avidemux_2.6_branch_mean/avidemux: . common
	common/ADM_editor common/ADM_filter common/ADM_script
	common/ADM_toolkit common/ADM_video common/ADM_videoFilter2
	gtk/ADM_userInterfaces/ADM_dialog gtk/ADM_userInterfaces/ADM_filters
Message-ID: <200910020522.n925M9SY030648@sheep.berlios.de>

Author: mean
Date: 2009-10-02 07:22:07 +0200 (Fri, 02 Oct 2009)
New Revision: 5364

Removed:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/ADM_vidDummyFilter.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/buildummy.sh
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/buildummy_win32.sh
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/buildummy_yadif.sh
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/buildummy_yadif_win32.sh
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_video/ADM_reorderTemplate.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_video/ADM_vidNull.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_video/ADM_vidPartial.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_video/ADM_vidPartial.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_video/ADM_vidPartial_param.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_video/ADM_vidRaw.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_video/ADM_videoNull.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_video/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_dialog/DIA_partial.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edLoadSave.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/filter_declaration.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/filter_saveload.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script/ADM_JSAvidemuxVideo.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_toolkit/automation.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/ADM_pluginLoad.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/gui_play.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/main.cpp
   branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake
   branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_dialog/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_filters/gui_filtermanager.cpp
Log:
[Vfilter] Keep on removing old stuff

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edLoadSave.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edLoadSave.cpp	2009-10-02 05:22:03 UTC (rev 5363)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edLoadSave.cpp	2009-10-02 05:22:07 UTC (rev 5364)
@@ -150,7 +150,7 @@
 // Filter
 //___________________________
         qfprintf(fd,"\n//** Filters **\n");
-        filterSaveScriptJS(fd);
+//        filterSaveScriptJS(fd);
 
 // Video codec
 //___________________________

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/ADM_vidDummyFilter.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/ADM_vidDummyFilter.cpp	2009-10-02 05:22:03 UTC (rev 5363)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/ADM_vidDummyFilter.cpp	2009-10-02 05:22:07 UTC (rev 5364)
@@ -1,139 +0,0 @@
-/***************************************************************************
-                          ADM_vidFlipV.cpp  -  description
-                             -------------------
-    begin                : Wed Nov 6 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-
-#if 0 // OBSOLETE
-
-#include "ADM_default.h"
-
-#include "ADM_videoFilter.h"
-#include "ADM_videoFilter/ADM_vidFlipV.h"
-
-//#define REDUCED
-//adm_fast_memcpy myAdmMemcpy=memcpy;
-#undef memcpy
-
-static FILTER_PARAM flipParam={0,{""}};
-
-//********************************************
-extern "C"
-{
-SCRIPT_CREATE(FILTER_create_fromscript,ADMVideoFlipV,flipParam);
-BUILD_CREATE(FILTER_create,ADMVideoFlipV);
-char *FILTER_getName(void)
-{
-	return "DynFLIPPER";
-}
-
-char *FILTER_getDesc(void)
-{
-	return "Vertical flip, demo for dynamically loaded filters";
-}
-
-
-
-uint32_t FILTER_getVersion(void)
-{
-  return 1; 
-}
-uint32_t FILTER_getAPIVersion(void)
-{
-  return ADM_FILTER_API_VERSION; 
-}
-}
-
-//********************************************
-char *ADMVideoFlipV::printConf( void )
-{
- 	ADM_FILTER_DECLARE_CONF(" V-Flip");
-
-}
-
-ADMVideoFlipV::ADMVideoFlipV(  AVDMGenericVideoStream *in,CONFcouple *setup)
-{
-    UNUSED_ARG(setup);
-    	ADM_assert(in);
- 	_in=in;		
-	printf("%s\n",_in->printConf());
-   	memcpy(&_info,_in->getInfo(),sizeof(_info)); 	
-  	_info.encoding=1;	
-	_uncompressed=new ADMImage(_in->getInfo()->width,_in->getInfo()->height);
-	ADM_assert(_uncompressed);    	  	
-}
-ADMVideoFlipV::~ADMVideoFlipV()
-{
- 	delete  _uncompressed;	
-	_uncompressed=NULL;
-  
-}
-uint8_t ADMVideoFlipV::getFrameNumberNoAlloc(uint32_t frame,
-				uint32_t *len,
-   				ADMImage *data,
-				uint32_t *flags)
-{
-
-	if(frame>= _info.nb_frames) return 0;
-	// read uncompressed frame
-	if(!_in->getFrameNumberNoAlloc(frame, len,_uncompressed,flags)) return 0;
-
-         uint8_t *in,*out;
-         uint32_t stride=_info.width;
-         uint32_t h=_info.height;
-         uint32_t page,qpage;
-        
-
-	  
-         page=stride*h;
-         qpage=page>>2;
-         
-         in=YPLANE(_uncompressed);
-         out=YPLANE(data)+(h-1)*stride;
-         // flip y
-         for(uint32_t y=h;y>0;y--)
-         {
-		 memcpy(out,in,stride);
-		 in+=stride;
-		 out-=stride;
-	}
-	// Flip U & V			         
-        stride>>=1;
-	in=UPLANE(_uncompressed);	
-        out=UPLANE(data)+qpage-stride;
-         // flip u
-         for(uint32_t y=h>>1;y>0;y--)
-         {
-		 memcpy(out,in,stride);
-		 in+=stride;
-		 out-=stride;
-	}
-	in=VPLANE(_uncompressed);
-        out=VPLANE(data)+qpage-stride;
-       
-      
-         // flip u
-         for(uint32_t y=h>>1;y>0;y--)
-         {
-		 memcpy(out,in,stride);
-		 in+=stride;
-		 out-=stride;
-	}   
-	data->copyInfo(_uncompressed);
-	return 1;
-}
-
-#endif
-

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/CMakeLists.txt	2009-10-02 05:22:03 UTC (rev 5363)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/CMakeLists.txt	2009-10-02 05:22:07 UTC (rev 5364)
@@ -1,5 +1,4 @@
 SET(ADM_filter_SRCS 
-ADM_vidDummyFilter.cpp  
 filter.cpp  
 filter_declaration.cpp  
 filter_saveload.cpp  

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/buildummy.sh
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/buildummy.sh	2009-10-02 05:22:03 UTC (rev 5363)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/buildummy.sh	2009-10-02 05:22:07 UTC (rev 5364)
@@ -1,3 +0,0 @@
-g++ -DHAVE_CONFIG_H -I. -I. -I../..  -I../ADM_libraries -I../ADM_libraries/ADM_utilities -I../ADM_libraries/ADM_lavutil -I/usr/include/libxml2  -I/usr/include/malloc -I/usr/include/libxml2 -I/usr/include/SDL -D_GNU_SOURCE=1 -D_REENTRANT  -I.. -I../ADM_lavutil -IADM_utilities -I../ADM_utilities  -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64 -g -O2 -I../.. -O1 -g3 -falign-loops=16 -shared -o dummy.so ADM_vidDummyFilter.cpp -fPIC
-g++ -DHAVE_CONFIG_H -I. -I. -I../..  -I../ADM_libraries -I../ADM_libraries/ADM_utilities -I../ADM_libraries/ADM_lavutil -I/usr/include/libxml2  -I/usr/include/malloc -I/usr/include/libxml2 -I/usr/include/SDL -D_GNU_SOURCE=1 -D_REENTRANT  -I.. -I../ADM_lavutil -IADM_utilities -I../ADM_utilities  -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64 -g -O2 -I../.. -O1 -g3 -falign-loops=16 -o dummy.E -E ADM_vidDummyFilter.cpp -fPIC
-cp dummy.so ~/Xfilters

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/buildummy_win32.sh
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/buildummy_win32.sh	2009-10-02 05:22:03 UTC (rev 5363)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/buildummy_win32.sh	2009-10-02 05:22:07 UTC (rev 5364)
@@ -1,10 +0,0 @@
-i586-mingw32msvc-g++ -DHAVE_CONFIG_H -I/rot2/include/ -I. -I. -I../..  -I../ADM_libraries -I../ADM_libraries/ADM_utilities -I../ADM_libraries/ADM_lavutil -I/usr/include/libxml2  -I/usr/include/malloc -I/usr/include/libxml2 -I/usr/include/SDL -D_GNU_SOURCE=1 -D_REENTRANT  -I.. -I../ADM_lavutil -IADM_utilities -I../ADM_utilities  -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64 -g -O2 -I../.. -O1 -g3 -falign-loops=16 \
--c -o dummy.o \
-ADM_vidDummyFilter.cpp  -mno-cygwin -mms-bitfields -mwindows
-
-i586-mingw32msvc-g++ -shared dummy.o -o dummy.dll -L.. \
-    -Wl,--export-all-symbols \
-    -Wl,--enable-auto-import \
-    -mno-cygwin -lmingw32  ../libavidemux2.dll.a
-    #../avidemux2_gtk.exe
-#../avidemux2_gtk.exe.a \

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/buildummy_yadif.sh
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/buildummy_yadif.sh	2009-10-02 05:22:03 UTC (rev 5363)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/buildummy_yadif.sh	2009-10-02 05:22:07 UTC (rev 5364)
@@ -1,4 +0,0 @@
-g++ -DHAVE_CONFIG_H -I. -I. -I../..  -I../ADM_libraries -I../ADM_libraries/ADM_utilities -I../ADM_libraries/ADM_lavutil -I/usr/include/libxml2  -I/usr/include/malloc -I/usr/include/libxml2 -I/usr/include/SDL -D_GNU_SOURCE=1 -D_REENTRANT  -I.. -I../ADM_lavutil -IADM_utilities -I../ADM_utilities  -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64 -g -O2 -I../.. -O1 -g3 -falign-loops=16  -o dummy.o ../ADM_videoFilter/ADM_vidYadif.cpp  -c -fPIC
-gcc -DHAVE_CONFIG_H -I. -I. -I../..  -I../ADM_libraries -I../ADM_libraries/ADM_utilities -I../ADM_libraries/ADM_lavutil -I/usr/include/libxml2  -I/usr/include/malloc -I/usr/include/libxml2 -I/usr/include/SDL -D_GNU_SOURCE=1 -D_REENTRANT  -I.. -I../ADM_lavutil -IADM_utilities -I../ADM_utilities  -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64 -g -O2 -I../.. -O1 -g3 -falign-loops=16  -o dummy2.o ../ADM_videoFilter/ADM_vidYadif_asm.c  -c -fPIC
-g++ -shared dummy.o dummy2.o -o yadif.so
-cp yadif.so ~/Xfilters

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/buildummy_yadif_win32.sh
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/buildummy_yadif_win32.sh	2009-10-02 05:22:03 UTC (rev 5363)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/buildummy_yadif_win32.sh	2009-10-02 05:22:07 UTC (rev 5364)
@@ -1,15 +0,0 @@
-i586-pc-mingw32-g++ -DHAVE_CONFIG_H -I/rot2/include/ -I. -I. -I../..  -I../ADM_libraries -I../ADM_libraries/ADM_utilities -I../ADM_libraries/ADM_lavutil -I/usr/include/libxml2  -I/usr/include/malloc -I/usr/include/libxml2 -I/usr/include/SDL -D_GNU_SOURCE=1 -D_REENTRANT  -I.. -I../ADM_lavutil -IADM_utilities -I../ADM_utilities  -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64 -g -O2 -I../.. -O1 -g3 -falign-loops=16 \
--c -o yad_dummy.o \
-../ADM_videoFilter/ADM_vidYadif.cpp  -mno-cygwin -mms-bitfields -mwindows
-
-i586-pc-mingw32-gcc -DHAVE_CONFIG_H -I/rot2/include/ -I. -I. -I../..  -I../ADM_libraries -I../ADM_libraries/ADM_utilities -I../ADM_libraries/ADM_lavutil -I/usr/include/libxml2  -I/usr/include/malloc -I/usr/include/libxml2 -I/usr/include/SDL -D_GNU_SOURCE=1 -D_REENTRANT  -I.. -I../ADM_lavutil -IADM_utilities -I../ADM_utilities  -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64 -g -O2 -I../.. -O1 -g3 -falign-loops=16 \
--c -o yad_dummy2.o \
-../ADM_videoFilter/ADM_vidYadif_asm.c  -mno-cygwin -mms-bitfields -mwindows
-
-i586-pc-mingw32-g++ -shared yad_dummy.o yad_dummy2.o -o yadif.dll -L.. \
-    -Wl,--export-all-symbols \
-    -Wl,--enable-auto-import \
-    -mno-cygwin -lmingw32  ../libavidemux2.dll.a
-    #../avidemux2_gtk.exe
-i586-pc-mingw32-strip -S yadiff.dll
-#../avidemux2_gtk.exe.a \

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/filter_declaration.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/filter_declaration.cpp	2009-10-02 05:22:03 UTC (rev 5363)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/filter_declaration.cpp	2009-10-02 05:22:07 UTC (rev 5364)
@@ -54,8 +54,8 @@
 	REGISTERX("swissarmyknife",QT_TR_NOOP("Swiss Army Knife"),QT_TR_NOOP("Apply operation like P'=P*A, P-A, P+A, etc. using a convolution, rolling average, image from file, or constant"),VF_SWISSARMYKNIFE,1,swissarmyknife_create,swissarmyknife_script);
 #endif
 // Misc filter, internal only
-	REGISTERX(VF_MISC,"partial",QT_TR_NOOP("Partial"),"",VF_PARTIAL,0,partial_create,partial_script);
-	REGISTERX(VF_MISC,"framenum",QT_TR_NOOP("Add Framenumber"),QT_TR_NOOP("Print frame number directly in image"),VF_FRAMENUM,1,number_create,number_script);
+//	REGISTERX(VF_MISC,"partial",QT_TR_NOOP("Partial"),"",VF_PARTIAL,0,partial_create,partial_script);
+//	REGISTERX(VF_MISC,"framenum",QT_TR_NOOP("Add Framenumber"),QT_TR_NOOP("Print frame number directly in image"),VF_FRAMENUM,1,number_create,number_script);
  printf("\n");
 }
 

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/filter_saveload.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/filter_saveload.cpp	2009-10-02 05:22:03 UTC (rev 5363)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/filter_saveload.cpp	2009-10-02 05:22:07 UTC (rev 5364)
@@ -28,9 +28,9 @@
 
 #include "ADM_editor/ADM_edit.hxx"
 #include "ADM_videoFilter.h"
-#include "ADM_video/ADM_videoNull.h"
+//#include "ADM_video/ADM_videoNull.h"
 #include "ADM_videoFilter_internal.h"
-#include "ADM_video/ADM_vidPartial.h"
+//#include "ADM_video/ADM_vidPartial.h"
 #include "avi_vars.h"
 // exported vars
 extern uint32_t nb_active_filter;
@@ -134,6 +134,7 @@
 
 int filterLoadXml(const char *docname,uint8_t silent)
 {
+#if 0
  xmlDocPtr xdoc;
  xmlNodePtr node,subnode;
 int32_t nb_filters,itag;
@@ -237,6 +238,7 @@
 			}
 			printf("\n found : %"LU" filters\n",nb_filters);
 	xmlFreeDoc(xdoc);
+#endif
 	return 1;
 }
 CONFcouple *buildCouple(uint32_t nb, xmlNodePtr node)

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.cpp	2009-10-02 05:22:03 UTC (rev 5363)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.cpp	2009-10-02 05:22:07 UTC (rev 5364)
@@ -175,6 +175,7 @@
 {
             aprintf("--killing\n");
             renderLock();
+#if 0
             getFirstVideoFilter();
             
             preview=videofilters[  nb_active_filter-1].filter;
@@ -182,7 +183,7 @@
             ADM_assert(!previewImage)
                 
             previewImage=new ADMImage(preview->getInfo()->width,preview->getInfo()->height);
-            
+#endif            
             ADM_assert(!original);
             switch(previewMode)
             {

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script/ADM_JSAvidemuxVideo.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script/ADM_JSAvidemuxVideo.cpp	2009-10-02 05:22:03 UTC (rev 5363)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script/ADM_JSAvidemuxVideo.cpp	2009-10-02 05:22:07 UTC (rev 5364)
@@ -192,7 +192,7 @@
 JSBool ADM_JSAvidemuxVideo::ClearFilters(JSContext *cx, JSObject *obj, uintN argc,
                                        jsval *argv, jsval *rval)
 {// begin Clear
-	filterCleanUp();
+//	filterCleanUp();
         return JS_TRUE;
 }// end Clear
 
@@ -200,6 +200,7 @@
 JSBool ADM_JSAvidemuxVideo::AddFilter(JSContext *cx, JSObject *obj, uintN argc, 
                                        jsval *argv, jsval *rval)
 {// begin AddFilter
+#if 0
         VF_FILTERS filter;
 
         // default return value
@@ -230,7 +231,7 @@
         {
             ADM_dealloc(args[i].arg.string);
         }
-        
+#endif        
         return JS_TRUE;
 }// end AddFilter
 

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_toolkit/automation.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_toolkit/automation.cpp	2009-10-02 05:22:03 UTC (rev 5363)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_toolkit/automation.cpp	2009-10-02 05:22:07 UTC (rev 5364)
@@ -44,7 +44,7 @@
 #include "ADM_vidMisc.h"
 #include "ADM_coreVideoEncoder.h"
 #include "ADM_audioFilter/include/ADM_audioFilterInterface.h"
-extern void filterListAll(void );
+//extern void filterListAll(void );
 
 //extern uint8_t loadVideoCodecConf( const char *name);
 extern int A_saveJpg (char *name);
@@ -137,7 +137,7 @@
 AUTOMATON reaction_table[]=
 {
         {"nogui",               0,"Run in silent mode",		(one_arg_type)GUI_Quiet}   ,
-        {"listfilters",		0,"list all filters by name",		(one_arg_type)filterListAll}   ,
+//        {"listfilters",		0,"list all filters by name",		(one_arg_type)filterListAll}   ,
         {"run",			1,"load and run a script",		(one_arg_type)A_parseECMAScript},
         {"audio-normalize",	1,"activate normalization",		call_normalize},
         {"audio-resample",	1,"resample to x hz",			call_resample},

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_video/ADM_reorderTemplate.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_video/ADM_reorderTemplate.cpp	2009-10-02 05:22:03 UTC (rev 5363)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_video/ADM_reorderTemplate.cpp	2009-10-02 05:22:07 UTC (rev 5364)
@@ -1,84 +0,0 @@
-/*
- * INDEX_TMPL is the type of each index
- * INDEX_ARRAY_TMPL is the attribute holding the index
- * FRAMETYPE_TMPL is the field holding video flags
- * */
-#ifndef INDEX_TMPL
-#error INDEX_TMPL
-#endif
-#ifndef INDEX_ARRAY_TMPL
-#error INDEX_ARRAY_TMPL
-#endif
-#ifndef FRAMETYPE_TMPL
-#error FRAMETYPE_TMPL
-#endif
-
-INDEX_TMPL *index;
-uint8_t ret=1;
-uint32_t nbFrame= _videostream.dwLength;
-	// already done..
-	if( _reordered) return 1;
-	ADM_assert(INDEX_ARRAY_TMPL);
-	
-	index=new INDEX_TMPL[nbFrame];
-	// clear B frame flag for last frames
-	INDEX_ARRAY_TMPL[nbFrame-1].FRAMETYPE_TMPL &=~AVI_B_FRAME;
-
-			//__________________________________________
-			// the direct index is in DTS time (i.e. decoder time)
-			// we will now do the PTS index, so that frame numbering is done
-			// according to the frame # as they are seen by editor / user
-			// I1 P0 B0 B1 P1 B2 B3 I2 B7 B8
-			// xx I1 B0 B1 P0 B2 B3 P1 B7 B8
-			//__________________________________________
-			uint32_t forward=0;
-			uint32_t curPTS=0;
-			uint32_t dropped=0;
-
-			for(uint32_t c=1;c<nbFrame;c++)
-			{
-				if(!(INDEX_ARRAY_TMPL[c].FRAMETYPE_TMPL & AVI_B_FRAME))
-					{
-								memcpy(&index[curPTS],
-										&INDEX_ARRAY_TMPL[forward],
-										sizeof(INDEX_TMPL));
-								forward=c;
-								curPTS++;
-								dropped++;
-					}
-					else
-					{// we need  at lest 2 i/P frames to start decoding B frames
-						if(dropped>=1)
-						{
-							memcpy(&index[curPTS],
-								&INDEX_ARRAY_TMPL[c],
-								sizeof(INDEX_TMPL));
-							curPTS++;
-						}
-						else
-						{
-						printf("We dropped a frame (%d/%d).\n",dropped,c);
-						}
-					}
-			}
-
-			uint32_t last;
-
-
-			// put back last I/P we had in store
-			memcpy(&index[curPTS],
-				&INDEX_ARRAY_TMPL[forward],
-				sizeof(INDEX_TMPL));
-			last=curPTS;
-
-			_videostream.dwLength= _mainaviheader.dwTotalFrames=nbFrame=last+1;
-			// last frame is always I
-
-			delete [] INDEX_ARRAY_TMPL;
-
-			INDEX_ARRAY_TMPL=index;;
-			// last frame cannot be B frame
-			INDEX_ARRAY_TMPL[last].FRAMETYPE_TMPL&=~AVI_B_FRAME;
-                        // And first is an intra
-                        INDEX_ARRAY_TMPL[0].FRAMETYPE_TMPL=AVI_KEY_FRAME;
-			 _reordered=ret;

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_video/ADM_vidNull.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_video/ADM_vidNull.cpp	2009-10-02 05:22:03 UTC (rev 5363)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_video/ADM_vidNull.cpp	2009-10-02 05:22:07 UTC (rev 5364)
@@ -1,107 +0,0 @@
-/***************************************************************************
-                          ADM_vidNull.cpp  -  description
-                             -------------------
-
-	This filter asks an image from the editor and
-	clean-up the output
-	It does compute the average quant possibly apply postprocessing
-
-
-
-    begin                : Wed Mar 20 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include "ADM_default.h"
-#include "ADM_editor/ADM_edit.hxx"
-#include "ADM_videoFilter.h"
-#include "ADM_videoNull.h"
-
-#include "ADM_debugID.h"
-#define MODULE_NAME MODULE_FILTER
-#include "ADM_debug.h"
-
-
-
-
-//_______________________________________________________________
-
-AVDMVideoStreamNull::AVDMVideoStreamNull(ADM_Composer *in,uint32_t start, uint32_t nb)
-{
-aviInfo aviinf;
-  	_in=in;
-
-  	// now build infos
-
-  	ADM_assert(_in->getVideoInfo(&aviinf));
-  	_info.width=aviinf.width;
-  	_info.height=aviinf.height;
-	if(start+nb==aviinf.nb_frames-1)  nb++; // take last frame
-  	_info.nb_frames=nb;
-	_start=start;
-  	_info.encoding=0;
-	_info.fps1000=aviinf.fps1000;
-	_info.orgFrame=start;
-//  	_uncompressed=(uint8_t *)malloc(3*aviinf.width*aviinf.height);
-//	_uncompressed=new ADMImage(aviinf.width,aviinf.height);
-
-  //	ADM_assert(_uncompressed);
-	ADM_assert(start+nb<=aviinf.nb_frames);
-        par_width=_in->getPARWidth();
-        par_height=_in->getPARHeight();
-	aprintf("\n Null stream initialized with start frame = %lu, nbframe=%lu \n",_start,nb);
-
-}
-uint32_t   AVDMVideoStreamNull::getPARWidth(void)
-{
-  return par_width;
-}
-uint32_t   AVDMVideoStreamNull::getPARHeight(void)
-{
-  return par_height;
-}
-AVDMVideoStreamNull::~AVDMVideoStreamNull()
-{
-
- //	delete _uncompressed;
-
-}
-//
-//	Basically ask a uncompressed frame from editor and ask
-//		GUI to decompress it .
-//
-
-uint8_t AVDMVideoStreamNull::getFrameNumberNoAlloc(uint32_t frame,
-				uint32_t *len,
-   				ADMImage *data,
-				uint32_t *flags)
-{
-        UNUSED_ARG(len);
-    	UNUSED_ARG(flags);
-		if(!(frame<_info.nb_frames))
-		{
-				printf("\n going out of bounds! :%"LD" / %"LD"\n",frame,_info.nb_frames);
-				return 0;
-		}
-
-			// read uncompressed frame
-
-	// 1 get it
-    	if(!_in->getUncompressedFrame(_start+frame,data)     )
-     			return 0;
-	return 1;
-}
-
-uint8_t AVDMVideoStreamNull::configure( AVDMGenericVideoStream *instream){
-	UNUSED_ARG(instream);
-	return 0;
-}

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_video/ADM_vidPartial.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_video/ADM_vidPartial.cpp	2009-10-02 05:22:03 UTC (rev 5363)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_video/ADM_vidPartial.cpp	2009-10-02 05:22:07 UTC (rev 5364)
@@ -1,155 +0,0 @@
-/***************************************************************************
-                          ADM_vidPartial.cpp  -  description
-                             -------------------
-    begin                : Mon Dec 30 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
-
-    This filter is special
-    It uses internally another filter from _start to _end
-    and output copy of input else
-
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include "ADM_default.h"
-
-#include "ADM_editor/ADM_edit.hxx"
-#include "ADM_videoFilter.h"
-#include "ADM_videoFilter_internal.h"
-#include "ADM_video/ADM_vidPartial.h"
-
-extern AVDMGenericVideoStream *filterCreateFromTag(VF_FILTERS tag,CONFcouple *couple, AVDMGenericVideoStream *in);
-
-
-static FILTER_PARAM partialParam={VARIABLE_PARAMS+3,{"_start","_end","_tag"}};
-
-
-SCRIPT_CREATE(partial_script,ADMVideoPartial,partialParam);
-BUILD_CREATE(partial_create,ADMVideoPartial);
-
-//___________________________________________________
-char 						*ADMVideoPartial::printConf(void)
-{
-	static char string[500];
-		 			sprintf(string,"Partial from %"LD" to %"LD" : %s",
-		    						_param->_start,
-		          			_param->_end,
-		             		_son->printConf());
-		    return string;
-}
-
-ADMVideoPartial::ADMVideoPartial(   AVDMGenericVideoStream *in,
-							CONFcouple		*couples)
-{
-		_param=NEW( PARTIAL_CONFIG);
-		_param->_start=0;
-		_param->_end=0;
-		_in=in;
-
-			GET(_start);
-			GET(_end);
-			GET(_tag);
-			// we share the same parameters
-			_son= filterCreateFromTag((VF_FILTERS)_param->_tag,couples,_in);
-		 	memcpy(&_info,_in->getInfo(),sizeof(_info));
-}
-
-ADMVideoPartial::ADMVideoPartial(  AVDMGenericVideoStream *in,VF_FILTERS tag,CONFcouple *setup)
-{
-		_param=NEW( PARTIAL_CONFIG);
-		_param->_start=0;
-		_param->_end=0;
-		_param->_tag=tag;
-		_in=in;
-		// we share the same parameters
-		_son= filterCreateFromTag(tag,setup,_in);
-		memcpy(&_info,_in->getInfo(),sizeof(_info));
-}
-
-/**/
-uint8_t	ADMVideoPartial::getCoupledConf( CONFcouple **couples)
-{
-			uint32_t nbParam=0;
-
-			ADM_assert(_param);
-
-			// first we ask the child its config
-			CONFcouple *child;
-			if(!_son->getCoupledConf(&child))
-			{
-				// no param for child
-#define CSET(x)  (*couples)->setCouple((char *)#x,(_param->x))
-				*couples=new CONFcouple(3);
-				CSET(_start);
-				CSET(_end);
-				CSET(_tag);
-				return 1;
-			}
-
-			// grab child param
-			nbParam=child->getNumber();
-
-			*couples=new CONFcouple(3+nbParam);
-			CSET(_start);
-			CSET(_end);
-			CSET(_tag);
-
-	// then set the child ones
-	char *nm,*vl;
-
-	for(uint32_t i=0;i<nbParam;i++)
-	{
-		child->getEntry(i,&nm, &vl);
-		  (*couples)->setCouple(nm,vl);
-	}
-	// delete child
-	delete child;
-
-	return 1;
-
-}
-
-//
-ADMVideoPartial::~ADMVideoPartial()
-{
-		if(_son) delete _son;
-		DELETE(_param);
-
-}
-//
-uint8_t ADMVideoPartial::getFrameNumberNoAlloc(uint32_t frame,
-				uint32_t *len,
-   				ADMImage *data,
-				uint32_t *flags)
-{
-		ADM_assert(_son);
-		if(frame>= _info.nb_frames) return 0;
-		if((frame+_info.orgFrame>=_param->_start) && (frame+_info.orgFrame)<=_param->_end) //
-		{
-				return _son->getFrameNumberNoAlloc(frame,len,data,flags);
-		}
-		return _in->getFrameNumberNoAlloc(frame,len,data,flags);
-}
-//
-extern uint8_t DIA_getPartial(PARTIAL_CONFIG *param,AVDMGenericVideoStream *son,AVDMGenericVideoStream *previous);
-uint8_t ADMVideoPartial::configure( AVDMGenericVideoStream *instream)
-{
-  uint8_t r=0;
-    r=DIA_getPartial(_param,_son,_in);
-    if(_param->_end<_param->_start) _param->_end=_param->_start;
-
-   return r;
-}
-
-
-
-

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_video/ADM_vidPartial.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_video/ADM_vidPartial.h	2009-10-02 05:22:03 UTC (rev 5363)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_video/ADM_vidPartial.h	2009-10-02 05:22:07 UTC (rev 5364)
@@ -1,42 +0,0 @@
-/***************************************************************************
-                          ADM_vidPartial.h  -  description
-                             -------------------
-    begin                : Mon Dec 30 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifndef PARTIAL__
-#define PARTIAL__
-
-#define MAXSONCONF 100
-
-#include "ADM_vidPartial_param.h"
- class  ADMVideoPartial:public AVDMGenericVideoStream
- {
-
- protected:
-
-      			AVDMGenericVideoStream 	*_son;
-			PARTIAL_CONFIG			*_param;
- public:
- 	virtual 	char 		*printConf(void);
-  					ADMVideoPartial(  AVDMGenericVideoStream *in,CONFcouple *setup);
-					ADMVideoPartial(  AVDMGenericVideoStream *in,VF_FILTERS tag,CONFcouple *setup);
-  			virtual ~ADMVideoPartial();
-		    	virtual uint8_t getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-          																	ADMImage *data,uint32_t *flags);
-			virtual uint8_t configure( AVDMGenericVideoStream *instream) ;
-			virtual uint8_t	getCoupledConf( CONFcouple **couples);
- }     ;
- 
-
-#endif

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_video/ADM_vidPartial_param.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_video/ADM_vidPartial_param.h	2009-10-02 05:22:03 UTC (rev 5363)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_video/ADM_vidPartial_param.h	2009-10-02 05:22:07 UTC (rev 5364)
@@ -1,21 +0,0 @@
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#ifndef ADM_VID_PARTIAL_PARAM_H
-#define ADM_VID_PARTIAL_PARAM_H
-
-typedef struct  PARTIAL_CONFIG
-{
-  uint32_t _start,_end;
-  uint32_t _confsize;
-  uint32_t _tag;
-
-}PARTIAL_CONFIG;
-
-#endif

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_video/ADM_vidRaw.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_video/ADM_vidRaw.cpp	2009-10-02 05:22:03 UTC (rev 5363)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_video/ADM_vidRaw.cpp	2009-10-02 05:22:07 UTC (rev 5364)
@@ -1,84 +0,0 @@
-/***************************************************************************
-                          ADM_vidRaw.cpp  -  description
-                             -------------------
-
-    Pass throught filter, just to have a coherent interface
-
-    begin                : Wed Mar 20 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include "ADM_default.h"
-#include "ADM_editor/ADM_edit.hxx"
-#include "ADM_videoFilter.h"
-#include "ADM_video/ADM_videoNull.h"
-
-
-
-
-//_______________________________________________________________
-
-AVDMVideoStreamRaw::AVDMVideoStreamRaw(ADM_Composer *in,uint32_t start, uint32_t nb)
-{
-aviInfo aviinf;
-  	_in=in;
-
-  	// now build infos
-
-  	ADM_assert(_in->getVideoInfo(&aviinf));
-  	_info.width=aviinf.width;
-  	_info.height=aviinf.height;
-  	_info.nb_frames=nb;
-	_start=start;
-  	_info.encoding=0;
-	_info.fps1000=aviinf.fps1000;
-	ADM_assert(start+nb<=aviinf.nb_frames);
-	printf("\n Raw stream initialized with start frame = %"LU"\n",_start);
-}
-AVDMVideoStreamRaw::~AVDMVideoStreamRaw()
-{
-
-
-}
-//
-//	Basically ask a uncompressed frame from editor and ask
-//		GUI to decompress it .
-//
-
-uint8_t AVDMVideoStreamRaw::getFrameNumberNoAlloc(uint32_t frame,
-				uint32_t *len,
-   				ADMImage *data,
-				uint32_t *flags)
-{
-        UNUSED_ARG(len);
-    	UNUSED_ARG(flags);
-                if(frame>= _info.nb_frames) return 0;
-		*len=(_info.width*_info.height*3)>>1;
-		if(!(frame<_info.nb_frames))
-		{
-				printf("\n going out of bounds! :%"LU" / %"LU" \n",frame,_info.nb_frames);
-				return 0;
-		}
-
-			// read uncompressed frame
-		if(!_in->getUncompressedFrame(_start+frame,data,flags)     )
-     			return 0;
-
-        return 1;
-
-
-}
-
-uint8_t AVDMVideoStreamRaw::configure( AVDMGenericVideoStream *instream){
-	UNUSED_ARG(instream);
-	return 0;
-}

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_video/ADM_videoNull.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_video/ADM_videoNull.h	2009-10-02 05:22:03 UTC (rev 5363)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_video/ADM_videoNull.h	2009-10-02 05:22:07 UTC (rev 5364)
@@ -1,48 +0,0 @@
-#ifndef ADM_VIDEO_NULL_H
-#define ADM_VIDEO_NULL_H
-
-class  AVDMVideoStreamNull :public AVDMGenericVideoStream
- {
-
- protected:
-                  ADM_Composer      *_in;
-                  uint32_t          _start;
-                  uint32_t          par_width,par_height;
-
- public:
-
-                          AVDMVideoStreamNull(  ADM_Composer *in,uint32_t framestart, uint32_t nb);
-                          virtual ~AVDMVideoStreamNull();
-    
-    
-        virtual	  uint8_t getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-                                                          ADMImage *data,uint32_t *flags);
-                  uint8_t configure( AVDMGenericVideoStream *instream);
-    
-        virtual uint32_t   getPARWidth(void);
-        virtual uint32_t   getPARHeight(void);
-
- }     ;
-
-class  AVDMVideoStreamRaw :public AVDMGenericVideoStream
- {
-
- protected:
-				ADM_Composer *_in;
-				uint32_t			_start;
-
- public:
-
-  				AVDMVideoStreamRaw(  ADM_Composer *in,uint32_t framestart, uint32_t nb);
-  				virtual ~AVDMVideoStreamRaw();
-
-
-          virtual 	uint8_t getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-								ADMImage *data,uint32_t *flags);
-           	 	uint8_t configure( AVDMGenericVideoStream *instream);
-
-
- }     ;
-
-#endif
-// EOF

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_video/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_video/CMakeLists.txt	2009-10-02 05:22:03 UTC (rev 5363)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_video/CMakeLists.txt	2009-10-02 05:22:07 UTC (rev 5364)
@@ -1,13 +0,0 @@
-SET(ADM_video_SRCS 
-ADM_vidPartial.cpp    
-ADM_vidRaw.cpp        
-ADM_vidNull.cpp)
-
-ADD_LIBRARY(ADM_video6 ${ADM_video_SRCS})
-
-IF (USE_FREETYPE)
-	ADD_TARGET_CFLAGS(ADM_video6 ${FREETYPE2_CFLAGS})
-ENDIF (USE_FREETYPE)
-
-ADD_TARGET_CFLAGS(ADM_video6 "-I../ADM_inputs")
-#ADM_vidFieldUnblend.cpp  

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/ADM_pluginLoad.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/ADM_pluginLoad.cpp	2009-10-02 05:22:03 UTC (rev 5363)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/ADM_pluginLoad.cpp	2009-10-02 05:22:07 UTC (rev 5364)
@@ -59,7 +59,7 @@
 
 		ADM_vf_plugin(const char *file) : ADM_LibWrapper()
 		{
-			initialised = (loadLibrary(file) && getSymbols(7,
+			initialised = (loadLibrary(file) && getSymbols(9,
 				&create, "create",
 				&destroy, "destroy",
 				&getApiVersion, "getApiVersion",

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/CMakeLists.txt	2009-10-02 05:22:03 UTC (rev 5363)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/CMakeLists.txt	2009-10-02 05:22:07 UTC (rev 5364)
@@ -16,7 +16,7 @@
 ADD_SUBDIRECTORY(ADM_requant)
 ADD_SUBDIRECTORY(ADM_script)
 ADD_SUBDIRECTORY(ADM_toolkit)
-ADD_SUBDIRECTORY(ADM_video)
+#ADD_SUBDIRECTORY(ADM_video)
 ADD_SUBDIRECTORY(ADM_videoFilter)
 ADD_SUBDIRECTORY(ADM_videoEncoder)
 ADD_SUBDIRECTORY(ADM_videoFilter2)

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp	2009-10-02 05:22:03 UTC (rev 5363)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp	2009-10-02 05:22:07 UTC (rev 5364)
@@ -875,7 +875,7 @@
 	}
 
 	currentaudiostream=NULL;
-	filterCleanUp();
+//	filterCleanUp();
 	admPreview::cleanUp();
 }
 
@@ -1267,7 +1267,7 @@
 	  aviaudiostream=NULL;
 	  secondaudiostream=NULL;
 
-      filterCleanUp ();
+//      filterCleanUp ();
 	  UI_setTitle(NULL);
 
       return 1;

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/gui_play.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/gui_play.cpp	2009-10-02 05:22:03 UTC (rev 5363)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/gui_play.cpp	2009-10-02 05:22:07 UTC (rev 5364)
@@ -114,11 +114,11 @@
     
     if(getPreviewMode()==ADM_PREVIEW_OUTPUT)
     {
-            filter=getLastVideoFilter();
+//            filter=getLastVideoFilter();
     }
     else
     {
-            filter=getFirstVideoFilter( );
+  //          filter=getFirstVideoFilter( );
     }
     
     stop_req = 0;
@@ -134,7 +134,7 @@
     delete playLoop;
    playing = 0;
             
-   getFirstVideoFilter( );
+//   getFirstVideoFilter( );
 
    admPreview::deferDisplay(0,0);
    

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/main.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/main.cpp	2009-10-02 05:22:03 UTC (rev 5363)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/main.cpp	2009-10-02 05:22:07 UTC (rev 5364)
@@ -320,7 +320,7 @@
     SpidermonkeyDestroy();
     pthread_mutex_unlock(&g_pSpiderMonkeyMutex);
     destroyPrefs();
-    filterCleanUp();
+//    filterCleanUp();
 	ADM_lavDestroy();
 
 #ifdef USE_SDL

Modified: branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake	2009-10-02 05:22:03 UTC (rev 5363)
+++ branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake	2009-10-02 05:22:07 UTC (rev 5364)
@@ -96,7 +96,7 @@
 ADM_script6 
 ADM_toolkit6
 ADM_videoEncoder6 
-ADM_video6 
+#ADM_video6 
 ADM_videoFilter6 
 ADM_internalVideoFilter6
 )

Modified: branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_dialog/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_dialog/CMakeLists.txt	2009-10-02 05:22:03 UTC (rev 5363)
+++ branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_dialog/CMakeLists.txt	2009-10-02 05:22:07 UTC (rev 5364)
@@ -12,7 +12,7 @@
  DIA_vcodec.cpp  
  DIA_xvid.cpp
  DIA_idx_pg.cpp    
- DIA_partial.cpp  
+ #DIA_partial.cpp  
  DIA_quota.cpp      
  DIA_vobsub.cpp
  DIA_jobs.cpp      

Deleted: branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_dialog/DIA_partial.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_dialog/DIA_partial.cpp	2009-10-02 05:22:03 UTC (rev 5363)
+++ branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_dialog/DIA_partial.cpp	2009-10-02 05:22:07 UTC (rev 5364)
@@ -1,188 +0,0 @@
-//
-// C++ Implementation: DIA_decimate
-//
-// Description: 
-//
-//
-// Author: mean <fixounet at free.fr>, (C) 2004
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-//
-// C++ Implementation: DIA_dectel
-//
-// Description: 
-//
-//
-// Author: mean <fixounet at free.fr>, (C) 2004
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-
-
-#include "ADM_toolkitGtk.h"
-
-
-#include "ADM_video/ADM_vidPartial_param.h"
-#include "ADM_videoFilter.h"
-#include "DIA_coreToolkit.h"
-#define SPIN_GET(x,y) {param->y= gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(WID(x))) ;}
-#define SPIN_SET(x,y)  {gtk_spin_button_set_value(GTK_SPIN_BUTTON(WID(x)),(gfloat)param->y) ;}
-#define SGET(x) gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(WID(x))) 
-
-static GtkWidget        *create_dialog1 (void);
-#define F_CONF 0x100
-uint8_t DIA_getPartial(PARTIAL_CONFIG *param,AVDMGenericVideoStream *son,AVDMGenericVideoStream *previous)
-{
-  
-    GtkWidget *dialog;
-    int ret=0,done=0;
-    dialog=create_dialog1();
-
-	gtk_dialog_set_alternative_button_order(GTK_DIALOG(dialog),
-								GTK_RESPONSE_OK,
-								GTK_RESPONSE_CANCEL,
-								-1);
-
-    // Update
-    SPIN_SET(spinbuttonStart,_start);
-    SPIN_SET(spinbuttonSize,_end);
-    gtk_dialog_add_action_widget (GTK_DIALOG (dialog), WID(buttonConf), F_CONF);
-    // Run
-    gtk_register_dialog(dialog);
-    while(!done)
-    {
-      switch(gtk_dialog_run(GTK_DIALOG(dialog)))
-      {
-          case F_CONF:
-              printf("Poof\n");
-              son->configure(previous);
-              break;
-          case GTK_RESPONSE_OK:
-            {
-              uint32_t s,e;
-                s=SGET(spinbuttonStart);
-                e=SGET(spinbuttonSize);
-                if(e<s)
-                {
-                  GUI_Error_HIG("Bad parameters","The end frame must be after the start frame !"); 
-                }
-                else
-                {
-                  param->_start=s;
-                  param->_end=e;
-                  done=1;
-                  ret=1;
-                }
-              }
-                break;
-            default:
-              done=1;
-              break;
-                
-        }
-    }
-    gtk_unregister_dialog(dialog);
-    gtk_widget_destroy(dialog);
-    return ret;
-}
-GtkWidget*
-    create_dialog1 (void)
-{
-  GtkWidget *dialog1;
-  GtkWidget *dialog_vbox1;
-  GtkWidget *vbox1;
-  GtkWidget *table1;
-  GtkWidget *label1;
-  GtkWidget *label2;
-  GtkObject *spinbuttonStart_adj;
-  GtkWidget *spinbuttonStart;
-  GtkObject *spinbuttonSize_adj;
-  GtkWidget *spinbuttonSize;
-  GtkWidget *buttonConf;
-  GtkWidget *dialog_action_area1;
-  GtkWidget *cancelbutton1;
-  GtkWidget *okbutton1;
-
-  dialog1 = gtk_dialog_new ();
-  gtk_window_set_title (GTK_WINDOW (dialog1), QT_TR_NOOP("Partial"));
-  gtk_window_set_type_hint (GTK_WINDOW (dialog1), GDK_WINDOW_TYPE_HINT_DIALOG);
-
-  dialog_vbox1 = GTK_DIALOG (dialog1)->vbox;
-  gtk_widget_show (dialog_vbox1);
-
-  vbox1 = gtk_vbox_new (FALSE, 0);
-  gtk_widget_show (vbox1);
-  gtk_box_pack_start (GTK_BOX (dialog_vbox1), vbox1, TRUE, TRUE, 0);
-
-  table1 = gtk_table_new (2, 2, FALSE);
-  gtk_widget_show (table1);
-  gtk_box_pack_start (GTK_BOX (vbox1), table1, TRUE, TRUE, 0);
-
-  label1 = gtk_label_new (QT_TR_NOOP("Start frame for partial :"));
-  gtk_widget_show (label1);
-  gtk_table_attach (GTK_TABLE (table1), label1, 0, 1, 0, 1,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_misc_set_alignment (GTK_MISC (label1), 0, 0.5);
-
-  label2 = gtk_label_new (QT_TR_NOOP("End frame for partial :"));
-  gtk_widget_show (label2);
-  gtk_table_attach (GTK_TABLE (table1), label2, 0, 1, 1, 2,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_misc_set_alignment (GTK_MISC (label2), 0, 0.5);
-
-  spinbuttonStart_adj = gtk_adjustment_new (1, 0, 1000000, 1, 10, 10);
-  spinbuttonStart = gtk_spin_button_new (GTK_ADJUSTMENT (spinbuttonStart_adj), 1, 0);
-  gtk_widget_show (spinbuttonStart);
-  gtk_table_attach (GTK_TABLE (table1), spinbuttonStart, 1, 2, 0, 1,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (spinbuttonStart), TRUE);
-
-  spinbuttonSize_adj = gtk_adjustment_new (1, 0, 1000000, 1, 10, 10);
-  spinbuttonSize = gtk_spin_button_new (GTK_ADJUSTMENT (spinbuttonSize_adj), 1, 0);
-  gtk_widget_show (spinbuttonSize);
-  gtk_table_attach (GTK_TABLE (table1), spinbuttonSize, 1, 2, 1, 2,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (spinbuttonSize), TRUE);
-
-  buttonConf = gtk_button_new_with_mnemonic (QT_TR_NOOP("Configure partialized filter"));
-  gtk_widget_show (buttonConf);
-  gtk_box_pack_start (GTK_BOX (vbox1), buttonConf, FALSE, FALSE, 0);
-
-  dialog_action_area1 = GTK_DIALOG (dialog1)->action_area;
-  gtk_widget_show (dialog_action_area1);
-  gtk_button_box_set_layout (GTK_BUTTON_BOX (dialog_action_area1), GTK_BUTTONBOX_END);
-
-  cancelbutton1 = gtk_button_new_from_stock ("gtk-cancel");
-  gtk_widget_show (cancelbutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), cancelbutton1, GTK_RESPONSE_CANCEL);
-  GTK_WIDGET_SET_FLAGS (cancelbutton1, GTK_CAN_DEFAULT);
-
-  okbutton1 = gtk_button_new_from_stock ("gtk-ok");
-  gtk_widget_show (okbutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), okbutton1, GTK_RESPONSE_OK);
-  GTK_WIDGET_SET_FLAGS (okbutton1, GTK_CAN_DEFAULT);
-
-  /* Store pointers to all widgets, for use by lookup_widget(). */
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog1, "dialog1");
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_vbox1, "dialog_vbox1");
-  GLADE_HOOKUP_OBJECT (dialog1, vbox1, "vbox1");
-  GLADE_HOOKUP_OBJECT (dialog1, table1, "table1");
-  GLADE_HOOKUP_OBJECT (dialog1, label1, "label1");
-  GLADE_HOOKUP_OBJECT (dialog1, label2, "label2");
-  GLADE_HOOKUP_OBJECT (dialog1, spinbuttonStart, "spinbuttonStart");
-  GLADE_HOOKUP_OBJECT (dialog1, spinbuttonSize, "spinbuttonSize");
-  GLADE_HOOKUP_OBJECT (dialog1, buttonConf, "buttonConf");
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_action_area1, "dialog_action_area1");
-  GLADE_HOOKUP_OBJECT (dialog1, cancelbutton1, "cancelbutton1");
-  GLADE_HOOKUP_OBJECT (dialog1, okbutton1, "okbutton1");
-
-  return dialog1;
-}
-

Modified: branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_filters/gui_filtermanager.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_filters/gui_filtermanager.cpp	2009-10-02 05:22:03 UTC (rev 5363)
+++ branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_filters/gui_filtermanager.cpp	2009-10-02 05:22:07 UTC (rev 5364)
@@ -17,9 +17,6 @@
 #include "ADM_videoFilter.h"
 #include "ADM_videoFilter_internal.h"
 #include "ADM_editor/ADM_edit.hxx"
-#include "ADM_video/ADM_videoNull.h"
-
-#include "ADM_video/ADM_vidPartial.h"
 #include "avi_vars.h"
 #include "ADM_filter/vidVCD.h"
 //___________________________________________
@@ -92,7 +89,7 @@
 int
 GUI_handleVFilter (void)
 {
-
+#if 0
     getLastVideoFilter ();	// expand video to full size
 
     // sanity check
@@ -127,7 +124,7 @@
         gtk_unregister_dialog (dialog);
         gtk_widget_destroy(dialog);
         dialog=NULL;
-        
+#endif        
     return 1;
     
 }
@@ -231,7 +228,8 @@
         setSelectionNumber(nb_active_filter-1, WID(treeview0), stores[0], action_parameter-1);
         break;
 
-    case A_PARTIAL:
+    case A_PARTIAL:
+#if 0
         if (!action_parameter) break;
         AVDMGenericVideoStream *replace;
         CONFcouple *conf;
@@ -258,7 +256,8 @@
 			updateFilterList ();
 			setSelectionNumber(nb_active_filter-1, WID(treeview0), stores[0], action_parameter-1);
         }
-        else delete replace;
+        else delete replace;
+#endif
         break;
 
     case A_UP:



From mean at mail.berlios.de  Fri Oct  2 07:22:14 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 2 Oct 2009 07:22:14 +0200
Subject: [Avidemux-svn-commit] r5365 - in
	branches/avidemux_2.6_branch_mean/avidemux: . common
	common/ADM_filter common/ADM_toolkit common/ADM_videoFilter
	gtk/ADM_userInterfaces/ADM_dialog gtk/ADM_userInterfaces/ADM_filters
	gtk/ADM_userInterfaces/ADM_ocr
Message-ID: <200910020522.n925MEbB030709@sheep.berlios.de>

Author: mean
Date: 2009-10-02 07:22:11 +0200 (Fri, 02 Oct 2009)
New Revision: 5365

Removed:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/filter.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/filter_autoFilter.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/filter_declaration.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/filter_saveload.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/vidVCD.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/vidVCD.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_mpdetc.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidComputeAverage.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidComputeAverage.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidDvbSub.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidDvbSub.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidEraser.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidEraser.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidNumber.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidParticle.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidParticle.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidSwissArmyKnife.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidSwissArmyKnife.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidThreshold.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidThreshold.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidUnblend_param.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidVobSub.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidVobSubBitmap.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidVobSubRender.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidVobsub.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vobsubinfo.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vobsubinfo.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADMmpdetc.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/CMakeLists.txt
Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_toolkit/automation.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/common/gui_autodrive.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/main.cpp
   branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake
   branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_dialog/DIA_vobsub.cpp
   branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_filters/gui_filtermanager.cpp
   branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_ocr/adm_ocr.cpp
Log:
[videoFilter] Remove old code

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/CMakeLists.txt	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/CMakeLists.txt	2009-10-02 05:22:11 UTC (rev 5365)
@@ -1,9 +0,0 @@
-SET(ADM_filter_SRCS 
-filter.cpp  
-filter_declaration.cpp  
-filter_saveload.cpp  
-filter_autoFilter.cpp
-vidVCD.cpp)
-
-ADD_LIBRARY(ADM_filter6 STATIC ${ADM_filter_SRCS})
-ADD_TARGET_CFLAGS(ADM_filter6 -I${LIBXML2_INCLUDE_DIR} ${LIBXML2_DEFINITIONS})

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/filter.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/filter.cpp	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/filter.cpp	2009-10-02 05:22:11 UTC (rev 5365)
@@ -1,479 +0,0 @@
-/***************************************************************************
-                          filter.cpp  -  description
-                             -------------------
-    begin                : Wed Mar 27 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#if 0
-#include "ADM_default.h"
-#include <vector>
-#include "fourcc.h"
-#include "DIA_fileSel.h"
-#include "ADM_dynamicLoading.h"
-
-#include "ADM_editor/ADM_edit.hxx"
-#include "ADM_videoFilter.h"
-#include "ADM_video/ADM_videoNull.h"
-#include "ADM_videoFilter_internal.h"
-#include "ADM_videoFilterDynamic.h"
-#include "ADM_video/ADM_vidPartial.h"
-#include "ADM_render/GUI_render.h"
-
-#include "ADM_debugID.h"
-#define MODULE_NAME MODULE_PREVIEW
-#include "ADM_debug.h"
-#include "ADM_quota.h"
-#include "ADM_preview.h"
-//
-
-extern ADM_UI_TYPE UI_GetCurrentUI(void);
-
-class ADM_vf_pluginLoader : public ADM_LibWrapper
-{
-	public:
-		VF_getDescriptor		*getDesc;
-		ADM_vf_pluginLoader(const char *file) : ADM_LibWrapper()
-		{
-				getDesc=NULL;
-				if(loadLibrary(file))
-					getDesc=(VF_getDescriptor *)getSymbol("ADM_VF_getDescriptor");
-		};
-};
-// exported vars
-std::vector <FilterDescriptor *> allfilters;
-std::vector <FilterDescriptor *> filterCategories[VF_MAX];
-std::vector <ADM_vf_pluginLoader *> pluginLoaderQueue;
-
-uint32_t nb_active_filter=0;
-FILTER  videofilters[VF_MAX_FILTER];
-
-
-
-static uint32_t lastStart=0, lastNb=0;
-static uint32_t tagCount=VF_START_TAG;
-
-extern ADM_Composer *video_body;
-extern AVDMGenericVideoStream *filterCreateFromTag(VF_FILTERS tag,CONFcouple *conf, AVDMGenericVideoStream *in) ;
-extern char *ADM_escape(const ADM_filename *incoming);
-//
-
-static  void updateVideoFilters(void);
-
-// Ugly should be dynamically allocated
-#warning HARDCODEC IMAGE SIZE
-
-// dummy constructor used to register the filter
-//____________________________________
-AVDMVideo_FilterDec::AVDMVideo_FilterDec(char *name,
-									AVDMGenericVideoStream *(*create) (AVDMGenericVideoStream *in, void *))
-{
-    UNUSED_ARG(name);
-    UNUSED_ARG(create);
-         //registerFilter(name, create);
-	 //
-}
-//
-// Delete everything that is pending
-void filterCleanUp( void )
-{
-	for(uint32_t i=0;i<nb_active_filter;i++)
-	{
-		  	delete videofilters[i].filter;
-			if(videofilters[i].conf) delete videofilters[i].conf;
-             videofilters[i].conf=NULL;
-             videofilters[i].filter=NULL;
-	}
-   nb_active_filter=0;
-}
-void filterListAll( void )
-{
-const char *name;
-	printf("\nVideo filters\n");
-	for(uint32_t i=0;i<allfilters.size();i++)
-	{
-		name=allfilters[i]->filterName;
-
-		{
-			if(name)
-				printf("\t%s\n",name);
-		}
-	}
-
-}
-/**
- *      \fn filterGetTagFromName
- *      \Brief returns the tag associated with a name, invalid otherwise
- */
-VF_FILTERS filterGetTagFromName(const char *inname)
-{
-const char *name;
-int max=allfilters.size();
-	VF_FILTERS filter=VF_INVALID;
-	for(uint32_t i=0;i<max;i++)
-	{
-		name=allfilters[ i]->filterName;
-		if(1) // allfilters[i]->tag==VF_PARTIAL_FILTER)
-		{
-			if(name)
-			{
-				if(strlen(name))
-				{
-					if(!strcasecmp(name,inname))
-						return allfilters[ i]->tag;
-				}
-			}
-		}
-	}
-	return filter;
-}
-/**
- * 	\fn tryLoadingFilterPlugin
- *  \brief try to load the plugin given as argument..
- */
-
-#define Fail(x) {printf("%s:"#x"\n",file);goto er;}
-static bool tryLoadingFilterPlugin(const char *file)
-{
-	ADM_vf_pluginLoader *dll=new ADM_vf_pluginLoader(file);
-
-	FilterDescriptor *desc=NULL;
-	FilterDescriptor *myDesc=NULL;
-	if(!dll->getDesc) Fail(nogetdesc);
-
-	desc=dll->getDesc();
-	if(!desc) Fail(GetDescriptor);
-	// Check the API version
-	if(desc->apiVersion!=ADM_FILTER_API_VERSION) Fail(WrongAPI);
-	if(!(desc->uiFlags & UI_GetCurrentUI())) Fail(WrongUI);
-	// Duplicate it, just in case...
-	myDesc=new FilterDescriptor();
-	memcpy(myDesc,desc,sizeof(*myDesc));
-	// push it !
-	myDesc->tag=tagCount++;
-	ADM_assert(myDesc->category<VF_MAX);
-
-    allfilters.push_back (myDesc);
-    filterCategories[myDesc->category].push_back(myDesc);
-    pluginLoaderQueue.push_back(dll); // Needed for cleanup. FIXME TODO Delete it.
-    printf("[Filters] Registered filter %s as  %s\n",file,desc->name);
-    return true;
-	// Tag it
-	// Fail!
-er:
-	delete dll;
-	return false;
-
-}
-/**
- * 	\fn ADM_vf_loadPlugins
- *  \brief load all video plugins
- */
-uint8_t ADM_vf_loadPlugins(const char *path)
-{
-#define MAX_EXTERNAL_FILTER 100
-
-
-	char *files[MAX_EXTERNAL_FILTER];
-	uint32_t nbFile;
-
-	memset(files,0,sizeof(char *)*MAX_EXTERNAL_FILTER);
-	printf("[ADM_vf_plugin] Scanning directory %s\n",path);
-
-	if(!buildDirectoryContent(&nbFile, path, files, MAX_EXTERNAL_FILTER, SHARED_LIB_EXT))
-	{
-		printf("[ADM_vf_plugin] Cannot parse plugin\n");
-		return 0;
-	}
-
-	for(int i=0;i<nbFile;i++)
-		tryLoadingFilterPlugin(files[i]);
-
-	printf("[ADM_vf_plugin] Scanning done\n");
-
-	return 1;
-}
-/**
- * 	\fn registerFilterEx
- *  \brief Register a video filter
- */
-void registerFilterEx(const char *name,const char *filtername,VF_CATEGORY category,
-		AVDMGenericVideoStream *(*create) (AVDMGenericVideoStream *in, CONFcouple *),
-		AVDMGenericVideoStream *(*create_from_script) (AVDMGenericVideoStream *in, int n,Arg *args),
-		const char *descText)
-{
-
-	FilterDescriptor *desc=new FilterDescriptor(tagCount++,filtername,name,
-												descText,
-												category,
-												create,
-												create_from_script);
-
-		ADM_assert(desc->category<VF_MAX);
-
-        allfilters.push_back (desc);
-        filterCategories[desc->category].push_back(desc);
-
-        aprintf("[Filters] Registered filter %s\n",desc->name);
-
-
-}
-/************************** Get the last video filter of the chain ***************************
-The reference is 0 in that case !
-************************************************************************************************/
-AVDMGenericVideoStream *getLastVideoFilter(void)
-{
-    aviInfo info;
-
-	video_body->getVideoInfo(&info);
-
-	lastNb=info.nb_frames;
-	lastStart=0;
-	aprintf("GetLast : -- LasrNB %lu start %lu \n",lastNb,lastNb);
-  // sanity check
-  	if(nb_active_filter==0)
-  		{
-  		 		nb_active_filter=1;
-				aprintf("--preview filter 0\n");
-				return videofilters[  nb_active_filter-1].filter;
-  		}
- 	updateVideoFilters();
-	return videofilters[  nb_active_filter-1].filter;
-}
-
-/*
-	Return last video filter and rebuild a chain with only the selected frame
-
-*/
-AVDMGenericVideoStream *getLastVideoFilter( uint32_t start, uint32_t nb)
-{
-  // sanity check
-  	lastNb=nb;
-	lastStart=start;
-	aprintf("GetLast full : -- LasrNB %lu start %lu \n",lastNb,lastNb);
-  	if(nb_active_filter==0)
-  		{
-  		 		nb_active_filter=1;
-  		 		videofilters[0].filter=  new AVDMVideoStreamNull(video_body,start,nb);
-  		}
-	updateVideoFilters();
-       return videofilters[  nb_active_filter-1].filter;
-}
-
-/********* Returns the first video filters starting from frame xx with nb frames ***************/
-AVDMGenericVideoStream *getFirstVideoFilter( uint32_t start, uint32_t nbFrame)
-{
-  // sanity check
-  	lastNb=nbFrame;
-	lastStart=start;
-	aprintf("GetFirst full : -- LasrNB %lu start %lu \n",lastNb,lastNb);
-	updateVideoFilters();
-       return videofilters[  0].filter;
-}
-AVDMGenericVideoStream *getFirstCurrentVideoFilter( void)
-{
-	ADM_assert(nb_active_filter);
- 	return videofilters[  0].filter;
-}
-AVDMGenericVideoStream *getFirstVideoFilter( void)
-{
-  // sanity check
-  aviInfo info;
-
-	video_body->getVideoInfo(&info);
-	lastNb=info.nb_frames;
-	lastStart=0;
-	aprintf("GetFirst : -- LasrNB %lu start %lu \n",lastNb,lastNb);
-	updateVideoFilters();
-       return videofilters[  0].filter;
-
-}
-
-FILTER * getCurrentVideoFilterList (uint32_t * count)
-{
-    if (count)
-        *count = nb_active_filter;
-    return videofilters;
-}
-
-//
-//	Parse the list of active filters, delete them et recreate them with (new ?) configuration
-//
-void updateVideoFilters(void )
-{
-		if(nb_active_filter!=0)
-		{
-			delete videofilters[0].filter;
-			videofilters[0].filter=NULL;
-
-		}
-  		 videofilters[0].filter=  new AVDMVideoStreamNull(video_body,lastStart,lastNb);
-
-  		if(nb_active_filter<=1)
-  		{
-  		 	nb_active_filter=1;
-			aprintf("--preview filter %d\n",nb_active_filter-1);
-                        admPreview::updateFilters(videofilters[0].filter,videofilters[nb_active_filter-1].filter);
-  		 	return;
-  		}
-  		// Rebuild other filters
-                for(uint32_t i=1;i<nb_active_filter;i++)
-                {
-                    VF_FILTERS tag;
-                    AVDMGenericVideoStream *old;
-                            old= videofilters[i].filter;
-                            tag=videofilters[i].tag;
-
-                            videofilters[i].filter=filterCreateFromTag(tag,
-                                                videofilters[i].conf,
-                                                videofilters[i-1].filter);
-                          delete old;
-                }
-		aprintf("--preview filter %d\n",nb_active_filter-1);
-                ADM_assert(nb_active_filter);
-                admPreview::updateFilters(videofilters[0].filter,videofilters[nb_active_filter-1].filter);
-}
-//
-//	Create a filter from : its tag, its config and an input stream
-//
-
-AVDMGenericVideoStream *filterCreateFromTag(VF_FILTERS tag,CONFcouple *couple, AVDMGenericVideoStream *in)
-{
-	 AVDMGenericVideoStream *filter;
-
-			ADM_assert(tag!=VF_INVALID);
-
-                        {
-                          for(unsigned int i=0;i<allfilters.size();i++)
-                                  {
-                                          if(tag==allfilters[i]->tag)
-                                                  {
-                                                          filter=allfilters[i]->create( in, couple);
-                                                          return filter;
-                                                  }
-                                  }
-                        }
-			ADM_assert(0);
-			return NULL;
-}
-
-/*
-
-
-*/
-const FilterDescriptor * filterGetEntryFromTag (VF_FILTERS tag)
-{
-    ADM_assert(tag!=VF_INVALID);
-    for(unsigned int i=0;i<allfilters.size();i++)
-    {
-        if(tag==allfilters[i]->tag)
-        {
-            return (allfilters[i]);
-        }
-    }
-    ADM_assert(0);
-    return NULL;
-}
-
-const char  *filterGetNameFromTag(VF_FILTERS tag)
-{
-    const FilterDescriptor * entry = filterGetEntryFromTag (tag);
-    ADM_assert(entry);
-    return entry->name;
-}
-/*____________________________________
-	Save and load current set of filters
-
-	We save/load the tag that identifies the filter
-	and a raw hex dump of its config
-		+ comment and name in clear text
-	____________________________________
-*/
-
-/*---------------------------------------*/
-
-
-uint8_t 	filterAddScript(VF_FILTERS tag,uint32_t n,Arg *args)
-{
-	// 1- search filter
-	int found=-1;
-	aviInfo info;
-
-	video_body->getVideoInfo(&info);
-
-	for(unsigned int i=0;i<allfilters.size();i++)
-	{
-		if(tag==allfilters[i]->tag)
-		{
-			if(nb_active_filter<1)
-			{
-  		 		nb_active_filter=1;
-  		 		videofilters[0].filter=  new AVDMVideoStreamNull(video_body,0,info.nb_frames);
-			}
-			AVDMGenericVideoStream *filter=NULL;
-			CONFcouple *setup=NULL;
-			if(!allfilters[i]->create_from_script)
-			{
-				printf("That filter cannot be created from script\n");
-				return 0;
-			}
-			filter=allfilters[i]->create_from_script(videofilters[nb_active_filter-1].filter,n-1,&(args[1]));
-			if(!filter) return 0;
-			videofilters[nb_active_filter].filter=filter;
-			videofilters[nb_active_filter].tag=tag;
-			filter->getCoupledConf(&setup);
-			videofilters[nb_active_filter].conf=setup;
-			nb_active_filter++;
-			return 1;
-		}
-	}
-	printf("Tag not found:%d\n",tag);
-	return 0;
-}
-
-void filterSaveScriptJS(FILE *f)
-{
-                for(int i=1;i<nb_active_filter;i++)
-                {
-                        VF_FILTERS tag=videofilters[i].tag;
-                        qfprintf(f,"app.video.addFilter(");
-                        for(unsigned int j=0;j<allfilters.size();j++)
-                                {
-                                        if(tag==allfilters[j]->tag)
-                                        {
-                                                qfprintf(f,"\"%s\"",allfilters[j]->filterName);
-                                                break;
-                                        }
-                                }
-                        // get args
-                        CONFcouple *couple;
-                        char *arg,*value,*filtered=NULL;
-                        if(videofilters[i].filter->getCoupledConf( &couple))
-                        {
-                                for(int j=0;j<couple->getNumber();j++)
-                                {
-                                         couple->getEntry(j, &arg,&value);
-                                        // Filter out backslash
-                                         filtered=ADM_escape((ADM_filename *)value);
-                                         qfprintf(f,",\"%s=%s\"",arg,filtered);
-                                         if(filtered) delete [] filtered ;
-                                         filtered=NULL;
-                                }
-                                delete couple;
-                        }
-                        qfprintf(f,");\n");
-
-                }
-
-}
-#endif
-// EOF

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/filter_autoFilter.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/filter_autoFilter.cpp	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/filter_autoFilter.cpp	2009-10-02 05:22:11 UTC (rev 5365)
@@ -1,94 +0,0 @@
-
-/***************************************************************************
-    \fn filter_autoFilter
-    \brief Build aut8omatically addborder & resize filter.
-    copyright            : (C) 200 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include "ADM_default.h"
-
-#include "ADM_videoFilter.h"
-#include "ADM_videoFilter_internal.h"
-
-#include "DIA_coreToolkit.h"
-
-
-extern uint32_t nb_active_filter;
-extern FILTER  videofilters[VF_MAX_FILTER];
-extern AVDMGenericVideoStream *filterCreateFromTag(VF_FILTERS tag,CONFcouple *couple, AVDMGenericVideoStream *in);
-//#include "ADM_video/ADM_vidCommonFilter.h"
-//BUILD_CREATE(crop_create,AVDMVideoStreamCrop);
-
-/**
- *      \fn insertFilter
- *      \brief Create filter
- */
-static AVDMGenericVideoStream *insertFilter(AVDMGenericVideoStream *in,VF_FILTERS tag, CONFcouple *conf)
-{
-  
-  AVDMGenericVideoStream *filter;
-   
-  filter=filterCreateFromTag(tag,conf, in) ;
-  if(!filter)
-    {
-      GUI_Error_HIG("Filter","Cannot create filter.\nMake sure your plugins are properly installed.\n I might crash soon.");
-      return NULL;
-    }
-  return filter;
-}
-/**
- *      \fn create_addBorder
- * 
- */
-AVDMGenericVideoStream *create_addBorder(VF_FILTERS *tag,AVDMGenericVideoStream *in,uint32_t x,uint32_t x2,uint32_t y,uint32_t y2)
-{
-  VF_FILTERS filterTag=VF_INVALID;
-  
-  filterTag=filterGetTagFromName("addblack");
-  if(filterTag==VF_INVALID)
-    {
-        GUI_Error_HIG("Border","The filter addBorder cannot be found.\nMake sure your plugins are properly installed.");
-        return NULL;
-    }
-    // Create confcouples
-  CONFcouple couple(4);
-    couple.setCouple("left",x);
-    couple.setCouple("right",x2);
-    couple.setCouple("top",y);
-    couple.setCouple("bottom",y2);
-    *tag=filterTag;
-    return insertFilter(in,filterTag,&couple);
-}
-
-/**
- *      \fn createResizeFromParam
- *      \brief Create & instert a resize filter
- */
-AVDMGenericVideoStream *createResizeFromParam(VF_FILTERS *tag,AVDMGenericVideoStream*in, unsigned int a, unsigned int b)
-{
-  VF_FILTERS filterTag=VF_INVALID;
-   
-   filterTag=filterGetTagFromName("mpresize");
-   if(filterTag==VF_INVALID)
-     {
-         GUI_Error_HIG("Resize","The filter resize cannot be found.\nMake sure your plugins are properly installed.");
-         return NULL;
-     }
-     // Create confcouples
-   CONFcouple couple(3);
-     couple.setCouple("w",a);
-     couple.setCouple("h",b);
-     couple.setCouple("algo",1);
-     *tag=filterTag;
-     return insertFilter(in,filterTag,&couple);     
-}

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/filter_declaration.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/filter_declaration.cpp	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/filter_declaration.cpp	2009-10-02 05:22:11 UTC (rev 5365)
@@ -1,63 +0,0 @@
-/***************************************************************************
-                          filter_declaration.cpp  -  description
-
-                          Declare filters that are statically linked to avidemux.
-                          Usually it is to be avoided and better to use dynamic filter.
-
-                             -------------------
-
-    copyright            : (C) 2008 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include "ADM_default.h"
-
-
-
-#include "ADM_videoFilter.h"
-#include "ADM_videoFilter_internal.h"
-
-#define FILTERDEC_create(x) extern   AVDMGenericVideoStream *x(AVDMGenericVideoStream *in, CONFcouple *param)
-#define FILTERDEC_createFromScript(x) extern   AVDMGenericVideoStream *x(AVDMGenericVideoStream *in, int n,Arg *args)
-
-#define REGISTERX(z,a,b,c,d,e,f,g) {\
-			FILTERDEC_create(f);\
-			FILTERDEC_createFromScript(g);\
-			registerFilterEx((const char*)a,(const char *)b,z,f,g,(const char *)c);\
-}
-
-void registerVideoFilters( void )
-{
-printf("\n Registering Internal Filters\n");
-printf(  "******************************\n");
-
-
-#if BAZOOKA
-        REGISTERX(VF_SUBTITLE,"vobsub",QT_TR_NOOP("VobSub"),QT_TR_NOOP("Embed VobSub subtitles into picture."),VF_VOBSUB,1,vobsub_create,vobsub_script);
-        REGISTERX(VF_SUBTITLE,"dvbsub",QT_TR_NOOP("DVB sub"),QT_TR_NOOP("Embed DVB-T subtitle."),VF_DVBSUB,1,dvbsub_create,dvbsub_script);
-#endif
-        //*********************
-#if 0
-	REGISTERX(VF_MISC, "computeaverage",QT_TR_NOOP("Compute Average"),QT_TR_NOOP("Compute average luma value for each pixel throughout all frames, and save to file"),VF_COMPUTEAVERAGE,1,computeaverage_create,computeaverage_script);
-	REGISTERX(VF_MISC, "threshold",QT_TR_NOOP("Threshold"),QT_TR_NOOP("Force too-bright/too-dim pixels to 0 and the rest to 255 or vice-versa"),VF_THRESHOLD,1,threshold_create,threshold_script);
-	REGISTERX("particlelist",QT_TR_NOOP("Particle List"),QT_TR_NOOP("Identify 'particles' (groups of pixels)"),VF_PARTICLELIST,1,particle_create,particle_script);
-	REGISTERX("eraser",QT_TR_NOOP("Eraser"),QT_TR_NOOP("\"Erase\" arbitrary areas of each frame"),VF_ERASER,1,eraser_create,eraser_script);
-	REGISTERX("swissarmyknife",QT_TR_NOOP("Swiss Army Knife"),QT_TR_NOOP("Apply operation like P'=P*A, P-A, P+A, etc. using a convolution, rolling average, image from file, or constant"),VF_SWISSARMYKNIFE,1,swissarmyknife_create,swissarmyknife_script);
-#endif
-// Misc filter, internal only
-//	REGISTERX(VF_MISC,"partial",QT_TR_NOOP("Partial"),"",VF_PARTIAL,0,partial_create,partial_script);
-//	REGISTERX(VF_MISC,"framenum",QT_TR_NOOP("Add Framenumber"),QT_TR_NOOP("Print frame number directly in image"),VF_FRAMENUM,1,number_create,number_script);
- printf("\n");
-}
-
-
-// EOF

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/filter_saveload.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/filter_saveload.cpp	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/filter_saveload.cpp	2009-10-02 05:22:11 UTC (rev 5365)
@@ -1,304 +0,0 @@
-/***************************************************************************
-                          filter_saveload.cpp  -  description
-                             -------------------
-	Save/load filter
-
-    begin                : Wed Apr 12 2003
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#define ADM_LEGACY_PROGGY
-
-#include "ADM_default.h"
-#include <libxml/tree.h>
-#include <libxml/parser.h>
-#include "fourcc.h"
-#include "DIA_coreToolkit.h"
-#include "ADM_quota.h"
-
-
-#include "ADM_editor/ADM_edit.hxx"
-#include "ADM_videoFilter.h"
-//#include "ADM_video/ADM_videoNull.h"
-#include "ADM_videoFilter_internal.h"
-//#include "ADM_video/ADM_vidPartial.h"
-#include "avi_vars.h"
-// exported vars
-extern uint32_t nb_active_filter;
-extern FILTER  videofilters[VF_MAX_FILTER];
-
-extern AVDMGenericVideoStream *filterCreateFromTag(VF_FILTERS tag,CONFcouple *couple, AVDMGenericVideoStream *in);
-extern void filterCleanUp( void );
-
-
-/*
-
-  	Try to rebuild filter from text file
-
-
-*/
-
-static int32_t getIntegerAttribute(xmlNodePtr node, char *name, char *atrname);
-static xmlNodePtr nextByName(xmlNodePtr node,char *name);
-static CONFcouple *buildCouple(uint32_t nb, xmlNodePtr node);
-extern int qxmlSaveFormatFile(const char *filename, xmlDocPtr cur, int format);
-/**
-	Xml Read/write ConfCouple from files
-*/
-void filterSaveXml(const char *docname)
-{
-	filterSaveXml(docname,0);
-}
-
-void filterSaveXml(const char *docname,uint8_t silent)
-{
- xmlDocPtr xdoc;
- xmlNodePtr node;
- xmlAttrPtr attr;
- char tmpstring[1024];
-VF_FILTERS tag;
-int max;
-		UNUSED_ARG(silent);
-		if( ! (xdoc = xmlNewDoc((const xmlChar *)"1.0")) ) {printf("Problem creating xml doc\n");	return ;}
-		if( ! (xdoc->children = xmlNewNode(NULL,(xmlChar *)"filters")) )
-			{
-				xmlFreeDoc(xdoc);
-				xdoc = NULL;
-				return ;
-			}
-		// we add # of filteras as attribute to the first children
-		max=nb_active_filter;
-		if(max) max--;
-		sprintf(tmpstring,"%d",max);
-		attr=xmlNewProp(xdoc->children,(xmlChar *)"FilterNumber",(xmlChar *)tmpstring);
-		if(max)
-		for(uint32_t curFilter=1;curFilter<nb_active_filter;curFilter++)
-		{
-			// for each filter we create a new node
-
-			node= xmlNewChild(xdoc->children,NULL,(xmlChar *)"Filter",NULL );
-
-			tag=videofilters[curFilter].tag;
-
-			// and fill-up some informations
-			sprintf(tmpstring,"%d",tag);
-			attr=xmlNewProp(node,(xmlChar *)"Tag",(xmlChar *)tmpstring);
-
-			attr=xmlNewProp(node,(xmlChar *)"Conf",(xmlChar *)videofilters[curFilter].filter->printConf());
-
-			// now we create a child containing the config
-			CONFcouple *setup;
-
-			if( videofilters[curFilter].filter->getCoupledConf(&setup))
-			{
-				// we create a new child parameters with # of parameter as attribute
-				 xmlNodePtr nodeConf; //,tmpnode;
-// 				 xmlAttrPtr attrConf;
-
-
-				 char *nm,*val;
-
-					nodeConf= xmlNewChild(node,NULL,(xmlChar *)"Parameters",NULL );
-					sprintf(tmpstring,"%"LU"",setup->getNumber());
-					xmlNewProp(nodeConf,(xmlChar *)"Number",(xmlChar *)tmpstring);
-
-					// and write each attribute
-					for(uint32_t i=0;i<setup->getNumber();i++)
-					{
-						ADM_assert(setup->getEntry(i,&nm,&val));
-						xmlNewChild(nodeConf,NULL,(xmlChar *)nm,(xmlChar *)val );
-					}
-				delete setup;
-			}
-
-		}
-
-		xmlSetDocCompressMode(xdoc,0);  // we want pure text
-		qxmlSaveFormatFile(docname,xdoc,1);
-		xmlFreeDoc(xdoc);
-	return ;
-}
-void filterLoadXml(const char *docname)
-{
-	filterLoadXml(docname,0);
-}
-
-int filterLoadXml(const char *docname,uint8_t silent)
-{
-#if 0
- xmlDocPtr xdoc;
- xmlNodePtr node,subnode;
-int32_t nb_filters,itag;
-CONFcouple *couple;
-//uint16_t s16;
-			UNUSED_ARG(silent);
-			xdoc=xmlParseFile(docname);
-			if(!xdoc)
-				{
-                                  GUI_Error_HIG(QT_TR_NOOP("Problem reading XML filters"), NULL);
-					return 0;
-				}
-			node=xdoc->children;
-			nb_filters=getIntegerAttribute(node,(  char *)"filters",(  char *)"FilterNumber");
-			if(nb_filters==-1)
-					{
-							xmlFreeDoc(xdoc);
-                                                        GUI_Error_HIG(QT_TR_NOOP("No filter found"), NULL);
-							return 0;
-					}
-
-			if(1<nb_active_filter)
-			{
-					  filterCleanUp();
-			}
-
-			// if there is no active filter
-			// Create at least the editor output one
-
-			if(!nb_active_filter)
-			{
-                                uint32_t fStart,fEnd;
-
-				// avoid going down
-				aviInfo aviinf;
-  				// now build infos
-  				video_body->getVideoInfo(&aviinf);
-				fStart=0;
-				fEnd=aviinf.nb_frames-1;
-  		 		videofilters[0].filter=  new AVDMVideoStreamNull(video_body,0,fEnd);
-
-    			}
-			nb_active_filter=1;
-
-			// now ready to add new ones
-
-			subnode=node->children;
-			for(uint32_t curFilter=0;curFilter<(uint32_t)nb_filters;curFilter++)
-			{
-				// lookup next filter_saveload
-				subnode=nextByName(subnode ,(char *)"Filter");
-				if(!node)
-					{
-                                          GUI_Error_HIG(QT_TR_NOOP("Could not find a filter"), NULL);
-						return 0;
-					}
-
-				itag=getIntegerAttribute(subnode,(char *)"Filter",(char *)"Tag");
-				if(itag==-1)
-					{
-							xmlFreeDoc(xdoc);
-                                                        GUI_Error_HIG(QT_TR_NOOP("No tag found"), NULL);
-							return 0;
-					}
-				// now we got the tag
-				printf("\n %"LU" tag \n",itag);
-
-				// and we can build a CONFCouple if necessary
-				xmlNodePtr conf;
-				conf=subnode->children;
-				conf=nextByName(conf ,(char *)"Parameters");
-				if(!conf)
-					{ // no paramaters needed
-						couple=NULL;
-					}
-				else
-					{
-						int32_t args=getIntegerAttribute(conf,(char *)"Parameters",(char *)"Number");
-			//			printf("\n ** needs %d param :\n",args);
-
-						conf=conf->children;
-						ADM_assert(conf);
-						ADM_assert(args);
-						couple=buildCouple(args,conf);
-
-					}
-
-				// once we have tag and CONFcouple we can build the filter
-			//	if(couple) couple->dump();
-				videofilters[nb_active_filter].filter= filterCreateFromTag( (VF_FILTERS)itag,
-													couple,
-													videofilters[nb_active_filter-1].filter);
-				videofilters[nb_active_filter].tag=(VF_FILTERS)itag;
-				videofilters[nb_active_filter].conf=couple;;
-				nb_active_filter++;
-
-
-				couple=NULL;
-				// next filter please!
-				subnode=subnode->next;
-			}
-			printf("\n found : %"LU" filters\n",nb_filters);
-	xmlFreeDoc(xdoc);
-#endif
-	return 1;
-}
-CONFcouple *buildCouple(uint32_t nb, xmlNodePtr node)
-{
-char *val,*nm;
-	CONFcouple *couple=new CONFcouple(nb);
-	while(node)
-	{
-		nm=(char *)node->name;
-		if(!xmlStrcmp((xmlChar *)nm,(xmlChar *)"text"))
-			{
-				node=node->next;
-			 	continue;
-			 }
-		val=(char *)xmlNodeGetContent(node);
-
-		ADM_assert(val);
-		ADM_assert(couple->setCouple(nm,val));
-	//	printf("\n --> :%s: %s \n",nm,val);
-		nb--;
-		node=node->next;
-
-	};
-	ADM_assert(nb==0);
-	return couple;
-
-}
-xmlNodePtr nextByName(xmlNodePtr node,char *name)
-{
-// lookup next filter_saveload
-				if(!node) return NULL;
-				while(1)
-				{
-				//	printf("\n %d %s\n",curFilter,subnode->name);
-					if(!xmlStrcmp(node->name,(const xmlChar *)name)) break;
-					node=node->next;
-					if(!node)
-					{
-                                          GUI_Error_HIG(QT_TR_NOOP("Node not found"), NULL);
-						return NULL;
-					}
-				};
-				return node;
-
-}
-int32_t getIntegerAttribute(xmlNodePtr node, char *name, char *atrname)
-{
-
-			if(!xmlStrcmp(node->name,(const xmlChar *)name))
-			{
-				// found
-				char *str;
-				str=(char *)xmlGetProp(node,(const xmlChar *)atrname);
-				return atoi(str);
-			}
-			printf("\n %s was the name\n",node->name);
-
-
-
-	return -1;
-}
-
-//EOF

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/vidVCD.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/vidVCD.cpp	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/vidVCD.cpp	2009-10-02 05:22:11 UTC (rev 5365)
@@ -1,324 +0,0 @@
-/***************************************************************************
-                          vidVCD.cpp  -  description
-                             -------------------
-    begin                : Wed Aug 21 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
-
-	This is a meta filter that adds the needed filter to convert the stream to VCD resolution
-   It computes the parmater and create
-			- A resize filter
-			- A Add border filter
-
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include "ADM_default.h"
-
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <unistd.h>
-#include <string.h>
-#include <math.h>
-#include "fourcc.h"
-#include "avi_vars.h"
-
-
-#include "prototype.h"
-#include "ADM_editor/ADM_edit.hxx"
-#include "ADM_videoFilter.h"
-#include "ADM_videoFilter_internal.h"
-#include "ADM_filter/vidVCD.h"
-#include "prefs.h"
-#include "ADM_commonUI/DIA_resizeWiz.h"
-#include "ADM_vidMisc.h"
-//___________________________________________
-extern FILTER videofilters[VF_MAX_FILTER];
-extern uint32_t nb_active_filter;
-extern ADM_Composer *video_body;
-
-static uint8_t computeResize (void);
-
-
-RESWIZ_FORMAT format;
-RESWIZ_AR sourceAR, destinationAR;
-static double aspectRatio[2][3]={
-                                                                {1.,0.888888,1.19}, // NTSC 1:1 4:3 16:9
-                                                                {1.,1.066667,1.43} // PAL  1:1 4:3 16:9
-                                                        };
-
-typedef struct 
-{
-        int x1,x2,y1,y2;
-}targetFmt;
-
-
-static targetFmt VCD={352, 352, 288, 240};
-static targetFmt SVCD={480, 720, 576, 480};
-static targetFmt DVD={720, 720, 576, 480};
-static targetFmt DVDHD1={352, 720, 576, 480};
-static targetFmt PSP={480, 480, 272, 272};
-static targetFmt PSPH264={720, 720, 480, 480};
-static targetFmt IPOD={320, 320, 240, 240};
-static targetFmt IPOD640={640, 640, 480, 480};
-
-/* Dont forget to update DIA_resizeWiz if you change something here */
-
-targetFmt *allFormats[]={&VCD,&SVCD,&DVD,&DVDHD1,&PSP,&PSPH264,&IPOD,&IPOD640};
-extern AVDMGenericVideoStream *createResampleFps(AVDMGenericVideoStream *in,uint32_t targetfps1000);
-#define ARME(x) format=RESWIZ_##x
-
-uint8_t setVCD (void)
-{
-
-  ARME (VCD);
-  return computeResize();
-}
-
-/**
-    \fn     setIPOD (void)
-    \brief  Setup  video size & fps to be compatible with IPOD
-*/
-uint8_t setIPOD (void)
-{
-  int8_t r=0;
-ADV_Info *info;
-uint32_t fps1000;
-
-    ARME (IPOD);
-    return computeResize();
-}
-
-/**
-    \fn     setPSP (void)
-    \brief  Setup  video size & fps to be compatible with PSP
-*/
-uint8_t setPSP (void)
-{
-uint8_t r=0;
-ADV_Info *info;
-uint32_t fps1000;
-
-    ARME (PSP);
-    return computeResize();
-}
-/**
-    \fn     setPSPFullRes (void)
-    \brief  Setup  video size & fps to be compatible with PSP FULL SCREEN
-*/
-uint8_t setPSPFullRes (void)
-{
-uint8_t r=0;
-ADV_Info *info;
-uint32_t fps1000;
-
-    ARME (PSP_FULLRES);
-    return computeResize();
-}
-
-uint8_t setSVCD (void)
-{
-
-  ARME (SVCD);
-  return computeResize();
-}
-uint8_t setDVD (void)
-{
-
-  ARME (DVD);
-  return computeResize();
-}
-uint8_t setHalfD1 (void)
-{
-
-  ARME (DVD_HD1);
-  return computeResize();
-}
-
-
-extern AVDMGenericVideoStream *create_addBorder (VF_FILTERS *o, AVDMGenericVideoStream * in,
-						 uint32_t x, uint32_t x2,
-						 uint32_t y, uint32_t y2);
-extern AVDMGenericVideoStream *createResizeFromParam (VF_FILTERS *o, AVDMGenericVideoStream *
-						      in, uint32_t x,
-						      uint32_t y);
-//
-//  Compute the filters, aspect is the reduction factor for h
-//  =1 for VCD/DVD
-//      =2/3 for SVCD
-//------------------------------
-/********************************************************************/
-uint8_t
-computeResize (void)
-{
-
-int targetx,targetxFinal,targetyPAL,targetyNTSC;
-
-  ADV_Info *info;
-  char *inputratio = NULL;
-
-
-  uint8_t res = 0;		/* 1 Pal, 2 NSTC or film */
-  uint32_t targety;
-
-  // scale as if it was 1:1 -> 4:3
-        prefs->get (FEATURE_SVCDRES_PREFEREDSOURCERATIO, &inputratio);
-        if(inputratio)
-        {
-                if (inputratio && !strcmp (inputratio, "1:1")) 
-                        sourceAR=RESWIZ_AR_1_1;
-                if (inputratio && !strcmp (inputratio, "4:3")) 
-                        sourceAR=RESWIZ_AR_4_3;
-                if (inputratio && !strcmp (inputratio, "16:9")) 
-                        sourceAR=RESWIZ_AR_16_9;
-     
-                ADM_dealloc (inputratio);
-                inputratio = NULL;
-        }
-        
-  
-  if (!DIA_resizeWiz (&format, &sourceAR, &destinationAR))
-    return 0;
-
- targetx=allFormats[format]->x1;
- targetxFinal=allFormats[format]->x2;
- targetyPAL=allFormats[format]->y1;
- targetyNTSC=allFormats[format]->y2;
-        
-
-  info = getLastVideoFilter (frameStart, frameEnd - frameStart)->getInfo ();
-
-
-  res = identMovieType (info->fps1000);
-  //printf("fps : %lu / %d \n",info->fps1000,res);
-  switch (res)
-    {
-    case FRAME_PAL:
-      res = 1;
-      break;
-    case FRAME_NTSC:
-    case FRAME_FILM:
-      res = 2;
-      break;
-    default:
-      res = 0;
-      return 0;
-      break;
-    }
-  if (res == 2)
-    targety = targetyNTSC;
-  else
-    targety = targetyPAL;
-
-
-  double rx, ry;
-  uint32_t newx, newy;
-  uint32_t cropx, cropy;
-  uint32_t original_x, original_y;
-
-
-  original_x = info->width;
-  original_y = info->height;
-
-  
-  // scale as if it was 1:1 -> 4:3
-  rx = original_x;
-  switch (res)
-  {
-      case 1:		//PAL
-                rx = rx *aspectRatio[1][sourceAR]/aspectRatio[1][destinationAR];
-                break;
-       case 2:		// NTSC
-                rx = rx * aspectRatio[0][sourceAR]/aspectRatio[0][destinationAR];
-                break;
-   }
-
-  original_x = (uint32_t) floor (rx + 0.49);
-
-  rx = original_x;
-  rx = rx / targetxFinal;
-
-
-  ry = original_y;
-  ry = ry / targety;
-
-  // which do do we compress less ?
-  if (rx > ry)			// resize by X, add border afterward
-    {
-      newx = targetx;
-      ry = original_y;
-      ry = ry / rx;
-      newy = (uint32_t) floor (ry + 0.49);
-      printf (" resize by x\n");
-
-    }
-  else
-    {
-      newy = targety;
-      rx = original_x;
-      rx = rx / ry;
-      rx *= targetx;
-      rx /= targetxFinal;
-      newx = (uint32_t) floor (rx + 0.49);
-      printf (" resize by y\n");
-
-    }
-
-  printf ("\n New X x Y = %u x %u\n", newx, newy);
-
-  // correct odd / even
-
-  newx -= newx % 4;
-  newy -= newy % 4;
-
-  // Now correct crop
-
-
-  cropx = targetx - newx;
-  cropy = targety - newy;
-
-  printf ("\n Resized to : %u x %u, add black border %u x %u",
-	  newx, newy, cropx, cropy);
-
-  // now build filter
-
-
-// first resize (if needed)
-
-  CONFcouple *couple;
-  if (newx != info->width || newy != info->height)
-    {
-      VF_FILTERS rtag=VF_INVALID;
-      videofilters[nb_active_filter].filter =
-	createResizeFromParam (&rtag,getLastVideoFilter (), newx, newy);
-      if(! videofilters[nb_active_filter].filter) return 0;
-
-      videofilters[nb_active_filter].tag = rtag;
-      videofilters[nb_active_filter].filter->getCoupledConf (&couple);
-      videofilters[nb_active_filter].conf = couple;;
-      nb_active_filter++;
-    }
-// then add crop (if needed)
-
-  if (cropx || cropy)
-    {
-      VF_FILTERS ctag=VF_INVALID;
-      videofilters[nb_active_filter].filter =
-	create_addBorder (&ctag,videofilters[nb_active_filter - 1].filter,
-			  cropx >> 1, cropx >> 1, cropy >> 1, cropy >> 1);
-      if(! videofilters[nb_active_filter].filter) return 0;
-      videofilters[nb_active_filter].tag = ctag;
-      videofilters[nb_active_filter].filter->getCoupledConf (&couple);
-      videofilters[nb_active_filter].conf = couple;;
-      nb_active_filter++;
-    }
-  return 1;
-}

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/vidVCD.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/vidVCD.h	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_filter/vidVCD.h	2009-10-02 05:22:11 UTC (rev 5365)
@@ -1,31 +0,0 @@
-/***************************************************************************
-                          vidVCD.h  -  description
-                             -------------------
-    begin                : Wed Aug 21 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
-
-	
-
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifndef vidVCD_H
-#define vidVCD_H
-
-uint8_t setSVCD( void );
-uint8_t setVCD( void );
-uint8_t setPSP(void);
-uint8_t setPSPFullRes(void);
-uint8_t setDVD( void );
-uint8_t setHalfD1( void );
-uint8_t setIPOD( void);
-
-#endif

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_toolkit/automation.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_toolkit/automation.cpp	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_toolkit/automation.cpp	2009-10-02 05:22:11 UTC (rev 5365)
@@ -40,7 +40,7 @@
 #include "ADM_debug.h"
 #include "avidemutils.h"
 
-#include "ADM_filter/vidVCD.h"
+
 #include "ADM_vidMisc.h"
 #include "ADM_coreVideoEncoder.h"
 #include "ADM_audioFilter/include/ADM_audioFilterInterface.h"

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_mpdetc.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_mpdetc.h	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_mpdetc.h	2009-10-02 05:22:11 UTC (rev 5365)
@@ -1,71 +0,0 @@
-//
-//
-// C++ Interface: ADM_mpdetc
-//
-// Description: 
-//		Port of Mplayer Detc filter (inverse telecine)
-//		Original author & copyright : Richard Felker
-//
-// Author: mean <fixounet at free.fr>, (C) 2003
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-typedef struct metrics {
-	/* difference: total, even lines, odd lines */
-	int d, e, o;
-	/* noise: temporal, spacial (current), spacial (past) */
-	int t, s, p;
-};
-
-typedef struct frameinfo {
-	/* peak, relative, mean */
-	 metrics p, r, m;
-};
-
-struct vf_priv_s {
-	struct frameinfo fi[2];
-	uint8_t  *dmpi;
-	int first;
-	int drop, lastdrop, dropnext;
-	int inframes, outframes;
-};
-
-enum {
-	F_DROP,
-	F_MERGE,
-	F_NEXT,
-	F_SHOW
-};
-
-
-
-class  AVDMVideoMPDetc:public AVDMGenericVideoStream
- {
-
- protected:
-
-	struct vf_priv_s	*_param;
-	ADMImage		*_lastFrame;
-        virtual char 		*printConf(void) ;
-	
-	
-		uint8_t 	do_put_image(ADMImage *data);
-		uint32_t	_inFrame;
-		uint32_t	_lastAsked;
-		uint32_t 	_copy;
-	
-
- public:
-  				AVDMVideoMPDetc(  AVDMGenericVideoStream *in,CONFcouple *setup);
-  				~AVDMVideoMPDetc();
-	virtual uint8_t 	getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-          									ADMImage *data,uint32_t *flags);
-
-			virtual uint8_t 	configure( AVDMGenericVideoStream *instream) 
-								{return 0;};
-
-
- }     ;
-
- 

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidComputeAverage.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidComputeAverage.cpp	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidComputeAverage.cpp	2009-10-02 05:22:11 UTC (rev 5365)
@@ -1,513 +0,0 @@
-/***************************************************************************
-                          ADM_vidComputeAverage.cpp  -  compute average of
-                                                     all frames (so it can
-                                                     later be subtracted to
-                                                     remove static
-                                                     background details)
-                              -------------------
-                          Chris MacGregor, 2005, 2007
-                         chris-avidemux at bouncingdog.com
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
- 
-#include "ADM_default.h"
-#include "ADM_videoFilter.h"
-
-#include "DIA_factory.h"
-#include "ADM_vidComputeAverage.h"
-
-static FILTER_PARAM computeAverageParam={5,{"start_frame",
-                                            "end_frame",
-                                            "output_file",
-                                            "bias",
-                                            "display_mode"}};
-
-// This is a hack to work around the fact that the ctor & dtor get called
-// too often.  The right solution would be to arrange for the filter
-// objects to be constructed and destructed only when really necessary:
-// when a new instance of a filter is added to the list (by the user), it
-// is constructed, and when it is removed from the list (by the user), it
-// is destructed, and anything else is handled by a separate init() or
-// configure() method.  This would allow the objects to maintain a
-// persistent state in a more straightforward way.
-
-ADMVideoComputeAverage::PImap ADMVideoComputeAverage::pimap;
-
-
-SCRIPT_CREATE(computeaverage_script,ADMVideoComputeAverage,computeAverageParam);
-
-BUILD_CREATE(computeaverage_create,ADMVideoComputeAverage);
-
-ADMVideoComputeAverage::ADMVideoComputeAverage(AVDMGenericVideoStream *in,CONFcouple *couples)
-			
-{
-    _in = in;
-    memcpy (&_info, in->getInfo(), sizeof(_info));
-    _info.encoding = 1;	
-    _uncompressed = new ADMImage (_in->getInfo()->width, _in->getInfo()->height);
-    ADM_assert(_uncompressed);
-    _param = new COMPUTEAVERAGE_PARAM;
-
-    if (couples)
-    {
-        GET(start_frame);
-        GET(end_frame);
-        char * tmp;
-        GET2(output_file, tmp);
-        GET(bias);
-        GET(display_mode);
-    }
-    else
-    {
-        _param->start_frame = 0;
-        _param->end_frame = -1;
-        _param->output_file = ADM_strdup ("");
-        _param->bias = 128;
-        _param->display_mode = DISPLAYMODE_FRAME_MINUS_AVERAGE;
-    }
-
-    // This is a hack to work around the fact that the ctor & dtor get called
-    // too often.  The right solution would be to arrange for the filter
-    // objects to be constructed and destructed only when really necessary:
-    // when a new instance of a filter is added to the list (by the user), it
-    // is constructed, and when it is removed from the list (by the user), it
-    // is destructed, and anything else is handled by a separate init() or
-    // configure() method.  This would allow the objects to maintain a
-    // persistent state in a more straightforward way.
-
-    // This explicit check wouldn't be necessary if there was an easier way of
-    // ensuring that we got a 0 pointer when a new map entry was auto-consed
-    // up...
-
-    if (pimap.count (couples) == 0)
-    {
-        myInfo = new PersistentInfo;
-        myInfo->conf = couples;
-        pimap [couples] = myInfo;
-    }
-    else
-    {
-        myInfo = pimap [couples];
-        if (couples)
-        {
-            if (myInfo->oldConf == couples)
-            {
-                pimap.erase (myInfo->conf);
-                myInfo->conf = myInfo->oldConf;
-                myInfo->oldConf = 0;
-            }
-            else
-            {
-                ADM_assert (myInfo->conf == couples);
-
-                if (myInfo->oldConf)
-                {
-                    pimap.erase (myInfo->oldConf);
-                    myInfo->oldConf = 0;
-                }
-            }
-        }
-    }
-
-    myInfo->refCount++;
-
-    printf ("ADMVideoComputeAverage ctor (%p, conf = %p), pi = %p, rc now %d\n",
-            this, couples, myInfo, myInfo->refCount);
-}
-
-uint8_t	ADMVideoComputeAverage::getCoupledConf (CONFcouple **couples)
-{
-
-    ADM_assert(_param);
-    *couples=new CONFcouple(computeAverageParam.nb);
-
-    // This is a hack to work around the fact that the ctor & dtor get called
-    // too often.  The right solution would be to arrange for the filter
-    // objects to be constructed and destructed only when really necessary:
-    // when a new instance of a filter is added to the list (by the user), it
-    // is constructed, and when it is removed from the list (by the user), it
-    // is destructed, and anything else is handled by a separate init() or
-    // configure() method.  This would allow the objects to maintain a
-    // persistent state in a more straightforward way.
-
-    printf("ADMVideoComputeAverage::getCoupledConf(): this = %p, couples = %p, "
-           "oldConf = %p (was %p), pi = %p\n",
-           this, *couples, myInfo->conf, myInfo->oldConf, myInfo);
-
-    if (myInfo->oldConf)
-        pimap.erase (myInfo->oldConf);
-    myInfo->oldConf = myInfo->conf;
-    myInfo->conf = *couples;
-    pimap [myInfo->conf] = myInfo;
-    if (myInfo->oldConf == 0)
-        pimap.erase (0);
-
-#define CSET(x)  (*couples)->setCouple((char *)#x,(_param->x))
-    CSET(start_frame);
-    CSET(end_frame);
-    CSET(output_file);
-    CSET(bias);
-    CSET(display_mode);
-
-    return 1;
-
-}
-
-uint8_t ADMVideoComputeAverage::configure(AVDMGenericVideoStream *in)
-{
-    UNUSED_ARG(in);
-
-    diaElemInteger start_frame
-        (&(_param->start_frame),
-         QT_TR_NOOP("_Start Frame (first frame # to include in average):"),
-         0, 0x7fffffff);
-    diaElemInteger end_frame
-        (&(_param->end_frame),
-         QT_TR_NOOP("_End Frame (last frame # to include), -1 = last:"),
-         -1000000, 0x7fffffff);
-    diaElemFile output_file
-        (1, const_cast<char **>(&(_param->output_file)),
-         QT_TR_NOOP("_Output File:"), NULL, QT_TR_NOOP("Select output file"));
-    diaElemSlider bias
-        (&(_param->bias),
-         QT_TR_NOOP("_Bias (only for display; use 0 for "
-           "average, 128 for frame minus average):"), -256, +256);
-    diaMenuEntry tDisplayMode [] = {
-        { DISPLAYMODE_FRAME_MINUS_AVERAGE,
-          QT_TR_NOOP("Current frame minus average so far"), NULL },
-        { DISPLAYMODE_AVERAGE, QT_TR_NOOP("Average so far"), NULL },
-        { DISPLAYMODE_BLANK,
-          QT_TR_NOOP("Display nothing (fast for batch processing)"), NULL },
-    };
-    diaElemMenu display_mode
-        (&(_param->display_mode),
-         QT_TR_NOOP("Display _Mode:"),
-         sizeof (tDisplayMode) / sizeof (diaMenuEntry), tDisplayMode);
-    diaElem * elems[] = { &start_frame, &end_frame, &output_file,
-                          &bias, &display_mode };
-
-    uint8_t ret = diaFactoryRun(QT_TR_NOOP("ComputeAverage"), sizeof (elems) / sizeof (diaElem *), elems);
-    return ret;
-	
-}
-
-ADMVideoComputeAverage::~ADMVideoComputeAverage()
-{
-    // This is a hack to work around the fact that the ctor & dtor get called
-    // too often.  The right solution would be to arrange for the filter
-    // objects to be constructed and destructed only when really necessary:
-    // when a new instance of a filter is added to the list (by the user), it
-    // is constructed, and when it is removed from the list (by the user), it
-    // is destructed, and anything else is handled by a separate init() or
-    // configure() method.  This would allow the objects to maintain a
-    // persistent state in a more straightforward way.
-
-    myInfo->refCount--;
-    printf ("ADMVideoComputeAverage dtor (%p), conf = %p, pi = %p, rc now %d\n",
-            this, myInfo->conf, myInfo, myInfo->refCount);
-
-    if (myInfo->oldConf)
-    {
-        pimap.erase (myInfo->oldConf);
-        myInfo->oldConf = 0;
-    }
-
-    if (myInfo->refCount < 1)
-    {
-        pimap.erase (myInfo->conf);
-        delete myInfo;
-    }
-
-    DELETE(_param);
-    delete  _uncompressed;	
-    _uncompressed=NULL;
-}
-
-char * ADMVideoComputeAverage::printConf (void) 
-{
-    const int CONF_LEN = 512;
-    static char conf[CONF_LEN];
-
-    const char * display = "oops";
-    if (_param->display_mode == DISPLAYMODE_AVERAGE)
-        display = "average so far";
-    else if (_param->display_mode == DISPLAYMODE_FRAME_MINUS_AVERAGE)
-        display = "current frame minus average so far";
-    else if (_param->display_mode == DISPLAYMODE_BLANK)
-        display = "nothing (fast)";
-
-    snprintf(conf, CONF_LEN, "ComputeAverage: Average of frames %d - %d, "
-             "output to %s, display %s %+d",
-             _param->start_frame, _param->end_frame, _param->output_file,
-             display, _param->bias);
-    return conf;
-	
-}
-
-static inline
-uint8_t saturate_pixel (uint32_t pixel)
-{
-    if (pixel & 0xffffff00)
-    {
-        if (int32_t (pixel) < 0)
-            return 0;
-        else // if (pixel > 255)
-            return 255;
-    }
-
-    return pixel;
-}
-
-uint8_t ADMVideoComputeAverage::getFrameNumberNoAlloc (uint32_t frame, uint32_t *len,
-                                                       ADMImage *data, uint32_t *flags)
-{
-    if (frame >= _info.nb_frames)
-        return 0;
-
-    int debug = 0;
-
-    int curr_frame = frame + _info.orgFrame;
-    int num_frames = _info.nb_frames + _info.orgFrame;
-
-    int planesize = _info.width * _info.height;
-    uint32_t size = (planesize * 3) >> 1;
-    *len = size;
-			
-    if (!_in->getFrameNumberNoAlloc (frame, len, _uncompressed, flags))
-        return 0;
-    ADMImage * image = _uncompressed;
-
-    uint32_t start_frame = _param->start_frame;
-    uint32_t end_frame = _param->end_frame;
-    if (int32_t (end_frame) < 0)
-        end_frame = int32_t (num_frames) + int32_t (end_frame); // 0-based, thus -1 = last frame
-
-    if (!myInfo->sums
-        || myInfo->width != _info.width || myInfo->height != _info.height
-        || myInfo->start_frame != start_frame
-        || myInfo->end_frame != end_frame)
-    {
-        printf ("ADMVideoComputeAverage: resetting; was %p %ux%u, %u..%u\n",
-                myInfo->sums, myInfo->width, myInfo->height,
-                myInfo->start_frame, myInfo->end_frame);
-
-        if (!myInfo->sums
-            || myInfo->width != _info.width || myInfo->height != _info.height)
-        {
-            myInfo->width = _info.width;
-            myInfo->height = _info.height;
-            delete[] myInfo->sums;
-            myInfo->sums = new uint32_t [planesize];
-        }
-
-        uint32_t pixremaining = planesize + 1;
-        uint32_t * sums = myInfo->sums + planesize;
-        while (--pixremaining)
-        {
-            *--sums = 0;
-        }
-
-        myInfo->frame_count = 0;
-        myInfo->most_recent_frame = -1;
-        myInfo->start_frame = start_frame;
-        myInfo->end_frame = end_frame;
-
-        printf ("ADMVideoComputeAverage: reset average; now %p %ux%u, "
-                "%u..%u\n",
-                myInfo->sums, myInfo->width, myInfo->height,
-                myInfo->start_frame, myInfo->end_frame);
-    }
-			
-    // HERE: for speed, we do luma (Y plane) only.  However, some
-    // users might want chroma, too... we should make that
-    // an option or something.
-
-    uint8_t * currp = YPLANE (image) + planesize;
-    uint8_t * destp = YPLANE (data) + planesize;
-    uint32_t * sums = myInfo->sums + planesize;
-    uint32_t pixremaining = planesize + 1;
-    int32_t bias = _param->bias;
-
-    if (curr_frame >= start_frame && curr_frame <= end_frame
-        && curr_frame != myInfo->most_recent_frame)
-    {
-        uint32_t frame_count = ++(myInfo->frame_count);
-        uint32_t half_frame_count = frame_count / 2;
-        if (debug & 2)
-            printf ("Including frame %u of %u, now have %u (%u - %u)\n",
-                    curr_frame, num_frames, frame_count, start_frame, end_frame);
-
-        if (_param->display_mode == DISPLAYMODE_AVERAGE)
-        {
-            while (--pixremaining)
-            {
-                uint8_t curr = *--currp;
-                uint32_t sum = (*--sums += curr);
-
-                uint32_t avg = (sum + half_frame_count) / frame_count;
-                *--destp = saturate_pixel (avg + bias);
-            }
-        }
-        else if (_param->display_mode == DISPLAYMODE_FRAME_MINUS_AVERAGE)
-        {
-            while (--pixremaining)
-            {
-                uint8_t curr = *--currp;
-                uint32_t sum = (*--sums += curr);
-
-                uint32_t avg = (sum + half_frame_count) / frame_count;
-                *--destp = saturate_pixel (curr + bias - avg);
-            }
-        }
-        else // if (_param->display_mode == DISPLAYMODE_BLANK)
-        {
-            while (--pixremaining)
-            {
-                *--sums += *--currp;
-            }
-        }
-
-        myInfo->most_recent_frame = curr_frame;
-
-        // If we just did the last frame of the specified range, then we need
-        // to write the output file.
-
-        if (curr_frame == end_frame
-            && frame_count == end_frame - start_frame + 1)
-            write_output_file();
-    }
-    else // frame out of specified range for collecting average
-    {
-        uint32_t frame_count = myInfo->frame_count;
-        uint32_t half_frame_count = frame_count / 2;
-        if (debug & 2)
-            printf ("Using %u frame(s) (%u - %u) worth of average on frame %u of %u\n",
-                    frame_count, start_frame, end_frame, curr_frame, num_frames);
-
-        if (frame_count == 0)
-        {
-            // dividing by zero is not a good idea.  Just punt.
-            return 0;
-        }
-        else if (_param->display_mode == DISPLAYMODE_AVERAGE)
-        {
-            while (--pixremaining)
-            {
-                uint32_t sum = *--sums;
-                uint32_t avg = (sum + half_frame_count) / frame_count;
-                *--destp = saturate_pixel (avg + bias);
-            }
-        }
-        else if (_param->display_mode == DISPLAYMODE_FRAME_MINUS_AVERAGE)
-        {
-            while (--pixremaining)
-            {
-                uint8_t curr = *--currp;
-                uint32_t sum = *--sums;
-
-                uint32_t avg = (sum + half_frame_count) / frame_count;
-                *--destp = saturate_pixel (curr + bias - avg);
-            }
-        }
-        else if (curr_frame > end_frame)
-        {
-            // nothing more to do
-            return 0;
-        }
-    }
-
-    if (_param->display_mode != DISPLAYMODE_BLANK)
-    {
-        // HERE: the following two lines do a luma-only-ize
-
-        memset (UPLANE (data), 128, planesize >> 2);
-        memset (VPLANE (data), 128, planesize >> 2);
-    }
-
-    data->copyInfo(image);
-    return 1;
-}
-
-void ADMVideoComputeAverage::write_output_file () const
-{
-    const char * output_file = _param->output_file;
-    if (!output_file || !*output_file)
-    {
-        fprintf (stderr, "ADMVideoComputeAverage: Wanted to write output "
-                 "file, but no file has been specified!!\n");
-        return;
-    }
-
-    FILE * fp = fopen (output_file, "wb");
-    if (!fp)
-    {
-        perror (output_file);
-        return;
-    }
-
-    uint32_t width = myInfo->width;
-    uint32_t height = myInfo->height;
-
-    int pixelcount = width * height;
-    uint32_t * sums = myInfo->sums;
-    uint32_t pixremaining = pixelcount + 1;
-
-    FileHeader header;
-    memcpy (header.magic, "DGCMimgF", sizeof (header.magic));
-    header.width = width;
-    header.height = height;
-
-    int nwritten = fwrite (&header, sizeof (FileHeader), 1, fp);
-    if (nwritten != 1)
-    {
-        fprintf (stderr, "Failed to write file header to %s\n", output_file);
-        perror (output_file);
-        fclose (fp);
-        unlink (output_file);
-        return;
-    }
-
-    uint32_t frame_count = myInfo->frame_count;
-
-    printf ("frame count = %u\n", frame_count);
-
-    float minavg = 1000;
-    float maxavg = -1000;
-    while (--pixremaining)
-    {
-        uint32_t sum = *sums++;
-        float avg = float (sum) / frame_count;
-
-        if (avg < minavg)
-            minavg = avg;
-        if (avg > maxavg)
-            maxavg = avg;
-
-        nwritten = fwrite (&avg, sizeof (float), 1, fp);
-        if (nwritten != 1)
-        {
-            fprintf (stderr, "Failed to write pixel %u to %s\n",
-                     pixelcount - pixremaining + 1, output_file);
-            fflush (stdout);
-            perror (output_file);
-            fclose (fp);
-            unlink (output_file);
-            return;
-        }
-    }
-
-    fprintf (stderr, "Successfully wrote %ux%u = %u floating point pixel "
-             "averages (from %.6f to %.6f) of %u frames to %s\n",
-             width, height, pixelcount, minavg, maxavg, frame_count,
-             output_file);
-
-    fclose (fp);
-}

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidComputeAverage.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidComputeAverage.h	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidComputeAverage.h	2009-10-02 05:22:11 UTC (rev 5365)
@@ -1,129 +0,0 @@
-/***************************************************************************
-                          ADM_vidComputeAverage.h  -  compute average of
-                                                     all frames (so it can
-                                                     later be subtracted to
-                                                     remove static
-                                                     background details)
-                              -------------------
-                          Chris MacGregor, 2005, 2007
-                         chris-avidemux at bouncingdog.com
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
- 
-#ifndef __COMPUTEAVERAGE__
-#define __COMPUTEAVERAGE__   
-
-#include <map>
-
-
-typedef struct COMPUTEAVERAGE_PARAM
-{
-    int32_t start_frame;
-    int32_t end_frame; // -1 means last frame, -2 = last - 1, ...
-    const char * output_file;
-    int32_t bias;
-    uint32_t display_mode;
-
-} COMPUTEAVERAGE_PARAM;
-
-class  ADMVideoComputeAverage : public AVDMGenericVideoStream
-{
-
-    enum DisplayMode
-    {
-        DISPLAYMODE_INVALID = 0,
-        DISPLAYMODE_FRAME_MINUS_AVERAGE,
-        DISPLAYMODE_AVERAGE,
-        DISPLAYMODE_BLANK,
-        DISPLAYMODE_COUNT
-    };
-
- public:
-
-    struct FileHeader
-    {
-        char magic [8]; // "DGCMimg" + (is_float ? "F" : "8")
-        uint32_t width;
-        uint32_t height;
-    };
-        
-
- protected:
-
-     // This is a hack to work around the fact that the ctor & dtor get called
-     // too often.  The right solution would be to arrange for the filter
-     // objects to be constructed and destructed only when really necessary:
-     // when a new instance of a filter is added to the list (by the user), it
-     // is constructed, and when it is removed from the list (by the user), it
-     // is destructed, and anything else is handled by a separate init() or
-     // configure() method.  This would allow the objects to maintain a
-     // persistent state in a more straightforward way.
-
-     class PersistentInfo
-     {
-     public:
-         CONFcouple *  conf;
-         CONFcouple *  oldConf;
-         uint32_t      refCount;
-
-         uint32_t *    sums;
-         uint32_t      frame_count;
-         uint32_t      width;
-         uint32_t      height;
-         uint32_t      start_frame;
-         uint32_t      end_frame;
-         uint32_t      most_recent_frame;
-
-         PersistentInfo ()
-             : conf (0),
-               oldConf (0),
-               refCount (0),
-
-               sums (0),
-               frame_count (0),
-               width (0),
-               height (0),
-               start_frame (0),
-               end_frame (0),
-               most_recent_frame (0)
-         {
-         }
-
-        ~PersistentInfo ()
-        {
-            delete [] sums;
-        }
-     };
-
-     typedef std::map <CONFcouple *, PersistentInfo *> PImap;
-     static PImap pimap;
-
-     PersistentInfo * myInfo;
-
-     COMPUTEAVERAGE_PARAM *  _param;
-
-     void write_output_file () const;
-
- public:
- 		
-     ADMVideoComputeAverage (AVDMGenericVideoStream *in, CONFcouple *setup);
-
-     ~ADMVideoComputeAverage();
-
-     virtual uint8_t getFrameNumberNoAlloc (uint32_t frame, uint32_t *len,
-                                            ADMImage *data, uint32_t *flags);
-
-     virtual uint8_t configure (AVDMGenericVideoStream *instream);
-     virtual char * printConf (void);
-     virtual uint8_t getCoupledConf (CONFcouple **couples);
-							
- };
-#endif

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidDvbSub.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidDvbSub.cpp	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidDvbSub.cpp	2009-10-02 05:22:11 UTC (rev 5365)
@@ -1,447 +0,0 @@
-/***************************************************************************
-                         DVB-T subtitle filter
-    
-    This is a dummy DVB-T Filter and should be only used through OCR
-    The filter exists just for debugging purpose and should not be exposed
-    to end user at all.
-    
-    copyright            : (C) 2007 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-
-
-#include "config.h"
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include "ADM_lavcodec.h"
-#include "ADM_assert.h"
-#include "ADM_default.h"
-#include "ADM_videoFilterDynamic.h"
-#include "fourcc.h"
-
-
-#include "ADM_videoFilter.h"
-#include "ADM_colorspace.h"
-#include "ADM_codecs/ADM_codec.h"
-#include "ADM_vidDvbSub.h"
-static FILTER_PARAM assParam={7,
-        { /* float */ "font_scale",
-          /*float*/ "line_spacing",
-          /* int */ "top_margin",
-          /* int */ "bottom_margin",
-          /* bool */ "extract_embedded_fonts",
-          /* ADM_filename */ "fonts_dir",
-          /* ADM_filename */ "subfile" }};
-
-SCRIPT_CREATE(dvbsub_script,ADMVideoSubDVB,assParam);
-BUILD_CREATE(dvbsub_create,ADMVideoSubDVB);
-
-char *ADMVideoSubDVB::printConf() 
-{
-    ADM_FILTER_DECLARE_CONF(" DVB Subtitle ");
-      
-      
-}
-
-
-uint8_t ADMVideoSubDVB::configure(AVDMGenericVideoStream * instream)
-{
-  
-   return 1;
-}
-//_______________________________________________________________
-
-ADMVideoSubDVB::ADMVideoSubDVB(const char *ts, uint32_t pid,uint32_t w, uint32_t h) 
-{
-        _in=NULL;		
-        memset(&_info,0,sizeof(_info));
-        _info.width=w;
-        _info.height=h;
-        _inited=0;
-        
-      
-        _uncompressed=new ADMImage(getInfo()->width,getInfo()->height);
-        ADM_assert(_uncompressed);
-        _info.encoding=1;
-        
-        decoder=new decoderFFSubs(1);
-        binary=new ADMCompressedImage;
-        binary->data=readBuffer+2;
-        
-        MPEG_TRACK track;
-        track.pid=pid;
-
-        
-        demuxer=new dmx_demuxerTS(1,&track,0,DMX_MPG_TS);
-      
-
-      
-}
-//_______________________________________________________________
-
-ADMVideoSubDVB::ADMVideoSubDVB(AVDMGenericVideoStream *in, CONFcouple *conf) 
-{
-        _in=in;		
-        memcpy(&_info,_in->getInfo(),sizeof(_info));
-        
-        
-      
-        _uncompressed=new ADMImage(_in->getInfo()->width,_in->getInfo()->height);
-        ADM_assert(_uncompressed);
-        _info.encoding=1;
-        
-        decoder=new decoderFFSubs(1);
-        binary=new ADMCompressedImage;
-        binary->data=readBuffer+2;
-        
-        MPEG_TRACK track;
-        track.pid=0x96;
-
-        
-        demuxer=new dmx_demuxerTS(1,&track,0,DMX_MPG_TS);
-        _inited=init(NULL);
-
-      
-}
-// **********************************
-uint8_t ADMVideoSubDVB::init(const char  *tsFileName)
-{
-	// For test only!
-#ifdef ADM_DEBUG
-	if(!tsFileName) tsFileName="/capture/grey/Grey_anatomy_2007_05_22_Avec_Le_Temp.mpg";
-#endif
-    // First create our demuxer
-     
-     if(!demuxer->open(tsFileName))
-     {
-        printf("Cannot open TS\n");
-        return 0; 
-     }
-      memset(&sub,0,sizeof(sub));
-      _inited=1;
-     return 1;
-} 
-
-//*******************************************
-ADMVideoSubDVB::~ADMVideoSubDVB() 
-{
-      if(_uncompressed) DELETE(_uncompressed);
-      if(decoder) delete decoder;
-      if(binary) delete binary;
-      if(demuxer) delete demuxer;
-      decoder=NULL;
-      binary=NULL;
-      demuxer=NULL;
-   
-}
-//*******************************************
-#define _r(c)  ((c)&0xff)
-#define _b(c)  (((c)>>16)&0xFF)
-#define _g(c)  (((c)>>8)&0xFF)
-#define _a(c)  ((c)>>24)
-#define rgba2y(c)  ( (( 263*_r(c)  + 516*_g(c) + 100*_b(c)) >> 10) + 16  )
-#define rgba2u(c)  ( (( 450*_r(c) - 376*_g(c) -  73*_b(c)) >> 10) + 128 )
-#define rgba2v(c)  ( ((-152*_r(c) - 298*_g(c) + 450*_b(c)) >> 10) + 128 )
-
-uint8_t ADMVideoSubDVB::getFrameNumberNoAlloc(uint32_t frame, uint32_t *len, ADMImage *data, uint32_t *flags) 
-{
-uint8_t *org=NULL;
-
-      // Read the original PIC
-        
-        if(!_in->getFrameNumberNoAlloc(frame, len, data, flags))
-                return 0;
-
-        if(!_inited) 
-        {
-          return 0; 
-        }
-        // Read the compressed DVB....
-        
-        uint32_t packetLen,dts,pts;
-          if(!demuxer->readPes(readBuffer,&packetLen, &dts,&pts)) return 1;
-          binary->dataLength=packetLen-3; // -2 for stream iD, -1 for ????
-          if(packetLen<=5) return 1;
-          // And decompress...
-          decoder->uncompress(binary,&sub);
-            
-          // Process All rectangles
-          
-            printf("Found %d rects to process\n",sub.num_rects);
-            for(int i=0;i<sub.num_rects;i++)
-            {
-              AVSubtitleRect *r=&(sub.rects[i]);
-              // First convert RGB to Y+ALPHA
-              for(int col=0;col<r->nb_colors;col++)
-              {
-                    // Color is RGB, convert to YUV
-                    uint32_t y,u,v,a;
-                    uint32_t rgb=r->rgba_palette[col];
-                
-                          y=rgba2y(rgb);
-                          u=rgba2u(rgb)&0xff;
-                          v=rgba2v(rgb)&0xff;
-                          a=_a(rgb);
-                          r->rgba_palette[col]=y+(u<<8)+(v<<16)+(a<<24);
-                          printf("Color %d, alpha %u luma %u rgb:%x\n",col,a,y,rgb);
-              }
-              // Palette is ready, display !
-              if(r->x>_info.width || r->y>_info.height)
-              {
-                  printf("[DVBSUB]Box is outside image\n");
-                  goto _skip;
-              }
-#if 0
-                  printf("x :%d\n",r->x);
-                  printf("y :%d\n",r->y);
-                  printf("w :%d\n",r->w);
-                  printf("h :%d\n",r->h);
-#endif
-                  {
-                      uint32_t clipW,clipH;
-                      
-                      clipW=FFMIN(_info.width,r->x+r->w)-r->x;
-                      clipH=FFMIN(_info.height,r->y+r->h)-r->y;
-                      
-                      ADMImage image(r->w,r->h);
-                      ADMImage imageU(r->w,r->h);
-                      ADMImage imageV(r->w,r->h);
-                      ADMImage alphaImage(r->w,r->h);
-                      
-                      uint8_t *ptr=image.data;
-                      uint8_t *ptrU=imageU.data;
-                      uint8_t *ptrV=imageV.data;
-                      uint8_t *ptrAlpha=alphaImage.data;
-                      uint8_t *in=r->bitmap;
-                      for(int yy=0;yy<r->h;yy++)
-                      {
-                          for(int xx=0;xx<r->w;xx++)
-                          {
-                            uint32_t alpha,valout;
-                            uint32_t val=*in++;
-                            
-                                  val=r->rgba_palette[val];
-                                  
-                                  *ptrAlpha++=(val>>24)&0xff;
-                                  *ptr++=(val&0xff);;
-                                  *ptrU++=(val>>8)&0xff;
-                                  *ptrV++=(val>>16)&0xff;
-                          }
-                      }
-              
-                      // Merge Luma
-                      for(int yy=0;yy<clipH;yy++)
-                      {
-                          org=data->data+(yy+r->y)*_info.width+r->x;
-                          
-                          ptrAlpha=alphaImage.data+yy*r->w;
-                          ptr=image.data+yy*r->w;
-                        
-                          for(int xx=0;xx<clipW;xx++)
-                          {
-                            uint32_t val,before,alpha;
-                            
-                                  before=*org;
-                                  val=*ptr++;
-                                  alpha=*ptrAlpha++;
-                                  
-                                  val=val*alpha+(255-alpha)*before;
-                                  val>>=8;
-                                  *org++=val;
-                          }
-                      }
-                      // Shrink alpha  & u & v
-                     alphaImage.LumaReduceBy2();
-                     imageU.LumaReduceBy2();
-                     imageV.LumaReduceBy2();
-                     r->x>>=1;
-                     r->y>>=1;
-                     r->w>>=1;
-                     r->h>>=1;
-                     clipH>>=1;
-                     clipW>>=1;
-                     
-                     
-                      uint8_t *orgU=(uint8_t *)(UPLANE(data)+(r->y)*(_info.width>>1)+(r->x));
-                      uint8_t *orgV=(uint8_t *)(VPLANE(data)+(r->y)*(_info.width>>1)+(r->x));
-#if 1
-                      // Merge
-                      for(int yy=0;yy<clipH;yy++)
-                      {
-                          ptrAlpha=alphaImage.data+yy*(r->w);
-                          ptrU=imageU.data+yy*r->w;
-                          ptrV=imageV.data+yy*r->w;
-                        
-                          for(int xx=0;xx<clipW;xx++)
-                          {
-                            uint32_t val,valU,valV,before,alpha;
-                            uint32_t newU,newV;
-                                  
-                                  newU=*ptrU++;
-                                  newV=*ptrV++;  // New color
-                                 
-                                   newU=(newU+newV)/2;
-                                   newV=newU;
-                                  
-                                  alpha=*ptrAlpha++;
-                                  
-                                  before=*orgU; // old color
-                                  valU=newU*alpha+(255-alpha)*before;
-                                  
-                                  before=*orgV;
-                                  valV=newV*alpha+(255-alpha)*before;
-                                  
-                                  valU=valU>>8;
-                                  valV=valV>>8;
-                                  
-                                  *orgU++=valU;
-                                  *orgV++=valV;
-                          }
-                      }
-#endif
-              }
-               // Delete palette & data
-_skip:
-               av_free(r->rgba_palette);
-               av_free(r->bitmap);
-            } // Next rec..
-            memset(&sub,0,sizeof(sub));
-        
-        return 1;
-}
-/**
- * \fn 			getNextBitmap
- * \brief 		Decode a bitmap and store the result (luma only) in the caller supplied vobSubBitmap
- * @param data  (in) Vobsubbitmap to put image in
- * @param pts   Raw pts in 90 Khz Tick
- * @return      0 on failure, 1 on success 
- * */
-uint8_t ADMVideoSubDVB::getNextBitmap(vobSubBitmap *data,uint32_t *pts) 
-{
-uint8_t *org=NULL;
-
-        uint32_t packetLen,dts; //,pts;
-        // Clear incoming picture
-        	data->clear();
-        
-          if(!demuxer->readPes(readBuffer,&packetLen, &dts,pts)) return 0;
-          binary->dataLength=packetLen-3; // -2 for stream iD, -1 for ????
-          if(packetLen<=5) return 1;
-          // And decompress...
-          decoder->uncompress(binary,&sub);
-            
-          // Process All rectangles
-          
-            printf("Found %d rects to process\n",sub.num_rects);
-            for(int i=0;i<sub.num_rects;i++)
-            {
-              AVSubtitleRect *r=&(sub.rects[i]);
-              // First convert RGB to Y+ALPHA
-              for(int col=0;col<r->nb_colors;col++)
-              {
-                    // Color is RGB, convert to YUV
-                    uint32_t y,u,v,a;
-                    uint32_t rgb=r->rgba_palette[col];
-                
-                          y=rgba2y(rgb);
-                          u=rgba2u(rgb)&0xff;
-                          v=rgba2v(rgb)&0xff;
-                          a=_a(rgb);
-                          r->rgba_palette[col]=y+(u<<8)+(v<<16)+(a<<24);
-#if 0
-                          printf("Color %d, alpha %u luma %u rgb:%x\n",col,a,y,rgb);
-#endif
-              }
-              // Palette is ready, display !
-              if(r->x>_info.width || r->y>_info.height)
-              {
-                  printf("[DVBSUB]Box is outside image\n");
-                  goto _skipX;
-              }
-#if 0
-                  printf("x :%d\n",r->x);
-                  printf("y :%d\n",r->y);
-                  printf("w :%d\n",r->w);
-                  printf("h :%d\n",r->h);
-#endif
-                  {
-                      uint32_t clipW,clipH;
-                      
-                      clipW=FFMIN(_info.width,r->x+r->w)-r->x;
-                      clipH=FFMIN(_info.height,r->y+r->h)-r->y;
-                      
-                      ADMImage image(r->w,r->h);
-                      ADMImage alphaImage(r->w,r->h);
-                      
-                      uint8_t *ptr=image.data;
-                      uint8_t *ptrAlpha=alphaImage.data;
-                      uint8_t *in=r->bitmap;
-                      for(int yy=0;yy<r->h;yy++)
-                      {
-                          for(int xx=0;xx<r->w;xx++)
-                          {
-                            uint32_t alpha,valout;
-                            uint32_t val=*in++;
-                            
-                                  val=r->rgba_palette[val];
-                                  
-                                  *ptrAlpha++=(val>>24)&0xff;
-                                  *ptr++=(val&0xff);;
-                          }
-                      }
-              
-                      // Merge Luma
-                      
-                      for(int yy=0;yy<clipH;yy++)
-                      {
-                          org=data->_bitmap+(yy+r->y)*_info.width+r->x;
-                          
-                          ptrAlpha=alphaImage.data+yy*r->w;
-                          ptr=image.data+yy*r->w;
-                          int clean=0;
-                          for(int xx=0;xx<clipW;xx++)
-                          {
-                            uint32_t val,before,alpha;
-                            
-                                  //before=*org;
-                                  val=*ptr++;
-                                  alpha=*ptrAlpha++;
-                                  
-                                  val=val*alpha;//+(255-alpha)*before;
-                                  val=val>>8;
-                                  if(val>10) clean=1; // Remove noise
-                                  *org++=val;
-                                  
-                          }
-                          if(clean) data->setDirty(r->y+yy);
-                      }
-                  }
-                   // We dont need chroma here...
-               // Delete palette & data
-_skipX:
-               av_free(r->rgba_palette);
-               av_free(r->bitmap);
-            } // Next rec..
-            memset(&sub,0,sizeof(sub));
-        
-        return 1;
-}
-uint8_t	ADMVideoSubDVB::getCoupledConf(CONFcouple **conf) 
-{
-
-        *conf=new CONFcouple(0);
-        return 1;
-}
-/************************************************/

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidDvbSub.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidDvbSub.h	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidDvbSub.h	2009-10-02 05:22:11 UTC (rev 5365)
@@ -1,53 +0,0 @@
-/***************************************************************************
-                         DVB-T subtitle filter
-    
-    copyright            : (C) 2007 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#ifndef ADM_VIDDVBSUB_H
-#define ADM_VIDDVBSUB_H
-#include "ADM_inputs/ADM_mpegdemuxer/dmx_mpegstartcode.h"
-#include "ADM_inputs/ADM_mpegdemuxer/dmx_demuxerTS.h"
-
-#include "ADM_codecs/ADM_ffmp43.h"
-#include "ADM_videoFilter/ADM_vidVobSubBitmap.h"
-
-
-#define READ_BUFFER_SIZE (64*1024)
-
-class ADMVideoSubDVB : public AVDMGenericVideoStream 
-{
-protected:
-        virtual char* printConf(void);
-       
-       
-        
-        decoderFFSubs *decoder;
-        ADMCompressedImage *binary;
-        dmx_demuxerTS *demuxer;
-        AVSubtitle  sub;
-        uint8_t     readBuffer[READ_BUFFER_SIZE];
-        uint32_t    _inited;
-        
-public:
-        ADMVideoSubDVB(AVDMGenericVideoStream *in, CONFcouple *conf);
-        ADMVideoSubDVB(const char *fileName, uint32_t pid,uint32_t w,uint32_t h);
-        virtual ~ADMVideoSubDVB();
-        virtual uint8_t getFrameNumberNoAlloc(uint32_t frame, uint32_t *len, ADMImage *data,uint32_t *flags);
-        uint8_t configure(AVDMGenericVideoStream *instream);
-        uint8_t	getCoupledConf(CONFcouple **conf);
-        uint8_t getNextBitmap(vobSubBitmap *data,uint32_t *pts);
-        uint8_t init(const char  *tsFileName);
-};
-#endif
-/************************************************/

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidEraser.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidEraser.cpp	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidEraser.cpp	2009-10-02 05:22:11 UTC (rev 5365)
@@ -1,539 +0,0 @@
-/***************************************************************************
-                          ADM_vidEraser.cpp  -  "Erase" arbitrary areas of
-                                                        each frame
-                             -------------------
-                         Chris MacGregor, December 2007
-                         chris-avidemux at bouncingdog.com
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
- 
-#include "ADM_default.h"
-
-#include <ctype.h>
-#include <errno.h>
-#include <math.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-
-#include <iostream>
-#include <fstream>
-#include <iterator>
-
-#include "ADM_assert.h"
-#include "fourcc.h"
-#include "avi_vars.h"
-
-#include "ADM_toolkit/toolkit.hxx"
-#include "ADM_videoFilter.h"
-#include "ADM_encoder/ADM_vidEncode.hxx"
-#include "ADM_encoder/adm_encoder.h"
-
-
-#include "DIA_factory.h"
-
-#include "ADM_vidEraser.h"
-#include "ADM_userInterfaces/ADM_commonUI/DIA_flyDialog.h" // for MenuMapping
-
-using namespace std;
-
-static const int MAX_PIXEL_LUMA = 255;
-
-static FILTER_PARAM eraserParam =
-{
-    5,
-    { "brush_mode", "brush_size", "output_color", "data_file", "debug" // 4
-    }
-};
-
-// This is a hack to work around the fact that the ctor & dtor get called
-// too often.  The right solution would be to arrange for the filter
-// objects to be constructed and destructed only when really necessary:
-// when a new instance of a filter is added to the list (by the user), it
-// is constructed, and when it is removed from the list (by the user), it
-// is destructed, and anything else is handled by a separate init() or
-// configure() method.  This would allow the objects to maintain a
-// persistent state in a more straightforward way.
-
-ADMVideoEraser::PImap ADMVideoEraser::pimap;
-
-
-SCRIPT_CREATE(eraser_script,ADMVideoEraser,eraserParam);
-
-BUILD_CREATE(eraser_create,ADMVideoEraser);
-
-ADMVideoEraser::ADMVideoEraser (AVDMGenericVideoStream *in, CONFcouple *couples)
-{
-    _in = in;
-    memcpy (&_info, in->getInfo(), sizeof(_info));
-    _info.encoding = 1;
-    _uncompressed = new ADMImage (_in->getInfo()->width, _in->getInfo()->height);
-    ADM_assert (_uncompressed);
-    _param = new ERASER_PARAM;
-
-    if (couples)
-    {
-        GET(brush_mode);
-        GET(brush_size);
-        GET(output_color);
-        char * tmp;
-        GET2(data_file, tmp);
-        GET(debug);
-    }
-    else
-    {
-        _param->brush_mode = 1; // erase
-        _param->brush_size = 1; // 3x3
-        _param->output_color = 0;
-        // _param->data_file = ""; // implicit
-        _param->debug = 0;
-    }
-
-    // This is a hack to work around the fact that the ctor & dtor get called
-    // too often.  The right solution would be to arrange for the filter
-    // objects to be constructed and destructed only when really necessary:
-    // when a new instance of a filter is added to the list (by the user), it
-    // is constructed, and when it is removed from the list (by the user), it
-    // is destructed, and anything else is handled by a separate init() or
-    // configure() method.  This would allow the objects to maintain a
-    // persistent state in a more straightforward way.
-
-    // This explicit check wouldn't be necessary if there was an easier way of
-    // ensuring that we got a 0 pointer when a new map entry was auto-consed
-    // up...
-
-    if (pimap.count (couples) == 0)
-    {
-        myInfo = new PersistentInfo;
-        myInfo->conf = couples;
-        pimap [couples] = myInfo;
-    }
-    else
-    {
-        myInfo = pimap [couples];
-        if (couples)
-        {
-            if (myInfo->oldConf == couples)
-            {
-                pimap.erase (myInfo->conf);
-                myInfo->conf = myInfo->oldConf;
-                myInfo->oldConf = 0;
-            }
-            else
-            {
-                ADM_assert (myInfo->conf == couples);
-
-                if (myInfo->oldConf)
-                {
-                    pimap.erase (myInfo->oldConf);
-                    myInfo->oldConf = 0;
-                }
-            }
-        }
-    }
-
-    myInfo->refCount++;
-
-    printf ("ADMVideoEraser ctor (%p, conf = %p), pi = %p, rc now %d\n",
-            this, couples, myInfo, myInfo->refCount);
-}
-
-uint8_t	ADMVideoEraser::getCoupledConf (CONFcouple **couples)
-{
-
-    ADM_assert (_param);
-    *couples = new CONFcouple (eraserParam.nb);
-
-    // This is a hack to work around the fact that the ctor & dtor get called
-    // too often.  The right solution would be to arrange for the filter
-    // objects to be constructed and destructed only when really necessary:
-    // when a new instance of a filter is added to the list (by the user), it
-    // is constructed, and when it is removed from the list (by the user), it
-    // is destructed, and anything else is handled by a separate init() or
-    // configure() method.  This would allow the objects to maintain a
-    // persistent state in a more straightforward way.
-
-    printf ("ADMVideoEraser::getCoupledConf(): this = %p, couples = %p, "
-            "oldConf = %p (was %p), pi = %p\n",
-            this, *couples, myInfo->conf, myInfo->oldConf, myInfo);
-
-    if (myInfo->oldConf)
-        pimap.erase (myInfo->oldConf);
-    myInfo->oldConf = myInfo->conf;
-    myInfo->conf = *couples;
-    pimap [myInfo->conf] = myInfo;
-    if (myInfo->oldConf == 0)
-        pimap.erase (0);
-
-    CSET(brush_mode);
-    CSET(brush_size);
-    CSET(output_color);
-    (*couples)->setCouple("data_file", _param->data_file.c_str());
-    CSET(debug);
-
-    return 1;
-}
-
-uint8_t ADMVideoEraser::configure (AVDMGenericVideoStream *in)
-{
-    diaMenuEntry tBrushMode [] = {
-        { 1, QT_TR_NOOP("Erase"), NULL },
-        { 0, QT_TR_NOOP("Un-Erase"), NULL },
-    };
-
-    diaMenuEntry tBrushSize [] = {
-        { 0, QT_TR_NOOP("1x1"), NULL },
-        { 1, QT_TR_NOOP("3x3"), NULL },
-        { 2, QT_TR_NOOP("5x5"), NULL },
-        { 3, QT_TR_NOOP("7x7"), NULL },
-        { 4, QT_TR_NOOP("9x9"), NULL },
-        { 5, QT_TR_NOOP("11x11"), NULL },
-        { 7, QT_TR_NOOP("15x15"), NULL },
-        { 10, QT_TR_NOOP("21x21"), NULL },
-    };
-
-    diaElemMenu brush_mode
-        (&(_param->brush_mode), QT_TR_NOOP("Brush _Mode:"),
-         sizeof (tBrushMode) / sizeof (diaMenuEntry), tBrushMode);
-
-    diaElemMenu brush_size
-        (&(_param->brush_size), QT_TR_NOOP("Brush _Size:"),
-         sizeof (tBrushSize) / sizeof (diaMenuEntry), tBrushSize);
-
-    MenuMapping menu_mapping [] = {
-        { "brushModeMenu", my_offsetof (ERASER_PARAM, brush_mode),
-          sizeof (tBrushMode) / sizeof (diaMenuEntry), tBrushMode },
-        { "brushSizeMenu", my_offsetof (ERASER_PARAM, brush_size),
-          sizeof (tBrushSize) / sizeof (diaMenuEntry), tBrushSize },
-    };
-
-    if (myInfo->masks.empty() || myInfo->mask_data_invalid)
-        readDataFile (_info.width);
-
-    // printf ("ADM_vidEraser: _param = %p\n", _param);
-    uint8_t ret = DIA_eraser (_in, this, _param, menu_mapping,
-                              sizeof (menu_mapping) / sizeof (MenuMapping));
-    if (ret == 1)
-    {
-        writeDataFile();
-        return ret;
-    }
-    else if (ret == 0) // 0 = cancel
-    {
-        myInfo->mask_data_invalid = true;
-        return ret;
-    }
-    else
-    {
-        ADM_assert (ret == 255); // 255 = whizzy dialog not implemented
-    }
-
-    diaElemUSlider output_color
-        (&(_param->output_color),
-         QT_TR_NOOP("Output \"_Color\" for all masked pixels:"), 0, 255);
-
-    char * file = ADM_strdup (_param->data_file.c_str());
-
-    diaElemFile data_file
-        (0, &file,
-         QT_TR_NOOP("Eraser _Data File:"), 0, QT_TR_NOOP("Select data file"));
-
-    // TODO: The configuration of the masks is not implemented!!!
-
-    diaElemUInteger debug
-        (&(_param->debug), QT_TR_NOOP("_Debugging settings (bits):"),
-         0, 0x7fffffff);
-
-    diaElem * elems[] = { &brush_mode, &brush_size, &output_color,
-                          &data_file, &debug };
-
-    ret = diaFactoryRun (QT_TR_NOOP("Eraser Configuration"),
-                         sizeof (elems) / sizeof (diaElem *), elems);
-    if (ret) // 0 = cancel
-    {
-        writeDataFile();
-        myInfo->mask_data_invalid = true;
-    }
-
-    _param->data_file = file;
-    delete[] file;
-
-    return ret;
-}
-
-ADMVideoEraser::~ADMVideoEraser()
-{
-    // This is a hack to work around the fact that the ctor & dtor get called
-    // too often.  The right solution would be to arrange for the filter
-    // objects to be constructed and destructed only when really necessary:
-    // when a new instance of a filter is added to the list (by the user), it
-    // is constructed, and when it is removed from the list (by the user), it
-    // is destructed, and anything else is handled by a separate init() or
-    // configure() method.  This would allow the objects to maintain a
-    // persistent state in a more straightforward way.
-
-    myInfo->refCount--;
-    printf ("ADMVideoEraser dtor (%p), conf = %p, pi = %p, rc now %d\n",
-            this, myInfo->conf, myInfo, myInfo->refCount);
-
-    if (myInfo->oldConf)
-    {
-        pimap.erase (myInfo->oldConf);
-        myInfo->oldConf = 0;
-    }
-
-    if (myInfo->refCount < 1)
-    {
-        pimap.erase (myInfo->conf);
-        delete myInfo;
-    }
-
-    DELETE (_param);
-    delete _uncompressed;
-    _uncompressed = NULL;
-}
-
-char * ADMVideoEraser::printConf ()
-{
-    const int CONF_LEN = 1024;
-    static char conf[CONF_LEN];
-
-    const char * data_file = _param->data_file.c_str();
-    if (!data_file || !*data_file)
-        data_file = "**** no file selected ****";
-
-    char * cptr = conf;
-    cptr += snprintf (conf, CONF_LEN, "Eraser: erase to %d, data in %s",
-                      _param->output_color, data_file);
-
-    if (_param->debug)
-        cptr += snprintf (cptr, CONF_LEN - (cptr - conf),
-                          ", debug = 0x%x", _param->debug);
-    return conf;
-}
-
-void ADMVideoEraser::writeDataFile () const
-{
-    const char * filename = _param->data_file.c_str();
-    ofstream outputStream (filename);
-    if (!outputStream)
-    {
-        perror (filename);
-        fprintf (stderr, "******** FAILED to write eraser data to %s (%d)\n",
-                 filename, errno);
-        return;
-    }
-
-    Eraser::MaskVec & masks = myInfo->masks;
-
-    outputStream << "# avidemux Eraser video filter data\n"
-                 << "version: 1"
-                 << "\ndimensions: " << _info.width << " " << _info.height
-                 << "\nmaskcount: " << masks.size()
-                 << "\n";
-
-    for (Eraser::MaskVec::const_iterator maskit = masks.begin();
-         maskit != masks.end();
-         ++maskit)
-    {
-        const Eraser::Mask & mask = *maskit;
-        const Eraser::LineVec & lines = mask.lines;
-        outputStream << "\nmask: " << mask.first_frame << " "
-                     << mask.last_frame << " " << lines.size() << "\n";
-
-        for (Eraser::LineVec::const_iterator lineit = lines.begin();
-             lineit != lines.end();
-             ++lineit)
-        {
-            outputStream << lineit->x << " " << lineit->y << " "
-                         << lineit->count << "\n";
-        }
-    }
-
-    outputStream << "\nend\n";
-}
-
-uint8_t ADMVideoEraser::readDataFile (uint32_t width)
-{
-    Eraser::MaskVec & masks = myInfo->masks;
-
-//    uint32_t & mask_w = myInfo->mask_w;
-//    uint32_t & mask_h = myInfo->mask_h;
-
-    const char * filename = _param->data_file.c_str();
-    if (filename[0] == '\0')
-    {
-        fprintf (stderr, "Eraser: no input file selected!\n");
-        return 0;
-    }
-
-//    mask_w = 0;
-//    mask_h = 0;
-
-    ifstream inputStream (filename);
-    if (!inputStream)
-    {
-        fprintf (stderr, "Eraser: can't open input file %s, "
-                 "but it apparently does exist...(%d)\n",
-                 filename, errno);
-        return 0;
-    }
-
-    masks.clear();
-    string buffer;
-
-    while (inputStream)
-    {
-        inputStream >> buffer;
-        if (buffer [0] == '#')
-        {
-            // toss rest of line
-            inputStream.ignore (1000000,'\n');
-        }
-        else if (buffer == "mask:")
-        {
-            uint32_t first_frame, last_frame, linecount;
-            inputStream >> first_frame >> last_frame >> linecount;
-            masks.push_back (Eraser::Mask (first_frame, last_frame));
-            Eraser::MaskVec::iterator maskit = masks.end() - 1;
-            Eraser::LineVec & lines = maskit->lines;
-            lines.reserve (linecount);
-            while (linecount--)
-            {
-                uint16_t x, y, count;
-                inputStream >> x >> y >> count;
-                if (count == 0)
-                {
-                    fprintf (stderr, "%s: bad count (x = %d, y = %d)\n",
-                             filename, x, y);
-                    return 0;
-                }
-                lines.push_back (Eraser::Line (x, y, count));
-            }
-            printf ("mask %d: %d lines\n", masks.size() - 1, lines.size());
-        }
-        else if (buffer == "maskcount:")
-        {
-            uint32_t count;
-            inputStream >> count;
-            masks.reserve (count);
-        }
-        else if (buffer == "version:")
-        {
-            int version;
-            inputStream >> version;
-            if (version != 1)
-            {
-                fprintf (stderr, "%s: unsupported version: %d\n",
-                         filename, version);
-                return 0;
-            }
-        }
-        else if (buffer == "dimensions:")
-        {
-            int dummy;
-            inputStream >> dummy; // width
-            inputStream >> dummy; // height
-        }
-        else if (buffer != "end")
-        {
-            fprintf (stderr, "%s: unrecognized gunk: \"%s\"\n",
-                     filename, buffer.c_str());
-            return 0;
-        }
-    }
-
-    myInfo->mask_data_invalid = false;
-    return 1;
-}
-
-//============================================================================
-
-uint8_t ADMVideoEraser::getFrameNumberNoAlloc (uint32_t frame, uint32_t *len,
-                                               ADMImage *data, uint32_t *flags)
-{
-    if (frame >= _info.nb_frames)
-        return 0;
-
-    if (_param->debug & 1)
-        printf ("in ADMVideoEraser::getFrameNumberNoAlloc(%d, ...)\n", frame);
-
-    if (!_in->getFrameNumberNoAlloc (frame, len, _uncompressed, flags))
-        return 0;
-
-    if (myInfo->masks.empty() || myInfo->mask_data_invalid)
-        readDataFile (_info.width);
-
-    uint32_t planesize = _info.width * _info.height;
-    uint32_t size = (planesize * 3) >> 1;
-    *len = size;
-
-    uint32_t real_frame = frame + _info.orgFrame;
-    uint8_t ret = doEraser (_uncompressed, data, _in, real_frame,
-                            this, _param, _info.width, _info.height);
-    return ret;
-}
-
-uint8_t
-ADMVideoEraser::doEraser (ADMImage * image, ADMImage * data,
-                          AVDMGenericVideoStream * in,
-                          uint32_t real_frame,
-                          ADMVideoEraser * eraser, ERASER_PARAM * param,
-                          uint32_t width, uint32_t height)
-{
-    PersistentInfo * myInfo = eraser->myInfo;
-    uint32_t debug = param->debug;
-
-    Eraser::MaskVec & masks = myInfo->masks;
-    uint32_t planesize = width * height;
-    uint8_t * outPixels = YPLANE (data);
-
-    memcpy (outPixels, YPLANE (image), planesize);
-
-    // HERE: for better performance, especially with more than a small number
-    // of masks, figure out how to use lower_bound() or some other binary
-    // search type of thing (write our own if necessary to handle comparing an
-    // int to an Eraser::Mask) to find the mask whose range includes
-    // real_frame, rather than linear searching on every frame.
-
-    for (Eraser::MaskVec::const_iterator maskit = masks.begin();
-         maskit != masks.end();
-         ++maskit)
-    {
-        const Eraser::Mask & mask = *maskit;
-
-        if (real_frame < mask.first_frame)
-            break; // they're sorted, so no more will match
-
-        if (real_frame > mask.last_frame)
-            continue;
-
-        const Eraser::LineVec & lines = mask.lines;
-        for (Eraser::LineVec::const_iterator lineit = lines.begin();
-             lineit != lines.end();
-             ++lineit)
-        {
-            memset (outPixels + (lineit->y * width) + lineit->x,
-                    param->output_color, lineit->count);
-        }
-
-        break; // only one can match any given frame number, since they can't
-               // overlap.
-    }
-
-    // HERE: the following two lines do a luma-only-ize
-
-    memset (UPLANE (data), 128, planesize >> 2);
-    memset (VPLANE (data), 128, planesize >> 2);
-
-    data->copyInfo (image);
-
-    return 1;
-}	                           

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidEraser.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidEraser.h	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidEraser.h	2009-10-02 05:22:11 UTC (rev 5365)
@@ -1,202 +0,0 @@
-/***************************************************************************
-                          ADM_vidEraser.h  -  "Erase" arbitrary areas of
-                                                      each frame
-                             -------------------
-                         Chris MacGregor, December 2007
-                         chris-avidemux at bouncingdog.com
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
- 
-#ifndef __ERASER__
-#define __ERASER__   
-
-#include <map>
-
-
-#include <vector>
-#include <string>
-
-#include <sys/time.h>
-
-struct ERASER_PARAM
-{
-    uint32_t brush_mode; // 0 = un-erase, 1 = erase
-    uint32_t brush_size; // NxN where N = brush_size * 2 + 1
-    uint32_t output_color; // 0 - 255
-    std::string data_file;
-    uint32_t debug;
-};
-
-// Alas, because offsetof() is only supposed to work on POD (plain old data)
-// structs, and our ERASER_PARAM includes a std::string (which has a
-// constructor, and which causes ERASER_PARAM to therefore have an implicit
-// constructor), we need to define our own offsetof() to use for the dialog
-// menus.  See
-// http://www.cplusplus.com/reference/clibrary/cstddef/offsetof.html for more
-// on offsetof().
-
-#define my_offsetof(_type, _memb) (size_t (&(((_type *)1)->_memb)) - 1)
-
-namespace Eraser
-{
-    // The mask for a range of frames is represented as a list (vector) of
-    // lines, where each line is a horizontal line of pixels.  Thus, each Line
-    // has a y coordinate, and a range of x coordinates (represented as the
-    // leftmost x coordinate and a count of pixels).  The list of lines is
-    // kept sorted by y and then by x, to make it more efficient to merge in
-    // new pixels or find ones to remove while maintaining the most compact
-    // (and thus most efficient to apply to an image) representation.
-
-    struct Line
-    {
-        uint16_t x;
-        uint16_t y;
-        uint16_t count;
-
-        Line ()
-            : x(), y(), count()
-        {
-        }
-
-        Line (uint16_t x, uint16_t y, uint16_t count)
-            : x (x), y (y), count (count)
-        {
-        }
-    };
-
-    typedef std::vector <Line> LineVec;
-
-    struct Mask
-    {
-        uint32_t first_frame;
-        uint32_t last_frame;
-        LineVec lines;
-
-        Mask (uint32_t first_frame, uint32_t last_frame)
-            : first_frame (first_frame),
-              last_frame (last_frame)
-        {
-        }
-
-        Mask (uint32_t first_frame, uint32_t last_frame,
-              const LineVec & lines)
-            : first_frame (first_frame),
-              last_frame (last_frame),
-              lines (lines)
-        {
-        }
-    };
-
-    typedef std::vector <Mask> MaskVec;
-}
-
-class ADMVideoEraser : public AVDMGenericVideoStream
-{
-protected:
-    	
-    // This is a hack to work around the fact that the ctor & dtor get called
-    // too often.  The right solution would be to arrange for the filter
-    // objects to be constructed and destructed only when really necessary:
-    // when a new instance of a filter is added to the list (by the user), it
-    // is constructed, and when it is removed from the list (by the user), it
-    // is destructed, and anything else is handled by a separate init() or
-    // configure() method.  This would allow the objects to maintain a
-    // persistent state in a more straightforward way.
-
-    class PersistentInfo
-    {
-    public:
-        CONFcouple *  conf;
-        CONFcouple *  oldConf;
-        uint32_t      refCount;
-
-//        uint32_t      mask_w;
-//        uint32_t      mask_h;
-
-//        std::string   data_file_name;
-//        time_t        data_file_mtime;
-
-        Eraser::MaskVec masks;
-
-        bool          mask_data_invalid;
-
-        PersistentInfo ()
-            : conf (0),
-              oldConf (0),
-              refCount (0),
-
-//              mask_w (0),
-//              mask_h (0),
-
-//              data_file_mtime (0),
-              mask_data_invalid (true)
-        {
-        }
-    };
-
-    typedef std::map <CONFcouple *, PersistentInfo *> PImap;
-    static PImap pimap;
-
-    PersistentInfo * myInfo;
-
-    ERASER_PARAM * _param;
-
-public:
-
-    ADMVideoEraser (AVDMGenericVideoStream * in, CONFcouple * setup);
-    ~ADMVideoEraser();
-
-    virtual uint8_t getFrameNumberNoAlloc (uint32_t frame, uint32_t * len,
-                                           ADMImage * data, uint32_t * flags);
-
-    virtual uint8_t configure (AVDMGenericVideoStream * instream);
-    virtual char * printConf (void);
-    virtual uint8_t getCoupledConf (CONFcouple ** couples);
-
-    static uint8_t doEraser (ADMImage * from_image,
-                             ADMImage * to_image,
-                             AVDMGenericVideoStream * in,
-                             uint32_t real_frame,
-                             ADMVideoEraser * eraserp,
-                             ERASER_PARAM * param,
-                             uint32_t width, uint32_t height);
-
-    Eraser::MaskVec & getMasks ()
-    {
-        return myInfo->masks;
-    }
-
-    void masksIsValid (bool valid)
-    {
-        myInfo->mask_data_invalid = !valid;
-    }
-
-protected:
-
-    uint8_t readDataFile (uint32_t width);
-    void writeDataFile () const;
-
-private:
-
-    const ADV_Info & getInfo () const
-    {
-        return _info;
-    }
-};
-
-struct MenuMapping;
-uint8_t DIA_eraser (AVDMGenericVideoStream * in,
-                    ADMVideoEraser * eraserp,
-                    ERASER_PARAM * param,
-                    const MenuMapping * menu_mapping,
-                    uint32_t menu_mapping_count);
-
-#endif

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidNumber.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidNumber.cpp	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidNumber.cpp	2009-10-02 05:22:11 UTC (rev 5365)
@@ -1,76 +0,0 @@
-/***************************************************************************
-                          ADM_vidNumber.cpp  -  Add frame number 
-                             -------------------
-
-    copyright            : (C) 2008 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include "ADM_default.h"
-#include "ADM_videoFilter.h"
-#include "ADM_videoFilterDynamic.h"
-
-static FILTER_PARAM flipParam={0,{""}};
-
- class  ADMVideoNumber:public AVDMGenericVideoStream
- {
-
- protected:
-    		AVDMGenericVideoStream 	*_in;    	
-           virtual char 									*printConf(void);
-          
- public:
- 		
-  					ADMVideoNumber(  AVDMGenericVideoStream *in,CONFcouple *setup);
-  					virtual ~ADMVideoNumber();
-		          virtual uint8_t getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-          																	ADMImage *data,uint32_t *flags);
-					virtual uint8_t configure( AVDMGenericVideoStream *instream) { UNUSED_ARG(instream); return 1;};          																	
-
-
- }     ;
-SCRIPT_CREATE(number_script,ADMVideoNumber,flipParam);
-BUILD_CREATE(number_create,ADMVideoNumber);
- 
-
-char *ADMVideoNumber::printConf( void )
-{
-    ADM_FILTER_DECLARE_CONF(" Add Frame Number");
-        
-}
-
-ADMVideoNumber::ADMVideoNumber(  AVDMGenericVideoStream *in,CONFcouple *setup)
-{
-    UNUSED_ARG(setup);
- 	_in=in;		
-   	memcpy(&_info,_in->getInfo(),sizeof(_info)); 	
-  	_info.encoding=1;	
-}
-ADMVideoNumber::~ADMVideoNumber()
-{
-  
-}
-uint8_t ADMVideoNumber::getFrameNumberNoAlloc(uint32_t frame,
-				uint32_t *len,
-   				ADMImage *data,
-				uint32_t *flags)
-{
-
-	if(frame>= _info.nb_frames) return 0;
-	// read uncompressed frame
-	if(!_in->getFrameNumberNoAlloc(frame, len,data,flags)) return 0;
-    char f[50];
-    snprintf(f,49,"%08u",frame);
-    drawString(data, 2, 2, f); 
-        
-	return 1;
-}

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidParticle.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidParticle.cpp	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidParticle.cpp	2009-10-02 05:22:11 UTC (rev 5365)
@@ -1,1462 +0,0 @@
-/***************************************************************************
-                          ADM_vidParticle.cpp  -  detect particles (groups
-                                                     of pixels)
-                              -------------------
-                          Chris MacGregor, 2005, 2007
-                         chris-avidemux at bouncingdog.com
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
- 
-#include <math.h>
-#include <algorithm>
-#include <string>
-#include <ctype.h>
-
-using namespace std;
-
-#include "ADM_default.h"
-
-#undef memcpy   // avoid compile errors due to macro
-#include "fourcc.h"
-
-#include "ADM_toolkit/toolkit.hxx"
-#include "ADM_videoFilter.h"
-
-#include "ADM_encoder/ADM_vidEncode.hxx"
-#include "ADM_encoder/adm_encoder.h"
-
-#include "ADM_filter/video_filters.h"
-
-#include "DIA_factory.h"
-
-#include "ADM_vidParticle.h"
-#include "ADM_userInterfaces/ADM_commonUI/DIA_flyDialog.h" // for MenuMapping
-
-FILE * ADMVideoParticle::outfp = 0;
-uint32_t ADMVideoParticle::last_frame_written = 0xffffffff;
-
-static FILTER_PARAM particleParam =
-{
-    10,
-    { "min_area", "max_area", "left_crop", "right_crop",          // 4
-      "top_crop", "bottom_crop", "output_format", "output_file",  // + 4 = 8
-//      "camera_number", "min_dim_pctile", "max_dim_pctile", "debug" // + 4 = 12
-      "camera_number", "debug" // + 2 = 10
-    }
-};
-
-SCRIPT_CREATE(particle_script,ADMVideoParticle,particleParam);
-
-BUILD_CREATE(particle_create,ADMVideoParticle);
-
-ADMVideoParticle::ADMVideoParticle (AVDMGenericVideoStream *in, CONFcouple *couples)
-{
-    printf ("ADMVideoParticle ctor (%p)\n", this);
-    _in = in;
-    memcpy(&_info, in->getInfo(), sizeof(_info));
-    _info.encoding = 1;
-    _uncompressed = new ADMImage(_in->getInfo()->width, _in->getInfo()->height);
-    ADM_assert(_uncompressed);
-    _param = new PARTICLE_PARAM;
-
-    if (couples)
-    {
-        GET(min_area);
-        GET(max_area);
-        GET(left_crop);
-        GET(right_crop);
-        GET(top_crop);
-        GET(bottom_crop);
-        GET(output_format);
-
-	char* tmp;
-        GET2(output_file, tmp);
-        GET(camera_number);
-//        GET(min_dim_pctile);
-//        GET(max_dim_pctile);
-        GET(debug);
-    }
-    else
-    {
-        _param->min_area = 5;
-        _param->max_area = 50000;
-        _param->left_crop = 0;
-        _param->right_crop = 0;
-        _param->top_crop = 0;
-        _param->bottom_crop = 0;
-        _param->output_format = OUTPUTFMT_FORMAT_NEW;
-        // _param->output_file = ""; // implicit
-        _param->camera_number = 1;
-//        _param->min_dim_pctile = 0;
-//        _param->max_dim_pctile = 100;
-        _param->debug = 0;
-    }
-}
-
-uint8_t	ADMVideoParticle::getCoupledConf (CONFcouple **couples)
-{
-
-    ADM_assert(_param);
-    *couples = new CONFcouple(particleParam.nb);
-
-    CSET(min_area);
-    CSET(max_area);
-    CSET(left_crop);
-    CSET(right_crop);
-    CSET(top_crop);
-    CSET(bottom_crop);
-    CSET(output_format);
-	(*couples)->setCouple("output_file", _param->output_file.c_str());
-    CSET(camera_number);
-//    CSET(min_dim_pctile);
-//    CSET(max_dim_pctile);
-    CSET(debug);
-
-    return 1;
-
-}
-
-uint8_t ADMVideoParticle::configure (AVDMGenericVideoStream *in)
-{
-    diaMenuEntry tOutputFmt [] = {
-        { OUTPUTFMT_FORMAT_NEW,
-          QT_TR_NOOP("New format, preferred, good for Tracker3D"), NULL },
-        { OUTPUTFMT_FORMAT_DG_UWA,
-          QT_TR_NOOP("DG at UWA format (includes shape info & bounding box)"), NULL },
-        { OUTPUTFMT_FORMAT_AB_ODU,
-          QT_TR_NOOP("AB at ODU format (includes shape info)"), NULL },
-        { OUTPUTFMT_FORMAT_OLD,
-          QT_TR_NOOP("Old format that Tracker3D can't read directly"), NULL },
-    };
-
-    diaElemMenu output_format
-        (&(_param->output_format), QT_TR_NOOP("Output _Format:"),
-         sizeof (tOutputFmt) / sizeof (diaMenuEntry), tOutputFmt);
-
-    MenuMapping menu_mapping [] = {
-        { "outputFormatMenu", my_offsetof (PARTICLE_PARAM, output_format),
-          sizeof (tOutputFmt) / sizeof (diaMenuEntry), tOutputFmt },
-    };
-
-    uint8_t ret = DIA_particle (_in, this, _param, menu_mapping,
-                                sizeof (menu_mapping) / sizeof (MenuMapping));
-    if (ret == 1)
-    {
-        return ret;
-    }
-    else if (ret == 0) // 0 = cancel
-    {
-        return ret;
-    }
-    else
-    {
-        ADM_assert (ret == 255); // 255 = whizzy dialog not implemented
-    }
-
-    diaElemUInteger min_area
-        (&(_param->min_area),
-         QT_TR_NOOP("Mi_nimum area for a particle to be detected:"), 1, 0x7fffffff);
-    diaElemUInteger max_area
-        (&(_param->max_area),
-         QT_TR_NOOP("Ma_ximum area for a particle to be detected:"), 1, 0x7fffffff);
-
-    diaElemUInteger left_crop
-        (&(_param->left_crop),
-         QT_TR_NOOP("_Left side crop (ignore particles in):"), 0, 0x7fffffff);
-    diaElemUInteger right_crop
-        (&(_param->right_crop),
-         QT_TR_NOOP("_Right side crop (ignore particles in):"), 0, 0x7fffffff);
-    diaElemUInteger top_crop
-        (&(_param->top_crop),
-         QT_TR_NOOP("_Top crop (ignore particles in):"), 0, 0x7fffffff);
-    diaElemUInteger bottom_crop
-        (&(_param->bottom_crop),
-         QT_TR_NOOP("_Bottom crop (ignore particles in):"), 0, 0x7fffffff);
-
-	char* file = ADM_strdup(_param->output_file.c_str());
-
-    diaElemFile output_file
-        (1, &file, QT_TR_NOOP("_Output File:"), NULL, QT_TR_NOOP("Select file"));
-
-    diaElemUInteger camera_number
-        (&(_param->camera_number), QT_TR_NOOP("_Camera number:"), 1, 0x7fffffff);
-
-    diaElemUInteger debug(&(_param->debug), QT_TR_NOOP("_Debugging settings (bits):"),
-                          0, 0x7fffffff);
-
-    diaElem * elems[] = { &min_area, &max_area, &left_crop, &right_crop,
-                          &top_crop, &bottom_crop, &output_format,
-                          &output_file, &camera_number, &debug };
-
-    ret = diaFactoryRun ("Particle Detection Configuration",
-                         sizeof (elems) / sizeof (diaElem *), elems);
-
-	_param->output_file = file;
-	delete[] file;
-
-    return ret;
-}
-
-ADMVideoParticle::~ADMVideoParticle()
-{
-    printf ("ADMVideoParticle dtor (%p)\n", this);
-    DELETE(_param);
-    delete _uncompressed;
-    _uncompressed = NULL;
-}
-
-char *ADMVideoParticle::printConf (void)
-{
-    const int CONF_LEN = 1024;
-    static char conf[CONF_LEN];
-
-    char * cptr = conf;
-
-    cptr += snprintf (conf, CONF_LEN, "ParticleList: Area=%u..%u",
-                      _param->min_area, _param->max_area);
-
-    if (_param->left_crop || _param->right_crop || _param->top_crop
-        || _param->bottom_crop)
-    {
-        cptr += snprintf (cptr, CONF_LEN - (cptr - conf),
-                          ", Crop (L/R/T/B): %u/%u/%u/%u",
-                          _param->left_crop, _param->right_crop,
-                          _param->top_crop, _param->bottom_crop);
-    }
-
-    if (!_param->output_file.empty())
-    {
-        cptr += snprintf (cptr, CONF_LEN - (cptr - conf), ", %s Output to %s",
-                          _param->output_format == OUTPUTFMT_FORMAT_OLD
-                          ? "Old" : "New", _param->output_file.c_str());
-    }
-
-    cptr += snprintf (cptr, CONF_LEN - (cptr - conf), ", Camera # %u",
-                      _param->camera_number);
-
-    if (_param->debug)
-        cptr += snprintf (cptr, CONF_LEN - (cptr - conf),
-                          ", debug=0x%x", _param->debug);
-
-    return conf;
-}
-
-uint8_t ADMVideoParticle::getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-                                                ADMImage *data, uint32_t *flags)
-{
-    if (frame >= _info.nb_frames)
-        return 0;
-
-    if (_param->debug & (0x01 << ImageTool::SHIFT_PAST_SHOW_FLAGS))
-        printf ("in ADMVideoParticle::getFrameNumberNoAlloc(%d, ...)\n", frame);
-
-    if (!_in->getFrameNumberNoAlloc (frame, len, _uncompressed, flags))
-        return 0;
-
-    uint32_t planesize = _info.width * _info.height;
-    uint32_t size = (planesize * 3) >> 1;
-    *len = size;
-
-    uint32_t real_frame = frame + _info.orgFrame;
-    OutputFmt outfmt = static_cast <OutputFmt> (_param->output_format);
-
-    if (!outfp && real_frame == 0 && !_param->output_file.empty())
-    {
-        printf ("Starting to write particle list to %s\n",
-                _param->output_file.c_str());
-
-        outfp = fopen (_param->output_file.c_str(), "w");
-        if (!outfp)
-        {
-            perror (_param->output_file.c_str());
-        }
-        else if (real_frame == 0) // ick
-        {
-            switch (outfmt)
-            {
-            case OUTPUTFMT_FORMAT_OLD:
-                fprintf (outfp, "%% Particle  Area  X  Y  Frame\n");
-                break;
-
-            case OUTPUTFMT_FORMAT_NEW:
-                fprintf (outfp, "%% Frame  Camera  X  Y  Area  Particle\n");
-                break;
-
-            case OUTPUTFMT_FORMAT_DG_UWA:
-                fprintf (outfp,
-                         "%% Frame #, Camera #, X, Y, Area, Particle #, "
-                         "Bounding Box Width, Bounding Box Height, "
-                         "Min Dim, Max Dim, Min Dim Angle, Max Dim Angle, "
-                         "Max / Min, Length, Length Angle, "
-                         "Width, Width Angle, Length / Width\n");
-                break;
-
-            case OUTPUTFMT_FORMAT_AB_ODU:
-#ifdef OLD_PARTICLE_WEDGE_SCHEME
-                fprintf (outfp,
-                         "Frame #,Particle #,Area,X,Y,Min Dim,Max Dim,"
-                         "Min Dim Angle,Max Dim Angle,Min / Max\n");
-#else // ! OLD_PARTICLE_WEDGE_SCHEME
-                fprintf (outfp,
-                         "Frame #,Particle #,Area,X,Y, Min Dim,Max Dim, "
-                         "Min Dim Angle,Max Dim Angle, Max / Min,  "
-                         "Length,Length Angle, Width,Width Angle, "
-                         "Length / Width\n");
-#endif // ? OLD_PARTICLE_WEDGE_SCHEME
-                break;
-
-            default:
-                fprintf (outfp, "%% Uh oh, unknown output format %d!\n",
-                         outfmt);
-                break;
-            }
-        }
-    }
-
-    uint8_t ret = doParticle (_uncompressed, data, _in, real_frame,
-                              (last_frame_written == real_frame) ? 0 : outfp,
-                              _param, _info.width, _info.height);
-
-    last_frame_written = real_frame;
-
-    if (outfp && real_frame >= _info.nb_frames + _info.orgFrame - 1)
-    {
-        fclose (outfp);
-        outfp = 0;
-        fprintf (stderr, "Finished writing particle list to %s\n",
-                 _param->output_file.c_str());
-    }
-
-    return ret;
-}
-
-uint8_t
-ADMVideoParticle::doParticle (ADMImage * image, ADMImage * data,
-                              AVDMGenericVideoStream * in,
-                              uint32_t real_frame,
-                              FILE * do_outfp, PARTICLE_PARAM * param,
-                              uint32_t width, uint32_t height)
-{
-    uint32_t debug = param->debug;
-
-    uint32_t planesize = width * height;
-    uint32_t uvplanesize = planesize >> 2;
-    uint32_t size = planesize + (uvplanesize * 2);
-			
-    memset (UPLANE (data), 128, uvplanesize);
-    memset (VPLANE (data), 128, uvplanesize);
-    memset (YPLANE (data), 0, planesize);
-
-    // HERE: we should erase anything outside the ROI (region of interest),
-    // unless we decide to handle that some other way and/or place...
-
-    OutputFmt outfmt = static_cast <OutputFmt> (param->output_format);
-    bool fancyOutput = (outfmt == OUTPUTFMT_FORMAT_AB_ODU ||
-                        outfmt == OUTPUTFMT_FORMAT_DG_UWA);
-
-    uint8_t * imagePixels = YPLANE (image);
-    uint32_t imagetool_flags
-        = fancyOutput ? ImageTool::FLAG_DO_SHAPE : ImageTool::FLAG_NONE;
-
-    ImageTool imtool (imagePixels, width, height, data, imagetool_flags);
-    imtool.setDebug (debug);
-    imtool.setMinArea (param->min_area);
-    imtool.setMaxArea (param->max_area);
-    imtool.setCropping (param->left_crop, param->right_crop,
-                        param->top_crop, param->bottom_crop);
-    static uint32_t totalParticleNum = 0;
-    uint32_t frameParticleNum = 0;
-
-    uint32_t camera_number = param->camera_number;
-
-    for (uint32_t y = param->top_crop; y < height - param->bottom_crop; y++)
-    {
-        uint8_t * pixelrow = imagePixels + (y * width);
-        for (uint32_t x = param->left_crop; x < width - param->right_crop; x++)
-        {
-            if (imtool.goodPixel (pixelrow [x]))
-            {
-                if (imtool.autoOutline (x, y) == 0)
-                    continue;
-
-                const Particle & particle = imtool.getParticle();
-                uint32_t area = particle.area;
-                float centroid_x = particle.centroidX;
-                float centroid_y = particle.centroidY;
-
-                if (debug & (0x02 << ImageTool::SHIFT_PAST_SHOW_FLAGS))
-                    printf ("frame %d, particle %d (%d total), "
-                            "%d pixels centered at (%.6f,%.6f)\n",
-                            real_frame, frameParticleNum,
-                            totalParticleNum, area, centroid_x, centroid_y);
-
-                if (!do_outfp)
-                    continue;
-
-                ++totalParticleNum;
-                ++frameParticleNum;
-
-                if (fancyOutput)
-                {
-#ifdef OLD_PARTICLE_WEDGE_SCHEME
-                    uint32_t mindim = particle.getMinDimCount();
-                    uint32_t maxdim = particle.getMaxDimCount();
-                    float mindimangle = particle.getMinDimAngle();
-                    float maxdimangle = particle.getMaxDimAngle();
-                    float minmaxratio = float (mindim) / float (maxdim);
-#else // ! OLD_PARTICLE_WEDGE_SCHEME
-                    float mindist = particle.getMinDistance();
-                    float maxdist = particle.getMaxDistance();
-                    float mindistangle = particle.getMinDistAngle();
-                    float maxdistangle = particle.getMaxDistAngle();
-                    float maxminratio = float (maxdist) / float (mindist);
-                    const Particle::BestFit & bf = particle.getBestFit();
-                    float lenwidthratio = bf.length / bf.width;
-#endif // ? OLD_PARTICLE_WEDGE_SCHEME
-
-                    if (outfmt == OUTPUTFMT_FORMAT_DG_UWA)
-                    {
-                        fprintf (do_outfp,
-                                 "%d %d "
-                                 "%.6f %.6f " // x, y
-                                 "%d %d " // area, totalParticleNum
-                                 "%d %d " // bbox width, bbox height
-                                 "%.5f %.5f " // min, max
-                                 "%.5f %.5f %.5f  " // minang,maxang,max/min
-                                 "%.5f %.5f " // len, len_angle
-                                 "%.5f %.5f %.5f\n", // wid, wid_ang, len/wid
-                                 real_frame, camera_number,
-                                 centroid_x, centroid_y,
-                                 area, totalParticleNum,
-                                 particle.maxx - particle.minx + 1,
-                                 particle.maxy - particle.miny + 1,
-                                 mindist, maxdist,
-                                 mindistangle, maxdistangle, maxminratio,
-                                 bf.length, bf.length_angle,
-                                 bf.width, bf.width_angle, lenwidthratio);
-                    }
-                    else if (outfmt == OUTPUTFMT_FORMAT_AB_ODU)
-                    {
-#ifdef OLD_PARTICLE_WEDGE_SCHEME
-                        fprintf (do_outfp,
-                                 "%d,%d,%d,%.6f,%.6f,%d,%d,%.5f,%.5f,%.5f\n",
-                                 real_frame, frameParticleNum, area,
-                                 centroid_x, centroid_y, mindim, maxdim,
-                                 mindimangle, maxdimangle, minmaxratio);
-#else // ! OLD_PARTICLE_WEDGE_SCHEME
-                        fprintf (do_outfp,
-                                 "%d,%d,%d,"
-                                 "%.6f,%.6f, %.5f,%.5f, " // x, y, min, max
-                                 "%.5f,%.5f, %.5f,  " // minang,maxang,max/min
-                                 "%.5f,%.5f, " // len, len_angle
-                                 "%.5f,%.5f, %.5f\n", // wid, wid_ang, len/wid
-                                 real_frame, frameParticleNum, area,
-                                 centroid_x, centroid_y, mindist, maxdist,
-                                 mindistangle, maxdistangle, maxminratio,
-                                 bf.length, bf.length_angle,
-                                 bf.width, bf.width_angle, lenwidthratio);
-#endif // ? OLD_PARTICLE_WEDGE_SCHEME
-                    }
-                    else
-                        fprintf (do_outfp,
-                                 "uh oh, unknown fancy output format %d\n",
-                                 outfmt);
-                }
-                else
-                {
-                    if (outfmt == OUTPUTFMT_FORMAT_NEW)
-                    {
-                        fprintf (do_outfp, "%d %d %.6f %.6f %d %d\n",
-                                 real_frame, camera_number,
-                                 centroid_x, centroid_y,
-                                 area, totalParticleNum);
-                    }
-                    else
-                    {
-                        fprintf (do_outfp, "%d %d %.6f %.6f %d\n",
-                                 totalParticleNum, area,
-                                 centroid_x, centroid_y, real_frame);
-                    }
-                }
-            }
-        }
-    }
-
-    data->copyInfo(image);
-    return 1;
-}	                           
-
-//////////////////////////////////////////////////////////////////////////////
-
-#ifdef OLD_PARTICLE_WEDGE_SCHEME
-inline void Particle_Old::Wedge::trim_to_edge ()
-{
-    for (int i = pixel_distance.size() - 1; i >= 0; --i)
-    {
-        if (pixel_distance [i] > max_white_distance)
-        {
-            // toss it; to save time we just mark it invalid instead of
-            // deleting from the various vectors.
-            pixel_distance [i] = -1;
-            --pixel_count;
-        }
-    }
-}
-#endif
-
-char ImageTool::directionLetters [] = "ESWN#?";
-
-PixelOffset ImageTool::leftOffset [ImageTool::DIRECTION_COUNT] =
-{
-//     East         South        West         North
-    {  0, -1 },  {  1,  0 },  {  0,  1 },  { -1,  0 }
-};
-
-// Interesting - aheadOffset [n] == leftOffset [(n + 1) % DIRECTION_COUNT]...
-PixelOffset ImageTool::aheadOffset [ImageTool::DIRECTION_COUNT] =
-{
-//     East         South        West         North
-    {  1,  0 },  {  0,  1 },  { -1,  0 },  {  0, -1 }
-};
-
-// If we're using 4-connectedness (current implementation), then the following
-// would be treated as two independent particles; with 8-connectedness, this
-// would be a single particle with some "holes" in it.
-
-// . . . * * . . .
-// . . * * * . . .
-// . * * * . * . .
-// . * * * . * * .
-// * * * . * * * .
-// * * . * * * * .
-// . * . * * * . .
-// . . . * . . . .
-
-
-uint8_t ImageTool::autoOutline (uint32_t x, uint32_t y)
-{
-/*    my_particle.init (debug);
-    PixelLocVec & outline = my_particle.outline;
-
-    static int needbar = 1;
-
-    if (needbar && (debug & 0xffff)) // anything
-    {
-        printf ("\n======================================="
-                "=======================================\n\n");
-        needbar = 0;
-    }
-
-    if ((debug & (0x04 << SHIFT_PAST_SHOW_FLAGS)) && ++needbar)
-        printf ("autoOutline(%d,%d):", x, y);
-
-    ADM_assert (goodPixel (x, y));
-
-    uint32_t startingX = x;
-    uint32_t startingY = y;
-
-    TracingDirection direction = DIRECTION_COUNT; // deliberately invalid
-    TracingDirection newDirection = DIRECTION_EAST;
-
-    int8_t
-        Lx, Ly,  // left
-        Ax, Ay;  // ahead
-
-#if 0
-    uint32_t prevX;
-    uint32_t prevY;
-    TracingDirection startingDirection = direction;
-#endif
-
-    uint32_t pointCount = 0;
-    uint32_t pointMax = my_w * my_h; // more than that and something is wrong
-
-    do
-    {
-#if 0
-        prevX = x;
-        prevY = y;
-#endif
-
-        outline.push_back (PixelLoc (x, y));
-        if ((debug & (0x08 << SHIFT_PAST_SHOW_FLAGS)) && ++needbar)
-            printf (" %c(%d,%d)%c", directionLetters [direction],
-                    x, y, directionLetters [newDirection]);
-
-        if (++pointCount >= pointMax)
-        {
-            printf ("\nUh oh!  Too many points!! (%d) (@(%d,%d), dir %c)\n",
-                    pointCount, x, y, directionLetters [direction]);
-            showStuff (SHOW_INPUT);
-            showStuff (SHOW_OUTLINE);
-            break;
-        }
-
-        if (newDirection != direction)
-        {
-            direction = newDirection;
-            Lx = leftOffset [direction].x;
-            Ly = leftOffset [direction].y;
-            Ax = aheadOffset [direction].x;
-            Ay = aheadOffset [direction].y;
-#define ARx (Ax + Rx)
-#define ARy (Ay + Ry)
-#define Rx  (-Lx)
-#define Ry  (-Ly)
-#define BRx (Bx + Rx)
-#define BRy (By + Ry)
-#define Bx  (-Ax)
-#define By  (-Ay)
-#define BLx (Bx + Lx)
-#define BLy (By + Ly)
-        }
-
-        if (goodPixel (x + Lx, y + Ly))
-        {
-            // Turn left
-            x += Lx;
-            y += Ly;
-            newDirection = TracingDirection ((direction + TURN_LEFT)
-                                             % DIRECTION_COUNT);
-        }
-        else if (goodPixel (x + Ax, y + Ay))
-        {
-            // Continue in same direction
-            x += Ax;
-            y += Ay;
-            // newDirection = direction;
-        }
-        else if (goodPixel (x + Rx, y + Ry))
-        {
-            // Turn right
-            x += Rx;
-            y += Ry;
-            newDirection = TracingDirection ((direction + TURN_RIGHT)
-                                             % DIRECTION_COUNT);
-        }
-#if 0
-// if we turn this on, we probably ought to be looking at the AL pixel as
-// well.  (And turn on the BR case, below?)
-
-        else if (goodPixel (x + ARx, y + ARy))
-        {
-            // Slide down one pixel and continue
-            do that!;
-        }
-#endif
-        else if (goodPixel (x + Bx, y + By))
-        {
-            // Turn around (reverse direction)
-            x += Bx;
-            y += By;
-            newDirection = TracingDirection ((direction + TURN_AROUND)
-                                             % DIRECTION_COUNT);
-        }
-#if 0
-        else if (goodPixel (x + BRx, y + BRy))
-        {
-            // Slide down one pixel and turn right
-            do that (the slide)!;
-            newDirection = TracingDirection ((direction + TURN_RIGHT)
-                                             % DIRECTION_COUNT);
-        }
-#endif
-        else
-        {
-            // Apparently there is nowhere to go.  This should happen only if
-            // we're looking at an isolated pixel (a one-pixel particle).
-
-            if (outline.size() > 1)
-            {
-                printf ("\nUh oh!  We're stuck, but it's not a lonely pixel!  "
-                        "(@(%d,%d), dir %c)\n",
-                        x, y, directionLetters [direction]);
-                showStuff (SHOW_INPUT);
-                showStuff (SHOW_OUTLINE);
-                ADM_assert (outline.size() > 1);
-            }
-
-            break; // we'd fall out anyway, but this is faster & more explicit
-        }
-
-    } while (x != startingX || y != startingY);
-
-    if ((debug & (0x04 << SHIFT_PAST_SHOW_FLAGS)) && ++needbar)
-        printf (" done! %d points in all\n", outline.size());
-
-    // We now do 5 things in one pass: 1. count the pixels in the particle
-    // (thus computing the area, defined as the number of pixels in the
-    // particle); 2. clear those pixels in the input image so that we don't
-    // count the particle more than once; 3. compute the centroid (defined as
-    // the point whose x is the average of all the x's in the particle, and
-    // whose y is the average of all the y's in the particle); 4. if there is
-    // an output image, draw the particle in the output, with the outline
-    // highlighted; 5. compute the bounding box (rectangle that completely
-    // encloses the particle).
-
-    PixelLocVec::iterator plit = outline.begin();
-    while (plit != outline.end())
-    {
-        uint32_t px = plit->x;
-        uint32_t py = plit->y;
-
-        ++plit;
-
-        if (my_outImage)
-        {
-            outPixel (px, py) = 255;
-#ifdef USE_COLOR_IN_OUTPUT
-            outUPixel (px, py) = 0;
-            outVPixel (px, py) = 0;
-#endif
-        }
-
-        // We do the above (set up output pixels) first so we ensure that the
-        // outline is highlighted even if the code below has already displayed
-        // some of the pixels in the outline (due to direct or indirect
-        // adjacency to other outline pixels).
-
-        if (getPixel (px, py) == 0)
-            continue;
-
-        // If we're still here, then this pixel is part of the particle but
-        // has not yet been counted or otherwise processed.  There may be
-        // other horizontally adjacent pixels, as well, which we will also
-        // process now, if they are present - this accomplishes "filling" the
-        // particle outline (except that any pixels that were actually not
-        // "on" in the particle will be ignored).
-
-        // First, we process the pixel itself, and any pixels to the right of
-        // it (if they are on).
-
-        uint32_t startX = px;
-
-        my_particle.addWhitePixel (px, py);
-        getPixel (px, py) = 0; // erase to prevent being counted again
-
-        while (goodPixel (++px, py))
-        {
-            my_particle.addWhitePixel (px, py);
-            getPixel (px, py) = 0; // erase to prevent being counted again
-            if (my_outImage)
-                outPixel (px, py) = 128;
-        }
-
-        // Now, we process any pixels to the left of the original one (if they
-        // are on).
-
-        px = startX;
-        while (goodPixel (--px, py))
-        {
-            my_particle.addWhitePixel (px, py);
-            getPixel (px, py) = 0; // erase to prevent being counted again
-            if (my_outImage)
-                outPixel (px, py) = 128;
-        }
-    }
-
-    if (my_particle.area < my_minArea || my_particle.area > my_maxArea)
-    {
-        if (my_outImage)
-        {
-            // We need to erase the particle we just drew. :-(
-
-            plit = my_particle.white_pixels.begin();
-            while (plit != my_particle.white_pixels.end())
-            {
-                outPixel (plit->x, plit->y) = 0;
-                ++plit;
-            }
-        }
-
-        return 0;
-    }
-
-    needbar = 1;
-
-    my_particle.computeCentroid();
-
-    if (debug & (0x0002 << ImageTool::SHIFT_PAST_SHOW_FLAGS))
-        printf ("    particle has %d pixels from (%d,%d) to (%d,%d) "
-                "with centroid at (%.5f,%.5f)\n",
-                my_particle.area, my_particle.minx, my_particle.miny,
-                my_particle.maxx, my_particle.maxy,
-                my_particle.centroidX, my_particle.centroidY);
-
-    if (my_outImage)
-    {
-        uint32_t px = static_cast <uint32_t> (nearbyintf (my_particle.centroidX));
-        uint32_t py = static_cast <uint32_t> (nearbyintf (my_particle.centroidY));
-        if (validPixel (px, py))
-            outPixel (px, py) = 255;
-        else
-            fprintf (stderr, "################# Uh oh, about to stomp "
-                     "invalid centroid pixel (%d, %d)!!\n", px, py);
-#ifdef USE_COLOR_IN_OUTPUT
-        outUPixel (px, py) = 255;
-        outVPixel (px, py) = 255;
-#endif
-    }
-
-    if (debug & SHOW_INPUT)
-        showStuff (SHOW_INPUT);
-
-    if (debug & SHOW_OUTLINE)
-        showStuff (SHOW_OUTLINE);
-
-#ifdef OLD_PARTICLE_WEDGE_SCHEME
-
-    if (my_flags & FLAG_DO_SHAPE)
-    {
-        typedef Particle::Wedge Wedge;
-        typedef Particle::WedgeVec WedgeVec;
-        typedef Particle::WedgePair WedgePair;
-        typedef Particle::WedgePairVec WedgePairVec;
-
-        // HERE: for DG/UWA format, we may only need the white pixels.  For
-        // AB/ODU format, we need to find all the pixels which are no further
-        // from the centroid than the furthest white pixel in the same wedge.
-        // For now, for DG/UWA format, we will show both numbers, so we need
-        // to measure the distance from the centroid for both formats.
-
-        my_particle.init_wedges();
-
-        // HERE: we don't need to sort the white_pixels vector unless we're
-        // counting non-white pixels in the shape stuff.
-
-        PixelLocVec & white_pixels = my_particle.white_pixels;
-        sort (white_pixels.begin(), white_pixels.end(), PixelLoc::Compare());
-
-        WedgeVec & wedges = my_particle.wedges;
-
-        uint16_t minx = my_particle.minx;
-        uint16_t miny = my_particle.miny;
-        uint16_t maxx = my_particle.maxx;
-        uint16_t maxy = my_particle.maxy;
-
-        const float pi_plus_half_wedge_arc
-            = M_PI + my_particle.half_wedge_arc;
-        const float wedge_arc = my_particle.wedge_arc;
-        const uint32_t num_wedges = my_particle.num_wedges;
-
-        for (uint16_t py = miny; py <= maxy; py++)
-        {
-            const float dy = py - my_particle.centroidY;
-            const float dy_squared = dy * dy;
-
-            for (uint16_t px = minx; px <= maxx; px++)
-            {
-                float dx = px - my_particle.centroidX;
-                float angle = atan2f (dy, dx);
-                uint32_t wedgeIndex
-                    = int ((angle + pi_plus_half_wedge_arc) / wedge_arc);
-                wedgeIndex %= num_wedges; // just in case
-
-                // uint8_t value = getPixel (px, py);
-                // oops, can't use that - we erased it already. :-(
-                bool value
-                    = binary_search (white_pixels.begin(), white_pixels.end(),
-                                     PixelLoc (px, py), PixelLoc::Compare());
-                float distance = sqrtf (dx * dx + dy_squared);
-                wedges [wedgeIndex].add_pixel (px, py, value, distance);
-                                               
-                printf ("%d @ (%d,%d) %.5f -> %d @ %.5f\n",
-                        value, px, py, distance,
-                        wedgeIndex, wedges[wedgeIndex].center_angle);
-            }
-        }
-
-        // See note in init_wedges() about what we're doing with the last
-        // wedge here.
-
-        wedges [0] += wedges [num_wedges];
-        wedges.pop_back();
-
-        // Now, in each wedge, toss any non-white pixels that are further out
-        // than the furthest white pixel in that wedge.
-
-        for (WedgeVec::iterator wit = wedges.begin();
-             wit != wedges.end();
-             ++wit)
-        {
-            printf ("wedge @ %.5f: max white distance = %.5f\n",
-                    wit->center_angle, wit->max_white_distance);
-            wit->trim_to_edge();
-        }
-
-        // Next, we combine opposite wedges so that we can report the
-        // dimension along a line through the centroid across the whole
-        // particle (not just from the centroid to the particle boundary).
-
-        WedgePairVec & wedge_pairs = my_particle.wedge_pairs;
-        int num_lines = my_particle.num_wedges / 2;
-        for (int widx = 0; widx < num_lines; ++widx)
-        {
-            const Wedge & neg_wedge = wedges [widx];
-            const Wedge & pos_wedge = wedges [widx + num_lines];
-
-            float angle = pos_wedge.center_angle;
-            printf ("wedge %d at %.5f = %d of %d  "
-                    "wedge %d at %.5f = %d of %d\n",
-                    widx, neg_wedge.center_angle, neg_wedge.pixel_count,
-                    neg_wedge.pixel_distance.size(),
-                    widx + num_lines, angle, pos_wedge.pixel_count,
-                    pos_wedge.pixel_distance.size());
-            uint32_t pixel_count
-                = pos_wedge.pixel_count + neg_wedge.pixel_count;
-            wedge_pairs.push_back (WedgePair (angle, pixel_count));
-        }
-
-        // Now we (effectively) sort the wedges by the number of pixels in
-        // them.
-
-        sort (wedge_pairs.begin(), wedge_pairs.end(), WedgePair::Less());
-
-        if (debug & SHOW_WEDGE_PIXELS)
-            showStuff (SHOW_WEDGE_PIXELS);
-    }
-
-#else // ! OLD_PARTICLE_WEDGE_SCHEME
-
-    if (my_flags & FLAG_DO_SHAPE)
-    {
-        typedef Particle::Wedge Wedge;
-        typedef Particle::WedgeVec WedgeVec;
-        typedef Particle::WedgePair WedgePair;
-        typedef Particle::WedgePairVec WedgePairVec;
-
-        my_particle.init_wedges();
-
-        PixelLocVec & white_pixels = my_particle.white_pixels;
-        WedgeVec & wedges = my_particle.wedges;
-
-        uint16_t minx = my_particle.minx;
-        uint16_t miny = my_particle.miny;
-        uint16_t maxx = my_particle.maxx;
-        uint16_t maxy = my_particle.maxy;
-
-        const float wedge_interval = my_particle.wedge_interval;
-        const uint32_t num_wedges = my_particle.num_wedges;
-
-        for (PixelLocVec::const_iterator wpit = white_pixels.begin();
-             wpit != white_pixels.end();
-             ++wpit)
-        {
-            const uint16_t px = wpit->x;
-            const uint16_t py = wpit->y;
-            const float dy = py - my_particle.centroidY;
-            const float dx = px - my_particle.centroidX;
-            float angle = atan2f (dy, dx);
-            uint32_t wedgeIndex = int ((angle + M_PI) / wedge_interval);
-            float distance = sqrtf (dx * dx + dy * dy);
-
-            while (1)
-            {
-                wedgeIndex %= num_wedges + 1;
-
-                Wedge & wedge = wedges [wedgeIndex];
-
-                if (angle < wedge.min_angle || angle > wedge.max_angle)
-                {
-                    if (debug & (0x0020 << SHIFT_PAST_SHOW_FLAGS))
-                        printf ("(%d,%d) = %.5f @ %.5f out of range for "
-                                "%d @ %.5f (%.5f to %.5f)\n",
-                                px, py, distance, angle,
-                                wedgeIndex, wedge.center_angle,
-                                wedge.min_angle, wedge.max_angle);
-                    break;
-                }
-
-                wedge.add_pixel (px, py, distance, angle);
-
-                if (debug & (0x0010 << SHIFT_PAST_SHOW_FLAGS))
-                    printf ("(%d,%d) = %.5f @ %.5f -> %d @ %.5f (%.5f)\n",
-                            px, py, distance, angle, wedgeIndex,
-                            wedge.angle_for_mwd, wedge.center_angle);
-                ++wedgeIndex;
-            }
-        }
-
-        // See note in init_wedges() about what we're doing with the last
-        // wedge here.
-
-        wedges [0] += wedges [num_wedges];
-        wedges.pop_back();
-
-        // Next, we combine opposite wedges so that we can report the
-        // dimension along a line through the centroid across the whole
-        // particle (not just from the centroid to the particle boundary).
-
-        WedgePairVec & wedge_pairs = my_particle.wedge_pairs;
-        int num_lines = my_particle.num_wedges / 2;
-        for (int widx = 0; widx < num_lines; ++widx)
-        {
-            const Wedge & neg_wedge = wedges [widx];
-            const Wedge & pos_wedge = wedges [widx + num_lines];
-
-            wedge_pairs.push_back (WedgePair (neg_wedge, pos_wedge));
-            const WedgePair & wp = wedge_pairs.end()[-1];
-            if (debug & (0x0100 << ImageTool::SHIFT_PAST_SHOW_FLAGS))
-                printf ("%c: wedge %d = %8.5f @ %.5f (%.5f), + "
-                        "wedge %d = %8.5f @ %.5f (%.5f), --> %9.5f @ %.5f\n",
-                        widx + 'a', widx, neg_wedge.max_white_distance,
-                        neg_wedge.angle_for_mwd, neg_wedge.center_angle,
-                        widx + num_lines, pos_wedge.max_white_distance,
-                        pos_wedge.angle_for_mwd, pos_wedge.center_angle,
-                        wp.total_distance, wp.angle);
-        }
-
-        // Now, we find the pair of perpendicular wedges with the greatest
-        // ratio of length to width, where length and width are arbitrary
-        // designations (but length will never be less than width).
-
-        float best_ratio = -1;
-        int best_ratio_index = -1;
-        for (int wpidx = 0; wpidx < num_lines; ++wpidx)
-        {
-            const WedgePair & wp = wedge_pairs [wpidx];
-            // Find the perpendicular wedge.
-            int pwpidx = (wpidx + (num_lines / 2)) % num_lines;
-            const WedgePair & pwp = wedge_pairs [pwpidx];
-            float ratio = wp.total_distance / pwp.total_distance;
-            if (debug & (0x0200 << ImageTool::SHIFT_PAST_SHOW_FLAGS))
-                printf ("%c: wedgepair %d = %9.5f @ %.5f / "
-                        "wedgepair %d = %9.5f @ %.5f = %.5f\n",
-                        wpidx + 'a', wpidx, wp.total_distance, wp.angle,
-                        pwpidx, pwp.total_distance, pwp.angle, ratio);
-            if (ratio > best_ratio)
-            {
-                best_ratio = ratio;
-                best_ratio_index = wpidx;
-            }
-        }
-
-        Particle::BestFit & best_fit = my_particle.best_fit;
-        const WedgePair & wp = wedge_pairs [best_ratio_index];
-        best_fit.length = wp.total_distance;
-        best_fit.length_angle = wp.angle;
-        int best_ratio_width_index
-            = (best_ratio_index + (num_lines / 2)) % num_lines;
-        const WedgePair & pwp = wedge_pairs [best_ratio_width_index];
-        best_fit.width = pwp.total_distance;
-        best_fit.width_angle = pwp.angle;
-
-        if (debug & (0x0200 << ImageTool::SHIFT_PAST_SHOW_FLAGS))
-            printf ("\nbest fit: length = wedgepair %d (%.5f @ %.5f) X "
-                    "wedgepair %d (%.5f @ %.5f); len/wid = %.5f\n\n",
-                    best_ratio_index, wp.total_distance, wp.angle,
-                    best_ratio_width_index, pwp.total_distance, pwp.angle,
-                    best_ratio);
-
-        // Finally, we (effectively) sort the wedges by the number of pixels
-        // in them.
-
-        sort (wedge_pairs.begin(), wedge_pairs.end(), WedgePair::Less());
-
-        if (debug & SHOW_WEDGE_PIXELS)
-            showStuff (SHOW_WEDGE_PIXELS);
-    }
-
-#endif // ? OLD_PARTICLE_WEDGE_SCHEME
-*/
-    return 1;
-}
-
-const PixelLoc PixelLoc::INVALID (0xffff, 0xffff);
-
-#ifdef OLD_PARTICLE_WEDGE_SCHEME
-
-void Particle_Old::init_wedges ()
-{
-    // num_wedges = (maxx - minx + 1 + maxy - miny + 1) * 2;
-    //    The above was too many - not enough pixels in any one wedge, and
-    //    minimum was always zero.
-    // num_wedges = maxx - minx + 1 + maxy - miny + 1;
-    //    The above was still too many.
-    num_wedges = min (int (area / 2), maxx - minx + 1 + maxy - miny + 1);
-
-    num_wedges = (num_wedges + 3) & ~3; // round up to multiple of 4
-    wedge_arc = 2.0 * M_PI / num_wedges;
-    half_wedge_arc = wedge_arc / 2;
-    printf ("init_wedges(): area = %d; %d wedges of arc %.5f\n",
-            area, num_wedges, wedge_arc);
-
-    // We are going to set up one extra wedge, because out on the negative X
-    // axis, there is a discontinuity: angles will be around +pi or -pi,
-    // depending on whether they are just above or below the negative X axis.
-    // So with the extra wedge, we have two exactly overlapping wedges (the
-    // first and last ones), with the first one catching all the ~-pi values
-    // and the last one catching the ~+pi values.  Later, we'll dump the last
-    // one into the first one before we process the wedges themselves.
-
-    wedges.reserve (num_wedges + 1);
-    double angle = -M_PI;
-    uint32_t wedge_index = 0;
-    while (wedge_index <= num_wedges)
-    {
-        wedges.push_back (Wedge (angle, half_wedge_arc));
-        angle += wedge_arc;
-        ++wedge_index;
-    }
-}
-
-#else // ! OLD_PARTICLE_WEDGE_SCHEME
-
-void Particle::init_wedges ()
-{
-    // We've tried various other things, but they didn't work out well.
-    // Now we have a fixed number of wedges, and each wedge overlaps with 50%
-    // of each of its neighbors (e.g., 16 wedges, each one 1/8 of the circle).
-
-    num_wedges = 16;
-    wedge_interval = 2.0 * M_PI / num_wedges;
-    wedge_arc = wedge_interval * 2;
-    half_wedge_arc = wedge_arc / 2;
-    if (debug & (0x40 << ImageTool::SHIFT_PAST_SHOW_FLAGS))
-        printf ("init_wedges(): %d wedges of arc %.5f, centered every %.5f\n",
-                num_wedges, wedge_arc, wedge_interval);
-
-    // We are going to set up one extra wedge, because out on the negative X
-    // axis, there is a discontinuity: angles will be around +pi or -pi,
-    // depending on whether they are just above or below the negative X axis.
-    // So with the extra wedge, we have two exactly overlapping wedges (the
-    // first and last ones), with the first one catching all the ~-pi values
-    // and the last one catching the ~+pi values.  Later, we'll dump the last
-    // one into the first one before we process the wedges themselves.
-
-    wedges.reserve (num_wedges + 1);
-    double angle = -M_PI;
-    uint32_t wedge_index = 0;
-    while (wedge_index <= num_wedges)
-    {
-        if (debug & (0x80 << ImageTool::SHIFT_PAST_SHOW_FLAGS))
-            printf ("    wedge %2d: %.5f (%.5f to %.5f)\n",
-                    wedge_index, angle, angle - half_wedge_arc,
-                    angle + half_wedge_arc);
-        wedges.push_back (Wedge (angle, half_wedge_arc));
-        angle += wedge_interval;
-        ++wedge_index;
-    }
-}
-
-#endif // ? OLD_PARTICLE_WEDGE_SCHEME
-
-static inline
-char & pixel_char (vector <string> & grid, int16_t xbase, int16_t ybase,
-                   float cX, float cY, float dX, float dY)
-{
-    uint16_t x = static_cast <uint16_t> (nearbyintf (cX + dX));
-    uint16_t y = static_cast <uint16_t> (nearbyintf (cY + dY));
-    return grid [y - ybase][x - xbase];
-}
-
-static inline
-char & pixel_char_from_angle (vector <string> & grid, int16_t xbase, int16_t ybase,
-                              float cX, float cY, float distance, float angle)
-{
-    float dX = distance * cosf (angle);
-    float dY = distance * sinf (angle);
-    return pixel_char (grid, xbase, ybase, cX, cY, dX, dY);
-}
-
-void ImageTool::showStuff (ShowStuff what) const
-{
-    const PixelLocVec & outline = my_particle.outline;
-
-    const int margin = 5;
-
-    uint16_t bbminx = my_particle.minx;
-    uint16_t bbminy = my_particle.miny;
-    uint16_t bbmaxx = my_particle.maxx;
-    uint16_t bbmaxy = my_particle.maxy;
-
-    if (bbminx > bbmaxx)
-    {
-        PixelLocVec::const_iterator plit = outline.begin();
-        while (plit != outline.end())
-        {
-            uint32_t px = plit->x;
-            uint32_t py = plit->y;
-
-            if (px < bbminx)
-                bbminx = px;
-            if (px > bbmaxx)
-                bbmaxx = px;
-            if (py < bbminy)
-                bbminy = py;
-            if (py > bbmaxy)
-                bbmaxy = py;
-
-            ++plit;
-        }
-    }
-
-    uint16_t minx = max (int16_t (bbminx) - margin, 0);
-    uint16_t miny = max (int16_t (bbminy) - margin, 0);
-    uint16_t maxx = min (bbmaxx + margin, int16_t (my_w) - 1);
-    uint16_t maxy = min (bbmaxy + margin, int16_t (my_h) - 1);
-
-    switch (what)
-    {
-    case SHOW_INPUT:
-        printf ("Input (after previous particle(s) erased):\n\n");
-        break;
-
-    case SHOW_OUTLINE:
-        printf ("Outline (%d points):\n\n", outline.size());
-        break;
-
-#ifdef OLD_PARTICLE_WEDGE_SCHEME
-    case SHOW_WEDGE_PIXELS:
-        printf ("Wedge pair assignments (%d wedges):\n\n",
-                my_particle.num_wedges);
-        break;
-#else
-    case SHOW_WEDGE_PIXELS:
-        printf ("Wedge distances (%d wedges, %.5f arc at %.5f interval):\n\n",
-                my_particle.num_wedges, my_particle.wedge_arc,
-                my_particle.wedge_interval);
-        break;
-#endif
-
-    default:
-        break;
-    }
-
-    uint16_t dimx = maxx - minx + 1;
-    uint16_t dimy = maxy - miny + 1;
-    int16_t xbase = minx - 1;
-    int16_t ybase = miny;
-
-    if (debug & (0x0400 << ImageTool::SHIFT_PAST_SHOW_FLAGS))
-        printf ("%dx%d (%d,%d - %d,%d; %d,%d - %d,%d; base = %d,%d)\n",
-                dimx, dimy, bbminx, bbminy, bbmaxx, bbmaxy,
-                minx, miny, maxx, maxy, xbase, ybase);
-
-    string ruler (dimx + 2, '-');
-    ruler [0] = '+';
-    ruler [dimx + 1] = '+';
-    printf ("  x|");
-    const int x_ruler_spacing = 5;
-    unsigned xtick = minx + x_ruler_spacing - (minx % x_ruler_spacing);
-    unsigned field_width = xtick - minx + 2;
-    while (xtick < maxx)
-    {
-        printf ("%*d", field_width, xtick);
-        ruler [xtick - xbase] = '+';
-        xtick += x_ruler_spacing;
-        field_width = x_ruler_spacing;
-    }
-    ruler [bbminx - xbase] = '|';
-    ruler [bbmaxx - xbase] = '|';
-    printf ("\ny: %s\n", ruler.c_str());
-
-    string blankLine (dimx + 2, '.');
-    blankLine [0] = '|';
-    blankLine [dimx + 1] = '|';
-    vector <string> grid (dimy, blankLine);
-    grid [bbminy - ybase][0] = '=';
-    grid [bbminy - ybase][dimx + 1] = '=';
-    grid [bbmaxy - ybase][0] = '=';
-    grid [bbmaxy - ybase][dimx + 1] = '=';
-
-    switch (what)
-    {
-    case SHOW_INPUT:
-    case SHOW_OUTLINE:
-    {
-        for (uint32_t py = miny; py <= maxy; py++)
-        {
-            string & gridline = grid [py - ybase];
-            for (uint32_t px = minx; px <= maxx; px++)
-                if (goodPixel (px, py))
-                    gridline [px - xbase] = 'x';
-        }
-    }
-
-    // case SHOW_OUTLINE:
-    {
-        PixelLocVec::const_iterator plit = my_particle.white_pixels.begin();
-        while (plit != my_particle.white_pixels.end())
-        {
-            grid [plit->y - ybase][plit->x - xbase] = '*';
-            ++plit;
-        }
-
-        if (what == SHOW_INPUT)
-            break;
-
-        plit = outline.begin();
-        while (plit != outline.end())
-        {
-            uint32_t px = plit->x;
-            uint32_t py = plit->y;
-
-            char & ch = grid [py - ybase][px - xbase];
-            // printf ("(%d,%d)%c", px, py, ch);
-            if (ch == '*')
-                ch = '1';
-            else if (ch == '9')
-                ch = '+';
-            else if (ch == '.')
-                ch = '1';
-            else if (ch != '+')
-                ++ch;
-            // printf ("->%c  ", ch);
-
-            ++plit;
-        }
-
-        uint32_t px = static_cast <uint32_t> (nearbyintf (my_particle.centroidX));
-        uint32_t py = static_cast <uint32_t> (nearbyintf (my_particle.centroidY));
-        char & ch = grid [py - ybase][px - xbase];
-        if (ch == 'x')
-            ch = 'X';
-        else if (ch == '.')
-            ch = 'c';
-        else
-            ch = 'C';
-        break;
-    }
-
-#ifdef OLD_PARTICLE_WEDGE_SCHEME
-    case SHOW_WEDGE_PIXELS:
-    {
-        const Particle::WedgeVec & wedges = my_particle.wedges;
-        int num_lines = my_particle.num_wedges / 2;
-        for (int widx = 0; widx < num_lines; ++widx)
-        {
-            char ch = 'a' + (widx % 26);
-            for (int incr = 0; incr <= num_lines; incr += num_lines)
-            {
-                const Particle::Wedge & wedge = wedges [widx + incr];
-                PixelLocVec::const_iterator plit = wedge.pixel_locs.begin();
-                vector <float>::const_iterator fit
-                    = wedge.pixel_distance.begin();
-                while (plit != wedge.pixel_locs.end())
-                {
-                    if (*fit++ > 0)
-                        grid [plit->y - ybase][plit->x - xbase] = ch;
-                    ++plit;
-                }
-            }
-        }
-        uint32_t px = static_cast <uint32_t> (nearbyintf (my_particle.centroidX));
-        uint32_t py = static_cast <uint32_t> (nearbyintf (my_particle.centroidY));
-        char & ch = grid [py - ybase][px - xbase];
-        if (ch == '.')
-            ch = '*';
-        else
-            ch = toupper (ch);
-        break;
-    }
-#else // ! OLD_PARTICLE_WEDGE_SCHEME
-    case SHOW_WEDGE_PIXELS:
-    {
-        // For each wedge, we mark the max distance for it with a lowercase
-        // letter at the point along the angle for that wedge that is the max
-        // distance from the centroid.
-        // 
-        // We mark the best-fit points with an L at points half the "length"
-        // from the centroid along the angle for the length and a W at points
-        // half the "width" from the centroid along the angle for the width.
-
-        const Particle::WedgeVec & wedges = my_particle.wedges;
-        const float centroidX = my_particle.centroidX;
-        const float centroidY = my_particle.centroidY;
-        int num_lines = my_particle.num_wedges / 2;
-        for (int widx = 0; widx < num_lines; ++widx)
-        {
-            char newch = 'a' + (widx % 26);
-            for (int incr = 0; incr <= num_lines; incr += num_lines)
-            {
-                const Particle::Wedge & wedge = wedges [widx + incr];
-                char & ch = pixel_char_from_angle (grid, xbase, ybase,
-                                                   centroidX, centroidY,
-                                                   wedge.max_white_distance,
-                                                   wedge.angle_for_mwd);
-                // printf ("(%d,%d) = '%c' (%.5f @ %.5f)\n",
-                //         x, y, newch, wedge.max_white_distance,
-                //         wedge.angle_for_mwd);
-                ch = newch;
-            }
-        }
-        const Particle::BestFit & bf = my_particle.best_fit;
-        pixel_char_from_angle (grid, xbase, ybase, centroidX, centroidY,
-                               bf.length / 2, bf.length_angle)
-            = 'L';
-        pixel_char_from_angle (grid, xbase, ybase, centroidX, centroidY,
-                               bf.length / 2, bf.length_angle - M_PI)
-            = 'L';
-        pixel_char_from_angle (grid, xbase, ybase, centroidX, centroidY,
-                               bf.width / 2, bf.width_angle)
-            = 'W';
-        pixel_char_from_angle (grid, xbase, ybase, centroidX, centroidY,
-                               bf.width / 2, bf.width_angle - M_PI)
-            = 'W';
-        char & ch = pixel_char (grid, xbase, ybase,
-                                centroidX, centroidY, 0, 0);
-        if (ch == '.')
-            ch = '*';
-        else
-            ch = '@';
-        break;
-    }
-#endif // ? OLD_PARTICLE_WEDGE_SCHEME
-
-    default:
-        break;
-    }
-
-    for (unsigned i = miny; i <= maxy; ++i)
-        printf ("%3d%s\n", i, grid [i - ybase].c_str());
-
-    printf ("   %s\n\n", ruler.c_str());
-}
-
-// Debug output should be able to show:
-
-// input: contents of entire bounding box plus 5-pixel margin on all sides
-// (with box boundaries marked somehow)
-
-// outline (current showStuff()) but with margin as above and showing all
-// pixel states (on/off) (on = *, C for centroid; . = off)
-
-// all pixels considered part of the particle, with wedge assignments if using
-// a shape-reporting format, and showing centroid.  each pixel is shown as
-// (wedge # % 26) + 'a', and (closest pixel to) centroid is in uppercase, or
-// a * if not actually a white pixel.  (use same letter for opposite wedges.)
-
-// list of wedges in angle order, showing their angles (center & bounds),
-// on/off/included pixel counts, and optionally list of all pixels in them
-
-// should show the angles to the bounding box corners, for comparison
-
-// list of wedges in percentile order, showing their percentiles, angles, etc.
-
-// debug option to draw line through the max angle - better, draw bounding box
-// (+1 on all sides), with lines from bounding box edges outward (20 pixels
-// for len, 10 for width)
-
-//   x|260 264 268 272 276
-// y: +-+-|-+---+---+-|-+-+
-// 120|...................|
-// 121|...................|
-// 122|...................|
-// 123=.....11111.........=
-// 124|...111***1111......|
-// 125|....111**C**111....|
-// 126|......111**11111...|
-// 127=........1111.......=
-// 128|...................|
-// 129|...................|
-// 130|...................|
-//    +---|-----------|---+

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidParticle.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidParticle.h	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidParticle.h	2009-10-02 05:22:11 UTC (rev 5365)
@@ -1,851 +0,0 @@
-/***************************************************************************
-                          ADM_vidParticle.h  -  detect particles (groups of pixels)
-                              -------------------
-                          Chris MacGregor, 2005, 2007
-                         chris-avidemux at bouncingdog.com
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
- 
-#ifndef __PARTICLE__
-#define __PARTICLE__   
-
-#include <string>
-#include <algorithm>
-#include <math.h>
-
-
-struct PARTICLE_PARAM
-{
-    uint32_t min_area;
-    uint32_t max_area;
-    uint32_t left_crop;
-    uint32_t right_crop;
-    uint32_t top_crop;
-    uint32_t bottom_crop;
-    uint32_t output_format;
-    std::string output_file;
-    uint32_t camera_number;
-    uint32_t min_dim_pctile;
-    uint32_t max_dim_pctile;
-    uint32_t debug;
-};
-
-// Alas, because offsetof() is only supposed to work on POD (plain old data)
-// structs, and our PARTICLE_PARAM includes a std::string (which has a
-// constructor, and which causes PARTICLE_PARAM to therefore have an implicit
-// constructor), we need to define our own offsetof() to use for the dialog
-// menus.  See
-// http://www.cplusplus.com/reference/clibrary/cstddef/offsetof.html for more
-// on offsetof().
-
-#define my_offsetof(_type, _memb) (size_t (&(((_type *)1)->_memb)) - 1)
-
-class ADMVideoParticle : public AVDMGenericVideoStream
-{
-
- protected:
-    	
-     PARTICLE_PARAM *  _param;
-
-     static FILE * outfp; // ugly, but hard to avoid
-     static uint32_t last_frame_written; // ditto
-
- public:
- 		
-     enum OutputFmt
-     {
-         OUTPUTFMT_INVALID = 0,
-
-         OUTPUTFMT_FORMAT_NEW,
-         OUTPUTFMT_FORMAT_DG_UWA,
-         OUTPUTFMT_FORMAT_AB_ODU,
-         OUTPUTFMT_FORMAT_OLD,
-
-         OUTPUTFMT_COUNT
-     };
-
-     ADMVideoParticle (AVDMGenericVideoStream *in, CONFcouple *setup);
-
-     ~ADMVideoParticle();
-
-     virtual uint8_t getFrameNumberNoAlloc (uint32_t frame, uint32_t *len,
-                                            ADMImage *data,uint32_t *flags);
-
-     virtual uint8_t configure (AVDMGenericVideoStream *instream);
-     virtual char * printConf (void);
-     virtual uint8_t getCoupledConf (CONFcouple **couples);
-							
-     static uint8_t doParticle (ADMImage * image, ADMImage * data,
-                                AVDMGenericVideoStream * in,
-                                uint32_t real_frame,
-                                FILE * do_outfp,
-                                PARTICLE_PARAM * param,
-                                uint32_t width, uint32_t height);
-};
-
-//////////////////////////////////////////////////////////////////////////////
-
-#include <list>
-//#include <vector>
-//#include <iostream>
-#include <iterator>
-
-class PixelLoc
-{
-public:
-    uint16_t x;
-    uint16_t y;
-
-    PixelLoc ()
-        : x (0),
-          y (0)
-    {
-    }
-
-    PixelLoc (uint32_t a_x, uint32_t a_y)
-        : x (a_x),
-          y (a_y)
-    {
-    }
-
-    // Use this to sort by y's, then (for PixelLoc's with the same y) by x's.
-
-    class Compare
-    {
-    public:
-        int operator () (const PixelLoc & p1, const PixelLoc & p2) const
-        {
-            return ((p1.y == p2.y) ? (p1.x < p2.x) : (p1.y < p2.y));
-        }
-    };
-
-    bool operator == (const PixelLoc & rhs)
-    {
-        return (x == rhs.x && y == rhs.y);
-    }
-
-    static const PixelLoc INVALID;
-};
-
-//typedef std::vector <PixelLoc> PixelLocVec;
-/*
-inline std::ostream &
-operator << (std::ostream & s, const PixelLoc & pl)
-{
-    return s << "(" << pl.x << "," << pl.y << ")";
-}
-
-inline std::ostream &
-operator << (std::ostream & s, const PixelLocVec & theList)
-{
-    s << "[ ";
-    std::copy (theList.begin(), theList.end(),
-               std::ostream_iterator <PixelLoc> (s, " "));
-    s << "]";
-    return s;
-}
-*/
-class ImageTool;
-
-#ifdef OLD_PARTICLE_WEDGE_SCHEME
-
-class Particle_Old
-{
-    struct Wedge
-    {
-        // HERE: if we're only counting white pixels, then we actually don't
-        // need any of the three vectors except for debugging output - we
-        // could just keep a count of pixels and that would be enough.
-
-        uint32_t pixel_count;
-        std::vector <float> pixel_distance;
-        PixelLocVec pixel_locs; // used only for debug output, else empty
-        std::vector <char> is_white; // faster than vector<bool>
-        float max_white_distance;
-        float min_angle;
-        float center_angle;
-        float max_angle;
-        float percentile;
-
-    private: // probably we don't need the default ctor - let's see...
-        Wedge ()
-            : pixel_count (0),
-              max_white_distance (-1),
-              min_angle (-10 * M_PI),
-              center_angle (-10 * M_PI),
-              max_angle (-10 * M_PI),
-              percentile (-1)
-        {
-        }
-    public:
-
-        Wedge (float angle, float half_arc)
-            : pixel_count (0),
-              max_white_distance (-1),
-              min_angle (angle - half_arc),
-              center_angle (angle),
-              max_angle (angle + half_arc),
-              percentile (-1)
-        {
-        }
-
-        void add_pixel (uint16_t x, uint16_t y)
-        {
-            ++pixel_count;
-            pixel_locs.push_back (PixelLoc (x, y));
-        }
-
-        void add_pixel (uint16_t x, uint16_t y, bool is_it_white, float distance)
-        {
-            ++pixel_count;
-            is_white.push_back (is_it_white);
-            if (is_it_white && max_white_distance < distance)
-                max_white_distance = distance;
-            pixel_distance.push_back (distance);
-            pixel_locs.push_back (PixelLoc (x, y));
-        }
-
-        Wedge & operator += (const Wedge & rhs)
-        {
-            pixel_count += rhs.pixel_count;
-            pixel_distance.insert (pixel_distance.end(),
-                                   rhs.pixel_distance.begin(),
-                                   rhs.pixel_distance.end());
-            pixel_locs.insert (pixel_locs.end(),
-                               rhs.pixel_locs.begin(),
-                               rhs.pixel_locs.end());
-            is_white.insert (is_white.end(),
-                             rhs.is_white.begin(),
-                             rhs.is_white.end());
-            if (rhs.max_white_distance > max_white_distance)
-                max_white_distance = rhs.max_white_distance;
-
-            return *this;
-        }
-
-        class Less
-        {
-        public:
-            bool operator () (const Wedge & lhs, const Wedge & rhs) const
-            {
-                return (lhs.pixel_count < rhs.pixel_count);
-            }
-        };
-
-        void trim_to_edge ();
-    };
-
-    //typedef std::vector <Wedge> WedgeVec;
-
-    struct WedgePair
-    {
-        float angle;
-        uint32_t pixel_count;
-
-        WedgePair (float angle, uint32_t pixel_count)
-            : angle (angle),
-              pixel_count (pixel_count)
-        {
-        }
-
-        class Less
-        {
-        public:
-            bool operator () (const WedgePair & lhs,
-                              const WedgePair & rhs) const
-            {
-                return (lhs.pixel_count < rhs.pixel_count);
-            }
-        };
-    };
-
-    typedef std::vector <WedgePair> WedgePairVec;
-
-public:
-    uint16_t minx, maxx; // bounding box x
-    uint16_t miny, maxy; // bounding box y
-    uint32_t area;
-    float centroidX, centroidY;
-
-private:
-    uint32_t sumOfXs;
-    uint32_t sumOfYs;
-    uint32_t num_wedges;
-    // doubles used to minimize error accumulation when generating wedges
-    double wedge_arc;
-    double half_wedge_arc;
-
-    PixelLocVec outline;
-    PixelLocVec white_pixels;
-    //WedgeVec wedges;
-    WedgePairVec wedge_pairs;
-
-public:
-    Particle ()
-    {
-        init();
-    }
-
-private:
-    void init ()
-    {
-        minx = 0xffff;
-        maxx = 0;
-        miny = 0xffff;
-        maxy = 0;
-        area = 0;
-        centroidX = -1;
-        centroidY = -1;
-        sumOfXs = 0;
-        sumOfYs = 0;
-        num_wedges = 0;
-        wedge_arc = -1;
-        half_wedge_arc = -1;
-        outline.clear();
-        white_pixels.clear();
-        wedges.clear();
-        wedge_pairs.clear();
-    }
-
-    void init_wedges ();
-
-    void addWhitePixel (uint16_t x, uint16_t y)
-    {
-        ++area;
-        sumOfXs += x;
-        if (x < minx)
-            minx = x;
-        if (x > maxx)
-            maxx = x;
-        sumOfYs += y;
-        if (y < miny)
-            miny = y;
-        if (y > maxy)
-            maxy = y;
-        white_pixels.push_back (PixelLoc (x, y));
-    }
-
-    void computeCentroid ()
-    {
-        if (!area)
-        {
-            fprintf (stderr, "Can't compute centroid of zero-pixel particle!\n");
-            centroidX = 0;
-            centroidY = 0;
-            return;
-        }
-        centroidX = float (sumOfXs) / area;
-        centroidY = float (sumOfYs) / area;
-    }
-
-public:
-    const WedgePair & getMinDim () const
-    {
-        WedgePairVec::const_iterator wit = wedge_pairs.begin();
-        while (!wit->pixel_count)
-            ++wit;
-        return *wit;
-    }
-
-    const WedgePair & getMaxDim () const
-    {
-        WedgePairVec::const_iterator wit = wedge_pairs.end();
-        return *--wit;
-    }
-
-    uint32_t getMinDimCount () const
-    {
-        return getMinDim().pixel_count;
-    }
-
-    uint32_t getMaxDimCount () const
-    {
-        return getMaxDim().pixel_count;
-    }
-
-    float getMinDimAngle () const
-    {
-        return getMinDim().angle;
-    }
-
-    float getMaxDimAngle () const
-    {
-        return getMaxDim().angle;
-    }
-
-    friend class ImageTool;
-};
-
-#else // ! OLD_PARTICLE_WEDGE_SCHEME
-
-class Particle
-{
-    struct Wedge
-    {
-        float max_white_distance;
-        float angle_for_mwd;
-        float min_angle;
-        float center_angle;
-        float max_angle;
-        float percentile;
-
-        Wedge (float angle, float half_arc)
-            : max_white_distance (.5), // minimum width is 1
-              angle_for_mwd (angle),
-              min_angle (angle - half_arc),
-              center_angle (angle),
-              max_angle (angle + half_arc),
-              percentile (-1)
-        {
-        }
-
-        void add_pixel (uint16_t x, uint16_t y, float distance, float angle)
-        {
-            if (max_white_distance < distance)
-            {
-                max_white_distance = distance;
-                angle_for_mwd = angle;
-            }
-        }
-
-        Wedge & operator += (const Wedge & rhs)
-        {
-            if (rhs.max_white_distance > max_white_distance)
-            {
-                max_white_distance = rhs.max_white_distance;
-                angle_for_mwd = rhs.angle_for_mwd;
-            }
-
-            return *this;
-        }
-
-        class Less
-        {
-        public:
-            bool operator () (const Wedge & lhs, const Wedge & rhs) const
-            {
-                return (lhs.max_white_distance < rhs.max_white_distance);
-            }
-        };
-    };
-
-    //typedef std::vector <Wedge> WedgeVec;
-
-    struct WedgePair
-    {
-        float angle;
-        float total_distance;
-
-        WedgePair (const Wedge & w1, const Wedge & w2)
-            : total_distance (w1.max_white_distance + w2.max_white_distance)
-        {
-            float a1 = w1.angle_for_mwd;
-            float a2 = w2.angle_for_mwd;
-            if (a1 > a2)
-                std::swap (a1, a2);
-            a1 += M_PI;
-            float avg = (a1 + a2) / 2;
-            if (avg < 0)
-                avg += M_PI;
-            angle = avg;
-        }
-
-        class Less
-        {
-        public:
-            bool operator () (const WedgePair & lhs,
-                              const WedgePair & rhs) const
-            {
-                return (lhs.total_distance < rhs.total_distance);
-            }
-        };
-    };
-
-    //typedef std::vector <WedgePair> WedgePairVec;
-
-public:
-    uint16_t minx, maxx; // bounding box x
-    uint16_t miny, maxy; // bounding box y
-    uint32_t area;
-    float centroidX, centroidY;
-
-    struct BestFit
-    {
-        float length;
-        float length_angle;
-        float width;
-        float width_angle;
-
-        BestFit ()
-            : length (-1),
-              length_angle (0),
-              width (-1),
-              width_angle (0)
-        {
-        }
-    };
-
-private:
-    uint32_t debug;
-    uint32_t sumOfXs;
-    uint32_t sumOfYs;
-    uint32_t num_wedges;
-    // doubles used to minimize error accumulation when generating wedges
-    double wedge_interval; // 2*PI / num_wedges
-    double wedge_arc;      // is > wedge_interval if overlapped with neighbors
-    double half_wedge_arc;
-    BestFit best_fit;
-
-    //PixelLocVec outline;
-    //PixelLocVec white_pixels;
-    //WedgeVec wedges;
-    //WedgePairVec wedge_pairs;
-
-public:
-    Particle ()
-    {
-        init (debug);
-    }
-
-private:
-    void init (uint32_t a_debug)
-    {
-        minx = 0xffff;
-        maxx = 0;
-        miny = 0xffff;
-        maxy = 0;
-        area = 0;
-        centroidX = -1;
-        centroidY = -1;
-        sumOfXs = 0;
-        sumOfYs = 0;
-        num_wedges = 0;
-        wedge_arc = -1;
-        wedge_interval = -1;
-        half_wedge_arc = -1;
-        best_fit = BestFit();
-        //outline.clear();
-        //white_pixels.clear();
-        //wedges.clear();
-        //wedge_pairs.clear();
-        debug = a_debug;
-    }
-
-    void init_wedges ();
-
-    void addWhitePixel (uint16_t x, uint16_t y)
-    {
-        ++area;
-        sumOfXs += x;
-        if (x < minx)
-            minx = x;
-        if (x > maxx)
-            maxx = x;
-        sumOfYs += y;
-        if (y < miny)
-            miny = y;
-        if (y > maxy)
-            maxy = y;
-        //white_pixels.push_back (PixelLoc (x, y));
-    }
-
-    void computeCentroid ()
-    {
-        if (!area)
-        {
-            fprintf (stderr, "Can't compute centroid of zero-pixel particle!\n");
-            centroidX = 0;
-            centroidY = 0;
-            return;
-        }
-        centroidX = float (sumOfXs) / area;
-        centroidY = float (sumOfYs) / area;
-    }
-
-public:
-    const BestFit & getBestFit () const
-    {
-        return best_fit;
-    }
-
-    const WedgePair & getMinDist () const
-    {
-/*        WedgePairVec::const_iterator wit = wedge_pairs.begin();
-#if 0
-        while (!wit->total_distance)
-            ++wit;
-#endif
-        return *wit; */
-    }
-
-    const WedgePair & getMaxDist () const
-    {
-        /*WedgePairVec::const_iterator wit = wedge_pairs.end();
-        return *--wit; */
-    }
-
-    float getMinDistance () const
-    {
-        return getMinDist().total_distance;
-    }
-
-    float getMaxDistance () const
-    {
-        return getMaxDist().total_distance;
-    }
-
-    float getMinDistAngle () const
-    {
-        return getMinDist().angle;
-    }
-
-    float getMaxDistAngle () const
-    {
-        return getMaxDist().angle;
-    }
-
-    friend class ImageTool;
-};
-
-#endif // ? OLD_PARTICLE_WEDGE_SCHEME
-
-struct PixelOffset
-{
-    int8_t x;
-    int8_t y;
-};
-
-class ImageTool
-{
-private:
-    uint8_t * my_pixels;
-    uint32_t my_w;
-    uint32_t my_h;
-    uint32_t my_left_margin;
-    uint32_t my_right_margin;
-    uint32_t my_top_margin;
-    uint32_t my_bottom_margin;
-    ADMImage * my_outImage;
-    uint32_t my_minArea;
-    uint32_t my_maxArea;
-    uint32_t my_flags;
-    uint32_t debug;
-    Particle my_particle;
-
-    enum TracingDirection
-    {
-        // The order of the members here is important - several things depend
-        // on it!
-
-        DIRECTION_EAST,   // x + 1, y
-        DIRECTION_SOUTH,  // x    , y + 1
-        DIRECTION_WEST,   // x - 1, y
-        DIRECTION_NORTH,  // x    , y - 1
-        DIRECTION_COUNT
-    };
-
-    enum TurnDirection
-    {
-        // These values are designed to be added to TracingDirection values.
-        TURN_RIGHT = 1,
-        TURN_AROUND = 2, // reverse
-        TURN_LEFT = 3,
-    };
-
-    static char directionLetters [];
-    static PixelOffset leftOffset [DIRECTION_COUNT];
-    static PixelOffset aheadOffset [DIRECTION_COUNT];
-
-public:
-    enum Flags
-    {
-        FLAG_NONE = 0,
-        FLAG_DO_SHAPE = 1,
-    };
-
-    ImageTool (uint8_t * pixels, uint32_t w, uint32_t h, ADMImage * outImage = 0,
-               uint32_t flags = 0)
-        : my_pixels (pixels),
-          my_w (w),
-          my_h (h),
-          my_left_margin (0),
-          my_right_margin (w),
-          my_top_margin (0),
-          my_bottom_margin (h),
-          my_outImage (outImage),
-          my_flags (flags),
-          debug (0)
-    {
-    }
-
-    void setCropping (uint32_t left_crop, uint32_t right_crop,
-                      uint32_t top_crop, uint32_t bottom_crop)
-    {
-        my_left_margin = left_crop;
-        my_right_margin = my_w - right_crop;
-        my_top_margin = top_crop;
-        my_bottom_margin = my_h - bottom_crop;
-    }
-
-    // Return true if the pixel is part of a particle.
-
-    bool goodPixel (uint8_t pixel) const
-    {
-        // HERE: If we wanted to incorporate thresholding into this step, or look
-        // for black particles on a white background, this function would be the
-        // place to make the change.
-
-        return (pixel != 0);
-    }
-
-    uint8_t & getPixel (uint32_t x, uint32_t y) const
-    {
-        return my_pixels [(y * my_w) + x];
-    }
-
-    uint8_t & getPixel (uint32_t index) const
-    {
-        return my_pixels [index];
-    }
-
-    // This one does bounds checking, and forces references "off the edge" to
-    // the nearest valid pixel - it's useful for convolutions.  It does not
-    // currently respect the crop settings, only because we know that this
-    // function is used only when those aren't set.
-
-    uint8_t & getPixelSafely (int32_t x, int32_t y) const
-    {
-        if (x < 0)
-            x = 0;
-        else if (x >= my_w)
-            x = my_w - 1;
-
-        if (y < 0)
-            y = 0;
-        else if (y >= my_h)
-            y = my_h - 1;
-
-        return my_pixels [(y * my_w) + x];
-    }
-
-    uint8_t & getPixelSafely (uint32_t x, uint32_t y) const
-    {
-        return getPixelSafely (static_cast <int32_t> (x),
-                               static_cast <int32_t> (y));
-    }
-
-    uint8_t & outPixel (uint32_t x, uint32_t y) const
-    {
-        return YPLANE (my_outImage) [(y * my_w) + x];
-    }
-
-    uint8_t & outUPixel (uint32_t x, uint32_t y) const
-    {
-        return UPLANE (my_outImage) [((y >> 2) * my_w) + (x >> 1)];
-    }
-
-    uint8_t & outVPixel (uint32_t x, uint32_t y) const
-    {
-        return VPLANE (my_outImage) [((y >> 2) * my_w) + (x >> 1)];
-    }
-
-    bool validPixel (uint32_t x, uint32_t y) const
-    {
-        // return (x < my_w && y < my_h);
-        return (x >= my_left_margin && x < my_right_margin
-                && y >= my_top_margin && y < my_bottom_margin);
-    }
-
-    bool goodPixel (uint32_t x, uint32_t y) const
-    {
-        // HERE: this might be a good place to implement ROI (region of
-        // interest) if we want that.
-
-        return (validPixel (x, y) && goodPixel (getPixel (x, y)));
-    }
-
-    uint32_t width () const
-    {
-        return my_w;
-    }
-
-    uint32_t height () const
-    {
-        return my_h;
-    }
-
-#if 0
-    uint32_t particleArea () const
-    {
-        return my_particle.area;
-    }
-
-    float particleCentroidX () const
-    {
-        return my_particle.centroidX;
-    }
-
-    float particleCentroidY () const
-    {
-        return my_particle.centroidY;
-    }
-#endif
-
-    const Particle & getParticle () const
-    {
-        return my_particle;
-    }
-
-    uint8_t autoOutline (uint32_t x, uint32_t y);
-
-    enum ShowStuff
-    {
-        SHOW_NOTHING = 0,
-        SHOW_INPUT          = 0x0001,
-        SHOW_OUTLINE        = 0x0002,
-        SHOW_WEDGE_PIXELS   = 0x0004,
-        SHIFT_PAST_SHOW_FLAGS = 4, // leave room for one more for now
-    };
-
-    void showStuff (ShowStuff what) const;
-
-    // implementation is in ADM_vidSwissArmyKnife.cpp - nothing else uses it
-    // (currently).
-/*
-    template <class Oper, class Histo>
-    void convolve (const std::vector <float> & kernel,
-                   uint32_t kw, uint32_t kh, int32_t bias, const Oper & op,
-                   const Histo & histogram_in); */
-
-    void setDebug (uint32_t newDebug)
-    {
-        debug = newDebug;
-    }
-
-    void setMinArea (uint32_t newMinArea)
-    {
-        my_minArea = newMinArea;
-    }
-
-    void setMaxArea (uint32_t newMaxArea)
-    {
-        my_maxArea = newMaxArea;
-    }
-};
-
-struct MenuMapping;
-uint8_t DIA_particle (AVDMGenericVideoStream *in,
-                      ADMVideoParticle * particlep,
-                      PARTICLE_PARAM * param,
-                      const MenuMapping * menu_mapping,
-                      uint32_t menu_mapping_count);
-
-#endif

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidSwissArmyKnife.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidSwissArmyKnife.cpp	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidSwissArmyKnife.cpp	2009-10-02 05:22:11 UTC (rev 5365)
@@ -1,3252 +0,0 @@
-/***************************************************************************
-                          ADM_vidSwissArmyKnife.cpp  -  Perform one of many
-                                                        possible operations
-                             -------------------
-                          Chris MacGregor, 2005, 2007
-                         chris-avidemux at bouncingdog.com
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
- 
-#include "ADM_default.h"
-
-#include <ctype.h>
-#include <errno.h>
-#include <math.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-
-#include <iostream>
-#include <fstream>
-#include <iterator>
-
-#include "fourcc.h"
-#include "avi_vars.h"
-
-#include "ADM_toolkit/toolkit.hxx"
-#include "ADM_videoFilter.h"
-
-#include "ADM_encoder/ADM_vidEncode.hxx"
-#include "ADM_encoder/adm_encoder.h"
-
-#include "ADM_filter/video_filters.h"
-
-#include "DIA_factory.h"
-
-#include "ADM_vidSwissArmyKnife.h"
-#include "ADM_vidParticle.h" // for ImageTool
-#include "ADM_vidComputeAverage.h" // for ADMVideoComputeAverage::FileHeader
-#include "ADM_userInterfaces/ADM_commonUI/DIA_flyDialog.h" // for MenuMapping
-
-static const int MAX_PIXEL_LUMA = 255;
-
-static FILTER_PARAM swissArmyKnifeParam =
-{
-    16,
-    { "tool", "input_type", "input_file", "load_bias",              // 4
-      "load_multiplier", "input_constant", "memory_constant_alpha", // + 3 = 7
-      "lookahead_n_frames", "init_start_frame", "init_end_frame",   // + 3 = 10
-      "init_by_rolling", "bias", "result_bias",                     // + 3 = 13
-      "result_multiplier", "histogram_frame_interval", "debug"      // + 3 = 16
-    }
-};
-
-ADMVideoSwissArmyKnife::ToolMap ADMVideoSwissArmyKnife::tool_map [] =
-{
-    { TOOL_A,         "A",        "%s",        "%s"     },
-    { TOOL_P,         "P",        "P",         "P"      },
-    { TOOL_P_MINUS_A, "P-A",      "P-%s",      "P - %s" },
-    { TOOL_A_MINUS_P, "A-P",      "%s-P",      "%s - P" },
-    { TOOL_P_PLUS_A,  "P+A",      "P+%s",      "P + %s" },
-    { TOOL_P_TIMES_A, "P*A",      "P*%s",      "P * %s" },
-    { TOOL_P_DIVBY_A, "P/A",      "P/%s",      "P / %s" },
-    { TOOL_A_DIVBY_P, "A/P",      "%s/P",      "%s / P" },
-    { TOOL_MIN_P_A,   "min(P,A)", "min(P,%s)", "min (P, %s)" },
-    { TOOL_MAX_P_A,   "max(P,A)", "max(P,%s)", "max (P, %s)" },
-
-    { TOOL_INVALID, 0, 0, 0 }
-};
-
-// This is a hack to work around the fact that the ctor & dtor get called
-// too often.  The right solution would be to arrange for the filter
-// objects to be constructed and destructed only when really necessary:
-// when a new instance of a filter is added to the list (by the user), it
-// is constructed, and when it is removed from the list (by the user), it
-// is destructed, and anything else is handled by a separate init() or
-// configure() method.  This would allow the objects to maintain a
-// persistent state in a more straightforward way.
-
-ADMVideoSwissArmyKnife::PImap ADMVideoSwissArmyKnife::pimap;
-
-
-SCRIPT_CREATE(swissarmyknife_script,ADMVideoSwissArmyKnife,swissArmyKnifeParam);
-
-BUILD_CREATE(swissarmyknife_create,ADMVideoSwissArmyKnife);
-
-ADMVideoSwissArmyKnife::ADMVideoSwissArmyKnife (AVDMGenericVideoStream *in, CONFcouple *couples)
-{
-    _in = in;
-    memcpy (&_info, in->getInfo(), sizeof(_info));
-    _info.encoding = 1;
-    _uncompressed = new ADMImage (_in->getInfo()->width, _in->getInfo()->height);
-    ADM_assert (_uncompressed);
-    _param = new SWISSARMYKNIFE_PARAM;
-
-    if (couples)
-    {
-        GET(tool);
-        GET(input_type);
-
-        char* tmp;
-        GET2(input_file, tmp);
-        GET(load_bias);
-        GET(load_multiplier);
-
-        GET(input_constant);
-
-        GET(memory_constant_alpha);
-        GET(lookahead_n_frames);
-        GET(init_start_frame);
-        GET(init_end_frame);
-        GET(init_by_rolling);
-
-        GET(bias);
-        GET(result_bias);
-        GET(result_multiplier);
-        GET(histogram_frame_interval);
-        GET(debug);
-
-        _param->enable_preview
-            = (_param->input_type != INPUT_ROLLING_AVERAGE);
-    }
-    else
-    {
-        _param->tool = TOOL_P_MINUS_A;
-        _param->input_type = INPUT_ROLLING_AVERAGE;
-
-        // _param->input_file = ""; // implicit
-        _param->load_bias = 0.0;
-        _param->load_multiplier = 1.0;
-
-        _param->input_constant = 0;
-
-        _param->memory_constant_alpha = 1.0 / _param->init_end_frame;
-        _param->lookahead_n_frames = 0;
-        _param->init_start_frame = 0;
-        _param->init_end_frame = 99;
-        _param->init_by_rolling = false;
-
-        _param->bias = 128;
-        _param->result_bias = 0.0;
-        _param->result_multiplier = 1.0;
-        _param->histogram_frame_interval = 0;
-        _param->debug = 0;
-
-        _param->enable_preview = false;
-    }
-
-    // This is a hack to work around the fact that the ctor & dtor get called
-    // too often.  The right solution would be to arrange for the filter
-    // objects to be constructed and destructed only when really necessary:
-    // when a new instance of a filter is added to the list (by the user), it
-    // is constructed, and when it is removed from the list (by the user), it
-    // is destructed, and anything else is handled by a separate init() or
-    // configure() method.  This would allow the objects to maintain a
-    // persistent state in a more straightforward way.
-
-    // This explicit check wouldn't be necessary if there was an easier way of
-    // ensuring that we got a 0 pointer when a new map entry was auto-consed
-    // up...
-
-    if (pimap.count (couples) == 0)
-    {
-        myInfo = new PersistentInfo;
-        myInfo->conf = couples;
-        pimap [couples] = myInfo;
-    }
-    else
-    {
-        myInfo = pimap [couples];
-        if (couples)
-        {
-            if (myInfo->oldConf == couples)
-            {
-                pimap.erase (myInfo->conf);
-                myInfo->conf = myInfo->oldConf;
-                myInfo->oldConf = 0;
-            }
-            else
-            {
-                ADM_assert (myInfo->conf == couples);
-
-                if (myInfo->oldConf)
-                {
-                    pimap.erase (myInfo->oldConf);
-                    myInfo->oldConf = 0;
-                }
-            }
-        }
-    }
-
-    myInfo->refCount++;
-
-    printf ("ADMVideoSwissArmyKnife ctor (%p, conf = %p), pi = %p, rc now %d\n",
-            this, couples, myInfo, myInfo->refCount);
-}
-
-uint8_t	ADMVideoSwissArmyKnife::getCoupledConf (CONFcouple **couples)
-{
-
-    ADM_assert (_param);
-    *couples = new CONFcouple (swissArmyKnifeParam.nb);
-
-    // This is a hack to work around the fact that the ctor & dtor get called
-    // too often.  The right solution would be to arrange for the filter
-    // objects to be constructed and destructed only when really necessary:
-    // when a new instance of a filter is added to the list (by the user), it
-    // is constructed, and when it is removed from the list (by the user), it
-    // is destructed, and anything else is handled by a separate init() or
-    // configure() method.  This would allow the objects to maintain a
-    // persistent state in a more straightforward way.
-
-    printf("ADMVideoSwissArmyKnife::getCoupledConf(): this = %p, couples = %p, "
-           "oldConf = %p (was %p), pi = %p\n",
-           this, *couples, myInfo->conf, myInfo->oldConf, myInfo);
-
-    if (myInfo->oldConf)
-        pimap.erase (myInfo->oldConf);
-    myInfo->oldConf = myInfo->conf;
-    myInfo->conf = *couples;
-    pimap [myInfo->conf] = myInfo;
-    if (myInfo->oldConf == 0)
-        pimap.erase (0);
-
-    CSET(tool);
-    CSET(input_type);
-
-    (*couples)->setCouple("input_file", _param->input_file.c_str());
-    CSET(load_bias);
-    CSET(load_multiplier);
-
-    CSET(input_constant);
-
-    CSET(memory_constant_alpha);
-    CSET(lookahead_n_frames);
-    CSET(init_start_frame);
-    CSET(init_end_frame);
-    CSET(init_by_rolling);
-
-    CSET(bias);
-    CSET(result_bias);
-    CSET(result_multiplier);
-    CSET(histogram_frame_interval);
-    CSET(debug);
-
-    return 1;
-}
-
-uint8_t ADMVideoSwissArmyKnife::configure (AVDMGenericVideoStream *in)
-{
-    diaMenuEntry tTool [] = {
-        { TOOL_A,          QT_TR_NOOP("P' = A"), NULL },
-        { TOOL_P,          QT_TR_NOOP("P' = P"), NULL },
-        { TOOL_P_MINUS_A,  QT_TR_NOOP("P' = P - A"), NULL },
-        { TOOL_A_MINUS_P,  QT_TR_NOOP("P' = A - P"), NULL },
-        { TOOL_P_PLUS_A,   QT_TR_NOOP("P' = P + A"), NULL },
-        { TOOL_P_TIMES_A,  QT_TR_NOOP("P' = P * A"), NULL },
-        { TOOL_P_DIVBY_A,  QT_TR_NOOP("P' = P / A"), NULL },
-        { TOOL_A_DIVBY_P,  QT_TR_NOOP("P' = A / P"), NULL },
-        { TOOL_MIN_P_A,    QT_TR_NOOP("P' = min (P, A)"), NULL },
-        { TOOL_MAX_P_A,    QT_TR_NOOP("P' = max (P, A)"), NULL }
-    };
-
-    diaMenuEntry tInputType [] = {
-        { INPUT_CUSTOM_CONVOLUTION,
-          QT_TR_NOOP("A = convolve(P); Load convolution kernel from file"), NULL },
-        { INPUT_FILE_IMAGE_FLOAT,
-          QT_TR_NOOP("A = pixel from image file as float; Load image from file"), NULL },
-        { INPUT_FILE_IMAGE_INTEGER,
-          QT_TR_NOOP("A = pixel from image file as integer; Load image from file"), NULL },
-        { INPUT_CONSTANT_VALUE,
-          QT_TR_NOOP("A = floating point constant value"), NULL },
-        { INPUT_ROLLING_AVERAGE,
-          QT_TR_NOOP("A = rolling average of pixel: A = A*(1-alpha)+(P*alpha)"), NULL },
-    };
-
-    diaElemMenu tool
-        (&(_param->tool),
-         QT_TR_NOOP("Select _Operation on each pixel P and input A:"),
-         sizeof (tTool) / sizeof (diaMenuEntry), tTool);
-
-    diaElemMenu input_type
-        (&(_param->input_type),
-         QT_TR_NOOP("Input _Type:"),
-         sizeof (tInputType) / sizeof (diaMenuEntry), tInputType);
-
-    MenuMapping menu_mapping [] = {
-        { "operationMenu", my_offsetof (SWISSARMYKNIFE_PARAM, tool),
-          sizeof (tTool) / sizeof (diaMenuEntry), tTool },
-        { "inputTypeMenu", my_offsetof (SWISSARMYKNIFE_PARAM, input_type),
-          sizeof (tInputType) / sizeof (diaMenuEntry), tInputType },
-    };
-
-    // printf ("ADM_vidSwissArmyKnife: _param = %p\n", _param);
-    uint8_t ret = DIA_SwissArmyKnife (_in, this, _param, menu_mapping,
-                                      sizeof (menu_mapping)
-                                      / sizeof (MenuMapping));
-    if (ret == 1)
-    {
-        return ret;
-    }
-    else if (ret == 0) // 0 = cancel
-    {
-        return ret;
-    }
-    else
-    {
-        ADM_assert (ret == 255); // 255 = whizzy dialog not implemented
-    }
-
-    char * file = ADM_strdup (_param->input_file.c_str());
-
-    diaElemFile input_file
-        (0, &file,
-         QT_TR_NOOP("Input _File (image or convolution kernel):"), NULL, QT_TR_NOOP("Select file"));
-    diaElemFloat load_bias
-        (&(_param->load_bias),
-         QT_TR_NOOP("_Load Bias (added to each pixel\n"
-           "in file image when loaded):"),
-         -99999, +99999); // arbitrary!
-    diaElemFloat load_multiplier
-        (&(_param->load_multiplier),
-         QT_TR_NOOP("Load _Multiplier (each pixel in\n"
-           "file image mult. by this when loaded):"),
-         -99999, +99999); // arbitrary!
-
-    diaElemFloat input_constant
-        (&(_param->input_constant),
-         QT_TR_NOOP("Input _Constant:"), -99999, +99999); // arbitrary!
-
-    diaElemFloat memory_constant_alpha
-        (&(_param->memory_constant_alpha),
-         QT_TR_NOOP("Memory constant _alpha\n"
-           "(where A = (1-alpha)*A + alpha*(curr_frame + lookahead)):"),
-         0, 0x7fffffff);
-    diaElemUInteger lookahead_n_frames
-        (&(_param->lookahead_n_frames),
-         QT_TR_NOOP("Look ahead _N frames:"),
-         0, 0x7fffffff);
-    diaElemUInteger init_start_frame
-        (&(_param->init_start_frame),
-         QT_TR_NOOP("Init _Start Frame (first frame # to use for head start):"),
-         0, 0x7fffffff);
-    diaElemUInteger init_end_frame
-        (&(_param->init_end_frame),
-         QT_TR_NOOP("Init _End Frame (last frame # to use for head start):"),
-         0, 0x7fffffff);
-    diaElemToggle init_by_rolling
-        (&(_param->init_by_rolling),
-         QT_TR_NOOP("Init By _Rolling (compute head start using a "
-           "rolling average rather than a straight average)"));
-
-    diaElemSlider bias
-        (&(_param->bias),
-         QT_TR_NOOP("_Bias (will be added to result):"), -256, +256);
-    diaElemFloat result_bias
-        (&(_param->result_bias),
-         QT_TR_NOOP("_Result Bias (added to each result pixel):"),
-         -99999, +99999); // arbitrary!
-    diaElemFloat result_multiplier
-        (&(_param->result_multiplier),
-         QT_TR_NOOP("Result _Multiplier (each result pixel\n"
-           "multiplied by this):"),
-         -99999, +99999); // arbitrary!
-    diaElemUInteger histogram_frame_interval
-        (&(_param->histogram_frame_interval),
-         QT_TR_NOOP("_Histogram every N frames (0 to disable):"), 0, 0x7fffffff);
-    diaElemUInteger debug
-        (&(_param->debug), QT_TR_NOOP("_Debugging settings (bits):"), 0, 0x7fffffff);
-
-    diaElem * elems[] = { &tool, &input_type, &input_file, &load_bias,
-                          &load_multiplier, &input_constant,
-                          &memory_constant_alpha, &lookahead_n_frames,
-                          &init_start_frame, &init_end_frame,
-                          &init_by_rolling, &bias, &result_bias,
-                          &result_multiplier, &histogram_frame_interval,
-                          &debug };
-
-    ret = diaFactoryRun (QT_TR_NOOP("Swiss Army Knife Configuration"),
-                         sizeof (elems) / sizeof (diaElem *), elems);
-    if (ret) // 0 = cancel
-    {
-        myInfo->image_data_invalid = true;
-        myInfo->histogram_data_invalid = true;
-    }
-
-    _param->input_file = file;
-    delete[] file;
-
-    return ret;
-}
-
-ADMVideoSwissArmyKnife::~ADMVideoSwissArmyKnife()
-{
-    // This is a hack to work around the fact that the ctor & dtor get called
-    // too often.  The right solution would be to arrange for the filter
-    // objects to be constructed and destructed only when really necessary:
-    // when a new instance of a filter is added to the list (by the user), it
-    // is constructed, and when it is removed from the list (by the user), it
-    // is destructed, and anything else is handled by a separate init() or
-    // configure() method.  This would allow the objects to maintain a
-    // persistent state in a more straightforward way.
-
-    myInfo->refCount--;
-    printf ("ADMVideoSwissArmyKnife dtor (%p), conf = %p, pi = %p, rc now %d\n",
-            this, myInfo->conf, myInfo, myInfo->refCount);
-
-    if (myInfo->oldConf)
-    {
-        pimap.erase (myInfo->oldConf);
-        myInfo->oldConf = 0;
-    }
-
-    if (myInfo->refCount < 1)
-    {
-        pimap.erase (myInfo->conf);
-        delete myInfo;
-    }
-
-    DELETE(_param);
-    delete _uncompressed;
-    _uncompressed = NULL;
-}
-
-char * ADMVideoSwissArmyKnife::printConf ()
-{
-    return getConf (_param, false);
-}
-
-char * ADMVideoSwissArmyKnife::getConf (SWISSARMYKNIFE_PARAM * param,
-                                        bool forDialog)
-{
-    const int CONF_LEN = 1024;
-    static char conf[CONF_LEN];
-
-    ToolMap * tm;
-    for (tm = tool_map; tm->outputName; tm++)
-        if (tm->toolid == param->tool)
-            break;
-
-    char inputstr [CONF_LEN];
-    char where [256];
-    where[0] = '\0';
-    char moreinfo [256];
-    moreinfo[0] = '\0';
-    const char * input_file = param->input_file.c_str();
-    if (!input_file || !*input_file)
-        input_file = "**** no file selected ****";
-
-    const char * space = forDialog ? " " : "";
-    char * cptr;
-
-    switch (param->input_type)
-    {
-    case INPUT_CUSTOM_CONVOLUTION:
-        snprintf (inputstr, CONF_LEN, "convolve%s(P,%s%s)",
-                  space, space, input_file);
-        break;
-    case INPUT_FILE_IMAGE_FLOAT:
-        snprintf (inputstr, CONF_LEN,
-                  (param->load_bias == 0.0 && param->load_multiplier == 1.0)
-                  ? "pixel_from%s(%s)"
-                  : (forDialog ? "((pixel_from%s(%s) + %.6f) * %.6f)"
-                     : "((pixel_from%s(%s)%+.6f)*%.6f)"),
-                  space, input_file,
-                  param->load_bias, param->load_multiplier);
-        break;
-    case INPUT_FILE_IMAGE_INTEGER:
-        snprintf (inputstr, CONF_LEN,
-                  (param->load_bias == 0.0 && param->load_multiplier == 1.0)
-                  ? "integer(pixel_from%s(%s))"
-                  : (forDialog ? "integer((pixel_from%s(%s) + %.6f) * %.6f)"
-                     : "integer((pixel_from%s(%s)%+.6f)*%.6f)"),
-                  space, input_file,
-                  param->load_bias, param->load_multiplier);
-        break;
-    case INPUT_CONSTANT_VALUE:
-        if (int (param->input_constant) == param->input_constant)
-            sprintf (inputstr, "%d", int (param->input_constant));
-        else
-            sprintf (inputstr, "%.6f", param->input_constant);
-        break;
-    case INPUT_ROLLING_AVERAGE:
-        sprintf (inputstr, "A");
-        cptr = where + sprintf (where, " (where each frame, "
-                                "A=(A*(1-alpha))+(P*alpha), alpha%s=%s%.6f",
-                                space, space, param->memory_constant_alpha);
-        if (param->lookahead_n_frames)
-            sprintf (cptr, ", P = pixel from %d frames ahead)",
-                     param->lookahead_n_frames);
-        else
-            strcpy (cptr, ")");
-        if (param->init_start_frame <= param->init_end_frame)
-            sprintf (moreinfo, ", initial A = %s avg of frames %u - %u",
-                     param->init_by_rolling ? "rolling" : "straight",
-                     param->init_start_frame, param->init_end_frame);
-        break;
-    default:
-        sprintf (inputstr, "OOOPS!! (unexpected type %d)",
-                 param->input_type);
-        break;
-    }
-
-    cptr = conf;
-
-    bool result_is_scaled
-        = (param->result_bias != 0.0 || param->result_multiplier != 1.0);
-
-    if (!forDialog)
-        cptr += snprintf (conf, CONF_LEN, "Swiss Army Knife: ");
-    cptr += snprintf (cptr, CONF_LEN - (cptr - conf), "P' = %s",
-                      result_is_scaled ? "((" : "");
-    cptr += snprintf (cptr, CONF_LEN - (cptr - conf),
-                      forDialog ? tm->spacy_format : tm->format, inputstr);
-    if (param->bias)
-        cptr += snprintf (cptr, CONF_LEN - (cptr - conf),
-                          forDialog ? " + %d" : "%+d", param->bias);
-    cptr += snprintf (cptr, CONF_LEN - (cptr - conf), "%s", where);
-    if (result_is_scaled)
-        cptr += snprintf (cptr, CONF_LEN - (cptr - conf),
-                          forDialog ? ") + %.6f) * %.6f" : ")%+.6f)*%.6f",
-                          param->result_bias, param->result_multiplier);
-    cptr += snprintf (cptr, CONF_LEN - (cptr - conf), "%s", moreinfo);
-    if (param->histogram_frame_interval)
-        cptr += snprintf (cptr, CONF_LEN - (cptr - conf),
-                          ", histogram every %u frames",
-                          param->histogram_frame_interval);
-    if (param->debug)
-        cptr += snprintf (cptr, CONF_LEN - (cptr - conf),
-                          ", debug%s=%s0x%x", space, space, param->debug);
-    if (!forDialog)
-        fprintf (stderr, "SAK conf is (%d) \"%s\"\n", cptr - conf, conf);
-    return conf;
-}
-
-//============================================================================
-
-// Note: The structure of the following code (with the template functions, and
-// the functor objects, etc.) is all about minimizing the code executed
-// per-pixel.  We need to select an input (convolution, etc.), and an
-// operation to apply that input to each pixel (P' = P - A, etc.), and
-// optionally scale the result, and optionally collect a histogram...but we
-// don't want any more if's or pointer (or reference dereferences) in the
-// per-pixel core of the loop than we absolutely must have, and we certainly
-// don't want any switches or function calls.  At the same time, we don't want
-// to duplicate the code that humans have to deal with - that's the whole
-// point of templates.  So, buckle your seat belts, because this is where C++
-// gets really fun!
-
-//============================================================================
-
-class HistogramNull // do-nothing version
-{
-public:
-    static
-    void reset()
-    {
-    }
-    static
-    void record_input (uint8_t P)
-    {
-    }
-    static
-    void record_output (int32_t P)
-    {
-    }
-    static
-    void dump (uint32_t frame_count, uint32_t pixels_per_frame)
-    {
-    }
-    static
-    bool frame_check ()
-    {
-        return false;
-    }
-};
-
-//----------------------------------------------------------------------------
-
-class Histogram
-{
-public:
-    // Optionally, we could make this a template class with range_size a
-    // template parameter.  However, it would have to be used in more than one
-    // place, with different range sizes, for that to be worth doing.
-
-    static const int32_t input_range_size = 256; // 8 bit pixels
-    static const int32_t range_size = 1024; // This must be a power of 2!
-    static const int32_t midpoint = 128;
-    static const int32_t range_min = midpoint - (range_size / 2);
-    static const int32_t range_max = midpoint + (range_size / 2) - 1;
-    static const int32_t out_of_range_mask = ~(range_size - 1);
-
-    uint32_t * input_data;
-    uint32_t * output_data;
-    uint32_t pixels_per_frame;
-    uint32_t & frame_count;
-    uint32_t frame_interval;
-
-    // The default copy ctor and assignment operators are just fine in this
-    // case!  Also, note that the ctor allocates the memory and sets the
-    // pointers to which it is passed references, but does not keep the
-    // references (since it won't need to change those pointers again) - it
-    // keeps local copies instead, to avoid later indirections.  It does store
-    // a reference to the frame_count for use in frame_check().
-
-    Histogram (uint32_t * & input_data_ref, uint32_t * & output_data_ref,
-               uint32_t frame_interval, uint32_t & frame_count,
-               uint32_t pixels_per_frame)
-        : input_data (input_data_ref),
-          output_data (output_data_ref),
-          pixels_per_frame (pixels_per_frame),
-          frame_count (frame_count),
-          frame_interval (frame_interval)
-    {
-        if (!input_data)
-        {
-            input_data = input_data_ref = new uint32_t [input_range_size];
-            output_data = output_data_ref = new uint32_t [range_size];
-            // printf ("histogram: allocated data at %p, %p\n",
-            //         input_data, output_data);
-            reset();
-        }
-        else
-            ;// printf ("histogram: using data at %p, %p\n",
-             //         input_data, output_data);
-    }
-
-    // no dtor needed - deallocation is handled elsewhere
-
-    void reset () const
-    {
-        memset (input_data, 0, input_range_size * sizeof (input_data[0]));
-        memset (output_data, 0, range_size * sizeof (output_data[0]));
-        frame_count = 0;
-    }
-
-    void record_input (uint8_t P) const
-    {
-        input_data[P]++;
-    }
-
-    void record_output (int32_t P) const
-    {
-        P -= range_min; // scale into histogram data array index
-        if ((P & out_of_range_mask) == 0)
-        {
-            output_data[P]++;
-            return;
-        }
-
-        if (P < 0)
-            P = 0;
-        else if (P >= range_size)
-            P = range_size - 1;
-
-        output_data[P]++;
-    }
-
-    void dump () const
-    {
-        int32_t index_min = 0;
-        int32_t index_max = range_size - 1;
-        while (index_min < index_max)
-        {
-            if (output_data[index_min])
-                break;
-            ++index_min;
-        }
-        while (index_min < index_max)
-        {
-            if (output_data[index_max])
-                break;
-            --index_max;
-        }
-        
-        printf ("Swiss Army Knife Histogram for past %u frames:\n"
-                " =================== Input (0 - 255), "
-                "avg/frame over %d frames: ====================\n",
-                frame_count, frame_count);
-        do_dump (input_data, 0, 255, 0);
-        printf ("=========== Result before saturation (%d - %d), "
-                "avg/frame over %d frames: ==========\n",
-                index_min + range_min, index_max + range_min, frame_count);
-        do_dump (output_data, index_min, index_max, range_min);
-    }
-
-    // returns true if it outputs data and resets the counter, else false.
-
-    bool frame_check () const
-    {
-        if (++frame_count < frame_interval)
-        {
-            // printf ("histogram: frame %d of %d\n",
-            //         frame_count, frame_interval);
-            return false;
-        }
-
-        dump();
-        reset();
-        return true;
-    }
-
-private:
-    void do_dump (uint32_t * data, int32_t index_min, int32_t index_max,
-                  int32_t bias) const
-    {
-        // We scan the data to find the maximum value, so we can scale the
-        // bars to provide useful visual data.
-
-        uint32_t max_pixels = 0;
-        for (int32_t index = index_min; index <= index_max; index++)
-        {
-            if (data[index] > max_pixels)
-                max_pixels = data[index];
-        }
-
-        // Effectively, for each pixel-value count, we divide by the frame
-        // count to get the average number of times that pixel value occurred
-        // per frame, and then we scale the bar so that only the max number of
-        // pixels gets 100% of the bar.
-
-        const int32_t bar_max = 11; // hardcoded as %11s in printf below
-#if 0
-        max_pixels /= frame_count;
-        int32_t divisor = frame_count * max_pixels / bar_max;
-#else
-        int32_t divisor = max_pixels / bar_max;
-#endif
-
-        const int32_t columns = 4;
-        // The "+ columns" below is to round up to the total number of rows we
-        // need including partial rows; it's really "+ 1 + (columns - 1)",
-        // where the + 1 is to account for index_max being the top end of the
-        // range, not the top end + 1.
-        int32_t column_len = (index_max - index_min + columns) / columns;
-
-        int32_t column_end = index_min + column_len;
-
-        const char * bar = "*********************************************";
-        const char * bar_end = bar + strlen (bar);
-
-        for (int32_t index = index_min; index < column_end; index++)
-        {
-            int32_t index2 = index;
-            int32_t val = index + bias;
-            
-            for (int32_t column = 0;
-                 column < columns;
-                 ++column, index2 += column_len, val += column_len)
-            {
-                if (index2 > index_max)
-                    break;
-
-                int32_t dat = data[index2];
-                int32_t bar_size = dat / divisor;
-                if (bar_size == 0 && dat != 0)
-                    bar_size = 1;
-#define HISTOGRAM_SHOW_VALUES 1
-#ifdef HISTOGRAM_SHOW_VALUES
-                printf (" %5d: %6d %-11s", val, dat / frame_count, bar_end - bar_size);
-#else
-                printf (" %5d: %-11s", val, bar_end - bar_size);
-#endif
-            }
-            printf ("\n");
-        }
-    }
-};
-
-//============================================================================
-/*
-template <typename Oper, typename Histo>
-void ImageTool::convolve (const std::vector <float> & kernel,
-                          uint32_t kw, uint32_t kh, int32_t bias,
-                          const Oper & op_in, const Histo & histogram_in)
-{
-    // We make local copies of the functors so that the calls below to
-    // record_input() and record_output() (for the histogram) and operator()
-    // (for the op) are accessing stack data rather than incurring yet another
-    // indirection.  When it's per-pixel, every little bit helps!
-
-    Histo histogram = histogram_in;
-    Oper op = op_in;
-
-    uint32_t sathigh = 0;
-    uint32_t satlow = 0;
-
-    // The following code is copied with little significant change (mostly
-    // just porting & performance tweaks, and adding some debugging output)
-    // from ImageJ's Convolver::convolveFloat() function.  Blame them for
-    // variable names like "uc". ;-)
-
-    // We have (for the moment) skipped the normalizing step - we assume that
-    // the scale is 1.0.
-
-    // We also assume that kw and kh are both odd.
-
-    int32_t uc = kw / 2;
-    int32_t vc = kh / 2;
-
-    uint32_t xedge = my_w - uc;
-    uint32_t yedge = my_h - vc;
-
-    for (uint32_t y = 0; y < my_h; y++)
-    {
-        bool y_is_edgy = (y < vc || y >= yedge);
-
-        for (uint32_t x = 0; x < my_w; x++)
-        {
-            float sum = 0;
-            uint32_t i = 0;
-
-            // If some of this pixel's neighbors are "off the edge" of the
-            // input image, we'll use the "safe" getPixel().
-
-            if (y_is_edgy || x < uc || x >= xedge)
-            {
-                for (int32_t v = -vc; v <= vc; v++)
-                    for (int32_t u = -uc; u <= uc; u++)
-                        sum += getPixelSafely (x + u, y + v) * kernel [i++];
-            }
-            else
-            {
-                // HERE: we could optimize this a good bit by putting
-                // &(getPixel(x - uc, y - vc)) into a pointer, then just
-                // incrementing the pointer (and adding a precomputed (my_w -
-                // uc * 2) to shift lines).  It violates the nice
-                // encapsulation provided by ImageTool, but if/when we add a
-                // SIMD version of this loop, that sure isn't going to use
-                // GetPixel()... ;-)
-
-                for (int32_t v = -vc; v <= vc; v++)
-                {
-                    int32_t offset = x + ((y + v) * my_w);
-
-                    for (int32_t u = -uc; u <= uc; u++)
-                        sum += getPixel (offset + u) * kernel [i++];
-                }
-            }
-
-            // as noted above, we're currently assuming the matrix was already
-            // normalized...
-            // sum *= scale;
-
-            int32_t P = getPixel (x, y);
-
-            histogram.record_input (P);
-
-            float A = sum;
-
-            int32_t result = op (P, A) + bias;
-
-            histogram.record_output (result);
-
-            if (result & 0xffffff00)
-            {
-                if (result < 0)
-                {
-                    result = 0;
-                    satlow++;
-                }
-                else // if (result > 255)
-                {
-                    result = 255;
-                    sathigh++;
-                }
-            }
-
-            outPixel (x, y) = result;
-        }
-    }
-
-    if (debug & 2)
-    {
-        if (satlow || sathigh)
-            printf ("    Saturated %d low, %d high\n", satlow, sathigh);
-    }
-}
-*/
-//============================================================================
-
-template <typename Oper, typename Histo>
-void ADMVideoSwissArmyKnife::computeRollingAverage (ADMImage * image,
-                                                    ADMImage * data,
-                                                    uint32_t planesize,
-                                                    SWISSARMYKNIFE_PARAM * param,
-                                                    int32_t bias,
-                                                    const Oper & op_in,
-                                                    const Histo & histogram_in)
-{
-    // We make local copies of the functors so that the calls below to
-    // record_input() and record_output() (for the histogram) and operator()
-    // (for the op) are accessing stack data rather than incurring yet another
-    // indirection.  When it's per-pixel, every little bit helps!
-
-    Histo histogram = histogram_in;
-    Oper op = op_in;
-
-    float alpha = param->memory_constant_alpha;
-    float oneminusalpha = 1 - alpha;
-
-    // HERE: for speed, we do luma (Y plane) only.  However, some
-    // users might want chroma, too... we should make that
-    // an option or something.
-
-    uint8_t * currp = YPLANE (image) + planesize;
-    uint8_t * destp = YPLANE (data) + planesize;
-    float * bgp = myInfo->bg + planesize;
-    uint32_t pixremaining = planesize + 1;
-
-    uint32_t sathigh = 0;
-    uint32_t satlow = 0;
-
-    while (--pixremaining)
-    {
-        int32_t P = *--currp;
-        histogram.record_input (P);
-
-        float A = *--bgp;
-        *bgp = (A * oneminusalpha) + (P * alpha);
-
-        int32_t result = op (P, A) + bias;
-
-        histogram.record_output (result);
-
-        if (result & 0xffffff00)
-        {
-            if (result < 0)
-            {
-                result = 0;
-                satlow++;
-            }
-            else // if (result > 255)
-            {
-                result = 255;
-                sathigh++;
-            }
-        }
-
-        *--destp = result;
-    }
-
-    if (param->debug & 2)
-    {
-        if (satlow || sathigh)
-            printf ("    Saturated %d low, %d high\n", satlow, sathigh);
-    }
-}
-
-//============================================================================
-
-// This one is used in the lookahead case; it takes the additional parameter
-// supplying the lookahead frame.
-
-template <typename Oper, typename Histo>
-void ADMVideoSwissArmyKnife::computeRollingAverage (ADMImage * image,
-                                                    ADMImage * lookaheadimage,
-                                                    ADMImage * data,
-                                                    uint32_t planesize,
-                                                    SWISSARMYKNIFE_PARAM * param,
-                                                    int32_t bias,
-                                                    const Oper & op_in,
-                                                    const Histo & histogram_in)
-{
-    // We make local copies of the functors so that the calls below to
-    // record_input() and record_output() (for the histogram) and operator()
-    // (for the op) are accessing stack data rather than incurring yet another
-    // indirection.  When it's per-pixel, every little bit helps!
-
-    Histo histogram = histogram_in;
-    Oper op = op_in;
-
-    float alpha = param->memory_constant_alpha;
-    float oneminusalpha = 1 - alpha;
-
-    // HERE: for speed, we do luma (Y plane) only.  However, some
-    // users might want chroma, too... we should make that
-    // an option or something.
-
-    uint8_t * currp = YPLANE (image) + planesize;
-    uint8_t * destp = YPLANE (data) + planesize;
-    float * bgp = myInfo->bg + planesize;
-    uint32_t pixremaining = planesize + 1;
-
-    uint32_t sathigh = 0;
-    uint32_t satlow = 0;
-
-    if (lookaheadimage)
-    {
-        uint8_t * aheadp = YPLANE (lookaheadimage) + planesize;
-
-        while (--pixremaining)
-        {
-            int32_t P = *--currp;
-            histogram.record_input (P);
-
-            float A = *--bgp;
-            *bgp = (A * oneminusalpha) + (*--aheadp * alpha);
-
-            int32_t result = op (P, A) + bias;
-
-            histogram.record_output (result);
-
-            if (result & 0xffffff00)
-            {
-                if (result < 0)
-                {
-                    result = 0;
-                    satlow++;
-                }
-                else // if (result > 255)
-                {
-                    result = 255;
-                    sathigh++;
-                }
-            }
-
-            *--destp = result;
-        }
-    }
-    else
-    {
-        while (--pixremaining)
-        {
-            int32_t P = *--currp;
-            histogram.record_input (P);
-
-            float A = *--bgp;
-            // no update of background - the lookahead is looking past the
-            // end of the video
-
-            int32_t result = op (P, A) + bias;
-
-            histogram.record_output (result);
-
-            if (result & 0xffffff00)
-            {
-                if (result < 0)
-                {
-                    result = 0;
-                    satlow++;
-                }
-                else // if (result > 255)
-                {
-                    result = 255;
-                    sathigh++;
-                }
-            }
-
-            *--destp = result;
-        }
-    }
-
-    if (param->debug & 2)
-    {
-        if (satlow || sathigh)
-            printf ("    Saturated %d low, %d high\n", satlow, sathigh);
-    }
-}
-
-//============================================================================
-
-template <typename InputImageType, typename Oper, typename Histo>
-void ADMVideoSwissArmyKnife::applyImage (ADMImage * image, ADMImage * data,
-                                         uint32_t planesize,
-                                         SWISSARMYKNIFE_PARAM * param,
-                                         int32_t bias,
-                                         InputImageType * input_image,
-                                         const Oper & op_in,
-                                         const Histo & histogram_in)
-{
-    // We make local copies of the functors so that the calls below to
-    // record_input() and record_output() (for the histogram) and operator()
-    // (for the op) are accessing stack data rather than incurring yet another
-    // indirection.  When it's per-pixel, every little bit helps!
-
-    Histo histogram = histogram_in;
-    Oper op = op_in;
-
-    // HERE: for speed, we do luma (Y plane) only.  However, some
-    // users might want chroma, too... we should make that
-    // an option or something.
-
-    uint8_t * currp = YPLANE (image) + planesize;
-    uint8_t * destp = YPLANE (data) + planesize;
-    InputImageType * bgp = input_image + planesize;
-    uint32_t pixremaining = planesize + 1;
-
-    uint32_t sathigh = 0;
-    uint32_t satlow = 0;
-
-    while (--pixremaining)
-    {
-        int32_t P = *--currp;
-        histogram.record_input (P);
-
-        InputImageType A = *--bgp;
-        int32_t result = op (P, A) + bias;
-
-        histogram.record_output (result);
-
-        if (result & 0xffffff00)
-        {
-            if (result < 0)
-            {
-                result = 0;
-                satlow++;
-            }
-            else // if (result > 255)
-            {
-                result = 255;
-                sathigh++;
-            }
-        }
-
-        *--destp = result;
-    }
-
-    if (param->debug & 2)
-    {
-        if (satlow || sathigh)
-            printf ("    Saturated %d low, %d high\n", satlow, sathigh);
-    }
-}
-
-//============================================================================
-
-template <typename Oper, typename Histo>
-void ADMVideoSwissArmyKnife::applyConstant (ADMImage * image, ADMImage * data,
-                                            uint32_t planesize,
-                                            SWISSARMYKNIFE_PARAM * param,
-                                            int32_t bias,
-                                            const Oper & op_in,
-                                            const Histo & histogram_in)
-{
-    // We make local copies of the functors so that the calls below to
-    // record_input() and record_output() (for the histogram) and operator()
-    // (for the op) are accessing stack data rather than incurring yet another
-    // indirection.  When it's per-pixel, every little bit helps!
-
-    Histo histogram = histogram_in;
-    Oper op = op_in;
-
-    // HERE: for speed, we do luma (Y plane) only.  However, some
-    // users might want chroma, too... we should make that
-    // an option or something.
-
-    uint8_t * currp = YPLANE (image) + planesize;
-    uint8_t * destp = YPLANE (data) + planesize;
-    float A = param->input_constant;
-    uint32_t pixremaining = planesize + 1;
-
-    uint32_t sathigh = 0;
-    uint32_t satlow = 0;
-
-    while (--pixremaining)
-    {
-        int32_t P = *--currp;
-        histogram.record_input (P);
-
-        int32_t result = op (P, A) + bias;
-
-        histogram.record_output (result);
-
-        if (result & 0xffffff00)
-        {
-            if (result < 0)
-            {
-                result = 0;
-                satlow++;
-            }
-            else // if (result > 255)
-            {
-                result = 255;
-                sathigh++;
-            }
-        }
-
-        *--destp = result;
-    }
-
-    if (param->debug & 2)
-    {
-        if (satlow || sathigh)
-            printf ("    Saturated %d low, %d high\n", satlow, sathigh);
-    }
-}
-
-//============================================================================
-
-class OpPequalsA
-{
-public:
-    int32_t operator () (int32_t P, float A) const
-    {
-        return static_cast <int32_t> (A + .5);
-    }
-
-    int32_t operator () (int32_t P, uint8_t A) const
-    {
-        return A;
-    }
-};
-
-class OpPequalsP
-{
-public:
-    int32_t operator () (int32_t P, float A) const
-    {
-        return P;
-    }
-
-    int32_t operator () (int32_t P, uint8_t A) const
-    {
-        return P;
-    }
-};
-
-class OpPequalsPminusA
-{
-public:
-    int32_t operator () (int32_t P, float A) const
-    {
-        return (P - static_cast <int32_t> (A + .5));
-    }
-
-    int32_t operator () (int32_t P, uint8_t A) const
-    {
-        return (P - A);
-    }
-};
-
-class OpPequalsAminusP
-{
-public:
-    int32_t operator () (int32_t P, float A) const
-    {
-        return (static_cast <int32_t> (A + .5) - P);
-    }
-
-    int32_t operator () (int32_t P, uint8_t A) const
-    {
-        return (A - P);
-    }
-};
-
-class OpPequalsPplusA
-{
-public:
-    int32_t operator () (int32_t P, float A) const
-    {
-        return (P + static_cast <int32_t> (A + .5));
-    }
-
-    int32_t operator () (int32_t P, uint8_t A) const
-    {
-        return (P + A);
-    }
-};
-
-class OpPequalsPtimesA
-{
-public:
-    int32_t operator () (int32_t P, float A) const
-    {
-        return static_cast <int32_t> ((P * A) + .5);
-    }
-
-    int32_t operator () (int32_t P, uint8_t A) const
-    {
-        return (P * A);
-    }
-};
-
-class OpPequalsPdivByA
-{
-public:
-    int32_t operator () (int32_t P, float A) const
-    {
-        return static_cast <int32_t> ((P / A) + .5);
-    }
-
-    int32_t operator () (int32_t P, uint8_t A) const
-    {
-        return (P / A);
-    }
-};
-
-class OpPequalsAdivByP
-{
-public:
-    int32_t operator () (int32_t P, float A) const
-    {
-        return static_cast <int32_t> ((A / P) + .5);
-    }
-
-    int32_t operator () (int32_t P, uint8_t A) const
-    {
-        return (A / P);
-    }
-};
-
-class OpPequalsMinPA
-{
-public:
-    int32_t operator () (int32_t P, float A) const
-    {
-        int32_t intA = static_cast <int32_t> (A + .5);
-        return ((intA > P) ? P : intA);
-    }
-
-    int32_t operator () (int32_t P, uint8_t A) const
-    {
-        return ((A > P) ? P : A);
-    }
-};
-
-class OpPequalsMaxPA
-{
-public:
-    int32_t operator () (int32_t P, float A) const
-    {
-        int32_t intA = static_cast <int32_t> (A + .5);
-        return ((intA > P) ? intA : P);
-    }
-
-    int32_t operator () (int32_t P, uint8_t A) const
-    {
-        return ((A > P) ? A : P);
-    }
-};
-
-//----------------------------------------------------------------------------
-
-class OpPequalsA_Scaled
-{
-    float bias;
-    float multiplier;
-public:
-    OpPequalsA_Scaled (float bias, float multiplier)
-        : bias (bias),
-          multiplier (multiplier)  { }
-
-    int32_t operator () (int32_t P, float A) const
-    {
-        return static_cast <int32_t> (((A + bias) * multiplier) + .5);
-    }
-};
-
-class OpPequalsP_Scaled
-{
-    float bias;
-    float multiplier;
-public:
-    OpPequalsP_Scaled (float bias, float multiplier)
-        : bias (bias),
-          multiplier (multiplier)  { }
-
-    int32_t operator () (int32_t P, float A) const
-    {
-        return static_cast <int32_t> (((P + bias) * multiplier) + .5);
-    }
-};
-
-class OpPequalsPminusA_Scaled
-{
-    float bias;
-    float multiplier;
-public:
-    OpPequalsPminusA_Scaled (float bias, float multiplier)
-        : bias (bias),
-          multiplier (multiplier)  { }
-
-    int32_t operator () (int32_t P, float A) const
-    {
-        return (static_cast <int32_t>
-                ((((P - A) + bias) * multiplier) + .5));
-    }
-};
-
-class OpPequalsAminusP_Scaled
-{
-    float bias;
-    float multiplier;
-public:
-    OpPequalsAminusP_Scaled (float bias, float multiplier)
-        : bias (bias),
-          multiplier (multiplier)  { }
-
-    int32_t operator () (int32_t P, float A) const
-    {
-        return (static_cast <int32_t>
-                ((((A - P) + bias) * multiplier) + .5));
-    }
-};
-
-class OpPequalsPplusA_Scaled
-{
-    float bias;
-    float multiplier;
-public:
-    OpPequalsPplusA_Scaled (float bias, float multiplier)
-        : bias (bias),
-          multiplier (multiplier)  { }
-
-    int32_t operator () (int32_t P, float A) const
-    {
-        return (static_cast <int32_t>
-                ((((P + A) + bias) * multiplier) + .5));
-    }
-};
-
-class OpPequalsPtimesA_Scaled
-{
-    float bias;
-    float multiplier;
-public:
-    OpPequalsPtimesA_Scaled (float bias, float multiplier)
-        : bias (bias),
-          multiplier (multiplier)  { }
-
-    int32_t operator () (int32_t P, float A) const
-    {
-        return (static_cast <int32_t>
-                ((((P * A) + bias) * multiplier) + .5));
-    }
-};
-
-class OpPequalsPdivByA_Scaled
-{
-    float bias;
-    float multiplier;
-public:
-    OpPequalsPdivByA_Scaled (float bias, float multiplier)
-        : bias (bias),
-          multiplier (multiplier)  { }
-
-    int32_t operator () (int32_t P, float A) const
-    {
-        return (static_cast <int32_t>
-                ((((P / A) + bias) * multiplier) + .5));
-    }
-};
-
-class OpPequalsAdivByP_Scaled
-{
-    float bias;
-    float multiplier;
-public:
-    OpPequalsAdivByP_Scaled (float bias, float multiplier)
-        : bias (bias),
-          multiplier (multiplier)  { }
-
-    int32_t operator () (int32_t P, float A) const
-    {
-        return (static_cast <int32_t>
-                ((((A / P) + bias) * multiplier) + .5));
-    }
-};
-
-class OpPequalsMinPA_Scaled
-{
-    float bias;
-    float multiplier;
-public:
-    OpPequalsMinPA_Scaled (float bias, float multiplier)
-        : bias (bias),
-          multiplier (multiplier)  { }
-
-    int32_t operator () (int32_t P, float A) const
-    {
-        return (static_cast <int32_t>
-                ((((A > P ? P : A) + bias) * multiplier) + .5));
-    }
-};
-
-class OpPequalsMaxPA_Scaled
-{
-    float bias;
-    float multiplier;
-public:
-    OpPequalsMaxPA_Scaled (float bias, float multiplier)
-        : bias (bias),
-          multiplier (multiplier)  { }
-
-    int32_t operator () (int32_t P, float A) const
-    {
-        return (static_cast <int32_t>
-                ((((A > P ? A : P) + bias) * multiplier) + .5));
-    }
-};
-
-//============================================================================
-
-uint8_t ADMVideoSwissArmyKnife::getFrameNumberNoAlloc(uint32_t frame,
-                                                      uint32_t *len,
-                                                      ADMImage *data,
-                                                      uint32_t *flags)
-{
-    if (frame >= _info.nb_frames)
-        return 0;
-
-    if (_param->debug & 1)
-        printf ("in ADMVideoSwissArmyKnife::getFrameNumberNoAlloc(%d, ...)\n",
-                frame);
-
-    if (!_in->getFrameNumberNoAlloc (frame, len, _uncompressed, flags))
-        return 0;
-
-    uint32_t planesize = _info.width * _info.height;
-    uint32_t size = (planesize * 3) >> 1;
-    ADMImage * lookaheadimage;
-
-    if (_param->lookahead_n_frames)
-    {
-        if (myInfo->bg_lab_size != planesize)
-        {
-            delete myInfo->bg_lab;
-            myInfo->bg_lab_size = planesize;
-            myInfo->bg_lab = new ADMImage (_info.width, _info.height);
-        }
-
-        if (frame + _param->lookahead_n_frames >= _info.nb_frames)
-            lookaheadimage = 0;
-        else if (!_in->getFrameNumberNoAlloc (frame
-                                              + _param->lookahead_n_frames,
-                                              len, myInfo->bg_lab, flags))
-            return 0;
-        else
-            lookaheadimage = myInfo->bg_lab;
-    }
-    else
-        lookaheadimage = 0;
-
-    // printf ("%s\n", getConf (_param, true));
-
-    *len = size;
-
-    uint8_t ret = doSwissArmyKnife (_uncompressed, lookaheadimage,
-                                    data, _in, this, _param,
-                                    _info.width, _info.height);
-    return ret;
-}
-
-uint8_t
-ADMVideoSwissArmyKnife::doSwissArmyKnife (ADMImage * image,
-                                          ADMImage * lookaheadimage,
-                                          ADMImage * data,
-                                          AVDMGenericVideoStream * in,
-                                          ADMVideoSwissArmyKnife * sak,
-                                          SWISSARMYKNIFE_PARAM * param,
-                                          uint32_t width, uint32_t height)
-{
-    PersistentInfo * myInfo = sak->myInfo;
-    uint32_t debug = param->debug;
-
-    bool doingConvolution = (param->input_type == INPUT_CUSTOM_CONVOLUTION);
-    bool doingRollingAvg = (param->input_type == INPUT_ROLLING_AVERAGE);
-    bool doingFileImage = (param->input_type == INPUT_FILE_IMAGE_FLOAT
-                           || param->input_type == INPUT_FILE_IMAGE_INTEGER);
-    bool doingFileImageFloat = (param->input_type == INPUT_FILE_IMAGE_FLOAT);
-    bool doingApplyConstant = (param->input_type == INPUT_CONSTANT_VALUE);
-
-    bool needRead = false;
-    bool needFile = doingConvolution || doingFileImage;
-
-    if (needFile)
-    {
-        if (myInfo->input_file_name != param->input_file)
-        {
-            myInfo->input_file_name = param->input_file;
-            myInfo->input_file_mtime = 0;
-            printf ("SwissArmyKnife: new input file has been selected: %s\n",
-                    myInfo->input_file_name.c_str());
-            needRead = true;
-        }
-
-        // HERE: we should rearrange a bit to move the stat() call out to the
-        // ctor - we don't need to check it every frame!
-
-        struct stat st;
-        if (stat (myInfo->input_file_name.c_str(), &st) == -1)
-        {
-            perror (myInfo->input_file_name.c_str());
-            return 0;
-        }
-
-        if (st.st_mtime != myInfo->input_file_mtime)
-        {
-            if (!needRead && myInfo->input_file_mtime)
-                printf ("SwissArmyKnife: input file %s has been changed - "
-                        "re-reading it\n", myInfo->input_file_name.c_str());
-            needRead = true;
-            myInfo->input_file_mtime = st.st_mtime;
-        }
-        else if (!needRead && doingFileImage)
-        {
-            if (myInfo->image_data_invalid
-                || myInfo->image_bias != param->load_bias
-                || myInfo->image_multiplier != param->load_multiplier)
-            {
-                needRead = true;
-            }
-        }
-    }
-
-    //FloatVector & kernel = myInfo->kernel;
-    uint32_t & kernel_w = myInfo->kernel_w;
-    uint32_t & kernel_h = myInfo->kernel_h;
-
-    uint32_t planesize = width * height;
-			
-    if (needRead)
-    {
-        myInfo->histogram_data_invalid = true;
-
-        if (doingConvolution)
-        {
-            //kernel.clear();
-            kernel_w = 0;
-            kernel_h = 0;
-
-            using namespace std;
-
-            const char * filename = myInfo->input_file_name.c_str();
-            ifstream inputStream (filename);
-            if (!inputStream)
-            {
-                fprintf (stderr, "SwissArmyKnife: can't open input file %s, "
-                         "but it apparently does exist...(%d)\n",
-                         filename, errno);
-                return 0;
-            }
-
-#ifndef ASSUME_SQUARE_MATRIX
-            // We read the dimensions as floats just in case they happen to be
-            // written that way (no reason to punt) - however, we do expect
-            // that anything to the right of the decimal is 0!
-
-            float dimtmp;
-            inputStream >> dimtmp;
-            kernel_w = uint32_t (dimtmp);
-            if (float (kernel_w) != dimtmp)
-                printf ("SwissArmyKnife: %s: What exactly do you expect a "
-                        "width of %f to mean?  Truncating to %d...\n",
-                        filename, dimtmp, uint32_t (dimtmp));
-            inputStream >> dimtmp;
-            kernel_h = uint32_t (dimtmp);
-            if (float (kernel_h) != dimtmp)
-                printf ("SwissArmyKnife: %s: What exactly do you expect a "
-                        "height of %f to mean?  Truncating to %d...\n",
-                        filename, dimtmp, uint32_t (dimtmp));
-            if (kernel_w < 1 || (kernel_w & 1) == 0
-                || kernel_h < 1 || (kernel_h & 1) == 0)
-            {
-                printf ("SwissArmyKnife: %s: Can't handle a convolution "
-                        "kernel with dimensions %dx%d - both dimensions "
-                        "must be odd (and positive)\n",
-                        filename, int (kernel_w), int (kernel_h));
-                myInfo->input_file_mtime = 0;  // force re-read, avoid crash
-                return 0;
-            }
-#endif
-/*
-            copy (istream_iterator <float> (inputStream),
-                  istream_iterator <float> (),
-                  back_inserter (kernel));
-
-#ifdef ASSUME_SQUARE_MATRIX
-            kernel_dim = uint32_t (sqrtf (kernel.size()));
-            if (kernel_dim * kernel_dim != kernel.size())
-            {
-                if ((kernel_dim + 1) * (kernel_dim + 1) == kernel.size())
-                    ++kernel_dim;
-                else
-                {
-                    printf ("SwissArmyKnife: Can't determine matrix "
-                            "dimensions to explain %d input values! "
-                            "(sqrt(%d) = %f)\n",
-                            kernel.size(), kernel.size(),
-                            sqrt (kernel.size()));
-                    kernel_dim = 0;
-                    return 0;
-                }
-            }
-#endif
-
-            printf ("SwissArmyKnife: read %d convolution kernel values "
-                    "from %s (%dx%d):\n",
-                    kernel.size(), filename, kernel_w, kernel_h);
-            if (debug & 8)
-            {
-                FloatVector::const_iterator kit = kernel.begin();
-                int count = 0;
-                while (kit != kernel.end())
-                {
-                    printf ("%.6f%c", *kit++,
-                            (++count % kernel_w) ? ' ' : '\n');
-                }
-                if (count % kernel_w)
-                    printf ("[incomplete?!]\n");
-            } */
-        }
-        else // file image (not convolution)
-        {
-            ADM_assert (param->input_type == INPUT_FILE_IMAGE_FLOAT
-                        || param->input_type == INPUT_FILE_IMAGE_INTEGER);
-
-            const char * filename = myInfo->input_file_name.c_str();
-            FILE * fin = fopen (filename, "rb");
-            if (!fin)
-            {
-                fprintf (stderr, "SwissArmyKnife: can't open input file %s, "
-                         "but it apparently does exist...(%d)\n",
-                         filename, errno);
-                return 0;
-            }
-
-            ADMVideoComputeAverage::FileHeader header;
-            int nread = fread (&header, sizeof (header), 1, fin);
-            if (nread != 1 || strncmp (header.magic, "DGCMimgF", 8) != 0)
-            {
-                fprintf (stderr, "SwissArmyKnife: %s does not appear to be a "
-                         "valid DG/CM floating-point raw image file (produced "
-                         "by the ComputeAverage filter)\n", filename);
-                fclose (fin);
-                return 0;
-            }
-
-            uint32_t width = header.width;
-            uint32_t height = header.height;
-            uint32_t pixelcount = width * height;
-
-            if (width > 2000 || height > 2000)
-            {
-                fprintf (stderr, "SwissArmyKnife: invalid image dimensions "
-                         "(%dx%d) in %s\n",
-                         int (width), int (height), filename);
-                fclose (fin);
-                return 0;
-            }
-
-            myInfo->image_data_invalid = true;
-            delete [] myInfo->image_float;
-            delete [] myInfo->image_int;
-
-            myInfo->image_float = new float [pixelcount];
-
-            nread = fread (myInfo->image_float, sizeof (float), pixelcount, fin);
-            fclose (fin);
-            if (nread != pixelcount)
-            {
-                fprintf (stderr, "SwissArmyKnife: failed to read image data "
-                         "(%ux%u = %u) from %s (got %u)\n",
-                         width, height, pixelcount, filename, nread);
-                delete [] myInfo->image_float;
-                myInfo->image_float = 0;
-                return 0;
-            }
-
-            printf ("SwissArmyKnife: successfully loaded image data "
-                    "(%ux%u = %u) from %s\n",
-                    width, height, pixelcount, filename);
-
-            myInfo->image_int = new uint8_t [pixelcount];
-            float * floatpixp = myInfo->image_float + pixelcount;
-            uint8_t * intpixp = myInfo->image_int + pixelcount;
-
-            if (param->load_bias == 0.0 && param->load_multiplier == 1.0)
-            {
-                printf ("Converting %u pixels to integer values (and keeping "
-                        "the floats, too)\n", pixelcount);
-
-                ++pixelcount;
-                while (--pixelcount)
-                {
-                    *--intpixp = static_cast <uint8_t> (*--floatpixp + 0.5);
-                }
-            }
-            else
-            {
-                float load_bias = param->load_bias;
-                float load_multiplier = param->load_multiplier;
-
-                printf ("applying P = (P + %.6f) * %.6f to %u pixels\n",
-                        load_bias, load_multiplier, pixelcount);
-
-                ++pixelcount;
-                while (--pixelcount)
-                {
-                    float floatpix
-                        = (*--floatpixp + load_bias) * load_multiplier;
-                    *floatpixp = floatpix;
-
-                    uint8_t intpix;
-                    if (floatpix < 0)
-                        intpix = 0;
-                    else if (floatpix > 255)
-                        intpix = 255;
-                    else
-                        intpix = static_cast <uint8_t> (floatpix + 0.5);
-
-                    *--intpixp = intpix;
-                }
-            }
-
-            myInfo->image_w = width;
-            myInfo->image_h = height;
-            myInfo->image_bias = param->load_bias;
-            myInfo->image_multiplier = param->load_multiplier;
-            myInfo->image_data_invalid = false;
-        }
-    }
-    else if (doingRollingAvg)
-    {
-        if (!myInfo->bg
-            || myInfo->bg_x != width || myInfo->bg_y != height
-            || myInfo->bg_mca != param->memory_constant_alpha
-            || myInfo->bg_lanf != param->lookahead_n_frames
-            || myInfo->bg_isf != param->init_start_frame
-            || myInfo->bg_ief != param->init_end_frame
-            || myInfo->bg_ibr != param->init_by_rolling)
-        {
-            if (!myInfo->bg || myInfo->bg_x != width || myInfo->bg_y != height)
-            {
-                myInfo->bg_x = width;
-                myInfo->bg_y = height;
-                delete [] myInfo->bg;
-                myInfo->bg = new float [planesize];
-            }
-
-            myInfo->histogram_data_invalid = true;
-
-            myInfo->bg_mca = param->memory_constant_alpha;
-            myInfo->bg_lanf = param->lookahead_n_frames;
-            myInfo->bg_isf = param->init_start_frame;
-            myInfo->bg_ief = param->init_end_frame;
-            myInfo->bg_ibr = param->init_by_rolling;
-
-            if (myInfo->bg_isf <= myInfo->bg_ief)
-            {
-                uint32_t do_frames = myInfo->bg_ief - myInfo->bg_isf + 1;
-
-                uint32_t firstframe = myInfo->bg_isf;
-                uint32_t lastframe = myInfo->bg_ief;
-                const ADV_Info & info = sak->getInfo();
-                if (lastframe >= info.nb_frames)
-                {
-                    lastframe = info.nb_frames - 1;
-                    if (firstframe >= info.nb_frames)
-                    {
-                        firstframe = lastframe - do_frames + 1;
-                        if (firstframe >= info.nb_frames)
-                            firstframe = 0;
-                    }
-                    do_frames = lastframe - firstframe + 1;
-                }
-
-                // if (debug & 2)
-                printf ("Getting a \"head start\" on rolling average by "
-                        "computing a %s %d frames of size %dx%d from %d to "
-                        "%d with alpha = %.6f\n",
-                        myInfo->bg_ibr ? "rolling average over"
-                        : "straight average of",
-                        do_frames, myInfo->bg_x, myInfo->bg_y,
-                        firstframe, lastframe, myInfo->bg_mca);
-
-                ADMImage aimage (myInfo->bg_x, myInfo->bg_y);
-
-                // HERE: for speed, we do luma (Y plane) only.  However, some
-                // users might want chroma, too... we should make that an option
-                // or something.  (...in which case bg should be big enough for
-                // all three planes.)
-
-
-//***************************************************************************
-//***************************************************************************
-//***************************************************************************
-
-                // HERE: issue: if we are not starting at the first frame,
-                // then I think that "in->getFrameNumberNoAlloc(framenum)"
-                // will give us framenum+frame_at_which_we_are_starting!!
-                // not sure this matters a lot in practice right now, but it
-                // might matter more if users start using a start frame > 1 to
-                // get a good fore/aft ratio...
-
-//***************************************************************************
-//***************************************************************************
-//***************************************************************************
-
-                if (myInfo->bg_ibr)
-                {
-                    // We want to "prime" the rolling average with the values from
-                    // the first frame (rather than zeroes, which doesn't seem to
-                    // work out well).  So we do the following block just once,
-                    // but in its own scope to not collide with the locals of the
-                    // loop that follows:
-                    {
-                        uint32_t flen;
-                        uint32_t fflags = 0;
-                        if (!in->getFrameNumberNoAlloc (firstframe, &flen,
-                                                        &aimage, &fflags))
-                            return 0;
-
-                        uint8_t * currp = YPLANE (&aimage) + planesize;
-                        float * bgp = myInfo->bg + planesize;
-                        uint32_t pixremaining = planesize + 1;
-                        while (--pixremaining)
-                        {
-                            *--bgp = *--currp;
-                        }
-
-                        ++firstframe; // don't include this one again
-                    }
-
-                    float alpha = param->memory_constant_alpha;
-                    float oneminusalpha = 1 - alpha;
-
-                    for (int fnum = firstframe; fnum <= lastframe; fnum++)
-                    {
-                        uint32_t flen;
-                        uint32_t fflags = 0;
-                        if (!in->getFrameNumberNoAlloc (fnum, &flen,
-                                                        &aimage, &fflags))
-                            return 0;
-
-                        uint8_t * currp = YPLANE (&aimage) + planesize;
-                        float * bgp = myInfo->bg + planesize;
-                        uint32_t pixremaining = planesize + 1;
-                        while (--pixremaining)
-                        {
-                            --bgp;
-                            *bgp = (*bgp * oneminusalpha) + (*--currp * alpha);
-                        }
-                    }
-                }
-                else // head start uses straight average (not rolling average)
-                {
-                    uint32_t sums [planesize];
-                    memset (sums, 0, planesize * sizeof sums[0]);
-
-                    for (int fnum = firstframe; fnum <= lastframe; fnum++)
-                    {
-                        uint32_t flen;
-                        uint32_t fflags = 0;
-                        if (!in->getFrameNumberNoAlloc (fnum, &flen,
-                                                        &aimage, &fflags))
-                            return 0;
-
-                        uint8_t * currp = YPLANE (&aimage) + planesize;
-                        uint32_t * sump = sums + planesize;
-                        uint32_t pixremaining = planesize + 1;
-                        while (--pixremaining)
-                        {
-                            *--sump += *--currp;
-                        }
-                    }
-
-                    float * bgp = myInfo->bg + planesize;
-                    uint32_t * sump = sums + planesize;
-                    uint32_t pixremaining = planesize + 1;
-                    // we use a floating point multiply of a reciprocal rather
-                    // than a floating point divide, because floating point
-                    // folklore says the multiply will be faster.
-                    float one_over_framecount = 1.0 / do_frames;
-                    while (--pixremaining)
-                    {
-                        *--bgp = *--sump * one_over_framecount;
-                    }
-                }
-
-                // if (debug & 2)
-                printf ("Done computing head start.\n");
-            }
-            else // if (debug & 2)
-            {
-                printf ("Starting with new 0 baseline background\n");
-                memset (myInfo->bg, 0, planesize * sizeof (myInfo->bg[0]));
-            }
-        }
-        else
-        {
-            if (debug & 4)
-                printf ("Using existing baseline background of size %dx%d with "
-                        "alpha = %.6f (1/%d)\n", myInfo->bg_x, myInfo->bg_y,
-                        myInfo->bg_mca);
-        }
-    }			
-
-    uint8_t * imagePixels = YPLANE (image);
-
-    ImageTool imtool (imagePixels, width, height, data);
-    imtool.setDebug (debug);
-
-    Histogram * histogram = 0;
-    int32_t bias = param->bias;
-    uint32_t tool = param->tool;
-
-    // HERE: give some thought to the general issue of keeping myInfo & param
-    // in sync, and resetting the histogram (or whatever) when things change.
-
-    if (param->histogram_frame_interval != 0)
-    {
-        histogram = new Histogram (myInfo->histogram_input_data,
-                                   myInfo->histogram_output_data,
-                                   param->histogram_frame_interval,
-                                   myInfo->histogram_frame_count,
-                                   width * height);
-        tool += TOOL_ADD_HISTOGRAM;
-        if (myInfo->histogram_frame_interval !=
-            param->histogram_frame_interval)
-        {
-            if (myInfo->histogram_frame_interval)
-                myInfo->histogram_data_invalid = true;
-            myInfo->histogram_frame_interval
-                = param->histogram_frame_interval;
-        }
-
-        if (myInfo->histogram_data_invalid)
-        {
-            myInfo->histogram_data_invalid = false;
-            histogram->reset();
-        }
-    }
-
-    float rbias = param->result_bias;
-    float rmultiplier = param->result_multiplier;
-    if (fabsf (rbias) >= 0.0001 || fabsf (rmultiplier - 1.0) >= 0.0001)
-    {
-        tool += TOOL_ADD_SCALING;
-    }
-
-    // It might look like the following switches could be collapsed
-    // significantly if we just used a pointer to the functor objects,
-    // assigning the appropriate operation, histogram functor, etc., and then
-    // using fewer cases.  The problem is that to get the fastest possible
-    // code (important since we're talking about per-pixel operations here),
-    // the tool functor object (e.g., OpPequalsAminusP) needs to be
-    // instantiated inline in the call to the operation template (e.g.,
-    // convolve(), computeRollingAverage(), etc.) so that the functor code can
-    // be inlined.  If we passed an object through a pointer or reference,
-    // we'd have much smaller code (both source and binary), but it would also
-    // be much slower because every pixel would have to traverse the pointer.
-    // So in this case we are buying performance at the cost of a bunch of big
-    // messy switches in the source plus massive template code expansion in
-    // the output.  It's worth it.
-
-    if (doingConvolution)
-    {
-        /*if (kernel.empty())
-        {
-            fprintf (stderr, "No convolution kernel loaded - can't do "
-                     "convolution!\n");
-            return 0;
-        }*/
-
-        switch (tool)
-        {
-        case TOOL_A:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias, OpPequalsA(), HistogramNull());
-            break;
-        case TOOL_P: // HERE: we could optimize this if we wanted to
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias, OpPequalsP(), HistogramNull());
-            break;
-        case TOOL_P_MINUS_A:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias, OpPequalsPminusA(), HistogramNull());
-            break;
-        case TOOL_A_MINUS_P:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias, OpPequalsAminusP(), HistogramNull());
-            break;
-        case TOOL_P_PLUS_A:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias, OpPequalsPplusA(), HistogramNull());
-            break;
-        case TOOL_P_TIMES_A:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias, OpPequalsPtimesA(), HistogramNull());
-            break;
-        case TOOL_P_DIVBY_A:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias, OpPequalsPdivByA(), HistogramNull());
-            break;
-        case TOOL_A_DIVBY_P:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias, OpPequalsAdivByP(), HistogramNull());
-            break;
-        case TOOL_MIN_P_A:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias, OpPequalsMinPA(), HistogramNull());
-            break;
-        case TOOL_MAX_P_A:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias, OpPequalsMaxPA(), HistogramNull());
-            break;
-
-        case TOOL_A_WITH_HISTOGRAM:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias, OpPequalsA(), *histogram);
-            break;
-        case TOOL_P_WITH_HISTOGRAM: // HERE: we could optimize this if we wanted to
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias, OpPequalsP(), *histogram);
-            break;
-        case TOOL_P_MINUS_A_WITH_HISTOGRAM:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias, OpPequalsPminusA(), *histogram);
-            break;
-        case TOOL_A_MINUS_P_WITH_HISTOGRAM:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias, OpPequalsAminusP(), *histogram);
-            break;
-        case TOOL_P_PLUS_A_WITH_HISTOGRAM:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias, OpPequalsPplusA(), *histogram);
-            break;
-        case TOOL_P_TIMES_A_WITH_HISTOGRAM:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias, OpPequalsPtimesA(), *histogram);
-            break;
-        case TOOL_P_DIVBY_A_WITH_HISTOGRAM:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias, OpPequalsPdivByA(), *histogram);
-            break;
-        case TOOL_A_DIVBY_P_WITH_HISTOGRAM:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias, OpPequalsAdivByP(), *histogram);
-            break;
-        case TOOL_MIN_P_A_WITH_HISTOGRAM:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias, OpPequalsMinPA(), *histogram);
-            break;
-        case TOOL_MAX_P_A_WITH_HISTOGRAM:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias, OpPequalsMaxPA(), *histogram);
-            break;
-
-        case TOOL_A_SCALED:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias,
-                             //OpPequalsA_Scaled (rbias, rmultiplier), HistogramNull());
-            break;
-        case TOOL_P_SCALED: // HERE_SCALED: we could optimize this if we wanted to
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias,
-                             //OpPequalsP_Scaled (rbias, rmultiplier), HistogramNull());
-            break;
-        case TOOL_P_MINUS_A_SCALED:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias,
-                             //OpPequalsPminusA_Scaled (rbias, rmultiplier), HistogramNull());
-            break;
-        case TOOL_A_MINUS_P_SCALED:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias,
-                             //OpPequalsAminusP_Scaled (rbias, rmultiplier), HistogramNull());
-            break;
-        case TOOL_P_PLUS_A_SCALED:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias,
-                             //OpPequalsPplusA_Scaled (rbias, rmultiplier), HistogramNull());
-            break;
-        case TOOL_P_TIMES_A_SCALED:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias,
-                             //OpPequalsPtimesA_Scaled (rbias, rmultiplier), HistogramNull());
-            break;
-        case TOOL_P_DIVBY_A_SCALED:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias,
-                             //OpPequalsPdivByA_Scaled (rbias, rmultiplier), HistogramNull());
-            break;
-        case TOOL_A_DIVBY_P_SCALED:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias,
-                             //OpPequalsAdivByP_Scaled (rbias, rmultiplier), HistogramNull());
-            break;
-        case TOOL_MIN_P_A_SCALED:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias,
-                             //OpPequalsMinPA_Scaled (rbias, rmultiplier), HistogramNull());
-            break;
-        case TOOL_MAX_P_A_SCALED:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias,
-                             //OpPequalsMaxPA_Scaled (rbias, rmultiplier), HistogramNull());
-            break;
-
-        case TOOL_A_SCALED_WITH_HISTOGRAM:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias,
-                             //OpPequalsA_Scaled (rbias, rmultiplier), *histogram);
-            break;
-        case TOOL_P_SCALED_WITH_HISTOGRAM: // HERE: we could optimize this if we wanted to
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias,
-                             //OpPequalsP_Scaled (rbias, rmultiplier), *histogram);
-            break;
-        case TOOL_P_MINUS_A_SCALED_WITH_HISTOGRAM:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias,
-                             //OpPequalsPminusA_Scaled (rbias, rmultiplier), *histogram);
-            break;
-        case TOOL_A_MINUS_P_SCALED_WITH_HISTOGRAM:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias,
-                             //OpPequalsAminusP_Scaled (rbias, rmultiplier), *histogram);
-            break;
-        case TOOL_P_PLUS_A_SCALED_WITH_HISTOGRAM:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias,
-                             //OpPequalsPplusA_Scaled (rbias, rmultiplier), *histogram);
-            break;
-        case TOOL_P_TIMES_A_SCALED_WITH_HISTOGRAM:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias,
-                             //OpPequalsPtimesA_Scaled (rbias, rmultiplier), *histogram);
-            break;
-        case TOOL_P_DIVBY_A_SCALED_WITH_HISTOGRAM:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias,
-                             //OpPequalsPdivByA_Scaled (rbias, rmultiplier), *histogram);
-            break;
-        case TOOL_A_DIVBY_P_SCALED_WITH_HISTOGRAM:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias,
-                             //OpPequalsAdivByP_Scaled (rbias, rmultiplier), *histogram);
-            break;
-        case TOOL_MIN_P_A_SCALED_WITH_HISTOGRAM:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias,
-                             //OpPequalsMinPA_Scaled (rbias, rmultiplier), *histogram);
-            break;
-        case TOOL_MAX_P_A_SCALED_WITH_HISTOGRAM:
-            //imtool.convolve (kernel, kernel_w, kernel_h, bias,
-                             //OpPequalsMaxPA_Scaled (rbias, rmultiplier), *histogram);
-            break;
-
-        default:
-            fprintf (stderr, "SwissArmyKnife: unknown operation (tool) %d!\n",
-                     param->tool);
-            return 0;
-        }
-    }
-    else if (doingRollingAvg && param->lookahead_n_frames == 0)
-    {
-        switch (tool)
-        {
-        case TOOL_A:
-            sak->computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsA(), HistogramNull());
-            break;
-        case TOOL_P: // HERE: we could optimize this if we wanted to
-            sak->computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsP(), HistogramNull());
-            break;
-        case TOOL_P_MINUS_A:
-            sak->computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsPminusA(), HistogramNull());
-            break;
-        case TOOL_A_MINUS_P:
-            sak->computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsAminusP(), HistogramNull());
-            break;
-        case TOOL_P_PLUS_A:
-            sak->computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsPplusA(), HistogramNull());
-            break;
-        case TOOL_P_TIMES_A:
-            sak->computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsPtimesA(), HistogramNull());
-            break;
-        case TOOL_P_DIVBY_A:
-            sak->computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsPdivByA(), HistogramNull());
-            break;
-        case TOOL_A_DIVBY_P:
-            sak->computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsAdivByP(), HistogramNull());
-            break;
-        case TOOL_MIN_P_A:
-            sak->computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsMinPA(), HistogramNull());
-            break;
-        case TOOL_MAX_P_A:
-            sak->computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsMaxPA(), HistogramNull());
-            break;
-
-        case TOOL_A_WITH_HISTOGRAM:
-            sak->computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsA(), *histogram);
-            break;
-        case TOOL_P_WITH_HISTOGRAM: // HERE: we could optimize this if we wanted to
-            sak->computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsP(), *histogram);
-            break;
-        case TOOL_P_MINUS_A_WITH_HISTOGRAM:
-            sak->computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsPminusA(), *histogram);
-            break;
-        case TOOL_A_MINUS_P_WITH_HISTOGRAM:
-            sak->computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsAminusP(), *histogram);
-            break;
-        case TOOL_P_PLUS_A_WITH_HISTOGRAM:
-            sak->computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsPplusA(), *histogram);
-            break;
-        case TOOL_P_TIMES_A_WITH_HISTOGRAM:
-            sak->computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsPtimesA(), *histogram);
-            break;
-        case TOOL_P_DIVBY_A_WITH_HISTOGRAM:
-            sak->computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsPdivByA(), *histogram);
-            break;
-        case TOOL_A_DIVBY_P_WITH_HISTOGRAM:
-            sak->computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsAdivByP(), *histogram);
-            break;
-        case TOOL_MIN_P_A_WITH_HISTOGRAM:
-            sak->computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsMinPA(), *histogram);
-            break;
-        case TOOL_MAX_P_A_WITH_HISTOGRAM:
-            sak->computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsMaxPA(), *histogram);
-            break;
-
-        case TOOL_A_SCALED:
-            sak->computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsA_Scaled (rbias, rmultiplier),
-                                        HistogramNull());
-            break;
-        case TOOL_P_SCALED: // HERE_SCALED: we could optimize this if we wanted to
-            sak->computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsP_Scaled (rbias, rmultiplier),
-                                        HistogramNull());
-            break;
-        case TOOL_P_MINUS_A_SCALED:
-            sak->computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsPminusA_Scaled (rbias, rmultiplier),
-                                        HistogramNull());
-            break;
-        case TOOL_A_MINUS_P_SCALED:
-            sak->computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsAminusP_Scaled (rbias, rmultiplier),
-                                        HistogramNull());
-            break;
-        case TOOL_P_PLUS_A_SCALED:
-            sak->computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsPplusA_Scaled (rbias, rmultiplier),
-                                        HistogramNull());
-            break;
-        case TOOL_P_TIMES_A_SCALED:
-            sak->computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsPtimesA_Scaled (rbias, rmultiplier),
-                                        HistogramNull());
-            break;
-        case TOOL_P_DIVBY_A_SCALED:
-            sak->computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsPdivByA_Scaled (rbias, rmultiplier),
-                                        HistogramNull());
-            break;
-        case TOOL_A_DIVBY_P_SCALED:
-            sak->computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsAdivByP_Scaled (rbias, rmultiplier),
-                                        HistogramNull());
-            break;
-        case TOOL_MIN_P_A_SCALED:
-            sak->computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsMinPA_Scaled (rbias, rmultiplier),
-                                        HistogramNull());
-            break;
-        case TOOL_MAX_P_A_SCALED:
-            sak->computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsMaxPA_Scaled (rbias, rmultiplier),
-                                        HistogramNull());
-            break;
-
-        case TOOL_A_SCALED_WITH_HISTOGRAM:
-            sak->computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsA_Scaled (rbias, rmultiplier),
-                                        *histogram);
-            break;
-        case TOOL_P_SCALED_WITH_HISTOGRAM: // HERE: we could optimize this if we wanted to
-            sak->computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsP_Scaled (rbias, rmultiplier),
-                                        *histogram);
-            break;
-        case TOOL_P_MINUS_A_SCALED_WITH_HISTOGRAM:
-            sak->computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsPminusA_Scaled (rbias, rmultiplier),
-                                        *histogram);
-            break;
-        case TOOL_A_MINUS_P_SCALED_WITH_HISTOGRAM:
-            sak->computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsAminusP_Scaled (rbias, rmultiplier),
-                                        *histogram);
-            break;
-        case TOOL_P_PLUS_A_SCALED_WITH_HISTOGRAM:
-            sak->computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsPplusA_Scaled (rbias, rmultiplier),
-                                        *histogram);
-            break;
-        case TOOL_P_TIMES_A_SCALED_WITH_HISTOGRAM:
-            sak->computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsPtimesA_Scaled (rbias, rmultiplier),
-                                        *histogram);
-            break;
-        case TOOL_P_DIVBY_A_SCALED_WITH_HISTOGRAM:
-            sak->computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsPdivByA_Scaled (rbias, rmultiplier),
-                                        *histogram);
-            break;
-        case TOOL_A_DIVBY_P_SCALED_WITH_HISTOGRAM:
-            sak->computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsAdivByP_Scaled (rbias, rmultiplier),
-                                        *histogram);
-            break;
-        case TOOL_MIN_P_A_SCALED_WITH_HISTOGRAM:
-            sak->computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsMinPA_Scaled (rbias, rmultiplier),
-                                        *histogram);
-            break;
-        case TOOL_MAX_P_A_SCALED_WITH_HISTOGRAM:
-            sak->computeRollingAverage (image, data, planesize, param, bias,
-                                        OpPequalsMaxPA_Scaled (rbias, rmultiplier),
-                                        *histogram);
-            break;
-
-        default:
-            fprintf (stderr, "SwissArmyKnife: unknown operation (tool) %d!\n",
-                     param->tool);
-            return 0;
-        }
-    }
-    else if (doingRollingAvg)
-    {
-        switch (tool)
-        {
-        case TOOL_A:
-            sak->computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias, OpPequalsA(), HistogramNull());
-            break;
-        case TOOL_P: // HERE: we could optimize this if we wanted to
-            sak->computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias, OpPequalsP(), HistogramNull());
-            break;
-        case TOOL_P_MINUS_A:
-            sak->computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias, OpPequalsPminusA(), HistogramNull());
-            break;
-        case TOOL_A_MINUS_P:
-            sak->computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias, OpPequalsAminusP(), HistogramNull());
-            break;
-        case TOOL_P_PLUS_A:
-            sak->computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias, OpPequalsPplusA(), HistogramNull());
-            break;
-        case TOOL_P_TIMES_A:
-            sak->computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias, OpPequalsPtimesA(), HistogramNull());
-            break;
-        case TOOL_P_DIVBY_A:
-            sak->computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias, OpPequalsPdivByA(), HistogramNull());
-            break;
-        case TOOL_A_DIVBY_P:
-            sak->computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias, OpPequalsAdivByP(), HistogramNull());
-            break;
-        case TOOL_MIN_P_A:
-            sak->computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias, OpPequalsMinPA(), HistogramNull());
-            break;
-        case TOOL_MAX_P_A:
-            sak->computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias, OpPequalsMaxPA(), HistogramNull());
-            break;
-
-        case TOOL_A_WITH_HISTOGRAM:
-            sak->computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias, OpPequalsA(), *histogram);
-            break;
-        case TOOL_P_WITH_HISTOGRAM: // HERE: we could optimize this if we wanted to
-            sak->computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias, OpPequalsP(), *histogram);
-            break;
-        case TOOL_P_MINUS_A_WITH_HISTOGRAM:
-            sak->computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias, OpPequalsPminusA(), *histogram);
-            break;
-        case TOOL_A_MINUS_P_WITH_HISTOGRAM:
-            sak->computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias, OpPequalsAminusP(), *histogram);
-            break;
-        case TOOL_P_PLUS_A_WITH_HISTOGRAM:
-            sak->computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias, OpPequalsPplusA(), *histogram);
-            break;
-        case TOOL_P_TIMES_A_WITH_HISTOGRAM:
-            sak->computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias, OpPequalsPtimesA(), *histogram);
-            break;
-        case TOOL_P_DIVBY_A_WITH_HISTOGRAM:
-            sak->computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias, OpPequalsPdivByA(), *histogram);
-            break;
-        case TOOL_A_DIVBY_P_WITH_HISTOGRAM:
-            sak->computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias, OpPequalsAdivByP(), *histogram);
-            break;
-        case TOOL_MIN_P_A_WITH_HISTOGRAM:
-            sak->computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias, OpPequalsMinPA(), *histogram);
-            break;
-        case TOOL_MAX_P_A_WITH_HISTOGRAM:
-            sak->computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias, OpPequalsMaxPA(), *histogram);
-            break;
-
-        case TOOL_A_SCALED:
-            sak->computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias,
-                                        OpPequalsA_Scaled (rbias, rmultiplier),
-                                        HistogramNull());
-            break;
-        case TOOL_P_SCALED: // HERE_SCALED: we could optimize this if we wanted to
-            sak->computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias,
-                                        OpPequalsP_Scaled (rbias, rmultiplier),
-                                        HistogramNull());
-            break;
-        case TOOL_P_MINUS_A_SCALED:
-            sak->computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias,
-                                        OpPequalsPminusA_Scaled (rbias, rmultiplier),
-                                        HistogramNull());
-            break;
-        case TOOL_A_MINUS_P_SCALED:
-            sak->computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias,
-                                        OpPequalsAminusP_Scaled (rbias, rmultiplier),
-                                        HistogramNull());
-            break;
-        case TOOL_P_PLUS_A_SCALED:
-            sak->computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias,
-                                        OpPequalsPplusA_Scaled (rbias, rmultiplier),
-                                        HistogramNull());
-            break;
-        case TOOL_P_TIMES_A_SCALED:
-            sak->computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias,
-                                        OpPequalsPtimesA_Scaled (rbias, rmultiplier),
-                                        HistogramNull());
-            break;
-        case TOOL_P_DIVBY_A_SCALED:
-            sak->computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias,
-                                        OpPequalsPdivByA_Scaled (rbias, rmultiplier),
-                                        HistogramNull());
-            break;
-        case TOOL_A_DIVBY_P_SCALED:
-            sak->computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias,
-                                        OpPequalsAdivByP_Scaled (rbias, rmultiplier),
-                                        HistogramNull());
-            break;
-        case TOOL_MIN_P_A_SCALED:
-            sak->computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias,
-                                        OpPequalsMinPA_Scaled (rbias, rmultiplier),
-                                        HistogramNull());
-            break;
-        case TOOL_MAX_P_A_SCALED:
-            sak->computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias,
-                                        OpPequalsMaxPA_Scaled (rbias, rmultiplier),
-                                        HistogramNull());
-            break;
-
-        case TOOL_A_SCALED_WITH_HISTOGRAM:
-            sak->computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias,
-                                        OpPequalsA_Scaled (rbias, rmultiplier),
-                                        *histogram);
-            break;
-        case TOOL_P_SCALED_WITH_HISTOGRAM: // HERE: we could optimize this if we wanted to
-            sak->computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias,
-                                        OpPequalsP_Scaled (rbias, rmultiplier),
-                                        *histogram);
-            break;
-        case TOOL_P_MINUS_A_SCALED_WITH_HISTOGRAM:
-            sak->computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias,
-                                        OpPequalsPminusA_Scaled (rbias, rmultiplier),
-                                        *histogram);
-            break;
-        case TOOL_A_MINUS_P_SCALED_WITH_HISTOGRAM:
-            sak->computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias,
-                                        OpPequalsAminusP_Scaled (rbias, rmultiplier),
-                                        *histogram);
-            break;
-        case TOOL_P_PLUS_A_SCALED_WITH_HISTOGRAM:
-            sak->computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias,
-                                        OpPequalsPplusA_Scaled (rbias, rmultiplier),
-                                        *histogram);
-            break;
-        case TOOL_P_TIMES_A_SCALED_WITH_HISTOGRAM:
-            sak->computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias,
-                                        OpPequalsPtimesA_Scaled (rbias, rmultiplier),
-                                        *histogram);
-            break;
-        case TOOL_P_DIVBY_A_SCALED_WITH_HISTOGRAM:
-            sak->computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias,
-                                        OpPequalsPdivByA_Scaled (rbias, rmultiplier),
-                                        *histogram);
-            break;
-        case TOOL_A_DIVBY_P_SCALED_WITH_HISTOGRAM:
-            sak->computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias,
-                                        OpPequalsAdivByP_Scaled (rbias, rmultiplier),
-                                        *histogram);
-            break;
-        case TOOL_MIN_P_A_SCALED_WITH_HISTOGRAM:
-            sak->computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias,
-                                        OpPequalsMinPA_Scaled (rbias, rmultiplier),
-                                        *histogram);
-            break;
-        case TOOL_MAX_P_A_SCALED_WITH_HISTOGRAM:
-            sak->computeRollingAverage (image, lookaheadimage, data, planesize,
-                                        param, bias,
-                                        OpPequalsMaxPA_Scaled (rbias, rmultiplier),
-                                        *histogram);
-            break;
-
-        default:
-            fprintf (stderr, "SwissArmyKnife: unknown operation (tool) %d!\n",
-                     param->tool);
-            return 0;
-        }
-    }
-    else if (doingFileImageFloat)
-    {
-        if (width != myInfo->image_w || height != myInfo->image_h)
-        {
-            const char * bar = "*************************";
-            fprintf (stderr, "\n%s%s%s\nAttempting to apply a %ux%u input "
-                     "image to %ux%u video - even if I could do that, it "
-                     "probably wouldn't be what you wanted...\n%s%s%s\n",
-                     bar, bar, bar, myInfo->image_w, myInfo->image_h,
-                     width, height, bar, bar, bar);
-            return 0;
-        }
-
-        float * flt_img = myInfo->image_float;
-
-        switch (tool)
-        {
-        case TOOL_A:
-            sak->applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsA(), HistogramNull());
-            break;
-        case TOOL_P: // HERE: we could optimize this if we wanted to
-            sak->applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsP(), HistogramNull());
-            break;
-        case TOOL_P_MINUS_A:
-            sak->applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsPminusA(), HistogramNull());
-            break;
-        case TOOL_A_MINUS_P:
-            sak->applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsAminusP(), HistogramNull());
-            break;
-        case TOOL_P_PLUS_A:
-            sak->applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsPplusA(), HistogramNull());
-            break;
-        case TOOL_P_TIMES_A:
-            sak->applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsPtimesA(), HistogramNull());
-            break;
-        case TOOL_P_DIVBY_A:
-            sak->applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsPdivByA(), HistogramNull());
-            break;
-        case TOOL_A_DIVBY_P:
-            sak->applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsAdivByP(), HistogramNull());
-            break;
-        case TOOL_MIN_P_A:
-            sak->applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsMinPA(), HistogramNull());
-            break;
-        case TOOL_MAX_P_A:
-            sak->applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsMaxPA(), HistogramNull());
-            break;
-
-        case TOOL_A_WITH_HISTOGRAM:
-            sak->applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsA(), *histogram);
-            break;
-        case TOOL_P_WITH_HISTOGRAM: // HERE: we could optimize this if we wanted to
-            sak->applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsP(), *histogram);
-            break;
-        case TOOL_P_MINUS_A_WITH_HISTOGRAM:
-            sak->applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsPminusA(), *histogram);
-            break;
-        case TOOL_A_MINUS_P_WITH_HISTOGRAM:
-            sak->applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsAminusP(), *histogram);
-            break;
-        case TOOL_P_PLUS_A_WITH_HISTOGRAM:
-            sak->applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsPplusA(), *histogram);
-            break;
-        case TOOL_P_TIMES_A_WITH_HISTOGRAM:
-            sak->applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsPtimesA(), *histogram);
-            break;
-        case TOOL_P_DIVBY_A_WITH_HISTOGRAM:
-            sak->applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsPdivByA(), *histogram);
-            break;
-        case TOOL_A_DIVBY_P_WITH_HISTOGRAM:
-            sak->applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsAdivByP(), *histogram);
-            break;
-        case TOOL_MIN_P_A_WITH_HISTOGRAM:
-            sak->applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsMinPA(), *histogram);
-            break;
-        case TOOL_MAX_P_A_WITH_HISTOGRAM:
-            sak->applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsMaxPA(), *histogram);
-            break;
-
-        case TOOL_A_SCALED:
-            sak->applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsA_Scaled (rbias, rmultiplier),
-                             HistogramNull());
-            break;
-        case TOOL_P_SCALED: // HERE_SCALED: we could optimize this if we wanted to
-            sak->applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsP_Scaled (rbias, rmultiplier),
-                             HistogramNull());
-            break;
-        case TOOL_P_MINUS_A_SCALED:
-            sak->applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsPminusA_Scaled (rbias, rmultiplier),
-                             HistogramNull());
-            break;
-        case TOOL_A_MINUS_P_SCALED:
-            sak->applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsAminusP_Scaled (rbias, rmultiplier),
-                             HistogramNull());
-            break;
-        case TOOL_P_PLUS_A_SCALED:
-            sak->applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsPplusA_Scaled (rbias, rmultiplier),
-                             HistogramNull());
-            break;
-        case TOOL_P_TIMES_A_SCALED:
-            sak->applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsPtimesA_Scaled (rbias, rmultiplier),
-                             HistogramNull());
-            break;
-        case TOOL_P_DIVBY_A_SCALED:
-            sak->applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsPdivByA_Scaled (rbias, rmultiplier),
-                             HistogramNull());
-            break;
-        case TOOL_A_DIVBY_P_SCALED:
-            sak->applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsAdivByP_Scaled (rbias, rmultiplier),
-                             HistogramNull());
-            break;
-        case TOOL_MIN_P_A_SCALED:
-            sak->applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsMinPA_Scaled (rbias, rmultiplier),
-                             HistogramNull());
-            break;
-        case TOOL_MAX_P_A_SCALED:
-            sak->applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsMaxPA_Scaled (rbias, rmultiplier),
-                             HistogramNull());
-            break;
-
-        case TOOL_A_SCALED_WITH_HISTOGRAM:
-            sak->applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsA_Scaled (rbias, rmultiplier),
-                             *histogram);
-            break;
-        case TOOL_P_SCALED_WITH_HISTOGRAM: // HERE: we could optimize this if we wanted to
-            sak->applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsP_Scaled (rbias, rmultiplier),
-                             *histogram);
-            break;
-        case TOOL_P_MINUS_A_SCALED_WITH_HISTOGRAM:
-            sak->applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsPminusA_Scaled (rbias, rmultiplier),
-                             *histogram);
-            break;
-        case TOOL_A_MINUS_P_SCALED_WITH_HISTOGRAM:
-            sak->applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsAminusP_Scaled (rbias, rmultiplier),
-                             *histogram);
-            break;
-        case TOOL_P_PLUS_A_SCALED_WITH_HISTOGRAM:
-            sak->applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsPplusA_Scaled (rbias, rmultiplier),
-                             *histogram);
-            break;
-        case TOOL_P_TIMES_A_SCALED_WITH_HISTOGRAM:
-            sak->applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsPtimesA_Scaled (rbias, rmultiplier),
-                             *histogram);
-            break;
-        case TOOL_P_DIVBY_A_SCALED_WITH_HISTOGRAM:
-            sak->applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsPdivByA_Scaled (rbias, rmultiplier),
-                             *histogram);
-            break;
-        case TOOL_A_DIVBY_P_SCALED_WITH_HISTOGRAM:
-            sak->applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsAdivByP_Scaled (rbias, rmultiplier),
-                             *histogram);
-            break;
-        case TOOL_MIN_P_A_SCALED_WITH_HISTOGRAM:
-            sak->applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsMinPA_Scaled (rbias, rmultiplier),
-                             *histogram);
-            break;
-        case TOOL_MAX_P_A_SCALED_WITH_HISTOGRAM:
-            sak->applyImage (image, data, planesize, param, bias, flt_img,
-                             OpPequalsMaxPA_Scaled (rbias, rmultiplier),
-                             *histogram);
-            break;
-
-        default:
-            fprintf (stderr, "SwissArmyKnife: unknown operation (tool) %d!\n",
-                     param->tool);
-            return 0;
-        }
-    }
-    else if (doingFileImage)
-    {
-        if (width != myInfo->image_w || height != myInfo->image_h)
-        {
-            const char * bar = "*************************";
-            fprintf (stderr, "\n%s%s%s\nAttempting to apply a %ux%u input "
-                     "image to %ux%u video - even if I could do that, it "
-                     "probably wouldn't be what you wanted...\n%s%s%s\n",
-                     bar, bar, bar, myInfo->image_w, myInfo->image_h,
-                     width, height, bar, bar, bar);
-            return 0;
-        }
-
-        uint8_t * int_img = myInfo->image_int;
-
-        switch (tool)
-        {
-        case TOOL_A:
-            sak->applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsA(), HistogramNull());
-            break;
-        case TOOL_P: // HERE: we could optimize this if we wanted to
-            sak->applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsP(), HistogramNull());
-            break;
-        case TOOL_P_MINUS_A:
-            sak->applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsPminusA(), HistogramNull());
-            break;
-        case TOOL_A_MINUS_P:
-            sak->applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsAminusP(), HistogramNull());
-            break;
-        case TOOL_P_PLUS_A:
-            sak->applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsPplusA(), HistogramNull());
-            break;
-        case TOOL_P_TIMES_A:
-            sak->applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsPtimesA(), HistogramNull());
-            break;
-        case TOOL_P_DIVBY_A:
-            sak->applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsPdivByA(), HistogramNull());
-            break;
-        case TOOL_A_DIVBY_P:
-            sak->applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsAdivByP(), HistogramNull());
-            break;
-        case TOOL_MIN_P_A:
-            sak->applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsMinPA(), HistogramNull());
-            break;
-        case TOOL_MAX_P_A:
-            sak->applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsMaxPA(), HistogramNull());
-            break;
-
-        case TOOL_A_WITH_HISTOGRAM:
-            sak->applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsA(), *histogram);
-            break;
-        case TOOL_P_WITH_HISTOGRAM: // HERE: we could optimize this if we wanted to
-            sak->applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsP(), *histogram);
-            break;
-        case TOOL_P_MINUS_A_WITH_HISTOGRAM:
-            sak->applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsPminusA(), *histogram);
-            break;
-        case TOOL_A_MINUS_P_WITH_HISTOGRAM:
-            sak->applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsAminusP(), *histogram);
-            break;
-        case TOOL_P_PLUS_A_WITH_HISTOGRAM:
-            sak->applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsPplusA(), *histogram);
-            break;
-        case TOOL_P_TIMES_A_WITH_HISTOGRAM:
-            sak->applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsPtimesA(), *histogram);
-            break;
-        case TOOL_P_DIVBY_A_WITH_HISTOGRAM:
-            sak->applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsPdivByA(), *histogram);
-            break;
-        case TOOL_A_DIVBY_P_WITH_HISTOGRAM:
-            sak->applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsAdivByP(), *histogram);
-            break;
-        case TOOL_MIN_P_A_WITH_HISTOGRAM:
-            sak->applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsMinPA(), *histogram);
-            break;
-        case TOOL_MAX_P_A_WITH_HISTOGRAM:
-            sak->applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsMaxPA(), *histogram);
-            break;
-
-        case TOOL_A_SCALED:
-            sak->applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsA_Scaled (rbias, rmultiplier),
-                             HistogramNull());
-            break;
-        case TOOL_P_SCALED: // HERE_SCALED: we could optimize this if we wanted to
-            sak->applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsP_Scaled (rbias, rmultiplier),
-                             HistogramNull());
-            break;
-        case TOOL_P_MINUS_A_SCALED:
-            sak->applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsPminusA_Scaled (rbias, rmultiplier),
-                             HistogramNull());
-            break;
-        case TOOL_A_MINUS_P_SCALED:
-            sak->applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsAminusP_Scaled (rbias, rmultiplier),
-                             HistogramNull());
-            break;
-        case TOOL_P_PLUS_A_SCALED:
-            sak->applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsPplusA_Scaled (rbias, rmultiplier),
-                             HistogramNull());
-            break;
-        case TOOL_P_TIMES_A_SCALED:
-            sak->applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsPtimesA_Scaled (rbias, rmultiplier),
-                             HistogramNull());
-            break;
-        case TOOL_P_DIVBY_A_SCALED:
-            sak->applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsPdivByA_Scaled (rbias, rmultiplier),
-                             HistogramNull());
-            break;
-        case TOOL_A_DIVBY_P_SCALED:
-            sak->applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsAdivByP_Scaled (rbias, rmultiplier),
-                             HistogramNull());
-            break;
-        case TOOL_MIN_P_A_SCALED:
-            sak->applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsMinPA_Scaled (rbias, rmultiplier),
-                             HistogramNull());
-            break;
-        case TOOL_MAX_P_A_SCALED:
-            sak->applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsMaxPA_Scaled (rbias, rmultiplier),
-                             HistogramNull());
-            break;
-
-        case TOOL_A_SCALED_WITH_HISTOGRAM:
-            sak->applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsA_Scaled (rbias, rmultiplier),
-                             *histogram);
-            break;
-        case TOOL_P_SCALED_WITH_HISTOGRAM: // HERE: we could optimize this if we wanted to
-            sak->applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsP_Scaled (rbias, rmultiplier),
-                             *histogram);
-            break;
-        case TOOL_P_MINUS_A_SCALED_WITH_HISTOGRAM:
-            sak->applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsPminusA_Scaled (rbias, rmultiplier),
-                             *histogram);
-            break;
-        case TOOL_A_MINUS_P_SCALED_WITH_HISTOGRAM:
-            sak->applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsAminusP_Scaled (rbias, rmultiplier),
-                             *histogram);
-            break;
-        case TOOL_P_PLUS_A_SCALED_WITH_HISTOGRAM:
-            sak->applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsPplusA_Scaled (rbias, rmultiplier),
-                             *histogram);
-            break;
-        case TOOL_P_TIMES_A_SCALED_WITH_HISTOGRAM:
-            sak->applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsPtimesA_Scaled (rbias, rmultiplier),
-                             *histogram);
-            break;
-        case TOOL_P_DIVBY_A_SCALED_WITH_HISTOGRAM:
-            sak->applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsPdivByA_Scaled (rbias, rmultiplier),
-                             *histogram);
-            break;
-        case TOOL_A_DIVBY_P_SCALED_WITH_HISTOGRAM:
-            sak->applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsAdivByP_Scaled (rbias, rmultiplier),
-                             *histogram);
-            break;
-        case TOOL_MIN_P_A_SCALED_WITH_HISTOGRAM:
-            sak->applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsMinPA_Scaled (rbias, rmultiplier),
-                             *histogram);
-            break;
-        case TOOL_MAX_P_A_SCALED_WITH_HISTOGRAM:
-            sak->applyImage (image, data, planesize, param, bias, int_img,
-                             OpPequalsMaxPA_Scaled (rbias, rmultiplier),
-                             *histogram);
-            break;
-
-        default:
-            fprintf (stderr, "SwissArmyKnife: unknown operation (tool) %d!\n",
-                     param->tool);
-            return 0;
-        }
-    }
-    else if (doingApplyConstant)
-    {
-        switch (tool)
-        {
-        case TOOL_A:
-            sak->applyConstant (image, data, planesize, param, bias,
-                                OpPequalsA(), HistogramNull());
-            break;
-        case TOOL_P: // HERE: we could optimize this if we wanted to
-            sak->applyConstant (image, data, planesize, param, bias,
-                                OpPequalsP(), HistogramNull());
-            break;
-        case TOOL_P_MINUS_A:
-            sak->applyConstant (image, data, planesize, param, bias,
-                                OpPequalsPminusA(), HistogramNull());
-            break;
-        case TOOL_A_MINUS_P:
-            sak->applyConstant (image, data, planesize, param, bias,
-                                OpPequalsAminusP(), HistogramNull());
-            break;
-        case TOOL_P_PLUS_A:
-            sak->applyConstant (image, data, planesize, param, bias,
-                                OpPequalsPplusA(), HistogramNull());
-            break;
-        case TOOL_P_TIMES_A:
-            sak->applyConstant (image, data, planesize, param, bias,
-                                OpPequalsPtimesA(), HistogramNull());
-            break;
-        case TOOL_P_DIVBY_A:
-            sak->applyConstant (image, data, planesize, param, bias,
-                                OpPequalsPdivByA(), HistogramNull());
-            break;
-        case TOOL_A_DIVBY_P:
-            sak->applyConstant (image, data, planesize, param, bias,
-                                OpPequalsAdivByP(), HistogramNull());
-            break;
-        case TOOL_MIN_P_A:
-            sak->applyConstant (image, data, planesize, param, bias,
-                                OpPequalsMinPA(), HistogramNull());
-            break;
-        case TOOL_MAX_P_A:
-            sak->applyConstant (image, data, planesize, param, bias,
-                                OpPequalsMaxPA(), HistogramNull());
-            break;
-
-        case TOOL_A_WITH_HISTOGRAM:
-            sak->applyConstant (image, data, planesize, param, bias,
-                                OpPequalsA(), *histogram);
-            break;
-        case TOOL_P_WITH_HISTOGRAM: // HERE: we could optimize this if we wanted to
-            sak->applyConstant (image, data, planesize, param, bias,
-                                OpPequalsP(), *histogram);
-            break;
-        case TOOL_P_MINUS_A_WITH_HISTOGRAM:
-            sak->applyConstant (image, data, planesize, param, bias,
-                                OpPequalsPminusA(), *histogram);
-            break;
-        case TOOL_A_MINUS_P_WITH_HISTOGRAM:
-            sak->applyConstant (image, data, planesize, param, bias,
-                                OpPequalsAminusP(), *histogram);
-            break;
-        case TOOL_P_PLUS_A_WITH_HISTOGRAM:
-            sak->applyConstant (image, data, planesize, param, bias,
-                                OpPequalsPplusA(), *histogram);
-            break;
-        case TOOL_P_TIMES_A_WITH_HISTOGRAM:
-            sak->applyConstant (image, data, planesize, param, bias,
-                                OpPequalsPtimesA(), *histogram);
-            break;
-        case TOOL_P_DIVBY_A_WITH_HISTOGRAM:
-            sak->applyConstant (image, data, planesize, param, bias,
-                                OpPequalsPdivByA(), *histogram);
-            break;
-        case TOOL_A_DIVBY_P_WITH_HISTOGRAM:
-            sak->applyConstant (image, data, planesize, param, bias,
-                                OpPequalsAdivByP(), *histogram);
-            break;
-        case TOOL_MIN_P_A_WITH_HISTOGRAM:
-            sak->applyConstant (image, data, planesize, param, bias,
-                                OpPequalsMinPA(), *histogram);
-            break;
-        case TOOL_MAX_P_A_WITH_HISTOGRAM:
-            sak->applyConstant (image, data, planesize, param, bias,
-                                OpPequalsMaxPA(), *histogram);
-            break;
-
-        case TOOL_A_SCALED:
-            sak->applyConstant (image, data, planesize, param, bias,
-                                OpPequalsA_Scaled (rbias, rmultiplier),
-                                HistogramNull());
-            break;
-        case TOOL_P_SCALED: // HERE_SCALED: we could optimize this if we wanted to
-            sak->applyConstant (image, data, planesize, param, bias,
-                                OpPequalsP_Scaled (rbias, rmultiplier),
-                                HistogramNull());
-            break;
-        case TOOL_P_MINUS_A_SCALED:
-            sak->applyConstant (image, data, planesize, param, bias,
-                                OpPequalsPminusA_Scaled (rbias, rmultiplier),
-                                HistogramNull());
-            break;
-        case TOOL_A_MINUS_P_SCALED:
-            sak->applyConstant (image, data, planesize, param, bias,
-                                OpPequalsAminusP_Scaled (rbias, rmultiplier),
-                                HistogramNull());
-            break;
-        case TOOL_P_PLUS_A_SCALED:
-            sak->applyConstant (image, data, planesize, param, bias,
-                                OpPequalsPplusA_Scaled (rbias, rmultiplier),
-                                HistogramNull());
-            break;
-        case TOOL_P_TIMES_A_SCALED:
-            sak->applyConstant (image, data, planesize, param, bias,
-                                OpPequalsPtimesA_Scaled (rbias, rmultiplier),
-                                HistogramNull());
-            break;
-        case TOOL_P_DIVBY_A_SCALED:
-            sak->applyConstant (image, data, planesize, param, bias,
-                                OpPequalsPdivByA_Scaled (rbias, rmultiplier),
-                                HistogramNull());
-            break;
-        case TOOL_A_DIVBY_P_SCALED:
-            sak->applyConstant (image, data, planesize, param, bias,
-                                OpPequalsAdivByP_Scaled (rbias, rmultiplier),
-                                HistogramNull());
-            break;
-        case TOOL_MIN_P_A_SCALED:
-            sak->applyConstant (image, data, planesize, param, bias,
-                                OpPequalsMinPA_Scaled (rbias, rmultiplier),
-                                HistogramNull());
-            break;
-        case TOOL_MAX_P_A_SCALED:
-            sak->applyConstant (image, data, planesize, param, bias,
-                                OpPequalsMaxPA_Scaled (rbias, rmultiplier),
-                                HistogramNull());
-            break;
-
-        case TOOL_A_SCALED_WITH_HISTOGRAM:
-            sak->applyConstant (image, data, planesize, param, bias,
-                                OpPequalsA_Scaled (rbias, rmultiplier),
-                                *histogram);
-            break;
-        case TOOL_P_SCALED_WITH_HISTOGRAM: // HERE: we could optimize this if we wanted to
-            sak->applyConstant (image, data, planesize, param, bias,
-                                OpPequalsP_Scaled (rbias, rmultiplier),
-                                *histogram);
-            break;
-        case TOOL_P_MINUS_A_SCALED_WITH_HISTOGRAM:
-            sak->applyConstant (image, data, planesize, param, bias,
-                                OpPequalsPminusA_Scaled (rbias, rmultiplier),
-                                *histogram);
-            break;
-        case TOOL_A_MINUS_P_SCALED_WITH_HISTOGRAM:
-            sak->applyConstant (image, data, planesize, param, bias,
-                                OpPequalsAminusP_Scaled (rbias, rmultiplier),
-                                *histogram);
-            break;
-        case TOOL_P_PLUS_A_SCALED_WITH_HISTOGRAM:
-            sak->applyConstant (image, data, planesize, param, bias,
-                                OpPequalsPplusA_Scaled (rbias, rmultiplier),
-                                *histogram);
-            break;
-        case TOOL_P_TIMES_A_SCALED_WITH_HISTOGRAM:
-            sak->applyConstant (image, data, planesize, param, bias,
-                                OpPequalsPtimesA_Scaled (rbias, rmultiplier),
-                                *histogram);
-            break;
-        case TOOL_P_DIVBY_A_SCALED_WITH_HISTOGRAM:
-            sak->applyConstant (image, data, planesize, param, bias,
-                                OpPequalsPdivByA_Scaled (rbias, rmultiplier),
-                                *histogram);
-            break;
-        case TOOL_A_DIVBY_P_SCALED_WITH_HISTOGRAM:
-            sak->applyConstant (image, data, planesize, param, bias,
-                                OpPequalsAdivByP_Scaled (rbias, rmultiplier),
-                                *histogram);
-            break;
-        case TOOL_MIN_P_A_SCALED_WITH_HISTOGRAM:
-            sak->applyConstant (image, data, planesize, param, bias,
-                                OpPequalsMinPA_Scaled (rbias, rmultiplier),
-                                *histogram);
-            break;
-        case TOOL_MAX_P_A_SCALED_WITH_HISTOGRAM:
-            sak->applyConstant (image, data, planesize, param, bias,
-                                OpPequalsMaxPA_Scaled (rbias, rmultiplier),
-                                *histogram);
-            break;
-
-        default:
-            fprintf (stderr, "SwissArmyKnife: unknown operation (tool) %d!\n",
-                     param->tool);
-            return 0;
-        }
-    }
-    else
-    {
-        fprintf (stderr, "ooops!  input selection botch in SwissArmyKnife!\n");
-        return 0;
-    }
-
-    if (histogram)
-    {
-        histogram->frame_check();
-        delete histogram;
-    }
-
-    // HERE: the following two lines do a luma-only-ize
-
-    memset (UPLANE (data), 128, planesize >> 2);
-    memset (VPLANE (data), 128, planesize >> 2);
-
-    data->copyInfo(image);
-
-    return 1;
-}	                           

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidSwissArmyKnife.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidSwissArmyKnife.h	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidSwissArmyKnife.h	2009-10-02 05:22:11 UTC (rev 5365)
@@ -1,323 +0,0 @@
-/***************************************************************************
-                          ADM_vidSwissArmyKnife.h  -  Perform one of many
-                                                      possible operations
-                             -------------------
-                          Chris MacGregor, 2005, 2007
-                         chris-avidemux at bouncingdog.com
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
- 
-#ifndef __SWISSARMYKNIFE__
-#define __SWISSARMYKNIFE__   
-
-#include <map>
-
-
-//#include <vector>
-#include <string>
-
-#include <sys/time.h>
-
-struct SWISSARMYKNIFE_PARAM
-{
-    uint32_t tool; // ADMVideoSwissArmyKnife::Tool
-    uint32_t input_type; // ADMVideoSwissArmyKnife::Input
-
-    std::string input_file;
-    float load_bias;
-    float load_multiplier;
-
-    float input_constant;
-
-    float    memory_constant_alpha;
-    uint32_t lookahead_n_frames;
-    uint32_t init_start_frame;
-    uint32_t init_end_frame;
-    uint32_t init_by_rolling;
-
-    int32_t  bias;
-    float    result_bias;
-    float    result_multiplier;
-    uint32_t histogram_frame_interval;
-    uint32_t debug;
-
-    bool     enable_preview;  // not loaded/stored; only for dialog
-};
-
-// Alas, because offsetof() is only supposed to work on POD (plain old data)
-// structs, and our SWISSARMYKNIFE_PARAM includes a std::string (which has a
-// constructor, and which causes SWISSARMYKNIFE_PARAM to therefore have an
-// implicit constructor), we need to define our own offsetof() to use for the
-// dialog menus.  See
-// http://www.cplusplus.com/reference/clibrary/cstddef/offsetof.html for more
-// on offsetof().
-
-#define my_offsetof(_type, _memb) (size_t (&(((_type *)1)->_memb)) - 1)
-
-class ADMVideoSwissArmyKnife : public AVDMGenericVideoStream
-{
-protected:
-    	
-    // This is a hack to work around the fact that the ctor & dtor get called
-    // too often.  The right solution would be to arrange for the filter
-    // objects to be constructed and destructed only when really necessary:
-    // when a new instance of a filter is added to the list (by the user), it
-    // is constructed, and when it is removed from the list (by the user), it
-    // is destructed, and anything else is handled by a separate init() or
-    // configure() method.  This would allow the objects to maintain a
-    // persistent state in a more straightforward way.
-
-    //typedef std::vector <float> FloatVector;
-
-    class PersistentInfo
-    {
-    public:
-        CONFcouple *  conf;
-        CONFcouple *  oldConf;
-        uint32_t      refCount;
-
-        //FloatVector   kernel;
-        uint32_t      kernel_w;
-        uint32_t      kernel_h;
-
-        uint32_t      image_w;
-        uint32_t      image_h;
-        float         image_bias;
-        float         image_multiplier;
-        uint8_t *     image_int;
-        float *       image_float;
-
-        std::string   input_file_name;
-        time_t        input_file_mtime;
-
-        float *       bg;
-        float         bg_mca;
-        ADMImage *    bg_lab; // lookahead buffer
-        uint32_t      bg_lab_size;
-        uint32_t      bg_lanf;
-        uint32_t      bg_isf;
-        uint32_t      bg_ief;
-        uint32_t      bg_x;
-        uint32_t      bg_y;
-
-        uint32_t      histogram_frame_interval;
-        uint32_t *    histogram_input_data;
-        uint32_t *    histogram_output_data;
-        uint32_t      histogram_frame_count;
-
-        bool          bg_ibr;
-        bool          histogram_data_invalid;
-        bool          image_data_invalid;
-
-        PersistentInfo ()
-            : conf (0),
-              oldConf (0),
-              refCount (0),
-
-              kernel_w (0),
-              kernel_h (0),
-
-              image_w (0),
-              image_h (0),
-              image_bias (0),
-              image_multiplier (0),
-              image_int (0),
-              image_float (0),
-
-              input_file_mtime (0),
-
-              bg (0),
-              bg_mca (0),
-              bg_lab (0),
-              bg_lab_size (0),
-              bg_lanf (0),
-              bg_isf (0),
-              bg_ief (0),
-              bg_x (0),
-              bg_y (0),
-
-              histogram_frame_interval (0),
-              histogram_input_data (0),
-              histogram_output_data (0),
-              histogram_frame_count (0),
-
-              bg_ibr (false),
-              histogram_data_invalid (false),
-              image_data_invalid (false)
-        {
-        }
-
-        ~PersistentInfo ()
-        {
-            delete [] image_int;
-            delete [] image_float;
-            delete [] bg;
-            delete bg_lab;
-            delete [] histogram_input_data;
-            delete [] histogram_output_data;
-        }
-    };
-
-    typedef std::map <CONFcouple *, PersistentInfo *> PImap;
-    static PImap pimap;
-
-    PersistentInfo * myInfo;
-
-public:
-    enum Input
-    {
-        INPUT_INVALID = 0,
-
-        INPUT_FILE_IMAGE_FLOAT,
-        INPUT_FILE_IMAGE_INTEGER,
-        INPUT_CUSTOM_CONVOLUTION,
-        INPUT_CONSTANT_VALUE,
-        INPUT_ROLLING_AVERAGE,
-
-        INPUT_COUNT
-    };
-
-protected:
-    enum Tool
-    {
-        TOOL_INVALID = 0,
-
-        TOOL_A,          // P' = A
-        TOOL_P,          // P' = P
-        TOOL_P_MINUS_A,  // P' = P - A
-        TOOL_A_MINUS_P,  // P' = A - P
-        TOOL_P_PLUS_A,   // P' = P + A
-        TOOL_P_TIMES_A,  // P' = P * A
-        TOOL_P_DIVBY_A,  // P' = P / A
-        TOOL_A_DIVBY_P,  // P' = A / P
-        TOOL_MIN_P_A,    // P' = min (P, A)
-        TOOL_MAX_P_A,    // P' = max (P, A)
-
-        TOOL_A_WITH_HISTOGRAM,
-        TOOL_P_WITH_HISTOGRAM,
-        TOOL_P_MINUS_A_WITH_HISTOGRAM,
-        TOOL_A_MINUS_P_WITH_HISTOGRAM,
-        TOOL_P_PLUS_A_WITH_HISTOGRAM,
-        TOOL_P_TIMES_A_WITH_HISTOGRAM,
-        TOOL_P_DIVBY_A_WITH_HISTOGRAM,
-        TOOL_A_DIVBY_P_WITH_HISTOGRAM,
-        TOOL_MIN_P_A_WITH_HISTOGRAM,
-        TOOL_MAX_P_A_WITH_HISTOGRAM,
-
-        TOOL_A_SCALED,
-        TOOL_P_SCALED,
-        TOOL_P_MINUS_A_SCALED,
-        TOOL_A_MINUS_P_SCALED,
-        TOOL_P_PLUS_A_SCALED,
-        TOOL_P_TIMES_A_SCALED,
-        TOOL_P_DIVBY_A_SCALED,
-        TOOL_A_DIVBY_P_SCALED,
-        TOOL_MIN_P_A_SCALED,
-        TOOL_MAX_P_A_SCALED,
-
-        TOOL_A_SCALED_WITH_HISTOGRAM,
-        TOOL_P_SCALED_WITH_HISTOGRAM,
-        TOOL_P_MINUS_A_SCALED_WITH_HISTOGRAM,
-        TOOL_A_MINUS_P_SCALED_WITH_HISTOGRAM,
-        TOOL_P_PLUS_A_SCALED_WITH_HISTOGRAM,
-        TOOL_P_TIMES_A_SCALED_WITH_HISTOGRAM,
-        TOOL_P_DIVBY_A_SCALED_WITH_HISTOGRAM,
-        TOOL_A_DIVBY_P_SCALED_WITH_HISTOGRAM,
-        TOOL_MIN_P_A_SCALED_WITH_HISTOGRAM,
-        TOOL_MAX_P_A_SCALED_WITH_HISTOGRAM,
-
-        TOOL_TOTAL_COUNT,
-
-        TOOL_ADD_HISTOGRAM = TOOL_A_WITH_HISTOGRAM - TOOL_A,
-        TOOL_ADD_SCALING = TOOL_A_SCALED - TOOL_A,
-    };
-
-    struct ToolMap
-    {
-        Tool toolid;
-        const char * outputName; // displayed name
-        const char * format;     // printf format (%s is A)
-        const char * spacy_format; // same with more whitespace
-    };
-
-    static ToolMap tool_map [];
-
-    SWISSARMYKNIFE_PARAM * _param;
-
-public:
-
-    ADMVideoSwissArmyKnife (AVDMGenericVideoStream *in,CONFcouple *setup);
-    ~ADMVideoSwissArmyKnife();
-
-    virtual uint8_t getFrameNumberNoAlloc (uint32_t frame, uint32_t *len,
-                                           ADMImage *data, uint32_t *flags);
-
-    virtual uint8_t configure (AVDMGenericVideoStream *instream);
-    virtual char * printConf (void);
-    virtual uint8_t getCoupledConf (CONFcouple **couples);
-
-    static char * getConf (SWISSARMYKNIFE_PARAM * param, bool forDialog);
-
-    static uint8_t doSwissArmyKnife (ADMImage * from_image,
-                                     ADMImage * lookaheadimage,
-                                     ADMImage * to_image,
-                                     AVDMGenericVideoStream * in,
-                                     ADMVideoSwissArmyKnife * sak,
-                                     SWISSARMYKNIFE_PARAM * param,
-                                     uint32_t width, uint32_t height);
-
-private:
-
-    template <typename Oper, typename Histo>
-    void computeRollingAverage (ADMImage * image, ADMImage * data,
-                                uint32_t planesize,
-                                SWISSARMYKNIFE_PARAM * param,
-                                int32_t bias,
-                                const Oper & op_in,
-                                const Histo & histogram_in);
-
-    template <typename Oper, typename Histo>
-    void computeRollingAverage (ADMImage * image, ADMImage * lookaheadimage,
-                                ADMImage * data,
-                                uint32_t planesize,
-                                SWISSARMYKNIFE_PARAM * param,
-                                int32_t bias,
-                                const Oper & op_in,
-                                const Histo & histogram_in);
-
-    template <typename InputImageType, typename Oper, typename Histo>
-    void applyImage (ADMImage * image, ADMImage * data,
-                     uint32_t planesize,
-                     SWISSARMYKNIFE_PARAM * param,
-                     int32_t bias, InputImageType * input_image,
-                     const Oper & op_in, const Histo & histogram_in);
-
-    template <typename Oper, typename Histo>
-    void applyConstant (ADMImage * image, ADMImage * data,
-                        uint32_t planesize,
-                        SWISSARMYKNIFE_PARAM * param,
-                        int32_t bias,
-                        const Oper & op_in,
-                        const Histo & histogram_in);
-    const ADV_Info & getInfo () const
-    {
-        return _info;
-    }
-};
-
-struct MenuMapping;
-uint8_t DIA_SwissArmyKnife (AVDMGenericVideoStream * in,
-                            ADMVideoSwissArmyKnife * sakp,
-                            SWISSARMYKNIFE_PARAM * param,
-                            const MenuMapping * menu_mapping,
-                            uint32_t menu_mapping_count);
-
-#endif

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidThreshold.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidThreshold.cpp	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidThreshold.cpp	2009-10-02 05:22:11 UTC (rev 5365)
@@ -1,251 +0,0 @@
-/***************************************************************************
-                          ADM_vidThreshold.cpp  -  do thresholding
-                              -------------------
-                          Chris MacGregor, 2005, 2007
-                         chris-avidemux at bouncingdog.com
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
- 
-#include "ADM_default.h"
-#include "ADM_videoFilter.h"
-#include "DIA_factory.h"
-#include "ADM_vidThreshold.h"
-
-// #define THRESHOLD_HISTO 1
-
-static FILTER_PARAM thresholdParam={4,{"min", "max", "in_range_is_white", "debug"}};
-
-SCRIPT_CREATE(threshold_script,ADMVideoThreshold,thresholdParam);
-
-BUILD_CREATE(threshold_create,ADMVideoThreshold);
-
-ADMVideoThreshold::ADMVideoThreshold (AVDMGenericVideoStream *in,
-                                      CONFcouple *couples)
-			
-{
-    printf ("ADMVideoThreshold ctor (%p)\n", this);
-    _in = in;
-    memcpy (&_info,in->getInfo(),sizeof(_info));
-    _info.encoding = 1;
-    _uncompressed = new ADMImage(_in->getInfo()->width, _in->getInfo()->height);
-    ADM_assert (_uncompressed);
-    _param = new THRESHOLD_PARAM;
-    if (couples)
-    {
-        GET(min);
-        GET(max);
-        GET(in_range_is_white);
-        GET(debug);
-    }
-    else
-    {
-        _param->min = 100;
-        _param->max = 200;
-        _param->in_range_is_white = 1;
-        _param->debug = 0;
-    }
-
-    computeLookupTable (_param);
-}
-
-uint8_t ADMVideoThreshold::computeLookupTable (THRESHOLD_PARAM * param)
-{
-    uint8_t changed = false;
-
-    if (param->min > param->max)
-    {
-        uint32_t tmp = param->min;
-        param->min = param->max;
-        param->max = tmp;
-        param->in_range_is_white = !param->in_range_is_white;
-        changed = true;
-    }
-
-    uint32_t min = param->min;
-    uint32_t max = param->max;
-    ADM_assert (min <= max);
-
-    uint8_t in_range_value;
-    uint8_t out_of_range_value;
-
-    if (param->in_range_is_white)
-    {
-        in_range_value = 255;
-        out_of_range_value = 0;
-    }
-    else
-    {
-        in_range_value = 0;
-        out_of_range_value = 255;
-    }
-
-    for (uint32_t i = 0; i <= 255; i++)
-    {
-        if (i < min || i > max)
-            lookup_table [i] = out_of_range_value;
-        else
-            lookup_table [i] = in_range_value;
-    }
-
-    return changed;
-}
-
-uint8_t	ADMVideoThreshold::getCoupledConf( CONFcouple **couples)
-{
-
-    ADM_assert(_param);
-    *couples = new CONFcouple(thresholdParam.nb);
-
-#define CSET(x)  (*couples)->setCouple((char *)#x,(_param->x))
-    CSET(min);
-    CSET(max);
-    CSET(in_range_is_white);
-    CSET(debug);
-
-    return 1;
-}
-
-uint8_t ADMVideoThreshold::configure (AVDMGenericVideoStream *in)
-{
-    uint8_t ret = DIA_threshold (_in, this, _param);
-    if (ret == 1)
-    {
-        computeLookupTable (_param);
-        return ret;
-    }
-    else if (ret == 0) // 0 = cancel
-    {
-        computeLookupTable (_param);
-        return ret;
-    }
-    else
-    {
-        ADM_assert (ret == 255); // 255 = whizzy dialog not implemented
-    }
-
-    diaElemUSlider minslide(&(_param->min), QT_TR_NOOP("Mi_nimum value to be in-range:"), 0, 255);
-    diaElemUSlider maxslide(&(_param->max), QT_TR_NOOP("Ma_ximum value to be in-range:"), 0, 255);
-
-    diaMenuEntry tInRangeIsWhite [] = {
-        { 1, QT_TR_NOOP("In-range values go white, out-of-range go black"), NULL },
-        { 0, QT_TR_NOOP("In-range values go black, out-of-range go white"), NULL },
-    };
-
-    diaElemMenu in_range_is_white
-        (&(_param->in_range_is_white),
-         QT_TR_NOOP("Output values:"),
-         sizeof (tInRangeIsWhite) / sizeof (diaMenuEntry), tInRangeIsWhite);
-
-    diaElemUInteger debug(&(_param->debug), QT_TR_NOOP("_Debugging settings (bits):"),
-                          0, 0x7fffffff);
-    diaElem * elems[] = { &minslide, &maxslide, &in_range_is_white, &debug };
-
-    ret = diaFactoryRun(QT_TR_NOOP("Threshold Configuration"), sizeof (elems) / sizeof (diaElem *), elems);
-
-    if (ret) // 0 = cancel
-    {
-        computeLookupTable (_param);
-    }
-
-    return ret;
-}
-
-ADMVideoThreshold::~ADMVideoThreshold()
-{
-    printf ("ADMVideoThreshold dtor (%p)\n", this);
-    DELETE(_param);
-    delete _uncompressed;	
-    _uncompressed = NULL;
-}
-
-char *ADMVideoThreshold::printConf (void) 
-{
-    const int CONF_LEN = 100;
-    static char conf[CONF_LEN];
-    char * cptr = conf;
-    cptr += snprintf (conf, CONF_LEN, "Threshold: In-range values (%u - %u) "
-                      "go %s, others %s",
-                      _param->min, _param->max,
-                      _param->in_range_is_white ? "white" : "black",
-                      _param->in_range_is_white ? "black" : "white");
-    if (_param->debug)
-        snprintf (cptr, CONF_LEN - (cptr - conf), "; debug=0x%x", _param->debug);
-
-    return conf;
-}
-
-uint8_t ADMVideoThreshold::getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-          			ADMImage *data,uint32_t *flags)
-{
-    if (frame>= _info.nb_frames)
-        return 0;
-
-    uint32_t debug = _param->debug;
-
-    if (debug & 1)
-        printf ("in ADMVideoThreshold::getFrameNumberNoAlloc(%d, ...)\n",
-                frame);
-
-    uint32_t planesize = _info.width * _info.height;
-    uint32_t size = (planesize * 3) >> 1;
-    *len = size;
-			
-    if (!_in->getFrameNumberNoAlloc (frame, len, _uncompressed, flags))
-        return 0;
-    ADMImage * image = _uncompressed;
-
-    // HERE: for speed, we do luma (Y plane) only.  However, some
-    // users might want chroma, too... we should make that
-    // an option or something.
-
-    uint8_t * currp = YPLANE (image) + planesize;
-    uint8_t * destp = YPLANE (data) + planesize;
-    uint32_t pixremaining = planesize + 1;
-
-    while (--pixremaining)
-    {
-        int32_t curr = *--currp;
-
-        *--destp = lookup_table [curr];
-    }
-
-    // HERE: the following two lines do a luma-only-ize
-
-    memset (UPLANE (data), 128, planesize >> 2);
-    memset (VPLANE (data), 128, planesize >> 2);
-
-    data->copyInfo (image);
-    return 1;
-}	                           
-
-// This is used by the preview code for the configuration dialog.
-
-void ADMVideoThreshold::doThreshold (ADMImage * from, ADMImage * to,
-                                     ADMVideoThreshold * thresholdp,
-                                     uint32_t pixelcount)
-{
-    uint8_t * currp = YPLANE (from) + pixelcount;
-    uint8_t * destp = YPLANE (to) + pixelcount;
-    uint32_t pixremaining = pixelcount + 1;
-    const uint8_t * table = thresholdp->lookup_table;
-
-    while (--pixremaining)
-    {
-        int32_t curr = *--currp;
-
-        *--destp = table [curr];
-    }
-
-    // HERE: the following two lines do a luma-only-ize
-
-    memset (UPLANE (to), 128, pixelcount >> 2);
-    memset (VPLANE (to), 128, pixelcount >> 2);
-}

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidThreshold.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidThreshold.h	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidThreshold.h	2009-10-02 05:22:11 UTC (rev 5365)
@@ -1,63 +0,0 @@
-/***************************************************************************
-                          ADM_vidThreshold.h  -  do thresholding
-                              -------------------
-                          Chris MacGregor, 2005, 2007
-                         chris-avidemux at bouncingdog.com
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
- 
-#ifndef __THRESHOLD__
-#define __THRESHOLD__   
-
-
-typedef struct THRESHOLD_PARAM
-{
-
-    uint32_t min;
-    uint32_t max;
-    uint32_t in_range_is_white;
-    uint32_t debug;
-
-} THRESHOLD_PARAM;
-
-class ADMVideoThreshold : public AVDMGenericVideoStream
-{
- protected:
-    	
-     THRESHOLD_PARAM * _param;
-     uint8_t lookup_table [256];
-
- public:
- 		
-
-     ADMVideoThreshold (AVDMGenericVideoStream *in, CONFcouple *setup);
-
-     ~ADMVideoThreshold();
-
-     virtual uint8_t 	getFrameNumberNoAlloc (uint32_t frame, uint32_t *len,
-                                               ADMImage *data,uint32_t *flags);
-
-     virtual uint8_t 	configure (AVDMGenericVideoStream *instream);
-     virtual char *     printConf(void);
-     virtual uint8_t 	getCoupledConf (CONFcouple **couples);
-
-     uint8_t computeLookupTable (THRESHOLD_PARAM * param);
-
-     static void doThreshold (ADMImage * from, ADMImage * to,
-                              ADMVideoThreshold * thresholdp,
-                              uint32_t pixelcount);
-};
-
-uint8_t DIA_threshold (AVDMGenericVideoStream *in,
-                       ADMVideoThreshold * thresholdp,
-                       THRESHOLD_PARAM * param);
-
-#endif

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidUnblend_param.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidUnblend_param.h	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidUnblend_param.h	2009-10-02 05:22:11 UTC (rev 5365)
@@ -1,26 +0,0 @@
-/***************************************************************************
-        See avisynth unblend
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#ifndef UNBLEND_PARAM_H
-#define UNBLEND_PARAM_H
-
-typedef struct PARAM_UNBLEND
-{
-        uint32_t show;
-        uint32_t threshold;
-        float    dthresh;
-
-}PARAM_UNBLEND;
-
-
-#endif

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidVobSub.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidVobSub.h	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidVobSub.h	2009-10-02 05:22:11 UTC (rev 5365)
@@ -1,81 +0,0 @@
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#ifndef _VOBSUB_V_
-#define _VOBSUB_V_
-#include "ADM_coreDemuxerMpeg/include/dmx_demuxerPS.h"
-#define VS_MAXPACKET 128*1024
-
-#define NOSUB 0xffffffff
-
-#define MAX_DISPLAY_TIME 3000 // 3s
-
-//************************************
-typedef struct vobSubParam
-{
-        char            *subname;
-        uint32_t        index;
-        int32_t         subShift;
-}vobSubParam;
-//************************************
-#include "ADM_videoFilter/ADM_vidVobSubBitmap.h"
-//************************************
-class  ADMVideoVobSub:public AVDMGenericVideoStream
- {
-
- protected:
-        virtual char                    *printConf(void);
-        uint8_t                         guessPalette(void);
-        uint8_t                         readbyte(void);         /// Read a byte from buffer
-        uint16_t                        readword(void);         /// Read a 16 bits word from buffer
-        uint8_t                         forward(uint32_t v);    /// Read a 16 bits word from buffer
-        uint8_t                         decodeRLE(uint32_t off,uint32_t start,uint32_t end);
-        uint8_t                         setup(void);            /// Rebuild internal info
-        uint8_t                         cleanup(void);          /// Destroy all internal info
-        uint8_t                         paletteYUV( void );     /// Convert RGB Pallette to yuv
-        uint8_t                         Palettte2Display( void ); /// Convert the RLE to YUV bitmap
-        uint8_t                         handleSub( uint32_t idx );/// Decode a sub packet
-        uint32_t                        lookupSub(uint64_t time);/// Return sub index corresponding to time
-        
-        dmx_demuxerPS                   *_parser;        
-        uint8_t                         *_data;                 /// Data for packet
-        VobSubInfo                      *_vobSubInfo;           /// Info of the index file
-        vobSubParam                     *_param;
-        vobSubBitmap                    *_original;              /// True size (..) depacked vobsub
-        vobSubBitmap                    *_resampled;            /// Final one; to be blended in picture
-        vobSubBitmap                    *_chromaResampled;      /// Same as above but shinked by 2
-        uint32_t                        _x1,_y1,_x2,_y2;        /// sub boxing
-        uint32_t                        _subW,_subH;
-        uint8_t                         _displaying;            ///  Is display active
-        uint32_t                        _curOffset;
-        uint32_t                        _subSize;
-        uint32_t                        _dataSize;              /// Size of the data chunk
-        
-        uint8_t                         _colors[4];             /// Colors palette
-        uint8_t                         _alpha[4];              /// Colors alpha
-        int16_t                         _YUVPalette[16];        /// Luma only
-        uint32_t                        _currentSub;            ///
-        uint32_t                        _initialPts;
- public:
-    /* This 3 functions are used by OCR */
-                        ADMVideoVobSub(  char *fileidx,uint32_t idx);
-              vobSubBitmap *getBitmap(uint32_t nb,uint32_t *start, uint32_t *end,uint32_t *first,uint32_t *last);
-              uint32_t     getNbImage( void);
-    /* /ocr */ 
-    
-                        ADMVideoVobSub(  AVDMGenericVideoStream *in,CONFcouple *setup);
-                        ~ADMVideoVobSub();
-        virtual uint8_t getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-                                                ADMImage *data,uint32_t *flags);
-        virtual uint8_t getCoupledConf( CONFcouple **couples)           ;
-        virtual uint8_t configure( AVDMGenericVideoStream *instream);
-                                                        
-};
-#endif

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidVobSubBitmap.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidVobSubBitmap.h	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidVobSubBitmap.h	2009-10-02 05:22:11 UTC (rev 5365)
@@ -1,40 +0,0 @@
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#ifndef _VOBSUB_BITMAP_H
-#define _VOBSUB_BITMAP_H
-//************************************
-class vobSubBitmap
-{
-  protected:
-        uint8_t                         *_dirty;                   /// Dirty lines (non transparent)
-  public:
-        uint8_t                         isDirty(uint32_t line);
-        uint8_t                         setDirty(uint32_t line);
-
-        uint32_t                        _width,_height;
-        uint32_t                        placeTop, placeHeight;     /// Position of the sub
-      
-        uint8_t                         *_bitmap;                  /// YUV image
-        uint8_t                         *_alphaMask;               /// alpha mask 
-        
- 
-                                        vobSubBitmap(uint32_t w, uint32_t h); 
-                                        ~vobSubBitmap();
-        void                            clear(void);
-        
-                                        /// Convert palette bitmap to yuv&mask bitmap
-        uint8_t                         buildYUV( int16_t *palette ); 
-                                        /// Generate the final bitmap (resized)
-        uint8_t                         subResize(vobSubBitmap **tgt,uint32_t newx,uint32_t newy,
-                                                uint32_t oldtop, uint32_t oldheight);
-};
-
-#endif

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidVobSubRender.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidVobSubRender.cpp	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidVobSubRender.cpp	2009-10-02 05:22:11 UTC (rev 5365)
@@ -1,663 +0,0 @@
-//
-// C++ Implementation: %{MODULE}
-//
-// Description:
-//
-//
-// Author: %{AUTHOR} <%{EMAIL}>, (C) %{YEAR}
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-//
-// C++ Implementation:Spudecoder (subs for DVd like stream)
-//
-// Description:
-//
-//
-// Author: Mean, fixounet at free.fr
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-// see http://sam.zoy.org/writings/dvd/subtitles/
-
-/*
-        This part of the vobsub stuff 
-                - decodes the command spu block
-                - rle decode the bitmap itself
-                
-        
-       palettized is the palette based decoded sub
-       
-       Elsewhere
-       
-       bitmap & alphamask are the bitmap & alpha channel stuff
-       subW & subH are width and height of them
-       
-       The RLE decoder is derivated from mplayer one
-*/
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-
-#include "ADM_assert.h"
-#include "config.h"
-#include "fourcc.h"
-
-#include "avi_vars.h"
-
-
-#include "ADM_videoFilter.h"
-#include "DIA_fileSel.h"
-#include "ADM_colorspace.h"
-#include "ADM_vobsubinfo.h"
-#include "ADM_vidVobSub.h"
-
-
-extern "C" {
-#include "ADM_libraries/ADM_ffmpeg/ADM_lavcodec/avcodec.h"
-#include "ADM_libraries/ADM_ffmpeg/ADM_lavutil/avutil.h"
-#include "ADM_libraries/ADM_ffmpeg/ADM_libswscale/swscale.h"
-}
-
-
-
-#include "ADM_osSupport/ADM_debugID.h"
-#define MODULE_NAME MODULE_FILTER
-#include "ADM_osSupport/ADM_debug.h"
-
-//*************************************************************
-uint8_t ADMVideoVobSub::forward(uint32_t v)
-{
-        aprintf("Current : %lu forwarding : %lu\n",_curOffset,v);
-         if(_curOffset+v>=_subSize) return 0;
-         _curOffset+=v;
-         return 1;
-
-}
-//*************************************************************
-uint8_t ADMVideoVobSub::readbyte( void )
-{
-        ADM_assert(_curOffset<_subSize);
-        return _data[_curOffset++];
-
-}
-//*************************************************************
-uint16_t ADMVideoVobSub::readword( void )
-{
-uint16_t w;
-        ADM_assert(_curOffset<_subSize-1);
-        w= _data[_curOffset]<<8;
-        w+= _data[_curOffset+1];
-        _curOffset+=2;
-        return w;
-}
-//***********************************************************
-//      Convert RGB Palette to YUV Palette
-//      ALL 16 of them
-//
-uint8_t ADMVideoVobSub::paletteYUV( void )
-{
-uint8_t r,g,b,a;
-uint8_t y;
-int8_t u,v;
-uint32_t value;
-        for(int i=0;i<16;i++)
-        {
-               value=_vobSubInfo->Palette[i];
-               r=(value>>16)&0xff;
-               g=(value>>8)&0xff; 
-               b=(value)&0xff;
-               
-               COL_RgbToYuv(b,  g,  r, &y, &u,&v);
-               
-                _YUVPalette[i]=y;
-                //_YUVPalette[i][1]=u;
-                //_YUVPalette[i][2]=v;
-        
-        }
-        return 1;
-
-}
-
-
-//***********************************************************
-// RLE code inspired from mplayer
-uint8_t ADMVideoVobSub::decodeRLE(uint32_t off,uint32_t start,uint32_t end)
-{
-
-        if(!_original) return 0;
-
-        uint32_t oldoffset=_curOffset;
-        uint32_t stride=_subW;
-        uint32_t x,y;
-        uint8_t *ptr=_original->_bitmap;
-        uint8_t *alpha=_original->_alphaMask;
-        uint32_t a,b;
-        int     nibbleparity=0;
-        int     nibble=0;
-        
-        int run,color;
-        
-#define SKIPNIBBLE        {nibbleparity=0;}
-#define NEXTNIBBLE(x) if(nibbleparity){ x=nibble&0xf;nibbleparity=0;}else {nibble=readbyte();nibbleparity=1;x=nibble>>4;}
-       
-        _curOffset=off;
-        aprintf("Vobsub: Rle at offset :%d datasize:%d (stride:%d)\n",off,_dataSize,stride);
-        if(!ptr)
-        {
-                printf("Vobsub:No infos yet RLE data...\n");
-                 return 1;
-        }
-        x=0;
-        y=0;
-        while(
-               (_curOffset<_dataSize)
-            && (y<(_subH>>1)) 
-            && ((!end) || (_curOffset<end))
-        )
-        {
-               NEXTNIBBLE(a);
-               if(a<4)
-               {
-                 a<<=4;
-                 NEXTNIBBLE(b);
-                 a|=b;
-                 if(a<0x10)
-                 {
-                        a<<=4;
-                        NEXTNIBBLE(b);
-                        a|=b;
-                        if(a<0x40)
-                        {
-                                a<<=4;
-                                NEXTNIBBLE(b);
-                                a|=b;
-                                if(a<0x100)
-                                {
-                                        a|=(stride-x)<<2;
-                                }
-                        }
-                 }
-              }
-              run=a>>2;
-              color=3-(a&0x3);
-             // aprintf("Vobsub: Run:%d color:%d\n",run,color);
-              if((run>stride-x) || !run)
-                run=stride-x;
-              
-              //memset(ptr,color,run);
-              memset(ptr,_colors[color],run);
-              memset(alpha,_alpha[color],run);
-              if(run!=stride) _original->setDirty(y*2+start);
-              x+=run;
-              ptr+=run;
-              alpha+=run;
-              //  aprintf("x:%d y:%d\n",x,y);
-              if(x>=stride)
-              {
-                        
-                     y++;
-                     x=0;
-                     ptr=_original->_bitmap+(y*2+start)*stride;
-                     alpha=_original->_alphaMask+(y*2+start)*stride;
-                     SKIPNIBBLE;
-              }
-        }
-        aprintf("vobsub End :%d y:%d\n",_curOffset,y); 
-        _curOffset=oldoffset;
-} 
-//***********************************************        
-// Decode Sub automaton command
-//***********************************************
-uint8_t  ADMVideoVobSub::handleSub( uint32_t idx )
-{       
-uint16_t date,next,dum;
-uint8_t  command;
-        _subSize=0;
-uint32_t pts;
-uint64_t posA,posR;
- uint32_t odd,even;
-int doneA=0;
-int doneB=0;
-        _parser->getPos(&posA,&posR);
-        // Read data
-aprintf("**Cur:A:%llx R:%llx next:%llx\n",posA,posR,_vobSubInfo->lines[idx+1].fileOffset);        
-while(posA<_vobSubInfo->lines[idx+1].fileOffset)
-{        
-        odd=even=0;
-        aprintf("**Cur: A:%llx R:%llx next:%llx\n",posA,posR,_vobSubInfo->lines[idx+1].fileOffset);
-        
-        _subSize=_parser->read16i();
-        if(!_subSize)
-        {
-            printf("Vobsub: error reading\n");
-            return 0;
-        }
-        
-        aprintf("Vobsub: data len =%d\n",_subSize);
-        
-        if(_subSize>VS_MAXPACKET-1)
-         {
-            printf("Vobsub: error reading (packet too big)\n");
-            return 0;
-        }
-        if(!_parser->read(_data+2,_subSize-2)) 
-        {
-                printf("VS: read failed\n");
-                return 0;
-        }
-       
-        // We got the full packet
-        // now scan it
-        _curOffset=2;
-        if(_subSize<4)
-        {
-          printf("[handleSub] Packet too short!\n");
-          return 1; 
-        }
-        _dataSize=readword();
-        aprintf("data block=%lu\n",_dataSize);
-        if(_dataSize<=4)
-        {
-            printf("Vobsub: data block too small\n");
-            return 0;       
-        }
-        
-        if(!forward(_dataSize-4)) return 0;    // go to the command block
-        
-        
-        while(2)
-        {
-                if(_curOffset>_subSize-5) break;
-                date=readword();
-                next=readword();
-                if(next==_curOffset-4) break;            // end of command
-                
-                while(_curOffset<next)
-                {
-                      
-                      
-                        command=readbyte();
-                        aprintf("vobsub:Command : %d date:%d next:%d cur:%lu\n",command,date,next,_curOffset);
-                        int left=next-_curOffset;
-                        switch(command)
-                        {
-                                case 00: _displaying=1;
-                                        break;
-                                case 01: // start date
-                                        break;
-                                case 02: // stop date
-#if 0                                
-                                        pts=_parser->getPTS();
-                                        if(!_vobSubInfo->lines[idx].stopTime)
-                                        {
-                                                double comp;
-                                           
-                                                comp=pts-_initialPts;
-                                                comp=comp/90;     // 90khz
-                                                comp+=date*10;    // 1/100th of a second
-                                                 _vobSubInfo->lines[idx].stopTime=(uint32_t)comp;
-                                                aprintf("****Sub: idx : %lu starts at :%lu end at :%lu\n",
-                                                        idx,
-                                                        _vobSubInfo->lines[idx].startTime, 
-                                                        _vobSubInfo->lines[idx].stopTime);
-                                        
-                                        }
-#endif                                        
-                                        break;
-                                case 03: // Pallette 4 nibble= 16 bits
-                                         if(left<2)
-                                         {
-                                            printf("Command 3: Palette: Not enough bytes left\n");
-                                            return 1; 
-                                         }
-                                         dum=readword();
-                                        _colors[0]=dum>>12;
-                                        _colors[1]=0xf & (dum>>8);
-                                        _colors[2]=0xf & (dum>>4);
-                                        _colors[3]=0xf & (dum);
-                                        break;          
-                                case 0xff:
-                                        break;
-                                case 04: // alpha channel
-                                         //4 nibble= 16 bits
-                                        if(left<2)
-                                         {
-                                            printf("Command 4: Alpha: Not enough bytes left\n");
-                                            return 1; 
-                                         }
-
-                                        dum=readword();
-                                        _alpha[0]=dum>>12;
-                                        _alpha[1]=0xf & (dum>>8);
-                                        _alpha[2]=0xf & (dum>>4);
-                                        _alpha[3]=0xf & (dum);
-                                        break;
-                                case 05:
-                                        // Coordinates 12 bits per entry X1/X2/Y1/Y2
-                                        // 48 bits total / 6 bytes
-                                        {
-                                                uint16_t a,b,c;
-                                                uint32_t nx1,nx2,ny1,ny2;
-                                                if(left<6)
-                                                {
-                                                    printf("Command 5: Coord: Not enough bytes left\n");
-                                                    return 1; 
-                                                }
-                                                if(doneA) return 1;
-                                                doneA++;
-                                                a=readword();
-                                                b=readword();
-                                                c=readword();
-                                                nx1=a>>4;
-                                                nx2=((a&0xf)<<8)+(b>>8);
-                                                ny1=((b&0xf)<<4)+(c>>12);
-                                                ny2=c&0xfff;
-                                                
-                                                aprintf("vobsuv: x1:%d x2:%d y1:%d y2:%d\n",nx1,nx2,ny1,ny2);
-                                                
-                                                if(nx1==_x1 && nx2==_x2 && ny1==_y1 && ny2==_y2 && _original)
-                                                {       // Reuse old bitmap
-                                                        _original->clear();
-                                                }
-                                                else
-                                                {
-                                                  if(_original)
-                                                        delete _original;
-                                                  _original=NULL;
-                                                  _x1=nx1;
-                                                  _x2=nx2;
-                                                  _y1=ny1;
-                                                  _y2=ny2;
-                                                  _subW=_x2-_x1+1;
-                                                  _subH=_y2-_y1+1;                                                
-                                                  _original=new vobSubBitmap(_subW,_subH);
-                                                }
-                                                                        
-                                        }
-                                        break;
-                                case 06: // RLE offset 
-                                        // 2*16 bits : odd offset, even offset
-                                        {
-                                                if(doneB) return 1;
-                                                doneB++;
-                                                if(left<4)
-                                                {
-                                                    printf("Command 6: RLE: Not enough bytes left\n");
-                                                    return 1; 
-                                                }
-                                        odd=readword();                                        
-                                        even=readword();
- 
-                                        }
-                                        break;   
-                                default:                                                     
-                                        printf("Unknown command:%d\n",command);
-                                        return 0;
-                                  
-                        } //End switch command     
-                }// end while
-        }
-        _parser->getPos(&posA,&posR);
-        /*****/
-        if(_original && odd && even) 
-        {
-                _original->clear();
-                decodeRLE(odd,0,even);
-                decodeRLE(even,1,0);
-                if(!_vobSubInfo->hasPalette)
-                {
-                        // guess palette   
-                        guessPalette();
-                }
-        }
-        /*****/
-  }   // Next picture  
-  return 1;
-}
-/*
-    Try to guess the palette...
-*/
-uint8_t ADMVideoVobSub::guessPalette(void)
-{
- int  stat[4];
- uint32_t sum,sumalpha,y,x;
- uint8_t *in,*inmax,*inalpha;
- int background,foreground,candidate1,candidate2;
- 
-    memset(stat,0,4*sizeof(int));
-   
-    in=_original->_bitmap ;
-    y=_original->_width*_original->_height;
-    inmax=in+y;
-    for(x=0;x<y;x++)
-    {
-        stat[(*in)&0x03]++;
-        in++; 
-           
-    }  
-    // normally just between 0 & 3
-    sum=stat[0]+stat[1]+stat[2]+stat[3];
-   
-    #define PERC(x) stat[x]*=10000;stat[x]/=sum;//alpha[x]*=1000;alpha[x]/=sumalpha;
-    PERC(0);
-    PERC(1);
-    PERC(2);
-    PERC(3);
-    int nbColor=0;
-    for(int i=0;i<4;i++) 
-    {
-        printf("Color : %d percent :%d \n",i,stat[i]);
-    }
-#define NB_COLOR nbColor=0;for(int i=0;i<4;i++) if(stat[i]) nbColor++;
-#define SEARCH_MAX(OUT) max=0;for(int o=0;o<4;o++) if(stat[o]>max) {max=stat[o];OUT=o;}stat[OUT]=0;
-#define SET_COLOR(x,color) for(int k=0;k<4;k++) _YUVPalette[x+4*k]=color;
-    // Search Max
-    int max=0;
-    memset(_YUVPalette,0,sizeof(_YUVPalette));
-    
-    // The most common color is background
-    SEARCH_MAX(background);
-    SET_COLOR(background,0);
-    printf("Background is %d\n",background);
- 
-    // Search for A/B /C
-    in=_original->_bitmap ;
-    while(in<inmax)
-    {
-        if(*in!=background) break;
-        in++;   
-    };
-    candidate1=*in; 
-    while(in<inmax)
-    {
-        if(*in!=candidate1) break;
-        in++;   
-    };
-    // if we have background / candidate / candidate2
-    //  we consider candidate to be blending and candidate2 to be solid
-    candidate2=*in;
-    if(candidate2!=background)
-    {
-        SET_COLOR(candidate1,0x40);
-        SET_COLOR(candidate2,0xFF); 
-    }else 
-    // We have background / candidate / background
-    // candidate is then considered solid color
-    {
-        SET_COLOR(candidate2,0xff);
-    }
-    return 1;
-    
-}
-
-vobSubBitmap::vobSubBitmap(uint32_t w, uint32_t h)
-{
-  uint32_t page;
-  
-  _width=w;
-  _height=h;
-  
-  page=w*h;
-   
-
-  _bitmap=new uint8_t [page];
-  _alphaMask=new uint8_t [page];
-  _dirty=new uint8_t[h];                                                
-  clear();
-}
-uint8_t vobSubBitmap::isDirty(uint32_t line)
-{
-        ADM_assert(line<_height);
-        if(_dirty[line]) return 1;
-        return 0;
-
-}
-uint8_t vobSubBitmap::setDirty(uint32_t line)
-{
-        ADM_assert(line<_height);
-        _dirty[line]=1;
-        return 1;
-}
-vobSubBitmap::~vobSubBitmap()
-{
-#define CLN(x) if(x) delete [] x;
-
-  CLN(_bitmap);
-  CLN(_alphaMask);  
-  CLN(_dirty);
-}
-void vobSubBitmap::clear(void)
-{
-#define CLR(x) memset(x,0,_width*_height);
-
-  CLR(_bitmap);
-  CLR(_alphaMask);
-  memset(_dirty,0,_height);
-}
-
-//***********************************************************
-// Convert the palette bitmap into yuv + alphamask bitmap
-//
-//***********************************************************
-uint8_t vobSubBitmap::buildYUV( int16_t *palette )
-{
-  
-  uint8_t *ptr;
-
-  ptr=_bitmap;      
-        
-  for(uint32_t y=0;y<_width*_height;y++)
-  {
-    *ptr=palette[*ptr];
-    ptr++;  
-  }
-  return 1;
-}
-//***********************************************************
-//
-//      Resample the square beginning at position = oldtop with a height of oldheigh
-//        to a square of size new, newy
-//
-//***********************************************************
-uint8_t vobSubBitmap::subResize(vobSubBitmap **tgt,uint32_t newx,uint32_t newy,uint32_t oldtop, uint32_t oldheight)
-{
-  int flags=0;
-  SwsContext *ctx=NULL;
-  int er=0;
-  
-  aprintf("Sub Resize : top %lu height %lu -> %lu %lu\n",oldtop, oldheight,newx, newy);
-  
-#if 0  
-//#ifdef USE_MMX
-                
-#define ADD(x,y) if( CpuCaps::has##x()) flags|=SWS_CPU_CAPS_##y;
-                ADD(MMX,MMX);           
-                ADD(3DNOW,3DNOW);
-                ADD(MMXEXT,MMX2);
-#endif  
-  flags+=SWS_BILINEAR;
-  // Need a new one ?
-  // Or reuse the old one ?
-  if(*tgt && (*tgt)->_width==newx && (*tgt)->_height==newy)
-  {
-    (*tgt)->clear(); // useless FIXME
-  }
-  else
-  {
-    if(*tgt) delete *tgt;
-    *tgt=NULL;
-    *tgt=new  vobSubBitmap(newx,newy);    
-  }
-  
-  // Need to resize ?
-  if(oldheight==newy && _width==newx)
-  {
-    uint8_t *src,*dst;
-    aprintf("No need to resize\n");
-    src=_bitmap+oldtop*_width;
-    dst=(*tgt)->_bitmap;
-    memcpy(dst,src,newx*newy); 
-    
-    src=_alphaMask+oldtop*_width;
-    dst=(*tgt)->_alphaMask;
-    memcpy(dst,src,newx*newy); 
-    
-    return 1;    
-  }
-  
-  ctx=sws_getContext(
-  _width,oldheight,
-  PIX_FMT_GRAY8,
-  newx,newy,
-  PIX_FMT_GRAY8,
-  flags,
-  NULL, NULL,NULL);
-
-  ADM_assert(ctx);
-    
-  //************************
-  uint8_t *src[3];
-  uint8_t *dst[3];
-  int ssrc[3];
-  int ddst[3];
-  
-
-  //resize bitmap
-  
-  src[0]=_bitmap+oldtop*_width;
-  src[1]=NULL;
-  src[2]=NULL;
-
-  ssrc[0]=_width;
-  ssrc[1]=ssrc[2]=0;
-
-  
-  dst[0]=(*tgt)->_bitmap;
-  dst[1]=NULL;
-  dst[2]=NULL;
-  
-  ddst[0]=newx;
-  ddst[1]=ddst[2]=0;
-
-  er=sws_scale(ctx,src,ssrc,0,oldheight,dst,ddst);
-  aprintf("Er:%d\n",er);
-  
-  // And alpha
-  src[0]=_alphaMask+oldtop*_width;  
-  dst[0]=(*tgt)->_alphaMask;
-  er=sws_scale(ctx,src,ssrc,0,_height,dst,ddst);
-  aprintf("Er:%d\n",er);
-  // end
-  sws_freeContext(ctx); 
-  return 1;             
-}
-
-//EOF

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidVobsub.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidVobsub.cpp	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vidVobsub.cpp	2009-10-02 05:22:11 UTC (rev 5365)
@@ -1,650 +0,0 @@
-//
-// C++ Implementation:Spudecoder (subs for DVd like stream)
-//
-// Description:
-//
-//
-// Author: Mean, fixounet at free.fr
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-// see http://sam.zoy.org/writings/dvd/subtitles/
-
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include "config.h"
-#include "ADM_default.h"
-#include "ADM_videoFilter.h"
-#include "DIA_fileSel.h"
-#include "ADM_colorspace.h"
-#include "ADM_vobsubinfo.h"
-#define VOBSUB "/capture/sub/phone.sub"
-#include "ADM_videoFilterDynamic.h"
-#include "ADM_vidVobSub.h"
-
-#include "ADM_osSupport/ADM_debugID.h"
-#define MODULE_NAME MODULE_FILTER
-#include "ADM_osSupport/ADM_debug.h"
-#include <math.h>
-
-extern uint8_t DIA_vobsub(vobSubParam *param);
-
-static FILTER_PARAM vobsubParam={3,{"subname","index","subShift"}};
-//*************************************************************
-//
-
-//*************************************************************
-SCRIPT_CREATE(vobsub_script,ADMVideoVobSub,vobsubParam);
-BUILD_CREATE(vobsub_create,ADMVideoVobSub);
-//*************************************************************
-uint8_t ADMVideoVobSub::configure(AVDMGenericVideoStream *in)
-{
-
-       
-  if(DIA_vobsub(_param))
-       {
-                cleanup();
-                setup();
-                return 1;
-       }
-        
-        return 0;        
-}
- 
-//*************************************************************
-char *ADMVideoVobSub::printConf( void )
-{
-    ADM_FILTER_DECLARE_CONF(" VobSub");
-        
-}
-//*************************************************************
-ADMVideoVobSub::ADMVideoVobSub(  AVDMGenericVideoStream *in,CONFcouple *couples)
-{
-
-        _in=in;         
-        memcpy(&_info,_in->getInfo(),sizeof(_info));    
-        _info.encoding=1;       
-        _parser=NULL;  
-        _resampled=NULL;
-        _chromaResampled=NULL;
-        _original=NULL;        
-        
-        _param=NEW(vobSubParam);
-        
-        if(couples)
-        {                 
-                GET(subname);
-                GET(index);                               
-                GET(subShift);  
-        }
-        else
-        {
-#ifdef KK_ADM_DEBUG
-                _param->subname=ADM_strdup(VOBSUB);
-#else                
-                _param->subname =NULL;
-#endif                
-                _param->index = 0;   
-                _param->subShift=0;             
-        }
-        
-        setup();
-}
-/*
-    Alternate constructor for use by OCR
-*/
-ADMVideoVobSub::ADMVideoVobSub(  char *fileidx,uint32_t idx)
-{
-
-        _in=NULL;         
-        memset(&_info,0,sizeof(_info));    
-        _info.encoding=1;       
-        _parser=NULL;  
-        _resampled=NULL;
-        _chromaResampled=NULL;
-        _original=NULL;        
-        
-        _param=NEW(vobSubParam);
-        
-        
-        _param->subname=ADM_strdup(fileidx);
-        _param->index = idx;   
-        _param->subShift=0;                    
-        
-        setup();
-}
-/*
-    Returns bitmap & info for the Nth subs
-*/
-
-vobSubBitmap *ADMVideoVobSub::getBitmap(uint32_t nb,uint32_t *start, uint32_t *end,uint32_t *first,uint32_t *last)
-{
-uint32_t top=0,bottom=0;
-    ADM_assert(_vobSubInfo);
-    ADM_assert(nb<_vobSubInfo->nbLines);
-    
-    // Seek & decode
-    //_parser->_asyncJump2(0,_vobSubInfo->lines[nb].fileOffset);
-    _parser->setPos(_vobSubInfo->lines[nb].fileOffset,0);
-    if(!handleSub(nb))
-        {
-                printf("Error reading getBimap\n");
-                *first=*last=0;
-                return _original; // might be null (?)
-        }
-    *first=*last=0;
-    if(_original)
-    {
-    uint32_t ox,oy;
-        _original->buildYUV(_YUVPalette);
-        ox=_original->_width;        
-        oy=_original->_height;
-        printf("Original :%lu x %lu (original  %d)\n",ox,oy,_vobSubInfo->height);
-        ADM_assert(oy<=_vobSubInfo->height);
-        
-        // Search the 1st/last non null line
-//#define DONTCLIP
-#ifdef DONTCLIP     
-         *first=0;
-         *last=oy-1;   
-#else
-        if(oy>_original->_height) oy=_original->_height-1;
-
-        while(top<oy && !_original->isDirty(top) ) top++;
-        
-        if(top==oy)
-        {
-                top=bottom=0;   // Empty bitmap ?
-                *first=top;
-                *last=bottom;
-                printf("Empry bitmap\n");
-                return NULL; 
-        }
-        bottom=oy-1;
-        while(bottom>top && !_original->isDirty(bottom)) bottom--;
-        
-        // If true it means we have 2 subs, one on top, one on bottom
-        //
-#if 0
-        if(bottom>(oy>>1) && top<(oy>>1) && (bottom-top>(oy>>1)))
-        {
-          // in that case, take only the lower one
-          top=oy>>1;
-          while(top<oy && !_original->isDirty(top)) top++;                    
-        }
-        printf("> clipped: %lu / %lu=%lu\n",top,bottom,bottom-top+1);
-#endif
-        *first=top;
-        *last=bottom;
-#endif
-    }
-    *start=_vobSubInfo->lines[nb].startTime;
-    *end=_vobSubInfo->lines[nb].stopTime;
-    return _original;
-}
-/*
-    Returns the nb of lines found in the sub
-*/
-uint32_t     ADMVideoVobSub::getNbImage( void)
-{
-    if(!_parser) return 0;
-    if(!_param) return 0;
-    if(!_vobSubInfo) return 0;
-    return _vobSubInfo->nbLines;
-
-}
-//************************************
-uint8_t ADMVideoVobSub::setup(void)
-{
-  char *dup;
-  int l;
-  
-   _vobSubInfo=NULL;
-   if(_param->subname && strlen(_param->subname)>5)
-        {
-                printf("Opening %s\n",_param->subname);
-                dup=ADM_strdup(_param->subname);
-                l=strlen(dup);
-                if(l>5)
-                  if(dup[l-4]=='.')
-                {
-                  dup[l-3]='s';
-                  dup[l-2]='u';
-                  dup[l-1]='b';
-                          
-                }
-                if(vobSubRead(_param->subname,_param->index,&_vobSubInfo))
-                {
-                        printf("Opening index \n");
-                       
-                        MPEG_TRACK track;
-                        memset(&track,0,sizeof(track));
-                        track.pes=_param->index+0x20;
-                        track.pid=0;
-                       // _parser=new ADM_mpegDemuxerProgramStream(_param->index+0x20,0xe0);
-                        _parser=new dmx_demuxerPS(1,&track,0);
-                        if(!_parser->open(dup))
-                        {
-                                printf("Mpeg Parser : opening %s failed\n",_param->subname);
-                                delete _parser;
-                                _parser=NULL;
-                
-                         }
-                         
-                }
-                ADM_dealloc(dup);
-        }
-        
-        
-        if(!_parser)
-        {
-                printf("opening of vobsub file failed\n");
-        }
-         else
-        {       // Recompute sub duration
-                uint32_t end;
-                vobSubLine *cur,*next;
-                // Assuming max displat time = MAX_DISPLAY_TIME
-                for(uint32_t i=0;i<_vobSubInfo->nbLines-1;i++)
-                {
-                        if(i && !_vobSubInfo->lines[i].startTime)
-                        {
-                                _vobSubInfo->lines[i].startTime=0xf0000000;
-                                _vobSubInfo->lines[i].stopTime=0xf0000001;
-                                
-                        }
-                        else
-                        {
-                                cur=&_vobSubInfo->lines[i];
-                                next=&_vobSubInfo->lines[i+1];
-                        
-                                end=cur->startTime+MAX_DISPLAY_TIME;
-                                if(end>=next->startTime) end=next->startTime-1;
-                                cur->stopTime=end;                                
-                        }
-                }
-                _vobSubInfo->lines[_vobSubInfo->nbLines-1].stopTime=
-                        MAX_DISPLAY_TIME+_vobSubInfo->lines[_vobSubInfo->nbLines-1].startTime;
-                // Convert all the palette from RGB to YUV
-                paletteYUV();
-        }
-      
-        _x1=_y1=_x2=_y2=0;
-        _data=new uint8_t [VS_MAXPACKET];
-        _subSize=0;
-        _subW=_subH=0;
-        
-        memset(&_original,0,sizeof(_original));
-        _currentSub=NOSUB;
-        _initialPts=0;
-                
-
-}
-//*************************************************************
-uint8_t ADMVideoVobSub::cleanup(void)
-{
-
-        if(_parser) delete _parser;
-        _parser=NULL;
-        
-        if(_original)
-          delete _original;
-        _original=NULL;        
-        
-        if(_resampled)
-          delete _resampled;
-        _resampled=NULL;
-        
-        if(_chromaResampled)
-          delete _chromaResampled;
-        _chromaResampled=NULL;
-        
-        
-        if(_data) delete [] _data;
-        _data=NULL;
-        
-        if(_vobSubInfo) destroySubInfo( _vobSubInfo);
-        _vobSubInfo=NULL;
-        
-
-}
-//*************************************************************
-ADMVideoVobSub::~ADMVideoVobSub()
-{
-        cleanup();
-         if(_param)
-        {
-                if(_param->subname)  ADM_dealloc(_param->subname);
-                DELETE(_param);
-        }
-        _param=NULL;
-}
-
-//*************************************************************
-uint8_t ADMVideoVobSub::getCoupledConf( CONFcouple **couples)
-{
-                        ADM_assert(_param);
-                        *couples=new CONFcouple(3);
-
-#define CSET(x)  (*couples)->setCouple((char *)#x,(_param->x))
-                        if(_param->subname)
-                                CSET(subname);
-                        else
-                          (*couples)->setCouple("subname","none") ;
-                        CSET(index);
-                        CSET(subShift);
-                        
-
-                        return 1;
-}
-//*************************************************************
-uint8_t ADMVideoVobSub::getFrameNumberNoAlloc(uint32_t frame,
-                                uint32_t *len,
-                                ADMImage *data,
-                                uint32_t *flags)
-{
-
-uint64_t time;
-uint32_t sub;
-
-        if(frame>= _info.nb_frames) return 0;
-        // read uncompressed frame
-        if(!_in->getFrameNumberNoAlloc(frame, len,data,flags)) return 0;
-
-        if(!_parser)        
-        {
-                //
-                printf("No valid vobsub to process\n");
-                
-                return 1;
-        
-        }
-        
-        time=(frame+_info.orgFrame);
-        time=(time*1000*1000)/_info.fps1000;
-        
-        sub=lookupSub(time);  
-        // Should we re-use the current one ? 
-        if(sub==NOSUB)
-        {
-                aprintf("No matching sub for time %llu frame%lu\n",time,frame);
-                return 1;
-        }
-        // If it is a new sub, decode it...
-        if(sub!=_currentSub )
-        {                
-                // _parser->_asyncJump2(0,_vobSubInfo->lines[sub].fileOffset);
-                _parser->setPos(_vobSubInfo->lines[sub].fileOffset,0);
-                 //_initialPts=_parser->getPTS();
-                 handleSub(sub);
-                _currentSub=sub;
-                Palettte2Display(); // Create the bitmap
-                // Time to resize the bitmap
-                // First try : Do it bluntly
-                
-        }                
-        
-        // and if there is something to display, display it
-        //
-        vobSubBitmap *src;
-        //src=_original;
-        src=_resampled;
-        
-        if(src)          
-        {
-               
-          aprintf("We have %lu %lu to merge\n",src->_width,src->_height);
-                // Merge
-                
-                uint32_t stridein,strideout,len;
-                uint8_t *in,*out,*mask,*in2;
-                uint16_t old,nw,alp;
-                uint32_t xx,yy;
-                
-                stridein=src->_width;
-                strideout=_info.width;
-                
-                if(strideout>stridein)
-                {
-                        len=stridein;
-                        xx=src->_width;
-                }
-                else
-                {
-                        xx=_info.width;
-                        len=strideout;
-                }
-                if(src->_height>_info.height) yy=_info.height;
-                        else                 yy=src->_height;           
-                in=src->_bitmap;
-                mask=src->_alphaMask;
-               
-                out=data->data+_info.width*src->placeTop;
-                // auto center
-                uint32_t center=_info.width-src->_width;
-                out+=(center>>2)*2;
-                
-                for(uint32_t y=0;y<yy;y++)
-                {
-                  for(uint32_t x=0;x<xx;x++)
-                        {
-                               old=out[x];
-                               nw=in[x];
-                               alp=mask[x];
-
-                                if(alp) 
-                                {
-                                  if(alp>7)  nw=old*(16-alp-1)+(alp+1)*nw;
-                                        else nw=old*(16-alp)+(alp)*nw;
-                                  out[x]=nw>>4;                                         
-                                }
-
-                               //out[x]=nw;
-                        }
-                        //memcpy(out,in,len);
-                        out+=strideout;
-                        in+=stridein;
-                        mask+=stridein;
-                }
-                
-                // Now do chroma u & chroma V
-#define DOCHROMA                
-#if defined(DOCHROMA)                
-                uint32_t crosspage=(_info.width*_info.height)>>2;
-                
-                strideout=_info.width>>1;
-                stridein=_chromaResampled->_width;
-                
-                out=data->data+_info.width*_info.height;
-                out+=(src->placeTop>>1)*(_info.width>>1);
-                mask=_chromaResampled->_alphaMask;
-                // Center
-                out+=(center>>2)*1;
-                if(strideout>stridein) xx=stridein;
-                else            xx=strideout;
-                
-                int16_t left=(_info.height>>1)-(_chromaResampled->_height+(_original->placeTop>>1));
-                
-                if(left<_chromaResampled->_height) yy=left;
-                else yy=_chromaResampled->_height;
-                
-                for(uint32_t y=0;y<yy;y++)
-                {
-                   for(uint32_t x=0;x<xx;x++)
-                   {
-                        if(mask[x]>10)         
-                        {
-                          int16_t val;
-                          val=out[x];
-                          val-=128;
-                         
-                          
-                          
-                          nw=val*(16-alp);
-                          
-                          val/=4;
-                          val=val+128;
-                                
-                          out[x]=val; 
-                          out[crosspage+x]=val;
-                        }                                                 
-                   }
-                   out+=strideout;
-                   mask+=stridein;
-                }
-#endif                
-        }
-        return 1;
-}
-//*************************************************************************
-//
-//      Convert the original bitmap to a rescaled & repositionned one
-//      that will be blended into the current picutr
-//
-//*************************************************************************
-uint8_t ADMVideoVobSub::Palettte2Display( void )
-{
-        ADM_assert(_parser);
-        ADM_assert(_vobSubInfo);
-     
-        // Then Process the RLE Datas
-        // To get the _bitmap yuv data
-        ADM_assert(_original);
-        
-        // Set correct color
-        _original->buildYUV(_YUVPalette);
-        
-        // rebuild the scaled one
-        // Compute the target size
-        uint32_t fx,fy;
-        uint32_t ox,oy;
-        uint32_t sx,sy;
-        /*
-                Fx, fy : Final size of the image (i.e size of the current picture)
-                ox,oy  : Original size of the image where the sub is coming from
-                sx,sy  : Size of the  sub
-        
-                And we want the final size of the sub
-                        + coordinates but that we will do later
-        
-        */
-        
-        fx=_info.width;
-        fy=_info.height;
-        
-        ox=_vobSubInfo->width;
-        oy=_vobSubInfo->height;
-        
-        sx=_subW;
-        sy=_subH;
-        
-        // Search the 1st/last non null line
-        uint32_t top=0,bottom=0;
-
-        if(oy>_original->_height) oy=_original->_height-1;
-
-        while(top<oy && !_original->isDirty(top)) top++;
-        
-        bottom=_original->_height-1;
-        if(top==bottom)
-        {
-                printf("Empty sub ?");
-                return 0;
-        }
-        
-        while(bottom && !_original->isDirty(bottom)) bottom--;
-        
-        // If true it means we have 2 subs, one on top, one on bottom
-        //
-        if(bottom>(oy>>1) && top<(oy>>1) && (bottom-top>(oy>>1)))
-        {
-          // in that case, take only the lower one
-          top=oy>>1;
-          while(top<oy && !_original->isDirty(top)) top++;                    
-        }
-        //
-        //  The useful part is between top & bottom lines
-        //
-        
-        // Shrink factor
-        // The shrink factor is the one used to shrink from the original video
-        // to the resize video
-        
-        double scale,l;
-        scale=fx;
-        scale/=ox;
-        printf("top %lu : bottom :%lu Scale :%f ox:%lu oy:%lu fx:%lu \n",top,bottom,scale,ox,oy,fx);
-        
-        // We rescale the sub by the same factor
-        // Only the visible / useful part
-        l=scale;
-        l=l*sx;
-        sx=(uint32_t )floor(l);
-        
-       
-        l=scale;
-        l=l*(bottom-top);
-        sy=(uint32_t )floor(l);
-        
-
-        // And we resize that useful part of sub
-        // to our final bitmap (resampled)
-                
-        _original->subResize(&_resampled,sx,sy,top, bottom-top);
-                
-        uint32_t tail;
-        
-        // Set the position of the sub so that it is ok
-        
-        tail=16+sy;
-        
-        if(tail>fy) tail=0;
-        else
-        {
-            tail=fy-tail;           
-        }
-        
-        _resampled->placeTop=tail;
-        
-        _resampled->subResize(&_chromaResampled,sx>>1,sy>>1,0,sy);
-        return 1;
-}
-
-//
-//      Return the index in the sub table of the sub matching the time
-//
-uint32_t ADMVideoVobSub::lookupSub(uint64_t time)
-{
-int64_t head,tail, cur;
-int32_t i;
-        cur=(int64_t)time;
-        i=0;
-        while(i<_vobSubInfo->nbLines-1)
-        {
-                head=(int64_t)_vobSubInfo->lines[i].startTime;
-                tail=(int64_t) _vobSubInfo->lines[i].stopTime;
-                head+=_param->subShift;
-                tail+=_param->subShift;
-                if(head<=cur &&tail>cur)
-                {
-                  aprintf("Matching for time %llu : sub %lu starting at :%lu (shift %lu)\n",
-                                        time,i,_vobSubInfo->lines[i].startTime,_param->subShift);
-                        return i; 
-                }   
-                if(head>cur) return NOSUB;                   
-                i++;       
-        }
-        return NOSUB;
-
-
-}
-//EOF
-

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vobsubinfo.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vobsubinfo.cpp	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vobsubinfo.cpp	2009-10-02 05:22:11 UTC (rev 5365)
@@ -1,263 +0,0 @@
-//
-// C++ Implementation: vobsub parser
-//
-// Description:
-//
-//
-// Author: Mean, 2005 GPL
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include "config.h"
-
-#include "ADM_default.h"
-#include "ADM_vobsubinfo.h"
-
-static uint8_t fillLine(char *str,VobSubInfo *sub,uint32_t line);
-static uint32_t countLine(FILE *f,int index);
-uint8_t fillPalette(char *str,VobSubInfo *sub);
-
-uint8_t destroySubInfo(VobSubInfo *sub)
-{
-        if(!sub) return 1;      // ?
-        if(sub->lines) delete [] sub->lines;
-        delete sub;
-        return 1;
-
-
-}
-//****************** 
-// Extract Line info
-//******************
-uint8_t fillLine(char *str,VobSubInfo *sub,uint32_t line)
-{
-int hh,mm,ss,ms,o;
-uint64_t ti;
-uint32_t pos;
-
-        ADM_assert(line<sub->nbLines);
-
-        o=sscanf(str,"timestamp: %d:%d:%d:%d, filepos: %x\n",&hh,&mm,&ss,&ms,&pos);
-        ADM_assert(o==5);
-        
-        ti=hh*3600+mm*60+ss;
-        ti=ti*1000+ms;
-        
-        sub->lines[line].startTime      =ti;
-        sub->lines[line].stopTime       =ti+1000;
-        sub->lines[line].fileOffset     =pos;
-        
-        return 1;
-}
-//******************
-// Extract palette
-//******************
-uint8_t fillPalette(char *str,VobSubInfo *sub)
-{
-int p[16],o;
-
-        o=sscanf(str,"palette: %x, %x, %x, %x, %x, %x, %x, %x,"
-                                " %x, %x, %x, %x, %x, %x, %x, %x",
-                                &p[0],&p[1],&p[2],&p[3],&p[4],&p[5],&p[6],&p[7],
-                                &p[8],&p[9],&p[10],&p[11],&p[12],&p[13],&p[14],&p[15]);
-        ADM_assert(o==16);
-        for(int i=0;i<16;i++)
-                sub->Palette[i]=p[i];
-                                       
-        return 1;
-}
-//******************
-//******************
-uint8_t vobSubRead(char *filename,int index,VobSubInfo **info)
-{
-FILE            *file=NULL;
-uint32_t        nb_lines;
-VobSubInfo      *sub=NULL;
-uint8_t         success=0;
-uint32_t        line=0,l;
-char            str[1024];
-char            *dup;
-int             language=0;
-
-        if(!filename)
-        {
-                printf("Null file ?\n");
-                return 0;
-        }
-        *info=NULL;
-        file=fopen(filename,"rt");
-        if(!file) 
-        {
-                printf("Could not open %s file\n",filename);
-                return 0;
-        }
-        nb_lines=countLine(file,index);
-        if(!nb_lines)
-        {
-                printf("Empty file\n");
-                 goto subAbort;
-        }
-        // Try to read the file
-        sub=new VobSubInfo;
-        memset(sub,0,sizeof(VobSubInfo));
-        //
-        sub->nbLines=nb_lines;
-        sub->lines=new vobSubLine[nb_lines];
-        memset(sub->lines,0,sizeof(vobSubLine)*nb_lines);
-        printf("Rebuilding %d lines of subs\n",nb_lines);
-        
-        while(line<nb_lines && !feof(file))
-        {
-                fgets(str,1023,file); 
-                if(!strncmp(str,"palette:",7))
-                {
-                                 fillPalette(str,sub);
-                                 sub->hasPalette=1;
-                }
-                else 
-                {
-                        if(!strncmp(str,"timestamp: ",10) && language)        
-                        {
-                                fillLine(str,sub,line);
-                                line++;
-                        }
-                        else
-                        {
-                                if(!strncmp(str,"id:",3))       // Catch language/index
-                                {
-                                  int  l;
-                                  char s[50];
-                                  s[0]=0;
-                                  l=999;
-                                  sscanf(str,"id: %s index: %d",s,&l);
-                                  printf("Found lang : %s index %d while searching %d\n",s,l,index);
-                                  if(l==index)
-                                  {
-                                	  language=1;
-                                	  printf("Match\n");
-                                  }
-                                  else language=0;                                                                              
-                                
-                                }
-                                else
-                                {
-                                        if(!strncmp(str,"size:",5))       // Catch original screen dimension
-                                        {
-                                            sscanf(str,"size:%"SCNu32"x%"SCNu32"",&(sub->width),&(sub->height));
-                                        }
-                                
-                                }
-                                
-                        }
-                }
-        }
-subSuccess:        
-        success=1;
-        if(!sub->hasPalette)
-        {
-            for(int j=0;j<16;j++)
-                sub->Palette[j]=j;   
-        }
-subAbort:        
-        if(success)
-        {
-                *info=sub;
-        }
-        else
-        {
-                destroySubInfo( sub);        
-        }
-        fclose(file);
-        return success;
-
-}
-//******************
-// count #nb beginning by timestamp in file
-//******************
-uint32_t countLine(FILE *f,int index)
-{
-char str[1024],s[1024];
-uint32_t nb=0;
-uint32_t match=0;
-int lang;
-
-        fseek(f,0,SEEK_SET);
-        while(!feof(f))
-        {
-                fgets(str,1023,f);
-                if(!strncmp(str,"id:",3))
-                {
-                  s[0]=0;
-                  lang=9999;
-                  sscanf(str,"id: %s index: %d",s,&lang);
-                  if(lang==index) match=1;
-                  else match=0;
-                }
-                else
-                  if(match)
-                        if(!strncmp(str,"timestamp: ",10)) nb++;
-        
-        }
-        fseek(f,0,SEEK_SET);
-        return nb;
-}
-//*****************************************
-vobSubLanguage *vobSubAllocateLanguage(void)
-{
-  vobSubLanguage *l;
-  l=new vobSubLanguage;
-  memset(l,0,sizeof(vobSubLanguage));
-  return l;  
-}
-//*****************************************
-uint8_t vobSubDestroyLanguage(vobSubLanguage *lingua)
-{
-  for(uint32_t i=0;i<lingua->nbLanguage;i++)  
-    delete [] lingua->language[i].name;
-  delete lingua; 
-  return 1;
-}
-//*****************************************
-uint8_t vobSubGetLanguage(const char *filename,vobSubLanguage *lingua)
-{
-  char str[1024];
-  char s[16];
-  uint32_t nb=0,index;
-  FILE *fd=NULL;
-  
-  fd=fopen(filename,"rb");
-  if(!fd) return 0;
-  
-  
-
-  
-  while(!feof(fd))
-  {
-    fgets(str,1023,fd);
-    if(!strncmp(str,"id: ",3))
-    {
-      sscanf(str,"id: %s index: %d",s,&index);
-      lingua->language[nb].name=new char[3];
-      lingua->language[nb].name[0]=str[4];
-      lingua->language[nb].name[1]=str[5];
-      lingua->language[nb].name[2]=0;
-      //
-      lingua->language[nb].index=index;
-      nb++;
-    }        
-  }
-  lingua->nbLanguage=nb;
-  return 1;
-}
-
-//EOF

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vobsubinfo.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vobsubinfo.h	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADM_vobsubinfo.h	2009-10-02 05:22:11 UTC (rev 5365)
@@ -1,60 +0,0 @@
-//
-// C++ Interface: Vobsubinfo struct & prototyping
-//
-// Description: Read the idx part of an index file
-//
-//
-// Author: mean , fixounet at free.fr, GPL (C) 2005
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifndef _VOBSUB_INFO_
-#define _VOBSUB_INFO_
-#define ADM_MAX_LANGUAGE 33
-typedef struct vobSubLine
-{
-        uint32_t        startTime;      /// Starting time in ms
-        uint32_t        stopTime;       /// Stop time
-        uint64_t        fileOffset;     /// Offset in the file where this sub starts
-
-}vobSubLine;
-typedef struct vobSubOneLang
-{
-        char     *name;
-        uint32_t index;
-}vobSubOneLang;
-typedef struct vobSubLanguage
-{
-        uint32_t        nbLanguage; 
-        vobSubOneLang   language[ADM_MAX_LANGUAGE];  
-}vobSubLanguage;
-
-typedef struct VobSubInfo
-{
-        uint32_t        hasPalette;
-        uint32_t        Palette[16];
-        uint32_t        nbLines;
-        uint32_t        width;
-        uint32_t        height;
-        vobSubLine      *lines;
-}VobSubInfo;
-
-/// Read the sub and return a new filled out vobsub info struct
-uint8_t vobSubRead(char *filename,int index,VobSubInfo **info);
-uint8_t destroySubInfo(VobSubInfo *sub);
-
-uint8_t         vobSubGetLanguage(const char *filename,vobSubLanguage *lingua);
-vobSubLanguage  *vobSubAllocateLanguage(void);
-uint8_t         vobSubDestroyLanguage(vobSubLanguage *lingua);
-
-#endif
-// EOF

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADMmpdetc.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADMmpdetc.cpp	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/ADMmpdetc.cpp	2009-10-02 05:22:11 UTC (rev 5365)
@@ -1,741 +0,0 @@
-//
-//
-// C++ Implementation: ADM_mpdetc
-//
-// Description: 
-//
-//	This is a port of mplayer ivtc filter by Richard 
-//	Copyright Richard Felker
-//
-// Author:Richard Felker, port to avidemux2 by  mean <fixounet at free.fr>, (C) 2003
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-//
-#define HAVE_DETC
-#ifdef HAVE_DETC
-
-#include "config.h"
-#include "ADM_lavcodec.h"
-#include "fourcc.h"
-
-#include "ADM_toolkit/toolkit.hxx"
-#include "ADM_videoFilter.h"
-#include "ADM_video/ADM_mpdetc.h"
-
-#include "ADM_osSupport/ADM_debugID.h"
-#define MODULE_NAME MODULE_FILTER
-#include "ADM_osSupport/ADM_debug.h"
-
-//static void decimate(uint8_t *src,uint8_t *target, uint32_t linessrc, uint32_t width);
-#include "ADM_filter/video_filters.h"
-
-
-static FILTER_PARAM flipParam={0,{""}};
-
-
-SCRIPT_CREATE(mpdetc_script,AVDMVideoMPDetc,flipParam);
-BUILD_CREATE(mpdetc_create,AVDMVideoMPDetc);
-
-
-void 		*my_memcpy_pic(uint8_t * dst, uint8_t * src, int bytesPerLine, int height, 
-						int dstStride, int srcStride);
-unsigned int 	hash_pic(unsigned char *img, int w, int h, int stride);
-static void 	block_diffs_C(struct metrics *m, unsigned char *old, unsigned char *nw, int os, int ns);
-#ifdef ADM_CPU_X86
-void block_diffs_MMX(struct metrics *m, unsigned char *old, unsigned char *ew, int os, int ns);
-#endif
-static void 	diff_planes(struct metrics *m, unsigned char *old, unsigned char *nw, int w, int h, int os, int ns);
-static void 	diff_fields(struct frameinfo *fi, uint8_t  *old, uint8_t  *nw);
-static void 	status(struct frameinfo *f);
-static void 	copy_image(ADMImage  *sdest, ADMImage  *ssrc, int field);
-
-static uint32_t 	myw,myh;
-static struct vf_priv_s *myparam; // UGLY FIXME BURK
-
-
-
-
-char *AVDMVideoMPDetc::printConf( void )
-{
- 	static char buf[50];
-
- 	sprintf((char *)buf," Mplayer ivtc");
-        return buf;
-}
-
-//_______________________________________________________________
-AVDMVideoMPDetc::AVDMVideoMPDetc(
-				AVDMGenericVideoStream *in,CONFcouple *setup)
-{
-UNUSED_ARG(setup);
-  	_in=in;
-   	memcpy(&_info,_in->getInfo(),sizeof(_info));
-	
-	// We alter frame rate here and # of frames
-	aprintf("Frame in : %lu fpsin: %lu\n",_info.nb_frames,_info.fps1000);
-	_info.fps1000=(_info.fps1000*4)/5;	
-	_info.nb_frames=_info.nb_frames/5;
-	_info.nb_frames=_info.nb_frames*4;
-	aprintf("Frame out : %lu fpout: %lu\n",_info.nb_frames,_info.fps1000);
-//	_uncompressed=new uint8_t[(3*_info.width*_info.height)>>1];
-//	_lastFrame=new uint8_t[(3*_info.width*_info.height)>>1];
-	_uncompressed=new ADMImage(_info.width,_info.height);
-	_lastFrame=new ADMImage(_info.width,_info.height);
-	
-	_param=new vf_priv_s;
-	_param->drop = 0;
-	_param->first = 1;
-	_inFrame=0;
-	_lastAsked=0xffffff0;
-		
-}
-
-// ___ destructor_____________
-AVDMVideoMPDetc::~AVDMVideoMPDetc()
-{
- 	delete  _uncompressed;
-	delete  _lastFrame;
-	if(myparam)
-	{
-		delete _param;
-		_param=NULL;
-	}
-	
-
-}
-
-int foo(struct vf_priv_s *p, uint8_t  *nw, uint8_t *cur)
-{
-	struct frameinfo *f = p->fi;
-
-	f[0] = f[1];
-	diff_fields(&(f[1]), cur, nw);
-	status(&(f[1]));
-
-	// Immediately drop this frame if it's already been used.
-	if (p->dropnext) {
-		p->dropnext = 0;
-		return F_DROP;
-	}
-	
-	// Sometimes a pulldown frame comes all by itself, so both
-	// its top and bottom field are duplicates from the adjacent
-	// two frames. We can just drop such a frame, but we
-	// immediately show the next frame instead to keep the frame
-	// drops evenly spaced during normal 3:2 pulldown sequences.
-	if ((3*f[1].r.o < f[1].r.e) && (f[1].r.s < f[1].r.d)) {
-		p->dropnext = 1;
-		return F_NEXT;
-	}
-	
-	// If none of these conditions hold, we will consider the frame
-	// progressive and just show it as-is.
-	if (!(  (3*f[0].r.e < f[0].r.o) ||
-		((2*f[0].r.d < f[0].r.s) && (f[0].r.s > 1200)) ||
-		((2*f[1].r.t < f[1].r.p) && (f[1].r.p > 1200))  ))
-		return F_SHOW;
-
-	// Otherwise, we have to decide whether to merge or drop.
-	// If the noise metric only increases minimally, we're off
-	// to a good start...
-	if (((2*f[1].r.t < 3*f[1].r.p) && (f[1].r.t < 3600)) ||
-		(f[1].r.t < 900) || (f[1].r.d < 900)) {
-		// ...and if noise decreases or the duplicate even field
-		// is detected, we go ahead with the merge.
-		if ((3*f[0].r.e < f[0].r.o) || (2*f[1].r.t < f[1].r.p)) {
-			p->dropnext = 1;
-			return F_MERGE;
-		}
-	}
-	return F_DROP;
-}
-
-//
-//	Basically ask a uncompressed frame from editor and ask
-//		GUI to decompress it .
-//
-
-#define clear(x) {memset(x,0,page);memset(x+page,128,page>>1);}
-
-uint8_t AVDMVideoMPDetc::getFrameNumberNoAlloc(uint32_t frame,
-				uint32_t *len,
-   				ADMImage *data,
-				uint32_t *flags)
-{
-uint32_t page=_info.width*_info.height;
-
-		if(frame>=_info.nb_frames) return 0;
-		
-       				
-		myw=_info.width;
-		myh=_info.height; // UGLY!!!
-		myparam=_param;
-		aprintf("Request for %lu frames (last %lu)\n",frame,_lastAsked);
-		// First frame or out of order, we copy it to prefill buffer
-		if(_lastAsked+1!=frame) 
-		{
-			// Convert to source filter frame no
-		  uint32_t off;			
-			aprintf("--Out of order access\n");
-			off=frame%4;	
-			frame=frame-off;		
-			_inFrame=(frame*5)>>2;
-			// 4 frame -> 5 frame
-			_inFrame+=off;
-			// Init buffer
-			// Clear refimage
-			clear(_lastFrame);	
-			_param->lastdrop=0;
-			_param->inframes = 1;
-			_param->outframes=1;					
-			_param->first=0;
-			_copy=0;
-			_lastAsked=frame;
-			if(!_in->getFrameNumberNoAlloc(_inFrame, len,data,flags)) return 0;	
-			return 1;
-		}
-		// Sequential access, we have the previous frame pre-filled		
-		uint8_t frame_ready=0;
-		int off;
-		
-		_lastAsked=frame;
-		while(!frame_ready )
-		{
-			
-			
-			if(!_in->getFrameNumberNoAlloc(_inFrame, len,_uncompressed,flags))
-			{
-				// be nice and return 1 if it does not seem to stupid
-				if(_param->inframes*4-_param->outframes*5 < 30)
-				{
-					_param->outframes++;
-					printf("Skew ignored\n");
-					return 1;
-				}
-				 return 0;
-			}
-		
-			_inFrame++;
-			myparam->inframes++;
-			off=4*_param->inframes - 5*(_param->outframes+1);
-			aprintf("**** Inframe : %lu / outframe : %lu / Off: %d (in: %lu)\n",
-				 _param->inframes,_param->outframes,off,_inFrame);
-/*				 
-			if(off>11)
-			{
-				_copy=9;
-			}
-			if(_copy)
-			{
-				_copy--;
-				aprintf("Too much drops!\n");
-				_param->outframes++;
-				_param->lastdrop=0;
-				if(!_copy)
-					copy_image(_lastFrame, _uncompressed, 2);
-				copy_image(data, _uncompressed, 2);
-				
-				return 1;				
-			}				 
-			
-*/			
-			
-			switch (foo(_param, _uncompressed->data, _lastFrame->data)) 
-			{
-			case F_DROP:
-				copy_image(_lastFrame, _uncompressed, 2);
-				frame_ready = 0;
-				_param->lastdrop = 0;
-				aprintf("MPivtc DROP\n");				
-				// we are dropping too much frames!
-				if(off>6)
-				{
-					aprintf("Cancelled dropout!, deinterlacing in place----------\n");
-					memcpy(data->data,_lastFrame,(page*3)>>1);
-					frame_ready=1;
-					_param->outframes++;
-					_param->dropnext=0;
-					// we deinterlace it in place
-					AVPicture src;
-					uint32_t page=_info.width*_info.height;
-		
-					src.data[0]=data->data;
-					src.data[1]=data->data+page;
-					src.data[2]=data->data+((page*5)>>2);
-  					
-		
-					src.linesize[0]=_info.width;
-					src.linesize[1]=_info.width>>1;
-					src.linesize[2]=_info.width>>1;
-  
-					if (avpicture_deinterlace(&src,&src,
-						PIX_FMT_YUV420P,_info.width,_info.height)<0)
-					{
-						printf("Error in avpicture deinterlace!\n");
-						return 0;
-					} 		
-				}
-				
-				break;
-			case F_MERGE:
-				copy_image(_lastFrame, _uncompressed, 0);
-				frame_ready = do_put_image(_lastFrame);
-				if(frame_ready) memcpy(data->data,_lastFrame->data,(page*3)>>1);
-				copy_image(_lastFrame, _uncompressed, 1);
-				aprintf("MPivtc MERGE\n");
-				//clear(_lastFrame);
-				break;
-			case F_NEXT:
-				copy_image(_lastFrame, _uncompressed, 2);
-				frame_ready = do_put_image(_lastFrame);
-				if(frame_ready) memcpy(data->data,_lastFrame->data,(page*3)>>1);
-				aprintf("MPivtc NEXT\n");
-				//clear(_lastFrame);
-				break;
-			case F_SHOW:
-				frame_ready = do_put_image(_lastFrame);
-				if(frame_ready) memcpy(data->data,_lastFrame->data,(page*3)>>1);
-				copy_image(_lastFrame, _uncompressed, 2);
-				aprintf("MPivtc OK\n");
-				//clear(_lastFrame);
-				break;
-			}
-		}
-	if(!frame_ready) return 0;	
-	return 1;
-}
-		
-
-/*
-	Return 1 if ok, 0 if dropped
-*/
-uint8_t AVDMVideoMPDetc::do_put_image(ADMImage *data)
-{
-	int dropflag;
-	int off=0;
-/*
-	switch (_param->drop && !_param->dropnext) 
-	{
-	case 0:
-		dropflag = 0;
-		break;
-	case 1:
-		dropflag = (++_param->lastdrop >= 5);
-		break;
-	case 2:
-		dropflag = (++_param->lastdrop >= 5) && (4*_param->inframes <= 5*_param->outframes);
-		break;
-	}
-*/
-	off=4*_param->inframes - 5*(_param->outframes+1);
-	aprintf("Dropnext : %d lastdrop  : %d off : %d \n",_param->dropnext,_param->lastdrop,off);
-		
-	dropflag = ((_param->dropnext)||(++_param->lastdrop >= 5)) && off< 0;
-	
-	if (dropflag) {
-		aprintf("-->drop! [%d/%d=%g]\n",
-			_param->outframes, _param->inframes, (float)_param->outframes/_param->inframes);
-		_param->lastdrop = 0;
-		return 0;
-	}
-
-	_param->outframes++;
-	return 1;
-
-
-}
-
-
-
-
-
-
-void *my_memcpy_pic(uint8_t  * dst, uint8_t * src, int bytesPerLine, int height, int dstStride, int srcStride)
-{
-	int i;
-	void *retval=dst;
-
-	for(i=0; i<height; i++)
-	{
-		memcpy(dst, src, bytesPerLine);
-		src+= srcStride;
-		dst+= dstStride;
-	}
-
-	return retval;
-}
-
-unsigned int hash_pic(unsigned char *img, int w, int h, int stride)
-{
-	int step = w*h/1024;
-	unsigned int hash=0;
-	int x=0, y;
-
-	step -= step % 3;
-
-	for (y=0; y<h; y++) {
-		for (; x<w; x+=step) {
-			hash = hash ^ (hash<<4) ^ img[x];
-		}
-		x -= w;
-		img += stride;
-	}
-	
-	return hash;
-}
-#define MAG(a) (((a)^((a)>>31))-((a)>>31))
-#define LOWPASS(s) ((s)[0])
-
-
- void block_diffs_C(struct metrics *m, unsigned char *old, unsigned char *nw, int os, int ns)
-{
-	int x, y, e=0, o=0, s=0, p=0, t=0;
-	unsigned char *oldp, *newp;
-	m->s = m->p = m->t = 0;
-	for (x = 8; x; x--) {
-		oldp = old++;
-		newp = nw++;
-		s = p = t = 0;
-		for (y = 4; y; y--) {
-			e += MAG(newp[0]-oldp[0]);
-			o += MAG(newp[ns]-oldp[os]);
-			s += newp[ns]-newp[0];
-			p += oldp[os]-oldp[0];
-			t += oldp[os]-newp[0];
-			oldp += os<<1;
-			newp += ns<<1;
-		}
-		m->s += MAG(s);
-		m->p += MAG(p);
-		m->t += MAG(t);
-	}
-	m->e = e;
-	m->o = o;
-	m->d = e+o;
-}
-#define MAXUP(a,b) ((a) = ((a)>(b)) ? (a) : (b))
-
-static void diff_planes(struct frameinfo *fi,
-	unsigned char *old, unsigned char *nw, int w, int h, int os, int ns)
-{
-	int x, y;
-	struct metrics l;
-	struct metrics *peak=&fi->p, *rel=&fi->r, *mean=&fi->m;
-	memset(peak, 0, sizeof(struct metrics));
-	memset(rel, 0, sizeof(struct metrics));
-	memset(mean, 0, sizeof(struct metrics));
-	for (y = 0; y < h-7; y += 8) {
-		for (x = 8; x < w-8-7; x += 8) {
-#if 00 //FIXME def USE_MMX	
-	#define block_diffs block_diffs_MMX
-#else
-	#define block_diffs block_diffs_C
-#endif	
-			block_diffs(&l, old+x+y*os, nw+x+y*ns, os, ns);
-			mean->d += l.d;
-			mean->e += l.e;
-			mean->o += l.o;
-			mean->s += l.s;
-			mean->p += l.p;
-			mean->t += l.t;
-			MAXUP(peak->d, l.d);
-			MAXUP(peak->e, l.e);
-			MAXUP(peak->o, l.o);
-			MAXUP(peak->s, l.s);
-			MAXUP(peak->p, l.p);
-			MAXUP(peak->t, l.t);
-			MAXUP(rel->e, l.e-l.o);
-			MAXUP(rel->o, l.o-l.e);
-			MAXUP(rel->s, l.s-l.t);
-			MAXUP(rel->p, l.p-l.t);
-			MAXUP(rel->t, l.t-l.p);
-			MAXUP(rel->d, l.t-l.s); /* hack */
-	
-		}
-	}
-	x = (w/8-2)*(h/8);
-	mean->d /= x;
-	mean->e /= x;
-	mean->o /= x;
-	mean->s /= x;
-	mean->p /= x;
-	mean->t /= x;
-}
-void diff_fields(struct frameinfo *fi, uint8_t  *old, uint8_t  *nw)
-{
-	diff_planes(fi, old, nw,
-		myw, myh, myw, myw);
-}
-
-
-
- void status(struct frameinfo *f)
-{
-	aprintf("       pd=%d re=%d ro=%d rp=%d rt=%d rs=%d rd=%d pp=%d pt=%d ps=%d\n",
-		f->p.d, f->r.e, f->r.o, f->r.p, f->r.t, f->r.s, f->r.d, f->p.p, f->p.t, f->p.s);
-}
-
-
-
-//void copy_image(mp_image_t *dmpi, mp_image_t *mpi, int field)
-void copy_image(ADMImage  *sdest, ADMImage  *ssrc, int field)
-{
-	uint32_t page;
-	page=myw*myh;
-	uint8_t *src,*dest;
-	src=ssrc->data;
-	dest=sdest->data;
-	switch (field) {
-	case 0:
-		my_memcpy_pic(dest, src, myw, myh>>1,
-			myw*2, myw*2);
-		//if (mpi->flags & MP_IMGFLAG_PLANAR) {
-		if(1){
-			src+=page;
-			dest+=page;
-			/*my_memcpy_pic(dmpi->planes[1], mpi->planes[1],
-				mpi->chroma_width, mpi->chroma_height/2,
-				dmpi->stride[1]*2, mpi->stride[1]*2);
-			my_memcpy_pic(dmpi->planes[2], mpi->planes[2],
-				mpi->chroma_width, mpi->chroma_height/2,
-				dmpi->stride[2]*2, mpi->stride[2]*2);*/
-			my_memcpy_pic(dest, src, myw>>1, myh>>2,
-						myw, myw);
-			src+=page>>2;
-			dest+=page>>2;
-			my_memcpy_pic(dest, src, myw>>1, myh>>2,
-					myw, myw);
-		}
-		break;
-	case 1:
-		/*my_memcpy_pic(dmpi->planes[0]+dmpi->stride[0],
-			mpi->planes[0]+mpi->stride[0], mpi->w, mpi->h/2,
-			dmpi->stride[0]*2, mpi->stride[0]*2);*/
-		my_memcpy_pic(dest+myw, src+myw, myw, myh>>1,
-			myw*2, myw*2);	
-		//if (mpi->flags & MP_IMGFLAG_PLANAR) {
-		if(1){/*
-			my_memcpy_pic(dmpi->planes[1]+dmpi->stride[1],
-				mpi->planes[1]+mpi->stride[1],
-				mpi->chroma_width, mpi->chroma_height/2,
-				dmpi->stride[1]*2, mpi->stride[1]*2);
-			my_memcpy_pic(dmpi->planes[2]+dmpi->stride[2],
-				mpi->planes[2]+mpi->stride[2],
-				mpi->chroma_width, mpi->chroma_height/2,
-				dmpi->stride[2]*2, mpi->stride[2]*2);*/
-			src+=page;
-			dest+=page;
-			/*my_memcpy_pic(dmpi->planes[1], mpi->planes[1],
-				mpi->chroma_width, mpi->chroma_height/2,
-				dmpi->stride[1]*2, mpi->stride[1]*2);
-			my_memcpy_pic(dmpi->planes[2], mpi->planes[2],
-				mpi->chroma_width, mpi->chroma_height/2,
-				dmpi->stride[2]*2, mpi->stride[2]*2);*/
-			my_memcpy_pic(dest+myw/2, src+myw/2, myw>>1, myh>>2,
-					myw, myw);
-			src+=page>>2;
-			dest+=page>>2;
-			my_memcpy_pic(dest+myw/2, src+myw/2, myw>>1, myh>>2,
-					myw, myw);				
-		}
-		break;
-	case 2:
-		/*
-		memcpy_pic(dmpi->planes[0], mpi->planes[0], mpi->w, mpi->h,
-			dmpi->stride[0], mpi->stride[0]);
-		if (mpi->flags & MP_IMGFLAG_PLANAR) {
-			memcpy_pic(dmpi->planes[1], mpi->planes[1],
-				mpi->chroma_width, mpi->chroma_height,
-				dmpi->stride[1], mpi->stride[1]);
-			memcpy_pic(dmpi->planes[2], mpi->planes[2],
-				mpi->chroma_width, mpi->chroma_height,
-				dmpi->stride[2], mpi->stride[2]);
-		}*/
-		memcpy(dest,src,(page*3)>>1);
-		break;
-	}
-}
-#if 0 // FIXME USE_MMX
- void block_diffs_MMX(struct metrics *m, unsigned char *old, unsigned char *nw, int os, int ns)
-{
-	int i;
-	short out[24]; // output buffer for the partial metrics from the mmx code
-	
-	__asm__ (
-		"movl $4, %%ecx \n\t"
-		"pxor %%mm4, %%mm4 \n\t" // 4 even difference sums
-		"pxor %%mm5, %%mm5 \n\t" // 4 odd difference sums
-		"pxor %%mm7, %%mm7 \n\t" // all zeros
-		
-		".balign 16 \n\t"
-		"1: \n\t"
-		
-		// Even difference
-		"movq (%%esi), %%mm0 \n\t"
-		"movq (%%esi), %%mm2 \n\t"
-		"addl %%eax, %%esi \n\t"
-		"movq (%%edi), %%mm1 \n\t"
-		"addl %%ebx, %%edi \n\t"
-		"psubusb %%mm1, %%mm2 \n\t"
-		"psubusb %%mm0, %%mm1 \n\t"
-		"movq %%mm2, %%mm0 \n\t"
-		"movq %%mm1, %%mm3 \n\t"
-		"punpcklbw %%mm7, %%mm0 \n\t"
-		"punpcklbw %%mm7, %%mm1 \n\t"
-		"punpckhbw %%mm7, %%mm2 \n\t"
-		"punpckhbw %%mm7, %%mm3 \n\t"
-		"paddw %%mm0, %%mm4 \n\t"
-		"paddw %%mm1, %%mm4 \n\t"
-		"paddw %%mm2, %%mm4 \n\t"
-		"paddw %%mm3, %%mm4 \n\t"
-		
-		// Odd difference
-		"movq (%%esi), %%mm0 \n\t"
-		"movq (%%esi), %%mm2 \n\t"
-		"addl %%eax, %%esi \n\t"
-		"movq (%%edi), %%mm1 \n\t"
-		"addl %%ebx, %%edi \n\t"
-		"psubusb %%mm1, %%mm2 \n\t"
-		"psubusb %%mm0, %%mm1 \n\t"
-		"movq %%mm2, %%mm0 \n\t"
-		"movq %%mm1, %%mm3 \n\t"
-		"punpcklbw %%mm7, %%mm0 \n\t"
-		"punpcklbw %%mm7, %%mm1 \n\t"
-		"punpckhbw %%mm7, %%mm2 \n\t"
-		"punpckhbw %%mm7, %%mm3 \n\t"
-		"paddw %%mm0, %%mm5 \n\t"
-		"paddw %%mm1, %%mm5 \n\t"
-		"paddw %%mm2, %%mm5 \n\t"
-		"paddw %%mm3, %%mm5 \n\t"
-			
-		"decl %%ecx \n\t"
-		"jnz 1b \n\t"
-		"movq %%mm4, (%%edx) \n\t"
-		"movq %%mm5, 8(%%edx) \n\t"
-		: 
-		: "S" (old), "D" (nw), "a" (os), "b" (ns), "d" (out)
-		: "memory"
-		);
-	m->e = out[0]+out[1]+out[2]+out[3];
-	m->o = out[4]+out[5]+out[6]+out[7];
-	m->d = m->e + m->o;
-
-	asm (
-		// First loop to measure first four columns
-		"movl $4, %%ecx \n\t"
-		"pxor %%mm4, %%mm4 \n\t" // Past spacial noise
-		"pxor %%mm5, %%mm5 \n\t" // Temporal noise
-		"pxor %%mm6, %%mm6 \n\t" // Current spacial noise
-		
-		".balign 16 \n\t"
-		"2: \n\t"
-		
-		"movq (%%esi), %%mm0 \n\t"
-		"movq (%%esi,%%eax), %%mm1 \n\t"
-		"addl %%eax, %%esi \n\t"
-		"addl %%eax, %%esi \n\t"
-		"movq (%%edi), %%mm2 \n\t"
-		"movq (%%edi,%%ebx), %%mm3 \n\t"
-		"addl %%ebx, %%edi \n\t"
-		"addl %%ebx, %%edi \n\t"
-		"punpcklbw %%mm7, %%mm0 \n\t"
-		"punpcklbw %%mm7, %%mm1 \n\t"
-		"punpcklbw %%mm7, %%mm2 \n\t"
-		"punpcklbw %%mm7, %%mm3 \n\t"
-		"paddw %%mm1, %%mm4 \n\t"
-		"paddw %%mm1, %%mm5 \n\t"
-		"paddw %%mm3, %%mm6 \n\t"
-		"psubw %%mm0, %%mm4 \n\t"
-		"psubw %%mm2, %%mm5 \n\t"
-		"psubw %%mm2, %%mm6 \n\t"
-		
-		"decl %%ecx \n\t"
-		"jnz 2b \n\t"
-		
-		"movq %%mm0, %%mm1 \n\t"
-		"movq %%mm0, %%mm2 \n\t"
-		"movq %%mm0, %%mm3 \n\t"
-		"pcmpgtw %%mm4, %%mm1 \n\t"
-		"pcmpgtw %%mm5, %%mm2 \n\t"
-		"pcmpgtw %%mm6, %%mm3 \n\t"
-		"pxor %%mm1, %%mm4 \n\t"
-		"pxor %%mm2, %%mm5 \n\t"
-		"pxor %%mm3, %%mm6 \n\t"
-		"psubw %%mm1, %%mm4 \n\t"
-		"psubw %%mm2, %%mm5 \n\t"
-		"psubw %%mm3, %%mm6 \n\t"
-		"movq %%mm4, (%%edx) \n\t"
-		"movq %%mm5, 16(%%edx) \n\t"
-		"movq %%mm6, 32(%%edx) \n\t"
-
-		"movl %%eax, %%ecx \n\t"
-		"shll $3, %%ecx \n\t"
-		"subl %%ecx, %%esi \n\t"
-		"movl %%ebx, %%ecx \n\t"
-		"shll $3, %%ecx \n\t"
-		"subl %%ecx, %%edi \n\t"
-
-		// Second loop for the last four columns
-		"movl $4, %%ecx \n\t"
-		"pxor %%mm4, %%mm4 \n\t"
-		"pxor %%mm5, %%mm5 \n\t"
-		"pxor %%mm6, %%mm6 \n\t"
-		
-		".balign 16 \n\t"
-		"3: \n\t"
-		
-		"movq (%%esi), %%mm0 \n\t"
-		"movq (%%esi,%%eax), %%mm1 \n\t"
-		"addl %%eax, %%esi \n\t"
-		"addl %%eax, %%esi \n\t"
-		"movq (%%edi), %%mm2 \n\t"
-		"movq (%%edi,%%ebx), %%mm3 \n\t"
-		"addl %%ebx, %%edi \n\t"
-		"addl %%ebx, %%edi \n\t"
-		"punpckhbw %%mm7, %%mm0 \n\t"
-		"punpckhbw %%mm7, %%mm1 \n\t"
-		"punpckhbw %%mm7, %%mm2 \n\t"
-		"punpckhbw %%mm7, %%mm3 \n\t"
-		"paddw %%mm1, %%mm4 \n\t"
-		"paddw %%mm1, %%mm5 \n\t"
-		"paddw %%mm3, %%mm6 \n\t"
-		"psubw %%mm0, %%mm4 \n\t"
-		"psubw %%mm2, %%mm5 \n\t"
-		"psubw %%mm2, %%mm6 \n\t"
-		
-		"decl %%ecx \n\t"
-		"jnz 3b \n\t"
-		
-		"movq %%mm0, %%mm1 \n\t"
-		"movq %%mm0, %%mm2 \n\t"
-		"movq %%mm0, %%mm3 \n\t"
-		"pcmpgtw %%mm4, %%mm1 \n\t"
-		"pcmpgtw %%mm5, %%mm2 \n\t"
-		"pcmpgtw %%mm6, %%mm3 \n\t"
-		"pxor %%mm1, %%mm4 \n\t"
-		"pxor %%mm2, %%mm5 \n\t"
-		"pxor %%mm3, %%mm6 \n\t"
-		"psubw %%mm1, %%mm4 \n\t"
-		"psubw %%mm2, %%mm5 \n\t"
-		"psubw %%mm3, %%mm6 \n\t"
-		"movq %%mm4, 8(%%edx) \n\t"
-		"movq %%mm5, 24(%%edx) \n\t"
-		"movq %%mm6, 40(%%edx) \n\t"
-
-		"emms \n\t"
-		: 
-		: "S" (old), "D" (nw), "a" (os), "b" (ns), "d" (out)
-		: "memory"
-		);
-	m->p = m->t = m->s = 0;
-	for (i=0; i<8; i++) {
-		m->p += out[i];
-		m->t += out[8+i];
-		m->s += out[16+i];
-	}
-	//printf("e=%d o=%d d=%d p=%d t=%d s=%d\n", m->e, m->o, m->d, m->p, m->t, m->s);
-}
-#endif
-#endif

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/CMakeLists.txt	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter/CMakeLists.txt	2009-10-02 05:22:11 UTC (rev 5365)
@@ -1,12 +0,0 @@
-SET(ADM_videoFilter_SRCS 
-#
-#	ADM_vidDvbSub.cpp
-	#ADM_vidVobsub.cpp
-	#ADM_vidVobSubRender.cpp
-	#ADM_vobsubinfo.cpp
-	ADM_vidComputeAverage.cpp
-	ADM_vidThreshold.cpp
-	ADM_vidNumber.cpp)
-
-ADD_LIBRARY(ADM_videoFilter6 STATIC ${ADM_videoFilter_SRCS})
-

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/CMakeLists.txt	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/CMakeLists.txt	2009-10-02 05:22:11 UTC (rev 5365)
@@ -4,7 +4,7 @@
 ADD_SUBDIRECTORY(ADM_codecs)
 ADD_SUBDIRECTORY(ADM_commonUI)
 ADD_SUBDIRECTORY(ADM_editor)
-ADD_SUBDIRECTORY(ADM_filter)
+#ADD_SUBDIRECTORY(ADM_filter)
 #ADD_SUBDIRECTORY(ADM_infoExtractor)
 ADD_SUBDIRECTORY(ADM_libraries)
 #ADD_SUBDIRECTORY(ADM_mpegIndexer)
@@ -17,6 +17,6 @@
 ADD_SUBDIRECTORY(ADM_script)
 ADD_SUBDIRECTORY(ADM_toolkit)
 #ADD_SUBDIRECTORY(ADM_video)
-ADD_SUBDIRECTORY(ADM_videoFilter)
+#ADD_SUBDIRECTORY(ADM_videoFilter)
 ADD_SUBDIRECTORY(ADM_videoEncoder)
 ADD_SUBDIRECTORY(ADM_videoFilter2)

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/gui_autodrive.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/gui_autodrive.cpp	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/gui_autodrive.cpp	2009-10-02 05:22:11 UTC (rev 5365)
@@ -32,7 +32,7 @@
 #include "gui_action.hxx"
 
 //#include "ADM_encoder/adm_encConfig.h"
-#include "ADM_filter/vidVCD.h"
+//#include "ADM_filter/vidVCD.h"
 //#include "ADM_encoder/ADM_vidEncode.hxx"
 
 //extern void setVideoEncoderSettings (COMPRESSION_MODE mode, uint32_t param,     uint32_t extraConf, uint8_t * extraData);

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/main.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/main.cpp	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/main.cpp	2009-10-02 05:22:11 UTC (rev 5365)
@@ -223,7 +223,7 @@
     video_body = new ADM_Composer;
 
 #ifdef HAVE_ENCODER
-     registerVideoFilters();
+//     registerVideoFilters();
 #endif
     ADM_lavFormatInit();
 	//***************Plugins *********************

Modified: branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake	2009-10-02 05:22:11 UTC (rev 5365)
@@ -90,15 +90,16 @@
 ADM_commonUI6
 )
 SET(commonLibs2
-ADM_filter6 
+#ADM_filter6 
 ADM_osSupport6 
 ADM_requant6 
 ADM_script6 
 ADM_toolkit6
 ADM_videoEncoder6 
+ADM_internalVideoFilter6
+
 #ADM_video6 
-ADM_videoFilter6 
-ADM_internalVideoFilter6
+#ADM_videoFilter6 
 )
 
 # END

Modified: branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_dialog/DIA_vobsub.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_dialog/DIA_vobsub.cpp	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_dialog/DIA_vobsub.cpp	2009-10-02 05:22:11 UTC (rev 5365)
@@ -21,7 +21,7 @@
 
 #include "DIA_coreToolkit.h"
 #include "DIA_fileSel.h"
-
+#if 0
 #define CHECK_GET(x,y) {*y=gtk_toggle_button_get_active( GTK_TOGGLE_BUTTON(WID(x)));}
 #define CHECK_SET(x,y) {gtk_toggle_button_set_active( GTK_TOGGLE_BUTTON(WID(x)),*y);}   
 #include "ADM_videoFilter.h"
@@ -315,4 +315,4 @@
 
   return dialog1;
 }
-
+#endif

Modified: branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_filters/gui_filtermanager.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_filters/gui_filtermanager.cpp	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_filters/gui_filtermanager.cpp	2009-10-02 05:22:11 UTC (rev 5365)
@@ -18,7 +18,7 @@
 #include "ADM_videoFilter_internal.h"
 #include "ADM_editor/ADM_edit.hxx"
 #include "avi_vars.h"
-#include "ADM_filter/vidVCD.h"
+//#include "ADM_filter/vidVCD.h"
 //___________________________________________
 typedef enum 
 {

Modified: branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_ocr/adm_ocr.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_ocr/adm_ocr.cpp	2009-10-02 05:22:07 UTC (rev 5364)
+++ branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_ocr/adm_ocr.cpp	2009-10-02 05:22:11 UTC (rev 5365)
@@ -37,9 +37,9 @@
 #include "ADM_videoFilter.h"
 #include "DIA_fileSel.h"
 
-
-#include "ADM_videoFilter/ADM_vobsubinfo.h"
-#include "ADM_videoFilter/ADM_vidVobSub.h"
+#if 0
+//#include "ADM_videoFilter/ADM_vobsubinfo.h"
+//#include "ADM_videoFilter/ADM_vidVobSub.h"
 #include "ADM_ocr/ADM_leftturn.h"
 #include "DIA_enter.h"
 
@@ -367,4 +367,5 @@
 	    return (void *)dialog;
 	
 }
+#endif
 //;



From mean at mail.berlios.de  Fri Oct  2 07:22:18 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 2 Oct 2009 07:22:18 +0200
Subject: [Avidemux-svn-commit] r5366 -
	branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/glade/main
Message-ID: <200910020522.n925MIBE030844@sheep.berlios.de>

Author: mean
Date: 2009-10-02 07:22:17 +0200 (Fri, 02 Oct 2009)
New Revision: 5366

Added:
   branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/glade/main/gtk2_build.gtkBuilder
Log:
[GTK] Switch from libflade to gtkbuilder for main menu

Added: branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/glade/main/gtk2_build.gtkBuilder
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/glade/main/gtk2_build.gtkBuilder	2009-10-02 05:22:11 UTC (rev 5365)
+++ branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/glade/main/gtk2_build.gtkBuilder	2009-10-02 05:22:17 UTC (rev 5366)
@@ -0,0 +1,1775 @@
+<?xml version="1.0"?>
+<interface>
+  <object class="GtkAdjustment" id="adjustment1">
+    <property name="upper">100</property>
+    <property name="lower">0</property>
+    <property name="page_increment">1</property>
+    <property name="step_increment">1</property>
+    <property name="page_size">1</property>
+    <property name="value">99</property>
+  </object>
+  <object class="GtkAdjustment" id="adjustment2">
+    <property name="upper">99999</property>
+    <property name="lower">-99999</property>
+    <property name="page_increment">10</property>
+    <property name="step_increment">1</property>
+    <property name="page_size">10</property>
+    <property name="value">0</property>
+  </object>
+  <object class="GtkAdjustment" id="adjustment3">
+    <property name="upper">99.989997863799999</property>
+    <property name="lower">0</property>
+    <property name="page_increment">1</property>
+    <property name="step_increment">0.0099999997764800008</property>
+    <property name="page_size">0</property>
+    <property name="value">0</property>
+  </object>
+  <object class="GtkListStore" id="model1">
+    <columns>
+      <column type="gchararray"/>
+    </columns>
+    <data>
+      <row>
+        <col id="0" translatable="yes">Copy</col>
+      </row>
+    </data>
+  </object>
+  <object class="GtkListStore" id="model2">
+    <columns>
+      <column type="gchararray"/>
+    </columns>
+    <data>
+      <row>
+        <col id="0" translatable="yes">Copy</col>
+      </row>
+    </data>
+  </object>
+  <object class="GtkListStore" id="model3">
+    <columns>
+      <column type="gchararray"/>
+    </columns>
+    <data>
+      <row>
+        <col id="0" translatable="yes">Copy</col>
+      </row>
+    </data>
+  </object>
+  <object class="GtkUIManager" id="uimanager1">
+    <child>
+      <object class="GtkActionGroup" id="actiongroup1">
+        <child>
+          <object class="GtkAction" id="menuitem1">
+            <property name="name">menuitem1</property>
+            <property name="label" translatable="yes">_File</property>
+          </object>
+        </child>
+        <child>
+          <object class="GtkAction" id="open_video1">
+            <property name="stock_id">_Open...</property>
+            <property name="name">open_video1</property>
+          </object>
+          <accelerator key="O" modifiers="GDK_CONTROL_MASK"/>
+        </child>
+        <child>
+          <object class="GtkAction" id="append_video1">
+            <property name="stock_id">_Append...</property>
+            <property name="name">append_video1</property>
+          </object>
+          <accelerator key="A" modifiers="GDK_CONTROL_MASK | GDK_MOD1_MASK"/>
+        </child>
+        <child>
+          <object class="GtkAction" id="save_stuff">
+            <property name="stock_id">_Save</property>
+            <property name="name">save_stuff</property>
+          </object>
+        </child>
+        <child>
+          <object class="GtkAction" id="save_as_avi1">
+            <property name="name">save_as_avi1</property>
+            <property name="label" translatable="yes">Save _Video...</property>
+          </object>
+          <accelerator key="S" modifiers="GDK_CONTROL_MASK"/>
+        </child>
+        <child>
+          <object class="GtkAction" id="save_image1">
+            <property name="name">save_image1</property>
+            <property name="label" translatable="yes">Save _BMP Image...</property>
+          </object>
+        </child>
+        <child>
+          <object class="GtkAction" id="save_jpg_image1">
+            <property name="name">save_jpg_image1</property>
+            <property name="label" translatable="yes">Save _JPEG Image...</property>
+          </object>
+        </child>
+        <child>
+          <object class="GtkAction" id="save_selection_as_jpegs1">
+            <property name="name">save_selection_as_jpegs1</property>
+            <property name="label" translatable="yes">Save _Selection as JPEG Images...</property>
+          </object>
+        </child>
+        <child>
+          <object class="GtkAction" id="close1">
+            <property name="stock_id">gtk-close</property>
+            <property name="name">close1</property>
+          </object>
+        </child>
+        <child>
+          <object class="GtkAction" id="save_project1">
+            <property name="stock_id">Save _Project</property>
+            <property name="name">save_project1</property>
+          </object>
+        </child>
+        <child>
+          <object class="GtkAction" id="save_project_as1">
+            <property name="stock_id">Save P_roject As...</property>
+            <property name="name">save_project_as1</property>
+          </object>
+        </child>
+        <child>
+          <object class="GtkAction" id="run_script1">
+            <property name="stock_id">_Load/Run Project...</property>
+            <property name="name">run_script1</property>
+          </object>
+        </child>
+        <child>
+          <object class="GtkAction" id="add_to_joblist1">
+            <property name="name">add_to_joblist1</property>
+            <property name="label" translatable="yes">A_dd to Joblist...</property>
+          </object>
+        </child>
+        <child>
+          <object class="GtkAction" id="joblist1">
+            <property name="name">joblist1</property>
+            <property name="label" translatable="yes">Show _Joblist</property>
+          </object>
+          <accelerator key="J" modifiers="GDK_CONTROL_MASK"/>
+        </child>
+        <child>
+          <object class="GtkAction" id="connect_to_avsproxy1">
+            <property name="name">connect_to_avsproxy1</property>
+            <property name="label" translatable="yes">Co_nnect to avsproxy</property>
+          </object>
+        </child>
+        <child>
+          <object class="GtkAction" id="video_informations1">
+            <property name="stock_id">Proper_ties</property>
+            <property name="name">video_informations1</property>
+          </object>
+          <accelerator key="Return" modifiers="GDK_MOD1_MASK"/>
+        </child>
+        <child>
+          <object class="GtkAction" id="avi_muxer_options1">
+            <property name="name">avi_muxer_options1</property>
+            <property name="label" translatable="yes">AVI _Muxer Options</property>
+          </object>
+        </child>
+        <child>
+          <object class="GtkAction" id="quit1">
+            <property name="stock_id">_Quit</property>
+            <property name="name">quit1</property>
+          </object>
+          <accelerator key="Q" modifiers="GDK_CONTROL_MASK"/>
+        </child>
+        <child>
+          <object class="GtkAction" id="menuitem2">
+            <property name="name">menuitem2</property>
+            <property name="label" translatable="yes">_Edit</property>
+          </object>
+        </child>
+        <child>
+          <object class="GtkAction" id="reset_edits1">
+            <property name="stock_id">_Reset Edits</property>
+            <property name="name">reset_edits1</property>
+          </object>
+        </child>
+        <child>
+          <object class="GtkAction" id="cut1">
+            <property name="stock_id">Cu_t</property>
+            <property name="name">cut1</property>
+          </object>
+          <accelerator key="X" modifiers="GDK_CONTROL_MASK"/>
+        </child>
+        <child>
+          <object class="GtkAction" id="copy1">
+            <property name="stock_id">_Copy</property>
+            <property name="name">copy1</property>
+          </object>
+          <accelerator key="C" modifiers="GDK_CONTROL_MASK"/>
+        </child>
+        <child>
+          <object class="GtkAction" id="paste1">
+            <property name="stock_id">_Paste</property>
+            <property name="name">paste1</property>
+          </object>
+          <accelerator key="V" modifiers="GDK_CONTROL_MASK"/>
+        </child>
+        <child>
+          <object class="GtkAction" id="delete1">
+            <property name="stock_id">_Delete</property>
+            <property name="name">delete1</property>
+          </object>
+          <accelerator key="Delete"/>
+        </child>
+        <child>
+          <object class="GtkAction" id="set_marker_a1">
+            <property name="name">set_marker_a1</property>
+            <property name="label" translatable="yes">Set Marker _A</property>
+          </object>
+          <accelerator key="bracketleft"/>
+        </child>
+        <child>
+          <object class="GtkAction" id="set_marker_b1">
+            <property name="name">set_marker_b1</property>
+            <property name="label" translatable="yes">Set Marker _B</property>
+          </object>
+          <accelerator key="bracketright"/>
+        </child>
+        <child>
+          <object class="GtkAction" id="preferences1">
+            <property name="stock_id">Pre_ferences</property>
+            <property name="name">preferences1</property>
+          </object>
+        </child>
+        <child>
+          <object class="GtkAction" id="view1">
+            <property name="name">view1</property>
+            <property name="label" translatable="yes">_View</property>
+          </object>
+        </child>
+        <child>
+          <object class="GtkToggleAction" id="toolbar1">
+            <property name="active">True</property>
+            <property name="name">toolbar1</property>
+            <property name="label" translatable="yes">_Main Toolbar</property>
+          </object>
+        </child>
+        <child>
+          <object class="GtkToggleAction" id="sidebar1">
+            <property name="active">True</property>
+            <property name="name">sidebar1</property>
+            <property name="label" translatable="yes">_A/V Sidebar</property>
+          </object>
+        </child>
+        <child>
+          <object class="GtkAction" id="zoom_1_4">
+            <property name="name">zoom_1_4</property>
+            <property name="label" translatable="yes">_Zoom 1:4</property>
+          </object>
+          <accelerator key="4" modifiers="GDK_SHIFT_MASK | GDK_CONTROL_MASK"/>
+        </child>
+        <child>
+          <object class="GtkAction" id="zoom_1_2">
+            <property name="name">zoom_1_2</property>
+            <property name="label" translatable="yes">Z_oom 1:2</property>
+          </object>
+          <accelerator key="2" modifiers="GDK_SHIFT_MASK | GDK_CONTROL_MASK"/>
+        </child>
+        <child>
+          <object class="GtkAction" id="zoom_1_1">
+            <property name="name">zoom_1_1</property>
+            <property name="label" translatable="yes">Zoom _1:1</property>
+          </object>
+          <accelerator key="1" modifiers="GDK_CONTROL_MASK | GDK_MOD1_MASK"/>
+        </child>
+        <child>
+          <object class="GtkAction" id="zoom_2_1">
+            <property name="name">zoom_2_1</property>
+            <property name="label" translatable="yes">Zoom _2:1</property>
+          </object>
+          <accelerator key="2" modifiers="GDK_CONTROL_MASK | GDK_MOD1_MASK"/>
+        </child>
+        <child>
+          <object class="GtkAction" id="video_1">
+            <property name="name">video_1</property>
+            <property name="label" translatable="yes">Vi_deo</property>
+          </object>
+        </child>
+        <child>
+          <object class="GtkAction" id="decoder_options1">
+            <property name="name">decoder_options1</property>
+            <property name="label" translatable="yes">_Decoder Options</property>
+          </object>
+          <accelerator key="F3"/>
+        </child>
+        <child>
+          <object class="GtkAction" id="set_postprocessing1">
+            <property name="name">set_postprocessing1</property>
+            <property name="tooltip" translatable="yes">Select postprocessing level</property>
+            <property name="label" translatable="yes">_Postprocessing</property>
+          </object>
+          <accelerator key="F4"/>
+        </child>
+        <child>
+          <object class="GtkToggleAction" id="preview1">
+            <property name="name">preview1</property>
+            <property name="label" translatable="yes">P_review</property>
+          </object>
+          <accelerator key="F5"/>
+        </child>
+        <child>
+          <object class="GtkToggleAction" id="display_output1">
+            <property name="name">display_output1</property>
+            <property name="label" translatable="yes">Display _Output</property>
+          </object>
+          <accelerator key="F6"/>
+        </child>
+        <child>
+          <object class="GtkAction" id="change_fps">
+            <property name="name">change_fps</property>
+            <property name="label" translatable="yes">_Frame Rate</property>
+          </object>
+        </child>
+        <child>
+          <object class="GtkAction" id="videoencoder">
+            <property name="name">videoencoder</property>
+            <property name="label" translatable="yes">_Encoder</property>
+          </object>
+          <accelerator key="V" modifiers="GDK_CONTROL_MASK | GDK_MOD1_MASK"/>
+        </child>
+        <child>
+          <object class="GtkAction" id="filters1">
+            <property name="name">filters1</property>
+            <property name="label" translatable="yes">Fil_ters</property>
+          </object>
+          <accelerator key="F" modifiers="GDK_CONTROL_MASK | GDK_MOD1_MASK"/>
+        </child>
+        <child>
+          <object class="GtkAction" id="audio1">
+            <property name="name">audio1</property>
+            <property name="label" translatable="yes">_Audio</property>
+          </object>
+        </child>
+        <child>
+          <object class="GtkAction" id="main_audio">
+            <property name="name">main_audio</property>
+            <property name="label" translatable="yes">_Main Track</property>
+          </object>
+        </child>
+        <child>
+          <object class="GtkAction" id="second_audio_track1">
+            <property name="name">second_audio_track1</property>
+            <property name="label" translatable="yes">_Second Track</property>
+          </object>
+        </child>
+        <child>
+          <object class="GtkAction" id="build_vbr_time_map1">
+            <property name="name">build_vbr_time_map1</property>
+            <property name="label" translatable="yes">_Build VBR Time Map</property>
+          </object>
+        </child>
+        <child>
+          <object class="GtkAction" id="save_audio1">
+            <property name="stock_id">S_ave...</property>
+            <property name="name">save_audio1</property>
+          </object>
+          <accelerator key="S" modifiers="GDK_CONTROL_MASK | GDK_MOD1_MASK"/>
+        </child>
+        <child>
+          <object class="GtkAction" id="audio_encoder1">
+            <property name="name">audio_encoder1</property>
+            <property name="label" translatable="yes">_Encoder</property>
+          </object>
+          <accelerator key="A" modifiers="GDK_CONTROL_MASK | GDK_MOD1_MASK"/>
+        </child>
+        <child>
+          <object class="GtkAction" id="filters2">
+            <property name="name">filters2</property>
+            <property name="label" translatable="yes">_Filters</property>
+          </object>
+        </child>
+        <child>
+          <object class="GtkAction" id="tools1">
+            <property name="name">tools1</property>
+            <property name="label" translatable="yes">_Tools</property>
+          </object>
+        </child>
+        <child>
+          <object class="GtkAction" id="calculator1">
+            <property name="stock_id">_Calculator</property>
+            <property name="name">calculator1</property>
+          </object>
+          <accelerator key="F7"/>
+        </child>
+        <child>
+          <object class="GtkAction" id="rebuild_frames">
+            <property name="name">rebuild_frames</property>
+            <property name="label" translatable="yes">_Rebuild Frames (I &amp; B)</property>
+          </object>
+        </child>
+        <child>
+          <object class="GtkAction" id="check_frames">
+            <property name="name">check_frames</property>
+            <property name="label" translatable="yes">C_heck Frames (slow)</property>
+          </object>
+        </child>
+        <child>
+          <object class="GtkAction" id="bitrate_histogram1">
+            <property name="name">bitrate_histogram1</property>
+            <property name="label" translatable="yes">_Bitrate Histogram</property>
+          </object>
+        </child>
+        <child>
+          <object class="GtkAction" id="item1">
+            <property name="name">item1</property>
+            <property name="label" translatable="yes">_Scan for Black Frames...</property>
+          </object>
+        </child>
+        <child>
+          <object class="GtkAction" id="v2v">
+            <property name="name">v2v</property>
+            <property name="label" translatable="yes">_VOB -&gt; VobSub</property>
+          </object>
+        </child>
+        <child>
+          <object class="GtkAction" id="ocr_vobsub_2_srt">
+            <property name="name">ocr_vobsub_2_srt</property>
+            <property name="label" translatable="yes">_OCR (VobSub -&gt; srt)</property>
+          </object>
+        </child>
+        <child>
+          <object class="GtkAction" id="ocr_dvb">
+            <property name="name">ocr_dvb</property>
+            <property name="label" translatable="yes">OCR (TS-&gt;srt)</property>
+          </object>
+        </child>
+        <child>
+          <object class="GtkAction" id="edit_glyph1">
+            <property name="name">edit_glyph1</property>
+            <property name="label" translatable="yes">_Edit Glyph</property>
+          </object>
+        </child>
+        <child>
+          <object class="GtkAction" id="see_hex1">
+            <property name="name">see_hex1</property>
+            <property name="label" translatable="yes">_Frame Hex Dump</property>
+          </object>
+        </child>
+        <child>
+          <object class="GtkAction" id="see_size">
+            <property name="name">see_size</property>
+            <property name="label" translatable="yes">Frame Size Dump</property>
+          </object>
+        </child>
+        <child>
+          <object class="GtkAction" id="help1">
+            <property name="name">help1</property>
+            <property name="label" translatable="yes">A_uto</property>
+          </object>
+        </child>
+        <child>
+          <object class="GtkAction" id="vcd1">
+            <property name="name">vcd1</property>
+            <property name="label" translatable="yes">_VCD</property>
+          </object>
+        </child>
+        <child>
+          <object class="GtkAction" id="svcd1">
+            <property name="name">svcd1</property>
+            <property name="label" translatable="yes">_SVCD</property>
+          </object>
+        </child>
+        <child>
+          <object class="GtkAction" id="dvd1">
+            <property name="name">dvd1</property>
+            <property name="label" translatable="yes">_DVD</property>
+          </object>
+        </child>
+        <child>
+          <object class="GtkAction" id="psp1">
+            <property name="name">psp1</property>
+            <property name="label" translatable="yes">_PSP</property>
+          </object>
+        </child>
+        <child>
+          <object class="GtkAction" id="psp_(h264)1">
+            <property name="name">psp_(h264)1</property>
+            <property name="label" translatable="yes">PSP (_H.264)</property>
+          </object>
+        </child>
+        <child>
+          <object class="GtkAction" id="flv1">
+            <property name="name">flv1</property>
+            <property name="label" translatable="yes">F_LV</property>
+          </object>
+        </child>
+        <child>
+          <object class="GtkAction" id="Ipod">
+            <property name="name">Ipod</property>
+            <property name="label" translatable="yes">IPOD (mpeg4)</property>
+          </object>
+        </child>
+        <child>
+          <object class="GtkAction" id="go1">
+            <property name="name">go1</property>
+            <property name="label" translatable="yes">_Go</property>
+          </object>
+        </child>
+        <child>
+          <object class="GtkAction" id="play_video1">
+            <property name="stock_id">_Play/Stop</property>
+            <property name="name">play_video1</property>
+          </object>
+          <accelerator key="P"/>
+        </child>
+        <child>
+          <object class="GtkAction" id="previous_frame1">
+            <property name="stock_id">P_revious Frame</property>
+            <property name="name">previous_frame1</property>
+          </object>
+          <accelerator key="KP_4"/>
+        </child>
+        <child>
+          <object class="GtkAction" id="next_frame1">
+            <property name="stock_id">_Next Frame</property>
+            <property name="name">next_frame1</property>
+          </object>
+          <accelerator key="KP_6"/>
+        </child>
+        <child>
+          <object class="GtkAction" id="previous_intra_frame1">
+            <property name="stock_id">Pr_evious Intra Frame</property>
+            <property name="name">previous_intra_frame1</property>
+          </object>
+          <accelerator key="KP_2"/>
+        </child>
+        <child>
+          <object class="GtkAction" id="next_intra_frame1">
+            <property name="stock_id">Next _Intra Frame</property>
+            <property name="name">next_intra_frame1</property>
+          </object>
+          <accelerator key="KP_8"/>
+        </child>
+        <child>
+          <object class="GtkAction" id="search_previous_black_frame1">
+            <property name="name">search_previous_black_frame1</property>
+            <property name="label" translatable="yes">Previou_s Black Frame</property>
+          </object>
+        </child>
+        <child>
+          <object class="GtkAction" id="search_next_black_frame1">
+            <property name="name">search_next_black_frame1</property>
+            <property name="label" translatable="yes">Ne_xt Black Frame</property>
+          </object>
+        </child>
+        <child>
+          <object class="GtkAction" id="first_frame1">
+            <property name="stock_id">_First Frame</property>
+            <property name="name">first_frame1</property>
+          </object>
+          <accelerator key="Home"/>
+        </child>
+        <child>
+          <object class="GtkAction" id="last_frame1">
+            <property name="stock_id">_Last Frame</property>
+            <property name="name">last_frame1</property>
+          </object>
+          <accelerator key="End"/>
+        </child>
+        <child>
+          <object class="GtkAction" id="go_to_marker_a1">
+            <property name="name">go_to_marker_a1</property>
+            <property name="label" translatable="yes">Go to Marker _A</property>
+          </object>
+          <accelerator key="bracketleft" modifiers="GDK_CONTROL_MASK"/>
+        </child>
+        <child>
+          <object class="GtkAction" id="go_to_marker_b1">
+            <property name="name">go_to_marker_b1</property>
+            <property name="label" translatable="yes">Go to Marker _B</property>
+          </object>
+          <accelerator key="bracketright" modifiers="GDK_CONTROL_MASK"/>
+        </child>
+        <child>
+          <object class="GtkAction" id="jum_to_frame1">
+            <property name="stock_id">Go to Fra_me...</property>
+            <property name="name">jum_to_frame1</property>
+          </object>
+          <accelerator key="F" modifiers="GDK_CONTROL_MASK"/>
+        </child>
+        <child>
+          <object class="GtkAction" id="jump_to_time1">
+            <property name="stock_id">Go to _Time...</property>
+            <property name="name">jump_to_time1</property>
+          </object>
+          <accelerator key="T" modifiers="GDK_CONTROL_MASK"/>
+        </child>
+        <child>
+          <object class="GtkAction" id="custom1">
+            <property name="name">custom1</property>
+            <property name="label" translatable="yes">_Custom</property>
+          </object>
+        </child>
+        <child>
+          <object class="GtkAction" id="help2">
+            <property name="name">help2</property>
+            <property name="label" translatable="yes">_Help</property>
+          </object>
+        </child>
+        <child>
+          <object class="GtkAction" id="plugins1">
+            <property name="name">plugins1</property>
+            <property name="label" translatable="yes">_Plugins</property>
+            <signal handler="on_plugins1_activate" name="activate"/>
+          </object>
+        </child>
+        <child>
+          <object class="GtkAction" id="show_builtin_support1">
+            <property name="name">show_builtin_support1</property>
+            <property name="label" translatable="yes">_Built-in Support</property>
+          </object>
+        </child>
+        <child>
+          <object class="GtkAction" id="about1">
+            <property name="stock_id">_About</property>
+            <property name="name">about1</property>
+          </object>
+        </child>
+      </object>
+    </child>
+    <ui>
+      <menubar name="menuBar">
+        <menu action="menuitem1">
+          <menuitem action="open_video1"/>
+          <menuitem action="append_video1"/>
+          <menu action="save_stuff">
+            <menuitem action="save_as_avi1"/>
+            <separator/>
+            <menuitem action="save_image1"/>
+            <menuitem action="save_jpg_image1"/>
+            <menuitem action="save_selection_as_jpegs1"/>
+          </menu>
+          <menuitem action="close1"/>
+          <separator/>
+          <menuitem action="save_project1"/>
+          <menuitem action="save_project_as1"/>
+          <menuitem action="run_script1"/>
+          <menuitem action="add_to_joblist1"/>
+          <menuitem action="joblist1"/>
+          <separator/>
+          <menuitem action="connect_to_avsproxy1"/>
+          <separator/>
+          <menuitem action="video_informations1"/>
+          <menuitem action="avi_muxer_options1"/>
+          <separator/>
+          <menuitem action="quit1"/>
+        </menu>
+        <menu action="menuitem2">
+          <menuitem action="reset_edits1"/>
+          <separator/>
+          <menuitem action="cut1"/>
+          <menuitem action="copy1"/>
+          <menuitem action="paste1"/>
+          <menuitem action="delete1"/>
+          <separator/>
+          <menuitem action="set_marker_a1"/>
+          <menuitem action="set_marker_b1"/>
+          <separator/>
+          <menuitem action="preferences1"/>
+        </menu>
+        <menu action="view1">
+          <menuitem action="toolbar1"/>
+          <menuitem action="sidebar1"/>
+          <separator/>
+          <menuitem action="zoom_1_4"/>
+          <menuitem action="zoom_1_2"/>
+          <menuitem action="zoom_1_1"/>
+          <menuitem action="zoom_2_1"/>
+        </menu>
+        <menu action="video_1">
+          <menuitem action="decoder_options1"/>
+          <menuitem action="set_postprocessing1"/>
+          <separator/>
+          <menuitem action="preview1"/>
+          <menuitem action="display_output1"/>
+          <separator/>
+          <menuitem action="change_fps"/>
+          <menuitem action="videoencoder"/>
+          <menuitem action="filters1"/>
+        </menu>
+        <menu action="audio1">
+          <menuitem action="main_audio"/>
+          <menuitem action="second_audio_track1"/>
+          <menuitem action="build_vbr_time_map1"/>
+          <separator/>
+          <menuitem action="save_audio1"/>
+          <menuitem action="audio_encoder1"/>
+          <menuitem action="filters2"/>
+        </menu>
+        <menu action="tools1">
+          <menuitem action="calculator1"/>
+          <separator/>
+          <menuitem action="rebuild_frames"/>
+          <menuitem action="check_frames"/>
+          <menuitem action="bitrate_histogram1"/>
+          <menuitem action="item1"/>
+          <separator/>
+          <menuitem action="v2v"/>
+          <menuitem action="ocr_vobsub_2_srt"/>
+          <menuitem action="ocr_dvb"/>
+          <menuitem action="edit_glyph1"/>
+          <separator/>
+          <menuitem action="see_hex1"/>
+          <menuitem action="see_size"/>
+        </menu>
+        <menu action="help1">
+          <menuitem action="vcd1"/>
+          <menuitem action="svcd1"/>
+          <menuitem action="dvd1"/>
+          <menuitem action="psp1"/>
+          <menuitem action="psp_(h264)1"/>
+          <menuitem action="flv1"/>
+          <menuitem action="Ipod"/>
+        </menu>
+        <menu action="go1">
+          <menuitem action="play_video1"/>
+          <menuitem action="previous_frame1"/>
+          <menuitem action="next_frame1"/>
+          <menuitem action="previous_intra_frame1"/>
+          <menuitem action="next_intra_frame1"/>
+          <menuitem action="search_previous_black_frame1"/>
+          <menuitem action="search_next_black_frame1"/>
+          <menuitem action="first_frame1"/>
+          <menuitem action="last_frame1"/>
+          <separator/>
+          <menuitem action="go_to_marker_a1"/>
+          <menuitem action="go_to_marker_b1"/>
+          <separator/>
+          <menuitem action="jum_to_frame1"/>
+          <menuitem action="jump_to_time1"/>
+        </menu>
+        <menuitem action="custom1"/>
+        <menu action="help2">
+          <menuitem action="plugins1"/>
+          <menuitem action="show_builtin_support1"/>
+          <menuitem action="about1"/>
+        </menu>
+      </menubar>
+    </ui>
+  </object>
+  <!-- interface-requires gtk+ 2.16 -->
+  <!-- interface-naming-policy toplevel-contextual -->
+  <object class="GtkWindow" id="mainWindow">
+    <property name="visible">True</property>
+    <property name="title" translatable="yes">Avidemux</property>
+    <property name="icon">avidemux_icon_small.png</property>
+    <child>
+      <object class="GtkVBox" id="vbox1">
+        <property name="visible">True</property>
+        <child>
+          <object class="GtkMenuBar" constructor="uimanager1" id="menuBar">
+            <property name="visible">True</property>
+            <property name="can_focus">True</property>
+          </object>
+          <packing>
+            <property name="expand">False</property>
+            <property name="fill">False</property>
+            <property name="position">0</property>
+          </packing>
+        </child>
+        <child>
+          <object class="GtkToolbar" id="toolbar2">
+            <property name="visible">True</property>
+            <property name="toolbar_style">both-horiz</property>
+            <child>
+              <object class="GtkMenuToolButton" id="menutoolbuttonOpen">
+                <property name="visible">True</property>
+                <property name="tooltip-text" translatable="yes">Open a file</property>
+                <property name="is_important">True</property>
+                <property name="stock_id">gtk-open</property>
+              </object>
+              <packing>
+                <property name="expand">False</property>
+              </packing>
+            </child>
+            <child>
+              <object class="GtkToolItem" id="toolitem11">
+                <property name="visible">True</property>
+              </object>
+              <packing>
+                <property name="expand">False</property>
+              </packing>
+            </child>
+            <child>
+              <object class="GtkToolButton" id="toolbuttonSave">
+                <property name="visible">True</property>
+                <property name="tooltip-text" translatable="yes">Save the file</property>
+                <property name="is_important">True</property>
+                <property name="stock_id">gtk-save</property>
+              </object>
+              <packing>
+                <property name="expand">False</property>
+                <property name="homogeneous">True</property>
+              </packing>
+            </child>
+            <child>
+              <object class="GtkToolButton" id="toolbuttonInfo">
+                <property name="visible">True</property>
+                <property name="tooltip-text" translatable="yes">Audio/video file information</property>
+                <property name="stock_id">gtk-properties</property>
+              </object>
+              <packing>
+                <property name="expand">False</property>
+                <property name="homogeneous">True</property>
+              </packing>
+            </child>
+            <child>
+              <object class="GtkSeparatorToolItem" id="separatortoolitem1">
+                <property name="visible">True</property>
+              </object>
+              <packing>
+                <property name="expand">False</property>
+              </packing>
+            </child>
+            <child>
+              <object class="GtkToolButton" id="toolbuttonCalc">
+                <property name="visible">True</property>
+                <property name="tooltip-text" translatable="yes">Bitrate/size calculator</property>
+                <property name="is_important">True</property>
+                <property name="label" translatable="yes">Calculator</property>
+                <property name="use_underline">True</property>
+                <property name="icon">gnome-calculator.png</property>
+              </object>
+              <packing>
+                <property name="expand">False</property>
+                <property name="homogeneous">True</property>
+              </packing>
+            </child>
+            <child>
+              <object class="GtkSeparatorToolItem" id="separatortoolitem2">
+                <property name="visible">True</property>
+              </object>
+              <packing>
+                <property name="expand">False</property>
+              </packing>
+            </child>
+            <child>
+              <object class="GtkToolItem" id="toolitem12">
+                <property name="visible">True</property>
+                <child>
+                  <object class="GtkComboBox" id="comboboxPreview">
+                    <property name="visible">True</property>
+                  </object>
+                </child>
+              </object>
+              <packing>
+                <property name="expand">False</property>
+              </packing>
+            </child>
+            <child>
+              <object class="GtkToolItem" id="toolitem13">
+                <property name="visible">True</property>
+                <child>
+                  <object class="GtkToggleButton" id="togglebutton1">
+                    <property name="visible">True</property>
+                    <property name="can_focus">True</property>
+                    <property name="receives_default">False</property>
+                    <property name="relief">none</property>
+                    <child>
+                      <object class="GtkImage" id="image8272">
+                        <property name="width_request">17</property>
+                        <property name="height_request">16</property>
+                        <property name="visible">True</property>
+                        <property name="pixbuf">audio-volume-medium.png</property>
+                      </object>
+                    </child>
+                  </object>
+                </child>
+              </object>
+              <packing>
+                <property name="expand">False</property>
+              </packing>
+            </child>
+            <child>
+              <object class="GtkToolItem" id="toolitem14">
+                <property name="visible">True</property>
+                <child>
+                  <object class="GtkHScale" id="hscalVolume">
+                    <property name="width_request">100</property>
+                    <property name="visible">True</property>
+                    <property name="can_focus">True</property>
+                    <property name="adjustment">adjustment1</property>
+                    <property name="digits">0</property>
+                    <property name="draw_value">False</property>
+                  </object>
+                </child>
+              </object>
+              <packing>
+                <property name="expand">False</property>
+              </packing>
+            </child>
+          </object>
+          <packing>
+            <property name="expand">False</property>
+            <property name="fill">False</property>
+            <property name="position">1</property>
+          </packing>
+        </child>
+        <child>
+          <object class="GtkVBox" id="vbox10">
+            <property name="visible">True</property>
+            <property name="spacing">3</property>
+            <child>
+              <object class="GtkHBox" id="hbox14">
+                <property name="visible">True</property>
+                <child>
+                  <object class="GtkAlignment" id="alignment19">
+                    <property name="visible">True</property>
+                    <property name="top_padding">3</property>
+                    <property name="left_padding">3</property>
+                    <child>
+                      <object class="GtkVBox" id="vbox9">
+                        <property name="visible">True</property>
+                        <property name="spacing">9</property>
+                        <child>
+                          <object class="GtkVBox" id="vbox11">
+                            <property name="visible">True</property>
+                            <child>
+                              <object class="GtkLabel" id="label18">
+                                <property name="visible">True</property>
+                                <property name="xalign">0</property>
+                                <property name="label" translatable="yes">&lt;b&gt;Video&lt;/b&gt;</property>
+                                <property name="use_markup">True</property>
+                              </object>
+                              <packing>
+                                <property name="expand">False</property>
+                                <property name="fill">False</property>
+                                <property name="position">0</property>
+                              </packing>
+                            </child>
+                            <child>
+                              <object class="GtkAlignment" id="alignment12">
+                                <property name="visible">True</property>
+                                <property name="top_padding">3</property>
+                                <property name="left_padding">12</property>
+                                <child>
+                                  <object class="GtkVBox" id="vbox7">
+                                    <property name="visible">True</property>
+                                    <property name="spacing">3</property>
+                                    <child>
+                                      <object class="GtkComboBox" id="comboboxVideo">
+                                        <property name="visible">True</property>
+                                        <property name="model">model1</property>
+                                        <child>
+                                          <object class="GtkCellRendererText" id="renderer1"/>
+                                          <attributes>
+                                            <attribute name="text">0</attribute>
+                                          </attributes>
+                                        </child>
+                                      </object>
+                                      <packing>
+                                        <property name="expand">False</property>
+                                        <property name="fill">False</property>
+                                        <property name="position">0</property>
+                                      </packing>
+                                    </child>
+                                    <child>
+                                      <object class="GtkButton" id="buttonConfV">
+                                        <property name="label" translatable="yes">Configure</property>
+                                        <property name="visible">True</property>
+                                        <property name="can_focus">True</property>
+                                        <property name="receives_default">False</property>
+                                        <property name="tooltip-text" translatable="yes">Configure video encoder</property>
+                                        <property name="use_underline">True</property>
+                                        <accelerator key="F3" signal="clicked"/>
+                                      </object>
+                                      <packing>
+                                        <property name="expand">False</property>
+                                        <property name="fill">False</property>
+                                        <property name="position">1</property>
+                                      </packing>
+                                    </child>
+                                    <child>
+                                      <object class="GtkButton" id="buttonFilters">
+                                        <property name="label" translatable="yes">Filters</property>
+                                        <property name="visible">True</property>
+                                        <property name="can_focus">True</property>
+                                        <property name="receives_default">False</property>
+                                        <property name="tooltip-text" translatable="yes">Video filters</property>
+                                        <property name="use_underline">True</property>
+                                        <accelerator key="F1" signal="clicked"/>
+                                      </object>
+                                      <packing>
+                                        <property name="expand">False</property>
+                                        <property name="fill">False</property>
+                                        <property name="position">2</property>
+                                      </packing>
+                                    </child>
+                                  </object>
+                                </child>
+                              </object>
+                              <packing>
+                                <property name="position">1</property>
+                              </packing>
+                            </child>
+                          </object>
+                          <packing>
+                            <property name="expand">False</property>
+                            <property name="fill">False</property>
+                            <property name="position">0</property>
+                          </packing>
+                        </child>
+                        <child>
+                          <object class="GtkVBox" id="vbox12">
+                            <property name="visible">True</property>
+                            <child>
+                              <object class="GtkLabel" id="label19">
+                                <property name="visible">True</property>
+                                <property name="xalign">0</property>
+                                <property name="label" translatable="yes">&lt;b&gt;Audio&lt;/b&gt;</property>
+                                <property name="use_markup">True</property>
+                              </object>
+                              <packing>
+                                <property name="expand">False</property>
+                                <property name="fill">False</property>
+                                <property name="position">0</property>
+                              </packing>
+                            </child>
+                            <child>
+                              <object class="GtkAlignment" id="alignment13">
+                                <property name="visible">True</property>
+                                <property name="top_padding">3</property>
+                                <property name="left_padding">12</property>
+                                <child>
+                                  <object class="GtkVBox" id="vbox8">
+                                    <property name="visible">True</property>
+                                    <property name="spacing">3</property>
+                                    <child>
+                                      <object class="GtkComboBox" id="comboboxAudio">
+                                        <property name="visible">True</property>
+                                        <property name="model">model2</property>
+                                        <child>
+                                          <object class="GtkCellRendererText" id="renderer2"/>
+                                          <attributes>
+                                            <attribute name="text">0</attribute>
+                                          </attributes>
+                                        </child>
+                                      </object>
+                                      <packing>
+                                        <property name="expand">False</property>
+                                        <property name="fill">False</property>
+                                        <property name="position">0</property>
+                                      </packing>
+                                    </child>
+                                    <child>
+                                      <object class="GtkButton" id="buttonConfA">
+                                        <property name="label" translatable="yes">Configure</property>
+                                        <property name="visible">True</property>
+                                        <property name="can_focus">True</property>
+                                        <property name="receives_default">False</property>
+                                        <property name="tooltip-text" translatable="yes">Configure audio encoder</property>
+                                        <property name="use_underline">True</property>
+                                        <accelerator key="F4" signal="clicked"/>
+                                      </object>
+                                      <packing>
+                                        <property name="expand">False</property>
+                                        <property name="fill">False</property>
+                                        <property name="position">1</property>
+                                      </packing>
+                                    </child>
+                                    <child>
+                                      <object class="GtkButton" id="buttonAudioFilter">
+                                        <property name="visible">True</property>
+                                        <property name="can_focus">True</property>
+                                        <property name="receives_default">False</property>
+                                        <property name="tooltip-text" translatable="yes">Audio filters</property>
+                                        <accelerator key="F2" signal="clicked"/>
+                                        <child>
+                                          <object class="GtkAlignment" id="alignment16">
+                                            <property name="visible">True</property>
+                                            <property name="xscale">0</property>
+                                            <property name="yscale">0</property>
+                                            <child>
+                                              <object class="GtkHBox" id="hbox18">
+                                                <property name="visible">True</property>
+                                                <property name="spacing">2</property>
+                                                <child>
+                                                  <object class="GtkLabel" id="label22">
+                                                    <property name="visible">True</property>
+                                                    <property name="label" translatable="yes">Filters</property>
+                                                    <property name="use_underline">True</property>
+                                                  </object>
+                                                  <packing>
+                                                    <property name="expand">False</property>
+                                                    <property name="fill">False</property>
+                                                    <property name="position">0</property>
+                                                  </packing>
+                                                </child>
+                                              </object>
+                                            </child>
+                                          </object>
+                                        </child>
+                                      </object>
+                                      <packing>
+                                        <property name="expand">False</property>
+                                        <property name="fill">False</property>
+                                        <property name="position">2</property>
+                                      </packing>
+                                    </child>
+                                    <child>
+                                      <object class="GtkHBox" id="hbox19">
+                                        <property name="visible">True</property>
+                                        <property name="spacing">6</property>
+                                        <child>
+                                          <object class="GtkCheckButton" id="CheckButtonTimeshift">
+                                            <property name="label" translatable="yes">Shift:</property>
+                                            <property name="visible">True</property>
+                                            <property name="can_focus">True</property>
+                                            <property name="receives_default">False</property>
+                                            <property name="tooltip-text" translatable="yes">Enable time shift</property>
+                                            <property name="use_underline">True</property>
+                                            <property name="draw_indicator">True</property>
+                                          </object>
+                                          <packing>
+                                            <property name="expand">False</property>
+                                            <property name="fill">False</property>
+                                            <property name="position">0</property>
+                                          </packing>
+                                        </child>
+                                        <child>
+                                          <object class="GtkSpinButton" id="spinbuttonTimeShift">
+                                            <property name="visible">True</property>
+                                            <property name="can_focus">True</property>
+                                            <property name="tooltip-text" translatable="yes">Audio/video time shift (ms)</property>
+                                            <property name="adjustment">adjustment2</property>
+                                            <property name="climb_rate">1</property>
+                                            <property name="numeric">True</property>
+                                          </object>
+                                          <packing>
+                                            <property name="position">1</property>
+                                          </packing>
+                                        </child>
+                                      </object>
+                                      <packing>
+                                        <property name="position">3</property>
+                                      </packing>
+                                    </child>
+                                  </object>
+                                </child>
+                              </object>
+                              <packing>
+                                <property name="position">1</property>
+                              </packing>
+                            </child>
+                          </object>
+                          <packing>
+                            <property name="expand">False</property>
+                            <property name="fill">False</property>
+                            <property name="position">1</property>
+                          </packing>
+                        </child>
+                        <child>
+                          <object class="GtkVBox" id="vbox13">
+                            <property name="visible">True</property>
+                            <child>
+                              <object class="GtkLabel" id="label20">
+                                <property name="visible">True</property>
+                                <property name="xalign">0</property>
+                                <property name="label" translatable="yes">&lt;b&gt;Format&lt;/b&gt;</property>
+                                <property name="use_markup">True</property>
+                              </object>
+                              <packing>
+                                <property name="expand">False</property>
+                                <property name="fill">False</property>
+                                <property name="position">0</property>
+                              </packing>
+                            </child>
+                            <child>
+                              <object class="GtkAlignment" id="alignment1">
+                                <property name="visible">True</property>
+                                <property name="top_padding">3</property>
+                                <property name="left_padding">12</property>
+                                <child>
+                                  <object class="GtkVBox" id="vbox2">
+                                    <property name="visible">True</property>
+                                    <property name="spacing">3</property>
+                                    <child>
+                                      <object class="GtkComboBox" id="comboboxFormat">
+                                        <property name="visible">True</property>
+                                        <property name="model">model3</property>
+                                        <child>
+                                          <object class="GtkCellRendererText" id="renderer3"/>
+                                          <attributes>
+                                            <attribute name="text">0</attribute>
+                                          </attributes>
+                                        </child>
+                                      </object>
+                                      <packing>
+                                        <property name="expand">False</property>
+                                        <property name="fill">False</property>
+                                        <property name="position">0</property>
+                                      </packing>
+                                    </child>
+                                    <child>
+                                      <object class="GtkButton" id="buttonConfF">
+                                        <property name="label" translatable="yes">Configure</property>
+                                        <property name="visible">True</property>
+                                        <property name="can_focus">True</property>
+                                        <property name="receives_default">False</property>
+                                        <property name="tooltip-text" translatable="yes">Configure video encoder</property>
+                                        <property name="use_underline">True</property>
+                                        <accelerator key="F3" signal="clicked"/>
+                                      </object>
+                                      <packing>
+                                        <property name="expand">False</property>
+                                        <property name="fill">False</property>
+                                        <property name="position">1</property>
+                                      </packing>
+                                    </child>
+                                  </object>
+                                </child>
+                              </object>
+                              <packing>
+                                <property name="position">1</property>
+                              </packing>
+                            </child>
+                          </object>
+                          <packing>
+                            <property name="expand">False</property>
+                            <property name="fill">False</property>
+                            <property name="position">2</property>
+                          </packing>
+                        </child>
+                      </object>
+                    </child>
+                  </object>
+                  <packing>
+                    <property name="expand">False</property>
+                    <property name="fill">False</property>
+                    <property name="position">0</property>
+                  </packing>
+                </child>
+                <child>
+                  <object class="GtkDrawingArea" id="guiDrawing">
+                    <property name="width_request">496</property>
+                    <property name="height_request">288</property>
+                    <property name="visible">True</property>
+                    <property name="sensitive">False</property>
+                  </object>
+                  <packing>
+                    <property name="position">1</property>
+                  </packing>
+                </child>
+              </object>
+              <packing>
+                <property name="position">0</property>
+              </packing>
+            </child>
+            <child>
+              <object class="GtkTable" id="table2">
+                <property name="visible">True</property>
+                <property name="border_width">3</property>
+                <property name="n_rows">3</property>
+                <property name="n_columns">2</property>
+                <property name="column_spacing">6</property>
+                <child>
+                  <object class="Custom" id="jogg">
+                    <property name="visible">True</property>
+                    <property name="creation_function">jog_shuttle_new</property>
+                  </object>
+                  <packing>
+                    <property name="left_attach">1</property>
+                    <property name="right_attach">2</property>
+                    <property name="x_options">GTK_FILL</property>
+                    <property name="y_options">GTK_EXPAND</property>
+                  </packing>
+                </child>
+                <child>
+                  <object class="GtkVBox" id="vbox14">
+                    <property name="visible">True</property>
+                    <child>
+                      <object class="GtkLabel" id="label21">
+                        <property name="visible">True</property>
+                        <property name="xalign">0</property>
+                        <property name="label" translatable="yes">&lt;b&gt;Selection&lt;/b&gt;</property>
+                        <property name="use_markup">True</property>
+                      </object>
+                      <packing>
+                        <property name="expand">False</property>
+                        <property name="fill">False</property>
+                        <property name="position">0</property>
+                      </packing>
+                    </child>
+                    <child>
+                      <object class="GtkAlignment" id="alignment15">
+                        <property name="visible">True</property>
+                        <property name="top_padding">3</property>
+                        <property name="left_padding">12</property>
+                        <child>
+                          <object class="GtkTable" id="table1">
+                            <property name="visible">True</property>
+                            <property name="n_rows">2</property>
+                            <property name="n_columns">2</property>
+                            <property name="column_spacing">3</property>
+                            <property name="row_spacing">3</property>
+                            <child>
+                              <object class="GtkLabel" id="labelMarkA">
+                                <property name="visible">True</property>
+                                <property name="can_focus">True</property>
+                                <property name="label" translatable="yes"> 0000000</property>
+                                <property name="selectable">True</property>
+                              </object>
+                              <packing>
+                                <property name="left_attach">1</property>
+                                <property name="right_attach">2</property>
+                                <property name="x_options"/>
+                                <property name="y_options"/>
+                              </packing>
+                            </child>
+                            <child>
+                              <object class="GtkLabel" id="labelMarkB">
+                                <property name="visible">True</property>
+                                <property name="can_focus">True</property>
+                                <property name="label" translatable="yes"> 0000000</property>
+                                <property name="selectable">True</property>
+                              </object>
+                              <packing>
+                                <property name="left_attach">1</property>
+                                <property name="right_attach">2</property>
+                                <property name="top_attach">1</property>
+                                <property name="bottom_attach">2</property>
+                                <property name="x_options"/>
+                                <property name="y_options"/>
+                              </packing>
+                            </child>
+                            <child>
+                              <object class="GtkButton" id="buttonGotoA">
+                                <property name="label" translatable="yes">A:</property>
+                                <property name="height_request">20</property>
+                                <property name="visible">True</property>
+                                <property name="can_focus">False</property>
+                                <property name="receives_default">False</property>
+                                <property name="tooltip-text" translatable="yes">Go to marker A</property>
+                                <property name="use_underline">True</property>
+                              </object>
+                              <packing>
+                                <property name="x_options"/>
+                                <property name="y_options"/>
+                              </packing>
+                            </child>
+                            <child>
+                              <object class="GtkButton" id="buttonGotoB">
+                                <property name="label" translatable="yes">B:</property>
+                                <property name="height_request">20</property>
+                                <property name="visible">True</property>
+                                <property name="can_focus">False</property>
+                                <property name="receives_default">False</property>
+                                <property name="tooltip-text" translatable="yes">Go to marker B</property>
+                                <property name="use_underline">True</property>
+                              </object>
+                              <packing>
+                                <property name="top_attach">1</property>
+                                <property name="bottom_attach">2</property>
+                                <property name="x_options"/>
+                                <property name="y_options"/>
+                              </packing>
+                            </child>
+                          </object>
+                        </child>
+                      </object>
+                      <packing>
+                        <property name="position">1</property>
+                      </packing>
+                    </child>
+                  </object>
+                  <packing>
+                    <property name="left_attach">1</property>
+                    <property name="right_attach">2</property>
+                    <property name="top_attach">1</property>
+                    <property name="bottom_attach">3</property>
+                    <property name="x_options"/>
+                    <property name="y_options"/>
+                  </packing>
+                </child>
+                <child>
+                  <object class="GtkHBox" id="hbox10">
+                    <property name="visible">True</property>
+                    <child>
+                      <object class="GtkButton" id="buttonPlay">
+                        <property name="visible">True</property>
+                        <property name="can_focus">False</property>
+                        <property name="receives_default">False</property>
+                        <property name="tooltip-text" translatable="yes">Play</property>
+                        <property name="relief">none</property>
+                        <property name="focus_on_click">False</property>
+                        <accelerator key="space" signal="clicked"/>
+                        <child>
+                          <object class="GtkImage" id="image591">
+                            <property name="visible">True</property>
+                            <property name="pixbuf">play.png</property>
+                          </object>
+                        </child>
+                      </object>
+                      <packing>
+                        <property name="expand">False</property>
+                        <property name="fill">False</property>
+                        <property name="position">0</property>
+                      </packing>
+                    </child>
+                    <child>
+                      <object class="GtkButton" id="buttonStop">
+                        <property name="visible">True</property>
+                        <property name="can_focus">True</property>
+                        <property name="receives_default">False</property>
+                        <property name="tooltip-text" translatable="yes">Stop</property>
+                        <property name="relief">none</property>
+                        <property name="focus_on_click">False</property>
+                        <child>
+                          <object class="GtkImage" id="image5056">
+                            <property name="visible">True</property>
+                            <property name="pixbuf">stop.png</property>
+                          </object>
+                        </child>
+                      </object>
+                      <packing>
+                        <property name="expand">False</property>
+                        <property name="fill">False</property>
+                        <property name="position">1</property>
+                      </packing>
+                    </child>
+                    <child>
+                      <object class="GtkButton" id="buttonPrevFrame">
+                        <property name="visible">True</property>
+                        <property name="can_focus">False</property>
+                        <property name="receives_default">False</property>
+                        <property name="tooltip-text" translatable="yes">Previous frame</property>
+                        <property name="relief">none</property>
+                        <property name="focus_on_click">False</property>
+                        <accelerator key="KP_4" signal="clicked"/>
+                        <child>
+                          <object class="GtkImage" id="image593">
+                            <property name="visible">True</property>
+                            <property name="pixbuf">previous-frame.png</property>
+                          </object>
+                        </child>
+                      </object>
+                      <packing>
+                        <property name="expand">False</property>
+                        <property name="fill">False</property>
+                        <property name="position">2</property>
+                      </packing>
+                    </child>
+                    <child>
+                      <object class="GtkButton" id="buttonNextFrame">
+                        <property name="visible">True</property>
+                        <property name="can_focus">False</property>
+                        <property name="receives_default">False</property>
+                        <property name="tooltip-text" translatable="yes">Next frame</property>
+                        <property name="relief">none</property>
+                        <property name="focus_on_click">False</property>
+                        <accelerator key="KP_6" signal="clicked"/>
+                        <child>
+                          <object class="GtkImage" id="image594">
+                            <property name="visible">True</property>
+                            <property name="pixbuf">next-frame.png</property>
+                          </object>
+                        </child>
+                      </object>
+                      <packing>
+                        <property name="expand">False</property>
+                        <property name="fill">False</property>
+                        <property name="position">3</property>
+                      </packing>
+                    </child>
+                    <child>
+                      <object class="GtkButton" id="buttonPrevKFrame">
+                        <property name="visible">True</property>
+                        <property name="can_focus">False</property>
+                        <property name="receives_default">False</property>
+                        <property name="tooltip-text" translatable="yes">Previous keyframe</property>
+                        <property name="relief">none</property>
+                        <property name="focus_on_click">False</property>
+                        <accelerator key="KP_2" signal="clicked"/>
+                        <child>
+                          <object class="GtkImage" id="image595">
+                            <property name="visible">True</property>
+                            <property name="pixbuf">previous-key-frame.png</property>
+                          </object>
+                        </child>
+                      </object>
+                      <packing>
+                        <property name="expand">False</property>
+                        <property name="fill">False</property>
+                        <property name="position">4</property>
+                      </packing>
+                    </child>
+                    <child>
+                      <object class="GtkButton" id="buttonNextKFrame">
+                        <property name="visible">True</property>
+                        <property name="can_focus">False</property>
+                        <property name="receives_default">False</property>
+                        <property name="tooltip-text" translatable="yes">Next keyframe</property>
+                        <property name="relief">none</property>
+                        <property name="focus_on_click">False</property>
+                        <accelerator key="KP_8" signal="clicked"/>
+                        <child>
+                          <object class="GtkImage" id="image596">
+                            <property name="visible">True</property>
+                            <property name="pixbuf">next-key-frame.png</property>
+                          </object>
+                        </child>
+                      </object>
+                      <packing>
+                        <property name="expand">False</property>
+                        <property name="fill">False</property>
+                        <property name="position">5</property>
+                      </packing>
+                    </child>
+                    <child>
+                      <object class="GtkButton" id="buttonMarkA">
+                        <property name="visible">True</property>
+                        <property name="can_focus">True</property>
+                        <property name="receives_default">False</property>
+                        <property name="tooltip-text" translatable="yes">Selection: start</property>
+                        <property name="relief">none</property>
+                        <property name="focus_on_click">False</property>
+                        <child>
+                          <object class="GtkImage" id="image2306">
+                            <property name="visible">True</property>
+                            <property name="pixbuf">markA.png</property>
+                          </object>
+                        </child>
+                      </object>
+                      <packing>
+                        <property name="expand">False</property>
+                        <property name="fill">False</property>
+                        <property name="position">6</property>
+                      </packing>
+                    </child>
+                    <child>
+                      <object class="GtkButton" id="buttonMarkB">
+                        <property name="visible">True</property>
+                        <property name="can_focus">True</property>
+                        <property name="receives_default">False</property>
+                        <property name="tooltip-text" translatable="yes">Selection: end</property>
+                        <property name="relief">none</property>
+                        <property name="focus_on_click">False</property>
+                        <child>
+                          <object class="GtkImage" id="image2307">
+                            <property name="visible">True</property>
+                            <property name="pixbuf">markB.png</property>
+                          </object>
+                        </child>
+                      </object>
+                      <packing>
+                        <property name="expand">False</property>
+                        <property name="fill">False</property>
+                        <property name="position">7</property>
+                      </packing>
+                    </child>
+                    <child>
+                      <object class="GtkButton" id="buttonPrevBlack">
+                        <property name="visible">True</property>
+                        <property name="can_focus">True</property>
+                        <property name="receives_default">False</property>
+                        <property name="tooltip-text" translatable="yes">Previous black frame</property>
+                        <property name="relief">none</property>
+                        <property name="focus_on_click">False</property>
+                        <child>
+                          <object class="GtkImage" id="image2308">
+                            <property name="visible">True</property>
+                            <property name="pixbuf">previous-black-frame.png</property>
+                          </object>
+                        </child>
+                      </object>
+                      <packing>
+                        <property name="expand">False</property>
+                        <property name="fill">False</property>
+                        <property name="position">8</property>
+                      </packing>
+                    </child>
+                    <child>
+                      <object class="GtkButton" id="buttonNextBlack">
+                        <property name="visible">True</property>
+                        <property name="can_focus">True</property>
+                        <property name="receives_default">False</property>
+                        <property name="tooltip-text" translatable="yes">Next black frame</property>
+                        <property name="relief">none</property>
+                        <property name="focus_on_click">False</property>
+                        <child>
+                          <object class="GtkImage" id="image2309">
+                            <property name="visible">True</property>
+                            <property name="pixbuf">next-black-frame.png</property>
+                          </object>
+                        </child>
+                      </object>
+                      <packing>
+                        <property name="expand">False</property>
+                        <property name="fill">False</property>
+                        <property name="position">9</property>
+                      </packing>
+                    </child>
+                    <child>
+                      <object class="GtkButton" id="buttonBegin">
+                        <property name="visible">True</property>
+                        <property name="can_focus">True</property>
+                        <property name="receives_default">False</property>
+                        <property name="tooltip-text" translatable="yes">First frame</property>
+                        <property name="relief">none</property>
+                        <property name="focus_on_click">False</property>
+                        <child>
+                          <object class="GtkImage" id="image5057">
+                            <property name="visible">True</property>
+                            <property name="pixbuf">first-frame.png</property>
+                          </object>
+                        </child>
+                      </object>
+                      <packing>
+                        <property name="expand">False</property>
+                        <property name="fill">False</property>
+                        <property name="position">10</property>
+                      </packing>
+                    </child>
+                    <child>
+                      <object class="GtkButton" id="buttonEnd">
+                        <property name="visible">True</property>
+                        <property name="can_focus">True</property>
+                        <property name="receives_default">False</property>
+                        <property name="tooltip-text" translatable="yes">Last frame</property>
+                        <property name="relief">none</property>
+                        <property name="focus_on_click">False</property>
+                        <child>
+                          <object class="GtkImage" id="image2245">
+                            <property name="visible">True</property>
+                            <property name="pixbuf">last-frame.png</property>
+                          </object>
+                        </child>
+                      </object>
+                      <packing>
+                        <property name="expand">False</property>
+                        <property name="fill">False</property>
+                        <property name="position">11</property>
+                      </packing>
+                    </child>
+                  </object>
+                  <packing>
+                    <property name="top_attach">1</property>
+                    <property name="bottom_attach">2</property>
+                  </packing>
+                </child>
+                <child>
+                  <object class="GtkHScale" id="sliderNavigate">
+                    <property name="visible">True</property>
+                    <property name="adjustment">adjustment3</property>
+                    <property name="value_pos">left</property>
+                  </object>
+                </child>
+                <child>
+                  <object class="GtkHBox" id="hbox16">
+                    <property name="visible">True</property>
+                    <property name="spacing">6</property>
+                    <child>
+                      <object class="GtkLabel" id="label1">
+                        <property name="visible">True</property>
+                        <property name="label" translatable="yes">Frame: </property>
+                      </object>
+                      <packing>
+                        <property name="expand">False</property>
+                        <property name="fill">False</property>
+                        <property name="position">0</property>
+                      </packing>
+                    </child>
+                    <child>
+                      <object class="GtkEntry" id="boxCurFrame">
+                        <property name="visible">True</property>
+                        <property name="can_focus">True</property>
+                        <property name="tooltip-text" translatable="yes">Current frame</property>
+                        <property name="max_length">8</property>
+                        <property name="width_chars">8</property>
+                        <property name="text" translatable="yes">0</property>
+                      </object>
+                      <packing>
+                        <property name="expand">False</property>
+                        <property name="fill">False</property>
+                        <property name="position">1</property>
+                      </packing>
+                    </child>
+                    <child>
+                      <object class="GtkLabel" id="labelTotalFrame">
+                        <property name="visible">True</property>
+                        <property name="can_focus">True</property>
+                        <property name="xpad">5</property>
+                        <property name="label" translatable="yes">/ 0000000</property>
+                        <property name="selectable">True</property>
+                      </object>
+                      <packing>
+                        <property name="expand">False</property>
+                        <property name="fill">False</property>
+                        <property name="position">2</property>
+                      </packing>
+                    </child>
+                    <child>
+                      <object class="GtkLabel" id="label4">
+                        <property name="visible">True</property>
+                        <property name="label" translatable="yes">Time: </property>
+                      </object>
+                      <packing>
+                        <property name="expand">False</property>
+                        <property name="fill">False</property>
+                        <property name="position">3</property>
+                      </packing>
+                    </child>
+                    <child>
+                      <object class="GtkEntry" id="boxCurTime">
+                        <property name="visible">True</property>
+                        <property name="can_focus">True</property>
+                        <property name="tooltip-text" translatable="yes">Current time</property>
+                        <property name="width_chars">13</property>
+                        <property name="text" translatable="yes">00:00:00.000</property>
+                      </object>
+                      <packing>
+                        <property name="expand">False</property>
+                        <property name="fill">False</property>
+                        <property name="position">4</property>
+                      </packing>
+                    </child>
+                    <child>
+                      <object class="GtkLabel" id="labelTotalTime">
+                        <property name="visible">True</property>
+                        <property name="can_focus">True</property>
+                        <property name="xpad">5</property>
+                        <property name="label" translatable="yes">/ 00:00:00,000</property>
+                        <property name="selectable">True</property>
+                      </object>
+                      <packing>
+                        <property name="expand">False</property>
+                        <property name="fill">False</property>
+                        <property name="position">5</property>
+                      </packing>
+                    </child>
+                    <child>
+                      <object class="GtkLabel" id="labelFrameType">
+                        <property name="visible">True</property>
+                        <property name="can_focus">True</property>
+                        <property name="label" translatable="yes">Frame: ?</property>
+                        <property name="selectable">True</property>
+                      </object>
+                      <packing>
+                        <property name="expand">False</property>
+                        <property name="fill">False</property>
+                        <property name="position">6</property>
+                      </packing>
+                    </child>
+                  </object>
+                  <packing>
+                    <property name="top_attach">2</property>
+                    <property name="bottom_attach">3</property>
+                    <property name="y_options"/>
+                  </packing>
+                </child>
+              </object>
+              <packing>
+                <property name="expand">False</property>
+                <property name="fill">False</property>
+                <property name="position">1</property>
+              </packing>
+            </child>
+          </object>
+          <packing>
+            <property name="position">2</property>
+          </packing>
+        </child>
+      </object>
+    </child>
+  </object>
+</interface>



From mean at mail.berlios.de  Fri Oct  2 07:22:21 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 2 Oct 2009 07:22:21 +0200
Subject: [Avidemux-svn-commit] r5367 - in
	branches/avidemux_2.6_branch_mean/avidemux/gtk: .
	ADM_userInterfaces/ADM_gui2 ADM_userInterfaces/glade/main
Message-ID: <200910020522.n925MLu5031004@sheep.berlios.de>

Author: mean
Date: 2009-10-02 07:22:20 +0200 (Fri, 02 Oct 2009)
New Revision: 5367

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_gui2/GUI_bindings.cpp
   branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_gui2/GUI_glade.cpp
   branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_gui2/GUI_glade.h
   branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/glade/main/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/glade/main/gtk2_build.gtkBuilder
   branches/avidemux_2.6_branch_mean/avidemux/gtk/CMakeLists.txt
Log:
[GTK] Switch from libflade to gtkbuilder for main menu

Modified: branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_gui2/GUI_bindings.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_gui2/GUI_bindings.cpp	2009-10-02 05:22:17 UTC (rev 5366)
+++ branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_gui2/GUI_bindings.cpp	2009-10-02 05:22:20 UTC (rev 5367)
@@ -309,7 +309,8 @@
 {
 uint8_t ret=0;
 uint32_t w,h;
-        if(!glade.loadFile("main/gtk2_build.glade"))
+        glade.init();
+        if(!glade.loadFile("main/gtk2_build.gtkBuilder"))
         {
             GUI_Error_HIG("Glade","Cannot load glade file");
             ADM_assert(0);
@@ -1428,6 +1429,7 @@
 
     ADM_renderLibInit(&UI_Hooks);
 
+    printf("[Gtk] Entering gtk_init\n");
     gtk_init(&global_argc, &global_argv);
     gdk_rgb_init();
 
@@ -1448,6 +1450,7 @@
     // Install our crash handler
     ADM_setCrashHook(&saveCrashProject, &gtk_fatalFunction);
     checkCrashFile();
+    printf("[Gtk] Entering gtk_main\n");
     gtk_main();
     gdk_threads_leave();
 

Modified: branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_gui2/GUI_glade.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_gui2/GUI_glade.cpp	2009-10-02 05:22:17 UTC (rev 5366)
+++ branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_gui2/GUI_glade.cpp	2009-10-02 05:22:20 UTC (rev 5367)
@@ -2,9 +2,27 @@
  *      \file GUI_glade.cpp
  *      \brief simple utility class to deal with glade class
  */
+#include <stdlib.h>
+#include "GUI_glade.h"
+#define GXML (GtkBuilder *)gxml
 
-#include "GUI_glade.h"
-#define GXML (GladeXML *)gxml
+admGlade::admGlade()
+{
+    gxml=NULL;
+}
+void admGlade::init(void)
+{
+GtkBuilder *x=NULL;
+    x =gtk_builder_new ();
+    if(!x)
+    {
+        printf("[GtkBuilder] Cannot create a builder\n");
+        exit(-1);
+    }
+    gxml=(void *)x; // Memleak!
+
+}
+
 /**
  *
  */
@@ -31,13 +49,17 @@
 {
 #define ADM_GLADE_PATH 1024
 char path[ADM_GLADE_PATH];
-            GladeXML *x;
+GError *er=NULL;
+            GtkBuilder *x;
             snprintf(path,ADM_GLADE_PATH,"%s/%s",prefix,file);
             printf("Trying :<%s>\n",path);
-            x = glade_xml_new (path, NULL, NULL);
-            if(!x) return false;
-            gxml=(void *)x;
-           // glade_xml_signal_autoconnect (x);
+           
+            gtk_builder_add_from_file(GXML,path,&er);
+            if(er)
+            {
+                printf("[GtkBuilder] %s\n",er->message);
+                return false;
+            }
             return true;
 
 
@@ -49,7 +71,7 @@
 GtkWidget *admGlade::getWidget(const char *widgetName)
 {
         if(!gxml) return NULL;
-        GtkWidget *w= glade_xml_get_widget (GXML, widgetName);
+        GtkWidget *w= (GtkWidget *)gtk_builder_get_object (GXML, widgetName);
         if(!w) printf("[admGlade] Cannot locate widget %s\n",widgetName);
         return w;
 }   

Modified: branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_gui2/GUI_glade.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_gui2/GUI_glade.h	2009-10-02 05:22:17 UTC (rev 5366)
+++ branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_gui2/GUI_glade.h	2009-10-02 05:22:20 UTC (rev 5367)
@@ -16,7 +16,8 @@
         void *gxml;
         bool tryLoad(const char *prefix, const char *file);
 public:
-                admGlade() {gxml=NULL;}
+                admGlade() ;
+        void    init(void);
                 ~admGlade();
         bool    loadFile(const char *file);   
         GtkWidget *getWidget(const char *widgetName);

Modified: branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/glade/main/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/glade/main/CMakeLists.txt	2009-10-02 05:22:17 UTC (rev 5366)
+++ branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/glade/main/CMakeLists.txt	2009-10-02 05:22:20 UTC (rev 5367)
@@ -1,5 +1,6 @@
 # Install glade file into FOO/lib/ADM_glade/
 set(ADM_glade
+gtk2_build.gtkBuilder
 gtk2_build.glade
 avidemux_icon_small.png
 audio-volume-medium.png

Modified: branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/glade/main/gtk2_build.gtkBuilder
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/glade/main/gtk2_build.gtkBuilder	2009-10-02 05:22:17 UTC (rev 5366)
+++ branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/glade/main/gtk2_build.gtkBuilder	2009-10-02 05:22:20 UTC (rev 5367)
@@ -595,12 +595,6 @@
           <accelerator key="T" modifiers="GDK_CONTROL_MASK"/>
         </child>
         <child>
-          <object class="GtkAction" id="custom1">
-            <property name="name">custom1</property>
-            <property name="label" translatable="yes">_Custom</property>
-          </object>
-        </child>
-        <child>
           <object class="GtkAction" id="help2">
             <property name="name">help2</property>
             <property name="label" translatable="yes">_Help</property>
@@ -1263,18 +1257,6 @@
                 <property name="n_columns">2</property>
                 <property name="column_spacing">6</property>
                 <child>
-                  <object class="Custom" id="jogg">
-                    <property name="visible">True</property>
-                    <property name="creation_function">jog_shuttle_new</property>
-                  </object>
-                  <packing>
-                    <property name="left_attach">1</property>
-                    <property name="right_attach">2</property>
-                    <property name="x_options">GTK_FILL</property>
-                    <property name="y_options">GTK_EXPAND</property>
-                  </packing>
-                </child>
-                <child>
                   <object class="GtkVBox" id="vbox14">
                     <property name="visible">True</property>
                     <child>

Modified: branches/avidemux_2.6_branch_mean/avidemux/gtk/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/gtk/CMakeLists.txt	2009-10-02 05:22:17 UTC (rev 5366)
+++ branches/avidemux_2.6_branch_mean/avidemux/gtk/CMakeLists.txt	2009-10-02 05:22:20 UTC (rev 5367)
@@ -13,10 +13,10 @@
 
 include(../commonCmakeApplication.cmake)
 include(admCheckGtk)
-include(admCheckGlade)
+#include(admCheckGlade)
 #
 checkGtk()
-checkGlade()
+#checkGlade()
 ##########################################
 # Config
 ##########################################



From mean at mail.berlios.de  Fri Oct  2 07:22:24 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 2 Oct 2009 07:22:24 +0200
Subject: [Avidemux-svn-commit] r5368 - in branches/avidemux_2.6_branch_mean:
	avidemux/qt4 avidemux/qt4/ADM_userInterfaces/ADM_dialog
	avidemux/qt4/ADM_userInterfaces/ADM_filters
	avidemux/qt4/ADM_userInterfaces/ADM_gui
	avidemux_core/ADM_core/include
Message-ID: <200910020522.n925MOZm031177@sheep.berlios.de>

Author: mean
Date: 2009-10-02 07:22:23 +0200 (Fri, 02 Oct 2009)
New Revision: 5368

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/Q_license.cpp
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/Q_vobsub.cpp
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/Q_vobsub.h
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/alert_qt4.cpp
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/Q_mainfilter.cpp
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/Q_mainfilter.h
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/ADM_qslider.cpp
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/ADM_qslider.h
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_gui2.cpp
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/gui_none.cpp
   branches/avidemux_2.6_branch_mean/avidemux/qt4/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/include/ADM_misc.h
Log:
[Qt4] Fix Qt4 build

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/Q_license.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/Q_license.cpp	2009-10-02 05:22:20 UTC (rev 5367)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/Q_license.cpp	2009-10-02 05:22:23 UTC (rev 5368)
@@ -14,7 +14,7 @@
  *   (at your option) any later version.                                   *
  *                                                                         *
  ***************************************************************************/
-
+#include "ADM_inttype.h"
 #include "Q_license.h"
 
 Ui_licenseWindow::Ui_licenseWindow()

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/Q_vobsub.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/Q_vobsub.cpp	2009-10-02 05:22:20 UTC (rev 5367)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/Q_vobsub.cpp	2009-10-02 05:22:23 UTC (rev 5368)
@@ -18,7 +18,7 @@
 
 #include "Q_vobsub.h"
 #include "DIA_fileSel.h"
-
+#if 0
 //
 //	Video is in YV12 Colorspace
 //
@@ -112,3 +112,4 @@
 // EOF
 
 
+#endif
\ No newline at end of file

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/Q_vobsub.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/Q_vobsub.h	2009-10-02 05:22:20 UTC (rev 5367)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/Q_vobsub.h	2009-10-02 05:22:23 UTC (rev 5368)
@@ -1,6 +1,6 @@
 #ifndef Q_vobsub_h
 #define Q_vobsub_h
-
+#if 0
 #include "ui_vobsub.h"
 #include "ADM_image.h"
 #include "ADM_videoFilter.h"
@@ -26,3 +26,4 @@
 	void idxSel(bool i);
 };
 #endif	// Q_vobsub_h
+#endif
\ No newline at end of file

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/alert_qt4.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/alert_qt4.cpp	2009-10-02 05:22:20 UTC (rev 5367)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/alert_qt4.cpp	2009-10-02 05:22:23 UTC (rev 5368)
@@ -12,7 +12,7 @@
  *   (at your option) any later version.                                   *
  *                                                                         *
  ***************************************************************************/
-
+#include "ADM_inttype.h"
 #include <QtGui/QDialog>
 #include <QtGui/QMessageBox>
 #include "DIA_coreToolkit.h"

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/Q_mainfilter.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/Q_mainfilter.cpp	2009-10-02 05:22:20 UTC (rev 5367)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/Q_mainfilter.cpp	2009-10-02 05:22:23 UTC (rev 5368)
@@ -23,7 +23,7 @@
  *                                                                         *
  ***************************************************************************/
 
-#include "config.h"
+
 #include <vector>
 
 #include "Q_mainfilter.h"
@@ -39,8 +39,8 @@
 #include "ADM_editor/ADM_edit.hxx"
 #include "ADM_videoFilter.h"
 #include "ADM_videoFilter_internal.h"
-#include "ADM_video/ADM_vidPartial.h"
-#include "ADM_filter/vidVCD.h"
+//#include "ADM_video/ADM_vidPartial.h"
+//#include "ADM_filter/vidVCD.h"
 #include "DIA_factory.h"
 /*******************************************************/
 #define NB_TREE 8
@@ -418,6 +418,7 @@
 */
 void filtermainWindow::partial( bool b)
 {
+#if 0
   printf("partial\n"); 
    QListWidgetItem *item=activeList->currentItem();
    if(!item)
@@ -460,6 +461,7 @@
 			setSelected(itag);
         }
         else delete replace;
+#endif
 }
 /**
         \fn setup
@@ -576,9 +578,10 @@
     \brief Partial dialog
     
 */
-
+#if 0
 uint8_t DIA_getPartial(PARTIAL_CONFIG *param,AVDMGenericVideoStream *son,AVDMGenericVideoStream *previous)
 {
+
 #define PX(x) &(param->x)
   void *params[2]={son,previous};
          uint32_t fmax=previous->getInfo()->nb_frames;
@@ -590,6 +593,9 @@
          
          diaElem *tabs[]={&start,&end,&button};
         return diaFactoryRun(QT_TR_NOOP("Partial Video Filter"),3,tabs);
+
+    
 }
+#endif
 //EOF
 

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/Q_mainfilter.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/Q_mainfilter.h	2009-10-02 05:22:20 UTC (rev 5367)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_filters/Q_mainfilter.h	2009-10-02 05:22:23 UTC (rev 5368)
@@ -3,7 +3,7 @@
 
 #include <QtGui/QItemDelegate>
 #include "ui_mainfilter.h"
-
+#include "ADM_inttype.h"
 class FilterItemEventFilter : public QObject
 {
 	Q_OBJECT

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/ADM_qslider.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/ADM_qslider.cpp	2009-10-02 05:22:20 UTC (rev 5367)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/ADM_qslider.cpp	2009-10-02 05:22:23 UTC (rev 5368)
@@ -13,7 +13,7 @@
 ***************************************************************************/
 #include <stdio.h>
 #include <stdlib.h>
-
+#include "ADM_inttype.h"
 #include <QtGui/QPainter>
 #include <QtGui/QSlider>
 #include "ADM_qslider.h"

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/ADM_qslider.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/ADM_qslider.h	2009-10-02 05:22:20 UTC (rev 5367)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/ADM_qslider.h	2009-10-02 05:22:23 UTC (rev 5368)
@@ -1,6 +1,6 @@
 #ifndef ADM_Q_SLIDER_H
 #define ADM_Q_SLIDER_H
-
+#include "ADM_inttype.h"
 class ADM_QSlider : public QSlider
 {
 protected:

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_gui2.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_gui2.cpp	2009-10-02 05:22:20 UTC (rev 5367)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_gui2.cpp	2009-10-02 05:22:23 UTC (rev 5368)
@@ -12,7 +12,7 @@
  *                                                                         *
  ***************************************************************************/
 #include "config.h"
-
+#include "ADM_inttype.h"
 #include <QtCore/QFileInfo>
 #include <QtCore/QUrl>
 #include <QtGui/QKeyEvent>

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/gui_none.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/gui_none.cpp	2009-10-02 05:22:20 UTC (rev 5367)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/gui_none.cpp	2009-10-02 05:22:23 UTC (rev 5368)
@@ -9,7 +9,7 @@
 //
 
 #include "config.h"
-
+#include "ADM_inttype.h"
 #include <QtGui/QApplication>
 #include <QtGui/QDesktopWidget>
 

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/CMakeLists.txt	2009-10-02 05:22:20 UTC (rev 5367)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/CMakeLists.txt	2009-10-02 05:22:23 UTC (rev 5368)
@@ -61,7 +61,7 @@
 FOREACH (_libName ${commonLibs2})
         TARGET_LINK_LIBRARIES(avidemux3_qt4 ${_libName})
 ENDFOREACH (_libName ${commonLibs})
-TARGET_LINK_LIBRARIES(avidemux3_qt4 ADM_filter6)
+#TARGET_LINK_LIBRARIES(avidemux3_qt4 ADM_filter6)
 #############################################
 # Add qt specific libs
 #############################################

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/include/ADM_misc.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/include/ADM_misc.h	2009-10-02 05:22:20 UTC (rev 5367)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/include/ADM_misc.h	2009-10-02 05:22:23 UTC (rev 5368)
@@ -10,8 +10,8 @@
 #define ADM_MISC_H
 
 #include "ADM_coreConfig.h"
+#include "ADM_inttype.h"
 
-
 typedef struct 
 {
   uint32_t hours,minutes,seconds; 



From gruntster at mail.berlios.de  Mon Oct  5 09:57:20 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Mon, 5 Oct 2009 09:57:20 +0200
Subject: [Avidemux-svn-commit] r5369 - in
	branches/avidemux_2.5_branch_gruntster/platforms/windows:
	build_scripts/avidemux installer
Message-ID: <200910050757.n957vKi6014250@sheep.berlios.de>

Author: gruntster
Date: 2009-10-05 09:56:44 +0200 (Mon, 05 Oct 2009)
New Revision: 5369

Modified:
   branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/avidemux/Package Notes.xml
   branches/avidemux_2.5_branch_gruntster/platforms/windows/installer/avidemux.nsi
Log:
[win32] update installer to support latest dependencies

Modified: branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/avidemux/Package Notes.xml
===================================================================
--- branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/avidemux/Package Notes.xml	2009-10-02 05:22:23 UTC (rev 5368)
+++ branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/avidemux/Package Notes.xml	2009-10-05 07:56:44 UTC (rev 5369)
@@ -1,5 +1,8 @@
 <?xml version="1.0"?>
 <log>
+  <buildentry revision="5341" date="2009-09-17">
+    <comment>Updated x264 to r1259.</comment>
+  </buildentry>
   <buildentry revision="5327" date="2009-09-09">
     <comment>Updated x264 to r1251.</comment>
   </buildentry>
@@ -36,7 +39,7 @@
     <comment>Updated x264 to r1185.</comment>
   </buildentry>
   <buildentry revision="5104" date="2009-07-17">
-    <comment>Added opencore-amr 0.1.1.</comment>
+    <comment>Added opencore-amr version 0.1.1.</comment>
     <comment>Updated x264 to r1183.</comment>
   </buildentry>
   <buildentry revision="5087" date="2009-07-13">

Modified: branches/avidemux_2.5_branch_gruntster/platforms/windows/installer/avidemux.nsi
===================================================================
--- branches/avidemux_2.5_branch_gruntster/platforms/windows/installer/avidemux.nsi	2009-10-02 05:22:23 UTC (rev 5368)
+++ branches/avidemux_2.5_branch_gruntster/platforms/windows/installer/avidemux.nsi	2009-10-05 07:56:44 UTC (rev 5369)
@@ -264,22 +264,17 @@
     ${File} "Change Log.html"
     ${File} zlib1.dll
     ${File} freetype6.dll
-    ${File} iconv.dll
-    ${File} intl.dll
     ${File} libjs.dll
-    ${File} nspr4.dll
+    ${File} libnspr4.dll
     ${File} libADM_core.dll
     ${File} libADM_coreAudio.dll
     ${File} libADM_coreImage.dll
     ${File} libADM_coreUI.dll
     ${File} libaften.dll
-    ${File} libexpat-*.dll
-    ${File} libfontconfig-1.dll
-    ${File} libxml2.dll
+    ${File} libxml2-*.dll
     ${File} ogg.dll
     ${File} pthreadGC2.dll
     ${File} SDL.dll
-    ${File} xmltok.dll
     ${File} AUTHORS.
     ${File} COPYING.
     ${File} README.
@@ -290,8 +285,6 @@
     ${File} swscale-*.dll
     ${File} libgcc_sjlj_*.dll
     ${File} libstdc++_sjlj_*.dll
-    SetOutPath $INSTDIR\etc\fonts
-    ${Folder} etc\fonts
     SetOutPath $INSTDIR\scripts
     ${Folder} scripts
 SectionEnd
@@ -326,7 +319,7 @@
         SetOutPath $INSTDIR
         ${File} avidemux2_gtk.exe
         ${File} gtk2_prefs.exe
-        ${File} jpeg62.dll
+        ${File} intl.dll
         ${File} libADM_render_gtk.dll
         ${File} libADM_UIGtk.dll
         ${File} libatk-1.0-0.dll
@@ -343,7 +336,6 @@
         ${File} libpangocairo-1.0-0.dll
         ${File} libpangowin32-1.0-0.dll
         ${File} libpng12-0.dll
-        ${File} libtiff3.dll
     ${MementoSectionEnd}
 !endif
 
@@ -400,7 +392,7 @@
 			SetOutPath $INSTDIR\plugins\audioDecoder
 			${File} plugins\audioDecoder\libADM_ad_opencore_amrnb.dll
 			SetOutPath $INSTDIR
-			${File} libopencore-amrnb.dll
+			${File} libopencore-amrnb-*.dll
 		${MementoSectionEnd}
 		${MementoSection} "opencore-amrwb (AMR-WB)" SecAudDecOpencoreAmrWb
 			SectionIn 1 2
@@ -408,7 +400,7 @@
 			SetOutPath $INSTDIR\plugins\audioDecoder
 			${File} plugins\audioDecoder\libADM_ad_opencore_amrwb.dll
 			SetOutPath $INSTDIR
-			${File} libopencore-amrwb.dll
+			${File} libopencore-amrwb-*.dll
 		${MementoSectionEnd}
 	SectionGroupEnd
 	SectionGroup "Audio Devices" SecGrpAudioDevice
@@ -1056,6 +1048,10 @@
 				SetOverwrite on
 				SetOutPath $INSTDIR\plugins\videoFilter
 				${File} plugins\videoFilter\libADM_vf_ssa.dll
+				SetOutPath $INSTDIR
+				${File} libfontconfig-1.dll
+				SetOutPath $INSTDIR\etc\fonts
+				${Folder} etc\fonts
 			${MementoSectionEnd}
 			${MementoSection} "Subtitler" SecVidFltSubtitler
 				SectionIn 1 2



From mean at mail.berlios.de  Mon Oct  5 20:07:43 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Mon, 5 Oct 2009 20:07:43 +0200
Subject: [Avidemux-svn-commit] r5370 -
	branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Jack
Message-ID: <200910051807.n95I7hKo001034@sheep.berlios.de>

Author: mean
Date: 2009-10-05 20:07:42 +0200 (Mon, 05 Oct 2009)
New Revision: 5370

Modified:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Jack/ADM_deviceJack.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Jack/ADM_deviceJack.h
Log:
[Jack] Re-enable jack plugin

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Jack/ADM_deviceJack.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Jack/ADM_deviceJack.cpp	2009-10-05 07:56:44 UTC (rev 5369)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Jack/ADM_deviceJack.cpp	2009-10-05 18:07:42 UTC (rev 5370)
@@ -12,10 +12,10 @@
 
 #include "ADM_default.h"
 #include "ADM_audiodevice.h"
-#include "ADM_assert.h"
+#include  "ADM_audioDeviceInternal.h"
 #include "ADM_deviceJack.h"
+ADM_DECLARE_AUDIODEVICE(Jack,jackAudioDevice,1,0,0,"Jack audio device (c) mean");
 
-
 #define BUFSIZE 16385
 
 jackAudioDevice::jackAudioDevice()
@@ -53,7 +53,7 @@
 	return 1;
 }
 
-uint8_t jackAudioDevice::init(uint8_t channels, uint32_t fq)
+uint8_t jackAudioDevice::init(uint32_t channels, uint32_t fq)
 {
 	jack_status_t status;
 	_channels = channels;

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Jack/ADM_deviceJack.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Jack/ADM_deviceJack.h	2009-10-05 07:56:44 UTC (rev 5369)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Jack/ADM_deviceJack.h	2009-10-05 18:07:42 UTC (rev 5370)
@@ -20,9 +20,9 @@
 {
 public:
 	jackAudioDevice();
-	virtual uint8_t init(uint8_t channel,uint32_t fq);
-	virtual uint8_t play(uint32_t len, float *data);
-	virtual uint8_t stop();
+	virtual uint8_t init(uint32_t channel,uint32_t fq);
+	virtual uint8_t  play(uint32_t len, float *data);
+	virtual uint8_t  stop();
 	uint8_t setVolume(int volume);
 	int process(jack_nframes_t nframes);
 



From mean at mail.berlios.de  Mon Oct  5 20:07:50 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Mon, 5 Oct 2009 20:07:50 +0200
Subject: [Avidemux-svn-commit] r5371 -
	branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Jack
Message-ID: <200910051807.n95I7oDr001074@sheep.berlios.de>

Author: mean
Date: 2009-10-05 20:07:49 +0200 (Mon, 05 Oct 2009)
New Revision: 5371

Modified:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Jack/ADM_deviceJack.cpp
Log:
[Jack] Update author

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Jack/ADM_deviceJack.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Jack/ADM_deviceJack.cpp	2009-10-05 18:07:42 UTC (rev 5370)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Jack/ADM_deviceJack.cpp	2009-10-05 18:07:49 UTC (rev 5371)
@@ -14,7 +14,7 @@
 #include "ADM_audiodevice.h"
 #include  "ADM_audioDeviceInternal.h"
 #include "ADM_deviceJack.h"
-ADM_DECLARE_AUDIODEVICE(Jack,jackAudioDevice,1,0,0,"Jack audio device (c) mean");
+ADM_DECLARE_AUDIODEVICE(Jack,jackAudioDevice,1,0,0,"Jack audio device (c) M. Zenkov ");
 
 #define BUFSIZE 16385
 



From mean at mail.berlios.de  Sat Oct 10 11:40:08 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 10 Oct 2009 11:40:08 +0200
Subject: [Avidemux-svn-commit] r5372 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDevices/PulseAudioSimple
Message-ID: <200910100940.n9A9e8VQ004470@sheep.berlios.de>

Author: mean
Date: 2009-10-10 11:40:08 +0200 (Sat, 10 Oct 2009)
New Revision: 5372

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDevices/PulseAudioSimple/ADM_devicePulseSimple.cpp
Log:
[Pulse] Remove useless double include

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDevices/PulseAudioSimple/ADM_devicePulseSimple.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDevices/PulseAudioSimple/ADM_devicePulseSimple.cpp	2009-10-05 18:07:49 UTC (rev 5371)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDevices/PulseAudioSimple/ADM_devicePulseSimple.cpp	2009-10-10 09:40:08 UTC (rev 5372)
@@ -18,8 +18,6 @@
 #include "ADM_default.h"
 #include "ADM_audiodevice.h"
 
-
-#include  "ADM_audiodevice.h"
 #include  "ADM_audioDeviceInternal.h"
 #include  "ADM_devicePulseSimple.h"
 #include  "pulse/simple.h"



From mean at mail.berlios.de  Sat Oct 10 11:40:09 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 10 Oct 2009 11:40:09 +0200
Subject: [Avidemux-svn-commit] r5373 - in
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDevices:
	. Jack
Message-ID: <200910100940.n9A9e9Oj004480@sheep.berlios.de>

Author: mean
Date: 2009-10-10 11:40:09 +0200 (Sat, 10 Oct 2009)
New Revision: 5373

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDevices/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDevices/Jack/ADM_deviceJack.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDevices/Jack/ADM_deviceJack.h
Log:
[Jack] Re-enable Jack, now completely done

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDevices/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDevices/CMakeLists.txt	2009-10-10 09:40:08 UTC (rev 5372)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDevices/CMakeLists.txt	2009-10-10 09:40:09 UTC (rev 5373)
@@ -24,9 +24,9 @@
 #ADD_SUBDIRECTORY(Arts)
 #endif(USE_ARTS)
 
-#if(USE_JACK)
-#ADD_SUBDIRECTORY(Jack)
-#endif(USE_JACK)
+if(USE_JACK)
+ADD_SUBDIRECTORY(Jack)
+endif(USE_JACK)
 
 if(WIN32)
 ADD_SUBDIRECTORY(Win32)

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDevices/Jack/ADM_deviceJack.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDevices/Jack/ADM_deviceJack.cpp	2009-10-10 09:40:08 UTC (rev 5372)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDevices/Jack/ADM_deviceJack.cpp	2009-10-10 09:40:09 UTC (rev 5373)
@@ -6,16 +6,12 @@
 //
 
 
-#include <unistd.h>
-#include <stdio.h>
-#include <stdint.h>
-
 #include "ADM_default.h"
 #include "ADM_audiodevice.h"
-#include "ADM_assert.h"
+#include "ADM_audioDeviceInternal.h"
 #include "ADM_deviceJack.h"
 
-
+ADM_DECLARE_AUDIODEVICE(Jack,jackAudioDevice,1,0,0,"Jack audio device (c) M. Zenkov");
 #define BUFSIZE 16385
 
 jackAudioDevice::jackAudioDevice()
@@ -33,7 +29,7 @@
 	((jackAudioDevice*)arg)->stop();
 }
 
-uint8_t jackAudioDevice::stop()
+bool jackAudioDevice::localStop()
 {
 	if (client) {
 		printf("[JACK] Stop\n");
@@ -52,15 +48,17 @@
 
 	return 1;
 }
+/**
 
-uint8_t jackAudioDevice::init(uint8_t channels, uint32_t fq)
+*/
+bool jackAudioDevice::localInit(void)
 {
 	jack_status_t status;
-	_channels = channels;
 
+
 	if (sizeof(jack_default_audio_sample_t) != sizeof(float)) {
 		printf("[JACK] jack_default_audio_sample_t != float\n");
-		return 0;
+		return false;
 	}
 
 	client = jack_client_open("avidemux", JackNullOption, &status, NULL);
@@ -69,24 +67,26 @@
 		printf("[JACK] jack_client_open() failed, status = 0x%2.0x\n", status);
 		if (status & JackServerFailed)
 			printf(("[JACK] Unable to connect to server\n"));
-		return 0;
+		return false;
 	}
 
 	if (status & JackServerStarted)
 		printf("[JACK] Server started\n");
 
-	if (jack_get_sample_rate(client) == fq) {
+	if (jack_get_sample_rate(client) == _frequency) 
+    {
 		jack_set_process_callback(client, process_callback, this);
-	} else {
-		printf("[JACK] audio stream sample rate: %i\n", fq);
+	} else 
+    {
+		printf("[JACK] audio stream sample rate: %i\n", _frequency);
 		printf("[JACK] jack server sample rate: %i\n", (int)jack_get_sample_rate(client));
 		#ifdef USE_SRC
 			src_out_buf = new float[BUFSIZE * channels];
 			src_state = src_new(SRC_SINC_FASTEST, channels, NULL);
 			if (!src_state) {
 				printf("[JACK] Can't init libsamplerate\n");
-				stop();
-				return 0;
+				localStop();
+				return false;
 			}
 			src_data.data_out = src_out_buf;
 			src_data.output_frames = BUFSIZE;
@@ -95,47 +95,48 @@
 //			printf("[JACK] ratio: %f\n", src_data.src_ratio);
 		#else
 			printf("[JACK] For play this, you need avidemux compiled with libsamplerate support\n");
-			stop();
-			return 0;
+			localStop();
+			return false;
 		#endif
 	}
 
-	ringbuffer = jack_ringbuffer_create(BUFSIZE * channels * sizeof(jack_default_audio_sample_t));
+	ringbuffer = jack_ringbuffer_create(BUFSIZE * _channels * sizeof(jack_default_audio_sample_t));
 
 	jack_set_process_callback(client, process_callback, this);
 	jack_on_shutdown(client, jack_shutdown, this);
 
 	char name[10];
-	for (int i = 0; i < channels; i++) {
+	for (int i = 0; i < _channels; i++) {
 		snprintf(name, 10, "output-%d", i);
 		ports[i] = jack_port_register(client, name, JACK_DEFAULT_AUDIO_TYPE, JackPortIsOutput, 0);
 		if (!ports[i]) {
 			printf("[JACK] Can't create new port\n");
-			stop();
-			return 0;
+			localStop();
+			return false;
 		}
 	}
 
 	if (jack_activate(client)) {
 		printf("[JACK] Cannot activate client\n");
-		stop();
+		localStop();
 		return 0;
 	}
 
 	const char **input_ports = jack_get_ports(client, NULL, NULL, JackPortIsInput|JackPortIsPhysical);
 
-	for (int i = 0; i < channels && input_ports[i]; i++) {
+	for (int i = 0; i < _channels && input_ports[i]; i++) {
 		if (jack_connect(client, jack_port_name(ports[i]), input_ports[i]))
 			printf("[JACK] Connecting failed\n");
 	}
 
-	if (channels == 1 && input_ports[1])
+	if (_channels == 1 && input_ports[1])
 		if (jack_connect(client, jack_port_name(ports[0]), input_ports[1]))
 			printf("[JACK] Connecting failed\n");
 
 	return 1;
 }
-
+/**
+*/
 int jackAudioDevice::process(jack_nframes_t nframes)
 {
 	jack_default_audio_sample_t *pbuf[_channels];
@@ -171,8 +172,21 @@
 	return ((jackAudioDevice*)arg)->process(nframes);
 }
 
+void jackAudioDevice::sendData(void)
+{
+	mutex.lock();
+    uint32_t avail=wrIndex-rdIndex;
+    if(avail>sizeOf10ms) avail=sizeOf10ms;
+    mutex.unlock();
+    //play(avail,audioBuffer+rdIndex);
+	//int w=write(esdDevice, audioBuffer+rdIndex, avail);
+    mutex.lock();
+    rdIndex+=avail;
+    mutex.unlock();
+	return ;
+}
 
-uint8_t jackAudioDevice::play(uint32_t len, float *data)
+bool jackAudioDevice::tempplay(uint32_t len, float *data)
 {
 //	static int min = 5000;
 	static int sleep = (int)((float)BUFSIZE / jack_get_sample_rate(client) / 2. * 1000000.);

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDevices/Jack/ADM_deviceJack.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDevices/Jack/ADM_deviceJack.h	2009-10-10 09:40:08 UTC (rev 5372)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDevices/Jack/ADM_deviceJack.h	2009-10-10 09:40:09 UTC (rev 5373)
@@ -16,17 +16,20 @@
 
 #define MAX_CHANNELS 9
 
-class jackAudioDevice : public audioDevice
+class jackAudioDevice : public audioDeviceThreaded
 {
 public:
 	jackAudioDevice();
-	virtual uint8_t init(uint8_t channel,uint32_t fq);
-	virtual uint8_t play(uint32_t len, float *data);
-	virtual uint8_t stop();
-	uint8_t setVolume(int volume);
-	int process(jack_nframes_t nframes);
+    virtual     bool     localInit(void);
+    virtual     bool     localStop(void);
+    virtual     void     sendData(void); 
+                uint8_t  setVolume(int volume);
+                int      process(jack_nframes_t nframes);
 
 protected:
+
+    bool tempplay(uint32_t len, float *data); // FIXME: DOES NOT WORK!
+
 	static void jack_shutdown(void *arg);
 	static int process_callback(jack_nframes_t nframes, void *arg);
 



From mean at mail.berlios.de  Sat Oct 10 11:40:15 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 10 Oct 2009 11:40:15 +0200
Subject: [Avidemux-svn-commit] r5375 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDevices/Alsa
Message-ID: <200910100940.n9A9eFDf004505@sheep.berlios.de>

Author: mean
Date: 2009-10-10 11:40:15 +0200 (Sat, 10 Oct 2009)
New Revision: 5375

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDevices/Alsa/ADM_deviceALSA.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDevices/Alsa/CMakeLists.txt
Log:
[Alsa] Add default as alsa audio device

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDevices/Alsa/ADM_deviceALSA.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDevices/Alsa/ADM_deviceALSA.cpp	2009-10-10 09:40:12 UTC (rev 5374)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDevices/Alsa/ADM_deviceALSA.cpp	2009-10-10 09:40:15 UTC (rev 5375)
@@ -39,16 +39,22 @@
 #define ADEVICE "dmix"
 #endif
 
-#if ADM_ADEVICE_HW
+#ifdef ADM_ADEVICE_HW
 #define alsaAudioDevice alsaAudioDeviceHw0
 #include  "ADM_deviceALSA.h"
-
 ADM_DECLARE_AUDIODEVICE(AlsaHw0,alsaAudioDevice,1,0,0,"Alsa Audio Device (hw:0) (c) Mean 2008");
 #define ADEVICE "hw:0"
 #endif
 
+#ifdef ADM_ADEVICE_DEFAULT
+#define alsaAudioDevice alsaAudioDeviceDefault
+#include  "ADM_deviceALSA.h"
+ADM_DECLARE_AUDIODEVICE(AlsaDefault,alsaAudioDevice,1,0,0,"Alsa Audio Device (default) (c) Mean 2009");
+#define ADEVICE "default"
+#endif
 
 
+
 /* Handle for the PCM device */
 snd_pcm_t *pcm_handle;
 
@@ -152,7 +158,7 @@
     }
 #else
 
- 	unsigned int buffer_time = 800000;
+ 	unsigned int buffer_time = 100LL*1000LL; // 800 Ms ?
 	int er;
 	unsigned int buff;
 	dir=0;
@@ -332,7 +338,7 @@
 		snd_mixer_close(mixer_handle);
 		ADM_dealloc(pcm_name);
 		return 0;
-	}
+}
 	ADM_dealloc(pcm_name);
 	if( (rc=snd_mixer_selem_register(mixer_handle,NULL,NULL)) < 0 ){
 		printf("[Alsa]: snd_mixer_selem_register failed: %d\n",rc);
@@ -342,8 +348,7 @@
 	if( (rc=snd_mixer_load(mixer_handle)) < 0 ){
 		printf("[Alsa]: snd_mixer_load failed: %d\n",rc);
 		snd_mixer_close(mixer_handle);
-		return 0;
-	}
+		return 0;}
 	{ snd_mixer_elem_t *elem;
 	  snd_mixer_selem_id_t *sid;
 	  const char *str;

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDevices/Alsa/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDevices/Alsa/CMakeLists.txt	2009-10-10 09:40:12 UTC (rev 5374)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDevices/Alsa/CMakeLists.txt	2009-10-10 09:40:15 UTC (rev 5375)
@@ -16,3 +16,11 @@
 
 INIT_AUDIO_DEVICE(ADM_av_alsaHw)
 INSTALL_AUDIODEVICE(ADM_av_alsaHw)
+
+
+ADD_LIBRARY(ADM_av_alsaDefault SHARED ${ADM_av_alsa_SRCS})
+ADD_TARGET_CFLAGS(ADM_av_alsaDefault -DADM_ADEVICE_DEFAULT)
+TARGET_LINK_LIBRARIES(ADM_av_alsaDefault ${ASOUND_LIBRARY})
+
+INIT_AUDIO_DEVICE(ADM_av_alsaDefault)
+INSTALL_AUDIODEVICE(ADM_av_alsaDefault)



From mean at mail.berlios.de  Sat Oct 10 11:40:13 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 10 Oct 2009 11:40:13 +0200
Subject: [Avidemux-svn-commit] r5374 - in
	branches/avidemux_2.6_branch_mean/avidemux/common: .
	ADM_editor ADM_script
Message-ID: <200910100940.n9A9eDJO004490@sheep.berlios.de>

Author: mean
Date: 2009-10-10 11:40:12 +0200 (Sat, 10 Oct 2009)
New Revision: 5374

Added:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_editInternal.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.h
Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edLoadSave.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edSearch.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edStub.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADMedAVIAUD.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script/ADM_JSAvidemux.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script/ADM_JSAvidemuxVideo.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/gui_blackframes.cpp
Log:
[Editor] Begin to put back the segments/editor logic (incomplet + buggy)

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edLoadSave.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edLoadSave.cpp	2009-10-10 09:40:09 UTC (rev 5373)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edLoadSave.cpp	2009-10-10 09:40:12 UTC (rev 5374)
@@ -35,20 +35,7 @@
 static uint32_t edFrameStart,edFrameEnd;
 const char *getCurrentContainerAsString(void);
 
-uint8_t ADM_Composer::getMarkers(uint32_t *start, uint32_t *end)
-{
-	if(_haveMarkers)
-		{
-			*start=edFrameStart;
-			*end=edFrameEnd;		
-		}
-	else
-		{
-			*start=0;
-			*end=_total_frames-1;
-		}
-	return 1;		
-}
+
 //______________________________________________
 // Save the config, including name, segment etc...
 //______________________________________________
@@ -67,7 +54,7 @@
 printf("\n **Saving script project **\n");
   char *    tmp;
 
-  if (!_nb_segment)
+  if (!_segments.getNbSegments())
     return 1;
 
   FILE *    fd;
@@ -87,11 +74,11 @@
 
   qfprintf (fd, "var app = new Avidemux();\n");
   qfprintf (fd,"\n//** Video **\n");
-  qfprintf (fd,"// %02ld videos source \n", _nb_video);
+  qfprintf (fd,"// %02ld videos source \n", _segments.getNbRefVideos());
   char *nm;
   uint32_t vop=!!(video_body->getSpecificMpeg4Info()&ADM_VOP_ON);
-
-  for (uint32_t i = 0; i < _nb_video; i++)
+#if 0
+  for (uint32_t i = 0; i < _videos.size(); i++)
     {
         nm=ADM_cleanupPath(_videos[i]._aviheader->getMyName() );
         if(vop)
@@ -108,12 +95,12 @@
         }
         ADM_dealloc(nm);
     }
-  
-  qfprintf (fd,"//%02ld segments\n", _nb_segment);
+#endif  
+  qfprintf (fd,"//%02ld segments\n", _segments.getNbSegments());
   qfprintf (fd,"app.clearSegments();\n");
   
  
-
+#if 0
 for (uint32_t i = 0; i < _nb_segment; i++)
     {
         uint32_t src,start,nb;
@@ -122,6 +109,7 @@
                 nb=_segments[i]._nb_frames;
                 qfprintf (fd, "app.addSegment(%lu,%lu,%lu);\n",src,start,nb);
     }
+#endif
 // Markers
 //
         qfprintf(fd,"app.markerA=%d;\n",frameStart);

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp	2009-10-10 09:40:09 UTC (rev 5373)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp	2009-10-10 09:40:12 UTC (rev 5374)
@@ -29,6 +29,9 @@
 #endif
 
 #include "ADM_pp.h"
+#define ADM_warning printf
+#define ADM_info    printf
+#define ADM_error   printf
 
 // FIXME BADLY !!!
 // This should be in a context somewhere
@@ -41,15 +44,14 @@
 */
 bool        ADM_Composer::GoToIntra(uint32_t frame)
 {
-uint32_t relframe, seg, flags, len;
+uint32_t relframe, ref, flags, len;
 
-  // convert frame to block, relative frame
-  if (!convFrame2Seg (frame, &seg, &relframe))
+    if(_segments.getRefFromFrame(frame,&ref,&relframe)==false)
     {
-      printf ("[ADMComposer::goToIntra] Conversion failed for frame %"LU" !\n",frame);
-      return false;
+        ADM_warning("[GoToIntra] Cannot convert frame %"LU"\n",frame);
+        return false;
     }
-    return DecodePictureUpToIntra(relframe,seg);
+    return DecodePictureUpToIntra(relframe,ref);
 }
 /**
     \fn GoToTime
@@ -97,14 +99,18 @@
 */
 bool        ADM_Composer::getCompressedPicure(uint32_t framenum,ADMCompressedImage *img)
 {
-uint8_t ref = 0;
-
-    _VIDEOS *vid=&_videos[ref];
+uint32_t ref = 0,relative=0;
+    if(false==_segments.getRefFromFrame(framenum,&ref,&relative))
+    {
+        ADM_warning("[getCompressedPicure] Cannot get ref+frame to frame %"LD"\n",framenum);
+        return false;
+    }
+    _VIDEOS *vid=_segments.getRefVideo(ref);
     vidHeader *demuxer=vid->_aviheader;
 
     img->cleanup(framenum);
 
-    if (!demuxer->getFrame (framenum,img)) return false;
+    if (!demuxer->getFrame (relative,img)) return false;
     return true;
 }
 //***************************** Internal API**************************
@@ -132,9 +138,9 @@
     img.cleanup(frame);
 
     printf("[EditorRender] DecodeUpToInta %u ref:%u\n",frame,ref);
-	_VIDEOS *vid=&_videos[ref];
+	_VIDEOS *vid=_segments.getRefVideo(ref);
     vidHeader *demuxer=vid->_aviheader;
-	cache=_videos[ref]._videoCache;
+	cache=_segments.getRefVideo(ref)->_videoCache;
 	ADM_assert(cache);
     // Make sure frame is an intra
     demuxer->getFlags(frame,&flags);
@@ -145,7 +151,7 @@
     uint32_t nbFrames=vid->_nb_video_frames;
     aprintf("[EditorRender] DecodeUpToIntra flushing cache & codec\n");
     cache->flush();
-    _videos[ref].decoder->flush();
+    vid->decoder->flush();
     // The PTS associated with our frame is the one we are looking for
     uint64_t wantedPts=vid->_aviheader->estimatePts(frame);
     uint32_t tries=15+7; // Max Ref frames for H264 + MaxRecovery , let's say 7 is ok for recovery
@@ -240,9 +246,9 @@
 */
 bool ADM_Composer::getSamePicture(ADMImage *out,uint32_t ref)
 {
-    _VIDEOS *vid=&_videos[ref];
+    _VIDEOS *vid=_segments.getRefVideo(ref);
     vidHeader *demuxer=vid->_aviheader;
-	EditorCache   *cache =_videos[ref]._videoCache;
+	EditorCache   *cache =vid->_videoCache;
 	ADM_assert(cache);
 
   ADMImage *in=cache->getByPts(vid->lastDecodedPts);
@@ -265,9 +271,9 @@
 */
 bool ADM_Composer::getNextPicture(ADMImage *out,uint32_t ref)
 {
-  EditorCache   *cache=_videos[ref]._videoCache;
+  EditorCache   *cache=_segments.getRefVideo(ref)->_videoCache;
   ADMImage	*result;
-  _VIDEOS *vid=&_videos[ref];
+  _VIDEOS *vid=_segments.getRefVideo(ref);
 
    uint32_t loop=20; // Try 20 frames ahead
 
@@ -324,9 +330,9 @@
   ADMImage	*result;
   uint32_t  flags;
   ADMCompressedImage img;
-   _VIDEOS *vid=&_videos[ref];
+   _VIDEOS *vid=_segments.getRefVideo(ref);
     vidHeader *demuxer=vid->_aviheader;
-	cache=_videos[ref]._videoCache;
+	cache=vid->_videoCache;
     // PlaceHolder...
     img.data=compBuffer;
     img.cleanup(vid->lastSentFrame+1);
@@ -392,7 +398,8 @@
 {
  ADMImage *tmpImage=NULL;
  uint32_t ww,hh,left,right;
- uint32_t refOnly=_videos[ref].decoder->dontcopy(); // can we skip one memcpy ?
+ _VIDEOS *v=_segments.getRefVideo(ref);
+ uint32_t refOnly=v->decoder->dontcopy(); // can we skip one memcpy ?
 // This is only an empty Shell
     if(refOnly)
     {
@@ -424,7 +431,7 @@
     //
     tmpImage->_colorspace=ADM_COLOR_YV12;
 	// Decode it
-        if (!_videos[ref].decoder->uncompress (in, tmpImage))
+        if (!v->decoder->uncompress (in, tmpImage))
 	    {
             printf("[decompressImage] uncompress failed\n");
             return false;
@@ -472,7 +479,7 @@
 	// Pp deactivated ?
 	if(!_pp.postProcType || !_pp.postProcStrength || tmpImage->_colorspace!=ADM_COLOR_YV12)
     {
-        dupe(tmpImage,out,&(_videos[ref]));
+        dupe(tmpImage,out,v);
         aprintf("EdCache: Postproc disabled\n");
 		return 1;
 	}
@@ -596,295 +603,8 @@
     return true;
 }
 
-/**_____________________________________________________________________
-		Main function
-		Caller ask for a frame from the editor
-		We first split it to segment and frame from that segment
-			then look if it is in the cache
-		If not and if there is Bframe we look if it is the forward
-			reference frame we currently have
 
-_______________________________________________________________________*/
-uint8_t  ADM_Composer::getUncompressedFrame (uint32_t frame, ADMImage * out,
-				      uint32_t * flagz)
-{
-  // first get segment
-  uint32_t relframe, seg, flags, len;
-  uint8_t ret = 0;
-  EditorCache   *cache;
-  ADMImage	*result;
 
-//    static uint32_t lastlen=0;
-    printf("[getUncompressedFrame] *************** OBSOLETE FUNCTION CALLED **********************\n");
-    printf("[getUncompressedFrame] *************** OBSOLETE FUNCTION CALLED **********************\n");
-    printf("[getUncompressedFrame] *************** OBSOLETE FUNCTION CALLED **********************\n");
-    printf("[getUncompressedFrame] *************** OBSOLETE FUNCTION CALLED **********************\n");
-    printf("[getUncompressedFrame] *************** OBSOLETE FUNCTION CALLED **********************\n");
-    printf("[getUncompressedFrame] *************** OBSOLETE FUNCTION CALLED **********************\n");
-	if(flagz)
-			*flagz=0;
-
-  // convert frame to block, relative frame
-  if (!convFrame2Seg (frame, &seg, &relframe))
-    {
-      printf ("\n Conversion failed !\n");
-      return 0;
-    }
-  uint32_t ref = _segments[seg]._reference;
-  uint32_t llen = _videos[ref]._aviheader->getWidth ()
-  				  * _videos[ref]._aviheader->getHeight ();
-	llen = llen + (llen >> 1);
-	_VIDEOS *vid=&_videos[ref];
-	cache=_videos[ref]._videoCache;
-	ADM_assert(cache);
-
-	aprintf("Ed: Request for frame %"LU" seg %"LU", old frame:%"LU" old seg:%"LU"\n",relframe,seg,_lastframe,_lastseg);
-
-	// First look in the cache
-
-	if((result=cache->getImage(relframe)))
-	{
-		aprintf(">>frame %"LU" is cached...\n",relframe);
-		out->duplicate(result);
-		if(flagz)
-			*flagz=result->flags;
-		return 1;
-	}
-	else
-	{
-		aprintf("frame %"LU" is not cached...\n",relframe);
-	}
-//
-
-//	Prepare the destination...
-	result=cache->getFreeImage();
-#ifdef VERBOSE
-	cache->dump();
-#endif
-
-  // now we got segment and frame
-  //*************************
-  // Is is a key frame ?
-  //*************************
-  _videos[ref]._aviheader->getFlags (relframe, &flags);
-
-    if (flags & AVI_KEY_FRAME)
-    {
-    	aprintf("keyframe\n");     	
-        if(!decodeCache(relframe,ref, result))
-		{
-			printf("[edRender]Editor: Cannot deccode keyframe %"LU"\n",relframe);
-			return 0;
-		}
-        _lastseg = seg;
-        _lastframe = relframe;
-        if(flagz)
-            *flagz=result->flags;
-        out->duplicate(result);
-        return (1);
-    }
-
-    //*************************
-    // following frame ?
-    // If it a  next b-frame we already have the forward reference set
-    // if it is a first B-frame --> do it
-    //
-    //*************************
-      if ((seg == _lastseg) && ((_lastframe + 1) == relframe))
-	{
-	aprintf("following frame\n");
-	// B Frame ?
-#if 0
-	if(_videos[ref]._aviheader->isReordered())
-	{
-		// The frame we seek is not in cache, so
-		if(!_videos[ref]._aviheader->getFlags (relframe, &flags))
-		{
-			printf("Editor : Getflags failed\n");
-			return 0;
-		}
-		// if it is a b frame we decode all of them up to
-		// the next ip included and put all this in cache
-		if(flags & AVI_B_FRAME)
-		{
-			// decode all of them up to the next I/P frame
-			uint32_t nextIp=relframe;
-
-			while((flags&AVI_B_FRAME))
-			{
-				nextIp++;
-				_videos[ref]._aviheader->getFlags (nextIp, &flags);
-
-			}
-			// Decode it
-			if(!decodeCache(nextIp,ref, result))
-			{
-				printf("Editor: Cannot read ip frame %"LU"\n",nextIp);
-				return 0;
-			}
-
-
-			// And now go forward...
-			uint32_t seeked=relframe;
-			while(seeked<nextIp)
-			{
-				result=cache->getFreeImage();
-				if(!decodeCache(seeked,ref, result))
-				{
-					printf("Editor: Cannot read ip frame %"LU"\n",nextIp);
-					return 0;
-				}
-				if(seeked==relframe)
-				{
-					 out->duplicate(result);
-					 if(flagz) *flagz=result->flags;
-				}
-				seeked++;
-			}
-			_lastframe=nextIp;
-			_lastseg = seg;
-			return 1;
-		}
-
-	}
-#endif
-	// No b frame...
-
-      	 if(!decodeCache(relframe,ref, result))
-			{
-				printf("Editor: Cannot read ip frame %"LU"\n",relframe);
-				return 0;
-			}
-	if(flagz)
-		*flagz=result->flags;
-	out->duplicate(result);
-	_lastframe=relframe;
-	_lastseg = seg;
-	return 1;
-    }
-  //*************************
-  // completly async frame
-  // rewind ?
-  //*************************
-
-  aprintf("async  frame, wanted : %"LU" last %"LU" (%"LU" - %"LU" seg)\n",relframe,_lastframe,seg,_lastseg);
-  uint32_t rewind;
-  uint32_t seekFlag=0;
-
-  _videos[ref]._aviheader->getFlags (relframe, &seekFlag);
-
-  flags = 0;
-  uint32_t need_rewind=1;
-  rewind = relframe;
-  ADM_assert(rewind); // the first frame should be a keyframe !
-  while (!(flags & AVI_KEY_FRAME))
-  {
-  	rewind--;
-  	_videos[ref]._aviheader->getFlags (rewind, &flags);
-   }
-   // Optimize for resample FPS*************************
-   // If we are in the same segment, look if it is better to decode
-    // From where we are or to seek the previous intra
-   if ((seg == _lastseg))
-   {
-     if(rewind<_lastframe && relframe>_lastframe) // we have a better position to go from
-     {
-       for (uint32_t i = _lastframe+1; i <relframe; i++)
-       {
-
-         _videos[ref]._aviheader->getFlags (i, &flags);
-      // Skip B frames, there can be a lot of them
-         if((flags&AVI_B_FRAME)) continue;
-
-         if(!decodeCache(i,ref, result))
-         {
-           printf("Editor: Cannot read ip frame %"LU"\n",relframe);
-           return 0;
-         }
-         result=cache->getFreeImage();
-       }
-       need_rewind=0;
-     }
-   }
-   // Optimize for resample FPS*************************
-   //
-  // now forward
-  // IP seen is the last P (or I) before the frame we seek
-   if(need_rewind)
-   {
-        for (uint32_t i = rewind; i <relframe; i++)
-        {
-
-                _videos[ref]._aviheader->getFlags (i, &flags);
-                // Skip B frames, there can be a lot of them
-                if((flags&AVI_B_FRAME)) continue;
-
-                if(!decodeCache(i,ref, result))
-	        {
-		      printf("Editor: Cannot read ip frame %"LU"\n",relframe);
-		      return 0;
-	        }
-	        result=cache->getFreeImage();
-        }
-   }
-      // Time to decode our frame
-      // if it is not a B, just decode it
-      // it it is a B, the usual stuff
-      if(!seekFlag)
-      {
-      		if(!decodeCache(relframe,ref, result))
-			{
-				printf("Editor: Cannot read ip frame %"LU"\n",relframe);
-				return 0;
-			}
-		if(flagz)
-			*flagz=result->flags;
-		out->duplicate(result);
-		_lastframe=relframe;
-		_lastseg=seg;
-		return 1;
-
-      }
-      // it is a b frame
-      // decode all of them up to the next I/P frame
-	uint32_t nextIp=relframe;
-	flags=AVI_B_FRAME;
-	while((flags&AVI_B_FRAME))
-	{
-		nextIp++;
-		_videos[ref]._aviheader->getFlags (nextIp, &flags);
-	}
-	// Decode it
-	if(!decodeCache(nextIp,ref, result))
-	{
-		printf("Editor: Cannot read ip frame %"LU"\n",nextIp);
-		return 0;
-	}
-
-
-	// And now go forward...
-	uint32_t seeked=relframe;
-	while(seeked<nextIp)
-	{
-		result=cache->getFreeImage();
-		if(!decodeCache(seeked,ref, result))
-		{
-			printf("Editor: Cannot read ip frame %"LU"\n",nextIp);
-			return 0;
-		}
-		if(seeked==relframe)
-		{
-			 out->duplicate(result);
-			 if(flagz) *flagz=result->flags;
-		}
-		seeked++;
-	}
-	_lastframe=nextIp;
-	_lastseg=seg;
-  	return 1;
-}
-
-
 /**
     \fn decodeCache
     \brief Decode an image an update cache
@@ -896,29 +616,40 @@
 
 uint32_t sumit;
 float	 sum;
-EditorCache *cache=_videos[seg]._videoCache;
+
+uint32_t ref,refOffset;
+
+        if(false==_segments.getRefFromFrame(frame,&ref,&refOffset))
+        {
+            ADM_warning("[decodeCache] Cannot get ref for frame %"LD"\n",frame);
+            return false;
+        }
+
+
+_VIDEOS *v=_segments.getRefVideo(ref); // FIXME!!!!
+EditorCache *cache=v->_videoCache;
 ADMImage *tmpImage=NULL;
 uint8_t refOnly=0;
 uint32_t left,ww;
 ADMCompressedImage img;
 
-        aprintf("decodeCache : Frame %u\n",frame);
+        aprintf("decodeCache : original :%"LD" Frame in ref %"LD"\n",frame,refOffset);
         img.data=compBuffer;
         img.cleanup(frame);
-    // Step 1, retrieve the compressed datas, including PTS & DTS infos
-	 if (!_videos[seg]._aviheader->getFrame (frame,&img))
-	{
-	  printf ("\nEditor: last decoding failed.%"LD")\n",   frame );
-	  return 0;
-	}
+        // Step 1, retrieve the compressed datas, including PTS & DTS infos
+         if (!v->_aviheader->getFrame (refOffset,&img))
+        {
+          ADM_warning ("Editor: last decoding failed.%"LD")\n",   refOffset );
+          return 0;
+        }
         ADM_assert(_imageBuffer);
 
         // if len is 0 then take the previous image
         //
 
-        refOnly=_videos[seg].decoder->dontcopy(); // can we skip one memcpy ?
+        refOnly=v->decoder->dontcopy(); // can we skip one memcpy ?
 
-        if(!img.dataLength & refOnly & !frame)      // Size is null = no image and we only got a pointer
+        if(!img.dataLength & refOnly & !refOffset)      // Size is null = no image and we only got a pointer
                                 // copy the previous one
         {
                 // First image
@@ -927,7 +658,7 @@
                         memset(YPLANE(image),0,page);
                         memset(UPLANE(image),128,page>>2);
                         memset(VPLANE(image),128,page>>2);
-                        if(!frame)
+                        if(!refOffset)
                                 image->flags=AVI_KEY_FRAME;
                         else
                                 image->flags=AVI_P_FRAME;
@@ -965,18 +696,18 @@
        }
 	tmpImage->_colorspace=ADM_COLOR_YV12;
 	// Do pp, and use imageBuffer as intermediate buffer
-	if (!_videos[seg].decoder->uncompress (&img, tmpImage))
+	if (!v->decoder->uncompress (&img, tmpImage))
 	    {
-	      printf ("\nEditor: Last Decoding2 failed for frame %"LU"\n",frame);
+	      printf ("\nEditor: Last Decoding2 failed for frame %"LU"\n",refOffset);
 	       // Try to dupe previous frame
-                if(frame)
+                if(refOffset)
                 {
                         ADMImage *prev;
-                        prev=cache->getImage(frame-1);
+                        prev=cache->getImage(refOffset-1);
                         if(prev)
                         {
                                 image->duplicate(prev);
-                                cache->updateFrameNum(image,frame);
+                                cache->updateFrameNum(image,refOffset);
                                 return 1;
                         }
                 }
@@ -984,7 +715,7 @@
            }
 
         //
-        if(tmpImage->_noPicture && refOnly && frame)
+        if(tmpImage->_noPicture && refOnly && refOffset)
         {
                 cache->updateFrameNum(image,0xffffffffU);
                 return 0;
@@ -994,7 +725,7 @@
 	{
 		image->_Qp=2;
 		image->duplicate(tmpImage);
-		cache->updateFrameNum(image,frame);
+		cache->updateFrameNum(image,refOffset);
           //      if(refOnly) delete tmpImage;
 		aprintf("EdCache: No quant avail\n");
 		return 1;
@@ -1025,9 +756,9 @@
 
 	// Pp deactivated ?
 	if(!_pp.postProcType || !_pp.postProcStrength || tmpImage->_colorspace!=ADM_COLOR_YV12)
-         {
-                dupe(tmpImage,image,&(_videos[seg]));
-		cache->updateFrameNum(image,frame);
+     {
+        dupe(tmpImage,image,v);
+		cache->updateFrameNum(image,refOffset);
                // if(refOnly) delete tmpImage;
 		aprintf("EdCache: Postproc disabled\n");
 		return 1;
@@ -1154,7 +885,7 @@
 _next:
         // update some infos
         //   if(refOnly) delete tmpImage;
-		cache->updateFrameNum(image,frame);
+		cache->updateFrameNum(image,refOffset);
 		aprintf("EdCache: Postproc done\n");
 		return 1;
 }
@@ -1188,7 +919,7 @@
 */
 uint8_t ADM_Composer::setPostProc( uint32_t type, uint32_t strength, uint32_t swapuv)
 {
-	if(!_nb_video) return 0;
+	if(!_segments.getNbRefVideos()) return 0;
 	_pp.postProcType=type;
 	_pp.postProcStrength=strength;
         _pp.swapuv=swapuv;
@@ -1201,7 +932,7 @@
 
 uint8_t ADM_Composer::getPostProc( uint32_t *type, uint32_t *strength, uint32_t *swapuv)
 {
-	if(!_nb_video) return 0;
+	if(!_segments.getNbRefVideos()) return 0;
 	*type=_pp.postProcType;
 	*strength=_pp.postProcStrength;
 	*swapuv=_pp.swapuv;
@@ -1213,7 +944,7 @@
     \fn getPKFrame
     \brief returns the keyFrame strictly before *frame
 */
-uint8_t	ADM_Composer::getPKFrame(uint32_t *frame)
+bool	ADM_Composer::getPKFrame(uint32_t *frame)
 {
 	uint32_t fr, seg, relframe;	//,len; //flags,ret,nf;
 
@@ -1221,22 +952,27 @@
 
   if (*frame == 0)
     {
-      return 0;
+      return false;
     }
   if (!searchPreviousKeyFrame (fr, &seg, &relframe))
     {
       printf (" NKF not found\n");
-      return 0;
+      return false;
     }
-  ADM_assert (convSeg2Frame (frame, seg, relframe));
-  return 1;
+    if(false==_segments.getFrameFromRef(frame,seg,relframe))
+    {
+        ADM_warning("[getPKFrame] getFrameFromRef failed for sefg : %"LD" reframe %"LD"\n",seg,relframe);
+        return false;
+    }
+  return true;
+
 }
 /**
     \fn getNKFrame
     \brief returns the keyFrame strictly after *frame
 */
 
-uint8_t	ADM_Composer::getNKFrame(uint32_t *frame)
+bool	ADM_Composer::getNKFrame(uint32_t *frame)
 {
 	uint32_t fr, seg, relframe;	//,len; //flags,ret,nf;
 
@@ -1246,8 +982,12 @@
       printf (" NKF not found\n");
       return 0;
     }
-  ADM_assert (convSeg2Frame (frame, seg, relframe));
-  return 1;
+    if(false==_segments.getFrameFromRef(frame,seg,relframe))
+    {
+        ADM_warning("[getNKFrame] getFrameFromRef failed for sefg : %"LD" reframe %"LD"\n",seg,relframe);
+        return false;
+    }
+  return true;
 }
 
 #if 0
@@ -1306,11 +1046,20 @@
 }
 /**
     \fn searchFrameBefore
-    \brief rEturn the frame number with pts just before pts
+    \brief Return the frame number with pts just before pts
 */
 uint32_t ADM_Composer::searchFrameBefore(uint64_t pts)
 {
-    _VIDEOS   *vid=&_videos[0];
+uint64_t refTime;
+uint32_t ref;
+    if(false==_segments.getRefFromTime(pts,&ref,&refTime))
+    {
+        ADM_warning("[searchFrameBefore] Failed for pts %"LLU"\n",pts);
+        ref=0;
+        refTime=pts;
+    }
+#warning fix over-seg issue
+    _VIDEOS   *vid=_segments.getRefVideo(ref);
     vidHeader *demuxer=vid->_aviheader;
     uint64_t  lastPts=demuxer->getTime(0);
     uint32_t  nb=demuxer->getVideoStreamHeader()->dwLength;
@@ -1336,8 +1085,8 @@
 {
     int ref=0;
     EditorCache   *cache;
-	_VIDEOS *vid=&_videos[ref];
-	cache=_videos[ref]._videoCache;
+	_VIDEOS *vid=_segments.getRefVideo(0);
+	cache=vid->_videoCache;
 	ADM_assert(cache);
         ADMImage *r=cache->findLastBefore(pts);
         if(!r) return false;
@@ -1351,7 +1100,14 @@
 */
 bool        ADM_Composer::getPtsDts(uint32_t frame,uint64_t *pts,uint64_t *dts)
 {
-     _VIDEOS   *vid=&_videos[0];
+uint32_t ref,refOffset;
+    if(_segments.getRefFromFrame(frame,&ref,&refOffset)==false)
+    {
+        ADM_warning("[Composer::getPtsDts] Cannot get ref video for frame %"LD"\n",frame);
+        return false;
+    }
+ 
+     _VIDEOS   *vid=_segments.getRefVideo(ref);
     vidHeader *demuxer=vid->_aviheader;
     return demuxer->getPtsDts(frame,pts,dts); // FIXME : Rescale frame number
 

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edSearch.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edSearch.cpp	2009-10-10 09:40:09 UTC (rev 5373)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edSearch.cpp	2009-10-10 09:40:12 UTC (rev 5374)
@@ -18,14 +18,16 @@
 #include "fourcc.h"
 #include "ADM_editor/ADM_edit.hxx"
 
-
+/**
+    \fn searchNextKeyFrame
  //             Input : frame <b>as seen by GUI  </b>
  //     Output, segment & relframe previous keyframe
  //
-uint8_t
-  ADM_Composer::searchNextKeyFrame (uint32_t in, uint32_t * oseg,
+*/
+uint8_t   ADM_Composer::searchNextKeyFrame (uint32_t in, uint32_t * oseg,
 				    uint32_t * orel)
 {
+#if 0
   uint32_t relframe;
   uint32_t seg, flags;
   uint8_t switched = 0;
@@ -44,7 +46,7 @@
       return 0;
     }
 
-  while (seg < _nb_segment)
+  while (seg < _segments.size())
     {
       ref = _segments[seg]._reference;
       // Search next kf in seg
@@ -77,6 +79,8 @@
       relframe = _segments[seg]._start_frame;
       switched = 1;
     }
+#endif
+#warning : Obsolete!
   return 0;
 
 }
@@ -86,6 +90,7 @@
   ADM_Composer::searchPreviousKeyFrame (uint32_t in, uint32_t * oseg,
 					uint32_t * orel)
 {
+#if 0
   uint32_t relframe;
   uint32_t seg, flags;
   uint32_t ref;
@@ -149,6 +154,8 @@
     }
   while (1);
   printf ("\n failed pkf..\n");
+#endif
+#warning obsolete
   return 0;
 
 }

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edStub.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edStub.cpp	2009-10-10 09:40:09 UTC (rev 5373)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edStub.cpp	2009-10-10 09:40:12 UTC (rev 5374)
@@ -17,201 +17,68 @@
 #include "ADM_default.h"
 #include <math.h>
 
+#define ADM_warning printf
+#define ADM_info    printf
+#define ADM_error   printf
 
 #include "fourcc.h"
 #include "ADM_editor/ADM_edit.hxx"
 
-#define STUBB _videos[0]._aviheader
-
+#define STUBB _segments.getRefVideo(0)->_aviheader
+#define ADM_TRANSLATE(func,frame) \
+uint32_t ref,refOffset;\
+    if(false== _segments.getRefFromFrame( frame,&ref,&refOffset))  \
+    { \
+        ADM_warning(#func " cannot translate fame %"LD"\n",frame); \
+        return false; \
+    }
 /*
 	Propagate this hack to the underlying decoder
 */
 uint32_t ADM_Composer::getSpecificMpeg4Info( void )
 {
-	if(_nb_segment)
-		if(_videos[0].decoder)
-	 		return _videos[0].decoder->getSpecificMpeg4Info();
+	if(_segments.getNbSegments())
+    {
+        _VIDEOS *vid=_segments.getRefVideo(0);
+		if(vid->decoder)
+	 		return vid->decoder->getSpecificMpeg4Info();
+    }
 	return 0;
 
 }
-/**
-  Convert a frame as seen by the gui to a segment and offset
-  in the segment
-*/
-uint8_t
-  ADM_Composer::convFrame2Seg (uint32_t framenum,
-			       uint32_t * seg, uint32_t * relframe)
-{
-  uint32_t curseg = 0, taq = 0;
 
-  while (curseg < _nb_segment)
-    {
 
-      if ((framenum >= taq)
-	  && (framenum < (taq + _segments[curseg]._nb_frames)))
-	{
-	  // gotcha
-	  *seg = curseg;
-	  *relframe = _segments[curseg]._start_frame + framenum - taq;
-	  return 1;
-
-	}
-      taq += _segments[curseg]._nb_frames;
-      curseg++;
-
-    };
-  printf("\n Frame 2 seg failed! (%"LU")\n",framenum);
-  dumpSeg();
-  return 0;
-
-
-}
-
 /**
-  Convert a frame inside a segment as a frame as seen by GUI
-  */
-uint8_t
-  ADM_Composer::convSeg2Frame (uint32_t * framenum,
-			       uint32_t seg, uint32_t relframe)
-{
-  uint32_t curseg = 0;
-  ADM_assert (seg < _nb_segment);
-  *framenum = 0;
-  while (curseg < seg)
-    {
-
-      *framenum += _segments[curseg]._nb_frames;
-
-      curseg++;
-    };
-#if 0
-  printf ("\n Seg: %lu Sum : %lu, relframe :%lu, start:%lu", seg,
-	  *framenum, relframe, _segments[seg]._start_frame);
-#endif
-  *framenum += relframe - _segments[seg]._start_frame;
-#if 0
-  printf ("--> %lu\n", *framenum);
-#endif
-  return 1;
-
-
-}
-
-decoders 		*ADM_Composer::rawGetDecoder(uint32_t frame)
-{
- uint32_t relframe;
-  uint32_t seg;
-  uint32_t ref;
-
-  // convert frame to block, relative frame
-  if (!convFrame2Seg (frame, &seg, &relframe))
-    return 0;
-   ref = _segments[seg]._reference;
-    return _videos[ref].decoder;
-}
-/**
     \fn getFrame
     \brief returns the raw frame from the demuxer with len pts & dts
 */
 uint8_t   ADM_Composer::getFrame (uint32_t framenum, ADMCompressedImage *img, uint8_t *isSeq)
 {
-  uint32_t relframe;
-  uint32_t seg;
-  static uint32_t lastseg = 0, lastframe = 0;
-  uint32_t ref;
+  static uint32_t lastRef = 0, lastframe = 0;
+  ADM_TRANSLATE(getFrame,framenum)
 
-  // convert frame to block, relative frame
-  if (!convFrame2Seg (framenum, &seg, &relframe))
-    return 0;
-#if 0
-  printf ("\n %"LU" --> %"LU",%"LU"\n", framenum, seg, relframe);
-#endif
-  if (seg)
+  if (ref)
     {
-      if ((lastseg == seg) && ((lastframe + 1) == relframe))
+      if ((lastRef == ref) && ((lastframe + 1) == refOffset))
 	{
 	  *isSeq = 1;
 	}
       else
 	*isSeq = 0;
     }
-  lastseg = seg;
-  lastframe = relframe;
-  ref = _segments[seg]._reference;
-  return _videos[ref]._aviheader->getFrame (relframe,img);
+  lastRef = ref;
+  lastframe = refOffset;
+  return _segments.getRefVideo(ref)->_aviheader->getFrame (refOffset,img);
 }
-//
-// Check that the 2 frames are sequential with just B frames in between
-// B > A!
-// Return 1 if they are in sequence
-// 0 if not
-uint8_t ADM_Composer::sequentialFramesB(uint32_t frameA,uint32_t frameB)
-{
-	uint32_t relframeA,segA;
-	uint32_t relframeB,segB,ref;
-	uint32_t flags;
 
-	ADM_assert(frameB>frameA);
 
-	if (!convFrame2Seg (frameA, &segA, &relframeA))
-  	{
-  		printf("Editor: seq : convFrame2seg failed!\n");
-    		return 0;
-  	}
-  	if (!convFrame2Seg (frameB, &segB, &relframeB))
-  	{
-  		printf("Editor: seq : convFrame2seg failed!\n");
-    		return 0;
-  	}
-  	if(segA!=segB)
-	{
-	// printf("%"LU" %"LU" -> seg differs: %"LU",%"LU"\n",frameA,frameB,segA,segB);
-	 return 0;
-	}
-
-	 ref = _segments[segA]._reference;
-
-	for(uint32_t i=relframeA+1;i<relframeB;i++)
-	{
-		_videos[ref]._aviheader->getFlags(i,&flags);
-		if(!(flags&AVI_B_FRAME))
-		{
-	//		printf("Start: %"LU" ko:%"LU" end:%"LU"\n",relframeA+1,i,relframeB);
-			return 0;		// There is not only B frame between A & B
-		}
-	}
-
-	return 1;
-
-}
-//_________________________________________________________________
-uint8_t   ADM_Composer::isSequential (uint32_t framenum)
-{
-  uint32_t relframe;
-  uint32_t seg;
-  static uint32_t lastseg = 0, lastframe = 0;
-  uint32_t ref;
-
-  // convert frame to block, relative frame
-  if (!convFrame2Seg (framenum, &seg, &relframe))
-  {
-  	printf("Editor: seq : convFrame2seg failed!\n");
-    return 0;
-  }
-
-	if ((lastseg == seg) && ((lastframe + 1) == relframe))
-	  return 1;
-	else
-	return 0;
-}
-
-
 /**
     \fn getTime
     \brief return or estimate the pts of frame fn
 */
 uint64_t ADM_Composer::getTime (uint32_t fn)
 {
+    
     uint64_t t= STUBB->getTime(fn);
     uint32_t org=fn;
     if(t!=ADM_COMPRESSED_NO_PTS) return t;
@@ -224,75 +91,54 @@
         if(STUBB->getTime(fn)!=ADM_COMPRESSED_NO_PTS)
         {
             t=STUBB->getTime(fn);
-            t+= _videos[0].timeIncrementInUs*(org-fn);
+            t+= _segments.getRefVideo(0)->timeIncrementInUs*(org-fn);
             return t;
         }
     }
     printf("[ADM_Composer::getTime] Cannot estimate time for frame %u\n",org);
     return 0;
 }
-
+/**
+    \fn getFlags
+*/
 uint32_t ADM_Composer::getFlags (uint32_t frame, uint32_t * flags)
 {
-  uint32_t
-    relframe;
-  uint32_t
-    seg;
-  if (!convFrame2Seg (frame, &seg, &relframe))
-  {
-        printf("Error for frame %u\n",frame);
-    return 0;
-  }
-  uint32_t
-    ref =
-    _segments[seg].
-    _reference;
-  return _videos[ref]._aviheader->getFlags (relframe, flags);
+    ADM_TRANSLATE(getFlags,frame);
+    return _segments.getRefVideo(ref)->_aviheader->getFlags (refOffset, flags);
 }
+/**
+    \fn getFlagsAndSeg
+*/
 uint32_t ADM_Composer::getFlagsAndSeg (uint32_t frame, uint32_t * flags,uint32_t *segs)
 {
-  uint32_t
-    relframe;
-  uint32_t
-    seg;
+#if 0
+  uint32_t    relframe;
+  uint32_t    seg;
   if (!convFrame2Seg (frame, &seg, &relframe))
     return 0;
   uint32_t    ref =   _segments[seg]._reference;
 
     *segs=seg;
-    return _videos[ref]._aviheader->getFlags (relframe, flags);
+#endif
+    return _segments.getRefVideo(0)->_aviheader->getFlags (frame, flags);
 }
 /**
     \fn getFrameSize
 */
 uint8_t ADM_Composer::getFrameSize (uint32_t frame, uint32_t * size)
 {
-  uint32_t    relframe;
-  uint32_t    seg,    ref;
-  if (!convFrame2Seg (frame, &seg, &relframe))
-    return 0;
+ 
+  ADM_TRANSLATE(getframeSize,frame);
+  return _segments.getRefVideo(ref)->_aviheader->getFrameSize (refOffset, size);
 
-  ref = _segments[seg]._reference;
-  return _videos[ref]._aviheader->getFrameSize (relframe, size);
 
-
 }
 
 
 uint8_t ADM_Composer::setFlag (uint32_t frame, uint32_t flags)
 {
-  uint32_t
-    relframe;
-  uint32_t
-    seg;
-  if (!convFrame2Seg (frame, &seg, &relframe))
-    return 0;
-
-  uint32_t
-    ref =
-    _segments[seg].
-    _reference;
-  return _videos[ref]._aviheader->setFlag (relframe, flags);
+    ADM_TRANSLATE(setFlag,frame);
+    return _segments.getRefVideo(ref)->_aviheader->setFlag (refOffset, flags);
 }
 
 //
@@ -300,40 +146,34 @@
 uint8_t ADM_Composer::updateVideoInfo (aviInfo * info)
 {
 
-  info->nb_frames = _total_frames;
+  info->nb_frames = _segments.getNbFrames();
   if (info->fps1000)
     {
-      uint32_t
-	r,
-	s,
-	d;
+      uint32_t 	r,	s,	d;
       // we got 1000 * image /s
       // we want rate, scale and duration
       //
       s = 1000;
       r = info->fps1000;
-      double
-	u;
+      double	u;
       u = (double) info->fps1000;
       if (u < 10.)
-	u = 10.;
+            u = 10.;
       u = 1000000. / u;
       d = (uint32_t) floor (u);;	// 25 fps hard coded
-
-      //getVideoStreamHeader
-
-      AVIStreamHeader *ily =	_videos[0]._aviheader->	getVideoStreamHeader ();
+      AVIStreamHeader *ily =	_segments.getRefVideo(0)->_aviheader->	getVideoStreamHeader ();
       ily->dwRate = r;
       ily->dwScale = s;
       rebuildDuration();
     }
   return 1;
 }
-
+/**
+    \fn getVideoInfo
+*/
 uint8_t ADM_Composer::getVideoInfo (aviInfo * info)
 {
-  uint8_t
-    ret;
+  uint8_t    ret;
   ret = STUBB->getVideoInfo (info);
   if (ret)
     {
@@ -345,13 +185,11 @@
 //______________________________
 //    Info etc... to be removed later
 //______________________________
-AVIStreamHeader *
-ADM_Composer::getVideoStreamHeader (void)
+AVIStreamHeader *ADM_Composer::getVideoStreamHeader (void)
 {
   return STUBB->getVideoStreamHeader ();
 };
-MainAVIHeader *
-ADM_Composer::getMainHeader (void)
+MainAVIHeader *ADM_Composer::getMainHeader (void)
 {
   return STUBB->getMainHeader ();
 }
@@ -360,13 +198,16 @@
 {
   return STUBB->getBIH ();
 };
-//
+/**
+    \fn sanityCheckRef
 //	Do a sanity check for copy mode
 //	Check that B frames did not loose there backward/forward ref frame
 // 	It is brute force as we only need to check begin/end of each segment
 //	But it should be fast anyway
+*/
 uint8_t		ADM_Composer::sanityCheckRef(uint32_t start, uint32_t end,uint32_t *fatal)
 {
+#if 0
 uint32_t flags,seg;
 uint32_t lastnonb=0,segnonB=0xffff;
 uint32_t forward=0,forwardseg=0xffff;
@@ -440,34 +281,10 @@
 		printf("Frame %d has lost its fw/bw reference frame (%"LU"/%"LU")\n",i,start,end);
 	}
 	return ok;
+#endif
+    return true;
 }
-// return the segment holding the next reference frame
-//
-uint32_t ADM_Composer::searchForwardSeg(uint32_t startframe)
-{
-	uint32_t fw=startframe;
-	uint32_t flags,seg;
-	uint8_t r;
 
-			while(1)
-			{
-				fw++;
-				r=getFlagsAndSeg (fw, &flags,&seg);
-				if(!(flags & AVI_B_FRAME))
-				{
-					return seg;
-
-				}
-
-				if(!r)
-				{
-					seg=0xffff;
-					return seg;
-				}
-
-			}
-	return 1;
-}
 /**
     \fn getVideoDuration
     \brief returns duration of the video track
@@ -475,9 +292,7 @@
 */
 uint64_t ADM_Composer::getVideoDuration(void)
 {
-  if(_nb_segment)
-    return _videos[0]._aviheader->getVideoDuration();
-  return 0;
+    return _segments.getTotalDuration();
 }
 
 //EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp	2009-10-10 09:40:09 UTC (rev 5373)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp	2009-10-10 09:40:12 UTC (rev 5374)
@@ -27,22 +27,6 @@
 #include "fourcc.h"
 #include "ADM_editor/ADM_edit.hxx"
 
-#if 0
-
-#include "ADM_inputs/ADM_inpics/ADM_pics.h"
-#include "ADM_inputs/ADM_nuv/ADM_nuv.h"
-#include "ADM_inputs/ADM_h263/ADM_h263.h"
-//#include "ADM_3gp/ADM_3gp.h"
-#include "ADM_inputs/ADM_mp4/ADM_mp4.h"
-#include "ADM_inputs/ADM_openDML/ADM_openDML.h"
-#include "ADM_inputs/ADM_avsproxy/ADM_avsproxy.h"
-#include "ADM_inputs/ADM_matroska/ADM_mkv.h"
-//#include "ADM_inputs/ADM_flv/ADM_flv.h"
-#include "ADM_inputs/ADM_amv/ADM_amv.h"
-#include "ADM_inputs/ADM_asf/ADM_asf.h"
-#include "ADM_inputs/ADM_ogm/ADM_ogm.h"
-#endif
-
 #include "DIA_coreToolkit.h"
 #include "ADM_editor/ADM_edit.hxx"
 #include "ADM_videoFilter.h"
@@ -52,24 +36,21 @@
 #define MODULE_NAME MODULE_EDITOR
 #include "ADM_debug.h"
 
-#//include "ADM_inputs/ADM_mpegdemuxer/dmx_indexer.h"
 #include "ADM_outputfmt.h"
 #include "ADM_edPtsDts.h"
 
 vidHeader *ADM_demuxerSpawn(uint32_t magic,const char *name);
 
-int DIA_mpegIndexer (char **mpegFile, char **indexFile, int *aid,
-		     int already = 0);
-void DIA_indexerPrefill(char *name);
-extern uint8_t indexMpeg (char *mpeg, char *file, uint8_t aid);
-
-extern uint8_t loadVideoCodecConf( const char *name);
 extern uint8_t parseScript(char *name);
 uint8_t UI_SetCurrentFormat( ADM_OUT_FORMAT fmt );
 const char *VBR_MSG = QT_TR_NOOP("Avidemux detected VBR MP3 audio in this file. For keeping audio/video in sync, time map is needed. Build it now?\n\nYou can do it later with \"Audio -> Build VBR Time Map\".");
 //
 //
 
+#define ADM_warning printf
+#define ADM_info    printf
+#define ADM_error   printf
+
 #define TEST_MPEG2DEC
 
 ADM_Composer::ADM_Composer (void) : ADM_audioStream(NULL,NULL)
@@ -79,15 +60,12 @@
    packetBufferSize=0;
    packetBufferDts=ADM_NO_PTS;
 
-  _nb_segment = 0;
-  _nb_video = 0;
   _total_frames = 0;
   _audioseg = 0;
   _audiooffset = 0;
   _audioSample=0;
   _lastseg = 99;
   _lastframe = 99;
-  _nb_clipboard=0;
   _haveMarkers=0; // only edl have markers
   // Initialize a default postprocessing (dummy)
   initPostProc(&_pp,16,16);
@@ -102,11 +80,6 @@
   _imageBuffer=NULL;
   _internalFlags=0;
   // Start with a clean base
-  memset (_videos, 0, sizeof (_videos));
-  max_seg = MAX_SEG;
-  _segments = new _SEGMENT[max_seg];
-  memset (_segments, 0, sizeof (_segments));
-  _scratch=NULL;
 
 }
 /**
@@ -114,147 +87,65 @@
 
 */
 #define YOURAUDIO(x) _videos[x].audioTracks[_videos[x].currentAudioStream]
+/**
+    \fn resetSeg
+    \brief Redo a 1:1 mapping between ref video and segment
+*/
 uint8_t ADM_Composer::resetSeg( void )
 {
-	_total_frames=0;
-	for(uint32_t i=0;i<_nb_video;i++)
-	{
-		_segments[i]._reference = i;
-        if(_videos[i].audioTracks)
-            _segments[i]._audio_size = YOURAUDIO(i)->size;
-        else
-            _segments[i]._audio_size=0;
-  		_segments[i]._audio_start = 0;
-  		_segments[i]._start_frame = 0;
-		_segments[i]._audio_duration = 0;
-		_segments[i]._nb_frames   =   _videos[i]._nb_video_frames ;
-		_total_frames+=_segments[i]._nb_frames  ;
-		updateAudioTrack (i);
-	}
+	_segments.resetSegment();
 
-  	_nb_segment=_nb_video;
   	computeTotalFrames();
-	dumpSeg();
+//	dumpSeg();
 	return 1;
 }
 /**
-	Return extra Header info present in avi chunk that are needed to initialize
+    \fn getExtraHeaderData
+    \brief	Return extra Header info present in avi chunk that are needed to initialize
 	the video codec
 	It is assumed that there is only one file or can share the same init data
 	(huffyuv for example)
 */
-uint8_t ADM_Composer::getExtraHeaderData (uint32_t * len, uint8_t ** data)
+bool ADM_Composer::getExtraHeaderData (uint32_t * len, uint8_t ** data)
 {
-  return _videos[0]._aviheader->getExtraHeaderData (len, data);
-
+    if(_segments.getNbRefVideos())
+        return _segments.getRefVideo(0)->_aviheader->getExtraHeaderData (len, data);
+    *len=0;
+    *data=NULL;
+    return false;
 }
 
 
 /**
-	Purge all segments
+    \fn ADM_Composer
 */
-uint8_t ADM_Composer::deleteAllSegments (void)
-{
-
-
-  memset (_segments, 0, sizeof (_segments));
-  _nb_segment = 0;
-  _total_frames=computeTotalFrames();
-  return 1;
-
-}
-
-/**
-	\fn Purge all videos
-    \brief delete datas associated with all video
-*/
-void
-ADM_Composer::deleteAllVideos (void)
-{
-
-  for (uint32_t vid = 0; vid < _nb_video; vid++)
-    {
-
-      // if there is a video decoder...
-      if (_videos[vid].decoder)
-            delete _videos[vid].decoder;
-      if(_videos[vid].color)
-            delete _videos[vid].color;
-      // prevent from crashing
-      _videos[vid]._aviheader->close ();
-      delete _videos[vid]._aviheader;
-      if(_videos[vid]._videoCache)
-      	delete  _videos[vid]._videoCache;
-      _videos[vid]._videoCache=NULL;
-     // Delete audio codec too
-     // audioStream will be deleted by the demuxer
-      if(_videos[vid].audioTracks)
-      {
-            for(int i=0;i<_videos[vid].nbAudioStream;i++)
-            {
-                delete _videos[vid].audioTracks[i];
-            }
-            delete [] _videos[vid].audioTracks;
-            _videos[vid].audioTracks=NULL;
-      }
-    }
-
-  memset (_videos, 0, sizeof (_videos));
-
-
-  if(_imageBuffer)
-  	delete _imageBuffer;
-  _imageBuffer=NULL;
-
-}
-
 ADM_Composer::~ADM_Composer ()
 {
-	deleteAllSegments();
-	deleteAllVideos();
+	_segments.deleteAll();
 	deletePostProc(&_pp);
-
-	if(_segments)
-	{
-		delete[] _segments;
-		_segments=NULL;
-	}
-	if(_scratch)
-	{
-		delete _scratch;
-		_scratch=NULL;
-	}
 }
 
-/*
-   			Return Magic : 4*4 bytes first
 
-*/
-
 /**
     \fn addFile
     \brief	Load or append a file.	The file type is determined automatically and the ad-hoc video decoder is spawned
 
     @param name: filename
-    @param mode: 0 open, 1 append
-
-
     @return 1 on success, 0 on failure
 
 
 */
-uint8_t ADM_Composer::addFile (const char *name, uint8_t mode)
+bool ADM_Composer::addFile (const char *name)
 {
+
   uint8_t    ret =    0;
   aviInfo    info;
 
+  _VIDEOS video;
+    memset(&video,0,sizeof(video));
 
-
-UNUSED_ARG(mode);
 	_haveMarkers=0; // by default no markers are present
-  ADM_assert (_nb_segment < max_seg);
-  ADM_assert (_nb_video < MAX_VIDEO);
-
+  
     FILE *f=fopen(name,"r");
     uint8_t buffer[4];
     if(!f) return 0;
@@ -264,34 +155,37 @@
 
 
   // First find the demuxer....
-   	_videos[_nb_video]._aviheader=ADM_demuxerSpawn(magic,name);
-    if(!_videos[_nb_video]._aviheader)
+   	video._aviheader=ADM_demuxerSpawn(magic,name);
+    if(!video._aviheader)
     {
      char str[512+1];
      snprintf(str,512,QT_TR_NOOP("Cannot find a demuxer for %s"), name);
       str[512] = '\0';
       GUI_Error_HIG(str,NULL);
-      return 0;
+      return false;
     }
-    ret = _videos[_nb_video]._aviheader->open(name);
+    ret = video._aviheader->open(name);
    // check opening was successful
    if (ret == 0) {
      char str[512+1];
      snprintf(str,512,QT_TR_NOOP("Attempt to open %s failed!"), name);
       str[512] = '\0';
       GUI_Error_HIG(str,NULL);
-      delete _videos[_nb_video]._aviheader;
-      return 0;
+      video._aviheader;
+      video._aviheader=NULL;
+      return false;
    }
 
    /* check for resolution */
-   if( _nb_video ){
+   if( _segments.getNbRefVideos())
+    {
       /* append operation */
       aviInfo info0, infox;
-      _videos[   0     ]._aviheader->getVideoInfo (&info0);
-      _videos[_nb_video]._aviheader->getVideoInfo (&infox);
-      if( info0.width != infox.width || info0.height != infox.height ){
-        char str[512+1];
+      _segments.getRefVideo(0)->_aviheader->getVideoInfo (&info0);
+      video._aviheader->getVideoInfo (&infox);
+      if( info0.width != infox.width || info0.height != infox.height )
+        {
+         char str[512+1];
          str[0] = '\0';
          if( info0.width != infox.width )
             strcpy(str,"width");
@@ -302,80 +196,78 @@
                  (strlen(str)?" are ":" is ") );
          str[512] = '\0';
          GUI_Error_HIG(str,QT_TR_NOOP("You cannot mix different video dimensions yet. Using the partial video filter later, will not work around this problem. The workaround is:\n1.) \"resize\" / \"add border\" / \"crop\" each stream to the same resolution\n2.) concatinate them together"));
-         delete _videos[_nb_video]._aviheader;
-         return 0;
+         delete video._aviheader;
+         return false;
       }
    }
 
   // else update info
-  _videos[_nb_video]._aviheader->getVideoInfo (&info);
-  _videos[_nb_video]._aviheader->setMyName (name);
+  video._aviheader->getVideoInfo (&info);
+  video._aviheader->setMyName (name);
 
   // Printf some info about extradata
-  {
+  
     uint32_t l=0;
     uint8_t *d=NULL;
-    _videos[_nb_video]._aviheader->getExtraHeaderData(&l,&d);
+    video._aviheader->getExtraHeaderData(&l,&d);
     if(l && d)
     {
         printf("[Editor]The video codec has some extradata (%d bytes)\n",l);
         mixDump(d,l);
         printf("\n");
     }
-  }
+  
   // 1st if it is our first video we update postproc
- if(!_nb_video)
- {
+    if(!_segments.getNbRefVideos())
+    {
         uint32_t type,value;
 
         if(!prefs->get(DEFAULT_POSTPROC_TYPE,&type)) type=3;
         if(!prefs->get(DEFAULT_POSTPROC_VALUE,&value)) value=3;
 
-	deletePostProc(&_pp );
- 	initPostProc(&_pp,info.width,info.height);
-	_pp.postProcType=type;
-	_pp.postProcStrength=value;
-	_pp.forcedQuant=0;
-	updatePostProc(&_pp);
+        deletePostProc(&_pp );
+        initPostProc(&_pp,info.width,info.height);
+        _pp.postProcType=type;
+        _pp.postProcStrength=value;
+        _pp.forcedQuant=0;
+        updatePostProc(&_pp);
 
-	if(_imageBuffer) delete _imageBuffer;
-	_imageBuffer=new ADMImage(info.width,info.height);
- 	_imageBuffer->_qSize= ((info.width+15)>>4)*((info.height+15)>>4);
-	_imageBuffer->quant=new uint8_t[_imageBuffer->_qSize];
-    memset(_imageBuffer->quant,0,_imageBuffer->_qSize);
-	_imageBuffer->_qStride=(info.width+15)>>4;
- }
+        if(_imageBuffer) delete _imageBuffer;
+        _imageBuffer=new ADMImage(info.width,info.height);
+        _imageBuffer->_qSize= ((info.width+15)>>4)*((info.height+15)>>4);
+        _imageBuffer->quant=new uint8_t[_imageBuffer->_qSize];
+        memset(_imageBuffer->quant,0,_imageBuffer->_qSize);
+        _imageBuffer->_qStride=(info.width+15)>>4;
+    }
 
 
 //    fourCC::print( info.fcc );
-  _total_frames += info.nb_frames;
-  _videos[_nb_video]._nb_video_frames = info.nb_frames;
+    _total_frames += info.nb_frames;
 
 
+
   // Update audio infos
   // an spawn the appropriate decoder
   //_________________________
-   uint32_t nbAStream=_videos[_nb_video]._aviheader->getNbAudioStreams();
+   uint32_t nbAStream=video._aviheader->getNbAudioStreams();
 
   if (!nbAStream)
     {
       printf ("[Editor] *** NO AUDIO ***\n");
-      _videos[_nb_video].audioTracks = NULL;
-      _videos[_nb_video].nbAudioStream=0;
-      _videos[_nb_video].currentAudioStream=0;
+      video.audioTracks = NULL;
+      video.nbAudioStream=0;
+      video.currentAudioStream=0;
     }
   else
     {
         // Read and construct the audio tracks for that videos
-
-
       audioInfo *info;
       uint32_t extraLen;
       uint8_t  *extraData;
       ADM_audioStream *stream;
       WAVHeader *header;
 
-      _VIDEOS *thisVid=&(_videos[_nb_video]);
+      _VIDEOS *thisVid=&(video);
       // Create streams
       thisVid->audioTracks=new ADM_audioStreamTrack*[nbAStream];
       thisVid->nbAudioStream=nbAStream;
@@ -383,12 +275,11 @@
       {
             ADM_audioStreamTrack *track=new ADM_audioStreamTrack;
 
-
             header=thisVid->_aviheader->getAudioInfo(i );
             memcpy(&(track->wavheader),header,sizeof(*header));
 
             // We need at last fq so that advanceDts will work
-            if(!i && !_nb_video)
+            if(!i && !_segments.getNbRefVideos())
             {
                 wavHeader.frequency=header->frequency;
                 wavHeader.channels=header->channels;
@@ -407,7 +298,6 @@
             thisVid->audioTracks[i]=track;
 
       }
-//      printf("[Editor] Duration in seconds: %"LLU", in samples: %"LLU"\n",_videos[_nb_video]._audio_duration/_wavinfo->frequency,_videos[_nb_video]._audio_duration);
     }
 
   printf ("[Editor] Decoder FCC: ");
@@ -419,143 +309,23 @@
       info.fps1000 = 25 * 1000;
       updateVideoInfo (&info);
     }
-  uint32_t    	l;
-  uint8_t 	*d;
-  _videos[_nb_video]._aviheader->getExtraHeaderData (&l, &d);
-  _videos[_nb_video].decoder = getDecoder (info.fcc,  info.width, info.height, l, d,info.bpp);
 
-  _videos[_nb_video]._videoCache   =   new EditorCache(32,info.width,info.height) ;
+    // From here we cannot fail, let the segment handler make the other part of the job
+    _segments.addReferenceVideo(&video);
 
-  float frameD=info.fps1000;
-  frameD=frameD/1000;
-  frameD=1/frameD;
-  frameD*=1000000;
-  _videos[_nb_video].timeIncrementInUs=(uint64_t)frameD;
-  printf("[Editor] About %"LLU" microseconds per frame\n",_videos[_nb_video].timeIncrementInUs);
-
-  //
-  //  And automatically create the segment
-  //
-  if(_videos[_nb_video].audioTracks)
-    {
-        ADM_audioStreamTrack *trk=_videos[_nb_video].audioTracks[0];
-        _segments[_nb_segment]._audio_size = trk->size;
-        _segments[_nb_segment]._audio_duration =trk->duration;
-    }else
-    {
-        _segments[_nb_segment]._audio_size = 0;
-        _segments[_nb_segment]._audio_duration =0;
-    }
-
-  _segments[_nb_segment]._reference = _nb_video;
-  _segments[_nb_segment]._audio_start = 0;
-  _segments[_nb_segment]._start_frame = 0;
-  _segments[_nb_segment]._nb_frames   =   _videos[_nb_video]._nb_video_frames ;
-
-
-//****************************
-
-
-  // next one please
-#if 0
-        if(_videos[_nb_video].audioTracks)
-        {
-            WAVHeader *    _wavinfo=&(_videos[_nb_video].audioTracks[0]->wavheader);
-            if(_wavinfo->encoding==WAV_MP3 && _wavinfo->blockalign==1152)
-            {
-              uint32_t autovbr=0;
-              prefs->get(FEATURE_AUTO_BUILDMAP,&autovbr);
-              if(autovbr || GUI_Confirmation_HIG(QT_TR_NOOP("Build Time Map"),QT_TR_NOOP( "Build VBR time map?"), VBR_MSG))
-                    {
-                   // _videos[_nb_video]._isAudioVbr=_videos[_nb_video]._audiostream->buildAudioTimeLine ();
-                    }
-            }
-        }
-#endif
-        // Update frametype if needed...
-        _VIDEOS 	*vid;
-        vid=&(_videos[_nb_video]);
-        decoders *decoder=vid->decoder;
-        rederiveFrameType(_videos[_nb_video]._aviheader);
-
-
-        //
-        _nb_video++;
-        _nb_segment++;
-
-        //Update time stamps if needed....
-		vid->_reorderReady=0;
-        vid->_unpackReady=0;
-		// we only try if we got everything needed...
-		if(!vid->decoder)
-		{
-			printf("[Editor] no decoder to check for B- frame\n");
-		}else
-        {
-           
-            if(vid->_aviheader->providePts()==false) // Else we rely on demuxer PTS
-            {
-                printf("[Editor] This container does not provide PTS \n");
-                if(decoder->bFramePossible())
-                {
-                    printf("[Editor] B- frame possible with that codec \n");
-                    if(isMpeg4Compatible(info.fcc) || isMpeg12Compatible(info.fcc))
-                    {
-                        printf("[Editor] It is mpeg4-SP/ASP, try to guess all PTS\n");                        
-                        setMpeg4PtsFromDts(vid->_aviheader,vid->timeIncrementInUs);
-                    }
-                }
-                else   
-                {
-                        printf("[Editor] No B frame with that codec, PTS=DTS\n");
-                        setPtsEqualDts(vid->_aviheader,vid->timeIncrementInUs);
-                }
-            }
-        }
-		GoToIntra(0);
-        durationInUs=vid->_aviheader->getVideoDuration();
-		printf("[Editor] End of B-frame check\n");
-
   return 1;
 }
-/**
-	Send a re-order order to all video if
-		- They may need it
-		- It is not already done.
-*/
-uint8_t ADM_Composer::reorder (void)
-{
-_VIDEOS *vid;
-	for(uint32_t i=0;i<_nb_video;i++)
-	{
-		vid=&_videos[i];
-#if 0
-		if(!vid->_reorderReady) // not already reordered ?
-		{
-				if(vid->decoder->bFramePossible()) // can be re-ordered ?
-				{
-						if((vid->_reorderReady=vid->_aviheader->reorder()))
-						{
-							aviInfo    info;
-							_videos[i]._aviheader->getVideoInfo (&info);
 
-							printf(" Video %"LU" has been reordered\n",i);
-						}
-
-				}
-		}
-#endif
-	}
-	return 1;
-}
-/*
+/**
+    \fn hasVBRAudio
         If one of the videos has VBR audio we handle the whole editor audio has VBR
         If it is CBR, it is not harmful
         and it avoid loosing the VBR info in case we do VBR time map upon loading
 */
-uint8_t ADM_Composer::hasVBRVideos(void)
+bool ADM_Composer::hasVBRAudio(void)
 {
-        for(int i=0;i<_nb_video;i++)
+    int n=_segments.getNbRefVideos();
+        for(int i=0;i<n;i++)
         {
                 ADM_audioStreamTrack *trk=getTrack(i);
                 if(trk)
@@ -564,24 +334,29 @@
         return 0;
 }
 
-/*
+/**
+    \fn getPARWidth
 
 */
 uint32_t ADM_Composer::getPARWidth()
 {
-  if (_nb_video)
+  if (_segments.getNbRefVideos())
   {
-    return _videos[0].decoder->getPARWidth();
+    return _segments.getRefVideo(0)->decoder->getPARWidth();
   }
   return 1;
 
 }
+/**
+    \fn getPARHeight
 
+*/
+
 uint32_t ADM_Composer::getPARHeight()
 {
-  if (_nb_video)
+  if (_segments.getNbRefVideos())
   {
-    return _videos[0].decoder->getPARHeight();
+    return _segments.getRefVideo(0)->decoder->getPARHeight();
   }
   return 1;
 
@@ -591,29 +366,28 @@
 */
 uint64_t ADM_Composer::getFrameIncrement(void)
 {
-    if (!_nb_video) return 0;
-    return _videos[0].timeIncrementInUs;
+    if (!_segments.getNbSegments()) return 0;
+    return _segments.getRefVideo(0)->timeIncrementInUs;
 }
 /**
 	Set decoder settings (post process/swap u&v...)
 	for the segment referred by frame
 
 */
-uint8_t ADM_Composer::setDecodeParam (uint32_t frame)
+bool ADM_Composer::setDecodeParam (uint64_t time)
 {
-uint32_t seg,relframe,ref;
-  if (_nb_video)
+uint64_t offset;
+uint32_t ref;
+  if (_segments.getNbRefVideos())
   {
-   if (!convFrame2Seg (frame, &seg, &relframe))
+    if(false==_segments.getRefFromTime(time,&ref,&offset))
     {
-      printf ("\n Conversion failed !\n");
-      return 0;
+        ADM_warning("Cannot get ref from time %"LLD" ms\n",time/1000);
+        return false;
     }
-    // Search source
-     ref = _segments[seg]._reference;
-    _videos[ref].decoder->setParam ();
+    _segments.getRefVideo(ref)->decoder->setParam ();
   }
-  return 1;
+  return true;
 
 }
 
@@ -624,20 +398,10 @@
 */
 uint8_t ADM_Composer::cleanup (void)
 {
-  deleteAllSegments ();
-  deleteAllVideos ();
-  _nb_segment = 0;
-  _nb_video = 0;
-  _total_frames = 0;
-
-	if(_scratch)
-	{
-		delete _scratch;
-		_scratch=NULL;
-	}
-
+  _segments.deleteAll();
   return 1;
 }
+#if 0
 /*
         param:
                 source : source #
@@ -758,89 +522,97 @@
   return 1;
 
 }
+#endif
 /**
     \fn getAudioStreamsInfo
     \brief Returns a copy of all audio trackes at frame frame
     call delete [] infos when you dont need them anymore
 */
-uint8_t ADM_Composer::getAudioStreamsInfo(uint32_t frame,uint32_t *nbStreams, audioInfo **infos)
+bool ADM_Composer::getAudioStreamsInfo(uint64_t xtime,uint32_t *nbStreams, audioInfo **infos)
 {
-uint32_t seg,rel,reference;
 
-        if (!convFrame2Seg (frame, &seg, &rel))
-        {
-                printf("Editor : frame2seg failed (%u)\n",frame);
-                return 0;
-        }
-        reference=_segments[seg]._reference;
-        if(!_videos[reference].nbAudioStream)
-        {
-            *nbStreams=0;
-            *infos=NULL;
-        }
-       // return _videos[reference]._aviheader->getAudioStreamsInfo(nbStreams,infos);
+uint64_t offset;
+uint32_t ref;
+  
+    if(false==_segments.getRefFromTime(xtime,&ref,&offset))
+    {
+        ADM_warning("[Editor] getAudioStreamsInfo failed for time %"LLD" ms\n",xtime);
+        return false;
+    }
 
-        *nbStreams=_videos[reference].nbAudioStream;
-        *infos=new audioInfo[*nbStreams];
-        for(int i=0;i<*nbStreams;i++)
-        {
-            WAVHeader *wav=&(_videos[reference].audioTracks[i]->wavheader);
-            audioInfo *t=(*infos)+i;
-            t->bitrate=(wav->byterate*8)/1000;
-            t->channels=wav->channels;
-            t->encoding=wav->encoding;
-            t->frequency=wav->frequency;
-            t->av_sync=0;
-         }
-        return 1;
-    return 0;
+    _VIDEOS *v=_segments.getRefVideo(ref);
+    ADM_assert(v);
+
+    if(!v->nbAudioStream)
+    {
+        *nbStreams=0;
+        *infos=NULL;
+        return true;
+    }
+
+    *nbStreams=v->nbAudioStream;
+    *infos=new audioInfo[*nbStreams];
+    for(int i=0;i<*nbStreams;i++)
+    {
+        WAVHeader *wav=&(v->audioTracks[i]->wavheader);
+        audioInfo *t=(*infos)+i;
+        t->bitrate=(wav->byterate*8)/1000;
+        t->channels=wav->channels;
+        t->encoding=wav->encoding;
+        t->frequency=wav->frequency;
+        t->av_sync=0;
+     }
+    return true;
 }
-/*
-        Change the audio track for the source video attached to the "frame" frame
+/**
+    \fn getCurrentAudioStreamNumber
+    \brief Get stream number used for frame at position xtime
 
 */
-uint32_t ADM_Composer::getCurrentAudioStreamNumber(uint32_t frame)
+uint32_t ADM_Composer::getCurrentAudioStreamNumber(uint64_t  xtime)
 {
-uint32_t   seg,rel,reference;
+uint32_t ref;
+uint64_t offset;
 
-        if (!convFrame2Seg (frame, &seg, &rel))
+        if(false==_segments.getRefFromTime(xtime,&ref,&offset))  
         {
-                printf("Editor : frame2seg failed (%u)\n",frame);
-                return 0;
+            ADM_warning("[Editor::getCurrentAudioStreamNumber] Cannot get ref video for time %"LLD" ms\n",xtime/1000);
+            return 0;
         }
-        reference=_segments[seg]._reference;
 
-        return _videos[reference].currentAudioStream;
+        return _segments.getRefVideo(ref)->currentAudioStream;
 }
 /**
         \fn changeAudioStream
 
 */
-uint8_t ADM_Composer::changeAudioStream(uint32_t frame,uint32_t newstream)
+bool ADM_Composer::changeAudioStream(uint64_t xtime,uint32_t newstream)
 {
-uint32_t   seg,rel,reference;
 double     duration;
 WAVHeader *wav;
 aviInfo    info;
 
-        if (!convFrame2Seg (frame, &seg, &rel))
+       uint32_t ref;
+        uint64_t offset;
+
+        if(false==_segments.getRefFromTime(xtime,&ref,&offset))  
         {
-                printf("Editor : frame2seg failed (%u)\n",frame);
-                return 0;
+            ADM_warning("[Editor::changeAudioStream] Cannot get ref video for time %"LLD" ms\n",xtime/1000);
+            return 0;
         }
-        reference=_segments[seg]._reference;
-        ADM_audioStreamTrack **trks=_videos[reference].audioTracks;
-        uint32_t nb=_videos[reference].nbAudioStream;
+        _VIDEOS *v=_segments.getRefVideo(ref);
+        ADM_assert(v);
+        ADM_audioStreamTrack **trks=v->audioTracks;
+        uint32_t nb=v->nbAudioStream;
         if(newstream>=nb)
         {
-            return 0;
+            ADM_warning("[Editor::changeAudioStream] New stream exceeds # of stream (%d/%d)\n",(int)newstream,(int)nb);
+            return false;
         }
-        _videos[reference].currentAudioStream=newstream;
-        for(uint32_t i=0;i<_nb_segment;i++)
-                updateAudioTrack(i);
-        return 1;
+        v->currentAudioStream=newstream;
+        return true;
 }
-
+#if 0
 /**
 ______________________________________________________
 //
@@ -1020,12 +792,13 @@
   return 1;
 
 }
-
+#endif
 //____________________________________
 //      Remove empty segments
 //____________________________________
 uint32_t ADM_Composer::computeTotalFrames (void)
 {
+#if 0
   uint32_t
     seg,
     tf =
@@ -1037,8 +810,9 @@
     }
 
   return tf;
+#endif
 }
-
+#if 0
 //____________________________________
 //      Remove empty segments
 //____________________________________
@@ -1124,7 +898,7 @@
   updateAudioTrack (seg);
   return 1;
 }
-
+#endif
 //
 //      Update the real size of audio track by computing the
 // delta between sync @end and sync at begin
@@ -1133,6 +907,7 @@
 
 uint8_t ADM_Composer::updateAudioTrack (uint32_t seg)
 {
+#if 0
   // audio sync
   uint32_t
     pos_start,
@@ -1147,7 +922,7 @@
   if (!getTrack(reference))
     return 1;
 
-
+#endif
   return 1;
 
 #warning FIXME, does not work if audio track is shorter
@@ -1155,7 +930,7 @@
 }
 
 
-
+#if 0
 //__________________________________________________
 // check that the given frame is inside the segment
 //__________________________________________________
@@ -1190,16 +965,8 @@
 
 
 }
+#endif
 
-/**
-	Propagate VBR building to underlying segment
-
-*/
-void
-ADM_Composer::propagateBuildMap (void)
-{
-
-}
 //_________________________________________
 uint8_t		ADM_Composer::setEnv(_ENV_EDITOR_FLAGS newflag)
 {
@@ -1303,7 +1070,7 @@
 uint64_t    ADM_Composer::estimatePts(uint32_t frame)
 {
     uint32_t flags;
-    _VIDEOS *vid=&_videos[0];
+    _VIDEOS *vid=_segments.getRefVideo(0);
     vidHeader *demuxer=vid->_aviheader;
     int count=0;
     uint64_t  wantedPts;

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx	2009-10-10 09:40:09 UTC (rev 5373)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx	2009-10-10 09:40:12 UTC (rev 5374)
@@ -1,6 +1,6 @@
 /***************************************************************************
-                          ADM_edit.hxx  -  description
-                             -------------------
+     \file  ADM_edit.hxx  
+     \brief Editor class
     This file is the composer
     It presents the processed underlying files as if it was a flat
     file.
@@ -12,11 +12,8 @@
     	described by the segment
     	** NOT the beginning of the segment start_frame **
 
+    (C) 2002-2009 Mean, fixounet at free.Fr
 
-
-    begin                : Thu Feb 28 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
  ***************************************************************************/
 
 /***************************************************************************
@@ -38,10 +35,10 @@
 
  #include "ADM_audioStream.h"
  #include "ADM_audiocodec/ADM_audiocodec.h"
-#define MAX_SEG  	100 // Should be enougth
-#define MAX_VIDEO   100
+ #include "ADM_segment.h"
+ #include <vector>
 
-#define ADM_EDITOR_AUDIO_BUFFER_SIZE (128*1024)
+#define ADM_EDITOR_AUDIO_BUFFER_SIZE (128*1024*6*sizeof(float))
 
 
 typedef enum
@@ -53,95 +50,25 @@
     ENV_EDITOR_SMART=  0x0005,
 	ENV_EDITOR_LAST=   0x8000
 }_ENV_EDITOR_FLAGS;
-/**
-    \class ADM_audioStreamTack
 
-*/
-class ADM_audioStreamTrack
-{
-public:
-    ADM_audioStream  *stream;
-    audioInfo        *info;
-    ADM_Audiocodec   *codec;
-    WAVHeader		 wavheader;
-    bool             vbr;
-    uint64_t         duration;
-    uint64_t         size;
 
-public:
-    ADM_audioStreamTrack() {memset(this,0,sizeof(*this));}
-    ~ADM_audioStreamTrack()
-    {
-        stream=NULL;
-        info=NULL;   // These 2 are destroyed by the demuxer itself
-        if(codec) 
-        {
-            delete codec;
-            codec=NULL;
-        }
 
-    }
-};
-//
-//  The start frame correspond to the frame 0 of the segment (quite obvisous)
-//  _nb_video_frames is the number of active frame in the segment
-//
-//
-
-typedef struct
-{
-  	vidHeader 							*_aviheader;
-  	decoders							*decoder;
-    COL_Generic2YV12                    *color;
-
-	
-    uint32_t                            nbAudioStream;
-    uint32_t                            currentAudioStream;
-    ADM_audioStreamTrack                **audioTracks;
-
-	uint32_t							_nb_video_frames;	
-	uint8_t								_reorderReady;
-    uint8_t                             _unpackReady;
-	EditorCache							*_videoCache;
-    uint32_t                            lastSentFrame;   // Last frame read/sent to decoder
-    uint64_t                            lastDecodedPts;  // Pts of last frame out of decoder
-    uint64_t                            lastReadPts;     // Pts of the last frame we read
-    uint64_t                            timeIncrementInUs; // in case the video has no PTS, time increment (us)
-}_VIDEOS;
-
-
-typedef struct
-{
-  	uint32_t							_reference;
- 	uint32_t							_start_frame;
-	uint32_t							_nb_frames;
-	uint32_t  							_audio_size;
-	uint64_t							_audio_duration; //! IN SAMPLE
-	uint32_t							_seg_audio_duration;
-	uint32_t							_seg_video_duration;
- 	uint32_t  							_audio_start;
-}_SEGMENT;
 /**
             \class ADM_Composer
+            \brief Wrapper class that handles all the logic to seek/deal with multiple video files
+                        with editing
 */
 class ADM_Composer : public ADM_audioStream
 {
   private:
-                
-//    uint8_t                             audioBuffer[ADM_EDITOR_AUDIO_BUFFER_SIZE];
-//    uint32_t                            audioBufferStart;
-//    uint32_t                            audioBufferEnd;
-
-                    uint8_t dupe(ADMImage *src,ADMImage *dst,_VIDEOS *vid); 
+                    ADM_EditorSegment _segments;
+                    uint8_t     dupe(ADMImage *src,ADMImage *dst,_VIDEOS *vid); 
                                                             // Duplicate img, do colorspace
                                                             // if needed
   					uint32_t	_internalFlags;
   					ADM_PP 		_pp;
 					ADMImage	*_imageBuffer;
   					uint8_t		decodeCache(uint32_t frame,uint32_t seg, ADMImage *image);
-  					uint32_t 	_nb_segment;
-					uint32_t 	_nb_video;
-					uint32_t    _nb_clipboard;
   					uint32_t 	_total_frames;
   					uint32_t 	_audio_size;
   					// _audiooffset points to the offset / the total segment
@@ -153,160 +80,146 @@
                     
        				uint32_t _lastseg,_lastframe,_lastlen;
 
-					uint32_t	    max_seg;
-  					_SEGMENT 		*_segments;
-					_SEGMENT 		_clipboard[MAX_SEG];
-					_VIDEOS 		_videos[MAX_VIDEO];
-                    ADM_audioStreamTrack *getTrack(uint32_t i)
+                    ADM_audioStreamTrack *getTrack(uint32_t i);
+#if 0
                                             {
                                                 if(!_videos[i].audioTracks) return NULL;
                                                 return _videos[i].audioTracks[_videos[i].currentAudioStream];
-
                                             }
+#endif
                     ADMImage        *_scratch;
-						uint8_t  	convFrame2Seg(uint32_t framenum,uint32_t *seg,
-																			uint32_t *relframe);
-						uint8_t  	convSeg2Frame(	uint32_t *framenum,
-																			uint32_t seg,
-																			uint32_t relframe);
-						uint8_t 	crunch( void)																			;
-						uint8_t 	duplicateSegment( uint32_t segno);
-						uint32_t 	computeTotalFrames(void) ;
+                    uint8_t 	crunch( void)																			;
+                    uint8_t 	duplicateSegment( uint32_t segno);
+                    uint32_t 	computeTotalFrames(void) ;
 
-						uint8_t 	removeTo( 	uint32_t to, uint32_t seg,uint8_t included);
-						uint8_t 	removeFrom( uint32_t from, uint32_t seg,uint8_t included);
-						uint8_t 	checkInSeg( uint32_t seg, uint32_t frame);
-						uint8_t 	sanityCheck( void);
-				        uint8_t  	updateAudioTrack(uint32_t seg);			   	
-						void 		deleteAllVideos(void );
+                    uint8_t 	removeTo( 	uint32_t to, uint32_t seg,uint8_t included);
+                    uint8_t 	removeFrom( uint32_t from, uint32_t seg,uint8_t included);
+                    uint8_t 	checkInSeg( uint32_t seg, uint32_t frame);
+                    uint8_t 	sanityCheck( void);
+                    uint8_t  	updateAudioTrack(uint32_t seg);			   	
+                    void 		deleteAllVideos(void );
 
-						uint8_t 	getMagic(const char *name,uint32_t *magic);
+                    uint8_t 	getMagic(const char *name,uint32_t *magic);
 
-						uint32_t 	searchForwardSeg(uint32_t startframe);
-                        uint8_t     tryIndexing(const char *name, const char *idxname=NULL);
-                        bool        rederiveFrameType(vidHeader *demuxer);
+                    uint32_t 	searchForwardSeg(uint32_t startframe);
+                    uint8_t     tryIndexing(const char *name, const char *idxname=NULL);
+                    bool        rederiveFrameType(vidHeader *demuxer);
 
   public:
-                            uint8_t hasVBRVideos(void);
-                            uint8_t addSegment(uint32_t source,uint32_t start, uint32_t nb);
-                            uint8_t deleteAllSegments(void);
-  						uint8_t 	getExtraHeaderData(uint32_t *len, uint8_t **data);
-                            uint32_t getPARWidth(void);
-                            uint32_t getPARHeight(void);
-                            uint8_t  rebuildDuration(void);
+                    bool        hasVBRAudio(void);
+                    uint8_t     addSegment(uint32_t source,uint32_t start, uint32_t nb);
+                    uint8_t     deleteAllSegments(void);
+                    bool     	getExtraHeaderData(uint32_t *len, uint8_t **data);
+                    uint32_t    getPARWidth(void);
+                    uint32_t    getPARHeight(void);
+                    uint8_t     rebuildDuration(void);
   								ADM_Composer();
   				virtual 			~ADM_Composer();
-  						void		clean( void );
-  						void		dumpSeg(void);
-                        uint8_t     saveAsScript (const char *name, const char *out);
-						uint8_t 	saveWorbench(const char *name);
-						uint8_t 	loadWorbench(const char *name);
-						uint8_t     resetSeg( void );
-						uint8_t	    reorder( void );
-						uint8_t	    isReordered( uint32_t framenum ) {return true;}
-						uint8_t	    isIndexable( void);
-  				//_______________________
-  				// specific to composer
-  				//_______________________
-  						uint8_t 	addFile (const char *name, uint8_t mode=0);
-  						uint8_t 	cleanup( void);
-			   			uint8_t 	isMultiSeg( void) { if(_nb_segment>1) return 1; else return 0;}
-  						uint8_t 	removeFrames(uint32_t start,uint32_t end);
-  						uint8_t 	addFrameFrom(uint32_t to,uint32_t frombegin,uint32_t fromend);
-						uint8_t 	copyToClipBoard (uint32_t start, uint32_t end);
-						uint8_t 	pasteFromClipBoard (uint32_t whereto);
-  				//_____________________________
+                    void		clean( void );
+                    void		dumpSeg(void);
+                    uint8_t     saveAsScript (const char *name, const char *out);
+                    uint8_t 	saveWorbench(const char *name);
+                    uint8_t 	loadWorbench(const char *name);
+                    uint8_t     resetSeg( void );
+                    uint8_t	    reorder( void );
+                    uint8_t	    isReordered( uint32_t framenum ) {return true;}
+                    uint8_t	    isIndexable( void);
+            //_______________________
+            // specific to composer
+            //_______________________
+                    bool     	addFile (const char *name);
+                    uint8_t 	cleanup( void);
+                    bool 	    isMultiSeg( void);
+                    uint8_t 	removeFrames(uint32_t start,uint32_t end);
+                    uint8_t 	addFrameFrom(uint32_t to,uint32_t frombegin,uint32_t fromend);
+                    uint8_t 	copyToClipBoard (uint32_t start, uint32_t end);
+                    uint8_t 	pasteFromClipBoard (uint32_t whereto);
+            //_____________________________
   				// navigation & frame functions
   				//_____________________________
 /************************************* Markers *****************************/
 private:        
-                        uint64_t markerAPts,markerBPts;
+                    uint64_t    markerAPts,markerBPts;
 public:
-                        uint64_t    getMarkerAPts();
-                        uint64_t    getMarkerBPts();
-                        bool        setMarkerAPts(uint64_t pts);
-                        bool        setMarkerBPts(uint64_t pts);
+                    uint64_t    getMarkerAPts();
+                    uint64_t    getMarkerBPts();
+                    bool        setMarkerAPts(uint64_t pts);
+                    bool        setMarkerBPts(uint64_t pts);
 public:
 /************************************ Public API ***************************/
 protected:
-                        uint32_t    currentFrame;
+                    uint32_t    currentFrame;
 public:
-                        uint32_t    getCurrentFrame(void);
-                        
-                        bool        setCurrentFrame(uint32_t frame);
-                        bool        GoToIntra(uint32_t frame);
-                        bool        GoToTime(uint64_t time);
-                        bool        NextPicture(ADMImage *image);
-                        bool        samePicture(ADMImage *image);
-                        bool        getCompressedPicure(uint32_t framenum,ADMCompressedImage *img);
-                        uint64_t    estimatePts(uint32_t frame);
-                        uint32_t    searchFrameBefore(uint64_t pts);
-                        bool        getImageFromCacheForFrameBefore(uint64_t pts,ADMImage *out);
-                        bool        getPictureJustBefore(uint64_t pts);
-                        bool        getPtsDts(uint32_t frame,uint64_t *pts,uint64_t *dts);
+                    uint32_t    getCurrentFrame(void);
+                    
+                    bool        setCurrentFrame(uint32_t frame);
+                    bool        GoToIntra(uint32_t frame);
+                    bool        GoToTime(uint64_t time);
+                    bool        NextPicture(ADMImage *image);
+                    bool        samePicture(ADMImage *image);
+                    bool        getCompressedPicure(uint32_t framenum,ADMCompressedImage *img);
+                    uint64_t    estimatePts(uint32_t frame);
+                    uint32_t    searchFrameBefore(uint64_t pts);
+                    bool        getImageFromCacheForFrameBefore(uint64_t pts,ADMImage *out);
+                    bool        getPictureJustBefore(uint64_t pts);
+                    bool        getPtsDts(uint32_t frame,uint64_t *pts,uint64_t *dts);
 /************************************ Internal ******************************/
 public:
-                                    /// Decode frame and on until frame is popped out of decoders
-                        bool        DecodePictureUpToIntra(uint32_t frame,uint32_t ref);
-                                    /// compressed image->yb12 image image and do postproc/colorconversion
-                        bool        decompressImage(ADMImage *out,ADMCompressedImage *in,uint32_t ref);
-                                    /// Decode next image
-                        bool        DecodeNextPicture(uint32_t ref);
-                                    /// Get the next decoded picture
-                        bool     	getNextPicture(ADMImage *out,uint32_t ref);
-                                    /// Get again last decoded picture
-                        bool        getSamePicture(ADMImage *out,uint32_t ref);
+                                /// Decode frame and on until frame is popped out of decoders
+                    bool        DecodePictureUpToIntra(uint32_t frame,uint32_t ref);
+                                /// compressed image->yb12 image image and do postproc/colorconversion
+                    bool        decompressImage(ADMImage *out,ADMCompressedImage *in,uint32_t ref);
+                                /// Decode next image
+                    bool        DecodeNextPicture(uint32_t ref);
+                                /// Get the next decoded picture
+                    bool     	getNextPicture(ADMImage *out,uint32_t ref);
+                                /// Get again last decoded picture
+                    bool        getSamePicture(ADMImage *out,uint32_t ref);
 /************************************ Internal ******************************/
-  						uint8_t 	getFrame(uint32_t   framenum,ADMCompressedImage *img,uint8_t *isSequential);
-						
-   					
-	          			uint64_t 	getTime(uint32_t fn);
-						uint32_t 	getFlags(uint32_t frame,uint32_t *flags);
-						uint8_t   	isSequential (uint32_t framenum);
-								// B follow A with just Bframes in between
-						uint8_t 	sequentialFramesB(uint32_t frameA,uint32_t frameB);
-						uint32_t 	getFlagsAndSeg (uint32_t frame, 
-									uint32_t * flags,uint32_t *segs);
-						uint8_t  	setFlag(uint32_t frame,uint32_t flags);
-						uint8_t	    updateVideoInfo(aviInfo *info);
+                    uint8_t 	getFrame(uint32_t   framenum,ADMCompressedImage *img,uint8_t *isSequential);
+                    
+                
+                    uint64_t 	getTime(uint32_t fn);
+                    uint32_t 	getFlags(uint32_t frame,uint32_t *flags);
+                    uint8_t   	isSequential (uint32_t framenum);
+                            // B follow A with just Bframes in between
+                    uint8_t 	sequentialFramesB(uint32_t frameA,uint32_t frameB);
+                    uint32_t 	getFlagsAndSeg (uint32_t frame, 
+                                uint32_t * flags,uint32_t *segs);
+                    uint8_t  	setFlag(uint32_t frame,uint32_t flags);
+                    uint8_t	    updateVideoInfo(aviInfo *info);
 
-						uint8_t  	getFrameSize(uint32_t frame,uint32_t *size) ;
-						uint8_t		sanityCheckRef(uint32_t start, uint32_t end,
-									uint32_t *fatal);
-                                                uint8_t         hasPtsDts(uint32_t ); // Return 1 if the container gives PTS & DTS info
-                                                uint32_t        ptsDtsDelta(uint32_t framenum) ;
-					//*******************************************	
-						uint32_t 	getSpecificMpeg4Info( void );
+                    uint8_t  	getFrameSize(uint32_t frame,uint32_t *size) ;
+                    uint8_t		sanityCheckRef(uint32_t start, uint32_t end,
+                                uint32_t *fatal);
+                                            uint8_t         hasPtsDts(uint32_t ); // Return 1 if the container gives PTS & DTS info
+                                            uint32_t        ptsDtsDelta(uint32_t framenum) ;
+                //*******************************************	
+                    uint32_t 	getSpecificMpeg4Info( void );
 /************************************ audioStream ******************************/
 protected:
 #define ADM_EDITOR_PACKET_BUFFER_SIZE (20*1024)
-                        uint8_t  packetBuffer[ADM_EDITOR_PACKET_BUFFER_SIZE];
-                        uint32_t packetBufferSize;
-                        uint64_t packetBufferDts;
-                        uint32_t packetBufferSamples;
-                        bool     refillPacketBuffer(void);
+                    uint8_t  packetBuffer[ADM_EDITOR_PACKET_BUFFER_SIZE];
+                    uint32_t packetBufferSize;
+                    uint64_t packetBufferDts;
+                    uint32_t packetBufferSamples;
+                    bool     refillPacketBuffer(void);
   
 public:
-        
-virtual uint8_t         getPacket(uint8_t *buffer,uint32_t *size, uint32_t sizeMax,uint32_t *nbSample,uint64_t *dts);
-        uint8_t         getPCMPacket(float  *dest, uint32_t sizeMax, uint32_t *samples,uint64_t *odts);
-virtual bool            goToTime(uint64_t nbUs);
-        bool            getExtraData(uint32_t *l, uint8_t **d);
-        uint64_t        getDurationInUs(void) {return durationInUs;}
-        uint8_t			getAudioStream(ADM_audioStream **audio);
-virtual WAVHeader       *getInfo(void);
-virtual CHANNEL_TYPE    *getChannelMapping(void );
+                    
+            virtual uint8_t         getPacket(uint8_t *buffer,uint32_t *size, uint32_t sizeMax,uint32_t *nbSample,uint64_t *dts);
+                    uint8_t         getPCMPacket(float  *dest, uint32_t sizeMax, uint32_t *samples,uint64_t *odts);
+            virtual bool            goToTime(uint64_t nbUs);
+                    bool            getExtraData(uint32_t *l, uint8_t **d);
+                    uint64_t        getDurationInUs(void) {return durationInUs;}
+                    uint8_t			getAudioStream(ADM_audioStream **audio);
+            virtual WAVHeader       *getInfo(void);
+            virtual CHANNEL_TYPE    *getChannelMapping(void );
 /************************************ /audioStream ******************************/
-					//______________________________
-					//   /audioStream
-					//______________________________
-                    uint8_t         getAudioStreamsInfo(uint32_t frame,uint32_t *nbStreams, audioInfo **infos);
-                    uint8_t         changeAudioStream(uint32_t frame,uint32_t newstream);
-                    uint32_t        getCurrentAudioStreamNumber(uint32_t frame);
-
-                    // /other audio stuff
-
-			     		uint8_t 			setDecodeParam( uint32_t frame );
+                    bool            getAudioStreamsInfo(uint64_t xtime,uint32_t *nbStreams, audioInfo **infos);
+                    bool            changeAudioStream(uint64_t xtime,uint32_t newstream);
+                    uint32_t        getCurrentAudioStreamNumber(uint64_t xframe);
+                    bool    		setDecodeParam( uint64_t frameTime );
 /**************************************** Video Info **************************/
 	 				AVIStreamHeader 	*getVideoStreamHeader(void ) ;
 	 				MainAVIHeader 		*getMainHeader(void );
@@ -319,34 +232,28 @@
 /**************************************** /Video Info **************************/					
 					
 					
-                  //
-                  //	Coder/decoder
-                  //
-		  			// Search previous/ next key frame
-		  			uint8_t			getPKFrame(uint32_t *frame);
-					uint8_t			getNKFrame(uint32_t *frame);
-					//
-                  			uint8_t			getUncompressedFrame(uint32_t frame,ADMImage *out,
-									uint32_t *flagz=NULL)    ;
-protected:					// Obsolete									
-              				uint8_t			searchNextKeyFrame(uint32_t in,uint32_t *oseg, uint32_t * orel);
-                 			uint8_t			searchPreviousKeyFrame(uint32_t in,uint32_t *oseg, uint32_t * orel);
+/***************************************** Seeking *****************************/            
+		  			bool			getPKFrame(uint32_t *frame);
+					bool			getNKFrame(uint32_t *frame);
+					
+                    bool			getUncompressedFrame(uint32_t frame,ADMImage *out,uint32_t *flagz=NULL);
 public:
-                  // kludg
-                  			void 			propagateBuildMap( void );
-
-			
-					uint8_t 		getMarkers(uint32_t *start, uint32_t *end);
-								 // get markers from file
-					uint8_t 		setPostProc( uint32_t type, uint32_t strength, 
-										uint32_t swapuv);
-					uint8_t 		getPostProc( uint32_t *type, uint32_t *strength, 
-										uint32_t *swapuv);
-										
-				
+                    
+/******************************* Post Processing ************************************/
+					uint8_t 		setPostProc( uint32_t type, uint32_t strength,	uint32_t swapuv);
+					uint8_t 		getPostProc( uint32_t *type, uint32_t *strength,uint32_t *swapuv);
+/******************************* /Post Processing ************************************/										
+/******************************* Misc ************************************/				
 					uint8_t			setEnv(_ENV_EDITOR_FLAGS newflag);
 					uint8_t			getEnv(_ENV_EDITOR_FLAGS newflag);
 					decoders 		*rawGetDecoder(uint32_t frame);
+/******************************* /Misc ************************************/				
+/***** OBSOLETE API *****/
+/***** OBSOLETE API *****/
+/***** OBSOLETE API *****/
+protected:					// Obsolete									
+                    uint8_t			searchNextKeyFrame(uint32_t in,uint32_t *oseg, uint32_t * orel);
+                    uint8_t			searchPreviousKeyFrame(uint32_t in,uint32_t *oseg, uint32_t * orel);
 
 };
 #endif

Added: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_editInternal.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_editInternal.h	2009-10-10 09:40:09 UTC (rev 5373)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_editInternal.h	2009-10-10 09:40:12 UTC (rev 5374)
@@ -0,0 +1,4 @@
+/**
+    \file ADM_editInternal.h
+
+*/
\ No newline at end of file

Added: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp	2009-10-10 09:40:09 UTC (rev 5373)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp	2009-10-10 09:40:12 UTC (rev 5374)
@@ -0,0 +1,289 @@
+/***************************************************************************
+     \file  ADM_segment.h
+     \brief Handle segment
+
+    (C) 2002-2009 Mean, fixounet at free.Fr
+
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "ADM_default.h"
+#include "ADM_segment.h"
+ #include "../ADM_codecs/ADM_codec.h"
+ #include "ADM_image.h"
+ #include "../ADM_editor/ADM_edCache.h"
+ #include "ADM_pp.h"
+ #include "ADM_colorspace.h"
+
+
+#define ADM_warning printf
+#define ADM_info    printf
+#define ADM_error   printf
+
+ADM_EditorSegment::ADM_EditorSegment(void)
+{
+
+}
+ADM_EditorSegment::~ADM_EditorSegment()
+{
+    deleteAll();
+}
+/**
+    \fn addReferenceVideo
+    \brief Add a new source video, fill in the missing info + create automatically the matching seg
+*/
+bool        ADM_EditorSegment::addReferenceVideo(_VIDEOS *ref)
+{
+  uint32_t    	l;
+  uint8_t 	    *d;
+  aviInfo       info;
+  _SEGMENT      seg;
+
+  memset(&seg,0,sizeof(seg));
+
+  ref->_aviheader->getVideoInfo (&info);
+  ref->_aviheader->getExtraHeaderData (&l, &d);
+  ref->decoder = getDecoder (info.fcc,  info.width, info.height, l, d,info.bpp);
+  ref->_videoCache   =   new EditorCache(32,info.width,info.height) ;
+
+  float frameD=info.fps1000;
+  frameD=frameD/1000;
+  frameD=1/frameD;
+  frameD*=1000000;
+  ref->timeIncrementInUs=(uint64_t)frameD;
+  ADM_info("[Editor] About %"LLU" microseconds per frame\n",ref->timeIncrementInUs);
+  ref->_nb_video_frames = info.nb_frames;
+  //
+  //  And automatically create the segment
+  //
+  seg._reference=videos.size();
+  if(!videos.size())
+  {
+        seg._startTimeUs=0;
+  }else
+  {
+      #warning todo compute cumulative time
+   }
+   seg._durationUs=ref->_aviheader->getVideoDuration();
+
+    // Update frametype if needed...
+    _VIDEOS 	*vid=ref;
+    decoders *decoder=vid->decoder;
+//    rederiveFrameType(_videos[_nb_video]._aviheader);
+
+#if 0
+    // we only try if we got everything needed...
+    if(!vid->decoder)
+    {
+        printf("[Editor] no decoder to check for B- frame\n");
+    }else
+    {
+       
+        if(vid->_aviheader->providePts()==false) // Else we rely on demuxer PTS
+        {
+            printf("[Editor] This container does not provide PTS \n");
+            if(decoder->bFramePossible())
+            {
+                printf("[Editor] B- frame possible with that codec \n");
+                if(isMpeg4Compatible(info.fcc) || isMpeg12Compatible(info.fcc))
+                {
+                    printf("[Editor] It is mpeg4-SP/ASP, try to guess all PTS\n");                        
+                    setMpeg4PtsFromDts(vid->_aviheader,vid->timeIncrementInUs);
+                }
+            }
+            else   
+            {
+                    printf("[Editor] No B frame with that codec, PTS=DTS\n");
+                    setPtsEqualDts(vid->_aviheader,vid->timeIncrementInUs);
+            }
+        }
+     }
+#endif    
+    segments.push_back(seg);
+    videos.push_back(*ref);
+    updateStartTime();
+    return true;
+}
+
+/**
+    \fn deleteAll
+    \brief Delete all segments & ref video
+*/
+bool        ADM_EditorSegment::deleteAll(void)
+{
+#warning todo
+    return true;
+}
+
+#if 0
+/**
+	\fn Purge all videos
+    \brief delete datas associated with all video
+*/
+void getFlags::deleteAllVideos (void)
+{
+
+  for (uint32_t vid = 0; vid < _videos.size(); vid++)
+    {
+
+      // if there is a video decoder...
+      if (_videos[vid].decoder)
+            delete _videos[vid].decoder;
+      if(_videos[vid].color)
+            delete _videos[vid].color;
+      // prevent from crashing
+      _videos[vid]._aviheader->close ();
+      delete _videos[vid]._aviheader;
+      if(_videos[vid]._videoCache)
+      	delete  _videos[vid]._videoCache;
+      _videos[vid]._videoCache=NULL;
+     // Delete audio codec too
+     // audioStream will be deleted by the demuxer
+      if(_videos[vid].audioTracks)
+      {
+            for(int i=0;i<_videos[vid].nbAudioStream;i++)
+            {
+                delete _videos[vid].audioTracks[i];
+            }
+            delete [] _videos[vid].audioTracks;
+            _videos[vid].audioTracks=NULL;
+      }
+    }
+
+   if(_videos.size())
+    {
+        _videos.erase(_videos.begin(),_videos.begin()+_videos.size()-1);
+    }
+
+
+  if(_imageBuffer)
+  	delete _imageBuffer;
+  _imageBuffer=NULL;
+
+}
+
+}
+#endif
+/**
+    \fn resetSegment
+    \brief Redo a 1:1 mapping between videos and segments
+*/
+bool        ADM_EditorSegment::resetSegment(void)
+{
+    //
+    
+    segments.clear();
+    int n=videos.size();
+    for(int i=0;i<n;i++)
+    {
+        _SEGMENT seg;
+        _VIDEOS  *vid=&(videos[i]);
+        memset(&seg,0,sizeof(seg));
+        seg._durationUs=vid->_aviheader->getVideoDuration();
+        seg._reference=i;
+    }
+    updateStartTime();
+    return true;
+}
+/**
+    \fn getRefVideo
+    \brief getRefVideo
+*/
+_VIDEOS     *ADM_EditorSegment::getRefVideo(int i)
+{
+    ADM_assert(i<videos.size());
+    return &(videos[i]);
+}
+/**
+    \fn getNbRefVideo
+    \brief getNbRefVideo
+*/
+int         ADM_EditorSegment::getNbRefVideos(void)
+{
+    return videos.size();
+}
+/**
+    \fn getNbSegment
+    \brief  getNbSegment
+*/
+int         ADM_EditorSegment::getNbSegments(void)
+{   
+    return segments.size();
+}
+/**
+    \fn updateStartTime
+    \brief Recompute the start time of the video 
+*/
+bool         ADM_EditorSegment::updateStartTime(void)
+{   
+    int n=segments.size();
+    uint64_t t=0;
+    for(int i=0;i<n;i++)
+    {
+        segments[i]._startTimeUs=t;
+        t+=segments[i]._durationUs;
+    }
+    return true;
+}
+/**
+    \fn getTotalDuration
+    \brief 
+*/
+uint64_t ADM_EditorSegment::getTotalDuration(void)
+{
+    uint64_t dur=0;
+    int n=segments.size();
+    for(int i=0;i<n;i++)
+        dur+=segments[i]._durationUs;
+    return dur;
+
+}
+/**
+    \fn getNbFrames
+    \brief 
+*/
+uint32_t ADM_EditorSegment::getNbFrames(void)
+{
+    uint32_t dur;
+    uint32_t nb=0;
+    int n=videos.size();
+    for(int i=0;i<n;i++)
+        dur+=videos[i]._nb_video_frames;
+    return nb;
+
+}
+/**
+    \fn getTotalDuration
+*/
+bool        ADM_EditorSegment::getRefFromTime(uint64_t time,uint32_t *refVideo, uint64_t *offset)
+{
+    *offset=time;
+    *refVideo=0;
+    return true;
+}
+/**
+    \fn getRefFromFrame
+*/
+bool        ADM_EditorSegment::getRefFromFrame(uint32_t frame,uint32_t *refVideo, uint32_t *frameOffset)
+{
+    *refVideo=0;
+    *frameOffset=frame;
+    return true;
+}
+/**
+    \fn getFrameFromRef
+*/
+bool        ADM_EditorSegment::getFrameFromRef(uint32_t *frame,uint32_t refVideo, uint32_t frameOffset)
+{
+    *frame=frameOffset;
+    return true;
+
+}
+//EOF

Added: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.h	2009-10-10 09:40:09 UTC (rev 5373)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.h	2009-10-10 09:40:12 UTC (rev 5374)
@@ -0,0 +1,131 @@
+/***************************************************************************
+     \file  ADM_segment.h
+     \brief Handle segment
+
+    (C) 2002-2009 Mean, fixounet at free.Fr
+
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef ADM_SEGMENT_H
+#define ADM_SEGMENT_H
+#include <vector>
+class ADM_audioStream;
+class ADM_Audiocodec;
+class decoders;
+class COL_Generic2YV12;
+class EditorCache;
+#include "ADM_Video.h"
+/**
+    \class ADM_audioStreamTack
+    \brief Place Holder for demuxer audio tracks.
+*/
+class ADM_audioStreamTrack
+{
+public:
+    ADM_audioStream  *stream;
+    audioInfo        *info;
+    ADM_Audiocodec   *codec;
+    WAVHeader		 wavheader;
+    bool             vbr;
+    uint64_t         duration;
+    uint64_t         size;
+
+public:
+    ADM_audioStreamTrack() {memset(this,0,sizeof(*this));}
+    ~ADM_audioStreamTrack()
+    {
+        stream=NULL;
+        info=NULL;   // These 2 are destroyed by the demuxer itself
+        if(codec) 
+        {
+            delete codec;
+            codec=NULL;
+        }
+    }
+};
+/**
+    \struct _VIDEOS
+    \brief The _VIDEOS struct is a video we have loaded.
+*/
+typedef struct
+{
+  	vidHeader 							*_aviheader;  /// Demuxer
+  	decoders							*decoder;     /// Video codec
+    COL_Generic2YV12                    *color;       /// Color conversion if needed
+
+	/* Audio part */
+
+    uint32_t                            nbAudioStream;   
+    uint32_t                            currentAudioStream;
+    ADM_audioStreamTrack                **audioTracks;
+
+	uint32_t							_nb_video_frames;  /// Really needed ?	
+	EditorCache							*_videoCache;      /// Decoded video cache
+
+    /* Timeing info */
+
+    uint32_t                            lastSentFrame;     /// Last frame read/sent to decoder
+    uint64_t                            lastDecodedPts;    /// Pts of last frame out of decoder
+    uint64_t                            lastReadPts;       /// Pts of the last frame we read
+    uint64_t                            timeIncrementInUs; /// in case the video has no PTS, time increment (us)
+}_VIDEOS;
+
+/**
+    \struct _SEGMENT
+    \brief The video is a collection of segment.
+            Each segment refers to its source (the reference) and the part of the source the segment is made of.
+*/
+typedef struct
+{
+  	uint32_t							_reference;       /// Reference video
+ 	uint64_t							_refStartTimeUs;  /// Starting time in reference
+    uint64_t                            _startTimeUs;     /// Start time in current (=sum(_duration of previous seg))
+	uint64_t							_durationUs;      ///
+
+}_SEGMENT;
+/*
+    Use vectors to store our videos & segments
+*/
+typedef std::vector <_VIDEOS>  ListOfVideos;
+typedef std::vector <_SEGMENT> ListOfSegments;
+
+/**
+    \class ADM_EditorSegment
+*/
+class ADM_EditorSegment
+{
+protected:
+        ListOfSegments segments;
+        ListOfVideos   videos;
+        bool           updateStartTime(void);
+
+public:
+                        ADM_EditorSegment(void);
+                        ~ADM_EditorSegment();
+            bool        addReferenceVideo(_VIDEOS *ref);
+            bool        deleteAll(void);
+            bool        resetSegment(void);
+
+            _VIDEOS     *getRefVideo(int i);
+            int         getNbRefVideos(void);
+
+            int         getNbSegments(void);
+            uint64_t    getTotalDuration(void);
+            uint32_t    getNbFrames(void);
+
+            bool        getRefFromTime(uint64_t time,uint32_t *refVideo, uint64_t *offset);
+            bool        getRefFromFrame(uint32_t frame,uint32_t *refVideo, uint32_t *frameOffset);
+            bool        getFrameFromRef(uint32_t *frame,uint32_t refVideo, uint32_t frameOffset);
+
+};
+
+#endif
+//EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADMedAVIAUD.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADMedAVIAUD.cpp	2009-10-10 09:40:09 UTC (rev 5373)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADMedAVIAUD.cpp	2009-10-10 09:40:12 UTC (rev 5374)
@@ -261,6 +261,16 @@
     return trk->stream->getExtraData(l,d); 
 
 }
+/**
+    \fn getTrack
+*/
+ADM_audioStreamTrack *ADM_Composer::getTrack(uint32_t i)
+{
+    _VIDEOS *v=_segments.getRefVideo(0);
+    if(!v->audioTracks) return NULL;
 
+    return v->audioTracks[v->currentAudioStream];
+}
+
 //EOF
 

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/CMakeLists.txt	2009-10-10 09:40:09 UTC (rev 5373)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/CMakeLists.txt	2009-10-10 09:40:12 UTC (rev 5374)
@@ -10,6 +10,7 @@
 ADM_edMarker.cpp
 ADM_edStub.cpp
 ADM_edPtsDts.cpp
+ADM_segment.cpp
 )
 
 ADD_LIBRARY(ADM_editor6 STATIC ${ADM_editor_SRCS})

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script/ADM_JSAvidemux.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script/ADM_JSAvidemux.cpp	2009-10-10 09:40:09 UTC (rev 5373)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script/ADM_JSAvidemux.cpp	2009-10-10 09:40:12 UTC (rev 5374)
@@ -418,7 +418,7 @@
                 return JS_FALSE;
         printf("clearing segments \n");
         enterLock();
-        *rval = BOOLEAN_TO_JSVAL(video_body->deleteAllSegments());
+//        *rval = BOOLEAN_TO_JSVAL(video_body->deleteAllSegments());
 	leaveLock();
         updateAll();
         return JS_TRUE;
@@ -441,7 +441,7 @@
         int c = JSVAL_TO_INT(argv[2]);
         aprintf("adding segment :%d %d %d\n",a,b,c);
         enterLock();
-        *rval = BOOLEAN_TO_JSVAL( video_body->addSegment(a,b,c));
+//        *rval = BOOLEAN_TO_JSVAL( video_body->addSegment(a,b,c));
 	leaveLock();
         updateAll();
         return JS_TRUE;

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script/ADM_JSAvidemuxVideo.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script/ADM_JSAvidemuxVideo.cpp	2009-10-10 09:40:09 UTC (rev 5373)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script/ADM_JSAvidemuxVideo.cpp	2009-10-10 09:40:12 UTC (rev 5374)
@@ -166,7 +166,7 @@
                 return JS_FALSE;
         printf("Clearing Video... \n");
         enterLock();
-        *rval = BOOLEAN_TO_JSVAL(video_body->deleteAllSegments());
+//        *rval = BOOLEAN_TO_JSVAL(video_body->deleteAllSegments());
         leaveLock();
         return JS_TRUE;
 }// end Clear
@@ -183,7 +183,7 @@
                 return JS_FALSE;
         printf("Adding Video... \n");
         enterLock();
-        *rval = BOOLEAN_TO_JSVAL(video_body->addSegment(JSVAL_TO_INT(argv[0]),JSVAL_TO_INT(argv[1]),JSVAL_TO_INT(argv[2])));
+//        *rval = BOOLEAN_TO_JSVAL(video_body->addSegment(JSVAL_TO_INT(argv[0]),JSVAL_TO_INT(argv[1]),JSVAL_TO_INT(argv[2])));
         leaveLock();
         return JS_TRUE;
 }// end Add

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp	2009-10-10 09:40:09 UTC (rev 5373)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp	2009-10-10 09:40:12 UTC (rev 5374)
@@ -385,7 +385,7 @@
       		if( frameEnd < frameStart ){
                   GUI_Error_HIG(QT_TR_NOOP("Marker A > B"), QT_TR_NOOP("Cannot copy."));
       		}else{
-    		   video_body->copyToClipBoard (frameStart,frameEnd);
+//    		   video_body->copyToClipBoard (frameStart,frameEnd);
       		}
 		break;
     case ACT_Paste:
@@ -590,12 +590,7 @@
   ** we may get a relative path by cmdline
   */
   longname = ADM_PathCanonize(name);
-  if (mode)
-    res = video_body->addFile (longname, 1);
-  else
-  {
-    res = video_body->addFile (longname);
-  }
+  res = video_body->addFile (longname);
 //  DIA_StopBusy ();
 
   // forget last project file
@@ -778,7 +773,7 @@
 //  DIA_StopBusy ();
 
 
-  video_body->dumpSeg ();
+//  video_body->dumpSeg ();
   if (!video_body->updateVideoInfo (avifileinfo))
     {
       GUI_Error_HIG (QT_TR_NOOP("Something bad happened (II)"), NULL);
@@ -904,6 +899,7 @@
 */
 void A_videoCheck( void)
 {
+#if 0
 uint32_t nb=0;
 //uint32_t buf[720*576*2];
 uint32_t error=0;
@@ -936,7 +932,7 @@
 
 	}
 	GUI_GoToFrame(0);
-
+#endif
 }
 int A_delete(uint32_t start, uint32_t end)
 {
@@ -956,13 +952,14 @@
 	  return 0;
 	}
 
-      video_body->dumpSeg ();
-      if (!video_body->removeFrames (start, end))
+//      video_body->dumpSeg ();
+//      if (!video_body->removeFrames (start, end))
+    if(0)
 	{
           GUI_Error_HIG (QT_TR_NOOP("Something bad happened"), NULL);
 	  return 0;
 	}
-      video_body->dumpSeg ();
+//      video_body->dumpSeg ();
       //resync GUI and video
       if (!video_body->updateVideoInfo (avifileinfo))
 	{
@@ -1238,8 +1235,8 @@
 */
 uint8_t GUI_getFrameContent(ADMImage *image, uint32_t frame)
 {
-  uint32_t flags;
-  if(!video_body->getUncompressedFrame(frame,image,&flags)) return 0;
+//  uint32_t flags;
+//  if(!video_body->getUncompressedFrame(frame,image,&flags)) return 0;
   return 1;
 }
 /**
@@ -1285,7 +1282,7 @@
 
 
   GUI_close();
-  res = video_body->addFile ("avsproxy.avs",0);
+  res = video_body->addFile ("avsproxy.avs");
   // forget last project file
   if( actual_workbench_file ){
      ADM_dealloc(actual_workbench_file);

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/gui_blackframes.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/gui_blackframes.cpp	2009-10-10 09:40:09 UTC (rev 5373)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/gui_blackframes.cpp	2009-10-10 09:40:12 UTC (rev 5374)
@@ -141,6 +141,7 @@
 
 void GUI_NextPrevBlackFrame(int dir)
 {
+#if 0
    uint32_t f;
    uint32_t flags;
    uint16_t reresh_count=0;
@@ -197,7 +198,7 @@
    }
 //    admPreview::update( curframe) ;
     GUI_setCurrentFrameAndTime();
-
+#endif
    return ;
 }
 /**
@@ -206,6 +207,7 @@
 */
 uint8_t A_ListAllBlackFrames(char *name)
 {
+#if 0
     uint32_t f;
     uint32_t flags;
     uint32_t startframe;
@@ -267,6 +269,7 @@
     fclose(fd);
     delete work;
     GUI_GoToFrame(startframe);
+#endif
     return 1;
 }
 //EOF



From mean at mail.berlios.de  Sat Oct 10 11:40:17 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 10 Oct 2009 11:40:17 +0200
Subject: [Avidemux-svn-commit] r5376 - in
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core:
	include src
Message-ID: <200910100940.n9A9eHI0004516@sheep.berlios.de>

Author: mean
Date: 2009-10-10 11:40:16 +0200 (Sat, 10 Oct 2009)
New Revision: 5376

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/include/ADM_default.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/ADM_debug.cpp
Log:
[Core] Add colored funcs ADM_warning, ADM_info and ADM_error

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/include/ADM_default.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/include/ADM_default.h	2009-10-10 09:40:15 UTC (rev 5375)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/include/ADM_default.h	2009-10-10 09:40:16 UTC (rev 5376)
@@ -31,8 +31,21 @@
 #include "ADM_cpuCap.h"
 #include "ADM_clock.h"
 #include "ADM_misc.h"
+
 #endif
+#ifdef __cplusplus
+extern "C" 
+{
+#endif
+void ADM_warning(const char *st, ...) ;
+void ADM_info(const char *st, ...) ;
+void ADM_error(const char *st, ...) ;
+#ifdef __cplusplus
+}
+#endif
 
+
+
 #include "ADM_mangle.h"
 #include "ADM_files.h"
 

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/ADM_debug.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/ADM_debug.cpp	2009-10-10 09:40:15 UTC (rev 5375)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/ADM_debug.cpp	2009-10-10 09:40:16 UTC (rev 5376)
@@ -77,5 +77,57 @@
 		return;
 	}
 }
+
+
+#define ADM_COLOR_YELLOW  "\e[33m"
+#define ADM_COLOR_RED     "\e[31m"
+#define ADM_DEFAULT_COLOR "\e[32m"
+
+
+static void ADM_prettyPrint(const char *color, const char *p)
+{
+    printf("%s %s %s",color,p,ADM_DEFAULT_COLOR);
+
 }
+
+
+ void ADM_info( const char *prf, ...)
+  {
+  static char print_buffer[1024];
+  	
+		va_list 	list;
+		va_start(list,	prf);
+		vsnprintf(print_buffer,1023,prf,list);
+		va_end(list);
+		print_buffer[1023]=0; // ensure the string is terminated
+        ADM_prettyPrint(ADM_DEFAULT_COLOR,print_buffer);
+		
+  }
+ void ADM_warning( const char *prf, ...)
+  {
+  static char print_buffer[1024];
+  	
+		va_list 	list;
+		va_start(list,	prf);
+		vsnprintf(print_buffer,1023,prf,list);
+		va_end(list);
+		print_buffer[1023]=0; // ensure the string is terminated
+        ADM_prettyPrint(ADM_COLOR_YELLOW,print_buffer);
+		
+  }
+ void ADM_error( const char *prf, ...)
+  {
+  static char print_buffer[1024];
+  	
+		va_list 	list;
+		va_start(list,	prf);
+		vsnprintf(print_buffer,1023,prf,list);
+		va_end(list);
+		print_buffer[1023]=0; // ensure the string is terminated
+        ADM_prettyPrint(ADM_COLOR_RED,print_buffer);
+		
+  }
+
+
+}
 //EOF



From mean at mail.berlios.de  Sat Oct 10 11:40:18 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 10 Oct 2009 11:40:18 +0200
Subject: [Avidemux-svn-commit] r5377 - in
	branches/avidemux_2.6_branch_mean/avidemux/common: . ADM_editor
Message-ID: <200910100940.n9A9eIZd004527@sheep.berlios.de>

Author: mean
Date: 2009-10-10 11:40:18 +0200 (Sat, 10 Oct 2009)
New Revision: 5377

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edStub.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/main.cpp
Log:
[Editor] More segments stuff, still broken/incomplete

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp	2009-10-10 09:40:16 UTC (rev 5376)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp	2009-10-10 09:40:18 UTC (rev 5377)
@@ -29,9 +29,6 @@
 #endif
 
 #include "ADM_pp.h"
-#define ADM_warning printf
-#define ADM_info    printf
-#define ADM_error   printf
 
 // FIXME BADLY !!!
 // This should be in a context somewhere

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edStub.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edStub.cpp	2009-10-10 09:40:16 UTC (rev 5376)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edStub.cpp	2009-10-10 09:40:18 UTC (rev 5377)
@@ -17,9 +17,6 @@
 #include "ADM_default.h"
 #include <math.h>
 
-#define ADM_warning printf
-#define ADM_info    printf
-#define ADM_error   printf
 
 #include "fourcc.h"
 #include "ADM_editor/ADM_edit.hxx"

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp	2009-10-10 09:40:16 UTC (rev 5376)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp	2009-10-10 09:40:18 UTC (rev 5377)
@@ -47,10 +47,6 @@
 //
 //
 
-#define ADM_warning printf
-#define ADM_info    printf
-#define ADM_error   printf
-
 #define TEST_MPEG2DEC
 
 ADM_Composer::ADM_Composer (void) : ADM_audioStream(NULL,NULL)
@@ -309,10 +305,34 @@
       info.fps1000 = 25 * 1000;
       updateVideoInfo (&info);
     }
-
-    // From here we cannot fail, let the segment handler make the other part of the job
     _segments.addReferenceVideo(&video);
-
+    // we only try if we got everything needed...
+    if(!video.decoder)
+    {
+        ADM_info("[Editor] no decoder to check for B- frame\n");
+    }else
+    {
+       
+        if(video._aviheader->providePts()==false) // Else we rely on demuxer PTS
+        {
+            ADM_info("[Editor] This container does not provide PTS \n");
+            if(video.decoder->bFramePossible())
+            {
+                printf("[Editor] B- frame possible with that codec \n");
+                if(isMpeg4Compatible(info.fcc) || isMpeg12Compatible(info.fcc))
+                {
+                    ADM_info("[Editor] It is mpeg4-SP/ASP, try to guess all PTS\n");                        
+                    setMpeg4PtsFromDts(video._aviheader,video.timeIncrementInUs);
+                }
+            }
+            else   
+            {
+                    printf("[Editor] No B frame with that codec, PTS=DTS\n");
+                    setPtsEqualDts(video._aviheader,video.timeIncrementInUs);
+            }
+        }
+     }
+  
   return 1;
 }
 

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp	2009-10-10 09:40:16 UTC (rev 5376)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp	2009-10-10 09:40:18 UTC (rev 5377)
@@ -22,11 +22,6 @@
  #include "ADM_pp.h"
  #include "ADM_colorspace.h"
 
-
-#define ADM_warning printf
-#define ADM_info    printf
-#define ADM_error   printf
-
 ADM_EditorSegment::ADM_EditorSegment(void)
 {
 
@@ -78,34 +73,6 @@
     decoders *decoder=vid->decoder;
 //    rederiveFrameType(_videos[_nb_video]._aviheader);
 
-#if 0
-    // we only try if we got everything needed...
-    if(!vid->decoder)
-    {
-        printf("[Editor] no decoder to check for B- frame\n");
-    }else
-    {
-       
-        if(vid->_aviheader->providePts()==false) // Else we rely on demuxer PTS
-        {
-            printf("[Editor] This container does not provide PTS \n");
-            if(decoder->bFramePossible())
-            {
-                printf("[Editor] B- frame possible with that codec \n");
-                if(isMpeg4Compatible(info.fcc) || isMpeg12Compatible(info.fcc))
-                {
-                    printf("[Editor] It is mpeg4-SP/ASP, try to guess all PTS\n");                        
-                    setMpeg4PtsFromDts(vid->_aviheader,vid->timeIncrementInUs);
-                }
-            }
-            else   
-            {
-                    printf("[Editor] No B frame with that codec, PTS=DTS\n");
-                    setPtsEqualDts(vid->_aviheader,vid->timeIncrementInUs);
-            }
-        }
-     }
-#endif    
     segments.push_back(seg);
     videos.push_back(*ref);
     updateStartTime();

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/main.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/main.cpp	2009-10-10 09:40:16 UTC (rev 5376)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/main.cpp	2009-10-10 09:40:18 UTC (rev 5377)
@@ -341,7 +341,7 @@
     ADMImage_stat();
     ADM_memStat();
     ADM_memStatEnd();
-    printf("\nGoodbye...\n\n");
+    ADM_info("\nGoodbye...\n\n");
 
 #if defined(ADM_DEBUG) && defined(FIND_LEAKS)
 	check_leaks();



From mean at mail.berlios.de  Sat Oct 10 11:41:13 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 10 Oct 2009 11:41:13 +0200
Subject: [Avidemux-svn-commit] r5378 -
	branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Alsa
Message-ID: <200910100941.n9A9fDLp004583@sheep.berlios.de>

Author: mean
Date: 2009-10-10 11:41:12 +0200 (Sat, 10 Oct 2009)
New Revision: 5378

Modified:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Alsa/ADM_deviceALSA.cpp
Log:
[AudioDevice] Set alsa to use default instead of dmix

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Alsa/ADM_deviceALSA.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Alsa/ADM_deviceALSA.cpp	2009-10-10 09:40:18 UTC (rev 5377)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Alsa/ADM_deviceALSA.cpp	2009-10-10 09:41:12 UTC (rev 5378)
@@ -61,7 +61,7 @@
 
   static char *pcm_name;
 //  if( prefs->get(DEVICE_AUDIO_ALSA_DEVICE, &pcm_name) != RC_OK )
-               pcm_name = ADM_strdup("dmix");
+               pcm_name = ADM_strdup("default");
     printf("[Alsa] Using device :%s\n",pcm_name);
  /* Allocate the snd_pcm_hw_params_t structure on the stack. */
     snd_pcm_hw_params_alloca(&hwparams);



From mean at mail.berlios.de  Wed Oct 14 07:46:20 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 14 Oct 2009 07:46:20 +0200
Subject: [Avidemux-svn-commit] r5379 - in
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core:
	include src
Message-ID: <200910140546.n9E5kK8r004557@sheep.berlios.de>

Author: mean
Date: 2009-10-14 07:46:19 +0200 (Wed, 14 Oct 2009)
New Revision: 5379

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/include/ADM_default.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/ADM_debug.cpp
Log:
[Core] Better log, automatic include of function name (gcc-ism)

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/include/ADM_default.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/include/ADM_default.h	2009-10-10 09:41:12 UTC (rev 5378)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/include/ADM_default.h	2009-10-14 05:46:19 UTC (rev 5379)
@@ -37,9 +37,13 @@
 extern "C" 
 {
 #endif
-void ADM_warning(const char *st, ...) ;
-void ADM_info(const char *st, ...) ;
-void ADM_error(const char *st, ...) ;
+void ADM_warning2(const char *f,const char *st, ...) ;
+void ADM_info2(const char *f,const char *st, ...) ;
+void ADM_error2(const char *f,const char *st, ...) ;
+
+#define ADM_warning(a,...)  ADM_warning2(__FUNCTION__,a, ##__VA_ARGS__)
+#define ADM_info(a,...)     ADM_info2(__FUNCTION__,a,    ##__VA_ARGS__)
+#define ADM_error(a,...)    ADM_error2(__FUNCTION__,a,   ##__VA_ARGS__)
 #ifdef __cplusplus
 }
 #endif

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/ADM_debug.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/ADM_debug.cpp	2009-10-10 09:41:12 UTC (rev 5378)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/ADM_debug.cpp	2009-10-14 05:46:19 UTC (rev 5379)
@@ -84,14 +84,14 @@
 #define ADM_DEFAULT_COLOR "\e[32m"
 
 
-static void ADM_prettyPrint(const char *color, const char *p)
+static void ADM_prettyPrint(const char *func,const char *color, const char *p)
 {
-    printf("%s %s %s",color,p,ADM_DEFAULT_COLOR);
+    printf("%s [%s]  %s %s",color,func,p,ADM_DEFAULT_COLOR);
 
 }
 
 
- void ADM_info( const char *prf, ...)
+ void ADM_info2(const char *func, const char *prf, ...)
   {
   static char print_buffer[1024];
   	
@@ -100,10 +100,10 @@
 		vsnprintf(print_buffer,1023,prf,list);
 		va_end(list);
 		print_buffer[1023]=0; // ensure the string is terminated
-        ADM_prettyPrint(ADM_DEFAULT_COLOR,print_buffer);
+        ADM_prettyPrint(func,ADM_DEFAULT_COLOR,print_buffer);
 		
   }
- void ADM_warning( const char *prf, ...)
+ void ADM_warning2( const char *func, const char *prf, ...)
   {
   static char print_buffer[1024];
   	
@@ -112,10 +112,10 @@
 		vsnprintf(print_buffer,1023,prf,list);
 		va_end(list);
 		print_buffer[1023]=0; // ensure the string is terminated
-        ADM_prettyPrint(ADM_COLOR_YELLOW,print_buffer);
+        ADM_prettyPrint(func,ADM_COLOR_YELLOW,print_buffer);
 		
   }
- void ADM_error( const char *prf, ...)
+ void ADM_error2( const char *func, const char *prf, ...)
   {
   static char print_buffer[1024];
   	
@@ -124,7 +124,7 @@
 		vsnprintf(print_buffer,1023,prf,list);
 		va_end(list);
 		print_buffer[1023]=0; // ensure the string is terminated
-        ADM_prettyPrint(ADM_COLOR_RED,print_buffer);
+        ADM_prettyPrint(func,ADM_COLOR_RED,print_buffer);
 		
   }
 



From mean at mail.berlios.de  Wed Oct 14 07:46:22 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 14 Oct 2009 07:46:22 +0200
Subject: [Avidemux-svn-commit] r5380 - in
	branches/avidemux_2.6_branch_mean/avidemux/common: .
	ADM_editor ADM_script
Message-ID: <200910140546.n9E5kMbC004582@sheep.berlios.de>

Author: mean
Date: 2009-10-14 07:46:21 +0200 (Wed, 14 Oct 2009)
New Revision: 5380

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edSearch.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edStub.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script/ADM_JSAvidemux.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/gui_navigate.cpp
Log:
[Editor] Switch seeking to time based seeking

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp	2009-10-14 05:46:19 UTC (rev 5379)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp	2009-10-14 05:46:21 UTC (rev 5380)
@@ -935,58 +935,8 @@
 	*swapuv=_pp.swapuv;
 	return 1;
 }
-//______________________________________________
-//_______________________________________________
-/**
-    \fn getPKFrame
-    \brief returns the keyFrame strictly before *frame
-*/
-bool	ADM_Composer::getPKFrame(uint32_t *frame)
-{
-	uint32_t fr, seg, relframe;	//,len; //flags,ret,nf;
 
-  fr = *frame;
 
-  if (*frame == 0)
-    {
-      return false;
-    }
-  if (!searchPreviousKeyFrame (fr, &seg, &relframe))
-    {
-      printf (" NKF not found\n");
-      return false;
-    }
-    if(false==_segments.getFrameFromRef(frame,seg,relframe))
-    {
-        ADM_warning("[getPKFrame] getFrameFromRef failed for sefg : %"LD" reframe %"LD"\n",seg,relframe);
-        return false;
-    }
-  return true;
-
-}
-/**
-    \fn getNKFrame
-    \brief returns the keyFrame strictly after *frame
-*/
-
-bool	ADM_Composer::getNKFrame(uint32_t *frame)
-{
-	uint32_t fr, seg, relframe;	//,len; //flags,ret,nf;
-
-  fr = *frame;
-  if (!searchNextKeyFrame (fr, &seg, &relframe))
-    {
-      printf (" NKF not found\n");
-      return 0;
-    }
-    if(false==_segments.getFrameFromRef(frame,seg,relframe))
-    {
-        ADM_warning("[getNKFrame] getFrameFromRef failed for sefg : %"LD" reframe %"LD"\n",seg,relframe);
-        return false;
-    }
-  return true;
-}
-
 #if 0
 uint8_t	ADM_Composer::isReordered( uint32_t framenum )
 {
@@ -1041,74 +991,7 @@
     }
     return true;
 }
-/**
-    \fn searchFrameBefore
-    \brief Return the frame number with pts just before pts
-*/
-uint32_t ADM_Composer::searchFrameBefore(uint64_t pts)
-{
-uint64_t refTime;
-uint32_t ref;
-    if(false==_segments.getRefFromTime(pts,&ref,&refTime))
-    {
-        ADM_warning("[searchFrameBefore] Failed for pts %"LLU"\n",pts);
-        ref=0;
-        refTime=pts;
-    }
-#warning fix over-seg issue
-    _VIDEOS   *vid=_segments.getRefVideo(ref);
-    vidHeader *demuxer=vid->_aviheader;
-    uint64_t  lastPts=demuxer->getTime(0);
-    uint32_t  nb=demuxer->getVideoStreamHeader()->dwLength;
 
-    if(lastPts>pts) return 0;
 
-	for(int i=1;i<nb-2;i++)
-    {
-        uint64_t cur,next;
-        cur=lastPts;
-        next=demuxer->getTime(i+1);
-        if(next==ADM_NO_PTS) next=cur+vid->timeIncrementInUs;
-        if(pts>=cur && pts<next) return i-1;
-        lastPts=next;
-    }
-    return nb-1;
-}
-/**
-    \fn getImageFromCacheForFrameBefore
-    \brief Search the cache for the image with PTS just before the input PTS
-*/
-bool    ADM_Composer::getImageFromCacheForFrameBefore(uint64_t pts,ADMImage *out)
-{
-    int ref=0;
-    EditorCache   *cache;
-	_VIDEOS *vid=_segments.getRefVideo(0);
-	cache=vid->_videoCache;
-	ADM_assert(cache);
-        ADMImage *r=cache->findLastBefore(pts);
-        if(!r) return false;
-        out->duplicateFull(r);
-        return true;
 
-}
-/**
-    \fn getPtsDts
-    \brief Return PTS & DTS for a given frame (in bitstream order)
-*/
-bool        ADM_Composer::getPtsDts(uint32_t frame,uint64_t *pts,uint64_t *dts)
-{
-uint32_t ref,refOffset;
-    if(_segments.getRefFromFrame(frame,&ref,&refOffset)==false)
-    {
-        ADM_warning("[Composer::getPtsDts] Cannot get ref video for frame %"LD"\n",frame);
-        return false;
-    }
- 
-     _VIDEOS   *vid=_segments.getRefVideo(ref);
-    vidHeader *demuxer=vid->_aviheader;
-    return demuxer->getPtsDts(frame,pts,dts); // FIXME : Rescale frame number
-
-}
-
-
 //EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edSearch.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edSearch.cpp	2009-10-14 05:46:19 UTC (rev 5379)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edSearch.cpp	2009-10-14 05:46:21 UTC (rev 5380)
@@ -19,143 +19,153 @@
 #include "ADM_editor/ADM_edit.hxx"
 
 /**
-    \fn searchNextKeyFrame
- //             Input : frame <b>as seen by GUI  </b>
- //     Output, segment & relframe previous keyframe
- //
+    \fn getNKFramePTS
 */
-uint8_t   ADM_Composer::searchNextKeyFrame (uint32_t in, uint32_t * oseg,
-				    uint32_t * orel)
+bool	ADM_Composer::getNKFramePTS(uint64_t *frameTime)
 {
-#if 0
-  uint32_t relframe;
-  uint32_t seg, flags;
-  uint8_t switched = 0;
-  uint32_t ref;
+uint64_t refTime,nkTime,segTime;
+int lastSeg=_segments.getNbSegments();
+uint32_t seg;
+bool r;
+    // 1- Convert frameTime to segments
+    if(false== _segments.convertLinearTimeToSeg(  *frameTime, &seg, &segTime))
+    {
+        ADM_warning("[getSegmentFromTime] Cannot find seg for time %"LLD"\n",*frameTime);
+        return false;
+    }   
+    // 
+again:
+    _SEGMENT *s=_segments.getSegment(seg);
+    uint32_t ref=s->_reference;
+    // 2- Now search the previous keyframe in the ref image...
+    // The time in reference = relTime+segmentStartTime
+    refTime=s->_startTimeUs+segTime; // Absolute time in the reference image
+    
+    r=searchNextKeyFrameInRef(ref,refTime,&nkTime);
 
-
-  if (in >= (_total_frames - 1))
+    // 3- if it does not belong to the same seg  ....
+    if(r==false || nkTime > (s->_refStartTimeUs+s->_refStartTimeUs))
     {
-      printf ("\nNKF  out of bounds\n");
-      return 0;;
+        if(seg>=lastSeg-1)
+        {
+            ADM_warning("[getSegmentFromTime] No next keyframe keyfr for frameTime \n");
+            return false;
+        }
+        // Go to the next segment
+        seg++;
+        goto again;
     }
-  // convert frame to block, relative frame
-  if (!convFrame2Seg (in, &seg, &relframe))
-    {
-      printf ("\n Conversion failed !\n");
-      return 0;
-    }
+    // Gotit, now convert it to the linear time
+    nkTime-=s->_startTimeUs;  // Ref to segment...
+    _segments.convertSegTimeToLinear(seg,nkTime,frameTime);
+    return true;
 
-  while (seg < _segments.size())
-    {
-      ref = _segments[seg]._reference;
-      // Search next kf in seg
-      if (!switched)
-	flags = 0;
-      else
-	_videos[ref]._aviheader->getFlags (relframe, &flags);
+}
 
+/**
+    \fn getPKFramePTS
+*/
 
-      while (!(flags & AVI_KEY_FRAME) && (relframe != 0xffffffff))
-	{
-	  relframe++;
-	  if (!_videos[ref]._aviheader->getFlags (relframe, &flags))
-	    relframe = 0xffffffff;
-	}
-      // verify it is within the segment
+bool			ADM_Composer::getPKFramePTS(uint64_t *frameTime)
+{
 
-      if (relframe == 0xffffffff)
-	printf ("\n not found in current seg\n");
-      if (relframe <
-	  (_segments[seg]._start_frame + _segments[seg]._nb_frames))
-	{			// It is ...
-	  *oseg = seg;
-	  *orel = relframe;
-	  return 1;
-	}
-      // Not in segment
-      printf ("\n trying next seg...\n");
-      seg++;
-      relframe = _segments[seg]._start_frame;
-      switched = 1;
-    }
-#endif
-#warning : Obsolete!
-  return 0;
 
 }
+/**
+    \fn searchNextKeyFrameInRef
+    \brief Search next key frame in ref video ref
+    @param ref: # of ref video
+    @param refTime : PTS to search keyframe after   
+    @param nkTime : Time of the ref video
 
-//_________________________________________
-uint8_t
-  ADM_Composer::searchPreviousKeyFrame (uint32_t in, uint32_t * oseg,
-					uint32_t * orel)
+*/
+bool ADM_Composer::searchNextKeyFrameInRef(int ref,uint64_t refTime,uint64_t *nkTime)
 {
-#if 0
-  uint32_t relframe;
-  uint32_t seg, flags;
-  uint32_t ref;
-
-
-  if (in == 0)
+    // Search from the end till we get a keyframe
+    _VIDEOS *v=_segments.getRefVideo(ref);
+    uint32_t nbFrame=v->_nb_video_frames;
+    
+    for(int i=0;i<nbFrame;i++)
     {
-      printf ("\n PKF out of bounds\n");
-      return 0;;
+        uint64_t p;
+        uint32_t flags;
+        v->_aviheader->getFlags(i,&flags);
+        if(!(flags & AVI_KEY_FRAME)) continue;
+        p=v->_aviheader->estimatePts(i);
+        if(p>refTime &&p!=ADM_NO_PTS)
+        {
+            *nkTime=p;
+            return true;
+        }
     }
-  // convert frame to block, relative frame
-  if (!convFrame2Seg (in, &seg, &relframe))
+    return false;
+}
+
+/**
+    \fn searchFrameBefore
+    \brief Return the frame number with pts just before pts
+*/
+uint32_t ADM_Composer::searchFrameBefore(uint64_t pts)
+{
+uint64_t refTime;
+uint32_t ref;
+    if(false==_segments.getRefFromTime(pts,&ref,&refTime))
     {
-      printf ("\n Conversion failed !\n");
-      return 0;
+        ADM_warning("[searchFrameBefore] Failed for pts %"LLU"\n",pts);
+        ref=0;
+        refTime=pts;
     }
+#warning fix over-seg issue
+    _VIDEOS   *vid=_segments.getRefVideo(ref);
+    vidHeader *demuxer=vid->_aviheader;
+    uint64_t  lastPts=demuxer->getTime(0);
+    uint32_t  nb=demuxer->getVideoStreamHeader()->dwLength;
 
-  if (relframe == 0)		//switch to last frame of prev seg
+    if(lastPts>pts) return 0;
+
+	for(int i=1;i<nb-2;i++)
     {
-      ADM_assert (seg);
-      seg--;
-      relframe = _segments[seg]._nb_frames - 1;
-
+        uint64_t cur,next;
+        cur=lastPts;
+        next=demuxer->getTime(i+1);
+        if(next==ADM_NO_PTS) next=cur+vid->timeIncrementInUs;
+        if(pts>=cur && pts<next) return i-1;
+        lastPts=next;
     }
+    return nb-1;
+}
+/**
+    \fn getImageFromCacheForFrameBefore
+    \brief Search the cache for the image with PTS just before the input PTS
+*/
+bool    ADM_Composer::getImageFromCacheForFrameBefore(uint64_t pts,ADMImage *out)
+{
+    int ref=0;
+    EditorCache   *cache;
+	_VIDEOS *vid=_segments.getRefVideo(0);
+	cache=vid->_videoCache;
+	ADM_assert(cache);
+        ADMImage *r=cache->findLastBefore(pts);
+        if(!r) return false;
+        out->duplicateFull(r);
+        return true;
 
-  do
+}
+/**
+    \fn getPtsDts
+    \brief Return PTS & DTS for a given frame (in bitstream order)
+*/
+bool        ADM_Composer::getPtsDts(uint32_t frame,uint64_t *pts,uint64_t *dts)
+{
+uint32_t ref,refOffset;
+    if(_segments.getRefFromFrame(frame,&ref,&refOffset)==false)
     {
-      ref = _segments[seg]._reference;
-      // Search next kf in seg
-      flags = 0;
-      while (!(flags & AVI_KEY_FRAME) && (relframe > 0))
-	{
-	  relframe--;
-	  if (!_videos[ref]._aviheader->getFlags (relframe, &flags))
-          {
-	    relframe = 0xffffffff;
-            break;
-          }
-	}
-      // verify it is within the segment
-
-      if ((relframe <
-	   (_segments[seg]._start_frame +
-	    _segments[seg]._nb_frames)) &&
-	  (relframe >= _segments[seg]._start_frame))
-
-	{			// It is ...
-	  *oseg = seg;
-	  *orel = relframe;
-	  return 1;
-	}
-      // Not in segment
-      printf ("\n trying previous seg...\n");
-      if (seg == 0)
-	{
-	  printf ("\n failed..\n");
-	  return 0;
-	}
-      seg--;
-      relframe = _segments[seg]._start_frame + _segments[seg]._nb_frames - 1;
+        ADM_warning("[Composer::getPtsDts] Cannot get ref video for frame %"LD"\n",frame);
+        return false;
     }
-  while (1);
-  printf ("\n failed pkf..\n");
-#endif
-#warning obsolete
-  return 0;
+ 
+     _VIDEOS   *vid=_segments.getRefVideo(ref);
+    vidHeader *demuxer=vid->_aviheader;
+    return demuxer->getPtsDts(frame,pts,dts); // FIXME : Rescale frame number
 
-}
+}
\ No newline at end of file

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edStub.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edStub.cpp	2009-10-14 05:46:19 UTC (rev 5379)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edStub.cpp	2009-10-14 05:46:21 UTC (rev 5380)
@@ -29,7 +29,8 @@
         ADM_warning(#func " cannot translate fame %"LD"\n",frame); \
         return false; \
     }
-/*
+/**
+    \fn getSpecificMpeg4Info
 	Propagate this hack to the underlying decoder
 */
 uint32_t ADM_Composer::getSpecificMpeg4Info( void )
@@ -92,7 +93,7 @@
             return t;
         }
     }
-    printf("[ADM_Composer::getTime] Cannot estimate time for frame %u\n",org);
+    ADM_warning("[ADM_Composer::getTime] Cannot estimate time for frame %u\n",org);
     return 0;
 }
 /**
@@ -108,16 +109,10 @@
 */
 uint32_t ADM_Composer::getFlagsAndSeg (uint32_t frame, uint32_t * flags,uint32_t *segs)
 {
-#if 0
-  uint32_t    relframe;
-  uint32_t    seg;
-  if (!convFrame2Seg (frame, &seg, &relframe))
-    return 0;
-  uint32_t    ref =   _segments[seg]._reference;
-
-    *segs=seg;
-#endif
-    return _segments.getRefVideo(0)->_aviheader->getFlags (frame, flags);
+ ADM_TRANSLATE(getFlagsAndSeg,frame);
+*segs=0;
+#warning fixme
+ return _segments.getRefVideo(ref)->_aviheader->getFlags (refOffset, flags);
 }
 /**
     \fn getFrameSize
@@ -127,11 +122,11 @@
  
   ADM_TRANSLATE(getframeSize,frame);
   return _segments.getRefVideo(ref)->_aviheader->getFrameSize (refOffset, size);
-
-
 }
 
-
+/**
+    \fn setFlag
+*/
 uint8_t ADM_Composer::setFlag (uint32_t frame, uint32_t flags)
 {
     ADM_TRANSLATE(setFlag,frame);
@@ -174,7 +169,7 @@
   ret = STUBB->getVideoInfo (info);
   if (ret)
     {
-      info->nb_frames = _total_frames;
+      info->nb_frames = _segments.getNbFrames();
     }
   return ret;
 }
@@ -195,93 +190,8 @@
 {
   return STUBB->getBIH ();
 };
-/**
-    \fn sanityCheckRef
-//	Do a sanity check for copy mode
-//	Check that B frames did not loose there backward/forward ref frame
-// 	It is brute force as we only need to check begin/end of each segment
-//	But it should be fast anyway
-*/
-uint8_t		ADM_Composer::sanityCheckRef(uint32_t start, uint32_t end,uint32_t *fatal)
-{
-#if 0
-uint32_t flags,seg;
-uint32_t lastnonb=0,segnonB=0xffff;
-uint32_t forward=0,forwardseg=0xffff;
 
-uint8_t ok=0;
-uint32_t i=0;
-	*fatal=0;
-	// If it is not in PTS, no need to bother
-	if(!isReordered(start))
-	{
-		printf("Not reordered or no B frame, nothing to check\n");
-		return 1;
-	}
-	// If the last frames are B frames it is fatal
-	if(!getFlagsAndSeg (end-1, &flags,&seg))
-	{
-				printf("Cannot get flags for frame %"LU"\n",end-1);
-				goto _abt;
-	}
-	if(flags & AVI_B_FRAME)
-	{
-		printf("Ending B frame -> abort (%"LU")\n",end-1);
-		*fatal=1;
-		return 0;
-	}
-	if(!getFlagsAndSeg (start, &flags,&seg))
-	{
-				printf("Cannot get flags for frame %"LU"\n",start);
-				goto _abt;
-	}
-	if(flags & AVI_B_FRAME)
-	{
-		printf("Starting B frame -> abort\n");
-		*fatal=1;
-		return 0;
-	}
-	for( i=start;i<end;i++)
-	{
-			//printf("%08lu/%08lu\r",i,end-start);
-			if(!getFlagsAndSeg (i, &flags,&seg))
-			{
-				printf("Cannot get flags for frame %"LU"\n",i);
-				goto _abt;
-			}
-			if(flags & AVI_B_FRAME)
-			{ 	// search if we have to send a I/P frame in adance
-				if(segnonB!=seg)
-				{
-					printf("bw failed! (%"LU"/%"LU")\n",seg,segnonB);
-					 goto _abt;
-				}
-;
 
-				forwardseg=searchForwardSeg(i);
-				if(seg!=forwardseg)
-				{
-					printf("Fw failed! (%"LU"/%"LU")\n",seg,forwardseg);
-					 goto _abt;
-				}
-			}
-			else // it is not a B frame and we have nothing on hold, sent it..
-			{
-				lastnonb=i;
-				segnonB=seg;
-			}
-	}
-	ok=1;
-_abt:
-	if(!ok)
-	{
-		printf("Frame %d has lost its fw/bw reference frame (%"LU"/%"LU")\n",i,start,end);
-	}
-	return ok;
-#endif
-    return true;
-}
-
 /**
     \fn getVideoDuration
     \brief returns duration of the video track

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp	2009-10-14 05:46:19 UTC (rev 5379)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp	2009-10-14 05:46:21 UTC (rev 5380)
@@ -36,27 +36,22 @@
 #define MODULE_NAME MODULE_EDITOR
 #include "ADM_debug.h"
 
-#include "ADM_outputfmt.h"
+//#include "ADM_outputfmt.h"
 #include "ADM_edPtsDts.h"
 
 vidHeader *ADM_demuxerSpawn(uint32_t magic,const char *name);
 
-extern uint8_t parseScript(char *name);
-uint8_t UI_SetCurrentFormat( ADM_OUT_FORMAT fmt );
-const char *VBR_MSG = QT_TR_NOOP("Avidemux detected VBR MP3 audio in this file. For keeping audio/video in sync, time map is needed. Build it now?\n\nYou can do it later with \"Audio -> Build VBR Time Map\".");
-//
-//
+//#define TEST_MPEG2DEC
+/**
+    \fn ADM_Composer
 
-#define TEST_MPEG2DEC
-
+*/
 ADM_Composer::ADM_Composer (void) : ADM_audioStream(NULL,NULL)
 {
 uint32_t type,value;
 
    packetBufferSize=0;
    packetBufferDts=ADM_NO_PTS;
-
-  _total_frames = 0;
   _audioseg = 0;
   _audiooffset = 0;
   _audioSample=0;
@@ -90,9 +85,6 @@
 uint8_t ADM_Composer::resetSeg( void )
 {
 	_segments.resetSegment();
-
-  	computeTotalFrames();
-//	dumpSeg();
 	return 1;
 }
 /**
@@ -237,11 +229,6 @@
     }
 
 
-//    fourCC::print( info.fcc );
-    _total_frames += info.nb_frames;
-
-
-
   // Update audio infos
   // an spawn the appropriate decoder
   //_________________________
@@ -421,129 +408,8 @@
   _segments.deleteAll();
   return 1;
 }
-#if 0
-/*
-        param:
-                source : source #
-                start : start frame in source #
-                nb    : nb frame to copy into segment
-*/
-uint8_t ADM_Composer::addSegment(uint32_t source,uint32_t start, uint32_t nb)
-{
-        // do some sanity check
-        if(_nb_segment==max_seg-1)
-	{
-	   _SEGMENT *s;
-            max_seg += MAX_SEG;
-            s = new _SEGMENT[max_seg];
-            memset (s, 0, sizeof(_SEGMENT)*max_seg);
-            memcpy(s,_segments,sizeof(_SEGMENT)*(max_seg-MAX_SEG));
-            delete _segments;
-            _segments = s;
-        }
-        if(_nb_video<=source)
-        {
-                printf("[editor]: No such source %d/%d\n",source,_nb_video);
-                 return 0;
-        }
-        if(_videos[source]._nb_video_frames<=start)
-        {
-                printf("[editor]:start out of bound %d/%d\n",start,_videos[source]._nb_video_frames);
-                 return 0;
-        }
-        if(_videos[source]._nb_video_frames<start+nb)
-        {
-                printf("[editor]:end out of bound %d/%d\n",start+nb,_videos[source]._nb_video_frames);
-                 return 0;
-        }
-        // ok, let's go
-        _SEGMENT *seg=&(_segments[_nb_segment]);
-        seg->_reference=source;
-        seg->_start_frame=start;
-        seg->_nb_frames=nb;
-        _nb_segment++;
-        updateAudioTrack (_nb_segment-1);
-        _total_frames=computeTotalFrames();
 
-        return 1;
-}
 /**
-______________________________________________________
-//  Remove frames , the frame are given as seen by GUI
-//  We remove from start to end -1
-// [start,end[
-//______________________________________________________
-*/
-uint8_t ADM_Composer::removeFrames (uint32_t start, uint32_t end)
-{
-
-  uint32_t
-    seg1,
-    seg2,
-    rel1,
-    rel2;
-  uint8_t
-    lastone =
-    0;
-
-  if (end == _total_frames - 1)
-    lastone = 1;
-
-  // sanity check
-  if (start > end)
-    return 0;
-  //if((1+start)==end) return 0;
-
-  // convert frame to block, relative frame
-  if (!convFrame2Seg (start, &seg1, &rel1) ||
-      !convFrame2Seg (end, &seg2, &rel2))
-    {
-      ADM_assert (0);
-    }
-  // if seg1 != seg2 we can just modify seg1 and seg2
-  if (seg1 != seg2)
-    {
-      // remove end of seg1
-
-      removeFrom (rel1, seg1, 1);
-      //  delete in between seg
-      for (uint32_t seg = seg1 + 1; seg < (seg2); seg++)
-	_segments[seg]._nb_frames = 0;
-      // remove beginning of seg2
-      removeTo (rel2, seg2, lastone);
-    }
-  else
-    {
-      // it is in the same segment, split it...
-      // complete seg ?
-      if ((rel1 == _segments[seg1]._start_frame)
-	  && (rel2 ==
-	      (_segments[seg1]._start_frame +
-	       _segments[seg1]._nb_frames - 1)))
-	{
-	  _segments[seg1]._nb_frames = 0;
-	}
-      else
-	{
-	  // split in between.... duh !
-	  duplicateSegment (seg1);
-	  //
-	  removeFrom (rel1, seg1, 1);
-	  removeTo (rel2, seg1 + 1, lastone);
-	}
-    }
-
-  // Crunch
-  crunch ();
-  sanityCheck ();
-  // Compute total nb of frame
-  _total_frames = computeTotalFrames ();
-  printf ("\n %"LU" frames ", _total_frames);
-  return 1;
-
-}
-#endif
-/**
     \fn getAudioStreamsInfo
     \brief Returns a copy of all audio trackes at frame frame
     call delete [] infos when you dont need them anymore
@@ -632,294 +498,8 @@
         v->currentAudioStream=newstream;
         return true;
 }
-#if 0
-/**
-______________________________________________________
-//
-//	Copy the start/eng seg  to clipboard
-//______________________________________________________
-*/
-uint8_t ADM_Composer::copyToClipBoard (uint32_t start, uint32_t end)
-{
 
-  uint32_t	    seg1,    seg2,    rel1,    rel2;
-  uint8_t    lastone =    0;
-uint32_t seg=0xfff;
-
-  if (end == _total_frames - 1)
-    lastone = 1;
-
-  // sanity check
-  if (start > end)
-  {
-    printf("End < Start \n");
-    return 0;
-   }
-  //if((1+start)==end) return 0;
-
-  // convert frame to block, relative frame
-  if (!convFrame2Seg (start, &seg1, &rel1) ||
-      !convFrame2Seg (end, &seg2, &rel2))
-    {
-      ADM_assert (0);
-    }
-    _nb_clipboard=0;
-  // if seg1 != seg2 we can just modify seg1 and seg2
-  if (seg1 != seg2)
-    {
-    aprintf("Diff  seg: %"LU" /%"LU" from %"LU" to %"LU" \n",seg1,seg2,rel1,rel2);
-      // remove end of seg1
-	_clipboard[_nb_clipboard]._reference=_segments[seg1]._reference;
-	_clipboard[_nb_clipboard]._start_frame=rel1;
- 	_clipboard[_nb_clipboard]._nb_frames =_segments[seg]._nb_frames- (rel1 - _segments[seg]._start_frame);
-	_nb_clipboard++;
-      // copy  in between seg
-      for ( seg = seg1 + 1; seg <=seg2; seg++)
-		memcpy(&_clipboard[_nb_clipboard++], &_segments[seg],sizeof(_segments[0]));
-      // Adjust nb frame for last seg
-      uint32_t l;
-      l=_nb_clipboard-1;
-	_clipboard[l]._nb_frames=rel2-_segments[seg2]._start_frame;
-    }
-  else
-    {
-      // it is in the same segment, split it...
-      // complete seg ?
-      if ((rel1 == _segments[seg1]._start_frame)
-	  && (rel2 ==
-	      (_segments[seg1]._start_frame +
-	       _segments[seg1]._nb_frames - 1)))
-	{
-	  aprintf("Full seg: %"LU" from %"LU" to %"LU" \n",seg1,rel1,rel2);
-		memcpy(&_clipboard[_nb_clipboard++], &_segments[seg1],sizeof(_segments[0]));
-	}
-      else
-	{
-	  // we just take a part of one chunk
-	  aprintf("Same seg: %"LU" from %"LU" to %"LU" \n",seg1,rel1,rel2);
-	  memcpy(&_clipboard[_nb_clipboard], &_segments[seg1],sizeof(_segments[0]));
-	  _clipboard[_nb_clipboard]._start_frame=rel1;
-	  _clipboard[_nb_clipboard]._nb_frames=rel2-rel1;
-	_nb_clipboard++;
-	aprintf("clipboard: %"LU" \n",_nb_clipboard);
-	}
-    }
-	dumpSeg();
-  return 1;
-
-}
-uint8_t ADM_Composer::pasteFromClipBoard (uint32_t whereto)
-{
-uint32_t rel,seg;
-
-	if (!convFrame2Seg (whereto, &seg, &rel) )
-    	{
-      		ADM_assert (0);
-    	}
-	dumpSeg();
-
-	// past at frame 0
-	if(	seg==0 && rel==_segments[0]._start_frame)
-	{
-		aprintf("Pasting at frame 0\n");
-		for(uint32_t i=0;i<_nb_clipboard;i++)
-			duplicateSegment(seg);
-		memcpy(&_segments[0],&_clipboard[0],_nb_clipboard*sizeof(_clipboard[0]));
-	}
-	else
-	if(rel==_segments[seg]._start_frame+_segments[seg]._nb_frames )
-	{
-		aprintf("\n setting at the end of seg %"LU"\n",seg);
-		// we put it after OLD insert OLD+1
-		for(uint32_t i=0;i<_nb_clipboard;i++)
-			duplicateSegment(seg);
-		memcpy(&_segments[seg+1],&_clipboard[0],_nb_clipboard*sizeof(_clipboard[0]));
-
-	}
-	else // need to split it
-	{
-		for(uint32_t i=0;i<_nb_clipboard+1;i++)
-			duplicateSegment(seg);
-		memcpy(&_segments[seg+1],&_clipboard[0],_nb_clipboard*sizeof(_clipboard[0]));
-
-		// and the last one
-		_segments[seg+_nb_clipboard+1]._nb_frames=(_segments[seg]._start_frame+_segments[seg]._nb_frames)-rel;
-		_segments[seg+_nb_clipboard+1]._start_frame=rel;
-		// adjust the current one
-		_segments[seg]._nb_frames=rel-_segments[seg]._start_frame;
-	}
-	 _total_frames = computeTotalFrames ();
-	for(uint32_t i=0;i<_nb_segment;i++)
- 		updateAudioTrack(i);
-  dumpSeg();
-  return 1;
-
-}
-
-//____________________________________
-//      Duplicate a segment
-//____________________________________
-
-uint8_t ADM_Composer::duplicateSegment (uint32_t segno)
-{
-
-  for (uint32_t i = _nb_segment; i > segno; i--)
-    {
-
-      memcpy (&_segments[i], &_segments[i - 1], sizeof (_SEGMENT));
-
-    }
-  _nb_segment++;
-  return 1;
-
-
-}
-
-//____________________________________
-//      Remove empty segments
-//____________________________________
-uint8_t ADM_Composer::crunch (void)
-{
-  uint32_t
-    seg =
-    0;
-  while (seg < _nb_segment)
-    {
-      if (_segments[seg]._nb_frames == 0)
-	{
-	  //
-
-	  for (uint32_t c = seg + 1; c < _nb_segment; c++)
-	    {
-	      memcpy (&_segments[c - 1], &_segments[c], sizeof (_SEGMENT));
-	    }
-	  _nb_segment--;
-
-	}
-      else
-	{
-	  seg++;
-	}
-    }
-  // Remove last seg if there is only one frame in it
-  if (_nb_segment)
-    {
-      if (_segments[_nb_segment - 1]._nb_frames == 1)
-	{
-	  _nb_segment--;
-	}
-    }
-  return 1;
-
-}
-#endif
-//____________________________________
-//      Remove empty segments
-//____________________________________
-uint32_t ADM_Composer::computeTotalFrames (void)
-{
-#if 0
-  uint32_t
-    seg,
-    tf =
-    0;
-  for (seg = 0; seg < _nb_segment; seg++)
-    {
-      tf += _segments[seg]._nb_frames;
-
-    }
-
-  return tf;
-#endif
-}
-#if 0
-//____________________________________
-//      Remove empty segments
-//____________________________________
-void
-ADM_Composer::dumpSeg (void)
-{
-  uint32_t seg;
-  printf ("\n________Video______________");
-  for (seg = 0; seg < _nb_video; seg++)
-    {
-//      printf ("\n Video : %"LU", nb video  :%"LU", audio size:%"LU"  audioDuration:%"LU"",
-//	      seg, _videos[seg]._nb_video_frames, _videos[seg]._audio_size,_videos[seg]._audio_duration);
-
-    }
-
-  printf ("\n______________________");
-  for (seg = 0; seg < _nb_segment; seg++)
-    {
-      printf
-	("\n Seg : %"LU", ref: %"LU" start :%"LU", size:%"LU" audio size : %"LU" audio start : %"LU" duration:%"LLU"",
-	 seg, _segments[seg]._reference, _segments[seg]._start_frame,
-	 _segments[seg]._nb_frames, _segments[seg]._audio_size,
-	 _segments[seg]._audio_start,
-	  _segments[seg]._audio_duration
-	 );
-
-    }
-  printf ("\n_________Clipboard_____________");
-  for (seg = 0; seg < _nb_clipboard; seg++)
-    {
-      printf
-	("\n Seg : %"LU", ref: %"LU" start :%"LU", size:%"LU" audio size : %"LU" audio start : %"LU"  duration:%"LLU"\n",
-	 seg, _clipboard[seg]._reference, _clipboard[seg]._start_frame,
-	 _clipboard[seg]._nb_frames, _clipboard[seg]._audio_size,
-	 _clipboard[seg]._audio_start,
-	 _segments[seg]._audio_duration);
-
-    }
-
-
-}
-
-// Clear from position to/from
 //
-// 0------To------end
-//  xxxxxx removed
-
-uint8_t ADM_Composer::removeTo (uint32_t to, uint32_t seg, uint8_t included)
-{
-  uint32_t
-    ref;
-
-  ADM_assert (checkInSeg (seg, to));
-  ref = _segments[seg]._start_frame;
-  _segments[seg]._start_frame = to;
-  if (included)
-    _segments[seg]._start_frame++;
-  _segments[seg]._nb_frames -= (_segments[seg]._start_frame - ref);
-
-
-  updateAudioTrack (seg);
-
-//---------------------------------------
-
-
-
-  return 1;
-}
-
-//
-// 0------From------end
-//            xxxxxx removed
-
-uint8_t
-  ADM_Composer::removeFrom (uint32_t from, uint32_t seg, uint8_t included)
-{
-  ADM_assert (checkInSeg (seg, from));
-  _segments[seg]._nb_frames = (from - _segments[seg]._start_frame);
-
-  if (!included)
-    _segments[seg]._nb_frames++;
-
-  updateAudioTrack (seg);
-  return 1;
-}
-#endif
-//
 //      Update the real size of audio track by computing the
 // delta between sync @end and sync at begin
 // We also upate the duration of the selected part
@@ -950,43 +530,7 @@
 }
 
 
-#if 0
-//__________________________________________________
-// check that the given frame is inside the segment
-//__________________________________________________
-uint8_t ADM_Composer::checkInSeg (uint32_t seg, uint32_t frame)
-{
-  if (frame < _segments[seg]._start_frame)
-    return 0;
-  if (frame > (_segments[seg]._nb_frames + _segments[seg]._start_frame))
-    return 0;
-  return 1;
 
-}
-uint8_t	ADM_Composer::isIndexable( void)
-{
-	if(!_nb_video) ADM_assert(0);
-	return _videos[0].decoder->isIndexable();
-
-}
-
-uint8_t ADM_Composer::sanityCheck (void)
-{
-  uint32_t
-    ref,
-    seg;
-
-  for (seg = 0; seg < _nb_segment; seg++)
-    {
-      ref = _segments[seg]._start_frame + _segments[seg]._nb_frames - 1;
-
-    }
-  return 1;
-
-
-}
-#endif
-
 //_________________________________________
 uint8_t		ADM_Composer::setEnv(_ENV_EDITOR_FLAGS newflag)
 {
@@ -1006,74 +550,7 @@
 		return r;
 
 }
-#if BAZOOKA
-//_________________________________________
-//    Try indexing the file, return 1 if file successfully indexed
-//              0 else
-//_________________________________________
-//
-uint8_t         ADM_Composer::tryIndexing(const char *name, const char *idxname)
-{
- unsigned int autoidx = 0;
-      prefs->get(FEATURE_TRYAUTOIDX,&autoidx);
-      if (!autoidx)
-        {
-          if (!GUI_Question (QT_TR_NOOP("This looks like mpeg\n Do you want to index it?")))
-            {
-                return 0;
-            }
-		}
-          char      *idx;
-          DMX_TYPE  type;
-          uint32_t  nbTrack=0,audioTrack=0;
-          MPEG_TRACK *tracks=NULL;
-          uint8_t r=1;
 
-                if(!dmx_probe(name,&type,&nbTrack,&tracks))
-                {
-                        printf("This is not mpeg\n");
-                        return 0;
-                }
-
-
-                if(type==DMX_MPG_PS || type==DMX_MPG_TS || type==DMX_MPG_TS2)
-                {
-                       if(nbTrack>2)
-		       if(autoidx)
-			{
-				printf("Using autoindex\n");
-			}
-/*                        else
-		       {
-
-                        if(!DIA_dmx(name,type,nbTrack,tracks,&audioTrack))
-                        {
-                                delete [] tracks;
-                                return 0;
-                        }
-		       }
-*/
-                        audioTrack=0;
-                }
-		if( idxname ){
-			idx=new char[strlen(idxname)];
-			strcpy(idx,idxname);
-		}else{
-                	idx=new char[strlen(name)+5];
-                	strcpy(idx,name);
-                	strcat(idx,".idx");
-		}
-
-                r=dmx_indexer(name,idx,audioTrack,0,nbTrack,tracks);
-
-                if(tracks)
-                        delete [] tracks;
-                delete [] idx;
-
-                if(!r) GUI_Error_HIG(QT_TR_NOOP("Indexing failed"), NULL);
-                return r;
-}
-#endif
 /**
       If a parameter has changed, rebuild the duration of the streams
       It can happen, for example in case of SBR audio such as AAC
@@ -1108,5 +585,16 @@
     wantedPts+=vid->timeIncrementInUs*count;
     return wantedPts;
 }
+/**
+    \fn getCurrentFramePts
+    \brief Get the PTS of current frame
+
+*/
+uint64_t    ADM_Composer::getCurrentFramePts(void)
+{
+    _SEGMENT *seg=_segments.getCurrentSeg();
+    _VIDEOS *vid=_segments.getRefVideo(seg->_reference);
+    return vid->lastDecodedPts;
+}
 //
 //

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx	2009-10-14 05:46:19 UTC (rev 5379)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx	2009-10-14 05:46:21 UTC (rev 5380)
@@ -69,8 +69,6 @@
   					ADM_PP 		_pp;
 					ADMImage	*_imageBuffer;
   					uint8_t		decodeCache(uint32_t frame,uint32_t seg, ADMImage *image);
-  					uint32_t 	_total_frames;
-  					uint32_t 	_audio_size;
   					// _audiooffset points to the offset / the total segment
   					// not the used part !
   					uint32_t  _audioseg;
@@ -81,34 +79,15 @@
        				uint32_t _lastseg,_lastframe,_lastlen;
 
                     ADM_audioStreamTrack *getTrack(uint32_t i);
-#if 0
-                                            {
-                                                if(!_videos[i].audioTracks) return NULL;
-                                                return _videos[i].audioTracks[_videos[i].currentAudioStream];
-                                            }
-#endif
-                    ADMImage        *_scratch;
-                    uint8_t 	crunch( void)																			;
-                    uint8_t 	duplicateSegment( uint32_t segno);
-                    uint32_t 	computeTotalFrames(void) ;
-
-                    uint8_t 	removeTo( 	uint32_t to, uint32_t seg,uint8_t included);
-                    uint8_t 	removeFrom( uint32_t from, uint32_t seg,uint8_t included);
-                    uint8_t 	checkInSeg( uint32_t seg, uint32_t frame);
-                    uint8_t 	sanityCheck( void);
+                    ADMImage    *_scratch;																		;
                     uint8_t  	updateAudioTrack(uint32_t seg);			   	
                     void 		deleteAllVideos(void );
-
                     uint8_t 	getMagic(const char *name,uint32_t *magic);
-
                     uint32_t 	searchForwardSeg(uint32_t startframe);
-                    uint8_t     tryIndexing(const char *name, const char *idxname=NULL);
                     bool        rederiveFrameType(vidHeader *demuxer);
 
   public:
                     bool        hasVBRAudio(void);
-                    uint8_t     addSegment(uint32_t source,uint32_t start, uint32_t nb);
-                    uint8_t     deleteAllSegments(void);
                     bool     	getExtraHeaderData(uint32_t *len, uint8_t **data);
                     uint32_t    getPARWidth(void);
                     uint32_t    getPARHeight(void);
@@ -116,27 +95,13 @@
   								ADM_Composer();
   				virtual 			~ADM_Composer();
                     void		clean( void );
-                    void		dumpSeg(void);
                     uint8_t     saveAsScript (const char *name, const char *out);
                     uint8_t 	saveWorbench(const char *name);
                     uint8_t 	loadWorbench(const char *name);
                     uint8_t     resetSeg( void );
-                    uint8_t	    reorder( void );
-                    uint8_t	    isReordered( uint32_t framenum ) {return true;}
-                    uint8_t	    isIndexable( void);
-            //_______________________
-            // specific to composer
-            //_______________________
                     bool     	addFile (const char *name);
                     uint8_t 	cleanup( void);
                     bool 	    isMultiSeg( void);
-                    uint8_t 	removeFrames(uint32_t start,uint32_t end);
-                    uint8_t 	addFrameFrom(uint32_t to,uint32_t frombegin,uint32_t fromend);
-                    uint8_t 	copyToClipBoard (uint32_t start, uint32_t end);
-                    uint8_t 	pasteFromClipBoard (uint32_t whereto);
-            //_____________________________
-  				// navigation & frame functions
-  				//_____________________________
 /************************************* Markers *****************************/
 private:        
                     uint64_t    markerAPts,markerBPts;
@@ -151,7 +116,7 @@
                     uint32_t    currentFrame;
 public:
                     uint32_t    getCurrentFrame(void);
-                    
+                    uint64_t    getCurrentFramePts(void);
                     bool        setCurrentFrame(uint32_t frame);
                     bool        GoToIntra(uint32_t frame);
                     bool        GoToTime(uint64_t time);
@@ -175,26 +140,21 @@
                     bool     	getNextPicture(ADMImage *out,uint32_t ref);
                                 /// Get again last decoded picture
                     bool        getSamePicture(ADMImage *out,uint32_t ref);
+
+                    bool        searchNextKeyFrameInRef(int ref,uint64_t refTime,uint64_t *nkTime);
 /************************************ Internal ******************************/
                     uint8_t 	getFrame(uint32_t   framenum,ADMCompressedImage *img,uint8_t *isSequential);
                     
                 
                     uint64_t 	getTime(uint32_t fn);
                     uint32_t 	getFlags(uint32_t frame,uint32_t *flags);
-                    uint8_t   	isSequential (uint32_t framenum);
+
                             // B follow A with just Bframes in between
-                    uint8_t 	sequentialFramesB(uint32_t frameA,uint32_t frameB);
                     uint32_t 	getFlagsAndSeg (uint32_t frame, 
                                 uint32_t * flags,uint32_t *segs);
                     uint8_t  	setFlag(uint32_t frame,uint32_t flags);
                     uint8_t	    updateVideoInfo(aviInfo *info);
-
                     uint8_t  	getFrameSize(uint32_t frame,uint32_t *size) ;
-                    uint8_t		sanityCheckRef(uint32_t start, uint32_t end,
-                                uint32_t *fatal);
-                                            uint8_t         hasPtsDts(uint32_t ); // Return 1 if the container gives PTS & DTS info
-                                            uint32_t        ptsDtsDelta(uint32_t framenum) ;
-                //*******************************************	
                     uint32_t 	getSpecificMpeg4Info( void );
 /************************************ audioStream ******************************/
 protected:
@@ -235,7 +195,8 @@
 /***************************************** Seeking *****************************/            
 		  			bool			getPKFrame(uint32_t *frame);
 					bool			getNKFrame(uint32_t *frame);
-					
+                    bool			getNKFramePTS(uint64_t *frameTime);
+                    bool			getPKFramePTS(uint64_t *frameTime);
                     bool			getUncompressedFrame(uint32_t frame,ADMImage *out,uint32_t *flagz=NULL);
 public:
                     
@@ -246,14 +207,7 @@
 /******************************* Misc ************************************/				
 					uint8_t			setEnv(_ENV_EDITOR_FLAGS newflag);
 					uint8_t			getEnv(_ENV_EDITOR_FLAGS newflag);
-					decoders 		*rawGetDecoder(uint32_t frame);
 /******************************* /Misc ************************************/				
-/***** OBSOLETE API *****/
-/***** OBSOLETE API *****/
-/***** OBSOLETE API *****/
-protected:					// Obsolete									
-                    uint8_t			searchNextKeyFrame(uint32_t in,uint32_t *oseg, uint32_t * orel);
-                    uint8_t			searchPreviousKeyFrame(uint32_t in,uint32_t *oseg, uint32_t * orel);
 
 };
 #endif

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp	2009-10-14 05:46:19 UTC (rev 5379)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp	2009-10-14 05:46:21 UTC (rev 5380)
@@ -22,6 +22,8 @@
  #include "ADM_pp.h"
  #include "ADM_colorspace.h"
 
+#include "ADM_audiocodec/ADM_audiocodec.h"
+
 ADM_EditorSegment::ADM_EditorSegment(void)
 {
 
@@ -79,65 +81,49 @@
     return true;
 }
 
-/**
-    \fn deleteAll
-    \brief Delete all segments & ref video
-*/
-bool        ADM_EditorSegment::deleteAll(void)
-{
-#warning todo
-    return true;
-}
 
-#if 0
 /**
-	\fn Purge all videos
+	\fn deleteAll
     \brief delete datas associated with all video
 */
-void getFlags::deleteAllVideos (void)
+bool ADM_EditorSegment::deleteAll (void)
 {
-
-  for (uint32_t vid = 0; vid < _videos.size(); vid++)
+  ADM_info("[Editor] Deleting all video\n");
+  int n=videos.size();
+  for (uint32_t vid = 0; vid < n; vid++)
     {
-
+        _VIDEOS *v=&(videos[vid]);
       // if there is a video decoder...
-      if (_videos[vid].decoder)
-            delete _videos[vid].decoder;
-      if(_videos[vid].color)
-            delete _videos[vid].color;
-      // prevent from crashing
-      _videos[vid]._aviheader->close ();
-      delete _videos[vid]._aviheader;
-      if(_videos[vid]._videoCache)
-      	delete  _videos[vid]._videoCache;
-      _videos[vid]._videoCache=NULL;
+      if (v->decoder)
+            delete v->decoder;
+      if(v->color)
+            delete v->color;
+      v->_aviheader->close ();
+      delete v->_aviheader;
+      if(v->_videoCache)
+      	delete  v->_videoCache;
+      v->_videoCache=NULL;
+      v->color=NULL;
+      v->decoder=NULL;
+      v->_aviheader=NULL;
      // Delete audio codec too
      // audioStream will be deleted by the demuxer
-      if(_videos[vid].audioTracks)
+      if(v->audioTracks)
       {
-            for(int i=0;i<_videos[vid].nbAudioStream;i++)
+            for(int i=0;i<v->nbAudioStream;i++)
             {
-                delete _videos[vid].audioTracks[i];
+                delete v->audioTracks[i];
             }
-            delete [] _videos[vid].audioTracks;
-            _videos[vid].audioTracks=NULL;
+            delete [] v->audioTracks;
+            v->audioTracks=NULL;
       }
     }
 
-   if(_videos.size())
-    {
-        _videos.erase(_videos.begin(),_videos.begin()+_videos.size()-1);
-    }
+    videos.clear();
+    return true;
+}
 
 
-  if(_imageBuffer)
-  	delete _imageBuffer;
-  _imageBuffer=NULL;
-
-}
-
-}
-#endif
 /**
     \fn resetSegment
     \brief Redo a 1:1 mapping between videos and segments
@@ -155,11 +141,21 @@
         memset(&seg,0,sizeof(seg));
         seg._durationUs=vid->_aviheader->getVideoDuration();
         seg._reference=i;
+        segments.push_back(seg);
     }
     updateStartTime();
     return true;
 }
 /**
+    \fn getSegment
+    \brief getRefVideo
+*/
+_SEGMENT     *ADM_EditorSegment::getSegment(int i)
+{
+    ADM_assert(i<segments.size());
+    return &(segments[i]);
+}
+/**
     \fn getRefVideo
     \brief getRefVideo
 */
@@ -253,4 +249,36 @@
     return true;
 
 }
+/**
+    \fn ~ADM_audioStreamTrack
+*/
+ ADM_audioStreamTrack::~ADM_audioStreamTrack()
+    {
+        stream=NULL;
+        info=NULL;   // These 2 are destroyed by the demuxer itself
+        if(codec) 
+        {
+            delete codec;
+            codec=NULL;
+        }
+    }
+/**
+    \fn getCurrentSeg
+*/
+_SEGMENT   * ADM_EditorSegment::getCurrentSeg(void)
+{
+    return &(segments[0]);
+}
+
+bool        ADM_EditorSegment::convertLinearTimeToSeg(  uint64_t frameTime, uint32_t *seg, uint64_t *segTime)
+{
+    *seg=0;
+    *segTime=frameTime;
+    return true;
+}
+bool        ADM_EditorSegment::convertSegTimeToLinear(  uint32_t seg,uint64_t segTime, uint64_t *frameTime)
+{
+    *frameTime=segTime;
+    return true;
+}
 //EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.h	2009-10-14 05:46:19 UTC (rev 5379)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.h	2009-10-14 05:46:21 UTC (rev 5380)
@@ -40,16 +40,7 @@
 
 public:
     ADM_audioStreamTrack() {memset(this,0,sizeof(*this));}
-    ~ADM_audioStreamTrack()
-    {
-        stream=NULL;
-        info=NULL;   // These 2 are destroyed by the demuxer itself
-        if(codec) 
-        {
-            delete codec;
-            codec=NULL;
-        }
-    }
+virtual    ~ADM_audioStreamTrack();
 };
 /**
     \struct _VIDEOS
@@ -89,7 +80,7 @@
  	uint64_t							_refStartTimeUs;  /// Starting time in reference
     uint64_t                            _startTimeUs;     /// Start time in current (=sum(_duration of previous seg))
 	uint64_t							_durationUs;      ///
-
+    uint32_t                            _nbFrame;
 }_SEGMENT;
 /*
     Use vectors to store our videos & segments
@@ -106,6 +97,7 @@
         ListOfSegments segments;
         ListOfVideos   videos;
         bool           updateStartTime(void);
+        uint32_t       currentSeg;
 
 public:
                         ADM_EditorSegment(void);
@@ -117,14 +109,22 @@
             _VIDEOS     *getRefVideo(int i);
             int         getNbRefVideos(void);
 
+            _SEGMENT    *getSegment(int i);
             int         getNbSegments(void);
+
             uint64_t    getTotalDuration(void);
             uint32_t    getNbFrames(void);
 
             bool        getRefFromTime(uint64_t time,uint32_t *refVideo, uint64_t *offset);
             bool        getRefFromFrame(uint32_t frame,uint32_t *refVideo, uint32_t *frameOffset);
+
             bool        getFrameFromRef(uint32_t *frame,uint32_t refVideo, uint32_t frameOffset);
 
+
+            bool        convertLinearTimeToSeg(  uint64_t frameTime, uint32_t *seg, uint64_t *segTime);
+            bool        convertSegTimeToLinear(  uint32_t seg,uint64_t segTime, uint64_t *frameTime);
+
+            _SEGMENT    *getCurrentSeg(void);
 };
 
 #endif

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.cpp	2009-10-14 05:46:19 UTC (rev 5379)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.cpp	2009-10-14 05:46:21 UTC (rev 5380)
@@ -623,11 +623,22 @@
 */
 bool admPreview::nextKeyFrame(void)
 {
+    uint64_t pts=getCurrentPts();
+    ADM_info("Current PTS :%"LLD" ms\n",pts/1000LL);
+    if(false==video_body->getNKFramePTS(&pts))
+    {
+        ADM_warning("Cannot find next keyframe\n");
+        return false;
+    }
+    ADM_info("next kf PTS :%"LLD" ms\n",pts/1000LL);
+    return true;
+/*
     uint32_t frame=video_body->getCurrentFrame();
     if(!video_body->getNKFrame(&frame)) return false;
     if(!video_body->GoToIntra(frame)) return false;
     video_body->setCurrentFrame(frame);
     samePicture();
+*/
     return true;
 }
 /**
@@ -636,11 +647,13 @@
 */
 bool admPreview::previousKeyFrame(void)
 {
+/*
     uint32_t frame=video_body->getCurrentFrame();
     if(!video_body->getPKFrame(&frame)) return false;
     if(!video_body->GoToIntra(frame)) return false;
     video_body->setCurrentFrame(frame);
     samePicture();
+*/
     return true;
 }/**
     \fn previousFrame
@@ -663,7 +676,7 @@
         }
         return false;
     }
-
+#if 0
     // Else go to the previous  keyframe...
     if(!video_body->getPKFrame(&frame)) return false;
     if(!video_body->GoToIntra(frame)) return false;
@@ -685,6 +698,7 @@
         renderUpdateImage(rdrImage->data,zoom);
         return true;
     }
+#endif
     return false;
 }
 // EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script/ADM_JSAvidemux.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script/ADM_JSAvidemux.cpp	2009-10-14 05:46:19 UTC (rev 5379)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script/ADM_JSAvidemux.cpp	2009-10-14 05:46:21 UTC (rev 5380)
@@ -500,7 +500,7 @@
         if(argc != 0)
                 return JS_FALSE;
         enterLock();
-        if(!video_body->isReordered(0)) // already done
+//        if(!video_body->isReordered(0)) // already done
         {
           //video_body->rebuildFrameType();
         }

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/gui_navigate.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/gui_navigate.cpp	2009-10-14 05:46:19 UTC (rev 5379)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/gui_navigate.cpp	2009-10-14 05:46:21 UTC (rev 5380)
@@ -239,7 +239,7 @@
 
     } else
       {
-	  if (!video_body->getPKFrame(&frame))
+//	  if (!video_body->getPKFrame(&frame))
 	    {
 		printf("[GUI_GoToKFrame] failed for frame %u\n", frame);
 		return;



From mean at mail.berlios.de  Wed Oct 14 07:46:24 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 14 Oct 2009 07:46:24 +0200
Subject: [Avidemux-svn-commit] r5381 - in
	branches/avidemux_2.6_branch_mean/avidemux/common: . ADM_editor
Message-ID: <200910140546.n9E5kO75004604@sheep.berlios.de>

Author: mean
Date: 2009-10-14 07:46:24 +0200 (Wed, 14 Oct 2009)
New Revision: 5381

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edSearch.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.h
   branches/avidemux_2.6_branch_mean/avidemux/common/gui_navigate.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/prototype.h
Log:
[seek] Slightly better seeking

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp	2009-10-14 05:46:21 UTC (rev 5380)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp	2009-10-14 05:46:24 UTC (rev 5381)
@@ -45,7 +45,7 @@
 
     if(_segments.getRefFromFrame(frame,&ref,&relframe)==false)
     {
-        ADM_warning("[GoToIntra] Cannot convert frame %"LU"\n",frame);
+        ADM_warning(" Cannot convert frame %"LU"\n",frame);
         return false;
     }
     return DecodePictureUpToIntra(relframe,ref);
@@ -72,6 +72,18 @@
     return GoToIntra(frame);
 }
 /**
+    \fn GoToIntraTime
+    \brief Go to an intra at time time (exact)
+    \return true on success, false on error
+*/
+bool        ADM_Composer::GoToIntraTime(uint64_t time)
+{
+    // 1st go to the previous intra...
+      uint32_t frame=searchFrameAt(time);
+    ADM_info("When looking for frame at %"LLU" ms, found frame %"LU" as candidate\n",time,frame);
+    return GoToIntra(frame);
+}
+/**
     \fn NextPicture
     \brief decode & returns the next picture
 */

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edSearch.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edSearch.cpp	2009-10-14 05:46:21 UTC (rev 5380)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edSearch.cpp	2009-10-14 05:46:24 UTC (rev 5381)
@@ -30,7 +30,7 @@
     // 1- Convert frameTime to segments
     if(false== _segments.convertLinearTimeToSeg(  *frameTime, &seg, &segTime))
     {
-        ADM_warning("[getSegmentFromTime] Cannot find seg for time %"LLD"\n",*frameTime);
+        ADM_warning(" Cannot find seg for time %"LLD"\n",*frameTime);
         return false;
     }   
     // 
@@ -44,11 +44,11 @@
     r=searchNextKeyFrameInRef(ref,refTime,&nkTime);
 
     // 3- if it does not belong to the same seg  ....
-    if(r==false || nkTime > (s->_refStartTimeUs+s->_refStartTimeUs))
+    if(r==false || nkTime > (s->_refStartTimeUs+s->_durationUs))
     {
         if(seg>=lastSeg-1)
         {
-            ADM_warning("[getSegmentFromTime] No next keyframe keyfr for frameTime \n");
+            ADM_warning(" No next keyframe keyfr for frameTime \n");
             return false;
         }
         // Go to the next segment
@@ -68,8 +68,42 @@
 
 bool			ADM_Composer::getPKFramePTS(uint64_t *frameTime)
 {
+uint64_t refTime,nkTime,segTime;
+int lastSeg=_segments.getNbSegments();
+uint32_t seg;
+bool r;
+    // 1- Convert frameTime to segments
+    if(false== _segments.convertLinearTimeToSeg(  *frameTime, &seg, &segTime))
+    {
+        ADM_warning(" Cannot find seg for time %"LLD"\n",*frameTime);
+        return false;
+    }   
+    // 
+again:
+    _SEGMENT *s=_segments.getSegment(seg);
+    uint32_t ref=s->_reference;
+    // 2- Now search the previous keyframe in the ref image...
+    // The time in reference = relTime+segmentStartTime
+    refTime=s->_startTimeUs+segTime; // Absolute time in the reference image
+    
+    r=searchPreviousKeyFrameInRef(ref,refTime,&nkTime);
 
-
+    // 3- if it does not belong to the same seg  ....
+    if(r==false || nkTime < (s->_refStartTimeUs))
+    {
+        if(!seg)
+        {
+            ADM_warning(" No next previous keyfr for frameTime %"LLU"\n",*frameTime);
+            return false;
+        }
+        // Go to the next segment
+        seg--;
+        goto again;
+    }
+    // Gotit, now convert it to the linear time
+    nkTime-=s->_startTimeUs;  // Ref to segment...
+    _segments.convertSegTimeToLinear(seg,nkTime,frameTime);
+    return true;
 }
 /**
     \fn searchNextKeyFrameInRef
@@ -84,23 +118,54 @@
     // Search from the end till we get a keyframe
     _VIDEOS *v=_segments.getRefVideo(ref);
     uint32_t nbFrame=v->_nb_video_frames;
-    
+    uint64_t pts,dts;
     for(int i=0;i<nbFrame;i++)
     {
         uint64_t p;
         uint32_t flags;
         v->_aviheader->getFlags(i,&flags);
         if(!(flags & AVI_KEY_FRAME)) continue;
-        p=v->_aviheader->estimatePts(i);
-        if(p>refTime &&p!=ADM_NO_PTS)
+        v->_aviheader->getPtsDts(i,&pts,&dts);
+        if(pts==ADM_NO_PTS) continue;
+        if(pts>refTime)
         {
-            *nkTime=p;
+            *nkTime=pts;
             return true;
         }
     }
     return false;
 }
+/**
+    \fn searchPreviousKeyFrameInRef
+    \brief Search next key frame in ref video ref
+    @param ref: # of ref video
+    @param refTime : PTS to search keyframe after   
+    @param nkTime : Time of the ref video
 
+*/
+bool ADM_Composer::searchPreviousKeyFrameInRef(int ref,uint64_t refTime,uint64_t *nkTime)
+{
+    // Search from the end till we get a keyframe
+    _VIDEOS *v=_segments.getRefVideo(ref);
+    uint32_t nbFrame=v->_nb_video_frames;
+    uint64_t pts,dts;
+    for(int i=nbFrame-1;i>=0;i--)
+    {
+        uint64_t p;
+        uint32_t flags;
+        v->_aviheader->getFlags(i,&flags);
+        if(!(flags & AVI_KEY_FRAME)) continue;
+        v->_aviheader->getPtsDts(i,&pts,&dts);
+        if(pts==ADM_NO_PTS) continue;
+        if(pts<refTime)
+        {
+            *nkTime=pts;
+            return true;
+        }
+    }
+    return false;
+}
+
 /**
     \fn searchFrameBefore
     \brief Return the frame number with pts just before pts
@@ -111,7 +176,7 @@
 uint32_t ref;
     if(false==_segments.getRefFromTime(pts,&ref,&refTime))
     {
-        ADM_warning("[searchFrameBefore] Failed for pts %"LLU"\n",pts);
+        ADM_warning(" Failed for pts %"LLU"\n",pts);
         ref=0;
         refTime=pts;
     }
@@ -135,6 +200,41 @@
     return nb-1;
 }
 /**
+    \fn searchFrameBefore
+    \brief Return the frame number with pts just before pts
+*/
+uint32_t ADM_Composer::searchFrameAt(uint64_t pts)
+{
+uint64_t refTime;
+uint32_t ref;
+    if(false==_segments.getRefFromTime(pts,&ref,&refTime))
+    {
+        ADM_warning(" Failed for pts %"LLU"\n",pts);
+        ref=0;
+        refTime=pts;
+    }
+#warning fix over-seg issue
+    _VIDEOS   *vid=_segments.getRefVideo(ref);
+    vidHeader *demuxer=vid->_aviheader;
+    
+    uint32_t  nb=demuxer->getVideoStreamHeader()->dwLength;
+;
+
+	for(int i=0;i<nb;i++)
+    {
+        uint64_t thisPts,thisDts;
+        demuxer->getPtsDts(i,&thisPts,&thisDts);
+        if(thisPts==ADM_NO_PTS) continue;
+        if(refTime==thisPts)
+        {
+            ADM_info("Found frame %"LU" for time %"LLU" ms\n",i,thisPts/1000);
+            return i;
+        }
+    }
+    ADM_warning("Cannot find frame at %"LLU"\n",pts);
+    return 0;
+}
+/**
     \fn getImageFromCacheForFrameBefore
     \brief Search the cache for the image with PTS just before the input PTS
 */
@@ -160,12 +260,12 @@
 uint32_t ref,refOffset;
     if(_segments.getRefFromFrame(frame,&ref,&refOffset)==false)
     {
-        ADM_warning("[Composer::getPtsDts] Cannot get ref video for frame %"LD"\n",frame);
+        ADM_warning("Cannot get ref video for frame %"LD"\n",frame);
         return false;
     }
  
      _VIDEOS   *vid=_segments.getRefVideo(ref);
     vidHeader *demuxer=vid->_aviheader;
     return demuxer->getPtsDts(frame,pts,dts); // FIXME : Rescale frame number
-
-}
\ No newline at end of file
+}
+//EOF
\ No newline at end of file

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx	2009-10-14 05:46:21 UTC (rev 5380)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx	2009-10-14 05:46:24 UTC (rev 5381)
@@ -120,11 +120,14 @@
                     bool        setCurrentFrame(uint32_t frame);
                     bool        GoToIntra(uint32_t frame);
                     bool        GoToTime(uint64_t time);
+                    bool        GoToIntraTime(uint64_t time);
                     bool        NextPicture(ADMImage *image);
                     bool        samePicture(ADMImage *image);
+
                     bool        getCompressedPicure(uint32_t framenum,ADMCompressedImage *img);
                     uint64_t    estimatePts(uint32_t frame);
                     uint32_t    searchFrameBefore(uint64_t pts);
+                    uint32_t    searchFrameAt(uint64_t pts);
                     bool        getImageFromCacheForFrameBefore(uint64_t pts,ADMImage *out);
                     bool        getPictureJustBefore(uint64_t pts);
                     bool        getPtsDts(uint32_t frame,uint64_t *pts,uint64_t *dts);
@@ -142,6 +145,8 @@
                     bool        getSamePicture(ADMImage *out,uint32_t ref);
 
                     bool        searchNextKeyFrameInRef(int ref,uint64_t refTime,uint64_t *nkTime);
+                    bool        searchPreviousKeyFrameInRef(int ref,uint64_t refTime,uint64_t *nkTime);
+
 /************************************ Internal ******************************/
                     uint8_t 	getFrame(uint32_t   framenum,ADMCompressedImage *img,uint8_t *isSequential);
                     

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.cpp	2009-10-14 05:46:21 UTC (rev 5380)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.cpp	2009-10-14 05:46:24 UTC (rev 5381)
@@ -324,6 +324,7 @@
         if(rdrImage) return rdrImage->Pts;
 
 }
+
 /**
       \fn admPreview::update
       \brief display data associated with framenum image
@@ -341,7 +342,24 @@
     return samePicture();
 
 }
+
 /**
+      \fn admPreview::seekToIntraPts
+      \brief Seek to intra at PTS given as arg
+      
+      @param timeframe Time of the image 
+*/
+
+bool admPreview::seekToIntraPts(uint64_t timeframe)
+{
+    if(!video_body->GoToIntraTime(timeframe)) 
+    {
+        ADM_warning(" seeking for frame at %"LLU" ms failed\n",timeframe/1000LL);
+        return false;
+    }
+    return samePicture();
+}
+/**
     \fn samePicture
 */
 uint8_t admPreview::samePicture(void)
@@ -631,15 +649,7 @@
         return false;
     }
     ADM_info("next kf PTS :%"LLD" ms\n",pts/1000LL);
-    return true;
-/*
-    uint32_t frame=video_body->getCurrentFrame();
-    if(!video_body->getNKFrame(&frame)) return false;
-    if(!video_body->GoToIntra(frame)) return false;
-    video_body->setCurrentFrame(frame);
-    samePicture();
-*/
-    return true;
+    return seekToIntraPts(pts);
 }
 /**
     \fn previousKeyFrame
@@ -647,13 +657,15 @@
 */
 bool admPreview::previousKeyFrame(void)
 {
-/*
-    uint32_t frame=video_body->getCurrentFrame();
-    if(!video_body->getPKFrame(&frame)) return false;
-    if(!video_body->GoToIntra(frame)) return false;
-    video_body->setCurrentFrame(frame);
-    samePicture();
-*/
+    uint64_t pts=getCurrentPts();
+    ADM_info("Current PTS :%"LLD" ms\n",pts/1000LL);
+    if(false==video_body->getPKFramePTS(&pts))
+    {
+        ADM_warning("Cannot find previous keyframe\n");
+        return false;
+    }
+    ADM_info("next kf PTS :%"LLD" ms\n",pts/1000LL);
+    return seekToIntraPts(pts);
     return true;
 }/**
     \fn previousFrame

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.h	2009-10-14 05:46:21 UTC (rev 5380)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.h	2009-10-14 05:46:24 UTC (rev 5381)
@@ -25,6 +25,7 @@
       static uint8_t nextPicture(void);
       static uint8_t samePicture(void);
       static uint8_t seekToIntra(uint32_t framenum);
+      static bool seekToIntraPts(uint64_t timeframe);
       static void start(void);
       static void stop(void);
       static void setMainDimension(uint32_t, uint32_t );

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/gui_navigate.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/gui_navigate.cpp	2009-10-14 05:46:21 UTC (rev 5380)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/gui_navigate.cpp	2009-10-14 05:46:24 UTC (rev 5381)
@@ -54,7 +54,10 @@
           uint32_t nf;
           ignore_change++;
           nf = GUI_GetScale ();
-          if (!SliderIsShifted) GUI_GoToKFrame (nf);
+          double tme=nf;
+          tme=video_body->getDurationInUs();
+          tme/=ADM_SCALE_SIZE;
+          if (!SliderIsShifted) GUI_GoToKFrameTime (tme);
           else GUI_GoToFrame (nf);
           ignore_change--;
 
@@ -143,7 +146,7 @@
             }
 	  break;
       case ACT_Begin:
-        GUI_GoToKFrame(0);
+        GUI_GoToKFrameTime(0);
 	  break;
       case ACT_JumpToFrame:
         {
@@ -225,27 +228,15 @@
     \fn GUI_GoToKFrame
     \brief Go to the nearest previous keyframe
 */
-void GUI_GoToKFrame(uint32_t frame)
+void GUI_GoToKFrameTime(uint64_t timeFrame)
 {
 
     if (playing)
 	return;
     if (!avifileinfo)
 	return;
-    uint32_t f;
-    video_body->getFlags(0, &f);
-    if (!frame && (f & AVI_KEY_FRAME))
-      {
 
-    } else
-      {
-//	  if (!video_body->getPKFrame(&frame))
-	    {
-		printf("[GUI_GoToKFrame] failed for frame %u\n", frame);
-		return;
-	    }
-      }
-    admPreview::seekToIntra(frame);
+    admPreview::seekToIntraPts(timeFrame);
     admPreview::samePicture();
     GUI_setCurrentFrameAndTime();
     UI_purge();
@@ -411,15 +402,8 @@
     UI_setTotalTime(video_body->getVideoDuration());
 
     // progress bar
-    len = 100;
-    if (avifileinfo->nb_frames > 1)
-	len = len / (double) (avifileinfo->nb_frames - 1);
-    len *= (double) video_body->getCurrentFrame();
+    UI_setScale(ADM_SCALE_SIZE);
 
-
-
-    UI_setScale(len);
-
 }
 
 /**
@@ -439,15 +423,8 @@
 		     avifileinfo->nb_frames);
     UI_setCurrentTime(admPreview::getCurrentPts());
 
-    // progress bar
-    len = 100;
-    if (avifileinfo->nb_frames > 1)
-	len = len / (double) (avifileinfo->nb_frames - 1);
-    len *= (double) video_body->getCurrentFrame();
 
-
-
-    UI_setScale(len);
+    UI_setScale(ADM_SCALE_SIZE);
 }
 /**
     \fn A_jumpToTime

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/prototype.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/prototype.h	2009-10-14 05:46:21 UTC (rev 5380)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/prototype.h	2009-10-14 05:46:24 UTC (rev 5381)
@@ -9,8 +9,8 @@
 uint8_t	GUI_XvRedraw(void);
 
 // GUI
-
-void GUI_GoToKFrame(uint32_t frame); // same as below execpt								                     // closest previous frame
+#define ADM_SCALE_SIZE 10000
+void GUI_GoToKFrameTime(uint64_t frame); // same as below execpt								                     // closest previous frame
 int GUI_GoToFrame(uint32_t frame);
 // not in callback.h to avoid importing COMPRESSION MODE in interface.cpp
 



From mean at mail.berlios.de  Wed Oct 14 19:51:16 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 14 Oct 2009 19:51:16 +0200
Subject: [Avidemux-svn-commit] r5382 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_infoExtractor
Message-ID: <200910141751.n9EHpGhQ031905@sheep.berlios.de>

Author: mean
Date: 2009-10-14 19:51:16 +0200 (Wed, 14 Oct 2009)
New Revision: 5382

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_infoExtractor/ADM_infoextractor.cpp
Log:
[H264/TS] Fix loading of lumix file

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_infoExtractor/ADM_infoextractor.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_infoExtractor/ADM_infoextractor.cpp	2009-10-14 05:46:24 UTC (rev 5381)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_infoExtractor/ADM_infoextractor.cpp	2009-10-14 17:51:16 UTC (rev 5382)
@@ -437,7 +437,7 @@
                  {
                       get_se_golomb(&s);
                  }
-             }else 
+             }else if(pic_order_cnt_type!=2)
              {
                printf("Error in SPS\n");
                return 0;
@@ -706,4 +706,4 @@
     	return 1; 
     }   
 	return 1;
-}
\ No newline at end of file
+}



From mean at mail.berlios.de  Thu Oct 15 19:36:30 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 15 Oct 2009 19:36:30 +0200
Subject: [Avidemux-svn-commit] r5383 -
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src
Message-ID: <200910151736.n9FHaU02011476@sheep.berlios.de>

Author: mean
Date: 2009-10-15 19:36:29 +0200 (Thu, 15 Oct 2009)
New Revision: 5383

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_infoExtractor.cpp
Log:
[info extractor] Cosmetic + allow poc=2

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_infoExtractor.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_infoExtractor.cpp	2009-10-14 17:51:16 UTC (rev 5382)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_infoExtractor.cpp	2009-10-15 17:36:29 UTC (rev 5383)
@@ -398,14 +398,17 @@
            printf("[H264]Profile : %u, Level :%u, SPSid:%u\n",profile,level,id);
            if(profile>=100) // ?? Borrowed from H264.C/FFMPEG
            {
-              printf("[H264]Warning : High profile\n");
-              if(get_ue_golomb(&s) == 3) //chroma_format_idc
-                get_bits1(&s);  //residual_color_transform_flag
-            get_ue_golomb(&s);  //bit_depth_luma_minus8
-            get_ue_golomb(&s);  //bit_depth_chroma_minus8
-            get_bits1(&s);
-			if (get_bits1(&s))
-				get_bits(&s, 8);
+                printf("[H264]Warning : High profile\n");
+                if(get_ue_golomb(&s) == 3) //chroma_format_idc
+                    get_bits1(&s);  //residual_color_transform_flag
+                get_ue_golomb(&s);  //bit_depth_luma_minus8
+                get_ue_golomb(&s);  //bit_depth_chroma_minus8
+                get_bits1(&s);      // Transform bypass
+                if (get_bits1(&s)) // Scaling matrix
+                {
+                    printf("[H264] Scaling matrix present\n");
+                    get_bits(&s, 8);
+                }
            }
            
 
@@ -430,7 +433,7 @@
                  {
                       get_se_golomb(&s);
                  }
-             }else 
+             }else if(pic_order_cnt_type!=2)
              {
                printf("Error in SPS\n");
                return 0;



From mean at mail.berlios.de  Thu Oct 15 19:36:32 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 15 Oct 2009 19:36:32 +0200
Subject: [Avidemux-svn-commit] r5384 - in
	branches/avidemux_2.6_branch_mean/avidemux/common: . ADM_editor
Message-ID: <200910151736.n9FHaWEg011505@sheep.berlios.de>

Author: mean
Date: 2009-10-15 19:36:31 +0200 (Thu, 15 Oct 2009)
New Revision: 5384

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edSearch.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/gui_navigate.cpp
Log:
[Editor] Seeking + handle seek bar as time based

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edSearch.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edSearch.cpp	2009-10-15 17:36:29 UTC (rev 5383)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edSearch.cpp	2009-10-15 17:36:31 UTC (rev 5384)
@@ -39,7 +39,7 @@
     uint32_t ref=s->_reference;
     // 2- Now search the previous keyframe in the ref image...
     // The time in reference = relTime+segmentStartTime
-    refTime=s->_startTimeUs+segTime; // Absolute time in the reference image
+    refTime=s->_refStartTimeUs+segTime; // Absolute time in the reference image
     
     r=searchNextKeyFrameInRef(ref,refTime,&nkTime);
 
@@ -56,7 +56,8 @@
         goto again;
     }
     // Gotit, now convert it to the linear time
-    nkTime-=s->_startTimeUs;  // Ref to segment...
+    // We have the time in the ref video, convert it to relatative to this segment
+    nkTime-=s->_refStartTimeUs;  // Ref to segment...
     _segments.convertSegTimeToLinear(seg,nkTime,frameTime);
     return true;
 
@@ -84,7 +85,7 @@
     uint32_t ref=s->_reference;
     // 2- Now search the previous keyframe in the ref image...
     // The time in reference = relTime+segmentStartTime
-    refTime=s->_startTimeUs+segTime; // Absolute time in the reference image
+    refTime=s->_refStartTimeUs+segTime; // Absolute time in the reference image
     
     r=searchPreviousKeyFrameInRef(ref,refTime,&nkTime);
 
@@ -101,7 +102,7 @@
         goto again;
     }
     // Gotit, now convert it to the linear time
-    nkTime-=s->_startTimeUs;  // Ref to segment...
+    nkTime-=s->_refStartTimeUs;  // Ref to segment...
     _segments.convertSegTimeToLinear(seg,nkTime,frameTime);
     return true;
 }
@@ -268,4 +269,12 @@
     vidHeader *demuxer=vid->_aviheader;
     return demuxer->getPtsDts(frame,pts,dts); // FIXME : Rescale frame number
 }
+/**
+    \fn getDurationInUs
+    \brief Return total duration of video in us
+*/
+ uint64_t        ADM_Composer::getDurationInUs(void) 
+{
+    return _segments.getTotalDuration();
+}
 //EOF
\ No newline at end of file

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx	2009-10-15 17:36:29 UTC (rev 5383)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx	2009-10-15 17:36:31 UTC (rev 5384)
@@ -176,7 +176,7 @@
                     uint8_t         getPCMPacket(float  *dest, uint32_t sizeMax, uint32_t *samples,uint64_t *odts);
             virtual bool            goToTime(uint64_t nbUs);
                     bool            getExtraData(uint32_t *l, uint8_t **d);
-                    uint64_t        getDurationInUs(void) {return durationInUs;}
+                    uint64_t        getDurationInUs(void);
                     uint8_t			getAudioStream(ADM_audioStream **audio);
             virtual WAVHeader       *getInfo(void);
             virtual CHANNEL_TYPE    *getChannelMapping(void );

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.cpp	2009-10-15 17:36:29 UTC (rev 5383)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.cpp	2009-10-15 17:36:31 UTC (rev 5384)
@@ -666,7 +666,6 @@
     }
     ADM_info("next kf PTS :%"LLD" ms\n",pts/1000LL);
     return seekToIntraPts(pts);
-    return true;
 }/**
     \fn previousFrame
 

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp	2009-10-15 17:36:29 UTC (rev 5383)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp	2009-10-15 17:36:31 UTC (rev 5384)
@@ -38,7 +38,7 @@
 #include "ADM_audioFilter/include/ADM_audioFilterInterface.h"
 
 #include "avi_vars.h"
-
+#include "prototype.h" // FIXME
 char * actual_workbench_file;
 renderZoom currentZoom=ZOOM_1_1;
 //***********************************
@@ -1221,7 +1221,7 @@
     float tg;
 
     percent = UI_readScale();
-    tg= (avifileinfo->nb_frames-1) * percent / 100.;
+    tg= ADM_SCALE_SIZE * percent / 100.;
 
     return (uint32_t)floor(tg);;
 }

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/gui_navigate.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/gui_navigate.cpp	2009-10-15 17:36:29 UTC (rev 5383)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/gui_navigate.cpp	2009-10-15 17:36:31 UTC (rev 5384)
@@ -54,13 +54,24 @@
           uint32_t nf;
           ignore_change++;
           nf = GUI_GetScale ();
+          ADM_info("Scale :%"LU"\n",nf);
           double tme=nf;
-          tme=video_body->getDurationInUs();
+          tme*=video_body->getDurationInUs();
           tme/=ADM_SCALE_SIZE;
-          if (!SliderIsShifted) GUI_GoToKFrameTime (tme);
-          else GUI_GoToFrame (nf);
-          ignore_change--;
-
+          uint64_t pts=(uint64_t)tme;
+          ADM_info("Scale Time:%"LLU" ms (total=%"LLU" ms)\n",pts/1000,video_body->getDurationInUs()/1000);
+           if(false==video_body->getPKFramePTS(&pts))
+            {
+                ADM_warning("Cannot seel to %"LLU" ms\n",pts/1000);
+                ignore_change--;
+                break;
+            }
+            
+            if(true!=admPreview::seekToIntraPts(pts))
+            {
+                ADM_warning("Scale: Seeking to intra at %"LLU" ms failed\n",pts/1000);
+            }
+            ignore_change--;
         }
         break;
       case ACT_GotoMarkA:



From mean at mail.berlios.de  Fri Oct 16 07:38:39 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 16 Oct 2009 07:38:39 +0200
Subject: [Avidemux-svn-commit] r5385 - in
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers:
	MpegPS MpegTS
Message-ID: <200910160538.n9G5cdih011310@sheep.berlios.de>

Author: mean
Date: 2009-10-16 07:38:36 +0200 (Fri, 16 Oct 2009)
New Revision: 5385

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegPS/ADM_ps.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegPS/ADM_psIndex.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegPS/ADM_psPlugin.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS/ADM_ts.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS/ADM_tsIndex.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS/ADM_tsPlugin.cpp
Log:
[Plugin/ts/ps] Use .idx2 rather than .idx so that files can co-exist with 2.4/2.5

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegPS/ADM_ps.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegPS/ADM_ps.cpp	2009-10-15 17:36:31 UTC (rev 5384)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegPS/ADM_ps.cpp	2009-10-16 05:38:36 UTC (rev 5385)
@@ -38,7 +38,7 @@
     char *type;
     uint64_t startDts;
 
-    sprintf(idxName,"%s.idx",name);
+    sprintf(idxName,"%s.idx2",name);
     indexFile index;
     if(!index.open(idxName))
     {

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegPS/ADM_psIndex.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegPS/ADM_psIndex.cpp	2009-10-15 17:36:31 UTC (rev 5384)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegPS/ADM_psIndex.cpp	2009-10-16 05:38:36 UTC (rev 5385)
@@ -150,7 +150,7 @@
 
     memset(&data,0,sizeof(data));
     char indexName[strlen(file)+5];
-    sprintf(indexName,"%s.idx",file);
+    sprintf(indexName,"%s.idx2",file);
     index=qfopen(indexName,"wt");
     if(!index)
     {

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegPS/ADM_psPlugin.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegPS/ADM_psPlugin.cpp	2009-10-15 17:36:31 UTC (rev 5384)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegPS/ADM_psPlugin.cpp	2009-10-16 05:38:36 UTC (rev 5385)
@@ -41,7 +41,7 @@
         return false;
     }
 
-    sprintf(index,"%s.idx",fileName);
+    sprintf(index,"%s.idx2",fileName);
 again:    
     if(ADM_fileExist(index)) 
     {

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS/ADM_ts.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS/ADM_ts.cpp	2009-10-15 17:36:31 UTC (rev 5384)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS/ADM_ts.cpp	2009-10-16 05:38:36 UTC (rev 5385)
@@ -39,7 +39,7 @@
     uint64_t startDts;
     
 
-    sprintf(idxName,"%s.idx",name);
+    sprintf(idxName,"%s.idx2",name);
     indexFile index;
     if(!index.open(idxName))
     {

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS/ADM_tsIndex.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS/ADM_tsIndex.cpp	2009-10-15 17:36:31 UTC (rev 5384)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS/ADM_tsIndex.cpp	2009-10-16 05:38:36 UTC (rev 5385)
@@ -296,7 +296,7 @@
 
     memset(&data,0,sizeof(data));
     char indexName[strlen(file)+5];
-    sprintf(indexName,"%s.idx",file);
+    sprintf(indexName,"%s.idx2",file);
     index=qfopen(indexName,"wt");
     if(!index)
     {
@@ -518,7 +518,7 @@
 
 
     char indexName[strlen(file)+5];
-    sprintf(indexName,"%s.idx",file);
+    sprintf(indexName,"%s.idx2",file);
     index=qfopen(indexName,"wt");
     if(!index)
     {

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS/ADM_tsPlugin.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS/ADM_tsPlugin.cpp	2009-10-15 17:36:31 UTC (rev 5384)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS/ADM_tsPlugin.cpp	2009-10-16 05:38:36 UTC (rev 5385)
@@ -42,7 +42,7 @@
         printf(" [TS Demuxer] Not a ts file\n");
         return false;
     }
-    sprintf(index,"%s.idx",fileName);
+    sprintf(index,"%s.idx2",fileName);
 again:    
     if(ADM_fileExist(index)) 
     {



From mean at mail.berlios.de  Tue Oct 20 15:26:35 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 20 Oct 2009 15:26:35 +0200
Subject: [Avidemux-svn-commit] r5386 - in
	branches/avidemux_2.6_branch_mean/avidemux: common
	qt4/ADM_userInterfaces/ADM_gui
Message-ID: <200910201326.n9KDQZWT003819@sheep.berlios.de>

Author: mean
Date: 2009-10-20 15:26:35 +0200 (Tue, 20 Oct 2009)
New Revision: 5386

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/gui_navigate.cpp
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_gui2.cpp
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/gui2.ui
Log:
[Qt4] Remove frame, only set time in QT4 ui

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/gui_navigate.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/gui_navigate.cpp	2009-10-16 05:38:36 UTC (rev 5385)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/gui_navigate.cpp	2009-10-20 13:26:35 UTC (rev 5386)
@@ -71,6 +71,7 @@
             {
                 ADM_warning("Scale: Seeking to intra at %"LLU" ms failed\n",pts/1000);
             }
+            GUI_setCurrentFrameAndTime();
             ignore_change--;
         }
         break;
@@ -425,17 +426,9 @@
 {
     char text[80];
     double len;
-    // int val;
-
-    // if(!guiReady) return ;
-    text[0] = 0;
-
-    UI_setFrameCount(video_body->getCurrentFrame(),
-		     avifileinfo->nb_frames);
+   
     UI_setCurrentTime(admPreview::getCurrentPts());
-
-
-    UI_setScale(ADM_SCALE_SIZE);
+    //UI_setScale(ADM_SCALE_SIZE);
 }
 /**
     \fn A_jumpToTime

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_gui2.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_gui2.cpp	2009-10-16 05:38:36 UTC (rev 5385)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_gui2.cpp	2009-10-20 13:26:35 UTC (rev 5386)
@@ -284,27 +284,23 @@
 	connect(ui.spinBox_TimeValue,SIGNAL(valueChanged(int)),this,SLOT(timeChanged(int)));
 	connect(ui.spinBox_TimeValue, SIGNAL(editingFinished()), this, SLOT(timeChangeFinished()));
 
-	connect(ui.lineEdit, SIGNAL(editingFinished()), this, SLOT(currentFrameChanged()));
 
-	QIntValidator *frameValidator = new QIntValidator(0, 0x7FFFFFFF, this);
-	ui.lineEdit->setValidator(frameValidator);
 
-	connect(ui.lineEdit, SIGNAL(editingFinished()), this, SLOT(currentFrameChanged()));
 
 	QRegExp timeRegExp("^[0-9]{2}:[0-5][0-9]:[0-5][0-9]\\.[0-9]{3}$");
 	QRegExpValidator *timeValidator = new QRegExpValidator(timeRegExp, this);
-	ui.lineEdit_2->setValidator(timeValidator);
-	ui.lineEdit_2->setInputMask("99:99:99.999");
+	ui.currentTime->setValidator(timeValidator);
+	ui.currentTime->setInputMask("99:99:99.999");
 
-	connect(ui.lineEdit_2, SIGNAL(editingFinished()), this, SLOT(currentTimeChanged()));
+	connect(ui.currentTime, SIGNAL(editingFinished()), this, SLOT(currentTimeChanged()));
 
 	/* Build the custom menu */
 	buildCustomMenu();
 
 	this->installEventFilter(this);
 	slider->installEventFilter(this);
-	ui.lineEdit->installEventFilter(this);
-	ui.lineEdit_2->installEventFilter(this);
+	
+	ui.currentTime->installEventFilter(this);
 
 	this->setFocus(Qt::OtherFocusReason);
 
@@ -424,16 +420,8 @@
 
 			break;
 		case QEvent::FocusOut:
-			if (watched == ui.lineEdit)
+			if (watched == ui.currentTime)
 			{
-				QString temp(ui.lineEdit->text());
-				int pos = 0;
-
-				if (ui.lineEdit->validator()->validate(temp, pos) != QValidator::Acceptable)
-					UI_updateFrameCount(currentFrame);
-			}
-			else if (watched == ui.lineEdit_2)
-			{
 				uint16_t hh, mm, ss, ms;
 
 				if (!UI_readCurTime(hh, mm, ss, ms))
@@ -782,19 +770,17 @@
 
 int UI_readCurFrame(void)
 {
-	bool ok;
-	
-	return WIDGET(lineEdit)->text().toInt(&ok);
+	return 0;
 }
 
 int UI_readCurTime(uint16_t &hh, uint16_t &mm, uint16_t &ss, uint16_t &ms)
 {
 	int success = 0;
 
-	QString timeText = WIDGET(lineEdit_2)->text();
+	QString timeText = WIDGET(currentTime)->text();
 	int pos;
 
-	if (WIDGET(lineEdit_2)->validator()->validate(timeText, pos) == QValidator::Acceptable)
+	if (WIDGET(currentTime)->validator()->validate(timeText, pos) == QValidator::Acceptable)
 	{
 		uint32_t frame;
 
@@ -876,11 +862,7 @@
 */
 void UI_updateFrameCount(uint32_t curFrame)
 {
-	char string[30];
-	sprintf(string,"%"LU,curFrame);
-	WIDGET(lineEdit)->setText(string);
-
-	currentFrame = curFrame;
+	
 }
 
 /**
@@ -889,16 +871,7 @@
 */
 void UI_setFrameCount(uint32_t curFrame,uint32_t total)
 {
-	char text[80]; 
-	if (total) total--; // We display from 0 to X  
-
-	UI_updateFrameCount(curFrame);
-
-	sprintf(text, "/ %"LU, total);
-	WIDGET(label_2)->setText(text);
-
-	((QIntValidator*)(WIDGET(lineEdit)->validator()))->setTop(total);
-	frameCount = total;
+	
 }
 
 /**
@@ -912,7 +885,7 @@
 
 	frame2time(curFrame,fps, &hh, &mm, &ss, &ms);
 	sprintf(text, "%02d:%02d:%02d.%03d", hh, mm, ss, ms);
-	WIDGET(lineEdit_2)->setText(text);
+	WIDGET(currentTime)->setText(text);
 }
 
 /**
@@ -929,7 +902,7 @@
 	UI_updateTimeCount(curFrame,fps);
 	frame2time(total,fps, &hh, &mm, &ss, &ms);
 	sprintf(text, "/ %02d:%02d:%02d.%03d", hh, mm, ss, ms);
-	WIDGET(label_7)->setText(text);
+	WIDGET(totalTime)->setText(text);
 
 	slider->setFrameCount(total);
 
@@ -948,7 +921,7 @@
 
     ms2time(shorty,&hh,&mm,&ss,&ms);
   	sprintf(text, "%02d:%02d:%02d.%03d", hh, mm, ss, ms);
-	WIDGET(label_7)->setText(text);
+	WIDGET(currentTime)->setText(text);
 
 }
 
@@ -964,7 +937,7 @@
 
     ms2time(shorty,&hh,&mm,&ss,&ms);
   	sprintf(text, "/%02d:%02d:%02d.%03d", hh, mm, ss, ms);
-    //WIDGET(label_7)->setText(text);
+    WIDGET(totalTime)->setText(text);
 }
 /**
     \fn     UI_setMarkers(uint64_t Ptsa, uint32_t Ptsb )

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/gui2.ui
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/gui2.ui	2009-10-16 05:38:36 UTC (rev 5385)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/gui2.ui	2009-10-20 13:26:35 UTC (rev 5386)
@@ -1,8 +1,9 @@
-<ui version="4.0" >
+<?xml version="1.0" encoding="UTF-8"?>
+<ui version="4.0">
  <author>mean</author>
  <class>MainWindow</class>
- <widget class="QMainWindow" name="MainWindow" >
-  <property name="geometry" >
+ <widget class="QMainWindow" name="MainWindow">
+  <property name="geometry">
    <rect>
     <x>0</x>
     <y>0</y>
@@ -10,83 +11,83 @@
     <height>606</height>
    </rect>
   </property>
-  <property name="windowTitle" >
+  <property name="windowTitle">
    <string>Avidemux</string>
   </property>
-  <property name="windowIcon" >
+  <property name="windowIcon">
    <iconset>
     <normaloff/>
    </iconset>
   </property>
-  <property name="iconSize" >
+  <property name="iconSize">
    <size>
     <width>22</width>
     <height>22</height>
    </size>
   </property>
-  <widget class="QWidget" name="centralwidget" >
-   <layout class="QVBoxLayout" >
-    <property name="spacing" >
+  <widget class="QWidget" name="centralwidget">
+   <layout class="QVBoxLayout">
+    <property name="spacing">
      <number>6</number>
     </property>
-    <property name="margin" >
+    <property name="margin">
      <number>9</number>
     </property>
     <item>
-     <layout class="QHBoxLayout" >
-      <property name="spacing" >
+     <layout class="QHBoxLayout">
+      <property name="spacing">
        <number>6</number>
       </property>
-      <property name="margin" >
+      <property name="margin">
        <number>0</number>
       </property>
       <item>
-       <layout class="QVBoxLayout" >
-        <property name="spacing" >
+       <layout class="QVBoxLayout">
+        <property name="spacing">
          <number>6</number>
         </property>
-        <property name="margin" >
+        <property name="margin">
          <number>0</number>
         </property>
         <item>
-         <layout class="QVBoxLayout" >
-          <property name="spacing" >
+         <layout class="QVBoxLayout">
+          <property name="spacing">
            <number>0</number>
           </property>
-          <property name="margin" >
+          <property name="margin">
            <number>0</number>
           </property>
           <item>
-           <widget class="QLabel" name="label_3" >
-            <property name="sizePolicy" >
-             <sizepolicy vsizetype="Preferred" hsizetype="Preferred" >
+           <widget class="QLabel" name="label_3">
+            <property name="sizePolicy">
+             <sizepolicy hsizetype="Preferred" vsizetype="Preferred">
               <horstretch>0</horstretch>
               <verstretch>0</verstretch>
              </sizepolicy>
             </property>
-            <property name="maximumSize" >
+            <property name="maximumSize">
              <size>
               <width>180</width>
               <height>16777215</height>
              </size>
             </property>
-            <property name="text" >
-             <string>&lt;b>Video&lt;/b></string>
+            <property name="text">
+             <string>&lt;b&gt;Video&lt;/b&gt;</string>
             </property>
-            <property name="textFormat" >
+            <property name="textFormat">
              <enum>Qt::AutoText</enum>
             </property>
            </widget>
           </item>
           <item>
            <spacer>
-            <property name="orientation" >
+            <property name="orientation">
              <enum>Qt::Vertical</enum>
             </property>
-            <property name="sizeType" >
+            <property name="sizeType">
              <enum>QSizePolicy::Fixed</enum>
             </property>
-            <property name="sizeHint" stdset="0" >
+            <property name="sizeHint" stdset="0">
              <size>
               <width>20</width>
               <height>5</height>
@@ -95,22 +96,22 @@
            </spacer>
           </item>
           <item>
-           <layout class="QHBoxLayout" >
-            <property name="spacing" >
+           <layout class="QHBoxLayout">
+            <property name="spacing">
              <number>0</number>
             </property>
-            <property name="margin" >
+            <property name="margin">
              <number>0</number>
             </property>
             <item>
              <spacer>
-              <property name="orientation" >
+              <property name="orientation">
                <enum>Qt::Horizontal</enum>
               </property>
-              <property name="sizeType" >
+              <property name="sizeType">
                <enum>QSizePolicy::Fixed</enum>
               </property>
-              <property name="sizeHint" stdset="0" >
+              <property name="sizeHint" stdset="0">
                <size>
                 <width>12</width>
                 <height>0</height>
@@ -119,56 +120,56 @@
              </spacer>
             </item>
             <item>
-             <layout class="QVBoxLayout" >
-              <property name="spacing" >
+             <layout class="QVBoxLayout">
+              <property name="spacing">
                <number>6</number>
               </property>
-              <property name="margin" >
+              <property name="margin">
                <number>0</number>
               </property>
               <item>
-               <widget class="QComboBox" name="comboBoxVideo" >
-                <property name="sizePolicy" >
-                 <sizepolicy vsizetype="Fixed" hsizetype="Minimum" >
+               <widget class="QComboBox" name="comboBoxVideo">
+                <property name="sizePolicy">
+                 <sizepolicy hsizetype="Minimum" vsizetype="Fixed">
                   <horstretch>0</horstretch>
                   <verstretch>0</verstretch>
                  </sizepolicy>
                 </property>
                 <item>
-                 <property name="text" >
+                 <property name="text">
                   <string>Copy</string>
                  </property>
                 </item>
                </widget>
               </item>
               <item>
-               <widget class="QPushButton" name="pushButtonVideoConf" >
-                <property name="enabled" >
+               <widget class="QPushButton" name="pushButtonVideoConf">
+                <property name="enabled">
                  <bool>true</bool>
                 </property>
-                <property name="sizePolicy" >
-                 <sizepolicy vsizetype="Fixed" hsizetype="Minimum" >
+                <property name="sizePolicy">
+                 <sizepolicy hsizetype="Minimum" vsizetype="Fixed">
                   <horstretch>0</horstretch>
                   <verstretch>0</verstretch>
                  </sizepolicy>
                 </property>
-                <property name="text" >
+                <property name="text">
                  <string>Configure</string>
                 </property>
                </widget>
               </item>
               <item>
-               <widget class="QPushButton" name="pushButtonVideoFilter" >
-                <property name="enabled" >
+               <widget class="QPushButton" name="pushButtonVideoFilter">
+                <property name="enabled">
                  <bool>true</bool>
                 </property>
-                <property name="sizePolicy" >
-                 <sizepolicy vsizetype="Fixed" hsizetype="Minimum" >
+                <property name="sizePolicy">
+                 <sizepolicy hsizetype="Minimum" vsizetype="Fixed">
                   <horstretch>0</horstretch>
                   <verstretch>0</verstretch>
                  </sizepolicy>
                 </property>
-                <property name="text" >
+                <property name="text">
                  <string>Filters</string>
                 </property>
                </widget>
@@ -179,13 +180,13 @@
           </item>
           <item>
            <spacer>
-            <property name="orientation" >
+            <property name="orientation">
              <enum>Qt::Vertical</enum>
             </property>
-            <property name="sizeType" >
+            <property name="sizeType">
              <enum>QSizePolicy::Fixed</enum>
             </property>
-            <property name="sizeHint" stdset="0" >
+            <property name="sizeHint" stdset="0">
              <size>
               <width>1</width>
               <height>14</height>
@@ -194,36 +195,36 @@
            </spacer>
           </item>
           <item>
-           <widget class="QLabel" name="label_5" >
-            <property name="sizePolicy" >
-             <sizepolicy vsizetype="Preferred" hsizetype="Preferred" >
+           <widget class="QLabel" name="label_5">
+            <property name="sizePolicy">
+             <sizepolicy hsizetype="Preferred" vsizetype="Preferred">
               <horstretch>0</horstretch>
               <verstretch>0</verstretch>
              </sizepolicy>
             </property>
-            <property name="maximumSize" >
+            <property name="maximumSize">
              <size>
               <width>180</width>
               <height>16777215</height>
              </size>
             </property>
-            <property name="text" >
-             <string>&lt;b>Audio&lt;/b></string>
+            <property name="text">
+             <string>&lt;b&gt;Audio&lt;/b&gt;</string>
             </property>
-            <property name="textFormat" >
+            <property name="textFormat">
              <enum>Qt::AutoText</enum>
             </property>
            </widget>
           </item>
           <item>
            <spacer>
-            <property name="orientation" >
+            <property name="orientation">
              <enum>Qt::Vertical</enum>
             </property>
-            <property name="sizeType" >
+            <property name="sizeType">
              <enum>QSizePolicy::Fixed</enum>
             </property>
-            <property name="sizeHint" stdset="0" >
+            <property name="sizeHint" stdset="0">
              <size>
               <width>20</width>
               <height>5</height>
@@ -232,22 +233,22 @@
            </spacer>
           </item>
           <item>
-           <layout class="QHBoxLayout" >
-            <property name="spacing" >
+           <layout class="QHBoxLayout">
+            <property name="spacing">
              <number>0</number>
             </property>
-            <property name="margin" >
+            <property name="margin">
              <number>0</number>
             </property>
             <item>
              <spacer>
-              <property name="orientation" >
+              <property name="orientation">
                <enum>Qt::Horizontal</enum>
               </property>
-              <property name="sizeType" >
+              <property name="sizeType">
                <enum>QSizePolicy::Fixed</enum>
               </property>
-              <property name="sizeHint" stdset="0" >
+              <property name="sizeHint" stdset="0">
                <size>
                 <width>12</width>
                 <height>0</height>
@@ -256,87 +257,87 @@
              </spacer>
             </item>
             <item>
-             <layout class="QVBoxLayout" >
-              <property name="spacing" >
+             <layout class="QVBoxLayout">
+              <property name="spacing">
                <number>6</number>
               </property>
-              <property name="margin" >
+              <property name="margin">
                <number>0</number>
               </property>
               <item>
-               <widget class="QComboBox" name="comboBoxAudio" >
-                <property name="sizePolicy" >
-                 <sizepolicy vsizetype="Fixed" hsizetype="Minimum" >
+               <widget class="QComboBox" name="comboBoxAudio">
+                <property name="sizePolicy">
+                 <sizepolicy hsizetype="Minimum" vsizetype="Fixed">
                   <horstretch>0</horstretch>
                   <verstretch>0</verstretch>
                  </sizepolicy>
                 </property>
                 <item>
-                 <property name="text" >
+                 <property name="text">
                   <string>Copy</string>
                  </property>
                 </item>
                </widget>
               </item>
               <item>
-               <widget class="QPushButton" name="pushButtonAudioConf" >
-                <property name="enabled" >
+               <widget class="QPushButton" name="pushButtonAudioConf">
+                <property name="enabled">
                  <bool>true</bool>
                 </property>
-                <property name="sizePolicy" >
-                 <sizepolicy vsizetype="Fixed" hsizetype="Minimum" >
+                <property name="sizePolicy">
+                 <sizepolicy hsizetype="Minimum" vsizetype="Fixed">
                   <horstretch>0</horstretch>
                   <verstretch>0</verstretch>
                  </sizepolicy>
                 </property>
-                <property name="text" >
+                <property name="text">
                  <string>Configure</string>
                 </property>
                </widget>
               </item>
               <item>
-               <widget class="QPushButton" name="pushButtonAudioFilter" >
-                <property name="enabled" >
+               <widget class="QPushButton" name="pushButtonAudioFilter">
+                <property name="enabled">
                  <bool>true</bool>
                 </property>
-                <property name="sizePolicy" >
-                 <sizepolicy vsizetype="Fixed" hsizetype="Minimum" >
+                <property name="sizePolicy">
+                 <sizepolicy hsizetype="Minimum" vsizetype="Fixed">
                   <horstretch>0</horstretch>
                   <verstretch>0</verstretch>
                  </sizepolicy>
                 </property>
-                <property name="text" >
+                <property name="text">
                  <string>Filters</string>
                 </property>
                </widget>
               </item>
               <item>
-               <layout class="QHBoxLayout" >
-                <property name="spacing" >
+               <layout class="QHBoxLayout">
+                <property name="spacing">
                  <number>6</number>
                 </property>
-                <property name="margin" >
+                <property name="margin">
                  <number>0</number>
                 </property>
                 <item>
-                 <widget class="QCheckBox" name="checkBox_TimeShift" >
-                  <property name="text" >
+                 <widget class="QCheckBox" name="checkBox_TimeShift">
+                  <property name="text">
                    <string>&amp;Shift:</string>
                   </property>
                  </widget>
                 </item>
                 <item>
-                 <widget class="QSpinBox" name="spinBox_TimeValue" >
-                  <property name="sizePolicy" >
-                   <sizepolicy vsizetype="Fixed" hsizetype="Minimum" >
+                 <widget class="QSpinBox" name="spinBox_TimeValue">
+                  <property name="sizePolicy">
+                   <sizepolicy hsizetype="Minimum" vsizetype="Fixed">
                     <horstretch>0</horstretch>
                     <verstretch>0</verstretch>
                    </sizepolicy>
                   </property>
-                  <property name="minimum" >
+                  <property name="minimum">
                    <number>-99999</number>
                   </property>
-                  <property name="maximum" >
+                  <property name="maximum">
                    <number>99999</number>
                   </property>
                  </widget>
@@ -349,13 +350,13 @@
           </item>
           <item>
            <spacer>
-            <property name="orientation" >
+            <property name="orientation">
              <enum>Qt::Vertical</enum>
             </property>
-            <property name="sizeType" >
+            <property name="sizeType">
              <enum>QSizePolicy::Fixed</enum>
             </property>
-            <property name="sizeHint" stdset="0" >
+            <property name="sizeHint" stdset="0">
              <size>
               <width>1</width>
               <height>14</height>
@@ -364,30 +365,30 @@
            </spacer>
           </item>
           <item>
-           <widget class="QLabel" name="label_4" >
-            <property name="sizePolicy" >
-             <sizepolicy vsizetype="Preferred" hsizetype="Preferred" >
+           <widget class="QLabel" name="label_4">
+            <property name="sizePolicy">
+             <sizepolicy hsizetype="Preferred" vsizetype="Preferred">
               <horstretch>0</horstretch>
               <verstretch>0</verstretch>
              </sizepolicy>
             </property>
-            <property name="text" >
-             <string>&lt;b>Format&lt;/b></string>
+            <property name="text">
+             <string>&lt;b&gt;Format&lt;/b&gt;</string>
             </property>
-            <property name="textFormat" >
+            <property name="textFormat">
              <enum>Qt::AutoText</enum>
             </property>
            </widget>
           </item>
           <item>
            <spacer>
-            <property name="orientation" >
+            <property name="orientation">
              <enum>Qt::Vertical</enum>
             </property>
-            <property name="sizeType" >
+            <property name="sizeType">
              <enum>QSizePolicy::Fixed</enum>
             </property>
-            <property name="sizeHint" stdset="0" >
+            <property name="sizeHint" stdset="0">
              <size>
               <width>20</width>
               <height>5</height>
@@ -397,13 +398,13 @@
           </item>
           <item>
            <spacer>
-            <property name="orientation" >
+            <property name="orientation">
              <enum>Qt::Vertical</enum>
             </property>
-            <property name="sizeType" >
+            <property name="sizeType">
              <enum>QSizePolicy::Expanding</enum>
             </property>
-            <property name="sizeHint" stdset="0" >
+            <property name="sizeHint" stdset="0">
              <size>
               <width>20</width>
               <height>10</height>
@@ -414,22 +415,22 @@
          </layout>
         </item>
         <item>
-         <layout class="QHBoxLayout" >
-          <property name="spacing" >
+         <layout class="QHBoxLayout">
+          <property name="spacing">
            <number>0</number>
           </property>
-          <property name="margin" >
+          <property name="margin">
            <number>0</number>
           </property>
           <item>
            <spacer>
-            <property name="orientation" >
+            <property name="orientation">
              <enum>Qt::Horizontal</enum>
             </property>
-            <property name="sizeType" >
+            <property name="sizeType">
              <enum>QSizePolicy::Fixed</enum>
             </property>
-            <property name="sizeHint" stdset="0" >
+            <property name="sizeHint" stdset="0">
              <size>
               <width>12</width>
               <height>1</height>
@@ -438,9 +439,9 @@
            </spacer>
           </item>
           <item>
-           <widget class="QComboBox" name="comboBoxFormat" >
-            <property name="sizePolicy" >
-             <sizepolicy vsizetype="Fixed" hsizetype="Minimum" >
+           <widget class="QComboBox" name="comboBoxFormat">
+            <property name="sizePolicy">
+             <sizepolicy hsizetype="Minimum" vsizetype="Fixed">
               <horstretch>0</horstretch>
               <verstretch>0</verstretch>
              </sizepolicy>
@@ -450,17 +451,17 @@
          </layout>
         </item>
         <item>
-         <widget class="QPushButton" name="pushButtonFormatConfigure" >
-          <property name="enabled" >
+         <widget class="QPushButton" name="pushButtonFormatConfigure">
+          <property name="enabled">
            <bool>true</bool>
           </property>
-          <property name="sizePolicy" >
-           <sizepolicy vsizetype="Fixed" hsizetype="Minimum" >
+          <property name="sizePolicy">
+           <sizepolicy hsizetype="Minimum" vsizetype="Fixed">
             <horstretch>0</horstretch>
             <verstretch>0</verstretch>
            </sizepolicy>
           </property>
-          <property name="text" >
+          <property name="text">
            <string>Configure</string>
           </property>
          </widget>
@@ -468,50 +469,50 @@
        </layout>
       </item>
       <item>
-       <layout class="QHBoxLayout" >
-        <property name="spacing" >
+       <layout class="QHBoxLayout">
+        <property name="spacing">
          <number>6</number>
         </property>
-        <property name="margin" >
+        <property name="margin">
          <number>0</number>
         </property>
         <item>
-         <widget class="QFrame" name="frame_video" >
-          <property name="sizePolicy" >
-           <sizepolicy vsizetype="Expanding" hsizetype="Expanding" >
+         <widget class="QFrame" name="frame_video">
+          <property name="sizePolicy">
+           <sizepolicy hsizetype="Expanding" vsizetype="Expanding">
             <horstretch>0</horstretch>
             <verstretch>0</verstretch>
            </sizepolicy>
           </property>
-          <property name="minimumSize" >
+          <property name="minimumSize">
            <size>
             <width>100</width>
             <height>100</height>
            </size>
           </property>
-          <property name="autoFillBackground" >
+          <property name="autoFillBackground">
            <bool>false</bool>
           </property>
-          <property name="frameShape" >
+          <property name="frameShape">
            <enum>QFrame::NoFrame</enum>
           </property>
-          <property name="frameShadow" >
+          <property name="frameShadow">
            <enum>QFrame::Raised</enum>
           </property>
-          <property name="lineWidth" >
+          <property name="lineWidth">
            <number>0</number>
           </property>
          </widget>
         </item>
         <item>
          <spacer>
-          <property name="orientation" >
+          <property name="orientation">
            <enum>Qt::Horizontal</enum>
           </property>
-          <property name="sizeType" >
+          <property name="sizeType">
            <enum>QSizePolicy::Expanding</enum>
           </property>
-          <property name="sizeHint" stdset="0" >
+          <property name="sizeHint" stdset="0">
            <size>
             <width>0</width>
             <height>0</height>
@@ -524,30 +525,30 @@
      </layout>
     </item>
     <item>
-     <layout class="QHBoxLayout" >
-      <property name="spacing" >
+     <layout class="QHBoxLayout">
+      <property name="spacing">
        <number>6</number>
       </property>
-      <property name="margin" >
+      <property name="margin">
        <number>0</number>
       </property>
       <item>
-       <layout class="QVBoxLayout" >
-        <property name="spacing" >
+       <layout class="QVBoxLayout">
+        <property name="spacing">
          <number>6</number>
         </property>
-        <property name="margin" >
+        <property name="margin">
          <number>0</number>
         </property>
         <item>
          <spacer>
-          <property name="orientation" >
+          <property name="orientation">
            <enum>Qt::Vertical</enum>
           </property>
-          <property name="sizeType" >
+          <property name="sizeType">
            <enum>QSizePolicy::Expanding</enum>
           </property>
-          <property name="sizeHint" stdset="0" >
+          <property name="sizeHint" stdset="0">
            <size>
             <width>0</width>
             <height>0</height>
@@ -556,272 +557,272 @@
          </spacer>
         </item>
         <item>
-         <widget class="ADM_QSlider" name="horizontalSlider" >
-          <property name="sizePolicy" >
-           <sizepolicy vsizetype="Fixed" hsizetype="Expanding" >
+         <widget class="ADM_QSlider" name="horizontalSlider">
+          <property name="sizePolicy">
+           <sizepolicy hsizetype="Expanding" vsizetype="Fixed">
             <horstretch>0</horstretch>
             <verstretch>0</verstretch>
            </sizepolicy>
           </property>
-          <property name="orientation" >
+          <property name="orientation">
            <enum>Qt::Horizontal</enum>
           </property>
          </widget>
         </item>
         <item>
-         <layout class="QHBoxLayout" >
-          <property name="spacing" >
+         <layout class="QHBoxLayout">
+          <property name="spacing">
            <number>6</number>
           </property>
-          <property name="margin" >
+          <property name="margin">
            <number>0</number>
           </property>
           <item>
-           <widget class="QToolButton" name="toolButtonPlay" >
-            <property name="text" >
+           <widget class="QToolButton" name="toolButtonPlay">
+            <property name="text">
              <string>...</string>
             </property>
-            <property name="icon" >
-             <iconset resource="avidemux.qrc" >
+            <property name="icon">
+             <iconset resource="avidemux.qrc">
               <normaloff>:/new/prefix1/pics/player_play.png</normaloff>:/new/prefix1/pics/player_play.png</iconset>
             </property>
-            <property name="iconSize" >
+            <property name="iconSize">
              <size>
               <width>24</width>
               <height>24</height>
              </size>
             </property>
-            <property name="autoRaise" >
+            <property name="autoRaise">
              <bool>true</bool>
             </property>
            </widget>
           </item>
           <item>
-           <widget class="QToolButton" name="toolButtonStop" >
-            <property name="text" >
+           <widget class="QToolButton" name="toolButtonStop">
+            <property name="text">
              <string>...</string>
             </property>
-            <property name="icon" >
-             <iconset resource="avidemux.qrc" >
+            <property name="icon">
+             <iconset resource="avidemux.qrc">
               <normaloff>:/new/prefix1/pics/player_stop.png</normaloff>:/new/prefix1/pics/player_stop.png</iconset>
             </property>
-            <property name="iconSize" >
+            <property name="iconSize">
              <size>
               <width>24</width>
               <height>24</height>
              </size>
             </property>
-            <property name="autoRaise" >
+            <property name="autoRaise">
              <bool>true</bool>
             </property>
            </widget>
           </item>
           <item>
-           <widget class="QToolButton" name="toolButtonPreviousFrame" >
-            <property name="text" >
+           <widget class="QToolButton" name="toolButtonPreviousFrame">
+            <property name="text">
              <string>...</string>
             </property>
-            <property name="icon" >
-             <iconset resource="avidemux.qrc" >
+            <property name="icon">
+             <iconset resource="avidemux.qrc">
               <normaloff>:/new/prefix1/pics/back.png</normaloff>:/new/prefix1/pics/back.png</iconset>
             </property>
-            <property name="iconSize" >
+            <property name="iconSize">
              <size>
               <width>24</width>
               <height>24</height>
              </size>
             </property>
-            <property name="autoRaise" >
+            <property name="autoRaise">
              <bool>true</bool>
             </property>
            </widget>
           </item>
           <item>
-           <widget class="QToolButton" name="toolButtonNextFrame" >
-            <property name="text" >
+           <widget class="QToolButton" name="toolButtonNextFrame">
+            <property name="text">
              <string>...</string>
             </property>
-            <property name="icon" >
-             <iconset resource="avidemux.qrc" >
+            <property name="icon">
+             <iconset resource="avidemux.qrc">
               <normaloff>:/new/prefix1/pics/forward.png</normaloff>:/new/prefix1/pics/forward.png</iconset>
             </property>
-            <property name="iconSize" >
+            <property name="iconSize">
              <size>
               <width>24</width>
               <height>24</height>
              </size>
             </property>
-            <property name="autoRaise" >
+            <property name="autoRaise">
              <bool>true</bool>
             </property>
            </widget>
           </item>
           <item>
-           <widget class="QToolButton" name="toolButtonPreviousIntraFrame" >
-            <property name="text" >
+           <widget class="QToolButton" name="toolButtonPreviousIntraFrame">
+            <property name="text">
              <string>...</string>
             </property>
-            <property name="icon" >
-             <iconset resource="avidemux.qrc" >
+            <property name="icon">
+             <iconset resource="avidemux.qrc">
               <normaloff>:/new/prefix1/pics/player_rew.png</normaloff>:/new/prefix1/pics/player_rew.png</iconset>
             </property>
-            <property name="iconSize" >
+            <property name="iconSize">
              <size>
               <width>24</width>
               <height>24</height>
              </size>
             </property>
-            <property name="autoRaise" >
+            <property name="autoRaise">
              <bool>true</bool>
             </property>
            </widget>
           </item>
           <item>
-           <widget class="QToolButton" name="toolButtonNextIntraFrame" >
-            <property name="text" >
+           <widget class="QToolButton" name="toolButtonNextIntraFrame">
+            <property name="text">
              <string>...</string>
             </property>
-            <property name="icon" >
-             <iconset resource="avidemux.qrc" >
+            <property name="icon">
+             <iconset resource="avidemux.qrc">
               <normaloff>:/new/prefix1/pics/player_fwd.png</normaloff>:/new/prefix1/pics/player_fwd.png</iconset>
             </property>
-            <property name="iconSize" >
+            <property name="iconSize">
              <size>
               <width>24</width>
               <height>24</height>
              </size>
             </property>
-            <property name="autoRaise" >
+            <property name="autoRaise">
              <bool>true</bool>
             </property>
            </widget>
           </item>
           <item>
-           <widget class="QToolButton" name="toolButtonSetMarkerA" >
-            <property name="text" >
+           <widget class="QToolButton" name="toolButtonSetMarkerA">
+            <property name="text">
              <string>...</string>
             </property>
-            <property name="icon" >
-             <iconset resource="avidemux.qrc" >
+            <property name="icon">
+             <iconset resource="avidemux.qrc">
               <normaloff>:/new/prefix1/pics/markA.png</normaloff>:/new/prefix1/pics/markA.png</iconset>
             </property>
-            <property name="iconSize" >
+            <property name="iconSize">
              <size>
               <width>24</width>
               <height>24</height>
              </size>
             </property>
-            <property name="autoRaise" >
+            <property name="autoRaise">
              <bool>true</bool>
             </property>
            </widget>
           </item>
           <item>
-           <widget class="QToolButton" name="toolButtonSetMarkerB" >
-            <property name="text" >
+           <widget class="QToolButton" name="toolButtonSetMarkerB">
+            <property name="text">
              <string>...</string>
             </property>
-            <property name="icon" >
-             <iconset resource="avidemux.qrc" >
+            <property name="icon">
+             <iconset resource="avidemux.qrc">
               <normaloff>:/new/prefix1/pics/markB.png</normaloff>:/new/prefix1/pics/markB.png</iconset>
             </property>
-            <property name="iconSize" >
+            <property name="iconSize">
              <size>
               <width>24</width>
               <height>24</height>
              </size>
             </property>
-            <property name="autoRaise" >
+            <property name="autoRaise">
              <bool>true</bool>
             </property>
            </widget>
           </item>
           <item>
-           <widget class="QToolButton" name="toolButtonPreviousBlackFrame" >
-            <property name="text" >
+           <widget class="QToolButton" name="toolButtonPreviousBlackFrame">
+            <property name="text">
              <string>...</string>
             </property>
-            <property name="icon" >
-             <iconset resource="avidemux.qrc" >
+            <property name="icon">
+             <iconset resource="avidemux.qrc">
               <normaloff>:/new/prefix1/pics/prev_black.png</normaloff>:/new/prefix1/pics/prev_black.png</iconset>
             </property>
-            <property name="iconSize" >
+            <property name="iconSize">
              <size>
               <width>24</width>
               <height>24</height>
              </size>
             </property>
-            <property name="autoRaise" >
+            <property name="autoRaise">
              <bool>true</bool>
             </property>
            </widget>
           </item>
           <item>
-           <widget class="QToolButton" name="toolButtonNextBlackFrame" >
-            <property name="text" >
+           <widget class="QToolButton" name="toolButtonNextBlackFrame">
+            <property name="text">
              <string>...</string>
             </property>
-            <property name="icon" >
-             <iconset resource="avidemux.qrc" >
+            <property name="icon">
+             <iconset resource="avidemux.qrc">
               <normaloff>:/new/prefix1/pics/next_black.png</normaloff>:/new/prefix1/pics/next_black.png</iconset>
             </property>
-            <property name="iconSize" >
+            <property name="iconSize">
              <size>
               <width>24</width>
               <height>24</height>
              </size>
             </property>
-            <property name="autoRaise" >
+            <property name="autoRaise">
              <bool>true</bool>
             </property>
            </widget>
           </item>
           <item>
-           <widget class="QToolButton" name="toolButtonFirstFrame" >
-            <property name="text" >
+           <widget class="QToolButton" name="toolButtonFirstFrame">
+            <property name="text">
              <string>...</string>
             </property>
-            <property name="icon" >
-             <iconset resource="avidemux.qrc" >
+            <property name="icon">
+             <iconset resource="avidemux.qrc">
               <normaloff>:/new/prefix1/pics/player_start.png</normaloff>:/new/prefix1/pics/player_start.png</iconset>
             </property>
-            <property name="iconSize" >
+            <property name="iconSize">
              <size>
               <width>24</width>
               <height>24</height>
              </size>
             </property>
-            <property name="autoRaise" >
+            <property name="autoRaise">
              <bool>true</bool>
             </property>
            </widget>
           </item>
           <item>
-           <widget class="QToolButton" name="toolButtonLastFrame" >
-            <property name="text" >
+           <widget class="QToolButton" name="toolButtonLastFrame">
+            <property name="text">
              <string>...</string>
             </property>
-            <property name="icon" >
-             <iconset resource="avidemux.qrc" >
+            <property name="icon">
+             <iconset resource="avidemux.qrc">
               <normaloff>:/new/prefix1/pics/player_end.png</normaloff>:/new/prefix1/pics/player_end.png</iconset>
             </property>
-            <property name="iconSize" >
+            <property name="iconSize">
              <size>
               <width>24</width>
               <height>24</height>
              </size>
             </property>
-            <property name="autoRaise" >
+            <property name="autoRaise">
              <bool>true</bool>
             </property>
            </widget>
           </item>
           <item>
            <spacer>
-            <property name="orientation" >
+            <property name="orientation">
              <enum>Qt::Horizontal</enum>
             </property>
-            <property name="sizeHint" stdset="0" >
+            <property name="sizeHint" stdset="0">
              <size>
               <width>20</width>
               <height>20</height>
@@ -832,22 +833,22 @@
          </layout>
         </item>
         <item>
-         <layout class="QHBoxLayout" >
-          <property name="spacing" >
+         <layout class="QHBoxLayout">
+          <property name="spacing">
            <number>6</number>
           </property>
-          <property name="margin" >
+          <property name="margin">
            <number>0</number>
           </property>
           <item>
-           <widget class="QLabel" name="label" >
-            <property name="sizePolicy" >
-             <sizepolicy vsizetype="Preferred" hsizetype="Minimum" >
+           <widget class="QLabel" name="label_6">
+            <property name="sizePolicy">
+             <sizepolicy hsizetype="Minimum" vsizetype="Preferred">
               <horstretch>0</horstretch>
               <verstretch>0</verstretch>
              </sizepolicy>
             </property>
-            <property name="font" >
+            <property name="font">
              <font>
               <family>MS Shell Dlg 2</family>
               <pointsize>8</pointsize>
@@ -858,142 +859,55 @@
               <strikeout>false</strikeout>
              </font>
             </property>
-            <property name="text" >
-             <string>Frame:</string>
-            </property>
-           </widget>
-          </item>
-          <item>
-           <widget class="QLineEdit" name="lineEdit" >
-            <property name="sizePolicy" >
-             <sizepolicy vsizetype="Fixed" hsizetype="Fixed" >
-              <horstretch>0</horstretch>
-              <verstretch>0</verstretch>
-             </sizepolicy>
-            </property>
-            <property name="maximumSize" >
-             <size>
-              <width>54</width>
-              <height>16777215</height>
-             </size>
-            </property>
-            <property name="baseSize" >
-             <size>
-              <width>0</width>
-              <height>0</height>
-             </size>
-            </property>
-            <property name="text" >
-             <string>0</string>
-            </property>
-            <property name="maxLength" >
-             <number>8</number>
-            </property>
-            <property name="echoMode" >
-             <enum>QLineEdit::Normal</enum>
-            </property>
-            <property name="cursorPosition" >
-             <number>1</number>
-            </property>
-           </widget>
-          </item>
-          <item>
-           <widget class="QLabel" name="label_2" >
-            <property name="sizePolicy" >
-             <sizepolicy vsizetype="Preferred" hsizetype="Minimum" >
-              <horstretch>0</horstretch>
-              <verstretch>0</verstretch>
-             </sizepolicy>
-            </property>
-            <property name="text" >
-             <string>/ 0</string>
-            </property>
-           </widget>
-          </item>
-          <item>
-           <spacer>
-            <property name="orientation" >
-             <enum>Qt::Horizontal</enum>
-            </property>
-            <property name="sizeType" >
-             <enum>QSizePolicy::Fixed</enum>
-            </property>
-            <property name="sizeHint" stdset="0" >
-             <size>
-              <width>20</width>
-              <height>20</height>
-             </size>
-            </property>
-           </spacer>
-          </item>
-          <item>
-           <widget class="QLabel" name="label_6" >
-            <property name="sizePolicy" >
-             <sizepolicy vsizetype="Preferred" hsizetype="Minimum" >
-              <horstretch>0</horstretch>
-              <verstretch>0</verstretch>
-             </sizepolicy>
-            </property>
-            <property name="font" >
-             <font>
-              <family>MS Shell Dlg 2</family>
-              <pointsize>8</pointsize>
-              <weight>75</weight>
-              <italic>false</italic>
-              <bold>true</bold>
-              <underline>false</underline>
-              <strikeout>false</strikeout>
-             </font>
-            </property>
-            <property name="text" >
+            <property name="text">
              <string>Time:</string>
             </property>
            </widget>
           </item>
           <item>
-           <widget class="QLineEdit" name="lineEdit_2" >
-            <property name="sizePolicy" >
-             <sizepolicy vsizetype="Fixed" hsizetype="Fixed" >
+           <widget class="QLineEdit" name="currentTime">
+            <property name="sizePolicy">
+             <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
               <horstretch>0</horstretch>
               <verstretch>0</verstretch>
              </sizepolicy>
             </property>
-            <property name="maximumSize" >
+            <property name="maximumSize">
              <size>
               <width>84</width>
               <height>16777215</height>
              </size>
             </property>
-            <property name="text" >
+            <property name="text">
              <string>00:00:00.000</string>
             </property>
-            <property name="maxLength" >
+            <property name="maxLength">
              <number>12</number>
             </property>
            </widget>
           </item>
           <item>
-           <widget class="QLabel" name="label_7" >
-            <property name="sizePolicy" >
-             <sizepolicy vsizetype="Preferred" hsizetype="Minimum" >
+           <widget class="QLabel" name="totalTime">
+            <property name="sizePolicy">
+             <sizepolicy hsizetype="Minimum" vsizetype="Preferred">
               <horstretch>0</horstretch>
               <verstretch>0</verstretch>
              </sizepolicy>
             </property>
-            <property name="text" >
+            <property name="text">
              <string>/ 00:00:00.000</string>
             </property>
            </widget>
           </item>
           <item>
            <spacer>
-            <property name="orientation" >
+            <property name="orientation">
              <enum>Qt::Horizontal</enum>
             </property>
-            <property name="sizeType" >
+            <property name="sizeType">
              <enum>QSizePolicy::Fixed</enum>
             </property>
-            <property name="sizeHint" stdset="0" >
+            <property name="sizeHint" stdset="0">
              <size>
               <width>20</width>
               <height>20</height>
@@ -1002,8 +916,8 @@
            </spacer>
           </item>
           <item>
-           <widget class="QLabel" name="label_14" >
-            <property name="font" >
+           <widget class="QLabel" name="label_14">
+            <property name="font">
              <font>
               <family>MS Shell Dlg 2</family>
               <pointsize>8</pointsize>
@@ -1014,30 +928,30 @@
               <strikeout>false</strikeout>
              </font>
             </property>
-            <property name="text" >
+            <property name="text">
              <string>Frame Type:</string>
             </property>
            </widget>
           </item>
           <item>
-           <widget class="QLabel" name="label_8" >
-            <property name="sizePolicy" >
-             <sizepolicy vsizetype="Preferred" hsizetype="Minimum" >
+           <widget class="QLabel" name="label_8">
+            <property name="sizePolicy">
+             <sizepolicy hsizetype="Minimum" vsizetype="Preferred">
               <horstretch>0</horstretch>
               <verstretch>0</verstretch>
              </sizepolicy>
             </property>
-            <property name="text" >
+            <property name="text">
              <string>?</string>
             </property>
            </widget>
           </item>
           <item>
            <spacer>
-            <property name="orientation" >
+            <property name="orientation">
              <enum>Qt::Horizontal</enum>
             </property>
-            <property name="sizeHint" stdset="0" >
+            <property name="sizeHint" stdset="0">
              <size>
               <width>60</width>
               <height>20</height>
@@ -1051,13 +965,13 @@
       </item>
       <item>
        <spacer>
-        <property name="orientation" >
+        <property name="orientation">
          <enum>Qt::Horizontal</enum>
         </property>
-        <property name="sizeType" >
+        <property name="sizeType">
          <enum>QSizePolicy::Fixed</enum>
         </property>
-        <property name="sizeHint" stdset="0" >
+        <property name="sizeHint" stdset="0">
          <size>
           <width>14</width>
           <height>95</height>
@@ -1066,22 +980,22 @@
        </spacer>
       </item>
       <item>
-       <layout class="QVBoxLayout" >
-        <property name="spacing" >
+       <layout class="QVBoxLayout">
+        <property name="spacing">
          <number>6</number>
         </property>
-        <property name="margin" >
+        <property name="margin">
          <number>0</number>
         </property>
         <item>
          <spacer>
-          <property name="orientation" >
+          <property name="orientation">
            <enum>Qt::Vertical</enum>
           </property>
-          <property name="sizeType" >
+          <property name="sizeType">
            <enum>QSizePolicy::Expanding</enum>
           </property>
-          <property name="sizeHint" stdset="0" >
+          <property name="sizeHint" stdset="0">
            <size>
             <width>0</width>
             <height>0</height>
@@ -1090,20 +1004,20 @@
          </spacer>
         </item>
         <item>
-         <widget class="QGroupBox" name="groupBox" >
-          <property name="sizePolicy" >
-           <sizepolicy vsizetype="Minimum" hsizetype="Minimum" >
+         <widget class="QGroupBox" name="groupBox">
+          <property name="sizePolicy">
+           <sizepolicy hsizetype="Minimum" vsizetype="Minimum">
             <horstretch>0</horstretch>
             <verstretch>0</verstretch>
            </sizepolicy>
           </property>
-          <property name="minimumSize" >
+          <property name="minimumSize">
            <size>
             <width>116</width>
             <height>80</height>
            </size>
           </property>
-          <property name="font" >
+          <property name="font">
            <font>
             <family>MS Shell Dlg 2</family>
             <pointsize>8</pointsize>
@@ -1114,14 +1028,14 @@
             <strikeout>false</strikeout>
            </font>
           </property>
-          <property name="title" >
+          <property name="title">
            <string>Selection</string>
           </property>
-          <property name="alignment" >
+          <property name="alignment">
            <set>Qt::AlignLeading|Qt::AlignLeft|Qt::AlignVCenter</set>
           </property>
-          <widget class="QLabel" name="label_11" >
-           <property name="geometry" >
+          <widget class="QLabel" name="label_11">
+           <property name="geometry">
             <rect>
              <x>10</x>
              <y>50</y>
@@ -1129,7 +1043,7 @@
              <height>23</height>
             </rect>
            </property>
-           <property name="font" >
+           <property name="font">
             <font>
              <family>MS Shell Dlg 2</family>
              <pointsize>8</pointsize>
@@ -1140,12 +1054,12 @@
              <strikeout>false</strikeout>
             </font>
            </property>
-           <property name="text" >
+           <property name="text">
             <string> B:</string>
            </property>
           </widget>
-          <widget class="QLabel" name="label_12" >
-           <property name="geometry" >
+          <widget class="QLabel" name="label_12">
+           <property name="geometry">
             <rect>
              <x>10</x>
              <y>20</y>
@@ -1153,7 +1067,7 @@
              <height>23</height>
             </rect>
            </property>
-           <property name="font" >
+           <property name="font">
             <font>
              <family>MS Shell Dlg 2</family>
              <pointsize>8</pointsize>
@@ -1164,12 +1078,12 @@
              <strikeout>false</strikeout>
             </font>
            </property>
-           <property name="text" >
+           <property name="text">
             <string> A:</string>
            </property>
           </widget>
-          <widget class="QPushButton" name="pushButtonJumpToMarkerA" >
-           <property name="geometry" >
+          <widget class="QPushButton" name="pushButtonJumpToMarkerA">
+           <property name="geometry">
             <rect>
              <x>30</x>
              <y>20</y>
@@ -1177,13 +1091,13 @@
              <height>23</height>
             </rect>
            </property>
-           <property name="sizePolicy" >
-            <sizepolicy vsizetype="Fixed" hsizetype="Minimum" >
+           <property name="sizePolicy">
+            <sizepolicy hsizetype="Minimum" vsizetype="Fixed">
              <horstretch>0</horstretch>
              <verstretch>0</verstretch>
             </sizepolicy>
            </property>
-           <property name="font" >
+           <property name="font">
             <font>
              <family>MS Shell Dlg 2</family>
              <pointsize>8</pointsize>
@@ -1194,12 +1108,12 @@
              <strikeout>false</strikeout>
             </font>
            </property>
-           <property name="text" >
+           <property name="text">
             <string>000000</string>
            </property>
           </widget>
-          <widget class="QPushButton" name="pushButtonJumpToMarkerB" >
-           <property name="geometry" >
+          <widget class="QPushButton" name="pushButtonJumpToMarkerB">
+           <property name="geometry">
             <rect>
              <x>30</x>
              <y>50</y>
@@ -1207,13 +1121,13 @@
              <height>23</height>
             </rect>
            </property>
-           <property name="sizePolicy" >
-            <sizepolicy vsizetype="Fixed" hsizetype="Minimum" >
+           <property name="sizePolicy">
+            <sizepolicy hsizetype="Minimum" vsizetype="Fixed">
              <horstretch>0</horstretch>
              <verstretch>0</verstretch>
             </sizepolicy>
            </property>
-           <property name="font" >
+           <property name="font">
             <font>
              <family>MS Shell Dlg 2</family>
              <pointsize>8</pointsize>
@@ -1224,10 +1138,10 @@
              <strikeout>false</strikeout>
             </font>
            </property>
-           <property name="layoutDirection" >
+           <property name="layoutDirection">
             <enum>Qt::LeftToRight</enum>
            </property>
-           <property name="text" >
+           <property name="text">
             <string>000000</string>
            </property>
           </widget>
@@ -1237,13 +1151,13 @@
       </item>
       <item>
        <spacer>
-        <property name="orientation" >
+        <property name="orientation">
          <enum>Qt::Horizontal</enum>
         </property>
-        <property name="sizeType" >
+        <property name="sizeType">
          <enum>QSizePolicy::Fixed</enum>
         </property>
-        <property name="sizeHint" stdset="0" >
+        <property name="sizeHint" stdset="0">
          <size>
           <width>14</width>
           <height>95</height>
@@ -1252,22 +1166,22 @@
        </spacer>
       </item>
       <item>
-       <layout class="QVBoxLayout" >
-        <property name="spacing" >
+       <layout class="QVBoxLayout">
+        <property name="spacing">
          <number>4</number>
         </property>
-        <property name="margin" >
+        <property name="margin">
          <number>0</number>
         </property>
         <item>
          <spacer>
-          <property name="orientation" >
+          <property name="orientation">
            <enum>Qt::Vertical</enum>
           </property>
-          <property name="sizeType" >
+          <property name="sizeType">
            <enum>QSizePolicy::Expanding</enum>
           </property>
-          <property name="sizeHint" stdset="0" >
+          <property name="sizeHint" stdset="0">
            <size>
             <width>0</width>
             <height>0</height>
@@ -1276,46 +1190,46 @@
          </spacer>
         </item>
         <item>
-         <widget class="QToolButton" name="toolButtonAudioToggle" >
-          <property name="enabled" >
+         <widget class="QToolButton" name="toolButtonAudioToggle">
+          <property name="enabled">
            <bool>true</bool>
           </property>
-          <property name="text" >
+          <property name="text">
            <string>...</string>
           </property>
-          <property name="icon" >
-           <iconset resource="avidemux.qrc" >
+          <property name="icon">
+           <iconset resource="avidemux.qrc">
             <normaloff>:/new/prefix1/pics/arts.png</normaloff>:/new/prefix1/pics/arts.png</iconset>
           </property>
-          <property name="checkable" >
+          <property name="checkable">
            <bool>true</bool>
           </property>
-          <property name="checked" >
+          <property name="checked">
            <bool>true</bool>
           </property>
          </widget>
         </item>
         <item>
-         <widget class="QSlider" name="horizontalSlider_2" >
-          <property name="sizePolicy" >
-           <sizepolicy vsizetype="Minimum" hsizetype="Preferred" >
+         <widget class="QSlider" name="horizontalSlider_2">
+          <property name="sizePolicy">
+           <sizepolicy hsizetype="Preferred" vsizetype="Minimum">
             <horstretch>0</horstretch>
             <verstretch>0</verstretch>
            </sizepolicy>
           </property>
-          <property name="maximumSize" >
+          <property name="maximumSize">
            <size>
             <width>16777215</width>
             <height>64</height>
            </size>
           </property>
-          <property name="maximum" >
+          <property name="maximum">
            <number>100</number>
           </property>
-          <property name="value" >
+          <property name="value">
            <number>100</number>
           </property>
-          <property name="orientation" >
+          <property name="orientation">
            <enum>Qt::Vertical</enum>
           </property>
          </widget>
@@ -1326,1091 +1240,1091 @@
     </item>
    </layout>
   </widget>
-  <widget class="QMenuBar" name="menubar" >
-   <property name="geometry" >
+  <widget class="QMenuBar" name="menubar">
+   <property name="geometry">
     <rect>
      <x>0</x>
      <y>0</y>
      <width>838</width>
-     <height>25</height>
+     <height>21</height>
     </rect>
    </property>
-   <widget class="QMenu" name="menuHelp" >
-    <property name="title" >
+   <widget class="QMenu" name="menuHelp">
+    <property name="title">
      <string>&amp;Help</string>
     </property>
-    <addaction name="actionShow_built_in_support" />
-    <addaction name="actionPlugins" />
-    <addaction name="actionAbout_avidemux" />
+    <addaction name="actionShow_built_in_support"/>
+    <addaction name="actionPlugins"/>
+    <addaction name="actionAbout_avidemux"/>
    </widget>
-   <widget class="QMenu" name="menuVideo" >
-    <property name="title" >
+   <widget class="QMenu" name="menuVideo">
+    <property name="title">
      <string>Vi&amp;deo</string>
     </property>
-    <addaction name="actionDecoder_options" />
-    <addaction name="actionPostprocessing" />
-    <addaction name="separator" />
-    <addaction name="actionFilters" />
-    <addaction name="actionFrame_rate" />
+    <addaction name="actionDecoder_options"/>
+    <addaction name="actionPostprocessing"/>
+    <addaction name="separator"/>
+    <addaction name="actionFilters"/>
+    <addaction name="actionFrame_rate"/>
    </widget>
-   <widget class="QMenu" name="menuAudio" >
-    <property name="title" >
+   <widget class="QMenu" name="menuAudio">
+    <property name="title">
      <string>&amp;Audio</string>
     </property>
-    <addaction name="actionMain_Track" />
-    <addaction name="actionSecondary_Track" />
-    <addaction name="actionBuild_VBR_time_map" />
-    <addaction name="separator" />
-    <addaction name="actionSave_2" />
-    <addaction name="actionFilters_2" />
+    <addaction name="actionMain_Track"/>
+    <addaction name="actionSecondary_Track"/>
+    <addaction name="actionBuild_VBR_time_map"/>
+    <addaction name="separator"/>
+    <addaction name="actionSave_2"/>
+    <addaction name="actionFilters_2"/>
    </widget>
-   <widget class="QMenu" name="menuFile" >
-    <property name="title" >
+   <widget class="QMenu" name="menuFile">
+    <property name="title">
      <string>&amp;File</string>
     </property>
-    <widget class="QMenu" name="menuRecent_Files" >
-     <property name="title" >
+    <widget class="QMenu" name="menuRecent_Files">
+     <property name="title">
       <string>&amp;Recent Files</string>
      </property>
-     <addaction name="actionRecent0" />
-     <addaction name="actionRecent1" />
-     <addaction name="actionRecent2" />
-     <addaction name="actionRecent3" />
+     <addaction name="actionRecent0"/>
+     <addaction name="actionRecent1"/>
+     <addaction name="actionRecent2"/>
+     <addaction name="actionRecent3"/>
     </widget>
-    <widget class="QMenu" name="menuSave" >
-     <property name="title" >
+    <widget class="QMenu" name="menuSave">
+     <property name="title">
       <string>&amp;Save</string>
      </property>
-     <addaction name="actionSave_video" />
-     <addaction name="separator" />
-     <addaction name="actionSave_BMP" />
-     <addaction name="actionSave_jpeg" />
+     <addaction name="actionSave_video"/>
+     <addaction name="separator"/>
+     <addaction name="actionSave_BMP"/>
+     <addaction name="actionSave_jpeg"/>
     </widget>
-    <addaction name="actionOpen" />
-    <addaction name="menuRecent_Files" />
-    <addaction name="actionAppend" />
-    <addaction name="menuSave" />
-    <addaction name="actionClose" />
-    <addaction name="separator" />
-    <addaction name="actionProperties" />
-    <addaction name="separator" />
-    <addaction name="actionLoad_run_project" />
-    <addaction name="actionSave_project" />
-    <addaction name="actionSave_project_as" />
-    <addaction name="separator" />
-    <addaction name="actionAdd_to_joblist" />
-    <addaction name="actionShow_Joblist" />
-    <addaction name="separator" />
-    <addaction name="actionConnect_to_AvsProxy" />
-    <addaction name="separator" />
-    <addaction name="actionQuit" />
+    <addaction name="actionOpen"/>
+    <addaction name="menuRecent_Files"/>
+    <addaction name="actionAppend"/>
+    <addaction name="menuSave"/>
+    <addaction name="actionClose"/>
+    <addaction name="separator"/>
+    <addaction name="actionProperties"/>
+    <addaction name="separator"/>
+    <addaction name="actionLoad_run_project"/>
+    <addaction name="actionSave_project"/>
+    <addaction name="actionSave_project_as"/>
+    <addaction name="separator"/>
+    <addaction name="actionAdd_to_joblist"/>
+    <addaction name="actionShow_Joblist"/>
+    <addaction name="separator"/>
+    <addaction name="actionConnect_to_AvsProxy"/>
+    <addaction name="separator"/>
+    <addaction name="actionQuit"/>
    </widget>
-   <widget class="QMenu" name="menuTools" >
-    <property name="title" >
+   <widget class="QMenu" name="menuTools">
+    <property name="title">
      <string>&amp;Tools</string>
     </property>
-    <addaction name="actionCalculator" />
-    <addaction name="separator" />
-    <addaction name="actionRebuild_I_B_Frames" />
-    <addaction name="actionBitrate_histogram" />
-    <addaction name="actionScan_for_black_frames" />
-    <addaction name="separator" />
-    <addaction name="actionVob_to_vobsub" />
-    <addaction name="actionOCR" />
-    <addaction name="actionOCR_DVB_T_TS_files" />
-    <addaction name="actionGlyphs_Edit" />
+    <addaction name="actionCalculator"/>
+    <addaction name="separator"/>
+    <addaction name="actionRebuild_I_B_Frames"/>
+    <addaction name="actionBitrate_histogram"/>
+    <addaction name="actionScan_for_black_frames"/>
+    <addaction name="separator"/>
+    <addaction name="actionVob_to_vobsub"/>
+    <addaction name="actionOCR"/>
+    <addaction name="actionOCR_DVB_T_TS_files"/>
+    <addaction name="actionGlyphs_Edit"/>
    </widget>
-   <widget class="QMenu" name="menuEdit" >
-    <property name="title" >
+   <widget class="QMenu" name="menuEdit">
+    <property name="title">
      <string>&amp;Edit</string>
     </property>
-    <addaction name="actionReset_Edits" />
-    <addaction name="separator" />
-    <addaction name="actionCut" />
-    <addaction name="actionCopy" />
-    <addaction name="actionPaste" />
-    <addaction name="actionDelete" />
-    <addaction name="separator" />
-    <addaction name="actionSet_marker_A" />
-    <addaction name="actionSet_marker_B" />
-    <addaction name="separator" />
-    <addaction name="actionPreferences" />
+    <addaction name="actionReset_Edits"/>
+    <addaction name="separator"/>
+    <addaction name="actionCut"/>
+    <addaction name="actionCopy"/>
+    <addaction name="actionPaste"/>
+    <addaction name="actionDelete"/>
+    <addaction name="separator"/>
+    <addaction name="actionSet_marker_A"/>
+    <addaction name="actionSet_marker_B"/>
+    <addaction name="separator"/>
+    <addaction name="actionPreferences"/>
    </widget>
-   <widget class="QMenu" name="menuView" >
-    <property name="title" >
+   <widget class="QMenu" name="menuView">
+    <property name="title">
      <string>&amp;View</string>
     </property>
-    <widget class="QMenu" name="menu_Preview" >
-     <property name="title" >
+    <widget class="QMenu" name="menu_Preview">
+     <property name="title">
       <string>&amp;Preview Mode</string>
      </property>
-     <addaction name="actionPreviewInput" />
-     <addaction name="actionPreviewOutput" />
-     <addaction name="actionPreviewSide" />
-     <addaction name="actionPreviewTop" />
-     <addaction name="actionPreviewSeparate" />
+     <addaction name="actionPreviewInput"/>
+     <addaction name="actionPreviewOutput"/>
+     <addaction name="actionPreviewSide"/>
+     <addaction name="actionPreviewTop"/>
+     <addaction name="actionPreviewSeparate"/>
     </widget>
-    <addaction name="actionZoom_1_4" />
-    <addaction name="actionZoom_1_2" />
-    <addaction name="actionZoom_1_1" />
-    <addaction name="actionZoom_2_1" />
-    <addaction name="separator" />
-    <addaction name="menu_Preview" />
+    <addaction name="actionZoom_1_4"/>
+    <addaction name="actionZoom_1_2"/>
+    <addaction name="actionZoom_1_1"/>
+    <addaction name="actionZoom_2_1"/>
+    <addaction name="separator"/>
+    <addaction name="menu_Preview"/>
    </widget>
-   <widget class="QMenu" name="menuCustom" >
-    <property name="title" >
+   <widget class="QMenu" name="menuCustom">
+    <property name="title">
      <string>&amp;Custom</string>
     </property>
    </widget>
-   <widget class="QMenu" name="menuGo" >
-    <property name="title" >
+   <widget class="QMenu" name="menuGo">
+    <property name="title">
      <string>&amp;Go</string>
     </property>
-    <addaction name="actionPlay" />
-    <addaction name="actionPrevious_Frame" />
-    <addaction name="actionNext_Frame" />
-    <addaction name="actionPrevious_intra_frame" />
-    <addaction name="actionNext_intra_frame" />
-    <addaction name="actionPrevious_black_frame" />
-    <addaction name="actionNext_blak_frame" />
-    <addaction name="actionFirst_Frame" />
-    <addaction name="actionLast_Frame" />
-    <addaction name="separator" />
-    <addaction name="actionGo_to_Marker_A" />
-    <addaction name="actionGo_to_Marker_B" />
-    <addaction name="separator" />
-    <addaction name="actionJump_to_Frame" />
-    <addaction name="actionJump_to_Time" />
+    <addaction name="actionPlay"/>
+    <addaction name="actionPrevious_Frame"/>
+    <addaction name="actionNext_Frame"/>
+    <addaction name="actionPrevious_intra_frame"/>
+    <addaction name="actionNext_intra_frame"/>
+    <addaction name="actionPrevious_black_frame"/>
+    <addaction name="actionNext_blak_frame"/>
+    <addaction name="actionFirst_Frame"/>
+    <addaction name="actionLast_Frame"/>
+    <addaction name="separator"/>
+    <addaction name="actionGo_to_Marker_A"/>
+    <addaction name="actionGo_to_Marker_B"/>
+    <addaction name="separator"/>
+    <addaction name="actionJump_to_Frame"/>
+    <addaction name="actionJump_to_Time"/>
    </widget>
-   <widget class="QMenu" name="menuAuto" >
-    <property name="title" >
+   <widget class="QMenu" name="menuAuto">
+    <property name="title">
      <string>A&amp;uto</string>
     </property>
-    <addaction name="actionVCD" />
-    <addaction name="actionSVCD" />
-    <addaction name="actionDVD" />
-    <addaction name="actionPSP" />
-    <addaction name="actionPSP_H264" />
-    <addaction name="actionFLV" />
-    <addaction name="actionIPOD" />
+    <addaction name="actionVCD"/>
+    <addaction name="actionSVCD"/>
+    <addaction name="actionDVD"/>
+    <addaction name="actionPSP"/>
+    <addaction name="actionPSP_H264"/>
+    <addaction name="actionFLV"/>
+    <addaction name="actionIPOD"/>
    </widget>
-   <addaction name="menuFile" />
-   <addaction name="menuEdit" />
-   <addaction name="menuView" />
-   <addaction name="menuVideo" />
-   <addaction name="menuAudio" />
-   <addaction name="menuTools" />
-   <addaction name="menuAuto" />
-   <addaction name="menuGo" />
-   <addaction name="menuCustom" />
-   <addaction name="menuHelp" />
+   <addaction name="menuFile"/>
+   <addaction name="menuEdit"/>
+   <addaction name="menuView"/>
+   <addaction name="menuVideo"/>
+   <addaction name="menuAudio"/>
+   <addaction name="menuTools"/>
+   <addaction name="menuAuto"/>
+   <addaction name="menuGo"/>
+   <addaction name="menuCustom"/>
+   <addaction name="menuHelp"/>
   </widget>
-  <widget class="QStatusBar" name="statusbar" />
-  <widget class="QToolBar" name="toolBar" >
-   <property name="orientation" >
+  <widget class="QStatusBar" name="statusbar"/>
+  <widget class="QToolBar" name="toolBar">
+   <property name="orientation">
     <enum>Qt::Horizontal</enum>
    </property>
-   <attribute name="toolBarArea" >
+   <attribute name="toolBarArea">
     <enum>TopToolBarArea</enum>
    </attribute>
-   <attribute name="toolBarBreak" >
+   <attribute name="toolBarBreak">
     <bool>false</bool>
    </attribute>
-   <addaction name="separator" />
-   <addaction name="actionOpen" />
-   <addaction name="actionSave_video" />
-   <addaction name="actionProperties" />
-   <addaction name="separator" />
-   <addaction name="actionLoad_run_project" />
-   <addaction name="actionSave_project" />
-   <addaction name="separator" />
-   <addaction name="actionCalculator" />
+   <addaction name="separator"/>
+   <addaction name="actionOpen"/>
+   <addaction name="actionSave_video"/>
+   <addaction name="actionProperties"/>
+   <addaction name="separator"/>
+   <addaction name="actionLoad_run_project"/>
+   <addaction name="actionSave_project"/>
+   <addaction name="separator"/>
+   <addaction name="actionCalculator"/>
   </widget>
-  <widget class="QToolBar" name="toolBar_2" >
-   <property name="orientation" >
+  <widget class="QToolBar" name="toolBar_2">
+   <property name="orientation">
     <enum>Qt::Horizontal</enum>
    </property>
-   <attribute name="toolBarArea" >
+   <attribute name="toolBarArea">
     <enum>TopToolBarArea</enum>
    </attribute>
-   <attribute name="toolBarBreak" >
+   <attribute name="toolBarBreak">
     <bool>false</bool>
    </attribute>
-   <addaction name="actionPreviewInput" />
-   <addaction name="actionPreviewOutput" />
-   <addaction name="actionPreviewSide" />
-   <addaction name="actionPreviewTop" />
-   <addaction name="actionPreviewSeparate" />
+   <addaction name="actionPreviewInput"/>
+   <addaction name="actionPreviewOutput"/>
+   <addaction name="actionPreviewSide"/>
+   <addaction name="actionPreviewTop"/>
+   <addaction name="actionPreviewSeparate"/>
   </widget>
-  <action name="actionOpen" >
-   <property name="icon" >
-    <iconset resource="avidemux.qrc" >
+  <action name="actionOpen">
+   <property name="icon">
+    <iconset resource="avidemux.qrc">
      <normaloff>:/new/prefix1/pics/fileopen.png</normaloff>:/new/prefix1/pics/fileopen.png</iconset>
    </property>
-   <property name="text" >
+   <property name="text">
     <string>&amp;Open...</string>
    </property>
-   <property name="shortcut" >
+   <property name="shortcut">
     <string>Ctrl+O</string>
    </property>
   </action>
-  <action name="actionAppend" >
-   <property name="text" >
+  <action name="actionAppend">
+   <property name="text">
     <string>&amp;Append...</string>
    </property>
-   <property name="shortcut" >
+   <property name="shortcut">
     <string>Ctrl+Alt+A</string>
    </property>
   </action>
-  <action name="actionQuit" >
-   <property name="text" >
+  <action name="actionQuit">
+   <property name="text">
     <string>&amp;Quit</string>
    </property>
   </action>
-  <action name="actionCut" >
-   <property name="text" >
+  <action name="actionCut">
+   <property name="text">
     <string>Cu&amp;t</string>
    </property>
-   <property name="shortcut" >
+   <property name="shortcut">
     <string>Ctrl+X</string>
    </property>
   </action>
-  <action name="actionCopy" >
-   <property name="text" >
+  <action name="actionCopy">
+   <property name="text">
     <string>&amp;Copy</string>
    </property>
-   <property name="shortcut" >
+   <property name="shortcut">
     <string>Ctrl+C</string>
    </property>
   </action>
-  <action name="actionPaste" >
-   <property name="text" >
+  <action name="actionPaste">
+   <property name="text">
     <string>&amp;Paste</string>
    </property>
-   <property name="shortcut" >
+   <property name="shortcut">
     <string>Ctrl+V</string>
    </property>
   </action>
-  <action name="actionDelete" >
-   <property name="text" >
+  <action name="actionDelete">
+   <property name="text">
     <string>&amp;Delete</string>
    </property>
-   <property name="shortcut" >
+   <property name="shortcut">
     <string>Del</string>
    </property>
   </action>
-  <action name="actionSet_marker_A" >
-   <property name="icon" >
-    <iconset resource="avidemux.qrc" >
+  <action name="actionSet_marker_A">
+   <property name="icon">
+    <iconset resource="avidemux.qrc">
      <normaloff>:/new/prefix1/pics/markA.png</normaloff>:/new/prefix1/pics/markA.png</iconset>
    </property>
-   <property name="text" >
+   <property name="text">
     <string>Set Marker A</string>
    </property>
-   <property name="iconText" >
+   <property name="iconText">
     <string>Set Marker A</string>
    </property>
-   <property name="toolTip" >
+   <property name="toolTip">
     <string>Set Marker A</string>
    </property>
-   <property name="shortcut" >
+   <property name="shortcut">
     <string>[</string>
    </property>
   </action>
-  <action name="actionSet_marker_B" >
-   <property name="icon" >
-    <iconset resource="avidemux.qrc" >
+  <action name="actionSet_marker_B">
+   <property name="icon">
+    <iconset resource="avidemux.qrc">
      <normaloff>:/new/prefix1/pics/markB.png</normaloff>:/new/prefix1/pics/markB.png</iconset>
    </property>
-   <property name="text" >
+   <property name="text">
     <string>Set Marker B</string>
    </property>
-   <property name="iconText" >
+   <property name="iconText">
     <string>Set Marker B</string>
    </property>
-   <property name="toolTip" >
+   <property name="toolTip">
     <string>Set Marker B</string>
    </property>
-   <property name="shortcut" >
+   <property name="shortcut">
     <string>]</string>
    </property>
   </action>
-  <action name="actionPreferences" >
-   <property name="text" >
+  <action name="actionPreferences">
+   <property name="text">
     <string>Pre&amp;ferences...</string>
    </property>
   </action>
-  <action name="actionProperties" >
-   <property name="icon" >
-    <iconset resource="avidemux.qrc" >
+  <action name="actionProperties">
+   <property name="icon">
+    <iconset resource="avidemux.qrc">
      <normaloff>:/new/prefix1/pics/info.png</normaloff>:/new/prefix1/pics/info.png</iconset>
    </property>
-   <property name="text" >
+   <property name="text">
     <string>&amp;Information...</string>
    </property>
-   <property name="shortcut" >
+   <property name="shortcut">
     <string>Alt+Return</string>
    </property>
   </action>
-  <action name="actionSave_video" >
-   <property name="icon" >
-    <iconset resource="avidemux.qrc" >
+  <action name="actionSave_video">
+   <property name="icon">
+    <iconset resource="avidemux.qrc">
      <normaloff>:/new/prefix1/pics/filesave.png</normaloff>:/new/prefix1/pics/filesave.png</iconset>
    </property>
-   <property name="text" >
+   <property name="text">
     <string>Save &amp;Video...</string>
    </property>
-   <property name="iconText" >
+   <property name="iconText">
     <string>Save Video</string>
    </property>
-   <property name="toolTip" >
+   <property name="toolTip">
     <string>Save Video</string>
    </property>
-   <property name="shortcut" >
+   <property name="shortcut">
     <string>Ctrl+S</string>
    </property>
   </action>
-  <action name="actionSave_BMP" >
-   <property name="text" >
+  <action name="actionSave_BMP">
+   <property name="text">
     <string>Save &amp;BMP Image...</string>
    </property>
-   <property name="iconText" >
+   <property name="iconText">
     <string>Save BMP Image</string>
    </property>
-   <property name="toolTip" >
+   <property name="toolTip">
     <string>Save BMP Image</string>
    </property>
   </action>
-  <action name="actionSave_jpeg" >
-   <property name="text" >
+  <action name="actionSave_jpeg">
+   <property name="text">
     <string>Save &amp;JPEG Image...</string>
    </property>
-   <property name="iconText" >
+   <property name="iconText">
     <string>Save JPEG Image</string>
    </property>
-   <property name="toolTip" >
+   <property name="toolTip">
     <string>Save JPEG Image</string>
    </property>
   </action>
-  <action name="actionLoad_run_project" >
-   <property name="icon" >
-    <iconset resource="avidemux.qrc" >
+  <action name="actionLoad_run_project">
+   <property name="icon">
+    <iconset resource="avidemux.qrc">
      <normaloff>:/new/prefix1/pics/project_open.png</normaloff>:/new/prefix1/pics/project_open.png</iconset>
    </property>
-   <property name="text" >
+   <property name="text">
     <string>&amp;Load/Run Project...</string>
    </property>
-   <property name="iconText" >
+   <property name="iconText">
     <string>Load/Run Project</string>
    </property>
-   <property name="toolTip" >
+   <property name="toolTip">
     <string>Load/Run Project</string>
    </property>
   </action>
-  <action name="actionSave_project" >
-   <property name="icon" >
-    <iconset resource="avidemux.qrc" >
+  <action name="actionSave_project">
+   <property name="icon">
+    <iconset resource="avidemux.qrc">
      <normaloff>:/new/prefix1/pics/filesave.png</normaloff>:/new/prefix1/pics/filesave.png</iconset>
    </property>
-   <property name="text" >
+   <property name="text">
     <string>Save &amp;Project</string>
    </property>
-   <property name="iconText" >
+   <property name="iconText">
     <string>Save Project</string>
    </property>
-   <property name="toolTip" >
+   <property name="toolTip">
     <string>Save Project</string>
    </property>
   </action>
-  <action name="actionSave_project_as" >
-   <property name="icon" >
-    <iconset resource="avidemux.qrc" >
+  <action name="actionSave_project_as">
+   <property name="icon">
+    <iconset resource="avidemux.qrc">
      <normaloff>:/new/prefix1/pics/filesaveas.png</normaloff>:/new/prefix1/pics/filesaveas.png</iconset>
    </property>
-   <property name="text" >
+   <property name="text">
     <string>Save P&amp;roject As...</string>
    </property>
-   <property name="iconText" >
+   <property name="iconText">
     <string>Save Project As</string>
    </property>
-   <property name="toolTip" >
+   <property name="toolTip">
     <string>Save Project As</string>
    </property>
   </action>
-  <action name="actionMain_toolbar" >
-   <property name="text" >
+  <action name="actionMain_toolbar">
+   <property name="text">
     <string>Main toolbar</string>
    </property>
   </action>
-  <action name="actionA_V_toolbar" >
-   <property name="text" >
+  <action name="actionA_V_toolbar">
+   <property name="text">
     <string>A/V toolbar</string>
    </property>
   </action>
-  <action name="actionZoom_1_4" >
-   <property name="checkable" >
+  <action name="actionZoom_1_4">
+   <property name="checkable">
     <bool>true</bool>
    </property>
-   <property name="text" >
+   <property name="text">
     <string>&amp;Zoom 1:4</string>
    </property>
-   <property name="shortcut" >
+   <property name="shortcut">
     <string>Ctrl+Shift+4</string>
    </property>
   </action>
-  <action name="actionZoom_1_2" >
-   <property name="checkable" >
+  <action name="actionZoom_1_2">
+   <property name="checkable">
     <bool>true</bool>
    </property>
-   <property name="text" >
+   <property name="text">
     <string>Z&amp;oom 1:2</string>
    </property>
-   <property name="shortcut" >
+   <property name="shortcut">
     <string>Ctrl+Shift+2</string>
    </property>
   </action>
-  <action name="actionZoom_1_1" >
-   <property name="checkable" >
+  <action name="actionZoom_1_1">
+   <property name="checkable">
     <bool>true</bool>
    </property>
-   <property name="checked" >
+   <property name="checked">
     <bool>true</bool>
    </property>
-   <property name="text" >
+   <property name="text">
     <string>Zoom &amp;1:1</string>
    </property>
-   <property name="shortcut" >
+   <property name="shortcut">
     <string>Ctrl+Alt+1</string>
    </property>
   </action>
-  <action name="actionZoom_2_1" >
-   <property name="checkable" >
+  <action name="actionZoom_2_1">
+   <property name="checkable">
     <bool>true</bool>
    </property>
-   <property name="text" >
+   <property name="text">
     <string>Zoom &amp;2:1</string>
    </property>
-   <property name="shortcut" >
+   <property name="shortcut">
     <string>Ctrl+Alt+2</string>
    </property>
   </action>
-  <action name="actionZoom_4_1" >
-   <property name="text" >
+  <action name="actionZoom_4_1">
+   <property name="text">
     <string>Zoom 4:1</string>
    </property>
   </action>
-  <action name="actionDecoder_options" >
-   <property name="text" >
+  <action name="actionDecoder_options">
+   <property name="text">
     <string>&amp;Decoder Options...</string>
    </property>
-   <property name="iconText" >
+   <property name="iconText">
     <string>Decoder Options</string>
    </property>
-   <property name="toolTip" >
+   <property name="toolTip">
     <string>Decoder Options</string>
    </property>
-   <property name="shortcut" >
+   <property name="shortcut">
     <string>F3</string>
    </property>
   </action>
-  <action name="actionPostprocessing" >
-   <property name="text" >
+  <action name="actionPostprocessing">
+   <property name="text">
     <string>&amp;Postprocessing...</string>
    </property>
-   <property name="shortcut" >
+   <property name="shortcut">
     <string>F4</string>
    </property>
   </action>
-  <action name="actionFrame_rate" >
-   <property name="text" >
+  <action name="actionFrame_rate">
+   <property name="text">
     <string>&amp;Frame Rate...</string>
    </property>
-   <property name="iconText" >
+   <property name="iconText">
     <string>Frame Rate</string>
    </property>
-   <property name="toolTip" >
+   <property name="toolTip">
     <string>Frame Rate</string>
    </property>
   </action>
-  <action name="actionEncoder" >
-   <property name="text" >
+  <action name="actionEncoder">
+   <property name="text">
     <string>Encoder</string>
    </property>
   </action>
-  <action name="actionFilters" >
-   <property name="text" >
+  <action name="actionFilters">
+   <property name="text">
     <string>Fil&amp;ters...</string>
    </property>
-   <property name="shortcut" >
+   <property name="shortcut">
     <string>Ctrl+Alt+F</string>
    </property>
   </action>
-  <action name="actionMain_Track" >
-   <property name="text" >
+  <action name="actionMain_Track">
+   <property name="text">
     <string>&amp;Main Track...</string>
    </property>
   </action>
-  <action name="actionSecondary_Track" >
-   <property name="text" >
+  <action name="actionSecondary_Track">
+   <property name="text">
     <string>&amp;Secondary Track...</string>
    </property>
   </action>
-  <action name="actionBuild_VBR_time_map" >
-   <property name="text" >
+  <action name="actionBuild_VBR_time_map">
+   <property name="text">
     <string>Build VBR Time Map</string>
    </property>
-   <property name="iconText" >
+   <property name="iconText">
     <string>Build VBR Time Map</string>
    </property>
-   <property name="toolTip" >
+   <property name="toolTip">
     <string>Build VBR Time Map</string>
    </property>
   </action>
-  <action name="actionSave_2" >
-   <property name="text" >
+  <action name="actionSave_2">
+   <property name="text">
     <string>S&amp;ave...</string>
    </property>
-   <property name="shortcut" >
+   <property name="shortcut">
     <string>Ctrl+Alt+S</string>
    </property>
   </action>
-  <action name="actionEncoder_2" >
-   <property name="text" >
+  <action name="actionEncoder_2">
+   <property name="text">
     <string>Encoder</string>
    </property>
   </action>
-  <action name="actionFilters_2" >
-   <property name="text" >
+  <action name="actionFilters_2">
+   <property name="text">
     <string>&amp;Filters</string>
    </property>
-   <property name="iconText" >
+   <property name="iconText">
     <string>Filters</string>
    </property>
-   <property name="toolTip" >
+   <property name="toolTip">
     <string>Filters</string>
    </property>
-   <property name="shortcut" >
+   <property name="shortcut">
     <string/>
    </property>
   </action>
-  <action name="actionCalculator" >
-   <property name="icon" >
-    <iconset resource="avidemux.qrc" >
+  <action name="actionCalculator">
+   <property name="icon">
+    <iconset resource="avidemux.qrc">
      <normaloff>:/new/prefix1/pics/calc.png</normaloff>:/new/prefix1/pics/calc.png</iconset>
    </property>
-   <property name="text" >
+   <property name="text">
     <string>&amp;Calculator...</string>
    </property>
-   <property name="shortcut" >
+   <property name="shortcut">
     <string>F7</string>
    </property>
   </action>
-  <action name="actionRebuild_I_B_Frames" >
-   <property name="text" >
+  <action name="actionRebuild_I_B_Frames">
+   <property name="text">
     <string>&amp;Rebuild I &amp;&amp; B Frames</string>
    </property>
-   <property name="iconText" >
+   <property name="iconText">
     <string>Rebuild I &amp; B Frames</string>
    </property>
-   <property name="toolTip" >
+   <property name="toolTip">
     <string>Rebuild I &amp; B Frames</string>
    </property>
   </action>
-  <action name="actionBitrate_histogram" >
-   <property name="text" >
+  <action name="actionBitrate_histogram">
+   <property name="text">
     <string>&amp;Bitrate Histogram...</string>
    </property>
-   <property name="iconText" >
+   <property name="iconText">
     <string>Bitrate Histogram</string>
    </property>
-   <property name="toolTip" >
+   <property name="toolTip">
     <string>Bitrate Histogram</string>
    </property>
   </action>
-  <action name="actionScan_for_black_frames" >
-   <property name="text" >
+  <action name="actionScan_for_black_frames">
+   <property name="text">
     <string>&amp;Scan for Black Frames...</string>
    </property>
-   <property name="iconText" >
+   <property name="iconText">
     <string>Scan for Black Frames</string>
    </property>
-   <property name="toolTip" >
+   <property name="toolTip">
     <string>Scan for Black Frames</string>
    </property>
   </action>
-  <action name="actionVob_to_vobsub" >
-   <property name="text" >
-    <string>&amp;VOB -> VobSub...</string>
+  <action name="actionVob_to_vobsub">
+   <property name="text">
+    <string>&amp;VOB -&gt; VobSub...</string>
    </property>
-   <property name="iconText" >
-    <string>VOB -> VobSub</string>
+   <property name="iconText">
+    <string>VOB -&gt; VobSub</string>
    </property>
-   <property name="toolTip" >
-    <string>VOB -> VobSub</string>
+   <property name="toolTip">
+    <string>VOB -&gt; VobSub</string>
    </property>
   </action>
-  <action name="actionOCR" >
-   <property name="text" >
-    <string>&amp;OCR (VobSub -> srt)...</string>
+  <action name="actionOCR">
+   <property name="text">
+    <string>&amp;OCR (VobSub -&gt; srt)...</string>
    </property>
-   <property name="iconText" >
-    <string>OCR (VobSub -> srt)</string>
+   <property name="iconText">
+    <string>OCR (VobSub -&gt; srt)</string>
    </property>
-   <property name="toolTip" >
-    <string>OCR (VobSub -> srt)</string>
+   <property name="toolTip">
+    <string>OCR (VobSub -&gt; srt)</string>
    </property>
   </action>
-  <action name="actionPlay_Stop" >
-   <property name="icon" >
-    <iconset resource="avidemux.qrc" >
+  <action name="actionPlay_Stop">
+   <property name="icon">
+    <iconset resource="avidemux.qrc">
      <normaloff>:/new/prefix1/pics/player_stop.png</normaloff>:/new/prefix1/pics/player_stop.png</iconset>
    </property>
-   <property name="text" >
+   <property name="text">
     <string>Stop</string>
    </property>
-   <property name="iconText" >
+   <property name="iconText">
     <string>Stop</string>
    </property>
-   <property name="toolTip" >
+   <property name="toolTip">
     <string>Stop</string>
    </property>
-   <property name="shortcut" >
+   <property name="shortcut">
     <string>P</string>
    </property>
   </action>
-  <action name="actionPrevious_Frame" >
-   <property name="icon" >
-    <iconset resource="avidemux.qrc" >
+  <action name="actionPrevious_Frame">
+   <property name="icon">
+    <iconset resource="avidemux.qrc">
      <normaloff>:/new/prefix1/pics/back.png</normaloff>:/new/prefix1/pics/back.png</iconset>
    </property>
-   <property name="text" >
+   <property name="text">
     <string>P&amp;revious Frame</string>
    </property>
-   <property name="shortcut" >
+   <property name="shortcut">
     <string>Left</string>
    </property>
   </action>
-  <action name="actionNext_Frame" >
-   <property name="icon" >
-    <iconset resource="avidemux.qrc" >
+  <action name="actionNext_Frame">
+   <property name="icon">
+    <iconset resource="avidemux.qrc">
      <normaloff>:/new/prefix1/pics/forward.png</normaloff>:/new/prefix1/pics/forward.png</iconset>
    </property>
-   <property name="text" >
+   <property name="text">
     <string>&amp;Next Frame</string>
    </property>
-   <property name="shortcut" >
+   <property name="shortcut">
     <string>Right</string>
    </property>
   </action>
-  <action name="actionPrevious_intra_frame" >
-   <property name="icon" >
-    <iconset resource="avidemux.qrc" >
+  <action name="actionPrevious_intra_frame">
+   <property name="icon">
+    <iconset resource="avidemux.qrc">
      <normaloff>:/new/prefix1/pics/player_rew.png</normaloff>:/new/prefix1/pics/player_rew.png</iconset>
    </property>
-   <property name="text" >
+   <property name="text">
     <string>Pr&amp;evious Intra Frame</string>
    </property>
-   <property name="iconText" >
+   <property name="iconText">
     <string>Previous Intra Frame</string>
    </property>
-   <property name="toolTip" >
+   <property name="toolTip">
     <string>Previous Intra Frame</string>
    </property>
-   <property name="shortcut" >
+   <property name="shortcut">
     <string>Down</string>
    </property>
   </action>
-  <action name="actionNext_intra_frame" >
-   <property name="icon" >
-    <iconset resource="avidemux.qrc" >
+  <action name="actionNext_intra_frame">
+   <property name="icon">
+    <iconset resource="avidemux.qrc">
      <normaloff>:/new/prefix1/pics/player_fwd.png</normaloff>:/new/prefix1/pics/player_fwd.png</iconset>
    </property>
-   <property name="text" >
+   <property name="text">
     <string>Next &amp;Intra Frame</string>
    </property>
-   <property name="iconText" >
+   <property name="iconText">
     <string>Next Intra Frame</string>
    </property>
-   <property name="toolTip" >
+   <property name="toolTip">
     <string>Next Intra Frame</string>
    </property>
-   <property name="shortcut" >
+   <property name="shortcut">
     <string>Up</string>
    </property>
   </action>
-  <action name="actionPrevious_black_frame" >
-   <property name="icon" >
-    <iconset resource="avidemux.qrc" >
+  <action name="actionPrevious_black_frame">
+   <property name="icon">
+    <iconset resource="avidemux.qrc">
      <normaloff>:/new/prefix1/pics/prev_black.png</normaloff>:/new/prefix1/pics/prev_black.png</iconset>
    </property>
-   <property name="text" >
+   <property name="text">
     <string>Previou&amp;s Black Frame</string>
    </property>
-   <property name="iconText" >
+   <property name="iconText">
     <string>Previous Black Frame</string>
    </property>
-   <property name="toolTip" >
+   <property name="toolTip">
     <string>Previous Black Frame</string>
    </property>
   </action>
-  <action name="actionNext_blak_frame" >
-   <property name="icon" >
-    <iconset resource="avidemux.qrc" >
+  <action name="actionNext_blak_frame">
+   <property name="icon">
+    <iconset resource="avidemux.qrc">
      <normaloff>:/new/prefix1/pics/next_black.png</normaloff>:/new/prefix1/pics/next_black.png</iconset>
    </property>
-   <property name="text" >
+   <property name="text">
     <string>Ne&amp;xt Black Frame</string>
    </property>
-   <property name="iconText" >
+   <property name="iconText">
     <string>Next Black Frame</string>
    </property>
-   <property name="toolTip" >
+   <property name="toolTip">
     <string>Next Black Frame</string>
    </property>
   </action>
-  <action name="actionFirst_Frame" >
-   <property name="icon" >
-    <iconset resource="avidemux.qrc" >
+  <action name="actionFirst_Frame">
+   <property name="icon">
+    <iconset resource="avidemux.qrc">
      <normaloff>:/new/prefix1/pics/player_start.png</normaloff>:/new/prefix1/pics/player_start.png</iconset>
    </property>
-   <property name="text" >
+   <property name="text">
     <string>&amp;First Frame</string>
    </property>
-   <property name="shortcut" >
+   <property name="shortcut">
     <string>Home</string>
    </property>
   </action>
-  <action name="actionLast_Frame" >
-   <property name="icon" >
-    <iconset resource="avidemux.qrc" >
+  <action name="actionLast_Frame">
+   <property name="icon">
+    <iconset resource="avidemux.qrc">
      <normaloff>:/new/prefix1/pics/player_end.png</normaloff>:/new/prefix1/pics/player_end.png</iconset>
    </property>
-   <property name="text" >
+   <property name="text">
     <string>&amp;Last Frame</string>
    </property>
-   <property name="shortcut" >
+   <property name="shortcut">
     <string>End</string>
    </property>
   </action>
-  <action name="actionGo_to_Marker_A" >
-   <property name="icon" >
-    <iconset resource="avidemux.qrc" >
+  <action name="actionGo_to_Marker_A">
+   <property name="icon">
+    <iconset resource="avidemux.qrc">
      <normaloff>:/new/prefix1/pics/gotoA.png</normaloff>:/new/prefix1/pics/gotoA.png</iconset>
    </property>
-   <property name="text" >
+   <property name="text">
     <string>Jump to Marker &amp;A</string>
    </property>
-   <property name="iconText" >
+   <property name="iconText">
     <string>Jump to Marker A</string>
    </property>
-   <property name="toolTip" >
+   <property name="toolTip">
     <string>Jump to Marker A</string>
    </property>
-   <property name="shortcut" >
+   <property name="shortcut">
     <string>Ctrl+[</string>
    </property>
   </action>
-  <action name="actionGo_to_Marker_B" >
-   <property name="icon" >
-    <iconset resource="avidemux.qrc" >
+  <action name="actionGo_to_Marker_B">
+   <property name="icon">
+    <iconset resource="avidemux.qrc">
      <normaloff>:/new/prefix1/pics/gotoB.png</normaloff>:/new/prefix1/pics/gotoB.png</iconset>
    </property>
-   <property name="text" >
+   <property name="text">
     <string>Jump to Marker &amp;B</string>
    </property>
-   <property name="iconText" >
+   <property name="iconText">
     <string>Jump to Marker B</string>
    </property>
-   <property name="toolTip" >
+   <property name="toolTip">
     <string>Jump to Marker B</string>
    </property>
-   <property name="shortcut" >
+   <property name="shortcut">
     <string>Ctrl+]</string>
    </property>
   </action>
-  <action name="actionJump_to_Frame" >
-   <property name="text" >
+  <action name="actionJump_to_Frame">
+   <property name="text">
     <string>Jump to Fra&amp;me...</string>
    </property>
-   <property name="shortcut" >
+   <property name="shortcut">
     <string>Ctrl+F</string>
    </property>
   </action>
-  <action name="actionJump_to_Time" >
-   <property name="text" >
+  <action name="actionJump_to_Time">
+   <property name="text">
     <string>Jump to &amp;Time...</string>
    </property>
-   <property name="shortcut" >
+   <property name="shortcut">
     <string>Ctrl+T</string>
    </property>
   </action>
-  <action name="actionShow_built_in_support" >
-   <property name="text" >
+  <action name="actionShow_built_in_support">
+   <property name="text">
     <string>&amp;Built-in Support...</string>
    </property>
-   <property name="iconText" >
+   <property name="iconText">
     <string>Built-in Support</string>
    </property>
-   <property name="toolTip" >
+   <property name="toolTip">
     <string>Built-in Support</string>
    </property>
   </action>
-  <action name="actionAbout_avidemux" >
-   <property name="text" >
+  <action name="actionAbout_avidemux">
+   <property name="text">
     <string>&amp;About Avidemux...</string>
    </property>
-   <property name="iconText" >
+   <property name="iconText">
     <string>About Avidemux</string>
    </property>
-   <property name="toolTip" >
+   <property name="toolTip">
     <string>About Avidemux</string>
    </property>
   </action>
-  <action name="actionPlay" >
-   <property name="icon" >
-    <iconset resource="avidemux.qrc" >
+  <action name="actionPlay">
+   <property name="icon">
+    <iconset resource="avidemux.qrc">
      <normaloff>:/new/prefix1/pics/player_play.png</normaloff>:/new/prefix1/pics/player_play.png</iconset>
    </property>
-   <property name="text" >
+   <property name="text">
     <string>&amp;Play/Stop</string>
    </property>
-   <property name="iconText" >
+   <property name="iconText">
     <string>Play/Stop</string>
    </property>
-   <property name="toolTip" >
+   <property name="toolTip">
     <string>Play/Stop</string>
    </property>
-   <property name="shortcut" >
+   <property name="shortcut">
     <string>P</string>
    </property>
   </action>
-  <action name="actionRecent0" >
-   <property name="text" >
+  <action name="actionRecent0">
+   <property name="text">
     <string>Recent0</string>
    </property>
   </action>
-  <action name="actionRecent1" >
-   <property name="text" >
+  <action name="actionRecent1">
+   <property name="text">
     <string>Recent1</string>
    </property>
   </action>
-  <action name="actionRecent2" >
-   <property name="text" >
+  <action name="actionRecent2">
+   <property name="text">
     <string>Recent2</string>
    </property>
   </action>
-  <action name="actionRecent3" >
-   <property name="text" >
+  <action name="actionRecent3">
+   <property name="text">
     <string>Recent3</string>
    </property>
   </action>
-  <action name="actionVCD" >
-   <property name="text" >
+  <action name="actionVCD">
+   <property name="text">
     <string>&amp;VCD</string>
    </property>
   </action>
-  <action name="actionSVCD" >
-   <property name="text" >
+  <action name="actionSVCD">
+   <property name="text">
     <string>&amp;SVCD</string>
    </property>
   </action>
-  <action name="actionDVD" >
-   <property name="text" >
+  <action name="actionDVD">
+   <property name="text">
     <string>&amp;DVD</string>
    </property>
   </action>
-  <action name="actionPSP" >
-   <property name="text" >
+  <action name="actionPSP">
+   <property name="text">
     <string>&amp;PSP</string>
    </property>
   </action>
-  <action name="actionPSP_H264" >
-   <property name="text" >
+  <action name="actionPSP_H264">
+   <property name="text">
     <string>PSP (&amp;H.264)</string>
    </property>
-   <property name="iconText" >
+   <property name="iconText">
     <string>PSP (H.264)</string>
    </property>
-   <property name="toolTip" >
+   <property name="toolTip">
     <string>PSP (H.264)</string>
    </property>
   </action>
-  <action name="actionAdd_to_joblist" >
-   <property name="text" >
+  <action name="actionAdd_to_joblist">
+   <property name="text">
     <string>Add to &amp;Joblist...</string>
    </property>
-   <property name="iconText" >
+   <property name="iconText">
     <string>Add to Joblist</string>
    </property>
-   <property name="toolTip" >
+   <property name="toolTip">
     <string>Add to Joblist</string>
    </property>
   </action>
-  <action name="actionShow_Joblist" >
-   <property name="text" >
+  <action name="actionShow_Joblist">
+   <property name="text">
     <string>View &amp;Joblist...</string>
    </property>
-   <property name="iconText" >
+   <property name="iconText">
     <string>View Joblist</string>
    </property>
-   <property name="toolTip" >
+   <property name="toolTip">
     <string>View Joblist</string>
    </property>
-   <property name="shortcut" >
+   <property name="shortcut">
     <string>Ctrl+J</string>
    </property>
   </action>
-  <action name="actionConnect_to_AvsProxy" >
-   <property name="text" >
+  <action name="actionConnect_to_AvsProxy">
+   <property name="text">
     <string>Co&amp;nnect to avsproxy</string>
    </property>
-   <property name="iconText" >
+   <property name="iconText">
     <string>Connect to avsproxy</string>
    </property>
-   <property name="toolTip" >
+   <property name="toolTip">
     <string>Connect to avsproxy</string>
    </property>
   </action>
-  <action name="actionReset_Edits" >
-   <property name="text" >
+  <action name="actionReset_Edits">
+   <property name="text">
     <string>&amp;Reset Edits</string>
    </property>
   </action>
-  <action name="actionSave" >
-   <property name="text" >
+  <action name="actionSave">
+   <property name="text">
     <string>Save</string>
    </property>
   </action>
-  <action name="actionOCR_DVB_T_TS_files" >
-   <property name="text" >
-    <string>OCR (&amp;TS -> srt)...</string>
+  <action name="actionOCR_DVB_T_TS_files">
+   <property name="text">
+    <string>OCR (&amp;TS -&gt; srt)...</string>
    </property>
-   <property name="iconText" >
-    <string>OCR (TS -> srt)</string>
+   <property name="iconText">
+    <string>OCR (TS -&gt; srt)</string>
    </property>
-   <property name="toolTip" >
-    <string>OCR (TS -> srt)</string>
+   <property name="toolTip">
+    <string>OCR (TS -&gt; srt)</string>
    </property>
   </action>
-  <action name="actionGlyphs_Edit" >
-   <property name="text" >
+  <action name="actionGlyphs_Edit">
+   <property name="text">
     <string>Edit &amp;Glyphs...</string>
    </property>
-   <property name="iconText" >
+   <property name="iconText">
     <string>Edit Glyphs</string>
    </property>
-   <property name="toolTip" >
+   <property name="toolTip">
     <string>Edit Glyphs</string>
    </property>
   </action>
-  <action name="actionPreviewInput" >
-   <property name="checkable" >
+  <action name="actionPreviewInput">
+   <property name="checkable">
     <bool>true</bool>
    </property>
-   <property name="checked" >
+   <property name="checked">
     <bool>true</bool>
    </property>
-   <property name="icon" >
-    <iconset resource="avidemux.qrc" >
+   <property name="icon">
+    <iconset resource="avidemux.qrc">
      <normaloff>:/new/prefix1/pics/preview_input.png</normaloff>:/new/prefix1/pics/preview_input.png</iconset>
    </property>
-   <property name="text" >
+   <property name="text">
     <string>&amp;Input</string>
    </property>
   </action>
-  <action name="actionPreviewOutput" >
-   <property name="checkable" >
+  <action name="actionPreviewOutput">
+   <property name="checkable">
     <bool>true</bool>
    </property>
-   <property name="icon" >
-    <iconset resource="avidemux.qrc" >
+   <property name="icon">
+    <iconset resource="avidemux.qrc">
      <normaloff>:/new/prefix1/pics/preview_output.png</normaloff>:/new/prefix1/pics/preview_output.png</iconset>
    </property>
-   <property name="text" >
+   <property name="text">
     <string>&amp;Output</string>
    </property>
   </action>
-  <action name="actionPreviewSide" >
-   <property name="checkable" >
+  <action name="actionPreviewSide">
+   <property name="checkable">
     <bool>true</bool>
    </property>
-   <property name="icon" >
-    <iconset resource="avidemux.qrc" >
+   <property name="icon">
+    <iconset resource="avidemux.qrc">
      <normaloff>:/new/prefix1/pics/preview_side.png</normaloff>:/new/prefix1/pics/preview_side.png</iconset>
    </property>
-   <property name="text" >
+   <property name="text">
     <string>Si&amp;de</string>
    </property>
   </action>
-  <action name="actionPreviewTop" >
-   <property name="checkable" >
+  <action name="actionPreviewTop">
+   <property name="checkable">
     <bool>true</bool>
    </property>
-   <property name="icon" >
-    <iconset resource="avidemux.qrc" >
+   <property name="icon">
+    <iconset resource="avidemux.qrc">
      <normaloff>:/new/prefix1/pics/preview_top.png</normaloff>:/new/prefix1/pics/preview_top.png</iconset>
    </property>
-   <property name="text" >
+   <property name="text">
     <string>&amp;Top</string>
    </property>
   </action>
-  <action name="actionPreviewSeparate" >
-   <property name="checkable" >
+  <action name="actionPreviewSeparate">
+   <property name="checkable">
     <bool>true</bool>
    </property>
-   <property name="icon" >
-    <iconset resource="avidemux.qrc" >
+   <property name="icon">
+    <iconset resource="avidemux.qrc">
      <normaloff>:/new/prefix1/pics/preview_separate.png</normaloff>:/new/prefix1/pics/preview_separate.png</iconset>
    </property>
-   <property name="text" >
+   <property name="text">
     <string>&amp;Separate</string>
    </property>
   </action>
-  <action name="action_Input" >
-   <property name="text" >
+  <action name="action_Input">
+   <property name="text">
     <string>&amp;Input</string>
    </property>
   </action>
-  <action name="action_Output" >
-   <property name="text" >
+  <action name="action_Output">
+   <property name="text">
     <string>&amp;Output</string>
    </property>
   </action>
-  <action name="actionSi_de" >
-   <property name="text" >
+  <action name="actionSi_de">
+   <property name="text">
     <string>Si&amp;de</string>
    </property>
   </action>
-  <action name="action_Top" >
-   <property name="text" >
+  <action name="action_Top">
+   <property name="text">
     <string>&amp;Top</string>
    </property>
   </action>
-  <action name="action_Separate" >
-   <property name="text" >
+  <action name="action_Separate">
+   <property name="text">
     <string>&amp;Separate</string>
    </property>
   </action>
-  <action name="actionFLV" >
-   <property name="text" >
+  <action name="actionFLV">
+   <property name="text">
     <string>FLV</string>
    </property>
   </action>
-  <action name="actionIPOD" >
-   <property name="text" >
+  <action name="actionIPOD">
+   <property name="text">
     <string>IPOD (mpeg4)</string>
    </property>
   </action>
-  <action name="actionClose" >
-   <property name="text" >
+  <action name="actionClose">
+   <property name="text">
     <string>&amp;Close</string>
    </property>
-   <property name="shortcut" >
+   <property name="shortcut">
     <string>Ctrl+W</string>
    </property>
   </action>
-  <action name="actionPlugins" >
-   <property name="text" >
+  <action name="actionPlugins">
+   <property name="text">
     <string>Plugins</string>
    </property>
   </action>
@@ -2423,7 +2337,7 @@
   </customwidget>
  </customwidgets>
  <resources>
-  <include location="avidemux.qrc" />
+  <include location="avidemux.qrc"/>
  </resources>
  <connections/>
 </ui>



From mean at mail.berlios.de  Tue Oct 20 15:26:37 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 20 Oct 2009 15:26:37 +0200
Subject: [Avidemux-svn-commit] r5387 -
	branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui
Message-ID: <200910201326.n9KDQbo1003833@sheep.berlios.de>

Author: mean
Date: 2009-10-20 15:26:37 +0200 (Tue, 20 Oct 2009)
New Revision: 5387

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/T_preview.cpp
Log:
[Qt4] window() behaviour has changed on recent qt, hence the root window is used for Xv/SDL display with the old scheme. Directly use the winid() so that the video window is used.

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/T_preview.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/T_preview.cpp	2009-10-20 13:26:35 UTC (rev 5386)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/T_preview.cpp	2009-10-20 13:26:37 UTC (rev 5387)
@@ -177,7 +177,7 @@
     const QX11Info &info=videoWindow->x11Info();
     xinfo->display=info.display();
    // xinfo->window=videoWindow->winId();
-    xinfo->window=videoWindow->window()->winId();
+    xinfo->window=videoWindow->winId();
 #endif
 
 	xinfo->x = widget->x();



From mean at mail.berlios.de  Tue Oct 20 15:26:39 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 20 Oct 2009 15:26:39 +0200
Subject: [Avidemux-svn-commit] r5388 -
	branches/avidemux_2.6_branch_mean/avidemux/common
Message-ID: <200910201326.n9KDQcMH003847@sheep.berlios.de>

Author: mean
Date: 2009-10-20 15:26:38 +0200 (Tue, 20 Oct 2009)
New Revision: 5388

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/gtkgui.h
   branches/avidemux_2.6_branch_mean/avidemux/common/gui_navigate.cpp
Log:
[UI] Cleanup the scale handling

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp	2009-10-20 13:26:37 UTC (rev 5387)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp	2009-10-20 13:26:38 UTC (rev 5388)
@@ -1210,10 +1210,11 @@
         ADM_dealloc(name);
         ADM_dealloc(final);
 }
-///
-///	Return the frame # corresponding to the position of the scale/slider
-///	Rougth estimation in fact
-///
+/**
+    \fn GUI_GetScale
+    \brief Return the % of the scale, between 0 and ADM_SCALE_SIZE
+
+*/
 uint32_t GUI_GetScale(void)
 {
 
@@ -1225,10 +1226,20 @@
 
     return (uint32_t)floor(tg);;
 }
+/**
+    \fn GUI_SetScale
+    \brief Set the scale, input is between 0 and ADM_SCALE_SIZE (max)
+*/
+void     GUI_SetScale( uint32_t scale )
+{
+    double percent;
+    percent=scale;
+    percent/=ADM_SCALE_SIZE;
+    percent*=100;
+    UI_setScale(percent);
+}
 
 
-
-
 /**
       \fn GUI_getFrameContent
       \brief fill image with content of frame frame

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/gtkgui.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/gtkgui.h	2009-10-20 13:26:37 UTC (rev 5387)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/gtkgui.h	2009-10-20 13:26:38 UTC (rev 5388)
@@ -33,6 +33,7 @@
 uint8_t A_ListAllBlackFrames( char *name);
 void GUI_PlayAvi( void );
 uint32_t GUI_GetScale( void );
+void     GUI_SetScale( uint32_t scale );
 void GUI_detransient(void );
 void GUI_retransient(void );
 

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/gui_navigate.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/gui_navigate.cpp	2009-10-20 13:26:37 UTC (rev 5387)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/gui_navigate.cpp	2009-10-20 13:26:38 UTC (rev 5388)
@@ -414,7 +414,7 @@
     UI_setTotalTime(video_body->getVideoDuration());
 
     // progress bar
-    UI_setScale(ADM_SCALE_SIZE);
+    GUI_SetScale(0);
 
 }
 
@@ -424,11 +424,14 @@
 */
 void GUI_setCurrentFrameAndTime(void)
 {
-    char text[80];
+    uint64_t pts=admPreview::getCurrentPts();
     double len;
    
-    UI_setCurrentTime(admPreview::getCurrentPts());
-    //UI_setScale(ADM_SCALE_SIZE);
+    UI_setCurrentTime(pts);
+    len=pts;
+    len*=ADM_SCALE_SIZE;
+    len/=video_body->getVideoDuration();  
+    GUI_SetScale(len);
 }
 /**
     \fn A_jumpToTime



From mean at mail.berlios.de  Tue Oct 20 15:26:43 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 20 Oct 2009 15:26:43 +0200
Subject: [Avidemux-svn-commit] r5389 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDevices/Alsa
Message-ID: <200910201326.n9KDQhuZ003861@sheep.berlios.de>

Author: mean
Date: 2009-10-20 15:26:42 +0200 (Tue, 20 Oct 2009)
New Revision: 5389

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDevices/Alsa/ADM_deviceALSA.cpp
Log:
[Alsa] Silence the underflow message

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDevices/Alsa/ADM_deviceALSA.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDevices/Alsa/ADM_deviceALSA.cpp	2009-10-20 13:26:38 UTC (rev 5388)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDevices/Alsa/ADM_deviceALSA.cpp	2009-10-20 13:26:42 UTC (rev 5389)
@@ -158,7 +158,7 @@
     }
 #else
 
- 	unsigned int buffer_time = 100LL*1000LL; // 800 Ms ?
+ 	unsigned int buffer_time = 1000LL*1000LL; // 60 Ms ?
 	int er;
 	unsigned int buff;
 	dir=0;
@@ -250,7 +250,7 @@
     lenInSample=lenInBytes/(_channels*2);
     if(!lenInSample)
     {
-        printf("[Alsa] Underflow\n");
+       // printf("[Alsa] Underflow\n");
         mutex.unlock();
         return ;
     }



From mean at mail.berlios.de  Tue Oct 20 15:26:45 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 20 Oct 2009 15:26:45 +0200
Subject: [Avidemux-svn-commit] r5390 - in
	branches/avidemux_2.6_branch_mean/avidemux/common: . ADM_script
Message-ID: <200910201326.n9KDQjTt003876@sheep.berlios.de>

Author: mean
Date: 2009-10-20 15:26:44 +0200 (Tue, 20 Oct 2009)
New Revision: 5390

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script/ADM_JSAvidemuxVideo.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/gui_navigate.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/gui_play.cpp
Log:
[Editor] Remove framenumber in editor API, only keep timeavidemux/common/ADM_editor

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.cpp	2009-10-20 13:26:42 UTC (rev 5389)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.cpp	2009-10-20 13:26:44 UTC (rev 5390)
@@ -331,7 +331,7 @@
       @param image : current main image (input)
       @param framenum, framenumber
 */
-
+#if 0 // OBSOLETE
 uint8_t admPreview::seekToIntra(uint32_t frame)
 {
     if(!video_body->GoToIntra(frame)) 
@@ -342,7 +342,7 @@
     return samePicture();
 
 }
-
+#endif
 /**
       \fn admPreview::seekToIntraPts
       \brief Seek to intra at PTS given as arg
@@ -673,8 +673,6 @@
 bool admPreview::previousFrame(void)
 {
     uint64_t pts=rdrImage->Pts;
-    uint32_t frame=video_body->getCurrentFrame();
-    if(!frame) return false;
     // If the frame is not an intra, the previous one
     // is still in the cache
     if(rdrImage->flags!=AVI_KEY_FRAME)

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.h	2009-10-20 13:26:42 UTC (rev 5389)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.h	2009-10-20 13:26:44 UTC (rev 5390)
@@ -24,7 +24,7 @@
   public:
       static uint8_t nextPicture(void);
       static uint8_t samePicture(void);
-      static uint8_t seekToIntra(uint32_t framenum);
+//      static uint8_t seekToIntra(uint32_t framenum);
       static bool seekToIntraPts(uint64_t timeframe);
       static void start(void);
       static void stop(void);

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script/ADM_JSAvidemuxVideo.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script/ADM_JSAvidemuxVideo.cpp	2009-10-20 13:26:42 UTC (rev 5389)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script/ADM_JSAvidemuxVideo.cpp	2009-10-20 13:26:44 UTC (rev 5390)
@@ -579,13 +579,14 @@
 uint32_t sz;
         if(argc != 1)
           return JS_FALSE;
-        
+#if 0        
         enterLock();
         frame=JSVAL_TO_INT(argv[0]);
         if(!video_body->getFrameSize(frame,&sz)) return JS_FALSE;
         leaveLock(); 
         
         *rval=INT_TO_JSVAL(sz);
+#endif
         return JS_TRUE;
 }// end PostProcess
 JSBool ADM_JSAvidemuxVideo::getFrameType(JSContext *cx, JSObject *obj, uintN argc, 
@@ -596,13 +597,14 @@
 uint32_t sz;
         if(argc != 1)
           return JS_FALSE;
-        
+#if 0        
         enterLock();
         frame=JSVAL_TO_INT(argv[0]);
         if(!video_body->getFlags(frame,&sz)) return JS_FALSE;
         leaveLock(); 
         
         *rval=INT_TO_JSVAL(sz);
+#endif
         return JS_TRUE;
 }// end PostProcess
 /* EOF */

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp	2009-10-20 13:26:42 UTC (rev 5389)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp	2009-10-20 13:26:44 UTC (rev 5390)
@@ -492,7 +492,7 @@
       break;
       // set decoder option (post processing ...)
     case ACT_DecoderOption:
-      video_body->setDecodeParam ( video_body->getCurrentFrame());
+      video_body->setDecodeParam ( admPreview::getCurrentPts());
 
       break;
     case ACT_VideoParameter:
@@ -641,7 +641,7 @@
         {
             uint32_t nbAudio;
             audioInfo *infos=NULL;
-            if(video_body->getAudioStreamsInfo(video_body->getCurrentFrame()+1,&nbAudio,&infos))
+            if(video_body->getAudioStreamsInfo(admPreview::getCurrentPts()+1,&nbAudio,&infos))
             {
                 if(nbAudio>1)
                 {   // Multiple track warn user
@@ -746,11 +746,11 @@
 
 
 
-      admPreview::seekToIntra (0);
+   //   admPreview::seekToIntraPts (0);
       admPreview::samePicture();
       GUI_setCurrentFrameAndTime();
 
-   printf("\n** conf updated **\n");
+   ADM_info(" conf updated \n");
 }
 
 //___________________________________________
@@ -1325,6 +1325,7 @@
  char sSize[15];
  ADMCompressedImage image;
  uint8_t seq;
+#if 0
  if (!avifileinfo) return;
 
  buffer=new uint8_t [avifileinfo->width*avifileinfo->height*3];
@@ -1348,6 +1349,7 @@
  if(diaFactoryRun(QT_TR_NOOP("Frame Hex Dump"),3,elems))
 
  delete [] buffer;
+#endif
 }
 /**
     \fn GUI_showSize
@@ -1364,13 +1366,9 @@
  char                text[DUMP_SIZE][100];
  
  if (!avifileinfo) return;
-
+#if 0
  buffer=new uint8_t [avifileinfo->width*avifileinfo->height*3];
  image.data=buffer;
-
-
-
-
     for(int i=0;i<DUMP_SIZE;i++)
     {
         int target=video_body->getCurrentFrame()+i;
@@ -1385,7 +1383,7 @@
 
  
  delete [] buffer;
- 
+ #endif
 }
 
 /**

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/gui_navigate.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/gui_navigate.cpp	2009-10-20 13:26:42 UTC (rev 5389)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/gui_navigate.cpp	2009-10-20 13:26:44 UTC (rev 5390)
@@ -87,6 +87,7 @@
             }
             break;
       case ACT_Goto:
+#if 0
           uint32_t fn;
           fn = video_body->getCurrentFrame();
           if (DIA_GetIntegerValue
@@ -98,14 +99,17 @@
             else
                 GUI_Error_HIG(QT_TR_NOOP("Out of bounds"), NULL);
             }
+#endif
           break;
       case ACT_Back25Frames:
+#if 0
           if (video_body->getCurrentFrame() >= 25)
           {
               DIA_StartBusy();
               GUI_GoToFrame (video_body->getCurrentFrame() - 25);
               DIA_StopBusy();
           }
+#endif
 	  break;
 
       case ACT_PreviousKFrame:
@@ -180,7 +184,7 @@
       case ACT_GotoTime:
 	  {
            // Get current time
-            uint64_t pts=video_body->estimatePts(video_body->getCurrentFrame());
+            uint64_t pts=admPreview::getCurrentPts();
 
 	      uint16_t mm, hh, ss, ms;
             ms2time((uint32_t)(pts/1000),&hh,&mm,&ss,&ms);
@@ -259,6 +263,7 @@
 */
 int GUI_GoToFrame(uint32_t frame)
 {
+#if 0
     uint32_t flags;
 
     if (playing)
@@ -273,6 +278,7 @@
 
     if(!admPreview::samePicture()) return 0;
     GUI_setAllFrameAndTime();
+#endif
     return 1;
 }
 
@@ -409,7 +415,7 @@
     // if(!guiReady) return ;
     text[0] = 0;
 
-    UI_updateFrameCount(video_body->getCurrentFrame());
+    //UI_updateFrameCount(video_body->getCurrentFrame());
     UI_setCurrentTime(admPreview::getCurrentPts());
     UI_setTotalTime(video_body->getVideoDuration());
 

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/gui_play.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/gui_play.cpp	2009-10-20 13:26:42 UTC (rev 5389)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/gui_play.cpp	2009-10-20 13:26:44 UTC (rev 5390)
@@ -94,7 +94,8 @@
     
     uint32_t framelen,flags;
     AVDMGenericVideoStream *filter;
-    uint32_t max,err,oldFrame;
+    uint32_t max,err;
+    uint64_t oldTimeFrame;
    
     // check we got everything...
     if (!avifileinfo)	return;
@@ -105,7 +106,7 @@
         stop_req = 1;
         return;
       }
-    oldFrame=video_body->getCurrentFrame();
+    oldTimeFrame=admPreview::getCurrentPts();
 	uint32_t priorityLevel;
 
 	originalPriority = getpriority(PRIO_PROCESS, 0);
@@ -140,7 +141,8 @@
    
    
    UI_purge();
-   video_body->setCurrentFrame(oldFrame);
+#warning FIXME
+//   admPreview::seekToFrame(oldTimeFrame);
    admPreview::samePicture();
    GUI_setCurrentFrameAndTime();
    UI_purge();



From mean at mail.berlios.de  Tue Oct 20 15:26:47 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 20 Oct 2009 15:26:47 +0200
Subject: [Avidemux-svn-commit] r5391 - in
	branches/avidemux_2.6_branch_mean/avidemux/common:
	ADM_commonUI ADM_editor ADM_muxerGate/src
Message-ID: <200910201326.n9KDQlgu003892@sheep.berlios.de>

Author: mean
Date: 2009-10-20 15:26:46 +0200 (Tue, 20 Oct 2009)
New Revision: 5391

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/DIA_bitrateHisto.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoCopy.cpp
Log:
[Editor] Remove framenumber in editor API, only keep time (part2)

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/DIA_bitrateHisto.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/DIA_bitrateHisto.cpp	2009-10-20 13:26:44 UTC (rev 5390)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/DIA_bitrateHisto.cpp	2009-10-20 13:26:46 UTC (rev 5391)
@@ -41,6 +41,7 @@
 uint32_t nbBFrame=0;
 uint32_t curBFrame=0;
 uint32_t maxBFrame=0;
+#if 0
 	// 1st compute the total
 	uint32_t start,end;
     uint64_t deltaTime=video_body->getMarkerBPts()-video_body->getMarkerAPts();
@@ -222,5 +223,6 @@
         {
           delete bar[i];
         }
+#endif
 }
 //EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp	2009-10-20 13:26:44 UTC (rev 5390)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp	2009-10-20 13:26:46 UTC (rev 5391)
@@ -106,8 +106,10 @@
         \brief bypass decoder and directly get the source image
 
 */
-bool        ADM_Composer::getCompressedPicure(uint32_t framenum,ADMCompressedImage *img)
+bool        ADM_Composer::getCompressedPicure(ADMCompressedImage *img)
 {
+    return false;
+#if 0
 uint32_t ref = 0,relative=0;
     if(false==_segments.getRefFromFrame(framenum,&ref,&relative))
     {
@@ -121,6 +123,7 @@
 
     if (!demuxer->getFrame (relative,img)) return false;
     return true;
+#endif
 }
 //***************************** Internal API**************************
 /**

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx	2009-10-20 13:26:44 UTC (rev 5390)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx	2009-10-20 13:26:46 UTC (rev 5391)
@@ -40,7 +40,9 @@
 
 #define ADM_EDITOR_AUDIO_BUFFER_SIZE (128*1024*6*sizeof(float))
 
-
+/**
+    \enum _ENV_EDITOR_FLAGS
+*/
 typedef enum
 {
 	ENV_EDITOR_NONE=   0x0000,
@@ -114,25 +116,32 @@
 /************************************ Public API ***************************/
 protected:
                     uint32_t    currentFrame;
+                    bool        GoToIntra(uint32_t frame);
+                    uint32_t    getCurrentFrame(void); 
+                    bool        setCurrentFrame(uint32_t frame);
+
+                    uint64_t    estimatePts(uint32_t frame);
 public:
-                    uint32_t    getCurrentFrame(void);
+                    bool        getCompressedPicure(ADMCompressedImage *img);
+      
+public:
+                   
                     uint64_t    getCurrentFramePts(void);
-                    bool        setCurrentFrame(uint32_t frame);
-                    bool        GoToIntra(uint32_t frame);
+                   
+                    
                     bool        GoToTime(uint64_t time);
                     bool        GoToIntraTime(uint64_t time);
                     bool        NextPicture(ADMImage *image);
                     bool        samePicture(ADMImage *image);
 
-                    bool        getCompressedPicure(uint32_t framenum,ADMCompressedImage *img);
-                    uint64_t    estimatePts(uint32_t frame);
+                   // Fixme, framenumber !
                     uint32_t    searchFrameBefore(uint64_t pts);
                     uint32_t    searchFrameAt(uint64_t pts);
                     bool        getImageFromCacheForFrameBefore(uint64_t pts,ADMImage *out);
                     bool        getPictureJustBefore(uint64_t pts);
                     bool        getPtsDts(uint32_t frame,uint64_t *pts,uint64_t *dts);
 /************************************ Internal ******************************/
-public:
+protected:
                                 /// Decode frame and on until frame is popped out of decoders
                     bool        DecodePictureUpToIntra(uint32_t frame,uint32_t ref);
                                 /// compressed image->yb12 image image and do postproc/colorconversion
@@ -148,6 +157,7 @@
                     bool        searchPreviousKeyFrameInRef(int ref,uint64_t refTime,uint64_t *nkTime);
 
 /************************************ Internal ******************************/
+protected:
                     uint8_t 	getFrame(uint32_t   framenum,ADMCompressedImage *img,uint8_t *isSequential);
                     
                 
@@ -155,11 +165,13 @@
                     uint32_t 	getFlags(uint32_t frame,uint32_t *flags);
 
                             // B follow A with just Bframes in between
-                    uint32_t 	getFlagsAndSeg (uint32_t frame, 
-                                uint32_t * flags,uint32_t *segs);
+                    uint32_t 	getFlagsAndSeg (uint32_t frame,    uint32_t * flags,uint32_t *segs);
                     uint8_t  	setFlag(uint32_t frame,uint32_t flags);
+
+                    uint8_t  	getFrameSize(uint32_t frame,uint32_t *size) ;
+
+public:
                     uint8_t	    updateVideoInfo(aviInfo *info);
-                    uint8_t  	getFrameSize(uint32_t frame,uint32_t *size) ;
                     uint32_t 	getSpecificMpeg4Info( void );
 /************************************ audioStream ******************************/
 protected:
@@ -198,13 +210,15 @@
 					
 					
 /***************************************** Seeking *****************************/            
+protected:
 		  			bool			getPKFrame(uint32_t *frame);
 					bool			getNKFrame(uint32_t *frame);
-                    bool			getNKFramePTS(uint64_t *frameTime);
-                    bool			getPKFramePTS(uint64_t *frameTime);
+
+                    
                     bool			getUncompressedFrame(uint32_t frame,ADMImage *out,uint32_t *flagz=NULL);
 public:
-                    
+                    bool			getNKFramePTS(uint64_t *frameTime);
+                    bool			getPKFramePTS(uint64_t *frameTime);   
 /******************************* Post Processing ************************************/
 					uint8_t 		setPostProc( uint32_t type, uint32_t strength,	uint32_t swapuv);
 					uint8_t 		getPostProc( uint32_t *type, uint32_t *strength,uint32_t *swapuv);

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp	2009-10-20 13:26:44 UTC (rev 5390)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp	2009-10-20 13:26:46 UTC (rev 5391)
@@ -131,7 +131,7 @@
 bool        ADM_EditorSegment::resetSegment(void)
 {
     //
-    
+    aviInfo info;
     segments.clear();
     int n=videos.size();
     for(int i=0;i<n;i++)
@@ -141,6 +141,8 @@
         memset(&seg,0,sizeof(seg));
         seg._durationUs=vid->_aviheader->getVideoDuration();
         seg._reference=i;
+        vid->_aviheader->getVideoInfo(&info);
+        seg._nbFrame=info.nb_frames;
         segments.push_back(seg);
     }
     updateStartTime();
@@ -210,20 +212,25 @@
 }
 /**
     \fn getNbFrames
-    \brief 
+    \brief Weak, avoid using it
 */
 uint32_t ADM_EditorSegment::getNbFrames(void)
 {
     uint32_t dur;
     uint32_t nb=0;
-    int n=videos.size();
+    int n=segments.size();
     for(int i=0;i<n;i++)
-        dur+=videos[i]._nb_video_frames;
+        dur+=segments[i]._nbFrame;
     return nb;
 
 }
+/***********************************************************************/
+/***********************************************************************/
+/***********************************************************************/
+/***********************************************************************/
 /**
-    \fn getTotalDuration
+    \fn getRefFromTime
+    \brief convert linear time to a ref video+ offset in the refvideo
 */
 bool        ADM_EditorSegment::getRefFromTime(uint64_t time,uint32_t *refVideo, uint64_t *offset)
 {
@@ -269,16 +276,28 @@
 {
     return &(segments[0]);
 }
-
+/**
+    \fn convertLinearTimeToSeg
+    \brief convert linear time to a segment+ offset in the segment
+*/
 bool        ADM_EditorSegment::convertLinearTimeToSeg(  uint64_t frameTime, uint32_t *seg, uint64_t *segTime)
 {
-    *seg=0;
-    *segTime=frameTime;
-    return true;
+    for(int i=0;i<segments.size();i++)
+    {
+        if(segments[i]._startTimeUs<=frameTime && segments[i]._startTimeUs+segments[i]._durationUs>frameTime)
+        {
+            *seg=i;
+            *segTime=frameTime-segments[i]._startTimeUs;
+            return true;
+        }
+    }
+    ADM_warning("Cannot find segment matching time %"LLU"ms \n",frameTime/1000);
+    return false;
 }
 bool        ADM_EditorSegment::convertSegTimeToLinear(  uint32_t seg,uint64_t segTime, uint64_t *frameTime)
 {
-    *frameTime=segTime;
+    ADM_assert(seg<segments.size());
+    *frameTime=segTime+segments[seg]._startTimeUs;
     return true;
 }
 //EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.h	2009-10-20 13:26:44 UTC (rev 5390)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.h	2009-10-20 13:26:46 UTC (rev 5391)
@@ -116,8 +116,8 @@
             uint32_t    getNbFrames(void);
 
             bool        getRefFromTime(uint64_t time,uint32_t *refVideo, uint64_t *offset);
+
             bool        getRefFromFrame(uint32_t frame,uint32_t *refVideo, uint32_t *frameOffset);
-
             bool        getFrameFromRef(uint32_t *frame,uint32_t refVideo, uint32_t frameOffset);
 
 

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoCopy.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoCopy.cpp	2009-10-20 13:26:44 UTC (rev 5390)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoCopy.cpp	2009-10-20 13:26:46 UTC (rev 5391)
@@ -24,6 +24,8 @@
 ADM_videoStreamCopy::ADM_videoStreamCopy(uint64_t startTime,uint64_t endTime)
 {
     aviInfo info;
+    uint64_t realStart=startTime;
+
     video_body->getVideoInfo(&info);
     width=info.width;
     height=info.height;
@@ -31,30 +33,15 @@
     averageFps1000=info.fps1000;
     isCFR=false;
     // Estimate start frame
-    currentFrame= video_body->searchFrameBefore(startTime+1);
-    while(currentFrame)
+    if(false==video_body->getPKFramePTS(&realStart))
     {
-        uint32_t flags;
-        video_body->getFlags(currentFrame,&flags);
-        if(flags&AVI_KEY_FRAME) break;
-        currentFrame--;
+        ADM_warning("Cannot find previous keyframe\n");
     }
     eofMet=false;
-    this->startTime=startTime;
+    this->startTime=realStart;
     this->endTime=endTime;
-    // Update start time if needed
-    uint64_t sPts,sDts,sStart=ADM_NO_PTS;
-    video_body->getPtsDts(currentFrame,&sPts,&sDts);
-    if(sDts!=ADM_NO_PTS) sStart=sDts;
-    else
-        if(sPts!=ADM_NO_PTS)
-        {
-            sStart=sPts;
-            printf("[Warning] No Dts available for first frame, guessing ...\n");
-        }
-    if(sStart!=ADM_NO_PTS)
-        this->startTime=sStart;
-    printf("[StreamCopy] Fixating start time by %u\n",abs((int)(this->startTime-startTime)));
+    video_body->GoToIntraTime(realStart);
+    ADM_info(" Fixating start time by %u\n",abs((int)(this->startTime-startTime)));
 }
 /**
     \fn ADM_videoStreamCopy
@@ -96,9 +83,9 @@
 {
     if(true==eofMet) return false;
     image.data=data;
-    if(false==video_body->getCompressedPicure(currentFrame,&image))
+    if(false==video_body->getCompressedPicure(&image))
     {
-            printf("[StreamCopy] Get packet failed for frame %d\n",currentFrame);
+            ADM_warning(" Get packet failed ");
             return false;
     }
     *len=image.dataLength;



From mean at mail.berlios.de  Tue Oct 20 15:26:49 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 20 Oct 2009 15:26:49 +0200
Subject: [Avidemux-svn-commit] r5392 - in
	branches/avidemux_2.6_branch_mean/avidemux/common: .
	ADM_editor ADM_muxerGate/src ADM_videoFilter2
Message-ID: <200910201326.n9KDQnrF003911@sheep.berlios.de>

Author: mean
Date: 2009-10-20 15:26:48 +0200 (Tue, 20 Oct 2009)
New Revision: 5392

Added:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRenderInternal.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edSearch.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edStub.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoCopy.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/ADM_videoFilterBridge.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/gui_navigate.cpp
Log:
[Editor] huge cleanup in editor api to only handle time, utterly boken

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp	2009-10-20 13:26:46 UTC (rev 5391)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp	2009-10-20 13:26:48 UTC (rev 5392)
@@ -1,13 +1,10 @@
 /***************************************************************************
-                          ADM_edRender.cpp  -  description
-                             -------------------
-     This file renders the compressed video depending on the availabilty of
-     		CODECs.      It also deals with key frame and stuff
+    \file  ADM_edRender.cpp  
+    \brief handle decoding by masking the editor segments (appended video, cut, etc..)
+    \author mean (c) 2002/2009 fixounet at free.fr
 
+    
 
-    begin                : Fri Apr 12 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
  ***************************************************************************/
 
 /***************************************************************************
@@ -29,878 +26,188 @@
 #endif
 
 #include "ADM_pp.h"
-
-// FIXME BADLY !!!
-// This should be in a context somewhere
-static uint8_t compBuffer[MAXIMUM_SIZE * MAXIMUM_SIZE * 3];
 /**
-        \fn GoToIntra
-        \brief Go to frame which must be an intra
-        @param frame is framenumber as seen by user
-        \return true on success, false on error
+    \fn recalibrate
+    \brief Convert time given in time from absolute ref video to linear time
 */
-bool        ADM_Composer::GoToIntra(uint32_t frame)
+static void recalibrate(uint64_t *time,_SEGMENT *seg)
 {
-uint32_t relframe, ref, flags, len;
+int64_t t=(int64_t)*time;
+        if(*time==ADM_NO_PTS) return;
 
-    if(_segments.getRefFromFrame(frame,&ref,&relframe)==false)
-    {
-        ADM_warning(" Cannot convert frame %"LU"\n",frame);
-        return false;
-    }
-    return DecodePictureUpToIntra(relframe,ref);
+        t-=seg->_refStartTimeUs;
+        if(t<0)
+        {
+            ADM_warning("Segment time is negative!\n");
+            t=0;
+        }
+        t+=seg->_startTimeUs;
+        *time=(uint64_t )t;
 }
 /**
-    \fn GoToTime
-    \brief Go to time time (just before)
-    \return true on success, false on error
+    \fn updateImageTiming
 */
-bool        ADM_Composer::GoToTime(uint64_t time)
+bool updateImageTiming(_SEGMENT *seg,ADMImage *image)
 {
-    // 1st go to the previous intra...
-      uint32_t frame=searchFrameBefore(time+1);
-      while(frame)
-      {
-            uint32_t flags;
-                getFlags(frame,&flags);
-                if(flags & AVI_KEY_FRAME) break;
-                frame--;
-      }
-        // Now go forward if needed
-#warning todo fixme!
-    printf("[Composer:GoToTime] Going to frame %"LU"\n",frame);
-    return GoToIntra(frame);
+    recalibrate(&(image->Pts),seg);
+//    recalibrate(&(image->Dts),seg);
+    return true;
 }
 /**
     \fn GoToIntraTime
     \brief Go to an intra at time time (exact)
     \return true on success, false on error
 */
-bool        ADM_Composer::GoToIntraTime(uint64_t time)
+bool        ADM_Composer::goToIntraTimeVideo(uint64_t time)
 {
-    // 1st go to the previous intra...
-      uint32_t frame=searchFrameAt(time);
-    ADM_info("When looking for frame at %"LLU" ms, found frame %"LU" as candidate\n",time,frame);
-    return GoToIntra(frame);
-}
-/**
-    \fn NextPicture
-    \brief decode & returns the next picture
-*/
-bool        ADM_Composer::NextPicture(ADMImage *image)
-{
-    return getNextPicture(image,0);
-
-}
-/**
-    \fn samePicture
-    \brief returns the last already decoded picture
-*/
-bool        ADM_Composer::samePicture(ADMImage *image)
-{
-    return getSamePicture(image,0);
-
-}
-/**
-        \fn getCompressedPicure
-        \brief bypass decoder and directly get the source image
-
-*/
-bool        ADM_Composer::getCompressedPicure(ADMCompressedImage *img)
-{
-    return false;
-#if 0
-uint32_t ref = 0,relative=0;
-    if(false==_segments.getRefFromFrame(framenum,&ref,&relative))
+    uint32_t s;
+    uint64_t segTime;
+    // Search the seg ..;
+    if(false==_segments.convertLinearTimeToSeg(time,&s,&segTime))
     {
-        ADM_warning("[getCompressedPicure] Cannot get ref+frame to frame %"LD"\n",framenum);
+        ADM_warning("GoToIntraTime failed!\n");
         return false;
     }
-    _VIDEOS *vid=_segments.getRefVideo(ref);
-    vidHeader *demuxer=vid->_aviheader;
+    _SEGMENT *seg=_segments.getSegment(s);
+    ADM_assert(seg);
+    _VIDEOS *ref=_segments.getRefVideo(seg->_reference);
+    ADM_assert(ref);
+    //
 
-    img->cleanup(framenum);
+    uint64_t refTime=seg->_refStartTimeUs+segTime;
 
-    if (!demuxer->getFrame (relative,img)) return false;
-    return true;
-#endif
-}
-//***************************** Internal API**************************
-/**
-    \fn DecodePictureUpToIntra
-    \brief Decode pictures from frameno, which must be an intra and on
-            until the decoded frameno is popped by the decoder
-
-    @param frame, framenumber relative to video ref (i.e. from its beginning)
-    @param ref  , video we are dealing with
-    returns true on success
-            fail on error
-
-*/
-bool ADM_Composer::DecodePictureUpToIntra(uint32_t frame,uint32_t ref)
-{
-  uint8_t ret = 0;
-  EditorCache   *cache;
-  ADMImage	*result;
-  uint32_t  flags;
-  ADMCompressedImage img;
-
-    // PlaceHolder...
-    img.data=compBuffer;
-    img.cleanup(frame);
-
-    printf("[EditorRender] DecodeUpToInta %u ref:%u\n",frame,ref);
-	_VIDEOS *vid=_segments.getRefVideo(ref);
-    vidHeader *demuxer=vid->_aviheader;
-	cache=_segments.getRefVideo(ref)->_videoCache;
-	ADM_assert(cache);
-    // Make sure frame is an intra
-    demuxer->getFlags(frame,&flags);
-    ADM_assert(flags==AVI_KEY_FRAME);
-
-    bool found=false;
-    vid->lastSentFrame=frame;
-    uint32_t nbFrames=vid->_nb_video_frames;
-    aprintf("[EditorRender] DecodeUpToIntra flushing cache & codec\n");
-    cache->flush();
-    vid->decoder->flush();
-    // The PTS associated with our frame is the one we are looking for
-    uint64_t wantedPts=vid->_aviheader->estimatePts(frame);
-    uint32_t tries=15+7; // Max Ref frames for H264 + MaxRecovery , let's say 7 is ok for recovery
-    bool syncFound=false;
-    while(found==false && tries--)
+    uint32_t frame=_segments.intraTimeToFrame(seg->_reference,time);       
+    if(false==switchToSegment(s))
     {
-        // Last frame ? if so repeat
-        if(vid->lastSentFrame>=nbFrames-1) vid->lastSentFrame=nbFrames-1;
-        // Fetch frame
-         aprintf("[Editor] Decoding  frame %u\n",vid->lastSentFrame);
-         
-         if (!demuxer->getFrame (vid->lastSentFrame,&img))
-         {
-                printf("[DecodePictureUpToIntra] getFrame failed for frame %"LU"\n",vid->lastSentFrame);
-                //cache->flush();
-                return false;
-         }
-         // Now uncompress it...
-         result=cache->getFreeImage();
-         if(frame==0) // out first frame, make sure it starts black to avoid the all green effect
-         {
-            result->blacken();
-         }
-         if(!result)
-         {
-                printf("[DecodePictureUpToIntra] Cache full for frame %"LU"\n",vid->lastSentFrame);
-                return false;
-          }
-           aprintf("[Decoder] Demuxer Frame %"LU" pts=%"LLU" ms, %"LLU" us\n",vid->lastSentFrame,img.demuxerPts/1000,
-                                                                    img.demuxerPts);
-          if(!decompressImage(result,&img,ref))
-          {
-             printf("[DecodePictureUpToIntra] decode error for frame %"LU"\n",vid->lastSentFrame);
-             //cache->dump();
-             cache->invalidate(result);
-             //cache->dump();
-             vid->lastSentFrame++;
-             continue;
-          }else
-            {
-                cache->updateFrameNum(result,vid->lastSentFrame);
-                uint64_t pts=result->Pts;
-                aprintf("[Decoder] Decoder Frame %"LU" pts=%"LLU" ms, %"LLU" us\n",vid->lastSentFrame,
-                                                        result->Pts/1000,result->Pts);
-                if(pts==ADM_COMPRESSED_NO_PTS) // No PTS available ?
-                {
-                   
-                    if(false==syncFound)
-                    {
-                        aprintf("[DecodePictureUpToIntra] No time stamp yet, dropping picture\n");
-                        cache->invalidate(result);
-                    }else
-                    {
-                        // increment it using average fps
-                        vid->lastDecodedPts+=vid->timeIncrementInUs;
-                        result->Pts=vid->lastDecodedPts;
-                    }
-                }else
-                {
-                    if(false==syncFound)
-                    {
-                        aprintf("[DecodePictureUpToIntra] Sync found\n");
-                        syncFound=true;
-                    }
-                    vid->lastDecodedPts=pts;
-                }
-            }
-
-            // Found our image ?
-          if(result->Pts==wantedPts)
-                found=true;
-          else
-                vid->lastSentFrame++;
+        ADM_warning("Cannot go to segment %"LU"\n",s);
+        return false;
     }
-    if(found==false)
+    if(false== DecodePictureUpToIntra(frame,seg->_reference))
     {
-        printf("[GoToIntra] Could not find decoded frame, wanted PTS :%"LU" PTS=%"LLU" ms, %"LLU" us\n",frame,wantedPts/1000,wantedPts);
-        cache->dump();
         return false;
     }
-    vid->lastReadPts=wantedPts;
-    currentFrame=frame;
     return true;
 }
 /**
-    \fn getSamePicture
-    \brief returns the last already decoded picture
-    @param out : Where to put the decoded image to
-    @param ref : Video we are dealing with
-    @return true on success, false on failure
-
+    \fn GoToTime
 */
-bool ADM_Composer::getSamePicture(ADMImage *out,uint32_t ref)
+bool  ADM_Composer::goToTimeVideo(uint64_t startTime)
 {
-    _VIDEOS *vid=_segments.getRefVideo(ref);
-    vidHeader *demuxer=vid->_aviheader;
-	EditorCache   *cache =vid->_videoCache;
-	ADM_assert(cache);
+    return goToIntraTimeVideo(startTime);
 
-  ADMImage *in=cache->getByPts(vid->lastDecodedPts);
-  if(!in)
-  {
-    printf("[ADM_Composer::getSamePicture] Failed\n");
-    return false;
-  }
-  out->duplicate(in);
-  return true;
 }
-
 /**
-    \fn getNextPicture
-    \brief returns the next picture
-    @param out : Where to put the decoded image to
-    @param ref : Video we are dealing with
-    @return true on success, false on failure
-
+    \fn NextPicture
+    \brief decode & returns the next picture
 */
-bool ADM_Composer::getNextPicture(ADMImage *out,uint32_t ref)
+bool        ADM_Composer::nextPicture(ADMImage *image)
 {
-  EditorCache   *cache=_segments.getRefVideo(ref)->_videoCache;
-  ADMImage	*result;
-  _VIDEOS *vid=_segments.getRefVideo(ref);
+uint64_t pts;
+uint64_t tail;
 
-   uint32_t loop=20; // Try 20 frames ahead
-
-	// Try decoding loop? rames ahead, if not we can consider it fails
-    while(loop--)
+    // Decode image...
+    _SEGMENT *seg=_segments.getSegment(_currentSegment);
+    if(false== nextPictureInternal(seg->_reference,image))
     {
-        // first decode a picture, cannot hurt...
-        if(DecodeNextPicture(ref)==false)
+        goto np_nextSeg;
+    }
+        // no we have our image, let's check it is within this segment range..
+        pts=image->Pts;
+        tail=seg->_startTimeUs+seg->_durationUs;
+        if(pts>=tail)
         {
-            printf("[AdmComposer::getPicture] Next picture failed\n");
-            continue;
+                ADM_info("Got an image (%"LU" ms, but is out of this segment (%"LU"+%"LU"=%"LU" ms)\n",
+                                                                    pts,seg->_startTimeUs,seg->_durationUs,tail);
+                goto np_nextSeg;
         }
-        // Search the lowest PTS above our current PTS...
-        ADMImage *img=cache->findJustAfter(vid->lastReadPts);
-        if(img)
+        
+        updateImageTiming(seg,image);
+        return true;
+
+// Try to get an image for the following segment....
+np_nextSeg:
+        if(_currentSegment+1<_segments.getNbSegments())
         {
-            // Duplicate
-            if(out)
+            if(switchToNextSegment()==false)
             {
-                aprintf("[getNextPicture] Looking for after> %"LLU", got %"LLU" delta=%"LD" ms\n",vid->lastReadPts,img->Pts,(img->Pts-vid->lastReadPts)/1000);
-                out->duplicate(img);
-                vid->lastReadPts=img->Pts;
-                currentFrame++;
+                ADM_warning("Cannot get next picture. cannot go to next segment also !\n");
+                return false;
             }
+            ADM_info("Switched to next segment\n");
+            seg=_segments.getSegment(_currentSegment);
+            samePictureInternal(seg->_reference,image);
+            updateImageTiming(seg,image);
             return true;
-        }else   
+        } else  
         {
-            aprintf("[getNextPic] Loop:%d, looking for pts> :%"LLU" ms %"LLU" us\n",loop,vid->lastReadPts/1000,vid->lastReadPts);
-#ifdef VERBOSE
-            cache->dump();
-#endif
-
+                ADM_warning("Cannot get next picture. Last segment\n");
+                return false;
         }
-    }
-    printf("[ADM_Composer::getPicture] Failed\n");
-    printf("[ADM_composer] while looking for %"LLU" us, %"LLU" ms\n",vid->lastReadPts,vid->lastReadPts/1000);
-    cache->dump();
-    return false;
+        return false;
 }
-
 /**
-    \fn DecodeNextPicture
-    \brief Decode the next picture
-
-    @param ref  , video we are dealing with
-    returns true on success
-            fail on error
-
+    \fn samePicture
+    \brief returns the last already decoded picture
 */
-bool ADM_Composer::DecodeNextPicture(uint32_t ref)
+bool        ADM_Composer::samePicture(ADMImage *image)
 {
-uint8_t ret = 0;
-  EditorCache   *cache;
-  ADMImage	*result;
-  uint32_t  flags;
-  ADMCompressedImage img;
-   _VIDEOS *vid=_segments.getRefVideo(ref);
-    vidHeader *demuxer=vid->_aviheader;
-	cache=vid->_videoCache;
-    // PlaceHolder...
-    img.data=compBuffer;
-    img.cleanup(vid->lastSentFrame+1);
-
-	ADM_assert(cache);
-    vid->lastSentFrame++;
-
-    uint32_t frame=vid->lastSentFrame;
-    aprintf("[EditorRender] DecodeNext %u ref:%u\n",frame,ref);
-    // Fetch frame
-     aprintf("[Editor] Decoding frame %u\n",frame);
-     if (!demuxer->getFrame (frame,&img))
-     {
-            printf("[DecodePictureUpToIntra] getFrame failed for frame %"LU"\n",vid->lastSentFrame);
-            return false;
-     }
-
-     // Now uncompress it...
-     result=cache->getFreeImage();
-     if(!result)
-     {
-            printf("[DecodePictureUpToIntra] Cache full for frame %"LU"\n",vid->lastSentFrame);
-            return false;
-      }
-        aprintf("Demuxed frame %"LU" with pts=%"LLD" us, %"LLD" ms\n",
-            frame,
-            img.demuxerPts,
-            img.demuxerPts/1000);
-    
-      if(!decompressImage(result,&img,ref))
-      {
-         printf("[DecodePictureUpToIntra] decode error for frame %"LU"\n",vid->lastSentFrame);
-         cache->invalidate(result);
-         return true; // Not an error in itself
-      }
-     cache->updateFrameNum(result,vid->lastSentFrame);
-     uint64_t pts=result->Pts;
-     uint64_t old=vid->lastDecodedPts;
-        if(pts==ADM_COMPRESSED_NO_PTS) // No PTS available ?
+      _SEGMENT *seg=_segments.getSegment(_currentSegment);
+        if(false== samePictureInternal(seg->_reference,image))
         {
-                aprintf("[Editor] No PTS, guessing value\n");
-                vid->lastDecodedPts+=vid->timeIncrementInUs;
-                result->Pts=vid->lastDecodedPts;
-        }else
-           {
-                aprintf("[Editor] got PTS\n");
-                vid->lastDecodedPts=pts;
-            }
-    aprintf(">>Decoded frame %"LU" with pts=%"LLD" us, %"LLD" ms, ptsdelta=%"LLD" ms \n",
-    frame,
-    vid->lastDecodedPts,
-    vid->lastDecodedPts/1000,
-    (vid->lastDecodedPts-old)/1000);
-    if(old>vid->lastDecodedPts) printf(">>>>> PTS going backward by %"LLD" ms\n",(old-vid->lastDecodedPts)/1000);
-    return true;
-}
-/**
-    \fn decompressImage
-    \brief push an image inside decoder and pop one. Warning the popped one might be an older image due to decoder lag.
-            Also do postprocessing and color conversion
-*/
-bool ADM_Composer::decompressImage(ADMImage *out,ADMCompressedImage *in,uint32_t ref)
-{
- ADMImage *tmpImage=NULL;
- uint32_t ww,hh,left,right;
- _VIDEOS *v=_segments.getRefVideo(ref);
- uint32_t refOnly=v->decoder->dontcopy(); // can we skip one memcpy ?
-// This is only an empty Shell
-    if(refOnly)
-    {
-                uint32_t w,h;
-                if(_scratch) // Can we reuse the old scratch memory ?
-                {
-                    _scratch->getWidthHeight(&w,&h);
-                    if(w!=_imageBuffer->_width || _imageBuffer->_height!=h)
-                    {
-                        delete _scratch;
-                        _scratch=NULL;
-                    }
-                }
-                if(!_scratch)
-                {
-                  _scratch=new ADMImage(_imageBuffer->_width,_imageBuffer->_height,1);
-                }
-                tmpImage=_scratch;
-                ww=_imageBuffer->_width & 0xfffff0;
-                left=_imageBuffer->_width & 0xf;
-
-        }
-        else
-        {
-                tmpImage=_imageBuffer;
-                ww=_imageBuffer->_width;
-                left=0;
-       }
-    //
-    tmpImage->_colorspace=ADM_COLOR_YV12;
-	// Decode it
-        if (!v->decoder->uncompress (in, tmpImage))
-	    {
-            printf("[decompressImage] uncompress failed\n");
+            ADM_warning("SamePicture failed\n");
             return false;
         }
-
-        //
-        if(tmpImage->_noPicture && refOnly)
-        {
-            printf("[decompressImage] NoPicture\n");
-            // Fill in with black
-            return true;
-        }
-        aprintf("[::Decompress] in:%"LU" out:%"LU" flags:%x\n",in->demuxerPts,out->Pts,out->flags);
-	// If not quant and it is already YV12, we can stop here
-	if((!tmpImage->quant || !tmpImage->_qStride) && tmpImage->_colorspace==ADM_COLOR_YV12)
-	{
-		out->_Qp=2;
-		out->duplicate(tmpImage);
-		aprintf("[decompressImage] : No quant avail\n");
-		return true;
-	}
-	// We got everything, let's go
-	// 1 compute average quant
-	int qz;
-	uint32_t sumit=0;
-    // Dupe infos
-    out->copyInfo(tmpImage);
-
-
-        // Do postprocessing if any
-	for(uint32_t z=0;z<tmpImage->_qSize;z++)
-	{
-            qz=(int)tmpImage->quant[z];
-			sumit+=qz;
-	}
-	sumit+=(tmpImage->_qSize-1);
-	float sum=(float)sumit;
-	sum/=tmpImage->_qSize;
-	if(sum>31) sum=31;
-	if(sum<1) sum=1;
-
-        // update average Q
-	tmpImage->_Qp=out->_Qp=(uint32_t)floor(sum);
-
-	// Pp deactivated ?
-	if(!_pp.postProcType || !_pp.postProcStrength || tmpImage->_colorspace!=ADM_COLOR_YV12)
-    {
-        dupe(tmpImage,out,v);
-        aprintf("EdCache: Postproc disabled\n");
-		return 1;
-	}
-
-	int type;
-	#warning FIXME should be FF_I_TYPE/B/P
-	if(tmpImage->flags & AVI_KEY_FRAME) type=1;
-		else if(tmpImage->flags & AVI_B_FRAME) type=3;
-			else type=2;
-
-        ADM_assert(tmpImage->_colorspace==ADM_COLOR_YV12);
-
-	// we do postproc !
-	// keep
-	uint8_t *oBuff[3];
-	const uint8_t *iBuff[3];
-	int	strideTab[3];
-	int	strideTab2[3];
-	aviInfo _info;
-
-        getVideoInfo(&_info);
-        if(refOnly)
-        {
-                iBuff[0]= tmpImage->_planes[0];
-                iBuff[1]= tmpImage->_planes[1];
-                iBuff[2]= tmpImage->_planes[2];
-
-                strideTab2[0]=_info.width;
-                strideTab2[1]=_info.width>>1;
-                strideTab2[2]=_info.width>>1;
-
-                strideTab[0]=tmpImage->_planeStride[0];
-                strideTab[1]=tmpImage->_planeStride[1];
-                strideTab[2]=tmpImage->_planeStride[2];
-
-        }
-        else
-        {
-                iBuff[0]= YPLANE((tmpImage));
-                iBuff[1]= UPLANE((tmpImage));
-                iBuff[2]= VPLANE((tmpImage));
-
-                strideTab[0]=strideTab2[0]=_info.width;
-                strideTab[1]=strideTab2[1]=_info.width>>1;
-                strideTab[2]=strideTab2[2]=_info.width>>1;
-        }
-        if(_pp.swapuv)
-        {
-                oBuff[0]= YPLANE(out);
-                oBuff[1]= VPLANE(out);
-                oBuff[2]= UPLANE(out);
-        }else
-        {
-
-                oBuff[0]= YPLANE(out);
-                oBuff[1]= UPLANE(out);
-                oBuff[2]= VPLANE(out);
-        }
-        pp_postprocess(
-            iBuff,
-            strideTab,
-            oBuff,
-            strideTab2,
-            ww,
-            _info.height,
-            (int8_t *)(tmpImage->quant),
-            tmpImage->_qStride,
-            _pp.ppMode,
-            _pp.ppContext,
-            type);			// img type
-        /*
-                If there is a chroma block that needs padding
-                (width not multiple of 16) while postprocessing,
-                we process up to the nearest 16 multiple and
-                just copy luma & chroma info that was left over
-        */
-        if(refOnly && left)
-        {
-                uint8_t *src,*dst;
-                uint32_t stridein,strideout,right;
-                right=_info.width-left;
-                // Luma
-                dst=YPLANE(out)+right;
-                src=tmpImage->_planes[0]+right;
-                stridein=tmpImage->_planeStride[0];
-                strideout=_info.width;
-                for(uint32_t y=_info.height;y>0;y--)
-                {
-                        memcpy(dst,src,left);
-                        dst+=strideout;
-                        src+=stridein;
-                }
-                // Chroma
-                left>>=1;
-                right>>=1;
-                //
-                dst=UPLANE(out)+right;
-                src=tmpImage->_planes[1]+right;
-                stridein=tmpImage->_planeStride[1];
-                strideout=_info.width>>1;
-                for(uint32_t y=_info.height>>1;y>0;y--)
-                {
-                        memcpy(dst,src,left);
-                        dst+=strideout;
-                        src+=stridein;
-                }
-                //
-                dst=VPLANE(out)+right;
-                src=tmpImage->_planes[2]+right;
-                stridein=tmpImage->_planeStride[2];
-                strideout=_info.width>>1;
-                for(uint32_t y=_info.height>>1;y>0;y--)
-                {
-                        memcpy(dst,src,left);
-                        dst+=strideout;
-                        src+=stridein;
-                }
-
-
-        }
-    return true;
+         updateImageTiming(seg,image);
+        return true;
 }
 
-
-
 /**
-    \fn decodeCache
-    \brief Decode an image an update cache
+        \fn getCompressedPicture
+        \brief bypass decoder and directly get the source image
 
 */
-
-uint8_t		ADM_Composer::decodeCache(uint32_t frame,uint32_t seg, ADMImage *image)
+bool        ADM_Composer::getCompressedPicture(ADMCompressedImage *img)
 {
+    uint64_t tail;
+    //
+    _SEGMENT *seg=_segments.getSegment(_currentSegment);
+    ADM_assert(seg);
+    _VIDEOS *vid=_segments.getRefVideo(seg->_reference);
+    ADM_assert(vid);
+    vidHeader *demuxer=vid->_aviheader;
+    ADM_assert(demuxer);
 
-uint32_t sumit;
-float	 sum;
+    // Get next pic?
+    if(false==demuxer->getFrame (seg->_curFrame,img))
+    {
+        ADM_info("Failed to get next frame for ref %"LU"\n",seg->_reference);
+        goto nextSeg;
+    }
+    seg->_curFrame++;
+    // Need to switch seg ?
+    tail=seg->_refStartTimeUs+seg->_durationUs;
+    if(img->demuxerDts!= ADM_NO_PTS && img->demuxerDts>tail) goto nextSeg;
+    if(img->demuxerPts!= ADM_NO_PTS && img->demuxerPts>tail) goto nextSeg;
+    {
+    // Recalibrate PTS & DTS...
+    int64_t offset=seg->_refStartTimeUs;
+    offset=seg->_startTimeUs;
+    recalibrate(&(img->demuxerPts),seg);
+    recalibrate(&(img->demuxerDts),seg);
+    }
+    return true;
 
-uint32_t ref,refOffset;
-
-        if(false==_segments.getRefFromFrame(frame,&ref,&refOffset))
-        {
-            ADM_warning("[decodeCache] Cannot get ref for frame %"LD"\n",frame);
-            return false;
-        }
-
-
-_VIDEOS *v=_segments.getRefVideo(ref); // FIXME!!!!
-EditorCache *cache=v->_videoCache;
-ADMImage *tmpImage=NULL;
-uint8_t refOnly=0;
-uint32_t left,ww;
-ADMCompressedImage img;
-
-        aprintf("decodeCache : original :%"LD" Frame in ref %"LD"\n",frame,refOffset);
-        img.data=compBuffer;
-        img.cleanup(frame);
-        // Step 1, retrieve the compressed datas, including PTS & DTS infos
-         if (!v->_aviheader->getFrame (refOffset,&img))
-        {
-          ADM_warning ("Editor: last decoding failed.%"LD")\n",   refOffset );
-          return 0;
-        }
-        ADM_assert(_imageBuffer);
-
-        // if len is 0 then take the previous image
-        //
-
-        refOnly=v->decoder->dontcopy(); // can we skip one memcpy ?
-
-        if(!img.dataLength & refOnly & !refOffset)      // Size is null = no image and we only got a pointer
-                                // copy the previous one
-        {
-                // First image
-
-                uint32_t page=_imageBuffer->_width*_imageBuffer->_height;
-                        memset(YPLANE(image),0,page);
-                        memset(UPLANE(image),128,page>>2);
-                        memset(VPLANE(image),128,page>>2);
-                        if(!refOffset)
-                                image->flags=AVI_KEY_FRAME;
-                        else
-                                image->flags=AVI_P_FRAME;
-                        image->_Qp=2;
-                        image->_qStride=0;
-                        return 1;
-        }
-
-        if(refOnly)
-        {       // This is only an empty Shell
-                uint32_t w,h;
-                if(_scratch) // Can we reuse the old scratch memory ?
-                {
-                    _scratch->getWidthHeight(&w,&h);
-                    if(w!=_imageBuffer->_width || _imageBuffer->_height!=h)
-                    {
-                        delete _scratch;
-                        _scratch=NULL;
-                    }
-                }
-                if(!_scratch)
-                {
-                  _scratch=new ADMImage(_imageBuffer->_width,_imageBuffer->_height,1);
-                }
-                tmpImage=_scratch;
-                ww=_imageBuffer->_width & 0xfffff0;
-                left=_imageBuffer->_width & 0xf;
-
-        }
-        else
-        {
-                tmpImage=_imageBuffer;
-                ww=_imageBuffer->_width;
-                left=0;
-       }
-	tmpImage->_colorspace=ADM_COLOR_YV12;
-	// Do pp, and use imageBuffer as intermediate buffer
-	if (!v->decoder->uncompress (&img, tmpImage))
-	    {
-	      printf ("\nEditor: Last Decoding2 failed for frame %"LU"\n",refOffset);
-	       // Try to dupe previous frame
-                if(refOffset)
-                {
-                        ADMImage *prev;
-                        prev=cache->getImage(refOffset-1);
-                        if(prev)
-                        {
-                                image->duplicate(prev);
-                                cache->updateFrameNum(image,refOffset);
-                                return 1;
-                        }
-                }
-                goto _next;
-           }
-
-        //
-        if(tmpImage->_noPicture && refOnly && refOffset)
-        {
-                cache->updateFrameNum(image,0xffffffffU);
-                return 0;
-        }
-	// If not quant and it is already YV12, we can stop here
-	if((!tmpImage->quant || !tmpImage->_qStride) && tmpImage->_colorspace==ADM_COLOR_YV12)
-	{
-		image->_Qp=2;
-		image->duplicate(tmpImage);
-		cache->updateFrameNum(image,refOffset);
-          //      if(refOnly) delete tmpImage;
-		aprintf("EdCache: No quant avail\n");
-		return 1;
-	}
-	// We got everything, let's go
-	// 1 compute average quant
-	int qz;
-	sumit=0;
-        // Dupe infos
-        image->copyInfo(tmpImage);
-
-
-        // Do postprocessing if any
-	for(uint32_t z=0;z<tmpImage->_qSize;z++)
-	{
-            qz=(int)tmpImage->quant[z];
-			sumit+=qz;
-	}
-	sumit+=(tmpImage->_qSize-1);
-//	sumit*=2;
-	sum=(float)sumit;
-	sum/=tmpImage->_qSize;
-	if(sum>31) sum=31;
-	if(sum<1) sum=1;
-
-        // update average Q
-	tmpImage->_Qp=image->_Qp=(uint32_t)floor(sum);
-
-	// Pp deactivated ?
-	if(!_pp.postProcType || !_pp.postProcStrength || tmpImage->_colorspace!=ADM_COLOR_YV12)
-     {
-        dupe(tmpImage,image,v);
-		cache->updateFrameNum(image,refOffset);
-               // if(refOnly) delete tmpImage;
-		aprintf("EdCache: Postproc disabled\n");
-		return 1;
-	}
-
-	int type;
-	#warning FIXME should be FF_I_TYPE/B/P
-	if(tmpImage->flags & AVI_KEY_FRAME) type=1;
-		else if(tmpImage->flags & AVI_B_FRAME) type=3;
-			else type=2;
-
-        ADM_assert(tmpImage->_colorspace==ADM_COLOR_YV12);
-
-	// we do postproc !
-	// keep
-	uint8_t *oBuff[3];
-	const uint8_t *iBuff[3];
-	int	strideTab[3];
-	int	strideTab2[3];
-	aviInfo _info;
-
-		getVideoInfo(&_info);
-                if(refOnly)
-                {
-                        iBuff[0]= tmpImage->_planes[0];
-                        iBuff[1]= tmpImage->_planes[1];
-                        iBuff[2]= tmpImage->_planes[2];
-
-                        strideTab2[0]=_info.width;
-                        strideTab2[1]=_info.width>>1;
-                        strideTab2[2]=_info.width>>1;
-
-                        strideTab[0]=tmpImage->_planeStride[0];
-                        strideTab[1]=tmpImage->_planeStride[1];
-                        strideTab[2]=tmpImage->_planeStride[2];
-
-                }
-                else
-                {
-		        iBuff[0]= YPLANE((tmpImage));
-                iBuff[1]= UPLANE((tmpImage));
-                iBuff[2]= VPLANE((tmpImage));
-
-
-
-                        strideTab[0]=strideTab2[0]=_info.width;
-                        strideTab[1]=strideTab2[1]=_info.width>>1;
-                        strideTab[2]=strideTab2[2]=_info.width>>1;
-                }
-                if(_pp.swapuv)
-                {
-        	        oBuff[0]= YPLANE(image);
-                        oBuff[1]= VPLANE(image);
-                        oBuff[2]= UPLANE(image);
-                }else
-                {
-
-                        oBuff[0]= YPLANE(image);
-                        oBuff[1]= UPLANE(image);
-                        oBuff[2]= VPLANE(image);
-                }
-		 pp_postprocess(
-		 		iBuff,
-		 		strideTab,
-		 		oBuff,
-		 		strideTab2,
-		 		ww,
-		        	_info.height,
-		          	(int8_t *)(tmpImage->quant),
-		          	tmpImage->_qStride,
-		         	_pp.ppMode,
-		          	_pp.ppContext,
-		          	type);			// img type
-                /*
-                        If there is a chroma block that needs padding
-                        (width not multiple of 16) while postprocessing,
-                        we process up to the nearest 16 multiple and
-                        just copy luma & chroma info that was left over
-                */
-                if(refOnly && left)
-                {
-                        uint8_t *src,*dst;
-                        uint32_t stridein,strideout,right;
-                        right=_info.width-left;
-                        // Luma
-                        dst=YPLANE(image)+right;
-                        src=tmpImage->_planes[0]+right;
-                        stridein=tmpImage->_planeStride[0];
-                        strideout=_info.width;
-                        for(uint32_t y=_info.height;y>0;y--)
-                        {
-                                memcpy(dst,src,left);
-                                dst+=strideout;
-                                src+=stridein;
-                        }
-                        // Chroma
-                        left>>=1;
-                        right>>=1;
-                        //
-                        dst=UPLANE(image)+right;
-                        src=tmpImage->_planes[1]+right;
-                        stridein=tmpImage->_planeStride[1];
-                        strideout=_info.width>>1;
-                        for(uint32_t y=_info.height>>1;y>0;y--)
-                        {
-                                memcpy(dst,src,left);
-                                dst+=strideout;
-                                src+=stridein;
-                        }
-                        //
-                        dst=VPLANE(image)+right;
-                        src=tmpImage->_planes[2]+right;
-                        stridein=tmpImage->_planeStride[2];
-                        strideout=_info.width>>1;
-                        for(uint32_t y=_info.height>>1;y>0;y--)
-                        {
-                                memcpy(dst,src,left);
-                                dst+=strideout;
-                                src+=stridein;
-                        }
-
-
-                }
-_next:
-        // update some infos
-        //   if(refOnly) delete tmpImage;
-		cache->updateFrameNum(image,refOffset);
-		aprintf("EdCache: Postproc done\n");
-		return 1;
+nextSeg:
+    if(false==switchToNextSegment())
+    {
+        ADM_warning("Cannot update to new segment\n");
+        return false;
+    }
+    ADM_info("Retrying for next segment\n");
+    return getCompressedPicture(img);
+   
 }
+
 /**
         \fn dupe
 */
@@ -950,63 +257,62 @@
 	*swapuv=_pp.swapuv;
 	return 1;
 }
+/**
+    \fn switchToNextSegment
+    \brief Switch to the next segment
 
-
-#if 0
-uint8_t	ADM_Composer::isReordered( uint32_t framenum )
+*/
+bool        ADM_Composer::switchToNextSegment(void)
 {
-uint32_t seg,relframe;
- if (!convFrame2Seg (framenum, &seg, &relframe))
+    if(_currentSegment==_segments.getNbSegments()-1)
     {
-      printf ("\n Conversion failed !\n");
-      return 0;
+        ADM_warning("This is the last segment (%"LU")\n",_currentSegment);
+        return false;
     }
-    uint32_t ref=_segments[seg]._reference;
-   return _videos[ref]._aviheader->isReordered();
+    if(true==switchToSegment(_currentSegment+1)) return true;
+    return false;
 }
-#endif
 /**
-    \fn getCurrentFrame
+    \fn switchToSegment
+    \brief Switch to the segment given as argument
+
 */
-uint32_t    ADM_Composer::getCurrentFrame(void)
+bool        ADM_Composer::switchToSegment(uint32_t s)
 {
-    return currentFrame;
-}
-/**
-    \fn setCurrentFrame
-*/
-bool        ADM_Composer::setCurrentFrame(uint32_t frame)
-{
-    // Seatch previous keyFrame
-    printf("[setCurrentFrame] >>> REQ for frame %"LU"\n",frame);
-    uint32_t keyFrame=frame,f;
-    while(keyFrame)
+    if(s+1>_segments.getNbSegments())
     {
-        if(getFlags(keyFrame,&f))
-        {
-            if(f&AVI_KEY_FRAME) break;
-        }
-        keyFrame--;
-    }
-    printf("[setCurrentFrame] >>> Prev KeyFrame %"LU"\n",keyFrame);
-    if(false==GoToIntra(keyFrame))
-    {
-        printf("[setCurrentFrame] GoToIntra failed for frame %u\n",keyFrame);
+        ADM_warning("Cannot switch to segment:%"LU"\n",s);
         return false;
     }
-    //Now go forward
-    uint32_t mx=frame-keyFrame;
-    uint32_t i=0;
-    for(i=0;i<mx;i++)
+    _SEGMENT *seg=_segments.getSegment(s);
+    ADM_assert(seg);
+    ADM_info("Switching to seg %"LU" with startTime in reference pic= %"LU" ms\n",s,seg->_refStartTimeUs/1000);
+    // Search the previous keyframe for segment....
+    uint64_t seekTime;
+    if(_segments.isKeyFrameByTime(seg->_reference,seg->_refStartTimeUs))
     {
-        if(NextPicture(NULL) ==false)
+        seekTime=seg->_refStartTimeUs;
+        ADM_info("First frame of the new segment is a keyframe at %"LU"ms\n",seekTime/1000);
+    }else   
+    {
+        if(false==searchPreviousKeyFrameInRef(seg->_reference,seg->_refStartTimeUs,&seekTime))
         {
+            ADM_warning("Cannot identify the keyframe before %"LLU" ms\n",seekTime/1000);
             return false;
         }
     }
+    // ok now seek...
+    uint32_t frame=_segments.intraTimeToFrame(seg->_reference,seekTime);
+    if(false==DecodePictureUpToIntra(frame,seg->_reference))
+    {
+        return false;
+    }
+    // Now forward to the frame we want...
+#warning TODO do not seek only on intra
+    _VIDEOS *ref=_segments.getRefVideo(seg->_reference);
+    seg->_curFrame=ref->lastSentFrame;
     return true;
 }
 
 
-
 //EOF

Copied: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRenderInternal.cpp (from rev 5391, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp	2009-10-20 13:26:46 UTC (rev 5391)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRenderInternal.cpp	2009-10-20 13:26:48 UTC (rev 5392)
@@ -0,0 +1,813 @@
+/***************************************************************************
+    \file  ADM_edRenderInternal.cpp  
+    \brief handle decoding from ONE source, ignoring the segments
+    \author mean (c) 2002/2009 fixounet at free.fr
+
+    
+
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include <math.h>
+#include "ADM_default.h"
+#include "ADM_editor/ADM_edit.hxx"
+
+#if defined(ADM_DEBUG) && 0
+#define aprintf printf
+#else
+#define aprintf(...) {}// printf
+#endif
+
+#include "ADM_pp.h"
+
+// FIXME BADLY !!!
+// This should be in a context somewhere
+static uint8_t compBuffer[MAXIMUM_SIZE * MAXIMUM_SIZE * 3];
+
+
+/**
+    \fn samePictureInternal
+    \brief returns the last already decoded picture
+    @param out : Where to put the decoded image to
+    @param ref : Video we are dealing with
+    @return true on success, false on failure
+
+*/
+bool ADM_Composer::samePictureInternal(uint32_t ref,ADMImage *out)
+{
+    _VIDEOS *vid=_segments.getRefVideo(ref);
+    vidHeader *demuxer=vid->_aviheader;
+	EditorCache   *cache =vid->_videoCache;
+	ADM_assert(cache);
+
+  ADMImage *in=cache->getByPts(vid->lastDecodedPts);
+  if(!in)
+  {
+    printf("[ADM_Composer::getSamePicture] Failed, while looking for Pts=%"LU" ms\n",vid->lastDecodedPts);
+    cache->dump();
+    return false;
+  }
+  out->duplicate(in);
+  return true;
+}
+
+/**
+    \fn nextPictureInternal
+    \brief returns the next picture
+    @param out : Where to put the decoded image to
+    @param ref : Video we are dealing with
+    @return true on success, false on failure
+
+*/
+bool ADM_Composer::nextPictureInternal(uint32_t ref,ADMImage *out)
+{
+  ADMImage	*result;
+  EditorCache   *cache=_segments.getRefVideo(ref)->_videoCache;
+  _VIDEOS *vid=_segments.getRefVideo(ref);
+
+  ADM_assert(vid);
+
+   uint32_t loop=20; // Try 20 frames ahead
+
+	// Try decoding loop rames ahead, if not we can consider it fails
+    while(loop--)
+    {
+        // first decode a picture, cannot hurt...
+        if(DecodeNextPicture(ref)==false)
+        {
+            ADM_warning("Next picture failed\n");
+            continue;
+        }
+        // Search the lowest PTS above our current PTS...
+        ADMImage *img=cache->findJustAfter(vid->lastReadPts);
+        if(img)
+        {
+            // Duplicate
+            if(out)
+            {
+                aprintf("[getNextPicture] Looking for after> %"LLU", got %"LLU" delta=%"LD" ms\n",vid->lastReadPts,img->Pts,(img->Pts-vid->lastReadPts)/1000);
+                out->duplicate(img);
+                vid->lastReadPts=img->Pts;
+                currentFrame++;
+            }
+            return true;
+        }else   
+        {
+            aprintf("[getNextPic] Loop:%d, looking for pts> :%"LLU" ms %"LLU" us\n",loop,vid->lastReadPts/1000,vid->lastReadPts);
+#ifdef VERBOSE
+            cache->dump();
+#endif
+
+        }
+    }
+    ADM_warning("nextPictureInternal Failed\n");
+    ADM_warning("while looking for %"LLU" us, %"LLU" ms\n",vid->lastReadPts,vid->lastReadPts/1000);
+    cache->dump();
+    return false;
+}
+
+/**
+    \fn DecodeNextPicture
+    \brief Decode the next picture
+
+    @param ref  , video we are dealing with
+    returns true on success
+            fail on error
+
+*/
+bool ADM_Composer::DecodeNextPicture(uint32_t ref)
+{
+uint8_t ret = 0;
+  EditorCache   *cache;
+  ADMImage	*result;
+  uint32_t  flags;
+  ADMCompressedImage img;
+   _VIDEOS *vid=_segments.getRefVideo(ref);
+    vidHeader *demuxer=vid->_aviheader;
+	cache=vid->_videoCache;
+    // PlaceHolder...
+    img.data=compBuffer;
+    img.cleanup(vid->lastSentFrame+1);
+
+	ADM_assert(cache);
+    vid->lastSentFrame++;
+
+    uint32_t frame=vid->lastSentFrame;
+    aprintf("[EditorRender] DecodeNext %u ref:%u\n",frame,ref);
+    // Fetch frame
+     aprintf("[Editor] Decoding frame %u\n",frame);
+     if (!demuxer->getFrame (frame,&img))
+     {
+            ADM_warning("getFrame failed for frame %"LU"\n",vid->lastSentFrame);
+            return false;
+     }
+
+     // Now uncompress it...
+     result=cache->getFreeImage();
+     if(!result)
+     {
+            ADM_warning(" Cache full for frame %"LU"\n",vid->lastSentFrame);
+            return false;
+      }
+        aprintf("Demuxed frame %"LU" with pts=%"LLD" us, %"LLD" ms\n",
+            frame,
+            img.demuxerPts,
+            img.demuxerPts/1000);
+    
+      if(!decompressImage(result,&img,ref))
+      {
+         ADM_warning("Decoding error for frame %"LU"\n",vid->lastSentFrame);
+         cache->invalidate(result);
+         return true; // Not an error in itself
+      }
+     cache->updateFrameNum(result,vid->lastSentFrame);
+     uint64_t pts=result->Pts;
+     uint64_t old=vid->lastDecodedPts;
+        if(pts==ADM_COMPRESSED_NO_PTS) // No PTS available ?
+        {
+                aprintf("[Editor] No PTS, guessing value\n");
+                vid->lastDecodedPts+=vid->timeIncrementInUs;
+                result->Pts=vid->lastDecodedPts;
+        }else
+           {
+                aprintf("[Editor] got PTS\n");
+                vid->lastDecodedPts=pts;
+            }
+    aprintf(">>Decoded frame %"LU" with pts=%"LLD" us, %"LLD" ms, ptsdelta=%"LLD" ms \n",
+    frame,
+    vid->lastDecodedPts,
+    vid->lastDecodedPts/1000,
+    (vid->lastDecodedPts-old)/1000);
+    if(old>vid->lastDecodedPts) ADM_warning(">>>>> PTS going backward by %"LLD" ms\n",(old-vid->lastDecodedPts)/1000);
+    return true;
+}
+
+
+/**
+    \fn decompressImage
+    \brief push an image inside decoder and pop one. Warning the popped one might be an older image due to decoder lag.
+            Also do postprocessing and color conversion
+*/
+bool ADM_Composer::decompressImage(ADMImage *out,ADMCompressedImage *in,uint32_t ref)
+{
+ ADMImage *tmpImage=NULL;
+ uint32_t ww,hh,left,right;
+ _VIDEOS *v=_segments.getRefVideo(ref);
+ uint32_t refOnly=v->decoder->dontcopy(); // can we skip one memcpy ?
+// This is only an empty Shell
+    if(refOnly)
+    {
+                uint32_t w,h;
+                if(_scratch) // Can we reuse the old scratch memory ?
+                {
+                    _scratch->getWidthHeight(&w,&h);
+                    if(w!=_imageBuffer->_width || _imageBuffer->_height!=h)
+                    {
+                        delete _scratch;
+                        _scratch=NULL;
+                    }
+                }
+                if(!_scratch)
+                {
+                  _scratch=new ADMImage(_imageBuffer->_width,_imageBuffer->_height,1);
+                }
+                tmpImage=_scratch;
+                ww=_imageBuffer->_width & 0xfffff0;
+                left=_imageBuffer->_width & 0xf;
+
+        }
+        else
+        {
+                tmpImage=_imageBuffer;
+                ww=_imageBuffer->_width;
+                left=0;
+       }
+    //
+    tmpImage->_colorspace=ADM_COLOR_YV12;
+	// Decode it
+        if (!v->decoder->uncompress (in, tmpImage))
+	    {
+            printf("[decompressImage] uncompress failed\n");
+            return false;
+        }
+
+        //
+        if(tmpImage->_noPicture && refOnly)
+        {
+            printf("[decompressImage] NoPicture\n");
+            // Fill in with black
+            return true;
+        }
+        aprintf("[::Decompress] in:%"LU" out:%"LU" flags:%x\n",in->demuxerPts,out->Pts,out->flags);
+	// If not quant and it is already YV12, we can stop here
+	if((!tmpImage->quant || !tmpImage->_qStride) && tmpImage->_colorspace==ADM_COLOR_YV12)
+	{
+		out->_Qp=2;
+		out->duplicate(tmpImage);
+		aprintf("[decompressImage] : No quant avail\n");
+		return true;
+	}
+	// We got everything, let's go
+	// 1 compute average quant
+	int qz;
+	uint32_t sumit=0;
+    // Dupe infos
+    out->copyInfo(tmpImage);
+
+
+        // Do postprocessing if any
+	for(uint32_t z=0;z<tmpImage->_qSize;z++)
+	{
+            qz=(int)tmpImage->quant[z];
+			sumit+=qz;
+	}
+	sumit+=(tmpImage->_qSize-1);
+	float sum=(float)sumit;
+	sum/=tmpImage->_qSize;
+	if(sum>31) sum=31;
+	if(sum<1) sum=1;
+
+        // update average Q
+	tmpImage->_Qp=out->_Qp=(uint32_t)floor(sum);
+
+	// Pp deactivated ?
+	if(!_pp.postProcType || !_pp.postProcStrength || tmpImage->_colorspace!=ADM_COLOR_YV12)
+    {
+        dupe(tmpImage,out,v);
+        aprintf("EdCache: Postproc disabled\n");
+		return 1;
+	}
+
+	int type;
+	#warning FIXME should be FF_I_TYPE/B/P
+	if(tmpImage->flags & AVI_KEY_FRAME) type=1;
+		else if(tmpImage->flags & AVI_B_FRAME) type=3;
+			else type=2;
+
+        ADM_assert(tmpImage->_colorspace==ADM_COLOR_YV12);
+
+	// we do postproc !
+	// keep
+	uint8_t *oBuff[3];
+	const uint8_t *iBuff[3];
+	int	strideTab[3];
+	int	strideTab2[3];
+	aviInfo _info;
+
+        getVideoInfo(&_info);
+        if(refOnly)
+        {
+                iBuff[0]= tmpImage->_planes[0];
+                iBuff[1]= tmpImage->_planes[1];
+                iBuff[2]= tmpImage->_planes[2];
+
+                strideTab2[0]=_info.width;
+                strideTab2[1]=_info.width>>1;
+                strideTab2[2]=_info.width>>1;
+
+                strideTab[0]=tmpImage->_planeStride[0];
+                strideTab[1]=tmpImage->_planeStride[1];
+                strideTab[2]=tmpImage->_planeStride[2];
+
+        }
+        else
+        {
+                iBuff[0]= YPLANE((tmpImage));
+                iBuff[1]= UPLANE((tmpImage));
+                iBuff[2]= VPLANE((tmpImage));
+
+                strideTab[0]=strideTab2[0]=_info.width;
+                strideTab[1]=strideTab2[1]=_info.width>>1;
+                strideTab[2]=strideTab2[2]=_info.width>>1;
+        }
+        if(_pp.swapuv)
+        {
+                oBuff[0]= YPLANE(out);
+                oBuff[1]= VPLANE(out);
+                oBuff[2]= UPLANE(out);
+        }else
+        {
+
+                oBuff[0]= YPLANE(out);
+                oBuff[1]= UPLANE(out);
+                oBuff[2]= VPLANE(out);
+        }
+        pp_postprocess(
+            iBuff,
+            strideTab,
+            oBuff,
+            strideTab2,
+            ww,
+            _info.height,
+            (int8_t *)(tmpImage->quant),
+            tmpImage->_qStride,
+            _pp.ppMode,
+            _pp.ppContext,
+            type);			// img type
+        /*
+                If there is a chroma block that needs padding
+                (width not multiple of 16) while postprocessing,
+                we process up to the nearest 16 multiple and
+                just copy luma & chroma info that was left over
+        */
+        if(refOnly && left)
+        {
+                uint8_t *src,*dst;
+                uint32_t stridein,strideout,right;
+                right=_info.width-left;
+                // Luma
+                dst=YPLANE(out)+right;
+                src=tmpImage->_planes[0]+right;
+                stridein=tmpImage->_planeStride[0];
+                strideout=_info.width;
+                for(uint32_t y=_info.height;y>0;y--)
+                {
+                        memcpy(dst,src,left);
+                        dst+=strideout;
+                        src+=stridein;
+                }
+                // Chroma
+                left>>=1;
+                right>>=1;
+                //
+                dst=UPLANE(out)+right;
+                src=tmpImage->_planes[1]+right;
+                stridein=tmpImage->_planeStride[1];
+                strideout=_info.width>>1;
+                for(uint32_t y=_info.height>>1;y>0;y--)
+                {
+                        memcpy(dst,src,left);
+                        dst+=strideout;
+                        src+=stridein;
+                }
+                //
+                dst=VPLANE(out)+right;
+                src=tmpImage->_planes[2]+right;
+                stridein=tmpImage->_planeStride[2];
+                strideout=_info.width>>1;
+                for(uint32_t y=_info.height>>1;y>0;y--)
+                {
+                        memcpy(dst,src,left);
+                        dst+=strideout;
+                        src+=stridein;
+                }
+
+
+        }
+    return true;
+}
+
+/**
+    \fn DecodePictureUpToIntra
+    \brief Decode pictures from frameno, which must be an intra and on
+            until the decoded frameno is popped by the decoder
+
+    @param frame, framenumber relative to video ref (i.e. from its beginning)
+    @param ref  , video we are dealing with
+    returns true on success
+            fail on error
+
+*/
+bool ADM_Composer::DecodePictureUpToIntra(uint32_t ref,uint32_t frame)
+{
+  uint8_t ret = 0;
+  EditorCache   *cache;
+  ADMImage	*result;
+  uint32_t  flags;
+  ADMCompressedImage img;
+
+    // PlaceHolder...
+    img.data=compBuffer;
+    img.cleanup(frame);
+
+    ADM_info(" DecodeUpToInta %u ref:%u\n",frame,ref);
+	_VIDEOS *vid=_segments.getRefVideo(ref);
+    vidHeader *demuxer=vid->_aviheader;
+	cache=vid->_videoCache;
+	ADM_assert(cache);
+    // Make sure frame is an intra
+    demuxer->getFlags(frame,&flags);
+    ADM_assert(flags==AVI_KEY_FRAME);
+
+    bool found=false;
+    vid->lastSentFrame=frame;
+    uint32_t nbFrames=vid->_nb_video_frames;
+    aprintf("[EditorRender] DecodeUpToIntra flushing cache & codec\n");
+    cache->flush();
+    vid->decoder->flush();
+    // The PTS associated with our frame is the one we are looking for
+    uint64_t wantedPts=demuxer->estimatePts(frame);
+    uint32_t tries=15+7; // Max Ref frames for H264 + MaxRecovery , let's say 7 is ok for recovery
+    bool syncFound=false;
+    while(found==false && tries--)
+    {
+        // Last frame ? if so repeat
+        if(vid->lastSentFrame>=nbFrames-1) vid->lastSentFrame=nbFrames-1;
+        // Fetch frame
+         aprintf("[Editor] Decoding  frame %u\n",vid->lastSentFrame);
+         
+         if (!demuxer->getFrame (vid->lastSentFrame,&img))
+         {
+                ADM_warning(" getFrame failed for frame %"LU"\n",vid->lastSentFrame);
+                //cache->flush();
+                return false;
+         }
+         // Now uncompress it...
+         result=cache->getFreeImage();
+         if(frame==0) // out first frame, make sure it starts black to avoid the all green effect
+         {
+            result->blacken();
+         }
+         if(!result)
+         {
+                ADM_warning(" Cache full for frame %"LU"\n",vid->lastSentFrame);
+                return false;
+          }
+           aprintf("[Decoder] Demuxer Frame %"LU" pts=%"LLU" ms, %"LLU" us\n",vid->lastSentFrame,img.demuxerPts/1000,
+                                                                    img.demuxerPts);
+          if(!decompressImage(result,&img,ref))
+          {
+             ADM_warning(" decode error for frame %"LU"\n",vid->lastSentFrame);
+             //cache->dump();
+             cache->invalidate(result);
+             //cache->dump();
+             vid->lastSentFrame++;
+             continue;
+          }else
+            {
+                cache->updateFrameNum(result,vid->lastSentFrame);
+                uint64_t pts=result->Pts;
+                aprintf("[Decoder] Decoder Frame %"LU" pts=%"LLU" ms, %"LLU" us\n",vid->lastSentFrame,
+                                                        result->Pts/1000,result->Pts);
+                if(pts==ADM_COMPRESSED_NO_PTS) // No PTS available ?
+                {
+                   
+                    if(false==syncFound)
+                    {
+                        aprintf("[DecodePictureUpToIntra] No time stamp yet, dropping picture\n");
+                        cache->invalidate(result);
+                    }else
+                    {
+                        // increment it using average fps
+                        vid->lastDecodedPts+=vid->timeIncrementInUs;
+                        result->Pts=vid->lastDecodedPts;
+                    }
+                }else
+                {
+                    if(false==syncFound)
+                    {
+                        aprintf("[DecodePictureUpToIntra] Sync found\n");
+                        syncFound=true;
+                    }
+                    vid->lastDecodedPts=pts;
+                }
+            }
+
+            // Found our image ?
+          if(result->Pts==wantedPts)
+                found=true;
+          else
+                vid->lastSentFrame++;
+    }
+    if(found==false)
+    {
+        ADM_warning(" Could not find decoded frame, wanted PTS :%"LU" PTS=%"LLU" ms, %"LLU" us\n",frame,wantedPts/1000,wantedPts);
+        cache->dump();
+        return false;
+    }
+    vid->lastReadPts=wantedPts;
+    currentFrame=frame;
+    return true;
+}
+
+#if 0
+
+/**
+    \fn decodeCache
+    \brief Decode an image an update cache
+    @param ref:index of reference video
+    @param frame:Frame to decode
+    @param image where to put the decoded image
+    @return true if a frame is available
+*/
+
+ bool		ADM_Composer::decodeCache(uint32_t ref, uint32_t frame,ADMImage *image)
+{
+
+uint32_t sumit;
+float	 sum;
+
+_VIDEOS *v=_segments.getRefVideo(ref); // FIXME!!!!
+EditorCache *cache=v->_videoCache;
+ADMImage *tmpImage=NULL;
+uint8_t refOnly=0;
+uint32_t left,ww;
+ADMCompressedImage img;
+
+        aprintf("decodeCache : original :%"LD" Frame in ref %"LD"\n",frame,refOffset);
+        img.data=compBuffer;
+        img.cleanup(frame);
+        // Step 1, retrieve the compressed datas, including PTS & DTS infos
+         if (!v->_aviheader->getFrame (frame,&img))
+        {
+          ADM_warning ("Editor: last decoding failed.%"LD")\n",   frame );
+          return 0;
+        }
+        ADM_assert(_imageBuffer);
+
+        // if len is 0 then take the previous image
+        //
+
+        refOnly=v->decoder->dontcopy(); // can we skip one memcpy ?
+
+        if(!img.dataLength & refOnly & !frame)      // Size is null = no image and we only got a pointer
+                                // copy the previous one
+        {
+                // First image
+
+                uint32_t page=_imageBuffer->_width*_imageBuffer->_height;
+                        memset(YPLANE(image),0,page);
+                        memset(UPLANE(image),128,page>>2);
+                        memset(VPLANE(image),128,page>>2);
+                        if(!frame)
+                                image->flags=AVI_KEY_FRAME;
+                        else
+                                image->flags=AVI_P_FRAME;
+                        image->_Qp=2;
+                        image->_qStride=0;
+                        return 1;
+        }
+
+        if(refOnly)
+        {       // This is only an empty Shell
+                uint32_t w,h;
+                if(_scratch) // Can we reuse the old scratch memory ?
+                {
+                    _scratch->getWidthHeight(&w,&h);
+                    if(w!=_imageBuffer->_width || _imageBuffer->_height!=h)
+                    {
+                        delete _scratch;
+                        _scratch=NULL;
+                    }
+                }
+                if(!_scratch)
+                {
+                  _scratch=new ADMImage(_imageBuffer->_width,_imageBuffer->_height,1);
+                }
+                tmpImage=_scratch;
+                ww=_imageBuffer->_width & 0xfffff0;
+                left=_imageBuffer->_width & 0xf;
+
+        }
+        else
+        {
+                tmpImage=_imageBuffer;
+                ww=_imageBuffer->_width;
+                left=0;
+       }
+	tmpImage->_colorspace=ADM_COLOR_YV12;
+	// Do pp, and use imageBuffer as intermediate buffer
+	if (!v->decoder->uncompress (&img, tmpImage))
+	    {
+	      ADM_warning (" Last Decoding2 failed for frame %"LU"\n",frame);
+	       // Try to dupe previous frame
+                if(frame)
+                {
+                        ADMImage *prev;
+                        prev=cache->getImage(frame-1);
+                        if(prev)
+                        {
+                                image->duplicate(prev);
+                                cache->updateFrameNum(image,frame);
+                                return 1;
+                        }
+                }
+                goto _next;
+           }
+
+        //
+        if(tmpImage->_noPicture && refOnly && frame)
+        {
+                cache->updateFrameNum(image,0xffffffffU);
+                return 0;
+        }
+	// If not quant and it is already YV12, we can stop here
+	if((!tmpImage->quant || !tmpImage->_qStride) && tmpImage->_colorspace==ADM_COLOR_YV12)
+	{
+		image->_Qp=2;
+		image->duplicate(tmpImage);
+		cache->updateFrameNum(image,frame);
+          //      if(refOnly) delete tmpImage;
+		aprintf("EdCache: No quant avail\n");
+		return 1;
+	}
+	// We got everything, let's go
+	// 1 compute average quant
+	int qz;
+	sumit=0;
+        // Dupe infos
+        image->copyInfo(tmpImage);
+
+
+        // Do postprocessing if any
+	for(uint32_t z=0;z<tmpImage->_qSize;z++)
+	{
+            qz=(int)tmpImage->quant[z];
+			sumit+=qz;
+	}
+	sumit+=(tmpImage->_qSize-1);
+//	sumit*=2;
+	sum=(float)sumit;
+	sum/=tmpImage->_qSize;
+	if(sum>31) sum=31;
+	if(sum<1) sum=1;
+
+        // update average Q
+	tmpImage->_Qp=image->_Qp=(uint32_t)floor(sum);
+
+	// Pp deactivated ?
+	if(!_pp.postProcType || !_pp.postProcStrength || tmpImage->_colorspace!=ADM_COLOR_YV12)
+     {
+        dupe(tmpImage,image,v);
+		cache->updateFrameNum(image,frame);
+               // if(refOnly) delete tmpImage;
+		aprintf("EdCache: Postproc disabled\n");
+		return 1;
+	}
+
+	int type;
+	#warning FIXME should be FF_I_TYPE/B/P
+	if(tmpImage->flags & AVI_KEY_FRAME) type=1;
+		else if(tmpImage->flags & AVI_B_FRAME) type=3;
+			else type=2;
+
+        ADM_assert(tmpImage->_colorspace==ADM_COLOR_YV12);
+
+	// we do postproc !
+	// keep
+	uint8_t *oBuff[3];
+	const uint8_t *iBuff[3];
+	int	strideTab[3];
+	int	strideTab2[3];
+	aviInfo _info;
+
+		getVideoInfo(&_info);
+                if(refOnly)
+                {
+                        iBuff[0]= tmpImage->_planes[0];
+                        iBuff[1]= tmpImage->_planes[1];
+                        iBuff[2]= tmpImage->_planes[2];
+
+                        strideTab2[0]=_info.width;
+                        strideTab2[1]=_info.width>>1;
+                        strideTab2[2]=_info.width>>1;
+
+                        strideTab[0]=tmpImage->_planeStride[0];
+                        strideTab[1]=tmpImage->_planeStride[1];
+                        strideTab[2]=tmpImage->_planeStride[2];
+
+                }
+                else
+                {
+		        iBuff[0]= YPLANE((tmpImage));
+                iBuff[1]= UPLANE((tmpImage));
+                iBuff[2]= VPLANE((tmpImage));
+
+
+
+                        strideTab[0]=strideTab2[0]=_info.width;
+                        strideTab[1]=strideTab2[1]=_info.width>>1;
+                        strideTab[2]=strideTab2[2]=_info.width>>1;
+                }
+                if(_pp.swapuv)
+                {
+        	        oBuff[0]= YPLANE(image);
+                        oBuff[1]= VPLANE(image);
+                        oBuff[2]= UPLANE(image);
+                }else
+                {
+
+                        oBuff[0]= YPLANE(image);
+                        oBuff[1]= UPLANE(image);
+                        oBuff[2]= VPLANE(image);
+                }
+		 pp_postprocess(
+		 		iBuff,
+		 		strideTab,
+		 		oBuff,
+		 		strideTab2,
+		 		ww,
+		        	_info.height,
+		          	(int8_t *)(tmpImage->quant),
+		          	tmpImage->_qStride,
+		         	_pp.ppMode,
+		          	_pp.ppContext,
+		          	type);			// img type
+                /*
+                        If there is a chroma block that needs padding
+                        (width not multiple of 16) while postprocessing,
+                        we process up to the nearest 16 multiple and
+                        just copy luma & chroma info that was left over
+                */
+                if(refOnly && left)
+                {
+                        uint8_t *src,*dst;
+                        uint32_t stridein,strideout,right;
+                        right=_info.width-left;
+                        // Luma
+                        dst=YPLANE(image)+right;
+                        src=tmpImage->_planes[0]+right;
+                        stridein=tmpImage->_planeStride[0];
+                        strideout=_info.width;
+                        for(uint32_t y=_info.height;y>0;y--)
+                        {
+                                memcpy(dst,src,left);
+                                dst+=strideout;
+                                src+=stridein;
+                        }
+                        // Chroma
+                        left>>=1;
+                        right>>=1;
+                        //
+                        dst=UPLANE(image)+right;
+                        src=tmpImage->_planes[1]+right;
+                        stridein=tmpImage->_planeStride[1];
+                        strideout=_info.width>>1;
+                        for(uint32_t y=_info.height>>1;y>0;y--)
+                        {
+                                memcpy(dst,src,left);
+                                dst+=strideout;
+                                src+=stridein;
+                        }
+                        //
+                        dst=VPLANE(image)+right;
+                        src=tmpImage->_planes[2]+right;
+                        stridein=tmpImage->_planeStride[2];
+                        strideout=_info.width>>1;
+                        for(uint32_t y=_info.height>>1;y>0;y--)
+                        {
+                                memcpy(dst,src,left);
+                                dst+=strideout;
+                                src+=stridein;
+                        }
+
+
+                }
+_next:
+        // update some infos
+        //   if(refOnly) delete tmpImage;
+		cache->updateFrameNum(image,frame);
+		aprintf("EdCache: Postproc done\n");
+		return 1;
+}
+#endif
+
+
+//EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edSearch.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edSearch.cpp	2009-10-20 13:26:46 UTC (rev 5391)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edSearch.cpp	2009-10-20 13:26:48 UTC (rev 5392)
@@ -168,108 +168,6 @@
 }
 
 /**
-    \fn searchFrameBefore
-    \brief Return the frame number with pts just before pts
-*/
-uint32_t ADM_Composer::searchFrameBefore(uint64_t pts)
-{
-uint64_t refTime;
-uint32_t ref;
-    if(false==_segments.getRefFromTime(pts,&ref,&refTime))
-    {
-        ADM_warning(" Failed for pts %"LLU"\n",pts);
-        ref=0;
-        refTime=pts;
-    }
-#warning fix over-seg issue
-    _VIDEOS   *vid=_segments.getRefVideo(ref);
-    vidHeader *demuxer=vid->_aviheader;
-    uint64_t  lastPts=demuxer->getTime(0);
-    uint32_t  nb=demuxer->getVideoStreamHeader()->dwLength;
-
-    if(lastPts>pts) return 0;
-
-	for(int i=1;i<nb-2;i++)
-    {
-        uint64_t cur,next;
-        cur=lastPts;
-        next=demuxer->getTime(i+1);
-        if(next==ADM_NO_PTS) next=cur+vid->timeIncrementInUs;
-        if(pts>=cur && pts<next) return i-1;
-        lastPts=next;
-    }
-    return nb-1;
-}
-/**
-    \fn searchFrameBefore
-    \brief Return the frame number with pts just before pts
-*/
-uint32_t ADM_Composer::searchFrameAt(uint64_t pts)
-{
-uint64_t refTime;
-uint32_t ref;
-    if(false==_segments.getRefFromTime(pts,&ref,&refTime))
-    {
-        ADM_warning(" Failed for pts %"LLU"\n",pts);
-        ref=0;
-        refTime=pts;
-    }
-#warning fix over-seg issue
-    _VIDEOS   *vid=_segments.getRefVideo(ref);
-    vidHeader *demuxer=vid->_aviheader;
-    
-    uint32_t  nb=demuxer->getVideoStreamHeader()->dwLength;
-;
-
-	for(int i=0;i<nb;i++)
-    {
-        uint64_t thisPts,thisDts;
-        demuxer->getPtsDts(i,&thisPts,&thisDts);
-        if(thisPts==ADM_NO_PTS) continue;
-        if(refTime==thisPts)
-        {
-            ADM_info("Found frame %"LU" for time %"LLU" ms\n",i,thisPts/1000);
-            return i;
-        }
-    }
-    ADM_warning("Cannot find frame at %"LLU"\n",pts);
-    return 0;
-}
-/**
-    \fn getImageFromCacheForFrameBefore
-    \brief Search the cache for the image with PTS just before the input PTS
-*/
-bool    ADM_Composer::getImageFromCacheForFrameBefore(uint64_t pts,ADMImage *out)
-{
-    int ref=0;
-    EditorCache   *cache;
-	_VIDEOS *vid=_segments.getRefVideo(0);
-	cache=vid->_videoCache;
-	ADM_assert(cache);
-        ADMImage *r=cache->findLastBefore(pts);
-        if(!r) return false;
-        out->duplicateFull(r);
-        return true;
-
-}
-/**
-    \fn getPtsDts
-    \brief Return PTS & DTS for a given frame (in bitstream order)
-*/
-bool        ADM_Composer::getPtsDts(uint32_t frame,uint64_t *pts,uint64_t *dts)
-{
-uint32_t ref,refOffset;
-    if(_segments.getRefFromFrame(frame,&ref,&refOffset)==false)
-    {
-        ADM_warning("Cannot get ref video for frame %"LD"\n",frame);
-        return false;
-    }
- 
-     _VIDEOS   *vid=_segments.getRefVideo(ref);
-    vidHeader *demuxer=vid->_aviheader;
-    return demuxer->getPtsDts(frame,pts,dts); // FIXME : Rescale frame number
-}
-/**
     \fn getDurationInUs
     \brief Return total duration of video in us
 */

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edStub.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edStub.cpp	2009-10-20 13:26:46 UTC (rev 5391)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edStub.cpp	2009-10-20 13:26:48 UTC (rev 5392)
@@ -45,96 +45,10 @@
 
 }
 
-
 /**
-    \fn getFrame
-    \brief returns the raw frame from the demuxer with len pts & dts
-*/
-uint8_t   ADM_Composer::getFrame (uint32_t framenum, ADMCompressedImage *img, uint8_t *isSeq)
-{
-  static uint32_t lastRef = 0, lastframe = 0;
-  ADM_TRANSLATE(getFrame,framenum)
+    \fn updateVideoInfo
 
-  if (ref)
-    {
-      if ((lastRef == ref) && ((lastframe + 1) == refOffset))
-	{
-	  *isSeq = 1;
-	}
-      else
-	*isSeq = 0;
-    }
-  lastRef = ref;
-  lastframe = refOffset;
-  return _segments.getRefVideo(ref)->_aviheader->getFrame (refOffset,img);
-}
-
-
-/**
-    \fn getTime
-    \brief return or estimate the pts of frame fn
 */
-uint64_t ADM_Composer::getTime (uint32_t fn)
-{
-    
-    uint64_t t= STUBB->getTime(fn);
-    uint32_t org=fn;
-    if(t!=ADM_COMPRESSED_NO_PTS) return t;
-    if(!fn) return 0;
-
-    // Try to guess what is the time...
-    while(1)
-    {
-        fn--;
-        if(STUBB->getTime(fn)!=ADM_COMPRESSED_NO_PTS)
-        {
-            t=STUBB->getTime(fn);
-            t+= _segments.getRefVideo(0)->timeIncrementInUs*(org-fn);
-            return t;
-        }
-    }
-    ADM_warning("[ADM_Composer::getTime] Cannot estimate time for frame %u\n",org);
-    return 0;
-}
-/**
-    \fn getFlags
-*/
-uint32_t ADM_Composer::getFlags (uint32_t frame, uint32_t * flags)
-{
-    ADM_TRANSLATE(getFlags,frame);
-    return _segments.getRefVideo(ref)->_aviheader->getFlags (refOffset, flags);
-}
-/**
-    \fn getFlagsAndSeg
-*/
-uint32_t ADM_Composer::getFlagsAndSeg (uint32_t frame, uint32_t * flags,uint32_t *segs)
-{
- ADM_TRANSLATE(getFlagsAndSeg,frame);
-*segs=0;
-#warning fixme
- return _segments.getRefVideo(ref)->_aviheader->getFlags (refOffset, flags);
-}
-/**
-    \fn getFrameSize
-*/
-uint8_t ADM_Composer::getFrameSize (uint32_t frame, uint32_t * size)
-{
- 
-  ADM_TRANSLATE(getframeSize,frame);
-  return _segments.getRefVideo(ref)->_aviheader->getFrameSize (refOffset, size);
-}
-
-/**
-    \fn setFlag
-*/
-uint8_t ADM_Composer::setFlag (uint32_t frame, uint32_t flags)
-{
-    ADM_TRANSLATE(setFlag,frame);
-    return _segments.getRefVideo(ref)->_aviheader->setFlag (refOffset, flags);
-}
-
-//
-//
 uint8_t ADM_Composer::updateVideoInfo (aviInfo * info)
 {
 

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp	2009-10-20 13:26:46 UTC (rev 5391)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp	2009-10-20 13:26:48 UTC (rev 5392)
@@ -55,9 +55,7 @@
   _audioseg = 0;
   _audiooffset = 0;
   _audioSample=0;
-  _lastseg = 99;
-  _lastframe = 99;
-  _haveMarkers=0; // only edl have markers
+
   // Initialize a default postprocessing (dummy)
   initPostProc(&_pp,16,16);
   if(!prefs->get(DEFAULT_POSTPROC_TYPE,&type)) type=3;
@@ -70,8 +68,7 @@
   updatePostProc(&_pp);
   _imageBuffer=NULL;
   _internalFlags=0;
-  // Start with a clean base
-
+  _currentSegment=0;
 }
 /**
 	Remap 1:1 video to segments
@@ -132,7 +129,7 @@
   _VIDEOS video;
     memset(&video,0,sizeof(video));
 
-	_haveMarkers=0; // by default no markers are present
+	
   
     FILE *f=fopen(name,"r");
     uint8_t buffer[4];
@@ -556,36 +553,11 @@
       It can happen, for example in case of SBR audio such as AAC
       The demuxer says it is xx kHz, but the codec updates it to 2*xx kHz
 */
-uint8_t ADM_Composer::rebuildDuration(void)
+bool  ADM_Composer::rebuildDuration(void)
 {
-  return 1;
+  return true;
 }
 /**
-    \fn estimatePts
-    \brief Get or estimate PTS of given frame
-*/
-uint64_t    ADM_Composer::estimatePts(uint32_t frame)
-{
-    uint32_t flags;
-    _VIDEOS *vid=_segments.getRefVideo(0);
-    vidHeader *demuxer=vid->_aviheader;
-    int count=0;
-    uint64_t  wantedPts;
-	while(1)
-    {
-        demuxer->getFlags(frame,&flags);
-        wantedPts=vid->_aviheader->getTime(frame);
-        if((flags & AVI_KEY_FRAME)&&(wantedPts!=ADM_NO_PTS))
-        {
-                break;
-        }
-        count++;
-        frame--;
-    }
-    wantedPts+=vid->timeIncrementInUs*count;
-    return wantedPts;
-}
-/**
     \fn getCurrentFramePts
     \brief Get the PTS of current frame
 

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx	2009-10-20 13:26:46 UTC (rev 5391)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx	2009-10-20 13:26:48 UTC (rev 5392)
@@ -63,6 +63,31 @@
 class ADM_Composer : public ADM_audioStream
 {
   private:
+//*********************************PRIVATE API *******************************************
+                    bool		decodeCache(uint32_t ref, uint32_t frame,ADMImage *image);
+                    bool        switchToNextSegment(void);
+                    bool        switchToSegment(uint32_t s);
+                    uint32_t    currentFrame;
+
+                    bool        nextPictureInternal(uint32_t ref,ADMImage *image);
+                    bool        samePictureInternal(uint32_t ref,ADMImage *image);
+
+protected:
+                                /// Decode frame and on until frame is popped out of decoders
+                    bool        DecodePictureUpToIntra(uint32_t frame,uint32_t ref);
+                                /// compressed image->yb12 image image and do postproc/colorconversion
+                    bool        decompressImage(ADMImage *out,ADMCompressedImage *in,uint32_t ref);
+                                /// Decode next image
+                    bool        DecodeNextPicture(uint32_t ref);
+                                /// Get the next decoded picture
+                    bool     	getNextPicture(ADMImage *out,uint32_t ref);
+                                /// Get again last decoded picture
+                    bool        getSamePicture(ADMImage *out,uint32_t ref);
+
+                    bool        searchNextKeyFrameInRef(int ref,uint64_t refTime,uint64_t *nkTime);
+                    bool        searchPreviousKeyFrameInRef(int ref,uint64_t refTime,uint64_t *nkTime);
+//******************************************************************************************
+  private:
                     ADM_EditorSegment _segments;
                     uint8_t     dupe(ADMImage *src,ADMImage *dst,_VIDEOS *vid); 
                                                             // Duplicate img, do colorspace
@@ -70,16 +95,16 @@
   					uint32_t	_internalFlags;
   					ADM_PP 		_pp;
 					ADMImage	*_imageBuffer;
-  					uint8_t		decodeCache(uint32_t frame,uint32_t seg, ADMImage *image);
+  				
   					// _audiooffset points to the offset / the total segment
   					// not the used part !
   					uint32_t  _audioseg;
 					int64_t   _audioSample;
   					uint32_t  _audiooffset;
-					uint8_t	  _haveMarkers; // used for load/save edl
-                    
-       				uint32_t _lastseg,_lastframe,_lastlen;
 
+                    uint32_t  _currentSegment;
+       				//uint32_t _lastseg,_lastframe,_lastlen;
+
                     ADM_audioStreamTrack *getTrack(uint32_t i);
                     ADMImage    *_scratch;																		;
                     uint8_t  	updateAudioTrack(uint32_t seg);			   	
@@ -93,7 +118,7 @@
                     bool     	getExtraHeaderData(uint32_t *len, uint8_t **data);
                     uint32_t    getPARWidth(void);
                     uint32_t    getPARHeight(void);
-                    uint8_t     rebuildDuration(void);
+                    bool        rebuildDuration(void);
   								ADM_Composer();
   				virtual 			~ADM_Composer();
                     void		clean( void );
@@ -114,62 +139,13 @@
                     bool        setMarkerBPts(uint64_t pts);
 public:
 /************************************ Public API ***************************/
-protected:
-                    uint32_t    currentFrame;
-                    bool        GoToIntra(uint32_t frame);
-                    uint32_t    getCurrentFrame(void); 
-                    bool        setCurrentFrame(uint32_t frame);
-
-                    uint64_t    estimatePts(uint32_t frame);
 public:
-                    bool        getCompressedPicure(ADMCompressedImage *img);
-      
-public:
-                   
+                    bool        getCompressedPicture(ADMCompressedImage *img);
                     uint64_t    getCurrentFramePts(void);
-                   
-                    
-                    bool        GoToTime(uint64_t time);
-                    bool        GoToIntraTime(uint64_t time);
-                    bool        NextPicture(ADMImage *image);
+                    bool        goToTimeVideo(uint64_t time);
+                    bool        goToIntraTimeVideo(uint64_t time);
+                    bool        nextPicture(ADMImage *image);
                     bool        samePicture(ADMImage *image);
-
-                   // Fixme, framenumber !
-                    uint32_t    searchFrameBefore(uint64_t pts);
-                    uint32_t    searchFrameAt(uint64_t pts);
-                    bool        getImageFromCacheForFrameBefore(uint64_t pts,ADMImage *out);
-                    bool        getPictureJustBefore(uint64_t pts);
-                    bool        getPtsDts(uint32_t frame,uint64_t *pts,uint64_t *dts);
-/************************************ Internal ******************************/
-protected:
-                                /// Decode frame and on until frame is popped out of decoders
-                    bool        DecodePictureUpToIntra(uint32_t frame,uint32_t ref);
-                                /// compressed image->yb12 image image and do postproc/colorconversion
-                    bool        decompressImage(ADMImage *out,ADMCompressedImage *in,uint32_t ref);
-                                /// Decode next image
-                    bool        DecodeNextPicture(uint32_t ref);
-                                /// Get the next decoded picture
-                    bool     	getNextPicture(ADMImage *out,uint32_t ref);
-                                /// Get again last decoded picture
-                    bool        getSamePicture(ADMImage *out,uint32_t ref);
-
-                    bool        searchNextKeyFrameInRef(int ref,uint64_t refTime,uint64_t *nkTime);
-                    bool        searchPreviousKeyFrameInRef(int ref,uint64_t refTime,uint64_t *nkTime);
-
-/************************************ Internal ******************************/
-protected:
-                    uint8_t 	getFrame(uint32_t   framenum,ADMCompressedImage *img,uint8_t *isSequential);
-                    
-                
-                    uint64_t 	getTime(uint32_t fn);
-                    uint32_t 	getFlags(uint32_t frame,uint32_t *flags);
-
-                            // B follow A with just Bframes in between
-                    uint32_t 	getFlagsAndSeg (uint32_t frame,    uint32_t * flags,uint32_t *segs);
-                    uint8_t  	setFlag(uint32_t frame,uint32_t flags);
-
-                    uint8_t  	getFrameSize(uint32_t frame,uint32_t *size) ;
-
 public:
                     uint8_t	    updateVideoInfo(aviInfo *info);
                     uint32_t 	getSpecificMpeg4Info( void );
@@ -210,12 +186,6 @@
 					
 					
 /***************************************** Seeking *****************************/            
-protected:
-		  			bool			getPKFrame(uint32_t *frame);
-					bool			getNKFrame(uint32_t *frame);
-
-                    
-                    bool			getUncompressedFrame(uint32_t frame,ADMImage *out,uint32_t *flagz=NULL);
 public:
                     bool			getNKFramePTS(uint64_t *frameTime);
                     bool			getPKFramePTS(uint64_t *frameTime);   

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp	2009-10-20 13:26:46 UTC (rev 5391)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp	2009-10-20 13:26:48 UTC (rev 5392)
@@ -239,24 +239,6 @@
     return true;
 }
 /**
-    \fn getRefFromFrame
-*/
-bool        ADM_EditorSegment::getRefFromFrame(uint32_t frame,uint32_t *refVideo, uint32_t *frameOffset)
-{
-    *refVideo=0;
-    *frameOffset=frame;
-    return true;
-}
-/**
-    \fn getFrameFromRef
-*/
-bool        ADM_EditorSegment::getFrameFromRef(uint32_t *frame,uint32_t refVideo, uint32_t frameOffset)
-{
-    *frame=frameOffset;
-    return true;
-
-}
-/**
     \fn ~ADM_audioStreamTrack
 */
  ADM_audioStreamTrack::~ADM_audioStreamTrack()
@@ -300,4 +282,59 @@
     *frameTime=segTime+segments[seg]._startTimeUs;
     return true;
 }
+/**
+    \fn TimeToFrame
+    \brief return the frameno whose PTS==time
+*/
+static bool TimeToFrame(_VIDEOS *v,uint64_t time,uint32_t *frame,uint32_t *oflags)
+{
+    vidHeader 							*demuxer=v->_aviheader;  
+    int nb=demuxer->getMainHeader()->dwTotalFrames;
+    for(int i=0;i<nb;i++)
+    {
+        uint64_t pts,dts;
+        uint32_t flags;
+            demuxer->getPtsDts(i,&pts,&dts);
+            demuxer->getFlags(i,&flags);
+            if(pts==time)
+            {
+                *frame=i;
+                *oflags=flags;
+                return true;
+            }
+            if(pts!=ADM_NO_PTS &&pts>time) return false;
+    }
+    return false;
+}
+/**
+    \fn intraTimeToFrame
+    \brief Return the frame whosePTS==seektime, assert if does not exist
+*/
+uint32_t    ADM_EditorSegment::intraTimeToFrame(uint32_t refVideo,uint64_t seekTime)
+{
+        uint32_t frame;
+        uint32_t flags;
+        _VIDEOS *v=getRefVideo(refVideo);
+        ADM_assert(v);
+        if(false==TimeToFrame(v,seekTime,&frame,&flags))
+        {
+            ADM_assert(0);
+        }
+        ADM_assert(flags & AVI_KEY_FRAME);
+        return frame;
+}
+/**
+    \fn         isKeyFrameByTime
+    \brief      Return true if frame with PTS==seektime is a keyframe
+*/
+bool        ADM_EditorSegment::isKeyFrameByTime(uint32_t refVideo,uint64_t seekTime)
+{
+        uint32_t frame;
+        uint32_t flags;
+        _VIDEOS *v=getRefVideo(refVideo);
+        ADM_assert(v);
+        if(false==TimeToFrame(v,seekTime,&frame,&flags)) return false;
+        if(flags & AVI_KEY_FRAME) return true;
+        return false;
+}
 //EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.h	2009-10-20 13:26:46 UTC (rev 5391)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.h	2009-10-20 13:26:48 UTC (rev 5392)
@@ -81,6 +81,7 @@
     uint64_t                            _startTimeUs;     /// Start time in current (=sum(_duration of previous seg))
 	uint64_t							_durationUs;      ///
     uint32_t                            _nbFrame;
+    uint32_t                            _curFrame;        ///
 }_SEGMENT;
 /*
     Use vectors to store our videos & segments
@@ -97,7 +98,6 @@
         ListOfSegments segments;
         ListOfVideos   videos;
         bool           updateStartTime(void);
-        uint32_t       currentSeg;
 
 public:
                         ADM_EditorSegment(void);
@@ -117,14 +117,14 @@
 
             bool        getRefFromTime(uint64_t time,uint32_t *refVideo, uint64_t *offset);
 
-            bool        getRefFromFrame(uint32_t frame,uint32_t *refVideo, uint32_t *frameOffset);
-            bool        getFrameFromRef(uint32_t *frame,uint32_t refVideo, uint32_t frameOffset);
-
-
             bool        convertLinearTimeToSeg(  uint64_t frameTime, uint32_t *seg, uint64_t *segTime);
             bool        convertSegTimeToLinear(  uint32_t seg,uint64_t segTime, uint64_t *frameTime);
 
             _SEGMENT    *getCurrentSeg(void);
+
+
+            uint32_t    intraTimeToFrame(uint32_t refVideo,uint64_t seekTime);       
+            bool        isKeyFrameByTime(uint32_t refVideo,uint64_t seekTime);
 };
 
 #endif

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/CMakeLists.txt	2009-10-20 13:26:46 UTC (rev 5391)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/CMakeLists.txt	2009-10-20 13:26:48 UTC (rev 5392)
@@ -7,6 +7,7 @@
 ADM_edFrameType.cpp 
 ADM_edit.cpp 
 ADM_edRender.cpp 
+ADM_edRenderInternal.cpp 
 ADM_edMarker.cpp
 ADM_edStub.cpp
 ADM_edPtsDts.cpp

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoCopy.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoCopy.cpp	2009-10-20 13:26:46 UTC (rev 5391)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoCopy.cpp	2009-10-20 13:26:48 UTC (rev 5392)
@@ -40,7 +40,7 @@
     eofMet=false;
     this->startTime=realStart;
     this->endTime=endTime;
-    video_body->GoToIntraTime(realStart);
+    video_body->goToIntraTimeVideo(realStart);
     ADM_info(" Fixating start time by %u\n",abs((int)(this->startTime-startTime)));
 }
 /**
@@ -83,7 +83,7 @@
 {
     if(true==eofMet) return false;
     image.data=data;
-    if(false==video_body->getCompressedPicure(&image))
+    if(false==video_body->getCompressedPicture(&image))
     {
             ADM_warning(" Get packet failed ");
             return false;

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.cpp	2009-10-20 13:26:46 UTC (rev 5391)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.cpp	2009-10-20 13:26:48 UTC (rev 5392)
@@ -352,7 +352,7 @@
 
 bool admPreview::seekToIntraPts(uint64_t timeframe)
 {
-    if(!video_body->GoToIntraTime(timeframe)) 
+    if(!video_body->goToIntraTimeVideo(timeframe)) 
     {
         ADM_warning(" seeking for frame at %"LLU" ms failed\n",timeframe/1000LL);
         return false;
@@ -405,7 +405,7 @@
         }
 #else
 
-        if(!video_body->NextPicture(rdrImage)) return 0;
+        if(!video_body->nextPicture(rdrImage)) return 0;
 #endif
             UI_setFrameType(  rdrImage->flags,rdrImage->_Qp);
 
@@ -672,6 +672,7 @@
 */
 bool admPreview::previousFrame(void)
 {
+#if 0
     uint64_t pts=rdrImage->Pts;
     // If the frame is not an intra, the previous one
     // is still in the cache
@@ -685,7 +686,7 @@
         }
         return false;
     }
-#if 0
+
     // Else go to the previous  keyframe...
     if(!video_body->getPKFrame(&frame)) return false;
     if(!video_body->GoToIntra(frame)) return false;

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/ADM_videoFilterBridge.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/ADM_videoFilterBridge.cpp	2009-10-20 13:26:46 UTC (rev 5391)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/ADM_videoFilterBridge.cpp	2009-10-20 13:26:48 UTC (rev 5392)
@@ -46,7 +46,7 @@
 bool ADM_videoFilterBridge::rewind(void)
 {
     printf("[VideoBridge] Goint to %"LU" ms\n",(uint32_t)(startTime/1000));
-    video_body->GoToTime(startTime);
+    video_body->goToTimeVideo(startTime);
     firstImage=true;
     lastSentImage=0;
     return true;
@@ -75,7 +75,7 @@
         lastSentImage=0;
     }else
     {
-        r=   video_body->NextPicture(image);
+        r=   video_body->nextPicture(image);
         lastSentImage++;
     }
     if(r==false) return false;

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/gui_navigate.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/gui_navigate.cpp	2009-10-20 13:26:46 UTC (rev 5391)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/gui_navigate.cpp	2009-10-20 13:26:48 UTC (rev 5392)
@@ -37,7 +37,7 @@
 extern void UI_purge(void);
 extern uint8_t DIA_gotoTime(uint16_t *hh, uint16_t *mm, uint16_t *ss);
 extern bool SliderIsShifted;
-
+bool   GUI_GoToTime(uint64_t time);
 uint8_t A_jumpToTime(uint32_t hh,uint32_t mm,uint32_t ss,uint32_t ms);
 /**
     \fn HandleAction_Navigate
@@ -81,8 +81,7 @@
                 uint64_t pts;
                 if(action==ACT_GotoMarkA) pts=video_body->getMarkerAPts();
                         else  pts=video_body->getMarkerBPts();
-                 uint32_t frame=video_body->searchFrameBefore(pts);
-                  GUI_GoToFrame(frame);
+                GUI_GoToTime(pts);
                  
             }
             break;
@@ -450,9 +449,16 @@
         pts*=1000;
         pts+=ms;
         pts*=1000;
-        uint32_t frame=video_body->searchFrameBefore(pts);
-        return GUI_GoToFrame(frame);
 
+        return GUI_GoToTime(pts);
+
 }
-
+/**
+    \fn GUI_GoToTime
+*/
+bool GUI_GoToTime(uint64_t time)
+{
+    ADM_warning("GUI_GoToTime called\n");
+    return false; 
+}   
 // EOF



From mean at mail.berlios.de  Tue Oct 20 19:17:21 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 20 Oct 2009 19:17:21 +0200
Subject: [Avidemux-svn-commit] r5393 - in
	branches/avidemux_2.6_branch_mean/avidemux/common: . ADM_editor
Message-ID: <200910201717.n9KHHLVt018144@sheep.berlios.de>

Author: mean
Date: 2009-10-20 19:17:18 +0200 (Tue, 20 Oct 2009)
New Revision: 5393

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRenderInternal.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edSearch.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/gui_navigate.cpp
Log:
[editor] Slightly less broken editor

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp	2009-10-20 13:26:48 UTC (rev 5392)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp	2009-10-20 17:17:18 UTC (rev 5393)
@@ -82,7 +82,7 @@
         ADM_warning("Cannot go to segment %"LU"\n",s);
         return false;
     }
-    if(false== DecodePictureUpToIntra(frame,seg->_reference))
+    if(false== DecodePictureUpToIntra(seg->_reference,frame))
     {
         return false;
     }
@@ -286,16 +286,35 @@
     }
     _SEGMENT *seg=_segments.getSegment(s);
     ADM_assert(seg);
-    ADM_info("Switching to seg %"LU" with startTime in reference pic= %"LU" ms\n",s,seg->_refStartTimeUs/1000);
+    ADM_info("Trying to switch to seg %"LU" with startTime in reference pic= %"LU" ms\n",s,seg->_refStartTimeUs/1000);
+        // If the refStartTime is 0, it is the first image
+        // But the fist image might not be = 0
+        _VIDEOS *vid=_segments.getRefVideo(seg->_reference);
+        vidHeader 	*demuxer=vid->_aviheader;  
+        ADM_assert(vid);
+        uint64_t from=seg->_refStartTimeUs;
+      uint32_t flags;
+      uint64_t pts,dts;
+        demuxer->getFlags(0,&flags);
+        demuxer->getPtsDts(0,&pts,&dts);
+    if(!seg->_refStartTimeUs)
+    {
+        if(pts!=ADM_NO_PTS && pts)
+        {
+                ADM_info("This segment does not start at 0,...\n");
+                from=pts;
+        }
+    }
+    
     // Search the previous keyframe for segment....
     uint64_t seekTime;
-    if(_segments.isKeyFrameByTime(seg->_reference,seg->_refStartTimeUs))
+    if(_segments.isKeyFrameByTime(seg->_reference,from))
     {
-        seekTime=seg->_refStartTimeUs;
+        seekTime=from;
         ADM_info("First frame of the new segment is a keyframe at %"LU"ms\n",seekTime/1000);
     }else   
     {
-        if(false==searchPreviousKeyFrameInRef(seg->_reference,seg->_refStartTimeUs,&seekTime))
+        if(false==searchPreviousKeyFrameInRef(seg->_reference,from,&seekTime))
         {
             ADM_warning("Cannot identify the keyframe before %"LLU" ms\n",seekTime/1000);
             return false;
@@ -303,7 +322,7 @@
     }
     // ok now seek...
     uint32_t frame=_segments.intraTimeToFrame(seg->_reference,seekTime);
-    if(false==DecodePictureUpToIntra(frame,seg->_reference))
+    if(false==DecodePictureUpToIntra(seg->_reference,frame))
     {
         return false;
     }
@@ -313,6 +332,14 @@
     seg->_curFrame=ref->lastSentFrame;
     return true;
 }
+/**
+    \fn rewind
+    \brief
+*/
+bool ADM_Composer::rewind(void)
+{
+        ADM_info("Rewinding\n");
+        return DecodePictureUpToIntra(0,0);
 
-
+}
 //EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRenderInternal.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRenderInternal.cpp	2009-10-20 13:26:48 UTC (rev 5392)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRenderInternal.cpp	2009-10-20 17:17:18 UTC (rev 5393)
@@ -50,7 +50,7 @@
   ADMImage *in=cache->getByPts(vid->lastDecodedPts);
   if(!in)
   {
-    printf("[ADM_Composer::getSamePicture] Failed, while looking for Pts=%"LU" ms\n",vid->lastDecodedPts);
+    printf("[ADM_Composer::getSamePicture] Failed, while looking for Pts=%"LLU" ms\n",vid->lastDecodedPts);
     cache->dump();
     return false;
   }

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edSearch.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edSearch.cpp	2009-10-20 13:26:48 UTC (rev 5392)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edSearch.cpp	2009-10-20 17:17:18 UTC (rev 5393)
@@ -130,6 +130,7 @@
         if(pts==ADM_NO_PTS) continue;
         if(pts>refTime)
         {
+            ADM_info("Found nextkeyframe %"LLU" at frame %"LU"\n",pts/1000,i);
             *nkTime=pts;
             return true;
         }
@@ -164,6 +165,7 @@
             return true;
         }
     }
+    ADM_warning("Cannot find keyframe with PTS less than %"LU"ms\n",refTime/1000);
     return false;
 }
 

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp	2009-10-20 13:26:48 UTC (rev 5392)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp	2009-10-20 17:17:18 UTC (rev 5393)
@@ -69,6 +69,7 @@
   _imageBuffer=NULL;
   _internalFlags=0;
   _currentSegment=0;
+  _scratch=NULL;
 }
 /**
 	Remap 1:1 video to segments
@@ -555,7 +556,8 @@
 */
 bool  ADM_Composer::rebuildDuration(void)
 {
-  return true;
+  switchToSegment(0);
+  return true; nextPictureInternal(0,NULL);
 }
 /**
     \fn getCurrentFramePts

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx	2009-10-20 13:26:48 UTC (rev 5392)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx	2009-10-20 17:17:18 UTC (rev 5393)
@@ -64,7 +64,7 @@
 {
   private:
 //*********************************PRIVATE API *******************************************
-                    bool		decodeCache(uint32_t ref, uint32_t frame,ADMImage *image);
+                    //bool		decodeCache(uint32_t ref, uint32_t frame,ADMImage *image);
                     bool        switchToNextSegment(void);
                     bool        switchToSegment(uint32_t s);
                     uint32_t    currentFrame;
@@ -146,6 +146,7 @@
                     bool        goToIntraTimeVideo(uint64_t time);
                     bool        nextPicture(ADMImage *image);
                     bool        samePicture(ADMImage *image);
+                    bool        rewind(void);
 public:
                     uint8_t	    updateVideoInfo(aviInfo *info);
                     uint32_t 	getSpecificMpeg4Info( void );

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp	2009-10-20 13:26:48 UTC (rev 5392)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp	2009-10-20 17:17:18 UTC (rev 5393)
@@ -70,11 +70,21 @@
    }
    seg._durationUs=ref->_aviheader->getVideoDuration();
 
-    // Update frametype if needed...
-    _VIDEOS 	*vid=ref;
-    decoders *decoder=vid->decoder;
-//    rederiveFrameType(_videos[_nb_video]._aviheader);
+    // Set the default startTime to the pts of first Pic
+    vidHeader *demuxer=	ref->_aviheader;
+    uint32_t flags;
+    uint64_t pts,dts;
+        demuxer->getFlags(0,&flags);
+        demuxer->getPtsDts(0,&pts,&dts);
 
+        if(pts!=ADM_NO_PTS &&pts)
+        {
+            ADM_warning("The first frame has a PTS >0, adjusting to %"LLU" ms\n",pts/1000);
+//            seg._refStartTimeUs=pts;
+        }
+    //
+
+
     segments.push_back(seg);
     videos.push_back(*ref);
     updateStartTime();
@@ -98,8 +108,11 @@
             delete v->decoder;
       if(v->color)
             delete v->color;
-      v->_aviheader->close ();
-      delete v->_aviheader;
+      if(v->_aviheader)
+      {
+          v->_aviheader->close ();
+          delete v->_aviheader;
+      }
       if(v->_videoCache)
       	delete  v->_videoCache;
       v->_videoCache=NULL;
@@ -112,7 +125,9 @@
       {
             for(int i=0;i<v->nbAudioStream;i++)
             {
-                delete v->audioTracks[i];
+                if(v->audioTracks[i])
+                    delete v->audioTracks[i];
+                v->audioTracks[i]=NULL;
             }
             delete [] v->audioTracks;
             v->audioTracks=NULL;
@@ -302,7 +317,6 @@
                 *oflags=flags;
                 return true;
             }
-            if(pts!=ADM_NO_PTS &&pts>time) return false;
     }
     return false;
 }
@@ -318,6 +332,7 @@
         ADM_assert(v);
         if(false==TimeToFrame(v,seekTime,&frame,&flags))
         {
+            ADM_error("Cannot find frame with time %"LLU"ms\n",seekTime/1000);
             ADM_assert(0);
         }
         ADM_assert(flags & AVI_KEY_FRAME);

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp	2009-10-20 13:26:48 UTC (rev 5392)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp	2009-10-20 17:17:18 UTC (rev 5393)
@@ -746,7 +746,7 @@
 
 
 
-   //   admPreview::seekToIntraPts (0);
+      video_body->rewind();
       admPreview::samePicture();
       GUI_setCurrentFrameAndTime();
 

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/gui_navigate.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/gui_navigate.cpp	2009-10-20 13:26:48 UTC (rev 5392)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/gui_navigate.cpp	2009-10-20 17:17:18 UTC (rev 5393)
@@ -161,8 +161,11 @@
             }
 	  break;
       case ACT_Begin:
-        GUI_GoToKFrameTime(0);
-	  break;
+            video_body->rewind();
+            admPreview::samePicture(); // Ugly FIXME TODO
+             GUI_setCurrentFrameAndTime();
+            //GUI_GoToKFrameTime(0);
+            break;
       case ACT_JumpToFrame:
         {
               // read value



From mean at mail.berlios.de  Wed Oct 21 07:14:29 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 21 Oct 2009 07:14:29 +0200
Subject: [Avidemux-svn-commit] r5394 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor
Message-ID: <200910210514.n9L5ETRe013582@sheep.berlios.de>

Author: mean
Date: 2009-10-21 07:14:27 +0200 (Wed, 21 Oct 2009)
New Revision: 5394

Removed:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp.orig
Log:
[editor] remove unused file

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp.orig
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp.orig	2009-10-20 17:17:18 UTC (rev 5393)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp.orig	2009-10-21 05:14:27 UTC (rev 5394)
@@ -1,1591 +0,0 @@
-/***************************************************************************
-                          ADM_edit.cpp  -  description
-                             -------------------
-    begin                : Thu Feb 28 2002
-    copyright            : (C) 2002/2008 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include "config.h"
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <math.h>
-#include <string.h>
-#include <fcntl.h>
-#include <errno.h>
-
-#if defined(__MINGW32__) || defined(ADM_BSD_FAMILY)
-#include <sys/stat.h>
-#endif
-
-#include "ADM_assert.h"
-#include "fourcc.h"
-#include "ADM_editor/ADM_edit.hxx"
-#include "ADM_inputs/ADM_inpics/ADM_pics.h"
-#include "ADM_inputs/ADM_nuv/ADM_nuv.h"
-#include "ADM_inputs/ADM_h263/ADM_h263.h"
-//#include "ADM_3gp/ADM_3gp.h"
-#include "ADM_inputs/ADM_mp4/ADM_mp4.h"
-#include "ADM_inputs/ADM_openDML/ADM_openDML.h"
-#include "ADM_inputs/ADM_avsproxy/ADM_avsproxy.h"
-#include "DIA_coreToolkit.h"
-#include "ADM_editor/ADM_edit.hxx"
-#include "ADM_videoFilter.h"
-//#include "ADM_dialog/DIA_working.h"
-#include "ADM_inputs/ADM_ogm/ADM_ogm.h"
-#include "ADM_inputs/ADM_mpegdemuxer/dmx_video.h"
-#include "ADM_inputs/ADM_mpegdemuxer/dmx_identify.h"
-#include "ADM_inputs/ADM_mpegdemuxer/dmx_probe.h"
-#include "ADM_inputs/ADM_matroska/ADM_mkv.h"
-#include "ADM_inputs/ADM_flv/ADM_flv.h"
-#include "ADM_inputs/ADM_amv/ADM_amv.h"
-#include "ADM_inputs/ADM_asf/ADM_asf.h"
-#include "prefs.h"
-
-#include "ADM_osSupport/ADM_debugID.h"
-#define MODULE_NAME MODULE_EDITOR
-#include "ADM_osSupport/ADM_debug.h"
-
-#ifdef USE_DIVX
-	#include "ADM_codecs/ADM_divx4.h"
-#endif
-#include "ADM_inputs/ADM_mpegdemuxer/dmx_indexer.h"
-#include "ADM_outputfmt.h"
-//#include "ADM_gui2/GUI_ui.h"
-int DIA_mpegIndexer (char **mpegFile, char **indexFile, int *aid,
-		     int already = 0);
-void DIA_indexerPrefill(char *name);
-extern uint8_t indexMpeg (char *mpeg, char *file, uint8_t aid);
-
-extern uint8_t loadVideoCodecConf( const char *name);
-extern uint8_t parseScript(char *name);
-uint8_t UI_SetCurrentFormat( ADM_OUT_FORMAT fmt );
-const char *VBR_MSG = QT_TR_NOOP("Avidemux detected VBR MP3 audio in this file. For keeping audio/video in sync, time map is needed. Build it now?\n\nYou can do it later with \"Audio -> Build VBR Time Map\".");
-//
-//
-
-#define TEST_MPEG2DEC
-
-ADM_Composer::ADM_Composer (void) : ADM_audioStream(NULL,NULL)
-{
-uint32_t type,value;
-   audioBufferStart=0;
-   audioBufferEnd=0;
-  _nb_segment = 0;
-  _nb_video = 0;
-  _total_frames = 0;
-  _audioseg = 0;
-  _audiooffset = 0;
-  _audioSample=0;
-  _lastseg = 99;
-  _lastframe = 99;
-  _nb_clipboard=0;
-  _haveMarkers=0; // only edl have markers
-  // Initialize a default postprocessing (dummy)
-  initPostProc(&_pp,16,16);
-  if(!prefs->get(DEFAULT_POSTPROC_TYPE,&type)) type=3;
-  if(!prefs->get(DEFAULT_POSTPROC_VALUE,&value)) value=3;
-
-  _pp.postProcType=type;
-  _pp.postProcStrength=value;
-  _pp.swapuv=0;
-  _pp.forcedQuant=0;
-  updatePostProc(&_pp);
-  _imageBuffer=NULL;    
-  _internalFlags=0;
-  // Start with a clean base
-  memset (_videos, 0, sizeof (_videos));
-  max_seg = MAX_SEG;
-  _segments = new _SEGMENT[max_seg];
-  memset (_segments, 0, sizeof (_segments));
-  _scratch=NULL;
-  
-}
-/**
-	Remap 1:1 video to segments
-
-*/
-uint8_t ADM_Composer::resetSeg( void )
-{
-	_total_frames=0;
-	for(uint32_t i=0;i<_nb_video;i++)
-	{
-		_segments[i]._reference = i;
-  		_segments[i]._audio_size = _videos[i]._audio_size;
-  		_segments[i]._audio_start = 0;
-  		_segments[i]._start_frame = 0;
-		_segments[i]._audio_duration = 0;		
-		_segments[i]._nb_frames   =   _videos[i]._nb_video_frames ;
-		_total_frames+=_segments[i]._nb_frames  ;
-		updateAudioTrack (i);
-	}
-
-  	_nb_segment=_nb_video;
-  	computeTotalFrames();
-	dumpSeg();
-	return 1;
-}
-/**
-	Return extra Header info present in avi chunk that are needed to initialize
-	the video codec
-	It is assumed that there is only one file or can share the same init data
-	(huffyuv for example)
-*/
-uint8_t ADM_Composer::getExtraHeaderData (uint32_t * len, uint8_t ** data)
-{
-  return _videos[0]._aviheader->getExtraHeaderData (len, data);
-
-}
-
-
-/**
-	Purge all segments
-*/
-uint8_t ADM_Composer::deleteAllSegments (void)
-{
-
-
-  memset (_segments, 0, sizeof (_segments));
-  _nb_segment = 0;
-  _total_frames=computeTotalFrames();
-  return 1;
-
-}
-
-/**
-	\fn Purge all videos
-    \brief delete datas associated with all video
-*/
-void
-ADM_Composer::deleteAllVideos (void)
-{
-
-  for (uint32_t vid = 0; vid < _nb_video; vid++)
-    {
-
-      // if there is a video decoder...
-      if (_videos[vid].decoder)
-            delete _videos[vid].decoder;
-      if(_videos[vid].color)
-            delete _videos[vid].color;
-      // prevent from crashing
-      _videos[vid]._aviheader->close ();
-      delete _videos[vid]._aviheader;
-      if(_videos[vid]._videoCache)
-      	delete  _videos[vid]._videoCache;
-      _videos[vid]._videoCache=NULL;
-     // Delete audio codec too
-     // audioStream will be deleted by the demuxer
-      if(_videos[vid]._audioCodec)
-        delete _videos[vid]._audioCodec;
-      _videos[vid]._audioCodec=NULL;
-    }
-
-  memset (_videos, 0, sizeof (_videos));
-  
-  
-  if(_imageBuffer)
-  	delete _imageBuffer;
-  _imageBuffer=NULL;
-
-}
-
-ADM_Composer::~ADM_Composer ()
-{
-	deleteAllSegments();
-	deleteAllVideos();
-	deletePostProc(&_pp);
-
-	if(_segments)
-	{
-		delete[] _segments;
-		_segments=NULL;
-	}
-	if(_scratch)
-	{
-		delete _scratch;
-		_scratch=NULL;
-	}
-}
-
-/*
-   			Return Magic : 4*4 bytes first
-
-*/
-
-/**
-    \fn addFile
-    \brief	Load or append a file.	The file type is determined automatically and the ad-hoc video decoder is spawned
-    
-    @param name: filename
-    @param mode: 0 open, 1 append
-    @param forcedType : if !=Unknown_FileType, it enables to force the file type
-
-    @return 1 on success, 0 on failure
-        
-
-*/
-uint8_t ADM_Composer::addFile (const char *name, uint8_t mode,fileType forcedType)
-{
-  uint8_t    ret =    0;
-  aviInfo    info;
-  WAVHeader *    _wavinfo;
-//  aviHeader *    tmp;
-  fileType    type =    forcedType;
-
-UNUSED_ARG(mode);
-	_haveMarkers=0; // by default no markers are present
-  ADM_assert (_nb_segment < max_seg);
-  ADM_assert (_nb_video < MAX_VIDEO);
-
-  // Autodetect file type ?
-  if(Unknown_FileType==type)
-  {
-      if (!identify (name, &type))
-        return 0;
-  }
-
-
-#define OPEN_AS(x,y) case x:\
-						_videos[_nb_video]._aviheader=new y; \
-						 ret = _videos[_nb_video]._aviheader->open(name); \
-						break;
-#if 0 // BAZOOKA
-  switch (type)
-    {
-      case VCodec_FileType:
-      		loadVideoCodecConf(name);      		
-		return ADM_IGN; // we do it but it wil fail, no problem with that
-      		break;
-      OPEN_AS (Mp4_FileType, mp4Header);
-      OPEN_AS (H263_FileType, h263Header);
-      
-      case ASF_FileType:
-              _videos[_nb_video]._aviheader=new asfHeader; 
-              ret = _videos[_nb_video]._aviheader->open(name); 
-              if(!ret)
-              {
-                delete _videos[_nb_video]._aviheader;
-                printf("Trying mpeg\n"); 
-                goto thisIsMpeg; 
-              }
-              break;
-      OPEN_AS (NewMpeg_FileType,dmxHeader);
-      // For AVI we first try top open it as openDML
-      case AVI_FileType:
-      			_videos[_nb_video]._aviheader=new OpenDMLHeader; 
-			 ret = _videos[_nb_video]._aviheader->open(name); 			
-			break;
-      
-    case Nuppel_FileType:
-	{ // look if the idx exists
-	  char *tmpname = (char*)ADM_alloc(strlen(name)+strlen(".idx")+1);
-		ADM_assert(tmpname);
-		sprintf(tmpname,"%s.idx",name);
-		if(addFile(tmpname))
-		{
-			return 1; // Memleak ?
-		}
-		ADM_dealloc(tmpname);
-		// open .nuv file
-		_videos[_nb_video]._aviheader=new nuvHeader;
-		ret = _videos[_nb_video]._aviheader->open(name);
-		// we store the native .nuv file in the edl
-		// the next load of the edl will open .idx instead
-		break;
-	}
-      OPEN_AS (BMP_FileType, picHeader);
-      OPEN_AS (Matroska_FileType, mkvHeader);
-      OPEN_AS (FLV_FileType, flvHeader);
-      OPEN_AS (AvsProxy_FileType, avsHeader);
-      OPEN_AS (_3GPP_FileType, MP4Header);
-      OPEN_AS (Ogg_FileType, oggHeader);
-      OPEN_AS (AMV_FileType, amvHeader);
-
-    case Mpeg_FileType:
-thisIsMpeg:
-    	// look if the idx exists
-	char tmpname[256];
-	ADM_assert(strlen(name)+5<256);
-	strcpy(tmpname,name);
-	strcat(tmpname,".idx");
-        if(ADM_fileExist(tmpname))
-        {
-	       return addFile(tmpname);
-        }
-	/* check for "Read-only file system" */
-	{
-                int fd = open(tmpname,O_CREAT|O_EXCL|O_WRONLY,S_IRUSR|S_IWUSR);
-                if( fd >= 0 )
-                {
-                    close(fd);
-                    unlink(tmpname);
-                    printf("Filesystem is writable\n");
-		}else if( errno == EROFS ){
-		  char *tmpdir = getenv("TMPDIR");
-#ifdef __WIN32
-                        printf("Filesystem is not writable, looking for somewhere else\n");
-			if( !tmpdir )
-				tmpdir = "c:";
-			snprintf(tmpname,256,"%s%s.idx",tmpdir,strrchr(name,'\\'));
-#else
-			if( !tmpdir )
-				tmpdir = "/tmp";
-			snprintf(tmpname,256,"%s%s.idx",tmpdir,strrchr(name,'/'));
-#endif
-			tmpname[255] = 0;
-                        printf("Storing index in %s\n",tmpname);
-                    if(ADM_fileExist(tmpname))
-                    {
-                        printf("Index present, loading it\n");
-                        return addFile(tmpname);
-                    }
-                }
-        }
-        if(tryIndexing(name,tmpname))
-        {
-                return addFile (tmpname);
-        }
-        return 0;
-      break;
-	case WorkBench_FileType:
-
-  		return loadWorbench(name);
-#if 0
-        case Script_FileType:
-                return parseScript(name);
-#endif
-	case ECMAScript_FileType:
-                printf("****** This is an ecmascript, run it with avidemux2 --run yourscript *******\n");
-                printf("****** This is an ecmascript, run it with avidemux2 --run yourscript *******\n");
-                printf("****** This is an ecmascript, run it with avidemux2 --run yourscript *******\n");
-                return 0;
-		
-                
-    default:
-      if (type == Unknown_FileType)
-	{
-	  printf ("\n not identified ...\n");
-	}
-      else
-        GUI_Error_HIG(QT_TR_NOOP("File type identified but no loader support detected..."),
-                      QT_TR_NOOP("May be related to an old index file."));
-      return 0;
-    }
-#else // BAZOOKA
-switch (type)
-    {
-        case AVI_FileType:
-            _videos[_nb_video]._aviheader=new OpenDMLHeader; 
-            ret = _videos[_nb_video]._aviheader->open(name); 			
-            break;
-        OPEN_AS (NewMpeg_FileType,dmxHeader);
-         
-
-    }
-#endif // BAZOOKA
-   // check opening was successful
-   if (ret == 0) {
-     char str[512+1];
-     snprintf(str,512,QT_TR_NOOP("Attempt to open %s failed!"), name);
-      str[512] = '\0';
-      GUI_Error_HIG(str,NULL);
-      delete _videos[_nb_video]._aviheader;
-      return 0;
-   }
-
-   /* check for resolution */
-   if( _nb_video ){
-      /* append operation */
-      aviInfo info0, infox;
-      _videos[   0     ]._aviheader->getVideoInfo (&info0);
-      _videos[_nb_video]._aviheader->getVideoInfo (&infox);
-      if( info0.width != infox.width || info0.height != infox.height ){
-        char str[512+1];
-         str[0] = '\0';
-         if( info0.width != infox.width )
-            strcpy(str,"width");
-         if( info0.height != infox.height )
-            snprintf(str+strlen(str),512-strlen(str),
-              "%sheight%sdifferent between first and this video stream",
-                 (strlen(str)?" and ":""),
-                 (strlen(str)?" are ":" is ") );
-         str[512] = '\0';
-         GUI_Error_HIG(str,QT_TR_NOOP("You cannot mix different video dimensions yet. Using the partial video filter later, will not work around this problem. The workaround is:\n1.) \"resize\" / \"add border\" / \"crop\" each stream to the same resolution\n2.) concatinate them together"));
-         delete _videos[_nb_video]._aviheader;
-         return 0;
-      }
-   }
- 
-  // else update info
-  _videos[_nb_video]._aviheader->getVideoInfo (&info);
-  _videos[_nb_video]._aviheader->setMyName (name);
-  
-  // Printf some info about extradata
-  {
-    uint32_t l=0;
-    uint8_t *d=NULL;
-    _videos[_nb_video]._aviheader->getExtraHeaderData(&l,&d);
-    if(l && d)
-    {
-        printf("The video codec has some extradata (%d bytes)\n",l);
-        mixDump(d,l);
-        printf("\n");
-    }
-  }
-  // 1st if it is our first video we update postproc
- if(!_nb_video)
- {
-        uint32_t type,value;
-
-        if(!prefs->get(DEFAULT_POSTPROC_TYPE,&type)) type=3;
-        if(!prefs->get(DEFAULT_POSTPROC_VALUE,&value)) value=3; 	
-
-	deletePostProc(&_pp );
- 	initPostProc(&_pp,info.width,info.height);
-	_pp.postProcType=type;
-	_pp.postProcStrength=value;
-	_pp.forcedQuant=0;
-	updatePostProc(&_pp);
-
-	if(_imageBuffer) delete _imageBuffer;
-	_imageBuffer=new ADMImage(info.width,info.height);
- 	_imageBuffer->_qSize= ((info.width+15)>>4)*((info.height+15)>>4);
-	_imageBuffer->quant=new uint8_t[_imageBuffer->_qSize];
-	_imageBuffer->_qStride=(info.width+15)>>4;
- }
-    
- 
-//    fourCC::print( info.fcc );
-  _total_frames += info.nb_frames;
-  _videos[_nb_video]._nb_video_frames = info.nb_frames;
-
-
-  // Update audio infos
-  // an spawn the appropriate decoder
-  //_________________________
-  _wavinfo = _videos[_nb_video]._aviheader->getAudioInfo ();	//wavinfo); // will be null if no audio
-  if (!_wavinfo)
-    {
-      printf ("\n *** NO AUDIO ***\n");
-      _videos[_nb_video]._audiostream = NULL;
-      _videos[_nb_video]._audioCodec=NULL;
-    }
-  else
-    {
-      float duration;
-      uint32_t extraLen;
-      uint8_t  *extraData;
-      _videos[_nb_video]._aviheader->getAudioStream (&_videos[_nb_video]. _audiostream);
-
-      ADM_audioStream *stream=_videos[_nb_video]. _audiostream;
-      stream->getExtraData(&extraLen,&extraData);
-      duration=stream->getDurationInUs();
-      duration*=stream->getInfo()->frequency;
-      duration/=1000*1000.; // Us -> seconds
-  	  _videos[_nb_video]._audio_duration=(uint64_t)floor(duration);
-      _videos[_nb_video]._audioCodec=getAudioCodec(_wavinfo->encoding,_wavinfo,extraLen,extraData);
-      printf("[Editor] Duration in seconds: %"LLU", in samples: %"LLU"\n",_videos[_nb_video]._audio_duration/_wavinfo->frequency,_videos[_nb_video]._audio_duration);
-    }
-
-  printf ("\n Decoder FCC: ");
-  fourCC::print (info.fcc);
-  // ugly hack
-  if (info.fps1000 > 2000 * 1000)
-    {
-      printf (" FPS too high, switching to 25 fps hardcoded\n");
-      info.fps1000 = 25 * 1000;
-      updateVideoInfo (&info);
-    }
-  uint32_t    	l;
-  uint8_t 	*d;
-  _videos[_nb_video]._aviheader->getExtraHeaderData (&l, &d);
-  _videos[_nb_video].decoder = getDecoder (info.fcc,  info.width, info.height, l, d,info.bpp);
-
-  _videos[_nb_video]._videoCache   =   new EditorCache(10,info.width,info.height) ;
-  //
-  //  And automatically create the segment
-  //
-  _segments[_nb_segment]._reference = _nb_video;
-  _segments[_nb_segment]._audio_size = _videos[_nb_video]._audio_size;
-  _segments[_nb_segment]._audio_duration =_videos[_nb_video]._audio_duration;
-  _segments[_nb_segment]._audio_start = 0;
-  _segments[_nb_segment]._start_frame = 0;
-  _segments[_nb_segment]._nb_frames   =   _videos[_nb_video]._nb_video_frames ;
-
-  _videos[_nb_video]._isAudioVbr=0;
-//****************************
-   
-
-  // next one please
-        if(_wavinfo)
-        if(_wavinfo->encoding==WAV_MP3 && _wavinfo->blockalign==1152)
-        {
-          uint32_t autovbr=0;
-          prefs->get(FEATURE_AUTO_BUILDMAP,&autovbr);
-          if(autovbr || GUI_Confirmation_HIG(QT_TR_NOOP("Build Time Map"),QT_TR_NOOP( "Build VBR time map?"), VBR_MSG))
-                {
-               // _videos[_nb_video]._isAudioVbr=_videos[_nb_video]._audiostream->buildAudioTimeLine ();
-                }
-        }
-
-	_nb_video++;
-	_nb_segment++;
-
-//______________________________________
-// 1-  check for B _ frame  existence
-// 2- check  for consistency with reported flags
-//______________________________________
-	uint8_t count=0;
-TryAgain:	
-	_VIDEOS 	*vid;
-	uint32_t err=0;
-
-		vid= &(_videos[_nb_video-1]);
-		vid->_reorderReady=0;
-                vid->_unpackReady=0;
-		// we only try if we got everything needed...
-		if(!vid->decoder)
-		{
-			printf("\n no decoder to check for B- frame\n");
-			return 1;
-		}
-		if(!vid->decoder->bFramePossible())
-		{
-			printf("\n no  B- frame with that codec \n");
-			return 1;
-		}
-                if(isH264Compatible(info.fcc))
-                {
-                  if(getEnv(ENV_EDITOR_X264) || GUI_Confirmation_HIG(QT_TR_NOOP("Use safe mode"),QT_TR_NOOP("H.264 detected"),QT_TR_NOOP("If the file is using B-frames as reference it can lead to a crash or stuttering.\nAvidemux can use another mode which is safe but YOU WILL LOSE FRAME ACCURACY.\nDo you want to use that mode?")))
-                    {
-                              printf("Switching to non low delay codec\n");
-                              _videos[_nb_video-1].decoder = getDecoderH264noLogic (info.fcc,  info.width, info.height, l, d);
-                              return 1;
-                    }
-
-
-                }
-		printf("\n checking for B-Frames...\n");
-		if( vid->_nb_video_frames > 12)
-		{
-				uint8_t 		*bufferin;
-				uint32_t 		len,flags;
-				uint8_t 		bframe=0, bconsistency=1;
-				uint32_t		scanned;
-                                ADMImage                *buffer=NULL;
-
-				if(vid->_nb_video_frames > (info.fps1000 * 5) / 1000)
-					scanned = (info.fps1000 * 5) / 1000;
-				else				scanned=vid->_nb_video_frames;
-
-				printf(" scanning %lu frames\n", scanned);
-				
-				bufferin=new uint8_t [info.width* info.height*2];
-                                if(vid->decoder->dontcopy())
-                                        buffer=new ADMImage(info.width,info.height,1);
-                                else
-				        buffer=new ADMImage(info.width,info.height);
-
-                                ADMCompressedImage img;
-                                img.data=bufferin;
-				for(uint32_t i=0;i<scanned;i++)  //10
-				{
-					flags=0;
-  					vid->_aviheader->getFrameNoAlloc (i,&img);
-                                        if(!img.dataLength) continue;
-					if(!vid->decoder->uncompress( &img,buffer ))
-					{
-						err++;
-						printf("\n ***oops***\n");
-					}
-
-					if(i<5) continue; // ignore the first frames
-					
-					// check if it is a b-frame
-					//printf(" %lu : %lu \n",i,flag2);
-					if(buffer->flags & AVI_B_FRAME)
-					{
-						printf(" * ");
-					 	bframe=1;
-						vid->_aviheader->getFlags(i,&flags);
-						if(!(flags & AVI_B_FRAME))
-                                                {
-                                                        printf("Frame %lu is A B frame, flag not ok\n",i);
-							bconsistency=0;
-                                                }
-						else
-							printf("# ");
-					}
-					if((i%16)==15) printf("\n");
-				}
-                                printf("\n");
-				delete  buffer;
-				delete [] bufferin;
-				if(getEnv(ENV_EDITOR_BFRAME))
-				{
-					printf("Forcing Bframe present and incorrect\n");
-					bframe=1;
-					bconsistency=0;
-					
-				}
-                                uint32_t ffcheck=vid->decoder->isDivxPacked ();
-                                if(ffcheck)
-                                {
-                                  printf("[Editor] Decoder says it is vop packed\n");
-                                }
-				if(bframe || ffcheck)
-				{
-					printf("\n Mmm this appear to have b-frame...\n");
-					if(bconsistency )
-					{
-						printf("\n And the index is ok\n");
-
-						//uint8_t [720*576*3];
-						vid->_reorderReady=vid->_aviheader->reorder();
-						if(vid->_reorderReady)
-						{
-							printf("\n Frames re-ordered, B-frame friendly now :)\n");
-							aprintf(" we had :%lu",info.nb_frames);
-							// update nb frame in case we dropped some
-							_total_frames -= info.nb_frames;
-							_videos[_nb_video-1]._aviheader->getVideoInfo (&info);
-							aprintf(" we have now  :%lu",info.nb_frames);
-							_total_frames += info.nb_frames;
-  							_videos[_nb_video-1]._nb_video_frames = info.nb_frames;
-						}
-						else
-						{
-							printf("\n Frames not  re-ordered, expect problem with b-frames\n");
-						}
-
-					}
-					else
-					{
-						printf("\n But the  index is not up to date \n");
-						uint32_t ispacked=0;
-                                                
-                                                uint32_t ff=vid->decoder->isDivxPacked ();
-                                                if(ff)
-                                                {
-                                                  printf("[Editor] Decoder says it is vop packed\n");
-                                                }
-                                                
-						// If it is Divx 5.0.xxx use divx decoder
-						if(isMpeg4Compatible(info.fcc))
-						{
-
-
-							//if(vid->decoder->isDivxPacked())
-							uint8_t forced= getEnv(ENV_EDITOR_PVOP);
-							if(ff ||forced)
-							{
-								
-								// can only unpack avi
-								if(!count && type==AVI_FileType)
-								{
-                                                                  uint32_t autounpack=0;
-                                                                  prefs->get(FEATURE_AUTO_UNPACK,&autounpack);
-									if( forced || autounpack || GUI_YesNo(
-                                                                                QT_TR_NOOP("Packed Bitstream detected"),
-                                                                        QT_TR_NOOP("Do you want me to unpack it ?")))
-									{
-									OpenDMLHeader *dml=NULL;
-									count++;	
-									dml=(OpenDMLHeader *)vid->_aviheader;
-									// Can we repack it ?
-									if(dml->unpackPacked())
-									{
-                                                                                // Set ouput to avi vop
-                                                                                UI_SetCurrentFormat(ADM_AVI_UNP);
-                                                                                // Create a new decoder
-                                                                                // As the current one have already decoded
-                                                                                // some pics
-                                                                                delete  _videos[_nb_video-1].decoder;
-                                                                                _videos[_nb_video-1].decoder=NULL;
-                                                                                printf("Creating fresh decoder\n");
-                                                                                 _videos[_nb_video-1].decoder = getDecoder (info.fcc,
-                                           info.width, info.height, l, d);
-										goto TryAgain;
-									}
-                                                                        GUI_Error_HIG(QT_TR_NOOP("Could not unpack the video"),QT_TR_NOOP( "Using backup decoder - not frame accurate."));
-									}
-								}
-#if  1 //def USE_DIVX
-                                                                if(count)
-                                                                        GUI_Info_HIG(ADM_LOG_IMPORTANT,QT_TR_NOOP("Weird"),QT_TR_NOOP( "The unpacking succeedeed but the index is still not up to date."));
-								printf("\n Switching codec...\n");
-								delete vid->decoder;
-								vid->decoder=getDecoderVopPacked(info.fcc, info.width,info.height,0,NULL);
-								ispacked=1;
-#else
-								GUI_Info_HIG(ADM_LOG_IMPORTANT,QT_TR_NOOP("Troubles ahead"), QT_TR_NOOP("This a VOP packed AVI."));
-#endif
-
-							}
-
-						}
-						// else warn user
-						if(!ispacked)
-                                                {
-                                                   uint32_t reindex=0;
-                                                  prefs->get(FEATURE_AUTO_REBUILDINDEX,&reindex);
-                                                  if(reindex || GUI_YesNo(QT_TR_NOOP("Index is not up to date"),QT_TR_NOOP("You should use Tool->Rebuild frame. Do it now ?")))
-                                                        {
-                                                                rebuildFrameType();
-							}
-                                                }
-					}
-				}
-				else
-				{
-					printf("Seems it does not contain B-frames...\n");
-				}
-		printf(" End of B-frame check\n");
-		}
-  return 1;
-}
-/**
-	Send a re-order order to all video if
-		- They may need it
-		- It is not already done.
-*/
-uint8_t ADM_Composer::reorder (void)
-{
-_VIDEOS *vid;
-	for(uint32_t i=0;i<_nb_video;i++)
-	{
-		vid=&_videos[i];
-		if(!vid->_reorderReady) // not already reordered ?
-		{
-				if(vid->decoder->bFramePossible()) // can be re-ordered ?
-				{
-						if((vid->_reorderReady=vid->_aviheader->reorder()))
-						{
-							aviInfo    info;
-							_videos[i]._aviheader->getVideoInfo (&info);
-                                                        
-							printf(" Video %lu has been reordered\n",i);
-						}
-
-				}
-		}
-	}
-	return 1;
-}
-/*
-        If one of the videos has VBR audio we handle the whole editor audio has VBR
-        If it is CBR, it is not harmful 
-        and it avoid loosing the VBR info in case we do VBR time map upon loading
-*/
-uint8_t ADM_Composer::hasVBRVideos(void)
-{
-        for(int i=0;i<_nb_video;i++)
-                if(_videos[i]._isAudioVbr) return 1;
-        return 0;
-}
-
-/*
-
-*/
-uint32_t ADM_Composer::getPARWidth()
-{
-  if (_nb_video)
-  {
-    return _videos[0].decoder->getPARWidth();
-  }
-  return 1;
-
-}
-
-uint32_t ADM_Composer::getPARHeight()
-{
-  if (_nb_video)
-  {
-    return _videos[0].decoder->getPARHeight();
-  }
-  return 1;
-
-}
-
-/**
-	Set decoder settings (post process/swap u&v...)
-	for the segment referred by frame
-
-*/
-uint8_t ADM_Composer::setDecodeParam (uint32_t frame)
-{
-uint32_t seg,relframe,ref;
-  if (_nb_video)
-  {
-   if (!convFrame2Seg (frame, &seg, &relframe))
-    {
-      printf ("\n Conversion failed !\n");
-      return 0;
-    }
-    // Search source
-     ref = _segments[seg]._reference;
-    _videos[ref].decoder->setParam ();        
-  }
-  return 1;
-
-}
-
-/**
-	Free all allocated memory and destroy all editors object
-
-
-*/
-uint8_t ADM_Composer::cleanup (void)
-{
-  deleteAllSegments ();
-  deleteAllVideos ();
-  _nb_segment = 0;
-  _nb_video = 0;
-  _total_frames = 0;
-
-	if(_scratch)
-	{
-		delete _scratch;
-		_scratch=NULL;
-	}
-
-  return 1;
-}
-/*
-        param:
-                source : source #
-                start : start frame in source #
-                nb    : nb frame to copy into segment
-*/
-uint8_t ADM_Composer::addSegment(uint32_t source,uint32_t start, uint32_t nb)
-{
-        // do some sanity check
-        if(_nb_segment==max_seg-1)
-	{
-	   _SEGMENT *s;
-            max_seg += MAX_SEG;
-            s = new _SEGMENT[max_seg];
-            memset (s, 0, sizeof(_SEGMENT)*max_seg);
-            memcpy(s,_segments,sizeof(_SEGMENT)*(max_seg-MAX_SEG));
-            delete _segments;
-            _segments = s;
-        }
-        if(_nb_video<=source)
-        {
-                printf("[editor]: No such source %d/%d\n",source,_nb_video);
-                 return 0;
-        }
-        if(_videos[source]._nb_video_frames<=start)
-        {
-                printf("[editor]:start out of bound %d/%d\n",start,_videos[source]._nb_video_frames);
-                 return 0;
-        }
-        if(_videos[source]._nb_video_frames<start+nb)
-        {
-                printf("[editor]:end out of bound %d/%d\n",start+nb,_videos[source]._nb_video_frames);
-                 return 0;
-        }
-        // ok, let's go
-        _SEGMENT *seg=&(_segments[_nb_segment]);
-        seg->_reference=source;
-        seg->_start_frame=start;
-        seg->_nb_frames=nb;
-        _nb_segment++;
-        updateAudioTrack (_nb_segment-1);
-        _total_frames=computeTotalFrames();
-
-        return 1;
-}
-/**
-______________________________________________________
-//  Remove frames , the frame are given as seen by GUI
-//  We remove from start to end -1
-// [start,end[
-//______________________________________________________
-*/
-uint8_t ADM_Composer::removeFrames (uint32_t start, uint32_t end)
-{
-
-  uint32_t
-    seg1,
-    seg2,
-    rel1,
-    rel2;
-  uint8_t
-    lastone =
-    0;
-
-  if (end == _total_frames - 1)
-    lastone = 1;
-
-  // sanity check
-  if (start > end)
-    return 0;
-  //if((1+start)==end) return 0;
-
-  // convert frame to block, relative frame
-  if (!convFrame2Seg (start, &seg1, &rel1) ||
-      !convFrame2Seg (end, &seg2, &rel2))
-    {
-      ADM_assert (0);
-    }
-  // if seg1 != seg2 we can just modify seg1 and seg2
-  if (seg1 != seg2)
-    {
-      // remove end of seg1
-
-      removeFrom (rel1, seg1, 1);
-      //  delete in between seg
-      for (uint32_t seg = seg1 + 1; seg < (seg2); seg++)
-	_segments[seg]._nb_frames = 0;
-      // remove beginning of seg2
-      removeTo (rel2, seg2, lastone);
-    }
-  else
-    {
-      // it is in the same segment, split it...
-      // complete seg ?
-      if ((rel1 == _segments[seg1]._start_frame)
-	  && (rel2 ==
-	      (_segments[seg1]._start_frame +
-	       _segments[seg1]._nb_frames - 1)))
-	{
-	  _segments[seg1]._nb_frames = 0;
-	}
-      else
-	{
-	  // split in between.... duh !
-	  duplicateSegment (seg1);
-	  //
-	  removeFrom (rel1, seg1, 1);
-	  removeTo (rel2, seg1 + 1, lastone);
-	}
-    }
-
-  // Crunch
-  crunch ();
-  sanityCheck ();
-  // Compute total nb of frame
-  _total_frames = computeTotalFrames ();
-  printf ("\n %lu frames ", _total_frames);
-  return 1;
-
-}
-//******************************
-// Select audio track
-//
-//******************************
-uint8_t ADM_Composer::getAudioStreamsInfo(uint32_t frame,uint32_t *nbStreams, audioInfo **infos)
-{
-uint32_t seg,rel,reference;
-
-        if (!convFrame2Seg (frame, &seg, &rel))
-        {
-                printf("Editor : frame2seg failed (%u)\n",frame);
-                return 0;
-        }
-        reference=_segments[seg]._reference;
-        return _videos[reference]._aviheader->getAudioStreamsInfo(nbStreams,infos);
-}
-/*
-        Change the audio track for the source video attached to the "frame" frame
-
-*/
-uint32_t ADM_Composer::getCurrentAudioStreamNumber(uint32_t frame)
-{
-uint32_t   seg,rel,reference;
-
-        if (!convFrame2Seg (frame, &seg, &rel))
-        {
-                printf("Editor : frame2seg failed (%u)\n",frame);
-                return 0;
-        }
-        reference=_segments[seg]._reference;
-        return _videos[reference]._aviheader->getCurrentAudioStreamNumber();
-}
-uint8_t ADM_Composer::changeAudioStream(uint32_t frame,uint32_t newstream)
-{
-uint32_t   seg,rel,reference;
-double     duration;
-WAVHeader *wav;
-aviInfo    info;
-
-        if (!convFrame2Seg (frame, &seg, &rel))
-        {
-                printf("Editor : frame2seg failed (%u)\n",frame);
-                return 0;
-        }
-        reference=_segments[seg]._reference;
-        if(!_videos[reference]._aviheader->changeAudioStream(newstream))
-        {
-                printf("Editor : stream change failed for frame %u seg %u stream %u\n",frame,seg,newstream);
-                return 0;
-        }
-        // Now update audio tracks infos
-        wav = _videos[reference]._aviheader->getAudioInfo ();
-        if(!wav)
-        {
-                ADM_assert(0); // Cannot change to a non existing track!
-        }
-        _videos[reference]._aviheader->getVideoInfo (&info);
-        _videos[reference]._aviheader->getAudioStream (&_videos[reference]._audiostream);
-
-        duration=_videos[reference]._nb_video_frames;
-        duration/=info.fps1000;
-        duration*=1000;                 // duration in seconds
-        duration*=wav->frequency;          // In sample
-        _videos[reference]._audio_duration=(uint64_t)floor(duration);
-        for(uint32_t i=0;i<_nb_segment;i++)
-                updateAudioTrack(i);
-        return 1;
-}
-
-/**
-______________________________________________________
-//
-//	Copy the start/eng seg  to clipboard
-//______________________________________________________
-*/
-uint8_t ADM_Composer::copyToClipBoard (uint32_t start, uint32_t end)
-{
-
-  uint32_t	    seg1,    seg2,    rel1,    rel2;
-  uint8_t    lastone =    0;
-uint32_t seg=0xfff;
-
-  if (end == _total_frames - 1)
-    lastone = 1;
-
-  // sanity check
-  if (start > end)
-  {
-    printf("End < Start \n");
-    return 0;
-   }
-  //if((1+start)==end) return 0;
-
-  // convert frame to block, relative frame
-  if (!convFrame2Seg (start, &seg1, &rel1) ||
-      !convFrame2Seg (end, &seg2, &rel2))
-    {
-      ADM_assert (0);
-    }
-    _nb_clipboard=0;
-  // if seg1 != seg2 we can just modify seg1 and seg2
-  if (seg1 != seg2)
-    {
-    aprintf("Diff  seg: %lu /%lu from %lu to %lu \n",seg1,seg2,rel1,rel2);
-      // remove end of seg1
-	_clipboard[_nb_clipboard]._reference=_segments[seg1]._reference;
-	_clipboard[_nb_clipboard]._start_frame=rel1;
- 	_clipboard[_nb_clipboard]._nb_frames =_segments[seg]._nb_frames- (rel1 - _segments[seg]._start_frame);
-	_nb_clipboard++;
-      // copy  in between seg
-      for ( seg = seg1 + 1; seg <=seg2; seg++)
-		memcpy(&_clipboard[_nb_clipboard++], &_segments[seg],sizeof(_segments[0]));
-      // Adjust nb frame for last seg
-      uint32_t l;
-      l=_nb_clipboard-1;
-	_clipboard[l]._nb_frames=rel2-_segments[seg2]._start_frame;
-    }
-  else
-    {
-      // it is in the same segment, split it...
-      // complete seg ?
-      if ((rel1 == _segments[seg1]._start_frame)
-	  && (rel2 ==
-	      (_segments[seg1]._start_frame +
-	       _segments[seg1]._nb_frames - 1)))
-	{
-	  aprintf("Full seg: %lu from %lu to %lu \n",seg1,rel1,rel2);
-		memcpy(&_clipboard[_nb_clipboard++], &_segments[seg1],sizeof(_segments[0]));
-	}
-      else
-	{
-	  // we just take a part of one chunk
-	  aprintf("Same seg: %lu from %lu to %lu \n",seg1,rel1,rel2);
-	  memcpy(&_clipboard[_nb_clipboard], &_segments[seg1],sizeof(_segments[0]));
-	  _clipboard[_nb_clipboard]._start_frame=rel1;
-	  _clipboard[_nb_clipboard]._nb_frames=rel2-rel1;
-	_nb_clipboard++;
-	aprintf("clipboard: %lu \n",_nb_clipboard);
-	}
-    }
-	dumpSeg();
-  return 1;
-
-}
-uint8_t ADM_Composer::pasteFromClipBoard (uint32_t whereto)
-{
-uint32_t rel,seg;
-
-	if (!convFrame2Seg (whereto, &seg, &rel) )
-    	{
-      		ADM_assert (0);
-    	}
-	dumpSeg();
-
-	// past at frame 0
-	if(	seg==0 && rel==_segments[0]._start_frame)
-	{
-		aprintf("Pasting at frame 0\n");
-		for(uint32_t i=0;i<_nb_clipboard;i++)
-			duplicateSegment(seg);
-		memcpy(&_segments[0],&_clipboard[0],_nb_clipboard*sizeof(_clipboard[0]));
-	}
-	else
-	if(rel==_segments[seg]._start_frame+_segments[seg]._nb_frames )
-	{
-		aprintf("\n setting at the end of seg %lu\n",seg);
-		// we put it after OLD insert OLD+1
-		for(uint32_t i=0;i<_nb_clipboard;i++)
-			duplicateSegment(seg);
-		memcpy(&_segments[seg+1],&_clipboard[0],_nb_clipboard*sizeof(_clipboard[0]));
-
-	}
-	else // need to split it
-	{
-		for(uint32_t i=0;i<_nb_clipboard+1;i++)
-			duplicateSegment(seg);
-		memcpy(&_segments[seg+1],&_clipboard[0],_nb_clipboard*sizeof(_clipboard[0]));
-
-		// and the last one
-		_segments[seg+_nb_clipboard+1]._nb_frames=(_segments[seg]._start_frame+_segments[seg]._nb_frames)-rel;
-		_segments[seg+_nb_clipboard+1]._start_frame=rel;
-		// adjust the current one
-		_segments[seg]._nb_frames=rel-_segments[seg]._start_frame;
-	}
-	 _total_frames = computeTotalFrames ();
-	for(uint32_t i=0;i<_nb_segment;i++)
- 		updateAudioTrack(i);
-  dumpSeg();
-  return 1;
-
-}
-
-//____________________________________
-//      Duplicate a segment
-//____________________________________
-
-uint8_t ADM_Composer::duplicateSegment (uint32_t segno)
-{
-
-  for (uint32_t i = _nb_segment; i > segno; i--)
-    {
-
-      memcpy (&_segments[i], &_segments[i - 1], sizeof (_SEGMENT));
-
-    }
-  _nb_segment++;
-  return 1;
-
-
-}
-
-//____________________________________
-//      Remove empty segments
-//____________________________________
-uint8_t ADM_Composer::crunch (void)
-{
-  uint32_t
-    seg =
-    0;
-  while (seg < _nb_segment)
-    {
-      if (_segments[seg]._nb_frames == 0)
-	{
-	  //
-
-	  for (uint32_t c = seg + 1; c < _nb_segment; c++)
-	    {
-	      memcpy (&_segments[c - 1], &_segments[c], sizeof (_SEGMENT));
-	    }
-	  _nb_segment--;
-
-	}
-      else
-	{
-	  seg++;
-	}
-    }
-  // Remove last seg if there is only one frame in it
-  if (_nb_segment)
-    {
-      if (_segments[_nb_segment - 1]._nb_frames == 1)
-	{
-	  _nb_segment--;
-	}
-    }
-  return 1;
-
-}
-
-//____________________________________
-//      Remove empty segments
-//____________________________________
-uint32_t ADM_Composer::computeTotalFrames (void)
-{
-  uint32_t
-    seg,
-    tf =
-    0;
-  for (seg = 0; seg < _nb_segment; seg++)
-    {
-      tf += _segments[seg]._nb_frames;
-
-    }
-
-  return tf;
-}
-
-//____________________________________
-//      Remove empty segments
-//____________________________________
-void
-ADM_Composer::dumpSeg (void)
-{
-  uint32_t seg;
-  printf ("\n________Video______________");
-  for (seg = 0; seg < _nb_video; seg++)
-    {
-      printf ("\n Video : %lu, nb video  :%lu, audio size:%lu  audioDuration:%lu",
-	      seg, _videos[seg]._nb_video_frames, _videos[seg]._audio_size,_videos[seg]._audio_duration);
-
-    }
-
-  printf ("\n______________________");
-  for (seg = 0; seg < _nb_segment; seg++)
-    {
-      printf
-	("\n Seg : %lu, ref: %lu start :%lu, size:%lu audio size : %lu audio start : %lu duration:%lu",
-	 seg, _segments[seg]._reference, _segments[seg]._start_frame,
-	 _segments[seg]._nb_frames, _segments[seg]._audio_size,
-	 _segments[seg]._audio_start,
-	  _segments[seg]._audio_duration
-	 );
-
-    }
-  printf ("\n_________Clipboard_____________");
-  for (seg = 0; seg < _nb_clipboard; seg++)
-    {
-      printf
-	("\n Seg : %lu, ref: %lu start :%lu, size:%lu audio size : %lu audio start : %lu  duration:%lu\n",
-	 seg, _clipboard[seg]._reference, _clipboard[seg]._start_frame,
-	 _clipboard[seg]._nb_frames, _clipboard[seg]._audio_size,
-	 _clipboard[seg]._audio_start,
-	 _segments[seg]._audio_duration);
-
-    }
-
-
-}
-
-// Clear from position to/from
-//
-// 0------To------end
-//  xxxxxx removed
-
-uint8_t ADM_Composer::removeTo (uint32_t to, uint32_t seg, uint8_t included)
-{
-  uint32_t
-    ref;
-
-  ADM_assert (checkInSeg (seg, to));
-  ref = _segments[seg]._start_frame;
-  _segments[seg]._start_frame = to;
-  if (included)
-    _segments[seg]._start_frame++;
-  _segments[seg]._nb_frames -= (_segments[seg]._start_frame - ref);
-
-
-  updateAudioTrack (seg);
-
-//---------------------------------------
-
-
-
-  return 1;
-}
-
-//
-// 0------From------end
-//            xxxxxx removed
-
-uint8_t
-  ADM_Composer::removeFrom (uint32_t from, uint32_t seg, uint8_t included)
-{
-  ADM_assert (checkInSeg (seg, from));
-  _segments[seg]._nb_frames = (from - _segments[seg]._start_frame);
-
-  if (!included)
-    _segments[seg]._nb_frames++;
-
-  updateAudioTrack (seg);
-  return 1;
-}
-
-//
-//      Update the real size of audio track by computing the
-// delta between sync @end and sync at begin
-// We also upate the duration of the selected part
-//
-
-uint8_t ADM_Composer::updateAudioTrack (uint32_t seg)
-{
-  // audio sync
-  uint32_t
-    pos_start,
-    pos_end,
-    off,
-    tf;
-  uint32_t
-    reference;
-
-  reference = _segments[seg]._reference;
-  // Mika
-  if (!_videos[reference]._audiostream)
-    return 1;
-  // Compute the resulting duration
-  // Of the segment
-  double duration;
-  aviInfo info;
-  	_videos[reference]._aviheader->getVideoInfo(&info);
-  	duration= _segments[seg]._nb_frames;
-	ADM_assert(info.fps1000);
-	duration/=info.fps1000;
-	duration*=1000*_videos[reference]._audiostream->getInfo()->frequency;
-	
-  _segments[seg]._audio_duration = (uint64_t)floor(duration);
-
-  // If we cannot go to sync point start --> no need to continue
-  // It can happen if audio track is shorter than video
-#if 0 // BAZOOKA
-  if (!audioGoToFn (seg, _segments[seg]._start_frame, &off))
-    {
-      _segments[seg]._audio_size = 0;
-      printf (" cannot seek audio tp frame : %lu\n", seg);
-      return 1;
-
-    }
-//  pos_start = _videos[reference]._audiostream->getPos ();
-
-  // Now try to go to the end...
-  // if it fails, try previous frame stamp
-  tf = _segments[seg]._start_frame + _segments[seg]._nb_frames;	//-1;
-
-  while ((!audioGoToFn (seg, tf, &off)
-	  && ((tf - 1) > _segments[seg]._start_frame)))
-    {
-      printf (" trying to sync on frame %lu\n", tf);
-      tf--;
-    }
-#endif
-//  pos_end = _videos[reference]._audiostream->getPos ();
-
-  _segments[seg]._audio_size = pos_end - pos_start;
-  _segments[seg]._audio_start = pos_start;
-  
-  printf (" Audio start : %lu end : %lu size : %lu\n", pos_start, pos_end,
-	  _segments[seg]._audio_size);
-
-  return 1;
-
-#warning FIXME, does not work if audio track is shorter
-
-}
-uint8_t WAV2AudioInfo(WAVHeader *hdr,audioInfo *info)
-{
-    info->bitrate=(hdr->byterate*8)/1000;
-    info->channels=hdr->channels;
-    info->encoding=hdr->encoding;
-    info->frequency=hdr->frequency;
-    info->av_sync=0;
-    return 1;
-}
-
-
-//__________________________________________________
-// check that the given frame is inside the segment
-//__________________________________________________
-uint8_t ADM_Composer::checkInSeg (uint32_t seg, uint32_t frame)
-{
-  if (frame < _segments[seg]._start_frame)
-    return 0;
-  if (frame > (_segments[seg]._nb_frames + _segments[seg]._start_frame))
-    return 0;
-  return 1;
-
-}
-uint8_t	ADM_Composer::isIndexable( void)
-{
-	if(!_nb_video) ADM_assert(0);
-	return _videos[0].decoder->isIndexable();
-
-}
-
-uint8_t ADM_Composer::sanityCheck (void)
-{
-  uint32_t
-    ref,
-    seg;
-
-  for (seg = 0; seg < _nb_segment; seg++)
-    {
-      ref = _segments[seg]._start_frame + _segments[seg]._nb_frames - 1;
-
-    }
-  return 1;
-
-
-}
-
-/**
-	Propagate VBR building to underlying segment
-
-*/
-void
-ADM_Composer::propagateBuildMap (void)
-{
-uint8_t need_update=0;
-  if (_nb_video)
-    {
-    for(uint32_t i=0;i<_nb_video;i++)
-    	{
-    		if(! _videos[i]._isAudioVbr)
-		{
-//			if((    		_videos[i]._isAudioVbr=_videos[i]._audiostream->buildAudioTimeLine ()))
-			{
-				need_update=1;
-			}
-		}
-	}
-    }
-
-}
-//_________________________________________
-uint8_t		ADM_Composer::setEnv(_ENV_EDITOR_FLAGS newflag)
-{
-	_internalFlags|=newflag;
-	return 1;
-
-}
-//_________________________________________
-//	Return 1 if the flag was set
-//		The flag is reset in all cases!!!!!!!!!!!!!
-uint8_t		ADM_Composer::getEnv(_ENV_EDITOR_FLAGS newflag)
-{
-uint8_t r=0;
-		if(_internalFlags&newflag) r=1;
-		_internalFlags&=~newflag;
-		if(r) { printf("Env override %d used\n",newflag);}
-		return r;
-
-}
-#if BAZOOKA
-//_________________________________________
-//    Try indexing the file, return 1 if file successfully indexed 
-//              0 else
-//_________________________________________
-//
-uint8_t         ADM_Composer::tryIndexing(const char *name, const char *idxname)
-{
- unsigned int autoidx = 0;
-      prefs->get(FEATURE_TRYAUTOIDX,&autoidx);
-      if (!autoidx)
-        {
-          if (!GUI_Question (QT_TR_NOOP("This looks like mpeg\n Do you want to index it?")))
-            {
-                return 0;
-            }
-		}  
-          char      *idx;
-          DMX_TYPE  type;
-          uint32_t  nbTrack=0,audioTrack=0;
-          MPEG_TRACK *tracks=NULL;
-          uint8_t r=1;
-
-                if(!dmx_probe(name,&type,&nbTrack,&tracks))
-                {
-                        printf("This is not mpeg\n");
-                        return 0;
-                }
-
-          
-                if(type==DMX_MPG_PS || type==DMX_MPG_TS || type==DMX_MPG_TS2)
-                {
-                       if(nbTrack>2)
-		       if(autoidx)
-			{
-				printf("Using autoindex\n");
-			}
-/*                        else
-		       {
-                           
-                        if(!DIA_dmx(name,type,nbTrack,tracks,&audioTrack))
-                        {
-                                delete [] tracks;
-                                return 0;
-                        }
-		       }
-*/
-                        audioTrack=0;
-                }
-		if( idxname ){
-			idx=new char[strlen(idxname)];
-			strcpy(idx,idxname);
-		}else{
-                	idx=new char[strlen(name)+5];
-                	strcpy(idx,name);
-                	strcat(idx,".idx");
-		}
-
-                r=dmx_indexer(name,idx,audioTrack,0,nbTrack,tracks);
-
-                if(tracks)
-                        delete [] tracks;
-                delete [] idx;
-
-                if(!r) GUI_Error_HIG(QT_TR_NOOP("Indexing failed"), NULL); 
-                return r;
-}
-#endif
-/**
-      If a parameter has changed, rebuild the duration of the streams
-      It can happen, for example in case of SBR audio such as AAC
-      The demuxer says it is xx kHz, but the codec updates it to 2*xx kHz
-*/
-uint8_t ADM_Composer::rebuildDuration(void)
-{
-  double duration;
-  WAVHeader *wav ;
-  aviInfo    info;
-  printf("[Editor] updating soundtracks duration\n");
-  _videos[   0     ]._aviheader->getVideoInfo (&info);
-  for(int i=0;i<_nb_video;i++)
-  {
-    wav= _videos[i]._aviheader->getAudioInfo ();
-      if(wav)
-      {
-          duration=_videos[i]._nb_video_frames;
-          duration/=info.fps1000;
-          duration*=1000;                 // duration in seconds
-          duration*=wav->frequency;          // In sample
-          _videos[i]._audio_duration=(uint64_t)floor(duration);
-      }
-  }
-  for(int i=0;i<_nb_segment;i++)
-    updateAudioTrack(i);
-  return 1;
-}
-//
-//



From mean at mail.berlios.de  Wed Oct 21 07:14:35 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 21 Oct 2009 07:14:35 +0200
Subject: [Avidemux-svn-commit] r5395 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor
Message-ID: <200910210514.n9L5EZxF013698@sheep.berlios.de>

Author: mean
Date: 2009-10-21 07:14:34 +0200 (Wed, 21 Oct 2009)
New Revision: 5395

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp
Log:
[editor] Wrong copy:paste

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp	2009-10-21 05:14:27 UTC (rev 5394)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp	2009-10-21 05:14:34 UTC (rev 5395)
@@ -550,14 +550,16 @@
 }
 
 /**
-      If a parameter has changed, rebuild the duration of the streams
+    \fn rebuildDuration
+    \brief      If a parameter has changed, rebuild the duration of the streams
       It can happen, for example in case of SBR audio such as AAC
       The demuxer says it is xx kHz, but the codec updates it to 2*xx kHz
+
+    Should not be needed with 2.6
 */
 bool  ADM_Composer::rebuildDuration(void)
 {
-  switchToSegment(0);
-  return true; nextPictureInternal(0,NULL);
+  return true;
 }
 /**
     \fn getCurrentFramePts



From mean at mail.berlios.de  Wed Oct 21 07:14:42 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 21 Oct 2009 07:14:42 +0200
Subject: [Avidemux-svn-commit] r5396 -
	branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_filters
Message-ID: <200910210514.n9L5Egr8013765@sheep.berlios.de>

Author: mean
Date: 2009-10-21 07:14:41 +0200 (Wed, 21 Oct 2009)
New Revision: 5396

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_filters/gui_filtermanager.cpp
Log:
[Gtk] Disable not working part of filtermanager

Modified: branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_filters/gui_filtermanager.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_filters/gui_filtermanager.cpp	2009-10-21 05:14:34 UTC (rev 5395)
+++ branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_filters/gui_filtermanager.cpp	2009-10-21 05:14:41 UTC (rev 5396)
@@ -328,8 +328,8 @@
     case A_PREVIEW:
         if (!action_parameter) break;
         {
-            uint32_t curframe=video_body->getCurrentFrame();
-            DIA_filterPreview(QT_TR_NOOP("Preview"), videofilters[action_parameter].filter, curframe);
+            //uint32_t curframe=video_body->getCurrentFrame();
+            //DIA_filterPreview(QT_TR_NOOP("Preview"), videofilters[action_parameter].filter, curframe);
         }
         break;
 



From mean at mail.berlios.de  Thu Oct 22 08:04:36 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 22 Oct 2009 08:04:36 +0200
Subject: [Avidemux-svn-commit] r5397 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor
Message-ID: <200910220604.n9M64aBK027519@sheep.berlios.de>

Author: mean
Date: 2009-10-22 08:04:35 +0200 (Thu, 22 Oct 2009)
New Revision: 5397

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edLoadSave.cpp
Log:
[editor] Cleanup

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edLoadSave.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edLoadSave.cpp	2009-10-21 05:14:41 UTC (rev 5396)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edLoadSave.cpp	2009-10-22 06:04:35 UTC (rev 5397)
@@ -36,15 +36,6 @@
 const char *getCurrentContainerAsString(void);
 
 
-//______________________________________________
-// Save the config, including name, segment etc...
-//______________________________________________
-
-uint8_t ADM_Composer::saveWorbench (const char *name)
-{
-        GUI_Error_HIG(QT_TR_NOOP("Unsupported"), NULL);
-        return 0;
-}
 /*______________________________________________
         Save the project as a script
 ______________________________________________*/
@@ -267,13 +258,4 @@
 
 }
 
-//______________________________________________
-// Save the config, including name, segment etc...
-//______________________________________________
-
-uint8_t ADM_Composer::loadWorbench (const char *name)
-{
-  GUI_Error_HIG(QT_TR_NOOP("Old format project file"),QT_TR_NOOP( "No more supported."));
- return 0;
-}
 //EOF



From mean at mail.berlios.de  Thu Oct 22 08:04:38 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 22 Oct 2009 08:04:38 +0200
Subject: [Avidemux-svn-commit] r5398 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor
Message-ID: <200910220604.n9M64coI027548@sheep.berlios.de>

Author: mean
Date: 2009-10-22 08:04:37 +0200 (Thu, 22 Oct 2009)
New Revision: 5398

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRenderInternal.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx
Log:
[editor] Implements seekToFrame, time based seek

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp	2009-10-22 06:04:35 UTC (rev 5397)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp	2009-10-22 06:04:37 UTC (rev 5398)
@@ -93,6 +93,8 @@
 */
 bool  ADM_Composer::goToTimeVideo(uint64_t startTime)
 {
+    // Search the previous keyframe...
+
     return goToIntraTimeVideo(startTime);
 
 }
@@ -305,31 +307,13 @@
                 from=pts;
         }
     }
-    
-    // Search the previous keyframe for segment....
-    uint64_t seekTime;
-    if(_segments.isKeyFrameByTime(seg->_reference,from))
+    if(false==seektoFrame(seg->_reference,from))
     {
-        seekTime=from;
-        ADM_info("First frame of the new segment is a keyframe at %"LU"ms\n",seekTime/1000);
-    }else   
-    {
-        if(false==searchPreviousKeyFrameInRef(seg->_reference,from,&seekTime))
-        {
-            ADM_warning("Cannot identify the keyframe before %"LLU" ms\n",seekTime/1000);
+            ADM_warning("Cannot seek to beginning of segment %"LU" at  %"LLU" ms\n",s,from/1000);
             return false;
-        }
     }
-    // ok now seek...
-    uint32_t frame=_segments.intraTimeToFrame(seg->_reference,seekTime);
-    if(false==DecodePictureUpToIntra(seg->_reference,frame))
-    {
-        return false;
-    }
-    // Now forward to the frame we want...
-#warning TODO do not seek only on intra
-    _VIDEOS *ref=_segments.getRefVideo(seg->_reference);
-    seg->_curFrame=ref->lastSentFrame;
+    _currentSegment=s;
+    ADM_info("Switched ok to segment %"LU"\n",s);
     return true;
 }
 /**

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRenderInternal.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRenderInternal.cpp	2009-10-22 06:04:35 UTC (rev 5397)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRenderInternal.cpp	2009-10-22 06:04:37 UTC (rev 5398)
@@ -31,7 +31,64 @@
 // This should be in a context somewhere
 static uint8_t compBuffer[MAXIMUM_SIZE * MAXIMUM_SIZE * 3];
 
+/**
+    \fn seektoFrame
+    \brief Seek to frame with timestamp given as arg
 
+*/
+bool ADM_Composer::seektoFrame(uint32_t ref,uint64_t timeToSeek)
+{
+   _VIDEOS *vid=_segments.getRefVideo(ref);
+    vidHeader *demuxer=vid->_aviheader;
+	EditorCache   *cache =vid->_videoCache;
+	ADM_assert(cache);
+    bool found=false;
+   // Search the previous keyframe for segment....
+    uint64_t seekTime;
+    if(_segments.isKeyFrameByTime(ref,timeToSeek))
+    {
+        seekTime=timeToSeek;
+        ADM_info("First frame of the new segment is a keyframe at %"LU"ms\n",seekTime/1000);
+        found=true;
+    }else   
+    {
+        if(false==searchPreviousKeyFrameInRef(ref,timeToSeek,&seekTime))
+        {
+            ADM_warning("Cannot identify the keyframe before %"LLU" ms\n",seekTime/1000);
+            return false;
+        }
+    }
+    // ok now seek...
+    uint32_t frame=_segments.intraTimeToFrame(ref,seekTime);
+    if(false==DecodePictureUpToIntra(ref,frame))
+    {
+        ADM_warning("Cannot decode up to intra %"LLU" at %"LLU" ms\n",frame,seekTime/1000);
+        return false;
+    }
+    if(found==true) return true;
+    // Now forward...
+    while(nextPictureInternal(ref,NULL)==true)
+    {
+        uint64_t pts=vid->lastDecodedPts;
+        if(pts==ADM_NO_PTS)     
+        {
+            ADM_warning("No PTS out of decoder\n");
+            continue;
+        }
+        if(pts==timeToSeek)
+        {
+            ADM_info("Image found, pts=%"LLU" ms\n",pts/1000);
+            return true;
+        }
+        if(pts>timeToSeek)
+        {
+            ADM_info("Image not found,searching %"LLU" ms, got  pts=%"LLU" ms\n",timeToSeek/1000,pts/1000);
+            return false;
+        }
+    }
+    ADM_warning("seekToFrame failed for frame at PTS= %"LLU" ms, next image failed\n",timeToSeek/1000);
+    return false;
+}
 /**
     \fn samePictureInternal
     \brief returns the last already decoded picture

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx	2009-10-22 06:04:35 UTC (rev 5397)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx	2009-10-22 06:04:37 UTC (rev 5398)
@@ -71,6 +71,7 @@
 
                     bool        nextPictureInternal(uint32_t ref,ADMImage *image);
                     bool        samePictureInternal(uint32_t ref,ADMImage *image);
+                    bool        seektoFrame(uint32_t ref,uint64_t timeToSeek);
 
 protected:
                                 /// Decode frame and on until frame is popped out of decoders



From mean at mail.berlios.de  Thu Oct 22 19:55:21 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 22 Oct 2009 19:55:21 +0200
Subject: [Avidemux-svn-commit] r5399 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor
Message-ID: <200910221755.n9MHtLlY011530@sheep.berlios.de>

Author: mean
Date: 2009-10-22 19:55:18 +0200 (Thu, 22 Oct 2009)
New Revision: 5399

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRenderInternal.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.h
Log:
[Editor] Implement goToTimevideo + simpligy getRefFromTime

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp	2009-10-22 06:04:37 UTC (rev 5398)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp	2009-10-22 17:55:18 UTC (rev 5399)
@@ -89,14 +89,30 @@
     return true;
 }
 /**
-    \fn GoToTime
+    \fn goToTimeVideo
+    \brief Seek video to the given time. Must be an exact time.
 */
 bool  ADM_Composer::goToTimeVideo(uint64_t startTime)
 {
-    // Search the previous keyframe...
+uint64_t segTime;
+uint32_t seg;
+    if(false==_segments.convertLinearTimeToSeg(startTime,&seg,&segTime))
+    {
+        ADM_warning("Cannot find segment for time %"LLU" ms\n",startTime/1000);
+        return false;
+    }
+    
+    // Try to seek...
+    _SEGMENT *s=_segments.getSegment(seg);
+    uint64_t to=segTime+s->_refStartTimeUs;
+    if(false==seektoTime(s->_reference,to))
+    {
+            ADM_warning("Cannot seek to beginning of segment %"LU" at  %"LLU" ms\n",s,to/1000);
+            return false;
+    }
+    _currentSegment=seg;
+    return true;
 
-    return goToIntraTimeVideo(startTime);
-
 }
 /**
     \fn NextPicture
@@ -307,7 +323,7 @@
                 from=pts;
         }
     }
-    if(false==seektoFrame(seg->_reference,from))
+    if(false==seektoTime(seg->_reference,from))
     {
             ADM_warning("Cannot seek to beginning of segment %"LU" at  %"LLU" ms\n",s,from/1000);
             return false;

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRenderInternal.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRenderInternal.cpp	2009-10-22 06:04:37 UTC (rev 5398)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRenderInternal.cpp	2009-10-22 17:55:18 UTC (rev 5399)
@@ -36,7 +36,7 @@
     \brief Seek to frame with timestamp given as arg
 
 */
-bool ADM_Composer::seektoFrame(uint32_t ref,uint64_t timeToSeek)
+bool ADM_Composer::seektoTime(uint32_t ref,uint64_t timeToSeek)
 {
    _VIDEOS *vid=_segments.getRefVideo(ref);
     vidHeader *demuxer=vid->_aviheader;

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp	2009-10-22 06:04:37 UTC (rev 5398)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp	2009-10-22 17:55:18 UTC (rev 5399)
@@ -381,11 +381,10 @@
 */
 bool ADM_Composer::setDecodeParam (uint64_t time)
 {
-uint64_t offset;
 uint32_t ref;
   if (_segments.getNbRefVideos())
   {
-    if(false==_segments.getRefFromTime(time,&ref,&offset))
+    if(false==_segments.getRefFromTime(time,&ref))
     {
         ADM_warning("Cannot get ref from time %"LLD" ms\n",time/1000);
         return false;
@@ -415,10 +414,9 @@
 bool ADM_Composer::getAudioStreamsInfo(uint64_t xtime,uint32_t *nbStreams, audioInfo **infos)
 {
 
-uint64_t offset;
 uint32_t ref;
   
-    if(false==_segments.getRefFromTime(xtime,&ref,&offset))
+    if(false==_segments.getRefFromTime(xtime,&ref))
     {
         ADM_warning("[Editor] getAudioStreamsInfo failed for time %"LLD" ms\n",xtime);
         return false;
@@ -456,9 +454,8 @@
 uint32_t ADM_Composer::getCurrentAudioStreamNumber(uint64_t  xtime)
 {
 uint32_t ref;
-uint64_t offset;
 
-        if(false==_segments.getRefFromTime(xtime,&ref,&offset))  
+        if(false==_segments.getRefFromTime(xtime,&ref))  
         {
             ADM_warning("[Editor::getCurrentAudioStreamNumber] Cannot get ref video for time %"LLD" ms\n",xtime/1000);
             return 0;
@@ -475,11 +472,10 @@
 double     duration;
 WAVHeader *wav;
 aviInfo    info;
+uint32_t ref;
 
-       uint32_t ref;
-        uint64_t offset;
 
-        if(false==_segments.getRefFromTime(xtime,&ref,&offset))  
+        if(false==_segments.getRefFromTime(xtime,&ref))  
         {
             ADM_warning("[Editor::changeAudioStream] Cannot get ref video for time %"LLD" ms\n",xtime/1000);
             return 0;

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx	2009-10-22 06:04:37 UTC (rev 5398)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx	2009-10-22 17:55:18 UTC (rev 5399)
@@ -71,7 +71,7 @@
 
                     bool        nextPictureInternal(uint32_t ref,ADMImage *image);
                     bool        samePictureInternal(uint32_t ref,ADMImage *image);
-                    bool        seektoFrame(uint32_t ref,uint64_t timeToSeek);
+                    bool        seektoTime(uint32_t ref,uint64_t timeToSeek);
 
 protected:
                                 /// Decode frame and on until frame is popped out of decoders

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp	2009-10-22 06:04:37 UTC (rev 5398)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp	2009-10-22 17:55:18 UTC (rev 5399)
@@ -247,9 +247,8 @@
     \fn getRefFromTime
     \brief convert linear time to a ref video+ offset in the refvideo
 */
-bool        ADM_EditorSegment::getRefFromTime(uint64_t time,uint32_t *refVideo, uint64_t *offset)
+bool        ADM_EditorSegment::getRefFromTime(uint64_t time,uint32_t *refVideo)
 {
-    *offset=time;
     *refVideo=0;
     return true;
 }

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.h	2009-10-22 06:04:37 UTC (rev 5398)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.h	2009-10-22 17:55:18 UTC (rev 5399)
@@ -115,7 +115,7 @@
             uint64_t    getTotalDuration(void);
             uint32_t    getNbFrames(void);
 
-            bool        getRefFromTime(uint64_t time,uint32_t *refVideo, uint64_t *offset);
+            bool        getRefFromTime(uint64_t time,uint32_t *refVideo);
 
             bool        convertLinearTimeToSeg(  uint64_t frameTime, uint32_t *seg, uint64_t *segTime);
             bool        convertSegTimeToLinear(  uint32_t seg,uint64_t segTime, uint64_t *frameTime);



From mean at mail.berlios.de  Thu Oct 22 20:05:04 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 22 Oct 2009 20:05:04 +0200
Subject: [Avidemux-svn-commit] r5400 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs
Message-ID: <200910221805.n9MI54ox013430@sheep.berlios.de>

Author: mean
Date: 2009-10-22 20:05:02 +0200 (Thu, 22 Oct 2009)
New Revision: 5400

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_codecs.cpp
Log:
[codec] Add SEDG (? samsung electronic d?? g??) fourcc, patch from colinl

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_codecs.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_codecs.cpp	2009-10-22 17:55:18 UTC (rev 5399)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_codecs.cpp	2009-10-22 18:05:02 UTC (rev 5400)
@@ -77,6 +77,7 @@
   CHECK ("BLZ0");
   CHECK ("M4S2");
   CHECK ("3IV2");
+  CHECK ("SEDG");
 
   return divx4;
 



From mean at mail.berlios.de  Fri Oct 23 20:09:19 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 23 Oct 2009 20:09:19 +0200
Subject: [Avidemux-svn-commit] r5401 -
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src
Message-ID: <200910231809.n9NI9JIV023499@sheep.berlios.de>

Author: mean
Date: 2009-10-23 20:09:18 +0200 (Fri, 23 Oct 2009)
New Revision: 5401

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_codecType.cpp
Log:
[codec] Add SEDG fourcc for mpeg4 (samsung)

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_codecType.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_codecType.cpp	2009-10-22 18:05:02 UTC (rev 5400)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/ADM_codecType.cpp	2009-10-23 18:09:18 UTC (rev 5401)
@@ -38,6 +38,7 @@
   CHECK ("BLZ0");
   CHECK ("M4S2");
   CHECK ("3IV2");
+  CHECK ("SEDG");
 
   return divx4;
 



From mean at mail.berlios.de  Fri Oct 23 20:09:21 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 23 Oct 2009 20:09:21 +0200
Subject: [Avidemux-svn-commit] r5402 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor
Message-ID: <200910231809.n9NI9LrT023514@sheep.berlios.de>

Author: mean
Date: 2009-10-23 20:09:20 +0200 (Fri, 23 Oct 2009)
New Revision: 5402

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRenderInternal.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.h
Log:
[editor] Better multi segment handling

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp	2009-10-23 18:09:18 UTC (rev 5401)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp	2009-10-23 18:09:20 UTC (rev 5402)
@@ -76,7 +76,7 @@
 
     uint64_t refTime=seg->_refStartTimeUs+segTime;
 
-    uint32_t frame=_segments.intraTimeToFrame(seg->_reference,time);       
+    uint32_t frame=_segments.intraTimeToFrame(seg->_reference,refTime);       
     if(false==switchToSegment(s))
     {
         ADM_warning("Cannot go to segment %"LU"\n",s);

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRenderInternal.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRenderInternal.cpp	2009-10-23 18:09:18 UTC (rev 5401)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRenderInternal.cpp	2009-10-23 18:09:20 UTC (rev 5402)
@@ -220,7 +220,7 @@
     
       if(!decompressImage(result,&img,ref))
       {
-         ADM_warning("Decoding error for frame %"LU"\n",vid->lastSentFrame);
+         ADM_info("Decoding error for frame %"LU", not necessarily a problem\n",vid->lastSentFrame);
          cache->invalidate(result);
          return true; // Not an error in itself
       }
@@ -531,7 +531,7 @@
                                                                     img.demuxerPts);
           if(!decompressImage(result,&img,ref))
           {
-             ADM_warning(" decode error for frame %"LU"\n",vid->lastSentFrame);
+             ADM_info(" decode error for frame %"LU", not necessarily a problem\n",vid->lastSentFrame);
              //cache->dump();
              cache->invalidate(result);
              //cache->dump();

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp	2009-10-23 18:09:18 UTC (rev 5401)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp	2009-10-23 18:09:20 UTC (rev 5402)
@@ -564,7 +564,7 @@
 */
 uint64_t    ADM_Composer::getCurrentFramePts(void)
 {
-    _SEGMENT *seg=_segments.getCurrentSeg();
+    _SEGMENT *seg=_segments.getSegment(_currentSegment);
     _VIDEOS *vid=_segments.getRefVideo(seg->_reference);
     return vid->lastDecodedPts;
 }

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp	2009-10-23 18:09:18 UTC (rev 5401)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp	2009-10-23 18:09:20 UTC (rev 5402)
@@ -245,11 +245,21 @@
 /***********************************************************************/
 /**
     \fn getRefFromTime
-    \brief convert linear time to a ref video+ offset in the refvideo
+    \brief Return the ref video where xtime is 
 */
-bool        ADM_EditorSegment::getRefFromTime(uint64_t time,uint32_t *refVideo)
+bool        ADM_EditorSegment::getRefFromTime(uint64_t xtime,uint32_t *refVideo)
 {
-    *refVideo=0;
+    // What segments does it belong to ?
+    uint32_t seg;
+    uint64_t segTime;
+    if(false== convertLinearTimeToSeg(  xtime, &seg, &segTime))
+    {
+        ADM_warning("Cannot identify segment for time %"LLU" ms\n",xtime/1000);
+        return false;
+    }
+    _SEGMENT *s=getSegment(seg);
+    ADM_assert(s);
+    *refVideo=s->_reference;
     return true;
 }
 /**
@@ -265,14 +275,8 @@
             codec=NULL;
         }
     }
+
 /**
-    \fn getCurrentSeg
-*/
-_SEGMENT   * ADM_EditorSegment::getCurrentSeg(void)
-{
-    return &(segments[0]);
-}
-/**
     \fn convertLinearTimeToSeg
     \brief convert linear time to a segment+ offset in the segment
 */

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.h	2009-10-23 18:09:18 UTC (rev 5401)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.h	2009-10-23 18:09:20 UTC (rev 5402)
@@ -120,9 +120,7 @@
             bool        convertLinearTimeToSeg(  uint64_t frameTime, uint32_t *seg, uint64_t *segTime);
             bool        convertSegTimeToLinear(  uint32_t seg,uint64_t segTime, uint64_t *frameTime);
 
-            _SEGMENT    *getCurrentSeg(void);
 
-
             uint32_t    intraTimeToFrame(uint32_t refVideo,uint64_t seekTime);       
             bool        isKeyFrameByTime(uint32_t refVideo,uint64_t seekTime);
 };



From mean at mail.berlios.de  Fri Oct 23 20:09:23 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 23 Oct 2009 20:09:23 +0200
Subject: [Avidemux-svn-commit] r5403 - in
	branches/avidemux_2.6_branch_mean/avidemux/common: . ADM_editor
Message-ID: <200910231809.n9NI9Nx8023529@sheep.berlios.de>

Author: mean
Date: 2009-10-23 20:09:22 +0200 (Fri, 23 Oct 2009)
New Revision: 5403

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.h
   branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp
Log:
[Editor] preliminary support for cutting (incomplete)

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp	2009-10-23 18:09:20 UTC (rev 5402)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp	2009-10-23 18:09:22 UTC (rev 5403)
@@ -568,5 +568,13 @@
     _VIDEOS *vid=_segments.getRefVideo(seg->_reference);
     return vid->lastDecodedPts;
 }
+/**
+    \fn remove
+    \brief Remove part of the video
+*/
+bool            ADM_Composer::remove(uint64_t start,uint64_t end)
+{
+    return _segments.removeChunk(start,end);
+}
 //
 //

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx	2009-10-23 18:09:20 UTC (rev 5402)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx	2009-10-23 18:09:22 UTC (rev 5403)
@@ -194,7 +194,10 @@
 /******************************* Post Processing ************************************/
 					uint8_t 		setPostProc( uint32_t type, uint32_t strength,	uint32_t swapuv);
 					uint8_t 		getPostProc( uint32_t *type, uint32_t *strength,uint32_t *swapuv);
-/******************************* /Post Processing ************************************/										
+/******************************* /Post Processing ************************************/	
+/******************************* Editing ************************************/	
+                    bool            remove(uint64_t start,uint64_t end);
+/******************************* /Editing **********************************/										
 /******************************* Misc ************************************/				
 					uint8_t			setEnv(_ENV_EDITOR_FLAGS newflag);
 					uint8_t			getEnv(_ENV_EDITOR_FLAGS newflag);

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp	2009-10-23 18:09:20 UTC (rev 5402)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp	2009-10-23 18:09:22 UTC (rev 5403)
@@ -355,4 +355,67 @@
         if(flags & AVI_KEY_FRAME) return true;
         return false;
 }
+/**
+    \fn removeChunk
+    \brief 
+*/
+bool        ADM_EditorSegment::removeChunk(uint64_t from, uint64_t to)
+{
+    uint32_t startSeg,endSeg;
+    uint64_t startOffset,endOffset;
+    if(false==convertLinearTimeToSeg( from,&startSeg,&startOffset))
+    {
+        ADM_warning("Cannot get starting point (%"LLU" ms\n",from/1000);
+        return false;
+    }
+    if(false==convertLinearTimeToSeg( to,&endSeg,&endOffset))
+    {
+        ADM_warning("Cannot get starting point (%"LLU" ms\n",from/1000);
+        return false;
+    }
+    _SEGMENT *first=getSegment(startSeg);
+    if(startSeg==endSeg)
+    {
+        // Split the seg int two..
+        segments.push_back(*first); 
+        endSeg=startSeg+1;
+#warning FiXME! they are not necessarily the last
+    }
+      // Span over several seg...
+    // 1- shorten the start segment..
+  
+    first->_durationUs=startOffset;
+    // 2- Kill the segment in between
+    for(int i=startSeg+1;i<endSeg;i++)
+    {
+        segments.erase(segments.begin()+i);
+    }
+    // 3- Shorten last segment
+    _SEGMENT *last=getSegment(endSeg);
+    last->_refStartTimeUs+=endOffset;
+    last->_durationUs-=endOffset;
+
+    updateStartTime();
+    dump();
+    return true;
+}
+/**
+    \fn dump
+    \brief Dump the segment content
+*/
+void ADM_EditorSegment::dump(void)
+{
+    int n=segments.size();
+    printf("We have %d segments\n",n);
+    for(int i=0;i<n;i++)
+    {
+        _SEGMENT *s=getSegment(i);
+        printf("Segment :%d/%d\n",i,n);
+        printf("\tReference    :%"LU"\n",s->_reference);
+        printf("\tstartLinear  :%"LLU"\n",s->_startTimeUs);
+        printf("\tduration     :%"LLU"\n",s->_durationUs);
+        printf("\trefStart     :%"LLU"\n",s->_refStartTimeUs);
+
+    }
+}
 //EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.h	2009-10-23 18:09:20 UTC (rev 5402)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.h	2009-10-23 18:09:22 UTC (rev 5403)
@@ -98,6 +98,7 @@
         ListOfSegments segments;
         ListOfVideos   videos;
         bool           updateStartTime(void);
+        void           dump(void);
 
 public:
                         ADM_EditorSegment(void);
@@ -123,6 +124,7 @@
 
             uint32_t    intraTimeToFrame(uint32_t refVideo,uint64_t seekTime);       
             bool        isKeyFrameByTime(uint32_t refVideo,uint64_t seekTime);
+            bool        removeChunk(uint64_t from, uint64_t to);
 };
 
 #endif

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp	2009-10-23 18:09:20 UTC (rev 5402)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp	2009-10-23 18:09:22 UTC (rev 5403)
@@ -429,20 +429,15 @@
 
     case ACT_Delete:
     case ACT_Cut:
-
-#if 0
-      old=frameStart;
-      if( A_delete(frameStart,frameEnd))
-      {
-      	if (old >= avifileinfo->nb_frames)
-	{			// we removed too much
-	  old = avifileinfo->nb_frames - 1;
-	}
-      	curframe=old;
-      	GUI_GoToFrame (old);
-      }
-
-#endif
+        {
+            uint64_t a=video_body->getMarkerAPts();
+            uint64_t b=video_body->getMarkerBPts();
+            if(false==video_body->remove(a,b))
+            {
+                GUI_Error_HIG("Cutting","Error while cutting out.");
+            }
+        }
+        
       break;
 
     case ACT_ChangeFPS:



From mean at mail.berlios.de  Fri Oct 23 20:09:24 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 23 Oct 2009 20:09:24 +0200
Subject: [Avidemux-svn-commit] r5404 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor
Message-ID: <200910231809.n9NI9OBc023542@sheep.berlios.de>

Author: mean
Date: 2009-10-23 20:09:24 +0200 (Fri, 23 Oct 2009)
New Revision: 5404

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp
Log:
[editor] Fix segment handling when cutting out

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp	2009-10-23 18:09:22 UTC (rev 5403)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp	2009-10-23 18:09:24 UTC (rev 5404)
@@ -363,6 +363,9 @@
 {
     uint32_t startSeg,endSeg;
     uint64_t startOffset,endOffset;
+    
+    ADM_info("Cutting from %"LLU" to %"LLU" ms\n",from/1000,to/1000);
+    dump();
     if(false==convertLinearTimeToSeg( from,&startSeg,&startOffset))
     {
         ADM_warning("Cannot get starting point (%"LLU" ms\n",from/1000);
@@ -373,28 +376,33 @@
         ADM_warning("Cannot get starting point (%"LLU" ms\n",from/1000);
         return false;
     }
-    _SEGMENT *first=getSegment(startSeg);
+
+    ADM_info("Start, seg %"LU" Offset :%"LLU" ms\n",startSeg,startOffset);
+    ADM_info("End  , seg %"LU" Offset :%"LLU" ms\n",endSeg,endOffset);
+
+    
     if(startSeg==endSeg)
     {
         // Split the seg int two..
-        segments.push_back(*first); 
+        segments.insert(segments.begin()+startSeg+1,*getSegment(startSeg)); 
         endSeg=startSeg+1;
-#warning FiXME! they are not necessarily the last
+
     }
+    _SEGMENT *first=getSegment(startSeg);
       // Span over several seg...
     // 1- shorten the start segment..
   
     first->_durationUs=startOffset;
+   
+    // 3- Shorten last segment
+    _SEGMENT *last=getSegment(endSeg);
+    last->_refStartTimeUs+=endOffset;
+    last->_durationUs-=endOffset;
     // 2- Kill the segment in between
     for(int i=startSeg+1;i<endSeg;i++)
     {
-        segments.erase(segments.begin()+i);
+        segments.erase(segments.begin()+startSeg+1);
     }
-    // 3- Shorten last segment
-    _SEGMENT *last=getSegment(endSeg);
-    last->_refStartTimeUs+=endOffset;
-    last->_durationUs-=endOffset;
-
     updateStartTime();
     dump();
     return true;



From mean at mail.berlios.de  Sat Oct 24 16:44:45 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 24 Oct 2009 16:44:45 +0200
Subject: [Avidemux-svn-commit] r5405 - in
	branches/avidemux_2.5_branch_gruntster/avidemux: ADM_audio
	ADM_audiocodec
Message-ID: <200910241444.n9OEijLd021061@sheep.berlios.de>

Author: mean
Date: 2009-10-24 16:44:44 +0200 (Sat, 24 Oct 2009)
New Revision: 5405

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audio/ADM_dcainfo.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiocodec/ADM_audiocodec.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiocodec/ADM_codecwma.cpp
Log:
[DCA] Fix # of channels + backport channel reordering from 2.6

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audio/ADM_dcainfo.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audio/ADM_dcainfo.cpp	2009-10-23 18:09:24 UTC (rev 5404)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audio/ADM_dcainfo.cpp	2009-10-24 14:44:44 UTC (rev 5405)
@@ -102,8 +102,13 @@
 #endif
                 *syncoff=cur-buf;
                 if(*syncoff) printf("[dts] Dropped %u bytes\n",*syncoff);
-                *chan=dts_channels[flags & 0xf];
-//                if(*chan==5 && (flags & 0X80)) *chan++;
+                get_bits(&s,10);
+                int lfe=get_bits(&s,2);
+                int c;
+                c=dts_channels[flags & 0xf];
+                if(c==5 && lfe) c++; // LFE
+                *chan=c;
+
                 *nbSample=nbBlocks*32;
                 return framesize;
                 

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiocodec/ADM_audiocodec.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiocodec/ADM_audiocodec.h	2009-10-23 18:09:24 UTC (rev 5404)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiocodec/ADM_audiocodec.h	2009-10-24 14:44:44 UTC (rev 5405)
@@ -109,6 +109,7 @@
 		uint8_t _buffer[ ADMWA_BUF];
 		uint32_t _tail,_head;
 		uint32_t _blockalign;
+                uint32_t _channels;
 
 	public:
 		ADM_AudiocodecWMA(uint32_t fourcc, WAVHeader *info, uint32_t l, uint8_t *d);

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiocodec/ADM_codecwma.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiocodec/ADM_codecwma.cpp	2009-10-23 18:09:24 UTC (rev 5404)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiocodec/ADM_codecwma.cpp	2009-10-24 14:44:44 UTC (rev 5405)
@@ -57,6 +57,7 @@
     // Fills in some values...
     _context->sample_rate = info->frequency;
     _context->channels = info->channels;
+    _channels=info->channels;
     _blockalign=_context->block_align = info->blockalign;
     _context->bit_rate = info->byterate*8;
     switch(fourcc)
@@ -163,6 +164,19 @@
           {
             *outptr++=((float)run16[i])/32767.;
           }
+         if(_channels>=5 )
+            {
+            CHANNEL_TYPE *p_ch_type = channelMapping;
+        #define DOIT(x,y) if(_context->channel_layout & CH_##x) *(p_ch_type++)=CHTYP_##y;
+                DOIT(LOW_FREQUENCY,LFE);
+                DOIT(FRONT_LEFT,FRONT_LEFT);
+                DOIT(FRONT_CENTER,FRONT_CENTER);
+                DOIT(FRONT_RIGHT,FRONT_RIGHT);
+                DOIT(SIDE_LEFT,REAR_LEFT);
+                DOIT(SIDE_RIGHT,REAR_RIGHT);
+
+            }
+
         }
         
         



From mean at mail.berlios.de  Sat Oct 24 16:57:03 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 24 Oct 2009 16:57:03 +0200
Subject: [Avidemux-svn-commit] r5406 -
	branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog
Message-ID: <200910241457.n9OEv38s022252@sheep.berlios.de>

Author: mean
Date: 2009-10-24 16:57:02 +0200 (Sat, 24 Oct 2009)
New Revision: 5406

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/Q_props.cpp
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/props.ui
Log:
[Qt4] Update the properties dialog (no more frames + display audio info)

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/Q_props.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/Q_props.cpp	2009-10-24 14:44:44 UTC (rev 5405)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/Q_props.cpp	2009-10-24 14:57:02 UTC (rev 5406)
@@ -48,15 +48,12 @@
         
         FILLTEXT4(labeImageSize,QT_TR_NOOP("%"LU" x %"LU), avifileinfo->width,avifileinfo->height);
         FILLTEXT(labelFrameRate, QT_TR_NOOP("%2.3f fps"), (float) avifileinfo->fps1000 / 1000.F);
-        FILLTEXT(labelNbOfFrames,QT_TR_NOOP("%"LU" frames"), avifileinfo->nb_frames);
         FILLTEXT(label4CC, "%s",      fourCC::tostring(avifileinfo->fcc));
-        if (avifileinfo->nb_frames)
-          {
-                frame2time(avifileinfo->nb_frames, avifileinfo->fps1000,
-                          &hh, &mm, &ss, &ms);
-                snprintf(text,79, QT_TR_NOOP("%02d:%02d:%02d.%03d"), hh, mm, ss, ms);
-                ui.labelVideoDuration->setText(text);
-          }
+        uint64_t duration=video_body->getVideoDuration();
+        ms2time(duration/1000,&hh,&mm,&ss,&ms);
+        snprintf(text,79, QT_TR_NOOP("%02d:%02d:%02d.%03d"), hh, mm, ss, ms);
+        ui.labelVideoDuration->setText(text);
+
         war=video_body->getPARWidth();
         har=video_body->getPARHeight();
         getAspectRatioFromAR(war,har, &s);
@@ -68,7 +65,7 @@
         SET_YES(LabelGMC,gmc);
         
          WAVHeader *wavinfo=NULL;
-        if (currentaudiostream) wavinfo=currentaudiostream->getInfo();
+         wavinfo=video_body->getInfo();
           if(wavinfo)
           {
               
@@ -91,23 +88,14 @@
                 
                 sprintf(text, "%s", getStrFromAudioCodec(wavinfo->encoding));
                 FILLQT_TR_NOOP(labelACodec);
+                //
+                duration=video_body->getDurationInUs();
+                ms2time(duration/1000,&hh,&mm,&ss,&ms);
 
-                // Duration in seconds too
-                if(currentaudiostream && wavinfo->byterate>1)
-                {
-                        uint32_t l; //=currentaudiostream->getLength();
-                        double du;
-                        du=l;
-                        du*=1000;
-                        du/=wavinfo->byterate;
-                        ms2time((uint32_t)floor(du), &hh, &mm, &ss, &ms);
+                sprintf(text, QT_TR_NOOP("%02d:%02d:%02d.%03d"), hh, mm, ss, ms);
+                FILLQT_TR_NOOP(labelAudioDuration);
 
-						sprintf(text, QT_TR_NOOP("%02d:%02d:%02d.%03d"), hh, mm, ss, ms);
-						FILLQT_TR_NOOP(labelAudioDuration);
 
-						sprintf(text, QT_TR_NOOP("%.2f MB"), l / 1048576.F);
-						FILLQT_TR_NOOP(labelFileSize);
-                }
 
 //                SET_YES(labelVBR,currentaudiostream->isVBR());
         } else

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/props.ui
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/props.ui	2009-10-24 14:44:44 UTC (rev 5405)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_dialog/props.ui	2009-10-24 14:57:02 UTC (rev 5406)
@@ -1,140 +1,106 @@
-<ui version="4.0" >
+<?xml version="1.0" encoding="UTF-8"?>
+<ui version="4.0">
  <class>propsDialog</class>
- <widget class="QDialog" name="propsDialog" >
-  <property name="geometry" >
+ <widget class="QDialog" name="propsDialog">
+  <property name="geometry">
    <rect>
     <x>0</x>
     <y>0</y>
-    <width>245</width>
-    <height>465</height>
+    <width>271</width>
+    <height>531</height>
    </rect>
   </property>
-  <property name="windowTitle" >
+  <property name="windowTitle">
    <string>Properties</string>
   </property>
-  <layout class="QVBoxLayout" >
-   <property name="spacing" >
+  <layout class="QVBoxLayout">
+   <property name="spacing">
     <number>6</number>
    </property>
-   <property name="leftMargin" >
+   <property name="margin">
     <number>9</number>
    </property>
-   <property name="topMargin" >
-    <number>9</number>
-   </property>
-   <property name="rightMargin" >
-    <number>9</number>
-   </property>
-   <property name="bottomMargin" >
-    <number>9</number>
-   </property>
    <item>
-    <widget class="QGroupBox" name="groupBox" >
-     <property name="title" >
+    <widget class="QGroupBox" name="groupBox">
+     <property name="title">
       <string>Video</string>
      </property>
-     <property name="flat" >
+     <property name="flat">
       <bool>false</bool>
      </property>
-     <layout class="QGridLayout" >
-      <property name="leftMargin" >
+     <layout class="QGridLayout">
+      <property name="margin">
        <number>9</number>
       </property>
-      <property name="topMargin" >
-       <number>9</number>
-      </property>
-      <property name="rightMargin" >
-       <number>9</number>
-      </property>
-      <property name="bottomMargin" >
-       <number>9</number>
-      </property>
-      <property name="horizontalSpacing" >
+      <property name="spacing">
        <number>6</number>
       </property>
-      <property name="verticalSpacing" >
-       <number>6</number>
-      </property>
-      <item row="3" column="1" >
-       <widget class="QLabel" name="labelFrameRate" >
-        <property name="text" >
+      <item row="3" column="1">
+       <widget class="QLabel" name="labelFrameRate">
+        <property name="text">
          <string>TextLabel</string>
         </property>
        </widget>
       </item>
-      <item row="3" column="0" >
-       <widget class="QLabel" name="label_2" >
-        <property name="text" >
+      <item row="3" column="0">
+       <widget class="QLabel" name="label_2">
+        <property name="text">
          <string>Frame Rate:</string>
         </property>
        </widget>
       </item>
-      <item row="4" column="1" >
-       <widget class="QLabel" name="labelNbOfFrames" >
-        <property name="text" >
+      <item row="4" column="1">
+       <widget class="QLabel" name="labelVideoDuration">
+        <property name="text">
          <string>TextLabel</string>
         </property>
        </widget>
       </item>
-      <item row="4" column="0" >
-       <widget class="QLabel" name="label_3" >
-        <property name="text" >
-         <string>Frame Count: </string>
-        </property>
-       </widget>
-      </item>
-      <item row="5" column="1" >
-       <widget class="QLabel" name="labelVideoDuration" >
-        <property name="text" >
-         <string>TextLabel</string>
-        </property>
-       </widget>
-      </item>
-      <item row="5" column="0" >
-       <widget class="QLabel" name="label_5" >
-        <property name="text" >
+      <item row="4" column="0">
+       <widget class="QLabel" name="label_5">
+        <property name="text">
          <string>Total Duration:</string>
         </property>
        </widget>
       </item>
-      <item row="2" column="1" >
-       <widget class="QLabel" name="LabelAspectRatio" >
-        <property name="text" >
+      <item row="2" column="1">
+       <widget class="QLabel" name="LabelAspectRatio">
+        <property name="text">
          <string>TextLabel</string>
         </property>
        </widget>
       </item>
-      <item row="2" column="0" >
-       <widget class="QLabel" name="label_6" >
-        <property name="text" >
+      <item row="2" column="0">
+       <widget class="QLabel" name="label_6">
+        <property name="text">
          <string>Aspect Ratio:</string>
         </property>
        </widget>
       </item>
-      <item row="1" column="1" >
-       <widget class="QLabel" name="labeImageSize" >
-        <property name="text" >
+      <item row="1" column="1">
+       <widget class="QLabel" name="labeImageSize">
+        <property name="text">
          <string>TextLabel</string>
         </property>
        </widget>
       </item>
-      <item row="1" column="0" >
-       <widget class="QLabel" name="label" >
-        <property name="text" >
+      <item row="1" column="0">
+       <widget class="QLabel" name="label">
+        <property name="text">
          <string>Image Size:</string>
         </property>
        </widget>
       </item>
-      <item row="0" column="1" >
-       <widget class="QLabel" name="label4CC" >
-        <property name="text" >
+      <item row="0" column="1">
+       <widget class="QLabel" name="label4CC">
+        <property name="text">
          <string>TextLabel</string>
         </property>
        </widget>
       </item>
-      <item row="0" column="0" >
-       <widget class="QLabel" name="label_4" >
-        <property name="text" >
+      <item row="0" column="0">
+       <widget class="QLabel" name="label_4">
+        <property name="text">
          <string>Codec 4CC:</string>
         </property>
        </widget>
@@ -143,67 +109,55 @@
     </widget>
    </item>
    <item>
-    <widget class="QGroupBox" name="groupBox_2" >
-     <property name="title" >
+    <widget class="QGroupBox" name="groupBox_2">
+     <property name="title">
       <string>Extra Video Properties</string>
      </property>
-     <layout class="QGridLayout" >
-      <property name="leftMargin" >
+     <layout class="QGridLayout">
+      <property name="margin">
        <number>9</number>
       </property>
-      <property name="topMargin" >
-       <number>9</number>
-      </property>
-      <property name="rightMargin" >
-       <number>9</number>
-      </property>
-      <property name="bottomMargin" >
-       <number>9</number>
-      </property>
-      <property name="horizontalSpacing" >
+      <property name="spacing">
        <number>6</number>
       </property>
-      <property name="verticalSpacing" >
-       <number>6</number>
-      </property>
-      <item row="0" column="0" >
-       <widget class="QLabel" name="label_9" >
-        <property name="text" >
+      <item row="0" column="0">
+       <widget class="QLabel" name="label_9">
+        <property name="text">
          <string>Global Motion Compensation:</string>
         </property>
        </widget>
       </item>
-      <item row="1" column="1" >
-       <widget class="QLabel" name="LabelPackedBitstream" >
-        <property name="text" >
+      <item row="1" column="1">
+       <widget class="QLabel" name="LabelPackedBitstream">
+        <property name="text">
          <string>TextLabel</string>
         </property>
        </widget>
       </item>
-      <item row="1" column="0" >
-       <widget class="QLabel" name="label_8" >
-        <property name="text" >
+      <item row="1" column="0">
+       <widget class="QLabel" name="label_8">
+        <property name="text">
          <string>Packed Bitstream:</string>
         </property>
        </widget>
       </item>
-      <item row="2" column="1" >
-       <widget class="QLabel" name="LabelQuarterPixel" >
-        <property name="text" >
+      <item row="2" column="1">
+       <widget class="QLabel" name="LabelQuarterPixel">
+        <property name="text">
          <string>TextLabel</string>
         </property>
        </widget>
       </item>
-      <item row="2" column="0" >
-       <widget class="QLabel" name="label_7" >
-        <property name="text" >
+      <item row="2" column="0">
+       <widget class="QLabel" name="label_7">
+        <property name="text">
          <string>Quarter Pixel:</string>
         </property>
        </widget>
       </item>
-      <item row="0" column="1" >
-       <widget class="QLabel" name="LabelGMC" >
-        <property name="text" >
+      <item row="0" column="1">
+       <widget class="QLabel" name="LabelGMC">
+        <property name="text">
          <string>TextLabel</string>
         </property>
        </widget>
@@ -212,126 +166,100 @@
     </widget>
    </item>
    <item>
-    <widget class="QGroupBox" name="groupBoxAudio" >
-     <property name="title" >
+    <widget class="QGroupBox" name="groupBoxAudio">
+     <property name="title">
       <string>Audio</string>
      </property>
-     <property name="flat" >
+     <property name="flat">
       <bool>false</bool>
      </property>
-     <layout class="QGridLayout" >
-      <property name="leftMargin" >
+     <layout class="QGridLayout">
+      <property name="margin">
        <number>9</number>
       </property>
-      <property name="topMargin" >
-       <number>9</number>
-      </property>
-      <property name="rightMargin" >
-       <number>9</number>
-      </property>
-      <property name="bottomMargin" >
-       <number>9</number>
-      </property>
-      <property name="horizontalSpacing" >
+      <property name="spacing">
        <number>6</number>
       </property>
-      <property name="verticalSpacing" >
-       <number>6</number>
-      </property>
-      <item row="6" column="1" >
-       <widget class="QLabel" name="labelFileSize" >
-        <property name="text" >
+      <item row="5" column="1">
+       <widget class="QLabel" name="labelAudioDuration">
+        <property name="text">
          <string/>
         </property>
        </widget>
       </item>
-      <item row="6" column="0" >
-       <widget class="QLabel" name="label_16" >
-        <property name="text" >
-         <string>File Size:</string>
-        </property>
-       </widget>
-      </item>
-      <item row="5" column="1" >
-       <widget class="QLabel" name="labelAudioDuration" >
-        <property name="text" >
-         <string/>
-        </property>
-       </widget>
-      </item>
-      <item row="5" column="0" >
-       <widget class="QLabel" name="label_13" >
-        <property name="text" >
+      <item row="5" column="0">
+       <widget class="QLabel" name="label_13">
+        <property name="text">
          <string>Total Duration:</string>
         </property>
        </widget>
       </item>
-      <item row="4" column="0" >
-       <widget class="QLabel" name="label_11" >
-        <property name="text" >
+      <item row="4" column="0">
+       <widget class="QLabel" name="label_11">
+        <property name="text">
          <string>Frequency:</string>
         </property>
        </widget>
       </item>
-      <item row="4" column="1" >
-       <widget class="QLabel" name="labelFrequency" >
-        <property name="text" >
+      <item row="4" column="1">
+       <widget class="QLabel" name="labelFrequency">
+        <property name="text">
          <string/>
         </property>
        </widget>
       </item>
-      <item row="3" column="0" >
-       <widget class="QLabel" name="label_14" >
-        <property name="text" >
+      <item row="3" column="0">
+       <widget class="QLabel" name="label_14">
+        <property name="text">
          <string>Variable Bitrate:</string>
         </property>
        </widget>
       </item>
-      <item row="3" column="1" >
-       <widget class="QLabel" name="labelVBR" >
-        <property name="text" >
+      <item row="3" column="1">
+       <widget class="QLabel" name="labelVBR">
+        <property name="text">
          <string/>
         </property>
        </widget>
       </item>
-      <item row="2" column="1" >
-       <widget class="QLabel" name="labelBitrate" >
-        <property name="text" >
+      <item row="2" column="1">
+       <widget class="QLabel" name="labelBitrate">
+        <property name="text">
          <string/>
         </property>
        </widget>
       </item>
-      <item row="2" column="0" >
-       <widget class="QLabel" name="label_15" >
-        <property name="text" >
+      <item row="2" column="0">
+       <widget class="QLabel" name="label_15">
+        <property name="text">
          <string>Bitrate:</string>
         </property>
        </widget>
       </item>
-      <item row="1" column="1" >
-       <widget class="QLabel" name="labelChannels" >
-        <property name="text" >
+      <item row="1" column="1">
+       <widget class="QLabel" name="labelChannels">
+        <property name="text">
          <string/>
         </property>
        </widget>
       </item>
-      <item row="1" column="0" >
-       <widget class="QLabel" name="label_10" >
-        <property name="text" >
+      <item row="1" column="0">
+       <widget class="QLabel" name="label_10">
+        <property name="text">
          <string>Channels:</string>
         </property>
        </widget>
       </item>
-      <item row="0" column="1" >
-       <widget class="QLabel" name="labelACodec" >
-        <property name="text" >
+      <item row="0" column="1">
+       <widget class="QLabel" name="labelACodec">
+        <property name="text">
          <string/>
         </property>
        </widget>
       </item>
-      <item row="0" column="0" >
-       <widget class="QLabel" name="label_12" >
-        <property name="text" >
+      <item row="0" column="0">
+       <widget class="QLabel" name="label_12">
+        <property name="text">
          <string>Codec:</string>
         </property>
        </widget>
@@ -340,20 +268,20 @@
     </widget>
    </item>
    <item>
-    <widget class="QPushButton" name="pushButton" >
-     <property name="sizePolicy" >
-      <sizepolicy vsizetype="Fixed" hsizetype="Fixed" >
+    <widget class="QPushButton" name="pushButton">
+     <property name="sizePolicy">
+      <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
        <horstretch>0</horstretch>
        <verstretch>0</verstretch>
       </sizepolicy>
      </property>
-     <property name="layoutDirection" >
+     <property name="layoutDirection">
       <enum>Qt::RightToLeft</enum>
      </property>
-     <property name="text" >
+     <property name="text">
       <string>OK</string>
      </property>
-     <property name="default" >
+     <property name="default">
       <bool>true</bool>
      </property>
     </widget>
@@ -368,11 +296,11 @@
    <receiver>propsDialog</receiver>
    <slot>accept()</slot>
    <hints>
-    <hint type="sourcelabel" >
+    <hint type="sourcelabel">
      <x>284</x>
      <y>424</y>
     </hint>
-    <hint type="destinationlabel" >
+    <hint type="destinationlabel">
      <x>167</x>
      <y>252</y>
     </hint>



From mean at mail.berlios.de  Sat Oct 24 16:57:05 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 24 Oct 2009 16:57:05 +0200
Subject: [Avidemux-svn-commit] r5408 -
	branches/avidemux_2.6_branch_mean/avidemux/common
Message-ID: <200910241457.n9OEv5Q3022272@sheep.berlios.de>

Author: mean
Date: 2009-10-24 16:57:05 +0200 (Sat, 24 Oct 2009)
New Revision: 5408

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/CMakeLists.txt
Log:
[common] Remove unused subdirs

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/CMakeLists.txt	2009-10-24 14:57:04 UTC (rev 5407)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/CMakeLists.txt	2009-10-24 14:57:05 UTC (rev 5408)
@@ -11,7 +11,7 @@
 ADD_SUBDIRECTORY(ADM_muxerGate)
 #ADD_SUBDIRECTORY(ADM_ocr)
 ADD_SUBDIRECTORY(ADM_osSupport)
-ADD_SUBDIRECTORY(ADM_plugin)
+#ADD_SUBDIRECTORY(ADM_plugin)
 ADD_SUBDIRECTORY(ADM_render)
 ADD_SUBDIRECTORY(ADM_requant)
 ADD_SUBDIRECTORY(ADM_script)



From mean at mail.berlios.de  Sat Oct 24 16:57:04 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 24 Oct 2009 16:57:04 +0200
Subject: [Avidemux-svn-commit] r5407 -
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioParser/src
Message-ID: <200910241457.n9OEv4cO022262@sheep.berlios.de>

Author: mean
Date: 2009-10-24 16:57:04 +0200 (Sat, 24 Oct 2009)
New Revision: 5407

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioParser/src/ADM_dcainfo.cpp
Log:
[DCA] enforce LFE

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioParser/src/ADM_dcainfo.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioParser/src/ADM_dcainfo.cpp	2009-10-24 14:57:02 UTC (rev 5406)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioParser/src/ADM_dcainfo.cpp	2009-10-24 14:57:04 UTC (rev 5407)
@@ -98,8 +98,12 @@
 #endif
                 *syncoff=cur-buf;
                 if(*syncoff) printf("[dts] Dropped %u bytes\n",*syncoff);
-                *chan=dts_channels[flags & 0xf];
-//                if(*chan==5 && (flags & 0X80)) *chan++;
+                get_bits(&s,10);
+                int lfe=get_bits(&s,2);
+                int c;
+                c=dts_channels[flags & 0xf];
+                if(c==5 && lfe) c++; // LFE
+                *chan=c;
                 *nbSample=nbBlocks*32;
                 return framesize;
                 



From mean at mail.berlios.de  Sat Oct 24 16:57:06 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 24 Oct 2009 16:57:06 +0200
Subject: [Avidemux-svn-commit] r5409 -
	branches/avidemux_2.6_branch_mean/avidemux/qt4
Message-ID: <200910241457.n9OEv6pp022282@sheep.berlios.de>

Author: mean
Date: 2009-10-24 16:57:06 +0200 (Sat, 24 Oct 2009)
New Revision: 5409

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/qt4/CMakeLists.txt
Log:
[qt4] Make a symlink for common on unix, moste IDE are confused if we do not.

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/CMakeLists.txt	2009-10-24 14:57:05 UTC (rev 5408)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/CMakeLists.txt	2009-10-24 14:57:06 UTC (rev 5409)
@@ -38,7 +38,18 @@
 # Add subdirectories 
 ########################################
 INCLUDE_DIRECTORIES(ADM_UIs/include/)
-ADD_SUBDIRECTORY(../common ./commonQt4)
+if(WIN32)
+        ADD_SUBDIRECTORY(../common ./commonQt4)
+else(WIN32)
+        # Make symlink else eclipe and kdev4 are puzzled by the tree structure
+        # Not needed for plain build
+        MESSAGE(STATUS "Creating common symlink in ${CMAKE_CURRENT_SOURCE_DIR}") 
+	execute_process(COMMAND rm -f common 	
+                                WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR})
+	execute_process(COMMAND ln -s ../common .
+                                WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR})
+        ADD_SUBDIRECTORY(common ./commonQt4)
+endif(WIN32)
 ADD_SUBDIRECTORY(ADM_UIs ./ADM_UIsQt4)
 ADD_SUBDIRECTORY(ADM_userInterfaces ./ADM_userInterfacesQT4)
 # Executable



From mean at mail.berlios.de  Sat Oct 24 17:58:44 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 24 Oct 2009 17:58:44 +0200
Subject: [Avidemux-svn-commit] r5410 - in
	branches/avidemux_2.5_branch_gruntster/avidemux:
	ADM_audiofilter ADM_coreAudio/include
Message-ID: <200910241558.n9OFwiMZ029900@sheep.berlios.de>

Author: mean
Date: 2009-10-24 17:58:43 +0200 (Sat, 24 Oct 2009)
New Revision: 5410

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audio_encoderWrapper.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audio_encoderWrapper.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/include/audioencoder.h
Log:
[AudioEnCoder] export VBR through wrapper, ref #45

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audio_encoderWrapper.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audio_encoderWrapper.cpp	2009-10-24 14:57:06 UTC (rev 5409)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audio_encoderWrapper.cpp	2009-10-24 15:58:43 UTC (rev 5410)
@@ -78,5 +78,13 @@
     return _encoder->extraData(l,d);
 
 }
-
+/**
+    \fn isVBR
+    \brief Trampoline
+*/
+uint8_t  	ADM_audioEncoderWrapper::isVBR(void )
+{
+    ADM_assert(_encoder);
+    return _encoder->isVBR();
+}
 //EOF
\ No newline at end of file

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audio_encoderWrapper.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audio_encoderWrapper.h	2009-10-24 14:57:06 UTC (rev 5409)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audio_encoderWrapper.h	2009-10-24 15:58:43 UTC (rev 5410)
@@ -20,6 +20,7 @@
         virtual uint8_t		goTo(uint32_t offset) {ADM_assert(0);return 0;} // Not supposed to seek..
         virtual uint32_t	read(uint32_t size,uint8_t *ptr);
         virtual uint8_t		extraData(uint32_t *l,uint8_t **d);
+        virtual uint8_t  	isVBR(void ) ;
 };
 
 #endif

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/include/audioencoder.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/include/audioencoder.h	2009-10-24 14:57:06 UTC (rev 5409)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/include/audioencoder.h	2009-10-24 15:58:43 UTC (rev 5410)
@@ -72,6 +72,7 @@
     virtual uint8_t packetPerFrame( void) {return 1;}
     virtual uint8_t extraData(uint32_t *l,uint8_t **d) {*l=_extraSize;*d=_extraData;return 1;}
             uint8_t  goTo(uint32_t timeMS) {ADM_assert(0);return 1;}
+    virtual bool    isVBR(void) {return false;}
 };
 // Used by some old code (lame/twolame) OBSOLETE   / DO NOT USE
 typedef enum  



From mean at mail.berlios.de  Sat Oct 24 17:58:48 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 24 Oct 2009 17:58:48 +0200
Subject: [Avidemux-svn-commit] r5411 -
	branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lame
Message-ID: <200910241558.n9OFwm2J029911@sheep.berlios.de>

Author: mean
Date: 2009-10-24 17:58:45 +0200 (Sat, 24 Oct 2009)
New Revision: 5411

Modified:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lame/audioencoder_lame.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lame/audioencoder_lame.h
Log:
[Lame] Properly export lame VBR settings, ref #45

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lame/audioencoder_lame.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lame/audioencoder_lame.cpp	2009-10-24 15:58:43 UTC (rev 5410)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lame/audioencoder_lame.cpp	2009-10-24 15:58:45 UTC (rev 5411)
@@ -172,11 +172,15 @@
     {
     default:
     case ADM_LAME_PRESET_CBR:
+          lame_set_VBR(MYFLAGS, vbr_off);
       break;
     case ADM_LAME_PRESET_ABR:
 
-      lame_set_preset (MYFLAGS, lameConf->bitrate);
+     // lame_set_preset (MYFLAGS, lameConf->bitrate);
       _wavheader->blockalign = BLOCK_SIZE;
+       lame_set_VBR(MYFLAGS, vbr_abr);
+       lame_set_VBR_mean_bitrate_kbps(MYFLAGS, lameConf->bitrate);
+
       break;
     case ADM_LAME_PRESET_EXTREME:
       _wavheader->blockalign = BLOCK_SIZE;
@@ -197,7 +201,7 @@
     @return 1 if the stream is vbr, 0 is cbr
 
 */
-uint8_t AUDMEncoder_Lame::isVBR (void)
+bool AUDMEncoder_Lame::isVBR (void)
 {
   if (myLameParam.preset == ADM_LAME_PRESET_CBR)
     return 0;

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lame/audioencoder_lame.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lame/audioencoder_lame.h	2009-10-24 15:58:43 UTC (rev 5410)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lame/audioencoder_lame.h	2009-10-24 15:58:45 UTC (rev 5411)
@@ -27,7 +27,7 @@
 //            uint8_t     init(ADM_audioEncoderDescriptor *config);
     virtual             ~AUDMEncoder_Lame();
                         AUDMEncoder_Lame(AUDMAudioFilter *instream);	
-            uint8_t	isVBR(void );
+   virtual bool	    isVBR(void );
             
    virtual uint8_t	getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples);
    virtual uint8_t  initialize(void);



From mean at mail.berlios.de  Sun Oct 25 19:27:27 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 25 Oct 2009 19:27:27 +0100
Subject: [Avidemux-svn-commit] r5412 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor
Message-ID: <200910251827.n9PIRRhA000418@sheep.berlios.de>

Author: mean
Date: 2009-10-25 19:27:25 +0100 (Sun, 25 Oct 2009)
New Revision: 5412

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADMedAVIAUD.cpp
Log:
[Editor] Better segment switching + preliminary audio handling when switching segment

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp	2009-10-24 15:58:45 UTC (rev 5411)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp	2009-10-25 18:27:25 UTC (rev 5412)
@@ -129,6 +129,9 @@
     {
         goto np_nextSeg;
     }
+        // Refresh in case we switched....
+        seg=_segments.getSegment(_currentSegment);
+        updateImageTiming(seg,image);
         // no we have our image, let's check it is within this segment range..
         pts=image->Pts;
         tail=seg->_startTimeUs+seg->_durationUs;
@@ -136,10 +139,11 @@
         {
                 ADM_info("Got an image (%"LU" ms, but is out of this segment (%"LU"+%"LU"=%"LU" ms)\n",
                                                                     pts,seg->_startTimeUs,seg->_durationUs,tail);
+                _segments.dump();
                 goto np_nextSeg;
         }
         
-        updateImageTiming(seg,image);
+
         return true;
 
 // Try to get an image for the following segment....

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp	2009-10-24 15:58:45 UTC (rev 5411)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp	2009-10-25 18:27:25 UTC (rev 5412)
@@ -52,8 +52,7 @@
 
    packetBufferSize=0;
    packetBufferDts=ADM_NO_PTS;
-  _audioseg = 0;
-  _audiooffset = 0;
+  _audioSeg = 0;
   _audioSample=0;
 
   // Initialize a default postprocessing (dummy)

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx	2009-10-24 15:58:45 UTC (rev 5411)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx	2009-10-25 18:27:25 UTC (rev 5412)
@@ -45,12 +45,12 @@
 */
 typedef enum
 {
-	ENV_EDITOR_NONE=   0x0000,
-	ENV_EDITOR_BFRAME= 0x0001,
-	ENV_EDITOR_PVOP=   0x0002,
-    ENV_EDITOR_X264=   0x0004,
-    ENV_EDITOR_SMART=  0x0005,
-	ENV_EDITOR_LAST=   0x8000
+        ENV_EDITOR_NONE=   0x0000,
+        ENV_EDITOR_BFRAME= 0x0001,
+        ENV_EDITOR_PVOP=   0x0002,
+        ENV_EDITOR_X264=   0x0004,
+        ENV_EDITOR_SMART=  0x0005,
+        ENV_EDITOR_LAST=   0x8000
 }_ENV_EDITOR_FLAGS;
 
 
@@ -91,27 +91,24 @@
   private:
                     ADM_EditorSegment _segments;
                     uint8_t     dupe(ADMImage *src,ADMImage *dst,_VIDEOS *vid); 
-                                                            // Duplicate img, do colorspace
-                                                            // if needed
-  					uint32_t	_internalFlags;
-  					ADM_PP 		_pp;
-					ADMImage	*_imageBuffer;
-  				
-  					// _audiooffset points to the offset / the total segment
-  					// not the used part !
-  					uint32_t  _audioseg;
-					int64_t   _audioSample;
-  					uint32_t  _audiooffset;
+                    uint32_t	_internalFlags;  // Flags :
+                    ADM_PP      _pp;             // Postprocessing settings
+                    ADMImage	*_imageBuffer;   // Temp buffer used for decoding
+                    uint32_t    _currentSegment;   // Current video segment
+//****************************** Audio **********************************
+                    // _audiooffset points to the offset / the total segment
+                    // not the used part !
+                    uint32_t  _audioSeg;
+                    int64_t   _audioSample;
 
-                    uint32_t  _currentSegment;
-       				//uint32_t _lastseg,_lastframe,_lastlen;
-
                     ADM_audioStreamTrack *getTrack(uint32_t i);
                     ADMImage    *_scratch;																		;
-                    uint8_t  	updateAudioTrack(uint32_t seg);			   	
-                    void 		deleteAllVideos(void );
-                    uint8_t 	getMagic(const char *name,uint32_t *magic);
-                    uint32_t 	searchForwardSeg(uint32_t startframe);
+                    uint8_t  	updateAudioTrack(uint32_t seg);
+                    bool        switchToNextAudioSegment(void);
+//****************************** Audio **********************************
+                    void        deleteAllVideos(void );
+                    uint8_t     getMagic(const char *name,uint32_t *magic);
+                    uint32_t    searchForwardSeg(uint32_t startframe);
                     bool        rederiveFrameType(vidHeader *demuxer);
 
   public:
@@ -120,16 +117,16 @@
                     uint32_t    getPARWidth(void);
                     uint32_t    getPARHeight(void);
                     bool        rebuildDuration(void);
-  								ADM_Composer();
-  				virtual 			~ADM_Composer();
-                    void		clean( void );
+                                ADM_Composer();
+virtual                         ~ADM_Composer();
+                    void        clean( void );
                     uint8_t     saveAsScript (const char *name, const char *out);
                     uint8_t 	saveWorbench(const char *name);
                     uint8_t 	loadWorbench(const char *name);
                     uint8_t     resetSeg( void );
                     bool     	addFile (const char *name);
                     uint8_t 	cleanup( void);
-                    bool 	    isMultiSeg( void);
+                    bool        isMultiSeg( void);
 /************************************* Markers *****************************/
 private:        
                     uint64_t    markerAPts,markerBPts;
@@ -163,7 +160,7 @@
 public:
                     
             virtual uint8_t         getPacket(uint8_t *buffer,uint32_t *size, uint32_t sizeMax,uint32_t *nbSample,uint64_t *dts);
-                    uint8_t         getPCMPacket(float  *dest, uint32_t sizeMax, uint32_t *samples,uint64_t *odts);
+                    bool            getPCMPacket(float  *dest, uint32_t sizeMax, uint32_t *samples,uint64_t *odts);
             virtual bool            goToTime(uint64_t nbUs);
                     bool            getExtraData(uint32_t *l, uint8_t **d);
                     uint64_t        getDurationInUs(void);
@@ -174,13 +171,13 @@
                     bool            getAudioStreamsInfo(uint64_t xtime,uint32_t *nbStreams, audioInfo **infos);
                     bool            changeAudioStream(uint64_t xtime,uint32_t newstream);
                     uint32_t        getCurrentAudioStreamNumber(uint64_t xframe);
-                    bool    		setDecodeParam( uint64_t frameTime );
+                    bool            setDecodeParam( uint64_t frameTime );
 /**************************************** Video Info **************************/
-	 				AVIStreamHeader 	*getVideoStreamHeader(void ) ;
-	 				MainAVIHeader 		*getMainHeader(void );
-	 				ADM_BITMAPINFOHEADER 	*getBIH(void ) ;
+                    AVIStreamHeader 	*getVideoStreamHeader(void ) ;
+                    MainAVIHeader 		*getMainHeader(void );
+                    ADM_BITMAPINFOHEADER 	*getBIH(void ) ;
 
-	  				uint8_t			getVideoInfo(aviInfo *info);
+                    uint8_t			getVideoInfo(aviInfo *info);
                     uint64_t        getVideoDuration(void);
                     uint64_t        getFrameIncrement(void); /// Returns the # of us between 2 frames or the smaller value of them
 
@@ -189,18 +186,18 @@
 					
 /***************************************** Seeking *****************************/            
 public:
-                    bool			getNKFramePTS(uint64_t *frameTime);
-                    bool			getPKFramePTS(uint64_t *frameTime);   
+                    bool                getNKFramePTS(uint64_t *frameTime);
+                    bool                getPKFramePTS(uint64_t *frameTime);
 /******************************* Post Processing ************************************/
-					uint8_t 		setPostProc( uint32_t type, uint32_t strength,	uint32_t swapuv);
-					uint8_t 		getPostProc( uint32_t *type, uint32_t *strength,uint32_t *swapuv);
+                    uint8_t             setPostProc( uint32_t type, uint32_t strength,	uint32_t swapuv);
+                    uint8_t             getPostProc( uint32_t *type, uint32_t *strength,uint32_t *swapuv);
 /******************************* /Post Processing ************************************/	
 /******************************* Editing ************************************/	
-                    bool            remove(uint64_t start,uint64_t end);
+                    bool                remove(uint64_t start,uint64_t end);
 /******************************* /Editing **********************************/										
 /******************************* Misc ************************************/				
-					uint8_t			setEnv(_ENV_EDITOR_FLAGS newflag);
-					uint8_t			getEnv(_ENV_EDITOR_FLAGS newflag);
+                    uint8_t             setEnv(_ENV_EDITOR_FLAGS newflag);
+                    uint8_t             getEnv(_ENV_EDITOR_FLAGS newflag);
 /******************************* /Misc ************************************/				
 
 };

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.h	2009-10-24 15:58:45 UTC (rev 5411)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.h	2009-10-25 18:27:25 UTC (rev 5412)
@@ -33,7 +33,7 @@
     ADM_audioStream  *stream;
     audioInfo        *info;
     ADM_Audiocodec   *codec;
-    WAVHeader		 wavheader;
+    WAVHeader        wavheader;
     bool             vbr;
     uint64_t         duration;
     uint64_t         size;
@@ -48,25 +48,25 @@
 */
 typedef struct
 {
-  	vidHeader 							*_aviheader;  /// Demuxer
-  	decoders							*decoder;     /// Video codec
-    COL_Generic2YV12                    *color;       /// Color conversion if needed
+      vidHeader *_aviheader; /// Demuxer
+      decoders *decoder; /// Video codec
+      COL_Generic2YV12 *color; /// Color conversion if needed
 
-	/* Audio part */
+      /* Audio part */
 
-    uint32_t                            nbAudioStream;   
-    uint32_t                            currentAudioStream;
-    ADM_audioStreamTrack                **audioTracks;
+      uint32_t nbAudioStream;
+      uint32_t currentAudioStream;
+      ADM_audioStreamTrack **audioTracks;
 
-	uint32_t							_nb_video_frames;  /// Really needed ?	
-	EditorCache							*_videoCache;      /// Decoded video cache
+      uint32_t _nb_video_frames; /// Really needed ?
+      EditorCache *_videoCache; /// Decoded video cache
 
-    /* Timeing info */
+      /* Timeing info */
 
-    uint32_t                            lastSentFrame;     /// Last frame read/sent to decoder
-    uint64_t                            lastDecodedPts;    /// Pts of last frame out of decoder
-    uint64_t                            lastReadPts;       /// Pts of the last frame we read
-    uint64_t                            timeIncrementInUs; /// in case the video has no PTS, time increment (us)
+      uint32_t lastSentFrame; /// Last frame read/sent to decoder
+      uint64_t lastDecodedPts; /// Pts of last frame out of decoder
+      uint64_t lastReadPts; /// Pts of the last frame we read
+      uint64_t timeIncrementInUs; /// in case the video has no PTS, time increment (us)
 }_VIDEOS;
 
 /**
@@ -76,13 +76,13 @@
 */
 typedef struct
 {
-  	uint32_t							_reference;       /// Reference video
- 	uint64_t							_refStartTimeUs;  /// Starting time in reference
-    uint64_t                            _startTimeUs;     /// Start time in current (=sum(_duration of previous seg))
-	uint64_t							_durationUs;      ///
-    uint32_t                            _nbFrame;
-    uint32_t                            _curFrame;        ///
-}_SEGMENT;
+        uint32_t _reference; /// Reference video
+        uint64_t _refStartTimeUs; /// Starting time in reference
+        uint64_t _startTimeUs; /// Start time in current (=sum(_duration of previous seg))
+        uint64_t _durationUs; ///
+        uint32_t _nbFrame;
+        uint32_t _curFrame; ///
+} _SEGMENT;
 /*
     Use vectors to store our videos & segments
 */
@@ -98,9 +98,10 @@
         ListOfSegments segments;
         ListOfVideos   videos;
         bool           updateStartTime(void);
-        void           dump(void);
 
+
 public:
+            void        dump(void);
                         ADM_EditorSegment(void);
                         ~ADM_EditorSegment();
             bool        addReferenceVideo(_VIDEOS *ref);

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADMedAVIAUD.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADMedAVIAUD.cpp	2009-10-24 15:58:45 UTC (rev 5411)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADMedAVIAUD.cpp	2009-10-25 18:27:25 UTC (rev 5412)
@@ -1,11 +1,11 @@
 /***************************************************************************
-                          ADMedAVIAUD.cpp  -  description
-                             -------------------
+   \fn  ADMedAVIAUD.cpp
+   \brief Interface to audio track(s) from editor
 
     Handle switching from pieces of movie
     Also fix the gap/overlap in audio to offer a strictly continuous audio stream
     
-    copyright            : (C) 2008 by mean
+    copyright            : (C) 2008/2009 by mean
     email                : fixounet at free.fr
 
 Todo:
@@ -50,7 +50,29 @@
 
 // ADM_audioStreamTack *
 #define MYAUDIO (_videos[0].audioTracks[_videos[0].currentAudioStream])
+/**
+ *      \fn switchToNextAudioSegment
+ *
+ */
+bool ADM_Composer::switchToNextAudioSegment(void)
+{
+        // Try to switch segment
+        if(_audioSeg+1>=_segments.getNbSegments()) return false;
 
+        ADM_warning("Switching to segment %"LU"\n",_audioSeg+1);
+        _audioSeg++;
+        _SEGMENT *seg=_segments.getSegment(_audioSeg);
+        ADM_audioStreamTrack *trk=getTrack(seg->_reference);
+        // Go to beginning of the stream
+        if(false==trk->stream->goToTime(seg->_refStartTimeUs))
+          {
+            ADM_warning("Fail to seek audio to %"LLU"ms\n",seg->_refStartTimeUs/1000);
+            return false;
+          }
+        ADM_info("Switched ok to audio segment %"LU"\n",_audioSeg);
+        return true;
+
+}
 /**
     \fn refillPacketBuffer
     \brief Fetch a new packet
@@ -58,31 +80,58 @@
 bool ADM_Composer::refillPacketBuffer(void)
 {
    packetBufferSize=0; 
-   ADM_audioStreamTrack *trk=getTrack(0);
+   uint64_t dts;
+   _SEGMENT *seg=_segments.getSegment(_audioSeg);
+   if(!seg) return false;
+
+   if(lastDts>=seg->_startTimeUs+seg->_durationUs)
+     {
+       ADM_info("Consumed all data from this audio segment\n");
+       switchToNextAudioSegment();
+       seg=_segments.getSegment(_audioSeg);
+     }
+
+
+
+   ADM_audioStreamTrack *trk=getTrack(seg->_reference);
     if(!trk) return false;    
-   if(!trk->stream->getPacket(packetBuffer,&packetBufferSize,ADM_EDITOR_PACKET_BUFFER_SIZE,
-                        &packetBufferSamples,&packetBufferDts))
+
+    if(!trk->stream->getPacket(packetBuffer,&packetBufferSize,ADM_EDITOR_PACKET_BUFFER_SIZE,
+                        &packetBufferSamples,&dts))
     {
-            adm_printf(ADM_PRINT_ERROR,"[Composer::getPCMPacket] Read failed\n");
-            return false;
+              if(true==switchToNextAudioSegment())
+                 return refillPacketBuffer();
+             ADM_warning("End of audio\n");
+             return false;
     }
+    //
+    // Ok we have a packet, rescale audio
+    if(dts==ADM_NO_PTS) packetBufferDts=ADM_NO_PTS;
+    else
+    {
+      if(dts>=seg->_refStartTimeUs) packetBufferDts=dts+seg->_startTimeUs-seg->_refStartTimeUs;
+      else
+        {
+          ADM_warning("Got PTS=%"LLU" which is too early for start=%"LLU"ms\n",dts/1000,seg->_refStartTimeUs);
+          return refillPacketBuffer();
+        }
+    }
     return true;
 }
 
-
 /**
     \fn     getPCMPacket
     \brief  Get audio packet
 
 */
 
-uint8_t ADM_Composer::getPCMPacket(float  *dest, uint32_t sizeMax, uint32_t *samples,uint64_t *odts)
+bool ADM_Composer::getPCMPacket(float  *dest, uint32_t sizeMax, uint32_t *samples,uint64_t *odts)
 {
 uint32_t fillerSample=0;   // FIXME : Store & fix the DTS error correctly!!!!
 uint32_t inSize;
 bool drop=false;
+static bool fail=false;
 
-
 again:
     *samples=0;
     ADM_audioStreamTrack *trk=getTrack(0);
@@ -92,14 +141,16 @@
     {
         if(!refillPacketBuffer())
         {
-            printf("[Editor] Cannot refill audio\n");
-            return 0;
+            if(fail==false)
+              ADM_warning("[Editor] Cannot refill audio\n");
+            fail=true;
+            return false;
         }
     }
     // We do now
     vprintf("[PCMPacket]  Got %d samples, time code %08lu  lastDts=%08lu delta =%08ld\n",packetBufferSamples,packetBufferDts,lastDts,packetBufferDts-lastDts);
+    fail=false;
 
-
     // Check if the Dts matches
     if(lastDts!=ADM_AUDIO_NO_DTS &&packetBufferDts!=ADM_AUDIO_NO_DTS)
     {
@@ -198,12 +249,24 @@
 */
 bool ADM_Composer::goToTime (uint64_t ustime)
 {
-    printf("[Editor] go to time %02.2f secs\n",((float)ustime)/1000000.);
-    ADM_audioStreamTrack *trk=getTrack(0);
-    if(!trk) return 0;
-    
-    
-    if(true==trk->stream->goToTime(ustime))
+  uint32_t seg;
+  uint64_t segTime;
+    ADM_info(" go to time %02.2f secs\n",((float)ustime)/1000000.);
+    if(false==_segments.convertLinearTimeToSeg(ustime,&seg,&segTime))
+      {
+        ADM_warning("Cannot convert %"LLU" to linear time\n",ustime/1000);
+        return false;
+      }
+    _SEGMENT *s=_segments.getSegment(seg);
+    ADM_audioStreamTrack *trk=getTrack(s->_reference);
+    if(!trk)
+      {
+        ADM_warning("No audio for segment %"LU"\n",seg);
+        return false;
+      }
+    uint64_t seekTime;
+    seekTime=segTime+s->_refStartTimeUs;
+    if(true==trk->stream->goToTime(seekTime))
     {
         setDts(ustime);
         return true;
@@ -234,8 +297,10 @@
 */
 WAVHeader       *ADM_Composer::getInfo(void)
 {
-     ADM_audioStreamTrack *trk=getTrack(0);
-    if(!trk) return 0;
+
+  _SEGMENT *seg=_segments.getSegment(_audioSeg);
+    ADM_audioStreamTrack *trk=getTrack(seg->_reference);
+    if(!trk) return NULL;
     return trk->stream->getInfo();
 }
 /**
@@ -244,29 +309,33 @@
 */
  CHANNEL_TYPE    *ADM_Composer::getChannelMapping(void )
 {
-  ADM_audioStreamTrack *trk=getTrack(0);
+  _SEGMENT *seg=_segments.getSegment(_audioSeg);
+  ADM_audioStreamTrack *trk=getTrack(seg->_reference);
     if(!trk) return NULL;
     return trk->codec->channelMapping;
-
 }
 /**
     \fn getExtraData
 */
 bool            ADM_Composer::getExtraData(uint32_t *l, uint8_t **d)
 {
+  _SEGMENT *seg=_segments.getSegment(_audioSeg);
+  ADM_audioStreamTrack *trk=getTrack(seg->_reference);
+
     *l=0;
     *d=NULL;
-     ADM_audioStreamTrack *trk=getTrack(0);
     if(!trk) return false;
     return trk->stream->getExtraData(l,d); 
 
 }
 /**
     \fn getTrack
+    \brief Returns Track for ref video given as parameter
+    @param : Reference video
 */
-ADM_audioStreamTrack *ADM_Composer::getTrack(uint32_t i)
+ADM_audioStreamTrack *ADM_Composer::getTrack(uint32_t refVideo)
 {
-    _VIDEOS *v=_segments.getRefVideo(0);
+    _VIDEOS *v=_segments.getRefVideo(refVideo);
     if(!v->audioTracks) return NULL;
 
     return v->audioTracks[v->currentAudioStream];



From mean at mail.berlios.de  Sun Oct 25 19:40:20 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 25 Oct 2009 19:40:20 +0100
Subject: [Avidemux-svn-commit] r5413 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor
Message-ID: <200910251840.n9PIeK0W024718@sheep.berlios.de>

Author: mean
Date: 2009-10-25 19:40:19 +0100 (Sun, 25 Oct 2009)
New Revision: 5413

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADMedAVIAUD.cpp
Log:
[Editor] Set new segment when seeking

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADMedAVIAUD.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADMedAVIAUD.cpp	2009-10-25 18:27:25 UTC (rev 5412)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADMedAVIAUD.cpp	2009-10-25 18:40:19 UTC (rev 5413)
@@ -48,8 +48,6 @@
 #define vprintf printf
 #endif
 
-// ADM_audioStreamTack *
-#define MYAUDIO (_videos[0].audioTracks[_videos[0].currentAudioStream])
 /**
  *      \fn switchToNextAudioSegment
  *
@@ -268,6 +266,7 @@
     seekTime=segTime+s->_refStartTimeUs;
     if(true==trk->stream->goToTime(seekTime))
     {
+        _audioSeg=seg;
         setDts(ustime);
         return true;
     }



From mean at mail.berlios.de  Mon Oct 26 07:24:27 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Mon, 26 Oct 2009 07:24:27 +0100
Subject: [Avidemux-svn-commit] r5414 -
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src
Message-ID: <200910260624.n9Q6ORDR026416@sheep.berlios.de>

Author: mean
Date: 2009-10-26 07:24:25 +0100 (Mon, 26 Oct 2009)
New Revision: 5414

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/ADM_fileio.cpp
Log:
[All] Use .avidemux6 as root dir to avoid clash with 2.4/2.5

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/ADM_fileio.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/ADM_fileio.cpp	2009-10-25 18:40:19 UTC (rev 5413)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/ADM_fileio.cpp	2009-10-26 06:24:25 UTC (rev 5414)
@@ -35,10 +35,10 @@
 
 #ifdef __WIN32
 static const char *separator="\\";
-const char *ADM_DIR_NAME="\\avidemux";
+const char *ADM_DIR_NAME="\\avidemux6";
 #else
 static const char *separator="/";
-const char *ADM_DIR_NAME="/.avidemux";
+const char *ADM_DIR_NAME="/.avidemux6";
 #endif
 
 static char ADM_basedir[1024] = {0};



From mean at mail.berlios.de  Tue Oct 27 07:44:18 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 27 Oct 2009 07:44:18 +0100
Subject: [Avidemux-svn-commit] r5415 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_requant
Message-ID: <200910270644.n9R6iIAx025105@sheep.berlios.de>

Author: mean
Date: 2009-10-27 07:44:17 +0100 (Tue, 27 Oct 2009)
New Revision: 5415

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_requant/tcrequant.c
Log:
[Requant] warning removal

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_requant/tcrequant.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_requant/tcrequant.c	2009-10-26 06:24:25 UTC (rev 5414)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_requant/tcrequant.c	2009-10-27 06:44:17 UTC (rev 5415)
@@ -249,7 +249,7 @@
 			inbytecnt += mloka1; \
 			rbuf += mloka1; \
 			if((rbuf-cbuf)<x)  \
-				{printf("Not enough : %"LU" %"LLD"\n",x,rbuf-cbuf);RETURN}\
+				{printf("Not enough : %"LU" %"LLD"\n",x,(int64_t)(rbuf-cbuf));RETURN}\
 		}
 
 	#define FORCE_LOCK() \
@@ -2388,7 +2388,7 @@
 	// Some leftovers, 4 we added to force a startsync and hopefully some crap
 	if(rbuf!=cbuf)
 	{
-    	printf("LeftOver..:%"LLD"\n",rbuf-cbuf);
+    	printf("LeftOver..:%"LLD"\n",(int64_t)(rbuf-cbuf));
     	mixDump_c(cbuf,rbuf-cbuf);
     	rbuf=cbuf;
     }



From mean at mail.berlios.de  Tue Oct 27 07:44:23 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 27 Oct 2009 07:44:23 +0100
Subject: [Avidemux-svn-commit] r5417 -
	branches/avidemux_2.6_branch_mean/avidemux/common
Message-ID: <200910270644.n9R6iNBD025157@sheep.berlios.de>

Author: mean
Date: 2009-10-27 07:44:22 +0100 (Tue, 27 Oct 2009)
New Revision: 5417

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/main.cpp
Log:
[Main/Prefs] Cleanup prefs deletion

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/main.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/main.cpp	2009-10-27 06:44:20 UTC (rev 5416)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/main.cpp	2009-10-27 06:44:22 UTC (rev 5417)
@@ -319,7 +319,6 @@
     printf("Cleaning up Spidermonkey.\n");
     SpidermonkeyDestroy();
     pthread_mutex_unlock(&g_pSpiderMonkeyMutex);
-    destroyPrefs();
 //    filterCleanUp();
 	ADM_lavDestroy();
 
@@ -332,11 +331,7 @@
 #endif
 
 	destroyGUI();
-    if(prefs)
-    {
-        delete prefs;
-        prefs=NULL;
-    }
+    destroyPrefs();
     printf("End of cleanup\n");
     ADMImage_stat();
     ADM_memStat();



From mean at mail.berlios.de  Tue Oct 27 07:44:20 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 27 Oct 2009 07:44:20 +0100
Subject: [Avidemux-svn-commit] r5416 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor
Message-ID: <200910270644.n9R6iKkk025131@sheep.berlios.de>

Author: mean
Date: 2009-10-27 07:44:20 +0100 (Tue, 27 Oct 2009)
New Revision: 5416

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp
Log:
[Editor] Put a memleak in, else it crashes ????

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp	2009-10-27 06:44:17 UTC (rev 5415)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp	2009-10-27 06:44:20 UTC (rev 5416)
@@ -125,8 +125,10 @@
       {
             for(int i=0;i<v->nbAudioStream;i++)
             {
+#if 0 // Deleted elsewhere ?
                 if(v->audioTracks[i])
                     delete v->audioTracks[i];
+#endif
                 v->audioTracks[i]=NULL;
             }
             delete [] v->audioTracks;



From mean at mail.berlios.de  Tue Oct 27 07:44:25 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 27 Oct 2009 07:44:25 +0100
Subject: [Avidemux-svn-commit] r5418 - in
	branches/avidemux_2.6_branch_mean/avidemux/common: ADM_editor
	ADM_muxerGate/src
Message-ID: <200910270644.n9R6iPBG025189@sheep.berlios.de>

Author: mean
Date: 2009-10-27 07:44:24 +0100 (Tue, 27 Oct 2009)
New Revision: 5418

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edSearch.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoCopy.cpp
Log:
[Editor] Better handling of video copy, dts+pts

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edSearch.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edSearch.cpp	2009-10-27 06:44:22 UTC (rev 5417)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edSearch.cpp	2009-10-27 06:44:24 UTC (rev 5418)
@@ -79,6 +79,21 @@
         ADM_warning(" Cannot find seg for time %"LLD"\n",*frameTime);
         return false;
     }   
+    // Special case : The very first frame
+    if(*frameTime<=1)
+      {
+          _VIDEOS *vid=_segments.getRefVideo(0);
+          uint64_t pts,dts;
+          vid->_aviheader->getPtsDts(0,&pts,&dts);
+          if(pts!=ADM_NO_PTS)
+            {
+              if(pts>0)
+                {
+                    ADM_warning("This video does not start at 0 but at %"LLU" ms, compensating\n",pts/1000);
+                    _segments.convertLinearTimeToSeg(  *frameTime+pts, &seg, &segTime);
+                }
+            }
+      }
     // 
 again:
     _SEGMENT *s=_segments.getSegment(seg);
@@ -94,7 +109,7 @@
     {
         if(!seg)
         {
-            ADM_warning(" No next previous keyfr for frameTime %"LLU"\n",*frameTime);
+            ADM_warning(" No previous previous keyfr for frameTime %"LLU"\n",*frameTime);
             return false;
         }
         // Go to the next segment
@@ -177,4 +192,40 @@
 {
     return _segments.getTotalDuration();
 }
-//EOF
\ No newline at end of file
+/**
+    \fn getDtsFromPts
+    \brief Estimate DTS from PTS
+
+*/
+bool        ADM_Composer::getDtsFromPts(uint64_t *time)
+{
+uint64_t refTime,nkTime,segTime;
+int lastSeg=_segments.getNbSegments();
+uint32_t seg;
+    // 1- Convert frameTime to segments
+    if(false== _segments.convertLinearTimeToSeg(  *time, &seg, &segTime))
+    {
+        ADM_warning(" Cannot find seg for time %"LLD"\n",*time);
+        return false;
+    }  
+    _SEGMENT *s=_segments.getSegment(seg);
+    //
+    // Search the frame with correct PTS
+    uint64_t pts=segTime+s->_refStartTimeUs;
+    uint64_t dts;
+    if(false==_segments.ptsFromDts(s->_reference,pts,&dts))
+    {
+        ADM_warning("Cannot get DTS from PTS=%"LLU"ms\n",pts/1000);
+        return false;
+    }
+    dts=dts+s->_startTimeUs;
+    if(dts<s->_refStartTimeUs)
+    {
+        ADM_warning("Warning DTS time is negative\n");
+        dts=0;
+    }else
+        dts=dts-s->_refStartTimeUs;
+    *time=dts;
+    return true;
+}
+//EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx	2009-10-27 06:44:22 UTC (rev 5417)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx	2009-10-27 06:44:24 UTC (rev 5418)
@@ -87,6 +87,9 @@
 
                     bool        searchNextKeyFrameInRef(int ref,uint64_t refTime,uint64_t *nkTime);
                     bool        searchPreviousKeyFrameInRef(int ref,uint64_t refTime,uint64_t *nkTime);
+
+
+
 //******************************************************************************************
   private:
                     ADM_EditorSegment _segments;
@@ -188,6 +191,7 @@
 public:
                     bool                getNKFramePTS(uint64_t *frameTime);
                     bool                getPKFramePTS(uint64_t *frameTime);
+                    bool                getDtsFromPts(uint64_t *time);
 /******************************* Post Processing ************************************/
                     uint8_t             setPostProc( uint32_t type, uint32_t strength,	uint32_t swapuv);
                     uint8_t             getPostProc( uint32_t *type, uint32_t *strength,uint32_t *swapuv);

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp	2009-10-27 06:44:22 UTC (rev 5417)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp	2009-10-27 06:44:24 UTC (rev 5418)
@@ -428,4 +428,36 @@
 
     }
 }
+/**
+    \fn ptsFromDts
+    \brief guestimate DTS from PTS
+*/
+ bool        ADM_EditorSegment::ptsFromDts(uint32_t refVideo,uint64_t pts,uint64_t *dts)
+{
+    uint32_t frame,flags;
+    _VIDEOS *vid=getRefVideo(refVideo);
+    vidHeader *demuxer=vid->_aviheader;
+    if(false==TimeToFrame(vid,pts,&frame,&flags))
+    {
+            ADM_warning("Cannot get frame with pts=%"LLU" ms\n",pts/1000);
+            return false;
+    }
+    // No get DTS..
+    int32_t deltaFrame=frame;
+    uint64_t p,d;
+    while(deltaFrame>0)
+    {
+            demuxer->getPtsDts(deltaFrame,&p,&d);
+            if(d!=ADM_NO_PTS) break;
+            deltaFrame--;
+    }
+    if(deltaFrame<0)    
+    {
+        ADM_warning("Cannot find a valid DTS for pts=%"LLU"ms\n",pts/1000);
+        return false;
+    }
+    deltaFrame=frame-deltaFrame;
+    *dts=d+deltaFrame*vid->timeIncrementInUs;
+    return true;
+}
 //EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.h	2009-10-27 06:44:22 UTC (rev 5417)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.h	2009-10-27 06:44:24 UTC (rev 5418)
@@ -125,7 +125,9 @@
 
             uint32_t    intraTimeToFrame(uint32_t refVideo,uint64_t seekTime);       
             bool        isKeyFrameByTime(uint32_t refVideo,uint64_t seekTime);
+
             bool        removeChunk(uint64_t from, uint64_t to);
+            bool        ptsFromDts(uint32_t refVideo,uint64_t pts,uint64_t *dts);
 };
 
 #endif

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoCopy.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoCopy.cpp	2009-10-27 06:44:22 UTC (rev 5417)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoCopy.cpp	2009-10-27 06:44:24 UTC (rev 5418)
@@ -24,8 +24,9 @@
 ADM_videoStreamCopy::ADM_videoStreamCopy(uint64_t startTime,uint64_t endTime)
 {
     aviInfo info;
-    uint64_t realStart=startTime;
-
+    uint64_t ptsStart=startTime+1;
+    uint64_t dtsStart;
+    ADM_info("Creating copy video stream\n");
     video_body->getVideoInfo(&info);
     width=info.width;
     height=info.height;
@@ -33,15 +34,28 @@
     averageFps1000=info.fps1000;
     isCFR=false;
     // Estimate start frame
-    if(false==video_body->getPKFramePTS(&realStart))
+    if(false==video_body->getPKFramePTS(&ptsStart))
     {
         ADM_warning("Cannot find previous keyframe\n");
+        ptsStart=dtsStart=startTime;
+    }else   
+    {
+        // Now search the DTS associated with it...
+        dtsStart=ptsStart;
+        if(false==video_body->getDtsFromPts(&dtsStart))
+        {
+                ADM_warning("Cannot get DTS for PTS=%"LLU" ms, expect problems\n",ptsStart/1000);
+                dtsStart=ptsStart;
+        }else
+        {
+            ADM_info("Using %"LLU" ms as startTime\n",dtsStart/1000);
+        }
     }
     eofMet=false;
-    this->startTime=realStart;
+    this->startTime=dtsStart;
     this->endTime=endTime;
-    video_body->goToIntraTimeVideo(realStart);
-    ADM_info(" Fixating start time by %u\n",abs((int)(this->startTime-startTime)));
+    video_body->goToIntraTimeVideo(ptsStart);
+    ADM_info(" Fixating start time by %u\n",abs((int)(this->startTime-dtsStart)));
 }
 /**
     \fn ADM_videoStreamCopy
@@ -65,6 +79,7 @@
 {
     if(in==ADM_NO_PTS) return in;
     if(in>startTime) return in-startTime;
+    ADM_warning("Negative time!\n");
     return 0;
 }
 /**
@@ -95,6 +110,15 @@
     *dts=rescaleTs(image.demuxerDts);
     if(image.demuxerDts!=ADM_NO_PTS)
     {
+        if(image.demuxerPts!=ADM_NO_PTS)
+          {
+            if(image.demuxerPts<image.demuxerDts)
+              {
+                ADM_warning("PTS<DTS : PTS=%"LLU" ms , DTS=%"LLU"ms\n",image.demuxerPts/1000,image.demuxerDts/1000);
+
+              }
+
+          }
         if(image.demuxerDts>endTime ) 
         {
             eofMet=true;



From mean at mail.berlios.de  Tue Oct 27 07:44:28 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 27 Oct 2009 07:44:28 +0100
Subject: [Avidemux-svn-commit] r5419 -
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat
Message-ID: <200910270644.n9R6iSYm025218@sheep.berlios.de>

Author: mean
Date: 2009-10-27 07:44:27 +0100 (Tue, 27 Oct 2009)
New Revision: 5419

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/utils.c
Log:
[Lavformat] Display value when pts<dts

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/utils.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/utils.c	2009-10-27 06:44:24 UTC (rev 5418)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/utils.c	2009-10-27 06:44:27 UTC (rev 5419)
@@ -2601,8 +2601,10 @@
         av_log(st->codec, AV_LOG_ERROR, "error, non monotone timestamps %"PRId64" >= %"PRId64"\n", st->cur_dts, pkt->dts);
         return -1;
     }
-    if(pkt->dts != AV_NOPTS_VALUE && pkt->pts != AV_NOPTS_VALUE && pkt->pts < pkt->dts){
-        av_log(st->codec, AV_LOG_ERROR, "error, pts < dts\n");
+    if(pkt->dts != AV_NOPTS_VALUE && pkt->pts != AV_NOPTS_VALUE && pkt->pts < pkt->dts)
+    {
+        av_log(st->codec, AV_LOG_ERROR, "error, pts < dts pts=%llu dts=%llu\n",pkt->pts,pkt->dts);
+        
         return -1;
     }
 



From mean at mail.berlios.de  Tue Oct 27 07:44:31 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 27 Oct 2009 07:44:31 +0100
Subject: [Avidemux-svn-commit] r5420 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS
Message-ID: <200910270644.n9R6iV14025250@sheep.berlios.de>

Author: mean
Date: 2009-10-27 07:44:30 +0100 (Tue, 27 Oct 2009)
New Revision: 5420

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS/ADM_ts.cpp
Log:
[TsDemux] Simplify

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS/ADM_ts.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS/ADM_ts.cpp	2009-10-27 06:44:27 UTC (rev 5419)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS/ADM_ts.cpp	2009-10-27 06:44:30 UTC (rev 5420)
@@ -217,19 +217,22 @@
 
 uint8_t tsHeader::close(void)
 {
+    ADM_info("Destroying TS demuxer\n");
     // Destroy index
-    while(ListOfFrames.size())
-    {
-        delete ListOfFrames[0];
-        ListOfFrames.erase(ListOfFrames.begin());
-    }
+    int n=ListOfFrames.size();
+    for(int i=0;i<n;i++)
+        delete ListOfFrames[i];
+    ListOfFrames.clear();
+
     // Destroy audio tracks
-    for(int i=0;i<listOfAudioTracks.size();i++)
+    n=listOfAudioTracks.size();
+    for(int i=0;i<n;i++)
     {
         ADM_tsTrackDescriptor *desc=listOfAudioTracks[i];
         delete desc;
         listOfAudioTracks[i]=NULL;
     } // Container will be destroyed by vector destructor
+    listOfAudioTracks.clear();
     if(tsPacket)
     {
         tsPacket->close();



From gruntster at mail.berlios.de  Tue Oct 27 21:38:39 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Tue, 27 Oct 2009 21:38:39 +0100
Subject: [Avidemux-svn-commit] r5421 - in
	branches/avidemux_2.5_branch_gruntster/cmake: . patches
Message-ID: <200910272038.n9RKcdIe005368@sheep.berlios.de>

Author: gruntster
Date: 2009-10-27 21:38:29 +0100 (Tue, 27 Oct 2009)
New Revision: 5421

Modified:
   branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_avcodec.h.patch
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_h264.c.patch
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_mpeg12enc.c.patch
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_utils.c.patch
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_flvenc.c.patch
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_matroskaenc.c.patch
Log:
[ffmpeg] update FFmpeg to r20383 & libswscale r29799

Modified: branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake	2009-10-27 06:44:30 UTC (rev 5420)
+++ branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake	2009-10-27 20:38:29 UTC (rev 5421)
@@ -1,7 +1,7 @@
 include(admFFmpegUtil)
 
-set(FFMPEG_VERSION 19894)	# http://git.ffmpeg.org/?p=ffmpeg;a=snapshot;h=2e3afeca36da83a20f58962b150580d00a48b6c6;sf=tgz
-set(SWSCALE_VERSION 29686)	# http://git.ffmpeg.org/?p=libswscale;a=snapshot;h=ef1afb1cee3222c7d41f56363c1f536a8ae4f442;sf=tgz
+set(FFMPEG_VERSION 20383)	# http://git.ffmpeg.org/?p=ffmpeg;a=snapshot;h=b977b67fd675b4253f7a71b38c5a8542fc7ad16f;sf=tgz
+set(SWSCALE_VERSION 29799)	# http://git.ffmpeg.org/?p=libswscale;a=snapshot;h=0e9c9e056c98d7474e3ea40519f3bd8c623b5a3f;sf=tgz
 
 set(LIBRARY_SOURCE_DIR "${CMAKE_SOURCE_DIR}/avidemux/ADM_libraries")
 set(FFMPEG_SOURCE_DIR "${LIBRARY_SOURCE_DIR}/ffmpeg")

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_avcodec.h.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_avcodec.h.patch	2009-10-27 06:44:30 UTC (rev 5420)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_avcodec.h.patch	2009-10-27 20:38:29 UTC (rev 5421)
@@ -1,8 +1,8 @@
-*** libavcodec/avcodec.h.old	Thu Sep 17 16:13:53 2009
---- libavcodec/avcodec.h	Thu Sep 17 16:13:53 2009
+*** libavcodec/avcodec.h.old	Sun Oct 18 17:15:04 2009
+--- libavcodec/avcodec.h	Sun Oct 18 17:15:04 2009
 ***************
-*** 572,577 ****
---- 572,579 ----
+*** 573,578 ****
+--- 573,580 ----
   #define CODEC_FLAG2_CHUNKS        0x00008000 ///< Input bitstream might be truncated at a packet boundaries instead of only at frame boundaries.
   #define CODEC_FLAG2_NON_LINEAR_QUANT 0x00010000 ///< Use MPEG-2 nonlinear quantizer.
   #define CODEC_FLAG2_BIT_RESERVOIR 0x00020000 ///< Use a bit reservoir when encoding if possible
@@ -12,8 +12,8 @@
   /* Unsupported options :
    *              Syntax Arithmetic coding (SAC)
 ***************
-*** 1430,1435 ****
---- 1432,1438 ----
+*** 1431,1436 ****
+--- 1433,1439 ----
        * - decoding: unused
        */
       int rc_max_rate;
@@ -22,8 +22,8 @@
       /**
        * minimum bitrate
 ***************
-*** 1444,1449 ****
---- 1447,1454 ----
+*** 1445,1450 ****
+--- 1448,1455 ----
        * - decoding: unused
        */
       int rc_buffer_size;

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_h264.c.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_h264.c.patch	2009-10-27 06:44:30 UTC (rev 5420)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_h264.c.patch	2009-10-27 20:38:29 UTC (rev 5421)
@@ -1,8 +1,8 @@
-*** libavcodec/h264.c.old	Sun Aug  2 10:23:00 2009
---- libavcodec/h264.c	Sun Aug  2 10:23:00 2009
+*** libavcodec/h264.c.old	Sun Oct 18 17:15:06 2009
+--- libavcodec/h264.c	Sun Oct 18 17:15:06 2009
 ***************
-*** 8155,8160 ****
---- 8155,8171 ----
+*** 8159,8164 ****
+--- 8159,8175 ----
       return 0;
   }
   

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_mpeg12enc.c.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_mpeg12enc.c.patch	2009-10-27 06:44:30 UTC (rev 5420)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_mpeg12enc.c.patch	2009-10-27 20:38:29 UTC (rev 5421)
@@ -1,5 +1,5 @@
-*** libavcodec/mpeg12enc.c.old	Thu Aug 27 21:16:08 2009
---- libavcodec/mpeg12enc.c	Thu Aug 27 21:16:09 2009
+*** libavcodec/mpeg12enc.c.old	Sun Oct 18 17:15:07 2009
+--- libavcodec/mpeg12enc.c	Sun Oct 18 17:15:07 2009
 ***************
 *** 127,136 ****
 --- 127,145 ----
@@ -128,8 +128,8 @@
                   put_bits(&s->pb, 2, s->width >>12);
                   put_bits(&s->pb, 2, s->height>>12);
 ***************
-*** 334,339 ****
---- 377,384 ----
+*** 339,344 ****
+--- 382,389 ----
   
   void mpeg1_encode_picture_header(MpegEncContext *s, int picture_number)
   {
@@ -139,8 +139,8 @@
   
       /* mpeg1 picture header */
 ***************
-*** 370,375 ****
---- 415,463 ----
+*** 375,380 ****
+--- 420,468 ----
   
       s->frame_pred_frame_dct = 1;
       if(s->codec_id == CODEC_ID_MPEG2VIDEO){
@@ -191,8 +191,8 @@
           put_bits(&s->pb, 4, 8); //pic ext
           if (s->pict_type == FF_P_TYPE || s->pict_type == FF_B_TYPE) {
 ***************
-*** 388,398 ****
---- 476,491 ----
+*** 393,403 ****
+--- 481,496 ----
   
           assert(s->picture_structure == PICT_FRAME);
           put_bits(&s->pb, 2, s->picture_structure);
@@ -210,7 +210,7 @@
              measures */
           s->frame_pred_frame_dct = s->progressive_sequence;
 ***************
-*** 402,408 ****
+*** 407,413 ****
           put_bits(&s->pb, 1, s->q_scale_type);
           put_bits(&s->pb, 1, s->intra_vlc_format);
           put_bits(&s->pb, 1, s->alternate_scan);
@@ -218,7 +218,7 @@
           s->progressive_frame = s->progressive_sequence;
           put_bits(&s->pb, 1, s->chroma_format == CHROMA_420 ? s->progressive_frame : 0); /* chroma_420_type */
           put_bits(&s->pb, 1, s->progressive_frame);
---- 495,504 ----
+--- 500,509 ----
           put_bits(&s->pb, 1, s->q_scale_type);
           put_bits(&s->pb, 1, s->intra_vlc_format);
           put_bits(&s->pb, 1, s->alternate_scan);

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_utils.c.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_utils.c.patch	2009-10-27 06:44:30 UTC (rev 5420)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_utils.c.patch	2009-10-27 20:38:29 UTC (rev 5421)
@@ -1,8 +1,8 @@
-*** libavcodec/utils.c.old	Thu Sep 17 16:14:07 2009
---- libavcodec/utils.c	Thu Sep 17 16:14:07 2009
+*** libavcodec/utils.c.old	Sun Oct 18 17:15:08 2009
+--- libavcodec/utils.c	Sun Oct 18 17:15:08 2009
 ***************
-*** 611,620 ****
---- 611,622 ----
+*** 631,640 ****
+--- 631,642 ----
   
       if((avctx->codec->capabilities & CODEC_CAP_DELAY) || avpkt->size){
           //FIXME remove the check below _after_ ensuring that all audio check that the available space is enough
@@ -16,7 +16,7 @@
           *frame_size_ptr < avctx->channels * avctx->frame_size * sizeof(int16_t)){
               av_log(avctx, AV_LOG_ERROR, "buffer %d too small\n", *frame_size_ptr);
 ***************
-*** 1049,1055 ****
+*** 1071,1077 ****
           return -1;
       }
   #if !HAVE_MKSTEMP
@@ -24,7 +24,7 @@
   #else
       snprintf(*filename, len, "/tmp/%sXXXXXX", prefix);
       fd = mkstemp(*filename);
---- 1051,1057 ----
+--- 1073,1079 ----
           return -1;
       }
   #if !HAVE_MKSTEMP

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_flvenc.c.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_flvenc.c.patch	2009-10-27 06:44:30 UTC (rev 5420)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_flvenc.c.patch	2009-10-27 20:38:29 UTC (rev 5421)
@@ -1,7 +1,7 @@
-*** libavformat/flvenc.c.old	Thu Sep 17 16:14:10 2009
---- libavformat/flvenc.c	Thu Sep 17 16:14:10 2009
+*** libavformat/flvenc.c.old	Sun Oct 18 17:15:09 2009
+--- libavformat/flvenc.c	Sun Oct 18 17:15:09 2009
 ***************
-*** 389,395 ****
+*** 405,411 ****
       "video/x-flv",
       "flv",
       sizeof(FLVContext),
@@ -9,7 +9,7 @@
       CODEC_ID_MP3,
   #else // CONFIG_LIBMP3LAME
       CODEC_ID_ADPCM_SWF,
---- 389,396 ----
+--- 405,412 ----
       "video/x-flv",
       "flv",
       sizeof(FLVContext),
@@ -19,8 +19,8 @@
   #else // CONFIG_LIBMP3LAME
       CODEC_ID_ADPCM_SWF,
 ***************
-*** 401,403 ****
---- 402,410 ----
+*** 417,419 ****
+--- 418,426 ----
       .codec_tag= (const AVCodecTag* const []){flv_video_codec_ids, flv_audio_codec_ids, 0},
       .flags= AVFMT_GLOBALHEADER | AVFMT_VARIABLE_FPS,
   };

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_matroskaenc.c.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_matroskaenc.c.patch	2009-10-27 06:44:30 UTC (rev 5420)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_matroskaenc.c.patch	2009-10-27 20:38:29 UTC (rev 5421)
@@ -1,5 +1,5 @@
-*** libavformat/matroskaenc.c.old	Sat Jun 27 18:45:28 2009
---- libavformat/matroskaenc.c	Sat Jun 27 18:45:28 2009
+*** libavformat/matroskaenc.c.old	Sun Oct 18 17:15:09 2009
+--- libavformat/matroskaenc.c	Sun Oct 18 17:15:10 2009
 ***************
 *** 395,400 ****
 --- 395,401 ----
@@ -68,8 +68,8 @@
           if ((tag = av_metadata_get(st->metadata, "description", NULL, 0)))
               put_ebml_string(pb, MATROSKA_ID_TRACKNAME, tag->value);
 ***************
-*** 907,909 ****
---- 947,959 ----
+*** 954,956 ****
+--- 994,1006 ----
       .flags = AVFMT_GLOBALHEADER,
       .codec_tag = (const AVCodecTag* const []){ff_codec_wav_tags, 0},
   };



From gruntster at mail.berlios.de  Tue Oct 27 21:41:46 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Tue, 27 Oct 2009 21:41:46 +0100
Subject: [Avidemux-svn-commit] r5422 -
	branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264
Message-ID: <200910272041.n9RKfk3W005659@sheep.berlios.de>

Author: gruntster
Date: 2009-10-27 21:41:38 +0100 (Tue, 27 Oct 2009)
New Revision: 5422

Modified:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/encoder.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/x264Options.cpp
Log:
[x264] support API version 78

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/encoder.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/encoder.cpp	2009-10-27 20:38:29 UTC (rev 5421)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/encoder.cpp	2009-10-27 20:41:38 UTC (rev 5422)
@@ -625,7 +625,11 @@
 	printf("[x264] i_bframe = %d\n", x264Param->i_bframe);
 	printf("[x264] i_bframe_bias = %d\n", x264Param->i_bframe_bias);
 	printf("[x264] i_frame_reference = %d\n", x264Param->i_frame_reference);
+#if X264_BUILD >= 78
+	printf("[x264] i_bframe_pyramid = %d\n", x264Param->i_bframe_pyramid);
+#else
 	printf("[x264] b_bframe_pyramid = %d\n", x264Param->b_bframe_pyramid);
+#endif
 #if X264_BUILD >= 63
 	printf("[x264] i_bframe_adaptive = %d\n", x264Param->i_bframe_adaptive);
 #else

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/x264Options.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/x264Options.cpp	2009-10-27 20:38:29 UTC (rev 5421)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/x264Options.cpp	2009-10-27 20:41:38 UTC (rev 5422)
@@ -330,12 +330,20 @@
 
 bool x264Options::getBFrameReferences(void)
 {
+#if X264_BUILD >= 78
+	return _param.i_bframe_pyramid;
+#else
 	return _param.b_bframe_pyramid;
+#endif
 }
 
 void x264Options::setBFrameReferences(bool bFrameReferences)
 {
+#if X264_BUILD >= 78
+	_param.i_bframe_pyramid = bFrameReferences;
+#else
 	_param.b_bframe_pyramid = bFrameReferences;
+#endif
 }
 
 bool x264Options::getLoopFilter(void)



From mean at mail.berlios.de  Wed Oct 28 20:10:08 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 28 Oct 2009 20:10:08 +0100
Subject: [Avidemux-svn-commit] r5423 -
	branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_gui2
Message-ID: <200910281910.n9SJA8Ob015436@sheep.berlios.de>

Author: mean
Date: 2009-10-28 20:10:08 +0100 (Wed, 28 Oct 2009)
New Revision: 5423

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_gui2/GUI_glade.h
Log:
[Gtk] Cleanup includes

Modified: branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_gui2/GUI_glade.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_gui2/GUI_glade.h	2009-10-27 20:41:38 UTC (rev 5422)
+++ branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_userInterfaces/ADM_gui2/GUI_glade.h	2009-10-28 19:10:08 UTC (rev 5423)
@@ -5,7 +5,7 @@
 
 #ifndef ADM_GLADE_H
 #define ADM_GLADE_H
-#include <glade/glade.h>
+#include <gtk/gtk.h>
 /**
     \class admGlade
     \brief simple glade wrapping class



From mean at mail.berlios.de  Wed Oct 28 20:10:10 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 28 Oct 2009 20:10:10 +0100
Subject: [Avidemux-svn-commit] r5424 - in
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate:
	include src
Message-ID: <200910281910.n9SJAAYi015448@sheep.berlios.de>

Author: mean
Date: 2009-10-28 20:10:10 +0100 (Wed, 28 Oct 2009)
New Revision: 5424

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/include/ADM_videoCopy.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoCopy.cpp
Log:
[Editor/Save] Better handing of PTS/DTS in copy mode

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/include/ADM_videoCopy.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/include/ADM_videoCopy.h	2009-10-28 19:10:08 UTC (rev 5423)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/include/ADM_videoCopy.h	2009-10-28 19:10:10 UTC (rev 5424)
@@ -13,7 +13,8 @@
 class ADM_videoStreamCopy: public ADM_videoStream
 {
 protected:
-            uint64_t startTime,endTime;
+            uint64_t startTimePts,startTimeDts;
+            uint64_t endTimePts;
             uint32_t currentFrame;
             ADMCompressedImage image;
             bool eofMet;

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoCopy.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoCopy.cpp	2009-10-28 19:10:08 UTC (rev 5423)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoCopy.cpp	2009-10-28 19:10:10 UTC (rev 5424)
@@ -52,10 +52,13 @@
         }
     }
     eofMet=false;
-    this->startTime=dtsStart;
-    this->endTime=endTime;
+
+    this->startTimeDts=dtsStart;
+    this->startTimePts=ptsStart;
+    this->endTimePts=endTime;
+
     video_body->goToIntraTimeVideo(ptsStart);
-    ADM_info(" Fixating start time by %u\n",abs((int)(this->startTime-dtsStart)));
+    ADM_info(" Fixating start time by %d\n",abs((int)(startTime-startTimeDts)));
 }
 /**
     \fn ADM_videoStreamCopy
@@ -78,7 +81,7 @@
 uint64_t  ADM_videoStreamCopy::rescaleTs(uint64_t in)
 {
     if(in==ADM_NO_PTS) return in;
-    if(in>startTime) return in-startTime;
+    if(in>startTimeDts) return in-startTimeDts;
     ADM_warning("Negative time!\n");
     return 0;
 }
@@ -87,7 +90,7 @@
 */
 uint64_t  ADM_videoStreamCopy::getStartTime(void)
 {
-    return this->startTime;
+    return this->startTimeDts;
 }
 /**
     \fn getPacket
@@ -97,6 +100,7 @@
                     uint32_t *flags)
 {
     if(true==eofMet) return false;
+again:
     image.data=data;
     if(false==video_body->getCompressedPicture(&image))
     {
@@ -105,12 +109,20 @@
     }
     *len=image.dataLength;
     ADM_assert(*len<maxLen);
-    
+    if(image.demuxerPts!=ADM_NO_PTS)
+        if(image.demuxerPts<startTimePts)   
+        {
+            if(image.flags & AVI_B_FRAME) 
+            {
+                ADM_warning("Dropping orphean B frame (PTS=%"LLU" ms)\n",image.demuxerPts/1000);
+                goto again;
+            }
+        }
     *pts=rescaleTs(image.demuxerPts);
     *dts=rescaleTs(image.demuxerDts);
-    if(image.demuxerDts!=ADM_NO_PTS)
+    if(image.demuxerPts!=ADM_NO_PTS)
     {
-        if(image.demuxerPts!=ADM_NO_PTS)
+          if(image.demuxerDts!=ADM_NO_PTS)
           {
             if(image.demuxerPts<image.demuxerDts)
               {
@@ -119,7 +131,7 @@
               }
 
           }
-        if(image.demuxerDts>endTime ) 
+        if(image.demuxerPts>endTimePts ) 
         {
             eofMet=true;
             return false;



From mean at mail.berlios.de  Wed Oct 28 20:10:12 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 28 Oct 2009 20:10:12 +0100
Subject: [Avidemux-svn-commit] r5425 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor
Message-ID: <200910281910.n9SJACtX015462@sheep.berlios.de>

Author: mean
Date: 2009-10-28 20:10:11 +0100 (Wed, 28 Oct 2009)
New Revision: 5425

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp
Log:
[Editor] More debug infos about editor

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp	2009-10-28 19:10:10 UTC (rev 5424)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp	2009-10-28 19:10:11 UTC (rev 5425)
@@ -30,7 +30,7 @@
     \fn recalibrate
     \brief Convert time given in time from absolute ref video to linear time
 */
-static void recalibrate(uint64_t *time,_SEGMENT *seg)
+void ADM_Composer::recalibrate(uint64_t *time,_SEGMENT *seg)
 {
 int64_t t=(int64_t)*time;
         if(*time==ADM_NO_PTS) return;
@@ -38,8 +38,9 @@
         t-=seg->_refStartTimeUs;
         if(t<0)
         {
-            ADM_warning("Segment time is negative!\n");
+            ADM_warning("Segment time is negative time : %"LLU" ms, refStartTime:%"LLU" ms!\n",*time/1000,seg->_refStartTimeUs/1000);
             t=0;
+            _segments.dump();
         }
         t+=seg->_startTimeUs;
         *time=(uint64_t )t;
@@ -47,7 +48,7 @@
 /**
     \fn updateImageTiming
 */
-bool updateImageTiming(_SEGMENT *seg,ADMImage *image)
+bool ADM_Composer::updateImageTiming(_SEGMENT *seg,ADMImage *image)
 {
     recalibrate(&(image->Pts),seg);
 //    recalibrate(&(image->Dts),seg);



From mean at mail.berlios.de  Wed Oct 28 20:10:13 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 28 Oct 2009 20:10:13 +0100
Subject: [Avidemux-svn-commit] r5426 - in branches/avidemux_2.6_branch_mean:
	avidemux/common/ADM_editor avidemux/common/ADM_script
	avidemux_core/ADM_coreMuxer/src
Message-ID: <200910281910.n9SJAD3Y015473@sheep.berlios.de>

Author: mean
Date: 2009-10-28 20:10:13 +0100 (Wed, 28 Oct 2009)
New Revision: 5426

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edLoadSave.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script/ADM_JSAvidemux.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_dynaMuxer.cpp
Log:
[Editor] Improved JS support (setContainer; marker,...)

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edLoadSave.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edLoadSave.cpp	2009-10-28 19:10:11 UTC (rev 5425)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edLoadSave.cpp	2009-10-28 19:10:13 UTC (rev 5426)
@@ -68,10 +68,10 @@
   qfprintf (fd,"// %02ld videos source \n", _segments.getNbRefVideos());
   char *nm;
   uint32_t vop=!!(video_body->getSpecificMpeg4Info()&ADM_VOP_ON);
-#if 0
-  for (uint32_t i = 0; i < _videos.size(); i++)
+
+  for (uint32_t i = 0; i < _segments.getNbRefVideos(); i++)
     {
-        nm=ADM_cleanupPath(_videos[i]._aviheader->getMyName() );
+        nm=ADM_cleanupPath(_segments.getRefVideo(i)->_aviheader->getMyName() );
         if(vop)
         {
           qfprintf(fd,"app.forceUnpack();\n");
@@ -86,30 +86,22 @@
         }
         ADM_dealloc(nm);
     }
-#endif  
+
   qfprintf (fd,"//%02ld segments\n", _segments.getNbSegments());
   qfprintf (fd,"app.clearSegments();\n");
   
  
-#if 0
-for (uint32_t i = 0; i < _nb_segment; i++)
+
+    for (uint32_t i = 0; i < _segments.getNbSegments(); i++)
     {
-        uint32_t src,start,nb;
-                src=_segments[i]._reference;
-                start=_segments[i]._start_frame;
-                nb=_segments[i]._nb_frames;
-                qfprintf (fd, "app.addSegment(%lu,%lu,%lu);\n",src,start,nb);
+        _SEGMENT *seg=_segments.getSegment(i);
+        qfprintf (fd, "app.addSegment(%"LU",%"LLU",%"LLU");\n",seg->_reference,seg->_refStartTimeUs,seg->_durationUs);
     }
-#endif
+
 // Markers
 //
-        qfprintf(fd,"app.markerA=%d;\n",frameStart);
-        qfprintf(fd,"app.markerB=%d;\n",frameEnd);
-// Reordering : Warning works only for video with one source video
-//        if(video_body->isReordered(0) && !vop)
-        {
- //           qfprintf(fd,"app.rebuildIndex();\n");
-        }
+        qfprintf(fd,"app.markerA=%"LLU";\n",getMarkerAPts());
+        qfprintf(fd,"app.markerB=%"LLU";\n",getMarkerBPts());
         
 // postproc
 //___________________________
@@ -120,12 +112,14 @@
                 qfprintf(fd,"app.video.setPostProc(%d,%d,%d);\n",pptype,ppstrength,ppswap);
 
 // fps
-	if( avifileinfo ){
+#if 0
+	if( avifileinfo )
+    {
 	  aviInfo info;
 		video_body->getVideoInfo(&info);
 		qfprintf(fd,"\napp.video.setFps1000(%u);\n",info.fps1000);
 	}
-
+#endif
 // Filter
 //___________________________
         qfprintf(fd,"\n//** Filters **\n");

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script/ADM_JSAvidemux.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script/ADM_JSAvidemux.cpp	2009-10-28 19:10:11 UTC (rev 5425)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script/ADM_JSAvidemux.cpp	2009-10-28 19:10:13 UTC (rev 5426)
@@ -17,8 +17,8 @@
 #include "avi_vars.h"
 #include "DIA_coreToolkit.h"
 #include "ADM_commonUI/GUI_ui.h"
-#include "ADM_script/ADM_container.h"
 
+
 #include "ADM_debugID.h"
 #define MODULE_NAME MODULE_SCRIPT
 #include "ADM_debug.h"
@@ -35,8 +35,9 @@
 extern uint8_t A_jumpToTime(uint32_t hh,uint32_t mm,uint32_t ss,uint32_t ms);
 extern uint8_t addFile(char *name);
 
-uint8_t A_setContainer(const char *cont);
-const char *getCurrentContainerAsString(void);
+bool           A_setContainer(const char *cont);
+const char     *getCurrentContainerAsString(void);
+extern int     ADM_MuxerIndexFromName(const char *name);
 
 JSPropertySpec ADM_JSAvidemux::avidemux_properties[] = 
 { 
@@ -138,10 +139,10 @@
                 {
 
                         case markerA_prop:
-                                *vp = INT_TO_JSVAL(frameStart);
+                                *vp = INT_TO_JSVAL(video_body->getMarkerAPts());
                                 break;
                         case markerB_prop:
-                                *vp = INT_TO_JSVAL(frameEnd);
+                                *vp = INT_TO_JSVAL(video_body->getMarkerBPts());
                                 break;
                         case audio_prop:
                                 *vp = OBJECT_TO_JSVAL(priv->getObject()->m_pAudio);
@@ -196,11 +197,7 @@
 					{
 						return JS_FALSE;
 					} 
-					if(f==-1)
-						f=avifileinfo->nb_frames-1;
-					if(f<0 || f>avifileinfo->nb_frames-1)
-						return JS_FALSE;
-					frameStart=f;
+                    video_body->setMarkerAPts(f);
 				}
 				break;
 			case markerB_prop:
@@ -212,11 +209,7 @@
 					{
 						return JS_FALSE;
 					} 
-					if(f==-1)
-						f=avifileinfo->nb_frames-1;
-					if(f<0 || f>avifileinfo->nb_frames-1)
-						return JS_FALSE;
-					frameEnd=f;
+                    video_body->setMarkerBPts(f);
 				}
 				break;
 			case audio_prop:
@@ -541,19 +534,20 @@
         leaveLock();
         return JS_TRUE;
 }
-uint8_t A_setContainer(const char *cont)
+/**
+    \fn ADM_JSAvidemux
+    \brief Select the current container from a string
+*/
+bool A_setContainer(const char *cont)
 {
-       for(int i=0;i<NB_CONT;i++)
-       {
-                printf("%s\n",container[i].name);
-                if(!strcasecmp(cont,container[i].name))
-                {
-                        UI_SetCurrentFormat(container[i].type);
-                        return 1;
-                }
-       }
-       printf("Cannot set output format \"%s\"\n",cont);
-       return 0;
+    int idx=ADM_MuxerIndexFromName(cont);
+    if(idx==-1)
+    {
+        ADM_error("Cannot find muxer for format=%s\n",cont);
+        return false;
+    }
+    UI_SetCurrentFormat(idx);
+    return true;
 }
 /**
     \fn getCurrentContainerAsString

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_dynaMuxer.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_dynaMuxer.cpp	2009-10-28 19:10:11 UTC (rev 5425)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_dynaMuxer.cpp	2009-10-28 19:10:13 UTC (rev 5426)
@@ -131,7 +131,22 @@
                         ListOfMuxers[i]=NULL;
                 }
 }
+
 /**
+    \fn ADM_muxerIndexFromName
+    \brief return muxer index from name, -1 if error
+*/
+int ADM_MuxerIndexFromName(const char *name)
+{
+    int n=ListOfMuxers.size();
+    for(int i=0;i<n;i++)
+    {
+        ADM_dynMuxer *mux=ListOfMuxers[i];
+        if(!strcasecmp(mux->name,name)) return i;
+    }
+    return -1;
+}
+/**
     \fn ADM_MuxerSpawn
     \brief Locate the correct demuxer and instantiate it
 
@@ -141,13 +156,7 @@
 int found=-1;
 uint32_t score=0;
 uint32_t mark;
-    for(int i=0;i<ListOfMuxers.size();i++)
-    {
-       
-            score=1;
-            found=i;
-        
-    }
+    found=ADM_MuxerIndexFromName(name);
     if(score && found!=-1)
     {
         return ListOfMuxers[found]->createmuxer();



From mean at mail.berlios.de  Wed Oct 28 20:10:17 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 28 Oct 2009 20:10:17 +0100
Subject: [Avidemux-svn-commit] r5428 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor
Message-ID: <200910281910.n9SJAH1f015499@sheep.berlios.de>

Author: mean
Date: 2009-10-28 20:10:16 +0100 (Wed, 28 Oct 2009)
New Revision: 5428

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx
Log:
[Editor] Merge some functions into editor so that they can dump internals

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx	2009-10-28 19:10:15 UTC (rev 5427)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx	2009-10-28 19:10:16 UTC (rev 5428)
@@ -72,6 +72,9 @@
                     bool        nextPictureInternal(uint32_t ref,ADMImage *image);
                     bool        samePictureInternal(uint32_t ref,ADMImage *image);
                     bool        seektoTime(uint32_t ref,uint64_t timeToSeek);
+                    // Some useful functions...
+                    void        recalibrate(uint64_t *time,_SEGMENT *seg);
+                    bool        updateImageTiming(_SEGMENT *seg,ADMImage *image);
 
 protected:
                                 /// Decode frame and on until frame is popped out of decoders



From mean at mail.berlios.de  Wed Oct 28 20:10:15 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 28 Oct 2009 20:10:15 +0100
Subject: [Avidemux-svn-commit] r5427 -
	branches/avidemux_2.6_branch_mean/avidemux/common
Message-ID: <200910281910.n9SJAFZn015485@sheep.berlios.de>

Author: mean
Date: 2009-10-28 20:10:15 +0100 (Wed, 28 Oct 2009)
New Revision: 5427

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/gui_action.names
   branches/avidemux_2.6_branch_mean/avidemux/common/gui_save.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/gui_savenew.cpp
Log:
[All] Reconnect save project to UI/main event handling

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/gui_action.names
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/gui_action.names	2009-10-28 19:10:13 UTC (rev 5426)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/gui_action.names	2009-10-28 19:10:15 UTC (rev 5427)
@@ -18,6 +18,9 @@
 ACT(SaveAvi)
 ACT(SaveWave)
 ACT(SaveRaw)
+ACT(SaveWork)
+ACT(SaveCurrentWork)
+
 ACT(SAVE_END)
 // /SAVE
 
@@ -94,8 +97,6 @@
 
 ACT(VideoConfigure)
 
-ACT(SaveWork)
-ACT(SaveCurrentWork)
 ACT(ResetSegments)
 
 ACT(SetLogFile)

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/gui_save.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/gui_save.cpp	2009-10-28 19:10:13 UTC (rev 5426)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/gui_save.cpp	2009-10-28 19:10:15 UTC (rev 5427)
@@ -56,7 +56,7 @@
     {
 
     case ACT_SaveWork:
-      GUI_FileSelWrite (QT_TR_NOOP("Select Workbench to Save"), A_saveWorkbench);
+      GUI_FileSelWrite (QT_TR_NOOP("Select Project to Save"), A_saveWorkbench);
 	  UI_refreshCustomMenu();
       break;
    case ACT_SaveCurrentWork:

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/gui_savenew.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/gui_savenew.cpp	2009-10-28 19:10:13 UTC (rev 5426)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/gui_savenew.cpp	2009-10-28 19:10:15 UTC (rev 5427)
@@ -39,12 +39,14 @@
 #include "ADM_muxerGate/include/ADM_videoProcess.h"
 #include "ADM_bitstream.h"
 #include "ADM_filterChain.h"
-
+/*
+    
+*/
 ADM_muxer               *ADM_MuxerSpawnFromIndex(int index);
 extern ADM_audioStream  *audioCreateEncodingStream(uint64_t startTime,int32_t shift);
-extern ADM_audioStream *audioCreateCopyStream(uint64_t startTime,int32_t shift,ADM_audioStream *input);
+extern ADM_audioStream  *audioCreateCopyStream(uint64_t startTime,int32_t shift,ADM_audioStream *input);
 extern ADM_videoStream  *createVideoStream(ADM_coreVideoEncoder *encoder);
-
+extern int              ADM_MuxerIndexFromName(const char *name);
 /**
     \class admSaver
     \brief Wrapper for saving



From mean at mail.berlios.de  Thu Oct 29 19:57:53 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 29 Oct 2009 19:57:53 +0100
Subject: [Avidemux-svn-commit] r5429 -
	branches/avidemux_2.6_branch_mean/avidemux/common
Message-ID: <200910291857.n9TIvrKR031872@sheep.berlios.de>

Author: mean
Date: 2009-10-29 19:57:52 +0100 (Thu, 29 Oct 2009)
New Revision: 5429

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp
Log:
[UI] After cut update UI + duration is taken from video

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp	2009-10-28 19:10:16 UTC (rev 5428)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp	2009-10-29 18:57:52 UTC (rev 5429)
@@ -436,6 +436,11 @@
             {
                 GUI_Error_HIG("Cutting","Error while cutting out.");
             }
+            else    
+            {
+              A_ResetMarkers();              
+              A_Resync();
+            }
         }
         
       break;
@@ -1426,7 +1431,7 @@
 */
 void A_ResetMarkers(void)
 {
-uint64_t duration=video_body->getDurationInUs();
+uint64_t duration=video_body->getVideoDuration();
         video_body->setMarkerAPts(0);
         video_body->setMarkerBPts(duration);
 }



From mean at mail.berlios.de  Thu Oct 29 19:57:55 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 29 Oct 2009 19:57:55 +0100
Subject: [Avidemux-svn-commit] r5430 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor
Message-ID: <200910291857.n9TIvtfc031884@sheep.berlios.de>

Author: mean
Date: 2009-10-29 19:57:54 +0100 (Thu, 29 Oct 2009)
New Revision: 5430

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.h
Log:
[Editor] Remove unused segment parts

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp	2009-10-29 18:57:52 UTC (rev 5429)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp	2009-10-29 18:57:54 UTC (rev 5430)
@@ -159,7 +159,6 @@
         seg._durationUs=vid->_aviheader->getVideoDuration();
         seg._reference=i;
         vid->_aviheader->getVideoInfo(&info);
-        seg._nbFrame=info.nb_frames;
         segments.push_back(seg);
     }
     updateStartTime();
@@ -233,13 +232,7 @@
 */
 uint32_t ADM_EditorSegment::getNbFrames(void)
 {
-    uint32_t dur;
-    uint32_t nb=0;
-    int n=segments.size();
-    for(int i=0;i<n;i++)
-        dur+=segments[i]._nbFrame;
-    return nb;
-
+    return 1;
 }
 /***********************************************************************/
 /***********************************************************************/

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.h	2009-10-29 18:57:52 UTC (rev 5429)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.h	2009-10-29 18:57:54 UTC (rev 5430)
@@ -80,8 +80,7 @@
         uint64_t _refStartTimeUs; /// Starting time in reference
         uint64_t _startTimeUs; /// Start time in current (=sum(_duration of previous seg))
         uint64_t _durationUs; ///
-        uint32_t _nbFrame;
-        uint32_t _curFrame; ///
+        
 } _SEGMENT;
 /*
     Use vectors to store our videos & segments



From mean at mail.berlios.de  Thu Oct 29 19:57:57 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 29 Oct 2009 19:57:57 +0100
Subject: [Avidemux-svn-commit] r5431 - in
	branches/avidemux_2.6_branch_mean/avidemux/common: ADM_editor
	ADM_muxerGate/src
Message-ID: <200910291857.n9TIvvkT031894@sheep.berlios.de>

Author: mean
Date: 2009-10-29 19:57:56 +0100 (Thu, 29 Oct 2009)
New Revision: 5431

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoCopy.cpp
Log:
[Editor] Try to make copy (DTS) and process (PTS) work both (incomplete)

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp	2009-10-29 18:57:54 UTC (rev 5430)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp	2009-10-29 18:57:56 UTC (rev 5431)
@@ -39,10 +39,13 @@
         if(t<0)
         {
             ADM_warning("Segment time is negative time : %"LLU" ms, refStartTime:%"LLU" ms!\n",*time/1000,seg->_refStartTimeUs/1000);
+        }
+        t+=seg->_startTimeUs;
+        if(t<0)
+        {
+            ADM_error("Absolute time is negative time : %"LLD" ms, _startTime:%"LLU" ms!\n",t/1000,seg->_startTimeUs/1000);
             t=0;
-            _segments.dump();
         }
-        t+=seg->_startTimeUs;
         *time=(uint64_t )t;
 }
 /**
@@ -55,11 +58,11 @@
     return true;
 }
 /**
-    \fn GoToIntraTime
-    \brief Go to an intra at time time (exact)
+    \fn GoToIntraTime_noDecoding
+    \brief Go to an intra at time time (exact) but do not decode frames
     \return true on success, false on error
 */
-bool        ADM_Composer::goToIntraTimeVideo(uint64_t time)
+bool        ADM_Composer::GoToIntraTime_noDecoding(uint64_t time,uint32_t *toframe)
 {
     uint32_t s;
     uint64_t segTime;
@@ -83,6 +86,24 @@
         ADM_warning("Cannot go to segment %"LU"\n",s);
         return false;
     }
+    if(toframe) *toframe=frame;
+    ref->lastSentFrame=frame; // For copy
+    return true;
+}
+/**
+    \fn GoToIntraTime
+    \brief Go to an intra at time time (exact)
+    \return true on success, false on error
+*/
+bool        ADM_Composer::goToIntraTimeVideo(uint64_t time)
+{
+    uint32_t frame;
+    if(false==GoToIntraTime_noDecoding(time,&frame))
+    {
+        ADM_warning("Seek failed.\n");
+        return false;
+    }
+    _SEGMENT *seg=_segments.getSegment(_currentSegment);
     if(false== DecodePictureUpToIntra(seg->_reference,frame))
     {
         return false;
@@ -201,12 +222,12 @@
     ADM_assert(demuxer);
 
     // Get next pic?
-    if(false==demuxer->getFrame (seg->_curFrame,img))
+    if(false==demuxer->getFrame (vid->lastSentFrame,img))
     {
         ADM_info("Failed to get next frame for ref %"LU"\n",seg->_reference);
         goto nextSeg;
     }
-    seg->_curFrame++;
+    vid->lastSentFrame++;
     // Need to switch seg ?
     tail=seg->_refStartTimeUs+seg->_durationUs;
     if(img->demuxerDts!= ADM_NO_PTS && img->demuxerDts>tail) goto nextSeg;

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx	2009-10-29 18:57:54 UTC (rev 5430)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx	2009-10-29 18:57:56 UTC (rev 5431)
@@ -144,13 +144,16 @@
 public:
 /************************************ Public API ***************************/
 public:
-                    bool        getCompressedPicture(ADMCompressedImage *img);
+
                     uint64_t    getCurrentFramePts(void);
                     bool        goToTimeVideo(uint64_t time);
                     bool        goToIntraTimeVideo(uint64_t time);
                     bool        nextPicture(ADMImage *image);
                     bool        samePicture(ADMImage *image);
                     bool        rewind(void);
+// Used for stream copy
+                    bool        GoToIntraTime_noDecoding(uint64_t time,uint32_t *toframe=NULL);
+                    bool        getCompressedPicture(ADMCompressedImage *img);                    
 public:
                     uint8_t	    updateVideoInfo(aviInfo *info);
                     uint32_t 	getSpecificMpeg4Info( void );

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoCopy.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoCopy.cpp	2009-10-29 18:57:54 UTC (rev 5430)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoCopy.cpp	2009-10-29 18:57:56 UTC (rev 5431)
@@ -26,7 +26,7 @@
     aviInfo info;
     uint64_t ptsStart=startTime+1;
     uint64_t dtsStart;
-    ADM_info("Creating copy video stream\n");
+    ADM_info("Creating copy video stream, start time=%2.2f s\n",(float)startTime/1000000.);
     video_body->getVideoInfo(&info);
     width=info.width;
     height=info.height;
@@ -57,8 +57,9 @@
     this->startTimePts=ptsStart;
     this->endTimePts=endTime;
 
-    video_body->goToIntraTimeVideo(ptsStart);
+    video_body->GoToIntraTime_noDecoding(ptsStart);
     ADM_info(" Fixating start time by %d\n",abs((int)(startTime-startTimeDts)));
+    ADM_info(" Starting DTS=%"LLU", PTS=%"LLU" ms\n",startTimeDts/1000,startTimePts/1000);
 }
 /**
     \fn ADM_videoStreamCopy



From mean at mail.berlios.de  Fri Oct 30 20:13:15 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 30 Oct 2009 20:13:15 +0100
Subject: [Avidemux-svn-commit] r5432 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor
Message-ID: <200910301913.n9UJDFEV009698@sheep.berlios.de>

Author: mean
Date: 2009-10-30 20:13:14 +0100 (Fri, 30 Oct 2009)
New Revision: 5432

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRenderInternal.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADMedAVIAUD.cpp
Log:
[Editor] Better handling of audio segment switching in copy mode, still no perfect

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp	2009-10-29 18:57:56 UTC (rev 5431)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp	2009-10-30 19:13:14 UTC (rev 5432)
@@ -230,8 +230,8 @@
     vid->lastSentFrame++;
     // Need to switch seg ?
     tail=seg->_refStartTimeUs+seg->_durationUs;
-    if(img->demuxerDts!= ADM_NO_PTS && img->demuxerDts>tail) goto nextSeg;
-    if(img->demuxerPts!= ADM_NO_PTS && img->demuxerPts>tail) goto nextSeg;
+    if(img->demuxerDts!= ADM_NO_PTS && img->demuxerDts>=tail) goto nextSeg;
+    if(img->demuxerPts!= ADM_NO_PTS && img->demuxerPts>=tail) goto nextSeg;
     {
     // Recalibrate PTS & DTS...
     int64_t offset=seg->_refStartTimeUs;

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRenderInternal.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRenderInternal.cpp	2009-10-29 18:57:56 UTC (rev 5431)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRenderInternal.cpp	2009-10-30 19:13:14 UTC (rev 5432)
@@ -583,288 +583,4 @@
     currentFrame=frame;
     return true;
 }
-
-#if 0
-
-/**
-    \fn decodeCache
-    \brief Decode an image an update cache
-    @param ref:index of reference video
-    @param frame:Frame to decode
-    @param image where to put the decoded image
-    @return true if a frame is available
-*/
-
- bool		ADM_Composer::decodeCache(uint32_t ref, uint32_t frame,ADMImage *image)
-{
-
-uint32_t sumit;
-float	 sum;
-
-_VIDEOS *v=_segments.getRefVideo(ref); // FIXME!!!!
-EditorCache *cache=v->_videoCache;
-ADMImage *tmpImage=NULL;
-uint8_t refOnly=0;
-uint32_t left,ww;
-ADMCompressedImage img;
-
-        aprintf("decodeCache : original :%"LD" Frame in ref %"LD"\n",frame,refOffset);
-        img.data=compBuffer;
-        img.cleanup(frame);
-        // Step 1, retrieve the compressed datas, including PTS & DTS infos
-         if (!v->_aviheader->getFrame (frame,&img))
-        {
-          ADM_warning ("Editor: last decoding failed.%"LD")\n",   frame );
-          return 0;
-        }
-        ADM_assert(_imageBuffer);
-
-        // if len is 0 then take the previous image
-        //
-
-        refOnly=v->decoder->dontcopy(); // can we skip one memcpy ?
-
-        if(!img.dataLength & refOnly & !frame)      // Size is null = no image and we only got a pointer
-                                // copy the previous one
-        {
-                // First image
-
-                uint32_t page=_imageBuffer->_width*_imageBuffer->_height;
-                        memset(YPLANE(image),0,page);
-                        memset(UPLANE(image),128,page>>2);
-                        memset(VPLANE(image),128,page>>2);
-                        if(!frame)
-                                image->flags=AVI_KEY_FRAME;
-                        else
-                                image->flags=AVI_P_FRAME;
-                        image->_Qp=2;
-                        image->_qStride=0;
-                        return 1;
-        }
-
-        if(refOnly)
-        {       // This is only an empty Shell
-                uint32_t w,h;
-                if(_scratch) // Can we reuse the old scratch memory ?
-                {
-                    _scratch->getWidthHeight(&w,&h);
-                    if(w!=_imageBuffer->_width || _imageBuffer->_height!=h)
-                    {
-                        delete _scratch;
-                        _scratch=NULL;
-                    }
-                }
-                if(!_scratch)
-                {
-                  _scratch=new ADMImage(_imageBuffer->_width,_imageBuffer->_height,1);
-                }
-                tmpImage=_scratch;
-                ww=_imageBuffer->_width & 0xfffff0;
-                left=_imageBuffer->_width & 0xf;
-
-        }
-        else
-        {
-                tmpImage=_imageBuffer;
-                ww=_imageBuffer->_width;
-                left=0;
-       }
-	tmpImage->_colorspace=ADM_COLOR_YV12;
-	// Do pp, and use imageBuffer as intermediate buffer
-	if (!v->decoder->uncompress (&img, tmpImage))
-	    {
-	      ADM_warning (" Last Decoding2 failed for frame %"LU"\n",frame);
-	       // Try to dupe previous frame
-                if(frame)
-                {
-                        ADMImage *prev;
-                        prev=cache->getImage(frame-1);
-                        if(prev)
-                        {
-                                image->duplicate(prev);
-                                cache->updateFrameNum(image,frame);
-                                return 1;
-                        }
-                }
-                goto _next;
-           }
-
-        //
-        if(tmpImage->_noPicture && refOnly && frame)
-        {
-                cache->updateFrameNum(image,0xffffffffU);
-                return 0;
-        }
-	// If not quant and it is already YV12, we can stop here
-	if((!tmpImage->quant || !tmpImage->_qStride) && tmpImage->_colorspace==ADM_COLOR_YV12)
-	{
-		image->_Qp=2;
-		image->duplicate(tmpImage);
-		cache->updateFrameNum(image,frame);
-          //      if(refOnly) delete tmpImage;
-		aprintf("EdCache: No quant avail\n");
-		return 1;
-	}
-	// We got everything, let's go
-	// 1 compute average quant
-	int qz;
-	sumit=0;
-        // Dupe infos
-        image->copyInfo(tmpImage);
-
-
-        // Do postprocessing if any
-	for(uint32_t z=0;z<tmpImage->_qSize;z++)
-	{
-            qz=(int)tmpImage->quant[z];
-			sumit+=qz;
-	}
-	sumit+=(tmpImage->_qSize-1);
-//	sumit*=2;
-	sum=(float)sumit;
-	sum/=tmpImage->_qSize;
-	if(sum>31) sum=31;
-	if(sum<1) sum=1;
-
-        // update average Q
-	tmpImage->_Qp=image->_Qp=(uint32_t)floor(sum);
-
-	// Pp deactivated ?
-	if(!_pp.postProcType || !_pp.postProcStrength || tmpImage->_colorspace!=ADM_COLOR_YV12)
-     {
-        dupe(tmpImage,image,v);
-		cache->updateFrameNum(image,frame);
-               // if(refOnly) delete tmpImage;
-		aprintf("EdCache: Postproc disabled\n");
-		return 1;
-	}
-
-	int type;
-	#warning FIXME should be FF_I_TYPE/B/P
-	if(tmpImage->flags & AVI_KEY_FRAME) type=1;
-		else if(tmpImage->flags & AVI_B_FRAME) type=3;
-			else type=2;
-
-        ADM_assert(tmpImage->_colorspace==ADM_COLOR_YV12);
-
-	// we do postproc !
-	// keep
-	uint8_t *oBuff[3];
-	const uint8_t *iBuff[3];
-	int	strideTab[3];
-	int	strideTab2[3];
-	aviInfo _info;
-
-		getVideoInfo(&_info);
-                if(refOnly)
-                {
-                        iBuff[0]= tmpImage->_planes[0];
-                        iBuff[1]= tmpImage->_planes[1];
-                        iBuff[2]= tmpImage->_planes[2];
-
-                        strideTab2[0]=_info.width;
-                        strideTab2[1]=_info.width>>1;
-                        strideTab2[2]=_info.width>>1;
-
-                        strideTab[0]=tmpImage->_planeStride[0];
-                        strideTab[1]=tmpImage->_planeStride[1];
-                        strideTab[2]=tmpImage->_planeStride[2];
-
-                }
-                else
-                {
-		        iBuff[0]= YPLANE((tmpImage));
-                iBuff[1]= UPLANE((tmpImage));
-                iBuff[2]= VPLANE((tmpImage));
-
-
-
-                        strideTab[0]=strideTab2[0]=_info.width;
-                        strideTab[1]=strideTab2[1]=_info.width>>1;
-                        strideTab[2]=strideTab2[2]=_info.width>>1;
-                }
-                if(_pp.swapuv)
-                {
-        	        oBuff[0]= YPLANE(image);
-                        oBuff[1]= VPLANE(image);
-                        oBuff[2]= UPLANE(image);
-                }else
-                {
-
-                        oBuff[0]= YPLANE(image);
-                        oBuff[1]= UPLANE(image);
-                        oBuff[2]= VPLANE(image);
-                }
-		 pp_postprocess(
-		 		iBuff,
-		 		strideTab,
-		 		oBuff,
-		 		strideTab2,
-		 		ww,
-		        	_info.height,
-		          	(int8_t *)(tmpImage->quant),
-		          	tmpImage->_qStride,
-		         	_pp.ppMode,
-		          	_pp.ppContext,
-		          	type);			// img type
-                /*
-                        If there is a chroma block that needs padding
-                        (width not multiple of 16) while postprocessing,
-                        we process up to the nearest 16 multiple and
-                        just copy luma & chroma info that was left over
-                */
-                if(refOnly && left)
-                {
-                        uint8_t *src,*dst;
-                        uint32_t stridein,strideout,right;
-                        right=_info.width-left;
-                        // Luma
-                        dst=YPLANE(image)+right;
-                        src=tmpImage->_planes[0]+right;
-                        stridein=tmpImage->_planeStride[0];
-                        strideout=_info.width;
-                        for(uint32_t y=_info.height;y>0;y--)
-                        {
-                                memcpy(dst,src,left);
-                                dst+=strideout;
-                                src+=stridein;
-                        }
-                        // Chroma
-                        left>>=1;
-                        right>>=1;
-                        //
-                        dst=UPLANE(image)+right;
-                        src=tmpImage->_planes[1]+right;
-                        stridein=tmpImage->_planeStride[1];
-                        strideout=_info.width>>1;
-                        for(uint32_t y=_info.height>>1;y>0;y--)
-                        {
-                                memcpy(dst,src,left);
-                                dst+=strideout;
-                                src+=stridein;
-                        }
-                        //
-                        dst=VPLANE(image)+right;
-                        src=tmpImage->_planes[2]+right;
-                        stridein=tmpImage->_planeStride[2];
-                        strideout=_info.width>>1;
-                        for(uint32_t y=_info.height>>1;y>0;y--)
-                        {
-                                memcpy(dst,src,left);
-                                dst+=strideout;
-                                src+=stridein;
-                        }
-
-
-                }
-_next:
-        // update some infos
-        //   if(refOnly) delete tmpImage;
-		cache->updateFrameNum(image,frame);
-		aprintf("EdCache: Postproc done\n");
-		return 1;
-}
-#endif
-
-
 //EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADMedAVIAUD.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADMedAVIAUD.cpp	2009-10-29 18:57:56 UTC (rev 5431)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADMedAVIAUD.cpp	2009-10-30 19:13:14 UTC (rev 5432)
@@ -234,11 +234,44 @@
 */
 uint8_t ADM_Composer::getPacket(uint8_t  *dest, uint32_t *len,uint32_t sizeMax, uint32_t *samples,uint64_t *odts)
 {
-     ADM_audioStreamTrack *trk=getTrack(0);
+        
+    _SEGMENT *seg=_segments.getSegment(_audioSeg);
+    ADM_audioStreamTrack *trk=getTrack(seg->_reference);
     if(!trk) return 0;
-    // Read a packet from stream 0
-     return trk->stream->getPacket(dest,len,sizeMax,samples,odts);
-    
+    uint64_t off=lastDts-seg->_startTimeUs;
+   
+    // Read a packet
+zgain:
+    bool r=trk->stream->getPacket(dest,len,sizeMax,samples,odts);
+    if(r==false) return false;
+    //
+
+
+    // Rescale odts
+    if(*odts!=ADM_NO_PTS)
+    {
+        if(*odts<seg->_refStartTimeUs)
+        {
+            ADM_warning("Audio packet is too early %"LLU" ms, this segment starts at %"LLU"ms\n",*odts,seg->_refStartTimeUs);
+            goto zgain;
+        }
+        
+        *odts-=seg->_refStartTimeUs;
+        if(*odts>seg->_durationUs)
+        {
+            if(switchToNextAudioSegment()==false)
+            {
+                return false;
+            }
+            goto zgain;
+        }
+        *odts+=seg->_startTimeUs;
+    }else
+    {
+        *odts=ADM_NO_PTS;
+    }
+    //advanceDtsBySample(*samples);
+    return true;
 }
 /**
     \fn goToTime



