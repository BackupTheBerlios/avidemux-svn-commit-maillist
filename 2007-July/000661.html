<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r3384 -	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2007-July/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r3384%20-%0A%09branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil&In-Reply-To=%3C200707161745.l6GHj86M008187%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000660.html">
   <LINK REL="Next"  HREF="000662.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r3384 -	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil</H1>
    <B>mean at BerliOS</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r3384%20-%0A%09branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil&In-Reply-To=%3C200707161745.l6GHj86M008187%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r3384 -	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil">mean at mail.berlios.de
       </A><BR>
    <I>Mon Jul 16 19:45:08 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000660.html">[Avidemux-svn-commit] r3383 -	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat
</A></li>
        <LI>Next message: <A HREF="000662.html">[Avidemux-svn-commit] r3386 - in	branches/avidemux_2.4_branch/avidemux/ADM_libraries:	ADM_lavcodec ADM_lavutil
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#661">[ date ]</a>
              <a href="thread.html#661">[ thread ]</a>
              <a href="subject.html#661">[ subject ]</a>
              <a href="author.html#661">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2007-07-16 19:45:07 +0200 (Mon, 16 Jul 2007)
New Revision: 3384

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/CMakeLists.txt
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/adler32.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/adler32.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/avutil.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/bswap.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/common.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/crc.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/crc.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/fifo.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/integer.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/integer.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/internal.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/intreadwrite.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/lls.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/lls.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/log.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/md5.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/md5.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/mem.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/rational.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/rational.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/x86_cpu.h
Log:
[LAV] update to RR9685 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/CMakeLists.txt
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/CMakeLists.txt	2007-07-16 17:44:22 UTC (rev 3383)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/CMakeLists.txt	2007-07-16 17:45:07 UTC (rev 3384)
@@ -6,6 +6,7 @@
 #
 SET(${ADM_LIB}_SRCS 
 integer.c  intfloat_readwrite.c  mathematics.c  rational.c md5.c crc.c log.c  adler32.c lls.c
+string.c
 
 )
 ADD_LIBRARY(${ADM_LIB} STATIC ${${ADM_LIB}_SRCS})

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/adler32.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/adler32.c	2007-07-16 17:44:22 UTC (rev 3383)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/adler32.c	2007-07-16 17:45:07 UTC (rev 3384)
@@ -18,7 +18,6 @@
  * 2. Altered source versions must be plainly marked as such, and must not be
  *    misrepresented as being the original software.
  * 3. This notice may not be removed or altered from any source distribution.
- *
  */
 
 #include &quot;common.h&quot;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/adler32.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/adler32.h	2007-07-16 17:44:22 UTC (rev 3383)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/adler32.h	2007-07-16 17:45:07 UTC (rev 3384)
@@ -21,6 +21,8 @@
 #ifndef ADLER32_H
 #define ADLER32_H
 
+#include &lt;stdint.h&gt;
+
 unsigned long av_adler32_update(unsigned long adler, const uint8_t *buf,
                                 unsigned int len);
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/avutil.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/avutil.h	2007-07-16 17:44:22 UTC (rev 3383)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/avutil.h	2007-07-16 17:45:07 UTC (rev 3384)
@@ -27,23 +27,19 @@
  */
 
 
-#ifdef __cplusplus
-extern &quot;C&quot; {
-#endif
-/* MEANX
- */
-	#define ASMALIGN(ZEROBITS) &quot;.p2align &quot; #ZEROBITS &quot;\n\t&quot; 
-/* /MEANX
- */
-
 #define AV_STRINGIFY(s)         AV_TOSTRING(s)
 #define AV_TOSTRING(s) #s
 
-#define LIBAVUTIL_VERSION_INT   ((49&lt;&lt;16)+(2&lt;&lt;8)+0)
-#define LIBAVUTIL_VERSION       49.2.0
+#define LIBAVUTIL_VERSION_INT   ((49&lt;&lt;16)+(4&lt;&lt;8)+1)
+#define LIBAVUTIL_VERSION       49.4.1
 #define LIBAVUTIL_BUILD         LIBAVUTIL_VERSION_INT
 
 #define LIBAVUTIL_IDENT         &quot;Lavu&quot; AV_STRINGIFY(LIBAVUTIL_VERSION)
+/* MEANX
+ */
+	#define ASMALIGN(ZEROBITS) &quot;.p2align &quot; #ZEROBITS &quot;\n\t&quot; 
+/* /MEANX
+ */
 
 
 #include &quot;common.h&quot;
@@ -85,8 +81,8 @@
     PIX_FMT_RGB565,    ///&lt; Packed RGB 5:6:5, 16bpp, (msb)   5R 6G 5B(lsb), in cpu endianness
     PIX_FMT_RGB555,    ///&lt; Packed RGB 5:5:5, 16bpp, (msb)1A 5R 5G 5B(lsb), in cpu endianness most significant bit to 0
     PIX_FMT_GRAY8,     ///&lt;        Y        ,  8bpp
-    PIX_FMT_MONOWHITE, ///&lt;        Y        ,  1bpp, 1 is white
-    PIX_FMT_MONOBLACK, ///&lt;        Y        ,  1bpp, 0 is black
+    PIX_FMT_MONOWHITE, ///&lt;        Y        ,  1bpp, 0 is white, 1 is black
+    PIX_FMT_MONOBLACK, ///&lt;        Y        ,  1bpp, 0 is black, 1 is white
     PIX_FMT_PAL8,      ///&lt; 8 bit with PIX_FMT_RGB32 palette
     PIX_FMT_YUVJ420P,  ///&lt; Planar YUV 4:2:0, 12bpp, full scale (jpeg)
     PIX_FMT_YUVJ422P,  ///&lt; Planar YUV 4:2:2, 16bpp, full scale (jpeg)
@@ -135,8 +131,4 @@
 #define PIX_FMT_YUV422  PIX_FMT_YUYV422
 #endif
 
-#ifdef __cplusplus
-}
-#endif
-
 #endif /* AVUTIL_H */

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/bswap.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/bswap.h	2007-07-16 17:44:22 UTC (rev 3383)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/bswap.h	2007-07-16 17:45:07 UTC (rev 3384)
@@ -23,9 +23,12 @@
  * byte swap.
  */
 
-#ifndef __BSWAP_H__
-#define __BSWAP_H__
+#ifndef BSWAP_H
+#define BSWAP_H
 
+#include &lt;stdint.h&gt;
+#include &quot;common.h&quot;
+
 #ifdef HAVE_BYTESWAP_H
 #include &lt;byteswap.h&gt;
 #else
@@ -36,17 +39,23 @@
 #  define LEGACY_REGS &quot;=q&quot;
 #endif
 
-#if defined(ARCH_X86)
 static av_always_inline uint16_t bswap_16(uint16_t x)
 {
+#if defined(ARCH_X86)
   __asm(&quot;rorw $8, %0&quot;   :
         LEGACY_REGS (x) :
         &quot;0&quot; (x));
+#elif defined(ARCH_SH4)
+        __asm__(&quot;swap.b %0,%0&quot;:&quot;=r&quot;(x):&quot;0&quot;(x));
+#else
+    x= (x&gt;&gt;8) | (x&lt;&lt;8);
+#endif
     return x;
 }
 
 static av_always_inline uint32_t bswap_32(uint32_t x)
 {
+#if defined(ARCH_X86)
 #if __CPU__ != 386
  __asm(&quot;bswap   %0&quot;:
       &quot;=r&quot; (x)     :
@@ -57,65 +66,13 @@
       LEGACY_REGS (x)                :
 #endif
       &quot;0&quot; (x));
-  return x;
-}
-
-static inline uint64_t bswap_64(uint64_t x)
-{
-#ifdef ARCH_X86_64
-  __asm(&quot;bswap  %0&quot;:
-        &quot;=r&quot; (x)   :
-        &quot;0&quot; (x));
-  return x;
-#else
-    union {
-        uint64_t ll;
-        struct {
-           uint32_t l,h;
-        } l;
-    } r;
-    r.l.l = bswap_32 (x);
-    r.l.h = bswap_32 (x&gt;&gt;32);
-    return r.ll;
-#endif
-}
-
 #elif defined(ARCH_SH4)
-
-static av_always_inline uint16_t bswap_16(uint16_t x) {
-        __asm__(&quot;swap.b %0,%0&quot;:&quot;=r&quot;(x):&quot;0&quot;(x));
-        return x;
-}
-
-static av_always_inline uint32_t bswap_32(uint32_t x) {
         __asm__(
         &quot;swap.b %0,%0\n&quot;
         &quot;swap.w %0,%0\n&quot;
         &quot;swap.b %0,%0\n&quot;
         :&quot;=r&quot;(x):&quot;0&quot;(x));
-        return x;
-}
-
-static inline uint64_t bswap_64(uint64_t x)
-{
-    union {
-        uint64_t ll;
-        struct {
-           uint32_t l,h;
-        } l;
-    } r;
-    r.l.l = bswap_32 (x);
-    r.l.h = bswap_32 (x&gt;&gt;32);
-    return r.ll;
-}
-#else
-
-static av_always_inline uint16_t bswap_16(uint16_t x){
-    return (x&gt;&gt;8) | (x&lt;&lt;8);
-}
-
-#ifdef ARCH_ARM
-static av_always_inline uint32_t bswap_32(uint32_t x){
+#elif defined(ARCH_ARM)
     uint32_t t;
     __asm__ (
       &quot;eor %1, %0, %0, ror #16 \n\t&quot;
@@ -123,14 +80,19 @@
       &quot;mov %0, %0, ror #8      \n\t&quot;
       &quot;eor %0, %0, %1, lsr #8  \n\t&quot;
       : &quot;+r&quot;(x), &quot;+r&quot;(t));
-    return x;
-}
+#elif defined(ARCH_BFIN)
+    unsigned tmp;
+    asm(&quot;%1 = %0 &gt;&gt; 8 (V);\n\t&quot;
+        &quot;%0 = %0 &lt;&lt; 8 (V);\n\t&quot;
+        &quot;%0 = %0 | %1;\n\t&quot;
+        &quot;%0 = PACK(%0.L, %0.H);\n\t&quot;
+        : &quot;+d&quot;(x), &quot;=&amp;d&quot;(tmp));
 #else
-static av_always_inline uint32_t bswap_32(uint32_t x){
     x= ((x&lt;&lt;8)&amp;0xFF00FF00) | ((x&gt;&gt;8)&amp;0x00FF00FF);
-    return (x&gt;&gt;16) | (x&lt;&lt;16);
-}
+    x= (x&gt;&gt;16) | (x&lt;&lt;16);
 #endif
+    return x;
+}
 
 static inline uint64_t bswap_64(uint64_t x)
 {
@@ -138,6 +100,11 @@
     x= ((x&lt;&lt; 8)&amp;0xFF00FF00FF00FF00ULL) | ((x&gt;&gt; 8)&amp;0x00FF00FF00FF00FFULL);
     x= ((x&lt;&lt;16)&amp;0xFFFF0000FFFF0000ULL) | ((x&gt;&gt;16)&amp;0x0000FFFF0000FFFFULL);
     return (x&gt;&gt;32) | (x&lt;&lt;32);
+#elif defined(ARCH_X86_64)
+  __asm(&quot;bswap  %0&quot;:
+        &quot;=r&quot; (x)   :
+        &quot;0&quot; (x));
+  return x;
 #else
     union {
         uint64_t ll;
@@ -149,7 +116,6 @@
     return r.ll;
 #endif
 }
-#endif  /* defined(ARCH_X86) */
 
 #endif  /* !HAVE_BYTESWAP_H */
 
@@ -172,4 +138,4 @@
 #define le2me_64(x) (x)
 #endif
 
-#endif /* __BSWAP_H__ */
+#endif /* BSWAP_H */

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/common.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/common.h	2007-07-16 17:44:22 UTC (rev 3383)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/common.h	2007-07-16 17:45:07 UTC (rev 3384)
@@ -37,19 +37,17 @@
 #    include &lt;string.h&gt;
 #    include &lt;ctype.h&gt;
 #    include &lt;limits.h&gt;
-#    ifndef __BEOS__
-#        include &lt;errno.h&gt;
-#    else
-#        include &quot;berrno.h&quot;
-#    endif
+#    include &lt;errno.h&gt;
 #    include &lt;math.h&gt;
 #endif /* HAVE_AV_CONFIG_H */
 
 #ifndef av_always_inline
 #if defined(__GNUC__) &amp;&amp; (__GNUC__ &gt; 3 || __GNUC__ == 3 &amp;&amp; __GNUC_MINOR__ &gt; 0)
 #    define av_always_inline __attribute__((always_inline)) inline
+#    define av_noinline __attribute__((noinline))
 #else
 #    define av_always_inline inline
+#    define av_noinline
 #endif
 #endif
 
@@ -65,11 +63,16 @@
 #endif
 #endif
 
-#ifndef INT64_C
-#define INT64_C(c)     (c ## LL)
-#define UINT64_C(c)    (c ## ULL)
+#ifndef av_unused
+#if defined(__GNUC__)
+#    define av_unused __attribute__((unused))
+#else
+#    define av_unused
 #endif
+#endif
 
+#include &quot;mem.h&quot;
+
 //rounded divison &amp; shift
 #define RSHIFT(a,b) ((a) &gt; 0 ? ((a) + ((1&lt;&lt;(b))&gt;&gt;1))&gt;&gt;(b) : ((a) + ((1&lt;&lt;(b))&gt;&gt;1)-1)&gt;&gt;(b))
 /* assume b&gt;0 */
@@ -165,7 +168,7 @@
  * @param amax maximum value of the clip range
  * @return clipped value
  */
-static inline int clip(int a, int amin, int amax)
+static inline int av_clip(int a, int amin, int amax)
 {
     if (a &lt; amin)      return amin;
     else if (a &gt; amax) return amax;
@@ -177,7 +180,7 @@
  * @param a value to clip
  * @return clipped value
  */
-static inline uint8_t clip_uint8(int a)
+static inline uint8_t av_clip_uint8(int a)
 {
     if (a&amp;(~255)) return (-a)&gt;&gt;31;
     else          return a;
@@ -202,14 +205,14 @@
 
 /*!
  * \def GET_UTF8(val, GET_BYTE, ERROR)
- * converts a utf-8 character (up to 4 bytes long) to its 32-bit ucs-4 encoded form
+ * converts a UTF-8 character (up to 4 bytes long) to its 32-bit UCS-4 encoded form
  * \param val is the output and should be of type uint32_t. It holds the converted
- * ucs-4 character and should be a left value.
- * \param GET_BYTE gets utf-8 encoded bytes from any proper source. It can be
+ * UCS-4 character and should be a left value.
+ * \param GET_BYTE gets UTF-8 encoded bytes from any proper source. It can be
  * a function or a statement whose return value or evaluated value is of type
- * uint8_t. It will be executed up to 4 times for values in the valid utf-8 range,
+ * uint8_t. It will be executed up to 4 times for values in the valid UTF-8 range,
  * and up to 7 times in the general case.
- * \param ERROR action that should be taken when an invalid utf-8 byte is returned
+ * \param ERROR action that should be taken when an invalid UTF-8 byte is returned
  * from GET_BYTE. It should be a statement that jumps out of the macro,
  * like exit(), goto, return, break, or continue.
  */
@@ -230,17 +233,17 @@
 
 /*!
  * \def PUT_UTF8(val, tmp, PUT_BYTE)
- * converts a 32-bit unicode character to its utf-8 encoded form (up to 4 bytes long).
+ * converts a 32-bit unicode character to its UTF-8 encoded form (up to 4 bytes long).
  * \param val is an input only argument and should be of type uint32_t. It holds
- * a ucs4 encoded unicode character that is to be converted to utf-8. If
+ * a ucs4 encoded unicode character that is to be converted to UTF-8. If
  * val is given as a function it's executed only once.
  * \param tmp is a temporary variable and should be of type uint8_t. It
  * represents an intermediate value during conversion that is to be
  * outputted by PUT_BYTE.
- * \param PUT_BYTE writes the converted utf-8 bytes to any proper destination.
+ * \param PUT_BYTE writes the converted UTF-8 bytes to any proper destination.
  * It could be a function or a statement, and uses tmp as the input byte.
  * For example, PUT_BYTE could be &quot;*output++ = tmp;&quot; PUT_BYTE will be
- * executed up to 4 times for values in the valid utf-8 range and up to
+ * executed up to 4 times for values in the valid UTF-8 range and up to
  * 7 times in the general case, depending on the length of the converted
  * unicode character.
  */
@@ -264,7 +267,7 @@
         }\
     }
 
-#if defined(ARCH_X86) || defined(ARCH_POWERPC)
+#if defined(ARCH_X86) || defined(ARCH_POWERPC) || defined(ARCH_BFIN)
 #if defined(ARCH_X86_64)
 static inline uint64_t read_time(void)
 {
@@ -283,6 +286,19 @@
         );
         return l;
 }
+#elif ARCH_BFIN
+static inline uint64_t read_time(void)
+{
+    union {
+        struct {
+            unsigned lo;
+            unsigned hi;
+        } p;
+        unsigned long long c;
+    } t;
+    asm volatile (&quot;%0=cycles; %1=cycles2;&quot; : &quot;=d&quot; (t.p.lo), &quot;=d&quot; (t.p.hi));
+    return t.c;
+}
 #else //FIXME check ppc64
 static inline uint64_t read_time(void)
 {
@@ -314,7 +330,7 @@
   static uint64_t tsum=0;\
   static int tcount=0;\
   static int tskip_count=0;\
-  if(tcount&lt;2 || tend - tstart &lt; 8*tsum/tcount){\
+  if(tcount&lt;2 || tend - tstart &lt; FFMAX(8*tsum/tcount, 2000)){\
       tsum+= tend - tstart;\
       tcount++;\
   }else\
@@ -328,21 +344,4 @@
 #define STOP_TIMER(id) {}
 #endif
 
-/* memory */
-
-#ifdef __GNUC__
-  #define DECLARE_ALIGNED(n,t,v)       t v __attribute__ ((aligned (n)))
-#else
-  #define DECLARE_ALIGNED(n,t,v)      __declspec(align(n)) t v
-#endif
-
-/* memory */
-void *av_malloc(unsigned int size);
-void *av_realloc(void *ptr, unsigned int size);
-void av_free(void *ptr);
-
-void *av_mallocz(unsigned int size);
-char *av_strdup(const char *s);
-void av_freep(void *ptr);
-
 #endif /* COMMON_H */

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/crc.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/crc.c	2007-07-16 17:44:22 UTC (rev 3383)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/crc.c	2007-07-16 17:45:07 UTC (rev 3384)
@@ -21,10 +21,17 @@
 #include &quot;common.h&quot;
 #include &quot;crc.h&quot;
 
+#if LIBAVUTIL_VERSION_INT  &lt; (50&lt;&lt;16)
 AVCRC *av_crcEDB88320;
 AVCRC *av_crc04C11DB7;
 AVCRC *av_crc8005    ;
 AVCRC *av_crc07      ;
+#else
+AVCRC av_crcEDB88320[257];
+AVCRC av_crc04C11DB7[257];
+AVCRC av_crc8005    [257];
+AVCRC av_crc07      [257];
+#endif
 
 /**
  * Inits a crc table.

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/crc.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/crc.h	2007-07-16 17:44:22 UTC (rev 3383)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/crc.h	2007-07-16 17:45:07 UTC (rev 3384)
@@ -21,12 +21,22 @@
 #ifndef CRC_H
 #define CRC_H
 
+#include &lt;stdint.h&gt;
+#include &lt;sys/types.h&gt;
+
 typedef uint32_t AVCRC;
 
+#if LIBAVUTIL_VERSION_INT  &lt; (50&lt;&lt;16)
 extern AVCRC *av_crcEDB88320;
 extern AVCRC *av_crc04C11DB7;
 extern AVCRC *av_crc8005    ;
 extern AVCRC *av_crc07      ;
+#else
+extern AVCRC av_crcEDB88320[];
+extern AVCRC av_crc04C11DB7[];
+extern AVCRC av_crc8005    [];
+extern AVCRC av_crc07      [];
+#endif
 
 int av_crc_init(AVCRC *ctx, int le, int bits, uint32_t poly, int ctx_size);
 uint32_t av_crc(const AVCRC *ctx, uint32_t start_crc, const uint8_t *buffer, size_t length);

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/fifo.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/fifo.h	2007-07-16 17:44:22 UTC (rev 3383)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/fifo.h	2007-07-16 17:45:07 UTC (rev 3384)
@@ -1,18 +1,95 @@
+/*
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file fifo.h
+ * A very simple circular buffer FIFO implementation.
+ */
+
 #ifndef FIFO_H
 #define FIFO_H
 
+#include &lt;stdint.h&gt;
+
 typedef struct AVFifoBuffer {
     uint8_t *buffer;
     uint8_t *rptr, *wptr, *end;
 } AVFifoBuffer;
 
+/**
+ * Initializes an AVFifoBuffer.
+ * @param *f AVFifoBuffer to initialize
+ * @param size of FIFO
+ * @return &lt;0 for failure &gt;=0 otherwise
+ */
 int av_fifo_init(AVFifoBuffer *f, int size);
+
+/**
+ * Frees an AVFifoBuffer.
+ * @param *f AVFifoBuffer to free
+ */
 void av_fifo_free(AVFifoBuffer *f);
+
+/**
+ * Returns the amount of data in bytes in the AVFifoBuffer, that is the
+ * amount of data you can read from it.
+ * @param *f AVFifoBuffer to read from
+ * @return size
+ */
 int av_fifo_size(AVFifoBuffer *f);
+
+/**
+ * Reads data from an AVFifoBuffer.
+ * @param *f AVFifoBuffer to read from
+ * @param *buf data destination
+ * @param buf_size number of bytes to read
+ */
 int av_fifo_read(AVFifoBuffer *f, uint8_t *buf, int buf_size);
+
+/**
+ * Feeds data from an AVFifoBuffer to a user supplied callback.
+ * @param *f AVFifoBuffer to read from
+ * @param buf_size number of bytes to read
+ * @param *func generic read function
+ * @param *dest data destination
+ */
 int av_fifo_generic_read(AVFifoBuffer *f, int buf_size, void (*func)(void*, void*, int), void* dest);
+
+/**
+ * Writes data into an AVFifoBuffer.
+ * @param *f AVFifoBuffer to write to
+ * @param *buf data source
+ * @param size data size
+ */
 void av_fifo_write(AVFifoBuffer *f, const uint8_t *buf, int size);
+
+/**
+ * Resizes an AVFifoBuffer.
+ * @param *f AVFifoBuffer to resize
+ * @param size new AVFifoBuffer size in bytes
+ */
 void av_fifo_realloc(AVFifoBuffer *f, unsigned int size);
+
+/**
+ * Reads and discards the specified amount of data from an AVFifoBuffer.
+ * @param *f AVFifoBuffer to read from
+ * @param size amount of data to read in bytes
+ */
 void av_fifo_drain(AVFifoBuffer *f, int size);
 
 static inline uint8_t av_fifo_peek(AVFifoBuffer *f, int offs)

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/integer.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/integer.c	2007-07-16 17:44:22 UTC (rev 3383)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/integer.c	2007-07-16 17:45:07 UTC (rev 3384)
@@ -17,7 +17,6 @@
  * You should have received a copy of the GNU Lesser General Public
  * License along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- *
  */
 
 /**
@@ -49,10 +48,6 @@
     return a;
 }
 
-/**
- * returns the rounded down value of the logarithm of base 2 of the given AVInteger.
- * this is simply the index of the most significant bit which is 1. Or 0 of all bits are 0
- */
 int av_log2_i(AVInteger a){
     int i;
 
@@ -84,9 +79,6 @@
     return out;
 }
 
-/**
- * returns 0 if a==b, 1 if a&gt;b and -1 if a&lt;b.
- */
 int av_cmp_i(AVInteger a, AVInteger b){
     int i;
     int v= (int16_t)a.v[AV_INTEGER_SIZE-1] - (int16_t)b.v[AV_INTEGER_SIZE-1];
@@ -99,10 +91,6 @@
     return 0;
 }
 
-/**
- * bitwise shift.
- * @param s the number of bits by which the value should be shifted right, may be negative for shifting left
- */
 AVInteger av_shr_i(AVInteger a, int s){
     AVInteger out;
     int i;
@@ -117,10 +105,6 @@
     return out;
 }
 
-/**
- * returns a % b.
- * @param quot a/b will be stored here
- */
 AVInteger av_mod_i(AVInteger *quot, AVInteger a, AVInteger b){
     int i= av_log2_i(a) - av_log2_i(b);
     AVInteger quot_temp;
@@ -145,18 +129,12 @@
     return a;
 }
 
-/**
- * returns a/b.
- */
 AVInteger av_div_i(AVInteger a, AVInteger b){
     AVInteger quot;
     av_mod_i(&amp;quot, a, b);
     return quot;
 }
 
-/**
- * converts the given int64_t to an AVInteger.
- */
 AVInteger av_int2i(int64_t a){
     AVInteger out;
     int i;
@@ -168,11 +146,6 @@
     return out;
 }
 
-/**
- * converts the given AVInteger to an int64_t.
- * if the AVInteger is too large to fit into an int64_t,
- * then only the least significant 64bit will be used
- */
 int64_t av_i2int(AVInteger a){
     int i;
     int64_t out=(int8_t)a.v[AV_INTEGER_SIZE-1];

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/integer.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/integer.h	2007-07-16 17:44:22 UTC (rev 3383)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/integer.h	2007-07-16 17:45:07 UTC (rev 3384)
@@ -17,7 +17,6 @@
  * You should have received a copy of the GNU Lesser General Public
  * License along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- *
  */
 
 /**
@@ -29,6 +28,8 @@
 #ifndef INTEGER_H
 #define INTEGER_H
 
+#include &lt;stdint.h&gt;
+
 #define AV_INTEGER_SIZE 8
 
 typedef struct AVInteger{
@@ -37,13 +38,46 @@
 
 AVInteger av_add_i(AVInteger a, AVInteger b);
 AVInteger av_sub_i(AVInteger a, AVInteger b);
+
+/**
+ * returns the rounded down value of the logarithm of base 2 of the given AVInteger.
+ * this is simply the index of the most significant bit which is 1. Or 0 of all bits are 0
+ */
 int av_log2_i(AVInteger a);
 AVInteger av_mul_i(AVInteger a, AVInteger b);
+
+/**
+ * returns 0 if a==b, 1 if a&gt;b and -1 if a&lt;b.
+ */
 int av_cmp_i(AVInteger a, AVInteger b);
+
+/**
+ * bitwise shift.
+ * @param s the number of bits by which the value should be shifted right, may be negative for shifting left
+ */
 AVInteger av_shr_i(AVInteger a, int s);
+
+/**
+ * returns a % b.
+ * @param quot a/b will be stored here
+ */
 AVInteger av_mod_i(AVInteger *quot, AVInteger a, AVInteger b);
+
+/**
+ * returns a/b.
+ */
 AVInteger av_div_i(AVInteger a, AVInteger b);
+
+/**
+ * converts the given int64_t to an AVInteger.
+ */
 AVInteger av_int2i(int64_t a);
+
+/**
+ * converts the given AVInteger to an int64_t.
+ * if the AVInteger is too large to fit into an int64_t,
+ * then only the least significant 64bit will be used
+ */
 int64_t av_i2int(AVInteger a);
 
 #endif // INTEGER_H

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/internal.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/internal.h	2007-07-16 17:44:22 UTC (rev 3383)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/internal.h	2007-07-16 17:45:07 UTC (rev 3384)
@@ -26,14 +26,14 @@
 #ifndef INTERNAL_H
 #define INTERNAL_H
 
-#ifndef attribute_align_arg
-#if defined(__GNUC__) &amp;&amp; (__GNUC__ &gt; 4 || __GNUC__ == 4 &amp;&amp; __GNUC_MINOR__ &gt; 1)
-#    define attribute_align_arg __attribute__((force_align_arg_pointer))
-#else
-#    define attribute_align_arg
-#endif
-#endif
+#if !defined(DEBUG) &amp;&amp; !defined(NDEBUG)
+#    define NDEBUG
+#endif
 
+#include &lt;stdint.h&gt;
+#include &lt;stddef.h&gt;
+#include &lt;assert.h&gt;
+
 #ifndef attribute_used
 #if defined(__GNUC__) &amp;&amp; (__GNUC__ &gt; 3 || __GNUC__ == 3 &amp;&amp; __GNUC_MINOR__ &gt; 0)
 #    define attribute_used __attribute__((used))
@@ -42,46 +42,10 @@
 #endif
 #endif
 
-#ifndef attribute_unused
-#if defined(__GNUC__)
-#    define attribute_unused __attribute__((unused))
-#else
-#    define attribute_unused
-#endif
-#endif
-
 #ifndef M_PI
 #define M_PI    3.14159265358979323846
 #endif
 
-#ifndef PRId64
-#define PRId64 &quot;lld&quot;
-#endif
-
-#ifndef PRIu64
-#define PRIu64 &quot;llu&quot;
-#endif
-
-#ifndef PRIx64
-#define PRIx64 &quot;llx&quot;
-#endif
-
-#ifndef PRIX64
-#define PRIX64 &quot;llX&quot;
-#endif
-
-#ifndef PRId32
-#define PRId32 &quot;d&quot;
-#endif
-
-#ifndef PRIdFAST16
-#define PRIdFAST16 PRId32
-#endif
-
-#ifndef PRIdFAST32
-#define PRIdFAST32 PRId32
-#endif
-
 #ifndef INT16_MIN
 #define INT16_MIN       (-0x7fff-1)
 #endif
@@ -126,45 +90,20 @@
 #    define PIC
 #endif
 
-#ifndef ENODATA
-#    define ENODATA  61
-#endif
-
 #include &quot;intreadwrite.h&quot;
 #include &quot;bswap.h&quot;
 
-#include &lt;stddef.h&gt;
 #ifndef offsetof
 #    define offsetof(T,F) ((unsigned int)((char *)&amp;((T *)0)-&gt;F))
 #endif
 
-#ifdef __MINGW32__
-#    ifdef _DEBUG
-#        define DEBUG
-#    endif
-
-#    define snprintf _snprintf
-#    define vsnprintf _vsnprintf
-
-#    ifdef CONFIG_WINCE
-#        define perror(a)
-#        define abort()
-#    endif
-
-/* __MINGW32__ end */
-#elif defined (CONFIG_OS2)
-/* OS/2 EMX */
-
-#    include &lt;float.h&gt;
-
-#endif /* !__MINGW32__ &amp;&amp; CONFIG_OS2 */
-
 #ifdef USE_FASTMEMCPY
 #    include &quot;libvo/fastmemcpy.h&quot;
+#    define memcpy(a,b,c) fast_memcpy(a,b,c)
 #endif
 
 // Use rip-relative addressing if compiling PIC code on x86-64.
-#if defined(__MINGW32__) || defined(__APPLE__)|| defined(__CYGWIN__) || \
+#if defined(__MINGW32__) || defined(__CYGWIN__) || \
     defined(__OS2__) || (defined (__OpenBSD__) &amp;&amp; !defined(__ELF__))
 #    if defined(ARCH_X86_64) &amp;&amp; defined(PIC)
 #        define MANGLE(a) &quot;_&quot; #a&quot;(%%rip)&quot;
@@ -183,16 +122,11 @@
 
 /* debug stuff */
 
-#if !defined(DEBUG) &amp;&amp; !defined(NDEBUG)
-#    define NDEBUG
-#endif
-#include &lt;assert.h&gt;
-
 /* dprintf macros */
 #ifdef DEBUG
-#    define dprintf(fmt,...) av_log(NULL, AV_LOG_DEBUG, fmt, __VA_ARGS__)
+#    define dprintf(pctx, ...) av_log(pctx, AV_LOG_DEBUG, __VA_ARGS__)
 #else
-#    define dprintf(fmt,...)
+#    define dprintf(pctx, ...)
 #endif
 
 #define av_abort()      do { av_log(NULL, AV_LOG_ERROR, &quot;Abort at %s:%d\n&quot;, __FILE__, __LINE__); abort(); } while (0)
@@ -234,16 +168,16 @@
 static inline int ff_sqrt(int a)
 {
     int ret=0;
-    int s;
-    int ret_sq=0;
+    int s, b;
 
     if(a&lt;128) return ff_sqrt_tab[a];
 
-    for(s=15; s&gt;=0; s--){
-        int b= ret_sq + (1&lt;&lt;(s*2)) + (ret&lt;&lt;s)*2;
+    for(s=30; s&gt;=0; s-=2){
+        ret+=ret;
+        b= (1+2*ret)&lt;&lt;s;
         if(b&lt;=a){
-            ret_sq=b;
-            ret+= 1&lt;&lt;s;
+            a-=b;
+            ret++;
         }
     }
     return ret;
@@ -270,7 +204,7 @@
     &quot;cmovl %3, %0       \n\t&quot;\
     &quot;cmovl %4, %1       \n\t&quot;\
     &quot;cmovl %5, %2       \n\t&quot;\
-    : &quot;+r&quot; (x), &quot;+r&quot; (a), &quot;+r&quot; (c)\
+    : &quot;+&amp;r&quot; (x), &quot;+&amp;r&quot; (a), &quot;+r&quot; (c)\
     : &quot;r&quot; (y), &quot;r&quot; (b), &quot;r&quot; (d)\
 );
 #else
@@ -283,16 +217,30 @@
 #endif
 
 /* avoid usage of various functions */
+#undef  malloc
 #define malloc please_use_av_malloc
+#undef  free
 #define free please_use_av_free
+#undef  realloc
 #define realloc please_use_av_realloc
+#undef  time
 #define time time_is_forbidden_due_to_security_issues
-#define rand rand_is_forbidden_due_to_state_trashing
-#define srand srand_is_forbidden_due_to_state_trashing
+#undef  rand
+#define rand rand_is_forbidden_due_to_state_trashing_use_av_random
+#undef  srand
+#define srand srand_is_forbidden_due_to_state_trashing_use_av_init_random
+#undef  random
+#define random random_is_forbidden_due_to_state_trashing_use_av_random
+#undef  sprintf
 #define sprintf sprintf_is_forbidden_due_to_security_issues_use_snprintf
-#define strcat strcat_is_forbidden_due_to_security_issues_use_pstrcat
-#if !(defined(LIBAVFORMAT_BUILD) || defined(_FRAMEHOOK_H))
+#undef  strcat
+#define strcat strcat_is_forbidden_due_to_security_issues_use_av_strlcat
+#undef  exit
+#define exit exit_is_forbidden
+#if !(defined(LIBAVFORMAT_BUILD) || defined(FRAMEHOOK_H))
+#undef  printf
 #define printf please_use_av_log
+#undef  fprintf
 #define fprintf please_use_av_log
 #endif
 
@@ -311,21 +259,7 @@
 /* btw, rintf() is existing on fbsd too -- alex */
 static av_always_inline long int lrintf(float x)
 {
-#ifdef __MINGW32__
-#  ifdef ARCH_X86_32
-    int32_t i;
-    asm volatile(
-        &quot;fistpl %0\n\t&quot;
-        : &quot;=m&quot; (i) : &quot;t&quot; (x) : &quot;st&quot;
-    );
-    return i;
-#  else
-    /* XXX: incorrect, but make it compile */
-    return (int)(x + (x &lt; 0 ? -0.5 : 0.5));
-#  endif /* ARCH_X86_32 */
-#else
     return (int)(rint(x));
-#endif /* __MINGW32__ */
 }
 #endif /* HAVE_LRINTF */
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/intreadwrite.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/intreadwrite.h	2007-07-16 17:44:22 UTC (rev 3383)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/intreadwrite.h	2007-07-16 17:45:07 UTC (rev 3384)
@@ -1,6 +1,27 @@
+/*
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
 #ifndef INTREADWRITE_H
 #define INTREADWRITE_H
 
+#include &lt;stdint.h&gt;
+#include &quot;bswap.h&quot;
+
 #ifdef __GNUC__
 
 struct unaligned_64 { uint64_t l; } __attribute__((packed));
@@ -13,6 +34,7 @@
 
 #define ST16(a, b) (((struct unaligned_16 *) (a))-&gt;l) = (b)
 #define ST32(a, b) (((struct unaligned_32 *) (a))-&gt;l) = (b)
+#define ST64(a, b) (((struct unaligned_64 *) (a))-&gt;l) = (b)
 
 #else /* __GNUC__ */
 
@@ -22,44 +44,146 @@
 
 #define ST16(a, b) *((uint16_t*)(a)) = (b)
 #define ST32(a, b) *((uint32_t*)(a)) = (b)
+#define ST64(a, b) *((uint64_t*)(a)) = (b)
 
 #endif /* !__GNUC__ */
 
 /* endian macros */
-#define AV_RB8(x)  (((uint8_t*)(x))[0])
-#define AV_WB8(p, i, d)  { ((uint8_t*)(p))[(i)] = (d); }
+#define AV_RB8(x)     (((uint8_t*)(x))[0])
+#define AV_WB8(p, d)  do { ((uint8_t*)(p))[0] = (d); } while(0)
 
-#define AV_RB16(x) ((((uint8_t*)(x))[0] &lt;&lt; 8) | ((uint8_t*)(x))[1])
-#define AV_WB16(p, i, d) { \
-                    ((uint8_t*)(p))[(i)+1] = (d); \
-                    ((uint8_t*)(p))[(i)] = (d)&gt;&gt;8; }
+#define AV_RL8(x)     AV_RB8(x)
+#define AV_WL8(p, d)  AV_WB8(p, d)
 
-#define AV_RB32(x) ((((uint8_t*)(x))[0] &lt;&lt; 24) | \
-                   (((uint8_t*)(x))[1] &lt;&lt; 16) | \
-                   (((uint8_t*)(x))[2] &lt;&lt; 8) | \
-                    ((uint8_t*)(x))[3])
-#define AV_WB32(p, i, d) { \
-                    ((uint8_t*)(p))[(i)+3] = (d); \
-                    ((uint8_t*)(p))[(i)+2] = (d)&gt;&gt;8; \
-                    ((uint8_t*)(p))[(i)+1] = (d)&gt;&gt;16; \
-                    ((uint8_t*)(p))[(i)] = (d)&gt;&gt;24; }
+#ifdef HAVE_FAST_UNALIGNED
+# ifdef WORDS_BIGENDIAN
+#  define AV_RB16(x)    LD16(x)
+#  define AV_WB16(p, d) ST16(p, d)
 
-#define AV_RL8(x)  AV_RB8(x)
-#define AV_WL8(p, i, d)  AV_WB8(p, i, d)
+#  define AV_RL16(x)    bswap_16(LD16(x))
+#  define AV_WL16(p, d) ST16(p, bswap_16(d))
+# else /* WORDS_BIGENDIAN */
+#  define AV_RB16(x)    bswap_16(LD16(x))
+#  define AV_WB16(p, d) ST16(p, bswap_16(d))
 
-#define AV_RL16(x) ((((uint8_t*)(x))[1] &lt;&lt; 8) | ((uint8_t*)(x))[0])
-#define AV_WL16(p, i, d) { \
-                    ((uint8_t*)(p))[(i)] = (d); \
-                    ((uint8_t*)(p))[(i)+1] = (d)&gt;&gt;8; }
+#  define AV_RL16(x)    LD16(x)
+#  define AV_WL16(p, d) ST16(p, d)
+# endif
+#else /* HAVE_FAST_UNALIGNED */
+#define AV_RB16(x)  ((((uint8_t*)(x))[0] &lt;&lt; 8) | ((uint8_t*)(x))[1])
+#define AV_WB16(p, d) do { \
+                    ((uint8_t*)(p))[1] = (d); \
+                    ((uint8_t*)(p))[0] = (d)&gt;&gt;8; } while(0)
 
+#define AV_RL16(x)  ((((uint8_t*)(x))[1] &lt;&lt; 8) | \
+                      ((uint8_t*)(x))[0])
+#define AV_WL16(p, d) do { \
+                    ((uint8_t*)(p))[0] = (d); \
+                    ((uint8_t*)(p))[1] = (d)&gt;&gt;8; } while(0)
+#endif
+
+#define AV_RB24(x)  ((((uint8_t*)(x))[0] &lt;&lt; 16) | \
+                     (((uint8_t*)(x))[1] &lt;&lt;  8) | \
+                      ((uint8_t*)(x))[2])
+#define AV_WB24(p, d) do { \
+                    ((uint8_t*)(p))[2] = (d); \
+                    ((uint8_t*)(p))[1] = (d)&gt;&gt;8; \
+                    ((uint8_t*)(p))[0] = (d)&gt;&gt;16; } while(0)
+
+#define AV_RL24(x)  ((((uint8_t*)(x))[2] &lt;&lt; 16) | \
+                     (((uint8_t*)(x))[1] &lt;&lt;  8) | \
+                      ((uint8_t*)(x))[0])
+#define AV_WL24(p, d) do { \
+                    ((uint8_t*)(p))[0] = (d); \
+                    ((uint8_t*)(p))[1] = (d)&gt;&gt;8; \
+                    ((uint8_t*)(p))[2] = (d)&gt;&gt;16; } while(0)
+
+#ifdef HAVE_FAST_UNALIGNED
+# ifdef WORDS_BIGENDIAN
+#  define AV_RB32(x)    LD32(x)
+#  define AV_WB32(p, d) ST32(p, d)
+
+#  define AV_RL32(x)    bswap_32(LD32(x))
+#  define AV_WL32(p, d) ST32(p, bswap_32(d))
+# else /* WORDS_BIGENDIAN */
+#  define AV_RB32(x)    bswap_32(LD32(x))
+#  define AV_WB32(p, d) ST32(p, bswap_32(d))
+
+#  define AV_RL32(x)    LD32(x)
+#  define AV_WL32(p, d) ST32(p, d)
+# endif
+#else /* HAVE_FAST_UNALIGNED */
+#define AV_RB32(x)  ((((uint8_t*)(x))[0] &lt;&lt; 24) | \
+                     (((uint8_t*)(x))[1] &lt;&lt; 16) | \
+                     (((uint8_t*)(x))[2] &lt;&lt;  8) | \
+                      ((uint8_t*)(x))[3])
+#define AV_WB32(p, d) do { \
+                    ((uint8_t*)(p))[3] = (d); \
+                    ((uint8_t*)(p))[2] = (d)&gt;&gt;8; \
+                    ((uint8_t*)(p))[1] = (d)&gt;&gt;16; \
+                    ((uint8_t*)(p))[0] = (d)&gt;&gt;24; } while(0)
+
 #define AV_RL32(x) ((((uint8_t*)(x))[3] &lt;&lt; 24) | \
-                   (((uint8_t*)(x))[2] &lt;&lt; 16) | \
-                   (((uint8_t*)(x))[1] &lt;&lt; 8) | \
-                    ((uint8_t*)(x))[0])
-#define AV_WL32(p, i, d) { \
-                    ((uint8_t*)(p))[(i)] = (d); \
-                    ((uint8_t*)(p))[(i)+1] = (d)&gt;&gt;8; \
-                    ((uint8_t*)(p))[(i)+2] = (d)&gt;&gt;16; \
-                    ((uint8_t*)(p))[(i)+3] = (d)&gt;&gt;24; }
+                    (((uint8_t*)(x))[2] &lt;&lt; 16) | \
+                    (((uint8_t*)(x))[1] &lt;&lt;  8) | \
+                     ((uint8_t*)(x))[0])
+#define AV_WL32(p, d) do { \
+                    ((uint8_t*)(p))[0] = (d); \
+                    ((uint8_t*)(p))[1] = (d)&gt;&gt;8; \
+                    ((uint8_t*)(p))[2] = (d)&gt;&gt;16; \
+                    ((uint8_t*)(p))[3] = (d)&gt;&gt;24; } while(0)
+#endif
 
+#ifdef HAVE_FAST_UNALIGNED
+# ifdef WORDS_BIGENDIAN
+#  define AV_RB64(x)    LD64(x)
+#  define AV_WB64(p, d) ST64(p, d)
+
+#  define AV_RL64(x)    bswap_64(LD64(x))
+#  define AV_WL64(p, d) ST64(p, bswap_64(d))
+# else /* WORDS_BIGENDIAN */
+#  define AV_RB64(x)    bswap_64(LD64(x))
+#  define AV_WB64(p, d) ST64(p, bswap_64(d))
+
+#  define AV_RL64(x)    LD64(x)
+#  define AV_WL64(p, d) ST64(p, d)
+# endif
+#else /* HAVE_FAST_UNALIGNED */
+#define AV_RB64(x)  (((uint64_t)((uint8_t*)(x))[0] &lt;&lt; 56) | \
+                     ((uint64_t)((uint8_t*)(x))[1] &lt;&lt; 48) | \
+                     ((uint64_t)((uint8_t*)(x))[2] &lt;&lt; 40) | \
+                     ((uint64_t)((uint8_t*)(x))[3] &lt;&lt; 32) | \
+                     ((uint64_t)((uint8_t*)(x))[4] &lt;&lt; 24) | \
+                     ((uint64_t)((uint8_t*)(x))[5] &lt;&lt; 16) | \
+                     ((uint64_t)((uint8_t*)(x))[6] &lt;&lt;  8) | \
+                      (uint64_t)((uint8_t*)(x))[7])
+#define AV_WB64(p, d) do { \
+                    ((uint8_t*)(p))[7] = (d);     \
+                    ((uint8_t*)(p))[6] = (d)&gt;&gt;8;  \
+                    ((uint8_t*)(p))[5] = (d)&gt;&gt;16; \
+                    ((uint8_t*)(p))[4] = (d)&gt;&gt;24; \
+                    ((uint8_t*)(p))[3] = (d)&gt;&gt;32; \
+                    ((uint8_t*)(p))[2] = (d)&gt;&gt;40; \
+                    ((uint8_t*)(p))[1] = (d)&gt;&gt;48; \
+                    ((uint8_t*)(p))[0] = (d)&gt;&gt;56; } while(0)
+
+#define AV_RL64(x)  (((uint64_t)((uint8_t*)(x))[7] &lt;&lt; 56) | \
+                     ((uint64_t)((uint8_t*)(x))[6] &lt;&lt; 48) | \
+                     ((uint64_t)((uint8_t*)(x))[5] &lt;&lt; 40) | \
+                     ((uint64_t)((uint8_t*)(x))[4] &lt;&lt; 32) | \
+                     ((uint64_t)((uint8_t*)(x))[3] &lt;&lt; 24) | \
+                     ((uint64_t)((uint8_t*)(x))[2] &lt;&lt; 16) | \
+                     ((uint64_t)((uint8_t*)(x))[1] &lt;&lt;  8) | \
+                      (uint64_t)((uint8_t*)(x))[0])
+#define AV_WL64(p, d) do { \
+                    ((uint8_t*)(p))[0] = (d);     \
+                    ((uint8_t*)(p))[1] = (d)&gt;&gt;8;  \
+                    ((uint8_t*)(p))[2] = (d)&gt;&gt;16; \
+                    ((uint8_t*)(p))[3] = (d)&gt;&gt;24; \
+                    ((uint8_t*)(p))[4] = (d)&gt;&gt;32; \
+                    ((uint8_t*)(p))[5] = (d)&gt;&gt;40; \
+                    ((uint8_t*)(p))[6] = (d)&gt;&gt;48; \
+                    ((uint8_t*)(p))[7] = (d)&gt;&gt;56; } while(0)
+#endif
+
 #endif /* INTREADWRITE_H */

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/lls.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/lls.c	2007-07-16 17:44:22 UTC (rev 3383)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/lls.c	2007-07-16 17:45:07 UTC (rev 3384)
@@ -17,7 +17,7 @@
  *
  * You should have received a copy of the GNU Lesser General Public
  * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
 /**

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/lls.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/lls.h	2007-07-16 17:44:22 UTC (rev 3383)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/lls.h	2007-07-16 17:45:07 UTC (rev 3384)
@@ -17,7 +17,7 @@
  *
  * You should have received a copy of the GNU Lesser General Public
  * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
 #ifndef LLS_H

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/log.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/log.h	2007-07-16 17:44:22 UTC (rev 3383)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/log.h	2007-07-16 17:45:07 UTC (rev 3384)
@@ -38,14 +38,65 @@
 
 /* av_log API */
 
+#if LIBAVUTIL_VERSION_INT &lt; (50&lt;&lt;16)
 #define AV_LOG_QUIET -1
+#define AV_LOG_FATAL 0
 #define AV_LOG_ERROR 0
+#define AV_LOG_WARNING 1
 #define AV_LOG_INFO 1
+#define AV_LOG_VERBOSE 1
 #define AV_LOG_DEBUG 2
-#define AV_LOG_VERBOSE 2
+#else
+#define AV_LOG_QUIET    -8
 
+/**
+ * something went really wrong and we will crash now
+ */
+#define AV_LOG_PANIC     0
+
+/**
+ * something went wrong and recovery is not possible
+ * like no header in a format which depends on it or a combination
+ * of parameters which are not allowed
+ */
+#define AV_LOG_FATAL     8
+
+/**
+ * something went wrong and cannot losslessly be recovered
+ * but not all future data is affected
+ */
+#define AV_LOG_ERROR    16
+
+/**
+ * something somehow does not look correct / something which may or may not
+ * lead to some problems like use of -vstrict -2
+ */
+#define AV_LOG_WARNING  24
+
+#define AV_LOG_INFO     32
+#define AV_LOG_VERBOSE  40
+
+/**
+ * stuff which is only useful for libav* developers
+ */
+#define AV_LOG_DEBUG    48
+#endif
 extern int av_log_level;
 
+/**
+ * Send the specified message to the log if the level is less than or equal to
+ * the current av_log_level. By default, all logging messages are sent to
+ * stderr. This behavior can be altered by setting a different av_vlog callback
+ * function.
+ *
+ * @param avcl A pointer to an arbitrary struct of which the first field is a
+ * pointer to an AVClass struct.
+ * @param level The importance level of the message, lower values signifying
+ * higher importance.
+ * @param fmt The format string (printf-compatible) that specifies how
+ * subsequent arguments are converted to output.
+ * @see av_vlog
+ */
 #ifdef __GNUC__
 extern void av_log(void*, int level, const char *fmt, ...) __attribute__ ((__format__ (__printf__, 3, 4)));
 #else

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/md5.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/md5.c	2007-07-16 17:44:22 UTC (rev 3383)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/md5.c	2007-07-16 17:45:07 UTC (rev 3384)
@@ -2,6 +2,17 @@
  * Copyright (C) 2006 Michael Niedermayer (<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">michaelni at gmx.at</A>)
  * Copyright (C) 2003-2005 by Christopher R. Hertel (<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">crh at ubiqx.mn.org</A>)
  *
+ * References:
+ *  IETF RFC 1321: The MD5 Message-Digest Algorithm
+ *       Ron Rivest. IETF, April, 1992
+ *
+ * based on <A HREF="http://ubiqx.org/libcifs/source/Auth/MD5.c">http://ubiqx.org/libcifs/source/Auth/MD5.c</A>
+ *          from Christopher R. Hertel (<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">crh at ubiqx.mn.org</A>)
+ * Simplified, cleaned and IMO redundant comments removed by michael.
+ *
+ * If you use gcc, then version 4.1 or later and -fomit-frame-pointer is
+ * strongly recommended.
+ *
  * This file is part of FFmpeg.
  *
  * FFmpeg is free software; you can redistribute it and/or
@@ -17,17 +28,6 @@
  * You should have received a copy of the GNU Lesser General Public
  * License along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- *
- * References:
- *  IETF RFC 1321: The MD5 Message-Digest Algorithm
- *       Ron Rivest. IETF, April, 1992
- *
- * based on <A HREF="http://ubiqx.org/libcifs/source/Auth/MD5.c">http://ubiqx.org/libcifs/source/Auth/MD5.c</A>
- *          from Christopher R. Hertel (<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">crh at ubiqx.mn.org</A>)
- * simplified, cleaned and IMO redundant comments removed by michael
- *
- * if you use gcc, then version 4.1 or later and -fomit-frame-pointer is
- * strongly recommended
  */
 
 #include &quot;common.h&quot;
@@ -35,10 +35,9 @@
 #include &quot;md5.h&quot;
 
 typedef struct AVMD5{
+    uint64_t len;
     uint8_t  block[64];
     uint32_t ABCD[4];
-    uint64_t len;
-    int      b_used;
 } AVMD5;
 
 const int av_md5_size= sizeof(AVMD5);
@@ -50,7 +49,7 @@
     { 6, 10, 15, 21 }   /* Round 4 */
 };
 
-static const uint32_t T[64] = {
+static const uint32_t T[64] = { // T[i]= fabs(sin(i+1)&lt;&lt;32)
     0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee,   /* Round 1 */
     0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501,
     0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be,
@@ -76,18 +75,19 @@
         t = S[i&gt;&gt;4][i&amp;3];\
         a += T[i];\
 \
-        switch(i&gt;&gt;4){\
-        case 0: a += (d ^ (b&amp;(c^d))) + X[      i &amp;15 ]; break;\
-        case 1: a += (c ^ (d&amp;(c^b))) + X[ (1+5*i)&amp;15 ]; break;\
-        case 2: a += (b^c^d)         + X[ (5+3*i)&amp;15 ]; break;\
-        case 3: a += (c^(b|~d))      + X[ (  7*i)&amp;15 ]; break;\
+        if(i&lt;32){\
+            if(i&lt;16) a += (d ^ (b&amp;(c^d))) + X[      i &amp;15 ];\
+            else     a += (c ^ (d&amp;(c^b))) + X[ (1+5*i)&amp;15 ];\
+        }else{\
+            if(i&lt;48) a += (b^c^d)         + X[ (5+3*i)&amp;15 ];\
+            else     a += (c^(b|~d))      + X[ (  7*i)&amp;15 ];\
         }\
         a = b + (( a &lt;&lt; t ) | ( a &gt;&gt; (32 - t) ));
 
 static void body(uint32_t ABCD[4], uint32_t X[16]){
 
     int t;
-    int i attribute_unused;
+    int i av_unused;
     unsigned int a= ABCD[3];
     unsigned int b= ABCD[2];
     unsigned int c= ABCD[1];
@@ -117,7 +117,6 @@
 
 void av_md5_init(AVMD5 *ctx){
     ctx-&gt;len    = 0;
-    ctx-&gt;b_used = 0;
 
     ctx-&gt;ABCD[0] = 0x10325476;
     ctx-&gt;ABCD[1] = 0x98badcfe;
@@ -126,36 +125,30 @@
 }
 
 void av_md5_update(AVMD5 *ctx, const uint8_t *src, const int len){
-    int i;
+    int i, j;
 
+    j= ctx-&gt;len &amp; 63;
     ctx-&gt;len += len;
 
     for( i = 0; i &lt; len; i++ ){
-        ctx-&gt;block[ ctx-&gt;b_used++ ] = src[i];
-        if( 64 == ctx-&gt;b_used ){
+        ctx-&gt;block[j++] = src[i];
+        if( 64 == j ){
             body(ctx-&gt;ABCD, (uint32_t*) ctx-&gt;block);
-            ctx-&gt;b_used = 0;
+            j = 0;
         }
     }
 }
 
 void av_md5_final(AVMD5 *ctx, uint8_t *dst){
     int i;
+    uint64_t finalcount= le2me_64(ctx-&gt;len&lt;&lt;3);
 
-    ctx-&gt;block[ctx-&gt;b_used++] = 0x80;
+    av_md5_update(ctx, &quot;\200&quot;, 1);
+    while((ctx-&gt;len &amp; 63)&lt;56)
+        av_md5_update(ctx, &quot;&quot;, 1);
 
-    memset(&amp;ctx-&gt;block[ctx-&gt;b_used], 0, 64 - ctx-&gt;b_used);
+    av_md5_update(ctx, &amp;finalcount, 8);
 
-    if( 56 &lt; ctx-&gt;b_used ){
-        body( ctx-&gt;ABCD, (uint32_t*) ctx-&gt;block );
-        memset(ctx-&gt;block, 0, 64);
-    }
-
-    for(i=0; i&lt;8; i++)
-        ctx-&gt;block[56+i] = (ctx-&gt;len &lt;&lt; 3) &gt;&gt; (i&lt;&lt;3);
-
-    body(ctx-&gt;ABCD, (uint32_t*) ctx-&gt;block);
-
     for(i=0; i&lt;4; i++)
         ((uint32_t*)dst)[i]= le2me_32(ctx-&gt;ABCD[3-i]);
 }
@@ -170,6 +163,7 @@
 
 #ifdef TEST
 #include &lt;stdio.h&gt;
+#undef printf
 main(){
     uint64_t md5val;
     int i;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/md5.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/md5.h	2007-07-16 17:44:22 UTC (rev 3383)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/md5.h	2007-07-16 17:45:07 UTC (rev 3384)
@@ -21,6 +21,8 @@
 #ifndef MD5_H
 #define MD5_H
 
+#include &lt;stdint.h&gt;
+
 extern const int av_md5_size;
 
 struct AVMD5;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/mem.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/mem.c	2007-07-16 17:44:22 UTC (rev 3383)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/mem.c	2007-07-16 17:45:07 UTC (rev 3384)
@@ -26,7 +26,7 @@
 
 #include &quot;common.h&quot;
 
-/* here we can use OS dependant allocation functions */
+/* here we can use OS dependent allocation functions */
 #undef malloc
 #undef free
 #undef realloc
@@ -39,11 +39,6 @@
    memory allocator. You do not need to suppress this file because the
    linker will do it automatically */
 
-/**
- * Memory allocation of size byte with alignment suitable for all
- * memory accesses (including vectors if available on the
- * CPU). av_malloc(0) must return a non NULL pointer.
- */
 void *av_malloc(unsigned int size)
 {
     void *ptr;
@@ -96,11 +91,6 @@
     return ptr;
 }
 
-/**
- * av_realloc semantics (same as glibc): if ptr is NULL and size &gt; 0,
- * identical to malloc(size). If size is zero, it is identical to
- * free(ptr) and NULL is returned.
- */
 void *av_realloc(void *ptr, unsigned int size)
 {
 #ifdef CONFIG_MEMALIGN_HACK
@@ -121,11 +111,6 @@
 #endif
 }
 
-/**
- * Free memory which has been allocated with av_malloc(z)() or av_realloc().
- * NOTE: ptr = NULL is explicetly allowed
- * Note2: it is recommended that you use av_freep() instead
- */
 void av_free(void *ptr)
 {
     /* XXX: this test should not be needed on most libcs */
@@ -137,10 +122,6 @@
 #endif
 }
 
-/**
- * Frees memory and sets the pointer to NULL.
- * @param arg pointer to the pointer which should be freed
- */
 void av_freep(void *arg)
 {
     void **ptr= (void**)arg;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/rational.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/rational.c	2007-07-16 17:44:22 UTC (rev 3383)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/rational.c	2007-07-16 17:45:07 UTC (rev 3384)
@@ -17,7 +17,6 @@
  * You should have received a copy of the GNU Lesser General Public
  * License along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- *
  */
 
 /**
@@ -75,40 +74,24 @@
     return den==0;
 }
 
-/**
- * returns b*c.
- */
 AVRational av_mul_q(AVRational b, AVRational c){
     av_reduce(&amp;b.num, &amp;b.den, b.num * (int64_t)c.num, b.den * (int64_t)c.den, INT_MAX);
     return b;
 }
 
-/**
- * returns b/c.
- */
 AVRational av_div_q(AVRational b, AVRational c){
     return av_mul_q(b, (AVRational){c.den, c.num});
 }
 
-/**
- * returns b+c.
- */
 AVRational av_add_q(AVRational b, AVRational c){
     av_reduce(&amp;b.num, &amp;b.den, b.num * (int64_t)c.den + c.num * (int64_t)b.den, b.den * (int64_t)c.den, INT_MAX);
     return b;
 }
 
-/**
- * returns b-c.
- */
 AVRational av_sub_q(AVRational b, AVRational c){
     return av_add_q(b, (AVRational){-c.num, c.den});
 }
 
-/**
- * Converts a double precission floating point number to a AVRational.
- * @param max the maximum allowed numerator and denominator
- */
 AVRational av_d2q(double d, int max){
     AVRational a;
 #define LOG2  0.69314718055994530941723212145817656807550013436025

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/rational.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/rational.h	2007-07-16 17:44:22 UTC (rev 3383)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/rational.h	2007-07-16 17:45:07 UTC (rev 3384)
@@ -17,7 +17,6 @@
  * You should have received a copy of the GNU Lesser General Public
  * License along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- *
  */
 
 /**
@@ -29,6 +28,8 @@
 #ifndef RATIONAL_H
 #define RATIONAL_H
 
+#include &lt;stdint.h&gt;
+
 /**
  * Rational number num/den.
  */
@@ -38,7 +39,10 @@
 } AVRational;
 
 /**
- * returns 0 if a==b, 1 if a&gt;b and -1 if a&lt;b.
+ * Compare two rationals.
+ * @param a first rational
+ * @param b second rational
+ * @return 0 if a==b, 1 if a&gt;b and -1 if a&lt;b.
  */
 static inline int av_cmp_q(AVRational a, AVRational b){
     const int64_t tmp= a.num * (int64_t)b.den - b.num * (int64_t)a.den;
@@ -48,24 +52,64 @@
 }
 
 /**
- * converts the given AVRational to a double.
+ * Rational to double conversion.
+ * @param a rational to convert
+ * @return (double) a
  */
 static inline double av_q2d(AVRational a){
     return a.num / (double) a.den;
 }
 
 /**
- * reduce a fraction.
- * this is usefull for framerate calculations
+ * Reduce a fraction.
+ * This is useful for framerate calculations.
+ * @param dst_nom destination numerator
+ * @param dst_den destination denominator
+ * @param nom source numerator
+ * @param den source denominator
  * @param max the maximum allowed for dst_nom &amp; dst_den
  * @return 1 if exact, 0 otherwise
  */
 int av_reduce(int *dst_nom, int *dst_den, int64_t nom, int64_t den, int64_t max);
 
+/**
+ * Multiplies two rationals.
+ * @param b first rational.
+ * @param c second rational.
+ * @return b*c.
+ */
 AVRational av_mul_q(AVRational b, AVRational c);
+
+/**
+ * Divides one rational by another.
+ * @param b first rational.
+ * @param c second rational.
+ * @return b/c.
+ */
 AVRational av_div_q(AVRational b, AVRational c);
+
+/**
+ * Adds two rationals.
+ * @param b first rational.
+ * @param c second rational.
+ * @return b+c.
+ */
 AVRational av_add_q(AVRational b, AVRational c);
+
+/**
+ * Subtracts one rational from another.
+ * @param b first rational.
+ * @param c second rational.
+ * @return b-c.
+ */
 AVRational av_sub_q(AVRational b, AVRational c);
+
+/**
+ * Converts a double precision floating point number to a rational.
+ * @param d double to convert
+ * @param max the maximum allowed numerator and denominator
+ * @return (AVRational) d.
+ */
 AVRational av_d2q(double d, int max);
 
 #endif // RATIONAL_H

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/x86_cpu.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/x86_cpu.h	2007-07-16 17:44:22 UTC (rev 3383)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/x86_cpu.h	2007-07-16 17:45:07 UTC (rev 3384)
@@ -57,4 +57,12 @@
 #  define REGSP   esp
 #endif
 
+#if defined(ARCH_X86_64) || (defined(ARCH_X86_32) &amp;&amp; defined(HAVE_EBX_AVAILABLE) &amp;&amp; defined(HAVE_EBP_AVAILABLE))
+#  define CONFIG_7REGS 1
+#endif
+
+#if defined(ARCH_X86_64) &amp;&amp; defined(PIC)
+#  define BROKEN_RELOCATIONS 1
+#endif
+
 #endif /* AVUTIL_X86CPU_H */


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000660.html">[Avidemux-svn-commit] r3383 -	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat
</A></li>
	<LI>Next message: <A HREF="000662.html">[Avidemux-svn-commit] r3386 - in	branches/avidemux_2.4_branch/avidemux/ADM_libraries:	ADM_lavcodec ADM_lavutil
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#661">[ date ]</a>
              <a href="thread.html#661">[ thread ]</a>
              <a href="subject.html#661">[ subject ]</a>
              <a href="author.html#661">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
