<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r3386 - in	branches/avidemux_2.4_branch/avidemux/ADM_libraries:	ADM_lavcodec ADM_lavutil
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2007-July/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r3386%20-%20in%0A%09branches/avidemux_2.4_branch/avidemux/ADM_libraries%3A%0A%09ADM_lavcodec%20ADM_lavutil&In-Reply-To=%3C200707161753.l6GHr50f008669%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000661.html">
   <LINK REL="Next"  HREF="000663.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r3386 - in	branches/avidemux_2.4_branch/avidemux/ADM_libraries:	ADM_lavcodec ADM_lavutil</H1>
    <B>mean at BerliOS</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r3386%20-%20in%0A%09branches/avidemux_2.4_branch/avidemux/ADM_libraries%3A%0A%09ADM_lavcodec%20ADM_lavutil&In-Reply-To=%3C200707161753.l6GHr50f008669%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r3386 - in	branches/avidemux_2.4_branch/avidemux/ADM_libraries:	ADM_lavcodec ADM_lavutil">mean at mail.berlios.de
       </A><BR>
    <I>Mon Jul 16 19:53:05 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000661.html">[Avidemux-svn-commit] r3384 -	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil
</A></li>
        <LI>Next message: <A HREF="000663.html">[Avidemux-svn-commit] r3387 -	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#662">[ date ]</a>
              <a href="thread.html#662">[ thread ]</a>
              <a href="subject.html#662">[ subject ]</a>
              <a href="author.html#662">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2007-07-16 19:53:04 +0200 (Mon, 16 Jul 2007)
New Revision: 3386

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/dnxhddata.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/dnxhddec.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/fraps.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/string.c
Log:
[LAV] Missing files

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/dnxhddata.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/dnxhddata.h	2007-07-16 17:46:57 UTC (rev 3385)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/dnxhddata.h	2007-07-16 17:53:04 UTC (rev 3386)
@@ -0,0 +1,113 @@
+/*
+ * VC3/DNxHD decoder.
+ * Copyright (c) 2007 SmartJog S.A., Baptiste Coudurier &lt;baptiste dot coudurier at smartjog dot com&gt;.
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_DNXHDDATA_H
+#define AVCODEC_DNXHDDATA_H
+
+#include &lt;stdint.h&gt;
+
+static const uint8_t dnxhd_1238_luma_weigth[] = {
+     0, 32, 32, 33, 34, 33, 33, 33,
+    33, 33, 33, 33, 33, 35, 37, 37,
+    36, 36, 35, 36, 38, 38, 36, 35,
+    36, 37, 38, 41, 42, 41, 39, 38,
+    38, 38, 39, 41, 42, 41, 39, 39,
+    40, 41, 43, 44, 44, 44, 44, 44,
+    45, 47, 47, 47, 49, 50, 51, 51,
+    51, 53, 55, 57, 58, 59, 57, 57,
+};
+
+static const uint8_t dnxhd_1238_chroma_weigth[] = {
+     0, 32, 35, 35, 35, 34, 34, 35,
+    39, 43, 45, 45, 41, 39, 40, 41,
+    42, 44, 48, 55, 59, 63, 65, 59,
+    53, 52, 52, 55, 61, 62, 58, 58,
+    63, 66, 66, 65, 70, 74, 70, 66,
+    65, 68, 75, 77, 74, 74, 77, 76,
+    73, 73, 73, 73, 76, 80, 89, 90,
+    82, 77, 80, 86, 84, 82, 82, 82,
+};
+
+/* FIXME permute */
+static const uint8_t dnxhd_1243_luma_weigth[] = {
+     0,32,35,35,38,40,44,45,
+    32,33,35,35,39,42,44,45,
+    33,35,34,37,41,42,45,45,
+    35,35,37,40,41,44,45,48,
+    35,37,38,40,43,45,47,48,
+    36,36,38,40,45,47,48,47,
+    35,36,38,41,45,46,47,48,
+    36,37,39,41,44,45,47,47,
+};
+
+/* FIXME permute */
+static const uint8_t dnxhd_1243_chroma_weigth[] = {
+     0,32,37,39,41,42,45,45,
+    36,36,39,41,43,45,46,45,
+    37,41,41,43,45,44,45,46,
+    43,42,43,46,44,45,46,48,
+    43,44,47,45,44,46,47,49,
+    44,46,44,45,45,47,48,47,
+    44,42,46,44,45,46,47,48,
+    41,43,45,44,45,46,47,47,
+};
+
+static const uint8_t dnxhd_1238_dc_codes[12] = {
+    0, 12, 13, 1, 2, 3, 4, 5, 14, 30, 62, 63,
+};
+
+static const uint8_t dnxhd_1238_dc_bits[12] = {
+    3, 4, 4, 3, 3, 3, 3, 3, 4, 5, 6, 6,
+};
+
+static const uint16_t dnxhd_1238_ac_codes[257] = {
+    0, 1, 4, 10, 11, 24, 25, 26, 54, 55, 56, 57, 116, 117, 118, 119, 240, 241, 242, 243, 244, 245, 492, 493, 494, 495, 496, 497, 498, 499, 1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025, 2026, 2027, 4056, 4057, 4058, 4059, 4060, 4061, 4062, 4063, 4064, 4065, 4066, 4067, 4068, 4069, 8140, 8141, 8142, 8143, 8144, 8145, 8146, 8147, 8148, 8149, 8150, 8151, 8152, 8153, 8154, 8155, 8156, 16314, 16315, 16316, 16317, 16318, 16319, 16320, 16321, 16322, 16323, 16324, 16325, 16326, 16327, 16328, 16329, 16330, 16331, 16332, 16333, 16334, 16335, 16336, 16337, 16338, 32678, 32679, 32680, 32681, 32682, 32683, 32684, 32685, 32686, 32687, 32688, 32689, 32690, 32691, 32692, 32693, 32694, 32695, 32696, 32697, 32698, 32699, 32700, 32701, 32702, 32703, 32704, 32705, 65412, 65413, 65414, 65415, 65416, 65417, 65418, 65419, 65420, 65421, 65422, 65423, 65424, 65425, 65426, 65427, 65428, 65429, 65430, 65431, 65432, 65433, 65434, 65435, 65436, 654!
 37, 65438, 65439, 65440, 65441, 65442, 65443, 65444, 65445, 65446, 65447, 65448, 65449, 65450, 65451, 65452, 65453, 65454, 65455, 65456, 65457, 65458, 65459, 65460, 65461, 65462, 65463, 65464, 65465, 65466, 65467, 65468, 65469, 65470, 65471, 65472, 65473, 65474, 65475, 65476, 65477, 65478, 65479, 65480, 65481, 65482, 65483, 65484, 65485, 65486, 65487, 65488, 65489, 65490, 65491, 65492, 65493, 65494, 65495, 65496, 65497, 65498, 65499, 65500, 65501, 65502, 65503, 65504, 65505, 65506, 65507, 65508, 65509, 65510, 65511, 65512, 65513, 65514, 65515, 65516, 65517, 65518, 65519, 65520, 65521, 65522, 65523, 65524, 65525, 65526, 65527, 65528, 65529, 65530, 65531, 65532, 65533, 65534, 65535,
+};
+
+static const uint8_t dnxhd_1238_ac_bits[257] = {
+    2, 2, 3, 4, 4, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16!
 , 16, 16, 16,
+};
+
+static const uint8_t dnxhd_1238_ac_level[257] = {
+    1, 1, 2, 3, 0, 4, 5, 2, 6, 7, 8, 3, 9, 10, 11, 4, 12, 13, 14, 15, 16, 5, 17, 18, 19, 20, 21, 22, 6, 7, 23, 24, 25, 26, 27, 28, 29, 8, 9, 30, 31, 32, 33, 34, 35, 36, 37, 10, 11, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 12, 13, 14, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 15, 16, 17, 18, 62, 63, 64, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 19, 20, 21, 22, 23, 24, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 40, 25, 26, 27, 28, 29, 30, 38, 39, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 6!
 3, 64,
+}; /* 0 is EOB */
+
+static const uint8_t dnxhd_1238_ac_run_flag[257] = {
+    0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+};
+
+static const uint8_t dnxhd_1238_ac_index_flag[257] = {
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+};
+
+static const uint16_t dnxhd_1238_run_codes[62] = {
+    0, 4, 10, 11, 24, 25, 26, 27, 56, 57, 58, 59, 120, 242, 486, 487, 488, 489, 980, 981, 982, 983, 984, 985, 986, 987, 988, 989, 990, 991, 992, 993, 994, 995, 996, 997, 998, 999, 1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023,
+};
+
+static const uint8_t dnxhd_1238_run_bits[62] = {
+    1, 3, 4, 4, 5, 5, 5, 5, 6, 6, 6, 6, 7, 8, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
+};
+
+static const uint8_t dnxhd_1238_run[62] = {
+    1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 20, 21, 17, 18, 19, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
+};
+
+#endif  // AVCODEC_DNXHDDATA_H

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/dnxhddec.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/dnxhddec.c	2007-07-16 17:46:57 UTC (rev 3385)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/dnxhddec.c	2007-07-16 17:53:04 UTC (rev 3386)
@@ -0,0 +1,368 @@
+/*
+ * VC3/DNxHD decoder.
+ * Copyright (c) 2007 SmartJog S.A., Baptiste Coudurier &lt;baptiste dot coudurier at smartjog dot com&gt;.
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+//#define TRACE
+//#define DEBUG
+
+#include &quot;avcodec.h&quot;
+#include &quot;bitstream.h&quot;
+#include &quot;dnxhddata.h&quot;
+#include &quot;dsputil.h&quot;
+#include &quot;mpegvideo.h&quot;
+
+typedef struct {
+    int cid;
+    unsigned int width, height;
+    int interlaced;
+    unsigned int frame_size;
+    int index_bits;
+    int bit_depth;
+    const uint8_t *luma_weigth, *chroma_weigth;
+    const uint8_t *dc_codes, *dc_bits;
+    const uint16_t *ac_codes;
+    const uint8_t *ac_bits, *ac_level;
+    const uint8_t *ac_run_flag, *ac_index_flag;
+    const uint16_t *run_codes;
+    const uint8_t *run_bits, *run;
+} CIDEntry;
+
+typedef struct {
+    AVCodecContext *avctx;
+    AVFrame picture;
+    GetBitContext gb;
+    int cid;                            ///&lt; compression id
+    unsigned int width, height;
+    unsigned int mb_width, mb_height;
+    uint32_t mb_scan_index[68];         /* max for 1080p */
+    int cur_field;                      ///&lt; current interlaced field
+    int index_bits;                     ///&lt; length of index value
+    VLC ac_vlc, dc_vlc, run_vlc;
+    const uint8_t *ac_level, *run;
+    const uint8_t *ac_run_flag, *ac_index_flag;
+    const uint8_t *luma_weigth, *chroma_weigth;
+    int last_dc[3];
+    DSPContext dsp;
+    DECLARE_ALIGNED_16(DCTELEM, blocks[8][64]);
+    DECLARE_ALIGNED_8(ScanTable, scantable);
+    const CIDEntry *cid_table;
+} DNXHDContext;
+
+static const CIDEntry cid_table[] = {
+    { 1238, 1920, 1080, 0, 917504, 4, 8,
+      dnxhd_1238_luma_weigth, dnxhd_1238_chroma_weigth,
+      dnxhd_1238_dc_codes, dnxhd_1238_dc_bits,
+      dnxhd_1238_ac_codes, dnxhd_1238_ac_bits, dnxhd_1238_ac_level,
+      dnxhd_1238_ac_run_flag, dnxhd_1238_ac_index_flag,
+      dnxhd_1238_run_codes, dnxhd_1238_run_bits, dnxhd_1238_run },
+/*     { 1243, 1920, 1080, 1, 917504, 4, 8, */
+/*       dnxhd_1243_luma_weigth, dnxhd_1243_chroma_weigth, */
+/*       dnxhd_1238_dc_codes, dnxhd_1238_dc_bits, */
+/*       dnxhd_1238_ac_codes, dnxhd_1238_ac_bits, dnxhd_1238_ac_level, */
+/*       dnxhd_1238_ac_run_flag, dnxhd_1238_ac_index_flag, */
+/*       dnxhd_1238_run_codes, dnxhd_1238_run_bits, dnxhd_1238_run }, */
+};
+
+static int dnxhd_get_cid_table(int cid)
+{
+    int i;
+    for (i = 0; i &lt; sizeof(cid_table)/sizeof(CIDEntry); i++)
+        if (cid_table[i].cid == cid)
+            return i;
+    return -1;
+}
+
+#define DNXHD_VLC_BITS 9
+#define DNXHD_DC_VLC_BITS 6
+
+static int dnxhd_decode_init(AVCodecContext *avctx)
+{
+    DNXHDContext *ctx = avctx-&gt;priv_data;
+
+    ctx-&gt;avctx = avctx;
+    dsputil_init(&amp;ctx-&gt;dsp, avctx);
+    avctx-&gt;coded_frame = &amp;ctx-&gt;picture;
+    ctx-&gt;picture.type = FF_I_TYPE;
+    return 0;
+}
+
+static int dnxhd_init_vlc(DNXHDContext *ctx, int cid)
+{
+    if (!ctx-&gt;cid_table) {
+        int index;
+
+        if ((index = dnxhd_get_cid_table(cid)) &lt; 0) {
+            av_log(ctx-&gt;avctx, AV_LOG_ERROR, &quot;unsupported cid %d\n&quot;, cid);
+            return -1;
+        }
+        ctx-&gt;cid_table = &amp;cid_table[index];
+        init_vlc(&amp;ctx-&gt;ac_vlc, DNXHD_VLC_BITS, 257,
+                 cid_table-&gt;ac_bits, 1, 1,
+                 cid_table-&gt;ac_codes, 2, 2, 0);
+        init_vlc(&amp;ctx-&gt;dc_vlc, DNXHD_DC_VLC_BITS, 12,
+                 cid_table-&gt;dc_bits, 1, 1,
+                 cid_table-&gt;dc_codes, 1, 1, 0);
+        init_vlc(&amp;ctx-&gt;run_vlc, DNXHD_VLC_BITS, 62,
+                 cid_table-&gt;run_bits, 1, 1,
+                 cid_table-&gt;run_codes, 2, 2, 0);
+
+        ctx-&gt;run           = cid_table-&gt;run;
+        ctx-&gt;ac_level      = cid_table-&gt;ac_level;
+        ctx-&gt;ac_run_flag   = cid_table-&gt;ac_run_flag;
+        ctx-&gt;ac_index_flag = cid_table-&gt;ac_index_flag;
+        ctx-&gt;luma_weigth   = cid_table-&gt;luma_weigth;
+        ctx-&gt;chroma_weigth = cid_table-&gt;chroma_weigth;
+
+        ctx-&gt;index_bits = cid_table-&gt;index_bits;
+
+        ff_init_scantable(ctx-&gt;dsp.idct_permutation, &amp;ctx-&gt;scantable, ff_zigzag_direct);
+    }
+    return 0;
+}
+
+static int dnxhd_decode_header(DNXHDContext *ctx, uint8_t *buf, int buf_size)
+{
+    static const uint8_t header_prefix[] = { 0x00, 0x00, 0x02, 0x80, 0x01 };
+    int i;
+
+    if (buf_size &lt; 0x280)
+        return -1;
+
+    if (memcmp(buf, header_prefix, 5)) {
+        av_log(ctx-&gt;avctx, AV_LOG_ERROR, &quot;error in header\n&quot;);
+        return -1;
+    }
+    if (buf[5] &amp; 2) {/* interlaced FIXME top or bottom */
+        ctx-&gt;picture.interlaced_frame = 1;
+        av_log(ctx-&gt;avctx, AV_LOG_DEBUG, &quot;interlaced %d\n&quot;, buf[5] &amp; 3);
+    }
+
+    ctx-&gt;height = AV_RB16(buf + 0x18);
+    ctx-&gt;width  = AV_RB16(buf + 0x1a);
+
+    dprintf(ctx-&gt;avctx, &quot;width %d, heigth %d\n&quot;, ctx-&gt;width, ctx-&gt;height);
+
+    if (buf[0x21] &amp; 0x80) {
+        av_log(ctx-&gt;avctx, AV_LOG_ERROR, &quot;10 bit per component\n&quot;);
+        return -1;
+    }
+
+    ctx-&gt;cid = AV_RB32(buf + 0x28);
+    dprintf(ctx-&gt;avctx, &quot;compression id %d\n&quot;, ctx-&gt;cid);
+
+    if (dnxhd_init_vlc(ctx, ctx-&gt;cid) &lt; 0)
+        return -1;
+
+    if (buf_size &lt; ctx-&gt;cid_table-&gt;frame_size) {
+        av_log(ctx-&gt;avctx, AV_LOG_ERROR, &quot;incorrect frame size\n&quot;);
+        return -1;
+    }
+
+    ctx-&gt;mb_width = ctx-&gt;width&gt;&gt;4;
+    ctx-&gt;mb_height = buf[0x16d];
+
+    if (ctx-&gt;mb_height &gt; 68) {
+        av_log(ctx-&gt;avctx, AV_LOG_ERROR, &quot;mb height too big\n&quot;);
+        return -1;
+    }
+
+    dprintf(ctx-&gt;avctx, &quot;mb width %d, mb height %d\n&quot;, ctx-&gt;mb_width, ctx-&gt;mb_height);
+    for (i = 0; i &lt; ctx-&gt;mb_height; i++) {
+        ctx-&gt;mb_scan_index[i] = AV_RB32(buf + 0x170 + (i&lt;&lt;2));
+        dprintf(ctx-&gt;avctx, &quot;mb scan index %d\n&quot;, ctx-&gt;mb_scan_index[i]);
+        if (buf_size &lt; ctx-&gt;mb_scan_index[i] + 0x280) {
+            av_log(ctx-&gt;avctx, AV_LOG_ERROR, &quot;invalid mb scan index\n&quot;);
+            return -1;
+        }
+    }
+
+    return 0;
+}
+
+static int dnxhd_decode_dc(DNXHDContext *ctx)
+{
+    int len;
+
+    len = get_vlc2(&amp;ctx-&gt;gb, ctx-&gt;dc_vlc.table, DNXHD_DC_VLC_BITS, 1);
+    return len ? get_xbits(&amp;ctx-&gt;gb, len) : 0;
+}
+
+static void dnxhd_decode_dct_block(DNXHDContext *ctx, DCTELEM *block, int n, int qscale)
+{
+    int i, j, index, index2;
+    int level, component, sign;
+    const uint8_t *weigth_matrix;
+
+    if (n&amp;2) {
+        component = 1 + (n&amp;1);
+        weigth_matrix = ctx-&gt;chroma_weigth;
+    } else {
+        component = 0;
+        weigth_matrix = ctx-&gt;luma_weigth;
+    }
+
+    ctx-&gt;last_dc[component] += dnxhd_decode_dc(ctx);
+    block[0] = ctx-&gt;last_dc[component];
+    //av_log(ctx-&gt;avctx, AV_LOG_DEBUG, &quot;dc %d\n&quot;, block[0]);
+    for (i = 1; ; i++) {
+        index = get_vlc2(&amp;ctx-&gt;gb, ctx-&gt;ac_vlc.table, DNXHD_VLC_BITS, 2);
+        //av_log(ctx-&gt;avctx, AV_LOG_DEBUG, &quot;index %d\n&quot;, index);
+        level = ctx-&gt;ac_level[index];
+        if (!level) { /* EOB */
+            //av_log(ctx-&gt;avctx, AV_LOG_DEBUG, &quot;EOB\n&quot;);
+            return;
+        }
+        sign = get_sbits(&amp;ctx-&gt;gb, 1);
+
+        if (ctx-&gt;ac_index_flag[index]) {
+            level += get_bits(&amp;ctx-&gt;gb, ctx-&gt;index_bits)&lt;&lt;6;
+        }
+
+        if (ctx-&gt;ac_run_flag[index]) {
+            index2 = get_vlc2(&amp;ctx-&gt;gb, ctx-&gt;run_vlc.table, DNXHD_VLC_BITS, 2);
+            i += ctx-&gt;run[index2];
+        }
+
+        j = ctx-&gt;scantable.permutated[i];
+        //av_log(ctx-&gt;avctx, AV_LOG_DEBUG, &quot;j %d\n&quot;, j);
+        //av_log(ctx-&gt;avctx, AV_LOG_DEBUG, &quot;level %d, weigth %d\n&quot;, level, weigth_matrix[i]);
+        level = (2*level+1) * qscale * weigth_matrix[i];
+        if (weigth_matrix[i] != 32) // FIXME 10bit
+            level += 32;
+        level &gt;&gt;= 6;
+        level = (level^sign) - sign;
+
+        if (i &gt; 63) {
+            av_log(ctx-&gt;avctx, AV_LOG_ERROR, &quot;ac tex damaged %d, %d\n&quot;, n, i);
+            return;
+        }
+
+        //av_log(NULL, AV_LOG_DEBUG, &quot;i %d, j %d, end level %d\n&quot;, i, j, level);
+        block[j] = level;
+    }
+}
+
+static int dnxhd_decode_macroblock(DNXHDContext *ctx, int x, int y)
+{
+    int dct_linesize_luma   = ctx-&gt;picture.linesize[0];
+    int dct_linesize_chroma = ctx-&gt;picture.linesize[1];
+    uint8_t *dest_y, *dest_u, *dest_v;
+    int dct_offset;
+    int qscale, i;
+
+    ctx-&gt;dsp.clear_blocks(ctx-&gt;blocks[0]);
+    ctx-&gt;dsp.clear_blocks(ctx-&gt;blocks[2]); // FIXME change clear blocks to take block amount
+
+    qscale = get_bits(&amp;ctx-&gt;gb, 11);
+    skip_bits1(&amp;ctx-&gt;gb);
+    //av_log(ctx-&gt;avctx, AV_LOG_DEBUG, &quot;qscale %d\n&quot;, qscale);
+
+    for (i = 0; i &lt; 8; i++) {
+        dnxhd_decode_dct_block(ctx, ctx-&gt;blocks[i], i, qscale);
+    }
+    dest_y = ctx-&gt;picture.data[0] + ((y * dct_linesize_luma)   &lt;&lt; 4) + (x &lt;&lt; 4);
+    dest_u = ctx-&gt;picture.data[1] + ((y * dct_linesize_chroma) &lt;&lt; 4) + (x &lt;&lt; 3);
+    dest_v = ctx-&gt;picture.data[2] + ((y * dct_linesize_chroma) &lt;&lt; 4) + (x &lt;&lt; 3);
+
+    dct_offset = dct_linesize_luma &lt;&lt; 3;
+    ctx-&gt;dsp.idct_put(dest_y,                  dct_linesize_luma, ctx-&gt;blocks[0]);
+    ctx-&gt;dsp.idct_put(dest_y + 8,              dct_linesize_luma, ctx-&gt;blocks[1]);
+    ctx-&gt;dsp.idct_put(dest_y + dct_offset,     dct_linesize_luma, ctx-&gt;blocks[4]);
+    ctx-&gt;dsp.idct_put(dest_y + dct_offset + 8, dct_linesize_luma, ctx-&gt;blocks[5]);
+
+    if (!(ctx-&gt;avctx-&gt;flags &amp; CODEC_FLAG_GRAY)) {
+        dct_offset = dct_linesize_chroma &lt;&lt; 3;
+        ctx-&gt;dsp.idct_put(dest_u,              dct_linesize_chroma, ctx-&gt;blocks[2]);
+        ctx-&gt;dsp.idct_put(dest_v,              dct_linesize_chroma, ctx-&gt;blocks[3]);
+        ctx-&gt;dsp.idct_put(dest_u + dct_offset, dct_linesize_chroma, ctx-&gt;blocks[6]);
+        ctx-&gt;dsp.idct_put(dest_v + dct_offset, dct_linesize_chroma, ctx-&gt;blocks[7]);
+    }
+
+    return 0;
+}
+
+static int dnxhd_decode_macroblocks(DNXHDContext *ctx, uint8_t *buf, int buf_size)
+{
+    int x, y;
+    for (y = 0; y &lt; ctx-&gt;mb_height; y++) {
+        memset(ctx-&gt;last_dc, 4, sizeof(ctx-&gt;last_dc)); // 4 for levels +128
+        init_get_bits(&amp;ctx-&gt;gb, buf + ctx-&gt;mb_scan_index[y], (buf_size - ctx-&gt;mb_scan_index[y]) &lt;&lt; 3);
+        for (x = 0; x &lt; ctx-&gt;mb_width; x++) {
+            //START_TIMER;
+            dnxhd_decode_macroblock(ctx, x, y);
+            //STOP_TIMER(&quot;decode macroblock&quot;);
+        }
+    }
+    return 0;
+}
+
+static int dnxhd_decode_frame(AVCodecContext *avctx, void *data, int *data_size,
+                              uint8_t *buf, int buf_size)
+{
+    DNXHDContext *ctx = avctx-&gt;priv_data;
+    AVFrame *picture = data;
+
+    dprintf(avctx, &quot;frame size %d\n&quot;, buf_size);
+
+    if (dnxhd_decode_header(ctx, buf, buf_size) &lt; 0)
+        return -1;
+
+    avctx-&gt;pix_fmt = PIX_FMT_YUV422P;
+    if (avcodec_check_dimensions(avctx, ctx-&gt;width, ctx-&gt;height))
+        return -1;
+    avcodec_set_dimensions(avctx, ctx-&gt;width, ctx-&gt;height);
+
+    if (ctx-&gt;picture.data[0])
+        avctx-&gt;release_buffer(avctx, &amp;ctx-&gt;picture);
+    if (avctx-&gt;get_buffer(avctx, &amp;ctx-&gt;picture) &lt; 0) {
+        av_log(avctx, AV_LOG_ERROR, &quot;get_buffer() failed\n&quot;);
+        return -1;
+    }
+
+    dnxhd_decode_macroblocks(ctx, buf + 0x280, buf_size - 0x280);
+
+    *picture = ctx-&gt;picture;
+    *data_size = sizeof(AVPicture);
+    return buf_size;
+}
+
+static int dnxhd_decode_close(AVCodecContext *avctx)
+{
+    DNXHDContext *ctx = avctx-&gt;priv_data;
+
+    if(ctx-&gt;picture.data[0])
+        avctx-&gt;release_buffer(avctx, &amp;ctx-&gt;picture);
+    free_vlc(&amp;ctx-&gt;ac_vlc);
+    free_vlc(&amp;ctx-&gt;dc_vlc);
+    free_vlc(&amp;ctx-&gt;run_vlc);
+    return 0;
+}
+
+AVCodec dnxhd_decoder = {
+    &quot;dnxhd&quot;,
+    CODEC_TYPE_VIDEO,
+    CODEC_ID_DNXHD,
+    sizeof(DNXHDContext),
+    dnxhd_decode_init,
+    NULL,
+    dnxhd_decode_close,
+    dnxhd_decode_frame,
+    CODEC_CAP_DR1,
+};

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/fraps.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/fraps.c	2007-07-16 17:46:57 UTC (rev 3385)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/fraps.c	2007-07-16 17:53:04 UTC (rev 3386)
@@ -0,0 +1,397 @@
+/*
+ * Fraps FPS1 decoder
+ * Copyright (c) 2005 Roine Gustafsson
+ * Copyright (c) 2006 Konstantin Shishkov
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file fraps.c
+ * Lossless Fraps 'FPS1' decoder
+ * @author Roine Gustafsson &lt;roine at users sf net&gt;
+ * @author Konstantin Shishkov
+ *
+ * Codec algorithm for version 0 is taken from Transcode &lt;www.transcoding.org&gt;
+ *
+ * Version 2 files support by Konstantin Shishkov
+ */
+
+#include &quot;avcodec.h&quot;
+#include &quot;bitstream.h&quot;
+#include &quot;dsputil.h&quot;
+
+#define FPS_TAG MKTAG('F', 'P', 'S', 'x')
+
+/* symbol for Huffman tree node */
+#define HNODE -1
+
+/**
+ * Huffman node
+ * FIXME one day this should belong to one general framework
+ */
+typedef struct Node{
+    int16_t sym;
+    int16_t n0;
+    int count;
+}Node;
+
+/**
+ * local variable storage
+ */
+typedef struct FrapsContext{
+    AVCodecContext *avctx;
+    AVFrame frame;
+    Node nodes[512];
+    uint8_t *tmpbuf;
+    DSPContext dsp;
+} FrapsContext;
+
+
+/**
+ * initializes decoder
+ * @param avctx codec context
+ * @return 0 on success or negative if fails
+ */
+static int decode_init(AVCodecContext *avctx)
+{
+    FrapsContext * const s = avctx-&gt;priv_data;
+
+    avctx-&gt;coded_frame = (AVFrame*)&amp;s-&gt;frame;
+    avctx-&gt;pix_fmt= PIX_FMT_NONE; /* set in decode_frame */
+
+    s-&gt;avctx = avctx;
+    s-&gt;frame.data[0] = NULL;
+    s-&gt;tmpbuf = NULL;
+
+    dsputil_init(&amp;s-&gt;dsp, avctx);
+
+    return 0;
+}
+
+/**
+ * Comparator - our nodes should ascend by count
+ * but with preserved symbol order
+ */
+static int huff_cmp(const void *va, const void *vb){
+    const Node *a = va, *b = vb;
+    return (a-&gt;count - b-&gt;count)*256 + a-&gt;sym - b-&gt;sym;
+}
+
+static void get_tree_codes(uint32_t *bits, int16_t *lens, uint8_t *xlat, Node *nodes, int node, uint32_t pfx, int pl, int *pos)
+{
+    int s;
+
+    s = nodes[node].sym;
+    if(s != HNODE || !nodes[node].count){
+        bits[*pos] = pfx;
+        lens[*pos] = pl;
+        xlat[*pos] = s;
+        (*pos)++;
+    }else{
+        pfx &lt;&lt;= 1;
+        pl++;
+        get_tree_codes(bits, lens, xlat, nodes, nodes[node].n0, pfx, pl, pos);
+        pfx |= 1;
+        get_tree_codes(bits, lens, xlat, nodes, nodes[node].n0+1, pfx, pl, pos);
+    }
+}
+
+static int build_huff_tree(VLC *vlc, Node *nodes, uint8_t *xlat)
+{
+    uint32_t bits[256];
+    int16_t lens[256];
+    int pos = 0;
+
+    get_tree_codes(bits, lens, xlat, nodes, 510, 0, 0, &amp;pos);
+    return init_vlc(vlc, 9, pos, lens, 2, 2, bits, 4, 4, 0);
+}
+
+
+/**
+ * decode Fraps v2 packed plane
+ */
+static int fraps2_decode_plane(FrapsContext *s, uint8_t *dst, int stride, int w,
+                               int h, uint8_t *src, int size, int Uoff)
+{
+    int i, j;
+    int cur_node;
+    GetBitContext gb;
+    VLC vlc;
+    int64_t sum = 0;
+    uint8_t recode[256];
+
+    for(i = 0; i &lt; 256; i++){
+        s-&gt;nodes[i].sym = i;
+        s-&gt;nodes[i].count = AV_RL32(src);
+        s-&gt;nodes[i].n0 = -2;
+        if(s-&gt;nodes[i].count &lt; 0) {
+            av_log(s-&gt;avctx, AV_LOG_ERROR, &quot;Symbol count &lt; 0\n&quot;);
+            return -1;
+        }
+        src += 4;
+        sum += s-&gt;nodes[i].count;
+    }
+    size -= 1024;
+
+    if(sum &gt;&gt; 31) {
+        av_log(s-&gt;avctx, AV_LOG_ERROR, &quot;Too high symbol frequencies. Tree construction is not possible\n&quot;);
+        return -1;
+    }
+    qsort(s-&gt;nodes, 256, sizeof(Node), huff_cmp);
+    cur_node = 256;
+    for(i = 0; i &lt; 511; i += 2){
+        s-&gt;nodes[cur_node].sym = HNODE;
+        s-&gt;nodes[cur_node].count = s-&gt;nodes[i].count + s-&gt;nodes[i+1].count;
+        s-&gt;nodes[cur_node].n0 = i;
+        for(j = cur_node; j &gt; 0; j--){
+            if(s-&gt;nodes[j].count &gt;= s-&gt;nodes[j - 1].count) break;
+            FFSWAP(Node, s-&gt;nodes[j], s-&gt;nodes[j - 1]);
+        }
+        cur_node++;
+    }
+    if(build_huff_tree(&amp;vlc, s-&gt;nodes, recode) &lt; 0){
+        av_log(s-&gt;avctx, AV_LOG_ERROR, &quot;Error building tree\n&quot;);
+        return -1;
+    }
+    /* we have built Huffman table and are ready to decode plane */
+
+    /* convert bits so they may be used by standard bitreader */
+    s-&gt;dsp.bswap_buf(s-&gt;tmpbuf, src, size &gt;&gt; 2);
+
+    init_get_bits(&amp;gb, s-&gt;tmpbuf, size * 8);
+    for(j = 0; j &lt; h; j++){
+        for(i = 0; i &lt; w; i++){
+            dst[i] = recode[get_vlc2(&amp;gb, vlc.table, 9, 3)];
+            /* lines are stored as deltas between previous lines
+             * and we need to add 0x80 to the first lines of chroma planes
+             */
+            if(j) dst[i] += dst[i - stride];
+            else if(Uoff) dst[i] += 0x80;
+        }
+        dst += stride;
+    }
+    free_vlc(&amp;vlc);
+    return 0;
+}
+
+/**
+ * decode a frame
+ * @param avctx codec context
+ * @param data output AVFrame
+ * @param data_size size of output data or 0 if no picture is returned
+ * @param buf input data frame
+ * @param buf_size size of input data frame
+ * @return number of consumed bytes on success or negative if decode fails
+ */
+static int decode_frame(AVCodecContext *avctx,
+                        void *data, int *data_size,
+                        uint8_t *buf, int buf_size)
+{
+    FrapsContext * const s = avctx-&gt;priv_data;
+    AVFrame *frame = data;
+    AVFrame * const f = (AVFrame*)&amp;s-&gt;frame;
+    uint32_t header;
+    unsigned int version,header_size;
+    unsigned int x, y;
+    uint32_t *buf32;
+    uint32_t *luma1,*luma2,*cb,*cr;
+    uint32_t offs[4];
+    int i, is_chroma, planes;
+
+
+    header = AV_RL32(buf);
+    version = header &amp; 0xff;
+    header_size = (header &amp; (1&lt;&lt;30))? 8 : 4; /* bit 30 means pad to 8 bytes */
+
+    if (version &gt; 2 &amp;&amp; version != 4) {
+        av_log(avctx, AV_LOG_ERROR,
+               &quot;This file is encoded with Fraps version %d. &quot; \
+               &quot;This codec can only decode version 0, 1, 2 and 4.\n&quot;, version);
+        return -1;
+    }
+
+    buf+=4;
+    if (header_size == 8)
+        buf+=4;
+
+    switch(version) {
+    case 0:
+    default:
+        /* Fraps v0 is a reordered YUV420 */
+        avctx-&gt;pix_fmt = PIX_FMT_YUV420P;
+
+        if ( (buf_size != avctx-&gt;width*avctx-&gt;height*3/2+header_size) &amp;&amp;
+             (buf_size != header_size) ) {
+            av_log(avctx, AV_LOG_ERROR,
+                   &quot;Invalid frame length %d (should be %d)\n&quot;,
+                   buf_size, avctx-&gt;width*avctx-&gt;height*3/2+header_size);
+            return -1;
+        }
+
+        if (( (avctx-&gt;width % 8) != 0) || ( (avctx-&gt;height % 2) != 0 )) {
+            av_log(avctx, AV_LOG_ERROR, &quot;Invalid frame size %dx%d\n&quot;,
+                   avctx-&gt;width, avctx-&gt;height);
+            return -1;
+        }
+
+        f-&gt;reference = 1;
+        f-&gt;buffer_hints = FF_BUFFER_HINTS_VALID |
+                          FF_BUFFER_HINTS_PRESERVE |
+                          FF_BUFFER_HINTS_REUSABLE;
+        if (avctx-&gt;reget_buffer(avctx, f)) {
+            av_log(avctx, AV_LOG_ERROR, &quot;reget_buffer() failed\n&quot;);
+            return -1;
+        }
+        /* bit 31 means same as previous pic */
+        f-&gt;pict_type = (header &amp; (1&lt;&lt;31))? FF_P_TYPE : FF_I_TYPE;
+        f-&gt;key_frame = f-&gt;pict_type == FF_I_TYPE;
+
+        if (f-&gt;pict_type == FF_I_TYPE) {
+            buf32=(uint32_t*)buf;
+            for(y=0; y&lt;avctx-&gt;height/2; y++){
+                luma1=(uint32_t*)&amp;f-&gt;data[0][ y*2*f-&gt;linesize[0] ];
+                luma2=(uint32_t*)&amp;f-&gt;data[0][ (y*2+1)*f-&gt;linesize[0] ];
+                cr=(uint32_t*)&amp;f-&gt;data[1][ y*f-&gt;linesize[1] ];
+                cb=(uint32_t*)&amp;f-&gt;data[2][ y*f-&gt;linesize[2] ];
+                for(x=0; x&lt;avctx-&gt;width; x+=8){
+                    *(luma1++) = *(buf32++);
+                    *(luma1++) = *(buf32++);
+                    *(luma2++) = *(buf32++);
+                    *(luma2++) = *(buf32++);
+                    *(cr++) = *(buf32++);
+                    *(cb++) = *(buf32++);
+                }
+            }
+        }
+        break;
+
+    case 1:
+        /* Fraps v1 is an upside-down BGR24 */
+        avctx-&gt;pix_fmt = PIX_FMT_BGR24;
+
+        if ( (buf_size != avctx-&gt;width*avctx-&gt;height*3+header_size) &amp;&amp;
+             (buf_size != header_size) ) {
+            av_log(avctx, AV_LOG_ERROR,
+                   &quot;Invalid frame length %d (should be %d)\n&quot;,
+                   buf_size, avctx-&gt;width*avctx-&gt;height*3+header_size);
+            return -1;
+        }
+
+        f-&gt;reference = 1;
+        f-&gt;buffer_hints = FF_BUFFER_HINTS_VALID |
+                          FF_BUFFER_HINTS_PRESERVE |
+                          FF_BUFFER_HINTS_REUSABLE;
+        if (avctx-&gt;reget_buffer(avctx, f)) {
+            av_log(avctx, AV_LOG_ERROR, &quot;reget_buffer() failed\n&quot;);
+            return -1;
+        }
+        /* bit 31 means same as previous pic */
+        f-&gt;pict_type = (header &amp; (1&lt;&lt;31))? FF_P_TYPE : FF_I_TYPE;
+        f-&gt;key_frame = f-&gt;pict_type == FF_I_TYPE;
+
+        if (f-&gt;pict_type == FF_I_TYPE) {
+            for(y=0; y&lt;avctx-&gt;height; y++)
+                memcpy(&amp;f-&gt;data[0][ (avctx-&gt;height-y)*f-&gt;linesize[0] ],
+                       &amp;buf[y*avctx-&gt;width*3],
+                       f-&gt;linesize[0]);
+        }
+        break;
+
+    case 2:
+    case 4:
+        /**
+         * Fraps v2 is Huffman-coded YUV420 planes
+         * Fraps v4 is virtually the same
+         */
+        avctx-&gt;pix_fmt = PIX_FMT_YUV420P;
+        planes = 3;
+        f-&gt;reference = 1;
+        f-&gt;buffer_hints = FF_BUFFER_HINTS_VALID |
+                          FF_BUFFER_HINTS_PRESERVE |
+                          FF_BUFFER_HINTS_REUSABLE;
+        if (avctx-&gt;reget_buffer(avctx, f)) {
+            av_log(avctx, AV_LOG_ERROR, &quot;reget_buffer() failed\n&quot;);
+            return -1;
+        }
+        /* skip frame */
+        if(buf_size == 8) {
+            f-&gt;pict_type = FF_P_TYPE;
+            f-&gt;key_frame = 0;
+            break;
+        }
+        f-&gt;pict_type = FF_I_TYPE;
+        f-&gt;key_frame = 1;
+        if ((AV_RL32(buf) != FPS_TAG)||(buf_size &lt; (planes*1024 + 24))) {
+            av_log(avctx, AV_LOG_ERROR, &quot;Fraps: error in data stream\n&quot;);
+            return -1;
+        }
+        for(i = 0; i &lt; planes; i++) {
+            offs[i] = AV_RL32(buf + 4 + i * 4);
+            if(offs[i] &gt;= buf_size || (i &amp;&amp; offs[i] &lt;= offs[i - 1] + 1024)) {
+                av_log(avctx, AV_LOG_ERROR, &quot;Fraps: plane %i offset is out of bounds\n&quot;, i);
+                return -1;
+            }
+        }
+        offs[planes] = buf_size;
+        for(i = 0; i &lt; planes; i++){
+            is_chroma = !!i;
+            s-&gt;tmpbuf = av_realloc(s-&gt;tmpbuf, offs[i + 1] - offs[i] - 1024 + FF_INPUT_BUFFER_PADDING_SIZE);
+            if(fraps2_decode_plane(s, f-&gt;data[i], f-&gt;linesize[i], avctx-&gt;width &gt;&gt; is_chroma,
+                    avctx-&gt;height &gt;&gt; is_chroma, buf + offs[i], offs[i + 1] - offs[i], is_chroma) &lt; 0) {
+                av_log(avctx, AV_LOG_ERROR, &quot;Error decoding plane %i\n&quot;, i);
+                return -1;
+            }
+        }
+        break;
+    }
+
+    *frame = *f;
+    *data_size = sizeof(AVFrame);
+
+    return buf_size;
+}
+
+
+/**
+ * closes decoder
+ * @param avctx codec context
+ * @return 0 on success or negative if fails
+ */
+static int decode_end(AVCodecContext *avctx)
+{
+    FrapsContext *s = (FrapsContext*)avctx-&gt;priv_data;
+
+    if (s-&gt;frame.data[0])
+        avctx-&gt;release_buffer(avctx, &amp;s-&gt;frame);
+
+    av_freep(&amp;s-&gt;tmpbuf);
+    return 0;
+}
+
+
+AVCodec fraps_decoder = {
+    &quot;fraps&quot;,
+    CODEC_TYPE_VIDEO,
+    CODEC_ID_FRAPS,
+    sizeof(FrapsContext),
+    decode_init,
+    NULL,
+    decode_end,
+    decode_frame,
+    CODEC_CAP_DR1,
+};

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/string.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/string.c	2007-07-16 17:46:57 UTC (rev 3385)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/string.c	2007-07-16 17:53:04 UTC (rev 3386)
@@ -0,0 +1,64 @@
+/*
+ * Copyright (c) 2000, 2001, 2002 Fabrice Bellard
+ * Copyright (c) 2007 Mans Rullgard
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include &lt;string.h&gt;
+#include &lt;ctype.h&gt;
+#include &quot;avstring.h&quot;
+
+int av_strstart(const char *str, const char *pfx, const char **ptr)
+{
+    while (*pfx &amp;&amp; *pfx == *str) {
+        pfx++;
+        str++;
+    }
+    if (!*pfx &amp;&amp; ptr)
+        *ptr = str;
+    return !*pfx;
+}
+
+int av_stristart(const char *str, const char *pfx, const char **ptr)
+{
+    while (*pfx &amp;&amp; toupper((unsigned)*pfx) == toupper((unsigned)*str)) {
+        pfx++;
+        str++;
+    }
+    if (!*pfx &amp;&amp; ptr)
+        *ptr = str;
+    return !*pfx;
+}
+
+size_t av_strlcpy(char *dst, const char *src, size_t size)
+{
+    size_t len = 0;
+    while (++len &lt; size &amp;&amp; *src)
+        *dst++ = *src++;
+    if (len &lt;= size)
+        *dst = 0;
+    return len + strlen(src) - 1;
+}
+
+size_t av_strlcat(char *dst, const char *src, size_t size)
+{
+    size_t len = strlen(dst);
+    if (size &lt;= len + 1)
+        return len + strlen(src);
+    return len + av_strlcpy(dst + len, src, size - len);
+}


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000661.html">[Avidemux-svn-commit] r3384 -	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil
</A></li>
	<LI>Next message: <A HREF="000663.html">[Avidemux-svn-commit] r3387 -	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#662">[ date ]</a>
              <a href="thread.html#662">[ thread ]</a>
              <a href="subject.html#662">[ subject ]</a>
              <a href="author.html#662">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
