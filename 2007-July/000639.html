<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r3362 - in	branches/avidemux_2.4_branch/avidemux:	ADM_libraries/ADM_libass ADM_videoFilter
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2007-July/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r3362%20-%20in%0A%09branches/avidemux_2.4_branch/avidemux%3A%0A%09ADM_libraries/ADM_libass%20ADM_videoFilter&In-Reply-To=%3C200707140827.l6E8Rd5H007901%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000638.html">
   <LINK REL="Next"  HREF="000640.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r3362 - in	branches/avidemux_2.4_branch/avidemux:	ADM_libraries/ADM_libass ADM_videoFilter</H1>
    <B>mean at BerliOS</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r3362%20-%20in%0A%09branches/avidemux_2.4_branch/avidemux%3A%0A%09ADM_libraries/ADM_libass%20ADM_videoFilter&In-Reply-To=%3C200707140827.l6E8Rd5H007901%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r3362 - in	branches/avidemux_2.4_branch/avidemux:	ADM_libraries/ADM_libass ADM_videoFilter">mean at mail.berlios.de
       </A><BR>
    <I>Sat Jul 14 10:27:39 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000638.html">[Avidemux-svn-commit] r3361 - in	branches/avidemux_2.4_branch/avidemux: ADM_ocr ADM_osSupport	ADM_userInterfaces/ADM_GTK/ADM_ocr
</A></li>
        <LI>Next message: <A HREF="000640.html">[Avidemux-svn-commit] r3363 -	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#639">[ date ]</a>
              <a href="thread.html#639">[ thread ]</a>
              <a href="subject.html#639">[ subject ]</a>
              <a href="author.html#639">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2007-07-14 10:27:37 +0200 (Sat, 14 Jul 2007)
New Revision: 3362

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/ass_font.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/ass_font.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/help_mp.h
Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/CMakeLists.txt
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/ass.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/ass.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/ass_bitmap.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/ass_bitmap.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/ass_cache.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/ass_cache.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/ass_fontconfig.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/ass_fontconfig.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/ass_library.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/ass_library.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/ass_render.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/ass_types.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/ass_utils.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/ass_utils.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/mputils.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/mputils.h
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidASS.cpp
Log:
[libASS] update to 0.9.4

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/CMakeLists.txt
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/CMakeLists.txt	2007-07-13 17:01:23 UTC (rev 3361)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/CMakeLists.txt	2007-07-14 08:27:37 UTC (rev 3362)
@@ -7,6 +7,7 @@
 if(FT_FOUND)
 SET(${ADM_LIB}_SRCS 
 ass_bitmap.c  ass.c  ass_cache.c  ass_fontconfig.c  ass_library.c  ass_mp.c  ass_render.c  ass_utils.c  mputils.c
+ass_font.c
 )
 ADD_LIBRARY(${ADM_LIB} STATIC ${${ADM_LIB}_SRCS})
 ADD_ADM_LIB(${ADM_LIB} ADM_libraries)

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/ass.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/ass.c	2007-07-13 17:01:23 UTC (rev 3361)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/ass.c	2007-07-14 08:27:37 UTC (rev 3362)
@@ -37,7 +37,6 @@
 #include &quot;ass.h&quot;
 #include &quot;ass_utils.h&quot;
 #include &quot;ass_library.h&quot;
-#include &quot;ass_types.h&quot; /* MEANX */
 #include &quot;mputils.h&quot;
 
 typedef enum {PST_UNKNOWN = 0, PST_INFO, PST_STYLES, PST_EVENTS, PST_FONTS} parser_state_t;
@@ -53,9 +52,6 @@
 #define ASS_STYLES_ALLOC 20
 #define ASS_EVENTS_ALLOC 200
 
-#define ADM_LEGACY_PROGGY
-#include &quot;ADM_assert.h&quot;
-
 void ass_free_track(ass_track_t* track) {
 	int i;
 	
@@ -171,7 +167,7 @@
 			return i;
 	}
 	i = track-&gt;default_style;
-	mp_msg(MSGT_ASS, MSGL_WARN, &quot;[%p] Warning: no style named '%s' found, using '%s'\n&quot;, track, name, track-&gt;styles[i].Name);
+	mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_NoStyleNamedXFoundUsingY, track, name, track-&gt;styles[i].Name);
 	return i; // use the first style
 }
 
@@ -186,7 +182,7 @@
 	long long tm;
 	int res = sscanf(p, &quot;%1d:%2d:%2d.%2d&quot;, &amp;h, &amp;m, &amp;s, &amp;ms);
 	if (res &lt; 4) {
-		mp_msg(MSGT_ASS, MSGL_WARN, &quot;bad timestamp\n&quot;);
+		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_BadTimestamp);
 		return 0;
 	}
 	tm = ((h * 60 + m) * 60 + s) * 1000 + ms * 10;
@@ -351,12 +347,12 @@
 					COLORVAL(SecondaryColour)
 					COLORVAL(OutlineColour)
 					COLORVAL(BackColour)
-					INTVAL(FontSize)
+					FPVAL(FontSize)
 					INTVAL(Bold)
 					INTVAL(Italic)
 					INTVAL(Underline)
 					INTVAL(StrikeOut)
-					INTVAL(Spacing)
+					FPVAL(Spacing)
 					INTVAL(Angle)
 					INTVAL(BorderStyle)
 					INTVAL(Alignment)
@@ -439,12 +435,12 @@
 				// this will destroy SSA's TertiaryColour, but i'm not going to use it anyway
 				if (track-&gt;track_type == TRACK_TYPE_SSA)
 					target-&gt;OutlineColour = target-&gt;BackColour;
-			INTVAL(FontSize)
+			FPVAL(FontSize)
 			INTVAL(Bold)
 			INTVAL(Italic)
 			INTVAL(Underline)
 			INTVAL(StrikeOut)
-			INTVAL(Spacing)
+			FPVAL(Spacing)
 			INTVAL(Angle)
 			INTVAL(BorderStyle)
 			INTVAL(Alignment)
@@ -462,6 +458,9 @@
 	}
 	style-&gt;ScaleX /= 100.;
 	style-&gt;ScaleY /= 100.;
+	style-&gt;Bold = !!style-&gt;Bold;
+	style-&gt;Italic = !!style-&gt;Italic;
+	style-&gt;Underline = !!style-&gt;Underline;
 	if (!style-&gt;Name)
 		style-&gt;Name = strdup(&quot;Default&quot;);
 	if (!style-&gt;FontName)
@@ -557,10 +556,10 @@
 	mp_msg(MSGT_ASS, MSGL_V, &quot;font: %d bytes encoded data \n&quot;, track-&gt;parser_priv-&gt;fontdata_used);
 	size = track-&gt;parser_priv-&gt;fontdata_used;
 	if (size % 4 == 1) {
-		mp_msg(MSGT_ASS, MSGL_ERR, &quot;bad encoded data size\n&quot;);
+		mp_msg(MSGT_ASS, MSGL_ERR, MSGTR_LIBASS_BadEncodedDataSize);
 		goto error_decode_font;
 	}
-	buf = (unsigned char*)malloc(size / 4 * 3 + 2);
+	buf = malloc(size / 4 * 3 + 2);
 	q = buf;
 	for (i = 0, p = (unsigned char*)track-&gt;parser_priv-&gt;fontdata; i &lt; size / 4; i++, p+=4) {
 		q = decode_chars(p[0], p[1], p[2], p[3], q, 3);
@@ -573,8 +572,10 @@
 	dsize = q - buf;
 	assert(dsize &lt;= size / 4 * 3 + 2);
 	
-	if (track-&gt;library-&gt;extract_fonts)
-		ass_process_font(track-&gt;library, track-&gt;parser_priv-&gt;fontname, (char*)buf, dsize);
+	if (track-&gt;library-&gt;extract_fonts) {
+		ass_add_font(track-&gt;library, track-&gt;parser_priv-&gt;fontname, (char*)buf, dsize);
+		buf = 0;
+	}
 
 error_decode_font:
 	if (buf) free(buf);
@@ -587,8 +588,6 @@
 	return 0;
 }
 
-static char* validate_fname(char* name);
-
 static int process_fonts_line(ass_track_t* track, char *str)
 {
 	int len;
@@ -599,7 +598,7 @@
 		if (track-&gt;parser_priv-&gt;fontname) {
 			decode_font(track);
 		}
-		track-&gt;parser_priv-&gt;fontname = validate_fname(p);
+		track-&gt;parser_priv-&gt;fontname = strdup(p);
 		mp_msg(MSGT_ASS, MSGL_V, &quot;fontname: %s\n&quot;, track-&gt;parser_priv-&gt;fontname);
 		return 0;
 	}
@@ -611,12 +610,12 @@
 
 	len = strlen(str);
 	if (len &gt; 80) {
-		mp_msg(MSGT_ASS, MSGL_WARN, &quot;Font line too long: %d, %s\n&quot;, len, str);
+		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FontLineTooLong, len, str);
 		return 0;
 	}
 	if (track-&gt;parser_priv-&gt;fontdata_used + len &gt; track-&gt;parser_priv-&gt;fontdata_size) {
 		track-&gt;parser_priv-&gt;fontdata_size += 100 * 1024;
-		track-&gt;parser_priv-&gt;fontdata =(char *) realloc(track-&gt;parser_priv-&gt;fontdata, track-&gt;parser_priv-&gt;fontdata_size);
+		track-&gt;parser_priv-&gt;fontdata = realloc(track-&gt;parser_priv-&gt;fontdata, track-&gt;parser_priv-&gt;fontdata_size);
 	}
 	memcpy(track-&gt;parser_priv-&gt;fontdata + track-&gt;parser_priv-&gt;fontdata_used, str, len);
 	track-&gt;parser_priv-&gt;fontdata_used += len;
@@ -697,7 +696,7 @@
 */ 
 void ass_process_codec_private(ass_track_t* track, char *data, int size)
 {
-	char* str = (char *)malloc(size + 1);
+	char* str = malloc(size + 1);
 	int sid;
 
 	memcpy(str, data, size);
@@ -751,14 +750,14 @@
 	ass_event_t* event;
 
 	if (!track-&gt;event_format) {
-		mp_msg(MSGT_ASS, MSGL_WARN, &quot;Event format header missing\n&quot;);
+		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_EventFormatHeaderMissing);
 		return;
 	}
 	
-	str = (char *)malloc(size + 1);
+	str = malloc(size + 1);
 	memcpy(str, data, size);
 	str[size] = '\0';
-	//mp_msg(MSGT_ASS, MSGL_V, &quot;event at %&quot; PRId64 &quot;, +%&quot; PRId64 &quot;: %s  \n&quot;, (int64_t)timecode, (int64_t)duration, str);
+	mp_msg(MSGT_ASS, MSGL_V, &quot;event at %&quot; PRId64 &quot;, +%&quot; PRId64 &quot;: %s  \n&quot;, (int64_t)timecode, (int64_t)duration, str);
 
 	eid = ass_alloc_event(track);
 	event = track-&gt;events + eid;
@@ -815,7 +814,7 @@
 		if ((icdsc = iconv_open (tocp, cp_tmp)) != (iconv_t)(-1)){
 			mp_msg(MSGT_ASS,MSGL_V,&quot;LIBSUB: opened iconv descriptor.\n&quot;);
 		} else
-			mp_msg(MSGT_ASS,MSGL_ERR,&quot;LIBSUB: error opening iconv descriptor.\n&quot;);
+			mp_msg(MSGT_ASS,MSGL_ERR,MSGTR_LIBASS_ErrorOpeningIconvDescriptor);
 #ifdef HAVE_ENCA
 		if (cp_tmp) free(cp_tmp);
 #endif
@@ -829,7 +828,7 @@
 		char* op;
 		size_t rc;
 		
-		outbuf = (char *)malloc(size);
+		outbuf = malloc(size);
 		ip = data;
 		op = outbuf;
 		
@@ -843,7 +842,7 @@
 					osize += size;
 					oleft += size;
 				} else {
-					mp_msg(MSGT_ASS, MSGL_WARN, &quot;LIBSUB: error recoding file.\n&quot;);
+					mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_ErrorRecodingFile);
 					return NULL;
 				}
 			}
@@ -876,12 +875,12 @@
 
 	FILE* fp = fopen(fname, &quot;rb&quot;);
 	if (!fp) {
-		mp_msg(MSGT_ASS, MSGL_WARN, &quot;ass_read_file(%s): fopen failed\n&quot;, fname);
+		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FopenFailed, fname);
 		return 0;
 	}
 	res = fseek(fp, 0, SEEK_END);
 	if (res == -1) {
-		mp_msg(MSGT_ASS, MSGL_WARN, &quot;ass_read_file(%s): fseek failed\n&quot;, fname);
+		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FseekFailed, fname);
 		fclose(fp);
 		return 0;
 	}
@@ -890,20 +889,20 @@
 	rewind(fp);
 
 	if (sz &gt; 10*1024*1024) {
-		mp_msg(MSGT_ASS, MSGL_INFO, &quot;ass_read_file(%s): Refusing to load subtitles larger than 10M\n&quot;, fname);
+		mp_msg(MSGT_ASS, MSGL_INFO, MSGTR_LIBASS_RefusingToLoadSubtitlesLargerThan10M, fname);
 		fclose(fp);
 		return 0;
 	}
 	
 	mp_msg(MSGT_ASS, MSGL_V, &quot;file size: %ld\n&quot;, sz);
 	
-	buf = (char *)malloc(sz + 1);
+	buf = malloc(sz + 1);
 	assert(buf);
 	bytes_read = 0;
 	do {
 		res = fread(buf + bytes_read, 1, sz - bytes_read, fp);
 		if (res &lt;= 0) {
-			mp_msg(MSGT_ASS, MSGL_INFO, &quot;Read failed, %d: %s\n&quot;, errno, strerror(errno));
+			mp_msg(MSGT_ASS, MSGL_INFO, MSGTR_LIBASS_ReadFailed, errno, strerror(errno));
 			fclose(fp);
 			free(buf);
 			return 0;
@@ -979,7 +978,7 @@
 	if (!track)
 		return 0;
 
-	mp_msg(MSGT_ASS, MSGL_INFO, &quot;LIBASS: added subtitle file: &lt;memory&gt; (%d styles, %d events)\n&quot;, track-&gt;n_styles, track-&gt;n_events);
+	mp_msg(MSGT_ASS, MSGL_INFO, MSGTR_LIBASS_AddedSubtitleFileMemory, track-&gt;n_styles, track-&gt;n_events);
 	return track;
 }
 
@@ -1015,7 +1014,7 @@
 	
 	track-&gt;name = strdup(fname);
 
-	mp_msg(MSGT_ASS, MSGL_INFO, &quot;LIBASS: added subtitle file: %s (%d styles, %d events)\n&quot;, fname, track-&gt;n_styles, track-&gt;n_events);
+	mp_msg(MSGT_ASS, MSGL_INFO, MSGTR_LIBASS_AddedSubtitleFileFname, fname, track-&gt;n_styles, track-&gt;n_events);
 	
 //	dump_events(forced_tid);
 	return track;
@@ -1052,86 +1051,6 @@
 	return 0;
 }
 
-static char* validate_fname(char* name)
-{
-	char* fname;
-	char* p;
-	char* q;
-	unsigned code;
-	int sz = strlen(name);
-
-	q = fname = (char *)malloc(sz + 1);
-	p = name;
-	while (*p) {
-		code = utf8_get_char(&amp;p);
-		if (code == 0)
-			break;
-		if (	(code &gt; 0x7F) ||
-			(code == '\\') ||
-			(code == '/') ||
-			(code == ':') ||
-			(code == '*') ||
-			(code == '?') ||
-			(code == '&lt;') ||
-			(code == '&gt;') ||
-			(code == '|') ||
-			(code == 0))
-		{
-			*q++ = '_';
-		} else {
-			*q++ = code;
-		}
-		if (p - name &gt; sz)
-			break;
-	}
-	*q = 0;
-	return fname;
-}
-
-/**
- * \brief Process embedded matroska font. Saves it to ~/.mplayer/fonts.
- * \param name attachment name
- * \param data binary font data
- * \param data_size data size
-*/ 
-void ass_process_font(ass_library_t* library, const char* name, char* data, int data_size)
-{
-	char buf[1000];
-	FILE* fp = 0;
-	int rc;
-	struct stat st;
-	char* fname;
-	const char* fonts_dir = library-&gt;fonts_dir;
-
-	if (!fonts_dir)
-		return;
-	rc = stat(fonts_dir, &amp;st);
-	if (rc) {
-		int res;
-#ifndef __MINGW32__
-		res = mkdir(fonts_dir, 0700);
-#else
-		res = mkdir(fonts_dir);
-#endif
-		if (res) {
-			mp_msg(MSGT_ASS, MSGL_WARN, &quot;Failed to create: %s\n&quot;, fonts_dir);
-		}
-	} else if (!S_ISDIR(st.st_mode)) {
-		mp_msg(MSGT_ASS, MSGL_WARN, &quot;Not a directory: %s\n&quot;, fonts_dir);
-	}
-	
-	fname = validate_fname((char*)name);
-
-	snprintf(buf, 1000, &quot;%s/%s&quot;, fonts_dir, fname);
-	free(fname);
-
-	fp = fopen(buf, &quot;wb&quot;);
-	if (!fp) return;
-
-	fwrite(data, data_size, 1, fp);
-	fclose(fp);
-}
-
 long long ass_step_sub(ass_track_t* track, long long now, int movement) {
 	int i;
 
@@ -1152,9 +1071,9 @@
 }
 
 ass_track_t* ass_new_track(ass_library_t* library) {
-	ass_track_t* track = (ass_track_t *)calloc(1, sizeof(ass_track_t));
+	ass_track_t* track = calloc(1, sizeof(ass_track_t));
 	track-&gt;library = library;
-	track-&gt;parser_priv = (parser_priv_t *)calloc(1, sizeof(parser_priv_t));
+	track-&gt;parser_priv = calloc(1, sizeof(parser_priv_t));
 	return track;
 }
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/ass.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/ass.h	2007-07-13 17:01:23 UTC (rev 3361)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/ass.h	2007-07-14 08:27:37 UTC (rev 3362)
@@ -37,6 +37,13 @@
 	struct ass_image_s* next; // linked list
 } ass_image_t;
 
+/// Hinting type
+typedef enum {ASS_HINTING_NONE = 0,
+	      ASS_HINTING_LIGHT,
+	      ASS_HINTING_NORMAL,
+	      ASS_HINTING_NATIVE
+} ass_hinting_t;
+
 /**
  * \brief initialize the library
  * \return library handle or NULL if failed
@@ -77,6 +84,7 @@
 void ass_set_use_margins(ass_renderer_t* priv, int use);
 void ass_set_aspect_ratio(ass_renderer_t* priv, double ar);
 void ass_set_font_scale(ass_renderer_t* priv, double font_scale);
+void ass_set_hinting(ass_renderer_t* priv, ass_hinting_t ht);
 
 /**
  * \brief set font lookup defaults
@@ -89,7 +97,7 @@
  * \param track subtitle track
  * \param now video timestamp in milliseconds
  */
-ass_image_t* ass_render_frame(ass_renderer_t *priv, ass_track_t* track, long long now);
+ass_image_t* ass_render_frame(ass_renderer_t *priv, ass_track_t* track, long long now, int* detect_change);
 
 
 // The following functions operate on track objects and do not need an ass_renderer //
@@ -177,12 +185,12 @@
 int ass_read_styles(ass_track_t* track, char* fname, char* codepage);
 
 /**
- * \brief Process embedded matroska font. Saves it to ~/.mplayer/fonts.
+ * \brief Add a memory font.
  * \param name attachment name
  * \param data binary font data
  * \param data_size data size
 */
-void ass_process_font(ass_library_t* library, const char* name, char* data, int data_size);
+void ass_add_font(ass_library_t* library, char* name, char* data, int data_size);
 
 /**
  * \brief Calculates timeshift from now to the start of some other subtitle event, depending on movement parameter

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/ass_bitmap.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/ass_bitmap.c	2007-07-13 17:01:23 UTC (rev 3361)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/ass_bitmap.c	2007-07-14 08:27:37 UTC (rev 3362)
@@ -28,10 +28,6 @@
 #include &quot;mputils.h&quot;
 #include &quot;ass_bitmap.h&quot;
 
-#define ADM_LEGACY_PROGGY
-#include &quot;ADM_assert.h&quot;
-
-
 struct ass_synth_priv_s {
 	int tmp_w, tmp_h;
 	unsigned short* tmp;
@@ -58,8 +54,8 @@
 	priv-&gt;g_w = 2*priv-&gt;g_r+1;
 
 	if (priv-&gt;g_r) {
-		priv-&gt;g = (unsigned*)malloc(priv-&gt;g_w * sizeof(unsigned));
-		priv-&gt;gt2 = (unsigned*)malloc(256 * priv-&gt;g_w * sizeof(unsigned));
+		priv-&gt;g = malloc(priv-&gt;g_w * sizeof(unsigned));
+		priv-&gt;gt2 = malloc(256 * priv-&gt;g_w * sizeof(unsigned));
 		if (priv-&gt;g==NULL || priv-&gt;gt2==NULL) {
 			return -1;
 		}
@@ -105,12 +101,12 @@
 	while (priv-&gt;tmp_h &lt; h) priv-&gt;tmp_h *= 2;
 	if (priv-&gt;tmp)
 		free(priv-&gt;tmp);
-	priv-&gt;tmp = (short unsigned int*)malloc((priv-&gt;tmp_w + 1) * priv-&gt;tmp_h * sizeof(short));
+	priv-&gt;tmp = malloc((priv-&gt;tmp_w + 1) * priv-&gt;tmp_h * sizeof(short));
 }
 
-ass_synth_priv_t* ass_synth_init()
+ass_synth_priv_t* ass_synth_init(void)
 {
-	ass_synth_priv_t* priv = (ass_synth_priv_t *)calloc(1, sizeof(ass_synth_priv_t));
+	ass_synth_priv_t* priv = calloc(1, sizeof(ass_synth_priv_t));
 	generate_tables(priv, blur_radius);
 	return priv;
 }
@@ -129,8 +125,8 @@
 static bitmap_t* alloc_bitmap(int w, int h)
 {
 	bitmap_t* bm;
-	bm = (bitmap_t *)calloc(1, sizeof(bitmap_t));
-	bm-&gt;buffer = (unsigned char *)malloc(w*h);
+	bm = calloc(1, sizeof(bitmap_t));
+	bm-&gt;buffer = malloc(w*h);
 	bm-&gt;w = w;
 	bm-&gt;h = h;
 	bm-&gt;left = bm-&gt;top = 0;
@@ -167,14 +163,14 @@
 
 	error = FT_Glyph_To_Bitmap(&amp;glyph, FT_RENDER_MODE_NORMAL, 0, 0);
 	if (error) {
-		mp_msg(MSGT_ASS, MSGL_WARN, &quot;FT_Glyph_To_Bitmap error %d \n&quot;, error);
+		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FT_Glyph_To_BitmapError, error);
 		return 0;
 	}
 
 	bg = (FT_BitmapGlyph)glyph;
 	bit = &amp;(bg-&gt;bitmap);
 	if (bit-&gt;pixel_mode != FT_PIXEL_MODE_GRAY) {
-		mp_msg(MSGT_ASS, MSGL_WARN, &quot;Unsupported pixel mode: %d\n&quot;, (int)(bit-&gt;pixel_mode));
+		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_UnsupportedPixelMode, (int)(bit-&gt;pixel_mode));
 		FT_Done_Glyph(glyph);
 		return 0;
 	}

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/ass_bitmap.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/ass_bitmap.h	2007-07-13 17:01:23 UTC (rev 3361)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/ass_bitmap.h	2007-07-14 08:27:37 UTC (rev 3362)
@@ -23,7 +23,7 @@
 
 typedef struct ass_synth_priv_s ass_synth_priv_t;
 
-ass_synth_priv_t* ass_synth_init();
+ass_synth_priv_t* ass_synth_init(void);
 void ass_synth_done(ass_synth_priv_t* priv);
 
 typedef struct bitmap_s {

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/ass_cache.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/ass_cache.c	2007-07-13 17:01:23 UTC (rev 3361)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/ass_cache.c	2007-07-14 08:27:37 UTC (rev 3362)
@@ -20,6 +20,7 @@
 
 #include &quot;config.h&quot;
 
+#include &lt;inttypes.h&gt;
 #include &lt;ft2build.h&gt;
 #include FT_FREETYPE_H
 #include FT_GLYPH_H
@@ -27,197 +28,272 @@
 #include &lt;assert.h&gt;
 
 #include &quot;mputils.h&quot;
+#include &quot;ass.h&quot;
 #include &quot;ass_fontconfig.h&quot;
+#include &quot;ass_font.h&quot;
 #include &quot;ass_bitmap.h&quot;
 #include &quot;ass_cache.h&quot;
 
-#define ADM_LEGACY_PROGGY
-#include &quot;ADM_assert.h&quot;
 
+typedef struct hashmap_item_s {
+	void* key;
+	void* value;
+	struct hashmap_item_s* next;
+} hashmap_item_t;
+typedef hashmap_item_t* hashmap_item_p;
 
-typedef struct face_cache_item_s {
-	face_desc_t desc;
-	char* path;
-	int index;
-	FT_Face face;
-} face_cache_item_t;
+struct hashmap_s {
+	int nbuckets;
+	size_t key_size, value_size;
+	hashmap_item_p* root;
+	hashmap_item_dtor_t item_dtor; // a destructor for hashmap key/value pairs
+	hashmap_key_compare_t key_compare;
+	hashmap_hash_t hash;
+	// stats
+	int hit_count;
+	int miss_count;
+	int count;
+};
 
-#define MAX_FACE_CACHE_SIZE 100
+#define FNV1_32A_INIT (unsigned)0x811c9dc5
 
-static face_cache_item_t* face_cache;
-static int face_cache_size;
+static inline unsigned fnv_32a_buf(void* buf, size_t len, unsigned hval)
+{
+	unsigned char *bp = buf;
+	unsigned char *be = bp + len;
+	while (bp &lt; be) {
+		hval ^= (unsigned)*bp++;
+		hval += (hval&lt;&lt;1) + (hval&lt;&lt;4) + (hval&lt;&lt;7) + (hval&lt;&lt;8) + (hval&lt;&lt;24);
+	}
+	return hval;
+}
+static inline unsigned fnv_32a_str(char* str, unsigned hval)
+{
+	unsigned char* s = (unsigned char*)str;
+	while (*s) {
+		hval ^= (unsigned)*s++;
+		hval += (hval&lt;&lt;1) + (hval&lt;&lt;4) + (hval&lt;&lt;7) + (hval&lt;&lt;8) + (hval&lt;&lt;24);
+	}
+	return hval;
+}
 
-extern int no_more_font_messages;
+static unsigned hashmap_hash(void* buf, size_t len)
+{
+	return fnv_32a_buf(buf, len, FNV1_32A_INIT);
+}
 
-static int font_compare(face_desc_t* a, face_desc_t* b) {
-	if (strcmp(a-&gt;family, b-&gt;family) != 0)
-		return 0;
-	if (a-&gt;bold != b-&gt;bold)
-		return 0;
-	if (a-&gt;italic != b-&gt;italic)
-		return 0;
-	return 1;
+static int hashmap_key_compare(void* a, void* b, size_t size)
+{
+	return (memcmp(a, b, size) == 0);
 }
 
-/**
- * Select Microfost Unicode CharMap, if the font has one.
- * Otherwise, let FreeType decide.
- */
-static void charmap_magic(FT_Face face)
+static void hashmap_item_dtor(void* key, size_t key_size, void* value, size_t value_size)
 {
-	int i;
-	for (i = 0; i &lt; face-&gt;num_charmaps; ++i) {
-		FT_CharMap cmap = face-&gt;charmaps[i];
-		unsigned pid = cmap-&gt;platform_id;
-		unsigned eid = cmap-&gt;encoding_id;
-		if (pid == 3 /*microsoft*/ &amp;&amp; (eid == 1 /*unicode bmp*/ || eid == 10 /*full unicode*/)) {
-			FT_Set_Charmap(face, cmap);
-			break;
-		}
-	}
+	free(key);
+	free(value);
 }
 
-/**
- * \brief Get a face object, either from cache or created through FreeType+FontConfig.
- * \param library FreeType library object
- * \param fontconfig_priv fontconfig private data
- * \param desc required face description
- * \param face out: the face object
-*/ 
-int ass_new_face(FT_Library library, void* fontconfig_priv, face_desc_t* desc, /*out*/ FT_Face* face)
+hashmap_t* hashmap_init(size_t key_size, size_t value_size, int nbuckets,
+			hashmap_item_dtor_t item_dtor, hashmap_key_compare_t key_compare,
+			hashmap_hash_t hash)
 {
-	FT_Error error;
+	hashmap_t* map = calloc(1, sizeof(hashmap_t));
+	map-&gt;nbuckets = nbuckets;
+	map-&gt;key_size = key_size;
+	map-&gt;value_size = value_size;
+	map-&gt;root = calloc(nbuckets, sizeof(hashmap_item_p));
+	map-&gt;item_dtor = item_dtor ? item_dtor : hashmap_item_dtor;
+	map-&gt;key_compare = key_compare ? key_compare : hashmap_key_compare;
+	map-&gt;hash = hash ? hash : hashmap_hash;
+	return map;
+}
+
+void hashmap_done(hashmap_t* map)
+{
 	int i;
-	char* path;
-	int index;
-	face_cache_item_t* item;
+	// print stats
+	if (map-&gt;count &gt; 0 || map-&gt;hit_count + map-&gt;miss_count &gt; 0)
+		mp_msg(MSGT_ASS, MSGL_V, &quot;cache statistics: \n  total accesses: %d\n  hits: %d\n  misses: %d\n  object count: %d\n&quot;,
+		       map-&gt;hit_count + map-&gt;miss_count, map-&gt;hit_count, map-&gt;miss_count, map-&gt;count);
 	
-	for (i=0; i&lt;face_cache_size; ++i)
-		if (font_compare(desc, &amp;(face_cache[i].desc))) {
-			*face = face_cache[i].face;
-			return 0;
+	for (i = 0; i &lt; map-&gt;nbuckets; ++i) {
+		hashmap_item_t* item = map-&gt;root[i];
+		while (item) {
+			hashmap_item_t* next = item-&gt;next;
+			map-&gt;item_dtor(item-&gt;key, map-&gt;key_size, item-&gt;value, map-&gt;value_size);
+			free(item);
+			item = next;
 		}
+	}
+	free(map-&gt;root);
+	free(map);
+}
 
-	if (face_cache_size == MAX_FACE_CACHE_SIZE) {
-		mp_msg(MSGT_ASS, MSGL_FATAL, &quot;Too many fonts\n&quot;);
-		return 1;
+// does nothing if key already exists
+void* hashmap_insert(hashmap_t* map, void* key, void* value)
+{
+	unsigned hash = map-&gt;hash(key, map-&gt;key_size);
+	hashmap_item_t** next = map-&gt;root + (hash % map-&gt;nbuckets);
+	while (*next) {
+		if (map-&gt;key_compare(key, (*next)-&gt;key, map-&gt;key_size))
+			return (*next)-&gt;value;
+		next = &amp;((*next)-&gt;next);
+		assert(next);
 	}
+	(*next) = malloc(sizeof(hashmap_item_t));
+	(*next)-&gt;key = malloc(map-&gt;key_size);
+	(*next)-&gt;value = malloc(map-&gt;value_size);
+	memcpy((*next)-&gt;key, key, map-&gt;key_size);
+	memcpy((*next)-&gt;value, value, map-&gt;value_size);
+	(*next)-&gt;next = 0;
 
-	path = fontconfig_select((fc_instance_t *)fontconfig_priv, desc-&gt;family, desc-&gt;bold, desc-&gt;italic, &amp;index);
-	
-	error = FT_New_Face(library, path, index, face);
-	if (error) {
-		if (!no_more_font_messages)
-			mp_msg(MSGT_ASS, MSGL_WARN, &quot;Error opening font: %s, %d\n&quot;, path, index);
-		no_more_font_messages = 1;
-		return 1;
+	map-&gt;count ++;
+	return (*next)-&gt;value;
+}
+
+void* hashmap_find(hashmap_t* map, void* key)
+{
+	unsigned hash = map-&gt;hash(key, map-&gt;key_size);
+	hashmap_item_t* item = map-&gt;root[hash % map-&gt;nbuckets];
+	while (item) {
+		if (map-&gt;key_compare(key, item-&gt;key, map-&gt;key_size)) {
+			map-&gt;hit_count++;
+			return item-&gt;value;
+		}
+		item = item-&gt;next;
 	}
-
-	charmap_magic(*face);
-	
-	item = face_cache + face_cache_size;
-	item-&gt;path = strdup(path);
-	item-&gt;index = index;
-	item-&gt;face = *face;
-	memcpy(&amp;(item-&gt;desc), desc, sizeof(face_desc_t));
-	face_cache_size++;
+	map-&gt;miss_count++;
 	return 0;
 }
 
-void ass_face_cache_init(void)
+//---------------------------------
+// font cache
+
+hashmap_t* font_cache;
+
+static unsigned font_desc_hash(void* buf, size_t len)
 {
-        
-        
-        face_cache = (face_cache_item_t *)calloc(MAX_FACE_CACHE_SIZE, sizeof(face_cache_item_t));
-	face_cache_size = 0;
-        
+	ass_font_desc_t* desc = buf;
+	unsigned hval;
+	hval = fnv_32a_str(desc-&gt;family, FNV1_32A_INIT);
+	hval = fnv_32a_buf(&amp;desc-&gt;bold, sizeof(desc-&gt;bold), hval);
+	hval = fnv_32a_buf(&amp;desc-&gt;italic, sizeof(desc-&gt;italic), hval);
+	return hval;
 }
 
-void ass_face_cache_done(void)
+static int font_compare(void* key1, void* key2, size_t key_size) {
+	ass_font_desc_t* a = key1;
+	ass_font_desc_t* b = key2;
+	if (strcmp(a-&gt;family, b-&gt;family) != 0)
+		return 0;
+	if (a-&gt;bold != b-&gt;bold)
+		return 0;
+	if (a-&gt;italic != b-&gt;italic)
+		return 0;
+	return 1;
+}
+
+static void font_hash_dtor(void* key, size_t key_size, void* value, size_t value_size)
 {
-	
-        int i;
-	for (i = 0; i &lt; face_cache_size; ++i) {
-		face_cache_item_t* item = face_cache + i;
-		if (item-&gt;face) FT_Done_Face(item-&gt;face);
-		if (item-&gt;path) free(item-&gt;path);
-		// FIXME: free desc ?
-	}
-	free(face_cache);
-	face_cache_size = 0;
-        face_cache=NULL; // MEANX
+	ass_font_free(value);
+	free(key);
+}
 
+ass_font_t* ass_font_cache_find(ass_font_desc_t* desc)
+{
+	return hashmap_find(font_cache, desc);
 }
 
-//---------------------------------
-// glyph cache
+/**
+ * \brief Add a face struct to cache.
+ * \param font font struct
+*/
+void* ass_font_cache_add(ass_font_t* font)
+{
+	return hashmap_insert(font_cache, &amp;(font-&gt;desc), font);
+}
 
-#define GLYPH_HASH_SIZE (0xFFFF + 13)
+void ass_font_cache_init(void)
+{
+	font_cache = hashmap_init(sizeof(ass_font_desc_t),
+				  sizeof(ass_font_t),
+				  1000,
+				  font_hash_dtor, font_compare, font_desc_hash);
+}
 
-typedef struct glyph_hash_item_s {
-	glyph_hash_key_t key;
-	glyph_hash_val_t val;
-	struct glyph_hash_item_s* next;
-} glyph_hash_item_t;
+void ass_font_cache_done(void)
+{
+	hashmap_done(font_cache);
+}
 
-typedef glyph_hash_item_t* glyph_hash_item_p;
+//---------------------------------
+// bitmap cache
 
-static glyph_hash_item_p* glyph_hash_root;
-static int glyph_hash_size;
+hashmap_t* bitmap_cache;
 
-static int glyph_compare(glyph_hash_key_t* a, glyph_hash_key_t* b) {
-	if (memcmp(a, b, sizeof(glyph_hash_key_t)) == 0)
-		return 1;
-	else
-		return 0;
+static void bitmap_hash_dtor(void* key, size_t key_size, void* value, size_t value_size)
+{
+	bitmap_hash_val_t* v = value;
+	if (v-&gt;bm) ass_free_bitmap(v-&gt;bm);
+	if (v-&gt;bm_o) ass_free_bitmap(v-&gt;bm_o);
+	if (v-&gt;bm_s) ass_free_bitmap(v-&gt;bm_s);
+	free(key);
+	free(value);
 }
 
-static unsigned glyph_hash(glyph_hash_key_t* key) {
-	unsigned val = 0;
-	unsigned i;
-	for (i = 0; i &lt; sizeof(key-&gt;face); ++i)
-		val += *(unsigned char *)(&amp;(key-&gt;face) + i);
-	val &lt;&lt;= 21;
-	
-	if (key-&gt;bitmap)   val &amp;= 0x80000000;
-	if (key-&gt;be) val &amp;= 0x40000000;
-	val += key-&gt;index;
-	val += key-&gt;size &lt;&lt; 8;
-	val += key-&gt;outline &lt;&lt; 3;
-	val += key-&gt;advance.x &lt;&lt; 10;
-	val += key-&gt;advance.y &lt;&lt; 16;
-	val += key-&gt;bold &lt;&lt; 1;
-	val += key-&gt;italic &lt;&lt; 20;
-	return val;
+void* cache_add_bitmap(bitmap_hash_key_t* key, bitmap_hash_val_t* val)
+{
+	return hashmap_insert(bitmap_cache, key, val);
 }
 
 /**
- * \brief Add a glyph to glyph cache.
+ * \brief Get a bitmap from bitmap cache.
  * \param key hash key
- * \param val hash val: 2 bitmap glyphs + some additional info
+ * \return requested hash val or 0 if not found
 */ 
-void cache_add_glyph(glyph_hash_key_t* key, glyph_hash_val_t* val)
+bitmap_hash_val_t* cache_find_bitmap(bitmap_hash_key_t* key)
 {
-	unsigned hash = glyph_hash(key);
-	glyph_hash_item_t** next = glyph_hash_root + (hash % GLYPH_HASH_SIZE);
-	while (*next) {
-		if (glyph_compare(key, &amp;((*next)-&gt;key)))
-			return;
-		next = &amp;((*next)-&gt;next);
-		assert(next);
-	}
-	(*next) = (glyph_hash_item_t *)malloc(sizeof(glyph_hash_item_t));
-//	(*next)-&gt;desc = glyph_key_copy(key, &amp;((*next)-&gt;key));
-	memcpy(&amp;((*next)-&gt;key), key, sizeof(glyph_hash_key_t));
-	memcpy(&amp;((*next)-&gt;val), val, sizeof(glyph_hash_val_t));
-	(*next)-&gt;next = 0;
+	return hashmap_find(bitmap_cache, key);
+}
 
-	glyph_hash_size ++;
-/*	if (glyph_hash_size  &amp;&amp; (glyph_hash_size % 25 == 0)) {
-		printf(&quot;\nGlyph cache: %d entries, %d bytes\n&quot;, glyph_hash_size, glyph_hash_size * sizeof(glyph_hash_item_t));
-	} */
+void ass_bitmap_cache_init(void)
+{
+	bitmap_cache = hashmap_init(sizeof(bitmap_hash_key_t),
+				   sizeof(bitmap_hash_val_t),
+				   0xFFFF + 13,
+				   bitmap_hash_dtor, NULL, NULL);
 }
 
+void ass_bitmap_cache_done(void)
+{
+	hashmap_done(bitmap_cache);
+}
+
+void ass_bitmap_cache_reset(void)
+{
+	ass_bitmap_cache_done();
+	ass_bitmap_cache_init();
+}
+
+//---------------------------------
+// glyph cache
+
+hashmap_t* glyph_cache;
+
+static void glyph_hash_dtor(void* key, size_t key_size, void* value, size_t value_size)
+{
+	glyph_hash_val_t* v = value;
+	if (v-&gt;glyph) FT_Done_Glyph(v-&gt;glyph);
+	if (v-&gt;outline_glyph) FT_Done_Glyph(v-&gt;outline_glyph);
+	free(key);
+	free(value);
+}
+
+void* cache_add_glyph(glyph_hash_key_t* key, glyph_hash_val_t* val)
+{
+	return hashmap_insert(glyph_cache, key, val);
+}
+
 /**
  * \brief Get a glyph from glyph cache.
  * \param key hash key
@@ -225,42 +301,20 @@
 */ 
 glyph_hash_val_t* cache_find_glyph(glyph_hash_key_t* key)
 {
-	unsigned hash = glyph_hash(key);
-	glyph_hash_item_t* item = glyph_hash_root[hash % GLYPH_HASH_SIZE];
-	while (item) {
-		if (glyph_compare(key, &amp;(item-&gt;key))) {
-			return &amp;(item-&gt;val);
-		}
-		item = item-&gt;next;
-	}
-	return 0;
+	return hashmap_find(glyph_cache, key);
 }
 
 void ass_glyph_cache_init(void)
 {
-	glyph_hash_root = (glyph_hash_item_p *)calloc(GLYPH_HASH_SIZE, sizeof(glyph_hash_item_p));
-	glyph_hash_size = 0;
-
+	glyph_cache = hashmap_init(sizeof(glyph_hash_key_t),
+				   sizeof(glyph_hash_val_t),
+				   0xFFFF + 13,
+				   glyph_hash_dtor, NULL, NULL);
 }
 
 void ass_glyph_cache_done(void)
 {
-	int i;
-	for (i = 0; i &lt; GLYPH_HASH_SIZE; ++i) {
-		glyph_hash_item_t* item = glyph_hash_root[i];
-		while (item) {
-			glyph_hash_item_t* next = item-&gt;next;
-			if (item-&gt;val.bm) ass_free_bitmap(item-&gt;val.bm);
-			if (item-&gt;val.bm_o) ass_free_bitmap(item-&gt;val.bm_o);
-			if (item-&gt;val.bm_s) ass_free_bitmap(item-&gt;val.bm_s);
-			free(item);
-			item = next;
-		}
-	}
-	free(glyph_hash_root);
-        glyph_hash_root=NULL;
-	glyph_hash_size = 0;
-
+	hashmap_done(glyph_cache);
 }
 
 void ass_glyph_cache_reset(void)
@@ -268,4 +322,3 @@
 	ass_glyph_cache_done();
 	ass_glyph_cache_init();
 }
-

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/ass_cache.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/ass_cache.h	2007-07-13 17:01:23 UTC (rev 3361)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/ass_cache.h	2007-07-14 08:27:37 UTC (rev 3362)
@@ -21,53 +21,78 @@
 #ifndef __ASS_CACHE_H__
 #define __ASS_CACHE_H__
 
-#include &lt;ft2build.h&gt;
-#include FT_FREETYPE_H
-#include FT_STROKER_H
-#include FT_GLYPH_H
+void ass_font_cache_init(void);
+ass_font_t* ass_font_cache_find(ass_font_desc_t* desc);
+void* ass_font_cache_add(ass_font_t* font);
+void ass_font_cache_done(void);
 
-// font cache
-typedef struct face_desc_s {
-	char* family;
-	unsigned bold;
-	unsigned italic;
-} face_desc_t;
 
-void ass_face_cache_init(void);
-int ass_new_face(FT_Library library, void* fontconfig_priv, face_desc_t* desc, /*out*/ FT_Face* face);
-void ass_face_cache_done(void);
-
-
-// describes a glyph; glyphs with equivalents structs are considered identical
-typedef struct glyph_hash_key_s {
+// describes a bitmap; bitmaps with equivalents structs are considered identical
+typedef struct bitmap_hash_key_s {
 	char bitmap; // bool : true = bitmap, false = outline
-	FT_Face face;
-	int size; // font size
-	int index; // glyph index in the face
+	ass_font_t* font;
+	double size; // font size
+	uint32_t ch; // character code
 	unsigned outline; // border width, 16.16 fixed point value
 	int bold, italic;
 	char be; // blur edges
 
-	// the following affects bitmap glyphs only
 	unsigned scale_x, scale_y; // 16.16
-	int angle; // signed 16.16
+	int frx, fry, frz; // signed 16.16
+	int shift_x, shift_y; // shift vector that was added to glyph before applying rotation
+	                      // = 0, if frx = fry = frx = 0
+	                      // = (glyph base point) - (rotation origin), otherwise
 	
 	FT_Vector advance; // subpixel shift vector
+} bitmap_hash_key_t;
+
+typedef struct bitmap_hash_val_s {
+	bitmap_t* bm; // the actual bitmaps
+	bitmap_t* bm_o;
+	bitmap_t* bm_s;
+} bitmap_hash_val_t;
+
+void ass_bitmap_cache_init(void);
+void* cache_add_bitmap(bitmap_hash_key_t* key, bitmap_hash_val_t* val);
+bitmap_hash_val_t* cache_find_bitmap(bitmap_hash_key_t* key);
+void ass_bitmap_cache_reset(void);
+void ass_bitmap_cache_done(void);
+
+// describes an outline glyph
+typedef struct glyph_hash_key_s {
+	ass_font_t* font;
+	double size; // font size
+	uint32_t ch; // character code
+	int bold, italic;
+	unsigned scale_x, scale_y; // 16.16
+	FT_Vector advance; // subpixel shift vector
+	unsigned outline; // border width, 16.16
 } glyph_hash_key_t;
 
 typedef struct glyph_hash_val_s {
-	bitmap_t* bm; // the actual glyph bitmaps
-	bitmap_t* bm_o;
-	bitmap_t* bm_s;
+	FT_Glyph glyph;
+	FT_Glyph outline_glyph;
 	FT_BBox bbox_scaled; // bbox after scaling, but before rotation
-	FT_Vector advance; // 26.6, advance distance to the next glyph in line
+	FT_Vector advance; // 26.6, advance distance to the next bitmap in line
 } glyph_hash_val_t;
 
 void ass_glyph_cache_init(void);
-void cache_add_glyph(glyph_hash_key_t* key, glyph_hash_val_t* val);
+void* cache_add_glyph(glyph_hash_key_t* key, glyph_hash_val_t* val);
 glyph_hash_val_t* cache_find_glyph(glyph_hash_key_t* key);
 void ass_glyph_cache_reset(void);
 void ass_glyph_cache_done(void);
 
+typedef struct hashmap_s hashmap_t; 
+typedef void (*hashmap_item_dtor_t)(void* key, size_t key_size, void* value, size_t value_size);
+typedef int (*hashmap_key_compare_t)(void* key1, void* key2, size_t key_size);
+typedef unsigned (*hashmap_hash_t)(void* key, size_t key_size);
+
+hashmap_t* hashmap_init(size_t key_size, size_t value_size, int nbuckets,
+			hashmap_item_dtor_t item_dtor, hashmap_key_compare_t key_compare,
+			hashmap_hash_t hash);
+void hashmap_done(hashmap_t* map);
+void* hashmap_insert(hashmap_t* map, void* key, void* value);
+void* hashmap_find(hashmap_t* map, void* key);
+
 #endif
 

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/ass_font.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/ass_font.c	2007-07-13 17:01:23 UTC (rev 3361)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/ass_font.c	2007-07-14 08:27:37 UTC (rev 3362)
@@ -0,0 +1,366 @@
+// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
+// vim:ts=8:sw=8:noet:ai:
+/*
+  Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+*/
+
+#include &quot;config.h&quot;
+
+#include &lt;inttypes.h&gt;
+#include &lt;ft2build.h&gt;
+#include FT_FREETYPE_H
+#include FT_SYNTHESIS_H
+#include FT_GLYPH_H
+#include FT_TRUETYPE_TABLES_H
+
+#include &quot;ass.h&quot;
+#include &quot;ass_library.h&quot;
+#include &quot;ass_font.h&quot;
+#include &quot;ass_bitmap.h&quot;
+#include &quot;ass_cache.h&quot;
+#include &quot;ass_fontconfig.h&quot;
+#include &quot;ass_utils.h&quot;
+#include &quot;mputils.h&quot;
+
+/**
+ * Select Microfost Unicode CharMap, if the font has one.
+ * Otherwise, let FreeType decide.
+ */
+static void charmap_magic(FT_Face face)
+{
+	int i;
+	for (i = 0; i &lt; face-&gt;num_charmaps; ++i) {
+		FT_CharMap cmap = face-&gt;charmaps[i];
+		unsigned pid = cmap-&gt;platform_id;
+		unsigned eid = cmap-&gt;encoding_id;
+		if (pid == 3 /*microsoft*/ &amp;&amp; (eid == 1 /*unicode bmp*/ || eid == 10 /*full unicode*/)) {
+			FT_Set_Charmap(face, cmap);
+			return;
+		}
+	}
+
+	if (!face-&gt;charmap) {
+		if (face-&gt;num_charmaps == 0) {
+			mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_NoCharmaps);
+			return;
+		}
+		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_NoCharmapAutodetected);
+		FT_Set_Charmap(face, face-&gt;charmaps[0]);
+		return;
+	}
+}
+
+static void update_transform(ass_font_t* font)
+{
+	int i;
+	FT_Matrix m;
+	m.xx = double_to_d16(font-&gt;scale_x);
+	m.yy = double_to_d16(font-&gt;scale_y);
+	m.xy = m.yx = 0;
+	for (i = 0; i &lt; font-&gt;n_faces; ++i)
+		FT_Set_Transform(font-&gt;faces[i], &amp;m, &amp;font-&gt;v);
+}
+
+/**
+ * \brief find a memory font by name
+ */
+static int find_font(ass_library_t* library, char* name)
+{
+	int i;
+	for (i = 0; i &lt; library-&gt;num_fontdata; ++i)
+		if (strcasecmp(name, library-&gt;fontdata[i].name) == 0)
+			return i;
+	return -1;
+}
+
+/**
+ * \brief Create a new ass_font_t according to &quot;desc&quot; argument
+ */
+ass_font_t* ass_font_new(ass_library_t* library, FT_Library ftlibrary, void* fc_priv, ass_font_desc_t* desc)
+{
+	char* path;
+	int index;
+	FT_Face face;
+	int error;
+	ass_font_t* fontp;
+	ass_font_t font;
+	int mem_idx;
+
+	fontp = ass_font_cache_find(desc);
+	if (fontp)
+		return fontp;
+	
+	path = fontconfig_select(fc_priv, desc-&gt;family, desc-&gt;bold, desc-&gt;italic, &amp;index);
+	
+	mem_idx = find_font(library, path);
+	if (mem_idx &gt;= 0) {
+		error = FT_New_Memory_Face(ftlibrary, (unsigned char*)library-&gt;fontdata[mem_idx].data,
+					   library-&gt;fontdata[mem_idx].size, 0, &amp;face);
+		if (error) {
+			mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_ErrorOpeningMemoryFont, path);
+			return 0;
+		}
+	} else {
+		error = FT_New_Face(ftlibrary, path, index, &amp;face);
+		if (error) {
+			mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_ErrorOpeningFont, path, index);
+			return 0;
+		}
+	}
+
+	charmap_magic(face);
+	
+	font.ftlibrary = ftlibrary;
+	font.faces[0] = face;
+	font.n_faces = 1;
+	font.desc.family = strdup(desc-&gt;family);
+	font.desc.bold = desc-&gt;bold;
+	font.desc.italic = desc-&gt;italic;
+
+	font.scale_x = font.scale_y = 1.;
+	font.v.x = font.v.y = 0;
+	font.size = 0.;
+
+#ifdef HAVE_FONTCONFIG
+	font.charset = FcCharSetCreate();
+#endif
+
+	return ass_font_cache_add(&amp;font);
+}
+
+/**
+ * \brief Set font transformation matrix and shift vector
+ **/
+void ass_font_set_transform(ass_font_t* font, double scale_x, double scale_y, FT_Vector* v)
+{
+	font-&gt;scale_x = scale_x;
+	font-&gt;scale_y = scale_y;
+	font-&gt;v.x = v-&gt;x;
+	font-&gt;v.y = v-&gt;y;
+	update_transform(font);
+}
+
+static void face_set_size(FT_Face face, double size)
+{
+#if (FREETYPE_MAJOR &gt; 2) || ((FREETYPE_MAJOR == 2) &amp;&amp; (FREETYPE_MINOR &gt; 1))
+	TT_HoriHeader *hori = FT_Get_Sfnt_Table(face, ft_sfnt_hhea);
+	TT_OS2 *os2 = FT_Get_Sfnt_Table(face, ft_sfnt_os2);
+	double mscale = 1.;
+	FT_Size_RequestRec rq;
+	FT_Size_Metrics *m = &amp;face-&gt;size-&gt;metrics;
+	// VSFilter uses metrics from TrueType OS/2 table
+	// The idea was borrowed from asa (<A HREF="http://asa.diac24.net">http://asa.diac24.net</A>)
+	if (hori &amp;&amp; os2)
+		mscale = ((double)(hori-&gt;Ascender - hori-&gt;Descender)) / (os2-&gt;usWinAscent + os2-&gt;usWinDescent);
+	memset(&amp;rq, 0, sizeof(rq));
+	rq.type = FT_SIZE_REQUEST_TYPE_REAL_DIM;
+	rq.width = 0;
+	rq.height = double_to_d6(size * mscale);
+	rq.horiResolution = rq.vertResolution = 0;
+	FT_Request_Size(face, &amp;rq);
+	m-&gt;ascender /= mscale;
+	m-&gt;descender /= mscale;
+	m-&gt;height /= mscale;
+#else
+	FT_Set_Char_Size(face, 0, double_to_d6(size), 0, 0);
+#endif
+}
+
+/**
+ * \brief Set font size
+ **/
+void ass_font_set_size(ass_font_t* font, double size)
+{
+	int i;
+	if (font-&gt;size != size) {
+		font-&gt;size = size;
+		for (i = 0; i &lt; font-&gt;n_faces; ++i)
+			face_set_size(font-&gt;faces[i], size);
+	}
+}
+
+#ifdef HAVE_FONTCONFIG
+/**
+ * \brief Select a new FT_Face with the given character
+ * The new face is added to the end of font-&gt;faces.
+ **/
+static void ass_font_reselect(void* fontconfig_priv, ass_font_t* font, uint32_t ch)
+{
+	char* path;
+	int index;
+	FT_Face face;
+	int error;
+
+	if (font-&gt;n_faces == ASS_FONT_MAX_FACES)
+		return;
+	
+	path = fontconfig_select_with_charset(fontconfig_priv, font-&gt;desc.family, font-&gt;desc.bold,
+					      font-&gt;desc.italic, &amp;index, font-&gt;charset);
+
+	error = FT_New_Face(font-&gt;ftlibrary, path, index, &amp;face);
+	if (error) {
+		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_ErrorOpeningFont, path, index);
+		return;
+	}
+	charmap_magic(face);
+
+	error = FT_Get_Char_Index(face, ch);
+	if (error == 0) { // the new font face is not better then the old one
+		FT_Done_Face(face);
+		return;
+	}
+
+	font-&gt;faces[font-&gt;n_faces++] = face;
+	update_transform(font);
+	FT_Set_Pixel_Sizes(face, 0, (int)font-&gt;size);
+}
+#endif
+
+/**
+ * \brief Get maximal font ascender and descender.
+ * \param ch character code
+ * The values are extracted from the font face that provides glyphs for the given character
+ **/
+void ass_font_get_asc_desc(ass_font_t* font, uint32_t ch, int* asc, int* desc)
+{
+	int i;
+	for (i = 0; i &lt; font-&gt;n_faces; ++i) {
+		FT_Face face = font-&gt;faces[i];
+		if (FT_Get_Char_Index(face, ch)) {
+			int v, v2;
+			v = face-&gt;size-&gt;metrics.ascender;
+			v2 = FT_MulFix(face-&gt;bbox.yMax, face-&gt;size-&gt;metrics.y_scale);
+			*asc = (v &gt; v2 * 0.9) ? v : v2;
+				
+			v = - face-&gt;size-&gt;metrics.descender;
+			v2 = - FT_MulFix(face-&gt;bbox.yMin, face-&gt;size-&gt;metrics.y_scale);
+			*desc = (v &gt; v2 * 0.9) ? v : v2;
+			return;
+		}
+	}
+	
+	*asc = *desc = 0;
+}
+
+/**
+ * \brief Get a glyph
+ * \param ch character code
+ **/
+FT_Glyph ass_font_get_glyph(void* fontconfig_priv, ass_font_t* font, uint32_t ch, ass_hinting_t hinting)
+{
+	int error;
+	int index = 0;
+	int i;
+	FT_Glyph glyph;
+	FT_Face face = 0;
+	int flags = 0;
+
+	if (ch &lt; 0x20)
+		return 0;
+	if (font-&gt;n_faces == 0)
+		return 0;
+
+	for (i = 0; i &lt; font-&gt;n_faces; ++i) {
+		face = font-&gt;faces[i];
+		index = FT_Get_Char_Index(face, ch);
+		if (index)
+			break;
+	}
+
+#ifdef HAVE_FONTCONFIG
+	FcCharSetAddChar(font-&gt;charset, ch);
+	if (index == 0) {
+		mp_msg(MSGT_ASS, MSGL_INFO, MSGTR_LIBASS_GlyphNotFoundReselectingFont,
+		       ch, font-&gt;desc.family, font-&gt;desc.bold, font-&gt;desc.italic);
+		ass_font_reselect(fontconfig_priv, font, ch);
+		face = font-&gt;faces[font-&gt;n_faces - 1];
+		index = FT_Get_Char_Index(face, ch);
+		if (index == 0) {
+			mp_msg(MSGT_ASS, MSGL_ERR, MSGTR_LIBASS_GlyphNotFound,
+			       ch, font-&gt;desc.family, font-&gt;desc.bold, font-&gt;desc.italic);
+		}
+	}
+#endif
+
+	switch (hinting) {
+	case ASS_HINTING_NONE: flags = FT_LOAD_NO_HINTING; break;
+	case ASS_HINTING_LIGHT: flags = FT_LOAD_FORCE_AUTOHINT | FT_LOAD_TARGET_LIGHT; break;
+	case ASS_HINTING_NORMAL: flags = FT_LOAD_FORCE_AUTOHINT; break;
+	case ASS_HINTING_NATIVE: flags = 0; break;
+	}
+	
+	error = FT_Load_Glyph(face, index, FT_LOAD_NO_BITMAP | flags);
+	if (error) {
+		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_ErrorLoadingGlyph);
+		return 0;
+	}
+	
+#if (FREETYPE_MAJOR &gt; 2) || \
+    ((FREETYPE_MAJOR == 2) &amp;&amp; (FREETYPE_MINOR &gt;= 2)) || \
+    ((FREETYPE_MAJOR == 2) &amp;&amp; (FREETYPE_MINOR == 1) &amp;&amp; (FREETYPE_PATCH &gt;= 10))
+// FreeType &gt;= 2.1.10 required
+	if (!(face-&gt;style_flags &amp; FT_STYLE_FLAG_ITALIC) &amp;&amp; 
+			(font-&gt;desc.italic &gt; 55)) {
+		FT_GlyphSlot_Oblique(face-&gt;glyph);
+	}
+#endif
+	error = FT_Get_Glyph(face-&gt;glyph, &amp;glyph);
+	if (error) {
+		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_ErrorLoadingGlyph);
+		return 0;
+	}
+	
+	return glyph;
+}
+
+/**
+ * \brief Get kerning for the pair of glyphs.
+ **/
+FT_Vector ass_font_get_kerning(ass_font_t* font, uint32_t c1, uint32_t c2)
+{
+	FT_Vector v = {0, 0};
+	int i;
+
+	for (i = 0; i &lt; font-&gt;n_faces; ++i) {
+		FT_Face face = font-&gt;faces[i];
+		int i1 = FT_Get_Char_Index(face, c1);
+		int i2 = FT_Get_Char_Index(face, c2);
+		if (i1 &amp;&amp; i2) {
+			if (FT_HAS_KERNING(face))
+				FT_Get_Kerning(face, i1, i2, FT_KERNING_DEFAULT, &amp;v);
+			return v;
+		}
+		if (i1 || i2) // these glyphs are from different font faces, no kerning information
+			return v;
+	}
+	return v;
+}
+
+/**
+ * \brief Deallocate ass_font_t
+ **/
+void ass_font_free(ass_font_t* font)
+{
+	int i;
+	for (i = 0; i &lt; font-&gt;n_faces; ++i)
+		if (font-&gt;faces[i]) FT_Done_Face(font-&gt;faces[i]);
+	if (font-&gt;desc.family) free(font-&gt;desc.family);
+#ifdef HAVE_FONTCONFIG
+	if (font-&gt;charset) FcCharSetDestroy(font-&gt;charset);
+#endif
+	free(font);
+}

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/ass_font.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/ass_font.h	2007-07-13 17:01:23 UTC (rev 3361)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/ass_font.h	2007-07-14 08:27:37 UTC (rev 3362)
@@ -0,0 +1,57 @@
+// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
+// vim:ts=8:sw=8:noet:ai:
+/*
+  Copyright (C) 2006 Evgeniy Stepanov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">eugeni.stepanov at gmail.com</A>&gt;
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+*/
+
+#ifndef __ASS_FONT_H__
+#define __ASS_FONT_H__
+
+#ifdef HAVE_FONTCONFIG
+#include &lt;fontconfig/fontconfig.h&gt;
+#endif
+
+typedef struct ass_font_desc_s {
+	char* family;
+	unsigned bold;
+	unsigned italic;
+} ass_font_desc_t;
+
+#define ASS_FONT_MAX_FACES 10
+
+typedef struct ass_font_s {
+	ass_font_desc_t desc;
+	FT_Library ftlibrary;
+	FT_Face faces[ASS_FONT_MAX_FACES];
+	int n_faces;
+	double scale_x, scale_y; // current transform
+	FT_Vector v; // current shift
+	double size;
+#ifdef HAVE_FONTCONFIG
+	FcCharSet* charset;
+#endif
+} ass_font_t;
+
+ass_font_t* ass_font_new(ass_library_t* library, FT_Library ftlibrary, void* fc_priv, ass_font_desc_t* desc);
+void ass_font_set_transform(ass_font_t* font, double scale_x, double scale_y, FT_Vector* v);
+void ass_font_set_size(ass_font_t* font, double size);
+void ass_font_get_asc_desc(ass_font_t* font, uint32_t ch, int* asc, int* desc);
+FT_Glyph ass_font_get_glyph(void* fontconfig_priv, ass_font_t* font, uint32_t ch, ass_hinting_t hinting);
+FT_Vector ass_font_get_kerning(ass_font_t* font, uint32_t c1, uint32_t c2);
+void ass_font_free(ass_font_t* font);
+
+#endif

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/ass_fontconfig.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/ass_fontconfig.c	2007-07-13 17:01:23 UTC (rev 3361)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/ass_fontconfig.c	2007-07-14 08:27:37 UTC (rev 3362)
@@ -26,18 +26,20 @@
 #include &lt;string.h&gt;
 #include &lt;sys/types.h&gt;
 #include &lt;sys/stat.h&gt;
+#include &lt;inttypes.h&gt;
+#include &lt;ft2build.h&gt;
+#include FT_FREETYPE_H
 
 #include &quot;mputils.h&quot;
+#include &quot;ass.h&quot;
+#include &quot;ass_library.h&quot;
 #include &quot;ass_fontconfig.h&quot;
 
 #ifdef HAVE_FONTCONFIG
 #include &lt;fontconfig/fontconfig.h&gt;
+#include &lt;fontconfig/fcfreetype.h&gt;
 #endif
 
-#define ADM_LEGACY_PROGGY
-#include &quot;ADM_assert.h&quot;
-
-
 struct fc_instance_s {
 #ifdef HAVE_FONTCONFIG
 	FcConfig* config;
@@ -47,8 +49,6 @@
 	int index_default;
 };
 
-extern int no_more_font_messages;
-
 #ifdef HAVE_FONTCONFIG
 /**
  * \brief Low-level font selection.
@@ -57,22 +57,28 @@
  * \param bold font weight value
  * \param italic font slant value
  * \param index out: font index inside a file
+ * \param charset: contains the characters that should be present in the font, can be NULL
  * \return font file path
 */ 
-static char* _select_font(fc_instance_t* priv, const char* family, unsigned bold, unsigned italic, int* index)
+static char* _select_font(fc_instance_t* priv, const char* family, unsigned bold, unsigned italic, int* index,
+			  FcCharSet* charset)
 {
 	FcBool rc;
 	FcResult result;
-	FcPattern *pat, *rpat;
+	FcPattern *pat = 0, *rpat;
 	int val_i;
 	FcChar8* val_s;
 	FcBool val_b;
+	FcCharSet* val_cs;
+	FcFontSet* fset = 0;
+	int curf, bestf, bestdiff = 0;
+	char* retval = 0;
 	
 	*index = 0;
 
 	pat = FcPatternCreate();
 	if (!pat)
-		return 0;
+		goto error;
 	
 	FcPatternAddString(pat, FC_FAMILY, (const FcChar8*)family);
 	FcPatternAddBool(pat, FC_OUTLINE, FcTrue);
@@ -83,36 +89,67 @@
 	
 	rc = FcConfigSubstitute(priv-&gt;config, pat, FcMatchPattern);
 	if (!rc)
-		return 0;
+		goto error;
+
+	fset = FcFontSort(priv-&gt;config, pat, FcTrue, NULL, &amp;result);
+
+	bestf = -1;
+	if (charset)
+		bestdiff = FcCharSetCount(charset) + 1;
+	for (curf = 0; curf &lt; fset-&gt;nfont; ++curf) {
+		rpat = fset-&gt;fonts[curf];
+		
+		result = FcPatternGetBool(rpat, FC_OUTLINE, 0, &amp;val_b);
+		if (result != FcResultMatch)
+			continue;
+		if (val_b != FcTrue)
+			continue;
+
+		if (charset) {
+			int diff;
+			result = FcPatternGetCharSet(rpat, FC_CHARSET, 0, &amp;val_cs);
+			if (result != FcResultMatch)
+				continue;
+			diff = FcCharSetSubtractCount(charset, val_cs);
+			if (diff &lt; bestdiff) {
+				bestdiff = diff;
+				bestf = curf;
+			}
+ 			if (diff == 0)
+				break;
+		} else {
+			bestf = curf;
+			break;
+		}
+	}
+
+	if (bestf &lt; 0)
+		goto error;
+
+	rpat = fset-&gt;fonts[bestf];
 	
-	rpat = FcFontMatch(priv-&gt;config, pat, &amp;result);
-	if (!rpat)
-		return 0;
-	
-	result = FcPatternGetBool(rpat, FC_OUTLINE, 0, &amp;val_b);
-	if (result != FcResultMatch)
-		return 0;
-	if (val_b != FcTrue)
-		return 0;
-	
 	result = FcPatternGetInteger(rpat, FC_INDEX, 0, &amp;val_i);
 	if (result != FcResultMatch)
-		return 0;
+		goto error;
 	*index = val_i;
 
 	result = FcPatternGetString(rpat, FC_FAMILY, 0, &amp;val_s);
 	if (result != FcResultMatch)
-		return 0;
+		goto error;
 
 	if (strcasecmp((const char*)val_s, family) != 0)
-		mp_msg(MSGT_ASS, MSGL_WARN, &quot;fontconfig: selected font family is not the requested one: '%s' != '%s'\n&quot;,
+		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_SelectedFontFamilyIsNotTheRequestedOne,
 				(const char*)val_s, family);
 
 	result = FcPatternGetString(rpat, FC_FILE, 0, &amp;val_s);
 	if (result != FcResultMatch)
-		return 0;
+		goto error;
 	
-	return strdup((const char*)val_s);
+	retval = strdup((const char*)val_s);
+ error:
+	if (pat) FcPatternDestroy(pat);
+	if (fset) FcFontSetDestroy(fset);
+	return retval;
 }
 
 /**
@@ -122,30 +159,31 @@
  * \param bold font weight value
  * \param italic font slant value
  * \param index out: font index inside a file
+ * \param charset: contains the characters that should be present in the font, can be NULL
  * \return font file path
 */ 
-char* fontconfig_select(fc_instance_t* priv, const char* family, unsigned bold, unsigned italic, int* index)
+char* fontconfig_select_with_charset(fc_instance_t* priv, const char* family, unsigned bold, unsigned italic, int* index,
+			FcCharSet* charset)
 {
 	char* res = 0;
 	if (family &amp;&amp; *family)
-		res = _select_font(priv, family, bold, italic, index);
+		res = _select_font(priv, family, bold, italic, index, charset);
 	if (!res &amp;&amp; priv-&gt;family_default) {
-		res = _select_font(priv, priv-&gt;family_default, bold, italic, index);
-		if (res &amp;&amp; !no_more_font_messages)
-			mp_msg(MSGT_ASS, MSGL_WARN, &quot;fontconfig_select: using default font family: (%s, %d, %d) -&gt; %s, %d\n&quot;, 
+		res = _select_font(priv, priv-&gt;family_default, bold, italic, index, charset);
+		if (res)
+			mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_UsingDefaultFontFamily, 
 					family, bold, italic, res, *index);
 	}
 	if (!res &amp;&amp; priv-&gt;path_default) {
 		res = priv-&gt;path_default;
 		*index = priv-&gt;index_default;
-		if (!no_more_font_messages)
-			mp_msg(MSGT_ASS, MSGL_WARN, &quot;fontconfig_select: using default font: (%s, %d, %d) -&gt; %s, %d\n&quot;,
-					family, bold, italic, res, *index);
+		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_UsingDefaultFont, 
+		       family, bold, italic, res, *index);
 	}
 	if (!res) {
-		res = _select_font(priv, &quot;Arial&quot;, bold, italic, index);
-		if (res &amp;&amp; !no_more_font_messages)
-			mp_msg(MSGT_ASS, MSGL_WARN, &quot;fontconfig_select: using 'Arial' font family: (%s, %d, %d) -&gt; %s, %d\n&quot;,
+		res = _select_font(priv, &quot;Arial&quot;, bold, italic, index, charset);
+		if (res)
+			mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_UsingArialFontFamily, 
 					family, bold, italic, res, *index);
 	}
 	if (res)
@@ -154,35 +192,170 @@
 	return res;
 }
 
+char* fontconfig_select(fc_instance_t* priv, const char* family, unsigned bold, unsigned italic, int* index)
+{
+	return fontconfig_select_with_charset(priv, family, bold, italic, index, 0);
+}
+
+#if (FC_VERSION &lt; 20402)
+static char* validate_fname(char* name)
+{
+	char* fname;
+	char* p;
+	char* q;
+	unsigned code;
+	int sz = strlen(name);
+
+	q = fname = malloc(sz + 1);
+	p = name;
+	while (*p) {
+		code = utf8_get_char(&amp;p);
+		if (code == 0)
+			break;
+		if (	(code &gt; 0x7F) ||
+			(code == '\\') ||
+			(code == '/') ||
+			(code == ':') ||
+			(code == '*') ||
+			(code == '?') ||
+			(code == '&lt;') ||
+			(code == '&gt;') ||
+			(code == '|') ||
+			(code == 0))
+		{
+			*q++ = '_';
+		} else {
+			*q++ = code;
+		}
+		if (p - name &gt; sz)
+			break;
+	}
+	*q = 0;
+	return fname;
+}
+#endif
+
 /**
+ * \brief Process memory font.
+ * \param priv private data
+ * \param library library object
+ * \param ftlibrary freetype library object
+ * \param idx index of the processed font in library-&gt;fontdata
+ * With FontConfig &gt;= 2.4.2, builds a font pattern in memory via FT_New_Memory_Face/FcFreeTypeQueryFace.
+ * With older FontConfig versions, save the font to ~/.mplayer/fonts.
+*/ 
+static void process_fontdata(fc_instance_t* priv, ass_library_t* library, FT_Library ftlibrary, int idx)
+{
+	int rc;
+	const char* name = library-&gt;fontdata[idx].name;
+	const char* data = library-&gt;fontdata[idx].data;
+	int data_size = library-&gt;fontdata[idx].size;
+
+#if (FC_VERSION &lt; 20402)
+	struct stat st;
+	char* fname;
+	const char* fonts_dir = library-&gt;fonts_dir;
+	char buf[1000];
+	FILE* fp = 0;
+
+	if (!fonts_dir)
+		return;
+	rc = stat(fonts_dir, &amp;st);
+	if (rc) {
+		int res;
+#ifndef __MINGW32__
+		res = mkdir(fonts_dir, 0700);
+#else
+		res = mkdir(fonts_dir);
+#endif
+		if (res) {
+			mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FailedToCreateDirectory, fonts_dir);
+		}
+	} else if (!S_ISDIR(st.st_mode)) {
+		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_NotADirectory, fonts_dir);
+	}
+	
+	fname = validate_fname((char*)name);
+
+	snprintf(buf, 1000, &quot;%s/%s&quot;, fonts_dir, fname);
+	free(fname);
+
+	fp = fopen(buf, &quot;wb&quot;);
+	if (!fp) return;
+
+	fwrite(data, data_size, 1, fp);
+	fclose(fp);
+
+#else // (FC_VERSION &gt;= 20402)
+	FT_Face face;
+	FcPattern* pattern;
+	FcFontSet* fset;
+	FcBool res;
+
+	rc = FT_New_Memory_Face(ftlibrary, (unsigned char*)data, data_size, 0, &amp;face);
+	if (rc) {
+		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_ErrorOpeningMemoryFont, name);
+		return;
+	}
+
+	pattern = FcFreeTypeQueryFace(face, (unsigned char*)name, 0, FcConfigGetBlanks(priv-&gt;config));
+	if (!pattern) {
+		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FunctionCallFailed, &quot;FcFreeTypeQueryFace&quot;);
+		FT_Done_Face(face);
+		return;
+	}
+
+	fset = FcConfigGetFonts(priv-&gt;config, FcSetSystem); // somehow it failes when asked for FcSetApplication
+	if (!fset) {
+		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FunctionCallFailed, &quot;FcConfigGetFonts&quot;);
+		FT_Done_Face(face);
+		return;
+	}
+
+	res = FcFontSetAdd(fset, pattern);
+	if (!res) {
+		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FunctionCallFailed, &quot;FcFontSetAdd&quot;);
+		FT_Done_Face(face);
+		return;
+	}
+
+	FT_Done_Face(face);
+#endif
+}
+
+/**
  * \brief Init fontconfig.
- * \param dir additional directoryu for fonts
+ * \param library libass library object
+ * \param ftlibrary freetype library object
  * \param family default font family
  * \param path default font path
  * \return pointer to fontconfig private data
 */ 
-fc_instance_t* fontconfig_init(const char* dir, const char* family, const char* path)
+fc_instance_t* fontconfig_init(ass_library_t* library, FT_Library ftlibrary, const char* family, const char* path)
 {
 	int rc;
-	struct stat st;
-	fc_instance_t* priv = (fc_instance_t *)calloc(1, sizeof(fc_instance_t));
+	fc_instance_t* priv = calloc(1, sizeof(fc_instance_t));
+	const char* dir = library-&gt;fonts_dir;
+	int i;
 	
 	rc = FcInit();
 	assert(rc);
 
 	priv-&gt;config = FcConfigGetCurrent();
 	if (!priv-&gt;config) {
-		mp_msg(MSGT_ASS, MSGL_FATAL, &quot;FcInitLoadConfigAndFonts failed\n&quot;);
+		mp_msg(MSGT_ASS, MSGL_FATAL, MSGTR_LIBASS_FcInitLoadConfigAndFontsFailed);
 		return 0;
 	}
 
+	for (i = 0; i &lt; library-&gt;num_fontdata; ++i)
+		process_fontdata(priv, library, ftlibrary, i);
+
 	if (FcDirCacheValid((const FcChar8 *)dir) == FcFalse)
 	{
-		mp_msg(MSGT_ASS, MSGL_INFO, &quot;[ass] Updating font cache\n&quot;);
+		mp_msg(MSGT_ASS, MSGL_INFO, MSGTR_LIBASS_UpdatingFontCache);
 		if (FcGetVersion() &gt;= 20390 &amp;&amp; FcGetVersion() &lt; 20400)
 			mp_msg(MSGT_ASS, MSGL_WARN,
-			       &quot;[ass] beta versions of fontconfig are not supported\n&quot;
-			       &quot;      update before reporting any bugs\n&quot;);
+			       MSGTR_LIBASS_BetaVersionsOfFontconfigAreNotSupported);
 		// FontConfig &gt;= 2.4.0 updates cache automatically in FcConfigAppFontAddDir()
 		if (FcGetVersion() &lt; 20390) {
 			FcFontSet* fcs;
@@ -191,19 +364,19 @@
 			fss = FcStrSetCreate();
 			rc = FcStrSetAdd(fss, (const FcChar8*)dir);
 			if (!rc) {
-				mp_msg(MSGT_ASS, MSGL_WARN, &quot;FcStrSetAdd failed\n&quot;);
+				mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FcStrSetAddFailed);
 				goto ErrorFontCache;
 			}
 
 			rc = FcDirScan(fcs, fss, NULL, FcConfigGetBlanks(priv-&gt;config), (const FcChar8 *)dir, FcFalse);
 			if (!rc) {
-				mp_msg(MSGT_ASS, MSGL_WARN, &quot;FcDirScan failed\n&quot;);
+				mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FcDirScanFailed);
 				goto ErrorFontCache;
 			}
 
 			rc = FcDirSave(fcs, fss, (const FcChar8 *)dir);
 			if (!rc) {
-				mp_msg(MSGT_ASS, MSGL_WARN, &quot;FcDirSave failed\n&quot;);
+				mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FcDirSave);
 				goto ErrorFontCache;
 			}
 		ErrorFontCache:
@@ -213,22 +386,17 @@
 
 	rc = FcConfigAppFontAddDir(priv-&gt;config, (const FcChar8*)dir);
 	if (!rc) {
-		mp_msg(MSGT_ASS, MSGL_WARN, &quot;FcConfigAppFontAddDir failed\n&quot;);
+		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FcConfigAppFontAddDirFailed);
 	}
 
 	priv-&gt;family_default = family ? strdup(family) : 0;
+	priv-&gt;path_default = path ? strdup(path) : 0;
 	priv-&gt;index_default = 0;
-	
-	rc = stat(path, &amp;st);
-	if (!rc &amp;&amp; S_ISREG(st.st_mode))
-		priv-&gt;path_default = path ? strdup(path) : 0;
-	else
-		priv-&gt;path_default = 0;
 
 	return priv;
 }
 
-#else
+#else // HAVE_FONTCONFIG
 
 char* fontconfig_select(fc_instance_t* priv, const char* family, unsigned bold, unsigned italic, int* index)
 {
@@ -236,11 +404,11 @@
 	return priv-&gt;path_default;
 }
 
-fc_instance_t* fontconfig_init(const char* dir, const char* family, const char* path)
+fc_instance_t* fontconfig_init(ass_library_t* library, FT_Library ftlibrary, const char* family, const char* path)
 {
 	fc_instance_t* priv;
 
-	mp_msg(MSGT_ASS, MSGL_WARN, &quot;Fontconfig disabled, only default font will be used\n&quot;);
+	mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FontconfigDisabledDefaultFontWillBeUsed);
 	
 	priv = calloc(1, sizeof(fc_instance_t));
 	

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/ass_fontconfig.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/ass_fontconfig.h	2007-07-13 17:01:23 UTC (rev 3361)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/ass_fontconfig.h	2007-07-14 08:27:37 UTC (rev 3362)
@@ -21,11 +21,19 @@
 #ifndef __ASS_FONTCONFIG_H__
 #define __ASS_FONTCONFIG_H__
 
+#ifdef HAVE_FONTCONFIG
+#include &lt;fontconfig/fontconfig.h&gt;
+#endif
+
 typedef struct fc_instance_s fc_instance_t;
 
-fc_instance_t* fontconfig_init(const char* dir, const char* family, const char* path);
+fc_instance_t* fontconfig_init(ass_library_t* library, FT_Library ftlibrary, const char* family, const char* path);
 char* fontconfig_select(fc_instance_t* priv, const char* family, unsigned bold, unsigned italic, int* index);
 void fontconfig_done(fc_instance_t* priv);
 
+#ifdef HAVE_FONTCONFIG
+char* fontconfig_select_with_charset(fc_instance_t* priv, const char* family, unsigned bold, unsigned italic, int* index, FcCharSet* charset);
 #endif
 
+#endif
+

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/ass_library.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/ass_library.c	2007-07-13 17:01:23 UTC (rev 3361)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/ass_library.c	2007-07-14 08:27:37 UTC (rev 3362)
@@ -26,17 +26,19 @@
 #include &quot;ass.h&quot;
 #include &quot;ass_library.h&quot;
 
-#define ADM_LEGACY_PROGGY
-#include &quot;ADM_assert.h&quot;
 
 ass_library_t* ass_library_init(void)
 {
-	return (ass_library_t *) calloc(1, sizeof(ass_library_t));
+	return calloc(1, sizeof(ass_library_t));
 }
 
 void ass_library_done(ass_library_t* priv)
 {
-	if (priv) free(priv);
+	if (priv) {
+		ass_set_fonts_dir(priv, NULL);
+		ass_set_style_overrides(priv, NULL);
+		free(priv);
+	}
 }
 
 void ass_set_fonts_dir(ass_library_t* priv, const char* fonts_dir)
@@ -68,8 +70,24 @@
 
 	for (p = list, cnt = 0; *p; ++p, ++cnt) {}
 
-	priv-&gt;style_overrides = (char **)malloc((cnt + 1) * sizeof(char*));
+	priv-&gt;style_overrides = malloc((cnt + 1) * sizeof(char*));
 	for (p = list, q = priv-&gt;style_overrides; *p; ++p, ++q)
 		*q = strdup(*p);
 	priv-&gt;style_overrides[cnt] = NULL;
 }
+
+static void grow_array(void **array, int nelem, size_t elsize)
+{
+	if (!(nelem &amp; 31))
+		*array = realloc(*array, (nelem + 32) * elsize);
+}
+
+void ass_add_font(ass_library_t* priv, char* name, char* data, int size)
+{
+	grow_array((void**)&amp;priv-&gt;fontdata, priv-&gt;num_fontdata, sizeof(*priv-&gt;fontdata));
+	priv-&gt;fontdata[priv-&gt;num_fontdata].name = name;
+	priv-&gt;fontdata[priv-&gt;num_fontdata].data = data;
+	priv-&gt;fontdata[priv-&gt;num_fontdata].size = size;
+	priv-&gt;num_fontdata ++;
+}
+

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/ass_library.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/ass_library.h	2007-07-13 17:01:23 UTC (rev 3361)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/ass_library.h	2007-07-14 08:27:37 UTC (rev 3362)
@@ -21,10 +21,19 @@
 #ifndef __ASS_LIBRARY_H__
 #define __ASS_LIBRARY_H__
 
+typedef struct ass_fontdata_s {
+	char* name;
+	char* data;
+	int size;
+} ass_fontdata_t;
+
 struct ass_library_s {
 	char* fonts_dir;
 	int extract_fonts;
 	char** style_overrides;
+
+	ass_fontdata_t* fontdata;
+	int num_fontdata;
 };
 
 #endif

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/ass_render.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/ass_render.c	2007-07-13 17:01:23 UTC (rev 3361)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/ass_render.c	2007-07-14 08:27:37 UTC (rev 3362)
@@ -32,16 +32,13 @@
 #include &quot;mputils.h&quot;
 
 #include &quot;ass.h&quot;
+#include &quot;ass_font.h&quot;
 #include &quot;ass_bitmap.h&quot;
 #include &quot;ass_cache.h&quot;
 #include &quot;ass_utils.h&quot;
 #include &quot;ass_fontconfig.h&quot;
 #include &quot;ass_library.h&quot;
 
-#define ADM_LEGACY_PROGGY
-#include &quot;ADM_assert.h&quot;
-
-
 #define MAX_GLYPHS 1000
 #define MAX_LINES 100
 
@@ -59,11 +56,21 @@
 	int use_margins; // 0 - place all subtitles inside original frame
 	                 // 1 - use margins for placing toptitles and subtitles
 	double aspect; // frame aspect ratio, d_width / d_height.
+	ass_hinting_t hinting;
 
 	char* default_font;
 	char* default_family;
 } ass_settings_t;
 
+// a rendered event
+typedef struct event_images_s {
+	ass_image_t* imgs;
+	int top, height;
+	int detect_collisions;
+	int shift_direction;
+	ass_event_t* event;
+} event_images_t;
+
 struct ass_renderer_s {
 	ass_library_t* library;
 	FT_Library ftlibrary;
@@ -73,10 +80,12 @@
 	ass_synth_priv_t* synth_priv;
 
 	ass_image_t* images_root; // rendering result is stored here
+	ass_image_t* prev_images_root;
+
+	event_images_t* eimg; // temporary buffer for sorting rendered events
+	int eimg_size; // allocated buffer size
 };
 
-int no_more_font_messages = 0;  // don't print font warnings
-
 typedef enum {EF_NONE = 0, EF_KARAOKE, EF_KARAOKE_KF, EF_KARAOKE_KO} effect_t;
 
 // describes a glyph
@@ -102,9 +111,9 @@
 //	int height;
 	int be; // blur edges
 	int shadow;
-	double frz; // z-axis rotation
+	double frx, fry, frz; // rotation
 	
-	glyph_hash_key_t hash_key;
+	bitmap_hash_key_t hash_key;
 } glyph_info_t;
 
 typedef struct line_info_s {
@@ -122,34 +131,27 @@
 
 // Renderer state.
 // Values like current font face, color, screen position, clipping and so on are stored here.
-typedef enum 
-{	EVENT_NORMAL, // &quot;normal&quot; top-, sub- or mid- title
-		EVENT_POSITIONED, // happens after pos(,), margins are ignored
-		EVENT_HSCROLL, // &quot;Banner&quot; transition effect, text_width is unlimited
-		EVENT_VSCROLL // &quot;Scroll up&quot;, &quot;Scroll down&quot; transition effects
-		}EVENT_X;
-typedef enum 
-{ SCROLL_LR, // left-to-right
-	       SCROLL_RL,
-	       SCROLL_TB, // top-to-bottom
-	       SCROLL_BT
-	       }SCROLL_TYPE;                    
 typedef struct render_context_s {
 	ass_event_t* event;
 	ass_style_t* style;
 	
-	FT_Face face;
+	ass_font_t* font;
 	char* font_path;
-	int font_size;
+	double font_size;
 	
 	FT_Stroker stroker;
 	int alignment; // alignment overrides go here; if zero, style value will be used
-	double rotation;
-	EVENT_X  evt_type;
+	double frx, fry, frz;
+	enum {	EVENT_NORMAL, // &quot;normal&quot; top-, sub- or mid- title
+		EVENT_POSITIONED, // happens after pos(,), margins are ignored
+		EVENT_HSCROLL, // &quot;Banner&quot; transition effect, text_width is unlimited
+		EVENT_VSCROLL // &quot;Scroll up&quot;, &quot;Scroll down&quot; transition effects
+		} evt_type;
 	int pos_x, pos_y; // position
 	int org_x, org_y; // origin
+	char have_origin; // origin is explicitly defined; if 0, get_base_point() is used
 	double scale_x, scale_y;
-	int hspacing; // distance between letters, in pixels
+	double hspacing; // distance between letters, in pixels
 	double border; // outline width
 	uint32_t c[4]; // colors(Primary, Secondary, so on) in RGBA
 	int clip_x0, clip_y0, clip_x1, clip_y1;
@@ -162,7 +164,11 @@
 	int effect_timing;
 	int effect_skip_timing;
 
-	SCROLL_TYPE scroll_direction; // for EVENT_HSCROLL, EVENT_VSCROLL
+	enum { SCROLL_LR, // left-to-right
+	       SCROLL_RL,
+	       SCROLL_TB, // top-to-bottom
+	       SCROLL_BT
+	       } scroll_direction; // for EVENT_HSCROLL, EVENT_VSCROLL
 	int scroll_shift;
 
 	// face properties
@@ -191,15 +197,6 @@
 static render_context_t render_context;
 static frame_context_t frame_context;
 
-// a rendered event
-typedef struct event_images_s {
-	ass_image_t* imgs;
-	int top, height;
-	int detect_collisions;
-	int shift_direction;
-	ass_event_t* event;
-} event_images_t;
-
 struct render_priv_s {
 	int top, height;
 	int render_id;
@@ -211,7 +208,7 @@
 	if (track-&gt;PlayResX &amp;&amp; track-&gt;PlayResY)
 		return;
 	if (!track-&gt;PlayResX &amp;&amp; !track-&gt;PlayResY) {
-		mp_msg(MSGT_ASS, MSGL_WARN, &quot;Neither PlayResX nor PlayResY defined. Assuming 384x288.  \n&quot;);
+		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_NeitherPlayResXNorPlayResYDefined);
 		track-&gt;PlayResX = 384;
 		track-&gt;PlayResY = 288;
 	} else {
@@ -219,10 +216,10 @@
 			frame_context.orig_height / frame_context.width;
 		if (!track-&gt;PlayResY) {
 			track-&gt;PlayResY = track-&gt;PlayResX / orig_aspect + .5;
-			mp_msg(MSGT_ASS, MSGL_WARN, &quot;PlayResY undefined, setting %d  \n&quot;, track-&gt;PlayResY);
+			mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_PlayResYUndefinedSettingY, track-&gt;PlayResY);
 		} else if (!track-&gt;PlayResX) {
 			track-&gt;PlayResX = track-&gt;PlayResY * orig_aspect + .5;
-			mp_msg(MSGT_ASS, MSGL_WARN, &quot;PlayResX undefined, setting %d  \n&quot;, track-&gt;PlayResX);
+			mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_PlayResXUndefinedSettingX, track-&gt;PlayResX);
 		}
 	}
 }
@@ -233,20 +230,17 @@
 	FT_Library ft;
 	ass_renderer_t* priv = 0;
 	
-        
-        {
-          memset(&amp;render_context, 0, sizeof(render_context));
-          memset(&amp;frame_context, 0, sizeof(frame_context));
-          memset(&amp;text_info, 0, sizeof(text_info));
-        }
-        
+	memset(&amp;render_context, 0, sizeof(render_context));
+	memset(&amp;frame_context, 0, sizeof(frame_context));
+	memset(&amp;text_info, 0, sizeof(text_info));
+
 	error = FT_Init_FreeType( &amp;ft );
 	if ( error ) { 
-		mp_msg(MSGT_ASS, MSGL_FATAL, &quot;FT_Init_FreeType failed\n&quot;);
+		mp_msg(MSGT_ASS, MSGL_FATAL, MSGTR_LIBASS_FT_Init_FreeTypeFailed);
 		goto ass_init_exit;
 	}
 
-	priv = (ass_renderer_t *)calloc(1, sizeof(ass_renderer_t));
+	priv = calloc(1, sizeof(ass_renderer_t));
 	if (!priv) {
 		FT_Done_FreeType(ft);
 		goto ass_init_exit;
@@ -258,21 +252,23 @@
 	priv-&gt;ftlibrary = ft;
 	// images_root and related stuff is zero-filled in calloc
 	
-	ass_face_cache_init();
+	ass_font_cache_init();
+	ass_bitmap_cache_init();
 	ass_glyph_cache_init();
 
-	text_info.glyphs = (glyph_info_t *)calloc(MAX_GLYPHS, sizeof(glyph_info_t));
+	text_info.glyphs = calloc(MAX_GLYPHS, sizeof(glyph_info_t));
 	
 ass_init_exit:
-	if (priv) mp_msg(MSGT_ASS, MSGL_INFO, &quot;[ass] Init\n&quot;);
-	else mp_msg(MSGT_ASS, MSGL_ERR, &quot;[ass] Init failed\n&quot;);
+	if (priv) mp_msg(MSGT_ASS, MSGL_INFO, MSGTR_LIBASS_Init);
+	else mp_msg(MSGT_ASS, MSGL_ERR, MSGTR_LIBASS_InitFailed);
 
 	return priv;
 }
 
 void ass_renderer_done(ass_renderer_t* priv)
 {
-	ass_face_cache_done();
+	ass_font_cache_done();
+	ass_bitmap_cache_done();
 	ass_glyph_cache_done();
 	if (render_context.stroker) {
 		FT_Stroker_Done(render_context.stroker);
@@ -281,23 +277,18 @@
 	if (priv &amp;&amp; priv-&gt;ftlibrary) FT_Done_FreeType(priv-&gt;ftlibrary);
 	if (priv &amp;&amp; priv-&gt;fontconfig_priv) fontconfig_done(priv-&gt;fontconfig_priv);
 	if (priv &amp;&amp; priv-&gt;synth_priv) ass_synth_done(priv-&gt;synth_priv);
+	if (priv &amp;&amp; priv-&gt;eimg) free(priv-&gt;eimg);
 	if (priv) free(priv);
-        priv=NULL;
-        
-        {
-	 if (text_info.glyphs) free(text_info.glyphs);
-          text_info.glyphs=NULL;
-        }
-        
+	if (text_info.glyphs) free(text_info.glyphs);
 }
 
 /**
  * \brief Create a new ass_image_t
  * Parameters are the same as ass_image_t fields.
  */
-ass_image_t* my_draw_bitmap(unsigned char* bitmap, int bitmap_w, int bitmap_h, int stride, int dst_x, int dst_y, uint32_t color)
+static ass_image_t* my_draw_bitmap(unsigned char* bitmap, int bitmap_w, int bitmap_h, int stride, int dst_x, int dst_y, uint32_t color)
 {
-	ass_image_t* img = (ass_image_t *)calloc(1, sizeof(ass_image_t));
+	ass_image_t* img = calloc(1, sizeof(ass_image_t));
 	
 	img-&gt;w = bitmap_w;
 	img-&gt;h = bitmap_h;
@@ -322,7 +313,7 @@
  * \return pointer to the new list tail
  * Performs clipping. Uses my_draw_bitmap for actual bitmap convertion.
  */
-ass_image_t** render_glyph(bitmap_t* bm, int dst_x, int dst_y, uint32_t color, uint32_t color2, int brk, ass_image_t** tail)
+static ass_image_t** render_glyph(bitmap_t* bm, int dst_x, int dst_y, uint32_t color, uint32_t color2, int brk, ass_image_t** tail)
 {
 	// brk is relative to dst_x
 	// color = color left of brk
@@ -390,45 +381,18 @@
 }
 
 /**
- * \brief Render text_info_t struct into ass_images_t list
- * Rasterize glyphs and put them in glyph cache.
+ * \brief Convert text_info_t struct to ass_image_t list
+ * Splits glyphs in halves when needed (for \kf karaoke).
  */
-ass_image_t* render_text(text_info_t* text_info, int dst_x, int dst_y)
+static ass_image_t* render_text(text_info_t* text_info, int dst_x, int dst_y)
 {
 	int pen_x, pen_y;
-	int i, error;
+	int i;
 	bitmap_t* bm;
-	glyph_hash_val_t hash_val;
 	ass_image_t* head;
 	ass_image_t** tail = &head;
 
 	for (i = 0; i &lt; text_info-&gt;length; ++i) {
-		if (text_info-&gt;glyphs[i].glyph) {
-			if ((text_info-&gt;glyphs[i].symbol == '\n') || (text_info-&gt;glyphs[i].symbol == 0))
-				continue;
-			error = glyph_to_bitmap(ass_renderer-&gt;synth_priv,
-					text_info-&gt;glyphs[i].glyph, text_info-&gt;glyphs[i].outline_glyph,
-					&amp;text_info-&gt;glyphs[i].bm, &amp;text_info-&gt;glyphs[i].bm_o,
-					&amp;text_info-&gt;glyphs[i].bm_s, text_info-&gt;glyphs[i].be);
-			if (error)
-				text_info-&gt;glyphs[i].symbol = 0;
-			FT_Done_Glyph(text_info-&gt;glyphs[i].glyph);
-			if (text_info-&gt;glyphs[i].outline_glyph)
-				FT_Done_Glyph(text_info-&gt;glyphs[i].outline_glyph);
-
-			// cache
-			hash_val.bbox_scaled = text_info-&gt;glyphs[i].bbox;
-			hash_val.bm_o = text_info-&gt;glyphs[i].bm_o;
-			hash_val.bm = text_info-&gt;glyphs[i].bm;
-			hash_val.bm_s = text_info-&gt;glyphs[i].bm_s;
-			hash_val.advance.x = text_info-&gt;glyphs[i].advance.x;
-			hash_val.advance.y = text_info-&gt;glyphs[i].advance.y;
-			cache_add_glyph(&amp;(text_info-&gt;glyphs[i].hash_key), &amp;hash_val);
-
-		}
-	}
-
-	for (i = 0; i &lt; text_info-&gt;length; ++i) {
 		glyph_info_t* info = text_info-&gt;glyphs + i;
 		if ((info-&gt;symbol == 0) || (info-&gt;symbol == '\n') || !info-&gt;bm_s || (info-&gt;shadow == 0))
 			continue;
@@ -513,12 +477,12 @@
 	if (text_info.length &gt; 0) {
 		bbox.xMin = 32000;
 		bbox.xMax = -32000;
-		bbox.yMin = - (text_info.lines[0].asc &gt;&gt; 6) + text_info.glyphs[0].pos.y;
-		bbox.yMax = ((text_info.height - text_info.lines[0].asc) &gt;&gt; 6) + text_info.glyphs[0].pos.y;
+		bbox.yMin = - d6_to_int(text_info.lines[0].asc) + text_info.glyphs[0].pos.y;
+		bbox.yMax = d6_to_int(text_info.height - text_info.lines[0].asc) + text_info.glyphs[0].pos.y;
 
 		for (i = 0; i &lt; text_info.length; ++i) {
 			int s = text_info.glyphs[i].pos.x;
-			int e = s + (text_info.glyphs[i].advance.x &gt;&gt; 6);
+			int e = s + d6_to_int(text_info.glyphs[i].advance.x);
 			bbox.xMin = FFMIN(bbox.xMin, s);
 			bbox.xMax = FFMAX(bbox.xMax, e);
 		}
@@ -542,9 +506,7 @@
 		return 0;
 }
 
-double ass_internal_font_size_coeff = 0.8;
-
-static void change_font_size(int sz)
+static void change_font_size(double sz)
 {
 	double size = sz * frame_context.font_scale;
 
@@ -552,9 +514,9 @@
 		size = 1;
 	else if (size &gt; frame_context.height * 2)
 		size = frame_context.height * 2;
-	
-	FT_Set_Pixel_Sizes(render_context.face, 0, size);
 
+	ass_font_set_size(render_context.font, size);
+
 	render_context.font_size = sz;
 }
 
@@ -563,10 +525,9 @@
  */
 static void update_font(void)
 {
-	int error;
 	unsigned val;
 	ass_renderer_t* priv = frame_context.ass_priv;
-	face_desc_t desc;
+	ass_font_desc_t desc;
 	desc.family = strdup(render_context.family);
 
 	val = render_context.bold;
@@ -580,12 +541,10 @@
 	else if (val == 1) val = 110; //italic
 	desc.italic = val;
 
-	error = ass_new_face(priv-&gt;ftlibrary, priv-&gt;fontconfig_priv, &amp;desc, &amp;(render_context.face));
-	if (error) {
-		render_context.face = 0;
-	}
+	render_context.font = ass_font_new(priv-&gt;library, priv-&gt;ftlibrary, priv-&gt;fontconfig_priv, &amp;desc);
+	free(desc.family);
 	
-	if (render_context.face)
+	if (render_context.font)
 		change_font_size(render_context.font_size);
 }
 
@@ -596,7 +555,7 @@
 static void change_border(double border)
 {
 	int b;
-	if (!render_context.face) return;
+	if (!render_context.font) return;
 
 	if (border &lt; 0) {
 		if (render_context.style-&gt;BorderStyle == 1) {
@@ -616,7 +575,7 @@
 #if (FREETYPE_MAJOR &gt; 2) || ((FREETYPE_MAJOR == 2) &amp;&amp; (FREETYPE_MINOR &gt; 1))
 			error = FT_Stroker_New( ass_renderer-&gt;ftlibrary, &amp;render_context.stroker );
 #else // &lt; 2.2
-			error = FT_Stroker_New( render_context.face-&gt;memory, &amp;render_context.stroker );
+			error = FT_Stroker_New( render_context.font-&gt;faces[0]-&gt;memory, &amp;render_context.stroker );
 #endif
 			if (error) {
 				mp_msg(MSGT_ASS, MSGL_V, &quot;failed to get stroker\n&quot;);
@@ -643,18 +602,18 @@
  * \brief Calculate a weighted average of two colors
  * calculates c1*(1-a) + c2*a, but separately for each component except alpha
  */
-static void change_color(uint32_t* var, uint32_t nzew, double pwr)
+static void change_color(uint32_t* var, uint32_t new, double pwr)
 {
-	(*var)= ((uint32_t)(_r(*var) * (1 - pwr) + _r(nzew) * pwr) &lt;&lt; 24) +
-		((uint32_t)(_g(*var) * (1 - pwr) + _g(nzew) * pwr) &lt;&lt; 16) +
-		((uint32_t)(_b(*var) * (1 - pwr) + _b(nzew) * pwr) &lt;&lt; 8) +
+	(*var)= ((uint32_t)(_r(*var) * (1 - pwr) + _r(new) * pwr) &lt;&lt; 24) +
+		((uint32_t)(_g(*var) * (1 - pwr) + _g(new) * pwr) &lt;&lt; 16) +
+		((uint32_t)(_b(*var) * (1 - pwr) + _b(new) * pwr) &lt;&lt; 8) +
 		_a(*var);
 }
 
 // like change_color, but for alpha component only
-static void change_alpha(uint32_t* var, uint32_t nzew, double pwr)
+static void change_alpha(uint32_t* var, uint32_t new, double pwr)
 {
-	*var = (_r(*var) &lt;&lt; 24) + (_g(*var) &lt;&lt; 16) + (_b(*var) &lt;&lt; 8) + (_a(*var) * (1 - pwr) + _a(nzew) * pwr);
+	*var = (_r(*var) &lt;&lt; 24) + (_g(*var) &lt;&lt; 16) + (_b(*var) &lt;&lt; 8) + (_a(*var) * (1 - pwr) + _a(new) * pwr);
 }
 
 /**
@@ -696,7 +655,7 @@
 	return a;
 }
 
-static void reset_render_context();
+static void reset_render_context(void);
 
 /**
  * \brief Parse style override tag.
@@ -718,29 +677,29 @@
 		if (tp == 'x') {
 			if (mystrtod(&amp;p, &amp;val)) {
 				val /= 100;
-				render_context.scale_x = (val - 1.) * pwr + 1.;
+				render_context.scale_x = render_context.scale_x * ( 1 - pwr) + val * pwr;
 			} else
 				render_context.scale_x = render_context.style-&gt;ScaleX;
 		} else if (tp == 'y') {
 			if (mystrtod(&amp;p, &amp;val)) {
 				val /= 100;
-				render_context.scale_y = (val - 1.) * pwr + 1.;
+				render_context.scale_y = render_context.scale_y * ( 1 - pwr) + val * pwr;
 			} else
 				render_context.scale_y = render_context.style-&gt;ScaleY;
 		}
 	} else if (mystrcmp(&amp;p, &quot;fsp&quot;)) {
-		int val;
-		if (mystrtoi(&amp;p, 10, &amp;val))
-			render_context.hspacing = val * pwr;
+		double val;
+		if (mystrtod(&amp;p, &amp;val))
+			render_context.hspacing = render_context.hspacing * ( 1 - pwr ) + val * pwr;
 		else
-			render_context.hspacing = 0;
+			render_context.hspacing = render_context.style-&gt;Spacing;
 	} else if (mystrcmp(&amp;p, &quot;fs&quot;)) {
-		int val;
-		if (mystrtoi(&amp;p, 10, &amp;val))
+		double val;
+		if (mystrtod(&amp;p, &amp;val))
 			val = render_context.font_size * ( 1 - pwr ) + val * pwr;
 		else
 			val = render_context.style-&gt;FontSize;
-		if (render_context.face)
+		if (render_context.font)
 			change_font_size(val);
 	} else if (mystrcmp(&amp;p, &quot;bord&quot;)) {
 		double val;
@@ -767,8 +726,8 @@
 			t1 = strtoll(p, &amp;p, 10);
 			skip(',');
 			t2 = strtoll(p, &amp;p, 10);
-//			mp_msg(MSGT_ASS, MSGL_DBG2, &quot;movement6: (%d, %d) -&gt; (%d, %d), (%&quot; PRId64 &quot; .. %&quot; PRId64 &quot;)\n&quot;, 
-//				x1, y1, x2, y2, (int64_t)t1, (int64_t)t2);
+			mp_msg(MSGT_ASS, MSGL_DBG2, &quot;movement6: (%d, %d) -&gt; (%d, %d), (%&quot; PRId64 &quot; .. %&quot; PRId64 &quot;)\n&quot;, 
+				x1, y1, x2, y2, (int64_t)t1, (int64_t)t2);
 		} else {
 			t1 = 0;
 			t2 = render_context.event-&gt;Duration;
@@ -788,24 +747,37 @@
 		render_context.pos_y = y;
 		render_context.detect_collisions = 0;
 		render_context.evt_type = EVENT_POSITIONED;
-	} else if (mystrcmp(&amp;p, &quot;frx&quot;) || mystrcmp(&amp;p, &quot;fry&quot;)) {
+	} else if (mystrcmp(&amp;p, &quot;frx&quot;)) {
 		double val;
-		mystrtod(&amp;p, &amp;val);
-		mp_msg(MSGT_ASS, MSGL_V, &quot;frx/fry unimplemented \n&quot;);
+		if (mystrtod(&amp;p, &amp;val)) {
+			val *= M_PI / 180;
+			render_context.frx = val * pwr + render_context.frx * (1-pwr);
+		} else
+			render_context.frx = 0.;
+	} else if (mystrcmp(&amp;p, &quot;fry&quot;)) {
+		double val;
+		if (mystrtod(&amp;p, &amp;val)) {
+			val *= M_PI / 180;
+			render_context.fry = val * pwr + render_context.fry * (1-pwr);
+		} else
+			render_context.fry = 0.;
 	} else if (mystrcmp(&amp;p, &quot;frz&quot;) || mystrcmp(&amp;p, &quot;fr&quot;)) {
-		double angle;
 		double val;
-		mystrtod(&amp;p, &amp;val);
-		mp_msg(MSGT_ASS, MSGL_DBG2, &quot;setting rotation to %.2f\n&quot;, val * pwr);
-		angle = M_PI * val / 180;
-		render_context.rotation = angle * pwr;
+		if (mystrtod(&amp;p, &amp;val)) {
+			val *= M_PI / 180;
+			render_context.frz = val * pwr + render_context.frz * (1-pwr);
+		} else
+			render_context.frz = M_PI * render_context.style-&gt;Angle / 180.;
 	} else if (mystrcmp(&amp;p, &quot;fn&quot;)) {
 		char* start = p;
 		char* family;
 		skip_all('\\');
-		family = (char *)malloc(p - start + 1);
-		strncpy(family, start, p - start);
-		family[p - start] = '\0';
+		if (p &gt; start) {
+			family = malloc(p - start + 1);
+			strncpy(family, start, p - start);
+			family[p - start] = '\0';
+		} else
+			family = strdup(render_context.style-&gt;FontName);
 		if (render_context.family)
 			free(render_context.family);
 		render_context.family = family;
@@ -825,17 +797,23 @@
 		}
 		// FIXME: simplify
 	} else if (mystrcmp(&amp;p, &quot;an&quot;)) {
-		int val = strtol(p, &amp;p, 10);
-		int v = (val - 1) / 3; // 0, 1 or 2 for vertical alignment
-		mp_msg(MSGT_ASS, MSGL_DBG2, &quot;an %d\n&quot;, val);
-		if (v != 0) v = 3 - v;
-		val = ((val - 1) % 3) + 1; // horizontal alignment
-		val += v*4;
-		mp_msg(MSGT_ASS, MSGL_DBG2, &quot;align %d\n&quot;, val);
-		render_context.alignment = val;
+		int val;
+		if (mystrtoi(&amp;p, 10, &amp;val) &amp;&amp; val) {
+			int v = (val - 1) / 3; // 0, 1 or 2 for vertical alignment
+			mp_msg(MSGT_ASS, MSGL_DBG2, &quot;an %d\n&quot;, val);
+			if (v != 0) v = 3 - v;
+			val = ((val - 1) % 3) + 1; // horizontal alignment
+			val += v*4;
+			mp_msg(MSGT_ASS, MSGL_DBG2, &quot;align %d\n&quot;, val);
+			render_context.alignment = val;
+		} else
+			render_context.alignment = render_context.style-&gt;Alignment;
 	} else if (mystrcmp(&amp;p, &quot;a&quot;)) {
-		int val = strtol(p, &amp;p, 10);
-		render_context.alignment = val;
+		int val;
+		if (mystrtoi(&amp;p, 10, &amp;val) &amp;&amp; val)
+			render_context.alignment = val;
+		else
+			render_context.alignment = render_context.style-&gt;Alignment;
 	} else if (mystrcmp(&amp;p, &quot;pos&quot;)) {
 		int v1, v2;
 		skip('(');
@@ -893,6 +871,7 @@
 		//				render_context.evt_type = EVENT_POSITIONED;
 		render_context.org_x = v1;
 		render_context.org_y = v2;
+		render_context.have_origin = 1;
 	} else if (mystrcmp(&amp;p, &quot;t&quot;)) {
 		double v[3];
 		int v1, v2;
@@ -923,11 +902,14 @@
 		if (v3 &lt; 0.)
 			v3 = 0.;
 		t = frame_context.time - render_context.event-&gt;Start; // FIXME: move to render_context
-		if (t &lt; t1)
+		if (t &lt;= t1)
 			k = 0.;
-		else if (t &gt; t2)
+		else if (t &gt;= t2)
 			k = 1.;
-		else k = pow(((double)(t - t1)) / delta_t, v3);
+		else {
+			assert(delta_t != 0.);
+			k = pow(((double)(t - t1)) / delta_t, v3);
+		}
 		while (*p == '\\')
 			p = parse_tag(p, k); // maybe k*pwr ? no, specs forbid nested \t's 
 		skip_all(')'); // FIXME: better skip(')'), but much more tags support required
@@ -977,7 +959,7 @@
 		switch (cmd) {
 			case 'c': change_color(render_context.c + cidx, val, pwr); break;
 			case 'a': change_alpha(render_context.c + cidx, val &gt;&gt; 24, pwr); break;
-			default: mp_msg(MSGT_ASS, MSGL_WARN, &quot;Bad command: %c%c\n&quot;, n, cmd); break;
+			default: mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_BadCommand, n, cmd); break;
 		}
 		mp_msg(MSGT_ASS, MSGL_DBG2, &quot;single c/a at %f: %c%c = %X   \n&quot;, pwr, n, cmd, render_context.c[cidx]);
 	} else if (mystrcmp(&amp;p, &quot;r&quot;)) {
@@ -990,17 +972,19 @@
 			render_context.be = 0;
 	} else if (mystrcmp(&amp;p, &quot;b&quot;)) {
 		int b;
-		if (mystrtoi(&amp;p, 10, &amp;b))
-			render_context.bold = b;
-		else
-			render_context.bold = - render_context.style-&gt;Bold;
+		if (mystrtoi(&amp;p, 10, &amp;b)) {
+			if (pwr &gt;= .5)
+				render_context.bold = b;
+		} else
+			render_context.bold = render_context.style-&gt;Bold;
 		update_font();
 	} else if (mystrcmp(&amp;p, &quot;i&quot;)) {
 		int i;
-		if (mystrtoi(&amp;p, 10, &amp;i))
-			render_context.italic = i;
-		else
-			render_context.italic = - render_context.style-&gt;Italic;
+		if (mystrtoi(&amp;p, 10, &amp;i)) {
+			if (pwr &gt;= .5)
+				render_context.italic = i;
+		} else
+			render_context.italic = render_context.style-&gt;Italic;
 		update_font();
 	} else if (mystrcmp(&amp;p, &quot;kf&quot;) || mystrcmp(&amp;p, &quot;K&quot;)) {
 		int val = strtol(p, &amp;p, 10);
@@ -1161,19 +1145,19 @@
 
 	if (render_context.family)
 		free(render_context.family);
-        render_context.family=NULL;
-        
 	render_context.family = strdup(render_context.style-&gt;FontName);
-	render_context.bold = - render_context.style-&gt;Bold;
-	render_context.italic = - render_context.style-&gt;Italic;
+	render_context.bold = render_context.style-&gt;Bold;
+	render_context.italic = render_context.style-&gt;Italic;
 	update_font();
 
 	change_border(-1.);
 	render_context.scale_x = render_context.style-&gt;ScaleX;
 	render_context.scale_y = render_context.style-&gt;ScaleY;
-	render_context.hspacing = 0; // FIXME
+	render_context.hspacing = render_context.style-&gt;Spacing;
 	render_context.be = 0;
 	render_context.shadow = render_context.style-&gt;Shadow;
+	render_context.frx = render_context.fry = 0.;
+	render_context.frz = M_PI * render_context.style-&gt;Angle / 180.;
 
 	// FIXME: does not reset unsupported attributes.
 }
@@ -1189,12 +1173,12 @@
 	reset_render_context();
 
 	render_context.evt_type = EVENT_NORMAL;
-	render_context.alignment = 0;
-	render_context.rotation = M_PI * render_context.style-&gt;Angle / 180.;
+	render_context.alignment = render_context.style-&gt;Alignment;
 	render_context.pos_x = 0;
 	render_context.pos_y = 0;
 	render_context.org_x = 0;
 	render_context.org_y = 0;
+	render_context.have_origin = 0;
 	render_context.clip_x0 = 0;
 	render_context.clip_y0 = 0;
 	render_context.clip_x1 = frame_context.track-&gt;PlayResX;
@@ -1213,86 +1197,121 @@
 }
 
 /**
- * \brief Get normal and outline glyphs from cache (if possible) or font face
- * \param index face glyph index
+ * \brief Get normal and outline (border) glyphs
  * \param symbol ucs4 char
  * \param info out: struct filled with extracted data
- * \param advance advance vector of the extracted glyph
- * \return 0 on success
+ * \param advance subpixel shift vector used for cache lookup
+ * Tries to get both glyphs from cache.
+ * If they can't be found, gets a glyph from font face, generates outline with FT_Stroker,
+ * and add them to cache.
+ * The glyphs are returned in info-&gt;glyph and info-&gt;outline_glyph
  */
-int get_glyph(int index, int symbol, glyph_info_t* info, FT_Vector* advance)
+static void get_outline_glyph(int symbol, glyph_info_t* info, FT_Vector* advance)
 {
 	int error;
 	glyph_hash_val_t* val;
-	glyph_hash_key_t* key = &amp;(info-&gt;hash_key);
-	
-	key-&gt;face = render_context.face;
-	key-&gt;size = render_context.font_size;
-	key-&gt;index = index;
-	key-&gt;outline = (render_context.border * 0xFFFF); // convert to 16.16
-	key-&gt;scale_x = (render_context.scale_x * 0xFFFF);
-	key-&gt;scale_y = (render_context.scale_y * 0xFFFF);
-	key-&gt;angle = (render_context.rotation * 0xFFFF);
-	key-&gt;advance = *advance;
-	key-&gt;bold = render_context.bold;
-	key-&gt;italic = render_context.italic;
-	key-&gt;be = render_context.be;
+	glyph_hash_key_t key;
+	key.font = render_context.font;
+	key.size = render_context.font_size;
+	key.ch = symbol;
+	key.scale_x = (render_context.scale_x * 0xFFFF);
+	key.scale_y = (render_context.scale_y * 0xFFFF);
+	key.advance = *advance;
+	key.bold = render_context.bold;
+	key.italic = render_context.italic;
+	key.outline = render_context.border * 0xFFFF;
 
-	val = cache_find_glyph(key);
-//	val = 0;
-	
+	info-&gt;glyph = info-&gt;outline_glyph = 0;
+
+	val = cache_find_glyph(&amp;key);
 	if (val) {
-		info-&gt;glyph = info-&gt;outline_glyph = 0;
-		info-&gt;bm = val-&gt;bm;
-		info-&gt;bm_o = val-&gt;bm_o;
-		info-&gt;bm_s = val-&gt;bm_s;
+		FT_Glyph_Copy(val-&gt;glyph, &amp;info-&gt;glyph);
+		if (val-&gt;outline_glyph)
+			FT_Glyph_Copy(val-&gt;outline_glyph, &amp;info-&gt;outline_glyph);
 		info-&gt;bbox = val-&gt;bbox_scaled;
 		info-&gt;advance.x = val-&gt;advance.x;
 		info-&gt;advance.y = val-&gt;advance.y;
+	} else {
+		glyph_hash_val_t v;
+		info-&gt;glyph = ass_font_get_glyph(frame_context.ass_priv-&gt;fontconfig_priv, render_context.font, symbol, global_settings-&gt;hinting);
+		if (!info-&gt;glyph)
+			return;
+		info-&gt;advance.x = d16_to_d6(info-&gt;glyph-&gt;advance.x);
+		info-&gt;advance.y = d16_to_d6(info-&gt;glyph-&gt;advance.y);
+		FT_Glyph_Get_CBox( info-&gt;glyph, FT_GLYPH_BBOX_PIXELS, &amp;info-&gt;bbox);
 
-		return 0;
+		if (render_context.stroker) {
+			info-&gt;outline_glyph = info-&gt;glyph;
+			error = FT_Glyph_StrokeBorder( &amp;(info-&gt;outline_glyph), render_context.stroker, 0 , 0 ); // don't destroy original
+			if (error) {
+				mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FT_Glyph_Stroke_Error, error);
+			}
+		}
+
+		memset(&amp;v, 0, sizeof(v));
+		FT_Glyph_Copy(info-&gt;glyph, &amp;v.glyph);
+		if (info-&gt;outline_glyph)
+			FT_Glyph_Copy(info-&gt;outline_glyph, &amp;v.outline_glyph);
+		v.advance = info-&gt;advance;
+		v.bbox_scaled = info-&gt;bbox;
+		cache_add_glyph(&amp;key, &amp;v);
 	}
+}
 
-	// not found, get a new outline glyph from face
-//	mp_msg(MSGT_ASS, MSGL_INFO, &quot;miss, index = %d, symbol = %c, adv = (%d, %d)\n&quot;, index, symbol, advance-&gt;x, advance-&gt;y);
+static void transform_3d(FT_Vector shift, FT_Glyph* glyph, FT_Glyph* glyph2, double frx, double fry, double frz);
+
+/**
+ * \brief Get bitmaps for a glyph
+ * \param info glyph info
+ * Tries to get glyph bitmaps from bitmap cache.
+ * If they can't be found, they are generated by rotating and rendering the glyph.
+ * After that, bitmaps are added to the cache.
+ * They are returned in info-&gt;bm (glyph), info-&gt;bm_o (outline) and info-&gt;bm_s (shadow).
+ */
+static void get_bitmap_glyph(glyph_info_t* info)
+{
+	bitmap_hash_val_t* val;
+	bitmap_hash_key_t* key = &amp;info-&gt;hash_key;
 	
-	error = FT_Load_Glyph(render_context.face, index, FT_LOAD_NO_BITMAP );
-	if (error) {
-		mp_msg(MSGT_ASS, MSGL_WARN, &quot;Error loading glyph\n&quot;);
-		return error;
-	}
+	val = cache_find_bitmap(key);
+/* 	val = 0; */
 	
-#if (FREETYPE_MAJOR &gt; 2) || \
-    ((FREETYPE_MAJOR == 2) &amp;&amp; (FREETYPE_MINOR &gt;= 2)) || \
-    ((FREETYPE_MAJOR == 2) &amp;&amp; (FREETYPE_MINOR == 1) &amp;&amp; (FREETYPE_PATCH &gt;= 10))
-// FreeType &gt;= 2.1.10 required
-	if (!(render_context.face-&gt;style_flags &amp; FT_STYLE_FLAG_ITALIC) &amp;&amp; 
-			((render_context.italic == 1) || (render_context.italic &gt; 55))) {
-		FT_GlyphSlot_Oblique(render_context.face-&gt;glyph);
-	}
-#endif
-	error = FT_Get_Glyph(render_context.face-&gt;glyph, &amp;(info-&gt;glyph));
-	if (error) {
-		mp_msg(MSGT_ASS, MSGL_WARN, &quot;Error getting glyph\n&quot;);
-		return error;
-	}
+	if (val) {
+		info-&gt;bm = val-&gt;bm;
+		info-&gt;bm_o = val-&gt;bm_o;
+		info-&gt;bm_s = val-&gt;bm_s;
+	} else {
+		FT_Vector shift;
+		bitmap_hash_val_t hash_val;
+		int error;
+		info-&gt;bm = info-&gt;bm_o = info-&gt;bm_s = 0;
+		if (info-&gt;glyph &amp;&amp; info-&gt;symbol != '\n' &amp;&amp; info-&gt;symbol != 0) {
+			// calculating rotation shift vector (from rotation origin to the glyph basepoint)
+			shift.x = int_to_d6(info-&gt;hash_key.shift_x);
+			shift.y = int_to_d6(info-&gt;hash_key.shift_y);
+			// apply rotation
+			transform_3d(shift, &amp;info-&gt;glyph, &amp;info-&gt;outline_glyph, info-&gt;frx, info-&gt;fry, info-&gt;frz);
 
-	info-&gt;advance.x = info-&gt;glyph-&gt;advance.x &gt;&gt; 10;
-	info-&gt;advance.y = info-&gt;glyph-&gt;advance.y &gt;&gt; 10;
+			// render glyph
+			error = glyph_to_bitmap(ass_renderer-&gt;synth_priv,
+					info-&gt;glyph, info-&gt;outline_glyph,
+					&amp;info-&gt;bm, &amp;info-&gt;bm_o,
+					&amp;info-&gt;bm_s, info-&gt;be);
+			if (error)
+				info-&gt;symbol = 0;
 
-	if (render_context.stroker) {
-		info-&gt;outline_glyph = info-&gt;glyph;
-		error = FT_Glyph_Stroke( &amp;(info-&gt;outline_glyph), render_context.stroker, 0 ); // don't destroy original
-		if (error) {
-			mp_msg(MSGT_ASS, MSGL_WARN, &quot;FT_Glyph_Stroke error %d \n&quot;, error);
+			// add bitmaps to cache
+			hash_val.bm_o = info-&gt;bm_o;
+			hash_val.bm = info-&gt;bm;
+			hash_val.bm_s = info-&gt;bm_s;
+			cache_add_bitmap(&amp;(info-&gt;hash_key), &amp;hash_val);
 		}
-	} else {
-		info-&gt;outline_glyph = 0;
 	}
-
-	info-&gt;bm = info-&gt;bm_o = info-&gt;bm_s = 0;
-
-	return 0;
+	// deallocate glyphs
+	if (info-&gt;glyph)
+		FT_Done_Glyph(info-&gt;glyph);
+	if (info-&gt;outline_glyph)
+		FT_Done_Glyph(info-&gt;outline_glyph);
 }
 
 /**
@@ -1304,7 +1323,7 @@
  *   lines[].asc
  *   lines[].desc
  */
-static void measure_text()
+static void measure_text(void)
 {
 	int cur_line = 0, max_asc = 0, max_desc = 0;
 	int i;
@@ -1320,9 +1339,9 @@
 		if (i &lt; text_info.length) {
 			glyph_info_t* cur = text_info.glyphs + i;
 			if (cur-&gt;asc &gt; max_asc)
-				max_asc = cur-&gt;asc * render_context.scale_y;
+				max_asc = cur-&gt;asc;
 			if (cur-&gt;desc &gt; max_desc)
-				max_desc = cur-&gt;desc * render_context.scale_y;
+				max_desc = cur-&gt;desc;
 		}
 	}
 }
@@ -1396,6 +1415,11 @@
 		
 		if (cur-&gt;symbol == ' ')
 			last_space = i;
+
+		// make sure the hard linebreak is not forgotten when
+		// there was a new soft linebreak just inserted
+		if (cur-&gt;symbol == '\n' &amp;&amp; break_type == 1)
+			i--;
 	}
 #define DIFF(x,y) (((x) &lt; (y)) ? (y - x) : (x - y))
 	exit = 0;
@@ -1450,7 +1474,7 @@
 			int height = text_info.lines[cur_line - 1].desc + text_info.lines[cur_line].asc;
 			cur_line ++;
 			pen_shift_x = - cur-&gt;pos.x;
-			pen_shift_y += (height &gt;&gt; 6) + global_settings-&gt;line_spacing;
+			pen_shift_y += d6_to_int(height) + global_settings-&gt;line_spacing;
 			mp_msg(MSGT_ASS, MSGL_DBG2, &quot;shifting from %d to %d by (%d, %d)\n&quot;, i, text_info.length - 1, pen_shift_x, pen_shift_y);
 		}
 		cur-&gt;pos.x += pen_shift_x;
@@ -1512,7 +1536,7 @@
 					dt /= (tm_end - tm_start);
 					x = x_start + (x_end - x_start) * dt;
 				} else {
-					mp_msg(MSGT_ASS, MSGL_ERR, &quot;Unknown effect type (internal error)  \n&quot;);
+					mp_msg(MSGT_ASS, MSGL_ERR, MSGTR_LIBASS_UnknownEffectType_InternalError);
 					continue;
 				}
 
@@ -1525,26 +1549,6 @@
 	}
 }
 
-static int get_face_ascender(FT_Face face)
-{
-	int v = face-&gt;size-&gt;metrics.ascender;
-	int v2 = FT_MulFix(face-&gt;bbox.yMax, face-&gt;size-&gt;metrics.y_scale);
-	if (v &gt; v2 * 0.9)
-		return v;
-	else
-		return v2;
-}
-
-static int get_face_descender(FT_Face face)
-{
-	int v = - face-&gt;size-&gt;metrics.descender;
-	int v2 = - FT_MulFix(face-&gt;bbox.yMin, face-&gt;size-&gt;metrics.y_scale);
-	if (v &gt; v2 * 0.9)
-		return v;
-	else
-		return v2;
-}
-
 /**
  * \brief Calculate base point for positioning and rotation
  * \param bbox text bbox
@@ -1582,19 +1586,121 @@
 }
 
 /**
+ * \brief Multiply 4-vector by 4-matrix
+ * \param a 4-vector
+ * \param m 4-matrix]
+ * \param b out: 4-vector
+ * Calculates a * m and stores result in b
+ */
+static inline void transform_point_3d(double *a, double *m, double *b)
+{
+	b[0] = a[0] * m[0] + a[1] * m[4] + a[2] * m[8] +  a[3] * m[12];
+	b[1] = a[0] * m[1] + a[1] * m[5] + a[2] * m[9] +  a[3] * m[13];
+	b[2] = a[0] * m[2] + a[1] * m[6] + a[2] * m[10] + a[3] * m[14];
+	b[3] = a[0] * m[3] + a[1] * m[7] + a[2] * m[11] + a[3] * m[15];
+}
+
+/**
+ * \brief Apply 3d transformation to a vector
+ * \param v FreeType vector (2d)
+ * \param m 4-matrix
+ * Transforms v by m, projects the result back to the screen plane
+ * Result is returned in v.
+ */
+static inline void transform_vector_3d(FT_Vector* v, double *m) {
+	const double camera = 2500 * frame_context.border_scale; // camera distance
+	double a[4], b[4];
+	a[0] = d6_to_double(v-&gt;x);
+	a[1] = d6_to_double(v-&gt;y);
+	a[2] = 0.;
+	a[3] = 1.;
+	transform_point_3d(a, m, b);
+	/* Apply perspective projection with the following matrix:
+	   2500     0     0     0
+	      0  2500     0     0
+	      0     0     0     0
+	      0     0     8     2500
+	   where 2500 is camera distance, 8 - z-axis scale.
+	   Camera is always located in (org_x, org_y, -2500). This means
+	   that different subtitle events can be displayed at the same time
+	   using different cameras. */
+	b[0] *= camera;
+	b[1] *= camera;
+	b[3] = 8 * b[2] + camera;
+	if (b[3] &lt; 0.001 &amp;&amp; b[3] &gt; -0.001)
+		b[3] = b[3] &lt; 0. ? -0.001 : 0.001;
+	v-&gt;x = double_to_d6(b[0] / b[3]);
+	v-&gt;y = double_to_d6(b[1] / b[3]);
+}
+
+/**
+ * \brief Apply 3d transformation to a glyph
+ * \param glyph FreeType glyph
+ * \param m 4-matrix
+ * Transforms glyph by m, projects the result back to the screen plane
+ * Result is returned in glyph.
+ */
+static inline void transform_glyph_3d(FT_Glyph glyph, double *m, FT_Vector shift) {
+	int i;
+	FT_Outline* outline = &amp;((FT_OutlineGlyph)glyph)-&gt;outline;
+	FT_Vector* p = outline-&gt;points;
+
+	for (i=0; i&lt;outline-&gt;n_points; i++) {
+		p[i].x += shift.x;
+		p[i].y += shift.y;
+		transform_vector_3d(p + i, m);
+		p[i].x -= shift.x;
+		p[i].y -= shift.y;
+	}
+
+	//transform_vector_3d(&amp;glyph-&gt;advance, m);
+}
+
+/**
+ * \brief Apply 3d transformation to several objects
+ * \param shift FreeType vector
+ * \param glyph FreeType glyph
+ * \param glyph2 FreeType glyph
+ * \param frx x-axis rotation angle
+ * \param fry y-axis rotation angle
+ * \param frz z-axis rotation angle
+ * Rotates both glyphs by frx, fry and frz. Shift vector is added before rotation and subtracted after it.
+ */
+static void transform_3d(FT_Vector shift, FT_Glyph* glyph, FT_Glyph* glyph2, double frx, double fry, double frz)
+{
+	fry = - fry; // FreeType's y axis goes in the opposite direction
+	if (frx != 0. || fry != 0. || frz != 0.) {
+		double m[16];
+		double sx = sin(frx);
+		double sy = sin(fry);
+ 		double sz = sin(frz);
+		double cx = cos(frx);
+		double cy = cos(fry);
+		double cz = cos(frz);
+		m[0] = cy * cz;            m[1] = cy*sz;              m[2]  = -sy;    m[3] = 0.0;
+		m[4] = -cx*sz + sx*sy*cz;  m[5] = cx*cz + sx*sy*sz;   m[6]  = sx*cy;  m[7] = 0.0;
+		m[8] = sx*sz + cx*sy*cz;   m[9] = -sx*cz + cx*sy*sz;  m[10] = cx*cy;  m[11] = 0.0;
+		m[12] = 0.0;               m[13] = 0.0;               m[14] = 0.0;    m[15] = 1.0;
+
+		if (glyph &amp;&amp; *glyph)
+			transform_glyph_3d(*glyph, m, shift);
+
+		if (glyph2 &amp;&amp; *glyph2)
+			transform_glyph_3d(*glyph2, m, shift);
+	}
+}
+
+/**
  * \brief Main ass rendering function, glues everything together
  * \param event event to render
  * Process event, appending resulting ass_image_t's to images_root.
  */
-int ass_render_event(ass_event_t* event, event_images_t* event_images)
+static int ass_render_event(ass_event_t* event, event_images_t* event_images)
 {
 	char* p;
-	FT_UInt glyph_index; 
-	FT_Bool use_kerning; 
 	FT_UInt previous; 
 	FT_UInt num_glyphs;
 	FT_Vector pen;
-	int error;
 	unsigned code;
 	FT_BBox bbox;
 	int i, j;
@@ -1605,11 +1711,11 @@
 	int device_x = 0, device_y = 0;
 
 	if (event-&gt;Style &gt;= frame_context.track-&gt;n_styles) {
-		mp_msg(MSGT_ASS, MSGL_WARN, &quot;No style found!\n&quot;);
+		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_NoStyleFound);
 		return 1;
 	}
 	if (!event-&gt;Text) {
-		mp_msg(MSGT_ASS, MSGL_WARN, &quot;Empty event!\n&quot;);
+		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_EmptyEvent);
 		return 1;
 	}
 
@@ -1628,7 +1734,7 @@
 		code = get_next_char(&amp;p);
 		
 		// face could have been changed in get_next_char
-		if (!render_context.face) {
+		if (!render_context.font) {
 			free_render_context();
 			return 1;
 		}
@@ -1636,19 +1742,15 @@
 		if (code == 0)
 			break;
 
-		use_kerning = FT_HAS_KERNING(render_context.face);
-
 		if (text_info.length &gt;= MAX_GLYPHS) {
-			mp_msg(MSGT_ASS, MSGL_WARN, &quot;\nMAX_GLYPHS reached: event %d, start = %llu, duration = %llu\n Text = %s\n&quot;, 
+			mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_MAX_GLYPHS_Reached, 
 					(int)(event - frame_context.track-&gt;events), event-&gt;Start, event-&gt;Duration, event-&gt;Text);
 			break;
 		}
 
-		glyph_index = FT_Get_Char_Index( render_context.face, code);
-
-		if ( use_kerning &amp;&amp; previous &amp;&amp; glyph_index ) {
+		if ( previous &amp;&amp; code ) {
 			FT_Vector delta;
-			FT_Get_Kerning( render_context.face, previous, glyph_index, FT_KERNING_DEFAULT, &amp;delta );
+			delta = ass_font_get_kerning(render_context.font, previous, code);
 			pen.x += delta.x * render_context.scale_x;
 			pen.y += delta.y * render_context.scale_y;
 		}
@@ -1656,40 +1758,22 @@
 		shift.x = pen.x &amp; 63;
 		shift.y = pen.y &amp; 63;
 
-		if ((render_context.scale_x != 1.) || (render_context.scale_y != 1.) ||
-				(frame_context.font_scale_x != 1.)) {
-			FT_Matrix matrix;
-			matrix.xx = (FT_Fixed)( render_context.scale_x * frame_context.font_scale_x * 0x10000L );
-			matrix.xy = (FT_Fixed)( 0 * 0x10000L );
-			matrix.yx = (FT_Fixed)( 0 * 0x10000L );
-			matrix.yy = (FT_Fixed)( render_context.scale_y * 0x10000L );
+		ass_font_set_transform(render_context.font,
+				       render_context.scale_x * frame_context.font_scale_x,
+				       render_context.scale_y,
+				       &amp;shift );
 
-			FT_Set_Transform( render_context.face, &amp;matrix, &amp;shift );
-		} else {
-			FT_Set_Transform(render_context.face, 0, &amp;shift);
-		}
+		get_outline_glyph(code, text_info.glyphs + text_info.length, &amp;shift);
 		
-		error = get_glyph(glyph_index, code, text_info.glyphs + text_info.length, &amp;shift);
-
-		if (error) {
-			continue;
-		}
-		
 		text_info.glyphs[text_info.length].pos.x = pen.x &gt;&gt; 6;
 		text_info.glyphs[text_info.length].pos.y = pen.y &gt;&gt; 6;
 		
 		pen.x += text_info.glyphs[text_info.length].advance.x;
-		pen.x += render_context.hspacing;
+		pen.x += double_to_d6(render_context.hspacing);
 		pen.y += text_info.glyphs[text_info.length].advance.y;
 		
-		// if it's an outline glyph, we still need to fill the bbox
-		if (text_info.glyphs[text_info.length].glyph) {
-			FT_Glyph_Get_CBox( text_info.glyphs[text_info.length].glyph, FT_GLYPH_BBOX_PIXELS, &amp;(text_info.glyphs[text_info.length].bbox) );
-		}
+		previous = code;
 
-		
-		previous = glyph_index;
-		
 		text_info.glyphs[text_info.length].symbol = code;
 		text_info.glyphs[text_info.length].linebreak = 0;
 		for (i = 0; i &lt; 4; ++i) {
@@ -1700,12 +1784,32 @@
 		text_info.glyphs[text_info.length].effect_type = render_context.effect_type;
 		text_info.glyphs[text_info.length].effect_timing = render_context.effect_timing;
 		text_info.glyphs[text_info.length].effect_skip_timing = render_context.effect_skip_timing;
-		text_info.glyphs[text_info.length].asc = get_face_ascender(render_context.face);
-		text_info.glyphs[text_info.length].desc = get_face_descender(render_context.face);
 		text_info.glyphs[text_info.length].be = render_context.be;
 		text_info.glyphs[text_info.length].shadow = render_context.shadow;
-		text_info.glyphs[text_info.length].frz = render_context.rotation;
+		text_info.glyphs[text_info.length].frx = render_context.frx;
+		text_info.glyphs[text_info.length].fry = render_context.fry;
+		text_info.glyphs[text_info.length].frz = render_context.frz;
+		ass_font_get_asc_desc(render_context.font, code,
+				      &amp;text_info.glyphs[text_info.length].asc,
+				      &amp;text_info.glyphs[text_info.length].desc);
+		text_info.glyphs[text_info.length].asc *= render_context.scale_y;
+		text_info.glyphs[text_info.length].desc *= render_context.scale_y;
 
+		// fill bitmap_hash_key
+		text_info.glyphs[text_info.length].hash_key.font = render_context.font;
+		text_info.glyphs[text_info.length].hash_key.size = render_context.font_size;
+		text_info.glyphs[text_info.length].hash_key.outline = render_context.border * 0xFFFF;
+		text_info.glyphs[text_info.length].hash_key.scale_x = render_context.scale_x * 0xFFFF;
+		text_info.glyphs[text_info.length].hash_key.scale_y = render_context.scale_y * 0xFFFF;
+		text_info.glyphs[text_info.length].hash_key.frx = render_context.frx * 0xFFFF;
+		text_info.glyphs[text_info.length].hash_key.fry = render_context.fry * 0xFFFF;
+		text_info.glyphs[text_info.length].hash_key.frz = render_context.frz * 0xFFFF;
+		text_info.glyphs[text_info.length].hash_key.bold = render_context.bold;
+		text_info.glyphs[text_info.length].hash_key.italic = render_context.italic;
+		text_info.glyphs[text_info.length].hash_key.ch = code;
+		text_info.glyphs[text_info.length].hash_key.advance = shift;
+		text_info.glyphs[text_info.length].hash_key.be = render_context.be;
+
 		text_info.length++;
 
 		render_context.effect_type = EF_NONE;
@@ -1724,8 +1828,6 @@
 	
 	// alignments
 	alignment = render_context.alignment;
-	if (!alignment)
-		alignment = render_context.style-&gt;Alignment;
 	halign = alignment &amp; 3;
 	valign = alignment &amp; 12;
 
@@ -1746,16 +1848,16 @@
 		last_break = -1;
 		for (i = 1; i &lt; text_info.length + 1; ++i) { // (text_info.length + 1) is the end of the last line
 			if ((i == text_info.length) || text_info.glyphs[i].linebreak) {
-				int width, shift;
+				int width, shift = 0;
 				glyph_info_t* first_glyph = text_info.glyphs + last_break + 1;
 				glyph_info_t* last_glyph = text_info.glyphs + i - 1;
 
 				while ((last_glyph &gt; first_glyph) &amp;&amp; ((last_glyph-&gt;symbol == '\n') || (last_glyph-&gt;symbol == 0)))
 					last_glyph --;
 
-				width = last_glyph-&gt;pos.x + last_glyph-&gt;bbox.xMax - first_glyph-&gt;pos.x - first_glyph-&gt;bbox.xMin;
-				shift = - first_glyph-&gt;bbox.xMin; // now text line starts exactly at 0 (left margin)
+				width = last_glyph-&gt;pos.x + d6_to_int(last_glyph-&gt;advance.x) - first_glyph-&gt;pos.x;
 				if (halign == HALIGN_LEFT) { // left aligned, no action
+					shift = 0;
 				} else if (halign == HALIGN_RIGHT) { // right aligned
 					shift = max_text_width - width;
 				} else if (halign == HALIGN_CENTER) { // centered
@@ -1791,7 +1893,7 @@
 	if (render_context.evt_type == EVENT_NORMAL ||
 	    render_context.evt_type == EVENT_HSCROLL) {
 		if (valign == VALIGN_TOP) { // toptitle
-			device_y = y2scr_top(MarginV) + (text_info.lines[0].asc &gt;&gt; 6);
+			device_y = y2scr_top(MarginV) + d6_to_int(text_info.lines[0].asc);
 		} else if (valign == VALIGN_CENTER) { // midtitle
 			int scr_y = y2scr(frame_context.track-&gt;PlayResY / 2);
 			device_y = scr_y - (bbox.yMax - bbox.yMin) / 2;
@@ -1801,8 +1903,8 @@
 				mp_msg(MSGT_ASS, MSGL_V, &quot;Invalid valign, supposing 0 (subtitle)\n&quot;);
 			scr_y = y2scr_sub(frame_context.track-&gt;PlayResY - MarginV);
 			device_y = scr_y;
-			device_y -= (text_info.height &gt;&gt; 6);
-			device_y += (text_info.lines[0].asc &gt;&gt; 6);
+			device_y -= d6_to_int(text_info.height);
+			device_y += d6_to_int(text_info.lines[0].asc);
 		}
 	} else if (render_context.evt_type == EVENT_VSCROLL) {
 		if (render_context.scroll_direction == SCROLL_TB)
@@ -1842,15 +1944,13 @@
 		render_context.clip_y1 = y2scr(render_context.clip_y1);
 	}
 
-	// rotate glyphs if needed
+	// calculate rotation parameters
 	{
-		double angle = 0.;
 		FT_Vector center;
-		FT_Matrix matrix_rotate;
 		
-		if (((render_context.org_x != 0) || (render_context.org_y != 0)) &amp;&amp; (render_context.evt_type == EVENT_POSITIONED)) {
-			center.x = render_context.org_x;
-			center.y = render_context.org_y;
+		if (render_context.have_origin) {
+			center.x = x2scr(render_context.org_x);
+			center.y = y2scr(render_context.org_y);
 		} else {
 			int bx, by;
 			get_base_point(bbox, alignment, &amp;bx, &amp;by);
@@ -1859,45 +1959,24 @@
 		}
 
 		for (i = 0; i &lt; text_info.length; ++i) {
-			FT_Vector start;
-			FT_Vector start_old;
 			glyph_info_t* info = text_info.glyphs + i;
 
-			if (info-&gt;frz &lt; 0.00001 &amp;&amp; info-&gt;frz &gt; -0.00001)
-				continue;
-			
-			if (info-&gt;frz != angle) {
-				angle = info-&gt;frz;
-				matrix_rotate.xx = (FT_Fixed)( cos( angle ) * 0x10000L );
-				matrix_rotate.xy = (FT_Fixed)( -sin( angle ) * 0x10000L );
-				matrix_rotate.yx = (FT_Fixed)( sin( angle ) * 0x10000L );
-				matrix_rotate.yy = (FT_Fixed)( cos( angle ) * 0x10000L );
+			if (info-&gt;hash_key.frx || info-&gt;hash_key.fry || info-&gt;hash_key.frz) {
+				info-&gt;hash_key.shift_x = info-&gt;pos.x + device_x - center.x;
+				info-&gt;hash_key.shift_y = - (info-&gt;pos.y + device_y - center.y);
+			} else {
+				info-&gt;hash_key.shift_x = 0;
+				info-&gt;hash_key.shift_y = 0;
 			}
-
-			// calculating shift vector
-			// shift = (position - center)*M - (position - center)
-			start.x = (info-&gt;pos.x + device_x - center.x) &lt;&lt; 6;
-			start.y = - (info-&gt;pos.y + device_y - center.y) &lt;&lt; 6;
-			start_old.x = start.x;
-			start_old.y = start.y;
-
-			FT_Vector_Transform(&amp;start, &amp;matrix_rotate);
-			
-			start.x -= start_old.x;
-			start.y -= start_old.y;
-
-			info-&gt;pos.x += start.x &gt;&gt; 6;
-			info-&gt;pos.y -= start.y &gt;&gt; 6;
-
-			if (info-&gt;glyph)
-				FT_Glyph_Transform( info-&gt;glyph, &amp;matrix_rotate, 0 );
-			if (info-&gt;outline_glyph)
-				FT_Glyph_Transform( info-&gt;outline_glyph, &amp;matrix_rotate, 0 );
 		}
 	}
 
-	event_images-&gt;top = device_y - (text_info.lines[0].asc &gt;&gt; 6);
-	event_images-&gt;height = text_info.height &gt;&gt; 6;
+	// convert glyphs to bitmaps
+	for (i = 0; i &lt; text_info.length; ++i)
+		get_bitmap_glyph(text_info.glyphs + i);
+
+	event_images-&gt;top = device_y - d6_to_int(text_info.lines[0].asc);
+	event_images-&gt;height = d6_to_int(text_info.height);
 	event_images-&gt;detect_collisions = render_context.detect_collisions;
 	event_images-&gt;shift_direction = (valign == VALIGN_TOP) ? 1 : -1;
 	event_images-&gt;event = event;
@@ -1908,10 +1987,26 @@
 	return 0;
 }
 
+/**
+ * \brief deallocate image list
+ * \param img list pointer
+ */
+void ass_free_images(ass_image_t* img)
+{
+	while (img) {
+		ass_image_t* next = img-&gt;next;
+		free(img);
+		img = next;
+	}
+}
+
 static void ass_reconfigure(ass_renderer_t* priv)
 {
 	priv-&gt;render_id = ++last_render_id;
 	ass_glyph_cache_reset();
+	ass_bitmap_cache_reset();
+	ass_free_images(priv-&gt;prev_images_root);
+	priv-&gt;prev_images_root = 0;
 }
 
 void ass_set_frame_size(ass_renderer_t* priv, int w, int h)
@@ -1960,6 +2055,14 @@
 	}
 }
 
+void ass_set_hinting(ass_renderer_t* priv, ass_hinting_t ht)
+{
+	if (priv-&gt;settings.hinting != ht) {
+		priv-&gt;settings.hinting = ht;
+		ass_reconfigure(priv);
+	}
+}
+
 int ass_set_fonts(ass_renderer_t* priv, const char* default_font, const char* default_family)
 {
 	if (priv-&gt;settings.default_font)
@@ -1972,7 +2075,7 @@
 
 	if (priv-&gt;fontconfig_priv)
 		fontconfig_done(priv-&gt;fontconfig_priv);
-	priv-&gt;fontconfig_priv = fontconfig_init(priv-&gt;library-&gt;fonts_dir, default_family, default_font);
+	priv-&gt;fontconfig_priv = fontconfig_init(priv-&gt;library, priv-&gt;ftlibrary, default_family, default_font);
 
 	return !!priv-&gt;fontconfig_priv;
 }
@@ -1982,8 +2085,6 @@
  */
 static int ass_start_frame(ass_renderer_t *priv, ass_track_t* track, long long now)
 {
-	ass_image_t* img;
-
 	ass_renderer = priv;
 	global_settings = &amp;priv-&gt;settings;
 
@@ -2000,7 +2101,7 @@
 
 	ass_lazy_track_init();
 	
-	frame_context.font_scale = global_settings-&gt;font_size_coeff * ass_internal_font_size_coeff *
+	frame_context.font_scale = global_settings-&gt;font_size_coeff *
 	                           frame_context.orig_height / frame_context.track-&gt;PlayResY;
 	frame_context.border_scale = ((double)frame_context.orig_height) / frame_context.track-&gt;PlayResY;
 
@@ -2009,12 +2110,7 @@
 	else
 		frame_context.font_scale_x = ((double)(frame_context.orig_width * track-&gt;PlayResY)) / (frame_context.orig_height * track-&gt;PlayResX);
 
-	img = priv-&gt;images_root;
-	while (img) {
-		ass_image_t* next = img-&gt;next;
-		free(img);
-		img = next;
-	}
+	priv-&gt;prev_images_root = priv-&gt;images_root;
 	priv-&gt;images_root = 0;
 
 	return 0;
@@ -2028,10 +2124,6 @@
 		return -1;
 	if (e1-&gt;Layer &gt; e2-&gt;Layer)
 		return 1;
-	if (e1-&gt;Start &lt; e2-&gt;Start)
-		return -1;
-	if (e1-&gt;Start &gt; e2-&gt;Start)
-		return 1;
 	if (e1-&gt;ReadOrder &lt; e2-&gt;ReadOrder)
 		return -1;
 	if (e1-&gt;ReadOrder &gt; e2-&gt;ReadOrder)
@@ -2044,7 +2136,7 @@
 static render_priv_t* get_render_priv(ass_event_t* event)
 {
 	if (!event-&gt;render_priv)
-		event-&gt;render_priv = (render_priv_t*)calloc(1, sizeof(render_priv_t));
+		event-&gt;render_priv = calloc(1, sizeof(render_priv_t));
 	// FIXME: check render_id
 	if (ass_renderer-&gt;render_id != event-&gt;render_priv-&gt;render_id) {
 		memset(event-&gt;render_priv, 0, sizeof(render_priv_t));
@@ -2099,37 +2191,27 @@
 static int fit_segment(segment_t* s, segment_t* fixed, int* cnt, int dir)
 {
 	int i;
-	int shift;
+	int shift = 0;
 
-	if (*cnt == 0) {
-		*cnt = 1;
-		fixed[0].a = s-&gt;a;
-		fixed[0].b = s-&gt;b;
-		return 0;
-	}
-
-	if (dir == 1) { // move down
-		if (s-&gt;b &lt;= fixed[0].a) // all ok
-			return 0;
+	if (dir == 1) // move down
 		for (i = 0; i &lt; *cnt; ++i) {
+			if (s-&gt;b + shift &lt;= fixed[i].a || s-&gt;a + shift &gt;= fixed[i].b)
+				continue;
 			shift = fixed[i].b - s-&gt;a;
-			if (i == *cnt - 1 || fixed[i+1].a &gt;= shift + s-&gt;b) { // here is a good place
-				fixed[i].b += s-&gt;b - s-&gt;a;
-				return shift;
-			}
 		}
-	} else { // dir == -1, move up
-		if (s-&gt;a &gt;= fixed[*cnt-1].b) // all ok
-			return 0;
+	else // dir == -1, move up
 		for (i = *cnt-1; i &gt;= 0; --i) {
+			if (s-&gt;b + shift &lt;= fixed[i].a || s-&gt;a + shift &gt;= fixed[i].b)
+				continue;
 			shift = fixed[i].a - s-&gt;b;
-			if (i == 0 || fixed[i-1].b &lt;= shift + s-&gt;a) { // here is a good place
-				fixed[i].a -= s-&gt;b - s-&gt;a;
-				return shift;
-			}
 		}
-	}
-	assert(0); // unreachable
+
+	fixed[*cnt].a = s-&gt;a + shift;
+	fixed[*cnt].b = s-&gt;b + shift;
+	(*cnt)++;
+	qsort(fixed, *cnt, sizeof(segment_t), cmp_segment);
+	
+	return shift;
 }
 
 static void fix_collisions(event_images_t* imgs, int cnt)
@@ -2148,7 +2230,7 @@
 			s.a = priv-&gt;top;
 			s.b = priv-&gt;top + priv-&gt;height;
 			if (priv-&gt;height != imgs[i].height) { // no, it's not
-				mp_msg(MSGT_ASS, MSGL_WARN, &quot;Achtung! Event height has changed!  \n&quot;);
+				mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_EventHeightHasChanged);
 				priv-&gt;top = 0;
 				priv-&gt;height = 0;
 			}
@@ -2188,15 +2270,72 @@
 }
 
 /**
+ * \brief compare two images
+ * \param i1 first image
+ * \param i2 second image
+ * \return 0 if identical, 1 if different positions, 2 if different content
+ */
+int ass_image_compare(ass_image_t *i1, ass_image_t *i2)
+{
+	if (i1-&gt;w != i2-&gt;w) return 2;
+	if (i1-&gt;h != i2-&gt;h) return 2;
+	if (i1-&gt;stride != i2-&gt;stride) return 2;
+	if (i1-&gt;color != i2-&gt;color) return 2;
+	if (i1-&gt;bitmap != i2-&gt;bitmap)
+		return 2;
+	if (i1-&gt;dst_x != i2-&gt;dst_x) return 1;
+	if (i1-&gt;dst_y != i2-&gt;dst_y) return 1;
+	return 0;
+}
+
+/**
+ * \brief compare current and previous image list
+ * \param priv library handle
+ * \return 0 if identical, 1 if different positions, 2 if different content
+ */
+int ass_detect_change(ass_renderer_t *priv)
+{
+	ass_image_t* img, *img2;
+	int diff;
+
+	img = priv-&gt;prev_images_root;
+	img2 = priv-&gt;images_root;
+	diff = 0;
+	while (img &amp;&amp; diff &lt; 2) {
+		ass_image_t* next, *next2;
+		next = img-&gt;next;
+		if (img2) {
+			int d = ass_image_compare(img, img2);
+			if (d &gt; diff) diff = d;
+			next2 = img2-&gt;next;
+		} else {
+			// previous list is shorter
+			diff = 2;
+			break;
+		}
+		img = next;
+		img2 = next2;
+	}
+
+	// is the previous list longer?
+	if (img2)
+		diff = 2;
+
+	return diff;
+}
+
+/**
  * \brief render a frame
  * \param priv library handle
  * \param track track
  * \param now current video timestamp (ms)
+ * \param detect_change a value describing how the new images differ from the previous ones will be written here:
+ *        0 if identical, 1 if different positions, 2 if different content.
+ *        Can be NULL, in that case no detection is performed.
  */
-ass_image_t* ass_render_frame(ass_renderer_t *priv, ass_track_t* track, long long now)
+ass_image_t* ass_render_frame(ass_renderer_t *priv, ass_track_t* track, long long now, int* detect_change)
 {
 	int i, cnt, rc;
-	event_images_t eimg[MAX_EVENTS];
 	event_images_t* last;
 	ass_image_t** tail;
 	
@@ -2210,40 +2349,46 @@
 	for (i = 0; i &lt; track-&gt;n_events; ++i) {
 		ass_event_t* event = track-&gt;events + i;
 		if ( (event-&gt;Start &lt;= now) &amp;&amp; (now &lt; (event-&gt;Start + event-&gt;Duration)) ) {
-			if (cnt &lt; MAX_EVENTS) {
-				rc = ass_render_event(event, eimg + cnt);
-				if (!rc) ++cnt;
-			} else {
-				mp_msg(MSGT_ASS, MSGL_WARN, &quot;Too many simultaneous events  \n&quot;);
-				break;
+			if (cnt &gt;= priv-&gt;eimg_size) {
+				priv-&gt;eimg_size += 100;
+				priv-&gt;eimg = realloc(priv-&gt;eimg, priv-&gt;eimg_size * sizeof(event_images_t));
 			}
+			rc = ass_render_event(event, priv-&gt;eimg + cnt);
+			if (!rc) ++cnt;
 		}
 	}
 
 	// sort by layer
-	qsort(eimg, cnt, sizeof(event_images_t), cmp_event_layer);
+	qsort(priv-&gt;eimg, cnt, sizeof(event_images_t), cmp_event_layer);
 
 	// call fix_collisions for each group of events with the same layer
-	last = eimg;
+	last = priv-&gt;eimg;
 	for (i = 1; i &lt; cnt; ++i)
-		if (last-&gt;event-&gt;Layer != eimg[i].event-&gt;Layer) {
-			fix_collisions(last, eimg + i - last);
-			last = eimg + i;
+		if (last-&gt;event-&gt;Layer != priv-&gt;eimg[i].event-&gt;Layer) {
+			fix_collisions(last, priv-&gt;eimg + i - last);
+			last = priv-&gt;eimg + i;
 		}
 	if (cnt &gt; 0)
-		fix_collisions(last, eimg + cnt - last);
+		fix_collisions(last, priv-&gt;eimg + cnt - last);
 
 	// concat lists
 	tail = &amp;ass_renderer-&gt;images_root;
 	for (i = 0; i &lt; cnt; ++i) {
-		ass_image_t* cur = eimg[i].imgs;
+		ass_image_t* cur = priv-&gt;eimg[i].imgs;
 		while (cur) {
 			*tail = cur;
 			tail = &amp;cur-&gt;next;
 			cur = cur-&gt;next;
 		}
 	}
+
+	if (detect_change)
+		*detect_change = ass_detect_change(priv);
 	
+	// free the previous image list
+	ass_free_images(priv-&gt;prev_images_root);
+	priv-&gt;prev_images_root = 0;
+
 	return ass_renderer-&gt;images_root;
 }
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/ass_types.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/ass_types.h	2007-07-13 17:01:23 UTC (rev 3361)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/ass_types.h	2007-07-14 08:27:37 UTC (rev 3362)
@@ -32,7 +32,7 @@
 typedef struct ass_style_s {
 	char* Name;
 	char* FontName;
-	int FontSize;
+	double FontSize;
 	uint32_t PrimaryColour;
 	uint32_t SecondaryColour;
 	uint32_t OutlineColour;
@@ -43,7 +43,7 @@
 	int StrikeOut;
 	double ScaleX;
 	double ScaleY;
-	int Spacing;
+	double Spacing;
 	int Angle;
 	int BorderStyle;
 	double Outline;
@@ -80,14 +80,7 @@
 typedef struct parser_priv_s parser_priv_t;
 
 typedef struct ass_library_s ass_library_t;
-/* MEANX */
-typedef enum 
-{
-    TRACK_TYPE_UNKNOWN = 0, 
-    TRACK_TYPE_ASS, 
-    TRACK_TYPE_SSA
-    }TRACK_TYPE;
-    /* MEANX */
+
 /// ass track represent either an external script or a matroska subtitle stream (no real difference between them)
 /// it can be used in rendering after the headers are parsed (i.e. events format line read)
 typedef struct ass_track_s {
@@ -100,8 +93,8 @@
 
 	char* style_format; // style format line (everything after &quot;Format: &quot;)
 	char* event_format; // event format line
- 
-	TRACK_TYPE track_type; /* MEANX */
+
+	enum {TRACK_TYPE_UNKNOWN = 0, TRACK_TYPE_ASS, TRACK_TYPE_SSA} track_type;
 	
 	// script header fields
 	int PlayResX;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/ass_utils.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/ass_utils.c	2007-07-13 17:01:23 UTC (rev 3361)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/ass_utils.c	2007-07-14 08:27:37 UTC (rev 3362)
@@ -19,19 +19,13 @@
 */
 
 #include &quot;config.h&quot;
-#include &lt;stdio.h&gt;
+
 #include &lt;stdlib.h&gt;
 #include &lt;inttypes.h&gt;
-#include &lt;sys/time.h&gt;
-#include &lt;time.h&gt;
 
 #include &quot;mputils.h&quot;
 #include &quot;ass_utils.h&quot;
 
-#define ADM_LEGACY_PROGGY
-#include &quot;ADM_assert.h&quot;
-
-
 int mystrtoi(char** p, int base, int* res)
 {
 	char* start = *p;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/ass_utils.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/ass_utils.h	2007-07-13 17:01:23 UTC (rev 3361)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/ass_utils.h	2007-07-14 08:27:37 UTC (rev 3362)
@@ -25,5 +25,37 @@
 int mystrtou32(char** p, int base, uint32_t* res);
 int mystrtod(char** p, double* res);
 int strtocolor(char** q, uint32_t* res);
+
+static inline int d6_to_int(int x) {
+	return (x + 32) &gt;&gt; 6;
+}
+static inline int d16_to_int(int x) {
+	return (x + 32768) &gt;&gt; 16;
+}
+static inline int int_to_d6(int x) {
+	return x &lt;&lt; 6;
+}
+static inline int int_to_d16(int x) {
+	return x &lt;&lt; 16;
+}
+static inline int d16_to_d6(int x) {
+	return (x + 512) &gt;&gt; 10;
+}
+static inline int d6_to_d16(int x) {
+	return x &lt;&lt; 10;
+}
+static inline double d6_to_double(int x) {
+	return x / 64.;
+}
+static inline int double_to_d6(double x) {
+	return (int)(x * 64);
+}
+static inline double d16_to_double(int x) {
+	return ((double)x) / 0x10000;
+}
+static inline int double_to_d16(double x) {
+	return (int)(x * 0x10000);
+}
+
 #endif
 

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/help_mp.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/help_mp.h	2007-07-13 17:01:23 UTC (rev 3361)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/help_mp.h	2007-07-14 08:27:37 UTC (rev 3362)
@@ -0,0 +1,55 @@
+#ifndef __LIBASS_HELP_MP_H__
+#define __LIBASS_HELP_MP_H__
+#define MSGTR_LIBASS_FT_Glyph_To_BitmapError &quot;[ass] FT_Glyph_To_Bitmap error %d \n&quot;
+#define MSGTR_LIBASS_UnsupportedPixelMode &quot;[ass] Unsupported pixel mode: %d\n&quot;
+#define MSGTR_LIBASS_NoStyleNamedXFoundUsingY &quot;[ass] [%p] Warning: no style named '%s' found, using '%s'\n&quot;
+#define MSGTR_LIBASS_BadTimestamp &quot;[ass] bad timestamp\n&quot;
+#define MSGTR_LIBASS_BadEncodedDataSize &quot;[ass] bad encoded data size\n&quot;
+#define MSGTR_LIBASS_FontLineTooLong &quot;[ass] Font line too long: %d, %s\n&quot;
+#define MSGTR_LIBASS_EventFormatHeaderMissing &quot;[ass] Event format header missing\n&quot;
+#define MSGTR_LIBASS_ErrorOpeningIconvDescriptor &quot;[ass] error opening iconv descriptor.\n&quot;
+#define MSGTR_LIBASS_ErrorRecodingFile &quot;[ass] error recoding file.\n&quot;
+#define MSGTR_LIBASS_FopenFailed &quot;[ass] ass_read_file(%s): fopen failed\n&quot;
+#define MSGTR_LIBASS_FseekFailed &quot;[ass] ass_read_file(%s): fseek failed\n&quot;
+#define MSGTR_LIBASS_RefusingToLoadSubtitlesLargerThan10M &quot;[ass] ass_read_file(%s): Refusing to load subtitles larger than 10M\n&quot;
+#define MSGTR_LIBASS_ReadFailed &quot;Read failed, %d: %s\n&quot;
+#define MSGTR_LIBASS_AddedSubtitleFileMemory &quot;[ass] Added subtitle file: &lt;memory&gt; (%d styles, %d events)\n&quot;
+#define MSGTR_LIBASS_AddedSubtitleFileFname &quot;[ass] Added subtitle file: %s (%d styles, %d events)\n&quot;
+#define MSGTR_LIBASS_FailedToCreateDirectory &quot;[ass] Failed to create directory %s\n&quot;
+#define MSGTR_LIBASS_NotADirectory &quot;[ass] Not a directory: %s\n&quot;
+#define MSGTR_LIBASS_TooManyFonts &quot;[ass] Too many fonts\n&quot;
+#define MSGTR_LIBASS_ErrorOpeningFont &quot;[ass] Error opening font: %s, %d\n&quot;
+#define MSGTR_LIBASS_SelectedFontFamilyIsNotTheRequestedOne &quot;[ass] fontconfig: Selected font family is not the requested one: '%s' != '%s'\n&quot;
+#define MSGTR_LIBASS_UsingDefaultFontFamily &quot;[ass] fontconfig_select: Using default font family: (%s, %d, %d) -&gt; %s, %d\n&quot;
+#define MSGTR_LIBASS_UsingDefaultFont &quot;[ass] fontconfig_select: Using default font: (%s, %d, %d) -&gt; %s, %d\n&quot;
+#define MSGTR_LIBASS_UsingArialFontFamily &quot;[ass] fontconfig_select: Using 'Arial' font family: (%s, %d, %d) -&gt; %s, %d\n&quot;
+#define MSGTR_LIBASS_FcInitLoadConfigAndFontsFailed &quot;[ass] FcInitLoadConfigAndFonts failed.\n&quot;
+#define MSGTR_LIBASS_UpdatingFontCache &quot;[ass] Updating font cache.\n&quot;
+#define MSGTR_LIBASS_BetaVersionsOfFontconfigAreNotSupported &quot;[ass] Beta versions of fontconfig are not supported.\n[ass] Update before reporting any bugs.\n&quot;
+#define MSGTR_LIBASS_FcStrSetAddFailed &quot;[ass] FcStrSetAdd failed.\n&quot;
+#define MSGTR_LIBASS_FcDirScanFailed &quot;[ass] FcDirScan failed.\n&quot;
+#define MSGTR_LIBASS_FcDirSave &quot;[ass] FcDirSave failed.\n&quot;
+#define MSGTR_LIBASS_FcConfigAppFontAddDirFailed &quot;[ass] FcConfigAppFontAddDir failed\n&quot;
+#define MSGTR_LIBASS_FontconfigDisabledDefaultFontWillBeUsed &quot;[ass] Fontconfig disabled, only default font will be used.\n&quot;
+#define MSGTR_LIBASS_FunctionCallFailed &quot;[ass] %s failed\n&quot;
+#define MSGTR_LIBASS_NeitherPlayResXNorPlayResYDefined &quot;[ass] Neither PlayResX nor PlayResY defined. Assuming 384x288.\n&quot;
+#define MSGTR_LIBASS_PlayResYUndefinedSettingY &quot;[ass] PlayResY undefined, setting %d.\n&quot;
+#define MSGTR_LIBASS_PlayResXUndefinedSettingX &quot;[ass] PlayResX undefined, setting %d.\n&quot;
+#define MSGTR_LIBASS_FT_Init_FreeTypeFailed &quot;[ass] FT_Init_FreeType failed.\n&quot;
+#define MSGTR_LIBASS_Init &quot;[ass] Init\n&quot;
+#define MSGTR_LIBASS_InitFailed &quot;[ass] Init failed.\n&quot;
+#define MSGTR_LIBASS_BadCommand &quot;[ass] Bad command: %c%c\n&quot;
+#define MSGTR_LIBASS_ErrorLoadingGlyph  &quot;[ass] Error loading glyph.\n&quot;
+#define MSGTR_LIBASS_FT_Glyph_Stroke_Error &quot;[ass] FT_Glyph_Stroke error %d \n&quot;
+#define MSGTR_LIBASS_UnknownEffectType_InternalError &quot;[ass] Unknown effect type (internal error)\n&quot;
+#define MSGTR_LIBASS_NoStyleFound &quot;[ass] No style found!\n&quot;
+#define MSGTR_LIBASS_EmptyEvent &quot;[ass] Empty event!\n&quot;
+#define MSGTR_LIBASS_MAX_GLYPHS_Reached &quot;[ass] MAX_GLYPHS reached: event %d, start = %llu, duration = %llu\n Text = %s\n&quot;
+#define MSGTR_LIBASS_EventHeightHasChanged &quot;[ass] Warning! Event height has changed!  \n&quot;
+#define MSGTR_LIBASS_GlyphNotFoundReselectingFont &quot;[ass] Glyph 0x%X not found, reselecting font for (%s, %d, %d)\n&quot;
+#define MSGTR_LIBASS_GlyphNotFound &quot;[ass] Glyph 0x%X not found in font for (%s, %d, %d)\n&quot;
+#define MSGTR_LIBASS_ErrorOpeningMemoryFont &quot;[ass] Error opening memory font: %s\n&quot;
+#define MSGTR_LIBASS_NoCharmaps &quot;[ass] font face with no charmaps\n&quot;
+#define MSGTR_LIBASS_NoCharmapAutodetected &quot;[ass] no charmap autodetected, trying the first one\n&quot;
+#endif
+

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/mputils.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/mputils.c	2007-07-13 17:01:23 UTC (rev 3361)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/mputils.c	2007-07-14 08:27:37 UTC (rev 3362)
@@ -13,15 +13,10 @@
 #include &lt;enca.h&gt;
 #endif
 
-
-#define ADM_LEGACY_PROGGY
-#include &quot;ADM_assert.h&quot;
-
-
 void my_mp_msg(int lvl, char *lvl_str, char *fmt, ...) {
+	va_list va;
 	if(lvl &gt; MSGL_V) return;
 	printf(&quot;[ass] **%s**: &quot;, lvl_str);
-	va_list va;
 	va_start(va, fmt);
 	vprintf(fmt, va);
 	va_end(va);
@@ -79,7 +74,7 @@
 	    if(src){
 		register unsigned short *dstp= t + x-r;
 		int mx;
-		unsigned *m3= (unsigned *)(m2 + src*mwidth);
+		unsigned *m3= m2 + src*mwidth;
 		for(mx=r-x; mx&lt;mwidth; mx++){
 		    dstp[mx]+= m3[mx];
 		}
@@ -91,7 +86,7 @@
 	    if(src){
 		register unsigned short *dstp= t + x-r;
 		int mx;
-		unsigned *m3= (unsigned *)(m2 + src*mwidth);
+		unsigned *m3= m2 + src*mwidth;
 		for(mx=0; mx&lt;mwidth; mx++){
 		    dstp[mx]+= m3[mx];
 		}
@@ -104,7 +99,7 @@
 		register unsigned short *dstp= t + x-r;
 		int mx;
 		const int x2= r+width -x;
-		unsigned *m3= (unsigned *)(m2 + src*mwidth);
+		unsigned *m3= m2 + src*mwidth;
 		for(mx=0; mx&lt;x2; mx++){
 		    dstp[mx]+= m3[mx];
 		}
@@ -123,7 +118,7 @@
 	    if(src){
 		register unsigned short *dstp= srcp - 1 + width+1;
 		const int src2= (src + 128)&gt;&gt;8;
-		unsigned *m3= (unsigned *)(m2 + src2*mwidth);
+		unsigned *m3= m2 + src2*mwidth;
 
 		int mx;
 		*srcp= 128;
@@ -139,7 +134,7 @@
 	    if(src){
 		register unsigned short *dstp= srcp - 1 - r*(width+1);
 		const int src2= (src + 128)&gt;&gt;8;
-		unsigned *m3= (unsigned *)(m2 + src2*mwidth);
+		unsigned *m3= m2 + src2*mwidth;
 
 		int mx;
 		*srcp= 128;
@@ -156,7 +151,7 @@
 		const int y2=r+height-y;
 		register unsigned short *dstp= srcp - 1 - r*(width+1);
 		const int src2= (src + 128)&gt;&gt;8;
-		unsigned *m3= (unsigned *)(m2 + src2*mwidth);
+		unsigned *m3= m2 + src2*mwidth;
 
 		int mx;
 		*srcp= 128;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/mputils.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/mputils.h	2007-07-13 17:01:23 UTC (rev 3361)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/mputils.h	2007-07-14 08:27:37 UTC (rev 3362)
@@ -1,11 +1,19 @@
 #ifndef __MPUTILS_H__
 #define __MPUTILS_H__
 
+#include &quot;help_mp.h&quot;
+
 unsigned utf8_get_char(char **str);
 
 void my_mp_msg(int lvl, char *lvl_str, char *fmt, ...);
 
+#ifdef __VISUALC__
+static void mp_msg(int mod, int level, const char *fmt, ...) {
+	// MSVC doesn't like the # used all around for mp_msg, so it breaks va_arg
+}
+#else
 #define mp_msg(mod, level, args...) my_mp_msg(level, #level, args)
+#endif
 
 #define MSGT_ASS 43
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidASS.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidASS.cpp	2007-07-13 17:01:23 UTC (rev 3361)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidASS.cpp	2007-07-14 08:27:37 UTC (rev 3362)
@@ -10,12 +10,14 @@
   Initial port from MPlayer by Moonz
 
 */
+#include &quot;config.h&quot;
+
 #include &lt;stdio.h&gt;
 #include &lt;stdlib.h&gt;
 #include &lt;string.h&gt;
 #include &quot;ADM_assert.h&quot;
 
-#include &quot;config.h&quot;
+
 #include &quot;fourcc.h&quot;
 #include &quot;avio.hxx&quot;
 #include &quot;avi_vars.h&quot;
@@ -187,7 +189,8 @@
        _ass_track = ass_read_file(_ass_lib, (char*)_params-&gt;subfile, NULL);
 
 //        ADM_assert(_ass_track);
-        GUI_Error_HIG(&quot;SSA Error&quot;,&quot;Cannot read_file for *%s*&quot;,(char*)_params-&gt;subfile);
+        if(!_ass_track)
+          GUI_Error_HIG(&quot;SSA Error&quot;,&quot;Cannot read_file for *%s*&quot;,(char*)_params-&gt;subfile);
         return 1;
 } 
 
@@ -283,8 +286,8 @@
           printf(&quot;[Ass] No sub to render\n&quot;);
           return 1; 
         }
-
-        ass_image_t *img = ass_render_frame(_ass_rend, _ass_track, where);
+        int changed=0;
+        ass_image_t *img = ass_render_frame(_ass_rend, _ass_track, where,&amp;changed);
         
 
         while(img) {


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000638.html">[Avidemux-svn-commit] r3361 - in	branches/avidemux_2.4_branch/avidemux: ADM_ocr ADM_osSupport	ADM_userInterfaces/ADM_GTK/ADM_ocr
</A></li>
	<LI>Next message: <A HREF="000640.html">[Avidemux-svn-commit] r3363 -	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#639">[ date ]</a>
              <a href="thread.html#639">[ thread ]</a>
              <a href="subject.html#639">[ subject ]</a>
              <a href="author.html#639">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
