<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r3361 - in	branches/avidemux_2.4_branch/avidemux: ADM_ocr ADM_osSupport	ADM_userInterfaces/ADM_GTK/ADM_ocr
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2007-July/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r3361%20-%20in%0A%09branches/avidemux_2.4_branch/avidemux%3A%20ADM_ocr%20ADM_osSupport%0A%09ADM_userInterfaces/ADM_GTK/ADM_ocr&In-Reply-To=%3C200707131701.l6DH1PNx030914%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000637.html">
   <LINK REL="Next"  HREF="000639.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r3361 - in	branches/avidemux_2.4_branch/avidemux: ADM_ocr ADM_osSupport	ADM_userInterfaces/ADM_GTK/ADM_ocr</H1>
    <B>mean at BerliOS</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r3361%20-%20in%0A%09branches/avidemux_2.4_branch/avidemux%3A%20ADM_ocr%20ADM_osSupport%0A%09ADM_userInterfaces/ADM_GTK/ADM_ocr&In-Reply-To=%3C200707131701.l6DH1PNx030914%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r3361 - in	branches/avidemux_2.4_branch/avidemux: ADM_ocr ADM_osSupport	ADM_userInterfaces/ADM_GTK/ADM_ocr">mean at mail.berlios.de
       </A><BR>
    <I>Fri Jul 13 19:01:25 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000637.html">[Avidemux-svn-commit] r3360 -	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_utilities
</A></li>
        <LI>Next message: <A HREF="000639.html">[Avidemux-svn-commit] r3362 - in	branches/avidemux_2.4_branch/avidemux:	ADM_libraries/ADM_libass ADM_videoFilter
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#638">[ date ]</a>
              <a href="thread.html#638">[ thread ]</a>
              <a href="subject.html#638">[ subject ]</a>
              <a href="author.html#638">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2007-07-13 19:01:23 +0200 (Fri, 13 Jul 2007)
New Revision: 3361

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_ocr/ADM_ocr.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_ocr/ADM_ocr.h
Removed:
   branches/avidemux_2.4_branch/avidemux/ADM_ocr/ADM_ocrLoadSave.h
Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_ocr/CMakeLists.txt
   branches/avidemux_2.4_branch/avidemux/ADM_ocr/Makefile.am
   branches/avidemux_2.4_branch/avidemux/ADM_ocr/adm_glyph.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_ocr/adm_glyph.h
   branches/avidemux_2.4_branch/avidemux/ADM_osSupport/ADM_crashdump.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_ocr/adm_editglyph.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_ocr/adm_ocr.cpp
Log:
[OCR] cleanup

Copied: branches/avidemux_2.4_branch/avidemux/ADM_ocr/ADM_ocr.cpp (from rev 3352, branches/avidemux_2.4_branch/avidemux/ADM_ocr/adm_glyph.cpp)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_ocr/adm_glyph.cpp	2007-07-09 14:04:04 UTC (rev 3352)
+++ branches/avidemux_2.4_branch/avidemux/ADM_ocr/ADM_ocr.cpp	2007-07-13 17:01:23 UTC (rev 3361)
@@ -0,0 +1,280 @@
+/***************************************************************************
+      UI independant part of the OCR engine
+      (C) 2007 Mean
+ ***************************************************************************/
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+ #include &quot;config.h&quot;
+ #include &lt;stdio.h&gt;
+ #include &lt;stdlib.h&gt;
+ #include &lt;string.h&gt;
+ #include &quot;ADM_assert.h&quot;
+ #include &quot;default.h&quot;
+ #include &quot;ADM_ocr.h&quot;
+ #include &quot;ADM_toolkit/toolkit.hxx&quot;
+ #include &quot;ADM_userInterfaces/ADM_commonUI/DIA_enter.h&quot;
+
+static uint32_t minThreshold=0x80;
+
+/* In the UI related code */
+extern ReplyType glyphToText(admGlyph *glyph);
+extern void UI_purge(void);
+
+extern uint8_t adm_estimate_glyphSize(admGlyph *glyph,uint32_t *minx, uint32_t *maxx,uint32_t *miny,uint32_t *maxy,int *raw);
+
+static uint32_t minAlpha=7; /* Below minAlpha is is considered black */
+
+/**
+      \fn mergeBitmap
+      \brief Merge bitmap with alpha mask so that we go a black &amp; white output
+      @param bitin bitmap (input)
+      @param bitout B&amp;W bitmap (output)
+      @param maskin alpha mask (input)
+      @param w width of bitmap
+      @param h height of bitmap
+
+*/
+uint8_t mergeBitmap(uint8_t *bitin, uint8_t *bitout, uint8_t *maskin,uint32_t w, uint32_t h)
+{
+// Merge with alpha channel
+           uint8_t *in,*mask,*out;
+           uint32_t alp,nw;
+           in=bitin;
+           out=bitout;
+           mask=maskin;
+           for(uint32_t y=0;y&lt;h;y++)
+           {
+            for(uint32_t x=0;x&lt;w;x++)
+            {
+                   
+                    nw=in[x];
+                    alp=mask[x];
+
+                    if(alp&gt;minAlpha&amp;&amp; nw &gt;minThreshold)  nw=0xff;
+                         else       nw=0;
+                        
+                    out[x]=nw;
+            }
+            out+=w;
+            in+=w;
+            mask+=w;
+           }    
+    return 1;
+}
+/**
+      \fn ocrBitmap
+      \brief Split the bitmap into glyphes, ocr glyphes and output text
+      @param workArea, Bitmap to work with
+      @param w width of bitmap
+      @param h height of bitmap
+      @param decodedString Will contain ocr'ed text
+*/
+ReplyType ocrBitmap(uint8_t *workArea,uint32_t w,uint32_t h,char *decodedString)
+{
+uint8_t found;
+uint32_t colstart=0,colend=0,oldcol;
+uint32_t line=0,nbLine=1;
+uint32_t base=0,bottom,top;    
+ReplyType reply;
+    // Search First non nul colum
+    decodedString[0]=0;
+    // Search how much lines there is in the file
+    //
+    top=bottom=0;
+    while(top&lt;h)
+    {
+        // Search non empty line as top
+        while(top&lt;h &amp;&amp; lineEmpty(workArea,w,w,top)) top++;
+        // Nothing found
+        if(top&gt;=h-1) break;
+
+        // 
+       
+
+        bottom=top+1;
+        // Search empty line if any, bottom is the 1st line full of zero
+        while(bottom&lt;h &amp;&amp; (!lineEmpty(workArea,w,w,bottom) || bottom-top&lt;7))
+        {
+            bottom++;
+        }
+        if(line) strcat(decodedString,&quot;\n&quot;); 
+        //printf(&quot;\n Top:%lu bottom:%lu\n&quot;,top,bottom);
+       
+        // Scan a full line
+        colstart=0;
+        oldcol=0;
+       
+        // Split a line into glyphs
+        while(colstart&lt;w)
+        {
+            UI_purge();
+            oldcol=colstart;
+            while( columnEmpty(workArea+colstart+top*w, w, bottom-top) &amp;&amp; colstart&lt;w) colstart++;
+            if(colstart&gt;=w) break;
+            // if too far apart, it means probably a blank space
+            if(colstart-oldcol&gt;6)
+            {
+                strcat(decodedString,&quot; &quot;);
+            }
+       
+            // We have found a non null column
+            // Seek the end now
+            colend=colstart+1;
+            while( !columnEmpty(workArea+colend+top*w, w, bottom-top) &amp;&amp; colend&lt;w) colend++;
+         
+         
+            // printf(&quot;Found glyph: %lu %lu\n&quot;,colstart,colend);  
+            reply=handleGlyph(workArea,colstart,colend,w,bottom,top);
+            switch(reply)
+                {
+                        case ReplySkip:break;
+                        case ReplyOk:break;
+                        case ReplyClose:
+                        case ReplyCalibrate: return reply;break;
+            
+                        case ReplySkipAll: return ReplyOk;break;
+                        default: ADM_assert(0);
+                }
+            
+            
+            colstart=colend;
+      }
+      line++;      
+      top=bottom;
+      
+    }
+   
+    return ReplyOk;
+}
+
+/**
+      \fn handleGlyph
+      \brief Handle ONE glyph
+      @param workArea full bitmap to OCR 
+      @param start Start column of glyph
+      @param end end column of glyph
+      @param w Width of bitmap
+      @param h Height of bitmap
+      @param base Baseline of glyph
+    We now have a good candidate for the glyph.
+    We will do the following processing :
+        - Clip the glyph to have it in its bounding box
+        - extract its container. If the container is smaller than the glyph, it means
+                that we have in fact several glyphs that overlaps slightly. In
+                that case we use another method to extract the glyph.
+                We split it using leftturn method and do it again.
+*/
+ReplyType handleGlyph(uint8_t *workArea,uint32_t start, uint32_t end,uint32_t w,uint32_t h,uint32_t base)
+{
+uint8_t found=0;
+static int inc=1;
+ReplyType reply;
+          
+    
+    // Ok now we have the cropped glyp
+    
+    admGlyph *glyph,*cand;
+    uint32_t minx,maxx,miny,maxy;
+    int     *raw=NULL;
+            glyph=new admGlyph(end-start,h-base);
+            glyph-&gt;create(workArea+start+base*w,w);
+            glyph=clippedGlyph(glyph);
+            if(!glyph-&gt;width) // Empty glyph
+            {
+                delete glyph;
+                return ReplyOk;
+            }
+            // now we have our full glyph, try harder to split it
+_nextglyph:
+            raw=new int[glyph-&gt;height];            
+            if(adm_estimate_glyphSize(glyph,&amp;minx, &amp;maxx,&amp;miny,&amp;maxy,raw))
+            {
+            //printf(&quot;Glyph width :%lu min:%lu max:%lu estimate width:%lu\n&quot;,glyph-&gt;width,minx,maxx,maxx-minx+1);
+            if((maxx-minx+2)&lt;glyph-&gt;width &amp;&amp; (maxx-minx&gt;2) &amp;&amp; (maxy-miny&gt;2))
+            {
+                // Suspicously too small
+                // We have to split the glyph
+                // recursively to extract each glyph
+                uint32_t width=maxx-minx+1;
+                uint32_t defStride=width+1;
+                
+                if(defStride&gt;glyph-&gt;width) defStride=glyph-&gt;width;
+                
+                admGlyph *lefty=new admGlyph(defStride,glyph-&gt;height);
+                for(int32_t i=miny;i&lt;=maxy;i++)
+                {
+                    if(raw[i]!=-1) memcpy(&amp;(lefty-&gt;data[0+i*defStride]),&amp;(glyph-&gt;data[minx+i*glyph-&gt;width]),raw[i]+1-minx);
+                    else
+                            memcpy(&amp;(lefty-&gt;data[0+i*defStride]),&amp;(glyph-&gt;data[minx+i*glyph-&gt;width]),defStride);
+                }
+                lefty=clippedGlyph(lefty);
+              
+                {
+                    // Remove that from the original
+                    for(uint32_t i=0;i&lt;glyph-&gt;height;i++)
+                    {
+                        //printf(&quot;%d:%d(%d)\n&quot;,i,raw[i],glyph-&gt;width);
+                        if(raw[i]!=-1) memset(&amp;(glyph-&gt;data[i*glyph-&gt;width]),0,raw[i]+1);
+                        else           memset(&amp;(glyph-&gt;data[i*glyph-&gt;width]),0,defStride); 
+                    }
+                    // Clip
+                    glyph=clippedGlyph(glyph);
+                
+                    if(lefty-&gt;width)
+                    {
+                        reply=glyphToText(lefty);
+                        if(reply!=ReplyOk)
+                        {
+                            printf(&quot;Glyph2text failed(1)\n&quot;);
+                            return reply;
+                        }
+                    }
+                    else
+                        delete lefty;
+                    if(glyph-&gt;width)
+                    {
+                        if(raw) delete [] raw;
+                        goto _nextglyph;                    
+                    } 
+                 }           
+            }
+            }//If
+            if(raw) delete [] raw;
+            if(glyph-&gt;width)
+            {
+                reply=glyphToText(glyph);
+                if(reply!=ReplyOk)                 
+                {
+                    printf(&quot;Glyph2text failed(2)\n&quot;);
+                    return reply;
+                }
+            }
+            else 
+            {
+                delete glyph;
+            }
+            
+    return ReplyOk;
+
+}
+/**
+      \fn ocrUpdateMinThreshold
+      \brief update the threshold to say black or white when we merge bitmap and alpha mask
+*/
+void ocrUpdateMinThreshold(void)
+{
+        int val;
+        val=minThreshold;
+        if(DIA_GetIntegerValue(&amp;val, 0x30, 0x80, &quot;Minimum pixel value&quot;, &quot;Enter new minimum pixel&quot;))
+        {
+                minThreshold=val;
+
+        }
+}
+//EOF

Copied: branches/avidemux_2.4_branch/avidemux/ADM_ocr/ADM_ocr.h (from rev 3352, branches/avidemux_2.4_branch/avidemux/ADM_ocr/ADM_leftturn.h)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_ocr/ADM_leftturn.h	2007-07-09 14:04:04 UTC (rev 3352)
+++ branches/avidemux_2.4_branch/avidemux/ADM_ocr/ADM_ocr.h	2007-07-13 17:01:23 UTC (rev 3361)
@@ -0,0 +1,30 @@
+//
+// C++ Interface: %{MODULE}
+//
+// Description: 
+//
+//
+// Author: %{AUTHOR} &lt;%{EMAIL}&gt;, (C) %{YEAR}
+//
+// Copyright: See COPYING file that comes with this distribution
+//
+//
+#ifndef ADM_OCR_H
+#define ADM_OCR_H
+#include &quot;adm_glyph.h&quot;
+
+
+typedef enum 
+{
+        ReplyOk=1,
+        ReplyClose=0,
+        ReplyCalibrate=2,
+        ReplySkip=3,
+        ReplySkipAll=4
+}ReplyType;
+
+ReplyType handleGlyph(uint8_t *workArea,uint32_t start, uint32_t end,uint32_t w,uint32_t h,uint32_t base);
+ReplyType ocrBitmap(uint8_t *data,uint32_t w,uint32_t h,char *decodedString);
+uint8_t   mergeBitmap(uint8_t *bitin, uint8_t *bitout, uint8_t *maskin,uint32_t w, uint32_t h);
+void ocrUpdateMinThreshold(void);
+#endif 

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_ocr/ADM_ocrLoadSave.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_ocr/ADM_ocrLoadSave.h	2007-07-13 15:22:27 UTC (rev 3360)
+++ branches/avidemux_2.4_branch/avidemux/ADM_ocr/ADM_ocrLoadSave.h	2007-07-13 17:01:23 UTC (rev 3361)
@@ -1,99 +0,0 @@
-//
-// C++ Interface: %{MODULE}
-//
-// Description: 
-//
-//
-// Author: %{AUTHOR} &lt;%{EMAIL}&gt;, (C) %{YEAR}
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-/**
- */
-uint8_t saveGlyph(void)
-{
-  FILE *out;
-  char *name=NULL;
-  uint32_t slen;
-    
-  admGlyph *glyph=head.next;
-    
-  GUI_FileSelWrite(_(&quot;Select Glyphfile to save to&quot;), &amp;name);
-  if(!name)
-    return 0;
-    
-  out=fopen(name,&quot;wb&quot;);
-  ADM_dealloc(name);
-  if(!out)
-  {
-    GUI_Error_HIG(_(&quot;Could not write the file&quot;), NULL);
-    return 0;
-  }
-#define WRITE(x) fwrite(&amp;(x),sizeof(x),1,out);
-    WRITE(nbGlyphs);
-    
-    while(glyph)
-    {
-      WRITE(glyph-&gt;width);
-      WRITE(glyph-&gt;height);
-      fwrite(glyph-&gt;data,glyph-&gt;width*glyph-&gt;height,1,out);
-      if(glyph-&gt;code) slen=strlen(glyph-&gt;code);
-      else slen=0;
-      WRITE(slen);
-      fwrite(glyph-&gt;code,slen,1,out);
-      glyph=glyph-&gt;next;
-    }
-    
-    fclose(out);
-    return 1;
-
-}
-/**
- */
-uint8_t loadGlyph(char *name)
-{
-  FILE *out;
-  admGlyph *glyph,*nw;
-  uint32_t N,w,h,slen;
-    
-  if(head.next)
-  {
-    if(!GUI_Question(_(&quot;Erase current glyphs ?&quot;)))
-      return 0;
-    destroyGlyphTree(&amp;head);
-    nbGlyphs=0;
-  }
-  glyph=&head;
-  out=fopen(name,&quot;rb&quot;);
-  if(!out)
-  {
-    GUI_Error_HIG(_(&quot;File error&quot;), _(&quot;Could not read \&quot;%s\&quot;.&quot;), name);
-    return 0;
-  }
-#define READ(x) fread(&amp;(x),sizeof(x),1,out);
-    nbGlyphs=0;
-    READ(N);
-    while(N--)
-    {
-        
-      READ(w);
-      READ(h);
-      nw=new admGlyph(w,h);
-      fread(nw-&gt;data,w*h,1,out);
-      READ(slen);
-      if(slen)
-      {
-        nw-&gt;code=new char[slen+1];
-        fread(nw-&gt;code,slen,1,out);
-        nw-&gt;code[slen]=0;
-      }
-      glyph-&gt;next=nw;
-      glyph=nw;
-      nbGlyphs++;
-    }
-    
-    fclose(out);
-    return 1;
-
-}

Modified: branches/avidemux_2.4_branch/avidemux/ADM_ocr/CMakeLists.txt
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_ocr/CMakeLists.txt	2007-07-13 15:22:27 UTC (rev 3360)
+++ branches/avidemux_2.4_branch/avidemux/ADM_ocr/CMakeLists.txt	2007-07-13 17:01:23 UTC (rev 3361)
@@ -1,5 +1,7 @@
 
 SET(ADM_ocr_SRCS 
-adm_glyph.cpp  adm_leftturn.cpp  ADM_vob2vobsub.cpp)
+adm_glyph.cpp  adm_leftturn.cpp  ADM_vob2vobsub.cpp
+ADM_ocr.cpp
+)
 ADD_LIBRARY(ADM_ocr STATIC ${ADM_ocr_SRCS})
-include_directories(../ADM_inputs)
\ No newline at end of file
+include_directories(../ADM_inputs)

Modified: branches/avidemux_2.4_branch/avidemux/ADM_ocr/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_ocr/Makefile.am	2007-07-13 15:22:27 UTC (rev 3360)
+++ branches/avidemux_2.4_branch/avidemux/ADM_ocr/Makefile.am	2007-07-13 17:01:23 UTC (rev 3361)
@@ -7,7 +7,7 @@
 
 libADM_ocr_a_METASOURCES = AUTO
 
-libADM_ocr_a_SOURCES =   adm_glyph.cpp adm_leftturn.cpp ADM_vob2vobsub.cpp
+libADM_ocr_a_SOURCES =   adm_glyph.cpp adm_leftturn.cpp ADM_vob2vobsub.cpp ADM_ocr.cpp
 
 
 EXTRA_DIST =  ADM_leftturn.h     ADM_vob2vobsub.cpp  adm_glyph.h  \

Modified: branches/avidemux_2.4_branch/avidemux/ADM_ocr/adm_glyph.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_ocr/adm_glyph.cpp	2007-07-13 15:22:27 UTC (rev 3360)
+++ branches/avidemux_2.4_branch/avidemux/ADM_ocr/adm_glyph.cpp	2007-07-13 17:01:23 UTC (rev 3361)
@@ -13,6 +13,7 @@
  #include &quot;ADM_assert.h&quot;
  #include &quot;default.h&quot;
  #include &quot;adm_glyph.h&quot;
+#include &quot;ADM_toolkit/toolkit.hxx&quot;
  //*************************************************
 admGlyph::admGlyph(uint32_t w,uint32_t h)
 {
@@ -154,4 +155,89 @@
   return NULL;
 }
 /*************************************************/
+/**
+    \fn       glyphSave
+    \brief    Save the glypset
+*/
+uint8_t saveGlyph(char *name,admGlyph *head,uint32_t nb)
+{
+  FILE *out;
+  uint32_t slen;
+    
+  admGlyph *glyph=head-&gt;next;
+    
+    
+  out=fopen(name,&quot;wb&quot;);
+  if(!out)
+  {
+    GUI_Error_HIG(_(&quot;Could not write the file&quot;), NULL);
+    return 0;
+  }
+#define WRITE(x) fwrite(&amp;(x),sizeof(x),1,out);
+    WRITE(nb);
+    
+    while(glyph)
+    {
+      WRITE(glyph-&gt;width);
+      WRITE(glyph-&gt;height);
+      fwrite(glyph-&gt;data,glyph-&gt;width*glyph-&gt;height,1,out);
+      if(glyph-&gt;code) slen=strlen(glyph-&gt;code);
+      else slen=0;
+      WRITE(slen);
+      fwrite(glyph-&gt;code,slen,1,out);
+      glyph=glyph-&gt;next;
+    }
+    
+    fclose(out);
+    return 1;
+  
+}
+/**
+    \fn loadGlyph
+    \brief Load a glyph set
+*/
+uint8_t loadGlyph(char *name,admGlyph *head,uint32_t *outNb)
+{
+  FILE *out;
+  admGlyph *glyph,*nw;
+  uint32_t N,w,h,slen;
+  uint32_t nbGlyphs;
+ 
+  *outNb=0;
+  
+  glyph=head;
+  out=fopen(name,&quot;rb&quot;);
+  if(!out)
+  {
+    GUI_Error_HIG(_(&quot;File error&quot;), _(&quot;Could not read \&quot;%s\&quot;.&quot;), name);
+    return 0;
+  }
+#define READ(x) fread(&amp;(x),sizeof(x),1,out);
+    nbGlyphs=0;
+    READ(N);
+    while(N--)
+    {
+        
+      READ(w);
+      READ(h);
+      nw=new admGlyph(w,h);
+      fread(nw-&gt;data,w*h,1,out);
+      READ(slen);
+      if(slen)
+      {
+        nw-&gt;code=new char[slen+1];
+        fread(nw-&gt;code,slen,1,out);
+        nw-&gt;code[slen]=0;
+      }
+      glyph-&gt;next=nw;
+      glyph=nw;
+      nbGlyphs++;
+    }
+    
+    fclose(out);
+    *outNb=nbGlyphs;
+    return 1;
 
+}
+/*************************************************/
+

Modified: branches/avidemux_2.4_branch/avidemux/ADM_ocr/adm_glyph.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_ocr/adm_glyph.h	2007-07-13 15:22:27 UTC (rev 3360)
+++ branches/avidemux_2.4_branch/avidemux/ADM_ocr/adm_glyph.h	2007-07-13 17:01:23 UTC (rev 3361)
@@ -60,4 +60,9 @@
 uint8_t  insertInGlyphTree(admGlyph *startGlyph, admGlyph *candidate);
 admGlyph *clippedGlyph(admGlyph *in);
 admGlyph *glyphSearchFather(admGlyph *in,admGlyph *head );
+
+uint8_t loadGlyph(char *name,admGlyph *head,uint32_t *outNb);
+uint8_t saveGlyph(char *name,admGlyph *head,uint32_t nb);
+
+
 #endif

Modified: branches/avidemux_2.4_branch/avidemux/ADM_osSupport/ADM_crashdump.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_osSupport/ADM_crashdump.cpp	2007-07-13 15:22:27 UTC (rev 3360)
+++ branches/avidemux_2.4_branch/avidemux/ADM_osSupport/ADM_crashdump.cpp	2007-07-13 17:01:23 UTC (rev 3361)
@@ -1,7 +1,7 @@
 /***************************************************************************
   Try to display interesting crash dump
 
-    copyright            : (C) 2007 by mean
+    copyright            : (C) 2007 by mean, (C) 2007 Grunster
     email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
  ***************************************************************************/
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_ocr/adm_editglyph.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_ocr/adm_editglyph.cpp	2007-07-13 15:22:27 UTC (rev 3360)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_ocr/adm_editglyph.cpp	2007-07-13 17:01:23 UTC (rev 3361)
@@ -33,8 +33,6 @@
 static admGlyph *currentGlyph=NULL;
 static GtkWidget *dialog;
 
-static uint8_t loadGlyph(char *name,admGlyph *head,uint32_t *outNb);
-static uint8_t saveGlyph(char *name,admGlyph *head,uint32_t nb);
 static gboolean glyphDraw( void );
 static gboolean glyphActivate(void);
 static void glyphUpdate(void );
@@ -265,43 +263,6 @@
 
 }
 /**
-    \fn       glyphSave
-    \brief    Save the glypset
-*/
-uint8_t saveGlyph(char *name,admGlyph *head,uint32_t nb)
-{
-  FILE *out;
-  uint32_t slen;
-    
-  admGlyph *glyph=head-&gt;next;
-    
-    
-  out=fopen(name,&quot;wb&quot;);
-  if(!out)
-  {
-    GUI_Error_HIG(_(&quot;Could not write the file&quot;), NULL);
-    return 0;
-  }
-#define WRITE(x) fwrite(&amp;(x),sizeof(x),1,out);
-    WRITE(nb);
-    
-    while(glyph)
-    {
-      WRITE(glyph-&gt;width);
-      WRITE(glyph-&gt;height);
-      fwrite(glyph-&gt;data,glyph-&gt;width*glyph-&gt;height,1,out);
-      if(glyph-&gt;code) slen=strlen(glyph-&gt;code);
-      else slen=0;
-      WRITE(slen);
-      fwrite(glyph-&gt;code,slen,1,out);
-      glyph=glyph-&gt;next;
-    }
-    
-    fclose(out);
-    return 1;
-  
-}
-/**
     \fn glyphUpdate
     \brief Update all fields in the dialog wrt currentGlyph
 */
@@ -346,51 +307,7 @@
     return true;
 }
 
-/**
-    \fn loadGlyph
-    \brief Load a glyph set
-*/
-uint8_t loadGlyph(char *name,admGlyph *head,uint32_t *outNb)
-{
-  FILE *out;
-  admGlyph *glyph,*nw;
-  uint32_t N,w,h,slen;
-  uint32_t nbGlyphs;
- 
-  glyph=head;
-  out=fopen(name,&quot;rb&quot;);
-  if(!out)
-  {
-    GUI_Error_HIG(_(&quot;File error&quot;), _(&quot;Could not read \&quot;%s\&quot;.&quot;), name);
-    return 0;
-  }
-#define READ(x) fread(&amp;(x),sizeof(x),1,out);
-    nbGlyphs=0;
-    READ(N);
-    while(N--)
-    {
-        
-      READ(w);
-      READ(h);
-      nw=new admGlyph(w,h);
-      fread(nw-&gt;data,w*h,1,out);
-      READ(slen);
-      if(slen)
-      {
-        nw-&gt;code=new char[slen+1];
-        fread(nw-&gt;code,slen,1,out);
-        nw-&gt;code[slen]=0;
-      }
-      glyph-&gt;next=nw;
-      glyph=nw;
-      nbGlyphs++;
-    }
-    
-    fclose(out);
-    *outNb=nbGlyphs;
-    return 1;
 
-}
 
 
 //**********************************

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_ocr/adm_ocr.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_ocr/adm_ocr.cpp	2007-07-13 15:22:27 UTC (rev 3360)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_ocr/adm_ocr.cpp	2007-07-13 17:01:23 UTC (rev 3361)
@@ -67,59 +67,43 @@
 #include &quot;ADM_video/ADM_vidVobSub.h&quot;
 #include &quot;ADM_leftturn.h&quot;
 #include &quot;DIA_enter.h&quot;
+#include &quot;ADM_ocr.h&quot;
 /******************************/
-#define GTK_PURGE {while (gtk_events_pending())                gtk_main_iteration(); }    
+
 #define TESTSUB &quot;/home/fx/usbstick/subs/vts_01_0.idx&quot;
 #define CONNECT(x,y,z) 	gtk_signal_connect(GTK_OBJECT(WID(x)), #y,GTK_SIGNAL_FUNC(z),   NULL);
-#define SUB_THRESH minThreshold
 
-typedef enum 
-{
-        ReplyOk=1,
-        ReplyClose=0,
-        ReplyCalibrate=2,
-        ReplySkip=3,
-        ReplySkipAll=4
-}ReplyType;
 
-static uint8_t mergeBitmap(uint8_t *bitin, uint8_t *bitout, uint8_t *maskin,uint32_t w, uint32_t h);
-static ReplyType ocrBitmap(uint8_t *data,uint32_t w,uint32_t h);
-static ReplyType handleGlyph(uint32_t start, uint32_t end,uint32_t w,uint32_t h,uint32_t base);
-static uint8_t lineEmpty(uint8_t *base, uint32_t stride, uint32_t width, uint32_t line);
-static uint8_t columnEmpty(uint8_t *base, uint32_t stride, uint32_t height);
-static ReplyType glyphToText(admGlyph *glyph);
-static uint8_t saveGlyph(void);
-static uint8_t loadGlyph(char *name);
-static void displaySmall( admGlyph *glyph );
-static int cb_accept(GtkObject * object, gpointer user_data);
-static ReplyType setup(void);
-static  vobSubParam subparam={NULL,0,0};
-static uint32_t minAlpha=7;
-static uint32_t minThreshold=0x80;
 
 
-/*++++++++++++++++++++++++++++++++++++++++*/
-extern  GtkWidget	*DIA_ocr(void);
+
+
+
 extern  uint8_t DIA_vobsub(vobSubParam *param);
-static gboolean gui_draw( void );
-static gboolean gui_draw_small( void );
-static char decodedString[1024];
-/*-------------------------*/
+//********************************************
+extern  GtkWidget *DIA_ocr(void);
+static gboolean   gui_draw( void );
+static gboolean   gui_draw_small( void );
+static void       displaySmall( admGlyph *glyph );
+static int        cb_accept(GtkObject * object, gpointer user_data);
+
 static GtkWidget *dialog;
 static GtkWidget *mainDisplay;
 static GtkWidget *smallDisplay;
-static vobSubBitmap *bitmap;
-
+static uint32_t redraw_x,redraw_y;
+//********************************************
+ReplyType glyphToText(admGlyph *glyph);
+static ReplyType setup(void);
+//********************************************
+static uint8_t ocrSaveGlyph(void);
+static  vobSubParam subparam={NULL,0,0};
 static uint8_t *workArea;
+static vobSubBitmap *bitmap;
 static admGlyph head(250,4);
 static uint32_t lang_index=0;
-
-
-static uint32_t redraw_x,redraw_y;
-
 static uint32_t nbGlyphs;
+static char decodedString[1024];
 
-
 typedef enum
 {
     actionLoadVob=10,
@@ -191,7 +175,7 @@
     // Everything ready go go go 
          
     redraw_x=redraw_y=0;
-    GTK_PURGE;
+    UI_purge();
 //  Time to go
     // Inactivate frame1=glyph    frame2=in/out  buttonStart
     gtk_widget_set_sensitive(WID(buttonStart),0);
@@ -268,34 +252,20 @@
            mergeBitmap(bitmap-&gt;_bitmap+first*w, workArea, bitmap-&gt;_alphaMask+first*w,  w,   h);
            if(oldw!=w || oldh !=h)
            {                
-                GTK_PURGE;  // Force redaw
+                UI_purge();  // Force redaw
            }
            // Merge
-             GTK_PURGE;
+             UI_purge();
              gui_draw();
-             GTK_PURGE; 
+             UI_purge();
              // OCR
-              reply=ocrBitmap(workArea,w,h);
+              reply=ocrBitmap(workArea,w,h,decodedString);
               if(reply==ReplyClose) goto endIt;
               if(reply==ReplyCalibrate)
                 {
                         //
                         //printf(&quot;TADA!!!!\n&quot;);
-                        int val;
-#if 0
-                         val=minAlpha;
-                        if(DIA_GetIntegerValue(&amp;val, 3, 7, &quot;Minimum alpha value&quot;, &quot;Enter new minimum alpha&quot;))
-                        {
-                                minAlpha=val;
-
-                        }
-#endif
-                        val=minThreshold;
-                        if(DIA_GetIntegerValue(&amp;val, 0x30, 0x80, &quot;Minimum pixel value&quot;, &quot;Enter new minimum pixel&quot;))
-                        {
-                                minThreshold=val;
-
-                        }
+                        ocrUpdateMinThreshold();
                         goto againPlease;
                 }
              
@@ -327,7 +297,9 @@
    // gtk_widget_set_sensitive(WID(Current_Glyph),0); 
     
     if(nbGlyphs &amp;&amp; actionSaveGlyph==gtk_dialog_run(GTK_DIALOG(dialog)))
-        saveGlyph();
+    {
+      ocrSaveGlyph();
+    }
     if(vobsub)
         delete vobsub;
     vobsub=NULL;
@@ -342,192 +314,22 @@
     return 1;
 
 }
-
-//*****************************************************************************************
-//  Separate the bitmap into glyph and handle each glyph on itw own
-//
-//*****************************************************************************************
-
-ReplyType ocrBitmap(uint8_t *data,uint32_t w,uint32_t h)
-{
-uint8_t found;
-uint32_t colstart=0,colend=0,oldcol;
-uint32_t line=0,nbLine=1;
-uint32_t base=0,bottom,top;    
-ReplyType reply;
-    // Search First non nul colum
-    decodedString[0]=0;
-    // Search how much lines there is in the file
-    //
-    top=bottom=0;
-    while(top&lt;h)
-    {
-        // Search non empty line as top
-        while(top&lt;h &amp;&amp; lineEmpty(workArea,w,w,top)) top++;
-        // Nothing found
-        if(top&gt;=h-1) break;
-
-        // 
-       
-
-        bottom=top+1;
-        // Search empty line if any, bottom is the 1st line full of zero
-        while(bottom&lt;h &amp;&amp; (!lineEmpty(workArea,w,w,bottom) || bottom-top&lt;7))
-        {
-            bottom++;
-        }
-        if(line) strcat(decodedString,&quot;\n&quot;); 
-        //printf(&quot;\n Top:%lu bottom:%lu\n&quot;,top,bottom);
-       
-        // Scan a full line
-        colstart=0;
-        oldcol=0;
-       
-        // Split a line into glyphs
-        while(colstart&lt;w)
-        {
-            GTK_PURGE;
-            oldcol=colstart;
-            while( columnEmpty(workArea+colstart+top*w, w, bottom-top) &amp;&amp; colstart&lt;w) colstart++;
-            if(colstart&gt;=w) break;
-            // if too far apart, it means probably a blank space
-            if(colstart-oldcol&gt;6)
-            {
-                strcat(decodedString,&quot; &quot;);
-            }
-       
-            // We have found a non null column
-            // Seek the end now
-            colend=colstart+1;
-            while( !columnEmpty(workArea+colend+top*w, w, bottom-top) &amp;&amp; colend&lt;w) colend++;
-         
-         
-            // printf(&quot;Found glyph: %lu %lu\n&quot;,colstart,colend);  
-            reply=handleGlyph(colstart,colend,w,bottom,top);
-            switch(reply)
-                {
-                        case ReplySkip:break;
-                        case ReplyOk:break;
-                        case ReplyClose:
-                        case ReplyCalibrate: return reply;break;
-            
-                        case ReplySkipAll: return ReplyOk;break;
-                        default: ADM_assert(0);
-                }
-            
-            
-            colstart=colend;
-      }
-      line++;      
-      top=bottom;
-      
-    }
-   
-    return ReplyOk;
-}
-//*****************************************************************************************
-/*
-    We now have a good candidate for the glyph.
-    We will do the following processing :
-        - Clip the glyph to have it in its bounding box
-        - extract its container. If the container is smaller than the glyph, it means
-                that we have in fact several glyphs that overlaps slightly. In
-                that case we use another method to extract the glyph.
-                We split it using leftturn method and do it again.
+/**
+    \fn ocrSaveGlyph
+    \brief bridge to saveGlyph
 */
-ReplyType handleGlyph(uint32_t start, uint32_t end,uint32_t w,uint32_t h,uint32_t base)
+uint8_t ocrSaveGlyph(void)
 {
-uint8_t found=0;
-static int inc=1;
-ReplyType reply;
-          
-    
-    // Ok now we have the cropped glyp
-    
-    admGlyph *glyph,*cand;
-    uint32_t minx,maxx,miny,maxy;
-    int     *raw=NULL;
-            glyph=new admGlyph(end-start,h-base);
-            glyph-&gt;create(workArea+start+base*w,w);
-            glyph=clippedGlyph(glyph);
-            if(!glyph-&gt;width) // Empty glyph
-            {
-                delete glyph;
-                return ReplyOk;
-            }
-            // now we have our full glyph, try harder to split it
-_nextglyph:
-            raw=new int[glyph-&gt;height];            
-            if(adm_estimate_glyphSize(glyph,&amp;minx, &amp;maxx,&amp;miny,&amp;maxy,raw))
-            {
-            //printf(&quot;Glyph width :%lu min:%lu max:%lu estimate width:%lu\n&quot;,glyph-&gt;width,minx,maxx,maxx-minx+1);
-            if((maxx-minx+2)&lt;glyph-&gt;width &amp;&amp; (maxx-minx&gt;2) &amp;&amp; (maxy-miny&gt;2))
-            {
-                // Suspicously too small
-                // We have to split the glyph
-                // recursively to extract each glyph
-                uint32_t width=maxx-minx+1;
-                uint32_t defStride=width+1;
-                
-                if(defStride&gt;glyph-&gt;width) defStride=glyph-&gt;width;
-                
-                admGlyph *lefty=new admGlyph(defStride,glyph-&gt;height);
-                for(int32_t i=miny;i&lt;=maxy;i++)
-                {
-                    if(raw[i]!=-1) memcpy(&amp;(lefty-&gt;data[0+i*defStride]),&amp;(glyph-&gt;data[minx+i*glyph-&gt;width]),raw[i]+1-minx);
-                    else
-                            memcpy(&amp;(lefty-&gt;data[0+i*defStride]),&amp;(glyph-&gt;data[minx+i*glyph-&gt;width]),defStride);
-                }
-                lefty=clippedGlyph(lefty);
-              
-                {
-                    // Remove that from the original
-                    for(uint32_t i=0;i&lt;glyph-&gt;height;i++)
-                    {
-                        //printf(&quot;%d:%d(%d)\n&quot;,i,raw[i],glyph-&gt;width);
-                        if(raw[i]!=-1) memset(&amp;(glyph-&gt;data[i*glyph-&gt;width]),0,raw[i]+1);
-                        else           memset(&amp;(glyph-&gt;data[i*glyph-&gt;width]),0,defStride); 
-                    }
-                    // Clip
-                    glyph=clippedGlyph(glyph);
-                
-                    if(lefty-&gt;width)
-                    {
-                        reply=glyphToText(lefty);
-                        if(reply!=ReplyOk)
-                        {
-                            printf(&quot;Glyph2text failed(1)\n&quot;);
-                            return reply;
-                        }
-                    }
-                    else
-                        delete lefty;
-                    if(glyph-&gt;width)
-                    {
-                        if(raw) delete [] raw;
-                        goto _nextglyph;                    
-                    } 
-                 }           
-            }
-            }//If
-            if(raw) delete [] raw;
-            if(glyph-&gt;width)
-            {
-                reply=glyphToText(glyph);
-                if(reply!=ReplyOk)                 
-                {
-                    printf(&quot;Glyph2text failed(2)\n&quot;);
-                    return reply;
-                }
-            }
-            else 
-            {
-                delete glyph;
-            }
-            
-    return ReplyOk;
+  char *name=NULL;
+          GUI_FileSelWrite(_(&quot;Select Glyphfile to save to&quot;), &amp;name);
+        if(!name)
+            return 0;
+        saveGlyph(name,&amp;head,nbGlyphs);
+        ADM_dealloc(name);
+        return 1;
 
 }
+
 /**
         Search throught the existing glyphs , if not present create it
         and append the text to decodedString
@@ -605,40 +407,8 @@
            return ReplyOk;  
 
 }
-/**************************************************************************************
-    returns 1 if the line is empty
-    0 if not
-*/
 
 //*****************************************************************************************
-uint8_t mergeBitmap(uint8_t *bitin, uint8_t *bitout, uint8_t *maskin,uint32_t w, uint32_t h)
-{
-// Merge with alpha channel
-           uint8_t *in,*mask,*out;
-           uint32_t alp,nw;
-           in=bitin;
-           out=bitout;
-           mask=maskin;
-           for(uint32_t y=0;y&lt;h;y++)
-           {
-            for(uint32_t x=0;x&lt;w;x++)
-            {
-                   
-                    nw=in[x];
-                    alp=mask[x];
-
-                    if(alp&gt;minAlpha&amp;&amp; nw &gt;SUB_THRESH)  nw=0xff;
-                         else       nw=0;
-                        
-                    out[x]=nw;
-            }
-            out+=w;
-            in+=w;
-            mask+=w;
-           }    
-    return 1;
-}
-//*****************************************************************************************
 gboolean gui_draw( void )
 {
 static int lastx=0,lasty=0;
@@ -721,7 +491,7 @@
     //gtk_widget_set_sensitive(WID(buttonAccept),0);
     //gtk_widget_set_sensitive(WID(buttonSkip),0);
     //gtk_widget_set_sensitive(WID(entryEntry),0);
-    GTK_PURGE;   
+    UI_purge();
     // Main loop : Only accept glyph load/save
     // Sub &amp; srt select &amp; start ocr
     gtk_widget_set_sensitive(WID(frameGlyph),1);
@@ -764,7 +534,7 @@
                     GUI_FileSelRead(_(&quot;Select Glyoh to save&quot;), &amp;gly);
                     if(gly)
                     {
-                            loadGlyph(gly);
+                            loadGlyph(gly,&amp;head,&amp;nbGlyphs);
                             sprintf(text,&quot;%03d&quot;,nbGlyphs);
                             gtk_label_set_text(GTK_LABEL(WID(labelNbGlyphs)),text);
                     }
@@ -778,8 +548,8 @@
                       GUI_Error_HIG(_(&quot;No glyphs to save&quot;), NULL);
                         break;
                     }                  
-                    saveGlyph();                                      
-                    break;
+                    ocrSaveGlyph();
+                        break;
         
         case GTK_RESPONSE_CLOSE: 
             printf(&quot;Close req\n&quot;);
@@ -792,16 +562,14 @@
     }
 }
 /**
+    \fn cb_accept
+    \brief Bridge between dialog/Accept and gtk signals
 */
 int cb_accept(GtkObject * object, gpointer user_data)
 {
         //printf(&quot;Hopla\n&quot;);
         gtk_signal_emit_by_name(GTK_OBJECT(WID(buttonOk)),&quot;clicked&quot;,(gpointer)1);
         return 0;
-
 }
 
-/**
- */
-#include &quot;ADM_ocrLoadSave.h&quot;
 //;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000637.html">[Avidemux-svn-commit] r3360 -	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_utilities
</A></li>
	<LI>Next message: <A HREF="000639.html">[Avidemux-svn-commit] r3362 - in	branches/avidemux_2.4_branch/avidemux:	ADM_libraries/ADM_libass ADM_videoFilter
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#638">[ date ]</a>
              <a href="thread.html#638">[ thread ]</a>
              <a href="subject.html#638">[ subject ]</a>
              <a href="author.html#638">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
