<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r3390 -	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2007-July/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r3390%20-%0A%09branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec&In-Reply-To=%3C200707161811.l6GIBdvJ010366%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000665.html">
   <LINK REL="Next"  HREF="000667.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r3390 -	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec</H1>
    <B>mean at BerliOS</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r3390%20-%0A%09branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec&In-Reply-To=%3C200707161811.l6GIBdvJ010366%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r3390 -	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec">mean at mail.berlios.de
       </A><BR>
    <I>Mon Jul 16 20:11:39 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000665.html">[Avidemux-svn-commit] r3389 - in	branches/avidemux_2.4_branch/avidemux/ADM_libraries:	ADM_lavcodec ADM_lavutil
</A></li>
        <LI>Next message: <A HREF="000667.html">[Avidemux-svn-commit] r3391 -	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#666">[ date ]</a>
              <a href="thread.html#666">[ thread ]</a>
              <a href="subject.html#666">[ subject ]</a>
              <a href="author.html#666">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2007-07-16 20:11:38 +0200 (Mon, 16 Jul 2007)
New Revision: 3390

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/allcodecs.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h261.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h263.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h263_parser.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h264.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h264_parser.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/mjpeg.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/mjpegdec.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/mpeg4video_parser.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/mpegvideo_common.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/msmpeg4.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/roqvideo.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/vc1.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/wma.h
Log:
missing files

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/allcodecs.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/allcodecs.h	2007-07-16 18:08:14 UTC (rev 3389)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/allcodecs.h	2007-07-16 18:11:38 UTC (rev 3390)
@@ -0,0 +1,288 @@
+/*
+ * copyright (c) 2001 Fabrice Bellard
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef ALLCODECS_H
+#define ALLCODECS_H
+
+#include &quot;avcodec.h&quot;
+
+extern AVCodec ac3_encoder;
+extern AVCodec asv1_encoder;
+extern AVCodec asv2_encoder;
+extern AVCodec bmp_encoder;
+extern AVCodec dvvideo_encoder;
+extern AVCodec ffv1_encoder;
+extern AVCodec ffvhuff_encoder;
+extern AVCodec flac_encoder;
+extern AVCodec flashsv_encoder;
+extern AVCodec flv_encoder;
+extern AVCodec gif_encoder;
+extern AVCodec h261_encoder;
+extern AVCodec h263_encoder;
+extern AVCodec h263p_encoder;
+extern AVCodec h264_encoder;
+extern AVCodec huffyuv_encoder;
+extern AVCodec jpegls_encoder;
+extern AVCodec ljpeg_encoder;
+extern AVCodec mdec_encoder;
+extern AVCodec mjpeg_encoder;
+extern AVCodec mp2_encoder;
+extern AVCodec mpeg1video_encoder;
+extern AVCodec mpeg2video_encoder;
+extern AVCodec mpeg4_encoder;
+extern AVCodec msmpeg4v1_encoder;
+extern AVCodec msmpeg4v2_encoder;
+extern AVCodec msmpeg4v3_encoder;
+extern AVCodec pam_encoder;
+extern AVCodec pbm_encoder;
+extern AVCodec pgm_encoder;
+extern AVCodec pgmyuv_encoder;
+extern AVCodec png_encoder;
+extern AVCodec ppm_encoder;
+extern AVCodec qtrle_encoder;
+extern AVCodec roq_dpcm_encoder;
+extern AVCodec roq_encoder;
+extern AVCodec rv10_encoder;
+extern AVCodec rv20_encoder;
+extern AVCodec sgi_encoder;
+extern AVCodec snow_encoder;
+extern AVCodec sonic_encoder;
+extern AVCodec sonic_ls_encoder;
+extern AVCodec svq1_encoder;
+extern AVCodec targa_encoder;
+extern AVCodec tiff_encoder;
+extern AVCodec vcr1_encoder;
+extern AVCodec vorbis_encoder;
+extern AVCodec wmav1_encoder;
+extern AVCodec wmav2_encoder;
+extern AVCodec wmv1_encoder;
+extern AVCodec wmv2_encoder;
+extern AVCodec zmbv_encoder;
+
+extern AVCodec aasc_decoder;
+extern AVCodec alac_decoder;
+extern AVCodec asv1_decoder;
+extern AVCodec asv2_decoder;
+extern AVCodec atrac3_decoder;
+extern AVCodec avs_decoder;
+extern AVCodec bethsoftvid_decoder;
+extern AVCodec bmp_decoder;
+extern AVCodec c93_decoder;
+extern AVCodec cavs_decoder;
+extern AVCodec cinepak_decoder;
+extern AVCodec cljr_decoder;
+extern AVCodec cook_decoder;
+extern AVCodec cscd_decoder;
+extern AVCodec cyuv_decoder;
+extern AVCodec dca_decoder;
+extern AVCodec dnxhd_decoder;
+extern AVCodec dsicinaudio_decoder;
+extern AVCodec dsicinvideo_decoder;
+extern AVCodec dvvideo_decoder;
+extern AVCodec dxa_decoder;
+extern AVCodec eightbps_decoder;
+extern AVCodec ffv1_decoder;
+extern AVCodec ffvhuff_decoder;
+extern AVCodec flac_decoder;
+extern AVCodec flashsv_decoder;
+extern AVCodec flic_decoder;
+extern AVCodec flv_decoder;
+extern AVCodec fourxm_decoder;
+extern AVCodec fraps_decoder;
+extern AVCodec gif_decoder;
+extern AVCodec h261_decoder;
+extern AVCodec h263_decoder;
+extern AVCodec h263i_decoder;
+extern AVCodec h264_decoder;
+extern AVCodec huffyuv_decoder;
+extern AVCodec idcin_decoder;
+extern AVCodec imc_decoder;
+extern AVCodec indeo2_decoder;
+extern AVCodec indeo3_decoder;
+extern AVCodec interplay_dpcm_decoder;
+extern AVCodec interplay_video_decoder;
+extern AVCodec jpegls_decoder;
+extern AVCodec kmvc_decoder;
+extern AVCodec loco_decoder;
+extern AVCodec mace3_decoder;
+extern AVCodec mace6_decoder;
+extern AVCodec mdec_decoder;
+extern AVCodec mjpeg_decoder;
+extern AVCodec mjpegb_decoder;
+extern AVCodec mmvideo_decoder;
+extern AVCodec mp2_decoder;
+extern AVCodec mp3_decoder;
+extern AVCodec mp3adu_decoder;
+extern AVCodec mp3on4_decoder;
+extern AVCodec mpc7_decoder;
+extern AVCodec mpeg1video_decoder;
+extern AVCodec mpeg2video_decoder;
+extern AVCodec mpeg4_decoder;
+extern AVCodec mpeg_xvmc_decoder;
+extern AVCodec mpegvideo_decoder;
+extern AVCodec msmpeg4v1_decoder;
+extern AVCodec msmpeg4v2_decoder;
+extern AVCodec msmpeg4v3_decoder;
+extern AVCodec msrle_decoder;
+extern AVCodec msvideo1_decoder;
+extern AVCodec mszh_decoder;
+extern AVCodec nuv_decoder;
+extern AVCodec png_decoder;
+extern AVCodec ptx_decoder;
+extern AVCodec qdm2_decoder;
+extern AVCodec qdraw_decoder;
+extern AVCodec qpeg_decoder;
+extern AVCodec qtrle_decoder;
+extern AVCodec ra_144_decoder;
+extern AVCodec ra_288_decoder;
+extern AVCodec roq_decoder;
+extern AVCodec roq_dpcm_decoder;
+extern AVCodec rpza_decoder;
+extern AVCodec rv10_decoder;
+extern AVCodec rv20_decoder;
+extern AVCodec rv30_decoder;
+extern AVCodec rv40_decoder;
+extern AVCodec sgi_decoder;
+extern AVCodec shorten_decoder;
+extern AVCodec smackaud_decoder;
+extern AVCodec smacker_decoder;
+extern AVCodec smc_decoder;
+extern AVCodec snow_decoder;
+extern AVCodec sol_dpcm_decoder;
+extern AVCodec sonic_decoder;
+extern AVCodec sp5x_decoder;
+extern AVCodec svq1_decoder;
+extern AVCodec svq3_decoder;
+extern AVCodec targa_decoder;
+extern AVCodec theora_decoder;
+extern AVCodec thp_decoder;
+extern AVCodec tiertexseqvideo_decoder;
+extern AVCodec tiff_decoder;
+extern AVCodec truemotion1_decoder;
+extern AVCodec truemotion2_decoder;
+extern AVCodec truespeech_decoder;
+extern AVCodec tscc_decoder;
+extern AVCodec tta_decoder;
+extern AVCodec txd_decoder;
+extern AVCodec ulti_decoder;
+extern AVCodec vc1_decoder;
+extern AVCodec vcr1_decoder;
+extern AVCodec vmdaudio_decoder;
+extern AVCodec vmdvideo_decoder;
+extern AVCodec vmnc_decoder;
+extern AVCodec vorbis_decoder;
+extern AVCodec vp3_decoder;
+extern AVCodec vp5_decoder;
+extern AVCodec vp6_decoder;
+extern AVCodec vp6f_decoder;
+extern AVCodec vqa_decoder;
+extern AVCodec wavpack_decoder;
+extern AVCodec wmav1_decoder;
+extern AVCodec wmav2_decoder;
+extern AVCodec wmv1_decoder;
+extern AVCodec wmv2_decoder;
+extern AVCodec wmv3_decoder;
+extern AVCodec wnv1_decoder;
+extern AVCodec ws_snd1_decoder;
+extern AVCodec xan_dpcm_decoder;
+extern AVCodec xan_wc3_decoder;
+extern AVCodec xl_decoder;
+extern AVCodec zmbv_decoder;
+
+/* PCM codecs */
+#define PCM_CODEC(id, name) \
+extern AVCodec name ## _decoder; \
+extern AVCodec name ## _encoder
+
+PCM_CODEC(CODEC_ID_PCM_ALAW,    pcm_alaw);
+PCM_CODEC(CODEC_ID_PCM_MULAW,   pcm_mulaw);
+PCM_CODEC(CODEC_ID_PCM_S8,      pcm_s8);
+PCM_CODEC(CODEC_ID_PCM_S16BE,   pcm_s16be);
+PCM_CODEC(CODEC_ID_PCM_S16LE,   pcm_s16le);
+PCM_CODEC(CODEC_ID_PCM_S24BE,   pcm_s24be);
+PCM_CODEC(CODEC_ID_PCM_S24DAUD, pcm_s24daud);
+PCM_CODEC(CODEC_ID_PCM_S24LE,   pcm_s24le);
+PCM_CODEC(CODEC_ID_PCM_S32BE,   pcm_s32be);
+PCM_CODEC(CODEC_ID_PCM_S32LE,   pcm_s32le);
+PCM_CODEC(CODEC_ID_PCM_U8,      pcm_u8);
+PCM_CODEC(CODEC_ID_PCM_U16BE,   pcm_u16be);
+PCM_CODEC(CODEC_ID_PCM_U16LE,   pcm_u16le);
+PCM_CODEC(CODEC_ID_PCM_U24BE,   pcm_u24be);
+PCM_CODEC(CODEC_ID_PCM_U24LE,   pcm_u24le);
+PCM_CODEC(CODEC_ID_PCM_U32BE,   pcm_u32be);
+PCM_CODEC(CODEC_ID_PCM_U32LE,   pcm_u32le);
+
+/* ADPCM codecs */
+
+PCM_CODEC(CODEC_ID_ADPCM_4XM,     adpcm_4xm);
+PCM_CODEC(CODEC_ID_ADPCM_ADX,     adpcm_adx);
+PCM_CODEC(CODEC_ID_ADPCM_CT,      adpcm_ct);
+PCM_CODEC(CODEC_ID_ADPCM_EA,      adpcm_ea);
+PCM_CODEC(CODEC_ID_ADPCM_G726,    adpcm_g726);
+PCM_CODEC(CODEC_ID_ADPCM_IMA_DK3, adpcm_ima_dk3);
+PCM_CODEC(CODEC_ID_ADPCM_IMA_DK4, adpcm_ima_dk4);
+PCM_CODEC(CODEC_ID_ADPCM_IMA_QT,  adpcm_ima_qt);
+PCM_CODEC(CODEC_ID_ADPCM_IMA_WAV, adpcm_ima_wav);
+PCM_CODEC(CODEC_ID_ADPCM_IMA_WS,  adpcm_ima_ws);
+PCM_CODEC(CODEC_ID_ADPCM_MS,      adpcm_ms);
+PCM_CODEC(CODEC_ID_ADPCM_SBPRO_2, adpcm_sbpro_2);
+PCM_CODEC(CODEC_ID_ADPCM_SBPRO_3, adpcm_sbpro_3);
+PCM_CODEC(CODEC_ID_ADPCM_SBPRO_4, adpcm_sbpro_4);
+PCM_CODEC(CODEC_ID_ADPCM_SMJPEG,  adpcm_ima_smjpeg);
+PCM_CODEC(CODEC_ID_ADPCM_SWF,     adpcm_swf);
+PCM_CODEC(CODEC_ID_ADPCM_THP,     adpcm_thp);
+PCM_CODEC(CODEC_ID_ADPCM_XA,      adpcm_xa);
+PCM_CODEC(CODEC_ID_ADPCM_YAMAHA,  adpcm_yamaha);
+
+#undef PCM_CODEC
+
+/* dummy raw video codec */
+extern AVCodec rawvideo_decoder;
+extern AVCodec rawvideo_encoder;
+
+/* the following codecs use external libs */
+extern AVCodec liba52_decoder;
+extern AVCodec libamr_nb_decoder;
+extern AVCodec libamr_nb_encoder;
+extern AVCodec libamr_wb_decoder;
+extern AVCodec libamr_wb_encoder;
+extern AVCodec libfaac_encoder;
+extern AVCodec libfaad_decoder;
+extern AVCodec libgsm_decoder;
+extern AVCodec libgsm_encoder;
+extern AVCodec libgsm_ms_decoder;
+extern AVCodec libgsm_ms_encoder;
+extern AVCodec libmp3lame_encoder;
+extern AVCodec libtheora_encoder;
+extern AVCodec libvorbis_decoder;
+extern AVCodec libvorbis_encoder;
+extern AVCodec libx264_encoder;
+extern AVCodec libxvid_encoder;
+extern AVCodec mpeg4aac_decoder;
+extern AVCodec zlib_decoder;
+extern AVCodec zlib_encoder;
+
+/* subtitles */
+extern AVCodec dvbsub_decoder;
+extern AVCodec dvbsub_encoder;
+extern AVCodec dvdsub_decoder;
+extern AVCodec dvdsub_encoder;
+
+#endif /* ALLCODECS_H */

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h261.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h261.h	2007-07-16 18:08:14 UTC (rev 3389)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h261.h	2007-07-16 18:11:38 UTC (rev 3390)
@@ -0,0 +1,51 @@
+/*
+ * H261 decoder
+ * Copyright (c) 2002-2004 Michael Niedermayer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">michaelni at gmx.at</A>&gt;
+ * Copyright (c) 2004 Maarten Daniels
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file h261.c
+ * h261codec.
+ */
+
+#ifndef AVCODEC_H261_H
+#define AVCODEC_H261_H
+
+#include &quot;mpegvideo.h&quot;
+
+/**
+ * H261Context
+ */
+typedef struct H261Context{
+    MpegEncContext s;
+
+    int current_mba;
+    int previous_mba;
+    int mba_diff;
+    int mtype;
+    int current_mv_x;
+    int current_mv_y;
+    int gob_number;
+    int gob_start_code_skipped; // 1 if gob start code is already read before gob header is read
+}H261Context;
+
+#define MB_TYPE_H261_FIL 0x800000
+
+#endif /* AVCODEC_H261_H */

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h263.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h263.h	2007-07-16 18:08:14 UTC (rev 3389)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h263.h	2007-07-16 18:11:38 UTC (rev 3390)
@@ -0,0 +1,46 @@
+/*
+ * H263/MPEG4 backend for ffmpeg encoder and decoder
+ * copyright (c) 2007 Aurelien Jacobs &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">aurel at gnuage.org</A>&gt;
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_H263_H
+#define AVCODEC_H263_H
+
+#include &quot;config.h&quot;
+#include &quot;msmpeg4.h&quot;
+
+#define ENABLE_ANY_H263_DECODER (ENABLE_H263_DECODER    || \
+                                 ENABLE_H263I_DECODER   || \
+                                 ENABLE_FLV_DECODER     || \
+                                 ENABLE_RV10_DECODER    || \
+                                 ENABLE_RV20_DECODER    || \
+                                 ENABLE_MPEG4_DECODER   || \
+                                 ENABLE_MSMPEG4_DECODER || \
+                                 ENABLE_WMV_DECODER)
+#define ENABLE_ANY_H263_ENCODER (ENABLE_H263_ENCODER    || \
+                                 ENABLE_H263P_ENCODER   || \
+                                 ENABLE_FLV_ENCODER     || \
+                                 ENABLE_RV10_ENCODER    || \
+                                 ENABLE_RV20_ENCODER    || \
+                                 ENABLE_MPEG4_ENCODER   || \
+                                 ENABLE_MSMPEG4_ENCODER || \
+                                 ENABLE_WMV_ENCODER)
+#define ENABLE_ANY_H263 (ENABLE_ANY_H263_DECODER || ENABLE_ANY_H263_ENCODER)
+
+#endif /* AVCODEC_H263_H */

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h263_parser.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h263_parser.h	2007-07-16 18:08:14 UTC (rev 3389)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h263_parser.h	2007-07-16 18:11:38 UTC (rev 3390)
@@ -0,0 +1,29 @@
+/*
+ * H.263 parser
+ * Copyright (c) 2002-2004 Michael Niedermayer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">michaelni at gmx.at</A>&gt;
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_H263_PARSER_H
+#define AVCODEC_H263_PARSER_H
+
+#include &quot;parser.h&quot;
+
+int ff_h263_find_frame_end(ParseContext *pc, const uint8_t *buf, int buf_size);
+
+#endif // AVCODEC_H263_PARSER_H

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h264.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h264.h	2007-07-16 18:08:14 UTC (rev 3389)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h264.h	2007-07-16 18:11:38 UTC (rev 3390)
@@ -0,0 +1,387 @@
+/*
+ * H.26L/H.264/AVC/JVT/14496-10/... encoder/decoder
+ * Copyright (c) 2003 Michael Niedermayer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">michaelni at gmx.at</A>&gt;
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file h264.h
+ * H.264 / AVC / MPEG4 part10 codec.
+ * @author Michael Niedermayer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">michaelni at gmx.at</A>&gt;
+ */
+
+#ifndef H264_H
+#define H264_H
+
+#include &quot;dsputil.h&quot;
+#include &quot;cabac.h&quot;
+#include &quot;mpegvideo.h&quot;
+
+#define interlaced_dct interlaced_dct_is_a_bad_name
+#define mb_intra mb_intra_is_not_initialized_see_mb_type
+
+#define LUMA_DC_BLOCK_INDEX   25
+#define CHROMA_DC_BLOCK_INDEX 26
+
+#define CHROMA_DC_COEFF_TOKEN_VLC_BITS 8
+#define COEFF_TOKEN_VLC_BITS           8
+#define TOTAL_ZEROS_VLC_BITS           9
+#define CHROMA_DC_TOTAL_ZEROS_VLC_BITS 3
+#define RUN_VLC_BITS                   3
+#define RUN7_VLC_BITS                  6
+
+#define MAX_SPS_COUNT 32
+#define MAX_PPS_COUNT 256
+
+#define MAX_MMCO_COUNT 66
+
+/* Compiling in interlaced support reduces the speed
+ * of progressive decoding by about 2%. */
+#define ALLOW_INTERLACE
+
+#ifdef ALLOW_INTERLACE
+#define MB_MBAFF h-&gt;mb_mbaff
+#define MB_FIELD h-&gt;mb_field_decoding_flag
+#define FRAME_MBAFF h-&gt;mb_aff_frame
+#else
+#define MB_MBAFF 0
+#define MB_FIELD 0
+#define FRAME_MBAFF 0
+#undef  IS_INTERLACED
+#define IS_INTERLACED(mb_type) 0
+#endif
+
+/**
+ * Sequence parameter set
+ */
+typedef struct SPS{
+
+    int profile_idc;
+    int level_idc;
+    int transform_bypass;              ///&lt; qpprime_y_zero_transform_bypass_flag
+    int log2_max_frame_num;            ///&lt; log2_max_frame_num_minus4 + 4
+    int poc_type;                      ///&lt; pic_order_cnt_type
+    int log2_max_poc_lsb;              ///&lt; log2_max_pic_order_cnt_lsb_minus4
+    int delta_pic_order_always_zero_flag;
+    int offset_for_non_ref_pic;
+    int offset_for_top_to_bottom_field;
+    int poc_cycle_length;              ///&lt; num_ref_frames_in_pic_order_cnt_cycle
+    int ref_frame_count;               ///&lt; num_ref_frames
+    int gaps_in_frame_num_allowed_flag;
+    int mb_width;                      ///&lt; frame_width_in_mbs_minus1 + 1
+    int mb_height;                     ///&lt; frame_height_in_mbs_minus1 + 1
+    int frame_mbs_only_flag;
+    int mb_aff;                        ///&lt;mb_adaptive_frame_field_flag
+    int direct_8x8_inference_flag;
+    int crop;                   ///&lt; frame_cropping_flag
+    int crop_left;              ///&lt; frame_cropping_rect_left_offset
+    int crop_right;             ///&lt; frame_cropping_rect_right_offset
+    int crop_top;               ///&lt; frame_cropping_rect_top_offset
+    int crop_bottom;            ///&lt; frame_cropping_rect_bottom_offset
+    int vui_parameters_present_flag;
+    AVRational sar;
+    int timing_info_present_flag;
+    uint32_t num_units_in_tick;
+    uint32_t time_scale;
+    int fixed_frame_rate_flag;
+    short offset_for_ref_frame[256]; //FIXME dyn aloc?
+    int bitstream_restriction_flag;
+    int num_reorder_frames;
+    int scaling_matrix_present;
+    uint8_t scaling_matrix4[6][16];
+    uint8_t scaling_matrix8[2][64];
+}SPS;
+
+/**
+ * Picture parameter set
+ */
+typedef struct PPS{
+    unsigned int sps_id;
+    int cabac;                  ///&lt; entropy_coding_mode_flag
+    int pic_order_present;      ///&lt; pic_order_present_flag
+    int slice_group_count;      ///&lt; num_slice_groups_minus1 + 1
+    int mb_slice_group_map_type;
+    unsigned int ref_count[2];  ///&lt; num_ref_idx_l0/1_active_minus1 + 1
+    int weighted_pred;          ///&lt; weighted_pred_flag
+    int weighted_bipred_idc;
+    int init_qp;                ///&lt; pic_init_qp_minus26 + 26
+    int init_qs;                ///&lt; pic_init_qs_minus26 + 26
+    int chroma_qp_index_offset[2];
+    int deblocking_filter_parameters_present; ///&lt; deblocking_filter_parameters_present_flag
+    int constrained_intra_pred; ///&lt; constrained_intra_pred_flag
+    int redundant_pic_cnt_present; ///&lt; redundant_pic_cnt_present_flag
+    int transform_8x8_mode;     ///&lt; transform_8x8_mode_flag
+    uint8_t scaling_matrix4[6][16];
+    uint8_t scaling_matrix8[2][64];
+    uint8_t chroma_qp_table[2][256];  ///&lt; pre-scaled (with chroma_qp_index_offset) version of qp_table
+    int chroma_qp_diff;
+}PPS;
+
+/**
+ * Memory management control operation opcode.
+ */
+typedef enum MMCOOpcode{
+    MMCO_END=0,
+    MMCO_SHORT2UNUSED,
+    MMCO_LONG2UNUSED,
+    MMCO_SHORT2LONG,
+    MMCO_SET_MAX_LONG,
+    MMCO_RESET,
+    MMCO_LONG,
+} MMCOOpcode;
+
+/**
+ * Memory management control operation.
+ */
+typedef struct MMCO{
+    MMCOOpcode opcode;
+    int short_frame_num;
+    int long_index;
+} MMCO;
+
+/**
+ * H264Context
+ */
+typedef struct H264Context{
+    MpegEncContext s;
+    int nal_ref_idc;
+    int nal_unit_type;
+    uint8_t *rbsp_buffer[2];
+    unsigned int rbsp_buffer_size[2];
+
+    /**
+      * Used to parse AVC variant of h264
+      */
+    int is_avc; ///&lt; this flag is != 0 if codec is avc1
+    int got_avcC; ///&lt; flag used to parse avcC data only once
+    int nal_length_size; ///&lt; Number of bytes used for nal length (1, 2 or 4)
+
+    int chroma_qp[2]; //QPc
+
+    int prev_mb_skipped;
+    int next_mb_skipped;
+
+    //prediction stuff
+    int chroma_pred_mode;
+    int intra16x16_pred_mode;
+
+    int top_mb_xy;
+    int left_mb_xy[2];
+
+    int8_t intra4x4_pred_mode_cache[5*8];
+    int8_t (*intra4x4_pred_mode)[8];
+    void (*pred4x4  [9+3])(uint8_t *src, uint8_t *topright, int stride);//FIXME move to dsp?
+    void (*pred8x8l [9+3])(uint8_t *src, int topleft, int topright, int stride);
+    void (*pred8x8  [4+3])(uint8_t *src, int stride);
+    void (*pred16x16[4+3])(uint8_t *src, int stride);
+    unsigned int topleft_samples_available;
+    unsigned int top_samples_available;
+    unsigned int topright_samples_available;
+    unsigned int left_samples_available;
+    uint8_t (*top_borders[2])[16+2*8];
+    uint8_t left_border[2*(17+2*9)];
+
+    /**
+     * non zero coeff count cache.
+     * is 64 if not available.
+     */
+    DECLARE_ALIGNED_8(uint8_t, non_zero_count_cache[6*8]);
+    uint8_t (*non_zero_count)[16];
+
+    /**
+     * Motion vector cache.
+     */
+    DECLARE_ALIGNED_8(int16_t, mv_cache[2][5*8][2]);
+    DECLARE_ALIGNED_8(int8_t, ref_cache[2][5*8]);
+#define LIST_NOT_USED -1 //FIXME rename?
+#define PART_NOT_AVAILABLE -2
+
+    /**
+     * is 1 if the specific list MV&amp;references are set to 0,0,-2.
+     */
+    int mv_cache_clean[2];
+
+    /**
+     * number of neighbors (top and/or left) that used 8x8 dct
+     */
+    int neighbor_transform_size;
+
+    /**
+     * block_offset[ 0..23] for frame macroblocks
+     * block_offset[24..47] for field macroblocks
+     */
+    int block_offset[2*(16+8)];
+
+    uint32_t *mb2b_xy; //FIXME are these 4 a good idea?
+    uint32_t *mb2b8_xy;
+    int b_stride; //FIXME use s-&gt;b4_stride
+    int b8_stride;
+
+    int mb_linesize;   ///&lt; may be equal to s-&gt;linesize or s-&gt;linesize*2, for mbaff
+    int mb_uvlinesize;
+
+    int emu_edge_width;
+    int emu_edge_height;
+
+    int halfpel_flag;
+    int thirdpel_flag;
+
+    int unknown_svq3_flag;
+    int next_slice_index;
+
+    SPS *sps_buffers[MAX_SPS_COUNT];
+    SPS sps; ///&lt; current sps
+
+    PPS *pps_buffers[MAX_PPS_COUNT];
+    /**
+     * current pps
+     */
+    PPS pps; //FIXME move to Picture perhaps? (-&gt;no) do we need that?
+
+    uint32_t dequant4_buffer[6][52][16];
+    uint32_t dequant8_buffer[2][52][64];
+    uint32_t (*dequant4_coeff[6])[16];
+    uint32_t (*dequant8_coeff[2])[64];
+    int dequant_coeff_pps;     ///&lt; reinit tables when pps changes
+
+    int slice_num;
+    uint8_t *slice_table_base;
+    uint8_t *slice_table;      ///&lt; slice_table_base + 2*mb_stride + 1
+    int slice_type;
+    int slice_type_fixed;
+
+    //interlacing specific flags
+    int mb_aff_frame;
+    int mb_field_decoding_flag;
+    int mb_mbaff;              ///&lt; mb_aff_frame &amp;&amp; mb_field_decoding_flag
+
+    unsigned int sub_mb_type[4];
+
+    //POC stuff
+    int poc_lsb;
+    int poc_msb;
+    int delta_poc_bottom;
+    int delta_poc[2];
+    int frame_num;
+    int prev_poc_msb;             ///&lt; poc_msb of the last reference pic for POC type 0
+    int prev_poc_lsb;             ///&lt; poc_lsb of the last reference pic for POC type 0
+    int frame_num_offset;         ///&lt; for POC type 2
+    int prev_frame_num_offset;    ///&lt; for POC type 2
+    int prev_frame_num;           ///&lt; frame_num of the last pic for POC type 1/2
+
+    /**
+     * frame_num for frames or 2*frame_num for field pics.
+     */
+    int curr_pic_num;
+
+    /**
+     * max_frame_num or 2*max_frame_num for field pics.
+     */
+    int max_pic_num;
+
+    //Weighted pred stuff
+    int use_weight;
+    int use_weight_chroma;
+    int luma_log2_weight_denom;
+    int chroma_log2_weight_denom;
+    int luma_weight[2][48];
+    int luma_offset[2][48];
+    int chroma_weight[2][48][2];
+    int chroma_offset[2][48][2];
+    int implicit_weight[48][48];
+
+    //deblock
+    int deblocking_filter;         ///&lt; disable_deblocking_filter_idc with 1&lt;-&gt;0
+    int slice_alpha_c0_offset;
+    int slice_beta_offset;
+
+    int redundant_pic_count;
+
+    int direct_spatial_mv_pred;
+    int dist_scale_factor[16];
+    int dist_scale_factor_field[32];
+    int map_col_to_list0[2][16];
+    int map_col_to_list0_field[2][32];
+
+    /**
+     * num_ref_idx_l0/1_active_minus1 + 1
+     */
+    unsigned int ref_count[2];   ///&lt; counts frames or fields, depending on current mb mode
+    unsigned int list_count;
+    Picture *short_ref[32];
+    Picture *long_ref[32];
+    Picture default_ref_list[2][32];
+    Picture ref_list[2][48];     ///&lt; 0..15: frame refs, 16..47: mbaff field refs
+    Picture *delayed_pic[18]; //FIXME size?
+    Picture *delayed_output_pic;
+
+    /**
+     * memory management control operations buffer.
+     */
+    MMCO mmco[MAX_MMCO_COUNT];
+    int mmco_index;
+
+    int long_ref_count;  ///&lt; number of actual long term references
+    int short_ref_count; ///&lt; number of actual short term references
+
+    //data partitioning
+    GetBitContext intra_gb;
+    GetBitContext inter_gb;
+    GetBitContext *intra_gb_ptr;
+    GetBitContext *inter_gb_ptr;
+
+    DECLARE_ALIGNED_8(DCTELEM, mb[16*24]);
+    DCTELEM mb_padding[256];        ///&lt; as mb is addressed by scantable[i] and scantable is uint8_t we can either check that i is not to large or ensure that there is some unused stuff after mb
+
+    /**
+     * Cabac
+     */
+    CABACContext cabac;
+    uint8_t      cabac_state[460];
+    int          cabac_init_idc;
+
+    /* 0x100 -&gt; non null luma_dc, 0x80/0x40 -&gt; non null chroma_dc (cb/cr), 0x?0 -&gt; chroma_cbp(0,1,2), 0x0? luma_cbp */
+    uint16_t     *cbp_table;
+    int cbp;
+    int top_cbp;
+    int left_cbp;
+    /* chroma_pred_mode for i4x4 or i16x16, else 0 */
+    uint8_t     *chroma_pred_mode_table;
+    int         last_qscale_diff;
+    int16_t     (*mvd_table[2])[2];
+    DECLARE_ALIGNED_8(int16_t, mvd_cache[2][5*8][2]);
+    uint8_t     *direct_table;
+    uint8_t     direct_cache[5*8];
+
+    uint8_t zigzag_scan[16];
+    uint8_t zigzag_scan8x8[64];
+    uint8_t zigzag_scan8x8_cavlc[64];
+    uint8_t field_scan[16];
+    uint8_t field_scan8x8[64];
+    uint8_t field_scan8x8_cavlc[64];
+    const uint8_t *zigzag_scan_q0;
+    const uint8_t *zigzag_scan8x8_q0;
+    const uint8_t *zigzag_scan8x8_cavlc_q0;
+    const uint8_t *field_scan_q0;
+    const uint8_t *field_scan8x8_q0;
+    const uint8_t *field_scan8x8_cavlc_q0;
+
+    int x264_build;
+}H264Context;
+
+#endif /* H264_H */

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h264_parser.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h264_parser.h	2007-07-16 18:08:14 UTC (rev 3389)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h264_parser.h	2007-07-16 18:11:38 UTC (rev 3390)
@@ -0,0 +1,39 @@
+/*
+ * H.26L/H.264/AVC/JVT/14496-10/... parser
+ * Copyright (c) 2003 Michael Niedermayer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">michaelni at gmx.at</A>&gt;
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file h264_parser.h
+ * H.264 / AVC / MPEG4 part10 parser.
+ * @author Michael Niedermayer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">michaelni at gmx.at</A>&gt;
+ */
+
+#ifndef H264_PARSER_H
+#define H264_PARSER_H
+
+#include &quot;h264.h&quot;
+
+/**
+ * finds the end of the current frame in the bitstream.
+ * @return the position of the first byte of the next frame, or -1
+ */
+int ff_h264_find_frame_end(H264Context *h, const uint8_t *buf, int buf_size);
+
+#endif /* H264_PARSER_H */

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/mjpeg.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/mjpeg.h	2007-07-16 18:08:14 UTC (rev 3389)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/mjpeg.h	2007-07-16 18:11:38 UTC (rev 3390)
@@ -0,0 +1,156 @@
+/*
+ * MJPEG encoder and decoder
+ * Copyright (c) 2000, 2001 Fabrice Bellard.
+ * Copyright (c) 2003 Alex Beregszaszi
+ * Copyright (c) 2003-2004 Michael Niedermayer
+ *
+ * Support for external huffman table, various fixes (AVID workaround),
+ * aspecting, new decode_frame mechanism and apple mjpeg-b support
+ *                                  by Alex Beregszaszi
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file mjpeg.h
+ * MJPEG encoder and decoder.
+ */
+
+#ifndef MJPEG_H
+#define MJPEG_H
+
+#include &quot;avcodec.h&quot;
+#include &quot;bitstream.h&quot;
+
+
+/* JPEG marker codes */
+typedef enum {
+    /* start of frame */
+    SOF0  = 0xc0,       /* baseline */
+    SOF1  = 0xc1,       /* extended sequential, huffman */
+    SOF2  = 0xc2,       /* progressive, huffman */
+    SOF3  = 0xc3,       /* lossless, huffman */
+
+    SOF5  = 0xc5,       /* differential sequential, huffman */
+    SOF6  = 0xc6,       /* differential progressive, huffman */
+    SOF7  = 0xc7,       /* differential lossless, huffman */
+    JPG   = 0xc8,       /* reserved for JPEG extension */
+    SOF9  = 0xc9,       /* extended sequential, arithmetic */
+    SOF10 = 0xca,       /* progressive, arithmetic */
+    SOF11 = 0xcb,       /* lossless, arithmetic */
+
+    SOF13 = 0xcd,       /* differential sequential, arithmetic */
+    SOF14 = 0xce,       /* differential progressive, arithmetic */
+    SOF15 = 0xcf,       /* differential lossless, arithmetic */
+
+    DHT   = 0xc4,       /* define huffman tables */
+
+    DAC   = 0xcc,       /* define arithmetic-coding conditioning */
+
+    /* restart with modulo 8 count &quot;m&quot; */
+    RST0  = 0xd0,
+    RST1  = 0xd1,
+    RST2  = 0xd2,
+    RST3  = 0xd3,
+    RST4  = 0xd4,
+    RST5  = 0xd5,
+    RST6  = 0xd6,
+    RST7  = 0xd7,
+
+    SOI   = 0xd8,       /* start of image */
+    EOI   = 0xd9,       /* end of image */
+    SOS   = 0xda,       /* start of scan */
+    DQT   = 0xdb,       /* define quantization tables */
+    DNL   = 0xdc,       /* define number of lines */
+    DRI   = 0xdd,       /* define restart interval */
+    DHP   = 0xde,       /* define hierarchical progression */
+    EXP   = 0xdf,       /* expand reference components */
+
+    APP0  = 0xe0,
+    APP1  = 0xe1,
+    APP2  = 0xe2,
+    APP3  = 0xe3,
+    APP4  = 0xe4,
+    APP5  = 0xe5,
+    APP6  = 0xe6,
+    APP7  = 0xe7,
+    APP8  = 0xe8,
+    APP9  = 0xe9,
+    APP10 = 0xea,
+    APP11 = 0xeb,
+    APP12 = 0xec,
+    APP13 = 0xed,
+    APP14 = 0xee,
+    APP15 = 0xef,
+
+    JPG0  = 0xf0,
+    JPG1  = 0xf1,
+    JPG2  = 0xf2,
+    JPG3  = 0xf3,
+    JPG4  = 0xf4,
+    JPG5  = 0xf5,
+    JPG6  = 0xf6,
+    SOF48 = 0xf7,       ///&lt; JPEG-LS
+    LSE   = 0xf8,       ///&lt; JPEG-LS extension parameters
+    JPG9  = 0xf9,
+    JPG10 = 0xfa,
+    JPG11 = 0xfb,
+    JPG12 = 0xfc,
+    JPG13 = 0xfd,
+
+    COM   = 0xfe,       /* comment */
+
+    TEM   = 0x01,       /* temporary private use for arithmetic coding */
+
+    /* 0x02 -&gt; 0xbf reserved */
+} JPEG_MARKER;
+
+static inline void put_marker(PutBitContext *p, int code)
+{
+    put_bits(p, 8, 0xff);
+    put_bits(p, 8, code);
+}
+
+#define PREDICT(ret, topleft, top, left, predictor)\
+    switch(predictor){\
+        case 1: ret= left; break;\
+        case 2: ret= top; break;\
+        case 3: ret= topleft; break;\
+        case 4: ret= left   +   top - topleft; break;\
+        case 5: ret= left   + ((top - topleft)&gt;&gt;1); break;\
+        case 6: ret= top + ((left   - topleft)&gt;&gt;1); break;\
+        default:\
+        case 7: ret= (left + top)&gt;&gt;1; break;\
+    }
+
+extern const uint8_t ff_mjpeg_bits_dc_luminance[];
+extern const uint8_t ff_mjpeg_val_dc_luminance[];
+
+extern const uint8_t ff_mjpeg_bits_dc_chrominance[];
+extern const uint8_t ff_mjpeg_val_dc_chrominance[];
+
+extern const uint8_t ff_mjpeg_bits_ac_luminance[];
+extern const uint8_t ff_mjpeg_val_ac_luminance[];
+
+extern const uint8_t ff_mjpeg_bits_ac_chrominance[];
+extern const uint8_t ff_mjpeg_val_ac_chrominance[];
+
+void ff_mjpeg_build_huffman_codes(uint8_t *huff_size, uint16_t *huff_code,
+                                  const uint8_t *bits_table,
+                                  const uint8_t *val_table);
+
+#endif /* MJPEG_H */

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/mjpegdec.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/mjpegdec.h	2007-07-16 18:08:14 UTC (rev 3389)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/mjpegdec.h	2007-07-16 18:11:38 UTC (rev 3390)
@@ -0,0 +1,112 @@
+/*
+ * MJPEG decoder
+ * Copyright (c) 2000, 2001 Fabrice Bellard.
+ * Copyright (c) 2003 Alex Beregszaszi
+ * Copyright (c) 2003-2004 Michael Niedermayer
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file mjpegdec.h
+ * MJPEG decoder.
+ */
+
+#ifndef MJPEGDEC_H
+#define MJPEGDEC_H
+
+#include &quot;avcodec.h&quot;
+#include &quot;bitstream.h&quot;
+#include &quot;dsputil.h&quot;
+#include &quot;mpegvideo.h&quot;
+
+#define MAX_COMPONENTS 4
+
+typedef struct MJpegDecodeContext {
+    AVCodecContext *avctx;
+    GetBitContext gb;
+
+    int start_code; /* current start code */
+    int buffer_size;
+    uint8_t *buffer;
+
+    int16_t quant_matrixes[4][64];
+    VLC vlcs[2][4];
+    int qscale[4];      ///&lt; quantizer scale calculated from quant_matrixes
+
+    int org_height;  /* size given at codec init */
+    int first_picture;    /* true if decoding first picture */
+    int interlaced;     /* true if interlaced */
+    int bottom_field;   /* true if bottom field */
+    int lossless;
+    int ls;
+    int progressive;
+    int rgb;
+    int rct;            /* standard rct */
+    int pegasus_rct;    /* pegasus reversible colorspace transform */
+    int bits;           /* bits per component */
+
+    int maxval;
+    int near;         ///&lt; near lossless bound (si 0 for lossless)
+    int t1,t2,t3;
+    int reset;        ///&lt; context halfing intervall ?rename
+
+    int width, height;
+    int mb_width, mb_height;
+    int nb_components;
+    int component_id[MAX_COMPONENTS];
+    int h_count[MAX_COMPONENTS]; /* horizontal and vertical count for each component */
+    int v_count[MAX_COMPONENTS];
+    int comp_index[MAX_COMPONENTS];
+    int dc_index[MAX_COMPONENTS];
+    int ac_index[MAX_COMPONENTS];
+    int nb_blocks[MAX_COMPONENTS];
+    int h_scount[MAX_COMPONENTS];
+    int v_scount[MAX_COMPONENTS];
+    int h_max, v_max; /* maximum h and v counts */
+    int quant_index[4];   /* quant table index for each component */
+    int last_dc[MAX_COMPONENTS]; /* last DEQUANTIZED dc (XXX: am I right to do that ?) */
+    AVFrame picture; /* picture structure */
+    int linesize[MAX_COMPONENTS];                   ///&lt; linesize &lt;&lt; interlaced
+    int8_t *qscale_table;
+    DECLARE_ALIGNED_8(DCTELEM, block[64]);
+    ScanTable scantable;
+    DSPContext dsp;
+
+    int restart_interval;
+    int restart_count;
+
+    int buggy_avid;
+    int cs_itu601;
+    int interlace_polarity;
+
+    int mjpb_skiptosod;
+
+    int cur_scan; /* current scan, used by JPEG-LS */
+} MJpegDecodeContext;
+
+int ff_mjpeg_decode_init(AVCodecContext *avctx);
+int ff_mjpeg_decode_end(AVCodecContext *avctx);
+int ff_mjpeg_decode_frame(AVCodecContext *avctx,
+                          void *data, int *data_size,
+                          uint8_t *buf, int buf_size);
+int ff_mjpeg_decode_dqt(MJpegDecodeContext *s);
+int ff_mjpeg_decode_dht(MJpegDecodeContext *s);
+int ff_mjpeg_decode_sof(MJpegDecodeContext *s);
+int ff_mjpeg_decode_sos(MJpegDecodeContext *s);
+
+#endif /* MJPEGDEC_H */

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/mpeg4video_parser.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/mpeg4video_parser.h	2007-07-16 18:08:14 UTC (rev 3389)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/mpeg4video_parser.h	2007-07-16 18:11:38 UTC (rev 3390)
@@ -0,0 +1,34 @@
+/*
+ * MPEG4 video parser prototypes
+ * Copyright (c) 2003 Fabrice Bellard.
+ * Copyright (c) 2003 Michael Niedermayer.
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef MPEG4VIDEO_PARSER_H
+#define MPEG4VIDEO_PARSER_H
+
+#include &quot;parser.h&quot;
+
+/**
+ * finds the end of the current frame in the bitstream.
+ * @return the position of the first byte of the next frame, or -1
+ */
+int ff_mpeg4_find_frame_end(ParseContext *pc, const uint8_t *buf, int buf_size);
+
+#endif /* MPEG4VIDEO_PARSER_H */

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/mpegvideo_common.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/mpegvideo_common.h	2007-07-16 18:08:14 UTC (rev 3389)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/mpegvideo_common.h	2007-07-16 18:11:38 UTC (rev 3390)
@@ -0,0 +1,836 @@
+/*
+ * The simplest mpeg encoder (well, it was the simplest!)
+ * Copyright (c) 2000,2001 Fabrice Bellard.
+ * Copyright (c) 2002-2004 Michael Niedermayer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">michaelni at gmx.at</A>&gt;
+ *
+ * 4MV &amp; hq &amp; B-frame encoding stuff by Michael Niedermayer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">michaelni at gmx.at</A>&gt;
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file mpegvideo_common.h
+ * The simplest mpeg encoder (well, it was the simplest!).
+ */
+
+#ifndef MPEGVIDEO_COMMON_H
+#define MPEGVIDEO_COMMON_H
+
+#include &quot;avcodec.h&quot;
+#include &quot;dsputil.h&quot;
+#include &quot;mpegvideo.h&quot;
+#include &quot;mjpegenc.h&quot;
+#include &quot;msmpeg4.h&quot;
+#include &quot;faandct.h&quot;
+#include &lt;limits.h&gt;
+
+int dct_quantize_c(MpegEncContext *s, DCTELEM *block, int n, int qscale, int *overflow);
+int dct_quantize_trellis_c(MpegEncContext *s, DCTELEM *block, int n, int qscale, int *overflow);
+void  denoise_dct_c(MpegEncContext *s, DCTELEM *block);
+void copy_picture(Picture *dst, Picture *src);
+
+/**
+ * allocates a Picture
+ * The pixels are allocated/set by calling get_buffer() if shared=0
+ */
+int alloc_picture(MpegEncContext *s, Picture *pic, int shared);
+
+/**
+ * sets the given MpegEncContext to common defaults (same for encoding and decoding).
+ * the changed fields will not depend upon the prior state of the MpegEncContext.
+ */
+void MPV_common_defaults(MpegEncContext *s);
+
+static inline void gmc1_motion(MpegEncContext *s,
+                               uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr,
+                               uint8_t **ref_picture)
+{
+    uint8_t *ptr;
+    int offset, src_x, src_y, linesize, uvlinesize;
+    int motion_x, motion_y;
+    int emu=0;
+
+    motion_x= s-&gt;sprite_offset[0][0];
+    motion_y= s-&gt;sprite_offset[0][1];
+    src_x = s-&gt;mb_x * 16 + (motion_x &gt;&gt; (s-&gt;sprite_warping_accuracy+1));
+    src_y = s-&gt;mb_y * 16 + (motion_y &gt;&gt; (s-&gt;sprite_warping_accuracy+1));
+    motion_x&lt;&lt;=(3-s-&gt;sprite_warping_accuracy);
+    motion_y&lt;&lt;=(3-s-&gt;sprite_warping_accuracy);
+    src_x = av_clip(src_x, -16, s-&gt;width);
+    if (src_x == s-&gt;width)
+        motion_x =0;
+    src_y = av_clip(src_y, -16, s-&gt;height);
+    if (src_y == s-&gt;height)
+        motion_y =0;
+
+    linesize = s-&gt;linesize;
+    uvlinesize = s-&gt;uvlinesize;
+
+    ptr = ref_picture[0] + (src_y * linesize) + src_x;
+
+    if(s-&gt;flags&amp;CODEC_FLAG_EMU_EDGE){
+        if(   (unsigned)src_x &gt;= s-&gt;h_edge_pos - 17
+           || (unsigned)src_y &gt;= s-&gt;v_edge_pos - 17){
+            ff_emulated_edge_mc(s-&gt;edge_emu_buffer, ptr, linesize, 17, 17, src_x, src_y, s-&gt;h_edge_pos, s-&gt;v_edge_pos);
+            ptr= s-&gt;edge_emu_buffer;
+        }
+    }
+
+    if((motion_x|motion_y)&amp;7){
+        s-&gt;dsp.gmc1(dest_y  , ptr  , linesize, 16, motion_x&amp;15, motion_y&amp;15, 128 - s-&gt;no_rounding);
+        s-&gt;dsp.gmc1(dest_y+8, ptr+8, linesize, 16, motion_x&amp;15, motion_y&amp;15, 128 - s-&gt;no_rounding);
+    }else{
+        int dxy;
+
+        dxy= ((motion_x&gt;&gt;3)&amp;1) | ((motion_y&gt;&gt;2)&amp;2);
+        if (s-&gt;no_rounding){
+            s-&gt;dsp.put_no_rnd_pixels_tab[0][dxy](dest_y, ptr, linesize, 16);
+        }else{
+            s-&gt;dsp.put_pixels_tab       [0][dxy](dest_y, ptr, linesize, 16);
+        }
+    }
+
+    if(s-&gt;flags&amp;CODEC_FLAG_GRAY) return;
+
+    motion_x= s-&gt;sprite_offset[1][0];
+    motion_y= s-&gt;sprite_offset[1][1];
+    src_x = s-&gt;mb_x * 8 + (motion_x &gt;&gt; (s-&gt;sprite_warping_accuracy+1));
+    src_y = s-&gt;mb_y * 8 + (motion_y &gt;&gt; (s-&gt;sprite_warping_accuracy+1));
+    motion_x&lt;&lt;=(3-s-&gt;sprite_warping_accuracy);
+    motion_y&lt;&lt;=(3-s-&gt;sprite_warping_accuracy);
+    src_x = av_clip(src_x, -8, s-&gt;width&gt;&gt;1);
+    if (src_x == s-&gt;width&gt;&gt;1)
+        motion_x =0;
+    src_y = av_clip(src_y, -8, s-&gt;height&gt;&gt;1);
+    if (src_y == s-&gt;height&gt;&gt;1)
+        motion_y =0;
+
+    offset = (src_y * uvlinesize) + src_x;
+    ptr = ref_picture[1] + offset;
+    if(s-&gt;flags&amp;CODEC_FLAG_EMU_EDGE){
+        if(   (unsigned)src_x &gt;= (s-&gt;h_edge_pos&gt;&gt;1) - 9
+           || (unsigned)src_y &gt;= (s-&gt;v_edge_pos&gt;&gt;1) - 9){
+            ff_emulated_edge_mc(s-&gt;edge_emu_buffer, ptr, uvlinesize, 9, 9, src_x, src_y, s-&gt;h_edge_pos&gt;&gt;1, s-&gt;v_edge_pos&gt;&gt;1);
+            ptr= s-&gt;edge_emu_buffer;
+            emu=1;
+        }
+    }
+    s-&gt;dsp.gmc1(dest_cb, ptr, uvlinesize, 8, motion_x&amp;15, motion_y&amp;15, 128 - s-&gt;no_rounding);
+
+    ptr = ref_picture[2] + offset;
+    if(emu){
+        ff_emulated_edge_mc(s-&gt;edge_emu_buffer, ptr, uvlinesize, 9, 9, src_x, src_y, s-&gt;h_edge_pos&gt;&gt;1, s-&gt;v_edge_pos&gt;&gt;1);
+        ptr= s-&gt;edge_emu_buffer;
+    }
+    s-&gt;dsp.gmc1(dest_cr, ptr, uvlinesize, 8, motion_x&amp;15, motion_y&amp;15, 128 - s-&gt;no_rounding);
+
+    return;
+}
+
+static inline void gmc_motion(MpegEncContext *s,
+                               uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr,
+                               uint8_t **ref_picture)
+{
+    uint8_t *ptr;
+    int linesize, uvlinesize;
+    const int a= s-&gt;sprite_warping_accuracy;
+    int ox, oy;
+
+    linesize = s-&gt;linesize;
+    uvlinesize = s-&gt;uvlinesize;
+
+    ptr = ref_picture[0];
+
+    ox= s-&gt;sprite_offset[0][0] + s-&gt;sprite_delta[0][0]*s-&gt;mb_x*16 + s-&gt;sprite_delta[0][1]*s-&gt;mb_y*16;
+    oy= s-&gt;sprite_offset[0][1] + s-&gt;sprite_delta[1][0]*s-&gt;mb_x*16 + s-&gt;sprite_delta[1][1]*s-&gt;mb_y*16;
+
+    s-&gt;dsp.gmc(dest_y, ptr, linesize, 16,
+           ox,
+           oy,
+           s-&gt;sprite_delta[0][0], s-&gt;sprite_delta[0][1],
+           s-&gt;sprite_delta[1][0], s-&gt;sprite_delta[1][1],
+           a+1, (1&lt;&lt;(2*a+1)) - s-&gt;no_rounding,
+           s-&gt;h_edge_pos, s-&gt;v_edge_pos);
+    s-&gt;dsp.gmc(dest_y+8, ptr, linesize, 16,
+           ox + s-&gt;sprite_delta[0][0]*8,
+           oy + s-&gt;sprite_delta[1][0]*8,
+           s-&gt;sprite_delta[0][0], s-&gt;sprite_delta[0][1],
+           s-&gt;sprite_delta[1][0], s-&gt;sprite_delta[1][1],
+           a+1, (1&lt;&lt;(2*a+1)) - s-&gt;no_rounding,
+           s-&gt;h_edge_pos, s-&gt;v_edge_pos);
+
+    if(s-&gt;flags&amp;CODEC_FLAG_GRAY) return;
+
+    ox= s-&gt;sprite_offset[1][0] + s-&gt;sprite_delta[0][0]*s-&gt;mb_x*8 + s-&gt;sprite_delta[0][1]*s-&gt;mb_y*8;
+    oy= s-&gt;sprite_offset[1][1] + s-&gt;sprite_delta[1][0]*s-&gt;mb_x*8 + s-&gt;sprite_delta[1][1]*s-&gt;mb_y*8;
+
+    ptr = ref_picture[1];
+    s-&gt;dsp.gmc(dest_cb, ptr, uvlinesize, 8,
+           ox,
+           oy,
+           s-&gt;sprite_delta[0][0], s-&gt;sprite_delta[0][1],
+           s-&gt;sprite_delta[1][0], s-&gt;sprite_delta[1][1],
+           a+1, (1&lt;&lt;(2*a+1)) - s-&gt;no_rounding,
+           s-&gt;h_edge_pos&gt;&gt;1, s-&gt;v_edge_pos&gt;&gt;1);
+
+    ptr = ref_picture[2];
+    s-&gt;dsp.gmc(dest_cr, ptr, uvlinesize, 8,
+           ox,
+           oy,
+           s-&gt;sprite_delta[0][0], s-&gt;sprite_delta[0][1],
+           s-&gt;sprite_delta[1][0], s-&gt;sprite_delta[1][1],
+           a+1, (1&lt;&lt;(2*a+1)) - s-&gt;no_rounding,
+           s-&gt;h_edge_pos&gt;&gt;1, s-&gt;v_edge_pos&gt;&gt;1);
+}
+
+static inline int hpel_motion(MpegEncContext *s,
+                                  uint8_t *dest, uint8_t *src,
+                                  int field_based, int field_select,
+                                  int src_x, int src_y,
+                                  int width, int height, int stride,
+                                  int h_edge_pos, int v_edge_pos,
+                                  int w, int h, op_pixels_func *pix_op,
+                                  int motion_x, int motion_y)
+{
+    int dxy;
+    int emu=0;
+
+    dxy = ((motion_y &amp; 1) &lt;&lt; 1) | (motion_x &amp; 1);
+    src_x += motion_x &gt;&gt; 1;
+    src_y += motion_y &gt;&gt; 1;
+
+    /* WARNING: do no forget half pels */
+    src_x = av_clip(src_x, -16, width); //FIXME unneeded for emu?
+    if (src_x == width)
+        dxy &amp;= ~1;
+    src_y = av_clip(src_y, -16, height);
+    if (src_y == height)
+        dxy &amp;= ~2;
+    src += src_y * stride + src_x;
+
+    if(s-&gt;unrestricted_mv &amp;&amp; (s-&gt;flags&amp;CODEC_FLAG_EMU_EDGE)){
+        if(   (unsigned)src_x &gt; h_edge_pos - (motion_x&amp;1) - w
+           || (unsigned)src_y &gt; v_edge_pos - (motion_y&amp;1) - h){
+            ff_emulated_edge_mc(s-&gt;edge_emu_buffer, src, s-&gt;linesize, w+1, (h+1)&lt;&lt;field_based,
+                             src_x, src_y&lt;&lt;field_based, h_edge_pos, s-&gt;v_edge_pos);
+            src= s-&gt;edge_emu_buffer;
+            emu=1;
+        }
+    }
+    if(field_select)
+        src += s-&gt;linesize;
+    pix_op[dxy](dest, src, stride, h);
+    return emu;
+}
+
+/* apply one mpeg motion vector to the three components */
+static av_always_inline void mpeg_motion(MpegEncContext *s,
+                               uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr,
+                               int field_based, int bottom_field, int field_select,
+                               uint8_t **ref_picture, op_pixels_func (*pix_op)[4],
+                               int motion_x, int motion_y, int h)
+{
+    uint8_t *ptr_y, *ptr_cb, *ptr_cr;
+    int dxy, uvdxy, mx, my, src_x, src_y, uvsrc_x, uvsrc_y, v_edge_pos, uvlinesize, linesize;
+
+#if 0
+if(s-&gt;quarter_sample)
+{
+    motion_x&gt;&gt;=1;
+    motion_y&gt;&gt;=1;
+}
+#endif
+
+    v_edge_pos = s-&gt;v_edge_pos &gt;&gt; field_based;
+    linesize   = s-&gt;current_picture.linesize[0] &lt;&lt; field_based;
+    uvlinesize = s-&gt;current_picture.linesize[1] &lt;&lt; field_based;
+
+    dxy = ((motion_y &amp; 1) &lt;&lt; 1) | (motion_x &amp; 1);
+    src_x = s-&gt;mb_x* 16               + (motion_x &gt;&gt; 1);
+    src_y =(s-&gt;mb_y&lt;&lt;(4-field_based)) + (motion_y &gt;&gt; 1);
+
+    if (s-&gt;out_format == FMT_H263) {
+        if((s-&gt;workaround_bugs &amp; FF_BUG_HPEL_CHROMA) &amp;&amp; field_based){
+            mx = (motion_x&gt;&gt;1)|(motion_x&amp;1);
+            my = motion_y &gt;&gt;1;
+            uvdxy = ((my &amp; 1) &lt;&lt; 1) | (mx &amp; 1);
+            uvsrc_x = s-&gt;mb_x* 8               + (mx &gt;&gt; 1);
+            uvsrc_y = (s-&gt;mb_y&lt;&lt;(3-field_based)) + (my &gt;&gt; 1);
+        }else{
+            uvdxy = dxy | (motion_y &amp; 2) | ((motion_x &amp; 2) &gt;&gt; 1);
+            uvsrc_x = src_x&gt;&gt;1;
+            uvsrc_y = src_y&gt;&gt;1;
+        }
+    }else if(s-&gt;out_format == FMT_H261){//even chroma mv's are full pel in H261
+        mx = motion_x / 4;
+        my = motion_y / 4;
+        uvdxy = 0;
+        uvsrc_x = s-&gt;mb_x*8 + mx;
+        uvsrc_y = s-&gt;mb_y*8 + my;
+    } else {
+        if(s-&gt;chroma_y_shift){
+            mx = motion_x / 2;
+            my = motion_y / 2;
+            uvdxy = ((my &amp; 1) &lt;&lt; 1) | (mx &amp; 1);
+            uvsrc_x = s-&gt;mb_x* 8               + (mx &gt;&gt; 1);
+            uvsrc_y = (s-&gt;mb_y&lt;&lt;(3-field_based)) + (my &gt;&gt; 1);
+        } else {
+            if(s-&gt;chroma_x_shift){
+            //Chroma422
+                mx = motion_x / 2;
+                uvdxy = ((motion_y &amp; 1) &lt;&lt; 1) | (mx &amp; 1);
+                uvsrc_x = s-&gt;mb_x* 8           + (mx &gt;&gt; 1);
+                uvsrc_y = src_y;
+            } else {
+            //Chroma444
+                uvdxy = dxy;
+                uvsrc_x = src_x;
+                uvsrc_y = src_y;
+            }
+        }
+    }
+
+    ptr_y  = ref_picture[0] + src_y * linesize + src_x;
+    ptr_cb = ref_picture[1] + uvsrc_y * uvlinesize + uvsrc_x;
+    ptr_cr = ref_picture[2] + uvsrc_y * uvlinesize + uvsrc_x;
+
+    if(   (unsigned)src_x &gt; s-&gt;h_edge_pos - (motion_x&amp;1) - 16
+       || (unsigned)src_y &gt;    v_edge_pos - (motion_y&amp;1) - h){
+            if(s-&gt;codec_id == CODEC_ID_MPEG2VIDEO ||
+               s-&gt;codec_id == CODEC_ID_MPEG1VIDEO){
+                av_log(s-&gt;avctx,AV_LOG_DEBUG,&quot;MPEG motion vector out of boundary\n&quot;);
+                return ;
+            }
+            ff_emulated_edge_mc(s-&gt;edge_emu_buffer, ptr_y, s-&gt;linesize, 17, 17+field_based,
+                             src_x, src_y&lt;&lt;field_based, s-&gt;h_edge_pos, s-&gt;v_edge_pos);
+            ptr_y = s-&gt;edge_emu_buffer;
+            if(!(s-&gt;flags&amp;CODEC_FLAG_GRAY)){
+                uint8_t *uvbuf= s-&gt;edge_emu_buffer+18*s-&gt;linesize;
+                ff_emulated_edge_mc(uvbuf  , ptr_cb, s-&gt;uvlinesize, 9, 9+field_based,
+                                 uvsrc_x, uvsrc_y&lt;&lt;field_based, s-&gt;h_edge_pos&gt;&gt;1, s-&gt;v_edge_pos&gt;&gt;1);
+                ff_emulated_edge_mc(uvbuf+16, ptr_cr, s-&gt;uvlinesize, 9, 9+field_based,
+                                 uvsrc_x, uvsrc_y&lt;&lt;field_based, s-&gt;h_edge_pos&gt;&gt;1, s-&gt;v_edge_pos&gt;&gt;1);
+                ptr_cb= uvbuf;
+                ptr_cr= uvbuf+16;
+            }
+    }
+
+    if(bottom_field){ //FIXME use this for field pix too instead of the obnoxious hack which changes picture.data
+        dest_y += s-&gt;linesize;
+        dest_cb+= s-&gt;uvlinesize;
+        dest_cr+= s-&gt;uvlinesize;
+    }
+
+    if(field_select){
+        ptr_y += s-&gt;linesize;
+        ptr_cb+= s-&gt;uvlinesize;
+        ptr_cr+= s-&gt;uvlinesize;
+    }
+
+    pix_op[0][dxy](dest_y, ptr_y, linesize, h);
+
+    if(!(s-&gt;flags&amp;CODEC_FLAG_GRAY)){
+        pix_op[s-&gt;chroma_x_shift][uvdxy](dest_cb, ptr_cb, uvlinesize, h &gt;&gt; s-&gt;chroma_y_shift);
+        pix_op[s-&gt;chroma_x_shift][uvdxy](dest_cr, ptr_cr, uvlinesize, h &gt;&gt; s-&gt;chroma_y_shift);
+    }
+    if((ENABLE_H261_ENCODER || ENABLE_H261_DECODER) &amp;&amp; s-&gt;out_format == FMT_H261){
+        ff_h261_loop_filter(s);
+    }
+}
+
+//FIXME move to dsputil, avg variant, 16x16 version
+static inline void put_obmc(uint8_t *dst, uint8_t *src[5], int stride){
+    int x;
+    uint8_t * const top   = src[1];
+    uint8_t * const left  = src[2];
+    uint8_t * const mid   = src[0];
+    uint8_t * const right = src[3];
+    uint8_t * const bottom= src[4];
+#define OBMC_FILTER(x, t, l, m, r, b)\
+    dst[x]= (t*top[x] + l*left[x] + m*mid[x] + r*right[x] + b*bottom[x] + 4)&gt;&gt;3
+#define OBMC_FILTER4(x, t, l, m, r, b)\
+    OBMC_FILTER(x         , t, l, m, r, b);\
+    OBMC_FILTER(x+1       , t, l, m, r, b);\
+    OBMC_FILTER(x  +stride, t, l, m, r, b);\
+    OBMC_FILTER(x+1+stride, t, l, m, r, b);
+
+    x=0;
+    OBMC_FILTER (x  , 2, 2, 4, 0, 0);
+    OBMC_FILTER (x+1, 2, 1, 5, 0, 0);
+    OBMC_FILTER4(x+2, 2, 1, 5, 0, 0);
+    OBMC_FILTER4(x+4, 2, 0, 5, 1, 0);
+    OBMC_FILTER (x+6, 2, 0, 5, 1, 0);
+    OBMC_FILTER (x+7, 2, 0, 4, 2, 0);
+    x+= stride;
+    OBMC_FILTER (x  , 1, 2, 5, 0, 0);
+    OBMC_FILTER (x+1, 1, 2, 5, 0, 0);
+    OBMC_FILTER (x+6, 1, 0, 5, 2, 0);
+    OBMC_FILTER (x+7, 1, 0, 5, 2, 0);
+    x+= stride;
+    OBMC_FILTER4(x  , 1, 2, 5, 0, 0);
+    OBMC_FILTER4(x+2, 1, 1, 6, 0, 0);
+    OBMC_FILTER4(x+4, 1, 0, 6, 1, 0);
+    OBMC_FILTER4(x+6, 1, 0, 5, 2, 0);
+    x+= 2*stride;
+    OBMC_FILTER4(x  , 0, 2, 5, 0, 1);
+    OBMC_FILTER4(x+2, 0, 1, 6, 0, 1);
+    OBMC_FILTER4(x+4, 0, 0, 6, 1, 1);
+    OBMC_FILTER4(x+6, 0, 0, 5, 2, 1);
+    x+= 2*stride;
+    OBMC_FILTER (x  , 0, 2, 5, 0, 1);
+    OBMC_FILTER (x+1, 0, 2, 5, 0, 1);
+    OBMC_FILTER4(x+2, 0, 1, 5, 0, 2);
+    OBMC_FILTER4(x+4, 0, 0, 5, 1, 2);
+    OBMC_FILTER (x+6, 0, 0, 5, 2, 1);
+    OBMC_FILTER (x+7, 0, 0, 5, 2, 1);
+    x+= stride;
+    OBMC_FILTER (x  , 0, 2, 4, 0, 2);
+    OBMC_FILTER (x+1, 0, 1, 5, 0, 2);
+    OBMC_FILTER (x+6, 0, 0, 5, 1, 2);
+    OBMC_FILTER (x+7, 0, 0, 4, 2, 2);
+}
+
+/* obmc for 1 8x8 luma block */
+static inline void obmc_motion(MpegEncContext *s,
+                               uint8_t *dest, uint8_t *src,
+                               int src_x, int src_y,
+                               op_pixels_func *pix_op,
+                               int16_t mv[5][2]/* mid top left right bottom*/)
+#define MID    0
+{
+    int i;
+    uint8_t *ptr[5];
+
+    assert(s-&gt;quarter_sample==0);
+
+    for(i=0; i&lt;5; i++){
+        if(i &amp;&amp; mv[i][0]==mv[MID][0] &amp;&amp; mv[i][1]==mv[MID][1]){
+            ptr[i]= ptr[MID];
+        }else{
+            ptr[i]= s-&gt;obmc_scratchpad + 8*(i&amp;1) + s-&gt;linesize*8*(i&gt;&gt;1);
+            hpel_motion(s, ptr[i], src, 0, 0,
+                        src_x, src_y,
+                        s-&gt;width, s-&gt;height, s-&gt;linesize,
+                        s-&gt;h_edge_pos, s-&gt;v_edge_pos,
+                        8, 8, pix_op,
+                        mv[i][0], mv[i][1]);
+        }
+    }
+
+    put_obmc(dest, ptr, s-&gt;linesize);
+}
+
+static inline void qpel_motion(MpegEncContext *s,
+                               uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr,
+                               int field_based, int bottom_field, int field_select,
+                               uint8_t **ref_picture, op_pixels_func (*pix_op)[4],
+                               qpel_mc_func (*qpix_op)[16],
+                               int motion_x, int motion_y, int h)
+{
+    uint8_t *ptr_y, *ptr_cb, *ptr_cr;
+    int dxy, uvdxy, mx, my, src_x, src_y, uvsrc_x, uvsrc_y, v_edge_pos, linesize, uvlinesize;
+
+    dxy = ((motion_y &amp; 3) &lt;&lt; 2) | (motion_x &amp; 3);
+    src_x = s-&gt;mb_x *  16                 + (motion_x &gt;&gt; 2);
+    src_y = s-&gt;mb_y * (16 &gt;&gt; field_based) + (motion_y &gt;&gt; 2);
+
+    v_edge_pos = s-&gt;v_edge_pos &gt;&gt; field_based;
+    linesize = s-&gt;linesize &lt;&lt; field_based;
+    uvlinesize = s-&gt;uvlinesize &lt;&lt; field_based;
+
+    if(field_based){
+        mx= motion_x/2;
+        my= motion_y&gt;&gt;1;
+    }else if(s-&gt;workaround_bugs&amp;FF_BUG_QPEL_CHROMA2){
+        static const int rtab[8]= {0,0,1,1,0,0,0,1};
+        mx= (motion_x&gt;&gt;1) + rtab[motion_x&amp;7];
+        my= (motion_y&gt;&gt;1) + rtab[motion_y&amp;7];
+    }else if(s-&gt;workaround_bugs&amp;FF_BUG_QPEL_CHROMA){
+        mx= (motion_x&gt;&gt;1)|(motion_x&amp;1);
+        my= (motion_y&gt;&gt;1)|(motion_y&amp;1);
+    }else{
+        mx= motion_x/2;
+        my= motion_y/2;
+    }
+    mx= (mx&gt;&gt;1)|(mx&amp;1);
+    my= (my&gt;&gt;1)|(my&amp;1);
+
+    uvdxy= (mx&amp;1) | ((my&amp;1)&lt;&lt;1);
+    mx&gt;&gt;=1;
+    my&gt;&gt;=1;
+
+    uvsrc_x = s-&gt;mb_x *  8                 + mx;
+    uvsrc_y = s-&gt;mb_y * (8 &gt;&gt; field_based) + my;
+
+    ptr_y  = ref_picture[0] +   src_y *   linesize +   src_x;
+    ptr_cb = ref_picture[1] + uvsrc_y * uvlinesize + uvsrc_x;
+    ptr_cr = ref_picture[2] + uvsrc_y * uvlinesize + uvsrc_x;
+
+    if(   (unsigned)src_x &gt; s-&gt;h_edge_pos - (motion_x&amp;3) - 16
+       || (unsigned)src_y &gt;    v_edge_pos - (motion_y&amp;3) - h  ){
+        ff_emulated_edge_mc(s-&gt;edge_emu_buffer, ptr_y, s-&gt;linesize, 17, 17+field_based,
+                         src_x, src_y&lt;&lt;field_based, s-&gt;h_edge_pos, s-&gt;v_edge_pos);
+        ptr_y= s-&gt;edge_emu_buffer;
+        if(!(s-&gt;flags&amp;CODEC_FLAG_GRAY)){
+            uint8_t *uvbuf= s-&gt;edge_emu_buffer + 18*s-&gt;linesize;
+            ff_emulated_edge_mc(uvbuf, ptr_cb, s-&gt;uvlinesize, 9, 9 + field_based,
+                             uvsrc_x, uvsrc_y&lt;&lt;field_based, s-&gt;h_edge_pos&gt;&gt;1, s-&gt;v_edge_pos&gt;&gt;1);
+            ff_emulated_edge_mc(uvbuf + 16, ptr_cr, s-&gt;uvlinesize, 9, 9 + field_based,
+                             uvsrc_x, uvsrc_y&lt;&lt;field_based, s-&gt;h_edge_pos&gt;&gt;1, s-&gt;v_edge_pos&gt;&gt;1);
+            ptr_cb= uvbuf;
+            ptr_cr= uvbuf + 16;
+        }
+    }
+
+    if(!field_based)
+        qpix_op[0][dxy](dest_y, ptr_y, linesize);
+    else{
+        if(bottom_field){
+            dest_y += s-&gt;linesize;
+            dest_cb+= s-&gt;uvlinesize;
+            dest_cr+= s-&gt;uvlinesize;
+        }
+
+        if(field_select){
+            ptr_y  += s-&gt;linesize;
+            ptr_cb += s-&gt;uvlinesize;
+            ptr_cr += s-&gt;uvlinesize;
+        }
+        //damn interlaced mode
+        //FIXME boundary mirroring is not exactly correct here
+        qpix_op[1][dxy](dest_y  , ptr_y  , linesize);
+        qpix_op[1][dxy](dest_y+8, ptr_y+8, linesize);
+    }
+    if(!(s-&gt;flags&amp;CODEC_FLAG_GRAY)){
+        pix_op[1][uvdxy](dest_cr, ptr_cr, uvlinesize, h &gt;&gt; 1);
+        pix_op[1][uvdxy](dest_cb, ptr_cb, uvlinesize, h &gt;&gt; 1);
+    }
+}
+
+/**
+ * h263 chorma 4mv motion compensation.
+ */
+static inline void chroma_4mv_motion(MpegEncContext *s,
+                                     uint8_t *dest_cb, uint8_t *dest_cr,
+                                     uint8_t **ref_picture,
+                                     op_pixels_func *pix_op,
+                                     int mx, int my){
+    int dxy, emu=0, src_x, src_y, offset;
+    uint8_t *ptr;
+
+    /* In case of 8X8, we construct a single chroma motion vector
+       with a special rounding */
+    mx= ff_h263_round_chroma(mx);
+    my= ff_h263_round_chroma(my);
+
+    dxy = ((my &amp; 1) &lt;&lt; 1) | (mx &amp; 1);
+    mx &gt;&gt;= 1;
+    my &gt;&gt;= 1;
+
+    src_x = s-&gt;mb_x * 8 + mx;
+    src_y = s-&gt;mb_y * 8 + my;
+    src_x = av_clip(src_x, -8, s-&gt;width/2);
+    if (src_x == s-&gt;width/2)
+        dxy &amp;= ~1;
+    src_y = av_clip(src_y, -8, s-&gt;height/2);
+    if (src_y == s-&gt;height/2)
+        dxy &amp;= ~2;
+
+    offset = (src_y * (s-&gt;uvlinesize)) + src_x;
+    ptr = ref_picture[1] + offset;
+    if(s-&gt;flags&amp;CODEC_FLAG_EMU_EDGE){
+        if(   (unsigned)src_x &gt; (s-&gt;h_edge_pos&gt;&gt;1) - (dxy &amp;1) - 8
+           || (unsigned)src_y &gt; (s-&gt;v_edge_pos&gt;&gt;1) - (dxy&gt;&gt;1) - 8){
+            ff_emulated_edge_mc(s-&gt;edge_emu_buffer, ptr, s-&gt;uvlinesize, 9, 9, src_x, src_y, s-&gt;h_edge_pos&gt;&gt;1, s-&gt;v_edge_pos&gt;&gt;1);
+            ptr= s-&gt;edge_emu_buffer;
+            emu=1;
+        }
+    }
+    pix_op[dxy](dest_cb, ptr, s-&gt;uvlinesize, 8);
+
+    ptr = ref_picture[2] + offset;
+    if(emu){
+        ff_emulated_edge_mc(s-&gt;edge_emu_buffer, ptr, s-&gt;uvlinesize, 9, 9, src_x, src_y, s-&gt;h_edge_pos&gt;&gt;1, s-&gt;v_edge_pos&gt;&gt;1);
+        ptr= s-&gt;edge_emu_buffer;
+    }
+    pix_op[dxy](dest_cr, ptr, s-&gt;uvlinesize, 8);
+}
+
+static inline void prefetch_motion(MpegEncContext *s, uint8_t **pix, int dir){
+    /* fetch pixels for estimated mv 4 macroblocks ahead
+     * optimized for 64byte cache lines */
+    const int shift = s-&gt;quarter_sample ? 2 : 1;
+    const int mx= (s-&gt;mv[dir][0][0]&gt;&gt;shift) + 16*s-&gt;mb_x + 8;
+    const int my= (s-&gt;mv[dir][0][1]&gt;&gt;shift) + 16*s-&gt;mb_y;
+    int off= mx + (my + (s-&gt;mb_x&amp;3)*4)*s-&gt;linesize + 64;
+    s-&gt;dsp.prefetch(pix[0]+off, s-&gt;linesize, 4);
+    off= (mx&gt;&gt;1) + ((my&gt;&gt;1) + (s-&gt;mb_x&amp;7))*s-&gt;uvlinesize + 64;
+    s-&gt;dsp.prefetch(pix[1]+off, pix[2]-pix[1], 2);
+}
+
+/**
+ * motion compensation of a single macroblock
+ * @param s context
+ * @param dest_y luma destination pointer
+ * @param dest_cb chroma cb/u destination pointer
+ * @param dest_cr chroma cr/v destination pointer
+ * @param dir direction (0-&gt;forward, 1-&gt;backward)
+ * @param ref_picture array[3] of pointers to the 3 planes of the reference picture
+ * @param pic_op halfpel motion compensation function (average or put normally)
+ * @param pic_op qpel motion compensation function (average or put normally)
+ * the motion vectors are taken from s-&gt;mv and the MV type from s-&gt;mv_type
+ */
+static inline void MPV_motion(MpegEncContext *s,
+                              uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr,
+                              int dir, uint8_t **ref_picture,
+                              op_pixels_func (*pix_op)[4], qpel_mc_func (*qpix_op)[16])
+{
+    int dxy, mx, my, src_x, src_y, motion_x, motion_y;
+    int mb_x, mb_y, i;
+    uint8_t *ptr, *dest;
+
+    mb_x = s-&gt;mb_x;
+    mb_y = s-&gt;mb_y;
+
+    prefetch_motion(s, ref_picture, dir);
+
+    if(s-&gt;obmc &amp;&amp; s-&gt;pict_type != B_TYPE){
+        int16_t mv_cache[4][4][2];
+        const int xy= s-&gt;mb_x + s-&gt;mb_y*s-&gt;mb_stride;
+        const int mot_stride= s-&gt;b8_stride;
+        const int mot_xy= mb_x*2 + mb_y*2*mot_stride;
+
+        assert(!s-&gt;mb_skipped);
+
+        memcpy(mv_cache[1][1], s-&gt;current_picture.motion_val[0][mot_xy           ], sizeof(int16_t)*4);
+        memcpy(mv_cache[2][1], s-&gt;current_picture.motion_val[0][mot_xy+mot_stride], sizeof(int16_t)*4);
+        memcpy(mv_cache[3][1], s-&gt;current_picture.motion_val[0][mot_xy+mot_stride], sizeof(int16_t)*4);
+
+        if(mb_y==0 || IS_INTRA(s-&gt;current_picture.mb_type[xy-s-&gt;mb_stride])){
+            memcpy(mv_cache[0][1], mv_cache[1][1], sizeof(int16_t)*4);
+        }else{
+            memcpy(mv_cache[0][1], s-&gt;current_picture.motion_val[0][mot_xy-mot_stride], sizeof(int16_t)*4);
+        }
+
+        if(mb_x==0 || IS_INTRA(s-&gt;current_picture.mb_type[xy-1])){
+            *(int32_t*)mv_cache[1][0]= *(int32_t*)mv_cache[1][1];
+            *(int32_t*)mv_cache[2][0]= *(int32_t*)mv_cache[2][1];
+        }else{
+            *(int32_t*)mv_cache[1][0]= *(int32_t*)s-&gt;current_picture.motion_val[0][mot_xy-1];
+            *(int32_t*)mv_cache[2][0]= *(int32_t*)s-&gt;current_picture.motion_val[0][mot_xy-1+mot_stride];
+        }
+
+        if(mb_x+1&gt;=s-&gt;mb_width || IS_INTRA(s-&gt;current_picture.mb_type[xy+1])){
+            *(int32_t*)mv_cache[1][3]= *(int32_t*)mv_cache[1][2];
+            *(int32_t*)mv_cache[2][3]= *(int32_t*)mv_cache[2][2];
+        }else{
+            *(int32_t*)mv_cache[1][3]= *(int32_t*)s-&gt;current_picture.motion_val[0][mot_xy+2];
+            *(int32_t*)mv_cache[2][3]= *(int32_t*)s-&gt;current_picture.motion_val[0][mot_xy+2+mot_stride];
+        }
+
+        mx = 0;
+        my = 0;
+        for(i=0;i&lt;4;i++) {
+            const int x= (i&amp;1)+1;
+            const int y= (i&gt;&gt;1)+1;
+            int16_t mv[5][2]= {
+                {mv_cache[y][x  ][0], mv_cache[y][x  ][1]},
+                {mv_cache[y-1][x][0], mv_cache[y-1][x][1]},
+                {mv_cache[y][x-1][0], mv_cache[y][x-1][1]},
+                {mv_cache[y][x+1][0], mv_cache[y][x+1][1]},
+                {mv_cache[y+1][x][0], mv_cache[y+1][x][1]}};
+            //FIXME cleanup
+            obmc_motion(s, dest_y + ((i &amp; 1) * 8) + (i &gt;&gt; 1) * 8 * s-&gt;linesize,
+                        ref_picture[0],
+                        mb_x * 16 + (i &amp; 1) * 8, mb_y * 16 + (i &gt;&gt;1) * 8,
+                        pix_op[1],
+                        mv);
+
+            mx += mv[0][0];
+            my += mv[0][1];
+        }
+        if(!(s-&gt;flags&amp;CODEC_FLAG_GRAY))
+            chroma_4mv_motion(s, dest_cb, dest_cr, ref_picture, pix_op[1], mx, my);
+
+        return;
+    }
+
+    switch(s-&gt;mv_type) {
+    case MV_TYPE_16X16:
+        if(s-&gt;mcsel){
+            if(s-&gt;real_sprite_warping_points==1){
+                gmc1_motion(s, dest_y, dest_cb, dest_cr,
+                            ref_picture);
+            }else{
+                gmc_motion(s, dest_y, dest_cb, dest_cr,
+                            ref_picture);
+            }
+        }else if(s-&gt;quarter_sample){
+            qpel_motion(s, dest_y, dest_cb, dest_cr,
+                        0, 0, 0,
+                        ref_picture, pix_op, qpix_op,
+                        s-&gt;mv[dir][0][0], s-&gt;mv[dir][0][1], 16);
+        }else if(ENABLE_WMV2 &amp;&amp; s-&gt;mspel){
+            ff_mspel_motion(s, dest_y, dest_cb, dest_cr,
+                        ref_picture, pix_op,
+                        s-&gt;mv[dir][0][0], s-&gt;mv[dir][0][1], 16);
+        }else
+        {
+            mpeg_motion(s, dest_y, dest_cb, dest_cr,
+                        0, 0, 0,
+                        ref_picture, pix_op,
+                        s-&gt;mv[dir][0][0], s-&gt;mv[dir][0][1], 16);
+        }
+        break;
+    case MV_TYPE_8X8:
+        mx = 0;
+        my = 0;
+        if(s-&gt;quarter_sample){
+            for(i=0;i&lt;4;i++) {
+                motion_x = s-&gt;mv[dir][i][0];
+                motion_y = s-&gt;mv[dir][i][1];
+
+                dxy = ((motion_y &amp; 3) &lt;&lt; 2) | (motion_x &amp; 3);
+                src_x = mb_x * 16 + (motion_x &gt;&gt; 2) + (i &amp; 1) * 8;
+                src_y = mb_y * 16 + (motion_y &gt;&gt; 2) + (i &gt;&gt;1) * 8;
+
+                /* WARNING: do no forget half pels */
+                src_x = av_clip(src_x, -16, s-&gt;width);
+                if (src_x == s-&gt;width)
+                    dxy &amp;= ~3;
+                src_y = av_clip(src_y, -16, s-&gt;height);
+                if (src_y == s-&gt;height)
+                    dxy &amp;= ~12;
+
+                ptr = ref_picture[0] + (src_y * s-&gt;linesize) + (src_x);
+                if(s-&gt;flags&amp;CODEC_FLAG_EMU_EDGE){
+                    if(   (unsigned)src_x &gt; s-&gt;h_edge_pos - (motion_x&amp;3) - 8
+                       || (unsigned)src_y &gt; s-&gt;v_edge_pos - (motion_y&amp;3) - 8 ){
+                        ff_emulated_edge_mc(s-&gt;edge_emu_buffer, ptr, s-&gt;linesize, 9, 9, src_x, src_y, s-&gt;h_edge_pos, s-&gt;v_edge_pos);
+                        ptr= s-&gt;edge_emu_buffer;
+                    }
+                }
+                dest = dest_y + ((i &amp; 1) * 8) + (i &gt;&gt; 1) * 8 * s-&gt;linesize;
+                qpix_op[1][dxy](dest, ptr, s-&gt;linesize);
+
+                mx += s-&gt;mv[dir][i][0]/2;
+                my += s-&gt;mv[dir][i][1]/2;
+            }
+        }else{
+            for(i=0;i&lt;4;i++) {
+                hpel_motion(s, dest_y + ((i &amp; 1) * 8) + (i &gt;&gt; 1) * 8 * s-&gt;linesize,
+                            ref_picture[0], 0, 0,
+                            mb_x * 16 + (i &amp; 1) * 8, mb_y * 16 + (i &gt;&gt;1) * 8,
+                            s-&gt;width, s-&gt;height, s-&gt;linesize,
+                            s-&gt;h_edge_pos, s-&gt;v_edge_pos,
+                            8, 8, pix_op[1],
+                            s-&gt;mv[dir][i][0], s-&gt;mv[dir][i][1]);
+
+                mx += s-&gt;mv[dir][i][0];
+                my += s-&gt;mv[dir][i][1];
+            }
+        }
+
+        if(!(s-&gt;flags&amp;CODEC_FLAG_GRAY))
+            chroma_4mv_motion(s, dest_cb, dest_cr, ref_picture, pix_op[1], mx, my);
+        break;
+    case MV_TYPE_FIELD:
+        if (s-&gt;picture_structure == PICT_FRAME) {
+            if(s-&gt;quarter_sample){
+                for(i=0; i&lt;2; i++){
+                    qpel_motion(s, dest_y, dest_cb, dest_cr,
+                                1, i, s-&gt;field_select[dir][i],
+                                ref_picture, pix_op, qpix_op,
+                                s-&gt;mv[dir][i][0], s-&gt;mv[dir][i][1], 8);
+                }
+            }else{
+                /* top field */
+                mpeg_motion(s, dest_y, dest_cb, dest_cr,
+                            1, 0, s-&gt;field_select[dir][0],
+                            ref_picture, pix_op,
+                            s-&gt;mv[dir][0][0], s-&gt;mv[dir][0][1], 8);
+                /* bottom field */
+                mpeg_motion(s, dest_y, dest_cb, dest_cr,
+                            1, 1, s-&gt;field_select[dir][1],
+                            ref_picture, pix_op,
+                            s-&gt;mv[dir][1][0], s-&gt;mv[dir][1][1], 8);
+            }
+        } else {
+            if(s-&gt;picture_structure != s-&gt;field_select[dir][0] + 1 &amp;&amp; s-&gt;pict_type != B_TYPE &amp;&amp; !s-&gt;first_field){
+                ref_picture= s-&gt;current_picture_ptr-&gt;data;
+            }
+
+            mpeg_motion(s, dest_y, dest_cb, dest_cr,
+                        0, 0, s-&gt;field_select[dir][0],
+                        ref_picture, pix_op,
+                        s-&gt;mv[dir][0][0], s-&gt;mv[dir][0][1], 16);
+        }
+        break;
+    case MV_TYPE_16X8:
+        for(i=0; i&lt;2; i++){
+            uint8_t ** ref2picture;
+
+            if(s-&gt;picture_structure == s-&gt;field_select[dir][i] + 1 || s-&gt;pict_type == B_TYPE || s-&gt;first_field){
+                ref2picture= ref_picture;
+            }else{
+                ref2picture= s-&gt;current_picture_ptr-&gt;data;
+            }
+
+            mpeg_motion(s, dest_y, dest_cb, dest_cr,
+                        0, 0, s-&gt;field_select[dir][i],
+                        ref2picture, pix_op,
+                        s-&gt;mv[dir][i][0], s-&gt;mv[dir][i][1] + 16*i, 8);
+
+            dest_y += 16*s-&gt;linesize;
+            dest_cb+= (16&gt;&gt;s-&gt;chroma_y_shift)*s-&gt;uvlinesize;
+            dest_cr+= (16&gt;&gt;s-&gt;chroma_y_shift)*s-&gt;uvlinesize;
+        }
+        break;
+    case MV_TYPE_DMV:
+        if(s-&gt;picture_structure == PICT_FRAME){
+            for(i=0; i&lt;2; i++){
+                int j;
+                for(j=0; j&lt;2; j++){
+                    mpeg_motion(s, dest_y, dest_cb, dest_cr,
+                                1, j, j^i,
+                                ref_picture, pix_op,
+                                s-&gt;mv[dir][2*i + j][0], s-&gt;mv[dir][2*i + j][1], 8);
+                }
+                pix_op = s-&gt;dsp.avg_pixels_tab;
+            }
+        }else{
+            for(i=0; i&lt;2; i++){
+                mpeg_motion(s, dest_y, dest_cb, dest_cr,
+                            0, 0, s-&gt;picture_structure != i+1,
+                            ref_picture, pix_op,
+                            s-&gt;mv[dir][2*i][0],s-&gt;mv[dir][2*i][1],16);
+
+                // after put we make avg of the same block
+                pix_op=s-&gt;dsp.avg_pixels_tab;
+
+                //opposite parity is always in the same frame if this is second field
+                if(!s-&gt;first_field){
+                    ref_picture = s-&gt;current_picture_ptr-&gt;data;
+                }
+            }
+        }
+    break;
+    default: assert(0);
+    }
+}
+
+#endif /* MPEGVIDEO_COMMON_H */

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/msmpeg4.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/msmpeg4.h	2007-07-16 18:08:14 UTC (rev 3389)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/msmpeg4.h	2007-07-16 18:11:38 UTC (rev 3390)
@@ -0,0 +1,44 @@
+/*
+ * MSMPEG4 backend for ffmpeg encoder and decoder
+ * copyright (c) 2007 Aurelien Jacobs &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">aurel at gnuage.org</A>&gt;
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file msmpeg4.h
+ */
+
+#ifndef MSMPEG4_H
+#define MSMPEG4_H
+
+#include &quot;config.h&quot;
+
+#define ENABLE_MSMPEG4_DECODER (ENABLE_MSMPEG4V1_DECODER || \
+                                ENABLE_MSMPEG4V2_DECODER || \
+                                ENABLE_MSMPEG4V3_DECODER || \
+                                ENABLE_WMV2_DECODER)
+#define ENABLE_MSMPEG4_ENCODER (ENABLE_MSMPEG4V1_ENCODER || \
+                                ENABLE_MSMPEG4V2_ENCODER || \
+                                ENABLE_MSMPEG4V3_ENCODER || \
+                                ENABLE_WMV2_ENCODER)
+#define ENABLE_MSMPEG4 (ENABLE_MSMPEG4_DECODER || ENABLE_MSMPEG4_ENCODER)
+#define ENABLE_WMV2 (ENABLE_WMV2_DECODER || ENABLE_WMV2_ENCODER)
+#define ENABLE_WMV_DECODER (ENABLE_WMV1_DECODER || ENABLE_WMV2_DECODER)
+#define ENABLE_WMV_ENCODER (ENABLE_WMV1_ENCODER || ENABLE_WMV2_ENCODER)
+
+#endif /* MSMPEG4_H */

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/roqvideo.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/roqvideo.h	2007-07-16 18:08:14 UTC (rev 3389)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/roqvideo.h	2007-07-16 18:11:38 UTC (rev 3390)
@@ -0,0 +1,92 @@
+/*
+ * Copyright (C) 2003 Mike Melanson
+ * Copyright (C) 2003 Dr. Tim Ferguson
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_ROQVIDEO_H
+#define AVCODEC_ROQVIDEO_H
+
+#include &quot;avcodec.h&quot;
+#include &quot;dsputil.h&quot;
+#include &quot;random.h&quot;
+
+typedef struct {
+    unsigned char y[4];
+    unsigned char u, v;
+} roq_cell;
+
+typedef struct {
+    int idx[4];
+} roq_qcell;
+
+typedef struct {
+    int d[2];
+} motion_vect;
+
+typedef struct RoqContext {
+
+    AVCodecContext *avctx;
+    DSPContext dsp;
+    AVFrame frames[2];
+    AVFrame *last_frame;
+    AVFrame *current_frame;
+    int first_frame;
+
+    roq_cell cb2x2[256];
+    roq_qcell cb4x4[256];
+
+    unsigned char *buf;
+    int size;
+    int width, height;
+
+    /* Encoder only data */
+    AVRandomState randctx;
+    uint64_t lambda;
+
+    motion_vect *this_motion4;
+    motion_vect *last_motion4;
+
+    motion_vect *this_motion8;
+    motion_vect *last_motion8;
+
+    unsigned int framesSinceKeyframe;
+
+    AVFrame *frame_to_enc;
+    uint8_t *out_buf;
+} RoqContext;
+
+#define RoQ_INFO              0x1001
+#define RoQ_QUAD_CODEBOOK     0x1002
+#define RoQ_QUAD_VQ           0x1011
+#define RoQ_SOUND_MONO        0x1020
+#define RoQ_SOUND_STEREO      0x1021
+
+#define RoQ_ID_MOT              0x00
+#define RoQ_ID_FCC              0x01
+#define RoQ_ID_SLD              0x02
+#define RoQ_ID_CCC              0x03
+
+void ff_apply_vector_2x2(RoqContext *ri, int x, int y, roq_cell *cell);
+void ff_apply_vector_4x4(RoqContext *ri, int x, int y, roq_cell *cell);
+
+void ff_apply_motion_4x4(RoqContext *ri, int x, int y, int deltax, int deltay);
+
+void ff_apply_motion_8x8(RoqContext *ri, int x, int y, int deltax, int deltay);
+
+#endif // AVCODEC_ROQVIDEO_H

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/vc1.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/vc1.h	2007-07-16 18:08:14 UTC (rev 3389)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/vc1.h	2007-07-16 18:11:38 UTC (rev 3390)
@@ -0,0 +1,307 @@
+/*
+ * VC-1 and WMV3 decoder
+ * Copyright (c) 2006-2007 Konstantin Shishkov
+ * Partly based on vc9.c (c) 2005 Anonymous, Alex Beregszaszi, Michael Niedermayer
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_VC1_H
+#define AVCODEC_VC1_H
+
+#include &quot;avcodec.h&quot;
+#include &quot;mpegvideo.h&quot;
+
+/** Markers used in VC-1 AP frame data */
+//@{
+enum VC1Code{
+    VC1_CODE_RES0       = 0x00000100,
+    VC1_CODE_ENDOFSEQ   = 0x0000010A,
+    VC1_CODE_SLICE,
+    VC1_CODE_FIELD,
+    VC1_CODE_FRAME,
+    VC1_CODE_ENTRYPOINT,
+    VC1_CODE_SEQHDR,
+};
+//@}
+
+#define IS_MARKER(x) (((x) &amp; ~0xFF) == VC1_CODE_RES0)
+
+/** Available Profiles */
+//@{
+enum Profile {
+    PROFILE_SIMPLE,
+    PROFILE_MAIN,
+    PROFILE_COMPLEX, ///&lt; TODO: WMV9 specific
+    PROFILE_ADVANCED
+};
+//@}
+
+/** Sequence quantizer mode */
+//@{
+enum QuantMode {
+    QUANT_FRAME_IMPLICIT,    ///&lt; Implicitly specified at frame level
+    QUANT_FRAME_EXPLICIT,    ///&lt; Explicitly specified at frame level
+    QUANT_NON_UNIFORM,       ///&lt; Non-uniform quant used for all frames
+    QUANT_UNIFORM            ///&lt; Uniform quant used for all frames
+};
+//@}
+
+/** Where quant can be changed */
+//@{
+enum DQProfile {
+    DQPROFILE_FOUR_EDGES,
+    DQPROFILE_DOUBLE_EDGES,
+    DQPROFILE_SINGLE_EDGE,
+    DQPROFILE_ALL_MBS
+};
+//@}
+
+/** @name Where quant can be changed
+ */
+//@{
+enum DQSingleEdge {
+    DQSINGLE_BEDGE_LEFT,
+    DQSINGLE_BEDGE_TOP,
+    DQSINGLE_BEDGE_RIGHT,
+    DQSINGLE_BEDGE_BOTTOM
+};
+//@}
+
+/** Which pair of edges is quantized with ALTPQUANT */
+//@{
+enum DQDoubleEdge {
+    DQDOUBLE_BEDGE_TOPLEFT,
+    DQDOUBLE_BEDGE_TOPRIGHT,
+    DQDOUBLE_BEDGE_BOTTOMRIGHT,
+    DQDOUBLE_BEDGE_BOTTOMLEFT
+};
+//@}
+
+/** MV modes for P frames */
+//@{
+enum MVModes {
+    MV_PMODE_1MV_HPEL_BILIN,
+    MV_PMODE_1MV,
+    MV_PMODE_1MV_HPEL,
+    MV_PMODE_MIXED_MV,
+    MV_PMODE_INTENSITY_COMP
+};
+//@}
+
+/** @name MV types for B frames */
+//@{
+enum BMVTypes {
+    BMV_TYPE_BACKWARD,
+    BMV_TYPE_FORWARD,
+    BMV_TYPE_INTERPOLATED
+};
+//@}
+
+/** @name Block types for P/B frames */
+//@{
+enum TransformTypes {
+    TT_8X8,
+    TT_8X4_BOTTOM,
+    TT_8X4_TOP,
+    TT_8X4, //Both halves
+    TT_4X8_RIGHT,
+    TT_4X8_LEFT,
+    TT_4X8, //Both halves
+    TT_4X4
+};
+//@}
+
+/** One more frame type */
+#define BI_TYPE 7
+
+enum CodingSet {
+    CS_HIGH_MOT_INTRA = 0,
+    CS_HIGH_MOT_INTER,
+    CS_LOW_MOT_INTRA,
+    CS_LOW_MOT_INTER,
+    CS_MID_RATE_INTRA,
+    CS_MID_RATE_INTER,
+    CS_HIGH_RATE_INTRA,
+    CS_HIGH_RATE_INTER
+};
+
+/** @name Overlap conditions for Advanced Profile */
+//@{
+enum COTypes {
+    CONDOVER_NONE = 0,
+    CONDOVER_ALL,
+    CONDOVER_SELECT
+};
+//@}
+
+
+/** The VC1 Context
+ * @todo Change size wherever another size is more efficient
+ * Many members are only used for Advanced Profile
+ */
+typedef struct VC1Context{
+    MpegEncContext s;
+
+    int bits;
+
+    /** Simple/Main Profile sequence header */
+    //@{
+    int res_sm;           ///&lt; reserved, 2b
+    int res_x8;           ///&lt; reserved
+    int multires;         ///&lt; frame-level RESPIC syntax element present
+    int res_fasttx;       ///&lt; reserved, always 1
+    int res_transtab;     ///&lt; reserved, always 0
+    int rangered;         ///&lt; RANGEREDFRM (range reduction) syntax element present
+                          ///&lt; at frame level
+    int res_rtm_flag;     ///&lt; reserved, set to 1
+    int reserved;         ///&lt; reserved
+    //@}
+
+    /** Advanced Profile */
+    //@{
+    int level;            ///&lt; 3bits, for Advanced/Simple Profile, provided by TS layer
+    int chromaformat;     ///&lt; 2bits, 2=4:2:0, only defined
+    int postprocflag;     ///&lt; Per-frame processing suggestion flag present
+    int broadcast;        ///&lt; TFF/RFF present
+    int interlace;        ///&lt; Progressive/interlaced (RPTFTM syntax element)
+    int tfcntrflag;       ///&lt; TFCNTR present
+    int panscanflag;      ///&lt; NUMPANSCANWIN, TOPLEFT{X,Y}, BOTRIGHT{X,Y} present
+    int extended_dmv;     ///&lt; Additional extended dmv range at P/B frame-level
+    int color_prim;       ///&lt; 8bits, chroma coordinates of the color primaries
+    int transfer_char;    ///&lt; 8bits, Opto-electronic transfer characteristics
+    int matrix_coef;      ///&lt; 8bits, Color primaries-&gt;YCbCr transform matrix
+    int hrd_param_flag;   ///&lt; Presence of Hypothetical Reference
+                          ///&lt; Decoder parameters
+    int psf;              ///&lt; Progressive Segmented Frame
+    //@}
+
+    /** Sequence header data for all Profiles
+     * TODO: choose between ints, uint8_ts and monobit flags
+     */
+    //@{
+    int profile;          ///&lt; 2bits, Profile
+    int frmrtq_postproc;  ///&lt; 3bits,
+    int bitrtq_postproc;  ///&lt; 5bits, quantized framerate-based postprocessing strength
+    int fastuvmc;         ///&lt; Rounding of qpel vector to hpel ? (not in Simple)
+    int extended_mv;      ///&lt; Ext MV in P/B (not in Simple)
+    int dquant;           ///&lt; How qscale varies with MBs, 2bits (not in Simple)
+    int vstransform;      ///&lt; variable-size [48]x[48] transform type + info
+    int overlap;          ///&lt; overlapped transforms in use
+    int quantizer_mode;   ///&lt; 2bits, quantizer mode used for sequence, see QUANT_*
+    int finterpflag;      ///&lt; INTERPFRM present
+    //@}
+
+    /** Frame decoding info for all profiles */
+    //@{
+    uint8_t mv_mode;      ///&lt; MV coding monde
+    uint8_t mv_mode2;     ///&lt; Secondary MV coding mode (B frames)
+    int k_x;              ///&lt; Number of bits for MVs (depends on MV range)
+    int k_y;              ///&lt; Number of bits for MVs (depends on MV range)
+    int range_x, range_y; ///&lt; MV range
+    uint8_t pq, altpq;    ///&lt; Current/alternate frame quantizer scale
+    /** pquant parameters */
+    //@{
+    uint8_t dquantfrm;
+    uint8_t dqprofile;
+    uint8_t dqsbedge;
+    uint8_t dqbilevel;
+    //@}
+    /** AC coding set indexes
+     * @see 8.1.1.10, p(1)10
+     */
+    //@{
+    int c_ac_table_index; ///&lt; Chroma index from ACFRM element
+    int y_ac_table_index; ///&lt; Luma index from AC2FRM element
+    //@}
+    int ttfrm;            ///&lt; Transform type info present at frame level
+    uint8_t ttmbf;        ///&lt; Transform type flag
+    uint8_t ttblk4x4;     ///&lt; Value of ttblk which indicates a 4x4 transform
+    int codingset;        ///&lt; index of current table set from 11.8 to use for luma block decoding
+    int codingset2;       ///&lt; index of current table set from 11.8 to use for chroma block decoding
+    int pqindex;          ///&lt; raw pqindex used in coding set selection
+    int a_avail, c_avail;
+    uint8_t *mb_type_base, *mb_type[3];
+
+
+    /** Luma compensation parameters */
+    //@{
+    uint8_t lumscale;
+    uint8_t lumshift;
+    //@}
+    int16_t bfraction;    ///&lt; Relative position % anchors=&gt; how to scale MVs
+    uint8_t halfpq;       ///&lt; Uniform quant over image and qp+.5
+    uint8_t respic;       ///&lt; Frame-level flag for resized images
+    int buffer_fullness;  ///&lt; HRD info
+    /** Ranges:
+     * -# 0 -&gt; [-64n 63.f] x [-32, 31.f]
+     * -# 1 -&gt; [-128, 127.f] x [-64, 63.f]
+     * -# 2 -&gt; [-512, 511.f] x [-128, 127.f]
+     * -# 3 -&gt; [-1024, 1023.f] x [-256, 255.f]
+     */
+    uint8_t mvrange;
+    uint8_t pquantizer;           ///&lt; Uniform (over sequence) quantizer in use
+    VLC *cbpcy_vlc;               ///&lt; CBPCY VLC table
+    int tt_index;                 ///&lt; Index for Transform Type tables
+    uint8_t* mv_type_mb_plane;    ///&lt; bitplane for mv_type == (4MV)
+    uint8_t* direct_mb_plane;     ///&lt; bitplane for &quot;direct&quot; MBs
+    int mv_type_is_raw;           ///&lt; mv type mb plane is not coded
+    int dmb_is_raw;               ///&lt; direct mb plane is raw
+    int skip_is_raw;              ///&lt; skip mb plane is not coded
+    uint8_t luty[256], lutuv[256]; // lookup tables used for intensity compensation
+    int use_ic;                   ///&lt; use intensity compensation in B-frames
+    int rnd;                      ///&lt; rounding control
+
+    /** Frame decoding info for S/M profiles only */
+    //@{
+    uint8_t rangeredfrm; ///&lt; out_sample = CLIP((in_sample-128)*2+128)
+    uint8_t interpfrm;
+    //@}
+
+    /** Frame decoding info for Advanced profile */
+    //@{
+    uint8_t fcm; ///&lt; 0-&gt;Progressive, 2-&gt;Frame-Interlace, 3-&gt;Field-Interlace
+    uint8_t numpanscanwin;
+    uint8_t tfcntr;
+    uint8_t rptfrm, tff, rff;
+    uint16_t topleftx;
+    uint16_t toplefty;
+    uint16_t bottomrightx;
+    uint16_t bottomrighty;
+    uint8_t uvsamp;
+    uint8_t postproc;
+    int hrd_num_leaky_buckets;
+    uint8_t bit_rate_exponent;
+    uint8_t buffer_size_exponent;
+    uint8_t* acpred_plane;       ///&lt; AC prediction flags bitplane
+    int acpred_is_raw;
+    uint8_t* over_flags_plane;   ///&lt; Overflags bitplane
+    int overflg_is_raw;
+    uint8_t condover;
+    uint16_t *hrd_rate, *hrd_buffer;
+    uint8_t *hrd_fullness;
+    uint8_t range_mapy_flag;
+    uint8_t range_mapuv_flag;
+    uint8_t range_mapy;
+    uint8_t range_mapuv;
+    //@}
+
+    int p_frame_skipped;
+    int bi_type;
+} VC1Context;
+
+#endif // AVCODEC_VC1_H

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/wma.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/wma.h	2007-07-16 18:08:14 UTC (rev 3389)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/wma.h	2007-07-16 18:11:38 UTC (rev 3390)
@@ -0,0 +1,150 @@
+/*
+ * WMA compatible codec
+ * Copyright (c) 2002-2007 The FFmpeg Project.
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef WMA_H
+#define WMA_H
+
+#include &quot;bitstream.h&quot;
+#include &quot;dsputil.h&quot;
+
+/* size of blocks */
+#define BLOCK_MIN_BITS 7
+#define BLOCK_MAX_BITS 11
+#define BLOCK_MAX_SIZE (1 &lt;&lt; BLOCK_MAX_BITS)
+
+#define BLOCK_NB_SIZES (BLOCK_MAX_BITS - BLOCK_MIN_BITS + 1)
+
+/* XXX: find exact max size */
+#define HIGH_BAND_MAX_SIZE 16
+
+#define NB_LSP_COEFS 10
+
+/* XXX: is it a suitable value ? */
+#define MAX_CODED_SUPERFRAME_SIZE 16384
+
+#define MAX_CHANNELS 2
+
+#define NOISE_TAB_SIZE 8192
+
+#define LSP_POW_BITS 7
+
+//FIXME should be in wmadec
+#define VLCBITS 9
+#define VLCMAX ((22+VLCBITS-1)/VLCBITS)
+
+typedef struct CoefVLCTable {
+    int n;                      ///&lt; total number of codes
+    int max_level;
+    const uint32_t *huffcodes;  ///&lt; VLC bit values
+    const uint8_t *huffbits;    ///&lt; VLC bit size
+    const uint16_t *levels;     ///&lt; table to build run/level tables
+} CoefVLCTable;
+
+typedef struct WMACodecContext {
+    AVCodecContext* avctx;
+    GetBitContext gb;
+    PutBitContext pb;
+    int sample_rate;
+    int nb_channels;
+    int bit_rate;
+    int version;                            ///&lt; 1 = 0x160 (WMAV1), 2 = 0x161 (WMAV2)
+    int block_align;
+    int use_bit_reservoir;
+    int use_variable_block_len;
+    int use_exp_vlc;                        ///&lt; exponent coding: 0 = lsp, 1 = vlc + delta
+    int use_noise_coding;                   ///&lt; true if perceptual noise is added
+    int byte_offset_bits;
+    VLC exp_vlc;
+    int exponent_sizes[BLOCK_NB_SIZES];
+    uint16_t exponent_bands[BLOCK_NB_SIZES][25];
+    int high_band_start[BLOCK_NB_SIZES];    ///&lt; index of first coef in high band
+    int coefs_start;                        ///&lt; first coded coef
+    int coefs_end[BLOCK_NB_SIZES];          ///&lt; max number of coded coefficients
+    int exponent_high_sizes[BLOCK_NB_SIZES];
+    int exponent_high_bands[BLOCK_NB_SIZES][HIGH_BAND_MAX_SIZE];
+    VLC hgain_vlc;
+
+    /* coded values in high bands */
+    int high_band_coded[MAX_CHANNELS][HIGH_BAND_MAX_SIZE];
+    int high_band_values[MAX_CHANNELS][HIGH_BAND_MAX_SIZE];
+
+    /* there are two possible tables for spectral coefficients */
+//FIXME the following 3 tables should be shared between decoders
+    VLC coef_vlc[2];
+    uint16_t *run_table[2];
+    uint16_t *level_table[2];
+    uint16_t *int_table[2];
+    const CoefVLCTable *coef_vlcs[2];
+    /* frame info */
+    int frame_len;                          ///&lt; frame length in samples
+    int frame_len_bits;                     ///&lt; frame_len = 1 &lt;&lt; frame_len_bits
+    int nb_block_sizes;                     ///&lt; number of block sizes
+    /* block info */
+    int reset_block_lengths;
+    int block_len_bits;                     ///&lt; log2 of current block length
+    int next_block_len_bits;                ///&lt; log2 of next block length
+    int prev_block_len_bits;                ///&lt; log2 of prev block length
+    int block_len;                          ///&lt; block length in samples
+    int block_num;                          ///&lt; block number in current frame
+    int block_pos;                          ///&lt; current position in frame
+    uint8_t ms_stereo;                      ///&lt; true if mid/side stereo mode
+    uint8_t channel_coded[MAX_CHANNELS];    ///&lt; true if channel is coded
+    int exponents_bsize[MAX_CHANNELS];      ///&lt; log2 ratio frame/exp. length
+    DECLARE_ALIGNED_16(float, exponents[MAX_CHANNELS][BLOCK_MAX_SIZE]);
+    float max_exponent[MAX_CHANNELS];
+    int16_t coefs1[MAX_CHANNELS][BLOCK_MAX_SIZE];
+    DECLARE_ALIGNED_16(float, coefs[MAX_CHANNELS][BLOCK_MAX_SIZE]);
+    DECLARE_ALIGNED_16(FFTSample, output[BLOCK_MAX_SIZE * 2]);
+    MDCTContext mdct_ctx[BLOCK_NB_SIZES];
+    float *windows[BLOCK_NB_SIZES];
+    DECLARE_ALIGNED_16(FFTSample, mdct_tmp[BLOCK_MAX_SIZE]); ///&lt; temporary storage for imdct
+    /* output buffer for one frame and the last for IMDCT windowing */
+    DECLARE_ALIGNED_16(float, frame_out[MAX_CHANNELS][BLOCK_MAX_SIZE * 2]);
+    /* last frame info */
+    uint8_t last_superframe[MAX_CODED_SUPERFRAME_SIZE + 4]; /* padding added */
+    int last_bitoffset;
+    int last_superframe_len;
+    float noise_table[NOISE_TAB_SIZE];
+    int noise_index;
+    float noise_mult; /* XXX: suppress that and integrate it in the noise array */
+    /* lsp_to_curve tables */
+    float lsp_cos_table[BLOCK_MAX_SIZE];
+    float lsp_pow_e_table[256];
+    float lsp_pow_m_table1[(1 &lt;&lt; LSP_POW_BITS)];
+    float lsp_pow_m_table2[(1 &lt;&lt; LSP_POW_BITS)];
+    DSPContext dsp;
+
+#ifdef TRACE
+    int frame_count;
+#endif
+} WMACodecContext;
+
+extern const uint16_t ff_wma_hgain_huffcodes[37];
+extern const uint8_t ff_wma_hgain_huffbits[37];
+extern const float ff_wma_lsp_codebook[NB_LSP_COEFS][16];
+extern const uint32_t ff_wma_scale_huffcodes[121];
+extern const uint8_t ff_wma_scale_huffbits[121];
+
+int ff_wma_init(AVCodecContext * avctx, int flags2);
+int ff_wma_total_gain_to_bits(int total_gain);
+int ff_wma_end(AVCodecContext *avctx);
+
+#endif


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000665.html">[Avidemux-svn-commit] r3389 - in	branches/avidemux_2.4_branch/avidemux/ADM_libraries:	ADM_lavcodec ADM_lavutil
</A></li>
	<LI>Next message: <A HREF="000667.html">[Avidemux-svn-commit] r3391 -	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#666">[ date ]</a>
              <a href="thread.html#666">[ thread ]</a>
              <a href="subject.html#666">[ subject ]</a>
              <a href="author.html#666">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
