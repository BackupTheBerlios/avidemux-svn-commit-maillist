<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r3383 -	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2007-July/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r3383%20-%0A%09branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat&In-Reply-To=%3C200707161744.l6GHiP55008123%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000659.html">
   <LINK REL="Next"  HREF="000661.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r3383 -	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat</H1>
    <B>mean at BerliOS</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r3383%20-%0A%09branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat&In-Reply-To=%3C200707161744.l6GHiP55008123%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r3383 -	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat">mean at mail.berlios.de
       </A><BR>
    <I>Mon Jul 16 19:44:25 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000659.html">[Avidemux-svn-commit] r3382 -	branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_asf
</A></li>
        <LI>Next message: <A HREF="000661.html">[Avidemux-svn-commit] r3384 -	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#660">[ date ]</a>
              <a href="thread.html#660">[ thread ]</a>
              <a href="subject.html#660">[ subject ]</a>
              <a href="author.html#660">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2007-07-16 19:44:22 +0200 (Mon, 16 Jul 2007)
New Revision: 3383

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/ADM_lavformat.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/allformats.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/allformats.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/avformat.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/avienc.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/avio.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/avio.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/aviobuf.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/cutils.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/dv.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/file.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/flv.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/img2.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/isom.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/isom.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/matroska.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/mov.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/movenc.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/mpeg.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/mpegts.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/mpegtsenc.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/qtpalette.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/riff.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/riff.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/rtp.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/rtsp.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/rtspcodes.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/utils.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/wav.c
Log:
[LAV] update to RR9685 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/ADM_lavformat.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/ADM_lavformat.cpp	2007-07-16 16:39:52 UTC (rev 3382)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/ADM_lavformat.cpp	2007-07-16 17:44:22 UTC (rev 3383)
@@ -611,12 +611,9 @@
      extern  int        movenc_init(void );
 };
 extern URLProtocol file_protocol ;
-extern AVInputFormat matroska_demuxer;
 uint8_t lavformat_init(void)
 {
-//                mpegps_init();
                 movenc_init();
-                av_register_input_format(&amp;matroska_demuxer);
                 register_protocol(&amp;file_protocol);
 }
 extern &quot;C&quot;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/allformats.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/allformats.c	2007-07-16 16:39:52 UTC (rev 3382)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/allformats.c	2007-07-16 17:44:22 UTC (rev 3383)
@@ -26,12 +26,14 @@
 #define REGISTER_DEMUXER(X,x) \
           if(ENABLE_##X##_DEMUXER) av_register_input_format(&amp;x##_demuxer)
 #define REGISTER_MUXDEMUX(X,x)  REGISTER_MUXER(X,x); REGISTER_DEMUXER(X,x)
+#define REGISTER_PROTOCOL(X,x) \
+          if(ENABLE_##X##_PROTOCOL) register_protocol(&amp;x##_protocol)
 
 /* If you do not call this function, then you can select exactly which
    formats you want to support */
 
 /**
- * Initialize libavcodec and register all the codecs and formats.
+ * Initialize libavformat and register all the (de)muxers and protocols.
  */
 void av_register_all(void)
 {
@@ -49,28 +51,26 @@
     REGISTER_MUXER   (ADTS, adts);
     REGISTER_MUXDEMUX(AIFF, aiff);
     REGISTER_MUXDEMUX(AMR, amr);
+    REGISTER_DEMUXER (APC, apc);
     REGISTER_MUXDEMUX(ASF, asf);
     REGISTER_MUXER   (ASF_STREAM, asf_stream);
     REGISTER_MUXDEMUX(AU, au);
-#if defined(CONFIG_AUDIO_OSS) || defined(CONFIG_AUDIO_BEOS)
     REGISTER_MUXDEMUX(AUDIO, audio);
-#endif
     REGISTER_MUXDEMUX(AVI, avi);
 #ifdef CONFIG_AVISYNTH
     av_register_input_format(&amp;avisynth_demuxer);
 #endif
     REGISTER_DEMUXER (AVS, avs);
+    REGISTER_DEMUXER (BETHSOFTVID, bethsoftvid);
+    REGISTER_DEMUXER (C93, c93);
     REGISTER_MUXER   (CRC, crc);
     REGISTER_DEMUXER (DAUD, daud);
-#ifdef CONFIG_DC1394
     REGISTER_DEMUXER (DC1394, dc1394);
-#endif
     REGISTER_DEMUXER (DSICIN, dsicin);
     REGISTER_DEMUXER (DTS, dts);
     REGISTER_MUXDEMUX(DV, dv);
-#ifdef CONFIG_DV1394
     REGISTER_DEMUXER (DV1394, dv1394);
-#endif
+    REGISTER_DEMUXER (DXA, dxa);
     REGISTER_DEMUXER (EA, ea);
     REGISTER_MUXDEMUX(FFM, ffm);
     REGISTER_MUXDEMUX(FLAC, flac);
@@ -80,9 +80,7 @@
     REGISTER_MUXER   (FRAMECRC, framecrc);
     REGISTER_MUXDEMUX(GIF, gif);
     REGISTER_DEMUXER (GXF, gxf);
-#ifdef CONFIG_GPL
     REGISTER_MUXER   (GXF, gxf);
-#endif
     REGISTER_MUXDEMUX(H261, h261);
     REGISTER_MUXDEMUX(H263, h263);
     REGISTER_MUXDEMUX(H264, h264);
@@ -91,6 +89,8 @@
     REGISTER_MUXDEMUX(IMAGE2PIPE, image2pipe);
     REGISTER_DEMUXER (INGENIENT, ingenient);
     REGISTER_DEMUXER (IPMOVIE, ipmovie);
+    if (!ENABLE_NUT_DEMUXER) REGISTER_DEMUXER (LIBNUT, libnut);
+    REGISTER_MUXER   (LIBNUT, libnut);
     REGISTER_MUXDEMUX(M4V, m4v);
     REGISTER_DEMUXER (MATROSKA, matroska);
     REGISTER_MUXDEMUX(MJPEG, mjpeg);
@@ -110,6 +110,7 @@
     REGISTER_MUXER   (MPEG2VOB, mpeg2vob);
     REGISTER_DEMUXER (MPEGPS, mpegps);
     REGISTER_MUXDEMUX(MPEGTS, mpegts);
+    REGISTER_DEMUXER (MPEGTSRAW, mpegtsraw);
     REGISTER_DEMUXER (MPEGVIDEO, mpegvideo);
     REGISTER_MUXER   (MPJPEG, mpjpeg);
     REGISTER_DEMUXER (MTV, mtv);
@@ -117,14 +118,9 @@
     REGISTER_DEMUXER (NSV, nsv);
     REGISTER_MUXER   (NULL, null);
     REGISTER_DEMUXER (NUT, nut);
-#ifdef CONFIG_LIBNUT
-    REGISTER_MUXER   (NUT, nut);
-#endif
     REGISTER_DEMUXER (NUV, nuv);
     REGISTER_DEMUXER (OGG, ogg);
-#ifdef CONFIG_LIBOGG
     REGISTER_MUXER   (OGG, ogg);
-#endif
     REGISTER_MUXDEMUX(PCM_ALAW,  pcm_alaw);
     REGISTER_MUXDEMUX(PCM_MULAW, pcm_mulaw);
     REGISTER_MUXDEMUX(PCM_S16BE, pcm_s16be);
@@ -136,12 +132,12 @@
     REGISTER_MUXER   (PSP, psp);
     REGISTER_MUXDEMUX(RAWVIDEO, rawvideo);
     REGISTER_MUXDEMUX(RM, rm);
-    REGISTER_DEMUXER (ROQ, roq);
-#ifdef CONFIG_NETWORK
+    REGISTER_MUXDEMUX(ROQ, roq);
     REGISTER_DEMUXER (REDIR, redir);
     REGISTER_MUXER   (RTP, rtp);
     REGISTER_DEMUXER (RTSP, rtsp);
     REGISTER_DEMUXER (SDP, sdp);
+#ifdef CONFIG_RTP_MUXER
     av_register_rtp_dynamic_payload_handlers();
 #endif
     REGISTER_DEMUXER (SEGAFILM, segafilm);
@@ -152,14 +148,14 @@
     REGISTER_MUXDEMUX(SWF, swf);
     REGISTER_MUXER   (TG2, tg2);
     REGISTER_MUXER   (TGP, tgp);
+    REGISTER_DEMUXER (THP, thp);
     REGISTER_DEMUXER (TIERTEXSEQ, tiertexseq);
     REGISTER_DEMUXER (TTA, tta);
-#ifdef CONFIG_VIDEO4LINUX2
+    REGISTER_DEMUXER (TXD, txd);
     REGISTER_DEMUXER (V4L2, v4l2);
-#endif
-#if defined(CONFIG_VIDEO4LINUX) || defined(CONFIG_BKTR)
-    REGISTER_DEMUXER (VIDEO_GRAB_DEVICE, video_grab_device);
-#endif
+    REGISTER_DEMUXER (VC1, vc1);
+    REGISTER_DEMUXER (VIDEO_GRAB_BKTR, video_grab_bktr);
+    REGISTER_DEMUXER (VIDEO_GRAB_V4L, video_grab_v4l);
     REGISTER_DEMUXER (VMD, vmd);
     REGISTER_MUXDEMUX(VOC, voc);
     REGISTER_MUXDEMUX(WAV, wav);
@@ -167,20 +163,13 @@
     REGISTER_DEMUXER (WSAUD, wsaud);
     REGISTER_DEMUXER (WSVQA, wsvqa);
     REGISTER_DEMUXER (WV, wv);
-#ifdef CONFIG_X11GRAB
     REGISTER_DEMUXER (X11_GRAB_DEVICE, x11_grab_device);
-#endif
     REGISTER_MUXDEMUX(YUV4MPEGPIPE, yuv4mpegpipe);
 
-#ifdef CONFIG_PROTOCOLS
-    /* file protocols */
-    register_protocol(&amp;file_protocol);
-    register_protocol(&amp;pipe_protocol);
-#ifdef CONFIG_NETWORK
-    register_protocol(&amp;udp_protocol);
-    register_protocol(&amp;rtp_protocol);
-    register_protocol(&amp;tcp_protocol);
-    register_protocol(&amp;http_protocol);
-#endif
-#endif
+    REGISTER_PROTOCOL(FILE, file);
+    REGISTER_PROTOCOL(HTTP, http);
+    REGISTER_PROTOCOL(PIPE, pipe);
+    REGISTER_PROTOCOL(RTP, rtp);
+    REGISTER_PROTOCOL(TCP, tcp);
+    REGISTER_PROTOCOL(UDP, udp);
 }

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/allformats.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/allformats.h	2007-07-16 16:39:52 UTC (rev 3382)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/allformats.h	2007-07-16 17:44:22 UTC (rev 3383)
@@ -22,150 +22,164 @@
 #ifndef ALLFORMATS_H
 #define ALLFORMATS_H
 
-extern AVInputFormat fourxm_demuxer;
-extern AVOutputFormat adts_muxer;
+#include &quot;avformat.h&quot;
+
+extern AVInputFormat aac_demuxer;
+extern AVInputFormat ac3_demuxer;
 extern AVInputFormat aiff_demuxer;
-extern AVOutputFormat aiff_muxer;
 extern AVInputFormat amr_demuxer;
-extern AVOutputFormat amr_muxer;
+extern AVInputFormat apc_demuxer;
 extern AVInputFormat asf_demuxer;
-extern AVOutputFormat asf_muxer;
-extern AVOutputFormat asf_stream_muxer;
 extern AVInputFormat au_demuxer;
-extern AVOutputFormat au_muxer;
 extern AVInputFormat audio_demuxer;
-extern AVOutputFormat audio_muxer;
 extern AVInputFormat avi_demuxer;
-extern AVOutputFormat avi_muxer;
 extern AVInputFormat avisynth_demuxer;
 extern AVInputFormat avs_demuxer;
-extern AVOutputFormat crc_muxer;
-extern AVOutputFormat framecrc_muxer;
+extern AVInputFormat bethsoftvid_demuxer;
+extern AVInputFormat c93_demuxer;
 extern AVInputFormat daud_demuxer;
 extern AVInputFormat dc1394_demuxer;
 extern AVInputFormat dsicin_demuxer;
+extern AVInputFormat dts_demuxer;
 extern AVInputFormat dv1394_demuxer;
 extern AVInputFormat dv_demuxer;
-extern AVOutputFormat dv_muxer;
+extern AVInputFormat dxa_demuxer;
 extern AVInputFormat ea_demuxer;
 extern AVInputFormat ffm_demuxer;
-extern AVOutputFormat ffm_muxer;
+extern AVInputFormat flac_demuxer;
 extern AVInputFormat flic_demuxer;
 extern AVInputFormat flv_demuxer;
-extern AVOutputFormat flv_muxer;
-extern AVOutputFormat gif_muxer;
+extern AVInputFormat fourxm_demuxer;
 extern AVInputFormat gif_demuxer;
-extern AVInputFormat video_grab_device_demuxer;
 extern AVInputFormat gxf_demuxer;
-extern AVOutputFormat gxf_muxer;
+extern AVInputFormat h261_demuxer;
+extern AVInputFormat h263_demuxer;
+extern AVInputFormat h264_demuxer;
 extern AVInputFormat idcin_demuxer;
-extern AVInputFormat roq_demuxer;
 extern AVInputFormat image2_demuxer;
 extern AVInputFormat image2pipe_demuxer;
-extern AVOutputFormat image2_muxer;
-extern AVOutputFormat image2pipe_muxer;
 extern AVInputFormat image_demuxer;
 extern AVInputFormat imagepipe_demuxer;
-extern AVOutputFormat image_muxer;
-extern AVOutputFormat imagepipe_muxer;
+extern AVInputFormat ingenient_demuxer;
 extern AVInputFormat ipmovie_demuxer;
+extern AVInputFormat libnut_demuxer;
+extern AVInputFormat m4v_demuxer;
 extern AVInputFormat matroska_demuxer;
+extern AVInputFormat mjpeg_demuxer;
 extern AVInputFormat mm_demuxer;
 extern AVInputFormat mmf_demuxer;
-extern AVOutputFormat mmf_muxer;
 extern AVInputFormat mov_demuxer;
-extern AVOutputFormat mov_muxer;
-extern AVOutputFormat tgp_muxer;
-extern AVOutputFormat mp4_muxer;
-extern AVOutputFormat psp_muxer;
-extern AVOutputFormat tg2_muxer;
 extern AVInputFormat mp3_demuxer;
-extern AVOutputFormat mp2_muxer;
-extern AVOutputFormat mp3_muxer;
 extern AVInputFormat mpc_demuxer;
-extern AVOutputFormat mpeg1system_muxer;
-extern AVOutputFormat mpeg1vcd_muxer;
-extern AVOutputFormat mpeg2vob_muxer;
-extern AVOutputFormat mpeg2svcd_muxer;
-extern AVOutputFormat mpeg2dvd_muxer;
 extern AVInputFormat mpegps_demuxer;
 extern AVInputFormat mpegts_demuxer;
-extern AVOutputFormat mpegts_muxer;
-extern AVOutputFormat mpjpeg_muxer;
+extern AVInputFormat mpegtsraw_demuxer;
+extern AVInputFormat mpegvideo_demuxer;
 extern AVInputFormat mtv_demuxer;
 extern AVInputFormat mxf_demuxer;
 extern AVInputFormat nsv_demuxer;
 extern AVInputFormat nut_demuxer;
-extern AVOutputFormat nut_muxer;
 extern AVInputFormat nuv_demuxer;
 extern AVInputFormat ogg_demuxer;
-extern AVOutputFormat ogg_muxer;
-extern AVInputFormat str_demuxer;
-extern AVInputFormat shorten_demuxer;
-extern AVInputFormat flac_demuxer;
-extern AVOutputFormat flac_muxer;
-extern AVInputFormat ac3_demuxer;
-extern AVOutputFormat ac3_muxer;
-extern AVInputFormat dts_demuxer;
-extern AVInputFormat aac_demuxer;
-extern AVInputFormat h261_demuxer;
-extern AVOutputFormat h261_muxer;
-extern AVInputFormat h263_demuxer;
-extern AVOutputFormat h263_muxer;
-extern AVInputFormat m4v_demuxer;
-extern AVOutputFormat m4v_muxer;
-extern AVInputFormat h264_demuxer;
-extern AVOutputFormat h264_muxer;
-extern AVInputFormat mpegvideo_demuxer;
-extern AVOutputFormat mpeg1video_muxer;
-extern AVOutputFormat mpeg2video_muxer;
-extern AVInputFormat mjpeg_demuxer;
-extern AVInputFormat ingenient_demuxer;
-extern AVOutputFormat mjpeg_muxer;
+extern AVInputFormat pcm_alaw_demuxer;
+extern AVInputFormat pcm_mulaw_demuxer;
+extern AVInputFormat pcm_s16be_demuxer;
 extern AVInputFormat pcm_s16le_demuxer;
-extern AVOutputFormat pcm_s16le_muxer;
-extern AVInputFormat pcm_s16be_demuxer;
-extern AVOutputFormat pcm_s16be_muxer;
+extern AVInputFormat pcm_s8_demuxer;
+extern AVInputFormat pcm_u16be_demuxer;
 extern AVInputFormat pcm_u16le_demuxer;
-extern AVOutputFormat pcm_u16le_muxer;
-extern AVInputFormat pcm_u16be_demuxer;
-extern AVOutputFormat pcm_u16be_muxer;
-extern AVInputFormat pcm_s8_demuxer;
-extern AVOutputFormat pcm_s8_muxer;
 extern AVInputFormat pcm_u8_demuxer;
-extern AVOutputFormat pcm_u8_muxer;
-extern AVInputFormat pcm_mulaw_demuxer;
-extern AVOutputFormat pcm_mulaw_muxer;
-extern AVInputFormat pcm_alaw_demuxer;
-extern AVOutputFormat pcm_alaw_muxer;
 extern AVInputFormat rawvideo_demuxer;
-extern AVOutputFormat rawvideo_muxer;
-extern AVOutputFormat null_muxer;
+extern AVInputFormat redir_demuxer;
 extern AVInputFormat rm_demuxer;
-extern AVOutputFormat rm_muxer;
+extern AVInputFormat roq_demuxer;
 extern AVInputFormat sdp_demuxer;
-extern AVInputFormat redir_demuxer;
 extern AVInputFormat segafilm_demuxer;
-extern AVInputFormat vmd_demuxer;
+extern AVInputFormat shorten_demuxer;
 extern AVInputFormat smacker_demuxer;
 extern AVInputFormat sol_demuxer;
+extern AVInputFormat str_demuxer;
 extern AVInputFormat swf_demuxer;
-extern AVOutputFormat swf_muxer;
+extern AVInputFormat thp_demuxer;
+extern AVInputFormat tiertexseq_demuxer;
 extern AVInputFormat tta_demuxer;
+extern AVInputFormat txd_demuxer;
 extern AVInputFormat v4l2_demuxer;
+extern AVInputFormat vc1_demuxer;
+extern AVInputFormat video_grab_bktr_demuxer;
+extern AVInputFormat video_grab_v4l_demuxer;
+extern AVInputFormat vmd_demuxer;
 extern AVInputFormat voc_demuxer;
-extern AVOutputFormat voc_muxer;
 extern AVInputFormat wav_demuxer;
-extern AVOutputFormat wav_muxer;
 extern AVInputFormat wc3_demuxer;
 extern AVInputFormat wsaud_demuxer;
 extern AVInputFormat wsvqa_demuxer;
 extern AVInputFormat wv_demuxer;
-extern AVOutputFormat yuv4mpegpipe_muxer;
+extern AVInputFormat x11_grab_device_demuxer;
 extern AVInputFormat yuv4mpegpipe_demuxer;
-extern AVInputFormat tiertexseq_demuxer;
-extern AVInputFormat x11_grab_device_demuxer;
 
+extern AVOutputFormat ac3_muxer;
+extern AVOutputFormat adts_muxer;
+extern AVOutputFormat aiff_muxer;
+extern AVOutputFormat amr_muxer;
+extern AVOutputFormat asf_muxer;
+extern AVOutputFormat asf_stream_muxer;
+extern AVOutputFormat au_muxer;
+extern AVOutputFormat audio_muxer;
+extern AVOutputFormat avi_muxer;
+extern AVOutputFormat crc_muxer;
+extern AVOutputFormat dv_muxer;
+extern AVOutputFormat ffm_muxer;
+extern AVOutputFormat flac_muxer;
+extern AVOutputFormat flv_muxer;
+extern AVOutputFormat framecrc_muxer;
+extern AVOutputFormat gif_muxer;
+extern AVOutputFormat gxf_muxer;
+extern AVOutputFormat h261_muxer;
+extern AVOutputFormat h263_muxer;
+extern AVOutputFormat h264_muxer;
+extern AVOutputFormat image2_muxer;
+extern AVOutputFormat image2pipe_muxer;
+extern AVOutputFormat image_muxer;
+extern AVOutputFormat imagepipe_muxer;
+extern AVOutputFormat libnut_muxer;
+extern AVOutputFormat m4v_muxer;
+extern AVOutputFormat mjpeg_muxer;
+extern AVOutputFormat mmf_muxer;
+extern AVOutputFormat mov_muxer;
+extern AVOutputFormat mp2_muxer;
+extern AVOutputFormat mp3_muxer;
+extern AVOutputFormat mp4_muxer;
+extern AVOutputFormat mpeg1system_muxer;
+extern AVOutputFormat mpeg1vcd_muxer;
+extern AVOutputFormat mpeg1video_muxer;
+extern AVOutputFormat mpeg2dvd_muxer;
+extern AVOutputFormat mpeg2svcd_muxer;
+extern AVOutputFormat mpeg2video_muxer;
+extern AVOutputFormat mpeg2vob_muxer;
+extern AVOutputFormat mpegts_muxer;
+extern AVOutputFormat mpjpeg_muxer;
+extern AVOutputFormat null_muxer;
+extern AVOutputFormat ogg_muxer;
+extern AVOutputFormat pcm_alaw_muxer;
+extern AVOutputFormat pcm_mulaw_muxer;
+extern AVOutputFormat pcm_s16be_muxer;
+extern AVOutputFormat pcm_s16le_muxer;
+extern AVOutputFormat pcm_s8_muxer;
+extern AVOutputFormat pcm_u16be_muxer;
+extern AVOutputFormat pcm_u16le_muxer;
+extern AVOutputFormat pcm_u8_muxer;
+extern AVOutputFormat psp_muxer;
+extern AVOutputFormat rawvideo_muxer;
+extern AVOutputFormat rm_muxer;
+extern AVOutputFormat roq_muxer;
+extern AVOutputFormat swf_muxer;
+extern AVOutputFormat tg2_muxer;
+extern AVOutputFormat tgp_muxer;
+extern AVOutputFormat voc_muxer;
+extern AVOutputFormat wav_muxer;
+extern AVOutputFormat yuv4mpegpipe_muxer;
+
 /* raw.c */
 int pcm_read_seek(AVFormatContext *s,
                   int stream_index, int64_t timestamp, int flags);
@@ -173,6 +187,6 @@
 /* rtsp.c */
 int redir_open(AVFormatContext **ic_ptr, ByteIOContext *f);
 /* rtp.c */
-void av_register_rtp_dynamic_payload_handlers();
+void av_register_rtp_dynamic_payload_handlers(void);
 
 #endif

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/avformat.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/avformat.h	2007-07-16 16:39:52 UTC (rev 3382)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/avformat.h	2007-07-16 17:44:22 UTC (rev 3383)
@@ -21,12 +21,8 @@
 #ifndef AVFORMAT_H
 #define AVFORMAT_H
 
-#ifdef __cplusplus
-extern &quot;C&quot; {
-#endif
-
-#define LIBAVFORMAT_VERSION_INT ((51&lt;&lt;16)+(8&lt;&lt;8)+0)
-#define LIBAVFORMAT_VERSION     51.8.0
+#define LIBAVFORMAT_VERSION_INT ((51&lt;&lt;16)+(12&lt;&lt;8)+1)
+#define LIBAVFORMAT_VERSION     51.12.1
 #define LIBAVFORMAT_BUILD       LIBAVFORMAT_VERSION_INT
 
 #define LIBAVFORMAT_IDENT       &quot;Lavf&quot; AV_STRINGIFY(LIBAVFORMAT_VERSION)
@@ -54,22 +50,41 @@
 #define PKT_FLAG_KEY   0x0001
 
 void av_destruct_packet_nofree(AVPacket *pkt);
+
+/**
+ * Default packet destructor.
+ */
 void av_destruct_packet(AVPacket *pkt);
 
-/* initialize optional fields of a packet */
-static inline void av_init_packet(AVPacket *pkt)
-{
-    pkt-&gt;pts   = AV_NOPTS_VALUE;
-    pkt-&gt;dts   = AV_NOPTS_VALUE;
-    pkt-&gt;pos   = -1;
-    pkt-&gt;duration = 0;
-    pkt-&gt;flags = 0;
-    pkt-&gt;stream_index = 0;
-    pkt-&gt;destruct= av_destruct_packet_nofree;
-}
+/**
+ * Initialize optional fields of a packet to default values.
+ *
+ * @param pkt packet
+ */
+void av_init_packet(AVPacket *pkt);
 
+/**
+ * Allocate the payload of a packet and initialize its fields to default values.
+ *
+ * @param pkt packet
+ * @param size wanted payload size
+ * @return 0 if OK. AVERROR_xxx otherwise.
+ */
 int av_new_packet(AVPacket *pkt, int size);
+
+/**
+ * Allocate and read the payload of a packet and initialize its fields to default values.
+ *
+ * @param pkt packet
+ * @param size wanted payload size
+ * @return &gt;0 (read size) if OK. AVERROR_xxx otherwise.
+ */
 int av_get_packet(ByteIOContext *s, AVPacket *pkt, int size);
+
+/**
+ * @warning This is a hack - the packet memory allocation stuff is broken. The
+ * packet is allocated if it was not really allocated
+ */
 int av_dup_packet(AVPacket *pkt);
 
 /**
@@ -87,8 +102,11 @@
 /*************************************************/
 /* fractional numbers for exact pts handling */
 
-/* the exact value of the fractional number is: 'val + num / den'. num
-   is assumed to be such as 0 &lt;= num &lt; den */
+/**
+ * the exact value of the fractional number is: 'val + num / den'.
+ * num is assumed to be such as 0 &lt;= num &lt; den
+ * @deprecated Use AVRational instead
+*/
 typedef struct AVFrac {
     int64_t val, num, den;
 } AVFrac attribute_deprecated;
@@ -100,7 +118,7 @@
 
 struct AVFormatContext;
 
-/* this structure contains the data a format has to probe a file */
+/** this structure contains the data a format has to probe a file */
 typedef struct AVProbeData {
     const char *filename;
     unsigned char *buf;
@@ -108,6 +126,7 @@
 } AVProbeData;
 
 #define AVPROBE_SCORE_MAX 100               ///&lt; max score, half of that is used for file extension based detection
+#define AVPROBE_PADDING_SIZE 32             ///&lt; extra allocated bytes at the end of the probe buffer
 
 typedef struct AVFormatParameters {
     AVRational time_base;
@@ -116,14 +135,16 @@
     int width;
     int height;
     enum PixelFormat pix_fmt;
-    int channel; /* used to select dv channel */
-    const char *device; /* video, audio or DV device */
-    const char *standard; /* tv standard, NTSC, PAL, SECAM */
-    int mpeg2ts_raw:1;  /* force raw MPEG2 transport stream output, if possible */
-    int mpeg2ts_compute_pcr:1; /* compute exact PCR for each transport
+    int channel; /**&lt; used to select dv channel */
+#if LIBAVFORMAT_VERSION_INT &lt; (52&lt;&lt;16)
+    const char *device; /**&lt; video, audio or DV device */
+#endif
+    const char *standard; /**&lt; tv standard, NTSC, PAL, SECAM */
+    int mpeg2ts_raw:1;  /**&lt; force raw MPEG2 transport stream output, if possible */
+    int mpeg2ts_compute_pcr:1; /**&lt; compute exact PCR for each transport
                                   stream packet (only meaningful if
-                                  mpeg2ts_raw is TRUE */
-    int initial_pause:1;       /* do not begin to play the stream
+                                  mpeg2ts_raw is TRUE) */
+    int initial_pause:1;       /**&lt; do not begin to play the stream
                                   immediately (RTSP only) */
     int prealloced_context:1;
     enum CodecID video_codec_id;
@@ -132,29 +153,30 @@
 
 //! demuxer will use url_fopen, no opened file should be provided by the caller
 #define AVFMT_NOFILE        0x0001
-#define AVFMT_NEEDNUMBER    0x0002 /* needs '%d' in filename */
-#define AVFMT_SHOW_IDS      0x0008 /* show format stream IDs numbers */
-#define AVFMT_RAWPICTURE    0x0020 /* format wants AVPicture structure for
+#define AVFMT_NEEDNUMBER    0x0002 /**&lt; needs '%d' in filename */
+#define AVFMT_SHOW_IDS      0x0008 /**&lt; show format stream IDs numbers */
+#define AVFMT_RAWPICTURE    0x0020 /**&lt; format wants AVPicture structure for
                                       raw picture data */
-#define AVFMT_GLOBALHEADER  0x0040 /* format wants global header */
-#define AVFMT_NOTIMESTAMPS  0x0080 /* format doesnt need / has any timestamps */
+#define AVFMT_GLOBALHEADER  0x0040 /**&lt; format wants global header */
+#define AVFMT_NOTIMESTAMPS  0x0080 /**&lt; format does not need / have any timestamps */
+#define AVFMT_GENERIC_INDEX 0x0100 /**&lt; use generic index building code */
 
 typedef struct AVOutputFormat {
     const char *name;
     const char *long_name;
     const char *mime_type;
-    const char *extensions; /* comma separated extensions */
-    /* size of private data so that it can be allocated in the wrapper */
+    const char *extensions; /**&lt; comma separated filename extensions */
+    /** size of private data so that it can be allocated in the wrapper */
     int priv_data_size;
     /* output support */
-    enum CodecID audio_codec; /* default audio codec */
-    enum CodecID video_codec; /* default video codec */
+    enum CodecID audio_codec; /**&lt; default audio codec */
+    enum CodecID video_codec; /**&lt; default video codec */
     int (*write_header)(struct AVFormatContext *);
     int (*write_packet)(struct AVFormatContext *, AVPacket *pkt);
     int (*write_trailer)(struct AVFormatContext *);
-    /* can use flags: AVFMT_NOFILE, AVFMT_NEEDNUMBER, AVFMT_GLOBALHEADER */
+    /** can use flags: AVFMT_NOFILE, AVFMT_NEEDNUMBER, AVFMT_GLOBALHEADER */
     int flags;
-    /* currently only used to set pixel format if not YUV420P */
+    /** currently only used to set pixel format if not YUV420P */
     int (*set_parameters)(struct AVFormatContext *, AVFormatParameters *);
     int (*interleave_packet)(struct AVFormatContext *, AVPacket *out, AVPacket *in, int flush);
 
@@ -162,7 +184,7 @@
      * list of supported codec_id-codec_tag pairs, ordered by &quot;better choice first&quot;
      * the arrays are all CODEC_ID_NONE terminated
      */
-    const struct AVCodecTag *codec_tag[4];
+    const struct AVCodecTag **codec_tag;
 
     /* private fields */
     struct AVOutputFormat *next;
@@ -171,21 +193,21 @@
 typedef struct AVInputFormat {
     const char *name;
     const char *long_name;
-    /* size of private data so that it can be allocated in the wrapper */
+    /** size of private data so that it can be allocated in the wrapper */
     int priv_data_size;
-    /* tell if a given file has a chance of being parsing by this format */
+    /** tell if a given file has a chance of being parsed by this format */
     int (*read_probe)(AVProbeData *);
-    /* read the format header and initialize the AVFormatContext
+    /** read the format header and initialize the AVFormatContext
        structure. Return 0 if OK. 'ap' if non NULL contains
-       additionnal paramters. Only used in raw format right
+       additional paramters. Only used in raw format right
        now. 'av_new_stream' should be called to create new streams.  */
     int (*read_header)(struct AVFormatContext *,
                        AVFormatParameters *ap);
-    /* read one packet and put it in 'pkt'. pts and flags are also
+    /** read one packet and put it in 'pkt'. pts and flags are also
        set. 'av_new_stream' can be called only if the flag
        AVFMTCTX_NOHEADER is used. */
     int (*read_packet)(struct AVFormatContext *, AVPacket *pkt);
-    /* close the stream. The AVFormatContext and AVStreams are not
+    /** close the stream. The AVFormatContext and AVStreams are not
        freed by this function */
     int (*read_close)(struct AVFormatContext *);
     /**
@@ -194,6 +216,7 @@
      * @param stream_index must not be -1
      * @param flags selects which direction should be preferred if no exact
      *              match is available
+     * @return &gt;= 0 on success (but not necessarily the new offset)
      */
     int (*read_seek)(struct AVFormatContext *,
                      int stream_index, int64_t timestamp, int flags);
@@ -202,57 +225,66 @@
      */
     int64_t (*read_timestamp)(struct AVFormatContext *s, int stream_index,
                               int64_t *pos, int64_t pos_limit);
-    /* can use flags: AVFMT_NOFILE, AVFMT_NEEDNUMBER */
+    /** can use flags: AVFMT_NOFILE, AVFMT_NEEDNUMBER */
     int flags;
-    /* if extensions are defined, then no probe is done. You should
+    /** if extensions are defined, then no probe is done. You should
        usually not use extension format guessing because it is not
        reliable enough */
     const char *extensions;
-    /* general purpose read only value that the format can use */
+    /** general purpose read only value that the format can use */
     int value;
 
-    /* start/resume playing - only meaningful if using a network based format
+    /** start/resume playing - only meaningful if using a network based format
        (RTSP) */
     int (*read_play)(struct AVFormatContext *);
 
-    /* pause playing - only meaningful if using a network based format
+    /** pause playing - only meaningful if using a network based format
        (RTSP) */
     int (*read_pause)(struct AVFormatContext *);
 
-    const struct AVCodecTag *codec_tag[4];
+    const struct AVCodecTag **codec_tag;
 
     /* private fields */
     struct AVInputFormat *next;
 } AVInputFormat;
 
+enum AVStreamParseType {
+    AVSTREAM_PARSE_NONE,
+    AVSTREAM_PARSE_FULL,       /**&lt; full parsing and repack */
+    AVSTREAM_PARSE_HEADERS,    /**&lt; only parse headers, don't repack */
+    AVSTREAM_PARSE_TIMESTAMPS, /**&lt; full parsing and interpolation of timestamps for frames not starting on packet boundary */
+};
+
 typedef struct AVIndexEntry {
     int64_t pos;
     int64_t timestamp;
 #define AVINDEX_KEYFRAME 0x0001
     int flags:2;
-    int size:30; //yeah trying to keep the size of this small to reduce memory requirements (its 24 vs 32 byte due to possible 8byte align)
-    int min_distance;         /* min distance between this and the previous keyframe, used to avoid unneeded searching */
+    int size:30; //Yeah, trying to keep the size of this small to reduce memory requirements (it is 24 vs 32 byte due to possible 8byte align).
+    int min_distance;         /**&lt; min distance between this and the previous keyframe, used to avoid unneeded searching */
 } AVIndexEntry;
 
 typedef struct AVStream {
-    int index;    /* stream index in AVFormatContext */
-    int id;       /* format specific stream id */
-    AVCodecContext *codec; /* codec context */
+    int index;    /**&lt; stream index in AVFormatContext */
+    int id;       /**&lt; format specific stream id */
+    AVCodecContext *codec; /**&lt; codec context */
     /**
      * real base frame rate of the stream.
      * this is the lowest framerate with which all timestamps can be
-     * represented accurately (its the least common multiple of all
+     * represented accurately (it is the least common multiple of all
      * framerates in the stream), Note, this value is just a guess!
      * for example if the timebase is 1/90000 and all frames have either
      * approximately 3600 or 1800 timer ticks then r_frame_rate will be 50/1
      */
     AVRational r_frame_rate;
     void *priv_data;
+#if LIBAVFORMAT_VERSION_INT &lt; (52&lt;&lt;16)
     /* internal data used in av_find_stream_info() */
     int64_t codec_info_duration;
     int codec_info_nb_frames;
-    /* encoding: PTS generation when outputing stream */
-    AVFrac pts;
+#endif
+    /** encoding: PTS generation when outputing stream */
+    struct AVFrac pts;
 
     /**
      * this is the fundamental unit of time (in seconds) in terms
@@ -261,32 +293,30 @@
      * identically 1.
      */
     AVRational time_base;
-    int pts_wrap_bits; /* number of bits in pts (used for wrapping control) */
+    int pts_wrap_bits; /**&lt; number of bits in pts (used for wrapping control) */
     /* ffmpeg.c private use */
-    int stream_copy; /* if TRUE, just copy stream */
-    enum AVDiscard discard; ///&lt; selects which packets can be discarded at will and dont need to be demuxed
+    int stream_copy; /**&lt; if set, just copy stream */
+    enum AVDiscard discard; ///&lt; selects which packets can be discarded at will and do not need to be demuxed
     //FIXME move stuff to a flags field?
-    /* quality, as it has been removed from AVCodecContext and put in AVVideoFrame
-     * MN:dunno if thats the right place, for it */
+    /** quality, as it has been removed from AVCodecContext and put in AVVideoFrame
+     * MN: dunno if that is the right place for it */
     float quality;
-    /* decoding: position of the first frame of the component, in
-       AV_TIME_BASE fractional seconds. */
+    /** decoding: pts of the first frame of the stream, in stream time base. */
     int64_t start_time;
-    /* decoding: duration of the stream, in AV_TIME_BASE fractional
-       seconds. */
+    /** decoding: duration of the stream, in stream time base. */
     int64_t duration;
 
-    char language[4]; /* ISO 639 3-letter language code (empty string if undefined) */
+    char language[4]; /** ISO 639 3-letter language code (empty string if undefined) */
 
     /* av_read_frame() support */
-    int need_parsing;                  ///&lt; 1-&gt;full parsing needed, 2-&gt;only parse headers dont repack
+    enum AVStreamParseType need_parsing;
     struct AVCodecParserContext *parser;
 
     int64_t cur_dts;
     int last_IP_duration;
     int64_t last_IP_pts;
     /* av_seek_frame() support */
-    AVIndexEntry *index_entries; /* only used if the format does not
+    AVIndexEntry *index_entries; /**&lt; only used if the format does not
                                     support seeking natively */
     int nb_index_entries;
     unsigned int index_entries_allocated_size;
@@ -297,14 +327,14 @@
     int64_t pts_buffer[MAX_REORDER_DELAY+1];
 } AVStream;
 
-#define AVFMTCTX_NOHEADER      0x0001 /* signal that no header is present
+#define AVFMTCTX_NOHEADER      0x0001 /**&lt; signal that no header is present
                                          (streams are added dynamically) */
 
 #define MAX_STREAMS 20
 
 /* format I/O context */
 typedef struct AVFormatContext {
-    const AVClass *av_class; /* set by av_alloc_format_context */
+    const AVClass *av_class; /**&lt; set by av_alloc_format_context */
     /* can only be iformat or oformat, not both at the same time */
     struct AVInputFormat *iformat;
     struct AVOutputFormat *oformat;
@@ -312,7 +342,7 @@
     ByteIOContext pb;
     unsigned int nb_streams;
     AVStream *streams[MAX_STREAMS];
-    char filename[1024]; /* input or output filename */
+    char filename[1024]; /**&lt; input or output filename */
     /* stream info */
     int64_t timestamp;
     char title[512];
@@ -320,28 +350,28 @@
     char copyright[512];
     char comment[512];
     char album[512];
-    int year;  /* ID3 year, 0 if none */
-    int track; /* track number, 0 if none */
-    char genre[32]; /* ID3 genre */
+    int year;  /**&lt; ID3 year, 0 if none */
+    int track; /**&lt; track number, 0 if none */
+    char genre[32]; /**&lt; ID3 genre */
 
-    int ctx_flags; /* format specific flags, see AVFMTCTX_xx */
+    int ctx_flags; /**&lt; format specific flags, see AVFMTCTX_xx */
     /* private data for pts handling (do not modify directly) */
-    /* This buffer is only needed when packets were already buffered but
+    /** This buffer is only needed when packets were already buffered but
        not decoded, for example to get the codec parameters in mpeg
        streams */
     struct AVPacketList *packet_buffer;
 
-    /* decoding: position of the first frame of the component, in
+    /** decoding: position of the first frame of the component, in
        AV_TIME_BASE fractional seconds. NEVER set this value directly:
        it is deduced from the AVStream values.  */
     int64_t start_time;
-    /* decoding: duration of the stream, in AV_TIME_BASE fractional
+    /** decoding: duration of the stream, in AV_TIME_BASE fractional
        seconds. NEVER set this value directly: it is deduced from the
        AVStream values.  */
     int64_t duration;
-    /* decoding: total file size. 0 if unknown */
+    /** decoding: total file size. 0 if unknown */
     int64_t file_size;
-    /* decoding: total stream bitrate in bit/s, 0 if not
+    /** decoding: total stream bitrate in bit/s, 0 if not
        available. Never set it directly if the file_size and the
        duration are known as ffmpeg can compute it automatically. */
     int bit_rate;
@@ -353,7 +383,7 @@
     AVPacket cur_pkt;
 
     /* av_seek_frame() support */
-    int64_t data_offset; /* offset of the first packet */
+    int64_t data_offset; /** offset of the first packet */
     int index_built;
 
     int mux_rate;
@@ -363,16 +393,25 @@
 
 #define AVFMT_NOOUTPUTLOOP -1
 #define AVFMT_INFINITEOUTPUTLOOP 0
-    /* number of times to loop output in formats that support it */
+    /** number of times to loop output in formats that support it */
     int loop_output;
 
     int flags;
 #define AVFMT_FLAG_GENPTS       0x0001 ///&lt; generate pts if missing even if it requires parsing future frames
 #define AVFMT_FLAG_IGNIDX       0x0002 ///&lt; ignore index
+#define AVFMT_FLAG_NONBLOCK     0x0004 ///&lt; do not block when reading packets from input
 
     int loop_input;
-    /* decoding: size of data to probe; encoding unused */
+    /** decoding: size of data to probe; encoding unused */
     unsigned int probesize;
+
+    /**
+     * maximum duration in AV_TIME_BASE units over which the input should be analyzed in av_find_stream_info()
+     */
+    int max_analyze_duration;
+
+    const uint8_t *key;
+    int keylen;
 } AVFormatContext;
 
 typedef struct AVPacketList {
@@ -399,47 +438,207 @@
                                     const char *filename, const char *mime_type);
 AVOutputFormat *guess_format(const char *short_name,
                              const char *filename, const char *mime_type);
+
+/**
+ * Guesses the codec id based upon muxer and filename.
+ */
 enum CodecID av_guess_codec(AVOutputFormat *fmt, const char *short_name,
                             const char *filename, const char *mime_type, enum CodecType type);
 
+/**
+ * Send a nice hexadecimal dump of a buffer to the specified file stream.
+ *
+ * @param f The file stream pointer where the dump should be sent to.
+ * @param buf buffer
+ * @param size buffer size
+ *
+ * @see av_hex_dump_log, av_pkt_dump, av_pkt_dump_log
+ */
 void av_hex_dump(FILE *f, uint8_t *buf, int size);
+
+/**
+ * Send a nice hexadecimal dump of a buffer to the log.
+ *
+ * @param avcl A pointer to an arbitrary struct of which the first field is a
+ * pointer to an AVClass struct.
+ * @param level The importance level of the message, lower values signifying
+ * higher importance.
+ * @param buf buffer
+ * @param size buffer size
+ *
+ * @see av_hex_dump, av_pkt_dump, av_pkt_dump_log
+ */
+void av_hex_dump_log(void *avcl, int level, uint8_t *buf, int size);
+
+/**
+ * Send a nice dump of a packet to the specified file stream.
+ *
+ * @param f The file stream pointer where the dump should be sent to.
+ * @param pkt packet to dump
+ * @param dump_payload true if the payload must be displayed too
+ */
 void av_pkt_dump(FILE *f, AVPacket *pkt, int dump_payload);
 
+/**
+ * Send a nice dump of a packet to the log.
+ *
+ * @param avcl A pointer to an arbitrary struct of which the first field is a
+ * pointer to an AVClass struct.
+ * @param level The importance level of the message, lower values signifying
+ * higher importance.
+ * @param pkt packet to dump
+ * @param dump_payload true if the payload must be displayed too
+ */
+void av_pkt_dump_log(void *avcl, int level, AVPacket *pkt, int dump_payload);
+
 void av_register_all(void);
 
-/* codec tag &lt;-&gt; codec id */
-enum CodecID av_codec_get_id(const struct AVCodecTag *tags[4], unsigned int tag);
-unsigned int av_codec_get_tag(const struct AVCodecTag *tags[4], enum CodecID id);
+/** codec tag &lt;-&gt; codec id */
+enum CodecID av_codec_get_id(const struct AVCodecTag **tags, unsigned int tag);
+unsigned int av_codec_get_tag(const struct AVCodecTag **tags, enum CodecID id);
 
 /* media file input */
+
+/**
+ * finds AVInputFormat based on input format's short name.
+ */
 AVInputFormat *av_find_input_format(const char *short_name);
+
+/**
+ * Guess file format.
+ *
+ * @param is_opened whether the file is already opened, determines whether
+ *                  demuxers with or without AVFMT_NOFILE are probed
+ */
 AVInputFormat *av_probe_input_format(AVProbeData *pd, int is_opened);
+
+/**
+ * Allocates all the structures needed to read an input stream.
+ *        This does not open the needed codecs for decoding the stream[s].
+ */
 int av_open_input_stream(AVFormatContext **ic_ptr,
                          ByteIOContext *pb, const char *filename,
                          AVInputFormat *fmt, AVFormatParameters *ap);
+
+/**
+ * Open a media file as input. The codecs are not opened. Only the file
+ * header (if present) is read.
+ *
+ * @param ic_ptr the opened media file handle is put here
+ * @param filename filename to open.
+ * @param fmt if non NULL, force the file format to use
+ * @param buf_size optional buffer size (zero if default is OK)
+ * @param ap additional parameters needed when opening the file (NULL if default)
+ * @return 0 if OK. AVERROR_xxx otherwise.
+ */
 int av_open_input_file(AVFormatContext **ic_ptr, const char *filename,
                        AVInputFormat *fmt,
                        int buf_size,
                        AVFormatParameters *ap);
-/* no av_open for output, so applications will need this: */
+/** no av_open for output, so applications will need this: */
 AVFormatContext *av_alloc_format_context(void);
 
-#define AVERROR_UNKNOWN     (-1)  /* unknown error */
-#define AVERROR_IO          (-2)  /* i/o error */
-#define AVERROR_NUMEXPECTED (-3)  /* number syntax expected in filename */
-#define AVERROR_INVALIDDATA (-4)  /* invalid data found */
-#define AVERROR_NOMEM       (-5)  /* not enough memory */
-#define AVERROR_NOFMT       (-6)  /* unknown format */
-#define AVERROR_NOTSUPP     (-7)  /* operation not supported */
+/**
+ * Read packets of a media file to get stream information. This
+ * is useful for file formats with no headers such as MPEG. This
+ * function also computes the real frame rate in case of mpeg2 repeat
+ * frame mode.
+ * The logical file position is not changed by this function;
+ * examined packets may be buffered for later processing.
+ *
+ * @param ic media file handle
+ * @return &gt;=0 if OK. AVERROR_xxx if error.
+ * @todo Let user decide somehow what information is needed so we do not waste time geting stuff the user does not need.
+ */
+int av_find_stream_info(AVFormatContext *ic);
 
-int av_find_stream_info(AVFormatContext *ic);
+/**
+ * Read a transport packet from a media file.
+ *
+ * This function is obsolete and should never be used.
+ * Use av_read_frame() instead.
+ *
+ * @param s media file handle
+ * @param pkt is filled
+ * @return 0 if OK. AVERROR_xxx if error.
+ */
 int av_read_packet(AVFormatContext *s, AVPacket *pkt);
+
+/**
+ * Return the next frame of a stream.
+ *
+ * The returned packet is valid
+ * until the next av_read_frame() or until av_close_input_file() and
+ * must be freed with av_free_packet. For video, the packet contains
+ * exactly one frame. For audio, it contains an integer number of
+ * frames if each frame has a known fixed size (e.g. PCM or ADPCM
+ * data). If the audio frames have a variable size (e.g. MPEG audio),
+ * then it contains one frame.
+ *
+ * pkt-&gt;pts, pkt-&gt;dts and pkt-&gt;duration are always set to correct
+ * values in AVStream.timebase units (and guessed if the format cannot
+ * provided them). pkt-&gt;pts can be AV_NOPTS_VALUE if the video format
+ * has B frames, so it is better to rely on pkt-&gt;dts if you do not
+ * decompress the payload.
+ *
+ * @return 0 if OK, &lt; 0 if error or end of file.
+ */
 int av_read_frame(AVFormatContext *s, AVPacket *pkt);
+
+/**
+ * Seek to the key frame at timestamp.
+ * 'timestamp' in 'stream_index'.
+ * @param stream_index If stream_index is (-1), a default
+ * stream is selected, and timestamp is automatically converted
+ * from AV_TIME_BASE units to the stream specific time_base.
+ * @param timestamp timestamp in AVStream.time_base units
+ *        or if there is no stream specified then in AV_TIME_BASE units
+ * @param flags flags which select direction and seeking mode
+ * @return &gt;= 0 on success
+ */
 int av_seek_frame(AVFormatContext *s, int stream_index, int64_t timestamp, int flags);
+
+/**
+ * start playing a network based stream (e.g. RTSP stream) at the
+ * current position
+ */
 int av_read_play(AVFormatContext *s);
+
+/**
+ * Pause a network based stream (e.g. RTSP stream).
+ *
+ * Use av_read_play() to resume it.
+ */
 int av_read_pause(AVFormatContext *s);
+
+/**
+ * Close a media file (but not its codecs).
+ *
+ * @param s media file handle
+ */
 void av_close_input_file(AVFormatContext *s);
+
+/**
+ * Add a new stream to a media file.
+ *
+ * Can only be called in the read_header() function. If the flag
+ * AVFMTCTX_NOHEADER is in the format context, then new streams
+ * can be added in read_packet too.
+ *
+ * @param s media file handle
+ * @param id file format dependent stream id
+ */
 AVStream *av_new_stream(AVFormatContext *s, int id);
+
+/**
+ * Set the pts for a given stream.
+ *
+ * @param s stream
+ * @param pts_wrap_bits number of bits effectively used by the pts
+ *        (used for wrap control, 33 is the value for MPEG)
+ * @param pts_num numerator to convert to seconds (MPEG: 1)
+ * @param pts_den denominator to convert to seconds (MPEG: 90000)
+ */
 void av_set_pts_info(AVStream *s, int pts_wrap_bits,
                      int pts_num, int pts_den);
 
@@ -448,28 +647,149 @@
 #define AVSEEK_FLAG_ANY      4 ///&lt; seek to any frame, even non keyframes
 
 int av_find_default_stream_index(AVFormatContext *s);
+
+/**
+ * Gets the index for a specific timestamp.
+ * @param flags if AVSEEK_FLAG_BACKWARD then the returned index will correspond to
+ *                 the timestamp which is &lt;= the requested one, if backward is 0
+ *                 then it will be &gt;=
+ *              if AVSEEK_FLAG_ANY seek to any frame, only keyframes otherwise
+ * @return &lt; 0 if no such timestamp could be found
+ */
 int av_index_search_timestamp(AVStream *st, int64_t timestamp, int flags);
+
+/**
+ * Add a index entry into a sorted list updateing if it is already there.
+ *
+ * @param timestamp timestamp in the timebase of the given stream
+ */
 int av_add_index_entry(AVStream *st,
                        int64_t pos, int64_t timestamp, int size, int distance, int flags);
+
+/**
+ * Does a binary search using av_index_search_timestamp() and AVCodec.read_timestamp().
+ * This is not supposed to be called directly by a user application, but by demuxers.
+ * @param target_ts target timestamp in the time base of the given stream
+ * @param stream_index stream number
+ */
 int av_seek_frame_binary(AVFormatContext *s, int stream_index, int64_t target_ts, int flags);
+
+/**
+ * Updates cur_dts of all streams based on given timestamp and AVStream.
+ *
+ * Stream ref_st unchanged, others set cur_dts in their native timebase
+ * only needed for timestamp wrapping or if (dts not set and pts!=dts).
+ * @param timestamp new dts expressed in time_base of param ref_st
+ * @param ref_st reference stream giving time_base of param timestamp
+ */
 void av_update_cur_dts(AVFormatContext *s, AVStream *ref_st, int64_t timestamp);
+
+/**
+ * Does a binary search using read_timestamp().
+ * This is not supposed to be called directly by a user application, but by demuxers.
+ * @param target_ts target timestamp in the time base of the given stream
+ * @param stream_index stream number
+ */
 int64_t av_gen_search(AVFormatContext *s, int stream_index, int64_t target_ts, int64_t pos_min, int64_t pos_max, int64_t pos_limit, int64_t ts_min, int64_t ts_max, int flags, int64_t *ts_ret, int64_t (*read_timestamp)(struct AVFormatContext *, int , int64_t *, int64_t ));
 
-/* media file output */
+/** media file output */
 int av_set_parameters(AVFormatContext *s, AVFormatParameters *ap);
+
+/**
+ * Allocate the stream private data and write the stream header to an
+ * output media file.
+ *
+ * @param s media file handle
+ * @return 0 if OK. AVERROR_xxx if error.
+ */
 int av_write_header(AVFormatContext *s);
+
+/**
+ * Write a packet to an output media file.
+ *
+ * The packet shall contain one audio or video frame.
+ * The packet must be correctly interleaved according to the container specification,
+ * if not then av_interleaved_write_frame must be used
+ *
+ * @param s media file handle
+ * @param pkt the packet, which contains the stream_index, buf/buf_size, dts/pts, ...
+ * @return &lt; 0 if error, = 0 if OK, 1 if end of stream wanted.
+ */
 int av_write_frame(AVFormatContext *s, AVPacket *pkt);
+
+/**
+ * Writes a packet to an output media file ensuring correct interleaving.
+ *
+ * The packet must contain one audio or video frame.
+ * If the packets are already correctly interleaved the application should
+ * call av_write_frame() instead as it is slightly faster. It is also important
+ * to keep in mind that completely non-interleaved input will need huge amounts
+ * of memory to interleave with this, so it is preferable to interleave at the
+ * demuxer level.
+ *
+ * @param s media file handle
+ * @param pkt the packet, which contains the stream_index, buf/buf_size, dts/pts, ...
+ * @return &lt; 0 if error, = 0 if OK, 1 if end of stream wanted.
+ */
 int av_interleaved_write_frame(AVFormatContext *s, AVPacket *pkt);
+
+/**
+ * Interleave a packet per DTS in an output media file.
+ *
+ * Packets with pkt-&gt;destruct == av_destruct_packet will be freed inside this function,
+ * so they cannot be used after it, note calling av_free_packet() on them is still safe.
+ *
+ * @param s media file handle
+ * @param out the interleaved packet will be output here
+ * @param in the input packet
+ * @param flush 1 if no further packets are available as input and all
+ *              remaining packets should be output
+ * @return 1 if a packet was output, 0 if no packet could be output,
+ *         &lt; 0 if an error occured
+ */
 int av_interleave_packet_per_dts(AVFormatContext *s, AVPacket *out, AVPacket *pkt, int flush);
 
+/**
+ * @brief Write the stream trailer to an output media file and
+ *        free the file private data.
+ *
+ * @param s media file handle
+ * @return 0 if OK. AVERROR_xxx if error.
+ */
 int av_write_trailer(AVFormatContext *s);
 
 void dump_format(AVFormatContext *ic,
                  int index,
                  const char *url,
                  int is_output);
-int parse_image_size(int *width_ptr, int *height_ptr, const char *str);
-int parse_frame_rate(int *frame_rate, int *frame_rate_base, const char *arg);
+
+/**
+ * parses width and height out of string str.
+ * @deprecated Use av_parse_video_frame_size instead.
+ */
+attribute_deprecated int parse_image_size(int *width_ptr, int *height_ptr, const char *str);
+
+/**
+ * Converts frame rate from string to a fraction.
+ * @deprecated Use av_parse_video_frame_rate instead.
+ */
+attribute_deprecated int parse_frame_rate(int *frame_rate, int *frame_rate_base, const char *arg);
+
+/**
+ * Converts date string to number of seconds since Jan 1st, 1970.
+ *
+ * @code
+ * Syntax:
+ * - If not a duration:
+ *  [{YYYY-MM-DD|YYYYMMDD}]{T| }{HH[:MM[:SS[.m...]]][Z]|HH[MM[SS[.m...]]][Z]}
+ * Time is localtime unless Z is suffixed to the end. In this case GMT
+ * Return the date in micro seconds since 1970
+ *
+ * - If a duration:
+ *  HH[:MM[:SS[.m...]]]
+ *  S+[.m...]
+ * @endcode
+ */
 int64_t parse_date(const char *datestr, int duration);
 
 int64_t av_gettime(void);
@@ -480,29 +800,41 @@
 void ffm_write_write_index(int fd, offset_t pos);
 void ffm_set_write_index(AVFormatContext *s, offset_t pos, offset_t file_size);
 
+/**
+ * Attempts to find a specific tag in a URL.
+ *
+ * syntax: '?tag1=val1&amp;tag2=val2...'. Little URL decoding is done.
+ * Return 1 if found.
+ */
 int find_info_tag(char *arg, int arg_size, const char *tag1, const char *info);
 
+/**
+ * Returns in 'buf' the path with '%d' replaced by number.
+
+ * Also handles the '%0nd' format where 'n' is the total number
+ * of digits and '%%'.
+ *
+ * @param buf destination buffer
+ * @param buf_size destination buffer size
+ * @param path numbered sequence string
+ * @number frame number
+ * @return 0 if OK, -1 if format error.
+ */
 int av_get_frame_filename(char *buf, int buf_size,
                           const char *path, int number);
+
+/**
+ * Check whether filename actually is a numbered sequence generator.
+ *
+ * @param filename possible numbered sequence string
+ * @return 1 if a valid numbered sequence string, 0 otherwise.
+ */
 int av_filename_number_test(const char *filename);
 
-/* grab specific */
-int video_grab_init(void);
-int audio_init(void);
-
-/* DV1394 */
-int dv1394_init(void);
-int dc1394_init(void);
-
 #ifdef HAVE_AV_CONFIG_H
 
 #include &quot;os_support.h&quot;
 
-int strstart(const char *str, const char *val, const char **ptr);
-int stristart(const char *str, const char *val, const char **ptr);
-void pstrcpy(char *buf, int buf_size, const char *str);
-char *pstrcat(char *buf, int buf_size, const char *s);
-
 void __dynarray_add(unsigned long **tab_ptr, int *nb_ptr, unsigned long elem);
 
 #ifdef __GNUC__
@@ -539,9 +871,5 @@
 
 #endif /* HAVE_AV_CONFIG_H */
 
-#ifdef __cplusplus
-}
-#endif
-
 #endif /* AVFORMAT_H */
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/avienc.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/avienc.c	2007-07-16 16:39:52 UTC (rev 3382)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/avienc.c	2007-07-16 17:44:22 UTC (rev 3383)
@@ -197,11 +197,6 @@
 
         stream = s-&gt;streams[i]-&gt;codec;
 
-        /* FourCC should really be set by the codec itself */
-        if (! stream-&gt;codec_tag) {
-            stream-&gt;codec_tag = codec_get_bmp_tag(stream-&gt;codec_id);
-        }
-
         /* stream generic header */
         strh = start_tag(pb, &quot;strh&quot;);
         switch(stream-&gt;codec_type) {
@@ -575,6 +570,6 @@
     avi_write_header,
     avi_write_packet,
     avi_write_trailer,
-    .codec_tag= {codec_bmp_tags, codec_wav_tags},
+    .codec_tag= (const AVCodecTag*[]){codec_bmp_tags, codec_wav_tags, 0},
 };
 #endif //CONFIG_AVI_MUXER

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/avio.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/avio.c	2007-07-16 16:39:52 UTC (rev 3382)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/avio.c	2007-07-16 17:44:22 UTC (rev 3383)
@@ -19,6 +19,7 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 #include &quot;avformat.h&quot;
+#include &quot;avstring.h&quot;
 
 static int default_interrupt_cb(void);
 
@@ -67,12 +68,12 @@
             goto found;
         up = up-&gt;next;
     }
-    err = -ENOENT;
+    err = AVERROR(ENOENT);
     goto fail;
  found:
     uc = av_malloc(sizeof(URLContext) + strlen(filename) + 1);
     if (!uc) {
-        err = -ENOMEM;
+        err = AVERROR(ENOMEM);
         goto fail;
     }
 #if LIBAVFORMAT_VERSION_INT &gt;= (52&lt;&lt;16)
@@ -124,7 +125,7 @@
     offset_t ret;
 
     if (!h-&gt;prot-&gt;url_seek)
-        return -EPIPE;
+        return AVERROR(EPIPE);
     ret = h-&gt;prot-&gt;url_seek(h, pos, whence);
     return ret;
 }
@@ -154,20 +155,14 @@
     size= url_seek(h, 0, AVSEEK_SIZE);
     if(size&lt;0){
         pos = url_seek(h, 0, SEEK_CUR);
-        size = url_seek(h, -1, SEEK_END)+1;
+        if ((size = url_seek(h, -1, SEEK_END)) &lt; 0)
+            return size;
+        size++;
         url_seek(h, pos, SEEK_SET);
     }
     return size;
 }
 
-/*
- * Return the maximum packet size associated to packetized file
- * handle. If the file is not packetized (stream like http or file on
- * disk), then 0 is returned.
- *
- * @param h file handle
- * @return maximum packet size in bytes
- */
 int url_get_max_packet_size(URLContext *h)
 {
     return h-&gt;max_packet_size;
@@ -175,7 +170,7 @@
 
 void url_get_filename(URLContext *h, char *buf, int buf_size)
 {
-    pstrcpy(buf, buf_size, h-&gt;filename);
+    av_strlcpy(buf, h-&gt;filename, buf_size);
 }
 
 
@@ -184,12 +179,6 @@
     return 0;
 }
 
-/**
- * The callback is called in blocking functions to test regulary if
- * asynchronous interruption is needed. -EINTR is returned in this
- * case by the interrupted function. 'NULL' means no interrupt
- * callback is given.
- */
 void url_set_interrupt_cb(URLInterruptCB *interrupt_cb)
 {
     if (!interrupt_cb)

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/avio.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/avio.h	2007-07-16 16:39:52 UTC (rev 3382)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/avio.h	2007-07-16 17:44:22 UTC (rev 3383)
@@ -21,6 +21,8 @@
 #ifndef AVIO_H
 #define AVIO_H
 
+#include &lt;stdint.h&gt;
+
 /* output byte stream handling */
 
 typedef int64_t offset_t;
@@ -30,13 +32,13 @@
 struct URLContext {
     struct URLProtocol *prot;
     int flags;
-    int is_streamed;  /* true if streamed (no seek possible), default = false */
-    int max_packet_size;  /* if non zero, the stream is packetized with this max packet size */
+    int is_streamed;  /**&lt; true if streamed (no seek possible), default = false */
+    int max_packet_size;  /**&lt; if non zero, the stream is packetized with this max packet size */
     void *priv_data;
 #if LIBAVFORMAT_VERSION_INT &gt;= (52&lt;&lt;16)
-    char *filename; /* specified filename */
+    char *filename; /**&lt; specified filename */
 #else
-    char filename[1]; /* specified filename */
+    char filename[1]; /**&lt; specified filename */
 #endif
 };
 
@@ -61,22 +63,33 @@
 int url_close(URLContext *h);
 int url_exist(const char *filename);
 offset_t url_filesize(URLContext *h);
+
+/**
+ * Return the maximum packet size associated to packetized file
+ * handle. If the file is not packetized (stream like http or file on
+ * disk), then 0 is returned.
+ *
+ * @param h file handle
+ * @return maximum packet size in bytes
+ */
 int url_get_max_packet_size(URLContext *h);
 void url_get_filename(URLContext *h, char *buf, int buf_size);
 
-/* the callback is called in blocking functions to test regulary if
-   asynchronous interruption is needed. -EINTR is returned in this
-   case by the interrupted function. 'NULL' means no interrupt
-   callback is given. */
+/**
+ * the callback is called in blocking functions to test regulary if
+ * asynchronous interruption is needed. AVERROR(EINTR) is returned
+ * in this case by the interrupted function. 'NULL' means no interrupt
+ * callback is given. i
+ */
 void url_set_interrupt_cb(URLInterruptCB *interrupt_cb);
 
 /* not implemented */
 int url_poll(URLPollEntry *poll_table, int n, int timeout);
 
 /**
- * passing this as the &quot;whence&quot; parameter to a seek function causes it to
- * return the filesize without seeking anywhere, supporting this is optional
- * if its not supprted then the seek function will return &lt;0
+ * Passing this as the &quot;whence&quot; parameter to a seek function causes it to
+ * return the filesize without seeking anywhere. Supporting this is optional.
+ * If it is not supported then the seek function will return &lt;0.
  */
 #define AVSEEK_SIZE 0x10000
 
@@ -103,10 +116,10 @@
     int (*read_packet)(void *opaque, uint8_t *buf, int buf_size);
     int (*write_packet)(void *opaque, uint8_t *buf, int buf_size);
     offset_t (*seek)(void *opaque, offset_t offset, int whence);
-    offset_t pos; /* position in the file of the current buffer */
-    int must_flush; /* true if the next seek should flush */
-    int eof_reached; /* true if eof reached */
-    int write_flag;  /* true if open for writing */
+    offset_t pos; /**&lt; position in the file of the current buffer */
+    int must_flush; /**&lt; true if the next seek should flush */
+    int eof_reached; /**&lt; true if eof reached */
+    int write_flag;  /**&lt; true if open for writing */
     int is_streamed;
     int max_packet_size;
     unsigned long checksum;
@@ -146,18 +159,27 @@
 int url_ferror(ByteIOContext *s);
 
 #define URL_EOF (-1)
+/** @note return URL_EOF (-1) if EOF */
 int url_fgetc(ByteIOContext *s);
+
+/** @warning currently size is limited */
 #ifdef __GNUC__
 int url_fprintf(ByteIOContext *s, const char *fmt, ...) __attribute__ ((__format__ (__printf__, 2, 3)));
 #else
 int url_fprintf(ByteIOContext *s, const char *fmt, ...);
 #endif
+
+/** @note unlike fgets, the EOL character is not returned and a whole
+   line is parsed. return NULL if first char read was EOF */
 char *url_fgets(ByteIOContext *s, char *buf, int buf_size);
 
 void put_flush_packet(ByteIOContext *s);
 
 int get_buffer(ByteIOContext *s, unsigned char *buf, int size);
 int get_partial_buffer(ByteIOContext *s, unsigned char *buf, int size);
+
+/** @note return 0 if EOF, so you cannot use it if EOF handling is
+   necessary */
 int get_byte(ByteIOContext *s);
 unsigned int get_le24(ByteIOContext *s);
 unsigned int get_le32(ByteIOContext *s);
@@ -176,17 +198,57 @@
 }
 
 int url_fdopen(ByteIOContext *s, URLContext *h);
+
+/** @warning must be called before any I/O */
 int url_setbufsize(ByteIOContext *s, int buf_size);
+
+/** @note when opened as read/write, the buffers are only used for
+   reading */
 int url_fopen(ByteIOContext *s, const char *filename, int flags);
 int url_fclose(ByteIOContext *s);
 URLContext *url_fileno(ByteIOContext *s);
+
+/**
+ * Return the maximum packet size associated to packetized buffered file
+ * handle. If the file is not packetized (stream like http or file on
+ * disk), then 0 is returned.
+ *
+ * @param h buffered file handle
+ * @return maximum packet size in bytes
+ */
 int url_fget_max_packet_size(ByteIOContext *s);
 
 int url_open_buf(ByteIOContext *s, uint8_t *buf, int buf_size, int flags);
+
+/** return the written or read size */
 int url_close_buf(ByteIOContext *s);
 
+/**
+ * Open a write only memory stream.
+ *
+ * @param s new IO context
+ * @return zero if no error.
+ */
 int url_open_dyn_buf(ByteIOContext *s);
+
+/**
+ * Open a write only packetized memory stream with a maximum packet
+ * size of 'max_packet_size'.  The stream is stored in a memory buffer
+ * with a big endian 4 byte header giving the packet size in bytes.
+ *
+ * @param s new IO context
+ * @param max_packet_size maximum packet size (must be &gt; 0)
+ * @return zero if no error.
+ */
 int url_open_dyn_packet_buf(ByteIOContext *s, int max_packet_size);
+
+/**
+ * Return the written size and a pointer to the buffer. The buffer
+ *  must be freed with av_free().
+ * @param s IO context
+ * @param pointer to a byte buffer
+ * @return the length of the byte buffer
+ */
 int url_close_dyn_buf(ByteIOContext *s, uint8_t **pbuffer);
 
 unsigned long get_checksum(ByteIOContext *s);

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/aviobuf.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/aviobuf.c	2007-07-16 16:39:52 UTC (rev 3382)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/aviobuf.c	2007-07-16 17:44:22 UTC (rev 3383)
@@ -117,7 +117,7 @@
     offset_t pos= s-&gt;pos - (s-&gt;write_flag ? 0 : (s-&gt;buf_end - s-&gt;buffer));
 
     if (whence != SEEK_CUR &amp;&amp; whence != SEEK_SET)
-        return -EINVAL;
+        return AVERROR(EINVAL);
 
     if (whence == SEEK_CUR) {
         offset1 = pos + (s-&gt;buf_ptr - s-&gt;buffer);
@@ -136,6 +136,8 @@
             fill_buffer(s);
         s-&gt;buf_ptr = s-&gt;buf_end + offset - s-&gt;pos;
     } else {
+        offset_t res = AVERROR(EPIPE);
+
 #if defined(CONFIG_MUXERS) || defined(CONFIG_NETWORK)
         if (s-&gt;write_flag) {
             flush_buffer(s);
@@ -146,8 +148,8 @@
             s-&gt;buf_end = s-&gt;buffer;
         }
         s-&gt;buf_ptr = s-&gt;buffer;
-        if (!s-&gt;seek || s-&gt;seek(s-&gt;opaque, offset, SEEK_SET) == (offset_t)-EPIPE)
-            return -EPIPE;
+        if (!s-&gt;seek || (res = s-&gt;seek(s-&gt;opaque, offset, SEEK_SET)) &lt; 0)
+            return res;
         s-&gt;pos = offset;
     }
     s-&gt;eof_reached = 0;
@@ -169,10 +171,12 @@
     offset_t size;
 
     if (!s-&gt;seek)
-        return -EPIPE;
+        return AVERROR(EPIPE);
     size = s-&gt;seek(s-&gt;opaque, 0, AVSEEK_SIZE);
     if(size&lt;0){
-        size = s-&gt;seek(s-&gt;opaque, -1, SEEK_END) + 1;
+        if ((size = s-&gt;seek(s-&gt;opaque, -1, SEEK_END)) &lt; 0)
+            return size;
+        size++;
         s-&gt;seek(s-&gt;opaque, s-&gt;pos, SEEK_SET);
     }
     return size;
@@ -276,8 +280,8 @@
         /* do not modify buffer if EOF reached so that a seek back can
            be done without rereading data */
         s-&gt;eof_reached = 1;
-    if(len&lt;0)
-        s-&gt;error= len;
+        if(len&lt;0)
+            s-&gt;error= len;
     } else {
         s-&gt;pos += len;
         s-&gt;buf_ptr = s-&gt;buffer;
@@ -299,8 +303,6 @@
     }
 }
 
-/* NOTE: return 0 if EOF, so you cannot use it if EOF handling is
-   necessary */
 /* XXX: put an inline version */
 int get_byte(ByteIOContext *s)
 {
@@ -315,7 +317,6 @@
     }
 }
 
-/* NOTE: return URL_EOF (-1) if EOF */
 int url_fgetc(ByteIOContext *s)
 {
     if (s-&gt;buf_ptr &lt; s-&gt;buf_end) {
@@ -507,7 +508,7 @@
     }
     buffer = av_malloc(buffer_size);
     if (!buffer)
-        return -ENOMEM;
+        return AVERROR(ENOMEM);
 
     if (init_put_byte(s, buffer, buffer_size,
                       (h-&gt;flags &amp; URL_WRONLY || h-&gt;flags &amp; URL_RDWR), h,
@@ -520,13 +521,12 @@
     return 0;
 }
 
-/* XXX: must be called before any I/O */
 int url_setbufsize(ByteIOContext *s, int buf_size)
 {
     uint8_t *buffer;
     buffer = av_malloc(buf_size);
     if (!buffer)
-        return -ENOMEM;
+        return AVERROR(ENOMEM);
 
     av_free(s-&gt;buffer);
     s-&gt;buffer = buffer;
@@ -539,8 +539,6 @@
     return 0;
 }
 
-/* NOTE: when opened as read/write, the buffers are only used for
-   reading */
 int url_fopen(ByteIOContext *s, const char *filename, int flags)
 {
     URLContext *h;
@@ -572,7 +570,6 @@
 }
 
 #ifdef CONFIG_MUXERS
-/* XXX: currently size is limited */
 int url_fprintf(ByteIOContext *s, const char *fmt, ...)
 {
     va_list ap;
@@ -587,8 +584,6 @@
 }
 #endif //CONFIG_MUXERS
 
-/* note: unlike fgets, the EOL character is not returned and a whole
-   line is parsed. return NULL if first char read was EOF */
 char *url_fgets(ByteIOContext *s, char *buf, int buf_size)
 {
     int c;
@@ -610,14 +605,6 @@
     return buf;
 }
 
-/*
- * Return the maximum packet size associated to packetized buffered file
- * handle. If the file is not packetized (stream like http or file on
- * disk), then 0 is returned.
- *
- * @param h buffered file handle
- * @return maximum packet size in bytes
- */
 int url_fget_max_packet_size(ByteIOContext *s)
 {
     return s-&gt;max_packet_size;
@@ -634,7 +621,6 @@
                          NULL, NULL, NULL, NULL);
 }
 
-/* return the written or read size */
 int url_close_buf(ByteIOContext *s)
 {
     put_flush_packet(s);
@@ -742,26 +728,11 @@
     return ret;
 }
 
-/*
- * Open a write only memory stream.
- *
- * @param s new IO context
- * @return zero if no error.
- */
 int url_open_dyn_buf(ByteIOContext *s)
 {
     return url_open_dyn_buf_internal(s, 0);
 }
 
-/*
- * Open a write only packetized memory stream with a maximum packet
- * size of 'max_packet_size'.  The stream is stored in a memory buffer
- * with a big endian 4 byte header giving the packet size in bytes.
- *
- * @param s new IO context
- * @param max_packet_size maximum packet size (must be &gt; 0)
- * @return zero if no error.
- */
 int url_open_dyn_packet_buf(ByteIOContext *s, int max_packet_size)
 {
     if (max_packet_size &lt;= 0)
@@ -769,13 +740,6 @@
     return url_open_dyn_buf_internal(s, max_packet_size);
 }
 
-/*
- * Return the written size and a pointer to the buffer. The buffer
- *  must be freed with av_free().
- * @param s IO context
- * @param pointer to a byte buffer
- * @return the length of the byte buffer
- */
 int url_close_dyn_buf(ByteIOContext *s, uint8_t **pbuffer)
 {
     DynBuffer *d = s-&gt;opaque;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/cutils.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/cutils.c	2007-07-16 16:39:52 UTC (rev 3382)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/cutils.c	2007-07-16 17:44:22 UTC (rev 3383)
@@ -20,96 +20,6 @@
  */
 #include &quot;avformat.h&quot;
 
-#if !defined(CONFIG_NOCUTILS)
-/**
- * Return TRUE if val is a prefix of str. If it returns TRUE, ptr is
- * set to the next character in 'str' after the prefix.
- *
- * @param str input string
- * @param val prefix to test
- * @param ptr updated after the prefix in str in there is a match
- * @return TRUE if there is a match
- */
-int strstart(const char *str, const char *val, const char **ptr)
-{
-    const char *p, *q;
-    p = str;
-    q = val;
-    while (*q != '\0') {
-        if (*p != *q)
-            return 0;
-        p++;
-        q++;
-    }
-    if (ptr)
-        *ptr = p;
-    return 1;
-}
-
-/**
- * Return TRUE if val is a prefix of str (case independent). If it
- * returns TRUE, ptr is set to the next character in 'str' after the
- * prefix.
- *
- * @param str input string
- * @param val prefix to test
- * @param ptr updated after the prefix in str in there is a match
- * @return TRUE if there is a match */
-int stristart(const char *str, const char *val, const char **ptr)
-{
-    const char *p, *q;
-    p = str;
-    q = val;
-    while (*q != '\0') {
-        if (toupper(*(const unsigned char *)p) != toupper(*(const unsigned char *)q))
-            return 0;
-        p++;
-        q++;
-    }
-    if (ptr)
-        *ptr = p;
-    return 1;
-}
-
-/**
- * Copy the string str to buf. If str length is bigger than buf_size -
- * 1 then it is clamped to buf_size - 1.
- * NOTE: this function does what strncpy should have done to be
- * useful. NEVER use strncpy.
- *
- * @param buf destination buffer
- * @param buf_size size of destination buffer
- * @param str source string
- */
-void pstrcpy(char *buf, int buf_size, const char *str)
-{
-    int c;
-    char *q = buf;
-
-    if (buf_size &lt;= 0)
-        return;
-
-    for(;;) {
-        c = *str++;
-        if (c == 0 || q &gt;= buf + buf_size - 1)
-            break;
-        *q++ = c;
-    }
-    *q = '\0';
-}
-
-/* strcat and truncate. */
-char *pstrcat(char *buf, int buf_size, const char *s)
-{
-    int len;
-    len = strlen(buf);
-    if (len &lt; buf_size)
-        pstrcpy(buf + len, buf_size - len, s);
-    return buf;
-}
-
-#endif
-
 /* add one element to a dynamic array */
 void __dynarray_add(unsigned long **tab_ptr, int *nb_ptr, unsigned long elem)
 {
@@ -152,7 +62,7 @@
 #define ISLEAP(y) (((y) % 4 == 0) &amp;&amp; (((y) % 100) != 0 || ((y) % 400) == 0))
 #define LEAPS_COUNT(y) ((y)/4 - (y)/100 + (y)/400)
 
-/* this is our own gmtime_r. it differs from its POSIX counterpart in a
+/* This is our own gmtime_r. It differs from its POSIX counterpart in a
    couple of places, though. */
 struct tm *brktimegm(time_t secs, struct tm *tm)
 {

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/dv.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/dv.h	2007-07-16 16:39:52 UTC (rev 3382)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/dv.h	2007-07-16 17:44:22 UTC (rev 3383)
@@ -25,6 +25,11 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
+#ifndef AVFORMAT_DV_H
+#define AVFORMAT_DV_H
+
+#include &quot;avformat.h&quot;
+
 typedef struct DVDemuxContext DVDemuxContext;
 DVDemuxContext* dv_init_demux(AVFormatContext* s);
 int dv_get_packet(DVDemuxContext*, AVPacket *);
@@ -35,3 +40,5 @@
 DVMuxContext* dv_init_mux(AVFormatContext* s);
 int dv_assemble_frame(DVMuxContext *c, AVStream*, const uint8_t*, int, uint8_t**);
 void dv_delete_mux(DVMuxContext*);
+
+#endif // AVFORMAT_DV_H

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/file.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/file.c	2007-07-16 16:39:52 UTC (rev 3382)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/file.c	2007-07-16 17:44:22 UTC (rev 3383)
@@ -19,6 +19,7 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 #include &quot;avformat.h&quot;
+#include &quot;avstring.h&quot;
 #include &lt;fcntl.h&gt;
 #include &lt;unistd.h&gt;
 #include &lt;sys/time.h&gt;
@@ -31,7 +32,7 @@
     int access;
     int fd;
 
-    strstart(filename, &quot;file:&quot;, &amp;filename);
+    av_strstart(filename, &quot;file:&quot;, &amp;filename);
 
     if (flags &amp; URL_RDWR) {
         access = O_CREAT | O_TRUNC | O_RDWR;
@@ -40,12 +41,12 @@
     } else {
         access = O_RDONLY;
     }
-#if defined(__MINGW32__) || defined(CONFIG_OS2) || defined(__CYGWIN__)
+#ifdef O_BINARY
     access |= O_BINARY;
 #endif
     fd = open(filename, access, 0666);
     if (fd &lt; 0)
-        return -ENOENT;
+        return AVERROR(ENOENT);
     h-&gt;priv_data = (void *)(size_t)fd;
     return 0;
 }
@@ -95,7 +96,7 @@
     } else {
         fd = 0;
     }
-#if defined(__MINGW32__) || defined(CONFIG_OS2) || defined(__CYGWIN__)
+#ifdef O_BINARY
     setmode(fd, O_BINARY);
 #endif
     h-&gt;priv_data = (void *)(size_t)fd;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/flv.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/flv.h	2007-07-16 16:39:52 UTC (rev 3382)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/flv.h	2007-07-16 17:44:22 UTC (rev 3383)
@@ -80,9 +80,11 @@
 };
 
 enum {
-    FLV_CODECID_H263   = 2,
-    FLV_CODECID_SCREEN = 3,
-    FLV_CODECID_VP6    = 4,
+    FLV_CODECID_H263    = 2,
+    FLV_CODECID_SCREEN  = 3,
+    FLV_CODECID_VP6     = 4,
+    FLV_CODECID_VP6A    = 5,
+    FLV_CODECID_SCREEN2 = 6,
 };
 
 enum {

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/img2.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/img2.c	2007-07-16 16:39:52 UTC (rev 3382)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/img2.c	2007-07-16 17:44:22 UTC (rev 3383)
@@ -20,6 +20,7 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 #include &quot;avformat.h&quot;
+#include &quot;avstring.h&quot;
 
 typedef struct {
     int img_first;
@@ -54,6 +55,8 @@
     { CODEC_ID_GIF       , &quot;gif&quot;},
     { CODEC_ID_TARGA     , &quot;tga&quot;},
     { CODEC_ID_TIFF      , &quot;tiff&quot;},
+    { CODEC_ID_SGI       , &quot;sgi&quot;},
+    { CODEC_ID_PTX       , &quot;ptx&quot;},
     {0, NULL}
 };
 
@@ -177,10 +180,10 @@
 
     st = av_new_stream(s1, 0);
     if (!st) {
-        return -ENOMEM;
+        return AVERROR(ENOMEM);
     }
 
-    pstrcpy(s-&gt;path, sizeof(s-&gt;path), s1-&gt;filename);
+    av_strlcpy(s-&gt;path, s1-&gt;filename, sizeof(s-&gt;path));
     s-&gt;img_number = 0;
     s-&gt;img_count = 0;
 
@@ -189,7 +192,7 @@
         s-&gt;is_pipe = 0;
     else{
         s-&gt;is_pipe = 1;
-        st-&gt;need_parsing= 1;
+        st-&gt;need_parsing = AVSTREAM_PARSE_FULL;
     }
 
     if (!ap-&gt;time_base.num) {
@@ -305,7 +308,7 @@
     VideoData *img = s-&gt;priv_data;
 
     img-&gt;img_number = 1;
-    pstrcpy(img-&gt;path, sizeof(img-&gt;path), s-&gt;filename);
+    av_strlcpy(img-&gt;path, s-&gt;filename, sizeof(img-&gt;path));
 
     /* find format */
     if (s-&gt;oformat-&gt;flags &amp; AVFMT_NOFILE)

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/isom.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/isom.c	2007-07-16 16:39:52 UTC (rev 3382)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/isom.c	2007-07-16 17:44:22 UTC (rev 3383)
@@ -25,8 +25,8 @@
 #include &quot;riff.h&quot;
 #include &quot;isom.h&quot;
 
-/* <A HREF="http://gpac.sourceforge.net/tutorial/mediatypes.htm">http://gpac.sourceforge.net/tutorial/mediatypes.htm</A> */
-const AVCodecTag ff_mov_obj_type[] = {
+/* <A HREF="http://www.mp4ra.org">http://www.mp4ra.org</A> */
+const AVCodecTag ff_mp4_obj_type[] = {
     { CODEC_ID_MPEG4     ,  32 },
     { CODEC_ID_H264      ,  33 },
     { CODEC_ID_AAC       ,  64 },
@@ -39,12 +39,15 @@
     { CODEC_ID_AAC       , 102 }, /* MPEG2 AAC Main */
     { CODEC_ID_AAC       , 103 }, /* MPEG2 AAC Low */
     { CODEC_ID_AAC       , 104 }, /* MPEG2 AAC SSR */
-    { CODEC_ID_MP3       , 105 },
-    { CODEC_ID_MPEG1VIDEO, 106 },
-    { CODEC_ID_MP2       , 107 },
-    { CODEC_ID_MJPEG     , 108 },
+    { CODEC_ID_MP3       , 105 }, /* 13818-3 */
+    { CODEC_ID_MPEG1VIDEO, 106 }, /* 11172-2 */
+    { CODEC_ID_MP2       , 107 }, /* 11172-3 */ /* MEANX WAS MP3 */
+    { CODEC_ID_MJPEG     , 108 }, /* 10918-1 */
+    { CODEC_ID_PNG       , 109 },
+    { CODEC_ID_JPEG2000  , 110 }, /* 15444-1 */
+    { CODEC_ID_VC1       , 163 },
+    { CODEC_ID_VORBIS    , 221 },
     { CODEC_ID_PCM_S16LE , 224 },
-    { CODEC_ID_VORBIS    , 221 },
     { CODEC_ID_QCELP     , 225 },
     { CODEC_ID_AC3       , 226 },
     { CODEC_ID_PCM_ALAW  , 227 },
@@ -55,6 +58,125 @@
     { 0, 0 },
 };
 
+const AVCodecTag codec_movvideo_tags[] = {
+/*  { CODEC_ID_, MKTAG('I', 'V', '5', '0') }, *//* Indeo 5.0 */
+
+    { CODEC_ID_RAWVIDEO, MKTAG('r', 'a', 'w', ' ') }, /* Uncompressed RGB */
+/*  { CODEC_ID_RAWVIDEO, MKTAG('Y', 'u', 'v', '2') }, *//* Uncompressed YUV422 */
+    { CODEC_ID_RAWVIDEO, MKTAG('A', 'V', 'U', 'I') }, /* YUV with alpha-channel (AVID Uncompressed) */
+    { CODEC_ID_RAWVIDEO, MKTAG('2', 'v', 'u', 'y') }, /* UNCOMPRESSED 8BIT 4:2:2 */
+
+    { CODEC_ID_MJPEG,  MKTAG('j', 'p', 'e', 'g') }, /* PhotoJPEG */
+    { CODEC_ID_MJPEG,  MKTAG('m', 'j', 'p', 'a') }, /* Motion-JPEG (format A) */
+    { CODEC_ID_MJPEG,  MKTAG('A', 'V', 'D', 'J') }, /* MJPEG with alpha-channel (AVID JFIF meridien compressed) */
+/*  { CODEC_ID_MJPEG,  MKTAG('A', 'V', 'R', 'n') }, *//* MJPEG with alpha-channel (AVID ABVB/Truevision NuVista) */
+    { CODEC_ID_MJPEG,  MKTAG('d', 'm', 'b', '1') }, /* Motion JPEG OpenDML */
+    { CODEC_ID_MJPEGB, MKTAG('m', 'j', 'p', 'b') }, /* Motion-JPEG (format B) */
+
+    { CODEC_ID_SVQ1, MKTAG('S', 'V', 'Q', '1') }, /* Sorenson Video v1 */
+    { CODEC_ID_SVQ1, MKTAG('s', 'v', 'q', '1') }, /* Sorenson Video v1 */
+    { CODEC_ID_SVQ1, MKTAG('s', 'v', 'q', 'i') }, /* Sorenson Video v1 (from QT specs)*/
+    { CODEC_ID_SVQ3, MKTAG('S', 'V', 'Q', '3') }, /* Sorenson Video v3 */
+
+    { CODEC_ID_MPEG4, MKTAG('m', 'p', '4', 'v') },
+    { CODEC_ID_MPEG4, MKTAG('D', 'I', 'V', 'X') }, /* OpenDiVX *//* sample files at <A HREF="http://heroinewarrior.com/xmovie.php3">http://heroinewarrior.com/xmovie.php3</A> use this tag */
+    { CODEC_ID_MPEG4, MKTAG('X', 'V', 'I', 'D') },
+    { CODEC_ID_MPEG4, MKTAG('3', 'I', 'V', '2') }, /* experimental: 3IVX files before ivx D4 4.5.1 */
+
+    { CODEC_ID_H263, MKTAG('h', '2', '6', '3') }, /* H263 */
+    { CODEC_ID_H263, MKTAG('s', '2', '6', '3') }, /* H263 ?? works */
+
+    { CODEC_ID_DVVIDEO, MKTAG('d', 'v', 'c', 'p') }, /* DV PAL */
+    { CODEC_ID_DVVIDEO, MKTAG('d', 'v', 'c', ' ') }, /* DV NTSC */
+    { CODEC_ID_DVVIDEO, MKTAG('d', 'v', 'p', 'p') }, /* DVCPRO PAL produced by FCP */
+    { CODEC_ID_DVVIDEO, MKTAG('d', 'v', '5', 'p') }, /* DVCPRO50 PAL produced by FCP */
+    { CODEC_ID_DVVIDEO, MKTAG('d', 'v', '5', 'n') }, /* DVCPRO50 NTSC produced by FCP */
+    { CODEC_ID_DVVIDEO, MKTAG('A', 'V', 'd', 'v') }, /* AVID DV */
+  //{ CODEC_ID_DVVIDEO, MKTAG('d', 'v', 'h', '5') }, /* DVCPRO HD 50i produced by FCP */
+  //{ CODEC_ID_DVVIDEO, MKTAG('d', 'v', 'h', '6') }, /* DVCPRO HD 60i produced by FCP */
+
+    { CODEC_ID_VP3,     MKTAG('V', 'P', '3', '1') }, /* On2 VP3 */
+    { CODEC_ID_RPZA,    MKTAG('r', 'p', 'z', 'a') }, /* Apple Video (RPZA) */
+    { CODEC_ID_CINEPAK, MKTAG('c', 'v', 'i', 'd') }, /* Cinepak */
+    { CODEC_ID_8BPS,    MKTAG('8', 'B', 'P', 'S') }, /* Planar RGB (8BPS) */
+    { CODEC_ID_SMC,     MKTAG('s', 'm', 'c', ' ') }, /* Apple Graphics (SMC) */
+    { CODEC_ID_QTRLE,   MKTAG('r', 'l', 'e', ' ') }, /* Apple Animation (RLE) */
+    { CODEC_ID_MSRLE,   MKTAG('W', 'R', 'L', 'E') },
+    { CODEC_ID_QDRAW,   MKTAG('q', 'd', 'r', 'w') }, /* QuickDraw */
+
+    { CODEC_ID_H264, MKTAG('a', 'v', 'c', '1') }, /* AVC-1/H.264 */
+
+    { CODEC_ID_MPEG1VIDEO, MKTAG('m', 'p', 'e', 'g') }, /* MPEG */
+    { CODEC_ID_MPEG2VIDEO, MKTAG('h', 'd', 'v', '1') }, /* HDV 720p30 */
+    { CODEC_ID_MPEG2VIDEO, MKTAG('h', 'd', 'v', '2') }, /* MPEG2 produced by Sony HD camera */
+    { CODEC_ID_MPEG2VIDEO, MKTAG('h', 'd', 'v', '3') }, /* HDV produced by FCP */
+    { CODEC_ID_MPEG2VIDEO, MKTAG('m', 'x', '5', 'n') }, /* MPEG2 IMX NTSC 525/60 50mb/s produced by FCP */
+    { CODEC_ID_MPEG2VIDEO, MKTAG('m', 'x', '5', 'p') }, /* MPEG2 IMX PAL 625/50 50mb/s produced by FCP */
+    { CODEC_ID_MPEG2VIDEO, MKTAG('m', 'x', '3', 'n') }, /* MPEG2 IMX NTSC 525/60 30mb/s produced by FCP */
+    { CODEC_ID_MPEG2VIDEO, MKTAG('m', 'x', '3', 'p') }, /* MPEG2 IMX PAL 625/50 30mb/s produced by FCP */
+    { CODEC_ID_MPEG2VIDEO, MKTAG('x', 'd', 'v', '2') }, /* XDCAM HD 1080i60 */
+    { CODEC_ID_MPEG2VIDEO, MKTAG('A', 'V', 'm', 'p') }, /* AVID IMX PAL */
+
+  //{ CODEC_ID_JPEG2000, MKTAG('m', 'j', 'p', '2') }, /* JPEG 2000 produced by FCP */
+
+    { CODEC_ID_TARGA, MKTAG('t', 'g', 'a', ' ') }, /* Truevision Targa */
+    { CODEC_ID_TIFF,  MKTAG('t', 'i', 'f', 'f') }, /* TIFF embedded in MOV */
+    { CODEC_ID_GIF,   MKTAG('g', 'i', 'f', ' ') }, /* embedded gif files as frames (usually one &quot;click to play movie&quot; frame) */
+    { CODEC_ID_PNG,   MKTAG('p', 'n', 'g', ' ') },
+
+    { CODEC_ID_VC1, MKTAG('v', 'c', '-', '1') }, /* SMPTE RP 2025 */
+
+    { CODEC_ID_DNXHD, MKTAG('A', 'V', 'd', 'n') }, /* AVID DNxHD */
+    { CODEC_ID_SGI,   MKTAG('s', 'g', 'i', ' ') }, /* SGI  */
+
+    { CODEC_ID_NONE, 0 },
+};
+
+const AVCodecTag codec_movaudio_tags[] = {
+    { CODEC_ID_PCM_S32BE, MKTAG('i', 'n', '3', '2') },
+    { CODEC_ID_PCM_S32LE, MKTAG('i', 'n', '3', '2') },
+    { CODEC_ID_PCM_S24BE, MKTAG('i', 'n', '2', '4') },
+    { CODEC_ID_PCM_S24LE, MKTAG('i', 'n', '2', '4') },
+    { CODEC_ID_PCM_S16BE, MKTAG('t', 'w', 'o', 's') }, /* 16 bits */
+    { CODEC_ID_PCM_S16BE, MKTAG('N', 'O', 'N', 'E') }, /* uncompressed */
+    { CODEC_ID_PCM_S16LE, MKTAG('s', 'o', 'w', 't') }, /*  */
+    { CODEC_ID_PCM_S16LE, MKTAG('l', 'p', 'c', 'm') },
+    { CODEC_ID_PCM_S8,    MKTAG('s', 'o', 'w', 't') },
+    { CODEC_ID_PCM_U8,    MKTAG('r', 'a', 'w', ' ') }, /* 8 bits unsigned */
+    { CODEC_ID_PCM_MULAW, MKTAG('u', 'l', 'a', 'w') }, /*  */
+    { CODEC_ID_PCM_ALAW,  MKTAG('a', 'l', 'a', 'w') }, /*  */
+
+    { CODEC_ID_ADPCM_IMA_QT, MKTAG('i', 'm', 'a', '4') }, /* IMA-4 ADPCM */
+    { CODEC_ID_ADPCM_MS,     MKTAG('m', 's', 0x00, 0x02) }, /* MS ADPCM */
+
+    { CODEC_ID_MACE3, MKTAG('M', 'A', 'C', '3') }, /* Macintosh Audio Compression and Expansion 3:1 */
+    { CODEC_ID_MACE6, MKTAG('M', 'A', 'C', '6') }, /* Macintosh Audio Compression and Expansion 6:1 */
+
+    // MEANX{ CODEC_ID_MP3, MKTAG('.', 'm', 'p', '3') }, /* MPEG layer 3 */ /* sample files at <A HREF="http://www.3ivx.com/showcase.html">http://www.3ivx.com/showcase.html</A> use this tag */
+     { CODEC_ID_MP3, MKTAG( 'm', 'p', '4','a') },
+
+    // /MEANX
+    { CODEC_ID_MP3, 0x6D730055 }, /* MPEG layer 3 */
+    { CODEC_ID_MP3, MKTAG('m', 's', 0x00, 0x55) }, /* MPEG layer 3 *//* XXX: check endianness */
+
+/*  { CODEC_ID_OGG_VORBIS, MKTAG('O', 'g', 'g', 'S') }, *//* sample files at <A HREF="http://heroinewarrior.com/xmovie.php3">http://heroinewarrior.com/xmovie.php3</A> use this tag */
+
+    { CODEC_ID_AAC, MKTAG('m', 'p', '4', 'a') }, /* MPEG-4 AAC */
+
+    { CODEC_ID_AMR_NB, MKTAG('s', 'a', 'm', 'r') }, /* AMR-NB 3gp */
+    { CODEC_ID_AMR_WB, MKTAG('s', 'a', 'w', 'b') }, /* AMR-WB 3gp */
+
+    { CODEC_ID_AC3,  MKTAG('m', 's', 0x20, 0x00) }, /* Dolby AC-3 */
+
+    { CODEC_ID_ALAC, MKTAG('a', 'l', 'a', 'c') }, /* Apple Lossless */
+    { CODEC_ID_QDM2, MKTAG('Q', 'D', 'M', '2') }, /* QDM2 */
+
+    { CODEC_ID_DVAUDIO, MKTAG('v', 'd', 'v', 'a') },
+    { CODEC_ID_DVAUDIO, MKTAG('d', 'v', 'c', 'a') },
+
+    { CODEC_ID_NONE, 0 },
+};
+
 /* map numeric codes from mdhd atom to ISO 639 */
 /* cf. QTFileFormat.pdf p253, qtff.pdf p205 */
 /* <A HREF="http://developer.apple.com/documentation/mac/Text/Text-368.html">http://developer.apple.com/documentation/mac/Text/Text-368.html</A> */

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/isom.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/isom.h	2007-07-16 16:39:52 UTC (rev 3382)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/isom.h	2007-07-16 17:44:22 UTC (rev 3383)
@@ -24,15 +24,19 @@
 #ifndef FFMPEG_ISOM_H
 #define FFMPEG_ISOM_H
 
+#include &quot;riff.h&quot;
+
 /* isom.c */
-extern const AVCodecTag ff_mov_obj_type[];
+extern const AVCodecTag ff_mp4_obj_type[];
+extern const AVCodecTag codec_movvideo_tags[];
+extern const AVCodecTag codec_movaudio_tags[];
 
 int ff_mov_iso639_to_lang(const char *lang, int mp4);
 int ff_mov_lang_to_iso639(int code, char *to);
 
-typedef struct Time2Sample{
+typedef struct {
     int count;
     int duration;
-}Time2Sample;
+} MOV_stts_t;
 
 #endif /* FFMPEG_ISOM_H */

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/matroska.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/matroska.c	2007-07-16 16:39:52 UTC (rev 3382)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/matroska.c	2007-07-16 17:44:22 UTC (rev 3383)
@@ -1,5 +1,5 @@
 /*
- * Matroska file demuxer (no muxer yet)
+ * Matroska common data
  * Copyright (c) 2003-2004 The ffmpeg Project
  *
  * This file is part of FFmpeg.
@@ -19,184 +19,9 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-/**
- * @file matroska.c
- * Matroska file demuxer
- * by Ronald Bultje &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">rbultje at ronald.bitfreak.net</A>&gt;
- * with a little help from Moritz Bunkus &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">moritz at bunkus.org</A>&gt;
- * Specs available on the matroska project page:
- * <A HREF="http://www.matroska.org/.">http://www.matroska.org/.</A>
- */
+#include &quot;matroska.h&quot;
 
-#include &quot;avformat.h&quot;
-/* For codec_get_bmp_id and codec_get_wav_id. */
-#include &quot;riff.h&quot;
-#include &quot;intfloat_readwrite.h&quot;
-
-/* EBML version supported */
-#define EBML_VERSION 1
-
-/* top-level master-IDs */
-#define EBML_ID_HEADER             0x1A45DFA3
-
-/* IDs in the HEADER master */
-#define EBML_ID_EBMLVERSION        0x4286
-#define EBML_ID_EBMLREADVERSION    0x42F7
-#define EBML_ID_EBMLMAXIDLENGTH    0x42F2
-#define EBML_ID_EBMLMAXSIZELENGTH  0x42F3
-#define EBML_ID_DOCTYPE            0x4282
-#define EBML_ID_DOCTYPEVERSION     0x4287
-#define EBML_ID_DOCTYPEREADVERSION 0x4285
-
-/* general EBML types */
-#define EBML_ID_VOID               0xEC
-
-/*
- * Matroska element IDs. max. 32-bit.
- */
-
-/* toplevel segment */
-#define MATROSKA_ID_SEGMENT    0x18538067
-
-/* matroska top-level master IDs */
-#define MATROSKA_ID_INFO       0x1549A966
-#define MATROSKA_ID_TRACKS     0x1654AE6B
-#define MATROSKA_ID_CUES       0x1C53BB6B
-#define MATROSKA_ID_TAGS       0x1254C367
-#define MATROSKA_ID_SEEKHEAD   0x114D9B74
-#define MATROSKA_ID_CLUSTER    0x1F43B675
-
-/* IDs in the info master */
-#define MATROSKA_ID_TIMECODESCALE 0x2AD7B1
-#define MATROSKA_ID_DURATION   0x4489
-#define MATROSKA_ID_TITLE      0x7BA9
-#define MATROSKA_ID_WRITINGAPP 0x5741
-#define MATROSKA_ID_MUXINGAPP  0x4D80
-#define MATROSKA_ID_DATEUTC    0x4461
-
-/* ID in the tracks master */
-#define MATROSKA_ID_TRACKENTRY 0xAE
-
-/* IDs in the trackentry master */
-#define MATROSKA_ID_TRACKNUMBER 0xD7
-#define MATROSKA_ID_TRACKUID   0x73C5
-#define MATROSKA_ID_TRACKTYPE  0x83
-#define MATROSKA_ID_TRACKAUDIO 0xE1
-#define MATROSKA_ID_TRACKVIDEO 0xE0
-#define MATROSKA_ID_CODECID    0x86
-#define MATROSKA_ID_CODECPRIVATE 0x63A2
-#define MATROSKA_ID_CODECNAME  0x258688
-#define MATROSKA_ID_CODECINFOURL 0x3B4040
-#define MATROSKA_ID_CODECDOWNLOADURL 0x26B240
-#define MATROSKA_ID_TRACKNAME  0x536E
-#define MATROSKA_ID_TRACKLANGUAGE 0x22B59C
-#define MATROSKA_ID_TRACKFLAGENABLED 0xB9
-#define MATROSKA_ID_TRACKFLAGDEFAULT 0x88
-#define MATROSKA_ID_TRACKFLAGLACING 0x9C
-#define MATROSKA_ID_TRACKMINCACHE 0x6DE7
-#define MATROSKA_ID_TRACKMAXCACHE 0x6DF8
-#define MATROSKA_ID_TRACKDEFAULTDURATION 0x23E383
-
-/* IDs in the trackvideo master */
-#define MATROSKA_ID_VIDEOFRAMERATE 0x2383E3
-#define MATROSKA_ID_VIDEODISPLAYWIDTH 0x54B0
-#define MATROSKA_ID_VIDEODISPLAYHEIGHT 0x54BA
-#define MATROSKA_ID_VIDEOPIXELWIDTH 0xB0
-#define MATROSKA_ID_VIDEOPIXELHEIGHT 0xBA
-#define MATROSKA_ID_VIDEOFLAGINTERLACED 0x9A
-#define MATROSKA_ID_VIDEOSTEREOMODE 0x53B9
-#define MATROSKA_ID_VIDEOASPECTRATIO 0x54B3
-#define MATROSKA_ID_VIDEOCOLOURSPACE 0x2EB524
-
-/* IDs in the trackaudio master */
-#define MATROSKA_ID_AUDIOSAMPLINGFREQ 0xB5
-#define MATROSKA_ID_AUDIOOUTSAMPLINGFREQ 0x78B5
-
-#define MATROSKA_ID_AUDIOBITDEPTH 0x6264
-#define MATROSKA_ID_AUDIOCHANNELS 0x9F
-
-/* ID in the cues master */
-#define MATROSKA_ID_POINTENTRY 0xBB
-
-/* IDs in the pointentry master */
-#define MATROSKA_ID_CUETIME    0xB3
-#define MATROSKA_ID_CUETRACKPOSITION 0xB7
-
-/* IDs in the cuetrackposition master */
-#define MATROSKA_ID_CUETRACK   0xF7
-#define MATROSKA_ID_CUECLUSTERPOSITION 0xF1
-
-/* IDs in the tags master */
-/* TODO */
-
-/* IDs in the seekhead master */
-#define MATROSKA_ID_SEEKENTRY  0x4DBB
-
-/* IDs in the seekpoint master */
-#define MATROSKA_ID_SEEKID     0x53AB
-#define MATROSKA_ID_SEEKPOSITION 0x53AC
-
-/* IDs in the cluster master */
-#define MATROSKA_ID_CLUSTERTIMECODE 0xE7
-#define MATROSKA_ID_BLOCKGROUP 0xA0
-
-/* IDs in the blockgroup master */
-#define MATROSKA_ID_BLOCK      0xA1
-#define MATROSKA_ID_BLOCKDURATION 0x9B
-#define MATROSKA_ID_BLOCKREFERENCE 0xFB
-
-typedef enum {
-  MATROSKA_TRACK_TYPE_VIDEO    = 0x1,
-  MATROSKA_TRACK_TYPE_AUDIO    = 0x2,
-  MATROSKA_TRACK_TYPE_COMPLEX  = 0x3,
-  MATROSKA_TRACK_TYPE_LOGO     = 0x10,
-  MATROSKA_TRACK_TYPE_SUBTITLE = 0x11,
-  MATROSKA_TRACK_TYPE_CONTROL  = 0x20,
-} MatroskaTrackType;
-
-typedef enum {
-  MATROSKA_EYE_MODE_MONO  = 0x0,
-  MATROSKA_EYE_MODE_RIGHT = 0x1,
-  MATROSKA_EYE_MODE_LEFT  = 0x2,
-  MATROSKA_EYE_MODE_BOTH  = 0x3,
-} MatroskaEyeMode;
-
-typedef enum {
-  MATROSKA_ASPECT_RATIO_MODE_FREE  = 0x0,
-  MATROSKA_ASPECT_RATIO_MODE_KEEP  = 0x1,
-  MATROSKA_ASPECT_RATIO_MODE_FIXED = 0x2,
-} MatroskaAspectRatioMode;
-
-/*
- * These aren't in any way &quot;matroska-form&quot; things,
- * it's just something I use in the muxer/demuxer.
- */
-
-typedef enum {
-  MATROSKA_TRACK_ENABLED = (1&lt;&lt;0),
-  MATROSKA_TRACK_DEFAULT = (1&lt;&lt;1),
-  MATROSKA_TRACK_LACING  = (1&lt;&lt;2),
-  MATROSKA_TRACK_REAL_V  = (1&lt;&lt;4),
-  MATROSKA_TRACK_SHIFT   = (1&lt;&lt;16)
-} MatroskaTrackFlags;
-
-typedef enum {
-  MATROSKA_VIDEOTRACK_INTERLACED = (MATROSKA_TRACK_SHIFT&lt;&lt;0)
-} MatroskaVideoTrackFlags;
-
-/*
- * Matroska Codec IDs. Strings.
- */
-
-typedef struct CodecTags{
-    const char *str;
-    enum CodecID id;
-}CodecTags;
-
-#define MATROSKA_CODEC_ID_VIDEO_VFW_FOURCC   &quot;V_MS/VFW/FOURCC&quot;
-#define MATROSKA_CODEC_ID_AUDIO_ACM          &quot;A_MS/ACM&quot;
-
-static CodecTags codec_tags[]={
+CodecTags ff_mkv_codec_tags[]={
 //    {&quot;V_MS/VFW/FOURCC&quot;  , CODEC_ID_NONE},
     {&quot;V_UNCOMPRESSED&quot;   , CODEC_ID_RAWVIDEO},
     {&quot;V_MPEG4/ISO/SP&quot;   , CODEC_ID_MPEG4},
@@ -211,6 +36,7 @@
     {&quot;V_REAL/RV20&quot;      , CODEC_ID_RV20},
     {&quot;V_REAL/RV30&quot;      , CODEC_ID_RV30},
     {&quot;V_REAL/RV40&quot;      , CODEC_ID_RV40},
+    {&quot;V_THEORA&quot;         , CODEC_ID_THEORA},
 /* TODO: Real/Quicktime */
 
 //    {&quot;A_MS/ACM&quot;         , CODEC_ID_NONE},
@@ -227,2541 +53,18 @@
     {&quot;A_FLAC&quot;           , CODEC_ID_FLAC},
     {&quot;A_WAVPACK4&quot;       , CODEC_ID_WAVPACK},
     {&quot;A_TTA1&quot;           , CODEC_ID_TTA},
+    {&quot;A_REAL/14_4&quot;      , CODEC_ID_RA_144},
+    {&quot;A_REAL/28_8&quot;      , CODEC_ID_RA_288},
+    {&quot;A_REAL/ATRC&quot;      , CODEC_ID_ATRAC3},
+    {&quot;A_REAL/COOK&quot;      , CODEC_ID_COOK},
+//    {&quot;A_REAL/SIPR&quot;      , CODEC_ID_SIPRO},
+
+    {&quot;S_TEXT/ASCII&quot;     , CODEC_ID_TEXT},
+    {&quot;S_TEXT/UTF8&quot;      , CODEC_ID_TEXT},
+    {&quot;S_TEXT/ASS&quot;       , CODEC_ID_TEXT},
+    {&quot;S_TEXT/SSA&quot;       , CODEC_ID_TEXT},
+    {&quot;S_VOBSUB&quot;         , CODEC_ID_DVD_SUBTITLE},
+
     {NULL               , CODEC_ID_NONE}
 /* TODO: AC3-9/10 (?), Real, Musepack, Quicktime */
 };
-
-/* max. depth in the EBML tree structure */
-#define EBML_MAX_DEPTH 16
-
-typedef struct Track {
-    MatroskaTrackType type;
-
-    /* Unique track number and track ID. stream_index is the index that
-     * the calling app uses for this track. */
-    uint32_t num,
-        uid,
-        stream_index;
-
-    char *name,
-        *language;
-
-    char *codec_id,
-        *codec_name;
-
-    unsigned char *codec_priv;
-    int codec_priv_size;
-
-    int64_t default_duration;
-    MatroskaTrackFlags flags;
-} MatroskaTrack;
-
-typedef struct MatroskaVideoTrack {
-    MatroskaTrack track;
-
-    int pixel_width,
-        pixel_height,
-        display_width,
-        display_height;
-
-    uint32_t fourcc;
-
-    MatroskaAspectRatioMode ar_mode;
-    MatroskaEyeMode eye_mode;
-
-    //..
-} MatroskaVideoTrack;
-
-typedef struct MatroskaAudioTrack {
-    MatroskaTrack track;
-
-    int channels,
-        bitdepth,
-        internal_samplerate,
-        samplerate;
-    //..
-} MatroskaAudioTrack;
-
-typedef struct MatroskaSubtitleTrack {
-    MatroskaTrack track;
-
-    //..
-} MatroskaSubtitleTrack;
-
-typedef struct MatroskaLevel {
-    uint64_t start, length;
-} MatroskaLevel;
-
-typedef struct MatroskaDemuxIndex {
-  uint64_t        pos;   /* of the corresponding *cluster*! */
-  uint16_t        track; /* reference to 'num' */
-  uint64_t        time;  /* in nanoseconds */
-} MatroskaDemuxIndex;
-
-typedef struct MatroskaDemuxContext {
-    AVFormatContext *ctx;
-
-    /* ebml stuff */
-    int num_levels;
-    MatroskaLevel levels[EBML_MAX_DEPTH];
-    int level_up;
-
-    /* matroska stuff */
-    char *writing_app,
-        *muxing_app;
-    int64_t created;
-
-    /* timescale in the file */
-    int64_t time_scale;
-
-    /* position (time, ns) */
-    int64_t pos;
-
-    /* num_streams is the number of streams that av_new_stream() was called
-     * for ( = that are available to the calling program). */
-    int num_tracks, num_streams;
-    MatroskaTrack *tracks[MAX_STREAMS];
-
-    /* cache for ID peeking */
-    uint32_t peek_id;
-
-    /* byte position of the segment inside the stream */
-    offset_t segment_start;
-
-    /* The packet queue. */
-    AVPacket **packets;
-    int num_packets;
-
-    /* have we already parse metadata/cues/clusters? */
-    int metadata_parsed,
-        index_parsed,
-        done;
-
-    /* The index for seeking. */
-    int num_indexes;
-    MatroskaDemuxIndex *index;
-} MatroskaDemuxContext;
-
-/*
- * The first few functions handle EBML file parsing. The rest
- * is the document interpretation. Matroska really just is a
- * EBML file.
- */
-
-/*
- * Return: the amount of levels in the hierarchy that the
- * current element lies higher than the previous one.
- * The opposite isn't done - that's auto-done using master
- * element reading.
- */
-
-static int
-ebml_read_element_level_up (MatroskaDemuxContext *matroska)
-{
-    ByteIOContext *pb = &amp;matroska-&gt;ctx-&gt;pb;
-    offset_t pos = url_ftell(pb);
-    int num = 0;
-
-    while (matroska-&gt;num_levels &gt; 0) {
-        MatroskaLevel *level = &amp;matroska-&gt;levels[matroska-&gt;num_levels - 1];
-
-        if (pos &gt;= level-&gt;start + level-&gt;length) {
-            matroska-&gt;num_levels--;
-            num++;
-        } else {
-            break;
-        }
-    }
-
-    return num;
-}
-
-/*
- * Read: an &quot;EBML number&quot;, which is defined as a variable-length
- * array of bytes. The first byte indicates the length by giving a
- * number of 0-bits followed by a one. The position of the first
- * &quot;one&quot; bit inside the first byte indicates the length of this
- * number.
- * Returns: num. of bytes read. &lt; 0 on error.
- */
-
-static int
-ebml_read_num (MatroskaDemuxContext *matroska,
-               int                   max_size,
-               uint64_t             *number)
-{
-    ByteIOContext *pb = &amp;matroska-&gt;ctx-&gt;pb;
-    int len_mask = 0x80, read = 1, n = 1;
-    int64_t total = 0;
-
-    /* the first byte tells us the length in bytes - get_byte() can normally
-     * return 0, but since that's not a valid first ebmlID byte, we can
-     * use it safely here to catch EOS. */
-    if (!(total = get_byte(pb))) {
-        /* we might encounter EOS here */
-        if (!url_feof(pb)) {
-            offset_t pos = url_ftell(pb);
-            av_log(matroska-&gt;ctx, AV_LOG_ERROR,
-                   &quot;Read error at pos. %&quot;PRIu64&quot; (0x%&quot;PRIx64&quot;)\n&quot;,
-                   pos, pos);
-        }
-        return AVERROR_IO; /* EOS or actual I/O error */
-    }
-
-    /* get the length of the EBML number */
-    while (read &lt;= max_size &amp;&amp; !(total &amp; len_mask)) {
-        read++;
-        len_mask &gt;&gt;= 1;
-    }
-    if (read &gt; max_size) {
-        offset_t pos = url_ftell(pb) - 1;
-        av_log(matroska-&gt;ctx, AV_LOG_ERROR,
-               &quot;Invalid EBML number size tag 0x%02x at pos %&quot;PRIu64&quot; (0x%&quot;PRIx64&quot;)\n&quot;,
-               (uint8_t) total, pos, pos);
-        return AVERROR_INVALIDDATA;
-    }
-
-    /* read out length */
-    total &amp;= ~len_mask;
-    while (n++ &lt; read)
-        total = (total &lt;&lt; 8) | get_byte(pb);
-
-    *number = total;
-
-    return read;
-}
-
-/*
- * Read: the element content data ID.
- * Return: the number of bytes read or &lt; 0 on error.
- */
-
-static int
-ebml_read_element_id (MatroskaDemuxContext *matroska,
-                      uint32_t             *id,
-                      int                  *level_up)
-{
-    int read;
-    uint64_t total;
-
-    /* if we re-call this, use our cached ID */
-    if (matroska-&gt;peek_id != 0) {
-        if (level_up)
-            *level_up = 0;
-        *id = matroska-&gt;peek_id;
-        return 0;
-    }
-
-    /* read out the &quot;EBML number&quot;, include tag in ID */
-    if ((read = ebml_read_num(matroska, 4, &amp;total)) &lt; 0)
-        return read;
-    *id = matroska-&gt;peek_id  = total | (1 &lt;&lt; (read * 7));
-
-    /* level tracking */
-    if (level_up)
-        *level_up = ebml_read_element_level_up(matroska);
-
-    return read;
-}
-
-/*
- * Read: element content length.
- * Return: the number of bytes read or &lt; 0 on error.
- */
-
-static int
-ebml_read_element_length (MatroskaDemuxContext *matroska,
-                          uint64_t             *length)
-{
-    /* clear cache since we're now beyond that data point */
-    matroska-&gt;peek_id = 0;
-
-    /* read out the &quot;EBML number&quot;, include tag in ID */
-    return ebml_read_num(matroska, 8, length);
-}
-
-/*
- * Return: the ID of the next element, or 0 on error.
- * Level_up contains the amount of levels that this
- * next element lies higher than the previous one.
- */
-
-static uint32_t
-ebml_peek_id (MatroskaDemuxContext *matroska,
-              int                  *level_up)
-{
-    uint32_t id;
-
-    assert(level_up != NULL);
-
-    if (ebml_read_element_id(matroska, &amp;id, level_up) &lt; 0)
-        return 0;
-
-    return id;
-}
-
-/*
- * Seek to a given offset.
- * 0 is success, -1 is failure.
- */
-
-static int
-ebml_read_seek (MatroskaDemuxContext *matroska,
-                offset_t              offset)
-{
-    ByteIOContext *pb = &amp;matroska-&gt;ctx-&gt;pb;
-
-    /* clear ID cache, if any */
-    matroska-&gt;peek_id = 0;
-
-    return (url_fseek(pb, offset, SEEK_SET) == offset) ? 0 : -1;
-}
-
-/*
- * Skip the next element.
- * 0 is success, -1 is failure.
- */
-
-static int
-ebml_read_skip (MatroskaDemuxContext *matroska)
-{
-    ByteIOContext *pb = &amp;matroska-&gt;ctx-&gt;pb;
-    uint32_t id;
-    uint64_t length;
-    int res;
-
-    if ((res = ebml_read_element_id(matroska, &amp;id, NULL)) &lt; 0 ||
-        (res = ebml_read_element_length(matroska, &amp;length)) &lt; 0)
-        return res;
-
-    url_fskip(pb, length);
-
-    return 0;
-}
-
-/*
- * Read the next element as an unsigned int.
- * 0 is success, &lt; 0 is failure.
- */
-
-static int
-ebml_read_uint (MatroskaDemuxContext *matroska,
-                uint32_t             *id,
-                uint64_t             *num)
-{
-    ByteIOContext *pb = &amp;matroska-&gt;ctx-&gt;pb;
-    int n = 0, size, res;
-    uint64_t rlength;
-
-    if ((res = ebml_read_element_id(matroska, id, NULL)) &lt; 0 ||
-        (res = ebml_read_element_length(matroska, &amp;rlength)) &lt; 0)
-        return res;
-    size = rlength;
-    if (size &lt; 1 || size &gt; 8) {
-        offset_t pos = url_ftell(pb);
-        av_log(matroska-&gt;ctx, AV_LOG_ERROR,
-               &quot;Invalid uint element size %d at position %&quot;PRId64&quot; (0x%&quot;PRIx64&quot;)\n&quot;,
-                size, pos, pos);
-        return AVERROR_INVALIDDATA;
-    }
-
-    /* big-endian ordening; build up number */
-    *num = 0;
-    while (n++ &lt; size)
-        *num = (*num &lt;&lt; 8) | get_byte(pb);
-
-    return 0;
-}
-
-/*
- * Read the next element as a signed int.
- * 0 is success, &lt; 0 is failure.
- */
-
-static int
-ebml_read_sint (MatroskaDemuxContext *matroska,
-                uint32_t             *id,
-                int64_t              *num)
-{
-    ByteIOContext *pb = &amp;matroska-&gt;ctx-&gt;pb;
-    int size, n = 1, negative = 0, res;
-    uint64_t rlength;
-
-    if ((res = ebml_read_element_id(matroska, id, NULL)) &lt; 0 ||
-        (res = ebml_read_element_length(matroska, &amp;rlength)) &lt; 0)
-        return res;
-    size = rlength;
-    if (size &lt; 1 || size &gt; 8) {
-        offset_t pos = url_ftell(pb);
-        av_log(matroska-&gt;ctx, AV_LOG_ERROR,
-               &quot;Invalid sint element size %d at position %&quot;PRId64&quot; (0x%&quot;PRIx64&quot;)\n&quot;,
-                size, pos, pos);
-        return AVERROR_INVALIDDATA;
-    }
-    if ((*num = get_byte(pb)) &amp; 0x80) {
-        negative = 1;
-        *num &amp;= ~0x80;
-    }
-    *num = 0;
-    while (n++ &lt; size)
-        *num = (*num &lt;&lt; 8) | get_byte(pb);
-
-    /* make signed */
-    if (negative)
-        *num = *num - (1LL &lt;&lt; ((8 * size) - 1));
-
-    return 0;
-}
-
-/*
- * Read the next element as a float.
- * 0 is success, &lt; 0 is failure.
- */
-
-static int
-ebml_read_float (MatroskaDemuxContext *matroska,
-                 uint32_t             *id,
-                 double               *num)
-{
-    ByteIOContext *pb = &amp;matroska-&gt;ctx-&gt;pb;
-    int size, res;
-    uint64_t rlength;
-
-    if ((res = ebml_read_element_id(matroska, id, NULL)) &lt; 0 ||
-        (res = ebml_read_element_length(matroska, &amp;rlength)) &lt; 0)
-        return res;
-    size = rlength;
-
-    if (size == 4) {
-        *num= av_int2flt(get_be32(pb));
-    } else if(size==8){
-        *num= av_int2dbl(get_be64(pb));
-    } else{
-        offset_t pos = url_ftell(pb);
-        av_log(matroska-&gt;ctx, AV_LOG_ERROR,
-               &quot;Invalid float element size %d at position %&quot;PRIu64&quot; (0x%&quot;PRIx64&quot;)\n&quot;,
-               size, pos, pos);
-        return AVERROR_INVALIDDATA;
-    }
-
-    return 0;
-}
-
-/*
- * Read the next element as an ASCII string.
- * 0 is success, &lt; 0 is failure.
- */
-
-static int
-ebml_read_ascii (MatroskaDemuxContext *matroska,
-                 uint32_t             *id,
-                 char                **str)
-{
-    ByteIOContext *pb = &amp;matroska-&gt;ctx-&gt;pb;
-    int size, res;
-    uint64_t rlength;
-
-    if ((res = ebml_read_element_id(matroska, id, NULL)) &lt; 0 ||
-        (res = ebml_read_element_length(matroska, &amp;rlength)) &lt; 0)
-        return res;
-    size = rlength;
-
-    /* ebml strings are usually not 0-terminated, so we allocate one
-     * byte more, read the string and NULL-terminate it ourselves. */
-    if (size &lt; 0 || !(*str = av_malloc(size + 1))) {
-        av_log(matroska-&gt;ctx, AV_LOG_ERROR, &quot;Memory allocation failed\n&quot;);
-        return AVERROR_NOMEM;
-    }
-    if (get_buffer(pb, (uint8_t *) *str, size) != size) {
-        offset_t pos = url_ftell(pb);
-        av_log(matroska-&gt;ctx, AV_LOG_ERROR,
-               &quot;Read error at pos. %&quot;PRIu64&quot; (0x%&quot;PRIx64&quot;)\n&quot;, pos, pos);
-        return AVERROR_IO;
-    }
-    (*str)[size] = '\0';
-
-    return 0;
-}
-
-/*
- * Read the next element as a UTF-8 string.
- * 0 is success, &lt; 0 is failure.
- */
-
-static int
-ebml_read_utf8 (MatroskaDemuxContext *matroska,
-                uint32_t             *id,
-                char                **str)
-{
-  return ebml_read_ascii(matroska, id, str);
-}
-
-/*
- * Read the next element as a date (nanoseconds since 1/1/2000).
- * 0 is success, &lt; 0 is failure.
- */
-
-static int
-ebml_read_date (MatroskaDemuxContext *matroska,
-                uint32_t             *id,
-                int64_t              *date)
-{
-  return ebml_read_sint(matroska, id, date);
-}
-
-/*
- * Read the next element, but only the header. The contents
- * are supposed to be sub-elements which can be read separately.
- * 0 is success, &lt; 0 is failure.
- */
-
-static int
-ebml_read_master (MatroskaDemuxContext *matroska,
-                  uint32_t             *id)
-{
-    ByteIOContext *pb = &amp;matroska-&gt;ctx-&gt;pb;
-    uint64_t length;
-    MatroskaLevel *level;
-    int res;
-
-    if ((res = ebml_read_element_id(matroska, id, NULL)) &lt; 0 ||
-        (res = ebml_read_element_length(matroska, &amp;length)) &lt; 0)
-        return res;
-
-    /* protect... (Heaven forbids that the '&gt;' is true) */
-    if (matroska-&gt;num_levels &gt;= EBML_MAX_DEPTH) {
-        av_log(matroska-&gt;ctx, AV_LOG_ERROR,
-               &quot;File moves beyond max. allowed depth (%d)\n&quot;, EBML_MAX_DEPTH);
-        return AVERROR_NOTSUPP;
-    }
-
-    /* remember level */
-    level = &amp;matroska-&gt;levels[matroska-&gt;num_levels++];
-    level-&gt;start = url_ftell(pb);
-    level-&gt;length = length;
-
-    return 0;
-}
-
-/*
- * Read the next element as binary data.
- * 0 is success, &lt; 0 is failure.
- */
-
-static int
-ebml_read_binary (MatroskaDemuxContext *matroska,
-                  uint32_t             *id,
-                  uint8_t             **binary,
-                  int                  *size)
-{
-    ByteIOContext *pb = &amp;matroska-&gt;ctx-&gt;pb;
-    uint64_t rlength;
-    int res;
-
-    if ((res = ebml_read_element_id(matroska, id, NULL)) &lt; 0 ||
-        (res = ebml_read_element_length(matroska, &amp;rlength)) &lt; 0)
-        return res;
-    *size = rlength;
-
-    if (!(*binary = av_malloc(*size))) {
-        av_log(matroska-&gt;ctx, AV_LOG_ERROR,
-               &quot;Memory allocation error\n&quot;);
-        return AVERROR_NOMEM;
-    }
-
-    if (get_buffer(pb, *binary, *size) != *size) {
-        offset_t pos = url_ftell(pb);
-        av_log(matroska-&gt;ctx, AV_LOG_ERROR,
-               &quot;Read error at pos. %&quot;PRIu64&quot; (0x%&quot;PRIx64&quot;)\n&quot;, pos, pos);
-        return AVERROR_IO;
-    }
-
-    return 0;
-}
-
-/*
- * Read signed/unsigned &quot;EBML&quot; numbers.
- * Return: number of bytes processed, &lt; 0 on error.
- * XXX: use ebml_read_num().
- */
-
-static int
-matroska_ebmlnum_uint (uint8_t  *data,
-                       uint32_t  size,
-                       uint64_t *num)
-{
-    int len_mask = 0x80, read = 1, n = 1, num_ffs = 0;
-    uint64_t total;
-
-    if (size &lt;= 0)
-        return AVERROR_INVALIDDATA;
-
-    total = data[0];
-    while (read &lt;= 8 &amp;&amp; !(total &amp; len_mask)) {
-        read++;
-        len_mask &gt;&gt;= 1;
-    }
-    if (read &gt; 8)
-        return AVERROR_INVALIDDATA;
-
-    if ((total &amp;= (len_mask - 1)) == len_mask - 1)
-        num_ffs++;
-    if (size &lt; read)
-        return AVERROR_INVALIDDATA;
-    while (n &lt; read) {
-        if (data[n] == 0xff)
-            num_ffs++;
-        total = (total &lt;&lt; 8) | data[n];
-        n++;
-    }
-
-    if (read == num_ffs)
-        *num = (uint64_t)-1;
-    else
-        *num = total;
-
-    return read;
-}
-
-/*
- * Same as above, but signed.
- */
-
-static int
-matroska_ebmlnum_sint (uint8_t  *data,
-                       uint32_t  size,
-                       int64_t  *num)
-{
-    uint64_t unum;
-    int res;
-
-    /* read as unsigned number first */
-    if ((res = matroska_ebmlnum_uint(data, size, &amp;unum)) &lt; 0)
-        return res;
-
-    /* make signed (weird way) */
-    if (unum == (uint64_t)-1)
-        *num = INT64_MAX;
-    else
-        *num = unum - ((1LL &lt;&lt; ((7 * res) - 1)) - 1);
-
-    return res;
-}
-
-/*
- * Read an EBML header.
- * 0 is success, &lt; 0 is failure.
- */
-
-static int
-ebml_read_header (MatroskaDemuxContext *matroska,
-                  char                **doctype,
-                  int                  *version)
-{
-    uint32_t id;
-    int level_up, res = 0;
-
-    /* default init */
-    if (doctype)
-        *doctype = NULL;
-    if (version)
-        *version = 1;
-
-    if (!(id = ebml_peek_id(matroska, &amp;level_up)) ||
-        level_up != 0 || id != EBML_ID_HEADER) {
-        av_log(matroska-&gt;ctx, AV_LOG_ERROR,
-               &quot;This is not an EBML file (id=0x%x/0x%x)\n&quot;, id, EBML_ID_HEADER);
-        return AVERROR_INVALIDDATA;
-    }
-    if ((res = ebml_read_master(matroska, &amp;id)) &lt; 0)
-        return res;
-
-    while (res == 0) {
-        if (!(id = ebml_peek_id(matroska, &amp;level_up)))
-            return AVERROR_IO;
-
-        /* end-of-header */
-        if (level_up)
-            break;
-
-        switch (id) {
-            /* is our read version uptodate? */
-            case EBML_ID_EBMLREADVERSION: {
-                uint64_t num;
-
-                if ((res = ebml_read_uint(matroska, &amp;id, &amp;num)) &lt; 0)
-                    return res;
-                if (num &gt; EBML_VERSION) {
-                    av_log(matroska-&gt;ctx, AV_LOG_ERROR,
-                           &quot;EBML version %&quot;PRIu64&quot; (&gt; %d) is not supported\n&quot;,
-                           num, EBML_VERSION);
-                    return AVERROR_INVALIDDATA;
-                }
-                break;
-            }
-
-            /* we only handle 8 byte lengths at max */
-            case EBML_ID_EBMLMAXSIZELENGTH: {
-                uint64_t num;
-
-                if ((res = ebml_read_uint(matroska, &amp;id, &amp;num)) &lt; 0)
-                    return res;
-                if (num &gt; sizeof(uint64_t)) {
-                    av_log(matroska-&gt;ctx, AV_LOG_ERROR,
-                           &quot;Integers of size %&quot;PRIu64&quot; (&gt; %zd) not supported\n&quot;,
-                           num, sizeof(uint64_t));
-                    return AVERROR_INVALIDDATA;
-                }
-                break;
-            }
-
-            /* we handle 4 byte IDs at max */
-            case EBML_ID_EBMLMAXIDLENGTH: {
-                uint64_t num;
-
-                if ((res = ebml_read_uint(matroska, &amp;id, &amp;num)) &lt; 0)
-                    return res;
-                if (num &gt; sizeof(uint32_t)) {
-                    av_log(matroska-&gt;ctx, AV_LOG_ERROR,
-                           &quot;IDs of size %&quot;PRIu64&quot; (&gt; %zu) not supported\n&quot;,
-                            num, sizeof(uint32_t));
-                    return AVERROR_INVALIDDATA;
-                }
-                break;
-            }
-
-            case EBML_ID_DOCTYPE: {
-                char *text;
-
-                if ((res = ebml_read_ascii(matroska, &amp;id, &amp;text)) &lt; 0)
-                    return res;
-                if (doctype) {
-                    if (*doctype)
-                        av_free(*doctype);
-                    *doctype = text;
-                } else
-                    av_free(text);
-                break;
-            }
-
-            case EBML_ID_DOCTYPEREADVERSION: {
-                uint64_t num;
-
-                if ((res = ebml_read_uint(matroska, &amp;id, &amp;num)) &lt; 0)
-                    return res;
-                if (version)
-                    *version = num;
-                break;
-            }
-
-            default:
-                av_log(matroska-&gt;ctx, AV_LOG_INFO,
-                       &quot;Unknown data type 0x%x in EBML header&quot;, id);
-                /* pass-through */
-
-            case EBML_ID_VOID:
-            /* we ignore these two, as they don't tell us anything we
-             * care about */
-            case EBML_ID_EBMLVERSION:
-            case EBML_ID_DOCTYPEVERSION:
-                res = ebml_read_skip (matroska);
-                break;
-        }
-    }
-
-    return 0;
-}
-
-/*
- * Put one packet in an application-supplied AVPacket struct.
- * Returns 0 on success or -1 on failure.
- */
-
-static int
-matroska_deliver_packet (MatroskaDemuxContext *matroska,
-                         AVPacket             *pkt)
-{
-    if (matroska-&gt;num_packets &gt; 0) {
-        memcpy(pkt, matroska-&gt;packets[0], sizeof(AVPacket));
-        av_free(matroska-&gt;packets[0]);
-        if (matroska-&gt;num_packets &gt; 1) {
-            memmove(&amp;matroska-&gt;packets[0], &amp;matroska-&gt;packets[1],
-                    (matroska-&gt;num_packets - 1) * sizeof(AVPacket *));
-            matroska-&gt;packets =
-                av_realloc(matroska-&gt;packets, (matroska-&gt;num_packets - 1) *
-                           sizeof(AVPacket *));
-        } else {
-            av_freep(&amp;matroska-&gt;packets);
-        }
-        matroska-&gt;num_packets--;
-        return 0;
-    }
-
-    return -1;
-}
-
-/*
- * Put a packet into our internal queue. Will be delivered to the
- * user/application during the next get_packet() call.
- */
-
-static void
-matroska_queue_packet (MatroskaDemuxContext *matroska,
-                       AVPacket             *pkt)
-{
-    matroska-&gt;packets =
-        av_realloc(matroska-&gt;packets, (matroska-&gt;num_packets + 1) *
-                   sizeof(AVPacket *));
-    matroska-&gt;packets[matroska-&gt;num_packets] = pkt;
-    matroska-&gt;num_packets++;
-}
-
-/*
- * Autodetecting...
- */
-
-static int
-matroska_probe (AVProbeData *p)
-{
-    uint64_t total = 0;
-    int len_mask = 0x80, size = 1, n = 1;
-    uint8_t probe_data[] = { 'm', 'a', 't', 'r', 'o', 's', 'k', 'a' };
-
-    if (p-&gt;buf_size &lt; 5)
-        return 0;
-
-    /* ebml header? */
-    if ((p-&gt;buf[0] &lt;&lt; 24 | p-&gt;buf[1] &lt;&lt; 16 |
-         p-&gt;buf[2] &lt;&lt; 8 | p-&gt;buf[3]) != EBML_ID_HEADER)
-        return 0;
-
-    /* length of header */
-    total = p-&gt;buf[4];
-    while (size &lt;= 8 &amp;&amp; !(total &amp; len_mask)) {
-        size++;
-        len_mask &gt;&gt;= 1;
-    }
-    if (size &gt; 8)
-      return 0;
-    total &amp;= (len_mask - 1);
-    while (n &lt; size)
-        total = (total &lt;&lt; 8) | p-&gt;buf[4 + n++];
-
-    /* does the probe data contain the whole header? */
-    if (p-&gt;buf_size &lt; 4 + size + total)
-      return 0;
-
-    /* the header must contain the document type 'matroska'. For now,
-     * we don't parse the whole header but simply check for the
-     * availability of that array of characters inside the header.
-     * Not fully fool-proof, but good enough. */
-    for (n = 4 + size; n &lt; 4 + size + total - sizeof(probe_data); n++)
-        if (!memcmp (&amp;p-&gt;buf[n], probe_data, sizeof(probe_data)))
-            return AVPROBE_SCORE_MAX;
-
-    return 0;
-}
-
-/*
- * From here on, it's all XML-style DTD stuff... Needs no comments.
- */
-
-static int
-matroska_parse_info (MatroskaDemuxContext *matroska)
-{
-    int res = 0;
-    uint32_t id;
-
-    av_log(matroska-&gt;ctx, AV_LOG_DEBUG, &quot;Parsing info...\n&quot;);
-
-    while (res == 0) {
-        if (!(id = ebml_peek_id(matroska, &amp;matroska-&gt;level_up))) {
-            res = AVERROR_IO;
-            break;
-        } else if (matroska-&gt;level_up) {
-            matroska-&gt;level_up--;
-            break;
-        }
-
-        switch (id) {
-            /* cluster timecode */
-            case MATROSKA_ID_TIMECODESCALE: {
-                uint64_t num;
-                if ((res = ebml_read_uint(matroska, &amp;id, &amp;num)) &lt; 0)
-                    break;
-                matroska-&gt;time_scale = num;
-                break;
-            }
-
-            case MATROSKA_ID_DURATION: {
-                double num;
-                if ((res = ebml_read_float(matroska, &amp;id, &amp;num)) &lt; 0)
-                    break;
-                matroska-&gt;ctx-&gt;duration = num * matroska-&gt;time_scale * 1000 / AV_TIME_BASE;
-                break;
-            }
-
-            case MATROSKA_ID_TITLE: {
-                char *text;
-                if ((res = ebml_read_utf8(matroska, &amp;id, &amp;text)) &lt; 0)
-                    break;
-                strncpy(matroska-&gt;ctx-&gt;title, text,
-                        sizeof(matroska-&gt;ctx-&gt;title)-1);
-                av_free(text);
-                break;
-            }
-
-            case MATROSKA_ID_WRITINGAPP: {
-                char *text;
-                if ((res = ebml_read_utf8(matroska, &amp;id, &amp;text)) &lt; 0)
-                    break;
-                matroska-&gt;writing_app = text;
-                break;
-            }
-
-            case MATROSKA_ID_MUXINGAPP: {
-                char *text;
-                if ((res = ebml_read_utf8(matroska, &amp;id, &amp;text)) &lt; 0)
-                    break;
-                matroska-&gt;muxing_app = text;
-                break;
-            }
-
-            case MATROSKA_ID_DATEUTC: {
-                int64_t time;
-                if ((res = ebml_read_date(matroska, &amp;id, &amp;time)) &lt; 0)
-                    break;
-                matroska-&gt;created = time;
-                break;
-            }
-
-            default:
-                av_log(matroska-&gt;ctx, AV_LOG_INFO,
-                       &quot;Unknown entry 0x%x in info header\n&quot;, id);
-                /* fall-through */
-
-            case EBML_ID_VOID:
-                res = ebml_read_skip(matroska);
-                break;
-        }
-
-        if (matroska-&gt;level_up) {
-            matroska-&gt;level_up--;
-            break;
-        }
-    }
-
-    return res;
-}
-
-static int
-matroska_add_stream (MatroskaDemuxContext *matroska)
-{
-    int res = 0;
-    uint32_t id;
-    MatroskaTrack *track;
-
-    av_log(matroska-&gt;ctx, AV_LOG_DEBUG, &quot;parsing track, adding stream..,\n&quot;);
-
-    /* Allocate a generic track. As soon as we know its type we'll realloc. */
-    track = av_mallocz(sizeof(MatroskaTrack));
-    matroska-&gt;num_tracks++;
-
-    /* start with the master */
-    if ((res = ebml_read_master(matroska, &amp;id)) &lt; 0)
-        return res;
-
-    /* try reading the trackentry headers */
-    while (res == 0) {
-        if (!(id = ebml_peek_id(matroska, &amp;matroska-&gt;level_up))) {
-            res = AVERROR_IO;
-            break;
-        } else if (matroska-&gt;level_up &gt; 0) {
-            matroska-&gt;level_up--;
-            break;
-        }
-
-        switch (id) {
-            /* track number (unique stream ID) */
-            case MATROSKA_ID_TRACKNUMBER: {
-                uint64_t num;
-                if ((res = ebml_read_uint(matroska, &amp;id, &amp;num)) &lt; 0)
-                    break;
-                track-&gt;num = num;
-                break;
-            }
-
-            /* track UID (unique identifier) */
-            case MATROSKA_ID_TRACKUID: {
-                uint64_t num;
-                if ((res = ebml_read_uint(matroska, &amp;id, &amp;num)) &lt; 0)
-                    break;
-                track-&gt;uid = num;
-                break;
-            }
-
-            /* track type (video, audio, combined, subtitle, etc.) */
-            case MATROSKA_ID_TRACKTYPE: {
-                uint64_t num;
-                if (track-&gt;type != 0) {
-                    av_log(matroska-&gt;ctx, AV_LOG_INFO,
-                           &quot;More than one tracktype in an entry - skip\n&quot;);
-                    break;
-                }
-                if ((res = ebml_read_uint(matroska, &amp;id, &amp;num)) &lt; 0)
-                    break;
-                track-&gt;type = num;
-
-                /* ok, so we're actually going to reallocate this thing */
-                switch (track-&gt;type) {
-                    case MATROSKA_TRACK_TYPE_VIDEO:
-                        track = (MatroskaTrack *)
-                            av_realloc(track, sizeof(MatroskaVideoTrack));
-                        break;
-                    case MATROSKA_TRACK_TYPE_AUDIO:
-                        track = (MatroskaTrack *)
-                            av_realloc(track, sizeof(MatroskaAudioTrack));
-                        ((MatroskaAudioTrack *)track)-&gt;channels = 1;
-                        ((MatroskaAudioTrack *)track)-&gt;samplerate = 8000;
-                        break;
-                    case MATROSKA_TRACK_TYPE_SUBTITLE:
-                        track = (MatroskaTrack *)
-                            av_realloc(track, sizeof(MatroskaSubtitleTrack));
-                        break;
-                    case MATROSKA_TRACK_TYPE_COMPLEX:
-                    case MATROSKA_TRACK_TYPE_LOGO:
-                    case MATROSKA_TRACK_TYPE_CONTROL:
-                    default:
-                        av_log(matroska-&gt;ctx, AV_LOG_INFO,
-                               &quot;Unknown or unsupported track type 0x%x\n&quot;,
-                               track-&gt;type);
-                        track-&gt;type = 0;
-                        break;
-                }
-                matroska-&gt;tracks[matroska-&gt;num_tracks - 1] = track;
-                break;
-            }
-
-            /* tracktype specific stuff for video */
-            case MATROSKA_ID_TRACKVIDEO: {
-                MatroskaVideoTrack *videotrack;
-                if (track-&gt;type != MATROSKA_TRACK_TYPE_VIDEO) {
-                    av_log(matroska-&gt;ctx, AV_LOG_INFO,
-                           &quot;video data in non-video track - ignoring\n&quot;);
-                    res = AVERROR_INVALIDDATA;
-                    break;
-                } else if ((res = ebml_read_master(matroska, &amp;id)) &lt; 0)
-                    break;
-                videotrack = (MatroskaVideoTrack *)track;
-
-                while (res == 0) {
-                    if (!(id = ebml_peek_id(matroska, &amp;matroska-&gt;level_up))) {
-                        res = AVERROR_IO;
-                        break;
-                    } else if (matroska-&gt;level_up &gt; 0) {
-                        matroska-&gt;level_up--;
-                        break;
-                    }
-
-                    switch (id) {
-                        /* fixme, this should be one-up, but I get it here */
-                        case MATROSKA_ID_TRACKDEFAULTDURATION: {
-                            uint64_t num;
-                            if ((res = ebml_read_uint (matroska, &amp;id,
-                                                       &amp;num)) &lt; 0)
-                                break;
-                            track-&gt;default_duration = num;
-                            break;
-                        }
-
-                        /* video framerate */
-                        case MATROSKA_ID_VIDEOFRAMERATE: {
-                            double num;
-                            if ((res = ebml_read_float(matroska, &amp;id,
-                                                       &amp;num)) &lt; 0)
-                                break;
-                            track-&gt;default_duration = 1000000000 * (1. / num);
-                            break;
-                        }
-
-                        /* width of the size to display the video at */
-                        case MATROSKA_ID_VIDEODISPLAYWIDTH: {
-                            uint64_t num;
-                            if ((res = ebml_read_uint(matroska, &amp;id,
-                                                      &amp;num)) &lt; 0)
-                                break;
-                            videotrack-&gt;display_width = num;
-                            break;
-                        }
-
-                        /* height of the size to display the video at */
-                        case MATROSKA_ID_VIDEODISPLAYHEIGHT: {
-                            uint64_t num;
-                            if ((res = ebml_read_uint(matroska, &amp;id,
-                                                      &amp;num)) &lt; 0)
-                                break;
-                            videotrack-&gt;display_height = num;
-                            break;
-                        }
-
-                        /* width of the video in the file */
-                        case MATROSKA_ID_VIDEOPIXELWIDTH: {
-                            uint64_t num;
-                            if ((res = ebml_read_uint(matroska, &amp;id,
-                                                      &amp;num)) &lt; 0)
-                                break;
-                            videotrack-&gt;pixel_width = num;
-                            break;
-                        }
-
-                        /* height of the video in the file */
-                        case MATROSKA_ID_VIDEOPIXELHEIGHT: {
-                            uint64_t num;
-                            if ((res = ebml_read_uint(matroska, &amp;id,
-                                                      &amp;num)) &lt; 0)
-                                break;
-                            videotrack-&gt;pixel_height = num;
-                            break;
-                        }
-
-                        /* whether the video is interlaced */
-                        case MATROSKA_ID_VIDEOFLAGINTERLACED: {
-                            uint64_t num;
-                            if ((res = ebml_read_uint(matroska, &amp;id,
-                                                      &amp;num)) &lt; 0)
-                                break;
-                            if (num)
-                                track-&gt;flags |=
-                                    MATROSKA_VIDEOTRACK_INTERLACED;
-                            else
-                                track-&gt;flags &amp;=
-                                    ~MATROSKA_VIDEOTRACK_INTERLACED;
-                            break;
-                        }
-
-                        /* stereo mode (whether the video has two streams,
-                         * where one is for the left eye and the other for
-                         * the right eye, which creates a 3D-like
-                         * effect) */
-                        case MATROSKA_ID_VIDEOSTEREOMODE: {
-                            uint64_t num;
-                            if ((res = ebml_read_uint(matroska, &amp;id,
-                                                      &amp;num)) &lt; 0)
-                                break;
-                            if (num != MATROSKA_EYE_MODE_MONO &amp;&amp;
-                                num != MATROSKA_EYE_MODE_LEFT &amp;&amp;
-                                num != MATROSKA_EYE_MODE_RIGHT &amp;&amp;
-                                num != MATROSKA_EYE_MODE_BOTH) {
-                                av_log(matroska-&gt;ctx, AV_LOG_INFO,
-                                       &quot;Ignoring unknown eye mode 0x%x\n&quot;,
-                                       (uint32_t) num);
-                                break;
-                            }
-                            videotrack-&gt;eye_mode = num;
-                            break;
-                        }
-
-                        /* aspect ratio behaviour */
-                        case MATROSKA_ID_VIDEOASPECTRATIO: {
-                            uint64_t num;
-                            if ((res = ebml_read_uint(matroska, &amp;id,
-                                                      &amp;num)) &lt; 0)
-                                break;
-                            if (num != MATROSKA_ASPECT_RATIO_MODE_FREE &amp;&amp;
-                                num != MATROSKA_ASPECT_RATIO_MODE_KEEP &amp;&amp;
-                                num != MATROSKA_ASPECT_RATIO_MODE_FIXED) {
-                                av_log(matroska-&gt;ctx, AV_LOG_INFO,
-                                       &quot;Ignoring unknown aspect ratio 0x%x\n&quot;,
-                                       (uint32_t) num);
-                                break;
-                            }
-                            videotrack-&gt;ar_mode = num;
-                            break;
-                        }
-
-                        /* colourspace (only matters for raw video)
-                         * fourcc */
-                        case MATROSKA_ID_VIDEOCOLOURSPACE: {
-                            uint64_t num;
-                            if ((res = ebml_read_uint(matroska, &amp;id,
-                                                      &amp;num)) &lt; 0)
-                                break;
-                            videotrack-&gt;fourcc = num;
-                            break;
-                        }
-
-                        default:
-                            av_log(matroska-&gt;ctx, AV_LOG_INFO,
-                                   &quot;Unknown video track header entry &quot;
-                                   &quot;0x%x - ignoring\n&quot;, id);
-                            /* pass-through */
-
-                        case EBML_ID_VOID:
-                            res = ebml_read_skip(matroska);
-                            break;
-                    }
-
-                    if (matroska-&gt;level_up) {
-                        matroska-&gt;level_up--;
-                        break;
-                    }
-                }
-                break;
-            }
-
-            /* tracktype specific stuff for audio */
-            case MATROSKA_ID_TRACKAUDIO: {
-                MatroskaAudioTrack *audiotrack;
-                if (track-&gt;type != MATROSKA_TRACK_TYPE_AUDIO) {
-                    av_log(matroska-&gt;ctx, AV_LOG_INFO,
-                           &quot;audio data in non-audio track - ignoring\n&quot;);
-                    res = AVERROR_INVALIDDATA;
-                    break;
-                } else if ((res = ebml_read_master(matroska, &amp;id)) &lt; 0)
-                    break;
-                audiotrack = (MatroskaAudioTrack *)track;
-
-                while (res == 0) {
-                    if (!(id = ebml_peek_id(matroska, &amp;matroska-&gt;level_up))) {
-                        res = AVERROR_IO;
-                        break;
-                    } else if (matroska-&gt;level_up &gt; 0) {
-                        matroska-&gt;level_up--;
-                        break;
-                    }
-
-                    switch (id) {
-                        /* samplerate */
-                        case MATROSKA_ID_AUDIOSAMPLINGFREQ: {
-                            double num;
-                            if ((res = ebml_read_float(matroska, &amp;id,
-                                                       &amp;num)) &lt; 0)
-                                break;
-                            audiotrack-&gt;internal_samplerate =
-                            audiotrack-&gt;samplerate = num;
-                            break;
-                        }
-
-                        case MATROSKA_ID_AUDIOOUTSAMPLINGFREQ: {
-                            double num;
-                            if ((res = ebml_read_float(matroska, &amp;id,
-                                                       &amp;num)) &lt; 0)
-                                break;
-                            audiotrack-&gt;samplerate = num;
-                            break;
-                        }
-
-                            /* bitdepth */
-                        case MATROSKA_ID_AUDIOBITDEPTH: {
-                            uint64_t num;
-                            if ((res = ebml_read_uint(matroska, &amp;id,
-                                                      &amp;num)) &lt; 0)
-                                break;
-                            audiotrack-&gt;bitdepth = num;
-                            break;
-                        }
-
-                            /* channels */
-                        case MATROSKA_ID_AUDIOCHANNELS: {
-                            uint64_t num;
-                            if ((res = ebml_read_uint(matroska, &amp;id,
-                                                      &amp;num)) &lt; 0)
-                                break;
-                            audiotrack-&gt;channels = num;
-                            break;
-                        }
-
-                        default:
-                            av_log(matroska-&gt;ctx, AV_LOG_INFO,
-                                   &quot;Unknown audio track header entry &quot;
-                                   &quot;0x%x - ignoring\n&quot;, id);
-                            /* pass-through */
-
-                        case EBML_ID_VOID:
-                            res = ebml_read_skip(matroska);
-                            break;
-                    }
-
-                    if (matroska-&gt;level_up) {
-                        matroska-&gt;level_up--;
-                        break;
-                    }
-                }
-                break;
-            }
-
-                /* codec identifier */
-            case MATROSKA_ID_CODECID: {
-                char *text;
-                if ((res = ebml_read_ascii(matroska, &amp;id, &amp;text)) &lt; 0)
-                    break;
-                track-&gt;codec_id = text;
-                break;
-            }
-
-                /* codec private data */
-            case MATROSKA_ID_CODECPRIVATE: {
-                uint8_t *data;
-                int size;
-                if ((res = ebml_read_binary(matroska, &amp;id, &amp;data, &amp;size) &lt; 0))
-                    break;
-                track-&gt;codec_priv = data;
-                track-&gt;codec_priv_size = size;
-                break;
-            }
-
-                /* name of the codec */
-            case MATROSKA_ID_CODECNAME: {
-                char *text;
-                if ((res = ebml_read_utf8(matroska, &amp;id, &amp;text)) &lt; 0)
-                    break;
-                track-&gt;codec_name = text;
-                break;
-            }
-
-                /* name of this track */
-            case MATROSKA_ID_TRACKNAME: {
-                char *text;
-                if ((res = ebml_read_utf8(matroska, &amp;id, &amp;text)) &lt; 0)
-                    break;
-                track-&gt;name = text;
-                break;
-            }
-
-                /* language (matters for audio/subtitles, mostly) */
-            case MATROSKA_ID_TRACKLANGUAGE: {
-                char *text;
-                if ((res = ebml_read_utf8(matroska, &amp;id, &amp;text)) &lt; 0)
-                    break;
-                track-&gt;language = text;
-                break;
-            }
-
-                /* whether this is actually used */
-            case MATROSKA_ID_TRACKFLAGENABLED: {
-                uint64_t num;
-                if ((res = ebml_read_uint(matroska, &amp;id, &amp;num)) &lt; 0)
-                    break;
-                if (num)
-                    track-&gt;flags |= MATROSKA_TRACK_ENABLED;
-                else
-                    track-&gt;flags &amp;= ~MATROSKA_TRACK_ENABLED;
-                break;
-            }
-
-                /* whether it's the default for this track type */
-            case MATROSKA_ID_TRACKFLAGDEFAULT: {
-                uint64_t num;
-                if ((res = ebml_read_uint(matroska, &amp;id, &amp;num)) &lt; 0)
-                    break;
-                if (num)
-                    track-&gt;flags |= MATROSKA_TRACK_DEFAULT;
-                else
-                    track-&gt;flags &amp;= ~MATROSKA_TRACK_DEFAULT;
-                break;
-            }
-
-                /* lacing (like MPEG, where blocks don't end/start on frame
-                 * boundaries) */
-            case MATROSKA_ID_TRACKFLAGLACING: {
-                uint64_t num;
-                if ((res = ebml_read_uint(matroska, &amp;id, &amp;num)) &lt; 0)
-                    break;
-                if (num)
-                    track-&gt;flags |= MATROSKA_TRACK_LACING;
-                else
-                    track-&gt;flags &amp;= ~MATROSKA_TRACK_LACING;
-                break;
-            }
-
-                /* default length (in time) of one data block in this track */
-            case MATROSKA_ID_TRACKDEFAULTDURATION: {
-                uint64_t num;
-                if ((res = ebml_read_uint(matroska, &amp;id, &amp;num)) &lt; 0)
-                    break;
-                track-&gt;default_duration = num;
-                break;
-            }
-
-            default:
-                av_log(matroska-&gt;ctx, AV_LOG_INFO,
-                       &quot;Unknown track header entry 0x%x - ignoring\n&quot;, id);
-                /* pass-through */
-
-            case EBML_ID_VOID:
-            /* we ignore these because they're nothing useful. */
-            case MATROSKA_ID_CODECINFOURL:
-            case MATROSKA_ID_CODECDOWNLOADURL:
-            case MATROSKA_ID_TRACKMINCACHE:
-            case MATROSKA_ID_TRACKMAXCACHE:
-                res = ebml_read_skip(matroska);
-                break;
-        }
-
-        if (matroska-&gt;level_up) {
-            matroska-&gt;level_up--;
-            break;
-        }
-    }
-
-    return res;
-}
-
-static int
-matroska_parse_tracks (MatroskaDemuxContext *matroska)
-{
-    int res = 0;
-    uint32_t id;
-
-    av_log(matroska-&gt;ctx, AV_LOG_DEBUG, &quot;parsing tracks...\n&quot;);
-
-    while (res == 0) {
-        if (!(id = ebml_peek_id(matroska, &amp;matroska-&gt;level_up))) {
-            res = AVERROR_IO;
-            break;
-        } else if (matroska-&gt;level_up) {
-            matroska-&gt;level_up--;
-            break;
-        }
-
-        switch (id) {
-            /* one track within the &quot;all-tracks&quot; header */
-            case MATROSKA_ID_TRACKENTRY:
-                res = matroska_add_stream(matroska);
-                break;
-
-            default:
-                av_log(matroska-&gt;ctx, AV_LOG_INFO,
-                       &quot;Unknown entry 0x%x in track header\n&quot;, id);
-                /* fall-through */
-
-            case EBML_ID_VOID:
-                res = ebml_read_skip(matroska);
-                break;
-        }
-
-        if (matroska-&gt;level_up) {
-            matroska-&gt;level_up--;
-            break;
-        }
-    }
-
-    return res;
-}
-
-static int
-matroska_parse_index (MatroskaDemuxContext *matroska)
-{
-    int res = 0;
-    uint32_t id;
-    MatroskaDemuxIndex idx;
-
-    av_log(matroska-&gt;ctx, AV_LOG_DEBUG, &quot;parsing index...\n&quot;);
-
-    while (res == 0) {
-        if (!(id = ebml_peek_id(matroska, &amp;matroska-&gt;level_up))) {
-            res = AVERROR_IO;
-            break;
-        } else if (matroska-&gt;level_up) {
-            matroska-&gt;level_up--;
-            break;
-        }
-
-        switch (id) {
-            /* one single index entry ('point') */
-            case MATROSKA_ID_POINTENTRY:
-                if ((res = ebml_read_master(matroska, &amp;id)) &lt; 0)
-                    break;
-
-                /* in the end, we hope to fill one entry with a
-                 * timestamp, a file position and a tracknum */
-                idx.pos   = (uint64_t) -1;
-                idx.time  = (uint64_t) -1;
-                idx.track = (uint16_t) -1;
-
-                while (res == 0) {
-                    if (!(id = ebml_peek_id(matroska, &amp;matroska-&gt;level_up))) {
-                        res = AVERROR_IO;
-                        break;
-                    } else if (matroska-&gt;level_up) {
-                        matroska-&gt;level_up--;
-                        break;
-                    }
-
-                    switch (id) {
-                        /* one single index entry ('point') */
-                        case MATROSKA_ID_CUETIME: {
-                            uint64_t time;
-                            if ((res = ebml_read_uint(matroska, &amp;id,
-                                                      &amp;time)) &lt; 0)
-                                break;
-                            idx.time = time * matroska-&gt;time_scale;
-                            break;
-                        }
-
-                        /* position in the file + track to which it
-                         * belongs */
-                        case MATROSKA_ID_CUETRACKPOSITION:
-                            if ((res = ebml_read_master(matroska, &amp;id)) &lt; 0)
-                                break;
-
-                            while (res == 0) {
-                                if (!(id = ebml_peek_id (matroska,
-                                                    &amp;matroska-&gt;level_up))) {
-                                    res = AVERROR_IO;
-                                    break;
-                                } else if (matroska-&gt;level_up) {
-                                    matroska-&gt;level_up--;
-                                    break;
-                                }
-
-                                switch (id) {
-                                    /* track number */
-                                    case MATROSKA_ID_CUETRACK: {
-                                        uint64_t num;
-                                        if ((res = ebml_read_uint(matroska,
-                                                          &amp;id, &amp;num)) &lt; 0)
-                                            break;
-                                        idx.track = num;
-                                        break;
-                                    }
-
-                                        /* position in file */
-                                    case MATROSKA_ID_CUECLUSTERPOSITION: {
-                                        uint64_t num;
-                                        if ((res = ebml_read_uint(matroska,
-                                                          &amp;id, &amp;num)) &lt; 0)
-                                            break;
-                                        idx.pos = num;
-                                        break;
-                                    }
-
-                                    default:
-                                        av_log(matroska-&gt;ctx, AV_LOG_INFO,
-                                               &quot;Unknown entry 0x%x in &quot;
-                                               &quot;CuesTrackPositions\n&quot;, id);
-                                        /* fall-through */
-
-                                    case EBML_ID_VOID:
-                                        res = ebml_read_skip(matroska);
-                                        break;
-                                }
-
-                                if (matroska-&gt;level_up) {
-                                    matroska-&gt;level_up--;
-                                    break;
-                                }
-                            }
-
-                            break;
-
-                        default:
-                            av_log(matroska-&gt;ctx, AV_LOG_INFO,
-                                   &quot;Unknown entry 0x%x in cuespoint &quot;
-                                   &quot;index\n&quot;, id);
-                            /* fall-through */
-
-                        case EBML_ID_VOID:
-                            res = ebml_read_skip(matroska);
-                            break;
-                    }
-
-                    if (matroska-&gt;level_up) {
-                        matroska-&gt;level_up--;
-                        break;
-                    }
-                }
-
-                /* so let's see if we got what we wanted */
-                if (idx.pos   != (uint64_t) -1 &amp;&amp;
-                    idx.time  != (uint64_t) -1 &amp;&amp;
-                    idx.track != (uint16_t) -1) {
-                    if (matroska-&gt;num_indexes % 32 == 0) {
-                        /* re-allocate bigger index */
-                        matroska-&gt;index =
-                            av_realloc(matroska-&gt;index,
-                                       (matroska-&gt;num_indexes + 32) *
-                                       sizeof(MatroskaDemuxIndex));
-                    }
-                    matroska-&gt;index[matroska-&gt;num_indexes] = idx;
-                    matroska-&gt;num_indexes++;
-                }
-                break;
-
-            default:
-                av_log(matroska-&gt;ctx, AV_LOG_INFO,
-                       &quot;Unknown entry 0x%x in cues header\n&quot;, id);
-                /* fall-through */
-
-            case EBML_ID_VOID:
-                res = ebml_read_skip(matroska);
-                break;
-        }
-
-        if (matroska-&gt;level_up) {
-            matroska-&gt;level_up--;
-            break;
-        }
-    }
-
-    return res;
-}
-
-static int
-matroska_parse_metadata (MatroskaDemuxContext *matroska)
-{
-    int res = 0;
-    uint32_t id;
-
-    while (res == 0) {
-        if (!(id = ebml_peek_id(matroska, &amp;matroska-&gt;level_up))) {
-            res = AVERROR_IO;
-            break;
-        } else if (matroska-&gt;level_up) {
-            matroska-&gt;level_up--;
-            break;
-        }
-
-        switch (id) {
-            /* Hm, this is unsupported... */
-            default:
-                av_log(matroska-&gt;ctx, AV_LOG_INFO,
-                       &quot;Unknown entry 0x%x in metadata header\n&quot;, id);
-                /* fall-through */
-
-            case EBML_ID_VOID:
-                res = ebml_read_skip(matroska);
-                break;
-        }
-
-        if (matroska-&gt;level_up) {
-            matroska-&gt;level_up--;
-            break;
-        }
-    }
-
-    return res;
-}
-
-static int
-matroska_parse_seekhead (MatroskaDemuxContext *matroska)
-{
-    int res = 0;
-    uint32_t id;
-
-    av_log(matroska-&gt;ctx, AV_LOG_DEBUG, &quot;parsing seekhead...\n&quot;);
-
-    while (res == 0) {
-        if (!(id = ebml_peek_id(matroska, &amp;matroska-&gt;level_up))) {
-            res = AVERROR_IO;
-            break;
-        } else if (matroska-&gt;level_up) {
-            matroska-&gt;level_up--;
-            break;
-        }
-
-        switch (id) {
-            case MATROSKA_ID_SEEKENTRY: {
-                uint32_t seek_id = 0, peek_id_cache = 0;
-                uint64_t seek_pos = (uint64_t) -1, t;
-
-                if ((res = ebml_read_master(matroska, &amp;id)) &lt; 0)
-                    break;
-
-                while (res == 0) {
-                    if (!(id = ebml_peek_id(matroska, &amp;matroska-&gt;level_up))) {
-                        res = AVERROR_IO;
-                        break;
-                    } else if (matroska-&gt;level_up) {
-                        matroska-&gt;level_up--;
-                        break;
-                    }
-
-                    switch (id) {
-                        case MATROSKA_ID_SEEKID:
-                            res = ebml_read_uint(matroska, &amp;id, &amp;t);
-                            seek_id = t;
-                            break;
-
-                        case MATROSKA_ID_SEEKPOSITION:
-                            res = ebml_read_uint(matroska, &amp;id, &amp;seek_pos);
-                            break;
-
-                        default:
-                            av_log(matroska-&gt;ctx, AV_LOG_INFO,
-                                   &quot;Unknown seekhead ID 0x%x\n&quot;, id);
-                            /* fall-through */
-
-                        case EBML_ID_VOID:
-                            res = ebml_read_skip(matroska);
-                            break;
-                    }
-
-                    if (matroska-&gt;level_up) {
-                        matroska-&gt;level_up--;
-                        break;
-                    }
-                }
-
-                if (!seek_id || seek_pos == (uint64_t) -1) {
-                    av_log(matroska-&gt;ctx, AV_LOG_INFO,
-                           &quot;Incomplete seekhead entry (0x%x/%&quot;PRIu64&quot;)\n&quot;,
-                           seek_id, seek_pos);
-                    break;
-                }
-
-                switch (seek_id) {
-                    case MATROSKA_ID_CUES:
-                    case MATROSKA_ID_TAGS: {
-                        uint32_t level_up = matroska-&gt;level_up;
-                        offset_t before_pos;
-                        uint64_t length;
-                        MatroskaLevel level;
-
-                        /* remember the peeked ID and the current position */
-                        peek_id_cache = matroska-&gt;peek_id;
-                        before_pos = url_ftell(&amp;matroska-&gt;ctx-&gt;pb);
-
-                        /* seek */
-                        if ((res = ebml_read_seek(matroska, seek_pos +
-                                               matroska-&gt;segment_start)) &lt; 0)
-                            return res;
-
-                        /* we don't want to lose our seekhead level, so we add
-                         * a dummy. This is a crude hack. */
-                        if (matroska-&gt;num_levels == EBML_MAX_DEPTH) {
-                            av_log(matroska-&gt;ctx, AV_LOG_INFO,
-                                   &quot;Max EBML element depth (%d) reached, &quot;
-                                   &quot;cannot parse further.\n&quot;, EBML_MAX_DEPTH);
-                            return AVERROR_UNKNOWN;
-                        }
-
-                        level.start = 0;
-                        level.length = (uint64_t)-1;
-                        matroska-&gt;levels[matroska-&gt;num_levels] = level;
-                        matroska-&gt;num_levels++;
-
-                        /* check ID */
-                        if (!(id = ebml_peek_id (matroska,
-                                                 &amp;matroska-&gt;level_up)))
-                            goto finish;
-                        if (id != seek_id) {
-                            av_log(matroska-&gt;ctx, AV_LOG_INFO,
-                                   &quot;We looked for ID=0x%x but got &quot;
-                                   &quot;ID=0x%x (pos=%&quot;PRIu64&quot;)&quot;,
-                                   seek_id, id, seek_pos +
-                                   matroska-&gt;segment_start);
-                            goto finish;
-                        }
-
-                        /* read master + parse */
-                        if ((res = ebml_read_master(matroska, &amp;id)) &lt; 0)
-                            goto finish;
-                        switch (id) {
-                            case MATROSKA_ID_CUES:
-                                if (!(res = matroska_parse_index(matroska)) ||
-                                    url_feof(&amp;matroska-&gt;ctx-&gt;pb)) {
-                                    matroska-&gt;index_parsed = 1;
-                                    res = 0;
-                                }
-                                break;
-                            case MATROSKA_ID_TAGS:
-                                if (!(res = matroska_parse_metadata(matroska)) ||
-                                   url_feof(&amp;matroska-&gt;ctx-&gt;pb)) {
-                                    matroska-&gt;metadata_parsed = 1;
-                                    res = 0;
-                                }
-                                break;
-                        }
-
-                    finish:
-                        /* remove dummy level */
-                        while (matroska-&gt;num_levels) {
-                            matroska-&gt;num_levels--;
-                            length =
-                                matroska-&gt;levels[matroska-&gt;num_levels].length;
-                            if (length == (uint64_t)-1)
-                                break;
-                        }
-
-                        /* seek back */
-                        if ((res = ebml_read_seek(matroska, before_pos)) &lt; 0)
-                            return res;
-                        matroska-&gt;peek_id = peek_id_cache;
-                        matroska-&gt;level_up = level_up;
-                        break;
-                    }
-
-                    default:
-                        av_log(matroska-&gt;ctx, AV_LOG_INFO,
-                               &quot;Ignoring seekhead entry for ID=0x%x\n&quot;,
-                               seek_id);
-                        break;
-                }
-
-                break;
-            }
-
-            default:
-                av_log(matroska-&gt;ctx, AV_LOG_INFO,
-                       &quot;Unknown seekhead ID 0x%x\n&quot;, id);
-                /* fall-through */
-
-            case EBML_ID_VOID:
-                res = ebml_read_skip(matroska);
-                break;
-        }
-
-        if (matroska-&gt;level_up) {
-            matroska-&gt;level_up--;
-            break;
-        }
-    }
-
-    return res;
-}
-
-#define ARRAY_SIZE(x)  (sizeof(x)/sizeof(*x))
-
-static int
-matroska_aac_profile (char *codec_id)
-{
-    static const char *aac_profiles[] = {
-        &quot;MAIN&quot;, &quot;LC&quot;, &quot;SSR&quot;
-    };
-    int profile;
-
-    for (profile=0; profile&lt;ARRAY_SIZE(aac_profiles); profile++)
-        if (strstr(codec_id, aac_profiles[profile]))
-            break;
-    return profile + 1;
-}
-
-static int
-matroska_aac_sri (int samplerate)
-{
-    static const int aac_sample_rates[] = {
-        96000, 88200, 64000, 48000, 44100, 32000,
-        24000, 22050, 16000, 12000, 11025,  8000,
-    };
-    int sri;
-
-    for (sri=0; sri&lt;ARRAY_SIZE(aac_sample_rates); sri++)
-        if (aac_sample_rates[sri] == samplerate)
-            break;
-    return sri;
-}
-
-static int
-matroska_read_header (AVFormatContext    *s,
-                      AVFormatParameters *ap)
-{
-    MatroskaDemuxContext *matroska = s-&gt;priv_data;
-    char *doctype;
-    int version, last_level, res = 0;
-    uint32_t id;
-
-    matroska-&gt;ctx = s;
-
-    /* First read the EBML header. */
-    doctype = NULL;
-    if ((res = ebml_read_header(matroska, &amp;doctype, &amp;version)) &lt; 0)
-        return res;
-    if ((doctype == NULL) || strcmp(doctype, &quot;matroska&quot;)) {
-        av_log(matroska-&gt;ctx, AV_LOG_ERROR,
-               &quot;Wrong EBML doctype ('%s' != 'matroska').\n&quot;,
-               doctype ? doctype : &quot;(none)&quot;);
-        if (doctype)
-            av_free(doctype);
-        return AVERROR_NOFMT;
-    }
-    av_free(doctype);
-    if (version != 1) {
-        av_log(matroska-&gt;ctx, AV_LOG_ERROR,
-               &quot;Matroska demuxer version 1 too old for file version %d\n&quot;,
-               version);
-        return AVERROR_NOFMT;
-    }
-
-    /* The next thing is a segment. */
-    while (1) {
-        if (!(id = ebml_peek_id(matroska, &amp;last_level)))
-            return AVERROR_IO;
-        if (id == MATROSKA_ID_SEGMENT)
-            break;
-
-        /* oi! */
-        av_log(matroska-&gt;ctx, AV_LOG_INFO,
-               &quot;Expected a Segment ID (0x%x), but received 0x%x!\n&quot;,
-               MATROSKA_ID_SEGMENT, id);
-        if ((res = ebml_read_skip(matroska)) &lt; 0)
-            return res;
-    }
-
-    /* We now have a Matroska segment.
-     * Seeks are from the beginning of the segment,
-     * after the segment ID/length. */
-    if ((res = ebml_read_master(matroska, &amp;id)) &lt; 0)
-        return res;
-    matroska-&gt;segment_start = url_ftell(&amp;s-&gt;pb);
-
-    matroska-&gt;time_scale = 1000000;
-    /* we've found our segment, start reading the different contents in here */
-    while (res == 0) {
-        if (!(id = ebml_peek_id(matroska, &amp;matroska-&gt;level_up))) {
-            res = AVERROR_IO;
-            break;
-        } else if (matroska-&gt;level_up) {
-            matroska-&gt;level_up--;
-            break;
-        }
-
-        switch (id) {
-            /* stream info */
-            case MATROSKA_ID_INFO: {
-                if ((res = ebml_read_master(matroska, &amp;id)) &lt; 0)
-                    break;
-                res = matroska_parse_info(matroska);
-                break;
-            }
-
-            /* track info headers */
-            case MATROSKA_ID_TRACKS: {
-                if ((res = ebml_read_master(matroska, &amp;id)) &lt; 0)
-                    break;
-                res = matroska_parse_tracks(matroska);
-                break;
-            }
-
-            /* stream index */
-            case MATROSKA_ID_CUES: {
-                if (!matroska-&gt;index_parsed) {
-                    if ((res = ebml_read_master(matroska, &amp;id)) &lt; 0)
-                        break;
-                    res = matroska_parse_index(matroska);
-                } else
-                    res = ebml_read_skip(matroska);
-                break;
-            }
-
-            /* metadata */
-            case MATROSKA_ID_TAGS: {
-                if (!matroska-&gt;metadata_parsed) {
-                    if ((res = ebml_read_master(matroska, &amp;id)) &lt; 0)
-                        break;
-                    res = matroska_parse_metadata(matroska);
-                } else
-                    res = ebml_read_skip(matroska);
-                break;
-            }
-
-            /* file index (if seekable, seek to Cues/Tags to parse it) */
-            case MATROSKA_ID_SEEKHEAD: {
-                if ((res = ebml_read_master(matroska, &amp;id)) &lt; 0)
-                    break;
-                res = matroska_parse_seekhead(matroska);
-                break;
-            }
-
-            case MATROSKA_ID_CLUSTER: {
-                /* Do not read the master - this will be done in the next
-                 * call to matroska_read_packet. */
-                res = 1;
-                break;
-            }
-
-            default:
-                av_log(matroska-&gt;ctx, AV_LOG_INFO,
-                       &quot;Unknown matroska file header ID 0x%x\n&quot;, id);
-            /* fall-through */
-
-            case EBML_ID_VOID:
-                res = ebml_read_skip(matroska);
-                break;
-        }
-
-        if (matroska-&gt;level_up) {
-            matroska-&gt;level_up--;
-            break;
-        }
-    }
-
-    /* Have we found a cluster? */
-    if (ebml_peek_id(matroska, NULL) == MATROSKA_ID_CLUSTER) {
-        int i, j;
-        MatroskaTrack *track;
-        AVStream *st;
-
-        for (i = 0; i &lt; matroska-&gt;num_tracks; i++) {
-            enum CodecID codec_id = CODEC_ID_NONE;
-            uint8_t *extradata = NULL;
-            int extradata_size = 0;
-            int extradata_offset = 0;
-            track = matroska-&gt;tracks[i];
-
-            /* libavformat does not really support subtitles.
-             * Also apply some sanity checks. */
-            if ((track-&gt;type == MATROSKA_TRACK_TYPE_SUBTITLE) ||
-                (track-&gt;codec_id == NULL))
-                continue;
-
-            for(j=0; codec_tags[j].str; j++){
-                if(!strncmp(codec_tags[j].str, track-&gt;codec_id,
-                            strlen(codec_tags[j].str))){
-                    codec_id= codec_tags[j].id;
-                    break;
-                }
-            }
-
-            /* Set the FourCC from the CodecID. */
-            /* This is the MS compatibility mode which stores a
-             * BITMAPINFOHEADER in the CodecPrivate. */
-            if (!strcmp(track-&gt;codec_id,
-                        MATROSKA_CODEC_ID_VIDEO_VFW_FOURCC) &amp;&amp;
-                (track-&gt;codec_priv_size &gt;= 40) &amp;&amp;
-                (track-&gt;codec_priv != NULL)) {
-                unsigned char *p;
-
-                /* Offset of biCompression. Stored in LE. */
-                p = (unsigned char *)track-&gt;codec_priv + 16;
-                ((MatroskaVideoTrack *)track)-&gt;fourcc = (p[3] &lt;&lt; 24) |
-                                 (p[2] &lt;&lt; 16) | (p[1] &lt;&lt; 8) | p[0];
-                codec_id = codec_get_bmp_id(((MatroskaVideoTrack *)track)-&gt;fourcc);
-
-            }
-
-            /* This is the MS compatibility mode which stores a
-             * WAVEFORMATEX in the CodecPrivate. */
-            else if (!strcmp(track-&gt;codec_id,
-                             MATROSKA_CODEC_ID_AUDIO_ACM) &amp;&amp;
-                (track-&gt;codec_priv_size &gt;= 18) &amp;&amp;
-                (track-&gt;codec_priv != NULL)) {
-                unsigned char *p;
-                uint16_t tag;
-
-                /* Offset of wFormatTag. Stored in LE. */
-                p = (unsigned char *)track-&gt;codec_priv;
-                tag = (p[1] &lt;&lt; 8) | p[0];
-                codec_id = codec_get_wav_id(tag);
-
-            }
-
-            else if (codec_id == CODEC_ID_AAC &amp;&amp; !track-&gt;codec_priv_size) {
-                MatroskaAudioTrack *audiotrack = (MatroskaAudioTrack *) track;
-                int profile = matroska_aac_profile(track-&gt;codec_id);
-                int sri = matroska_aac_sri(audiotrack-&gt;internal_samplerate);
-                extradata = av_malloc(5);
-                if (extradata == NULL)
-                    return AVERROR_NOMEM;
-                extradata[0] = (profile &lt;&lt; 3) | ((sri&amp;0x0E) &gt;&gt; 1);
-                extradata[1] = ((sri&amp;0x01) &lt;&lt; 7) | (audiotrack-&gt;channels&lt;&lt;3);
-                if (strstr(track-&gt;codec_id, &quot;SBR&quot;)) {
-                    sri = matroska_aac_sri(audiotrack-&gt;samplerate);
-                    extradata[2] = 0x56;
-                    extradata[3] = 0xE5;
-                    extradata[4] = 0x80 | (sri&lt;&lt;3);
-                    extradata_size = 5;
-                } else {
-                    extradata_size = 2;
-                }
-            }
-
-            else if (codec_id == CODEC_ID_TTA) {
-                MatroskaAudioTrack *audiotrack = (MatroskaAudioTrack *) track;
-                ByteIOContext b;
-                extradata_size = 30;
-                extradata = av_mallocz(extradata_size);
-                if (extradata == NULL)
-                    return AVERROR_NOMEM;
-                init_put_byte(&amp;b, extradata, extradata_size, 1,
-                              NULL, NULL, NULL, NULL);
-                put_buffer(&amp;b, (uint8_t *) &quot;TTA1&quot;, 4);
-                put_le16(&amp;b, 1);
-                put_le16(&amp;b, audiotrack-&gt;channels);
-                put_le16(&amp;b, audiotrack-&gt;bitdepth);
-                put_le32(&amp;b, audiotrack-&gt;samplerate);
-                put_le32(&amp;b, matroska-&gt;ctx-&gt;duration * audiotrack-&gt;samplerate);
-            }
-
-            else if (codec_id == CODEC_ID_RV10 || codec_id == CODEC_ID_RV20 ||
-                     codec_id == CODEC_ID_RV30 || codec_id == CODEC_ID_RV40) {
-                extradata_offset = 26;
-                track-&gt;codec_priv_size -= extradata_offset;
-                track-&gt;flags |= MATROSKA_TRACK_REAL_V;
-            }
-
-            if (codec_id == CODEC_ID_NONE) {
-                av_log(matroska-&gt;ctx, AV_LOG_INFO,
-                       &quot;Unknown/unsupported CodecID %s.\n&quot;,
-                       track-&gt;codec_id);
-            }
-
-            track-&gt;stream_index = matroska-&gt;num_streams;
-
-            matroska-&gt;num_streams++;
-            st = av_new_stream(s, track-&gt;stream_index);
-            if (st == NULL)
-                return AVERROR_NOMEM;
-            av_set_pts_info(st, 64, matroska-&gt;time_scale, 1000*1000*1000); /* 64 bit pts in ns */
-
-            st-&gt;codec-&gt;codec_id = codec_id;
-
-            if (track-&gt;default_duration)
-                av_reduce(&amp;st-&gt;codec-&gt;time_base.num, &amp;st-&gt;codec-&gt;time_base.den,
-                          track-&gt;default_duration, 1000000000, 30000);
-
-            if(extradata){
-                st-&gt;codec-&gt;extradata = extradata;
-                st-&gt;codec-&gt;extradata_size = extradata_size;
-            } else if(track-&gt;codec_priv &amp;&amp; track-&gt;codec_priv_size &gt; 0){
-                st-&gt;codec-&gt;extradata = av_malloc(track-&gt;codec_priv_size);
-                if(st-&gt;codec-&gt;extradata == NULL)
-                    return AVERROR_NOMEM;
-                st-&gt;codec-&gt;extradata_size = track-&gt;codec_priv_size;
-                memcpy(st-&gt;codec-&gt;extradata,track-&gt;codec_priv+extradata_offset,
-                       track-&gt;codec_priv_size);
-            }
-
-            if (track-&gt;type == MATROSKA_TRACK_TYPE_VIDEO) {
-                MatroskaVideoTrack *videotrack = (MatroskaVideoTrack *)track;
-
-                st-&gt;codec-&gt;codec_type = CODEC_TYPE_VIDEO;
-                st-&gt;codec-&gt;codec_tag = videotrack-&gt;fourcc;
-                st-&gt;codec-&gt;width = videotrack-&gt;pixel_width;
-                st-&gt;codec-&gt;height = videotrack-&gt;pixel_height;
-                if (videotrack-&gt;display_width == 0)
-                    videotrack-&gt;display_width= videotrack-&gt;pixel_width;
-                if (videotrack-&gt;display_height == 0)
-                    videotrack-&gt;display_height= videotrack-&gt;pixel_height;
-                av_reduce(&amp;st-&gt;codec-&gt;sample_aspect_ratio.num,
-                          &amp;st-&gt;codec-&gt;sample_aspect_ratio.den,
-                          st-&gt;codec-&gt;height * videotrack-&gt;display_width,
-                          st-&gt;codec-&gt; width * videotrack-&gt;display_height,
-                          255);
-            } else if (track-&gt;type == MATROSKA_TRACK_TYPE_AUDIO) {
-                MatroskaAudioTrack *audiotrack = (MatroskaAudioTrack *)track;
-
-                st-&gt;codec-&gt;codec_type = CODEC_TYPE_AUDIO;
-                st-&gt;codec-&gt;sample_rate = audiotrack-&gt;samplerate;
-                st-&gt;codec-&gt;channels = audiotrack-&gt;channels;
-            } else if (track-&gt;type == MATROSKA_TRACK_TYPE_SUBTITLE) {
-                st-&gt;codec-&gt;codec_type = CODEC_TYPE_SUBTITLE;
-            }
-
-            /* What do we do with private data? E.g. for Vorbis. */
-        }
-        res = 0;
-    }
-
-    return res;
-}
-
-static int
-matroska_find_track_by_num (MatroskaDemuxContext *matroska,
-                            int                   num)
-{
-    int i;
-
-    for (i = 0; i &lt; matroska-&gt;num_tracks; i++)
-        if (matroska-&gt;tracks[i]-&gt;num == num)
-            return i;
-
-    return -1;
-}
-
-static inline int
-rv_offset(uint8_t *data, int slice, int slices)
-{
-    return AV_RL32(data+8*slice+4) + 8*slices;
-}
-
-static int
-matroska_parse_blockgroup (MatroskaDemuxContext *matroska,
-                           uint64_t              cluster_time)
-{
-    int res = 0;
-    uint32_t id;
-    AVPacket *pkt = NULL;
-    int is_keyframe = PKT_FLAG_KEY, last_num_packets = matroska-&gt;num_packets;
-    uint64_t duration = AV_NOPTS_VALUE;
-    int track = -1;
-
-    av_log(matroska-&gt;ctx, AV_LOG_DEBUG, &quot;parsing blockgroup...\n&quot;);
-
-    while (res == 0) {
-        if (!(id = ebml_peek_id(matroska, &amp;matroska-&gt;level_up))) {
-            res = AVERROR_IO;
-            break;
-        } else if (matroska-&gt;level_up) {
-            matroska-&gt;level_up--;
-            break;
-        }
-
-        switch (id) {
-            /* one block inside the group. Note, block parsing is one
-             * of the harder things, so this code is a bit complicated.
-             * See <A HREF="http://www.matroska.org/">http://www.matroska.org/</A> for documentation. */
-            case MATROSKA_ID_BLOCK: {
-                uint8_t *data, *origdata;
-                int size;
-                int16_t block_time;
-                uint32_t *lace_size = NULL;
-                int n, flags, laces = 0;
-                uint64_t num;
-                int64_t pos= url_ftell(&amp;matroska-&gt;ctx-&gt;pb);
-
-                if ((res = ebml_read_binary(matroska, &amp;id, &amp;data, &amp;size)) &lt; 0)
-                    break;
-                origdata = data;
-
-                /* first byte(s): tracknum */
-                if ((n = matroska_ebmlnum_uint(data, size, &amp;num)) &lt; 0) {
-                    av_log(matroska-&gt;ctx, AV_LOG_ERROR,
-                           &quot;EBML block data error\n&quot;);
-                    av_free(origdata);
-                    break;
-                }
-                data += n;
-                size -= n;
-
-                /* fetch track from num */
-                track = matroska_find_track_by_num(matroska, num);
-                if (size &lt;= 3 || track &lt; 0 || track &gt;= matroska-&gt;num_tracks) {
-                    av_log(matroska-&gt;ctx, AV_LOG_INFO,
-                           &quot;Invalid stream %d or size %u\n&quot;, track, size);
-                    av_free(origdata);
-                    break;
-                }
-                if(matroska-&gt;ctx-&gt;streams[ matroska-&gt;tracks[track]-&gt;stream_index ]-&gt;discard &gt;= AVDISCARD_ALL){
-                    av_free(origdata);
-                    break;
-                }
-
-                /* block_time (relative to cluster time) */
-                block_time = (data[0] &lt;&lt; 8) | data[1];
-                data += 2;
-                size -= 2;
-                flags = *data;
-                data += 1;
-                size -= 1;
-                switch ((flags &amp; 0x06) &gt;&gt; 1) {
-                    case 0x0: /* no lacing */
-                        laces = 1;
-                        lace_size = av_mallocz(sizeof(int));
-                        lace_size[0] = size;
-                        break;
-
-                    case 0x1: /* xiph lacing */
-                    case 0x2: /* fixed-size lacing */
-                    case 0x3: /* EBML lacing */
-                        if (size == 0) {
-                            res = -1;
-                            break;
-                        }
-                        laces = (*data) + 1;
-                        data += 1;
-                        size -= 1;
-                        lace_size = av_mallocz(laces * sizeof(int));
-
-                        switch ((flags &amp; 0x06) &gt;&gt; 1) {
-                            case 0x1: /* xiph lacing */ {
-                                uint8_t temp;
-                                uint32_t total = 0;
-                                for (n = 0; res == 0 &amp;&amp; n &lt; laces - 1; n++) {
-                                    while (1) {
-                                        if (size == 0) {
-                                            res = -1;
-                                            break;
-                                        }
-                                        temp = *data;
-                                        lace_size[n] += temp;
-                                        data += 1;
-                                        size -= 1;
-                                        if (temp != 0xff)
-                                            break;
-                                    }
-                                    total += lace_size[n];
-                                }
-                                lace_size[n] = size - total;
-                                break;
-                            }
-
-                            case 0x2: /* fixed-size lacing */
-                                for (n = 0; n &lt; laces; n++)
-                                    lace_size[n] = size / laces;
-                                break;
-
-                            case 0x3: /* EBML lacing */ {
-                                uint32_t total;
-                                n = matroska_ebmlnum_uint(data, size, &amp;num);
-                                if (n &lt; 0) {
-                                    av_log(matroska-&gt;ctx, AV_LOG_INFO,
-                                           &quot;EBML block data error\n&quot;);
-                                    break;
-                                }
-                                data += n;
-                                size -= n;
-                                total = lace_size[0] = num;
-                                for (n = 1; res == 0 &amp;&amp; n &lt; laces - 1; n++) {
-                                    int64_t snum;
-                                    int r;
-                                    r = matroska_ebmlnum_sint (data, size,
-                                                               &amp;snum);
-                                    if (r &lt; 0) {
-                                        av_log(matroska-&gt;ctx, AV_LOG_INFO,
-                                               &quot;EBML block data error\n&quot;);
-                                        break;
-                                    }
-                                    data += r;
-                                    size -= r;
-                                    lace_size[n] = lace_size[n - 1] + snum;
-                                    total += lace_size[n];
-                                }
-                                lace_size[n] = size - total;
-                                break;
-                            }
-                        }
-                        break;
-                }
-
-                if (res == 0) {
-                    int real_v = matroska-&gt;tracks[track]-&gt;flags &amp; MATROSKA_TRACK_REAL_V;
-                    for (n = 0; n &lt; laces; n++) {
-                        uint64_t timecode = AV_NOPTS_VALUE;
-                        int slice, slices = 1;
-
-                        if (real_v) {
-                            slices = *data++ + 1;
-                            lace_size[n]--;
-                        }
-                        if (cluster_time != (uint64_t)-1 &amp;&amp; n == 0) {
-                            if (cluster_time + block_time &gt;= 0)
-                                timecode = (cluster_time + block_time) * matroska-&gt;time_scale;
-                        }
-                        /* FIXME: duration */
-
-                        for (slice=0; slice&lt;slices; slice++) {
-                            int slice_size, slice_offset = 0;
-                            if (real_v)
-                                slice_offset = rv_offset(data, slice, slices);
-                            if (slice+1 == slices)
-                                slice_size = lace_size[n] - slice_offset;
-                            else
-                                slice_size = rv_offset(data, slice+1, slices) - slice_offset;
-                            pkt = av_mallocz(sizeof(AVPacket));
-                            /* XXX: prevent data copy... */
-                            if (av_new_packet(pkt, slice_size) &lt; 0) {
-                                res = AVERROR_NOMEM;
-                                n = laces-1;
-                                break;
-                            }
-                            memcpy (pkt-&gt;data, data+slice_offset, slice_size);
-
-                            if (n == 0)
-                                pkt-&gt;flags = is_keyframe;
-                            pkt-&gt;stream_index =
-                                matroska-&gt;tracks[track]-&gt;stream_index;
-
-                            pkt-&gt;pts = timecode;
-                            pkt-&gt;pos = pos;
-
-                            matroska_queue_packet(matroska, pkt);
-                        }
-                        data += lace_size[n];
-                    }
-                }
-
-                av_free(lace_size);
-                av_free(origdata);
-                break;
-            }
-
-            case MATROSKA_ID_BLOCKDURATION: {
-                if ((res = ebml_read_uint(matroska, &amp;id, &amp;duration)) &lt; 0)
-                    break;
-                break;
-            }
-
-            case MATROSKA_ID_BLOCKREFERENCE:
-                /* We've found a reference, so not even the first frame in
-                 * the lace is a key frame. */
-                is_keyframe = 0;
-                if (last_num_packets != matroska-&gt;num_packets)
-                    matroska-&gt;packets[last_num_packets]-&gt;flags = 0;
-                res = ebml_read_skip(matroska);
-                break;
-
-            default:
-                av_log(matroska-&gt;ctx, AV_LOG_INFO,
-                       &quot;Unknown entry 0x%x in blockgroup data\n&quot;, id);
-                /* fall-through */
-
-            case EBML_ID_VOID:
-                res = ebml_read_skip(matroska);
-                break;
-        }
-
-        if (matroska-&gt;level_up) {
-            matroska-&gt;level_up--;
-            break;
-        }
-    }
-
-    if (pkt)
-    {
-        if (duration != AV_NOPTS_VALUE)
-            pkt-&gt;duration = duration;
-        else if (track &gt;= 0 &amp;&amp; track &lt; matroska-&gt;num_tracks)
-            pkt-&gt;duration = matroska-&gt;tracks[track]-&gt;default_duration / matroska-&gt;time_scale;
-    }
-
-    return res;
-}
-
-static int
-matroska_parse_cluster (MatroskaDemuxContext *matroska)
-{
-    int res = 0;
-    uint32_t id;
-    uint64_t cluster_time = 0;
-
-    av_log(matroska-&gt;ctx, AV_LOG_DEBUG,
-           &quot;parsing cluster at %&quot;PRId64&quot;\n&quot;, url_ftell(&amp;matroska-&gt;ctx-&gt;pb));
-
-    while (res == 0) {
-        if (!(id = ebml_peek_id(matroska, &amp;matroska-&gt;level_up))) {
-            res = AVERROR_IO;
-            break;
-        } else if (matroska-&gt;level_up) {
-            matroska-&gt;level_up--;
-            break;
-        }
-
-        switch (id) {
-            /* cluster timecode */
-            case MATROSKA_ID_CLUSTERTIMECODE: {
-                uint64_t num;
-                if ((res = ebml_read_uint(matroska, &amp;id, &amp;num)) &lt; 0)
-                    break;
-                cluster_time = num;
-                break;
-            }
-
-                /* a group of blocks inside a cluster */
-            case MATROSKA_ID_BLOCKGROUP:
-                if ((res = ebml_read_master(matroska, &amp;id)) &lt; 0)
-                    break;
-                res = matroska_parse_blockgroup(matroska, cluster_time);
-                break;
-
-            default:
-                av_log(matroska-&gt;ctx, AV_LOG_INFO,
-                       &quot;Unknown entry 0x%x in cluster data\n&quot;, id);
-                /* fall-through */
-
-            case EBML_ID_VOID:
-                res = ebml_read_skip(matroska);
-                break;
-        }
-
-        if (matroska-&gt;level_up) {
-            matroska-&gt;level_up--;
-            break;
-        }
-    }
-
-    return res;
-}
-
-static int
-matroska_read_packet (AVFormatContext *s,
-                      AVPacket        *pkt)
-{
-    MatroskaDemuxContext *matroska = s-&gt;priv_data;
-    int res = 0;
-    uint32_t id;
-
-    /* Do we still have a packet queued? */
-    if (matroska_deliver_packet(matroska, pkt) == 0)
-        return 0;
-
-    /* Have we already reached the end? */
-    if (matroska-&gt;done)
-        return AVERROR_IO;
-
-    while (res == 0) {
-        if (!(id = ebml_peek_id(matroska, &amp;matroska-&gt;level_up))) {
-            res = AVERROR_IO;
-            break;
-        } else if (matroska-&gt;level_up) {
-            matroska-&gt;level_up--;
-            break;
-        }
-
-        switch (id) {
-            case MATROSKA_ID_CLUSTER:
-                if ((res = ebml_read_master(matroska, &amp;id)) &lt; 0)
-                    break;
-                if ((res = matroska_parse_cluster(matroska)) == 0)
-                    res = 1; /* Parsed one cluster, let's get out. */
-                break;
-
-            default:
-            case EBML_ID_VOID:
-                res = ebml_read_skip(matroska);
-                break;
-        }
-
-        if (matroska-&gt;level_up) {
-            matroska-&gt;level_up--;
-            break;
-        }
-    }
-
-    if (res == -1)
-        matroska-&gt;done = 1;
-
-    return matroska_deliver_packet(matroska, pkt);
-}
-
-static int
-matroska_read_close (AVFormatContext *s)
-{
-    MatroskaDemuxContext *matroska = s-&gt;priv_data;
-    int n = 0;
-
-    av_free(matroska-&gt;writing_app);
-    av_free(matroska-&gt;muxing_app);
-    av_free(matroska-&gt;index);
-
-    if (matroska-&gt;packets != NULL) {
-        for (n = 0; n &lt; matroska-&gt;num_packets; n++) {
-            av_free_packet(matroska-&gt;packets[n]);
-            av_free(matroska-&gt;packets[n]);
-        }
-        av_free(matroska-&gt;packets);
-    }
-
-    for (n = 0; n &lt; matroska-&gt;num_tracks; n++) {
-        MatroskaTrack *track = matroska-&gt;tracks[n];
-        av_free(track-&gt;codec_id);
-        av_free(track-&gt;codec_name);
-        av_free(track-&gt;codec_priv);
-        av_free(track-&gt;name);
-        av_free(track-&gt;language);
-
-        av_free(track);
-    }
-
-    return 0;
-}
-
-AVInputFormat matroska_demuxer = {
-    &quot;matroska&quot;,
-    &quot;Matroska file format&quot;,
-    sizeof(MatroskaDemuxContext),
-    matroska_probe,
-    matroska_read_header,
-    matroska_read_packet,
-    matroska_read_close,
-};

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/mov.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/mov.c	2007-07-16 16:39:52 UTC (rev 3382)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/mov.c	2007-07-16 17:44:22 UTC (rev 3383)
@@ -38,16 +38,8 @@
  *
  * Features and limitations:
  * - reads most of the QT files I have (at least the structure),
- *   the exceptions are .mov with zlib compressed headers ('cmov' section). It shouldn't be hard to implement.
- *   FIXED, Francois Revol, 07/17/2002
- * - ffmpeg has nearly none of the usual QuickTime codecs,
- *   although I succesfully dumped raw and mp3 audio tracks off .mov files.
  *   Sample QuickTime files with mp3 audio can be found at: <A HREF="http://www.3ivx.com/showcase.html">http://www.3ivx.com/showcase.html</A>
- * - .mp4 parsing is still hazardous, although the format really is QuickTime with some minor changes
- *   (to make .mov parser crash maybe ?), despite what they say in the MPEG FAQ at
- *   <A HREF="http://mpeg.telecomitalialab.com/faq.htm">http://mpeg.telecomitalialab.com/faq.htm</A>
  * - the code is quite ugly... maybe I won't do it recursive next time :-)
- * - seek is not supported with files that contain edit list
  *
  * Funny I didn't know about <A HREF="http://sourceforge.net/projects/qt-ffmpeg/">http://sourceforge.net/projects/qt-ffmpeg/</A>
  * when coding this :) (it's a writer anyway)
@@ -66,109 +58,16 @@
 #undef NDEBUG
 #include &lt;assert.h&gt;
 
-static const AVCodecTag mov_video_tags[] = {
-/*  { CODEC_ID_, MKTAG('c', 'v', 'i', 'd') }, *//* Cinepak */
-/*  { CODEC_ID_H263, MKTAG('r', 'a', 'w', ' ') }, *//* Uncompressed RGB */
-/*  { CODEC_ID_H263, MKTAG('Y', 'u', 'v', '2') }, *//* Uncompressed YUV422 */
-/*    { CODEC_ID_RAWVIDEO, MKTAG('A', 'V', 'U', 'I') }, *//* YUV with alpha-channel (AVID Uncompressed) */
-/* Graphics */
-/* Animation */
-/* Apple video */
-/* Kodak Photo CD */
-    { CODEC_ID_MJPEG, MKTAG('j', 'p', 'e', 'g') }, /* PhotoJPEG */
-    { CODEC_ID_MPEG1VIDEO, MKTAG('m', 'p', 'e', 'g') }, /* MPEG */
-    { CODEC_ID_MJPEG, MKTAG('m', 'j', 'p', 'a') }, /* Motion-JPEG (format A) */
-    { CODEC_ID_MJPEGB, MKTAG('m', 'j', 'p', 'b') }, /* Motion-JPEG (format B) */
-    { CODEC_ID_MJPEG, MKTAG('A', 'V', 'D', 'J') }, /* MJPEG with alpha-channel (AVID JFIF meridien compressed) */
-/*    { CODEC_ID_MJPEG, MKTAG('A', 'V', 'R', 'n') }, *//* MJPEG with alpha-channel (AVID ABVB/Truevision NuVista) */
-    { CODEC_ID_GIF, MKTAG('g', 'i', 'f', ' ') }, /* embedded gif files as frames (usually one &quot;click to play movie&quot; frame) */
-/* Sorenson video */
-    { CODEC_ID_SVQ1, MKTAG('S', 'V', 'Q', '1') }, /* Sorenson Video v1 */
-    { CODEC_ID_SVQ1, MKTAG('s', 'v', 'q', '1') }, /* Sorenson Video v1 */
-    { CODEC_ID_SVQ1, MKTAG('s', 'v', 'q', 'i') }, /* Sorenson Video v1 (from QT specs)*/
-    { CODEC_ID_SVQ3, MKTAG('S', 'V', 'Q', '3') }, /* Sorenson Video v3 */
-    { CODEC_ID_MPEG4, MKTAG('m', 'p', '4', 'v') },
-    { CODEC_ID_MPEG4, MKTAG('D', 'I', 'V', 'X') }, /* OpenDiVX *//* sample files at <A HREF="http://heroinewarrior.com/xmovie.php3">http://heroinewarrior.com/xmovie.php3</A> use this tag */
-    { CODEC_ID_MPEG4, MKTAG('X', 'V', 'I', 'D') },
-    { CODEC_ID_MPEG4, MKTAG('3', 'I', 'V', '2') }, /* experimental: 3IVX files before ivx D4 4.5.1 */
-/*    { CODEC_ID_, MKTAG('I', 'V', '5', '0') }, *//* Indeo 5.0 */
-    { CODEC_ID_H263, MKTAG('h', '2', '6', '3') }, /* H263 */
-    { CODEC_ID_H263, MKTAG('s', '2', '6', '3') }, /* H263 ?? works */
-    { CODEC_ID_DVVIDEO, MKTAG('d', 'v', 'c', ' ') }, /* DV NTSC */
-    { CODEC_ID_DVVIDEO, MKTAG('d', 'v', 'c', 'p') }, /* DV PAL */
-    { CODEC_ID_VP3, MKTAG('V', 'P', '3', '1') }, /* On2 VP3 */
-    { CODEC_ID_RPZA, MKTAG('r', 'p', 'z', 'a') }, /* Apple Video (RPZA) */
-    { CODEC_ID_CINEPAK, MKTAG('c', 'v', 'i', 'd') }, /* Cinepak */
-    { CODEC_ID_8BPS, MKTAG('8', 'B', 'P', 'S') }, /* Planar RGB (8BPS) */
-    { CODEC_ID_SMC, MKTAG('s', 'm', 'c', ' ') }, /* Apple Graphics (SMC) */
-    { CODEC_ID_QTRLE, MKTAG('r', 'l', 'e', ' ') }, /* Apple Animation (RLE) */
-    { CODEC_ID_MSRLE, MKTAG('W', 'R', 'L', 'E') },
-    { CODEC_ID_QDRAW, MKTAG('q', 'd', 'r', 'w') }, /* QuickDraw */
-    { CODEC_ID_H264, MKTAG('a', 'v', 'c', '1') }, /* AVC-1/H.264 */
-    { CODEC_ID_MPEG2VIDEO, MKTAG('h', 'd', 'v', '2') }, /* MPEG2 produced by Sony HD camera */
-    { CODEC_ID_MPEG2VIDEO, MKTAG('h', 'd', 'v', '3') }, /* HDV produced by FCP */
-    { CODEC_ID_MPEG2VIDEO, MKTAG('m', 'x', '5', 'n') }, /* MPEG2 IMX NTSC 525/60 50mb/s produced by FCP */
-    { CODEC_ID_MPEG2VIDEO, MKTAG('m', 'x', '5', 'p') }, /* MPEG2 IMX PAL 625/50 50mb/s produced by FCP */
-    { CODEC_ID_MPEG2VIDEO, MKTAG('m', 'x', '3', 'n') }, /* MPEG2 IMX NTSC 525/60 30mb/s produced by FCP */
-    { CODEC_ID_MPEG2VIDEO, MKTAG('m', 'x', '3', 'p') }, /* MPEG2 IMX PAL 625/50 30mb/s produced by FCP */
-    { CODEC_ID_DVVIDEO, MKTAG('d', 'v', 'p', 'p') }, /* DVCPRO PAL produced by FCP */
-    //{ CODEC_ID_DVVIDEO, MKTAG('d', 'v', 'h', '5') }, /* DVCPRO HD 50i produced by FCP */
-    //{ CODEC_ID_DVVIDEO, MKTAG('d', 'v', 'h', '6') }, /* DVCPRO HD 60i produced by FCP */
-    { CODEC_ID_DVVIDEO, MKTAG('d', 'v', '5', 'p') }, /* DVCPRO50 PAL produced by FCP */
-    { CODEC_ID_DVVIDEO, MKTAG('d', 'v', '5', 'n') }, /* DVCPRO50 NTSC produced by FCP */
-    { CODEC_ID_DVVIDEO, MKTAG('A', 'V', 'd', 'v') }, /* AVID DV */
-    //{ CODEC_ID_JPEG2000, MKTAG('m', 'j', 'p', '2') }, /* JPEG 2000 produced by FCP */
-    { CODEC_ID_TARGA, MKTAG('t', 'g', 'a', ' ') }, /* Truevision Targa */
-    { CODEC_ID_TIFF, MKTAG('t', 'i', 'f', 'f') }, /* TIFF embedded in MOV */
-    { CODEC_ID_RAWVIDEO, MKTAG('2', 'v', 'u', 'y') }, /* UNCOMPRESSED 8BIT 4:2:2 */
-    { CODEC_ID_VC1,  MKTAG('v', 'c', '-', '1') }, /* SMPTE RP 2025 */
-    { CODEC_ID_WMV3, MKTAG('v', 'c', '-', '1') }, /* SMPTE RP 2025 */
-    { CODEC_ID_PNG,  MKTAG('p', 'n', 'g', ' ') },
-    { CODEC_ID_NONE, 0 },
-};
-
-static const AVCodecTag mov_audio_tags[] = {
-    { CODEC_ID_PCM_S32BE, MKTAG('i', 'n', '3', '2') },
-    { CODEC_ID_PCM_S24BE, MKTAG('i', 'n', '2', '4') },
-    { CODEC_ID_PCM_S16BE, MKTAG('N', 'O', 'N', 'E') }, /* uncompressed */
-    { CODEC_ID_PCM_S16BE, MKTAG('t', 'w', 'o', 's') }, /* 16 bits */
-    { CODEC_ID_PCM_U8, MKTAG('r', 'a', 'w', ' ') }, /* 8 bits unsigned */
-    { CODEC_ID_PCM_S16LE, MKTAG('s', 'o', 'w', 't') }, /*  */
-    { CODEC_ID_PCM_MULAW, MKTAG('u', 'l', 'a', 'w') }, /*  */
-    { CODEC_ID_PCM_ALAW, MKTAG('a', 'l', 'a', 'w') }, /*  */
-    { CODEC_ID_ADPCM_IMA_QT, MKTAG('i', 'm', 'a', '4') }, /* IMA-4 ADPCM */
-    { CODEC_ID_ADPCM_MS, MKTAG('m', 's', 0x00, 0x02) }, /* MS ADPCM */
-    { CODEC_ID_MACE3, MKTAG('M', 'A', 'C', '3') }, /* Macintosh Audio Compression and Expansion 3:1 */
-    { CODEC_ID_MACE6, MKTAG('M', 'A', 'C', '6') }, /* Macintosh Audio Compression and Expansion 6:1 */
-
-    { CODEC_ID_MP3, MKTAG('.', 'm', 'p', '3') }, /* MPEG layer 3 */ /* sample files at <A HREF="http://www.3ivx.com/showcase.html">http://www.3ivx.com/showcase.html</A> use this tag */
-    { CODEC_ID_MP2, 0x6D730055 }, /* MPEG layer 3 */
-    { CODEC_ID_MP2, 0x5500736D }, /* MPEG layer 3 *//* XXX: check endianness */
-/*    { CODEC_ID_OGG_VORBIS, MKTAG('O', 'g', 'g', 'S') }, *//* sample files at <A HREF="http://heroinewarrior.com/xmovie.php3">http://heroinewarrior.com/xmovie.php3</A> use this tag */
-/* MP4 tags */
-    { CODEC_ID_AAC, MKTAG('m', 'p', '4', 'a') }, /* MPEG-4 AAC */
-    /* The standard for mpeg4 audio is still not normalised AFAIK anyway */
-    { CODEC_ID_AMR_NB, MKTAG('s', 'a', 'm', 'r') }, /* AMR-NB 3gp */
-    { CODEC_ID_AMR_WB, MKTAG('s', 'a', 'w', 'b') }, /* AMR-WB 3gp */
-    { CODEC_ID_AC3, MKTAG('m', 's', 0x20, 0x00) }, /* Dolby AC-3 */
-    { CODEC_ID_ALAC,MKTAG('a', 'l', 'a', 'c') }, /* Apple Lossless */
-    { CODEC_ID_QDM2,MKTAG('Q', 'D', 'M', '2') }, /* QDM2 */
-    { CODEC_ID_DVAUDIO, MKTAG('v', 'd', 'v', 'a') },
-    { CODEC_ID_DVAUDIO, MKTAG('d', 'v', 'c', 'a') },
-    { CODEC_ID_PCM_S16LE, MKTAG('l', 'p', 'c', 'm') },
-    { CODEC_ID_NONE, 0 },
-};
-
 /* the QuickTime file format is quite convoluted...
  * it has lots of index tables, each indexing something in another one...
  * Here we just use what is needed to read the chunks
  */
 
-typedef struct MOV_sample_to_chunk_tbl {
-    long first;
-    long count;
-    long id;
-} MOV_sample_to_chunk_tbl;
+typedef struct {
+    int first;
+    int count;
+    int id;
+} MOV_stsc_t;
 
 typedef struct {
     uint32_t type;
@@ -177,91 +76,36 @@
 } MOV_atom_t;
 
 typedef struct {
-    int seed;
-    int flags;
-    int size;
-    void* clrs;
-} MOV_ctab_t;
-
-typedef struct MOV_mdat_atom_s {
     offset_t offset;
     int64_t size;
-} MOV_mdat_atom_t;
+} MOV_mdat_t;
 
-typedef struct {
-    uint8_t  version;
-    uint32_t flags; // 24bit
-
-    /* 0x03 ESDescrTag */
-    uint16_t es_id;
-#define MP4ODescrTag                    0x01
-#define MP4IODescrTag                   0x02
-#define MP4ESDescrTag                   0x03
-#define MP4DecConfigDescrTag            0x04
-#define MP4DecSpecificDescrTag          0x05
-#define MP4SLConfigDescrTag             0x06
-#define MP4ContentIdDescrTag            0x07
-#define MP4SupplContentIdDescrTag       0x08
-#define MP4IPIPtrDescrTag               0x09
-#define MP4IPMPPtrDescrTag              0x0A
-#define MP4IPMPDescrTag                 0x0B
-#define MP4RegistrationDescrTag         0x0D
-#define MP4ESIDIncDescrTag              0x0E
-#define MP4ESIDRefDescrTag              0x0F
-#define MP4FileIODescrTag               0x10
-#define MP4FileODescrTag                0x11
-#define MP4ExtProfileLevelDescrTag      0x13
-#define MP4ExtDescrTagsStart            0x80
-#define MP4ExtDescrTagsEnd              0xFE
-    uint8_t  stream_priority;
-
-    /* 0x04 DecConfigDescrTag */
-    uint8_t  object_type_id;
-    uint8_t  stream_type;
-    /* XXX: really streamType is
-     * only 6bit, followed by:
-     * 1bit  upStream
-     * 1bit  reserved
-     */
-    uint32_t buffer_size_db; // 24
-    uint32_t max_bitrate;
-    uint32_t avg_bitrate;
-
-    /* 0x05 DecSpecificDescrTag */
-    uint8_t  decoder_cfg_len;
-    uint8_t *decoder_cfg;
-
-    /* 0x06 SLConfigDescrTag */
-    uint8_t  sl_config_len;
-    uint8_t *sl_config;
-} MOV_esds_t;
-
 struct MOVParseTableEntry;
 
 typedef struct MOVStreamContext {
     int ffindex; /* the ffmpeg stream id */
-    long next_chunk;
-    long chunk_count;
+    int next_chunk;
+    unsigned int chunk_count;
     int64_t *chunk_offsets;
-    int stts_count;
-    Time2Sample *stts_data;
-    int ctts_count;
-    Time2Sample *ctts_data;
-    int edit_count;             /* number of 'edit' (elst atom) */
-    long sample_to_chunk_sz;
-    MOV_sample_to_chunk_tbl *sample_to_chunk;
+    unsigned int stts_count;
+    MOV_stts_t *stts_data;
+    unsigned int ctts_count;
+    MOV_stts_t *ctts_data;
+    unsigned int edit_count; /* number of 'edit' (elst atom) */
+    unsigned int sample_to_chunk_sz;
+    MOV_stsc_t *sample_to_chunk;
     int sample_to_ctime_index;
     int sample_to_ctime_sample;
-    long sample_size;
-    long sample_count;
-    long *sample_sizes;
-    long keyframe_count;
-    long *keyframes;
+    unsigned int sample_size;
+    unsigned int sample_count;
+    int *sample_sizes;
+    unsigned int keyframe_count;
+    int *keyframes;
     int time_scale;
     int time_rate;
-    long current_sample;
-    MOV_esds_t esds;
-    AVRational sample_size_v1;
+    int current_sample;
+    unsigned int bytes_per_frame;
+    unsigned int samples_per_frame;
     int dv_audio_container;
 } MOVStreamContext;
 
@@ -271,21 +115,15 @@
     int64_t duration; /* duration of the longest track */
     int found_moov; /* when both 'moov' and 'mdat' sections has been found */
     int found_mdat; /* we suppose we have enough data to read the file */
-    int64_t mdat_size;
     int64_t mdat_offset;
     int total_streams;
-    /* some streams listed here aren't presented to the ffmpeg API, since they aren't either video nor audio
-     * but we need the info to be able to skip data from those streams in the 'mdat' section
-     */
     MOVStreamContext *streams[MAX_STREAMS];
 
-    int ctab_size;
-    MOV_ctab_t **ctab;           /* color tables */
     const struct MOVParseTableEntry *parse_table; /* could be eventually used to change the table */
     /* NOTE: for recursion save to/ restore from local variable! */
 
     AVPaletteControl palette_control;
-    MOV_mdat_atom_t *mdat_list;
+    MOV_mdat_t *mdat_list;
     int mdat_count;
     DVDemuxContext *dv_demux;
     AVFormatContext *dv_fctx;
@@ -319,7 +157,7 @@
     a.offset = atom.offset;
 
     if (atom.size &lt; 0)
-        atom.size = 0x7fffffffffffffffLL;
+        atom.size = INT64_MAX;
     while(((total_size + 8) &lt; atom.size) &amp;&amp; !url_feof(pb) &amp;&amp; !err) {
         a.size = atom.size;
         a.type=0L;
@@ -329,7 +167,7 @@
         }
         total_size += 8;
         a.offset += 8;
-        dprintf(&quot;type: %08x  %.4s  sz: %&quot;PRIx64&quot;  %&quot;PRIx64&quot;   %&quot;PRIx64&quot;\n&quot;, a.type, (char*)&amp;a.type, a.size, atom.size, total_size);
+        dprintf(c-&gt;fc, &quot;type: %08x  %.4s  sz: %&quot;PRIx64&quot;  %&quot;PRIx64&quot;   %&quot;PRIx64&quot;\n&quot;, a.type, (char*)&amp;a.type, a.size, atom.size, total_size);
         if (a.size == 1) { /* 64 bit extended size */
             a.size = get_be64(pb) - 8;
             a.offset += 8;
@@ -340,15 +178,14 @@
             if (a.size &lt;= 8)
                 break;
         }
+        a.size -= 8;
+        if(a.size &lt; 0 || a.size &gt; atom.size - total_size)
+            break;
+
         for (i = 0; c-&gt;parse_table[i].type != 0L
              &amp;&amp; c-&gt;parse_table[i].type != a.type; i++)
             /* empty */;
 
-        a.size -= 8;
-
-        if(a.size &lt; 0)
-            break;
-
         if (c-&gt;parse_table[i].type == 0) { /* skip leaf atoms data */
             url_fskip(pb, a.size);
         } else {
@@ -371,30 +208,6 @@
     return err;
 }
 
-static int mov_read_ctab(MOVContext *c, ByteIOContext *pb, MOV_atom_t atom)
-{
-#if 1
-    url_fskip(pb, atom.size); // for now
-#else
-    VERY VERY BROKEN, NEVER execute this, needs rewrite
-    unsigned int len;
-    MOV_ctab_t *t;
-    c-&gt;ctab = av_realloc(c-&gt;ctab, ++c-&gt;ctab_size);
-    t = c-&gt;ctab[c-&gt;ctab_size];
-    t-&gt;seed = get_be32(pb);
-    t-&gt;flags = get_be16(pb);
-    t-&gt;size = get_be16(pb) + 1;
-    len = 2 * t-&gt;size * 4;
-    if (len &gt; 0) {
-        t-&gt;clrs = av_malloc(len); // 16bit A R G B
-        if (t-&gt;clrs)
-            get_buffer(pb, t-&gt;clrs, len);
-    }
-#endif
-
-    return 0;
-}
-
 static int mov_read_hdlr(MOVContext *c, ByteIOContext *pb, MOV_atom_t atom)
 {
     AVStream *st = c-&gt;fc-&gt;streams[c-&gt;fc-&gt;nb_streams-1];
@@ -408,8 +221,8 @@
     ctype = get_le32(pb);
     type = get_le32(pb); /* component subtype */
 
-    dprintf(&quot;ctype= %c%c%c%c (0x%08lx)\n&quot;, *((char *)&amp;ctype), ((char *)&amp;ctype)[1], ((char *)&amp;ctype)[2], ((char *)&amp;ctype)[3], (long) ctype);
-    dprintf(&quot;stype= %c%c%c%c\n&quot;, *((char *)&amp;type), ((char *)&amp;type)[1], ((char *)&amp;type)[2], ((char *)&amp;type)[3]);
+    dprintf(c-&gt;fc, &quot;ctype= %c%c%c%c (0x%08x)\n&quot;, *((char *)&amp;ctype), ((char *)&amp;ctype)[1], ((char *)&amp;ctype)[2], ((char *)&amp;ctype)[3], (int) ctype);
+    dprintf(c-&gt;fc, &quot;stype= %c%c%c%c\n&quot;, *((char *)&amp;type), ((char *)&amp;type)[1], ((char *)&amp;type)[2], ((char *)&amp;type)[3]);
     if(!ctype)
         c-&gt;isom = 1;
     if(type == MKTAG('v', 'i', 'd', 'e'))
@@ -433,7 +246,7 @@
     return 0;
 }
 
-static int mov_mp4_read_descr_len(ByteIOContext *pb)
+static int mp4_read_descr_len(ByteIOContext *pb)
 {
     int len = 0;
     int count = 4;
@@ -446,43 +259,45 @@
     return len;
 }
 
-static int mov_mp4_read_descr(ByteIOContext *pb, int *tag)
+static int mp4_read_descr(MOVContext *c, ByteIOContext *pb, int *tag)
 {
     int len;
     *tag = get_byte(pb);
-    len = mov_mp4_read_descr_len(pb);
-    dprintf(&quot;MPEG4 description: tag=0x%02x len=%d\n&quot;, *tag, len);
+    len = mp4_read_descr_len(pb);
+    dprintf(c-&gt;fc, &quot;MPEG4 description: tag=0x%02x len=%d\n&quot;, *tag, len);
     return len;
 }
 
+#define MP4ESDescrTag                   0x03
+#define MP4DecConfigDescrTag            0x04
+#define MP4DecSpecificDescrTag          0x05
+
 static int mov_read_esds(MOVContext *c, ByteIOContext *pb, MOV_atom_t atom)
 {
     AVStream *st = c-&gt;fc-&gt;streams[c-&gt;fc-&gt;nb_streams-1];
-    MOVStreamContext *sc = (MOVStreamContext *)st-&gt;priv_data;
     int tag, len;
 
-    /* Well, broken but suffisant for some MP4 streams */
     get_be32(pb); /* version + flags */
-    len = mov_mp4_read_descr(pb, &amp;tag);
+    len = mp4_read_descr(c, pb, &amp;tag);
     if (tag == MP4ESDescrTag) {
         get_be16(pb); /* ID */
         get_byte(pb); /* priority */
     } else
         get_be16(pb); /* ID */
 
-    len = mov_mp4_read_descr(pb, &amp;tag);
+    len = mp4_read_descr(c, pb, &amp;tag);
     if (tag == MP4DecConfigDescrTag) {
-        sc-&gt;esds.object_type_id = get_byte(pb);
-        sc-&gt;esds.stream_type = get_byte(pb);
-        sc-&gt;esds.buffer_size_db = get_be24(pb);
-        sc-&gt;esds.max_bitrate = get_be32(pb);
-        sc-&gt;esds.avg_bitrate = get_be32(pb);
+        int object_type_id = get_byte(pb);
+        get_byte(pb); /* stream type */
+        get_be24(pb); /* buffer size db */
+        get_be32(pb); /* max bitrate */
+        get_be32(pb); /* avg bitrate */
 
-        st-&gt;codec-&gt;codec_id= codec_get_id(ff_mov_obj_type, sc-&gt;esds.object_type_id);
-        dprintf(&quot;esds object type id %d\n&quot;, sc-&gt;esds.object_type_id);
-        len = mov_mp4_read_descr(pb, &amp;tag);
+        st-&gt;codec-&gt;codec_id= codec_get_id(ff_mp4_obj_type, object_type_id);
+        dprintf(c-&gt;fc, &quot;esds object type id %d\n&quot;, object_type_id);
+        len = mp4_read_descr(c, pb, &amp;tag);
         if (tag == MP4DecSpecificDescrTag) {
-            dprintf(&quot;Specific MPEG4 header len=%d\n&quot;, len);
+            dprintf(c-&gt;fc, &quot;Specific MPEG4 header len=%d\n&quot;, len);
             st-&gt;codec-&gt;extradata = av_mallocz(len + FF_INPUT_BUFFER_PADDING_SIZE);
             if (st-&gt;codec-&gt;extradata) {
                 get_buffer(pb, st-&gt;codec-&gt;extradata, len);
@@ -508,7 +323,6 @@
     c-&gt;mdat_count++;
     c-&gt;found_mdat=1;
     c-&gt;mdat_offset = atom.offset;
-    c-&gt;mdat_size = atom.size;
     if(c-&gt;found_moov)
         return 1; /* found both, just go */
     url_fskip(pb, atom.size);
@@ -545,7 +359,7 @@
 static int mov_read_mdhd(MOVContext *c, ByteIOContext *pb, MOV_atom_t atom)
 {
     AVStream *st = c-&gt;fc-&gt;streams[c-&gt;fc-&gt;nb_streams-1];
-    MOVStreamContext *sc = (MOVStreamContext *)st-&gt;priv_data;
+    MOVStreamContext *sc = st-&gt;priv_data;
     int version = get_byte(pb);
     int lang;
 
@@ -586,9 +400,9 @@
         get_be32(pb); /* modification time */
     }
     c-&gt;time_scale = get_be32(pb); /* time scale */
-#ifdef DEBUG
-    av_log(NULL, AV_LOG_DEBUG, &quot;time scale = %i\n&quot;, c-&gt;time_scale);
-#endif
+
+    dprintf(c-&gt;fc, &quot;time scale = %i\n&quot;, c-&gt;time_scale);
+
     c-&gt;duration = (version == 1) ? get_be64(pb) : get_be32(pb); /* duration */
     get_be32(pb); /* preferred scale */
 
@@ -623,9 +437,9 @@
     st-&gt;codec-&gt;extradata = av_mallocz(st-&gt;codec-&gt;extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);
 
     if (st-&gt;codec-&gt;extradata) {
-        strcpy(st-&gt;codec-&gt;extradata, &quot;SVQ3&quot;); // fake
+        memcpy(st-&gt;codec-&gt;extradata, &quot;SVQ3&quot;, 4); // fake
         get_buffer(pb, st-&gt;codec-&gt;extradata + 0x5a, atom.size);
-        dprintf(&quot;Reading SMI %&quot;PRId64&quot;  %s\n&quot;, atom.size, st-&gt;codec-&gt;extradata + 0x5a);
+        dprintf(c-&gt;fc, &quot;Reading SMI %&quot;PRId64&quot;  %s\n&quot;, atom.size, st-&gt;codec-&gt;extradata + 0x5a);
     } else
         url_fskip(pb, atom.size);
 
@@ -652,21 +466,18 @@
     return 0;
 }
 
-static int mov_read_alac(MOVContext *c, ByteIOContext *pb, MOV_atom_t atom)
+/* FIXME modify qdm2/svq3/h264 decoders to take full atom as extradata */
+static int mov_read_extradata(MOVContext *c, ByteIOContext *pb, MOV_atom_t atom)
 {
     AVStream *st = c-&gt;fc-&gt;streams[c-&gt;fc-&gt;nb_streams-1];
-
-    // currently ALAC decoder expect full atom header - so let's fake it
-    // this should be fixed and just ALAC header should be passed
-
+    if((uint64_t)atom.size &gt; (1&lt;&lt;30))
+        return -1;
     av_free(st-&gt;codec-&gt;extradata);
-    st-&gt;codec-&gt;extradata_size = 36;
+    st-&gt;codec-&gt;extradata_size = atom.size + 8;
     st-&gt;codec-&gt;extradata = av_mallocz(st-&gt;codec-&gt;extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);
-
     if (st-&gt;codec-&gt;extradata) {
-        strcpy(st-&gt;codec-&gt;extradata + 4, &quot;alac&quot;); // fake
-        get_buffer(pb, st-&gt;codec-&gt;extradata + 8, 36 - 8);
-        dprintf(&quot;Reading alac %d  %s\n&quot;, st-&gt;codec-&gt;extradata_size, st-&gt;codec-&gt;extradata);
+        AV_WL32(st-&gt;codec-&gt;extradata + 4, atom.type);
+        get_buffer(pb, st-&gt;codec-&gt;extradata + 8, atom.size);
     } else
         url_fskip(pb, atom.size);
     return 0;
@@ -696,27 +507,6 @@
     return 0;
 }
 
-static int mov_read_jp2h(MOVContext *c, ByteIOContext *pb, MOV_atom_t atom)
-{
-    AVStream *st = c-&gt;fc-&gt;streams[c-&gt;fc-&gt;nb_streams-1];
-
-    if((uint64_t)atom.size &gt; (1&lt;&lt;30))
-        return -1;
-
-    av_free(st-&gt;codec-&gt;extradata);
-
-    st-&gt;codec-&gt;extradata_size = atom.size + 8;
-    st-&gt;codec-&gt;extradata = av_mallocz(st-&gt;codec-&gt;extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);
-
-    /* pass all jp2h atom to codec */
-    if (st-&gt;codec-&gt;extradata) {
-        strcpy(st-&gt;codec-&gt;extradata + 4, &quot;jp2h&quot;);
-        get_buffer(pb, st-&gt;codec-&gt;extradata + 8, atom.size);
-    } else
-        url_fskip(pb, atom.size);
-    return 0;
-}
-
 static int mov_read_avcC(MOVContext *c, ByteIOContext *pb, MOV_atom_t atom)
 {
     AVStream *st = c-&gt;fc-&gt;streams[c-&gt;fc-&gt;nb_streams-1];
@@ -740,7 +530,7 @@
 static int mov_read_stco(MOVContext *c, ByteIOContext *pb, MOV_atom_t atom)
 {
     AVStream *st = c-&gt;fc-&gt;streams[c-&gt;fc-&gt;nb_streams-1];
-    MOVStreamContext *sc = (MOVStreamContext *)st-&gt;priv_data;
+    MOVStreamContext *sc = st-&gt;priv_data;
     unsigned int i, entries;
 
     get_byte(pb); /* version */
@@ -772,7 +562,7 @@
 static int mov_read_stsd(MOVContext *c, ByteIOContext *pb, MOV_atom_t atom)
 {
     AVStream *st = c-&gt;fc-&gt;streams[c-&gt;fc-&gt;nb_streams-1];
-    MOVStreamContext *sc = (MOVStreamContext *)st-&gt;priv_data;
+    MOVStreamContext *sc = st-&gt;priv_data;
     int entries, frames_per_sample;
     uint32_t format;
     uint8_t codec_name[32];
@@ -812,19 +602,19 @@
         }
 
         st-&gt;codec-&gt;codec_tag = format;
-        id = codec_get_id(mov_audio_tags, format);
+        id = codec_get_id(codec_movaudio_tags, format);
         if (st-&gt;codec-&gt;codec_type != CODEC_TYPE_VIDEO &amp;&amp; id &gt; 0) {
             st-&gt;codec-&gt;codec_type = CODEC_TYPE_AUDIO;
         } else if (st-&gt;codec-&gt;codec_type != CODEC_TYPE_AUDIO &amp;&amp; /* do not overwrite codec type */
                    format &amp;&amp; format != MKTAG('m', 'p', '4', 's')) { /* skip old asf mpeg4 tag */
-            id = codec_get_id(mov_video_tags, format);
+            id = codec_get_id(codec_movvideo_tags, format);
             if (id &lt;= 0)
                 id = codec_get_id(codec_bmp_tags, format);
             if (id &gt; 0)
                 st-&gt;codec-&gt;codec_type = CODEC_TYPE_VIDEO;
         }
 
-        dprintf(&quot;size=%d 4CC= %c%c%c%c codec_type=%d\n&quot;,
+        dprintf(c-&gt;fc, &quot;size=%d 4CC= %c%c%c%c codec_type=%d\n&quot;,
                 size,
                 (format &gt;&gt; 0) &amp; 0xff, (format &gt;&gt; 8) &amp; 0xff, (format &gt;&gt; 16) &amp; 0xff, (format &gt;&gt; 24) &amp; 0xff,
                 st-&gt;codec-&gt;codec_type);
@@ -844,9 +634,9 @@
             get_be32(pb); /* vert resolution */
             get_be32(pb); /* data size, always 0 */
             frames_per_sample = get_be16(pb); /* frames per samples */
-#ifdef DEBUG
-            av_log(NULL, AV_LOG_DEBUG, &quot;frames/samples = %d\n&quot;, frames_per_sample);
-#endif
+
+            dprintf(c-&gt;fc, &quot;frames/samples = %d\n&quot;, frames_per_sample);
+
             get_buffer(pb, codec_name, 32); /* codec name, pascal string (FIXME: true for mp4?) */
             if (codec_name[0] &lt;= 31) {
                 memcpy(st-&gt;codec-&gt;codec_name, &amp;codec_name[1],codec_name[0]);
@@ -934,7 +724,7 @@
             get_be32(pb); /* vendor */
 
             st-&gt;codec-&gt;channels = get_be16(pb);             /* channel count */
-            dprintf(&quot;audio channels %d\n&quot;, st-&gt;codec-&gt;channels);
+            dprintf(c-&gt;fc, &quot;audio channels %d\n&quot;, st-&gt;codec-&gt;channels);
             st-&gt;codec-&gt;bits_per_sample = get_be16(pb);      /* sample size */
             /* do we need to force to 16 for AMR ? */
 
@@ -961,13 +751,13 @@
                 break;
             }
 
-            //Read QT version 1 fields. In version 0 theese dont exist
-            dprintf(&quot;version =%d, isom =%d\n&quot;,version,c-&gt;isom);
+            //Read QT version 1 fields. In version 0 these do not exist.
+            dprintf(c-&gt;fc, &quot;version =%d, isom =%d\n&quot;,version,c-&gt;isom);
             if(!c-&gt;isom) {
                 if(version==1) {
-                    sc-&gt;sample_size_v1.den = get_be32(pb); /* samples per packet */
+                    sc-&gt;samples_per_frame = get_be32(pb);
                     get_be32(pb); /* bytes per packet */
-                    sc-&gt;sample_size_v1.num = get_be32(pb); /* bytes per frame */
+                    sc-&gt;bytes_per_frame = get_be32(pb);
                     get_be32(pb); /* bytes per sample */
                 } else if(version==2) {
                     get_be32(pb); /* sizeof struct only */
@@ -1047,8 +837,9 @@
         st-&gt;codec-&gt;channels= 1; /* really needed */
         break;
     case CODEC_ID_MP2:
+    case CODEC_ID_MP3:
         st-&gt;codec-&gt;codec_type = CODEC_TYPE_AUDIO; /* force type after stsd for m1a hdlr */
-        st-&gt;need_parsing = 1;
+        st-&gt;need_parsing = AVSTREAM_PARSE_FULL;
         break;
     default:
         break;
@@ -1060,7 +851,7 @@
 static int mov_read_stsc(MOVContext *c, ByteIOContext *pb, MOV_atom_t atom)
 {
     AVStream *st = c-&gt;fc-&gt;streams[c-&gt;fc-&gt;nb_streams-1];
-    MOVStreamContext *sc = (MOVStreamContext *)st-&gt;priv_data;
+    MOVStreamContext *sc = st-&gt;priv_data;
     unsigned int i, entries;
 
     get_byte(pb); /* version */
@@ -1068,14 +859,13 @@
 
     entries = get_be32(pb);
 
-    if(entries &gt;= UINT_MAX / sizeof(MOV_sample_to_chunk_tbl))
+    if(entries &gt;= UINT_MAX / sizeof(MOV_stsc_t))
         return -1;
 
-#ifdef DEBUG
-av_log(NULL, AV_LOG_DEBUG, &quot;track[%i].stsc.entries = %i\n&quot;, c-&gt;fc-&gt;nb_streams-1, entries);
-#endif
+    dprintf(c-&gt;fc, &quot;track[%i].stsc.entries = %i\n&quot;, c-&gt;fc-&gt;nb_streams-1, entries);
+
     sc-&gt;sample_to_chunk_sz = entries;
-    sc-&gt;sample_to_chunk = av_malloc(entries * sizeof(MOV_sample_to_chunk_tbl));
+    sc-&gt;sample_to_chunk = av_malloc(entries * sizeof(MOV_stsc_t));
     if (!sc-&gt;sample_to_chunk)
         return -1;
     for(i=0; i&lt;entries; i++) {
@@ -1089,7 +879,7 @@
 static int mov_read_stss(MOVContext *c, ByteIOContext *pb, MOV_atom_t atom)
 {
     AVStream *st = c-&gt;fc-&gt;streams[c-&gt;fc-&gt;nb_streams-1];
-    MOVStreamContext *sc = (MOVStreamContext *)st-&gt;priv_data;
+    MOVStreamContext *sc = st-&gt;priv_data;
     unsigned int i, entries;
 
     get_byte(pb); /* version */
@@ -1097,21 +887,19 @@
 
     entries = get_be32(pb);
 
-    if(entries &gt;= UINT_MAX / sizeof(long))
+    if(entries &gt;= UINT_MAX / sizeof(int))
         return -1;
 
     sc-&gt;keyframe_count = entries;
-#ifdef DEBUG
-    av_log(NULL, AV_LOG_DEBUG, &quot;keyframe_count = %ld\n&quot;, sc-&gt;keyframe_count);
-#endif
-    sc-&gt;keyframes = av_malloc(entries * sizeof(long));
+
+    dprintf(c-&gt;fc, &quot;keyframe_count = %d\n&quot;, sc-&gt;keyframe_count);
+
+    sc-&gt;keyframes = av_malloc(entries * sizeof(int));
     if (!sc-&gt;keyframes)
         return -1;
     for(i=0; i&lt;entries; i++) {
         sc-&gt;keyframes[i] = get_be32(pb);
-#ifdef DEBUG
-/*        av_log(NULL, AV_LOG_DEBUG, &quot;keyframes[]=%ld\n&quot;, sc-&gt;keyframes[i]); */
-#endif
+        //dprintf(c-&gt;fc, &quot;keyframes[]=%d\n&quot;, sc-&gt;keyframes[i]);
     }
     return 0;
 }
@@ -1119,7 +907,7 @@
 static int mov_read_stsz(MOVContext *c, ByteIOContext *pb, MOV_atom_t atom)
 {
     AVStream *st = c-&gt;fc-&gt;streams[c-&gt;fc-&gt;nb_streams-1];
-    MOVStreamContext *sc = (MOVStreamContext *)st-&gt;priv_data;
+    MOVStreamContext *sc = st-&gt;priv_data;
     unsigned int i, entries, sample_size;
 
     get_byte(pb); /* version */
@@ -1129,24 +917,21 @@
     if (!sc-&gt;sample_size) /* do not overwrite value computed in stsd */
         sc-&gt;sample_size = sample_size;
     entries = get_be32(pb);
-    if(entries &gt;= UINT_MAX / sizeof(long))
+    if(entries &gt;= UINT_MAX / sizeof(int))
         return -1;
 
     sc-&gt;sample_count = entries;
     if (sample_size)
         return 0;
 
-#ifdef DEBUG
-    av_log(NULL, AV_LOG_DEBUG, &quot;sample_size = %ld sample_count = %ld\n&quot;, sc-&gt;sample_size, sc-&gt;sample_count);
-#endif
-    sc-&gt;sample_sizes = av_malloc(entries * sizeof(long));
+    dprintf(c-&gt;fc, &quot;sample_size = %d sample_count = %d\n&quot;, sc-&gt;sample_size, sc-&gt;sample_count);
+
+    sc-&gt;sample_sizes = av_malloc(entries * sizeof(int));
     if (!sc-&gt;sample_sizes)
         return -1;
     for(i=0; i&lt;entries; i++) {
         sc-&gt;sample_sizes[i] = get_be32(pb);
-#ifdef DEBUG
-        av_log(NULL, AV_LOG_DEBUG, &quot;sample_sizes[]=%ld\n&quot;, sc-&gt;sample_sizes[i]);
-#endif
+        dprintf(c-&gt;fc, &quot;sample_sizes[]=%d\n&quot;, sc-&gt;sample_sizes[i]);
     }
     return 0;
 }
@@ -1154,7 +939,7 @@
 static int mov_read_stts(MOVContext *c, ByteIOContext *pb, MOV_atom_t atom)
 {
     AVStream *st = c-&gt;fc-&gt;streams[c-&gt;fc-&gt;nb_streams-1];
-    MOVStreamContext *sc = (MOVStreamContext *)st-&gt;priv_data;
+    MOVStreamContext *sc = st-&gt;priv_data;
     unsigned int i, entries;
     int64_t duration=0;
     int64_t total_sample_count=0;
@@ -1162,15 +947,13 @@
     get_byte(pb); /* version */
     get_byte(pb); get_byte(pb); get_byte(pb); /* flags */
     entries = get_be32(pb);
-    if(entries &gt;= UINT_MAX / sizeof(Time2Sample))
+    if(entries &gt;= UINT_MAX / sizeof(MOV_stts_t))
         return -1;
 
     sc-&gt;stts_count = entries;
-    sc-&gt;stts_data = av_malloc(entries * sizeof(Time2Sample));
+    sc-&gt;stts_data = av_malloc(entries * sizeof(MOV_stts_t));
 
-#ifdef DEBUG
-av_log(NULL, AV_LOG_DEBUG, &quot;track[%i].stts.entries = %i\n&quot;, c-&gt;fc-&gt;nb_streams-1, entries);
-#endif
+    dprintf(c-&gt;fc, &quot;track[%i].stts.entries = %i\n&quot;, c-&gt;fc-&gt;nb_streams-1, entries);
 
     sc-&gt;time_rate=0;
 
@@ -1185,7 +968,7 @@
 
         sc-&gt;time_rate= ff_gcd(sc-&gt;time_rate, sample_duration);
 
-        dprintf(&quot;sample_count=%d, sample_duration=%d\n&quot;,sample_count,sample_duration);
+        dprintf(c-&gt;fc, &quot;sample_count=%d, sample_duration=%d\n&quot;,sample_count,sample_duration);
 
         duration+=(int64_t)sample_duration*sample_count;
         total_sample_count+=sample_count;
@@ -1200,19 +983,19 @@
 static int mov_read_ctts(MOVContext *c, ByteIOContext *pb, MOV_atom_t atom)
 {
     AVStream *st = c-&gt;fc-&gt;streams[c-&gt;fc-&gt;nb_streams-1];
-    MOVStreamContext *sc = (MOVStreamContext *)st-&gt;priv_data;
+    MOVStreamContext *sc = st-&gt;priv_data;
     unsigned int i, entries;
 
     get_byte(pb); /* version */
     get_byte(pb); get_byte(pb); get_byte(pb); /* flags */
     entries = get_be32(pb);
-    if(entries &gt;= UINT_MAX / sizeof(Time2Sample))
+    if(entries &gt;= UINT_MAX / sizeof(MOV_stts_t))
         return -1;
 
     sc-&gt;ctts_count = entries;
-    sc-&gt;ctts_data = av_malloc(entries * sizeof(Time2Sample));
+    sc-&gt;ctts_data = av_malloc(entries * sizeof(MOV_stts_t));
 
-    dprintf(&quot;track[%i].ctts.entries = %i\n&quot;, c-&gt;fc-&gt;nb_streams-1, entries);
+    dprintf(c-&gt;fc, &quot;track[%i].ctts.entries = %i\n&quot;, c-&gt;fc-&gt;nb_streams-1, entries);
 
     for(i=0; i&lt;entries; i++) {
         int count    =get_be32(pb);
@@ -1384,7 +1167,7 @@
         get_be32(pb); /* Media time */
         get_be32(pb); /* Media rate */
     }
-    dprintf(&quot;track[%i].edit_count = %i\n&quot;, c-&gt;fc-&gt;nb_streams-1, c-&gt;streams[c-&gt;fc-&gt;nb_streams-1]-&gt;edit_count);
+    dprintf(c-&gt;fc, &quot;track[%i].edit_count = %i\n&quot;, c-&gt;fc-&gt;nb_streams-1, c-&gt;streams[c-&gt;fc-&gt;nb_streams-1]-&gt;edit_count);
     return 0;
 }
 
@@ -1395,9 +1178,10 @@
 { MKTAG( 'e', 'd', 't', 's' ), mov_read_default },
 { MKTAG( 'e', 'l', 's', 't' ), mov_read_elst },
 { MKTAG( 'e', 'n', 'd', 'a' ), mov_read_enda },
+{ MKTAG( 'f', 'i', 'e', 'l' ), mov_read_extradata },
 { MKTAG( 'f', 't', 'y', 'p' ), mov_read_ftyp },
 { MKTAG( 'h', 'd', 'l', 'r' ), mov_read_hdlr },
-{ MKTAG( 'j', 'p', '2', 'h' ), mov_read_jp2h },
+{ MKTAG( 'j', 'p', '2', 'h' ), mov_read_extradata },
 { MKTAG( 'm', 'd', 'a', 't' ), mov_read_mdat },
 { MKTAG( 'm', 'd', 'h', 'd' ), mov_read_mdhd },
 { MKTAG( 'm', 'd', 'i', 'a' ), mov_read_default },
@@ -1405,7 +1189,7 @@
 { MKTAG( 'm', 'o', 'o', 'v' ), mov_read_moov },
 { MKTAG( 'm', 'v', 'h', 'd' ), mov_read_mvhd },
 { MKTAG( 'S', 'M', 'I', ' ' ), mov_read_smi }, /* Sorenson extension ??? */
-{ MKTAG( 'a', 'l', 'a', 'c' ), mov_read_alac }, /* alac specific atom */
+{ MKTAG( 'a', 'l', 'a', 'c' ), mov_read_extradata }, /* alac specific atom */
 { MKTAG( 'a', 'v', 'c', 'C' ), mov_read_avcC },
 { MKTAG( 's', 't', 'b', 'l' ), mov_read_default },
 { MKTAG( 's', 't', 'c', 'o' ), mov_read_stco },
@@ -1417,21 +1201,12 @@
 { MKTAG( 't', 'k', 'h', 'd' ), mov_read_tkhd }, /* track header */
 { MKTAG( 't', 'r', 'a', 'k' ), mov_read_trak },
 { MKTAG( 'w', 'a', 'v', 'e' ), mov_read_wave },
-{ MKTAG( 'c', 't', 'a', 'b' ), mov_read_ctab },
 { MKTAG( 'e', 's', 'd', 's' ), mov_read_esds },
 { MKTAG( 'w', 'i', 'd', 'e' ), mov_read_wide }, /* place holder */
 { MKTAG( 'c', 'm', 'o', 'v' ), mov_read_cmov },
 { 0L, NULL }
 };
 
-static void mov_free_stream_context(MOVStreamContext *sc)
-{
-    if(sc) {
-        av_freep(&amp;sc-&gt;ctts_data);
-        av_freep(&amp;sc);
-    }
-}
-
 /* XXX: is it sufficient ? */
 static int mov_probe(AVProbeData *p)
 {
@@ -1440,8 +1215,6 @@
     int score = 0;
 
     /* check file header */
-    if (p-&gt;buf_size &lt;= 12)
-        return 0;
     offset = 0;
     for(;;) {
         /* ignore invalid offset */
@@ -1457,6 +1230,7 @@
         case MKTAG( 'u', 'd', 't', 'a' ): /* Packet Video PVAuthor adds this and a lot of more junk */
             return AVPROBE_SCORE_MAX;
         /* those are more common words, so rate then a bit less */
+        case MKTAG( 'e', 'd', 'i', 'w' ): /* xdcam files have reverted first tags */
         case MKTAG( 'w', 'i', 'd', 'e' ):
         case MKTAG( 'f', 'r', 'e', 'e' ):
         case MKTAG( 'j', 'u', 'n', 'k' ):
@@ -1482,16 +1256,16 @@
     MOVStreamContext *sc = st-&gt;priv_data;
     offset_t current_offset;
     int64_t current_dts = 0;
-    int stts_index = 0;
-    int stsc_index = 0;
-    int stss_index = 0;
-    int i, j, k;
+    unsigned int stts_index = 0;
+    unsigned int stsc_index = 0;
+    unsigned int stss_index = 0;
+    unsigned int i, j, k;
 
     if (sc-&gt;sample_sizes || st-&gt;codec-&gt;codec_type == CODEC_TYPE_VIDEO || sc-&gt;dv_audio_container) {
-        int keyframe, sample_size;
-        int current_sample = 0;
-        int stts_sample = 0;
-        int distance = 0;
+        unsigned int current_sample = 0;
+        unsigned int stts_sample = 0;
+        unsigned int keyframe, sample_size;
+        unsigned int distance = 0;
 
         st-&gt;nb_frames = sc-&gt;sample_count;
         for (i = 0; i &lt; sc-&gt;chunk_count; i++) {
@@ -1499,6 +1273,10 @@
             if (stsc_index + 1 &lt; sc-&gt;sample_to_chunk_sz &amp;&amp; i + 1 == sc-&gt;sample_to_chunk[stsc_index + 1].first)
                 stsc_index++;
             for (j = 0; j &lt; sc-&gt;sample_to_chunk[stsc_index].count; j++) {
+                if (current_sample &gt;= sc-&gt;sample_count) {
+                    av_log(mov-&gt;fc, AV_LOG_ERROR, &quot;wrong sample count\n&quot;);
+                    goto out;
+                }
                 keyframe = !sc-&gt;keyframe_count || current_sample + 1 == sc-&gt;keyframes[stss_index];
                 if (keyframe) {
                     distance = 0;
@@ -1506,7 +1284,7 @@
                         stss_index++;
                 }
                 sample_size = sc-&gt;sample_size &gt; 0 ? sc-&gt;sample_size : sc-&gt;sample_sizes[current_sample];
-                dprintf(&quot;AVIndex stream %d, sample %d, offset %&quot;PRIx64&quot;, dts %&quot;PRId64&quot;, size %d, distance %d, keyframe %d\n&quot;,
+                dprintf(mov-&gt;fc, &quot;AVIndex stream %d, sample %d, offset %&quot;PRIx64&quot;, dts %&quot;PRId64&quot;, size %d, distance %d, keyframe %d\n&quot;,
                         st-&gt;index, current_sample, current_offset, current_dts, sample_size, distance, keyframe);
                 av_add_index_entry(st, current_offset, current_dts, sample_size, distance, keyframe ? AVINDEX_KEYFRAME : 0);
                 current_offset += sample_size;
@@ -1514,8 +1292,7 @@
                 current_dts += sc-&gt;stts_data[stts_index].duration / sc-&gt;time_rate;
                 distance++;
                 stts_sample++;
-                if (current_sample + 1 &lt; sc-&gt;sample_count)
-                    current_sample++;
+                current_sample++;
                 if (stts_index + 1 &lt; sc-&gt;stts_count &amp;&amp; stts_sample == sc-&gt;stts_data[stts_index].count) {
                     stts_sample = 0;
                     stts_index++;
@@ -1523,7 +1300,7 @@
             }
         }
     } else { /* read whole chunk */
-        int chunk_samples, chunk_size, chunk_duration;
+        unsigned int chunk_samples, chunk_size, chunk_duration;
 
         for (i = 0; i &lt; sc-&gt;chunk_count; i++) {
             current_offset = sc-&gt;chunk_offsets[i];
@@ -1533,8 +1310,8 @@
             /* get chunk size */
             if (sc-&gt;sample_size &gt; 1 || st-&gt;codec-&gt;codec_id == CODEC_ID_PCM_U8 || st-&gt;codec-&gt;codec_id == CODEC_ID_PCM_S8)
                 chunk_size = chunk_samples * sc-&gt;sample_size;
-            else if (sc-&gt;sample_size_v1.den &gt; 0 &amp;&amp; (chunk_samples * sc-&gt;sample_size_v1.num % sc-&gt;sample_size_v1.den == 0))
-                chunk_size = chunk_samples * sc-&gt;sample_size_v1.num / sc-&gt;sample_size_v1.den;
+            else if (sc-&gt;samples_per_frame &gt; 0 &amp;&amp; (chunk_samples * sc-&gt;bytes_per_frame % sc-&gt;samples_per_frame == 0))
+                chunk_size = chunk_samples * sc-&gt;bytes_per_frame / sc-&gt;samples_per_frame;
             else { /* workaround to find nearest next chunk offset */
                 chunk_size = INT_MAX;
                 for (j = 0; j &lt; mov-&gt;total_streams; j++) {
@@ -1551,7 +1328,7 @@
                 /* check for last chunk */
                 if (chunk_size == INT_MAX)
                     for (j = 0; j &lt; mov-&gt;mdat_count; j++) {
-                        dprintf(&quot;mdat %d, offset %&quot;PRIx64&quot;, size %&quot;PRId64&quot;, current offset %&quot;PRIx64&quot;\n&quot;,
+                        dprintf(mov-&gt;fc, &quot;mdat %d, offset %&quot;PRIx64&quot;, size %&quot;PRId64&quot;, current offset %&quot;PRIx64&quot;\n&quot;,
                                 j, mov-&gt;mdat_list[j].offset, mov-&gt;mdat_list[j].size, current_offset);
                         if (mov-&gt;mdat_list[j].offset &lt;= current_offset &amp;&amp; mov-&gt;mdat_list[j].offset + mov-&gt;mdat_list[j].size &gt; current_offset)
                             chunk_size = mov-&gt;mdat_list[j].offset + mov-&gt;mdat_list[j].size - current_offset;
@@ -1577,19 +1354,20 @@
                     }
                 }
             }
-            dprintf(&quot;AVIndex stream %d, chunk %d, offset %&quot;PRIx64&quot;, dts %&quot;PRId64&quot;, size %d, duration %d\n&quot;,
+            dprintf(mov-&gt;fc, &quot;AVIndex stream %d, chunk %d, offset %&quot;PRIx64&quot;, dts %&quot;PRId64&quot;, size %d, duration %d\n&quot;,
                     st-&gt;index, i, current_offset, current_dts, chunk_size, chunk_duration);
             assert(chunk_duration % sc-&gt;time_rate == 0);
             current_dts += chunk_duration / sc-&gt;time_rate;
         }
     }
+ out:
     /* adjust sample count to avindex entries */
     sc-&gt;sample_count = st-&gt;nb_index_entries;
 }
 
 static int mov_read_header(AVFormatContext *s, AVFormatParameters *ap)
 {
-    MOVContext *mov = (MOVContext *) s-&gt;priv_data;
+    MOVContext *mov = s-&gt;priv_data;
     ByteIOContext *pb = &amp;s-&gt;pb;
     int i, err;
     MOV_atom_t atom = { 0, 0, 0 };
@@ -1600,7 +1378,7 @@
     if(!url_is_streamed(pb)) /* .mov and .mp4 aren't streamable anyway (only progressive download if moov is before mdat) */
         atom.size = url_fsize(pb);
     else
-        atom.size = 0x7FFFFFFFFFFFFFFFLL;
+        atom.size = INT64_MAX;
 
     /* check MOV header */
     err = mov_read_default(mov, pb, atom);
@@ -1609,7 +1387,7 @@
                 err, mov-&gt;found_moov, mov-&gt;found_mdat, url_ftell(pb));
         return -1;
     }
-    dprintf(&quot;on_parse_exit_offset=%d\n&quot;, (int) url_ftell(pb));
+    dprintf(mov-&gt;fc, &quot;on_parse_exit_offset=%d\n&quot;, (int) url_ftell(pb));
 
     /* some cleanup : make sure we are on the mdat atom */
     if(!url_is_streamed(pb) &amp;&amp; (url_ftell(pb) != mov-&gt;mdat_offset))
@@ -1619,23 +1397,33 @@
 
     for(i=0; i&lt;mov-&gt;total_streams; i++) {
         MOVStreamContext *sc = mov-&gt;streams[i];
-
+        AVStream *st = s-&gt;streams[i];
+        /* sanity checks */
+        if(!sc-&gt;stts_count || !sc-&gt;chunk_count || !sc-&gt;sample_to_chunk_sz ||
+           (!sc-&gt;sample_size &amp;&amp; !sc-&gt;sample_count)){
+            av_log(s, AV_LOG_ERROR, &quot;missing mandatory atoms, broken header\n&quot;);
+            sc-&gt;sample_count = 0; //ignore track
+            continue;
+        }
         if(!sc-&gt;time_rate)
             sc-&gt;time_rate=1;
         if(!sc-&gt;time_scale)
             sc-&gt;time_scale= mov-&gt;time_scale;
-        av_set_pts_info(s-&gt;streams[i], 64, sc-&gt;time_rate, sc-&gt;time_scale);
+        av_set_pts_info(st, 64, sc-&gt;time_rate, sc-&gt;time_scale);
 
-        if(s-&gt;streams[i]-&gt;duration != AV_NOPTS_VALUE){
-            assert(s-&gt;streams[i]-&gt;duration % sc-&gt;time_rate == 0);
-            s-&gt;streams[i]-&gt;duration /= sc-&gt;time_rate;
+        if (st-&gt;codec-&gt;codec_type == CODEC_TYPE_AUDIO &amp;&amp; sc-&gt;stts_count == 1)
+            st-&gt;codec-&gt;frame_size = sc-&gt;stts_data[0].duration;
+
+        if(st-&gt;duration != AV_NOPTS_VALUE){
+            assert(st-&gt;duration % sc-&gt;time_rate == 0);
+            st-&gt;duration /= sc-&gt;time_rate;
         }
         sc-&gt;ffindex = i;
-        mov_build_index(mov, s-&gt;streams[i]);
+        mov_build_index(mov, st);
     }
 
     for(i=0; i&lt;mov-&gt;total_streams; i++) {
-        /* dont need those anymore */
+        /* Do not need those anymore. */
         av_freep(&amp;mov-&gt;streams[i]-&gt;chunk_offsets);
         av_freep(&amp;mov-&gt;streams[i]-&gt;sample_to_chunk);
         av_freep(&amp;mov-&gt;streams[i]-&gt;sample_sizes);
@@ -1661,7 +1449,7 @@
             AVIndexEntry *current_sample = &amp;s-&gt;streams[i]-&gt;index_entries[msc-&gt;current_sample];
             int64_t dts = av_rescale(current_sample-&gt;timestamp * (int64_t)msc-&gt;time_rate, AV_TIME_BASE, msc-&gt;time_scale);
 
-            dprintf(&quot;stream %d, sample %ld, dts %&quot;PRId64&quot;\n&quot;, i, msc-&gt;current_sample, dts);
+            dprintf(s, &quot;stream %d, sample %d, dts %&quot;PRId64&quot;\n&quot;, i, msc-&gt;current_sample, dts);
             if (dts &lt; best_dts) {
                 sample = current_sample;
                 best_dts = dts;
@@ -1680,7 +1468,7 @@
 #ifdef CONFIG_DV_DEMUXER
     if (sc-&gt;dv_audio_container) {
         dv_get_packet(mov-&gt;dv_demux, pkt);
-        dprintf(&quot;dv audio pkt size %d\n&quot;, pkt-&gt;size);
+        dprintf(s, &quot;dv audio pkt size %d\n&quot;, pkt-&gt;size);
     } else {
 #endif
         url_fseek(&amp;s-&gt;pb, sample-&gt;pos, SEEK_SET);
@@ -1709,7 +1497,7 @@
     }
     pkt-&gt;flags |= sample-&gt;flags &amp; AVINDEX_KEYFRAME ? PKT_FLAG_KEY : 0;
     pkt-&gt;pos = sample-&gt;pos;
-    dprintf(&quot;stream %d, pts %&quot;PRId64&quot;, dts %&quot;PRId64&quot;, pos 0x%&quot;PRIx64&quot;, duration %d\n&quot;, pkt-&gt;stream_index, pkt-&gt;pts, pkt-&gt;dts, pkt-&gt;pos, pkt-&gt;duration);
+    dprintf(s, &quot;stream %d, pts %&quot;PRId64&quot;, dts %&quot;PRId64&quot;, pos 0x%&quot;PRIx64&quot;, duration %d\n&quot;, pkt-&gt;stream_index, pkt-&gt;pts, pkt-&gt;dts, pkt-&gt;pos, pkt-&gt;duration);
     return 0;
 }
 
@@ -1720,21 +1508,22 @@
     int i;
 
     sample = av_index_search_timestamp(st, timestamp, flags);
-    dprintf(&quot;stream %d, timestamp %&quot;PRId64&quot;, sample %d\n&quot;, st-&gt;index, timestamp, sample);
+    dprintf(st-&gt;codec, &quot;stream %d, timestamp %&quot;PRId64&quot;, sample %d\n&quot;, st-&gt;index, timestamp, sample);
     if (sample &lt; 0) /* not sure what to do */
         return -1;
     sc-&gt;current_sample = sample;
-    dprintf(&quot;stream %d, found sample %ld\n&quot;, st-&gt;index, sc-&gt;current_sample);
+    dprintf(st-&gt;codec, &quot;stream %d, found sample %d\n&quot;, st-&gt;index, sc-&gt;current_sample);
     /* adjust ctts index */
     if (sc-&gt;ctts_data) {
         time_sample = 0;
         for (i = 0; i &lt; sc-&gt;ctts_count; i++) {
-            time_sample += sc-&gt;ctts_data[i].count;
-            if (time_sample &gt;= sc-&gt;current_sample) {
+            int next = time_sample + sc-&gt;ctts_data[i].count;
+            if (next &gt; sc-&gt;current_sample) {
                 sc-&gt;sample_to_ctime_index = i;
-                sc-&gt;sample_to_ctime_sample = time_sample - sc-&gt;current_sample;
+                sc-&gt;sample_to_ctime_sample = sc-&gt;current_sample - time_sample;
                 break;
             }
+            time_sample = next;
         }
     }
     return sample;
@@ -1772,12 +1561,11 @@
 static int mov_read_close(AVFormatContext *s)
 {
     int i;
-    MOVContext *mov = (MOVContext *) s-&gt;priv_data;
-    for(i=0; i&lt;mov-&gt;total_streams; i++)
-        mov_free_stream_context(mov-&gt;streams[i]);
-    /* free color tabs */
-    for(i=0; i&lt;mov-&gt;ctab_size; i++)
-        av_freep(&amp;mov-&gt;ctab[i]);
+    MOVContext *mov = s-&gt;priv_data;
+    for(i=0; i&lt;mov-&gt;total_streams; i++) {
+        av_freep(&amp;mov-&gt;streams[i]-&gt;ctts_data);
+        av_freep(&amp;mov-&gt;streams[i]);
+    }
     if(mov-&gt;dv_demux){
         for(i=0; i&lt;mov-&gt;dv_fctx-&gt;nb_streams; i++){
             av_freep(&amp;mov-&gt;dv_fctx-&gt;streams[i]-&gt;codec);
@@ -1786,7 +1574,6 @@
         av_freep(&amp;mov-&gt;dv_fctx);
         av_freep(&amp;mov-&gt;dv_demux);
     }
-    av_freep(&amp;mov-&gt;ctab);
     return 0;
 }
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/movenc.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/movenc.c	2007-07-16 16:39:52 UTC (rev 3382)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/movenc.c	2007-07-16 17:44:22 UTC (rev 3383)
@@ -19,8 +19,6 @@
  * License along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
-#include &quot;config.h&quot; 
-#define MEANX_PUT_MP3_IN_MP4A //MEANX
 #include &quot;avformat.h&quot;
 #include &quot;riff.h&quot;
 #include &quot;avio.h&quot;
@@ -43,6 +41,8 @@
 extern int ADM_useAlternateTagging(void);
 // MEANX
 
+
+
 typedef struct MOVIentry {
     unsigned int flags, size;
     uint64_t     pos;
@@ -84,7 +84,7 @@
     MOVTrack tracks[MAX_STREAMS];
 } MOVContext;
 
-//FIXME supprt 64bit varaint with wide placeholders
+//FIXME support 64 bit variant with wide placeholders
 static offset_t updateSize (ByteIOContext *pb, offset_t pos)
 {
     offset_t curpos = url_ftell(pb);
@@ -249,7 +249,7 @@
 
 static int mov_write_esds_tag(ByteIOContext *pb, MOVTrack* track) // Basic
 {
-  int codec_id;
+int codec_id; // MEANX
     offset_t pos = url_ftell(pb);
     int decoderSpecificInfoLen = track-&gt;vosLen ? descrLength(track-&gt;vosLen):0;
 
@@ -267,11 +267,13 @@
     putDescr(pb, 0x04, 13 + decoderSpecificInfoLen);
 
     // Object type indication
-    // MEANX
+  //MEANX  put_byte(pb, codec_get_tag(ff_mp4_obj_type, track-&gt;enc-&gt;codec_id));
+ // MEANX
     codec_id=track-&gt;enc-&gt;codec_id;
     if(ADM_useAlternateTagging() &amp;&amp; codec_id==CODEC_ID_MP3) codec_id=CODEC_ID_MP2;
-    put_byte(pb, codec_get_tag(ff_mov_obj_type, codec_id));
+    put_byte(pb, codec_get_tag(ff_mp4_obj_type, codec_id));
     // /MEANX
+
     // the following fields is made of 6 bits to identify the streamtype (4 for video, 5 for audio)
     // plus 1 bit to indicate upstream and 1 bit set to 1 (reserved)
     if(track-&gt;enc-&gt;codec_type == CODEC_TYPE_AUDIO)
@@ -332,33 +334,6 @@
     return updateSize (pb, pos);
 }
 
-static const AVCodecTag codec_movaudio_tags[] = {
-    { CODEC_ID_PCM_MULAW, MKTAG('u', 'l', 'a', 'w') },
-    { CODEC_ID_PCM_ALAW, MKTAG('a', 'l', 'a', 'w') },
-    { CODEC_ID_ADPCM_IMA_QT, MKTAG('i', 'm', 'a', '4') },
-    { CODEC_ID_MACE3, MKTAG('M', 'A', 'C', '3') },
-    { CODEC_ID_MACE6, MKTAG('M', 'A', 'C', '6') },
-    { CODEC_ID_AAC, MKTAG('m', 'p', '4', 'a') },
-    { CODEC_ID_AMR_NB, MKTAG('s', 'a', 'm', 'r') },
-    { CODEC_ID_AMR_WB, MKTAG('s', 'a', 'w', 'b') },
-    { CODEC_ID_PCM_S16BE, MKTAG('t', 'w', 'o', 's') },
-    { CODEC_ID_PCM_S16LE, MKTAG('s', 'o', 'w', 't') },
-    { CODEC_ID_PCM_S24BE, MKTAG('i', 'n', '2', '4') },
-    { CODEC_ID_PCM_S24LE, MKTAG('i', 'n', '2', '4') },
-    { CODEC_ID_PCM_S32BE, MKTAG('i', 'n', '3', '2') },
-    { CODEC_ID_PCM_S32LE, MKTAG('i', 'n', '3', '2') },
-    //{ CODEC_ID_MP3, MKTAG('.', 'm', 'p', '3') },
-   // MEANX
-#ifdef MEANX_PUT_MP3_IN_MP4A
-    { CODEC_ID_MP3, MKTAG( 'm', 'p', '4','a') },
-#else
-    { CODEC_ID_MP3, MKTAG('.', 'm', 'p', '3') },
-#endif
-//MEANX
-
-    { CODEC_ID_NONE, 0 },
-};
-
 static int mov_write_audio_tag(ByteIOContext *pb, MOVTrack* track)
 {
     offset_t pos = url_ftell(pb);
@@ -378,11 +353,20 @@
     put_be16(pb, 0); /* Revision level */
     put_be32(pb, 0); /* Reserved */
 
-    put_be16(pb, track-&gt;mode == MODE_MOV ? track-&gt;enc-&gt;channels : 2); /* Number of channels */
-    /* FIXME 8 bit for 'raw ' in mov */
-    put_be16(pb, 16); /* Reserved */
+    if (track-&gt;mode == MODE_MOV) {
+        put_be16(pb, track-&gt;enc-&gt;channels);
+        if (track-&gt;enc-&gt;codec_id == CODEC_ID_PCM_U8 ||
+            track-&gt;enc-&gt;codec_id == CODEC_ID_PCM_S8)
+            put_be16(pb, 8); /* bits per sample */
+        else
+            put_be16(pb, 16);
+        put_be16(pb, track-&gt;audio_vbr ? -2 : 0); /* compression ID */
+    } else { /* reserved for mp4/3gp */
+        put_be16(pb, 2);
+        put_be16(pb, 16);
+        put_be16(pb, 0);
+    }
 
-    put_be16(pb, track-&gt;mode == MODE_MOV &amp;&amp; track-&gt;audio_vbr ? -2 : 0); /* compression ID */
     put_be16(pb, 0); /* packet size (= 0) */
     put_be16(pb, track-&gt;timescale); /* Time scale */
     put_be16(pb, 0); /* Reserved */
@@ -400,15 +384,8 @@
         track-&gt;enc-&gt;codec_id == CODEC_ID_PCM_S24LE ||
         track-&gt;enc-&gt;codec_id == CODEC_ID_PCM_S32LE))
         mov_write_wave_tag(pb, track);
-    else if(track-&gt;enc-&gt;codec_id == CODEC_ID_AAC
- //MEANX
-#ifdef MEANX_PUT_MP3_IN_MP4A
-   || track-&gt;enc-&gt;codec_id == CODEC_ID_MP3
-#endif
-//MEANX
- 
-    
-    )
+    else if(track-&gt;enc-&gt;codec_id == CODEC_ID_AAC // MEANX)
+       || track-&gt;enc-&gt;codec_id == CODEC_ID_MP3) // MEANX
         mov_write_esds_tag(pb, track);
     else if(track-&gt;enc-&gt;codec_id == CODEC_ID_AMR_NB)
         mov_write_amr_tag(pb, track);
@@ -443,7 +420,7 @@
 
 static uint8_t *avc_find_startcode( uint8_t *p, uint8_t *end )
 {
-    uint8_t *a = p + 4 - ((int)p &amp; 3);
+    uint8_t *a = p + 4 - ((long)p &amp; 3);
 
     for( end -= 3; p &lt; a &amp;&amp; p &lt; end; p++ ) {
         if( p[0] == 0 &amp;&amp; p[1] == 0 &amp;&amp; p[2] == 1 )
@@ -552,22 +529,6 @@
     return updateSize(pb, pos);
 }
 
-static const AVCodecTag codec_movvideo_tags[] = {
-    { CODEC_ID_SVQ1, MKTAG('S', 'V', 'Q', '1') },
-    { CODEC_ID_SVQ3, MKTAG('S', 'V', 'Q', '3') },
-    { CODEC_ID_MPEG4, MKTAG('m', 'p', '4', 'v') },
-    { CODEC_ID_H263, MKTAG('h', '2', '6', '3') },
-    { CODEC_ID_H263, MKTAG('s', '2', '6', '3') },
-    { CODEC_ID_H264, MKTAG('a', 'v', 'c', '1') },
-    /* special handling in mov_find_video_codec_tag */
-    { CODEC_ID_DVVIDEO, MKTAG('d', 'v', 'c', ' ') }, /* DV NTSC */
-    { CODEC_ID_DVVIDEO, MKTAG('d', 'v', 'c', 'p') }, /* DV PAL */
-    { CODEC_ID_DVVIDEO, MKTAG('d', 'v', 'p', 'p') }, /* DVCPRO PAL */
-    { CODEC_ID_DVVIDEO, MKTAG('d', 'v', '5', 'n') }, /* DVCPRO50 NTSC */
-    { CODEC_ID_DVVIDEO, MKTAG('d', 'v', '5', 'p') }, /* DVCPRO50 PAL */
-    { CODEC_ID_NONE, 0 },
-};
-
 static int mov_find_video_codec_tag(AVFormatContext *s, MOVTrack *track)
 {
     int tag = track-&gt;enc-&gt;codec_tag;
@@ -695,7 +656,7 @@
 
 static int mov_write_ctts_tag(ByteIOContext *pb, MOVTrack* track)
 {
-    Time2Sample *ctts_entries;
+    MOV_stts_t *ctts_entries;
     uint32_t entries = 0;
     uint32_t atom_size;
     int i;
@@ -729,7 +690,7 @@
 /* Time to sample atom */
 static int mov_write_stts_tag(ByteIOContext *pb, MOVTrack* track)
 {
-    Time2Sample *stts_entries;
+    MOV_stts_t *stts_entries;
     uint32_t entries = -1;
     uint32_t atom_size;
     int i;
@@ -897,6 +858,14 @@
     (version == 1) ? put_be64(pb, track-&gt;trackDuration) : put_be32(pb, track-&gt;trackDuration); /* duration */
     put_be16(pb, track-&gt;language); /* language */
     put_be16(pb, 0); /* reserved (quality) */
+
+    if(version!=0 &amp;&amp; track-&gt;mode == MODE_MOV){
+        av_log(NULL, AV_LOG_ERROR,
+            &quot;FATAL error, file duration too long for timebase, this file will not be\n&quot;
+            &quot;playable with quicktime. Choose a different timebase or a different\n&quot;
+            &quot;container format\n&quot;);
+    }
+
     return 32;
 }
 
@@ -978,11 +947,12 @@
 
     put_be32(pb, av_rescale_rnd(track-&gt;trackDuration, globalTimescale, track-&gt;timescale, AV_ROUND_UP)); /* duration   ... doesn't seem to effect psp */
 
-    //MEANX NO put_be32(pb, track-&gt;cluster[0].cts); /* first pts is cts since dts is 0 */
-    put_be32(pb, 0x00000000);
+    // MEANX : NO put_be32(pb, track-&gt;cluster[0].cts); /* first pts is cts since dts is 0 */
+      put_be32(pb, 0x00000000);
     // /MEANX
 
-    put_be32(pb, 0x1); // MEANXput_be32(pb, 0x00010000);
+
+    put_be32(pb, 0x0001); // MEANX put_be32(pb, 0x00010000);
     return 0x24;
 }
 
@@ -1229,7 +1199,7 @@
     /* iTunes meta data */
     mov_write_meta_tag(pb, mov, s);
 
-  if(mov-&gt;mode == MODE_MOV){ // the title field breaks gtkpod with mp4 and my suspicion is that stuff isnt valid in mp4
+  if(mov-&gt;mode == MODE_MOV){ // the title field breaks gtkpod with mp4 and my suspicion is that stuff is not valid in mp4
     /* Requirements */
     for (i=0; i&lt;mov-&gt;nb_streams; i++) {
         if(mov-&gt;tracks[i].entry &lt;= 0) continue;
@@ -1500,6 +1470,11 @@
     MOVContext *mov = s-&gt;priv_data;
     int i;
 
+    if (url_is_streamed(&amp;s-&gt;pb)) {
+        av_log(s, AV_LOG_ERROR, &quot;muxer does not support non seekable output\n&quot;);
+        return -1;
+    }
+
     /* Default mode == MP4 */
     mov-&gt;mode = MODE_MP4;
 
@@ -1530,24 +1505,23 @@
             track-&gt;tag = mov_find_video_codec_tag(s, track);
             track-&gt;timescale = st-&gt;codec-&gt;time_base.den;
             av_set_pts_info(st, 64, 1, st-&gt;codec-&gt;time_base.den);
+            if (track-&gt;timescale &gt; 100000)
+                av_log(NULL, AV_LOG_WARNING,
+                       &quot;WARNING codec timebase is very high. If duration is too long,\n&quot;
+                       &quot;file may not be playable by quicktime. Specify a shorter timebase\n&quot;
+                       &quot;or choose different container.\n&quot;);
         }else if(st-&gt;codec-&gt;codec_type == CODEC_TYPE_AUDIO){
             track-&gt;tag = mov_find_audio_codec_tag(s, track);
             track-&gt;timescale = st-&gt;codec-&gt;sample_rate;
             av_set_pts_info(st, 64, 1, st-&gt;codec-&gt;sample_rate);
-            switch(track-&gt;enc-&gt;codec_id){
-            case CODEC_ID_MP3:
-            case CODEC_ID_AAC:
-            case CODEC_ID_AMR_NB:
-            case CODEC_ID_AMR_WB:
+            if(!st-&gt;codec-&gt;frame_size){
+                av_log(s, AV_LOG_ERROR, &quot;track %d: codec frame size is not set\n&quot;, i);
+                return -1;
+            }else if(st-&gt;codec-&gt;frame_size &gt; 1){ /* assume compressed audio */
                 track-&gt;audio_vbr = 1;
-                break;
-            default:
+            }else{
                 track-&gt;sampleSize = (av_get_bits_per_sample(st-&gt;codec-&gt;codec_id) &gt;&gt; 3) * st-&gt;codec-&gt;channels;
             }
-            if (!st-&gt;codec-&gt;frame_size) {
-                av_log(s, AV_LOG_ERROR, &quot;track %d: codec frame size is not set\n&quot;, i);
-                return -1;
-            }
         }
     }
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/mpeg.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/mpeg.c	2007-07-16 16:39:52 UTC (rev 3382)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/mpeg.c	2007-07-16 17:44:22 UTC (rev 3383)
@@ -1,5 +1,5 @@
 /*
- * MPEG1/2 muxer and demuxer
+ * MPEG1/2 demuxer
  * Copyright (c) 2000, 2001, 2002 Fabrice Bellard.
  *
  * This file is part of FFmpeg.
@@ -18,1240 +18,15 @@
  * License along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
+
 #include &quot;avformat.h&quot;
-#include &quot;bitstream.h&quot;
-#include &quot;fifo.h&quot;
+#include &quot;mpeg.h&quot;
 
-#define MAX_PAYLOAD_SIZE 4096
 //#define DEBUG_SEEK
 
 #undef NDEBUG
 #include &lt;assert.h&gt;
 
-typedef struct PacketDesc {
-    int64_t pts;
-    int64_t dts;
-    int size;
-    int unwritten_size;
-    int flags;
-    struct PacketDesc *next;
-} PacketDesc;
-
-typedef struct {
-    AVFifoBuffer fifo;
-    uint8_t id;
-    int max_buffer_size; /* in bytes */
-    int buffer_index;
-    PacketDesc *predecode_packet;
-    PacketDesc *premux_packet;
-    PacketDesc **next_packet;
-    int packet_number;
-    uint8_t lpcm_header[3];
-    int lpcm_align;
-    int bytes_to_iframe;
-    int align_iframe;
-    int64_t vobu_start_pts;
-} StreamInfo;
-
-typedef struct {
-    int packet_size; /* required packet size */
-    int packet_number;
-    int pack_header_freq;     /* frequency (in packets^-1) at which we send pack headers */
-    int system_header_freq;
-    int system_header_size;
-    int mux_rate; /* bitrate in units of 50 bytes/s */
-    /* stream info */
-    int audio_bound;
-    int video_bound;
-    int is_mpeg2;
-    int is_vcd;
-    int is_svcd;
-    int is_dvd;
-    int64_t last_scr; /* current system clock */
-
-    double vcd_padding_bitrate; //FIXME floats
-    int64_t vcd_padding_bytes_written;
-
-} MpegMuxContext;
-
-#define PACK_START_CODE             ((unsigned int)0x000001ba)
-#define SYSTEM_HEADER_START_CODE    ((unsigned int)0x000001bb)
-#define SEQUENCE_END_CODE           ((unsigned int)0x000001b7)
-#define PACKET_START_CODE_MASK      ((unsigned int)0xffffff00)
-#define PACKET_START_CODE_PREFIX    ((unsigned int)0x00000100)
-#define ISO_11172_END_CODE          ((unsigned int)0x000001b9)
-
-/* mpeg2 */
-#define PROGRAM_STREAM_MAP 0x1bc
-#define PRIVATE_STREAM_1   0x1bd
-#define PADDING_STREAM     0x1be
-#define PRIVATE_STREAM_2   0x1bf
-
-
-#define AUDIO_ID 0xc0
-#define VIDEO_ID 0xe0
-#define AC3_ID   0x80
-#define DTS_ID   0x8a
-#define LPCM_ID  0xa0
-#define SUB_ID   0x20
-
-#define STREAM_TYPE_VIDEO_MPEG1     0x01
-#define STREAM_TYPE_VIDEO_MPEG2     0x02
-#define STREAM_TYPE_AUDIO_MPEG1     0x03
-#define STREAM_TYPE_AUDIO_MPEG2     0x04
-#define STREAM_TYPE_PRIVATE_SECTION 0x05
-#define STREAM_TYPE_PRIVATE_DATA    0x06
-#define STREAM_TYPE_AUDIO_AAC       0x0f
-#define STREAM_TYPE_VIDEO_MPEG4     0x10
-#define STREAM_TYPE_VIDEO_H264      0x1b
-
-#define STREAM_TYPE_AUDIO_AC3       0x81
-#define STREAM_TYPE_AUDIO_DTS       0x8a
-
-static const int lpcm_freq_tab[4] = { 48000, 96000, 44100, 32000 };
-
-#ifdef CONFIG_MUXERS
-AVOutputFormat mpeg1system_muxer;
-AVOutputFormat mpeg1vcd_muxer;
-AVOutputFormat mpeg2vob_muxer;
-AVOutputFormat mpeg2svcd_muxer;
-AVOutputFormat mpeg2dvd_muxer;
-
-static int put_pack_header(AVFormatContext *ctx,
-                           uint8_t *buf, int64_t timestamp)
-{
-    MpegMuxContext *s = ctx-&gt;priv_data;
-    PutBitContext pb;
-
-    init_put_bits(&amp;pb, buf, 128);
-
-    put_bits(&amp;pb, 32, PACK_START_CODE);
-    if (s-&gt;is_mpeg2) {
-        put_bits(&amp;pb, 2, 0x1);
-    } else {
-        put_bits(&amp;pb, 4, 0x2);
-    }
-    put_bits(&amp;pb, 3, (uint32_t)((timestamp &gt;&gt; 30) &amp; 0x07));
-    put_bits(&amp;pb, 1, 1);
-    put_bits(&amp;pb, 15, (uint32_t)((timestamp &gt;&gt; 15) &amp; 0x7fff));
-    put_bits(&amp;pb, 1, 1);
-    put_bits(&amp;pb, 15, (uint32_t)((timestamp) &amp; 0x7fff));
-    put_bits(&amp;pb, 1, 1);
-    if (s-&gt;is_mpeg2) {
-        /* clock extension */
-        put_bits(&amp;pb, 9, 0);
-    }
-    put_bits(&amp;pb, 1, 1);
-    put_bits(&amp;pb, 22, s-&gt;mux_rate);
-    put_bits(&amp;pb, 1, 1);
-    if (s-&gt;is_mpeg2) {
-        put_bits(&amp;pb, 1, 1);
-        put_bits(&amp;pb, 5, 0x1f); /* reserved */
-        put_bits(&amp;pb, 3, 0); /* stuffing length */
-    }
-    flush_put_bits(&amp;pb);
-    return pbBufPtr(&amp;pb) - pb.buf;
-}
-
-static int put_system_header(AVFormatContext *ctx, uint8_t *buf,int only_for_stream_id)
-{
-    MpegMuxContext *s = ctx-&gt;priv_data;
-    int size, i, private_stream_coded, id;
-    PutBitContext pb;
-
-    init_put_bits(&amp;pb, buf, 128);
-
-    put_bits(&amp;pb, 32, SYSTEM_HEADER_START_CODE);
-    put_bits(&amp;pb, 16, 0);
-    put_bits(&amp;pb, 1, 1);
-
-    put_bits(&amp;pb, 22, s-&gt;mux_rate); /* maximum bit rate of the multiplexed stream */
-    put_bits(&amp;pb, 1, 1); /* marker */
-    if (s-&gt;is_vcd &amp;&amp; only_for_stream_id==VIDEO_ID) {
-        /* This header applies only to the video stream (see VCD standard p. IV-7)*/
-        put_bits(&amp;pb, 6, 0);
-    } else
-        put_bits(&amp;pb, 6, s-&gt;audio_bound);
-
-    if (s-&gt;is_vcd) {
-        /* see VCD standard, p. IV-7*/
-        put_bits(&amp;pb, 1, 0);
-        put_bits(&amp;pb, 1, 1);
-    } else {
-        put_bits(&amp;pb, 1, 0); /* variable bitrate*/
-        put_bits(&amp;pb, 1, 0); /* non constrainted bit stream */
-    }
-
-    if (s-&gt;is_vcd || s-&gt;is_dvd) {
-        /* see VCD standard p IV-7 */
-        put_bits(&amp;pb, 1, 1); /* audio locked */
-        put_bits(&amp;pb, 1, 1); /* video locked */
-    } else {
-        put_bits(&amp;pb, 1, 0); /* audio locked */
-        put_bits(&amp;pb, 1, 0); /* video locked */
-    }
-
-    put_bits(&amp;pb, 1, 1); /* marker */
-
-    if (s-&gt;is_vcd &amp;&amp; only_for_stream_id==AUDIO_ID) {
-        /* This header applies only to the audio stream (see VCD standard p. IV-7)*/
-        put_bits(&amp;pb, 5, 0);
-    } else
-        put_bits(&amp;pb, 5, s-&gt;video_bound);
-
-    if (s-&gt;is_dvd) {
-        put_bits(&amp;pb, 1, 0);    /* packet_rate_restriction_flag */
-        put_bits(&amp;pb, 7, 0x7f); /* reserved byte */
-    } else
-        put_bits(&amp;pb, 8, 0xff); /* reserved byte */
-
-    /* DVD-Video Stream_bound entries
-    id (0xB9) video, maximum P-STD for stream 0xE0. (P-STD_buffer_bound_scale = 1)
-    id (0xB8) audio, maximum P-STD for any MPEG audio (0xC0 to 0xC7) streams. If there are none set to 4096 (32x128). (P-STD_buffer_bound_scale = 0)
-    id (0xBD) private stream 1 (audio other than MPEG and subpictures). (P-STD_buffer_bound_scale = 1)
-    id (0xBF) private stream 2, NAV packs, set to 2x1024. */
-    if (s-&gt;is_dvd) {
-
-        int P_STD_max_video = 0;
-        int P_STD_max_mpeg_audio = 0;
-        int P_STD_max_mpeg_PS1 = 0;
-
-        for(i=0;i&lt;ctx-&gt;nb_streams;i++) {
-            StreamInfo *stream = ctx-&gt;streams[i]-&gt;priv_data;
-
-            id = stream-&gt;id;
-            if (id == 0xbd &amp;&amp; stream-&gt;max_buffer_size &gt; P_STD_max_mpeg_PS1) {
-                P_STD_max_mpeg_PS1 = stream-&gt;max_buffer_size;
-            } else if (id &gt;= 0xc0 &amp;&amp; id &lt;= 0xc7 &amp;&amp; stream-&gt;max_buffer_size &gt; P_STD_max_mpeg_audio) {
-                P_STD_max_mpeg_audio = stream-&gt;max_buffer_size;
-            } else if (id == 0xe0 &amp;&amp; stream-&gt;max_buffer_size &gt; P_STD_max_video) {
-                P_STD_max_video = stream-&gt;max_buffer_size;
-            }
-        }
-
-        /* video */
-        put_bits(&amp;pb, 8, 0xb9); /* stream ID */
-        put_bits(&amp;pb, 2, 3);
-        put_bits(&amp;pb, 1, 1);
-        put_bits(&amp;pb, 13, P_STD_max_video / 1024);
-
-        /* audio */
-        if (P_STD_max_mpeg_audio == 0)
-            P_STD_max_mpeg_audio = 4096;
-        put_bits(&amp;pb, 8, 0xb8); /* stream ID */
-        put_bits(&amp;pb, 2, 3);
-        put_bits(&amp;pb, 1, 0);
-        put_bits(&amp;pb, 13, P_STD_max_mpeg_audio / 128);
-
-        /* private stream 1 */
-        put_bits(&amp;pb, 8, 0xbd); /* stream ID */
-        put_bits(&amp;pb, 2, 3);
-        put_bits(&amp;pb, 1, 0);
-        put_bits(&amp;pb, 13, P_STD_max_mpeg_PS1 / 128);
-
-        /* private stream 2 */
-        put_bits(&amp;pb, 8, 0xbf); /* stream ID */
-        put_bits(&amp;pb, 2, 3);
-        put_bits(&amp;pb, 1, 1);
-        put_bits(&amp;pb, 13, 2);
-    }
-    else {
-        /* audio stream info */
-        private_stream_coded = 0;
-        for(i=0;i&lt;ctx-&gt;nb_streams;i++) {
-            StreamInfo *stream = ctx-&gt;streams[i]-&gt;priv_data;
-
-
-            /* For VCDs, only include the stream info for the stream
-            that the pack which contains this system belongs to.
-            (see VCD standard p. IV-7) */
-            if ( !s-&gt;is_vcd || stream-&gt;id==only_for_stream_id
-                || only_for_stream_id==0) {
-
-                id = stream-&gt;id;
-                if (id &lt; 0xc0) {
-                    /* special case for private streams (AC3 use that) */
-                    if (private_stream_coded)
-                        continue;
-                    private_stream_coded = 1;
-                    id = 0xbd;
-                }
-                put_bits(&amp;pb, 8, id); /* stream ID */
-                put_bits(&amp;pb, 2, 3);
-                if (id &lt; 0xe0) {
-                    /* audio */
-                    put_bits(&amp;pb, 1, 0);
-                    put_bits(&amp;pb, 13, stream-&gt;max_buffer_size / 128);
-                } else {
-                    /* video */
-                    put_bits(&amp;pb, 1, 1);
-                    put_bits(&amp;pb, 13, stream-&gt;max_buffer_size / 1024);
-                }
-            }
-        }
-    }
-
-    flush_put_bits(&amp;pb);
-    size = pbBufPtr(&amp;pb) - pb.buf;
-    /* patch packet size */
-    buf[4] = (size - 6) &gt;&gt; 8;
-    buf[5] = (size - 6) &amp; 0xff;
-
-    return size;
-}
-
-static int get_system_header_size(AVFormatContext *ctx)
-{
-    int buf_index, i, private_stream_coded;
-    StreamInfo *stream;
-    MpegMuxContext *s = ctx-&gt;priv_data;
-
-    if (s-&gt;is_dvd)
-       return 18; // DVD-Video system headers are 18 bytes fixed length.
-
-    buf_index = 12;
-    private_stream_coded = 0;
-    for(i=0;i&lt;ctx-&gt;nb_streams;i++) {
-        stream = ctx-&gt;streams[i]-&gt;priv_data;
-        if (stream-&gt;id &lt; 0xc0) {
-            if (private_stream_coded)
-                continue;
-            private_stream_coded = 1;
-        }
-        buf_index += 3;
-    }
-    return buf_index;
-}
-
-static int mpeg_mux_init(AVFormatContext *ctx)
-{
-    MpegMuxContext *s = ctx-&gt;priv_data;
-    int bitrate, i, mpa_id, mpv_id, mps_id, ac3_id, dts_id, lpcm_id, j;
-    AVStream *st;
-    StreamInfo *stream;
-    int audio_bitrate;
-    int video_bitrate;
-
-    s-&gt;packet_number = 0;
-    s-&gt;is_vcd = (ctx-&gt;oformat == &amp;mpeg1vcd_muxer);
-    s-&gt;is_svcd = (ctx-&gt;oformat == &amp;mpeg2svcd_muxer);
-    s-&gt;is_mpeg2 = (ctx-&gt;oformat == &amp;mpeg2vob_muxer || ctx-&gt;oformat == &amp;mpeg2svcd_muxer || ctx-&gt;oformat == &amp;mpeg2dvd_muxer);
-    s-&gt;is_dvd = (ctx-&gt;oformat == &amp;mpeg2dvd_muxer);
-
-    if(ctx-&gt;packet_size)
-        s-&gt;packet_size = ctx-&gt;packet_size;
-    else
-        s-&gt;packet_size = 2048;
-
-    s-&gt;vcd_padding_bytes_written = 0;
-    s-&gt;vcd_padding_bitrate=0;
-
-    s-&gt;audio_bound = 0;
-    s-&gt;video_bound = 0;
-    mpa_id = AUDIO_ID;
-    ac3_id = AC3_ID;
-    dts_id = DTS_ID;
-    mpv_id = VIDEO_ID;
-    mps_id = SUB_ID;
-    lpcm_id = LPCM_ID;
-    for(i=0;i&lt;ctx-&gt;nb_streams;i++) {
-        st = ctx-&gt;streams[i];
-        stream = av_mallocz(sizeof(StreamInfo));
-        if (!stream)
-            goto fail;
-        st-&gt;priv_data = stream;
-
-        av_set_pts_info(st, 64, 1, 90000);
-
-        switch(st-&gt;codec-&gt;codec_type) {
-        case CODEC_TYPE_AUDIO:
-            if (st-&gt;codec-&gt;codec_id == CODEC_ID_AC3) {
-                stream-&gt;id = ac3_id++;
-            } else if (st-&gt;codec-&gt;codec_id == CODEC_ID_DTS) {
-                stream-&gt;id = dts_id++;
-            } else if (st-&gt;codec-&gt;codec_id == CODEC_ID_PCM_S16BE) {
-                stream-&gt;id = lpcm_id++;
-                for(j = 0; j &lt; 4; j++) {
-                    if (lpcm_freq_tab[j] == st-&gt;codec-&gt;sample_rate)
-                        break;
-                }
-                if (j == 4)
-                    goto fail;
-                if (st-&gt;codec-&gt;channels &gt; 8)
-                    return -1;
-                stream-&gt;lpcm_header[0] = 0x0c;
-                stream-&gt;lpcm_header[1] = (st-&gt;codec-&gt;channels - 1) | (j &lt;&lt; 4);
-                stream-&gt;lpcm_header[2] = 0x80;
-                stream-&gt;lpcm_align = st-&gt;codec-&gt;channels * 2;
-            } else {
-                stream-&gt;id = mpa_id++;
-            }
-
-            /* This value HAS to be used for VCD (see VCD standard, p. IV-7).
-               Right now it is also used for everything else.*/
-            stream-&gt;max_buffer_size = 4 * 1024;
-            s-&gt;audio_bound++;
-            break;
-        case CODEC_TYPE_VIDEO:
-            stream-&gt;id = mpv_id++;
-            if (st-&gt;codec-&gt;rc_buffer_size)
-                stream-&gt;max_buffer_size = 6*1024 + st-&gt;codec-&gt;rc_buffer_size/8;
-            else
-                stream-&gt;max_buffer_size = 230*1024; //FIXME this is probably too small as default
-#if 0
-                /* see VCD standard, p. IV-7*/
-                stream-&gt;max_buffer_size = 46 * 1024;
-            else
-                /* This value HAS to be used for SVCD (see SVCD standard, p. 26 V.2.3.2).
-                   Right now it is also used for everything else.*/
-                stream-&gt;max_buffer_size = 230 * 1024;
-#endif
-            s-&gt;video_bound++;
-            break;
-        case CODEC_TYPE_SUBTITLE:
-            stream-&gt;id = mps_id++;
-            stream-&gt;max_buffer_size = 16 * 1024;
-            break;
-        default:
-            return -1;
-        }
-        av_fifo_init(&amp;stream-&gt;fifo, 16);
-    }
-    bitrate = 0;
-    audio_bitrate = 0;
-    video_bitrate = 0;
-    for(i=0;i&lt;ctx-&gt;nb_streams;i++) {
-        int codec_rate;
-        st = ctx-&gt;streams[i];
-        stream = (StreamInfo*) st-&gt;priv_data;
-
-        if(st-&gt;codec-&gt;rc_max_rate || stream-&gt;id==VIDEO_ID)
-            codec_rate= st-&gt;codec-&gt;rc_max_rate;
-        else
-            codec_rate= st-&gt;codec-&gt;bit_rate;
-
-        if(!codec_rate)
-            codec_rate= (1&lt;&lt;21)*8*50/ctx-&gt;nb_streams;
-
-        bitrate += codec_rate;
-
-        if (stream-&gt;id==AUDIO_ID)
-            audio_bitrate += codec_rate;
-        else if (stream-&gt;id==VIDEO_ID)
-            video_bitrate += codec_rate;
-    }
-
-    if(ctx-&gt;mux_rate){
-        s-&gt;mux_rate= (ctx-&gt;mux_rate + (8 * 50) - 1) / (8 * 50);
-    } else {
-        /* we increase slightly the bitrate to take into account the
-           headers. XXX: compute it exactly */
-        bitrate += bitrate*5/100;
-        bitrate += 10000;
-        s-&gt;mux_rate = (bitrate + (8 * 50) - 1) / (8 * 50);
-    }
-
-    if (s-&gt;is_vcd) {
-        double overhead_rate;
-
-        /* The VCD standard mandates that the mux_rate field is 3528
-           (see standard p. IV-6).
-           The value is actually &quot;wrong&quot;, i.e. if you calculate
-           it using the normal formula and the 75 sectors per second transfer
-           rate you get a different value because the real pack size is 2324,
-           not 2352. But the standard explicitly specifies that the mux_rate
-           field in the header must have this value.*/
-//        s-&gt;mux_rate=2352 * 75 / 50;    /* = 3528*/
-
-        /* The VCD standard states that the muxed stream must be
-           exactly 75 packs / second (the data rate of a single speed cdrom).
-           Since the video bitrate (probably 1150000 bits/sec) will be below
-           the theoretical maximum we have to add some padding packets
-           to make up for the lower data rate.
-           (cf. VCD standard p. IV-6 )*/
-
-        /* Add the header overhead to the data rate.
-           2279 data bytes per audio pack, 2294 data bytes per video pack*/
-        overhead_rate = ((audio_bitrate / 8.0) / 2279) * (2324 - 2279);
-        overhead_rate += ((video_bitrate / 8.0) / 2294) * (2324 - 2294);
-        overhead_rate *= 8;
-
-        /* Add padding so that the full bitrate is 2324*75 bytes/sec */
-        s-&gt;vcd_padding_bitrate = 2324 * 75 * 8 - (bitrate + overhead_rate);
-    }
-
-    if (s-&gt;is_vcd || s-&gt;is_mpeg2)
-        /* every packet */
-        s-&gt;pack_header_freq = 1;
-    else
-        /* every 2 seconds */
-        s-&gt;pack_header_freq = 2 * bitrate / s-&gt;packet_size / 8;
-
-    /* the above seems to make pack_header_freq zero sometimes */
-    if (s-&gt;pack_header_freq == 0)
-       s-&gt;pack_header_freq = 1;
-
-    if (s-&gt;is_mpeg2)
-        /* every 200 packets. Need to look at the spec.  */
-        s-&gt;system_header_freq = s-&gt;pack_header_freq * 40;
-    else if (s-&gt;is_vcd)
-        /* the standard mandates that there are only two system headers
-           in the whole file: one in the first packet of each stream.
-           (see standard p. IV-7 and IV-8) */
-        s-&gt;system_header_freq = 0x7fffffff;
-    else
-        s-&gt;system_header_freq = s-&gt;pack_header_freq * 5;
-
-    for(i=0;i&lt;ctx-&gt;nb_streams;i++) {
-        stream = ctx-&gt;streams[i]-&gt;priv_data;
-        stream-&gt;packet_number = 0;
-    }
-    s-&gt;system_header_size = get_system_header_size(ctx);
-    s-&gt;last_scr = 0;
-    return 0;
- fail:
-    for(i=0;i&lt;ctx-&gt;nb_streams;i++) {
-        av_free(ctx-&gt;streams[i]-&gt;priv_data);
-    }
-    return -ENOMEM;
-}
-
-static inline void put_timestamp(ByteIOContext *pb, int id, int64_t timestamp)
-{
-    put_byte(pb,
-             (id &lt;&lt; 4) |
-             (((timestamp &gt;&gt; 30) &amp; 0x07) &lt;&lt; 1) |
-             1);
-    put_be16(pb, (uint16_t)((((timestamp &gt;&gt; 15) &amp; 0x7fff) &lt;&lt; 1) | 1));
-    put_be16(pb, (uint16_t)((((timestamp) &amp; 0x7fff) &lt;&lt; 1) | 1));
-}
-
-
-/* return the number of padding bytes that should be inserted into
-   the multiplexed stream.*/
-static int get_vcd_padding_size(AVFormatContext *ctx, int64_t pts)
-{
-    MpegMuxContext *s = ctx-&gt;priv_data;
-    int pad_bytes = 0;
-
-    if (s-&gt;vcd_padding_bitrate &gt; 0 &amp;&amp; pts!=AV_NOPTS_VALUE)
-    {
-        int64_t full_pad_bytes;
-
-        full_pad_bytes = (int64_t)((s-&gt;vcd_padding_bitrate * (pts / 90000.0)) / 8.0); //FIXME this is wrong
-        pad_bytes = (int) (full_pad_bytes - s-&gt;vcd_padding_bytes_written);
-
-        if (pad_bytes&lt;0)
-            /* might happen if we have already padded to a later timestamp. This
-               can occur if another stream has already advanced further.*/
-            pad_bytes=0;
-    }
-
-    return pad_bytes;
-}
-
-
-#if 0 /* unused, remove? */
-/* return the exact available payload size for the next packet for
-   stream 'stream_index'. 'pts' and 'dts' are only used to know if
-   timestamps are needed in the packet header. */
-static int get_packet_payload_size(AVFormatContext *ctx, int stream_index,
-                                   int64_t pts, int64_t dts)
-{
-    MpegMuxContext *s = ctx-&gt;priv_data;
-    int buf_index;
-    StreamInfo *stream;
-
-    stream = ctx-&gt;streams[stream_index]-&gt;priv_data;
-
-    buf_index = 0;
-    if (((s-&gt;packet_number % s-&gt;pack_header_freq) == 0)) {
-        /* pack header size */
-        if (s-&gt;is_mpeg2)
-            buf_index += 14;
-        else
-            buf_index += 12;
-
-        if (s-&gt;is_vcd) {
-            /* there is exactly one system header for each stream in a VCD MPEG,
-               One in the very first video packet and one in the very first
-               audio packet (see VCD standard p. IV-7 and IV-8).*/
-
-            if (stream-&gt;packet_number==0)
-                /* The system headers refer only to the stream they occur in,
-                   so they have a constant size.*/
-                buf_index += 15;
-
-        } else {
-            if ((s-&gt;packet_number % s-&gt;system_header_freq) == 0)
-                buf_index += s-&gt;system_header_size;
-        }
-    }
-
-    if ((s-&gt;is_vcd &amp;&amp; stream-&gt;packet_number==0)
-        || (s-&gt;is_svcd &amp;&amp; s-&gt;packet_number==0))
-        /* the first pack of each stream contains only the pack header,
-           the system header and some padding (see VCD standard p. IV-6)
-           Add the padding size, so that the actual payload becomes 0.*/
-        buf_index += s-&gt;packet_size - buf_index;
-    else {
-        /* packet header size */
-        buf_index += 6;
-        if (s-&gt;is_mpeg2) {
-            buf_index += 3;
-            if (stream-&gt;packet_number==0)
-                buf_index += 3; /* PES extension */
-            buf_index += 1;    /* obligatory stuffing byte */
-        }
-        if (pts != AV_NOPTS_VALUE) {
-            if (dts != pts)
-                buf_index += 5 + 5;
-            else
-                buf_index += 5;
-
-        } else {
-            if (!s-&gt;is_mpeg2)
-                buf_index++;
-        }
-
-        if (stream-&gt;id &lt; 0xc0) {
-            /* AC3/LPCM private data header */
-            buf_index += 4;
-            if (stream-&gt;id &gt;= 0xa0) {
-                int n;
-                buf_index += 3;
-                /* NOTE: we round the payload size to an integer number of
-                   LPCM samples */
-                n = (s-&gt;packet_size - buf_index) % stream-&gt;lpcm_align;
-                if (n)
-                    buf_index += (stream-&gt;lpcm_align - n);
-            }
-        }
-
-        if (s-&gt;is_vcd &amp;&amp; stream-&gt;id == AUDIO_ID)
-            /* The VCD standard demands that 20 zero bytes follow
-               each audio packet (see standard p. IV-8).*/
-            buf_index+=20;
-    }
-    return s-&gt;packet_size - buf_index;
-}
-#endif
-
-/* Write an MPEG padding packet header. */
-static void put_padding_packet(AVFormatContext *ctx, ByteIOContext *pb,int packet_bytes)
-{
-    MpegMuxContext *s = ctx-&gt;priv_data;
-    int i;
-
-    put_be32(pb, PADDING_STREAM);
-    put_be16(pb, packet_bytes - 6);
-    if (!s-&gt;is_mpeg2) {
-        put_byte(pb, 0x0f);
-        packet_bytes -= 7;
-    } else
-        packet_bytes -= 6;
-
-    for(i=0;i&lt;packet_bytes;i++)
-        put_byte(pb, 0xff);
-}
-
-static int get_nb_frames(AVFormatContext *ctx, StreamInfo *stream, int len){
-    int nb_frames=0;
-    PacketDesc *pkt_desc= stream-&gt;premux_packet;
-
-    while(len&gt;0){
-        if(pkt_desc-&gt;size == pkt_desc-&gt;unwritten_size)
-            nb_frames++;
-        len -= pkt_desc-&gt;unwritten_size;
-        pkt_desc= pkt_desc-&gt;next;
-    }
-
-    return nb_frames;
-}
-
-/* flush the packet on stream stream_index */
-static int flush_packet(AVFormatContext *ctx, int stream_index,
-                         int64_t pts, int64_t dts, int64_t scr, int trailer_size)
-{
-    MpegMuxContext *s = ctx-&gt;priv_data;
-    StreamInfo *stream = ctx-&gt;streams[stream_index]-&gt;priv_data;
-    uint8_t *buf_ptr;
-    int size, payload_size, startcode, id, stuffing_size, i, header_len;
-    int packet_size;
-    uint8_t buffer[128];
-    int zero_trail_bytes = 0;
-    int pad_packet_bytes = 0;
-    int pes_flags;
-    int general_pack = 0;  /*&quot;general&quot; pack without data specific to one stream?*/
-    int nb_frames;
-
-    id = stream-&gt;id;
-
-#if 0
-    printf(&quot;packet ID=%2x PTS=%0.3f\n&quot;,
-           id, pts / 90000.0);
-#endif
-
-    buf_ptr = buffer;
-
-    if ((s-&gt;packet_number % s-&gt;pack_header_freq) == 0 || s-&gt;last_scr != scr) {
-        /* output pack and systems header if needed */
-        size = put_pack_header(ctx, buf_ptr, scr);
-        buf_ptr += size;
-        s-&gt;last_scr= scr;
-
-        if (s-&gt;is_vcd) {
-            /* there is exactly one system header for each stream in a VCD MPEG,
-               One in the very first video packet and one in the very first
-               audio packet (see VCD standard p. IV-7 and IV-8).*/
-
-            if (stream-&gt;packet_number==0) {
-                size = put_system_header(ctx, buf_ptr, id);
-                buf_ptr += size;
-            }
-        } else if (s-&gt;is_dvd) {
-            if (stream-&gt;align_iframe || s-&gt;packet_number == 0){
-                int PES_bytes_to_fill = s-&gt;packet_size - size - 10;
-
-                if (pts != AV_NOPTS_VALUE) {
-                    if (dts != pts)
-                        PES_bytes_to_fill -= 5 + 5;
-                    else
-                        PES_bytes_to_fill -= 5;
-                }
-
-                if (stream-&gt;bytes_to_iframe == 0 || s-&gt;packet_number == 0) {
-                    size = put_system_header(ctx, buf_ptr, 0);
-                    buf_ptr += size;
-                    size = buf_ptr - buffer;
-                    put_buffer(&amp;ctx-&gt;pb, buffer, size);
-
-                    put_be32(&amp;ctx-&gt;pb, PRIVATE_STREAM_2);
-                    put_be16(&amp;ctx-&gt;pb, 0x03d4);         // length
-                    put_byte(&amp;ctx-&gt;pb, 0x00);           // substream ID, 00=PCI
-                    for (i = 0; i &lt; 979; i++)
-                        put_byte(&amp;ctx-&gt;pb, 0x00);
-
-                    put_be32(&amp;ctx-&gt;pb, PRIVATE_STREAM_2);
-                    put_be16(&amp;ctx-&gt;pb, 0x03fa);         // length
-                    put_byte(&amp;ctx-&gt;pb, 0x01);           // substream ID, 01=DSI
-                    for (i = 0; i &lt; 1017; i++)
-                        put_byte(&amp;ctx-&gt;pb, 0x00);
-
-                    memset(buffer, 0, 128);
-                    buf_ptr = buffer;
-                    s-&gt;packet_number++;
-                    stream-&gt;align_iframe = 0;
-                    scr += s-&gt;packet_size*90000LL / (s-&gt;mux_rate*50LL); //FIXME rounding and first few bytes of each packet
-                    size = put_pack_header(ctx, buf_ptr, scr);
-                    s-&gt;last_scr= scr;
-                    buf_ptr += size;
-                    /* GOP Start */
-                } else if (stream-&gt;bytes_to_iframe &lt; PES_bytes_to_fill) {
-                    pad_packet_bytes = PES_bytes_to_fill - stream-&gt;bytes_to_iframe;
-                }
-            }
-        } else {
-            if ((s-&gt;packet_number % s-&gt;system_header_freq) == 0) {
-                size = put_system_header(ctx, buf_ptr, 0);
-                buf_ptr += size;
-            }
-        }
-    }
-    size = buf_ptr - buffer;
-    put_buffer(&amp;ctx-&gt;pb, buffer, size);
-
-    packet_size = s-&gt;packet_size - size;
-
-    if (s-&gt;is_vcd &amp;&amp; id == AUDIO_ID)
-        /* The VCD standard demands that 20 zero bytes follow
-           each audio pack (see standard p. IV-8).*/
-        zero_trail_bytes += 20;
-
-    if ((s-&gt;is_vcd &amp;&amp; stream-&gt;packet_number==0)
-        || (s-&gt;is_svcd &amp;&amp; s-&gt;packet_number==0)) {
-        /* for VCD the first pack of each stream contains only the pack header,
-           the system header and lots of padding (see VCD standard p. IV-6).
-           In the case of an audio pack, 20 zero bytes are also added at
-           the end.*/
-        /* For SVCD we fill the very first pack to increase compatibility with
-           some DVD players. Not mandated by the standard.*/
-        if (s-&gt;is_svcd)
-            general_pack = 1;    /* the system header refers to both streams and no stream data*/
-        pad_packet_bytes = packet_size - zero_trail_bytes;
-    }
-
-    packet_size -= pad_packet_bytes + zero_trail_bytes;
-
-    if (packet_size &gt; 0) {
-
-        /* packet header size */
-        packet_size -= 6;
-
-        /* packet header */
-        if (s-&gt;is_mpeg2) {
-            header_len = 3;
-            if (stream-&gt;packet_number==0)
-                header_len += 3; /* PES extension */
-            header_len += 1; /* obligatory stuffing byte */
-        } else {
-            header_len = 0;
-        }
-        if (pts != AV_NOPTS_VALUE) {
-            if (dts != pts)
-                header_len += 5 + 5;
-            else
-                header_len += 5;
-        } else {
-            if (!s-&gt;is_mpeg2)
-                header_len++;
-        }
-
-        payload_size = packet_size - header_len;
-        if (id &lt; 0xc0) {
-            startcode = PRIVATE_STREAM_1;
-            payload_size -= 1;
-            if (id &gt;= 0x40) {
-                payload_size -= 3;
-                if (id &gt;= 0xa0)
-                    payload_size -= 3;
-            }
-        } else {
-            startcode = 0x100 + id;
-        }
-
-        stuffing_size = payload_size - av_fifo_size(&amp;stream-&gt;fifo);
-
-        // first byte doesnt fit -&gt; reset pts/dts + stuffing
-        if(payload_size &lt;= trailer_size &amp;&amp; pts != AV_NOPTS_VALUE){
-            int timestamp_len=0;
-            if(dts != pts)
-                timestamp_len += 5;
-            if(pts != AV_NOPTS_VALUE)
-                timestamp_len += s-&gt;is_mpeg2 ? 5 : 4;
-            pts=dts= AV_NOPTS_VALUE;
-            header_len -= timestamp_len;
-            if (s-&gt;is_dvd &amp;&amp; stream-&gt;align_iframe) {
-                pad_packet_bytes += timestamp_len;
-                packet_size -= timestamp_len;
-            } else {
-                payload_size += timestamp_len;
-            }
-            stuffing_size += timestamp_len;
-            if(payload_size &gt; trailer_size)
-                stuffing_size += payload_size - trailer_size;
-        }
-
-        if (pad_packet_bytes &gt; 0 &amp;&amp; pad_packet_bytes &lt;= 7) { // can't use padding, so use stuffing
-            packet_size += pad_packet_bytes;
-            payload_size += pad_packet_bytes; // undo the previous adjustment
-            if (stuffing_size &lt; 0) {
-                stuffing_size = pad_packet_bytes;
-            } else {
-                stuffing_size += pad_packet_bytes;
-            }
-            pad_packet_bytes = 0;
-        }
-
-        if (stuffing_size &lt; 0)
-            stuffing_size = 0;
-        if (stuffing_size &gt; 16) {    /*&lt;=16 for MPEG-1, &lt;=32 for MPEG-2*/
-            pad_packet_bytes += stuffing_size;
-            packet_size -= stuffing_size;
-            payload_size -= stuffing_size;
-            stuffing_size = 0;
-        }
-
-        nb_frames= get_nb_frames(ctx, stream, payload_size - stuffing_size);
-
-        put_be32(&amp;ctx-&gt;pb, startcode);
-
-        put_be16(&amp;ctx-&gt;pb, packet_size);
-
-        if (!s-&gt;is_mpeg2)
-            for(i=0;i&lt;stuffing_size;i++)
-                put_byte(&amp;ctx-&gt;pb, 0xff);
-
-        if (s-&gt;is_mpeg2) {
-            put_byte(&amp;ctx-&gt;pb, 0x80); /* mpeg2 id */
-
-            pes_flags=0;
-
-            if (pts != AV_NOPTS_VALUE) {
-                pes_flags |= 0x80;
-                if (dts != pts)
-                    pes_flags |= 0x40;
-            }
-
-            /* Both the MPEG-2 and the SVCD standards demand that the
-               P-STD_buffer_size field be included in the first packet of
-               every stream. (see SVCD standard p. 26 V.2.3.1 and V.2.3.2
-               and MPEG-2 standard 2.7.7) */
-            if (stream-&gt;packet_number == 0)
-                pes_flags |= 0x01;
-
-            put_byte(&amp;ctx-&gt;pb, pes_flags); /* flags */
-            put_byte(&amp;ctx-&gt;pb, header_len - 3 + stuffing_size);
-
-            if (pes_flags &amp; 0x80)  /*write pts*/
-                put_timestamp(&amp;ctx-&gt;pb, (pes_flags &amp; 0x40) ? 0x03 : 0x02, pts);
-            if (pes_flags &amp; 0x40)  /*write dts*/
-                put_timestamp(&amp;ctx-&gt;pb, 0x01, dts);
-
-            if (pes_flags &amp; 0x01) {  /*write pes extension*/
-                put_byte(&amp;ctx-&gt;pb, 0x10); /* flags */
-
-                /* P-STD buffer info */
-                if (id == AUDIO_ID)
-                    put_be16(&amp;ctx-&gt;pb, 0x4000 | stream-&gt;max_buffer_size/128);
-                else
-                    put_be16(&amp;ctx-&gt;pb, 0x6000 | stream-&gt;max_buffer_size/1024);
-            }
-
-        } else {
-            if (pts != AV_NOPTS_VALUE) {
-                if (dts != pts) {
-                    put_timestamp(&amp;ctx-&gt;pb, 0x03, pts);
-                    put_timestamp(&amp;ctx-&gt;pb, 0x01, dts);
-                } else {
-                    put_timestamp(&amp;ctx-&gt;pb, 0x02, pts);
-                }
-            } else {
-                put_byte(&amp;ctx-&gt;pb, 0x0f);
-            }
-        }
-
-        if (s-&gt;is_mpeg2) {
-            /* special stuffing byte that is always written
-               to prevent accidental generation of start codes. */
-            put_byte(&amp;ctx-&gt;pb, 0xff);
-
-            for(i=0;i&lt;stuffing_size;i++)
-                put_byte(&amp;ctx-&gt;pb, 0xff);
-        }
-
-        if (startcode == PRIVATE_STREAM_1) {
-            put_byte(&amp;ctx-&gt;pb, id);
-            if (id &gt;= 0xa0) {
-                /* LPCM (XXX: check nb_frames) */
-                put_byte(&amp;ctx-&gt;pb, 7);
-                put_be16(&amp;ctx-&gt;pb, 4); /* skip 3 header bytes */
-                put_byte(&amp;ctx-&gt;pb, stream-&gt;lpcm_header[0]);
-                put_byte(&amp;ctx-&gt;pb, stream-&gt;lpcm_header[1]);
-                put_byte(&amp;ctx-&gt;pb, stream-&gt;lpcm_header[2]);
-            } else if (id &gt;= 0x40) {
-                /* AC3 */
-                put_byte(&amp;ctx-&gt;pb, nb_frames);
-                put_be16(&amp;ctx-&gt;pb, trailer_size+1);
-            }
-        }
-
-        /* output data */
-        if(av_fifo_generic_read(&amp;stream-&gt;fifo, payload_size - stuffing_size, &amp;put_buffer, &amp;ctx-&gt;pb) &lt; 0)
-            return -1;
-        stream-&gt;bytes_to_iframe -= payload_size - stuffing_size;
-    }else{
-        payload_size=
-        stuffing_size= 0;
-    }
-
-    if (pad_packet_bytes &gt; 0)
-        put_padding_packet(ctx,&amp;ctx-&gt;pb, pad_packet_bytes);
-
-    for(i=0;i&lt;zero_trail_bytes;i++)
-        put_byte(&amp;ctx-&gt;pb, 0x00);
-
-    put_flush_packet(&amp;ctx-&gt;pb);
-
-    s-&gt;packet_number++;
-
-    /* only increase the stream packet number if this pack actually contains
-       something that is specific to this stream! I.e. a dedicated header
-       or some data.*/
-    if (!general_pack)
-        stream-&gt;packet_number++;
-
-    return payload_size - stuffing_size;
-}
-
-static void put_vcd_padding_sector(AVFormatContext *ctx)
-{
-    /* There are two ways to do this padding: writing a sector/pack
-       of 0 values, or writing an MPEG padding pack. Both seem to
-       work with most decoders, BUT the VCD standard only allows a 0-sector
-       (see standard p. IV-4, IV-5).
-       So a 0-sector it is...*/
-
-    MpegMuxContext *s = ctx-&gt;priv_data;
-    int i;
-
-    for(i=0;i&lt;s-&gt;packet_size;i++)
-        put_byte(&amp;ctx-&gt;pb, 0);
-
-    s-&gt;vcd_padding_bytes_written += s-&gt;packet_size;
-
-    put_flush_packet(&amp;ctx-&gt;pb);
-
-    /* increasing the packet number is correct. The SCR of the following packs
-       is calculated from the packet_number and it has to include the padding
-       sector (it represents the sector index, not the MPEG pack index)
-       (see VCD standard p. IV-6)*/
-    s-&gt;packet_number++;
-}
-
-#if 0 /* unused, remove? */
-static int64_t get_vcd_scr(AVFormatContext *ctx,int stream_index,int64_t pts)
-{
-    MpegMuxContext *s = ctx-&gt;priv_data;
-    int64_t scr;
-
-        /* Since the data delivery rate is constant, SCR is computed
-           using the formula C + i * 1200 where C is the start constant
-           and i is the pack index.
-           It is recommended that SCR 0 is at the beginning of the VCD front
-           margin (a sequence of empty Form 2 sectors on the CD).
-           It is recommended that the front margin is 30 sectors long, so
-           we use C = 30*1200 = 36000
-           (Note that even if the front margin is not 30 sectors the file
-           will still be correct according to the standard. It just won't have
-           the &quot;recommended&quot; value).*/
-        scr = 36000 + s-&gt;packet_number * 1200;
-
-    return scr;
-}
-#endif
-
-static int remove_decoded_packets(AVFormatContext *ctx, int64_t scr){
-//    MpegMuxContext *s = ctx-&gt;priv_data;
-    int i;
-
-    for(i=0; i&lt;ctx-&gt;nb_streams; i++){
-        AVStream *st = ctx-&gt;streams[i];
-        StreamInfo *stream = st-&gt;priv_data;
-        PacketDesc *pkt_desc= stream-&gt;predecode_packet;
-
-        while(pkt_desc &amp;&amp; scr &gt; pkt_desc-&gt;dts){ //FIXME &gt; vs &gt;=
-            if(stream-&gt;buffer_index &lt; pkt_desc-&gt;size ||
-               stream-&gt;predecode_packet == stream-&gt;premux_packet){
-                av_log(ctx, AV_LOG_ERROR, &quot;buffer underflow\n&quot;);
-                break;
-            }
-            stream-&gt;buffer_index -= pkt_desc-&gt;size;
-
-            stream-&gt;predecode_packet= pkt_desc-&gt;next;
-            av_freep(&amp;pkt_desc);
-        }
-    }
-
-    return 0;
-}
-
-static int output_packet(AVFormatContext *ctx, int flush){
-    MpegMuxContext *s = ctx-&gt;priv_data;
-    AVStream *st;
-    StreamInfo *stream;
-    int i, avail_space, es_size, trailer_size;
-    int best_i= -1;
-    int best_score= INT_MIN;
-    int ignore_constraints=0;
-    int64_t scr= s-&gt;last_scr;
-    PacketDesc *timestamp_packet;
-    const int64_t max_delay= av_rescale(ctx-&gt;max_delay, 90000, AV_TIME_BASE);
-
-retry:
-    for(i=0; i&lt;ctx-&gt;nb_streams; i++){
-        AVStream *st = ctx-&gt;streams[i];
-        StreamInfo *stream = st-&gt;priv_data;
-        const int avail_data=  av_fifo_size(&amp;stream-&gt;fifo);
-        const int space= stream-&gt;max_buffer_size - stream-&gt;buffer_index;
-        int rel_space= 1024*space / stream-&gt;max_buffer_size;
-        PacketDesc *next_pkt= stream-&gt;premux_packet;
-
-        /* for subtitle, a single PES packet must be generated,
-           so we flush after every single subtitle packet */
-        if(s-&gt;packet_size &gt; avail_data &amp;&amp; !flush
-           &amp;&amp; st-&gt;codec-&gt;codec_type != CODEC_TYPE_SUBTITLE)
-            return 0;
-        if(avail_data==0)
-            continue;
-        assert(avail_data&gt;0);
-
-        if(space &lt; s-&gt;packet_size &amp;&amp; !ignore_constraints)
-            continue;
-
-        if(next_pkt &amp;&amp; next_pkt-&gt;dts - scr &gt; max_delay)
-            continue;
-
-        if(rel_space &gt; best_score){
-            best_score= rel_space;
-            best_i = i;
-            avail_space= space;
-        }
-    }
-
-    if(best_i &lt; 0){
-        int64_t best_dts= INT64_MAX;
-
-        for(i=0; i&lt;ctx-&gt;nb_streams; i++){
-            AVStream *st = ctx-&gt;streams[i];
-            StreamInfo *stream = st-&gt;priv_data;
-            PacketDesc *pkt_desc= stream-&gt;predecode_packet;
-            if(pkt_desc &amp;&amp; pkt_desc-&gt;dts &lt; best_dts)
-                best_dts= pkt_desc-&gt;dts;
-        }
-
-#if 0
-        av_log(ctx, AV_LOG_DEBUG, &quot;bumping scr, scr:%f, dts:%f\n&quot;,
-               scr/90000.0, best_dts/90000.0);
-#endif
-        if(best_dts == INT64_MAX)
-            return 0;
-
-        if(scr &gt;= best_dts+1 &amp;&amp; !ignore_constraints){
-            av_log(ctx, AV_LOG_ERROR, &quot;packet too large, ignoring buffer limits to mux it\n&quot;);
-            ignore_constraints= 1;
-        }
-        scr= FFMAX(best_dts+1, scr);
-        if(remove_decoded_packets(ctx, scr) &lt; 0)
-            return -1;
-        goto retry;
-    }
-
-    assert(best_i &gt;= 0);
-
-    st = ctx-&gt;streams[best_i];
-    stream = st-&gt;priv_data;
-
-    assert(av_fifo_size(&amp;stream-&gt;fifo) &gt; 0);
-
-    assert(avail_space &gt;= s-&gt;packet_size || ignore_constraints);
-
-    timestamp_packet= stream-&gt;premux_packet;
-    if(timestamp_packet-&gt;unwritten_size == timestamp_packet-&gt;size){
-        trailer_size= 0;
-    }else{
-        trailer_size= timestamp_packet-&gt;unwritten_size;
-        timestamp_packet= timestamp_packet-&gt;next;
-    }
-
-    if(timestamp_packet){
-//av_log(ctx, AV_LOG_DEBUG, &quot;dts:%f pts:%f scr:%f stream:%d\n&quot;, timestamp_packet-&gt;dts/90000.0, timestamp_packet-&gt;pts/90000.0, scr/90000.0, best_i);
-        es_size= flush_packet(ctx, best_i, timestamp_packet-&gt;pts, timestamp_packet-&gt;dts, scr, trailer_size);
-    }else{
-        assert(av_fifo_size(&amp;stream-&gt;fifo) == trailer_size);
-        es_size= flush_packet(ctx, best_i, AV_NOPTS_VALUE, AV_NOPTS_VALUE, scr, trailer_size);
-    }
-
-    if (s-&gt;is_vcd) {
-        /* Write one or more padding sectors, if necessary, to reach
-           the constant overall bitrate.*/
-        int vcd_pad_bytes;
-
-        while((vcd_pad_bytes = get_vcd_padding_size(ctx,stream-&gt;premux_packet-&gt;pts) ) &gt;= s-&gt;packet_size){ //FIXME pts cannot be correct here
-            put_vcd_padding_sector(ctx);
-            s-&gt;last_scr += s-&gt;packet_size*90000LL / (s-&gt;mux_rate*50LL); //FIXME rounding and first few bytes of each packet
-        }
-    }
-
-    stream-&gt;buffer_index += es_size;
-    s-&gt;last_scr += s-&gt;packet_size*90000LL / (s-&gt;mux_rate*50LL); //FIXME rounding and first few bytes of each packet
-
-    while(stream-&gt;premux_packet &amp;&amp; stream-&gt;premux_packet-&gt;unwritten_size &lt;= es_size){
-        es_size -= stream-&gt;premux_packet-&gt;unwritten_size;
-        stream-&gt;premux_packet= stream-&gt;premux_packet-&gt;next;
-    }
-    if(es_size)
-        stream-&gt;premux_packet-&gt;unwritten_size -= es_size;
-
-    if(remove_decoded_packets(ctx, s-&gt;last_scr) &lt; 0)
-        return -1;
-
-    return 1;
-}
-
-static int mpeg_mux_write_packet(AVFormatContext *ctx, AVPacket *pkt)
-{
-    MpegMuxContext *s = ctx-&gt;priv_data;
-    int stream_index= pkt-&gt;stream_index;
-    int size= pkt-&gt;size;
-    uint8_t *buf= pkt-&gt;data;
-    AVStream *st = ctx-&gt;streams[stream_index];
-    StreamInfo *stream = st-&gt;priv_data;
-    int64_t pts, dts;
-    PacketDesc *pkt_desc;
-    const int preload= av_rescale(ctx-&gt;preload, 90000, AV_TIME_BASE);
-    const int is_iframe = st-&gt;codec-&gt;codec_type == CODEC_TYPE_VIDEO &amp;&amp; (pkt-&gt;flags &amp; PKT_FLAG_KEY);
-
-    pts= pkt-&gt;pts;
-    dts= pkt-&gt;dts;
-
-    if(pts != AV_NOPTS_VALUE) pts += preload;
-    if(dts != AV_NOPTS_VALUE) dts += preload;
-
-//av_log(ctx, AV_LOG_DEBUG, &quot;dts:%f pts:%f flags:%d stream:%d nopts:%d\n&quot;, dts/90000.0, pts/90000.0, pkt-&gt;flags, pkt-&gt;stream_index, pts != AV_NOPTS_VALUE);
-    if (!stream-&gt;premux_packet)
-        stream-&gt;next_packet = &amp;stream-&gt;premux_packet;
-    *stream-&gt;next_packet=
-    pkt_desc= av_mallocz(sizeof(PacketDesc));
-    pkt_desc-&gt;pts= pts;
-    pkt_desc-&gt;dts= dts;
-    pkt_desc-&gt;unwritten_size=
-    pkt_desc-&gt;size= size;
-    if(!stream-&gt;predecode_packet)
-        stream-&gt;predecode_packet= pkt_desc;
-    stream-&gt;next_packet= &amp;pkt_desc-&gt;next;
-
-    av_fifo_realloc(&amp;stream-&gt;fifo, av_fifo_size(&amp;stream-&gt;fifo) + size + 1);
-
-    if (s-&gt;is_dvd){
-        if (is_iframe &amp;&amp; (s-&gt;packet_number == 0 || (pts - stream-&gt;vobu_start_pts &gt;= 36000))) { // min VOBU length 0.4 seconds (mpucoder)
-            stream-&gt;bytes_to_iframe = av_fifo_size(&amp;stream-&gt;fifo);
-            stream-&gt;align_iframe = 1;
-            stream-&gt;vobu_start_pts = pts;
-        } else {
-            stream-&gt;align_iframe = 0;
-        }
-    }
-
-    av_fifo_write(&amp;stream-&gt;fifo, buf, size);
-
-    for(;;){
-        int ret= output_packet(ctx, 0);
-        if(ret&lt;=0)
-            return ret;
-    }
-}
-
-static int mpeg_mux_end(AVFormatContext *ctx)
-{
-//    MpegMuxContext *s = ctx-&gt;priv_data;
-    StreamInfo *stream;
-    int i;
-
-    for(;;){
-        int ret= output_packet(ctx, 1);
-        if(ret&lt;0)
-            return ret;
-        else if(ret==0)
-            break;
-    }
-
-    /* End header according to MPEG1 systems standard. We do not write
-       it as it is usually not needed by decoders and because it
-       complicates MPEG stream concatenation. */
-    //put_be32(&amp;ctx-&gt;pb, ISO_11172_END_CODE);
-    //put_flush_packet(&amp;ctx-&gt;pb);
-
-    for(i=0;i&lt;ctx-&gt;nb_streams;i++) {
-        stream = ctx-&gt;streams[i]-&gt;priv_data;
-
-        assert(av_fifo_size(&amp;stream-&gt;fifo) == 0);
-        av_fifo_free(&amp;stream-&gt;fifo);
-    }
-    return 0;
-}
-#endif //CONFIG_MUXERS
-
 /*********************************************/
 /* demux code */
 
@@ -1260,8 +35,6 @@
 static int cdxa_probe(AVProbeData *p)
 {
     /* check file header */
-    if (p-&gt;buf_size &lt;= 32)
-        return 0;
     if (p-&gt;buf[0] == 'R' &amp;&amp; p-&gt;buf[1] == 'I' &amp;&amp;
         p-&gt;buf[2] == 'F' &amp;&amp; p-&gt;buf[3] == 'F' &amp;&amp;
         p-&gt;buf[8] == 'C' &amp;&amp; p-&gt;buf[9] == 'D' &amp;&amp;
@@ -1445,6 +218,7 @@
 {
     MpegDemuxContext *m = s-&gt;priv_data;
     int len, size, startcode, c, flags, header_len;
+    int pes_ext, ext2_len, id_ext, skip;
     int64_t pts, dts;
     int64_t last_sync= url_ftell(&amp;s-&gt;pb);
 
@@ -1478,7 +252,7 @@
     /* find matching stream */
     if (!((startcode &gt;= 0x1c0 &amp;&amp; startcode &lt;= 0x1df) ||
           (startcode &gt;= 0x1e0 &amp;&amp; startcode &lt;= 0x1ef) ||
-          (startcode == 0x1bd)))
+          (startcode == 0x1bd) || (startcode == 0x1fd)))
         goto redo;
     if (ppos) {
         *ppos = url_ftell(&amp;s-&gt;pb) - 4;
@@ -1531,6 +305,29 @@
                 header_len -= 5;
             }
         }
+        if (flags &amp; 0x01) { /* PES extension */
+            pes_ext = get_byte(&amp;s-&gt;pb);
+            header_len--;
+            if (pes_ext &amp; 0x40) { /* pack header - should be zero in PS */
+                goto error_redo;
+            }
+            /* Skip PES private data, program packet sequence counter and P-STD buffer */
+            skip = (pes_ext &gt;&gt; 4) &amp; 0xb;
+            skip += skip &amp; 0x9;
+            url_fskip(&amp;s-&gt;pb, skip);
+            header_len -= skip;
+
+            if (pes_ext &amp; 0x01) { /* PES extension 2 */
+                ext2_len = get_byte(&amp;s-&gt;pb);
+                header_len--;
+                if ((ext2_len &amp; 0x7f) &gt; 0) {
+                    id_ext = get_byte(&amp;s-&gt;pb);
+                    if ((id_ext &amp; 0x80) == 0)
+                        startcode = ((startcode &amp; 0xff) &lt;&lt; 8) | id_ext;
+                    header_len--;
+                }
+            }
+        }
         if(header_len &lt; 0)
             goto error_redo;
         url_fskip(&amp;s-&gt;pb, header_len);
@@ -1541,12 +338,17 @@
     if (startcode == PRIVATE_STREAM_1 &amp;&amp; !m-&gt;psm_es_type[startcode &amp; 0xff]) {
         startcode = get_byte(&amp;s-&gt;pb);
         len--;
-        if (startcode &gt;= 0x80 &amp;&amp; startcode &lt;= 0xbf) {
+        if (startcode &gt;= 0x80 &amp;&amp; startcode &lt;= 0xcf) {
             /* audio: skip header */
             get_byte(&amp;s-&gt;pb);
             get_byte(&amp;s-&gt;pb);
             get_byte(&amp;s-&gt;pb);
             len -= 3;
+            if (startcode &gt;= 0xb0 &amp;&amp; startcode &lt;= 0xbf) {
+                /* MLP/TrueHD audio has a 4-byte header */
+                get_byte(&amp;s-&gt;pb);
+                len--;
+            }
         }
     }
     if(len&lt;0)
@@ -1629,15 +431,27 @@
     } else if (startcode &gt;= 0x80 &amp;&amp; startcode &lt;= 0x87) {
         type = CODEC_TYPE_AUDIO;
         codec_id = CODEC_ID_AC3;
-    } else if (startcode &gt;= 0x88 &amp;&amp; startcode &lt;= 0x9f) {
+    } else if ((startcode &gt;= 0x88 &amp;&amp; startcode &lt;= 0x8f)
+               ||( startcode &gt;= 0x98 &amp;&amp; startcode &lt;= 0x9f)) {
+        /* 0x90 - 0x97 is reserved for SDDS in DVD specs */
         type = CODEC_TYPE_AUDIO;
         codec_id = CODEC_ID_DTS;
-    } else if (startcode &gt;= 0xa0 &amp;&amp; startcode &lt;= 0xbf) {
+    } else if (startcode &gt;= 0xa0 &amp;&amp; startcode &lt;= 0xaf) {
         type = CODEC_TYPE_AUDIO;
         codec_id = CODEC_ID_PCM_S16BE;
+    } else if (startcode &gt;= 0xb0 &amp;&amp; startcode &lt;= 0xbf) {
+        type = CODEC_TYPE_AUDIO;
+        codec_id = CODEC_ID_MLP;
+    } else if (startcode &gt;= 0xc0 &amp;&amp; startcode &lt;= 0xcf) {
+        /* Used for both AC-3 and E-AC-3 in EVOB files */
+        type = CODEC_TYPE_AUDIO;
+        codec_id = CODEC_ID_AC3;
     } else if (startcode &gt;= 0x20 &amp;&amp; startcode &lt;= 0x3f) {
         type = CODEC_TYPE_SUBTITLE;
         codec_id = CODEC_ID_DVD_SUBTITLE;
+    } else if (startcode &gt;= 0xfd55 &amp;&amp; startcode &lt;= 0xfd5f) {
+        type = CODEC_TYPE_VIDEO;
+        codec_id = CODEC_ID_VC1;
     } else {
     skip:
         /* skip packet */
@@ -1651,11 +465,11 @@
     st-&gt;codec-&gt;codec_type = type;
     st-&gt;codec-&gt;codec_id = codec_id;
     if (codec_id != CODEC_ID_PCM_S16BE)
-        st-&gt;need_parsing = 1;
+        st-&gt;need_parsing = AVSTREAM_PARSE_FULL;
  found:
     if(st-&gt;discard &gt;= AVDISCARD_ALL)
         goto skip;
-    if (startcode &gt;= 0xa0 &amp;&amp; startcode &lt;= 0xbf) {
+    if (startcode &gt;= 0xa0 &amp;&amp; startcode &lt;= 0xaf) {
         int b1, freq;
 
         /* for LPCM, we just skip the header and consider it is raw
@@ -1721,82 +535,6 @@
     return dts;
 }
 
-#ifdef CONFIG_MPEG1SYSTEM_MUXER
-AVOutputFormat mpeg1system_muxer = {
-    &quot;mpeg&quot;,
-    &quot;MPEG1 System format&quot;,
-    &quot;video/mpeg&quot;,
-    &quot;mpg,mpeg&quot;,
-    sizeof(MpegMuxContext),
-    CODEC_ID_MP2,
-    CODEC_ID_MPEG1VIDEO,
-    mpeg_mux_init,
-    mpeg_mux_write_packet,
-    mpeg_mux_end,
-};
-#endif
-#ifdef CONFIG_MPEG1VCD_MUXER
-AVOutputFormat mpeg1vcd_muxer = {
-    &quot;vcd&quot;,
-    &quot;MPEG1 System format (VCD)&quot;,
-    &quot;video/mpeg&quot;,
-    NULL,
-    sizeof(MpegMuxContext),
-    CODEC_ID_MP2,
-    CODEC_ID_MPEG1VIDEO,
-    mpeg_mux_init,
-    mpeg_mux_write_packet,
-    mpeg_mux_end,
-};
-#endif
-#ifdef CONFIG_MPEG2VOB_MUXER
-AVOutputFormat mpeg2vob_muxer = {
-    &quot;vob&quot;,
-    &quot;MPEG2 PS format (VOB)&quot;,
-    &quot;video/mpeg&quot;,
-    &quot;vob&quot;,
-    sizeof(MpegMuxContext),
-    CODEC_ID_MP2,
-    CODEC_ID_MPEG2VIDEO,
-    mpeg_mux_init,
-    mpeg_mux_write_packet,
-    mpeg_mux_end,
-};
-#endif
-
-/* Same as mpeg2vob_mux except that the pack size is 2324 */
-#ifdef CONFIG_MPEG2SVCD_MUXER
-AVOutputFormat mpeg2svcd_muxer = {
-    &quot;svcd&quot;,
-    &quot;MPEG2 PS format (VOB)&quot;,
-    &quot;video/mpeg&quot;,
-    &quot;vob&quot;,
-    sizeof(MpegMuxContext),
-    CODEC_ID_MP2,
-    CODEC_ID_MPEG2VIDEO,
-    mpeg_mux_init,
-    mpeg_mux_write_packet,
-    mpeg_mux_end,
-};
-#endif
-
-/*  Same as mpeg2vob_mux except the 'is_dvd' flag is set to produce NAV pkts */
-#ifdef CONFIG_MPEG2DVD_MUXER
-AVOutputFormat mpeg2dvd_muxer = {
-    &quot;dvd&quot;,
-    &quot;MPEG2 PS format (DVD VOB)&quot;,
-    &quot;video/mpeg&quot;,
-    &quot;dvd&quot;,
-    sizeof(MpegMuxContext),
-    CODEC_ID_MP2,
-    CODEC_ID_MPEG2VIDEO,
-    mpeg_mux_init,
-    mpeg_mux_write_packet,
-    mpeg_mux_end,
-};
-#endif
-
-#ifdef CONFIG_MPEGPS_DEMUXER
 AVInputFormat mpegps_demuxer = {
     &quot;mpeg&quot;,
     &quot;MPEG PS format&quot;,
@@ -1809,4 +547,3 @@
     mpegps_read_dts,
     .flags = AVFMT_SHOW_IDS,
 };
-#endif

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/mpegts.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/mpegts.h	2007-07-16 16:39:52 UTC (rev 3382)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/mpegts.h	2007-07-16 17:44:22 UTC (rev 3383)
@@ -19,6 +19,11 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
+#ifndef AVFORMAT_MPEGTS_H
+#define AVFORMAT_MPEGTS_H
+
+#include &quot;avformat.h&quot;
+
 #define TS_FEC_PACKET_SIZE 204
 #define TS_DVHS_PACKET_SIZE 192
 #define TS_PACKET_SIZE 188
@@ -46,18 +51,18 @@
 #define STREAM_TYPE_AUDIO_AAC       0x0f
 #define STREAM_TYPE_VIDEO_MPEG4     0x10
 #define STREAM_TYPE_VIDEO_H264      0x1b
+#define STREAM_TYPE_VIDEO_VC1       0xea
 
 #define STREAM_TYPE_AUDIO_AC3       0x81
 #define STREAM_TYPE_AUDIO_DTS       0x8a
 
 #define STREAM_TYPE_SUBTITLE_DVB    0x100
 
-unsigned int mpegts_crc32(const uint8_t *data, int len);
-extern AVOutputFormat mpegts_muxer;
-
 typedef struct MpegTSContext MpegTSContext;
 
 MpegTSContext *mpegts_parse_open(AVFormatContext *s);
 int mpegts_parse_packet(MpegTSContext *ts, AVPacket *pkt,
                         const uint8_t *buf, int len);
 void mpegts_parse_close(MpegTSContext *ts);
+
+#endif /* AVFORMAT_MPEGTS_H */

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/mpegtsenc.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/mpegtsenc.c	2007-07-16 16:39:52 UTC (rev 3382)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/mpegtsenc.c	2007-07-16 17:44:22 UTC (rev 3383)
@@ -143,6 +143,7 @@
     int cc;
     int payload_index;
     int64_t payload_pts;
+    int64_t payload_dts;
     uint8_t payload[DEFAULT_PES_PAYLOAD_SIZE];
 } MpegTSWriteStream;
 
@@ -396,6 +397,7 @@
         ts_st-&gt;service = service;
         ts_st-&gt;pid = DEFAULT_START_PID + i;
         ts_st-&gt;payload_pts = AV_NOPTS_VALUE;
+        ts_st-&gt;payload_dts = AV_NOPTS_VALUE;
         /* update PCR pid by using the first video stream */
         if (st-&gt;codec-&gt;codec_type == CODEC_TYPE_VIDEO &amp;&amp;
             service-&gt;pcr_pid == 0x1fff)
@@ -460,15 +462,29 @@
     }
 }
 
+static void write_pts(uint8_t *q, int fourbits, int64_t pts)
+{
+    int val;
+
+    val = fourbits &lt;&lt; 4 | (((pts &gt;&gt; 30) &amp; 0x07) &lt;&lt; 1) | 1;
+    *q++ = val;
+    val = (((pts &gt;&gt; 15) &amp; 0x7fff) &lt;&lt; 1) | 1;
+    *q++ = val &gt;&gt; 8;
+    *q++ = val;
+    val = (((pts) &amp; 0x7fff) &lt;&lt; 1) | 1;
+    *q++ = val &gt;&gt; 8;
+    *q++ = val;
+}
+
 /* NOTE: pes_data contains all the PES packet */
 static void mpegts_write_pes(AVFormatContext *s, AVStream *st,
                              const uint8_t *payload, int payload_size,
-                             int64_t pts)
+                             int64_t pts, int64_t dts)
 {
     MpegTSWriteStream *ts_st = st-&gt;priv_data;
     uint8_t buf[TS_PACKET_SIZE];
     uint8_t *q;
-    int val, is_start, len, header_len, write_pcr, private_code;
+    int val, is_start, len, header_len, write_pcr, private_code, flags;
     int afc_len, stuffing_len;
     int64_t pcr = -1; /* avoid warning */
 
@@ -527,13 +543,19 @@
                     private_code = 0x20;
                 }
             }
-            if (pts != AV_NOPTS_VALUE)
-                header_len = 8;
-            else
-                header_len = 3;
+            header_len = 0;
+            flags = 0;
+            if (pts != AV_NOPTS_VALUE) {
+                header_len += 5;
+                flags |= 0x80;
+            }
+            if (dts != AV_NOPTS_VALUE) {
+                header_len += 5;
+                flags |= 0x40;
+            }
+            len = payload_size + header_len + 3;
             if (private_code != 0)
-                header_len++;
-            len = payload_size + header_len;
+                len++;
             *q++ = len &gt;&gt; 8;
             *q++ = len;
             val = 0x80;
@@ -541,22 +563,16 @@
             if (st-&gt;codec-&gt;codec_type == CODEC_TYPE_SUBTITLE)
                 val |= 0x04;
             *q++ = val;
+            *q++ = flags;
+            *q++ = header_len;
             if (pts != AV_NOPTS_VALUE) {
-                *q++ = 0x80; /* PTS only */
-                *q++ = 0x05; /* header len */
-                val = (0x02 &lt;&lt; 4) |
-                    (((pts &gt;&gt; 30) &amp; 0x07) &lt;&lt; 1) | 1;
-                *q++ = val;
-                val = (((pts &gt;&gt; 15) &amp; 0x7fff) &lt;&lt; 1) | 1;
-                *q++ = val &gt;&gt; 8;
-                *q++ = val;
-                val = (((pts) &amp; 0x7fff) &lt;&lt; 1) | 1;
-                *q++ = val &gt;&gt; 8;
-                *q++ = val;
-            } else {
-                *q++ = 0x00;
-                *q++ = 0x00;
+                write_pts(q, flags &gt;&gt; 6, pts);
+                q += 5;
             }
+            if (dts != AV_NOPTS_VALUE) {
+                write_pts(q, 1, dts);
+                q += 5;
+            }
             if (private_code != 0)
                 *q++ = private_code;
             is_start = 0;
@@ -607,7 +623,7 @@
 
     if (st-&gt;codec-&gt;codec_type == CODEC_TYPE_SUBTITLE) {
         /* for subtitle, a single PES packet must be generated */
-        mpegts_write_pes(s, st, buf, size, pkt-&gt;pts);
+        mpegts_write_pes(s, st, buf, size, pkt-&gt;pts, AV_NOPTS_VALUE);
         return 0;
     }
 
@@ -622,10 +638,13 @@
         ts_st-&gt;payload_index += len;
         if (ts_st-&gt;payload_pts == AV_NOPTS_VALUE)
             ts_st-&gt;payload_pts = pkt-&gt;pts;
+        if (ts_st-&gt;payload_dts == AV_NOPTS_VALUE)
+            ts_st-&gt;payload_dts = pkt-&gt;dts;
         if (ts_st-&gt;payload_index &gt;= max_payload_size) {
             mpegts_write_pes(s, st, ts_st-&gt;payload, ts_st-&gt;payload_index,
-                             ts_st-&gt;payload_pts);
+                             ts_st-&gt;payload_pts, ts_st-&gt;payload_dts);
             ts_st-&gt;payload_pts = AV_NOPTS_VALUE;
+            ts_st-&gt;payload_dts = AV_NOPTS_VALUE;
             ts_st-&gt;payload_index = 0;
         }
     }
@@ -646,7 +665,7 @@
         ts_st = st-&gt;priv_data;
         if (ts_st-&gt;payload_index &gt; 0) {
             mpegts_write_pes(s, st, ts_st-&gt;payload, ts_st-&gt;payload_index,
-                             ts_st-&gt;payload_pts);
+                             ts_st-&gt;payload_pts, ts_st-&gt;payload_dts);
         }
     }
     put_flush_packet(&amp;s-&gt;pb);

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/qtpalette.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/qtpalette.h	2007-07-16 16:39:52 UTC (rev 3382)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/qtpalette.h	2007-07-16 17:44:22 UTC (rev 3383)
@@ -2,6 +2,22 @@
  * Default Palettes for Quicktime Files
  *  Automatically generated from a utility derived from XAnim:
  *  <A HREF="http://xanim.va.pubnix.com/home.html">http://xanim.va.pubnix.com/home.html</A>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
 #ifndef QTPALETTE_H

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/riff.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/riff.c	2007-07-16 16:39:52 UTC (rev 3382)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/riff.c	2007-07-16 17:44:22 UTC (rev 3383)
@@ -97,12 +97,16 @@
     { CODEC_ID_MPEG1VIDEO, 0x10000001 },
     { CODEC_ID_MPEG2VIDEO, 0x10000002 },
     { CODEC_ID_MPEG2VIDEO, MKTAG('D', 'V', 'R', ' ') },
+    { CODEC_ID_MPEG2VIDEO, MKTAG('M', 'M', 'E', 'S') },
     { CODEC_ID_MJPEG, MKTAG('M', 'J', 'P', 'G') },
     { CODEC_ID_MJPEG, MKTAG('L', 'J', 'P', 'G') },
     { CODEC_ID_LJPEG, MKTAG('L', 'J', 'P', 'G') },
     { CODEC_ID_MJPEG, MKTAG('J', 'P', 'G', 'L') }, /* Pegasus lossless JPEG */
+    { CODEC_ID_JPEGLS,MKTAG('M', 'J', 'L', 'S') }, /* JPEG-LS custom FOURCC for avi - encoder */
     { CODEC_ID_MJPEG, MKTAG('M', 'J', 'L', 'S') }, /* JPEG-LS custom FOURCC for avi - decoder */
-    { CODEC_ID_JPEGLS, MKTAG('M', 'J', 'L', 'S') }, /* JPEG-LS custom FOURCC for avi - encoder */
+    { CODEC_ID_MJPEG, MKTAG('j', 'p', 'e', 'g') },
+    { CODEC_ID_MJPEG, MKTAG('I', 'J', 'P', 'G') },
+    { CODEC_ID_MJPEG, MKTAG('A', 'V', 'R', 'n') },
     { CODEC_ID_HUFFYUV, MKTAG('H', 'F', 'Y', 'U') },
     { CODEC_ID_FFVHUFF, MKTAG('F', 'F', 'V', 'H') },
     { CODEC_ID_CYUV, MKTAG('C', 'Y', 'U', 'V') },
@@ -153,6 +157,7 @@
     { CODEC_ID_QPEG, MKTAG('Q', '1', '.', '1') },
     { CODEC_ID_WMV3, MKTAG('W', 'M', 'V', '3') },
     { CODEC_ID_VC1, MKTAG('W', 'V', 'C', '1') },
+    { CODEC_ID_VC1, MKTAG('W', 'M', 'V', 'A') },
     { CODEC_ID_LOCO, MKTAG('L', 'O', 'C', 'O') },
     { CODEC_ID_WNV1, MKTAG('W', 'N', 'V', '1') },
     { CODEC_ID_AASC, MKTAG('A', 'A', 'S', 'C') },
@@ -166,6 +171,7 @@
     { CODEC_ID_CAVS, MKTAG('C', 'A', 'V', 'S') },
     { CODEC_ID_JPEG2000, MKTAG('M', 'J', '2', 'C') },
     { CODEC_ID_VMNC, MKTAG('V', 'M', 'n', 'c') },
+    { CODEC_ID_TARGA, MKTAG('t', 'g', 'a', ' ') },
     { CODEC_ID_NONE, 0 },
 };
 
@@ -198,6 +204,8 @@
     { CODEC_ID_TRUESPEECH, 0x22 },
     { CODEC_ID_FLAC, 0xF1AC },
     { CODEC_ID_IMC, 0x401 },
+    { CODEC_ID_GSM_MS, 0x31 },
+    { CODEC_ID_ATRAC3, 0x270 },
 
     /* FIXME: All of the IDs below are not 16 bit and thus illegal. */
     // for NuppelVideo (nuv.c)
@@ -207,69 +215,6 @@
     { 0, 0 },
 };
 
-unsigned int codec_get_tag(const AVCodecTag *tags, int id)
-{
-    while (tags-&gt;id != CODEC_ID_NONE) {
-        if (tags-&gt;id == id)
-            return tags-&gt;tag;
-        tags++;
-    }
-    return 0;
-}
-
-enum CodecID codec_get_id(const AVCodecTag *tags, unsigned int tag)
-{
-    while (tags-&gt;id != CODEC_ID_NONE) {
-        if(   toupper((tag &gt;&gt; 0)&amp;0xFF) == toupper((tags-&gt;tag &gt;&gt; 0)&amp;0xFF)
-           &amp;&amp; toupper((tag &gt;&gt; 8)&amp;0xFF) == toupper((tags-&gt;tag &gt;&gt; 8)&amp;0xFF)
-           &amp;&amp; toupper((tag &gt;&gt;16)&amp;0xFF) == toupper((tags-&gt;tag &gt;&gt;16)&amp;0xFF)
-           &amp;&amp; toupper((tag &gt;&gt;24)&amp;0xFF) == toupper((tags-&gt;tag &gt;&gt;24)&amp;0xFF))
-            return tags-&gt;id;
-        tags++;
-    }
-    return CODEC_ID_NONE;
-}
-
-unsigned int av_codec_get_tag(const AVCodecTag *tags[4], enum CodecID id)
-{
-    int i;
-    for(i=0; i&lt;4 &amp;&amp; tags[i]; i++){
-        int tag= codec_get_tag(tags[i], id);
-        if(tag) return tag;
-    }
-    return 0;
-}
-
-enum CodecID av_codec_get_id(const AVCodecTag *tags[4], unsigned int tag)
-{
-    int i;
-    for(i=0; i&lt;4 &amp;&amp; tags[i]; i++){
-        enum CodecID id= codec_get_id(tags[i], tag);
-        if(id!=CODEC_ID_NONE) return id;
-    }
-    return CODEC_ID_NONE;
-}
-
-unsigned int codec_get_bmp_tag(int id)
-{
-    return codec_get_tag(codec_bmp_tags, id);
-}
-
-unsigned int codec_get_wav_tag(int id)
-{
-    return codec_get_tag(codec_wav_tags, id);
-}
-
-enum CodecID codec_get_bmp_id(unsigned int tag)
-{
-    return codec_get_id(codec_bmp_tags, tag);
-}
-
-enum CodecID codec_get_wav_id(unsigned int tag)
-{
-    return codec_get_id(codec_wav_tags, tag);
-}
-
 #ifdef CONFIG_MUXERS
 offset_t start_tag(ByteIOContext *pb, const char *tag)
 {
@@ -296,8 +241,6 @@
     int hdrsize = 18;
 
     if(!enc-&gt;codec_tag || enc-&gt;codec_tag &gt; 0xffff)
-       enc-&gt;codec_tag = codec_get_tag(codec_wav_tags, enc-&gt;codec_id);
-    if(!enc-&gt;codec_tag || enc-&gt;codec_tag &gt; 0xffff)
         return -1;
 
     put_le16(pb, enc-&gt;codec_tag);
@@ -307,7 +250,7 @@
         enc-&gt;codec_id == CODEC_ID_PCM_ALAW ||
         enc-&gt;codec_id == CODEC_ID_PCM_MULAW) {
         bps = 8;
-    } else if (enc-&gt;codec_id == CODEC_ID_MP2 || enc-&gt;codec_id == CODEC_ID_MP3) {
+    } else if (enc-&gt;codec_id == CODEC_ID_MP2 || enc-&gt;codec_id == CODEC_ID_MP3 || enc-&gt;codec_id == CODEC_ID_GSM_MS) {
         bps = 0;
     } else if (enc-&gt;codec_id == CODEC_ID_ADPCM_IMA_WAV || enc-&gt;codec_id == CODEC_ID_ADPCM_MS || enc-&gt;codec_id == CODEC_ID_ADPCM_G726 || enc-&gt;codec_id == CODEC_ID_ADPCM_YAMAHA) { //
         bps = 4;
@@ -318,9 +261,12 @@
     } else {
         bps = 16;
     }
+    if(bps != enc-&gt;bits_per_sample &amp;&amp; enc-&gt;bits_per_sample){
+        av_log(enc, AV_LOG_WARNING, &quot;requested bits_per_sample (%d) and actually stored (%d) differ\n&quot;, enc-&gt;bits_per_sample, bps);
+    }
 
-    if (enc-&gt;codec_id == CODEC_ID_MP2 || enc-&gt;codec_id == CODEC_ID_MP3) {
-        blkalign = enc-&gt;frame_size; //this is wrong, but seems many demuxers dont work if this is set correctly
+    if (enc-&gt;codec_id == CODEC_ID_MP2 || enc-&gt;codec_id == CODEC_ID_MP3 || enc-&gt;codec_id == CODEC_ID_GSM_MS) {
+        blkalign = enc-&gt;frame_size; //this is wrong, but it seems many demuxers do not work if this is set correctly
         //blkalign = 144 * enc-&gt;bit_rate/enc-&gt;sample_rate;
     } else if (enc-&gt;codec_id == CODEC_ID_ADPCM_G726) { //
         blkalign = 1;
@@ -358,10 +304,14 @@
         put_le16(pb, 16); /* fwHeadFlags */
         put_le32(pb, 0);  /* dwPTSLow */
         put_le32(pb, 0);  /* dwPTSHigh */
+    } else if (enc-&gt;codec_id == CODEC_ID_GSM_MS) {
+        put_le16(pb, 2); /* wav_extra_size */
+        hdrsize += 2;
+        put_le16(pb, enc-&gt;frame_size); /* wSamplesPerBlock */
     } else if (enc-&gt;codec_id == CODEC_ID_ADPCM_IMA_WAV) {
         put_le16(pb, 2); /* wav_extra_size */
         hdrsize += 2;
-        put_le16(pb, ((enc-&gt;block_align - 4 * enc-&gt;channels) / (4 * enc-&gt;channels)) * 8 + 1); /* wSamplesPerBlock */
+        put_le16(pb, enc-&gt;frame_size); /* wSamplesPerBlock */
     } else if(enc-&gt;extradata_size){
         put_le16(pb, enc-&gt;extradata_size);
         put_buffer(pb, enc-&gt;extradata, enc-&gt;extradata_size);
@@ -387,10 +337,7 @@
 
     put_le16(pb, enc-&gt;bits_per_sample ? enc-&gt;bits_per_sample : 24); /* depth */
     /* compression type */
-
-    // MEANX we dont need that
-        assert(0);
-/*    put_le32(pb, for_asf ? (enc-&gt;codec_tag ? enc-&gt;codec_tag : av_codec_get_tag(asf_muxer.codec_tag, enc-&gt;codec_id)) : enc-&gt;codec_tag); //*/
+    put_le32(pb, enc-&gt;codec_tag);
     put_le32(pb, enc-&gt;width * enc-&gt;height * 3);
     put_le32(pb, 0);
     put_le32(pb, 0);
@@ -427,22 +374,30 @@
         codec-&gt;bits_per_sample = 8;
     }else
         codec-&gt;bits_per_sample = get_le16(pb);
-    codec-&gt;codec_id = wav_codec_get_id(id, codec-&gt;bits_per_sample);
-
-    if (size &gt; 16) {  /* We're obviously dealing with WAVEFORMATEX */
-        codec-&gt;extradata_size = get_le16(pb);
-        if (codec-&gt;extradata_size &gt; 0) {
-            if (codec-&gt;extradata_size &gt; size - 18)
-                codec-&gt;extradata_size = size - 18;
+    if (size &gt;= 18) {  /* We're obviously dealing with WAVEFORMATEX */
+        int cbSize = get_le16(pb); /* cbSize */
+        size -= 18;
+        cbSize = FFMIN(size, cbSize);
+        if (cbSize &gt;= 22 &amp;&amp; id == 0xfffe) { /* WAVEFORMATEXTENSIBLE */
+            codec-&gt;bits_per_sample = get_le16(pb);
+            get_le32(pb); /* dwChannelMask */
+            id = get_le32(pb); /* 4 first bytes of GUID */
+            url_fskip(pb, 12); /* skip end of GUID */
+            cbSize -= 22;
+            size -= 22;
+        }
+        codec-&gt;extradata_size = cbSize;
+        if (cbSize &gt; 0) {
             codec-&gt;extradata = av_mallocz(codec-&gt;extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);
             get_buffer(pb, codec-&gt;extradata, codec-&gt;extradata_size);
-        } else
-            codec-&gt;extradata_size = 0;
+            size -= cbSize;
+        }
 
         /* It is possible for the chunk to contain garbage at the end */
-        if (size - codec-&gt;extradata_size - 18 &gt; 0)
-            url_fskip(pb, size - codec-&gt;extradata_size - 18);
+        if (size &gt; 0)
+            url_fskip(pb, size);
     }
+    codec-&gt;codec_id = wav_codec_get_id(id, codec-&gt;bits_per_sample);
 }
 
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/riff.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/riff.h	2007-07-16 16:39:52 UTC (rev 3382)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/riff.h	2007-07-16 17:44:22 UTC (rev 3383)
@@ -28,6 +28,9 @@
 #ifndef FF_RIFF_H
 #define FF_RIFF_H
 
+#include &quot;avcodec.h&quot;
+#include &quot;avio.h&quot;
+
 offset_t start_tag(ByteIOContext *pb, const char *tag);
 void end_tag(ByteIOContext *pb, offset_t start);
 
@@ -46,10 +49,6 @@
 
 unsigned int codec_get_tag(const AVCodecTag *tags, int id);
 enum CodecID codec_get_id(const AVCodecTag *tags, unsigned int tag);
-unsigned int codec_get_bmp_tag(int id) attribute_deprecated; //use av_codec_get_tag
-unsigned int codec_get_wav_tag(int id) attribute_deprecated; //use av_codec_get_tag
-enum CodecID codec_get_bmp_id(unsigned int tag) attribute_deprecated; //use av_codec_get_id
-enum CodecID codec_get_wav_id(unsigned int tag) attribute_deprecated; //use av_codec_get_id
 void ff_parse_specific_params(AVCodecContext *stream, int *au_rate, int *au_ssize, int *au_scale);
 
 #endif

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/rtp.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/rtp.h	2007-07-16 16:39:52 UTC (rev 3382)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/rtp.h	2007-07-16 17:44:22 UTC (rev 3383)
@@ -21,11 +21,16 @@
 #ifndef RTP_H
 #define RTP_H
 
+#include &quot;avcodec.h&quot;
+#include &quot;avformat.h&quot;
+
 #define RTP_MIN_PACKET_LENGTH 12
 #define RTP_MAX_PACKET_LENGTH 1500 /* XXX: suppress this define */
 
 int rtp_init(void);
 int rtp_get_codec_info(AVCodecContext *codec, int payload_type);
+
+/** return &lt; 0 if unknown payload type */
 int rtp_get_payload_type(AVCodecContext *codec);
 
 typedef struct RTPDemuxContext RTPDemuxContext;
@@ -42,17 +47,24 @@
 int rtp_set_remote_url(URLContext *h, const char *uri);
 void rtp_get_file_handles(URLContext *h, int *prtp_fd, int *prtcp_fd);
 
+/**
+ * some rtp servers assume client is dead if they don't hear from them...
+ * so we send a Receiver Report to the provided ByteIO context
+ * (we don't have access to the rtcp handle from here)
+ */
+int rtp_check_and_send_back_rr(RTPDemuxContext *s, int count);
+
 extern URLProtocol rtp_protocol;
 
 #define RTP_PT_PRIVATE 96
 #define RTP_VERSION 2
-#define RTP_MAX_SDES 256   /* maximum text length for SDES */
+#define RTP_MAX_SDES 256   /**&lt; maximum text length for SDES */
 
 /* RTCP paquets use 0.5 % of the bandwidth */
 #define RTCP_TX_RATIO_NUM 5
 #define RTCP_TX_RATIO_DEN 1000
 
-/* Structure listing usefull vars to parse RTP packet payload*/
+/** Structure listing useful vars to parse RTP packet payload*/
 typedef struct rtp_payload_data_s
 {
     int sizelength;
@@ -63,7 +75,7 @@
     int objecttype;
     char *mode;
 
-    /* mpeg 4 AU headers */
+    /** mpeg 4 AU headers */
     struct AUHeaders {
         int size;
         int index;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/rtsp.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/rtsp.h	2007-07-16 16:39:52 UTC (rev 3382)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/rtsp.h	2007-07-16 17:44:22 UTC (rev 3383)
@@ -21,12 +21,9 @@
 #ifndef RTSP_H
 #define RTSP_H
 
-/* RTSP handling */
-enum RTSPStatusCode {
-#define DEF(n, c, s) c = n,
+#include &lt;stdint.h&gt;
+#include &quot;avformat.h&quot;
 #include &quot;rtspcodes.h&quot;
-#undef DEF
-};
 
 enum RTSPProtocol {
     RTSP_PROTOCOL_RTP_UDP = 0,
@@ -43,27 +40,27 @@
 #define RTSP_RTP_PORT_MAX 10000
 
 typedef struct RTSPTransportField {
-    int interleaved_min, interleaved_max;  /* interleave ids, if TCP transport */
-    int port_min, port_max; /* RTP ports */
-    int client_port_min, client_port_max; /* RTP ports */
-    int server_port_min, server_port_max; /* RTP ports */
-    int ttl; /* ttl value */
-    uint32_t destination; /* destination IP address */
+    int interleaved_min, interleaved_max;  /**&lt; interleave ids, if TCP transport */
+    int port_min, port_max; /**&lt; RTP ports */
+    int client_port_min, client_port_max; /**&lt; RTP ports */
+    int server_port_min, server_port_max; /**&lt; RTP ports */
+    int ttl; /**&lt; ttl value */
+    uint32_t destination; /**&lt; destination IP address */
     enum RTSPProtocol protocol;
 } RTSPTransportField;
 
 typedef struct RTSPHeader {
     int content_length;
-    enum RTSPStatusCode status_code; /* response code from server */
+    enum RTSPStatusCode status_code; /**&lt; response code from server */
     int nb_transports;
-    /* in AV_TIME_BASE unit, AV_NOPTS_VALUE if not used */
+    /** in AV_TIME_BASE unit, AV_NOPTS_VALUE if not used */
     int64_t range_start, range_end;
     RTSPTransportField transports[RTSP_MAX_TRANSPORTS];
-    int seq; /* sequence number */
+    int seq; /**&lt; sequence number */
     char session_id[512];
 } RTSPHeader;
 
-/* the callback can be used to extend the connection setup/teardown step */
+/** the callback can be used to extend the connection setup/teardown step */
 enum RTSPCallbackAction {
     RTSP_ACTION_SERVER_SETUP,
     RTSP_ACTION_SERVER_TEARDOWN,
@@ -81,15 +78,12 @@
                            char *buf, int buf_size,
                            void *arg);
 
-void rtsp_set_callback(FFRTSPCallback *rtsp_cb);
-
 int rtsp_init(void);
 void rtsp_parse_line(RTSPHeader *reply, const char *buf);
 
 extern int rtsp_default_protocols;
 extern int rtsp_rtp_port_min;
 extern int rtsp_rtp_port_max;
-extern FFRTSPCallback *ff_rtsp_callback;
 extern AVInputFormat rtsp_demuxer;
 
 int rtsp_pause(AVFormatContext *s);

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/rtspcodes.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/rtspcodes.h	2007-07-16 16:39:52 UTC (rev 3382)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/rtspcodes.h	2007-07-16 17:44:22 UTC (rev 3383)
@@ -18,14 +18,23 @@
  * License along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
-DEF(200, RTSP_STATUS_OK, &quot;OK&quot;)
-DEF(405, RTSP_STATUS_METHOD, &quot;Method Not Allowed&quot;)
-DEF(453, RTSP_STATUS_BANDWIDTH, &quot;Not Enough Bandwidth&quot;)
-DEF(454, RTSP_STATUS_SESSION, &quot;Session Not Found&quot;)
-DEF(455, RTSP_STATUS_STATE, &quot;Method Not Valid in This State&quot;)
-DEF(459, RTSP_STATUS_AGGREGATE, &quot;Aggregate operation not allowed&quot;)
-DEF(460, RTSP_STATUS_ONLY_AGGREGATE, &quot;Only aggregate operation allowed&quot;)
-DEF(461, RTSP_STATUS_TRANSPORT, &quot;Unsupported transport&quot;)
-DEF(500, RTSP_STATUS_INTERNAL, &quot;Internal Server Error&quot;)
-DEF(503, RTSP_STATUS_SERVICE, &quot;Service Unavailable&quot;)
-DEF(505, RTSP_STATUS_VERSION, &quot;RTSP Version not supported&quot;)
+
+#ifndef AVFORMAT_RTSPCODES_H
+#define AVFORMAT_RTSPCODES_H
+
+/** RTSP handling */
+enum RTSPStatusCode {
+RTSP_STATUS_OK              =200, /**&lt; OK */
+RTSP_STATUS_METHOD          =405, /**&lt; Method Not Allowed */
+RTSP_STATUS_BANDWIDTH       =453, /**&lt; Not Enough Bandwidth */
+RTSP_STATUS_SESSION         =454, /**&lt; Session Not Found */
+RTSP_STATUS_STATE           =455, /**&lt; Method Not Valid in This State */
+RTSP_STATUS_AGGREGATE       =459, /**&lt; Aggregate operation not allowed */
+RTSP_STATUS_ONLY_AGGREGATE  =460, /**&lt; Only aggregate operation allowed */
+RTSP_STATUS_TRANSPORT       =461, /**&lt; Unsupported transport */
+RTSP_STATUS_INTERNAL        =500, /**&lt; Internal Server Error */
+RTSP_STATUS_SERVICE         =503, /**&lt; Service Unavailable */
+RTSP_STATUS_VERSION         =505, /**&lt; RTSP Version not supported */
+};
+
+#endif // AVFORMAT_RTSPCODES_H

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/utils.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/utils.c	2007-07-16 16:39:52 UTC (rev 3382)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/utils.c	2007-07-16 17:44:22 UTC (rev 3383)
@@ -21,6 +21,8 @@
 #include &quot;avformat.h&quot;
 #include &quot;allformats.h&quot;
 #include &quot;opt.h&quot;
+#include &quot;avstring.h&quot;
+#include &quot;riff.h&quot;
 
 #undef NDEBUG
 #include &lt;assert.h&gt;
@@ -139,9 +141,6 @@
     return fmt;
 }
 
-/**
- * Guesses the codec id based upon muxer and filename.
- */
 enum CodecID av_guess_codec(AVOutputFormat *fmt, const char *short_name,
                             const char *filename, const char *mime_type, enum CodecType type){
     if(type == CODEC_TYPE_VIDEO){
@@ -161,9 +160,6 @@
         return CODEC_ID_NONE;
 }
 
-/**
- * finds AVInputFormat based on input format's short name.
- */
 AVInputFormat *av_find_input_format(const char *short_name)
 {
     AVInputFormat *fmt;
@@ -176,22 +172,23 @@
 
 /* memory handling */
 
-/**
- * Default packet destructor.
- */
 void av_destruct_packet(AVPacket *pkt)
 {
     av_free(pkt-&gt;data);
     pkt-&gt;data = NULL; pkt-&gt;size = 0;
 }
 
-/**
- * Allocate the payload of a packet and intialized its fields to default values.
- *
- * @param pkt packet
- * @param size wanted payload size
- * @return 0 if OK. AVERROR_xxx otherwise.
- */
+void av_init_packet(AVPacket *pkt)
+{
+    pkt-&gt;pts   = AV_NOPTS_VALUE;
+    pkt-&gt;dts   = AV_NOPTS_VALUE;
+    pkt-&gt;pos   = -1;
+    pkt-&gt;duration = 0;
+    pkt-&gt;flags = 0;
+    pkt-&gt;stream_index = 0;
+    pkt-&gt;destruct= av_destruct_packet_nofree;
+}
+
 int av_new_packet(AVPacket *pkt, int size)
 {
     uint8_t *data;
@@ -209,13 +206,6 @@
     return 0;
 }
 
-/**
- * Allocate and read the payload of a packet and intialized its fields to default values.
- *
- * @param pkt packet
- * @param size wanted payload size
- * @return &gt;0 (read size) if OK. AVERROR_xxx otherwise.
- */
 int av_get_packet(ByteIOContext *s, AVPacket *pkt, int size)
 {
     int ret= av_new_packet(pkt, size);
@@ -234,8 +224,6 @@
     return ret;
 }
 
-/* This is a hack - the packet memory allocation stuff is broken. The
-   packet is allocated if it was not really allocated */
 int av_dup_packet(AVPacket *pkt)
 {
     if (pkt-&gt;destruct != av_destruct_packet) {
@@ -256,31 +244,18 @@
     return 0;
 }
 
-/**
- * Allocate the payload of a packet and intialized its fields to default values.
- *
- * @param filename possible numbered sequence string
- * @return 1 if a valid numbered sequence string, 0 otherwise.
- */
 int av_filename_number_test(const char *filename)
 {
     char buf[1024];
     return filename &amp;&amp; (av_get_frame_filename(buf, sizeof(buf), filename, 1)&gt;=0);
 }
 
-/**
- * Guess file format.
- *
- * @param is_opened whether the file is already opened, determines whether
- *                  demuxers with or without AVFMT_NOFILE are probed
- */
-AVInputFormat *av_probe_input_format(AVProbeData *pd, int is_opened)
+static AVInputFormat *av_probe_input_format2(AVProbeData *pd, int is_opened, int *score_max)
 {
     AVInputFormat *fmt1, *fmt;
-    int score, score_max;
+    int score;
 
     fmt = NULL;
-    score_max = 0;
     for(fmt1 = first_iformat; fmt1 != NULL; fmt1 = fmt1-&gt;next) {
         if (!is_opened == !(fmt1-&gt;flags &amp; AVFMT_NOFILE))
             continue;
@@ -292,14 +267,19 @@
                 score = 50;
             }
         }
-        if (score &gt; score_max) {
-            score_max = score;
+        if (score &gt; *score_max) {
+            *score_max = score;
             fmt = fmt1;
         }
     }
     return fmt;
 }
 
+AVInputFormat *av_probe_input_format(AVProbeData *pd, int is_opened){
+    int score=0;
+    return av_probe_input_format2(pd, is_opened, &amp;score);
+}
+
 /************************************************************/
 /* input media file */
 
@@ -315,7 +295,7 @@
 }
 
 #define OFFSET(x) offsetof(AVFormatContext,x)
-#define DEFAULT 0 //should be NAN but it doesnt work as its not a constant in glibc as required by ANSI/ISO C
+#define DEFAULT 0 //should be NAN but it does not work as it is not a constant in glibc as required by ANSI/ISO C
 //these names are too long to be readable
 #define E AV_OPT_FLAG_ENCODING_PARAM
 #define D AV_OPT_FLAG_DECODING_PARAM
@@ -329,6 +309,7 @@
 {&quot;genpts&quot;, &quot;generate pts&quot;, 0, FF_OPT_TYPE_CONST, AVFMT_FLAG_GENPTS, INT_MIN, INT_MAX, D, &quot;fflags&quot;},
 {&quot;track&quot;, &quot; set the track number&quot;, OFFSET(track), FF_OPT_TYPE_INT, DEFAULT, 0, INT_MAX, E},
 {&quot;year&quot;, &quot;set the year&quot;, OFFSET(year), FF_OPT_TYPE_INT, DEFAULT, INT_MIN, INT_MAX, E},
+{&quot;analyzeduration&quot;, &quot;how many microseconds are analyzed to estimate duration&quot;, OFFSET(max_analyze_duration), FF_OPT_TYPE_INT, 3*AV_TIME_BASE, 0, INT_MAX, D},
 {NULL},
 };
 
@@ -357,10 +338,6 @@
     return ic;
 }
 
-/**
- * Allocates all the structures needed to read an input stream.
- *        This does not open the needed codecs for decoding the stream[s].
- */
 int av_open_input_stream(AVFormatContext **ic_ptr,
                          ByteIOContext *pb, const char *filename,
                          AVInputFormat *fmt, AVFormatParameters *ap)
@@ -387,7 +364,7 @@
         ic-&gt;pb = *pb;
     ic-&gt;duration = AV_NOPTS_VALUE;
     ic-&gt;start_time = AV_NOPTS_VALUE;
-    pstrcpy(ic-&gt;filename, sizeof(ic-&gt;filename), filename);
+    av_strlcpy(ic-&gt;filename, filename, sizeof(ic-&gt;filename));
 
     /* allocate private data */
     if (fmt-&gt;priv_data_size &gt; 0) {
@@ -422,17 +399,6 @@
 #define PROBE_BUF_MIN 2048
 #define PROBE_BUF_MAX (1&lt;&lt;20)
 
-/**
- * Open a media file as input. The codec are not opened. Only the file
- * header (if present) is read.
- *
- * @param ic_ptr the opened media file handle is put here
- * @param filename filename to open.
- * @param fmt if non NULL, force the file format to use
- * @param buf_size optional buffer size (zero if default is OK)
- * @param ap additionnal parameters needed when opening the file (NULL if default)
- * @return 0 if OK. AVERROR_xxx otherwise.
- */
 int av_open_input_file(AVFormatContext **ic_ptr, const char *filename,
                        AVInputFormat *fmt,
                        int buf_size,
@@ -459,13 +425,12 @@
     must_open_file = 1;
     if (fmt &amp;&amp; (fmt-&gt;flags &amp; AVFMT_NOFILE)) {
         must_open_file = 0;
-        pb= NULL; //FIXME this or memset(pb, 0, sizeof(ByteIOContext)); otherwise its uninitalized
+        pb= NULL; //FIXME this or memset(pb, 0, sizeof(ByteIOContext)); otherwise it is uninitialized
     }
 
     if (!fmt || must_open_file) {
         /* if no file needed do not try to open one */
-        if (url_fopen(pb, filename, URL_RDONLY) &lt; 0) {
-            err = AVERROR_IO;
+        if ((err=url_fopen(pb, filename, URL_RDONLY)) &lt; 0) {
             goto fail;
         }
         file_opened = 1;
@@ -474,10 +439,11 @@
         }
 
         for(probe_size= PROBE_BUF_MIN; probe_size&lt;=PROBE_BUF_MAX &amp;&amp; !fmt; probe_size&lt;&lt;=1){
+            int score= probe_size &lt; PROBE_BUF_MAX ? AVPROBE_SCORE_MAX/4 : 0;
             /* read probe data */
-            pd-&gt;buf= av_realloc(pd-&gt;buf, probe_size);
+            pd-&gt;buf= av_realloc(pd-&gt;buf, probe_size + AVPROBE_PADDING_SIZE);
             pd-&gt;buf_size = get_buffer(pb, pd-&gt;buf, probe_size);
-            if (url_fseek(pb, 0, SEEK_SET) == (offset_t)-EPIPE) {
+            if (url_fseek(pb, 0, SEEK_SET) &lt; 0) {
                 url_fclose(pb);
                 if (url_fopen(pb, filename, URL_RDONLY) &lt; 0) {
                     file_opened = 0;
@@ -486,7 +452,7 @@
                 }
             }
             /* guess file format */
-            fmt = av_probe_input_format(pd, 1);
+            fmt = av_probe_input_format2(pd, 1, &amp;score);
         }
         av_freep(&amp;pd-&gt;buf);
     }
@@ -498,7 +464,7 @@
     }
 
     /* XXX: suppress this hack for redirectors */
-#ifdef CONFIG_NETWORK
+#ifdef CONFIG_REDIR_DEMUXER
     if (fmt == &amp;redir_demuxer) {
         err = redir_open(ic_ptr, pb);
         url_fclose(pb);
@@ -528,18 +494,9 @@
 
 /*******************************************************/
 
-/**
- * Read a transport packet from a media file.
- *
- * This function is absolete and should never be used.
- * Use av_read_frame() instead.
- *
- * @param s media file handle
- * @param pkt is filled
- * @return 0 if OK. AVERROR_xxx if error.
- */
 int av_read_packet(AVFormatContext *s, AVPacket *pkt)
 {
+    av_init_packet(pkt);
     return s-&gt;iformat-&gt;read_packet(s, pkt);
 }
 
@@ -639,7 +596,8 @@
 static void compute_pkt_fields(AVFormatContext *s, AVStream *st,
                                AVCodecParserContext *pc, AVPacket *pkt)
 {
-    int num, den, presentation_delayed;
+    int num, den, presentation_delayed, delay, i;
+    int64_t offset;
     /* handle wrapping */
     if(st-&gt;cur_dts != AV_NOPTS_VALUE){
         if(pkt-&gt;pts != AV_NOPTS_VALUE)
@@ -655,95 +613,95 @@
         }
     }
 
+    /* correct timestamps with byte offset if demuxers only have timestamps on packet boundaries */
+    if(pc &amp;&amp; st-&gt;need_parsing == AVSTREAM_PARSE_TIMESTAMPS &amp;&amp; pkt-&gt;size){
+        /* this will estimate bitrate based on this frame's duration and size */
+        offset = av_rescale(pc-&gt;offset, pkt-&gt;duration, pkt-&gt;size);
+        if(pkt-&gt;pts != AV_NOPTS_VALUE)
+            pkt-&gt;pts += offset;
+        if(pkt-&gt;dts != AV_NOPTS_VALUE)
+            pkt-&gt;dts += offset;
+    }
+
     if(is_intra_only(st-&gt;codec))
         pkt-&gt;flags |= PKT_FLAG_KEY;
 
     /* do we have a video B frame ? */
+    delay= st-&gt;codec-&gt;has_b_frames;
     presentation_delayed = 0;
-    if (st-&gt;codec-&gt;codec_type == CODEC_TYPE_VIDEO) {
-        /* XXX: need has_b_frame, but cannot get it if the codec is
-           not initialized */
-        if ((   st-&gt;codec-&gt;codec_id == CODEC_ID_H264
-             || st-&gt;codec-&gt;has_b_frames) &amp;&amp;
-            pc &amp;&amp; pc-&gt;pict_type != FF_B_TYPE)
-            presentation_delayed = 1;
-        /* this may be redundant, but it shouldnt hurt */
-        if(pkt-&gt;dts != AV_NOPTS_VALUE &amp;&amp; pkt-&gt;pts != AV_NOPTS_VALUE &amp;&amp; pkt-&gt;pts &gt; pkt-&gt;dts)
-            presentation_delayed = 1;
-    }
+    /* XXX: need has_b_frame, but cannot get it if the codec is
+        not initialized */
+    if (delay &amp;&amp;
+        pc &amp;&amp; pc-&gt;pict_type != FF_B_TYPE)
+        presentation_delayed = 1;
+    /* This may be redundant, but it should not hurt. */
+    if(pkt-&gt;dts != AV_NOPTS_VALUE &amp;&amp; pkt-&gt;pts != AV_NOPTS_VALUE &amp;&amp; pkt-&gt;pts &gt; pkt-&gt;dts)
+        presentation_delayed = 1;
 
     if(st-&gt;cur_dts == AV_NOPTS_VALUE){
-        if(presentation_delayed) st-&gt;cur_dts = -pkt-&gt;duration;
-        else                     st-&gt;cur_dts = 0;
+        st-&gt;cur_dts = -delay * pkt-&gt;duration;
     }
 
 //    av_log(NULL, AV_LOG_DEBUG, &quot;IN delayed:%d pts:%&quot;PRId64&quot;, dts:%&quot;PRId64&quot; cur_dts:%&quot;PRId64&quot; st:%d pc:%p\n&quot;, presentation_delayed, pkt-&gt;pts, pkt-&gt;dts, st-&gt;cur_dts, pkt-&gt;stream_index, pc);
     /* interpolate PTS and DTS if they are not present */
-    if (presentation_delayed) {
-        /* DTS = decompression time stamp */
-        /* PTS = presentation time stamp */
-        if (pkt-&gt;dts == AV_NOPTS_VALUE) {
-            /* if we know the last pts, use it */
-            if(st-&gt;last_IP_pts != AV_NOPTS_VALUE)
-                st-&gt;cur_dts = pkt-&gt;dts = st-&gt;last_IP_pts;
-            else
+    if(delay &lt;=1){
+        if (presentation_delayed) {
+            /* DTS = decompression time stamp */
+            /* PTS = presentation time stamp */
+            if (pkt-&gt;dts == AV_NOPTS_VALUE)
+                pkt-&gt;dts = st-&gt;last_IP_pts;
+            if (pkt-&gt;dts == AV_NOPTS_VALUE)
                 pkt-&gt;dts = st-&gt;cur_dts;
-        } else {
-            st-&gt;cur_dts = pkt-&gt;dts;
-        }
-        /* this is tricky: the dts must be incremented by the duration
-           of the frame we are displaying, i.e. the last I or P frame */
-        if (st-&gt;last_IP_duration == 0)
-            st-&gt;cur_dts += pkt-&gt;duration;
-        else
-            st-&gt;cur_dts += st-&gt;last_IP_duration;
-        st-&gt;last_IP_duration  = pkt-&gt;duration;
-        st-&gt;last_IP_pts= pkt-&gt;pts;
-        /* cannot compute PTS if not present (we can compute it only
-           by knowing the futur */
-    } else if(pkt-&gt;pts != AV_NOPTS_VALUE || pkt-&gt;dts != AV_NOPTS_VALUE || pkt-&gt;duration){
-        if(pkt-&gt;pts != AV_NOPTS_VALUE &amp;&amp; pkt-&gt;duration){
-            int64_t old_diff= FFABS(st-&gt;cur_dts - pkt-&gt;duration - pkt-&gt;pts);
-            int64_t new_diff= FFABS(st-&gt;cur_dts - pkt-&gt;pts);
-            if(old_diff &lt; new_diff &amp;&amp; old_diff &lt; (pkt-&gt;duration&gt;&gt;3)){
-                pkt-&gt;pts += pkt-&gt;duration;
-//                av_log(NULL, AV_LOG_DEBUG, &quot;id:%d old:%&quot;PRId64&quot; new:%&quot;PRId64&quot; dur:%d cur:%&quot;PRId64&quot; size:%d\n&quot;, pkt-&gt;stream_index, old_diff, new_diff, pkt-&gt;duration, st-&gt;cur_dts, pkt-&gt;size);
-            }
-        }
 
-        /* presentation is not delayed : PTS and DTS are the same */
-        if (pkt-&gt;pts == AV_NOPTS_VALUE) {
-            if (pkt-&gt;dts == AV_NOPTS_VALUE) {
-                pkt-&gt;pts = st-&gt;cur_dts;
-                pkt-&gt;dts = st-&gt;cur_dts;
+            /* this is tricky: the dts must be incremented by the duration
+            of the frame we are displaying, i.e. the last I or P frame */
+            if (st-&gt;last_IP_duration == 0)
+                st-&gt;last_IP_duration = pkt-&gt;duration;
+            st-&gt;cur_dts = pkt-&gt;dts + st-&gt;last_IP_duration;
+            st-&gt;last_IP_duration  = pkt-&gt;duration;
+            st-&gt;last_IP_pts= pkt-&gt;pts;
+            /* cannot compute PTS if not present (we can compute it only
+            by knowing the futur */
+        } else if(pkt-&gt;pts != AV_NOPTS_VALUE || pkt-&gt;dts != AV_NOPTS_VALUE || pkt-&gt;duration){
+            if(pkt-&gt;pts != AV_NOPTS_VALUE &amp;&amp; pkt-&gt;duration){
+                int64_t old_diff= FFABS(st-&gt;cur_dts - pkt-&gt;duration - pkt-&gt;pts);
+                int64_t new_diff= FFABS(st-&gt;cur_dts - pkt-&gt;pts);
+                if(old_diff &lt; new_diff &amp;&amp; old_diff &lt; (pkt-&gt;duration&gt;&gt;3)){
+                    pkt-&gt;pts += pkt-&gt;duration;
+    //                av_log(NULL, AV_LOG_DEBUG, &quot;id:%d old:%&quot;PRId64&quot; new:%&quot;PRId64&quot; dur:%d cur:%&quot;PRId64&quot; size:%d\n&quot;, pkt-&gt;stream_index, old_diff, new_diff, pkt-&gt;duration, st-&gt;cur_dts, pkt-&gt;size);
+                }
             }
-            else {
-                st-&gt;cur_dts = pkt-&gt;dts;
+
+            /* presentation is not delayed : PTS and DTS are the same */
+            if(pkt-&gt;pts == AV_NOPTS_VALUE)
                 pkt-&gt;pts = pkt-&gt;dts;
-            }
-        } else {
-            st-&gt;cur_dts = pkt-&gt;pts;
+            if(pkt-&gt;pts == AV_NOPTS_VALUE)
+                pkt-&gt;pts = st-&gt;cur_dts;
             pkt-&gt;dts = pkt-&gt;pts;
+            st-&gt;cur_dts = pkt-&gt;pts + pkt-&gt;duration;
         }
-        st-&gt;cur_dts += pkt-&gt;duration;
     }
-//    av_log(NULL, AV_LOG_DEBUG, &quot;OUTdelayed:%d pts:%&quot;PRId64&quot;, dts:%&quot;PRId64&quot; cur_dts:%&quot;PRId64&quot;\n&quot;, presentation_delayed, pkt-&gt;pts, pkt-&gt;dts, st-&gt;cur_dts);
 
+    if(pkt-&gt;pts != AV_NOPTS_VALUE){
+        st-&gt;pts_buffer[0]= pkt-&gt;pts;
+        for(i=1; i&lt;delay+1 &amp;&amp; st-&gt;pts_buffer[i] == AV_NOPTS_VALUE; i++)
+            st-&gt;pts_buffer[i]= (i-delay-1) * pkt-&gt;duration;
+        for(i=0; i&lt;delay &amp;&amp; st-&gt;pts_buffer[i] &gt; st-&gt;pts_buffer[i+1]; i++)
+            FFSWAP(int64_t, st-&gt;pts_buffer[i], st-&gt;pts_buffer[i+1]);
+        if(pkt-&gt;dts == AV_NOPTS_VALUE)
+            pkt-&gt;dts= st-&gt;pts_buffer[0];
+        if(pkt-&gt;dts &gt; st-&gt;cur_dts)
+            st-&gt;cur_dts = pkt-&gt;dts;
+    }
+
+//    av_log(NULL, AV_LOG_ERROR, &quot;OUTdelayed:%d/%d pts:%&quot;PRId64&quot;, dts:%&quot;PRId64&quot; cur_dts:%&quot;PRId64&quot;\n&quot;, presentation_delayed, delay, pkt-&gt;pts, pkt-&gt;dts, st-&gt;cur_dts);
+
     /* update flags */
     if (pc) {
         pkt-&gt;flags = 0;
         /* key frame computation */
-        switch(st-&gt;codec-&gt;codec_type) {
-        case CODEC_TYPE_VIDEO:
             if (pc-&gt;pict_type == FF_I_TYPE)
                 pkt-&gt;flags |= PKT_FLAG_KEY;
-            break;
-        case CODEC_TYPE_AUDIO:
-            pkt-&gt;flags |= PKT_FLAG_KEY;
-            break;
-        default:
-            break;
-        }
     }
 }
 
@@ -757,6 +715,8 @@
     AVStream *st;
     int len, ret, i;
 
+    av_init_packet(pkt);
+
     for(;;) {
         /* select current input stream component */
         st = s-&gt;cur_st;
@@ -781,12 +741,19 @@
                 /* return packet if any */
                 if (pkt-&gt;size) {
                 got_packet:
+                    pkt-&gt;pos = s-&gt;cur_pkt.pos;              // Isn't quite accurate but close.
                     pkt-&gt;duration = 0;
                     pkt-&gt;stream_index = st-&gt;index;
                     pkt-&gt;pts = st-&gt;parser-&gt;pts;
                     pkt-&gt;dts = st-&gt;parser-&gt;dts;
                     pkt-&gt;destruct = av_destruct_packet_nofree;
                     compute_pkt_fields(s, st, st-&gt;parser, pkt);
+
+                    if((s-&gt;iformat-&gt;flags &amp; AVFMT_GENERIC_INDEX) &amp;&amp; pkt-&gt;flags &amp; PKT_FLAG_KEY){
+                        av_add_index_entry(st, st-&gt;parser-&gt;frame_offset, pkt-&gt;dts,
+                                           0, 0, AVINDEX_KEYFRAME);
+                    }
+
                     break;
                 }
             } else {
@@ -798,7 +765,7 @@
             /* read next packet */
             ret = av_read_packet(s, &amp;s-&gt;cur_pkt);
             if (ret &lt; 0) {
-                if (ret == -EAGAIN)
+                if (ret == AVERROR(EAGAIN))
                     return ret;
                 /* return the last frames, if any */
                 for(i = 0; i &lt; s-&gt;nb_streams; i++) {
@@ -831,10 +798,14 @@
                 st-&gt;parser = av_parser_init(st-&gt;codec-&gt;codec_id);
                 if (!st-&gt;parser) {
                     /* no parser available : just output the raw packets */
-                    st-&gt;need_parsing = 0;
-                }else if(st-&gt;need_parsing == 2){
+                    st-&gt;need_parsing = AVSTREAM_PARSE_NONE;
+                }else if(st-&gt;need_parsing == AVSTREAM_PARSE_HEADERS){
                     st-&gt;parser-&gt;flags |= PARSER_FLAG_COMPLETE_FRAMES;
                 }
+                if(st-&gt;parser &amp;&amp; (s-&gt;iformat-&gt;flags &amp; AVFMT_GENERIC_INDEX)){
+                    st-&gt;parser-&gt;last_frame_offset=
+                    st-&gt;parser-&gt;cur_offset= s-&gt;cur_pkt.pos;
+                }
             }
         }
     }
@@ -848,25 +819,6 @@
     return 0;
 }
 
-/**
- * Return the next frame of a stream.
- *
- * The returned packet is valid
- * until the next av_read_frame() or until av_close_input_file() and
- * must be freed with av_free_packet. For video, the packet contains
- * exactly one frame. For audio, it contains an integer number of
- * frames if each frame has a known fixed size (e.g. PCM or ADPCM
- * data). If the audio frames have a variable size (e.g. MPEG audio),
- * then it contains one frame.
- *
- * pkt-&gt;pts, pkt-&gt;dts and pkt-&gt;duration are always set to correct
- * values in AV_TIME_BASE unit (and guessed if the format cannot
- * provided them). pkt-&gt;pts can be AV_NOPTS_VALUE if the video format
- * has B frames, so it is better to rely on pkt-&gt;dts if you do not
- * decompress the payload.
- *
- * @return 0 if OK, &lt; 0 if error or end of file.
- */
 int av_read_frame(AVFormatContext *s, AVPacket *pkt)
 {
     AVPacketList *pktl;
@@ -905,7 +857,7 @@
             AVPacketList **plast_pktl= &amp;s-&gt;packet_buffer;
             int ret= av_read_frame_internal(s, pkt);
             if(ret&lt;0){
-                if(pktl &amp;&amp; ret != -EAGAIN){
+                if(pktl &amp;&amp; ret != AVERROR(EAGAIN)){
                     eof=1;
                     continue;
                 }else
@@ -995,18 +947,10 @@
             st-&gt;parser = NULL;
         }
         st-&gt;last_IP_pts = AV_NOPTS_VALUE;
-        st-&gt;cur_dts = 0; /* we set the current DTS to an unspecified origin */
+        st-&gt;cur_dts = AV_NOPTS_VALUE; /* we set the current DTS to an unspecified origin */
     }
 }
 
-/**
- * Updates cur_dts of all streams based on given timestamp and AVStream.
- *
- * Stream ref_st unchanged, others set cur_dts in their native timebase
- * only needed for timestamp wrapping or if (dts not set and pts!=dts)
- * @param timestamp new dts expressed in time_base of param ref_st
- * @param ref_st reference stream giving time_base of param timestamp
- */
 void av_update_cur_dts(AVFormatContext *s, AVStream *ref_st, int64_t timestamp){
     int i;
 
@@ -1019,11 +963,6 @@
     }
 }
 
-/**
- * Add a index entry into a sorted list updateing if it is already there.
- *
- * @param timestamp timestamp in the timebase of the given stream
- */
 int av_add_index_entry(AVStream *st,
                             int64_t pos, int64_t timestamp, int size, int distance, int flags)
 {
@@ -1055,7 +994,7 @@
                 return -1;
             memmove(entries + index + 1, entries + index, sizeof(AVIndexEntry)*(st-&gt;nb_index_entries - index));
             st-&gt;nb_index_entries++;
-        }else if(ie-&gt;pos == pos &amp;&amp; distance &lt; ie-&gt;min_distance) //dont reduce the distance
+        }else if(ie-&gt;pos == pos &amp;&amp; distance &lt; ie-&gt;min_distance) //do not reduce the distance
             distance= ie-&gt;min_distance;
     }
 
@@ -1068,57 +1007,6 @@
     return index;
 }
 
-/**
- * build an index for raw streams using a parser.
- */
-static void av_build_index_raw(AVFormatContext *s)
-{
-    AVPacket pkt1, *pkt = &amp;pkt1;
-    int ret;
-    AVStream *st;
-
-    st = s-&gt;streams[0];
-    av_read_frame_flush(s);
-    url_fseek(&amp;s-&gt;pb, s-&gt;data_offset, SEEK_SET);
-
-    for(;;) {
-        ret = av_read_frame(s, pkt);
-        if (ret &lt; 0)
-            break;
-        if (pkt-&gt;stream_index == 0 &amp;&amp; st-&gt;parser &amp;&amp;
-            (pkt-&gt;flags &amp; PKT_FLAG_KEY)) {
-            av_add_index_entry(st, st-&gt;parser-&gt;frame_offset, pkt-&gt;dts,
-                            0, 0, AVINDEX_KEYFRAME);
-        }
-        av_free_packet(pkt);
-    }
-}
-
-/**
- * Returns TRUE if we deal with a raw stream.
- *
- * Raw codec data and parsing needed.
- */
-static int is_raw_stream(AVFormatContext *s)
-{
-    AVStream *st;
-
-    if (s-&gt;nb_streams != 1)
-        return 0;
-    st = s-&gt;streams[0];
-    if (!st-&gt;need_parsing)
-        return 0;
-    return 1;
-}
-
-/**
- * Gets the index for a specific timestamp.
- * @param flags if AVSEEK_FLAG_BACKWARD then the returned index will correspond to
- *                 the timestamp which is &lt;= the requested one, if backward is 0
- *                 then it will be &gt;=
- *              if AVSEEK_FLAG_ANY seek to any frame, only keyframes otherwise
- * @return &lt; 0 if no such timestamp could be found
- */
 int av_index_search_timestamp(AVStream *st, int64_t wanted_timestamp,
                               int flags)
 {
@@ -1153,12 +1041,6 @@
 
 #define DEBUG_SEEK
 
-/**
- * Does a binary search using av_index_search_timestamp() and AVCodec.read_timestamp().
- * this isnt supposed to be called directly by a user application, but by demuxers
- * @param target_ts target timestamp in the time base of the given stream
- * @param stream_index stream number
- */
 int av_seek_frame_binary(AVFormatContext *s, int stream_index, int64_t target_ts, int flags){
     AVInputFormat *avif= s-&gt;iformat;
     int64_t pos_min, pos_max, pos, pos_limit;
@@ -1175,7 +1057,7 @@
 
     ts_max=
     ts_min= AV_NOPTS_VALUE;
-    pos_limit= -1; //gcc falsely says it may be uninitalized
+    pos_limit= -1; //gcc falsely says it may be uninitialized
 
     st= s-&gt;streams[stream_index];
     if(st-&gt;index_entries){
@@ -1223,12 +1105,6 @@
     return 0;
 }
 
-/**
- * Does a binary search using read_timestamp().
- * this isnt supposed to be called directly by a user application, but by demuxers
- * @param target_ts target timestamp in the time base of the given stream
- * @param stream_index stream number
- */
 int64_t av_gen_search(AVFormatContext *s, int stream_index, int64_t target_ts, int64_t pos_min, int64_t pos_max, int64_t pos_limit, int64_t ts_min, int64_t ts_max, int flags, int64_t *ts_ret, int64_t (*read_timestamp)(struct AVFormatContext *, int , int64_t *, int64_t )){
     int64_t pos, ts;
     int64_t start_pos, filesize;
@@ -1311,6 +1187,10 @@
 #ifdef DEBUG_SEEK
 av_log(s, AV_LOG_DEBUG, &quot;%&quot;PRId64&quot; %&quot;PRId64&quot; %&quot;PRId64&quot; / %&quot;PRId64&quot; %&quot;PRId64&quot; %&quot;PRId64&quot; target:%&quot;PRId64&quot; limit:%&quot;PRId64&quot; start:%&quot;PRId64&quot; noc:%d\n&quot;, pos_min, pos, pos_max, ts_min, ts, ts_max, target_ts, pos_limit, start_pos, no_change);
 #endif
+        if(ts == AV_NOPTS_VALUE){
+            av_log(s, AV_LOG_ERROR, &quot;read_timestamp() failed in the middle\n&quot;);
+            return -1;
+        }
         assert(ts != AV_NOPTS_VALUE);
         if (target_ts &lt;= ts) {
             pos_limit = start_pos - 1;
@@ -1369,23 +1249,42 @@
     AVStream *st;
     AVIndexEntry *ie;
 
-    if (!s-&gt;index_built) {
-        if (is_raw_stream(s)) {
-            av_build_index_raw(s);
-        } else {
-            return -1;
-        }
-        s-&gt;index_built = 1;
-    }
-
     st = s-&gt;streams[stream_index];
+
     index = av_index_search_timestamp(st, timestamp, flags);
+
+    if(index &lt; 0 || index==st-&gt;nb_index_entries-1){
+        int i;
+        AVPacket pkt;
+
+        if(st-&gt;index_entries &amp;&amp; st-&gt;nb_index_entries){
+            ie= &amp;st-&gt;index_entries[st-&gt;nb_index_entries-1];
+            url_fseek(&amp;s-&gt;pb, ie-&gt;pos, SEEK_SET);
+            av_update_cur_dts(s, st, ie-&gt;timestamp);
+        }else
+            url_fseek(&amp;s-&gt;pb, 0, SEEK_SET);
+
+        for(i=0;; i++) {
+            int ret = av_read_frame(s, &amp;pkt);
+            if(ret&lt;0)
+                break;
+            av_free_packet(&amp;pkt);
+            if(stream_index == pkt.stream_index){
+                if((pkt.flags &amp; PKT_FLAG_KEY) &amp;&amp; pkt.dts &gt; timestamp)
+                    break;
+            }
+        }
+        index = av_index_search_timestamp(st, timestamp, flags);
+    }
     if (index &lt; 0)
         return -1;
 
-    /* now we have found the index, we can seek */
-    ie = &amp;st-&gt;index_entries[index];
     av_read_frame_flush(s);
+    if (s-&gt;iformat-&gt;read_seek){
+        if(s-&gt;iformat-&gt;read_seek(s, stream_index, timestamp, flags) &gt;= 0)
+            return 0;
+    }
+    ie = &amp;st-&gt;index_entries[index];
     url_fseek(&amp;s-&gt;pb, ie-&gt;pos, SEEK_SET);
 
     av_update_cur_dts(s, st, ie-&gt;timestamp);
@@ -1393,17 +1292,6 @@
     return 0;
 }
 
-/**
- * Seek to the key frame at timestamp.
- * 'timestamp' in 'stream_index'.
- * @param stream_index If stream_index is (-1), a default
- * stream is selected, and timestamp is automatically converted
- * from AV_TIME_BASE units to the stream specific time_base.
- * @param timestamp timestamp in AVStream.time_base units
- *        or if there is no stream specified then in AV_TIME_BASE units
- * @param flags flags which select direction and seeking mode
- * @return &gt;= 0 on success
- */
 int av_seek_frame(AVFormatContext *s, int stream_index, int64_t timestamp, int flags)
 {
     int ret;
@@ -1557,7 +1445,7 @@
 #define DURATION_MAX_READ_SIZE 250000
 
 /* only usable for MPEG-PS streams */
-static void av_estimate_timings_from_pts(AVFormatContext *ic)
+static void av_estimate_timings_from_pts(AVFormatContext *ic, offset_t old_offset)
 {
     AVPacket pkt1, *pkt = &amp;pkt1;
     AVStream *st;
@@ -1649,10 +1537,10 @@
 
     fill_all_stream_timings(ic);
 
-    url_fseek(&amp;ic-&gt;pb, 0, SEEK_SET);
+    url_fseek(&amp;ic-&gt;pb, old_offset, SEEK_SET);
 }
 
-static void av_estimate_timings(AVFormatContext *ic)
+static void av_estimate_timings(AVFormatContext *ic, offset_t old_offset)
 {
     int64_t file_size;
 
@@ -1670,7 +1558,7 @@
          !strcmp(ic-&gt;iformat-&gt;name, &quot;mpegts&quot;)) &amp;&amp;
         file_size &amp;&amp; !ic-&gt;pb.is_streamed) {
         /* get accurate estimate from the PTSes */
-        av_estimate_timings_from_pts(ic);
+        av_estimate_timings_from_pts(ic, old_offset);
     } else if (av_has_timings(ic)) {
         /* at least one components has timings - we use them for all
            the components */
@@ -1720,7 +1608,7 @@
 {
     int16_t *samples;
     AVCodec *codec;
-    int got_picture, ret=0;
+    int got_picture, data_size, ret=0;
     AVFrame picture;
 
   if(!st-&gt;codec-&gt;codec){
@@ -1739,11 +1627,12 @@
                                    &amp;got_picture, (uint8_t *)data, size);
         break;
     case CODEC_TYPE_AUDIO:
-        samples = av_malloc(AVCODEC_MAX_AUDIO_FRAME_SIZE);
+        data_size = FFMAX(size, AVCODEC_MAX_AUDIO_FRAME_SIZE);
+        samples = av_malloc(data_size);
         if (!samples)
             goto fail;
-        ret = avcodec_decode_audio(st-&gt;codec, samples,
-                                   &amp;got_picture, (uint8_t *)data, size);
+        ret = avcodec_decode_audio2(st-&gt;codec, samples,
+                                    &amp;data_size, (uint8_t *)data, size);
         av_free(samples);
         break;
     default:
@@ -1754,28 +1643,72 @@
     return ret;
 }
 
+static int set_codec_from_probe_data(AVStream *st, AVProbeData *pd, int score)
+{
+    AVInputFormat *fmt;
+    fmt = av_probe_input_format2(pd, 1, &amp;score);
+
+    if (fmt) {
+        if (strncmp(fmt-&gt;name, &quot;mp3&quot;, 3) == 0)
+            st-&gt;codec-&gt;codec_id = CODEC_ID_MP3;
+        else if (strncmp(fmt-&gt;name, &quot;ac3&quot;, 3) == 0)
+            st-&gt;codec-&gt;codec_id = CODEC_ID_AC3;
+    }
+    return !!fmt;
+}
+
+unsigned int codec_get_tag(const AVCodecTag *tags, int id)
+{
+    while (tags-&gt;id != CODEC_ID_NONE) {
+        if (tags-&gt;id == id)
+            return tags-&gt;tag;
+        tags++;
+    }
+    return 0;
+}
+
+enum CodecID codec_get_id(const AVCodecTag *tags, unsigned int tag)
+{
+    while (tags-&gt;id != CODEC_ID_NONE) {
+        if(   toupper((tag &gt;&gt; 0)&amp;0xFF) == toupper((tags-&gt;tag &gt;&gt; 0)&amp;0xFF)
+           &amp;&amp; toupper((tag &gt;&gt; 8)&amp;0xFF) == toupper((tags-&gt;tag &gt;&gt; 8)&amp;0xFF)
+           &amp;&amp; toupper((tag &gt;&gt;16)&amp;0xFF) == toupper((tags-&gt;tag &gt;&gt;16)&amp;0xFF)
+           &amp;&amp; toupper((tag &gt;&gt;24)&amp;0xFF) == toupper((tags-&gt;tag &gt;&gt;24)&amp;0xFF))
+            return tags-&gt;id;
+        tags++;
+    }
+    return CODEC_ID_NONE;
+}
+
+unsigned int av_codec_get_tag(const AVCodecTag *tags[4], enum CodecID id)
+{
+    int i;
+    for(i=0; tags &amp;&amp; tags[i]; i++){
+        int tag= codec_get_tag(tags[i], id);
+        if(tag) return tag;
+    }
+    return 0;
+}
+
+enum CodecID av_codec_get_id(const AVCodecTag *tags[4], unsigned int tag)
+{
+    int i;
+    for(i=0; tags &amp;&amp; tags[i]; i++){
+        enum CodecID id= codec_get_id(tags[i], tag);
+        if(id!=CODEC_ID_NONE) return id;
+    }
+    return CODEC_ID_NONE;
+}
+
 /* absolute maximum size we read until we abort */
 #define MAX_READ_SIZE        5000000
 
-/* maximum duration until we stop analysing the stream */
-#define MAX_STREAM_DURATION  ((int)(AV_TIME_BASE * 3.0))
-
 #define MAX_STD_TIMEBASES (60*12+5)
 static int get_std_framerate(int i){
     if(i&lt;60*12) return i*1001;
     else        return ((int[]){24,30,60,12,15})[i-60*12]*1000*12;
 }
 
-/**
- * Read the beginning of a media file to get stream information. This
- * is useful for file formats with no headers such as MPEG. This
- * function also compute the real frame rate in case of mpeg2 repeat
- * frame mode.
- *
- * @param ic media file handle
- * @return &gt;=0 if OK. AVERROR_xxx if error.
- * @todo let user decide somehow what information is needed so we dont waste time geting stuff the user doesnt need
- */
 int av_find_stream_info(AVFormatContext *ic)
 {
     int i, count, ret, read_size, j;
@@ -1784,8 +1717,16 @@
     AVPacketList *pktl=NULL, **ppktl;
     int64_t last_dts[MAX_STREAMS];
     int duration_count[MAX_STREAMS]={0};
-    double duration_error[MAX_STREAMS][MAX_STD_TIMEBASES]={{0}}; //FIXME malloc()?
+    double (*duration_error)[MAX_STD_TIMEBASES];
+    offset_t old_offset = url_ftell(&amp;ic-&gt;pb);
+    int64_t codec_info_duration[MAX_STREAMS]={0};
+    int codec_info_nb_frames[MAX_STREAMS]={0};
+    AVProbeData probe_data[MAX_STREAMS];
+    int codec_identified[MAX_STREAMS]={0};
 
+    duration_error = av_mallocz(MAX_STREAMS * sizeof(*duration_error));
+    if (!duration_error) return AVERROR_NOMEM;
+
     for(i=0;i&lt;ic-&gt;nb_streams;i++) {
         st = ic-&gt;streams[i];
         if(st-&gt;codec-&gt;codec_type == CODEC_TYPE_VIDEO){
@@ -1797,7 +1738,7 @@
         //only for the split stuff
         if (!st-&gt;parser) {
             st-&gt;parser = av_parser_init(st-&gt;codec-&gt;codec_id);
-            if(st-&gt;need_parsing == 2 &amp;&amp; st-&gt;parser){
+            if(st-&gt;need_parsing == AVSTREAM_PARSE_HEADERS &amp;&amp; st-&gt;parser){
                 st-&gt;parser-&gt;flags |= PARSER_FLAG_COMPLETE_FRAMES;
             }
         }
@@ -1807,6 +1748,7 @@
         last_dts[i]= AV_NOPTS_VALUE;
     }
 
+    memset(probe_data, 0, sizeof(probe_data));
     count = 0;
     read_size = 0;
     ppktl = &amp;ic-&gt;packet_buffer;
@@ -1817,11 +1759,14 @@
             if (!has_codec_parameters(st-&gt;codec))
                 break;
             /* variable fps and no guess at the real fps */
-            if(   st-&gt;codec-&gt;time_base.den &gt;= 101LL*st-&gt;codec-&gt;time_base.num
+            if(   (st-&gt;codec-&gt;time_base.den &gt;= 101LL*st-&gt;codec-&gt;time_base.num || st-&gt;codec-&gt;codec_id == CODEC_ID_MPEG2VIDEO)
                &amp;&amp; duration_count[i]&lt;20 &amp;&amp; st-&gt;codec-&gt;codec_type == CODEC_TYPE_VIDEO)
                 break;
             if(st-&gt;parser &amp;&amp; st-&gt;parser-&gt;parser-&gt;split &amp;&amp; !st-&gt;codec-&gt;extradata)
                 break;
+            if (st-&gt;codec-&gt;codec_type == CODEC_TYPE_AUDIO &amp;&amp;
+                st-&gt;codec-&gt;codec_id == CODEC_ID_NONE)
+                break;
         }
         if (i == ic-&gt;nb_streams) {
             /* NOTE: if the format has no header, then we need to read
@@ -1880,10 +1825,10 @@
         read_size += pkt-&gt;size;
 
         st = ic-&gt;streams[pkt-&gt;stream_index];
-        if(st-&gt;codec_info_nb_frames&gt;1) //FIXME move codec_info_nb_frames and codec_info_duration from AVStream into this func
-            st-&gt;codec_info_duration += pkt-&gt;duration;
+        if(codec_info_nb_frames[st-&gt;index]&gt;1)
+            codec_info_duration[st-&gt;index] += pkt-&gt;duration;
         if (pkt-&gt;duration != 0)
-            st-&gt;codec_info_nb_frames++;
+            codec_info_nb_frames[st-&gt;index]++;
 
         {
             int index= pkt-&gt;stream_index;
@@ -1896,7 +1841,7 @@
 //                if(st-&gt;codec-&gt;codec_type == CODEC_TYPE_VIDEO)
 //                    av_log(NULL, AV_LOG_ERROR, &quot;%f\n&quot;, dur);
                 if(duration_count[index] &lt; 2)
-                    memset(duration_error, 0, sizeof(duration_error));
+                    memset(duration_error, 0, MAX_STREAMS * sizeof(*duration_error));
                 for(i=1; i&lt;MAX_STD_TIMEBASES; i++){
                     int framerate= get_std_framerate(i);
                     int ticks= lrintf(dur*framerate/(1001*12));
@@ -1904,12 +1849,16 @@
                     duration_error[index][i] += error*error;
                 }
                 duration_count[index]++;
-
-                if(st-&gt;codec_info_nb_frames == 0 &amp;&amp; 0)
-                    st-&gt;codec_info_duration += duration;
             }
             if(last == AV_NOPTS_VALUE || duration_count[index]&lt;=1)
                 last_dts[pkt-&gt;stream_index]= pkt-&gt;dts;
+
+            if (st-&gt;codec-&gt;codec_id == CODEC_ID_NONE) {
+                AVProbeData *pd = &amp;(probe_data[st-&gt;index]);
+                pd-&gt;buf = av_realloc(pd-&gt;buf, pd-&gt;buf_size+pkt-&gt;size);
+                memcpy(pd-&gt;buf+pd-&gt;buf_size, pkt-&gt;data, pkt-&gt;size);
+                pd-&gt;buf_size += pkt-&gt;size;
+            }
         }
         if(st-&gt;parser &amp;&amp; st-&gt;parser-&gt;parser-&gt;split &amp;&amp; !st-&gt;codec-&gt;extradata){
             int i= st-&gt;parser-&gt;parser-&gt;split(st-&gt;codec, pkt-&gt;data, pkt-&gt;size);
@@ -1942,7 +1891,7 @@
              (st-&gt;codec-&gt;codec_id == CODEC_ID_MPEG4 &amp;&amp; !st-&gt;need_parsing))*/)
             try_decode_frame(st, pkt-&gt;data, pkt-&gt;size);
 
-        if (av_rescale_q(st-&gt;codec_info_duration, st-&gt;time_base, AV_TIME_BASE_Q) &gt;= MAX_STREAM_DURATION) {
+        if (st-&gt;time_base.den &gt; 0 &amp;&amp; av_rescale_q(codec_info_duration[st-&gt;index], st-&gt;time_base, AV_TIME_BASE_Q) &gt;= ic-&gt;max_analyze_duration) {
             break;
         }
         count++;
@@ -1988,10 +1937,29 @@
                     st-&gt;r_frame_rate.den = st-&gt;time_base.num;
                 }
             }
+        }else if(st-&gt;codec-&gt;codec_type == CODEC_TYPE_AUDIO) {
+            if (st-&gt;codec-&gt;codec_id == CODEC_ID_NONE &amp;&amp; probe_data[st-&gt;index].buf_size &gt; 0) {
+                codec_identified[st-&gt;index] = set_codec_from_probe_data(st, &amp;(probe_data[st-&gt;index]), 0);
+                if (codec_identified[st-&gt;index]) {
+                    st-&gt;need_parsing = AVSTREAM_PARSE_FULL;
+                }
+            }
+            if(!st-&gt;codec-&gt;bits_per_sample)
+                st-&gt;codec-&gt;bits_per_sample= av_get_bits_per_sample(st-&gt;codec-&gt;codec_id);
         }
     }
 
-    av_estimate_timings(ic);
+    av_estimate_timings(ic, old_offset);
+
+    for(i=0;i&lt;ic-&gt;nb_streams;i++) {
+        st = ic-&gt;streams[i];
+        if (codec_identified[st-&gt;index]) {
+            av_read_frame_flush(ic);
+            av_seek_frame(ic, st-&gt;index, 0.0, 0);
+            url_fseek(&amp;ic-&gt;pb, ic-&gt;data_offset, SEEK_SET);
+        }
+    }
+
 #if 0
     /* correct DTS for b frame streams with no timestamps */
     for(i=0;i&lt;ic-&gt;nb_streams;i++) {
@@ -2016,15 +1984,17 @@
         }
     }
 #endif
+
+    av_free(duration_error);
+    for(i=0;i&lt;MAX_STREAMS;i++){
+        av_freep(&amp;(probe_data[i].buf));
+    }
+
     return ret;
 }
 
 /*******************************************************/
 
-/**
- * start playing a network based stream (e.g. RTSP stream) at the
- * current position
- */
 int av_read_play(AVFormatContext *s)
 {
     if (!s-&gt;iformat-&gt;read_play)
@@ -2032,11 +2002,6 @@
     return s-&gt;iformat-&gt;read_play(s);
 }
 
-/**
- * Pause a network based stream (e.g. RTSP stream).
- *
- * Use av_read_play() to resume it.
- */
 int av_read_pause(AVFormatContext *s)
 {
     if (!s-&gt;iformat-&gt;read_pause)
@@ -2044,11 +2009,6 @@
     return s-&gt;iformat-&gt;read_pause(s);
 }
 
-/**
- * Close a media file (but not its codecs).
- *
- * @param s media file handle
- */
 void av_close_input_file(AVFormatContext *s)
 {
     int i, must_open_file;
@@ -2083,16 +2043,6 @@
     av_free(s);
 }
 
-/**
- * Add a new stream to a media file.
- *
- * Can only be called in the read_header() function. If the flag
- * AVFMTCTX_NOHEADER is in the format context, then new streams
- * can be added in read_packet too.
- *
- * @param s media file handle
- * @param id file format dependent stream id
- */
 AVStream *av_new_stream(AVFormatContext *s, int id)
 {
     AVStream *st;
@@ -2148,13 +2098,6 @@
     return 0;
 }
 
-/**
- * allocate the stream private data and write the stream header to an
- * output media file
- *
- * @param s media file handle
- * @return 0 if OK. AVERROR_xxx if error.
- */
 int av_write_header(AVFormatContext *s)
 {
     int ret, i;
@@ -2182,6 +2125,17 @@
             }
             break;
         }
+
+        if(s-&gt;oformat-&gt;codec_tag){
+            if(st-&gt;codec-&gt;codec_tag){
+                //FIXME
+                //check that tag + id is in the table
+                //if neither is in the table -&gt; ok
+                //if tag is in the table with another id -&gt; FAIL
+                //if id is in the table with another tag -&gt; FAIL unless strict &lt; ?
+            }else
+                st-&gt;codec-&gt;codec_tag= av_codec_get_tag(s-&gt;oformat-&gt;codec_tag, st-&gt;codec-&gt;codec_id);
+        }
     }
 
     if (!s-&gt;priv_data &amp;&amp; s-&gt;oformat-&gt;priv_data_size &gt; 0) {
@@ -2301,15 +2255,6 @@
         pkt-&gt;dts &amp;= pts_mask;
 }
 
-/**
- * Write a packet to an output media file.
- *
- * The packet shall contain one audio or video frame.
- *
- * @param s media file handle
- * @param pkt the packet, which contains the stream_index, buf/buf_size, dts/pts, ...
- * @return &lt; 0 if error, = 0 if OK, 1 if end of stream wanted.
- */
 int av_write_frame(AVFormatContext *s, AVPacket *pkt)
 {
     int ret;
@@ -2326,20 +2271,6 @@
     return ret;
 }
 
-/**
- * Interleave a packet per DTS in an output media file.
- *
- * Packets with pkt-&gt;destruct == av_destruct_packet will be freed inside this function,
- * so they cannot be used after it, note calling av_free_packet() on them is still safe.
- *
- * @param s media file handle
- * @param out the interleaved packet will be output here
- * @param in the input packet
- * @param flush 1 if no further packets are available as input and all
- *              remaining packets should be output
- * @return 1 if a packet was output, 0 if no packet could be output,
- *         &lt; 0 if an error occured
- */
 int av_interleave_packet_per_dts(AVFormatContext *s, AVPacket *out, AVPacket *pkt, int flush){
     AVPacketList *pktl, **next_point, *this_pktl;
     int stream_count=0;
@@ -2409,20 +2340,6 @@
         return av_interleave_packet_per_dts(s, out, in, flush);
 }
 
-/**
- * Writes a packet to an output media file ensuring correct interleaving.
- *
- * The packet must contain one audio or video frame.
- * If the packets are already correctly interleaved the application should
- * call av_write_frame() instead as its slightly faster, its also important
- * to keep in mind that completly non interleaved input will need huge amounts
- * of memory to interleave with this, so its prefereable to interleave at the
- * demuxer level
- *
- * @param s media file handle
- * @param pkt the packet, which contains the stream_index, buf/buf_size, dts/pts, ...
- * @return &lt; 0 if error, = 0 if OK, 1 if end of stream wanted.
- */
 int av_interleaved_write_frame(AVFormatContext *s, AVPacket *pkt){
     AVStream *st= s-&gt;streams[ pkt-&gt;stream_index];
 
@@ -2456,13 +2373,6 @@
     }
 }
 
-/**
- * @brief Write the stream trailer to an output media file and
- *        free the file private data.
- *
- * @param s media file handle
- * @return 0 if OK. AVERROR_xxx if error.
- */
 int av_write_trailer(AVFormatContext *s)
 {
     int ret, i;
@@ -2574,118 +2484,20 @@
     }
 }
 
-typedef struct {
-    const char *abv;
-    int width, height;
-    int frame_rate, frame_rate_base;
-} AbvEntry;
-
-static AbvEntry frame_abvs[] = {
-    { &quot;ntsc&quot;,      720, 480, 30000, 1001 },
-    { &quot;pal&quot;,       720, 576,    25,    1 },
-    { &quot;qntsc&quot;,     352, 240, 30000, 1001 }, /* VCD compliant ntsc */
-    { &quot;qpal&quot;,      352, 288,    25,    1 }, /* VCD compliant pal */
-    { &quot;sntsc&quot;,     640, 480, 30000, 1001 }, /* square pixel ntsc */
-    { &quot;spal&quot;,      768, 576,    25,    1 }, /* square pixel pal */
-    { &quot;film&quot;,      352, 240,    24,    1 },
-    { &quot;ntsc-film&quot;, 352, 240, 24000, 1001 },
-    { &quot;sqcif&quot;,     128,  96,     0,    0 },
-    { &quot;qcif&quot;,      176, 144,     0,    0 },
-    { &quot;cif&quot;,       352, 288,     0,    0 },
-    { &quot;4cif&quot;,      704, 576,     0,    0 },
-};
-
-/**
- * parses width and height out of string str.
- */
 int parse_image_size(int *width_ptr, int *height_ptr, const char *str)
 {
-    int i;
-    int n = sizeof(frame_abvs) / sizeof(AbvEntry);
-    const char *p;
-    int frame_width = 0, frame_height = 0;
-
-    for(i=0;i&lt;n;i++) {
-        if (!strcmp(frame_abvs[i].abv, str)) {
-            frame_width = frame_abvs[i].width;
-            frame_height = frame_abvs[i].height;
-            break;
-        }
-    }
-    if (i == n) {
-        p = str;
-        frame_width = strtol(p, (char **)&amp;p, 10);
-        if (*p)
-            p++;
-        frame_height = strtol(p, (char **)&amp;p, 10);
-    }
-    if (frame_width &lt;= 0 || frame_height &lt;= 0)
-        return -1;
-    *width_ptr = frame_width;
-    *height_ptr = frame_height;
-    return 0;
+    return av_parse_video_frame_size(width_ptr, height_ptr, str);
 }
 
-/**
- * Converts frame rate from string to a fraction.
- *
- * First we try to get an exact integer or fractional frame rate.
- * If this fails we convert the frame rate to a double and return
- * an approximate fraction using the DEFAULT_FRAME_RATE_BASE.
- */
-int parse_frame_rate(int *frame_rate, int *frame_rate_base, const char *arg)
+int parse_frame_rate(int *frame_rate_num, int *frame_rate_den, const char *arg)
 {
-    int i;
-    char* cp;
-
-    /* First, we check our abbreviation table */
-    for (i = 0; i &lt; sizeof(frame_abvs)/sizeof(*frame_abvs); ++i)
-         if (!strcmp(frame_abvs[i].abv, arg)) {
-             *frame_rate = frame_abvs[i].frame_rate;
-             *frame_rate_base = frame_abvs[i].frame_rate_base;
-             return 0;
-         }
-
-    /* Then, we try to parse it as fraction */
-    cp = strchr(arg, '/');
-    if (!cp)
-        cp = strchr(arg, ':');
-    if (cp) {
-        char* cpp;
-        *frame_rate = strtol(arg, &amp;cpp, 10);
-        if (cpp != arg || cpp == cp)
-            *frame_rate_base = strtol(cp+1, &amp;cpp, 10);
-        else
-           *frame_rate = 0;
-    }
-    else {
-        /* Finally we give up and parse it as double */
-        AVRational time_base = av_d2q(strtod(arg, 0), DEFAULT_FRAME_RATE_BASE);
-        *frame_rate_base = time_base.den;
-        *frame_rate = time_base.num;
-    }
-    if (!*frame_rate || !*frame_rate_base)
-        return -1;
-    else
-        return 0;
+    AVRational frame_rate;
+    int ret = av_parse_video_frame_rate(&amp;frame_rate, arg);
+    *frame_rate_num= frame_rate.num;
+    *frame_rate_den= frame_rate.den;
+    return ret;
 }
 
-/**
- * Converts date string to number of seconds since Jan 1st, 1970.
- *
- * @code
- * Syntax:
- * - If not a duration:
- *  [{YYYY-MM-DD|YYYYMMDD}]{T| }{HH[:MM[:SS[.m...]]][Z]|HH[MM[SS[.m...]]][Z]}
- * Time is localtime unless Z is suffixed to the end. In this case GMT
- * Return the date in micro seconds since 1970
- *
- * - If a duration:
- *  HH[:MM[:SS[.m...]]]
- *  S+[.m...]
- * @endcode
- */
-#ifndef CONFIG_WINCE
 int64_t parse_date(const char *datestr, int duration)
 {
     const char *p;
@@ -2793,14 +2605,7 @@
     }
     return negative ? -t : t;
 }
-#endif /* CONFIG_WINCE */
 
-/**
- * Attempts to find a specific tag in a URL.
- *
- * syntax: '?tag1=val1&amp;tag2=val2...'. Little URL decoding is done.
- * Return 1 if found.
- */
 int find_info_tag(char *arg, int arg_size, const char *tag1, const char *info)
 {
     const char *p;
@@ -2840,18 +2645,6 @@
     return 0;
 }
 
-/**
- * Returns in 'buf' the path with '%d' replaced by number.
-
- * Also handles the '%0nd' format where 'n' is the total number
- * of digits and '%%'.
- *
- * @param buf destination buffer
- * @param buf_size destination buffer size
- * @param path numbered sequence string
- * @number frame number
- * @return 0 if OK, -1 if format error.
- */
 int av_get_frame_filename(char *buf, int buf_size,
                           const char *path, int number)
 {
@@ -2907,68 +2700,80 @@
     return -1;
 }
 
-/**
- * Print  nice hexa dump of a buffer
- * @param f stream for output
- * @param buf buffer
- * @param size buffer size
- */
-void av_hex_dump(FILE *f, uint8_t *buf, int size)
+static void hex_dump_internal(void *avcl, FILE *f, int level, uint8_t *buf, int size)
 {
     int len, i, j, c;
+#define PRINT(...) do { if (!f) av_log(avcl, level, __VA_ARGS__); else fprintf(f, __VA_ARGS__); } while(0)
 
     for(i=0;i&lt;size;i+=16) {
         len = size - i;
         if (len &gt; 16)
             len = 16;
-        fprintf(f, &quot;%08x &quot;, i);
+        PRINT(&quot;%08x &quot;, i);
         for(j=0;j&lt;16;j++) {
             if (j &lt; len)
-                fprintf(f, &quot; %02x&quot;, buf[i+j]);
+                PRINT(&quot; %02x&quot;, buf[i+j]);
             else
-                fprintf(f, &quot;   &quot;);
+                PRINT(&quot;   &quot;);
         }
-        fprintf(f, &quot; &quot;);
+        PRINT(&quot; &quot;);
         for(j=0;j&lt;len;j++) {
             c = buf[i+j];
             if (c &lt; ' ' || c &gt; '~')
                 c = '.';
-            fprintf(f, &quot;%c&quot;, c);
+            PRINT(&quot;%c&quot;, c);
         }
-        fprintf(f, &quot;\n&quot;);
+        PRINT(&quot;\n&quot;);
     }
+#undef PRINT
 }
 
-/**
- * Print on 'f' a nice dump of a packet
- * @param f stream for output
- * @param pkt packet to dump
- * @param dump_payload true if the payload must be displayed too
- */
+void av_hex_dump(FILE *f, uint8_t *buf, int size)
+{
+    hex_dump_internal(NULL, f, 0, buf, size);
+}
+
+void av_hex_dump_log(void *avcl, int level, uint8_t *buf, int size)
+{
+    hex_dump_internal(avcl, NULL, level, buf, size);
+}
+
  //FIXME needs to know the time_base
-void av_pkt_dump(FILE *f, AVPacket *pkt, int dump_payload)
+static void pkt_dump_internal(void *avcl, FILE *f, int level, AVPacket *pkt, int dump_payload)
 {
-    fprintf(f, &quot;stream #%d:\n&quot;, pkt-&gt;stream_index);
-    fprintf(f, &quot;  keyframe=%d\n&quot;, ((pkt-&gt;flags &amp; PKT_FLAG_KEY) != 0));
-    fprintf(f, &quot;  duration=%0.3f\n&quot;, (double)pkt-&gt;duration / AV_TIME_BASE);
+#define PRINT(...) do { if (!f) av_log(avcl, level, __VA_ARGS__); else fprintf(f, __VA_ARGS__); } while(0)
+    PRINT(&quot;stream #%d:\n&quot;, pkt-&gt;stream_index);
+    PRINT(&quot;  keyframe=%d\n&quot;, ((pkt-&gt;flags &amp; PKT_FLAG_KEY) != 0));
+    PRINT(&quot;  duration=%0.3f\n&quot;, (double)pkt-&gt;duration / AV_TIME_BASE);
     /* DTS is _always_ valid after av_read_frame() */
-    fprintf(f, &quot;  dts=&quot;);
+    PRINT(&quot;  dts=&quot;);
     if (pkt-&gt;dts == AV_NOPTS_VALUE)
-        fprintf(f, &quot;N/A&quot;);
+        PRINT(&quot;N/A&quot;);
     else
-        fprintf(f, &quot;%0.3f&quot;, (double)pkt-&gt;dts / AV_TIME_BASE);
+        PRINT(&quot;%0.3f&quot;, (double)pkt-&gt;dts / AV_TIME_BASE);
     /* PTS may be not known if B frames are present */
-    fprintf(f, &quot;  pts=&quot;);
+    PRINT(&quot;  pts=&quot;);
     if (pkt-&gt;pts == AV_NOPTS_VALUE)
-        fprintf(f, &quot;N/A&quot;);
+        PRINT(&quot;N/A&quot;);
     else
-        fprintf(f, &quot;%0.3f&quot;, (double)pkt-&gt;pts / AV_TIME_BASE);
-    fprintf(f, &quot;\n&quot;);
-    fprintf(f, &quot;  size=%d\n&quot;, pkt-&gt;size);
+        PRINT(&quot;%0.3f&quot;, (double)pkt-&gt;pts / AV_TIME_BASE);
+    PRINT(&quot;\n&quot;);
+    PRINT(&quot;  size=%d\n&quot;, pkt-&gt;size);
+#undef PRINT
     if (dump_payload)
         av_hex_dump(f, pkt-&gt;data, pkt-&gt;size);
 }
 
+void av_pkt_dump(FILE *f, AVPacket *pkt, int dump_payload)
+{
+    pkt_dump_internal(NULL, f, 0, pkt, dump_payload);
+}
+
+void av_pkt_dump_log(void *avcl, int level, AVPacket *pkt, int dump_payload)
+{
+    pkt_dump_internal(avcl, NULL, level, pkt, dump_payload);
+}
+
 void url_split(char *proto, int proto_size,
                char *authorization, int authorization_size,
                char *hostname, int hostname_size,
@@ -3037,18 +2842,9 @@
     }
     if (port_ptr)
         *port_ptr = port;
-    pstrcpy(path, path_size, p);
+    av_strlcpy(path, p, path_size);
 }
 
-/**
- * Set the pts for a given stream.
- *
- * @param s stream
- * @param pts_wrap_bits number of bits effectively used by the pts
- *        (used for wrap control, 33 is the value for MPEG)
- * @param pts_num numerator to convert to seconds (MPEG: 1)
- * @param pts_den denominator to convert to seconds (MPEG: 90000)
- */
 void av_set_pts_info(AVStream *s, int pts_wrap_bits,
                      int pts_num, int pts_den)
 {

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/wav.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/wav.c	2007-07-16 16:39:52 UTC (rev 3382)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/wav.c	2007-07-16 17:44:22 UTC (rev 3383)
@@ -25,6 +25,9 @@
 typedef struct {
     offset_t data;
     offset_t data_end;
+    int64_t minpts;
+    int64_t maxpts;
+    int last_duration;
 } WAVContext;
 
 #ifdef CONFIG_MUXERS
@@ -32,7 +35,7 @@
 {
     WAVContext *wav = s-&gt;priv_data;
     ByteIOContext *pb = &amp;s-&gt;pb;
-    offset_t fmt;
+    offset_t fmt, fact;
 
     put_tag(pb, &quot;RIFF&quot;);
     put_le32(pb, 0); /* file length */
@@ -46,7 +49,16 @@
     }
     end_tag(pb, fmt);
 
+    if(s-&gt;streams[0]-&gt;codec-&gt;codec_tag != 0x01 /* hence for all other than PCM */
+       &amp;&amp; !url_is_streamed(&amp;s-&gt;pb)) {
+        fact = start_tag(pb, &quot;fact&quot;);
+        put_le32(pb, 0);
+        end_tag(pb, fact);
+    }
+
     av_set_pts_info(s-&gt;streams[0], 64, 1, s-&gt;streams[0]-&gt;codec-&gt;sample_rate);
+    wav-&gt;maxpts = wav-&gt;last_duration = 0;
+    wav-&gt;minpts = INT64_MAX;
 
     /* data header */
     wav-&gt;data = start_tag(pb, &quot;data&quot;);
@@ -59,7 +71,14 @@
 static int wav_write_packet(AVFormatContext *s, AVPacket *pkt)
 {
     ByteIOContext *pb = &amp;s-&gt;pb;
+    WAVContext *wav = s-&gt;priv_data;
     put_buffer(pb, pkt-&gt;data, pkt-&gt;size);
+    if(pkt-&gt;pts != AV_NOPTS_VALUE) {
+        wav-&gt;minpts = FFMIN(wav-&gt;minpts, pkt-&gt;pts);
+        wav-&gt;maxpts = FFMAX(wav-&gt;maxpts, pkt-&gt;pts);
+        wav-&gt;last_duration = pkt-&gt;duration;
+    } else
+        av_log(s, AV_LOG_ERROR, &quot;wav_write_packet: NOPTS\n&quot;);
     return 0;
 }
 
@@ -79,6 +98,18 @@
         url_fseek(pb, file_size, SEEK_SET);
 
         put_flush_packet(pb);
+
+        if(s-&gt;streams[0]-&gt;codec-&gt;codec_tag != 0x01) {
+            /* Update num_samps in fact chunk */
+            int number_of_samples;
+            number_of_samples = av_rescale(wav-&gt;maxpts - wav-&gt;minpts + wav-&gt;last_duration,
+                                           s-&gt;streams[0]-&gt;codec-&gt;sample_rate * (int64_t)s-&gt;streams[0]-&gt;time_base.num,
+                                           s-&gt;streams[0]-&gt;time_base.den);
+            url_fseek(pb, wav-&gt;data-12, SEEK_SET);
+            put_le32(pb, number_of_samples);
+            url_fseek(pb, file_size, SEEK_SET);
+            put_flush_packet(pb);
+        }
     }
     return 0;
 }
@@ -148,7 +179,7 @@
         return AVERROR_NOMEM;
 
     get_wav_header(pb, st-&gt;codec, size);
-    st-&gt;need_parsing = 1;
+    st-&gt;need_parsing = AVSTREAM_PARSE_FULL;
 
     av_set_pts_info(st, 64, 1, st-&gt;codec-&gt;sample_rate);
 
@@ -188,13 +219,11 @@
         size = (size / st-&gt;codec-&gt;block_align) * st-&gt;codec-&gt;block_align;
     }
     size= FFMIN(size, left);
-    if (av_new_packet(pkt, size))
+    ret= av_get_packet(&amp;s-&gt;pb, pkt, size);
+    if (ret &lt;= 0)
         return AVERROR_IO;
     pkt-&gt;stream_index = 0;
 
-    ret = get_buffer(&amp;s-&gt;pb, pkt-&gt;data, pkt-&gt;size);
-    if (ret &lt; 0)
-        av_free_packet(pkt);
     /* note: we need to modify the packet size here to handle the last
        packet */
     pkt-&gt;size = ret;
@@ -235,7 +264,8 @@
     wav_read_packet,
     wav_read_close,
     wav_read_seek,
-    .codec_tag= {codec_wav_tags},
+    .flags= AVFMT_GENERIC_INDEX,
+    .codec_tag= (const AVCodecTag*[]){codec_wav_tags, 0},
 };
 #endif
 #ifdef CONFIG_WAV_MUXER
@@ -250,6 +280,6 @@
     wav_write_header,
     wav_write_packet,
     wav_write_trailer,
-    .codec_tag= {codec_wav_tags},
+    .codec_tag= (const AVCodecTag*[]){codec_wav_tags, 0},
 };
 #endif


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000659.html">[Avidemux-svn-commit] r3382 -	branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_asf
</A></li>
	<LI>Next message: <A HREF="000661.html">[Avidemux-svn-commit] r3384 -	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#660">[ date ]</a>
              <a href="thread.html#660">[ thread ]</a>
              <a href="subject.html#660">[ subject ]</a>
              <a href="author.html#660">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
