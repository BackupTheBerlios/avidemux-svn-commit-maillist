<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r4106 - in branches/avidemux_2.4_branch: .	avidemux/ADM_audiocodec avidemux/ADM_libraries/ADM_lavcodec
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2008-June/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r4106%20-%20in%20branches/avidemux_2.4_branch%3A%20.%0A%09avidemux/ADM_audiocodec%20avidemux/ADM_libraries/ADM_lavcodec&In-Reply-To=%3C200806161543.m5GFhUOV032616%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001361.html">
   <LINK REL="Next"  HREF="001363.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r4106 - in branches/avidemux_2.4_branch: .	avidemux/ADM_audiocodec avidemux/ADM_libraries/ADM_lavcodec</H1>
    <B>gruntster at mail.berlios.de</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r4106%20-%20in%20branches/avidemux_2.4_branch%3A%20.%0A%09avidemux/ADM_audiocodec%20avidemux/ADM_libraries/ADM_lavcodec&In-Reply-To=%3C200806161543.m5GFhUOV032616%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r4106 - in branches/avidemux_2.4_branch: .	avidemux/ADM_audiocodec avidemux/ADM_libraries/ADM_lavcodec">gruntster at mail.berlios.de
       </A><BR>
    <I>Mon Jun 16 17:43:30 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001361.html">[Avidemux-svn-commit] r4105 - in	branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces:	ADM_GTK/ADM_dialog ADM_GTK/ADM_toolkit_gtk ADM_commonUI
</A></li>
        <LI>Next message: <A HREF="001363.html">[Avidemux-svn-commit] r4107 - in branches/avidemux_2.4_branch: .	avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk	avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1362">[ date ]</a>
              <a href="thread.html#1362">[ thread ]</a>
              <a href="subject.html#1362">[ subject ]</a>
              <a href="author.html#1362">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: gruntster
Date: 2008-06-16 17:43:11 +0200 (Mon, 16 Jun 2008)
New Revision: 4106

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/libamr.c
Removed:
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/amr.c
Modified:
   branches/avidemux_2.4_branch/ConfigureChecks.cmake
   branches/avidemux_2.4_branch/avidemux/ADM_audiocodec/ADM_codecwma.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/CMakeLists.txt
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/Makefile.am
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/ffconf.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/ffconf.h
   branches/avidemux_2.4_branch/config.h.cmake
Log:
[amrnb] fix regressions (r3385, r3473, r3598, r3612)

Modified: branches/avidemux_2.4_branch/ConfigureChecks.cmake
===================================================================
--- branches/avidemux_2.4_branch/ConfigureChecks.cmake	2008-06-16 12:13:43 UTC (rev 4105)
+++ branches/avidemux_2.4_branch/ConfigureChecks.cmake	2008-06-16 15:43:11 UTC (rev 4106)
@@ -456,7 +456,7 @@
 ENDIF (USE_LATE_BINDING)
 
 IF (USE_AMR_NB)
-	SET(CONFIG_AMR_NB 1)
+	SET(CONFIG_LIBAMR_NB 1)
 ENDIF (USE_AMR_NB)
 
 ########################################

Modified: branches/avidemux_2.4_branch/avidemux/ADM_audiocodec/ADM_codecwma.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_audiocodec/ADM_codecwma.cpp	2008-06-16 12:13:43 UTC (rev 4105)
+++ branches/avidemux_2.4_branch/avidemux/ADM_audiocodec/ADM_codecwma.cpp	2008-06-16 15:43:11 UTC (rev 4106)
@@ -235,6 +235,7 @@
         _tail+=nbIn;
         while(_tail-_head&gt;AMR_PACKET)
         {
+          pout=SCRATCH_PAD_SIZE;
           out=avcodec_decode_audio2(_context,(int16_t *)scratchPad,
                                    &amp;pout,_buffer+_head,_tail-_head);
                 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/CMakeLists.txt
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/CMakeLists.txt	2008-06-16 12:13:43 UTC (rev 4105)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/CMakeLists.txt	2008-06-16 15:43:11 UTC (rev 4106)
@@ -15,7 +15,7 @@
 		roqvideo.c 	xan.c 	rpza.c 	msrle.c 	msvideo1.c 	cinepak.c 	vqavideo.c 
 		idcinvideo.c 	smc.c 	flicvideo.c 	interplayvideo.c 	dpcm.c 	8bps.c vmdav.c 
 		truemotion1.c flac.c g726.c 	qtrle.c lcl.c 	snow.c  
-		rangecoder.c bitstream.c h264idct.c h261.c amr.c tscc.c 
+		rangecoder.c bitstream.c h264idct.c h261.c libamr.c tscc.c 
 		resample2.c pthread.c qdm2.c bitstream_filter.c eval.c 
 		vc1.c vc1dsp.c vp56.c  vp6.c vp5.c indeo2.c smacker.c  opt.c
                 fraps.c dnxhddata.h  dnxhddec.c

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/Makefile.am	2008-06-16 12:13:43 UTC (rev 4105)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/Makefile.am	2008-06-16 15:43:11 UTC (rev 4106)
@@ -54,7 +54,7 @@
 		roqvideo.c 	xan.c 	rpza.c 	msrle.c 	msvideo1.c 	cinepak.c 	vqavideo.c \
 		idcinvideo.c 	smc.c 	flicvideo.c 	interplayvideo.c 	dpcm.c 	8bps.c vmdav.c \
 		truemotion1.c flac.c g726.c 	qtrle.c lcl.c 	snow.c  \
-		rangecoder.c bitstream.c h264idct.c h261.c amr.c tscc.c \
+		rangecoder.c bitstream.c h264idct.c h261.c libamr.c tscc.c \
 		resample2.c pthread.c qdm2.c bitstream_filter.c eval.c \
 		vc1.c vc1dsp.c vp56.c vp56data.c vp6.c vp5.c indeo2.c indeo3.c  smacker.c  opt.c \
 		 fraps.c dnxhddata.h  dnxhddec.c	\
@@ -93,7 +93,7 @@
 adx.c     eval.c      kmvc.c       pnm.c    utils.c \
 alac.c      faac.c      lcl.c      pthread.c  vc1.c \
 allcodecs.c   faad.c      libgsm.c     qdm2.c   vcr1.c \
-amr.c     faandct.c     loco.c       qdrw.c   vmdav.c \
+libamr.c     faandct.c     loco.c       qdrw.c   vmdav.c \
 apiexample.c    fdctref.c     lzo.c      qpeg.c   vorbis.c \
 asv1.c      fft-test.c    mace.c       qtrle.c    vp3.c \
 avcodec.c     fft.c     mdct.c       ra144.c    vp3dsp.c \

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/amr.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/amr.c	2008-06-16 12:13:43 UTC (rev 4105)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/amr.c	2008-06-16 15:43:11 UTC (rev 4106)
@@ -1,699 +0,0 @@
-/*
- * AMR Audio decoder stub
- * Copyright (c) 2003 the ffmpeg project
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
- /*
-    This code implements amr-nb and amr-wb audio encoder/decoder through external reference
-    code from www.3gpp.org. The licence of the code from 3gpp is unclear so you
-    have to download the code separately. Two versions exists: One fixed-point
-    and one with floats. For some reason the float-encoder is significant faster
-    atleast on a P4 1.5GHz (0.9s instead of 9.9s on a 30s audio clip at MR102).
-    Both float and fixed point is supported for amr-nb, but only float for
-    amr-wb.
-
-    --AMR-NB--
-    The fixed-point (TS26.073) can be downloaded from:
-    <A HREF="http://www.3gpp.org/ftp/Specs/archive/26_series/26.073/26073-510.zip">http://www.3gpp.org/ftp/Specs/archive/26_series/26.073/26073-510.zip</A>
-    Extract the soure into ffmpeg/libavcodec/amr
-    To use the fixed version run &quot;./configure&quot; with &quot;--enable-amr_nb-fixed&quot;
-
-    The float version (default) can be downloaded from:
-    <A HREF="http://www.3gpp.org/ftp/Specs/archive/26_series/26.104/26104-510.zip">http://www.3gpp.org/ftp/Specs/archive/26_series/26.104/26104-510.zip</A>
-    Extract the soure into ffmpeg/libavcodec/amrnb
-
-    The specification for amr-nb can be found in TS 26.071
-    (<A HREF="http://www.3gpp.org/ftp/Specs/html-info/26071.htm">http://www.3gpp.org/ftp/Specs/html-info/26071.htm</A>) and some other
-    info at <A HREF="http://www.3gpp.org/ftp/Specs/html-info/26-series.htm">http://www.3gpp.org/ftp/Specs/html-info/26-series.htm</A>
-
-    --AMR-WB--
-    The reference code can be downloaded from:
-    <A HREF="http://www.3gpp.org/ftp/Specs/archive/26_series/26.204/26204-510.zip">http://www.3gpp.org/ftp/Specs/archive/26_series/26.204/26204-510.zip</A>
-    It should be extracted to &quot;libavcodec/amrwb_float&quot;. Enable it with
-    &quot;--enable-amr_wb&quot;.
-
-    The specification for amr-wb can be downloaded from:
-    <A HREF="http://www.3gpp.org/ftp/Specs/archive/26_series/26.171/26171-500.zip">http://www.3gpp.org/ftp/Specs/archive/26_series/26.171/26171-500.zip</A>
-
-    If someone want to use the fixed point version it can be downloaded
-    from: <A HREF="http://www.3gpp.org/ftp/Specs/archive/26_series/26.173/26173-571.zip">http://www.3gpp.org/ftp/Specs/archive/26_series/26.173/26173-571.zip</A>
-
- */
- /* MEANX */
-#include &quot;config.h&quot;
-#ifdef USE_AMR_NB
- /* MEANX */
-
-#include &quot;ADM_libraries/ADM_libwrapper/libwrapper_global.h&quot;
-#include &quot;avcodec.h&quot;
-
-#ifdef CONFIG_AMR_NB_FIXED
-
-#define MMS_IO
-
-#include &quot;amr/sp_dec.h&quot;
-#include &quot;amr/d_homing.h&quot;
-#include &quot;amr/typedef.h&quot;
-#include &quot;amr/sp_enc.h&quot;
-#include &quot;amr/sid_sync.h&quot;
-#include &quot;amr/e_homing.h&quot;
-
-#else
-#include &quot;amrnb/interf_dec.h&quot;
-#include &quot;amrnb/interf_enc.h&quot;
-#endif
-
-/* Common code for fixed and float version*/
-typedef struct AMR_bitrates
-{
-    int startrate;
-    int stoprate;
-    enum Mode mode;
-
-} AMR_bitrates;
-
-/* Match desired bitrate with closest one*/
-static enum Mode getBitrateMode(int bitrate)
-{
-    /* Adjusted so that all bitrates can be used from commandline where
-       only a multiple of 1000 can be specified*/
-    AMR_bitrates rates[]={ {0,4999,MR475}, //4
-                           {5000,5899,MR515},//5
-                           {5900,6699,MR59},//6
-                           {6700,7000,MR67},//7
-                           {7001,7949,MR74},//8
-                           {7950,9999,MR795},//9
-                           {10000,11999,MR102},//10
-                           {12000,64000,MR122},//12
-
-                         };
-    int i;
-    for(i=0;i&lt;8;i++)
-    {
-        if(rates[i].startrate&lt;=bitrate &amp;&amp; rates[i].stoprate&gt;=bitrate)
-        {
-            return(rates[i].mode);
-        }
-    }
-    /*Return highest possible*/
-    return(MR122);
-}
-
-static void amr_decode_fix_avctx(AVCodecContext * avctx)
-{
-    const int is_amr_wb = 1 + (avctx-&gt;codec_id == CODEC_ID_AMR_WB);
-
-    if(avctx-&gt;sample_rate == 0)
-    {
-        avctx-&gt;sample_rate = 8000 * is_amr_wb;
-    }
-
-    if(avctx-&gt;channels == 0)
-    {
-        avctx-&gt;channels = 1;
-    }
-
-    avctx-&gt;frame_size = 160 * is_amr_wb;
-}
-
-#ifdef CONFIG_AMR_NB_FIXED
-/* fixed point version*/
-/* frame size in serial bitstream file (frame type + serial stream + flags) */
-#define SERIAL_FRAMESIZE (1+MAX_SERIAL_SIZE+5)
-
-typedef struct AMRContext {
-    int frameCount;
-    Speech_Decode_FrameState *speech_decoder_state;
-    enum RXFrameType rx_type;
-    enum Mode mode;
-    Word16 reset_flag;
-    Word16 reset_flag_old;
-
-    enum Mode enc_bitrate;
-    Speech_Encode_FrameState *enstate;
-    sid_syncState *sidstate;
-    enum TXFrameType tx_frametype;
-
-
-} AMRContext;
-
-static int amr_nb_decode_init(AVCodecContext * avctx)
-{
-    AMRContext *s = avctx-&gt;priv_data;
-    s-&gt;frameCount=0;
-    s-&gt;speech_decoder_state=NULL;
-    s-&gt;rx_type = (enum RXFrameType)0;
-    s-&gt;mode= (enum Mode)0;
-    s-&gt;reset_flag=0;
-    s-&gt;reset_flag_old=1;
-
-    if(Speech_Decode_Frame_init(&amp;s-&gt;speech_decoder_state, &quot;Decoder&quot;))
-    {
-        av_log(avctx, AV_LOG_ERROR, &quot;Speech_Decode_Frame_init error\n&quot;);
-        return -1;
-    }
-
-    amr_decode_fix_avctx(avctx);
-
-    if(avctx-&gt;channels &gt; 1)
-    {
-        av_log(avctx, AV_LOG_ERROR, &quot;amr_nb: multichannel decoding not supported\n&quot;);
-        return -1;
-    }
-
-    return 0;
-}
-
-static int amr_nb_encode_init(AVCodecContext * avctx)
-{
-    AMRContext *s = avctx-&gt;priv_data;
-    s-&gt;frameCount=0;
-    s-&gt;speech_decoder_state=NULL;
-    s-&gt;rx_type = (enum RXFrameType)0;
-    s-&gt;mode= (enum Mode)0;
-    s-&gt;reset_flag=0;
-    s-&gt;reset_flag_old=1;
-
-    if(avctx-&gt;sample_rate!=8000)
-    {
-        av_log(avctx, AV_LOG_ERROR, &quot;Only 8000Hz sample rate supported\n&quot;);
-        return -1;
-    }
-
-    if(avctx-&gt;channels!=1)
-    {
-        av_log(avctx, AV_LOG_ERROR, &quot;Only mono supported\n&quot;);
-        return -1;
-    }
-
-    avctx-&gt;frame_size=160;
-    avctx-&gt;coded_frame= avcodec_alloc_frame();
-
-    if(Speech_Encode_Frame_init(&amp;s-&gt;enstate, 0, &quot;encoder&quot;) || sid_sync_init (&amp;s-&gt;sidstate))
-    {
-        av_log(avctx, AV_LOG_ERROR, &quot;Speech_Encode_Frame_init error\n&quot;);
-        return -1;
-    }
-
-    s-&gt;enc_bitrate=getBitrateMode(avctx-&gt;bit_rate);
-
-    return 0;
-}
-
-static int amr_nb_encode_close(AVCodecContext * avctx)
-{
-    AMRContext *s = avctx-&gt;priv_data;
-    Speech_Encode_Frame_exit(&amp;s-&gt;enstate);
-    sid_sync_exit (&amp;s-&gt;sidstate);
-    av_freep(&amp;avctx-&gt;coded_frame);
-    return 0;
-}
-
-static int amr_nb_decode_close(AVCodecContext * avctx)
-{
-    AMRContext *s = avctx-&gt;priv_data;
-    Speech_Decode_Frame_exit(&amp;s-&gt;speech_decoder_state);
-    return 0;
-}
-
-static int amr_nb_decode_frame(AVCodecContext * avctx,
-            void *data, int *data_size,
-            uint8_t * buf, int buf_size)
-{
-    AMRContext *s = avctx-&gt;priv_data;
-
-    uint8_t*amrData=buf;
-    int offset=0;
-
-    UWord8 toc, q, ft;
-
-    Word16 serial[SERIAL_FRAMESIZE];   /* coded bits */
-    Word16 *synth;
-    UWord8 *packed_bits;
-
-    static Word16 packed_size[16] = {12, 13, 15, 17, 19, 20, 26, 31, 5, 0, 0, 0, 0, 0, 0, 0};
-    int i;
-
-    //printf(&quot;amr_decode_frame data_size=%i buf=0x%X buf_size=%d frameCount=%d!!\n&quot;,*data_size,buf,buf_size,s-&gt;frameCount);
-
-    synth=data;
-
-//    while(offset&lt;buf_size)
-    {
-        toc=amrData[offset];
-        /* read rest of the frame based on ToC byte */
-        q  = (toc &gt;&gt; 2) &amp; 0x01;
-        ft = (toc &gt;&gt; 3) &amp; 0x0F;
-
-        //printf(&quot;offset=%d, packet_size=%d amrData= 0x%X %X %X %X\n&quot;,offset,packed_size[ft],amrData[offset],amrData[offset+1],amrData[offset+2],amrData[offset+3]);
-
-        offset++;
-
-        packed_bits=amrData+offset;
-
-        offset+=packed_size[ft];
-
-        //Unsort and unpack bits
-        s-&gt;rx_type = UnpackBits(q, ft, packed_bits, &amp;s-&gt;mode, &amp;serial[1]);
-
-        //We have a new frame
-        s-&gt;frameCount++;
-
-        if (s-&gt;rx_type == RX_NO_DATA)
-        {
-            s-&gt;mode = s-&gt;speech_decoder_state-&gt;prev_mode;
-        }
-        else {
-            s-&gt;speech_decoder_state-&gt;prev_mode = s-&gt;mode;
-        }
-
-        /* if homed: check if this frame is another homing frame */
-        if (s-&gt;reset_flag_old == 1)
-        {
-            /* only check until end of first subframe */
-            s-&gt;reset_flag = decoder_homing_frame_test_first(&amp;serial[1], s-&gt;mode);
-        }
-        /* produce encoder homing frame if homed &amp; input=decoder homing frame */
-        if ((s-&gt;reset_flag != 0) &amp;&amp; (s-&gt;reset_flag_old != 0))
-        {
-            for (i = 0; i &lt; L_FRAME; i++)
-            {
-                synth[i] = EHF_MASK;
-            }
-        }
-        else
-        {
-            /* decode frame */
-            Speech_Decode_Frame(s-&gt;speech_decoder_state, s-&gt;mode, &amp;serial[1], s-&gt;rx_type, synth);
-        }
-
-        //Each AMR-frame results in 160 16-bit samples
-        *data_size+=160*2;
-        synth+=160;
-
-        /* if not homed: check whether current frame is a homing frame */
-        if (s-&gt;reset_flag_old == 0)
-        {
-            /* check whole frame */
-            s-&gt;reset_flag = decoder_homing_frame_test(&amp;serial[1], s-&gt;mode);
-        }
-        /* reset decoder if current frame is a homing frame */
-        if (s-&gt;reset_flag != 0)
-        {
-            Speech_Decode_Frame_reset(s-&gt;speech_decoder_state);
-        }
-        s-&gt;reset_flag_old = s-&gt;reset_flag;
-
-    }
-    return offset;
-}
-
-
-static int amr_nb_encode_frame(AVCodecContext *avctx,
-                            unsigned char *frame/*out*/, int buf_size, void *data/*in*/)
-{
-    short serial_data[250] = {0};
-
-    AMRContext *s = avctx-&gt;priv_data;
-    int written;
-
-    s-&gt;reset_flag = encoder_homing_frame_test(data);
-
-    Speech_Encode_Frame(s-&gt;enstate, s-&gt;enc_bitrate, data, &amp;serial_data[1], &amp;s-&gt;mode);
-
-    /* add frame type and mode */
-    sid_sync (s-&gt;sidstate, s-&gt;mode, &amp;s-&gt;tx_frametype);
-
-    written = PackBits(s-&gt;mode, s-&gt;enc_bitrate, s-&gt;tx_frametype, &amp;serial_data[1], frame);
-
-    if (s-&gt;reset_flag != 0)
-    {
-        Speech_Encode_Frame_reset(s-&gt;enstate);
-        sid_sync_reset(s-&gt;sidstate);
-    }
-    return written;
-}
-
-
-#elif defined(CONFIG_AMR_NB) /* Float point version*/
-
-typedef struct AMRContext {
-    int frameCount;
-    void * decState;
-    int *enstate;
-    enum Mode enc_bitrate;
-} AMRContext;
-
-static int amr_nb_decode_init(AVCodecContext * avctx)
-{
-    AMRContext *s = avctx-&gt;priv_data;
-    s-&gt;frameCount=0;
-    s-&gt;decState=Decoder_Interface_initQT_TR_NOOP(getAmrnbWrapper());
-    if(!s-&gt;decState)
-    {
-        av_log(avctx, AV_LOG_ERROR, &quot;Decoder_Interface_init error\r\n&quot;);
-        return -1;
-    }
-
-    amr_decode_fix_avctx(avctx);
-
-    if(avctx-&gt;channels &gt; 1)
-    {
-        av_log(avctx, AV_LOG_ERROR, &quot;amr_nb: multichannel decoding not supported\n&quot;);
-        return -1;
-    }
-
-    return 0;
-}
-
-static int amr_nb_encode_init(AVCodecContext * avctx)
-{
-    AMRContext *s = avctx-&gt;priv_data;
-    s-&gt;frameCount=0;
-
-    if(avctx-&gt;sample_rate!=8000)
-    {
-        av_log(avctx, AV_LOG_ERROR, &quot;Only 8000Hz sample rate supported\n&quot;);
-        return -1;
-    }
-
-    if(avctx-&gt;channels!=1)
-    {
-        av_log(avctx, AV_LOG_ERROR, &quot;Only mono supported\n&quot;);
-        return -1;
-    }
-
-    avctx-&gt;frame_size=160;
-    avctx-&gt;coded_frame= avcodec_alloc_frame();
-
-    s-&gt;enstate=Encoder_Interface_initQT_TR_NOOP(getAmrnbWrapper(), 0);
-    if(!s-&gt;enstate)
-    {
-        av_log(avctx, AV_LOG_ERROR, &quot;Encoder_Interface_init error\n&quot;);
-        return -1;
-    }
-
-    s-&gt;enc_bitrate=getBitrateMode(avctx-&gt;bit_rate);
-
-    return 0;
-}
-
-static int amr_nb_decode_close(AVCodecContext * avctx)
-{
-    AMRContext *s = avctx-&gt;priv_data;
-    Decoder_Interface_exitQT_TR_NOOP(getAmrnbWrapper(), s-&gt;decState);
-    return 0;
-}
-
-static int amr_nb_encode_close(AVCodecContext * avctx)
-{
-    AMRContext *s = avctx-&gt;priv_data;
-    Encoder_Interface_exitQT_TR_NOOP(getAmrnbWrapper(), s-&gt;enstate);
-    av_freep(&amp;avctx-&gt;coded_frame);
-    return 0;
-}
-
-static int amr_nb_decode_frame(AVCodecContext * avctx,
-            void *data, int *data_size,
-            uint8_t * buf, int buf_size)
-{
-    AMRContext *s = (AMRContext*)avctx-&gt;priv_data;
-
-    uint8_t*amrData=buf;
-    static short block_size[16]={ 12, 13, 15, 17, 19, 20, 26, 31, 5, 0, 0, 0, 0, 0, 0, 0 };
-    enum Mode dec_mode;
-    int packet_size;
-
-    /* av_log(NULL,AV_LOG_DEBUG,&quot;amr_decode_frame buf=%p buf_size=%d frameCount=%d!!\n&quot;,buf,buf_size,s-&gt;frameCount); */
-
-    if(buf_size==0) {
-        /* nothing to do */
-        return 0;
-    }
-
-    dec_mode = (buf[0] &gt;&gt; 3) &amp; 0x000F;
-    packet_size = block_size[dec_mode]+1;
-
-    if(packet_size &gt; buf_size) {
-        av_log(avctx, AV_LOG_ERROR, &quot;amr frame too short (%u, should be %u)\n&quot;, buf_size, packet_size);
-        return -1;
-    }
-
-    s-&gt;frameCount++;
-    /* av_log(NULL,AV_LOG_DEBUG,&quot;packet_size=%d amrData= 0x%X %X %X %X\n&quot;,packet_size,amrData[0],amrData[1],amrData[2],amrData[3]); */
-    /* call decoder */
-    Decoder_Interface_DecodeQT_TR_NOOP(getAmrnbWrapper(), s-&gt;decState, amrData, data, 0);
-    *data_size=160*2;
-
-    return packet_size;
-}
-
-static int amr_nb_encode_frame(AVCodecContext *avctx,
-                            unsigned char *frame/*out*/, int buf_size, void *data/*in*/)
-{
-    AMRContext *s = (AMRContext*)avctx-&gt;priv_data;
-    int written;
-
-    s-&gt;enc_bitrate=getBitrateMode(avctx-&gt;bit_rate);
-
-    written = Encoder_Interface_EncodeQT_TR_NOOP(getAmrnbWrapper(), s-&gt;enstate,
-        s-&gt;enc_bitrate,
-        data,
-        frame,
-        0);
-    /* av_log(NULL,AV_LOG_DEBUG,&quot;amr_nb_encode_frame encoded %u bytes, bitrate %u, first byte was %#02x\n&quot;,written, s-&gt;enc_bitrate, frame[0] ); */
-
-    return written;
-}
-
-#endif
-
-#if defined(CONFIG_AMR_NB) || defined(CONFIG_AMR_NB_FIXED)
-
-AVCodec amr_nb_decoder =
-{
-    &quot;amr_nb&quot;,
-    CODEC_TYPE_AUDIO,
-    CODEC_ID_AMR_NB,
-    sizeof(AMRContext),
-    amr_nb_decode_init,
-    NULL,
-    amr_nb_decode_close,
-    amr_nb_decode_frame,
-};
-
-AVCodec amr_nb_encoder =
-{
-    &quot;amr_nb&quot;,
-    CODEC_TYPE_AUDIO,
-    CODEC_ID_AMR_NB,
-    sizeof(AMRContext),
-    amr_nb_encode_init,
-    amr_nb_encode_frame,
-    amr_nb_encode_close,
-    NULL,
-};
-
-#endif
-
-/* -----------AMR wideband ------------*/
-#ifdef CONFIG_AMR_WB
-
-#ifdef _TYPEDEF_H
-//To avoid duplicate typedefs from typdef in amr-nb
-#define typedef_h
-#endif
-
-#include &quot;amrwb_float/enc_if.h&quot;
-#include &quot;amrwb_float/dec_if.h&quot;
-
-/* Common code for fixed and float version*/
-typedef struct AMRWB_bitrates
-{
-    int startrate;
-    int stoprate;
-    int mode;
-
-} AMRWB_bitrates;
-
-static int getWBBitrateMode(int bitrate)
-{
-    /* Adjusted so that all bitrates can be used from commandline where
-       only a multiple of 1000 can be specified*/
-    AMRWB_bitrates rates[]={ {0,7999,0}, //6.6kHz
-                           {8000,9999,1},//8.85
-                           {10000,13000,2},//12.65
-                           {13001,14999,3},//14.25
-                           {15000,17000,4},//15.85
-                           {17001,18000,5},//18.25
-                           {18001,22000,6},//19.85
-                           {22001,23000,7},//23.05
-                           {23001,24000,8},//23.85
-
-                         };
-    int i;
-
-    for(i=0;i&lt;9;i++)
-    {
-        if(rates[i].startrate&lt;=bitrate &amp;&amp; rates[i].stoprate&gt;=bitrate)
-        {
-            return(rates[i].mode);
-        }
-    }
-    /*Return highest possible*/
-    return(8);
-}
-
-
-typedef struct AMRWBContext {
-    int frameCount;
-    void *state;
-    int mode;
-    Word16 allow_dtx;
-} AMRWBContext;
-
-static int amr_wb_encode_init(AVCodecContext * avctx)
-{
-    AMRWBContext *s = (AMRWBContext*)avctx-&gt;priv_data;
-    s-&gt;frameCount=0;
-
-    if(avctx-&gt;sample_rate!=16000)
-    {
-        av_log(avctx, AV_LOG_ERROR, &quot;Only 16000Hz sample rate supported\n&quot;);
-        return -1;
-    }
-
-    if(avctx-&gt;channels!=1)
-    {
-        av_log(avctx, AV_LOG_ERROR, &quot;Only mono supported\n&quot;);
-        return -1;
-    }
-
-    avctx-&gt;frame_size=320;
-    avctx-&gt;coded_frame= avcodec_alloc_frame();
-
-    s-&gt;state = E_IF_init();
-    s-&gt;mode=getWBBitrateMode(avctx-&gt;bit_rate);
-    s-&gt;allow_dtx=0;
-
-    return 0;
-}
-
-static int amr_wb_encode_close(AVCodecContext * avctx)
-{
-    AMRWBContext *s = (AMRWBContext*) avctx-&gt;priv_data;
-    E_IF_exit(s-&gt;state);
-    av_freep(&amp;avctx-&gt;coded_frame);
-    s-&gt;frameCount++;
-    return 0;
-}
-
-static int amr_wb_encode_frame(AVCodecContext *avctx,
-                            unsigned char *frame/*out*/, int buf_size, void *data/*in*/)
-{
-    AMRWBContext *s;
-    int size;
-    s = (AMRWBContext*) avctx-&gt;priv_data;
-    s-&gt;mode=getWBBitrateMode(avctx-&gt;bit_rate);
-    size = E_IF_encode(s-&gt;state, s-&gt;mode, data, frame, s-&gt;allow_dtx);
-    return size;
-}
-
-static int amr_wb_decode_init(AVCodecContext * avctx)
-{
-    AMRWBContext *s = (AMRWBContext *)avctx-&gt;priv_data;
-    s-&gt;frameCount=0;
-    s-&gt;state = D_IF_init();
-
-    amr_decode_fix_avctx(avctx);
-
-    if(avctx-&gt;channels &gt; 1)
-    {
-        av_log(avctx, AV_LOG_ERROR, &quot;amr_wb: multichannel decoding not supported\n&quot;);
-        return -1;
-    }
-
-    return 0;
-}
-
-extern const UWord8 block_size[];
-
-static int amr_wb_decode_frame(AVCodecContext * avctx,
-            void *data, int *data_size,
-            uint8_t * buf, int buf_size)
-{
-    AMRWBContext *s = (AMRWBContext*)avctx-&gt;priv_data;
-
-    uint8_t*amrData=buf;
-    int mode;
-    int packet_size;
-
-    if(buf_size==0) {
-        /* nothing to do */
-        return 0;
-    }
-
-    mode = (amrData[0] &gt;&gt; 3) &amp; 0x000F;
-    packet_size = block_size[mode];
-
-    if(packet_size &gt; buf_size) {
-        av_log(avctx, AV_LOG_ERROR, &quot;amr frame too short (%u, should be %u)\n&quot;, buf_size, packet_size+1);
-        return -1;
-    }
-
-    s-&gt;frameCount++;
-    D_IF_decode( s-&gt;state, amrData, data, _good_frame);
-    *data_size=320*2;
-    return packet_size;
-}
-
-static int amr_wb_decode_close(AVCodecContext * avctx)
-{
-    AMRWBContext *s = (AMRWBContext *)avctx-&gt;priv_data;
-    D_IF_exit(s-&gt;state);
-    return 0;
-}
-
-AVCodec amr_wb_decoder =
-{
-    &quot;amr_wb&quot;,
-    CODEC_TYPE_AUDIO,
-    CODEC_ID_AMR_WB,
-    sizeof(AMRWBContext),
-    amr_wb_decode_init,
-    NULL,
-    amr_wb_decode_close,
-    amr_wb_decode_frame,
-};
-
-AVCodec amr_wb_encoder =
-{
-    &quot;amr_wb&quot;,
-    CODEC_TYPE_AUDIO,
-    CODEC_ID_AMR_WB,
-    sizeof(AMRWBContext),
-    amr_wb_encode_init,
-    amr_wb_encode_frame,
-    amr_wb_encode_close,
-    NULL,
-};
-
-#endif //CONFIG_AMR_WB
- /* MEANX */
- #endif
- /* MEANX */

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/ffconf.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/ffconf.c	2008-06-16 12:13:43 UTC (rev 4105)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/ffconf.c	2008-06-16 15:43:11 UTC (rev 4106)
@@ -6,6 +6,8 @@
 #include &lt;stdio.h&gt;
 int main(void)
 {
+	printf(&quot;#include \&quot;config.h\&quot;\n\n&quot;);
+
 #define DECLARE_DECODER(a,b); printf(&quot;#define ENABLE_&quot;#a&quot;_DECODER 1\n&quot;); 
   
     DECLARE_DECODER(NELLYMOSER,nellymoser);
@@ -144,7 +146,6 @@
     DECLARE_DECODER (ZLIB, zlib);
     DECLARE_DECODER (ZMBV, zmbv);
     DECLARE_DECODER (FLAC, flac);
-    DECLARE_DECODER (LIBAMR_NB, libamr_nb);
     DECLARE_DECODER (LIBAMR_WB, libamr_wb);
     DECLARE_DECODER (LIBGSM, libgsm);
     DECLARE_DECODER (LIBGSM_MS, libgsm_ms);
@@ -190,6 +191,12 @@
     DECLARE_DECODER (ADPCM_YAMAHA, adpcm_yamaha);
     DECLARE_DECODER (DVDSUB, dvdsub);
 
+	printf(&quot;#ifdef USE_AMR_NB\n&quot;);
+	printf(&quot;#define ENABLE_LIBAMR_NB_DECODER 1\n&quot;);
+	printf(&quot;#else\n&quot;);
+	printf(&quot;#define ENABLE_LIBAMR_NB_DECODER 0\n&quot;);
+	printf(&quot;#endif\n&quot;);
+
 #define DECLARE_PARSER(a,b); printf(&quot;#define ENABLE_&quot;#a&quot;_PARSER 1\n&quot;); 
     DECLARE_PARSER (H263, h263);
     DECLARE_PARSER (H264, h264);
@@ -333,7 +340,6 @@
 printf(&quot;#define ENABLE_ALPHA      0\n&quot;);
 
 // Hack so CMake and autoconf don't need to be changed
-printf(&quot;#include \&quot;config.h\&quot;\n&quot;);
 printf(&quot;#ifdef ARCH_POWERPC\n&quot;);
 printf(&quot;#define ENABLE_POWERPC      1\n&quot;);
 printf(&quot;#else\n&quot;);

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/ffconf.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/ffconf.h	2008-06-16 12:13:43 UTC (rev 4105)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/ffconf.h	2008-06-16 15:43:11 UTC (rev 4106)
@@ -1,3 +1,5 @@
+#include &quot;config.h&quot;
+
 #define ENABLE_NELLYMOSER_DECODER 1
 #define ENABLE_ADPCM_IMA_AMV_DECODER 1
 #define ENABLE_CINEPAK_DECODER 1
@@ -130,7 +132,6 @@
 #define ENABLE_ZLIB_DECODER 0
 #define ENABLE_ZMBV_DECODER 0
 #define ENABLE_FLAC_DECODER 0
-#define ENABLE_LIBAMR_NB_DECODER 0
 #define ENABLE_LIBAMR_WB_DECODER 0
 #define ENABLE_LIBGSM_DECODER 0
 #define ENABLE_LIBGSM_MS_DECODER 0
@@ -175,6 +176,11 @@
 #define ENABLE_ADPCM_XA_DECODER 0
 #define ENABLE_ADPCM_YAMAHA_DECODER 0
 #define ENABLE_DVDSUB_DECODER 0
+#ifdef USE_AMR_NB
+#define ENABLE_LIBAMR_NB_DECODER 1
+#else
+#define ENABLE_LIBAMR_NB_DECODER 0
+#endif
 #define ENABLE_H263_PARSER 1
 #define ENABLE_H264_PARSER 1
 #define ENABLE_MPEG4VIDEO_PARSER 1
@@ -303,7 +309,6 @@
 #define ENABLE_MLIB      0
 #define ENABLE_SPARC      0
 #define ENABLE_ALPHA      0
-#include &quot;config.h&quot;
 #ifdef ARCH_POWERPC
 #define ENABLE_POWERPC      1
 #else

Copied: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/libamr.c (from rev 4095, branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/amr.c)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/amr.c	2008-06-13 12:18:36 UTC (rev 4095)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/libamr.c	2008-06-16 15:43:11 UTC (rev 4106)
@@ -0,0 +1,719 @@
+/*
+ * AMR Audio decoder stub
+ * Copyright (c) 2003 the ffmpeg project
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+ /** @file
+ * Adaptive Multi-Rate (AMR) Audio decoder stub.
+ *
+ * This code implements both an AMR-NarrowBand (AMR-NB) and an AMR-WideBand
+ * (AMR-WB) audio encoder/decoder through external reference code from
+ * <A HREF="http://www.3gpp.org/.">http://www.3gpp.org/.</A> The license of the code from 3gpp is unclear so you
+ * have to download the code separately. Two versions exists: One fixed-point
+ * and one floating-point. For some reason the float encoder is significantly
+ * faster at least on a P4 1.5GHz (0.9s instead of 9.9s on a 30s audio clip
+ * at MR102). Both float and fixed point are supported for AMR-NB, but only
+ * float for AMR-WB.
+ *
+ * \section AMR-NB
+ *
+ * \subsection Float
+ * The float version (default) can be downloaded from:
+ * <A HREF="http://www.3gpp.org/ftp/Specs/archive/26_series/26.104/26104-610.zip">http://www.3gpp.org/ftp/Specs/archive/26_series/26.104/26104-610.zip</A>
+ *
+ * \subsection Fixed-point
+ * The fixed-point (TS26.073) can be downloaded from:
+ * <A HREF="http://www.3gpp.org/ftp/Specs/archive/26_series/26.073/26073-600.zip">http://www.3gpp.org/ftp/Specs/archive/26_series/26.073/26073-600.zip</A>
+ *
+ * \subsection Specification
+ * The specification for AMR-NB can be found in TS 26.071
+ * (<A HREF="http://www.3gpp.org/ftp/Specs/html-info/26071.htm">http://www.3gpp.org/ftp/Specs/html-info/26071.htm</A>) and some other
+ * info at <A HREF="http://www.3gpp.org/ftp/Specs/html-info/26-series.htm.">http://www.3gpp.org/ftp/Specs/html-info/26-series.htm.</A>
+ *
+ * \section AMR-WB
+ *
+ * \subsection Float
+ * The reference code can be downloaded from:
+ * <A HREF="http://www.3gpp.org/ftp/Specs/archive/26_series/26.204/26204-600.zip">http://www.3gpp.org/ftp/Specs/archive/26_series/26.204/26204-600.zip</A>
+ *
+ * \subsection Fixed-point
+ * If someone wants to use the fixed point version it can be downloaded from:
+ * <A HREF="http://www.3gpp.org/ftp/Specs/archive/26_series/26.173/26173-571.zip.">http://www.3gpp.org/ftp/Specs/archive/26_series/26.173/26173-571.zip.</A>
+ *
+ * \subsection Specification
+ * The specification for AMR-WB can be found in TS 26.171
+ * (<A HREF="http://www.3gpp.org/ftp/Specs/html-info/26171.htm">http://www.3gpp.org/ftp/Specs/html-info/26171.htm</A>) and some other
+ * info at <A HREF="http://www.3gpp.org/ftp/Specs/html-info/26-series.htm.">http://www.3gpp.org/ftp/Specs/html-info/26-series.htm.</A>
+ *
+ */
+ /* MEANX */
+#include &quot;config.h&quot;
+#ifdef USE_AMR_NB
+ /* MEANX */
+
+#include &quot;ADM_libraries/ADM_libwrapper/libwrapper_global.h&quot;
+#include &quot;avcodec.h&quot;
+
+#ifdef CONFIG_LIBAMR_NB_FIXED
+
+#define MMS_IO
+
+#include &quot;amr/sp_dec.h&quot;
+#include &quot;amr/d_homing.h&quot;
+#include &quot;amr/typedef.h&quot;
+#include &quot;amr/sp_enc.h&quot;
+#include &quot;amr/sid_sync.h&quot;
+#include &quot;amr/e_homing.h&quot;
+
+#else
+#include &lt;amrnb/interf_dec.h&gt;
+#include &lt;amrnb/interf_enc.h&gt;
+#endif
+
+static const char *nb_bitrate_unsupported =
+    &quot;bitrate not supported: use one of 4.75k, 5.15k, 5.9k, 6.7k, 7.4k, 7.95k, 10.2k or 12.2k\n&quot;;
+static const char *wb_bitrate_unsupported =
+    &quot;bitrate not supported: use one of 6.6k, 8.85k, 12.65k, 14.25k, 15.85k, 18.25k, 19.85k, 23.05k, or 23.85k\n&quot;;
+
+/* Common code for fixed and float version*/
+typedef struct AMR_bitrates
+{
+    int rate;
+    enum Mode mode;
+} AMR_bitrates;
+
+/* Match desired bitrate */
+static int getBitrateMode(int bitrate)
+{
+    /* make the correspondance between bitrate and mode */
+    AMR_bitrates rates[]={ {4750,MR475},
+                           {5150,MR515},
+                           {5900,MR59},
+                           {6700,MR67},
+                           {7400,MR74},
+                           {7950,MR795},
+                           {10200,MR102},
+                           {12200,MR122},
+                         };
+    int i;
+
+    for(i=0;i&lt;8;i++)
+    {
+        if(rates[i].rate==bitrate)
+        {
+            return(rates[i].mode);
+        }
+    }
+    /* no bitrate matching, return an error */
+    return -1;
+}
+
+static void amr_decode_fix_avctx(AVCodecContext * avctx)
+{
+    const int is_amr_wb = 1 + (avctx-&gt;codec_id == CODEC_ID_AMR_WB);
+
+    if(avctx-&gt;sample_rate == 0)
+    {
+        avctx-&gt;sample_rate = 8000 * is_amr_wb;
+    }
+
+    if(avctx-&gt;channels == 0)
+    {
+        avctx-&gt;channels = 1;
+    }
+
+    avctx-&gt;frame_size = 160 * is_amr_wb;
+}
+
+#ifdef CONFIG_LIBAMR_NB_FIXED
+/* fixed point version*/
+/* frame size in serial bitstream file (frame type + serial stream + flags) */
+#define SERIAL_FRAMESIZE (1+MAX_SERIAL_SIZE+5)
+
+typedef struct AMRContext {
+    int frameCount;
+    Speech_Decode_FrameState *speech_decoder_state;
+    enum RXFrameType rx_type;
+    enum Mode mode;
+    Word16 reset_flag;
+    Word16 reset_flag_old;
+
+    int enc_bitrate;
+    Speech_Encode_FrameState *enstate;
+    sid_syncState *sidstate;
+    enum TXFrameType tx_frametype;
+} AMRContext;
+
+static int amr_nb_decode_init(AVCodecContext * avctx)
+{
+    AMRContext *s = avctx-&gt;priv_data;
+
+    s-&gt;frameCount=0;
+    s-&gt;speech_decoder_state=NULL;
+    s-&gt;rx_type = (enum RXFrameType)0;
+    s-&gt;mode= (enum Mode)0;
+    s-&gt;reset_flag=0;
+    s-&gt;reset_flag_old=1;
+
+    if(Speech_Decode_Frame_init(&amp;s-&gt;speech_decoder_state, &quot;Decoder&quot;))
+    {
+        av_log(avctx, AV_LOG_ERROR, &quot;Speech_Decode_Frame_init error\n&quot;);
+        return -1;
+    }
+
+    amr_decode_fix_avctx(avctx);
+
+    if(avctx-&gt;channels &gt; 1)
+    {
+        av_log(avctx, AV_LOG_ERROR, &quot;amr_nb: multichannel decoding not supported\n&quot;);
+        return -1;
+    }
+
+    return 0;
+}
+
+static int amr_nb_encode_init(AVCodecContext * avctx)
+{
+    AMRContext *s = avctx-&gt;priv_data;
+
+    s-&gt;frameCount=0;
+    s-&gt;speech_decoder_state=NULL;
+    s-&gt;rx_type = (enum RXFrameType)0;
+    s-&gt;mode= (enum Mode)0;
+    s-&gt;reset_flag=0;
+    s-&gt;reset_flag_old=1;
+
+    if(avctx-&gt;sample_rate!=8000)
+    {
+        av_log(avctx, AV_LOG_ERROR, &quot;Only 8000Hz sample rate supported\n&quot;);
+        return -1;
+    }
+
+    if(avctx-&gt;channels!=1)
+    {
+        av_log(avctx, AV_LOG_ERROR, &quot;Only mono supported\n&quot;);
+        return -1;
+    }
+
+    avctx-&gt;frame_size=160;
+    avctx-&gt;coded_frame= avcodec_alloc_frame();
+
+    if(Speech_Encode_Frame_init(&amp;s-&gt;enstate, 0, &quot;encoder&quot;) || sid_sync_init (&amp;s-&gt;sidstate))
+    {
+        av_log(avctx, AV_LOG_ERROR, &quot;Speech_Encode_Frame_init error\n&quot;);
+        return -1;
+    }
+
+    if((s-&gt;enc_bitrate=getBitrateMode(avctx-&gt;bit_rate))&lt;0)
+    {
+        av_log(avctx, AV_LOG_ERROR, nb_bitrate_unsupported);
+        return -1;
+    }
+
+    return 0;
+}
+
+static int amr_nb_encode_close(AVCodecContext * avctx)
+{
+    AMRContext *s = avctx-&gt;priv_data;
+
+    Speech_Encode_Frame_exit(&amp;s-&gt;enstate);
+    sid_sync_exit (&amp;s-&gt;sidstate);
+    av_freep(&amp;avctx-&gt;coded_frame);
+    return 0;
+}
+
+static int amr_nb_decode_close(AVCodecContext * avctx)
+{
+    AMRContext *s = avctx-&gt;priv_data;
+
+    Speech_Decode_Frame_exit(&amp;s-&gt;speech_decoder_state);
+    return 0;
+}
+
+static int amr_nb_decode_frame(AVCodecContext * avctx,
+            void *data, int *data_size,
+            uint8_t * buf, int buf_size)
+{
+    AMRContext *s = avctx-&gt;priv_data;
+    uint8_t*amrData=buf;
+    int offset=0;
+    UWord8 toc, q, ft;
+    Word16 serial[SERIAL_FRAMESIZE];   /* coded bits */
+    Word16 *synth;
+    UWord8 *packed_bits;
+    static Word16 packed_size[16] = {12, 13, 15, 17, 19, 20, 26, 31, 5, 0, 0, 0, 0, 0, 0, 0};
+    int i;
+
+    //printf(&quot;amr_decode_frame data_size=%i buf=0x%X buf_size=%d frameCount=%d!!\n&quot;,*data_size,buf,buf_size,s-&gt;frameCount);
+
+    synth=data;
+
+    toc=amrData[offset];
+    /* read rest of the frame based on ToC byte */
+    q  = (toc &gt;&gt; 2) &amp; 0x01;
+    ft = (toc &gt;&gt; 3) &amp; 0x0F;
+
+    //printf(&quot;offset=%d, packet_size=%d amrData= 0x%X %X %X %X\n&quot;,offset,packed_size[ft],amrData[offset],amrData[offset+1],amrData[offset+2],amrData[offset+3]);
+
+    offset++;
+
+    packed_bits=amrData+offset;
+
+    offset+=packed_size[ft];
+
+    //Unsort and unpack bits
+    s-&gt;rx_type = UnpackBits(q, ft, packed_bits, &amp;s-&gt;mode, &amp;serial[1]);
+
+    //We have a new frame
+    s-&gt;frameCount++;
+
+    if (s-&gt;rx_type == RX_NO_DATA)
+    {
+        s-&gt;mode = s-&gt;speech_decoder_state-&gt;prev_mode;
+    }
+    else {
+        s-&gt;speech_decoder_state-&gt;prev_mode = s-&gt;mode;
+    }
+
+    /* if homed: check if this frame is another homing frame */
+    if (s-&gt;reset_flag_old == 1)
+    {
+        /* only check until end of first subframe */
+        s-&gt;reset_flag = decoder_homing_frame_test_first(&amp;serial[1], s-&gt;mode);
+    }
+    /* produce encoder homing frame if homed &amp; input=decoder homing frame */
+    if ((s-&gt;reset_flag != 0) &amp;&amp; (s-&gt;reset_flag_old != 0))
+    {
+        for (i = 0; i &lt; L_FRAME; i++)
+        {
+            synth[i] = EHF_MASK;
+        }
+    }
+    else
+    {
+        /* decode frame */
+        Speech_Decode_Frame(s-&gt;speech_decoder_state, s-&gt;mode, &amp;serial[1], s-&gt;rx_type, synth);
+    }
+
+    //Each AMR-frame results in 160 16-bit samples
+    *data_size=160*2;
+
+    /* if not homed: check whether current frame is a homing frame */
+    if (s-&gt;reset_flag_old == 0)
+    {
+        /* check whole frame */
+        s-&gt;reset_flag = decoder_homing_frame_test(&amp;serial[1], s-&gt;mode);
+    }
+    /* reset decoder if current frame is a homing frame */
+    if (s-&gt;reset_flag != 0)
+    {
+        Speech_Decode_Frame_reset(s-&gt;speech_decoder_state);
+    }
+    s-&gt;reset_flag_old = s-&gt;reset_flag;
+
+    return offset;
+}
+
+
+static int amr_nb_encode_frame(AVCodecContext *avctx,
+                            unsigned char *frame/*out*/, int buf_size, void *data/*in*/)
+{
+    short serial_data[250] = {0};
+    AMRContext *s = avctx-&gt;priv_data;
+    int written;
+
+    s-&gt;reset_flag = encoder_homing_frame_test(data);
+
+    Speech_Encode_Frame(s-&gt;enstate, s-&gt;enc_bitrate, data, &amp;serial_data[1], &amp;s-&gt;mode);
+
+    /* add frame type and mode */
+    sid_sync (s-&gt;sidstate, s-&gt;mode, &amp;s-&gt;tx_frametype);
+
+    written = PackBits(s-&gt;mode, s-&gt;enc_bitrate, s-&gt;tx_frametype, &amp;serial_data[1], frame);
+
+    if (s-&gt;reset_flag != 0)
+    {
+        Speech_Encode_Frame_reset(s-&gt;enstate);
+        sid_sync_reset(s-&gt;sidstate);
+    }
+    return written;
+}
+
+
+#elif defined(CONFIG_LIBAMR_NB) /* Float point version*/
+
+typedef struct AMRContext {
+    int frameCount;
+    void * decState;
+    int *enstate;
+    int enc_bitrate;
+} AMRContext;
+
+static int amr_nb_decode_init(AVCodecContext * avctx)
+{
+    AMRContext *s = avctx-&gt;priv_data;
+
+    s-&gt;frameCount=0;
+    s-&gt;decState=Decoder_Interface_init_(getAmrnbWrapper());
+    if(!s-&gt;decState)
+    {
+        av_log(avctx, AV_LOG_ERROR, &quot;Decoder_Interface_init error\r\n&quot;);
+        return -1;
+    }
+
+    amr_decode_fix_avctx(avctx);
+
+    if(avctx-&gt;channels &gt; 1)
+    {
+        av_log(avctx, AV_LOG_ERROR, &quot;amr_nb: multichannel decoding not supported\n&quot;);
+        return -1;
+    }
+
+    return 0;
+}
+
+static int amr_nb_encode_init(AVCodecContext * avctx)
+{
+    AMRContext *s = avctx-&gt;priv_data;
+
+    s-&gt;frameCount=0;
+
+    if(avctx-&gt;sample_rate!=8000)
+    {
+        av_log(avctx, AV_LOG_ERROR, &quot;Only 8000Hz sample rate supported\n&quot;);
+        return -1;
+    }
+
+    if(avctx-&gt;channels!=1)
+    {
+        av_log(avctx, AV_LOG_ERROR, &quot;Only mono supported\n&quot;);
+        return -1;
+    }
+
+    avctx-&gt;frame_size=160;
+    avctx-&gt;coded_frame= avcodec_alloc_frame();
+
+    s-&gt;enstate=Encoder_Interface_init_(getAmrnbWrapper(), 0);
+    if(!s-&gt;enstate)
+    {
+        av_log(avctx, AV_LOG_ERROR, &quot;Encoder_Interface_init error\n&quot;);
+        return -1;
+    }
+
+    if((s-&gt;enc_bitrate=getBitrateMode(avctx-&gt;bit_rate))&lt;0)
+    {
+        av_log(avctx, AV_LOG_ERROR, nb_bitrate_unsupported);
+        return -1;
+    }
+
+    return 0;
+}
+
+static int amr_nb_decode_close(AVCodecContext * avctx)
+{
+    AMRContext *s = avctx-&gt;priv_data;
+
+    Decoder_Interface_exit(s-&gt;decState);
+    return 0;
+}
+
+static int amr_nb_encode_close(AVCodecContext * avctx)
+{
+    AMRContext *s = avctx-&gt;priv_data;
+
+    Encoder_Interface_exit(s-&gt;enstate);
+    av_freep(&amp;avctx-&gt;coded_frame);
+    return 0;
+}
+
+static int amr_nb_decode_frame(AVCodecContext * avctx,
+            void *data, int *data_size,
+            uint8_t * buf, int buf_size)
+{
+    AMRContext *s = avctx-&gt;priv_data;
+    uint8_t*amrData=buf;
+    static short block_size[16]={ 12, 13, 15, 17, 19, 20, 26, 31, 5, 0, 0, 0, 0, 0, 0, 0 };
+    enum Mode dec_mode;
+    int packet_size;
+
+    /* av_log(NULL,AV_LOG_DEBUG,&quot;amr_decode_frame buf=%p buf_size=%d frameCount=%d!!\n&quot;,buf,buf_size,s-&gt;frameCount); */
+
+    dec_mode = (buf[0] &gt;&gt; 3) &amp; 0x000F;
+    packet_size = block_size[dec_mode]+1;
+
+    if(packet_size &gt; buf_size) {
+        av_log(avctx, AV_LOG_ERROR, &quot;amr frame too short (%u, should be %u)\n&quot;, buf_size, packet_size);
+        return -1;
+    }
+
+    s-&gt;frameCount++;
+    /* av_log(NULL,AV_LOG_DEBUG,&quot;packet_size=%d amrData= 0x%X %X %X %X\n&quot;,packet_size,amrData[0],amrData[1],amrData[2],amrData[3]); */
+    /* call decoder */
+    Decoder_Interface_Decode_(getAmrnbWrapper(), s-&gt;decState, amrData, data, 0);
+    *data_size=160*2;
+
+    return packet_size;
+}
+
+static int amr_nb_encode_frame(AVCodecContext *avctx,
+                            unsigned char *frame/*out*/, int buf_size, void *data/*in*/)
+{
+    AMRContext *s = avctx-&gt;priv_data;
+    int written;
+
+    if((s-&gt;enc_bitrate=getBitrateMode(avctx-&gt;bit_rate))&lt;0)
+    {
+        av_log(avctx, AV_LOG_ERROR, nb_bitrate_unsupported);
+        return -1;
+    }
+
+    written = Encoder_Interface_Encode_(getAmrnbWrapper(), s-&gt;enstate,
+        s-&gt;enc_bitrate,
+        data,
+        frame,
+        0);
+    /* av_log(NULL,AV_LOG_DEBUG,&quot;amr_nb_encode_frame encoded %u bytes, bitrate %u, first byte was %#02x\n&quot;,written, s-&gt;enc_bitrate, frame[0] ); */
+
+    return written;
+}
+
+#endif
+
+#if defined(CONFIG_LIBAMR_NB) || defined(CONFIG_LIBAMR_NB_FIXED)
+
+AVCodec libamr_nb_decoder =
+{
+    &quot;libamr_nb&quot;,
+    CODEC_TYPE_AUDIO,
+    CODEC_ID_AMR_NB,
+    sizeof(AMRContext),
+    amr_nb_decode_init,
+    NULL,
+    amr_nb_decode_close,
+    amr_nb_decode_frame,
+};
+
+AVCodec libamr_nb_encoder =
+{
+    &quot;libamr_nb&quot;,
+    CODEC_TYPE_AUDIO,
+    CODEC_ID_AMR_NB,
+    sizeof(AMRContext),
+    amr_nb_encode_init,
+    amr_nb_encode_frame,
+    amr_nb_encode_close,
+    NULL,
+};
+
+#endif
+
+/* -----------AMR wideband ------------*/
+#ifdef CONFIG_LIBAMR_WB
+
+#ifdef _TYPEDEF_H
+//To avoid duplicate typedefs from typdef in amr-nb
+#define typedef_h
+#endif
+
+#include &lt;amrwb/enc_if.h&gt;
+#include &lt;amrwb/dec_if.h&gt;
+#include &lt;amrwb/if_rom.h&gt;
+
+/* Common code for fixed and float version*/
+typedef struct AMRWB_bitrates
+{
+    int rate;
+    int mode;
+} AMRWB_bitrates;
+
+static int getWBBitrateMode(int bitrate)
+{
+    /* make the correspondance between bitrate and mode */
+    AMRWB_bitrates rates[]={ {6600,0},
+                           {8850,1},
+                           {12650,2},
+                           {14250,3},
+                           {15850,4},
+                           {18250,5},
+                           {19850,6},
+                           {23050,7},
+                           {23850,8},
+                         };
+    int i;
+
+    for(i=0;i&lt;9;i++)
+    {
+        if(rates[i].rate==bitrate)
+        {
+            return(rates[i].mode);
+        }
+    }
+    /* no bitrate matching, return an error */
+    return -1;
+}
+
+
+typedef struct AMRWBContext {
+    int frameCount;
+    void *state;
+    int mode;
+    Word16 allow_dtx;
+} AMRWBContext;
+
+static int amr_wb_encode_init(AVCodecContext * avctx)
+{
+    AMRWBContext *s = avctx-&gt;priv_data;
+
+    s-&gt;frameCount=0;
+
+    if(avctx-&gt;sample_rate!=16000)
+    {
+        av_log(avctx, AV_LOG_ERROR, &quot;Only 16000Hz sample rate supported\n&quot;);
+        return -1;
+    }
+
+    if(avctx-&gt;channels!=1)
+    {
+        av_log(avctx, AV_LOG_ERROR, &quot;Only mono supported\n&quot;);
+        return -1;
+    }
+
+    if((s-&gt;mode=getWBBitrateMode(avctx-&gt;bit_rate))&lt;0)
+    {
+        av_log(avctx, AV_LOG_ERROR, wb_bitrate_unsupported);
+        return -1;
+    }
+
+    avctx-&gt;frame_size=320;
+    avctx-&gt;coded_frame= avcodec_alloc_frame();
+
+    s-&gt;state = E_IF_init();
+    s-&gt;allow_dtx=0;
+
+    return 0;
+}
+
+static int amr_wb_encode_close(AVCodecContext * avctx)
+{
+    AMRWBContext *s = avctx-&gt;priv_data;
+
+    E_IF_exit(s-&gt;state);
+    av_freep(&amp;avctx-&gt;coded_frame);
+    s-&gt;frameCount++;
+    return 0;
+}
+
+static int amr_wb_encode_frame(AVCodecContext *avctx,
+                            unsigned char *frame/*out*/, int buf_size, void *data/*in*/)
+{
+    AMRWBContext *s = avctx-&gt;priv_data;
+    int size;
+
+    if((s-&gt;mode=getWBBitrateMode(avctx-&gt;bit_rate))&lt;0)
+    {
+        av_log(avctx, AV_LOG_ERROR, wb_bitrate_unsupported);
+        return -1;
+    }
+    size = E_IF_encode(s-&gt;state, s-&gt;mode, data, frame, s-&gt;allow_dtx);
+    return size;
+}
+
+static int amr_wb_decode_init(AVCodecContext * avctx)
+{
+    AMRWBContext *s = avctx-&gt;priv_data;
+
+    s-&gt;frameCount=0;
+    s-&gt;state = D_IF_init();
+
+    amr_decode_fix_avctx(avctx);
+
+    if(avctx-&gt;channels &gt; 1)
+    {
+        av_log(avctx, AV_LOG_ERROR, &quot;amr_wb: multichannel decoding not supported\n&quot;);
+        return -1;
+    }
+
+    return 0;
+}
+
+static int amr_wb_decode_frame(AVCodecContext * avctx,
+            void *data, int *data_size,
+            uint8_t * buf, int buf_size)
+{
+    AMRWBContext *s = avctx-&gt;priv_data;
+    uint8_t*amrData=buf;
+    int mode;
+    int packet_size;
+
+    if(buf_size==0) {
+        /* nothing to do */
+        return 0;
+    }
+
+    mode = (amrData[0] &gt;&gt; 3) &amp; 0x000F;
+    packet_size = block_size[mode];
+
+    if(packet_size &gt; buf_size) {
+        av_log(avctx, AV_LOG_ERROR, &quot;amr frame too short (%u, should be %u)\n&quot;, buf_size, packet_size+1);
+        return -1;
+    }
+
+    s-&gt;frameCount++;
+    D_IF_decode( s-&gt;state, amrData, data, _good_frame);
+    *data_size=320*2;
+    return packet_size;
+}
+
+static int amr_wb_decode_close(AVCodecContext * avctx)
+{
+    AMRWBContext *s = avctx-&gt;priv_data;
+
+    D_IF_exit(s-&gt;state);
+    return 0;
+}
+
+AVCodec libamr_wb_decoder =
+{
+    &quot;libamr_wb&quot;,
+    CODEC_TYPE_AUDIO,
+    CODEC_ID_AMR_WB,
+    sizeof(AMRWBContext),
+    amr_wb_decode_init,
+    NULL,
+    amr_wb_decode_close,
+    amr_wb_decode_frame,
+};
+
+AVCodec libamr_wb_encoder =
+{
+    &quot;libamr_wb&quot;,
+    CODEC_TYPE_AUDIO,
+    CODEC_ID_AMR_WB,
+    sizeof(AMRWBContext),
+    amr_wb_encode_init,
+    amr_wb_encode_frame,
+    amr_wb_encode_close,
+    NULL,
+};
+
+#endif //CONFIG_LIBAMR_WB
+ /* MEANX */
+ #endif
+ /* MEANX */

Modified: branches/avidemux_2.4_branch/config.h.cmake
===================================================================
--- branches/avidemux_2.4_branch/config.h.cmake	2008-06-16 12:13:43 UTC (rev 4105)
+++ branches/avidemux_2.4_branch/config.h.cmake	2008-06-16 15:43:11 UTC (rev 4106)
@@ -29,9 +29,6 @@
 /* use ALSA as possible audio device */
 #cmakedefine ALSA_SUPPORT
 
-/* AMR_NB */
-#cmakedefine AMR_NB
-
 /* X86_64 AMD64 assembly */
 #cmakedefine ARCH_64_BITS
 
@@ -54,6 +51,7 @@
 #cmakedefine CONFIG_ENCODERS
 #cmakedefine CONFIG_DVVIDEO_ENCODER
 
+#cmakedefine CONFIG_LIBAMR_NB
 #cmakedefine CONFIG_DECODERS
 #cmakedefine CONFIG_DVVIDEO_DECODER
 #cmakedefine CONFIG_H263_DECODER


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001361.html">[Avidemux-svn-commit] r4105 - in	branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces:	ADM_GTK/ADM_dialog ADM_GTK/ADM_toolkit_gtk ADM_commonUI
</A></li>
	<LI>Next message: <A HREF="001363.html">[Avidemux-svn-commit] r4107 - in branches/avidemux_2.4_branch: .	avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk	avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1362">[ date ]</a>
              <a href="thread.html#1362">[ thread ]</a>
              <a href="subject.html#1362">[ subject ]</a>
              <a href="author.html#1362">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
