<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r4112 - in	branches/avidemux_2.5_branch_gruntster: avidemux	avidemux/ADM_inputs/ADM_mp4 plugins/ADM_videoFilters	plugins/ADM_videoFilters/TIsophote	plugins/ADM_videoFilters/TIsophote/original
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2008-June/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r4112%20-%20in%0A%09branches/avidemux_2.5_branch_gruntster%3A%20avidemux%0A%09avidemux/ADM_inputs/ADM_mp4%20plugins/ADM_videoFilters%0A%09plugins/ADM_videoFilters/TIsophote%0A%09plugins/ADM_videoFilters/TIsophote/original&In-Reply-To=%3C200806161807.m5GI7k1G002339%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001367.html">
   <LINK REL="Next"  HREF="001369.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r4112 - in	branches/avidemux_2.5_branch_gruntster: avidemux	avidemux/ADM_inputs/ADM_mp4 plugins/ADM_videoFilters	plugins/ADM_videoFilters/TIsophote	plugins/ADM_videoFilters/TIsophote/original</H1>
    <B>mean at BerliOS</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r4112%20-%20in%0A%09branches/avidemux_2.5_branch_gruntster%3A%20avidemux%0A%09avidemux/ADM_inputs/ADM_mp4%20plugins/ADM_videoFilters%0A%09plugins/ADM_videoFilters/TIsophote%0A%09plugins/ADM_videoFilters/TIsophote/original&In-Reply-To=%3C200806161807.m5GI7k1G002339%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r4112 - in	branches/avidemux_2.5_branch_gruntster: avidemux	avidemux/ADM_inputs/ADM_mp4 plugins/ADM_videoFilters	plugins/ADM_videoFilters/TIsophote	plugins/ADM_videoFilters/TIsophote/original">mean at mail.berlios.de
       </A><BR>
    <I>Mon Jun 16 20:07:46 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001367.html">[Avidemux-svn-commit] r4111 - branches/avidemux_2.4_branch/avidemux
</A></li>
        <LI>Next message: <A HREF="001369.html">[Avidemux-svn-commit] r4113 -	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1368">[ date ]</a>
              <a href="thread.html#1368">[ thread ]</a>
              <a href="subject.html#1368">[ subject ]</a>
              <a href="author.html#1368">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2008-06-16 20:07:45 +0200 (Mon, 16 Jun 2008)
New Revision: 4112

Added:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/TIsophote/
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/TIsophote/ADM_vidTisophote.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/TIsophote/ADM_vidTisophote.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/TIsophote/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/TIsophote/HELP FILE.txt
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/TIsophote/original/
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/TIsophote/original/TIsophote.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/TIsophote/original/TIsophote.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/TIsophote/original/avisynth.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/TIsophote/original/gpl.txt
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/TIsophote/original/internal.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/TIsophote/original/resource.h
Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Analyzer.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/gtk_gui.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CMakeLists.txt
Log:
[Merge]


Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Analyzer.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Analyzer.cpp	2008-06-16 17:49:32 UTC (rev 4111)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Analyzer.cpp	2008-06-16 18:07:45 UTC (rev 4112)
@@ -1,6 +1,6 @@
 /***************************************************************************
 /*
-    
+
     copyright            : (C) 2007 by mean
     email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
  ***************************************************************************/
@@ -42,7 +42,7 @@
 
 uint32_t ADM_UsecFromFps1000(uint32_t fps1000);
 // 14496-1 / 8.2.1
-typedef enum 
+typedef enum
 {
 	Tag_InitialObjDesc	=0x02,
 	Tag_ES_Desc		=0x03,
@@ -58,7 +58,7 @@
 */
 uint8_t     MP4Header::lookupMainAtoms(void *ztom)
 {
-  
+
   adm_atom *tom=(adm_atom *)ztom;
   adm_atom *moov;
   ADMAtoms id;
@@ -81,19 +81,19 @@
     {
       switch( id)
       {
-        case ADM_MP4_MVHD: parseMvhd(&amp;son);break; 
-        case ADM_MP4_TRACK: 
+        case ADM_MP4_MVHD: parseMvhd(&amp;son);break;
+        case ADM_MP4_TRACK:
             if(!parseTrack(&amp;son))
             {
                 printf(&quot;Parse Track failed\n&quot;);
             } ;
             break;
-        default : 
+        default :
                 adm_printf(ADM_PRINT_DEBUG,&quot;atom %s not handled\n&quot;,fourCC::tostringBE(son.getFCC()));
                 break;
       }
-      
-      
+
+
     }
     son.skipAtom();
   }
@@ -110,7 +110,7 @@
   adm_atom *tom=(adm_atom *)ztom;
   tom-&gt;skipBytes(12);
   uint32_t scale,duration=1000;
-  
+
         scale=tom-&gt;read32();
         duration=tom-&gt;read32();
         _videoScale=scale;
@@ -135,7 +135,7 @@
   uint32_t container;
   uint32_t w,h;
   uint32_t trackType=TRACK_OTHER;
-  
+
   printf(&quot;Parsing Track\n&quot;);
    while(!tom-&gt;isDone())
   {
@@ -158,7 +158,7 @@
                       son.skipBytes(8);
                       son.skipBytes(4); // layers
                       son.skipBytes(40); // layers
-  
+
                       w=son.read32()&gt;&gt;16;
                       h=son.read32()&gt;&gt;16;
                       adm_printf(ADM_PRINT_DEBUG,&quot;tkhd : %ld %ld\n&quot;,w,h);
@@ -202,7 +202,7 @@
      }
      switch(id)
      {
-       case ADM_MP4_MDHD:  
+       case ADM_MP4_MDHD:
        {
                 uint32_t version=son.read(),duration;
                 son.skipBytes(3); // flags + version
@@ -220,16 +220,16 @@
                 printf(&quot;MDHD,Track duration :%s, trackScale :%u\n&quot;,ms2timedisplay((1000*duration)/trackScale),trackScale);
                 break;
        }
-       case ADM_MP4_HDLR:  
+       case ADM_MP4_HDLR:
        {
             uint32_t type;
-            
+
                 son.read32();
                 son.read32();
                 type=son.read32();
                 printf(&quot;[HDLR]\n&quot;);
                 switch(type)
-                {	
+                {
                 case MKFCCR('v','i','d','e')://'vide':
                         *trackType=TRACK_VIDEO;
                         printf(&quot;hdlr video found \n &quot;);
@@ -253,14 +253,14 @@
                         printf(&quot;Url : &lt;%s&gt;\n&quot;,str);
                       }
                       break;
-                 
+
                 }
                 break;
-       } 
-       case ADM_MP4_MINF:  
+       }
+       case ADM_MP4_MINF:
        {
             // We are only interested in stbl
-            
+
             while(!son.isDone())
             {
               adm_atom grandson(&amp;son);
@@ -275,7 +275,7 @@
                    if(! parseStbl(&amp;grandson,*trackType, w, h,trackScale))
                    {
                       printf(&quot;STBL failed\n&quot;);
-                      return 0; 
+                      return 0;
                    }
                    r=1;
               }
@@ -286,7 +286,7 @@
         default:
             adm_printf(ADM_PRINT_DEBUG,&quot;** atom  NOT HANDLED [%s] \n&quot;,fourCC::tostringBE(son.getFCC()));
      }
-     
+
      son.skipAtom();
   }
   return r;
@@ -302,11 +302,11 @@
   ADMAtoms id;
   uint32_t container;
   MPsampleinfo  info;
-  
-  
+
+
   memset(&amp;info,0,sizeof(info));
 
-  
+
   printf(&quot;&lt;&lt;Parsing Stbl&gt;&gt;\n&quot;);
   while(!tom-&gt;isDone())
   {
@@ -333,9 +333,9 @@
                   }
           }
           break;
-         
+
        }
-       case ADM_MP4_STTS: 
+       case ADM_MP4_STTS:
             {
                 printf(&quot;stts:%lu\n&quot;,son.read32()); // version &amp; flags
                 info.nbStts=son.read32();
@@ -346,13 +346,13 @@
                 double dur;
                 for(int i=0;i&lt;info.nbStts;i++)
                 {
-                        
+
                         info.SttsN[i]=son.read32();
                         info.SttsC[i]=son.read32();
-                        adm_printf(ADM_PRINT_VERY_VERBOSE,&quot;stts: count:%u size:%u (unscaled)\n&quot;,info.SttsN[i],info.SttsC[i]);	
+                        adm_printf(ADM_PRINT_VERY_VERBOSE,&quot;stts: count:%u size:%u (unscaled)\n&quot;,info.SttsN[i],info.SttsC[i]);
                         //dur*=1000.*1000.;; // us
                         //dur/=myScale;
-                }                
+                }
             }
             break;
        case ADM_MP4_STSC:
@@ -397,10 +397,10 @@
               }
           }
           break;
-           case ADM_MP4_CTTS: // Composition time to sample             
+           case ADM_MP4_CTTS: // Composition time to sample
             {
                 uint32_t n,i,j,k,v;
-                
+
                   printf(&quot;ctts:%lu\n&quot;,son.read32()); // version &amp; flags
                   n=son.read32();
                   if(n==1) // all the same , ignore
@@ -420,12 +420,12 @@
                     sum+=count[i];
                 }
                 info.Ctts=new uint32_t[sum+1]; // keep a safe margin
-                
+
                 for(i=0;i&lt;n;i++)
                 {
                     if(i&lt;20)
                     {
-                        adm_printf(ADM_PRINT_VERY_VERBOSE,&quot;Ctts: nb: %u (%x) val:%u (%x)\n&quot;,count[i],count[i],values[i],values[i]);   
+                        adm_printf(ADM_PRINT_VERY_VERBOSE,&quot;Ctts: nb: %u (%x) val:%u (%x)\n&quot;,count[i],count[i],values[i],values[i]);
                     }
                     for(k=0;k&lt;count[i];k++)
                     {
@@ -443,7 +443,7 @@
                 ADM_assert(info.nbCtts&lt;sum+1);
                 printf(&quot;Found %u elements\n&quot;,info.nbCtts);
             }
-            break;  
+            break;
        case ADM_MP4_STCO:
        {
           son.read32();
@@ -487,7 +487,7 @@
                    left=entrySize-8;
                    if(i || (trackType==TRACK_VIDEO &amp;&amp; _videoFound) || (trackType==TRACK_OTHER))
                    {
-                    son.skipBytes(left); 
+                    son.skipBytes(left);
                     printf(&quot;[STSD] ignoring %s, size %u\n&quot;,fourCC::tostringBE(entryName),entrySize);
                     if(trackType==TRACK_OTHER) printf(&quot;[STSD] because track=other\n&quot;);
                     continue;
@@ -504,23 +504,23 @@
                                 left-=4;
                                 printf(&quot;[STSD] vendor %s\n&quot;,fourCC::tostringBE(son.read32()));
                                 left-=4;
-                                
+
                                 son.skipBytes(8); // spatial qual etc..
                                 left-=8;
-                                
+
                                 printf(&quot;[STSD] width :%u\n&quot;,lw=son.read16());
                                 printf(&quot;[STSD] height :%u\n&quot;,lh=son.read16());
                                 left-=4;
-                                
+
                                 son.skipBytes(8); // Resolution
                                 left-=8;
-                                
+
                                 printf(&quot;[STSD] datasize :%u\n&quot;,son.read32());
                                 left-=4;
-                     
+
                                 printf(&quot;[STSD] FrameCount :%u\n&quot;,son.read16());
                                 left-=4;
-                                
+
                                 // Codec name
                                 uint32_t u32=son.read();
                                 if(u32&gt;31) u32=31;
@@ -529,22 +529,22 @@
                                 printf(&quot;&gt;\n&quot;);
                                 son.skipBytes(32-1-u32);
                                 left-=32;
-                                // 
+                                //
                                 son.read32();
                                 left-=4; //Depth &amp; color Id
                                 //
                                 printf(&quot;LEFT:%d\n&quot;,left);
-                                
+
                                 if(left&gt;8)
                                 {
-//                                  decodeVideoAtom(&amp;son); 
+//                                  decodeVideoAtom(&amp;son);
                                 }
                                 //
 #define commonPart(x)             _videostream.fccHandler=_video_bih.biCompression=fourCC::get((uint8_t *)#x);
-                      
 
-                                 _video_bih.biWidth=_mainaviheader.dwWidth=lw ; 
-                                  _video_bih.biHeight=_mainaviheader.dwHeight=lh; 
+
+                                 _video_bih.biWidth=_mainaviheader.dwWidth=lw ;
+                                  _video_bih.biHeight=_mainaviheader.dwHeight=lh;
                                   _video_bih.biCompression=_videostream.fccHandler;
 
                                 //
@@ -619,13 +619,19 @@
                                           commonPart(H264);
                                           // There is a avcC atom just after
                                           // configuration data for h264
-nextAtom:                                          
+nextAtom:
                                           adm_atom avcc(&amp;son);
                                           printf(&quot;Reading avcC, got %s\n&quot;,fourCC::tostringBE(avcc.getFCC()));
-                                          if(avcc.getFCC()==MKFCCR('c','o','l','r')) // Color atom
+                                          switch(avcc.getFCC())
                                           {
-                                        	  avcc.skipAtom();
-                                        	  goto nextAtom;
+                                              case MKFCCR('a','v','c','C'): break;
+                                              default:
+                                              case MKFCCR('c','o','l','r'):  // Color atom
+                                              case MKFCCR('p','a','s','p'):
+                                              case MKFCCR('c','l','a','p'):
+                                                  avcc.skipAtom();
+                                                  goto nextAtom;
+                                                  break;
                                           }
                                           int len,offset;
                                           VDEO.extraDataSize=avcc.getRemainingSize();
@@ -641,14 +647,14 @@
                                             printf(&quot;avcC AVCProfileIndication :%x\n&quot;, MKD8(1));
                                             printf(&quot;avcC profile_compatibility:%x\n&quot;, MKD8(2));
                                             printf(&quot;avcC AVCLevelIndication   :%x\n&quot;, MKD8(3));
-        
+
                                             printf(&quot;avcC lengthSizeMinusOne   :%x\n&quot;, MKD8(4));
                                             printf(&quot;avcC NumSeq               :%x\n&quot;, MKD8(5));
                                             len=MKD16(6);
                                             printf(&quot;avcC sequenceParSetLen    :%x &quot;,len );
                                             offset=8;
                                             mixDump(VDEO.extraData+offset,len);
-        
+
                                             offset=8+len;
                                             printf(&quot;\navcC numOfPictureParSets  :%x\n&quot;, MKD8(offset++));
                                             len=MKD16(offset);
@@ -664,7 +670,7 @@
                                                 adm_atom avcc(&amp;son);
                                                 printf(&quot;Reading , got %s\n&quot;,fourCC::tostringBE(avcc.getFCC()));
                                                 left=0;
-                                                
+
                                             }
                                             break;
                                 } // Entry name
@@ -673,34 +679,34 @@
                      case TRACK_AUDIO:
                      {
                         uint32_t channels,bpp,encoding,fq,packSize;
-                        
+
                                 // Put some defaults
                                 ADIO.encoding=1234;
                                 ADIO.frequency=44100;
                                 ADIO.byterate=128000&gt;&gt;3;
                                 ADIO.channels=2;
                                 ADIO.bitspersample=16;
-                        
+
                                 printf(&quot;[STSD] AUDIO &lt;%s&gt;, 0x%08x, size %u\n&quot;,fourCC::tostringBE(entryName),entryName,entrySize);
                                 son.skipBytes(8);  // reserved etc..
                                 left-=8;
-                                
+
                                 int atomVersion=son.read16();  // version
                                 left-=2;
                                 printf(&quot;[STSD]Revision       :%d\n&quot;,atomVersion);
                                 son.skipBytes(2);  // revision
                                 left-=2;
-                                
+
                                 printf(&quot;[STSD]Vendor         : %s\n&quot;,fourCC::tostringBE(son.read32()));
                                 left-=4;
-                                
+
                                 ADIO.channels=channels=son.read16(); // Channel
                                 left-=2;
                                 printf(&quot;[STSD]Channels       :%d\n&quot;,ADIO.channels);
                                 ADIO.bitspersample=bpp=son.read16(); // version/revision
                                 left-=2;
                                 printf(&quot;[STSD]Bit per sample :%d\n&quot;,bpp);
-                                
+
                                 encoding=son.read16(); // version/revision
                                 left-=2;
                                 printf(&quot;[STSD]Encoding       :%d\n&quot;,encoding);
@@ -708,8 +714,8 @@
                                 packSize=son.read16(); // Packet Size
                                 left-=2;
                                 printf(&quot;[STSD]Packet size    :%d\n&quot;,encoding);
-                                
-                              
+
+
                                 fq=ADIO.frequency=son.read16();
                                 printf(&quot;[STSD]Fq:%u\n&quot;,fq);
                                 if(ADIO.frequency&lt;6000) ADIO.frequency=48000;
@@ -752,12 +758,12 @@
 #define audioCodec(x) ADIO.encoding=WAV_##x;
                                 switch(entryName)
                                 {
-                                    
+
                                     case MKFCCR('t','w','o','s'):
                                             audioCodec(LPCM);
                                             ADIO.byterate=ADIO.frequency*ADIO.bitspersample*ADIO.channels/8;
                                             break;
-                                                
+
                                     case MKFCCR('u','l','a','w'):
                                             audioCodec(ULAW);
                                             ADIO.byterate=ADIO.frequency;
@@ -839,11 +845,11 @@
                                                           ADIO.blockalign=ADM_swap16(item.read16());
                                                           ADIO.bitspersample=ADM_swap16(item.read16());
                                                           printWavHeader(&amp;(ADIO));
-                                                          
+
                                                         }
                                                        break;
                                                         case MKFCCR('m','p','4','a'):
-                                                          break; 
+                                                          break;
                                                         case MKFCCR('e','s','d','s'):
                                                           {
                                                                decodeEsds(&amp;item,TRACK_AUDIO);
@@ -855,7 +861,7 @@
                                                      }
 
                                                      item.skipAtom();
-                                                   
+
                                                  }  // Wave iddone
                                                  left=0;
                                               }  // if ==wave
@@ -865,25 +871,25 @@
                                                           {
                                                                decodeEsds(&amp;wave,TRACK_AUDIO);
                                                                goto foundit; // FIXME!!!
-                                                          } 
+                                                          }
                                                 else
                                                 {
-                                                  printf(&quot;UNHANDLED ATOM : %s\n&quot;,fourCC::tostringBE(wave.getFCC())); 
+                                                  printf(&quot;UNHANDLED ATOM : %s\n&quot;,fourCC::tostringBE(wave.getFCC()));
                                                 }
                                               }
                                             } // if left &gt; 10
-foundit: // HACK FIXME     
+foundit: // HACK FIXME
                                             left=0;
-                                    }       
+                                    }
                                             break; // mp4a
-                                  
+
                                 }
                      }
                           break;
                      default:
                           ADM_assert(0);
                    }
-                   son.skipBytes(left); 
+                   son.skipBytes(left);
                 }
        }
               break;
@@ -904,7 +910,7 @@
               return 1;
           }
           r=indexify(&amp;(_tracks[0]),trackScale,&amp;info,0,&amp;nbo);
-          
+
           _videostream.dwLength= _mainaviheader.dwTotalFrames=_tracks[0].nbIndex;
           // update fps
           float f=_videostream.dwLength;
@@ -936,7 +942,7 @@
             updateCtts(&amp;info);
           }
 
-          
+
            VDEO.index[0].intra=AVI_KEY_FRAME;
         }
           break;
@@ -960,7 +966,7 @@
                 _tracks[1+nbAudioTrack].scale=trackScale;
                 nbAudioTrack++;
             }
-            
+
             break;
     case TRACK_OTHER:
         r=1;
@@ -974,7 +980,7 @@
 */
 uint8_t MP4Header::decodeEsds(void *ztom,uint32_t trackType)
 {
-adm_atom *tom=(adm_atom *)ztom; 
+adm_atom *tom=(adm_atom *)ztom;
 int tag,l;
             // in case of mpeg4 we only take
             // the mpeg4 vol header
@@ -1006,10 +1012,10 @@
                                           case 0x6d:ADIO.encoding=WAV_MP3;break;
                                           case 226:ADIO.encoding=WAV_AC3;break;
                                           break;
-                                  
+
                                       }
                                     }
-                                    tom-&gt;skipBytes(1+3+4+4);	
+                                    tom-&gt;skipBytes(1+3+4+4);
                                     break;
                             }
                             case Tag_DecSpecificInfo:
@@ -1035,7 +1041,7 @@
                                     }
                             }
             }
-            
+
     tom-&gt;skipAtom();
     return 1;
 }
@@ -1046,15 +1052,15 @@
 uint8_t MP4Header::updateCtts(MPsampleinfo *info )
 {
     uint32_t scope=info-&gt;nbCtts;
-            
+
             if(scope&gt;_videostream.dwLength) scope=_videostream.dwLength;
-            
+
             // Search floor value
             uint32_t  flor=0xFFFFFFFF;
             uint32_t  cel=0;
             for(uint32_t i=0;i&lt;scope;i++)
             {
-              if(info-&gt;Ctts[i]&gt;4294967290) 
+              if(info-&gt;Ctts[i]&gt;4294967290)
               {
                 if(i)
                   info-&gt;Ctts[i]=info-&gt;Ctts[0];
@@ -1078,7 +1084,7 @@
                 aprintf(&quot;&gt;Frame :%u delta=%d\n&quot;,i,floops);
               if(floops&lt;0)
               {
-                printf(&quot;[3GPP] CTTS negative for frame %u : %d\n&quot;,i,floops); 
+                printf(&quot;[3GPP] CTTS negative for frame %u : %d\n&quot;,i,floops);
                 floops=0;
               }
               _tracks[0].index[i].deltaPtsDts=floops;

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/gtk_gui.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/gtk_gui.cpp	2008-06-16 17:49:32 UTC (rev 4111)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/gtk_gui.cpp	2008-06-16 18:07:45 UTC (rev 4112)
@@ -808,6 +808,7 @@
 	  video_body-&gt;updateVideoInfo (&amp;info);
 	  // update display
 	  video_body-&gt;getVideoInfo (avifileinfo);
+          rebuild_status_bar();
 	 }
 	}
       break;

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CMakeLists.txt	2008-06-16 17:49:32 UTC (rev 4111)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CMakeLists.txt	2008-06-16 18:07:45 UTC (rev 4112)
@@ -54,3 +54,5 @@
 ADD_SUBDIRECTORY(Srt)
 ADD_SUBDIRECTORY(Ass)
 # Dependancy toward codec &amp; pics ADD_SUBDIRECTORY(Animated)
+#ADD_SUBDIRECTORY(leakKernelDeint)
+ADD_SUBDIRECTORY(TIsophote)

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/TIsophote/ADM_vidTisophote.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/TIsophote/ADM_vidTisophote.cpp	2008-06-16 17:49:32 UTC (rev 4111)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/TIsophote/ADM_vidTisophote.cpp	2008-06-16 18:07:45 UTC (rev 4112)
@@ -0,0 +1,493 @@
+/***************************************************************************
+                       \file TIsophote.cpp
+                       \brief Port of TIsophote by Tritical <A HREF="http://bengal.missouri.edu/~kes25c/">http://bengal.missouri.edu/~kes25c/</A>
+     ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+/*
+**                     TIsophote v0.9.1 for AviSynth 2.5.x
+**
+**   TIsophote is a simple unconstrained level-set (isophote) smoothing filter.
+**
+**   Copyright (C) 2004 Kevin Stone
+**
+**   This program is free software; you can redistribute it and/or modify
+**   it under the terms of the GNU General Public License as published by
+**   the Free Software Foundation; either version 2 of the License, or
+**   (at your option) any later version.
+**
+**   This program is distributed in the hope that it will be useful,
+**   but WITHOUT ANY WARRANTY; without even the implied warranty of
+**   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**   GNU General Public License for more details.
+**
+**   You should have received a copy of the GNU General Public License
+**   along with this program; if not, write to the Free Software
+**   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#include &quot;ADM_default.h&quot;
+#include &quot;ADM_videoFilterDynamic.h&quot;
+#include &quot;ADM_vidTisophote.h&quot;
+
+#include &quot;DIA_factory.h&quot;
+static FILTER_PARAM kdintParam={4,{&quot;iterations&quot;,&quot;tStep&quot;,&quot;type&quot;,&quot;chroma&quot;}};
+
+
+VF_DEFINE_FILTER(ADMVideoTIsophote,kdintParam,
+    tisophote,
+                QT_TR_NOOP(&quot;TIsophote&quot;),
+                1,
+                VF_NOISE,
+                QT_TR_NOOP(&quot;Port of TIsophote by tritical .&quot;));
+
+
+
+
+
+uint8_t ADMVideoTIsophote::configure( AVDMGenericVideoStream *instream)
+{
+  #define PX(x) &amp;(_param-&gt;x)
+_in=instream;
+
+   diaMenuEntry menuField[3]={{0,QT_TR_NOOP(&quot;Simple&quot;),NULL},
+                             {1,QT_TR_NOOP(&quot;Medium&quot;),NULL},
+                             {2,QT_TR_NOOP(&quot;Slow&quot;),NULL}
+                          };
+
+
+    diaElemMenu     menu1(PX(type),QT_TR_NOOP(&quot;_Type:&quot;), 3,menuField);
+    diaElemUInteger iterations(PX(iterations),QT_TR_NOOP(&quot;_Iterations:&quot;),1,10,QT_TR_NOOP(&quot;Smaller means more deinterlacing&quot;));
+    diaElemToggle   chroma(PX(chroma),QT_TR_NOOP(&quot;_Chroma:&quot;),QT_TR_NOOP(&quot;Process chroma.&quot;));
+    diaElemFloat   step(PX(tStep),QT_TR_NOOP(&quot;_Step:&quot;),0,1,QT_TR_NOOP(&quot;Step.&quot;));
+
+    diaElem *elems[4]={&amp;menu1,&amp;iterations,&amp;chroma,&amp;step};
+
+   return  diaFactoryRun(QT_TR_NOOP(&quot;KernelDeint&quot;),4,elems);
+}
+uint8_t	ADMVideoTIsophote::getCoupledConf( CONFcouple **couples)
+{
+
+			*couples=new CONFcouple(4);
+			CSET(iterations);
+			CSET(tStep);
+			CSET(type);
+			CSET(chroma);
+
+		return 1;
+}
+char *ADMVideoTIsophote::printConf( void )
+{
+ 	static char buf[50];
+
+ 	sprintf((char *)buf,&quot; TIsoPhote by Tritical&quot;);
+        return buf;
+}
+
+ADMVideoTIsophote::~ADMVideoTIsophote()
+{
+ if(vidCache) delete vidCache;
+ if(_param) delete _param;
+  if(dst1) delete dst1;
+  if(dst2) delete dst2;
+}
+
+
+ ADMVideoTIsophote::ADMVideoTIsophote( AVDMGenericVideoStream *in,CONFcouple *couples)
+{
+
+		if(!couples)
+		{
+			_param=NEW(TISO_CONF);
+	    		_param-&gt;iterations=4;
+	    		_param-&gt;tStep=0.2;
+	    		_param-&gt;type=0;
+	    		_param-&gt;chroma=0;
+		}
+		else
+		{
+			_param=NEW(TISO_CONF);
+			GET(iterations);
+			GET(tStep);
+			GET(type);
+			GET(chroma);
+
+
+		}
+	    debug=0;
+	    _in=in;
+
+	   _uncompressed=NULL;
+
+  	memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info));
+	vidCache=new VideoCache(4,_in);
+    dst1=new ADMImage(_info.width,_info.height);
+    dst2=new ADMImage(_info.width,_info.height);
+
+}
+/**
+    \fn getFrameNumberNoAlloc
+    \brief Get a processed image
+
+*/
+uint8_t ADMVideoTIsophote::getFrameNumberNoAlloc(uint32_t frame,
+							uint32_t *len,
+							ADMImage *data,
+							uint32_t *flags)
+{
+  // Get the current frame.
+  uint32_t n=frame;
+
+    if(frame&gt;_info.nb_frames-1) return 0;
+
+    ADMImage *mysrc=NULL;
+    mysrc=vidCache-&gt;getImage(frame);
+
+    //*****
+    ADMImage *src = vidCache-&gt;getImage(n);
+
+	unsigned char *srcp1 = src-&gt;GetReadPtr(PLANAR_Y);
+	int src1_pitch = src-&gt;GetPitch(PLANAR_Y);
+	int width = src-&gt;GetRowSize(PLANAR_Y) - 1;
+	int height = src-&gt;GetHeight(PLANAR_Y) - 1;
+	unsigned char *srcpp, *srcp, *srcpn;
+	unsigned char *dstp1 = dst1-&gt;GetWritePtr(PLANAR_Y);
+	int dst1_pitch = dst1-&gt;GetPitch(PLANAR_Y);
+	unsigned char *dstp2 = dst2-&gt;GetWritePtr(PLANAR_Y);
+	int dst2_pitch = dst2-&gt;GetPitch(PLANAR_Y);
+	unsigned char *dstp;
+	double off = 0.0000000001;
+	int x, y, b, dst_pitch, src_pitch, temp;
+	int Ix, Ix2, Iy, Iy2, Ixy, Ixx, Iyy;
+	BitBlit(dstp1,dst1_pitch,srcp1,src1_pitch,width+1,height+1);
+	BitBlit(dstp2,dst2_pitch,srcp1,src1_pitch,width+1,height+1);
+	for (b=0; b&lt;_param-&gt;iterations; ++b)
+	{
+		if (b&amp;1)
+		{
+			srcp = dstp2 + dst2_pitch;
+			src_pitch = dst2_pitch;
+			srcpp = srcp - src_pitch;
+			srcpn = srcp + src_pitch;
+			dstp = dstp1 + dst1_pitch;
+			dst_pitch = dst1_pitch;
+		}
+		else
+		{
+			srcp = dstp1 + dst1_pitch;
+			src_pitch = dst1_pitch;
+			srcpp = srcp - src_pitch;
+			srcpn = srcp + src_pitch;
+			dstp = dstp2 + dst2_pitch;
+			dst_pitch = dst2_pitch;
+		}
+		if (_param-&gt;type == 0)
+		{
+			for (y=1; y&lt;height; ++y)
+			{
+				for (x=1; x&lt;width; ++x)
+				{
+					Ix = srcp[x+1] - srcp[x-1];
+					Ix2 = Ix*Ix;
+					Iy = srcpn[x] - srcpp[x];
+					Iy2 = Iy*Iy;
+					Ixy = srcpp[x-1] - srcpp[x+1] - srcpn[x-1] + srcpn[x+1];
+					Ixx = srcp[x+1] + srcp[x-1] - srcp[x] - srcp[x];
+					Iyy = srcpp[x] + srcpn[x] - srcp[x] - srcp[x];
+					temp = srcp[x] + ((int)((((Ix2*Iyy - Ix*Iy*Ixy + Iy2*Ixx)*_param-&gt;tStep) / (((Ix2 + Iy2) &lt;&lt; 1) + off)) + 0.5f));
+					if (temp &gt; 255) temp = 255;
+					else if (temp &lt; 0) temp = 0;
+					dstp[x] = temp;
+				}
+				srcpp += src_pitch;
+				srcp += src_pitch;
+				srcpn += src_pitch;
+				dstp += dst_pitch;
+			}
+		}
+		else if (_param-&gt;type == 1)
+		{
+			for (y=1; y&lt;height; ++y)
+			{
+				for (x=1; x&lt;width; ++x)
+				{
+					Ix = srcpp[x+1]+srcp[x+1]+srcp[x+1]+srcpn[x+1]-srcpp[x-1]-srcp[x-1]-srcp[x-1]-srcpn[x-1];
+					Ix2 = Ix*Ix;
+					Iy = srcpn[x-1]+srcpn[x]+srcpn[x]+srcpn[x+1]-srcpp[x-1]-srcpp[x]-srcpp[x]-srcpp[x+1];
+					Iy2 = Iy*Iy;
+					Ixy = srcpp[x-1] - srcpp[x+1] - srcpn[x-1] + srcpn[x+1];
+					Ixx = srcp[x+1] + srcp[x-1] - srcp[x] - srcp[x];
+					Iyy = srcpp[x] + srcpn[x] - srcp[x] - srcp[x];
+					temp = srcp[x] + ((int)((((Ix2*Iyy - Ix*Iy*Ixy + Iy2*Ixx)*_param-&gt;tStep) / (((Ix2 + Iy2) &lt;&lt; 1) + off)) + 0.5f));
+					if (temp &gt; 255) temp = 255;
+					else if (temp &lt; 0) temp = 0;
+					dstp[x] = temp;
+				}
+				srcpp += src_pitch;
+				srcp += src_pitch;
+				srcpn += src_pitch;
+				dstp += dst_pitch;
+			}
+		}
+		else
+		{
+			for (y=1; y&lt;height; ++y)
+			{
+				for (x=1; x&lt;width; ++x)
+				{
+					Ix = srcpp[x+1]+srcp[x+1]+srcp[x+1]+srcpn[x+1]-srcpp[x-1]-srcp[x-1]-srcp[x-1]-srcpn[x-1];
+					Ix2 = Ix*Ix;
+					Iy = srcpn[x-1]+srcpn[x]+srcpn[x]+srcpn[x+1]-srcpp[x-1]-srcpp[x]-srcpp[x]-srcpp[x+1];
+					Iy2 = Iy*Iy;
+					Ixy = srcpp[x-1] - srcpp[x+1] - srcpn[x-1] + srcpn[x+1];
+					Ixx = srcpp[x+1] + srcp[x+1] + srcp[x+1] + srcpn[x+1] + srcpp[x-1] + srcp[x-1] +
+						srcp[x-1] + srcpn[x-1] - (srcpp[x]&lt;&lt;1) - (srcp[x]&lt;&lt;2) - (srcpn[x]&lt;&lt;1);
+					Iyy = srcpp[x-1] + srcpp[x] + srcpp[x] + srcpp[x+1] + srcpn[x-1] + srcpn[x] +
+						srcpn[x] + srcpn[x+1] - (srcp[x-1]&lt;&lt;1) - (srcp[x]&lt;&lt;2) - (srcp[x+1]&lt;&lt;1);
+					temp = srcp[x] + ((int)((((Ix2*Iyy - 4*Ix*Iy*Ixy + Iy2*Ixx)*_param-&gt;tStep) / (((Ix2 + Iy2) &lt;&lt; 3) + off)) + 0.5f));
+					if (temp &gt; 255) temp = 255;
+					else if (temp &lt; 0) temp = 0;
+					dstp[x] = temp;
+				}
+				srcpp += src_pitch;
+				srcp += src_pitch;
+				srcpn += src_pitch;
+				dstp += dst_pitch;
+			}
+		}
+	}
+	srcp1 = src-&gt;GetReadPtr(PLANAR_U);
+	src1_pitch = src-&gt;GetPitch(PLANAR_U);
+	width = src-&gt;GetRowSize(PLANAR_U) - 1;
+	height = src-&gt;GetHeight(PLANAR_U) - 1;
+	dstp1 = dst1-&gt;GetWritePtr(PLANAR_U);
+	dst1_pitch = dst1-&gt;GetPitch(PLANAR_U);
+	dstp2 = dst2-&gt;GetWritePtr(PLANAR_U);
+	dst2_pitch = dst2-&gt;GetPitch(PLANAR_U);
+	if (_param-&gt;chroma)
+	{
+		BitBlit(dstp1,dst1_pitch,srcp1,src1_pitch,width+1,height+1);
+		BitBlit(dstp2,dst2_pitch,srcp1,src1_pitch,width+1,height+1);
+		for (b=0; b&lt;_param-&gt;iterations; ++b)
+		{
+			if (b&amp;1)
+			{
+				srcp = dstp2 + dst2_pitch;
+				src_pitch = dst2_pitch;
+				srcpp = srcp - src_pitch;
+				srcpn = srcp + src_pitch;
+				dstp = dstp1 + dst1_pitch;
+				dst_pitch = dst1_pitch;
+			}
+			else
+			{
+				srcp = dstp1 + dst1_pitch;
+				src_pitch = dst1_pitch;
+				srcpp = srcp - src_pitch;
+				srcpn = srcp + src_pitch;
+				dstp = dstp2 + dst2_pitch;
+				dst_pitch = dst2_pitch;
+			}
+			if (_param-&gt;type == 0)
+			{
+				for (y=1; y&lt;height; ++y)
+				{
+					for (x=1; x&lt;width; ++x)
+					{
+						Ix = srcp[x+1] - srcp[x-1];
+						Ix2 = Ix*Ix;
+						Iy = srcpn[x] - srcpp[x];
+						Iy2 = Iy*Iy;
+						Ixy = srcpp[x-1] - srcpp[x+1] - srcpn[x-1] + srcpn[x+1];
+						Ixx = srcp[x+1] + srcp[x-1] - srcp[x] - srcp[x];
+						Iyy = srcpp[x] + srcpn[x] - srcp[x] - srcp[x];
+						temp = srcp[x] + ((int)((((Ix2*Iyy - Ix*Iy*Ixy + Iy2*Ixx)*_param-&gt;tStep) / (((Ix2 + Iy2) &lt;&lt; 1) + off)) + 0.5f));
+						if (temp &gt; 255) temp = 255;
+						else if (temp &lt; 0) temp = 0;
+						dstp[x] = temp;
+					}
+					srcpp += src_pitch;
+					srcp += src_pitch;
+					srcpn += src_pitch;
+					dstp += dst_pitch;
+				}
+			}
+			else if (_param-&gt;type == 1)
+			{
+				for (y=1; y&lt;height; ++y)
+				{
+					for (x=1; x&lt;width; ++x)
+					{
+						Ix = srcpp[x+1]+srcp[x+1]+srcp[x+1]+srcpn[x+1]-srcpp[x-1]-srcp[x-1]-srcp[x-1]-srcpn[x-1];
+						Ix2 = Ix*Ix;
+						Iy = srcpn[x-1]+srcpn[x]+srcpn[x]+srcpn[x+1]-srcpp[x-1]-srcpp[x]-srcpp[x]-srcpp[x+1];
+						Iy2 = Iy*Iy;
+						Ixy = srcpp[x-1] - srcpp[x+1] - srcpn[x-1] + srcpn[x+1];
+						Ixx = srcp[x+1] + srcp[x-1] - srcp[x] - srcp[x];
+						Iyy = srcpp[x] + srcpn[x] - srcp[x] - srcp[x];
+						temp = srcp[x] + ((int)((((Ix2*Iyy - Ix*Iy*Ixy + Iy2*Ixx)*_param-&gt;tStep) / (((Ix2 + Iy2) &lt;&lt; 1) + off)) + 0.5f));
+						if (temp &gt; 255) temp = 255;
+						else if (temp &lt; 0) temp = 0;
+						dstp[x] = temp;
+					}
+					srcpp += src_pitch;
+					srcp += src_pitch;
+					srcpn += src_pitch;
+					dstp += dst_pitch;
+				}
+			}
+			else
+			{
+				for (y=1; y&lt;height; ++y)
+				{
+					for (x=1; x&lt;width; ++x)
+					{
+						Ix = srcpp[x+1]+srcp[x+1]+srcp[x+1]+srcpn[x+1]-srcpp[x-1]-srcp[x-1]-srcp[x-1]-srcpn[x-1];
+						Ix2 = Ix*Ix;
+						Iy = srcpn[x-1]+srcpn[x]+srcpn[x]+srcpn[x+1]-srcpp[x-1]-srcpp[x]-srcpp[x]-srcpp[x+1];
+						Iy2 = Iy*Iy;
+						Ixy = srcpp[x-1] - srcpp[x+1] - srcpn[x-1] + srcpn[x+1];
+						Ixx = srcpp[x+1] + srcp[x+1] + srcp[x+1] + srcpn[x+1] + srcpp[x-1] + srcp[x-1] +
+							srcp[x-1] + srcpn[x-1] - (srcpp[x]&lt;&lt;1) - (srcp[x]&lt;&lt;2) - (srcpn[x]&lt;&lt;1);
+						Iyy = srcpp[x-1] + srcpp[x] + srcpp[x] + srcpp[x+1] + srcpn[x-1] + srcpn[x] +
+							srcpn[x] + srcpn[x+1] - (srcp[x-1]&lt;&lt;1) - (srcp[x]&lt;&lt;2) - (srcp[x+1]&lt;&lt;1);
+						temp = srcp[x] + ((int)((((Ix2*Iyy - 4*Ix*Iy*Ixy + Iy2*Ixx)*_param-&gt;tStep) / (((Ix2 + Iy2) &lt;&lt; 3) + off)) + 0.5f));
+						if (temp &gt; 255) temp = 255;
+						else if (temp &lt; 0) temp = 0;
+						dstp[x] = temp;
+					}
+					srcpp += src_pitch;
+					srcp += src_pitch;
+					srcpn += src_pitch;
+					dstp += dst_pitch;
+				}
+			}
+		}
+		srcp1 = src-&gt;GetReadPtr(PLANAR_V);
+		dstp1 = dst1-&gt;GetWritePtr(PLANAR_V);
+		dstp2 = dst2-&gt;GetWritePtr(PLANAR_V);
+		BitBlit(dstp1,dst1_pitch,srcp1,src1_pitch,width+1,height+1);
+		BitBlit(dstp2,dst2_pitch,srcp1,src1_pitch,width+1,height+1);
+		for (b=0; b&lt;_param-&gt;iterations; ++b)
+		{
+			if (b&amp;1)
+			{
+				srcp = dstp2 + dst2_pitch;
+				src_pitch = dst2_pitch;
+				srcpp = srcp - src_pitch;
+				srcpn = srcp + src_pitch;
+				dstp = dstp1 + dst1_pitch;
+				dst_pitch = dst1_pitch;
+			}
+			else
+			{
+				srcp = dstp1 + dst1_pitch;
+				src_pitch = dst1_pitch;
+				srcpp = srcp - src_pitch;
+				srcpn = srcp + src_pitch;
+				dstp = dstp2 + dst2_pitch;
+				dst_pitch = dst2_pitch;
+			}
+			if (_param-&gt;type == 0)
+			{
+				for (y=1; y&lt;height; ++y)
+				{
+					for (x=1; x&lt;width; ++x)
+					{
+						Ix = srcp[x+1] - srcp[x-1];
+						Ix2 = Ix*Ix;
+						Iy = srcpn[x] - srcpp[x];
+						Iy2 = Iy*Iy;
+						Ixy = srcpp[x-1] - srcpp[x+1] - srcpn[x-1] + srcpn[x+1];
+						Ixx = srcp[x+1] + srcp[x-1] - srcp[x] - srcp[x];
+						Iyy = srcpp[x] + srcpn[x] - srcp[x] - srcp[x];
+						temp = srcp[x] + ((int)((((Ix2*Iyy - Ix*Iy*Ixy + Iy2*Ixx)*_param-&gt;tStep) / (((Ix2 + Iy2) &lt;&lt; 1) + off)) + 0.5f));
+						if (temp &gt; 255) temp = 255;
+						else if (temp &lt; 0) temp = 0;
+						dstp[x] = temp;
+					}
+					srcpp += src_pitch;
+					srcp += src_pitch;
+					srcpn += src_pitch;
+					dstp += dst_pitch;
+				}
+			}
+			else if (_param-&gt;type == 1)
+			{
+				for (y=1; y&lt;height; ++y)
+				{
+					for (x=1; x&lt;width; ++x)
+					{
+						Ix = srcpp[x+1]+srcp[x+1]+srcp[x+1]+srcpn[x+1]-srcpp[x-1]-srcp[x-1]-srcp[x-1]-srcpn[x-1];
+						Ix2 = Ix*Ix;
+						Iy = srcpn[x-1]+srcpn[x]+srcpn[x]+srcpn[x+1]-srcpp[x-1]-srcpp[x]-srcpp[x]-srcpp[x+1];
+						Iy2 = Iy*Iy;
+						Ixy = srcpp[x-1] - srcpp[x+1] - srcpn[x-1] + srcpn[x+1];
+						Ixx = srcp[x+1] + srcp[x-1] - srcp[x] - srcp[x];
+						Iyy = srcpp[x] + srcpn[x] - srcp[x] - srcp[x];
+						temp = srcp[x] + ((int)((((Ix2*Iyy - Ix*Iy*Ixy + Iy2*Ixx)*_param-&gt;tStep) / (((Ix2 + Iy2) &lt;&lt; 1) + off)) + 0.5f));
+						if (temp &gt; 255) temp = 255;
+						else if (temp &lt; 0) temp = 0;
+						dstp[x] = temp;
+					}
+					srcpp += src_pitch;
+					srcp += src_pitch;
+					srcpn += src_pitch;
+					dstp += dst_pitch;
+				}
+			}
+			else
+			{
+				for (y=1; y&lt;height; ++y)
+				{
+					for (x=1; x&lt;width; ++x)
+					{
+						Ix = srcpp[x+1]+srcp[x+1]+srcp[x+1]+srcpn[x+1]-srcpp[x-1]-srcp[x-1]-srcp[x-1]-srcpn[x-1];
+						Ix2 = Ix*Ix;
+						Iy = srcpn[x-1]+srcpn[x]+srcpn[x]+srcpn[x+1]-srcpp[x-1]-srcpp[x]-srcpp[x]-srcpp[x+1];
+						Iy2 = Iy*Iy;
+						Ixy = srcpp[x-1] - srcpp[x+1] - srcpn[x-1] + srcpn[x+1];
+						Ixx = srcpp[x+1] + srcp[x+1] + srcp[x+1] + srcpn[x+1] + srcpp[x-1] + srcp[x-1] +
+							srcp[x-1] + srcpn[x-1] - (srcpp[x]&lt;&lt;1) - (srcp[x]&lt;&lt;2) - (srcpn[x]&lt;&lt;1);
+						Iyy = srcpp[x-1] + srcpp[x] + srcpp[x] + srcpp[x+1] + srcpn[x-1] + srcpn[x] +
+							srcpn[x] + srcpn[x+1] - (srcp[x-1]&lt;&lt;1) - (srcp[x]&lt;&lt;2) - (srcp[x+1]&lt;&lt;1);
+						temp = srcp[x] + ((int)((((Ix2*Iyy - 4*Ix*Iy*Ixy + Iy2*Ixx)*_param-&gt;tStep) / (((Ix2 + Iy2) &lt;&lt; 3) + off)) + 0.5f));
+						if (temp &gt; 255) temp = 255;
+						else if (temp &lt; 0) temp = 0;
+						dstp[x] = temp;
+					}
+					srcpp += src_pitch;
+					srcp += src_pitch;
+					srcpn += src_pitch;
+					dstp += dst_pitch;
+				}
+			}
+		}
+	}
+	else
+	{
+		if (_param-&gt;iterations&amp;1) BitBlit(dstp2,dst2_pitch,srcp1,src1_pitch,width+1,height+1);
+		else BitBlit(dstp1,dst1_pitch,srcp1,src1_pitch,width+1,height+1);
+		srcp1 = src-&gt;GetReadPtr(PLANAR_V);
+		dstp1 = dst1-&gt;GetWritePtr(PLANAR_V);
+		dstp2 = dst2-&gt;GetWritePtr(PLANAR_V);
+		if (_param-&gt;iterations&amp;1) BitBlit(dstp2,dst2_pitch,srcp1,src1_pitch,width+1,height+1);
+		else BitBlit(dstp1,dst1_pitch,srcp1,src1_pitch,width+1,height+1);
+	}
+	if (_param-&gt;iterations&amp;1) data-&gt;duplicate(dst2);
+        else data-&gt;duplicate(dst1);
+
+    //*****
+    vidCache-&gt;unlockAll();
+    return 1;
+
+}
+
+//***

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/TIsophote/ADM_vidTisophote.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/TIsophote/ADM_vidTisophote.h	2008-06-16 17:49:32 UTC (rev 4111)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/TIsophote/ADM_vidTisophote.h	2008-06-16 18:07:45 UTC (rev 4112)
@@ -0,0 +1,57 @@
+/*
+**                     TIsophote v0.9.1 for AviSynth 2.5.x
+**
+**   TIsophote is a simple unconstrained level-set (isophote) smoothing filter.
+**
+**   Copyright (C) 2004 Kevin Stone
+**
+**   This program is free software; you can redistribute it and/or modify
+**   it under the terms of the GNU General Public License as published by
+**   the Free Software Foundation; either version 2 of the License, or
+**   (at your option) any later version.
+**
+**   This program is distributed in the hope that it will be useful,
+**   but WITHOUT ANY WARRANTY; without even the implied warranty of
+**   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**   GNU General Public License for more details.
+**
+**   You should have received a copy of the GNU General Public License
+**   along with this program; if not, write to the Free Software
+**   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#ifndef ADM_TISOPHOTE
+#define ADM_TISOPHOTE
+
+typedef struct  TISO_CONF
+{
+    uint32_t        iterations ; //  int 4
+    float           tStep;        // float 0.2
+    uint32_t        type;         // drop down 0--2 2
+    uint32_t        chroma;       // bool 0
+}KERNEL_CONF;
+
+class  ADMVideoTIsophote:public AVDMGenericVideoStream
+ {
+
+ protected:
+        virtual char 		*printConf(void) ;
+	TISO_CONF		*_param;
+        int			 debug;
+	VideoCache		*vidCache;
+        ADMImage    *dst1;
+        ADMImage    *dst2;
+
+
+ public:
+
+  			ADMVideoTIsophote(  AVDMGenericVideoStream *in,CONFcouple *setup);
+  			~ADMVideoTIsophote();
+	virtual uint8_t getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
+						ADMImage *data,uint32_t *flags);
+	virtual uint8_t	getCoupledConf( CONFcouple **couples)		;
+	virtual uint8_t configure( AVDMGenericVideoStream *instream);
+
+};
+
+#endif

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/TIsophote/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/TIsophote/CMakeLists.txt	2008-06-16 17:49:32 UTC (rev 4111)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/TIsophote/CMakeLists.txt	2008-06-16 18:07:45 UTC (rev 4112)
@@ -0,0 +1,9 @@
+INCLUDE(vf_plugin)
+
+
+SET(ADM_vf_Tisophote_SRCS ADM_vidTisophote.cpp)
+
+ADD_LIBRARY(ADM_vf_Tisophote SHARED ${ADM_vf_Tisophote_SRCS})
+
+INIT_VIDEOFILTER_PLUGIN(ADM_vf_Tisophote)
+INSTALL_VIDEOFILTER(ADM_vf_Tisophote)

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/TIsophote/HELP FILE.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/TIsophote/HELP FILE.txt	2008-06-16 17:49:32 UTC (rev 4111)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/TIsophote/HELP FILE.txt	2008-06-16 18:07:45 UTC (rev 4112)
@@ -0,0 +1,118 @@
+                                                                                                      |
+                                   TIsophote for AviSynth v2.5.x                                      |
+                                       v0.9.1 (24 July 2004)                                          |
+                                            by tritical                                               |
+                                                                                                      |
+                                             HELP FILE                                                |
+-------------------------------------------------------------------------------------------------------
+-------------------------------------------------------------------------------------------------------
+
+
+INFO:
+
+
+      TIsophote is a level-set (isophote) smoothing filter.  It does simple unconstrained level-set
+   smoothing.  Basically, it can smooth jagged edges in an image.  If over used it will remove jagged 
+   edges as well as object features and eventually completely eliminate all level curves. For a more 
+   in-depth explanation see the technical info towards the bottom of the help file. 
+
+    Or for more info (includes information besides simple unconstrained smoothing):
+
+              <A HREF="http://neuron2.net/library/LSImageReconstruction.pdf">http://neuron2.net/library/LSImageReconstruction.pdf</A>
+
+   Syntax =&gt;    TIsophote(int iterations, float tStep, int type, bool chroma)
+
+
+
+PARAMETERS:
+
+
+   iterations
+  
+      Sets the number of iterations used.  More iterations will take more processing time.
+      Increasing the number of iterations while holding tStep constant will result in more and
+      more shortening of the level curves.  Total 'time' of the filter is equal to -
+      iterations*tStep. iterations must be set to at least 1.
+
+      default -  4  (int)
+
+
+   tStep
+
+      Sets the update per iteration.  At 1.0, each iteration is a full cycle of the flow equation.
+      At 0, the original image is always returned.  Generally, lower values produce more &quot;stable&quot;
+      flow but require more iterations.  Recommended values are between 0.1 and 0.5, though setting
+      this to 1.0 is usually ok and simply results in an extra overall smoothing.  While this
+      value can be anything, it really only makes sense when it is 0.0 &lt;= tStep &lt;= 1.0, other values
+      will generally result in garbage output.  This setting could be seen as a strength of smoothing
+      per iteration setting (1.0 being strongest, 0.0 being nothing).  Note:  technically for long run
+      numerical stability this value must be less then 0.25!
+
+      default -  0.2  (float)
+
+
+   type
+
+      Sets how the needed derivatives are calculated.
+
+         type 0 - simplest possible estimate of both first and second derivatives 
+                  (fastest, probably best clean video)
+
+         type 1 - sobel operator for first derivatives, simple estimate for second
+                  (in-between 0 and 2 speed wise and noise wise)
+
+         type 2 - sobel operator for first and similar inherent denoising operator for second
+                  (slowest, probably best for noisy video)   
+  
+      default -  2 (int)
+
+
+   chroma
+
+      If set to true the chroma planes are processed.  If set to false the chroma planes from the
+      source are simply copied to the output frame.
+
+      default - false  (bool)
+   
+
+
+TECHNICAL INFO:
+
+
+   The filter operation is really quite simple, all it does is use the following equation to update the 
+   value of each pixel in the frame after each iteration.
+
+    I(n) = a pixel in the frame at iteration n
+
+    I(n+1) = I(n) + It
+
+    It = ((Ix*Ix*Iyy + 2*Ix*Iy*Ixy + Iy*Iy*Ixx) * tStep) / (Ix*Ix + Iy*Iy + e)
+
+        - e = a very small constant (ex. 10^-10) to prevent division by 0
+        - Ix, Iy, Ixy, Iyy, Ixx are the first and second derivatives of
+          the image at the current pixel location, i.e.
+             Ix = first derivative in x direction
+             Iy = first derivative in y direction, etc...
+      
+
+
+CHANGE LIST:
+
+   07/24/2004  v0.9.1
+       - Changed default values for iterations, type, and chroma parameters
+       - Fixed incorrect clipping for values below 0.  Pixel values were clipped 
+            to 0-255 range but values below 0 were getting clipped to abs(pixel)
+            instead of 0 which would lead to artifacts.
+
+   06/25/2004  v0.9
+       - Initial Release
+
+
+
+TO DO LIST:  
+
+     - bug fixes as needed
+
+
+
+contact:    doom9.org forum (nick = tritical)

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/TIsophote/original/TIsophote.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/TIsophote/original/TIsophote.cpp	2008-06-16 17:49:32 UTC (rev 4111)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/TIsophote/original/TIsophote.cpp	2008-06-16 18:07:45 UTC (rev 4112)
@@ -0,0 +1,647 @@
+/*
+**                     TIsophote v0.9.1 for AviSynth 2.5.x
+**
+**   TIsophote is a simple unconstrained level-set (isophote) smoothing filter.
+**
+**   Copyright (C) 2004 Kevin Stone
+**
+**   This program is free software; you can redistribute it and/or modify
+**   it under the terms of the GNU General Public License as published by
+**   the Free Software Foundation; either version 2 of the License, or
+**   (at your option) any later version.
+**
+**   This program is distributed in the hope that it will be useful,
+**   but WITHOUT ANY WARRANTY; without even the implied warranty of
+**   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**   GNU General Public License for more details.
+**
+**   You should have received a copy of the GNU General Public License
+**   along with this program; if not, write to the Free Software
+**   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#include &quot;TIsophote.h&quot;
+
+PVideoFrame __stdcall TIsophote::GetFrame(int n, IScriptEnvironment* env) 
+{
+	if (n&lt;0) n = 0;
+	else if (n&gt;nfrms) n = nfrms;
+	if (vi.IsYV12()) return(GetFrameYV12(n, env));
+	else return(GetFrameYUY2(n, env));
+}
+
+PVideoFrame __stdcall TIsophote::GetFrameYV12(int n, IScriptEnvironment* env) 
+{
+	PVideoFrame src = child-&gt;GetFrame(n, env);
+	PVideoFrame dst1 = env-&gt;NewVideoFrame(vi);
+	PVideoFrame dst2 = env-&gt;NewVideoFrame(vi);
+	const unsigned char *srcp1 = src-&gt;GetReadPtr(PLANAR_Y);
+	int src1_pitch = src-&gt;GetPitch(PLANAR_Y);
+	int width = src-&gt;GetRowSize(PLANAR_Y) - 1;
+	int height = src-&gt;GetHeight(PLANAR_Y) - 1;
+	unsigned char *srcpp, *srcp, *srcpn;
+	unsigned char *dstp1 = dst1-&gt;GetWritePtr(PLANAR_Y);
+	int dst1_pitch = dst1-&gt;GetPitch(PLANAR_Y);
+	unsigned char *dstp2 = dst2-&gt;GetWritePtr(PLANAR_Y);
+	int dst2_pitch = dst2-&gt;GetPitch(PLANAR_Y);
+	unsigned char *dstp;
+	double off = 0.0000000001;
+	int x, y, b, dst_pitch, src_pitch, temp;
+	int Ix, Ix2, Iy, Iy2, Ixy, Ixx, Iyy;
+	env-&gt;BitBlt(dstp1,dst1_pitch,srcp1,src1_pitch,width+1,height+1);
+	env-&gt;BitBlt(dstp2,dst2_pitch,srcp1,src1_pitch,width+1,height+1);
+	for (b=0; b&lt;iterations; ++b)
+	{
+		if (b&amp;1)
+		{
+			srcp = dstp2 + dst2_pitch;
+			src_pitch = dst2_pitch;
+			srcpp = srcp - src_pitch;
+			srcpn = srcp + src_pitch;
+			dstp = dstp1 + dst1_pitch;
+			dst_pitch = dst1_pitch;
+		}
+		else
+		{
+			srcp = dstp1 + dst1_pitch;
+			src_pitch = dst1_pitch;
+			srcpp = srcp - src_pitch;
+			srcpn = srcp + src_pitch;
+			dstp = dstp2 + dst2_pitch;
+			dst_pitch = dst2_pitch;
+		}
+		if (type == 0)
+		{
+			for (y=1; y&lt;height; ++y)
+			{
+				for (x=1; x&lt;width; ++x)
+				{
+					Ix = srcp[x+1] - srcp[x-1];
+					Ix2 = Ix*Ix;
+					Iy = srcpn[x] - srcpp[x];
+					Iy2 = Iy*Iy;
+					Ixy = srcpp[x-1] - srcpp[x+1] - srcpn[x-1] + srcpn[x+1];
+					Ixx = srcp[x+1] + srcp[x-1] - srcp[x] - srcp[x];
+					Iyy = srcpp[x] + srcpn[x] - srcp[x] - srcp[x];
+					temp = srcp[x] + ((int)((((Ix2*Iyy - Ix*Iy*Ixy + Iy2*Ixx)*tStep) / (((Ix2 + Iy2) &lt;&lt; 1) + off)) + 0.5f));
+					if (temp &gt; 255) temp = 255;
+					else if (temp &lt; 0) temp = 0;
+					dstp[x] = temp;
+				}
+				srcpp += src_pitch;
+				srcp += src_pitch;
+				srcpn += src_pitch;
+				dstp += dst_pitch;
+			}
+		}
+		else if (type == 1)
+		{
+			for (y=1; y&lt;height; ++y)
+			{
+				for (x=1; x&lt;width; ++x)
+				{
+					Ix = srcpp[x+1]+srcp[x+1]+srcp[x+1]+srcpn[x+1]-srcpp[x-1]-srcp[x-1]-srcp[x-1]-srcpn[x-1];
+					Ix2 = Ix*Ix;
+					Iy = srcpn[x-1]+srcpn[x]+srcpn[x]+srcpn[x+1]-srcpp[x-1]-srcpp[x]-srcpp[x]-srcpp[x+1];
+					Iy2 = Iy*Iy;
+					Ixy = srcpp[x-1] - srcpp[x+1] - srcpn[x-1] + srcpn[x+1];
+					Ixx = srcp[x+1] + srcp[x-1] - srcp[x] - srcp[x];
+					Iyy = srcpp[x] + srcpn[x] - srcp[x] - srcp[x];
+					temp = srcp[x] + ((int)((((Ix2*Iyy - Ix*Iy*Ixy + Iy2*Ixx)*tStep) / (((Ix2 + Iy2) &lt;&lt; 1) + off)) + 0.5f));
+					if (temp &gt; 255) temp = 255;
+					else if (temp &lt; 0) temp = 0;
+					dstp[x] = temp;
+				}
+				srcpp += src_pitch;
+				srcp += src_pitch;
+				srcpn += src_pitch;
+				dstp += dst_pitch;
+			}
+		}
+		else
+		{
+			for (y=1; y&lt;height; ++y)
+			{
+				for (x=1; x&lt;width; ++x)
+				{
+					Ix = srcpp[x+1]+srcp[x+1]+srcp[x+1]+srcpn[x+1]-srcpp[x-1]-srcp[x-1]-srcp[x-1]-srcpn[x-1];
+					Ix2 = Ix*Ix;
+					Iy = srcpn[x-1]+srcpn[x]+srcpn[x]+srcpn[x+1]-srcpp[x-1]-srcpp[x]-srcpp[x]-srcpp[x+1];
+					Iy2 = Iy*Iy;
+					Ixy = srcpp[x-1] - srcpp[x+1] - srcpn[x-1] + srcpn[x+1];
+					Ixx = srcpp[x+1] + srcp[x+1] + srcp[x+1] + srcpn[x+1] + srcpp[x-1] + srcp[x-1] + 
+						srcp[x-1] + srcpn[x-1] - (srcpp[x]&lt;&lt;1) - (srcp[x]&lt;&lt;2) - (srcpn[x]&lt;&lt;1);
+					Iyy = srcpp[x-1] + srcpp[x] + srcpp[x] + srcpp[x+1] + srcpn[x-1] + srcpn[x] + 
+						srcpn[x] + srcpn[x+1] - (srcp[x-1]&lt;&lt;1) - (srcp[x]&lt;&lt;2) - (srcp[x+1]&lt;&lt;1);
+					temp = srcp[x] + ((int)((((Ix2*Iyy - 4*Ix*Iy*Ixy + Iy2*Ixx)*tStep) / (((Ix2 + Iy2) &lt;&lt; 3) + off)) + 0.5f));
+					if (temp &gt; 255) temp = 255;
+					else if (temp &lt; 0) temp = 0;
+					dstp[x] = temp;
+				}
+				srcpp += src_pitch;
+				srcp += src_pitch;
+				srcpn += src_pitch;
+				dstp += dst_pitch;
+			}
+		}
+	}
+	srcp1 = src-&gt;GetReadPtr(PLANAR_U);
+	src1_pitch = src-&gt;GetPitch(PLANAR_U);
+	width = src-&gt;GetRowSize(PLANAR_U) - 1;
+	height = src-&gt;GetHeight(PLANAR_U) - 1;
+	dstp1 = dst1-&gt;GetWritePtr(PLANAR_U);
+	dst1_pitch = dst1-&gt;GetPitch(PLANAR_U);
+	dstp2 = dst2-&gt;GetWritePtr(PLANAR_U);
+	dst2_pitch = dst2-&gt;GetPitch(PLANAR_U);
+	if (chroma)
+	{
+		env-&gt;BitBlt(dstp1,dst1_pitch,srcp1,src1_pitch,width+1,height+1);
+		env-&gt;BitBlt(dstp2,dst2_pitch,srcp1,src1_pitch,width+1,height+1);
+		for (b=0; b&lt;iterations; ++b)
+		{
+			if (b&amp;1)
+			{
+				srcp = dstp2 + dst2_pitch;
+				src_pitch = dst2_pitch;
+				srcpp = srcp - src_pitch;
+				srcpn = srcp + src_pitch;
+				dstp = dstp1 + dst1_pitch;
+				dst_pitch = dst1_pitch;
+			}
+			else
+			{
+				srcp = dstp1 + dst1_pitch;
+				src_pitch = dst1_pitch;
+				srcpp = srcp - src_pitch;
+				srcpn = srcp + src_pitch;
+				dstp = dstp2 + dst2_pitch;
+				dst_pitch = dst2_pitch;
+			}
+			if (type == 0)
+			{
+				for (y=1; y&lt;height; ++y)
+				{
+					for (x=1; x&lt;width; ++x)
+					{
+						Ix = srcp[x+1] - srcp[x-1];
+						Ix2 = Ix*Ix;
+						Iy = srcpn[x] - srcpp[x];
+						Iy2 = Iy*Iy;
+						Ixy = srcpp[x-1] - srcpp[x+1] - srcpn[x-1] + srcpn[x+1];
+						Ixx = srcp[x+1] + srcp[x-1] - srcp[x] - srcp[x];
+						Iyy = srcpp[x] + srcpn[x] - srcp[x] - srcp[x];
+						temp = srcp[x] + ((int)((((Ix2*Iyy - Ix*Iy*Ixy + Iy2*Ixx)*tStep) / (((Ix2 + Iy2) &lt;&lt; 1) + off)) + 0.5f));
+						if (temp &gt; 255) temp = 255;
+						else if (temp &lt; 0) temp = 0;
+						dstp[x] = temp;
+					}
+					srcpp += src_pitch;
+					srcp += src_pitch;
+					srcpn += src_pitch;
+					dstp += dst_pitch;
+				}
+			}
+			else if (type == 1)
+			{
+				for (y=1; y&lt;height; ++y)
+				{
+					for (x=1; x&lt;width; ++x)
+					{
+						Ix = srcpp[x+1]+srcp[x+1]+srcp[x+1]+srcpn[x+1]-srcpp[x-1]-srcp[x-1]-srcp[x-1]-srcpn[x-1];
+						Ix2 = Ix*Ix;
+						Iy = srcpn[x-1]+srcpn[x]+srcpn[x]+srcpn[x+1]-srcpp[x-1]-srcpp[x]-srcpp[x]-srcpp[x+1];
+						Iy2 = Iy*Iy;
+						Ixy = srcpp[x-1] - srcpp[x+1] - srcpn[x-1] + srcpn[x+1];
+						Ixx = srcp[x+1] + srcp[x-1] - srcp[x] - srcp[x];
+						Iyy = srcpp[x] + srcpn[x] - srcp[x] - srcp[x];
+						temp = srcp[x] + ((int)((((Ix2*Iyy - Ix*Iy*Ixy + Iy2*Ixx)*tStep) / (((Ix2 + Iy2) &lt;&lt; 1) + off)) + 0.5f));
+						if (temp &gt; 255) temp = 255;
+						else if (temp &lt; 0) temp = 0;
+						dstp[x] = temp;
+					}
+					srcpp += src_pitch;
+					srcp += src_pitch;
+					srcpn += src_pitch;
+					dstp += dst_pitch;
+				}
+			}
+			else
+			{
+				for (y=1; y&lt;height; ++y)
+				{
+					for (x=1; x&lt;width; ++x)
+					{
+						Ix = srcpp[x+1]+srcp[x+1]+srcp[x+1]+srcpn[x+1]-srcpp[x-1]-srcp[x-1]-srcp[x-1]-srcpn[x-1];
+						Ix2 = Ix*Ix;
+						Iy = srcpn[x-1]+srcpn[x]+srcpn[x]+srcpn[x+1]-srcpp[x-1]-srcpp[x]-srcpp[x]-srcpp[x+1];
+						Iy2 = Iy*Iy;
+						Ixy = srcpp[x-1] - srcpp[x+1] - srcpn[x-1] + srcpn[x+1];
+						Ixx = srcpp[x+1] + srcp[x+1] + srcp[x+1] + srcpn[x+1] + srcpp[x-1] + srcp[x-1] + 
+							srcp[x-1] + srcpn[x-1] - (srcpp[x]&lt;&lt;1) - (srcp[x]&lt;&lt;2) - (srcpn[x]&lt;&lt;1);
+						Iyy = srcpp[x-1] + srcpp[x] + srcpp[x] + srcpp[x+1] + srcpn[x-1] + srcpn[x] + 
+							srcpn[x] + srcpn[x+1] - (srcp[x-1]&lt;&lt;1) - (srcp[x]&lt;&lt;2) - (srcp[x+1]&lt;&lt;1);
+						temp = srcp[x] + ((int)((((Ix2*Iyy - 4*Ix*Iy*Ixy + Iy2*Ixx)*tStep) / (((Ix2 + Iy2) &lt;&lt; 3) + off)) + 0.5f));
+						if (temp &gt; 255) temp = 255;
+						else if (temp &lt; 0) temp = 0;
+						dstp[x] = temp;
+					}
+					srcpp += src_pitch;
+					srcp += src_pitch;
+					srcpn += src_pitch;
+					dstp += dst_pitch;
+				}
+			}
+		}
+		srcp1 = src-&gt;GetReadPtr(PLANAR_V);
+		dstp1 = dst1-&gt;GetWritePtr(PLANAR_V);
+		dstp2 = dst2-&gt;GetWritePtr(PLANAR_V);
+		env-&gt;BitBlt(dstp1,dst1_pitch,srcp1,src1_pitch,width+1,height+1);
+		env-&gt;BitBlt(dstp2,dst2_pitch,srcp1,src1_pitch,width+1,height+1);
+		for (b=0; b&lt;iterations; ++b)
+		{
+			if (b&amp;1)
+			{
+				srcp = dstp2 + dst2_pitch;
+				src_pitch = dst2_pitch;
+				srcpp = srcp - src_pitch;
+				srcpn = srcp + src_pitch;
+				dstp = dstp1 + dst1_pitch;
+				dst_pitch = dst1_pitch;
+			}
+			else
+			{
+				srcp = dstp1 + dst1_pitch;
+				src_pitch = dst1_pitch;
+				srcpp = srcp - src_pitch;
+				srcpn = srcp + src_pitch;
+				dstp = dstp2 + dst2_pitch;
+				dst_pitch = dst2_pitch;
+			}
+			if (type == 0)
+			{
+				for (y=1; y&lt;height; ++y)
+				{
+					for (x=1; x&lt;width; ++x)
+					{
+						Ix = srcp[x+1] - srcp[x-1];
+						Ix2 = Ix*Ix;
+						Iy = srcpn[x] - srcpp[x];
+						Iy2 = Iy*Iy;
+						Ixy = srcpp[x-1] - srcpp[x+1] - srcpn[x-1] + srcpn[x+1];
+						Ixx = srcp[x+1] + srcp[x-1] - srcp[x] - srcp[x];
+						Iyy = srcpp[x] + srcpn[x] - srcp[x] - srcp[x];
+						temp = srcp[x] + ((int)((((Ix2*Iyy - Ix*Iy*Ixy + Iy2*Ixx)*tStep) / (((Ix2 + Iy2) &lt;&lt; 1) + off)) + 0.5f));
+						if (temp &gt; 255) temp = 255;
+						else if (temp &lt; 0) temp = 0;
+						dstp[x] = temp;
+					}
+					srcpp += src_pitch;
+					srcp += src_pitch;
+					srcpn += src_pitch;
+					dstp += dst_pitch;
+				}
+			}
+			else if (type == 1)
+			{
+				for (y=1; y&lt;height; ++y)
+				{
+					for (x=1; x&lt;width; ++x)
+					{
+						Ix = srcpp[x+1]+srcp[x+1]+srcp[x+1]+srcpn[x+1]-srcpp[x-1]-srcp[x-1]-srcp[x-1]-srcpn[x-1];
+						Ix2 = Ix*Ix;
+						Iy = srcpn[x-1]+srcpn[x]+srcpn[x]+srcpn[x+1]-srcpp[x-1]-srcpp[x]-srcpp[x]-srcpp[x+1];
+						Iy2 = Iy*Iy;
+						Ixy = srcpp[x-1] - srcpp[x+1] - srcpn[x-1] + srcpn[x+1];
+						Ixx = srcp[x+1] + srcp[x-1] - srcp[x] - srcp[x];
+						Iyy = srcpp[x] + srcpn[x] - srcp[x] - srcp[x];
+						temp = srcp[x] + ((int)((((Ix2*Iyy - Ix*Iy*Ixy + Iy2*Ixx)*tStep) / (((Ix2 + Iy2) &lt;&lt; 1) + off)) + 0.5f));
+						if (temp &gt; 255) temp = 255;
+						else if (temp &lt; 0) temp = 0;
+						dstp[x] = temp;
+					}
+					srcpp += src_pitch;
+					srcp += src_pitch;
+					srcpn += src_pitch;
+					dstp += dst_pitch;
+				}
+			}
+			else
+			{
+				for (y=1; y&lt;height; ++y)
+				{
+					for (x=1; x&lt;width; ++x)
+					{
+						Ix = srcpp[x+1]+srcp[x+1]+srcp[x+1]+srcpn[x+1]-srcpp[x-1]-srcp[x-1]-srcp[x-1]-srcpn[x-1];
+						Ix2 = Ix*Ix;
+						Iy = srcpn[x-1]+srcpn[x]+srcpn[x]+srcpn[x+1]-srcpp[x-1]-srcpp[x]-srcpp[x]-srcpp[x+1];
+						Iy2 = Iy*Iy;
+						Ixy = srcpp[x-1] - srcpp[x+1] - srcpn[x-1] + srcpn[x+1];
+						Ixx = srcpp[x+1] + srcp[x+1] + srcp[x+1] + srcpn[x+1] + srcpp[x-1] + srcp[x-1] + 
+							srcp[x-1] + srcpn[x-1] - (srcpp[x]&lt;&lt;1) - (srcp[x]&lt;&lt;2) - (srcpn[x]&lt;&lt;1);
+						Iyy = srcpp[x-1] + srcpp[x] + srcpp[x] + srcpp[x+1] + srcpn[x-1] + srcpn[x] + 
+							srcpn[x] + srcpn[x+1] - (srcp[x-1]&lt;&lt;1) - (srcp[x]&lt;&lt;2) - (srcp[x+1]&lt;&lt;1);
+						temp = srcp[x] + ((int)((((Ix2*Iyy - 4*Ix*Iy*Ixy + Iy2*Ixx)*tStep) / (((Ix2 + Iy2) &lt;&lt; 3) + off)) + 0.5f));
+						if (temp &gt; 255) temp = 255;
+						else if (temp &lt; 0) temp = 0;
+						dstp[x] = temp;
+					}
+					srcpp += src_pitch;
+					srcp += src_pitch;
+					srcpn += src_pitch;
+					dstp += dst_pitch;
+				}
+			}
+		}
+	}
+	else
+	{
+		if (iterations&amp;1) env-&gt;BitBlt(dstp2,dst2_pitch,srcp1,src1_pitch,width+1,height+1);
+		else env-&gt;BitBlt(dstp1,dst1_pitch,srcp1,src1_pitch,width+1,height+1);
+		srcp1 = src-&gt;GetReadPtr(PLANAR_V);
+		dstp1 = dst1-&gt;GetWritePtr(PLANAR_V);
+		dstp2 = dst2-&gt;GetWritePtr(PLANAR_V);
+		if (iterations&amp;1) env-&gt;BitBlt(dstp2,dst2_pitch,srcp1,src1_pitch,width+1,height+1);
+		else env-&gt;BitBlt(dstp1,dst1_pitch,srcp1,src1_pitch,width+1,height+1);
+	}
+	if (iterations&amp;1) return dst2;
+	return dst1;
+}
+
+PVideoFrame __stdcall TIsophote::GetFrameYUY2(int n, IScriptEnvironment* env) 
+{
+	PVideoFrame src = child-&gt;GetFrame(n, env);
+	PVideoFrame dst1 = env-&gt;NewVideoFrame(vi);
+	PVideoFrame dst2 = env-&gt;NewVideoFrame(vi);
+	const unsigned char *srcp1 = src-&gt;GetReadPtr();
+	int src1_pitch = src-&gt;GetPitch(PLANAR_Y);
+	int width = src-&gt;GetRowSize() - 1;
+	int height = src-&gt;GetHeight() - 1;
+	unsigned char *srcpp, *srcp, *srcpn;
+	unsigned char *dstp1 = dst1-&gt;GetWritePtr();
+	int dst1_pitch = dst1-&gt;GetPitch();
+	unsigned char *dstp2 = dst2-&gt;GetWritePtr();
+	int dst2_pitch = dst2-&gt;GetPitch();
+	unsigned char *dstp;
+	double off = 0.0000000001;
+	int x, y, b, dst_pitch, src_pitch, temp;
+	int Ix, Ix2, Iy, Iy2, Ixy, Ixx, Iyy;
+	env-&gt;BitBlt(dstp1,dst1_pitch,srcp1,src1_pitch,width+1,height+1);
+	env-&gt;BitBlt(dstp2,dst2_pitch,srcp1,src1_pitch,width+1,height+1);
+	if (!chroma)
+	{
+		for (b=0; b&lt;iterations; ++b)
+		{
+			if (b&amp;1)
+			{
+				srcp = dstp2 + dst2_pitch;
+				src_pitch = dst2_pitch;
+				srcpp = srcp - src_pitch;
+				srcpn = srcp + src_pitch;
+				dstp = dstp1 + dst1_pitch;
+				dst_pitch = dst1_pitch;
+			}
+			else
+			{
+				srcp = dstp1 + dst1_pitch;
+				src_pitch = dst1_pitch;
+				srcpp = srcp - src_pitch;
+				srcpn = srcp + src_pitch;
+				dstp = dstp2 + dst2_pitch;
+				dst_pitch = dst2_pitch;
+			}
+			if (type == 0)
+			{
+				for (y=1; y&lt;height; ++y)
+				{
+					for (x=2; x&lt;width; x+=2)
+					{
+						Ix = srcp[x+2] - srcp[x-2];
+						Ix2 = Ix*Ix;
+						Iy = srcpn[x] - srcpp[x];
+						Iy2 = Iy*Iy;
+						Ixy = srcpp[x-2] - srcpp[x+2] - srcpn[x-2] + srcpn[x+2];
+						Ixx = srcp[x+2] + srcp[x-2] - srcp[x] - srcp[x];
+						Iyy = srcpp[x] + srcpn[x] - srcp[x] - srcp[x];
+						temp = srcp[x] + ((int)((((Ix2*Iyy - Ix*Iy*Ixy + Iy2*Ixx)*tStep) / (((Ix2 + Iy2) &lt;&lt; 1) + off)) + 0.5f));
+						if (temp &gt; 255) temp = 255;
+						else if (temp &lt; 0) temp = 0;
+						dstp[x] = temp;
+					}
+					srcpp += src_pitch;
+					srcp += src_pitch;
+					srcpn += src_pitch;
+					dstp += dst_pitch;
+				}
+			}
+			else if (type == 1)
+			{
+				for (y=1; y&lt;height; ++y)
+				{
+					for (x=2; x&lt;width; x+=2)
+					{
+						Ix = srcpp[x+2]+srcp[x+2]+srcp[x+2]+srcpn[x+2]-srcpp[x-2]-srcp[x-2]-srcp[x-2]-srcpn[x-2];
+						Ix2 = Ix*Ix;
+						Iy = srcpn[x-2]+srcpn[x]+srcpn[x]+srcpn[x+2]-srcpp[x-2]-srcpp[x]-srcpp[x]-srcpp[x+2];
+						Iy2 = Iy*Iy;
+						Ixy = srcpp[x-2] - srcpp[x+2] - srcpn[x-2] + srcpn[x+2];
+						Ixx = srcp[x+2] + srcp[x-2] - srcp[x] - srcp[x];
+						Iyy = srcpp[x] + srcpn[x] - srcp[x] - srcp[x];
+						temp = srcp[x] + ((int)((((Ix2*Iyy - Ix*Iy*Ixy + Iy2*Ixx)*tStep) / (((Ix2 + Iy2) &lt;&lt; 1) + off)) + 0.5f));
+						if (temp &gt; 255) temp = 255;
+						else if (temp &lt; 0) temp = 0;
+						dstp[x] = temp;
+					}
+					srcpp += src_pitch;
+					srcp += src_pitch;
+					srcpn += src_pitch;
+					dstp += dst_pitch;
+				}
+			}
+			else
+			{
+				for (y=1; y&lt;height; ++y)
+				{
+					for (x=2; x&lt;width; x+=2)
+					{
+						Ix = srcpp[x+2]+srcp[x+2]+srcp[x+2]+srcpn[x+2]-srcpp[x-2]-srcp[x-2]-srcp[x-2]-srcpn[x-2];
+						Ix2 = Ix*Ix;
+						Iy = srcpn[x-2]+srcpn[x]+srcpn[x]+srcpn[x+2]-srcpp[x-2]-srcpp[x]-srcpp[x]-srcpp[x+2];
+						Iy2 = Iy*Iy;
+						Ixy = srcpp[x-2] - srcpp[x+2] - srcpn[x-2] + srcpn[x+2];
+						Ixx = srcpp[x+2] + srcp[x+2] + srcp[x+2] + srcpn[x+2] + srcpp[x-2] + srcp[x-2] + 
+							srcp[x-2] + srcpn[x-2] - (srcpp[x]&lt;&lt;1) - (srcp[x]&lt;&lt;2) - (srcpn[x]&lt;&lt;1);
+						Iyy = srcpp[x-2] + srcpp[x] + srcpp[x] + srcpp[x+2] + srcpn[x-2] + srcpn[x] + 
+							srcpn[x] + srcpn[x+2] - (srcp[x-2]&lt;&lt;1) - (srcp[x]&lt;&lt;2) - (srcp[x+2]&lt;&lt;1);
+						temp = srcp[x] + ((int)((((Ix2*Iyy - 4*Ix*Iy*Ixy + Iy2*Ixx)*tStep) / (((Ix2 + Iy2) &lt;&lt; 3) + off)) + 0.5f));
+						if (temp &gt; 255) temp = 255;
+						else if (temp &lt; 0) temp = 0;
+						dstp[x] = temp;
+					}
+					srcpp += src_pitch;
+					srcp += src_pitch;
+					srcpn += src_pitch;
+					dstp += dst_pitch;
+				}
+			}
+		}
+	}
+	else
+	{
+		width -= 3;
+		for (b=0; b&lt;iterations; ++b)
+		{
+			if (b&amp;1)
+			{
+				srcp = dstp2 + dst2_pitch;
+				src_pitch = dst2_pitch;
+				srcpp = srcp - src_pitch;
+				srcpn = srcp + src_pitch;
+				dstp = dstp1 + dst1_pitch;
+				dst_pitch = dst1_pitch;
+			}
+			else
+			{
+				srcp = dstp1 + dst1_pitch;
+				src_pitch = dst1_pitch;
+				srcpp = srcp - src_pitch;
+				srcpn = srcp + src_pitch;
+				dstp = dstp2 + dst2_pitch;
+				dst_pitch = dst2_pitch;
+			}
+			if (type == 0)
+			{
+				for (y=1; y&lt;height; ++y)
+				{
+					for (x=4; x&lt;width; ++x)
+					{
+						Ix = srcp[x+2] - srcp[x-2];
+						Ix2 = Ix*Ix;
+						Iy = srcpn[x] - srcpp[x];
+						Iy2 = Iy*Iy;
+						Ixy = srcpp[x-2] - srcpp[x+2] - srcpn[x-2] + srcpn[x+2];
+						Ixx = srcp[x+2] + srcp[x-2] - srcp[x] - srcp[x];
+						Iyy = srcpp[x] + srcpn[x] - srcp[x] - srcp[x];
+						temp = srcp[x] + ((int)((((Ix2*Iyy - Ix*Iy*Ixy + Iy2*Ixx)*tStep) / (((Ix2 + Iy2) &lt;&lt; 1) + off)) + 0.5f));
+						if (temp &gt; 255) temp = 255;
+						else if (temp &lt; 0) temp = 0;
+						dstp[x] = temp;
+						++x;
+						Ix = srcp[x+4] - srcp[x-4];
+						Ix2 = Ix*Ix;
+						Iy = srcpn[x] - srcpp[x];
+						Iy2 = Iy*Iy;
+						Ixy = srcpp[x-4] - srcpp[x+4] - srcpn[x-4] + srcpn[x+4];
+						Ixx = srcp[x+4] + srcp[x-4] - srcp[x] - srcp[x];
+						Iyy = srcpp[x] + srcpn[x] - srcp[x] - srcp[x];
+						temp = srcp[x] + ((int)((((Ix2*Iyy - Ix*Iy*Ixy + Iy2*Ixx)*tStep) / (((Ix2 + Iy2) &lt;&lt; 1) + off)) + 0.5f));
+						if (temp &gt; 255) temp = 255;
+						else if (temp &lt; 0) temp = 0;
+						dstp[x] = temp;
+					}
+					srcpp += src_pitch;
+					srcp += src_pitch;
+					srcpn += src_pitch;
+					dstp += dst_pitch;
+				}
+			}
+			else if (type == 1)
+			{
+				for (y=1; y&lt;height; ++y)
+				{
+					for (x=4; x&lt;width; ++x)
+					{
+						Ix = srcpp[x+2]+srcp[x+2]+srcp[x+2]+srcpn[x+2]-srcpp[x-2]-srcp[x-2]-srcp[x-2]-srcpn[x-2];
+						Ix2 = Ix*Ix;
+						Iy = srcpn[x-2]+srcpn[x]+srcpn[x]+srcpn[x+2]-srcpp[x-2]-srcpp[x]-srcpp[x]-srcpp[x+2];
+						Iy2 = Iy*Iy;
+						Ixy = srcpp[x-2] - srcpp[x+2] - srcpn[x-2] + srcpn[x+2];
+						Ixx = srcp[x+2] + srcp[x-2] - srcp[x] - srcp[x];
+						Iyy = srcpp[x] + srcpn[x] - srcp[x] - srcp[x];
+						temp = srcp[x] + ((int)((((Ix2*Iyy - Ix*Iy*Ixy + Iy2*Ixx)*tStep) / (((Ix2 + Iy2) &lt;&lt; 1) + off)) + 0.5f));
+						if (temp &gt; 255) temp = 255;
+						else if (temp &lt; 0) temp = 0;
+						dstp[x] = temp;
+						++x;
+						Ix = srcpp[x+4]+srcp[x+4]+srcp[x+4]+srcpn[x+4]-srcpp[x-4]-srcp[x-4]-srcp[x-4]-srcpn[x-4];
+						Ix2 = Ix*Ix;
+						Iy = srcpn[x-4]+srcpn[x]+srcpn[x]+srcpn[x+4]-srcpp[x-4]-srcpp[x]-srcpp[x]-srcpp[x+4];
+						Iy2 = Iy*Iy;
+						Ixy = srcpp[x-4] - srcpp[x+4] - srcpn[x-4] + srcpn[x+4];
+						Ixx = srcp[x+4] + srcp[x-4] - srcp[x] - srcp[x];
+						Iyy = srcpp[x] + srcpn[x] - srcp[x] - srcp[x];
+						temp = srcp[x] + ((int)((((Ix2*Iyy - Ix*Iy*Ixy + Iy2*Ixx)*tStep) / (((Ix2 + Iy2) &lt;&lt; 1) + off)) + 0.5f));
+						if (temp &gt; 255) temp = 255;
+						else if (temp &lt; 0) temp = 0;
+						dstp[x] = temp;
+					}
+					srcpp += src_pitch;
+					srcp += src_pitch;
+					srcpn += src_pitch;
+					dstp += dst_pitch;
+				}
+			}
+			else
+			{
+				for (y=1; y&lt;height; ++y)
+				{
+					for (x=4; x&lt;width; ++x)
+					{
+						Ix = srcpp[x+2]+srcp[x+2]+srcp[x+2]+srcpn[x+2]-srcpp[x-2]-srcp[x-2]-srcp[x-2]-srcpn[x-2];
+						Ix2 = Ix*Ix;
+						Iy = srcpn[x-2]+srcpn[x]+srcpn[x]+srcpn[x+2]-srcpp[x-2]-srcpp[x]-srcpp[x]-srcpp[x+2];
+						Iy2 = Iy*Iy;
+						Ixy = srcpp[x-2] - srcpp[x+2] - srcpn[x-2] + srcpn[x+2];
+						Ixx = srcpp[x+2] + srcp[x+2] + srcp[x+2] + srcpn[x+2] + srcpp[x-2] + srcp[x-2] + 
+							srcp[x-2] + srcpn[x-2] - (srcpp[x]&lt;&lt;1) - (srcp[x]&lt;&lt;2) - (srcpn[x]&lt;&lt;1);
+						Iyy = srcpp[x-2] + srcpp[x] + srcpp[x] + srcpp[x+2] + srcpn[x-2] + srcpn[x] + 
+							srcpn[x] + srcpn[x+2] - (srcp[x-2]&lt;&lt;1) - (srcp[x]&lt;&lt;2) - (srcp[x+2]&lt;&lt;1);
+						temp = srcp[x] + ((int)((((Ix2*Iyy - 4*Ix*Iy*Ixy + Iy2*Ixx)*tStep) / (((Ix2 + Iy2) &lt;&lt; 3) + off)) + 0.5f));
+						if (temp &gt; 255) temp = 255;
+						else if (temp &lt; 0) temp = 0;
+						dstp[x] = temp;
+						++x;
+						Ix = srcpp[x+4]+srcp[x+4]+srcp[x+4]+srcpn[x+4]-srcpp[x-4]-srcp[x-4]-srcp[x-4]-srcpn[x-4];
+						Ix2 = Ix*Ix;
+						Iy = srcpn[x-4]+srcpn[x]+srcpn[x]+srcpn[x+4]-srcpp[x-4]-srcpp[x]-srcpp[x]-srcpp[x+4];
+						Iy2 = Iy*Iy;
+						Ixy = srcpp[x-4] - srcpp[x+4] - srcpn[x-4] + srcpn[x+4];
+						Ixx = srcpp[x+4] + srcp[x+4] + srcp[x+4] + srcpn[x+4] + srcpp[x-4] + srcp[x-4] + 
+							srcp[x-4] + srcpn[x-4] - (srcpp[x]&lt;&lt;1) - (srcp[x]&lt;&lt;2) - (srcpn[x]&lt;&lt;1);
+						Iyy = srcpp[x-4] + srcpp[x] + srcpp[x] + srcpp[x+4] + srcpn[x-4] + srcpn[x] + 
+							srcpn[x] + srcpn[x+4] - (srcp[x-4]&lt;&lt;1) - (srcp[x]&lt;&lt;2) - (srcp[x+4]&lt;&lt;1);
+						temp = srcp[x] + ((int)((((Ix2*Iyy - 4*Ix*Iy*Ixy + Iy2*Ixx)*tStep) / (((Ix2 + Iy2) &lt;&lt; 3) + off)) + 0.5f));
+						if (temp &gt; 255) temp = 255;
+						else if (temp &lt; 0) temp = 0;
+						dstp[x] = temp;
+					}
+					srcpp += src_pitch;
+					srcp += src_pitch;
+					srcpn += src_pitch;
+					dstp += dst_pitch;
+				}
+			}
+		}
+	}
+	if (iterations&amp;1) return dst2;
+	return dst1;
+}
+
+AVSValue __cdecl Create_TIsophote(AVSValue args, void* user_data, IScriptEnvironment* env) 
+{
+	int iterations = 4;
+	double tStep = 0.2f;
+	int type = 2;
+	bool chroma = false;
+    return new TIsophote(args[0].AsClip(),
+						args[1].AsInt(iterations),
+						args[2].AsFloat(tStep),
+						args[3].AsInt(type),
+						args[4].AsBool(chroma),
+						env);
+}
+
+extern &quot;C&quot; __declspec(dllexport) const char* __stdcall AvisynthPluginInit2(IScriptEnvironment* env) 
+{
+    env-&gt;AddFunction(&quot;TIsophote&quot;, &quot;c[iterations]i[tStep]f[type]i[chroma]b&quot;, Create_TIsophote, 0);
+    return 0;
+}
\ No newline at end of file

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/TIsophote/original/TIsophote.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/TIsophote/original/TIsophote.h	2008-06-16 17:49:32 UTC (rev 4111)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/TIsophote/original/TIsophote.h	2008-06-16 18:07:45 UTC (rev 4112)
@@ -0,0 +1,55 @@
+/*
+**                     TIsophote v0.9.1 for AviSynth 2.5.x
+**
+**   TIsophote is a simple unconstrained level-set (isophote) smoothing filter.
+**
+**   Copyright (C) 2004 Kevin Stone
+**
+**   This program is free software; you can redistribute it and/or modify
+**   it under the terms of the GNU General Public License as published by
+**   the Free Software Foundation; either version 2 of the License, or
+**   (at your option) any later version.
+**
+**   This program is distributed in the hope that it will be useful,
+**   but WITHOUT ANY WARRANTY; without even the implied warranty of
+**   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**   GNU General Public License for more details.
+**
+**   You should have received a copy of the GNU General Public License
+**   along with this program; if not, write to the Free Software
+**   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#include &lt;windows.h&gt;
+#include &quot;internal.h&quot;
+
+class TIsophote : public GenericVideoFilter
+{
+private:
+	int iterations;
+	double tStep;
+	int type;
+	bool chroma;
+	int nfrms;
+	PVideoFrame __stdcall TIsophote::GetFrameYV12(int n, IScriptEnvironment *env);
+	PVideoFrame __stdcall TIsophote::GetFrameYUY2(int n, IScriptEnvironment *env);
+
+public:
+	PVideoFrame __stdcall TIsophote::GetFrame(int n, IScriptEnvironment *env);
+
+	TIsophote(PClip _child, int _iterations, double _tStep, int _type, bool _chroma, IScriptEnvironment* env) : 
+		GenericVideoFilter(_child), iterations(_iterations), tStep(_tStep), type(_type), chroma(_chroma)
+	{
+		if (!vi.IsYV12() &amp;&amp; !vi.IsYUY2())
+			env-&gt;ThrowError(&quot;TIsophote:  YV12 and YUY2 data only!&quot;);
+		if (iterations &lt;= 0)
+			env-&gt;ThrowError(&quot;TIsophote:  iterations must be set to at least 1!&quot;);
+		if (type &lt; 0 || type &gt; 2)
+			env-&gt;ThrowError(&quot;TIsophote:  type must be set to 0, 1, or 2!&quot;);
+		nfrms = vi.num_frames-1;
+	}
+	TIsophote::~TIsophote()
+	{
+		// nothing to free
+	}
+};
\ No newline at end of file

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/TIsophote/original/avisynth.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/TIsophote/original/avisynth.h	2008-06-16 17:49:32 UTC (rev 4111)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/TIsophote/original/avisynth.h	2008-06-16 18:07:45 UTC (rev 4112)
@@ -0,0 +1,711 @@
+// Avisynth v2.5.  Copyright 2002 Ben Rudiak-Gould et al.
+// <A HREF="http://www.avisynth.org">http://www.avisynth.org</A>
+
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+//
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA, or visit
+// <A HREF="http://www.gnu.org/copyleft/gpl.html">http://www.gnu.org/copyleft/gpl.html</A> .
+//
+// Linking Avisynth statically or dynamically with other modules is making a
+// combined work based on Avisynth.  Thus, the terms and conditions of the GNU
+// General Public License cover the whole combination.
+//
+// As a special exception, the copyright holders of Avisynth give you
+// permission to link Avisynth with independent modules that communicate with
+// Avisynth solely through the interfaces defined in avisynth.h, regardless of the license
+// terms of these independent modules, and to copy and distribute the
+// resulting combined work under terms of your choice, provided that
+// every copy of the combined work is accompanied by a complete copy of
+// the source code of Avisynth (the version of Avisynth used to produce the
+// combined work), being distributed under the terms of the GNU General
+// Public License plus this exception.  An independent module is a module
+// which is not derived from or based on Avisynth, such as 3rd-party filters,
+// import and export plugins, or graphical user interfaces.
+
+
+
+
+
+#ifndef __AVISYNTH_H__
+#define __AVISYNTH_H__
+
+enum { AVISYNTH_INTERFACE_VERSION = 2 };
+
+
+/* Define all types necessary for interfacing with avisynth.dll
+   Moved from internal.h */
+
+// Win32 API macros, notably the types BYTE, DWORD, ULONG, etc. 
+#include &lt;windef.h&gt;  
+
+// COM interface macros
+#include &lt;objbase.h&gt;
+
+// Raster types used by VirtualDub &amp; Avisynth
+#define in64 (__int64)(unsigned short)
+typedef unsigned long	Pixel;    // this will break on 64-bit machines!
+typedef unsigned long	Pixel32;
+typedef unsigned char Pixel8;
+typedef long			PixCoord;
+typedef	long			PixDim;
+typedef	long			PixOffset;
+
+
+/* Compiler-specific crap */
+
+// Tell MSVC to stop precompiling here
+#ifdef _MSC_VER
+  #pragma hdrstop
+#endif
+
+// Set up debugging macros for MS compilers; for others, step down to the
+// standard &lt;assert.h&gt; interface
+#ifdef _MSC_VER
+  #include &lt;crtdbg.h&gt;
+#else
+  #define _RPT0(a,b) ((void)0)
+  #define _RPT1(a,b,c) ((void)0)
+  #define _RPT2(a,b,c,d) ((void)0)
+  #define _RPT3(a,b,c,d,e) ((void)0)
+  #define _RPT4(a,b,c,d,e,f) ((void)0)
+  
+  #define _ASSERTE(x) assert(x)
+  #include &lt;assert.h&gt;
+#endif
+
+
+
+// I had problems with Premiere wanting 1-byte alignment for its structures,
+// so I now set the Avisynth struct alignment explicitly here.
+#pragma pack(push,8)
+
+#define FRAME_ALIGN 16
+// Default frame alignment is 16 bytes, to help P4, when using SSE2
+
+// The VideoInfo struct holds global information about a clip (i.e.
+// information that does not depend on the frame number).  The GetVideoInfo
+// method in IClip returns this struct.
+
+// Audio Sample information
+typedef float SFLOAT;
+
+enum {SAMPLE_INT8  = 1&lt;&lt;0,
+        SAMPLE_INT16 = 1&lt;&lt;1, 
+        SAMPLE_INT24 = 1&lt;&lt;2,    // Int24 is a very stupid thing to code, but it's supported by some hardware.
+        SAMPLE_INT32 = 1&lt;&lt;3,
+        SAMPLE_FLOAT = 1&lt;&lt;4};
+
+enum {
+   PLANAR_Y=1&lt;&lt;0,
+   PLANAR_U=1&lt;&lt;1,
+   PLANAR_V=1&lt;&lt;2,
+   PLANAR_ALIGNED=1&lt;&lt;3,
+   PLANAR_Y_ALIGNED=PLANAR_Y|PLANAR_ALIGNED,
+   PLANAR_U_ALIGNED=PLANAR_U|PLANAR_ALIGNED,
+   PLANAR_V_ALIGNED=PLANAR_V|PLANAR_ALIGNED,
+  };
+
+struct VideoInfo {
+  int width, height;    // width=0 means no video
+  unsigned fps_numerator, fps_denominator;
+  int num_frames;
+  // This is more extensible than previous versions. More properties can be added seeminglesly.
+
+  // Colorspace properties.
+  enum {
+    CS_BGR = 1&lt;&lt;28,  
+    CS_YUV = 1&lt;&lt;29,
+    CS_INTERLEAVED = 1&lt;&lt;30,
+    CS_PLANAR = 1&lt;&lt;31
+  };
+
+  // Specific colorformats
+  enum { CS_UNKNOWN = 0,
+         CS_BGR24 = 1&lt;&lt;0 | CS_BGR | CS_INTERLEAVED,
+         CS_BGR32 = 1&lt;&lt;1 | CS_BGR | CS_INTERLEAVED,
+         CS_YUY2 = 1&lt;&lt;2 | CS_YUV | CS_INTERLEAVED,
+         CS_YV12 = 1&lt;&lt;3 | CS_YUV | CS_PLANAR,  // y-v-u, planar
+         CS_I420 = 1&lt;&lt;4 | CS_YUV | CS_PLANAR,  // y-u-v, planar
+         CS_IYUV = 1&lt;&lt;4 | CS_YUV | CS_PLANAR  // same as above
+         };
+  int pixel_type;                // changed to int as of 2.5
+  
+
+  int audio_samples_per_second;   // 0 means no audio
+  int sample_type;                // as of 2.5
+  __int64 num_audio_samples;      // changed as of 2.5
+  int nchannels;                  // as of 2.5
+
+  // Imagetype properties
+
+  int image_type;
+
+  enum {
+    IT_BFF = 1&lt;&lt;0,
+    IT_TFF = 1&lt;&lt;1,
+    IT_FIELDBASED = 1&lt;&lt;2
+  };
+
+  // useful functions of the above
+  bool HasVideo() const { return (width!=0); }
+  bool HasAudio() const { return (audio_samples_per_second!=0); }
+  bool IsRGB() const { return !!(pixel_type&amp;CS_BGR); }
+  bool IsRGB24() const { return (pixel_type&amp;CS_BGR24)==CS_BGR24; } // Clear out additional properties
+  bool IsRGB32() const { return (pixel_type &amp; CS_BGR32) == CS_BGR32 ; }
+  bool IsYUV() const { return !!(pixel_type&amp;CS_YUV ); }
+  bool IsYUY2() const { return (pixel_type &amp; CS_YUY2) == CS_YUY2; }  
+  bool IsYV12() const { return ((pixel_type &amp; CS_YV12) == CS_YV12)||((pixel_type &amp; CS_I420) == CS_I420); }
+  bool IsColorSpace(int c_space) const { return ((pixel_type &amp; c_space) == c_space); }
+  bool Is(int property) const { return ((pixel_type &amp; property)==property ); }
+  bool IsPlanar() const { return !!(pixel_type &amp; CS_PLANAR); }
+  bool IsFieldBased() const { return !!(image_type &amp; IT_FIELDBASED); }
+  bool IsParityKnown() const { return ((image_type &amp; IT_FIELDBASED)&amp;&amp;(image_type &amp; (IT_BFF||IT_TFF))); }
+  bool IsBFF() const { return !!(image_type &amp; IT_BFF); }
+  bool IsTFF() const { return !!(image_type &amp; IT_TFF); }
+  
+  bool IsVPlaneFirst() const {return ((pixel_type &amp; CS_YV12) == CS_YV12); }  // Don't use this 
+  int BytesFromPixels(int pixels) const { return pixels * (BitsPerPixel()&gt;&gt;3); }   // Will not work on planar images, but will return only luma planes
+  int RowSize() const { return BytesFromPixels(width); }  // Also only returns first plane on planar images
+  int BMPSize() const { if (IsPlanar()) {int p = height * ((RowSize()+3) &amp; ~3); p+=p&gt;&gt;1; return p;  } return height * ((RowSize()+3) &amp; ~3); }
+  __int64 AudioSamplesFromFrames(__int64 frames) const { return HasVideo() ? ((__int64)(frames) * audio_samples_per_second * fps_denominator / fps_numerator) : 0; }
+  int FramesFromAudioSamples(__int64 samples) const { return (HasAudio()) ? (int)(samples * (__int64)fps_numerator / (__int64)fps_denominator / (__int64)audio_samples_per_second) : 0; }
+  __int64 AudioSamplesFromBytes(__int64 bytes) const { return HasAudio() ? bytes / BytesPerAudioSample() : 0; }
+  __int64 BytesFromAudioSamples(__int64 samples) const { return samples * BytesPerAudioSample(); }
+  int AudioChannels() const { return nchannels; }
+  int SampleType() const{ return sample_type;}
+  bool IsSampleType(int testtype) const{ return !!(sample_type&amp;testtype);}
+  int SamplesPerSecond() const { return audio_samples_per_second; }
+  int BytesPerAudioSample() const { return nchannels*BytesPerChannelSample();}
+  void SetFieldBased(bool isfieldbased)  { if (isfieldbased) image_type|=IT_FIELDBASED; else  image_type&amp;=~IT_FIELDBASED; }
+  void Set(int property)  { image_type|=property; }
+  void Clear(int property)  { image_type&amp;=~property; }
+
+  int BitsPerPixel() const { 
+    switch (pixel_type) {
+      case CS_BGR24:
+        return 24;
+      case CS_BGR32:
+        return 32;
+      case CS_YUY2:
+        return 16;
+      case CS_YV12:
+      case CS_I420:
+        return 12;
+      default:
+        return 0;
+    }
+  }
+  int BytesPerChannelSample() const { 
+    switch (sample_type) {
+    case SAMPLE_INT8:
+      return sizeof(signed char);
+    case SAMPLE_INT16:
+      return sizeof(signed short);
+    case SAMPLE_INT24:
+      return 3;
+    case SAMPLE_INT32:
+      return sizeof(signed int);
+    case SAMPLE_FLOAT:
+      return sizeof(SFLOAT);
+    default:
+      _ASSERTE(&quot;Sample type not recognized!&quot;);
+      return 0;
+    }
+  }
+
+  // useful mutator
+  void SetFPS(unsigned numerator, unsigned denominator) {
+    unsigned x=numerator, y=denominator;
+    while (y) {   // find gcd
+      unsigned t = x%y; x = y; y = t;
+    }
+    fps_numerator = numerator/x;
+    fps_denominator = denominator/x;
+  }
+  // Test for same colorspace
+  bool IsSameColorspace(const VideoInfo&amp; vi) {
+    if (vi.pixel_type == pixel_type) return TRUE;
+    if (IsYV12() &amp;&amp; vi.IsYV12()) return TRUE;
+    return FALSE;
+  }
+
+};
+
+enum {
+  FILTER_TYPE=1,
+  FILTER_INPUT_COLORSPACE=2,
+  FILTER_OUTPUT_TYPE=9,
+  FILTER_NAME=4,
+  FILTER_AUTHOR=5,
+  FILTER_VERSION=6,
+  FILTER_ARGS=7,
+  FILTER_ARGS_INFO=8,
+  FILTER_ARGS_DESCRIPTION=10,
+  FILTER_DESCRIPTION=11,
+};
+enum {  //SUBTYPES
+  FILTER_TYPE_AUDIO=1,
+  FILTER_TYPE_VIDEO=2,
+  FILTER_OUTPUT_TYPE_SAME=3,
+  FILTER_OUTPUT_TYPE_DIFFERENT=4,
+};
+
+
+
+// VideoFrameBuffer holds information about a memory block which is used
+// for video data.  For efficiency, instances of this class are not deleted
+// when the refcount reaches zero; instead they're stored in a linked list
+// to be reused.  The instances are deleted when the corresponding AVS
+// file is closed.
+
+class VideoFrameBuffer {
+  BYTE* const data;
+  const int data_size;
+  // sequence_number is incremented every time the buffer is changed, so
+  // that stale views can tell they're no longer valid.
+  long sequence_number;
+
+  friend class VideoFrame;
+  friend class Cache;
+  friend class ScriptEnvironment;
+  long refcount;
+
+public:
+  VideoFrameBuffer(int size);
+  VideoFrameBuffer();
+  ~VideoFrameBuffer();
+
+  const BYTE* GetReadPtr() const { return data; }
+  BYTE* GetWritePtr() { ++sequence_number; return data; }
+  int GetDataSize() { return data_size; }
+  int GetSequenceNumber() { return sequence_number; }
+  int GetRefcount() { return refcount; }
+};
+
+
+class IClip;
+class PClip;
+class PVideoFrame;
+class IScriptEnvironment;
+class AVSValue;
+
+
+// VideoFrame holds a &quot;window&quot; into a VideoFrameBuffer.  Operator new
+// is overloaded to recycle class instances.
+
+class VideoFrame {
+  int refcount;
+  VideoFrameBuffer* const vfb;
+  const int offset, pitch, row_size, height, offsetU, offsetV, pitchUV;  // U&amp;V offsets are from top of picture.
+
+  friend class PVideoFrame;
+  void AddRef() { InterlockedIncrement((long *)&amp;refcount); }
+  void Release() { if (refcount==1) InterlockedDecrement(&amp;vfb-&gt;refcount); InterlockedDecrement((long *)&amp;refcount); }
+
+  friend class ScriptEnvironment;
+  friend class Cache;
+
+  VideoFrame(VideoFrameBuffer* _vfb, int _offset, int _pitch, int _row_size, int _height);
+  VideoFrame(VideoFrameBuffer* _vfb, int _offset, int _pitch, int _row_size, int _height, int _offsetU, int _offsetV, int _pitchUV);
+
+  void* operator new(unsigned size);
+// TESTME: OFFSET U/V may be switched to what could be expected from AVI standard!
+public:
+  int GetPitch() const { return pitch; }
+  int GetPitch(int plane) const { switch (plane) {case PLANAR_U: case PLANAR_V: return pitchUV;} return pitch; }
+  int GetRowSize() const { return row_size; }
+  int GetRowSize(int plane) const { 
+    switch (plane) {
+    case PLANAR_U: case PLANAR_V: if (pitchUV) return row_size&gt;&gt;1; else return 0;
+    case PLANAR_U_ALIGNED: case PLANAR_V_ALIGNED: 
+      if (pitchUV) { 
+        int r = ((row_size+FRAME_ALIGN-1)&amp;(~(FRAME_ALIGN-1)) )&gt;&gt;1; // Aligned rowsize
+        if (r&lt;=pitchUV) 
+          return r; 
+        return row_size&gt;&gt;1; 
+      } else return 0;
+    case PLANAR_Y_ALIGNED:
+      int r = (row_size+FRAME_ALIGN-1)&amp;(~(FRAME_ALIGN-1)); // Aligned rowsize
+      if (r&lt;=pitch) 
+        return r; 
+      return row_size;
+    }
+    return row_size; }
+  int GetHeight() const { return height; }
+  int GetHeight(int plane) const {  switch (plane) {case PLANAR_U: case PLANAR_V: if (pitchUV) return height&gt;&gt;1; return 0;} return height; }
+
+  // generally you shouldn't use these three
+  VideoFrameBuffer* GetFrameBuffer() const { return vfb; }
+  int GetOffset() const { return offset; }
+  int GetOffset(int plane) const { switch (plane) {case PLANAR_U: return offsetU;case PLANAR_V: return offsetV;default: return offset;}; }
+
+  // in plugins use env-&gt;SubFrame()
+  VideoFrame* Subframe(int rel_offset, int new_pitch, int new_row_size, int new_height) const;
+  VideoFrame* Subframe(int rel_offset, int new_pitch, int new_row_size, int new_height, int rel_offsetU, int rel_offsetV, int pitchUV) const;
+
+
+  const BYTE* GetReadPtr() const { return vfb-&gt;GetReadPtr() + offset; }
+  const BYTE* GetReadPtr(int plane) const { return vfb-&gt;GetReadPtr() + GetOffset(plane); }
+
+  bool IsWritable() const { return (refcount == 1 &amp;&amp; vfb-&gt;refcount == 1); }
+
+  BYTE* GetWritePtr() const {
+    if (vfb-&gt;GetRefcount()&gt;1) {
+      _ASSERT(FALSE);
+      //throw AvisynthError(&quot;Internal Error - refcount was more than one!&quot;);
+    }
+    return IsWritable() ? (vfb-&gt;GetWritePtr() + offset) : 0;
+  }
+
+  BYTE* GetWritePtr(int plane) const {
+    if (plane==PLANAR_Y) {
+      if (vfb-&gt;GetRefcount()&gt;1) {
+        _ASSERT(FALSE);
+//        throw AvisynthError(&quot;Internal Error - refcount was more than one!&quot;);
+      }
+      return IsWritable() ? vfb-&gt;GetWritePtr() + GetOffset(plane) : 0;
+    }
+    return vfb-&gt;data + GetOffset(plane);
+  }
+
+  ~VideoFrame() { InterlockedDecrement(&amp;vfb-&gt;refcount); }
+};
+
+enum {
+  CACHE_NOTHING=0,
+  CACHE_RANGE=1,
+  CACHE_ALL=2,
+  CACHE_AUDIO=3
+ };
+
+// Base class for all filters.
+class IClip {
+  friend class PClip;
+  friend class AVSValue;
+  int refcnt;
+  void AddRef() { InterlockedIncrement((long *)&amp;refcnt); }
+  void Release() { InterlockedDecrement((long *)&amp;refcnt); if (!refcnt) delete this; }
+public:
+  IClip() : refcnt(0) {}
+
+  virtual int __stdcall GetVersion() { return AVISYNTH_INTERFACE_VERSION; }
+  
+  virtual PVideoFrame __stdcall GetFrame(int n, IScriptEnvironment* env) = 0;
+  virtual bool __stdcall GetParity(int n) = 0;  // return field parity if field_based, else parity of first field in frame
+  virtual void __stdcall GetAudio(void* buf, __int64 start, __int64 count, IScriptEnvironment* env) = 0;  // start and count are in samples
+  virtual void __stdcall SetCacheHints(int cachehints,int frame_range) = 0 ;  // We do not pass cache requests upwards, only to the next filter.
+  virtual const VideoInfo&amp; __stdcall GetVideoInfo() = 0;
+  virtual __stdcall ~IClip() {}
+};
+
+
+// smart pointer to IClip
+class PClip {
+
+  IClip* p;
+
+  IClip* GetPointerWithAddRef() const { if (p) p-&gt;AddRef(); return p; }
+  friend class AVSValue;
+  friend class VideoFrame;
+
+  void Init(IClip* x) {
+    if (x) x-&gt;AddRef();
+    p=x;
+  }
+  void Set(IClip* x) {
+    if (x) x-&gt;AddRef();
+    if (p) p-&gt;Release();
+    p=x;
+  }
+
+public:
+  PClip() { p = 0; }
+  PClip(const PClip&amp; x) { Init(x.p); }
+  PClip(IClip* x) { Init(x); }
+  void operator=(IClip* x) { Set(x); }
+  void operator=(const PClip&amp; x) { Set(x.p); }
+
+  IClip* operator-&gt;() const { return p; }
+
+  // useful in conditional expressions
+  operator void*() const { return p; }
+  bool operator!() const { return !p; }
+
+  ~PClip() { if (p) p-&gt;Release(); }
+};
+
+
+// smart pointer to VideoFrame
+class PVideoFrame {
+
+  VideoFrame* p;
+
+  void Init(VideoFrame* x) {
+    if (x) x-&gt;AddRef();
+    p=x;
+  }
+  void Set(VideoFrame* x) {
+    if (x) x-&gt;AddRef();
+    if (p) p-&gt;Release();
+    p=x;
+  }
+
+public:
+  PVideoFrame() { p = 0; }
+  PVideoFrame(const PVideoFrame&amp; x) { Init(x.p); }
+  PVideoFrame(VideoFrame* x) { Init(x); }
+  void operator=(VideoFrame* x) { Set(x); }
+  void operator=(const PVideoFrame&amp; x) { Set(x.p); }
+
+  VideoFrame* operator-&gt;() const { return p; }
+
+  // for conditional expressions
+  operator void*() const { return p; }
+  bool operator!() const { return !p; }
+
+  ~PVideoFrame() { if (p) p-&gt;Release();}
+};
+
+
+class AVSValue {
+public:
+
+  AVSValue() { type = 'v'; }
+  AVSValue(IClip* c) { type = 'c'; clip = c; if (c) c-&gt;AddRef(); }
+  AVSValue(const PClip&amp; c) { type = 'c'; clip = c.GetPointerWithAddRef(); }
+  AVSValue(bool b) { type = 'b'; boolean = b; }
+  AVSValue(int i) { type = 'i'; integer = i; }
+//  AVSValue(__int64 l) { type = 'l'; longlong = l; }
+  AVSValue(float f) { type = 'f'; floating_pt = f; }
+  AVSValue(double f) { type = 'f'; floating_pt = float(f); }
+  AVSValue(const char* s) { type = 's'; string = s; }
+  AVSValue(const AVSValue* a, int size) { type = 'a'; array = a; array_size = size; }
+  AVSValue(const AVSValue&amp; v) { Assign(&amp;v, true); }
+
+  ~AVSValue() { if (IsClip() &amp;&amp; clip) clip-&gt;Release(); }
+  AVSValue&amp; operator=(const AVSValue&amp; v) { Assign(&amp;v, false); return *this; }
+
+  // Note that we transparently allow 'int' to be treated as 'float'.
+  // There are no int&lt;-&gt;bool conversions, though.
+
+  bool Defined() const { return type != 'v'; }
+  bool IsClip() const { return type == 'c'; }
+  bool IsBool() const { return type == 'b'; }
+  bool IsInt() const { return type == 'i'; }
+//  bool IsLong() const { return (type == 'l'|| type == 'i'); }
+  bool IsFloat() const { return type == 'f' || type == 'i'; }
+  bool IsString() const { return type == 's'; }
+  bool IsArray() const { return type == 'a'; }
+
+  PClip AsClip() const { _ASSERTE(IsClip()); return IsClip()?clip:0; }
+  bool AsBool() const { _ASSERTE(IsBool()); return boolean; }
+  int AsInt() const { _ASSERTE(IsInt()); return integer; }   
+//  int AsLong() const { _ASSERTE(IsLong()); return longlong; } 
+  const char* AsString() const { _ASSERTE(IsString()); return IsString()?string:0; }
+  double AsFloat() const { _ASSERTE(IsFloat()); return IsInt()?integer:floating_pt; }
+
+  bool AsBool(bool def) const { _ASSERTE(IsBool()||!Defined()); return IsBool() ? boolean : def; }
+  int AsInt(int def) const { _ASSERTE(IsInt()||!Defined()); return IsInt() ? integer : def; }
+  double AsFloat(double def) const { _ASSERTE(IsFloat()||!Defined()); return IsInt() ? integer : type=='f' ? floating_pt : def; }
+  const char* AsString(const char* def) const { _ASSERTE(IsString()||!Defined()); return IsString() ? string : def; }
+
+  int ArraySize() const { _ASSERTE(IsArray()); return IsArray()?array_size:1; }
+
+  const AVSValue&amp; operator[](int index) const {
+    _ASSERTE(IsArray() &amp;&amp; index&gt;=0 &amp;&amp; index&lt;array_size);
+    return (IsArray() &amp;&amp; index&gt;=0 &amp;&amp; index&lt;array_size) ? array[index] : *this;
+  }
+
+private:
+
+  short type;  // 'a'rray, 'c'lip, 'b'ool, 'i'nt, 'f'loat, 's'tring, 'v'oid, or 'l'ong
+  short array_size;
+  union {
+    IClip* clip;
+    bool boolean;
+    int integer;
+    float floating_pt;
+    const char* string;
+    const AVSValue* array;
+//    __int64 longlong;
+  };
+
+  void Assign(const AVSValue* src, bool init) {
+    if (src-&gt;IsClip() &amp;&amp; src-&gt;clip)
+      src-&gt;clip-&gt;AddRef();
+    if (!init &amp;&amp; IsClip() &amp;&amp; clip)
+      clip-&gt;Release();
+    // make sure this copies the whole struct!
+    ((__int32*)this)[0] = ((__int32*)src)[0];
+    ((__int32*)this)[1] = ((__int32*)src)[1];
+  }
+};
+
+
+// instantiable null filter
+class GenericVideoFilter : public IClip {
+protected:
+  PClip child;
+  VideoInfo vi;
+public:
+  GenericVideoFilter(PClip _child) : child(_child) { vi = child-&gt;GetVideoInfo(); }
+  PVideoFrame __stdcall GetFrame(int n, IScriptEnvironment* env) { return child-&gt;GetFrame(n, env); }
+  void __stdcall GetAudio(void* buf, __int64 start, __int64 count, IScriptEnvironment* env) { child-&gt;GetAudio(buf, start, count, env); }
+  const VideoInfo&amp; __stdcall GetVideoInfo() { return vi; }
+  bool __stdcall GetParity(int n) { return child-&gt;GetParity(n); }
+  void __stdcall SetCacheHints(int cachehints,int frame_range) { } ;  // We do not pass cache requests upwards, only to the next filter.
+};
+
+
+class AvisynthError /* exception */ {
+public:
+  const char* const msg;
+  AvisynthError(const char* _msg) : msg(_msg) {}
+};
+
+
+
+
+/* Helper classes useful to plugin authors */
+
+class AlignPlanar : public GenericVideoFilter 
+{
+public:
+  AlignPlanar(PClip _clip);
+  static PClip Create(PClip clip);
+  PVideoFrame __stdcall GetFrame(int n, IScriptEnvironment* env);
+};
+
+
+
+class FillBorder : public GenericVideoFilter 
+{
+public:
+  FillBorder(PClip _clip);
+  static PClip Create(PClip clip);
+  PVideoFrame __stdcall GetFrame(int n, IScriptEnvironment* env);
+};
+
+
+
+class ConvertAudio : public GenericVideoFilter 
+/**
+  * Helper class to convert audio to any format
+ **/
+{
+public:
+  ConvertAudio(PClip _clip, int prefered_format);
+  void __stdcall GetAudio(void* buf, __int64 start, __int64 count, IScriptEnvironment* env);
+
+  static PClip Create(PClip clip, int sample_type, int prefered_type);
+  static AVSValue __cdecl Create_float(AVSValue args, void*, IScriptEnvironment*);
+  static AVSValue __cdecl Create_32bit(AVSValue args, void*, IScriptEnvironment*);
+  static AVSValue __cdecl Create_24bit(AVSValue args, void*, IScriptEnvironment*);
+  static AVSValue __cdecl Create_16bit(AVSValue args, void*, IScriptEnvironment*);
+  static AVSValue __cdecl Create_8bit(AVSValue args, void*, IScriptEnvironment*);
+  virtual ~ConvertAudio()
+  {if (tempbuffer_size) {delete[] tempbuffer;tempbuffer_size=0;}}
+private:
+  void convertToFloat(char* inbuf, float* outbuf, char sample_type, int count);
+  void convertFromFloat(float* inbuf, void* outbuf, char sample_type, int count);
+
+  __inline int Saturate_int8(float n);
+  __inline short Saturate_int16(float n);
+  __inline int Saturate_int24(float n);
+  __inline int Saturate_int32(float n);
+
+  char src_format;
+  char dst_format;
+  int src_bps;
+  char *tempbuffer;
+  SFLOAT *floatbuffer;
+  int tempbuffer_size;
+};
+
+
+// For GetCPUFlags.  These are backwards-compatible with those in VirtualDub.
+enum {                    
+                    /* slowest CPU to support extension */
+  CPUF_FORCE			  = 0x01,   // N/A
+  CPUF_FPU			    = 0x02,   // 386/486DX
+  CPUF_MMX			    = 0x04,   // P55C, K6, PII
+  CPUF_INTEGER_SSE	= 0x08,		// PIII, Athlon
+  CPUF_SSE			    = 0x10,		// PIII, Athlon XP/MP
+  CPUF_SSE2			    = 0x20,		// PIV, Hammer
+  CPUF_3DNOW			  = 0x40,   // K6-2
+  CPUF_3DNOW_EXT		= 0x80,		// Athlon
+  CPUF_X86_64       = 0xA0,   // Hammer (note: equiv. to 3DNow + SSE2, which only Hammer
+                              //         will have anyway)
+};
+#define MAX_INT 0x7fffffff
+#define MIN_INT -0x7fffffff
+
+
+
+class IScriptEnvironment {
+public:
+  virtual __stdcall ~IScriptEnvironment() {}
+
+  virtual /*static*/ long __stdcall GetCPUFlags() = 0;
+
+  virtual char* __stdcall SaveString(const char* s, int length = -1) = 0;
+  virtual char* __stdcall Sprintf(const char* fmt, ...) = 0;
+  // note: val is really a va_list; I hope everyone typedefs va_list to a pointer
+  virtual char* __stdcall VSprintf(const char* fmt, void* val) = 0;
+
+  __declspec(noreturn) virtual void __stdcall ThrowError(const char* fmt, ...) = 0;
+
+  class NotFound /*exception*/ {};  // thrown by Invoke and GetVar
+
+  typedef AVSValue (__cdecl *ApplyFunc)(AVSValue args, void* user_data, IScriptEnvironment* env);
+
+  virtual void __stdcall AddFunction(const char* name, const char* params, ApplyFunc apply, void* user_data) = 0;
+  virtual bool __stdcall FunctionExists(const char* name) = 0;
+  virtual AVSValue __stdcall Invoke(const char* name, const AVSValue args, const char** arg_names=0) = 0;
+
+  virtual AVSValue __stdcall GetVar(const char* name) = 0;
+  virtual bool __stdcall SetVar(const char* name, const AVSValue&amp; val) = 0;
+  virtual bool __stdcall SetGlobalVar(const char* name, const AVSValue&amp; val) = 0;
+
+  virtual void __stdcall PushContext(int level=0) = 0;
+  virtual void __stdcall PopContext() = 0;
+
+  // align should be 4 or 8
+  virtual PVideoFrame __stdcall NewVideoFrame(const VideoInfo&amp; vi, int align=FRAME_ALIGN) = 0;
+
+  virtual bool __stdcall MakeWritable(PVideoFrame* pvf) = 0;
+
+  virtual /*static*/ void __stdcall BitBlt(BYTE* dstp, int dst_pitch, const BYTE* srcp, int src_pitch, int row_size, int height) = 0;
+
+  typedef void (__cdecl *ShutdownFunc)(void* user_data, IScriptEnvironment* env);
+  virtual void __stdcall AtExit(ShutdownFunc function, void* user_data) = 0;
+
+  virtual void __stdcall CheckVersion(int version = AVISYNTH_INTERFACE_VERSION) = 0;
+
+  virtual PVideoFrame __stdcall Subframe(PVideoFrame src, int rel_offset, int new_pitch, int new_row_size, int new_height) = 0;
+
+	virtual int __stdcall SetMemoryMax(int mem) = 0;
+
+  virtual int __stdcall SetWorkingDir(const char * newdir) = 0;
+
+};
+
+
+// avisynth.dll exports this; it's a way to use it as a library, without
+// writing an AVS script or without going through AVIFile.
+IScriptEnvironment* __stdcall CreateScriptEnvironment(int version = AVISYNTH_INTERFACE_VERSION);
+
+
+#pragma pack(pop)
+
+#endif //__AVISYNTH_H__

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/TIsophote/original/gpl.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/TIsophote/original/gpl.txt	2008-06-16 17:49:32 UTC (rev 4111)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/TIsophote/original/gpl.txt	2008-06-16 18:07:45 UTC (rev 4112)
@@ -0,0 +1,340 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+                       59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The &quot;Program&quot;, below,
+refers to any such program or work, and a &quot;work based on the Program&quot;
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term &quot;modification&quot;.)  Each licensee is addressed as &quot;you&quot;.
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and &quot;any
+later version&quot;, you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM &quot;AS IS&quot; WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the &quot;copyright&quot; line and a pointer to where the full notice is found.
+
+    &lt;one line to give the program's name and a brief idea of what it does.&gt;
+    Copyright (C) &lt;year&gt;  &lt;name of author&gt;
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a &quot;copyright disclaimer&quot; for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  &lt;signature of Ty Coon&gt;, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/TIsophote/original/internal.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/TIsophote/original/internal.h	2008-06-16 17:49:32 UTC (rev 4111)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/TIsophote/original/internal.h	2008-06-16 18:07:45 UTC (rev 4112)
@@ -0,0 +1,115 @@
+// Avisynth v2.5.  Copyright 2002 Ben Rudiak-Gould et al.
+// <A HREF="http://www.avisynth.org">http://www.avisynth.org</A>
+
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+//
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA, or visit
+// <A HREF="http://www.gnu.org/copyleft/gpl.html">http://www.gnu.org/copyleft/gpl.html</A> .
+//
+// Linking Avisynth statically or dynamically with other modules is making a
+// combined work based on Avisynth.  Thus, the terms and conditions of the GNU
+// General Public License cover the whole combination.
+//
+// As a special exception, the copyright holders of Avisynth give you
+// permission to link Avisynth with independent modules that communicate with
+// Avisynth solely through the interfaces defined in avisynth.h, regardless of the license
+// terms of these independent modules, and to copy and distribute the
+// resulting combined work under terms of your choice, provided that
+// every copy of the combined work is accompanied by a complete copy of
+// the source code of Avisynth (the version of Avisynth used to produce the
+// combined work), being distributed under the terms of the GNU General
+// Public License plus this exception.  An independent module is a module
+// which is not derived from or based on Avisynth, such as 3rd-party filters,
+// import and export plugins, or graphical user interfaces.
+
+
+#ifndef __Internal_H__
+#define __Internal_H__
+
+#define AVS_VERSION 2.54
+#define AVS_VERSTR &quot;AviSynth 2.54, build:&quot;__DATE__&quot; [&quot;__TIME__&quot;]&quot;
+
+
+#include &quot;avisynth.h&quot;
+
+
+
+struct AVSFunction {
+  const char* name;
+  const char* param_types;
+  AVSValue (__cdecl *apply)(AVSValue args, void* user_data, IScriptEnvironment* env);
+  void* user_data;
+};
+
+
+int RGB2YUV(int rgb);
+
+PClip Create_MessageClip(const char* message, int width, int height,
+  int pixel_type, bool shrink, int textcolor, int halocolor, int bgcolor,
+  IScriptEnvironment* env);
+
+PClip new_Splice(PClip _child1, PClip _child2, bool realign_sound, IScriptEnvironment* env);
+PClip new_SeparateFields(PClip _child, IScriptEnvironment* env);
+PClip new_AssumeFrameBased(PClip _child);
+
+void BitBlt(BYTE* dstp, int dst_pitch, const BYTE* srcp, 
+            int src_pitch, int row_size, int height);
+
+  void asm_BitBlt_ISSE(BYTE* dstp, int dst_pitch, const BYTE* srcp, int src_pitch, int row_size, int height);
+  void asm_BitBlt_MMX(BYTE* dstp, int dst_pitch, const BYTE* srcp, int src_pitch, int row_size, int height);
+
+long GetCPUFlags();
+
+
+class _PixelClip {
+  enum { buffer=320 };
+  BYTE clip[256+buffer*2];
+public:
+  _PixelClip() {  
+    memset(clip, 0, buffer);
+    for (int i=0; i&lt;256; ++i) clip[i+buffer] = i;
+    memset(clip+buffer+256, 255, buffer);
+  }
+  BYTE operator()(int i) { return clip[i+buffer]; }
+};
+
+extern _PixelClip PixelClip;
+
+
+template&lt;class ListNode&gt;
+static __inline void Relink(ListNode* newprev, ListNode* me, ListNode* newnext) {
+  if (me == newprev || me == newnext) return;
+  me-&gt;next-&gt;prev = me-&gt;prev;
+  me-&gt;prev-&gt;next = me-&gt;next;
+  me-&gt;prev = newprev;
+  me-&gt;next = newnext;
+  me-&gt;prev-&gt;next = me-&gt;next-&gt;prev = me;
+}
+
+
+
+/*** Inline helper methods ***/
+
+
+static __inline BYTE ScaledPixelClip(int i) {
+  return PixelClip((i+32768) &gt;&gt; 16);
+}
+
+
+static __inline bool IsClose(int a, int b, unsigned threshold) 
+  { return (unsigned(a-b+threshold) &lt;= threshold*2); }
+
+
+
+
+#endif  // __Internal_H__
\ No newline at end of file

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/TIsophote/original/resource.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/TIsophote/original/resource.h	2008-06-16 17:49:32 UTC (rev 4111)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/TIsophote/original/resource.h	2008-06-16 18:07:45 UTC (rev 4112)
@@ -0,0 +1,14 @@
+//{{NO_DEPENDENCIES}}
+// Microsoft Visual C++ generated include file.
+// Used by TIsophote.rc
+
+// Next default values for new objects
+// 
+#ifdef APSTUDIO_INVOKED
+#ifndef APSTUDIO_READONLY_SYMBOLS
+#define _APS_NEXT_RESOURCE_VALUE        101
+#define _APS_NEXT_COMMAND_VALUE         40001
+#define _APS_NEXT_CONTROL_VALUE         1001
+#define _APS_NEXT_SYMED_VALUE           101
+#endif
+#endif


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001367.html">[Avidemux-svn-commit] r4111 - branches/avidemux_2.4_branch/avidemux
</A></li>
	<LI>Next message: <A HREF="001369.html">[Avidemux-svn-commit] r4113 -	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1368">[ date ]</a>
              <a href="thread.html#1368">[ thread ]</a>
              <a href="subject.html#1368">[ subject ]</a>
              <a href="author.html#1368">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
