<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r4089 - in	branches/avidemux_2.5_branch_gruntster: avidemux/ADM_codecs	avidemux/ADM_inputs/ADM_matroska	avidemux/ADM_libraries/ADM_utilities avidemux/ADM_outputs	avidemux/ADM_outputs/oplug_flv plugins/ADM_videoFilters/Ass
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2008-June/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r4089%20-%20in%0A%09branches/avidemux_2.5_branch_gruntster%3A%20avidemux/ADM_codecs%0A%09avidemux/ADM_inputs/ADM_matroska%0A%09avidemux/ADM_libraries/ADM_utilities%20avidemux/ADM_outputs%0A%09avidemux/ADM_outputs/oplug_flv%20plugins/ADM_videoFilters/Ass&In-Reply-To=%3C200806080716.m587GkM0012339%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001344.html">
   <LINK REL="Next"  HREF="001346.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r4089 - in	branches/avidemux_2.5_branch_gruntster: avidemux/ADM_codecs	avidemux/ADM_inputs/ADM_matroska	avidemux/ADM_libraries/ADM_utilities avidemux/ADM_outputs	avidemux/ADM_outputs/oplug_flv plugins/ADM_videoFilters/Ass</H1>
    <B>mean at BerliOS</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r4089%20-%20in%0A%09branches/avidemux_2.5_branch_gruntster%3A%20avidemux/ADM_codecs%0A%09avidemux/ADM_inputs/ADM_matroska%0A%09avidemux/ADM_libraries/ADM_utilities%20avidemux/ADM_outputs%0A%09avidemux/ADM_outputs/oplug_flv%20plugins/ADM_videoFilters/Ass&In-Reply-To=%3C200806080716.m587GkM0012339%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r4089 - in	branches/avidemux_2.5_branch_gruntster: avidemux/ADM_codecs	avidemux/ADM_inputs/ADM_matroska	avidemux/ADM_libraries/ADM_utilities avidemux/ADM_outputs	avidemux/ADM_outputs/oplug_flv plugins/ADM_videoFilters/Ass">mean at mail.berlios.de
       </A><BR>
    <I>Sun Jun  8 09:16:46 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001344.html">[Avidemux-svn-commit] r4088 -	branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_matroska
</A></li>
        <LI>Next message: <A HREF="001346.html">[Avidemux-svn-commit] r4090 -	branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1345">[ date ]</a>
              <a href="thread.html#1345">[ thread ]</a>
              <a href="subject.html#1345">[ subject ]</a>
              <a href="author.html#1345">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2008-06-08 09:16:45 +0200 (Sun, 08 Jun 2008)
New Revision: 4089

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_codecs.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_matroska/ADM_mkv.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_matroska/ADM_mkv.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_matroska/ADM_mkvEntries.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_matroska/ADM_mkvIndexer.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_matroska/ADM_mkv_audio.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_utilities/fourcc.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_utilities/fourcc.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/ADM_lavformat.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_flv/oplug_flv.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/CMakeLists.txt
Log:
[MKV] Merge


Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_codecs.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_codecs.cpp	2008-06-07 20:32:22 UTC (rev 4088)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_codecs.cpp	2008-06-08 07:16:45 UTC (rev 4089)
@@ -150,6 +150,23 @@
 
 #undef CHECK
 }
+uint8_t isVP6Compatible (uint32_t fourcc)
+{
+
+#define CHECK(x) if(fourCC::check(fourcc,(uint8_t *)x)) \
+						{divx3=1; }
+
+  uint8_t divx3 = 0;
+
+  CHECK (&quot;VP6F&quot;);
+  CHECK (&quot;VP6 &quot;);
+  CHECK (&quot;VP61&quot;);
+  CHECK (&quot;VP62&quot;);
+
+  return divx3;
+
+#undef CHECK
+}
 uint8_t
 isDVCompatible (uint32_t fourcc)
 {
@@ -363,8 +380,7 @@
       return (decoders *) (new decoderFFAMV (w, h,extraLen,extraData));
     }
 
-    
-  if (fourCC::check (fcc, (uint8_t *) &quot;VP6F&quot;))
+    if (isVP6Compatible(fcc))
     {
       printf (&quot;\n using VP6F codec\n&quot;);
       return (decoders *) (new decoderFFVP6F (w, h,extraLen,extraData));

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_matroska/ADM_mkv.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_matroska/ADM_mkv.cpp	2008-06-07 20:32:22 UTC (rev 4088)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_matroska/ADM_mkv.cpp	2008-06-08 07:16:45 UTC (rev 4089)
@@ -31,19 +31,19 @@
 
 uint8_t mkvHeader::open(char *name)
 {
- 
+
   ADM_ebml_file ebml;
   uint64_t id,len;
   uint64_t alen;
   ADM_MKV_TYPE type;
   const char *ss;
-  
-  
+
+
   _isvideopresent=0;
-  if(!ebml.open(name)) 
+  if(!ebml.open(name))
   {
     printf(&quot;[MKV]Failed to open file\n&quot;);
-    return 0; 
+    return 0;
   }
   if(!ebml.find(ADM_MKV_PRIMARY,EBML_HEADER,(MKV_ELEM_ID)0,&amp;alen))
   {
@@ -84,30 +84,50 @@
     if(!videoIndexer(&amp;ebml))
     {
       printf(&quot;[MKV] Video indexing failed\n&quot;);
-      return 0; 
+      return 0;
     }
   // update some infos
-  _videostream.dwLength= _mainaviheader.dwTotalFrames=_tracks[0]._nbIndex; 
-  
+  _videostream.dwLength= _mainaviheader.dwTotalFrames=_tracks[0]._nbIndex;
+
   _parser=new ADM_ebml_file();
   ADM_assert(_parser-&gt;open(name));
   _filename=ADM_strdup(name);
-  
+
   // Finaly update index with queue
+  float duration=_videostream.dwLength*_tracks[0]._defaultFrameDuration;
+  duration/=1000;
+  uint32_t duration32=(uint32_t)duration;
+  printf(&quot;[MKV] Video Track duration %u ms\n&quot;,_videostream.dwLength);
   // Useless.....readCue(&amp;ebml);
   for(int i=0;i&lt;_nbAudioTrack;i++)
   {
+    rescaleTrack(&amp;(_tracks[1+i]),duration32);
     if(_tracks[1+i].wavHeader.encoding==WAV_OGG)
     {
         printf(&quot;[MKV] Reformatting vorbis header for track %u\n&quot;,i);
-        reformatVorbisHeader(&amp;(_tracks[1+i]));  
+        reformatVorbisHeader(&amp;(_tracks[1+i]));
     }
   }
   printf(&quot;[MKV]Matroska successfully read\n&quot;);
-  
+
   return 1;
 }
 /**
+    \fn rescaleTrack
+    \brief Compute the average duration of one audio frame if the info is not present in the stream
+
+*/
+uint8_t mkvHeader::rescaleTrack(mkvTrak *track,uint32_t durationMs)
+{
+        if(track-&gt;_defaultFrameDuration) return 1; // No need to change
+        float samples=1000.;
+        samples*=durationMs;
+        samples/=track-&gt;nbPackets;  // 1000 * sample per packet
+        track-&gt;_defaultFrameDuration=(uint32_t)samples;
+        return 1;
+
+}
+/**
     \fn checkHeader
     \brief Check that we are compatible with that version of matroska. At the moment, just dump some infos.
 */
@@ -117,8 +137,8 @@
  ADM_ebml_file father( (ADM_ebml_file *)head,headlen);
  walk(&amp;father);
  printf(&quot;[MKV] *** End of Header dump ***\n&quot;);
- return 1; 
-  
+ return 1;
+
 }
 /**
     \fn analyzeTracks
@@ -140,15 +160,15 @@
         continue;
       }
       ADM_assert(ss);
-      if(id!=MKV_TRACK_ENTRY) 
+      if(id!=MKV_TRACK_ENTRY)
       {
         printf(&quot;[MKV] skipping %s\n&quot;,ss);
         father.skip(len);
-        continue; 
+        continue;
       }
       if(!analyzeOneTrack(&amp;father,len)) return 0;
  }
- return 1; 
+ return 1;
 }
 
 /**
@@ -160,7 +180,7 @@
   uint64_t id,len;
   ADM_MKV_TYPE type;
   const char *ss;
-  
+
    ADM_ebml_file *father=(ADM_ebml_file *)seed;
     while(!father-&gt;finished())
    {
@@ -210,7 +230,7 @@
 {
   if(_nbAudioTrack)
   {
-    return &amp;(_tracks[1+_currentAudioTrack].wavHeader); 
+    return &amp;(_tracks[1+_currentAudioTrack].wavHeader);
   }
   return NULL;
 }
@@ -226,7 +246,7 @@
       return 1;
   }
   *audio=NULL;
-  return 0; 
+  return 0;
 }
 /*
     __________________________________________________________
@@ -234,7 +254,7 @@
 
 void mkvHeader::Dump(void)
 {
- 
+
 }
 
 /*
@@ -246,21 +266,21 @@
   if(_clusters)
   {
     delete [] _clusters;
-    _clusters=NULL; 
+    _clusters=NULL;
   }
   // CLEANUP!!
   if(_parser) delete _parser;
   _parser=NULL;
-  
-  
+
+
 #define FREEIF(i) { if(_tracks[i].extraData) delete [] _tracks[i].extraData; _tracks[i].extraData=0;}
   if(_isvideopresent)
   {
-      FREEIF(0); 
+      FREEIF(0);
   }
   for(int i=0;i&lt;_nbAudioTrack;i++)
   {
-    FREEIF(1+i); 
+    FREEIF(1+i);
   }
   // Delete index
   if(_isvideopresent &amp;&amp; _tracks[0]._index)
@@ -283,13 +303,13 @@
 */
 
  mkvHeader::mkvHeader( void ) : vidHeader()
-{ 
+{
   _parser=NULL;
   _nbAudioTrack=0;
   _filename=NULL;
   memset(_tracks,0,sizeof(_tracks));
   _reordered=0;
-  
+
   _clusters=NULL;
   _clustersCeil=0;
   _nbClusters=0;
@@ -316,7 +336,7 @@
 {
   if(frame&gt;=_tracks[0]._nbIndex) return 0;
   _tracks[0]._index[frame].flags=flags;
-  return 1; 
+  return 1;
 }
 /*
     __________________________________________________________
@@ -327,7 +347,7 @@
   if(frame&gt;=_tracks[0]._nbIndex) return 0;
   *flags=_tracks[0]._index[frame].flags;
   if(!frame) *flags=AVI_KEY_FRAME;
-  return 1; 
+  return 1;
 }
 /*
     __________________________________________________________
@@ -337,19 +357,19 @@
 {
   ADM_assert(_parser);
   if(framenum&gt;=_tracks[0]._nbIndex) return 0;
-  
+
   mkvIndex *dx=&amp;(_tracks[0]._index[framenum]);
-  
+
   _parser-&gt;seek(dx-&gt;pos);
   _parser-&gt;readBin(img-&gt;data,dx-&gt;size);
   img-&gt;dataLength=dx-&gt;size;
-  
+
   img-&gt;flags=dx-&gt;flags;
-  
+
   if(!framenum) img-&gt;flags=AVI_KEY_FRAME;
-  
-  
-  return 1; 
+
+
+  return 1;
 }
 /*
     __________________________________________________________
@@ -359,13 +379,13 @@
 {
                 *len=_tracks[0].extraDataLen;
                 *data=_tracks[0].extraData;
-                return 1;            
+                return 1;
 }
 /*
     __________________________________________________________
 */
 uint8_t			mkvHeader::isReordered( void )
-{ 
+{
  	return _reordered;
 }
 /*
@@ -373,16 +393,16 @@
 */
 uint8_t mkvHeader::reorder( void )
 {
-  
+
 #define INDEX_TMPL        mkvIndex
 #define INDEX_ARRAY_TMPL  (_tracks[0]._index)
 #define FRAMETYPE_TMPL    flags
-  
+
 #include &quot;ADM_video/ADM_reorderTemplate.cpp&quot;
 
-#undef INDEX_TMPL       
-#undef INDEX_ARRAY_TMPL 
-#undef FRAMETYPE_TMPL   
+#undef INDEX_TMPL
+#undef INDEX_ARRAY_TMPL
+#undef FRAMETYPE_TMPL
      _tracks[0]._nbIndex=_videostream.dwLength;
          return 1;
 }
@@ -457,14 +477,14 @@
         head++; \
       } \
       x+=*head++;
-  
+
       READ_LEN(len1);
       READ_LEN(len2);
       len3=oldata+oldlen-head;
       if(len3&lt;=len1+len2)
       {
         printf(&quot;Error in vorbis header, len3 too small %u %u / %u\n&quot;,len1,len2,len3);
-        return 0; 
+        return 0;
       }
       len3-=(len1+len2);
       printf(&quot;Found packet len : %u %u %u, total size %u\n&quot;,len1,len2,len3,oldlen);
@@ -475,7 +495,7 @@
       memcpy(cp,head,len1);
       memcpy(cp+len1,head+len1,len2);
       memcpy(cp+len1+len2,head+len1+len2,len3);
-      
+
       uint32_t *h=(uint32_t *)nwdata;
       h[0]=len1;
       h[1]=len2;
@@ -484,7 +504,7 @@
       delete [] oldata;
       trk-&gt;extraData=nwdata;
       trk-&gt;extraDataLen=nwlen;
-  return 1; 
+  return 1;
 }
 //****************************************
 /**

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_matroska/ADM_mkv.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_matroska/ADM_mkv.h	2008-06-07 20:32:22 UTC (rev 4088)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_matroska/ADM_mkv.h	2008-06-08 07:16:45 UTC (rev 4089)
@@ -14,9 +14,9 @@
  *   (at your option) any later version.                                   *
  *                                                                         *
  ***************************************************************************/
- 
 
 
+
 #ifndef ADM_MKV_H
 #define ADM_MKV_H
 
@@ -25,7 +25,7 @@
 #include &quot;ADM_inputs/ADM_matroska/ADM_ebml.h&quot;
 
 
-typedef struct 
+typedef struct
 {
     uint64_t pos;
     uint32_t size;
@@ -33,11 +33,11 @@
     uint32_t timeCode;  // In fact it is delta between DTS and PTS for audio...
 }mkvIndex;
 //**********************************************
-typedef struct 
+typedef struct
 {
   /* Index in mkv */
   uint32_t  streamIndex;
-  
+
   /* Used for audio */
   WAVHeader wavHeader;
   uint32_t  nbPackets;
@@ -49,7 +49,7 @@
   uint32_t  _nbIndex;  // current size of the index
   uint32_t  _indexMax; // Max size of the index
   uint32_t  _sizeInBytes; // Approximate size in bytes of that stream
-  uint32_t  _defaultFrameDuration; // in us!
+  uint32_t  _defaultFrameDuration; // Duration of ONE frame in us!
 }mkvTrak;
 
 #define MKV_MAX_LACES 20 // ?
@@ -63,9 +63,8 @@
     mkvIndex                    *_clusters;
     uint32_t                    _nbClusters;
     uint32_t                    _currentCluster;
-    
+
     uint32_t                    _frameDurationInSample; // Nb Samples per frame
-    
     uint32_t                    _currentLace;
     uint32_t                    _maxLace;
     uint32_t                    _Laces[MKV_MAX_LACES];
@@ -75,8 +74,8 @@
     uint32_t                    _curTimeCode;
   public:
                                 mkvAudio(const char *name,mkvTrak *track,mkvIndex *clust,uint32_t nbClusters);
-                                
-                                
+
+
     virtual                     ~mkvAudio();
     virtual uint32_t            read(uint32_t len,uint8_t *buffer);
     virtual uint8_t             goTo(uint32_t newoffset);
@@ -92,7 +91,7 @@
 class mkvHeader         :public vidHeader
 {
   protected:
-                                
+
     ADM_ebml_file           *_parser;
     char                    *_filename;
     mkvTrak                 _tracks[ADM_MKV_MAX_TRACKS+1];
@@ -100,31 +99,31 @@
     mkvIndex                    *_clusters;
     uint32_t                    _nbClusters;
     uint32_t                    _clustersCeil;
- 
+
     uint32_t                _nbAudioTrack;
     uint32_t                _currentAudioTrack;
     uint32_t                _reordered;
-    
+
     uint8_t                 checkHeader(void *head,uint32_t headlen);
     uint8_t                 analyzeTracks(void *head,uint32_t headlen);
     uint8_t                 analyzeOneTrack(void *head,uint32_t headlen);
     uint8_t                 walk(void *seed);
     int                     searchTrackFromTid(uint32_t tid);
     //
-    uint8_t                 reformatVorbisHeader(mkvTrak *trk);  
+    uint8_t                 reformatVorbisHeader(mkvTrak *trk);
     // Indexers
-    
+
     uint8_t                 addIndexEntry(uint32_t track,uint64_t where, uint32_t size,uint32_t flags,
                                             uint32_t timecodeMS);
     uint8_t                 videoIndexer(ADM_ebml_file *parser);
     uint8_t                 readCue(ADM_ebml_file *parser);
     uint8_t                 indexClusters(ADM_ebml_file *parser);
     uint8_t                 indexBlock(ADM_ebml_file *parser,uint32_t count,uint32_t timecodeMS);
-    
+
     uint8_t                 changeAudioStream(uint32_t newstream);
     uint32_t                getCurrentAudioStreamNumber(void);
     uint8_t                 getAudioStreamsInfo(uint32_t *nbStreams, audioInfo **infos);
-    
+    uint8_t                 rescaleTrack(mkvTrak *track,uint32_t durationMs);
   public:
 
       uint8_t               hasPtsDts(void) {return 1;} // Return 1 if the container gives PTS &amp; DTS info

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_matroska/ADM_mkvEntries.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_matroska/ADM_mkvEntries.cpp	2008-06-07 20:32:22 UTC (rev 4088)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_matroska/ADM_mkvEntries.cpp	2008-06-08 07:16:45 UTC (rev 4089)
@@ -37,14 +37,14 @@
           uint32_t     trackNo;
           uint32_t     trackType;
           uint32_t     extraDataLen;
-          
+
           uint32_t fcc;
           uint32_t w,h,fps;
           uint32_t fq,chan,bpp;
           uint32_t defaultDuration;
           float    trackScale;
           uint8_t *extraData;
-          
+
           void dump(void);
 };
 /* Prototypes */
@@ -86,7 +86,7 @@
 /**
       \fn analyzeOneTrack
       \brief Grab info about the track (it is a recursive function !)
-              
+
 */
 uint8_t mkvHeader::analyzeOneTrack(void *head,uint32_t headlen)
 {
@@ -96,12 +96,12 @@
       /* Set some defaults value */
 
       entry.chan=2;
-      
+
       entryWalk(  (ADM_ebml_file *)head,headlen,&amp;entry);
       entry.dump();
       if(entry.trackType==1 &amp;&amp;  !_isvideopresent)
       {
-        _isvideopresent=1; 
+        _isvideopresent=1;
         if(entry.defaultDuration)
         {
             _tracks[0]._defaultFrameDuration=entry.defaultDuration;
@@ -114,13 +114,13 @@
             _videostream.dwRate=(uint32_t)inv;
         }else
         {
-          printf(&quot;[MKV] No duration, assuming 25 fps\n&quot;); 
+          printf(&quot;[MKV] No duration, assuming 25 fps\n&quot;);
           _videostream.dwScale=1000;
           _videostream.dwRate=25000;
 
         }
-    
-        _mainaviheader.dwMicroSecPerFrame=(uint32_t)floor(50);;     
+
+        _mainaviheader.dwMicroSecPerFrame=(uint32_t)floor(50);;
         _videostream.fccType=fourCC::get((uint8_t *)&quot;vids&quot;);
         _video_bih.biBitCount=24;
         _videostream.dwInitialFrames= 0;
@@ -128,7 +128,7 @@
         _video_bih.biWidth=_mainaviheader.dwWidth=entry.w;
         _video_bih.biHeight=_mainaviheader.dwHeight=entry.h;
         _videostream.fccHandler=_video_bih.biCompression=entry.fcc;
-        
+
         // if it is vfw...
         if(fourCC::check(entry.fcc,(uint8_t *)&quot;VFWX&quot;) &amp;&amp; entry.extraData &amp;&amp; entry.extraDataLen&gt;=sizeof(ADM_BITMAPINFOHEADER))
         {
@@ -136,24 +136,24 @@
           delete [] _tracks[0].extraData;
           entry.extraData=NULL;
           entry.extraDataLen=0;
-          
+
           _videostream.fccHandler=_video_bih.biCompression;
           _mainaviheader.dwWidth=  _video_bih.biWidth;
-          _mainaviheader.dwHeight= _video_bih.biHeight;    
-          
+          _mainaviheader.dwHeight= _video_bih.biHeight;
+
         } // FIXME there can be real extradata after bitmapinfoheader
-        
-        _tracks[0].extraData=entry.extraData; 
-        _tracks[0].extraDataLen=entry.extraDataLen;       
+
+        _tracks[0].extraData=entry.extraData;
+        _tracks[0].extraDataLen=entry.extraDataLen;
         _tracks[0].streamIndex=entry.trackNo;
-        
+
         return 1;
       }
       if(entry.trackType==2 &amp;&amp; _nbAudioTrack&lt;ADM_MKV_MAX_TRACKS)
       {
          uint32_t  streamIndex;
          mkvTrak *t=&amp;(_tracks[1+_nbAudioTrack]);
-         
+
          t-&gt;wavHeader.encoding=entry.fcc;
          t-&gt;wavHeader.channels=entry.chan;
          t-&gt;wavHeader.frequency=entry.fq;
@@ -165,15 +165,15 @@
          if(entry.defaultDuration)
           t-&gt;_defaultFrameDuration=entry.defaultDuration;
          else
-           t-&gt;_defaultFrameDuration=24000;
+           t-&gt;_defaultFrameDuration=0;
         _nbAudioTrack++;
         return 1;
       }
       if(entry.extraData) delete [] entry.extraData;
       return 1;
-  
+
 }
-  
+
 /**
     \fn entryWalk
     \brief walk a trackEntry atom and grabs all infos. Store them in entry
@@ -184,7 +184,7 @@
    uint64_t id,len;
   ADM_MKV_TYPE type;
   const char *ss;
-  
+
   while(!father.finished())
   {
       father.readElemId(&amp;id,&amp;len);
@@ -196,7 +196,7 @@
       }
       switch(id)
       {
-        
+
         case  MKV_TRACK_NUMBER: entry-&gt;trackNo=father.readUnsignedInt(len);break;
         case  MKV_TRACK_TYPE: entry-&gt;trackType=father.readUnsignedInt(len);break;
 
@@ -225,13 +225,13 @@
                   father.readBin(codec,len);
                   codec[len]=0;
                   entry-&gt;fcc=ADM_mkvCodecToFourcc((char *)codec);
-                  
+
             }
                   break;
         default: printf(&quot;[MKV]not handled %s\n&quot;,ss);
-                  father.skip(len);  
+                  father.skip(len);
         }
-        
+
       }
   return 1;
 }//EOF

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_matroska/ADM_mkvIndexer.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_matroska/ADM_mkvIndexer.cpp	2008-06-07 20:32:22 UTC (rev 4088)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_matroska/ADM_mkvIndexer.cpp	2008-06-08 07:16:45 UTC (rev 4089)
@@ -44,7 +44,7 @@
   uint64_t id;
   ADM_MKV_TYPE type;
   const char *ss;
-  
+
    parser-&gt;seek(0);
    DIA_working *work=new DIA_working(&quot;Matroska Images&quot;);
    // Start with a small index, it will grow automatically afterward
@@ -73,8 +73,8 @@
       //printf(&quot;\t\tFound %s\n&quot;,ss);
       switch(id)
       {
-                default: 
-                case MKV_TIMECODE: 
+                default:
+                case MKV_TIMECODE:
                   //printf(&quot;Skipping %s\n&quot;,ss);
                   cluster.skip(len);
                   break;
@@ -101,7 +101,7 @@
                                 switch(id)
                                 {
                                   default: blockGroup.skip(len);
-                                  case MKV_BLOCK : 
+                                  case MKV_BLOCK :
                                   case MKV_SIMPLE_BLOCK:
                                   {
                                     indexBlock(&amp;blockGroup,len,_clusters[clusters].timeCode);
@@ -111,7 +111,7 @@
                           }
                           thiscluster++;
             }
-            
+
             break; // Block Group
        }
      }
@@ -130,19 +130,19 @@
   int lacing,nbLaces,entryFlags=0;
   //
   uint64_t tail=parser-&gt;tell()+len;
-  // Read Track id 
+  // Read Track id
   uint32_t tid=parser-&gt;readEBMCode();
   int track=searchTrackFromTid(tid);
-  
+
       //printf(&quot;Wanted %u got %u\n&quot;,_tracks[0].streamIndex,tid);
       if(track==-1) //dont care track
       {
-        
+
         parser-&gt;seek(tail);
         return 1; // we do only video here...
       }
       // Skip timecode
-      int16_t timecode=parser-&gt;readSignedInt(2); 
+      int16_t timecode=parser-&gt;readSignedInt(2);
       //if(!track) printf(&quot;TC: %d\n&quot;,timecode);
       uint8_t flags=parser-&gt;readu8();
       uint32_t remaining=tail-parser-&gt;tell();
@@ -153,12 +153,13 @@
       {
         case 0: // No lacing
               if(!track) // Video
-              {    
+              {
                   addIndexEntry(track,parser-&gt;tell(),remaining,entryFlags,clusterTimeCodeMs+timecode);
               }
               else
               {
-                _tracks[track]._sizeInBytes+=remaining; // keep some stat, useful for audio 
+                _tracks[track]._sizeInBytes+=remaining; // keep some stat, useful for audio
+                _tracks[track].nbPackets++;
               }
               break;
         case 2 : // Constant size lacing
@@ -166,14 +167,14 @@
                     nbLaces=parser-&gt;readu8()+1;
                     remaining--;
                     // Only mp3/Ac3 supported, ignore lacing FIXME : Vorbis or AAC will not work
-                    
-                    
+
+
                     int bsize=remaining/nbLaces;
                     if(bsize*nbLaces!=remaining)
                     {
                       printf(&quot;Warning not multiple bsize=%d total=%u  nbLaces=%u\n&quot;,bsize,remaining,nbLaces);
                     }
-                    if(!track) 
+                    if(!track)
                     {
                       addIndexEntry(track,parser-&gt;tell(),remaining,0,clusterTimeCodeMs+timecode);
                       printf(&quot;Warning lacing on video track\n&quot;);
@@ -181,6 +182,7 @@
                     else
                     {
                        _tracks[track]._sizeInBytes+=remaining;
+                       _tracks[track].nbPackets++;
                     }
                     //printf(&quot;tid:%u track %u Remaining : %llu laces %u blksize %d er%d\n&quot;,tid,track,remaining,nbLaces,remaining/nbLaces,remaining-(remaining/nbLaces)*nbLaces);
             }
@@ -188,7 +190,7 @@
 #if 1
         case 3: // Ebml lacing
           {
-                                
+
                                 int nbLaces=parser-&gt;readu8();
                                 for(int i=1;i&lt;nbLaces;i++)
                                 {
@@ -197,13 +199,14 @@
                                 ADM_assert(track); // Not video!
                                 if(parser-&gt;tell()&gt;=tail)
                                 {
-                                  printf(&quot;[MKVINDEXER]OOps overflow for EBML(track %u tid%u) at 0x%llx\n&quot;,track,tid,parser-&gt;tell()); 
+                                  printf(&quot;[MKVINDEXER]OOps overflow for EBML(track %u tid%u) at 0x%llx\n&quot;,track,tid,parser-&gt;tell());
                                   break;
                                 }else
                                 {
                                     _tracks[track]._sizeInBytes+=tail-parser-&gt;tell();
+                                    _tracks[track].nbPackets++;
                                 }
-                                
+
                               }
             break;
 #endif
@@ -217,16 +220,17 @@
                                 }
                                 if(parser-&gt;tell()&gt;=tail)
                                 {
-                                  printf(&quot;[MKVINDEXER]OOps overflow for XIPH(track %u tid%u) at 0x%llx\n&quot;,track,tid,parser-&gt;tell()); 
+                                  printf(&quot;[MKVINDEXER]OOps overflow for XIPH(track %u tid%u) at 0x%llx\n&quot;,track,tid,parser-&gt;tell());
                                   break;
                                 }
                                 ADM_assert(track); // Not video!
                                 _tracks[track]._sizeInBytes+=(tail-parser-&gt;tell());
+                                _tracks[track].nbPackets++;
                                 //printf(&quot;This round %lld total:%lld\n&quot;,tail-parser-&gt;tell(),    _tracks[track]._sizeInBytes);
                                 break;
-          
+
         }
-        default: 
+        default:
             printf(&quot;unsupported lacing Track:%d (%d)\n&quot;,track,lacing);
             break;
       }
@@ -246,21 +250,21 @@
   // Need to grow index ?
   if(Track-&gt;_nbIndex==Track-&gt;_indexMax-1)
   {
-    // Realloc 
+    // Realloc
     mkvIndex *dx=new mkvIndex[Track-&gt;_indexMax*2];
     memcpy(dx, Track-&gt;_index,sizeof(mkvIndex)*Track-&gt;_nbIndex);
     Track-&gt;_indexMax*=2;
     delete [] Track-&gt;_index;
     Track-&gt;_index=dx;
   }
-  
+
   mkvIndex *index=Track-&gt;_index;
   int x=Track-&gt;_nbIndex;
   index[x].pos=where;
   index[x].size=size;
   index[x].flags=AVI_KEY_FRAME;
   index[x].timeCode=0;
-  
+
   float f=timecodeMS;
   uint32_t delta;
   f*=_videostream.dwRate;
@@ -270,14 +274,14 @@
   //printf(&quot;Frame :%u rawTimeCode:%u convertedtoframe:%u \n&quot;,Track-&gt;_nbIndex,timecodeMS,delta);
   if(delta+2&lt;Track-&gt;_nbIndex)
   {
-    printf(&quot;[MKV] WARNING DELTA PTS/DTS is negative for frame %u (delta:%u, raw value %u,dwrate=%u)\n&quot;,Track-&gt;_nbIndex,delta,timecodeMS,_videostream.dwRate); 
+    printf(&quot;[MKV] WARNING DELTA PTS/DTS is negative for frame %u (delta:%u, raw value %u,dwrate=%u)\n&quot;,Track-&gt;_nbIndex,delta,timecodeMS,_videostream.dwRate);
     index[x].timeCode=0;
   }else
   {
     index[x].timeCode=delta+1-Track-&gt;_nbIndex;
   }
   Track-&gt;_nbIndex++;
-  
+
  // printf(&quot;++\n&quot;);
   return 1;
 }
@@ -310,9 +314,9 @@
   const char *ss;
   uint64_t time;
   uint64_t segmentPos;
-  
+
    parser-&gt;seek(0);
-   
+
    if(!parser-&gt;simplefind(MKV_SEGMENT,&amp;vlen,1))
    {
      printf(&quot;[MKV] Cannot find CLUSTER atom\n&quot;);
@@ -320,7 +324,7 @@
    }
    ADM_ebml_file segment(parser,vlen);
    segmentPos=segment.tell();
-   
+
    while(segment.simplefind(MKV_CUES,&amp;alen,0))
   {
    ADM_ebml_file cues(&amp;segment,alen);
@@ -335,7 +339,7 @@
       }
       if(id!=MKV_CUE_POINT)
       {
-        printf(&quot;Found %s in CUES, ignored \n&quot;,ss); 
+        printf(&quot;Found %s in CUES, ignored \n&quot;,ss);
         cues.skip(len);
         continue;
       }
@@ -350,8 +354,8 @@
           continue;
        }
        time=cue.readUnsignedInt(len);
-       
-       
+
+
        cue.readElemId(&amp;id,&amp;len);
        if(id!=MKV_CUE_TRACK_POSITION)
        {
@@ -370,7 +374,7 @@
          {
            case MKV_CUE_TRACK: tid=trackPos.readUnsignedInt(len);break;
            case MKV_CUE_CLUSTER_POSITION: cluster_position=trackPos.readUnsignedInt(len);break;
-           default: 
+           default:
                  ADM_searchMkvTag( (MKV_ELEM_ID)id,&amp;ss,&amp;type);
                  printf(&quot;[MKV] in cluster position found tag %s (0x%x)\n&quot;,ss,id);
                  trackPos.skip(len);
@@ -382,7 +386,7 @@
      }
    }
    printf(&quot;[MKV] Cues updated\n&quot;);
-   return 1;  
+   return 1;
 }
 /**
         \fn indexClusters
@@ -403,7 +407,7 @@
   _clusters=new mkvIndex[NB_DEFAULT_CLUSTERS];
   _clustersCeil=NB_DEFAULT_CLUSTERS;
   _nbClusters=0;
-  
+
   // Search segment
    fileSize=parser-&gt;getFileSize();
    if(!parser-&gt;simplefind(MKV_SEGMENT,&amp;vlen,1))
@@ -413,9 +417,9 @@
    }
    ADM_ebml_file segment(parser,vlen);
    DIA_working *work=new DIA_working(&quot;Matroska clusters&quot;);
-   while(segment.simplefind(MKV_CLUSTER,&amp;alen,0)) 
+   while(segment.simplefind(MKV_CLUSTER,&amp;alen,0))
    {
-     
+
      // UI update
      work-&gt;update(segment.tell()&gt;&gt;10,fileSize&gt;&gt;10);
      // Grow clusters index if needed
@@ -429,8 +433,8 @@
      }
      _clusters[_nbClusters].pos=segment.tell();
      _clusters[_nbClusters].size=alen;
-     
-     // Normally the timecode is the 1st one following 
+
+     // Normally the timecode is the 1st one following
        segment.readElemId(&amp;id,&amp;len);
        int seekme=_nbClusters;
        if(id!=MKV_TIMECODE)
@@ -438,7 +442,7 @@
           ADM_searchMkvTag( (MKV_ELEM_ID)id,&amp;ss,&amp;type);
           printf(&quot;[MKV] Cluster : no time code Found %s(0x%x), expected MKV_TIMECODE  (0x%x)\n&quot;,
                   ss,id,MKV_TIMECODE);
-       } 
+       }
        else
        {
            uint64_t timecode=segment.readUnsignedInt(len);

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_matroska/ADM_mkv_audio.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_matroska/ADM_mkv_audio.cpp	2008-06-07 20:32:22 UTC (rev 4088)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_matroska/ADM_mkv_audio.cpp	2008-06-08 07:16:45 UTC (rev 4089)
@@ -33,14 +33,14 @@
 
 /**
     \fn ~mkvAudio
-    
+
 */
  mkvAudio ::~mkvAudio()
 {
   if(_clusterParser)  delete _clusterParser;
   _clusterParser=NULL;
     if(_parser) delete _parser;
-  _parser=NULL; 
+  _parser=NULL;
 
 }
 
@@ -65,7 +65,7 @@
 uint8_t             mkvAudio::extraData(uint32_t *l,uint8_t **d)
 {
   *l=_track-&gt;extraDataLen;
-  *d=_track-&gt;extraData; 
+  *d=_track-&gt;extraData;
 }
 /**
     \fn getPacket
@@ -89,10 +89,25 @@
       _clusterParser-&gt;readBin(dest,_Laces[_currentLace]);
       *packlen= _Laces[_currentLace];
       vprintf(&quot;Continuing lacing : %u bytes, lacing %u/%u\n&quot;,*packlen,_currentLace,_maxLace);
+
+      if(_currentLace==_maxLace-1)
+      {
+          float f;
+          f=_frameDurationInSample;
+          f/=_maxLace;
+          uint32_t total=(uint32_t)floor(f);
+          total*=(_maxLace-1);
+          *samples=_frameDurationInSample-total;
+          ADM_assert(_frameDurationInSample&gt;=total);
+      }else
+      {
+          float f;
+          f=_frameDurationInSample;
+          f/=_maxLace;
+          *samples=(uint32_t )floor(f);
+      }
+      *timecode=_curTimeCode;
       _currentLace++;
-      *samples=_frameDurationInSample;
-      *timecode=_curTimeCode;
-      
       return 1;
     }
     while(1)
@@ -104,14 +119,14 @@
           if(!goToCluster(_currentCluster+1))
           {
             printf(&quot;[MKVAUDIO] cannot go to next cluster\n&quot;);
-            return 0; 
+            return 0;
           }
           _currentCluster++;
         }
         // Ok read a new block
         while(!_clusterParser-&gt;finished())
         {
-          
+
             _clusterParser-&gt;readElemId(&amp;id,&amp;len);
             pos=_clusterParser-&gt;tell();
             if(!ADM_searchMkvTag( (MKV_ELEM_ID)id,&amp;ss,&amp;type))
@@ -120,23 +135,23 @@
               _clusterParser-&gt;skip(len);
               continue;
             }
-            
+
             vprintf(&quot;[MKVAudio]Found tag %x (%s) at 0x%llx len %u\n&quot;,id,ss,_clusterParser-&gt;tell(),len);
-            
+
             switch(id)
             {
               default:
               case MKV_TIMECODE:     _clusterParser-&gt;skip(len);  break;
               case MKV_BLOCK_GROUP:    break;
-              case MKV_SIMPLE_BLOCK: 
-              case MKV_BLOCK: 
+              case MKV_SIMPLE_BLOCK:
+              case MKV_BLOCK:
               {
                   uint32_t tid=_clusterParser-&gt;readEBMCode();
                   uint64_t tail=pos+len;
                   uint64_t head=pos;
-                  
+
                   // FIXME WARNING ASSUME TRACK FITS ON 1 BYTE!
-                  len--; 
+                  len--;
                   vprintf(&quot;Tid = %u, my tid=%u\n&quot;,tid,_track-&gt;streamIndex);
                   if(tid!=_track-&gt;streamIndex)
                     {
@@ -155,19 +170,19 @@
                     uint32_t lacing=((flags&gt;&gt;1)&amp;3);
                     switch(lacing)
                     {
-                      case 0 : // no lacing 
-                          
+                      case 0 : // no lacing
+
                               vprintf(&quot;No lacing :%d bytes\n&quot;,remaining);
                               _clusterParser-&gt;readBin(dest,remaining);
-                              *packlen=remaining; 
+                              *packlen=remaining;
                               *samples=_frameDurationInSample;
                               _currentLace=_maxLace=0;
-                              
+
                               return 1;
                       case 1: //Xiph lacing
                         {
                                 int nbLaces=_clusterParser-&gt;readu8()+1;
-                                
+
                                 ADM_assert(nbLaces&lt;MKV_MAX_LACES);
                                 for(int i=0;i&lt;nbLaces-1;i++)
                                 {
@@ -178,40 +193,40 @@
                                   _Laces[i]=lce;
                                 }
                                 int64_t d=_clusterParser-&gt;tell();
-                                
+
                                 d=tail-d;
                                 /* We have the remaining size after laces, substract the already known lace size */
                                 for(int i=0;i&lt;nbLaces-1;i++)
                                 {
-                                  d-=_Laces[i]; 
+                                  d-=_Laces[i];
                                 }
                                 // What is left is the sift of the last lace
                                 if(d&gt;0)
-                                  _Laces[nbLaces-1]=(uint32_t)d; 
+                                  _Laces[nbLaces-1]=(uint32_t)d;
                                 else
                                 {
                                   printf(&quot;[MKVAUDIO] OOps overflow on Xiph\n&quot;);
-                                  nbLaces--; 
+                                  nbLaces--;
                                 }
 
-                                
+
                                 _currentLace=0;
                                 _maxLace=nbLaces;
                                 return getPacket(dest, packlen, samples);
                               }
-                              
+
                               break;
                       case 2 : // constant size lacing
                               {
                                 int nbLaces=_clusterParser-&gt;readu8()+1;
-                                
+
                                 remaining--;
                                 int bsize=remaining/nbLaces;
                                 vprintf(&quot;NbLaces :%u lacesize:%u\n&quot;,nbLaces,bsize);
                                 ADM_assert(nbLaces&lt;MKV_MAX_LACES);
                                 for(int i=0;i&lt;nbLaces;i++)
                                 {
-                                  _Laces[i]=bsize; 
+                                  _Laces[i]=bsize;
                                 }
                                 _currentLace=0;
                                 _maxLace=nbLaces;
@@ -220,13 +235,13 @@
                               break;
                       case 3: // Ebml lacing
                         {
-                                
+
                                 int nbLaces=_clusterParser-&gt;readu8()+1;
                                 int32_t curSize=_clusterParser-&gt;readEBMCode();
                                 int32_t delta;
-                                
+
                                 vprintf(&quot;Ebml nbLaces :%u lacesize(0):%u\n&quot;,nbLaces,curSize);
-                                
+
                                 _Laces[0]=curSize;
                                 ADM_assert(nbLaces&lt;MKV_MAX_LACES);
                                 for(int i=1;i&lt;nbLaces-1;i++)
@@ -235,24 +250,24 @@
                                   vprintf(&quot;Ebml delta :%d lacesize[%d]-&gt;:%d\n&quot;,delta,i,curSize+delta);
                                   curSize+=delta;
                                   ADM_assert(curSize&gt;0);
-                                  _Laces[i]=curSize; 
-                                 
+                                  _Laces[i]=curSize;
+
                                 }
                                 int64_t d=_clusterParser-&gt;tell();
-                                
+
                                 d=tail-d;
                                 /* We have the remaining size after laces, substract the already known lace size */
                                 for(int i=0;i&lt;nbLaces-1;i++)
                                 {
-                                  d-=_Laces[i]; 
+                                  d-=_Laces[i];
                                 }
                                 // What is left is the sift of the last lace
                                 if(d&gt;0)
-                                  _Laces[nbLaces-1]=(uint32_t)d; 
+                                  _Laces[nbLaces-1]=(uint32_t)d;
                                 else
                                 {
                                   printf(&quot;[MKVAUDIO] OOps overflow on ebml\n&quot;);
-                                  nbLaces--; 
+                                  nbLaces--;
                                 }
                                 _currentLace=0;
                                 _maxLace=nbLaces;
@@ -263,7 +278,7 @@
                             printf(&quot;Unsupported lacing %u\n&quot;,lacing);
                             _clusterParser-&gt;seek(pos+len);
                     }
-                
+
               }
               break;
             }
@@ -272,33 +287,35 @@
   return 0;
 }
 /**
-      \fn mkvAudio 
+      \fn mkvAudio
 */
- mkvAudio::mkvAudio(const char *name,mkvTrak *track,mkvIndex *clust,uint32_t nbClusters) 
+ mkvAudio::mkvAudio(const char *name,mkvTrak *track,mkvIndex *clust,uint32_t nbClusters)
   : AVDMGenericAudioStream()
 {
   _nbClusters=nbClusters;
   _clusters=clust;
   ADM_assert(_clusters);
   _destroyable = 1;
-  
+
    _parser=new ADM_ebml_file();
    ADM_assert(_parser-&gt;open(name));
-  _track=track; 
+  _track=track;
   ADM_assert(_track);
-  
-  
+
+
   // Compute total length in byte
   _length=_track-&gt;_sizeInBytes; // FIXME
-  
+
   float f=_track-&gt;wavHeader.frequency;
   f*=_track-&gt;_defaultFrameDuration;
   f=f/1000000.;
-  
+
   _frameDurationInSample=(uint32_t)floor(f+0.5);
-  
+
   _wavheader=new WAVHeader;
   memcpy(_wavheader,&amp;(_track-&gt;wavHeader),sizeof(WAVHeader));
+  printf(&quot;[MKVAUDIO] found %lu packets\n&quot;,track-&gt;nbPackets);
+  printf(&quot;[MKVAUDIO] Default duration %u us\n&quot;,_track-&gt;_defaultFrameDuration);
   printf(&quot;[MKVAUDIO] found %lu bytes, %u samples per frame\n&quot;,_length,_frameDurationInSample);
   _currentLace=_maxLace=0;
   _clusterParser=NULL;
@@ -328,20 +345,21 @@
 uint8_t mkvAudio::goToCluster(uint32_t x)
 {
   ADM_assert(_nbClusters);
-  
+
   if(x&gt;=_nbClusters)
   {
-    printf(&quot;Exceeding max cluster : asked: %u max :%u\n&quot;,x,_nbClusters); 
+    printf(&quot;Exceeding max cluster : asked: %u max :%u\n&quot;,x,_nbClusters);
     return 0;  // FIXME
   }
-  
+
   if( _clusterParser) delete _clusterParser;
   _clusterParser=NULL;
-  
+
   //************/
   _parser-&gt;seek(_clusters[x].pos);
   _clusterParser=new ADM_ebml_file(_parser,_clusters[x].size);
   _currentLace=_maxLace=0;
+
   printf(&quot;switching to cluster :%u/%u\n&quot;,x,_nbClusters);
   return 1;
 }
@@ -360,16 +378,16 @@
               if(target&gt;=_clusters[i].timeCode &amp;&amp; target&lt;_clusters[i+1].timeCode)
               {
                 clus=i;
-                i=_nbClusters; 
+                i=_nbClusters;
               }
             }
             if(clus==-1) clus=_nbClusters-1; // Hopefully in the last one
-            
+
             target-=_clusters[clus].timeCode; // now the time is relative
             goToCluster(clus);
             _currentCluster=clus;
             _curTimeCode=_clusters[clus].timeCode;
-            
+
             printf(&quot;[MKVAUDIO] Asked for %u ms, go to cluster %u which starts at %u\n&quot;,mstime,clus,_curTimeCode);
             if(clus&lt;_nbClusters-1)
               printf(&quot;[MKVAUDIO] next cluster starts at %u\n&quot;,_clusters[clus+1].timeCode);
@@ -383,9 +401,9 @@
             {
               uint32_t curTime=_clusters[_currentCluster].timeCode;
               vprintf(&quot;Wanted: %u clus : %u Timecode:%u=&gt; %u\n&quot;,mstime,curTime,timecode,timecode+curTime);
-              ADM_assert(len&lt;MAX_SEEK_BUFFER); 
-              
-              if(timecode+curTime&gt;=mstime) 
+              ADM_assert(len&lt;MAX_SEEK_BUFFER);
+
+              if(timecode+curTime&gt;=mstime)
               {
                 printf(&quot;[MKV audio] fine seek to %u (clu)+%u=%u\n&quot;,curTime,timecode,timecode+curTime);
                 return 1;

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_utilities/fourcc.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_utilities/fourcc.cpp	2008-06-07 20:32:22 UTC (rev 4088)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_utilities/fourcc.cpp	2008-06-08 07:16:45 UTC (rev 4089)
@@ -82,7 +82,7 @@
 #if defined( ADM_BIG_ENDIAN)
     if (*inb == (uint32_t) mmioFOURCC(*(cc+3), *(cc + 2), *(cc + 1), *(cc + 0)))
 #else
-    if (*inb == (uint32_t) mmioFOURCC(*cc, *(cc + 1), *(cc + 2), *(cc + 3)))	
+    if (*inb == (uint32_t) mmioFOURCC(*cc, *(cc + 1), *(cc + 2), *(cc + 3)))
 #endif
       {
 	  return 1;
@@ -102,7 +102,7 @@
     return inb;
 }
 
-int fourCC::check(uint8_t * cc, uint32_t in)
+int fourCC::check(const uint8_t * cc, uint32_t in)
 {
 
     if (in == (uint32_t) mmioFOURCC(*cc, *(cc + 1), *(cc + 2), *(cc + 3)))
@@ -113,7 +113,7 @@
     return 0;
 }
 
-int fourCC::check(uint32_t in, uint8_t * cc)
+int fourCC::check(uint32_t in, const uint8_t * cc)
 {
     return check(cc, in);
 

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_utilities/fourcc.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_utilities/fourcc.h	2008-06-07 20:32:22 UTC (rev 4088)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_utilities/fourcc.h	2008-06-08 07:16:45 UTC (rev 4089)
@@ -20,14 +20,14 @@
 class fourCC
 {
 public:
-  static int  			check(uint8_t *,uint8_t *);
+    static int  		    check(uint8_t *,uint8_t *);
 	static void 			print(uint32_t four);
 	static void 			printBE(uint32_t four);
-	static int  			check(uint32_t in,uint8_t *cc);
-	static int  			check(uint8_t *cc,uint32_t in);
-	static  uint32_t 	get(uint8_t *in)   ;
-	static char 		  *tostring(uint32_t fourcc);
-        static char               *tostringBE(uint32_t fourcc);
+	static int  			check(uint32_t in,const uint8_t *cc);
+	static int  			check(const uint8_t *cc,uint32_t in);
+	static  uint32_t 	    get(uint8_t *in)   ;
+	static char 		    *tostring(uint32_t fourcc);
+    static char            *tostringBE(uint32_t fourcc);
 
 };
 void mixDump(uint8_t *ptr, uint32_t len);

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/ADM_lavformat.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/ADM_lavformat.cpp	2008-06-07 20:32:22 UTC (rev 4088)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/ADM_lavformat.cpp	2008-06-08 07:16:45 UTC (rev 4089)
@@ -62,6 +62,9 @@
 
 static uint8_t ADM_4cc_to_lavcodec(const char *fcc, CodecID *outlavid);
 static uint8_t ADM_WaveTag_to_lavcodec(uint32_t tag, CodecID *outlavid);
+
+extern uint8_t isVP6Compatible (uint32_t fourcc);
+
 // convert in in us to out in 90Khz tick
 int64_t adm_90k( double in)
 {
@@ -174,14 +177,14 @@
 					 	 c-&gt;codec-&gt;name=ADM_strdup(&quot;FLV1&quot;);
 					 }else
 					 {
-						 if(fourCC::check(info-&gt;fcc,(uint8_t *)&quot;VP6F&quot;))
+					         if(isVP6Compatible(info-&gt;fcc))
 						 			{
 							 		 c-&gt;codec_id=CODEC_ID_VP6F;
 					 				 c-&gt;codec-&gt;name=ADM_strdup(&quot;VP6F&quot;);
 						 			}
 						 else
 							 ADM_assert(0);
-					 
+ 
 					 }
 					 
 					 break;

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_flv/oplug_flv.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_flv/oplug_flv.cpp	2008-06-07 20:32:22 UTC (rev 4088)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_flv/oplug_flv.cpp	2008-06-08 07:16:45 UTC (rev 4089)
@@ -65,6 +65,7 @@
 extern AVDMGenericAudioStream 	*currentaudiostream;;
 
 static 				uint8_t *_buffer=NULL,*_outbuffer=NULL;
+extern uint8_t isVP6Compatible (uint32_t fourcc);
 
 /*
  * 		\fn    Oplug_flv
@@ -129,15 +130,10 @@
 
            info.fcc=*(uint32_t *)_encode-&gt;getCodecName(); //FIXME
            //
-           const char *supportedVideo[3]={&quot;FLV1&quot;,&quot;VP6F&quot;,&quot;VP6 &quot;};
            int supported=0;
-           for(int i=0;i&lt;3;i++)
-           {
-        	   if(fourCC::check(info.fcc,(uint8_t *)supportedVideo[i]))
-        	   {
-        		   	supported=1;
-        	   }
-           }
+           if(isVP6Compatible(info.fcc)) supported=1;
+           if(fourCC::check(info.fcc,(const uint8_t *)&quot;FLV1&quot;)) supported=1;
+
            if(!supported)
            {
         	   GUI_Error_HIG(QT_TR_NOOP(&quot;Unsupported video&quot;),QT_TR_NOOP(&quot;Only FLV1 and VP6 video are supported&quot;));

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/CMakeLists.txt	2008-06-07 20:32:22 UTC (rev 4088)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/CMakeLists.txt	2008-06-08 07:16:45 UTC (rev 4089)
@@ -8,8 +8,7 @@
 
         ADD_LIBRARY(ADM_vf_ssa SHARED ${ADM_vf_ssa_SRCS})
         TARGET_LINK_LIBRARIES(ADM_vf_ssa ADM_libass)
-        ADD_TARGET_LDFLAGS(ADM_vf_ssa  &quot;${FONTCONFIG_LDFLAGS}&quot;)
-        ADD_TARGET_LDFLAGS(ADM_vf_ssa  &quot;${FREETYPE2_LDFLAGS}&quot;)
+        ADD_TARGET_LDFLAGS(ADM_vf_ssa  &quot;${FONTCONFIG_LDFLAGS} ${FREETYPE2_LDFLAGS}&quot;)
         INIT_VIDEOFILTER_PLUGIN(ADM_vf_ssa)
         INSTALL_VIDEOFILTER(ADM_vf_ssa)
 ENDIF(USE_FREETYPE)


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001344.html">[Avidemux-svn-commit] r4088 -	branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_matroska
</A></li>
	<LI>Next message: <A HREF="001346.html">[Avidemux-svn-commit] r4090 -	branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1345">[ date ]</a>
              <a href="thread.html#1345">[ thread ]</a>
              <a href="subject.html#1345">[ subject ]</a>
              <a href="author.html#1345">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
