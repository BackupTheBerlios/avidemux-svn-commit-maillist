<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r6483 - in	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg:	libavcodec libavcodec/x86 patches patches/avcodec
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2010-July/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r6483%20-%20in%0A%09branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg%3A%0A%09libavcodec%20libavcodec/x86%20patches%20patches/avcodec&In-Reply-To=%3C20100725100753.10E51480E6C%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003669.html">
   <LINK REL="Next"  HREF="003671.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r6483 - in	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg:	libavcodec libavcodec/x86 patches patches/avcodec</H1>
    <B>mean at mail.berlios.de</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r6483%20-%20in%0A%09branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg%3A%0A%09libavcodec%20libavcodec/x86%20patches%20patches/avcodec&In-Reply-To=%3C20100725100753.10E51480E6C%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r6483 - in	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg:	libavcodec libavcodec/x86 patches patches/avcodec">mean at mail.berlios.de
       </A><BR>
    <I>Sun Jul 25 12:07:52 CEST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="003669.html">[Avidemux-svn-commit] r6482 - in	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale:	. x86
</A></li>
        <LI>Next message: <A HREF="003671.html">[Avidemux-svn-commit] r6484 -	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3670">[ date ]</a>
              <a href="thread.html#3670">[ thread ]</a>
              <a href="subject.html#3670">[ subject ]</a>
              <a href="author.html#3670">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2010-07-25 12:07:52 +0200 (Sun, 25 Jul 2010)
New Revision: 6483

Added:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aacps.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aacps.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aacps_tablegen.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aacps_tablegen.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aacpsdata.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/ansi.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/gsmdec.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/inverse.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/pictordec.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/ra144dec.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/ra144enc.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/avcodec.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/avcodec.h.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/fft.c.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/h263dec.c.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/h264dsp.c.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/mpeg12.c.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/mpeg12enc.c.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/mpegvideo.c.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/mpegvideo_enc.c.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/png.c.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/pngdec.c.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/pngenc.c.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/utils.c.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/x86_mathops.h.patch
Removed:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aac.c
Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/avcodec.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/fft.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/ffv1.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/h263dec.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/h264dsp.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/mpeg12.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/mpeg12enc.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/mpegvideo.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/mpegvideo_enc.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/png.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/pngdec.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/pngenc.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/utils.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/x86/mathops.h
Log:
[ffmpeg] update 25 july avcodec

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/CMakeLists.txt	2010-07-25 10:07:49 UTC (rev 6482)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/CMakeLists.txt	2010-07-25 10:07:52 UTC (rev 6483)
@@ -26,7 +26,7 @@
         dca.c
         ac3enc.c  ac3.c  ac3tab.c   ac3_parser.c
         eac3dec.c ac3dec.c ac3dec_data.c eac3dec_data.c
-        aacenc.c aaccoder.c aac.c aactab.c psymodel.c aacpsy.c iirfilter.c
+        aacenc.c aaccoder.c  aactab.c psymodel.c aacpsy.c iirfilter.c
 	dvbsub_parser.c  dvbsubdec.c  dvbsub.c  xiph.c  sp5xdec.c  
         nellymoserdec.c nellymoser.c
 	ADM_lavcodec.cpp  pthread.c  huffman.c  wmv2dec.c  wmv2.c  h264pred.c  intrax8.c
@@ -37,6 +37,7 @@
         ivi_common.c dcadsp.c h264_direct.c ivi_dsp.c ituh263dec.c dvdata.c ituh263enc.c aacsbr.c
         synth_filter.c    mpeg4videodec.c h264_cabac.c h264_cavlc.c vp56dsp.c h264_loopfilter.c
         h264_sei.c h264_ps.c svq3.c h264dsp.c flvdec.c
+        aacps.c  aacpsy.c aacadtsdec.c lpc.c vp8_parser.c vp8.c vp8dsp.c inverse.c dct.c aacdec.c
         )
 
 if(USE_VDPAU)
@@ -51,12 +52,20 @@
                 x86/idct_sse2_xvid.c 
                 x86/vp6dsp_mmx.c
                 x86/vp6dsp_sse2.c
+                x86/vp8dsp-init.c
+                x86/mpegaudiodec_mmx.c
+                x86/lpc_mmx.c
+                x86/fft.c
+                x86/dct32_sse.c
                 #x86/fft_sse.c
                 #x86/fft_3dn2.c
 		#x86/fft_3dn.c  
                 x86/dsputilenc_mmx.c  x86/vc1dsp_mmx.c  x86/idct_mmx.c)
         IF(USE_YASM)
-                SET(YASM_SOURCE
+                SET(YASM_SOURCE         
+                                x86/h264_intrapred.asm
+                                x86/vp8dsp.asm
+                                x86/vc1dsp_yasm.asm
                                 x86/dsputil_yasm.asm
                                 x86/fft_mmx.asm
                                 x86/h264_deblock_sse2.asm

Deleted: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aac.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aac.c	2010-07-25 10:07:49 UTC (rev 6482)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aac.c	2010-07-25 10:07:52 UTC (rev 6483)
@@ -1,2108 +0,0 @@
-/*
- * AAC decoder
- * Copyright (c) 2005-2006 Oded Shimon ( ods15 ods15 dyndns org )
- * Copyright (c) 2006-2007 Maxim Gavrilov ( maxim.gavrilov gmail com )
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-/**
- * @file
- * AAC decoder
- * @author Oded Shimon  ( ods15 ods15 dyndns org )
- * @author Maxim Gavrilov ( maxim.gavrilov gmail com )
- */
-
-/*
- * supported tools
- *
- * Support?             Name
- * N (code in SoC repo) gain control
- * Y                    block switching
- * Y                    window shapes - standard
- * N                    window shapes - Low Delay
- * Y                    filterbank - standard
- * N (code in SoC repo) filterbank - Scalable Sample Rate
- * Y                    Temporal Noise Shaping
- * N (code in SoC repo) Long Term Prediction
- * Y                    intensity stereo
- * Y                    channel coupling
- * Y                    frequency domain prediction
- * Y                    Perceptual Noise Substitution
- * Y                    Mid/Side stereo
- * N                    Scalable Inverse AAC Quantization
- * N                    Frequency Selective Switch
- * N                    upsampling filter
- * Y                    quantization &amp; coding - AAC
- * N                    quantization &amp; coding - TwinVQ
- * N                    quantization &amp; coding - BSAC
- * N                    AAC Error Resilience tools
- * N                    Error Resilience payload syntax
- * N                    Error Protection tool
- * N                    CELP
- * N                    Silence Compression
- * N                    HVXC
- * N                    HVXC 4kbits/s VR
- * N                    Structured Audio tools
- * N                    Structured Audio Sample Bank Format
- * N                    MIDI
- * N                    Harmonic and Individual Lines plus Noise
- * N                    Text-To-Speech Interface
- * Y                    Spectral Band Replication
- * Y (not in this code) Layer-1
- * Y (not in this code) Layer-2
- * Y (not in this code) Layer-3
- * N                    SinuSoidal Coding (Transient, Sinusoid, Noise)
- * N (planned)          Parametric Stereo
- * N                    Direct Stream Transfer
- *
- * Note: - HE AAC v1 comprises LC AAC with Spectral Band Replication.
- *       - HE AAC v2 comprises LC AAC with Spectral Band Replication and
-           Parametric Stereo.
- */
-
-
-#include &quot;avcodec.h&quot;
-#include &quot;internal.h&quot;
-#include &quot;get_bits.h&quot;
-#include &quot;dsputil.h&quot;
-#include &quot;fft.h&quot;
-#include &quot;lpc.h&quot;
-
-#include &quot;aac.h&quot;
-#include &quot;aactab.h&quot;
-#include &quot;aacdectab.h&quot;
-#include &quot;cbrt_tablegen.h&quot;
-#include &quot;sbr.h&quot;
-#include &quot;aacsbr.h&quot;
-#include &quot;mpeg4audio.h&quot;
-#include &quot;aac_parser.h&quot;
-
-#include &lt;assert.h&gt;
-#include &lt;errno.h&gt;
-#include &lt;math.h&gt;
-#include &lt;string.h&gt;
-
-#if ARCH_ARM
-#   include &quot;arm/aac.h&quot;
-#endif
-
-union float754 {
-    float f;
-    uint32_t i;
-};
-
-static VLC vlc_scalefactors;
-static VLC vlc_spectral[11];
-
-static const char overread_err[] = &quot;Input buffer exhausted before END element found\n&quot;;
-
-static ChannelElement *get_che(AACContext *ac, int type, int elem_id)
-{
-    if (ac-&gt;tag_che_map[type][elem_id]) {
-        return ac-&gt;tag_che_map[type][elem_id];
-    }
-    if (ac-&gt;tags_mapped &gt;= tags_per_config[ac-&gt;m4ac.chan_config]) {
-        return NULL;
-    }
-    switch (ac-&gt;m4ac.chan_config) {
-    case 7:
-        if (ac-&gt;tags_mapped == 3 &amp;&amp; type == TYPE_CPE) {
-            ac-&gt;tags_mapped++;
-            return ac-&gt;tag_che_map[TYPE_CPE][elem_id] = ac-&gt;che[TYPE_CPE][2];
-        }
-    case 6:
-        /* Some streams incorrectly code 5.1 audio as SCE[0] CPE[0] CPE[1] SCE[1]
-           instead of SCE[0] CPE[0] CPE[0] LFE[0]. If we seem to have
-           encountered such a stream, transfer the LFE[0] element to SCE[1] */
-        if (ac-&gt;tags_mapped == tags_per_config[ac-&gt;m4ac.chan_config] - 1 &amp;&amp; (type == TYPE_LFE || type == TYPE_SCE)) {
-            ac-&gt;tags_mapped++;
-            return ac-&gt;tag_che_map[type][elem_id] = ac-&gt;che[TYPE_LFE][0];
-        }
-    case 5:
-        if (ac-&gt;tags_mapped == 2 &amp;&amp; type == TYPE_CPE) {
-            ac-&gt;tags_mapped++;
-            return ac-&gt;tag_che_map[TYPE_CPE][elem_id] = ac-&gt;che[TYPE_CPE][1];
-        }
-    case 4:
-        if (ac-&gt;tags_mapped == 2 &amp;&amp; ac-&gt;m4ac.chan_config == 4 &amp;&amp; type == TYPE_SCE) {
-            ac-&gt;tags_mapped++;
-            return ac-&gt;tag_che_map[TYPE_SCE][elem_id] = ac-&gt;che[TYPE_SCE][1];
-        }
-    case 3:
-    case 2:
-        if (ac-&gt;tags_mapped == (ac-&gt;m4ac.chan_config != 2) &amp;&amp; type == TYPE_CPE) {
-            ac-&gt;tags_mapped++;
-            return ac-&gt;tag_che_map[TYPE_CPE][elem_id] = ac-&gt;che[TYPE_CPE][0];
-        } else if (ac-&gt;m4ac.chan_config == 2) {
-            return NULL;
-        }
-    case 1:
-        if (!ac-&gt;tags_mapped &amp;&amp; type == TYPE_SCE) {
-            ac-&gt;tags_mapped++;
-            return ac-&gt;tag_che_map[TYPE_SCE][elem_id] = ac-&gt;che[TYPE_SCE][0];
-        }
-    default:
-        return NULL;
-    }
-}
-
-/**
- * Check for the channel element in the current channel position configuration.
- * If it exists, make sure the appropriate element is allocated and map the
- * channel order to match the internal FFmpeg channel layout.
- *
- * @param   che_pos current channel position configuration
- * @param   type channel element type
- * @param   id channel element id
- * @param   channels count of the number of channels in the configuration
- *
- * @return  Returns error status. 0 - OK, !0 - error
- */
-static av_cold int che_configure(AACContext *ac,
-                         enum ChannelPosition che_pos[4][MAX_ELEM_ID],
-                         int type, int id,
-                         int *channels)
-{
-    if (che_pos[type][id]) {
-        if (!ac-&gt;che[type][id] &amp;&amp; !(ac-&gt;che[type][id] = av_mallocz(sizeof(ChannelElement))))
-            return AVERROR(ENOMEM);
-        ff_aac_sbr_ctx_init(&amp;ac-&gt;che[type][id]-&gt;sbr);
-        if (type != TYPE_CCE) {
-            ac-&gt;output_data[(*channels)++] = ac-&gt;che[type][id]-&gt;ch[0].ret;
-            if (type == TYPE_CPE) {
-                ac-&gt;output_data[(*channels)++] = ac-&gt;che[type][id]-&gt;ch[1].ret;
-            }
-        }
-    } else {
-        if (ac-&gt;che[type][id])
-            ff_aac_sbr_ctx_close(&amp;ac-&gt;che[type][id]-&gt;sbr);
-        av_freep(&amp;ac-&gt;che[type][id]);
-    }
-    return 0;
-}
-
-/**
- * Configure output channel order based on the current program configuration element.
- *
- * @param   che_pos current channel position configuration
- * @param   new_che_pos New channel position configuration - we only do something if it differs from the current one.
- *
- * @return  Returns error status. 0 - OK, !0 - error
- */
-static av_cold int output_configure(AACContext *ac,
-                            enum ChannelPosition che_pos[4][MAX_ELEM_ID],
-                            enum ChannelPosition new_che_pos[4][MAX_ELEM_ID],
-                            int channel_config, enum OCStatus oc_type)
-{
-    AVCodecContext *avctx = ac-&gt;avccontext;
-    int i, type, channels = 0, ret;
-
-    memcpy(che_pos, new_che_pos, 4 * MAX_ELEM_ID * sizeof(new_che_pos[0][0]));
-
-    if (channel_config) {
-        for (i = 0; i &lt; tags_per_config[channel_config]; i++) {
-            if ((ret = che_configure(ac, che_pos,
-                                     aac_channel_layout_map[channel_config - 1][i][0],
-                                     aac_channel_layout_map[channel_config - 1][i][1],
-                                     &amp;channels)))
-                return ret;
-        }
-
-        memset(ac-&gt;tag_che_map, 0,       4 * MAX_ELEM_ID * sizeof(ac-&gt;che[0][0]));
-        ac-&gt;tags_mapped = 0;
-
-        avctx-&gt;channel_layout = aac_channel_layout[channel_config - 1];
-    } else {
-        /* Allocate or free elements depending on if they are in the
-         * current program configuration.
-         *
-         * Set up default 1:1 output mapping.
-         *
-         * For a 5.1 stream the output order will be:
-         *    [ Center ] [ Front Left ] [ Front Right ] [ LFE ] [ Surround Left ] [ Surround Right ]
-         */
-
-        for (i = 0; i &lt; MAX_ELEM_ID; i++) {
-            for (type = 0; type &lt; 4; type++) {
-                if ((ret = che_configure(ac, che_pos, type, i, &amp;channels)))
-                    return ret;
-            }
-        }
-
-        memcpy(ac-&gt;tag_che_map, ac-&gt;che, 4 * MAX_ELEM_ID * sizeof(ac-&gt;che[0][0]));
-        ac-&gt;tags_mapped = 4 * MAX_ELEM_ID;
-
-        avctx-&gt;channel_layout = 0;
-    }
-
-    avctx-&gt;channels = channels;
-
-    ac-&gt;output_configured = oc_type;
-
-    return 0;
-}
-
-/**
- * Decode an array of 4 bit element IDs, optionally interleaved with a stereo/mono switching bit.
- *
- * @param cpe_map Stereo (Channel Pair Element) map, NULL if stereo bit is not present.
- * @param sce_map mono (Single Channel Element) map
- * @param type speaker type/position for these channels
- */
-static void decode_channel_map(enum ChannelPosition *cpe_map,
-                               enum ChannelPosition *sce_map,
-                               enum ChannelPosition type,
-                               GetBitContext *gb, int n)
-{
-    while (n--) {
-        enum ChannelPosition *map = cpe_map &amp;&amp; get_bits1(gb) ? cpe_map : sce_map; // stereo or mono map
-        map[get_bits(gb, 4)] = type;
-    }
-}
-
-/**
- * Decode program configuration element; reference: table 4.2.
- *
- * @param   new_che_pos New channel position configuration - we only do something if it differs from the current one.
- *
- * @return  Returns error status. 0 - OK, !0 - error
- */
-static int decode_pce(AACContext *ac, enum ChannelPosition new_che_pos[4][MAX_ELEM_ID],
-                      GetBitContext *gb)
-{
-    int num_front, num_side, num_back, num_lfe, num_assoc_data, num_cc, sampling_index;
-    int comment_len;
-
-    skip_bits(gb, 2);  // object_type
-
-    sampling_index = get_bits(gb, 4);
-    if (ac-&gt;m4ac.sampling_index != sampling_index)
-        av_log(ac-&gt;avccontext, AV_LOG_WARNING, &quot;Sample rate index in program config element does not match the sample rate index configured by the container.\n&quot;);
-
-    num_front       = get_bits(gb, 4);
-    num_side        = get_bits(gb, 4);
-    num_back        = get_bits(gb, 4);
-    num_lfe         = get_bits(gb, 2);
-    num_assoc_data  = get_bits(gb, 3);
-    num_cc          = get_bits(gb, 4);
-
-    if (get_bits1(gb))
-        skip_bits(gb, 4); // mono_mixdown_tag
-    if (get_bits1(gb))
-        skip_bits(gb, 4); // stereo_mixdown_tag
-
-    if (get_bits1(gb))
-        skip_bits(gb, 3); // mixdown_coeff_index and pseudo_surround
-
-    decode_channel_map(new_che_pos[TYPE_CPE], new_che_pos[TYPE_SCE], AAC_CHANNEL_FRONT, gb, num_front);
-    decode_channel_map(new_che_pos[TYPE_CPE], new_che_pos[TYPE_SCE], AAC_CHANNEL_SIDE,  gb, num_side );
-    decode_channel_map(new_che_pos[TYPE_CPE], new_che_pos[TYPE_SCE], AAC_CHANNEL_BACK,  gb, num_back );
-    decode_channel_map(NULL,                  new_che_pos[TYPE_LFE], AAC_CHANNEL_LFE,   gb, num_lfe  );
-
-    skip_bits_long(gb, 4 * num_assoc_data);
-
-    decode_channel_map(new_che_pos[TYPE_CCE], new_che_pos[TYPE_CCE], AAC_CHANNEL_CC,    gb, num_cc   );
-
-    align_get_bits(gb);
-
-    /* comment field, first byte is length */
-    comment_len = get_bits(gb, 8) * 8;
-    if (get_bits_left(gb) &lt; comment_len) {
-        av_log(ac-&gt;avccontext, AV_LOG_ERROR, overread_err);
-        return -1;
-    }
-    skip_bits_long(gb, comment_len);
-    return 0;
-}
-
-/**
- * Set up channel positions based on a default channel configuration
- * as specified in table 1.17.
- *
- * @param   new_che_pos New channel position configuration - we only do something if it differs from the current one.
- *
- * @return  Returns error status. 0 - OK, !0 - error
- */
-static av_cold int set_default_channel_config(AACContext *ac,
-                                      enum ChannelPosition new_che_pos[4][MAX_ELEM_ID],
-                                      int channel_config)
-{
-    if (channel_config &lt; 1 || channel_config &gt; 7) {
-        av_log(ac-&gt;avccontext, AV_LOG_ERROR, &quot;invalid default channel configuration (%d)\n&quot;,
-               channel_config);
-        return -1;
-    }
-
-    /* default channel configurations:
-     *
-     * 1ch : front center (mono)
-     * 2ch : L + R (stereo)
-     * 3ch : front center + L + R
-     * 4ch : front center + L + R + back center
-     * 5ch : front center + L + R + back stereo
-     * 6ch : front center + L + R + back stereo + LFE
-     * 7ch : front center + L + R + outer front left + outer front right + back stereo + LFE
-     */
-
-    if (channel_config != 2)
-        new_che_pos[TYPE_SCE][0] = AAC_CHANNEL_FRONT; // front center (or mono)
-    if (channel_config &gt; 1)
-        new_che_pos[TYPE_CPE][0] = AAC_CHANNEL_FRONT; // L + R (or stereo)
-    if (channel_config == 4)
-        new_che_pos[TYPE_SCE][1] = AAC_CHANNEL_BACK;  // back center
-    if (channel_config &gt; 4)
-        new_che_pos[TYPE_CPE][(channel_config == 7) + 1]
-        = AAC_CHANNEL_BACK;  // back stereo
-    if (channel_config &gt; 5)
-        new_che_pos[TYPE_LFE][0] = AAC_CHANNEL_LFE;   // LFE
-    if (channel_config == 7)
-        new_che_pos[TYPE_CPE][1] = AAC_CHANNEL_FRONT; // outer front left + outer front right
-
-    return 0;
-}
-
-/**
- * Decode GA &quot;General Audio&quot; specific configuration; reference: table 4.1.
- *
- * @return  Returns error status. 0 - OK, !0 - error
- */
-static int decode_ga_specific_config(AACContext *ac, GetBitContext *gb,
-                                     int channel_config)
-{
-    enum ChannelPosition new_che_pos[4][MAX_ELEM_ID];
-    int extension_flag, ret;
-
-    if (get_bits1(gb)) { // frameLengthFlag
-        av_log_missing_feature(ac-&gt;avccontext, &quot;960/120 MDCT window is&quot;, 1);
-        return -1;
-    }
-
-    if (get_bits1(gb))       // dependsOnCoreCoder
-        skip_bits(gb, 14);   // coreCoderDelay
-    extension_flag = get_bits1(gb);
-
-    if (ac-&gt;m4ac.object_type == AOT_AAC_SCALABLE ||
-        ac-&gt;m4ac.object_type == AOT_ER_AAC_SCALABLE)
-        skip_bits(gb, 3);     // layerNr
-
-    memset(new_che_pos, 0, 4 * MAX_ELEM_ID * sizeof(new_che_pos[0][0]));
-    if (channel_config == 0) {
-        skip_bits(gb, 4);  // element_instance_tag
-        if ((ret = decode_pce(ac, new_che_pos, gb)))
-            return ret;
-    } else {
-        if ((ret = set_default_channel_config(ac, new_che_pos, channel_config)))
-            return ret;
-    }
-    if ((ret = output_configure(ac, ac-&gt;che_pos, new_che_pos, channel_config, OC_GLOBAL_HDR)))
-        return ret;
-
-    if (extension_flag) {
-        switch (ac-&gt;m4ac.object_type) {
-        case AOT_ER_BSAC:
-            skip_bits(gb, 5);    // numOfSubFrame
-            skip_bits(gb, 11);   // layer_length
-            break;
-        case AOT_ER_AAC_LC:
-        case AOT_ER_AAC_LTP:
-        case AOT_ER_AAC_SCALABLE:
-        case AOT_ER_AAC_LD:
-            skip_bits(gb, 3);  /* aacSectionDataResilienceFlag
-                                    * aacScalefactorDataResilienceFlag
-                                    * aacSpectralDataResilienceFlag
-                                    */
-            break;
-        }
-        skip_bits1(gb);    // extensionFlag3 (TBD in version 3)
-    }
-    return 0;
-}
-
-/**
- * Decode audio specific configuration; reference: table 1.13.
- *
- * @param   data        pointer to AVCodecContext extradata
- * @param   data_size   size of AVCCodecContext extradata
- *
- * @return  Returns error status. 0 - OK, !0 - error
- */
-static int decode_audio_specific_config(AACContext *ac, void *data,
-                                        int data_size)
-{
-    GetBitContext gb;
-    int i;
-
-    init_get_bits(&amp;gb, data, data_size * 8);
-
-    if ((i = ff_mpeg4audio_get_config(&amp;ac-&gt;m4ac, data, data_size)) &lt; 0)
-        return -1;
-    if (ac-&gt;m4ac.sampling_index &gt; 12) {
-        av_log(ac-&gt;avccontext, AV_LOG_ERROR, &quot;invalid sampling rate index %d\n&quot;, ac-&gt;m4ac.sampling_index);
-        return -1;
-    }
-
-    skip_bits_long(&amp;gb, i);
-
-    switch (ac-&gt;m4ac.object_type) {
-    case AOT_AAC_MAIN:
-    case AOT_AAC_LC:
-        if (decode_ga_specific_config(ac, &amp;gb, ac-&gt;m4ac.chan_config))
-            return -1;
-        break;
-    default:
-        av_log(ac-&gt;avccontext, AV_LOG_ERROR, &quot;Audio object type %s%d is not supported.\n&quot;,
-               ac-&gt;m4ac.sbr == 1? &quot;SBR+&quot; : &quot;&quot;, ac-&gt;m4ac.object_type);
-        return -1;
-    }
-    return 0;
-}
-
-/**
- * linear congruential pseudorandom number generator
- *
- * @param   previous_val    pointer to the current state of the generator
- *
- * @return  Returns a 32-bit pseudorandom integer
- */
-static av_always_inline int lcg_random(int previous_val)
-{
-    return previous_val * 1664525 + 1013904223;
-}
-
-static av_always_inline void reset_predict_state(PredictorState *ps)
-{
-    ps-&gt;r0   = 0.0f;
-    ps-&gt;r1   = 0.0f;
-    ps-&gt;cor0 = 0.0f;
-    ps-&gt;cor1 = 0.0f;
-    ps-&gt;var0 = 1.0f;
-    ps-&gt;var1 = 1.0f;
-}
-
-static void reset_all_predictors(PredictorState *ps)
-{
-    int i;
-    for (i = 0; i &lt; MAX_PREDICTORS; i++)
-        reset_predict_state(&amp;ps[i]);
-}
-
-static void reset_predictor_group(PredictorState *ps, int group_num)
-{
-    int i;
-    for (i = group_num - 1; i &lt; MAX_PREDICTORS; i += 30)
-        reset_predict_state(&amp;ps[i]);
-}
-
-static av_cold int aac_decode_init(AVCodecContext *avccontext)
-{
-    AACContext *ac = avccontext-&gt;priv_data;
-    int i;
-
-    ac-&gt;avccontext = avccontext;
-    ac-&gt;m4ac.sample_rate = avccontext-&gt;sample_rate;
-
-    if (avccontext-&gt;extradata_size &gt; 0) {
-        if (decode_audio_specific_config(ac, avccontext-&gt;extradata, avccontext-&gt;extradata_size))
-            return -1;
-    }
-
-    avccontext-&gt;sample_fmt = SAMPLE_FMT_S16;
-
-    AAC_INIT_VLC_STATIC( 0, 304);
-    AAC_INIT_VLC_STATIC( 1, 270);
-    AAC_INIT_VLC_STATIC( 2, 550);
-    AAC_INIT_VLC_STATIC( 3, 300);
-    AAC_INIT_VLC_STATIC( 4, 328);
-    AAC_INIT_VLC_STATIC( 5, 294);
-    AAC_INIT_VLC_STATIC( 6, 306);
-    AAC_INIT_VLC_STATIC( 7, 268);
-    AAC_INIT_VLC_STATIC( 8, 510);
-    AAC_INIT_VLC_STATIC( 9, 366);
-    AAC_INIT_VLC_STATIC(10, 462);
-
-    ff_aac_sbr_init();
-
-    dsputil_init(&amp;ac-&gt;dsp, avccontext);
-
-    ac-&gt;random_state = 0x1f2e3d4c;
-
-    // -1024 - Compensate wrong IMDCT method.
-    // 32768 - Required to scale values to the correct range for the bias method
-    //         for float to int16 conversion.
-
-    if (ac-&gt;dsp.float_to_int16_interleave == ff_float_to_int16_interleave_c) {
-        ac-&gt;add_bias  = 385.0f;
-        ac-&gt;sf_scale  = 1. / (-1024. * 32768.);
-        ac-&gt;sf_offset = 0;
-    } else {
-        ac-&gt;add_bias  = 0.0f;
-        ac-&gt;sf_scale  = 1. / -1024.;
-        ac-&gt;sf_offset = 60;
-    }
-
-#if !CONFIG_HARDCODED_TABLES
-    for (i = 0; i &lt; 428; i++)
-        ff_aac_pow2sf_tab[i] = pow(2, (i - 200) / 4.);
-#endif /* CONFIG_HARDCODED_TABLES */
-
-    INIT_VLC_STATIC(&amp;vlc_scalefactors,7,FF_ARRAY_ELEMS(ff_aac_scalefactor_code),
-                    ff_aac_scalefactor_bits, sizeof(ff_aac_scalefactor_bits[0]), sizeof(ff_aac_scalefactor_bits[0]),
-                    ff_aac_scalefactor_code, sizeof(ff_aac_scalefactor_code[0]), sizeof(ff_aac_scalefactor_code[0]),
-                    352);
-
-    ff_mdct_init(&amp;ac-&gt;mdct, 11, 1, 1.0);
-    ff_mdct_init(&amp;ac-&gt;mdct_small, 8, 1, 1.0);
-    // window initialization
-    ff_kbd_window_init(ff_aac_kbd_long_1024, 4.0, 1024);
-    ff_kbd_window_init(ff_aac_kbd_short_128, 6.0, 128);
-    ff_init_ff_sine_windows(10);
-    ff_init_ff_sine_windows( 7);
-
-    cbrt_tableinit();
-
-    return 0;
-}
-
-/**
- * Skip data_stream_element; reference: table 4.10.
- */
-static int skip_data_stream_element(AACContext *ac, GetBitContext *gb)
-{
-    int byte_align = get_bits1(gb);
-    int count = get_bits(gb, 8);
-    if (count == 255)
-        count += get_bits(gb, 8);
-    if (byte_align)
-        align_get_bits(gb);
-
-    if (get_bits_left(gb) &lt; 8 * count) {
-        av_log(ac-&gt;avccontext, AV_LOG_ERROR, overread_err);
-        return -1;
-    }
-    skip_bits_long(gb, 8 * count);
-    return 0;
-}
-
-static int decode_prediction(AACContext *ac, IndividualChannelStream *ics,
-                             GetBitContext *gb)
-{
-    int sfb;
-    if (get_bits1(gb)) {
-        ics-&gt;predictor_reset_group = get_bits(gb, 5);
-        if (ics-&gt;predictor_reset_group == 0 || ics-&gt;predictor_reset_group &gt; 30) {
-            av_log(ac-&gt;avccontext, AV_LOG_ERROR, &quot;Invalid Predictor Reset Group.\n&quot;);
-            return -1;
-        }
-    }
-    for (sfb = 0; sfb &lt; FFMIN(ics-&gt;max_sfb, ff_aac_pred_sfb_max[ac-&gt;m4ac.sampling_index]); sfb++) {
-        ics-&gt;prediction_used[sfb] = get_bits1(gb);
-    }
-    return 0;
-}
-
-/**
- * Decode Individual Channel Stream info; reference: table 4.6.
- *
- * @param   common_window   Channels have independent [0], or shared [1], Individual Channel Stream information.
- */
-static int decode_ics_info(AACContext *ac, IndividualChannelStream *ics,
-                           GetBitContext *gb, int common_window)
-{
-    if (get_bits1(gb)) {
-        av_log(ac-&gt;avccontext, AV_LOG_ERROR, &quot;Reserved bit set.\n&quot;);
-        memset(ics, 0, sizeof(IndividualChannelStream));
-        return -1;
-    }
-    ics-&gt;window_sequence[1] = ics-&gt;window_sequence[0];
-    ics-&gt;window_sequence[0] = get_bits(gb, 2);
-    ics-&gt;use_kb_window[1]   = ics-&gt;use_kb_window[0];
-    ics-&gt;use_kb_window[0]   = get_bits1(gb);
-    ics-&gt;num_window_groups  = 1;
-    ics-&gt;group_len[0]       = 1;
-    if (ics-&gt;window_sequence[0] == EIGHT_SHORT_SEQUENCE) {
-        int i;
-        ics-&gt;max_sfb = get_bits(gb, 4);
-        for (i = 0; i &lt; 7; i++) {
-            if (get_bits1(gb)) {
-                ics-&gt;group_len[ics-&gt;num_window_groups - 1]++;
-            } else {
-                ics-&gt;num_window_groups++;
-                ics-&gt;group_len[ics-&gt;num_window_groups - 1] = 1;
-            }
-        }
-        ics-&gt;num_windows       = 8;
-        ics-&gt;swb_offset        =    ff_swb_offset_128[ac-&gt;m4ac.sampling_index];
-        ics-&gt;num_swb           =   ff_aac_num_swb_128[ac-&gt;m4ac.sampling_index];
-        ics-&gt;tns_max_bands     = ff_tns_max_bands_128[ac-&gt;m4ac.sampling_index];
-        ics-&gt;predictor_present = 0;
-    } else {
-        ics-&gt;max_sfb               = get_bits(gb, 6);
-        ics-&gt;num_windows           = 1;
-        ics-&gt;swb_offset            =    ff_swb_offset_1024[ac-&gt;m4ac.sampling_index];
-        ics-&gt;num_swb               =   ff_aac_num_swb_1024[ac-&gt;m4ac.sampling_index];
-        ics-&gt;tns_max_bands         = ff_tns_max_bands_1024[ac-&gt;m4ac.sampling_index];
-        ics-&gt;predictor_present     = get_bits1(gb);
-        ics-&gt;predictor_reset_group = 0;
-        if (ics-&gt;predictor_present) {
-            if (ac-&gt;m4ac.object_type == AOT_AAC_MAIN) {
-                if (decode_prediction(ac, ics, gb)) {
-                    memset(ics, 0, sizeof(IndividualChannelStream));
-                    return -1;
-                }
-            } else if (ac-&gt;m4ac.object_type == AOT_AAC_LC) {
-                av_log(ac-&gt;avccontext, AV_LOG_ERROR, &quot;Prediction is not allowed in AAC-LC.\n&quot;);
-                memset(ics, 0, sizeof(IndividualChannelStream));
-                return -1;
-            } else {
-                av_log_missing_feature(ac-&gt;avccontext, &quot;Predictor bit set but LTP is&quot;, 1);
-                memset(ics, 0, sizeof(IndividualChannelStream));
-                return -1;
-            }
-        }
-    }
-
-    if (ics-&gt;max_sfb &gt; ics-&gt;num_swb) {
-        av_log(ac-&gt;avccontext, AV_LOG_ERROR,
-               &quot;Number of scalefactor bands in group (%d) exceeds limit (%d).\n&quot;,
-               ics-&gt;max_sfb, ics-&gt;num_swb);
-        memset(ics, 0, sizeof(IndividualChannelStream));
-        return -1;
-    }
-
-    return 0;
-}
-
-/**
- * Decode band types (section_data payload); reference: table 4.46.
- *
- * @param   band_type           array of the used band type
- * @param   band_type_run_end   array of the last scalefactor band of a band type run
- *
- * @return  Returns error status. 0 - OK, !0 - error
- */
-static int decode_band_types(AACContext *ac, enum BandType band_type[120],
-                             int band_type_run_end[120], GetBitContext *gb,
-                             IndividualChannelStream *ics)
-{
-    int g, idx = 0;
-    const int bits = (ics-&gt;window_sequence[0] == EIGHT_SHORT_SEQUENCE) ? 3 : 5;
-    for (g = 0; g &lt; ics-&gt;num_window_groups; g++) {
-        int k = 0;
-        while (k &lt; ics-&gt;max_sfb) {
-            uint8_t sect_end = k;
-            int sect_len_incr;
-            int sect_band_type = get_bits(gb, 4);
-            if (sect_band_type == 12) {
-                av_log(ac-&gt;avccontext, AV_LOG_ERROR, &quot;invalid band type\n&quot;);
-                return -1;
-            }
-            while ((sect_len_incr = get_bits(gb, bits)) == (1 &lt;&lt; bits) - 1)
-                sect_end += sect_len_incr;
-            sect_end += sect_len_incr;
-            if (get_bits_left(gb) &lt; 0) {
-                av_log(ac-&gt;avccontext, AV_LOG_ERROR, overread_err);
-                return -1;
-            }
-            if (sect_end &gt; ics-&gt;max_sfb) {
-                av_log(ac-&gt;avccontext, AV_LOG_ERROR,
-                       &quot;Number of bands (%d) exceeds limit (%d).\n&quot;,
-                       sect_end, ics-&gt;max_sfb);
-                return -1;
-            }
-            for (; k &lt; sect_end; k++) {
-                band_type        [idx]   = sect_band_type;
-                band_type_run_end[idx++] = sect_end;
-            }
-        }
-    }
-    return 0;
-}
-
-/**
- * Decode scalefactors; reference: table 4.47.
- *
- * @param   global_gain         first scalefactor value as scalefactors are differentially coded
- * @param   band_type           array of the used band type
- * @param   band_type_run_end   array of the last scalefactor band of a band type run
- * @param   sf                  array of scalefactors or intensity stereo positions
- *
- * @return  Returns error status. 0 - OK, !0 - error
- */
-static int decode_scalefactors(AACContext *ac, float sf[120], GetBitContext *gb,
-                               unsigned int global_gain,
-                               IndividualChannelStream *ics,
-                               enum BandType band_type[120],
-                               int band_type_run_end[120])
-{
-    const int sf_offset = ac-&gt;sf_offset + (ics-&gt;window_sequence[0] == EIGHT_SHORT_SEQUENCE ? 12 : 0);
-    int g, i, idx = 0;
-    int offset[3] = { global_gain, global_gain - 90, 100 };
-    int noise_flag = 1;
-    static const char *sf_str[3] = { &quot;Global gain&quot;, &quot;Noise gain&quot;, &quot;Intensity stereo position&quot; };
-    for (g = 0; g &lt; ics-&gt;num_window_groups; g++) {
-        for (i = 0; i &lt; ics-&gt;max_sfb;) {
-            int run_end = band_type_run_end[idx];
-            if (band_type[idx] == ZERO_BT) {
-                for (; i &lt; run_end; i++, idx++)
-                    sf[idx] = 0.;
-            } else if ((band_type[idx] == INTENSITY_BT) || (band_type[idx] == INTENSITY_BT2)) {
-                for (; i &lt; run_end; i++, idx++) {
-                    offset[2] += get_vlc2(gb, vlc_scalefactors.table, 7, 3) - 60;
-                    if (offset[2] &gt; 255U) {
-                        av_log(ac-&gt;avccontext, AV_LOG_ERROR,
-                               &quot;%s (%d) out of range.\n&quot;, sf_str[2], offset[2]);
-                        return -1;
-                    }
-                    sf[idx] = ff_aac_pow2sf_tab[-offset[2] + 300];
-                }
-            } else if (band_type[idx] == NOISE_BT) {
-                for (; i &lt; run_end; i++, idx++) {
-                    if (noise_flag-- &gt; 0)
-                        offset[1] += get_bits(gb, 9) - 256;
-                    else
-                        offset[1] += get_vlc2(gb, vlc_scalefactors.table, 7, 3) - 60;
-                    if (offset[1] &gt; 255U) {
-                        av_log(ac-&gt;avccontext, AV_LOG_ERROR,
-                               &quot;%s (%d) out of range.\n&quot;, sf_str[1], offset[1]);
-                        return -1;
-                    }
-                    sf[idx] = -ff_aac_pow2sf_tab[offset[1] + sf_offset + 100];
-                }
-            } else {
-                for (; i &lt; run_end; i++, idx++) {
-                    offset[0] += get_vlc2(gb, vlc_scalefactors.table, 7, 3) - 60;
-                    if (offset[0] &gt; 255U) {
-                        av_log(ac-&gt;avccontext, AV_LOG_ERROR,
-                               &quot;%s (%d) out of range.\n&quot;, sf_str[0], offset[0]);
-                        return -1;
-                    }
-                    sf[idx] = -ff_aac_pow2sf_tab[ offset[0] + sf_offset];
-                }
-            }
-        }
-    }
-    return 0;
-}
-
-/**
- * Decode pulse data; reference: table 4.7.
- */
-static int decode_pulses(Pulse *pulse, GetBitContext *gb,
-                         const uint16_t *swb_offset, int num_swb)
-{
-    int i, pulse_swb;
-    pulse-&gt;num_pulse = get_bits(gb, 2) + 1;
-    pulse_swb        = get_bits(gb, 6);
-    if (pulse_swb &gt;= num_swb)
-        return -1;
-    pulse-&gt;pos[0]    = swb_offset[pulse_swb];
-    pulse-&gt;pos[0]   += get_bits(gb, 5);
-    if (pulse-&gt;pos[0] &gt; 1023)
-        return -1;
-    pulse-&gt;amp[0]    = get_bits(gb, 4);
-    for (i = 1; i &lt; pulse-&gt;num_pulse; i++) {
-        pulse-&gt;pos[i] = get_bits(gb, 5) + pulse-&gt;pos[i - 1];
-        if (pulse-&gt;pos[i] &gt; 1023)
-            return -1;
-        pulse-&gt;amp[i] = get_bits(gb, 4);
-    }
-    return 0;
-}
-
-/**
- * Decode Temporal Noise Shaping data; reference: table 4.48.
- *
- * @return  Returns error status. 0 - OK, !0 - error
- */
-static int decode_tns(AACContext *ac, TemporalNoiseShaping *tns,
-                      GetBitContext *gb, const IndividualChannelStream *ics)
-{
-    int w, filt, i, coef_len, coef_res, coef_compress;
-    const int is8 = ics-&gt;window_sequence[0] == EIGHT_SHORT_SEQUENCE;
-    const int tns_max_order = is8 ? 7 : ac-&gt;m4ac.object_type == AOT_AAC_MAIN ? 20 : 12;
-    for (w = 0; w &lt; ics-&gt;num_windows; w++) {
-        if ((tns-&gt;n_filt[w] = get_bits(gb, 2 - is8))) {
-            coef_res = get_bits1(gb);
-
-            for (filt = 0; filt &lt; tns-&gt;n_filt[w]; filt++) {
-                int tmp2_idx;
-                tns-&gt;length[w][filt] = get_bits(gb, 6 - 2 * is8);
-
-                if ((tns-&gt;order[w][filt] = get_bits(gb, 5 - 2 * is8)) &gt; tns_max_order) {
-                    av_log(ac-&gt;avccontext, AV_LOG_ERROR, &quot;TNS filter order %d is greater than maximum %d.\n&quot;,
-                           tns-&gt;order[w][filt], tns_max_order);
-                    tns-&gt;order[w][filt] = 0;
-                    return -1;
-                }
-                if (tns-&gt;order[w][filt]) {
-                    tns-&gt;direction[w][filt] = get_bits1(gb);
-                    coef_compress = get_bits1(gb);
-                    coef_len = coef_res + 3 - coef_compress;
-                    tmp2_idx = 2 * coef_compress + coef_res;
-
-                    for (i = 0; i &lt; tns-&gt;order[w][filt]; i++)
-                        tns-&gt;coef[w][filt][i] = tns_tmp2_map[tmp2_idx][get_bits(gb, coef_len)];
-                }
-            }
-        }
-    }
-    return 0;
-}
-
-/**
- * Decode Mid/Side data; reference: table 4.54.
- *
- * @param   ms_present  Indicates mid/side stereo presence. [0] mask is all 0s;
- *                      [1] mask is decoded from bitstream; [2] mask is all 1s;
- *                      [3] reserved for scalable AAC
- */
-static void decode_mid_side_stereo(ChannelElement *cpe, GetBitContext *gb,
-                                   int ms_present)
-{
-    int idx;
-    if (ms_present == 1) {
-        for (idx = 0; idx &lt; cpe-&gt;ch[0].ics.num_window_groups * cpe-&gt;ch[0].ics.max_sfb; idx++)
-            cpe-&gt;ms_mask[idx] = get_bits1(gb);
-    } else if (ms_present == 2) {
-        memset(cpe-&gt;ms_mask, 1, cpe-&gt;ch[0].ics.num_window_groups * cpe-&gt;ch[0].ics.max_sfb * sizeof(cpe-&gt;ms_mask[0]));
-    }
-}
-
-#ifndef VMUL2
-static inline float *VMUL2(float *dst, const float *v, unsigned idx,
-                           const float *scale)
-{
-    float s = *scale;
-    *dst++ = v[idx    &amp; 15] * s;
-    *dst++ = v[idx&gt;&gt;4 &amp; 15] * s;
-    return dst;
-}
-#endif
-
-#ifndef VMUL4
-static inline float *VMUL4(float *dst, const float *v, unsigned idx,
-                           const float *scale)
-{
-    float s = *scale;
-    *dst++ = v[idx    &amp; 3] * s;
-    *dst++ = v[idx&gt;&gt;2 &amp; 3] * s;
-    *dst++ = v[idx&gt;&gt;4 &amp; 3] * s;
-    *dst++ = v[idx&gt;&gt;6 &amp; 3] * s;
-    return dst;
-}
-#endif
-
-#ifndef VMUL2S
-static inline float *VMUL2S(float *dst, const float *v, unsigned idx,
-                            unsigned sign, const float *scale)
-{
-    union float754 s0, s1;
-
-    s0.f = s1.f = *scale;
-    s0.i ^= sign &gt;&gt; 1 &lt;&lt; 31;
-    s1.i ^= sign      &lt;&lt; 31;
-
-    *dst++ = v[idx    &amp; 15] * s0.f;
-    *dst++ = v[idx&gt;&gt;4 &amp; 15] * s1.f;
-
-    return dst;
-}
-#endif
-
-#ifndef VMUL4S
-static inline float *VMUL4S(float *dst, const float *v, unsigned idx,
-                            unsigned sign, const float *scale)
-{
-    unsigned nz = idx &gt;&gt; 12;
-    union float754 s = { .f = *scale };
-    union float754 t;
-
-    t.i = s.i ^ (sign &amp; 1&lt;&lt;31);
-    *dst++ = v[idx    &amp; 3] * t.f;
-
-    sign &lt;&lt;= nz &amp; 1; nz &gt;&gt;= 1;
-    t.i = s.i ^ (sign &amp; 1&lt;&lt;31);
-    *dst++ = v[idx&gt;&gt;2 &amp; 3] * t.f;
-
-    sign &lt;&lt;= nz &amp; 1; nz &gt;&gt;= 1;
-    t.i = s.i ^ (sign &amp; 1&lt;&lt;31);
-    *dst++ = v[idx&gt;&gt;4 &amp; 3] * t.f;
-
-    sign &lt;&lt;= nz &amp; 1; nz &gt;&gt;= 1;
-    t.i = s.i ^ (sign &amp; 1&lt;&lt;31);
-    *dst++ = v[idx&gt;&gt;6 &amp; 3] * t.f;
-
-    return dst;
-}
-#endif
-
-/**
- * Decode spectral data; reference: table 4.50.
- * Dequantize and scale spectral data; reference: 4.6.3.3.
- *
- * @param   coef            array of dequantized, scaled spectral data
- * @param   sf              array of scalefactors or intensity stereo positions
- * @param   pulse_present   set if pulses are present
- * @param   pulse           pointer to pulse data struct
- * @param   band_type       array of the used band type
- *
- * @return  Returns error status. 0 - OK, !0 - error
- */
-static int decode_spectrum_and_dequant(AACContext *ac, float coef[1024],
-                                       GetBitContext *gb, const float sf[120],
-                                       int pulse_present, const Pulse *pulse,
-                                       const IndividualChannelStream *ics,
-                                       enum BandType band_type[120])
-{
-    int i, k, g, idx = 0;
-    const int c = 1024 / ics-&gt;num_windows;
-    const uint16_t *offsets = ics-&gt;swb_offset;
-    float *coef_base = coef;
-    int err_idx;
-
-    for (g = 0; g &lt; ics-&gt;num_windows; g++)
-        memset(coef + g * 128 + offsets[ics-&gt;max_sfb], 0, sizeof(float) * (c - offsets[ics-&gt;max_sfb]));
-
-    for (g = 0; g &lt; ics-&gt;num_window_groups; g++) {
-        unsigned g_len = ics-&gt;group_len[g];
-
-        for (i = 0; i &lt; ics-&gt;max_sfb; i++, idx++) {
-            const unsigned cbt_m1 = band_type[idx] - 1;
-            float *cfo = coef + offsets[i];
-            int off_len = offsets[i + 1] - offsets[i];
-            int group;
-
-            if (cbt_m1 &gt;= INTENSITY_BT2 - 1) {
-                for (group = 0; group &lt; g_len; group++, cfo+=128) {
-                    memset(cfo, 0, off_len * sizeof(float));
-                }
-            } else if (cbt_m1 == NOISE_BT - 1) {
-                for (group = 0; group &lt; g_len; group++, cfo+=128) {
-                    float scale;
-                    float band_energy;
-
-                    for (k = 0; k &lt; off_len; k++) {
-                        ac-&gt;random_state  = lcg_random(ac-&gt;random_state);
-                        cfo[k] = ac-&gt;random_state;
-                    }
-
-                    band_energy = ac-&gt;dsp.scalarproduct_float(cfo, cfo, off_len);
-                    scale = sf[idx] / sqrtf(band_energy);
-                    ac-&gt;dsp.vector_fmul_scalar(cfo, cfo, scale, off_len);
-                }
-            } else {
-                const float *vq = ff_aac_codebook_vector_vals[cbt_m1];
-                const uint16_t *cb_vector_idx = ff_aac_codebook_vector_idx[cbt_m1];
-                VLC_TYPE (*vlc_tab)[2] = vlc_spectral[cbt_m1].table;
-                const int cb_size = ff_aac_spectral_sizes[cbt_m1];
-                OPEN_READER(re, gb);
-
-                switch (cbt_m1 &gt;&gt; 1) {
-                case 0:
-                    for (group = 0; group &lt; g_len; group++, cfo+=128) {
-                        float *cf = cfo;
-                        int len = off_len;
-
-                        do {
-                            int code;
-                            unsigned cb_idx;
-
-                            UPDATE_CACHE(re, gb);
-                            GET_VLC(code, re, gb, vlc_tab, 8, 2);
-
-                            if (code &gt;= cb_size) {
-                                err_idx = code;
-                                goto err_cb_overflow;
-                            }
-
-                            cb_idx = cb_vector_idx[code];
-                            cf = VMUL4(cf, vq, cb_idx, sf + idx);
-                        } while (len -= 4);
-                    }
-                    break;
-
-                case 1:
-                    for (group = 0; group &lt; g_len; group++, cfo+=128) {
-                        float *cf = cfo;
-                        int len = off_len;
-
-                        do {
-                            int code;
-                            unsigned nnz;
-                            unsigned cb_idx;
-                            uint32_t bits;
-
-                            UPDATE_CACHE(re, gb);
-                            GET_VLC(code, re, gb, vlc_tab, 8, 2);
-
-                            if (code &gt;= cb_size) {
-                                err_idx = code;
-                                goto err_cb_overflow;
-                            }
-
-#if MIN_CACHE_BITS &lt; 20
-                            UPDATE_CACHE(re, gb);
-#endif
-                            cb_idx = cb_vector_idx[code];
-                            nnz = cb_idx &gt;&gt; 8 &amp; 15;
-                            bits = SHOW_UBITS(re, gb, nnz) &lt;&lt; (32-nnz);
-                            LAST_SKIP_BITS(re, gb, nnz);
-                            cf = VMUL4S(cf, vq, cb_idx, bits, sf + idx);
-                        } while (len -= 4);
-                    }
-                    break;
-
-                case 2:
-                    for (group = 0; group &lt; g_len; group++, cfo+=128) {
-                        float *cf = cfo;
-                        int len = off_len;
-
-                        do {
-                            int code;
-                            unsigned cb_idx;
-
-                            UPDATE_CACHE(re, gb);
-                            GET_VLC(code, re, gb, vlc_tab, 8, 2);
-
-                            if (code &gt;= cb_size) {
-                                err_idx = code;
-                                goto err_cb_overflow;
-                            }
-
-                            cb_idx = cb_vector_idx[code];
-                            cf = VMUL2(cf, vq, cb_idx, sf + idx);
-                        } while (len -= 2);
-                    }
-                    break;
-
-                case 3:
-                case 4:
-                    for (group = 0; group &lt; g_len; group++, cfo+=128) {
-                        float *cf = cfo;
-                        int len = off_len;
-
-                        do {
-                            int code;
-                            unsigned nnz;
-                            unsigned cb_idx;
-                            unsigned sign;
-
-                            UPDATE_CACHE(re, gb);
-                            GET_VLC(code, re, gb, vlc_tab, 8, 2);
-
-                            if (code &gt;= cb_size) {
-                                err_idx = code;
-                                goto err_cb_overflow;
-                            }
-
-                            cb_idx = cb_vector_idx[code];
-                            nnz = cb_idx &gt;&gt; 8 &amp; 15;
-                            sign = SHOW_UBITS(re, gb, nnz) &lt;&lt; (cb_idx &gt;&gt; 12);
-                            LAST_SKIP_BITS(re, gb, nnz);
-                            cf = VMUL2S(cf, vq, cb_idx, sign, sf + idx);
-                        } while (len -= 2);
-                    }
-                    break;
-
-                default:
-                    for (group = 0; group &lt; g_len; group++, cfo+=128) {
-                        float *cf = cfo;
-                        uint32_t *icf = (uint32_t *) cf;
-                        int len = off_len;
-
-                        do {
-                            int code;
-                            unsigned nzt, nnz;
-                            unsigned cb_idx;
-                            uint32_t bits;
-                            int j;
-
-                            UPDATE_CACHE(re, gb);
-                            GET_VLC(code, re, gb, vlc_tab, 8, 2);
-
-                            if (!code) {
-                                *icf++ = 0;
-                                *icf++ = 0;
-                                continue;
-                            }
-
-                            if (code &gt;= cb_size) {
-                                err_idx = code;
-                                goto err_cb_overflow;
-                            }
-
-                            cb_idx = cb_vector_idx[code];
-                            nnz = cb_idx &gt;&gt; 12;
-                            nzt = cb_idx &gt;&gt; 8;
-                            bits = SHOW_UBITS(re, gb, nnz) &lt;&lt; (32-nnz);
-                            LAST_SKIP_BITS(re, gb, nnz);
-
-                            for (j = 0; j &lt; 2; j++) {
-                                if (nzt &amp; 1&lt;&lt;j) {
-                                    uint32_t b;
-                                    int n;
-                                    /* The total length of escape_sequence must be &lt; 22 bits according
-                                       to the specification (i.e. max is 111111110xxxxxxxxxxxx). */
-                                    UPDATE_CACHE(re, gb);
-                                    b = GET_CACHE(re, gb);
-                                    b = 31 - av_log2(~b);
-
-                                    if (b &gt; 8) {
-                                        av_log(ac-&gt;avccontext, AV_LOG_ERROR, &quot;error in spectral data, ESC overflow\n&quot;);
-                                        return -1;
-                                    }
-
-#if MIN_CACHE_BITS &lt; 21
-                                    LAST_SKIP_BITS(re, gb, b + 1);
-                                    UPDATE_CACHE(re, gb);
-#else
-                                    SKIP_BITS(re, gb, b + 1);
-#endif
-                                    b += 4;
-                                    n = (1 &lt;&lt; b) + SHOW_UBITS(re, gb, b);
-                                    LAST_SKIP_BITS(re, gb, b);
-                                    *icf++ = cbrt_tab[n] | (bits &amp; 1&lt;&lt;31);
-                                    bits &lt;&lt;= 1;
-                                } else {
-                                    unsigned v = ((const uint32_t*)vq)[cb_idx &amp; 15];
-                                    *icf++ = (bits &amp; 1&lt;&lt;31) | v;
-                                    bits &lt;&lt;= !!v;
-                                }
-                                cb_idx &gt;&gt;= 4;
-                            }
-                        } while (len -= 2);
-
-                        ac-&gt;dsp.vector_fmul_scalar(cfo, cfo, sf[idx], off_len);
-                    }
-                }
-
-                CLOSE_READER(re, gb);
-            }
-        }
-        coef += g_len &lt;&lt; 7;
-    }
-
-    if (pulse_present) {
-        idx = 0;
-        for (i = 0; i &lt; pulse-&gt;num_pulse; i++) {
-            float co = coef_base[ pulse-&gt;pos[i] ];
-            while (offsets[idx + 1] &lt;= pulse-&gt;pos[i])
-                idx++;
-            if (band_type[idx] != NOISE_BT &amp;&amp; sf[idx]) {
-                float ico = -pulse-&gt;amp[i];
-                if (co) {
-                    co /= sf[idx];
-                    ico = co / sqrtf(sqrtf(fabsf(co))) + (co &gt; 0 ? -ico : ico);
-                }
-                coef_base[ pulse-&gt;pos[i] ] = cbrtf(fabsf(ico)) * ico * sf[idx];
-            }
-        }
-    }
-    return 0;
-
-err_cb_overflow:
-    av_log(ac-&gt;avccontext, AV_LOG_ERROR,
-           &quot;Read beyond end of ff_aac_codebook_vectors[%d][]. index %d &gt;= %d\n&quot;,
-           band_type[idx], err_idx, ff_aac_spectral_sizes[band_type[idx]]);
-    return -1;
-}
-
-static av_always_inline float flt16_round(float pf)
-{
-    union float754 tmp;
-    tmp.f = pf;
-    tmp.i = (tmp.i + 0x00008000U) &amp; 0xFFFF0000U;
-    return tmp.f;
-}
-
-static av_always_inline float flt16_even(float pf)
-{
-    union float754 tmp;
-    tmp.f = pf;
-    tmp.i = (tmp.i + 0x00007FFFU + (tmp.i &amp; 0x00010000U &gt;&gt; 16)) &amp; 0xFFFF0000U;
-    return tmp.f;
-}
-
-static av_always_inline float flt16_trunc(float pf)
-{
-    union float754 pun;
-    pun.f = pf;
-    pun.i &amp;= 0xFFFF0000U;
-    return pun.f;
-}
-
-static av_always_inline void predict(AACContext *ac, PredictorState *ps, float *coef,
-                    int output_enable)
-{
-    const float a     = 0.953125; // 61.0 / 64
-    const float alpha = 0.90625;  // 29.0 / 32
-    float e0, e1;
-    float pv;
-    float k1, k2;
-
-    k1 = ps-&gt;var0 &gt; 1 ? ps-&gt;cor0 * flt16_even(a / ps-&gt;var0) : 0;
-    k2 = ps-&gt;var1 &gt; 1 ? ps-&gt;cor1 * flt16_even(a / ps-&gt;var1) : 0;
-
-    pv = flt16_round(k1 * ps-&gt;r0 + k2 * ps-&gt;r1);
-    if (output_enable)
-        *coef += pv * ac-&gt;sf_scale;
-
-    e0 = *coef / ac-&gt;sf_scale;
-    e1 = e0 - k1 * ps-&gt;r0;
-
-    ps-&gt;cor1 = flt16_trunc(alpha * ps-&gt;cor1 + ps-&gt;r1 * e1);
-    ps-&gt;var1 = flt16_trunc(alpha * ps-&gt;var1 + 0.5 * (ps-&gt;r1 * ps-&gt;r1 + e1 * e1));
-    ps-&gt;cor0 = flt16_trunc(alpha * ps-&gt;cor0 + ps-&gt;r0 * e0);
-    ps-&gt;var0 = flt16_trunc(alpha * ps-&gt;var0 + 0.5 * (ps-&gt;r0 * ps-&gt;r0 + e0 * e0));
-
-    ps-&gt;r1 = flt16_trunc(a * (ps-&gt;r0 - k1 * e0));
-    ps-&gt;r0 = flt16_trunc(a * e0);
-}
-
-/**
- * Apply AAC-Main style frequency domain prediction.
- */
-static void apply_prediction(AACContext *ac, SingleChannelElement *sce)
-{
-    int sfb, k;
-
-    if (!sce-&gt;ics.predictor_initialized) {
-        reset_all_predictors(sce-&gt;predictor_state);
-        sce-&gt;ics.predictor_initialized = 1;
-    }
-
-    if (sce-&gt;ics.window_sequence[0] != EIGHT_SHORT_SEQUENCE) {
-        for (sfb = 0; sfb &lt; ff_aac_pred_sfb_max[ac-&gt;m4ac.sampling_index]; sfb++) {
-            for (k = sce-&gt;ics.swb_offset[sfb]; k &lt; sce-&gt;ics.swb_offset[sfb + 1]; k++) {
-                predict(ac, &amp;sce-&gt;predictor_state[k], &amp;sce-&gt;coeffs[k],
-                        sce-&gt;ics.predictor_present &amp;&amp; sce-&gt;ics.prediction_used[sfb]);
-            }
-        }
-        if (sce-&gt;ics.predictor_reset_group)
-            reset_predictor_group(sce-&gt;predictor_state, sce-&gt;ics.predictor_reset_group);
-    } else
-        reset_all_predictors(sce-&gt;predictor_state);
-}
-
-/**
- * Decode an individual_channel_stream payload; reference: table 4.44.
- *
- * @param   common_window   Channels have independent [0], or shared [1], Individual Channel Stream information.
- * @param   scale_flag      scalable [1] or non-scalable [0] AAC (Unused until scalable AAC is implemented.)
- *
- * @return  Returns error status. 0 - OK, !0 - error
- */
-static int decode_ics(AACContext *ac, SingleChannelElement *sce,
-                      GetBitContext *gb, int common_window, int scale_flag)
-{
-    Pulse pulse;
-    TemporalNoiseShaping    *tns = &amp;sce-&gt;tns;
-    IndividualChannelStream *ics = &amp;sce-&gt;ics;
-    float *out = sce-&gt;coeffs;
-    int global_gain, pulse_present = 0;
-
-    /* This assignment is to silence a GCC warning about the variable being used
-     * uninitialized when in fact it always is.
-     */
-    pulse.num_pulse = 0;
-
-    global_gain = get_bits(gb, 8);
-
-    if (!common_window &amp;&amp; !scale_flag) {
-        if (decode_ics_info(ac, ics, gb, 0) &lt; 0)
-            return -1;
-    }
-
-    if (decode_band_types(ac, sce-&gt;band_type, sce-&gt;band_type_run_end, gb, ics) &lt; 0)
-        return -1;
-    if (decode_scalefactors(ac, sce-&gt;sf, gb, global_gain, ics, sce-&gt;band_type, sce-&gt;band_type_run_end) &lt; 0)
-        return -1;
-
-    pulse_present = 0;
-    if (!scale_flag) {
-        if ((pulse_present = get_bits1(gb))) {
-            if (ics-&gt;window_sequence[0] == EIGHT_SHORT_SEQUENCE) {
-                av_log(ac-&gt;avccontext, AV_LOG_ERROR, &quot;Pulse tool not allowed in eight short sequence.\n&quot;);
-                return -1;
-            }
-            if (decode_pulses(&amp;pulse, gb, ics-&gt;swb_offset, ics-&gt;num_swb)) {
-                av_log(ac-&gt;avccontext, AV_LOG_ERROR, &quot;Pulse data corrupt or invalid.\n&quot;);
-                return -1;
-            }
-        }
-        if ((tns-&gt;present = get_bits1(gb)) &amp;&amp; decode_tns(ac, tns, gb, ics))
-            return -1;
-        if (get_bits1(gb)) {
-            av_log_missing_feature(ac-&gt;avccontext, &quot;SSR&quot;, 1);
-            return -1;
-        }
-    }
-
-    if (decode_spectrum_and_dequant(ac, out, gb, sce-&gt;sf, pulse_present, &amp;pulse, ics, sce-&gt;band_type) &lt; 0)
-        return -1;
-
-    if (ac-&gt;m4ac.object_type == AOT_AAC_MAIN &amp;&amp; !common_window)
-        apply_prediction(ac, sce);
-
-    return 0;
-}
-
-/**
- * Mid/Side stereo decoding; reference: 4.6.8.1.3.
- */
-static void apply_mid_side_stereo(AACContext *ac, ChannelElement *cpe)
-{
-    const IndividualChannelStream *ics = &amp;cpe-&gt;ch[0].ics;
-    float *ch0 = cpe-&gt;ch[0].coeffs;
-    float *ch1 = cpe-&gt;ch[1].coeffs;
-    int g, i, group, idx = 0;
-    const uint16_t *offsets = ics-&gt;swb_offset;
-    for (g = 0; g &lt; ics-&gt;num_window_groups; g++) {
-        for (i = 0; i &lt; ics-&gt;max_sfb; i++, idx++) {
-            if (cpe-&gt;ms_mask[idx] &amp;&amp;
-                    cpe-&gt;ch[0].band_type[idx] &lt; NOISE_BT &amp;&amp; cpe-&gt;ch[1].band_type[idx] &lt; NOISE_BT) {
-                for (group = 0; group &lt; ics-&gt;group_len[g]; group++) {
-                    ac-&gt;dsp.butterflies_float(ch0 + group * 128 + offsets[i],
-                                              ch1 + group * 128 + offsets[i],
-                                              offsets[i+1] - offsets[i]);
-                }
-            }
-        }
-        ch0 += ics-&gt;group_len[g] * 128;
-        ch1 += ics-&gt;group_len[g] * 128;
-    }
-}
-
-/**
- * intensity stereo decoding; reference: 4.6.8.2.3
- *
- * @param   ms_present  Indicates mid/side stereo presence. [0] mask is all 0s;
- *                      [1] mask is decoded from bitstream; [2] mask is all 1s;
- *                      [3] reserved for scalable AAC
- */
-static void apply_intensity_stereo(ChannelElement *cpe, int ms_present)
-{
-    const IndividualChannelStream *ics = &amp;cpe-&gt;ch[1].ics;
-    SingleChannelElement         *sce1 = &amp;cpe-&gt;ch[1];
-    float *coef0 = cpe-&gt;ch[0].coeffs, *coef1 = cpe-&gt;ch[1].coeffs;
-    const uint16_t *offsets = ics-&gt;swb_offset;
-    int g, group, i, k, idx = 0;
-    int c;
-    float scale;
-    for (g = 0; g &lt; ics-&gt;num_window_groups; g++) {
-        for (i = 0; i &lt; ics-&gt;max_sfb;) {
-            if (sce1-&gt;band_type[idx] == INTENSITY_BT || sce1-&gt;band_type[idx] == INTENSITY_BT2) {
-                const int bt_run_end = sce1-&gt;band_type_run_end[idx];
-                for (; i &lt; bt_run_end; i++, idx++) {
-                    c = -1 + 2 * (sce1-&gt;band_type[idx] - 14);
-                    if (ms_present)
-                        c *= 1 - 2 * cpe-&gt;ms_mask[idx];
-                    scale = c * sce1-&gt;sf[idx];
-                    for (group = 0; group &lt; ics-&gt;group_len[g]; group++)
-                        for (k = offsets[i]; k &lt; offsets[i + 1]; k++)
-                            coef1[group * 128 + k] = scale * coef0[group * 128 + k];
-                }
-            } else {
-                int bt_run_end = sce1-&gt;band_type_run_end[idx];
-                idx += bt_run_end - i;
-                i    = bt_run_end;
-            }
-        }
-        coef0 += ics-&gt;group_len[g] * 128;
-        coef1 += ics-&gt;group_len[g] * 128;
-    }
-}
-
-/**
- * Decode a channel_pair_element; reference: table 4.4.
- *
- * @param   elem_id Identifies the instance of a syntax element.
- *
- * @return  Returns error status. 0 - OK, !0 - error
- */
-static int decode_cpe(AACContext *ac, GetBitContext *gb, ChannelElement *cpe)
-{
-    int i, ret, common_window, ms_present = 0;
-
-    common_window = get_bits1(gb);
-    if (common_window) {
-        if (decode_ics_info(ac, &amp;cpe-&gt;ch[0].ics, gb, 1))
-            return -1;
-        i = cpe-&gt;ch[1].ics.use_kb_window[0];
-        cpe-&gt;ch[1].ics = cpe-&gt;ch[0].ics;
-        cpe-&gt;ch[1].ics.use_kb_window[1] = i;
-        ms_present = get_bits(gb, 2);
-        if (ms_present == 3) {
-            av_log(ac-&gt;avccontext, AV_LOG_ERROR, &quot;ms_present = 3 is reserved.\n&quot;);
-            return -1;
-        } else if (ms_present)
-            decode_mid_side_stereo(cpe, gb, ms_present);
-    }
-    if ((ret = decode_ics(ac, &amp;cpe-&gt;ch[0], gb, common_window, 0)))
-        return ret;
-    if ((ret = decode_ics(ac, &amp;cpe-&gt;ch[1], gb, common_window, 0)))
-        return ret;
-
-    if (common_window) {
-        if (ms_present)
-            apply_mid_side_stereo(ac, cpe);
-        if (ac-&gt;m4ac.object_type == AOT_AAC_MAIN) {
-            apply_prediction(ac, &amp;cpe-&gt;ch[0]);
-            apply_prediction(ac, &amp;cpe-&gt;ch[1]);
-        }
-    }
-
-    apply_intensity_stereo(cpe, ms_present);
-    return 0;
-}
-
-/**
- * Decode coupling_channel_element; reference: table 4.8.
- *
- * @param   elem_id Identifies the instance of a syntax element.
- *
- * @return  Returns error status. 0 - OK, !0 - error
- */
-static int decode_cce(AACContext *ac, GetBitContext *gb, ChannelElement *che)
-{
-    int num_gain = 0;
-    int c, g, sfb, ret;
-    int sign;
-    float scale;
-    SingleChannelElement *sce = &amp;che-&gt;ch[0];
-    ChannelCoupling     *coup = &amp;che-&gt;coup;
-
-    coup-&gt;coupling_point = 2 * get_bits1(gb);
-    coup-&gt;num_coupled = get_bits(gb, 3);
-    for (c = 0; c &lt;= coup-&gt;num_coupled; c++) {
-        num_gain++;
-        coup-&gt;type[c] = get_bits1(gb) ? TYPE_CPE : TYPE_SCE;
-        coup-&gt;id_select[c] = get_bits(gb, 4);
-        if (coup-&gt;type[c] == TYPE_CPE) {
-            coup-&gt;ch_select[c] = get_bits(gb, 2);
-            if (coup-&gt;ch_select[c] == 3)
-                num_gain++;
-        } else
-            coup-&gt;ch_select[c] = 2;
-    }
-    coup-&gt;coupling_point += get_bits1(gb) || (coup-&gt;coupling_point &gt;&gt; 1);
-
-    sign  = get_bits(gb, 1);
-    scale = pow(2., pow(2., (int)get_bits(gb, 2) - 3));
-
-    if ((ret = decode_ics(ac, sce, gb, 0, 0)))
-        return ret;
-
-    for (c = 0; c &lt; num_gain; c++) {
-        int idx  = 0;
-        int cge  = 1;
-        int gain = 0;
-        float gain_cache = 1.;
-        if (c) {
-            cge = coup-&gt;coupling_point == AFTER_IMDCT ? 1 : get_bits1(gb);
-            gain = cge ? get_vlc2(gb, vlc_scalefactors.table, 7, 3) - 60: 0;
-            gain_cache = pow(scale, -gain);
-        }
-        if (coup-&gt;coupling_point == AFTER_IMDCT) {
-            coup-&gt;gain[c][0] = gain_cache;
-        } else {
-            for (g = 0; g &lt; sce-&gt;ics.num_window_groups; g++) {
-                for (sfb = 0; sfb &lt; sce-&gt;ics.max_sfb; sfb++, idx++) {
-                    if (sce-&gt;band_type[idx] != ZERO_BT) {
-                        if (!cge) {
-                            int t = get_vlc2(gb, vlc_scalefactors.table, 7, 3) - 60;
-                            if (t) {
-                                int s = 1;
-                                t = gain += t;
-                                if (sign) {
-                                    s  -= 2 * (t &amp; 0x1);
-                                    t &gt;&gt;= 1;
-                                }
-                                gain_cache = pow(scale, -t) * s;
-                            }
-                        }
-                        coup-&gt;gain[c][idx] = gain_cache;
-                    }
-                }
-            }
-        }
-    }
-    return 0;
-}
-
-/**
- * Parse whether channels are to be excluded from Dynamic Range Compression; reference: table 4.53.
- *
- * @return  Returns number of bytes consumed.
- */
-static int decode_drc_channel_exclusions(DynamicRangeControl *che_drc,
-                                         GetBitContext *gb)
-{
-    int i;
-    int num_excl_chan = 0;
-
-    do {
-        for (i = 0; i &lt; 7; i++)
-            che_drc-&gt;exclude_mask[num_excl_chan++] = get_bits1(gb);
-    } while (num_excl_chan &lt; MAX_CHANNELS - 7 &amp;&amp; get_bits1(gb));
-
-    return num_excl_chan / 7;
-}
-
-/**
- * Decode dynamic range information; reference: table 4.52.
- *
- * @param   cnt length of TYPE_FIL syntactic element in bytes
- *
- * @return  Returns number of bytes consumed.
- */
-static int decode_dynamic_range(DynamicRangeControl *che_drc,
-                                GetBitContext *gb, int cnt)
-{
-    int n             = 1;
-    int drc_num_bands = 1;
-    int i;
-
-    /* pce_tag_present? */
-    if (get_bits1(gb)) {
-        che_drc-&gt;pce_instance_tag  = get_bits(gb, 4);
-        skip_bits(gb, 4); // tag_reserved_bits
-        n++;
-    }
-
-    /* excluded_chns_present? */
-    if (get_bits1(gb)) {
-        n += decode_drc_channel_exclusions(che_drc, gb);
-    }
-
-    /* drc_bands_present? */
-    if (get_bits1(gb)) {
-        che_drc-&gt;band_incr            = get_bits(gb, 4);
-        che_drc-&gt;interpolation_scheme = get_bits(gb, 4);
-        n++;
-        drc_num_bands += che_drc-&gt;band_incr;
-        for (i = 0; i &lt; drc_num_bands; i++) {
-            che_drc-&gt;band_top[i] = get_bits(gb, 8);
-            n++;
-        }
-    }
-
-    /* prog_ref_level_present? */
-    if (get_bits1(gb)) {
-        che_drc-&gt;prog_ref_level = get_bits(gb, 7);
-        skip_bits1(gb); // prog_ref_level_reserved_bits
-        n++;
-    }
-
-    for (i = 0; i &lt; drc_num_bands; i++) {
-        che_drc-&gt;dyn_rng_sgn[i] = get_bits1(gb);
-        che_drc-&gt;dyn_rng_ctl[i] = get_bits(gb, 7);
-        n++;
-    }
-
-    return n;
-}
-
-/**
- * Decode extension data (incomplete); reference: table 4.51.
- *
- * @param   cnt length of TYPE_FIL syntactic element in bytes
- *
- * @return Returns number of bytes consumed
- */
-static int decode_extension_payload(AACContext *ac, GetBitContext *gb, int cnt,
-                                    ChannelElement *che, enum RawDataBlockType elem_type)
-{
-    int crc_flag = 0;
-    int res = cnt;
-    switch (get_bits(gb, 4)) { // extension type
-    case EXT_SBR_DATA_CRC:
-        crc_flag++;
-    case EXT_SBR_DATA:
-        if (!che) {
-            av_log(ac-&gt;avccontext, AV_LOG_ERROR, &quot;SBR was found before the first channel element.\n&quot;);
-            return res;
-        } else if (!ac-&gt;m4ac.sbr) {
-            av_log(ac-&gt;avccontext, AV_LOG_ERROR, &quot;SBR signaled to be not-present but was found in the bitstream.\n&quot;);
-            skip_bits_long(gb, 8 * cnt - 4);
-            return res;
-        } else if (ac-&gt;m4ac.sbr == -1 &amp;&amp; ac-&gt;output_configured == OC_LOCKED) {
-            av_log(ac-&gt;avccontext, AV_LOG_ERROR, &quot;Implicit SBR was found with a first occurrence after the first frame.\n&quot;);
-            skip_bits_long(gb, 8 * cnt - 4);
-            return res;
-        } else {
-            ac-&gt;m4ac.sbr = 1;
-        }
-        res = ff_decode_sbr_extension(ac, &amp;che-&gt;sbr, gb, crc_flag, cnt, elem_type);
-        break;
-    case EXT_DYNAMIC_RANGE:
-        res = decode_dynamic_range(&amp;ac-&gt;che_drc, gb, cnt);
-        break;
-    case EXT_FILL:
-    case EXT_FILL_DATA:
-    case EXT_DATA_ELEMENT:
-    default:
-        skip_bits_long(gb, 8 * cnt - 4);
-        break;
-    };
-    return res;
-}
-
-/**
- * Decode Temporal Noise Shaping filter coefficients and apply all-pole filters; reference: 4.6.9.3.
- *
- * @param   decode  1 if tool is used normally, 0 if tool is used in LTP.
- * @param   coef    spectral coefficients
- */
-static void apply_tns(float coef[1024], TemporalNoiseShaping *tns,
-                      IndividualChannelStream *ics, int decode)
-{
-    const int mmm = FFMIN(ics-&gt;tns_max_bands, ics-&gt;max_sfb);
-    int w, filt, m, i;
-    int bottom, top, order, start, end, size, inc;
-    float lpc[TNS_MAX_ORDER];
-
-    for (w = 0; w &lt; ics-&gt;num_windows; w++) {
-        bottom = ics-&gt;num_swb;
-        for (filt = 0; filt &lt; tns-&gt;n_filt[w]; filt++) {
-            top    = bottom;
-            bottom = FFMAX(0, top - tns-&gt;length[w][filt]);
-            order  = tns-&gt;order[w][filt];
-            if (order == 0)
-                continue;
-
-            // tns_decode_coef
-            compute_lpc_coefs(tns-&gt;coef[w][filt], order, lpc, 0, 0, 0);
-
-            start = ics-&gt;swb_offset[FFMIN(bottom, mmm)];
-            end   = ics-&gt;swb_offset[FFMIN(   top, mmm)];
-            if ((size = end - start) &lt;= 0)
-                continue;
-            if (tns-&gt;direction[w][filt]) {
-                inc = -1;
-                start = end - 1;
-            } else {
-                inc = 1;
-            }
-            start += w * 128;
-
-            // ar filter
-            for (m = 0; m &lt; size; m++, start += inc)
-                for (i = 1; i &lt;= FFMIN(m, order); i++)
-                    coef[start] -= coef[start - i * inc] * lpc[i - 1];
-        }
-    }
-}
-
-/**
- * Conduct IMDCT and windowing.
- */
-static void imdct_and_windowing(AACContext *ac, SingleChannelElement *sce, float bias)
-{
-    IndividualChannelStream *ics = &amp;sce-&gt;ics;
-    float *in    = sce-&gt;coeffs;
-    float *out   = sce-&gt;ret;
-    float *saved = sce-&gt;saved;
-    const float *swindow      = ics-&gt;use_kb_window[0] ? ff_aac_kbd_short_128 : ff_sine_128;
-    const float *lwindow_prev = ics-&gt;use_kb_window[1] ? ff_aac_kbd_long_1024 : ff_sine_1024;
-    const float *swindow_prev = ics-&gt;use_kb_window[1] ? ff_aac_kbd_short_128 : ff_sine_128;
-    float *buf  = ac-&gt;buf_mdct;
-    float *temp = ac-&gt;temp;
-    int i;
-
-    // imdct
-    if (ics-&gt;window_sequence[0] == EIGHT_SHORT_SEQUENCE) {
-        if (ics-&gt;window_sequence[1] == ONLY_LONG_SEQUENCE || ics-&gt;window_sequence[1] == LONG_STOP_SEQUENCE)
-            av_log(ac-&gt;avccontext, AV_LOG_WARNING,
-                   &quot;Transition from an ONLY_LONG or LONG_STOP to an EIGHT_SHORT sequence detected. &quot;
-                   &quot;If you heard an audible artifact, please submit the sample to the FFmpeg developers.\n&quot;);
-        for (i = 0; i &lt; 1024; i += 128)
-            ff_imdct_half(&amp;ac-&gt;mdct_small, buf + i, in + i);
-    } else
-        ff_imdct_half(&amp;ac-&gt;mdct, buf, in);
-
-    /* window overlapping
-     * NOTE: To simplify the overlapping code, all 'meaningless' short to long
-     * and long to short transitions are considered to be short to short
-     * transitions. This leaves just two cases (long to long and short to short)
-     * with a little special sauce for EIGHT_SHORT_SEQUENCE.
-     */
-    if ((ics-&gt;window_sequence[1] == ONLY_LONG_SEQUENCE || ics-&gt;window_sequence[1] == LONG_STOP_SEQUENCE) &amp;&amp;
-            (ics-&gt;window_sequence[0] == ONLY_LONG_SEQUENCE || ics-&gt;window_sequence[0] == LONG_START_SEQUENCE)) {
-        ac-&gt;dsp.vector_fmul_window(    out,               saved,            buf,         lwindow_prev, bias, 512);
-    } else {
-        for (i = 0; i &lt; 448; i++)
-            out[i] = saved[i] + bias;
-
-        if (ics-&gt;window_sequence[0] == EIGHT_SHORT_SEQUENCE) {
-            ac-&gt;dsp.vector_fmul_window(out + 448 + 0*128, saved + 448,      buf + 0*128, swindow_prev, bias, 64);
-            ac-&gt;dsp.vector_fmul_window(out + 448 + 1*128, buf + 0*128 + 64, buf + 1*128, swindow,      bias, 64);
-            ac-&gt;dsp.vector_fmul_window(out + 448 + 2*128, buf + 1*128 + 64, buf + 2*128, swindow,      bias, 64);
-            ac-&gt;dsp.vector_fmul_window(out + 448 + 3*128, buf + 2*128 + 64, buf + 3*128, swindow,      bias, 64);
-            ac-&gt;dsp.vector_fmul_window(temp,              buf + 3*128 + 64, buf + 4*128, swindow,      bias, 64);
-            memcpy(                    out + 448 + 4*128, temp, 64 * sizeof(float));
-        } else {
-            ac-&gt;dsp.vector_fmul_window(out + 448,         saved + 448,      buf,         swindow_prev, bias, 64);
-            for (i = 576; i &lt; 1024; i++)
-                out[i] = buf[i-512] + bias;
-        }
-    }
-
-    // buffer update
-    if (ics-&gt;window_sequence[0] == EIGHT_SHORT_SEQUENCE) {
-        for (i = 0; i &lt; 64; i++)
-            saved[i] = temp[64 + i] - bias;
-        ac-&gt;dsp.vector_fmul_window(saved + 64,  buf + 4*128 + 64, buf + 5*128, swindow, 0, 64);
-        ac-&gt;dsp.vector_fmul_window(saved + 192, buf + 5*128 + 64, buf + 6*128, swindow, 0, 64);
-        ac-&gt;dsp.vector_fmul_window(saved + 320, buf + 6*128 + 64, buf + 7*128, swindow, 0, 64);
-        memcpy(                    saved + 448, buf + 7*128 + 64,  64 * sizeof(float));
-    } else if (ics-&gt;window_sequence[0] == LONG_START_SEQUENCE) {
-        memcpy(                    saved,       buf + 512,        448 * sizeof(float));
-        memcpy(                    saved + 448, buf + 7*128 + 64,  64 * sizeof(float));
-    } else { // LONG_STOP or ONLY_LONG
-        memcpy(                    saved,       buf + 512,        512 * sizeof(float));
-    }
-}
-
-/**
- * Apply dependent channel coupling (applied before IMDCT).
- *
- * @param   index   index into coupling gain array
- */
-static void apply_dependent_coupling(AACContext *ac,
-                                     SingleChannelElement *target,
-                                     ChannelElement *cce, int index)
-{
-    IndividualChannelStream *ics = &amp;cce-&gt;ch[0].ics;
-    const uint16_t *offsets = ics-&gt;swb_offset;
-    float *dest = target-&gt;coeffs;
-    const float *src = cce-&gt;ch[0].coeffs;
-    int g, i, group, k, idx = 0;
-    if (ac-&gt;m4ac.object_type == AOT_AAC_LTP) {
-        av_log(ac-&gt;avccontext, AV_LOG_ERROR,
-               &quot;Dependent coupling is not supported together with LTP\n&quot;);
-        return;
-    }
-    for (g = 0; g &lt; ics-&gt;num_window_groups; g++) {
-        for (i = 0; i &lt; ics-&gt;max_sfb; i++, idx++) {
-            if (cce-&gt;ch[0].band_type[idx] != ZERO_BT) {
-                const float gain = cce-&gt;coup.gain[index][idx];
-                for (group = 0; group &lt; ics-&gt;group_len[g]; group++) {
-                    for (k = offsets[i]; k &lt; offsets[i + 1]; k++) {
-                        // XXX dsputil-ize
-                        dest[group * 128 + k] += gain * src[group * 128 + k];
-                    }
-                }
-            }
-        }
-        dest += ics-&gt;group_len[g] * 128;
-        src  += ics-&gt;group_len[g] * 128;
-    }
-}
-
-/**
- * Apply independent channel coupling (applied after IMDCT).
- *
- * @param   index   index into coupling gain array
- */
-static void apply_independent_coupling(AACContext *ac,
-                                       SingleChannelElement *target,
-                                       ChannelElement *cce, int index)
-{
-    int i;
-    const float gain = cce-&gt;coup.gain[index][0];
-    const float bias = ac-&gt;add_bias;
-    const float *src = cce-&gt;ch[0].ret;
-    float *dest = target-&gt;ret;
-    const int len = 1024 &lt;&lt; (ac-&gt;m4ac.sbr == 1);
-
-    for (i = 0; i &lt; len; i++)
-        dest[i] += gain * (src[i] - bias);
-}
-
-/**
- * channel coupling transformation interface
- *
- * @param   index   index into coupling gain array
- * @param   apply_coupling_method   pointer to (in)dependent coupling function
- */
-static void apply_channel_coupling(AACContext *ac, ChannelElement *cc,
-                                   enum RawDataBlockType type, int elem_id,
-                                   enum CouplingPoint coupling_point,
-                                   void (*apply_coupling_method)(AACContext *ac, SingleChannelElement *target, ChannelElement *cce, int index))
-{
-    int i, c;
-
-    for (i = 0; i &lt; MAX_ELEM_ID; i++) {
-        ChannelElement *cce = ac-&gt;che[TYPE_CCE][i];
-        int index = 0;
-
-        if (cce &amp;&amp; cce-&gt;coup.coupling_point == coupling_point) {
-            ChannelCoupling *coup = &amp;cce-&gt;coup;
-
-            for (c = 0; c &lt;= coup-&gt;num_coupled; c++) {
-                if (coup-&gt;type[c] == type &amp;&amp; coup-&gt;id_select[c] == elem_id) {
-                    if (coup-&gt;ch_select[c] != 1) {
-                        apply_coupling_method(ac, &amp;cc-&gt;ch[0], cce, index);
-                        if (coup-&gt;ch_select[c] != 0)
-                            index++;
-                    }
-                    if (coup-&gt;ch_select[c] != 2)
-                        apply_coupling_method(ac, &amp;cc-&gt;ch[1], cce, index++);
-                } else
-                    index += 1 + (coup-&gt;ch_select[c] == 3);
-            }
-        }
-    }
-}
-
-/**
- * Convert spectral data to float samples, applying all supported tools as appropriate.
- */
-static void spectral_to_sample(AACContext *ac)
-{
-    int i, type;
-    float imdct_bias = (ac-&gt;m4ac.sbr &lt;= 0) ? ac-&gt;add_bias : 0.0f;
-    for (type = 3; type &gt;= 0; type--) {
-        for (i = 0; i &lt; MAX_ELEM_ID; i++) {
-            ChannelElement *che = ac-&gt;che[type][i];
-            if (che) {
-                if (type &lt;= TYPE_CPE)
-                    apply_channel_coupling(ac, che, type, i, BEFORE_TNS, apply_dependent_coupling);
-                if (che-&gt;ch[0].tns.present)
-                    apply_tns(che-&gt;ch[0].coeffs, &amp;che-&gt;ch[0].tns, &amp;che-&gt;ch[0].ics, 1);
-                if (che-&gt;ch[1].tns.present)
-                    apply_tns(che-&gt;ch[1].coeffs, &amp;che-&gt;ch[1].tns, &amp;che-&gt;ch[1].ics, 1);
-                if (type &lt;= TYPE_CPE)
-                    apply_channel_coupling(ac, che, type, i, BETWEEN_TNS_AND_IMDCT, apply_dependent_coupling);
-                if (type != TYPE_CCE || che-&gt;coup.coupling_point == AFTER_IMDCT) {
-                    imdct_and_windowing(ac, &amp;che-&gt;ch[0], imdct_bias);
-                    if (type == TYPE_CPE) {
-                        imdct_and_windowing(ac, &amp;che-&gt;ch[1], imdct_bias);
-                    }
-                    if (ac-&gt;m4ac.sbr &gt; 0) {
-                        ff_sbr_apply(ac, &amp;che-&gt;sbr, type, che-&gt;ch[0].ret, che-&gt;ch[1].ret);
-                    }
-                }
-                if (type &lt;= TYPE_CCE)
-                    apply_channel_coupling(ac, che, type, i, AFTER_IMDCT, apply_independent_coupling);
-            }
-        }
-    }
-}
-
-static int parse_adts_frame_header(AACContext *ac, GetBitContext *gb)
-{
-    int size;
-    AACADTSHeaderInfo hdr_info;
-
-    size = ff_aac_parse_header(gb, &amp;hdr_info);
-    if (size &gt; 0) {
-        if (ac-&gt;output_configured != OC_LOCKED &amp;&amp; hdr_info.chan_config) {
-            enum ChannelPosition new_che_pos[4][MAX_ELEM_ID];
-            memset(new_che_pos, 0, 4 * MAX_ELEM_ID * sizeof(new_che_pos[0][0]));
-            ac-&gt;m4ac.chan_config = hdr_info.chan_config;
-            if (set_default_channel_config(ac, new_che_pos, hdr_info.chan_config))
-                return -7;
-            if (output_configure(ac, ac-&gt;che_pos, new_che_pos, hdr_info.chan_config, OC_TRIAL_FRAME))
-                return -7;
-        } else if (ac-&gt;output_configured != OC_LOCKED) {
-            ac-&gt;output_configured = OC_NONE;
-        }
-        if (ac-&gt;output_configured != OC_LOCKED)
-            ac-&gt;m4ac.sbr = -1;
-        ac-&gt;m4ac.sample_rate     = hdr_info.sample_rate;
-        ac-&gt;m4ac.sampling_index  = hdr_info.sampling_index;
-        ac-&gt;m4ac.object_type     = hdr_info.object_type;
-        if (!ac-&gt;avccontext-&gt;sample_rate)
-            ac-&gt;avccontext-&gt;sample_rate = hdr_info.sample_rate;
-        if (hdr_info.num_aac_frames == 1) {
-            if (!hdr_info.crc_absent)
-                skip_bits(gb, 16);
-        } else {
-            av_log_missing_feature(ac-&gt;avccontext, &quot;More than one AAC RDB per ADTS frame is&quot;, 0);
-            return -1;
-        }
-    }
-    return size;
-}
-
-static int aac_decode_frame(AVCodecContext *avccontext, void *data,
-                            int *data_size, AVPacket *avpkt)
-{
-    const uint8_t *buf = avpkt-&gt;data;
-    int buf_size = avpkt-&gt;size;
-    AACContext *ac = avccontext-&gt;priv_data;
-    ChannelElement *che = NULL, *che_prev = NULL;
-    GetBitContext gb;
-    enum RawDataBlockType elem_type, elem_type_prev = TYPE_END;
-    int err, elem_id, data_size_tmp;
-    int buf_consumed;
-    int samples = 1024, multiplier;
-    int buf_offset;
-
-    init_get_bits(&amp;gb, buf, buf_size * 8);
-
-    if (show_bits(&amp;gb, 12) == 0xfff) {
-        if (parse_adts_frame_header(ac, &amp;gb) &lt; 0) {
-            av_log(avccontext, AV_LOG_ERROR, &quot;Error decoding AAC frame header.\n&quot;);
-            return -1;
-        }
-        if (ac-&gt;m4ac.sampling_index &gt; 12) {
-            av_log(ac-&gt;avccontext, AV_LOG_ERROR, &quot;invalid sampling rate index %d\n&quot;, ac-&gt;m4ac.sampling_index);
-            return -1;
-        }
-    }
-
-    // parse
-    while ((elem_type = get_bits(&amp;gb, 3)) != TYPE_END) {
-        elem_id = get_bits(&amp;gb, 4);
-
-        if (elem_type &lt; TYPE_DSE &amp;&amp; !(che=get_che(ac, elem_type, elem_id))) {
-            av_log(ac-&gt;avccontext, AV_LOG_ERROR, &quot;channel element %d.%d is not allocated\n&quot;, elem_type, elem_id);
-            return -1;
-        }
-
-        switch (elem_type) {
-
-        case TYPE_SCE:
-            err = decode_ics(ac, &amp;che-&gt;ch[0], &amp;gb, 0, 0);
-            break;
-
-        case TYPE_CPE:
-            err = decode_cpe(ac, &amp;gb, che);
-            break;
-
-        case TYPE_CCE:
-            err = decode_cce(ac, &amp;gb, che);
-            break;
-
-        case TYPE_LFE:
-            err = decode_ics(ac, &amp;che-&gt;ch[0], &amp;gb, 0, 0);
-            break;
-
-        case TYPE_DSE:
-            err = skip_data_stream_element(ac, &amp;gb);
-            break;
-
-        case TYPE_PCE: {
-            enum ChannelPosition new_che_pos[4][MAX_ELEM_ID];
-            memset(new_che_pos, 0, 4 * MAX_ELEM_ID * sizeof(new_che_pos[0][0]));
-            if ((err = decode_pce(ac, new_che_pos, &amp;gb)))
-                break;
-            if (ac-&gt;output_configured &gt; OC_TRIAL_PCE)
-                av_log(avccontext, AV_LOG_ERROR,
-                       &quot;Not evaluating a further program_config_element as this construct is dubious at best.\n&quot;);
-            else
-                err = output_configure(ac, ac-&gt;che_pos, new_che_pos, 0, OC_TRIAL_PCE);
-            break;
-        }
-
-        case TYPE_FIL:
-            if (elem_id == 15)
-                elem_id += get_bits(&amp;gb, 8) - 1;
-            if (get_bits_left(&amp;gb) &lt; 8 * elem_id) {
-                    av_log(avccontext, AV_LOG_ERROR, overread_err);
-                    return -1;
-            }
-            while (elem_id &gt; 0)
-                elem_id -= decode_extension_payload(ac, &amp;gb, elem_id, che_prev, elem_type_prev);
-            err = 0; /* FIXME */
-            break;
-
-        default:
-            err = -1; /* should not happen, but keeps compiler happy */
-            break;
-        }
-
-        che_prev       = che;
-        elem_type_prev = elem_type;
-
-        if (err)
-            return err;
-
-        if (get_bits_left(&amp;gb) &lt; 3) {
-            av_log(avccontext, AV_LOG_ERROR, overread_err);
-            return -1;
-        }
-    }
-
-    spectral_to_sample(ac);
-
-    multiplier = (ac-&gt;m4ac.sbr == 1) ? ac-&gt;m4ac.ext_sample_rate &gt; ac-&gt;m4ac.sample_rate : 0;
-    samples &lt;&lt;= multiplier;
-    if (ac-&gt;output_configured &lt; OC_LOCKED) {
-        avccontext-&gt;sample_rate = ac-&gt;m4ac.sample_rate &lt;&lt; multiplier;
-        avccontext-&gt;frame_size = samples;
-    }
-
-    data_size_tmp = samples * avccontext-&gt;channels * sizeof(int16_t);
-    if (*data_size &lt; data_size_tmp) {
-        av_log(avccontext, AV_LOG_ERROR,
-               &quot;Output buffer too small (%d) or trying to output too many samples (%d) for this frame.\n&quot;,
-               *data_size, data_size_tmp);
-        return -1;
-    }
-    *data_size = data_size_tmp;
-
-    ac-&gt;dsp.float_to_int16_interleave(data, (const float **)ac-&gt;output_data, samples, avccontext-&gt;channels);
-
-    if (ac-&gt;output_configured)
-        ac-&gt;output_configured = OC_LOCKED;
-
-    buf_consumed = (get_bits_count(&amp;gb) + 7) &gt;&gt; 3;
-    for (buf_offset = buf_consumed; buf_offset &lt; buf_size; buf_offset++)
-        if (buf[buf_offset])
-            break;
-
-    return buf_size &gt; buf_offset ? buf_consumed : buf_size;
-}
-
-static av_cold int aac_decode_close(AVCodecContext *avccontext)
-{
-    AACContext *ac = avccontext-&gt;priv_data;
-    int i, type;
-
-    for (i = 0; i &lt; MAX_ELEM_ID; i++) {
-        for (type = 0; type &lt; 4; type++) {
-            if (ac-&gt;che[type][i])
-                ff_aac_sbr_ctx_close(&amp;ac-&gt;che[type][i]-&gt;sbr);
-            av_freep(&amp;ac-&gt;che[type][i]);
-        }
-    }
-
-    ff_mdct_end(&amp;ac-&gt;mdct);
-    ff_mdct_end(&amp;ac-&gt;mdct_small);
-    return 0;
-}
-
-AVCodec aac_decoder = {
-    &quot;aac&quot;,
-    AVMEDIA_TYPE_AUDIO,
-    CODEC_ID_AAC,
-    sizeof(AACContext),
-    aac_decode_init,
-    NULL,
-    aac_decode_close,
-    aac_decode_frame,
-    .long_name = NULL_IF_CONFIG_SMALL(&quot;Advanced Audio Coding&quot;),
-    .sample_fmts = (const enum SampleFormat[]) {
-        SAMPLE_FMT_S16,SAMPLE_FMT_NONE
-    },
-    .channel_layouts = aac_channel_layout,
-};

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aacps.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aacps.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aacps.c	2010-07-25 10:07:52 UTC (rev 6483)
@@ -0,0 +1,1037 @@
+/*
+ * MPEG-4 Parametric Stereo decoding functions
+ * Copyright (c) 2010 Alex Converse &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">alex.converse at gmail.com</A>&gt;
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include &lt;stdint.h&gt;
+#include &quot;libavutil/common.h&quot;
+#include &quot;libavutil/mathematics.h&quot;
+#include &quot;avcodec.h&quot;
+#include &quot;get_bits.h&quot;
+#include &quot;aacps.h&quot;
+#include &quot;aacps_tablegen.h&quot;
+#include &quot;aacpsdata.c&quot;
+
+#define PS_BASELINE 0  //&lt; Operate in Baseline PS mode
+                       //&lt; Baseline implies 10 or 20 stereo bands,
+                       //&lt; mixing mode A, and no ipd/opd
+
+#define numQMFSlots 32 //numTimeSlots * RATE
+
+static const int8_t num_env_tab[2][4] = {
+    { 0, 1, 2, 4, },
+    { 1, 2, 3, 4, },
+};
+
+static const int8_t nr_iidicc_par_tab[] = {
+    10, 20, 34, 10, 20, 34,
+};
+
+static const int8_t nr_iidopd_par_tab[] = {
+     5, 11, 17,  5, 11, 17,
+};
+
+enum {
+    huff_iid_df1,
+    huff_iid_dt1,
+    huff_iid_df0,
+    huff_iid_dt0,
+    huff_icc_df,
+    huff_icc_dt,
+    huff_ipd_df,
+    huff_ipd_dt,
+    huff_opd_df,
+    huff_opd_dt,
+};
+
+static const int huff_iid[] = {
+    huff_iid_df0,
+    huff_iid_df1,
+    huff_iid_dt0,
+    huff_iid_dt1,
+};
+
+static VLC vlc_ps[10];
+
+/**
+ * Read Inter-channel Intensity Difference/Inter-Channel Coherence/
+ * Inter-channel Phase Difference/Overall Phase Difference parameters from the
+ * bitstream.
+ *
+ * @param avctx contains the current codec context
+ * @param gb    pointer to the input bitstream
+ * @param ps    pointer to the Parametric Stereo context
+ * @param par   pointer to the parameter to be read
+ * @param e     envelope to decode
+ * @param dt    1: time delta-coded, 0: frequency delta-coded
+ */
+#define READ_PAR_DATA(PAR, OFFSET, MASK, ERR_CONDITION) \
+static int read_ ## PAR ## _data(AVCodecContext *avctx, GetBitContext *gb, PSContext *ps, \
+                        int8_t (*PAR)[PS_MAX_NR_IIDICC], int table_idx, int e, int dt) \
+{ \
+    int b, num = ps-&gt;nr_ ## PAR ## _par; \
+    VLC_TYPE (*vlc_table)[2] = vlc_ps[table_idx].table; \
+    if (dt) { \
+        int e_prev = e ? e - 1 : ps-&gt;num_env_old - 1; \
+        e_prev = FFMAX(e_prev, 0); \
+        for (b = 0; b &lt; num; b++) { \
+            int val = PAR[e_prev][b] + get_vlc2(gb, vlc_table, 9, 3) - OFFSET; \
+            if (MASK) val &amp;= MASK; \
+            PAR[e][b] = val; \
+            if (ERR_CONDITION) \
+                goto err; \
+        } \
+    } else { \
+        int val = 0; \
+        for (b = 0; b &lt; num; b++) { \
+            val += get_vlc2(gb, vlc_table, 9, 3) - OFFSET; \
+            if (MASK) val &amp;= MASK; \
+            PAR[e][b] = val; \
+            if (ERR_CONDITION) \
+                goto err; \
+        } \
+    } \
+    return 0; \
+err: \
+    av_log(avctx, AV_LOG_ERROR, &quot;illegal &quot;#PAR&quot;\n&quot;); \
+    return -1; \
+}
+
+READ_PAR_DATA(iid,    huff_offset[table_idx],    0, FFABS(ps-&gt;iid_par[e][b]) &gt; 7 + 8 * ps-&gt;iid_quant)
+READ_PAR_DATA(icc,    huff_offset[table_idx],    0, ps-&gt;icc_par[e][b] &gt; 7U)
+READ_PAR_DATA(ipdopd,                      0, 0x07, 0)
+
+static int ps_read_extension_data(GetBitContext *gb, PSContext *ps, int ps_extension_id)
+{
+    int e;
+    int count = get_bits_count(gb);
+
+    if (ps_extension_id)
+        return 0;
+
+    ps-&gt;enable_ipdopd = get_bits1(gb);
+    if (ps-&gt;enable_ipdopd) {
+        for (e = 0; e &lt; ps-&gt;num_env; e++) {
+            int dt = get_bits1(gb);
+            read_ipdopd_data(NULL, gb, ps, ps-&gt;ipd_par, dt ? huff_ipd_dt : huff_ipd_df, e, dt);
+            dt = get_bits1(gb);
+            read_ipdopd_data(NULL, gb, ps, ps-&gt;opd_par, dt ? huff_opd_dt : huff_opd_df, e, dt);
+        }
+    }
+    skip_bits1(gb);      //reserved_ps
+    return get_bits_count(gb) - count;
+}
+
+static void ipdopd_reset(int8_t *opd_hist, int8_t *ipd_hist)
+{
+    int i;
+    for (i = 0; i &lt; PS_MAX_NR_IPDOPD; i++) {
+        opd_hist[i] = 0;
+        ipd_hist[i] = 0;
+    }
+}
+
+int ff_ps_read_data(AVCodecContext *avctx, GetBitContext *gb_host, PSContext *ps, int bits_left)
+{
+    int e;
+    int bit_count_start = get_bits_count(gb_host);
+    int header;
+    int bits_consumed;
+    GetBitContext gbc = *gb_host, *gb = &gbc;
+
+    header = get_bits1(gb);
+    if (header) {     //enable_ps_header
+        ps-&gt;enable_iid = get_bits1(gb);
+        if (ps-&gt;enable_iid) {
+            int iid_mode = get_bits(gb, 3);
+            if (iid_mode &gt; 5) {
+                av_log(avctx, AV_LOG_ERROR, &quot;iid_mode %d is reserved.\n&quot;,
+                       iid_mode);
+                goto err;
+            }
+            ps-&gt;nr_iid_par    = nr_iidicc_par_tab[iid_mode];
+            ps-&gt;iid_quant     = iid_mode &gt; 2;
+            ps-&gt;nr_ipdopd_par = nr_iidopd_par_tab[iid_mode];
+        }
+        ps-&gt;enable_icc = get_bits1(gb);
+        if (ps-&gt;enable_icc) {
+            ps-&gt;icc_mode = get_bits(gb, 3);
+            if (ps-&gt;icc_mode &gt; 5) {
+                av_log(avctx, AV_LOG_ERROR, &quot;icc_mode %d is reserved.\n&quot;,
+                       ps-&gt;icc_mode);
+                goto err;
+            }
+            ps-&gt;nr_icc_par = nr_iidicc_par_tab[ps-&gt;icc_mode];
+        }
+        ps-&gt;enable_ext = get_bits1(gb);
+    }
+
+    ps-&gt;frame_class = get_bits1(gb);
+    ps-&gt;num_env_old = ps-&gt;num_env;
+    ps-&gt;num_env     = num_env_tab[ps-&gt;frame_class][get_bits(gb, 2)];
+
+    ps-&gt;border_position[0] = -1;
+    if (ps-&gt;frame_class) {
+        for (e = 1; e &lt;= ps-&gt;num_env; e++)
+            ps-&gt;border_position[e] = get_bits(gb, 5);
+    } else
+        for (e = 1; e &lt;= ps-&gt;num_env; e++)
+            ps-&gt;border_position[e] = (e * numQMFSlots &gt;&gt; ff_log2_tab[ps-&gt;num_env]) - 1;
+
+    if (ps-&gt;enable_iid) {
+        for (e = 0; e &lt; ps-&gt;num_env; e++) {
+            int dt = get_bits1(gb);
+            if (read_iid_data(avctx, gb, ps, ps-&gt;iid_par, huff_iid[2*dt+ps-&gt;iid_quant], e, dt))
+                goto err;
+        }
+    } else
+        memset(ps-&gt;iid_par, 0, sizeof(ps-&gt;iid_par));
+
+    if (ps-&gt;enable_icc)
+        for (e = 0; e &lt; ps-&gt;num_env; e++) {
+            int dt = get_bits1(gb);
+            if (read_icc_data(avctx, gb, ps, ps-&gt;icc_par, dt ? huff_icc_dt : huff_icc_df, e, dt))
+                goto err;
+        }
+    else
+        memset(ps-&gt;icc_par, 0, sizeof(ps-&gt;icc_par));
+
+    if (ps-&gt;enable_ext) {
+        int cnt = get_bits(gb, 4);
+        if (cnt == 15) {
+            cnt += get_bits(gb, 8);
+        }
+        cnt *= 8;
+        while (cnt &gt; 7) {
+            int ps_extension_id = get_bits(gb, 2);
+            cnt -= 2 + ps_read_extension_data(gb, ps, ps_extension_id);
+        }
+        if (cnt &lt; 0) {
+            av_log(avctx, AV_LOG_ERROR, &quot;ps extension overflow %d&quot;, cnt);
+            goto err;
+        }
+        skip_bits(gb, cnt);
+    }
+
+    ps-&gt;enable_ipdopd &amp;= !PS_BASELINE;
+
+    //Fix up envelopes
+    if (!ps-&gt;num_env || ps-&gt;border_position[ps-&gt;num_env] &lt; numQMFSlots - 1) {
+        //Create a fake envelope
+        int source = ps-&gt;num_env ? ps-&gt;num_env - 1 : ps-&gt;num_env_old - 1;
+        if (source &gt;= 0 &amp;&amp; source != ps-&gt;num_env) {
+            if (ps-&gt;enable_iid) {
+                memcpy(ps-&gt;iid_par+ps-&gt;num_env, ps-&gt;iid_par+source, sizeof(ps-&gt;iid_par[0]));
+            }
+            if (ps-&gt;enable_icc) {
+                memcpy(ps-&gt;icc_par+ps-&gt;num_env, ps-&gt;icc_par+source, sizeof(ps-&gt;icc_par[0]));
+            }
+            if (ps-&gt;enable_ipdopd) {
+                memcpy(ps-&gt;ipd_par+ps-&gt;num_env, ps-&gt;ipd_par+source, sizeof(ps-&gt;ipd_par[0]));
+                memcpy(ps-&gt;opd_par+ps-&gt;num_env, ps-&gt;opd_par+source, sizeof(ps-&gt;opd_par[0]));
+            }
+        }
+        ps-&gt;num_env++;
+        ps-&gt;border_position[ps-&gt;num_env] = numQMFSlots - 1;
+    }
+
+
+    ps-&gt;is34bands_old = ps-&gt;is34bands;
+    if (!PS_BASELINE &amp;&amp; (ps-&gt;enable_iid || ps-&gt;enable_icc))
+        ps-&gt;is34bands = (ps-&gt;enable_iid &amp;&amp; ps-&gt;nr_iid_par == 34) ||
+                        (ps-&gt;enable_icc &amp;&amp; ps-&gt;nr_icc_par == 34);
+
+    //Baseline
+    if (!ps-&gt;enable_ipdopd) {
+        memset(ps-&gt;ipd_par, 0, sizeof(ps-&gt;ipd_par));
+        memset(ps-&gt;opd_par, 0, sizeof(ps-&gt;opd_par));
+    }
+
+    if (header)
+        ps-&gt;start = 1;
+
+    bits_consumed = get_bits_count(gb) - bit_count_start;
+    if (bits_consumed &lt;= bits_left) {
+        skip_bits_long(gb_host, bits_consumed);
+        return bits_consumed;
+    }
+    av_log(avctx, AV_LOG_ERROR, &quot;Expected to read %d PS bits actually read %d.\n&quot;, bits_left, bits_consumed);
+err:
+    ps-&gt;start = 0;
+    skip_bits_long(gb_host, bits_left);
+    return bits_left;
+}
+
+/** Split one subband into 2 subsubbands with a symmetric real filter.
+ * The filter must have its non-center even coefficients equal to zero. */
+static void hybrid2_re(float (*in)[2], float (*out)[32][2], const float filter[7], int len, int reverse)
+{
+    int i, j;
+    for (i = 0; i &lt; len; i++, in++) {
+        float re_in = filter[6] * in[6][0];          //real inphase
+        float re_op = 0.0f;                          //real out of phase
+        float im_in = filter[6] * in[6][1];          //imag inphase
+        float im_op = 0.0f;                          //imag out of phase
+        for (j = 0; j &lt; 6; j += 2) {
+            re_op += filter[j+1] * (in[j+1][0] + in[12-j-1][0]);
+            im_op += filter[j+1] * (in[j+1][1] + in[12-j-1][1]);
+        }
+        out[ reverse][i][0] = re_in + re_op;
+        out[ reverse][i][1] = im_in + im_op;
+        out[!reverse][i][0] = re_in - re_op;
+        out[!reverse][i][1] = im_in - im_op;
+    }
+}
+
+/** Split one subband into 6 subsubbands with a complex filter */
+static void hybrid6_cx(float (*in)[2], float (*out)[32][2], const float (*filter)[7][2], int len)
+{
+    int i, j, ssb;
+    int N = 8;
+    float temp[8][2];
+
+    for (i = 0; i &lt; len; i++, in++) {
+        for (ssb = 0; ssb &lt; N; ssb++) {
+            float sum_re = filter[ssb][6][0] * in[6][0], sum_im = filter[ssb][6][0] * in[6][1];
+            for (j = 0; j &lt; 6; j++) {
+                float in0_re = in[j][0];
+                float in0_im = in[j][1];
+                float in1_re = in[12-j][0];
+                float in1_im = in[12-j][1];
+                sum_re += filter[ssb][j][0] * (in0_re + in1_re) - filter[ssb][j][1] * (in0_im - in1_im);
+                sum_im += filter[ssb][j][0] * (in0_im + in1_im) + filter[ssb][j][1] * (in0_re - in1_re);
+            }
+            temp[ssb][0] = sum_re;
+            temp[ssb][1] = sum_im;
+        }
+        out[0][i][0] = temp[6][0];
+        out[0][i][1] = temp[6][1];
+        out[1][i][0] = temp[7][0];
+        out[1][i][1] = temp[7][1];
+        out[2][i][0] = temp[0][0];
+        out[2][i][1] = temp[0][1];
+        out[3][i][0] = temp[1][0];
+        out[3][i][1] = temp[1][1];
+        out[4][i][0] = temp[2][0] + temp[5][0];
+        out[4][i][1] = temp[2][1] + temp[5][1];
+        out[5][i][0] = temp[3][0] + temp[4][0];
+        out[5][i][1] = temp[3][1] + temp[4][1];
+    }
+}
+
+static void hybrid4_8_12_cx(float (*in)[2], float (*out)[32][2], const float (*filter)[7][2], int N, int len)
+{
+    int i, j, ssb;
+
+    for (i = 0; i &lt; len; i++, in++) {
+        for (ssb = 0; ssb &lt; N; ssb++) {
+            float sum_re = filter[ssb][6][0] * in[6][0], sum_im = filter[ssb][6][0] * in[6][1];
+            for (j = 0; j &lt; 6; j++) {
+                float in0_re = in[j][0];
+                float in0_im = in[j][1];
+                float in1_re = in[12-j][0];
+                float in1_im = in[12-j][1];
+                sum_re += filter[ssb][j][0] * (in0_re + in1_re) - filter[ssb][j][1] * (in0_im - in1_im);
+                sum_im += filter[ssb][j][0] * (in0_im + in1_im) + filter[ssb][j][1] * (in0_re - in1_re);
+            }
+            out[ssb][i][0] = sum_re;
+            out[ssb][i][1] = sum_im;
+        }
+    }
+}
+
+static void hybrid_analysis(float out[91][32][2], float in[5][44][2], float L[2][38][64], int is34, int len)
+{
+    int i, j;
+    for (i = 0; i &lt; 5; i++) {
+        for (j = 0; j &lt; 38; j++) {
+            in[i][j+6][0] = L[0][j][i];
+            in[i][j+6][1] = L[1][j][i];
+        }
+    }
+    if (is34) {
+        hybrid4_8_12_cx(in[0], out,    f34_0_12, 12, len);
+        hybrid4_8_12_cx(in[1], out+12, f34_1_8,   8, len);
+        hybrid4_8_12_cx(in[2], out+20, f34_2_4,   4, len);
+        hybrid4_8_12_cx(in[3], out+24, f34_2_4,   4, len);
+        hybrid4_8_12_cx(in[4], out+28, f34_2_4,   4, len);
+        for (i = 0; i &lt; 59; i++) {
+            for (j = 0; j &lt; len; j++) {
+                out[i+32][j][0] = L[0][j][i+5];
+                out[i+32][j][1] = L[1][j][i+5];
+            }
+        }
+    } else {
+        hybrid6_cx(in[0], out, f20_0_8, len);
+        hybrid2_re(in[1], out+6, g1_Q2, len, 1);
+        hybrid2_re(in[2], out+8, g1_Q2, len, 0);
+        for (i = 0; i &lt; 61; i++) {
+            for (j = 0; j &lt; len; j++) {
+                out[i+10][j][0] = L[0][j][i+3];
+                out[i+10][j][1] = L[1][j][i+3];
+            }
+        }
+    }
+    //update in_buf
+    for (i = 0; i &lt; 5; i++) {
+        memcpy(in[i], in[i]+32, 6 * sizeof(in[i][0]));
+    }
+}
+
+static void hybrid_synthesis(float out[2][38][64], float in[91][32][2], int is34, int len)
+{
+    int i, n;
+    if (is34) {
+        for (n = 0; n &lt; len; n++) {
+            memset(out[0][n], 0, 5*sizeof(out[0][n][0]));
+            memset(out[1][n], 0, 5*sizeof(out[1][n][0]));
+            for (i = 0; i &lt; 12; i++) {
+                out[0][n][0] += in[   i][n][0];
+                out[1][n][0] += in[   i][n][1];
+            }
+            for (i = 0; i &lt; 8; i++) {
+                out[0][n][1] += in[12+i][n][0];
+                out[1][n][1] += in[12+i][n][1];
+            }
+            for (i = 0; i &lt; 4; i++) {
+                out[0][n][2] += in[20+i][n][0];
+                out[1][n][2] += in[20+i][n][1];
+                out[0][n][3] += in[24+i][n][0];
+                out[1][n][3] += in[24+i][n][1];
+                out[0][n][4] += in[28+i][n][0];
+                out[1][n][4] += in[28+i][n][1];
+            }
+        }
+        for (i = 0; i &lt; 59; i++) {
+            for (n = 0; n &lt; len; n++) {
+                out[0][n][i+5] = in[i+32][n][0];
+                out[1][n][i+5] = in[i+32][n][1];
+            }
+        }
+    } else {
+        for (n = 0; n &lt; len; n++) {
+            out[0][n][0] = in[0][n][0] + in[1][n][0] + in[2][n][0] +
+                           in[3][n][0] + in[4][n][0] + in[5][n][0];
+            out[1][n][0] = in[0][n][1] + in[1][n][1] + in[2][n][1] +
+                           in[3][n][1] + in[4][n][1] + in[5][n][1];
+            out[0][n][1] = in[6][n][0] + in[7][n][0];
+            out[1][n][1] = in[6][n][1] + in[7][n][1];
+            out[0][n][2] = in[8][n][0] + in[9][n][0];
+            out[1][n][2] = in[8][n][1] + in[9][n][1];
+        }
+        for (i = 0; i &lt; 61; i++) {
+            for (n = 0; n &lt; len; n++) {
+                out[0][n][i+3] = in[i+10][n][0];
+                out[1][n][i+3] = in[i+10][n][1];
+            }
+        }
+    }
+}
+
+/// All-pass filter decay slope
+#define DECAY_SLOPE      0.05f
+/// Number of frequency bands that can be addressed by the parameter index, b(k)
+static const int   NR_PAR_BANDS[]      = { 20, 34 };
+/// Number of frequency bands that can be addressed by the sub subband index, k
+static const int   NR_BANDS[]          = { 71, 91 };
+/// Start frequency band for the all-pass filter decay slope
+static const int   DECAY_CUTOFF[]      = { 10, 32 };
+/// Number of all-pass filer bands
+static const int   NR_ALLPASS_BANDS[]  = { 30, 50 };
+/// First stereo band using the short one sample delay
+static const int   SHORT_DELAY_BAND[]  = { 42, 62 };
+
+/** Table 8.46 */
+static void map_idx_10_to_20(int8_t *par_mapped, const int8_t *par, int full)
+{
+    int b;
+    if (full)
+        b = 9;
+    else {
+        b = 4;
+        par_mapped[10] = 0;
+    }
+    for (; b &gt;= 0; b--) {
+        par_mapped[2*b+1] = par_mapped[2*b] = par[b];
+    }
+}
+
+static void map_idx_34_to_20(int8_t *par_mapped, const int8_t *par, int full)
+{
+    par_mapped[ 0] = (2*par[ 0] +   par[ 1]) / 3;
+    par_mapped[ 1] = (  par[ 1] + 2*par[ 2]) / 3;
+    par_mapped[ 2] = (2*par[ 3] +   par[ 4]) / 3;
+    par_mapped[ 3] = (  par[ 4] + 2*par[ 5]) / 3;
+    par_mapped[ 4] = (  par[ 6] +   par[ 7]) / 2;
+    par_mapped[ 5] = (  par[ 8] +   par[ 9]) / 2;
+    par_mapped[ 6] =    par[10];
+    par_mapped[ 7] =    par[11];
+    par_mapped[ 8] = (  par[12] +   par[13]) / 2;
+    par_mapped[ 9] = (  par[14] +   par[15]) / 2;
+    par_mapped[10] =    par[16];
+    if (full) {
+        par_mapped[11] =    par[17];
+        par_mapped[12] =    par[18];
+        par_mapped[13] =    par[19];
+        par_mapped[14] = (  par[20] +   par[21]) / 2;
+        par_mapped[15] = (  par[22] +   par[23]) / 2;
+        par_mapped[16] = (  par[24] +   par[25]) / 2;
+        par_mapped[17] = (  par[26] +   par[27]) / 2;
+        par_mapped[18] = (  par[28] +   par[29] +   par[30] +   par[31]) / 4;
+        par_mapped[19] = (  par[32] +   par[33]) / 2;
+    }
+}
+
+static void map_val_34_to_20(float par[PS_MAX_NR_IIDICC])
+{
+    par[ 0] = (2*par[ 0] +   par[ 1]) * 0.33333333f;
+    par[ 1] = (  par[ 1] + 2*par[ 2]) * 0.33333333f;
+    par[ 2] = (2*par[ 3] +   par[ 4]) * 0.33333333f;
+    par[ 3] = (  par[ 4] + 2*par[ 5]) * 0.33333333f;
+    par[ 4] = (  par[ 6] +   par[ 7]) * 0.5f;
+    par[ 5] = (  par[ 8] +   par[ 9]) * 0.5f;
+    par[ 6] =    par[10];
+    par[ 7] =    par[11];
+    par[ 8] = (  par[12] +   par[13]) * 0.5f;
+    par[ 9] = (  par[14] +   par[15]) * 0.5f;
+    par[10] =    par[16];
+    par[11] =    par[17];
+    par[12] =    par[18];
+    par[13] =    par[19];
+    par[14] = (  par[20] +   par[21]) * 0.5f;
+    par[15] = (  par[22] +   par[23]) * 0.5f;
+    par[16] = (  par[24] +   par[25]) * 0.5f;
+    par[17] = (  par[26] +   par[27]) * 0.5f;
+    par[18] = (  par[28] +   par[29] +   par[30] +   par[31]) * 0.25f;
+    par[19] = (  par[32] +   par[33]) * 0.5f;
+}
+
+static void map_idx_10_to_34(int8_t *par_mapped, const int8_t *par, int full)
+{
+    if (full) {
+        par_mapped[33] = par[9];
+        par_mapped[32] = par[9];
+        par_mapped[31] = par[9];
+        par_mapped[30] = par[9];
+        par_mapped[29] = par[9];
+        par_mapped[28] = par[9];
+        par_mapped[27] = par[8];
+        par_mapped[26] = par[8];
+        par_mapped[25] = par[8];
+        par_mapped[24] = par[8];
+        par_mapped[23] = par[7];
+        par_mapped[22] = par[7];
+        par_mapped[21] = par[7];
+        par_mapped[20] = par[7];
+        par_mapped[19] = par[6];
+        par_mapped[18] = par[6];
+        par_mapped[17] = par[5];
+        par_mapped[16] = par[5];
+    } else {
+        par_mapped[16] =      0;
+    }
+    par_mapped[15] = par[4];
+    par_mapped[14] = par[4];
+    par_mapped[13] = par[4];
+    par_mapped[12] = par[4];
+    par_mapped[11] = par[3];
+    par_mapped[10] = par[3];
+    par_mapped[ 9] = par[2];
+    par_mapped[ 8] = par[2];
+    par_mapped[ 7] = par[2];
+    par_mapped[ 6] = par[2];
+    par_mapped[ 5] = par[1];
+    par_mapped[ 4] = par[1];
+    par_mapped[ 3] = par[1];
+    par_mapped[ 2] = par[0];
+    par_mapped[ 1] = par[0];
+    par_mapped[ 0] = par[0];
+}
+
+static void map_idx_20_to_34(int8_t *par_mapped, const int8_t *par, int full)
+{
+    if (full) {
+        par_mapped[33] =  par[19];
+        par_mapped[32] =  par[19];
+        par_mapped[31] =  par[18];
+        par_mapped[30] =  par[18];
+        par_mapped[29] =  par[18];
+        par_mapped[28] =  par[18];
+        par_mapped[27] =  par[17];
+        par_mapped[26] =  par[17];
+        par_mapped[25] =  par[16];
+        par_mapped[24] =  par[16];
+        par_mapped[23] =  par[15];
+        par_mapped[22] =  par[15];
+        par_mapped[21] =  par[14];
+        par_mapped[20] =  par[14];
+        par_mapped[19] =  par[13];
+        par_mapped[18] =  par[12];
+        par_mapped[17] =  par[11];
+    }
+    par_mapped[16] =  par[10];
+    par_mapped[15] =  par[ 9];
+    par_mapped[14] =  par[ 9];
+    par_mapped[13] =  par[ 8];
+    par_mapped[12] =  par[ 8];
+    par_mapped[11] =  par[ 7];
+    par_mapped[10] =  par[ 6];
+    par_mapped[ 9] =  par[ 5];
+    par_mapped[ 8] =  par[ 5];
+    par_mapped[ 7] =  par[ 4];
+    par_mapped[ 6] =  par[ 4];
+    par_mapped[ 5] =  par[ 3];
+    par_mapped[ 4] = (par[ 2] + par[ 3]) / 2;
+    par_mapped[ 3] =  par[ 2];
+    par_mapped[ 2] =  par[ 1];
+    par_mapped[ 1] = (par[ 0] + par[ 1]) / 2;
+    par_mapped[ 0] =  par[ 0];
+}
+
+static void map_val_20_to_34(float par[PS_MAX_NR_IIDICC])
+{
+    par[33] =  par[19];
+    par[32] =  par[19];
+    par[31] =  par[18];
+    par[30] =  par[18];
+    par[29] =  par[18];
+    par[28] =  par[18];
+    par[27] =  par[17];
+    par[26] =  par[17];
+    par[25] =  par[16];
+    par[24] =  par[16];
+    par[23] =  par[15];
+    par[22] =  par[15];
+    par[21] =  par[14];
+    par[20] =  par[14];
+    par[19] =  par[13];
+    par[18] =  par[12];
+    par[17] =  par[11];
+    par[16] =  par[10];
+    par[15] =  par[ 9];
+    par[14] =  par[ 9];
+    par[13] =  par[ 8];
+    par[12] =  par[ 8];
+    par[11] =  par[ 7];
+    par[10] =  par[ 6];
+    par[ 9] =  par[ 5];
+    par[ 8] =  par[ 5];
+    par[ 7] =  par[ 4];
+    par[ 6] =  par[ 4];
+    par[ 5] =  par[ 3];
+    par[ 4] = (par[ 2] + par[ 3]) * 0.5f;
+    par[ 3] =  par[ 2];
+    par[ 2] =  par[ 1];
+    par[ 1] = (par[ 0] + par[ 1]) * 0.5f;
+    par[ 0] =  par[ 0];
+}
+
+static void decorrelation(PSContext *ps, float (*out)[32][2], const float (*s)[32][2], int is34)
+{
+    float power[34][PS_QMF_TIME_SLOTS] = {{0}};
+    float transient_gain[34][PS_QMF_TIME_SLOTS];
+    float *peak_decay_nrg = ps-&gt;peak_decay_nrg;
+    float *power_smooth = ps-&gt;power_smooth;
+    float *peak_decay_diff_smooth = ps-&gt;peak_decay_diff_smooth;
+    float (*delay)[PS_QMF_TIME_SLOTS + PS_MAX_DELAY][2] = ps-&gt;delay;
+    float (*ap_delay)[PS_AP_LINKS][PS_QMF_TIME_SLOTS + PS_MAX_AP_DELAY][2] = ps-&gt;ap_delay;
+    const int8_t *k_to_i = is34 ? k_to_i_34 : k_to_i_20;
+    const float peak_decay_factor = 0.76592833836465f;
+    const float transient_impact  = 1.5f;
+    const float a_smooth          = 0.25f; //&lt; Smoothing coefficient
+    int i, k, m, n;
+    int n0 = 0, nL = 32;
+    static const int link_delay[] = { 3, 4, 5 };
+    static const float a[] = { 0.65143905753106f,
+                               0.56471812200776f,
+                               0.48954165955695f };
+
+    if (is34 != ps-&gt;is34bands_old) {
+        memset(ps-&gt;peak_decay_nrg,         0, sizeof(ps-&gt;peak_decay_nrg));
+        memset(ps-&gt;power_smooth,           0, sizeof(ps-&gt;power_smooth));
+        memset(ps-&gt;peak_decay_diff_smooth, 0, sizeof(ps-&gt;peak_decay_diff_smooth));
+        memset(ps-&gt;delay,                  0, sizeof(ps-&gt;delay));
+        memset(ps-&gt;ap_delay,               0, sizeof(ps-&gt;ap_delay));
+    }
+
+    for (n = n0; n &lt; nL; n++) {
+        for (k = 0; k &lt; NR_BANDS[is34]; k++) {
+            int i = k_to_i[k];
+            power[i][n] += s[k][n][0] * s[k][n][0] + s[k][n][1] * s[k][n][1];
+        }
+    }
+
+    //Transient detection
+    for (i = 0; i &lt; NR_PAR_BANDS[is34]; i++) {
+        for (n = n0; n &lt; nL; n++) {
+            float decayed_peak = peak_decay_factor * peak_decay_nrg[i];
+            float denom;
+            peak_decay_nrg[i] = FFMAX(decayed_peak, power[i][n]);
+            power_smooth[i] += a_smooth * (power[i][n] - power_smooth[i]);
+            peak_decay_diff_smooth[i] += a_smooth * (peak_decay_nrg[i] - power[i][n] - peak_decay_diff_smooth[i]);
+            denom = transient_impact * peak_decay_diff_smooth[i];
+            transient_gain[i][n]   = (denom &gt; power_smooth[i]) ?
+                                         power_smooth[i] / denom : 1.0f;
+        }
+    }
+
+    //Decorrelation and transient reduction
+    //                         PS_AP_LINKS - 1
+    //                               -----
+    //                                | |  Q_fract_allpass[k][m]*z^-link_delay[m] - a[m]*g_decay_slope[k]
+    //H[k][z] = z^-2 * phi_fract[k] * | | ----------------------------------------------------------------
+    //                                | | 1 - a[m]*g_decay_slope[k]*Q_fract_allpass[k][m]*z^-link_delay[m]
+    //                               m = 0
+    //d[k][z] (out) = transient_gain_mapped[k][z] * H[k][z] * s[k][z]
+    for (k = 0; k &lt; NR_ALLPASS_BANDS[is34]; k++) {
+        int b = k_to_i[k];
+        float g_decay_slope = 1.f - DECAY_SLOPE * (k - DECAY_CUTOFF[is34]);
+        float ag[PS_AP_LINKS];
+        g_decay_slope = av_clipf(g_decay_slope, 0.f, 1.f);
+        memcpy(delay[k], delay[k]+nL, PS_MAX_DELAY*sizeof(delay[k][0]));
+        memcpy(delay[k]+PS_MAX_DELAY, s[k], numQMFSlots*sizeof(delay[k][0]));
+        for (m = 0; m &lt; PS_AP_LINKS; m++) {
+            memcpy(ap_delay[k][m],   ap_delay[k][m]+numQMFSlots,           5*sizeof(ap_delay[k][m][0]));
+            ag[m] = a[m] * g_decay_slope;
+        }
+        for (n = n0; n &lt; nL; n++) {
+            float in_re = delay[k][n+PS_MAX_DELAY-2][0] * phi_fract[is34][k][0] -
+                          delay[k][n+PS_MAX_DELAY-2][1] * phi_fract[is34][k][1];
+            float in_im = delay[k][n+PS_MAX_DELAY-2][0] * phi_fract[is34][k][1] +
+                          delay[k][n+PS_MAX_DELAY-2][1] * phi_fract[is34][k][0];
+            for (m = 0; m &lt; PS_AP_LINKS; m++) {
+                float a_re                = ag[m] * in_re;
+                float a_im                = ag[m] * in_im;
+                float link_delay_re       = ap_delay[k][m][n+5-link_delay[m]][0];
+                float link_delay_im       = ap_delay[k][m][n+5-link_delay[m]][1];
+                float fractional_delay_re = Q_fract_allpass[is34][k][m][0];
+                float fractional_delay_im = Q_fract_allpass[is34][k][m][1];
+                ap_delay[k][m][n+5][0] = in_re;
+                ap_delay[k][m][n+5][1] = in_im;
+                in_re = link_delay_re * fractional_delay_re - link_delay_im * fractional_delay_im - a_re;
+                in_im = link_delay_re * fractional_delay_im + link_delay_im * fractional_delay_re - a_im;
+                ap_delay[k][m][n+5][0] += ag[m] * in_re;
+                ap_delay[k][m][n+5][1] += ag[m] * in_im;
+            }
+            out[k][n][0] = transient_gain[b][n] * in_re;
+            out[k][n][1] = transient_gain[b][n] * in_im;
+        }
+    }
+    for (; k &lt; SHORT_DELAY_BAND[is34]; k++) {
+        memcpy(delay[k], delay[k]+nL, PS_MAX_DELAY*sizeof(delay[k][0]));
+        memcpy(delay[k]+PS_MAX_DELAY, s[k], numQMFSlots*sizeof(delay[k][0]));
+        for (n = n0; n &lt; nL; n++) {
+            //H = delay 14
+            out[k][n][0] = transient_gain[k_to_i[k]][n] * delay[k][n+PS_MAX_DELAY-14][0];
+            out[k][n][1] = transient_gain[k_to_i[k]][n] * delay[k][n+PS_MAX_DELAY-14][1];
+        }
+    }
+    for (; k &lt; NR_BANDS[is34]; k++) {
+        memcpy(delay[k], delay[k]+nL, PS_MAX_DELAY*sizeof(delay[k][0]));
+        memcpy(delay[k]+PS_MAX_DELAY, s[k], numQMFSlots*sizeof(delay[k][0]));
+        for (n = n0; n &lt; nL; n++) {
+            //H = delay 1
+            out[k][n][0] = transient_gain[k_to_i[k]][n] * delay[k][n+PS_MAX_DELAY-1][0];
+            out[k][n][1] = transient_gain[k_to_i[k]][n] * delay[k][n+PS_MAX_DELAY-1][1];
+        }
+    }
+}
+
+static void remap34(int8_t (**p_par_mapped)[PS_MAX_NR_IIDICC],
+                    int8_t           (*par)[PS_MAX_NR_IIDICC],
+                    int num_par, int num_env, int full)
+{
+    int8_t (*par_mapped)[PS_MAX_NR_IIDICC] = *p_par_mapped;
+    int e;
+    if (num_par == 20 || num_par == 11) {
+        for (e = 0; e &lt; num_env; e++) {
+            map_idx_20_to_34(par_mapped[e], par[e], full);
+        }
+    } else if (num_par == 10 || num_par == 5) {
+        for (e = 0; e &lt; num_env; e++) {
+            map_idx_10_to_34(par_mapped[e], par[e], full);
+        }
+    } else {
+        *p_par_mapped = par;
+    }
+}
+
+static void remap20(int8_t (**p_par_mapped)[PS_MAX_NR_IIDICC],
+                    int8_t           (*par)[PS_MAX_NR_IIDICC],
+                    int num_par, int num_env, int full)
+{
+    int8_t (*par_mapped)[PS_MAX_NR_IIDICC] = *p_par_mapped;
+    int e;
+    if (num_par == 34 || num_par == 17) {
+        for (e = 0; e &lt; num_env; e++) {
+            map_idx_34_to_20(par_mapped[e], par[e], full);
+        }
+    } else if (num_par == 10 || num_par == 5) {
+        for (e = 0; e &lt; num_env; e++) {
+            map_idx_10_to_20(par_mapped[e], par[e], full);
+        }
+    } else {
+        *p_par_mapped = par;
+    }
+}
+
+static void stereo_processing(PSContext *ps, float (*l)[32][2], float (*r)[32][2], int is34)
+{
+    int e, b, k, n;
+
+    float (*H11)[PS_MAX_NUM_ENV+1][PS_MAX_NR_IIDICC] = ps-&gt;H11;
+    float (*H12)[PS_MAX_NUM_ENV+1][PS_MAX_NR_IIDICC] = ps-&gt;H12;
+    float (*H21)[PS_MAX_NUM_ENV+1][PS_MAX_NR_IIDICC] = ps-&gt;H21;
+    float (*H22)[PS_MAX_NUM_ENV+1][PS_MAX_NR_IIDICC] = ps-&gt;H22;
+    int8_t *opd_hist = ps-&gt;opd_hist;
+    int8_t *ipd_hist = ps-&gt;ipd_hist;
+    int8_t iid_mapped_buf[PS_MAX_NUM_ENV][PS_MAX_NR_IIDICC];
+    int8_t icc_mapped_buf[PS_MAX_NUM_ENV][PS_MAX_NR_IIDICC];
+    int8_t ipd_mapped_buf[PS_MAX_NUM_ENV][PS_MAX_NR_IIDICC];
+    int8_t opd_mapped_buf[PS_MAX_NUM_ENV][PS_MAX_NR_IIDICC];
+    int8_t (*iid_mapped)[PS_MAX_NR_IIDICC] = iid_mapped_buf;
+    int8_t (*icc_mapped)[PS_MAX_NR_IIDICC] = icc_mapped_buf;
+    int8_t (*ipd_mapped)[PS_MAX_NR_IIDICC] = ipd_mapped_buf;
+    int8_t (*opd_mapped)[PS_MAX_NR_IIDICC] = opd_mapped_buf;
+    const int8_t *k_to_i = is34 ? k_to_i_34 : k_to_i_20;
+    const float (*H_LUT)[8][4] = (PS_BASELINE || ps-&gt;icc_mode &lt; 3) ? HA : HB;
+
+    //Remapping
+    memcpy(H11[0][0], H11[0][ps-&gt;num_env_old], PS_MAX_NR_IIDICC*sizeof(H11[0][0][0]));
+    memcpy(H11[1][0], H11[1][ps-&gt;num_env_old], PS_MAX_NR_IIDICC*sizeof(H11[1][0][0]));
+    memcpy(H12[0][0], H12[0][ps-&gt;num_env_old], PS_MAX_NR_IIDICC*sizeof(H12[0][0][0]));
+    memcpy(H12[1][0], H12[1][ps-&gt;num_env_old], PS_MAX_NR_IIDICC*sizeof(H12[1][0][0]));
+    memcpy(H21[0][0], H21[0][ps-&gt;num_env_old], PS_MAX_NR_IIDICC*sizeof(H21[0][0][0]));
+    memcpy(H21[1][0], H21[1][ps-&gt;num_env_old], PS_MAX_NR_IIDICC*sizeof(H21[1][0][0]));
+    memcpy(H22[0][0], H22[0][ps-&gt;num_env_old], PS_MAX_NR_IIDICC*sizeof(H22[0][0][0]));
+    memcpy(H22[1][0], H22[1][ps-&gt;num_env_old], PS_MAX_NR_IIDICC*sizeof(H22[1][0][0]));
+    if (is34) {
+        remap34(&amp;iid_mapped, ps-&gt;iid_par, ps-&gt;nr_iid_par, ps-&gt;num_env, 1);
+        remap34(&amp;icc_mapped, ps-&gt;icc_par, ps-&gt;nr_icc_par, ps-&gt;num_env, 1);
+        if (ps-&gt;enable_ipdopd) {
+            remap34(&amp;ipd_mapped, ps-&gt;ipd_par, ps-&gt;nr_ipdopd_par, ps-&gt;num_env, 0);
+            remap34(&amp;opd_mapped, ps-&gt;opd_par, ps-&gt;nr_ipdopd_par, ps-&gt;num_env, 0);
+        }
+        if (!ps-&gt;is34bands_old) {
+            map_val_20_to_34(H11[0][0]);
+            map_val_20_to_34(H11[1][0]);
+            map_val_20_to_34(H12[0][0]);
+            map_val_20_to_34(H12[1][0]);
+            map_val_20_to_34(H21[0][0]);
+            map_val_20_to_34(H21[1][0]);
+            map_val_20_to_34(H22[0][0]);
+            map_val_20_to_34(H22[1][0]);
+            ipdopd_reset(ipd_hist, opd_hist);
+        }
+    } else {
+        remap20(&amp;iid_mapped, ps-&gt;iid_par, ps-&gt;nr_iid_par, ps-&gt;num_env, 1);
+        remap20(&amp;icc_mapped, ps-&gt;icc_par, ps-&gt;nr_icc_par, ps-&gt;num_env, 1);
+        if (ps-&gt;enable_ipdopd) {
+            remap20(&amp;ipd_mapped, ps-&gt;ipd_par, ps-&gt;nr_ipdopd_par, ps-&gt;num_env, 0);
+            remap20(&amp;opd_mapped, ps-&gt;opd_par, ps-&gt;nr_ipdopd_par, ps-&gt;num_env, 0);
+        }
+        if (ps-&gt;is34bands_old) {
+            map_val_34_to_20(H11[0][0]);
+            map_val_34_to_20(H11[1][0]);
+            map_val_34_to_20(H12[0][0]);
+            map_val_34_to_20(H12[1][0]);
+            map_val_34_to_20(H21[0][0]);
+            map_val_34_to_20(H21[1][0]);
+            map_val_34_to_20(H22[0][0]);
+            map_val_34_to_20(H22[1][0]);
+            ipdopd_reset(ipd_hist, opd_hist);
+        }
+    }
+
+    //Mixing
+    for (e = 0; e &lt; ps-&gt;num_env; e++) {
+        for (b = 0; b &lt; NR_PAR_BANDS[is34]; b++) {
+            float h11, h12, h21, h22;
+            h11 = H_LUT[iid_mapped[e][b] + 7 + 23 * ps-&gt;iid_quant][icc_mapped[e][b]][0];
+            h12 = H_LUT[iid_mapped[e][b] + 7 + 23 * ps-&gt;iid_quant][icc_mapped[e][b]][1];
+            h21 = H_LUT[iid_mapped[e][b] + 7 + 23 * ps-&gt;iid_quant][icc_mapped[e][b]][2];
+            h22 = H_LUT[iid_mapped[e][b] + 7 + 23 * ps-&gt;iid_quant][icc_mapped[e][b]][3];
+            if (!PS_BASELINE &amp;&amp; ps-&gt;enable_ipdopd &amp;&amp; b &lt; ps-&gt;nr_ipdopd_par) {
+                //The spec say says to only run this smoother when enable_ipdopd
+                //is set but the reference decoder appears to run it constantly
+                float h11i, h12i, h21i, h22i;
+                float ipd_adj_re, ipd_adj_im;
+                int opd_idx = opd_hist[b] * 8 + opd_mapped[e][b];
+                int ipd_idx = ipd_hist[b] * 8 + ipd_mapped[e][b];
+                float opd_re = pd_re_smooth[opd_idx];
+                float opd_im = pd_im_smooth[opd_idx];
+                float ipd_re = pd_re_smooth[ipd_idx];
+                float ipd_im = pd_im_smooth[ipd_idx];
+                opd_hist[b] = opd_idx &amp; 0x3F;
+                ipd_hist[b] = ipd_idx &amp; 0x3F;
+
+                ipd_adj_re = opd_re*ipd_re + opd_im*ipd_im;
+                ipd_adj_im = opd_im*ipd_re - opd_re*ipd_im;
+                h11i = h11 * opd_im;
+                h11  = h11 * opd_re;
+                h12i = h12 * ipd_adj_im;
+                h12  = h12 * ipd_adj_re;
+                h21i = h21 * opd_im;
+                h21  = h21 * opd_re;
+                h22i = h22 * ipd_adj_im;
+                h22  = h22 * ipd_adj_re;
+                H11[1][e+1][b] = h11i;
+                H12[1][e+1][b] = h12i;
+                H21[1][e+1][b] = h21i;
+                H22[1][e+1][b] = h22i;
+            }
+            H11[0][e+1][b] = h11;
+            H12[0][e+1][b] = h12;
+            H21[0][e+1][b] = h21;
+            H22[0][e+1][b] = h22;
+        }
+        for (k = 0; k &lt; NR_BANDS[is34]; k++) {
+            float h11r, h12r, h21r, h22r;
+            float h11i, h12i, h21i, h22i;
+            float h11r_step, h12r_step, h21r_step, h22r_step;
+            float h11i_step, h12i_step, h21i_step, h22i_step;
+            int start = ps-&gt;border_position[e];
+            int stop  = ps-&gt;border_position[e+1];
+            float width = 1.f / (stop - start);
+            b = k_to_i[k];
+            h11r = H11[0][e][b];
+            h12r = H12[0][e][b];
+            h21r = H21[0][e][b];
+            h22r = H22[0][e][b];
+            if (!PS_BASELINE &amp;&amp; ps-&gt;enable_ipdopd) {
+            //Is this necessary? ps_04_new seems unchanged
+            if ((is34 &amp;&amp; k &lt;= 13 &amp;&amp; k &gt;= 9) || (!is34 &amp;&amp; k &lt;= 1)) {
+                h11i = -H11[1][e][b];
+                h12i = -H12[1][e][b];
+                h21i = -H21[1][e][b];
+                h22i = -H22[1][e][b];
+            } else {
+                h11i = H11[1][e][b];
+                h12i = H12[1][e][b];
+                h21i = H21[1][e][b];
+                h22i = H22[1][e][b];
+            }
+            }
+            //Interpolation
+            h11r_step = (H11[0][e+1][b] - h11r) * width;
+            h12r_step = (H12[0][e+1][b] - h12r) * width;
+            h21r_step = (H21[0][e+1][b] - h21r) * width;
+            h22r_step = (H22[0][e+1][b] - h22r) * width;
+            if (!PS_BASELINE &amp;&amp; ps-&gt;enable_ipdopd) {
+                h11i_step = (H11[1][e+1][b] - h11i) * width;
+                h12i_step = (H12[1][e+1][b] - h12i) * width;
+                h21i_step = (H21[1][e+1][b] - h21i) * width;
+                h22i_step = (H22[1][e+1][b] - h22i) * width;
+            }
+            for (n = start + 1; n &lt;= stop; n++) {
+                //l is s, r is d
+                float l_re = l[k][n][0];
+                float l_im = l[k][n][1];
+                float r_re = r[k][n][0];
+                float r_im = r[k][n][1];
+                h11r += h11r_step;
+                h12r += h12r_step;
+                h21r += h21r_step;
+                h22r += h22r_step;
+                if (!PS_BASELINE &amp;&amp; ps-&gt;enable_ipdopd) {
+                    h11i += h11i_step;
+                    h12i += h12i_step;
+                    h21i += h21i_step;
+                    h22i += h22i_step;
+
+                    l[k][n][0] = h11r*l_re + h21r*r_re - h11i*l_im - h21i*r_im;
+                    l[k][n][1] = h11r*l_im + h21r*r_im + h11i*l_re + h21i*r_re;
+                    r[k][n][0] = h12r*l_re + h22r*r_re - h12i*l_im - h22i*r_im;
+                    r[k][n][1] = h12r*l_im + h22r*r_im + h12i*l_re + h22i*r_re;
+                } else {
+                    l[k][n][0] = h11r*l_re + h21r*r_re;
+                    l[k][n][1] = h11r*l_im + h21r*r_im;
+                    r[k][n][0] = h12r*l_re + h22r*r_re;
+                    r[k][n][1] = h12r*l_im + h22r*r_im;
+                }
+            }
+        }
+    }
+}
+
+int ff_ps_apply(AVCodecContext *avctx, PSContext *ps, float L[2][38][64], float R[2][38][64], int top)
+{
+    float Lbuf[91][32][2];
+    float Rbuf[91][32][2];
+    const int len = 32;
+    int is34 = ps-&gt;is34bands;
+
+    top += NR_BANDS[is34] - 64;
+    memset(ps-&gt;delay+top, 0, (NR_BANDS[is34] - top)*sizeof(ps-&gt;delay[0]));
+    if (top &lt; NR_ALLPASS_BANDS[is34])
+        memset(ps-&gt;ap_delay + top, 0, (NR_ALLPASS_BANDS[is34] - top)*sizeof(ps-&gt;ap_delay[0]));
+
+    hybrid_analysis(Lbuf, ps-&gt;in_buf, L, is34, len);
+    decorrelation(ps, Rbuf, Lbuf, is34);
+    stereo_processing(ps, Lbuf, Rbuf, is34);
+    hybrid_synthesis(L, Lbuf, is34, len);
+    hybrid_synthesis(R, Rbuf, is34, len);
+
+    return 0;
+}
+
+#define PS_INIT_VLC_STATIC(num, size) \
+    INIT_VLC_STATIC(&amp;vlc_ps[num], 9, ps_tmp[num].table_size / ps_tmp[num].elem_size,    \
+                    ps_tmp[num].ps_bits, 1, 1,                                          \
+                    ps_tmp[num].ps_codes, ps_tmp[num].elem_size, ps_tmp[num].elem_size, \
+                    size);
+
+#define PS_VLC_ROW(name) \
+    { name ## _codes, name ## _bits, sizeof(name ## _codes), sizeof(name ## _codes[0]) }
+
+av_cold void ff_ps_init(void) {
+    // Syntax initialization
+    static const struct {
+        const void *ps_codes, *ps_bits;
+        const unsigned int table_size, elem_size;
+    } ps_tmp[] = {
+        PS_VLC_ROW(huff_iid_df1),
+        PS_VLC_ROW(huff_iid_dt1),
+        PS_VLC_ROW(huff_iid_df0),
+        PS_VLC_ROW(huff_iid_dt0),
+        PS_VLC_ROW(huff_icc_df),
+        PS_VLC_ROW(huff_icc_dt),
+        PS_VLC_ROW(huff_ipd_df),
+        PS_VLC_ROW(huff_ipd_dt),
+        PS_VLC_ROW(huff_opd_df),
+        PS_VLC_ROW(huff_opd_dt),
+    };
+
+    PS_INIT_VLC_STATIC(0, 1544);
+    PS_INIT_VLC_STATIC(1,  832);
+    PS_INIT_VLC_STATIC(2, 1024);
+    PS_INIT_VLC_STATIC(3, 1036);
+    PS_INIT_VLC_STATIC(4,  544);
+    PS_INIT_VLC_STATIC(5,  544);
+    PS_INIT_VLC_STATIC(6,  512);
+    PS_INIT_VLC_STATIC(7,  512);
+    PS_INIT_VLC_STATIC(8,  512);
+    PS_INIT_VLC_STATIC(9,  512);
+
+    ps_tableinit();
+}
+
+av_cold void ff_ps_ctx_init(PSContext *ps)
+{
+}

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aacps.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aacps.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aacps.h	2010-07-25 10:07:52 UTC (rev 6483)
@@ -0,0 +1,82 @@
+/*
+ * MPEG-4 Parametric Stereo definitions and declarations
+ * Copyright (c) 2010 Alex Converse &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">alex.converse at gmail.com</A>&gt;
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_PS_H
+#define AVCODEC_PS_H
+
+#include &lt;stdint.h&gt;
+
+#include &quot;avcodec.h&quot;
+#include &quot;get_bits.h&quot;
+
+#define PS_MAX_NUM_ENV 5
+#define PS_MAX_NR_IIDICC 34
+#define PS_MAX_NR_IPDOPD 17
+#define PS_MAX_SSB 91
+#define PS_MAX_AP_BANDS 50
+#define PS_QMF_TIME_SLOTS 32
+#define PS_MAX_DELAY 14
+#define PS_AP_LINKS 3
+#define PS_MAX_AP_DELAY 5
+
+typedef struct {
+    int    start;
+    int    enable_iid;
+    int    iid_quant;
+    int    nr_iid_par;
+    int    nr_ipdopd_par;
+    int    enable_icc;
+    int    icc_mode;
+    int    nr_icc_par;
+    int    enable_ext;
+    int    frame_class;
+    int    num_env_old;
+    int    num_env;
+    int    enable_ipdopd;
+    int    border_position[PS_MAX_NUM_ENV+1];
+    int8_t iid_par[PS_MAX_NUM_ENV][PS_MAX_NR_IIDICC]; //&lt;Inter-channel Intensity Difference Parameters
+    int8_t icc_par[PS_MAX_NUM_ENV][PS_MAX_NR_IIDICC]; //&lt;Inter-Channel Coherence Parameters
+    /* ipd/opd is iid/icc sized so that the same functions can handle both */
+    int8_t ipd_par[PS_MAX_NUM_ENV][PS_MAX_NR_IIDICC]; //&lt;Inter-channel Phase Difference Parameters
+    int8_t opd_par[PS_MAX_NUM_ENV][PS_MAX_NR_IIDICC]; //&lt;Overall Phase Difference Parameters
+    int    is34bands;
+    int    is34bands_old;
+
+    float  in_buf[5][44][2];
+    float  delay[PS_MAX_SSB][PS_QMF_TIME_SLOTS + PS_MAX_DELAY][2];
+    float  ap_delay[PS_MAX_AP_BANDS][PS_AP_LINKS][PS_QMF_TIME_SLOTS + PS_MAX_AP_DELAY][2];
+    float  peak_decay_nrg[34];
+    float  power_smooth[34];
+    float  peak_decay_diff_smooth[34];
+    float  H11[2][PS_MAX_NUM_ENV+1][PS_MAX_NR_IIDICC];
+    float  H12[2][PS_MAX_NUM_ENV+1][PS_MAX_NR_IIDICC];
+    float  H21[2][PS_MAX_NUM_ENV+1][PS_MAX_NR_IIDICC];
+    float  H22[2][PS_MAX_NUM_ENV+1][PS_MAX_NR_IIDICC];
+    int8_t opd_hist[PS_MAX_NR_IIDICC];
+    int8_t ipd_hist[PS_MAX_NR_IIDICC];
+} PSContext;
+
+void ff_ps_init(void);
+void ff_ps_ctx_init(PSContext *ps);
+int ff_ps_read_data(AVCodecContext *avctx, GetBitContext *gb, PSContext *ps, int bits_left);
+int ff_ps_apply(AVCodecContext *avctx, PSContext *ps, float L[2][38][64], float R[2][38][64], int top);
+
+#endif /* AVCODEC_PS_H */

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aacps_tablegen.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aacps_tablegen.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aacps_tablegen.c	2010-07-25 10:07:52 UTC (rev 6483)
@@ -0,0 +1,93 @@
+/*
+ * Generate a header file for hardcoded Parametric Stereo tables
+ *
+ * Copyright (c) 2010 Alex Converse &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">alex.converse at gmail.com</A>&gt;
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include &lt;stdlib.h&gt;
+#define CONFIG_HARDCODED_TABLES 0
+#include &quot;aacps_tablegen.h&quot;
+#include &quot;tableprint.h&quot;
+
+void write_float_3d_array (const void *p, int b, int c, int d)
+{
+    int i;
+    const float *f = p;
+    for (i = 0; i &lt; b; i++) {
+        printf(&quot;{\n&quot;);
+        write_float_2d_array(f, c, d);
+        printf(&quot;},\n&quot;);
+        f += c * d;
+    }
+}
+
+void write_float_4d_array (const void *p, int a, int b, int c, int d)
+{
+    int i;
+    const float *f = p;
+    for (i = 0; i &lt; a; i++) {
+        printf(&quot;{\n&quot;);
+        write_float_3d_array(f, b, c, d);
+        printf(&quot;},\n&quot;);
+        f += b * c * d;
+    }
+}
+
+int main(void)
+{
+    ps_tableinit();
+
+    write_fileheader();
+
+    printf(&quot;static const float pd_re_smooth[8*8*8] = {\n&quot;);
+    write_float_array(pd_re_smooth, 8*8*8);
+    printf(&quot;};\n&quot;);
+    printf(&quot;static const float pd_im_smooth[8*8*8] = {\n&quot;);
+    write_float_array(pd_im_smooth, 8*8*8);
+    printf(&quot;};\n&quot;);
+
+    printf(&quot;static const float HA[46][8][4] = {\n&quot;);
+    write_float_3d_array(HA, 46, 8, 4);
+    printf(&quot;};\n&quot;);
+    printf(&quot;static const float HB[46][8][4] = {\n&quot;);
+    write_float_3d_array(HB, 46, 8, 4);
+    printf(&quot;};\n&quot;);
+
+    printf(&quot;static const float f20_0_8[8][7][2] = {\n&quot;);
+    write_float_3d_array(f20_0_8, 8, 7, 2);
+    printf(&quot;};\n&quot;);
+    printf(&quot;static const float f34_0_12[12][7][2] = {\n&quot;);
+    write_float_3d_array(f34_0_12, 12, 7, 2);
+    printf(&quot;};\n&quot;);
+    printf(&quot;static const float f34_1_8[8][7][2] = {\n&quot;);
+    write_float_3d_array(f34_1_8, 8, 7, 2);
+    printf(&quot;};\n&quot;);
+    printf(&quot;static const float f34_2_4[4][7][2] = {\n&quot;);
+    write_float_3d_array(f34_2_4, 4, 7, 2);
+    printf(&quot;};\n&quot;);
+
+    printf(&quot;static const float Q_fract_allpass[2][50][3][2] = {\n&quot;);
+    write_float_4d_array(Q_fract_allpass, 2, 50, 3, 2);
+    printf(&quot;};\n&quot;);
+    printf(&quot;static const float phi_fract[2][50][2] = {\n&quot;);
+    write_float_3d_array(phi_fract, 2, 50, 2);
+    printf(&quot;};\n&quot;);
+
+    return 0;
+}

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aacps_tablegen.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aacps_tablegen.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aacps_tablegen.h	2010-07-25 10:07:52 UTC (rev 6483)
@@ -0,0 +1,212 @@
+/*
+ * Header file for hardcoded Parametric Stereo tables
+ *
+ * Copyright (c) 2010 Alex Converse &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">alex.converse at gmail.com</A>&gt;
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AACPS_TABLEGEN_H
+#define AACPS_TABLEGEN_H
+
+#include &lt;stdint.h&gt;
+
+#if CONFIG_HARDCODED_TABLES
+#define ps_tableinit()
+#include &quot;libavcodec/aacps_tables.h&quot;
+#else
+#include &quot;libavutil/common.h&quot;
+#include &quot;libavutil/mathematics.h&quot;
+#define NR_ALLPASS_BANDS20 30
+#define NR_ALLPASS_BANDS34 50
+#define PS_AP_LINKS 3
+static float pd_re_smooth[8*8*8];
+static float pd_im_smooth[8*8*8];
+static float HA[46][8][4];
+static float HB[46][8][4];
+static float f20_0_8 [ 8][7][2];
+static float f34_0_12[12][7][2];
+static float f34_1_8 [ 8][7][2];
+static float f34_2_4 [ 4][7][2];
+static float Q_fract_allpass[2][50][3][2];
+static float phi_fract[2][50][2];
+
+static const float g0_Q8[] = {
+    0.00746082949812f, 0.02270420949825f, 0.04546865930473f, 0.07266113929591f,
+    0.09885108575264f, 0.11793710567217f, 0.125f
+};
+
+static const float g0_Q12[] = {
+    0.04081179924692f, 0.03812810994926f, 0.05144908135699f, 0.06399831151592f,
+    0.07428313801106f, 0.08100347892914f, 0.08333333333333f
+};
+
+static const float g1_Q8[] = {
+    0.01565675600122f, 0.03752716391991f, 0.05417891378782f, 0.08417044116767f,
+    0.10307344158036f, 0.12222452249753f, 0.125f
+};
+
+static const float g2_Q4[] = {
+    -0.05908211155639f, -0.04871498374946f, 0.0f,   0.07778723915851f,
+     0.16486303567403f,  0.23279856662996f, 0.25f
+};
+
+static void make_filters_from_proto(float (*filter)[7][2], const float *proto, int bands)
+{
+    int q, n;
+    for (q = 0; q &lt; bands; q++) {
+        for (n = 0; n &lt; 7; n++) {
+            double theta = 2 * M_PI * (q + 0.5) * (n - 6) / bands;
+            filter[q][n][0] = proto[n] *  cos(theta);
+            filter[q][n][1] = proto[n] * -sin(theta);
+        }
+    }
+}
+
+static void ps_tableinit(void)
+{
+    static const float ipdopd_sin[] = { 0, M_SQRT1_2, 1,  M_SQRT1_2,  0, -M_SQRT1_2, -1, -M_SQRT1_2 };
+    static const float ipdopd_cos[] = { 1, M_SQRT1_2, 0, -M_SQRT1_2, -1, -M_SQRT1_2,  0,  M_SQRT1_2 };
+    int pd0, pd1, pd2;
+
+    static const float iid_par_dequant[] = {
+        //iid_par_dequant_default
+        0.05623413251903, 0.12589254117942, 0.19952623149689, 0.31622776601684,
+        0.44668359215096, 0.63095734448019, 0.79432823472428, 1,
+        1.25892541179417, 1.58489319246111, 2.23872113856834, 3.16227766016838,
+        5.01187233627272, 7.94328234724282, 17.7827941003892,
+        //iid_par_dequant_fine
+        0.00316227766017, 0.00562341325190, 0.01,             0.01778279410039,
+        0.03162277660168, 0.05623413251903, 0.07943282347243, 0.11220184543020,
+        0.15848931924611, 0.22387211385683, 0.31622776601684, 0.39810717055350,
+        0.50118723362727, 0.63095734448019, 0.79432823472428, 1,
+        1.25892541179417, 1.58489319246111, 1.99526231496888, 2.51188643150958,
+        3.16227766016838, 4.46683592150963, 6.30957344480193, 8.91250938133745,
+        12.5892541179417, 17.7827941003892, 31.6227766016838, 56.2341325190349,
+        100,              177.827941003892, 316.227766016837,
+    };
+    static const float icc_invq[] = {
+        1, 0.937,      0.84118,    0.60092,    0.36764,   0,      -0.589,    -1
+    };
+    static const float acos_icc_invq[] = {
+        0, 0.35685527, 0.57133466, 0.92614472, 1.1943263, M_PI/2, 2.2006171, M_PI
+    };
+    int iid, icc;
+
+    int k, m;
+    static const int8_t f_center_20[] = {
+        -3, -1, 1, 3, 5, 7, 10, 14, 18, 22,
+    };
+    static const int8_t f_center_34[] = {
+         2,  6, 10, 14, 18, 22, 26, 30,
+        34,-10, -6, -2, 51, 57, 15, 21,
+        27, 33, 39, 45, 54, 66, 78, 42,
+       102, 66, 78, 90,102,114,126, 90,
+    };
+    static const float fractional_delay_links[] = { 0.43f, 0.75f, 0.347f };
+    const float fractional_delay_gain = 0.39f;
+
+    for (pd0 = 0; pd0 &lt; 8; pd0++) {
+        float pd0_re = ipdopd_cos[pd0];
+        float pd0_im = ipdopd_sin[pd0];
+        for (pd1 = 0; pd1 &lt; 8; pd1++) {
+            float pd1_re = ipdopd_cos[pd1];
+            float pd1_im = ipdopd_sin[pd1];
+            for (pd2 = 0; pd2 &lt; 8; pd2++) {
+                float pd2_re = ipdopd_cos[pd2];
+                float pd2_im = ipdopd_sin[pd2];
+                float re_smooth = 0.25f * pd0_re + 0.5f * pd1_re + pd2_re;
+                float im_smooth = 0.25f * pd0_im + 0.5f * pd1_im + pd2_im;
+                float pd_mag = 1 / sqrt(im_smooth * im_smooth + re_smooth * re_smooth);
+                pd_re_smooth[pd0*64+pd1*8+pd2] = re_smooth * pd_mag;
+                pd_im_smooth[pd0*64+pd1*8+pd2] = im_smooth * pd_mag;
+            }
+        }
+    }
+
+    for (iid = 0; iid &lt; 46; iid++) {
+        float c = iid_par_dequant[iid]; //&lt;Linear Inter-channel Intensity Difference
+        float c1 = (float)M_SQRT2 / sqrtf(1.0f + c*c);
+        float c2 = c * c1;
+        for (icc = 0; icc &lt; 8; icc++) {
+            /*if (PS_BASELINE || ps-&gt;icc_mode &lt; 3)*/ {
+                float alpha = 0.5f * acos_icc_invq[icc];
+                float beta  = alpha * (c1 - c2) * (float)M_SQRT1_2;
+                HA[iid][icc][0] = c2 * cosf(beta + alpha);
+                HA[iid][icc][1] = c1 * cosf(beta - alpha);
+                HA[iid][icc][2] = c2 * sinf(beta + alpha);
+                HA[iid][icc][3] = c1 * sinf(beta - alpha);
+            } /* else */ {
+                float alpha, gamma, mu, rho;
+                float alpha_c, alpha_s, gamma_c, gamma_s;
+                rho = FFMAX(icc_invq[icc], 0.05f);
+                alpha = 0.5f * atan2f(2.0f * c * rho, c*c - 1.0f);
+                mu = c + 1.0f / c;
+                mu = sqrtf(1 + (4 * rho * rho - 4)/(mu * mu));
+                gamma = atanf(sqrtf((1.0f - mu)/(1.0f + mu)));
+                if (alpha &lt; 0) alpha += M_PI/2;
+                alpha_c = cosf(alpha);
+                alpha_s = sinf(alpha);
+                gamma_c = cosf(gamma);
+                gamma_s = sinf(gamma);
+                HB[iid][icc][0] =  M_SQRT2 * alpha_c * gamma_c;
+                HB[iid][icc][1] =  M_SQRT2 * alpha_s * gamma_c;
+                HB[iid][icc][2] = -M_SQRT2 * alpha_s * gamma_s;
+                HB[iid][icc][3] =  M_SQRT2 * alpha_c * gamma_s;
+            }
+        }
+    }
+
+    for (k = 0; k &lt; NR_ALLPASS_BANDS20; k++) {
+        double f_center, theta;
+        if (k &lt; FF_ARRAY_ELEMS(f_center_20))
+            f_center = f_center_20[k] * 0.125;
+        else
+            f_center = k - 6.5f;
+        for (m = 0; m &lt; PS_AP_LINKS; m++) {
+            theta = -M_PI * fractional_delay_links[m] * f_center;
+            Q_fract_allpass[0][k][m][0] = cos(theta);
+            Q_fract_allpass[0][k][m][1] = sin(theta);
+        }
+        theta = -M_PI*fractional_delay_gain*f_center;
+        phi_fract[0][k][0] = cos(theta);
+        phi_fract[0][k][1] = sin(theta);
+    }
+    for (k = 0; k &lt; NR_ALLPASS_BANDS34; k++) {
+        double f_center, theta;
+        if (k &lt; FF_ARRAY_ELEMS(f_center_34))
+            f_center = f_center_34[k] / 24.;
+        else
+            f_center = k - 26.5f;
+        for (m = 0; m &lt; PS_AP_LINKS; m++) {
+            theta = -M_PI * fractional_delay_links[m] * f_center;
+            Q_fract_allpass[1][k][m][0] = cos(theta);
+            Q_fract_allpass[1][k][m][1] = sin(theta);
+        }
+        theta = -M_PI*fractional_delay_gain*f_center;
+        phi_fract[1][k][0] = cos(theta);
+        phi_fract[1][k][1] = sin(theta);
+    }
+
+    make_filters_from_proto(f20_0_8,  g0_Q8,   8);
+    make_filters_from_proto(f34_0_12, g0_Q12, 12);
+    make_filters_from_proto(f34_1_8,  g1_Q8,   8);
+    make_filters_from_proto(f34_2_4,  g2_Q4,   4);
+}
+#endif /* CONFIG_HARDCODED_TABLES */
+
+#endif /* AACPS_TABLEGEN_H */

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aacpsdata.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aacpsdata.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aacpsdata.c	2010-07-25 10:07:52 UTC (rev 6483)
@@ -0,0 +1,163 @@
+/*
+ * MPEG-4 Parametric Stereo data tables
+ * Copyright (c) 2010 Alex Converse &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">alex.converse at gmail.com</A>&gt;
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+static const uint8_t huff_iid_df1_bits[] = {
+    18, 18, 18, 18, 18, 18, 18, 18, 18, 17, 18, 17, 17, 16, 16, 15, 14, 14,
+    13, 12, 12, 11, 10, 10,  8,  7,  6,  5,  4,  3,  1,  3,  4,  5,  6,  7,
+     8,  9, 10, 11, 11, 12, 13, 14, 14, 15, 16, 16, 17, 17, 18, 17, 18, 18,
+    18, 18, 18, 18, 18, 18, 18,
+};
+
+static const uint32_t huff_iid_df1_codes[] = {
+    0x01FEB4, 0x01FEB5, 0x01FD76, 0x01FD77, 0x01FD74, 0x01FD75, 0x01FE8A,
+    0x01FE8B, 0x01FE88, 0x00FE80, 0x01FEB6, 0x00FE82, 0x00FEB8, 0x007F42,
+    0x007FAE, 0x003FAF, 0x001FD1, 0x001FE9, 0x000FE9, 0x0007EA, 0x0007FB,
+    0x0003FB, 0x0001FB, 0x0001FF, 0x00007C, 0x00003C, 0x00001C, 0x00000C,
+    0x000000, 0x000001, 0x000001, 0x000002, 0x000001, 0x00000D, 0x00001D,
+    0x00003D, 0x00007D, 0x0000FC, 0x0001FC, 0x0003FC, 0x0003F4, 0x0007EB,
+    0x000FEA, 0x001FEA, 0x001FD6, 0x003FD0, 0x007FAF, 0x007F43, 0x00FEB9,
+    0x00FE83, 0x01FEB7, 0x00FE81, 0x01FE89, 0x01FE8E, 0x01FE8F, 0x01FE8C,
+    0x01FE8D, 0x01FEB2, 0x01FEB3, 0x01FEB0, 0x01FEB1,
+};
+
+static const uint8_t huff_iid_dt1_bits[] = {
+    16, 16, 16, 16, 16, 16, 16, 16, 16, 15, 15, 15, 15, 15, 15, 14, 14, 13,
+    13, 13, 12, 12, 11, 10,  9,  9,  7,  6,  5,  3,  1,  2,  5,  6,  7,  8,
+     9, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16,
+    16, 16, 16, 16, 16, 16, 16,
+};
+
+static const uint16_t huff_iid_dt1_codes[] = {
+    0x004ED4, 0x004ED5, 0x004ECE, 0x004ECF, 0x004ECC, 0x004ED6, 0x004ED8,
+    0x004F46, 0x004F60, 0x002718, 0x002719, 0x002764, 0x002765, 0x00276D,
+    0x0027B1, 0x0013B7, 0x0013D6, 0x0009C7, 0x0009E9, 0x0009ED, 0x0004EE,
+    0x0004F7, 0x000278, 0x000139, 0x00009A, 0x00009F, 0x000020, 0x000011,
+    0x00000A, 0x000003, 0x000001, 0x000000, 0x00000B, 0x000012, 0x000021,
+    0x00004C, 0x00009B, 0x00013A, 0x000279, 0x000270, 0x0004EF, 0x0004E2,
+    0x0009EA, 0x0009D8, 0x0013D7, 0x0013D0, 0x0027B2, 0x0027A2, 0x00271A,
+    0x00271B, 0x004F66, 0x004F67, 0x004F61, 0x004F47, 0x004ED9, 0x004ED7,
+    0x004ECD, 0x004ED2, 0x004ED3, 0x004ED0, 0x004ED1,
+};
+
+static const uint8_t huff_iid_df0_bits[] = {
+    17, 17, 17, 17, 16, 15, 13, 10,  9,  7,  6,  5,  4,  3,  1,  3,  4,  5,
+     6,  6,  8, 11, 13, 14, 14, 15, 17, 18, 18,
+};
+
+static const uint32_t huff_iid_df0_codes[] = {
+    0x01FFFB, 0x01FFFC, 0x01FFFD, 0x01FFFA, 0x00FFFC, 0x007FFC, 0x001FFD,
+    0x0003FE, 0x0001FE, 0x00007E, 0x00003C, 0x00001D, 0x00000D, 0x000005,
+    0x000000, 0x000004, 0x00000C, 0x00001C, 0x00003D, 0x00003E, 0x0000FE,
+    0x0007FE, 0x001FFC, 0x003FFC, 0x003FFD, 0x007FFD, 0x01FFFE, 0x03FFFE,
+    0x03FFFF,
+};
+
+static const uint8_t huff_iid_dt0_bits[] = {
+    19, 19, 19, 20, 20, 20, 17, 15, 12, 10,  8,  6,  4,  2,  1,  3,  5,  7,
+     9, 11, 13, 14, 17, 19, 20, 20, 20, 20, 20,
+};
+
+static const uint32_t huff_iid_dt0_codes[] = {
+    0x07FFF9, 0x07FFFA, 0x07FFFB, 0x0FFFF8, 0x0FFFF9, 0x0FFFFA, 0x01FFFD,
+    0x007FFE, 0x000FFE, 0x0003FE, 0x0000FE, 0x00003E, 0x00000E, 0x000002,
+    0x000000, 0x000006, 0x00001E, 0x00007E, 0x0001FE, 0x0007FE, 0x001FFE,
+    0x003FFE, 0x01FFFC, 0x07FFF8, 0x0FFFFB, 0x0FFFFC, 0x0FFFFD, 0x0FFFFE,
+    0x0FFFFF,
+};
+
+static const uint8_t huff_icc_df_bits[] = {
+    14, 14, 12, 10, 7, 5, 3, 1, 2, 4, 6, 8, 9, 11, 13,
+};
+
+static const uint16_t huff_icc_df_codes[] = {
+    0x3FFF, 0x3FFE, 0x0FFE, 0x03FE, 0x007E, 0x001E, 0x0006, 0x0000,
+    0x0002, 0x000E, 0x003E, 0x00FE, 0x01FE, 0x07FE, 0x1FFE,
+};
+
+static const uint8_t huff_icc_dt_bits[] = {
+    14, 13, 11, 9, 7, 5, 3, 1, 2, 4, 6, 8, 10, 12, 14,
+};
+
+static const uint16_t huff_icc_dt_codes[] = {
+    0x3FFE, 0x1FFE, 0x07FE, 0x01FE, 0x007E, 0x001E, 0x0006, 0x0000,
+    0x0002, 0x000E, 0x003E, 0x00FE, 0x03FE, 0x0FFE, 0x3FFF,
+};
+
+static const uint8_t huff_ipd_df_bits[] = {
+    1, 3, 4, 4, 4, 4, 4, 4,
+};
+
+static const uint8_t huff_ipd_df_codes[] = {
+    0x01, 0x00, 0x06, 0x04, 0x02, 0x03, 0x05, 0x07,
+};
+
+static const uint8_t huff_ipd_dt_bits[] = {
+    1, 3, 4, 5, 5, 4, 4, 3,
+};
+
+static const uint8_t huff_ipd_dt_codes[] = {
+    0x01, 0x02, 0x02, 0x03, 0x02, 0x00, 0x03, 0x03,
+};
+
+static const uint8_t huff_opd_df_bits[] = {
+    1, 3, 4, 4, 5, 5, 4, 3,
+};
+
+static const uint8_t huff_opd_df_codes[] = {
+    0x01, 0x01, 0x06, 0x04, 0x0F, 0x0E, 0x05, 0x00,
+};
+
+static const uint8_t huff_opd_dt_bits[] = {
+    1, 3, 4, 5, 5, 4, 4, 3,
+};
+
+static const uint8_t huff_opd_dt_codes[] = {
+    0x01, 0x02, 0x01, 0x07, 0x06, 0x00, 0x02, 0x03,
+};
+
+static const int8_t huff_offset[] = {
+    30, 30,
+    14, 14,
+    7, 7,
+    0, 0,
+    0, 0,
+};
+
+///Table 8.48
+static const int8_t k_to_i_20[] = {
+     1,  0,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 14, 15,
+    15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18,
+    18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
+    19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19
+};
+///Table 8.49
+static const int8_t k_to_i_34[] = {
+     0,  1,  2,  3,  4,  5,  6,  6,  7,  2,  1,  0, 10, 10,  4,  5,  6,  7,  8,
+     9, 10, 11, 12,  9, 14, 11, 12, 13, 14, 15, 16, 13, 16, 17, 18, 19, 20, 21,
+    22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 27, 28, 28, 28, 29, 29, 29,
+    30, 30, 30, 31, 31, 31, 31, 32, 32, 32, 32, 33, 33, 33, 33, 33, 33, 33, 33,
+    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33
+};
+
+static const float g1_Q2[] = {
+    0.0f,  0.01899487526049f, 0.0f, -0.07293139167538f,
+    0.0f,  0.30596630545168f, 0.5f
+};

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/ansi.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/ansi.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/ansi.c	2010-07-25 10:07:52 UTC (rev 6483)
@@ -0,0 +1,432 @@
+/*
+ * ASCII/ANSI art decoder
+ * Copyright (c) 2010 Peter Ross &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">pross at xvid.org</A>&gt;
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * ASCII/ANSI art decoder
+ */
+
+#include &quot;avcodec.h&quot;
+#include &quot;cga_data.h&quot;
+#include &lt;libavutil/lfg.h&gt;
+
+#define ATTR_BOLD         0x01  /** Bold/Bright-foreground (mode 1) */
+#define ATTR_FAINT        0x02  /** Faint (mode 2) */
+#define ATTR_UNDERLINE    0x08  /** Underline (mode 4) */
+#define ATTR_BLINK        0x10  /** Blink/Bright-background (mode 5) */
+#define ATTR_REVERSE      0x40  /** Reverse (mode 7) */
+#define ATTR_CONCEALED    0x80  /** Concealed (mode 8) */
+
+#define DEFAULT_FG_COLOR     7  /** CGA color index */
+#define DEFAULT_BG_COLOR     0
+#define DEFAULT_SCREEN_MODE  3  /** 80x25 */
+
+#define FONT_WIDTH           8  /** Font width */
+
+/** map ansi color index to cga palette index */
+static const uint8_t ansi_to_cga[16] = {
+    0,  4,  2,  6,  1,  5,  3, 7, 8, 12, 10, 14,  9, 13, 11, 15
+};
+
+typedef struct {
+    AVFrame frame;
+    int x, y;             /** cursor position (pixels) */
+    int sx, sy;           /** saved cursor position (pixels) */
+    const uint8_t* font;  /** font */
+    int font_height;      /** font height */
+    int attributes;       /** attribute flags */
+    int fg, bg;           /** foreground and background color */
+
+    /* ansi parser state machine */
+    enum {
+        STATE_NORMAL = 0,
+        STATE_ESCAPE,
+        STATE_CODE,
+        STATE_MUSIC_PREAMBLE
+    } state;
+#define MAX_NB_ARGS 4
+    int args[MAX_NB_ARGS];
+    int nb_args;          /** number of arguments (may exceed MAX_NB_ARGS) */
+} AnsiContext;
+
+static av_cold int decode_init(AVCodecContext *avctx)
+{
+    AnsiContext *s = avctx-&gt;priv_data;
+    avctx-&gt;pix_fmt = PIX_FMT_PAL8;
+
+    /* defaults */
+    s-&gt;font        = ff_vga16_font;
+    s-&gt;font_height = 16;
+    s-&gt;fg          = DEFAULT_FG_COLOR;
+    s-&gt;bg          = DEFAULT_BG_COLOR;
+
+    if (!avctx-&gt;width || !avctx-&gt;height)
+        avcodec_set_dimensions(avctx, 80&lt;&lt;3, 25&lt;&lt;4);
+
+    return 0;
+}
+
+static void hscroll(AVCodecContext *avctx)
+{
+    AnsiContext *s = avctx-&gt;priv_data;
+    int i;
+
+    if (s-&gt;y &lt; avctx-&gt;height - s-&gt;font_height) {
+        s-&gt;y += s-&gt;font_height;
+        return;
+    }
+
+    i = 0;
+    for (; i &lt; avctx-&gt;height - s-&gt;font_height; i++)
+        memcpy(s-&gt;frame.data[0] + i * s-&gt;frame.linesize[0],
+               s-&gt;frame.data[0] + (i + s-&gt;font_height) * s-&gt;frame.linesize[0],
+               avctx-&gt;width);
+    for (; i &lt; avctx-&gt;height; i++)
+        memset(s-&gt;frame.data[0] + i * s-&gt;frame.linesize[0],
+            DEFAULT_BG_COLOR, avctx-&gt;width);
+}
+
+static void erase_line(AVCodecContext * avctx, int xoffset, int xlength)
+{
+    AnsiContext *s = avctx-&gt;priv_data;
+    int i;
+    for (i = 0; i &lt; s-&gt;font_height; i++)
+        memset(s-&gt;frame.data[0] + (s-&gt;y + i)*s-&gt;frame.linesize[0] + xoffset,
+            DEFAULT_BG_COLOR, xlength);
+}
+
+static void erase_screen(AVCodecContext *avctx)
+{
+    AnsiContext *s = avctx-&gt;priv_data;
+    int i;
+    for (i = 0; i &lt; avctx-&gt;height; i++)
+        memset(s-&gt;frame.data[0] + i * s-&gt;frame.linesize[0], DEFAULT_BG_COLOR, avctx-&gt;width);
+    s-&gt;x = s-&gt;y = 0;
+}
+
+/**
+ * Draw character to screen
+ */
+static void draw_char(AVCodecContext *avctx, int c)
+{
+    AnsiContext *s = avctx-&gt;priv_data;
+    int fg = s-&gt;fg;
+    int bg = s-&gt;bg;
+
+    if ((s-&gt;attributes &amp; ATTR_BOLD))
+        fg += 8;
+    if ((s-&gt;attributes &amp; ATTR_BLINK))
+        bg += 8;
+    if ((s-&gt;attributes &amp; ATTR_REVERSE))
+        FFSWAP(int, fg, bg);
+    if ((s-&gt;attributes &amp; ATTR_CONCEALED))
+        fg = bg;
+    ff_draw_pc_font(s-&gt;frame.data[0] + s-&gt;y * s-&gt;frame.linesize[0] + s-&gt;x,
+                    s-&gt;frame.linesize[0], s-&gt;font, s-&gt;font_height, c, fg, bg);
+    s-&gt;x += FONT_WIDTH;
+    if (s-&gt;x &gt;= avctx-&gt;width) {
+        s-&gt;x = 0;
+        hscroll(avctx);
+    }
+}
+
+/**
+ * Execute ANSI escape code
+ * @param &lt;0 error
+ */
+static int execute_code(AVCodecContext * avctx, int c)
+{
+    AnsiContext *s = avctx-&gt;priv_data;
+    int ret, i, width, height;
+    switch(c) {
+    case 'A': //Cursor Up
+        s-&gt;y = FFMAX(s-&gt;y - (s-&gt;nb_args &gt; 0 ? s-&gt;args[0]*s-&gt;font_height : s-&gt;font_height), 0);
+        break;
+    case 'B': //Cursor Down
+        s-&gt;y = FFMIN(s-&gt;y + (s-&gt;nb_args &gt; 0 ? s-&gt;args[0]*s-&gt;font_height : s-&gt;font_height), avctx-&gt;height - s-&gt;font_height);
+        break;
+    case 'C': //Cursor Right
+        s-&gt;x = FFMIN(s-&gt;x + (s-&gt;nb_args &gt; 0 ? s-&gt;args[0]*FONT_WIDTH : FONT_WIDTH), avctx-&gt;width  - FONT_WIDTH);
+        break;
+    case 'D': //Cursor Left
+        s-&gt;x = FFMAX(s-&gt;x - (s-&gt;nb_args &gt; 0 ? s-&gt;args[0]*FONT_WIDTH : FONT_WIDTH), 0);
+        break;
+    case 'H': //Cursor Position
+    case 'f': //Horizontal and Vertical Position
+        s-&gt;y = s-&gt;nb_args &gt; 0 ? av_clip((s-&gt;args[0] - 1)*s-&gt;font_height, 0, avctx-&gt;height - s-&gt;font_height) : 0;
+        s-&gt;x = s-&gt;nb_args &gt; 1 ? av_clip((s-&gt;args[1] - 1)*FONT_WIDTH,     0, avctx-&gt;width  - FONT_WIDTH) : 0;
+        break;
+    case 'h': //set creen mode
+    case 'l': //reset screen mode
+        if (s-&gt;nb_args &lt; 2)
+            s-&gt;args[0] = DEFAULT_SCREEN_MODE;
+        switch(s-&gt;args[0]) {
+        case 0: case 1: case 4: case 5: case 13: case 19: //320x200 (25 rows)
+            s-&gt;font = ff_cga_font;
+            s-&gt;font_height = 8;
+            width  = 40&lt;&lt;3;
+            height = 25&lt;&lt;3;
+            break;
+        case 2: case 3: //640x400 (25 rows)
+            s-&gt;font = ff_vga16_font;
+            s-&gt;font_height = 16;
+            width  = 80&lt;&lt;3;
+            height = 25&lt;&lt;4;
+            break;
+        case 6: case 14: //640x200 (25 rows)
+            s-&gt;font = ff_cga_font;
+            s-&gt;font_height = 8;
+            width  = 80&lt;&lt;3;
+            height = 25&lt;&lt;3;
+            break;
+        case 7: //set line wrapping
+            break;
+        case 15: case 16: //640x350 (43 rows)
+            s-&gt;font = ff_cga_font;
+            s-&gt;font_height = 8;
+            width  = 80&lt;&lt;3;
+            height = 43&lt;&lt;3;
+            break;
+        case 17: case 18: //640x480 (60 rows)
+            s-&gt;font = ff_cga_font;
+            s-&gt;font_height = 8;
+            width  = 80&lt;&lt;3;
+            height = 60&lt;&lt;4;
+            break;
+        default:
+            av_log_ask_for_sample(avctx, &quot;unsupported screen mode\n&quot;);
+        }
+        if (width != avctx-&gt;width || height != avctx-&gt;height) {
+            if (s-&gt;frame.data[0])
+                avctx-&gt;release_buffer(avctx, &amp;s-&gt;frame);
+            avcodec_set_dimensions(avctx, width, height);
+            ret = avctx-&gt;get_buffer(avctx, &amp;s-&gt;frame);
+            if (ret &lt; 0) {
+                av_log(avctx, AV_LOG_ERROR, &quot;get_buffer() failed\n&quot;);
+                return ret;
+            }
+            s-&gt;frame.pict_type           = FF_I_TYPE;
+            s-&gt;frame.palette_has_changed = 1;
+            memcpy(s-&gt;frame.data[1], ff_cga_palette, 16 * 4);
+            erase_screen(avctx);
+        } else if (c == 'l') {
+            erase_screen(avctx);
+        }
+        break;
+    case 'J': //Erase in Page
+        switch (s-&gt;args[0]) {
+        case 0:
+            erase_line(avctx, s-&gt;x, avctx-&gt;width - s-&gt;x);
+            if (s-&gt;y &lt; avctx-&gt;height - s-&gt;font_height)
+                memset(s-&gt;frame.data[0] + (s-&gt;y + s-&gt;font_height)*s-&gt;frame.linesize[0],
+                    DEFAULT_BG_COLOR, (avctx-&gt;height - s-&gt;y - s-&gt;font_height)*s-&gt;frame.linesize[0]);
+            break;
+        case 1:
+            erase_line(avctx, 0, s-&gt;x);
+            if (s-&gt;y &gt; 0)
+                memset(s-&gt;frame.data[0], DEFAULT_BG_COLOR, s-&gt;y * s-&gt;frame.linesize[0]);
+            break;
+        case 2:
+            erase_screen(avctx);
+        }
+        break;
+    case 'K': //Erase in Line
+        switch(s-&gt;args[0]) {
+        case 0:
+            erase_line(avctx, s-&gt;x, avctx-&gt;width - s-&gt;x);
+            break;
+        case 1:
+            erase_line(avctx, 0, s-&gt;x);
+            break;
+        case 2:
+            erase_line(avctx, 0, avctx-&gt;width);
+        }
+        break;
+    case 'm': //Select Graphics Rendition
+        if (s-&gt;nb_args == 0) {
+            s-&gt;nb_args = 1;
+            s-&gt;args[0] = 0;
+        }
+        for (i = 0; i &lt; FFMIN(s-&gt;nb_args, MAX_NB_ARGS); i++) {
+            int m = s-&gt;args[i];
+            if (m == 0) {
+                s-&gt;attributes = 0;
+                s-&gt;fg = DEFAULT_FG_COLOR;
+                s-&gt;bg = DEFAULT_BG_COLOR;
+            } else if (m == 1 || m == 2 || m == 4 || m == 5 || m == 7 || m == 8) {
+                s-&gt;attributes |= 1 &lt;&lt; (m - 1);
+            } else if (m &gt;= 30 &amp;&amp; m &lt;= 38) {
+                s-&gt;fg = ansi_to_cga[m - 30];
+            } else if (m == 39) {
+                s-&gt;fg = ansi_to_cga[DEFAULT_FG_COLOR];
+            } else if (m &gt;= 40 &amp;&amp; m &lt;= 47) {
+                s-&gt;bg = ansi_to_cga[m - 40];
+            } else if (m == 49) {
+                s-&gt;fg = ansi_to_cga[DEFAULT_BG_COLOR];
+            } else {
+                av_log_ask_for_sample(avctx, &quot;unsupported rendition parameter\n&quot;);
+            }
+        }
+        break;
+    case 'n': //Device Status Report
+    case 'R': //report current line and column
+        /* ignore */
+        break;
+    case 's': //Save Cursor Position
+        s-&gt;sx = s-&gt;x;
+        s-&gt;sy = s-&gt;y;
+        break;
+    case 'u': //Restore Cursor Position
+        s-&gt;x = av_clip(s-&gt;sx, 0, avctx-&gt;width  - FONT_WIDTH);
+        s-&gt;y = av_clip(s-&gt;sy, 0, avctx-&gt;height - s-&gt;font_height);
+        break;
+    default:
+        av_log_ask_for_sample(avctx, &quot;unsupported escape code\n&quot;);
+        break;
+    }
+    return 0;
+}
+
+static int decode_frame(AVCodecContext *avctx,
+                            void *data, int *data_size,
+                            AVPacket *avpkt)
+{
+    AnsiContext *s = avctx-&gt;priv_data;
+    uint8_t *buf = avpkt-&gt;data;
+    int buf_size = avpkt-&gt;size;
+    const uint8_t *buf_end   = buf+buf_size;
+    int ret, i, count;
+
+    ret = avctx-&gt;reget_buffer(avctx, &amp;s-&gt;frame);
+    if (ret &lt; 0){
+        av_log(avctx, AV_LOG_ERROR, &quot;get_buffer() failed\n&quot;);
+        return ret;
+    }
+    s-&gt;frame.pict_type           = FF_I_TYPE;
+    s-&gt;frame.palette_has_changed = 1;
+    memcpy(s-&gt;frame.data[1], ff_cga_palette, 16 * 4);
+
+    while(buf &lt; buf_end) {
+        switch(s-&gt;state) {
+        case STATE_NORMAL:
+            switch (buf[0]) {
+            case 0x00: //NUL
+            case 0x07: //BEL
+            case 0x1A: //SUB
+                /* ignore */
+                break;
+            case 0x08: //BS
+                s-&gt;x = FFMAX(s-&gt;x - 1, 0);
+                break;
+            case 0x09: //HT
+                i = s-&gt;x / FONT_WIDTH;
+                count = ((i + 8) &amp; ~7) - i;
+                for (i = 0; i &lt; count; i++)
+                    draw_char(avctx, ' ');
+                break;
+            case 0x0A: //LF
+                hscroll(avctx);
+            case 0x0D: //CR
+                s-&gt;x = 0;
+                break;
+            case 0x0C: //FF
+                erase_screen(avctx);
+                break;
+            case 0x1B: //ESC
+                s-&gt;state = STATE_ESCAPE;
+                break;
+            default:
+                draw_char(avctx, buf[0]);
+            }
+            break;
+        case STATE_ESCAPE:
+            if (buf[0] == '[') {
+                s-&gt;state   = STATE_CODE;
+                s-&gt;nb_args = 0;
+                s-&gt;args[0] = 0;
+            } else {
+                s-&gt;state = STATE_NORMAL;
+                draw_char(avctx, 0x1B);
+                    return -1;
+                continue;
+            }
+            break;
+        case STATE_CODE:
+            switch(buf[0]) {
+            case '0': case '1': case '2': case '3': case '4':
+            case '5': case '6': case '7': case '8': case '9':
+                if (s-&gt;nb_args &lt; MAX_NB_ARGS)
+                    s-&gt;args[s-&gt;nb_args] = s-&gt;args[s-&gt;nb_args] * 10 + buf[0] - '0';
+                break;
+            case ';':
+                s-&gt;nb_args++;
+                if (s-&gt;nb_args &lt; MAX_NB_ARGS)
+                    s-&gt;args[s-&gt;nb_args] = 0;
+                break;
+            case 'M':
+                s-&gt;state = STATE_MUSIC_PREAMBLE;
+                break;
+            case '=': case '?':
+                /* ignore */
+                break;
+            default:
+                if (s-&gt;nb_args &gt; MAX_NB_ARGS)
+                    av_log(avctx, AV_LOG_WARNING, &quot;args overflow (%i)\n&quot;, s-&gt;nb_args);
+                if (s-&gt;nb_args &lt; MAX_NB_ARGS &amp;&amp; s-&gt;args[s-&gt;nb_args])
+                    s-&gt;nb_args++;
+                if (execute_code(avctx, buf[0]) &lt; 0)
+                    return -1;
+                s-&gt;state = STATE_NORMAL;
+            }
+            break;
+        case STATE_MUSIC_PREAMBLE:
+            if (buf[0] == 0x0E || buf[0] == 0x1B)
+                s-&gt;state = STATE_NORMAL;
+            /* ignore music data */
+            break;
+        }
+        buf++;
+    }
+
+    *data_size = sizeof(AVFrame);
+    *(AVFrame*)data = s-&gt;frame;
+    return buf_size;
+}
+
+static av_cold int decode_close(AVCodecContext *avctx)
+{
+    AnsiContext *s = avctx-&gt;priv_data;
+    if (s-&gt;frame.data[0])
+        avctx-&gt;release_buffer(avctx, &amp;s-&gt;frame);
+    return 0;
+}
+
+AVCodec ansi_decoder = {
+    .name           = &quot;ansi&quot;,
+    .type           = CODEC_TYPE_VIDEO,
+    .id             = CODEC_ID_ANSI,
+    .priv_data_size = sizeof(AnsiContext),
+    .init           = decode_init,
+    .close          = decode_close,
+    .decode         = decode_frame,
+    .capabilities   = CODEC_CAP_DR1,
+    .long_name      = NULL_IF_CONFIG_SMALL(&quot;ASCII/ANSI art&quot;),
+};

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/avcodec.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/avcodec.h	2010-07-25 10:07:49 UTC (rev 6482)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/avcodec.h	2010-07-25 10:07:52 UTC (rev 6483)
@@ -614,6 +614,8 @@
 #define CODEC_FLAG2_PSY           0x00080000 ///&lt; Use psycho visual optimizations.
 #define CODEC_FLAG2_SSIM          0x00100000 ///&lt; Compute SSIM during encoding, error[] values are undefined.
 #define CODEC_FLAG2_INTRA_REFRESH 0x00200000 ///&lt; Use periodic insertion of intra blocks instead of keyframes.
+//MEANX: NEVER EVER USE CLOSED GOP ?
+#define CODEC_FLAG2_32_PULLDOWN   0x80000000 
 
 /* Unsupported options :
  *              Syntax Arithmetic coding (SAC)
@@ -1496,6 +1498,7 @@
      * - decoding: unused
      */
     int rc_max_rate;
+    int rc_max_rate_header; /*&lt; That one is set in the header MEANX */
 
     /**
      * minimum bitrate
@@ -1510,6 +1513,8 @@
      * - decoding: unused
      */
     int rc_buffer_size;
+    int rc_buffer_size_header;  /*&lt; That one is set in the header MEANX*/
+
     float rc_buffer_aggressivity;
 
     /**

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/fft.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/fft.c	2010-07-25 10:07:49 UTC (rev 6482)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/fft.c	2010-07-25 10:07:52 UTC (rev 6483)
@@ -105,7 +105,7 @@
 
     if (ARCH_ARM)     ff_fft_init_arm(s);
     if (HAVE_ALTIVEC) ff_fft_init_altivec(s);
-    if (HAVE_MMX)     ff_fft_init_mmx(s);
+    // MEANX if (HAVE_MMX)     ff_fft_init_mmx(s);
 
     for(j=4; j&lt;=nbits; j++) {
         ff_init_ff_cos_tabs(j);

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/ffv1.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/ffv1.c	2010-07-25 10:07:49 UTC (rev 6482)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/ffv1.c	2010-07-25 10:07:52 UTC (rev 6483)
@@ -1112,6 +1112,8 @@
         clear_state(f);
     }else{
         p-&gt;key_frame= 0;
+         p-&gt;pict_type= FF_P_TYPE; // MEANX : looks more like a P to me as user
+
     }
     if(f-&gt;ac&gt;1){
         int i;

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/gsmdec.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/gsmdec.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/gsmdec.c	2010-07-25 10:07:52 UTC (rev 6483)
@@ -0,0 +1,316 @@
+/*
+ * gsm 06.10 decoder
+ * Copyright (c) 2010 Reimar D&#246;ffinger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">Reimar.Doeffinger at gmx.de</A>&gt;
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * GSM decoder
+ */
+
+#define ALT_BITSTREAM_READER_LE
+#include &quot;avcodec.h&quot;
+#include &quot;get_bits.h&quot;
+
+// input and output sizes in byte
+#define GSM_BLOCK_SIZE    33
+#define GSM_MS_BLOCK_SIZE 65
+#define GSM_FRAME_SIZE   160
+
+typedef struct {
+    int16_t ref_buf[280];
+    int v[9];
+    int lar[2][8];
+    int lar_idx;
+    int msr;
+} GSMContext;
+
+static av_cold int gsm_init(AVCodecContext *avctx)
+{
+    avctx-&gt;channels = 1;
+    if (!avctx-&gt;sample_rate)
+        avctx-&gt;sample_rate = 8000;
+    avctx-&gt;sample_fmt = SAMPLE_FMT_S16;
+
+    switch (avctx-&gt;codec_id) {
+    case CODEC_ID_GSM:
+        avctx-&gt;frame_size  = GSM_FRAME_SIZE;
+        avctx-&gt;block_align = GSM_BLOCK_SIZE;
+        break;
+    case CODEC_ID_GSM_MS:
+        avctx-&gt;frame_size  = 2 * GSM_FRAME_SIZE;
+        avctx-&gt;block_align = GSM_MS_BLOCK_SIZE;
+    }
+
+    return 0;
+}
+
+static const int16_t dequant_tab[64][8] = {
+    {   -28,    -20,    -12,     -4,      4,     12,     20,     28},
+    {   -56,    -40,    -24,     -8,      8,     24,     40,     56},
+    {   -84,    -60,    -36,    -12,     12,     36,     60,     84},
+    {  -112,    -80,    -48,    -16,     16,     48,     80,    112},
+    {  -140,   -100,    -60,    -20,     20,     60,    100,    140},
+    {  -168,   -120,    -72,    -24,     24,     72,    120,    168},
+    {  -196,   -140,    -84,    -28,     28,     84,    140,    196},
+    {  -224,   -160,    -96,    -32,     32,     96,    160,    224},
+    {  -252,   -180,   -108,    -36,     36,    108,    180,    252},
+    {  -280,   -200,   -120,    -40,     40,    120,    200,    280},
+    {  -308,   -220,   -132,    -44,     44,    132,    220,    308},
+    {  -336,   -240,   -144,    -48,     48,    144,    240,    336},
+    {  -364,   -260,   -156,    -52,     52,    156,    260,    364},
+    {  -392,   -280,   -168,    -56,     56,    168,    280,    392},
+    {  -420,   -300,   -180,    -60,     60,    180,    300,    420},
+    {  -448,   -320,   -192,    -64,     64,    192,    320,    448},
+    {  -504,   -360,   -216,    -72,     72,    216,    360,    504},
+    {  -560,   -400,   -240,    -80,     80,    240,    400,    560},
+    {  -616,   -440,   -264,    -88,     88,    264,    440,    616},
+    {  -672,   -480,   -288,    -96,     96,    288,    480,    672},
+    {  -728,   -520,   -312,   -104,    104,    312,    520,    728},
+    {  -784,   -560,   -336,   -112,    112,    336,    560,    784},
+    {  -840,   -600,   -360,   -120,    120,    360,    600,    840},
+    {  -896,   -640,   -384,   -128,    128,    384,    640,    896},
+    { -1008,   -720,   -432,   -144,    144,    432,    720,   1008},
+    { -1120,   -800,   -480,   -160,    160,    480,    800,   1120},
+    { -1232,   -880,   -528,   -176,    176,    528,    880,   1232},
+    { -1344,   -960,   -576,   -192,    192,    576,    960,   1344},
+    { -1456,  -1040,   -624,   -208,    208,    624,   1040,   1456},
+    { -1568,  -1120,   -672,   -224,    224,    672,   1120,   1568},
+    { -1680,  -1200,   -720,   -240,    240,    720,   1200,   1680},
+    { -1792,  -1280,   -768,   -256,    256,    768,   1280,   1792},
+    { -2016,  -1440,   -864,   -288,    288,    864,   1440,   2016},
+    { -2240,  -1600,   -960,   -320,    320,    960,   1600,   2240},
+    { -2464,  -1760,  -1056,   -352,    352,   1056,   1760,   2464},
+    { -2688,  -1920,  -1152,   -384,    384,   1152,   1920,   2688},
+    { -2912,  -2080,  -1248,   -416,    416,   1248,   2080,   2912},
+    { -3136,  -2240,  -1344,   -448,    448,   1344,   2240,   3136},
+    { -3360,  -2400,  -1440,   -480,    480,   1440,   2400,   3360},
+    { -3584,  -2560,  -1536,   -512,    512,   1536,   2560,   3584},
+    { -4032,  -2880,  -1728,   -576,    576,   1728,   2880,   4032},
+    { -4480,  -3200,  -1920,   -640,    640,   1920,   3200,   4480},
+    { -4928,  -3520,  -2112,   -704,    704,   2112,   3520,   4928},
+    { -5376,  -3840,  -2304,   -768,    768,   2304,   3840,   5376},
+    { -5824,  -4160,  -2496,   -832,    832,   2496,   4160,   5824},
+    { -6272,  -4480,  -2688,   -896,    896,   2688,   4480,   6272},
+    { -6720,  -4800,  -2880,   -960,    960,   2880,   4800,   6720},
+    { -7168,  -5120,  -3072,  -1024,   1024,   3072,   5120,   7168},
+    { -8063,  -5759,  -3456,  -1152,   1152,   3456,   5760,   8064},
+    { -8959,  -6399,  -3840,  -1280,   1280,   3840,   6400,   8960},
+    { -9855,  -7039,  -4224,  -1408,   1408,   4224,   7040,   9856},
+    {-10751,  -7679,  -4608,  -1536,   1536,   4608,   7680,  10752},
+    {-11647,  -8319,  -4992,  -1664,   1664,   4992,   8320,  11648},
+    {-12543,  -8959,  -5376,  -1792,   1792,   5376,   8960,  12544},
+    {-13439,  -9599,  -5760,  -1920,   1920,   5760,   9600,  13440},
+    {-14335, -10239,  -6144,  -2048,   2048,   6144,  10240,  14336},
+    {-16127, -11519,  -6912,  -2304,   2304,   6912,  11519,  16127},
+    {-17919, -12799,  -7680,  -2560,   2560,   7680,  12799,  17919},
+    {-19711, -14079,  -8448,  -2816,   2816,   8448,  14079,  19711},
+    {-21503, -15359,  -9216,  -3072,   3072,   9216,  15359,  21503},
+    {-23295, -16639,  -9984,  -3328,   3328,   9984,  16639,  23295},
+    {-25087, -17919, -10752,  -3584,   3584,  10752,  17919,  25087},
+    {-26879, -19199, -11520,  -3840,   3840,  11520,  19199,  26879},
+    {-28671, -20479, -12288,  -4096,   4096,  12288,  20479,  28671}
+};
+
+static void apcm_dequant_add(GetBitContext *gb, int16_t *dst)
+{
+    int i;
+    int maxidx = get_bits(gb, 6);
+    const int16_t *tab = dequant_tab[maxidx];
+    for (i = 0; i &lt; 13; i++)
+        dst[3*i] += tab[get_bits(gb, 3)];
+}
+
+static inline int gsm_mult(int a, int b)
+{
+    return (a * b + (1 &lt;&lt; 14)) &gt;&gt; 15;
+}
+
+static const uint16_t long_term_gain_tab[4] = {
+    3277, 11469, 21299, 32767
+};
+
+static void long_term_synth(int16_t *dst, int lag, int gain_idx)
+{
+    int i;
+    const int16_t *src = dst - lag;
+    uint16_t gain = long_term_gain_tab[gain_idx];
+    for (i = 0; i &lt; 40; i++)
+        dst[i] = gsm_mult(gain, src[i]);
+}
+
+static inline int decode_log_area(int coded, int factor, int offset)
+{
+    coded &lt;&lt;= 10;
+    coded -= offset;
+    return gsm_mult(coded, factor) &lt;&lt; 1;
+}
+
+static av_noinline int get_rrp(int filtered)
+{
+    int abs = FFABS(filtered);
+    if      (abs &lt; 11059) abs &lt;&lt;= 1;
+    else if (abs &lt; 20070) abs += 11059;
+    else                  abs = (abs &gt;&gt; 2) + 26112;
+    return filtered &lt; 0 ? -abs : abs;
+}
+
+static int filter_value(int in, int rrp[8], int v[9])
+{
+    int i;
+    for (i = 7; i &gt;= 0; i--) {
+        in -= gsm_mult(rrp[i], v[i]);
+        v[i + 1] = v[i] + gsm_mult(rrp[i], in);
+    }
+    v[0] = in;
+    return in;
+}
+
+static void short_term_synth(GSMContext *ctx, int16_t *dst, const int16_t *src)
+{
+    int i;
+    int rrp[8];
+    int *lar = ctx-&gt;lar[ctx-&gt;lar_idx];
+    int *lar_prev = ctx-&gt;lar[ctx-&gt;lar_idx ^ 1];
+    for (i = 0; i &lt; 8; i++)
+        rrp[i] = get_rrp((lar_prev[i] &gt;&gt; 2) + (lar_prev[i] &gt;&gt; 1) + (lar[i] &gt;&gt; 2));
+    for (i = 0; i &lt; 13; i++)
+        dst[i] = filter_value(src[i], rrp, ctx-&gt;v);
+
+    for (i = 0; i &lt; 8; i++)
+        rrp[i] = get_rrp((lar_prev[i] &gt;&gt; 1) + (lar     [i] &gt;&gt; 1));
+    for (i = 13; i &lt; 27; i++)
+        dst[i] = filter_value(src[i], rrp, ctx-&gt;v);
+
+    for (i = 0; i &lt; 8; i++)
+        rrp[i] = get_rrp((lar_prev[i] &gt;&gt; 2) + (lar     [i] &gt;&gt; 1) + (lar[i] &gt;&gt; 2));
+    for (i = 27; i &lt; 40; i++)
+        dst[i] = filter_value(src[i], rrp, ctx-&gt;v);
+
+    for (i = 0; i &lt; 8; i++)
+        rrp[i] = get_rrp(lar[i]);
+    for (i = 40; i &lt; 160; i++)
+        dst[i] = filter_value(src[i], rrp, ctx-&gt;v);
+
+    ctx-&gt;lar_idx ^= 1;
+}
+
+static int postprocess(int16_t *data, int msr)
+{
+    int i;
+    for (i = 0; i &lt; 160; i++) {
+        msr = av_clip_int16(data[i] + gsm_mult(msr, 28180));
+        data[i] = av_clip_int16(msr &lt;&lt; 1) &amp; ~7;
+    }
+    return msr;
+}
+
+static int gsm_decode_block(AVCodecContext *avctx, int16_t *samples,
+                            GetBitContext *gb)
+{
+    GSMContext *ctx = avctx-&gt;priv_data;
+    int i;
+    int16_t *ref_dst = ctx-&gt;ref_buf + 120;
+    int *lar = ctx-&gt;lar[ctx-&gt;lar_idx];
+    lar[0] = decode_log_area(get_bits(gb, 6), 13107,  1 &lt;&lt; 15);
+    lar[1] = decode_log_area(get_bits(gb, 6), 13107,  1 &lt;&lt; 15);
+    lar[2] = decode_log_area(get_bits(gb, 5), 13107, (1 &lt;&lt; 14) + 2048*2);
+    lar[3] = decode_log_area(get_bits(gb, 5), 13107, (1 &lt;&lt; 14) - 2560*2);
+    lar[4] = decode_log_area(get_bits(gb, 4), 19223, (1 &lt;&lt; 13) +   94*2);
+    lar[5] = decode_log_area(get_bits(gb, 4), 17476, (1 &lt;&lt; 13) - 1792*2);
+    lar[6] = decode_log_area(get_bits(gb, 3), 31454, (1 &lt;&lt; 12) -  341*2);
+    lar[7] = decode_log_area(get_bits(gb, 3), 29708, (1 &lt;&lt; 12) - 1144*2);
+
+    for (i = 0; i &lt; 4; i++) {
+        int lag      = get_bits(gb, 7);
+        int gain_idx = get_bits(gb, 2);
+        int offset   = get_bits(gb, 2);
+        lag = av_clip(lag, 40, 120);
+        long_term_synth(ref_dst, lag, gain_idx);
+        apcm_dequant_add(gb, ref_dst + offset);
+        ref_dst += 40;
+    }
+    memcpy(ctx-&gt;ref_buf, ctx-&gt;ref_buf + 160, 120 * sizeof(*ctx-&gt;ref_buf));
+    short_term_synth(ctx, samples, ctx-&gt;ref_buf + 120);
+    // for optimal speed this could be merged with short_term_synth,
+    // not done yet because it is a bit ugly
+    ctx-&gt;msr = postprocess(samples, ctx-&gt;msr);
+    return 0;
+}
+
+static int gsm_decode_frame(AVCodecContext *avctx, void *data,
+                            int *data_size, AVPacket *avpkt)
+{
+    int res;
+    GetBitContext gb;
+    const uint8_t *buf = avpkt-&gt;data;
+    int buf_size = avpkt-&gt;size;
+    int16_t *samples = data;
+    int frame_bytes = 2 * avctx-&gt;frame_size;
+
+    if (*data_size &lt; frame_bytes)
+        return -1;
+    *data_size = 0;
+    if(buf_size &lt; avctx-&gt;block_align)
+        return AVERROR_INVALIDDATA;
+    init_get_bits(&amp;gb, buf, buf_size * 8);
+
+    switch (avctx-&gt;codec_id) {
+    case CODEC_ID_GSM:
+        if (get_bits(&amp;gb, 4) != 0xd)
+            av_log(avctx, AV_LOG_WARNING, &quot;Missing GSM magic!\n&quot;);
+        res = gsm_decode_block(avctx, samples, &amp;gb);
+        if (res &lt; 0)
+            return res;
+        break;
+    case CODEC_ID_GSM_MS:
+        res = gsm_decode_block(avctx, samples, &amp;gb);
+        if (res &lt; 0)
+            return res;
+        res = gsm_decode_block(avctx, samples + GSM_FRAME_SIZE, &amp;gb);
+        if (res &lt; 0)
+            return res;
+    }
+    *data_size = frame_bytes;
+    return avctx-&gt;block_align;
+}
+
+AVCodec gsm_decoder = {
+    &quot;gsm&quot;,
+    AVMEDIA_TYPE_AUDIO,
+    CODEC_ID_GSM,
+    sizeof(GSMContext),
+    gsm_init,
+    NULL,
+    NULL,
+    gsm_decode_frame,
+    .long_name = NULL_IF_CONFIG_SMALL(&quot;GSM&quot;),
+};
+
+AVCodec gsm_ms_decoder = {
+    &quot;gsm_ms&quot;,
+    AVMEDIA_TYPE_AUDIO,
+    CODEC_ID_GSM_MS,
+    sizeof(GSMContext),
+    gsm_init,
+    NULL,
+    NULL,
+    gsm_decode_frame,
+    .long_name = NULL_IF_CONFIG_SMALL(&quot;GSM Microsoft variant&quot;),
+};

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/h263dec.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/h263dec.c	2010-07-25 10:07:49 UTC (rev 6482)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/h263dec.c	2010-07-25 10:07:52 UTC (rev 6483)
@@ -119,7 +119,24 @@
 
     return 0;
 }
+/* MeanX : Ugly patch to detect vo ppacked stuff ... */
+int av_is_voppacked(AVCodecContext *avctx, int *vop_packed, int *gmc, int *qpel)
+{
+    MpegEncContext *s = avctx-&gt;priv_data;
+    // set sane default
+    *vop_packed=0;
+    *gmc=0;
+    *qpel=0;
+    if(avctx-&gt;codec-&gt;id!=CODEC_ID_MPEG4) return 0;
+    	
+  	*vop_packed=(s-&gt;divx_packed);
+	*qpel=s-&gt;quarter_sample;
+	*gmc=0;	// FIXME
+	return 1;
 
+  }
+  /* MeanX */
+
 av_cold int ff_h263_decode_end(AVCodecContext *avctx)
 {
     MpegEncContext *s = avctx-&gt;priv_data;
@@ -414,6 +431,12 @@
     } else {
         ret = h263_decode_picture_header(s);
     }
+	//MEANX we need to do it here also for quicktime file / ctts atom 
+        // we need the correct frame type, and qt file may contain 
+        // vop not coded frame.
+        pict-&gt;pict_type=s-&gt;current_picture.pict_type= s-&gt;pict_type;
+        pict-&gt;key_frame=s-&gt;current_picture.key_frame= s-&gt;pict_type == FF_I_TYPE;
+        //MEANX
 
     if(ret==FRAME_SKIPPED) return get_consumed_bytes(s, buf_size);
 
@@ -709,6 +732,14 @@
 
 assert(s-&gt;current_picture.pict_type == s-&gt;current_picture_ptr-&gt;pict_type);
 assert(s-&gt;current_picture.pict_type == s-&gt;pict_type);
+/* MEANX */
+  if(s-&gt;current_picture_ptr)
+      s-&gt;current_picture_ptr-&gt;opaque=pict-&gt;opaque;
+/* MEANX */
+
+
+
+
     if (s-&gt;pict_type == FF_B_TYPE || s-&gt;low_delay) {
         *pict= *(AVFrame*)s-&gt;current_picture_ptr;
     } else if (s-&gt;last_picture_ptr != NULL) {

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/h264dsp.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/h264dsp.c	2010-07-25 10:07:49 UTC (rev 6482)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/h264dsp.c	2010-07-25 10:07:52 UTC (rev 6483)
@@ -316,5 +316,7 @@
 
     if (ARCH_ARM) ff_h264dsp_init_arm(c);
     if (HAVE_ALTIVEC) ff_h264dsp_init_ppc(c);
+#if CONFIG_H264DSP //MEANX
     if (HAVE_MMX) ff_h264dsp_init_x86(c);
+#endif
 }

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/inverse.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/inverse.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/inverse.c	2010-07-25 10:07:52 UTC (rev 6483)
@@ -0,0 +1 @@
+#include &quot;libavutil/inverse.c&quot;

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/mpeg12.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/mpeg12.c	2010-07-25 10:07:49 UTC (rev 6482)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/mpeg12.c	2010-07-25 10:07:52 UTC (rev 6483)
@@ -1948,7 +1948,12 @@
         ff_er_frame_end(s);
 
         MPV_frame_end(s);
+/* MEANX */
+  if(s-&gt;current_picture_ptr)
+      s-&gt;current_picture_ptr-&gt;opaque=pict-&gt;opaque;
+/* MEANX */
 
+
         if (s-&gt;pict_type == FF_B_TYPE || s-&gt;low_delay) {
             *pict= *(AVFrame*)s-&gt;current_picture_ptr;
             ff_print_debug_info(s, pict);

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/mpeg12enc.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/mpeg12enc.c	2010-07-25 10:07:49 UTC (rev 6482)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/mpeg12enc.c	2010-07-25 10:07:52 UTC (rev 6483)
@@ -127,10 +127,19 @@
             s-&gt;frame_rate_index= i;
         }
     }
+ /* MEANX 
+
     if(dmin)
         return -1;
     else
         return 0;
+  */
+        if(dmin&gt;4)
+   {
+        av_log(0,AV_LOG_ERROR,&quot;We did a roundup ! Expect async!\n&quot;);
+   }
+        return 0; //MEANX
+
 }
 
 static av_cold int encode_init(AVCodecContext *avctx)
@@ -209,6 +218,7 @@
             put_sbits(&amp;s-&gt;pb, 12, s-&gt;width );
             put_sbits(&amp;s-&gt;pb, 12, s-&gt;height);
 
+#if 0 //MEANX
             for(i=1; i&lt;15; i++){
                 float error= aspect_ratio;
                 if(s-&gt;codec_id == CODEC_ID_MPEG1VIDEO || i &lt;=1)
@@ -223,20 +233,44 @@
                     s-&gt;aspect_ratio_info= i;
                 }
             }
+#endif // MEANX
+            //MEANX put_bits(&amp;s-&gt;pb, 4, s-&gt;aspect_ratio_info);
+            //MEANX put_bits(&amp;s-&gt;pb, 4, s-&gt;frame_rate_index);
+ // MEANX 4:3
+  if(s-&gt;avctx-&gt;sample_aspect_ratio.num==16 &amp;&amp; s-&gt;avctx-&gt;sample_aspect_ratio.den==9)
+            {
+                //printf(&quot;FFmpeg : Wide\n&quot;);
+                put_bits(&amp;s-&gt;pb,4,3); //16:9
+            }
+            else        //4:3
+            {
+              if(s-&gt;codec_id == CODEC_ID_MPEG2VIDEO)
+                put_bits(&amp;s-&gt;pb, 4, 2);
+              else
+                put_bits(&amp;s-&gt;pb, 4, 12); // MPEG1
+            }
+// /MEANX
 
-            put_bits(&amp;s-&gt;pb, 4, s-&gt;aspect_ratio_info);
-            put_bits(&amp;s-&gt;pb, 4, s-&gt;frame_rate_index);
+// //MEANX PULLDOWN            put_bits(&amp;s-&gt;pb, 4, s-&gt;frame_rate_index);
+if((s-&gt;flags2 &amp; CODEC_FLAG2_32_PULLDOWN) &amp;&amp; (s-&gt;codec_id == CODEC_ID_MPEG2VIDEO))
+            {           
+                put_bits(&amp;s-&gt;pb, 4,4);
+            }
+            else
+            {                                  
+                put_bits(&amp;s-&gt;pb, 4, s-&gt;frame_rate_index);
+            } //MEANX pulldown
 
-            if(s-&gt;avctx-&gt;rc_max_rate){
-                v = (s-&gt;avctx-&gt;rc_max_rate + 399) / 400;
+            if(s-&gt;avctx-&gt;rc_max_rate_header){ //MEANX we use header
+                v = (s-&gt;avctx-&gt;rc_max_rate_header + 399) / 400;
                 if (v &gt; 0x3ffff &amp;&amp; s-&gt;codec_id == CODEC_ID_MPEG1VIDEO)
                     v = 0x3ffff;
             }else{
                 v= 0x3FFFF;
             }
 
-            if(s-&gt;avctx-&gt;rc_buffer_size)
-                vbv_buffer_size = s-&gt;avctx-&gt;rc_buffer_size;
+            if(s-&gt;avctx-&gt;rc_buffer_size_header) // MEANX we use header
+                vbv_buffer_size = s-&gt;avctx-&gt;rc_buffer_size_header;
             else
                 /* VBV calculation: Scaled so that a VCD has the proper VBV size of 40 kilobytes */
                 vbv_buffer_size = (( 20 * s-&gt;bit_rate) / (1151929 / 2)) * 8 * 1024;
@@ -269,8 +303,17 @@
 
                 put_bits(&amp;s-&gt;pb, 3, s-&gt;avctx-&gt;profile); //profile
                 put_bits(&amp;s-&gt;pb, 4, s-&gt;avctx-&gt;level); //level
+   // MEANX pulldown put_bits(&amp;s-&gt;pb, 1, s-&gt;progressive_sequence);
+  // MEANX Pulldown
+ if(s-&gt;flags2 &amp; CODEC_FLAG2_32_PULLDOWN) //MEANX
+                        put_bits(&amp;s-&gt;pb, 1, 0);
+                else
+                        put_bits(&amp;s-&gt;pb, 1, s-&gt;progressive_sequence);
 
-                put_bits(&amp;s-&gt;pb, 1, s-&gt;progressive_sequence);
+
+// /MEANX
+
+
                 put_bits(&amp;s-&gt;pb, 2, s-&gt;chroma_format);
                 put_bits(&amp;s-&gt;pb, 2, s-&gt;width &gt;&gt;12);
                 put_bits(&amp;s-&gt;pb, 2, s-&gt;height&gt;&gt;12);
@@ -339,6 +382,8 @@
 
 void mpeg1_encode_picture_header(MpegEncContext *s, int picture_number)
 {
+	int tff,rff; //MEANX
+
     mpeg1_encode_sequence_header(s);
 
     /* mpeg1 picture header */
@@ -375,6 +420,49 @@
 
     s-&gt;frame_pred_frame_dct = 1;
     if(s-&gt;codec_id == CODEC_ID_MPEG2VIDEO){
+ /* MEANX -- Pulldown */
+        if(s-&gt;flags2 &amp; CODEC_FLAG2_32_PULLDOWN)
+        {
+        
+                switch((s-&gt;picture_number - 
+                          s-&gt;gop_picture_number)&amp;3)
+                {
+                        case 0:
+                        default:
+                                rff=1;
+                                tff=1;
+                                break;
+                        case 1:
+                                rff=0;
+                                tff=0;
+                                break;
+                        case 2:
+                                rff=1;
+                                tff=0;
+                                break;
+                        case 3:
+                                rff=0;
+                                tff=1;
+                                break;
+                }               
+           }
+        else
+        {
+                if (s-&gt;progressive_sequence) 
+                {
+                        tff=0; /* no repeat */
+                } else 
+                {
+                        tff= s-&gt;current_picture_ptr-&gt;top_field_first;
+                }
+                rff=s-&gt;repeat_first_field;
+        
+        }
+
+//               /MEANX pulldown
+
+
+
         put_header(s, EXT_START_CODE);
         put_bits(&amp;s-&gt;pb, 4, 8); //pic ext
         if (s-&gt;pict_type == FF_P_TYPE || s-&gt;pict_type == FF_B_TYPE) {
@@ -393,11 +481,16 @@
 
         assert(s-&gt;picture_structure == PICT_FRAME);
         put_bits(&amp;s-&gt;pb, 2, s-&gt;picture_structure);
+#if 0 //MEANX
+
         if (s-&gt;progressive_sequence) {
             put_bits(&amp;s-&gt;pb, 1, 0); /* no repeat */
         } else {
             put_bits(&amp;s-&gt;pb, 1, s-&gt;current_picture_ptr-&gt;top_field_first);
         }
+#endif
+         put_bits(&amp;s-&gt;pb, 1, tff);  //MEANX PULLDOWN
+
         /* XXX: optimize the generation of this flag with entropy
            measures */
         s-&gt;frame_pred_frame_dct = s-&gt;progressive_sequence;
@@ -407,7 +500,10 @@
         put_bits(&amp;s-&gt;pb, 1, s-&gt;q_scale_type);
         put_bits(&amp;s-&gt;pb, 1, s-&gt;intra_vlc_format);
         put_bits(&amp;s-&gt;pb, 1, s-&gt;alternate_scan);
-        put_bits(&amp;s-&gt;pb, 1, s-&gt;repeat_first_field);
+ // MEANX put_bits(&amp;s-&gt;pb, 1, s-&gt;repeat_first_field);
+	put_bits(&amp;s-&gt;pb, 1, rff);
+      // /MEANX
+
         s-&gt;progressive_frame = s-&gt;progressive_sequence;
         put_bits(&amp;s-&gt;pb, 1, s-&gt;chroma_format == CHROMA_420 ? s-&gt;progressive_frame : 0); /* chroma_420_type */
         put_bits(&amp;s-&gt;pb, 1, s-&gt;progressive_frame);

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/mpegvideo.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/mpegvideo.c	2010-07-25 10:07:49 UTC (rev 6482)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/mpegvideo.c	2010-07-25 10:07:52 UTC (rev 6483)
@@ -652,7 +652,11 @@
     FF_ALLOCZ_OR_GOTO(s-&gt;avctx, s-&gt;prev_pict_types, PREV_PICT_TYPES_BUFFER_SIZE, fail);
 
     s-&gt;parse_context.state= -1;
-    if((s-&gt;avctx-&gt;debug&amp;(FF_DEBUG_VIS_QP|FF_DEBUG_VIS_MB_TYPE)) || (s-&gt;avctx-&gt;debug_mv)){
+ //MEANX: Allocate them always, as they may be free when we decode 1st image
+
+    // MEANXif((s-&gt;avctx-&gt;debug&amp;(FF_DEBUG_VIS_QP|FF_DEBUG_VIS_MB_TYPE)) || (s-&gt;avctx-&gt;debug_mv)){
+if(1){ // MEANX
+
        s-&gt;visualization_buffer[0] = av_malloc((s-&gt;mb_width*16 + 2*EDGE_WIDTH) * s-&gt;mb_height*16 + 2*EDGE_WIDTH);
        s-&gt;visualization_buffer[1] = av_malloc((s-&gt;mb_width*16 + 2*EDGE_WIDTH) * s-&gt;mb_height*16 + 2*EDGE_WIDTH);
        s-&gt;visualization_buffer[2] = av_malloc((s-&gt;mb_width*16 + 2*EDGE_WIDTH) * s-&gt;mb_height*16 + 2*EDGE_WIDTH);

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/mpegvideo_enc.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/mpegvideo_enc.c	2010-07-25 10:07:49 UTC (rev 6482)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/mpegvideo_enc.c	2010-07-25 10:07:52 UTC (rev 6483)
@@ -367,12 +367,14 @@
 
         av_log(avctx, AV_LOG_INFO, &quot;Warning vbv_delay will be set to 0xFFFF (=VBR) as the specified vbv buffer is too large for the given bitrate!\n&quot;);
     }
+#if 0 //MEANX
 
     if((s-&gt;flags &amp; CODEC_FLAG_4MV) &amp;&amp; s-&gt;codec_id != CODEC_ID_MPEG4
        &amp;&amp; s-&gt;codec_id != CODEC_ID_H263 &amp;&amp; s-&gt;codec_id != CODEC_ID_H263P &amp;&amp; s-&gt;codec_id != CODEC_ID_FLV1){
         av_log(avctx, AV_LOG_ERROR, &quot;4MV not supported by codec\n&quot;);
         return -1;
     }
+#endif
 
     if(s-&gt;obmc &amp;&amp; s-&gt;avctx-&gt;mb_decision != FF_MB_DECISION_SIMPLE){
         av_log(avctx, AV_LOG_ERROR, &quot;OBMC is only supported with simple mb decision\n&quot;);
@@ -413,10 +415,12 @@
         return -1;
     }
 
+#if 0 //MEANX
     if(s-&gt;mpeg_quant &amp;&amp; s-&gt;codec_id != CODEC_ID_MPEG4){ //FIXME mpeg2 uses that too
         av_log(avctx, AV_LOG_ERROR, &quot;mpeg2 style quantization not supported by codec\n&quot;);
         return -1;
     }
+#endif
 
     if((s-&gt;flags &amp; CODEC_FLAG_CBP_RD) &amp;&amp; !avctx-&gt;trellis){
         av_log(avctx, AV_LOG_ERROR, &quot;CBP RD needs trellis quant\n&quot;);

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/pictordec.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/pictordec.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/pictordec.c	2010-07-25 10:07:52 UTC (rev 6483)
@@ -0,0 +1,250 @@
+/*
+ * Pictor/PC Paint decoder
+ * Copyright (c) 2010 Peter Ross &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">pross at xvid.org</A>&gt;
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * Pictor/PC Paint decoder
+ */
+
+#include &quot;avcodec.h&quot;
+#include &quot;bytestream.h&quot;
+#include &quot;cga_data.h&quot;
+
+typedef struct PicContext {
+    AVFrame frame;
+    int width, height;
+    int nb_planes;
+} PicContext;
+
+static void picmemset_8bpp(PicContext *s, int value, int run, int *x, int *y)
+{
+    while (run &gt; 0) {
+        uint8_t *d = s-&gt;frame.data[0] + *y * s-&gt;frame.linesize[0];
+        if (*x + run &gt;= s-&gt;width) {
+            int n = s-&gt;width - *x;
+            memset(d + *x, value, n);
+            run -= n;
+            *x = 0;
+            *y -= 1;
+            if (*y &lt; 0)
+                break;
+        } else {
+            memset(d + *x, value, run);
+            *x += run;
+            break;
+        }
+    }
+}
+
+static void picmemset(PicContext *s, int value, int run, int *x, int *y, int *plane, int bits_per_plane)
+{
+    uint8_t *d;
+    int shift = *plane * bits_per_plane;
+    int mask  = ((1 &lt;&lt; bits_per_plane) - 1) &lt;&lt; shift;
+    value   &lt;&lt;= shift;
+
+    while (run &gt; 0) {
+        int j;
+        for (j = 8-bits_per_plane; j &gt;= 0; j -= bits_per_plane) {
+            d = s-&gt;frame.data[0] + *y * s-&gt;frame.linesize[0];
+            d[*x] |= (value &gt;&gt; j) &amp; mask;
+            *x += 1;
+            if (*x == s-&gt;width) {
+                *y -= 1;
+                *x = 0;
+                if (*y &lt; 0) {
+                   *y = s-&gt;height - 1;
+                   *plane += 1;
+                   value &lt;&lt;= bits_per_plane;
+                   mask  &lt;&lt;= bits_per_plane;
+                   if (*plane &gt;= s-&gt;nb_planes)
+                       break;
+                }
+            }
+        }
+        run--;
+    }
+}
+
+static const uint8_t cga_mode45_index[6][4] = {
+    [0] = { 0, 3,  5,   7 }, // mode4, palette#1, low intensity
+    [1] = { 0, 2,  4,   6 }, // mode4, palette#2, low intensity
+    [2] = { 0, 3,  4,   7 }, // mode5, low intensity
+    [3] = { 0, 11, 13, 15 }, // mode4, palette#1, high intensity
+    [4] = { 0, 10, 12, 14 }, // mode4, palette#2, high intensity
+    [5] = { 0, 11, 12, 15 }, // mode5, high intensity
+};
+
+static int decode_frame(AVCodecContext *avctx,
+                        void *data, int *data_size,
+                        AVPacket *avpkt)
+{
+    PicContext *s = avctx-&gt;priv_data;
+    int buf_size = avpkt-&gt;size;
+    const uint8_t *buf = avpkt-&gt;data;
+    const uint8_t *buf_end = avpkt-&gt;data + buf_size;
+    uint32_t *palette;
+    int bits_per_plane, bpp, etype, esize, npal;
+    int i, x, y, plane;
+
+    if (buf_size &lt; 11)
+        return AVERROR_INVALIDDATA;
+
+    if (bytestream_get_le16(&amp;buf) != 0x1234)
+        return AVERROR_INVALIDDATA;
+    s-&gt;width  = bytestream_get_le16(&amp;buf);
+    s-&gt;height = bytestream_get_le16(&amp;buf);
+    buf += 4;
+    bits_per_plane    = *buf &amp; 0xF;
+    s-&gt;nb_planes      = (*buf++ &gt;&gt; 4) + 1;
+    bpp               = s-&gt;nb_planes ? bits_per_plane*s-&gt;nb_planes : bits_per_plane;
+    if (bits_per_plane &gt; 8 || bpp &lt; 1 || bpp &gt; 32) {
+        av_log_ask_for_sample(s, &quot;unsupported bit depth\n&quot;);
+        return AVERROR_INVALIDDATA;
+    }
+
+    if (*buf == 0xFF) {
+        buf += 2;
+        etype  = bytestream_get_le16(&amp;buf);
+        esize  = bytestream_get_le16(&amp;buf);
+        if (buf_end - buf &lt; esize)
+            return AVERROR_INVALIDDATA;
+    } else {
+        etype = -1;
+        esize = 0;
+    }
+
+    avctx-&gt;pix_fmt = PIX_FMT_PAL8;
+
+    if (s-&gt;width != avctx-&gt;width &amp;&amp; s-&gt;height != avctx-&gt;height) {
+        if (avcodec_check_dimensions(avctx, s-&gt;width, s-&gt;height) &lt; 0)
+            return -1;
+        avcodec_set_dimensions(avctx, s-&gt;width, s-&gt;height);
+        if (s-&gt;frame.data[0])
+            avctx-&gt;release_buffer(avctx, &amp;s-&gt;frame);
+    }
+
+    if (avctx-&gt;get_buffer(avctx, &amp;s-&gt;frame) &lt; 0){
+        av_log(avctx, AV_LOG_ERROR, &quot;get_buffer() failed\n&quot;);
+        return -1;
+    }
+    memset(s-&gt;frame.data[0], 0, s-&gt;height * s-&gt;frame.linesize[0]);
+    s-&gt;frame.pict_type           = FF_I_TYPE;
+    s-&gt;frame.palette_has_changed = 1;
+
+    palette = (uint32_t*)s-&gt;frame.data[1];
+    if (etype == 1 &amp;&amp; esize &gt; 1 &amp;&amp; *buf &lt; 6) {
+        int idx = *buf;
+        npal = 4;
+        for (i = 0; i &lt; npal; i++)
+            palette[i] = ff_cga_palette[ cga_mode45_index[idx][i] ];
+    } else if (etype == 2) {
+        npal = FFMIN(esize, 16);
+        for (i = 0; i &lt; npal; i++)
+            palette[i] = ff_cga_palette[ FFMIN(buf[i], 16)];
+    } else if (etype == 3) {
+        npal = FFMIN(esize, 16);
+        for (i = 0; i &lt; npal; i++)
+            palette[i] = ff_ega_palette[ FFMIN(buf[i], 63)];
+    } else if (etype == 4 || etype == 5) {
+        npal = FFMIN(esize / 3, 256);
+        for (i = 0; i &lt; npal; i++)
+            palette[i] = AV_RB24(buf + i*3) &lt;&lt; 2;
+    } else {
+        if (bpp == 1) {
+            npal = 2;
+            palette[0] = 0x000000;
+            palette[1] = 0xFFFFFF;
+        } else if (bpp == 2) {
+            npal = 4;
+            for (i = 0; i &lt; npal; i++)
+                palette[i] = ff_cga_palette[ cga_mode45_index[0][i] ];
+        } else {
+            npal = 16;
+            memcpy(palette, ff_cga_palette, npal * 4);
+        }
+    }
+    // fill remaining palette entries
+    memset(palette + npal, 0, AVPALETTE_SIZE - npal * 4);
+    buf += esize;
+
+
+    x = 0;
+    y = s-&gt;height - 1;
+    plane = 0;
+    if (bytestream_get_le16(&amp;buf)) {
+        while (buf_end - buf &gt;= 6) {
+            const uint8_t *buf_pend = buf + FFMIN(AV_RL16(buf), buf_end - buf);
+            //ignore uncompressed block size reported at buf[2]
+            int marker = buf[4];
+            buf += 5;
+
+            while (plane &lt; s-&gt;nb_planes &amp;&amp; buf_pend - buf &gt;= 1) {
+                int run = 1;
+                int val = *buf++;
+                if (val == marker) {
+                    run = *buf++;
+                    if (run == 0)
+                        run = bytestream_get_le16(&amp;buf);
+                    val = *buf++;
+                }
+                if (buf &gt; buf_end)
+                    break;
+
+                if (bits_per_plane == 8) {
+                    picmemset_8bpp(s, val, run, &amp;x, &amp;y);
+                    if (y &lt; 0)
+                        break;
+                } else {
+                    picmemset(s, val, run, &amp;x, &amp;y, &amp;plane, bits_per_plane);
+                }
+            }
+        }
+    } else {
+        av_log_ask_for_sample(s, &quot;uncompressed image\n&quot;);
+        return buf_size;
+    }
+
+    *data_size = sizeof(AVFrame);
+    *(AVFrame*)data = s-&gt;frame;
+    return buf_size;
+}
+
+static av_cold int decode_end(AVCodecContext *avctx)
+{
+    PicContext *s = avctx-&gt;priv_data;
+    if (s-&gt;frame.data[0])
+        avctx-&gt;release_buffer(avctx, &amp;s-&gt;frame);
+    return 0;
+}
+
+AVCodec pictor_decoder = {
+    &quot;pictor&quot;,
+    CODEC_TYPE_VIDEO,
+    CODEC_ID_PICTOR,
+    sizeof(PicContext),
+    NULL,
+    NULL,
+    decode_end,
+    decode_frame,
+    CODEC_CAP_DR1,
+    .long_name = NULL_IF_CONFIG_SMALL(&quot;Pictor/PC Paint&quot;),
+};

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/png.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/png.c	2010-07-25 10:07:49 UTC (rev 6482)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/png.c	2010-07-25 10:07:52 UTC (rev 6483)
@@ -20,7 +20,7 @@
  */
 #include &quot;avcodec.h&quot;
 #include &quot;bytestream.h&quot;
-#include &quot;png.h&quot;
+#include &quot;ffpng.h&quot;
 
 const uint8_t ff_pngsig[8] = {137, 80, 78, 71, 13, 10, 26, 10};
 const uint8_t ff_mngsig[8] = {138, 77, 78, 71, 13, 10, 26, 10};

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/pngdec.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/pngdec.c	2010-07-25 10:07:49 UTC (rev 6482)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/pngdec.c	2010-07-25 10:07:52 UTC (rev 6483)
@@ -20,7 +20,7 @@
  */
 #include &quot;avcodec.h&quot;
 #include &quot;bytestream.h&quot;
-#include &quot;png.h&quot;
+#include &quot;ffpng.h&quot;
 #include &quot;dsputil.h&quot;
 
 /* TODO:

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/pngenc.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/pngenc.c	2010-07-25 10:07:49 UTC (rev 6482)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/pngenc.c	2010-07-25 10:07:52 UTC (rev 6483)
@@ -21,7 +21,7 @@
 #include &quot;avcodec.h&quot;
 #include &quot;bytestream.h&quot;
 #include &quot;dsputil.h&quot;
-#include &quot;png.h&quot;
+#include &quot;ffpng.h&quot;
 
 /* TODO:
  * - add 2, 4 and 16 bit depth support

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/ra144dec.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/ra144dec.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/ra144dec.c	2010-07-25 10:07:52 UTC (rev 6483)
@@ -0,0 +1,128 @@
+/*
+ * Real Audio 1.0 (14.4K)
+ *
+ * Copyright (c) 2008 Vitor Sessak
+ * Copyright (c) 2003 Nick Kurshev
+ *     Based on public domain decoder at <A HREF="http://www.honeypot.net/audio">http://www.honeypot.net/audio</A>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include &quot;libavutil/intmath.h&quot;
+#include &quot;avcodec.h&quot;
+#include &quot;get_bits.h&quot;
+#include &quot;ra144.h&quot;
+
+
+static av_cold int ra144_decode_init(AVCodecContext * avctx)
+{
+    RA144Context *ractx = avctx-&gt;priv_data;
+
+    ractx-&gt;avctx = avctx;
+
+    ractx-&gt;lpc_coef[0] = ractx-&gt;lpc_tables[0];
+    ractx-&gt;lpc_coef[1] = ractx-&gt;lpc_tables[1];
+
+    avctx-&gt;sample_fmt = SAMPLE_FMT_S16;
+    return 0;
+}
+
+static void do_output_subblock(RA144Context *ractx, const uint16_t  *lpc_coefs,
+                               int gval, GetBitContext *gb)
+{
+    int cba_idx = get_bits(gb, 7); // index of the adaptive CB, 0 if none
+    int gain    = get_bits(gb, 8);
+    int cb1_idx = get_bits(gb, 7);
+    int cb2_idx = get_bits(gb, 7);
+
+    ff_subblock_synthesis(ractx, lpc_coefs, cba_idx, cb1_idx, cb2_idx, gval,
+                          gain);
+}
+
+/** Uncompress one block (20 bytes -&gt; 160*2 bytes). */
+static int ra144_decode_frame(AVCodecContext * avctx, void *vdata,
+                              int *data_size, AVPacket *avpkt)
+{
+    const uint8_t *buf = avpkt-&gt;data;
+    int buf_size = avpkt-&gt;size;
+    static const uint8_t sizes[10] = {6, 5, 5, 4, 4, 3, 3, 3, 3, 2};
+    unsigned int refl_rms[4];    // RMS of the reflection coefficients
+    uint16_t block_coefs[4][10]; // LPC coefficients of each sub-block
+    unsigned int lpc_refl[10];   // LPC reflection coefficients of the frame
+    int i, j;
+    int16_t *data = vdata;
+    unsigned int energy;
+
+    RA144Context *ractx = avctx-&gt;priv_data;
+    GetBitContext gb;
+
+    if (*data_size &lt; 2*160)
+        return -1;
+
+    if(buf_size &lt; 20) {
+        av_log(avctx, AV_LOG_ERROR,
+               &quot;Frame too small (%d bytes). Truncated file?\n&quot;, buf_size);
+        *data_size = 0;
+        return buf_size;
+    }
+    init_get_bits(&amp;gb, buf, 20 * 8);
+
+    for (i=0; i&lt;10; i++)
+        lpc_refl[i] = ff_lpc_refl_cb[i][get_bits(&amp;gb, sizes[i])];
+
+    ff_eval_coefs(ractx-&gt;lpc_coef[0], lpc_refl);
+    ractx-&gt;lpc_refl_rms[0] = ff_rms(lpc_refl);
+
+    energy = ff_energy_tab[get_bits(&amp;gb, 5)];
+
+    refl_rms[0] = ff_interp(ractx, block_coefs[0], 1, 1, ractx-&gt;old_energy);
+    refl_rms[1] = ff_interp(ractx, block_coefs[1], 2,
+                            energy &lt;= ractx-&gt;old_energy,
+                            ff_t_sqrt(energy*ractx-&gt;old_energy) &gt;&gt; 12);
+    refl_rms[2] = ff_interp(ractx, block_coefs[2], 3, 0, energy);
+    refl_rms[3] = ff_rescale_rms(ractx-&gt;lpc_refl_rms[0], energy);
+
+    ff_int_to_int16(block_coefs[3], ractx-&gt;lpc_coef[0]);
+
+    for (i=0; i &lt; 4; i++) {
+        do_output_subblock(ractx, block_coefs[i], refl_rms[i], &amp;gb);
+
+        for (j=0; j &lt; BLOCKSIZE; j++)
+            *data++ = av_clip_int16(ractx-&gt;curr_sblock[j + 10] &lt;&lt; 2);
+    }
+
+    ractx-&gt;old_energy = energy;
+    ractx-&gt;lpc_refl_rms[1] = ractx-&gt;lpc_refl_rms[0];
+
+    FFSWAP(unsigned int *, ractx-&gt;lpc_coef[0], ractx-&gt;lpc_coef[1]);
+
+    *data_size = 2*160;
+    return 20;
+}
+
+AVCodec ra_144_decoder =
+{
+    &quot;real_144&quot;,
+    AVMEDIA_TYPE_AUDIO,
+    CODEC_ID_RA_144,
+    sizeof(RA144Context),
+    ra144_decode_init,
+    NULL,
+    NULL,
+    ra144_decode_frame,
+    .long_name = NULL_IF_CONFIG_SMALL(&quot;RealAudio 1.0 (14.4K)&quot;),
+};

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/ra144enc.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/ra144enc.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/ra144enc.c	2010-07-25 10:07:52 UTC (rev 6483)
@@ -0,0 +1,511 @@
+/*
+ * Real Audio 1.0 (14.4K) encoder
+ * Copyright (c) 2010 Francesco Lavra &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">francescolavra at interfree.it</A>&gt;
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * Real Audio 1.0 (14.4K) encoder
+ * @author Francesco Lavra &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">francescolavra at interfree.it</A>&gt;
+ */
+
+#include &lt;float.h&gt;
+
+#include &quot;avcodec.h&quot;
+#include &quot;put_bits.h&quot;
+#include &quot;lpc.h&quot;
+#include &quot;celp_filters.h&quot;
+#include &quot;ra144.h&quot;
+
+
+static av_cold int ra144_encode_init(AVCodecContext * avctx)
+{
+    RA144Context *ractx;
+
+    if (avctx-&gt;sample_fmt != SAMPLE_FMT_S16) {
+        av_log(avctx, AV_LOG_ERROR, &quot;invalid sample format\n&quot;);
+        return -1;
+    }
+    if (avctx-&gt;channels != 1) {
+        av_log(avctx, AV_LOG_ERROR, &quot;invalid number of channels: %d\n&quot;,
+               avctx-&gt;channels);
+        return -1;
+    }
+    avctx-&gt;frame_size = NBLOCKS * BLOCKSIZE;
+    avctx-&gt;bit_rate = 8000;
+    ractx = avctx-&gt;priv_data;
+    ractx-&gt;lpc_coef[0] = ractx-&gt;lpc_tables[0];
+    ractx-&gt;lpc_coef[1] = ractx-&gt;lpc_tables[1];
+    ractx-&gt;avctx = avctx;
+    dsputil_init(&amp;ractx-&gt;dsp, avctx);
+    return 0;
+}
+
+
+/**
+ * Quantize a value by searching a sorted table for the element with the
+ * nearest value
+ *
+ * @param value value to quantize
+ * @param table array containing the quantization table
+ * @param size size of the quantization table
+ * @return index of the quantization table corresponding to the element with the
+ *         nearest value
+ */
+static int quantize(int value, const int16_t *table, unsigned int size)
+{
+    unsigned int low = 0, high = size - 1;
+
+    while (1) {
+        int index = (low + high) &gt;&gt; 1;
+        int error = table[index] - value;
+
+        if (index == low)
+            return table[high] + error &gt; value ? low : high;
+        if (error &gt; 0) {
+            high = index;
+        } else {
+            low = index;
+        }
+    }
+}
+
+
+/**
+ * Orthogonalize a vector to another vector
+ *
+ * @param v vector to orthogonalize
+ * @param u vector against which orthogonalization is performed
+ */
+static void orthogonalize(float *v, const float *u)
+{
+    int i;
+    float num = 0, den = 0;
+
+    for (i = 0; i &lt; BLOCKSIZE; i++) {
+        num += v[i] * u[i];
+        den += u[i] * u[i];
+    }
+    num /= den;
+    for (i = 0; i &lt; BLOCKSIZE; i++)
+        v[i] -= num * u[i];
+}
+
+
+/**
+ * Calculate match score and gain of an LPC-filtered vector with respect to
+ * input data, possibly othogonalizing it to up to 2 other vectors
+ *
+ * @param work array used to calculate the filtered vector
+ * @param coefs coefficients of the LPC filter
+ * @param vect original vector
+ * @param ortho1 first vector against which orthogonalization is performed
+ * @param ortho2 second vector against which orthogonalization is performed
+ * @param data input data
+ * @param score pointer to variable where match score is returned
+ * @param gain pointer to variable where gain is returned
+ */
+static void get_match_score(float *work, const float *coefs, float *vect,
+                            const float *ortho1, const float *ortho2,
+                            const float *data, float *score, float *gain)
+{
+    float c, g;
+    int i;
+
+    ff_celp_lp_synthesis_filterf(work, coefs, vect, BLOCKSIZE, LPC_ORDER);
+    if (ortho1)
+        orthogonalize(work, ortho1);
+    if (ortho2)
+        orthogonalize(work, ortho2);
+    c = g = 0;
+    for (i = 0; i &lt; BLOCKSIZE; i++) {
+        g += work[i] * work[i];
+        c += data[i] * work[i];
+    }
+    if (c &lt;= 0) {
+        *score = 0;
+        return;
+    }
+    *gain = c / g;
+    *score = *gain * c;
+}
+
+
+/**
+ * Create a vector from the adaptive codebook at a given lag value
+ *
+ * @param vect array where vector is stored
+ * @param cb adaptive codebook
+ * @param lag lag value
+ */
+static void create_adapt_vect(float *vect, const int16_t *cb, int lag)
+{
+    int i;
+
+    cb += BUFFERSIZE - lag;
+    for (i = 0; i &lt; FFMIN(BLOCKSIZE, lag); i++)
+        vect[i] = cb[i];
+    if (lag &lt; BLOCKSIZE)
+        for (i = 0; i &lt; BLOCKSIZE - lag; i++)
+            vect[lag + i] = cb[i];
+}
+
+
+/**
+ * Search the adaptive codebook for the best entry and gain and remove its
+ * contribution from input data
+ *
+ * @param adapt_cb array from which the adaptive codebook is extracted
+ * @param work array used to calculate LPC-filtered vectors
+ * @param coefs coefficients of the LPC filter
+ * @param data input data
+ * @return index of the best entry of the adaptive codebook
+ */
+static int adaptive_cb_search(const int16_t *adapt_cb, float *work,
+                              const float *coefs, float *data)
+{
+    int i, best_vect;
+    float score, gain, best_score, best_gain;
+    float exc[BLOCKSIZE];
+
+    gain = best_score = 0;
+    for (i = BLOCKSIZE / 2; i &lt;= BUFFERSIZE; i++) {
+        create_adapt_vect(exc, adapt_cb, i);
+        get_match_score(work, coefs, exc, NULL, NULL, data, &amp;score, &amp;gain);
+        if (score &gt; best_score) {
+            best_score = score;
+            best_vect = i;
+            best_gain = gain;
+        }
+    }
+    if (!best_score)
+        return 0;
+
+    /**
+     * Re-calculate the filtered vector from the vector with maximum match score
+     * and remove its contribution from input data.
+     */
+    create_adapt_vect(exc, adapt_cb, best_vect);
+    ff_celp_lp_synthesis_filterf(work, coefs, exc, BLOCKSIZE, LPC_ORDER);
+    for (i = 0; i &lt; BLOCKSIZE; i++)
+        data[i] -= best_gain * work[i];
+    return (best_vect - BLOCKSIZE / 2 + 1);
+}
+
+
+/**
+ * Find the best vector of a fixed codebook by applying an LPC filter to
+ * codebook entries, possibly othogonalizing them to up to 2 other vectors and
+ * matching the results with input data
+ *
+ * @param work array used to calculate the filtered vectors
+ * @param coefs coefficients of the LPC filter
+ * @param cb fixed codebook
+ * @param ortho1 first vector against which orthogonalization is performed
+ * @param ortho2 second vector against which orthogonalization is performed
+ * @param data input data
+ * @param idx pointer to variable where the index of the best codebook entry is
+ *        returned
+ * @param gain pointer to variable where the gain of the best codebook entry is
+ *        returned
+ */
+static void find_best_vect(float *work, const float *coefs,
+                           const int8_t cb[][BLOCKSIZE], const float *ortho1,
+                           const float *ortho2, float *data, int *idx,
+                           float *gain)
+{
+    int i, j;
+    float g, score, best_score;
+    float vect[BLOCKSIZE];
+
+    *idx = *gain = best_score = 0;
+    for (i = 0; i &lt; FIXED_CB_SIZE; i++) {
+        for (j = 0; j &lt; BLOCKSIZE; j++)
+            vect[j] = cb[i][j];
+        get_match_score(work, coefs, vect, ortho1, ortho2, data, &amp;score, &amp;g);
+        if (score &gt; best_score) {
+            best_score = score;
+            *idx = i;
+            *gain = g;
+        }
+    }
+}
+
+
+/**
+ * Search the two fixed codebooks for the best entry and gain
+ *
+ * @param work array used to calculate LPC-filtered vectors
+ * @param coefs coefficients of the LPC filter
+ * @param data input data
+ * @param cba_idx index of the best entry of the adaptive codebook
+ * @param cb1_idx pointer to variable where the index of the best entry of the
+ *        first fixed codebook is returned
+ * @param cb2_idx pointer to variable where the index of the best entry of the
+ *        second fixed codebook is returned
+ */
+static void fixed_cb_search(float *work, const float *coefs, float *data,
+                            int cba_idx, int *cb1_idx, int *cb2_idx)
+{
+    int i, ortho_cb1;
+    float gain;
+    float cba_vect[BLOCKSIZE], cb1_vect[BLOCKSIZE];
+    float vect[BLOCKSIZE];
+
+    /**
+     * The filtered vector from the adaptive codebook can be retrieved from
+     * work, because this function is called just after adaptive_cb_search().
+     */
+    if (cba_idx)
+        memcpy(cba_vect, work, sizeof(cba_vect));
+
+    find_best_vect(work, coefs, ff_cb1_vects, cba_idx ? cba_vect : NULL, NULL,
+                   data, cb1_idx, &amp;gain);
+
+    /**
+     * Re-calculate the filtered vector from the vector with maximum match score
+     * and remove its contribution from input data.
+     */
+    if (gain) {
+        for (i = 0; i &lt; BLOCKSIZE; i++)
+            vect[i] = ff_cb1_vects[*cb1_idx][i];
+        ff_celp_lp_synthesis_filterf(work, coefs, vect, BLOCKSIZE, LPC_ORDER);
+        if (cba_idx)
+            orthogonalize(work, cba_vect);
+        for (i = 0; i &lt; BLOCKSIZE; i++)
+            data[i] -= gain * work[i];
+        memcpy(cb1_vect, work, sizeof(cb1_vect));
+        ortho_cb1 = 1;
+    } else
+        ortho_cb1 = 0;
+
+    find_best_vect(work, coefs, ff_cb2_vects, cba_idx ? cba_vect : NULL,
+                   ortho_cb1 ? cb1_vect : NULL, data, cb2_idx, &amp;gain);
+}
+
+
+/**
+ * Encode a subblock of the current frame
+ *
+ * @param ractx encoder context
+ * @param sblock_data input data of the subblock
+ * @param lpc_coefs coefficients of the LPC filter
+ * @param rms RMS of the reflection coefficients
+ * @param pb pointer to PutBitContext of the current frame
+ */
+static void ra144_encode_subblock(RA144Context *ractx,
+                                  const int16_t *sblock_data,
+                                  const int16_t *lpc_coefs, unsigned int rms,
+                                  PutBitContext *pb)
+{
+    float data[BLOCKSIZE], work[LPC_ORDER + BLOCKSIZE];
+    float coefs[LPC_ORDER];
+    float zero[BLOCKSIZE], cba[BLOCKSIZE], cb1[BLOCKSIZE], cb2[BLOCKSIZE];
+    int16_t cba_vect[BLOCKSIZE];
+    int cba_idx, cb1_idx, cb2_idx, gain;
+    int i, n, m[3];
+    float g[3];
+    float error, best_error;
+
+    for (i = 0; i &lt; LPC_ORDER; i++) {
+        work[i] = ractx-&gt;curr_sblock[BLOCKSIZE + i];
+        coefs[i] = lpc_coefs[i] * (1/4096.0);
+    }
+
+    /**
+     * Calculate the zero-input response of the LPC filter and subtract it from
+     * input data.
+     */
+    memset(data, 0, sizeof(data));
+    ff_celp_lp_synthesis_filterf(work + LPC_ORDER, coefs, data, BLOCKSIZE,
+                                 LPC_ORDER);
+    for (i = 0; i &lt; BLOCKSIZE; i++) {
+        zero[i] = work[LPC_ORDER + i];
+        data[i] = sblock_data[i] - zero[i];
+    }
+
+    /**
+     * Codebook search is performed without taking into account the contribution
+     * of the previous subblock, since it has been just subtracted from input
+     * data.
+     */
+    memset(work, 0, LPC_ORDER * sizeof(*work));
+
+    cba_idx = adaptive_cb_search(ractx-&gt;adapt_cb, work + LPC_ORDER, coefs,
+                                 data);
+    if (cba_idx) {
+        /**
+         * The filtered vector from the adaptive codebook can be retrieved from
+         * work, see implementation of adaptive_cb_search().
+         */
+        memcpy(cba, work + LPC_ORDER, sizeof(cba));
+
+        ff_copy_and_dup(cba_vect, ractx-&gt;adapt_cb, cba_idx + BLOCKSIZE / 2 - 1);
+        m[0] = (ff_irms(cba_vect) * rms) &gt;&gt; 12;
+    }
+    fixed_cb_search(work + LPC_ORDER, coefs, data, cba_idx, &amp;cb1_idx, &amp;cb2_idx);
+    for (i = 0; i &lt; BLOCKSIZE; i++) {
+        cb1[i] = ff_cb1_vects[cb1_idx][i];
+        cb2[i] = ff_cb2_vects[cb2_idx][i];
+    }
+    ff_celp_lp_synthesis_filterf(work + LPC_ORDER, coefs, cb1, BLOCKSIZE,
+                                 LPC_ORDER);
+    memcpy(cb1, work + LPC_ORDER, sizeof(cb1));
+    m[1] = (ff_cb1_base[cb1_idx] * rms) &gt;&gt; 8;
+    ff_celp_lp_synthesis_filterf(work + LPC_ORDER, coefs, cb2, BLOCKSIZE,
+                                 LPC_ORDER);
+    memcpy(cb2, work + LPC_ORDER, sizeof(cb2));
+    m[2] = (ff_cb2_base[cb2_idx] * rms) &gt;&gt; 8;
+    best_error = FLT_MAX;
+    gain = 0;
+    for (n = 0; n &lt; 256; n++) {
+        g[1] = ((ff_gain_val_tab[n][1] * m[1]) &gt;&gt; ff_gain_exp_tab[n]) *
+               (1/4096.0);
+        g[2] = ((ff_gain_val_tab[n][2] * m[2]) &gt;&gt; ff_gain_exp_tab[n]) *
+               (1/4096.0);
+        error = 0;
+        if (cba_idx) {
+            g[0] = ((ff_gain_val_tab[n][0] * m[0]) &gt;&gt; ff_gain_exp_tab[n]) *
+                   (1/4096.0);
+            for (i = 0; i &lt; BLOCKSIZE; i++) {
+                data[i] = zero[i] + g[0] * cba[i] + g[1] * cb1[i] +
+                          g[2] * cb2[i];
+                error += (data[i] - sblock_data[i]) *
+                         (data[i] - sblock_data[i]);
+            }
+        } else {
+            for (i = 0; i &lt; BLOCKSIZE; i++) {
+                data[i] = zero[i] + g[1] * cb1[i] + g[2] * cb2[i];
+                error += (data[i] - sblock_data[i]) *
+                         (data[i] - sblock_data[i]);
+            }
+        }
+        if (error &lt; best_error) {
+            best_error = error;
+            gain = n;
+        }
+    }
+    put_bits(pb, 7, cba_idx);
+    put_bits(pb, 8, gain);
+    put_bits(pb, 7, cb1_idx);
+    put_bits(pb, 7, cb2_idx);
+    ff_subblock_synthesis(ractx, lpc_coefs, cba_idx, cb1_idx, cb2_idx, rms,
+                          gain);
+}
+
+
+static int ra144_encode_frame(AVCodecContext *avctx, uint8_t *frame,
+                              int buf_size, void *data)
+{
+    static const uint8_t sizes[LPC_ORDER] = {64, 32, 32, 16, 16, 8, 8, 8, 8, 4};
+    static const uint8_t bit_sizes[LPC_ORDER] = {6, 5, 5, 4, 4, 3, 3, 3, 3, 2};
+    RA144Context *ractx;
+    PutBitContext pb;
+    int32_t lpc_data[NBLOCKS * BLOCKSIZE];
+    int32_t lpc_coefs[LPC_ORDER][MAX_LPC_ORDER];
+    int shift[LPC_ORDER];
+    int16_t block_coefs[NBLOCKS][LPC_ORDER];
+    int lpc_refl[LPC_ORDER];    /**&lt; reflection coefficients of the frame */
+    unsigned int refl_rms[NBLOCKS]; /**&lt; RMS of the reflection coefficients */
+    int energy = 0;
+    int i, idx;
+
+    if (buf_size &lt; FRAMESIZE) {
+        av_log(avctx, AV_LOG_ERROR, &quot;output buffer too small\n&quot;);
+        return 0;
+    }
+    ractx = avctx-&gt;priv_data;
+
+    /**
+     * Since the LPC coefficients are calculated on a frame centered over the
+     * fourth subframe, to encode a given frame, data from the next frame is
+     * needed. In each call to this function, the previous frame (whose data are
+     * saved in the encoder context) is encoded, and data from the current frame
+     * are saved in the encoder context to be used in the next function call.
+     */
+    for (i = 0; i &lt; (2 * BLOCKSIZE + BLOCKSIZE / 2); i++) {
+        lpc_data[i] = ractx-&gt;curr_block[BLOCKSIZE + BLOCKSIZE / 2 + i];
+        energy += (lpc_data[i] * lpc_data[i]) &gt;&gt; 4;
+    }
+    for (i = 2 * BLOCKSIZE + BLOCKSIZE / 2; i &lt; NBLOCKS * BLOCKSIZE; i++) {
+        lpc_data[i] = *((int16_t *)data + i - 2 * BLOCKSIZE - BLOCKSIZE / 2) &gt;&gt;
+                      2;
+        energy += (lpc_data[i] * lpc_data[i]) &gt;&gt; 4;
+    }
+    energy = ff_energy_tab[quantize(ff_t_sqrt(energy &gt;&gt; 5) &gt;&gt; 10, ff_energy_tab,
+                                    32)];
+
+    ff_lpc_calc_coefs(&amp;ractx-&gt;dsp, lpc_data, NBLOCKS * BLOCKSIZE, LPC_ORDER,
+                      LPC_ORDER, 16, lpc_coefs, shift, AV_LPC_TYPE_LEVINSON,
+                      0, ORDER_METHOD_EST, 12, 0);
+    for (i = 0; i &lt; LPC_ORDER; i++)
+        block_coefs[NBLOCKS - 1][i] = -(lpc_coefs[LPC_ORDER - 1][i] &lt;&lt;
+                                        (12 - shift[LPC_ORDER - 1]));
+
+    /**
+     * TODO: apply perceptual weighting of the input speech through bandwidth
+     * expansion of the LPC filter.
+     */
+
+    if (ff_eval_refl(lpc_refl, block_coefs[NBLOCKS - 1], avctx)) {
+        /**
+         * The filter is unstable: use the coefficients of the previous frame.
+         */
+        ff_int_to_int16(block_coefs[NBLOCKS - 1], ractx-&gt;lpc_coef[1]);
+        ff_eval_refl(lpc_refl, block_coefs[NBLOCKS - 1], avctx);
+    }
+    init_put_bits(&amp;pb, frame, buf_size);
+    for (i = 0; i &lt; LPC_ORDER; i++) {
+        idx = quantize(lpc_refl[i], ff_lpc_refl_cb[i], sizes[i]);
+        put_bits(&amp;pb, bit_sizes[i], idx);
+        lpc_refl[i] = ff_lpc_refl_cb[i][idx];
+    }
+    ractx-&gt;lpc_refl_rms[0] = ff_rms(lpc_refl);
+    ff_eval_coefs(ractx-&gt;lpc_coef[0], lpc_refl);
+    refl_rms[0] = ff_interp(ractx, block_coefs[0], 1, 1, ractx-&gt;old_energy);
+    refl_rms[1] = ff_interp(ractx, block_coefs[1], 2,
+                            energy &lt;= ractx-&gt;old_energy,
+                            ff_t_sqrt(energy * ractx-&gt;old_energy) &gt;&gt; 12);
+    refl_rms[2] = ff_interp(ractx, block_coefs[2], 3, 0, energy);
+    refl_rms[3] = ff_rescale_rms(ractx-&gt;lpc_refl_rms[0], energy);
+    ff_int_to_int16(block_coefs[NBLOCKS - 1], ractx-&gt;lpc_coef[0]);
+    put_bits(&amp;pb, 5, quantize(energy, ff_energy_tab, 32));
+    for (i = 0; i &lt; NBLOCKS; i++)
+        ra144_encode_subblock(ractx, ractx-&gt;curr_block + i * BLOCKSIZE,
+                              block_coefs[i], refl_rms[i], &amp;pb);
+    flush_put_bits(&amp;pb);
+    ractx-&gt;old_energy = energy;
+    ractx-&gt;lpc_refl_rms[1] = ractx-&gt;lpc_refl_rms[0];
+    FFSWAP(unsigned int *, ractx-&gt;lpc_coef[0], ractx-&gt;lpc_coef[1]);
+    for (i = 0; i &lt; NBLOCKS * BLOCKSIZE; i++)
+        ractx-&gt;curr_block[i] = *((int16_t *)data + i) &gt;&gt; 2;
+    return FRAMESIZE;
+}
+
+
+AVCodec ra_144_encoder =
+{
+    &quot;real_144&quot;,
+    CODEC_TYPE_AUDIO,
+    CODEC_ID_RA_144,
+    sizeof(RA144Context),
+    ra144_encode_init,
+    ra144_encode_frame,
+    .long_name = NULL_IF_CONFIG_SMALL(&quot;RealAudio 1.0 (14.4K) encoder&quot;),
+};

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/utils.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/utils.c	2010-07-25 10:07:49 UTC (rev 6482)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/utils.c	2010-07-25 10:07:52 UTC (rev 6483)
@@ -643,10 +643,12 @@
 
     if((avctx-&gt;codec-&gt;capabilities &amp; CODEC_CAP_DELAY) || avpkt-&gt;size){
         //FIXME remove the check below _after_ ensuring that all audio check that the available space is enough
+#if 0 // MEANX : Silence
         if(*frame_size_ptr &lt; AVCODEC_MAX_AUDIO_FRAME_SIZE){
             av_log(avctx, AV_LOG_ERROR, &quot;buffer smaller than AVCODEC_MAX_AUDIO_FRAME_SIZE\n&quot;);
             return -1;
         }
+#endif
         if(*frame_size_ptr &lt; FF_MIN_BUFFER_SIZE ||
         *frame_size_ptr &lt; avctx-&gt;channels * avctx-&gt;frame_size * sizeof(int16_t)){
             av_log(avctx, AV_LOG_ERROR, &quot;buffer %d too small\n&quot;, *frame_size_ptr);
@@ -952,13 +954,13 @@
 
 const char *avcodec_configuration(void)
 {
-    return FFMPEG_CONFIGURATION;
+    return &quot;avidemux&quot;; //FFMPEG_CONFIGURATION;
 }
 
 const char *avcodec_license(void)
 {
 #define LICENSE_PREFIX &quot;libavcodec license: &quot;
-    return LICENSE_PREFIX FFMPEG_LICENSE + sizeof(LICENSE_PREFIX) - 1;
+    return LICENSE_PREFIX /*FFMPEG_LICENSE*/ &quot;GPL&quot; + sizeof(LICENSE_PREFIX) - 1;
 }
 
 void avcodec_init(void)

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/x86/mathops.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/x86/mathops.h	2010-07-25 10:07:49 UTC (rev 6482)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/x86/mathops.h	2010-07-25 10:07:52 UTC (rev 6483)
@@ -21,8 +21,12 @@
 
 #ifndef AVCODEC_X86_MATHOPS_H
 #define AVCODEC_X86_MATHOPS_H
+// MEANX
+#ifndef ADM_NO_CONFIG_H
+#include &quot;config.h&quot;
+#endif
+// /MEANX
 
-#include &quot;config.h&quot;
 #include &quot;libavutil/common.h&quot;
 
 #if ARCH_X86_32

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/avcodec.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/avcodec.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/avcodec.h	2010-07-25 10:07:52 UTC (rev 6483)
@@ -0,0 +1,30 @@
+diff --git a/avidemux_core/ADM_ffmpeg/libavcodec/avcodec.h b/avidemux_core/ADM_ffmpeg/libavcodec/avcodec.h
+index 14e049d..78e39a5 100644
+--- a/avidemux_core/ADM_ffmpeg/libavcodec/avcodec.h
++++ b/avidemux_core/ADM_ffmpeg/libavcodec/avcodec.h
+@@ -614,6 +614,8 @@ typedef struct RcOverride{
+ #define CODEC_FLAG2_PSY           0x00080000 ///&lt; Use psycho visual optimizations.
+ #define CODEC_FLAG2_SSIM          0x00100000 ///&lt; Compute SSIM during encoding, error[] values are undefined.
+ #define CODEC_FLAG2_INTRA_REFRESH 0x00200000 ///&lt; Use periodic insertion of intra blocks instead of keyframes.
++//MEANX: NEVER EVER USE CLOSED GOP ?
++#define CODEC_FLAG2_32_PULLDOWN   0x80000000 
+ 
+ /* Unsupported options :
+  *              Syntax Arithmetic coding (SAC)
+@@ -1496,6 +1498,7 @@ typedef struct AVCodecContext {
+      * - decoding: unused
+      */
+     int rc_max_rate;
++    int rc_max_rate_header; /*&lt; That one is set in the header MEANX */
+ 
+     /**
+      * minimum bitrate
+@@ -1510,6 +1513,8 @@ typedef struct AVCodecContext {
+      * - decoding: unused
+      */
+     int rc_buffer_size;
++    int rc_buffer_size_header;  /*&lt; That one is set in the header MEANX*/
++
+     float rc_buffer_aggressivity;
+ 
+     /**

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/avcodec.h.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/avcodec.h.patch	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/avcodec.h.patch	2010-07-25 10:07:52 UTC (rev 6483)
@@ -0,0 +1,30 @@
+diff --git a/avidemux_core/ADM_ffmpeg/libavcodec/avcodec.h b/avidemux_core/ADM_ffmpeg/libavcodec/avcodec.h
+index 14e049d..78e39a5 100644
+--- a/avidemux_core/ADM_ffmpeg/libavcodec/avcodec.h
++++ b/avidemux_core/ADM_ffmpeg/libavcodec/avcodec.h
+@@ -614,6 +614,8 @@ typedef struct RcOverride{
+ #define CODEC_FLAG2_PSY           0x00080000 ///&lt; Use psycho visual optimizations.
+ #define CODEC_FLAG2_SSIM          0x00100000 ///&lt; Compute SSIM during encoding, error[] values are undefined.
+ #define CODEC_FLAG2_INTRA_REFRESH 0x00200000 ///&lt; Use periodic insertion of intra blocks instead of keyframes.
++//MEANX: NEVER EVER USE CLOSED GOP ?
++#define CODEC_FLAG2_32_PULLDOWN   0x80000000 
+ 
+ /* Unsupported options :
+  *              Syntax Arithmetic coding (SAC)
+@@ -1496,6 +1498,7 @@ typedef struct AVCodecContext {
+      * - decoding: unused
+      */
+     int rc_max_rate;
++    int rc_max_rate_header; /*&lt; That one is set in the header MEANX */
+ 
+     /**
+      * minimum bitrate
+@@ -1510,6 +1513,8 @@ typedef struct AVCodecContext {
+      * - decoding: unused
+      */
+     int rc_buffer_size;
++    int rc_buffer_size_header;  /*&lt; That one is set in the header MEANX*/
++
+     float rc_buffer_aggressivity;
+ 
+     /**

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/fft.c.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/fft.c.patch	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/fft.c.patch	2010-07-25 10:07:52 UTC (rev 6483)
@@ -0,0 +1,13 @@
+diff --git a/avidemux_core/ADM_ffmpeg/libavcodec/fft.c b/avidemux_core/ADM_ffmpeg/libavcodec/fft.c
+index 8176551..c946d87 100644
+--- a/avidemux_core/ADM_ffmpeg/libavcodec/fft.c
++++ b/avidemux_core/ADM_ffmpeg/libavcodec/fft.c
+@@ -105,7 +105,7 @@ av_cold int ff_fft_init(FFTContext *s, int nbits, int inverse)
+ 
+     if (ARCH_ARM)     ff_fft_init_arm(s);
+     if (HAVE_ALTIVEC) ff_fft_init_altivec(s);
+-    if (HAVE_MMX)     ff_fft_init_mmx(s);
++    // MEANX if (HAVE_MMX)     ff_fft_init_mmx(s);
+ 
+     for(j=4; j&lt;=nbits; j++) {
+         ff_init_ff_cos_tabs(j);

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/h263dec.c.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/h263dec.c.patch	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/h263dec.c.patch	2010-07-25 10:07:52 UTC (rev 6483)
@@ -0,0 +1,56 @@
+diff --git a/avidemux_core/ADM_ffmpeg/libavcodec/h263dec.c b/avidemux_core/ADM_ffmpeg/libavcodec/h263dec.c
+index d9d6f7e..218959d 100644
+--- a/avidemux_core/ADM_ffmpeg/libavcodec/h263dec.c
++++ b/avidemux_core/ADM_ffmpeg/libavcodec/h263dec.c
+@@ -119,6 +119,23 @@ av_cold int ff_h263_decode_init(AVCodecContext *avctx)
+ 
+     return 0;
+ }
++/* MeanX : Ugly patch to detect vo ppacked stuff ... */
++int av_is_voppacked(AVCodecContext *avctx, int *vop_packed, int *gmc, int *qpel)
++{
++    MpegEncContext *s = avctx-&gt;priv_data;
++    // set sane default
++    *vop_packed=0;
++    *gmc=0;
++    *qpel=0;
++    if(avctx-&gt;codec-&gt;id!=CODEC_ID_MPEG4) return 0;
++    	
++  	*vop_packed=(s-&gt;divx_packed);
++	*qpel=s-&gt;quarter_sample;
++	*gmc=0;	// FIXME
++	return 1;
++
++  }
++  /* MeanX */
+ 
+ av_cold int ff_h263_decode_end(AVCodecContext *avctx)
+ {
+@@ -414,6 +431,12 @@ retry:
+     } else {
+         ret = h263_decode_picture_header(s);
+     }
++	//MEANX we need to do it here also for quicktime file / ctts atom 
++        // we need the correct frame type, and qt file may contain 
++        // vop not coded frame.
++        pict-&gt;pict_type=s-&gt;current_picture.pict_type= s-&gt;pict_type;
++        pict-&gt;key_frame=s-&gt;current_picture.key_frame= s-&gt;pict_type == FF_I_TYPE;
++        //MEANX
+ 
+     if(ret==FRAME_SKIPPED) return get_consumed_bytes(s, buf_size);
+ 
+@@ -709,6 +732,14 @@ intrax8_decoded:
+ 
+ assert(s-&gt;current_picture.pict_type == s-&gt;current_picture_ptr-&gt;pict_type);
+ assert(s-&gt;current_picture.pict_type == s-&gt;pict_type);
++/* MEANX */
++  if(s-&gt;current_picture_ptr)
++      s-&gt;current_picture_ptr-&gt;opaque=pict-&gt;opaque;
++/* MEANX */
++
++
++
++
+     if (s-&gt;pict_type == FF_B_TYPE || s-&gt;low_delay) {
+         *pict= *(AVFrame*)s-&gt;current_picture_ptr;
+     } else if (s-&gt;last_picture_ptr != NULL) {

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/h264dsp.c.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/h264dsp.c.patch	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/h264dsp.c.patch	2010-07-25 10:07:52 UTC (rev 6483)
@@ -0,0 +1,12 @@
+diff --git a/avidemux_core/ADM_ffmpeg/libavcodec/h264dsp.c b/avidemux_core/ADM_ffmpeg/libavcodec/h264dsp.c
+index c01fc77..0fe9f40 100644
+--- a/avidemux_core/ADM_ffmpeg/libavcodec/h264dsp.c
++++ b/avidemux_core/ADM_ffmpeg/libavcodec/h264dsp.c
+@@ -316,5 +316,7 @@ void ff_h264dsp_init(H264DSPContext *c)
+ 
+     if (ARCH_ARM) ff_h264dsp_init_arm(c);
+     if (HAVE_ALTIVEC) ff_h264dsp_init_ppc(c);
++#if CONFIG_H264DSP //MEANX
+     if (HAVE_MMX) ff_h264dsp_init_x86(c);
++#endif
+ }

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/mpeg12.c.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/mpeg12.c.patch	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/mpeg12.c.patch	2010-07-25 10:07:52 UTC (rev 6483)
@@ -0,0 +1,16 @@
+diff --git a/avidemux_core/ADM_ffmpeg/libavcodec/mpeg12.c b/avidemux_core/ADM_ffmpeg/libavcodec/mpeg12.c
+index 0af24ad..3ffea4c 100644
+--- a/avidemux_core/ADM_ffmpeg/libavcodec/mpeg12.c
++++ b/avidemux_core/ADM_ffmpeg/libavcodec/mpeg12.c
+@@ -1948,6 +1948,11 @@ static int slice_end(AVCodecContext *avctx, AVFrame *pict)
+         ff_er_frame_end(s);
+ 
+         MPV_frame_end(s);
++/* MEANX */
++  if(s-&gt;current_picture_ptr)
++      s-&gt;current_picture_ptr-&gt;opaque=pict-&gt;opaque;
++/* MEANX */
++
+ 
+         if (s-&gt;pict_type == FF_B_TYPE || s-&gt;low_delay) {
+             *pict= *(AVFrame*)s-&gt;current_picture_ptr;

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/mpeg12enc.c.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/mpeg12enc.c.patch	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/mpeg12enc.c.patch	2010-07-25 10:07:52 UTC (rev 6483)
@@ -0,0 +1,190 @@
+diff --git a/avidemux_core/ADM_ffmpeg/libavcodec/mpeg12enc.c b/avidemux_core/ADM_ffmpeg/libavcodec/mpeg12enc.c
+index 6868e2a..34b650f 100644
+--- a/avidemux_core/ADM_ffmpeg/libavcodec/mpeg12enc.c
++++ b/avidemux_core/ADM_ffmpeg/libavcodec/mpeg12enc.c
+@@ -127,10 +127,19 @@ static int find_frame_rate_index(MpegEncContext *s){
+             s-&gt;frame_rate_index= i;
+         }
+     }
++ /* MEANX 
++
+     if(dmin)
+         return -1;
+     else
+         return 0;
++  */
++        if(dmin&gt;4)
++   {
++        av_log(0,AV_LOG_ERROR,&quot;We did a roundup ! Expect async!\n&quot;);
++   }
++        return 0; //MEANX
++
+ }
+ 
+ static av_cold int encode_init(AVCodecContext *avctx)
+@@ -209,6 +218,7 @@ static void mpeg1_encode_sequence_header(MpegEncContext *s)
+             put_sbits(&amp;s-&gt;pb, 12, s-&gt;width );
+             put_sbits(&amp;s-&gt;pb, 12, s-&gt;height);
+ 
++#if 0 //MEANX
+             for(i=1; i&lt;15; i++){
+                 float error= aspect_ratio;
+                 if(s-&gt;codec_id == CODEC_ID_MPEG1VIDEO || i &lt;=1)
+@@ -223,20 +233,44 @@ static void mpeg1_encode_sequence_header(MpegEncContext *s)
+                     s-&gt;aspect_ratio_info= i;
+                 }
+             }
++#endif // MEANX
++            //MEANX put_bits(&amp;s-&gt;pb, 4, s-&gt;aspect_ratio_info);
++            //MEANX put_bits(&amp;s-&gt;pb, 4, s-&gt;frame_rate_index);
++ // MEANX 4:3
++  if(s-&gt;avctx-&gt;sample_aspect_ratio.num==16 &amp;&amp; s-&gt;avctx-&gt;sample_aspect_ratio.den==9)
++            {
++                //printf(&quot;FFmpeg : Wide\n&quot;);
++                put_bits(&amp;s-&gt;pb,4,3); //16:9
++            }
++            else        //4:3
++            {
++              if(s-&gt;codec_id == CODEC_ID_MPEG2VIDEO)
++                put_bits(&amp;s-&gt;pb, 4, 2);
++              else
++                put_bits(&amp;s-&gt;pb, 4, 12); // MPEG1
++            }
++// /MEANX
+ 
+-            put_bits(&amp;s-&gt;pb, 4, s-&gt;aspect_ratio_info);
+-            put_bits(&amp;s-&gt;pb, 4, s-&gt;frame_rate_index);
++// //MEANX PULLDOWN            put_bits(&amp;s-&gt;pb, 4, s-&gt;frame_rate_index);
++if((s-&gt;flags2 &amp; CODEC_FLAG2_32_PULLDOWN) &amp;&amp; (s-&gt;codec_id == CODEC_ID_MPEG2VIDEO))
++            {           
++                put_bits(&amp;s-&gt;pb, 4,4);
++            }
++            else
++            {                                  
++                put_bits(&amp;s-&gt;pb, 4, s-&gt;frame_rate_index);
++            } //MEANX pulldown
+ 
+-            if(s-&gt;avctx-&gt;rc_max_rate){
+-                v = (s-&gt;avctx-&gt;rc_max_rate + 399) / 400;
++            if(s-&gt;avctx-&gt;rc_max_rate_header){ //MEANX we use header
++                v = (s-&gt;avctx-&gt;rc_max_rate_header + 399) / 400;
+                 if (v &gt; 0x3ffff &amp;&amp; s-&gt;codec_id == CODEC_ID_MPEG1VIDEO)
+                     v = 0x3ffff;
+             }else{
+                 v= 0x3FFFF;
+             }
+ 
+-            if(s-&gt;avctx-&gt;rc_buffer_size)
+-                vbv_buffer_size = s-&gt;avctx-&gt;rc_buffer_size;
++            if(s-&gt;avctx-&gt;rc_buffer_size_header) // MEANX we use header
++                vbv_buffer_size = s-&gt;avctx-&gt;rc_buffer_size_header;
+             else
+                 /* VBV calculation: Scaled so that a VCD has the proper VBV size of 40 kilobytes */
+                 vbv_buffer_size = (( 20 * s-&gt;bit_rate) / (1151929 / 2)) * 8 * 1024;
+@@ -269,8 +303,17 @@ static void mpeg1_encode_sequence_header(MpegEncContext *s)
+ 
+                 put_bits(&amp;s-&gt;pb, 3, s-&gt;avctx-&gt;profile); //profile
+                 put_bits(&amp;s-&gt;pb, 4, s-&gt;avctx-&gt;level); //level
++   // MEANX pulldown put_bits(&amp;s-&gt;pb, 1, s-&gt;progressive_sequence);
++  // MEANX Pulldown
++ if(s-&gt;flags2 &amp; CODEC_FLAG2_32_PULLDOWN) //MEANX
++                        put_bits(&amp;s-&gt;pb, 1, 0);
++                else
++                        put_bits(&amp;s-&gt;pb, 1, s-&gt;progressive_sequence);
++
++
++// /MEANX
++
+ 
+-                put_bits(&amp;s-&gt;pb, 1, s-&gt;progressive_sequence);
+                 put_bits(&amp;s-&gt;pb, 2, s-&gt;chroma_format);
+                 put_bits(&amp;s-&gt;pb, 2, s-&gt;width &gt;&gt;12);
+                 put_bits(&amp;s-&gt;pb, 2, s-&gt;height&gt;&gt;12);
+@@ -339,6 +382,8 @@ void ff_mpeg1_encode_slice_header(MpegEncContext *s){
+ 
+ void mpeg1_encode_picture_header(MpegEncContext *s, int picture_number)
+ {
++	int tff,rff; //MEANX
++
+     mpeg1_encode_sequence_header(s);
+ 
+     /* mpeg1 picture header */
+@@ -375,6 +420,49 @@ void mpeg1_encode_picture_header(MpegEncContext *s, int picture_number)
+ 
+     s-&gt;frame_pred_frame_dct = 1;
+     if(s-&gt;codec_id == CODEC_ID_MPEG2VIDEO){
++ /* MEANX -- Pulldown */
++        if(s-&gt;flags2 &amp; CODEC_FLAG2_32_PULLDOWN)
++        {
++        
++                switch((s-&gt;picture_number - 
++                          s-&gt;gop_picture_number)&amp;3)
++                {
++                        case 0:
++                        default:
++                                rff=1;
++                                tff=1;
++                                break;
++                        case 1:
++                                rff=0;
++                                tff=0;
++                                break;
++                        case 2:
++                                rff=1;
++                                tff=0;
++                                break;
++                        case 3:
++                                rff=0;
++                                tff=1;
++                                break;
++                }               
++           }
++        else
++        {
++                if (s-&gt;progressive_sequence) 
++                {
++                        tff=0; /* no repeat */
++                } else 
++                {
++                        tff= s-&gt;current_picture_ptr-&gt;top_field_first;
++                }
++                rff=s-&gt;repeat_first_field;
++        
++        }
++
++//               /MEANX pulldown
++
++
++
+         put_header(s, EXT_START_CODE);
+         put_bits(&amp;s-&gt;pb, 4, 8); //pic ext
+         if (s-&gt;pict_type == FF_P_TYPE || s-&gt;pict_type == FF_B_TYPE) {
+@@ -393,11 +481,16 @@ void mpeg1_encode_picture_header(MpegEncContext *s, int picture_number)
+ 
+         assert(s-&gt;picture_structure == PICT_FRAME);
+         put_bits(&amp;s-&gt;pb, 2, s-&gt;picture_structure);
++#if 0 //MEANX
++
+         if (s-&gt;progressive_sequence) {
+             put_bits(&amp;s-&gt;pb, 1, 0); /* no repeat */
+         } else {
+             put_bits(&amp;s-&gt;pb, 1, s-&gt;current_picture_ptr-&gt;top_field_first);
+         }
++#endif
++         put_bits(&amp;s-&gt;pb, 1, tff);  //MEANX PULLDOWN
++
+         /* XXX: optimize the generation of this flag with entropy
+            measures */
+         s-&gt;frame_pred_frame_dct = s-&gt;progressive_sequence;
+@@ -407,7 +500,10 @@ void mpeg1_encode_picture_header(MpegEncContext *s, int picture_number)
+         put_bits(&amp;s-&gt;pb, 1, s-&gt;q_scale_type);
+         put_bits(&amp;s-&gt;pb, 1, s-&gt;intra_vlc_format);
+         put_bits(&amp;s-&gt;pb, 1, s-&gt;alternate_scan);
+-        put_bits(&amp;s-&gt;pb, 1, s-&gt;repeat_first_field);
++ // MEANX put_bits(&amp;s-&gt;pb, 1, s-&gt;repeat_first_field);
++	put_bits(&amp;s-&gt;pb, 1, rff);
++      // /MEANX
++
+         s-&gt;progressive_frame = s-&gt;progressive_sequence;
+         put_bits(&amp;s-&gt;pb, 1, s-&gt;chroma_format == CHROMA_420 ? s-&gt;progressive_frame : 0); /* chroma_420_type */
+         put_bits(&amp;s-&gt;pb, 1, s-&gt;progressive_frame);

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/mpegvideo.c.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/mpegvideo.c.patch	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/mpegvideo.c.patch	2010-07-25 10:07:52 UTC (rev 6483)
@@ -0,0 +1,17 @@
+diff --git a/avidemux_core/ADM_ffmpeg/libavcodec/mpegvideo.c b/avidemux_core/ADM_ffmpeg/libavcodec/mpegvideo.c
+index 684bdfe..2135c3d 100644
+--- a/avidemux_core/ADM_ffmpeg/libavcodec/mpegvideo.c
++++ b/avidemux_core/ADM_ffmpeg/libavcodec/mpegvideo.c
+@@ -652,7 +652,11 @@ av_cold int MPV_common_init(MpegEncContext *s)
+     FF_ALLOCZ_OR_GOTO(s-&gt;avctx, s-&gt;prev_pict_types, PREV_PICT_TYPES_BUFFER_SIZE, fail);
+ 
+     s-&gt;parse_context.state= -1;
+-    if((s-&gt;avctx-&gt;debug&amp;(FF_DEBUG_VIS_QP|FF_DEBUG_VIS_MB_TYPE)) || (s-&gt;avctx-&gt;debug_mv)){
++ //MEANX: Allocate them always, as they may be free when we decode 1st image
++
++    // MEANXif((s-&gt;avctx-&gt;debug&amp;(FF_DEBUG_VIS_QP|FF_DEBUG_VIS_MB_TYPE)) || (s-&gt;avctx-&gt;debug_mv)){
++if(1){ // MEANX
++
+        s-&gt;visualization_buffer[0] = av_malloc((s-&gt;mb_width*16 + 2*EDGE_WIDTH) * s-&gt;mb_height*16 + 2*EDGE_WIDTH);
+        s-&gt;visualization_buffer[1] = av_malloc((s-&gt;mb_width*16 + 2*EDGE_WIDTH) * s-&gt;mb_height*16 + 2*EDGE_WIDTH);
+        s-&gt;visualization_buffer[2] = av_malloc((s-&gt;mb_width*16 + 2*EDGE_WIDTH) * s-&gt;mb_height*16 + 2*EDGE_WIDTH);

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/mpegvideo_enc.c.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/mpegvideo_enc.c.patch	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/mpegvideo_enc.c.patch	2010-07-25 10:07:52 UTC (rev 6483)
@@ -0,0 +1,32 @@
+diff --git a/avidemux_core/ADM_ffmpeg/libavcodec/mpegvideo_enc.c b/avidemux_core/ADM_ffmpeg/libavcodec/mpegvideo_enc.c
+index 9f8682c..1f296a5 100644
+--- a/avidemux_core/ADM_ffmpeg/libavcodec/mpegvideo_enc.c
++++ b/avidemux_core/ADM_ffmpeg/libavcodec/mpegvideo_enc.c
+@@ -367,12 +367,14 @@ av_cold int MPV_encode_init(AVCodecContext *avctx)
+ 
+         av_log(avctx, AV_LOG_INFO, &quot;Warning vbv_delay will be set to 0xFFFF (=VBR) as the specified vbv buffer is too large for the given bitrate!\n&quot;);
+     }
++#if 0 //MEANX
+ 
+     if((s-&gt;flags &amp; CODEC_FLAG_4MV) &amp;&amp; s-&gt;codec_id != CODEC_ID_MPEG4
+        &amp;&amp; s-&gt;codec_id != CODEC_ID_H263 &amp;&amp; s-&gt;codec_id != CODEC_ID_H263P &amp;&amp; s-&gt;codec_id != CODEC_ID_FLV1){
+         av_log(avctx, AV_LOG_ERROR, &quot;4MV not supported by codec\n&quot;);
+         return -1;
+     }
++#endif
+ 
+     if(s-&gt;obmc &amp;&amp; s-&gt;avctx-&gt;mb_decision != FF_MB_DECISION_SIMPLE){
+         av_log(avctx, AV_LOG_ERROR, &quot;OBMC is only supported with simple mb decision\n&quot;);
+@@ -413,10 +415,12 @@ av_cold int MPV_encode_init(AVCodecContext *avctx)
+         return -1;
+     }
+ 
++#if 0 //MEANX
+     if(s-&gt;mpeg_quant &amp;&amp; s-&gt;codec_id != CODEC_ID_MPEG4){ //FIXME mpeg2 uses that too
+         av_log(avctx, AV_LOG_ERROR, &quot;mpeg2 style quantization not supported by codec\n&quot;);
+         return -1;
+     }
++#endif
+ 
+     if((s-&gt;flags &amp; CODEC_FLAG_CBP_RD) &amp;&amp; !avctx-&gt;trellis){
+         av_log(avctx, AV_LOG_ERROR, &quot;CBP RD needs trellis quant\n&quot;);

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/png.c.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/png.c.patch	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/png.c.patch	2010-07-25 10:07:52 UTC (rev 6483)
@@ -0,0 +1,13 @@
+diff --git a/avidemux_core/ADM_ffmpeg/libavcodec/png.c b/avidemux_core/ADM_ffmpeg/libavcodec/png.c
+index 534dc68..1a6e137 100644
+--- a/avidemux_core/ADM_ffmpeg/libavcodec/png.c
++++ b/avidemux_core/ADM_ffmpeg/libavcodec/png.c
+@@ -20,7 +20,7 @@
+  */
+ #include &quot;avcodec.h&quot;
+ #include &quot;bytestream.h&quot;
+-#include &quot;png.h&quot;
++#include &quot;ffpng.h&quot;
+ 
+ const uint8_t ff_pngsig[8] = {137, 80, 78, 71, 13, 10, 26, 10};
+ const uint8_t ff_mngsig[8] = {138, 77, 78, 71, 13, 10, 26, 10};

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/pngdec.c.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/pngdec.c.patch	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/pngdec.c.patch	2010-07-25 10:07:52 UTC (rev 6483)
@@ -0,0 +1,13 @@
+diff --git a/avidemux_core/ADM_ffmpeg/libavcodec/pngdec.c b/avidemux_core/ADM_ffmpeg/libavcodec/pngdec.c
+index 037c5a0..6546567 100644
+--- a/avidemux_core/ADM_ffmpeg/libavcodec/pngdec.c
++++ b/avidemux_core/ADM_ffmpeg/libavcodec/pngdec.c
+@@ -20,7 +20,7 @@
+  */
+ #include &quot;avcodec.h&quot;
+ #include &quot;bytestream.h&quot;
+-#include &quot;png.h&quot;
++#include &quot;ffpng.h&quot;
+ #include &quot;dsputil.h&quot;
+ 
+ /* TODO:

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/pngenc.c.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/pngenc.c.patch	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/pngenc.c.patch	2010-07-25 10:07:52 UTC (rev 6483)
@@ -0,0 +1,13 @@
+diff --git a/avidemux_core/ADM_ffmpeg/libavcodec/pngenc.c b/avidemux_core/ADM_ffmpeg/libavcodec/pngenc.c
+index d199b95..b63c84e 100644
+--- a/avidemux_core/ADM_ffmpeg/libavcodec/pngenc.c
++++ b/avidemux_core/ADM_ffmpeg/libavcodec/pngenc.c
+@@ -21,7 +21,7 @@
+ #include &quot;avcodec.h&quot;
+ #include &quot;bytestream.h&quot;
+ #include &quot;dsputil.h&quot;
+-#include &quot;png.h&quot;
++#include &quot;ffpng.h&quot;
+ 
+ /* TODO:
+  * - add 2, 4 and 16 bit depth support

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/utils.c.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/utils.c.patch	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/utils.c.patch	2010-07-25 10:07:52 UTC (rev 6483)
@@ -0,0 +1,33 @@
+diff --git a/avidemux_core/ADM_ffmpeg/libavcodec/utils.c b/avidemux_core/ADM_ffmpeg/libavcodec/utils.c
+index f21e9ed..acd1078 100644
+--- a/avidemux_core/ADM_ffmpeg/libavcodec/utils.c
++++ b/avidemux_core/ADM_ffmpeg/libavcodec/utils.c
+@@ -643,10 +643,12 @@ int attribute_align_arg avcodec_decode_audio3(AVCodecContext *avctx, int16_t *sa
+ 
+     if((avctx-&gt;codec-&gt;capabilities &amp; CODEC_CAP_DELAY) || avpkt-&gt;size){
+         //FIXME remove the check below _after_ ensuring that all audio check that the available space is enough
++#if 0 // MEANX : Silence
+         if(*frame_size_ptr &lt; AVCODEC_MAX_AUDIO_FRAME_SIZE){
+             av_log(avctx, AV_LOG_ERROR, &quot;buffer smaller than AVCODEC_MAX_AUDIO_FRAME_SIZE\n&quot;);
+             return -1;
+         }
++#endif
+         if(*frame_size_ptr &lt; FF_MIN_BUFFER_SIZE ||
+         *frame_size_ptr &lt; avctx-&gt;channels * avctx-&gt;frame_size * sizeof(int16_t)){
+             av_log(avctx, AV_LOG_ERROR, &quot;buffer %d too small\n&quot;, *frame_size_ptr);
+@@ -952,13 +954,13 @@ unsigned avcodec_version( void )
+ 
+ const char *avcodec_configuration(void)
+ {
+-    return FFMPEG_CONFIGURATION;
++    return &quot;avidemux&quot;; //FFMPEG_CONFIGURATION;
+ }
+ 
+ const char *avcodec_license(void)
+ {
+ #define LICENSE_PREFIX &quot;libavcodec license: &quot;
+-    return LICENSE_PREFIX FFMPEG_LICENSE + sizeof(LICENSE_PREFIX) - 1;
++    return LICENSE_PREFIX /*FFMPEG_LICENSE*/ &quot;GPL&quot; + sizeof(LICENSE_PREFIX) - 1;
+ }
+ 
+ void avcodec_init(void)

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/x86_mathops.h.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/x86_mathops.h.patch	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avcodec/x86_mathops.h.patch	2010-07-25 10:07:52 UTC (rev 6483)
@@ -0,0 +1,18 @@
+diff --git a/avidemux_core/ADM_ffmpeg/libavcodec/x86/mathops.h b/avidemux_core/ADM_ffmpeg/libavcodec/x86/mathops.h
+index 5949dfe..c30f9df 100644
+--- a/avidemux_core/ADM_ffmpeg/libavcodec/x86/mathops.h
++++ b/avidemux_core/ADM_ffmpeg/libavcodec/x86/mathops.h
+@@ -21,8 +21,12 @@
+ 
+ #ifndef AVCODEC_X86_MATHOPS_H
+ #define AVCODEC_X86_MATHOPS_H
+-
++// MEANX
++#ifndef ADM_NO_CONFIG_H
+ #include &quot;config.h&quot;
++#endif
++// /MEANX
++
+ #include &quot;libavutil/common.h&quot;
+ 
+ #if ARCH_X86_32


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003669.html">[Avidemux-svn-commit] r6482 - in	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale:	. x86
</A></li>
	<LI>Next message: <A HREF="003671.html">[Avidemux-svn-commit] r6484 -	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3670">[ date ]</a>
              <a href="thread.html#3670">[ thread ]</a>
              <a href="subject.html#3670">[ subject ]</a>
              <a href="author.html#3670">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
