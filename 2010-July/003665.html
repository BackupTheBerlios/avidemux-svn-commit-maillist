<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r6478 - in	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg:	libavcodec libavcodec/x86 libavutil
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2010-July/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r6478%20-%20in%0A%09branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg%3A%0A%09libavcodec%20libavcodec/x86%20libavutil&In-Reply-To=%3C20100725100739.8F4B4480E6C%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003664.html">
   <LINK REL="Next"  HREF="003666.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r6478 - in	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg:	libavcodec libavcodec/x86 libavutil</H1>
    <B>mean at mail.berlios.de</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r6478%20-%20in%0A%09branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg%3A%0A%09libavcodec%20libavcodec/x86%20libavutil&In-Reply-To=%3C20100725100739.8F4B4480E6C%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r6478 - in	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg:	libavcodec libavcodec/x86 libavutil">mean at mail.berlios.de
       </A><BR>
    <I>Sun Jul 25 12:07:39 CEST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="003664.html">[Avidemux-svn-commit] r6476 - in	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6:	. resampleFps
</A></li>
        <LI>Next message: <A HREF="003666.html">[Avidemux-svn-commit] r6479 -	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/ffmpeg_config
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3665">[ date ]</a>
              <a href="thread.html#3665">[ thread ]</a>
              <a href="subject.html#3665">[ subject ]</a>
              <a href="author.html#3665">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2010-07-25 12:07:39 +0200 (Sun, 25 Jul 2010)
New Revision: 6478

Added:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aac_tablegen.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aac_tablegen.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aac_tablegen_decl.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aacadtsdec.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aacadtsdec.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aacdec.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/dct32.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/dxva2_mpeg2.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/vp8.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/vp8_parser.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/vp8data.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/vp8dsp.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/vp8dsp.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/x86/dct32_sse.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/x86/h264_intrapred.asm
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/x86/mpegaudiodec_mmx.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/x86/vc1dsp_yasm.asm
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/x86/vp56_arith.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/x86/vp8dsp-init.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/x86/vp8dsp.asm
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/colorspace.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/eval.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/eval.h
Log:
[ff] Import 25 July 2010

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aac_tablegen.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aac_tablegen.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aac_tablegen.c	2010-07-25 10:07:39 UTC (rev 6478)
@@ -0,0 +1,37 @@
+/*
+ * Generate a header file for hardcoded AAC tables
+ *
+ * Copyright (c) 2010 Alex Converse &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">alex.converse at gmail.com</A>&gt;
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include &lt;stdlib.h&gt;
+#define CONFIG_HARDCODED_TABLES 0
+#include &quot;aac_tablegen.h&quot;
+#include &quot;tableprint.h&quot;
+
+int main(void)
+{
+    ff_aac_tableinit();
+
+    write_fileheader();
+
+    WRITE_ARRAY(&quot;const&quot;, float, ff_aac_pow2sf_tab);
+
+    return 0;
+}

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aac_tablegen.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aac_tablegen.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aac_tablegen.h	2010-07-25 10:07:39 UTC (rev 6478)
@@ -0,0 +1,42 @@
+/*
+ * Header file for hardcoded AAC tables
+ *
+ * Copyright (c) 2010 Alex Converse &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">alex.converse at gmail.com</A>&gt;
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AAC_TABLEGEN_H
+#define AAC_TABLEGEN_H
+
+#include &quot;aac_tablegen_decl.h&quot;
+
+#if CONFIG_HARDCODED_TABLES
+#include &quot;libavcodec/aac_tables.h&quot;
+#else
+#include &quot;libavutil/mathematics.h&quot;
+float ff_aac_pow2sf_tab[428];
+
+void ff_aac_tableinit(void)
+{
+    int i;
+    for (i = 0; i &lt; 428; i++)
+        ff_aac_pow2sf_tab[i] = pow(2, (i - 200) / 4.);
+}
+#endif /* CONFIG_HARDCODED_TABLES */
+
+#endif /* AAC_TABLEGEN_H */

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aac_tablegen_decl.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aac_tablegen_decl.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aac_tablegen_decl.h	2010-07-25 10:07:39 UTC (rev 6478)
@@ -0,0 +1,34 @@
+/*
+ * Header file for hardcoded AAC tables
+ *
+ * Copyright (c) 2010 Alex Converse &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">alex.converse at gmail.com</A>&gt;
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AAC_TABLEGEN_INIT_H
+#define AAC_TABLEGEN_INIT_H
+
+#if CONFIG_HARDCODED_TABLES
+#define ff_aac_tableinit()
+extern const float ff_aac_pow2sf_tab[428];
+#else
+void ff_aac_tableinit(void);
+extern       float ff_aac_pow2sf_tab[428];
+#endif /* CONFIG_HARDCODED_TABLES */
+
+#endif /* AAC_TABLEGEN_INIT_H */

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aacadtsdec.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aacadtsdec.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aacadtsdec.c	2010-07-25 10:07:39 UTC (rev 6478)
@@ -0,0 +1,70 @@
+/*
+ * Audio and Video frame extraction
+ * Copyright (c) 2003 Fabrice Bellard
+ * Copyright (c) 2003 Michael Niedermayer
+ * Copyright (c) 2009 Alex Converse
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include &quot;aac_ac3_parser.h&quot;
+#include &quot;aacadtsdec.h&quot;
+#include &quot;get_bits.h&quot;
+#include &quot;mpeg4audio.h&quot;
+
+int ff_aac_parse_header(GetBitContext *gbc, AACADTSHeaderInfo *hdr)
+{
+    int size, rdb, ch, sr;
+    int aot, crc_abs;
+
+    if(get_bits(gbc, 12) != 0xfff)
+        return AAC_AC3_PARSE_ERROR_SYNC;
+
+    skip_bits1(gbc);             /* id */
+    skip_bits(gbc, 2);           /* layer */
+    crc_abs = get_bits1(gbc);    /* protection_absent */
+    aot     = get_bits(gbc, 2);  /* profile_objecttype */
+    sr      = get_bits(gbc, 4);  /* sample_frequency_index */
+    if(!ff_mpeg4audio_sample_rates[sr])
+        return AAC_AC3_PARSE_ERROR_SAMPLE_RATE;
+    skip_bits1(gbc);             /* private_bit */
+    ch      = get_bits(gbc, 3);  /* channel_configuration */
+
+    skip_bits1(gbc);             /* original/copy */
+    skip_bits1(gbc);             /* home */
+
+    /* adts_variable_header */
+    skip_bits1(gbc);             /* copyright_identification_bit */
+    skip_bits1(gbc);             /* copyright_identification_start */
+    size    = get_bits(gbc, 13); /* aac_frame_length */
+    if(size &lt; AAC_ADTS_HEADER_SIZE)
+        return AAC_AC3_PARSE_ERROR_FRAME_SIZE;
+
+    skip_bits(gbc, 11);          /* adts_buffer_fullness */
+    rdb = get_bits(gbc, 2);      /* number_of_raw_data_blocks_in_frame */
+
+    hdr-&gt;object_type    = aot + 1;
+    hdr-&gt;chan_config    = ch;
+    hdr-&gt;crc_absent     = crc_abs;
+    hdr-&gt;num_aac_frames = rdb + 1;
+    hdr-&gt;sampling_index = sr;
+    hdr-&gt;sample_rate    = ff_mpeg4audio_sample_rates[sr];
+    hdr-&gt;samples        = (rdb + 1) * 1024;
+    hdr-&gt;bit_rate       = size * 8 * hdr-&gt;sample_rate / hdr-&gt;samples;
+
+    return size;
+}

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aacadtsdec.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aacadtsdec.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aacadtsdec.h	2010-07-25 10:07:39 UTC (rev 6478)
@@ -0,0 +1,54 @@
+/*
+ * AAC ADTS header decoding prototypes and structures
+ * Copyright (c) 2003 Fabrice Bellard
+ * Copyright (c) 2003 Michael Niedermayer
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_AACADTSDEC_H
+#define AVCODEC_AACADTSDEC_H
+
+#include &lt;stdint.h&gt;
+#include &quot;get_bits.h&quot;
+
+#define AAC_ADTS_HEADER_SIZE 7
+
+typedef struct {
+    uint32_t sample_rate;
+    uint32_t samples;
+    uint32_t bit_rate;
+    uint8_t  crc_absent;
+    uint8_t  object_type;
+    uint8_t  sampling_index;
+    uint8_t  chan_config;
+    uint8_t  num_aac_frames;
+} AACADTSHeaderInfo;
+
+/**
+ * Parse AAC frame header.
+ * Parse the ADTS frame header to the end of the variable header, which is
+ * the first 54 bits.
+ * @param[in]  gbc BitContext containing the first 54 bits of the frame.
+ * @param[out] hdr Pointer to struct where header info is written.
+ * @return Returns 0 on success, -1 if there is a sync word mismatch,
+ * -2 if the version element is invalid, -3 if the sample rate
+ * element is invalid, or -4 if the bit rate element is invalid.
+ */
+int ff_aac_parse_header(GetBitContext *gbc, AACADTSHeaderInfo *hdr);
+
+#endif /* AVCODEC_AACADTSDEC_H */

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aacdec.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aacdec.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/aacdec.c	2010-07-25 10:07:39 UTC (rev 6478)
@@ -0,0 +1,2109 @@
+/*
+ * AAC decoder
+ * Copyright (c) 2005-2006 Oded Shimon ( ods15 ods15 dyndns org )
+ * Copyright (c) 2006-2007 Maxim Gavrilov ( maxim.gavrilov gmail com )
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * AAC decoder
+ * @author Oded Shimon  ( ods15 ods15 dyndns org )
+ * @author Maxim Gavrilov ( maxim.gavrilov gmail com )
+ */
+
+/*
+ * supported tools
+ *
+ * Support?             Name
+ * N (code in SoC repo) gain control
+ * Y                    block switching
+ * Y                    window shapes - standard
+ * N                    window shapes - Low Delay
+ * Y                    filterbank - standard
+ * N (code in SoC repo) filterbank - Scalable Sample Rate
+ * Y                    Temporal Noise Shaping
+ * N (code in SoC repo) Long Term Prediction
+ * Y                    intensity stereo
+ * Y                    channel coupling
+ * Y                    frequency domain prediction
+ * Y                    Perceptual Noise Substitution
+ * Y                    Mid/Side stereo
+ * N                    Scalable Inverse AAC Quantization
+ * N                    Frequency Selective Switch
+ * N                    upsampling filter
+ * Y                    quantization &amp; coding - AAC
+ * N                    quantization &amp; coding - TwinVQ
+ * N                    quantization &amp; coding - BSAC
+ * N                    AAC Error Resilience tools
+ * N                    Error Resilience payload syntax
+ * N                    Error Protection tool
+ * N                    CELP
+ * N                    Silence Compression
+ * N                    HVXC
+ * N                    HVXC 4kbits/s VR
+ * N                    Structured Audio tools
+ * N                    Structured Audio Sample Bank Format
+ * N                    MIDI
+ * N                    Harmonic and Individual Lines plus Noise
+ * N                    Text-To-Speech Interface
+ * Y                    Spectral Band Replication
+ * Y (not in this code) Layer-1
+ * Y (not in this code) Layer-2
+ * Y (not in this code) Layer-3
+ * N                    SinuSoidal Coding (Transient, Sinusoid, Noise)
+ * Y                    Parametric Stereo
+ * N                    Direct Stream Transfer
+ *
+ * Note: - HE AAC v1 comprises LC AAC with Spectral Band Replication.
+ *       - HE AAC v2 comprises LC AAC with Spectral Band Replication and
+           Parametric Stereo.
+ */
+
+
+#include &quot;avcodec.h&quot;
+#include &quot;internal.h&quot;
+#include &quot;get_bits.h&quot;
+#include &quot;dsputil.h&quot;
+#include &quot;fft.h&quot;
+#include &quot;lpc.h&quot;
+
+#include &quot;aac.h&quot;
+#include &quot;aactab.h&quot;
+#include &quot;aacdectab.h&quot;
+#include &quot;cbrt_tablegen.h&quot;
+#include &quot;sbr.h&quot;
+#include &quot;aacsbr.h&quot;
+#include &quot;mpeg4audio.h&quot;
+#include &quot;aacadtsdec.h&quot;
+
+#include &lt;assert.h&gt;
+#include &lt;errno.h&gt;
+#include &lt;math.h&gt;
+#include &lt;string.h&gt;
+
+#if ARCH_ARM
+#   include &quot;arm/aac.h&quot;
+#endif
+
+union float754 {
+    float f;
+    uint32_t i;
+};
+
+static VLC vlc_scalefactors;
+static VLC vlc_spectral[11];
+
+static const char overread_err[] = &quot;Input buffer exhausted before END element found\n&quot;;
+
+static ChannelElement *get_che(AACContext *ac, int type, int elem_id)
+{
+    /* Some buggy encoders appear to set all elem_ids to zero and rely on
+    channels always occurring in the same order. This is expressly forbidden
+    by the spec but we will try to work around it.
+    */
+    int err_printed = 0;
+    while (ac-&gt;tags_seen_this_frame[type][elem_id] &amp;&amp; elem_id &lt; MAX_ELEM_ID) {
+        if (ac-&gt;output_configured &lt; OC_LOCKED &amp;&amp; !err_printed) {
+            av_log(ac-&gt;avctx, AV_LOG_WARNING, &quot;Duplicate channel tag found, attempting to remap.\n&quot;);
+            err_printed = 1;
+        }
+        elem_id++;
+    }
+    if (elem_id == MAX_ELEM_ID)
+        return NULL;
+    ac-&gt;tags_seen_this_frame[type][elem_id] = 1;
+
+    if (ac-&gt;tag_che_map[type][elem_id]) {
+        return ac-&gt;tag_che_map[type][elem_id];
+    }
+    if (ac-&gt;tags_mapped &gt;= tags_per_config[ac-&gt;m4ac.chan_config]) {
+        return NULL;
+    }
+    switch (ac-&gt;m4ac.chan_config) {
+    case 7:
+        if (ac-&gt;tags_mapped == 3 &amp;&amp; type == TYPE_CPE) {
+            ac-&gt;tags_mapped++;
+            return ac-&gt;tag_che_map[TYPE_CPE][elem_id] = ac-&gt;che[TYPE_CPE][2];
+        }
+    case 6:
+        /* Some streams incorrectly code 5.1 audio as SCE[0] CPE[0] CPE[1] SCE[1]
+           instead of SCE[0] CPE[0] CPE[1] LFE[0]. If we seem to have
+           encountered such a stream, transfer the LFE[0] element to the SCE[1]'s mapping */
+        if (ac-&gt;tags_mapped == tags_per_config[ac-&gt;m4ac.chan_config] - 1 &amp;&amp; (type == TYPE_LFE || type == TYPE_SCE)) {
+            ac-&gt;tags_mapped++;
+            return ac-&gt;tag_che_map[type][elem_id] = ac-&gt;che[TYPE_LFE][0];
+        }
+    case 5:
+        if (ac-&gt;tags_mapped == 2 &amp;&amp; type == TYPE_CPE) {
+            ac-&gt;tags_mapped++;
+            return ac-&gt;tag_che_map[TYPE_CPE][elem_id] = ac-&gt;che[TYPE_CPE][1];
+        }
+    case 4:
+        if (ac-&gt;tags_mapped == 2 &amp;&amp; ac-&gt;m4ac.chan_config == 4 &amp;&amp; type == TYPE_SCE) {
+            ac-&gt;tags_mapped++;
+            return ac-&gt;tag_che_map[TYPE_SCE][elem_id] = ac-&gt;che[TYPE_SCE][1];
+        }
+    case 3:
+    case 2:
+        if (ac-&gt;tags_mapped == (ac-&gt;m4ac.chan_config != 2) &amp;&amp; type == TYPE_CPE) {
+            ac-&gt;tags_mapped++;
+            return ac-&gt;tag_che_map[TYPE_CPE][elem_id] = ac-&gt;che[TYPE_CPE][0];
+        } else if (ac-&gt;m4ac.chan_config == 2) {
+            return NULL;
+        }
+    case 1:
+        if (!ac-&gt;tags_mapped &amp;&amp; type == TYPE_SCE) {
+            ac-&gt;tags_mapped++;
+            return ac-&gt;tag_che_map[TYPE_SCE][elem_id] = ac-&gt;che[TYPE_SCE][0];
+        }
+    default:
+        return NULL;
+    }
+}
+
+/**
+ * Check for the channel element in the current channel position configuration.
+ * If it exists, make sure the appropriate element is allocated and map the
+ * channel order to match the internal FFmpeg channel layout.
+ *
+ * @param   che_pos current channel position configuration
+ * @param   type channel element type
+ * @param   id channel element id
+ * @param   channels count of the number of channels in the configuration
+ *
+ * @return  Returns error status. 0 - OK, !0 - error
+ */
+static av_cold int che_configure(AACContext *ac,
+                         enum ChannelPosition che_pos[4][MAX_ELEM_ID],
+                         int type, int id,
+                         int *channels)
+{
+    if (che_pos[type][id]) {
+        if (!ac-&gt;che[type][id] &amp;&amp; !(ac-&gt;che[type][id] = av_mallocz(sizeof(ChannelElement))))
+            return AVERROR(ENOMEM);
+        ff_aac_sbr_ctx_init(&amp;ac-&gt;che[type][id]-&gt;sbr);
+        if (type != TYPE_CCE) {
+            ac-&gt;output_data[(*channels)++] = ac-&gt;che[type][id]-&gt;ch[0].ret;
+            if (type == TYPE_CPE ||
+                (type == TYPE_SCE &amp;&amp; ac-&gt;m4ac.ps == 1)) {
+                ac-&gt;output_data[(*channels)++] = ac-&gt;che[type][id]-&gt;ch[1].ret;
+            }
+        }
+    } else {
+        if (ac-&gt;che[type][id])
+            ff_aac_sbr_ctx_close(&amp;ac-&gt;che[type][id]-&gt;sbr);
+        av_freep(&amp;ac-&gt;che[type][id]);
+    }
+    return 0;
+}
+
+/**
+ * Configure output channel order based on the current program configuration element.
+ *
+ * @param   che_pos current channel position configuration
+ * @param   new_che_pos New channel position configuration - we only do something if it differs from the current one.
+ *
+ * @return  Returns error status. 0 - OK, !0 - error
+ */
+static av_cold int output_configure(AACContext *ac,
+                            enum ChannelPosition che_pos[4][MAX_ELEM_ID],
+                            enum ChannelPosition new_che_pos[4][MAX_ELEM_ID],
+                            int channel_config, enum OCStatus oc_type)
+{
+    AVCodecContext *avctx = ac-&gt;avctx;
+    int i, type, channels = 0, ret;
+
+    if (new_che_pos != che_pos)
+    memcpy(che_pos, new_che_pos, 4 * MAX_ELEM_ID * sizeof(new_che_pos[0][0]));
+
+    if (channel_config) {
+        for (i = 0; i &lt; tags_per_config[channel_config]; i++) {
+            if ((ret = che_configure(ac, che_pos,
+                                     aac_channel_layout_map[channel_config - 1][i][0],
+                                     aac_channel_layout_map[channel_config - 1][i][1],
+                                     &amp;channels)))
+                return ret;
+        }
+
+        memset(ac-&gt;tag_che_map, 0,       4 * MAX_ELEM_ID * sizeof(ac-&gt;che[0][0]));
+        ac-&gt;tags_mapped = 0;
+
+        avctx-&gt;channel_layout = aac_channel_layout[channel_config - 1];
+    } else {
+        /* Allocate or free elements depending on if they are in the
+         * current program configuration.
+         *
+         * Set up default 1:1 output mapping.
+         *
+         * For a 5.1 stream the output order will be:
+         *    [ Center ] [ Front Left ] [ Front Right ] [ LFE ] [ Surround Left ] [ Surround Right ]
+         */
+
+        for (i = 0; i &lt; MAX_ELEM_ID; i++) {
+            for (type = 0; type &lt; 4; type++) {
+                if ((ret = che_configure(ac, che_pos, type, i, &amp;channels)))
+                    return ret;
+            }
+        }
+
+        memcpy(ac-&gt;tag_che_map, ac-&gt;che, 4 * MAX_ELEM_ID * sizeof(ac-&gt;che[0][0]));
+        ac-&gt;tags_mapped = 4 * MAX_ELEM_ID;
+
+        avctx-&gt;channel_layout = 0;
+    }
+
+    avctx-&gt;channels = channels;
+
+    ac-&gt;output_configured = oc_type;
+
+    return 0;
+}
+
+/**
+ * Decode an array of 4 bit element IDs, optionally interleaved with a stereo/mono switching bit.
+ *
+ * @param cpe_map Stereo (Channel Pair Element) map, NULL if stereo bit is not present.
+ * @param sce_map mono (Single Channel Element) map
+ * @param type speaker type/position for these channels
+ */
+static void decode_channel_map(enum ChannelPosition *cpe_map,
+                               enum ChannelPosition *sce_map,
+                               enum ChannelPosition type,
+                               GetBitContext *gb, int n)
+{
+    while (n--) {
+        enum ChannelPosition *map = cpe_map &amp;&amp; get_bits1(gb) ? cpe_map : sce_map; // stereo or mono map
+        map[get_bits(gb, 4)] = type;
+    }
+}
+
+/**
+ * Decode program configuration element; reference: table 4.2.
+ *
+ * @param   new_che_pos New channel position configuration - we only do something if it differs from the current one.
+ *
+ * @return  Returns error status. 0 - OK, !0 - error
+ */
+static int decode_pce(AACContext *ac, enum ChannelPosition new_che_pos[4][MAX_ELEM_ID],
+                      GetBitContext *gb)
+{
+    int num_front, num_side, num_back, num_lfe, num_assoc_data, num_cc, sampling_index;
+    int comment_len;
+
+    skip_bits(gb, 2);  // object_type
+
+    sampling_index = get_bits(gb, 4);
+    if (ac-&gt;m4ac.sampling_index != sampling_index)
+        av_log(ac-&gt;avctx, AV_LOG_WARNING, &quot;Sample rate index in program config element does not match the sample rate index configured by the container.\n&quot;);
+
+    num_front       = get_bits(gb, 4);
+    num_side        = get_bits(gb, 4);
+    num_back        = get_bits(gb, 4);
+    num_lfe         = get_bits(gb, 2);
+    num_assoc_data  = get_bits(gb, 3);
+    num_cc          = get_bits(gb, 4);
+
+    if (get_bits1(gb))
+        skip_bits(gb, 4); // mono_mixdown_tag
+    if (get_bits1(gb))
+        skip_bits(gb, 4); // stereo_mixdown_tag
+
+    if (get_bits1(gb))
+        skip_bits(gb, 3); // mixdown_coeff_index and pseudo_surround
+
+    decode_channel_map(new_che_pos[TYPE_CPE], new_che_pos[TYPE_SCE], AAC_CHANNEL_FRONT, gb, num_front);
+    decode_channel_map(new_che_pos[TYPE_CPE], new_che_pos[TYPE_SCE], AAC_CHANNEL_SIDE,  gb, num_side );
+    decode_channel_map(new_che_pos[TYPE_CPE], new_che_pos[TYPE_SCE], AAC_CHANNEL_BACK,  gb, num_back );
+    decode_channel_map(NULL,                  new_che_pos[TYPE_LFE], AAC_CHANNEL_LFE,   gb, num_lfe  );
+
+    skip_bits_long(gb, 4 * num_assoc_data);
+
+    decode_channel_map(new_che_pos[TYPE_CCE], new_che_pos[TYPE_CCE], AAC_CHANNEL_CC,    gb, num_cc   );
+
+    align_get_bits(gb);
+
+    /* comment field, first byte is length */
+    comment_len = get_bits(gb, 8) * 8;
+    if (get_bits_left(gb) &lt; comment_len) {
+        av_log(ac-&gt;avctx, AV_LOG_ERROR, overread_err);
+        return -1;
+    }
+    skip_bits_long(gb, comment_len);
+    return 0;
+}
+
+/**
+ * Set up channel positions based on a default channel configuration
+ * as specified in table 1.17.
+ *
+ * @param   new_che_pos New channel position configuration - we only do something if it differs from the current one.
+ *
+ * @return  Returns error status. 0 - OK, !0 - error
+ */
+static av_cold int set_default_channel_config(AACContext *ac,
+                                      enum ChannelPosition new_che_pos[4][MAX_ELEM_ID],
+                                      int channel_config)
+{
+    if (channel_config &lt; 1 || channel_config &gt; 7) {
+        av_log(ac-&gt;avctx, AV_LOG_ERROR, &quot;invalid default channel configuration (%d)\n&quot;,
+               channel_config);
+        return -1;
+    }
+
+    /* default channel configurations:
+     *
+     * 1ch : front center (mono)
+     * 2ch : L + R (stereo)
+     * 3ch : front center + L + R
+     * 4ch : front center + L + R + back center
+     * 5ch : front center + L + R + back stereo
+     * 6ch : front center + L + R + back stereo + LFE
+     * 7ch : front center + L + R + outer front left + outer front right + back stereo + LFE
+     */
+
+    if (channel_config != 2)
+        new_che_pos[TYPE_SCE][0] = AAC_CHANNEL_FRONT; // front center (or mono)
+    if (channel_config &gt; 1)
+        new_che_pos[TYPE_CPE][0] = AAC_CHANNEL_FRONT; // L + R (or stereo)
+    if (channel_config == 4)
+        new_che_pos[TYPE_SCE][1] = AAC_CHANNEL_BACK;  // back center
+    if (channel_config &gt; 4)
+        new_che_pos[TYPE_CPE][(channel_config == 7) + 1]
+        = AAC_CHANNEL_BACK;  // back stereo
+    if (channel_config &gt; 5)
+        new_che_pos[TYPE_LFE][0] = AAC_CHANNEL_LFE;   // LFE
+    if (channel_config == 7)
+        new_che_pos[TYPE_CPE][1] = AAC_CHANNEL_FRONT; // outer front left + outer front right
+
+    return 0;
+}
+
+/**
+ * Decode GA &quot;General Audio&quot; specific configuration; reference: table 4.1.
+ *
+ * @return  Returns error status. 0 - OK, !0 - error
+ */
+static int decode_ga_specific_config(AACContext *ac, GetBitContext *gb,
+                                     int channel_config)
+{
+    enum ChannelPosition new_che_pos[4][MAX_ELEM_ID];
+    int extension_flag, ret;
+
+    if (get_bits1(gb)) { // frameLengthFlag
+        av_log_missing_feature(ac-&gt;avctx, &quot;960/120 MDCT window is&quot;, 1);
+        return -1;
+    }
+
+    if (get_bits1(gb))       // dependsOnCoreCoder
+        skip_bits(gb, 14);   // coreCoderDelay
+    extension_flag = get_bits1(gb);
+
+    if (ac-&gt;m4ac.object_type == AOT_AAC_SCALABLE ||
+        ac-&gt;m4ac.object_type == AOT_ER_AAC_SCALABLE)
+        skip_bits(gb, 3);     // layerNr
+
+    memset(new_che_pos, 0, 4 * MAX_ELEM_ID * sizeof(new_che_pos[0][0]));
+    if (channel_config == 0) {
+        skip_bits(gb, 4);  // element_instance_tag
+        if ((ret = decode_pce(ac, new_che_pos, gb)))
+            return ret;
+    } else {
+        if ((ret = set_default_channel_config(ac, new_che_pos, channel_config)))
+            return ret;
+    }
+    if ((ret = output_configure(ac, ac-&gt;che_pos, new_che_pos, channel_config, OC_GLOBAL_HDR)))
+        return ret;
+
+    if (extension_flag) {
+        switch (ac-&gt;m4ac.object_type) {
+        case AOT_ER_BSAC:
+            skip_bits(gb, 5);    // numOfSubFrame
+            skip_bits(gb, 11);   // layer_length
+            break;
+        case AOT_ER_AAC_LC:
+        case AOT_ER_AAC_LTP:
+        case AOT_ER_AAC_SCALABLE:
+        case AOT_ER_AAC_LD:
+            skip_bits(gb, 3);  /* aacSectionDataResilienceFlag
+                                    * aacScalefactorDataResilienceFlag
+                                    * aacSpectralDataResilienceFlag
+                                    */
+            break;
+        }
+        skip_bits1(gb);    // extensionFlag3 (TBD in version 3)
+    }
+    return 0;
+}
+
+/**
+ * Decode audio specific configuration; reference: table 1.13.
+ *
+ * @param   data        pointer to AVCodecContext extradata
+ * @param   data_size   size of AVCCodecContext extradata
+ *
+ * @return  Returns error status. 0 - OK, !0 - error
+ */
+static int decode_audio_specific_config(AACContext *ac, void *data,
+                                        int data_size)
+{
+    GetBitContext gb;
+    int i;
+
+    init_get_bits(&amp;gb, data, data_size * 8);
+
+    if ((i = ff_mpeg4audio_get_config(&amp;ac-&gt;m4ac, data, data_size)) &lt; 0)
+        return -1;
+    if (ac-&gt;m4ac.sampling_index &gt; 12) {
+        av_log(ac-&gt;avctx, AV_LOG_ERROR, &quot;invalid sampling rate index %d\n&quot;, ac-&gt;m4ac.sampling_index);
+        return -1;
+    }
+    if (ac-&gt;m4ac.sbr == 1 &amp;&amp; ac-&gt;m4ac.ps == -1)
+        ac-&gt;m4ac.ps = 1;
+
+    skip_bits_long(&amp;gb, i);
+
+    switch (ac-&gt;m4ac.object_type) {
+    case AOT_AAC_MAIN:
+    case AOT_AAC_LC:
+        if (decode_ga_specific_config(ac, &amp;gb, ac-&gt;m4ac.chan_config))
+            return -1;
+        break;
+    default:
+        av_log(ac-&gt;avctx, AV_LOG_ERROR, &quot;Audio object type %s%d is not supported.\n&quot;,
+               ac-&gt;m4ac.sbr == 1? &quot;SBR+&quot; : &quot;&quot;, ac-&gt;m4ac.object_type);
+        return -1;
+    }
+    return 0;
+}
+
+/**
+ * linear congruential pseudorandom number generator
+ *
+ * @param   previous_val    pointer to the current state of the generator
+ *
+ * @return  Returns a 32-bit pseudorandom integer
+ */
+static av_always_inline int lcg_random(int previous_val)
+{
+    return previous_val * 1664525 + 1013904223;
+}
+
+static av_always_inline void reset_predict_state(PredictorState *ps)
+{
+    ps-&gt;r0   = 0.0f;
+    ps-&gt;r1   = 0.0f;
+    ps-&gt;cor0 = 0.0f;
+    ps-&gt;cor1 = 0.0f;
+    ps-&gt;var0 = 1.0f;
+    ps-&gt;var1 = 1.0f;
+}
+
+static void reset_all_predictors(PredictorState *ps)
+{
+    int i;
+    for (i = 0; i &lt; MAX_PREDICTORS; i++)
+        reset_predict_state(&amp;ps[i]);
+}
+
+static void reset_predictor_group(PredictorState *ps, int group_num)
+{
+    int i;
+    for (i = group_num - 1; i &lt; MAX_PREDICTORS; i += 30)
+        reset_predict_state(&amp;ps[i]);
+}
+
+#define AAC_INIT_VLC_STATIC(num, size) \
+    INIT_VLC_STATIC(&amp;vlc_spectral[num], 8, ff_aac_spectral_sizes[num], \
+         ff_aac_spectral_bits[num], sizeof( ff_aac_spectral_bits[num][0]), sizeof( ff_aac_spectral_bits[num][0]), \
+        ff_aac_spectral_codes[num], sizeof(ff_aac_spectral_codes[num][0]), sizeof(ff_aac_spectral_codes[num][0]), \
+        size);
+
+static av_cold int aac_decode_init(AVCodecContext *avctx)
+{
+    AACContext *ac = avctx-&gt;priv_data;
+
+    ac-&gt;avctx = avctx;
+    ac-&gt;m4ac.sample_rate = avctx-&gt;sample_rate;
+
+    if (avctx-&gt;extradata_size &gt; 0) {
+        if (decode_audio_specific_config(ac, avctx-&gt;extradata, avctx-&gt;extradata_size))
+            return -1;
+    }
+
+    avctx-&gt;sample_fmt = SAMPLE_FMT_S16;
+
+    AAC_INIT_VLC_STATIC( 0, 304);
+    AAC_INIT_VLC_STATIC( 1, 270);
+    AAC_INIT_VLC_STATIC( 2, 550);
+    AAC_INIT_VLC_STATIC( 3, 300);
+    AAC_INIT_VLC_STATIC( 4, 328);
+    AAC_INIT_VLC_STATIC( 5, 294);
+    AAC_INIT_VLC_STATIC( 6, 306);
+    AAC_INIT_VLC_STATIC( 7, 268);
+    AAC_INIT_VLC_STATIC( 8, 510);
+    AAC_INIT_VLC_STATIC( 9, 366);
+    AAC_INIT_VLC_STATIC(10, 462);
+
+    ff_aac_sbr_init();
+
+    dsputil_init(&amp;ac-&gt;dsp, avctx);
+
+    ac-&gt;random_state = 0x1f2e3d4c;
+
+    // -1024 - Compensate wrong IMDCT method.
+    // 32768 - Required to scale values to the correct range for the bias method
+    //         for float to int16 conversion.
+
+    if (ac-&gt;dsp.float_to_int16_interleave == ff_float_to_int16_interleave_c) {
+        ac-&gt;add_bias  = 385.0f;
+        ac-&gt;sf_scale  = 1. / (-1024. * 32768.);
+        ac-&gt;sf_offset = 0;
+    } else {
+        ac-&gt;add_bias  = 0.0f;
+        ac-&gt;sf_scale  = 1. / -1024.;
+        ac-&gt;sf_offset = 60;
+    }
+
+    ff_aac_tableinit();
+
+    INIT_VLC_STATIC(&amp;vlc_scalefactors,7,FF_ARRAY_ELEMS(ff_aac_scalefactor_code),
+                    ff_aac_scalefactor_bits, sizeof(ff_aac_scalefactor_bits[0]), sizeof(ff_aac_scalefactor_bits[0]),
+                    ff_aac_scalefactor_code, sizeof(ff_aac_scalefactor_code[0]), sizeof(ff_aac_scalefactor_code[0]),
+                    352);
+
+    ff_mdct_init(&amp;ac-&gt;mdct, 11, 1, 1.0);
+    ff_mdct_init(&amp;ac-&gt;mdct_small, 8, 1, 1.0);
+    // window initialization
+    ff_kbd_window_init(ff_aac_kbd_long_1024, 4.0, 1024);
+    ff_kbd_window_init(ff_aac_kbd_short_128, 6.0, 128);
+    ff_init_ff_sine_windows(10);
+    ff_init_ff_sine_windows( 7);
+
+    cbrt_tableinit();
+
+    return 0;
+}
+
+/**
+ * Skip data_stream_element; reference: table 4.10.
+ */
+static int skip_data_stream_element(AACContext *ac, GetBitContext *gb)
+{
+    int byte_align = get_bits1(gb);
+    int count = get_bits(gb, 8);
+    if (count == 255)
+        count += get_bits(gb, 8);
+    if (byte_align)
+        align_get_bits(gb);
+
+    if (get_bits_left(gb) &lt; 8 * count) {
+        av_log(ac-&gt;avctx, AV_LOG_ERROR, overread_err);
+        return -1;
+    }
+    skip_bits_long(gb, 8 * count);
+    return 0;
+}
+
+static int decode_prediction(AACContext *ac, IndividualChannelStream *ics,
+                             GetBitContext *gb)
+{
+    int sfb;
+    if (get_bits1(gb)) {
+        ics-&gt;predictor_reset_group = get_bits(gb, 5);
+        if (ics-&gt;predictor_reset_group == 0 || ics-&gt;predictor_reset_group &gt; 30) {
+            av_log(ac-&gt;avctx, AV_LOG_ERROR, &quot;Invalid Predictor Reset Group.\n&quot;);
+            return -1;
+        }
+    }
+    for (sfb = 0; sfb &lt; FFMIN(ics-&gt;max_sfb, ff_aac_pred_sfb_max[ac-&gt;m4ac.sampling_index]); sfb++) {
+        ics-&gt;prediction_used[sfb] = get_bits1(gb);
+    }
+    return 0;
+}
+
+/**
+ * Decode Individual Channel Stream info; reference: table 4.6.
+ *
+ * @param   common_window   Channels have independent [0], or shared [1], Individual Channel Stream information.
+ */
+static int decode_ics_info(AACContext *ac, IndividualChannelStream *ics,
+                           GetBitContext *gb, int common_window)
+{
+    if (get_bits1(gb)) {
+        av_log(ac-&gt;avctx, AV_LOG_ERROR, &quot;Reserved bit set.\n&quot;);
+        memset(ics, 0, sizeof(IndividualChannelStream));
+        return -1;
+    }
+    ics-&gt;window_sequence[1] = ics-&gt;window_sequence[0];
+    ics-&gt;window_sequence[0] = get_bits(gb, 2);
+    ics-&gt;use_kb_window[1]   = ics-&gt;use_kb_window[0];
+    ics-&gt;use_kb_window[0]   = get_bits1(gb);
+    ics-&gt;num_window_groups  = 1;
+    ics-&gt;group_len[0]       = 1;
+    if (ics-&gt;window_sequence[0] == EIGHT_SHORT_SEQUENCE) {
+        int i;
+        ics-&gt;max_sfb = get_bits(gb, 4);
+        for (i = 0; i &lt; 7; i++) {
+            if (get_bits1(gb)) {
+                ics-&gt;group_len[ics-&gt;num_window_groups - 1]++;
+            } else {
+                ics-&gt;num_window_groups++;
+                ics-&gt;group_len[ics-&gt;num_window_groups - 1] = 1;
+            }
+        }
+        ics-&gt;num_windows       = 8;
+        ics-&gt;swb_offset        =    ff_swb_offset_128[ac-&gt;m4ac.sampling_index];
+        ics-&gt;num_swb           =   ff_aac_num_swb_128[ac-&gt;m4ac.sampling_index];
+        ics-&gt;tns_max_bands     = ff_tns_max_bands_128[ac-&gt;m4ac.sampling_index];
+        ics-&gt;predictor_present = 0;
+    } else {
+        ics-&gt;max_sfb               = get_bits(gb, 6);
+        ics-&gt;num_windows           = 1;
+        ics-&gt;swb_offset            =    ff_swb_offset_1024[ac-&gt;m4ac.sampling_index];
+        ics-&gt;num_swb               =   ff_aac_num_swb_1024[ac-&gt;m4ac.sampling_index];
+        ics-&gt;tns_max_bands         = ff_tns_max_bands_1024[ac-&gt;m4ac.sampling_index];
+        ics-&gt;predictor_present     = get_bits1(gb);
+        ics-&gt;predictor_reset_group = 0;
+        if (ics-&gt;predictor_present) {
+            if (ac-&gt;m4ac.object_type == AOT_AAC_MAIN) {
+                if (decode_prediction(ac, ics, gb)) {
+                    memset(ics, 0, sizeof(IndividualChannelStream));
+                    return -1;
+                }
+            } else if (ac-&gt;m4ac.object_type == AOT_AAC_LC) {
+                av_log(ac-&gt;avctx, AV_LOG_ERROR, &quot;Prediction is not allowed in AAC-LC.\n&quot;);
+                memset(ics, 0, sizeof(IndividualChannelStream));
+                return -1;
+            } else {
+                av_log_missing_feature(ac-&gt;avctx, &quot;Predictor bit set but LTP is&quot;, 1);
+                memset(ics, 0, sizeof(IndividualChannelStream));
+                return -1;
+            }
+        }
+    }
+
+    if (ics-&gt;max_sfb &gt; ics-&gt;num_swb) {
+        av_log(ac-&gt;avctx, AV_LOG_ERROR,
+               &quot;Number of scalefactor bands in group (%d) exceeds limit (%d).\n&quot;,
+               ics-&gt;max_sfb, ics-&gt;num_swb);
+        memset(ics, 0, sizeof(IndividualChannelStream));
+        return -1;
+    }
+
+    return 0;
+}
+
+/**
+ * Decode band types (section_data payload); reference: table 4.46.
+ *
+ * @param   band_type           array of the used band type
+ * @param   band_type_run_end   array of the last scalefactor band of a band type run
+ *
+ * @return  Returns error status. 0 - OK, !0 - error
+ */
+static int decode_band_types(AACContext *ac, enum BandType band_type[120],
+                             int band_type_run_end[120], GetBitContext *gb,
+                             IndividualChannelStream *ics)
+{
+    int g, idx = 0;
+    const int bits = (ics-&gt;window_sequence[0] == EIGHT_SHORT_SEQUENCE) ? 3 : 5;
+    for (g = 0; g &lt; ics-&gt;num_window_groups; g++) {
+        int k = 0;
+        while (k &lt; ics-&gt;max_sfb) {
+            uint8_t sect_end = k;
+            int sect_len_incr;
+            int sect_band_type = get_bits(gb, 4);
+            if (sect_band_type == 12) {
+                av_log(ac-&gt;avctx, AV_LOG_ERROR, &quot;invalid band type\n&quot;);
+                return -1;
+            }
+            while ((sect_len_incr = get_bits(gb, bits)) == (1 &lt;&lt; bits) - 1)
+                sect_end += sect_len_incr;
+            sect_end += sect_len_incr;
+            if (get_bits_left(gb) &lt; 0) {
+                av_log(ac-&gt;avctx, AV_LOG_ERROR, overread_err);
+                return -1;
+            }
+            if (sect_end &gt; ics-&gt;max_sfb) {
+                av_log(ac-&gt;avctx, AV_LOG_ERROR,
+                       &quot;Number of bands (%d) exceeds limit (%d).\n&quot;,
+                       sect_end, ics-&gt;max_sfb);
+                return -1;
+            }
+            for (; k &lt; sect_end; k++) {
+                band_type        [idx]   = sect_band_type;
+                band_type_run_end[idx++] = sect_end;
+            }
+        }
+    }
+    return 0;
+}
+
+/**
+ * Decode scalefactors; reference: table 4.47.
+ *
+ * @param   global_gain         first scalefactor value as scalefactors are differentially coded
+ * @param   band_type           array of the used band type
+ * @param   band_type_run_end   array of the last scalefactor band of a band type run
+ * @param   sf                  array of scalefactors or intensity stereo positions
+ *
+ * @return  Returns error status. 0 - OK, !0 - error
+ */
+static int decode_scalefactors(AACContext *ac, float sf[120], GetBitContext *gb,
+                               unsigned int global_gain,
+                               IndividualChannelStream *ics,
+                               enum BandType band_type[120],
+                               int band_type_run_end[120])
+{
+    const int sf_offset = ac-&gt;sf_offset + (ics-&gt;window_sequence[0] == EIGHT_SHORT_SEQUENCE ? 12 : 0);
+    int g, i, idx = 0;
+    int offset[3] = { global_gain, global_gain - 90, 100 };
+    int noise_flag = 1;
+    static const char *sf_str[3] = { &quot;Global gain&quot;, &quot;Noise gain&quot;, &quot;Intensity stereo position&quot; };
+    for (g = 0; g &lt; ics-&gt;num_window_groups; g++) {
+        for (i = 0; i &lt; ics-&gt;max_sfb;) {
+            int run_end = band_type_run_end[idx];
+            if (band_type[idx] == ZERO_BT) {
+                for (; i &lt; run_end; i++, idx++)
+                    sf[idx] = 0.;
+            } else if ((band_type[idx] == INTENSITY_BT) || (band_type[idx] == INTENSITY_BT2)) {
+                for (; i &lt; run_end; i++, idx++) {
+                    offset[2] += get_vlc2(gb, vlc_scalefactors.table, 7, 3) - 60;
+                    if (offset[2] &gt; 255U) {
+                        av_log(ac-&gt;avctx, AV_LOG_ERROR,
+                               &quot;%s (%d) out of range.\n&quot;, sf_str[2], offset[2]);
+                        return -1;
+                    }
+                    sf[idx] = ff_aac_pow2sf_tab[-offset[2] + 300];
+                }
+            } else if (band_type[idx] == NOISE_BT) {
+                for (; i &lt; run_end; i++, idx++) {
+                    if (noise_flag-- &gt; 0)
+                        offset[1] += get_bits(gb, 9) - 256;
+                    else
+                        offset[1] += get_vlc2(gb, vlc_scalefactors.table, 7, 3) - 60;
+                    if (offset[1] &gt; 255U) {
+                        av_log(ac-&gt;avctx, AV_LOG_ERROR,
+                               &quot;%s (%d) out of range.\n&quot;, sf_str[1], offset[1]);
+                        return -1;
+                    }
+                    sf[idx] = -ff_aac_pow2sf_tab[offset[1] + sf_offset + 100];
+                }
+            } else {
+                for (; i &lt; run_end; i++, idx++) {
+                    offset[0] += get_vlc2(gb, vlc_scalefactors.table, 7, 3) - 60;
+                    if (offset[0] &gt; 255U) {
+                        av_log(ac-&gt;avctx, AV_LOG_ERROR,
+                               &quot;%s (%d) out of range.\n&quot;, sf_str[0], offset[0]);
+                        return -1;
+                    }
+                    sf[idx] = -ff_aac_pow2sf_tab[ offset[0] + sf_offset];
+                }
+            }
+        }
+    }
+    return 0;
+}
+
+/**
+ * Decode pulse data; reference: table 4.7.
+ */
+static int decode_pulses(Pulse *pulse, GetBitContext *gb,
+                         const uint16_t *swb_offset, int num_swb)
+{
+    int i, pulse_swb;
+    pulse-&gt;num_pulse = get_bits(gb, 2) + 1;
+    pulse_swb        = get_bits(gb, 6);
+    if (pulse_swb &gt;= num_swb)
+        return -1;
+    pulse-&gt;pos[0]    = swb_offset[pulse_swb];
+    pulse-&gt;pos[0]   += get_bits(gb, 5);
+    if (pulse-&gt;pos[0] &gt; 1023)
+        return -1;
+    pulse-&gt;amp[0]    = get_bits(gb, 4);
+    for (i = 1; i &lt; pulse-&gt;num_pulse; i++) {
+        pulse-&gt;pos[i] = get_bits(gb, 5) + pulse-&gt;pos[i - 1];
+        if (pulse-&gt;pos[i] &gt; 1023)
+            return -1;
+        pulse-&gt;amp[i] = get_bits(gb, 4);
+    }
+    return 0;
+}
+
+/**
+ * Decode Temporal Noise Shaping data; reference: table 4.48.
+ *
+ * @return  Returns error status. 0 - OK, !0 - error
+ */
+static int decode_tns(AACContext *ac, TemporalNoiseShaping *tns,
+                      GetBitContext *gb, const IndividualChannelStream *ics)
+{
+    int w, filt, i, coef_len, coef_res, coef_compress;
+    const int is8 = ics-&gt;window_sequence[0] == EIGHT_SHORT_SEQUENCE;
+    const int tns_max_order = is8 ? 7 : ac-&gt;m4ac.object_type == AOT_AAC_MAIN ? 20 : 12;
+    for (w = 0; w &lt; ics-&gt;num_windows; w++) {
+        if ((tns-&gt;n_filt[w] = get_bits(gb, 2 - is8))) {
+            coef_res = get_bits1(gb);
+
+            for (filt = 0; filt &lt; tns-&gt;n_filt[w]; filt++) {
+                int tmp2_idx;
+                tns-&gt;length[w][filt] = get_bits(gb, 6 - 2 * is8);
+
+                if ((tns-&gt;order[w][filt] = get_bits(gb, 5 - 2 * is8)) &gt; tns_max_order) {
+                    av_log(ac-&gt;avctx, AV_LOG_ERROR, &quot;TNS filter order %d is greater than maximum %d.\n&quot;,
+                           tns-&gt;order[w][filt], tns_max_order);
+                    tns-&gt;order[w][filt] = 0;
+                    return -1;
+                }
+                if (tns-&gt;order[w][filt]) {
+                    tns-&gt;direction[w][filt] = get_bits1(gb);
+                    coef_compress = get_bits1(gb);
+                    coef_len = coef_res + 3 - coef_compress;
+                    tmp2_idx = 2 * coef_compress + coef_res;
+
+                    for (i = 0; i &lt; tns-&gt;order[w][filt]; i++)
+                        tns-&gt;coef[w][filt][i] = tns_tmp2_map[tmp2_idx][get_bits(gb, coef_len)];
+                }
+            }
+        }
+    }
+    return 0;
+}
+
+/**
+ * Decode Mid/Side data; reference: table 4.54.
+ *
+ * @param   ms_present  Indicates mid/side stereo presence. [0] mask is all 0s;
+ *                      [1] mask is decoded from bitstream; [2] mask is all 1s;
+ *                      [3] reserved for scalable AAC
+ */
+static void decode_mid_side_stereo(ChannelElement *cpe, GetBitContext *gb,
+                                   int ms_present)
+{
+    int idx;
+    if (ms_present == 1) {
+        for (idx = 0; idx &lt; cpe-&gt;ch[0].ics.num_window_groups * cpe-&gt;ch[0].ics.max_sfb; idx++)
+            cpe-&gt;ms_mask[idx] = get_bits1(gb);
+    } else if (ms_present == 2) {
+        memset(cpe-&gt;ms_mask, 1, cpe-&gt;ch[0].ics.num_window_groups * cpe-&gt;ch[0].ics.max_sfb * sizeof(cpe-&gt;ms_mask[0]));
+    }
+}
+
+#ifndef VMUL2
+static inline float *VMUL2(float *dst, const float *v, unsigned idx,
+                           const float *scale)
+{
+    float s = *scale;
+    *dst++ = v[idx    &amp; 15] * s;
+    *dst++ = v[idx&gt;&gt;4 &amp; 15] * s;
+    return dst;
+}
+#endif
+
+#ifndef VMUL4
+static inline float *VMUL4(float *dst, const float *v, unsigned idx,
+                           const float *scale)
+{
+    float s = *scale;
+    *dst++ = v[idx    &amp; 3] * s;
+    *dst++ = v[idx&gt;&gt;2 &amp; 3] * s;
+    *dst++ = v[idx&gt;&gt;4 &amp; 3] * s;
+    *dst++ = v[idx&gt;&gt;6 &amp; 3] * s;
+    return dst;
+}
+#endif
+
+#ifndef VMUL2S
+static inline float *VMUL2S(float *dst, const float *v, unsigned idx,
+                            unsigned sign, const float *scale)
+{
+    union float754 s0, s1;
+
+    s0.f = s1.f = *scale;
+    s0.i ^= sign &gt;&gt; 1 &lt;&lt; 31;
+    s1.i ^= sign      &lt;&lt; 31;
+
+    *dst++ = v[idx    &amp; 15] * s0.f;
+    *dst++ = v[idx&gt;&gt;4 &amp; 15] * s1.f;
+
+    return dst;
+}
+#endif
+
+#ifndef VMUL4S
+static inline float *VMUL4S(float *dst, const float *v, unsigned idx,
+                            unsigned sign, const float *scale)
+{
+    unsigned nz = idx &gt;&gt; 12;
+    union float754 s = { .f = *scale };
+    union float754 t;
+
+    t.i = s.i ^ (sign &amp; 1&lt;&lt;31);
+    *dst++ = v[idx    &amp; 3] * t.f;
+
+    sign &lt;&lt;= nz &amp; 1; nz &gt;&gt;= 1;
+    t.i = s.i ^ (sign &amp; 1&lt;&lt;31);
+    *dst++ = v[idx&gt;&gt;2 &amp; 3] * t.f;
+
+    sign &lt;&lt;= nz &amp; 1; nz &gt;&gt;= 1;
+    t.i = s.i ^ (sign &amp; 1&lt;&lt;31);
+    *dst++ = v[idx&gt;&gt;4 &amp; 3] * t.f;
+
+    sign &lt;&lt;= nz &amp; 1; nz &gt;&gt;= 1;
+    t.i = s.i ^ (sign &amp; 1&lt;&lt;31);
+    *dst++ = v[idx&gt;&gt;6 &amp; 3] * t.f;
+
+    return dst;
+}
+#endif
+
+/**
+ * Decode spectral data; reference: table 4.50.
+ * Dequantize and scale spectral data; reference: 4.6.3.3.
+ *
+ * @param   coef            array of dequantized, scaled spectral data
+ * @param   sf              array of scalefactors or intensity stereo positions
+ * @param   pulse_present   set if pulses are present
+ * @param   pulse           pointer to pulse data struct
+ * @param   band_type       array of the used band type
+ *
+ * @return  Returns error status. 0 - OK, !0 - error
+ */
+static int decode_spectrum_and_dequant(AACContext *ac, float coef[1024],
+                                       GetBitContext *gb, const float sf[120],
+                                       int pulse_present, const Pulse *pulse,
+                                       const IndividualChannelStream *ics,
+                                       enum BandType band_type[120])
+{
+    int i, k, g, idx = 0;
+    const int c = 1024 / ics-&gt;num_windows;
+    const uint16_t *offsets = ics-&gt;swb_offset;
+    float *coef_base = coef;
+
+    for (g = 0; g &lt; ics-&gt;num_windows; g++)
+        memset(coef + g * 128 + offsets[ics-&gt;max_sfb], 0, sizeof(float) * (c - offsets[ics-&gt;max_sfb]));
+
+    for (g = 0; g &lt; ics-&gt;num_window_groups; g++) {
+        unsigned g_len = ics-&gt;group_len[g];
+
+        for (i = 0; i &lt; ics-&gt;max_sfb; i++, idx++) {
+            const unsigned cbt_m1 = band_type[idx] - 1;
+            float *cfo = coef + offsets[i];
+            int off_len = offsets[i + 1] - offsets[i];
+            int group;
+
+            if (cbt_m1 &gt;= INTENSITY_BT2 - 1) {
+                for (group = 0; group &lt; g_len; group++, cfo+=128) {
+                    memset(cfo, 0, off_len * sizeof(float));
+                }
+            } else if (cbt_m1 == NOISE_BT - 1) {
+                for (group = 0; group &lt; g_len; group++, cfo+=128) {
+                    float scale;
+                    float band_energy;
+
+                    for (k = 0; k &lt; off_len; k++) {
+                        ac-&gt;random_state  = lcg_random(ac-&gt;random_state);
+                        cfo[k] = ac-&gt;random_state;
+                    }
+
+                    band_energy = ac-&gt;dsp.scalarproduct_float(cfo, cfo, off_len);
+                    scale = sf[idx] / sqrtf(band_energy);
+                    ac-&gt;dsp.vector_fmul_scalar(cfo, cfo, scale, off_len);
+                }
+            } else {
+                const float *vq = ff_aac_codebook_vector_vals[cbt_m1];
+                const uint16_t *cb_vector_idx = ff_aac_codebook_vector_idx[cbt_m1];
+                VLC_TYPE (*vlc_tab)[2] = vlc_spectral[cbt_m1].table;
+                OPEN_READER(re, gb);
+
+                switch (cbt_m1 &gt;&gt; 1) {
+                case 0:
+                    for (group = 0; group &lt; g_len; group++, cfo+=128) {
+                        float *cf = cfo;
+                        int len = off_len;
+
+                        do {
+                            int code;
+                            unsigned cb_idx;
+
+                            UPDATE_CACHE(re, gb);
+                            GET_VLC(code, re, gb, vlc_tab, 8, 2);
+                            cb_idx = cb_vector_idx[code];
+                            cf = VMUL4(cf, vq, cb_idx, sf + idx);
+                        } while (len -= 4);
+                    }
+                    break;
+
+                case 1:
+                    for (group = 0; group &lt; g_len; group++, cfo+=128) {
+                        float *cf = cfo;
+                        int len = off_len;
+
+                        do {
+                            int code;
+                            unsigned nnz;
+                            unsigned cb_idx;
+                            uint32_t bits;
+
+                            UPDATE_CACHE(re, gb);
+                            GET_VLC(code, re, gb, vlc_tab, 8, 2);
+#if MIN_CACHE_BITS &lt; 20
+                            UPDATE_CACHE(re, gb);
+#endif
+                            cb_idx = cb_vector_idx[code];
+                            nnz = cb_idx &gt;&gt; 8 &amp; 15;
+                            bits = SHOW_UBITS(re, gb, nnz) &lt;&lt; (32-nnz);
+                            LAST_SKIP_BITS(re, gb, nnz);
+                            cf = VMUL4S(cf, vq, cb_idx, bits, sf + idx);
+                        } while (len -= 4);
+                    }
+                    break;
+
+                case 2:
+                    for (group = 0; group &lt; g_len; group++, cfo+=128) {
+                        float *cf = cfo;
+                        int len = off_len;
+
+                        do {
+                            int code;
+                            unsigned cb_idx;
+
+                            UPDATE_CACHE(re, gb);
+                            GET_VLC(code, re, gb, vlc_tab, 8, 2);
+                            cb_idx = cb_vector_idx[code];
+                            cf = VMUL2(cf, vq, cb_idx, sf + idx);
+                        } while (len -= 2);
+                    }
+                    break;
+
+                case 3:
+                case 4:
+                    for (group = 0; group &lt; g_len; group++, cfo+=128) {
+                        float *cf = cfo;
+                        int len = off_len;
+
+                        do {
+                            int code;
+                            unsigned nnz;
+                            unsigned cb_idx;
+                            unsigned sign;
+
+                            UPDATE_CACHE(re, gb);
+                            GET_VLC(code, re, gb, vlc_tab, 8, 2);
+                            cb_idx = cb_vector_idx[code];
+                            nnz = cb_idx &gt;&gt; 8 &amp; 15;
+                            sign = SHOW_UBITS(re, gb, nnz) &lt;&lt; (cb_idx &gt;&gt; 12);
+                            LAST_SKIP_BITS(re, gb, nnz);
+                            cf = VMUL2S(cf, vq, cb_idx, sign, sf + idx);
+                        } while (len -= 2);
+                    }
+                    break;
+
+                default:
+                    for (group = 0; group &lt; g_len; group++, cfo+=128) {
+                        float *cf = cfo;
+                        uint32_t *icf = (uint32_t *) cf;
+                        int len = off_len;
+
+                        do {
+                            int code;
+                            unsigned nzt, nnz;
+                            unsigned cb_idx;
+                            uint32_t bits;
+                            int j;
+
+                            UPDATE_CACHE(re, gb);
+                            GET_VLC(code, re, gb, vlc_tab, 8, 2);
+
+                            if (!code) {
+                                *icf++ = 0;
+                                *icf++ = 0;
+                                continue;
+                            }
+
+                            cb_idx = cb_vector_idx[code];
+                            nnz = cb_idx &gt;&gt; 12;
+                            nzt = cb_idx &gt;&gt; 8;
+                            bits = SHOW_UBITS(re, gb, nnz) &lt;&lt; (32-nnz);
+                            LAST_SKIP_BITS(re, gb, nnz);
+
+                            for (j = 0; j &lt; 2; j++) {
+                                if (nzt &amp; 1&lt;&lt;j) {
+                                    uint32_t b;
+                                    int n;
+                                    /* The total length of escape_sequence must be &lt; 22 bits according
+                                       to the specification (i.e. max is 111111110xxxxxxxxxxxx). */
+                                    UPDATE_CACHE(re, gb);
+                                    b = GET_CACHE(re, gb);
+                                    b = 31 - av_log2(~b);
+
+                                    if (b &gt; 8) {
+                                        av_log(ac-&gt;avctx, AV_LOG_ERROR, &quot;error in spectral data, ESC overflow\n&quot;);
+                                        return -1;
+                                    }
+
+#if MIN_CACHE_BITS &lt; 21
+                                    LAST_SKIP_BITS(re, gb, b + 1);
+                                    UPDATE_CACHE(re, gb);
+#else
+                                    SKIP_BITS(re, gb, b + 1);
+#endif
+                                    b += 4;
+                                    n = (1 &lt;&lt; b) + SHOW_UBITS(re, gb, b);
+                                    LAST_SKIP_BITS(re, gb, b);
+                                    *icf++ = cbrt_tab[n] | (bits &amp; 1&lt;&lt;31);
+                                    bits &lt;&lt;= 1;
+                                } else {
+                                    unsigned v = ((const uint32_t*)vq)[cb_idx &amp; 15];
+                                    *icf++ = (bits &amp; 1&lt;&lt;31) | v;
+                                    bits &lt;&lt;= !!v;
+                                }
+                                cb_idx &gt;&gt;= 4;
+                            }
+                        } while (len -= 2);
+
+                        ac-&gt;dsp.vector_fmul_scalar(cfo, cfo, sf[idx], off_len);
+                    }
+                }
+
+                CLOSE_READER(re, gb);
+            }
+        }
+        coef += g_len &lt;&lt; 7;
+    }
+
+    if (pulse_present) {
+        idx = 0;
+        for (i = 0; i &lt; pulse-&gt;num_pulse; i++) {
+            float co = coef_base[ pulse-&gt;pos[i] ];
+            while (offsets[idx + 1] &lt;= pulse-&gt;pos[i])
+                idx++;
+            if (band_type[idx] != NOISE_BT &amp;&amp; sf[idx]) {
+                float ico = -pulse-&gt;amp[i];
+                if (co) {
+                    co /= sf[idx];
+                    ico = co / sqrtf(sqrtf(fabsf(co))) + (co &gt; 0 ? -ico : ico);
+                }
+                coef_base[ pulse-&gt;pos[i] ] = cbrtf(fabsf(ico)) * ico * sf[idx];
+            }
+        }
+    }
+    return 0;
+}
+
+static av_always_inline float flt16_round(float pf)
+{
+    union float754 tmp;
+    tmp.f = pf;
+    tmp.i = (tmp.i + 0x00008000U) &amp; 0xFFFF0000U;
+    return tmp.f;
+}
+
+static av_always_inline float flt16_even(float pf)
+{
+    union float754 tmp;
+    tmp.f = pf;
+    tmp.i = (tmp.i + 0x00007FFFU + (tmp.i &amp; 0x00010000U &gt;&gt; 16)) &amp; 0xFFFF0000U;
+    return tmp.f;
+}
+
+static av_always_inline float flt16_trunc(float pf)
+{
+    union float754 pun;
+    pun.f = pf;
+    pun.i &amp;= 0xFFFF0000U;
+    return pun.f;
+}
+
+static av_always_inline void predict(PredictorState *ps, float *coef,
+                                     float sf_scale, float inv_sf_scale,
+                    int output_enable)
+{
+    const float a     = 0.953125; // 61.0 / 64
+    const float alpha = 0.90625;  // 29.0 / 32
+    float e0, e1;
+    float pv;
+    float k1, k2;
+    float   r0 = ps-&gt;r0,     r1 = ps-&gt;r1;
+    float cor0 = ps-&gt;cor0, cor1 = ps-&gt;cor1;
+    float var0 = ps-&gt;var0, var1 = ps-&gt;var1;
+
+    k1 = var0 &gt; 1 ? cor0 * flt16_even(a / var0) : 0;
+    k2 = var1 &gt; 1 ? cor1 * flt16_even(a / var1) : 0;
+
+    pv = flt16_round(k1 * r0 + k2 * r1);
+    if (output_enable)
+        *coef += pv * sf_scale;
+
+    e0 = *coef * inv_sf_scale;
+    e1 = e0 - k1 * r0;
+
+    ps-&gt;cor1 = flt16_trunc(alpha * cor1 + r1 * e1);
+    ps-&gt;var1 = flt16_trunc(alpha * var1 + 0.5f * (r1 * r1 + e1 * e1));
+    ps-&gt;cor0 = flt16_trunc(alpha * cor0 + r0 * e0);
+    ps-&gt;var0 = flt16_trunc(alpha * var0 + 0.5f * (r0 * r0 + e0 * e0));
+
+    ps-&gt;r1 = flt16_trunc(a * (r0 - k1 * e0));
+    ps-&gt;r0 = flt16_trunc(a * e0);
+}
+
+/**
+ * Apply AAC-Main style frequency domain prediction.
+ */
+static void apply_prediction(AACContext *ac, SingleChannelElement *sce)
+{
+    int sfb, k;
+    float sf_scale = ac-&gt;sf_scale, inv_sf_scale = 1 / ac-&gt;sf_scale;
+
+    if (!sce-&gt;ics.predictor_initialized) {
+        reset_all_predictors(sce-&gt;predictor_state);
+        sce-&gt;ics.predictor_initialized = 1;
+    }
+
+    if (sce-&gt;ics.window_sequence[0] != EIGHT_SHORT_SEQUENCE) {
+        for (sfb = 0; sfb &lt; ff_aac_pred_sfb_max[ac-&gt;m4ac.sampling_index]; sfb++) {
+            for (k = sce-&gt;ics.swb_offset[sfb]; k &lt; sce-&gt;ics.swb_offset[sfb + 1]; k++) {
+                predict(&amp;sce-&gt;predictor_state[k], &amp;sce-&gt;coeffs[k],
+                        sf_scale, inv_sf_scale,
+                        sce-&gt;ics.predictor_present &amp;&amp; sce-&gt;ics.prediction_used[sfb]);
+            }
+        }
+        if (sce-&gt;ics.predictor_reset_group)
+            reset_predictor_group(sce-&gt;predictor_state, sce-&gt;ics.predictor_reset_group);
+    } else
+        reset_all_predictors(sce-&gt;predictor_state);
+}
+
+/**
+ * Decode an individual_channel_stream payload; reference: table 4.44.
+ *
+ * @param   common_window   Channels have independent [0], or shared [1], Individual Channel Stream information.
+ * @param   scale_flag      scalable [1] or non-scalable [0] AAC (Unused until scalable AAC is implemented.)
+ *
+ * @return  Returns error status. 0 - OK, !0 - error
+ */
+static int decode_ics(AACContext *ac, SingleChannelElement *sce,
+                      GetBitContext *gb, int common_window, int scale_flag)
+{
+    Pulse pulse;
+    TemporalNoiseShaping    *tns = &amp;sce-&gt;tns;
+    IndividualChannelStream *ics = &amp;sce-&gt;ics;
+    float *out = sce-&gt;coeffs;
+    int global_gain, pulse_present = 0;
+
+    /* This assignment is to silence a GCC warning about the variable being used
+     * uninitialized when in fact it always is.
+     */
+    pulse.num_pulse = 0;
+
+    global_gain = get_bits(gb, 8);
+
+    if (!common_window &amp;&amp; !scale_flag) {
+        if (decode_ics_info(ac, ics, gb, 0) &lt; 0)
+            return -1;
+    }
+
+    if (decode_band_types(ac, sce-&gt;band_type, sce-&gt;band_type_run_end, gb, ics) &lt; 0)
+        return -1;
+    if (decode_scalefactors(ac, sce-&gt;sf, gb, global_gain, ics, sce-&gt;band_type, sce-&gt;band_type_run_end) &lt; 0)
+        return -1;
+
+    pulse_present = 0;
+    if (!scale_flag) {
+        if ((pulse_present = get_bits1(gb))) {
+            if (ics-&gt;window_sequence[0] == EIGHT_SHORT_SEQUENCE) {
+                av_log(ac-&gt;avctx, AV_LOG_ERROR, &quot;Pulse tool not allowed in eight short sequence.\n&quot;);
+                return -1;
+            }
+            if (decode_pulses(&amp;pulse, gb, ics-&gt;swb_offset, ics-&gt;num_swb)) {
+                av_log(ac-&gt;avctx, AV_LOG_ERROR, &quot;Pulse data corrupt or invalid.\n&quot;);
+                return -1;
+            }
+        }
+        if ((tns-&gt;present = get_bits1(gb)) &amp;&amp; decode_tns(ac, tns, gb, ics))
+            return -1;
+        if (get_bits1(gb)) {
+            av_log_missing_feature(ac-&gt;avctx, &quot;SSR&quot;, 1);
+            return -1;
+        }
+    }
+
+    if (decode_spectrum_and_dequant(ac, out, gb, sce-&gt;sf, pulse_present, &amp;pulse, ics, sce-&gt;band_type) &lt; 0)
+        return -1;
+
+    if (ac-&gt;m4ac.object_type == AOT_AAC_MAIN &amp;&amp; !common_window)
+        apply_prediction(ac, sce);
+
+    return 0;
+}
+
+/**
+ * Mid/Side stereo decoding; reference: 4.6.8.1.3.
+ */
+static void apply_mid_side_stereo(AACContext *ac, ChannelElement *cpe)
+{
+    const IndividualChannelStream *ics = &amp;cpe-&gt;ch[0].ics;
+    float *ch0 = cpe-&gt;ch[0].coeffs;
+    float *ch1 = cpe-&gt;ch[1].coeffs;
+    int g, i, group, idx = 0;
+    const uint16_t *offsets = ics-&gt;swb_offset;
+    for (g = 0; g &lt; ics-&gt;num_window_groups; g++) {
+        for (i = 0; i &lt; ics-&gt;max_sfb; i++, idx++) {
+            if (cpe-&gt;ms_mask[idx] &amp;&amp;
+                    cpe-&gt;ch[0].band_type[idx] &lt; NOISE_BT &amp;&amp; cpe-&gt;ch[1].band_type[idx] &lt; NOISE_BT) {
+                for (group = 0; group &lt; ics-&gt;group_len[g]; group++) {
+                    ac-&gt;dsp.butterflies_float(ch0 + group * 128 + offsets[i],
+                                              ch1 + group * 128 + offsets[i],
+                                              offsets[i+1] - offsets[i]);
+                }
+            }
+        }
+        ch0 += ics-&gt;group_len[g] * 128;
+        ch1 += ics-&gt;group_len[g] * 128;
+    }
+}
+
+/**
+ * intensity stereo decoding; reference: 4.6.8.2.3
+ *
+ * @param   ms_present  Indicates mid/side stereo presence. [0] mask is all 0s;
+ *                      [1] mask is decoded from bitstream; [2] mask is all 1s;
+ *                      [3] reserved for scalable AAC
+ */
+static void apply_intensity_stereo(ChannelElement *cpe, int ms_present)
+{
+    const IndividualChannelStream *ics = &amp;cpe-&gt;ch[1].ics;
+    SingleChannelElement         *sce1 = &amp;cpe-&gt;ch[1];
+    float *coef0 = cpe-&gt;ch[0].coeffs, *coef1 = cpe-&gt;ch[1].coeffs;
+    const uint16_t *offsets = ics-&gt;swb_offset;
+    int g, group, i, k, idx = 0;
+    int c;
+    float scale;
+    for (g = 0; g &lt; ics-&gt;num_window_groups; g++) {
+        for (i = 0; i &lt; ics-&gt;max_sfb;) {
+            if (sce1-&gt;band_type[idx] == INTENSITY_BT || sce1-&gt;band_type[idx] == INTENSITY_BT2) {
+                const int bt_run_end = sce1-&gt;band_type_run_end[idx];
+                for (; i &lt; bt_run_end; i++, idx++) {
+                    c = -1 + 2 * (sce1-&gt;band_type[idx] - 14);
+                    if (ms_present)
+                        c *= 1 - 2 * cpe-&gt;ms_mask[idx];
+                    scale = c * sce1-&gt;sf[idx];
+                    for (group = 0; group &lt; ics-&gt;group_len[g]; group++)
+                        for (k = offsets[i]; k &lt; offsets[i + 1]; k++)
+                            coef1[group * 128 + k] = scale * coef0[group * 128 + k];
+                }
+            } else {
+                int bt_run_end = sce1-&gt;band_type_run_end[idx];
+                idx += bt_run_end - i;
+                i    = bt_run_end;
+            }
+        }
+        coef0 += ics-&gt;group_len[g] * 128;
+        coef1 += ics-&gt;group_len[g] * 128;
+    }
+}
+
+/**
+ * Decode a channel_pair_element; reference: table 4.4.
+ *
+ * @return  Returns error status. 0 - OK, !0 - error
+ */
+static int decode_cpe(AACContext *ac, GetBitContext *gb, ChannelElement *cpe)
+{
+    int i, ret, common_window, ms_present = 0;
+
+    common_window = get_bits1(gb);
+    if (common_window) {
+        if (decode_ics_info(ac, &amp;cpe-&gt;ch[0].ics, gb, 1))
+            return -1;
+        i = cpe-&gt;ch[1].ics.use_kb_window[0];
+        cpe-&gt;ch[1].ics = cpe-&gt;ch[0].ics;
+        cpe-&gt;ch[1].ics.use_kb_window[1] = i;
+        ms_present = get_bits(gb, 2);
+        if (ms_present == 3) {
+            av_log(ac-&gt;avctx, AV_LOG_ERROR, &quot;ms_present = 3 is reserved.\n&quot;);
+            return -1;
+        } else if (ms_present)
+            decode_mid_side_stereo(cpe, gb, ms_present);
+    }
+    if ((ret = decode_ics(ac, &amp;cpe-&gt;ch[0], gb, common_window, 0)))
+        return ret;
+    if ((ret = decode_ics(ac, &amp;cpe-&gt;ch[1], gb, common_window, 0)))
+        return ret;
+
+    if (common_window) {
+        if (ms_present)
+            apply_mid_side_stereo(ac, cpe);
+        if (ac-&gt;m4ac.object_type == AOT_AAC_MAIN) {
+            apply_prediction(ac, &amp;cpe-&gt;ch[0]);
+            apply_prediction(ac, &amp;cpe-&gt;ch[1]);
+        }
+    }
+
+    apply_intensity_stereo(cpe, ms_present);
+    return 0;
+}
+
+static const float cce_scale[] = {
+    1.09050773266525765921, //2^(1/8)
+    1.18920711500272106672, //2^(1/4)
+    M_SQRT2,
+    2,
+};
+
+/**
+ * Decode coupling_channel_element; reference: table 4.8.
+ *
+ * @return  Returns error status. 0 - OK, !0 - error
+ */
+static int decode_cce(AACContext *ac, GetBitContext *gb, ChannelElement *che)
+{
+    int num_gain = 0;
+    int c, g, sfb, ret;
+    int sign;
+    float scale;
+    SingleChannelElement *sce = &amp;che-&gt;ch[0];
+    ChannelCoupling     *coup = &amp;che-&gt;coup;
+
+    coup-&gt;coupling_point = 2 * get_bits1(gb);
+    coup-&gt;num_coupled = get_bits(gb, 3);
+    for (c = 0; c &lt;= coup-&gt;num_coupled; c++) {
+        num_gain++;
+        coup-&gt;type[c] = get_bits1(gb) ? TYPE_CPE : TYPE_SCE;
+        coup-&gt;id_select[c] = get_bits(gb, 4);
+        if (coup-&gt;type[c] == TYPE_CPE) {
+            coup-&gt;ch_select[c] = get_bits(gb, 2);
+            if (coup-&gt;ch_select[c] == 3)
+                num_gain++;
+        } else
+            coup-&gt;ch_select[c] = 2;
+    }
+    coup-&gt;coupling_point += get_bits1(gb) || (coup-&gt;coupling_point &gt;&gt; 1);
+
+    sign  = get_bits(gb, 1);
+    scale = cce_scale[get_bits(gb, 2)];
+
+    if ((ret = decode_ics(ac, sce, gb, 0, 0)))
+        return ret;
+
+    for (c = 0; c &lt; num_gain; c++) {
+        int idx  = 0;
+        int cge  = 1;
+        int gain = 0;
+        float gain_cache = 1.;
+        if (c) {
+            cge = coup-&gt;coupling_point == AFTER_IMDCT ? 1 : get_bits1(gb);
+            gain = cge ? get_vlc2(gb, vlc_scalefactors.table, 7, 3) - 60: 0;
+            gain_cache = powf(scale, -gain);
+        }
+        if (coup-&gt;coupling_point == AFTER_IMDCT) {
+            coup-&gt;gain[c][0] = gain_cache;
+        } else {
+            for (g = 0; g &lt; sce-&gt;ics.num_window_groups; g++) {
+                for (sfb = 0; sfb &lt; sce-&gt;ics.max_sfb; sfb++, idx++) {
+                    if (sce-&gt;band_type[idx] != ZERO_BT) {
+                        if (!cge) {
+                            int t = get_vlc2(gb, vlc_scalefactors.table, 7, 3) - 60;
+                            if (t) {
+                                int s = 1;
+                                t = gain += t;
+                                if (sign) {
+                                    s  -= 2 * (t &amp; 0x1);
+                                    t &gt;&gt;= 1;
+                                }
+                                gain_cache = powf(scale, -t) * s;
+                            }
+                        }
+                        coup-&gt;gain[c][idx] = gain_cache;
+                    }
+                }
+            }
+        }
+    }
+    return 0;
+}
+
+/**
+ * Parse whether channels are to be excluded from Dynamic Range Compression; reference: table 4.53.
+ *
+ * @return  Returns number of bytes consumed.
+ */
+static int decode_drc_channel_exclusions(DynamicRangeControl *che_drc,
+                                         GetBitContext *gb)
+{
+    int i;
+    int num_excl_chan = 0;
+
+    do {
+        for (i = 0; i &lt; 7; i++)
+            che_drc-&gt;exclude_mask[num_excl_chan++] = get_bits1(gb);
+    } while (num_excl_chan &lt; MAX_CHANNELS - 7 &amp;&amp; get_bits1(gb));
+
+    return num_excl_chan / 7;
+}
+
+/**
+ * Decode dynamic range information; reference: table 4.52.
+ *
+ * @param   cnt length of TYPE_FIL syntactic element in bytes
+ *
+ * @return  Returns number of bytes consumed.
+ */
+static int decode_dynamic_range(DynamicRangeControl *che_drc,
+                                GetBitContext *gb, int cnt)
+{
+    int n             = 1;
+    int drc_num_bands = 1;
+    int i;
+
+    /* pce_tag_present? */
+    if (get_bits1(gb)) {
+        che_drc-&gt;pce_instance_tag  = get_bits(gb, 4);
+        skip_bits(gb, 4); // tag_reserved_bits
+        n++;
+    }
+
+    /* excluded_chns_present? */
+    if (get_bits1(gb)) {
+        n += decode_drc_channel_exclusions(che_drc, gb);
+    }
+
+    /* drc_bands_present? */
+    if (get_bits1(gb)) {
+        che_drc-&gt;band_incr            = get_bits(gb, 4);
+        che_drc-&gt;interpolation_scheme = get_bits(gb, 4);
+        n++;
+        drc_num_bands += che_drc-&gt;band_incr;
+        for (i = 0; i &lt; drc_num_bands; i++) {
+            che_drc-&gt;band_top[i] = get_bits(gb, 8);
+            n++;
+        }
+    }
+
+    /* prog_ref_level_present? */
+    if (get_bits1(gb)) {
+        che_drc-&gt;prog_ref_level = get_bits(gb, 7);
+        skip_bits1(gb); // prog_ref_level_reserved_bits
+        n++;
+    }
+
+    for (i = 0; i &lt; drc_num_bands; i++) {
+        che_drc-&gt;dyn_rng_sgn[i] = get_bits1(gb);
+        che_drc-&gt;dyn_rng_ctl[i] = get_bits(gb, 7);
+        n++;
+    }
+
+    return n;
+}
+
+/**
+ * Decode extension data (incomplete); reference: table 4.51.
+ *
+ * @param   cnt length of TYPE_FIL syntactic element in bytes
+ *
+ * @return Returns number of bytes consumed
+ */
+static int decode_extension_payload(AACContext *ac, GetBitContext *gb, int cnt,
+                                    ChannelElement *che, enum RawDataBlockType elem_type)
+{
+    int crc_flag = 0;
+    int res = cnt;
+    switch (get_bits(gb, 4)) { // extension type
+    case EXT_SBR_DATA_CRC:
+        crc_flag++;
+    case EXT_SBR_DATA:
+        if (!che) {
+            av_log(ac-&gt;avctx, AV_LOG_ERROR, &quot;SBR was found before the first channel element.\n&quot;);
+            return res;
+        } else if (!ac-&gt;m4ac.sbr) {
+            av_log(ac-&gt;avctx, AV_LOG_ERROR, &quot;SBR signaled to be not-present but was found in the bitstream.\n&quot;);
+            skip_bits_long(gb, 8 * cnt - 4);
+            return res;
+        } else if (ac-&gt;m4ac.sbr == -1 &amp;&amp; ac-&gt;output_configured == OC_LOCKED) {
+            av_log(ac-&gt;avctx, AV_LOG_ERROR, &quot;Implicit SBR was found with a first occurrence after the first frame.\n&quot;);
+            skip_bits_long(gb, 8 * cnt - 4);
+            return res;
+        } else if (ac-&gt;m4ac.ps == -1 &amp;&amp; ac-&gt;output_configured &lt; OC_LOCKED &amp;&amp; ac-&gt;avctx-&gt;channels == 1) {
+            ac-&gt;m4ac.sbr = 1;
+            ac-&gt;m4ac.ps = 1;
+            output_configure(ac, ac-&gt;che_pos, ac-&gt;che_pos, ac-&gt;m4ac.chan_config, ac-&gt;output_configured);
+        } else {
+            ac-&gt;m4ac.sbr = 1;
+        }
+        res = ff_decode_sbr_extension(ac, &amp;che-&gt;sbr, gb, crc_flag, cnt, elem_type);
+        break;
+    case EXT_DYNAMIC_RANGE:
+        res = decode_dynamic_range(&amp;ac-&gt;che_drc, gb, cnt);
+        break;
+    case EXT_FILL:
+    case EXT_FILL_DATA:
+    case EXT_DATA_ELEMENT:
+    default:
+        skip_bits_long(gb, 8 * cnt - 4);
+        break;
+    };
+    return res;
+}
+
+/**
+ * Decode Temporal Noise Shaping filter coefficients and apply all-pole filters; reference: 4.6.9.3.
+ *
+ * @param   decode  1 if tool is used normally, 0 if tool is used in LTP.
+ * @param   coef    spectral coefficients
+ */
+static void apply_tns(float coef[1024], TemporalNoiseShaping *tns,
+                      IndividualChannelStream *ics, int decode)
+{
+    const int mmm = FFMIN(ics-&gt;tns_max_bands, ics-&gt;max_sfb);
+    int w, filt, m, i;
+    int bottom, top, order, start, end, size, inc;
+    float lpc[TNS_MAX_ORDER];
+
+    for (w = 0; w &lt; ics-&gt;num_windows; w++) {
+        bottom = ics-&gt;num_swb;
+        for (filt = 0; filt &lt; tns-&gt;n_filt[w]; filt++) {
+            top    = bottom;
+            bottom = FFMAX(0, top - tns-&gt;length[w][filt]);
+            order  = tns-&gt;order[w][filt];
+            if (order == 0)
+                continue;
+
+            // tns_decode_coef
+            compute_lpc_coefs(tns-&gt;coef[w][filt], order, lpc, 0, 0, 0);
+
+            start = ics-&gt;swb_offset[FFMIN(bottom, mmm)];
+            end   = ics-&gt;swb_offset[FFMIN(   top, mmm)];
+            if ((size = end - start) &lt;= 0)
+                continue;
+            if (tns-&gt;direction[w][filt]) {
+                inc = -1;
+                start = end - 1;
+            } else {
+                inc = 1;
+            }
+            start += w * 128;
+
+            // ar filter
+            for (m = 0; m &lt; size; m++, start += inc)
+                for (i = 1; i &lt;= FFMIN(m, order); i++)
+                    coef[start] -= coef[start - i * inc] * lpc[i - 1];
+        }
+    }
+}
+
+/**
+ * Conduct IMDCT and windowing.
+ */
+static void imdct_and_windowing(AACContext *ac, SingleChannelElement *sce, float bias)
+{
+    IndividualChannelStream *ics = &amp;sce-&gt;ics;
+    float *in    = sce-&gt;coeffs;
+    float *out   = sce-&gt;ret;
+    float *saved = sce-&gt;saved;
+    const float *swindow      = ics-&gt;use_kb_window[0] ? ff_aac_kbd_short_128 : ff_sine_128;
+    const float *lwindow_prev = ics-&gt;use_kb_window[1] ? ff_aac_kbd_long_1024 : ff_sine_1024;
+    const float *swindow_prev = ics-&gt;use_kb_window[1] ? ff_aac_kbd_short_128 : ff_sine_128;
+    float *buf  = ac-&gt;buf_mdct;
+    float *temp = ac-&gt;temp;
+    int i;
+
+    // imdct
+    if (ics-&gt;window_sequence[0] == EIGHT_SHORT_SEQUENCE) {
+        for (i = 0; i &lt; 1024; i += 128)
+            ff_imdct_half(&amp;ac-&gt;mdct_small, buf + i, in + i);
+    } else
+        ff_imdct_half(&amp;ac-&gt;mdct, buf, in);
+
+    /* window overlapping
+     * NOTE: To simplify the overlapping code, all 'meaningless' short to long
+     * and long to short transitions are considered to be short to short
+     * transitions. This leaves just two cases (long to long and short to short)
+     * with a little special sauce for EIGHT_SHORT_SEQUENCE.
+     */
+    if ((ics-&gt;window_sequence[1] == ONLY_LONG_SEQUENCE || ics-&gt;window_sequence[1] == LONG_STOP_SEQUENCE) &amp;&amp;
+            (ics-&gt;window_sequence[0] == ONLY_LONG_SEQUENCE || ics-&gt;window_sequence[0] == LONG_START_SEQUENCE)) {
+        ac-&gt;dsp.vector_fmul_window(    out,               saved,            buf,         lwindow_prev, bias, 512);
+    } else {
+        for (i = 0; i &lt; 448; i++)
+            out[i] = saved[i] + bias;
+
+        if (ics-&gt;window_sequence[0] == EIGHT_SHORT_SEQUENCE) {
+            ac-&gt;dsp.vector_fmul_window(out + 448 + 0*128, saved + 448,      buf + 0*128, swindow_prev, bias, 64);
+            ac-&gt;dsp.vector_fmul_window(out + 448 + 1*128, buf + 0*128 + 64, buf + 1*128, swindow,      bias, 64);
+            ac-&gt;dsp.vector_fmul_window(out + 448 + 2*128, buf + 1*128 + 64, buf + 2*128, swindow,      bias, 64);
+            ac-&gt;dsp.vector_fmul_window(out + 448 + 3*128, buf + 2*128 + 64, buf + 3*128, swindow,      bias, 64);
+            ac-&gt;dsp.vector_fmul_window(temp,              buf + 3*128 + 64, buf + 4*128, swindow,      bias, 64);
+            memcpy(                    out + 448 + 4*128, temp, 64 * sizeof(float));
+        } else {
+            ac-&gt;dsp.vector_fmul_window(out + 448,         saved + 448,      buf,         swindow_prev, bias, 64);
+            for (i = 576; i &lt; 1024; i++)
+                out[i] = buf[i-512] + bias;
+        }
+    }
+
+    // buffer update
+    if (ics-&gt;window_sequence[0] == EIGHT_SHORT_SEQUENCE) {
+        for (i = 0; i &lt; 64; i++)
+            saved[i] = temp[64 + i] - bias;
+        ac-&gt;dsp.vector_fmul_window(saved + 64,  buf + 4*128 + 64, buf + 5*128, swindow, 0, 64);
+        ac-&gt;dsp.vector_fmul_window(saved + 192, buf + 5*128 + 64, buf + 6*128, swindow, 0, 64);
+        ac-&gt;dsp.vector_fmul_window(saved + 320, buf + 6*128 + 64, buf + 7*128, swindow, 0, 64);
+        memcpy(                    saved + 448, buf + 7*128 + 64,  64 * sizeof(float));
+    } else if (ics-&gt;window_sequence[0] == LONG_START_SEQUENCE) {
+        memcpy(                    saved,       buf + 512,        448 * sizeof(float));
+        memcpy(                    saved + 448, buf + 7*128 + 64,  64 * sizeof(float));
+    } else { // LONG_STOP or ONLY_LONG
+        memcpy(                    saved,       buf + 512,        512 * sizeof(float));
+    }
+}
+
+/**
+ * Apply dependent channel coupling (applied before IMDCT).
+ *
+ * @param   index   index into coupling gain array
+ */
+static void apply_dependent_coupling(AACContext *ac,
+                                     SingleChannelElement *target,
+                                     ChannelElement *cce, int index)
+{
+    IndividualChannelStream *ics = &amp;cce-&gt;ch[0].ics;
+    const uint16_t *offsets = ics-&gt;swb_offset;
+    float *dest = target-&gt;coeffs;
+    const float *src = cce-&gt;ch[0].coeffs;
+    int g, i, group, k, idx = 0;
+    if (ac-&gt;m4ac.object_type == AOT_AAC_LTP) {
+        av_log(ac-&gt;avctx, AV_LOG_ERROR,
+               &quot;Dependent coupling is not supported together with LTP\n&quot;);
+        return;
+    }
+    for (g = 0; g &lt; ics-&gt;num_window_groups; g++) {
+        for (i = 0; i &lt; ics-&gt;max_sfb; i++, idx++) {
+            if (cce-&gt;ch[0].band_type[idx] != ZERO_BT) {
+                const float gain = cce-&gt;coup.gain[index][idx];
+                for (group = 0; group &lt; ics-&gt;group_len[g]; group++) {
+                    for (k = offsets[i]; k &lt; offsets[i + 1]; k++) {
+                        // XXX dsputil-ize
+                        dest[group * 128 + k] += gain * src[group * 128 + k];
+                    }
+                }
+            }
+        }
+        dest += ics-&gt;group_len[g] * 128;
+        src  += ics-&gt;group_len[g] * 128;
+    }
+}
+
+/**
+ * Apply independent channel coupling (applied after IMDCT).
+ *
+ * @param   index   index into coupling gain array
+ */
+static void apply_independent_coupling(AACContext *ac,
+                                       SingleChannelElement *target,
+                                       ChannelElement *cce, int index)
+{
+    int i;
+    const float gain = cce-&gt;coup.gain[index][0];
+    const float bias = ac-&gt;add_bias;
+    const float *src = cce-&gt;ch[0].ret;
+    float *dest = target-&gt;ret;
+    const int len = 1024 &lt;&lt; (ac-&gt;m4ac.sbr == 1);
+
+    for (i = 0; i &lt; len; i++)
+        dest[i] += gain * (src[i] - bias);
+}
+
+/**
+ * channel coupling transformation interface
+ *
+ * @param   apply_coupling_method   pointer to (in)dependent coupling function
+ */
+static void apply_channel_coupling(AACContext *ac, ChannelElement *cc,
+                                   enum RawDataBlockType type, int elem_id,
+                                   enum CouplingPoint coupling_point,
+                                   void (*apply_coupling_method)(AACContext *ac, SingleChannelElement *target, ChannelElement *cce, int index))
+{
+    int i, c;
+
+    for (i = 0; i &lt; MAX_ELEM_ID; i++) {
+        ChannelElement *cce = ac-&gt;che[TYPE_CCE][i];
+        int index = 0;
+
+        if (cce &amp;&amp; cce-&gt;coup.coupling_point == coupling_point) {
+            ChannelCoupling *coup = &amp;cce-&gt;coup;
+
+            for (c = 0; c &lt;= coup-&gt;num_coupled; c++) {
+                if (coup-&gt;type[c] == type &amp;&amp; coup-&gt;id_select[c] == elem_id) {
+                    if (coup-&gt;ch_select[c] != 1) {
+                        apply_coupling_method(ac, &amp;cc-&gt;ch[0], cce, index);
+                        if (coup-&gt;ch_select[c] != 0)
+                            index++;
+                    }
+                    if (coup-&gt;ch_select[c] != 2)
+                        apply_coupling_method(ac, &amp;cc-&gt;ch[1], cce, index++);
+                } else
+                    index += 1 + (coup-&gt;ch_select[c] == 3);
+            }
+        }
+    }
+}
+
+/**
+ * Convert spectral data to float samples, applying all supported tools as appropriate.
+ */
+static void spectral_to_sample(AACContext *ac)
+{
+    int i, type;
+    float imdct_bias = (ac-&gt;m4ac.sbr &lt;= 0) ? ac-&gt;add_bias : 0.0f;
+    for (type = 3; type &gt;= 0; type--) {
+        for (i = 0; i &lt; MAX_ELEM_ID; i++) {
+            ChannelElement *che = ac-&gt;che[type][i];
+            if (che) {
+                if (type &lt;= TYPE_CPE)
+                    apply_channel_coupling(ac, che, type, i, BEFORE_TNS, apply_dependent_coupling);
+                if (che-&gt;ch[0].tns.present)
+                    apply_tns(che-&gt;ch[0].coeffs, &amp;che-&gt;ch[0].tns, &amp;che-&gt;ch[0].ics, 1);
+                if (che-&gt;ch[1].tns.present)
+                    apply_tns(che-&gt;ch[1].coeffs, &amp;che-&gt;ch[1].tns, &amp;che-&gt;ch[1].ics, 1);
+                if (type &lt;= TYPE_CPE)
+                    apply_channel_coupling(ac, che, type, i, BETWEEN_TNS_AND_IMDCT, apply_dependent_coupling);
+                if (type != TYPE_CCE || che-&gt;coup.coupling_point == AFTER_IMDCT) {
+                    imdct_and_windowing(ac, &amp;che-&gt;ch[0], imdct_bias);
+                    if (type == TYPE_CPE) {
+                        imdct_and_windowing(ac, &amp;che-&gt;ch[1], imdct_bias);
+                    }
+                    if (ac-&gt;m4ac.sbr &gt; 0) {
+                        ff_sbr_apply(ac, &amp;che-&gt;sbr, type, che-&gt;ch[0].ret, che-&gt;ch[1].ret);
+                    }
+                }
+                if (type &lt;= TYPE_CCE)
+                    apply_channel_coupling(ac, che, type, i, AFTER_IMDCT, apply_independent_coupling);
+            }
+        }
+    }
+}
+
+static int parse_adts_frame_header(AACContext *ac, GetBitContext *gb)
+{
+    int size;
+    AACADTSHeaderInfo hdr_info;
+
+    size = ff_aac_parse_header(gb, &amp;hdr_info);
+    if (size &gt; 0) {
+        if (ac-&gt;output_configured != OC_LOCKED &amp;&amp; hdr_info.chan_config) {
+            enum ChannelPosition new_che_pos[4][MAX_ELEM_ID];
+            memset(new_che_pos, 0, 4 * MAX_ELEM_ID * sizeof(new_che_pos[0][0]));
+            ac-&gt;m4ac.chan_config = hdr_info.chan_config;
+            if (set_default_channel_config(ac, new_che_pos, hdr_info.chan_config))
+                return -7;
+            if (output_configure(ac, ac-&gt;che_pos, new_che_pos, hdr_info.chan_config, OC_TRIAL_FRAME))
+                return -7;
+        } else if (ac-&gt;output_configured != OC_LOCKED) {
+            ac-&gt;output_configured = OC_NONE;
+        }
+        if (ac-&gt;output_configured != OC_LOCKED) {
+            ac-&gt;m4ac.sbr = -1;
+            ac-&gt;m4ac.ps  = -1;
+        }
+        ac-&gt;m4ac.sample_rate     = hdr_info.sample_rate;
+        ac-&gt;m4ac.sampling_index  = hdr_info.sampling_index;
+        ac-&gt;m4ac.object_type     = hdr_info.object_type;
+        if (!ac-&gt;avctx-&gt;sample_rate)
+            ac-&gt;avctx-&gt;sample_rate = hdr_info.sample_rate;
+        if (hdr_info.num_aac_frames == 1) {
+            if (!hdr_info.crc_absent)
+                skip_bits(gb, 16);
+        } else {
+            av_log_missing_feature(ac-&gt;avctx, &quot;More than one AAC RDB per ADTS frame is&quot;, 0);
+            return -1;
+        }
+    }
+    return size;
+}
+
+static int aac_decode_frame(AVCodecContext *avctx, void *data,
+                            int *data_size, AVPacket *avpkt)
+{
+    const uint8_t *buf = avpkt-&gt;data;
+    int buf_size = avpkt-&gt;size;
+    AACContext *ac = avctx-&gt;priv_data;
+    ChannelElement *che = NULL, *che_prev = NULL;
+    GetBitContext gb;
+    enum RawDataBlockType elem_type, elem_type_prev = TYPE_END;
+    int err, elem_id, data_size_tmp;
+    int buf_consumed;
+    int samples = 0, multiplier;
+    int buf_offset;
+
+    init_get_bits(&amp;gb, buf, buf_size * 8);
+
+    if (show_bits(&amp;gb, 12) == 0xfff) {
+        if (parse_adts_frame_header(ac, &amp;gb) &lt; 0) {
+            av_log(avctx, AV_LOG_ERROR, &quot;Error decoding AAC frame header.\n&quot;);
+            return -1;
+        }
+        if (ac-&gt;m4ac.sampling_index &gt; 12) {
+            av_log(ac-&gt;avctx, AV_LOG_ERROR, &quot;invalid sampling rate index %d\n&quot;, ac-&gt;m4ac.sampling_index);
+            return -1;
+        }
+    }
+
+    memset(ac-&gt;tags_seen_this_frame, 0, sizeof(ac-&gt;tags_seen_this_frame));
+    // parse
+    while ((elem_type = get_bits(&amp;gb, 3)) != TYPE_END) {
+        elem_id = get_bits(&amp;gb, 4);
+
+        if (elem_type &lt; TYPE_DSE) {
+            if (!(che=get_che(ac, elem_type, elem_id))) {
+                av_log(ac-&gt;avctx, AV_LOG_ERROR, &quot;channel element %d.%d is not allocated\n&quot;,
+                       elem_type, elem_id);
+                return -1;
+            }
+            samples = 1024;
+        }
+
+        switch (elem_type) {
+
+        case TYPE_SCE:
+            err = decode_ics(ac, &amp;che-&gt;ch[0], &amp;gb, 0, 0);
+            break;
+
+        case TYPE_CPE:
+            err = decode_cpe(ac, &amp;gb, che);
+            break;
+
+        case TYPE_CCE:
+            err = decode_cce(ac, &amp;gb, che);
+            break;
+
+        case TYPE_LFE:
+            err = decode_ics(ac, &amp;che-&gt;ch[0], &amp;gb, 0, 0);
+            break;
+
+        case TYPE_DSE:
+            err = skip_data_stream_element(ac, &amp;gb);
+            break;
+
+        case TYPE_PCE: {
+            enum ChannelPosition new_che_pos[4][MAX_ELEM_ID];
+            memset(new_che_pos, 0, 4 * MAX_ELEM_ID * sizeof(new_che_pos[0][0]));
+            if ((err = decode_pce(ac, new_che_pos, &amp;gb)))
+                break;
+            if (ac-&gt;output_configured &gt; OC_TRIAL_PCE)
+                av_log(avctx, AV_LOG_ERROR,
+                       &quot;Not evaluating a further program_config_element as this construct is dubious at best.\n&quot;);
+            else
+                err = output_configure(ac, ac-&gt;che_pos, new_che_pos, 0, OC_TRIAL_PCE);
+            break;
+        }
+
+        case TYPE_FIL:
+            if (elem_id == 15)
+                elem_id += get_bits(&amp;gb, 8) - 1;
+            if (get_bits_left(&amp;gb) &lt; 8 * elem_id) {
+                    av_log(avctx, AV_LOG_ERROR, overread_err);
+                    return -1;
+            }
+            while (elem_id &gt; 0)
+                elem_id -= decode_extension_payload(ac, &amp;gb, elem_id, che_prev, elem_type_prev);
+            err = 0; /* FIXME */
+            break;
+
+        default:
+            err = -1; /* should not happen, but keeps compiler happy */
+            break;
+        }
+
+        che_prev       = che;
+        elem_type_prev = elem_type;
+
+        if (err)
+            return err;
+
+        if (get_bits_left(&amp;gb) &lt; 3) {
+            av_log(avctx, AV_LOG_ERROR, overread_err);
+            return -1;
+        }
+    }
+
+    spectral_to_sample(ac);
+
+    multiplier = (ac-&gt;m4ac.sbr == 1) ? ac-&gt;m4ac.ext_sample_rate &gt; ac-&gt;m4ac.sample_rate : 0;
+    samples &lt;&lt;= multiplier;
+    if (ac-&gt;output_configured &lt; OC_LOCKED) {
+        avctx-&gt;sample_rate = ac-&gt;m4ac.sample_rate &lt;&lt; multiplier;
+        avctx-&gt;frame_size = samples;
+    }
+
+    data_size_tmp = samples * avctx-&gt;channels * sizeof(int16_t);
+    if (*data_size &lt; data_size_tmp) {
+        av_log(avctx, AV_LOG_ERROR,
+               &quot;Output buffer too small (%d) or trying to output too many samples (%d) for this frame.\n&quot;,
+               *data_size, data_size_tmp);
+        return -1;
+    }
+    *data_size = data_size_tmp;
+
+    if (samples)
+        ac-&gt;dsp.float_to_int16_interleave(data, (const float **)ac-&gt;output_data, samples, avctx-&gt;channels);
+
+    if (ac-&gt;output_configured)
+        ac-&gt;output_configured = OC_LOCKED;
+
+    buf_consumed = (get_bits_count(&amp;gb) + 7) &gt;&gt; 3;
+    for (buf_offset = buf_consumed; buf_offset &lt; buf_size; buf_offset++)
+        if (buf[buf_offset])
+            break;
+
+    return buf_size &gt; buf_offset ? buf_consumed : buf_size;
+}
+
+static av_cold int aac_decode_close(AVCodecContext *avctx)
+{
+    AACContext *ac = avctx-&gt;priv_data;
+    int i, type;
+
+    for (i = 0; i &lt; MAX_ELEM_ID; i++) {
+        for (type = 0; type &lt; 4; type++) {
+            if (ac-&gt;che[type][i])
+                ff_aac_sbr_ctx_close(&amp;ac-&gt;che[type][i]-&gt;sbr);
+            av_freep(&amp;ac-&gt;che[type][i]);
+        }
+    }
+
+    ff_mdct_end(&amp;ac-&gt;mdct);
+    ff_mdct_end(&amp;ac-&gt;mdct_small);
+    return 0;
+}
+
+AVCodec aac_decoder = {
+    &quot;aac&quot;,
+    AVMEDIA_TYPE_AUDIO,
+    CODEC_ID_AAC,
+    sizeof(AACContext),
+    aac_decode_init,
+    NULL,
+    aac_decode_close,
+    aac_decode_frame,
+    .long_name = NULL_IF_CONFIG_SMALL(&quot;Advanced Audio Coding&quot;),
+    .sample_fmts = (const enum SampleFormat[]) {
+        SAMPLE_FMT_S16,SAMPLE_FMT_NONE
+    },
+    .channel_layouts = aac_channel_layout,
+};

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/dct32.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/dct32.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/dct32.c	2010-07-25 10:07:39 UTC (rev 6478)
@@ -0,0 +1,267 @@
+/*
+ * Template for the Discrete Cosine Transform for 32 samples
+ * Copyright (c) 2001, 2002 Fabrice Bellard
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifdef DCT32_FLOAT
+#   define FIXHR(x)       ((float)(x))
+#   define MULH3(x, y, s) ((s)*(y)*(x))
+#   define INTFLOAT float
+#endif
+
+
+/* tab[i][j] = 1.0 / (2.0 * cos(pi*(2*k+1) / 2^(6 - j))) */
+
+/* cos(i*pi/64) */
+
+#define COS0_0  FIXHR(0.50060299823519630134/2)
+#define COS0_1  FIXHR(0.50547095989754365998/2)
+#define COS0_2  FIXHR(0.51544730992262454697/2)
+#define COS0_3  FIXHR(0.53104259108978417447/2)
+#define COS0_4  FIXHR(0.55310389603444452782/2)
+#define COS0_5  FIXHR(0.58293496820613387367/2)
+#define COS0_6  FIXHR(0.62250412303566481615/2)
+#define COS0_7  FIXHR(0.67480834145500574602/2)
+#define COS0_8  FIXHR(0.74453627100229844977/2)
+#define COS0_9  FIXHR(0.83934964541552703873/2)
+#define COS0_10 FIXHR(0.97256823786196069369/2)
+#define COS0_11 FIXHR(1.16943993343288495515/4)
+#define COS0_12 FIXHR(1.48416461631416627724/4)
+#define COS0_13 FIXHR(2.05778100995341155085/8)
+#define COS0_14 FIXHR(3.40760841846871878570/8)
+#define COS0_15 FIXHR(10.19000812354805681150/32)
+
+#define COS1_0 FIXHR(0.50241928618815570551/2)
+#define COS1_1 FIXHR(0.52249861493968888062/2)
+#define COS1_2 FIXHR(0.56694403481635770368/2)
+#define COS1_3 FIXHR(0.64682178335999012954/2)
+#define COS1_4 FIXHR(0.78815462345125022473/2)
+#define COS1_5 FIXHR(1.06067768599034747134/4)
+#define COS1_6 FIXHR(1.72244709823833392782/4)
+#define COS1_7 FIXHR(5.10114861868916385802/16)
+
+#define COS2_0 FIXHR(0.50979557910415916894/2)
+#define COS2_1 FIXHR(0.60134488693504528054/2)
+#define COS2_2 FIXHR(0.89997622313641570463/2)
+#define COS2_3 FIXHR(2.56291544774150617881/8)
+
+#define COS3_0 FIXHR(0.54119610014619698439/2)
+#define COS3_1 FIXHR(1.30656296487637652785/4)
+
+#define COS4_0 FIXHR(0.70710678118654752439/2)
+
+/* butterfly operator */
+#define BF(a, b, c, s)\
+{\
+    tmp0 = val##a + val##b;\
+    tmp1 = val##a - val##b;\
+    val##a = tmp0;\
+    val##b = MULH3(tmp1, c, 1&lt;&lt;(s));\
+}
+
+#define BF0(a, b, c, s)\
+{\
+    tmp0 = tab[a] + tab[b];\
+    tmp1 = tab[a] - tab[b];\
+    val##a = tmp0;\
+    val##b = MULH3(tmp1, c, 1&lt;&lt;(s));\
+}
+
+#define BF1(a, b, c, d)\
+{\
+    BF(a, b, COS4_0, 1);\
+    BF(c, d,-COS4_0, 1);\
+    val##c += val##d;\
+}
+
+#define BF2(a, b, c, d)\
+{\
+    BF(a, b, COS4_0, 1);\
+    BF(c, d,-COS4_0, 1);\
+    val##c += val##d;\
+    val##a += val##c;\
+    val##c += val##b;\
+    val##b += val##d;\
+}
+
+#define ADD(a, b) val##a += val##b
+
+/* DCT32 without 1/sqrt(2) coef zero scaling. */
+static void dct32(INTFLOAT *out, const INTFLOAT *tab)
+{
+    INTFLOAT tmp0, tmp1;
+
+    INTFLOAT val0 , val1 , val2 , val3 , val4 , val5 , val6 , val7 ,
+             val8 , val9 , val10, val11, val12, val13, val14, val15,
+             val16, val17, val18, val19, val20, val21, val22, val23,
+             val24, val25, val26, val27, val28, val29, val30, val31;
+
+    /* pass 1 */
+    BF0( 0, 31, COS0_0 , 1);
+    BF0(15, 16, COS0_15, 5);
+    /* pass 2 */
+    BF( 0, 15, COS1_0 , 1);
+    BF(16, 31,-COS1_0 , 1);
+    /* pass 1 */
+    BF0( 7, 24, COS0_7 , 1);
+    BF0( 8, 23, COS0_8 , 1);
+    /* pass 2 */
+    BF( 7,  8, COS1_7 , 4);
+    BF(23, 24,-COS1_7 , 4);
+    /* pass 3 */
+    BF( 0,  7, COS2_0 , 1);
+    BF( 8, 15,-COS2_0 , 1);
+    BF(16, 23, COS2_0 , 1);
+    BF(24, 31,-COS2_0 , 1);
+    /* pass 1 */
+    BF0( 3, 28, COS0_3 , 1);
+    BF0(12, 19, COS0_12, 2);
+    /* pass 2 */
+    BF( 3, 12, COS1_3 , 1);
+    BF(19, 28,-COS1_3 , 1);
+    /* pass 1 */
+    BF0( 4, 27, COS0_4 , 1);
+    BF0(11, 20, COS0_11, 2);
+    /* pass 2 */
+    BF( 4, 11, COS1_4 , 1);
+    BF(20, 27,-COS1_4 , 1);
+    /* pass 3 */
+    BF( 3,  4, COS2_3 , 3);
+    BF(11, 12,-COS2_3 , 3);
+    BF(19, 20, COS2_3 , 3);
+    BF(27, 28,-COS2_3 , 3);
+    /* pass 4 */
+    BF( 0,  3, COS3_0 , 1);
+    BF( 4,  7,-COS3_0 , 1);
+    BF( 8, 11, COS3_0 , 1);
+    BF(12, 15,-COS3_0 , 1);
+    BF(16, 19, COS3_0 , 1);
+    BF(20, 23,-COS3_0 , 1);
+    BF(24, 27, COS3_0 , 1);
+    BF(28, 31,-COS3_0 , 1);
+
+
+
+    /* pass 1 */
+    BF0( 1, 30, COS0_1 , 1);
+    BF0(14, 17, COS0_14, 3);
+    /* pass 2 */
+    BF( 1, 14, COS1_1 , 1);
+    BF(17, 30,-COS1_1 , 1);
+    /* pass 1 */
+    BF0( 6, 25, COS0_6 , 1);
+    BF0( 9, 22, COS0_9 , 1);
+    /* pass 2 */
+    BF( 6,  9, COS1_6 , 2);
+    BF(22, 25,-COS1_6 , 2);
+    /* pass 3 */
+    BF( 1,  6, COS2_1 , 1);
+    BF( 9, 14,-COS2_1 , 1);
+    BF(17, 22, COS2_1 , 1);
+    BF(25, 30,-COS2_1 , 1);
+
+    /* pass 1 */
+    BF0( 2, 29, COS0_2 , 1);
+    BF0(13, 18, COS0_13, 3);
+    /* pass 2 */
+    BF( 2, 13, COS1_2 , 1);
+    BF(18, 29,-COS1_2 , 1);
+    /* pass 1 */
+    BF0( 5, 26, COS0_5 , 1);
+    BF0(10, 21, COS0_10, 1);
+    /* pass 2 */
+    BF( 5, 10, COS1_5 , 2);
+    BF(21, 26,-COS1_5 , 2);
+    /* pass 3 */
+    BF( 2,  5, COS2_2 , 1);
+    BF(10, 13,-COS2_2 , 1);
+    BF(18, 21, COS2_2 , 1);
+    BF(26, 29,-COS2_2 , 1);
+    /* pass 4 */
+    BF( 1,  2, COS3_1 , 2);
+    BF( 5,  6,-COS3_1 , 2);
+    BF( 9, 10, COS3_1 , 2);
+    BF(13, 14,-COS3_1 , 2);
+    BF(17, 18, COS3_1 , 2);
+    BF(21, 22,-COS3_1 , 2);
+    BF(25, 26, COS3_1 , 2);
+    BF(29, 30,-COS3_1 , 2);
+
+    /* pass 5 */
+    BF1( 0,  1,  2,  3);
+    BF2( 4,  5,  6,  7);
+    BF1( 8,  9, 10, 11);
+    BF2(12, 13, 14, 15);
+    BF1(16, 17, 18, 19);
+    BF2(20, 21, 22, 23);
+    BF1(24, 25, 26, 27);
+    BF2(28, 29, 30, 31);
+
+    /* pass 6 */
+
+    ADD( 8, 12);
+    ADD(12, 10);
+    ADD(10, 14);
+    ADD(14,  9);
+    ADD( 9, 13);
+    ADD(13, 11);
+    ADD(11, 15);
+
+    out[ 0] = val0;
+    out[16] = val1;
+    out[ 8] = val2;
+    out[24] = val3;
+    out[ 4] = val4;
+    out[20] = val5;
+    out[12] = val6;
+    out[28] = val7;
+    out[ 2] = val8;
+    out[18] = val9;
+    out[10] = val10;
+    out[26] = val11;
+    out[ 6] = val12;
+    out[22] = val13;
+    out[14] = val14;
+    out[30] = val15;
+
+    ADD(24, 28);
+    ADD(28, 26);
+    ADD(26, 30);
+    ADD(30, 25);
+    ADD(25, 29);
+    ADD(29, 27);
+    ADD(27, 31);
+
+    out[ 1] = val16 + val24;
+    out[17] = val17 + val25;
+    out[ 9] = val18 + val26;
+    out[25] = val19 + val27;
+    out[ 5] = val20 + val28;
+    out[21] = val21 + val29;
+    out[13] = val22 + val30;
+    out[29] = val23 + val31;
+    out[ 3] = val24 + val20;
+    out[19] = val25 + val21;
+    out[11] = val26 + val22;
+    out[27] = val27 + val23;
+    out[ 7] = val28 + val18;
+    out[23] = val29 + val19;
+    out[15] = val30 + val17;
+    out[31] = val31;
+}

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/dxva2_mpeg2.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/dxva2_mpeg2.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/dxva2_mpeg2.c	2010-07-25 10:07:39 UTC (rev 6478)
@@ -0,0 +1,274 @@
+/*
+ * MPEG-2 HW acceleration.
+ *
+ * copyright (c) 2010 Laurent Aimar
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include &quot;dxva2_internal.h&quot;
+
+#define MAX_SLICES (SLICE_MAX_START_CODE - SLICE_MIN_START_CODE + 1)
+struct dxva2_picture_context {
+    DXVA_PictureParameters pp;
+    DXVA_QmatrixData       qm;
+    unsigned               slice_count;
+    DXVA_SliceInfo         slice[MAX_SLICES];
+
+    const uint8_t          *bitstream;
+    unsigned               bitstream_size;
+};
+
+static void fill_picture_parameters(AVCodecContext *avctx,
+                                    struct dxva_context *ctx,
+                                    const struct MpegEncContext *s,
+                                    DXVA_PictureParameters *pp)
+{
+    const Picture *current_picture = s-&gt;current_picture_ptr;
+    int is_field = s-&gt;picture_structure != PICT_FRAME;
+
+    memset(pp, 0, sizeof(*pp));
+    pp-&gt;wDecodedPictureIndex         = ff_dxva2_get_surface_index(ctx, current_picture);
+    pp-&gt;wDeblockedPictureIndex       = 0;
+    if (s-&gt;pict_type != FF_I_TYPE)
+        pp-&gt;wForwardRefPictureIndex  = ff_dxva2_get_surface_index(ctx, &amp;s-&gt;last_picture);
+    else
+        pp-&gt;wForwardRefPictureIndex  = 0xffff;
+    if (s-&gt;pict_type == FF_B_TYPE)
+        pp-&gt;wBackwardRefPictureIndex = ff_dxva2_get_surface_index(ctx, &amp;s-&gt;next_picture);
+    else
+        pp-&gt;wBackwardRefPictureIndex = 0xffff;
+    pp-&gt;wPicWidthInMBminus1          = s-&gt;mb_width  - 1;
+    pp-&gt;wPicHeightInMBminus1         = (s-&gt;mb_height &gt;&gt; is_field) - 1;
+    pp-&gt;bMacroblockWidthMinus1       = 15;
+    pp-&gt;bMacroblockHeightMinus1      = 15;
+    pp-&gt;bBlockWidthMinus1            = 7;
+    pp-&gt;bBlockHeightMinus1           = 7;
+    pp-&gt;bBPPminus1                   = 7;
+    pp-&gt;bPicStructure                = s-&gt;picture_structure;
+    pp-&gt;bSecondField                 = is_field &amp;&amp; !s-&gt;first_field;
+    pp-&gt;bPicIntra                    = s-&gt;pict_type == FF_I_TYPE;
+    pp-&gt;bPicBackwardPrediction       = s-&gt;pict_type == FF_B_TYPE;
+    pp-&gt;bBidirectionalAveragingMode  = 0;
+    pp-&gt;bMVprecisionAndChromaRelation= 0; /* FIXME */
+    pp-&gt;bChromaFormat                = s-&gt;chroma_format;
+    pp-&gt;bPicScanFixed                = 1;
+    pp-&gt;bPicScanMethod               = s-&gt;alternate_scan ? 1 : 0;
+    pp-&gt;bPicReadbackRequests         = 0;
+    pp-&gt;bRcontrol                    = 0;
+    pp-&gt;bPicSpatialResid8            = 0;
+    pp-&gt;bPicOverflowBlocks           = 0;
+    pp-&gt;bPicExtrapolation            = 0;
+    pp-&gt;bPicDeblocked                = 0;
+    pp-&gt;bPicDeblockConfined          = 0;
+    pp-&gt;bPic4MVallowed               = 0;
+    pp-&gt;bPicOBMC                     = 0;
+    pp-&gt;bPicBinPB                    = 0;
+    pp-&gt;bMV_RPS                      = 0;
+    pp-&gt;bReservedBits                = 0;
+    pp-&gt;wBitstreamFcodes             = (s-&gt;mpeg_f_code[0][0] &lt;&lt; 12) |
+                                       (s-&gt;mpeg_f_code[0][1] &lt;&lt;  8) |
+                                       (s-&gt;mpeg_f_code[1][0] &lt;&lt;  4) |
+                                       (s-&gt;mpeg_f_code[1][1]      );
+    pp-&gt;wBitstreamPCEelements        = (s-&gt;intra_dc_precision         &lt;&lt; 14) |
+                                       (s-&gt;picture_structure          &lt;&lt; 12) |
+                                       (s-&gt;top_field_first            &lt;&lt; 11) |
+                                       (s-&gt;frame_pred_frame_dct       &lt;&lt; 10) |
+                                       (s-&gt;concealment_motion_vectors &lt;&lt;  9) |
+                                       (s-&gt;q_scale_type               &lt;&lt;  8) |
+                                       (s-&gt;intra_vlc_format           &lt;&lt;  7) |
+                                       (s-&gt;alternate_scan             &lt;&lt;  6) |
+                                       (s-&gt;repeat_first_field         &lt;&lt;  5) |
+                                       (s-&gt;chroma_420_type            &lt;&lt;  4) |
+                                       (s-&gt;progressive_frame          &lt;&lt;  3);
+    pp-&gt;bBitstreamConcealmentNeed    = 0;
+    pp-&gt;bBitstreamConcealmentMethod  = 0;
+}
+
+static void fill_quantization_matrices(AVCodecContext *avctx,
+                                       struct dxva_context *ctx,
+                                       const struct MpegEncContext *s,
+                                       DXVA_QmatrixData *qm)
+{
+    int i;
+    for (i = 0; i &lt; 4; i++)
+        qm-&gt;bNewQmatrix[i] = 1;
+    for (i = 0; i &lt; 64; i++) {
+        int n = s-&gt;dsp.idct_permutation[ff_zigzag_direct[i]];
+        qm-&gt;Qmatrix[0][i] = s-&gt;intra_matrix[n];;
+        qm-&gt;Qmatrix[1][i] = s-&gt;inter_matrix[n];;
+        qm-&gt;Qmatrix[2][i] = s-&gt;chroma_intra_matrix[n];;
+        qm-&gt;Qmatrix[3][i] = s-&gt;chroma_inter_matrix[n];;
+    }
+}
+
+static void fill_slice(AVCodecContext *avctx,
+                       const struct MpegEncContext *s,
+                       DXVA_SliceInfo *slice,
+                       unsigned position,
+                       const uint8_t *buffer, unsigned size)
+{
+    int is_field = s-&gt;picture_structure != PICT_FRAME;
+    GetBitContext gb;
+
+    memset(slice, 0, sizeof(*slice));
+    slice-&gt;wHorizontalPosition = s-&gt;mb_x;
+    slice-&gt;wVerticalPosition   = s-&gt;mb_y &gt;&gt; is_field;
+    slice-&gt;dwSliceBitsInBuffer = 8 * size;
+    slice-&gt;dwSliceDataLocation = position;
+    slice-&gt;bStartCodeBitOffset = 0;
+    slice-&gt;bReservedBits       = 0;
+    /* XXX We store the index of the first MB and it will be fixed later */
+    slice-&gt;wNumberMBsInSlice   = (s-&gt;mb_y &gt;&gt; is_field) * s-&gt;mb_width + s-&gt;mb_x;
+    slice-&gt;wBadSliceChopping   = 0;
+
+    init_get_bits(&amp;gb, &amp;buffer[4], 8 * (size - 4));
+
+    slice-&gt;wQuantizerScaleCode = get_bits(&amp;gb, 5);
+    while (get_bits1(&amp;gb))
+        skip_bits(&amp;gb, 8);
+
+    slice-&gt;wMBbitOffset        = 4 * 8 + get_bits_count(&amp;gb);
+}
+static int commit_bitstream_and_slice_buffer(AVCodecContext *avctx,
+                                             DXVA2_DecodeBufferDesc *bs,
+                                             DXVA2_DecodeBufferDesc *sc)
+{
+    const struct MpegEncContext *s = avctx-&gt;priv_data;
+    struct dxva_context *ctx = avctx-&gt;hwaccel_context;
+    struct dxva2_picture_context *ctx_pic =
+        s-&gt;current_picture_ptr-&gt;hwaccel_picture_private;
+    const int is_field = s-&gt;picture_structure != PICT_FRAME;
+    const unsigned mb_count = s-&gt;mb_width * (s-&gt;mb_height &gt;&gt; is_field);
+    uint8_t  *dxva_data, *current, *end;
+    unsigned dxva_size;
+    unsigned i;
+
+    if (FAILED(IDirectXVideoDecoder_GetBuffer(ctx-&gt;decoder,
+                                              DXVA2_BitStreamDateBufferType,
+                                              &amp;dxva_data, &amp;dxva_size)))
+        return -1;
+    current = dxva_data;
+    end = dxva_data + dxva_size;
+
+    for (i = 0; i &lt; ctx_pic-&gt;slice_count; i++) {
+        DXVA_SliceInfo *slice = &amp;ctx_pic-&gt;slice[i];
+        unsigned position = slice-&gt;dwSliceDataLocation;
+        unsigned size     = slice-&gt;dwSliceBitsInBuffer / 8;
+        if (size &gt; end - current) {
+            av_log(avctx, AV_LOG_ERROR, &quot;Failed to build bitstream&quot;);
+            break;
+        }
+        slice-&gt;dwSliceDataLocation = current - dxva_data;
+
+        if (i &lt; ctx_pic-&gt;slice_count - 1)
+            slice-&gt;wNumberMBsInSlice =
+                slice[1].wNumberMBsInSlice - slice[0].wNumberMBsInSlice;
+        else
+            slice-&gt;wNumberMBsInSlice =
+                mb_count - slice[0].wNumberMBsInSlice;
+
+        memcpy(current, &amp;ctx_pic-&gt;bitstream[position], size);
+        current += size;
+    }
+    if (FAILED(IDirectXVideoDecoder_ReleaseBuffer(ctx-&gt;decoder,
+                                                  DXVA2_BitStreamDateBufferType)))
+        return -1;
+    if (i &lt; ctx_pic-&gt;slice_count)
+        return -1;
+
+    memset(bs, 0, sizeof(*bs));
+    bs-&gt;CompressedBufferType = DXVA2_BitStreamDateBufferType;
+    bs-&gt;DataSize             = current - dxva_data;
+    bs-&gt;NumMBsInBuffer       = mb_count;
+
+    return ff_dxva2_commit_buffer(avctx, ctx, sc,
+                                  DXVA2_SliceControlBufferType,
+                                  ctx_pic-&gt;slice,
+                                  ctx_pic-&gt;slice_count * sizeof(*ctx_pic-&gt;slice),
+                                  mb_count);
+}
+
+static int start_frame(AVCodecContext *avctx,
+                       av_unused const uint8_t *buffer,
+                       av_unused uint32_t size)
+{
+    const struct MpegEncContext *s = avctx-&gt;priv_data;
+    struct dxva_context *ctx = avctx-&gt;hwaccel_context;
+    struct dxva2_picture_context *ctx_pic =
+        s-&gt;current_picture_ptr-&gt;hwaccel_picture_private;
+
+    if (!ctx-&gt;decoder || !ctx-&gt;cfg || ctx-&gt;surface_count &lt;= 0)
+        return -1;
+    assert(ctx_pic);
+
+    fill_picture_parameters(avctx, ctx, s, &amp;ctx_pic-&gt;pp);
+    fill_quantization_matrices(avctx, ctx, s, &amp;ctx_pic-&gt;qm);
+
+    ctx_pic-&gt;slice_count    = 0;
+    ctx_pic-&gt;bitstream_size = 0;
+    ctx_pic-&gt;bitstream      = NULL;
+    return 0;
+}
+
+static int decode_slice(AVCodecContext *avctx,
+                        const uint8_t *buffer, uint32_t size)
+{
+    const struct MpegEncContext *s = avctx-&gt;priv_data;
+    struct dxva2_picture_context *ctx_pic =
+        s-&gt;current_picture_ptr-&gt;hwaccel_picture_private;
+    unsigned position;
+
+    if (ctx_pic-&gt;slice_count &gt;= MAX_SLICES)
+        return -1;
+
+    if (!ctx_pic-&gt;bitstream)
+        ctx_pic-&gt;bitstream = buffer;
+    ctx_pic-&gt;bitstream_size += size;
+
+    position = buffer - ctx_pic-&gt;bitstream;
+    fill_slice(avctx, s, &amp;ctx_pic-&gt;slice[ctx_pic-&gt;slice_count++], position,
+               buffer, size);
+    return 0;
+}
+
+static int end_frame(AVCodecContext *avctx)
+{
+    struct MpegEncContext *s = avctx-&gt;priv_data;
+    struct dxva2_picture_context *ctx_pic =
+        s-&gt;current_picture_ptr-&gt;hwaccel_picture_private;
+
+    if (ctx_pic-&gt;slice_count &lt;= 0 || ctx_pic-&gt;bitstream_size &lt;= 0)
+        return -1;
+    return ff_dxva2_common_end_frame(avctx, s,
+                                     &amp;ctx_pic-&gt;pp, sizeof(ctx_pic-&gt;pp),
+                                     &amp;ctx_pic-&gt;qm, sizeof(ctx_pic-&gt;qm),
+                                     commit_bitstream_and_slice_buffer);
+}
+
+AVHWAccel mpeg2_dxva2_hwaccel = {
+    .name           = &quot;mpeg2_dxva2&quot;,
+    .type           = AVMEDIA_TYPE_VIDEO,
+    .id             = CODEC_ID_MPEG2VIDEO,
+    .pix_fmt        = PIX_FMT_DXVA2_VLD,
+    .capabilities   = 0,
+    .start_frame    = start_frame,
+    .decode_slice   = decode_slice,
+    .end_frame      = end_frame,
+    .priv_data_size = sizeof(struct dxva2_picture_context),
+};
+

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/vp8.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/vp8.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/vp8.c	2010-07-25 10:07:39 UTC (rev 6478)
@@ -0,0 +1,1673 @@
+/**
+ * VP8 compatible video decoder
+ *
+ * Copyright (C) 2010 David Conrad
+ * Copyright (C) 2010 Ronald S. Bultje
+ * Copyright (C) 2010 Jason Garrett-Glaser
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include &quot;avcodec.h&quot;
+#include &quot;vp56.h&quot;
+#include &quot;vp8data.h&quot;
+#include &quot;vp8dsp.h&quot;
+#include &quot;h264pred.h&quot;
+#include &quot;rectangle.h&quot;
+
+typedef struct {
+    uint8_t filter_level;
+    uint8_t inner_limit;
+    uint8_t inner_filter;
+} VP8FilterStrength;
+
+typedef struct {
+    uint8_t skip;
+    // todo: make it possible to check for at least (i4x4 or split_mv)
+    // in one op. are others needed?
+    uint8_t mode;
+    uint8_t ref_frame;
+    uint8_t partitioning;
+    VP56mv mv;
+    VP56mv bmv[16];
+} VP8Macroblock;
+
+typedef struct {
+    AVCodecContext *avctx;
+    DSPContext dsp;
+    VP8DSPContext vp8dsp;
+    H264PredContext hpc;
+    vp8_mc_func put_pixels_tab[3][3][3];
+    AVFrame frames[4];
+    AVFrame *framep[4];
+    uint8_t *edge_emu_buffer;
+    VP56RangeCoder c;   ///&lt; header context, includes mb modes and motion vectors
+    int profile;
+
+    int mb_width;   /* number of horizontal MB */
+    int mb_height;  /* number of vertical MB */
+    int linesize;
+    int uvlinesize;
+
+    int keyframe;
+    int invisible;
+    int update_last;    ///&lt; update VP56_FRAME_PREVIOUS with the current one
+    int update_golden;  ///&lt; VP56_FRAME_NONE if not updated, or which frame to copy if so
+    int update_altref;
+    int deblock_filter;
+
+    /**
+     * If this flag is not set, all the probability updates
+     * are discarded after this frame is decoded.
+     */
+    int update_probabilities;
+
+    /**
+     * All coefficients are contained in separate arith coding contexts.
+     * There can be 1, 2, 4, or 8 of these after the header context.
+     */
+    int num_coeff_partitions;
+    VP56RangeCoder coeff_partition[8];
+
+    VP8Macroblock *macroblocks;
+    VP8Macroblock *macroblocks_base;
+    VP8FilterStrength *filter_strength;
+    int mb_stride;
+
+    uint8_t *intra4x4_pred_mode;
+    uint8_t *intra4x4_pred_mode_base;
+    uint8_t *segmentation_map;
+    int b4_stride;
+
+    /**
+     * Cache of the top row needed for intra prediction
+     * 16 for luma, 8 for each chroma plane
+     */
+    uint8_t (*top_border)[16+8+8];
+
+    /**
+     * For coeff decode, we need to know whether the above block had non-zero
+     * coefficients. This means for each macroblock, we need data for 4 luma
+     * blocks, 2 u blocks, 2 v blocks, and the luma dc block, for a total of 9
+     * per macroblock. We keep the last row in top_nnz.
+     */
+    uint8_t (*top_nnz)[9];
+    DECLARE_ALIGNED(8, uint8_t, left_nnz)[9];
+
+    /**
+     * This is the index plus one of the last non-zero coeff
+     * for each of the blocks in the current macroblock.
+     * So, 0 -&gt; no coeffs
+     *     1 -&gt; dc-only (special transform)
+     *     2+-&gt; full transform
+     */
+    DECLARE_ALIGNED(16, uint8_t, non_zero_count_cache)[6][4];
+    DECLARE_ALIGNED(16, DCTELEM, block)[6][4][16];
+    uint8_t intra4x4_pred_mode_mb[16];
+
+    int chroma_pred_mode;    ///&lt; 8x8c pred mode of the current macroblock
+    int segment;             ///&lt; segment of the current macroblock
+
+    int mbskip_enabled;
+    int sign_bias[4]; ///&lt; one state [0, 1] per ref frame type
+    int ref_count[3];
+
+    /**
+     * Base parameters for segmentation, i.e. per-macroblock parameters.
+     * These must be kept unchanged even if segmentation is not used for
+     * a frame, since the values persist between interframes.
+     */
+    struct {
+        int enabled;
+        int absolute_vals;
+        int update_map;
+        int8_t base_quant[4];
+        int8_t filter_level[4];     ///&lt; base loop filter level
+    } segmentation;
+
+    /**
+     * Macroblocks can have one of 4 different quants in a frame when
+     * segmentation is enabled.
+     * If segmentation is disabled, only the first segment's values are used.
+     */
+    struct {
+        // [0] - DC qmul  [1] - AC qmul
+        int16_t luma_qmul[2];
+        int16_t luma_dc_qmul[2];    ///&lt; luma dc-only block quant
+        int16_t chroma_qmul[2];
+    } qmat[4];
+
+    struct {
+        int simple;
+        int level;
+        int sharpness;
+    } filter;
+
+    struct {
+        int enabled;    ///&lt; whether each mb can have a different strength based on mode/ref
+
+        /**
+         * filter strength adjustment for the following macroblock modes:
+         * [0] - i4x4
+         * [1] - zero mv
+         * [2] - inter modes except for zero or split mv
+         * [3] - split mv
+         *  i16x16 modes never have any adjustment
+         */
+        int8_t mode[4];
+
+        /**
+         * filter strength adjustment for macroblocks that reference:
+         * [0] - intra / VP56_FRAME_CURRENT
+         * [1] - VP56_FRAME_PREVIOUS
+         * [2] - VP56_FRAME_GOLDEN
+         * [3] - altref / VP56_FRAME_GOLDEN2
+         */
+        int8_t ref[4];
+    } lf_delta;
+
+    /**
+     * These are all of the updatable probabilities for binary decisions.
+     * They are only implictly reset on keyframes, making it quite likely
+     * for an interframe to desync if a prior frame's header was corrupt
+     * or missing outright!
+     */
+    struct {
+        uint8_t segmentid[3];
+        uint8_t mbskip;
+        uint8_t intra;
+        uint8_t last;
+        uint8_t golden;
+        uint8_t pred16x16[4];
+        uint8_t pred8x8c[3];
+        uint8_t token[4][8][3][NUM_DCT_TOKENS-1];
+        uint8_t mvc[2][19];
+    } prob[2];
+} VP8Context;
+
+static void vp8_decode_flush(AVCodecContext *avctx)
+{
+    VP8Context *s = avctx-&gt;priv_data;
+    int i;
+
+    for (i = 0; i &lt; 4; i++)
+        if (s-&gt;frames[i].data[0])
+            avctx-&gt;release_buffer(avctx, &amp;s-&gt;frames[i]);
+    memset(s-&gt;framep, 0, sizeof(s-&gt;framep));
+
+    av_freep(&amp;s-&gt;macroblocks_base);
+    av_freep(&amp;s-&gt;intra4x4_pred_mode_base);
+    av_freep(&amp;s-&gt;top_nnz);
+    av_freep(&amp;s-&gt;edge_emu_buffer);
+    av_freep(&amp;s-&gt;top_border);
+    av_freep(&amp;s-&gt;segmentation_map);
+
+    s-&gt;macroblocks        = NULL;
+    s-&gt;intra4x4_pred_mode = NULL;
+}
+
+static int update_dimensions(VP8Context *s, int width, int height)
+{
+    int i;
+
+    if (avcodec_check_dimensions(s-&gt;avctx, width, height))
+        return AVERROR_INVALIDDATA;
+
+    vp8_decode_flush(s-&gt;avctx);
+
+    avcodec_set_dimensions(s-&gt;avctx, width, height);
+
+    s-&gt;mb_width  = (s-&gt;avctx-&gt;coded_width +15) / 16;
+    s-&gt;mb_height = (s-&gt;avctx-&gt;coded_height+15) / 16;
+
+    // we allocate a border around the top/left of intra4x4 modes
+    // this is 4 blocks for intra4x4 to keep 4-byte alignment for fill_rectangle
+    s-&gt;mb_stride = s-&gt;mb_width+1;
+    s-&gt;b4_stride = 4*s-&gt;mb_stride;
+
+    s-&gt;macroblocks_base        = av_mallocz((s-&gt;mb_stride+s-&gt;mb_height*2+2)*sizeof(*s-&gt;macroblocks));
+    s-&gt;filter_strength         = av_mallocz(s-&gt;mb_stride*sizeof(*s-&gt;filter_strength));
+    s-&gt;intra4x4_pred_mode_base = av_mallocz(s-&gt;b4_stride*(4*s-&gt;mb_height+1));
+    s-&gt;top_nnz                 = av_mallocz(s-&gt;mb_width*sizeof(*s-&gt;top_nnz));
+    s-&gt;top_border              = av_mallocz((s-&gt;mb_width+1)*sizeof(*s-&gt;top_border));
+    s-&gt;segmentation_map        = av_mallocz(s-&gt;mb_stride*s-&gt;mb_height);
+
+    if (!s-&gt;macroblocks_base || !s-&gt;filter_strength || !s-&gt;intra4x4_pred_mode_base ||
+        !s-&gt;top_nnz || !s-&gt;top_border || !s-&gt;segmentation_map)
+        return AVERROR(ENOMEM);
+
+    s-&gt;macroblocks        = s-&gt;macroblocks_base + 1;
+    s-&gt;intra4x4_pred_mode = s-&gt;intra4x4_pred_mode_base + 4 + s-&gt;b4_stride;
+
+    memset(s-&gt;intra4x4_pred_mode_base, DC_PRED, s-&gt;b4_stride);
+    for (i = 0; i &lt; 4*s-&gt;mb_height; i++)
+        s-&gt;intra4x4_pred_mode[i*s-&gt;b4_stride-1] = DC_PRED;
+
+    return 0;
+}
+
+static void parse_segment_info(VP8Context *s)
+{
+    VP56RangeCoder *c = &amp;s-&gt;c;
+    int i;
+
+    s-&gt;segmentation.update_map = vp8_rac_get(c);
+
+    if (vp8_rac_get(c)) { // update segment feature data
+        s-&gt;segmentation.absolute_vals = vp8_rac_get(c);
+
+        for (i = 0; i &lt; 4; i++)
+            s-&gt;segmentation.base_quant[i]   = vp8_rac_get_sint(c, 7);
+
+        for (i = 0; i &lt; 4; i++)
+            s-&gt;segmentation.filter_level[i] = vp8_rac_get_sint(c, 6);
+    }
+    if (s-&gt;segmentation.update_map)
+        for (i = 0; i &lt; 3; i++)
+            s-&gt;prob-&gt;segmentid[i] = vp8_rac_get(c) ? vp8_rac_get_uint(c, 8) : 255;
+}
+
+static void update_lf_deltas(VP8Context *s)
+{
+    VP56RangeCoder *c = &amp;s-&gt;c;
+    int i;
+
+    for (i = 0; i &lt; 4; i++)
+        s-&gt;lf_delta.ref[i]  = vp8_rac_get_sint(c, 6);
+
+    for (i = 0; i &lt; 4; i++)
+        s-&gt;lf_delta.mode[i] = vp8_rac_get_sint(c, 6);
+}
+
+static int setup_partitions(VP8Context *s, const uint8_t *buf, int buf_size)
+{
+    const uint8_t *sizes = buf;
+    int i;
+
+    s-&gt;num_coeff_partitions = 1 &lt;&lt; vp8_rac_get_uint(&amp;s-&gt;c, 2);
+
+    buf      += 3*(s-&gt;num_coeff_partitions-1);
+    buf_size -= 3*(s-&gt;num_coeff_partitions-1);
+    if (buf_size &lt; 0)
+        return -1;
+
+    for (i = 0; i &lt; s-&gt;num_coeff_partitions-1; i++) {
+        int size = AV_RL24(sizes + 3*i);
+        if (buf_size - size &lt; 0)
+            return -1;
+
+        vp56_init_range_decoder(&amp;s-&gt;coeff_partition[i], buf, size);
+        buf      += size;
+        buf_size -= size;
+    }
+    vp56_init_range_decoder(&amp;s-&gt;coeff_partition[i], buf, buf_size);
+
+    return 0;
+}
+
+static void get_quants(VP8Context *s)
+{
+    VP56RangeCoder *c = &amp;s-&gt;c;
+    int i, base_qi;
+
+    int yac_qi     = vp8_rac_get_uint(c, 7);
+    int ydc_delta  = vp8_rac_get_sint(c, 4);
+    int y2dc_delta = vp8_rac_get_sint(c, 4);
+    int y2ac_delta = vp8_rac_get_sint(c, 4);
+    int uvdc_delta = vp8_rac_get_sint(c, 4);
+    int uvac_delta = vp8_rac_get_sint(c, 4);
+
+    for (i = 0; i &lt; 4; i++) {
+        if (s-&gt;segmentation.enabled) {
+            base_qi = s-&gt;segmentation.base_quant[i];
+            if (!s-&gt;segmentation.absolute_vals)
+                base_qi += yac_qi;
+        } else
+            base_qi = yac_qi;
+
+        s-&gt;qmat[i].luma_qmul[0]    =       vp8_dc_qlookup[av_clip(base_qi + ydc_delta , 0, 127)];
+        s-&gt;qmat[i].luma_qmul[1]    =       vp8_ac_qlookup[av_clip(base_qi             , 0, 127)];
+        s-&gt;qmat[i].luma_dc_qmul[0] =   2 * vp8_dc_qlookup[av_clip(base_qi + y2dc_delta, 0, 127)];
+        s-&gt;qmat[i].luma_dc_qmul[1] = 155 * vp8_ac_qlookup[av_clip(base_qi + y2ac_delta, 0, 127)] / 100;
+        s-&gt;qmat[i].chroma_qmul[0]  =       vp8_dc_qlookup[av_clip(base_qi + uvdc_delta, 0, 127)];
+        s-&gt;qmat[i].chroma_qmul[1]  =       vp8_ac_qlookup[av_clip(base_qi + uvac_delta, 0, 127)];
+
+        s-&gt;qmat[i].luma_dc_qmul[1] = FFMAX(s-&gt;qmat[i].luma_dc_qmul[1], 8);
+        s-&gt;qmat[i].chroma_qmul[0]  = FFMIN(s-&gt;qmat[i].chroma_qmul[0], 132);
+    }
+}
+
+/**
+ * Determine which buffers golden and altref should be updated with after this frame.
+ * The spec isn't clear here, so I'm going by my understanding of what libvpx does
+ *
+ * Intra frames update all 3 references
+ * Inter frames update VP56_FRAME_PREVIOUS if the update_last flag is set
+ * If the update (golden|altref) flag is set, it's updated with the current frame
+ *      if update_last is set, and VP56_FRAME_PREVIOUS otherwise.
+ * If the flag is not set, the number read means:
+ *      0: no update
+ *      1: VP56_FRAME_PREVIOUS
+ *      2: update golden with altref, or update altref with golden
+ */
+static VP56Frame ref_to_update(VP8Context *s, int update, VP56Frame ref)
+{
+    VP56RangeCoder *c = &amp;s-&gt;c;
+
+    if (update)
+        return VP56_FRAME_CURRENT;
+
+    switch (vp8_rac_get_uint(c, 2)) {
+    case 1:
+        return VP56_FRAME_PREVIOUS;
+    case 2:
+        return (ref == VP56_FRAME_GOLDEN) ? VP56_FRAME_GOLDEN2 : VP56_FRAME_GOLDEN;
+    }
+    return VP56_FRAME_NONE;
+}
+
+static void update_refs(VP8Context *s)
+{
+    VP56RangeCoder *c = &amp;s-&gt;c;
+
+    int update_golden = vp8_rac_get(c);
+    int update_altref = vp8_rac_get(c);
+
+    s-&gt;update_golden = ref_to_update(s, update_golden, VP56_FRAME_GOLDEN);
+    s-&gt;update_altref = ref_to_update(s, update_altref, VP56_FRAME_GOLDEN2);
+}
+
+static int decode_frame_header(VP8Context *s, const uint8_t *buf, int buf_size)
+{
+    VP56RangeCoder *c = &amp;s-&gt;c;
+    int header_size, hscale, vscale, i, j, k, l, ret;
+    int width  = s-&gt;avctx-&gt;width;
+    int height = s-&gt;avctx-&gt;height;
+
+    s-&gt;keyframe  = !(buf[0] &amp; 1);
+    s-&gt;profile   =  (buf[0]&gt;&gt;1) &amp; 7;
+    s-&gt;invisible = !(buf[0] &amp; 0x10);
+    header_size  = AV_RL24(buf) &gt;&gt; 5;
+    buf      += 3;
+    buf_size -= 3;
+
+    if (s-&gt;profile &gt; 3)
+        av_log(s-&gt;avctx, AV_LOG_WARNING, &quot;Unknown profile %d\n&quot;, s-&gt;profile);
+
+    if (!s-&gt;profile)
+        memcpy(s-&gt;put_pixels_tab, s-&gt;vp8dsp.put_vp8_epel_pixels_tab, sizeof(s-&gt;put_pixels_tab));
+    else    // profile 1-3 use bilinear, 4+ aren't defined so whatever
+        memcpy(s-&gt;put_pixels_tab, s-&gt;vp8dsp.put_vp8_bilinear_pixels_tab, sizeof(s-&gt;put_pixels_tab));
+
+    if (header_size &gt; buf_size - 7*s-&gt;keyframe) {
+        av_log(s-&gt;avctx, AV_LOG_ERROR, &quot;Header size larger than data provided\n&quot;);
+        return AVERROR_INVALIDDATA;
+    }
+
+    if (s-&gt;keyframe) {
+        if (AV_RL24(buf) != 0x2a019d) {
+            av_log(s-&gt;avctx, AV_LOG_ERROR, &quot;Invalid start code 0x%x\n&quot;, AV_RL24(buf));
+            return AVERROR_INVALIDDATA;
+        }
+        width  = AV_RL16(buf+3) &amp; 0x3fff;
+        height = AV_RL16(buf+5) &amp; 0x3fff;
+        hscale = buf[4] &gt;&gt; 6;
+        vscale = buf[6] &gt;&gt; 6;
+        buf      += 7;
+        buf_size -= 7;
+
+        if (hscale || vscale)
+            av_log_missing_feature(s-&gt;avctx, &quot;Upscaling&quot;, 1);
+
+        s-&gt;update_golden = s-&gt;update_altref = VP56_FRAME_CURRENT;
+        memcpy(s-&gt;prob-&gt;token    , vp8_token_default_probs , sizeof(s-&gt;prob-&gt;token));
+        memcpy(s-&gt;prob-&gt;pred16x16, vp8_pred16x16_prob_inter, sizeof(s-&gt;prob-&gt;pred16x16));
+        memcpy(s-&gt;prob-&gt;pred8x8c , vp8_pred8x8c_prob_inter , sizeof(s-&gt;prob-&gt;pred8x8c));
+        memcpy(s-&gt;prob-&gt;mvc      , vp8_mv_default_prob     , sizeof(s-&gt;prob-&gt;mvc));
+        memset(&amp;s-&gt;segmentation, 0, sizeof(s-&gt;segmentation));
+    }
+
+    if (!s-&gt;macroblocks_base || /* first frame */
+        width != s-&gt;avctx-&gt;width || height != s-&gt;avctx-&gt;height) {
+        if ((ret = update_dimensions(s, width, height) &lt; 0))
+            return ret;
+    }
+
+    vp56_init_range_decoder(c, buf, header_size);
+    buf      += header_size;
+    buf_size -= header_size;
+
+    if (s-&gt;keyframe) {
+        if (vp8_rac_get(c))
+            av_log(s-&gt;avctx, AV_LOG_WARNING, &quot;Unspecified colorspace\n&quot;);
+        vp8_rac_get(c); // whether we can skip clamping in dsp functions
+    }
+
+    if ((s-&gt;segmentation.enabled = vp8_rac_get(c)))
+        parse_segment_info(s);
+    else
+        s-&gt;segmentation.update_map = 0; // FIXME: move this to some init function?
+
+    s-&gt;filter.simple    = vp8_rac_get(c);
+    s-&gt;filter.level     = vp8_rac_get_uint(c, 6);
+    s-&gt;filter.sharpness = vp8_rac_get_uint(c, 3);
+
+    if ((s-&gt;lf_delta.enabled = vp8_rac_get(c)))
+        if (vp8_rac_get(c))
+            update_lf_deltas(s);
+
+    if (setup_partitions(s, buf, buf_size)) {
+        av_log(s-&gt;avctx, AV_LOG_ERROR, &quot;Invalid partitions\n&quot;);
+        return AVERROR_INVALIDDATA;
+    }
+
+    get_quants(s);
+
+    if (!s-&gt;keyframe) {
+        update_refs(s);
+        s-&gt;sign_bias[VP56_FRAME_GOLDEN]               = vp8_rac_get(c);
+        s-&gt;sign_bias[VP56_FRAME_GOLDEN2 /* altref */] = vp8_rac_get(c);
+    }
+
+    // if we aren't saving this frame's probabilities for future frames,
+    // make a copy of the current probabilities
+    if (!(s-&gt;update_probabilities = vp8_rac_get(c)))
+        s-&gt;prob[1] = s-&gt;prob[0];
+
+    s-&gt;update_last = s-&gt;keyframe || vp8_rac_get(c);
+
+    for (i = 0; i &lt; 4; i++)
+        for (j = 0; j &lt; 8; j++)
+            for (k = 0; k &lt; 3; k++)
+                for (l = 0; l &lt; NUM_DCT_TOKENS-1; l++)
+                    if (vp56_rac_get_prob_branchy(c, vp8_token_update_probs[i][j][k][l]))
+                        s-&gt;prob-&gt;token[i][j][k][l] = vp8_rac_get_uint(c, 8);
+
+    if ((s-&gt;mbskip_enabled = vp8_rac_get(c)))
+        s-&gt;prob-&gt;mbskip = vp8_rac_get_uint(c, 8);
+
+    if (!s-&gt;keyframe) {
+        s-&gt;prob-&gt;intra  = vp8_rac_get_uint(c, 8);
+        s-&gt;prob-&gt;last   = vp8_rac_get_uint(c, 8);
+        s-&gt;prob-&gt;golden = vp8_rac_get_uint(c, 8);
+
+        if (vp8_rac_get(c))
+            for (i = 0; i &lt; 4; i++)
+                s-&gt;prob-&gt;pred16x16[i] = vp8_rac_get_uint(c, 8);
+        if (vp8_rac_get(c))
+            for (i = 0; i &lt; 3; i++)
+                s-&gt;prob-&gt;pred8x8c[i]  = vp8_rac_get_uint(c, 8);
+
+        // 17.2 MV probability update
+        for (i = 0; i &lt; 2; i++)
+            for (j = 0; j &lt; 19; j++)
+                if (vp56_rac_get_prob_branchy(c, vp8_mv_update_prob[i][j]))
+                    s-&gt;prob-&gt;mvc[i][j] = vp8_rac_get_nn(c);
+    }
+
+    return 0;
+}
+
+static av_always_inline
+void clamp_mv(VP8Context *s, VP56mv *dst, const VP56mv *src, int mb_x, int mb_y)
+{
+#define MARGIN (16 &lt;&lt; 2)
+    dst-&gt;x = av_clip(src-&gt;x, -((mb_x &lt;&lt; 6) + MARGIN),
+                     ((s-&gt;mb_width  - 1 - mb_x) &lt;&lt; 6) + MARGIN);
+    dst-&gt;y = av_clip(src-&gt;y, -((mb_y &lt;&lt; 6) + MARGIN),
+                     ((s-&gt;mb_height - 1 - mb_y) &lt;&lt; 6) + MARGIN);
+}
+
+static av_always_inline
+void find_near_mvs(VP8Context *s, VP8Macroblock *mb, int mb_x, int mb_y,
+                   VP56mv near[2], VP56mv *best, uint8_t cnt[4])
+{
+    VP8Macroblock *mb_edge[3] = { mb + 2 /* top */,
+                                  mb - 1 /* left */,
+                                  mb + 1 /* top-left */ };
+    enum { EDGE_TOP, EDGE_LEFT, EDGE_TOPLEFT };
+    VP56mv near_mv[4]  = {{ 0 }};
+    enum { CNT_ZERO, CNT_NEAREST, CNT_NEAR, CNT_SPLITMV };
+    int idx = CNT_ZERO;
+    int best_idx = CNT_ZERO;
+    int cur_sign_bias = s-&gt;sign_bias[mb-&gt;ref_frame];
+    int *sign_bias = s-&gt;sign_bias;
+
+    /* Process MB on top, left and top-left */
+    #define MV_EDGE_CHECK(n)\
+    {\
+        VP8Macroblock *edge = mb_edge[n];\
+        int edge_ref = edge-&gt;ref_frame;\
+        if (edge_ref != VP56_FRAME_CURRENT) {\
+            uint32_t mv = AV_RN32A(&amp;edge-&gt;mv);\
+            if (mv) {\
+                if (cur_sign_bias != sign_bias[edge_ref]) {\
+                    /* SWAR negate of the values in mv. */\
+                    mv = ~mv;\
+                    mv = ((mv&amp;0x7fff7fff) + 0x00010001) ^ (mv&amp;0x80008000);\
+                }\
+                if (!n || mv != AV_RN32A(&amp;near_mv[idx]))\
+                    AV_WN32A(&amp;near_mv[++idx], mv);\
+                cnt[idx]      += 1 + (n != 2);\
+            } else\
+                cnt[CNT_ZERO] += 1 + (n != 2);\
+        }\
+    }
+    MV_EDGE_CHECK(0)
+    MV_EDGE_CHECK(1)
+    MV_EDGE_CHECK(2)
+
+    /* If we have three distinct MVs, merge first and last if they're the same */
+    if (cnt[CNT_SPLITMV] &amp;&amp; AV_RN32A(&amp;near_mv[1+EDGE_TOP]) == AV_RN32A(&amp;near_mv[1+EDGE_TOPLEFT]))
+        cnt[CNT_NEAREST] += 1;
+
+    cnt[CNT_SPLITMV] = ((mb_edge[EDGE_LEFT]-&gt;mode   == VP8_MVMODE_SPLIT) +
+                        (mb_edge[EDGE_TOP]-&gt;mode    == VP8_MVMODE_SPLIT)) * 2 +
+                       (mb_edge[EDGE_TOPLEFT]-&gt;mode == VP8_MVMODE_SPLIT);
+
+    /* Swap near and nearest if necessary */
+    if (cnt[CNT_NEAR] &gt; cnt[CNT_NEAREST]) {
+        FFSWAP(uint8_t,     cnt[CNT_NEAREST],     cnt[CNT_NEAR]);
+        FFSWAP( VP56mv, near_mv[CNT_NEAREST], near_mv[CNT_NEAR]);
+    }
+
+    /* Choose the best mv out of 0,0 and the nearest mv */
+    if (cnt[CNT_NEAREST] &gt;= cnt[CNT_ZERO])
+        best_idx = CNT_NEAREST;
+
+    mb-&gt;mv  = near_mv[best_idx];
+    near[0] = near_mv[CNT_NEAREST];
+    near[1] = near_mv[CNT_NEAR];
+}
+
+/**
+ * Motion vector coding, 17.1.
+ */
+static int read_mv_component(VP56RangeCoder *c, const uint8_t *p)
+{
+    int bit, x = 0;
+
+    if (vp56_rac_get_prob_branchy(c, p[0])) {
+        int i;
+
+        for (i = 0; i &lt; 3; i++)
+            x += vp56_rac_get_prob(c, p[9 + i]) &lt;&lt; i;
+        for (i = 9; i &gt; 3; i--)
+            x += vp56_rac_get_prob(c, p[9 + i]) &lt;&lt; i;
+        if (!(x &amp; 0xFFF0) || vp56_rac_get_prob(c, p[12]))
+            x += 8;
+    } else {
+        // small_mvtree
+        const uint8_t *ps = p+2;
+        bit = vp56_rac_get_prob(c, *ps);
+        ps += 1 + 3*bit;
+        x  += 4*bit;
+        bit = vp56_rac_get_prob(c, *ps);
+        ps += 1 + bit;
+        x  += 2*bit;
+        x  += vp56_rac_get_prob(c, *ps);
+    }
+
+    return (x &amp;&amp; vp56_rac_get_prob(c, p[1])) ? -x : x;
+}
+
+static av_always_inline
+const uint8_t *get_submv_prob(uint32_t left, uint32_t top)
+{
+    if (left == top)
+        return vp8_submv_prob[4-!!left];
+    if (!top)
+        return vp8_submv_prob[2];
+    return vp8_submv_prob[1-!!left];
+}
+
+/**
+ * Split motion vector prediction, 16.4.
+ * @returns the number of motion vectors parsed (2, 4 or 16)
+ */
+static av_always_inline
+int decode_splitmvs(VP8Context *s, VP56RangeCoder *c, VP8Macroblock *mb)
+{
+    int part_idx = mb-&gt;partitioning =
+        vp8_rac_get_tree(c, vp8_mbsplit_tree, vp8_mbsplit_prob);
+    int n, num = vp8_mbsplit_count[part_idx];
+    VP8Macroblock *top_mb  = &amp;mb[2];
+    VP8Macroblock *left_mb = &amp;mb[-1];
+    const uint8_t *mbsplits_left = vp8_mbsplits[left_mb-&gt;partitioning],
+                  *mbsplits_top = vp8_mbsplits[top_mb-&gt;partitioning],
+                  *mbsplits_cur = vp8_mbsplits[part_idx],
+                  *firstidx = vp8_mbfirstidx[part_idx];
+    VP56mv *top_mv  = top_mb-&gt;bmv;
+    VP56mv *left_mv = left_mb-&gt;bmv;
+    VP56mv *cur_mv  = mb-&gt;bmv;
+
+    for (n = 0; n &lt; num; n++) {
+        int k = firstidx[n];
+        uint32_t left, above;
+        const uint8_t *submv_prob;
+
+        if (!(k &amp; 3))
+            left = AV_RN32A(&amp;left_mv[mbsplits_left[k + 3]]);
+        else
+            left  = AV_RN32A(&amp;cur_mv[mbsplits_cur[k - 1]]);
+        if (k &lt;= 3)
+            above = AV_RN32A(&amp;top_mv[mbsplits_top[k + 12]]);
+        else
+            above = AV_RN32A(&amp;cur_mv[mbsplits_cur[k - 4]]);
+
+        submv_prob = get_submv_prob(left, above);
+
+        switch (vp8_rac_get_tree(c, vp8_submv_ref_tree, submv_prob)) {
+        case VP8_SUBMVMODE_NEW4X4:
+            mb-&gt;bmv[n].y = mb-&gt;mv.y + read_mv_component(c, s-&gt;prob-&gt;mvc[0]);
+            mb-&gt;bmv[n].x = mb-&gt;mv.x + read_mv_component(c, s-&gt;prob-&gt;mvc[1]);
+            break;
+        case VP8_SUBMVMODE_ZERO4X4:
+            AV_ZERO32(&amp;mb-&gt;bmv[n]);
+            break;
+        case VP8_SUBMVMODE_LEFT4X4:
+            AV_WN32A(&amp;mb-&gt;bmv[n], left);
+            break;
+        case VP8_SUBMVMODE_TOP4X4:
+            AV_WN32A(&amp;mb-&gt;bmv[n], above);
+            break;
+        }
+    }
+
+    return num;
+}
+
+static av_always_inline
+void decode_intra4x4_modes(VP56RangeCoder *c, uint8_t *intra4x4,
+                           int stride, int keyframe)
+{
+    int x, y, t, l, i;
+
+    if (keyframe) {
+        const uint8_t *ctx;
+        for (y = 0; y &lt; 4; y++) {
+            for (x = 0; x &lt; 4; x++) {
+                t = intra4x4[x - stride];
+                l = intra4x4[x - 1];
+                ctx = vp8_pred4x4_prob_intra[t][l];
+                intra4x4[x] = vp8_rac_get_tree(c, vp8_pred4x4_tree, ctx);
+            }
+            intra4x4 += stride;
+        }
+    } else {
+        for (i = 0; i &lt; 16; i++)
+            intra4x4[i] = vp8_rac_get_tree(c, vp8_pred4x4_tree, vp8_pred4x4_prob_inter);
+    }
+}
+
+static av_always_inline
+void decode_mb_mode(VP8Context *s, VP8Macroblock *mb, int mb_x, int mb_y,
+                    uint8_t *intra4x4, uint8_t *segment)
+{
+    VP56RangeCoder *c = &amp;s-&gt;c;
+
+    if (s-&gt;segmentation.update_map)
+        *segment = vp8_rac_get_tree(c, vp8_segmentid_tree, s-&gt;prob-&gt;segmentid);
+    s-&gt;segment = *segment;
+
+    mb-&gt;skip = s-&gt;mbskip_enabled ? vp56_rac_get_prob(c, s-&gt;prob-&gt;mbskip) : 0;
+
+    if (s-&gt;keyframe) {
+        mb-&gt;mode = vp8_rac_get_tree(c, vp8_pred16x16_tree_intra, vp8_pred16x16_prob_intra);
+
+        if (mb-&gt;mode == MODE_I4x4) {
+            decode_intra4x4_modes(c, intra4x4, s-&gt;b4_stride, 1);
+        } else
+            fill_rectangle(intra4x4, 4, 4, s-&gt;b4_stride, vp8_pred4x4_mode[mb-&gt;mode], 1);
+
+        s-&gt;chroma_pred_mode = vp8_rac_get_tree(c, vp8_pred8x8c_tree, vp8_pred8x8c_prob_intra);
+        mb-&gt;ref_frame = VP56_FRAME_CURRENT;
+    } else if (vp56_rac_get_prob_branchy(c, s-&gt;prob-&gt;intra)) {
+        VP56mv near[2], best;
+        uint8_t cnt[4] = { 0 };
+        uint8_t p[4];
+
+        // inter MB, 16.2
+        if (vp56_rac_get_prob_branchy(c, s-&gt;prob-&gt;last))
+            mb-&gt;ref_frame = vp56_rac_get_prob(c, s-&gt;prob-&gt;golden) ?
+                VP56_FRAME_GOLDEN2 /* altref */ : VP56_FRAME_GOLDEN;
+        else
+            mb-&gt;ref_frame = VP56_FRAME_PREVIOUS;
+        s-&gt;ref_count[mb-&gt;ref_frame-1]++;
+
+        // motion vectors, 16.3
+        find_near_mvs(s, mb, mb_x, mb_y, near, &amp;best, cnt);
+        p[0] = vp8_mode_contexts[cnt[0]][0];
+        p[1] = vp8_mode_contexts[cnt[1]][1];
+        p[2] = vp8_mode_contexts[cnt[2]][2];
+        p[3] = vp8_mode_contexts[cnt[3]][3];
+        mb-&gt;mode = vp8_rac_get_tree(c, vp8_pred16x16_tree_mvinter, p);
+        switch (mb-&gt;mode) {
+        case VP8_MVMODE_SPLIT:
+            clamp_mv(s, &amp;mb-&gt;mv, &amp;mb-&gt;mv, mb_x, mb_y);
+            mb-&gt;mv = mb-&gt;bmv[decode_splitmvs(s, c, mb) - 1];
+            break;
+        case VP8_MVMODE_ZERO:
+            AV_ZERO32(&amp;mb-&gt;mv);
+            break;
+        case VP8_MVMODE_NEAREST:
+            clamp_mv(s, &amp;mb-&gt;mv, &amp;near[0], mb_x, mb_y);
+            break;
+        case VP8_MVMODE_NEAR:
+            clamp_mv(s, &amp;mb-&gt;mv, &amp;near[1], mb_x, mb_y);
+            break;
+        case VP8_MVMODE_NEW:
+            clamp_mv(s, &amp;mb-&gt;mv, &amp;mb-&gt;mv, mb_x, mb_y);
+            mb-&gt;mv.y += + read_mv_component(c, s-&gt;prob-&gt;mvc[0]);
+            mb-&gt;mv.x += + read_mv_component(c, s-&gt;prob-&gt;mvc[1]);
+            break;
+        }
+        if (mb-&gt;mode != VP8_MVMODE_SPLIT) {
+            mb-&gt;partitioning = VP8_SPLITMVMODE_NONE;
+            mb-&gt;bmv[0] = mb-&gt;mv;
+        }
+    } else {
+        // intra MB, 16.1
+        mb-&gt;mode = vp8_rac_get_tree(c, vp8_pred16x16_tree_inter, s-&gt;prob-&gt;pred16x16);
+
+        if (mb-&gt;mode == MODE_I4x4)
+            decode_intra4x4_modes(c, intra4x4, 4, 0);
+
+        s-&gt;chroma_pred_mode = vp8_rac_get_tree(c, vp8_pred8x8c_tree, s-&gt;prob-&gt;pred8x8c);
+        mb-&gt;ref_frame = VP56_FRAME_CURRENT;
+        mb-&gt;partitioning = VP8_SPLITMVMODE_NONE;
+        AV_ZERO32(&amp;mb-&gt;bmv[0]);
+    }
+}
+
+/**
+ * @param c arithmetic bitstream reader context
+ * @param block destination for block coefficients
+ * @param probs probabilities to use when reading trees from the bitstream
+ * @param i initial coeff index, 0 unless a separate DC block is coded
+ * @param zero_nhood the initial prediction context for number of surrounding
+ *                   all-zero blocks (only left/top, so 0-2)
+ * @param qmul array holding the dc/ac dequant factor at position 0/1
+ * @return 0 if no coeffs were decoded
+ *         otherwise, the index of the last coeff decoded plus one
+ */
+static int decode_block_coeffs(VP56RangeCoder *c, DCTELEM block[16],
+                               uint8_t probs[8][3][NUM_DCT_TOKENS-1],
+                               int i, int zero_nhood, int16_t qmul[2])
+{
+    uint8_t *token_prob;
+    int nonzero = 0;
+    int coeff;
+
+    do {
+        token_prob = probs[vp8_coeff_band[i]][zero_nhood];
+
+        if (!vp56_rac_get_prob_branchy(c, token_prob[0]))   // DCT_EOB
+            return nonzero;
+
+skip_eob:
+        if (!vp56_rac_get_prob_branchy(c, token_prob[1])) { // DCT_0
+            zero_nhood = 0;
+            token_prob = probs[vp8_coeff_band[++i]][0];
+            if (i &lt; 16)
+                goto skip_eob;
+            return nonzero; // invalid input; blocks should end with EOB
+        }
+
+        if (!vp56_rac_get_prob_branchy(c, token_prob[2])) { // DCT_1
+            coeff = 1;
+            zero_nhood = 1;
+        } else {
+            zero_nhood = 2;
+
+            if (!vp56_rac_get_prob_branchy(c, token_prob[3])) { // DCT 2,3,4
+                coeff = vp56_rac_get_prob(c, token_prob[4]);
+                if (coeff)
+                    coeff += vp56_rac_get_prob(c, token_prob[5]);
+                coeff += 2;
+            } else {
+                // DCT_CAT*
+                if (!vp56_rac_get_prob_branchy(c, token_prob[6])) {
+                    if (!vp56_rac_get_prob_branchy(c, token_prob[7])) { // DCT_CAT1
+                        coeff  = 5 + vp56_rac_get_prob(c, vp8_dct_cat1_prob[0]);
+                    } else {                                    // DCT_CAT2
+                        coeff  = 7;
+                        coeff += vp56_rac_get_prob(c, vp8_dct_cat2_prob[0]) &lt;&lt; 1;
+                        coeff += vp56_rac_get_prob(c, vp8_dct_cat2_prob[1]);
+                    }
+                } else {    // DCT_CAT3 and up
+                    int a = vp56_rac_get_prob(c, token_prob[8]);
+                    int b = vp56_rac_get_prob(c, token_prob[9+a]);
+                    int cat = (a&lt;&lt;1) + b;
+                    coeff  = 3 + (8&lt;&lt;cat);
+                    coeff += vp8_rac_get_coeff(c, vp8_dct_cat_prob[cat]);
+                }
+            }
+        }
+
+        // todo: full [16] qmat? load into register?
+        block[zigzag_scan[i]] = (vp8_rac_get(c) ? -coeff : coeff) * qmul[!!i];
+        nonzero = ++i;
+    } while (i &lt; 16);
+
+    return nonzero;
+}
+
+static av_always_inline
+void decode_mb_coeffs(VP8Context *s, VP56RangeCoder *c, VP8Macroblock *mb,
+                      uint8_t t_nnz[9], uint8_t l_nnz[9])
+{
+    LOCAL_ALIGNED_16(DCTELEM, dc,[16]);
+    int i, x, y, luma_start = 0, luma_ctx = 3;
+    int nnz_pred, nnz, nnz_total = 0;
+    int segment = s-&gt;segment;
+
+    if (mb-&gt;mode != MODE_I4x4 &amp;&amp; mb-&gt;mode != VP8_MVMODE_SPLIT) {
+        AV_ZERO128(dc);
+        AV_ZERO128(dc+8);
+        nnz_pred = t_nnz[8] + l_nnz[8];
+
+        // decode DC values and do hadamard
+        nnz = decode_block_coeffs(c, dc, s-&gt;prob-&gt;token[1], 0, nnz_pred,
+                                  s-&gt;qmat[segment].luma_dc_qmul);
+        l_nnz[8] = t_nnz[8] = !!nnz;
+        nnz_total += nnz;
+        s-&gt;vp8dsp.vp8_luma_dc_wht(s-&gt;block, dc);
+        luma_start = 1;
+        luma_ctx = 0;
+    }
+
+    // luma blocks
+    for (y = 0; y &lt; 4; y++)
+        for (x = 0; x &lt; 4; x++) {
+            nnz_pred = l_nnz[y] + t_nnz[x];
+            nnz = decode_block_coeffs(c, s-&gt;block[y][x], s-&gt;prob-&gt;token[luma_ctx], luma_start,
+                                      nnz_pred, s-&gt;qmat[segment].luma_qmul);
+            // nnz+luma_start may be one more than the actual last index, but we don't care
+            s-&gt;non_zero_count_cache[y][x] = nnz + luma_start;
+            t_nnz[x] = l_nnz[y] = !!nnz;
+            nnz_total += nnz;
+        }
+
+    // chroma blocks
+    // TODO: what to do about dimensions? 2nd dim for luma is x,
+    // but for chroma it's (y&lt;&lt;1)|x
+    for (i = 4; i &lt; 6; i++)
+        for (y = 0; y &lt; 2; y++)
+            for (x = 0; x &lt; 2; x++) {
+                nnz_pred = l_nnz[i+2*y] + t_nnz[i+2*x];
+                nnz = decode_block_coeffs(c, s-&gt;block[i][(y&lt;&lt;1)+x], s-&gt;prob-&gt;token[2], 0,
+                                          nnz_pred, s-&gt;qmat[segment].chroma_qmul);
+                s-&gt;non_zero_count_cache[i][(y&lt;&lt;1)+x] = nnz;
+                t_nnz[i+2*x] = l_nnz[i+2*y] = !!nnz;
+                nnz_total += nnz;
+            }
+
+    // if there were no coded coeffs despite the macroblock not being marked skip,
+    // we MUST not do the inner loop filter and should not do IDCT
+    // Since skip isn't used for bitstream prediction, just manually set it.
+    if (!nnz_total)
+        mb-&gt;skip = 1;
+}
+
+static av_always_inline
+void backup_mb_border(uint8_t *top_border, uint8_t *src_y, uint8_t *src_cb, uint8_t *src_cr,
+                      int linesize, int uvlinesize, int simple)
+{
+    AV_COPY128(top_border, src_y + 15*linesize);
+    if (!simple) {
+        AV_COPY64(top_border+16, src_cb + 7*uvlinesize);
+        AV_COPY64(top_border+24, src_cr + 7*uvlinesize);
+    }
+}
+
+static av_always_inline
+void xchg_mb_border(uint8_t *top_border, uint8_t *src_y, uint8_t *src_cb, uint8_t *src_cr,
+                    int linesize, int uvlinesize, int mb_x, int mb_y, int mb_width,
+                    int simple, int xchg)
+{
+    uint8_t *top_border_m1 = top_border-32;     // for TL prediction
+    src_y  -=   linesize;
+    src_cb -= uvlinesize;
+    src_cr -= uvlinesize;
+
+#define XCHG(a,b,xchg) do {                     \
+        if (xchg) AV_SWAP64(b,a);               \
+        else      AV_COPY64(b,a);               \
+    } while (0)
+
+    XCHG(top_border_m1+8, src_y-8, xchg);
+    XCHG(top_border,      src_y,   xchg);
+    XCHG(top_border+8,    src_y+8, 1);
+    if (mb_x &lt; mb_width-1)
+        XCHG(top_border+32, src_y+16, 1);
+
+    // only copy chroma for normal loop filter
+    // or to initialize the top row to 127
+    if (!simple || !mb_y) {
+        XCHG(top_border_m1+16, src_cb-8, xchg);
+        XCHG(top_border_m1+24, src_cr-8, xchg);
+        XCHG(top_border+16,    src_cb, 1);
+        XCHG(top_border+24,    src_cr, 1);
+    }
+}
+
+static av_always_inline
+int check_intra_pred_mode(int mode, int mb_x, int mb_y)
+{
+    if (mode == DC_PRED8x8) {
+        if (!mb_x) {
+            mode = mb_y ? TOP_DC_PRED8x8 : DC_128_PRED8x8;
+        } else if (!mb_y) {
+            mode = LEFT_DC_PRED8x8;
+        }
+    }
+    return mode;
+}
+
+static av_always_inline
+void intra_predict(VP8Context *s, uint8_t *dst[3], VP8Macroblock *mb,
+                   uint8_t *intra4x4, int mb_x, int mb_y)
+{
+    int x, y, mode, nnz, tr;
+
+    // for the first row, we need to run xchg_mb_border to init the top edge to 127
+    // otherwise, skip it if we aren't going to deblock
+    if (s-&gt;deblock_filter || !mb_y)
+        xchg_mb_border(s-&gt;top_border[mb_x+1], dst[0], dst[1], dst[2],
+                       s-&gt;linesize, s-&gt;uvlinesize, mb_x, mb_y, s-&gt;mb_width,
+                       s-&gt;filter.simple, 1);
+
+    if (mb-&gt;mode &lt; MODE_I4x4) {
+        mode = check_intra_pred_mode(mb-&gt;mode, mb_x, mb_y);
+        s-&gt;hpc.pred16x16[mode](dst[0], s-&gt;linesize);
+    } else {
+        uint8_t *ptr = dst[0];
+        int stride = s-&gt;keyframe ? s-&gt;b4_stride : 4;
+
+        // all blocks on the right edge of the macroblock use bottom edge
+        // the top macroblock for their topright edge
+        uint8_t *tr_right = ptr - s-&gt;linesize + 16;
+
+        // if we're on the right edge of the frame, said edge is extended
+        // from the top macroblock
+        if (mb_x == s-&gt;mb_width-1) {
+            tr = tr_right[-1]*0x01010101;
+            tr_right = (uint8_t *)&tr;
+        }
+
+        if (mb-&gt;skip)
+            AV_ZERO128(s-&gt;non_zero_count_cache);
+
+        for (y = 0; y &lt; 4; y++) {
+            uint8_t *topright = ptr + 4 - s-&gt;linesize;
+            for (x = 0; x &lt; 4; x++) {
+                if (x == 3)
+                    topright = tr_right;
+
+                s-&gt;hpc.pred4x4[intra4x4[x]](ptr+4*x, topright, s-&gt;linesize);
+
+                nnz = s-&gt;non_zero_count_cache[y][x];
+                if (nnz) {
+                    if (nnz == 1)
+                        s-&gt;vp8dsp.vp8_idct_dc_add(ptr+4*x, s-&gt;block[y][x], s-&gt;linesize);
+                    else
+                        s-&gt;vp8dsp.vp8_idct_add(ptr+4*x, s-&gt;block[y][x], s-&gt;linesize);
+                }
+                topright += 4;
+            }
+
+            ptr   += 4*s-&gt;linesize;
+            intra4x4 += stride;
+        }
+    }
+
+    mode = check_intra_pred_mode(s-&gt;chroma_pred_mode, mb_x, mb_y);
+    s-&gt;hpc.pred8x8[mode](dst[1], s-&gt;uvlinesize);
+    s-&gt;hpc.pred8x8[mode](dst[2], s-&gt;uvlinesize);
+
+    if (s-&gt;deblock_filter || !mb_y)
+        xchg_mb_border(s-&gt;top_border[mb_x+1], dst[0], dst[1], dst[2],
+                       s-&gt;linesize, s-&gt;uvlinesize, mb_x, mb_y, s-&gt;mb_width,
+                       s-&gt;filter.simple, 0);
+}
+
+/**
+ * Generic MC function.
+ *
+ * @param s VP8 decoding context
+ * @param luma 1 for luma (Y) planes, 0 for chroma (Cb/Cr) planes
+ * @param dst target buffer for block data at block position
+ * @param src reference picture buffer at origin (0, 0)
+ * @param mv motion vector (relative to block position) to get pixel data from
+ * @param x_off horizontal position of block from origin (0, 0)
+ * @param y_off vertical position of block from origin (0, 0)
+ * @param block_w width of block (16, 8 or 4)
+ * @param block_h height of block (always same as block_w)
+ * @param width width of src/dst plane data
+ * @param height height of src/dst plane data
+ * @param linesize size of a single line of plane data, including padding
+ * @param mc_func motion compensation function pointers (bilinear or sixtap MC)
+ */
+static av_always_inline
+void vp8_mc(VP8Context *s, int luma,
+            uint8_t *dst, uint8_t *src, const VP56mv *mv,
+            int x_off, int y_off, int block_w, int block_h,
+            int width, int height, int linesize,
+            vp8_mc_func mc_func[3][3])
+{
+    if (AV_RN32A(mv)) {
+        static const uint8_t idx[8] = { 0, 1, 2, 1, 2, 1, 2, 1 };
+        int mx = (mv-&gt;x &lt;&lt; luma)&amp;7, mx_idx = idx[mx];
+        int my = (mv-&gt;y &lt;&lt; luma)&amp;7, my_idx = idx[my];
+
+        x_off += mv-&gt;x &gt;&gt; (3 - luma);
+        y_off += mv-&gt;y &gt;&gt; (3 - luma);
+
+        // edge emulation
+        src += y_off * linesize + x_off;
+        if (x_off &lt; 2 || x_off &gt;= width  - block_w - 3 ||
+            y_off &lt; 2 || y_off &gt;= height - block_h - 3) {
+            ff_emulated_edge_mc(s-&gt;edge_emu_buffer, src - 2 * linesize - 2, linesize,
+                                block_w + 5, block_h + 5,
+                                x_off - 2, y_off - 2, width, height);
+            src = s-&gt;edge_emu_buffer + 2 + linesize * 2;
+        }
+        mc_func[my_idx][mx_idx](dst, linesize, src, linesize, block_h, mx, my);
+    } else
+        mc_func[0][0](dst, linesize, src + y_off * linesize + x_off, linesize, block_h, 0, 0);
+}
+
+static av_always_inline
+void vp8_mc_part(VP8Context *s, uint8_t *dst[3],
+                 AVFrame *ref_frame, int x_off, int y_off,
+                 int bx_off, int by_off,
+                 int block_w, int block_h,
+                 int width, int height, VP56mv *mv)
+{
+    VP56mv uvmv = *mv;
+
+    /* Y */
+    vp8_mc(s, 1, dst[0] + by_off * s-&gt;linesize + bx_off,
+           ref_frame-&gt;data[0], mv, x_off + bx_off, y_off + by_off,
+           block_w, block_h, width, height, s-&gt;linesize,
+           s-&gt;put_pixels_tab[block_w == 8]);
+
+    /* U/V */
+    if (s-&gt;profile == 3) {
+        uvmv.x &amp;= ~7;
+        uvmv.y &amp;= ~7;
+    }
+    x_off   &gt;&gt;= 1; y_off   &gt;&gt;= 1;
+    bx_off  &gt;&gt;= 1; by_off  &gt;&gt;= 1;
+    width   &gt;&gt;= 1; height  &gt;&gt;= 1;
+    block_w &gt;&gt;= 1; block_h &gt;&gt;= 1;
+    vp8_mc(s, 0, dst[1] + by_off * s-&gt;uvlinesize + bx_off,
+           ref_frame-&gt;data[1], &amp;uvmv, x_off + bx_off, y_off + by_off,
+           block_w, block_h, width, height, s-&gt;uvlinesize,
+           s-&gt;put_pixels_tab[1 + (block_w == 4)]);
+    vp8_mc(s, 0, dst[2] + by_off * s-&gt;uvlinesize + bx_off,
+           ref_frame-&gt;data[2], &amp;uvmv, x_off + bx_off, y_off + by_off,
+           block_w, block_h, width, height, s-&gt;uvlinesize,
+           s-&gt;put_pixels_tab[1 + (block_w == 4)]);
+}
+
+/* Fetch pixels for estimated mv 4 macroblocks ahead.
+ * Optimized for 64-byte cache lines.  Inspired by ffh264 prefetch_motion. */
+static av_always_inline void prefetch_motion(VP8Context *s, VP8Macroblock *mb, int mb_x, int mb_y, int mb_xy, int ref)
+{
+    /* Don't prefetch refs that haven't been used very often this frame. */
+    if (s-&gt;ref_count[ref-1] &gt; (mb_xy &gt;&gt; 5)) {
+        int x_off = mb_x &lt;&lt; 4, y_off = mb_y &lt;&lt; 4;
+        int mx = mb-&gt;mv.x + x_off + 8;
+        int my = mb-&gt;mv.y + y_off;
+        uint8_t **src= s-&gt;framep[ref]-&gt;data;
+        int off= mx + (my + (mb_x&amp;3)*4)*s-&gt;linesize + 64;
+        s-&gt;dsp.prefetch(src[0]+off, s-&gt;linesize, 4);
+        off= (mx&gt;&gt;1) + ((my&gt;&gt;1) + (mb_x&amp;7))*s-&gt;uvlinesize + 64;
+        s-&gt;dsp.prefetch(src[1]+off, src[2]-src[1], 2);
+    }
+}
+
+/**
+ * Apply motion vectors to prediction buffer, chapter 18.
+ */
+static av_always_inline
+void inter_predict(VP8Context *s, uint8_t *dst[3], VP8Macroblock *mb,
+                   int mb_x, int mb_y)
+{
+    int x_off = mb_x &lt;&lt; 4, y_off = mb_y &lt;&lt; 4;
+    int width = 16*s-&gt;mb_width, height = 16*s-&gt;mb_height;
+    AVFrame *ref = s-&gt;framep[mb-&gt;ref_frame];
+    VP56mv *bmv = mb-&gt;bmv;
+
+    if (mb-&gt;mode &lt; VP8_MVMODE_SPLIT) {
+        vp8_mc_part(s, dst, ref, x_off, y_off,
+                    0, 0, 16, 16, width, height, &amp;mb-&gt;mv);
+    } else switch (mb-&gt;partitioning) {
+    case VP8_SPLITMVMODE_4x4: {
+        int x, y;
+        VP56mv uvmv;
+
+        /* Y */
+        for (y = 0; y &lt; 4; y++) {
+            for (x = 0; x &lt; 4; x++) {
+                vp8_mc(s, 1, dst[0] + 4*y*s-&gt;linesize + x*4,
+                       ref-&gt;data[0], &amp;bmv[4*y + x],
+                       4*x + x_off, 4*y + y_off, 4, 4,
+                       width, height, s-&gt;linesize,
+                       s-&gt;put_pixels_tab[2]);
+            }
+        }
+
+        /* U/V */
+        x_off &gt;&gt;= 1; y_off &gt;&gt;= 1; width &gt;&gt;= 1; height &gt;&gt;= 1;
+        for (y = 0; y &lt; 2; y++) {
+            for (x = 0; x &lt; 2; x++) {
+                uvmv.x = mb-&gt;bmv[ 2*y    * 4 + 2*x  ].x +
+                         mb-&gt;bmv[ 2*y    * 4 + 2*x+1].x +
+                         mb-&gt;bmv[(2*y+1) * 4 + 2*x  ].x +
+                         mb-&gt;bmv[(2*y+1) * 4 + 2*x+1].x;
+                uvmv.y = mb-&gt;bmv[ 2*y    * 4 + 2*x  ].y +
+                         mb-&gt;bmv[ 2*y    * 4 + 2*x+1].y +
+                         mb-&gt;bmv[(2*y+1) * 4 + 2*x  ].y +
+                         mb-&gt;bmv[(2*y+1) * 4 + 2*x+1].y;
+                uvmv.x = (uvmv.x + 2 + (uvmv.x &gt;&gt; (INT_BIT-1))) &gt;&gt; 2;
+                uvmv.y = (uvmv.y + 2 + (uvmv.y &gt;&gt; (INT_BIT-1))) &gt;&gt; 2;
+                if (s-&gt;profile == 3) {
+                    uvmv.x &amp;= ~7;
+                    uvmv.y &amp;= ~7;
+                }
+                vp8_mc(s, 0, dst[1] + 4*y*s-&gt;uvlinesize + x*4,
+                       ref-&gt;data[1], &amp;uvmv,
+                       4*x + x_off, 4*y + y_off, 4, 4,
+                       width, height, s-&gt;uvlinesize,
+                       s-&gt;put_pixels_tab[2]);
+                vp8_mc(s, 0, dst[2] + 4*y*s-&gt;uvlinesize + x*4,
+                       ref-&gt;data[2], &amp;uvmv,
+                       4*x + x_off, 4*y + y_off, 4, 4,
+                       width, height, s-&gt;uvlinesize,
+                       s-&gt;put_pixels_tab[2]);
+            }
+        }
+        break;
+    }
+    case VP8_SPLITMVMODE_16x8:
+        vp8_mc_part(s, dst, ref, x_off, y_off,
+                    0, 0, 16, 8, width, height, &amp;bmv[0]);
+        vp8_mc_part(s, dst, ref, x_off, y_off,
+                    0, 8, 16, 8, width, height, &amp;bmv[1]);
+        break;
+    case VP8_SPLITMVMODE_8x16:
+        vp8_mc_part(s, dst, ref, x_off, y_off,
+                    0, 0, 8, 16, width, height, &amp;bmv[0]);
+        vp8_mc_part(s, dst, ref, x_off, y_off,
+                    8, 0, 8, 16, width, height, &amp;bmv[1]);
+        break;
+    case VP8_SPLITMVMODE_8x8:
+        vp8_mc_part(s, dst, ref, x_off, y_off,
+                    0, 0, 8, 8, width, height, &amp;bmv[0]);
+        vp8_mc_part(s, dst, ref, x_off, y_off,
+                    8, 0, 8, 8, width, height, &amp;bmv[1]);
+        vp8_mc_part(s, dst, ref, x_off, y_off,
+                    0, 8, 8, 8, width, height, &amp;bmv[2]);
+        vp8_mc_part(s, dst, ref, x_off, y_off,
+                    8, 8, 8, 8, width, height, &amp;bmv[3]);
+        break;
+    }
+}
+
+static av_always_inline void idct_mb(VP8Context *s, uint8_t *dst[3], VP8Macroblock *mb)
+{
+    int x, y, ch;
+
+    if (mb-&gt;mode != MODE_I4x4) {
+        uint8_t *y_dst = dst[0];
+        for (y = 0; y &lt; 4; y++) {
+            uint32_t nnz4 = AV_RN32A(s-&gt;non_zero_count_cache[y]);
+            if (nnz4) {
+                if (nnz4&amp;~0x01010101) {
+                    for (x = 0; x &lt; 4; x++) {
+                        int nnz = s-&gt;non_zero_count_cache[y][x];
+                        if (nnz) {
+                            if (nnz == 1)
+                                s-&gt;vp8dsp.vp8_idct_dc_add(y_dst+4*x, s-&gt;block[y][x], s-&gt;linesize);
+                            else
+                                s-&gt;vp8dsp.vp8_idct_add(y_dst+4*x, s-&gt;block[y][x], s-&gt;linesize);
+                        }
+                    }
+                } else {
+                    s-&gt;vp8dsp.vp8_idct_dc_add4y(y_dst, s-&gt;block[y], s-&gt;linesize);
+                }
+            }
+            y_dst += 4*s-&gt;linesize;
+        }
+    }
+
+    for (ch = 0; ch &lt; 2; ch++) {
+        uint32_t nnz4 = AV_RN32A(s-&gt;non_zero_count_cache[4+ch]);
+        if (nnz4) {
+            uint8_t *ch_dst = dst[1+ch];
+            if (nnz4&amp;~0x01010101) {
+                for (y = 0; y &lt; 2; y++) {
+                    for (x = 0; x &lt; 2; x++) {
+                        int nnz = s-&gt;non_zero_count_cache[4+ch][(y&lt;&lt;1)+x];
+                        if (nnz) {
+                            if (nnz == 1)
+                                s-&gt;vp8dsp.vp8_idct_dc_add(ch_dst+4*x, s-&gt;block[4+ch][(y&lt;&lt;1)+x], s-&gt;uvlinesize);
+                            else
+                                s-&gt;vp8dsp.vp8_idct_add(ch_dst+4*x, s-&gt;block[4+ch][(y&lt;&lt;1)+x], s-&gt;uvlinesize);
+                        }
+                    }
+                    ch_dst += 4*s-&gt;uvlinesize;
+                }
+            } else {
+                s-&gt;vp8dsp.vp8_idct_dc_add4uv(ch_dst, s-&gt;block[4+ch], s-&gt;uvlinesize);
+            }
+        }
+    }
+}
+
+static av_always_inline void filter_level_for_mb(VP8Context *s, VP8Macroblock *mb, VP8FilterStrength *f )
+{
+    int interior_limit, filter_level;
+
+    if (s-&gt;segmentation.enabled) {
+        filter_level = s-&gt;segmentation.filter_level[s-&gt;segment];
+        if (!s-&gt;segmentation.absolute_vals)
+            filter_level += s-&gt;filter.level;
+    } else
+        filter_level = s-&gt;filter.level;
+
+    if (s-&gt;lf_delta.enabled) {
+        filter_level += s-&gt;lf_delta.ref[mb-&gt;ref_frame];
+
+        if (mb-&gt;ref_frame == VP56_FRAME_CURRENT) {
+            if (mb-&gt;mode == MODE_I4x4)
+                filter_level += s-&gt;lf_delta.mode[0];
+        } else {
+            if (mb-&gt;mode == VP8_MVMODE_ZERO)
+                filter_level += s-&gt;lf_delta.mode[1];
+            else if (mb-&gt;mode == VP8_MVMODE_SPLIT)
+                filter_level += s-&gt;lf_delta.mode[3];
+            else
+                filter_level += s-&gt;lf_delta.mode[2];
+        }
+    }
+    filter_level = av_clip(filter_level, 0, 63);
+
+    interior_limit = filter_level;
+    if (s-&gt;filter.sharpness) {
+        interior_limit &gt;&gt;= s-&gt;filter.sharpness &gt; 4 ? 2 : 1;
+        interior_limit = FFMIN(interior_limit, 9 - s-&gt;filter.sharpness);
+    }
+    interior_limit = FFMAX(interior_limit, 1);
+
+    f-&gt;filter_level = filter_level;
+    f-&gt;inner_limit = interior_limit;
+    f-&gt;inner_filter = !mb-&gt;skip || mb-&gt;mode == MODE_I4x4 || mb-&gt;mode == VP8_MVMODE_SPLIT;
+}
+
+static av_always_inline void filter_mb(VP8Context *s, uint8_t *dst[3], VP8FilterStrength *f, int mb_x, int mb_y)
+{
+    int mbedge_lim, bedge_lim, hev_thresh;
+    int filter_level = f-&gt;filter_level;
+    int inner_limit = f-&gt;inner_limit;
+    int inner_filter = f-&gt;inner_filter;
+    int linesize = s-&gt;linesize;
+    int uvlinesize = s-&gt;uvlinesize;
+
+    if (!filter_level)
+        return;
+
+    mbedge_lim = 2*(filter_level+2) + inner_limit;
+     bedge_lim = 2* filter_level    + inner_limit;
+    hev_thresh = filter_level &gt;= 15;
+
+    if (s-&gt;keyframe) {
+        if (filter_level &gt;= 40)
+            hev_thresh = 2;
+    } else {
+        if (filter_level &gt;= 40)
+            hev_thresh = 3;
+        else if (filter_level &gt;= 20)
+            hev_thresh = 2;
+    }
+
+    if (mb_x) {
+        s-&gt;vp8dsp.vp8_h_loop_filter16y(dst[0],     linesize,
+                                       mbedge_lim, inner_limit, hev_thresh);
+        s-&gt;vp8dsp.vp8_h_loop_filter8uv(dst[1],     dst[2],      uvlinesize,
+                                       mbedge_lim, inner_limit, hev_thresh);
+    }
+
+    if (inner_filter) {
+        s-&gt;vp8dsp.vp8_h_loop_filter16y_inner(dst[0]+ 4, linesize, bedge_lim,
+                                             inner_limit, hev_thresh);
+        s-&gt;vp8dsp.vp8_h_loop_filter16y_inner(dst[0]+ 8, linesize, bedge_lim,
+                                             inner_limit, hev_thresh);
+        s-&gt;vp8dsp.vp8_h_loop_filter16y_inner(dst[0]+12, linesize, bedge_lim,
+                                             inner_limit, hev_thresh);
+        s-&gt;vp8dsp.vp8_h_loop_filter8uv_inner(dst[1] + 4, dst[2] + 4,
+                                             uvlinesize,  bedge_lim,
+                                             inner_limit, hev_thresh);
+    }
+
+    if (mb_y) {
+        s-&gt;vp8dsp.vp8_v_loop_filter16y(dst[0],     linesize,
+                                       mbedge_lim, inner_limit, hev_thresh);
+        s-&gt;vp8dsp.vp8_v_loop_filter8uv(dst[1],     dst[2],      uvlinesize,
+                                       mbedge_lim, inner_limit, hev_thresh);
+    }
+
+    if (inner_filter) {
+        s-&gt;vp8dsp.vp8_v_loop_filter16y_inner(dst[0]+ 4*linesize,
+                                             linesize,    bedge_lim,
+                                             inner_limit, hev_thresh);
+        s-&gt;vp8dsp.vp8_v_loop_filter16y_inner(dst[0]+ 8*linesize,
+                                             linesize,    bedge_lim,
+                                             inner_limit, hev_thresh);
+        s-&gt;vp8dsp.vp8_v_loop_filter16y_inner(dst[0]+12*linesize,
+                                             linesize,    bedge_lim,
+                                             inner_limit, hev_thresh);
+        s-&gt;vp8dsp.vp8_v_loop_filter8uv_inner(dst[1] + 4 * uvlinesize,
+                                             dst[2] + 4 * uvlinesize,
+                                             uvlinesize,  bedge_lim,
+                                             inner_limit, hev_thresh);
+    }
+}
+
+static av_always_inline void filter_mb_simple(VP8Context *s, uint8_t *dst, VP8FilterStrength *f, int mb_x, int mb_y)
+{
+    int mbedge_lim, bedge_lim;
+    int filter_level = f-&gt;filter_level;
+    int inner_limit = f-&gt;inner_limit;
+    int inner_filter = f-&gt;inner_filter;
+    int linesize = s-&gt;linesize;
+
+    if (!filter_level)
+        return;
+
+    mbedge_lim = 2*(filter_level+2) + inner_limit;
+     bedge_lim = 2* filter_level    + inner_limit;
+
+    if (mb_x)
+        s-&gt;vp8dsp.vp8_h_loop_filter_simple(dst, linesize, mbedge_lim);
+    if (inner_filter) {
+        s-&gt;vp8dsp.vp8_h_loop_filter_simple(dst+ 4, linesize, bedge_lim);
+        s-&gt;vp8dsp.vp8_h_loop_filter_simple(dst+ 8, linesize, bedge_lim);
+        s-&gt;vp8dsp.vp8_h_loop_filter_simple(dst+12, linesize, bedge_lim);
+    }
+
+    if (mb_y)
+        s-&gt;vp8dsp.vp8_v_loop_filter_simple(dst, linesize, mbedge_lim);
+    if (inner_filter) {
+        s-&gt;vp8dsp.vp8_v_loop_filter_simple(dst+ 4*linesize, linesize, bedge_lim);
+        s-&gt;vp8dsp.vp8_v_loop_filter_simple(dst+ 8*linesize, linesize, bedge_lim);
+        s-&gt;vp8dsp.vp8_v_loop_filter_simple(dst+12*linesize, linesize, bedge_lim);
+    }
+}
+
+static void filter_mb_row(VP8Context *s, int mb_y)
+{
+    VP8FilterStrength *f = s-&gt;filter_strength;
+    uint8_t *dst[3] = {
+        s-&gt;framep[VP56_FRAME_CURRENT]-&gt;data[0] + 16*mb_y*s-&gt;linesize,
+        s-&gt;framep[VP56_FRAME_CURRENT]-&gt;data[1] +  8*mb_y*s-&gt;uvlinesize,
+        s-&gt;framep[VP56_FRAME_CURRENT]-&gt;data[2] +  8*mb_y*s-&gt;uvlinesize
+    };
+    int mb_x;
+
+    for (mb_x = 0; mb_x &lt; s-&gt;mb_width; mb_x++) {
+        backup_mb_border(s-&gt;top_border[mb_x+1], dst[0], dst[1], dst[2], s-&gt;linesize, s-&gt;uvlinesize, 0);
+        filter_mb(s, dst, f++, mb_x, mb_y);
+        dst[0] += 16;
+        dst[1] += 8;
+        dst[2] += 8;
+    }
+}
+
+static void filter_mb_row_simple(VP8Context *s, int mb_y)
+{
+    VP8FilterStrength *f = s-&gt;filter_strength;
+    uint8_t *dst = s-&gt;framep[VP56_FRAME_CURRENT]-&gt;data[0] + 16*mb_y*s-&gt;linesize;
+    int mb_x;
+
+    for (mb_x = 0; mb_x &lt; s-&gt;mb_width; mb_x++) {
+        backup_mb_border(s-&gt;top_border[mb_x+1], dst, NULL, NULL, s-&gt;linesize, 0, 1);
+        filter_mb_simple(s, dst, f++, mb_x, mb_y);
+        dst += 16;
+    }
+}
+
+static int vp8_decode_frame(AVCodecContext *avctx, void *data, int *data_size,
+                            AVPacket *avpkt)
+{
+    VP8Context *s = avctx-&gt;priv_data;
+    int ret, mb_x, mb_y, i, y, referenced;
+    enum AVDiscard skip_thresh;
+    AVFrame *curframe = NULL;
+
+    if ((ret = decode_frame_header(s, avpkt-&gt;data, avpkt-&gt;size)) &lt; 0)
+        return ret;
+
+    referenced = s-&gt;update_last || s-&gt;update_golden == VP56_FRAME_CURRENT
+                                || s-&gt;update_altref == VP56_FRAME_CURRENT;
+
+    skip_thresh = !referenced ? AVDISCARD_NONREF :
+                    !s-&gt;keyframe ? AVDISCARD_NONKEY : AVDISCARD_ALL;
+
+    if (avctx-&gt;skip_frame &gt;= skip_thresh) {
+        s-&gt;invisible = 1;
+        goto skip_decode;
+    }
+    s-&gt;deblock_filter = s-&gt;filter.level &amp;&amp; avctx-&gt;skip_loop_filter &lt; skip_thresh;
+
+    for (i = 0; i &lt; 4; i++)
+        if (&amp;s-&gt;frames[i] != s-&gt;framep[VP56_FRAME_PREVIOUS] &amp;&amp;
+            &amp;s-&gt;frames[i] != s-&gt;framep[VP56_FRAME_GOLDEN] &amp;&amp;
+            &amp;s-&gt;frames[i] != s-&gt;framep[VP56_FRAME_GOLDEN2]) {
+            curframe = s-&gt;framep[VP56_FRAME_CURRENT] = &amp;s-&gt;frames[i];
+            break;
+        }
+    if (curframe-&gt;data[0])
+        avctx-&gt;release_buffer(avctx, curframe);
+
+    curframe-&gt;key_frame = s-&gt;keyframe;
+    curframe-&gt;pict_type = s-&gt;keyframe ? FF_I_TYPE : FF_P_TYPE;
+    curframe-&gt;reference = referenced ? 3 : 0;
+    if ((ret = avctx-&gt;get_buffer(avctx, curframe))) {
+        av_log(avctx, AV_LOG_ERROR, &quot;get_buffer() failed!\n&quot;);
+        return ret;
+    }
+
+    // Given that arithmetic probabilities are updated every frame, it's quite likely
+    // that the values we have on a random interframe are complete junk if we didn't
+    // start decode on a keyframe. So just don't display anything rather than junk.
+    if (!s-&gt;keyframe &amp;&amp; (!s-&gt;framep[VP56_FRAME_PREVIOUS] ||
+                         !s-&gt;framep[VP56_FRAME_GOLDEN] ||
+                         !s-&gt;framep[VP56_FRAME_GOLDEN2])) {
+        av_log(avctx, AV_LOG_WARNING, &quot;Discarding interframe without a prior keyframe!\n&quot;);
+        return AVERROR_INVALIDDATA;
+    }
+
+    s-&gt;linesize   = curframe-&gt;linesize[0];
+    s-&gt;uvlinesize = curframe-&gt;linesize[1];
+
+    if (!s-&gt;edge_emu_buffer)
+        s-&gt;edge_emu_buffer = av_malloc(21*s-&gt;linesize);
+
+    memset(s-&gt;top_nnz, 0, s-&gt;mb_width*sizeof(*s-&gt;top_nnz));
+
+    /* Zero macroblock structures for top/left prediction from outside the frame. */
+    memset(s-&gt;macroblocks, 0, (s-&gt;mb_width + s-&gt;mb_height*2)*sizeof(*s-&gt;macroblocks));
+
+    // top edge of 127 for intra prediction
+    memset(s-&gt;top_border, 127, (s-&gt;mb_width+1)*sizeof(*s-&gt;top_border));
+    memset(s-&gt;ref_count, 0, sizeof(s-&gt;ref_count));
+
+    for (mb_y = 0; mb_y &lt; s-&gt;mb_height; mb_y++) {
+        VP56RangeCoder *c = &amp;s-&gt;coeff_partition[mb_y &amp; (s-&gt;num_coeff_partitions-1)];
+        VP8Macroblock *mb = s-&gt;macroblocks + (s-&gt;mb_height - mb_y - 1)*2;
+        uint8_t *intra4x4 = s-&gt;intra4x4_pred_mode + 4*mb_y*s-&gt;b4_stride;
+        uint8_t *segment_map = s-&gt;segmentation_map + mb_y*s-&gt;mb_stride;
+        int mb_xy = mb_y * s-&gt;mb_stride;
+        uint8_t *dst[3] = {
+            curframe-&gt;data[0] + 16*mb_y*s-&gt;linesize,
+            curframe-&gt;data[1] +  8*mb_y*s-&gt;uvlinesize,
+            curframe-&gt;data[2] +  8*mb_y*s-&gt;uvlinesize
+        };
+
+        memset(s-&gt;left_nnz, 0, sizeof(s-&gt;left_nnz));
+
+        // left edge of 129 for intra prediction
+        if (!(avctx-&gt;flags &amp; CODEC_FLAG_EMU_EDGE))
+            for (i = 0; i &lt; 3; i++)
+                for (y = 0; y &lt; 16&gt;&gt;!!i; y++)
+                    dst[i][y*curframe-&gt;linesize[i]-1] = 129;
+        if (mb_y)
+            memset(s-&gt;top_border, 129, sizeof(*s-&gt;top_border));
+
+        for (mb_x = 0; mb_x &lt; s-&gt;mb_width; mb_x++, mb_xy++, mb++) {
+            uint8_t *intra4x4_mb = s-&gt;keyframe ? intra4x4 + 4*mb_x : s-&gt;intra4x4_pred_mode_mb;
+            uint8_t *segment_mb = segment_map+mb_x;
+
+            /* Prefetch the current frame, 4 MBs ahead */
+            s-&gt;dsp.prefetch(dst[0] + (mb_x&amp;3)*4*s-&gt;linesize + 64, s-&gt;linesize, 4);
+            s-&gt;dsp.prefetch(dst[1] + (mb_x&amp;7)*s-&gt;uvlinesize + 64, dst[2] - dst[1], 2);
+
+            decode_mb_mode(s, mb, mb_x, mb_y, intra4x4_mb, segment_mb);
+
+            prefetch_motion(s, mb, mb_x, mb_y, mb_xy, VP56_FRAME_PREVIOUS);
+
+            if (!mb-&gt;skip)
+                decode_mb_coeffs(s, c, mb, s-&gt;top_nnz[mb_x], s-&gt;left_nnz);
+
+            if (mb-&gt;mode &lt;= MODE_I4x4)
+                intra_predict(s, dst, mb, intra4x4_mb, mb_x, mb_y);
+            else
+                inter_predict(s, dst, mb, mb_x, mb_y);
+
+            prefetch_motion(s, mb, mb_x, mb_y, mb_xy, VP56_FRAME_GOLDEN);
+
+            if (!mb-&gt;skip) {
+                idct_mb(s, dst, mb);
+            } else {
+                AV_ZERO64(s-&gt;left_nnz);
+                AV_WN64(s-&gt;top_nnz[mb_x], 0);   // array of 9, so unaligned
+
+                // Reset DC block predictors if they would exist if the mb had coefficients
+                if (mb-&gt;mode != MODE_I4x4 &amp;&amp; mb-&gt;mode != VP8_MVMODE_SPLIT) {
+                    s-&gt;left_nnz[8]      = 0;
+                    s-&gt;top_nnz[mb_x][8] = 0;
+                }
+            }
+
+            if (s-&gt;deblock_filter)
+                filter_level_for_mb(s, mb, &amp;s-&gt;filter_strength[mb_x]);
+
+            prefetch_motion(s, mb, mb_x, mb_y, mb_xy, VP56_FRAME_GOLDEN2);
+
+            dst[0] += 16;
+            dst[1] += 8;
+            dst[2] += 8;
+        }
+        if (s-&gt;deblock_filter) {
+            if (s-&gt;filter.simple)
+                filter_mb_row_simple(s, mb_y);
+            else
+                filter_mb_row(s, mb_y);
+        }
+    }
+
+skip_decode:
+    // if future frames don't use the updated probabilities,
+    // reset them to the values we saved
+    if (!s-&gt;update_probabilities)
+        s-&gt;prob[0] = s-&gt;prob[1];
+
+    // check if golden and altref are swapped
+    if (s-&gt;update_altref == VP56_FRAME_GOLDEN &amp;&amp;
+        s-&gt;update_golden == VP56_FRAME_GOLDEN2)
+        FFSWAP(AVFrame *, s-&gt;framep[VP56_FRAME_GOLDEN], s-&gt;framep[VP56_FRAME_GOLDEN2]);
+    else {
+        if (s-&gt;update_altref != VP56_FRAME_NONE)
+            s-&gt;framep[VP56_FRAME_GOLDEN2] = s-&gt;framep[s-&gt;update_altref];
+
+        if (s-&gt;update_golden != VP56_FRAME_NONE)
+            s-&gt;framep[VP56_FRAME_GOLDEN] = s-&gt;framep[s-&gt;update_golden];
+    }
+
+    if (s-&gt;update_last) // move cur-&gt;prev
+        s-&gt;framep[VP56_FRAME_PREVIOUS] = s-&gt;framep[VP56_FRAME_CURRENT];
+
+    // release no longer referenced frames
+    for (i = 0; i &lt; 4; i++)
+        if (s-&gt;frames[i].data[0] &amp;&amp;
+            &amp;s-&gt;frames[i] != s-&gt;framep[VP56_FRAME_CURRENT] &amp;&amp;
+            &amp;s-&gt;frames[i] != s-&gt;framep[VP56_FRAME_PREVIOUS] &amp;&amp;
+            &amp;s-&gt;frames[i] != s-&gt;framep[VP56_FRAME_GOLDEN] &amp;&amp;
+            &amp;s-&gt;frames[i] != s-&gt;framep[VP56_FRAME_GOLDEN2])
+            avctx-&gt;release_buffer(avctx, &amp;s-&gt;frames[i]);
+
+    if (!s-&gt;invisible) {
+        *(AVFrame*)data = *s-&gt;framep[VP56_FRAME_CURRENT];
+        *data_size = sizeof(AVFrame);
+    }
+
+    return avpkt-&gt;size;
+}
+
+static av_cold int vp8_decode_init(AVCodecContext *avctx)
+{
+    VP8Context *s = avctx-&gt;priv_data;
+
+    s-&gt;avctx = avctx;
+    avctx-&gt;pix_fmt = PIX_FMT_YUV420P;
+
+    dsputil_init(&amp;s-&gt;dsp, avctx);
+    ff_h264_pred_init(&amp;s-&gt;hpc, CODEC_ID_VP8);
+    ff_vp8dsp_init(&amp;s-&gt;vp8dsp);
+
+    // intra pred needs edge emulation among other things
+    if (avctx-&gt;flags&amp;CODEC_FLAG_EMU_EDGE) {
+        av_log(avctx, AV_LOG_ERROR, &quot;Edge emulation not supported\n&quot;);
+        return AVERROR_PATCHWELCOME;
+    }
+
+    return 0;
+}
+
+static av_cold int vp8_decode_free(AVCodecContext *avctx)
+{
+    vp8_decode_flush(avctx);
+    return 0;
+}
+
+AVCodec vp8_decoder = {
+    &quot;vp8&quot;,
+    AVMEDIA_TYPE_VIDEO,
+    CODEC_ID_VP8,
+    sizeof(VP8Context),
+    vp8_decode_init,
+    NULL,
+    vp8_decode_free,
+    vp8_decode_frame,
+    CODEC_CAP_DR1,
+    .flush = vp8_decode_flush,
+    .long_name = NULL_IF_CONFIG_SMALL(&quot;On2 VP8&quot;),
+};

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/vp8_parser.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/vp8_parser.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/vp8_parser.c	2010-07-25 10:07:39 UTC (rev 6478)
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2008 Michael Niedermayer
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include &quot;parser.h&quot;
+
+static int parse(AVCodecParserContext *s,
+                           AVCodecContext *avctx,
+                           const uint8_t **poutbuf, int *poutbuf_size,
+                           const uint8_t *buf, int buf_size)
+{
+    s-&gt;pict_type= (buf[0]&amp;0x01) ? FF_P_TYPE : FF_I_TYPE;
+
+    *poutbuf = buf;
+    *poutbuf_size = buf_size;
+    return buf_size;
+}
+
+AVCodecParser vp8_parser = {
+    { CODEC_ID_VP8 },
+    0,
+    NULL,
+    parse,
+};

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/vp8data.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/vp8data.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/vp8data.h	2010-07-25 10:07:39 UTC (rev 6478)
@@ -0,0 +1,734 @@
+/**
+ * VP8 compatible video decoder
+ *
+ * Copyright (C) 2010 David Conrad
+ * Copyright (C) 2010 Ronald S. Bultje
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+// TODO: move these #define and enum to a better header...
+
+#define VP8_MAX_QUANT 127
+
+enum dct_token {
+    DCT_0,
+    DCT_1,
+    DCT_2,
+    DCT_3,
+    DCT_4,
+    DCT_CAT1,
+    DCT_CAT2,
+    DCT_CAT3,
+    DCT_CAT4,
+    DCT_CAT5,
+    DCT_CAT6,
+    DCT_EOB,
+
+    NUM_DCT_TOKENS
+};
+
+#include &quot;h264pred.h&quot;
+
+// used to signal 4x4 intra pred in luma MBs
+#define MODE_I4x4 4
+
+enum inter_mvmode {
+    VP8_MVMODE_NEAREST = MODE_I4x4 + 1,
+    VP8_MVMODE_NEAR,
+    VP8_MVMODE_ZERO,
+    VP8_MVMODE_NEW,
+    VP8_MVMODE_SPLIT
+};
+
+enum inter_submvmode {
+    VP8_SUBMVMODE_LEFT4X4,
+    VP8_SUBMVMODE_TOP4X4,
+    VP8_SUBMVMODE_ZERO4X4,
+    VP8_SUBMVMODE_NEW4X4
+};
+
+enum inter_splitmvmode {
+    VP8_SPLITMVMODE_16x8 = 0,    ///&lt; 2 16x8 blocks (vertical)
+    VP8_SPLITMVMODE_8x16,        ///&lt; 2 8x16 blocks (horizontal)
+    VP8_SPLITMVMODE_8x8,         ///&lt; 2x2 blocks of 8x8px each
+    VP8_SPLITMVMODE_4x4,         ///&lt; 4x4 blocks of 4x4px each
+    VP8_SPLITMVMODE_NONE,        ///&lt; (only used in prediction) no split MVs
+};
+
+static const uint8_t vp8_pred4x4_mode[] =
+{
+    [DC_PRED8x8]    = DC_PRED,
+    [VERT_PRED8x8]  = VERT_PRED,
+    [HOR_PRED8x8]   = HOR_PRED,
+    [PLANE_PRED8x8] = TM_VP8_PRED,
+};
+
+static const int8_t vp8_pred16x16_tree_intra[4][2] =
+{
+    { -MODE_I4x4, 1 },                      // '0'
+     { 2, 3 },
+      {  -DC_PRED8x8,  -VERT_PRED8x8 },     // '100', '101'
+      { -HOR_PRED8x8, -PLANE_PRED8x8 },     // '110', '111'
+};
+
+static const int8_t vp8_pred16x16_tree_inter[4][2] =
+{
+    { -DC_PRED8x8, 1 },                     // '0'
+     { 2, 3 },
+      {  -VERT_PRED8x8, -HOR_PRED8x8 },     // '100', '101'
+      { -PLANE_PRED8x8, -MODE_I4x4 },       // '110', '111'
+};
+
+static const int vp8_mode_contexts[6][4] = {
+    {   7,   1,   1, 143 },
+    {  14,  18,  14, 107 },
+    { 135,  64,  57,  68 },
+    {  60,  56, 128,  65 },
+    { 159, 134, 128,  34 },
+    { 234, 188, 128,  28 },
+};
+
+static const int8_t vp8_pred16x16_tree_mvinter[4][2] = {
+    { -VP8_MVMODE_ZERO,      1 },           // '0'
+     { -VP8_MVMODE_NEAREST,  2 },           // '10'
+      { -VP8_MVMODE_NEAR,    3 },           // '110'
+       { -VP8_MVMODE_NEW, -VP8_MVMODE_SPLIT } // '1110', '1111'
+};
+
+static const uint8_t vp8_mbsplits[5][16] = {
+    {  0,  0,  0,  0,  0,  0,  0,  0,
+       1,  1,  1,  1,  1,  1,  1,  1  },
+    {  0,  0,  1,  1,  0,  0,  1,  1,
+       0,  0,  1,  1,  0,  0,  1,  1  },
+    {  0,  0,  1,  1,  0,  0,  1,  1,
+       2,  2,  3,  3,  2,  2,  3,  3  },
+    {  0,  1,  2,  3,  4,  5,  6,  7,
+       8,  9, 10, 11, 12, 13, 14, 15  },
+    {  0,  0,  0,  0,  0,  0,  0,  0,
+       0,  0,  0,  0,  0,  0,  0,  0  }
+};
+
+static const uint8_t vp8_mbfirstidx[4][16] = {
+    {  0,  8 }, {  0,  2 }, {  0,  2,  8,  10 },
+    {  0,  1,  2,  3,  4,  5,  6,  7,
+       8,  9, 10, 11, 12, 13, 14, 15 }
+};
+
+static const int8_t vp8_mbsplit_tree[3][2] = {
+    { -VP8_SPLITMVMODE_4x4,  1 },           // '0' - 16 individual MVs
+     { -VP8_SPLITMVMODE_8x8,  2 },          // '10' - quarter-based MVs
+      { -VP8_SPLITMVMODE_16x8,              // '110' - top/bottom MVs
+        -VP8_SPLITMVMODE_8x16 }             // '111' - left/right MVs
+};
+static const uint8_t vp8_mbsplit_count[4] = {   2,   2,   4,  16 };
+static const uint8_t vp8_mbsplit_prob[3]  = { 110, 111, 150 };
+
+static const uint8_t vp8_submv_prob[5][3] = {
+    { 147, 136,  18 },
+    { 106, 145,   1 },
+    { 179, 121,   1 },
+    { 223,   1,  34 },
+    { 208,   1,   1 }
+};
+
+static const int8_t vp8_submv_ref_tree[3][2] = {
+    { -VP8_SUBMVMODE_LEFT4X4, 1 },          // '0'
+     { -VP8_SUBMVMODE_TOP4X4, 2 },          // '10'
+      { -VP8_SUBMVMODE_ZERO4X4, -VP8_SUBMVMODE_NEW4X4 } // '110', '111'
+};
+
+static const uint8_t vp8_pred16x16_prob_intra[4] = { 145, 156, 163, 128 };
+static const uint8_t vp8_pred16x16_prob_inter[4] = { 112,  86, 140,  37 };
+
+static const int8_t vp8_pred4x4_tree[9][2] =
+{
+    { -DC_PRED, 1 },                                    // '0'
+     { -TM_VP8_PRED, 2 },                               // '10'
+      { -VERT_PRED, 3 },                                // '110'
+       { 4, 6 },
+        { -HOR_PRED, 5 },                               // '11100'
+         { -DIAG_DOWN_RIGHT_PRED, -VERT_RIGHT_PRED },   // '111010', '111011'
+        { -DIAG_DOWN_LEFT_PRED, 7 },                    // '11110'
+         { -VERT_LEFT_PRED, 8 },                        // '111110'
+          { -HOR_DOWN_PRED, -HOR_UP_PRED },             // '1111110', '1111111'
+};
+
+static const int8_t vp8_pred8x8c_tree[3][2] =
+{
+    { -DC_PRED8x8, 1 },                 // '0'
+     { -VERT_PRED8x8, 2 },              // '10
+      { -HOR_PRED8x8, -PLANE_PRED8x8 }, // '110', '111'
+};
+
+static const uint8_t vp8_pred8x8c_prob_intra[3] = { 142, 114, 183 };
+static const uint8_t vp8_pred8x8c_prob_inter[3] = { 162, 101, 204 };
+
+static const uint8_t vp8_pred4x4_prob_inter[9] =
+{
+    120, 90, 79, 133, 87, 85, 80, 111, 151
+};
+
+static const uint8_t vp8_pred4x4_prob_intra[10][10][9] =
+{
+    {
+        {  39,  53, 200,  87,  26,  21,  43, 232, 171 },
+        {  56,  34,  51, 104, 114, 102,  29,  93,  77 },
+        {  88,  88, 147, 150,  42,  46,  45, 196, 205 },
+        { 107,  54,  32,  26,  51,   1,  81,  43,  31 },
+        {  39,  28,  85, 171,  58, 165,  90,  98,  64 },
+        {  34,  22, 116, 206,  23,  34,  43, 166,  73 },
+        {  34,  19,  21, 102, 132, 188,  16,  76, 124 },
+        {  68,  25, 106,  22,  64, 171,  36, 225, 114 },
+        {  62,  18,  78,  95,  85,  57,  50,  48,  51 },
+        {  43,  97, 183, 117,  85,  38,  35, 179,  61 },
+    },
+    {
+        { 112, 113,  77,  85, 179, 255,  38, 120, 114 },
+        {  40,  42,   1, 196, 245, 209,  10,  25, 109 },
+        { 193, 101,  35, 159, 215, 111,  89,  46, 111 },
+        { 100,  80,   8,  43, 154,   1,  51,  26,  71 },
+        {  88,  43,  29, 140, 166, 213,  37,  43, 154 },
+        {  61,  63,  30, 155,  67,  45,  68,   1, 209 },
+        {  41,  40,   5, 102, 211, 183,   4,   1, 221 },
+        { 142,  78,  78,  16, 255, 128,  34, 197, 171 },
+        {  51,  50,  17, 168, 209, 192,  23,  25,  82 },
+        {  60, 148,  31, 172, 219, 228,  21,  18, 111 },
+    },
+    {
+        { 175,  69, 143,  80,  85,  82,  72, 155, 103 },
+        {  56,  58,  10, 171, 218, 189,  17,  13, 152 },
+        { 231, 120,  48,  89, 115, 113, 120, 152, 112 },
+        { 144,  71,  10,  38, 171, 213, 144,  34,  26 },
+        { 114,  26,  17, 163,  44, 195,  21,  10, 173 },
+        { 121,  24,  80, 195,  26,  62,  44,  64,  85 },
+        {  63,  20,   8, 114, 114, 208,  12,   9, 226 },
+        { 170,  46,  55,  19, 136, 160,  33, 206,  71 },
+        {  81,  40,  11,  96, 182,  84,  29,  16,  36 },
+        { 152, 179,  64, 126, 170, 118,  46,  70,  95 },
+    },
+    {
+        {  75,  79, 123,  47,  51, 128,  81, 171,   1 },
+        {  57,  17,   5,  71, 102,  57,  53,  41,  49 },
+        { 125,  98,  42,  88, 104,  85, 117, 175,  82 },
+        { 115,  21,   2,  10, 102, 255, 166,  23,   6 },
+        {  38,  33,  13, 121,  57,  73,  26,   1,  85 },
+        {  41,  10,  67, 138,  77, 110,  90,  47, 114 },
+        {  57,  18,  10, 102, 102, 213,  34,  20,  43 },
+        { 101,  29,  16,  10,  85, 128, 101, 196,  26 },
+        { 117,  20,  15,  36, 163, 128,  68,   1,  26 },
+        {  95,  84,  53,  89, 128, 100, 113, 101,  45 },
+    },
+    {
+        {  63,  59,  90, 180,  59, 166,  93,  73, 154 },
+        {  40,  40,  21, 116, 143, 209,  34,  39, 175 },
+        { 138,  31,  36, 171,  27, 166,  38,  44, 229 },
+        {  57,  46,  22,  24, 128,   1,  54,  17,  37 },
+        {  47,  15,  16, 183,  34, 223,  49,  45, 183 },
+        {  46,  17,  33, 183,   6,  98,  15,  32, 183 },
+        {  40,   3,   9, 115,  51, 192,  18,   6, 223 },
+        {  65,  32,  73, 115,  28, 128,  23, 128, 205 },
+        {  87,  37,   9, 115,  59,  77,  64,  21,  47 },
+        {  67,  87,  58, 169,  82, 115,  26,  59, 179 },
+    },
+    {
+        {  54,  57, 112, 184,   5,  41,  38, 166, 213 },
+        {  30,  34,  26, 133, 152, 116,  10,  32, 134 },
+        { 104,  55,  44, 218,   9,  54,  53, 130, 226 },
+        {  75,  32,  12,  51, 192, 255, 160,  43,  51 },
+        {  39,  19,  53, 221,  26, 114,  32,  73, 255 },
+        {  31,   9,  65, 234,   2,  15,   1, 118,  73 },
+        {  56,  21,  23, 111,  59, 205,  45,  37, 192 },
+        {  88,  31,  35,  67, 102,  85,  55, 186,  85 },
+        {  55,  38,  70, 124,  73, 102,   1,  34,  98 },
+        {  64,  90,  70, 205,  40,  41,  23,  26,  57 },
+    },
+    {
+        {  86,  40,  64, 135, 148, 224,  45, 183, 128 },
+        {  22,  26,  17, 131, 240, 154,  14,   1, 209 },
+        { 164,  50,  31, 137, 154, 133,  25,  35, 218 },
+        {  83,  12,  13,  54, 192, 255,  68,  47,  28 },
+        {  45,  16,  21,  91,  64, 222,   7,   1, 197 },
+        {  56,  21,  39, 155,  60, 138,  23, 102, 213 },
+        {  18,  11,   7,  63, 144, 171,   4,   4, 246 },
+        {  85,  26,  85,  85, 128, 128,  32, 146, 171 },
+        {  35,  27,  10, 146, 174, 171,  12,  26, 128 },
+        {  51, 103,  44, 131, 131, 123,  31,   6, 158 },
+    },
+    {
+        {  68,  45, 128,  34,   1,  47,  11, 245, 171 },
+        {  62,  17,  19,  70, 146,  85,  55,  62,  70 },
+        { 102,  61,  71,  37,  34,  53,  31, 243, 192 },
+        {  75,  15,   9,   9,  64, 255, 184, 119,  16 },
+        {  37,  43,  37, 154, 100, 163,  85, 160,   1 },
+        {  63,   9,  92, 136,  28,  64,  32, 201,  85 },
+        {  56,   8,  17, 132, 137, 255,  55, 116, 128 },
+        {  86,   6,  28,   5,  64, 255,  25, 248,   1 },
+        {  58,  15,  20,  82, 135,  57,  26, 121,  40 },
+        {  69,  60,  71,  38,  73, 119,  28, 222,  37 },
+    },
+    {
+        { 101,  75, 128, 139, 118, 146, 116, 128,  85 },
+        {  56,  41,  15, 176, 236,  85,  37,   9,  62 },
+        { 190,  80,  35,  99, 180,  80, 126,  54,  45 },
+        { 146,  36,  19,  30, 171, 255,  97,  27,  20 },
+        {  71,  30,  17, 119, 118, 255,  17,  18, 138 },
+        { 101,  38,  60, 138,  55,  70,  43,  26, 142 },
+        {  32,  41,  20, 117, 151, 142,  20,  21, 163 },
+        { 138,  45,  61,  62, 219,   1,  81, 188,  64 },
+        { 112,  19,  12,  61, 195, 128,  48,   4,  24 },
+        {  85, 126,  47,  87, 176,  51,  41,  20,  32 },
+    },
+    {
+        {  66, 102, 167,  99,  74,  62,  40, 234, 128 },
+        {  41,  53,   9, 178, 241, 141,  26,   8, 107 },
+        { 134, 183,  89, 137,  98, 101, 106, 165, 148 },
+        { 104,  79,  12,  27, 217, 255,  87,  17,   7 },
+        {  74,  43,  26, 146,  73, 166,  49,  23, 157 },
+        {  65,  38, 105, 160,  51,  52,  31, 115, 128 },
+        {  47,  41,  14, 110, 182, 183,  21,  17, 194 },
+        {  87,  68,  71,  44, 114,  51,  15, 186,  23 },
+        {  66,  45,  25, 102, 197, 189,  23,  18,  22 },
+        {  72, 187, 100, 130, 157, 111,  32,  75,  80 },
+    },
+};
+
+static const int8_t vp8_segmentid_tree[][2] =
+{
+    { 1, 2 },
+     { -0, -1 },    // '00', '01'
+     { -2, -3 },    // '10', '11'
+};
+
+static const uint8_t vp8_coeff_band[16] =
+{
+    0, 1, 2, 3, 6, 4, 5, 6, 6, 6, 6, 6, 6, 6, 6, 7
+};
+
+static const uint8_t vp8_dct_cat1_prob[] = { 159, 0 };
+static const uint8_t vp8_dct_cat2_prob[] = { 165, 145, 0 };
+static const uint8_t vp8_dct_cat3_prob[] = { 173, 148, 140, 0 };
+static const uint8_t vp8_dct_cat4_prob[] = { 176, 155, 140, 135, 0 };
+static const uint8_t vp8_dct_cat5_prob[] = { 180, 157, 141, 134, 130, 0 };
+static const uint8_t vp8_dct_cat6_prob[] = { 254, 254, 243, 230, 196, 177, 153, 140, 133, 130, 129, 0 };
+
+// only used for cat3 and above; cat 1 and 2 are referenced directly
+static const uint8_t * const vp8_dct_cat_prob[] =
+{
+    vp8_dct_cat3_prob,
+    vp8_dct_cat4_prob,
+    vp8_dct_cat5_prob,
+    vp8_dct_cat6_prob,
+};
+
+static const uint8_t vp8_token_default_probs[4][8][3][NUM_DCT_TOKENS-1] =
+{
+    {
+        {
+            { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128 },
+            { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128 },
+            { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128 },
+        },
+        {
+            { 253, 136, 254, 255, 228, 219, 128, 128, 128, 128, 128 },
+            { 189, 129, 242, 255, 227, 213, 255, 219, 128, 128, 128 },
+            { 106, 126, 227, 252, 214, 209, 255, 255, 128, 128, 128 },
+        },
+        {
+            {   1,  98, 248, 255, 236, 226, 255, 255, 128, 128, 128 },
+            { 181, 133, 238, 254, 221, 234, 255, 154, 128, 128, 128 },
+            {  78, 134, 202, 247, 198, 180, 255, 219, 128, 128, 128 },
+        },
+        {
+            {   1, 185, 249, 255, 243, 255, 128, 128, 128, 128, 128 },
+            { 184, 150, 247, 255, 236, 224, 128, 128, 128, 128, 128 },
+            {  77, 110, 216, 255, 236, 230, 128, 128, 128, 128, 128 },
+        },
+        {
+            {   1, 101, 251, 255, 241, 255, 128, 128, 128, 128, 128 },
+            { 170, 139, 241, 252, 236, 209, 255, 255, 128, 128, 128 },
+            {  37, 116, 196, 243, 228, 255, 255, 255, 128, 128, 128 },
+        },
+        {
+            {   1, 204, 254, 255, 245, 255, 128, 128, 128, 128, 128 },
+            { 207, 160, 250, 255, 238, 128, 128, 128, 128, 128, 128 },
+            { 102, 103, 231, 255, 211, 171, 128, 128, 128, 128, 128 },
+        },
+        {
+            {   1, 152, 252, 255, 240, 255, 128, 128, 128, 128, 128 },
+            { 177, 135, 243, 255, 234, 225, 128, 128, 128, 128, 128 },
+            {  80, 129, 211, 255, 194, 224, 128, 128, 128, 128, 128 },
+        },
+        {
+            {   1,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128 },
+            { 246,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128 },
+            { 255, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128 },
+        },
+    },
+    {
+        {
+            { 198,  35, 237, 223, 193, 187, 162, 160, 145, 155,  62 },
+            { 131,  45, 198, 221, 172, 176, 220, 157, 252, 221,   1 },
+            {  68,  47, 146, 208, 149, 167, 221, 162, 255, 223, 128 },
+        },
+        {
+            {   1, 149, 241, 255, 221, 224, 255, 255, 128, 128, 128 },
+            { 184, 141, 234, 253, 222, 220, 255, 199, 128, 128, 128 },
+            {  81,  99, 181, 242, 176, 190, 249, 202, 255, 255, 128 },
+        },
+        {
+            {   1, 129, 232, 253, 214, 197, 242, 196, 255, 255, 128 },
+            {  99, 121, 210, 250, 201, 198, 255, 202, 128, 128, 128 },
+            {  23,  91, 163, 242, 170, 187, 247, 210, 255, 255, 128 },
+        },
+        {
+            {   1, 200, 246, 255, 234, 255, 128, 128, 128, 128, 128 },
+            { 109, 178, 241, 255, 231, 245, 255, 255, 128, 128, 128 },
+            {  44, 130, 201, 253, 205, 192, 255, 255, 128, 128, 128 },
+        },
+        {
+            {   1, 132, 239, 251, 219, 209, 255, 165, 128, 128, 128 },
+            {  94, 136, 225, 251, 218, 190, 255, 255, 128, 128, 128 },
+            {  22, 100, 174, 245, 186, 161, 255, 199, 128, 128, 128 },
+        },
+        {
+            {   1, 182, 249, 255, 232, 235, 128, 128, 128, 128, 128 },
+            { 124, 143, 241, 255, 227, 234, 128, 128, 128, 128, 128 },
+            {  35,  77, 181, 251, 193, 211, 255, 205, 128, 128, 128 },
+        },
+        {
+            {   1, 157, 247, 255, 236, 231, 255, 255, 128, 128, 128 },
+            { 121, 141, 235, 255, 225, 227, 255, 255, 128, 128, 128 },
+            {  45,  99, 188, 251, 195, 217, 255, 224, 128, 128, 128 },
+        },
+        {
+            {   1,   1, 251, 255, 213, 255, 128, 128, 128, 128, 128 },
+            { 203,   1, 248, 255, 255, 128, 128, 128, 128, 128, 128 },
+            { 137,   1, 177, 255, 224, 255, 128, 128, 128, 128, 128 },
+        },
+    },
+    {
+        {
+            { 253,   9, 248, 251, 207, 208, 255, 192, 128, 128, 128 },
+            { 175,  13, 224, 243, 193, 185, 249, 198, 255, 255, 128 },
+            {  73,  17, 171, 221, 161, 179, 236, 167, 255, 234, 128 },
+        },
+        {
+            {   1,  95, 247, 253, 212, 183, 255, 255, 128, 128, 128 },
+            { 239,  90, 244, 250, 211, 209, 255, 255, 128, 128, 128 },
+            { 155,  77, 195, 248, 188, 195, 255, 255, 128, 128, 128 },
+        },
+        {
+            {   1,  24, 239, 251, 218, 219, 255, 205, 128, 128, 128 },
+            { 201,  51, 219, 255, 196, 186, 128, 128, 128, 128, 128 },
+            {  69,  46, 190, 239, 201, 218, 255, 228, 128, 128, 128 },
+        },
+        {
+            {   1, 191, 251, 255, 255, 128, 128, 128, 128, 128, 128 },
+            { 223, 165, 249, 255, 213, 255, 128, 128, 128, 128, 128 },
+            { 141, 124, 248, 255, 255, 128, 128, 128, 128, 128, 128 },
+        },
+        {
+            {   1,  16, 248, 255, 255, 128, 128, 128, 128, 128, 128 },
+            { 190,  36, 230, 255, 236, 255, 128, 128, 128, 128, 128 },
+            { 149,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128 },
+        },
+        {
+            {   1, 226, 255, 128, 128, 128, 128, 128, 128, 128, 128 },
+            { 247, 192, 255, 128, 128, 128, 128, 128, 128, 128, 128 },
+            { 240, 128, 255, 128, 128, 128, 128, 128, 128, 128, 128 },
+        },
+        {
+            {   1, 134, 252, 255, 255, 128, 128, 128, 128, 128, 128 },
+            { 213,  62, 250, 255, 255, 128, 128, 128, 128, 128, 128 },
+            {  55,  93, 255, 128, 128, 128, 128, 128, 128, 128, 128 },
+        },
+        {
+            { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128 },
+            { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128 },
+            { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128 },
+        },
+    },
+    {
+        {
+            { 202,  24, 213, 235, 186, 191, 220, 160, 240, 175, 255 },
+            { 126,  38, 182, 232, 169, 184, 228, 174, 255, 187, 128 },
+            {  61,  46, 138, 219, 151, 178, 240, 170, 255, 216, 128 },
+        },
+        {
+            {   1, 112, 230, 250, 199, 191, 247, 159, 255, 255, 128 },
+            { 166, 109, 228, 252, 211, 215, 255, 174, 128, 128, 128 },
+            {  39,  77, 162, 232, 172, 180, 245, 178, 255, 255, 128 },
+        },
+        {
+            {   1,  52, 220, 246, 198, 199, 249, 220, 255, 255, 128 },
+            { 124,  74, 191, 243, 183, 193, 250, 221, 255, 255, 128 },
+            {  24,  71, 130, 219, 154, 170, 243, 182, 255, 255, 128 },
+        },
+        {
+            {   1, 182, 225, 249, 219, 240, 255, 224, 128, 128, 128 },
+            { 149, 150, 226, 252, 216, 205, 255, 171, 128, 128, 128 },
+            {  28, 108, 170, 242, 183, 194, 254, 223, 255, 255, 128 },
+        },
+        {
+            {   1,  81, 230, 252, 204, 203, 255, 192, 128, 128, 128 },
+            { 123, 102, 209, 247, 188, 196, 255, 233, 128, 128, 128 },
+            {  20,  95, 153, 243, 164, 173, 255, 203, 128, 128, 128 },
+        },
+        {
+            {   1, 222, 248, 255, 216, 213, 128, 128, 128, 128, 128 },
+            { 168, 175, 246, 252, 235, 205, 255, 255, 128, 128, 128 },
+            {  47, 116, 215, 255, 211, 212, 255, 255, 128, 128, 128 },
+        },
+        {
+            {   1, 121, 236, 253, 212, 214, 255, 255, 128, 128, 128 },
+            { 141,  84, 213, 252, 201, 202, 255, 219, 128, 128, 128 },
+            {  42,  80, 160, 240, 162, 185, 255, 205, 128, 128, 128 },
+        },
+        {
+            {   1,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128 },
+            { 244,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128 },
+            { 238,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128 },
+        },
+    },
+};
+
+static const uint8_t vp8_token_update_probs[4][8][3][NUM_DCT_TOKENS-1] =
+{
+    {
+        {
+            { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+        },
+        {
+            { 176, 246, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 223, 241, 252, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 249, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255 },
+        },
+        {
+            { 255, 244, 252, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 234, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+        },
+        {
+            { 255, 246, 254, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 239, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255 },
+        },
+        {
+            { 255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 251, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+        },
+        {
+            { 255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 251, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255 },
+        },
+        {
+            { 255, 254, 253, 255, 254, 255, 255, 255, 255, 255, 255 },
+            { 250, 255, 254, 255, 254, 255, 255, 255, 255, 255, 255 },
+            { 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+        },
+        {
+            { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+        },
+    },
+    {
+        {
+            { 217, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 225, 252, 241, 253, 255, 255, 254, 255, 255, 255, 255 },
+            { 234, 250, 241, 250, 253, 255, 253, 254, 255, 255, 255 },
+        },
+        {
+            { 255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 223, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 238, 253, 254, 254, 255, 255, 255, 255, 255, 255, 255 },
+        },
+        {
+            { 255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 249, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+        },
+        {
+            { 255, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 247, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+        },
+        {
+            { 255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 252, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+        },
+        {
+            { 255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+        },
+        {
+            { 255, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+        },
+        {
+            { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+        },
+    },
+    {
+        {
+            { 186, 251, 250, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 234, 251, 244, 254, 255, 255, 255, 255, 255, 255, 255 },
+            { 251, 251, 243, 253, 254, 255, 254, 255, 255, 255, 255 },
+        },
+        {
+            { 255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 236, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 251, 253, 253, 254, 254, 255, 255, 255, 255, 255, 255 },
+        },
+        {
+            { 255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 254, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+        },
+        {
+            { 255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+        },
+        {
+            { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+        },
+        {
+            { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+        },
+        {
+            { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+        },
+        {
+            { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+        },
+    },
+    {
+        {
+            { 248, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 250, 254, 252, 254, 255, 255, 255, 255, 255, 255, 255 },
+            { 248, 254, 249, 253, 255, 255, 255, 255, 255, 255, 255 },
+        },
+        {
+            { 255, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 246, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 252, 254, 251, 254, 254, 255, 255, 255, 255, 255, 255 },
+        },
+        {
+            { 255, 254, 252, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 248, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 253, 255, 254, 254, 255, 255, 255, 255, 255, 255, 255 },
+        },
+        {
+            { 255, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 245, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 253, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255 },
+        },
+        {
+            { 255, 251, 253, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 252, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+        },
+        {
+            { 255, 252, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 249, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 255, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255 },
+        },
+        {
+            { 255, 255, 253, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+        },
+        {
+            { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+            { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
+        },
+    },
+};
+
+// fixme: copied from h264data.h
+static const uint8_t zigzag_scan[16]={
+    0+0*4, 1+0*4, 0+1*4, 0+2*4,
+    1+1*4, 2+0*4, 3+0*4, 2+1*4,
+    1+2*4, 0+3*4, 1+3*4, 2+2*4,
+    3+1*4, 3+2*4, 2+3*4, 3+3*4,
+};
+
+static const uint8_t vp8_dc_qlookup[VP8_MAX_QUANT+1] =
+{
+      4,   5,   6,   7,   8,   9,  10,  10,  11,  12,  13,  14,  15,  16,  17,  17,
+     18,  19,  20,  20,  21,  21,  22,  22,  23,  23,  24,  25,  25,  26,  27,  28,
+     29,  30,  31,  32,  33,  34,  35,  36,  37,  37,  38,  39,  40,  41,  42,  43,
+     44,  45,  46,  46,  47,  48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  58,
+     59,  60,  61,  62,  63,  64,  65,  66,  67,  68,  69,  70,  71,  72,  73,  74,
+     75,  76,  76,  77,  78,  79,  80,  81,  82,  83,  84,  85,  86,  87,  88,  89,
+     91,  93,  95,  96,  98, 100, 101, 102, 104, 106, 108, 110, 112, 114, 116, 118,
+    122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 143, 145, 148, 151, 154, 157,
+};
+
+static const uint16_t vp8_ac_qlookup[VP8_MAX_QUANT+1] =
+{
+      4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
+     20,  21,  22,  23,  24,  25,  26,  27,  28,  29,  30,  31,  32,  33,  34,  35,
+     36,  37,  38,  39,  40,  41,  42,  43,  44,  45,  46,  47,  48,  49,  50,  51,
+     52,  53,  54,  55,  56,  57,  58,  60,  62,  64,  66,  68,  70,  72,  74,  76,
+     78,  80,  82,  84,  86,  88,  90,  92,  94,  96,  98, 100, 102, 104, 106, 108,
+    110, 112, 114, 116, 119, 122, 125, 128, 131, 134, 137, 140, 143, 146, 149, 152,
+    155, 158, 161, 164, 167, 170, 173, 177, 181, 185, 189, 193, 197, 201, 205, 209,
+    213, 217, 221, 225, 229, 234, 239, 245, 249, 254, 259, 264, 269, 274, 279, 284,
+};
+
+static const uint8_t vp8_mv_update_prob[2][19] = {
+    { 237,
+      246,
+      253, 253, 254, 254, 254, 254, 254,
+      254, 254, 254, 254, 254, 250, 250, 252, 254, 254 },
+    { 231,
+      243,
+      245, 253, 254, 254, 254, 254, 254,
+      254, 254, 254, 254, 254, 251, 251, 254, 254, 254 }
+};
+
+static const uint8_t vp8_mv_default_prob[2][19] = {
+    { 162,
+      128,
+      225, 146, 172, 147, 214, 39, 156,
+      128, 129, 132,  75, 145, 178, 206, 239, 254, 254 },
+    { 164,
+      128,
+      204, 170, 119, 235, 140, 230, 228,
+      128, 130, 130,  74, 148, 180, 203, 236, 254, 254 }
+};

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/vp8dsp.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/vp8dsp.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/vp8dsp.c	2010-07-25 10:07:39 UTC (rev 6478)
@@ -0,0 +1,509 @@
+/**
+ * VP8 compatible video decoder
+ *
+ * Copyright (C) 2010 David Conrad
+ * Copyright (C) 2010 Ronald S. Bultje
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include &quot;dsputil.h&quot;
+#include &quot;vp8dsp.h&quot;
+
+// TODO: Maybe add dequant
+static void vp8_luma_dc_wht_c(DCTELEM block[4][4][16], DCTELEM dc[16])
+{
+    int i, t0, t1, t2, t3;
+
+    for (i = 0; i &lt; 4; i++) {
+        t0 = dc[0*4+i] + dc[3*4+i];
+        t1 = dc[1*4+i] + dc[2*4+i];
+        t2 = dc[1*4+i] - dc[2*4+i];
+        t3 = dc[0*4+i] - dc[3*4+i];
+
+        dc[0*4+i] = t0 + t1;
+        dc[1*4+i] = t3 + t2;
+        dc[2*4+i] = t0 - t1;
+        dc[3*4+i] = t3 - t2;
+    }
+
+    for (i = 0; i &lt; 4; i++) {
+        t0 = dc[i*4+0] + dc[i*4+3] + 3; // rounding
+        t1 = dc[i*4+1] + dc[i*4+2];
+        t2 = dc[i*4+1] - dc[i*4+2];
+        t3 = dc[i*4+0] - dc[i*4+3] + 3; // rounding
+
+        *block[i][0] = (t0 + t1) &gt;&gt; 3;
+        *block[i][1] = (t3 + t2) &gt;&gt; 3;
+        *block[i][2] = (t0 - t1) &gt;&gt; 3;
+        *block[i][3] = (t3 - t2) &gt;&gt; 3;
+    }
+}
+
+
+#define MUL_20091(a) ((((a)*20091) &gt;&gt; 16) + (a))
+#define MUL_35468(a)  (((a)*35468) &gt;&gt; 16)
+
+static void vp8_idct_add_c(uint8_t *dst, DCTELEM block[16], int stride)
+{
+    int i, t0, t1, t2, t3;
+    uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;
+    DCTELEM tmp[16];
+
+    for (i = 0; i &lt; 4; i++) {
+        t0 = block[0*4+i] + block[2*4+i];
+        t1 = block[0*4+i] - block[2*4+i];
+        t2 = MUL_35468(block[1*4+i]) - MUL_20091(block[3*4+i]);
+        t3 = MUL_20091(block[1*4+i]) + MUL_35468(block[3*4+i]);
+        block[0*4+i] = 0;
+        block[1*4+i] = 0;
+        block[2*4+i] = 0;
+        block[3*4+i] = 0;
+
+        tmp[i*4+0] = t0 + t3;
+        tmp[i*4+1] = t1 + t2;
+        tmp[i*4+2] = t1 - t2;
+        tmp[i*4+3] = t0 - t3;
+    }
+
+    for (i = 0; i &lt; 4; i++) {
+        t0 = tmp[0*4+i] + tmp[2*4+i];
+        t1 = tmp[0*4+i] - tmp[2*4+i];
+        t2 = MUL_35468(tmp[1*4+i]) - MUL_20091(tmp[3*4+i]);
+        t3 = MUL_20091(tmp[1*4+i]) + MUL_35468(tmp[3*4+i]);
+
+        dst[0] = cm[dst[0] + ((t0 + t3 + 4) &gt;&gt; 3)];
+        dst[1] = cm[dst[1] + ((t1 + t2 + 4) &gt;&gt; 3)];
+        dst[2] = cm[dst[2] + ((t1 - t2 + 4) &gt;&gt; 3)];
+        dst[3] = cm[dst[3] + ((t0 - t3 + 4) &gt;&gt; 3)];
+        dst += stride;
+    }
+}
+
+static void vp8_idct_dc_add_c(uint8_t *dst, DCTELEM block[16], int stride)
+{
+    int i, dc = (block[0] + 4) &gt;&gt; 3;
+    uint8_t *cm = ff_cropTbl + MAX_NEG_CROP + dc;
+    block[0] = 0;
+
+    for (i = 0; i &lt; 4; i++) {
+        dst[0] = cm[dst[0]];
+        dst[1] = cm[dst[1]];
+        dst[2] = cm[dst[2]];
+        dst[3] = cm[dst[3]];
+        dst += stride;
+    }
+}
+
+static void vp8_idct_dc_add4uv_c(uint8_t *dst, DCTELEM block[4][16], int stride)
+{
+    vp8_idct_dc_add_c(dst+stride*0+0, block[0], stride);
+    vp8_idct_dc_add_c(dst+stride*0+4, block[1], stride);
+    vp8_idct_dc_add_c(dst+stride*4+0, block[2], stride);
+    vp8_idct_dc_add_c(dst+stride*4+4, block[3], stride);
+}
+
+static void vp8_idct_dc_add4y_c(uint8_t *dst, DCTELEM block[4][16], int stride)
+{
+    vp8_idct_dc_add_c(dst+ 0, block[0], stride);
+    vp8_idct_dc_add_c(dst+ 4, block[1], stride);
+    vp8_idct_dc_add_c(dst+ 8, block[2], stride);
+    vp8_idct_dc_add_c(dst+12, block[3], stride);
+}
+
+// because I like only having two parameters to pass functions...
+#define LOAD_PIXELS\
+    int av_unused p3 = p[-4*stride];\
+    int av_unused p2 = p[-3*stride];\
+    int av_unused p1 = p[-2*stride];\
+    int av_unused p0 = p[-1*stride];\
+    int av_unused q0 = p[ 0*stride];\
+    int av_unused q1 = p[ 1*stride];\
+    int av_unused q2 = p[ 2*stride];\
+    int av_unused q3 = p[ 3*stride];
+
+#define clip_int8(n) (cm[n+0x80]-0x80)
+
+static av_always_inline void filter_common(uint8_t *p, int stride, int is4tap)
+{
+    LOAD_PIXELS
+    int a, f1, f2;
+    uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;
+
+    a = 3*(q0 - p0);
+
+    if (is4tap)
+        a += clip_int8(p1 - q1);
+
+    a = clip_int8(a);
+
+    // We deviate from the spec here with c(a+3) &gt;&gt; 3
+    // since that's what libvpx does.
+    f1 = FFMIN(a+4, 127) &gt;&gt; 3;
+    f2 = FFMIN(a+3, 127) &gt;&gt; 3;
+
+    // Despite what the spec says, we do need to clamp here to
+    // be bitexact with libvpx.
+    p[-1*stride] = cm[p0 + f2];
+    p[ 0*stride] = cm[q0 - f1];
+
+    // only used for _inner on blocks without high edge variance
+    if (!is4tap) {
+        a = (f1+1)&gt;&gt;1;
+        p[-2*stride] = cm[p1 + a];
+        p[ 1*stride] = cm[q1 - a];
+    }
+}
+
+static av_always_inline int simple_limit(uint8_t *p, int stride, int flim)
+{
+    LOAD_PIXELS
+    return 2*FFABS(p0-q0) + (FFABS(p1-q1) &gt;&gt; 1) &lt;= flim;
+}
+
+/**
+ * E - limit at the macroblock edge
+ * I - limit for interior difference
+ */
+static av_always_inline int normal_limit(uint8_t *p, int stride, int E, int I)
+{
+    LOAD_PIXELS
+    return simple_limit(p, stride, E)
+        &amp;&amp; FFABS(p3-p2) &lt;= I &amp;&amp; FFABS(p2-p1) &lt;= I &amp;&amp; FFABS(p1-p0) &lt;= I
+        &amp;&amp; FFABS(q3-q2) &lt;= I &amp;&amp; FFABS(q2-q1) &lt;= I &amp;&amp; FFABS(q1-q0) &lt;= I;
+}
+
+// high edge variance
+static av_always_inline int hev(uint8_t *p, int stride, int thresh)
+{
+    LOAD_PIXELS
+    return FFABS(p1-p0) &gt; thresh || FFABS(q1-q0) &gt; thresh;
+}
+
+static av_always_inline void filter_mbedge(uint8_t *p, int stride)
+{
+    int a0, a1, a2, w;
+    uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;
+
+    LOAD_PIXELS
+
+    w = clip_int8(p1-q1);
+    w = clip_int8(w + 3*(q0-p0));
+
+    a0 = (27*w + 63) &gt;&gt; 7;
+    a1 = (18*w + 63) &gt;&gt; 7;
+    a2 = ( 9*w + 63) &gt;&gt; 7;
+
+    p[-3*stride] = cm[p2 + a2];
+    p[-2*stride] = cm[p1 + a1];
+    p[-1*stride] = cm[p0 + a0];
+    p[ 0*stride] = cm[q0 - a0];
+    p[ 1*stride] = cm[q1 - a1];
+    p[ 2*stride] = cm[q2 - a2];
+}
+
+#define LOOP_FILTER(dir, size, stridea, strideb, maybe_inline) \
+static maybe_inline void vp8_ ## dir ## _loop_filter ## size ## _c(uint8_t *dst, int stride,\
+                                     int flim_E, int flim_I, int hev_thresh)\
+{\
+    int i;\
+\
+    for (i = 0; i &lt; size; i++)\
+        if (normal_limit(dst+i*stridea, strideb, flim_E, flim_I)) {\
+            if (hev(dst+i*stridea, strideb, hev_thresh))\
+                filter_common(dst+i*stridea, strideb, 1);\
+            else\
+                filter_mbedge(dst+i*stridea, strideb);\
+        }\
+}\
+\
+static maybe_inline void vp8_ ## dir ## _loop_filter ## size ## _inner_c(uint8_t *dst, int stride,\
+                                      int flim_E, int flim_I, int hev_thresh)\
+{\
+    int i;\
+\
+    for (i = 0; i &lt; size; i++)\
+        if (normal_limit(dst+i*stridea, strideb, flim_E, flim_I)) {\
+            int hv = hev(dst+i*stridea, strideb, hev_thresh);\
+            if (hv) \
+                filter_common(dst+i*stridea, strideb, 1);\
+            else \
+                filter_common(dst+i*stridea, strideb, 0);\
+        }\
+}
+
+LOOP_FILTER(v, 16, 1, stride,)
+LOOP_FILTER(h, 16, stride, 1,)
+
+#define UV_LOOP_FILTER(dir, stridea, strideb) \
+LOOP_FILTER(dir, 8, stridea, strideb, av_always_inline) \
+static void vp8_ ## dir ## _loop_filter8uv_c(uint8_t *dstU, uint8_t *dstV, int stride,\
+                                      int fE, int fI, int hev_thresh)\
+{\
+  vp8_ ## dir ## _loop_filter8_c(dstU, stride, fE, fI, hev_thresh);\
+  vp8_ ## dir ## _loop_filter8_c(dstV, stride, fE, fI, hev_thresh);\
+}\
+static void vp8_ ## dir ## _loop_filter8uv_inner_c(uint8_t *dstU, uint8_t *dstV, int stride,\
+                                      int fE, int fI, int hev_thresh)\
+{\
+  vp8_ ## dir ## _loop_filter8_inner_c(dstU, stride, fE, fI, hev_thresh);\
+  vp8_ ## dir ## _loop_filter8_inner_c(dstV, stride, fE, fI, hev_thresh);\
+}
+
+UV_LOOP_FILTER(v, 1, stride)
+UV_LOOP_FILTER(h, stride, 1)
+
+static void vp8_v_loop_filter_simple_c(uint8_t *dst, int stride, int flim)
+{
+    int i;
+
+    for (i = 0; i &lt; 16; i++)
+        if (simple_limit(dst+i, stride, flim))
+            filter_common(dst+i, stride, 1);
+}
+
+static void vp8_h_loop_filter_simple_c(uint8_t *dst, int stride, int flim)
+{
+    int i;
+
+    for (i = 0; i &lt; 16; i++)
+        if (simple_limit(dst+i*stride, 1, flim))
+            filter_common(dst+i*stride, 1, 1);
+}
+
+static const uint8_t subpel_filters[7][6] = {
+    { 0,   6, 123,  12,   1,   0 },
+    { 2,  11, 108,  36,   8,   1 },
+    { 0,   9,  93,  50,   6,   0 },
+    { 3,  16,  77,  77,  16,   3 },
+    { 0,   6,  50,  93,   9,   0 },
+    { 1,   8,  36, 108,  11,   2 },
+    { 0,   1,  12, 123,   6,   0 },
+};
+
+#define PUT_PIXELS(WIDTH) \
+static void put_vp8_pixels ## WIDTH ##_c(uint8_t *dst, int dststride, uint8_t *src, int srcstride, int h, int x, int y) { \
+    int i; \
+    for (i = 0; i &lt; h; i++, dst+= dststride, src+= srcstride) { \
+        memcpy(dst, src, WIDTH); \
+    } \
+}
+
+PUT_PIXELS(16)
+PUT_PIXELS(8)
+PUT_PIXELS(4)
+
+#define FILTER_6TAP(src, F, stride) \
+    cm[(F[2]*src[x+0*stride] - F[1]*src[x-1*stride] + F[0]*src[x-2*stride] + \
+        F[3]*src[x+1*stride] - F[4]*src[x+2*stride] + F[5]*src[x+3*stride] + 64) &gt;&gt; 7]
+
+#define FILTER_4TAP(src, F, stride) \
+    cm[(F[2]*src[x+0*stride] - F[1]*src[x-1*stride] + \
+        F[3]*src[x+1*stride] - F[4]*src[x+2*stride] + 64) &gt;&gt; 7]
+
+#define VP8_EPEL_H(SIZE, FILTER, FILTERNAME) \
+static void put_vp8_epel ## SIZE ## _ ## FILTERNAME ## _c(uint8_t *dst, int dststride, uint8_t *src, int srcstride, int h, int mx, int my) \
+{ \
+    const uint8_t *filter = subpel_filters[mx-1]; \
+    uint8_t *cm = ff_cropTbl + MAX_NEG_CROP; \
+    int x, y; \
+\
+    for (y = 0; y &lt; h; y++) { \
+        for (x = 0; x &lt; SIZE; x++) \
+            dst[x] = FILTER(src, filter, 1); \
+        dst += dststride; \
+        src += srcstride; \
+    } \
+}
+#define VP8_EPEL_V(SIZE, FILTER, FILTERNAME) \
+static void put_vp8_epel ## SIZE ## _ ## FILTERNAME ## _c(uint8_t *dst, int dststride, uint8_t *src, int srcstride, int h, int mx, int my) \
+{ \
+    const uint8_t *filter = subpel_filters[my-1]; \
+    uint8_t *cm = ff_cropTbl + MAX_NEG_CROP; \
+    int x, y; \
+\
+    for (y = 0; y &lt; h; y++) { \
+        for (x = 0; x &lt; SIZE; x++) \
+            dst[x] = FILTER(src, filter, srcstride); \
+        dst += dststride; \
+        src += srcstride; \
+    } \
+}
+#define VP8_EPEL_HV(SIZE, FILTERX, FILTERY, FILTERNAME) \
+static void put_vp8_epel ## SIZE ## _ ## FILTERNAME ## _c(uint8_t *dst, int dststride, uint8_t *src, int srcstride, int h, int mx, int my) \
+{ \
+    const uint8_t *filter = subpel_filters[mx-1]; \
+    uint8_t *cm = ff_cropTbl + MAX_NEG_CROP; \
+    int x, y; \
+    uint8_t tmp_array[(2*SIZE+5)*SIZE]; \
+    uint8_t *tmp = tmp_array; \
+    src -= 2*srcstride; \
+\
+    for (y = 0; y &lt; h+5; y++) { \
+        for (x = 0; x &lt; SIZE; x++) \
+            tmp[x] = FILTERX(src, filter, 1); \
+        tmp += SIZE; \
+        src += srcstride; \
+    } \
+\
+    tmp = tmp_array + 2*SIZE; \
+    filter = subpel_filters[my-1]; \
+\
+    for (y = 0; y &lt; h; y++) { \
+        for (x = 0; x &lt; SIZE; x++) \
+            dst[x] = FILTERY(tmp, filter, SIZE); \
+        dst += dststride; \
+        tmp += SIZE; \
+    } \
+}
+
+VP8_EPEL_H(16, FILTER_4TAP, h4)
+VP8_EPEL_H(8,  FILTER_4TAP, h4)
+VP8_EPEL_H(4,  FILTER_4TAP, h4)
+VP8_EPEL_H(16, FILTER_6TAP, h6)
+VP8_EPEL_H(8,  FILTER_6TAP, h6)
+VP8_EPEL_H(4,  FILTER_6TAP, h6)
+VP8_EPEL_V(16, FILTER_4TAP, v4)
+VP8_EPEL_V(8,  FILTER_4TAP, v4)
+VP8_EPEL_V(4,  FILTER_4TAP, v4)
+VP8_EPEL_V(16, FILTER_6TAP, v6)
+VP8_EPEL_V(8,  FILTER_6TAP, v6)
+VP8_EPEL_V(4,  FILTER_6TAP, v6)
+VP8_EPEL_HV(16, FILTER_4TAP, FILTER_4TAP, h4v4)
+VP8_EPEL_HV(8,  FILTER_4TAP, FILTER_4TAP, h4v4)
+VP8_EPEL_HV(4,  FILTER_4TAP, FILTER_4TAP, h4v4)
+VP8_EPEL_HV(16, FILTER_4TAP, FILTER_6TAP, h4v6)
+VP8_EPEL_HV(8,  FILTER_4TAP, FILTER_6TAP, h4v6)
+VP8_EPEL_HV(4,  FILTER_4TAP, FILTER_6TAP, h4v6)
+VP8_EPEL_HV(16, FILTER_6TAP, FILTER_4TAP, h6v4)
+VP8_EPEL_HV(8,  FILTER_6TAP, FILTER_4TAP, h6v4)
+VP8_EPEL_HV(4,  FILTER_6TAP, FILTER_4TAP, h6v4)
+VP8_EPEL_HV(16, FILTER_6TAP, FILTER_6TAP, h6v6)
+VP8_EPEL_HV(8,  FILTER_6TAP, FILTER_6TAP, h6v6)
+VP8_EPEL_HV(4,  FILTER_6TAP, FILTER_6TAP, h6v6)
+
+#define VP8_BILINEAR(SIZE) \
+static void put_vp8_bilinear ## SIZE ## _h_c(uint8_t *dst, int stride, uint8_t *src, int s2, int h, int mx, int my) \
+{ \
+    int a = 8-mx, b = mx; \
+    int x, y; \
+\
+    for (y = 0; y &lt; h; y++) { \
+        for (x = 0; x &lt; SIZE; x++) \
+            dst[x] = (a*src[x] + b*src[x+1] + 4) &gt;&gt; 3; \
+        dst += stride; \
+        src += stride; \
+    } \
+} \
+static void put_vp8_bilinear ## SIZE ## _v_c(uint8_t *dst, int stride, uint8_t *src, int s2, int h, int mx, int my) \
+{ \
+    int c = 8-my, d = my; \
+    int x, y; \
+\
+    for (y = 0; y &lt; h; y++) { \
+        for (x = 0; x &lt; SIZE; x++) \
+            dst[x] = (c*src[x] + d*src[x+stride] + 4) &gt;&gt; 3; \
+        dst += stride; \
+        src += stride; \
+    } \
+} \
+\
+static void put_vp8_bilinear ## SIZE ## _hv_c(uint8_t *dst, int stride, uint8_t *src, int s2, int h, int mx, int my) \
+{ \
+    int a = 8-mx, b = mx; \
+    int c = 8-my, d = my; \
+    int x, y; \
+    uint8_t tmp_array[(2*SIZE+1)*SIZE]; \
+    uint8_t *tmp = tmp_array; \
+\
+    for (y = 0; y &lt; h+1; y++) { \
+        for (x = 0; x &lt; SIZE; x++) \
+            tmp[x] = (a*src[x] + b*src[x+1] + 4) &gt;&gt; 3; \
+        tmp += SIZE; \
+        src += stride; \
+    } \
+\
+    tmp = tmp_array; \
+\
+    for (y = 0; y &lt; h; y++) { \
+        for (x = 0; x &lt; SIZE; x++) \
+            dst[x] = (c*tmp[x] + d*tmp[x+SIZE] + 4) &gt;&gt; 3; \
+        dst += stride; \
+        tmp += SIZE; \
+    } \
+}
+
+VP8_BILINEAR(16)
+VP8_BILINEAR(8)
+VP8_BILINEAR(4)
+
+#define VP8_MC_FUNC(IDX, SIZE) \
+    dsp-&gt;put_vp8_epel_pixels_tab[IDX][0][0] = put_vp8_pixels ## SIZE ## _c; \
+    dsp-&gt;put_vp8_epel_pixels_tab[IDX][0][1] = put_vp8_epel ## SIZE ## _h4_c; \
+    dsp-&gt;put_vp8_epel_pixels_tab[IDX][0][2] = put_vp8_epel ## SIZE ## _h6_c; \
+    dsp-&gt;put_vp8_epel_pixels_tab[IDX][1][0] = put_vp8_epel ## SIZE ## _v4_c; \
+    dsp-&gt;put_vp8_epel_pixels_tab[IDX][1][1] = put_vp8_epel ## SIZE ## _h4v4_c; \
+    dsp-&gt;put_vp8_epel_pixels_tab[IDX][1][2] = put_vp8_epel ## SIZE ## _h6v4_c; \
+    dsp-&gt;put_vp8_epel_pixels_tab[IDX][2][0] = put_vp8_epel ## SIZE ## _v6_c; \
+    dsp-&gt;put_vp8_epel_pixels_tab[IDX][2][1] = put_vp8_epel ## SIZE ## _h4v6_c; \
+    dsp-&gt;put_vp8_epel_pixels_tab[IDX][2][2] = put_vp8_epel ## SIZE ## _h6v6_c
+
+#define VP8_BILINEAR_MC_FUNC(IDX, SIZE) \
+    dsp-&gt;put_vp8_bilinear_pixels_tab[IDX][0][0] = put_vp8_pixels ## SIZE ## _c; \
+    dsp-&gt;put_vp8_bilinear_pixels_tab[IDX][0][1] = put_vp8_bilinear ## SIZE ## _h_c; \
+    dsp-&gt;put_vp8_bilinear_pixels_tab[IDX][0][2] = put_vp8_bilinear ## SIZE ## _h_c; \
+    dsp-&gt;put_vp8_bilinear_pixels_tab[IDX][1][0] = put_vp8_bilinear ## SIZE ## _v_c; \
+    dsp-&gt;put_vp8_bilinear_pixels_tab[IDX][1][1] = put_vp8_bilinear ## SIZE ## _hv_c; \
+    dsp-&gt;put_vp8_bilinear_pixels_tab[IDX][1][2] = put_vp8_bilinear ## SIZE ## _hv_c; \
+    dsp-&gt;put_vp8_bilinear_pixels_tab[IDX][2][0] = put_vp8_bilinear ## SIZE ## _v_c; \
+    dsp-&gt;put_vp8_bilinear_pixels_tab[IDX][2][1] = put_vp8_bilinear ## SIZE ## _hv_c; \
+    dsp-&gt;put_vp8_bilinear_pixels_tab[IDX][2][2] = put_vp8_bilinear ## SIZE ## _hv_c
+
+av_cold void ff_vp8dsp_init(VP8DSPContext *dsp)
+{
+    dsp-&gt;vp8_luma_dc_wht    = vp8_luma_dc_wht_c;
+    dsp-&gt;vp8_idct_add       = vp8_idct_add_c;
+    dsp-&gt;vp8_idct_dc_add    = vp8_idct_dc_add_c;
+    dsp-&gt;vp8_idct_dc_add4y  = vp8_idct_dc_add4y_c;
+    dsp-&gt;vp8_idct_dc_add4uv = vp8_idct_dc_add4uv_c;
+
+    dsp-&gt;vp8_v_loop_filter16y = vp8_v_loop_filter16_c;
+    dsp-&gt;vp8_h_loop_filter16y = vp8_h_loop_filter16_c;
+    dsp-&gt;vp8_v_loop_filter8uv = vp8_v_loop_filter8uv_c;
+    dsp-&gt;vp8_h_loop_filter8uv = vp8_h_loop_filter8uv_c;
+
+    dsp-&gt;vp8_v_loop_filter16y_inner = vp8_v_loop_filter16_inner_c;
+    dsp-&gt;vp8_h_loop_filter16y_inner = vp8_h_loop_filter16_inner_c;
+    dsp-&gt;vp8_v_loop_filter8uv_inner = vp8_v_loop_filter8uv_inner_c;
+    dsp-&gt;vp8_h_loop_filter8uv_inner = vp8_h_loop_filter8uv_inner_c;
+
+    dsp-&gt;vp8_v_loop_filter_simple = vp8_v_loop_filter_simple_c;
+    dsp-&gt;vp8_h_loop_filter_simple = vp8_h_loop_filter_simple_c;
+
+    VP8_MC_FUNC(0, 16);
+    VP8_MC_FUNC(1, 8);
+    VP8_MC_FUNC(2, 4);
+
+    VP8_BILINEAR_MC_FUNC(0, 16);
+    VP8_BILINEAR_MC_FUNC(1, 8);
+    VP8_BILINEAR_MC_FUNC(2, 4);
+
+    if (HAVE_MMX)
+        ff_vp8dsp_init_x86(dsp);
+    if (HAVE_ALTIVEC)
+        ff_vp8dsp_init_altivec(dsp);
+}

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/vp8dsp.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/vp8dsp.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/vp8dsp.h	2010-07-25 10:07:39 UTC (rev 6478)
@@ -0,0 +1,82 @@
+/**
+ * VP8 compatible video decoder
+ *
+ * Copyright (C) 2010 David Conrad
+ * Copyright (C) 2010 Ronald S. Bultje
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+
+#ifndef AVCODEC_VP8DSP_H
+#define AVCODEC_VP8DSP_H
+
+#include &quot;dsputil.h&quot;
+
+typedef void (*vp8_mc_func)(uint8_t *dst/*align 8*/, int dstStride, uint8_t *src/*align 1*/, int srcStride, int h, int x, int y);
+
+typedef struct VP8DSPContext {
+    void (*vp8_luma_dc_wht)(DCTELEM block[4][4][16], DCTELEM dc[16]);
+    void (*vp8_idct_add)(uint8_t *dst, DCTELEM block[16], int stride);
+    void (*vp8_idct_dc_add)(uint8_t *dst, DCTELEM block[16], int stride);
+    void (*vp8_idct_dc_add4y)(uint8_t *dst, DCTELEM block[4][16], int stride);
+    void (*vp8_idct_dc_add4uv)(uint8_t *dst, DCTELEM block[4][16], int stride);
+
+    // loop filter applied to edges between macroblocks
+    void (*vp8_v_loop_filter16y)(uint8_t *dst, int stride,
+                                 int flim_E, int flim_I, int hev_thresh);
+    void (*vp8_h_loop_filter16y)(uint8_t *dst, int stride,
+                                 int flim_E, int flim_I, int hev_thresh);
+    void (*vp8_v_loop_filter8uv)(uint8_t *dstU, uint8_t *dstV, int stride,
+                                 int flim_E, int flim_I, int hev_thresh);
+    void (*vp8_h_loop_filter8uv)(uint8_t *dstU, uint8_t *dstV, int stride,
+                                 int flim_E, int flim_I, int hev_thresh);
+
+    // loop filter applied to inner macroblock edges
+    void (*vp8_v_loop_filter16y_inner)(uint8_t *dst, int stride,
+                                       int flim_E, int flim_I, int hev_thresh);
+    void (*vp8_h_loop_filter16y_inner)(uint8_t *dst, int stride,
+                                       int flim_E, int flim_I, int hev_thresh);
+    void (*vp8_v_loop_filter8uv_inner)(uint8_t *dstU, uint8_t *dstV, int stride,
+                                       int flim_E, int flim_I, int hev_thresh);
+    void (*vp8_h_loop_filter8uv_inner)(uint8_t *dstU, uint8_t *dstV, int stride,
+                                       int flim_E, int flim_I, int hev_thresh);
+
+    void (*vp8_v_loop_filter_simple)(uint8_t *dst, int stride, int flim);
+    void (*vp8_h_loop_filter_simple)(uint8_t *dst, int stride, int flim);
+
+    /**
+     * first dimension: width&gt;&gt;3, height is assumed equal to width
+     * second dimension: 0 if no vertical interpolation is needed;
+     *                   1 4-tap vertical interpolation filter (my &amp; 1)
+     *                   2 6-tap vertical interpolation filter (!(my &amp; 1))
+     * third dimension: same as second dimention, for horizontal interpolation
+     * so something like put_vp8_epel_pixels_tab[width&gt;&gt;3][2*!!my-(my&amp;1)][2*!!mx-(mx&amp;1)](..., mx, my)
+     */
+    vp8_mc_func put_vp8_epel_pixels_tab[3][3][3];
+    vp8_mc_func put_vp8_bilinear_pixels_tab[3][3][3];
+} VP8DSPContext;
+
+void ff_put_vp8_pixels16_c(uint8_t *dst, uint8_t *src, int stride, int h, int x, int y);
+void ff_put_vp8_pixels8_c(uint8_t *dst, uint8_t *src, int stride, int h, int x, int y);
+void ff_put_vp8_pixels4_c(uint8_t *dst, uint8_t *src, int stride, int h, int x, int y);
+
+void ff_vp8dsp_init(VP8DSPContext *c);
+void ff_vp8dsp_init_x86(VP8DSPContext *c);
+void ff_vp8dsp_init_altivec(VP8DSPContext *c);
+
+#endif /* AVCODEC_VP8DSP_H */

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/x86/dct32_sse.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/x86/dct32_sse.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/x86/dct32_sse.c	2010-07-25 10:07:39 UTC (rev 6478)
@@ -0,0 +1,294 @@
+/*
+ * 32 point SSE-optimized DCT transform
+ * Copyright (c) 2010 Vitor Sessak
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include &lt;stdint.h&gt;
+
+#include &quot;libavutil/x86_cpu.h&quot;
+#include &quot;libavutil/mem.h&quot;
+#include &quot;libavcodec/dsputil.h&quot;
+#include &quot;fft.h&quot;
+
+DECLARE_ALIGNED(16, static const float, b1)[] = {
+     0.500603,  0.505471,  0.515447,  0.531043,
+     0.553104,  0.582935,  0.622504,  0.674808,
+    -1.169440, -0.972568, -0.839350, -0.744536,
+   -10.190008, -3.407609, -2.057781, -1.484165,
+     0.502419,  0.522499,  0.566944,  0.646822,
+     0.788155,  1.060678,  1.722447,  5.101149,
+     0.509796,  0.601345,  0.899976,  2.562916,
+     1.000000,  1.000000,  1.306563,  0.541196,
+     1.000000,  0.707107,  1.000000, -0.707107
+};
+
+DECLARE_ALIGNED(16, static const int32_t, smask)[4] = {
+    0, 0, 0x80000000, 0x80000000
+};
+
+/* butterfly operator */
+#define BUTTERFLY(a,b,c,tmp)                            \
+    &quot;movaps  %%&quot; #a    &quot;, %%&quot; #tmp  &quot;             \n\t&quot; \
+    &quot;subps   %%&quot; #b    &quot;, %%&quot; #a    &quot;             \n\t&quot; \
+    &quot;addps   %%&quot; #tmp  &quot;, %%&quot; #b    &quot;             \n\t&quot; \
+    &quot;mulps     &quot; #c    &quot;, %%&quot; #a    &quot;             \n\t&quot;
+
+///* Same as BUTTERFLY when vectors a and b overlap */
+#define BUTTERFLY0(val, mask, cos, tmp, shuf)                            \
+    &quot;movaps  %%&quot; #val  &quot;, %%&quot; #tmp  &quot;             \n\t&quot;                  \
+    &quot;shufps    &quot; #shuf &quot;, %%&quot; #val  &quot;,%%&quot; #val &quot;  \n\t&quot;                  \
+    &quot;xorps   %%&quot; #mask &quot;, %%&quot; #tmp  &quot;             \n\t&quot; /* flip signs */ \
+    &quot;addps   %%&quot; #tmp  &quot;, %%&quot; #val  &quot;             \n\t&quot;                  \
+    &quot;mulps   %%&quot; #cos  &quot;, %%&quot; #val  &quot;             \n\t&quot;
+
+#define BUTTERFLY2(val, mask, cos, tmp) BUTTERFLY0(val, mask, cos, tmp, $0x1b)
+#define BUTTERFLY3(val, mask, cos, tmp) BUTTERFLY0(val, mask, cos, tmp, $0xb1)
+
+void ff_dct32_float_sse(FFTSample *out, const FFTSample *in)
+{
+    int32_t tmp1 = 0;
+    __asm__ volatile(
+        /* pass 1 */
+
+        &quot;movaps    (%4), %%xmm0           \n\t&quot;
+        &quot;movaps 112(%4), %%xmm1           \n\t&quot;
+        &quot;shufps   $0x1b, %%xmm1, %%xmm1   \n\t&quot;
+        BUTTERFLY(xmm0, xmm1, (%2), xmm3)
+
+        &quot;movaps  64(%4), %%xmm7           \n\t&quot;
+        &quot;movaps  48(%4), %%xmm4           \n\t&quot;
+        &quot;shufps   $0x1b, %%xmm4, %%xmm4   \n\t&quot;
+        BUTTERFLY(xmm7, xmm4, 48(%2), xmm3)
+
+
+        /* pass 2 */
+        &quot;movaps  64(%2), %%xmm2           \n\t&quot;
+        BUTTERFLY(xmm1, xmm4, %%xmm2, xmm3)
+        &quot;movaps  %%xmm1, 48(%1)           \n\t&quot;
+        &quot;movaps  %%xmm4, (%1)             \n\t&quot;
+
+        /* pass 1 */
+        &quot;movaps  16(%4), %%xmm1           \n\t&quot;
+        &quot;movaps  96(%4), %%xmm6           \n\t&quot;
+        &quot;shufps   $0x1b, %%xmm6, %%xmm6   \n\t&quot;
+        BUTTERFLY(xmm1, xmm6, 16(%2), xmm3)
+
+        &quot;movaps  80(%4), %%xmm4           \n\t&quot;
+        &quot;movaps  32(%4), %%xmm5           \n\t&quot;
+        &quot;shufps   $0x1b, %%xmm5, %%xmm5   \n\t&quot;
+        BUTTERFLY(xmm4, xmm5, 32(%2), xmm3)
+
+        /* pass 2 */
+        BUTTERFLY(xmm0, xmm7, %%xmm2, xmm3)
+
+        &quot;movaps  80(%2), %%xmm2           \n\t&quot;
+        BUTTERFLY(xmm6, xmm5, %%xmm2, xmm3)
+
+        BUTTERFLY(xmm1, xmm4, %%xmm2, xmm3)
+
+        /* pass 3 */
+        &quot;movaps  96(%2), %%xmm2           \n\t&quot;
+        &quot;shufps   $0x1b, %%xmm1, %%xmm1   \n\t&quot;
+        BUTTERFLY(xmm0, xmm1, %%xmm2, xmm3)
+        &quot;movaps  %%xmm0, 112(%1)          \n\t&quot;
+        &quot;movaps  %%xmm1,  96(%1)          \n\t&quot;
+
+        &quot;movaps   0(%1), %%xmm0           \n\t&quot;
+        &quot;shufps   $0x1b, %%xmm5, %%xmm5   \n\t&quot;
+        BUTTERFLY(xmm0, xmm5, %%xmm2, xmm3)
+
+        &quot;movaps  48(%1), %%xmm1           \n\t&quot;
+        &quot;shufps   $0x1b, %%xmm6, %%xmm6   \n\t&quot;
+        BUTTERFLY(xmm1, xmm6, %%xmm2, xmm3)
+        &quot;movaps  %%xmm1,  48(%1)          \n\t&quot;
+
+        &quot;shufps   $0x1b, %%xmm4, %%xmm4   \n\t&quot;
+        BUTTERFLY(xmm7, xmm4, %%xmm2, xmm3)
+
+        /* pass 4 */
+        &quot;movaps    (%3), %%xmm3           \n\t&quot;
+        &quot;movaps 112(%2), %%xmm2           \n\t&quot;
+
+        BUTTERFLY2(xmm5, xmm3, xmm2, xmm1)
+
+        BUTTERFLY2(xmm0, xmm3, xmm2, xmm1)
+        &quot;movaps  %%xmm0, 16(%1)           \n\t&quot;
+
+        BUTTERFLY2(xmm6, xmm3, xmm2, xmm1)
+        &quot;movaps  %%xmm6, 32(%1)           \n\t&quot;
+
+        &quot;movaps  48(%1), %%xmm0           \n\t&quot;
+        BUTTERFLY2(xmm0, xmm3, xmm2, xmm1)
+        &quot;movaps  %%xmm0, 48(%1)           \n\t&quot;
+
+        BUTTERFLY2(xmm4, xmm3, xmm2, xmm1)
+
+        BUTTERFLY2(xmm7, xmm3, xmm2, xmm1)
+
+        &quot;movaps  96(%1), %%xmm6           \n\t&quot;
+        BUTTERFLY2(xmm6, xmm3, xmm2, xmm1)
+
+        &quot;movaps 112(%1), %%xmm0           \n\t&quot;
+        BUTTERFLY2(xmm0, xmm3, xmm2, xmm1)
+
+        /* pass 5 */
+        &quot;movaps 128(%2), %%xmm2           \n\t&quot;
+        &quot;shufps   $0xCC, %%xmm3,%%xmm3    \n\t&quot;
+
+        BUTTERFLY3(xmm5, xmm3, xmm2, xmm1)
+        &quot;movaps  %%xmm5, (%1)             \n\t&quot;
+
+        &quot;movaps  16(%1), %%xmm1           \n\t&quot;
+        BUTTERFLY3(xmm1, xmm3, xmm2, xmm5)
+        &quot;movaps  %%xmm1, 16(%1)           \n\t&quot;
+
+        BUTTERFLY3(xmm4, xmm3, xmm2, xmm5)
+        &quot;movaps  %%xmm4, 64(%1)           \n\t&quot;
+
+        BUTTERFLY3(xmm7, xmm3, xmm2, xmm5)
+        &quot;movaps  %%xmm7, 80(%1)           \n\t&quot;
+
+        &quot;movaps  32(%1), %%xmm5           \n\t&quot;
+        BUTTERFLY3(xmm5, xmm3, xmm2, xmm7)
+        &quot;movaps  %%xmm5, 32(%1)           \n\t&quot;
+
+        &quot;movaps  48(%1), %%xmm4           \n\t&quot;
+        BUTTERFLY3(xmm4, xmm3, xmm2, xmm7)
+        &quot;movaps  %%xmm4, 48(%1)           \n\t&quot;
+
+        BUTTERFLY3(xmm6, xmm3, xmm2, xmm7)
+        &quot;movaps  %%xmm6, 96(%1)           \n\t&quot;
+
+        BUTTERFLY3(xmm0, xmm3, xmm2, xmm7)
+        &quot;movaps  %%xmm0, 112(%1)          \n\t&quot;
+
+
+        /* pass 6, no SIMD... */
+        &quot;movss    56(%1),  %%xmm3           \n\t&quot;
+        &quot;movl      4(%1),      %0           \n\t&quot;
+        &quot;addss    60(%1),  %%xmm3           \n\t&quot;
+        &quot;movss    72(%1),  %%xmm7           \n\t&quot;
+        &quot;addss    %%xmm3,  %%xmm4           \n\t&quot;
+        &quot;movss    52(%1),  %%xmm2           \n\t&quot;
+        &quot;addss    %%xmm3,  %%xmm2           \n\t&quot;
+        &quot;movss    24(%1),  %%xmm3           \n\t&quot;
+        &quot;addss    28(%1),  %%xmm3           \n\t&quot;
+        &quot;addss    76(%1),  %%xmm7           \n\t&quot;
+        &quot;addss    %%xmm3,  %%xmm1           \n\t&quot;
+        &quot;addss    %%xmm4,  %%xmm5           \n\t&quot;
+        &quot;movss    %%xmm1,  16(%1)           \n\t&quot;
+        &quot;movss    20(%1),  %%xmm1           \n\t&quot;
+        &quot;addss    %%xmm3,  %%xmm1           \n\t&quot;
+        &quot;movss    40(%1),  %%xmm3           \n\t&quot;
+        &quot;movss    %%xmm1,  48(%1)           \n\t&quot;
+        &quot;addss    44(%1),  %%xmm3           \n\t&quot;
+        &quot;movss    20(%1),  %%xmm1           \n\t&quot;
+        &quot;addss    %%xmm3,  %%xmm4           \n\t&quot;
+        &quot;addss    %%xmm2,  %%xmm3           \n\t&quot;
+        &quot;addss    28(%1),  %%xmm1           \n\t&quot;
+        &quot;movss    %%xmm3,  40(%1)           \n\t&quot;
+        &quot;addss    36(%1),  %%xmm2           \n\t&quot;
+        &quot;movss     8(%1),  %%xmm3           \n\t&quot;
+        &quot;movss    %%xmm2,  56(%1)           \n\t&quot;
+        &quot;addss    12(%1),  %%xmm3           \n\t&quot;
+        &quot;movss    %%xmm5,   8(%1)           \n\t&quot;
+        &quot;movss    %%xmm3,  32(%1)           \n\t&quot;
+        &quot;movss    52(%1),  %%xmm2           \n\t&quot;
+        &quot;movss    80(%1),  %%xmm3           \n\t&quot;
+        &quot;movss   120(%1),  %%xmm5           \n\t&quot;
+        &quot;movss    %%xmm1,  80(%1)           \n\t&quot;
+        &quot;movss    %%xmm4,  24(%1)           \n\t&quot;
+        &quot;addss   124(%1),  %%xmm5           \n\t&quot;
+        &quot;movss    64(%1),  %%xmm1           \n\t&quot;
+        &quot;addss    60(%1),  %%xmm2           \n\t&quot;
+        &quot;addss    %%xmm5,  %%xmm0           \n\t&quot;
+        &quot;addss   116(%1),  %%xmm5           \n\t&quot;
+        &quot;movl         %0,  64(%1)           \n\t&quot;
+        &quot;addss    %%xmm0,  %%xmm6           \n\t&quot;
+        &quot;addss    %%xmm6,  %%xmm1           \n\t&quot;
+        &quot;movl     12(%1),      %0           \n\t&quot;
+        &quot;movss    %%xmm1,   4(%1)           \n\t&quot;
+        &quot;movss    88(%1),  %%xmm1           \n\t&quot;
+        &quot;movl         %0,  96(%1)           \n\t&quot;
+        &quot;addss    92(%1),  %%xmm1           \n\t&quot;
+        &quot;movss   104(%1),  %%xmm4           \n\t&quot;
+        &quot;movl     28(%1),      %0           \n\t&quot;
+        &quot;addss   108(%1),  %%xmm4           \n\t&quot;
+        &quot;addss    %%xmm4,  %%xmm0           \n\t&quot;
+        &quot;addss    %%xmm1,  %%xmm3           \n\t&quot;
+        &quot;addss    84(%1),  %%xmm1           \n\t&quot;
+        &quot;addss    %%xmm5,  %%xmm4           \n\t&quot;
+        &quot;addss    %%xmm3,  %%xmm6           \n\t&quot;
+        &quot;addss    %%xmm0,  %%xmm3           \n\t&quot;
+        &quot;addss    %%xmm7,  %%xmm0           \n\t&quot;
+        &quot;addss   100(%1),  %%xmm5           \n\t&quot;
+        &quot;addss    %%xmm4,  %%xmm7           \n\t&quot;
+        &quot;movl         %0, 112(%1)           \n\t&quot;
+        &quot;movss    %%xmm0,  28(%1)           \n\t&quot;
+        &quot;movss    36(%1),  %%xmm0           \n\t&quot;
+        &quot;movss    %%xmm7,  36(%1)           \n\t&quot;
+        &quot;addss    %%xmm1,  %%xmm4           \n\t&quot;
+        &quot;movss   116(%1),  %%xmm7           \n\t&quot;
+        &quot;addss    %%xmm2,  %%xmm0           \n\t&quot;
+        &quot;addss   124(%1),  %%xmm7           \n\t&quot;
+        &quot;movss    %%xmm0,  72(%1)           \n\t&quot;
+        &quot;movss    44(%1),  %%xmm0           \n\t&quot;
+        &quot;movss    %%xmm6,  12(%1)           \n\t&quot;
+        &quot;movss    %%xmm3,  20(%1)           \n\t&quot;
+        &quot;addss    %%xmm0,  %%xmm2           \n\t&quot;
+        &quot;movss    %%xmm4,  44(%1)           \n\t&quot;
+        &quot;movss    %%xmm2,  88(%1)           \n\t&quot;
+        &quot;addss    60(%1),  %%xmm0           \n\t&quot;
+        &quot;movl     60(%1),      %0           \n\t&quot;
+        &quot;movl         %0, 120(%1)           \n\t&quot;
+        &quot;movss    %%xmm0, 104(%1)           \n\t&quot;
+        &quot;addss    %%xmm5,  %%xmm1           \n\t&quot;
+        &quot;addss    68(%1),  %%xmm5           \n\t&quot;
+        &quot;movss    %%xmm1,  52(%1)           \n\t&quot;
+        &quot;movss    %%xmm5,  60(%1)           \n\t&quot;
+        &quot;movss    68(%1),  %%xmm1           \n\t&quot;
+        &quot;movss   100(%1),  %%xmm5           \n\t&quot;
+        &quot;addss    %%xmm7,  %%xmm5           \n\t&quot;
+        &quot;addss   108(%1),  %%xmm7           \n\t&quot;
+        &quot;addss    %%xmm5,  %%xmm1           \n\t&quot;
+        &quot;movss    84(%1),  %%xmm2           \n\t&quot;
+        &quot;addss    92(%1),  %%xmm2           \n\t&quot;
+        &quot;addss    %%xmm2,  %%xmm5           \n\t&quot;
+        &quot;movss    %%xmm1,  68(%1)           \n\t&quot;
+        &quot;addss    %%xmm7,  %%xmm2           \n\t&quot;
+        &quot;movss    76(%1),  %%xmm1           \n\t&quot;
+        &quot;movss    %%xmm2,  84(%1)           \n\t&quot;
+        &quot;movss    %%xmm5,  76(%1)           \n\t&quot;
+        &quot;movss   108(%1),  %%xmm2           \n\t&quot;
+        &quot;addss    %%xmm1,  %%xmm7           \n\t&quot;
+        &quot;addss   124(%1),  %%xmm2           \n\t&quot;
+        &quot;addss    %%xmm2,  %%xmm1           \n\t&quot;
+        &quot;addss    92(%1),  %%xmm2           \n\t&quot;
+        &quot;movss    %%xmm1, 100(%1)           \n\t&quot;
+        &quot;movss    %%xmm2, 108(%1)           \n\t&quot;
+        &quot;movss    92(%1),  %%xmm2           \n\t&quot;
+        &quot;movss    %%xmm7,  92(%1)           \n\t&quot;
+        &quot;addss   124(%1),  %%xmm2           \n\t&quot;
+        &quot;movss    %%xmm2, 116(%1)           \n\t&quot;
+        :&quot;+&amp;r&quot;(tmp1)
+        :&quot;r&quot;(out), &quot;r&quot;(b1), &quot;r&quot;(smask), &quot;r&quot;(in)
+        :&quot;memory&quot;
+        );
+}
+

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/x86/h264_intrapred.asm
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/x86/h264_intrapred.asm	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/x86/h264_intrapred.asm	2010-07-25 10:07:39 UTC (rev 6478)
@@ -0,0 +1,602 @@
+;******************************************************************************
+;* H.264 intra prediction asm optimizations
+;* Copyright (c) 2010 Jason Garrett-Glaser
+;*
+;* This file is part of FFmpeg.
+;*
+;* FFmpeg is free software; you can redistribute it and/or
+;* modify it under the terms of the GNU Lesser General Public
+;* License as published by the Free Software Foundation; either
+;* version 2.1 of the License, or (at your option) any later version.
+;*
+;* FFmpeg is distributed in the hope that it will be useful,
+;* but WITHOUT ANY WARRANTY; without even the implied warranty of
+;* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+;* Lesser General Public License for more details.
+;*
+;* You should have received a copy of the GNU Lesser General Public
+;* License along with FFmpeg; if not, write to the Free Software
+;* 51, Inc., Foundation Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+;******************************************************************************
+
+%include &quot;x86inc.asm&quot;
+
+SECTION_RODATA
+
+tm_shuf: times 8 db 0x03, 0x80
+
+SECTION .text
+
+cextern pb_1
+cextern pb_3
+
+;-----------------------------------------------------------------------------
+; void pred16x16_vertical(uint8_t *src, int stride)
+;-----------------------------------------------------------------------------
+
+cglobal pred16x16_vertical_mmx, 2,3
+    sub   r0, r1
+    mov   r2, 8
+    movq mm0, [r0+0]
+    movq mm1, [r0+8]
+.loop:
+    movq [r0+r1*1+0], mm0
+    movq [r0+r1*1+8], mm1
+    movq [r0+r1*2+0], mm0
+    movq [r0+r1*2+8], mm1
+    lea   r0, [r0+r1*2]
+    dec   r2
+    jg .loop
+    REP_RET
+
+cglobal pred16x16_vertical_sse, 2,3
+    sub   r0, r1
+    mov   r2, 4
+    movaps xmm0, [r0]
+.loop:
+    movaps [r0+r1*1], xmm0
+    movaps [r0+r1*2], xmm0
+    lea   r0, [r0+r1*2]
+    movaps [r0+r1*1], xmm0
+    movaps [r0+r1*2], xmm0
+    lea   r0, [r0+r1*2]
+    dec   r2
+    jg .loop
+    REP_RET
+
+;-----------------------------------------------------------------------------
+; void pred16x16_horizontal(uint8_t *src, int stride)
+;-----------------------------------------------------------------------------
+
+%macro PRED16x16_H 1
+cglobal pred16x16_horizontal_%1, 2,3
+    mov       r2, 8
+%ifidn %1, ssse3
+    mova      m2, [pb_3]
+%endif
+.loop:
+    movd      m0, [r0+r1*0-4]
+    movd      m1, [r0+r1*1-4]
+
+%ifidn %1, ssse3
+    pshufb    m0, m2
+    pshufb    m1, m2
+%else
+    punpcklbw m0, m0
+    punpcklbw m1, m1
+%ifidn %1, mmxext
+    pshufw    m0, m0, 0xff
+    pshufw    m1, m1, 0xff
+%else
+    punpckhwd m0, m0
+    punpckhwd m1, m1
+    punpckhdq m0, m0
+    punpckhdq m1, m1
+%endif
+    mova [r0+r1*0+8], m0
+    mova [r0+r1*1+8], m1
+%endif
+
+    mova [r0+r1*0], m0
+    mova [r0+r1*1], m1
+    lea       r0, [r0+r1*2]
+    dec       r2
+    jg .loop
+    REP_RET
+%endmacro
+
+INIT_MMX
+PRED16x16_H mmx
+PRED16x16_H mmxext
+INIT_XMM
+PRED16x16_H ssse3
+
+;-----------------------------------------------------------------------------
+; void pred16x16_dc(uint8_t *src, int stride)
+;-----------------------------------------------------------------------------
+
+%macro PRED16x16_DC 1
+cglobal pred16x16_dc_%1, 2,7
+    mov       r4, r0
+    sub       r0, r1
+    pxor      mm0, mm0
+    pxor      mm1, mm1
+    psadbw    mm0, [r0+0]
+    psadbw    mm1, [r0+8]
+    dec        r0
+    movzx     r5d, byte [r0+r1*1]
+    paddw     mm0, mm1
+    movd      r6d, mm0
+    lea        r0, [r0+r1*2]
+%rep 7
+    movzx     r2d, byte [r0+r1*0]
+    movzx     r3d, byte [r0+r1*1]
+    add       r5d, r2d
+    add       r6d, r3d
+    lea        r0, [r0+r1*2]
+%endrep
+    movzx     r2d, byte [r0+r1*0]
+    add       r5d, r6d
+    lea       r2d, [r2+r5+16]
+    shr       r2d, 5
+%ifidn %1, mmxext
+    movd       m0, r2d
+    punpcklbw  m0, m0
+    pshufw     m0, m0, 0
+%elifidn %1, sse2
+    movd       m0, r2d
+    punpcklbw  m0, m0
+    pshuflw    m0, m0, 0
+    punpcklqdq m0, m0
+%elifidn %1, ssse3
+    pxor       m1, m1
+    movd       m0, r2d
+    pshufb     m0, m1
+%endif
+
+%if mmsize==8
+    mov       r3d, 8
+.loop:
+    mova [r4+r1*0+0], m0
+    mova [r4+r1*0+8], m0
+    mova [r4+r1*1+0], m0
+    mova [r4+r1*1+8], m0
+%else
+    mov       r3d, 4
+.loop:
+    mova [r4+r1*0], m0
+    mova [r4+r1*1], m0
+    lea   r4, [r4+r1*2]
+    mova [r4+r1*0], m0
+    mova [r4+r1*1], m0
+%endif
+    lea   r4, [r4+r1*2]
+    dec   r3d
+    jg .loop
+    REP_RET
+%endmacro
+
+INIT_MMX
+PRED16x16_DC mmxext
+INIT_XMM
+PRED16x16_DC   sse2
+PRED16x16_DC  ssse3
+
+;-----------------------------------------------------------------------------
+; void pred16x16_tm_vp8(uint8_t *src, int stride)
+;-----------------------------------------------------------------------------
+
+%macro PRED16x16_TM_MMX 1
+cglobal pred16x16_tm_vp8_%1, 2,5
+    sub        r0, r1
+    pxor      mm7, mm7
+    movq      mm0, [r0+0]
+    movq      mm2, [r0+8]
+    movq      mm1, mm0
+    movq      mm3, mm2
+    punpcklbw mm0, mm7
+    punpckhbw mm1, mm7
+    punpcklbw mm2, mm7
+    punpckhbw mm3, mm7
+    movzx     r3d, byte [r0-1]
+    mov       r4d, 16
+.loop:
+    movzx     r2d, byte [r0+r1-1]
+    sub       r2d, r3d
+    movd      mm4, r2d
+%ifidn %1, mmx
+    punpcklwd mm4, mm4
+    punpckldq mm4, mm4
+%else
+    pshufw    mm4, mm4, 0
+%endif
+    movq      mm5, mm4
+    movq      mm6, mm4
+    movq      mm7, mm4
+    paddw     mm4, mm0
+    paddw     mm5, mm1
+    paddw     mm6, mm2
+    paddw     mm7, mm3
+    packuswb  mm4, mm5
+    packuswb  mm6, mm7
+    movq [r0+r1+0], mm4
+    movq [r0+r1+8], mm6
+    add        r0, r1
+    dec       r4d
+    jg .loop
+    REP_RET
+%endmacro
+
+PRED16x16_TM_MMX mmx
+PRED16x16_TM_MMX mmxext
+
+cglobal pred16x16_tm_vp8_sse2, 2,6,6
+    sub          r0, r1
+    pxor       xmm2, xmm2
+    movdqa     xmm0, [r0]
+    movdqa     xmm1, xmm0
+    punpcklbw  xmm0, xmm2
+    punpckhbw  xmm1, xmm2
+    movzx       r4d, byte [r0-1]
+    mov         r5d, 8
+.loop:
+    movzx       r2d, byte [r0+r1*1-1]
+    movzx       r3d, byte [r0+r1*2-1]
+    sub         r2d, r4d
+    sub         r3d, r4d
+    movd       xmm2, r2d
+    movd       xmm4, r3d
+    pshuflw    xmm2, xmm2, 0
+    pshuflw    xmm4, xmm4, 0
+    punpcklqdq xmm2, xmm2
+    punpcklqdq xmm4, xmm4
+    movdqa     xmm3, xmm2
+    movdqa     xmm5, xmm4
+    paddw      xmm2, xmm0
+    paddw      xmm3, xmm1
+    paddw      xmm4, xmm0
+    paddw      xmm5, xmm1
+    packuswb   xmm2, xmm3
+    packuswb   xmm4, xmm5
+    movdqa [r0+r1*1], xmm2
+    movdqa [r0+r1*2], xmm4
+    lea          r0, [r0+r1*2]
+    dec         r5d
+    jg .loop
+    REP_RET
+
+;-----------------------------------------------------------------------------
+; void pred8x8_vertical(uint8_t *src, int stride)
+;-----------------------------------------------------------------------------
+
+cglobal pred8x8_vertical_mmx, 2,2
+    sub    r0, r1
+    movq  mm0, [r0]
+%rep 3
+    movq [r0+r1*1], mm0
+    movq [r0+r1*2], mm0
+    lea    r0, [r0+r1*2]
+%endrep
+    movq [r0+r1*1], mm0
+    movq [r0+r1*2], mm0
+    RET
+
+;-----------------------------------------------------------------------------
+; void pred8x8_horizontal(uint8_t *src, int stride)
+;-----------------------------------------------------------------------------
+
+%macro PRED8x8_H 1
+cglobal pred8x8_horizontal_%1, 2,3
+    mov       r2, 4
+%ifidn %1, ssse3
+    mova      m2, [pb_3]
+%endif
+.loop:
+    movd      m0, [r0+r1*0-4]
+    movd      m1, [r0+r1*1-4]
+%ifidn %1, ssse3
+    pshufb    m0, m2
+    pshufb    m1, m2
+%else
+    punpcklbw m0, m0
+    punpcklbw m1, m1
+%ifidn %1, mmxext
+    pshufw    m0, m0, 0xff
+    pshufw    m1, m1, 0xff
+%else
+    punpckhwd m0, m0
+    punpckhwd m1, m1
+    punpckhdq m0, m0
+    punpckhdq m1, m1
+%endif
+%endif
+    mova [r0+r1*0], m0
+    mova [r0+r1*1], m1
+    lea       r0, [r0+r1*2]
+    dec       r2
+    jg .loop
+    REP_RET
+%endmacro
+
+INIT_MMX
+PRED8x8_H mmx
+PRED8x8_H mmxext
+PRED8x8_H ssse3
+
+;-----------------------------------------------------------------------------
+; void pred8x8_dc_rv40(uint8_t *src, int stride)
+;-----------------------------------------------------------------------------
+
+cglobal pred8x8_dc_rv40_mmxext, 2,7
+    mov       r4, r0
+    sub       r0, r1
+    pxor      mm0, mm0
+    psadbw    mm0, [r0]
+    dec        r0
+    movzx     r5d, byte [r0+r1*1]
+    movd      r6d, mm0
+    lea        r0, [r0+r1*2]
+%rep 3
+    movzx     r2d, byte [r0+r1*0]
+    movzx     r3d, byte [r0+r1*1]
+    add       r5d, r2d
+    add       r6d, r3d
+    lea        r0, [r0+r1*2]
+%endrep
+    movzx     r2d, byte [r0+r1*0]
+    add       r5d, r6d
+    lea       r2d, [r2+r5+8]
+    shr       r2d, 4
+    movd      mm0, r2d
+    punpcklbw mm0, mm0
+    pshufw    mm0, mm0, 0
+    mov       r3d, 4
+.loop:
+    movq [r4+r1*0], mm0
+    movq [r4+r1*1], mm0
+    lea   r4, [r4+r1*2]
+    dec   r3d
+    jg .loop
+    REP_RET
+
+;-----------------------------------------------------------------------------
+; void pred8x8_tm_vp8(uint8_t *src, int stride)
+;-----------------------------------------------------------------------------
+
+%macro PRED8x8_TM_MMX 1
+cglobal pred8x8_tm_vp8_%1, 2,6
+    sub        r0, r1
+    pxor      mm7, mm7
+    movq      mm0, [r0]
+    movq      mm1, mm0
+    punpcklbw mm0, mm7
+    punpckhbw mm1, mm7
+    movzx     r4d, byte [r0-1]
+    mov       r5d, 4
+.loop:
+    movzx     r2d, byte [r0+r1*1-1]
+    movzx     r3d, byte [r0+r1*2-1]
+    sub       r2d, r4d
+    sub       r3d, r4d
+    movd      mm2, r2d
+    movd      mm4, r3d
+%ifidn %1, mmx
+    punpcklwd mm2, mm2
+    punpcklwd mm4, mm4
+    punpckldq mm2, mm2
+    punpckldq mm4, mm4
+%else
+    pshufw    mm2, mm2, 0
+    pshufw    mm4, mm4, 0
+%endif
+    movq      mm3, mm2
+    movq      mm5, mm4
+    paddw     mm2, mm0
+    paddw     mm3, mm1
+    paddw     mm4, mm0
+    paddw     mm5, mm1
+    packuswb  mm2, mm3
+    packuswb  mm4, mm5
+    movq [r0+r1*1], mm2
+    movq [r0+r1*2], mm4
+    lea        r0, [r0+r1*2]
+    dec       r5d
+    jg .loop
+    REP_RET
+%endmacro
+
+PRED8x8_TM_MMX mmx
+PRED8x8_TM_MMX mmxext
+
+cglobal pred8x8_tm_vp8_sse2, 2,6,4
+    sub          r0, r1
+    pxor       xmm1, xmm1
+    movq       xmm0, [r0]
+    punpcklbw  xmm0, xmm1
+    movzx       r4d, byte [r0-1]
+    mov         r5d, 4
+.loop:
+    movzx       r2d, byte [r0+r1*1-1]
+    movzx       r3d, byte [r0+r1*2-1]
+    sub         r2d, r4d
+    sub         r3d, r4d
+    movd       xmm2, r2d
+    movd       xmm3, r3d
+    pshuflw    xmm2, xmm2, 0
+    pshuflw    xmm3, xmm3, 0
+    punpcklqdq xmm2, xmm2
+    punpcklqdq xmm3, xmm3
+    paddw      xmm2, xmm0
+    paddw      xmm3, xmm0
+    packuswb   xmm2, xmm3
+    movq   [r0+r1*1], xmm2
+    movhps [r0+r1*2], xmm2
+    lea          r0, [r0+r1*2]
+    dec         r5d
+    jg .loop
+    REP_RET
+
+cglobal pred8x8_tm_vp8_ssse3, 2,3,6
+    sub          r0, r1
+    movdqa     xmm4, [tm_shuf]
+    pxor       xmm1, xmm1
+    movq       xmm0, [r0]
+    punpcklbw  xmm0, xmm1
+    movd       xmm5, [r0-4]
+    pshufb     xmm5, xmm4
+    mov         r2d, 4
+.loop:
+    movd       xmm2, [r0+r1*1-4]
+    movd       xmm3, [r0+r1*2-4]
+    pshufb     xmm2, xmm4
+    pshufb     xmm3, xmm4
+    psubw      xmm2, xmm5
+    psubw      xmm3, xmm5
+    paddw      xmm2, xmm0
+    paddw      xmm3, xmm0
+    packuswb   xmm2, xmm3
+    movq   [r0+r1*1], xmm2
+    movhps [r0+r1*2], xmm2
+    lea          r0, [r0+r1*2]
+    dec         r2d
+    jg .loop
+    REP_RET
+
+;-----------------------------------------------------------------------------
+; void pred4x4_dc_mmxext(uint8_t *src, const uint8_t *topright, int stride)
+;-----------------------------------------------------------------------------
+
+cglobal pred4x4_dc_mmxext, 3,5
+    pxor   mm7, mm7
+    mov     r4, r0
+    sub     r0, r2
+    movd   mm0, [r0]
+    psadbw mm0, mm7
+    movzx  r1d, byte [r0+r2*1-1]
+    movd   r3d, mm0
+    add    r3d, r1d
+    movzx  r1d, byte [r0+r2*2-1]
+    lea     r0, [r0+r2*2]
+    add    r3d, r1d
+    movzx  r1d, byte [r0+r2*1-1]
+    add    r3d, r1d
+    movzx  r1d, byte [r0+r2*2-1]
+    add    r3d, r1d
+    add    r3d, 4
+    shr    r3d, 3
+    imul   r3d, 0x01010101
+    mov   [r4+r2*0], r3d
+    mov   [r0+r2*0], r3d
+    mov   [r0+r2*1], r3d
+    mov   [r0+r2*2], r3d
+    RET
+
+;-----------------------------------------------------------------------------
+; void pred4x4_tm_vp8_mmxext(uint8_t *src, const uint8_t *topright, int stride)
+;-----------------------------------------------------------------------------
+
+%macro PRED4x4_TM_MMX 1
+cglobal pred4x4_tm_vp8_%1, 3,6
+    sub        r0, r2
+    pxor      mm7, mm7
+    movd      mm0, [r0]
+    punpcklbw mm0, mm7
+    movzx     r4d, byte [r0-1]
+    mov       r5d, 2
+.loop:
+    movzx     r1d, byte [r0+r2*1-1]
+    movzx     r3d, byte [r0+r2*2-1]
+    sub       r1d, r4d
+    sub       r3d, r4d
+    movd      mm2, r1d
+    movd      mm4, r3d
+%ifidn %1, mmx
+    punpcklwd mm2, mm2
+    punpcklwd mm4, mm4
+    punpckldq mm2, mm2
+    punpckldq mm4, mm4
+%else
+    pshufw    mm2, mm2, 0
+    pshufw    mm4, mm4, 0
+%endif
+    paddw     mm2, mm0
+    paddw     mm4, mm0
+    packuswb  mm2, mm2
+    packuswb  mm4, mm4
+    movd [r0+r2*1], mm2
+    movd [r0+r2*2], mm4
+    lea        r0, [r0+r2*2]
+    dec       r5d
+    jg .loop
+    REP_RET
+%endmacro
+
+PRED4x4_TM_MMX mmx
+PRED4x4_TM_MMX mmxext
+
+cglobal pred4x4_tm_vp8_ssse3, 3,3
+    sub         r0, r2
+    movq       mm6, [tm_shuf]
+    pxor       mm1, mm1
+    movd       mm0, [r0]
+    punpcklbw  mm0, mm1
+    movd       mm7, [r0-4]
+    pshufb     mm7, mm6
+    lea         r1, [r0+r2*2]
+    movd       mm2, [r0+r2*1-4]
+    movd       mm3, [r0+r2*2-4]
+    movd       mm4, [r1+r2*1-4]
+    movd       mm5, [r1+r2*2-4]
+    pshufb     mm2, mm6
+    pshufb     mm3, mm6
+    pshufb     mm4, mm6
+    pshufb     mm5, mm6
+    psubw      mm2, mm7
+    psubw      mm3, mm7
+    psubw      mm4, mm7
+    psubw      mm5, mm7
+    paddw      mm2, mm0
+    paddw      mm3, mm0
+    paddw      mm4, mm0
+    paddw      mm5, mm0
+    packuswb   mm2, mm2
+    packuswb   mm3, mm3
+    packuswb   mm4, mm4
+    packuswb   mm5, mm5
+    movd [r0+r2*1], mm2
+    movd [r0+r2*2], mm3
+    movd [r1+r2*1], mm4
+    movd [r1+r2*2], mm5
+    RET
+
+; dest, left, right, src, tmp
+; output: %1 = (t[n-1] + t[n]*2 + t[n+1] + 2) &gt;&gt; 2
+%macro PRED4x4_LOWPASS 5
+    mova    %5, %2
+    pavgb   %2, %3
+    pxor    %3, %5
+    mova    %1, %4
+    pand    %3, [pb_1]
+    psubusb %2, %3
+    pavgb   %1, %2
+%endmacro
+
+;-----------------------------------------------------------------------------
+; void pred4x4_vertical_vp8_mmxext(uint8_t *src, const uint8_t *topright, int stride)
+;-----------------------------------------------------------------------------
+
+INIT_MMX
+cglobal pred4x4_vertical_vp8_mmxext, 3,3
+    sub       r0, r2
+    movd      m1, [r0-1]
+    movd      m0, [r0]
+    mova      m2, m0   ;t0 t1 t2 t3
+    punpckldq m0, [r1] ;t0 t1 t2 t3 t4 t5 t6 t7
+    lea       r1, [r0+r2*2]
+    psrlq     m0, 8    ;t1 t2 t3 t4
+    PRED4x4_LOWPASS m3, m1, m0, m2, m4
+    movd [r0+r2*1], m3
+    movd [r0+r2*2], m3
+    movd [r1+r2*1], m3
+    movd [r1+r2*2], m3
+    RET

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/x86/mpegaudiodec_mmx.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/x86/mpegaudiodec_mmx.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/x86/mpegaudiodec_mmx.c	2010-07-25 10:07:39 UTC (rev 6478)
@@ -0,0 +1,157 @@
+/*
+ * MMX optimized MP3 decoding functions
+ * Copyright (c) 2010 Vitor Sessak
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include &quot;libavutil/x86_cpu.h&quot;
+
+#define CONFIG_FLOAT 1
+#include &quot;libavcodec/mpegaudio.h&quot;
+
+#define MACS(rt, ra, rb) rt+=(ra)*(rb)
+#define MLSS(rt, ra, rb) rt-=(ra)*(rb)
+
+#define SUM8(op, sum, w, p)               \
+{                                         \
+    op(sum, (w)[0 * 64], (p)[0 * 64]);    \
+    op(sum, (w)[1 * 64], (p)[1 * 64]);    \
+    op(sum, (w)[2 * 64], (p)[2 * 64]);    \
+    op(sum, (w)[3 * 64], (p)[3 * 64]);    \
+    op(sum, (w)[4 * 64], (p)[4 * 64]);    \
+    op(sum, (w)[5 * 64], (p)[5 * 64]);    \
+    op(sum, (w)[6 * 64], (p)[6 * 64]);    \
+    op(sum, (w)[7 * 64], (p)[7 * 64]);    \
+}
+
+static void apply_window(const float *buf, const float *win1,
+                         const float *win2, float *sum1, float *sum2, int len)
+{
+    x86_reg count = - 4*len;
+    const float *win1a = win1+len;
+    const float *win2a = win2+len;
+    const float *bufa  = buf+len;
+    float *sum1a = sum1+len;
+    float *sum2a = sum2+len;
+
+
+#define MULT(a, b)                                 \
+    &quot;movaps &quot; #a &quot;(%1,%0), %%xmm1           \n\t&quot;  \
+    &quot;movaps &quot; #a &quot;(%3,%0), %%xmm2           \n\t&quot;  \
+    &quot;mulps         %%xmm2, %%xmm1           \n\t&quot;  \
+    &quot;subps         %%xmm1, %%xmm0           \n\t&quot;  \
+    &quot;mulps  &quot; #b &quot;(%2,%0), %%xmm2           \n\t&quot;  \
+    &quot;subps         %%xmm2, %%xmm4           \n\t&quot;  \
+
+    __asm__ volatile(
+            &quot;1:                                   \n\t&quot;
+            &quot;xorps       %%xmm0, %%xmm0           \n\t&quot;
+            &quot;xorps       %%xmm4, %%xmm4           \n\t&quot;
+
+            MULT(   0,   0)
+            MULT( 256,  64)
+            MULT( 512, 128)
+            MULT( 768, 192)
+            MULT(1024, 256)
+            MULT(1280, 320)
+            MULT(1536, 384)
+            MULT(1792, 448)
+
+            &quot;movaps      %%xmm0, (%4,%0)          \n\t&quot;
+            &quot;movaps      %%xmm4, (%5,%0)          \n\t&quot;
+            &quot;add            $16,  %0              \n\t&quot;
+            &quot;jl              1b                   \n\t&quot;
+            :&quot;+&amp;r&quot;(count)
+            :&quot;r&quot;(win1a), &quot;r&quot;(win2a), &quot;r&quot;(bufa), &quot;r&quot;(sum1a), &quot;r&quot;(sum2a)
+            );
+
+#undef MULT
+}
+
+static void apply_window_mp3(float *in, float *win, int *unused, float *out,
+                             int incr)
+{
+    LOCAL_ALIGNED_16(float, suma, [17]);
+    LOCAL_ALIGNED_16(float, sumb, [17]);
+    LOCAL_ALIGNED_16(float, sumc, [17]);
+    LOCAL_ALIGNED_16(float, sumd, [17]);
+
+    float sum;
+
+    /* copy to avoid wrap */
+    memcpy(in + 512, in, 32 * sizeof(*in));
+
+    apply_window(in + 16, win     , win + 512, suma, sumc, 16);
+    apply_window(in + 32, win + 48, win + 640, sumb, sumd, 16);
+
+    SUM8(MACS, suma[0], win + 32, in + 48);
+
+    sumc[ 0] = 0;
+    sumb[16] = 0;
+    sumd[16] = 0;
+
+#define SUMS(suma, sumb, sumc, sumd, out1, out2)               \
+            &quot;movups &quot; #sumd &quot;(%4),       %%xmm0          \n\t&quot; \
+            &quot;shufps         $0x1b,       %%xmm0, %%xmm0  \n\t&quot; \
+            &quot;subps  &quot; #suma &quot;(%1),       %%xmm0          \n\t&quot; \
+            &quot;movaps        %%xmm0,&quot; #out1 &quot;(%0)          \n\t&quot; \
+\
+            &quot;movups &quot; #sumc &quot;(%3),       %%xmm0          \n\t&quot; \
+            &quot;shufps         $0x1b,       %%xmm0, %%xmm0  \n\t&quot; \
+            &quot;addps  &quot; #sumb &quot;(%2),       %%xmm0          \n\t&quot; \
+            &quot;movaps        %%xmm0,&quot; #out2 &quot;(%0)          \n\t&quot;
+
+    if (incr == 1) {
+        __asm__ volatile(
+            SUMS( 0, 48,  4, 52,  0, 112)
+            SUMS(16, 32, 20, 36, 16,  96)
+            SUMS(32, 16, 36, 20, 32,  80)
+            SUMS(48,  0, 52,  4, 48,  64)
+
+            :&quot;+&amp;r&quot;(out)
+            :&quot;r&quot;(&amp;suma[0]), &quot;r&quot;(&amp;sumb[0]), &quot;r&quot;(&amp;sumc[0]), &quot;r&quot;(&amp;sumd[0])
+            :&quot;memory&quot;
+            );
+        out += 16*incr;
+    } else {
+        int j;
+        float *out2 = out + 32 * incr;
+        out[0  ]  = -suma[   0];
+        out += incr;
+        out2 -= incr;
+        for(j=1;j&lt;16;j++) {
+            *out  = -suma[   j] + sumd[16-j];
+            *out2 =  sumb[16-j] + sumc[   j];
+            out  += incr;
+            out2 -= incr;
+        }
+    }
+
+    sum = 0;
+    SUM8(MLSS, sum, win + 16 + 32, in + 32);
+    *out = sum;
+}
+
+void ff_mpegaudiodec_init_mmx(MPADecodeContext *s)
+{
+    mm_flags = mm_support();
+
+    if (mm_flags &amp; FF_MM_SSE2) {
+        s-&gt;apply_window_mp3 = apply_window_mp3;
+    }
+}

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/x86/vc1dsp_yasm.asm
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/x86/vc1dsp_yasm.asm	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/x86/vc1dsp_yasm.asm	2010-07-25 10:07:39 UTC (rev 6478)
@@ -0,0 +1,330 @@
+;******************************************************************************
+;* VC1 deblocking optimizations
+;* Copyright (c) 2009 David Conrad
+;*
+;* This file is part of FFmpeg.
+;*
+;* FFmpeg is free software; you can redistribute it and/or
+;* modify it under the terms of the GNU Lesser General Public
+;* License as published by the Free Software Foundation; either
+;* version 2.1 of the License, or (at your option) any later version.
+;*
+;* FFmpeg is distributed in the hope that it will be useful,
+;* but WITHOUT ANY WARRANTY; without even the implied warranty of
+;* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+;* Lesser General Public License for more details.
+;*
+;* You should have received a copy of the GNU Lesser General Public
+;* License along with FFmpeg; if not, write to the Free Software
+;* 51, Inc., Foundation Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+;******************************************************************************
+
+%include &quot;x86inc.asm&quot;
+%include &quot;x86util.asm&quot;
+
+cextern pw_4
+cextern pw_5
+
+section .text
+
+; dst_low, dst_high (src), zero
+; zero-extends one vector from 8 to 16 bits
+%macro UNPACK_8TO16 4
+    mova      m%2, m%3
+    punpckh%1 m%3, m%4
+    punpckl%1 m%2, m%4
+%endmacro
+
+%macro STORE_4_WORDS_MMX 6
+    movd   %6, %5
+%if mmsize==16
+    psrldq %5, 4
+%else
+    psrlq  %5, 32
+%endif
+    mov    %1, %6w
+    shr    %6, 16
+    mov    %2, %6w
+    movd   %6, %5
+    mov    %3, %6w
+    shr    %6, 16
+    mov    %4, %6w
+%endmacro
+
+%macro STORE_4_WORDS_SSE4 6
+    pextrw %1, %5, %6+0
+    pextrw %2, %5, %6+1
+    pextrw %3, %5, %6+2
+    pextrw %4, %5, %6+3
+%endmacro
+
+; in:  p1 p0 q0 q1, clobbers p0
+; out: p1 = (2*(p1 - q1) - 5*(p0 - q0) + 4) &gt;&gt; 3
+%macro VC1_LOOP_FILTER_A0 4
+    psubw  %1, %4
+    psubw  %2, %3
+    paddw  %1, %1
+    pmullw %2, [pw_5]
+    psubw  %1, %2
+    paddw  %1, [pw_4]
+    psraw  %1, 3
+%endmacro
+
+; in: p0 q0 a0 a1 a2
+;     m0 m1 m7 m6 m5
+; %1: size
+; out: m0=p0' m1=q0'
+%macro VC1_FILTER 1
+    PABSW   m4, m7
+    PABSW   m3, m6
+    PABSW   m2, m5
+    mova    m6, m4
+    pminsw  m3, m2
+    pcmpgtw m6, m3  ; if (a2 &lt; a0 || a1 &lt; a0)
+    psubw   m3, m4
+    pmullw  m3, [pw_5]   ; 5*(a3 - a0)
+    PABSW   m2, m3
+    psraw   m2, 3   ; abs(d/8)
+    pxor    m7, m3  ; d_sign ^= a0_sign
+
+    pxor    m5, m5
+    movd    m3, r2
+%if %1 &gt; 4
+    punpcklbw m3, m3
+%endif
+    punpcklbw m3, m5
+    pcmpgtw m3, m4  ; if (a0 &lt; pq)
+    pand    m6, m3
+
+    mova    m3, m0
+    psubw   m3, m1
+    PABSW   m4, m3
+    psraw   m4, 1
+    pxor    m3, m7  ; d_sign ^ clip_sign
+    psraw   m3, 15
+    pminsw  m2, m4  ; min(d, clip)
+    pcmpgtw m4, m5
+    pand    m6, m4  ; filt3 (C return value)
+
+; each set of 4 pixels is not filtered if the 3rd is not
+%if mmsize==16
+    pshuflw m4, m6, 0xaa
+%if %1 &gt; 4
+    pshufhw m4, m4, 0xaa
+%endif
+%else
+    pshufw  m4, m6, 0xaa
+%endif
+    pandn   m3, m4
+    pand    m2, m6
+    pand    m3, m2  ; d final
+
+    PSIGNW  m3, m7
+    psubw   m0, m3
+    paddw   m1, m3
+    packuswb m0, m0
+    packuswb m1, m1
+%endmacro
+
+; 1st param: size of filter
+; 2nd param: mov suffix equivalent to the filter size
+%macro VC1_V_LOOP_FILTER 2
+    pxor      m5, m5
+    mov%2     m6, [r4]
+    mov%2     m4, [r4+r1]
+    mov%2     m7, [r4+2*r1]
+    mov%2     m0, [r4+r3]
+    punpcklbw m6, m5
+    punpcklbw m4, m5
+    punpcklbw m7, m5
+    punpcklbw m0, m5
+
+    VC1_LOOP_FILTER_A0 m6, m4, m7, m0
+    mov%2     m1, [r0]
+    mov%2     m2, [r0+r1]
+    punpcklbw m1, m5
+    punpcklbw m2, m5
+    mova      m4, m0
+    VC1_LOOP_FILTER_A0 m7, m4, m1, m2
+    mov%2     m3, [r0+2*r1]
+    mov%2     m4, [r0+r3]
+    punpcklbw m3, m5
+    punpcklbw m4, m5
+    mova      m5, m1
+    VC1_LOOP_FILTER_A0 m5, m2, m3, m4
+
+    VC1_FILTER %1
+    mov%2 [r4+r3], m0
+    mov%2 [r0],    m1
+%endmacro
+
+; 1st param: size of filter
+;     NOTE: UNPACK_8TO16 this number of 8 bit numbers are in half a register
+; 2nd (optional) param: temp register to use for storing words
+%macro VC1_H_LOOP_FILTER 1-2
+%if %1 == 4
+    movq      m0, [r0     -4]
+    movq      m1, [r0+  r1-4]
+    movq      m2, [r0+2*r1-4]
+    movq      m3, [r0+  r3-4]
+    TRANSPOSE4x4B 0, 1, 2, 3, 4
+%else
+    movq      m0, [r0     -4]
+    movq      m4, [r0+  r1-4]
+    movq      m1, [r0+2*r1-4]
+    movq      m5, [r0+  r3-4]
+    movq      m2, [r4     -4]
+    movq      m6, [r4+  r1-4]
+    movq      m3, [r4+2*r1-4]
+    movq      m7, [r4+  r3-4]
+    punpcklbw m0, m4
+    punpcklbw m1, m5
+    punpcklbw m2, m6
+    punpcklbw m3, m7
+    TRANSPOSE4x4W 0, 1, 2, 3, 4
+%endif
+    pxor      m5, m5
+
+    UNPACK_8TO16 bw, 6, 0, 5
+    UNPACK_8TO16 bw, 7, 1, 5
+    VC1_LOOP_FILTER_A0 m6, m0, m7, m1
+    UNPACK_8TO16 bw, 4, 2, 5
+    mova    m0, m1                      ; m0 = p0
+    VC1_LOOP_FILTER_A0 m7, m1, m4, m2
+    UNPACK_8TO16 bw, 1, 3, 5
+    mova    m5, m4
+    VC1_LOOP_FILTER_A0 m5, m2, m1, m3
+    SWAP 1, 4                           ; m1 = q0
+
+    VC1_FILTER %1
+    punpcklbw m0, m1
+%if %0 &gt; 1
+    STORE_4_WORDS_MMX [r0-1], [r0+r1-1], [r0+2*r1-1], [r0+r3-1], m0, %2
+%if %1 &gt; 4
+    psrldq m0, 4
+    STORE_4_WORDS_MMX [r4-1], [r4+r1-1], [r4+2*r1-1], [r4+r3-1], m0, %2
+%endif
+%else
+    STORE_4_WORDS_SSE4 [r0-1], [r0+r1-1], [r0+2*r1-1], [r0+r3-1], m0, 0
+    STORE_4_WORDS_SSE4 [r4-1], [r4+r1-1], [r4+2*r1-1], [r4+r3-1], m0, 4
+%endif
+%endmacro
+
+
+%macro START_V_FILTER 0
+    mov  r4, r0
+    lea  r3, [4*r1]
+    sub  r4, r3
+    lea  r3, [r1+2*r1]
+    imul r2, 0x01010101
+%endmacro
+
+%macro START_H_FILTER 1
+    lea  r3, [r1+2*r1]
+%if %1 &gt; 4
+    lea  r4, [r0+4*r1]
+%endif
+    imul r2, 0x01010101
+%endmacro
+
+; I dont know why the sign extension is needed...
+%macro PSIGNW_SRA_MMX 2
+    psraw %2, 15
+    PSIGNW_MMX %1, %2
+%endmacro
+
+
+%macro VC1_LF_MMX 1
+INIT_MMX
+cglobal vc1_v_loop_filter_internal_%1
+    VC1_V_LOOP_FILTER 4, d
+    ret
+
+cglobal vc1_h_loop_filter_internal_%1
+    VC1_H_LOOP_FILTER 4, r4
+    ret
+
+; void ff_vc1_v_loop_filter4_mmx2(uint8_t *src, int stride, int pq)
+cglobal vc1_v_loop_filter4_%1, 3,5,0
+    START_V_FILTER
+    call vc1_v_loop_filter_internal_%1
+    RET
+
+; void ff_vc1_h_loop_filter4_mmx2(uint8_t *src, int stride, int pq)
+cglobal vc1_h_loop_filter4_%1, 3,5,0
+    START_H_FILTER 4
+    call vc1_h_loop_filter_internal_%1
+    RET
+
+; void ff_vc1_v_loop_filter8_mmx2(uint8_t *src, int stride, int pq)
+cglobal vc1_v_loop_filter8_%1, 3,5,0
+    START_V_FILTER
+    call vc1_v_loop_filter_internal_%1
+    add  r4, 4
+    add  r0, 4
+    call vc1_v_loop_filter_internal_%1
+    RET
+
+; void ff_vc1_h_loop_filter8_mmx2(uint8_t *src, int stride, int pq)
+cglobal vc1_h_loop_filter8_%1, 3,5,0
+    START_H_FILTER 4
+    call vc1_h_loop_filter_internal_%1
+    lea  r0, [r0+4*r1]
+    call vc1_h_loop_filter_internal_%1
+    RET
+%endmacro
+
+%define PABSW PABSW_MMX
+%define PSIGNW PSIGNW_SRA_MMX
+VC1_LF_MMX mmx
+
+%define PABSW PABSW_MMX2
+VC1_LF_MMX mmx2
+
+INIT_XMM
+; void ff_vc1_v_loop_filter8_sse2(uint8_t *src, int stride, int pq)
+cglobal vc1_v_loop_filter8_sse2, 3,5,8
+    START_V_FILTER
+    VC1_V_LOOP_FILTER 8, q
+    RET
+
+; void ff_vc1_h_loop_filter8_sse2(uint8_t *src, int stride, int pq)
+cglobal vc1_h_loop_filter8_sse2, 3,6,8
+    START_H_FILTER 8
+    VC1_H_LOOP_FILTER 8, r5
+    RET
+
+%define PABSW PABSW_SSSE3
+%define PSIGNW PSIGNW_SSSE3
+
+INIT_MMX
+; void ff_vc1_v_loop_filter4_ssse3(uint8_t *src, int stride, int pq)
+cglobal vc1_v_loop_filter4_ssse3, 3,5,0
+    START_V_FILTER
+    VC1_V_LOOP_FILTER 4, d
+    RET
+
+; void ff_vc1_h_loop_filter4_ssse3(uint8_t *src, int stride, int pq)
+cglobal vc1_h_loop_filter4_ssse3, 3,5,0
+    START_H_FILTER 4
+    VC1_H_LOOP_FILTER 4, r4
+    RET
+
+INIT_XMM
+; void ff_vc1_v_loop_filter8_ssse3(uint8_t *src, int stride, int pq)
+cglobal vc1_v_loop_filter8_ssse3, 3,5,8
+    START_V_FILTER
+    VC1_V_LOOP_FILTER 8, q
+    RET
+
+; void ff_vc1_h_loop_filter8_ssse3(uint8_t *src, int stride, int pq)
+cglobal vc1_h_loop_filter8_ssse3, 3,6,8
+    START_H_FILTER 8
+    VC1_H_LOOP_FILTER 8, r5
+    RET
+
+; void ff_vc1_h_loop_filter8_sse4(uint8_t *src, int stride, int pq)
+cglobal vc1_h_loop_filter8_sse4, 3,5,8
+    START_H_FILTER 8
+    VC1_H_LOOP_FILTER 8
+    RET

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/x86/vp56_arith.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/x86/vp56_arith.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/x86/vp56_arith.h	2010-07-25 10:07:39 UTC (rev 6478)
@@ -0,0 +1,54 @@
+/**
+ * VP5 and VP6 compatible video decoder (arith decoder)
+ *
+ * Copyright (C) 2006  Aurelien Jacobs &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">aurel at gnuage.org</A>&gt;
+ * Copyright (C) 2010  Eli Friedman
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_X86_VP56_ARITH_H
+#define AVCODEC_X86_VP56_ARITH_H
+
+#if HAVE_FAST_CMOV
+#define vp56_rac_get_prob vp56_rac_get_prob
+static inline int vp56_rac_get_prob(VP56RangeCoder *c, uint8_t prob)
+{
+    unsigned int code_word = vp56_rac_renorm(c);
+    unsigned int high = c-&gt;high;
+    unsigned int low = 1 + (((high - 1) * prob) &gt;&gt; 8);
+    unsigned int low_shift = low &lt;&lt; 8;
+    int bit = 0;
+
+    __asm__(
+        &quot;subl  %4, %1      \n\t&quot;
+        &quot;subl  %3, %2      \n\t&quot;
+        &quot;leal (%2, %3), %3 \n\t&quot;
+        &quot;setae %b0         \n\t&quot;
+        &quot;cmovb %4, %1      \n\t&quot;
+        &quot;cmovb %3, %2      \n\t&quot;
+        : &quot;+q&quot;(bit), &quot;+r&quot;(high), &quot;+r&quot;(code_word), &quot;+r&quot;(low_shift)
+        : &quot;r&quot;(low)
+    );
+
+    c-&gt;high      = high;
+    c-&gt;code_word = code_word;
+    return bit;
+}
+#endif
+
+#endif /* AVCODEC_X86_VP56_ARITH_H */

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/x86/vp8dsp-init.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/x86/vp8dsp-init.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/x86/vp8dsp-init.c	2010-07-25 10:07:39 UTC (rev 6478)
@@ -0,0 +1,397 @@
+/*
+ * VP8 DSP functions x86-optimized
+ * Copyright (c) 2010 Ronald S. Bultje &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">rsbultje at gmail.com</A>&gt;
+ * Copyright (c) 2010 Jason Garrett-Glaser &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">darkshikari at gmail.com</A>&gt;
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include &quot;libavutil/x86_cpu.h&quot;
+#include &quot;libavcodec/vp8dsp.h&quot;
+
+#if HAVE_YASM
+
+/*
+ * MC functions
+ */
+extern void ff_put_vp8_epel4_h4_mmxext(uint8_t *dst, int dststride,
+                                       uint8_t *src, int srcstride,
+                                       int height, int mx, int my);
+extern void ff_put_vp8_epel4_h6_mmxext(uint8_t *dst, int dststride,
+                                       uint8_t *src, int srcstride,
+                                       int height, int mx, int my);
+extern void ff_put_vp8_epel4_v4_mmxext(uint8_t *dst, int dststride,
+                                       uint8_t *src, int srcstride,
+                                       int height, int mx, int my);
+extern void ff_put_vp8_epel4_v6_mmxext(uint8_t *dst, int dststride,
+                                       uint8_t *src, int srcstride,
+                                       int height, int mx, int my);
+
+extern void ff_put_vp8_epel8_h4_sse2  (uint8_t *dst, int dststride,
+                                       uint8_t *src, int srcstride,
+                                       int height, int mx, int my);
+extern void ff_put_vp8_epel8_h6_sse2  (uint8_t *dst, int dststride,
+                                       uint8_t *src, int srcstride,
+                                       int height, int mx, int my);
+extern void ff_put_vp8_epel8_v4_sse2  (uint8_t *dst, int dststride,
+                                       uint8_t *src, int srcstride,
+                                       int height, int mx, int my);
+extern void ff_put_vp8_epel8_v6_sse2  (uint8_t *dst, int dststride,
+                                       uint8_t *src, int srcstride,
+                                       int height, int mx, int my);
+
+extern void ff_put_vp8_epel4_h4_ssse3 (uint8_t *dst, int dststride,
+                                       uint8_t *src, int srcstride,
+                                       int height, int mx, int my);
+extern void ff_put_vp8_epel4_h6_ssse3 (uint8_t *dst, int dststride,
+                                       uint8_t *src, int srcstride,
+                                       int height, int mx, int my);
+extern void ff_put_vp8_epel4_v4_ssse3 (uint8_t *dst, int dststride,
+                                       uint8_t *src, int srcstride,
+                                       int height, int mx, int my);
+extern void ff_put_vp8_epel4_v6_ssse3 (uint8_t *dst, int dststride,
+                                       uint8_t *src, int srcstride,
+                                       int height, int mx, int my);
+extern void ff_put_vp8_epel8_h4_ssse3 (uint8_t *dst, int dststride,
+                                       uint8_t *src, int srcstride,
+                                       int height, int mx, int my);
+extern void ff_put_vp8_epel8_h6_ssse3 (uint8_t *dst, int dststride,
+                                       uint8_t *src, int srcstride,
+                                       int height, int mx, int my);
+extern void ff_put_vp8_epel8_v4_ssse3 (uint8_t *dst, int dststride,
+                                       uint8_t *src, int srcstride,
+                                       int height, int mx, int my);
+extern void ff_put_vp8_epel8_v6_ssse3 (uint8_t *dst, int dststride,
+                                       uint8_t *src, int srcstride,
+                                       int height, int mx, int my);
+
+extern void ff_put_vp8_bilinear4_h_mmxext(uint8_t *dst, int dststride,
+                                          uint8_t *src, int srcstride,
+                                          int height, int mx, int my);
+extern void ff_put_vp8_bilinear8_h_sse2  (uint8_t *dst, int dststride,
+                                          uint8_t *src, int srcstride,
+                                          int height, int mx, int my);
+extern void ff_put_vp8_bilinear4_h_ssse3 (uint8_t *dst, int dststride,
+                                          uint8_t *src, int srcstride,
+                                          int height, int mx, int my);
+extern void ff_put_vp8_bilinear8_h_ssse3 (uint8_t *dst, int dststride,
+                                          uint8_t *src, int srcstride,
+                                          int height, int mx, int my);
+
+extern void ff_put_vp8_bilinear4_v_mmxext(uint8_t *dst, int dststride,
+                                          uint8_t *src, int srcstride,
+                                          int height, int mx, int my);
+extern void ff_put_vp8_bilinear8_v_sse2  (uint8_t *dst, int dststride,
+                                          uint8_t *src, int srcstride,
+                                          int height, int mx, int my);
+extern void ff_put_vp8_bilinear4_v_ssse3 (uint8_t *dst, int dststride,
+                                          uint8_t *src, int srcstride,
+                                          int height, int mx, int my);
+extern void ff_put_vp8_bilinear8_v_ssse3 (uint8_t *dst, int dststride,
+                                          uint8_t *src, int srcstride,
+                                          int height, int mx, int my);
+
+
+extern void ff_put_vp8_pixels8_mmx (uint8_t *dst, int dststride,
+                                    uint8_t *src, int srcstride,
+                                    int height, int mx, int my);
+extern void ff_put_vp8_pixels16_mmx(uint8_t *dst, int dststride,
+                                    uint8_t *src, int srcstride,
+                                    int height, int mx, int my);
+extern void ff_put_vp8_pixels16_sse(uint8_t *dst, int dststride,
+                                    uint8_t *src, int srcstride,
+                                    int height, int mx, int my);
+
+#define TAP_W16(OPT, FILTERTYPE, TAPTYPE) \
+static void ff_put_vp8_ ## FILTERTYPE ## 16_ ## TAPTYPE ## _ ## OPT( \
+    uint8_t *dst,  int dststride, uint8_t *src, \
+    int srcstride, int height, int mx, int my) \
+{ \
+    ff_put_vp8_ ## FILTERTYPE ## 8_ ## TAPTYPE ## _ ## OPT( \
+        dst,     dststride, src,     srcstride, height, mx, my); \
+    ff_put_vp8_ ## FILTERTYPE ## 8_ ## TAPTYPE ## _ ## OPT( \
+        dst + 8, dststride, src + 8, srcstride, height, mx, my); \
+}
+#define TAP_W8(OPT, FILTERTYPE, TAPTYPE) \
+static void ff_put_vp8_ ## FILTERTYPE ## 8_ ## TAPTYPE ## _ ## OPT( \
+    uint8_t *dst,  int dststride, uint8_t *src, \
+    int srcstride, int height, int mx, int my) \
+{ \
+    ff_put_vp8_ ## FILTERTYPE ## 4_ ## TAPTYPE ## _ ## OPT( \
+        dst,     dststride, src,     srcstride, height, mx, my); \
+    ff_put_vp8_ ## FILTERTYPE ## 4_ ## TAPTYPE ## _ ## OPT( \
+        dst + 4, dststride, src + 4, srcstride, height, mx, my); \
+}
+
+TAP_W8 (mmxext, epel, h4)
+TAP_W8 (mmxext, epel, h6)
+TAP_W16(mmxext, epel, h6)
+TAP_W8 (mmxext, epel, v4)
+TAP_W8 (mmxext, epel, v6)
+TAP_W16(mmxext, epel, v6)
+TAP_W8 (mmxext, bilinear, h)
+TAP_W16(mmxext, bilinear, h)
+TAP_W8 (mmxext, bilinear, v)
+TAP_W16(mmxext, bilinear, v)
+
+TAP_W16(sse2,   epel, h6)
+TAP_W16(sse2,   epel, v6)
+TAP_W16(sse2,   bilinear, h)
+TAP_W16(sse2,   bilinear, v)
+
+TAP_W16(ssse3,  epel, h6)
+TAP_W16(ssse3,  epel, v6)
+TAP_W16(ssse3,  bilinear, h)
+TAP_W16(ssse3,  bilinear, v)
+
+#define HVTAP(OPT, ALIGN, TAPNUMX, TAPNUMY, SIZE, MAXHEIGHT) \
+static void ff_put_vp8_epel ## SIZE ## _h ## TAPNUMX ## v ## TAPNUMY ## _ ## OPT( \
+    uint8_t *dst, int dststride, uint8_t *src, \
+    int srcstride, int height, int mx, int my) \
+{ \
+    DECLARE_ALIGNED(ALIGN, uint8_t, tmp)[SIZE * (MAXHEIGHT + TAPNUMY - 1)]; \
+    uint8_t *tmpptr = tmp + SIZE * (TAPNUMY / 2 - 1); \
+    src -= srcstride * (TAPNUMY / 2 - 1); \
+    ff_put_vp8_epel ## SIZE ## _h ## TAPNUMX ## _ ## OPT( \
+        tmp, SIZE,      src,    srcstride, height + TAPNUMY - 1, mx, my); \
+    ff_put_vp8_epel ## SIZE ## _v ## TAPNUMY ## _ ## OPT( \
+        dst, dststride, tmpptr, SIZE,      height,               mx, my); \
+}
+
+#define HVTAPMMX(x, y) \
+HVTAP(mmxext, 8, x, y,  4,  8) \
+HVTAP(mmxext, 8, x, y,  8, 16)
+
+HVTAPMMX(4, 4)
+HVTAPMMX(4, 6)
+HVTAPMMX(6, 4)
+HVTAPMMX(6, 6)
+HVTAP(mmxext, 8, 6, 6, 16, 16)
+
+#define HVTAPSSE2(x, y, w) \
+HVTAP(sse2,  16, x, y, w, 16) \
+HVTAP(ssse3, 16, x, y, w, 16)
+
+HVTAPSSE2(4, 4, 8)
+HVTAPSSE2(4, 6, 8)
+HVTAPSSE2(6, 4, 8)
+HVTAPSSE2(6, 6, 8)
+HVTAPSSE2(6, 6, 16)
+
+HVTAP(ssse3, 16, 4, 4, 4, 8)
+HVTAP(ssse3, 16, 4, 6, 4, 8)
+HVTAP(ssse3, 16, 6, 4, 4, 8)
+HVTAP(ssse3, 16, 6, 6, 4, 8)
+
+#define HVBILIN(OPT, ALIGN, SIZE, MAXHEIGHT) \
+static void ff_put_vp8_bilinear ## SIZE ## _hv_ ## OPT( \
+    uint8_t *dst, int dststride, uint8_t *src, \
+    int srcstride, int height, int mx, int my) \
+{ \
+    DECLARE_ALIGNED(ALIGN, uint8_t, tmp)[SIZE * (MAXHEIGHT + 2)]; \
+    ff_put_vp8_bilinear ## SIZE ## _h_ ## OPT( \
+        tmp, SIZE,      src, srcstride, height + 1, mx, my); \
+    ff_put_vp8_bilinear ## SIZE ## _v_ ## OPT( \
+        dst, dststride, tmp, SIZE,      height,     mx, my); \
+}
+
+HVBILIN(mmxext, 8,  4,  8)
+HVBILIN(mmxext, 8,  8, 16)
+HVBILIN(mmxext, 8, 16, 16)
+HVBILIN(sse2,   8,  8, 16)
+HVBILIN(sse2,   8, 16, 16)
+HVBILIN(ssse3,  8,  4,  8)
+HVBILIN(ssse3,  8,  8, 16)
+HVBILIN(ssse3,  8, 16, 16)
+
+extern void ff_vp8_idct_dc_add_mmx(uint8_t *dst, DCTELEM block[16], int stride);
+extern void ff_vp8_idct_dc_add_sse4(uint8_t *dst, DCTELEM block[16], int stride);
+extern void ff_vp8_idct_dc_add4y_mmx(uint8_t *dst, DCTELEM block[4][16], int stride);
+extern void ff_vp8_idct_dc_add4y_sse2(uint8_t *dst, DCTELEM block[4][16], int stride);
+extern void ff_vp8_idct_dc_add4uv_mmx(uint8_t *dst, DCTELEM block[2][16], int stride);
+extern void ff_vp8_luma_dc_wht_mmx(DCTELEM block[4][4][16], DCTELEM dc[16]);
+extern void ff_vp8_idct_add_mmx(uint8_t *dst, DCTELEM block[16], int stride);
+extern void ff_vp8_idct_add_sse(uint8_t *dst, DCTELEM block[16], int stride);
+
+#define DECLARE_LOOP_FILTER(NAME)\
+extern void ff_vp8_v_loop_filter_simple_ ## NAME(uint8_t *dst, int stride, int flim);\
+extern void ff_vp8_h_loop_filter_simple_ ## NAME(uint8_t *dst, int stride, int flim);\
+extern void ff_vp8_v_loop_filter16y_inner_ ## NAME (uint8_t *dst, int stride,\
+                                                    int e, int i, int hvt);\
+extern void ff_vp8_h_loop_filter16y_inner_ ## NAME (uint8_t *dst, int stride,\
+                                                    int e, int i, int hvt);\
+extern void ff_vp8_v_loop_filter8uv_inner_ ## NAME (uint8_t *dstU, uint8_t *dstV,\
+                                                    int s, int e, int i, int hvt);\
+extern void ff_vp8_h_loop_filter8uv_inner_ ## NAME (uint8_t *dstU, uint8_t *dstV,\
+                                                    int s, int e, int i, int hvt);\
+extern void ff_vp8_v_loop_filter16y_mbedge_ ## NAME(uint8_t *dst, int stride,\
+                                                    int e, int i, int hvt);\
+extern void ff_vp8_h_loop_filter16y_mbedge_ ## NAME(uint8_t *dst, int stride,\
+                                                    int e, int i, int hvt);\
+extern void ff_vp8_v_loop_filter8uv_mbedge_ ## NAME(uint8_t *dstU, uint8_t *dstV,\
+                                                    int s, int e, int i, int hvt);\
+extern void ff_vp8_h_loop_filter8uv_mbedge_ ## NAME(uint8_t *dstU, uint8_t *dstV,\
+                                                    int s, int e, int i, int hvt);
+
+DECLARE_LOOP_FILTER(mmx)
+DECLARE_LOOP_FILTER(mmxext)
+DECLARE_LOOP_FILTER(sse2)
+DECLARE_LOOP_FILTER(ssse3)
+DECLARE_LOOP_FILTER(sse4)
+
+#endif
+
+#define VP8_LUMA_MC_FUNC(IDX, SIZE, OPT) \
+    c-&gt;put_vp8_epel_pixels_tab[IDX][0][2] = ff_put_vp8_epel ## SIZE ## _h6_ ## OPT; \
+    c-&gt;put_vp8_epel_pixels_tab[IDX][2][0] = ff_put_vp8_epel ## SIZE ## _v6_ ## OPT; \
+    c-&gt;put_vp8_epel_pixels_tab[IDX][2][2] = ff_put_vp8_epel ## SIZE ## _h6v6_ ## OPT
+
+#define VP8_MC_FUNC(IDX, SIZE, OPT) \
+    c-&gt;put_vp8_epel_pixels_tab[IDX][0][1] = ff_put_vp8_epel ## SIZE ## _h4_ ## OPT; \
+    c-&gt;put_vp8_epel_pixels_tab[IDX][1][0] = ff_put_vp8_epel ## SIZE ## _v4_ ## OPT; \
+    c-&gt;put_vp8_epel_pixels_tab[IDX][1][1] = ff_put_vp8_epel ## SIZE ## _h4v4_ ## OPT; \
+    c-&gt;put_vp8_epel_pixels_tab[IDX][1][2] = ff_put_vp8_epel ## SIZE ## _h6v4_ ## OPT; \
+    c-&gt;put_vp8_epel_pixels_tab[IDX][2][1] = ff_put_vp8_epel ## SIZE ## _h4v6_ ## OPT; \
+    VP8_LUMA_MC_FUNC(IDX, SIZE, OPT)
+
+#define VP8_BILINEAR_MC_FUNC(IDX, SIZE, OPT) \
+    c-&gt;put_vp8_bilinear_pixels_tab[IDX][0][1] = ff_put_vp8_bilinear ## SIZE ## _h_ ## OPT; \
+    c-&gt;put_vp8_bilinear_pixels_tab[IDX][0][2] = ff_put_vp8_bilinear ## SIZE ## _h_ ## OPT; \
+    c-&gt;put_vp8_bilinear_pixels_tab[IDX][1][0] = ff_put_vp8_bilinear ## SIZE ## _v_ ## OPT; \
+    c-&gt;put_vp8_bilinear_pixels_tab[IDX][1][1] = ff_put_vp8_bilinear ## SIZE ## _hv_ ## OPT; \
+    c-&gt;put_vp8_bilinear_pixels_tab[IDX][1][2] = ff_put_vp8_bilinear ## SIZE ## _hv_ ## OPT; \
+    c-&gt;put_vp8_bilinear_pixels_tab[IDX][2][0] = ff_put_vp8_bilinear ## SIZE ## _v_ ## OPT; \
+    c-&gt;put_vp8_bilinear_pixels_tab[IDX][2][1] = ff_put_vp8_bilinear ## SIZE ## _hv_ ## OPT; \
+    c-&gt;put_vp8_bilinear_pixels_tab[IDX][2][2] = ff_put_vp8_bilinear ## SIZE ## _hv_ ## OPT
+
+
+av_cold void ff_vp8dsp_init_x86(VP8DSPContext* c)
+{
+    mm_flags = mm_support();
+
+#if HAVE_YASM
+    if (mm_flags &amp; FF_MM_MMX) {
+        c-&gt;vp8_idct_dc_add    = ff_vp8_idct_dc_add_mmx;
+        c-&gt;vp8_idct_dc_add4y  = ff_vp8_idct_dc_add4y_mmx;
+        c-&gt;vp8_idct_dc_add4uv = ff_vp8_idct_dc_add4uv_mmx;
+        c-&gt;vp8_idct_add       = ff_vp8_idct_add_mmx;
+        c-&gt;vp8_luma_dc_wht    = ff_vp8_luma_dc_wht_mmx;
+        c-&gt;put_vp8_epel_pixels_tab[0][0][0]     =
+        c-&gt;put_vp8_bilinear_pixels_tab[0][0][0] = ff_put_vp8_pixels16_mmx;
+        c-&gt;put_vp8_epel_pixels_tab[1][0][0]     =
+        c-&gt;put_vp8_bilinear_pixels_tab[1][0][0] = ff_put_vp8_pixels8_mmx;
+
+        c-&gt;vp8_v_loop_filter_simple = ff_vp8_v_loop_filter_simple_mmx;
+        c-&gt;vp8_h_loop_filter_simple = ff_vp8_h_loop_filter_simple_mmx;
+
+        c-&gt;vp8_v_loop_filter16y_inner = ff_vp8_v_loop_filter16y_inner_mmx;
+        c-&gt;vp8_h_loop_filter16y_inner = ff_vp8_h_loop_filter16y_inner_mmx;
+        c-&gt;vp8_v_loop_filter8uv_inner = ff_vp8_v_loop_filter8uv_inner_mmx;
+        c-&gt;vp8_h_loop_filter8uv_inner = ff_vp8_h_loop_filter8uv_inner_mmx;
+
+        c-&gt;vp8_v_loop_filter16y       = ff_vp8_v_loop_filter16y_mbedge_mmx;
+        c-&gt;vp8_h_loop_filter16y       = ff_vp8_h_loop_filter16y_mbedge_mmx;
+        c-&gt;vp8_v_loop_filter8uv       = ff_vp8_v_loop_filter8uv_mbedge_mmx;
+        c-&gt;vp8_h_loop_filter8uv       = ff_vp8_h_loop_filter8uv_mbedge_mmx;
+    }
+
+    /* note that 4-tap width=16 functions are missing because w=16
+     * is only used for luma, and luma is always a copy or sixtap. */
+    if (mm_flags &amp; FF_MM_MMX2) {
+        VP8_LUMA_MC_FUNC(0, 16, mmxext);
+        VP8_MC_FUNC(1, 8, mmxext);
+        VP8_MC_FUNC(2, 4, mmxext);
+        VP8_BILINEAR_MC_FUNC(0, 16, mmxext);
+        VP8_BILINEAR_MC_FUNC(1, 8, mmxext);
+        VP8_BILINEAR_MC_FUNC(2, 4, mmxext);
+
+        c-&gt;vp8_v_loop_filter_simple = ff_vp8_v_loop_filter_simple_mmxext;
+        c-&gt;vp8_h_loop_filter_simple = ff_vp8_h_loop_filter_simple_mmxext;
+
+        c-&gt;vp8_v_loop_filter16y_inner = ff_vp8_v_loop_filter16y_inner_mmxext;
+        c-&gt;vp8_h_loop_filter16y_inner = ff_vp8_h_loop_filter16y_inner_mmxext;
+        c-&gt;vp8_v_loop_filter8uv_inner = ff_vp8_v_loop_filter8uv_inner_mmxext;
+        c-&gt;vp8_h_loop_filter8uv_inner = ff_vp8_h_loop_filter8uv_inner_mmxext;
+
+        c-&gt;vp8_v_loop_filter16y       = ff_vp8_v_loop_filter16y_mbedge_mmxext;
+        c-&gt;vp8_h_loop_filter16y       = ff_vp8_h_loop_filter16y_mbedge_mmxext;
+        c-&gt;vp8_v_loop_filter8uv       = ff_vp8_v_loop_filter8uv_mbedge_mmxext;
+        c-&gt;vp8_h_loop_filter8uv       = ff_vp8_h_loop_filter8uv_mbedge_mmxext;
+    }
+
+    if (mm_flags &amp; FF_MM_SSE) {
+        c-&gt;vp8_idct_add                         = ff_vp8_idct_add_sse;
+        c-&gt;put_vp8_epel_pixels_tab[0][0][0]     =
+        c-&gt;put_vp8_bilinear_pixels_tab[0][0][0] = ff_put_vp8_pixels16_sse;
+    }
+
+    if (mm_flags &amp; (FF_MM_SSE2|FF_MM_SSE2SLOW)) {
+        VP8_LUMA_MC_FUNC(0, 16, sse2);
+        VP8_MC_FUNC(1, 8, sse2);
+        VP8_BILINEAR_MC_FUNC(0, 16, sse2);
+        VP8_BILINEAR_MC_FUNC(1, 8, sse2);
+
+        c-&gt;vp8_v_loop_filter_simple = ff_vp8_v_loop_filter_simple_sse2;
+        c-&gt;vp8_h_loop_filter_simple = ff_vp8_h_loop_filter_simple_sse2;
+
+        c-&gt;vp8_v_loop_filter16y_inner = ff_vp8_v_loop_filter16y_inner_sse2;
+        c-&gt;vp8_v_loop_filter8uv_inner = ff_vp8_v_loop_filter8uv_inner_sse2;
+
+        c-&gt;vp8_v_loop_filter16y       = ff_vp8_v_loop_filter16y_mbedge_sse2;
+        c-&gt;vp8_v_loop_filter8uv       = ff_vp8_v_loop_filter8uv_mbedge_sse2;
+    }
+
+    if (mm_flags &amp; FF_MM_SSE2) {
+        c-&gt;vp8_idct_dc_add4y          = ff_vp8_idct_dc_add4y_sse2;
+
+        c-&gt;vp8_h_loop_filter16y_inner = ff_vp8_h_loop_filter16y_inner_sse2;
+        c-&gt;vp8_h_loop_filter8uv_inner = ff_vp8_h_loop_filter8uv_inner_sse2;
+
+        c-&gt;vp8_h_loop_filter16y       = ff_vp8_h_loop_filter16y_mbedge_sse2;
+        c-&gt;vp8_h_loop_filter8uv       = ff_vp8_h_loop_filter8uv_mbedge_sse2;
+    }
+
+    if (mm_flags &amp; FF_MM_SSSE3) {
+        VP8_LUMA_MC_FUNC(0, 16, ssse3);
+        VP8_MC_FUNC(1, 8, ssse3);
+        VP8_MC_FUNC(2, 4, ssse3);
+        VP8_BILINEAR_MC_FUNC(0, 16, ssse3);
+        VP8_BILINEAR_MC_FUNC(1, 8, ssse3);
+        VP8_BILINEAR_MC_FUNC(2, 4, ssse3);
+
+        c-&gt;vp8_v_loop_filter_simple = ff_vp8_v_loop_filter_simple_ssse3;
+        c-&gt;vp8_h_loop_filter_simple = ff_vp8_h_loop_filter_simple_ssse3;
+
+        c-&gt;vp8_v_loop_filter16y_inner = ff_vp8_v_loop_filter16y_inner_ssse3;
+        c-&gt;vp8_h_loop_filter16y_inner = ff_vp8_h_loop_filter16y_inner_ssse3;
+        c-&gt;vp8_v_loop_filter8uv_inner = ff_vp8_v_loop_filter8uv_inner_ssse3;
+        c-&gt;vp8_h_loop_filter8uv_inner = ff_vp8_h_loop_filter8uv_inner_ssse3;
+
+        c-&gt;vp8_v_loop_filter16y       = ff_vp8_v_loop_filter16y_mbedge_ssse3;
+        c-&gt;vp8_h_loop_filter16y       = ff_vp8_h_loop_filter16y_mbedge_ssse3;
+        c-&gt;vp8_v_loop_filter8uv       = ff_vp8_v_loop_filter8uv_mbedge_ssse3;
+        c-&gt;vp8_h_loop_filter8uv       = ff_vp8_h_loop_filter8uv_mbedge_ssse3;
+    }
+
+    if (mm_flags &amp; FF_MM_SSE4) {
+        c-&gt;vp8_idct_dc_add                  = ff_vp8_idct_dc_add_sse4;
+
+        c-&gt;vp8_h_loop_filter16y       = ff_vp8_h_loop_filter16y_mbedge_sse4;
+        c-&gt;vp8_h_loop_filter8uv       = ff_vp8_h_loop_filter8uv_mbedge_sse4;
+    }
+#endif
+}

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/x86/vp8dsp.asm
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/x86/vp8dsp.asm	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/x86/vp8dsp.asm	2010-07-25 10:07:39 UTC (rev 6478)
@@ -0,0 +1,2752 @@
+;******************************************************************************
+;* VP8 MMXEXT optimizations
+;* Copyright (c) 2010 Ronald S. Bultje &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">rsbultje at gmail.com</A>&gt;
+;* Copyright (c) 2010 Jason Garrett-Glaser &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">darkshikari at gmail.com</A>&gt;
+;*
+;* This file is part of FFmpeg.
+;*
+;* FFmpeg is free software; you can redistribute it and/or
+;* modify it under the terms of the GNU Lesser General Public
+;* License as published by the Free Software Foundation; either
+;* version 2.1 of the License, or (at your option) any later version.
+;*
+;* FFmpeg is distributed in the hope that it will be useful,
+;* but WITHOUT ANY WARRANTY; without even the implied warranty of
+;* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+;* Lesser General Public License for more details.
+;*
+;* You should have received a copy of the GNU Lesser General Public
+;* License along with FFmpeg; if not, write to the Free Software
+;* 51, Inc., Foundation Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+;******************************************************************************
+
+%include &quot;x86inc.asm&quot;
+%include &quot;x86util.asm&quot;
+
+SECTION_RODATA
+
+fourtap_filter_hw_m: times 4 dw  -6, 123
+                     times 4 dw  12,  -1
+                     times 4 dw  -9,  93
+                     times 4 dw  50,  -6
+                     times 4 dw  -6,  50
+                     times 4 dw  93,  -9
+                     times 4 dw  -1,  12
+                     times 4 dw 123,  -6
+
+sixtap_filter_hw_m:  times 4 dw   2, -11
+                     times 4 dw 108,  36
+                     times 4 dw  -8,   1
+                     times 4 dw   3, -16
+                     times 4 dw  77,  77
+                     times 4 dw -16,   3
+                     times 4 dw   1,  -8
+                     times 4 dw  36, 108
+                     times 4 dw -11,   2
+
+fourtap_filter_hb_m: times 8 db  -6, 123
+                     times 8 db  12,  -1
+                     times 8 db  -9,  93
+                     times 8 db  50,  -6
+                     times 8 db  -6,  50
+                     times 8 db  93,  -9
+                     times 8 db  -1,  12
+                     times 8 db 123,  -6
+
+sixtap_filter_hb_m:  times 8 db   2,   1
+                     times 8 db -11, 108
+                     times 8 db  36,  -8
+                     times 8 db   3,   3
+                     times 8 db -16,  77
+                     times 8 db  77, -16
+                     times 8 db   1,   2
+                     times 8 db  -8,  36
+                     times 8 db 108, -11
+
+fourtap_filter_v_m:  times 8 dw  -6
+                     times 8 dw 123
+                     times 8 dw  12
+                     times 8 dw  -1
+                     times 8 dw  -9
+                     times 8 dw  93
+                     times 8 dw  50
+                     times 8 dw  -6
+                     times 8 dw  -6
+                     times 8 dw  50
+                     times 8 dw  93
+                     times 8 dw  -9
+                     times 8 dw  -1
+                     times 8 dw  12
+                     times 8 dw 123
+                     times 8 dw  -6
+
+sixtap_filter_v_m:   times 8 dw   2
+                     times 8 dw -11
+                     times 8 dw 108
+                     times 8 dw  36
+                     times 8 dw  -8
+                     times 8 dw   1
+                     times 8 dw   3
+                     times 8 dw -16
+                     times 8 dw  77
+                     times 8 dw  77
+                     times 8 dw -16
+                     times 8 dw   3
+                     times 8 dw   1
+                     times 8 dw  -8
+                     times 8 dw  36
+                     times 8 dw 108
+                     times 8 dw -11
+                     times 8 dw   2
+
+bilinear_filter_vw_m: times 8 dw 1
+                      times 8 dw 2
+                      times 8 dw 3
+                      times 8 dw 4
+                      times 8 dw 5
+                      times 8 dw 6
+                      times 8 dw 7
+
+bilinear_filter_vb_m: times 8 db 7, 1
+                      times 8 db 6, 2
+                      times 8 db 5, 3
+                      times 8 db 4, 4
+                      times 8 db 3, 5
+                      times 8 db 2, 6
+                      times 8 db 1, 7
+
+%ifdef PIC
+%define fourtap_filter_hw    r11
+%define sixtap_filter_hw     r11
+%define fourtap_filter_hb    r11
+%define sixtap_filter_hb     r11
+%define fourtap_filter_v     r11
+%define sixtap_filter_v      r11
+%define bilinear_filter_vw   r11
+%define bilinear_filter_vb   r11
+%else
+%define fourtap_filter_hw fourtap_filter_hw_m
+%define sixtap_filter_hw  sixtap_filter_hw_m
+%define fourtap_filter_hb fourtap_filter_hb_m
+%define sixtap_filter_hb  sixtap_filter_hb_m
+%define fourtap_filter_v  fourtap_filter_v_m
+%define sixtap_filter_v   sixtap_filter_v_m
+%define bilinear_filter_vw bilinear_filter_vw_m
+%define bilinear_filter_vb bilinear_filter_vb_m
+%endif
+
+filter_h2_shuf:  db 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5,  6, 6,  7,  7,  8
+filter_h4_shuf:  db 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7,  8, 8,  9,  9, 10
+
+filter_h6_shuf1: db 0, 5, 1, 6, 2, 7, 3, 8, 4, 9, 5, 10, 6, 11,  7, 12
+filter_h6_shuf2: db 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,  7, 7,  8,  8,  9
+filter_h6_shuf3: db 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8,  9, 9, 10, 10, 11
+
+pw_20091: times 4 dw 20091
+pw_17734: times 4 dw 17734
+
+cextern pb_1
+cextern pw_3
+cextern pb_3
+cextern pw_4
+cextern pb_4
+cextern pw_9
+cextern pw_18
+cextern pw_27
+cextern pw_63
+cextern pw_64
+cextern pb_80
+cextern pb_F8
+cextern pb_FE
+
+SECTION .text
+
+;-----------------------------------------------------------------------------
+; subpel MC functions:
+;
+; void put_vp8_epel&lt;size&gt;_h&lt;htap&gt;v&lt;vtap&gt;_&lt;opt&gt;(uint8_t *dst, int deststride,
+;                                              uint8_t *src, int srcstride,
+;                                              int height,   int mx, int my);
+;-----------------------------------------------------------------------------
+
+%macro FILTER_SSSE3 3
+cglobal put_vp8_epel%1_h6_ssse3, 6, 6, %2
+    lea      r5d, [r5*3]
+    mova      m3, [filter_h6_shuf2]
+    mova      m4, [filter_h6_shuf3]
+%ifdef PIC
+    lea      r11, [sixtap_filter_hb_m]
+%endif
+    mova      m5, [sixtap_filter_hb+r5*8-48] ; set up 6tap filter in bytes
+    mova      m6, [sixtap_filter_hb+r5*8-32]
+    mova      m7, [sixtap_filter_hb+r5*8-16]
+
+.nextrow
+    movu      m0, [r2-2]
+    mova      m1, m0
+    mova      m2, m0
+%ifidn %1, 4
+; For epel4, we need 9 bytes, but only 8 get loaded; to compensate, do the
+; shuffle with a memory operand
+    punpcklbw m0, [r2+3]
+%else
+    pshufb    m0, [filter_h6_shuf1]
+%endif
+    pshufb    m1, m3
+    pshufb    m2, m4
+    pmaddubsw m0, m5
+    pmaddubsw m1, m6
+    pmaddubsw m2, m7
+    paddsw    m0, m1
+    paddsw    m0, m2
+    paddsw    m0, [pw_64]
+    psraw     m0, 7
+    packuswb  m0, m0
+    movh    [r0], m0        ; store
+
+    ; go to next line
+    add       r0, r1
+    add       r2, r3
+    dec       r4            ; next row
+    jg .nextrow
+    REP_RET
+
+cglobal put_vp8_epel%1_h4_ssse3, 6, 6, %3
+    shl      r5d, 4
+    mova      m2, [pw_64]
+    mova      m3, [filter_h2_shuf]
+    mova      m4, [filter_h4_shuf]
+%ifdef PIC
+    lea      r11, [fourtap_filter_hb_m]
+%endif
+    mova      m5, [fourtap_filter_hb+r5-16] ; set up 4tap filter in bytes
+    mova      m6, [fourtap_filter_hb+r5]
+
+.nextrow
+    movu      m0, [r2-1]
+    mova      m1, m0
+    pshufb    m0, m3
+    pshufb    m1, m4
+    pmaddubsw m0, m5
+    pmaddubsw m1, m6
+    paddsw    m0, m2
+    paddsw    m0, m1
+    psraw     m0, 7
+    packuswb  m0, m0
+    movh    [r0], m0        ; store
+
+    ; go to next line
+    add       r0, r1
+    add       r2, r3
+    dec       r4            ; next row
+    jg .nextrow
+    REP_RET
+
+cglobal put_vp8_epel%1_v4_ssse3, 7, 7, %2
+    shl      r6d, 4
+%ifdef PIC
+    lea      r11, [fourtap_filter_hb_m]
+%endif
+    mova      m5, [fourtap_filter_hb+r6-16]
+    mova      m6, [fourtap_filter_hb+r6]
+    mova      m7, [pw_64]
+
+    ; read 3 lines
+    sub       r2, r3
+    movh      m0, [r2]
+    movh      m1, [r2+  r3]
+    movh      m2, [r2+2*r3]
+    add       r2, r3
+
+.nextrow
+    movh      m3, [r2+2*r3]                ; read new row
+    mova      m4, m0
+    mova      m0, m1
+    punpcklbw m4, m1
+    mova      m1, m2
+    punpcklbw m2, m3
+    pmaddubsw m4, m5
+    pmaddubsw m2, m6
+    paddsw    m4, m2
+    mova      m2, m3
+    paddsw    m4, m7
+    psraw     m4, 7
+    packuswb  m4, m4
+    movh    [r0], m4
+
+    ; go to next line
+    add        r0, r1
+    add        r2, r3
+    dec        r4                          ; next row
+    jg .nextrow
+    REP_RET
+
+cglobal put_vp8_epel%1_v6_ssse3, 7, 7, %2
+    lea      r6d, [r6*3]
+%ifdef PIC
+    lea      r11, [sixtap_filter_hb_m]
+%endif
+    lea       r6, [sixtap_filter_hb+r6*8]
+
+    ; read 5 lines
+    sub       r2, r3
+    sub       r2, r3
+    movh      m0, [r2]
+    movh      m1, [r2+r3]
+    movh      m2, [r2+r3*2]
+    lea       r2, [r2+r3*2]
+    add       r2, r3
+    movh      m3, [r2]
+    movh      m4, [r2+r3]
+
+.nextrow
+    movh      m5, [r2+2*r3]                ; read new row
+    mova      m6, m0
+    punpcklbw m6, m5
+    mova      m0, m1
+    punpcklbw m1, m2
+    mova      m7, m3
+    punpcklbw m7, m4
+    pmaddubsw m6, [r6-48]
+    pmaddubsw m1, [r6-32]
+    pmaddubsw m7, [r6-16]
+    paddsw    m6, m1
+    paddsw    m6, m7
+    mova      m1, m2
+    paddsw    m6, [pw_64]
+    mova      m2, m3
+    psraw     m6, 7
+    mova      m3, m4
+    packuswb  m6, m6
+    mova      m4, m5
+    movh    [r0], m6
+
+    ; go to next line
+    add        r0, r1
+    add        r2, r3
+    dec        r4                          ; next row
+    jg .nextrow
+    REP_RET
+%endmacro
+
+INIT_MMX
+FILTER_SSSE3 4, 0, 0
+INIT_XMM
+FILTER_SSSE3 8, 8, 7
+
+; 4x4 block, H-only 4-tap filter
+cglobal put_vp8_epel4_h4_mmxext, 6, 6
+    shl       r5d, 4
+%ifdef PIC
+    lea       r11, [fourtap_filter_hw_m]
+%endif
+    movq      mm4, [fourtap_filter_hw+r5-16] ; set up 4tap filter in words
+    movq      mm5, [fourtap_filter_hw+r5]
+    movq      mm7, [pw_64]
+    pxor      mm6, mm6
+
+.nextrow
+    movq      mm1, [r2-1]                  ; (ABCDEFGH) load 8 horizontal pixels
+
+    ; first set of 2 pixels
+    movq      mm2, mm1                     ; byte ABCD..
+    punpcklbw mm1, mm6                     ; byte-&gt;word ABCD
+    pshufw    mm0, mm2, 9                  ; byte CDEF..
+    punpcklbw mm0, mm6                     ; byte-&gt;word CDEF
+    pshufw    mm3, mm1, 0x94               ; word ABBC
+    pshufw    mm1, mm0, 0x94               ; word CDDE
+    pmaddwd   mm3, mm4                     ; multiply 2px with F0/F1
+    movq      mm0, mm1                     ; backup for second set of pixels
+    pmaddwd   mm1, mm5                     ; multiply 2px with F2/F3
+    paddd     mm3, mm1                     ; finish 1st 2px
+
+    ; second set of 2 pixels, use backup of above
+    punpckhbw mm2, mm6                     ; byte-&gt;word EFGH
+    pmaddwd   mm0, mm4                     ; multiply backed up 2px with F0/F1
+    pshufw    mm1, mm2, 0x94               ; word EFFG
+    pmaddwd   mm1, mm5                     ; multiply 2px with F2/F3
+    paddd     mm0, mm1                     ; finish 2nd 2px
+
+    ; merge two sets of 2 pixels into one set of 4, round/clip/store
+    packssdw  mm3, mm0                     ; merge dword-&gt;word (4px)
+    paddsw    mm3, mm7                     ; rounding
+    psraw     mm3, 7
+    packuswb  mm3, mm6                     ; clip and word-&gt;bytes
+    movd     [r0], mm3                     ; store
+
+    ; go to next line
+    add        r0, r1
+    add        r2, r3
+    dec        r4                          ; next row
+    jg .nextrow
+    REP_RET
+
+; 4x4 block, H-only 6-tap filter
+cglobal put_vp8_epel4_h6_mmxext, 6, 6
+    lea       r5d, [r5*3]
+%ifdef PIC
+    lea       r11, [sixtap_filter_hw_m]
+%endif
+    movq      mm4, [sixtap_filter_hw+r5*8-48] ; set up 4tap filter in words
+    movq      mm5, [sixtap_filter_hw+r5*8-32]
+    movq      mm6, [sixtap_filter_hw+r5*8-16]
+    movq      mm7, [pw_64]
+    pxor      mm3, mm3
+
+.nextrow
+    movq      mm1, [r2-2]                  ; (ABCDEFGH) load 8 horizontal pixels
+
+    ; first set of 2 pixels
+    movq      mm2, mm1                     ; byte ABCD..
+    punpcklbw mm1, mm3                     ; byte-&gt;word ABCD
+    pshufw    mm0, mm2, 0x9                ; byte CDEF..
+    punpckhbw mm2, mm3                     ; byte-&gt;word EFGH
+    punpcklbw mm0, mm3                     ; byte-&gt;word CDEF
+    pshufw    mm1, mm1, 0x94               ; word ABBC
+    pshufw    mm2, mm2, 0x94               ; word EFFG
+    pmaddwd   mm1, mm4                     ; multiply 2px with F0/F1
+    pshufw    mm3, mm0, 0x94               ; word CDDE
+    movq      mm0, mm3                     ; backup for second set of pixels
+    pmaddwd   mm3, mm5                     ; multiply 2px with F2/F3
+    paddd     mm1, mm3                     ; add to 1st 2px cache
+    movq      mm3, mm2                     ; backup for second set of pixels
+    pmaddwd   mm2, mm6                     ; multiply 2px with F4/F5
+    paddd     mm1, mm2                     ; finish 1st 2px
+
+    ; second set of 2 pixels, use backup of above
+    movd      mm2, [r2+3]                  ; byte FGHI (prevent overreads)
+    pmaddwd   mm0, mm4                     ; multiply 1st backed up 2px with F0/F1
+    pmaddwd   mm3, mm5                     ; multiply 2nd backed up 2px with F2/F3
+    paddd     mm0, mm3                     ; add to 2nd 2px cache
+    pxor      mm3, mm3
+    punpcklbw mm2, mm3                     ; byte-&gt;word FGHI
+    pshufw    mm2, mm2, 0xE9               ; word GHHI
+    pmaddwd   mm2, mm6                     ; multiply 2px with F4/F5
+    paddd     mm0, mm2                     ; finish 2nd 2px
+
+    ; merge two sets of 2 pixels into one set of 4, round/clip/store
+    packssdw  mm1, mm0                     ; merge dword-&gt;word (4px)
+    paddsw    mm1, mm7                     ; rounding
+    psraw     mm1, 7
+    packuswb  mm1, mm3                     ; clip and word-&gt;bytes
+    movd     [r0], mm1                     ; store
+
+    ; go to next line
+    add        r0, r1
+    add        r2, r3
+    dec        r4                          ; next row
+    jg .nextrow
+    REP_RET
+
+; 4x4 block, H-only 4-tap filter
+INIT_XMM
+cglobal put_vp8_epel8_h4_sse2, 6, 6, 8
+    shl      r5d, 4
+%ifdef PIC
+    lea      r11, [fourtap_filter_hw_m]
+%endif
+    mova      m5, [fourtap_filter_hw+r5-16] ; set up 4tap filter in words
+    mova      m6, [fourtap_filter_hw+r5]
+    pxor      m7, m7
+
+.nextrow
+    movh      m0, [r2-1]
+    punpcklbw m0, m7        ; ABCDEFGH
+    mova      m1, m0
+    mova      m2, m0
+    mova      m3, m0
+    psrldq    m1, 2         ; BCDEFGH
+    psrldq    m2, 4         ; CDEFGH
+    psrldq    m3, 6         ; DEFGH
+    punpcklwd m0, m1        ; ABBCCDDE
+    punpcklwd m2, m3        ; CDDEEFFG
+    pmaddwd   m0, m5
+    pmaddwd   m2, m6
+    paddd     m0, m2
+
+    movh      m1, [r2+3]
+    punpcklbw m1, m7        ; ABCDEFGH
+    mova      m2, m1
+    mova      m3, m1
+    mova      m4, m1
+    psrldq    m2, 2         ; BCDEFGH
+    psrldq    m3, 4         ; CDEFGH
+    psrldq    m4, 6         ; DEFGH
+    punpcklwd m1, m2        ; ABBCCDDE
+    punpcklwd m3, m4        ; CDDEEFFG
+    pmaddwd   m1, m5
+    pmaddwd   m3, m6
+    paddd     m1, m3
+
+    packssdw  m0, m1
+    paddsw    m0, [pw_64]
+    psraw     m0, 7
+    packuswb  m0, m7
+    movh    [r0], m0        ; store
+
+    ; go to next line
+    add       r0, r1
+    add       r2, r3
+    dec       r4            ; next row
+    jg .nextrow
+    REP_RET
+
+cglobal put_vp8_epel8_h6_sse2, 6, 6, 8
+    lea      r5d, [r5*3]
+%ifdef PIC
+    lea      r11, [sixtap_filter_hw_m]
+%endif
+    lea       r5, [sixtap_filter_hw+r5*8]
+    pxor      m7, m7
+
+.nextrow
+    movu      m0, [r2-2]
+    mova      m6, m0
+    mova      m4, m0
+    punpcklbw m0, m7        ; ABCDEFGHI
+    mova      m1, m0
+    mova      m2, m0
+    mova      m3, m0
+    psrldq    m1, 2         ; BCDEFGH
+    psrldq    m2, 4         ; CDEFGH
+    psrldq    m3, 6         ; DEFGH
+    psrldq    m4, 4
+    punpcklbw m4, m7        ; EFGH
+    mova      m5, m4
+    psrldq    m5, 2         ; FGH
+    punpcklwd m0, m1        ; ABBCCDDE
+    punpcklwd m2, m3        ; CDDEEFFG
+    punpcklwd m4, m5        ; EFFGGHHI
+    pmaddwd   m0, [r5-48]
+    pmaddwd   m2, [r5-32]
+    pmaddwd   m4, [r5-16]
+    paddd     m0, m2
+    paddd     m0, m4
+
+    psrldq    m6, 4
+    mova      m4, m6
+    punpcklbw m6, m7        ; ABCDEFGHI
+    mova      m1, m6
+    mova      m2, m6
+    mova      m3, m6
+    psrldq    m1, 2         ; BCDEFGH
+    psrldq    m2, 4         ; CDEFGH
+    psrldq    m3, 6         ; DEFGH
+    psrldq    m4, 4
+    punpcklbw m4, m7        ; EFGH
+    mova      m5, m4
+    psrldq    m5, 2         ; FGH
+    punpcklwd m6, m1        ; ABBCCDDE
+    punpcklwd m2, m3        ; CDDEEFFG
+    punpcklwd m4, m5        ; EFFGGHHI
+    pmaddwd   m6, [r5-48]
+    pmaddwd   m2, [r5-32]
+    pmaddwd   m4, [r5-16]
+    paddd     m6, m2
+    paddd     m6, m4
+
+    packssdw  m0, m6
+    paddsw    m0, [pw_64]
+    psraw     m0, 7
+    packuswb  m0, m7
+    movh    [r0], m0        ; store
+
+    ; go to next line
+    add       r0, r1
+    add       r2, r3
+    dec       r4            ; next row
+    jg .nextrow
+    REP_RET
+
+%macro FILTER_V 3
+; 4x4 block, V-only 4-tap filter
+cglobal put_vp8_epel%2_v4_%1, 7, 7, %3
+    shl      r6d, 5
+%ifdef PIC
+    lea      r11, [fourtap_filter_v_m]
+%endif
+    lea       r6, [fourtap_filter_v+r6-32]
+    mova      m6, [pw_64]
+    pxor      m7, m7
+    mova      m5, [r6+48]
+
+    ; read 3 lines
+    sub       r2, r3
+    movh      m0, [r2]
+    movh      m1, [r2+  r3]
+    movh      m2, [r2+2*r3]
+    add       r2, r3
+    punpcklbw m0, m7
+    punpcklbw m1, m7
+    punpcklbw m2, m7
+
+.nextrow
+    ; first calculate negative taps (to prevent losing positive overflows)
+    movh      m4, [r2+2*r3]                ; read new row
+    punpcklbw m4, m7
+    mova      m3, m4
+    pmullw    m0, [r6+0]
+    pmullw    m4, m5
+    paddsw    m4, m0
+
+    ; then calculate positive taps
+    mova      m0, m1
+    pmullw    m1, [r6+16]
+    paddsw    m4, m1
+    mova      m1, m2
+    pmullw    m2, [r6+32]
+    paddsw    m4, m2
+    mova      m2, m3
+
+    ; round/clip/store
+    paddsw    m4, m6
+    psraw     m4, 7
+    packuswb  m4, m7
+    movh    [r0], m4
+
+    ; go to next line
+    add       r0, r1
+    add       r2, r3
+    dec       r4                           ; next row
+    jg .nextrow
+    REP_RET
+
+
+; 4x4 block, V-only 6-tap filter
+cglobal put_vp8_epel%2_v6_%1, 7, 7, %3
+    shl      r6d, 4
+    lea       r6, [r6*3]
+%ifdef PIC
+    lea      r11, [sixtap_filter_v_m]
+%endif
+    lea       r6, [sixtap_filter_v+r6-96]
+    pxor      m7, m7
+
+    ; read 5 lines
+    sub       r2, r3
+    sub       r2, r3
+    movh      m0, [r2]
+    movh      m1, [r2+r3]
+    movh      m2, [r2+r3*2]
+    lea       r2, [r2+r3*2]
+    add       r2, r3
+    movh      m3, [r2]
+    movh      m4, [r2+r3]
+    punpcklbw m0, m7
+    punpcklbw m1, m7
+    punpcklbw m2, m7
+    punpcklbw m3, m7
+    punpcklbw m4, m7
+
+.nextrow
+    ; first calculate negative taps (to prevent losing positive overflows)
+    mova      m5, m1
+    pmullw    m5, [r6+16]
+    mova      m6, m4
+    pmullw    m6, [r6+64]
+    paddsw    m6, m5
+
+    ; then calculate positive taps
+    movh      m5, [r2+2*r3]                ; read new row
+    punpcklbw m5, m7
+    pmullw    m0, [r6+0]
+    paddsw    m6, m0
+    mova      m0, m1
+    mova      m1, m2
+    pmullw    m2, [r6+32]
+    paddsw    m6, m2
+    mova      m2, m3
+    pmullw    m3, [r6+48]
+    paddsw    m6, m3
+    mova      m3, m4
+    mova      m4, m5
+    pmullw    m5, [r6+80]
+    paddsw    m6, m5
+
+    ; round/clip/store
+    paddsw    m6, [pw_64]
+    psraw     m6, 7
+    packuswb  m6, m7
+    movh    [r0], m6
+
+    ; go to next line
+    add       r0, r1
+    add       r2, r3
+    dec       r4                           ; next row
+    jg .nextrow
+    REP_RET
+%endmacro
+
+INIT_MMX
+FILTER_V mmxext, 4, 0
+INIT_XMM
+FILTER_V sse2,   8, 8
+
+%macro FILTER_BILINEAR 3
+cglobal put_vp8_bilinear%2_v_%1, 7,7,%3
+    mov      r5d, 8*16
+    shl      r6d, 4
+    sub      r5d, r6d
+%ifdef PIC
+    lea      r11, [bilinear_filter_vw_m]
+%endif
+    pxor      m6, m6
+    mova      m4, [bilinear_filter_vw+r5-16]
+    mova      m5, [bilinear_filter_vw+r6-16]
+.nextrow
+    movh      m0, [r2+r3*0]
+    movh      m1, [r2+r3*1]
+    movh      m3, [r2+r3*2]
+    punpcklbw m0, m6
+    punpcklbw m1, m6
+    punpcklbw m3, m6
+    mova      m2, m1
+    pmullw    m0, m4
+    pmullw    m1, m5
+    pmullw    m2, m4
+    pmullw    m3, m5
+    paddsw    m0, m1
+    paddsw    m2, m3
+    psraw     m0, 2
+    psraw     m2, 2
+    pavgw     m0, m6
+    pavgw     m2, m6
+%ifidn %1, mmxext
+    packuswb  m0, m0
+    packuswb  m2, m2
+    movh [r0+r1*0], m0
+    movh [r0+r1*1], m2
+%else
+    packuswb  m0, m2
+    movh   [r0+r1*0], m0
+    movhps [r0+r1*1], m0
+%endif
+
+    lea       r0, [r0+r1*2]
+    lea       r2, [r2+r3*2]
+    sub       r4, 2
+    jg .nextrow
+    REP_RET
+
+cglobal put_vp8_bilinear%2_h_%1, 7,7,%3
+    mov      r6d, 8*16
+    shl      r5d, 4
+    sub      r6d, r5d
+%ifdef PIC
+    lea      r11, [bilinear_filter_vw_m]
+%endif
+    pxor      m6, m6
+    mova      m4, [bilinear_filter_vw+r6-16]
+    mova      m5, [bilinear_filter_vw+r5-16]
+.nextrow
+    movh      m0, [r2+r3*0+0]
+    movh      m1, [r2+r3*0+1]
+    movh      m2, [r2+r3*1+0]
+    movh      m3, [r2+r3*1+1]
+    punpcklbw m0, m6
+    punpcklbw m1, m6
+    punpcklbw m2, m6
+    punpcklbw m3, m6
+    pmullw    m0, m4
+    pmullw    m1, m5
+    pmullw    m2, m4
+    pmullw    m3, m5
+    paddsw    m0, m1
+    paddsw    m2, m3
+    psraw     m0, 2
+    psraw     m2, 2
+    pavgw     m0, m6
+    pavgw     m2, m6
+%ifidn %1, mmxext
+    packuswb  m0, m0
+    packuswb  m2, m2
+    movh [r0+r1*0], m0
+    movh [r0+r1*1], m2
+%else
+    packuswb  m0, m2
+    movh   [r0+r1*0], m0
+    movhps [r0+r1*1], m0
+%endif
+
+    lea       r0, [r0+r1*2]
+    lea       r2, [r2+r3*2]
+    sub       r4, 2
+    jg .nextrow
+    REP_RET
+%endmacro
+
+INIT_MMX
+FILTER_BILINEAR mmxext, 4, 0
+INIT_XMM
+FILTER_BILINEAR   sse2, 8, 7
+
+%macro FILTER_BILINEAR_SSSE3 1
+cglobal put_vp8_bilinear%1_v_ssse3, 7,7
+    shl      r6d, 4
+%ifdef PIC
+    lea      r11, [bilinear_filter_vb_m]
+%endif
+    pxor      m4, m4
+    mova      m3, [bilinear_filter_vb+r6-16]
+.nextrow
+    movh      m0, [r2+r3*0]
+    movh      m1, [r2+r3*1]
+    movh      m2, [r2+r3*2]
+    punpcklbw m0, m1
+    punpcklbw m1, m2
+    pmaddubsw m0, m3
+    pmaddubsw m1, m3
+    psraw     m0, 2
+    psraw     m1, 2
+    pavgw     m0, m4
+    pavgw     m1, m4
+%if mmsize==8
+    packuswb  m0, m0
+    packuswb  m1, m1
+    movh [r0+r1*0], m0
+    movh [r0+r1*1], m1
+%else
+    packuswb  m0, m1
+    movh   [r0+r1*0], m0
+    movhps [r0+r1*1], m0
+%endif
+
+    lea       r0, [r0+r1*2]
+    lea       r2, [r2+r3*2]
+    sub       r4, 2
+    jg .nextrow
+    REP_RET
+
+cglobal put_vp8_bilinear%1_h_ssse3, 7,7
+    shl      r5d, 4
+%ifdef PIC
+    lea      r11, [bilinear_filter_vb_m]
+%endif
+    pxor      m4, m4
+    mova      m2, [filter_h2_shuf]
+    mova      m3, [bilinear_filter_vb+r5-16]
+.nextrow
+    movu      m0, [r2+r3*0]
+    movu      m1, [r2+r3*1]
+    pshufb    m0, m2
+    pshufb    m1, m2
+    pmaddubsw m0, m3
+    pmaddubsw m1, m3
+    psraw     m0, 2
+    psraw     m1, 2
+    pavgw     m0, m4
+    pavgw     m1, m4
+%if mmsize==8
+    packuswb  m0, m0
+    packuswb  m1, m1
+    movh [r0+r1*0], m0
+    movh [r0+r1*1], m1
+%else
+    packuswb  m0, m1
+    movh   [r0+r1*0], m0
+    movhps [r0+r1*1], m0
+%endif
+
+    lea       r0, [r0+r1*2]
+    lea       r2, [r2+r3*2]
+    sub       r4, 2
+    jg .nextrow
+    REP_RET
+%endmacro
+
+INIT_MMX
+FILTER_BILINEAR_SSSE3 4
+INIT_XMM
+FILTER_BILINEAR_SSSE3 8
+
+cglobal put_vp8_pixels8_mmx, 5,5
+.nextrow:
+    movq  mm0, [r2+r3*0]
+    movq  mm1, [r2+r3*1]
+    lea    r2, [r2+r3*2]
+    movq [r0+r1*0], mm0
+    movq [r0+r1*1], mm1
+    lea    r0, [r0+r1*2]
+    sub   r4d, 2
+    jg .nextrow
+    REP_RET
+
+cglobal put_vp8_pixels16_mmx, 5,5
+.nextrow:
+    movq  mm0, [r2+r3*0+0]
+    movq  mm1, [r2+r3*0+8]
+    movq  mm2, [r2+r3*1+0]
+    movq  mm3, [r2+r3*1+8]
+    lea    r2, [r2+r3*2]
+    movq [r0+r1*0+0], mm0
+    movq [r0+r1*0+8], mm1
+    movq [r0+r1*1+0], mm2
+    movq [r0+r1*1+8], mm3
+    lea    r0, [r0+r1*2]
+    sub   r4d, 2
+    jg .nextrow
+    REP_RET
+
+cglobal put_vp8_pixels16_sse, 5,5,2
+.nextrow:
+    movups xmm0, [r2+r3*0]
+    movups xmm1, [r2+r3*1]
+    lea     r2, [r2+r3*2]
+    movaps [r0+r1*0], xmm0
+    movaps [r0+r1*1], xmm1
+    lea     r0, [r0+r1*2]
+    sub    r4d, 2
+    jg .nextrow
+    REP_RET
+
+;-----------------------------------------------------------------------------
+; void vp8_idct_dc_add_&lt;opt&gt;(uint8_t *dst, DCTELEM block[16], int stride);
+;-----------------------------------------------------------------------------
+
+%macro ADD_DC 4
+    %4        m2, [r0+%3]
+    %4        m3, [r0+r2+%3]
+    %4        m4, [r1+%3]
+    %4        m5, [r1+r2+%3]
+    paddusb   m2, %1
+    paddusb   m3, %1
+    paddusb   m4, %1
+    paddusb   m5, %1
+    psubusb   m2, %2
+    psubusb   m3, %2
+    psubusb   m4, %2
+    psubusb   m5, %2
+    %4    [r0+%3], m2
+    %4 [r0+r2+%3], m3
+    %4    [r1+%3], m4
+    %4 [r1+r2+%3], m5
+%endmacro
+
+INIT_MMX
+cglobal vp8_idct_dc_add_mmx, 3, 3
+    ; load data
+    movd       m0, [r1]
+
+    ; calculate DC
+    paddw      m0, [pw_4]
+    pxor       m1, m1
+    psraw      m0, 3
+    movd      [r1], m1
+    psubw      m1, m0
+    packuswb   m0, m0
+    packuswb   m1, m1
+    punpcklbw  m0, m0
+    punpcklbw  m1, m1
+    punpcklwd  m0, m0
+    punpcklwd  m1, m1
+
+    ; add DC
+    lea        r1, [r0+r2*2]
+    ADD_DC     m0, m1, 0, movh
+    RET
+
+INIT_XMM
+cglobal vp8_idct_dc_add_sse4, 3, 3, 6
+    ; load data
+    movd       m0, [r1]
+    pxor       m1, m1
+
+    ; calculate DC
+    paddw      m0, [pw_4]
+    movd     [r1], m1
+    lea        r1, [r0+r2*2]
+    movd       m2, [r0]
+    movd       m3, [r0+r2]
+    movd       m4, [r1]
+    movd       m5, [r1+r2]
+    psraw      m0, 3
+    pshuflw    m0, m0, 0
+    punpcklqdq m0, m0
+    punpckldq  m2, m3
+    punpckldq  m4, m5
+    punpcklbw  m2, m1
+    punpcklbw  m4, m1
+    paddw      m2, m0
+    paddw      m4, m0
+    packuswb   m2, m4
+    movd      [r0], m2
+    pextrd [r0+r2], m2, 1
+    pextrd    [r1], m2, 2
+    pextrd [r1+r2], m2, 3
+    RET
+
+;-----------------------------------------------------------------------------
+; void vp8_idct_dc_add4y_&lt;opt&gt;(uint8_t *dst, DCTELEM block[4][16], int stride);
+;-----------------------------------------------------------------------------
+
+INIT_MMX
+cglobal vp8_idct_dc_add4y_mmx, 3, 3
+    ; load data
+    movd      m0, [r1+32*0] ; A
+    movd      m1, [r1+32*2] ; C
+    punpcklwd m0, [r1+32*1] ; A B
+    punpcklwd m1, [r1+32*3] ; C D
+    punpckldq m0, m1        ; A B C D
+    pxor      m6, m6
+
+    ; calculate DC
+    paddw     m0, [pw_4]
+    movd [r1+32*0], m6
+    movd [r1+32*1], m6
+    movd [r1+32*2], m6
+    movd [r1+32*3], m6
+    psraw     m0, 3
+    psubw     m6, m0
+    packuswb  m0, m0
+    packuswb  m6, m6
+    punpcklbw m0, m0 ; AABBCCDD
+    punpcklbw m6, m6 ; AABBCCDD
+    movq      m1, m0
+    movq      m7, m6
+    punpcklbw m0, m0 ; AAAABBBB
+    punpckhbw m1, m1 ; CCCCDDDD
+    punpcklbw m6, m6 ; AAAABBBB
+    punpckhbw m7, m7 ; CCCCDDDD
+
+    ; add DC
+    lea       r1, [r0+r2*2]
+    ADD_DC    m0, m6, 0, mova
+    ADD_DC    m1, m7, 8, mova
+    RET
+
+INIT_XMM
+cglobal vp8_idct_dc_add4y_sse2, 3, 3, 6
+    ; load data
+    movd      m0, [r1+32*0] ; A
+    movd      m1, [r1+32*2] ; C
+    punpcklwd m0, [r1+32*1] ; A B
+    punpcklwd m1, [r1+32*3] ; C D
+    punpckldq m0, m1        ; A B C D
+    pxor      m1, m1
+
+    ; calculate DC
+    paddw     m0, [pw_4]
+    movd [r1+32*0], m1
+    movd [r1+32*1], m1
+    movd [r1+32*2], m1
+    movd [r1+32*3], m1
+    psraw     m0, 3
+    psubw     m1, m0
+    packuswb  m0, m0
+    packuswb  m1, m1
+    punpcklbw m0, m0
+    punpcklbw m1, m1
+    punpcklbw m0, m0
+    punpcklbw m1, m1
+
+    ; add DC
+    lea       r1, [r0+r2*2]
+    ADD_DC    m0, m1, 0, mova
+    RET
+
+;-----------------------------------------------------------------------------
+; void vp8_idct_dc_add4uv_&lt;opt&gt;(uint8_t *dst, DCTELEM block[4][16], int stride);
+;-----------------------------------------------------------------------------
+
+INIT_MMX
+cglobal vp8_idct_dc_add4uv_mmx, 3, 3
+    ; load data
+    movd      m0, [r1+32*0] ; A
+    movd      m1, [r1+32*2] ; C
+    punpcklwd m0, [r1+32*1] ; A B
+    punpcklwd m1, [r1+32*3] ; C D
+    punpckldq m0, m1        ; A B C D
+    pxor      m6, m6
+
+    ; calculate DC
+    paddw     m0, [pw_4]
+    movd [r1+32*0], m6
+    movd [r1+32*1], m6
+    movd [r1+32*2], m6
+    movd [r1+32*3], m6
+    psraw     m0, 3
+    psubw     m6, m0
+    packuswb  m0, m0
+    packuswb  m6, m6
+    punpcklbw m0, m0 ; AABBCCDD
+    punpcklbw m6, m6 ; AABBCCDD
+    movq      m1, m0
+    movq      m7, m6
+    punpcklbw m0, m0 ; AAAABBBB
+    punpckhbw m1, m1 ; CCCCDDDD
+    punpcklbw m6, m6 ; AAAABBBB
+    punpckhbw m7, m7 ; CCCCDDDD
+
+    ; add DC
+    lea       r1, [r0+r2*2]
+    ADD_DC    m0, m6, 0, mova
+    lea       r0, [r0+r2*4]
+    lea       r1, [r1+r2*4]
+    ADD_DC    m1, m7, 0, mova
+    RET
+
+;-----------------------------------------------------------------------------
+; void vp8_idct_add_&lt;opt&gt;(uint8_t *dst, DCTELEM block[16], int stride);
+;-----------------------------------------------------------------------------
+
+; calculate %1=mul_35468(%1)-mul_20091(%2); %2=mul_20091(%1)+mul_35468(%2)
+;           this macro assumes that m6/m7 have words for 20091/17734 loaded
+%macro VP8_MULTIPLY_SUMSUB 4
+    mova      %3, %1
+    mova      %4, %2
+    pmulhw    %3, m6 ;20091(1)
+    pmulhw    %4, m6 ;20091(2)
+    paddw     %3, %1
+    paddw     %4, %2
+    paddw     %1, %1
+    paddw     %2, %2
+    pmulhw    %1, m7 ;35468(1)
+    pmulhw    %2, m7 ;35468(2)
+    psubw     %1, %4
+    paddw     %2, %3
+%endmacro
+
+; calculate x0=%1+%3; x1=%1-%3
+;           x2=mul_35468(%2)-mul_20091(%4); x3=mul_20091(%2)+mul_35468(%4)
+;           %1=x0+x3 (tmp0); %2=x1+x2 (tmp1); %3=x1-x2 (tmp2); %4=x0-x3 (tmp3)
+;           %5/%6 are temporary registers
+;           we assume m6/m7 have constant words 20091/17734 loaded in them
+%macro VP8_IDCT_TRANSFORM4x4_1D 6
+    SUMSUB_BA           m%3, m%1, m%5     ;t0, t1
+    VP8_MULTIPLY_SUMSUB m%2, m%4, m%5,m%6 ;t2, t3
+    SUMSUB_BA           m%4, m%3, m%5     ;tmp0, tmp3
+    SUMSUB_BA           m%2, m%1, m%5     ;tmp1, tmp2
+    SWAP                 %4,  %1
+    SWAP                 %4,  %3
+%endmacro
+
+INIT_MMX
+%macro VP8_IDCT_ADD 1
+cglobal vp8_idct_add_%1, 3, 3
+    ; load block data
+    movq         m0, [r1+ 0]
+    movq         m1, [r1+ 8]
+    movq         m2, [r1+16]
+    movq         m3, [r1+24]
+    movq         m6, [pw_20091]
+    movq         m7, [pw_17734]
+%ifidn %1, sse
+    xorps      xmm0, xmm0
+    movaps  [r1+ 0], xmm0
+    movaps  [r1+16], xmm0
+%else
+    pxor         m4, m4
+    movq    [r1+ 0], m4
+    movq    [r1+ 8], m4
+    movq    [r1+16], m4
+    movq    [r1+24], m4
+%endif
+
+    ; actual IDCT
+    VP8_IDCT_TRANSFORM4x4_1D 0, 1, 2, 3, 4, 5
+    TRANSPOSE4x4W            0, 1, 2, 3, 4
+    paddw        m0, [pw_4]
+    VP8_IDCT_TRANSFORM4x4_1D 0, 1, 2, 3, 4, 5
+    TRANSPOSE4x4W            0, 1, 2, 3, 4
+
+    ; store
+    pxor         m4, m4
+    lea          r1, [r0+2*r2]
+    STORE_DIFFx2 m0, m1, m6, m7, m4, 3, r0, r2
+    STORE_DIFFx2 m2, m3, m6, m7, m4, 3, r1, r2
+
+    RET
+%endmacro
+
+VP8_IDCT_ADD mmx
+VP8_IDCT_ADD sse
+
+;-----------------------------------------------------------------------------
+; void vp8_luma_dc_wht_mmxext(DCTELEM block[4][4][16], DCTELEM dc[16])
+;-----------------------------------------------------------------------------
+
+%macro SCATTER_WHT 3
+    movd  r1d, m%1
+    movd  r2d, m%2
+    mov [r0+2*16*(0+%3)], r1w
+    mov [r0+2*16*(1+%3)], r2w
+    shr   r1d, 16
+    shr   r2d, 16
+    psrlq m%1, 32
+    psrlq m%2, 32
+    mov [r0+2*16*(4+%3)], r1w
+    mov [r0+2*16*(5+%3)], r2w
+    movd  r1d, m%1
+    movd  r2d, m%2
+    mov [r0+2*16*(8+%3)], r1w
+    mov [r0+2*16*(9+%3)], r2w
+    shr   r1d, 16
+    shr   r2d, 16
+    mov [r0+2*16*(12+%3)], r1w
+    mov [r0+2*16*(13+%3)], r2w
+%endmacro
+
+%macro HADAMARD4_1D 4
+    SUMSUB_BADC m%2, m%1, m%4, m%3
+    SUMSUB_BADC m%4, m%2, m%3, m%1
+    SWAP %1, %4, %3
+%endmacro
+
+INIT_MMX
+cglobal vp8_luma_dc_wht_mmx, 2,3
+    movq          m0, [r1]
+    movq          m1, [r1+8]
+    movq          m2, [r1+16]
+    movq          m3, [r1+24]
+    HADAMARD4_1D  0, 1, 2, 3
+    TRANSPOSE4x4W 0, 1, 2, 3, 4
+    paddw         m0, [pw_3]
+    HADAMARD4_1D  0, 1, 2, 3
+    psraw         m0, 3
+    psraw         m1, 3
+    psraw         m2, 3
+    psraw         m3, 3
+    SCATTER_WHT   0, 1, 0
+    SCATTER_WHT   2, 3, 2
+    RET
+
+;-----------------------------------------------------------------------------
+; void vp8_h/v_loop_filter_simple_&lt;opt&gt;(uint8_t *dst, int stride, int flim);
+;-----------------------------------------------------------------------------
+
+; macro called with 7 mm register indexes as argument, and 4 regular registers
+;
+; first 4 mm registers will carry the transposed pixel data
+; the other three are scratchspace (one would be sufficient, but this allows
+; for more spreading/pipelining and thus faster execution on OOE CPUs)
+;
+; first two regular registers are buf+4*stride and buf+5*stride
+; third is -stride, fourth is +stride
+%macro READ_8x4_INTERLEAVED 11
+    ; interleave 8 (A-H) rows of 4 pixels each
+    movd          m%1, [%8+%10*4]   ; A0-3
+    movd          m%5, [%9+%10*4]   ; B0-3
+    movd          m%2, [%8+%10*2]   ; C0-3
+    movd          m%6, [%8+%10]     ; D0-3
+    movd          m%3, [%8]         ; E0-3
+    movd          m%7, [%9]         ; F0-3
+    movd          m%4, [%9+%11]     ; G0-3
+    punpcklbw     m%1, m%5          ; A/B interleaved
+    movd          m%5, [%9+%11*2]   ; H0-3
+    punpcklbw     m%2, m%6          ; C/D interleaved
+    punpcklbw     m%3, m%7          ; E/F interleaved
+    punpcklbw     m%4, m%5          ; G/H interleaved
+%endmacro
+
+; macro called with 7 mm register indexes as argument, and 5 regular registers
+; first 11 mean the same as READ_8x4_TRANSPOSED above
+; fifth regular register is scratchspace to reach the bottom 8 rows, it
+; will be set to second regular register + 8*stride at the end
+%macro READ_16x4_INTERLEAVED 12
+    ; transpose 16 (A-P) rows of 4 pixels each
+    lea           %12, [r0+8*r2]
+
+    ; read (and interleave) those addressable by %8 (=r0), A/C/D/E/I/K/L/M
+    movd          m%1, [%8+%10*4]   ; A0-3
+    movd          m%3, [%12+%10*4]  ; I0-3
+    movd          m%2, [%8+%10*2]   ; C0-3
+    movd          m%4, [%12+%10*2]  ; K0-3
+    movd          m%6, [%8+%10]     ; D0-3
+    movd          m%5, [%12+%10]    ; L0-3
+    movd          m%7, [%12]        ; M0-3
+    add           %12, %11
+    punpcklbw     m%1, m%3          ; A/I
+    movd          m%3, [%8]         ; E0-3
+    punpcklbw     m%2, m%4          ; C/K
+    punpcklbw     m%6, m%5          ; D/L
+    punpcklbw     m%3, m%7          ; E/M
+    punpcklbw     m%2, m%6          ; C/D/K/L interleaved
+
+    ; read (and interleave) those addressable by %9 (=r4), B/F/G/H/J/N/O/P
+    movd         m%5, [%9+%10*4]   ; B0-3
+    movd         m%4, [%12+%10*4]  ; J0-3
+    movd         m%7, [%9]         ; F0-3
+    movd         m%6, [%12]        ; N0-3
+    punpcklbw    m%5, m%4          ; B/J
+    punpcklbw    m%7, m%6          ; F/N
+    punpcklbw    m%1, m%5          ; A/B/I/J interleaved
+    punpcklbw    m%3, m%7          ; E/F/M/N interleaved
+    movd         m%4, [%9+%11]     ; G0-3
+    movd         m%6, [%12+%11]    ; O0-3
+    movd         m%5, [%9+%11*2]   ; H0-3
+    movd         m%7, [%12+%11*2]  ; P0-3
+    punpcklbw    m%4, m%6          ; G/O
+    punpcklbw    m%5, m%7          ; H/P
+    punpcklbw    m%4, m%5          ; G/H/O/P interleaved
+%endmacro
+
+; write 4 mm registers of 2 dwords each
+; first four arguments are mm register indexes containing source data
+; last four are registers containing buf+4*stride, buf+5*stride,
+; -stride and +stride
+%macro WRITE_4x2D 8
+    ; write out (2 dwords per register)
+    movd    [%5+%7*4], m%1
+    movd    [%5+%7*2], m%2
+    movd         [%5], m%3
+    movd      [%6+%8], m%4
+    punpckhdq     m%1, m%1
+    punpckhdq     m%2, m%2
+    punpckhdq     m%3, m%3
+    punpckhdq     m%4, m%4
+    movd    [%6+%7*4], m%1
+    movd      [%5+%7], m%2
+    movd         [%6], m%3
+    movd    [%6+%8*2], m%4
+%endmacro
+
+; write 4 xmm registers of 4 dwords each
+; arguments same as WRITE_2x4D, but with an extra register, so that the 5 regular
+; registers contain buf+4*stride, buf+5*stride, buf+12*stride, -stride and +stride
+; we add 1*stride to the third regular registry in the process
+; the 10th argument is 16 if it's a Y filter (i.e. all regular registers cover the
+; same memory region), or 8 if they cover two separate buffers (third one points to
+; a different memory region than the first two), allowing for more optimal code for
+; the 16-width case
+%macro WRITE_4x4D 10
+    ; write out (4 dwords per register), start with dwords zero
+    movd    [%5+%8*4], m%1
+    movd         [%5], m%2
+    movd    [%7+%8*4], m%3
+    movd         [%7], m%4
+
+    ; store dwords 1
+    psrldq        m%1, 4
+    psrldq        m%2, 4
+    psrldq        m%3, 4
+    psrldq        m%4, 4
+    movd    [%6+%8*4], m%1
+    movd         [%6], m%2
+%if %10 == 16
+    movd    [%6+%9*4], m%3
+%endif
+    movd      [%7+%9], m%4
+
+    ; write dwords 2
+    psrldq        m%1, 4
+    psrldq        m%2, 4
+%if %10 == 8
+    movd    [%5+%8*2], m%1
+    movd           %5, m%3
+%endif
+    psrldq        m%3, 4
+    psrldq        m%4, 4
+%if %10 == 16
+    movd    [%5+%8*2], m%1
+%endif
+    movd      [%6+%9], m%2
+    movd    [%7+%8*2], m%3
+    movd    [%7+%9*2], m%4
+    add            %7, %9
+
+    ; store dwords 3
+    psrldq        m%1, 4
+    psrldq        m%2, 4
+    psrldq        m%3, 4
+    psrldq        m%4, 4
+%if %10 == 8
+    mov     [%7+%8*4], %5d
+    movd    [%6+%8*2], m%1
+%else
+    movd      [%5+%8], m%1
+%endif
+    movd    [%6+%9*2], m%2
+    movd    [%7+%8*2], m%3
+    movd    [%7+%9*2], m%4
+%endmacro
+
+%macro SPLATB_REG_MMX 2-3
+    movd           %1, %2
+    punpcklbw      %1, %1
+    punpcklwd      %1, %1
+    punpckldq      %1, %1
+%endmacro
+
+%macro SPLATB_REG_MMXEXT 2-3
+    movd           %1, %2
+    punpcklbw      %1, %1
+    pshufw         %1, %1, 0x0
+%endmacro
+
+%macro SPLATB_REG_SSE2 2-3
+    movd           %1, %2
+    punpcklbw      %1, %1
+    pshuflw        %1, %1, 0x0
+    punpcklqdq     %1, %1
+%endmacro
+
+%macro SPLATB_REG_SSSE3 3
+    movd           %1, %2
+    pshufb         %1, %3
+%endmacro
+
+%macro SIMPLE_LOOPFILTER 3
+cglobal vp8_%2_loop_filter_simple_%1, 3, %3
+%ifidn %2, h
+    mov            r5, rsp          ; backup stack pointer
+    and           rsp, ~(mmsize-1)  ; align stack
+%endif
+%if mmsize == 8 ; mmx/mmxext
+    mov            r3, 2
+%endif
+%ifnidn %1, sse2 &amp;&amp; mmsize == 16
+    pxor           m0, m0
+%endif
+    SPLATB_REG     m7, r2, m0       ; splat &quot;flim&quot; into register
+
+    ; set up indexes to address 4 rows
+    mov            r2, r1
+    neg            r1
+%ifidn %2, h
+    lea            r0, [r0+4*r2-2]
+    sub           rsp, mmsize*2     ; (aligned) storage space for saving p1/q1
+%endif
+
+%if mmsize == 8 ; mmx / mmxext
+.next8px
+%endif
+%ifidn %2, v
+    ; read 4 half/full rows of pixels
+    mova           m0, [r0+r1*2]    ; p1
+    mova           m1, [r0+r1]      ; p0
+    mova           m2, [r0]         ; q0
+    mova           m3, [r0+r2]      ; q1
+%else ; h
+    lea            r4, [r0+r2]
+
+%if mmsize == 8 ; mmx/mmxext
+    READ_8x4_INTERLEAVED  0, 1, 2, 3, 4, 5, 6, r0, r4, r1, r2
+%else ; sse2
+    READ_16x4_INTERLEAVED 0, 1, 2, 3, 4, 5, 6, r0, r4, r1, r2, r3
+%endif
+    TRANSPOSE4x4W         0, 1, 2, 3, 4
+
+    mova        [rsp], m0           ; store p1
+    mova [rsp+mmsize], m3           ; store q1
+%endif
+
+    ; simple_limit
+    mova           m5, m2           ; m5=backup of q0
+    mova           m6, m1           ; m6=backup of p0
+    psubusb        m1, m2           ; p0-q0
+    psubusb        m2, m6           ; q0-p0
+    por            m1, m2           ; FFABS(p0-q0)
+    paddusb        m1, m1           ; m1=FFABS(p0-q0)*2
+
+    mova           m4, m3
+    mova           m2, m0
+    psubusb        m3, m0           ; q1-p1
+    psubusb        m0, m4           ; p1-q1
+    por            m3, m0           ; FFABS(p1-q1)
+    mova           m0, [pb_80]
+    pxor           m2, m0
+    pxor           m4, m0
+    psubsb         m2, m4           ; m2=p1-q1 (signed) backup for below
+    pand           m3, [pb_FE]
+    psrlq          m3, 1            ; m3=FFABS(p1-q1)/2, this can be used signed
+    paddusb        m3, m1
+    psubusb        m3, m7
+    pxor           m1, m1
+    pcmpeqb        m3, m1           ; abs(p0-q0)*2+abs(p1-q1)/2&lt;=flim mask(0xff/0x0)
+
+    ; filter_common (use m2/p1-q1, m4=q0, m6=p0, m5/q0-p0 and m3/mask)
+    mova           m4, m5
+    pxor           m5, m0
+    pxor           m0, m6
+    psubsb         m5, m0           ; q0-p0 (signed)
+    paddsb         m2, m5
+    paddsb         m2, m5
+    paddsb         m2, m5           ; a=(p1-q1) + 3*(q0-p0)
+    pand           m2, m3           ; apply filter mask (m3)
+
+    mova           m3, [pb_F8]
+    mova           m1, m2
+    paddsb         m2, [pb_4]       ; f1&lt;&lt;3=a+4
+    paddsb         m1, [pb_3]       ; f2&lt;&lt;3=a+3
+    pand           m2, m3
+    pand           m1, m3           ; cache f2&lt;&lt;3
+
+    pxor           m0, m0
+    pxor           m3, m3
+    pcmpgtb        m0, m2           ; which values are &lt;0?
+    psubb          m3, m2           ; -f1&lt;&lt;3
+    psrlq          m2, 3            ; +f1
+    psrlq          m3, 3            ; -f1
+    pand           m3, m0
+    pandn          m0, m2
+    psubusb        m4, m0
+    paddusb        m4, m3           ; q0-f1
+
+    pxor           m0, m0
+    pxor           m3, m3
+    pcmpgtb        m0, m1           ; which values are &lt;0?
+    psubb          m3, m1           ; -f2&lt;&lt;3
+    psrlq          m1, 3            ; +f2
+    psrlq          m3, 3            ; -f2
+    pand           m3, m0
+    pandn          m0, m1
+    paddusb        m6, m0
+    psubusb        m6, m3           ; p0+f2
+
+    ; store
+%ifidn %2, v
+    mova         [r0], m4
+    mova      [r0+r1], m6
+%else ; h
+    mova           m0, [rsp]        ; p1
+    SWAP            2, 4            ; p0
+    SWAP            1, 6            ; q0
+    mova           m3, [rsp+mmsize] ; q1
+
+    TRANSPOSE4x4B  0, 1, 2, 3, 4
+%if mmsize == 16 ; sse2
+    add            r3, r1           ; change from r4*8*stride to r0+8*stride
+    WRITE_4x4D 0, 1, 2, 3, r0, r4, r3, r1, r2, 16
+%else ; mmx/mmxext
+    WRITE_4x2D 0, 1, 2, 3, r0, r4, r1, r2
+%endif
+%endif
+
+%if mmsize == 8 ; mmx/mmxext
+    ; next 8 pixels
+%ifidn %2, v
+    add            r0, 8            ; advance 8 cols = pixels
+%else ; h
+    lea            r0, [r0+r2*8]    ; advance 8 rows = lines
+%endif
+    dec            r3
+    jg .next8px
+%ifidn %2, v
+    REP_RET
+%else ; h
+    mov           rsp, r5           ; restore stack pointer
+    RET
+%endif
+%else ; sse2
+%ifidn %2, h
+    mov           rsp, r5           ; restore stack pointer
+%endif
+    RET
+%endif
+%endmacro
+
+INIT_MMX
+%define SPLATB_REG SPLATB_REG_MMX
+SIMPLE_LOOPFILTER mmx,    v, 4
+SIMPLE_LOOPFILTER mmx,    h, 6
+%define SPLATB_REG SPLATB_REG_MMXEXT
+SIMPLE_LOOPFILTER mmxext, v, 4
+SIMPLE_LOOPFILTER mmxext, h, 6
+INIT_XMM
+%define SPLATB_REG SPLATB_REG_SSE2
+SIMPLE_LOOPFILTER sse2,   v, 3
+SIMPLE_LOOPFILTER sse2,   h, 6
+%define SPLATB_REG SPLATB_REG_SSSE3
+SIMPLE_LOOPFILTER ssse3,  v, 3
+SIMPLE_LOOPFILTER ssse3,  h, 6
+
+;-----------------------------------------------------------------------------
+; void vp8_h/v_loop_filter&lt;size&gt;_inner_&lt;opt&gt;(uint8_t *dst, [uint8_t *v,] int stride,
+;                                            int flimE, int flimI, int hev_thr);
+;-----------------------------------------------------------------------------
+
+%macro INNER_LOOPFILTER 5
+%if %4 == 8 ; chroma
+cglobal vp8_%2_loop_filter8uv_inner_%1, 6, %3, %5
+%define dst8_reg    r1
+%define mstride_reg r2
+%define E_reg       r3
+%define I_reg       r4
+%define hev_thr_reg r5
+%else ; luma
+cglobal vp8_%2_loop_filter16y_inner_%1, 5, %3, %5
+%define mstride_reg r1
+%define E_reg       r2
+%define I_reg       r3
+%define hev_thr_reg r4
+%ifdef m8 ; x86-64, sse2
+%define dst8_reg    r4
+%elif mmsize == 16 ; x86-32, sse2
+%define dst8_reg    r5
+%else ; x86-32, mmx/mmxext
+%define cnt_reg     r5
+%endif
+%endif
+%define dst_reg     r0
+%define stride_reg  E_reg
+%define dst2_reg    I_reg
+%ifndef m8
+%define stack_reg   hev_thr_reg
+%endif
+
+%ifnidn %1, sse2 &amp;&amp; mmsize == 16
+    pxor             m7, m7
+%endif
+
+%ifndef m8 ; mmx/mmxext or sse2 on x86-32
+    ; splat function arguments
+    SPLATB_REG       m0, E_reg, m7   ; E
+    SPLATB_REG       m1, I_reg, m7   ; I
+    SPLATB_REG       m2, hev_thr_reg, m7 ; hev_thresh
+
+    ; align stack
+    mov       stack_reg, rsp         ; backup stack pointer
+    and             rsp, ~(mmsize-1) ; align stack
+%ifidn %2, v
+    sub             rsp, mmsize * 4  ; stack layout: [0]=E, [1]=I, [2]=hev_thr
+                                     ;               [3]=hev() result
+%else ; h
+    sub             rsp, mmsize * 5  ; extra storage space for transposes
+%endif
+
+%define flim_E   [rsp]
+%define flim_I   [rsp+mmsize]
+%define hev_thr  [rsp+mmsize*2]
+%define mask_res [rsp+mmsize*3]
+%define p0backup [rsp+mmsize*3]
+%define q0backup [rsp+mmsize*4]
+
+    mova         flim_E, m0
+    mova         flim_I, m1
+    mova        hev_thr, m2
+
+%else ; sse2 on x86-64
+
+%define flim_E   m9
+%define flim_I   m10
+%define hev_thr  m11
+%define mask_res m12
+%define p0backup m12
+%define q0backup m8
+
+    ; splat function arguments
+    SPLATB_REG   flim_E, E_reg, m7   ; E
+    SPLATB_REG   flim_I, I_reg, m7   ; I
+    SPLATB_REG  hev_thr, hev_thr_reg, m7 ; hev_thresh
+%endif
+
+%if mmsize == 8 &amp;&amp; %4 == 16 ; mmx/mmxext
+    mov         cnt_reg, 2
+%endif
+    mov      stride_reg, mstride_reg
+    neg     mstride_reg
+%ifidn %2, h
+    lea         dst_reg, [dst_reg + stride_reg*4-4]
+%if %4 == 8
+    lea        dst8_reg, [dst8_reg+ stride_reg*4-4]
+%endif
+%endif
+
+%if mmsize == 8
+.next8px
+%endif
+    ; read
+    lea        dst2_reg, [dst_reg + stride_reg]
+%ifidn %2, v
+%if %4 == 8 &amp;&amp; mmsize == 16
+%define movrow movh
+%else
+%define movrow mova
+%endif
+    movrow           m0, [dst_reg +mstride_reg*4] ; p3
+    movrow           m1, [dst2_reg+mstride_reg*4] ; p2
+    movrow           m2, [dst_reg +mstride_reg*2] ; p1
+    movrow           m5, [dst2_reg]               ; q1
+    movrow           m6, [dst2_reg+ stride_reg]   ; q2
+    movrow           m7, [dst2_reg+ stride_reg*2] ; q3
+%if mmsize == 16 &amp;&amp; %4 == 8
+    movhps           m0, [dst8_reg+mstride_reg*4]
+    movhps           m2, [dst8_reg+mstride_reg*2]
+    add        dst8_reg, stride_reg
+    movhps           m1, [dst8_reg+mstride_reg*4]
+    movhps           m5, [dst8_reg]
+    movhps           m6, [dst8_reg+ stride_reg]
+    movhps           m7, [dst8_reg+ stride_reg*2]
+    add        dst8_reg, mstride_reg
+%endif
+%elif mmsize == 8 ; mmx/mmxext (h)
+    ; read 8 rows of 8px each
+    movu             m0, [dst_reg +mstride_reg*4]
+    movu             m1, [dst2_reg+mstride_reg*4]
+    movu             m2, [dst_reg +mstride_reg*2]
+    movu             m3, [dst_reg +mstride_reg]
+    movu             m4, [dst_reg]
+    movu             m5, [dst2_reg]
+    movu             m6, [dst2_reg+ stride_reg]
+
+    ; 8x8 transpose
+    TRANSPOSE4x4B     0, 1, 2, 3, 7
+    mova       q0backup, m1
+    movu             m7, [dst2_reg+ stride_reg*2]
+    TRANSPOSE4x4B     4, 5, 6, 7, 1
+    SBUTTERFLY       dq, 0, 4, 1     ; p3/p2
+    SBUTTERFLY       dq, 2, 6, 1     ; q0/q1
+    SBUTTERFLY       dq, 3, 7, 1     ; q2/q3
+    mova             m1, q0backup
+    mova       q0backup, m2          ; store q0
+    SBUTTERFLY       dq, 1, 5, 2     ; p1/p0
+    mova       p0backup, m5          ; store p0
+    SWAP              1, 4
+    SWAP              2, 4
+    SWAP              6, 3
+    SWAP              5, 3
+%else ; sse2 (h)
+%if %4 == 16
+    lea        dst8_reg, [dst_reg + stride_reg*8]
+%endif
+
+    ; read 16 rows of 8px each, interleave
+    movh             m0, [dst_reg +mstride_reg*4]
+    movh             m1, [dst8_reg+mstride_reg*4]
+    movh             m2, [dst_reg +mstride_reg*2]
+    movh             m5, [dst8_reg+mstride_reg*2]
+    movh             m3, [dst_reg +mstride_reg]
+    movh             m6, [dst8_reg+mstride_reg]
+    movh             m4, [dst_reg]
+    movh             m7, [dst8_reg]
+    punpcklbw        m0, m1          ; A/I
+    punpcklbw        m2, m5          ; C/K
+    punpcklbw        m3, m6          ; D/L
+    punpcklbw        m4, m7          ; E/M
+
+    add        dst8_reg, stride_reg
+    movh             m1, [dst2_reg+mstride_reg*4]
+    movh             m6, [dst8_reg+mstride_reg*4]
+    movh             m5, [dst2_reg]
+    movh             m7, [dst8_reg]
+    punpcklbw        m1, m6          ; B/J
+    punpcklbw        m5, m7          ; F/N
+    movh             m6, [dst2_reg+ stride_reg]
+    movh             m7, [dst8_reg+ stride_reg]
+    punpcklbw        m6, m7          ; G/O
+
+    ; 8x16 transpose
+    TRANSPOSE4x4B     0, 1, 2, 3, 7
+%ifdef m8
+    SWAP              1, 8
+%else
+    mova       q0backup, m1
+%endif
+    movh             m7, [dst2_reg+ stride_reg*2]
+    movh             m1, [dst8_reg+ stride_reg*2]
+    punpcklbw        m7, m1          ; H/P
+    TRANSPOSE4x4B     4, 5, 6, 7, 1
+    SBUTTERFLY       dq, 0, 4, 1     ; p3/p2
+    SBUTTERFLY       dq, 2, 6, 1     ; q0/q1
+    SBUTTERFLY       dq, 3, 7, 1     ; q2/q3
+%ifdef m8
+    SWAP              1, 8
+    SWAP              2, 8
+%else
+    mova             m1, q0backup
+    mova       q0backup, m2          ; store q0
+%endif
+    SBUTTERFLY       dq, 1, 5, 2     ; p1/p0
+%ifdef m12
+    SWAP              5, 12
+%else
+    mova       p0backup, m5          ; store p0
+%endif
+    SWAP              1, 4
+    SWAP              2, 4
+    SWAP              6, 3
+    SWAP              5, 3
+%endif
+
+    ; normal_limit for p3-p2, p2-p1, q3-q2 and q2-q1
+    mova             m4, m1
+    SWAP              4, 1
+    psubusb          m4, m0          ; p2-p3
+    psubusb          m0, m1          ; p3-p2
+    por              m0, m4          ; abs(p3-p2)
+
+    mova             m4, m2
+    SWAP              4, 2
+    psubusb          m4, m1          ; p1-p2
+    psubusb          m1, m2          ; p2-p1
+    por              m1, m4          ; abs(p2-p1)
+
+    mova             m4, m6
+    SWAP              4, 6
+    psubusb          m4, m7          ; q2-q3
+    psubusb          m7, m6          ; q3-q2
+    por              m7, m4          ; abs(q3-q2)
+
+    mova             m4, m5
+    SWAP              4, 5
+    psubusb          m4, m6          ; q1-q2
+    psubusb          m6, m5          ; q2-q1
+    por              m6, m4          ; abs(q2-q1)
+
+%ifidn %1, mmx
+    mova             m4, flim_I
+    pxor             m3, m3
+    psubusb          m0, m4
+    psubusb          m1, m4
+    psubusb          m7, m4
+    psubusb          m6, m4
+    pcmpeqb          m0, m3          ; abs(p3-p2) &lt;= I
+    pcmpeqb          m1, m3          ; abs(p2-p1) &lt;= I
+    pcmpeqb          m7, m3          ; abs(q3-q2) &lt;= I
+    pcmpeqb          m6, m3          ; abs(q2-q1) &lt;= I
+    pand             m0, m1
+    pand             m7, m6
+    pand             m0, m7
+%else ; mmxext/sse2
+    pmaxub           m0, m1
+    pmaxub           m6, m7
+    pmaxub           m0, m6
+%endif
+
+    ; normal_limit and high_edge_variance for p1-p0, q1-q0
+    SWAP              7, 3           ; now m7 is zero
+%ifidn %2, v
+    movrow           m3, [dst_reg +mstride_reg] ; p0
+%if mmsize == 16 &amp;&amp; %4 == 8
+    movhps           m3, [dst8_reg+mstride_reg]
+%endif
+%elifdef m12
+    SWAP              3, 12
+%else
+    mova             m3, p0backup
+%endif
+
+    mova             m1, m2
+    SWAP              1, 2
+    mova             m6, m3
+    SWAP              3, 6
+    psubusb          m1, m3          ; p1-p0
+    psubusb          m6, m2          ; p0-p1
+    por              m1, m6          ; abs(p1-p0)
+%ifidn %1, mmx
+    mova             m6, m1
+    psubusb          m1, m4
+    psubusb          m6, hev_thr
+    pcmpeqb          m1, m7          ; abs(p1-p0) &lt;= I
+    pcmpeqb          m6, m7          ; abs(p1-p0) &lt;= hev_thresh
+    pand             m0, m1
+    mova       mask_res, m6
+%else ; mmxext/sse2
+    pmaxub           m0, m1          ; max_I
+    SWAP              1, 4           ; max_hev_thresh
+%endif
+
+    SWAP              6, 4           ; now m6 is I
+%ifidn %2, v
+    movrow           m4, [dst_reg]   ; q0
+%if mmsize == 16 &amp;&amp; %4 == 8
+    movhps           m4, [dst8_reg]
+%endif
+%elifdef m8
+    SWAP              4, 8
+%else
+    mova             m4, q0backup
+%endif
+    mova             m1, m4
+    SWAP              1, 4
+    mova             m7, m5
+    SWAP              7, 5
+    psubusb          m1, m5          ; q0-q1
+    psubusb          m7, m4          ; q1-q0
+    por              m1, m7          ; abs(q1-q0)
+%ifidn %1, mmx
+    mova             m7, m1
+    psubusb          m1, m6
+    psubusb          m7, hev_thr
+    pxor             m6, m6
+    pcmpeqb          m1, m6          ; abs(q1-q0) &lt;= I
+    pcmpeqb          m7, m6          ; abs(q1-q0) &lt;= hev_thresh
+    mova             m6, mask_res
+    pand             m0, m1          ; abs([pq][321]-[pq][210]) &lt;= I
+    pand             m6, m7
+%else ; mmxext/sse2
+    pxor             m7, m7
+    pmaxub           m0, m1
+    pmaxub           m6, m1
+    psubusb          m0, flim_I
+    psubusb          m6, hev_thr
+    pcmpeqb          m0, m7          ; max(abs(..)) &lt;= I
+    pcmpeqb          m6, m7          ; !(max(abs..) &gt; thresh)
+%endif
+%ifdef m12
+    SWAP              6, 12
+%else
+    mova       mask_res, m6          ; !(abs(p1-p0) &gt; hev_t || abs(q1-q0) &gt; hev_t)
+%endif
+
+    ; simple_limit
+    mova             m1, m3
+    SWAP              1, 3
+    mova             m6, m4          ; keep copies of p0/q0 around for later use
+    SWAP              6, 4
+    psubusb          m1, m4          ; p0-q0
+    psubusb          m6, m3          ; q0-p0
+    por              m1, m6          ; abs(q0-p0)
+    paddusb          m1, m1          ; m1=2*abs(q0-p0)
+
+    mova             m7, m2
+    SWAP              7, 2
+    mova             m6, m5
+    SWAP              6, 5
+    psubusb          m7, m5          ; p1-q1
+    psubusb          m6, m2          ; q1-p1
+    por              m7, m6          ; abs(q1-p1)
+    pxor             m6, m6
+    pand             m7, [pb_FE]
+    psrlq            m7, 1           ; abs(q1-p1)/2
+    paddusb          m7, m1          ; abs(q0-p0)*2+abs(q1-p1)/2
+    psubusb          m7, flim_E
+    pcmpeqb          m7, m6          ; abs(q0-p0)*2+abs(q1-p1)/2 &lt;= E
+    pand             m0, m7          ; normal_limit result
+
+    ; filter_common; at this point, m2-m5=p1-q1 and m0 is filter_mask
+%ifdef m8 ; x86-64 &amp;&amp; sse2
+    mova             m8, [pb_80]
+%define pb_80_var m8
+%else ; x86-32 or mmx/mmxext
+%define pb_80_var [pb_80]
+%endif
+    mova             m1, m4
+    mova             m7, m3
+    pxor             m1, pb_80_var
+    pxor             m7, pb_80_var
+    psubsb           m1, m7          ; (signed) q0-p0
+    mova             m6, m2
+    mova             m7, m5
+    pxor             m6, pb_80_var
+    pxor             m7, pb_80_var
+    psubsb           m6, m7          ; (signed) p1-q1
+    mova             m7, mask_res
+    pandn            m7, m6
+    paddsb           m7, m1
+    paddsb           m7, m1
+    paddsb           m7, m1          ; 3*(q0-p0)+is4tap?(p1-q1)
+
+    pand             m7, m0
+    mova             m1, [pb_F8]
+    mova             m6, m7
+    paddsb           m7, [pb_3]
+    paddsb           m6, [pb_4]
+    pand             m7, m1
+    pand             m6, m1
+
+    pxor             m1, m1
+    pxor             m0, m0
+    pcmpgtb          m1, m7
+    psubb            m0, m7
+    psrlq            m7, 3           ; +f2
+    psrlq            m0, 3           ; -f2
+    pand             m0, m1
+    pandn            m1, m7
+    psubusb          m3, m0
+    paddusb          m3, m1          ; p0+f2
+
+    pxor             m1, m1
+    pxor             m0, m0
+    pcmpgtb          m0, m6
+    psubb            m1, m6
+    psrlq            m6, 3           ; +f1
+    psrlq            m1, 3           ; -f1
+    pand             m1, m0
+    pandn            m0, m6
+    psubusb          m4, m0
+    paddusb          m4, m1          ; q0-f1
+
+%ifdef m12
+    SWAP              6, 12
+%else
+    mova             m6, mask_res
+%endif
+%ifidn %1, mmx
+    mova             m7, [pb_1]
+%else ; mmxext/sse2
+    pxor             m7, m7
+%endif
+    pand             m0, m6
+    pand             m1, m6
+%ifidn %1, mmx
+    paddusb          m0, m7
+    pand             m1, [pb_FE]
+    pandn            m7, m0
+    psrlq            m1, 1
+    psrlq            m7, 1
+    SWAP              0, 7
+%else ; mmxext/sse2
+    psubusb          m1, [pb_1]
+    pavgb            m0, m7          ; a
+    pavgb            m1, m7          ; -a
+%endif
+    psubusb          m5, m0
+    psubusb          m2, m1
+    paddusb          m5, m1          ; q1-a
+    paddusb          m2, m0          ; p1+a
+
+    ; store
+%ifidn %2, v
+    movrow [dst_reg +mstride_reg*2], m2
+    movrow [dst_reg +mstride_reg  ], m3
+    movrow    [dst_reg], m4
+    movrow [dst_reg + stride_reg  ], m5
+%if mmsize == 16 &amp;&amp; %4 == 8
+    movhps [dst8_reg+mstride_reg*2], m2
+    movhps [dst8_reg+mstride_reg  ], m3
+    movhps   [dst8_reg], m4
+    movhps [dst8_reg+ stride_reg  ], m5
+%endif
+%else ; h
+    add         dst_reg, 2
+    add        dst2_reg, 2
+
+    ; 4x8/16 transpose
+    TRANSPOSE4x4B     2, 3, 4, 5, 6
+
+%if mmsize == 8 ; mmx/mmxext (h)
+    WRITE_4x2D        2, 3, 4, 5, dst_reg, dst2_reg, mstride_reg, stride_reg
+%else ; sse2 (h)
+    lea        dst8_reg, [dst8_reg+mstride_reg+2]
+    WRITE_4x4D        2, 3, 4, 5, dst_reg, dst2_reg, dst8_reg, mstride_reg, stride_reg, %4
+%endif
+%endif
+
+%if mmsize == 8
+%if %4 == 8 ; chroma
+%ifidn %2, h
+    sub         dst_reg, 2
+%endif
+    cmp         dst_reg, dst8_reg
+    mov         dst_reg, dst8_reg
+    jnz .next8px
+%else
+%ifidn %2, h
+    lea         dst_reg, [dst_reg + stride_reg*8-2]
+%else ; v
+    add         dst_reg, 8
+%endif
+    dec         cnt_reg
+    jg .next8px
+%endif
+%endif
+
+%ifndef m8 ; sse2 on x86-32 or mmx/mmxext
+    mov             rsp, stack_reg   ; restore stack pointer
+%endif
+    RET
+%endmacro
+
+INIT_MMX
+%define SPLATB_REG SPLATB_REG_MMX
+INNER_LOOPFILTER mmx,    v, 6, 16, 0
+INNER_LOOPFILTER mmx,    h, 6, 16, 0
+INNER_LOOPFILTER mmx,    v, 6,  8, 0
+INNER_LOOPFILTER mmx,    h, 6,  8, 0
+
+%define SPLATB_REG SPLATB_REG_MMXEXT
+INNER_LOOPFILTER mmxext, v, 6, 16, 0
+INNER_LOOPFILTER mmxext, h, 6, 16, 0
+INNER_LOOPFILTER mmxext, v, 6,  8, 0
+INNER_LOOPFILTER mmxext, h, 6,  8, 0
+
+INIT_XMM
+%define SPLATB_REG SPLATB_REG_SSE2
+INNER_LOOPFILTER sse2,   v, 5, 16, 13
+%ifdef m8
+INNER_LOOPFILTER sse2,   h, 5, 16, 13
+%else
+INNER_LOOPFILTER sse2,   h, 6, 16, 13
+%endif
+INNER_LOOPFILTER sse2,   v, 6,  8, 13
+INNER_LOOPFILTER sse2,   h, 6,  8, 13
+
+%define SPLATB_REG SPLATB_REG_SSSE3
+INNER_LOOPFILTER ssse3,  v, 5, 16, 13
+%ifdef m8
+INNER_LOOPFILTER ssse3,  h, 5, 16, 13
+%else
+INNER_LOOPFILTER ssse3,  h, 6, 16, 13
+%endif
+INNER_LOOPFILTER ssse3,  v, 6,  8, 13
+INNER_LOOPFILTER ssse3,  h, 6,  8, 13
+
+;-----------------------------------------------------------------------------
+; void vp8_h/v_loop_filter&lt;size&gt;_mbedge_&lt;opt&gt;(uint8_t *dst, [uint8_t *v,] int stride,
+;                                            int flimE, int flimI, int hev_thr);
+;-----------------------------------------------------------------------------
+
+; write 4 or 8 words in the mmx/xmm registers as 8 lines
+; 1 and 2 are the registers to write, this can be the same (for SSE2)
+; for pre-SSE4:
+; 3 is a general-purpose register that we will clobber
+; for SSE4:
+; 3 is a pointer to the destination's 5th line
+; 4 is a pointer to the destination's 4th line
+; 5/6 is -stride and +stride
+; 7 is optimization string
+%macro WRITE_8W 7
+%ifidn %7, sse4
+    pextrw    [%4+%5*4], %1, 0
+    pextrw    [%3+%5*4], %1, 1
+    pextrw    [%4+%5*2], %1, 2
+    pextrw    [%4+%5  ], %1, 3
+    pextrw    [%4     ], %1, 4
+    pextrw    [%3     ], %1, 5
+    pextrw    [%3+%6  ], %1, 6
+    pextrw    [%3+%6*2], %1, 7
+%else
+    movd             %3, %1
+%if mmsize == 8
+    punpckhdq        %1, %1
+%else
+    psrldq           %1, 4
+%endif
+    mov       [%4+%5*4], %3w
+    shr              %3, 16
+    add              %4, %6
+    mov       [%4+%5*4], %3w
+
+    movd             %3, %1
+%if mmsize == 16
+    psrldq           %1, 4
+%endif
+    add              %4, %5
+    mov       [%4+%5*2], %3w
+    shr              %3, 16
+    mov       [%4+%5  ], %3w
+
+    movd             %3, %2
+%if mmsize == 8
+    punpckhdq        %2, %2
+%else
+    psrldq           %2, 4
+%endif
+    mov       [%4     ], %3w
+    shr              %3, 16
+    mov       [%4+%6  ], %3w
+
+    movd             %3, %2
+    add              %4, %6
+    mov       [%4+%6  ], %3w
+    shr              %3, 16
+    mov       [%4+%6*2], %3w
+%if mmsize == 8
+    add              %4, %5
+%endif
+%endif
+%endmacro
+
+%macro MBEDGE_LOOPFILTER 5
+%if %4 == 8 ; chroma
+cglobal vp8_%2_loop_filter8uv_mbedge_%1, 6, %3, %5
+%define dst8_reg    r1
+%define mstride_reg r2
+%define E_reg       r3
+%define I_reg       r4
+%define hev_thr_reg r5
+%else ; luma
+cglobal vp8_%2_loop_filter16y_mbedge_%1, 5, %3, %5
+%define mstride_reg r1
+%define E_reg       r2
+%define I_reg       r3
+%define hev_thr_reg r4
+%ifdef m8 ; x86-64, sse2
+%define dst8_reg    r4
+%elif mmsize == 16 ; x86-32, sse2
+%define dst8_reg    r5
+%else ; x86-32, mmx/mmxext
+%define cnt_reg     r5
+%endif
+%endif
+%define dst_reg     r0
+%define stride_reg  E_reg
+%define dst2_reg    I_reg
+%ifndef m8
+%define stack_reg   hev_thr_reg
+%endif
+
+%ifnidn %1, sse2 &amp;&amp; mmsize == 16
+    pxor             m7, m7
+%endif
+
+%ifndef m8 ; mmx/mmxext or sse2 on x86-32
+    ; splat function arguments
+    SPLATB_REG       m0, E_reg, m7   ; E
+    SPLATB_REG       m1, I_reg, m7   ; I
+    SPLATB_REG       m2, hev_thr_reg, m7 ; hev_thresh
+
+    ; align stack
+    mov       stack_reg, rsp         ; backup stack pointer
+    and             rsp, ~(mmsize-1) ; align stack
+    sub             rsp, mmsize * 8  ; stack layout: [0]=E, [1]=I, [2]=hev_thr
+                                     ;               [3]=hev() result
+                                     ;               [4]=filter tmp result
+                                     ;               [5]/[6] = p2/q2 backup
+                                     ;               [7]=lim_res sign result
+
+%define flim_E   [rsp]
+%define flim_I   [rsp+mmsize]
+%define hev_thr  [rsp+mmsize*2]
+%define mask_res [rsp+mmsize*3]
+%define lim_res  [rsp+mmsize*4]
+%define p0backup [rsp+mmsize*3]
+%define q0backup [rsp+mmsize*4]
+%define p2backup [rsp+mmsize*5]
+%define q2backup [rsp+mmsize*6]
+%define lim_sign [rsp+mmsize*7]
+
+    mova         flim_E, m0
+    mova         flim_I, m1
+    mova        hev_thr, m2
+
+%else ; sse2 on x86-64
+
+%define flim_E   m9
+%define flim_I   m10
+%define hev_thr  m11
+%define mask_res m12
+%define lim_res  m8
+%define p0backup m12
+%define q0backup m8
+%define p2backup m13
+%define q2backup m14
+%define lim_sign m15
+
+    ; splat function arguments
+    SPLATB_REG   flim_E, E_reg, m7   ; E
+    SPLATB_REG   flim_I, I_reg, m7   ; I
+    SPLATB_REG  hev_thr, hev_thr_reg, m7 ; hev_thresh
+%endif
+
+%if mmsize == 8 &amp;&amp; %4 == 16 ; mmx/mmxext
+    mov         cnt_reg, 2
+%endif
+    mov      stride_reg, mstride_reg
+    neg     mstride_reg
+%ifidn %2, h
+    lea         dst_reg, [dst_reg + stride_reg*4-4]
+%if %4 == 8
+    lea        dst8_reg, [dst8_reg+ stride_reg*4-4]
+%endif
+%endif
+
+%if mmsize == 8
+.next8px
+%endif
+    ; read
+    lea        dst2_reg, [dst_reg + stride_reg]
+%ifidn %2, v
+%if %4 == 8 &amp;&amp; mmsize == 16
+%define movrow movh
+%else
+%define movrow mova
+%endif
+    movrow           m0, [dst_reg +mstride_reg*4] ; p3
+    movrow           m1, [dst2_reg+mstride_reg*4] ; p2
+    movrow           m2, [dst_reg +mstride_reg*2] ; p1
+    movrow           m5, [dst2_reg]               ; q1
+    movrow           m6, [dst2_reg+ stride_reg]   ; q2
+    movrow           m7, [dst2_reg+ stride_reg*2] ; q3
+%if mmsize == 16 &amp;&amp; %4 == 8
+    movhps           m0, [dst8_reg+mstride_reg*4]
+    movhps           m2, [dst8_reg+mstride_reg*2]
+    add        dst8_reg, stride_reg
+    movhps           m1, [dst8_reg+mstride_reg*4]
+    movhps           m5, [dst8_reg]
+    movhps           m6, [dst8_reg+ stride_reg]
+    movhps           m7, [dst8_reg+ stride_reg*2]
+    add        dst8_reg, mstride_reg
+%endif
+%elif mmsize == 8 ; mmx/mmxext (h)
+    ; read 8 rows of 8px each
+    movu             m0, [dst_reg +mstride_reg*4]
+    movu             m1, [dst2_reg+mstride_reg*4]
+    movu             m2, [dst_reg +mstride_reg*2]
+    movu             m3, [dst_reg +mstride_reg]
+    movu             m4, [dst_reg]
+    movu             m5, [dst2_reg]
+    movu             m6, [dst2_reg+ stride_reg]
+
+    ; 8x8 transpose
+    TRANSPOSE4x4B     0, 1, 2, 3, 7
+    mova       q0backup, m1
+    movu             m7, [dst2_reg+ stride_reg*2]
+    TRANSPOSE4x4B     4, 5, 6, 7, 1
+    SBUTTERFLY       dq, 0, 4, 1     ; p3/p2
+    SBUTTERFLY       dq, 2, 6, 1     ; q0/q1
+    SBUTTERFLY       dq, 3, 7, 1     ; q2/q3
+    mova             m1, q0backup
+    mova       q0backup, m2          ; store q0
+    SBUTTERFLY       dq, 1, 5, 2     ; p1/p0
+    mova       p0backup, m5          ; store p0
+    SWAP              1, 4
+    SWAP              2, 4
+    SWAP              6, 3
+    SWAP              5, 3
+%else ; sse2 (h)
+%if %4 == 16
+    lea        dst8_reg, [dst_reg + stride_reg*8]
+%endif
+
+    ; read 16 rows of 8px each, interleave
+    movh             m0, [dst_reg +mstride_reg*4]
+    movh             m1, [dst8_reg+mstride_reg*4]
+    movh             m2, [dst_reg +mstride_reg*2]
+    movh             m5, [dst8_reg+mstride_reg*2]
+    movh             m3, [dst_reg +mstride_reg]
+    movh             m6, [dst8_reg+mstride_reg]
+    movh             m4, [dst_reg]
+    movh             m7, [dst8_reg]
+    punpcklbw        m0, m1          ; A/I
+    punpcklbw        m2, m5          ; C/K
+    punpcklbw        m3, m6          ; D/L
+    punpcklbw        m4, m7          ; E/M
+
+    add        dst8_reg, stride_reg
+    movh             m1, [dst2_reg+mstride_reg*4]
+    movh             m6, [dst8_reg+mstride_reg*4]
+    movh             m5, [dst2_reg]
+    movh             m7, [dst8_reg]
+    punpcklbw        m1, m6          ; B/J
+    punpcklbw        m5, m7          ; F/N
+    movh             m6, [dst2_reg+ stride_reg]
+    movh             m7, [dst8_reg+ stride_reg]
+    punpcklbw        m6, m7          ; G/O
+
+    ; 8x16 transpose
+    TRANSPOSE4x4B     0, 1, 2, 3, 7
+%ifdef m8
+    SWAP              1, 8
+%else
+    mova       q0backup, m1
+%endif
+    movh             m7, [dst2_reg+ stride_reg*2]
+    movh             m1, [dst8_reg+ stride_reg*2]
+    punpcklbw        m7, m1          ; H/P
+    TRANSPOSE4x4B     4, 5, 6, 7, 1
+    SBUTTERFLY       dq, 0, 4, 1     ; p3/p2
+    SBUTTERFLY       dq, 2, 6, 1     ; q0/q1
+    SBUTTERFLY       dq, 3, 7, 1     ; q2/q3
+%ifdef m8
+    SWAP              1, 8
+    SWAP              2, 8
+%else
+    mova             m1, q0backup
+    mova       q0backup, m2          ; store q0
+%endif
+    SBUTTERFLY       dq, 1, 5, 2     ; p1/p0
+%ifdef m12
+    SWAP              5, 12
+%else
+    mova       p0backup, m5          ; store p0
+%endif
+    SWAP              1, 4
+    SWAP              2, 4
+    SWAP              6, 3
+    SWAP              5, 3
+%endif
+
+    ; normal_limit for p3-p2, p2-p1, q3-q2 and q2-q1
+    mova             m4, m1
+    SWAP              4, 1
+    psubusb          m4, m0          ; p2-p3
+    psubusb          m0, m1          ; p3-p2
+    por              m0, m4          ; abs(p3-p2)
+
+    mova             m4, m2
+    SWAP              4, 2
+    psubusb          m4, m1          ; p1-p2
+    mova       p2backup, m1
+    psubusb          m1, m2          ; p2-p1
+    por              m1, m4          ; abs(p2-p1)
+
+    mova             m4, m6
+    SWAP              4, 6
+    psubusb          m4, m7          ; q2-q3
+    psubusb          m7, m6          ; q3-q2
+    por              m7, m4          ; abs(q3-q2)
+
+    mova             m4, m5
+    SWAP              4, 5
+    psubusb          m4, m6          ; q1-q2
+    mova       q2backup, m6
+    psubusb          m6, m5          ; q2-q1
+    por              m6, m4          ; abs(q2-q1)
+
+%ifidn %1, mmx
+    mova             m4, flim_I
+    pxor             m3, m3
+    psubusb          m0, m4
+    psubusb          m1, m4
+    psubusb          m7, m4
+    psubusb          m6, m4
+    pcmpeqb          m0, m3          ; abs(p3-p2) &lt;= I
+    pcmpeqb          m1, m3          ; abs(p2-p1) &lt;= I
+    pcmpeqb          m7, m3          ; abs(q3-q2) &lt;= I
+    pcmpeqb          m6, m3          ; abs(q2-q1) &lt;= I
+    pand             m0, m1
+    pand             m7, m6
+    pand             m0, m7
+%else ; mmxext/sse2
+    pmaxub           m0, m1
+    pmaxub           m6, m7
+    pmaxub           m0, m6
+%endif
+
+    ; normal_limit and high_edge_variance for p1-p0, q1-q0
+    SWAP              7, 3           ; now m7 is zero
+%ifidn %2, v
+    movrow           m3, [dst_reg +mstride_reg] ; p0
+%if mmsize == 16 &amp;&amp; %4 == 8
+    movhps           m3, [dst8_reg+mstride_reg]
+%endif
+%elifdef m12
+    SWAP              3, 12
+%else
+    mova             m3, p0backup
+%endif
+
+    mova             m1, m2
+    SWAP              1, 2
+    mova             m6, m3
+    SWAP              3, 6
+    psubusb          m1, m3          ; p1-p0
+    psubusb          m6, m2          ; p0-p1
+    por              m1, m6          ; abs(p1-p0)
+%ifidn %1, mmx
+    mova             m6, m1
+    psubusb          m1, m4
+    psubusb          m6, hev_thr
+    pcmpeqb          m1, m7          ; abs(p1-p0) &lt;= I
+    pcmpeqb          m6, m7          ; abs(p1-p0) &lt;= hev_thresh
+    pand             m0, m1
+    mova       mask_res, m6
+%else ; mmxext/sse2
+    pmaxub           m0, m1          ; max_I
+    SWAP              1, 4           ; max_hev_thresh
+%endif
+
+    SWAP              6, 4           ; now m6 is I
+%ifidn %2, v
+    movrow           m4, [dst_reg]   ; q0
+%if mmsize == 16 &amp;&amp; %4 == 8
+    movhps           m4, [dst8_reg]
+%endif
+%elifdef m8
+    SWAP              4, 8
+%else
+    mova             m4, q0backup
+%endif
+    mova             m1, m4
+    SWAP              1, 4
+    mova             m7, m5
+    SWAP              7, 5
+    psubusb          m1, m5          ; q0-q1
+    psubusb          m7, m4          ; q1-q0
+    por              m1, m7          ; abs(q1-q0)
+%ifidn %1, mmx
+    mova             m7, m1
+    psubusb          m1, m6
+    psubusb          m7, hev_thr
+    pxor             m6, m6
+    pcmpeqb          m1, m6          ; abs(q1-q0) &lt;= I
+    pcmpeqb          m7, m6          ; abs(q1-q0) &lt;= hev_thresh
+    mova             m6, mask_res
+    pand             m0, m1          ; abs([pq][321]-[pq][210]) &lt;= I
+    pand             m6, m7
+%else ; mmxext/sse2
+    pxor             m7, m7
+    pmaxub           m0, m1
+    pmaxub           m6, m1
+    psubusb          m0, flim_I
+    psubusb          m6, hev_thr
+    pcmpeqb          m0, m7          ; max(abs(..)) &lt;= I
+    pcmpeqb          m6, m7          ; !(max(abs..) &gt; thresh)
+%endif
+%ifdef m12
+    SWAP              6, 12
+%else
+    mova       mask_res, m6          ; !(abs(p1-p0) &gt; hev_t || abs(q1-q0) &gt; hev_t)
+%endif
+
+    ; simple_limit
+    mova             m1, m3
+    SWAP              1, 3
+    mova             m6, m4          ; keep copies of p0/q0 around for later use
+    SWAP              6, 4
+    psubusb          m1, m4          ; p0-q0
+    psubusb          m6, m3          ; q0-p0
+    por              m1, m6          ; abs(q0-p0)
+    paddusb          m1, m1          ; m1=2*abs(q0-p0)
+
+    mova             m7, m2
+    SWAP              7, 2
+    mova             m6, m5
+    SWAP              6, 5
+    psubusb          m7, m5          ; p1-q1
+    psubusb          m6, m2          ; q1-p1
+    por              m7, m6          ; abs(q1-p1)
+    pxor             m6, m6
+    pand             m7, [pb_FE]
+    psrlq            m7, 1           ; abs(q1-p1)/2
+    paddusb          m7, m1          ; abs(q0-p0)*2+abs(q1-p1)/2
+    psubusb          m7, flim_E
+    pcmpeqb          m7, m6          ; abs(q0-p0)*2+abs(q1-p1)/2 &lt;= E
+    pand             m0, m7          ; normal_limit result
+
+    ; filter_common; at this point, m2-m5=p1-q1 and m0 is filter_mask
+%ifdef m8 ; x86-64 &amp;&amp; sse2
+    mova             m8, [pb_80]
+%define pb_80_var m8
+%else ; x86-32 or mmx/mmxext
+%define pb_80_var [pb_80]
+%endif
+    mova             m1, m4
+    mova             m7, m3
+    pxor             m1, pb_80_var
+    pxor             m7, pb_80_var
+    psubsb           m1, m7          ; (signed) q0-p0
+    mova             m6, m2
+    mova             m7, m5
+    pxor             m6, pb_80_var
+    pxor             m7, pb_80_var
+    psubsb           m6, m7          ; (signed) p1-q1
+    mova             m7, mask_res
+    paddsb           m6, m1
+    paddsb           m6, m1
+    paddsb           m6, m1
+    pand             m6, m0
+%ifdef m8
+    mova        lim_res, m6          ; 3*(qp-p0)+(p1-q1) masked for filter_mbedge
+    pand        lim_res, m7
+%else
+    mova             m0, m6
+    pand             m0, m7
+    mova        lim_res, m0
+%endif
+    pandn            m7, m6          ; 3*(q0-p0)+(p1-q1) masked for filter_common
+
+    mova             m1, [pb_F8]
+    mova             m6, m7
+    paddsb           m7, [pb_3]
+    paddsb           m6, [pb_4]
+    pand             m7, m1
+    pand             m6, m1
+
+    pxor             m1, m1
+    pxor             m0, m0
+    pcmpgtb          m1, m7
+    psubb            m0, m7
+    psrlq            m7, 3           ; +f2
+    psrlq            m0, 3           ; -f2
+    pand             m0, m1
+    pandn            m1, m7
+    psubusb          m3, m0
+    paddusb          m3, m1          ; p0+f2
+
+    pxor             m1, m1
+    pxor             m0, m0
+    pcmpgtb          m0, m6
+    psubb            m1, m6
+    psrlq            m6, 3           ; +f1
+    psrlq            m1, 3           ; -f1
+    pand             m1, m0
+    pandn            m0, m6
+    psubusb          m4, m0
+    paddusb          m4, m1          ; q0-f1
+
+    ; filter_mbedge (m2-m5 = p1-q1; lim_res carries w)
+    mova             m7, [pw_63]
+%ifdef m8
+    SWAP              1, 8
+%else
+    mova             m1, lim_res
+%endif
+    pxor             m0, m0
+    mova             m6, m1
+    pcmpgtb          m0, m1         ; which are negative
+    punpcklbw        m6, m0         ; signed byte-&gt;word
+    punpckhbw        m1, m0
+    mova       lim_sign, m0
+    mova       mask_res, m6         ; backup for later in filter
+    mova        lim_res, m1
+    pmullw          m6, [pw_27]
+    pmullw          m1, [pw_27]
+    paddw           m6, m7
+    paddw           m1, m7
+    psraw           m6, 7
+    psraw           m1, 7
+    packsswb        m6, m1          ; a0
+    pxor            m1, m1
+    psubb           m1, m6
+    pand            m1, m0          ; -a0
+    pandn           m0, m6          ; +a0
+    psubusb         m3, m1
+    paddusb         m4, m1
+    paddusb         m3, m0          ; p0+a0
+    psubusb         m4, m0          ; q0-a0
+
+    mova            m6, mask_res
+    mova            m1, lim_res
+    mova            m0, lim_sign
+    pmullw          m6, [pw_18]
+    pmullw          m1, [pw_18]
+    paddw           m6, m7
+    paddw           m1, m7
+    psraw           m6, 7
+    psraw           m1, 7
+    packsswb        m6, m1          ; a1
+    pxor            m1, m1
+    psubb           m1, m6
+    pand            m1, m0          ; -a1
+    pandn           m0, m6          ; +a1
+    psubusb         m2, m1
+    paddusb         m5, m1
+    paddusb         m2, m0          ; p1+a1
+    psubusb         m5, m0          ; q1-a1
+
+%ifdef m8
+    SWAP             6, 12
+    SWAP             1, 8
+%else
+    mova            m6, mask_res
+    mova            m1, lim_res
+%endif
+    pmullw          m6, [pw_9]
+    pmullw          m1, [pw_9]
+    paddw           m6, m7
+    paddw           m1, m7
+%ifdef m15
+    SWAP             7, 15
+%else
+    mova            m7, lim_sign
+%endif
+    psraw           m6, 7
+    psraw           m1, 7
+    packsswb        m6, m1          ; a1
+    pxor            m0, m0
+    psubb           m0, m6
+    pand            m0, m7          ; -a1
+    pandn           m7, m6          ; +a1
+%ifdef m8
+    SWAP             1, 13
+    SWAP             6, 14
+%else
+    mova            m1, p2backup
+    mova            m6, q2backup
+%endif
+    psubusb         m1, m0
+    paddusb         m6, m0
+    paddusb         m1, m7          ; p1+a1
+    psubusb         m6, m7          ; q1-a1
+
+    ; store
+%ifidn %2, v
+    movrow [dst2_reg+mstride_reg*4], m1
+    movrow [dst_reg +mstride_reg*2], m2
+    movrow [dst_reg +mstride_reg  ], m3
+    movrow    [dst_reg], m4
+    movrow   [dst2_reg], m5
+    movrow [dst2_reg+ stride_reg  ], m6
+%if mmsize == 16 &amp;&amp; %4 == 8
+    add        dst8_reg, mstride_reg
+    movhps [dst8_reg+mstride_reg*2], m1
+    movhps [dst8_reg+mstride_reg  ], m2
+    movhps   [dst8_reg], m3
+    add        dst8_reg, stride_reg
+    movhps   [dst8_reg], m4
+    movhps [dst8_reg+ stride_reg  ], m5
+    movhps [dst8_reg+ stride_reg*2], m6
+%endif
+%else ; h
+    inc         dst_reg
+    inc        dst2_reg
+
+    ; 4x8/16 transpose
+    TRANSPOSE4x4B     1, 2, 3, 4, 0
+    SBUTTERFLY       bw, 5, 6, 0
+
+%if mmsize == 8 ; mmx/mmxext (h)
+    WRITE_4x2D        1, 2, 3, 4, dst_reg, dst2_reg, mstride_reg, stride_reg
+    add         dst_reg, 4
+    WRITE_8W         m5, m6, dst2_reg, dst_reg, mstride_reg, stride_reg, %4
+%else ; sse2 (h)
+    lea        dst8_reg, [dst8_reg+mstride_reg+1]
+    WRITE_4x4D        1, 2, 3, 4, dst_reg, dst2_reg, dst8_reg, mstride_reg, stride_reg, %4
+    lea         dst_reg, [dst2_reg+mstride_reg+4]
+    lea        dst8_reg, [dst8_reg+mstride_reg+4]
+    WRITE_8W         m5, m5, dst2_reg, dst_reg,  mstride_reg, stride_reg, %2
+%ifidn %2, sse4
+    lea        dst2_reg, [dst8_reg+ stride_reg]
+%endif
+    WRITE_8W         m6, m6, dst2_reg, dst8_reg, mstride_reg, stride_reg, %2
+%endif
+%endif
+
+%if mmsize == 8
+%if %4 == 8 ; chroma
+%ifidn %2, h
+    sub         dst_reg, 5
+%endif
+    cmp         dst_reg, dst8_reg
+    mov         dst_reg, dst8_reg
+    jnz .next8px
+%else
+%ifidn %2, h
+    lea         dst_reg, [dst_reg + stride_reg*8-5]
+%else ; v
+    add         dst_reg, 8
+%endif
+    dec         cnt_reg
+    jg .next8px
+%endif
+%endif
+
+%ifndef m8 ; sse2 on x86-32 or mmx/mmxext
+    mov             rsp, stack_reg   ; restore stack pointer
+%endif
+    RET
+%endmacro
+
+INIT_MMX
+%define SPLATB_REG SPLATB_REG_MMX
+MBEDGE_LOOPFILTER mmx,    v, 6, 16, 0
+MBEDGE_LOOPFILTER mmx,    h, 6, 16, 0
+MBEDGE_LOOPFILTER mmx,    v, 6,  8, 0
+MBEDGE_LOOPFILTER mmx,    h, 6,  8, 0
+
+%define SPLATB_REG SPLATB_REG_MMXEXT
+MBEDGE_LOOPFILTER mmxext, v, 6, 16, 0
+MBEDGE_LOOPFILTER mmxext, h, 6, 16, 0
+MBEDGE_LOOPFILTER mmxext, v, 6,  8, 0
+MBEDGE_LOOPFILTER mmxext, h, 6,  8, 0
+
+INIT_XMM
+%define SPLATB_REG SPLATB_REG_SSE2
+MBEDGE_LOOPFILTER sse2,   v, 5, 16, 16
+%ifdef m8
+MBEDGE_LOOPFILTER sse2,   h, 5, 16, 16
+%else
+MBEDGE_LOOPFILTER sse2,   h, 6, 16, 16
+%endif
+MBEDGE_LOOPFILTER sse2,   v, 6,  8, 16
+MBEDGE_LOOPFILTER sse2,   h, 6,  8, 16
+
+%define SPLATB_REG SPLATB_REG_SSSE3
+MBEDGE_LOOPFILTER ssse3,  v, 5, 16, 16
+%ifdef m8
+MBEDGE_LOOPFILTER ssse3,  h, 5, 16, 16
+%else
+MBEDGE_LOOPFILTER ssse3,  h, 6, 16, 16
+%endif
+MBEDGE_LOOPFILTER ssse3,  v, 6,  8, 16
+MBEDGE_LOOPFILTER ssse3,  h, 6,  8, 16
+
+%ifdef m8
+MBEDGE_LOOPFILTER sse4,   h, 5, 16, 16
+%else
+MBEDGE_LOOPFILTER sse4,   h, 6, 16, 16
+%endif
+MBEDGE_LOOPFILTER sse4,   h, 6,  8, 16

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/colorspace.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/colorspace.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/colorspace.h	2010-07-25 10:07:39 UTC (rev 6478)
@@ -0,0 +1,111 @@
+/*
+ * Colorspace conversion defines
+ * Copyright (c) 2001, 2002, 2003 Fabrice Bellard
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * Various defines for YUV&lt;-&gt;RGB conversion
+ */
+
+#ifndef AVUTIL_COLORSPACE_H
+#define AVUTIL_COLORSPACE_H
+
+#define SCALEBITS 10
+#define ONE_HALF  (1 &lt;&lt; (SCALEBITS - 1))
+#define FIX(x)    ((int) ((x) * (1&lt;&lt;SCALEBITS) + 0.5))
+
+#define YUV_TO_RGB1_CCIR(cb1, cr1)\
+{\
+    cb = (cb1) - 128;\
+    cr = (cr1) - 128;\
+    r_add = FIX(1.40200*255.0/224.0) * cr + ONE_HALF;\
+    g_add = - FIX(0.34414*255.0/224.0) * cb - FIX(0.71414*255.0/224.0) * cr + \
+            ONE_HALF;\
+    b_add = FIX(1.77200*255.0/224.0) * cb + ONE_HALF;\
+}
+
+#define YUV_TO_RGB2_CCIR(r, g, b, y1)\
+{\
+    y = ((y1) - 16) * FIX(255.0/219.0);\
+    r = cm[(y + r_add) &gt;&gt; SCALEBITS];\
+    g = cm[(y + g_add) &gt;&gt; SCALEBITS];\
+    b = cm[(y + b_add) &gt;&gt; SCALEBITS];\
+}
+
+#define YUV_TO_RGB1(cb1, cr1)\
+{\
+    cb = (cb1) - 128;\
+    cr = (cr1) - 128;\
+    r_add = FIX(1.40200) * cr + ONE_HALF;\
+    g_add = - FIX(0.34414) * cb - FIX(0.71414) * cr + ONE_HALF;\
+    b_add = FIX(1.77200) * cb + ONE_HALF;\
+}
+
+#define YUV_TO_RGB2(r, g, b, y1)\
+{\
+    y = (y1) &lt;&lt; SCALEBITS;\
+    r = cm[(y + r_add) &gt;&gt; SCALEBITS];\
+    g = cm[(y + g_add) &gt;&gt; SCALEBITS];\
+    b = cm[(y + b_add) &gt;&gt; SCALEBITS];\
+}
+
+#define Y_CCIR_TO_JPEG(y)\
+ cm[((y) * FIX(255.0/219.0) + (ONE_HALF - 16 * FIX(255.0/219.0))) &gt;&gt; SCALEBITS]
+
+#define Y_JPEG_TO_CCIR(y)\
+ (((y) * FIX(219.0/255.0) + (ONE_HALF + (16 &lt;&lt; SCALEBITS))) &gt;&gt; SCALEBITS)
+
+#define C_CCIR_TO_JPEG(y)\
+ cm[(((y) - 128) * FIX(127.0/112.0) + (ONE_HALF + (128 &lt;&lt; SCALEBITS))) &gt;&gt; SCALEBITS]
+
+/* NOTE: the clamp is really necessary! */
+static inline int C_JPEG_TO_CCIR(int y) {
+    y = (((y - 128) * FIX(112.0/127.0) + (ONE_HALF + (128 &lt;&lt; SCALEBITS))) &gt;&gt; SCALEBITS);
+    if (y &lt; 16)
+        y = 16;
+    return y;
+}
+
+
+#define RGB_TO_Y(r, g, b) \
+((FIX(0.29900) * (r) + FIX(0.58700) * (g) + \
+  FIX(0.11400) * (b) + ONE_HALF) &gt;&gt; SCALEBITS)
+
+#define RGB_TO_U(r1, g1, b1, shift)\
+(((- FIX(0.16874) * r1 - FIX(0.33126) * g1 +         \
+     FIX(0.50000) * b1 + (ONE_HALF &lt;&lt; shift) - 1) &gt;&gt; (SCALEBITS + shift)) + 128)
+
+#define RGB_TO_V(r1, g1, b1, shift)\
+(((FIX(0.50000) * r1 - FIX(0.41869) * g1 -           \
+   FIX(0.08131) * b1 + (ONE_HALF &lt;&lt; shift) - 1) &gt;&gt; (SCALEBITS + shift)) + 128)
+
+#define RGB_TO_Y_CCIR(r, g, b) \
+((FIX(0.29900*219.0/255.0) * (r) + FIX(0.58700*219.0/255.0) * (g) + \
+  FIX(0.11400*219.0/255.0) * (b) + (ONE_HALF + (16 &lt;&lt; SCALEBITS))) &gt;&gt; SCALEBITS)
+
+#define RGB_TO_U_CCIR(r1, g1, b1, shift)\
+(((- FIX(0.16874*224.0/255.0) * r1 - FIX(0.33126*224.0/255.0) * g1 +         \
+     FIX(0.50000*224.0/255.0) * b1 + (ONE_HALF &lt;&lt; shift) - 1) &gt;&gt; (SCALEBITS + shift)) + 128)
+
+#define RGB_TO_V_CCIR(r1, g1, b1, shift)\
+(((FIX(0.50000*224.0/255.0) * r1 - FIX(0.41869*224.0/255.0) * g1 -           \
+   FIX(0.08131*224.0/255.0) * b1 + (ONE_HALF &lt;&lt; shift) - 1) &gt;&gt; (SCALEBITS + shift)) + 128)
+
+#endif /* AVUTIL_COLORSPACE_H */

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/eval.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/eval.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/eval.c	2010-07-25 10:07:39 UTC (rev 6478)
@@ -0,0 +1,591 @@
+/*
+ * Copyright (c) 2002-2006 Michael Niedermayer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">michaelni at gmx.at</A>&gt;
+ * Copyright (c) 2006 Oded Shimon &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">ods15 at ods15.dyndns.org</A>&gt;
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * simple arithmetic expression evaluator.
+ *
+ * see <A HREF="http://joe.hotchkiss.com/programming/eval/eval.html">http://joe.hotchkiss.com/programming/eval/eval.html</A>
+ */
+
+#include &quot;libavutil/avutil.h&quot;
+#include &quot;eval.h&quot;
+
+typedef struct Parser {
+    const AVClass *class;
+    int stack_index;
+    char *s;
+    const double *const_values;
+    const char * const *const_names;          // NULL terminated
+    double (* const *funcs1)(void *, double a);           // NULL terminated
+    const char * const *func1_names;          // NULL terminated
+    double (* const *funcs2)(void *, double a, double b); // NULL terminated
+    const char * const *func2_names;          // NULL terminated
+    void *opaque;
+    int log_offset;
+    void *log_ctx;
+#define VARS 10
+    double var[VARS];
+} Parser;
+
+static const AVClass class = { &quot;Eval&quot;, av_default_item_name, NULL, LIBAVUTIL_VERSION_INT, offsetof(Parser,log_offset), offsetof(Parser,log_ctx) };
+
+static const int8_t si_prefixes['z' - 'E' + 1] = {
+    ['y'-'E']= -24,
+    ['z'-'E']= -21,
+    ['a'-'E']= -18,
+    ['f'-'E']= -15,
+    ['p'-'E']= -12,
+    ['n'-'E']= - 9,
+    ['u'-'E']= - 6,
+    ['m'-'E']= - 3,
+    ['c'-'E']= - 2,
+    ['d'-'E']= - 1,
+    ['h'-'E']=   2,
+    ['k'-'E']=   3,
+    ['K'-'E']=   3,
+    ['M'-'E']=   6,
+    ['G'-'E']=   9,
+    ['T'-'E']=  12,
+    ['P'-'E']=  15,
+    ['E'-'E']=  18,
+    ['Z'-'E']=  21,
+    ['Y'-'E']=  24,
+};
+
+double av_strtod(const char *numstr, char **tail)
+{
+    double d;
+    char *next;
+    d = strtod(numstr, &amp;next);
+    /* if parsing succeeded, check for and interpret postfixes */
+    if (next!=numstr) {
+        if (*next &gt;= 'E' &amp;&amp; *next &lt;= 'z') {
+            int e= si_prefixes[*next - 'E'];
+            if (e) {
+                if (next[1] == 'i') {
+                    d*= pow( 2, e/0.3);
+                    next+=2;
+                } else {
+                    d*= pow(10, e);
+                    next++;
+                }
+            }
+        }
+
+        if (*next=='B') {
+            d*=8;
+            next++;
+        }
+    }
+    /* if requested, fill in tail with the position after the last parsed
+       character */
+    if (tail)
+        *tail = next;
+    return d;
+}
+
+static int strmatch(const char *s, const char *prefix)
+{
+    int i;
+    for (i=0; prefix[i]; i++) {
+        if (prefix[i] != s[i]) return 0;
+    }
+    return 1;
+}
+
+struct AVExpr {
+    enum {
+        e_value, e_const, e_func0, e_func1, e_func2,
+        e_squish, e_gauss, e_ld,
+        e_mod, e_max, e_min, e_eq, e_gt, e_gte,
+        e_pow, e_mul, e_div, e_add,
+        e_last, e_st, e_while,
+    } type;
+    double value; // is sign in other types
+    union {
+        int const_index;
+        double (*func0)(double);
+        double (*func1)(void *, double);
+        double (*func2)(void *, double, double);
+    } a;
+    struct AVExpr *param[2];
+};
+
+static double eval_expr(Parser *p, AVExpr *e)
+{
+    switch (e-&gt;type) {
+        case e_value:  return e-&gt;value;
+        case e_const:  return e-&gt;value * p-&gt;const_values[e-&gt;a.const_index];
+        case e_func0:  return e-&gt;value * e-&gt;a.func0(eval_expr(p, e-&gt;param[0]));
+        case e_func1:  return e-&gt;value * e-&gt;a.func1(p-&gt;opaque, eval_expr(p, e-&gt;param[0]));
+        case e_func2:  return e-&gt;value * e-&gt;a.func2(p-&gt;opaque, eval_expr(p, e-&gt;param[0]), eval_expr(p, e-&gt;param[1]));
+        case e_squish: return 1/(1+exp(4*eval_expr(p, e-&gt;param[0])));
+        case e_gauss: { double d = eval_expr(p, e-&gt;param[0]); return exp(-d*d/2)/sqrt(2*M_PI); }
+        case e_ld:     return e-&gt;value * p-&gt;var[av_clip(eval_expr(p, e-&gt;param[0]), 0, VARS-1)];
+        case e_while: {
+            double d = NAN;
+            while (eval_expr(p, e-&gt;param[0]))
+                d=eval_expr(p, e-&gt;param[1]);
+            return d;
+        }
+        default: {
+            double d = eval_expr(p, e-&gt;param[0]);
+            double d2 = eval_expr(p, e-&gt;param[1]);
+            switch (e-&gt;type) {
+                case e_mod: return e-&gt;value * (d - floor(d/d2)*d2);
+                case e_max: return e-&gt;value * (d &gt;  d2 ?   d : d2);
+                case e_min: return e-&gt;value * (d &lt;  d2 ?   d : d2);
+                case e_eq:  return e-&gt;value * (d == d2 ? 1.0 : 0.0);
+                case e_gt:  return e-&gt;value * (d &gt;  d2 ? 1.0 : 0.0);
+                case e_gte: return e-&gt;value * (d &gt;= d2 ? 1.0 : 0.0);
+                case e_pow: return e-&gt;value * pow(d, d2);
+                case e_mul: return e-&gt;value * (d * d2);
+                case e_div: return e-&gt;value * (d / d2);
+                case e_add: return e-&gt;value * (d + d2);
+                case e_last:return e-&gt;value * d2;
+                case e_st : return e-&gt;value * (p-&gt;var[av_clip(d, 0, VARS-1)]= d2);
+            }
+        }
+    }
+    return NAN;
+}
+
+static int parse_expr(AVExpr **e, Parser *p);
+
+void av_free_expr(AVExpr *e)
+{
+    if (!e) return;
+    av_free_expr(e-&gt;param[0]);
+    av_free_expr(e-&gt;param[1]);
+    av_freep(&amp;e);
+}
+
+static int parse_primary(AVExpr **e, Parser *p)
+{
+    AVExpr *d = av_mallocz(sizeof(AVExpr));
+    char *next = p-&gt;s, *s0 = p-&gt;s;
+    int ret, i;
+
+    if (!d)
+        return AVERROR(ENOMEM);
+
+    /* number */
+    d-&gt;value = av_strtod(p-&gt;s, &amp;next);
+    if (next != p-&gt;s) {
+        d-&gt;type = e_value;
+        p-&gt;s= next;
+        *e = d;
+        return 0;
+    }
+    d-&gt;value = 1;
+
+    /* named constants */
+    for (i=0; p-&gt;const_names &amp;&amp; p-&gt;const_names[i]; i++) {
+        if (strmatch(p-&gt;s, p-&gt;const_names[i])) {
+            p-&gt;s+= strlen(p-&gt;const_names[i]);
+            d-&gt;type = e_const;
+            d-&gt;a.const_index = i;
+            *e = d;
+            return 0;
+        }
+    }
+
+    p-&gt;s= strchr(p-&gt;s, '(');
+    if (p-&gt;s==NULL) {
+        av_log(p, AV_LOG_ERROR, &quot;Undefined constant or missing '(' in '%s'\n&quot;, s0);
+        p-&gt;s= next;
+        av_free_expr(d);
+        return AVERROR(EINVAL);
+    }
+    p-&gt;s++; // &quot;(&quot;
+    if (*next == '(') { // special case do-nothing
+        av_freep(&amp;d);
+        if ((ret = parse_expr(&amp;d, p)) &lt; 0)
+            return ret;
+        if (p-&gt;s[0] != ')') {
+            av_log(p, AV_LOG_ERROR, &quot;Missing ')' in '%s'\n&quot;, s0);
+            av_free_expr(d);
+            return AVERROR(EINVAL);
+        }
+        p-&gt;s++; // &quot;)&quot;
+        *e = d;
+        return 0;
+    }
+    if ((ret = parse_expr(&amp;(d-&gt;param[0]), p)) &lt; 0) {
+        av_free_expr(d);
+        return ret;
+    }
+    if (p-&gt;s[0]== ',') {
+        p-&gt;s++; // &quot;,&quot;
+        parse_expr(&amp;d-&gt;param[1], p);
+    }
+    if (p-&gt;s[0] != ')') {
+        av_log(p, AV_LOG_ERROR, &quot;Missing ')' or too many args in '%s'\n&quot;, s0);
+        av_free_expr(d);
+        return AVERROR(EINVAL);
+    }
+    p-&gt;s++; // &quot;)&quot;
+
+    d-&gt;type = e_func0;
+         if (strmatch(next, &quot;sinh&quot;  )) d-&gt;a.func0 = sinh;
+    else if (strmatch(next, &quot;cosh&quot;  )) d-&gt;a.func0 = cosh;
+    else if (strmatch(next, &quot;tanh&quot;  )) d-&gt;a.func0 = tanh;
+    else if (strmatch(next, &quot;sin&quot;   )) d-&gt;a.func0 = sin;
+    else if (strmatch(next, &quot;cos&quot;   )) d-&gt;a.func0 = cos;
+    else if (strmatch(next, &quot;tan&quot;   )) d-&gt;a.func0 = tan;
+    else if (strmatch(next, &quot;atan&quot;  )) d-&gt;a.func0 = atan;
+    else if (strmatch(next, &quot;asin&quot;  )) d-&gt;a.func0 = asin;
+    else if (strmatch(next, &quot;acos&quot;  )) d-&gt;a.func0 = acos;
+    else if (strmatch(next, &quot;exp&quot;   )) d-&gt;a.func0 = exp;
+    else if (strmatch(next, &quot;log&quot;   )) d-&gt;a.func0 = log;
+    else if (strmatch(next, &quot;abs&quot;   )) d-&gt;a.func0 = fabs;
+    else if (strmatch(next, &quot;squish&quot;)) d-&gt;type = e_squish;
+    else if (strmatch(next, &quot;gauss&quot; )) d-&gt;type = e_gauss;
+    else if (strmatch(next, &quot;mod&quot;   )) d-&gt;type = e_mod;
+    else if (strmatch(next, &quot;max&quot;   )) d-&gt;type = e_max;
+    else if (strmatch(next, &quot;min&quot;   )) d-&gt;type = e_min;
+    else if (strmatch(next, &quot;eq&quot;    )) d-&gt;type = e_eq;
+    else if (strmatch(next, &quot;gte&quot;   )) d-&gt;type = e_gte;
+    else if (strmatch(next, &quot;gt&quot;    )) d-&gt;type = e_gt;
+    else if (strmatch(next, &quot;lte&quot;   )) { AVExpr *tmp = d-&gt;param[1]; d-&gt;param[1] = d-&gt;param[0]; d-&gt;param[0] = tmp; d-&gt;type = e_gt; }
+    else if (strmatch(next, &quot;lt&quot;    )) { AVExpr *tmp = d-&gt;param[1]; d-&gt;param[1] = d-&gt;param[0]; d-&gt;param[0] = tmp; d-&gt;type = e_gte; }
+    else if (strmatch(next, &quot;ld&quot;    )) d-&gt;type = e_ld;
+    else if (strmatch(next, &quot;st&quot;    )) d-&gt;type = e_st;
+    else if (strmatch(next, &quot;while&quot; )) d-&gt;type = e_while;
+    else {
+        for (i=0; p-&gt;func1_names &amp;&amp; p-&gt;func1_names[i]; i++) {
+            if (strmatch(next, p-&gt;func1_names[i])) {
+                d-&gt;a.func1 = p-&gt;funcs1[i];
+                d-&gt;type = e_func1;
+                *e = d;
+                return 0;
+            }
+        }
+
+        for (i=0; p-&gt;func2_names &amp;&amp; p-&gt;func2_names[i]; i++) {
+            if (strmatch(next, p-&gt;func2_names[i])) {
+                d-&gt;a.func2 = p-&gt;funcs2[i];
+                d-&gt;type = e_func2;
+                *e = d;
+                return 0;
+            }
+        }
+
+        av_log(p, AV_LOG_ERROR, &quot;Unknown function in '%s'\n&quot;, s0);
+        av_free_expr(d);
+        return AVERROR(EINVAL);
+    }
+
+    *e = d;
+    return 0;
+}
+
+static AVExpr *new_eval_expr(int type, int value, AVExpr *p0, AVExpr *p1)
+{
+    AVExpr *e = av_mallocz(sizeof(AVExpr));
+    if (!e)
+        return NULL;
+    e-&gt;type     =type   ;
+    e-&gt;value    =value  ;
+    e-&gt;param[0] =p0     ;
+    e-&gt;param[1] =p1     ;
+    return e;
+}
+
+static int parse_pow(AVExpr **e, Parser *p, int *sign)
+{
+    *sign= (*p-&gt;s == '+') - (*p-&gt;s == '-');
+    p-&gt;s += *sign&amp;1;
+    return parse_primary(e, p);
+}
+
+static int parse_factor(AVExpr **e, Parser *p)
+{
+    int sign, sign2, ret;
+    AVExpr *e0, *e1, *e2;
+    if ((ret = parse_pow(&amp;e0, p, &amp;sign)) &lt; 0)
+        return ret;
+    while(p-&gt;s[0]=='^'){
+        e1 = e0;
+        p-&gt;s++;
+        if ((ret = parse_pow(&amp;e2, p, &amp;sign2)) &lt; 0) {
+            av_free_expr(e1);
+            return ret;
+        }
+        e0 = new_eval_expr(e_pow, 1, e1, e2);
+        if (!e0) {
+            av_free_expr(e1);
+            av_free_expr(e2);
+            return AVERROR(ENOMEM);
+        }
+        if (e0-&gt;param[1]) e0-&gt;param[1]-&gt;value *= (sign2|1);
+    }
+    if (e0) e0-&gt;value *= (sign|1);
+
+    *e = e0;
+    return 0;
+}
+
+static int parse_term(AVExpr **e, Parser *p)
+{
+    int ret;
+    AVExpr *e0, *e1, *e2;
+    if ((ret = parse_factor(&amp;e0, p)) &lt; 0)
+        return ret;
+    while (p-&gt;s[0]=='*' || p-&gt;s[0]=='/') {
+        int c= *p-&gt;s++;
+        e1 = e0;
+        if ((ret = parse_factor(&amp;e2, p)) &lt; 0) {
+            av_free_expr(e1);
+            return ret;
+        }
+        e0 = new_eval_expr(c == '*' ? e_mul : e_div, 1, e1, e2);
+        if (!e0) {
+            av_free_expr(e1);
+            av_free_expr(e2);
+            return AVERROR(ENOMEM);
+        }
+    }
+    *e = e0;
+    return 0;
+}
+
+static int parse_subexpr(AVExpr **e, Parser *p)
+{
+    int ret;
+    AVExpr *e0, *e1, *e2;
+    if ((ret = parse_term(&amp;e0, p)) &lt; 0)
+        return ret;
+    while (*p-&gt;s == '+' || *p-&gt;s == '-') {
+        e1 = e0;
+        if ((ret = parse_term(&amp;e2, p)) &lt; 0) {
+            av_free_expr(e1);
+            return ret;
+        }
+        e0 = new_eval_expr(e_add, 1, e1, e2);
+        if (!e0) {
+            av_free_expr(e1);
+            av_free_expr(e2);
+            return AVERROR(ENOMEM);
+        }
+    };
+
+    *e = e0;
+    return 0;
+}
+
+static int parse_expr(AVExpr **e, Parser *p)
+{
+    int ret;
+    AVExpr *e0, *e1, *e2;
+    if (p-&gt;stack_index &lt;= 0) //protect against stack overflows
+        return AVERROR(EINVAL);
+    p-&gt;stack_index--;
+
+    if ((ret = parse_subexpr(&amp;e0, p)) &lt; 0)
+        return ret;
+    while (*p-&gt;s == ';') {
+        e1 = e0;
+        if ((ret = parse_subexpr(&amp;e2, p)) &lt; 0) {
+            av_free_expr(e1);
+            return ret;
+        }
+        p-&gt;s++;
+        e0 = new_eval_expr(e_last, 1, e1, e2);
+        if (!e0) {
+            av_free_expr(e1);
+            av_free_expr(e2);
+            return AVERROR(ENOMEM);
+        }
+    };
+
+    p-&gt;stack_index++;
+    *e = e0;
+    return 0;
+}
+
+static int verify_expr(AVExpr *e)
+{
+    if (!e) return 0;
+    switch (e-&gt;type) {
+        case e_value:
+        case e_const: return 1;
+        case e_func0:
+        case e_func1:
+        case e_squish:
+        case e_ld:
+        case e_gauss: return verify_expr(e-&gt;param[0]);
+        default: return verify_expr(e-&gt;param[0]) &amp;&amp; verify_expr(e-&gt;param[1]);
+    }
+}
+
+int av_parse_expr(AVExpr **expr, const char *s,
+                  const char * const *const_names,
+                  const char * const *func1_names, double (* const *funcs1)(void *, double),
+                  const char * const *func2_names, double (* const *funcs2)(void *, double, double),
+                  int log_offset, void *log_ctx)
+{
+    Parser p;
+    AVExpr *e = NULL;
+    char *w = av_malloc(strlen(s) + 1);
+    char *wp = w;
+    const char *s0 = s;
+    int ret = 0;
+
+    if (!w)
+        return AVERROR(ENOMEM);
+
+    while (*s)
+        if (!isspace(*s++)) *wp++ = s[-1];
+    *wp++ = 0;
+
+    p.class      = &class;
+    p.stack_index=100;
+    p.s= w;
+    p.const_names = const_names;
+    p.funcs1      = funcs1;
+    p.func1_names = func1_names;
+    p.funcs2      = funcs2;
+    p.func2_names = func2_names;
+    p.log_offset = log_offset;
+    p.log_ctx    = log_ctx;
+
+    if ((ret = parse_expr(&amp;e, &amp;p)) &lt; 0)
+        goto end;
+    if (*p.s) {
+        av_log(&amp;p, AV_LOG_ERROR, &quot;Invalid chars '%s' at the end of expression '%s'\n&quot;, p.s, s0);
+        ret = AVERROR(EINVAL);
+        goto end;
+    }
+    if (!verify_expr(e)) {
+        av_free_expr(e);
+        ret = AVERROR(EINVAL);
+        goto end;
+    }
+    *expr = e;
+end:
+    av_free(w);
+    return ret;
+}
+
+double av_eval_expr(AVExpr *e, const double *const_values, void *opaque)
+{
+    Parser p;
+
+    p.const_values = const_values;
+    p.opaque     = opaque;
+    return eval_expr(&amp;p, e);
+}
+
+int av_parse_and_eval_expr(double *d, const char *s,
+                           const char * const *const_names, const double *const_values,
+                           const char * const *func1_names, double (* const *funcs1)(void *, double),
+                           const char * const *func2_names, double (* const *funcs2)(void *, double, double),
+                           void *opaque, int log_offset, void *log_ctx)
+{
+    AVExpr *e = NULL;
+    int ret = av_parse_expr(&amp;e, s, const_names, func1_names, funcs1, func2_names, funcs2, log_offset, log_ctx);
+
+    if (ret &lt; 0) {
+        *d = NAN;
+        return ret;
+    }
+    *d = av_eval_expr(e, const_values, opaque);
+    av_free_expr(e);
+    return isnan(*d) ? AVERROR(EINVAL) : 0;
+}
+
+#ifdef TEST
+#undef printf
+static double const_values[] = {
+    M_PI,
+    M_E,
+    0
+};
+
+static const char *const_names[] = {
+    &quot;PI&quot;,
+    &quot;E&quot;,
+    0
+};
+
+int main(void)
+{
+    int i;
+    double d;
+    const char **expr, *exprs[] = {
+        &quot;&quot;,
+        &quot;1+(5-2)^(3-1)+1/2+sin(PI)-max(-2.2,-3.1)&quot;,
+        &quot;80G/80Gi&quot;
+        &quot;1k&quot;,
+        &quot;1Gi&quot;,
+        &quot;1gi&quot;,
+        &quot;1GiFoo&quot;,
+        &quot;1k+1k&quot;,
+        &quot;1Gi*3foo&quot;,
+        &quot;foo&quot;,
+        &quot;foo(&quot;,
+        &quot;foo()&quot;,
+        &quot;foo)&quot;,
+        &quot;sin&quot;,
+        &quot;sin(&quot;,
+        &quot;sin()&quot;,
+        &quot;sin)&quot;,
+        &quot;sin 10&quot;,
+        &quot;sin(1,2,3)&quot;,
+        &quot;sin(1 )&quot;,
+        &quot;1&quot;,
+        &quot;1foo&quot;,
+        &quot;bar + PI + E + 100f*2 + foo&quot;,
+        &quot;13k + 12f - foo(1, 2)&quot;,
+        &quot;1gi&quot;,
+        &quot;1Gi&quot;,
+        NULL
+    };
+
+    for (expr = exprs; *expr; expr++) {
+        printf(&quot;Evaluating '%s'\n&quot;, *expr);
+        av_parse_and_eval_expr(&amp;d, *expr,
+                               const_names, const_values,
+                               NULL, NULL, NULL, NULL, NULL, 0, NULL);
+        printf(&quot;'%s' -&gt; %f\n\n&quot;, *expr, d);
+    }
+
+    av_parse_and_eval_expr(&amp;d, &quot;1+(5-2)^(3-1)+1/2+sin(PI)-max(-2.2,-3.1)&quot;,
+                           const_names, const_values,
+                           NULL, NULL, NULL, NULL, NULL, 0, NULL);
+    printf(&quot;%f == 12.7\n&quot;, d);
+    av_parse_and_eval_expr(&amp;d, &quot;80G/80Gi&quot;,
+                           const_names, const_values,
+                           NULL, NULL, NULL, NULL, NULL, 0, NULL);
+    printf(&quot;%f == 0.931322575\n&quot;, d);
+
+    for (i=0; i&lt;1050; i++) {
+        START_TIMER
+            av_parse_and_eval_expr(&amp;d, &quot;1+(5-2)^(3-1)+1/2+sin(PI)-max(-2.2,-3.1)&quot;,
+                                   const_names, const_values,
+                                   NULL, NULL, NULL, NULL, NULL, 0, NULL);
+        STOP_TIMER(&quot;av_parse_and_eval_expr&quot;)
+    }
+    return 0;
+}
+#endif

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/eval.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/eval.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/eval.h	2010-07-25 10:07:39 UTC (rev 6478)
@@ -0,0 +1,111 @@
+/*
+ * Copyright (c) 2002 Michael Niedermayer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">michaelni at gmx.at</A>&gt;
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * simple arithmetic expression evaluator
+ */
+
+#ifndef AVUTIL_EVAL_H
+#define AVUTIL_EVAL_H
+
+typedef struct AVExpr AVExpr;
+
+/**
+ * Parse and evaluate an expression.
+ * Note, this is significantly slower than av_eval_expr().
+ *
+ * @param res a pointer to a double where is put the result value of
+ * the expression, or NAN in case of error
+ * @param s expression as a zero terminated string, for example &quot;1+2^3+5*5+sin(2/3)&quot;
+ * @param const_names NULL terminated array of zero terminated strings of constant identifiers, for example {&quot;PI&quot;, &quot;E&quot;, 0}
+ * @param const_values a zero terminated array of values for the identifiers from const_names
+ * @param func1_names NULL terminated array of zero terminated strings of funcs1 identifiers
+ * @param funcs1 NULL terminated array of function pointers for functions which take 1 argument
+ * @param func2_names NULL terminated array of zero terminated strings of funcs2 identifiers
+ * @param funcs2 NULL terminated array of function pointers for functions which take 2 arguments
+ * @param opaque a pointer which will be passed to all functions from funcs1 and funcs2
+ * @param log_ctx parent logging context
+ * @return 0 in case of success, a negative value corresponding to an
+ * AVERROR code otherwise
+ */
+int av_parse_and_eval_expr(double *res, const char *s,
+                           const char * const *const_names, const double *const_values,
+                           const char * const *func1_names, double (* const *funcs1)(void *, double),
+                           const char * const *func2_names, double (* const *funcs2)(void *, double, double),
+                           void *opaque, int log_offset, void *log_ctx);
+
+/**
+ * Parse an expression.
+ *
+ * @param expr a pointer where is put an AVExpr containing the parsed
+ * value in case of successfull parsing, or NULL otherwise.
+ * The pointed to AVExpr must be freed with av_free_expr() by the user
+ * when it is not needed anymore.
+ * @param s expression as a zero terminated string, for example &quot;1+2^3+5*5+sin(2/3)&quot;
+ * @param const_names NULL terminated array of zero terminated strings of constant identifiers, for example {&quot;PI&quot;, &quot;E&quot;, 0}
+ * @param func1_names NULL terminated array of zero terminated strings of funcs1 identifiers
+ * @param funcs1 NULL terminated array of function pointers for functions which take 1 argument
+ * @param func2_names NULL terminated array of zero terminated strings of funcs2 identifiers
+ * @param funcs2 NULL terminated array of function pointers for functions which take 2 arguments
+ * @param log_ctx parent logging context
+ * @return 0 in case of success, a negative value corresponding to an
+ * AVERROR code otherwise
+ */
+int av_parse_expr(AVExpr **expr, const char *s,
+                  const char * const *const_names,
+                  const char * const *func1_names, double (* const *funcs1)(void *, double),
+                  const char * const *func2_names, double (* const *funcs2)(void *, double, double),
+                  int log_offset, void *log_ctx);
+
+/**
+ * Evaluate a previously parsed expression.
+ *
+ * @param const_values a zero terminated array of values for the identifiers from av_parse_expr() const_names
+ * @param opaque a pointer which will be passed to all functions from funcs1 and funcs2
+ * @return the value of the expression
+ */
+double av_eval_expr(AVExpr *e, const double *const_values, void *opaque);
+
+/**
+ * Free a parsed expression previously created with av_parse_expr().
+ */
+void av_free_expr(AVExpr *e);
+
+/**
+ * Parse the string in numstr and return its value as a double. If
+ * the string is empty, contains only whitespaces, or does not contain
+ * an initial substring that has the expected syntax for a
+ * floating-point number, no conversion is performed. In this case,
+ * returns a value of zero and the value returned in tail is the value
+ * of numstr.
+ *
+ * @param numstr a string representing a number, may contain one of
+ * the International System number postfixes, for example 'K', 'M',
+ * 'G'. If 'i' is appended after the postfix, powers of 2 are used
+ * instead of powers of 10. The 'B' postfix multiplies the value for
+ * 8, and can be appended after another postfix or used alone. This
+ * allows using for example 'KB', 'MiB', 'G' and 'B' as postfix.
+ * @param tail if non-NULL puts here the pointer to the char next
+ * after the last parsed character
+ */
+double av_strtod(const char *numstr, char **tail);
+
+#endif /* AVUTIL_EVAL_H */


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003664.html">[Avidemux-svn-commit] r6476 - in	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6:	. resampleFps
</A></li>
	<LI>Next message: <A HREF="003666.html">[Avidemux-svn-commit] r6479 -	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/ffmpeg_config
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3665">[ date ]</a>
              <a href="thread.html#3665">[ thread ]</a>
              <a href="subject.html#3665">[ subject ]</a>
              <a href="author.html#3665">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
