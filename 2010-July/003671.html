<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r6484 -	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2010-July/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r6484%20-%0A%09branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat&In-Reply-To=%3C20100725100755.7E8DE480E6C%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003670.html">
   <LINK REL="Next"  HREF="003672.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r6484 -	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat</H1>
    <B>mean at mail.berlios.de</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r6484%20-%0A%09branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat&In-Reply-To=%3C20100725100755.7E8DE480E6C%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r6484 -	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat">mean at mail.berlios.de
       </A><BR>
    <I>Sun Jul 25 12:07:55 CEST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="003670.html">[Avidemux-svn-commit] r6483 - in	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg:	libavcodec libavcodec/x86 patches patches/avcodec
</A></li>
        <LI>Next message: <A HREF="003672.html">[Avidemux-svn-commit] r6485 - in	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches:	. avcodec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3671">[ date ]</a>
              <a href="thread.html#3671">[ thread ]</a>
              <a href="subject.html#3671">[ subject ]</a>
              <a href="author.html#3671">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2010-07-25 12:07:55 +0200 (Sun, 25 Jul 2010)
New Revision: 6484

Removed:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/movenc.c.orig
Log:
[cleanup] libavformat/movenc.c.orig

Deleted: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/movenc.c.orig
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/movenc.c.orig	2010-07-25 10:07:52 UTC (rev 6483)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/movenc.c.orig	2010-07-25 10:07:55 UTC (rev 6484)
@@ -1,2300 +0,0 @@
-/*
- * MOV, 3GP, MP4 muxer
- * Copyright (c) 2003 Thomas Raivio
- * Copyright (c) 2004 Gildas Bazin &lt;gbazin at videolan dot org&gt;
- * Copyright (c) 2009 Baptiste Coudurier &lt;baptiste dot coudurier at gmail dot com&gt;
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#include &quot;movenc.h&quot;
-#include &quot;avformat.h&quot;
-#include &quot;riff.h&quot;
-#include &quot;avio.h&quot;
-#include &quot;isom.h&quot;
-#include &quot;avc.h&quot;
-#include &quot;libavcodec/get_bits.h&quot;
-#include &quot;libavcodec/put_bits.h&quot;
-#include &quot;internal.h&quot;
-#include &quot;libavutil/avstring.h&quot;
-
-#undef NDEBUG
-#include &lt;assert.h&gt;
-
-//FIXME support 64 bit variant with wide placeholders
-static int64_t updateSize(ByteIOContext *pb, int64_t pos)
-{
-    int64_t curpos = url_ftell(pb);
-    url_fseek(pb, pos, SEEK_SET);
-    put_be32(pb, curpos - pos); /* rewrite size */
-    url_fseek(pb, curpos, SEEK_SET);
-
-    return curpos - pos;
-}
-
-/* Chunk offset atom */
-static int mov_write_stco_tag(ByteIOContext *pb, MOVTrack *track)
-{
-    int i;
-    int mode64 = 0; //   use 32 bit size variant if possible
-    int64_t pos = url_ftell(pb);
-    put_be32(pb, 0); /* size */
-    if (pos &gt; UINT32_MAX) {
-        mode64 = 1;
-        put_tag(pb, &quot;co64&quot;);
-    } else
-        put_tag(pb, &quot;stco&quot;);
-    put_be32(pb, 0); /* version &amp; flags */
-    put_be32(pb, track-&gt;entry); /* entry count */
-    for (i=0; i&lt;track-&gt;entry; i++) {
-        if(mode64 == 1)
-            put_be64(pb, track-&gt;cluster[i].pos);
-        else
-            put_be32(pb, track-&gt;cluster[i].pos);
-    }
-    return updateSize(pb, pos);
-}
-
-/* Sample size atom */
-static int mov_write_stsz_tag(ByteIOContext *pb, MOVTrack *track)
-{
-    int equalChunks = 1;
-    int i, j, entries = 0, tst = -1, oldtst = -1;
-
-    int64_t pos = url_ftell(pb);
-    put_be32(pb, 0); /* size */
-    put_tag(pb, &quot;stsz&quot;);
-    put_be32(pb, 0); /* version &amp; flags */
-
-    for (i=0; i&lt;track-&gt;entry; i++) {
-        tst = track-&gt;cluster[i].size/track-&gt;cluster[i].entries;
-        if(oldtst != -1 &amp;&amp; tst != oldtst) {
-            equalChunks = 0;
-        }
-        oldtst = tst;
-        entries += track-&gt;cluster[i].entries;
-    }
-    if (equalChunks) {
-        int sSize = track-&gt;cluster[0].size/track-&gt;cluster[0].entries;
-        put_be32(pb, sSize); // sample size
-        put_be32(pb, entries); // sample count
-    }
-    else {
-        put_be32(pb, 0); // sample size
-        put_be32(pb, entries); // sample count
-        for (i=0; i&lt;track-&gt;entry; i++) {
-            for (j=0; j&lt;track-&gt;cluster[i].entries; j++) {
-                put_be32(pb, track-&gt;cluster[i].size /
-                         track-&gt;cluster[i].entries);
-            }
-        }
-    }
-    return updateSize(pb, pos);
-}
-
-/* Sample to chunk atom */
-static int mov_write_stsc_tag(ByteIOContext *pb, MOVTrack *track)
-{
-    int index = 0, oldval = -1, i;
-    int64_t entryPos, curpos;
-
-    int64_t pos = url_ftell(pb);
-    put_be32(pb, 0); /* size */
-    put_tag(pb, &quot;stsc&quot;);
-    put_be32(pb, 0); // version &amp; flags
-    entryPos = url_ftell(pb);
-    put_be32(pb, track-&gt;entry); // entry count
-    for (i=0; i&lt;track-&gt;entry; i++) {
-        if(oldval != track-&gt;cluster[i].samplesInChunk)
-        {
-            put_be32(pb, i+1); // first chunk
-            put_be32(pb, track-&gt;cluster[i].samplesInChunk); // samples per chunk
-            put_be32(pb, 0x1); // sample description index
-            oldval = track-&gt;cluster[i].samplesInChunk;
-            index++;
-        }
-    }
-    curpos = url_ftell(pb);
-    url_fseek(pb, entryPos, SEEK_SET);
-    put_be32(pb, index); // rewrite size
-    url_fseek(pb, curpos, SEEK_SET);
-
-    return updateSize(pb, pos);
-}
-
-/* Sync sample atom */
-static int mov_write_stss_tag(ByteIOContext *pb, MOVTrack *track, uint32_t flag)
-{
-    int64_t curpos, entryPos;
-    int i, index = 0;
-    int64_t pos = url_ftell(pb);
-    put_be32(pb, 0); // size
-    put_tag(pb, flag == MOV_SYNC_SAMPLE ? &quot;stss&quot; : &quot;stps&quot;);
-    put_be32(pb, 0); // version &amp; flags
-    entryPos = url_ftell(pb);
-    put_be32(pb, track-&gt;entry); // entry count
-    for (i=0; i&lt;track-&gt;entry; i++) {
-        if (track-&gt;cluster[i].flags &amp; flag) {
-            put_be32(pb, i+1);
-            index++;
-        }
-    }
-    curpos = url_ftell(pb);
-    url_fseek(pb, entryPos, SEEK_SET);
-    put_be32(pb, index); // rewrite size
-    url_fseek(pb, curpos, SEEK_SET);
-    return updateSize(pb, pos);
-}
-
-static int mov_write_amr_tag(ByteIOContext *pb, MOVTrack *track)
-{
-    put_be32(pb, 0x11); /* size */
-    if (track-&gt;mode == MODE_MOV) put_tag(pb, &quot;samr&quot;);
-    else                         put_tag(pb, &quot;damr&quot;);
-    put_tag(pb, &quot;FFMP&quot;);
-    put_byte(pb, 0); /* decoder version */
-
-    put_be16(pb, 0x81FF); /* Mode set (all modes for AMR_NB) */
-    put_byte(pb, 0x00); /* Mode change period (no restriction) */
-    put_byte(pb, 0x01); /* Frames per sample */
-    return 0x11;
-}
-
-static int mov_write_ac3_tag(ByteIOContext *pb, MOVTrack *track)
-{
-    GetBitContext gbc;
-    PutBitContext pbc;
-    uint8_t buf[3];
-    int fscod, bsid, bsmod, acmod, lfeon, frmsizecod;
-
-    if (track-&gt;vosLen &lt; 7)
-        return -1;
-
-    put_be32(pb, 11);
-    put_tag(pb, &quot;dac3&quot;);
-
-    init_get_bits(&amp;gbc, track-&gt;vosData+4, track-&gt;vosLen-4);
-    fscod      = get_bits(&amp;gbc, 2);
-    frmsizecod = get_bits(&amp;gbc, 6);
-    bsid       = get_bits(&amp;gbc, 5);
-    bsmod      = get_bits(&amp;gbc, 3);
-    acmod      = get_bits(&amp;gbc, 3);
-    if (acmod == 2) {
-        skip_bits(&amp;gbc, 2); // dsurmod
-    } else {
-        if ((acmod &amp; 1) &amp;&amp; acmod != 1)
-            skip_bits(&amp;gbc, 2); // cmixlev
-        if (acmod &amp; 4)
-            skip_bits(&amp;gbc, 2); // surmixlev
-    }
-    lfeon = get_bits1(&amp;gbc);
-
-    init_put_bits(&amp;pbc, buf, sizeof(buf));
-    put_bits(&amp;pbc, 2, fscod);
-    put_bits(&amp;pbc, 5, bsid);
-    put_bits(&amp;pbc, 3, bsmod);
-    put_bits(&amp;pbc, 3, acmod);
-    put_bits(&amp;pbc, 1, lfeon);
-    put_bits(&amp;pbc, 5, frmsizecod&gt;&gt;1); // bit_rate_code
-    put_bits(&amp;pbc, 5, 0); // reserved
-
-    flush_put_bits(&amp;pbc);
-    put_buffer(pb, buf, sizeof(buf));
-
-    return 11;
-}
-
-/**
- * This function writes extradata &quot;as is&quot;.
- * Extradata must be formated like a valid atom (with size and tag)
- */
-static int mov_write_extradata_tag(ByteIOContext *pb, MOVTrack *track)
-{
-    put_buffer(pb, track-&gt;enc-&gt;extradata, track-&gt;enc-&gt;extradata_size);
-    return track-&gt;enc-&gt;extradata_size;
-}
-
-static int mov_write_enda_tag(ByteIOContext *pb)
-{
-    put_be32(pb, 10);
-    put_tag(pb, &quot;enda&quot;);
-    put_be16(pb, 1); /* little endian */
-    return 10;
-}
-
-static unsigned int descrLength(unsigned int len)
-{
-    int i;
-    for(i=1; len&gt;&gt;(7*i); i++);
-    return len + 1 + i;
-}
-
-static void putDescr(ByteIOContext *pb, int tag, unsigned int size)
-{
-    int i= descrLength(size) - size - 2;
-    put_byte(pb, tag);
-    for(; i&gt;0; i--)
-        put_byte(pb, (size&gt;&gt;(7*i)) | 0x80);
-    put_byte(pb, size &amp; 0x7F);
-}
-
-static int mov_write_esds_tag(ByteIOContext *pb, MOVTrack *track) // Basic
-{
-    int64_t pos = url_ftell(pb);
-    int decoderSpecificInfoLen = track-&gt;vosLen ? descrLength(track-&gt;vosLen):0;
-
-    put_be32(pb, 0); // size
-    put_tag(pb, &quot;esds&quot;);
-    put_be32(pb, 0); // Version
-
-    // ES descriptor
-    putDescr(pb, 0x03, 3 + descrLength(13 + decoderSpecificInfoLen) +
-             descrLength(1));
-    put_be16(pb, track-&gt;trackID);
-    put_byte(pb, 0x00); // flags (= no flags)
-
-    // DecoderConfig descriptor
-    putDescr(pb, 0x04, 13 + decoderSpecificInfoLen);
-
-    // Object type indication
-    if ((track-&gt;enc-&gt;codec_id == CODEC_ID_MP2 ||
-         track-&gt;enc-&gt;codec_id == CODEC_ID_MP3) &amp;&amp;
-        track-&gt;enc-&gt;sample_rate &gt; 24000)
-        put_byte(pb, 0x6B); // 11172-3
-    else
-        put_byte(pb, ff_codec_get_tag(ff_mp4_obj_type, track-&gt;enc-&gt;codec_id));
-
-    // the following fields is made of 6 bits to identify the streamtype (4 for video, 5 for audio)
-    // plus 1 bit to indicate upstream and 1 bit set to 1 (reserved)
-    if(track-&gt;enc-&gt;codec_type == AVMEDIA_TYPE_AUDIO)
-        put_byte(pb, 0x15); // flags (= Audiostream)
-    else
-        put_byte(pb, 0x11); // flags (= Visualstream)
-
-    put_byte(pb,  track-&gt;enc-&gt;rc_buffer_size&gt;&gt;(3+16));    // Buffersize DB (24 bits)
-    put_be16(pb, (track-&gt;enc-&gt;rc_buffer_size&gt;&gt;3)&amp;0xFFFF); // Buffersize DB
-
-    put_be32(pb, FFMAX(track-&gt;enc-&gt;bit_rate, track-&gt;enc-&gt;rc_max_rate)); // maxbitrate (FIXME should be max rate in any 1 sec window)
-    if(track-&gt;enc-&gt;rc_max_rate != track-&gt;enc-&gt;rc_min_rate || track-&gt;enc-&gt;rc_min_rate==0)
-        put_be32(pb, 0); // vbr
-    else
-        put_be32(pb, track-&gt;enc-&gt;rc_max_rate); // avg bitrate
-
-    if (track-&gt;vosLen) {
-        // DecoderSpecific info descriptor
-        putDescr(pb, 0x05, track-&gt;vosLen);
-        put_buffer(pb, track-&gt;vosData, track-&gt;vosLen);
-    }
-
-    // SL descriptor
-    putDescr(pb, 0x06, 1);
-    put_byte(pb, 0x02);
-    return updateSize(pb, pos);
-}
-
-static int mov_pcm_le_gt16(enum CodecID codec_id)
-{
-    return codec_id == CODEC_ID_PCM_S24LE ||
-           codec_id == CODEC_ID_PCM_S32LE ||
-           codec_id == CODEC_ID_PCM_F32LE ||
-           codec_id == CODEC_ID_PCM_F64LE;
-}
-
-static int mov_write_wave_tag(ByteIOContext *pb, MOVTrack *track)
-{
-    int64_t pos = url_ftell(pb);
-
-    put_be32(pb, 0);     /* size */
-    put_tag(pb, &quot;wave&quot;);
-
-    put_be32(pb, 12);    /* size */
-    put_tag(pb, &quot;frma&quot;);
-    put_le32(pb, track-&gt;tag);
-
-    if (track-&gt;enc-&gt;codec_id == CODEC_ID_AAC) {
-        /* useless atom needed by mplayer, ipod, not needed by quicktime */
-        put_be32(pb, 12); /* size */
-        put_tag(pb, &quot;mp4a&quot;);
-        put_be32(pb, 0);
-        mov_write_esds_tag(pb, track);
-    } else if (mov_pcm_le_gt16(track-&gt;enc-&gt;codec_id)) {
-        mov_write_enda_tag(pb);
-    } else if (track-&gt;enc-&gt;codec_id == CODEC_ID_AMR_NB) {
-        mov_write_amr_tag(pb, track);
-    } else if (track-&gt;enc-&gt;codec_id == CODEC_ID_AC3) {
-        mov_write_ac3_tag(pb, track);
-    } else if (track-&gt;enc-&gt;codec_id == CODEC_ID_ALAC) {
-        mov_write_extradata_tag(pb, track);
-    }
-
-    put_be32(pb, 8);     /* size */
-    put_be32(pb, 0);     /* null tag */
-
-    return updateSize(pb, pos);
-}
-
-static int mov_write_glbl_tag(ByteIOContext *pb, MOVTrack *track)
-{
-    put_be32(pb, track-&gt;vosLen+8);
-    put_tag(pb, &quot;glbl&quot;);
-    put_buffer(pb, track-&gt;vosData, track-&gt;vosLen);
-    return 8+track-&gt;vosLen;
-}
-
-/**
- * Compute flags for 'lpcm' tag.
- * See CoreAudioTypes and AudioStreamBasicDescription at Apple.
- */
-static int mov_get_lpcm_flags(enum CodecID codec_id)
-{
-    switch (codec_id) {
-    case CODEC_ID_PCM_F32BE:
-    case CODEC_ID_PCM_F64BE:
-        return 11;
-    case CODEC_ID_PCM_F32LE:
-    case CODEC_ID_PCM_F64LE:
-        return 9;
-    case CODEC_ID_PCM_U8:
-        return 10;
-    case CODEC_ID_PCM_S16BE:
-    case CODEC_ID_PCM_S24BE:
-    case CODEC_ID_PCM_S32BE:
-        return 14;
-    case CODEC_ID_PCM_S8:
-    case CODEC_ID_PCM_S16LE:
-    case CODEC_ID_PCM_S24LE:
-    case CODEC_ID_PCM_S32LE:
-        return 12;
-    default:
-        return 0;
-    }
-}
-
-static int mov_write_audio_tag(ByteIOContext *pb, MOVTrack *track)
-{
-    int64_t pos = url_ftell(pb);
-    int version = 0;
-    uint32_t tag = track-&gt;tag;
-
-    if (track-&gt;mode == MODE_MOV) {
-        if (track-&gt;timescale &gt; UINT16_MAX) {
-            if (mov_get_lpcm_flags(track-&gt;enc-&gt;codec_id))
-                tag = AV_RL32(&quot;lpcm&quot;);
-            version = 2;
-        } else if (track-&gt;audio_vbr || mov_pcm_le_gt16(track-&gt;enc-&gt;codec_id)) {
-            version = 1;
-        }
-    }
-
-    put_be32(pb, 0); /* size */
-    put_le32(pb, tag); // store it byteswapped
-    put_be32(pb, 0); /* Reserved */
-    put_be16(pb, 0); /* Reserved */
-    put_be16(pb, 1); /* Data-reference index, XXX  == 1 */
-
-    /* SoundDescription */
-    put_be16(pb, version); /* Version */
-    put_be16(pb, 0); /* Revision level */
-    put_be32(pb, 0); /* Reserved */
-
-    if (version == 2) {
-        put_be16(pb, 3);
-        put_be16(pb, 16);
-        put_be16(pb, 0xfffe);
-        put_be16(pb, 0);
-        put_be32(pb, 0x00010000);
-        put_be32(pb, 72);
-        put_be64(pb, av_dbl2int(track-&gt;timescale));
-        put_be32(pb, track-&gt;enc-&gt;channels);
-        put_be32(pb, 0x7F000000);
-        put_be32(pb, av_get_bits_per_sample(track-&gt;enc-&gt;codec_id));
-        put_be32(pb, mov_get_lpcm_flags(track-&gt;enc-&gt;codec_id));
-        put_be32(pb, track-&gt;sampleSize);
-        put_be32(pb, track-&gt;enc-&gt;frame_size);
-    } else {
-        if (track-&gt;mode == MODE_MOV) {
-            put_be16(pb, track-&gt;enc-&gt;channels);
-            if (track-&gt;enc-&gt;codec_id == CODEC_ID_PCM_U8 ||
-                track-&gt;enc-&gt;codec_id == CODEC_ID_PCM_S8)
-                put_be16(pb, 8); /* bits per sample */
-            else
-                put_be16(pb, 16);
-            put_be16(pb, track-&gt;audio_vbr ? -2 : 0); /* compression ID */
-        } else { /* reserved for mp4/3gp */
-            put_be16(pb, 2);
-            put_be16(pb, 16);
-            put_be16(pb, 0);
-        }
-
-        put_be16(pb, 0); /* packet size (= 0) */
-        put_be16(pb, track-&gt;timescale); /* Time scale */
-        put_be16(pb, 0); /* Reserved */
-    }
-
-    if(version == 1) { /* SoundDescription V1 extended info */
-        put_be32(pb, track-&gt;enc-&gt;frame_size); /* Samples per packet */
-        put_be32(pb, track-&gt;sampleSize / track-&gt;enc-&gt;channels); /* Bytes per packet */
-        put_be32(pb, track-&gt;sampleSize); /* Bytes per frame */
-        put_be32(pb, 2); /* Bytes per sample */
-    }
-
-    if(track-&gt;mode == MODE_MOV &amp;&amp;
-       (track-&gt;enc-&gt;codec_id == CODEC_ID_AAC ||
-        track-&gt;enc-&gt;codec_id == CODEC_ID_AC3 ||
-        track-&gt;enc-&gt;codec_id == CODEC_ID_AMR_NB ||
-        track-&gt;enc-&gt;codec_id == CODEC_ID_ALAC ||
-        mov_pcm_le_gt16(track-&gt;enc-&gt;codec_id)))
-        mov_write_wave_tag(pb, track);
-    else if(track-&gt;tag == MKTAG('m','p','4','a'))
-        mov_write_esds_tag(pb, track);
-    else if(track-&gt;enc-&gt;codec_id == CODEC_ID_AMR_NB)
-        mov_write_amr_tag(pb, track);
-    else if(track-&gt;enc-&gt;codec_id == CODEC_ID_AC3)
-        mov_write_ac3_tag(pb, track);
-    else if(track-&gt;enc-&gt;codec_id == CODEC_ID_ALAC)
-        mov_write_extradata_tag(pb, track);
-    else if(track-&gt;vosLen &gt; 0)
-        mov_write_glbl_tag(pb, track);
-
-    return updateSize(pb, pos);
-}
-
-static int mov_write_d263_tag(ByteIOContext *pb)
-{
-    put_be32(pb, 0xf); /* size */
-    put_tag(pb, &quot;d263&quot;);
-    put_tag(pb, &quot;FFMP&quot;);
-    put_byte(pb, 0); /* decoder version */
-    /* FIXME use AVCodecContext level/profile, when encoder will set values */
-    put_byte(pb, 0xa); /* level */
-    put_byte(pb, 0); /* profile */
-    return 0xf;
-}
-
-/* TODO: No idea about these values */
-static int mov_write_svq3_tag(ByteIOContext *pb)
-{
-    put_be32(pb, 0x15);
-    put_tag(pb, &quot;SMI &quot;);
-    put_tag(pb, &quot;SEQH&quot;);
-    put_be32(pb, 0x5);
-    put_be32(pb, 0xe2c0211d);
-    put_be32(pb, 0xc0000000);
-    put_byte(pb, 0);
-    return 0x15;
-}
-
-static int mov_write_avcc_tag(ByteIOContext *pb, MOVTrack *track)
-{
-    int64_t pos = url_ftell(pb);
-
-    put_be32(pb, 0);
-    put_tag(pb, &quot;avcC&quot;);
-    ff_isom_write_avcc(pb, track-&gt;vosData, track-&gt;vosLen);
-    return updateSize(pb, pos);
-}
-
-/* also used by all avid codecs (dv, imx, meridien) and their variants */
-static int mov_write_avid_tag(ByteIOContext *pb, MOVTrack *track)
-{
-    int i;
-    put_be32(pb, 24); /* size */
-    put_tag(pb, &quot;ACLR&quot;);
-    put_tag(pb, &quot;ACLR&quot;);
-    put_tag(pb, &quot;0001&quot;);
-    put_be32(pb, 1); /* yuv 1 / rgb 2 ? */
-    put_be32(pb, 0); /* unknown */
-
-    put_be32(pb, 24); /* size */
-    put_tag(pb, &quot;APRG&quot;);
-    put_tag(pb, &quot;APRG&quot;);
-    put_tag(pb, &quot;0001&quot;);
-    put_be32(pb, 1); /* unknown */
-    put_be32(pb, 0); /* unknown */
-
-    put_be32(pb, 120); /* size */
-    put_tag(pb, &quot;ARES&quot;);
-    put_tag(pb, &quot;ARES&quot;);
-    put_tag(pb, &quot;0001&quot;);
-    put_be32(pb, AV_RB32(track-&gt;vosData + 0x28)); /* dnxhd cid, some id ? */
-    put_be32(pb, track-&gt;enc-&gt;width);
-    /* values below are based on samples created with quicktime and avid codecs */
-    if (track-&gt;vosData[5] &amp; 2) { // interlaced
-        put_be32(pb, track-&gt;enc-&gt;height/2);
-        put_be32(pb, 2); /* unknown */
-        put_be32(pb, 0); /* unknown */
-        put_be32(pb, 4); /* unknown */
-    } else {
-        put_be32(pb, track-&gt;enc-&gt;height);
-        put_be32(pb, 1); /* unknown */
-        put_be32(pb, 0); /* unknown */
-        if (track-&gt;enc-&gt;height == 1080)
-            put_be32(pb, 5); /* unknown */
-        else
-            put_be32(pb, 6); /* unknown */
-    }
-    /* padding */
-    for (i = 0; i &lt; 10; i++)
-        put_be64(pb, 0);
-
-    /* extra padding for stsd needed */
-    put_be32(pb, 0);
-    return 0;
-}
-
-static int mp4_get_codec_tag(AVFormatContext *s, MOVTrack *track)
-{
-    int tag = track-&gt;enc-&gt;codec_tag;
-
-    if (!ff_codec_get_tag(ff_mp4_obj_type, track-&gt;enc-&gt;codec_id))
-        return 0;
-
-    if      (track-&gt;enc-&gt;codec_id == CODEC_ID_H264)      tag = MKTAG('a','v','c','1');
-    else if (track-&gt;enc-&gt;codec_id == CODEC_ID_AC3)       tag = MKTAG('a','c','-','3');
-    else if (track-&gt;enc-&gt;codec_id == CODEC_ID_DIRAC)     tag = MKTAG('d','r','a','c');
-    else if (track-&gt;enc-&gt;codec_id == CODEC_ID_MOV_TEXT)  tag = MKTAG('t','x','3','g');
-    else if (track-&gt;enc-&gt;codec_type == AVMEDIA_TYPE_VIDEO) tag = MKTAG('m','p','4','v');
-    else if (track-&gt;enc-&gt;codec_type == AVMEDIA_TYPE_AUDIO) tag = MKTAG('m','p','4','a');
-
-    return tag;
-}
-
-static const AVCodecTag codec_ipod_tags[] = {
-    { CODEC_ID_H264,   MKTAG('a','v','c','1') },
-    { CODEC_ID_MPEG4,  MKTAG('m','p','4','v') },
-    { CODEC_ID_AAC,    MKTAG('m','p','4','a') },
-    { CODEC_ID_ALAC,   MKTAG('a','l','a','c') },
-    { CODEC_ID_AC3,    MKTAG('a','c','-','3') },
-    { CODEC_ID_MOV_TEXT, MKTAG('t','x','3','g') },
-    { CODEC_ID_MOV_TEXT, MKTAG('t','e','x','t') },
-    { CODEC_ID_NONE, 0 },
-};
-
-static int ipod_get_codec_tag(AVFormatContext *s, MOVTrack *track)
-{
-    int tag = track-&gt;enc-&gt;codec_tag;
-
-    // keep original tag for subs, ipod supports both formats
-    if (!(track-&gt;enc-&gt;codec_type == AVMEDIA_TYPE_SUBTITLE &amp;&amp;
-        (tag == MKTAG('t','x','3','g') ||
-         tag == MKTAG('t','e','x','t'))))
-        tag = ff_codec_get_tag(codec_ipod_tags, track-&gt;enc-&gt;codec_id);
-
-    if (!av_match_ext(s-&gt;filename, &quot;m4a&quot;) &amp;&amp; !av_match_ext(s-&gt;filename, &quot;m4v&quot;))
-        av_log(s, AV_LOG_WARNING, &quot;Warning, extension is not .m4a nor .m4v &quot;
-               &quot;Quicktime/Ipod might not play the file\n&quot;);
-
-    return tag;
-}
-
-static int mov_get_dv_codec_tag(AVFormatContext *s, MOVTrack *track)
-{
-    int tag;
-
-    if (track-&gt;enc-&gt;height == 480) /* NTSC */
-        if  (track-&gt;enc-&gt;pix_fmt == PIX_FMT_YUV422P) tag = MKTAG('d','v','5','n');
-        else                                         tag = MKTAG('d','v','c',' ');
-    else if (track-&gt;enc-&gt;pix_fmt == PIX_FMT_YUV422P) tag = MKTAG('d','v','5','p');
-    else if (track-&gt;enc-&gt;pix_fmt == PIX_FMT_YUV420P) tag = MKTAG('d','v','c','p');
-    else                                             tag = MKTAG('d','v','p','p');
-
-    return tag;
-}
-
-static const struct {
-    enum PixelFormat pix_fmt;
-    uint32_t tag;
-    unsigned bps;
-} mov_pix_fmt_tags[] = {
-    { PIX_FMT_YUYV422, MKTAG('y','u','v','s'),  0 },
-    { PIX_FMT_UYVY422, MKTAG('2','v','u','y'),  0 },
-    { PIX_FMT_RGB555BE,MKTAG('r','a','w',' '), 16 },
-    { PIX_FMT_RGB555LE,MKTAG('L','5','5','5'), 16 },
-    { PIX_FMT_RGB565LE,MKTAG('L','5','6','5'), 16 },
-    { PIX_FMT_RGB565BE,MKTAG('B','5','6','5'), 16 },
-    { PIX_FMT_GRAY16BE,MKTAG('b','1','6','g'), 16 },
-    { PIX_FMT_RGB24,   MKTAG('r','a','w',' '), 24 },
-    { PIX_FMT_BGR24,   MKTAG('2','4','B','G'), 24 },
-    { PIX_FMT_ARGB,    MKTAG('r','a','w',' '), 32 },
-    { PIX_FMT_BGRA,    MKTAG('B','G','R','A'), 32 },
-    { PIX_FMT_RGBA,    MKTAG('R','G','B','A'), 32 },
-    { PIX_FMT_ABGR,    MKTAG('A','B','G','R'), 32 },
-    { PIX_FMT_RGB48BE, MKTAG('b','4','8','r'), 48 },
-};
-
-static int mov_get_rawvideo_codec_tag(AVFormatContext *s, MOVTrack *track)
-{
-    int tag = track-&gt;enc-&gt;codec_tag;
-    int i;
-
-    for (i = 0; i &lt; FF_ARRAY_ELEMS(mov_pix_fmt_tags); i++) {
-        if (track-&gt;enc-&gt;pix_fmt == mov_pix_fmt_tags[i].pix_fmt) {
-            tag = mov_pix_fmt_tags[i].tag;
-            track-&gt;enc-&gt;bits_per_coded_sample = mov_pix_fmt_tags[i].bps;
-            break;
-        }
-    }
-
-    return tag;
-}
-
-static int mov_get_codec_tag(AVFormatContext *s, MOVTrack *track)
-{
-    int tag = track-&gt;enc-&gt;codec_tag;
-
-    if (!tag || (track-&gt;enc-&gt;strict_std_compliance &gt;= FF_COMPLIANCE_NORMAL &amp;&amp;
-                 (tag == MKTAG('d','v','c','p') ||
-                  track-&gt;enc-&gt;codec_id == CODEC_ID_RAWVIDEO ||
-                  av_get_bits_per_sample(track-&gt;enc-&gt;codec_id)))) { // pcm audio
-        if (track-&gt;enc-&gt;codec_id == CODEC_ID_DVVIDEO)
-            tag = mov_get_dv_codec_tag(s, track);
-        else if (track-&gt;enc-&gt;codec_id == CODEC_ID_RAWVIDEO)
-            tag = mov_get_rawvideo_codec_tag(s, track);
-        else if (track-&gt;enc-&gt;codec_type == AVMEDIA_TYPE_VIDEO) {
-            tag = ff_codec_get_tag(codec_movvideo_tags, track-&gt;enc-&gt;codec_id);
-            if (!tag) { // if no mac fcc found, try with Microsoft tags
-                tag = ff_codec_get_tag(ff_codec_bmp_tags, track-&gt;enc-&gt;codec_id);
-                if (tag)
-                    av_log(s, AV_LOG_INFO, &quot;Warning, using MS style video codec tag, &quot;
-                           &quot;the file may be unplayable!\n&quot;);
-            }
-        } else if (track-&gt;enc-&gt;codec_type == AVMEDIA_TYPE_AUDIO) {
-            tag = ff_codec_get_tag(codec_movaudio_tags, track-&gt;enc-&gt;codec_id);
-            if (!tag) { // if no mac fcc found, try with Microsoft tags
-                int ms_tag = ff_codec_get_tag(ff_codec_wav_tags, track-&gt;enc-&gt;codec_id);
-                if (ms_tag) {
-                    tag = MKTAG('m', 's', ((ms_tag &gt;&gt; 8) &amp; 0xff), (ms_tag &amp; 0xff));
-                    av_log(s, AV_LOG_INFO, &quot;Warning, using MS style audio codec tag, &quot;
-                           &quot;the file may be unplayable!\n&quot;);
-                }
-            }
-        } else if (track-&gt;enc-&gt;codec_type == AVMEDIA_TYPE_SUBTITLE)
-            tag = ff_codec_get_tag(ff_codec_movsubtitle_tags, track-&gt;enc-&gt;codec_id);
-    }
-
-    return tag;
-}
-
-static const AVCodecTag codec_3gp_tags[] = {
-    { CODEC_ID_H263,   MKTAG('s','2','6','3') },
-    { CODEC_ID_H264,   MKTAG('a','v','c','1') },
-    { CODEC_ID_MPEG4,  MKTAG('m','p','4','v') },
-    { CODEC_ID_AAC,    MKTAG('m','p','4','a') },
-    { CODEC_ID_AMR_NB, MKTAG('s','a','m','r') },
-    { CODEC_ID_AMR_WB, MKTAG('s','a','w','b') },
-    { CODEC_ID_MOV_TEXT, MKTAG('t','x','3','g') },
-    { CODEC_ID_NONE, 0 },
-};
-
-static int mov_find_codec_tag(AVFormatContext *s, MOVTrack *track)
-{
-    int tag = track-&gt;enc-&gt;codec_tag;
-
-    if (track-&gt;mode == MODE_MP4 || track-&gt;mode == MODE_PSP)
-        tag = mp4_get_codec_tag(s, track);
-    else if (track-&gt;mode == MODE_IPOD)
-        tag = ipod_get_codec_tag(s, track);
-    else if (track-&gt;mode &amp; MODE_3GP)
-        tag = ff_codec_get_tag(codec_3gp_tags, track-&gt;enc-&gt;codec_id);
-    else
-        tag = mov_get_codec_tag(s, track);
-
-    return tag;
-}
-
-/** Write uuid atom.
- * Needed to make file play in iPods running newest firmware
- * goes after avcC atom in moov.trak.mdia.minf.stbl.stsd.avc1
- */
-static int mov_write_uuid_tag_ipod(ByteIOContext *pb)
-{
-    put_be32(pb, 28);
-    put_tag(pb, &quot;uuid&quot;);
-    put_be32(pb, 0x6b6840f2);
-    put_be32(pb, 0x5f244fc5);
-    put_be32(pb, 0xba39a51b);
-    put_be32(pb, 0xcf0323f3);
-    put_be32(pb, 0x0);
-    return 28;
-}
-
-static int mov_write_subtitle_tag(ByteIOContext *pb, MOVTrack *track)
-{
-    int64_t pos = url_ftell(pb);
-    put_be32(pb, 0);    /* size */
-    put_le32(pb, track-&gt;tag); // store it byteswapped
-    put_be32(pb, 0);    /* Reserved */
-    put_be16(pb, 0);    /* Reserved */
-    put_be16(pb, 1);    /* Data-reference index */
-
-    if (track-&gt;enc-&gt;extradata_size)
-        put_buffer(pb, track-&gt;enc-&gt;extradata, track-&gt;enc-&gt;extradata_size);
-
-    return updateSize(pb, pos);
-}
-
-static int mov_write_pasp_tag(ByteIOContext *pb, MOVTrack *track)
-{
-    AVRational sar;
-    av_reduce(&amp;sar.num, &amp;sar.den, track-&gt;enc-&gt;sample_aspect_ratio.num,
-              track-&gt;enc-&gt;sample_aspect_ratio.den, INT_MAX);
-
-    put_be32(pb, 16);
-    put_tag(pb, &quot;pasp&quot;);
-    put_be32(pb, track-&gt;enc-&gt;sample_aspect_ratio.num);
-    put_be32(pb, track-&gt;enc-&gt;sample_aspect_ratio.den);
-    return 16;
-}
-
-static int mov_write_video_tag(ByteIOContext *pb, MOVTrack *track)
-{
-    int64_t pos = url_ftell(pb);
-    char compressor_name[32];
-
-    put_be32(pb, 0); /* size */
-    put_le32(pb, track-&gt;tag); // store it byteswapped
-    put_be32(pb, 0); /* Reserved */
-    put_be16(pb, 0); /* Reserved */
-    put_be16(pb, 1); /* Data-reference index */
-
-    put_be16(pb, 0); /* Codec stream version */
-    put_be16(pb, 0); /* Codec stream revision (=0) */
-    if (track-&gt;mode == MODE_MOV) {
-        put_tag(pb, &quot;FFMP&quot;); /* Vendor */
-        if(track-&gt;enc-&gt;codec_id == CODEC_ID_RAWVIDEO) {
-            put_be32(pb, 0); /* Temporal Quality */
-            put_be32(pb, 0x400); /* Spatial Quality = lossless*/
-        } else {
-            put_be32(pb, 0x200); /* Temporal Quality = normal */
-            put_be32(pb, 0x200); /* Spatial Quality = normal */
-        }
-    } else {
-        put_be32(pb, 0); /* Reserved */
-        put_be32(pb, 0); /* Reserved */
-        put_be32(pb, 0); /* Reserved */
-    }
-    put_be16(pb, track-&gt;enc-&gt;width); /* Video width */
-    put_be16(pb, track-&gt;height); /* Video height */
-    put_be32(pb, 0x00480000); /* Horizontal resolution 72dpi */
-    put_be32(pb, 0x00480000); /* Vertical resolution 72dpi */
-    put_be32(pb, 0); /* Data size (= 0) */
-    put_be16(pb, 1); /* Frame count (= 1) */
-
-    memset(compressor_name,0,32);
-    /* FIXME not sure, ISO 14496-1 draft where it shall be set to 0 */
-    if (track-&gt;mode == MODE_MOV &amp;&amp; track-&gt;enc-&gt;codec &amp;&amp; track-&gt;enc-&gt;codec-&gt;name)
-        strncpy(compressor_name,track-&gt;enc-&gt;codec-&gt;name,31);
-    put_byte(pb, strlen(compressor_name));
-    put_buffer(pb, compressor_name, 31);
-
-    if (track-&gt;mode == MODE_MOV &amp;&amp; track-&gt;enc-&gt;bits_per_coded_sample)
-        put_be16(pb, track-&gt;enc-&gt;bits_per_coded_sample);
-    else
-        put_be16(pb, 0x18); /* Reserved */
-    put_be16(pb, 0xffff); /* Reserved */
-    if(track-&gt;tag == MKTAG('m','p','4','v'))
-        mov_write_esds_tag(pb, track);
-    else if(track-&gt;enc-&gt;codec_id == CODEC_ID_H263)
-        mov_write_d263_tag(pb);
-    else if(track-&gt;enc-&gt;codec_id == CODEC_ID_SVQ3)
-        mov_write_svq3_tag(pb);
-    else if(track-&gt;enc-&gt;codec_id == CODEC_ID_DNXHD)
-        mov_write_avid_tag(pb, track);
-    else if(track-&gt;enc-&gt;codec_id == CODEC_ID_H264) {
-        mov_write_avcc_tag(pb, track);
-        if(track-&gt;mode == MODE_IPOD)
-            mov_write_uuid_tag_ipod(pb);
-    } else if(track-&gt;vosLen &gt; 0)
-        mov_write_glbl_tag(pb, track);
-
-    if (track-&gt;mode == MODE_MOV &amp;&amp;
-        track-&gt;enc-&gt;sample_aspect_ratio.den &amp;&amp; track-&gt;enc-&gt;sample_aspect_ratio.num &amp;&amp;
-        track-&gt;enc-&gt;sample_aspect_ratio.den != track-&gt;enc-&gt;sample_aspect_ratio.num) {
-        mov_write_pasp_tag(pb, track);
-    }
-
-    return updateSize(pb, pos);
-}
-
-static int mov_write_rtp_tag(ByteIOContext *pb, MOVTrack *track)
-{
-    int64_t pos = url_ftell(pb);
-    put_be32(pb, 0); /* size */
-    put_tag(pb, &quot;rtp &quot;);
-    put_be32(pb, 0); /* Reserved */
-    put_be16(pb, 0); /* Reserved */
-    put_be16(pb, 1); /* Data-reference index */
-
-    put_be16(pb, 1); /* Hint track version */
-    put_be16(pb, 1); /* Highest compatible version */
-    put_be32(pb, track-&gt;max_packet_size); /* Max packet size */
-
-    put_be32(pb, 12); /* size */
-    put_tag(pb, &quot;tims&quot;);
-    put_be32(pb, track-&gt;timescale);
-
-    return updateSize(pb, pos);
-}
-
-static int mov_write_stsd_tag(ByteIOContext *pb, MOVTrack *track)
-{
-    int64_t pos = url_ftell(pb);
-    put_be32(pb, 0); /* size */
-    put_tag(pb, &quot;stsd&quot;);
-    put_be32(pb, 0); /* version &amp; flags */
-    put_be32(pb, 1); /* entry count */
-    if (track-&gt;enc-&gt;codec_type == AVMEDIA_TYPE_VIDEO)
-        mov_write_video_tag(pb, track);
-    else if (track-&gt;enc-&gt;codec_type == AVMEDIA_TYPE_AUDIO)
-        mov_write_audio_tag(pb, track);
-    else if (track-&gt;enc-&gt;codec_type == AVMEDIA_TYPE_SUBTITLE)
-        mov_write_subtitle_tag(pb, track);
-    else if (track-&gt;enc-&gt;codec_tag == MKTAG('r','t','p',' '))
-        mov_write_rtp_tag(pb, track);
-    return updateSize(pb, pos);
-}
-
-static int mov_write_ctts_tag(ByteIOContext *pb, MOVTrack *track)
-{
-    MOVStts *ctts_entries;
-    uint32_t entries = 0;
-    uint32_t atom_size;
-    int i;
-
-    ctts_entries = av_malloc((track-&gt;entry + 1) * sizeof(*ctts_entries)); /* worst case */
-    ctts_entries[0].count = 1;
-    ctts_entries[0].duration = track-&gt;cluster[0].cts;
-    for (i=1; i&lt;track-&gt;entry; i++) {
-        if (track-&gt;cluster[i].cts == ctts_entries[entries].duration) {
-            ctts_entries[entries].count++; /* compress */
-        } else {
-            entries++;
-            ctts_entries[entries].duration = track-&gt;cluster[i].cts;
-            ctts_entries[entries].count = 1;
-        }
-    }
-    entries++; /* last one */
-    atom_size = 16 + (entries * 8);
-    put_be32(pb, atom_size); /* size */
-    put_tag(pb, &quot;ctts&quot;);
-    put_be32(pb, 0); /* version &amp; flags */
-    put_be32(pb, entries); /* entry count */
-    for (i=0; i&lt;entries; i++) {
-        put_be32(pb, ctts_entries[i].count);
-        put_be32(pb, ctts_entries[i].duration);
-    }
-    av_free(ctts_entries);
-    return atom_size;
-}
-
-/* Time to sample atom */
-static int mov_write_stts_tag(ByteIOContext *pb, MOVTrack *track)
-{
-    MOVStts *stts_entries;
-    uint32_t entries = -1;
-    uint32_t atom_size;
-    int i;
-
-    if (track-&gt;enc-&gt;codec_type == AVMEDIA_TYPE_AUDIO &amp;&amp; !track-&gt;audio_vbr) {
-        stts_entries = av_malloc(sizeof(*stts_entries)); /* one entry */
-        stts_entries[0].count = track-&gt;sampleCount;
-        stts_entries[0].duration = 1;
-        entries = 1;
-    } else {
-        stts_entries = av_malloc(track-&gt;entry * sizeof(*stts_entries)); /* worst case */
-        for (i=0; i&lt;track-&gt;entry; i++) {
-            int64_t duration = i + 1 == track-&gt;entry ?
-                track-&gt;trackDuration - track-&gt;cluster[i].dts + track-&gt;cluster[0].dts : /* readjusting */
-                track-&gt;cluster[i+1].dts - track-&gt;cluster[i].dts;
-            if (i &amp;&amp; duration == stts_entries[entries].duration) {
-                stts_entries[entries].count++; /* compress */
-            } else {
-                entries++;
-                stts_entries[entries].duration = duration;
-                stts_entries[entries].count = 1;
-            }
-        }
-        entries++; /* last one */
-    }
-    atom_size = 16 + (entries * 8);
-    put_be32(pb, atom_size); /* size */
-    put_tag(pb, &quot;stts&quot;);
-    put_be32(pb, 0); /* version &amp; flags */
-    put_be32(pb, entries); /* entry count */
-    for (i=0; i&lt;entries; i++) {
-        put_be32(pb, stts_entries[i].count);
-        put_be32(pb, stts_entries[i].duration);
-    }
-    av_free(stts_entries);
-    return atom_size;
-}
-
-static int mov_write_dref_tag(ByteIOContext *pb)
-{
-    put_be32(pb, 28); /* size */
-    put_tag(pb, &quot;dref&quot;);
-    put_be32(pb, 0); /* version &amp; flags */
-    put_be32(pb, 1); /* entry count */
-
-    put_be32(pb, 0xc); /* size */
-    put_tag(pb, &quot;url &quot;);
-    put_be32(pb, 1); /* version &amp; flags */
-
-    return 28;
-}
-
-static int mov_write_stbl_tag(ByteIOContext *pb, MOVTrack *track)
-{
-    int64_t pos = url_ftell(pb);
-    put_be32(pb, 0); /* size */
-    put_tag(pb, &quot;stbl&quot;);
-    mov_write_stsd_tag(pb, track);
-    mov_write_stts_tag(pb, track);
-    if ((track-&gt;enc-&gt;codec_type == AVMEDIA_TYPE_VIDEO ||
-         track-&gt;enc-&gt;codec_tag == MKTAG('r','t','p',' ')) &amp;&amp;
-        track-&gt;hasKeyframes &amp;&amp; track-&gt;hasKeyframes &lt; track-&gt;entry)
-        mov_write_stss_tag(pb, track, MOV_SYNC_SAMPLE);
-    if (track-&gt;mode == MODE_MOV &amp;&amp; track-&gt;flags &amp; MOV_TRACK_STPS)
-        mov_write_stss_tag(pb, track, MOV_PARTIAL_SYNC_SAMPLE);
-    if (track-&gt;enc-&gt;codec_type == AVMEDIA_TYPE_VIDEO &amp;&amp;
-        track-&gt;flags &amp; MOV_TRACK_CTTS)
-        mov_write_ctts_tag(pb, track);
-    mov_write_stsc_tag(pb, track);
-    mov_write_stsz_tag(pb, track);
-    mov_write_stco_tag(pb, track);
-    return updateSize(pb, pos);
-}
-
-static int mov_write_dinf_tag(ByteIOContext *pb)
-{
-    int64_t pos = url_ftell(pb);
-    put_be32(pb, 0); /* size */
-    put_tag(pb, &quot;dinf&quot;);
-    mov_write_dref_tag(pb);
-    return updateSize(pb, pos);
-}
-
-static int mov_write_nmhd_tag(ByteIOContext *pb)
-{
-    put_be32(pb, 12);
-    put_tag(pb, &quot;nmhd&quot;);
-    put_be32(pb, 0);
-    return 12;
-}
-
-static int mov_write_gmhd_tag(ByteIOContext *pb)
-{
-    put_be32(pb, 0x20);   /* size */
-    put_tag(pb, &quot;gmhd&quot;);
-    put_be32(pb, 0x18);   /* gmin size */
-    put_tag(pb, &quot;gmin&quot;);  /* generic media info */
-    put_be32(pb, 0);      /* version &amp; flags */
-    put_be16(pb, 0x40);   /* graphics mode = */
-    put_be16(pb, 0x8000); /* opColor (r?) */
-    put_be16(pb, 0x8000); /* opColor (g?) */
-    put_be16(pb, 0x8000); /* opColor (b?) */
-    put_be16(pb, 0);      /* balance */
-    put_be16(pb, 0);      /* reserved */
-    return 0x20;
-}
-
-static int mov_write_smhd_tag(ByteIOContext *pb)
-{
-    put_be32(pb, 16); /* size */
-    put_tag(pb, &quot;smhd&quot;);
-    put_be32(pb, 0); /* version &amp; flags */
-    put_be16(pb, 0); /* reserved (balance, normally = 0) */
-    put_be16(pb, 0); /* reserved */
-    return 16;
-}
-
-static int mov_write_vmhd_tag(ByteIOContext *pb)
-{
-    put_be32(pb, 0x14); /* size (always 0x14) */
-    put_tag(pb, &quot;vmhd&quot;);
-    put_be32(pb, 0x01); /* version &amp; flags */
-    put_be64(pb, 0); /* reserved (graphics mode = copy) */
-    return 0x14;
-}
-
-static int mov_write_hdlr_tag(ByteIOContext *pb, MOVTrack *track)
-{
-    const char *hdlr, *descr = NULL, *hdlr_type = NULL;
-    int64_t pos = url_ftell(pb);
-
-    if (!track) { /* no media --&gt; data handler */
-        hdlr = &quot;dhlr&quot;;
-        hdlr_type = &quot;url &quot;;
-        descr = &quot;DataHandler&quot;;
-    } else {
-        hdlr = (track-&gt;mode == MODE_MOV) ? &quot;mhlr&quot; : &quot;\0\0\0\0&quot;;
-        if (track-&gt;enc-&gt;codec_type == AVMEDIA_TYPE_VIDEO) {
-            hdlr_type = &quot;vide&quot;;
-            descr = &quot;VideoHandler&quot;;
-        } else if (track-&gt;enc-&gt;codec_type == AVMEDIA_TYPE_AUDIO) {
-            hdlr_type = &quot;soun&quot;;
-            descr = &quot;SoundHandler&quot;;
-        } else if (track-&gt;enc-&gt;codec_type == AVMEDIA_TYPE_SUBTITLE) {
-            if (track-&gt;tag == MKTAG('t','x','3','g')) hdlr_type = &quot;sbtl&quot;;
-            else                                      hdlr_type = &quot;text&quot;;
-            descr = &quot;SubtitleHandler&quot;;
-        } else if (track-&gt;enc-&gt;codec_tag == MKTAG('r','t','p',' ')) {
-            hdlr_type = &quot;hint&quot;;
-            descr = &quot;HintHandler&quot;;
-        }
-    }
-
-    put_be32(pb, 0); /* size */
-    put_tag(pb, &quot;hdlr&quot;);
-    put_be32(pb, 0); /* Version &amp; flags */
-    put_buffer(pb, hdlr, 4); /* handler */
-    put_tag(pb, hdlr_type); /* handler type */
-    put_be32(pb ,0); /* reserved */
-    put_be32(pb ,0); /* reserved */
-    put_be32(pb ,0); /* reserved */
-    if (!track || track-&gt;mode == MODE_MOV)
-        put_byte(pb, strlen(descr)); /* pascal string */
-    put_buffer(pb, descr, strlen(descr)); /* handler description */
-    if (track &amp;&amp; track-&gt;mode != MODE_MOV)
-        put_byte(pb, 0); /* c string */
-    return updateSize(pb, pos);
-}
-
-static int mov_write_hmhd_tag(ByteIOContext *pb)
-{
-    /* This atom must be present, but leaving the values at zero
-     * seems harmless. */
-    put_be32(pb, 28); /* size */
-    put_tag(pb, &quot;hmhd&quot;);
-    put_be32(pb, 0); /* version, flags */
-    put_be16(pb, 0); /* maxPDUsize */
-    put_be16(pb, 0); /* avgPDUsize */
-    put_be32(pb, 0); /* maxbitrate */
-    put_be32(pb, 0); /* avgbitrate */
-    put_be32(pb, 0); /* reserved */
-    return 28;
-}
-
-static int mov_write_minf_tag(ByteIOContext *pb, MOVTrack *track)
-{
-    int64_t pos = url_ftell(pb);
-    put_be32(pb, 0); /* size */
-    put_tag(pb, &quot;minf&quot;);
-    if(track-&gt;enc-&gt;codec_type == AVMEDIA_TYPE_VIDEO)
-        mov_write_vmhd_tag(pb);
-    else if (track-&gt;enc-&gt;codec_type == AVMEDIA_TYPE_AUDIO)
-        mov_write_smhd_tag(pb);
-    else if (track-&gt;enc-&gt;codec_type == AVMEDIA_TYPE_SUBTITLE) {
-        if (track-&gt;tag == MKTAG('t','e','x','t')) mov_write_gmhd_tag(pb);
-        else                                      mov_write_nmhd_tag(pb);
-    } else if (track-&gt;tag == MKTAG('r','t','p',' ')) {
-        mov_write_hmhd_tag(pb);
-    }
-    if (track-&gt;mode == MODE_MOV) /* FIXME: Why do it for MODE_MOV only ? */
-        mov_write_hdlr_tag(pb, NULL);
-    mov_write_dinf_tag(pb);
-    mov_write_stbl_tag(pb, track);
-    return updateSize(pb, pos);
-}
-
-static int mov_write_mdhd_tag(ByteIOContext *pb, MOVTrack *track)
-{
-    int version = track-&gt;trackDuration &lt; INT32_MAX ? 0 : 1;
-
-    (version == 1) ? put_be32(pb, 44) : put_be32(pb, 32); /* size */
-    put_tag(pb, &quot;mdhd&quot;);
-    put_byte(pb, version);
-    put_be24(pb, 0); /* flags */
-    if (version == 1) {
-        put_be64(pb, track-&gt;time);
-        put_be64(pb, track-&gt;time);
-    } else {
-        put_be32(pb, track-&gt;time); /* creation time */
-        put_be32(pb, track-&gt;time); /* modification time */
-    }
-    put_be32(pb, track-&gt;timescale); /* time scale (sample rate for audio) */
-    (version == 1) ? put_be64(pb, track-&gt;trackDuration) : put_be32(pb, track-&gt;trackDuration); /* duration */
-    put_be16(pb, track-&gt;language); /* language */
-    put_be16(pb, 0); /* reserved (quality) */
-
-    if(version!=0 &amp;&amp; track-&gt;mode == MODE_MOV){
-        av_log(NULL, AV_LOG_ERROR,
-            &quot;FATAL error, file duration too long for timebase, this file will not be\n&quot;
-            &quot;playable with quicktime. Choose a different timebase or a different\n&quot;
-            &quot;container format\n&quot;);
-    }
-
-    return 32;
-}
-
-static int mov_write_mdia_tag(ByteIOContext *pb, MOVTrack *track)
-{
-    int64_t pos = url_ftell(pb);
-    put_be32(pb, 0); /* size */
-    put_tag(pb, &quot;mdia&quot;);
-    mov_write_mdhd_tag(pb, track);
-    mov_write_hdlr_tag(pb, track);
-    mov_write_minf_tag(pb, track);
-    return updateSize(pb, pos);
-}
-
-static int mov_write_tkhd_tag(ByteIOContext *pb, MOVTrack *track, AVStream *st)
-{
-    int64_t duration = av_rescale_rnd(track-&gt;trackDuration, MOV_TIMESCALE,
-                                      track-&gt;timescale, AV_ROUND_UP);
-    int version = duration &lt; INT32_MAX ? 0 : 1;
-
-    (version == 1) ? put_be32(pb, 104) : put_be32(pb, 92); /* size */
-    put_tag(pb, &quot;tkhd&quot;);
-    put_byte(pb, version);
-    put_be24(pb, 0xf); /* flags (track enabled) */
-    if (version == 1) {
-        put_be64(pb, track-&gt;time);
-        put_be64(pb, track-&gt;time);
-    } else {
-        put_be32(pb, track-&gt;time); /* creation time */
-        put_be32(pb, track-&gt;time); /* modification time */
-    }
-    put_be32(pb, track-&gt;trackID); /* track-id */
-    put_be32(pb, 0); /* reserved */
-    (version == 1) ? put_be64(pb, duration) : put_be32(pb, duration);
-
-    put_be32(pb, 0); /* reserved */
-    put_be32(pb, 0); /* reserved */
-    put_be32(pb, 0x0); /* reserved (Layer &amp; Alternate group) */
-    /* Volume, only for audio */
-    if(track-&gt;enc-&gt;codec_type == AVMEDIA_TYPE_AUDIO)
-        put_be16(pb, 0x0100);
-    else
-        put_be16(pb, 0);
-    put_be16(pb, 0); /* reserved */
-
-    /* Matrix structure */
-    put_be32(pb, 0x00010000); /* reserved */
-    put_be32(pb, 0x0); /* reserved */
-    put_be32(pb, 0x0); /* reserved */
-    put_be32(pb, 0x0); /* reserved */
-    put_be32(pb, 0x00010000); /* reserved */
-    put_be32(pb, 0x0); /* reserved */
-    put_be32(pb, 0x0); /* reserved */
-    put_be32(pb, 0x0); /* reserved */
-    put_be32(pb, 0x40000000); /* reserved */
-
-    /* Track width and height, for visual only */
-    if(st &amp;&amp; (track-&gt;enc-&gt;codec_type == AVMEDIA_TYPE_VIDEO ||
-              track-&gt;enc-&gt;codec_type == AVMEDIA_TYPE_SUBTITLE)) {
-        double sample_aspect_ratio = av_q2d(st-&gt;sample_aspect_ratio);
-        if(!sample_aspect_ratio || track-&gt;height != track-&gt;enc-&gt;height)
-            sample_aspect_ratio = 1;
-        put_be32(pb, sample_aspect_ratio * track-&gt;enc-&gt;width*0x10000);
-        put_be32(pb, track-&gt;height*0x10000);
-    }
-    else {
-        put_be32(pb, 0);
-        put_be32(pb, 0);
-    }
-    return 0x5c;
-}
-
-// This box seems important for the psp playback ... without it the movie seems to hang
-static int mov_write_edts_tag(ByteIOContext *pb, MOVTrack *track)
-{
-    put_be32(pb, 0x24); /* size  */
-    put_tag(pb, &quot;edts&quot;);
-    put_be32(pb, 0x1c); /* size  */
-    put_tag(pb, &quot;elst&quot;);
-    put_be32(pb, 0x0);
-    put_be32(pb, 0x1);
-
-    /* duration   ... doesn't seem to effect psp */
-    put_be32(pb, av_rescale_rnd(track-&gt;trackDuration, MOV_TIMESCALE,
-                                track-&gt;timescale, AV_ROUND_UP));
-
-    put_be32(pb, track-&gt;cluster[0].cts); /* first pts is cts since dts is 0 */
-    put_be32(pb, 0x00010000);
-    return 0x24;
-}
-
-static int mov_write_tref_tag(ByteIOContext *pb, MOVTrack *track)
-{
-    put_be32(pb, 20);   // size
-    put_tag(pb, &quot;tref&quot;);
-    put_be32(pb, 12);   // size (subatom)
-    put_le32(pb, track-&gt;tref_tag);
-    put_be32(pb, track-&gt;tref_id);
-    return 20;
-}
-
-// goes at the end of each track!  ... Critical for PSP playback (&quot;Incompatible data&quot; without it)
-static int mov_write_uuid_tag_psp(ByteIOContext *pb, MOVTrack *mov)
-{
-    put_be32(pb, 0x34); /* size ... reports as 28 in mp4box! */
-    put_tag(pb, &quot;uuid&quot;);
-    put_tag(pb, &quot;USMT&quot;);
-    put_be32(pb, 0x21d24fce);
-    put_be32(pb, 0xbb88695c);
-    put_be32(pb, 0xfac9c740);
-    put_be32(pb, 0x1c);     // another size here!
-    put_tag(pb, &quot;MTDT&quot;);
-    put_be32(pb, 0x00010012);
-    put_be32(pb, 0x0a);
-    put_be32(pb, 0x55c40000);
-    put_be32(pb, 0x1);
-    put_be32(pb, 0x0);
-    return 0x34;
-}
-
-static int mov_write_udta_sdp(ByteIOContext *pb, AVCodecContext *ctx, int index)
-{
-    char buf[1000] = &quot;&quot;;
-    int len;
-
-    ff_sdp_write_media(buf, sizeof(buf), ctx, NULL, 0, 0);
-    av_strlcatf(buf, sizeof(buf), &quot;a=control:streamid=%d\r\n&quot;, index);
-    len = strlen(buf);
-
-    put_be32(pb, len + 24);
-    put_tag (pb, &quot;udta&quot;);
-    put_be32(pb, len + 16);
-    put_tag (pb, &quot;hnti&quot;);
-    put_be32(pb, len + 8);
-    put_tag (pb, &quot;sdp &quot;);
-    put_buffer(pb, buf, len);
-    return len + 24;
-}
-
-static int mov_write_trak_tag(ByteIOContext *pb, MOVTrack *track, AVStream *st)
-{
-    int64_t pos = url_ftell(pb);
-    put_be32(pb, 0); /* size */
-    put_tag(pb, &quot;trak&quot;);
-    mov_write_tkhd_tag(pb, track, st);
-    if (track-&gt;mode == MODE_PSP || track-&gt;flags &amp; MOV_TRACK_CTTS)
-        mov_write_edts_tag(pb, track);  // PSP Movies require edts box
-    if (track-&gt;tref_tag)
-        mov_write_tref_tag(pb, track);
-    mov_write_mdia_tag(pb, track);
-    if (track-&gt;mode == MODE_PSP)
-        mov_write_uuid_tag_psp(pb,track);  // PSP Movies require this uuid box
-    if (track-&gt;tag == MKTAG('r','t','p',' '))
-        mov_write_udta_sdp(pb, track-&gt;rtp_ctx-&gt;streams[0]-&gt;codec, track-&gt;trackID);
-    return updateSize(pb, pos);
-}
-
-#if 0
-/* TODO: Not sorted out, but not necessary either */
-static int mov_write_iods_tag(ByteIOContext *pb, MOVMuxContext *mov)
-{
-    put_be32(pb, 0x15); /* size */
-    put_tag(pb, &quot;iods&quot;);
-    put_be32(pb, 0);    /* version &amp; flags */
-    put_be16(pb, 0x1007);
-    put_byte(pb, 0);
-    put_be16(pb, 0x4fff);
-    put_be16(pb, 0xfffe);
-    put_be16(pb, 0x01ff);
-    return 0x15;
-}
-#endif
-
-static int mov_write_mvhd_tag(ByteIOContext *pb, MOVMuxContext *mov)
-{
-    int maxTrackID = 1, i;
-    int64_t maxTrackLenTemp, maxTrackLen = 0;
-    int version;
-
-    for (i=0; i&lt;mov-&gt;nb_streams; i++) {
-        if(mov-&gt;tracks[i].entry &gt; 0) {
-            maxTrackLenTemp = av_rescale_rnd(mov-&gt;tracks[i].trackDuration,
-                                             MOV_TIMESCALE,
-                                             mov-&gt;tracks[i].timescale,
-                                             AV_ROUND_UP);
-            if(maxTrackLen &lt; maxTrackLenTemp)
-                maxTrackLen = maxTrackLenTemp;
-            if(maxTrackID &lt; mov-&gt;tracks[i].trackID)
-                maxTrackID = mov-&gt;tracks[i].trackID;
-        }
-    }
-
-    version = maxTrackLen &lt; UINT32_MAX ? 0 : 1;
-    (version == 1) ? put_be32(pb, 120) : put_be32(pb, 108); /* size */
-    put_tag(pb, &quot;mvhd&quot;);
-    put_byte(pb, version);
-    put_be24(pb, 0); /* flags */
-    if (version == 1) {
-        put_be64(pb, mov-&gt;time);
-        put_be64(pb, mov-&gt;time);
-    } else {
-        put_be32(pb, mov-&gt;time); /* creation time */
-        put_be32(pb, mov-&gt;time); /* modification time */
-    }
-    put_be32(pb, MOV_TIMESCALE);
-    (version == 1) ? put_be64(pb, maxTrackLen) : put_be32(pb, maxTrackLen); /* duration of longest track */
-
-    put_be32(pb, 0x00010000); /* reserved (preferred rate) 1.0 = normal */
-    put_be16(pb, 0x0100); /* reserved (preferred volume) 1.0 = normal */
-    put_be16(pb, 0); /* reserved */
-    put_be32(pb, 0); /* reserved */
-    put_be32(pb, 0); /* reserved */
-
-    /* Matrix structure */
-    put_be32(pb, 0x00010000); /* reserved */
-    put_be32(pb, 0x0); /* reserved */
-    put_be32(pb, 0x0); /* reserved */
-    put_be32(pb, 0x0); /* reserved */
-    put_be32(pb, 0x00010000); /* reserved */
-    put_be32(pb, 0x0); /* reserved */
-    put_be32(pb, 0x0); /* reserved */
-    put_be32(pb, 0x0); /* reserved */
-    put_be32(pb, 0x40000000); /* reserved */
-
-    put_be32(pb, 0); /* reserved (preview time) */
-    put_be32(pb, 0); /* reserved (preview duration) */
-    put_be32(pb, 0); /* reserved (poster time) */
-    put_be32(pb, 0); /* reserved (selection time) */
-    put_be32(pb, 0); /* reserved (selection duration) */
-    put_be32(pb, 0); /* reserved (current time) */
-    put_be32(pb, maxTrackID+1); /* Next track id */
-    return 0x6c;
-}
-
-static int mov_write_itunes_hdlr_tag(ByteIOContext *pb, MOVMuxContext *mov,
-                                     AVFormatContext *s)
-{
-    put_be32(pb, 33); /* size */
-    put_tag(pb, &quot;hdlr&quot;);
-    put_be32(pb, 0);
-    put_be32(pb, 0);
-    put_tag(pb, &quot;mdir&quot;);
-    put_tag(pb, &quot;appl&quot;);
-    put_be32(pb, 0);
-    put_be32(pb, 0);
-    put_byte(pb, 0);
-    return 33;
-}
-
-/* helper function to write a data tag with the specified string as data */
-static int mov_write_string_data_tag(ByteIOContext *pb, const char *data, int lang, int long_style)
-{
-    if(long_style){
-        int size = 16 + strlen(data);
-        put_be32(pb, size); /* size */
-        put_tag(pb, &quot;data&quot;);
-        put_be32(pb, 1);
-        put_be32(pb, 0);
-        put_buffer(pb, data, strlen(data));
-        return size;
-    }else{
-        if (!lang)
-            lang = ff_mov_iso639_to_lang(&quot;und&quot;, 1);
-        put_be16(pb, strlen(data)); /* string length */
-        put_be16(pb, lang);
-        put_buffer(pb, data, strlen(data));
-        return strlen(data) + 4;
-    }
-}
-
-static int mov_write_string_tag(ByteIOContext *pb, const char *name, const char *value, int lang, int long_style){
-    int size = 0;
-    if (value &amp;&amp; value[0]) {
-        int64_t pos = url_ftell(pb);
-        put_be32(pb, 0); /* size */
-        put_tag(pb, name);
-        mov_write_string_data_tag(pb, value, lang, long_style);
-        size= updateSize(pb, pos);
-    }
-    return size;
-}
-
-static int mov_write_string_metadata(AVFormatContext *s, ByteIOContext *pb,
-                                     const char *name, const char *tag,
-                                     int long_style)
-{
-    int l, lang = 0, len, len2;
-    AVMetadataTag *t, *t2 = NULL;
-    char tag2[16];
-
-    if (!(t = av_metadata_get(s-&gt;metadata, tag, NULL, 0)))
-        return 0;
-
-    len = strlen(t-&gt;key);
-    snprintf(tag2, sizeof(tag2), &quot;%s-&quot;, tag);
-    while ((t2 = av_metadata_get(s-&gt;metadata, tag2, t2, AV_METADATA_IGNORE_SUFFIX))) {
-        len2 = strlen(t2-&gt;key);
-        if (len2 == len+4 &amp;&amp; !strcmp(t-&gt;value, t2-&gt;value)
-            &amp;&amp; (l=ff_mov_iso639_to_lang(&amp;t2-&gt;key[len2-3], 1)) &gt;= 0) {
-            lang = l;
-            break;
-        }
-    }
-    return mov_write_string_tag(pb, name, t-&gt;value, lang, long_style);
-}
-
-/* iTunes track number */
-static int mov_write_trkn_tag(ByteIOContext *pb, MOVMuxContext *mov,
-                              AVFormatContext *s)
-{
-    AVMetadataTag *t = av_metadata_get(s-&gt;metadata, &quot;track&quot;, NULL, 0);
-    int size = 0, track = t ? atoi(t-&gt;value) : 0;
-    if (track) {
-        put_be32(pb, 32); /* size */
-        put_tag(pb, &quot;trkn&quot;);
-            put_be32(pb, 24); /* size */
-            put_tag(pb, &quot;data&quot;);
-            put_be32(pb, 0);        // 8 bytes empty
-            put_be32(pb, 0);
-            put_be16(pb, 0);        // empty
-            put_be16(pb, track);    // track number
-            put_be16(pb, 0);        // total track number
-            put_be16(pb, 0);        // empty
-        size = 32;
-    }
-    return size;
-}
-
-/* iTunes meta data list */
-static int mov_write_ilst_tag(ByteIOContext *pb, MOVMuxContext *mov,
-                              AVFormatContext *s)
-{
-    int64_t pos = url_ftell(pb);
-    put_be32(pb, 0); /* size */
-    put_tag(pb, &quot;ilst&quot;);
-    mov_write_string_metadata(s, pb, &quot;\251nam&quot;, &quot;title&quot;    , 1);
-    mov_write_string_metadata(s, pb, &quot;\251ART&quot;, &quot;artist&quot;   , 1);
-    mov_write_string_metadata(s, pb, &quot;aART&quot;, &quot;album_artist&quot;, 1);
-    mov_write_string_metadata(s, pb, &quot;\251wrt&quot;, &quot;composer&quot; , 1);
-    mov_write_string_metadata(s, pb, &quot;\251alb&quot;, &quot;album&quot;    , 1);
-    mov_write_string_metadata(s, pb, &quot;\251day&quot;, &quot;date&quot;     , 1);
-    mov_write_string_tag(pb, &quot;\251too&quot;, LIBAVFORMAT_IDENT, 0, 1);
-    mov_write_string_metadata(s, pb, &quot;\251cmt&quot;, &quot;comment&quot;  , 1);
-    mov_write_string_metadata(s, pb, &quot;\251gen&quot;, &quot;genre&quot;    , 1);
-    mov_write_string_metadata(s, pb, &quot;\251cpy&quot;, &quot;copyright&quot;, 1);
-    mov_write_string_metadata(s, pb, &quot;\251grp&quot;, &quot;grouping&quot; , 1);
-    mov_write_string_metadata(s, pb, &quot;\251lyr&quot;, &quot;lyrics&quot;   , 1);
-    mov_write_string_metadata(s, pb, &quot;desc&quot;,    &quot;description&quot;,1);
-    mov_write_string_metadata(s, pb, &quot;ldes&quot;,    &quot;synopsis&quot; , 1);
-    mov_write_string_metadata(s, pb, &quot;tvsh&quot;,    &quot;show&quot;     , 1);
-    mov_write_string_metadata(s, pb, &quot;tven&quot;,    &quot;episode_id&quot;,1);
-    mov_write_string_metadata(s, pb, &quot;tvnn&quot;,    &quot;network&quot;  , 1);
-    mov_write_trkn_tag(pb, mov, s);
-    return updateSize(pb, pos);
-}
-
-/* iTunes meta data tag */
-static int mov_write_meta_tag(ByteIOContext *pb, MOVMuxContext *mov,
-                              AVFormatContext *s)
-{
-    int size = 0;
-    int64_t pos = url_ftell(pb);
-    put_be32(pb, 0); /* size */
-    put_tag(pb, &quot;meta&quot;);
-    put_be32(pb, 0);
-    mov_write_itunes_hdlr_tag(pb, mov, s);
-    mov_write_ilst_tag(pb, mov, s);
-    size = updateSize(pb, pos);
-    return size;
-}
-
-static int utf8len(const uint8_t *b)
-{
-    int len=0;
-    int val;
-    while(*b){
-        GET_UTF8(val, *b++, return -1;)
-        len++;
-    }
-    return len;
-}
-
-static int ascii_to_wc(ByteIOContext *pb, const uint8_t *b)
-{
-    int val;
-    while(*b){
-        GET_UTF8(val, *b++, return -1;)
-        put_be16(pb, val);
-    }
-    put_be16(pb, 0x00);
-    return 0;
-}
-
-static uint16_t language_code(const char *str)
-{
-    return (((str[0]-0x60) &amp; 0x1F) &lt;&lt; 10) + (((str[1]-0x60) &amp; 0x1F) &lt;&lt; 5) + ((str[2]-0x60) &amp; 0x1F);
-}
-
-static int mov_write_3gp_udta_tag(ByteIOContext *pb, AVFormatContext *s,
-                                  const char *tag, const char *str)
-{
-    int64_t pos = url_ftell(pb);
-    AVMetadataTag *t = av_metadata_get(s-&gt;metadata, str, NULL, 0);
-    if (!t || !utf8len(t-&gt;value))
-        return 0;
-    put_be32(pb, 0);   /* size */
-    put_tag (pb, tag); /* type */
-    put_be32(pb, 0);   /* version + flags */
-    if (!strcmp(tag, &quot;yrrc&quot;))
-        put_be16(pb, atoi(t-&gt;value));
-    else {
-        put_be16(pb, language_code(&quot;eng&quot;)); /* language */
-        put_buffer(pb, t-&gt;value, strlen(t-&gt;value)+1); /* UTF8 string value */
-        if (!strcmp(tag, &quot;albm&quot;) &amp;&amp;
-            (t = av_metadata_get(s-&gt;metadata, &quot;track&quot;, NULL, 0)))
-            put_byte(pb, atoi(t-&gt;value));
-    }
-    return updateSize(pb, pos);
-}
-
-static int mov_write_chpl_tag(ByteIOContext *pb, AVFormatContext *s)
-{
-    int64_t pos = url_ftell(pb);
-    int i, nb_chapters = FFMIN(s-&gt;nb_chapters, 255);
-
-    put_be32(pb, 0);            // size
-    put_tag (pb, &quot;chpl&quot;);
-    put_be32(pb, 0x01000000);   // version + flags
-    put_be32(pb, 0);            // unknown
-    put_byte(pb, nb_chapters);
-
-    for (i = 0; i &lt; nb_chapters; i++) {
-        AVChapter *c = s-&gt;chapters[i];
-        AVMetadataTag *t;
-        put_be64(pb, av_rescale_q(c-&gt;start, c-&gt;time_base, (AVRational){1,10000000}));
-
-        if ((t = av_metadata_get(c-&gt;metadata, &quot;title&quot;, NULL, 0))) {
-            int len = FFMIN(strlen(t-&gt;value), 255);
-            put_byte(pb, len);
-            put_buffer(pb, t-&gt;value, len);
-        } else
-            put_byte(pb, 0);
-    }
-    return updateSize(pb, pos);
-}
-
-static int mov_write_udta_tag(ByteIOContext *pb, MOVMuxContext *mov,
-                              AVFormatContext *s)
-{
-    ByteIOContext *pb_buf;
-    int i, ret, size;
-    uint8_t *buf;
-
-    for (i = 0; i &lt; s-&gt;nb_streams; i++)
-        if (mov-&gt;tracks[i].enc-&gt;flags &amp; CODEC_FLAG_BITEXACT) {
-            return 0;
-        }
-
-    ret = url_open_dyn_buf(&amp;pb_buf);
-    if(ret &lt; 0)
-        return ret;
-
-        if (mov-&gt;mode &amp; MODE_3GP) {
-            mov_write_3gp_udta_tag(pb_buf, s, &quot;perf&quot;, &quot;artist&quot;);
-            mov_write_3gp_udta_tag(pb_buf, s, &quot;titl&quot;, &quot;title&quot;);
-            mov_write_3gp_udta_tag(pb_buf, s, &quot;auth&quot;, &quot;author&quot;);
-            mov_write_3gp_udta_tag(pb_buf, s, &quot;gnre&quot;, &quot;genre&quot;);
-            mov_write_3gp_udta_tag(pb_buf, s, &quot;dscp&quot;, &quot;comment&quot;);
-            mov_write_3gp_udta_tag(pb_buf, s, &quot;albm&quot;, &quot;album&quot;);
-            mov_write_3gp_udta_tag(pb_buf, s, &quot;cprt&quot;, &quot;copyright&quot;);
-            mov_write_3gp_udta_tag(pb_buf, s, &quot;yrrc&quot;, &quot;date&quot;);
-        } else if (mov-&gt;mode == MODE_MOV) { // the title field breaks gtkpod with mp4 and my suspicion is that stuff is not valid in mp4
-            mov_write_string_metadata(s, pb_buf, &quot;\251nam&quot;, &quot;title&quot;      , 0);
-            mov_write_string_metadata(s, pb_buf, &quot;\251aut&quot;, &quot;author&quot;     , 0);
-            mov_write_string_metadata(s, pb_buf, &quot;\251alb&quot;, &quot;album&quot;      , 0);
-            mov_write_string_metadata(s, pb_buf, &quot;\251day&quot;, &quot;date&quot;       , 0);
-            mov_write_string_tag(pb_buf, &quot;\251enc&quot;, LIBAVFORMAT_IDENT, 0, 0);
-            mov_write_string_metadata(s, pb_buf, &quot;\251des&quot;, &quot;comment&quot;    , 0);
-            mov_write_string_metadata(s, pb_buf, &quot;\251gen&quot;, &quot;genre&quot;      , 0);
-            mov_write_string_metadata(s, pb_buf, &quot;\251cpy&quot;, &quot;copyright&quot;  , 0);
-        } else {
-            /* iTunes meta data */
-            mov_write_meta_tag(pb_buf, mov, s);
-        }
-
-        if (s-&gt;nb_chapters)
-            mov_write_chpl_tag(pb_buf, s);
-
-    if ((size = url_close_dyn_buf(pb_buf, &amp;buf)) &gt; 0) {
-        put_be32(pb, size+8);
-        put_tag(pb, &quot;udta&quot;);
-        put_buffer(pb, buf, size);
-    }
-    av_free(buf);
-
-    return 0;
-}
-
-static void mov_write_psp_udta_tag(ByteIOContext *pb,
-                                  const char *str, const char *lang, int type)
-{
-    int len = utf8len(str)+1;
-    if(len&lt;=0)
-        return;
-    put_be16(pb, len*2+10);            /* size */
-    put_be32(pb, type);                /* type */
-    put_be16(pb, language_code(lang)); /* language */
-    put_be16(pb, 0x01);                /* ? */
-    ascii_to_wc(pb, str);
-}
-
-static int mov_write_uuidusmt_tag(ByteIOContext *pb, AVFormatContext *s)
-{
-    AVMetadataTag *title = av_metadata_get(s-&gt;metadata, &quot;title&quot;, NULL, 0);
-    int64_t pos, pos2;
-
-    if (title) {
-        pos = url_ftell(pb);
-        put_be32(pb, 0); /* size placeholder*/
-        put_tag(pb, &quot;uuid&quot;);
-        put_tag(pb, &quot;USMT&quot;);
-        put_be32(pb, 0x21d24fce); /* 96 bit UUID */
-        put_be32(pb, 0xbb88695c);
-        put_be32(pb, 0xfac9c740);
-
-        pos2 = url_ftell(pb);
-        put_be32(pb, 0); /* size placeholder*/
-        put_tag(pb, &quot;MTDT&quot;);
-        put_be16(pb, 4);
-
-        // ?
-        put_be16(pb, 0x0C);                 /* size */
-        put_be32(pb, 0x0B);                 /* type */
-        put_be16(pb, language_code(&quot;und&quot;)); /* language */
-        put_be16(pb, 0x0);                  /* ? */
-        put_be16(pb, 0x021C);               /* data */
-
-        mov_write_psp_udta_tag(pb, LIBAVCODEC_IDENT,      &quot;eng&quot;, 0x04);
-        mov_write_psp_udta_tag(pb, title-&gt;value,          &quot;eng&quot;, 0x01);
-//        snprintf(dt,32,&quot;%04d/%02d/%02d %02d:%02d:%02d&quot;,t_st-&gt;tm_year+1900,t_st-&gt;tm_mon+1,t_st-&gt;tm_mday,t_st-&gt;tm_hour,t_st-&gt;tm_min,t_st-&gt;tm_sec);
-        mov_write_psp_udta_tag(pb, &quot;2006/04/01 11:11:11&quot;, &quot;und&quot;, 0x03);
-
-        updateSize(pb, pos2);
-        return updateSize(pb, pos);
-    }
-
-    return 0;
-}
-
-static int mov_write_moov_tag(ByteIOContext *pb, MOVMuxContext *mov,
-                              AVFormatContext *s)
-{
-    int i;
-    int64_t pos = url_ftell(pb);
-    put_be32(pb, 0); /* size placeholder*/
-    put_tag(pb, &quot;moov&quot;);
-
-    for (i=0; i&lt;mov-&gt;nb_streams; i++) {
-        if(mov-&gt;tracks[i].entry &lt;= 0) continue;
-
-        mov-&gt;tracks[i].time = mov-&gt;time;
-        mov-&gt;tracks[i].trackID = i+1;
-    }
-
-    if (mov-&gt;chapter_track)
-        for (i=0; i&lt;s-&gt;nb_streams; i++) {
-            mov-&gt;tracks[i].tref_tag = MKTAG('c','h','a','p');
-            mov-&gt;tracks[i].tref_id = mov-&gt;tracks[mov-&gt;chapter_track].trackID;
-        }
-    for (i = 0; i &lt; mov-&gt;nb_streams; i++) {
-        if (mov-&gt;tracks[i].tag == MKTAG('r','t','p',' ')) {
-            mov-&gt;tracks[i].tref_tag = MKTAG('h','i','n','t');
-            mov-&gt;tracks[i].tref_id =
-                mov-&gt;tracks[mov-&gt;tracks[i].src_track].trackID;
-        }
-    }
-
-    mov_write_mvhd_tag(pb, mov);
-    //mov_write_iods_tag(pb, mov);
-    for (i=0; i&lt;mov-&gt;nb_streams; i++) {
-        if(mov-&gt;tracks[i].entry &gt; 0) {
-            mov_write_trak_tag(pb, &amp;(mov-&gt;tracks[i]), i &lt; s-&gt;nb_streams ? s-&gt;streams[i] : NULL);
-        }
-    }
-
-    if (mov-&gt;mode == MODE_PSP)
-        mov_write_uuidusmt_tag(pb, s);
-    else
-        mov_write_udta_tag(pb, mov, s);
-
-    return updateSize(pb, pos);
-}
-
-static int mov_write_mdat_tag(ByteIOContext *pb, MOVMuxContext *mov)
-{
-    put_be32(pb, 8);    // placeholder for extended size field (64 bit)
-    put_tag(pb, mov-&gt;mode == MODE_MOV ? &quot;wide&quot; : &quot;free&quot;);
-
-    mov-&gt;mdat_pos = url_ftell(pb);
-    put_be32(pb, 0); /* size placeholder*/
-    put_tag(pb, &quot;mdat&quot;);
-    return 0;
-}
-
-/* TODO: This needs to be more general */
-static int mov_write_ftyp_tag(ByteIOContext *pb, AVFormatContext *s)
-{
-    MOVMuxContext *mov = s-&gt;priv_data;
-    int64_t pos = url_ftell(pb);
-    int has_h264 = 0, has_video = 0;
-    int minor = 0x200;
-    int i;
-
-    for (i = 0; i &lt; s-&gt;nb_streams; i++) {
-        AVStream *st = s-&gt;streams[i];
-        if (st-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_VIDEO)
-            has_video = 1;
-        if (st-&gt;codec-&gt;codec_id == CODEC_ID_H264)
-            has_h264 = 1;
-    }
-
-    put_be32(pb, 0); /* size */
-    put_tag(pb, &quot;ftyp&quot;);
-
-    if (mov-&gt;mode == MODE_3GP) {
-        put_tag(pb, has_h264 ? &quot;3gp6&quot;  : &quot;3gp4&quot;);
-        minor =     has_h264 ?   0x100 :   0x200;
-    } else if (mov-&gt;mode &amp; MODE_3G2) {
-        put_tag(pb, has_h264 ? &quot;3g2b&quot;  : &quot;3g2a&quot;);
-        minor =     has_h264 ? 0x20000 : 0x10000;
-    }else if (mov-&gt;mode == MODE_PSP)
-        put_tag(pb, &quot;MSNV&quot;);
-    else if (mov-&gt;mode == MODE_MP4)
-        put_tag(pb, &quot;isom&quot;);
-    else if (mov-&gt;mode == MODE_IPOD)
-        put_tag(pb, has_video ? &quot;M4V &quot;:&quot;M4A &quot;);
-    else
-        put_tag(pb, &quot;qt  &quot;);
-
-    put_be32(pb, minor);
-
-    if(mov-&gt;mode == MODE_MOV)
-        put_tag(pb, &quot;qt  &quot;);
-    else{
-        put_tag(pb, &quot;isom&quot;);
-        put_tag(pb, &quot;iso2&quot;);
-        if(has_h264)
-            put_tag(pb, &quot;avc1&quot;);
-    }
-
-    if (mov-&gt;mode == MODE_3GP)
-        put_tag(pb, has_h264 ? &quot;3gp6&quot;:&quot;3gp4&quot;);
-    else if (mov-&gt;mode &amp; MODE_3G2)
-        put_tag(pb, has_h264 ? &quot;3g2b&quot;:&quot;3g2a&quot;);
-    else if (mov-&gt;mode == MODE_PSP)
-        put_tag(pb, &quot;MSNV&quot;);
-    else if (mov-&gt;mode == MODE_MP4)
-        put_tag(pb, &quot;mp41&quot;);
-    return updateSize(pb, pos);
-}
-
-static void mov_write_uuidprof_tag(ByteIOContext *pb, AVFormatContext *s)
-{
-    AVCodecContext *VideoCodec = s-&gt;streams[0]-&gt;codec;
-    AVCodecContext *AudioCodec = s-&gt;streams[1]-&gt;codec;
-    int AudioRate = AudioCodec-&gt;sample_rate;
-    int FrameRate = ((VideoCodec-&gt;time_base.den) * (0x10000))/ (VideoCodec-&gt;time_base.num);
-    int audio_kbitrate= AudioCodec-&gt;bit_rate / 1000;
-    int video_kbitrate= FFMIN(VideoCodec-&gt;bit_rate / 1000, 800 - audio_kbitrate);
-
-    put_be32(pb, 0x94); /* size */
-    put_tag(pb, &quot;uuid&quot;);
-    put_tag(pb, &quot;PROF&quot;);
-
-    put_be32(pb, 0x21d24fce); /* 96 bit UUID */
-    put_be32(pb, 0xbb88695c);
-    put_be32(pb, 0xfac9c740);
-
-    put_be32(pb, 0x0);  /* ? */
-    put_be32(pb, 0x3);  /* 3 sections ? */
-
-    put_be32(pb, 0x14); /* size */
-    put_tag(pb, &quot;FPRF&quot;);
-    put_be32(pb, 0x0);  /* ? */
-    put_be32(pb, 0x0);  /* ? */
-    put_be32(pb, 0x0);  /* ? */
-
-    put_be32(pb, 0x2c);  /* size */
-    put_tag(pb, &quot;APRF&quot;);   /* audio */
-    put_be32(pb, 0x0);
-    put_be32(pb, 0x2);   /* TrackID */
-    put_tag(pb, &quot;mp4a&quot;);
-    put_be32(pb, 0x20f);
-    put_be32(pb, 0x0);
-    put_be32(pb, audio_kbitrate);
-    put_be32(pb, audio_kbitrate);
-    put_be32(pb, AudioRate);
-    put_be32(pb, AudioCodec-&gt;channels);
-
-    put_be32(pb, 0x34);  /* size */
-    put_tag(pb, &quot;VPRF&quot;);   /* video */
-    put_be32(pb, 0x0);
-    put_be32(pb, 0x1);    /* TrackID */
-    if (VideoCodec-&gt;codec_id == CODEC_ID_H264) {
-        put_tag(pb, &quot;avc1&quot;);
-        put_be16(pb, 0x014D);
-        put_be16(pb, 0x0015);
-    } else {
-        put_tag(pb, &quot;mp4v&quot;);
-        put_be16(pb, 0x0000);
-        put_be16(pb, 0x0103);
-    }
-    put_be32(pb, 0x0);
-    put_be32(pb, video_kbitrate);
-    put_be32(pb, video_kbitrate);
-    put_be32(pb, FrameRate);
-    put_be32(pb, FrameRate);
-    put_be16(pb, VideoCodec-&gt;width);
-    put_be16(pb, VideoCodec-&gt;height);
-    put_be32(pb, 0x010001); /* ? */
-}
-
-static int mov_parse_mpeg2_frame(AVPacket *pkt, uint32_t *flags)
-{
-    uint32_t c = -1;
-    int i, closed_gop = 0;
-
-    for (i = 0; i &lt; pkt-&gt;size - 4; i++) {
-        c = (c&lt;&lt;8) + pkt-&gt;data[i];
-        if (c == 0x1b8) { // gop
-            closed_gop = pkt-&gt;data[i+4]&gt;&gt;6 &amp; 0x01;
-        } else if (c == 0x100) { // pic
-            int temp_ref = (pkt-&gt;data[i+1]&lt;&lt;2) | (pkt-&gt;data[i+2]&gt;&gt;6);
-            if (!temp_ref || closed_gop) // I picture is not reordered
-                *flags = MOV_SYNC_SAMPLE;
-            else
-                *flags = MOV_PARTIAL_SYNC_SAMPLE;
-            break;
-        }
-    }
-    return 0;
-}
-
-int ff_mov_write_packet(AVFormatContext *s, AVPacket *pkt)
-{
-    MOVMuxContext *mov = s-&gt;priv_data;
-    ByteIOContext *pb = s-&gt;pb;
-    MOVTrack *trk = &amp;mov-&gt;tracks[pkt-&gt;stream_index];
-    AVCodecContext *enc = trk-&gt;enc;
-    unsigned int samplesInChunk = 0;
-    int size= pkt-&gt;size;
-
-    if (url_is_streamed(s-&gt;pb)) return 0; /* Can't handle that */
-    if (!size) return 0; /* Discard 0 sized packets */
-
-    if (enc-&gt;codec_id == CODEC_ID_AMR_NB) {
-        /* We must find out how many AMR blocks there are in one packet */
-        static uint16_t packed_size[16] =
-            {13, 14, 16, 18, 20, 21, 27, 32, 6, 0, 0, 0, 0, 0, 0, 0};
-        int len = 0;
-
-        while (len &lt; size &amp;&amp; samplesInChunk &lt; 100) {
-            len += packed_size[(pkt-&gt;data[len] &gt;&gt; 3) &amp; 0x0F];
-            samplesInChunk++;
-        }
-        if(samplesInChunk &gt; 1){
-            av_log(s, AV_LOG_ERROR, &quot;fatal error, input is not a single packet, implement a AVParser for it\n&quot;);
-            return -1;
-        }
-    } else if (trk-&gt;sampleSize)
-        samplesInChunk = size/trk-&gt;sampleSize;
-    else
-        samplesInChunk = 1;
-
-    /* copy extradata if it exists */
-    if (trk-&gt;vosLen == 0 &amp;&amp; enc-&gt;extradata_size &gt; 0) {
-        trk-&gt;vosLen = enc-&gt;extradata_size;
-        trk-&gt;vosData = av_malloc(trk-&gt;vosLen);
-        memcpy(trk-&gt;vosData, enc-&gt;extradata, trk-&gt;vosLen);
-    }
-
-    if (enc-&gt;codec_id == CODEC_ID_H264 &amp;&amp; trk-&gt;vosLen &gt; 0 &amp;&amp; *(uint8_t *)trk-&gt;vosData != 1) {
-        /* from x264 or from bytestream h264 */
-        /* nal reformating needed */
-        size = ff_avc_parse_nal_units(pb, pkt-&gt;data, pkt-&gt;size);
-    } else {
-        put_buffer(pb, pkt-&gt;data, size);
-    }
-
-    if ((enc-&gt;codec_id == CODEC_ID_DNXHD ||
-         enc-&gt;codec_id == CODEC_ID_AC3) &amp;&amp; !trk-&gt;vosLen) {
-        /* copy frame to create needed atoms */
-        trk-&gt;vosLen = size;
-        trk-&gt;vosData = av_malloc(size);
-        if (!trk-&gt;vosData)
-            return AVERROR(ENOMEM);
-        memcpy(trk-&gt;vosData, pkt-&gt;data, size);
-    }
-
-    if (!(trk-&gt;entry % MOV_INDEX_CLUSTER_SIZE)) {
-        trk-&gt;cluster = av_realloc(trk-&gt;cluster, (trk-&gt;entry + MOV_INDEX_CLUSTER_SIZE) * sizeof(*trk-&gt;cluster));
-        if (!trk-&gt;cluster)
-            return -1;
-    }
-
-    trk-&gt;cluster[trk-&gt;entry].pos = url_ftell(pb) - size;
-    trk-&gt;cluster[trk-&gt;entry].samplesInChunk = samplesInChunk;
-    trk-&gt;cluster[trk-&gt;entry].size = size;
-    trk-&gt;cluster[trk-&gt;entry].entries = samplesInChunk;
-    trk-&gt;cluster[trk-&gt;entry].dts = pkt-&gt;dts;
-    trk-&gt;trackDuration = pkt-&gt;dts - trk-&gt;cluster[0].dts + pkt-&gt;duration;
-
-    if (pkt-&gt;pts == AV_NOPTS_VALUE) {
-        av_log(s, AV_LOG_WARNING, &quot;pts has no value\n&quot;);
-        pkt-&gt;pts = pkt-&gt;dts;
-    }
-    if (pkt-&gt;dts != pkt-&gt;pts)
-        trk-&gt;flags |= MOV_TRACK_CTTS;
-    trk-&gt;cluster[trk-&gt;entry].cts = pkt-&gt;pts - pkt-&gt;dts;
-    trk-&gt;cluster[trk-&gt;entry].flags = 0;
-    if (pkt-&gt;flags &amp; AV_PKT_FLAG_KEY) {
-        if (mov-&gt;mode == MODE_MOV &amp;&amp; enc-&gt;codec_id == CODEC_ID_MPEG2VIDEO) {
-            mov_parse_mpeg2_frame(pkt, &amp;trk-&gt;cluster[trk-&gt;entry].flags);
-            if (trk-&gt;cluster[trk-&gt;entry].flags &amp; MOV_PARTIAL_SYNC_SAMPLE)
-                trk-&gt;flags |= MOV_TRACK_STPS;
-        } else {
-            trk-&gt;cluster[trk-&gt;entry].flags = MOV_SYNC_SAMPLE;
-        }
-        if (trk-&gt;cluster[trk-&gt;entry].flags &amp; MOV_SYNC_SAMPLE)
-            trk-&gt;hasKeyframes++;
-    }
-    trk-&gt;entry++;
-    trk-&gt;sampleCount += samplesInChunk;
-    mov-&gt;mdat_size += size;
-
-    put_flush_packet(pb);
-
-    if (trk-&gt;hint_track &gt;= 0 &amp;&amp; trk-&gt;hint_track &lt; mov-&gt;nb_streams)
-        ff_mov_add_hinted_packet(s, pkt, trk-&gt;hint_track, trk-&gt;entry);
-    return 0;
-}
-
-// QuickTime chapters involve an additional text track with the chapter names
-// as samples, and a tref pointing from the other tracks to the chapter one.
-static void mov_create_chapter_track(AVFormatContext *s, int tracknum)
-{
-    MOVMuxContext *mov = s-&gt;priv_data;
-    MOVTrack *track = &amp;mov-&gt;tracks[tracknum];
-    AVPacket pkt = { .stream_index = tracknum, .flags = AV_PKT_FLAG_KEY };
-    int i, len;
-
-    track-&gt;mode = mov-&gt;mode;
-    track-&gt;tag = MKTAG('t','e','x','t');
-    track-&gt;timescale = MOV_TIMESCALE;
-    track-&gt;enc = avcodec_alloc_context();
-    track-&gt;enc-&gt;codec_type = AVMEDIA_TYPE_SUBTITLE;
-
-    for (i = 0; i &lt; s-&gt;nb_chapters; i++) {
-        AVChapter *c = s-&gt;chapters[i];
-        AVMetadataTag *t;
-
-        int64_t end = av_rescale_q(c-&gt;end, c-&gt;time_base, (AVRational){1,MOV_TIMESCALE});
-        pkt.pts = pkt.dts = av_rescale_q(c-&gt;start, c-&gt;time_base, (AVRational){1,MOV_TIMESCALE});
-        pkt.duration = end - pkt.dts;
-
-        if ((t = av_metadata_get(c-&gt;metadata, &quot;title&quot;, NULL, 0))) {
-            len = strlen(t-&gt;value);
-            pkt.size = len+2;
-            pkt.data = av_malloc(pkt.size);
-            AV_WB16(pkt.data, len);
-            memcpy(pkt.data+2, t-&gt;value, len);
-            ff_mov_write_packet(s, &amp;pkt);
-            av_freep(&amp;pkt.data);
-        }
-    }
-}
-
-static int mov_write_header(AVFormatContext *s)
-{
-    ByteIOContext *pb = s-&gt;pb;
-    MOVMuxContext *mov = s-&gt;priv_data;
-    int i, hint_track = 0;
-
-    if (url_is_streamed(s-&gt;pb)) {
-        av_log(s, AV_LOG_ERROR, &quot;muxer does not support non seekable output\n&quot;);
-        return -1;
-    }
-
-    /* Default mode == MP4 */
-    mov-&gt;mode = MODE_MP4;
-
-    if (s-&gt;oformat != NULL) {
-        if (!strcmp(&quot;3gp&quot;, s-&gt;oformat-&gt;name)) mov-&gt;mode = MODE_3GP;
-        else if (!strcmp(&quot;3g2&quot;, s-&gt;oformat-&gt;name)) mov-&gt;mode = MODE_3GP|MODE_3G2;
-        else if (!strcmp(&quot;mov&quot;, s-&gt;oformat-&gt;name)) mov-&gt;mode = MODE_MOV;
-        else if (!strcmp(&quot;psp&quot;, s-&gt;oformat-&gt;name)) mov-&gt;mode = MODE_PSP;
-        else if (!strcmp(&quot;ipod&quot;,s-&gt;oformat-&gt;name)) mov-&gt;mode = MODE_IPOD;
-
-        mov_write_ftyp_tag(pb,s);
-        if (mov-&gt;mode == MODE_PSP) {
-            if (s-&gt;nb_streams != 2) {
-                av_log(s, AV_LOG_ERROR, &quot;PSP mode need one video and one audio stream\n&quot;);
-                return -1;
-            }
-            mov_write_uuidprof_tag(pb,s);
-        }
-    }
-
-    mov-&gt;nb_streams = s-&gt;nb_streams;
-    if (mov-&gt;mode &amp; (MODE_MOV|MODE_IPOD) &amp;&amp; s-&gt;nb_chapters)
-        mov-&gt;chapter_track = mov-&gt;nb_streams++;
-
-    if (s-&gt;flags &amp; AVFMT_FLAG_RTP_HINT) {
-        /* Add hint tracks for each audio and video stream */
-        hint_track = mov-&gt;nb_streams;
-        for (i = 0; i &lt; s-&gt;nb_streams; i++) {
-            AVStream *st = s-&gt;streams[i];
-            if (st-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_VIDEO ||
-                st-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_AUDIO) {
-                mov-&gt;nb_streams++;
-            }
-        }
-    }
-
-    mov-&gt;tracks = av_mallocz(mov-&gt;nb_streams*sizeof(*mov-&gt;tracks));
-    if (!mov-&gt;tracks)
-        return AVERROR(ENOMEM);
-
-    for(i=0; i&lt;s-&gt;nb_streams; i++){
-        AVStream *st= s-&gt;streams[i];
-        MOVTrack *track= &amp;mov-&gt;tracks[i];
-        AVMetadataTag *lang = av_metadata_get(st-&gt;metadata, &quot;language&quot;, NULL,0);
-
-        track-&gt;enc = st-&gt;codec;
-        track-&gt;language = ff_mov_iso639_to_lang(lang?lang-&gt;value:&quot;und&quot;, mov-&gt;mode!=MODE_MOV);
-        if (track-&gt;language &lt; 0)
-            track-&gt;language = 0;
-        track-&gt;mode = mov-&gt;mode;
-        track-&gt;tag = mov_find_codec_tag(s, track);
-        if (!track-&gt;tag) {
-            av_log(s, AV_LOG_ERROR, &quot;track %d: could not find tag, &quot;
-                   &quot;codec not currently supported in container\n&quot;, i);
-            goto error;
-        }
-        /* If hinting of this track is enabled by a later hint track,
-         * this is updated. */
-        track-&gt;hint_track = -1;
-        if(st-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_VIDEO){
-            if (track-&gt;tag == MKTAG('m','x','3','p') || track-&gt;tag == MKTAG('m','x','3','n') ||
-                track-&gt;tag == MKTAG('m','x','4','p') || track-&gt;tag == MKTAG('m','x','4','n') ||
-                track-&gt;tag == MKTAG('m','x','5','p') || track-&gt;tag == MKTAG('m','x','5','n')) {
-                if (st-&gt;codec-&gt;width != 720 || (st-&gt;codec-&gt;height != 608 &amp;&amp; st-&gt;codec-&gt;height != 512)) {
-                    av_log(s, AV_LOG_ERROR, &quot;D-10/IMX must use 720x608 or 720x512 video resolution\n&quot;);
-                    goto error;
-                }
-                track-&gt;height = track-&gt;tag&gt;&gt;24 == 'n' ? 486 : 576;
-            }
-            track-&gt;timescale = st-&gt;codec-&gt;time_base.den;
-            if (track-&gt;mode == MODE_MOV &amp;&amp; track-&gt;timescale &gt; 100000)
-                av_log(s, AV_LOG_WARNING,
-                       &quot;WARNING codec timebase is very high. If duration is too long,\n&quot;
-                       &quot;file may not be playable by quicktime. Specify a shorter timebase\n&quot;
-                       &quot;or choose different container.\n&quot;);
-        }else if(st-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_AUDIO){
-            track-&gt;timescale = st-&gt;codec-&gt;sample_rate;
-            if(!st-&gt;codec-&gt;frame_size &amp;&amp; !av_get_bits_per_sample(st-&gt;codec-&gt;codec_id)) {
-                av_log(s, AV_LOG_ERROR, &quot;track %d: codec frame size is not set\n&quot;, i);
-                goto error;
-            }else if(st-&gt;codec-&gt;frame_size &gt; 1){ /* assume compressed audio */
-                track-&gt;audio_vbr = 1;
-            }else{
-                st-&gt;codec-&gt;frame_size = 1;
-                track-&gt;sampleSize = (av_get_bits_per_sample(st-&gt;codec-&gt;codec_id) &gt;&gt; 3) * st-&gt;codec-&gt;channels;
-            }
-            if (track-&gt;mode != MODE_MOV) {
-                if (track-&gt;timescale &gt; UINT16_MAX) {
-                    av_log(s, AV_LOG_ERROR, &quot;track %d: output format does not support &quot;
-                           &quot;sample rate %dhz\n&quot;, i, track-&gt;timescale);
-                    goto error;
-                }
-                if (track-&gt;enc-&gt;codec_id == CODEC_ID_MP3 &amp;&amp; track-&gt;timescale &lt; 16000) {
-                    av_log(s, AV_LOG_ERROR, &quot;track %d: muxing mp3 at %dhz is not supported\n&quot;,
-                           i, track-&gt;enc-&gt;sample_rate);
-                    goto error;
-                }
-            }
-        }else if(st-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_SUBTITLE){
-            track-&gt;timescale = st-&gt;codec-&gt;time_base.den;
-        }
-        if (!track-&gt;height)
-            track-&gt;height = st-&gt;codec-&gt;height;
-
-        av_set_pts_info(st, 64, 1, track-&gt;timescale);
-    }
-
-    mov_write_mdat_tag(pb, mov);
-    mov-&gt;time = s-&gt;timestamp + 0x7C25B080; //1970 based -&gt; 1904 based
-
-    if (mov-&gt;chapter_track)
-        mov_create_chapter_track(s, mov-&gt;chapter_track);
-
-    if (s-&gt;flags &amp; AVFMT_FLAG_RTP_HINT) {
-        /* Initialize the hint tracks for each audio and video stream */
-        for (i = 0; i &lt; s-&gt;nb_streams; i++) {
-            AVStream *st = s-&gt;streams[i];
-            if (st-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_VIDEO ||
-                st-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_AUDIO) {
-                ff_mov_init_hinting(s, hint_track, i);
-                hint_track++;
-            }
-        }
-    }
-
-    put_flush_packet(pb);
-
-    return 0;
- error:
-    av_freep(&amp;mov-&gt;tracks);
-    return -1;
-}
-
-static int mov_write_trailer(AVFormatContext *s)
-{
-    MOVMuxContext *mov = s-&gt;priv_data;
-    ByteIOContext *pb = s-&gt;pb;
-    int res = 0;
-    int i;
-
-    int64_t moov_pos = url_ftell(pb);
-
-    /* Write size of mdat tag */
-    if (mov-&gt;mdat_size+8 &lt;= UINT32_MAX) {
-        url_fseek(pb, mov-&gt;mdat_pos, SEEK_SET);
-        put_be32(pb, mov-&gt;mdat_size+8);
-    } else {
-        /* overwrite 'wide' placeholder atom */
-        url_fseek(pb, mov-&gt;mdat_pos - 8, SEEK_SET);
-        put_be32(pb, 1); /* special value: real atom size will be 64 bit value after tag field */
-        put_tag(pb, &quot;mdat&quot;);
-        put_be64(pb, mov-&gt;mdat_size+16);
-    }
-    url_fseek(pb, moov_pos, SEEK_SET);
-
-    mov_write_moov_tag(pb, mov, s);
-
-    if (mov-&gt;chapter_track)
-        av_freep(&amp;mov-&gt;tracks[mov-&gt;chapter_track].enc);
-
-    for (i=0; i&lt;mov-&gt;nb_streams; i++) {
-        if (mov-&gt;tracks[i].tag == MKTAG('r','t','p',' '))
-            ff_mov_close_hinting(&amp;mov-&gt;tracks[i]);
-        av_freep(&amp;mov-&gt;tracks[i].cluster);
-
-        if(mov-&gt;tracks[i].vosLen) av_free(mov-&gt;tracks[i].vosData);
-
-    }
-
-    put_flush_packet(pb);
-
-    av_freep(&amp;mov-&gt;tracks);
-
-    return res;
-}
-
-#if CONFIG_MOV_MUXER
-AVOutputFormat mov_muxer = {
-    &quot;mov&quot;,
-    NULL_IF_CONFIG_SMALL(&quot;MOV format&quot;),
-    NULL,
-    &quot;mov&quot;,
-    sizeof(MOVMuxContext),
-    CODEC_ID_AAC,
-    CODEC_ID_MPEG4,
-    mov_write_header,
-    ff_mov_write_packet,
-    mov_write_trailer,
-    .flags = AVFMT_GLOBALHEADER | AVFMT_VARIABLE_FPS,
-    .codec_tag = (const AVCodecTag* const []){codec_movvideo_tags, codec_movaudio_tags, 0},
-};
-#endif
-#if CONFIG_TGP_MUXER
-AVOutputFormat tgp_muxer = {
-    &quot;3gp&quot;,
-    NULL_IF_CONFIG_SMALL(&quot;3GP format&quot;),
-    NULL,
-    &quot;3gp&quot;,
-    sizeof(MOVMuxContext),
-    CODEC_ID_AMR_NB,
-    CODEC_ID_H263,
-    mov_write_header,
-    ff_mov_write_packet,
-    mov_write_trailer,
-    .flags = AVFMT_GLOBALHEADER,
-    .codec_tag = (const AVCodecTag* const []){codec_3gp_tags, 0},
-};
-#endif
-#if CONFIG_MP4_MUXER
-AVOutputFormat mp4_muxer = {
-    &quot;mp4&quot;,
-    NULL_IF_CONFIG_SMALL(&quot;MP4 format&quot;),
-    &quot;application/mp4&quot;,
-    &quot;mp4&quot;,
-    sizeof(MOVMuxContext),
-    CODEC_ID_AAC,
-    CODEC_ID_MPEG4,
-    mov_write_header,
-    ff_mov_write_packet,
-    mov_write_trailer,
-    .flags = AVFMT_GLOBALHEADER | AVFMT_VARIABLE_FPS,
-    .codec_tag = (const AVCodecTag* const []){ff_mp4_obj_type, 0},
-};
-#endif
-#if CONFIG_PSP_MUXER
-AVOutputFormat psp_muxer = {
-    &quot;psp&quot;,
-    NULL_IF_CONFIG_SMALL(&quot;PSP MP4 format&quot;),
-    NULL,
-    &quot;mp4,psp&quot;,
-    sizeof(MOVMuxContext),
-    CODEC_ID_AAC,
-    CODEC_ID_MPEG4,
-    mov_write_header,
-    ff_mov_write_packet,
-    mov_write_trailer,
-    .flags = AVFMT_GLOBALHEADER,
-    .codec_tag = (const AVCodecTag* const []){ff_mp4_obj_type, 0},
-};
-#endif
-#if CONFIG_TG2_MUXER
-AVOutputFormat tg2_muxer = {
-    &quot;3g2&quot;,
-    NULL_IF_CONFIG_SMALL(&quot;3GP2 format&quot;),
-    NULL,
-    &quot;3g2&quot;,
-    sizeof(MOVMuxContext),
-    CODEC_ID_AMR_NB,
-    CODEC_ID_H263,
-    mov_write_header,
-    ff_mov_write_packet,
-    mov_write_trailer,
-    .flags = AVFMT_GLOBALHEADER,
-    .codec_tag = (const AVCodecTag* const []){codec_3gp_tags, 0},
-};
-#endif
-#if CONFIG_IPOD_MUXER
-AVOutputFormat ipod_muxer = {
-    &quot;ipod&quot;,
-    NULL_IF_CONFIG_SMALL(&quot;iPod H.264 MP4 format&quot;),
-    &quot;application/mp4&quot;,
-    &quot;m4v,m4a&quot;,
-    sizeof(MOVMuxContext),
-    CODEC_ID_AAC,
-    CODEC_ID_H264,
-    mov_write_header,
-    ff_mov_write_packet,
-    mov_write_trailer,
-    .flags = AVFMT_GLOBALHEADER,
-    .codec_tag = (const AVCodecTag* const []){codec_ipod_tags, 0},
-};
-#endif


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003670.html">[Avidemux-svn-commit] r6483 - in	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg:	libavcodec libavcodec/x86 patches patches/avcodec
</A></li>
	<LI>Next message: <A HREF="003672.html">[Avidemux-svn-commit] r6485 - in	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches:	. avcodec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3671">[ date ]</a>
              <a href="thread.html#3671">[ thread ]</a>
              <a href="subject.html#3671">[ subject ]</a>
              <a href="author.html#3671">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
