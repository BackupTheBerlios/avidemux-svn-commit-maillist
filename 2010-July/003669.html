<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r6482 - in	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale:	. x86
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2010-July/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r6482%20-%20in%0A%09branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale%3A%0A%09.%20x86&In-Reply-To=%3C20100725100749.8B3A2480E6C%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003668.html">
   <LINK REL="Next"  HREF="003670.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r6482 - in	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale:	. x86</H1>
    <B>mean at mail.berlios.de</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r6482%20-%20in%0A%09branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale%3A%0A%09.%20x86&In-Reply-To=%3C20100725100749.8B3A2480E6C%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r6482 - in	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale:	. x86">mean at mail.berlios.de
       </A><BR>
    <I>Sun Jul 25 12:07:49 CEST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="003668.html">[Avidemux-svn-commit] r6481 - in	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg:	libavformat patches patches/avformat
</A></li>
        <LI>Next message: <A HREF="003670.html">[Avidemux-svn-commit] r6483 - in	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg:	libavcodec libavcodec/x86 patches patches/avcodec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3669">[ date ]</a>
              <a href="thread.html#3669">[ thread ]</a>
              <a href="subject.html#3669">[ subject ]</a>
              <a href="author.html#3669">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2010-07-25 12:07:49 +0200 (Sun, 25 Jul 2010)
New Revision: 6482

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/rgb2rgb.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/rgb2rgb.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/rgb2rgb_template.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/swscale.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/swscale.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/swscale_internal.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/swscale_template.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/utils.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/x86/yuv2rgb_mmx.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/x86/yuv2rgb_template.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/yuv2rgb.c
Log:
[swscale] update 25 july

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/CMakeLists.txt	2010-07-25 10:07:46 UTC (rev 6481)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/CMakeLists.txt	2010-07-25 10:07:49 UTC (rev 6482)
@@ -2,7 +2,7 @@
 SET(${ADM_LIB}_SRCS 
         swscale.c yuv2rgb.c rgb2rgb.c ADM_mp.cpp swscale_avoption.c utils.c
 )
-
+ADD_DEFINITIONS(&quot;-Dbswap_16=av_bswap16&quot;)
 IF(ADM_CPU_X86)
 SET(${ADM_LIB}_SRCS ${${ADM_LIB}_SRCS} x86/yuv2rgb_mmx.c)
 ENDIF(ADM_CPU_X86)

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/rgb2rgb.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/rgb2rgb.c	2010-07-25 10:07:46 UTC (rev 6481)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/rgb2rgb.c	2010-07-25 10:07:49 UTC (rev 6482)
@@ -8,22 +8,19 @@
  *
  * This file is part of FFmpeg.
  *
- * FFmpeg is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
  *
  * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
  *
- * You should have received a copy of the GNU General Public License
- * along with FFmpeg; if not, write to the Free Software
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- *
- * The C code (not assembly, MMX, ...) of this file can be used
- * under the LGPL license.
  */
 #include &lt;inttypes.h&gt;
 #include &quot;config.h&quot;
@@ -101,7 +98,7 @@
                      long lumStride, long chromStride, long srcStride);
 
 
-#if ARCH_X86 &amp;&amp; CONFIG_GPL
+#if ARCH_X86
 DECLARE_ASM_CONST(8, uint64_t, mmx_null)     = 0x0000000000000000ULL;
 DECLARE_ASM_CONST(8, uint64_t, mmx_one)      = 0xFFFFFFFFFFFFFFFFULL;
 DECLARE_ASM_CONST(8, uint64_t, mask32b)      = 0x000000FF000000FFULL;
@@ -162,7 +159,7 @@
 #define RENAME(a) a ## _C
 #include &quot;rgb2rgb_template.c&quot;
 
-#if ARCH_X86 &amp;&amp; CONFIG_GPL
+#if ARCH_X86
 
 //MMX versions
 #undef RENAME
@@ -198,7 +195,7 @@
 
 void sws_rgb2rgb_init(int flags)
 {
-#if (HAVE_MMX2 || HAVE_AMD3DNOW || HAVE_MMX)  &amp;&amp; CONFIG_GPL
+#if HAVE_MMX2 || HAVE_AMD3DNOW || HAVE_MMX
     if (flags &amp; SWS_CPU_CAPS_MMX2)
         rgb2rgb_init_MMX2();
     else if (flags &amp; SWS_CPU_CAPS_3DNOW)
@@ -210,31 +207,15 @@
         rgb2rgb_init_C();
 }
 
-/**
- * Convert the palette to the same packet 32-bit format as the palette
- */
+#if LIBSWSCALE_VERSION_MAJOR &lt; 1
 void palette8topacked32(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)
 {
-    long i;
-
-    for (i=0; i&lt;num_pixels; i++)
-        ((uint32_t *) dst)[i] = ((const uint32_t *) palette)[src[i]];
+    sws_convertPalette8ToPacked32(src, dst, num_pixels, palette);
 }
 
-/**
- * Palette format: ABCD -&gt; dst format: ABC
- */
 void palette8topacked24(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)
 {
-    long i;
-
-    for (i=0; i&lt;num_pixels; i++) {
-        //FIXME slow?
-        dst[0]= palette[src[i]*4+0];
-        dst[1]= palette[src[i]*4+1];
-        dst[2]= palette[src[i]*4+2];
-        dst+= 3;
-    }
+    sws_convertPalette8ToPacked24(src, dst, num_pixels, palette);
 }
 
 /**
@@ -252,23 +233,8 @@
     for (i=0; i&lt;num_pixels; i++)
         ((uint16_t *)dst)[i] = bswap_16(((const uint16_t *)palette)[src[i]]);
 }
+#endif
 
-/**
- * Palette is assumed to contain BGR15, see rgb32to15 to convert the palette.
- */
-void palette8torgb15(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)
-{
-    long i;
-    for (i=0; i&lt;num_pixels; i++)
-        ((uint16_t *)dst)[i] = ((const uint16_t *)palette)[src[i]];
-}
-void palette8tobgr15(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)
-{
-    long i;
-    for (i=0; i&lt;num_pixels; i++)
-        ((uint16_t *)dst)[i] = bswap_16(((const uint16_t *)palette)[src[i]]);
-}
-
 void rgb32to24(const uint8_t *src, uint8_t *dst, long src_size)
 {
     long i;

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/rgb2rgb.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/rgb2rgb.h	2010-07-25 10:07:46 UTC (rev 6481)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/rgb2rgb.h	2010-07-25 10:07:49 UTC (rev 6482)
@@ -4,7 +4,7 @@
  *               Software YUV to YUV converter
  *               Software YUV to RGB converter
  *  Written by Nick Kurshev.
- *  palette &amp; YUV &amp; runtime CPU stuff by Michael (<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">michaelni at gmx.at</A>)
+ *  YUV &amp; runtime CPU stuff by Michael (<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">michaelni at gmx.at</A>)
  *
  * This file is part of FFmpeg.
  *
@@ -28,6 +28,9 @@
 
 #include &lt;inttypes.h&gt;
 
+#include &quot;libswscale/swscale.h&quot;
+#include &quot;libavutil/avutil.h&quot;
+
 /* A full collection of RGB to RGB(BGR) converters */
 extern void (*rgb24tobgr32)(const uint8_t *src, uint8_t *dst, long src_size);
 extern void (*rgb24tobgr16)(const uint8_t *src, uint8_t *dst, long src_size);
@@ -66,13 +69,16 @@
 void shuffle_bytes_3012(const uint8_t *src, uint8_t *dst, long src_size);
 void shuffle_bytes_3210(const uint8_t *src, uint8_t *dst, long src_size);
 
-void palette8topacked32(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette);
-void palette8topacked24(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette);
-void palette8torgb16(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette);
-void palette8tobgr16(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette);
-void palette8torgb15(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette);
-void palette8tobgr15(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette);
+#if LIBSWSCALE_VERSION_MAJOR &lt; 1
+/* deprecated, use the public versions in swscale.h */
+attribute_deprecated void palette8topacked32(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette);
+attribute_deprecated void palette8topacked24(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette);
 
+/* totally deprecated, please fix code that uses this */
+attribute_deprecated void palette8torgb16(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette);
+attribute_deprecated void palette8tobgr16(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette);
+#endif
+
 /**
  * Height should be a multiple of 2 and width should be a multiple of 16.
  * (If this is a problem for anyone then tell me, and I will fix it.)

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/rgb2rgb_template.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/rgb2rgb_template.c	2010-07-25 10:07:46 UTC (rev 6481)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/rgb2rgb_template.c	2010-07-25 10:07:49 UTC (rev 6482)
@@ -9,22 +9,19 @@
  *
  * This file is part of FFmpeg.
  *
- * FFmpeg is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
  *
  * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
  *
- * You should have received a copy of the GNU General Public License
- * along with FFmpeg; if not, write to the Free Software
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- *
- * The C code (not assembly, MMX, ...) of this file can be used
- * under the LGPL license.
  */
 
 #include &lt;stddef.h&gt;
@@ -125,6 +122,43 @@
     }
 }
 
+#define STORE_BGR24_MMX \
+            &quot;psrlq         $8, %%mm2    \n\t&quot; \
+            &quot;psrlq         $8, %%mm3    \n\t&quot; \
+            &quot;psrlq         $8, %%mm6    \n\t&quot; \
+            &quot;psrlq         $8, %%mm7    \n\t&quot; \
+            &quot;pand &quot;MANGLE(mask24l)&quot;, %%mm0\n\t&quot; \
+            &quot;pand &quot;MANGLE(mask24l)&quot;, %%mm1\n\t&quot; \
+            &quot;pand &quot;MANGLE(mask24l)&quot;, %%mm4\n\t&quot; \
+            &quot;pand &quot;MANGLE(mask24l)&quot;, %%mm5\n\t&quot; \
+            &quot;pand &quot;MANGLE(mask24h)&quot;, %%mm2\n\t&quot; \
+            &quot;pand &quot;MANGLE(mask24h)&quot;, %%mm3\n\t&quot; \
+            &quot;pand &quot;MANGLE(mask24h)&quot;, %%mm6\n\t&quot; \
+            &quot;pand &quot;MANGLE(mask24h)&quot;, %%mm7\n\t&quot; \
+            &quot;por        %%mm2, %%mm0    \n\t&quot; \
+            &quot;por        %%mm3, %%mm1    \n\t&quot; \
+            &quot;por        %%mm6, %%mm4    \n\t&quot; \
+            &quot;por        %%mm7, %%mm5    \n\t&quot; \
+ \
+            &quot;movq       %%mm1, %%mm2    \n\t&quot; \
+            &quot;movq       %%mm4, %%mm3    \n\t&quot; \
+            &quot;psllq        $48, %%mm2    \n\t&quot; \
+            &quot;psllq        $32, %%mm3    \n\t&quot; \
+            &quot;pand &quot;MANGLE(mask24hh)&quot;, %%mm2\n\t&quot; \
+            &quot;pand &quot;MANGLE(mask24hhh)&quot;, %%mm3\n\t&quot; \
+            &quot;por        %%mm2, %%mm0    \n\t&quot; \
+            &quot;psrlq        $16, %%mm1    \n\t&quot; \
+            &quot;psrlq        $32, %%mm4    \n\t&quot; \
+            &quot;psllq        $16, %%mm5    \n\t&quot; \
+            &quot;por        %%mm3, %%mm1    \n\t&quot; \
+            &quot;pand  &quot;MANGLE(mask24hhhh)&quot;, %%mm5\n\t&quot; \
+            &quot;por        %%mm5, %%mm4    \n\t&quot; \
+ \
+            MOVNTQ&quot;     %%mm0,   %0     \n\t&quot; \
+            MOVNTQ&quot;     %%mm1,  8%0     \n\t&quot; \
+            MOVNTQ&quot;     %%mm4, 16%0&quot;
+
+
 static inline void RENAME(rgb32tobgr24)(const uint8_t *src, uint8_t *dst, long src_size)
 {
     uint8_t *dest = dst;
@@ -148,43 +182,9 @@
             &quot;movq       %%mm1, %%mm3    \n\t&quot;
             &quot;movq       %%mm4, %%mm6    \n\t&quot;
             &quot;movq       %%mm5, %%mm7    \n\t&quot;
-            &quot;psrlq         $8, %%mm2    \n\t&quot;
-            &quot;psrlq         $8, %%mm3    \n\t&quot;
-            &quot;psrlq         $8, %%mm6    \n\t&quot;
-            &quot;psrlq         $8, %%mm7    \n\t&quot;
-            &quot;pand          %2, %%mm0    \n\t&quot;
-            &quot;pand          %2, %%mm1    \n\t&quot;
-            &quot;pand          %2, %%mm4    \n\t&quot;
-            &quot;pand          %2, %%mm5    \n\t&quot;
-            &quot;pand          %3, %%mm2    \n\t&quot;
-            &quot;pand          %3, %%mm3    \n\t&quot;
-            &quot;pand          %3, %%mm6    \n\t&quot;
-            &quot;pand          %3, %%mm7    \n\t&quot;
-            &quot;por        %%mm2, %%mm0    \n\t&quot;
-            &quot;por        %%mm3, %%mm1    \n\t&quot;
-            &quot;por        %%mm6, %%mm4    \n\t&quot;
-            &quot;por        %%mm7, %%mm5    \n\t&quot;
-
-            &quot;movq       %%mm1, %%mm2    \n\t&quot;
-            &quot;movq       %%mm4, %%mm3    \n\t&quot;
-            &quot;psllq        $48, %%mm2    \n\t&quot;
-            &quot;psllq        $32, %%mm3    \n\t&quot;
-            &quot;pand          %4, %%mm2    \n\t&quot;
-            &quot;pand          %5, %%mm3    \n\t&quot;
-            &quot;por        %%mm2, %%mm0    \n\t&quot;
-            &quot;psrlq        $16, %%mm1    \n\t&quot;
-            &quot;psrlq        $32, %%mm4    \n\t&quot;
-            &quot;psllq        $16, %%mm5    \n\t&quot;
-            &quot;por        %%mm3, %%mm1    \n\t&quot;
-            &quot;pand          %6, %%mm5    \n\t&quot;
-            &quot;por        %%mm5, %%mm4    \n\t&quot;
-
-            MOVNTQ&quot;     %%mm0,   %0     \n\t&quot;
-            MOVNTQ&quot;     %%mm1,  8%0     \n\t&quot;
-            MOVNTQ&quot;     %%mm4, 16%0&quot;
+            STORE_BGR24_MMX
             :&quot;=m&quot;(*dest)
-            :&quot;m&quot;(*s),&quot;m&quot;(mask24l),
-            &quot;m&quot;(mask24h),&quot;m&quot;(mask24hh),&quot;m&quot;(mask24hhh),&quot;m&quot;(mask24hhhh)
+            :&quot;m&quot;(*s)
             :&quot;memory&quot;);
         dest += 24;
         s += 32;
@@ -974,43 +974,10 @@
             &quot;movq       %%mm0, %%mm2    \n\t&quot;
             &quot;movq       %%mm1, %%mm3    \n\t&quot;
 
-            &quot;psrlq         $8, %%mm2    \n\t&quot;
-            &quot;psrlq         $8, %%mm3    \n\t&quot;
-            &quot;psrlq         $8, %%mm6    \n\t&quot;
-            &quot;psrlq         $8, %%mm7    \n\t&quot;
-            &quot;pand          %2, %%mm0    \n\t&quot;
-            &quot;pand          %2, %%mm1    \n\t&quot;
-            &quot;pand          %2, %%mm4    \n\t&quot;
-            &quot;pand          %2, %%mm5    \n\t&quot;
-            &quot;pand          %3, %%mm2    \n\t&quot;
-            &quot;pand          %3, %%mm3    \n\t&quot;
-            &quot;pand          %3, %%mm6    \n\t&quot;
-            &quot;pand          %3, %%mm7    \n\t&quot;
-            &quot;por        %%mm2, %%mm0    \n\t&quot;
-            &quot;por        %%mm3, %%mm1    \n\t&quot;
-            &quot;por        %%mm6, %%mm4    \n\t&quot;
-            &quot;por        %%mm7, %%mm5    \n\t&quot;
+            STORE_BGR24_MMX
 
-            &quot;movq       %%mm1, %%mm2    \n\t&quot;
-            &quot;movq       %%mm4, %%mm3    \n\t&quot;
-            &quot;psllq        $48, %%mm2    \n\t&quot;
-            &quot;psllq        $32, %%mm3    \n\t&quot;
-            &quot;pand          %4, %%mm2    \n\t&quot;
-            &quot;pand          %5, %%mm3    \n\t&quot;
-            &quot;por        %%mm2, %%mm0    \n\t&quot;
-            &quot;psrlq        $16, %%mm1    \n\t&quot;
-            &quot;psrlq        $32, %%mm4    \n\t&quot;
-            &quot;psllq        $16, %%mm5    \n\t&quot;
-            &quot;por        %%mm3, %%mm1    \n\t&quot;
-            &quot;pand          %6, %%mm5    \n\t&quot;
-            &quot;por        %%mm5, %%mm4    \n\t&quot;
-
-            MOVNTQ&quot;     %%mm0,   %0     \n\t&quot;
-            MOVNTQ&quot;     %%mm1,  8%0     \n\t&quot;
-            MOVNTQ&quot;     %%mm4, 16%0&quot;
-
             :&quot;=m&quot;(*d)
-            :&quot;m&quot;(*s),&quot;m&quot;(mask24l),&quot;m&quot;(mask24h),&quot;m&quot;(mask24hh),&quot;m&quot;(mask24hhh),&quot;m&quot;(mask24hhhh)
+            :&quot;m&quot;(*s)
             :&quot;memory&quot;);
         d += 24;
         s += 8;
@@ -1113,43 +1080,10 @@
             &quot;movq       %%mm0, %%mm2    \n\t&quot;
             &quot;movq       %%mm1, %%mm3    \n\t&quot;
 
-            &quot;psrlq         $8, %%mm2    \n\t&quot;
-            &quot;psrlq         $8, %%mm3    \n\t&quot;
-            &quot;psrlq         $8, %%mm6    \n\t&quot;
-            &quot;psrlq         $8, %%mm7    \n\t&quot;
-            &quot;pand          %2, %%mm0    \n\t&quot;
-            &quot;pand          %2, %%mm1    \n\t&quot;
-            &quot;pand          %2, %%mm4    \n\t&quot;
-            &quot;pand          %2, %%mm5    \n\t&quot;
-            &quot;pand          %3, %%mm2    \n\t&quot;
-            &quot;pand          %3, %%mm3    \n\t&quot;
-            &quot;pand          %3, %%mm6    \n\t&quot;
-            &quot;pand          %3, %%mm7    \n\t&quot;
-            &quot;por        %%mm2, %%mm0    \n\t&quot;
-            &quot;por        %%mm3, %%mm1    \n\t&quot;
-            &quot;por        %%mm6, %%mm4    \n\t&quot;
-            &quot;por        %%mm7, %%mm5    \n\t&quot;
+            STORE_BGR24_MMX
 
-            &quot;movq       %%mm1, %%mm2    \n\t&quot;
-            &quot;movq       %%mm4, %%mm3    \n\t&quot;
-            &quot;psllq        $48, %%mm2    \n\t&quot;
-            &quot;psllq        $32, %%mm3    \n\t&quot;
-            &quot;pand          %4, %%mm2    \n\t&quot;
-            &quot;pand          %5, %%mm3    \n\t&quot;
-            &quot;por        %%mm2, %%mm0    \n\t&quot;
-            &quot;psrlq        $16, %%mm1    \n\t&quot;
-            &quot;psrlq        $32, %%mm4    \n\t&quot;
-            &quot;psllq        $16, %%mm5    \n\t&quot;
-            &quot;por        %%mm3, %%mm1    \n\t&quot;
-            &quot;pand          %6, %%mm5    \n\t&quot;
-            &quot;por        %%mm5, %%mm4    \n\t&quot;
-
-            MOVNTQ&quot;     %%mm0,   %0     \n\t&quot;
-            MOVNTQ&quot;     %%mm1,  8%0     \n\t&quot;
-            MOVNTQ&quot;     %%mm4, 16%0&quot;
-
             :&quot;=m&quot;(*d)
-            :&quot;m&quot;(*s),&quot;m&quot;(mask24l),&quot;m&quot;(mask24h),&quot;m&quot;(mask24hh),&quot;m&quot;(mask24hhh),&quot;m&quot;(mask24hhhh)
+            :&quot;m&quot;(*s)
             :&quot;memory&quot;);
         d += 24;
         s += 8;

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/swscale.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/swscale.c	2010-07-25 10:07:46 UTC (rev 6481)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/swscale.c	2010-07-25 10:07:49 UTC (rev 6482)
@@ -3,22 +3,19 @@
  *
  * This file is part of FFmpeg.
  *
- * FFmpeg is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
  *
  * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
  *
- * You should have received a copy of the GNU General Public License
- * along with FFmpeg; if not, write to the Free Software
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- *
- * the C code (not assembly, mmx, ...) of this file can be used
- * under the LGPL license too
  */
 
 /*
@@ -27,7 +24,7 @@
   {BGR,RGB}{1,4,8,15,16} support dithering
 
   unscaled special converters (YV12=I420=IYUV, Y800=Y8)
-  YV12 -&gt; {BGR,RGB}{1,4,8,15,16,24,32}
+  YV12 -&gt; {BGR,RGB}{1,4,8,12,15,16,24,32}
   x -&gt; x
   YUV9 -&gt; YV12
   YUV9/YV12 -&gt; Y800
@@ -39,7 +36,7 @@
 
 /*
 tested special converters (most are tested actually, but I did not write it down ...)
- YV12 -&gt; BGR16
+ YV12 -&gt; BGR12/BGR16
  YV12 -&gt; YV12
  BGR15 -&gt; BGR16
  BGR16 -&gt; BGR16
@@ -66,6 +63,7 @@
 #include &quot;libavutil/intreadwrite.h&quot;
 #include &quot;libavutil/x86_cpu.h&quot;
 #include &quot;libavutil/avutil.h&quot;
+#include &quot;libavutil/mathematics.h&quot;
 #include &quot;libavutil/bswap.h&quot;
 #include &quot;libavutil/pixdesc.h&quot;
 
@@ -80,19 +78,12 @@
 
 #define FAST_BGR2YV12 // use 7 bit coefficients instead of 15 bit
 
-#ifdef M_PI
-#define PI M_PI
-#else
-#define PI 3.14159265358979323846
-#endif
-
 #define isPacked(x)         (       \
            (x)==PIX_FMT_PAL8        \
         || (x)==PIX_FMT_YUYV422     \
         || (x)==PIX_FMT_UYVY422     \
         || isAnyRGB(x)              \
     )
-#define usePal(x) (av_pix_fmt_descriptors[x].flags &amp; PIX_FMT_PAL)
 
 #define RGB2YUV_SHIFT 15
 #define BY ( (int)(0.114*219/255*(1&lt;&lt;RGB2YUV_SHIFT)+0.5))
@@ -131,7 +122,7 @@
 write special BGR-&gt;BGR scaler
 */
 
-#if ARCH_X86 &amp;&amp; CONFIG_GPL
+#if ARCH_X86
 DECLARE_ASM_CONST(8, uint64_t, bF8)=       0xF8F8F8F8F8F8F8F8LL;
 DECLARE_ASM_CONST(8, uint64_t, bFC)=       0xFCFCFCFCFCFCFCFCLL;
 DECLARE_ASM_CONST(8, uint64_t, w10)=       0x0010001000100010LL;
@@ -186,7 +177,7 @@
 
 DECLARE_ASM_CONST(8, uint64_t, ff_bgr24toUVOffset)= 0x0040400000404000ULL;
 
-#endif /* ARCH_X86 &amp;&amp; CONFIG_GPL */
+#endif /* ARCH_X86 */
 
 DECLARE_ALIGNED(8, static const uint8_t, dither_2x2_4)[2][8]={
 {  1,   3,   1,   3,   1,   3,   1,   3, },
@@ -198,6 +189,13 @@
 {  0,   4,   0,   4,   0,   4,   0,   4, },
 };
 
+DECLARE_ALIGNED(8, const uint8_t, dither_4x4_16)[4][8]={
+{  8,   4,  11,   7,   8,   4,  11,   7, },
+{  2,  14,   1,  13,   2,  14,   1,  13, },
+{ 10,   6,   9,   5,  10,   6,   9,   5, },
+{  0,  12,   3,  15,   0,  12,   3,  15, },
+};
+
 DECLARE_ALIGNED(8, const uint8_t, dither_8x8_32)[8][8]={
 { 17,   9,  23,  15,  16,   8,  22,  14, },
 {  5,  29,   3,  27,   4,  28,   2,  26, },
@@ -765,8 +763,10 @@
             dest+=6;\
         }\
         break;\
-    case PIX_FMT_RGB565:\
-    case PIX_FMT_BGR565:\
+    case PIX_FMT_RGB565BE:\
+    case PIX_FMT_RGB565LE:\
+    case PIX_FMT_BGR565BE:\
+    case PIX_FMT_BGR565LE:\
         {\
             const int dr1= dither_2x2_8[y&amp;1    ][0];\
             const int dg1= dither_2x2_4[y&amp;1    ][0];\
@@ -780,8 +780,10 @@
             }\
         }\
         break;\
-    case PIX_FMT_RGB555:\
-    case PIX_FMT_BGR555:\
+    case PIX_FMT_RGB555BE:\
+    case PIX_FMT_RGB555LE:\
+    case PIX_FMT_BGR555BE:\
+    case PIX_FMT_BGR555LE:\
         {\
             const int dr1= dither_2x2_8[y&amp;1    ][0];\
             const int dg1= dither_2x2_8[y&amp;1    ][1];\
@@ -795,6 +797,23 @@
             }\
         }\
         break;\
+    case PIX_FMT_RGB444BE:\
+    case PIX_FMT_RGB444LE:\
+    case PIX_FMT_BGR444BE:\
+    case PIX_FMT_BGR444LE:\
+        {\
+            const int dr1= dither_4x4_16[y&amp;3    ][0];\
+            const int dg1= dither_4x4_16[y&amp;3    ][1];\
+            const int db1= dither_4x4_16[(y&amp;3)^3][0];\
+            const int dr2= dither_4x4_16[y&amp;3    ][1];\
+            const int dg2= dither_4x4_16[y&amp;3    ][0];\
+            const int db2= dither_4x4_16[(y&amp;3)^3][1];\
+            func(uint16_t,0)\
+                ((uint16_t*)dest)[i2+0]= r[Y1+dr1] + g[Y1+dg1] + b[Y1+db1];\
+                ((uint16_t*)dest)[i2+1]= r[Y2+dr2] + g[Y2+dg2] + b[Y2+db2];\
+            }\
+        }\
+        break;\
     case PIX_FMT_RGB8:\
     case PIX_FMT_BGR8:\
         {\
@@ -970,7 +989,7 @@
     }
 }
 
-static inline void rgb48ToY(uint8_t *dst, const uint8_t *src, int width,
+static inline void rgb48ToY(uint8_t *dst, const uint8_t *src, long width,
                             uint32_t *unused)
 {
     int i;
@@ -985,7 +1004,7 @@
 
 static inline void rgb48ToUV(uint8_t *dstU, uint8_t *dstV,
                              const uint8_t *src1, const uint8_t *src2,
-                             int width, uint32_t *unused)
+                             long width, uint32_t *unused)
 {
     int i;
     assert(src1==src2);
@@ -1001,7 +1020,7 @@
 
 static inline void rgb48ToUV_half(uint8_t *dstU, uint8_t *dstV,
                                   const uint8_t *src1, const uint8_t *src2,
-                                  int width, uint32_t *unused)
+                                  long width, uint32_t *unused)
 {
     int i;
     assert(src1==src2);
@@ -1127,27 +1146,27 @@
 
 //Note: we have C, MMX, MMX2, 3DNOW versions, there is no 3DNOW+MMX2 one
 //Plain C versions
-#if ((!HAVE_MMX || !CONFIG_GPL) &amp;&amp; !HAVE_ALTIVEC) || CONFIG_RUNTIME_CPUDETECT
+#if (!HAVE_MMX &amp;&amp; !HAVE_ALTIVEC) || CONFIG_RUNTIME_CPUDETECT
 #define COMPILE_C
 #endif
 
 #if ARCH_PPC
-#if HAVE_ALTIVEC || CONFIG_RUNTIME_CPUDETECT
+#if HAVE_ALTIVEC
 #define COMPILE_ALTIVEC
 #endif
 #endif //ARCH_PPC
 
 #if ARCH_X86
 
-#if ((HAVE_MMX &amp;&amp; !HAVE_AMD3DNOW &amp;&amp; !HAVE_MMX2) || CONFIG_RUNTIME_CPUDETECT) &amp;&amp; CONFIG_GPL
+#if (HAVE_MMX &amp;&amp; !HAVE_AMD3DNOW &amp;&amp; !HAVE_MMX2) || CONFIG_RUNTIME_CPUDETECT
 #define COMPILE_MMX
 #endif
 
-#if (HAVE_MMX2 || CONFIG_RUNTIME_CPUDETECT) &amp;&amp; CONFIG_GPL
+#if HAVE_MMX2 || CONFIG_RUNTIME_CPUDETECT
 #define COMPILE_MMX2
 #endif
 
-#if ((HAVE_AMD3DNOW &amp;&amp; !HAVE_MMX2) || CONFIG_RUNTIME_CPUDETECT) &amp;&amp; CONFIG_GPL
+#if (HAVE_AMD3DNOW &amp;&amp; !HAVE_MMX2) || CONFIG_RUNTIME_CPUDETECT
 #define COMPILE_3DNOW
 #endif
 #endif //ARCH_X86
@@ -1218,7 +1237,7 @@
 #if CONFIG_RUNTIME_CPUDETECT
     int flags = c-&gt;flags;
 
-#if ARCH_X86 &amp;&amp; CONFIG_GPL
+#if ARCH_X86
     // ordered per speed fastest first
     if (flags &amp; SWS_CPU_CAPS_MMX2) {
         sws_init_swScale_MMX2(c);
@@ -1235,7 +1254,7 @@
     }
 
 #else
-#if ARCH_PPC
+#ifdef COMPILE_ALTIVEC
     if (flags &amp; SWS_CPU_CAPS_ALTIVEC) {
         sws_init_swScale_altivec(c);
         return swScale_altivec;
@@ -1246,7 +1265,7 @@
 #endif
     sws_init_swScale_C(c);
     return swScale_C;
-#endif /* ARCH_X86 &amp;&amp; CONFIG_GPL */
+#endif /* ARCH_X86 */
 #else //CONFIG_RUNTIME_CPUDETECT
 #if   COMPILE_TEMPLATE_MMX2
     sws_init_swScale_MMX2(c);
@@ -1400,12 +1419,12 @@
 
     if (usePal(srcFormat)) {
         switch (dstFormat) {
-        case PIX_FMT_RGB32  : conv = palette8topacked32; break;
-        case PIX_FMT_BGR32  : conv = palette8topacked32; break;
-        case PIX_FMT_BGR32_1: conv = palette8topacked32; break;
-        case PIX_FMT_RGB32_1: conv = palette8topacked32; break;
-        case PIX_FMT_RGB24  : conv = palette8topacked24; break;
-        case PIX_FMT_BGR24  : conv = palette8topacked24; break;
+        case PIX_FMT_RGB32  : conv = sws_convertPalette8ToPacked32; break;
+        case PIX_FMT_BGR32  : conv = sws_convertPalette8ToPacked32; break;
+        case PIX_FMT_BGR32_1: conv = sws_convertPalette8ToPacked32; break;
+        case PIX_FMT_RGB32_1: conv = sws_convertPalette8ToPacked32; break;
+        case PIX_FMT_RGB24  : conv = sws_convertPalette8ToPacked24; break;
+        case PIX_FMT_BGR24  : conv = sws_convertPalette8ToPacked24; break;
         }
     }
 
@@ -1849,6 +1868,8 @@
                 r= (i&gt;&gt;3    )*255;
                 g= ((i&gt;&gt;1)&amp;3)*85;
                 b= (i&amp;1     )*255;
+            } else if(c-&gt;srcFormat == PIX_FMT_GRAY8) {
+                r = g = b = i;
             } else {
                 assert(c-&gt;srcFormat == PIX_FMT_BGR4_BYTE);
                 b= (i&gt;&gt;3    )*255;
@@ -1936,3 +1957,26 @@
     return sws_scale(c, src, srcStride, srcSliceY, srcSliceH, dst, dstStride);
 }
 #endif
+
+/* Convert the palette to the same packed 32-bit format as the palette */
+void sws_convertPalette8ToPacked32(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)
+{
+    long i;
+
+    for (i=0; i&lt;num_pixels; i++)
+        ((uint32_t *) dst)[i] = ((const uint32_t *) palette)[src[i]];
+}
+
+/* Palette format: ABCD -&gt; dst format: ABC */
+void sws_convertPalette8ToPacked24(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)
+{
+    long i;
+
+    for (i=0; i&lt;num_pixels; i++) {
+        //FIXME slow?
+        dst[0]= palette[src[i]*4+0];
+        dst[1]= palette[src[i]*4+1];
+        dst[2]= palette[src[i]*4+2];
+        dst+= 3;
+    }
+}

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/swscale.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/swscale.h	2010-07-25 10:07:46 UTC (rev 6481)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/swscale.h	2010-07-25 10:07:49 UTC (rev 6482)
@@ -22,7 +22,7 @@
 #define SWSCALE_SWSCALE_H
 
 /**
- * @file libswscale/swscale.h
+ * @file
  * @brief
  *     external api for the swscale stuff
  */
@@ -30,7 +30,7 @@
 #include &quot;libavutil/avutil.h&quot;
 
 #define LIBSWSCALE_VERSION_MAJOR 0
-#define LIBSWSCALE_VERSION_MINOR 10
+#define LIBSWSCALE_VERSION_MINOR 11
 #define LIBSWSCALE_VERSION_MICRO 0
 
 #define LIBSWSCALE_VERSION_INT  AV_VERSION_INT(LIBSWSCALE_VERSION_MAJOR, \
@@ -194,6 +194,7 @@
  */
 int sws_scale(struct SwsContext *context, const uint8_t* const srcSlice[], const int srcStride[],
               int srcSliceY, int srcSliceH, uint8_t* const dst[], const int dstStride[]);
+
 #if LIBSWSCALE_VERSION_MAJOR &lt; 1
 /**
  * @deprecated Use sws_scale() instead.
@@ -302,4 +303,29 @@
                                         int flags, SwsFilter *srcFilter,
                                         SwsFilter *dstFilter, const double *param);
 
+/**
+ * Converts an 8bit paletted frame into a frame with a color depth of 32-bits.
+ *
+ * The output frame will have the same packed format as the palette.
+ *
+ * @param src        source frame buffer
+ * @param dst        destination frame buffer
+ * @param num_pixels number of pixels to convert
+ * @param palette    array with [256] entries, which must match color arrangement (RGB or BGR) of src
+ */
+void sws_convertPalette8ToPacked32(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette);
+
+/**
+ * Converts an 8bit paletted frame into a frame with a color depth of 24 bits.
+ *
+ * With the palette format &quot;ABCD&quot;, the destination frame ends up with the format &quot;ABC&quot;.
+ *
+ * @param src        source frame buffer
+ * @param dst        destination frame buffer
+ * @param num_pixels number of pixels to convert
+ * @param palette    array with [256] entries, which must match color arrangement (RGB or BGR) of src
+ */
+void sws_convertPalette8ToPacked24(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette);
+
+
 #endif /* SWSCALE_SWSCALE_H */

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/swscale_internal.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/swscale_internal.h	2010-07-25 10:07:46 UTC (rev 6481)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/swscale_internal.h	2010-07-25 10:07:49 UTC (rev 6482)
@@ -391,8 +391,12 @@
         || (x)==PIX_FMT_RGB32       \
         || (x)==PIX_FMT_RGB32_1     \
         || (x)==PIX_FMT_RGB24       \
-        || (x)==PIX_FMT_RGB565      \
-        || (x)==PIX_FMT_RGB555      \
+        || (x)==PIX_FMT_RGB565BE    \
+        || (x)==PIX_FMT_RGB565LE    \
+        || (x)==PIX_FMT_RGB555BE    \
+        || (x)==PIX_FMT_RGB555LE    \
+        || (x)==PIX_FMT_RGB444BE    \
+        || (x)==PIX_FMT_RGB444LE    \
         || (x)==PIX_FMT_RGB8        \
         || (x)==PIX_FMT_RGB4        \
         || (x)==PIX_FMT_RGB4_BYTE   \
@@ -403,8 +407,12 @@
            (x)==PIX_FMT_BGR32       \
         || (x)==PIX_FMT_BGR32_1     \
         || (x)==PIX_FMT_BGR24       \
-        || (x)==PIX_FMT_BGR565      \
-        || (x)==PIX_FMT_BGR555      \
+        || (x)==PIX_FMT_BGR565BE    \
+        || (x)==PIX_FMT_BGR565LE    \
+        || (x)==PIX_FMT_BGR555BE    \
+        || (x)==PIX_FMT_BGR555LE    \
+        || (x)==PIX_FMT_BGR444BE    \
+        || (x)==PIX_FMT_BGR444LE    \
         || (x)==PIX_FMT_BGR8        \
         || (x)==PIX_FMT_BGR4        \
         || (x)==PIX_FMT_BGR4_BYTE   \
@@ -434,6 +442,7 @@
         || (x)==PIX_FMT_RGB32_1     \
         || (x)==PIX_FMT_YUVA420P    \
     )
+#define usePal(x) (av_pix_fmt_descriptors[x].flags &amp; PIX_FMT_PAL)
 
 extern const uint64_t ff_dither4[2];
 extern const uint64_t ff_dither8[2];

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/swscale_template.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/swscale_template.c	2010-07-25 10:07:46 UTC (rev 6481)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/swscale_template.c	2010-07-25 10:07:49 UTC (rev 6482)
@@ -3,22 +3,19 @@
  *
  * This file is part of FFmpeg.
  *
- * FFmpeg is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
  *
  * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
  *
- * You should have received a copy of the GNU General Public License
- * along with FFmpeg; if not, write to the Free Software
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- *
- * The C code (not assembly, MMX, ...) of this file can be used
- * under the LGPL license.
  */
 
 #undef REAL_MOVNTQ
@@ -2211,7 +2208,7 @@
         dst[i] = FFMIN(val&gt;&gt;7, (1&lt;&lt;15)-1); // the cubic equation does overflow ...
         //dst[i] = val&gt;&gt;7;
     }
-#endif /* COMPILE_ALTIVEC */
+#endif /* COMPILE_TEMPLATE_ALTIVEC */
 #endif /* COMPILE_MMX */
 }
 
@@ -2258,7 +2255,7 @@
                                         long dstWidth, const uint8_t *src, int srcW,
                                         int xInc)
 {
-#if ARCH_X86 &amp;&amp; CONFIG_GPL
+#if ARCH_X86
 #if COMPILE_TEMPLATE_MMX2
     int32_t *filterPos = c-&gt;hLumFilterPos;
     int16_t *filter    = c-&gt;hLumFilter;
@@ -2407,7 +2404,7 @@
                                         long dstWidth, const uint8_t *src1,
                                         const uint8_t *src2, int srcW, int xInc)
 {
-#if ARCH_X86 &amp;&amp; CONFIG_GPL
+#if ARCH_X86
 #if COMPILE_TEMPLATE_MMX2
     int32_t *filterPos = c-&gt;hChrFilterPos;
     int16_t *filter    = c-&gt;hChrFilter;
@@ -2651,8 +2648,10 @@
         unsigned char *aDest=(CONFIG_SWSCALE_ALPHA &amp;&amp; alpPixBuf) ? dst[3]+dstStride[3]*dstY : NULL;
 
         const int firstLumSrcY= vLumFilterPos[dstY]; //First line needed as input
+        const int firstLumSrcY2= vLumFilterPos[FFMIN(dstY | ((1&lt;&lt;c-&gt;chrDstVSubSample) - 1), dstH-1)];
         const int firstChrSrcY= vChrFilterPos[chrDstY]; //First line needed as input
         int lastLumSrcY= firstLumSrcY + vLumFilterSize -1; // Last line needed as input
+        int lastLumSrcY2=firstLumSrcY2+ vLumFilterSize -1; // Last line needed as input
         int lastChrSrcY= firstChrSrcY + vChrFilterSize -1; // Last line needed as input
         int enough_lines;
 
@@ -2669,7 +2668,8 @@
                          firstChrSrcY,    lastChrSrcY,    lastInChrBuf);
 
         // Do we have enough lines in this slice to output the dstY line
-        enough_lines = lastLumSrcY &lt; srcSliceY + srcSliceH &amp;&amp; lastChrSrcY &lt; -((-srcSliceY - srcSliceH)&gt;&gt;c-&gt;chrSrcVSubSample);
+        enough_lines = lastLumSrcY2 &lt; srcSliceY + srcSliceH &amp;&amp; lastChrSrcY &lt; -((-srcSliceY - srcSliceH)&gt;&gt;c-&gt;chrSrcVSubSample);
+
         if (!enough_lines) {
             lastLumSrcY = srcSliceY + srcSliceH - 1;
             lastChrSrcY = chrSrcSliceY + chrSrcSliceH - 1;

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/utils.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/utils.c	2010-07-25 10:07:46 UTC (rev 6481)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/utils.c	2010-07-25 10:07:49 UTC (rev 6482)
@@ -3,22 +3,19 @@
  *
  * This file is part of FFmpeg.
  *
- * FFmpeg is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
  *
  * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
  *
- * You should have received a copy of the GNU General Public License
- * along with FFmpeg; if not, write to the Free Software
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- *
- * the C code (not assembly, mmx, ...) of this file can be used
- * under the LGPL license too
  */
 
 #define _SVID_SOURCE //needed for MAP_ANONYMOUS
@@ -54,13 +51,13 @@
 
 const char *swscale_configuration(void)
 {
-    return &quot;avidemux&quot;;//FFMPEG_CONFIGURATION;
+    return &quot;avidemux&quot;; // MEANX FFMPEG_CONFIGURATION;
 }
 
 const char *swscale_license(void)
 {
 #define LICENSE_PREFIX &quot;libswscale license: &quot;
-    return LICENSE_PREFIX &quot;GPL&quot;; //FFMPEG_LICENSE + sizeof(LICENSE_PREFIX) - 1;
+    return LICENSE_PREFIX &quot;GPL&quot;; // MEANX FFMPEG_LICENSE + sizeof(LICENSE_PREFIX) - 1;
 }
 
 #define RET 0xC3 //near return opcode for x86
@@ -150,8 +147,6 @@
     return isSupportedOut(pix_fmt);
 }
 
-#define usePal(x) (av_pix_fmt_descriptors[x].flags &amp; PIX_FMT_PAL)
-
 extern const int32_t ff_yuv2rgb_coeffs[8][4];
 
 const char *sws_format_name(enum PixelFormat format)
@@ -292,7 +287,7 @@
                 }
 /*                else if (flags &amp; SWS_X) {
                     double p= param ? param*0.01 : 0.3;
-                    coeff = d ? sin(d*PI)/(d*PI) : 1.0;
+                    coeff = d ? sin(d*M_PI)/(d*M_PI) : 1.0;
                     coeff*= pow(2.0, - p*d*d);
                 }*/
                 else if (flags &amp; SWS_X) {
@@ -510,7 +505,7 @@
     return ret;
 }
 
-#if ARCH_X86 &amp;&amp; (HAVE_MMX2 || CONFIG_RUNTIME_CPUDETECT) &amp;&amp; CONFIG_GPL
+#if ARCH_X86 &amp;&amp; (HAVE_MMX2 || CONFIG_RUNTIME_CPUDETECT)
 static int initMMX2HScaler(int dstW, int xInc, uint8_t *filterCode, int16_t *filter, int32_t *filterPos, int numSplits)
 {
     uint8_t *fragmentA;
@@ -668,7 +663,7 @@
 
     return fragmentPos + 1;
 }
-#endif /* ARCH_X86 &amp;&amp; (HAVE_MMX2 || CONFIG_RUNTIME_CPUDETECT) &amp;&amp; CONFIG_GPL */
+#endif /* ARCH_X86 &amp;&amp; (HAVE_MMX2 || CONFIG_RUNTIME_CPUDETECT) */
 
 static void getSubSampleFactors(int *h, int *v, enum PixelFormat format)
 {
@@ -676,23 +671,8 @@
     *v = av_pix_fmt_descriptors[format].log2_chroma_h;
 }
 
-static uint16_t roundToInt16(int64_t f)
-{
-    int r= (f + (1&lt;&lt;15))&gt;&gt;16;
-         if (r&lt;-0x7FFF) return 0x8000;
-    else if (r&gt; 0x7FFF) return 0x7FFF;
-    else                return r;
-}
-
 int sws_setColorspaceDetails(SwsContext *c, const int inv_table[4], int srcRange, const int table[4], int dstRange, int brightness, int contrast, int saturation)
 {
-    int64_t crv =  inv_table[0];
-    int64_t cbu =  inv_table[1];
-    int64_t cgu = -inv_table[2];
-    int64_t cgv = -inv_table[3];
-    int64_t cy  = 1&lt;&lt;16;
-    int64_t oy  = 0;
-
     memcpy(c-&gt;srcColorspaceTable, inv_table, sizeof(int)*4);
     memcpy(c-&gt;dstColorspaceTable,     table, sizeof(int)*4);
 
@@ -703,45 +683,10 @@
     c-&gt;dstRange  = dstRange;
     if (isYUV(c-&gt;dstFormat) || isGray(c-&gt;dstFormat)) return -1;
 
-    c-&gt;uOffset=   0x0400040004000400LL;
-    c-&gt;vOffset=   0x0400040004000400LL;
-
-    if (!srcRange) {
-        cy= (cy*255) / 219;
-        oy= 16&lt;&lt;16;
-    } else {
-        crv= (crv*224) / 255;
-        cbu= (cbu*224) / 255;
-        cgu= (cgu*224) / 255;
-        cgv= (cgv*224) / 255;
-    }
-
-    cy = (cy *contrast             )&gt;&gt;16;
-    crv= (crv*contrast * saturation)&gt;&gt;32;
-    cbu= (cbu*contrast * saturation)&gt;&gt;32;
-    cgu= (cgu*contrast * saturation)&gt;&gt;32;
-    cgv= (cgv*contrast * saturation)&gt;&gt;32;
-
-    oy -= 256*brightness;
-
-    c-&gt;yCoeff=    roundToInt16(cy *8192) * 0x0001000100010001ULL;
-    c-&gt;vrCoeff=   roundToInt16(crv*8192) * 0x0001000100010001ULL;
-    c-&gt;ubCoeff=   roundToInt16(cbu*8192) * 0x0001000100010001ULL;
-    c-&gt;vgCoeff=   roundToInt16(cgv*8192) * 0x0001000100010001ULL;
-    c-&gt;ugCoeff=   roundToInt16(cgu*8192) * 0x0001000100010001ULL;
-    c-&gt;yOffset=   roundToInt16(oy *   8) * 0x0001000100010001ULL;
-
-    c-&gt;yuv2rgb_y_coeff  = (int16_t)roundToInt16(cy &lt;&lt;13);
-    c-&gt;yuv2rgb_y_offset = (int16_t)roundToInt16(oy &lt;&lt; 9);
-    c-&gt;yuv2rgb_v2r_coeff= (int16_t)roundToInt16(crv&lt;&lt;13);
-    c-&gt;yuv2rgb_v2g_coeff= (int16_t)roundToInt16(cgv&lt;&lt;13);
-    c-&gt;yuv2rgb_u2g_coeff= (int16_t)roundToInt16(cgu&lt;&lt;13);
-    c-&gt;yuv2rgb_u2b_coeff= (int16_t)roundToInt16(cbu&lt;&lt;13);
-
     ff_yuv2rgb_c_init_tables(c, inv_table, srcRange, brightness, contrast, saturation);
     //FIXME factorize
 
-#if ARCH_PPC &amp;&amp; (HAVE_ALTIVEC || CONFIG_RUNTIME_CPUDETECT)
+#if HAVE_ALTIVEC
     if (c-&gt;flags &amp; SWS_CPU_CAPS_ALTIVEC)
         ff_yuv2rgb_init_tables_altivec(c, inv_table, brightness, contrast, saturation);
 #endif
@@ -766,20 +711,11 @@
 static int handle_jpeg(enum PixelFormat *format)
 {
     switch (*format) {
-    case PIX_FMT_YUVJ420P:
-        *format = PIX_FMT_YUV420P;
-        return 1;
-    case PIX_FMT_YUVJ422P:
-        *format = PIX_FMT_YUV422P;
-        return 1;
-    case PIX_FMT_YUVJ444P:
-        *format = PIX_FMT_YUV444P;
-        return 1;
-    case PIX_FMT_YUVJ440P:
-        *format = PIX_FMT_YUV440P;
-        return 1;
-    default:
-        return 0;
+    case PIX_FMT_YUVJ420P: *format = PIX_FMT_YUV420P; return 1;
+    case PIX_FMT_YUVJ422P: *format = PIX_FMT_YUV422P; return 1;
+    case PIX_FMT_YUVJ444P: *format = PIX_FMT_YUV444P; return 1;
+    case PIX_FMT_YUVJ440P: *format = PIX_FMT_YUV440P; return 1;
+    default:                                          return 0;
     }
 }
 
@@ -787,7 +723,6 @@
                            int dstW, int dstH, enum PixelFormat dstFormat, int flags,
                            SwsFilter *srcFilter, SwsFilter *dstFilter, const double *param)
 {
-
     SwsContext *c;
     int i;
     int usesVFilter, usesHFilter;
@@ -954,7 +889,7 @@
 
     /* precalculate horizontal scaler filter coefficients */
     {
-#if ARCH_X86 &amp;&amp; (HAVE_MMX2 || CONFIG_RUNTIME_CPUDETECT) &amp;&amp; CONFIG_GPL
+#if ARCH_X86 &amp;&amp; (HAVE_MMX2 || CONFIG_RUNTIME_CPUDETECT)
 // can't downscale !!!
         if (c-&gt;canMMX2BeUsed &amp;&amp; (flags &amp; SWS_FAST_BILINEAR)) {
             c-&gt;lumMmx2FilterCodeSize = initMMX2HScaler(      dstW, c-&gt;lumXInc, NULL, NULL, NULL, 8);
@@ -971,6 +906,8 @@
             c-&gt;chrMmx2FilterCode = av_malloc(c-&gt;chrMmx2FilterCodeSize);
 #endif
 
+            if (!c-&gt;lumMmx2FilterCode || !c-&gt;chrMmx2FilterCode)
+                goto fail;
             FF_ALLOCZ_OR_GOTO(c, c-&gt;hLumFilter   , (dstW        /8+8)*sizeof(int16_t), fail);
             FF_ALLOCZ_OR_GOTO(c, c-&gt;hChrFilter   , (c-&gt;chrDstW  /4+8)*sizeof(int16_t), fail);
             FF_ALLOCZ_OR_GOTO(c, c-&gt;hLumFilterPos, (dstW      /2/8+8)*sizeof(int32_t), fail);
@@ -984,7 +921,7 @@
             mprotect(c-&gt;chrMmx2FilterCode, c-&gt;chrMmx2FilterCodeSize, PROT_EXEC | PROT_READ);
 #endif
         } else
-#endif /* ARCH_X86 &amp;&amp; (HAVE_MMX2 || CONFIG_RUNTIME_CPUDETECT) &amp;&amp; CONFIG_GPL */
+#endif /* ARCH_X86 &amp;&amp; (HAVE_MMX2 || CONFIG_RUNTIME_CPUDETECT) */
         {
             const int filterAlign=
                 (flags &amp; SWS_CPU_CAPS_MMX) ? 4 :
@@ -1022,7 +959,7 @@
                        srcFilter-&gt;chrV, dstFilter-&gt;chrV, c-&gt;param) &lt; 0)
             goto fail;
 
-#if ARCH_PPC &amp;&amp; (HAVE_ALTIVEC || CONFIG_RUNTIME_CPUDETECT)
+#if HAVE_ALTIVEC
         FF_ALLOC_OR_GOTO(c, c-&gt;vYCoeffsBank, sizeof (vector signed short)*c-&gt;vLumFilterSize*c-&gt;dstH, fail);
         FF_ALLOC_OR_GOTO(c, c-&gt;vCCoeffsBank, sizeof (vector signed short)*c-&gt;vChrFilterSize*c-&gt;chrDstH, fail);
 
@@ -1116,7 +1053,9 @@
         av_log(c, AV_LOG_INFO, &quot;from %s to %s%s &quot;,
                sws_format_name(srcFormat),
 #ifdef DITHER1XBPP
-               dstFormat == PIX_FMT_BGR555 || dstFormat == PIX_FMT_BGR565 ? &quot;dithered &quot; : &quot;&quot;,
+               dstFormat == PIX_FMT_BGR555 || dstFormat == PIX_FMT_BGR565 ||
+               dstFormat == PIX_FMT_RGB444BE || dstFormat == PIX_FMT_RGB444LE ||
+               dstFormat == PIX_FMT_BGR444BE || dstFormat == PIX_FMT_BGR444LE ? &quot;dithered &quot; : &quot;&quot;,
 #else
                &quot;&quot;,
 #endif
@@ -1185,6 +1124,9 @@
             av_log(c, AV_LOG_VERBOSE, &quot;using %s YV12-&gt;BGR16 converter\n&quot;, (flags &amp; SWS_CPU_CAPS_MMX) ? &quot;MMX&quot; : &quot;C&quot;);
         else if (dstFormat==PIX_FMT_BGR555)
             av_log(c, AV_LOG_VERBOSE, &quot;using %s YV12-&gt;BGR15 converter\n&quot;, (flags &amp; SWS_CPU_CAPS_MMX) ? &quot;MMX&quot; : &quot;C&quot;);
+        else if (dstFormat == PIX_FMT_RGB444BE || dstFormat == PIX_FMT_RGB444LE ||
+                 dstFormat == PIX_FMT_BGR444BE || dstFormat == PIX_FMT_BGR444LE)
+            av_log(c, AV_LOG_VERBOSE, &quot;using %s YV12-&gt;BGR12 converter\n&quot;, (flags &amp; SWS_CPU_CAPS_MMX) ? &quot;MMX&quot; : &quot;C&quot;);
 
         av_log(c, AV_LOG_VERBOSE, &quot;%dx%d -&gt; %dx%d\n&quot;, srcW, srcH, dstW, dstH);
         av_log(c, AV_LOG_DEBUG, &quot;lum srcW=%d srcH=%d dstW=%d dstH=%d xInc=%d yInc=%d\n&quot;,
@@ -1312,7 +1254,7 @@
     return sws_getConstVec(1.0, 1);
 }
 
-double sws_dcVec(SwsVector *a)
+static double sws_dcVec(SwsVector *a)
 {
     int i;
     double sum=0;
@@ -1526,7 +1468,7 @@
     av_freep(&amp;c-&gt;vChrFilter);
     av_freep(&amp;c-&gt;hLumFilter);
     av_freep(&amp;c-&gt;hChrFilter);
-#if ARCH_PPC &amp;&amp; (HAVE_ALTIVEC || CONFIG_RUNTIME_CPUDETECT)
+#if HAVE_ALTIVEC
     av_freep(&amp;c-&gt;vYCoeffsBank);
     av_freep(&amp;c-&gt;vCCoeffsBank);
 #endif
@@ -1536,20 +1478,20 @@
     av_freep(&amp;c-&gt;hLumFilterPos);
     av_freep(&amp;c-&gt;hChrFilterPos);
 
-#if ARCH_X86 &amp;&amp; CONFIG_GPL
+#if ARCH_X86
 #ifdef MAP_ANONYMOUS
     if (c-&gt;lumMmx2FilterCode) munmap(c-&gt;lumMmx2FilterCode, c-&gt;lumMmx2FilterCodeSize);
     if (c-&gt;chrMmx2FilterCode) munmap(c-&gt;chrMmx2FilterCode, c-&gt;chrMmx2FilterCodeSize);
 #elif HAVE_VIRTUALALLOC
-    if (c-&gt;lumMmx2FilterCode) VirtualFree(c-&gt;lumMmx2FilterCode, c-&gt;lumMmx2FilterCodeSize, MEM_RELEASE);
-    if (c-&gt;chrMmx2FilterCode) VirtualFree(c-&gt;chrMmx2FilterCode, c-&gt;chrMmx2FilterCodeSize, MEM_RELEASE);
+    if (c-&gt;lumMmx2FilterCode) VirtualFree(c-&gt;lumMmx2FilterCode, 0, MEM_RELEASE);
+    if (c-&gt;chrMmx2FilterCode) VirtualFree(c-&gt;chrMmx2FilterCode, 0, MEM_RELEASE);
 #else
     av_free(c-&gt;lumMmx2FilterCode);
     av_free(c-&gt;chrMmx2FilterCode);
 #endif
     c-&gt;lumMmx2FilterCode=NULL;
     c-&gt;chrMmx2FilterCode=NULL;
-#endif /* ARCH_X86 &amp;&amp; CONFIG_GPL */
+#endif /* ARCH_X86 */
 
     av_freep(&amp;c-&gt;yuvTable);
 

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/x86/yuv2rgb_mmx.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/x86/yuv2rgb_mmx.c	2010-07-25 10:07:46 UTC (rev 6481)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/x86/yuv2rgb_mmx.c	2010-07-25 10:07:49 UTC (rev 6482)
@@ -41,6 +41,9 @@
 DECLARE_ASM_CONST(8, uint64_t, mmx_00ffw)   = 0x00ff00ff00ff00ffULL;
 DECLARE_ASM_CONST(8, uint64_t, mmx_redmask) = 0xf8f8f8f8f8f8f8f8ULL;
 DECLARE_ASM_CONST(8, uint64_t, mmx_grnmask) = 0xfcfcfcfcfcfcfcfcULL;
+DECLARE_ASM_CONST(8, uint64_t, pb_e0) = 0xe0e0e0e0e0e0e0e0ULL;
+DECLARE_ASM_CONST(8, uint64_t, pb_03) = 0x0303030303030303ULL;
+DECLARE_ASM_CONST(8, uint64_t, pb_07) = 0x0707070707070707ULL;
 
 //MMX versions
 #undef RENAME

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/x86/yuv2rgb_template.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/x86/yuv2rgb_template.c	2010-07-25 10:07:46 UTC (rev 6481)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/x86/yuv2rgb_template.c	2010-07-25 10:07:49 UTC (rev 6482)
@@ -1,28 +1,23 @@
 /*
- * yuv2rgb_mmx.c, software YUV to RGB converter with Intel MMX &quot;technology&quot;
+ * software YUV to RGB converter
  *
- * Copyright (C) 2000, Silicon Integrated System Corp
+ * Copyright (C) 2001-2007 Michael Niedermayer
+ *           (c) 2010 Konstantin Shishkov
  *
- * Author: Olie Lho &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">ollie at sis.com.tw</A>&gt;
+ * This file is part of FFmpeg.
  *
- * 15,24 bpp and dithering from Michael Niedermayer (<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">michaelni at gmx.at</A>)
- * MMX/MMX2 Template stuff from Michael Niedermayer (needed for fast movntq support)
- * context / deglobalize stuff by Michael Niedermayer
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
  *
- * This file is part of mpeg2dec, a free MPEG-2 video decoder
- *
- * mpeg2dec is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
- *
- * mpeg2dec is distributed in the hope that it will be useful,
+ * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
  *
- * You should have received a copy of the GNU General Public License
- * along with mpeg2dec; if not, write to the Free Software
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
@@ -32,9 +27,9 @@
 
 #if HAVE_AMD3DNOW
 /* On K6 femms is faster than emms. On K7 femms is directly mapped to emms. */
-#define EMMS     &quot;femms&quot;
+#define EMMS   &quot;femms&quot;
 #else
-#define EMMS     &quot;emms&quot;
+#define EMMS   &quot;emms&quot;
 #endif
 
 #if HAVE_MMX2
@@ -45,520 +40,414 @@
 #define SFENCE &quot; # nop&quot;
 #endif
 
-#define YUV2RGB \
-    /* Do the multiply part of the conversion for even and odd pixels,
-       register usage:
-       mm0 -&gt; Cblue, mm1 -&gt; Cred, mm2 -&gt; Cgreen even pixels,
-       mm3 -&gt; Cblue, mm4 -&gt; Cred, mm5 -&gt; Cgreen odd pixels,
-       mm6 -&gt; Y even, mm7 -&gt; Y odd */\
-    /* convert the chroma part */\
-    &quot;punpcklbw %%mm4, %%mm0;&quot; /* scatter 4 Cb 00 u3 00 u2 00 u1 00 u0 */ \
-    &quot;punpcklbw %%mm4, %%mm1;&quot; /* scatter 4 Cr 00 v3 00 v2 00 v1 00 v0 */ \
+#define REG_BLUE  &quot;0&quot;
+#define REG_RED   &quot;1&quot;
+#define REG_GREEN &quot;2&quot;
+#define REG_ALPHA &quot;3&quot;
+
+#define YUV2RGB_LOOP(depth)                                          \
+    h_size = (c-&gt;dstW + 7) &amp; ~7;                                     \
+    if (h_size * depth &gt; FFABS(dstStride[0]))                        \
+        h_size -= 8;                                                 \
+                                                                     \
+    if (c-&gt;srcFormat == PIX_FMT_YUV422P) {                           \
+        srcStride[1] *= 2;                                           \
+        srcStride[2] *= 2;                                           \
+    }                                                                \
+                                                                     \
+    __asm__ volatile (&quot;pxor %mm4, %mm4\n\t&quot;);                        \
+    for (y = 0; y &lt; srcSliceH; y++) {                                \
+        uint8_t *image    = dst[0] + (y + srcSliceY) * dstStride[0]; \
+        const uint8_t *py = src[0] +               y * srcStride[0]; \
+        const uint8_t *pu = src[1] +        (y &gt;&gt; 1) * srcStride[1]; \
+        const uint8_t *pv = src[2] +        (y &gt;&gt; 1) * srcStride[2]; \
+        x86_reg index = -h_size / 2;                                 \
+
+#define YUV2RGB_INITIAL_LOAD          \
+    __asm__ volatile (                \
+        &quot;movq (%5, %0, 2), %%mm6\n\t&quot; \
+        &quot;movd    (%2, %0), %%mm0\n\t&quot; \
+        &quot;movd    (%3, %0), %%mm1\n\t&quot; \
+        &quot;1: \n\t&quot;                     \
+
+/* YUV2RGB core
+ * Conversion is performed in usual way:
+ * R = Y' * Ycoef + Vred * V'
+ * G = Y' * Ycoef + Vgreen * V' + Ugreen * U'
+ * B = Y' * Ycoef               + Ublue * U'
+ *
+ * where X' = X * 8 - Xoffset (multiplication is performed to increase
+ * precision a bit).
+ * Since it operates in YUV420 colorspace, Y component is additionally
+ * split into Y1 and Y2 for even and odd pixels.
+ *
+ * Input:
+ * mm0 - U (4 elems), mm1 - V (4 elems), mm6 - Y (8 elems), mm4 - zero register
+ * Output:
+ * mm1 - R, mm2 - G, mm0 - B
+ */
+#define YUV2RGB                                  \
+    /* convert Y, U, V into Y1', Y2', U', V' */  \
+    &quot;movq      %%mm6, %%mm7\n\t&quot;                 \
+    &quot;punpcklbw %%mm4, %%mm0\n\t&quot;                 \
+    &quot;punpcklbw %%mm4, %%mm1\n\t&quot;                 \
+    &quot;pand     &quot;MANGLE(mmx_00ffw)&quot;, %%mm6\n\t&quot;    \
+    &quot;psrlw     $8,    %%mm7\n\t&quot;                 \
+    &quot;psllw     $3,    %%mm0\n\t&quot;                 \
+    &quot;psllw     $3,    %%mm1\n\t&quot;                 \
+    &quot;psllw     $3,    %%mm6\n\t&quot;                 \
+    &quot;psllw     $3,    %%mm7\n\t&quot;                 \
+    &quot;psubsw   &quot;U_OFFSET&quot;(%4), %%mm0\n\t&quot;         \
+    &quot;psubsw   &quot;V_OFFSET&quot;(%4), %%mm1\n\t&quot;         \
+    &quot;psubw    &quot;Y_OFFSET&quot;(%4), %%mm6\n\t&quot;         \
+    &quot;psubw    &quot;Y_OFFSET&quot;(%4), %%mm7\n\t&quot;         \
 \
-    &quot;psllw $3, %%mm0;&quot; /* Promote precision */ \
-    &quot;psllw $3, %%mm1;&quot; /* Promote precision */ \
+     /* multiply by coefficients */              \
+    &quot;movq      %%mm0, %%mm2\n\t&quot;                 \
+    &quot;movq      %%mm1, %%mm3\n\t&quot;                 \
+    &quot;pmulhw   &quot;UG_COEFF&quot;(%4), %%mm2\n\t&quot;         \
+    &quot;pmulhw   &quot;VG_COEFF&quot;(%4), %%mm3\n\t&quot;         \
+    &quot;pmulhw   &quot;Y_COEFF&quot; (%4), %%mm6\n\t&quot;         \
+    &quot;pmulhw   &quot;Y_COEFF&quot; (%4), %%mm7\n\t&quot;         \
+    &quot;pmulhw   &quot;UB_COEFF&quot;(%4), %%mm0\n\t&quot;         \
+    &quot;pmulhw   &quot;VR_COEFF&quot;(%4), %%mm1\n\t&quot;         \
+    &quot;paddsw    %%mm3, %%mm2\n\t&quot;                 \
+    /* now: mm0 = UB, mm1 = VR, mm2 = CG */      \
+    /*      mm6 = Y1, mm7 = Y2 */                \
 \
-    &quot;psubsw &quot;U_OFFSET&quot;(%4), %%mm0;&quot; /* Cb -= 128 */ \
-    &quot;psubsw &quot;V_OFFSET&quot;(%4), %%mm1;&quot; /* Cr -= 128 */ \
-\
-    &quot;movq %%mm0, %%mm2;&quot; /* Copy 4 Cb 00 u3 00 u2 00 u1 00 u0 */ \
-    &quot;movq %%mm1, %%mm3;&quot; /* Copy 4 Cr 00 v3 00 v2 00 v1 00 v0 */ \
-\
-    &quot;pmulhw &quot;UG_COEFF&quot;(%4), %%mm2;&quot; /* Mul Cb with green coeff -&gt; Cb green */ \
-    &quot;pmulhw &quot;VG_COEFF&quot;(%4), %%mm3;&quot; /* Mul Cr with green coeff -&gt; Cr green */ \
-\
-    &quot;pmulhw &quot;UB_COEFF&quot;(%4), %%mm0;&quot; /* Mul Cb -&gt; Cblue 00 b3 00 b2 00 b1 00 b0 */\
-    &quot;pmulhw &quot;VR_COEFF&quot;(%4), %%mm1;&quot; /* Mul Cr -&gt; Cred 00 r3 00 r2 00 r1 00 r0 */\
-\
-    &quot;paddsw %%mm3, %%mm2;&quot; /* Cb green + Cr green -&gt; Cgreen */\
-\
-    /* convert the luma part */\
-    &quot;movq %%mm6, %%mm7;&quot; /* Copy 8 Y Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 */\
-    &quot;pand &quot;MANGLE(mmx_00ffw)&quot;, %%mm6;&quot; /* get Y even 00 Y6 00 Y4 00 Y2 00 Y0 */\
-\
-    &quot;psrlw $8, %%mm7;&quot; /* get Y odd 00 Y7 00 Y5 00 Y3 00 Y1 */\
-\
-    &quot;psllw $3, %%mm6;&quot; /* Promote precision */\
-    &quot;psllw $3, %%mm7;&quot; /* Promote precision */\
-\
-    &quot;psubw &quot;Y_OFFSET&quot;(%4), %%mm6;&quot; /* Y -= 16 */\
-    &quot;psubw &quot;Y_OFFSET&quot;(%4), %%mm7;&quot; /* Y -= 16 */\
-\
-    &quot;pmulhw &quot;Y_COEFF&quot;(%4), %%mm6;&quot; /* Mul 4 Y even 00 y6 00 y4 00 y2 00 y0 */\
-    &quot;pmulhw &quot;Y_COEFF&quot;(%4), %%mm7;&quot; /* Mul 4 Y odd 00 y7 00 y5 00 y3 00 y1 */\
-\
-    /* Do the addition part of the conversion for even and odd pixels,
-       register usage:
-       mm0 -&gt; Cblue, mm1 -&gt; Cred, mm2 -&gt; Cgreen even pixels,
-       mm3 -&gt; Cblue, mm4 -&gt; Cred, mm5 -&gt; Cgreen odd pixels,
-       mm6 -&gt; Y even, mm7 -&gt; Y odd */\
-    &quot;movq %%mm0, %%mm3;&quot; /* Copy Cblue */\
-    &quot;movq %%mm1, %%mm4;&quot; /* Copy Cred */\
-    &quot;movq %%mm2, %%mm5;&quot; /* Copy Cgreen */\
-\
-    &quot;paddsw %%mm6, %%mm0;&quot; /* Y even + Cblue 00 B6 00 B4 00 B2 00 B0 */\
-    &quot;paddsw %%mm7, %%mm3;&quot; /* Y odd + Cblue 00 B7 00 B5 00 B3 00 B1 */\
-\
-    &quot;paddsw %%mm6, %%mm1;&quot; /* Y even + Cred 00 R6 00 R4 00 R2 00 R0 */\
-    &quot;paddsw %%mm7, %%mm4;&quot; /* Y odd + Cred 00 R7 00 R5 00 R3 00 R1 */\
-\
-    &quot;paddsw %%mm6, %%mm2;&quot; /* Y even + Cgreen 00 G6 00 G4 00 G2 00 G0 */\
-    &quot;paddsw %%mm7, %%mm5;&quot; /* Y odd + Cgreen 00 G7 00 G5 00 G3 00 G1 */\
-\
-    /* Limit RGB even to 0..255 */\
-    &quot;packuswb %%mm0, %%mm0;&quot; /* B6 B4 B2 B0  B6 B4 B2 B0 */\
-    &quot;packuswb %%mm1, %%mm1;&quot; /* R6 R4 R2 R0  R6 R4 R2 R0 */\
-    &quot;packuswb %%mm2, %%mm2;&quot; /* G6 G4 G2 G0  G6 G4 G2 G0 */\
-\
-    /* Limit RGB odd to 0..255 */\
-    &quot;packuswb %%mm3, %%mm3;&quot; /* B7 B5 B3 B1  B7 B5 B3 B1 */\
-    &quot;packuswb %%mm4, %%mm4;&quot; /* R7 R5 R3 R1  R7 R5 R3 R1 */\
-    &quot;packuswb %%mm5, %%mm5;&quot; /* G7 G5 G3 G1  G7 G5 G3 G1 */\
-\
-    /* Interleave RGB even and odd */\
-    &quot;punpcklbw %%mm3, %%mm0;&quot; /* B7 B6 B5 B4 B3 B2 B1 B0 */\
-    &quot;punpcklbw %%mm4, %%mm1;&quot; /* R7 R6 R5 R4 R3 R2 R1 R0 */\
-    &quot;punpcklbw %%mm5, %%mm2;&quot; /* G7 G6 G5 G4 G3 G2 G1 G0 */\
+    /* produce RGB */                            \
+    &quot;movq      %%mm7, %%mm3\n\t&quot;                 \
+    &quot;movq      %%mm7, %%mm5\n\t&quot;                 \
+    &quot;paddsw    %%mm0, %%mm3\n\t&quot;                 \
+    &quot;paddsw    %%mm1, %%mm5\n\t&quot;                 \
+    &quot;paddsw    %%mm2, %%mm7\n\t&quot;                 \
+    &quot;paddsw    %%mm6, %%mm0\n\t&quot;                 \
+    &quot;paddsw    %%mm6, %%mm1\n\t&quot;                 \
+    &quot;paddsw    %%mm6, %%mm2\n\t&quot;                 \
 
+#define RGB_PACK_INTERLEAVE                  \
+    /* pack and interleave even/odd pixels */    \
+    &quot;packuswb  %%mm1, %%mm0\n\t&quot;                 \
+    &quot;packuswb  %%mm5, %%mm3\n\t&quot;                 \
+    &quot;packuswb  %%mm2, %%mm2\n\t&quot;                 \
+    &quot;movq      %%mm0, %%mm1\n\n&quot;                 \
+    &quot;packuswb  %%mm7, %%mm7\n\t&quot;                 \
+    &quot;punpcklbw %%mm3, %%mm0\n\t&quot;                 \
+    &quot;punpckhbw %%mm3, %%mm1\n\t&quot;                 \
+    &quot;punpcklbw %%mm7, %%mm2\n\t&quot;                 \
 
-#define YUV422_UNSHIFT                   \
-    if(c-&gt;srcFormat == PIX_FMT_YUV422P) {\
-        srcStride[1] *= 2;               \
-        srcStride[2] *= 2;               \
-    }                                    \
+#define YUV2RGB_ENDLOOP(depth)                   \
+    &quot;movq 8 (%5, %0, 2), %%mm6\n\t&quot;              \
+    &quot;movd 4 (%3, %0),    %%mm1\n\t&quot;              \
+    &quot;movd 4 (%2, %0),    %%mm0\n\t&quot;              \
+    &quot;add $&quot;AV_STRINGIFY(depth * 8)&quot;, %1\n\t&quot;     \
+    &quot;add  $4, %0\n\t&quot;                            \
+    &quot;js   1b\n\t&quot;                                \
 
-#define YUV2RGB_LOOP(depth)                                   \
-    h_size= (c-&gt;dstW+7)&amp;~7;                                   \
-    if(h_size*depth &gt; FFABS(dstStride[0])) h_size-=8;         \
-\
-    __asm__ volatile (&quot;pxor %mm4, %mm4;&quot; /* zero mm4 */ );    \
-    for (y= 0; y&lt;srcSliceH; y++ ) {                           \
-        uint8_t *image = dst[0] + (y+srcSliceY)*dstStride[0]; \
-        const uint8_t *py = src[0] + y*srcStride[0];          \
-        const uint8_t *pu = src[1] + (y&gt;&gt;1)*srcStride[1];     \
-        const uint8_t *pv = src[2] + (y&gt;&gt;1)*srcStride[2];     \
-        x86_reg index= -h_size/2;                                \
+#define YUV2RGB_OPERANDS                                          \
+        : &quot;+r&quot; (index), &quot;+r&quot; (image)                              \
+        : &quot;r&quot; (pu - index), &quot;r&quot; (pv - index), &quot;r&quot;(&amp;c-&gt;redDither), \
+          &quot;r&quot; (py - 2*index)                                      \
+        );                                                        \
+    }                                                             \
 
-#define YUV2RGB_INIT                                                       \
-        /* This MMX assembly code deals with a SINGLE scan line at a time, \
-         * it converts 8 pixels in each iteration. */                      \
-        __asm__ volatile (                                                 \
-        /* load data for start of next scan line */                        \
-        &quot;movd    (%2, %0), %%mm0;&quot; /* Load 4 Cb 00 00 00 00 u3 u2 u1 u0 */ \
-        &quot;movd    (%3, %0), %%mm1;&quot; /* Load 4 Cr 00 00 00 00 v3 v2 v1 v0 */ \
-        &quot;movq (%5, %0, 2), %%mm6;&quot; /* Load 8  Y Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 */ \
-        /*                                                                 \
-        &quot;.balign 16     \n\t&quot;                                              \
-        */                                                                 \
-        &quot;1:             \n\t&quot;                                              \
-        /* No speed difference on my <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">p3 at 500</A> with prefetch,                 \
-         * if it is faster for anyone with -benchmark then tell me.        \
-        PREFETCH&quot; 64(%0) \n\t&quot;                                             \
-        PREFETCH&quot; 64(%1) \n\t&quot;                                             \
-        PREFETCH&quot; 64(%2) \n\t&quot;                                             \
-        */                                                                 \
+#define YUV2RGB_OPERANDS_ALPHA                                    \
+        : &quot;+r&quot; (index), &quot;+r&quot; (image)                              \
+        : &quot;r&quot; (pu - index), &quot;r&quot; (pv - index), &quot;r&quot;(&amp;c-&gt;redDither), \
+          &quot;r&quot; (py - 2*index), &quot;r&quot; (pa - 2*index)                  \
+        );                                                        \
+    }                                                             \
 
-#define YUV2RGB_ENDLOOP(depth) \
-        &quot;add $&quot;AV_STRINGIFY(depth*8)&quot;, %1    \n\t&quot; \
-        &quot;add                       $4, %0    \n\t&quot; \
-        &quot; js                       1b        \n\t&quot; \
+#define YUV2RGB_ENDFUNC                          \
+    __asm__ volatile (SFENCE&quot;\n\t&quot;EMMS);         \
+    return srcSliceH;                            \
 
-#define YUV2RGB_OPERANDS \
-        : &quot;+r&quot; (index), &quot;+r&quot; (image) \
-        : &quot;r&quot; (pu - index), &quot;r&quot; (pv - index), &quot;r&quot;(&amp;c-&gt;redDither), &quot;r&quot; (py - 2*index) \
-        ); \
-    } \
-    __asm__ volatile (SFENCE&quot;\n\t&quot;EMMS); \
-    return srcSliceH; \
+#define IF0(x)
+#define IF1(x) x
 
-#define YUV2RGB_OPERANDS_ALPHA \
-        : &quot;+r&quot; (index), &quot;+r&quot; (image) \
-        : &quot;r&quot; (pu - index), &quot;r&quot; (pv - index), &quot;r&quot;(&amp;c-&gt;redDither), &quot;r&quot; (py - 2*index), &quot;r&quot; (pa - 2*index) \
-        ); \
-    } \
-    __asm__ volatile (SFENCE&quot;\n\t&quot;EMMS); \
-    return srcSliceH; \
+#define RGB_PACK16(gmask, is15)                  \
+    &quot;pand      &quot;MANGLE(mmx_redmask)&quot;, %%mm0\n\t&quot; \
+    &quot;pand      &quot;MANGLE(mmx_redmask)&quot;, %%mm1\n\t&quot; \
+    &quot;movq      %%mm2,     %%mm3\n\t&quot;             \
+    &quot;psllw   $&quot;AV_STRINGIFY(3-is15)&quot;, %%mm2\n\t&quot; \
+    &quot;psrlw   $&quot;AV_STRINGIFY(5+is15)&quot;, %%mm3\n\t&quot; \
+    &quot;psrlw     $3,        %%mm0\n\t&quot;             \
+    IF##is15(&quot;psrlw  $1,  %%mm1\n\t&quot;)            \
+    &quot;pand &quot;MANGLE(pb_e0)&quot;, %%mm2\n\t&quot;            \
+    &quot;pand &quot;MANGLE(gmask)&quot;, %%mm3\n\t&quot;            \
+    &quot;por       %%mm2,     %%mm0\n\t&quot;             \
+    &quot;por       %%mm3,     %%mm1\n\t&quot;             \
+    &quot;movq      %%mm0,     %%mm2\n\t&quot;             \
+    &quot;punpcklbw %%mm1,     %%mm0\n\t&quot;             \
+    &quot;punpckhbw %%mm1,     %%mm2\n\t&quot;             \
+    MOVNTQ &quot;   %%mm0,      (%1)\n\t&quot;             \
+    MOVNTQ &quot;   %%mm2,     8(%1)\n\t&quot;             \
 
-static inline int RENAME(yuv420_rgb16)(SwsContext *c, const uint8_t* src[], int srcStride[], int srcSliceY,
-                                       int srcSliceH, uint8_t* dst[], int dstStride[])
+#define DITHER_RGB                               \
+    &quot;paddusb &quot;BLUE_DITHER&quot;(%4),  %%mm0\n\t&quot;      \
+    &quot;paddusb &quot;GREEN_DITHER&quot;(%4), %%mm2\n\t&quot;      \
+    &quot;paddusb &quot;RED_DITHER&quot;(%4),   %%mm1\n\t&quot;      \
+
+static inline int RENAME(yuv420_rgb15)(SwsContext *c, const uint8_t *src[],
+                                       int srcStride[],
+                                       int srcSliceY, int srcSliceH,
+                                       uint8_t *dst[], int dstStride[])
 {
     int y, h_size;
 
-    YUV422_UNSHIFT
     YUV2RGB_LOOP(2)
 
-        c-&gt;blueDither= ff_dither8[y&amp;1];
-        c-&gt;greenDither= ff_dither4[y&amp;1];
-        c-&gt;redDither= ff_dither8[(y+1)&amp;1];
+#ifdef DITHER1XBPP
+        c-&gt;blueDither  = ff_dither8[y       &amp; 1];
+        c-&gt;greenDither = ff_dither8[y       &amp; 1];
+        c-&gt;redDither   = ff_dither8[(y + 1) &amp; 1];
+#endif
 
-        YUV2RGB_INIT
+        YUV2RGB_INITIAL_LOAD
         YUV2RGB
-
+        RGB_PACK_INTERLEAVE
 #ifdef DITHER1XBPP
-        &quot;paddusb &quot;BLUE_DITHER&quot;(%4), %%mm0;&quot;
-        &quot;paddusb &quot;GREEN_DITHER&quot;(%4), %%mm2;&quot;
-        &quot;paddusb &quot;RED_DITHER&quot;(%4), %%mm1;&quot;
+        DITHER_RGB
 #endif
-        /* mask unneeded bits off */
-        &quot;pand &quot;MANGLE(mmx_redmask)&quot;, %%mm0;&quot; /* b7b6b5b4 b3_0_0_0 b7b6b5b4 b3_0_0_0 */
-        &quot;pand &quot;MANGLE(mmx_grnmask)&quot;, %%mm2;&quot; /* g7g6g5g4 g3g2_0_0 g7g6g5g4 g3g2_0_0 */
-        &quot;pand &quot;MANGLE(mmx_redmask)&quot;, %%mm1;&quot; /* r7r6r5r4 r3_0_0_0 r7r6r5r4 r3_0_0_0 */
+        RGB_PACK16(pb_03, 1)
 
-        &quot;psrlw   $3, %%mm0;&quot; /* 0_0_0_b7 b6b5b4b3 0_0_0_b7 b6b5b4b3 */
-        &quot;pxor %%mm4, %%mm4;&quot; /* zero mm4 */
-
-        &quot;movq %%mm0, %%mm5;&quot; /* Copy B7-B0 */
-        &quot;movq %%mm2, %%mm7;&quot; /* Copy G7-G0 */
-
-        /* convert RGB24 plane to RGB16 pack for pixel 0-3 */
-        &quot;punpcklbw %%mm4, %%mm2;&quot; /* 0_0_0_0 0_0_0_0 g7g6g5g4 g3g2_0_0 */
-        &quot;punpcklbw %%mm1, %%mm0;&quot; /* r7r6r5r4 r3_0_0_0 0_0_0_b7 b6b5b4b3 */
-
-        &quot;psllw  $3, %%mm2;&quot; /* 0_0_0_0 0_g7g6g5 g4g3g2_0 0_0_0_0 */
-        &quot;por %%mm2, %%mm0;&quot; /* r7r6r5r4 r3g7g6g5 g4g3g2b7 b6b5b4b3 */
-
-        &quot;movq 8 (%5, %0, 2), %%mm6;&quot; /* Load 8 Y Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 */
-        MOVNTQ &quot;      %%mm0, (%1);&quot; /* store pixel 0-3 */
-
-        /* convert RGB24 plane to RGB16 pack for pixel 0-3 */
-        &quot;punpckhbw %%mm4, %%mm7;&quot; /* 0_0_0_0 0_0_0_0 g7g6g5g4 g3g2_0_0 */
-        &quot;punpckhbw %%mm1, %%mm5;&quot; /* r7r6r5r4 r3_0_0_0 0_0_0_b7 b6b5b4b3 */
-
-        &quot;psllw        $3, %%mm7;&quot; /* 0_0_0_0 0_g7g6g5 g4g3g2_0 0_0_0_0 */
-        &quot;movd 4 (%2, %0), %%mm0;&quot; /* Load 4 Cb 00 00 00 00 u3 u2 u1 u0 */
-
-        &quot;por       %%mm7, %%mm5;&quot; /* r7r6r5r4 r3g7g6g5 g4g3g2b7 b6b5b4b3 */
-        &quot;movd 4 (%3, %0), %%mm1;&quot; /* Load 4 Cr 00 00 00 00 v3 v2 v1 v0 */
-
-        MOVNTQ &quot;   %%mm5, 8 (%1);&quot; /* store pixel 4-7 */
-
     YUV2RGB_ENDLOOP(2)
     YUV2RGB_OPERANDS
+    YUV2RGB_ENDFUNC
 }
 
-static inline int RENAME(yuv420_rgb15)(SwsContext *c, const uint8_t* src[], int srcStride[], int srcSliceY,
-                                       int srcSliceH, uint8_t* dst[], int dstStride[])
+static inline int RENAME(yuv420_rgb16)(SwsContext *c, const uint8_t *src[],
+                                       int srcStride[],
+                                       int srcSliceY, int srcSliceH,
+                                       uint8_t *dst[], int dstStride[])
 {
     int y, h_size;
 
-    YUV422_UNSHIFT
     YUV2RGB_LOOP(2)
 
-        c-&gt;blueDither= ff_dither8[y&amp;1];
-        c-&gt;greenDither= ff_dither8[y&amp;1];
-        c-&gt;redDither= ff_dither8[(y+1)&amp;1];
+#ifdef DITHER1XBPP
+        c-&gt;blueDither  = ff_dither8[y       &amp; 1];
+        c-&gt;greenDither = ff_dither4[y       &amp; 1];
+        c-&gt;redDither   = ff_dither8[(y + 1) &amp; 1];
+#endif
 
-        YUV2RGB_INIT
+        YUV2RGB_INITIAL_LOAD
         YUV2RGB
-
+        RGB_PACK_INTERLEAVE
 #ifdef DITHER1XBPP
-        &quot;paddusb &quot;BLUE_DITHER&quot;(%4), %%mm0  \n\t&quot;
-        &quot;paddusb &quot;GREEN_DITHER&quot;(%4), %%mm2  \n\t&quot;
-        &quot;paddusb &quot;RED_DITHER&quot;(%4), %%mm1  \n\t&quot;
+        DITHER_RGB
 #endif
+        RGB_PACK16(pb_07, 0)
 
-        /* mask unneeded bits off */
-        &quot;pand &quot;MANGLE(mmx_redmask)&quot;, %%mm0;&quot; /* b7b6b5b4 b3_0_0_0 b7b6b5b4 b3_0_0_0 */
-        &quot;pand &quot;MANGLE(mmx_redmask)&quot;, %%mm2;&quot; /* g7g6g5g4 g3_0_0_0 g7g6g5g4 g3_0_0_0 */
-        &quot;pand &quot;MANGLE(mmx_redmask)&quot;, %%mm1;&quot; /* r7r6r5r4 r3_0_0_0 r7r6r5r4 r3_0_0_0 */
-
-        &quot;psrlw   $3, %%mm0;&quot; /* 0_0_0_b7 b6b5b4b3 0_0_0_b7 b6b5b4b3 */
-        &quot;psrlw   $1, %%mm1;&quot; /* 0_r7r6r5  r4r3_0_0 0_r7r6r5 r4r3_0_0 */
-        &quot;pxor %%mm4, %%mm4;&quot; /* zero mm4 */
-
-        &quot;movq %%mm0, %%mm5;&quot; /* Copy B7-B0 */
-        &quot;movq %%mm2, %%mm7;&quot; /* Copy G7-G0 */
-
-        /* convert RGB24 plane to RGB16 pack for pixel 0-3 */
-        &quot;punpcklbw %%mm4, %%mm2;&quot; /* 0_0_0_0 0_0_0_0 g7g6g5g4 g3_0_0_0 */
-        &quot;punpcklbw %%mm1, %%mm0;&quot; /* r7r6r5r4 r3_0_0_0 0_0_0_b7 b6b5b4b3 */
-
-        &quot;psllw  $2, %%mm2;&quot; /* 0_0_0_0 0_0_g7g6 g5g4g3_0 0_0_0_0 */
-        &quot;por %%mm2, %%mm0;&quot; /* 0_r7r6r5 r4r3g7g6 g5g4g3b7 b6b5b4b3 */
-
-        &quot;movq 8 (%5, %0, 2), %%mm6;&quot; /* Load 8 Y Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 */
-        MOVNTQ &quot;      %%mm0, (%1);&quot;  /* store pixel 0-3 */
-
-        /* convert RGB24 plane to RGB16 pack for pixel 0-3 */
-        &quot;punpckhbw %%mm4, %%mm7;&quot; /* 0_0_0_0 0_0_0_0 0_g7g6g5 g4g3_0_0 */
-        &quot;punpckhbw %%mm1, %%mm5;&quot; /* r7r6r5r4 r3_0_0_0 0_0_0_b7 b6b5b4b3 */
-
-        &quot;psllw        $2, %%mm7;&quot; /* 0_0_0_0 0_0_g7g6 g5g4g3_0 0_0_0_0 */
-        &quot;movd 4 (%2, %0), %%mm0;&quot; /* Load 4 Cb 00 00 00 00 u3 u2 u1 u0 */
-
-        &quot;por       %%mm7, %%mm5;&quot; /* 0_r7r6r5 r4r3g7g6 g5g4g3b7 b6b5b4b3 */
-        &quot;movd 4 (%3, %0), %%mm1;&quot; /* Load 4 Cr 00 00 00 00 v3 v2 v1 v0 */
-
-        MOVNTQ &quot; %%mm5, 8 (%1);&quot; /* store pixel 4-7 */
-
     YUV2RGB_ENDLOOP(2)
     YUV2RGB_OPERANDS
+    YUV2RGB_ENDFUNC
 }
 
-#undef RGB_PLANAR2PACKED24
+#define RGB_PACK24(blue, red)\
+    &quot;packuswb  %%mm3,      %%mm0 \n&quot; /* R0 R2 R4 R6 R1 R3 R5 R7 */\
+    &quot;packuswb  %%mm5,      %%mm1 \n&quot; /* B0 B2 B4 B6 B1 B3 B5 B7 */\
+    &quot;packuswb  %%mm7,      %%mm2 \n&quot; /* G0 G2 G4 G6 G1 G3 G5 G7 */\
+    &quot;movq      %%mm&quot;red&quot;,  %%mm3 \n&quot;\
+    &quot;movq      %%mm&quot;blue&quot;, %%mm6 \n&quot;\
+    &quot;psrlq     $32,        %%mm&quot;red&quot; \n&quot; /* R1 R3 R5 R7 */\
+    &quot;punpcklbw %%mm2,      %%mm3 \n&quot; /* R0 G0 R2 G2 R4 G4 R6 G6 */\
+    &quot;punpcklbw %%mm&quot;red&quot;,  %%mm6 \n&quot; /* B0 R1 B2 R3 B4 R5 B6 R7 */\
+    &quot;movq      %%mm3,      %%mm5 \n&quot;\
+    &quot;punpckhbw %%mm&quot;blue&quot;, %%mm2 \n&quot; /* G1 B1 G3 B3 G5 B5 G7 B7&#160;*/\
+    &quot;punpcklwd %%mm6,      %%mm3 \n&quot; /* R0 G0 B0 R1 R2 G2 B2 R3 */\
+    &quot;punpckhwd %%mm6,      %%mm5 \n&quot; /* R4 G4 B4 R5 R6 G6 B6 R7 */\
+    RGB_PACK24_B
+
 #if HAVE_MMX2
-#define RGB_PLANAR2PACKED24(red, blue)\
-        &quot;movq &quot;MANGLE(ff_M24A)&quot;, %%mm4     \n\t&quot;\
-        &quot;movq &quot;MANGLE(ff_M24C)&quot;, %%mm7     \n\t&quot;\
-        &quot;pshufw $0x50, %%mm&quot;blue&quot;, %%mm5   \n\t&quot; /* B3 B2 B3 B2  B1 B0 B1 B0 */\
-        &quot;pshufw $0x50, %%mm2, %%mm3     \n\t&quot; /* G3 G2 G3 G2  G1 G0 G1 G0 */\
-        &quot;pshufw $0x00, %%mm&quot;red&quot;, %%mm6 \n\t&quot; /* R1 R0 R1 R0  R1 R0 R1 R0 */\
-\
-        &quot;pand   %%mm4, %%mm5            \n\t&quot; /*    B2        B1       B0 */\
-        &quot;pand   %%mm4, %%mm3            \n\t&quot; /*    G2        G1       G0 */\
-        &quot;pand   %%mm7, %%mm6            \n\t&quot; /*       R1        R0       */\
-\
-        &quot;psllq     $8, %%mm3            \n\t&quot; /* G2        G1       G0    */\
-        &quot;por    %%mm5, %%mm6            \n\t&quot;\
-        &quot;por    %%mm3, %%mm6            \n\t&quot;\
-        MOVNTQ&quot; %%mm6, (%1)             \n\t&quot;\
-\
-        &quot;psrlq     $8, %%mm2            \n\t&quot; /* 00 G7 G6 G5  G4 G3 G2 G1 */\
-        &quot;pshufw $0xA5, %%mm&quot;blue&quot;, %%mm5\n\t&quot; /* B5 B4 B5 B4  B3 B2 B3 B2 */\
-        &quot;pshufw $0x55, %%mm2, %%mm3     \n\t&quot; /* G4 G3 G4 G3  G4 G3 G4 G3 */\
-        &quot;pshufw $0xA5, %%mm&quot;red&quot;, %%mm6 \n\t&quot; /* R5 R4 R5 R4  R3 R2 R3 R2 */\
-\
-        &quot;pand &quot;MANGLE(ff_M24B)&quot;, %%mm5  \n\t&quot; /* B5       B4        B3    */\
-        &quot;pand          %%mm7, %%mm3     \n\t&quot; /*       G4        G3       */\
-        &quot;pand          %%mm4, %%mm6     \n\t&quot; /*    R4        R3       R2 */\
-\
-        &quot;por    %%mm5, %%mm3            \n\t&quot; /* B5    G4 B4     G3 B3    */\
-        &quot;por    %%mm3, %%mm6            \n\t&quot;\
-        MOVNTQ&quot; %%mm6, 8(%1)            \n\t&quot;\
-\
-        &quot;pshufw $0xFF, %%mm&quot;blue&quot;, %%mm5\n\t&quot; /* B7 B6 B7 B6  B7 B6 B6 B7 */\
-        &quot;pshufw $0xFA, %%mm2, %%mm3     \n\t&quot; /* 00 G7 00 G7  G6 G5 G6 G5 */\
-        &quot;pshufw $0xFA, %%mm&quot;red&quot;, %%mm6 \n\t&quot; /* R7 R6 R7 R6  R5 R4 R5 R4 */\
-        &quot;movd 4 (%2, %0), %%mm0;&quot; /* Load 4 Cb 00 00 00 00 u3 u2 u1 u0 */\
-\
-        &quot;pand          %%mm7, %%mm5     \n\t&quot; /*       B7        B6       */\
-        &quot;pand          %%mm4, %%mm3     \n\t&quot; /*    G7        G6       G5 */\
-        &quot;pand &quot;MANGLE(ff_M24B)&quot;, %%mm6  \n\t&quot; /* R7       R6        R5    */\
-        &quot;movd 4 (%3, %0), %%mm1;&quot; /* Load 4 Cr 00 00 00 00 v3 v2 v1 v0 */\
-\
-        &quot;por          %%mm5, %%mm3      \n\t&quot;\
-        &quot;por          %%mm3, %%mm6      \n\t&quot;\
-        MOVNTQ&quot;       %%mm6, 16(%1)     \n\t&quot;\
-        &quot;movq 8 (%5, %0, 2), %%mm6;&quot; /* Load 8 Y Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 */\
-        &quot;pxor         %%mm4, %%mm4      \n\t&quot;
+DECLARE_ASM_CONST(8, int16_t, mask1101[4]) = {-1,-1, 0,-1};
+DECLARE_ASM_CONST(8, int16_t, mask0010[4]) = { 0, 0,-1, 0};
+DECLARE_ASM_CONST(8, int16_t, mask0110[4]) = { 0,-1,-1, 0};
+DECLARE_ASM_CONST(8, int16_t, mask1001[4]) = {-1, 0, 0,-1};
+DECLARE_ASM_CONST(8, int16_t, mask0100[4]) = { 0,-1, 0, 0};
+#undef RGB_PACK24_B
+#define RGB_PACK24_B\
+    &quot;pshufw    $0xc6,  %%mm2, %%mm1 \n&quot;\
+    &quot;pshufw    $0x84,  %%mm3, %%mm6 \n&quot;\
+    &quot;pshufw    $0x38,  %%mm5, %%mm7 \n&quot;\
+    &quot;pand &quot;MANGLE(mask1101)&quot;, %%mm6 \n&quot; /* R0 G0 B0 R1 -- -- R2 G2 */\
+    &quot;movq      %%mm1,         %%mm0 \n&quot;\
+    &quot;pand &quot;MANGLE(mask0110)&quot;, %%mm7 \n&quot; /* -- -- R6 G6 B6 R7 -- -- */\
+    &quot;movq      %%mm1,         %%mm2 \n&quot;\
+    &quot;pand &quot;MANGLE(mask0100)&quot;, %%mm1 \n&quot; /* -- -- G3 B3 -- -- -- -- */\
+    &quot;psrlq       $48,         %%mm3 \n&quot; /* B2 R3 -- -- -- -- -- -- */\
+    &quot;pand &quot;MANGLE(mask0010)&quot;, %%mm0 \n&quot; /* -- -- -- -- G1 B1 -- -- */\
+    &quot;psllq       $32,         %%mm5 \n&quot; /* -- -- -- -- R4 G4 B4 R5 */\
+    &quot;pand &quot;MANGLE(mask1001)&quot;, %%mm2 \n&quot; /* G5 B5 -- -- -- -- G7 B7 */\
+    &quot;por       %%mm3,         %%mm1 \n&quot;\
+    &quot;por       %%mm6,         %%mm0 \n&quot;\
+    &quot;por       %%mm5,         %%mm1 \n&quot;\
+    &quot;por       %%mm7,         %%mm2 \n&quot;\
+    MOVNTQ&quot;    %%mm0,          (%1) \n&quot;\
+    MOVNTQ&quot;    %%mm1,         8(%1) \n&quot;\
+    MOVNTQ&quot;    %%mm2,        16(%1) \n&quot;\
+
 #else
-#define RGB_PLANAR2PACKED24(red, blue)\
-        &quot;pxor      %%mm4, %%mm4     \n\t&quot;\
-        &quot;movq      %%mm&quot;blue&quot;, %%mm5\n\t&quot; /* B */\
-        &quot;movq      %%mm&quot;red&quot;, %%mm6 \n\t&quot; /* R */\
-        &quot;punpcklbw %%mm2, %%mm&quot;blue&quot;\n\t&quot; /* GBGBGBGB 0 */\
-        &quot;punpcklbw %%mm4, %%mm&quot;red&quot; \n\t&quot; /* 0R0R0R0R 0 */\
-        &quot;punpckhbw %%mm2, %%mm5     \n\t&quot; /* GBGBGBGB 2 */\
-        &quot;punpckhbw %%mm4, %%mm6     \n\t&quot; /* 0R0R0R0R 2 */\
-        &quot;movq      %%mm&quot;blue&quot;, %%mm7\n\t&quot; /* GBGBGBGB 0 */\
-        &quot;movq      %%mm5, %%mm3     \n\t&quot; /* GBGBGBGB 2 */\
-        &quot;punpcklwd %%mm&quot;red&quot;, %%mm7 \n\t&quot; /* 0RGB0RGB 0 */\
-        &quot;punpckhwd %%mm&quot;red&quot;, %%mm&quot;blue&quot;\n\t&quot; /* 0RGB0RGB 1 */\
-        &quot;punpcklwd %%mm6, %%mm5     \n\t&quot; /* 0RGB0RGB 2 */\
-        &quot;punpckhwd %%mm6, %%mm3     \n\t&quot; /* 0RGB0RGB 3 */\
-\
-        &quot;movq      %%mm7, %%mm2     \n\t&quot; /* 0RGB0RGB 0 */\
-        &quot;movq      %%mm&quot;blue&quot;, %%mm6\n\t&quot; /* 0RGB0RGB 1 */\
-        &quot;movq      %%mm5, %%mm&quot;red&quot; \n\t&quot; /* 0RGB0RGB 2 */\
-        &quot;movq      %%mm3, %%mm4     \n\t&quot; /* 0RGB0RGB 3 */\
-\
-        &quot;psllq       $40, %%mm7     \n\t&quot; /* RGB00000 0 */\
-        &quot;psllq       $40, %%mm&quot;blue&quot;\n\t&quot; /* RGB00000 1 */\
-        &quot;psllq       $40, %%mm5     \n\t&quot; /* RGB00000 2 */\
-        &quot;psllq       $40, %%mm3     \n\t&quot; /* RGB00000 3 */\
-\
-        &quot;punpckhdq %%mm2, %%mm7     \n\t&quot; /* 0RGBRGB0 0 */\
-        &quot;punpckhdq %%mm6, %%mm&quot;blue&quot;\n\t&quot; /* 0RGBRGB0 1 */\
-        &quot;punpckhdq %%mm&quot;red&quot;, %%mm5 \n\t&quot; /* 0RGBRGB0 2 */\
-        &quot;punpckhdq %%mm4, %%mm3     \n\t&quot; /* 0RGBRGB0 3 */\
-\
-        &quot;psrlq        $8, %%mm7     \n\t&quot; /* 00RGBRGB 0 */\
-        &quot;movq      %%mm&quot;blue&quot;, %%mm6\n\t&quot; /* 0RGBRGB0 1 */\
-        &quot;psllq       $40, %%mm&quot;blue&quot;\n\t&quot; /* GB000000 1 */\
-        &quot;por       %%mm&quot;blue&quot;, %%mm7\n\t&quot; /* GBRGBRGB 0 */\
-        MOVNTQ&quot;    %%mm7, (%1)      \n\t&quot;\
-\
-        &quot;psrlq       $24, %%mm6     \n\t&quot; /* 0000RGBR 1 */\
-        &quot;movq      %%mm5, %%mm&quot;red&quot; \n\t&quot; /* 0RGBRGB0 2 */\
-        &quot;psllq       $24, %%mm5     \n\t&quot; /* BRGB0000 2 */\
-        &quot;por       %%mm5, %%mm6     \n\t&quot; /* BRGBRGBR 1 */\
-        MOVNTQ&quot;    %%mm6, 8(%1)     \n\t&quot;\
-\
-        &quot;movq 8 (%5, %0, 2), %%mm6;&quot; /* Load 8 Y Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 */\
-\
-        &quot;psrlq       $40, %%mm&quot;red&quot; \n\t&quot; /* 000000RG 2 */\
-        &quot;psllq        $8, %%mm3     \n\t&quot; /* RGBRGB00 3 */\
-        &quot;por       %%mm3, %%mm&quot;red&quot; \n\t&quot; /* RGBRGBRG 2 */\
-        MOVNTQ&quot;    %%mm&quot;red&quot;, 16(%1)\n\t&quot;\
-\
-        &quot;movd 4 (%3, %0), %%mm1;&quot; /* Load 4 Cr 00 00 00 00 v3 v2 v1 v0 */\
-        &quot;movd 4 (%2, %0), %%mm0;&quot; /* Load 4 Cb 00 00 00 00 u3 u2 u1 u0 */\
-        &quot;pxor      %%mm4, %%mm4     \n\t&quot;
+#undef RGB_PACK24_B
+#define RGB_PACK24_B\
+    &quot;movd      %%mm3,       (%1) \n&quot; /* R0 G0 B0 R1 */\
+    &quot;movd      %%mm2,      4(%1) \n&quot; /* G1 B1 */\
+    &quot;psrlq     $32,        %%mm3 \n&quot;\
+    &quot;psrlq     $16,        %%mm2 \n&quot;\
+    &quot;movd      %%mm3,      6(%1) \n&quot; /* R2 G2 B2 R3 */\
+    &quot;movd      %%mm2,     10(%1) \n&quot; /* G3 B3 */\
+    &quot;psrlq     $16,        %%mm2 \n&quot;\
+    &quot;movd      %%mm5,     12(%1) \n&quot; /* R4 G4 B4 R5 */\
+    &quot;movd      %%mm2,     16(%1) \n&quot; /* G5 B5 */\
+    &quot;psrlq     $32,        %%mm5 \n&quot;\
+    &quot;movd      %%mm2,     20(%1) \n&quot; /* -- -- G7 B7 */\
+    &quot;movd      %%mm5,     18(%1) \n&quot; /* R6 G6 B6 R7 */\
+
 #endif
 
-static inline int RENAME(yuv420_rgb24)(SwsContext *c, const uint8_t* src[], int srcStride[], int srcSliceY,
-                                       int srcSliceH, uint8_t* dst[], int dstStride[])
+static inline int RENAME(yuv420_rgb24)(SwsContext *c, const uint8_t *src[],
+                                       int srcStride[],
+                                       int srcSliceY, int srcSliceH,
+                                       uint8_t *dst[], int dstStride[])
 {
     int y, h_size;
 
-    YUV422_UNSHIFT
     YUV2RGB_LOOP(3)
 
-        YUV2RGB_INIT
+        YUV2RGB_INITIAL_LOAD
         YUV2RGB
-        /* mm0=B, %%mm2=G, %%mm1=R */
-        RGB_PLANAR2PACKED24(&quot;0&quot;, &quot;1&quot;)
+        RGB_PACK24(REG_BLUE, REG_RED)
 
     YUV2RGB_ENDLOOP(3)
     YUV2RGB_OPERANDS
+    YUV2RGB_ENDFUNC
 }
 
-static inline int RENAME(yuv420_bgr24)(SwsContext *c, const uint8_t* src[], int srcStride[], int srcSliceY,
-                                       int srcSliceH, uint8_t* dst[], int dstStride[])
+static inline int RENAME(yuv420_bgr24)(SwsContext *c, const uint8_t *src[],
+                                       int srcStride[],
+                                       int srcSliceY, int srcSliceH,
+                                       uint8_t *dst[], int dstStride[])
 {
     int y, h_size;
 
-    YUV422_UNSHIFT
     YUV2RGB_LOOP(3)
 
-        YUV2RGB_INIT
+        YUV2RGB_INITIAL_LOAD
         YUV2RGB
-        /* mm0=B, %%mm2=G, %%mm1=R */
-        RGB_PLANAR2PACKED24(&quot;1&quot;, &quot;0&quot;)
+        RGB_PACK24(REG_RED, REG_BLUE)
 
     YUV2RGB_ENDLOOP(3)
     YUV2RGB_OPERANDS
+    YUV2RGB_ENDFUNC
 }
 
-/*
 
-RGB_PLANAR2PACKED32(red,green,blue,alpha)
+#define SET_EMPTY_ALPHA                                                      \
+    &quot;pcmpeqd   %%mm&quot;REG_ALPHA&quot;, %%mm&quot;REG_ALPHA&quot;\n\t&quot; /* set alpha to 0xFF */ \
 
-convert RGB plane to RGB packed format
+#define LOAD_ALPHA                                   \
+    &quot;movq      (%6, %0, 2),     %%mm&quot;REG_ALPHA&quot;\n\t&quot; \
 
-macro parameters specify the output color channel order:
+#define RGB_PACK32(red, green, blue, alpha)  \
+    &quot;movq      %%mm&quot;blue&quot;,  %%mm5\n\t&quot;       \
+    &quot;movq      %%mm&quot;red&quot;,   %%mm6\n\t&quot;       \
+    &quot;punpckhbw %%mm&quot;green&quot;, %%mm5\n\t&quot;       \
+    &quot;punpcklbw %%mm&quot;green&quot;, %%mm&quot;blue&quot;\n\t&quot;  \
+    &quot;punpckhbw %%mm&quot;alpha&quot;, %%mm6\n\t&quot;       \
+    &quot;punpcklbw %%mm&quot;alpha&quot;, %%mm&quot;red&quot;\n\t&quot;   \
+    &quot;movq      %%mm&quot;blue&quot;,  %%mm&quot;green&quot;\n\t&quot; \
+    &quot;movq      %%mm5,       %%mm&quot;alpha&quot;\n\t&quot; \
+    &quot;punpcklwd %%mm&quot;red&quot;,   %%mm&quot;blue&quot;\n\t&quot;  \
+    &quot;punpckhwd %%mm&quot;red&quot;,   %%mm&quot;green&quot;\n\t&quot; \
+    &quot;punpcklwd %%mm6,       %%mm5\n\t&quot;       \
+    &quot;punpckhwd %%mm6,       %%mm&quot;alpha&quot;\n\t&quot; \
+    MOVNTQ &quot;   %%mm&quot;blue&quot;,   0(%1)\n\t&quot;      \
+    MOVNTQ &quot;   %%mm&quot;green&quot;,  8(%1)\n\t&quot;      \
+    MOVNTQ &quot;   %%mm5,       16(%1)\n\t&quot;      \
+    MOVNTQ &quot;   %%mm&quot;alpha&quot;, 24(%1)\n\t&quot;      \
 
-RGB_PLANAR2PACKED32(REG_RED,  REG_GREEN, REG_BLUE, REG_ALPHA) for RGBA output,
-RGB_PLANAR2PACKED32(REG_BLUE, REG_GREEN, REG_RED,  REG_ALPHA) for BGRA output,
-RGB_PLANAR2PACKED32(REG_ALPHA,REG_BLUE,  REG_GREEN,REG_RED)   for ABGR output,
-
-etc.
-*/
-
-#define REG_BLUE  &quot;0&quot;
-#define REG_RED   &quot;1&quot;
-#define REG_GREEN &quot;2&quot;
-#define REG_ALPHA &quot;3&quot;
-
-#define RGB_PLANAR2PACKED32(red,green,blue,alpha)                       \
-    /* convert RGB plane to RGB packed format,                          \
-       mm0 -&gt;  B, mm1 -&gt; R, mm2 -&gt; G, mm3 -&gt; A,                         \
-       mm4 -&gt; GB, mm5 -&gt; AR pixel 4-7,                                  \
-       mm6 -&gt; GB, mm7 -&gt; AR pixel 0-3 */                                \
-    &quot;movq      %%mm&quot; blue &quot;, %%mm6;&quot;   /* B7 B6 B5 B4 B3 B2 B1 B0 */    \
-    &quot;movq      %%mm&quot; red  &quot;, %%mm7;&quot;   /* R7 R6 R5 R4 R3 R2 R1 R0 */    \
-\
-    &quot;movq      %%mm&quot; blue &quot;, %%mm4;&quot;   /* B7 B6 B5 B4 B3 B2 B1 B0 */    \
-    &quot;movq      %%mm&quot; red  &quot;, %%mm5;&quot;   /* R7 R6 R5 R4 R3 R2 R1 R0 */    \
-\
-    &quot;punpcklbw %%mm&quot; green &quot;, %%mm6;&quot;  /* G3 B3 G2 B2 G1 B1 G0 B0 */    \
-    &quot;punpcklbw %%mm&quot; alpha &quot;, %%mm7;&quot;  /* A3 R3 A2 R2 A1 R1 A0 R0 */    \
-\
-    &quot;punpcklwd %%mm7, %%mm6;&quot;          /* A1 R1 B1 G1 A0 R0 B0 G0 */    \
-    MOVNTQ &quot;   %%mm6, (%1);&quot;           /* Store ARGB1 ARGB0 */          \
-\
-    &quot;movq      %%mm&quot; blue &quot;, %%mm6;&quot;   /* B7 B6 B5 B4 B3 B2 B1 B0 */    \
-    &quot;punpcklbw %%mm&quot; green &quot;, %%mm6;&quot;  /* G3 B3 G2 B2 G1 B1 G0 B0 */    \
-\
-    &quot;punpckhwd %%mm7, %%mm6;&quot;          /* A3 R3 G3 B3 A2 R2 B3 G2 */    \
-    MOVNTQ &quot;   %%mm6, 8 (%1);&quot;         /* Store ARGB3 ARGB2 */          \
-\
-    &quot;punpckhbw %%mm&quot; green &quot;, %%mm4;&quot;  /* G7 B7 G6 B6 G5 B5 G4 B4 */    \
-    &quot;punpckhbw %%mm&quot; alpha &quot;, %%mm5;&quot;  /* A7 R7 A6 R6 A5 R5 A4 R4 */    \
-\
-    &quot;punpcklwd %%mm5, %%mm4;&quot;          /* A5 R5 B5 G5 A4 R4 B4 G4 */    \
-    MOVNTQ &quot;   %%mm4, 16 (%1);&quot;        /* Store ARGB5 ARGB4 */          \
-\
-    &quot;movq      %%mm&quot; blue &quot;, %%mm4;&quot;   /* B7 B6 B5 B4 B3 B2 B1 B0 */    \
-    &quot;punpckhbw %%mm&quot; green &quot;, %%mm4;&quot;  /* G7 B7 G6 B6 G5 B5 G4 B4 */    \
-\
-    &quot;punpckhwd %%mm5, %%mm4;&quot;   /* A7 R7 G7 B7 A6 R6 B6 G6 */           \
-    MOVNTQ &quot;   %%mm4, 24 (%1);&quot; /* Store ARGB7 ARGB6 */                 \
-\
-    &quot;movd 4 (%2, %0), %%mm0;&quot;   /* Load 4 Cb 00 00 00 00 u3 u2 u1 u0 */ \
-    &quot;movd 4 (%3, %0), %%mm1;&quot;   /* Load 4 Cr 00 00 00 00 v3 v2 v1 v0 */ \
-\
-    &quot;pxor         %%mm4, %%mm4;&quot; /* zero mm4 */                         \
-    &quot;movq 8 (%5, %0, 2), %%mm6;&quot; /* Load 8 Y Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 */ \
-
-static inline int RENAME(yuv420_rgb32)(SwsContext *c, const uint8_t* src[], int srcStride[], int srcSliceY,
-                                       int srcSliceH, uint8_t* dst[], int dstStride[])
+static inline int RENAME(yuv420_rgb32)(SwsContext *c, const uint8_t *src[],
+                                       int srcStride[],
+                                       int srcSliceY, int srcSliceH,
+                                       uint8_t *dst[], int dstStride[])
 {
     int y, h_size;
 
-    YUV422_UNSHIFT
     YUV2RGB_LOOP(4)
 
-        YUV2RGB_INIT
+        YUV2RGB_INITIAL_LOAD
         YUV2RGB
-        &quot;pcmpeqd   %%mm3, %%mm3;&quot;   /* fill mm3 */
-        RGB_PLANAR2PACKED32(REG_RED,REG_GREEN,REG_BLUE,REG_ALPHA)
+        RGB_PACK_INTERLEAVE
+        SET_EMPTY_ALPHA
+        RGB_PACK32(REG_RED, REG_GREEN, REG_BLUE, REG_ALPHA)
 
     YUV2RGB_ENDLOOP(4)
     YUV2RGB_OPERANDS
+    YUV2RGB_ENDFUNC
 }
 
-static inline int RENAME(yuva420_rgb32)(SwsContext *c, const uint8_t* src[], int srcStride[], int srcSliceY,
-                                        int srcSliceH, uint8_t* dst[], int dstStride[])
+static inline int RENAME(yuva420_rgb32)(SwsContext *c, const uint8_t *src[],
+                                        int srcStride[],
+                                        int srcSliceY, int srcSliceH,
+                                        uint8_t *dst[], int dstStride[])
 {
 #if HAVE_7REGS
     int y, h_size;
 
     YUV2RGB_LOOP(4)
 
-        const uint8_t *pa = src[3] + y*srcStride[3];
-        YUV2RGB_INIT
+        const uint8_t *pa = src[3] + y * srcStride[3];
+        YUV2RGB_INITIAL_LOAD
         YUV2RGB
-        &quot;movq     (%6, %0, 2), %%mm3;&quot;            /* Load 8 A A7 A6 A5 A4 A3 A2 A1 A0 */
-        RGB_PLANAR2PACKED32(REG_RED,REG_GREEN,REG_BLUE,REG_ALPHA)
+        RGB_PACK_INTERLEAVE
+        LOAD_ALPHA
+        RGB_PACK32(REG_RED, REG_GREEN, REG_BLUE, REG_ALPHA)
 
     YUV2RGB_ENDLOOP(4)
     YUV2RGB_OPERANDS_ALPHA
+    YUV2RGB_ENDFUNC
 #endif
 }
 
-static inline int RENAME(yuv420_bgr32)(SwsContext *c, const uint8_t* src[], int srcStride[], int srcSliceY,
-                                       int srcSliceH, uint8_t* dst[], int dstStride[])
+static inline int RENAME(yuv420_bgr32)(SwsContext *c, const uint8_t *src[],
+                                       int srcStride[],
+                                       int srcSliceY, int srcSliceH,
+                                       uint8_t *dst[], int dstStride[])
 {
     int y, h_size;
 
-    YUV422_UNSHIFT
     YUV2RGB_LOOP(4)
 
-        YUV2RGB_INIT
+        YUV2RGB_INITIAL_LOAD
         YUV2RGB
-        &quot;pcmpeqd   %%mm3, %%mm3;&quot;   /* fill mm3 */
-        RGB_PLANAR2PACKED32(REG_BLUE,REG_GREEN,REG_RED,REG_ALPHA)
+        RGB_PACK_INTERLEAVE
+        SET_EMPTY_ALPHA
+        RGB_PACK32(REG_BLUE, REG_GREEN, REG_RED, REG_ALPHA)
 
     YUV2RGB_ENDLOOP(4)
     YUV2RGB_OPERANDS
+    YUV2RGB_ENDFUNC
 }
 
-static inline int RENAME(yuva420_bgr32)(SwsContext *c, const uint8_t* src[], int srcStride[], int srcSliceY,
-                                        int srcSliceH, uint8_t* dst[], int dstStride[])
+static inline int RENAME(yuva420_bgr32)(SwsContext *c, const uint8_t *src[],
+                                        int srcStride[],
+                                        int srcSliceY, int srcSliceH,
+                                        uint8_t *dst[], int dstStride[])
 {
 #if HAVE_7REGS
     int y, h_size;
 
     YUV2RGB_LOOP(4)
 
-        const uint8_t *pa = src[3] + y*srcStride[3];
-        YUV2RGB_INIT
+        const uint8_t *pa = src[3] + y * srcStride[3];
+        YUV2RGB_INITIAL_LOAD
         YUV2RGB
-        &quot;movq     (%6, %0, 2), %%mm3;&quot;            /* Load 8 A A7 A6 A5 A4 A3 A2 A1 A0 */
-        RGB_PLANAR2PACKED32(REG_BLUE,REG_GREEN,REG_RED,REG_ALPHA)
+        RGB_PACK_INTERLEAVE
+        LOAD_ALPHA
+        RGB_PACK32(REG_BLUE, REG_GREEN, REG_RED, REG_ALPHA)
 
     YUV2RGB_ENDLOOP(4)
     YUV2RGB_OPERANDS_ALPHA
+    YUV2RGB_ENDFUNC
 #endif
 }

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/yuv2rgb.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/yuv2rgb.c	2010-07-25 10:07:46 UTC (rev 6481)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale/yuv2rgb.c	2010-07-25 10:07:49 UTC (rev 6482)
@@ -33,7 +33,9 @@
 #include &quot;swscale.h&quot;
 #include &quot;swscale_internal.h&quot;
 #include &quot;libavutil/x86_cpu.h&quot;
+#include &quot;libavutil/bswap.h&quot;
 
+extern const uint8_t dither_4x4_16[4][8];
 extern const uint8_t dither_8x8_32[8][8];
 extern const uint8_t dither_8x8_73[8][8];
 extern const uint8_t dither_8x8_220[8][8];
@@ -49,7 +51,7 @@
     {117579, 136230, 16907, 35559}  /* SMPTE 240M (1987) */
 };
 
-const int * sws_getCoefficients(int colorspace)
+const int *sws_getCoefficients(int colorspace)
 {
     if (colorspace &gt; 7 || colorspace &lt; 0)
         colorspace = SWS_CS_DEFAULT;
@@ -351,6 +353,32 @@
 #endif
 
 // r, g, b, dst_1, dst_2
+YUV2RGBFUNC(yuv2rgb_c_12_ordered_dither, uint16_t, 0)
+    const uint8_t *d16 = dither_4x4_16[y&amp;3];
+#define PUTRGB12(dst,src,i,o)                                   \
+    Y = src[2*i];                                               \
+    dst[2*i]   = r[Y+d16[0+o]] + g[Y+d16[0+o]] + b[Y+d16[0+o]]; \
+    Y = src[2*i+1];                                             \
+    dst[2*i+1] = r[Y+d16[1+o]] + g[Y+d16[1+o]] + b[Y+d16[1+o]];
+
+    LOADCHROMA(0);
+    PUTRGB12(dst_1,py_1,0,0);
+    PUTRGB12(dst_2,py_2,0,0+8);
+
+    LOADCHROMA(1);
+    PUTRGB12(dst_2,py_2,1,2+8);
+    PUTRGB12(dst_1,py_1,1,2);
+
+    LOADCHROMA(2);
+    PUTRGB12(dst_1,py_1,2,4);
+    PUTRGB12(dst_2,py_2,2,4+8);
+
+    LOADCHROMA(3);
+    PUTRGB12(dst_2,py_2,3,6+8);
+    PUTRGB12(dst_1,py_1,3,6);
+CLOSEYUV2RGBFUNC(8)
+
+// r, g, b, dst_1, dst_2
 YUV2RGBFUNC(yuv2rgb_c_8_ordered_dither, uint8_t, 0)
     const uint8_t *d32 = dither_8x8_32[y&amp;7];
     const uint8_t *d64 = dither_8x8_73[y&amp;7];
@@ -515,7 +543,7 @@
 SwsFunc ff_yuv2rgb_get_func_ptr(SwsContext *c)
 {
     SwsFunc t = NULL;
-#if (HAVE_MMX2 || HAVE_MMX) &amp;&amp; CONFIG_GPL
+#if HAVE_MMX
      t = ff_yuv2rgb_init_mmx(c);
 #endif
 #if HAVE_VIS
@@ -552,6 +580,8 @@
     case PIX_FMT_BGR565:
     case PIX_FMT_RGB555:
     case PIX_FMT_BGR555:     return yuv2rgb_c_16;
+    case PIX_FMT_RGB444:
+    case PIX_FMT_BGR444:     return yuv2rgb_c_12_ordered_dither;
     case PIX_FMT_RGB8:
     case PIX_FMT_BGR8:       return yuv2rgb_c_8_ordered_dither;
     case PIX_FMT_RGB4:
@@ -590,18 +620,36 @@
     }
 }
 
+static uint16_t roundToInt16(int64_t f)
+{
+    int r= (f + (1&lt;&lt;15))&gt;&gt;16;
+         if (r&lt;-0x7FFF) return 0x8000;
+    else if (r&gt; 0x7FFF) return 0x7FFF;
+    else                return r;
+}
+
 av_cold int ff_yuv2rgb_c_init_tables(SwsContext *c, const int inv_table[4], int fullRange,
                                      int brightness, int contrast, int saturation)
 {
     const int isRgb =      c-&gt;dstFormat==PIX_FMT_RGB32
                         || c-&gt;dstFormat==PIX_FMT_RGB32_1
                         || c-&gt;dstFormat==PIX_FMT_BGR24
-                        || c-&gt;dstFormat==PIX_FMT_RGB565
-                        || c-&gt;dstFormat==PIX_FMT_RGB555
+                        || c-&gt;dstFormat==PIX_FMT_RGB565BE
+                        || c-&gt;dstFormat==PIX_FMT_RGB565LE
+                        || c-&gt;dstFormat==PIX_FMT_RGB555BE
+                        || c-&gt;dstFormat==PIX_FMT_RGB555LE
+                        || c-&gt;dstFormat==PIX_FMT_RGB444BE
+                        || c-&gt;dstFormat==PIX_FMT_RGB444LE
                         || c-&gt;dstFormat==PIX_FMT_RGB8
                         || c-&gt;dstFormat==PIX_FMT_RGB4
                         || c-&gt;dstFormat==PIX_FMT_RGB4_BYTE
                         || c-&gt;dstFormat==PIX_FMT_MONOBLACK;
+    const int isNotNe =    c-&gt;dstFormat==PIX_FMT_NE(RGB565LE,RGB565BE)
+                        || c-&gt;dstFormat==PIX_FMT_NE(RGB555LE,RGB555BE)
+                        || c-&gt;dstFormat==PIX_FMT_NE(RGB444LE,RGB444BE)
+                        || c-&gt;dstFormat==PIX_FMT_NE(BGR565LE,BGR565BE)
+                        || c-&gt;dstFormat==PIX_FMT_NE(BGR555LE,BGR555BE)
+                        || c-&gt;dstFormat==PIX_FMT_NE(BGR444LE,BGR444BE);
     const int bpp = c-&gt;dstFormatBpp;
     uint8_t *y_table;
     uint16_t *y_table16;
@@ -635,6 +683,22 @@
     cgv = (cgv*contrast * saturation) &gt;&gt; 32;
     oy -= 256*brightness;
 
+    c-&gt;uOffset=   0x0400040004000400LL;
+    c-&gt;vOffset=   0x0400040004000400LL;
+    c-&gt;yCoeff=    roundToInt16(cy *8192) * 0x0001000100010001ULL;
+    c-&gt;vrCoeff=   roundToInt16(crv*8192) * 0x0001000100010001ULL;
+    c-&gt;ubCoeff=   roundToInt16(cbu*8192) * 0x0001000100010001ULL;
+    c-&gt;vgCoeff=   roundToInt16(cgv*8192) * 0x0001000100010001ULL;
+    c-&gt;ugCoeff=   roundToInt16(cgu*8192) * 0x0001000100010001ULL;
+    c-&gt;yOffset=   roundToInt16(oy *   8) * 0x0001000100010001ULL;
+
+    c-&gt;yuv2rgb_y_coeff  = (int16_t)roundToInt16(cy &lt;&lt;13);
+    c-&gt;yuv2rgb_y_offset = (int16_t)roundToInt16(oy &lt;&lt; 9);
+    c-&gt;yuv2rgb_v2r_coeff= (int16_t)roundToInt16(crv&lt;&lt;13);
+    c-&gt;yuv2rgb_v2g_coeff= (int16_t)roundToInt16(cgv&lt;&lt;13);
+    c-&gt;yuv2rgb_u2g_coeff= (int16_t)roundToInt16(cgu&lt;&lt;13);
+    c-&gt;yuv2rgb_u2b_coeff= (int16_t)roundToInt16(cbu&lt;&lt;13);
+
     //scale coefficients by cy
     crv = ((crv &lt;&lt; 16) + 0x8000) / cy;
     cbu = ((cbu &lt;&lt; 16) + 0x8000) / cy;
@@ -694,6 +758,28 @@
         fill_table(c-&gt;table_bU, 1, cbu, y_table + yoffs + 2048);
         fill_gv_table(c-&gt;table_gV, 1, cgv);
         break;
+    case 12:
+        rbase = isRgb ? 8 : 0;
+        gbase = 4;
+        bbase = isRgb ? 0 : 8;
+        c-&gt;yuvTable = av_malloc(1024*3*2);
+        y_table16 = c-&gt;yuvTable;
+        yb = -(384&lt;&lt;16) - oy;
+        for (i = 0; i &lt; 1024; i++) {
+            uint8_t yval = av_clip_uint8((yb + 0x8000) &gt;&gt; 16);
+            y_table16[i     ] = (yval &gt;&gt; 4) &lt;&lt; rbase;
+            y_table16[i+1024] = (yval &gt;&gt; 4) &lt;&lt; gbase;
+            y_table16[i+2048] = (yval &gt;&gt; 4) &lt;&lt; bbase;
+            yb += cy;
+        }
+        if (isNotNe)
+            for (i = 0; i &lt; 1024*3; i++)
+                y_table16[i] = bswap_16(y_table16[i]);
+        fill_table(c-&gt;table_rV, 2, crv, y_table16 + yoffs);
+        fill_table(c-&gt;table_gU, 2, cgu, y_table16 + yoffs + 1024);
+        fill_table(c-&gt;table_bU, 2, cbu, y_table16 + yoffs + 2048);
+        fill_gv_table(c-&gt;table_gV, 2, cgv);
+        break;
     case 15:
     case 16:
         rbase = isRgb ? bpp - 5 : 0;
@@ -709,6 +795,9 @@
             y_table16[i+2048] = (yval &gt;&gt; 3)          &lt;&lt; bbase;
             yb += cy;
         }
+        if(isNotNe)
+            for (i = 0; i &lt; 1024*3; i++)
+                y_table16[i] = bswap_16(y_table16[i]);
         fill_table(c-&gt;table_rV, 2, crv, y_table16 + yoffs);
         fill_table(c-&gt;table_gU, 2, cgu, y_table16 + yoffs + 1024);
         fill_table(c-&gt;table_bU, 2, cbu, y_table16 + yoffs + 2048);


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003668.html">[Avidemux-svn-commit] r6481 - in	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg:	libavformat patches patches/avformat
</A></li>
	<LI>Next message: <A HREF="003670.html">[Avidemux-svn-commit] r6483 - in	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg:	libavcodec libavcodec/x86 patches patches/avcodec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3669">[ date ]</a>
              <a href="thread.html#3669">[ thread ]</a>
              <a href="subject.html#3669">[ subject ]</a>
              <a href="author.html#3669">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
