<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r6451 - in	branches/avidemux_2.6_branch_mean/avidemux/common:	ADM_audioFilter/src/ADM_libsamplerate ADM_commonUI ADM_ocr
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2010-July/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r6451%20-%20in%0A%09branches/avidemux_2.6_branch_mean/avidemux/common%3A%0A%09ADM_audioFilter/src/ADM_libsamplerate%20ADM_commonUI%20ADM_ocr&In-Reply-To=%3C20100714121723.2041B480BDF%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003638.html">
   <LINK REL="Next"  HREF="003640.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r6451 - in	branches/avidemux_2.6_branch_mean/avidemux/common:	ADM_audioFilter/src/ADM_libsamplerate ADM_commonUI ADM_ocr</H1>
    <B>mean at mail.berlios.de</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r6451%20-%20in%0A%09branches/avidemux_2.6_branch_mean/avidemux/common%3A%0A%09ADM_audioFilter/src/ADM_libsamplerate%20ADM_commonUI%20ADM_ocr&In-Reply-To=%3C20100714121723.2041B480BDF%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r6451 - in	branches/avidemux_2.6_branch_mean/avidemux/common:	ADM_audioFilter/src/ADM_libsamplerate ADM_commonUI ADM_ocr">mean at mail.berlios.de
       </A><BR>
    <I>Wed Jul 14 14:17:22 CEST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="003638.html">[Avidemux-svn-commit] r6450 - in branches/avidemux_2.6_branch_mean:	avidemux avidemux/common/ADM_render	avidemux/common/ADM_videoCodec/include	avidemux/common/ADM_videoCodec/src avidemux_core	avidemux_core/ADM_coreUI/include avidemux_core/ADM_coreVdpau	avidemux_core/ADM_coreVdpau/include avidemux_core/ADM_coreVdpau/src
</A></li>
        <LI>Next message: <A HREF="003640.html">[Avidemux-svn-commit] r6452 -	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3639">[ date ]</a>
              <a href="thread.html#3639">[ thread ]</a>
              <a href="subject.html#3639">[ subject ]</a>
              <a href="author.html#3639">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2010-07-14 14:17:22 +0200 (Wed, 14 Jul 2010)
New Revision: 6451

Removed:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/DIA_requant.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/ADM_bitmapSource.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/ADM_leftturn.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/ADM_ocr.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/ADM_ocr.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/ADM_ocrEngine.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/ADM_ocrInternal.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/ADM_vob2vobsub.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/adm_glyph.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/adm_glyph.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/adm_leftturn.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/ADM_libsamplerate/float_cast.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/ADM_libsamplerate/samplerate.c
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/ADM_libsamplerate/src_linear.c
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/ADM_libsamplerate/src_sinc.c
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/ADM_libsamplerate/src_zoh.c
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/DIA_plugins.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/DIA_postproc.cpp
Log:
[all] try to remove as much include config.h as possible

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/ADM_libsamplerate/float_cast.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/ADM_libsamplerate/float_cast.h	2010-07-14 12:17:20 UTC (rev 6450)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/ADM_libsamplerate/float_cast.h	2010-07-14 12:17:22 UTC (rev 6451)
@@ -45,12 +45,12 @@
 **		long int lrint  (double x) ;
 */
 
-// MEANX #include &quot;config.h&quot;
+// MEANX #include &quot;xonfig.h&quot;
 
 /*
 **	The presence of the required functions are detected during the configure
 **	process and the values HAVE_LRINT and HAVE_LRINTF are set accordingly in
-**	the config.h file.
+**	the xonfig.h file.
 */
 
 #define		HAVE_LRINT_REPLACEMENT	0

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/ADM_libsamplerate/samplerate.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/ADM_libsamplerate/samplerate.c	2010-07-14 12:17:20 UTC (rev 6450)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/ADM_libsamplerate/samplerate.c	2010-07-14 12:17:22 UTC (rev 6451)
@@ -26,7 +26,7 @@
 #include	&lt;stdlib.h&gt;
 #include	&lt;string.h&gt;
 
-#include	&quot;config.h&quot;
+#include	&quot;xonfig.h&quot;
 #else
 #include &quot;ADM_default.h&quot;
 #endif

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/ADM_libsamplerate/src_linear.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/ADM_libsamplerate/src_linear.c	2010-07-14 12:17:20 UTC (rev 6450)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/ADM_libsamplerate/src_linear.c	2010-07-14 12:17:22 UTC (rev 6451)
@@ -26,7 +26,7 @@
 #include &lt;stdlib.h&gt;
 #include &lt;string.h&gt;
 
-#include &quot;config.h&quot;
+#include &quot;xonfig.h&quot;
 #else
 #include &quot;ADM_default.h&quot;
 #endif

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/ADM_libsamplerate/src_sinc.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/ADM_libsamplerate/src_sinc.c	2010-07-14 12:17:20 UTC (rev 6450)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/ADM_libsamplerate/src_sinc.c	2010-07-14 12:17:22 UTC (rev 6451)
@@ -26,7 +26,7 @@
 #include &lt;stdlib.h&gt;
 #include &lt;string.h&gt;
 
-#include &quot;config.h&quot;
+#include &quot;xonfig.h&quot;
 #else
 #include &quot;ADM_default.h&quot;
 #endif

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/ADM_libsamplerate/src_zoh.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/ADM_libsamplerate/src_zoh.c	2010-07-14 12:17:20 UTC (rev 6450)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/ADM_libsamplerate/src_zoh.c	2010-07-14 12:17:22 UTC (rev 6451)
@@ -26,7 +26,7 @@
 #include &lt;stdlib.h&gt;
 #include &lt;string.h&gt;
 
-#include &quot;config.h&quot;
+#include &quot;xonfig.h&quot;
 #else
 #include &quot;ADM_default.h&quot;
 #endif

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/CMakeLists.txt	2010-07-14 12:17:20 UTC (rev 6450)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/CMakeLists.txt	2010-07-14 12:17:22 UTC (rev 6451)
@@ -7,7 +7,6 @@
 DIA_bitrateHisto.cpp  
 DIA_prefs.cpp     
 DIA_builtin.cpp       
-DIA_requant.cpp   
 DIA_jobs_save.cpp
 DIA_plugins.cpp
 )

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/DIA_plugins.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/DIA_plugins.cpp	2010-07-14 12:17:20 UTC (rev 6450)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/DIA_plugins.cpp	2010-07-14 12:17:22 UTC (rev 6451)
@@ -13,7 +13,7 @@
  *                                                                         *
  ***************************************************************************/
 
-//#include &quot;config.h&quot;
+//#include &quot;xonfig.h&quot;
 #include &quot;ADM_default.h&quot;
 #include &quot;DIA_factory.h&quot;
 

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/DIA_postproc.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/DIA_postproc.cpp	2010-07-14 12:17:20 UTC (rev 6450)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/DIA_postproc.cpp	2010-07-14 12:17:22 UTC (rev 6451)
@@ -12,7 +12,7 @@
 //
 //
 
-#include &quot;config.h&quot;
+//#include &quot;xonfig.h&quot;
 #include &quot;ADM_default.h&quot;
 
 

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/DIA_requant.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/DIA_requant.cpp	2010-07-14 12:17:20 UTC (rev 6450)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/DIA_requant.cpp	2010-07-14 12:17:22 UTC (rev 6451)
@@ -1,52 +0,0 @@
-/*
-    Dialog for lavcodec based Mpeg1/mpeg2 codec
-
-
-*/
-#include &quot;config.h&quot;
-
-#if 0
-#include &quot;ADM_lavcodec.h&quot;
-
-#include &quot;ADM_default.h&quot;
-
-#include &quot;ADM_codecs/ADM_codec.h&quot;
-#include &quot;ADM_encoder/ADM_vidEncode.hxx&quot;
-#include &quot;ADM_codecs/ADM_ffmpegConfig.h&quot;
-
-  
-#include &quot;DIA_factory.h&quot;
-#include &quot;../../ADM_encoder/adm_encmjpeg_param.h&quot;
-
-/**
-      \fn DIA_mjpegCodecSetting
-      \brief Dialog to set encoding options for Mjpeg lavcodec based
-*/
-//____________________________________________
-uint8_t DIA_requant(COMPRES_PARAMS *param)
-{
-  uint32_t *pp;
-  ELEM_TYPE_FLOAT fp;
-        ADM_assert(param-&gt;extraSettingsLen==sizeof(uint32_t));
-        pp=(uint32_t *)param-&gt;extraSettings;
-        
-       
-        fp=(ELEM_TYPE_FLOAT)(*pp);
-        fp/=1000;
-        
-       
-        uint8_t ret=0;
-        diaElemFloat  shrink(&amp;fp,QT_TR_NOOP(&quot;_Shrink Factor:&quot;),1,4.0);
-        
-        diaElem *elems[1]={&amp;shrink};
-        if( diaFactoryRun(QT_TR_NOOP(&quot;Requant Configuration&quot;),1,elems))
-        {
-            ret=1;
-            *pp=(uint32_t)(fp*1000);
-        }
-        return ret;
-        
-}   
-#endif
-// EOF
-

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/ADM_bitmapSource.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/ADM_bitmapSource.cpp	2010-07-14 12:17:20 UTC (rev 6450)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/ADM_bitmapSource.cpp	2010-07-14 12:17:22 UTC (rev 6451)
@@ -1,223 +0,0 @@
-/***************************************************************************
-      Front end for bitmap sources (vobsub, ts, sup,...)
-      (C) 2007 Mean
- ***************************************************************************/
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
- #include &quot;config.h&quot;
- #include &quot;ADM_default.h&quot;
-
- #include &quot;ADM_editor/ADM_edit.hxx&quot;
- #include &quot;ADM_videoFilter.h&quot;
- #include &quot;ADM_ocr.h&quot;
- #include &quot;ADM_ocrInternal.h&quot;
-  #include &quot;DIA_enter.h&quot;
-#include &quot;ADM_videoFilter/ADM_vidDvbSub.h&quot;
-
-/*  *****************************
- * 	**** Case 1 : Vobsub ********
- *  *****************************
- */
-
-class ADM_BitmapSource_VobSub : public ADM_BitmapSource
-{
-protected:
-			ADMVideoVobSub *_vobsub;
-			uint32_t		_nbPics;
-public: 
-								ADM_BitmapSource_VobSub(void);
-			virtual uint8_t     init(ADM_OCR_SOURCE *source);
-			virtual 			~ADM_BitmapSource_VobSub();
-			virtual uint32_t 	getNbImages(void);
-			virtual vobSubBitmap *getBitmap(uint32_t nb,uint32_t *start, uint32_t *end,uint32_t *first,uint32_t *last,uint32_t *eos);
-};
-
-ADM_BitmapSource_VobSub::ADM_BitmapSource_VobSub(void)
-{
-	_vobsub=NULL;
-	_nbPics=0;
-}
-ADM_BitmapSource_VobSub::~ADM_BitmapSource_VobSub()
-{
-	if(_vobsub) delete _vobsub;
-	_vobsub=NULL;
-}
-uint8_t     ADM_BitmapSource_VobSub::init(ADM_OCR_SOURCE *source)
-{
-	_vobsub=new ADMVideoVobSub(source-&gt;subparam-&gt;subname,source-&gt;subparam-&gt;index);
-	if(!_vobsub)
-	{
-		printf(&quot;[BitmapSource_VS] Cannot open source\n&quot;);
-		return 0;
-	}
-	_nbPics=_vobsub-&gt;getNbImage();
-	return 1;
-}
-uint32_t 	ADM_BitmapSource_VobSub::getNbImages(void)
-{
-	return _nbPics;
-}
-/**
- * 		\fn getBitmap
- * 		\brief returns a bitmap in black &amp; white (luma+alpha)
- * */
-vobSubBitmap *ADM_BitmapSource_VobSub::getBitmap(uint32_t nb,uint32_t *start, uint32_t *end,uint32_t *first,uint32_t *last,uint32_t *endofstream)
-{
-	*endofstream=0;
-	return _vobsub-&gt;getBitmap(nb,start, end,first,last);
-}
-/*  *****************************
- * 	**** Case 2 : TsSub  ********
- *  *****************************
- */
-#define TS_WIDTH  720
-#define TS_HEIGHT 576
-#define NO_STARTING_TIMECODE 0xFFFFFFF
-class ADM_BitmapSource_TsSub : public ADM_BitmapSource
-{
-protected:
-			uint32_t		_nbPics;
-			ADMVideoSubDVB  *_dvb;
-			vobSubBitmap    *_bitmap;
-			uint32_t		_firstTimeCode;
-public: 
-								ADM_BitmapSource_TsSub(void);
-			virtual uint8_t     init(ADM_OCR_SOURCE *source);
-			virtual 			~ADM_BitmapSource_TsSub();
-			virtual uint32_t 	getNbImages(void);
-			virtual vobSubBitmap *getBitmap(uint32_t nb,uint32_t *start, uint32_t *end,uint32_t *first,uint32_t *last,
-									uint32_t *eos);
-};
-
-ADM_BitmapSource_TsSub::ADM_BitmapSource_TsSub(void)
-{
-	_nbPics=0x7FFFF;
-	_dvb=NULL;
-	_bitmap=new vobSubBitmap(TS_WIDTH,TS_HEIGHT);
-	_firstTimeCode=NO_STARTING_TIMECODE;
-}
-ADM_BitmapSource_TsSub::~ADM_BitmapSource_TsSub()
-{
-	if(_dvb) delete _dvb;
-	_dvb=NULL;
-	if(_bitmap) delete _bitmap;
-	_bitmap=NULL;
-}
-uint8_t     ADM_BitmapSource_TsSub::init(ADM_OCR_SOURCE *source)
-{
-	_dvb=new ADMVideoSubDVB(source-&gt;TsFile,source-&gt;TsPid,TS_WIDTH,TS_HEIGHT);
-	
-	ADM_assert(_dvb);
-	return _dvb-&gt;init(source-&gt;TsFile);
-}
-uint32_t 	ADM_BitmapSource_TsSub::getNbImages(void)
-{
-	return _nbPics;
-}
-/**
- * 		\fn getBitmap
- * 		\brief returns a bitmap in black &amp; white (luma+alpha)
- *      @param nb : unused
- *      @start : Timecode of start (ms)
- * 		@end   : Timecode of end (ms)
- * 		@first : First non empty line
- * 		@last  : Last non empty line
- * */
-vobSubBitmap *ADM_BitmapSource_TsSub::getBitmap(uint32_t nb,uint32_t *start, uint32_t *end,uint32_t *first,uint32_t *last,uint32_t *endOfStream)
-{
-	uint32_t pts;
-	//
-	*endOfStream=0;
-	// First get our bitmap
-	  if(! _dvb-&gt;getNextBitmap(_bitmap,&amp;pts))
-	  {
-		  printf(&quot;[BitmapSource] cannot get next bitmap\n&quot;);
-		  *endOfStream=1;
-		  return NULL;
-	  }
-	  // First ?
-	  if(_firstTimeCode==NO_STARTING_TIMECODE)
-	  {
-		  _firstTimeCode=pts;
-	  }
-	  // Now build it
-	  // First &amp; last are the 1st and last non empty lines
-	  *first=0;
-	  *last=TS_HEIGHT-1;
-	  
-	  // Lookup the actual beginning /end
-	  uint32_t top=0;
-	   while(top&lt;TS_HEIGHT &amp;&amp; !_bitmap-&gt;isDirty(top) ) top++;
-	        
-	        if(top==TS_HEIGHT)
-	        {
-	                printf(&quot;[BitmapSource]Empty bitmap\n&quot;);
-	                return NULL; 
-	        }
-	  // 
-	        *first=top;
-	        
-	  // Now bottom
-	        uint32_t bottom=TS_HEIGHT-1;
-	        while(bottom&gt;top &amp;&amp; !_bitmap-&gt;isDirty(bottom) ) bottom--;
-	        if(bottom==top)
-	        {
-	        	   printf(&quot;[BitmapSource]Empty bitmap\n&quot;);
-	        	   return NULL; 
-	        }
-	        *last=bottom;
-	        
-	  // start &amp; end are timecodes
-#define WRAP_TIMECODE 0x3FFFFFFF
-	  if(pts&gt;_firstTimeCode)
-	  {
-		  *start=(pts-_firstTimeCode)/90;
-	  }else
-	  {
-		  *start=((WRAP_TIMECODE-pts)+_firstTimeCode)/90;
-	  }
-	  *end=*start+1000;
-			  
-	  // Set alpha as luma
-	  uint8_t *in,*out;
-	  in=_bitmap-&gt;_bitmap;
-	  out=_bitmap-&gt;_alphaMask;
-	  for(uint32_t yy=0;yy&lt;TS_HEIGHT;yy++)
-		  for(uint32_t xx=0;xx&lt;TS_WIDTH;xx++)
-		  {
-			  if(*in) *out=255;
-			  else *out=0;
-			  
-			  in++;
-			  out++;
-			  
-		  }
-		  
-	return _bitmap;
-}
-//**********************************************************
-//**********************************************************
-//**********************************************************
-/**
- * 	\fn ADM_buildBitmapSource
- * \brief Instantiate the correct bitmap source
-*/
-ADM_BitmapSource *ADM_buildBitmapSource(ADM_OCR_SOURCE *source)
-{
-	switch(source-&gt;type)
-	{
-			case ADM_OCR_TYPE_VOBSUB: 	return new ADM_BitmapSource_VobSub();
-			case ADM_OCR_TYPE_TS: 		return new ADM_BitmapSource_TsSub();
-			default:
-						printf(&quot;[BitmapSource] Unknown source type %d\n&quot;,source-&gt;type);
-						ADM_assert(0);
-	}
-	return NULL;
-}
-//EOF

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/ADM_leftturn.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/ADM_leftturn.h	2010-07-14 12:17:20 UTC (rev 6450)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/ADM_leftturn.h	2010-07-14 12:17:22 UTC (rev 6451)
@@ -1,17 +0,0 @@
-//
-// C++ Interface: %{MODULE}
-//
-// Description: 
-//
-//
-// Author: %{AUTHOR} &lt;%{EMAIL}&gt;, (C) %{YEAR}
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-#ifndef ADM_LEFTY
-#define ADM_LEFTY
-#include &quot;adm_glyph.h&quot;
-
-uint8_t adm_estimate_glyphSize(admGlyph *gl,uint32_t *minx, uint32_t *maxx,uint32_t *miny,uint32_t *maxy,int *raw);
-#endif 

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/ADM_ocr.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/ADM_ocr.cpp	2010-07-14 12:17:20 UTC (rev 6450)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/ADM_ocr.cpp	2010-07-14 12:17:22 UTC (rev 6451)
@@ -1,278 +0,0 @@
-/***************************************************************************
-      UI independant part of the OCR engine
-      (C) 2007 Mean
- ***************************************************************************/
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
- #include &quot;config.h&quot;
-#include &quot;ADM_default.h&quot;
-
- #include &quot;ADM_editor/ADM_edit.hxx&quot;
- #include &quot;ADM_videoFilter.h&quot;
- #include &quot;ADM_ocr.h&quot;
-#include &quot;ADM_ocrInternal.h&quot;
-  #include &quot;DIA_enter.h&quot;
-static uint32_t minThreshold=0x80;
-
-/* In the UI related code */
-extern void UI_purge(void);
-
-extern uint8_t adm_estimate_glyphSize(admGlyph *glyph,uint32_t *minx, uint32_t *maxx,uint32_t *miny,uint32_t *maxy,int *raw);
-
-static uint32_t minAlpha=7; /* Below minAlpha is is considered black */
-
-/**
-      \fn mergeBitmap
-      \brief Merge bitmap with alpha mask so that we go a black &amp; white output
-      @param bitin bitmap (input)
-      @param bitout B&amp;W bitmap (output)
-      @param maskin alpha mask (input)
-      @param w width of bitmap
-      @param h height of bitmap
-
-*/
-uint8_t mergeBitmap(uint8_t *bitin, uint8_t *bitout, uint8_t *maskin,uint32_t w, uint32_t h)
-{
-// Merge with alpha channel
-           uint8_t *in,*mask,*out;
-           uint32_t alp,nw;
-           in=bitin;
-           out=bitout;
-           mask=maskin;
-           for(uint32_t y=0;y&lt;h;y++)
-           {
-            for(uint32_t x=0;x&lt;w;x++)
-            {
-                   
-                    nw=in[x];
-                    alp=mask[x];
-
-                    if(alp&gt;minAlpha&amp;&amp; nw &gt;minThreshold)  nw=0xff;
-                         else       nw=0;
-                        
-                    out[x]=nw;
-            }
-            out+=w;
-            in+=w;
-            mask+=w;
-           }    
-    return 1;
-}
-/**
-      \fn ocrBitmap
-      \brief Split the bitmap into glyphes, ocr glyphes and output text
-      @param workArea, Bitmap to work with
-      @param w width of bitmap
-      @param h height of bitmap
-      @param decodedString Will contain ocr'ed text
-*/
-ReplyType ocrBitmap(uint8_t *workArea,uint32_t w,uint32_t h,char *decodedString,admGlyph *head)
-{
-uint8_t found;
-uint32_t colstart=0,colend=0,oldcol;
-uint32_t line=0,nbLine=1;
-uint32_t base=0,bottom,top;    
-ReplyType reply;
-    // Search First non nul colum
-    decodedString[0]=0;
-    // Search how much lines there is in the file
-    //
-    top=bottom=0;
-    while(top&lt;h)
-    {
-        // Search non empty line as top
-        while(top&lt;h &amp;&amp; lineEmpty(workArea,w,w,top)) top++;
-        // Nothing found
-        if(top&gt;=h-1) break;
-
-        // 
-       
-
-        bottom=top+1;
-        // Search empty line if any, bottom is the 1st line full of zero
-        while(bottom&lt;h &amp;&amp; (!lineEmpty(workArea,w,w,bottom) || bottom-top&lt;7))
-        {
-            bottom++;
-        }
-        if(line) strcat(decodedString,&quot;\n&quot;); 
-        //printf(&quot;\n Top:%lu bottom:%lu\n&quot;,top,bottom);
-       
-        // Scan a full line
-        colstart=0;
-        oldcol=0;
-       
-        // Split a line into glyphs
-        while(colstart&lt;w)
-        {
-            UI_purge();
-            oldcol=colstart;
-            while( columnEmpty(workArea+colstart+top*w, w, bottom-top) &amp;&amp; colstart&lt;w) colstart++;
-            if(colstart&gt;=w) break;
-            // if too far apart, it means probably a blank space
-            if(colstart-oldcol&gt;6)
-            {
-                strcat(decodedString,&quot; &quot;);
-            }
-       
-            // We have found a non null column
-            // Seek the end now
-            colend=colstart+1;
-            while( !columnEmpty(workArea+colend+top*w, w, bottom-top) &amp;&amp; colend&lt;w) colend++;
-         
-         
-            // printf(&quot;Found glyph: %lu %lu\n&quot;,colstart,colend);  
-            reply=handleGlyph(workArea,colstart,colend,w,bottom,top,head,decodedString);
-            switch(reply)
-                {
-                        case ReplySkip:break;
-                        case ReplyOk:break;
-                        case ReplyClose:
-                        case ReplyCalibrate: return reply;break;
-            
-                        case ReplySkipAll: return ReplyOk;break;
-                        default: ADM_assert(0);
-                }
-            
-            
-            colstart=colend;
-      }
-      line++;      
-      top=bottom;
-      
-    }
-   
-    return ReplyOk;
-}
-
-/**
-      \fn handleGlyph
-      \brief Handle ONE glyph
-      @param workArea full bitmap to OCR 
-      @param start Start column of glyph
-      @param end end column of glyph
-      @param w Width of bitmap
-      @param h Height of bitmap
-      @param base Baseline of glyph
-    We now have a good candidate for the glyph.
-    We will do the following processing :
-        - Clip the glyph to have it in its bounding box
-        - extract its container. If the container is smaller than the glyph, it means
-                that we have in fact several glyphs that overlaps slightly. In
-                that case we use another method to extract the glyph.
-                We split it using leftturn method and do it again.
-*/
-ReplyType handleGlyph(uint8_t *workArea,uint32_t start, uint32_t end,uint32_t w,uint32_t h,uint32_t base,
-							admGlyph *head,char *decodedString)
-{
-uint8_t found=0;
-static int inc=1;
-ReplyType reply;
-          
-    
-    // Ok now we have the cropped glyp
-    
-    admGlyph *glyph,*cand;
-    uint32_t minx,maxx,miny,maxy;
-    int     *raw=NULL;
-            glyph=new admGlyph(end-start,h-base);
-            glyph-&gt;create(workArea+start+base*w,w);
-            glyph=clippedGlyph(glyph);
-            if(!glyph-&gt;width) // Empty glyph
-            {
-                delete glyph;
-                return ReplyOk;
-            }
-            // now we have our full glyph, try harder to split it
-_nextglyph:
-            raw=new int[glyph-&gt;height];            
-            if(adm_estimate_glyphSize(glyph,&amp;minx, &amp;maxx,&amp;miny,&amp;maxy,raw))
-            {
-            //printf(&quot;Glyph width :%lu min:%lu max:%lu estimate width:%lu\n&quot;,glyph-&gt;width,minx,maxx,maxx-minx+1);
-            if((maxx-minx+2)&lt;glyph-&gt;width &amp;&amp; (maxx-minx&gt;2) &amp;&amp; (maxy-miny&gt;2))
-            {
-                // Suspicously too small
-                // We have to split the glyph
-                // recursively to extract each glyph
-                uint32_t width=maxx-minx+1;
-                uint32_t defStride=width+1;
-                
-                if(defStride&gt;glyph-&gt;width) defStride=glyph-&gt;width;
-                
-                admGlyph *lefty=new admGlyph(defStride,glyph-&gt;height);
-                for(int32_t i=miny;i&lt;=maxy;i++)
-                {
-                    if(raw[i]!=-1) memcpy(&amp;(lefty-&gt;data[0+i*defStride]),&amp;(glyph-&gt;data[minx+i*glyph-&gt;width]),raw[i]+1-minx);
-                    else
-                            memcpy(&amp;(lefty-&gt;data[0+i*defStride]),&amp;(glyph-&gt;data[minx+i*glyph-&gt;width]),defStride);
-                }
-                lefty=clippedGlyph(lefty);
-              
-                {
-                    // Remove that from the original
-                    for(uint32_t i=0;i&lt;glyph-&gt;height;i++)
-                    {
-                        //printf(&quot;%d:%d(%d)\n&quot;,i,raw[i],glyph-&gt;width);
-                        if(raw[i]!=-1) memset(&amp;(glyph-&gt;data[i*glyph-&gt;width]),0,raw[i]+1);
-                        else           memset(&amp;(glyph-&gt;data[i*glyph-&gt;width]),0,defStride); 
-                    }
-                    // Clip
-                    glyph=clippedGlyph(glyph);
-                
-                    if(lefty-&gt;width)
-                    {
-                        reply=glyphToText(lefty,head,decodedString);
-                        if(reply!=ReplyOk)
-                        {
-                            printf(&quot;Glyph2text failed(1)\n&quot;);
-                            return reply;
-                        }
-                    }
-                    else
-                        delete lefty;
-                    if(glyph-&gt;width)
-                    {
-                        if(raw) delete [] raw;
-                        goto _nextglyph;                    
-                    } 
-                 }           
-            }
-            }//If
-            if(raw) delete [] raw;
-            if(glyph-&gt;width)
-            {
-                reply=glyphToText(glyph,head,decodedString);
-                if(reply!=ReplyOk)                 
-                {
-                    printf(&quot;Glyph2text failed(2)\n&quot;);
-                    return reply;
-                }
-            }
-            else 
-            {
-                delete glyph;
-            }
-            
-    return ReplyOk;
-
-}
-/**
-      \fn ocrUpdateMinThreshold
-      \brief update the threshold to say black or white when we merge bitmap and alpha mask
-*/
-void ocrUpdateMinThreshold(void)
-{
-        int val;
-        val=minThreshold;
-        if(DIA_GetIntegerValue(&amp;val, 0x30, 0x80, &quot;Minimum pixel value&quot;, &quot;Enter new minimum pixel&quot;))
-        {
-                minThreshold=val;
-
-        }
-}
-//EOF

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/ADM_ocr.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/ADM_ocr.h	2010-07-14 12:17:20 UTC (rev 6450)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/ADM_ocr.h	2010-07-14 12:17:22 UTC (rev 6451)
@@ -1,41 +0,0 @@
-/***************************************************************************
-                         
-     External Interface for OCR engine
-     
-    copyright            : (C) 2007 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifndef ADM_OCR_H
-#define ADM_OCR_H
-#include &quot;ADM_videoFilter/ADM_vobsubinfo.h&quot;
-#include &quot;ADM_videoFilter/ADM_vidVobSub.h&quot;
-#include &quot;ADM_ocr/adm_glyph.h&quot;
-typedef enum
-{
-	ADM_OCR_TYPE_VOBSUB=1,
-	ADM_OCR_TYPE_TS=2,
-}ADM_OCR_SOURCE_TYPE;
-
-
-typedef struct
-{
-	ADM_OCR_SOURCE_TYPE type;
-	vobSubParam *subparam;
-	char		*TsFile;
-	uint32_t    TsPid;
-}ADM_OCR_SOURCE;
-
-
-uint8_t ADM_ocr_engine(   ADM_OCR_SOURCE &amp; source,const char *labelSrt,admGlyph *head);
-
-
-#endif 

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/ADM_ocrEngine.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/ADM_ocrEngine.cpp	2010-07-14 12:17:20 UTC (rev 6450)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/ADM_ocrEngine.cpp	2010-07-14 12:17:22 UTC (rev 6451)
@@ -1,191 +0,0 @@
-/***************************************************************************
-      UI independant part of the OCR engine
-      (C) 2007 Mean
- ***************************************************************************/
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
- #include &quot;config.h&quot;
-#include &quot;ADM_default.h&quot;
-
- #include &quot;ADM_editor/ADM_edit.hxx&quot;
- #include &quot;ADM_videoFilter.h&quot;
- #include &quot;ADM_ocr.h&quot;
- #include &quot;ADM_ocrInternal.h&quot;
- #include &quot;DIA_coreToolkit.h&quot;
-
-#include &quot;ADM_video/ADM_vidMisc.h&quot;
-
-/**************************
- *  UI Dependant part
- *************************/
-uint8_t ADM_ocrUpdateNbLines(void *ui,uint32_t cur,uint32_t total);
-uint8_t ADM_ocrUpdateNbGlyphs(void *ui,uint32_t nbGlyphs);
-uint8_t ADM_ocrUpdateTextAndTime(void *ui,char *decodedString,char *timeCode);
-uint8_t ADM_ocrDrawFull(void *d,uint8_t *data);
-uint8_t ADM_ocrUiEnd(void *d);
-void 	*ADM_ocrUiSetup(void);
-uint8_t ADM_ocrSetRedrawSize(void *ui,uint32_t w,uint32_t h);
-
-extern void UI_purge(void);
-/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++
-        Main
-   +++++++++++++++++++++++++++++++++++++++++++++++++++++++ */
-
-/**
- * 		\fn 		ADM_ocr_engine
- * 		\brief 		Common part of the OCR engine
- */
-uint8_t ADM_ocr_engine(ADM_OCR_SOURCE &amp; source,const char *labelSrt,admGlyph *head)
-{
-    uint32_t nbSub=0;
-    FILE *out=NULL;
-    vobSubBitmap *bitmap=NULL;
-    ADM_BitmapSource *bitmapSource=NULL;
-    uint32_t startTime,endTime;
-    uint32_t w,h,oldw=0,oldh=0;
-    uint32_t oldbitmapw=0;
-    uint32_t oldbitmaph=0;
-    uint32_t first,last;
-    uint32_t seqNum;
-    char     text[1024];
-    ReplyType reply;
-    void *ui=NULL;
-    char decodedString[1024];
-    uint8_t *workArea=NULL;
-    uint32_t nbGlyphs=0;
-    
-    ui=ADM_ocrUiSetup();
-    
-    int success = 1;
-
-_again:    
-    
-    UI_purge();
- 
-    out=fopen(labelSrt,&quot;wb&quot;);
-    if(!out)
-    {
-        success = 0;
-       GUI_Error_HIG(QT_TR_NOOP(&quot;Output file error&quot;), QT_TR_NOOP(&quot;Could not open \&quot;%s\&quot; for writing.&quot;), labelSrt);
-       goto endIt;
-    }
-
-    bitmapSource=ADM_buildBitmapSource(&amp;source);
-    if(!bitmapSource)
-    {
-        success = 0;
-        GUI_Error_HIG(QT_TR_NOOP(&quot;Input file error&quot;), QT_TR_NOOP(&quot;Unknown source type&quot;));
-        goto endIt;
-    }
-    if(!bitmapSource-&gt;init(&amp;source))
-    {
-        success = 0;
-        GUI_Error_HIG(QT_TR_NOOP(&quot;Input file error&quot;), QT_TR_NOOP(&quot;Bitmap source failed&quot;));
-        goto endIt;
-    }
-    
-    nbSub=bitmapSource-&gt;getNbImages();
-    if(!nbSub)
-    {
-        success = 0;
-        GUI_Error_HIG(QT_TR_NOOP(&quot;Problem loading sub&quot;),QT_TR_NOOP(&quot;No subs&quot;));
-        goto endIt;
-     }
-
-    seqNum=1;   // Sub number in srt file
-    oldw=oldh=0;
-    uint32_t eos;
-    //******************    
-    // Load all bitmaps
-    //******************
-    for(uint32_t i=0;i&lt;nbSub;i++)
-    {
-            first=last=0;
-            bitmap=bitmapSource-&gt;getBitmap(i,&amp;startTime, &amp;endTime,&amp;first,&amp;last,&amp;eos);
-            if(eos) break;
-            ADM_assert(last&gt;=first);
-            
-            if(!bitmap) continue;
-            if(first==last) continue;
-
-            // If the bitmap size changed or does not exist yet...
-            if(!workArea || oldbitmapw!=bitmap-&gt;_width || oldbitmaph!=bitmap-&gt;_height)
-            {
-              if(workArea) 
-              {
-                delete [] workArea;
-                workArea=NULL; 
-              }
-              // Workarea is actually bigger than what we use
-              workArea=new uint8_t[bitmap-&gt;_width*(bitmap-&gt;_height)];
-              memset(workArea,0,bitmap-&gt;_width*(bitmap-&gt;_height));
-            }
-            oldbitmaph=bitmap-&gt;_height;
-            oldbitmapw=bitmap-&gt;_width;
-
-           w=bitmap-&gt;_width;
-           h=last-first+1;
-           
-           ADM_ocrSetRedrawSize(ui,w,h);
-           
-           // Build
-againPlease:
-           mergeBitmap(bitmap-&gt;_bitmap+first*w, workArea, bitmap-&gt;_alphaMask+first*w,  w,   h);
-           if(oldw!=w || oldh !=h)
-           {                
-                UI_purge();  // Force redaw
-           }
-           // Merge &amp; draw
-             ADM_ocrDrawFull(ui,workArea);
-             // OCR
-              reply=ocrBitmap(workArea,w,h,decodedString,head);
-              if(reply==ReplyClose) goto endIt;
-              if(reply==ReplyCalibrate)
-                {
-                        ocrUpdateMinThreshold();
-                        goto againPlease;
-                }
-             
-             fprintf(out,&quot;%d\n&quot;,seqNum++);
-             uint16_t hh,mm,ss,ms;
-             ms2time(startTime, &amp;hh, &amp;mm, &amp;ss, &amp;ms);
-             fprintf(out,&quot;%02d:%02d:%02d,%03d --&gt; &quot;,hh,mm,ss,ms);
-             
-             // Update Timecode
-             char timeCode[100];
-             snprintf(timeCode,100,&quot;%02d:%02d:%02d,%03d&quot;,hh,mm,ss,ms);
-             ADM_ocrUpdateTextAndTime(ui,decodedString,timeCode);
-             
-             ms2time(endTime, &amp;hh, &amp;mm, &amp;ss, &amp;ms);
-             fprintf(out,&quot;%02d:%02d:%02d,%03d\n&quot;,hh,mm,ss,ms);
-             fprintf(out,&quot;%s\n\n&quot;,decodedString);
-
-             oldw=w;
-             oldh=h;
-             // Update infos
-             ADM_ocrUpdateNbLines(ui,i+1,nbSub);
-             ADM_ocrUpdateNbGlyphs(ui,nbGlyphs);
-    }
-
-endIt:
-	ADM_ocrUiEnd(ui);
-	ui=NULL;
-    
-    if(out) 
-          fclose(out);
-      out=NULL;
-      
-      if(bitmapSource)
-    	        delete bitmapSource;
-    	    bitmapSource=NULL;
-      
-    return success;
-}
-
-//EOF

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/ADM_ocrInternal.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/ADM_ocrInternal.h	2010-07-14 12:17:20 UTC (rev 6450)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/ADM_ocrInternal.h	2010-07-14 12:17:22 UTC (rev 6451)
@@ -1,51 +0,0 @@
-/***************************************************************************
-                         
-     Internal Interface for OCR engine
-     
-    copyright            : (C) 2007 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-#ifndef ADM_OCR_INTERNAL_H
-#define ADM_OCR_INTERNAL_H
- 
-#include &quot;adm_glyph.h&quot;
-
-
-typedef enum 
-{
-        ReplyOk=1,
-        ReplyClose=0,
-        ReplyCalibrate=2,
-        ReplySkip=3,
-        ReplySkipAll=4
-}ReplyType;
-
-// GUI independant part
-ReplyType handleGlyph(uint8_t *workArea,uint32_t start, uint32_t end,uint32_t w,uint32_t h,uint32_t base,
-							admGlyph *head,char *decodedstring);
-ReplyType ocrBitmap(uint8_t *workArea,uint32_t w,uint32_t h,char *decodedString,admGlyph *head);
-uint8_t   mergeBitmap(uint8_t *bitin, uint8_t *bitout, uint8_t *maskin,uint32_t w, uint32_t h);
-void 	  ocrUpdateMinThreshold(void);
-
-// In GUI dependant part
-ReplyType glyphToText(admGlyph *glyph,admGlyph *head,char *decodedString);
-
-/**
- * \class ADM_BitmapSource
- * \brief Front end base class for all OCR'able bitmap source
- */
-class ADM_BitmapSource
-{
-				
-public: 
-								ADM_BitmapSource(void) {};
-			virtual uint8_t     init(ADM_OCR_SOURCE *source)=0;
-			virtual 			~ADM_BitmapSource() {};
-			virtual uint32_t 	getNbImages(void)=0;
-			virtual vobSubBitmap *getBitmap(uint32_t nb,uint32_t *start, uint32_t *end,uint32_t *first,uint32_t *last,
-											uint32_t *eos)=0;
-};
-ADM_BitmapSource *ADM_buildBitmapSource(ADM_OCR_SOURCE *source);
-
-#endif 

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/ADM_vob2vobsub.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/ADM_vob2vobsub.cpp	2010-07-14 12:17:20 UTC (rev 6450)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/ADM_vob2vobsub.cpp	2010-07-14 12:17:22 UTC (rev 6451)
@@ -1,551 +0,0 @@
-/***************************************************************************
-                         Vob2vobsub
-                      -------------------
-          Convert a set of vobs to a vobsub file
-          * missing : 
-                size 720*576 
-                palette
-                languages
-                Multiple sub           
-                      
-     IFO reading from mplayer, everything else from me
-                      
-    copyright            : (C) 2005 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &quot;config.h&quot;
-
-#include &quot;ADM_default.h&quot;
-#include &lt;math.h&gt;
-
-#include &lt;time.h&gt;
-#include &lt;sys/time.h&gt;
-
-#include &quot;DIA_coreToolkit.h&quot;
-
-
-#include &quot;ADM_audio/aviaudio.hxx&quot;
-#include &quot;ADM_audiofilter/audioprocess.hxx&quot;
-
-#include &quot;DIA_fileSel.h&quot;
-#include &quot;ADM_inputs/ADM_mpegdemuxer/dmx_demuxer.h&quot;
-#include &quot;ADM_inputs/ADM_mpegdemuxer/dmx_demuxerPS.h&quot;
-#include &quot;ADM_userInterfaces/ADM_commonUI/DIA_working.h&quot;
-
-#include &quot;ADM_video/ADM_vidMisc.h&quot;
-
-#define ADM_VOBSUB_NO_PADDING
-static int vobsub_parse_ifo(const char *const name, 
-                     uint32_t *palette, 
-                     uint32_t *width, uint32_t *height, 
-		             char *language);
-static uint8_t dumpHeader(FILE *fd,int index,uint32_t w,uint32_t h,uint32_t *palette);
-static void padd(int nb,FILE *fd);
-
-static uint8_t  *padder;
-
-#define PADDER_SIZE 0x800
-
-#define MAX_LINE        5000
-#define MAX_BUFFER      (1*1024)
-#define MAX_LANGUAGE    10
-
-#define MIN_WRAP_VALUE (90*1000*60*1) // 1 mn
-
-typedef struct oneLine
-{
-    uint64_t pts;
-    uint32_t start;
-}oneLine;
-
-class OneTrack
-{
-protected:         
-            char        language[2];   
-            uint8_t     *base;
-            uint32_t    limit;
-            uint32_t    index;
-            oneLine     *lines;
-            uint32_t    nbLines;
-            int         runCode;
-            uint64_t    currentPTS;
-            int         firstOne;
-            
-            uint8_t     addData(uint8_t *data,uint32_t len);
-            uint8_t     addLine(uint64_t pts,uint32_t start);
-            uint8_t     grow(void);
-public:    
-            uint8_t     run(uint16_t twofirst,uint8_t *data,uint32_t size,uint32_t usableSize,uint64_t pts);
-            uint8_t     setLang(char *lang);
-            uint8_t     dump(uint32_t index,FILE *fdIdx, FILE *fdSub,uint32_t *out);
-                        OneTrack(void);
-                        ~OneTrack();
-};
-
-OneTrack::OneTrack(void)
-{
-    
-    base=new uint8_t[  MAX_BUFFER];
-    limit= MAX_BUFFER;
-    index=0;
-    lines=new oneLine[MAX_LINE];
-    nbLines=0;  
-    runCode=0;
-    
-}
-uint8_t OneTrack::setLang(char *lang)
-{
-    language[0]=lang[0];
-    language[1]=lang[1];
-    return 1;
-}
-OneTrack::~OneTrack()
-{
-    delete [] base;
-    delete [] lines;
-}
- uint8_t     OneTrack::addData(uint8_t *data,uint32_t len)
-{
-    while(len+index&gt;limit) grow();
-    
-    memcpy(base+index,data,len);
-    index+=len;
-    return 1;   
-}
-uint8_t     OneTrack::grow(void)
-{
-    uint8_t *nw;
-    nw=new uint8_t[2*limit];
-    memcpy(nw,base,limit);
-    delete [] base;
-    base=nw;
-    limit*=2;
-    return 1;   
-    
-}
- uint8_t     OneTrack::addLine(uint64_t pts,uint32_t start)
-{
-    if(nbLines&gt;=MAX_LINE) return 0;
-    lines[nbLines].pts=pts;
-    lines[nbLines].start=start;
-        
-    nbLines++;
-    return 1;   
-}
-uint8_t     OneTrack::dump(uint32_t number,FILE *fdIdx, FILE *fdSub,uint32_t *out)
-{
-    uint16_t hh,mm,ss,ms;
-    uint32_t timestamp;
-    uint32_t original,position;
-    original=ftello(fdSub); // Current position, we start from here
-      
-    if(!index) return 1;
-  
-    fwrite(base,index,1,fdSub); // Append our datas
-    
-    
-    fprintf(fdIdx,&quot;# English\n&quot;);
-    fprintf(fdIdx,&quot;id: %c%c, index: %d\n&quot;,language[0],language[1],number);
-    fprintf(fdIdx,&quot;# Decomment next line to activate alternative name in DirectVobSub / Windows Media Player 6.x\n&quot;);
-    fprintf(fdIdx,&quot;# alt: English\n&quot;);
-    fprintf(fdIdx,&quot;# Vob/Cell ID: 1, 1 (PTS: 0)\n&quot;);
-    (*out)++;
-    for(int i=0;i&lt;nbLines;i++) // We shift PTS &amp; position by 1 to workaround the display bug
-    {   
-        if(lines[i].pts!=ADM_NO_PTS)
-        {     
-            timestamp=(uint32_t)floor(lines[i].pts/90.);
-            ms2time(timestamp,&amp;hh,&amp;mm,&amp;ss,&amp;ms);
-            position=lines[i].start;
-            //printf(&quot;Stream :%d position :%x offset:%x total:%x\n&quot;,i,position,original,original+position);
-            position+=original;          
-            fprintf(fdIdx,&quot;timestamp: %02d:%02d:%02d:%03d, filepos: %08x\n&quot;,hh,mm,ss,ms,position); 
-        }
-        else
-        {
-                printf(&quot;Sub %d, skipped line at %d\n&quot;,number,i);
-        }
-    }
-    return 1;
-}
-uint8_t     OneTrack::run(uint16_t twofirst,uint8_t *data,uint32_t size,uint32_t usableSize,uint64_t pts)
-{
-uint32_t padding;
-    
-    if(!runCode) // new line
-    {
-        currentPTS=pts;
-        runCode=twofirst-usableSize;
-        addLine(pts,index);
-#if 0
-        {
-        uint16_t hh,mm,ss,ms;
-        uint32_t timestamp;
-
-              timestamp=pts/90;
-              ms2time(timestamp,&amp;hh,&amp;mm,&amp;ss,&amp;ms);
-              printf(&quot;Line : %03u  at %02d:%02d:%02d \n&quot;,nbLines,hh,mm,ss);
-        }
-#endif
-        addData(data,size);
-        if(runCode&lt;0) runCode=0;
-        return 1; 
-    }
-    if(currentPTS==ADM_NO_PTS &amp;&amp; pts!=ADM_NO_PTS)
-        currentPTS=lines[nbLines-1].pts=pts;
-    runCode-=usableSize;
-    if(runCode&lt;0)
-    {
-         printf(&quot;Overrun %d\n&quot;,runCode);
-         runCode=0;
-    }
-    addData(data,size);
-    return 1;
-    
-} 
-/*
-    nameVob     : path + name of the 1st .vob file
-    nameVobSub  : path+name of the .idx file to write
-    nameIfo     : path+name of the ifo file
-
-
-*/
-//**********************************************
-uint8_t ADM_vob2vobsub(char *nameVob, char *nameVobSub, char *nameIfo)
-{
-   dmx_demuxerPS *demuxer=NULL;
-   DIA_working *working=NULL;
-   MPEG_TRACK track;
-   FILE *indexFile=NULL;
-   FILE *indexSub=NULL;
-   uint32_t palette[16],width,height;
-   uint64_t abs,rel,size,pts;
-   int blockSize;
-   uint8_t *data,stream;
-   char *subname;
-   double percent;
-   uint32_t packetLen,usedLen,read;
-   OneTrack allIndex[MAX_LANGUAGE];
-   char language[MAX_LANGUAGE*4];
-#ifdef  TEST_V2V  
-   nameIfo=&quot;d:/Crime/VTS_01_0.IFO&quot;;
-   nameVobSub=&quot;toto.idx&quot;;
-#endif
-   
-        printf(&quot;v2v: Ifo:%s Vob:%s Vsub:%s\n&quot;,nameIfo,nameVob,nameVobSub);
-
-   memset(language,0,sizeof(language));
-   memset(palette,0,sizeof(uint32_t)*16);
-   if(!vobsub_parse_ifo(nameIfo,palette,&amp;width,&amp;height,language))
-   {
-     GUI_Error_HIG(QT_TR_NOOP(&quot;Ifo error&quot;),QT_TR_NOOP(&quot;Error reading ifo file, aborting.&quot;));   
-        return 0;
-   } 
-   printf(&quot;Ifo: %d x %d\n&quot;,width,height);                 
-   
-   indexFile=fopen(nameVobSub,&quot;wt&quot;);
-   if(!indexFile)
-   {
-     GUI_Error_HIG(QT_TR_NOOP(&quot;Cannot write .idx&quot;),NULL);              
-        return 0;
-    }
-   subname=ADM_strdup(nameVobSub);
-   size=strlen(subname);
-   subname[size-3]='s';
-   subname[size-2]='u';
-   subname[size-1]='b';
-   indexSub=fopen(subname,&quot;wb&quot;);
-   ADM_dealloc(subname);
-    if(!indexSub)
-    {
-        fclose(indexFile);
-        GUI_Error_HIG(QT_TR_NOOP(&quot;Cannot write .sub&quot;),NULL);
-        return 0;
-    }
-   for(int i=0;i&lt;MAX_LANGUAGE;i++)
-   {
-         allIndex[i].setLang(language+i*3);  
-   }
-   track.pes=0x20;
-   track.pid=track.pes;
-   demuxer=new  dmx_demuxerPS(1,&amp;track,1);
-   if(!demuxer-&gt;open(nameVob))
-   {
-     GUI_Error_HIG(QT_TR_NOOP(&quot;Problem opening the mpeg files&quot;),NULL);
-        delete demuxer;
-        fclose(indexFile);
-        fclose(indexSub);
-        return 0;   
-   }
-   
-   
-   size=demuxer-&gt;getSize();
-   
-    int display=0;
-    
-   dumpHeader(indexFile,0,width,height,palette);
-   working=new DIA_working(QT_TR_NOOP(&quot;Generating VobSub file&quot;));
-   
-   //*** Main Loop ***
-   uint32_t startPts=0,lastPts=0;
-   uint16_t hh,mm,ss,ms;
-   uint32_t timestamp;
-   while(1)
-   {
-       if(!demuxer-&gt;forceRefill(&amp;stream)) goto _abt;
-       demuxer-&gt;getPos(&amp;abs,&amp;rel);
-       display++;
-       if(display&gt;20)
-       {
-        working-&gt;update(abs&gt;&gt;10,size&gt;&gt;10);
-        display=0;
-       }
-#ifdef TEST_V2V       
-       //if(abs&gt;200*1024*1024) break;
-#endif       
-       if(stream&gt;=0x20 &amp;&amp; stream&lt;0x20+MAX_LANGUAGE)
-       {
-            demuxer-&gt;getPacketInfo(&amp;data,&amp;packetLen,&amp;usedLen,&amp;pts);
-            if(pts!=ADM_NO_PTS)
-            {
-                        // Wrap around ?
-                        if(lastPts)
-                        {
-                                if(pts&lt;lastPts)
-                                {
-                                        if(lastPts-pts&gt;MIN_WRAP_VALUE)
-                                        {
-                                                
-                                                printf(&quot;Wrapping at %u &quot;,lastPts);
-                                                startPts+=lastPts;
-                                                timestamp=startPts/90;
-                                                ms2time(timestamp,&amp;hh,&amp;mm,&amp;ss,&amp;ms);
-                                                printf(&quot;%02d:%02d:%02d \n&quot;,hh,mm,ss);
-                                        }
-                                }
-                        }
-
-                        lastPts=pts;
-                        pts+=startPts;
-            }
-#if 0
-            if(pts!=ADM_NO_PTS)
-            {
-              timestamp=pts/90;
-              ms2time(timestamp,&amp;hh,&amp;mm,&amp;ss,&amp;ms);
-              printf(&quot;%02d:%02d:%02d \n&quot;,hh,mm,ss);
-            }
-#endif
-            blockSize=demuxer-&gt;read16i();
-            allIndex[stream-0x20].run(blockSize,data,packetLen,usedLen, pts)  ;
-       }
-    }
-  //*** /Main Loop ***     
-  _abt:
-  uint32_t out=0,padding;
-  for(int i=0;i&lt;MAX_LANGUAGE;i++)
-  {
-      allIndex[i].dump(i,indexFile, indexSub,&amp;out);  
-      padding=ftello(indexSub);
-      printf(&quot;Padding : was %x &quot;,padding);
-      padding=padding+PADDER_SIZE-1;
-      padding&amp;=0xffffffff^(PADDER_SIZE-1);  
-      fseeko(indexSub,padding,SEEK_SET);  
-      printf(&quot; -&gt; %x\n&quot;,padding);
-  }
-  
-  
-  printf(&quot;scan done %&quot;LLU&quot;/%&quot;LLU&quot;\n&quot;,abs,size); 
-  delete working;
-  delete demuxer;     
-  fclose(indexFile);
-  fclose(indexSub);
-  return 1;
-    
-}
-/*
-Borrowed from Mplayer
-*/
-
-extern void mixDump(uint8_t *p,uint32_t l);
-int vobsub_parse_ifo(const char *const name, 
-                     uint32_t *palette, 
-                     uint32_t *width, uint32_t *height, 
-		             char *language)
-{
-    int ret = 0;
-    FILE *fd = fopen(name, &quot;rb&quot;);
-    if(!fd) return 0;
-    
-	// parse IFO header
-	unsigned char block[0x800];
-	const char *const ifo_magic = &quot;DVDVIDEO-VTS&quot;;
-	if (fread(block, sizeof(block), 1, fd) != 1) 
-	{
-    	fclose(fd);
-    	return 0;
-    }
-    if(memcmp(block,ifo_magic,strlen(ifo_magic+1)))
-    {
-        printf(&quot;Bad ifo magic\n&quot;);
-        fclose(fd);
-    	return 0;
-    }
-	    unsigned long pgci_sector = block[0xcc] &lt;&lt; 24 | block[0xcd] &lt;&lt; 16
-		| block[0xce] &lt;&lt; 8 | block[0xcf];
-	    int standard = (block[0x200] &amp; 0x30) &gt;&gt; 4;
-	    int resolution = (block[0x201] &amp; 0x0c) &gt;&gt; 2;
-	    *height = standard ? 576 : 480;
-	    *width = 0;
-	    switch (resolution) {
-	    case 0x0:
-		*width = 720;
-		break;
-	    case 0x1:
-		*width = 704;
-		break;
-	    case 0x2:
-		*width = 352;
-		break;
-	    case 0x3:
-		*width = 352;
-		*height /= 2;
-		break;
-	    default:
-		printf(&quot;Vobsub: Unknown resolution %d \n&quot;, resolution);
-	    }
-	    unsigned  int tmp=0;
-	    for(int lg=0;lg&lt;MAX_LANGUAGE;lg++)
-	    {
-		    tmp= 0x256 + lg * 6 + 2;
-		    //printf(&quot;Lang :%d %c%c\n&quot;,lg,block[tmp],block[tmp+1]);//tmp[0],tmp[1]);
-		    language[lg*3+0]=block[tmp];
-		    language[lg*3+1]=block[tmp+1];
-            language[lg*3+2]=0;
-		}
-	    if (fseeko(fd, pgci_sector * sizeof(block), SEEK_SET)
-		|| fread(block, sizeof(block), 1, fd) != 1)
-		 {}
-		 else
-		 {
-	    
-		        unsigned long idx,r,g,b,y,u,v;
-		        unsigned long pgc_offset = block[0xc] &lt;&lt; 24 | block[0xd] &lt;&lt; 16
-		                 | block[0xe] &lt;&lt; 8 | block[0xf];
-		        // 8+32*4+8*2+4+dvd_time_t+user_ops_t
-		        // 9c+dvd_time+user_ops_t=9c+4+8=0xA8  
-		        //mixDump(block,0x800);      
-		        for (idx = 0; idx &lt; 16; ++idx) 
-		        {
-  		        
-		            unsigned char *p = block + pgc_offset + 0xa4 + 4 * idx; 
-#if 1
-                        r=p[1];g=p[2];b=p[3];
-                       // palette[idx] = r &lt;&lt; 16 | g &lt;&lt; 8 | b;
-                        palette[idx] = r &lt;&lt; 16 | r &lt;&lt; 8 | r;
-#else		            
-		                y=p[1];u=p[2];v=p[3];
-		                float rr,bb,gg;
-	                    float yy=y,uu=u-128,vv=v-128;
-
-	                    rr=	yy+			 	1.402*vv;
-	                    gg= yy+ 	-0.344*uu+  	-0.714*vv;
-	                    bb=	yy+ 	1.772*uu 	 		;
-
-	#define CLIP(x) if(x&gt;255) x=255; else if (x&lt;0) x=0;x=x+0.49;
-		                CLIP(rr);CLIP(gg);CLIP(bb);
-		                r=(unsigned long int)rr;
-		                g=(unsigned long int)gg;
-		                b=(unsigned long int)bb;
-		                //palette[idx] = p[0] &lt;&lt; 24 | p[1] &lt;&lt; 16 | p[2] &lt;&lt; 8 | p[3];
-		                palette[idx] = r &lt;&lt; 16 | g &lt;&lt; 8 | b;
-#endif		                
-		        }
-		        ret= 1;
-	     }
-_ifo_abt:		
-	    fclose(fd);
-    
-    return ret;
-}
-
-/**********************************************************************
-
-
-***********************************************************************/
-static uint8_t dumpHeader(FILE *fd,int index,uint32_t w,uint32_t h,uint32_t *palette)
-{
-    fprintf(fd,&quot;# VobSub index file, v7 (do not modify this line!)\n&quot;);
-    fprintf(fd,&quot;# \n&quot;);
-    fprintf(fd,&quot;# To repair desyncronization, you can insert gaps this way:\n&quot;);
-    fprintf(fd,&quot;# (it usually happens after vob id changes)\n&quot;);
-    fprintf(fd,&quot;# \n&quot;);
-    fprintf(fd,&quot;#	 delay: [sign]hh:mm:ss:ms\n&quot;);
-    fprintf(fd,&quot;# \n&quot;);
-    fprintf(fd,&quot;# Where:\n&quot;);
-    fprintf(fd,&quot;#	 [sign]: +, - (optional)\n&quot;);
-    fprintf(fd,&quot;#	 hh: hours (0 &lt;= hh)\n&quot;);
-    fprintf(fd,&quot;#	 mm/ss: minutes/seconds (0 &lt;= mm/ss &lt;= 59)\n&quot;);
-    fprintf(fd,&quot;#	 ms: milliseconds (0 &lt;= ms &lt;= 999)\n&quot;);
-    fprintf(fd,&quot;# \n&quot;);
-    fprintf(fd,&quot;#	 Note: You can't position a sub before the previous with a negative value.\n&quot;);
-    fprintf(fd,&quot;# \n&quot;);
-    fprintf(fd,&quot;# You can also modify timestamps or delete a few subs you don't like.\n&quot;);
-    fprintf(fd,&quot;# Just make sure they stay in increasing order.\n&quot;);
-    fprintf(fd,&quot;\n&quot;);
-    fprintf(fd,&quot;\n&quot;);
-    fprintf(fd,&quot;# Settings\n&quot;);
-    fprintf(fd,&quot;\n&quot;);
-    fprintf(fd,&quot;# Original frame size\n&quot;);
-    fprintf(fd,&quot;size: %dx%d\n&quot;,w,h);
-    fprintf(fd,&quot;\n&quot;);
-    fprintf(fd,&quot;# Origin, relative to the upper-left corner, can be overloaded by aligment\n&quot;);
-    fprintf(fd,&quot;org: 0, 0\n&quot;);
-    fprintf(fd,&quot;\n&quot;);
-    fprintf(fd,&quot;# Image scaling (hor,ver), origin is at the upper-left corner or at the alignment coord (x, y)\n&quot;);
-    fprintf(fd,&quot;scale: 100%%, 100%%\n&quot;);
-    fprintf(fd,&quot;\n&quot;);
-    fprintf(fd,&quot;# Alpha blending\n&quot;);
-    fprintf(fd,&quot;alpha: 100%%\n&quot;);
-    fprintf(fd,&quot;\n&quot;);
-    fprintf(fd,&quot;# Smoothing for very blocky images (use OLD for no filtering)\n&quot;);
-    fprintf(fd,&quot;smooth: OFF\n&quot;);
-    fprintf(fd,&quot;\n&quot;);
-    fprintf(fd,&quot;# In millisecs\n&quot;);
-    fprintf(fd,&quot;fadein/out: 50, 50\n&quot;);
-    fprintf(fd,&quot;\n&quot;);
-    fprintf(fd,&quot;# Force subtitle placement relative to (org.x, org.y)\n&quot;);
-    fprintf(fd,&quot;align: OFF at LEFT TOP\n&quot;);
-    fprintf(fd,&quot;\n&quot;);
-    fprintf(fd,&quot;# For correcting non-progressive desync. (in millisecs or hh:mm:ss:ms)\n&quot;);
-    fprintf(fd,&quot;# Note: Not effective in DirectVobSub, use \&quot;delay: ... \&quot; instead.\n&quot;);
-    fprintf(fd,&quot;time offset: 0\n&quot;);
-    fprintf(fd,&quot;\n&quot;);
-    fprintf(fd,&quot;# ON: displays only forced subtitles, OFF: shows everything\n&quot;);
-    fprintf(fd,&quot;forced subs: OFF\n&quot;);
-    fprintf(fd,&quot;\n&quot;);
-    fprintf(fd,&quot;# The original palette of the DVD\n&quot;);
-    fprintf(fd,&quot;palette:&quot;);
-    for(int k=0;k&lt;16;k++) // 131313, efefef, efefef, ffffff, ffffff, ffffff, ffffff, ffffff, ffffff, ffffff, ffffff, ffffff, ffffff, ffffff, ffffff, ffffff\n&quot;);
-    {
-        if(k) fprintf(fd,&quot;, &quot;);
-        fprintf(fd,&quot;%06x&quot;,palette[k]);
-    }
-    fprintf(fd,&quot;\n&quot;);
-    fprintf(fd,&quot;# Custom colors (transp idxs and the four colors)\n&quot;);
-    fprintf(fd,&quot;custom colors: OFF, tridx: 0000, colors: 000008, 300030, 000030, 9332c8\n&quot;);
-    fprintf(fd,&quot;\n&quot;);
-    fprintf(fd,&quot;# Language index in use\n&quot;);
-    fprintf(fd,&quot;langidx: %d\n&quot;,0);
-    fprintf(fd,&quot;\n&quot;);
-    return 1;  
-}

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/CMakeLists.txt	2010-07-14 12:17:20 UTC (rev 6450)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/CMakeLists.txt	2010-07-14 12:17:22 UTC (rev 6451)
@@ -1,7 +0,0 @@
-SET(ADM_ocr_SRCS 
-	adm_glyph.cpp  adm_leftturn.cpp  ADM_vob2vobsub.cpp
-	ADM_ocr.cpp
-	ADM_bitmapSource.cpp
-	ADM_ocrEngine.cpp)
-
-ADD_ADM_LIB_ALL_TARGETS(ADM_ocr ${ADM_ocr_SRCS})
\ No newline at end of file

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/adm_glyph.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/adm_glyph.cpp	2010-07-14 12:17:20 UTC (rev 6450)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/adm_glyph.cpp	2010-07-14 12:17:22 UTC (rev 6451)
@@ -1,249 +0,0 @@
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
- #include &quot;config.h&quot;
-#include &quot;ADM_default.h&quot;
- #include &quot;adm_glyph.h&quot;
-#include &quot;DIA_coreToolkit.h&quot;
- //*************************************************
-admGlyph::admGlyph(uint32_t w,uint32_t h)
-{
-    ADM_assert(w*h);
-    width=w;
-    height=h;
-    data=new uint8_t[w*h];
-    memset(data,0,w*h);
-    code=NULL;
-    next=NULL;
-}
-//*************************************************
-admGlyph::~admGlyph()
-{
-    delete [] data;
-    data=NULL;
-    if(code)
-    {
-        ADM_dealloc(code);
-        code=NULL;
-    }
-}
-//*************************************************
-uint8_t admGlyph::create(uint8_t *incoming, uint32_t stride)
-{
-uint8_t *in=incoming;
-uint8_t *out=data;
-    for(uint32_t y=0;y&lt;height;y++)
-    {
-        memcpy(out,in,width);
-        out+=width;
-        in+=stride;
-    }
-    return 1;
-}
-//*************************************************
-uint8_t  insertInGlyphTree(admGlyph *startGlyph, admGlyph *candidate)
-{
-admGlyph *old;
-            old=startGlyph-&gt;next;
-            candidate-&gt;next=old;
-            startGlyph-&gt;next=candidate;
-            return 1;
-}
-//*************************************************
-uint8_t  destroyGlyphTree(admGlyph *startGlyph)
-{
-admGlyph *head,*tmp;
-        if(!startGlyph) return 0;
-        head=startGlyph-&gt;next;
-        while(head)
-        {
-            tmp=head;
-            head=head-&gt;next;
-            delete tmp;
-        }
-    return 1;
-}
-//*************************************************
-admGlyph *searchGlyph(admGlyph *startGlyph, admGlyph *candidate)
-{
-admGlyph *head=startGlyph-&gt;next;
-            while(head)
-            {   
-                if(head-&gt;width==candidate-&gt;width &amp;&amp; head-&gt;height==candidate-&gt;height)
-                {
-                    //Raw compare
-                    if(!memcmp(head-&gt;data,candidate-&gt;data,head-&gt;width*head-&gt;height))
-                        return head;
-                
-                }
-                head=head-&gt;next;
-            }
-            return NULL;
-}
-/*************************************************/
-admGlyph *clippedGlyph(admGlyph *in)
-{
-uint32_t w,h,lonecount,lone;
-int32_t top,bottom,left,right;
-admGlyph *nw=NULL;
-            w=in-&gt;width;
-            h=in-&gt;height;
-            // Look if we got a lonely point at the first line
-            lonecount=0;
-            if(w&gt;3)
-              for(uint32_t i=0;i&lt;w;i++) 
-                if(in-&gt;data[i]) 
-                {
-                    lonecount++;
-                    lone=i;
-                }
-            if(lonecount==1)
-            {
-                if(!lone) lone++;
-                if(lone==w-1) lone--;
-                if(!in-&gt;data[w+lone-1] &amp;&amp; !in-&gt;data[w+lone] &amp;&amp; !in-&gt;data[w+lone+1])
-                    in-&gt;data[lone]=0;
-            }
-            // Go!
-            left=0;
-            while(columnEmpty(in-&gt;data+left,w,h) &amp;&amp; left&lt;w) left++;
-            if(left==w) 
-            {
-                in-&gt;width=in-&gt;height=0;
-                return in;
-            }
-            right=w-1;
-            while(columnEmpty(in-&gt;data+right,w,h) &amp;&amp; right&gt;=left) right--;
-            
-            top=0;
-            while(lineEmpty(in-&gt;data,w,w,top) &amp;&amp; top&lt;h) top++;
-            
-            bottom=h-1;
-            while(lineEmpty(in-&gt;data,w,w,bottom) &amp;&amp; bottom&gt;=top) bottom--;
-            
-            nw=new admGlyph(right-left+1,bottom-top+1);
-            nw-&gt;create(in-&gt;data+left+top*w,w);
-            delete in;
-            return nw;
-
-}
-/**
-    \fn glyphSearchFather
-    \brief Returns the father of the &quot;in&quot; glyph.
-    @param in : Glyph to search the father of
-    @param head : head of glyph list
-    @returns father or NULL if not found
-*/
-admGlyph *glyphSearchFather(admGlyph *in,admGlyph *head )
-{
-  admGlyph *cur=head;
-  while(cur)
-  {
-    if(!cur-&gt;next) return NULL;
-    if(cur-&gt;next==in) return cur; 
-    cur=cur-&gt;next;
-  }
-  return NULL;
-}
-/*************************************************/
-/**
-    \fn       glyphSave
-    \brief    Save the glypset
-*/
-uint8_t saveGlyph(char *name,admGlyph *head,uint32_t nb)
-{
-  FILE *out;
-  uint32_t slen;
-  nb=0;
-  admGlyph *glyph=head-&gt;next;
-    
-    
-  out=fopen(name,&quot;wb&quot;);
-  if(!out)
-  {
-    GUI_Error_HIG(QT_TR_NOOP(&quot;Could not write the file&quot;), NULL);
-    return 0;
-  }
-    
-    /* First count how many glyphs */
-     while(glyph)
-    {
-      glyph=glyph-&gt;next;
-      nb++;
-    }
-    
-#define WRITE(x) fwrite(&amp;(x),sizeof(x),1,out);
-    WRITE(nb);
-    
-    glyph=head-&gt;next;
-    while(glyph)
-    {
-      WRITE(glyph-&gt;width);
-      WRITE(glyph-&gt;height);
-      fwrite(glyph-&gt;data,glyph-&gt;width*glyph-&gt;height,1,out);
-      if(glyph-&gt;code) slen=strlen(glyph-&gt;code);
-      else slen=0;
-      WRITE(slen);
-      fwrite(glyph-&gt;code,slen,1,out);
-      glyph=glyph-&gt;next;
-    }
-    printf(&quot;[Glyph] Saved %u glyphs\n&quot;,nb);
-    fclose(out);
-    return 1;
-  
-}
-/**
-    \fn loadGlyph
-    \brief Load a glyph set
-*/
-uint8_t loadGlyph(char *name,admGlyph *head,uint32_t *outNb)
-{
-  FILE *out;
-  admGlyph *glyph,*nw;
-  uint32_t N,w,h,slen;
-  uint32_t nbGlyphs;
- 
-  *outNb=0;
-  
-  glyph=head;
-  out=fopen(name,&quot;rb&quot;);
-  if(!out)
-  {
-    GUI_Error_HIG(QT_TR_NOOP(&quot;File error&quot;), QT_TR_NOOP(&quot;Could not read \&quot;%s\&quot;.&quot;), name);
-    return 0;
-  }
-#define READ(x) fread(&amp;(x),sizeof(x),1,out);
-    nbGlyphs=0;
-    READ(N);
-    while(N--)
-    {
-        
-      READ(w);
-      READ(h);
-      nw=new admGlyph(w,h);
-      fread(nw-&gt;data,w*h,1,out);
-      READ(slen);
-      if(slen)
-      {
-        nw-&gt;code=new char[slen+1];
-        fread(nw-&gt;code,slen,1,out);
-        nw-&gt;code[slen]=0;
-      }
-      glyph-&gt;next=nw;
-      glyph=nw;
-      nbGlyphs++;
-    }
-    
-    fclose(out);
-    *outNb=nbGlyphs;
-    printf(&quot;[Glyph] Loaded %u glyphs\n&quot;,nbGlyphs);
-    return 1;
-
-}
-/*************************************************/
-

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/adm_glyph.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/adm_glyph.h	2010-07-14 12:17:20 UTC (rev 6450)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/adm_glyph.h	2010-07-14 12:17:22 UTC (rev 6451)
@@ -1,68 +0,0 @@
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#ifndef ADM_GLYPH_
-#define ADM_GLYPH_
-
-#include &quot;ADM_default.h&quot;
-/*
-    returns 1 if the line is empty
-    0 if not
-*/
-static inline uint8_t lineEmpty(uint8_t *base, uint32_t stride, uint32_t width, uint32_t line)
-{
-    base+=line*stride;
-    for(uint32_t x=0;x&lt;width;x++)
-    {
-        if(base[x]) return 0;
-    }
-    return 1;
-}
-/*
-    returns 1 if the line is empty
-    0 if not
-*/
-static inline uint8_t columnEmpty(uint8_t *base, uint32_t stride, uint32_t height)
-{
-   
-    for(uint32_t y=0;y&lt;height;y++)
-    {
-        if(base[y*stride]) return 0;
-    }
-    return 1;
-}
-
-class admGlyph
-{
-private:
-public:
-    uint32_t width;
-    uint32_t height;
-    uint8_t  *data;
-    
-    
-
-        admGlyph *next;  
-        char * code;    
-                admGlyph(uint32_t w,uint32_t h);
-                ~admGlyph();
-        uint8_t create(uint8_t *data, uint32_t stride);
-};
-
-admGlyph *searchGlyph(admGlyph *startGlyph, admGlyph *candidate);
-uint8_t  destroyGlyphTree(admGlyph *startGlyph);
-uint8_t  insertInGlyphTree(admGlyph *startGlyph, admGlyph *candidate);
-admGlyph *clippedGlyph(admGlyph *in);
-admGlyph *glyphSearchFather(admGlyph *in,admGlyph *head );
-
-uint8_t loadGlyph(char *name,admGlyph *head,uint32_t *outNb);
-uint8_t saveGlyph(char *name,admGlyph *head,uint32_t nb);
-
-
-#endif

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/adm_leftturn.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/adm_leftturn.cpp	2010-07-14 12:17:20 UTC (rev 6450)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_ocr/adm_leftturn.cpp	2010-07-14 12:17:22 UTC (rev 6451)
@@ -1,122 +0,0 @@
-//
-// C++ Implementation: %{MODULE}
-//
-// Description:
-//
-//
-// Author: %{AUTHOR} &lt;%{EMAIL}&gt;, (C) %{YEAR}
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-#include &quot;config.h&quot;
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-#include &quot;ADM_assert.h&quot;
-
-
-#include &quot;fourcc.h&quot;
-
-#include &quot;config.h&quot;
-#include &quot;avi_vars.h&quot;
-
-
-#include &quot;ADM_leftturn.h&quot;
-
-static int incx[4]={1,0,-1,0};
-static int incy[4]={0,1,0,-1};
-
-static int nextdir[4]={1,0,3,2};
-
-
-uint8_t adm_estimate_glyphSize(admGlyph *glyph,uint32_t *minx, uint32_t *maxx,uint32_t *miny,uint32_t *maxy,int *raw)
-{
-    uint32_t nbPoints=0;
-    
-    int      startx,starty;
-    int      curx,cury;
-    int      tgtx,tgty;
-    int      dir;
-    int      found;
-    uint32_t xmin=glyph-&gt;width-1;
-    uint32_t xmax=0;
-    
-    uint32_t ymin=glyph-&gt;height-1,ymax=0;
-    
-    for(uint32_t i=0;i&lt;glyph-&gt;height;i++) raw[i]=-1;
-    
-    
-    *minx=0;
-    *maxx=0;
-    // Small glyph ?
-    if(glyph-&gt;width&lt;3)
-    {
-        *minx=0;
-        *maxx=glyph-&gt;width-1;
-        return 1;
-    }
-    // Search for a non empty line from the bottom of the glyph bottom to top, left to right
-    startx=0;
-    for(starty=glyph-&gt;height-1;starty&gt;=0;starty--)
-    {
-       
-            if(glyph-&gt;data[starty*glyph-&gt;width]) goto _fnd;   
-        
-    }
-    // Glyph empty ?
-    printf(&quot;Empty glyph\n&quot;);
-    return 0;
-_fnd:
-    dir=0;
-    curx=startx;
-    cury=starty;
-    //printf(&quot;Starting :%d %d (%d x %d )\n&quot;,startx,starty,glyph-&gt;width,glyph-&gt;height);
-    
-    while(1)
-    {   
-        found=0;
-        for(uint32_t i=0;i&lt;4;i++)
-        {   
-            tgtx=curx+incx[(dir+nextdir[i])%4];
-            tgty=cury+incy[(dir+nextdir[i])%4];
-            //printf(&quot;\t candidate :%d %d dir %d\n&quot;,tgtx,tgty,(dir+i)%4);
-            if(tgtx&gt;=0 &amp;&amp; tgty&gt;=0 &amp;&amp; tgtx&lt;glyph-&gt;width &amp;&amp; tgty&lt;glyph-&gt;height)   // Still into the glyph bounding box ?
-                if(glyph-&gt;data[tgtx+glyph-&gt;width*tgty])                                // Still inside glyph ?
-                {
-                    dir=(dir+nextdir[i])%4;
-                    found=1;
-                    curx=tgtx;
-                    cury=tgty;
-                    break;
-                    
-                }
-        }     
-        if(!found)
-        {          
-            printf(&quot;!Stuck\n&quot;);
-            return 0;
-        }
-        if(curx&gt;xmax) xmax=curx;
-        if(curx&lt;xmin) xmin=curx;
-        if(cury&gt;ymax) ymax=cury;
-        if(cury&lt;ymin) ymin=cury;
-        if((int)curx&gt;raw[cury])
-        {
-            raw[cury]=curx;
-        }
-        
-       // printf(&quot;New coord:%d %d, dir=%d\n&quot;,curx,cury,dir);
-        
-        if(curx==startx &amp;&amp; cury==starty) 
-        {
-            *minx=xmin;
-            *maxx=xmax;
-    
-            *miny=ymin;
-            *maxy=ymax;
-            return 1;        
-        }        
-    }   
-    return 0;
-}


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003638.html">[Avidemux-svn-commit] r6450 - in branches/avidemux_2.6_branch_mean:	avidemux avidemux/common/ADM_render	avidemux/common/ADM_videoCodec/include	avidemux/common/ADM_videoCodec/src avidemux_core	avidemux_core/ADM_coreUI/include avidemux_core/ADM_coreVdpau	avidemux_core/ADM_coreVdpau/include avidemux_core/ADM_coreVdpau/src
</A></li>
	<LI>Next message: <A HREF="003640.html">[Avidemux-svn-commit] r6452 -	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3639">[ date ]</a>
              <a href="thread.html#3639">[ thread ]</a>
              <a href="subject.html#3639">[ subject ]</a>
              <a href="author.html#3639">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
