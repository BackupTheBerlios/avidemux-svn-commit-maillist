<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r6481 - in	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg:	libavformat patches patches/avformat
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2010-July/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r6481%20-%20in%0A%09branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg%3A%0A%09libavformat%20patches%20patches/avformat&In-Reply-To=%3C20100725100746.C3EBA480E6C%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003667.html">
   <LINK REL="Next"  HREF="003669.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r6481 - in	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg:	libavformat patches patches/avformat</H1>
    <B>mean at mail.berlios.de</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r6481%20-%20in%0A%09branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg%3A%0A%09libavformat%20patches%20patches/avformat&In-Reply-To=%3C20100725100746.C3EBA480E6C%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r6481 - in	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg:	libavformat patches patches/avformat">mean at mail.berlios.de
       </A><BR>
    <I>Sun Jul 25 12:07:46 CEST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="003667.html">[Avidemux-svn-commit] r6480 - in	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg:	libavutil patches patches/avutils
</A></li>
        <LI>Next message: <A HREF="003669.html">[Avidemux-svn-commit] r6482 - in	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale:	. x86
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3668">[ date ]</a>
              <a href="thread.html#3668">[ thread ]</a>
              <a href="subject.html#3668">[ subject ]</a>
              <a href="author.html#3668">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2010-07-25 12:07:46 +0200 (Sun, 25 Jul 2010)
New Revision: 6481

Added:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/http.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/ivfdec.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/md5proto.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/mmst.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rso.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rso.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rsodec.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rsoenc.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rtpdec_mpeg4.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rtpdec_mpeg4.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rtpdec_qdm2.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rtpdec_qdm2.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rtpdec_svq3.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rtpdec_svq3.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/sauce.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/sauce.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/srtdec.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/tty.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/file.c.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/flvenc.c.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/isom.c.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/matroskaenc.c.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/movenc.c.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/mpegenc.c.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/mpegtsenc.c.patch
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/utils.c.patch
Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/file.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/flvenc.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/isom.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/matroskaenc.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/movenc.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/movenc.c.orig
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/mpegenc.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/mpegtsenc.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/utils.c
Log:
[ffmpeg] update 25 July , avformat

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/file.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/file.c	2010-07-25 10:07:43 UTC (rev 6480)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/file.c	2010-07-25 10:07:46 UTC (rev 6481)
@@ -30,7 +30,73 @@
 #include &lt;stdlib.h&gt;
 #include &quot;os_support.h&quot;
 
+// GRUNTSTER start
+#ifdef __WIN32
+#include &lt;windows.h&gt;
 
+int utf8StringToWideChar(const char *utf8String, int utf8StringLength, wchar_t *wideCharString)
+{
+	int wideCharStringLength = MultiByteToWideChar(CP_UTF8, 0, utf8String, utf8StringLength, NULL, 0);
+
+	if (wideCharString)
+		MultiByteToWideChar(CP_UTF8, 0, utf8String, utf8StringLength, wideCharString, wideCharStringLength);
+
+	return wideCharStringLength;
+}
+
+int ADM_open(const char *path, int oflag, ...)
+{
+	int fileNameLength = utf8StringToWideChar(path, -1, NULL);
+	wchar_t wcFile[fileNameLength];
+	int creation = 0, access = 0;
+	HANDLE hFile;
+
+	utf8StringToWideChar(path, -1, wcFile);
+
+	if (oflag &amp; O_WRONLY || oflag &amp; O_RDWR)
+	{
+		access = GENERIC_WRITE;
+
+		if (oflag &amp; O_RDWR)
+			access |= GENERIC_READ;
+
+		if (oflag &amp; O_CREAT)
+		{
+			if (oflag &amp; O_EXCL)
+				creation = CREATE_NEW;
+			else if (oflag &amp; O_TRUNC)
+				creation = CREATE_ALWAYS;
+			else
+				creation = OPEN_ALWAYS;
+		}
+		else if (oflag &amp; O_TRUNC)
+			creation = TRUNCATE_EXISTING;
+	}
+	else if (oflag &amp; O_RDONLY)
+		creation = OPEN_EXISTING;
+
+	if (creation &amp; GENERIC_WRITE)
+	{
+		hFile = CreateFileW(wcFile, access, 0, NULL, creation, 0, NULL);
+
+		if (hFile == INVALID_HANDLE_VALUE)
+			return -1;
+		else
+			CloseHandle(hFile);
+	}
+
+	hFile = CreateFileW(wcFile, access, FILE_SHARE_READ, NULL, creation, 0, NULL);
+
+	if (hFile == INVALID_HANDLE_VALUE)
+		return -1;
+	else
+		return _open_osfhandle((intptr_t)hFile, oflag);
+}
+
+#define open ADM_open
+#endif
+// GRUNTSTER end
+
 /* standard file protocol */
 
 static int file_read(URLContext *h, unsigned char *buf, int size)

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/flvenc.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/flvenc.c	2010-07-25 10:07:43 UTC (rev 6480)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/flvenc.c	2010-07-25 10:07:46 UTC (rev 6481)
@@ -406,7 +406,8 @@
     &quot;video/x-flv&quot;,
     &quot;flv&quot;,
     sizeof(FLVContext),
-#if CONFIG_LIBMP3LAME
+//MEANX #if CONFIG_LIBMP3LAME
+#ifdef HAVE_LIBMP3LAME
     CODEC_ID_MP3,
 #else // CONFIG_LIBMP3LAME
     CODEC_ID_ADPCM_SWF,
@@ -418,3 +419,9 @@
     .codec_tag= (const AVCodecTag* const []){flv_video_codec_ids, flv_audio_codec_ids, 0},
     .flags= AVFMT_GLOBALHEADER | AVFMT_VARIABLE_FPS,
 };
+// MEANX
+int flvenc_init(void)
+{
+    av_register_output_format(&amp;flv_muxer);
+    return 0;
+}
\ No newline at end of file

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/http.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/http.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/http.h	2010-07-25 10:07:46 UTC (rev 6481)
@@ -0,0 +1,64 @@
+/*
+ * HTTP definitions
+ * Copyright (c) 2010 Josh Allmann
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVFORMAT_HTTP_H
+#define AVFORMAT_HTTP_H
+
+#include &quot;avio.h&quot;
+
+/**
+ * Set custom HTTP headers.
+ * A trailing CRLF (&quot;\r\n&quot;) is required for custom headers.
+ * Passing in an empty header string (&quot;\0&quot;) will reset to defaults.
+ *
+ * The following headers can be overriden by custom values,
+ * otherwise they will be set to their defaults.
+ *  -User-Agent
+ *  -Accept
+ *  -Range
+ *  -Host
+ *  -Connection
+ *
+ * @param h URL context for this HTTP connection
+ * @param headers the custom headers to set
+ */
+void ff_http_set_headers(URLContext *h, const char *headers);
+
+/**
+ * Enable or disable chunked transfer encoding. (default is enabled)
+ *
+ * @param h URL context for this HTTP connection
+ * @param is_chunked 0 to disable chunking, nonzero otherwise.
+ */
+void ff_http_set_chunked_transfer_encoding(URLContext *h, int is_chunked);
+
+/**
+ * Initialize the authentication state based on another HTTP URLContext.
+ * This can be used to pre-initialize the authentication parameters if
+ * they are known beforehand, to avoid having to do an initial failing
+ * request just to get the parameters.
+ *
+ * @param dest URL context whose authentication state gets updated
+ * @param src URL context whose authentication state gets copied
+ */
+void ff_http_init_auth_state(URLContext *dest, const URLContext *src);
+
+#endif /* AVFORMAT_HTTP_H */

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/isom.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/isom.c	2010-07-25 10:07:43 UTC (rev 6480)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/isom.c	2010-07-25 10:07:46 UTC (rev 6481)
@@ -215,7 +215,10 @@
     { CODEC_ID_MP1, MKTAG('.', 'm', 'p', '1') }, /* MPEG layer 1 */
     { CODEC_ID_MP2, MKTAG('.', 'm', 'p', '2') }, /* MPEG layer 2 */
 
-    { CODEC_ID_MP3, MKTAG('.', 'm', 'p', '3') }, /* MPEG layer 3 */ /* sample files at <A HREF="http://www.3ivx.com/showcase.html">http://www.3ivx.com/showcase.html</A> use this tag */
+    //MEANX { CODEC_ID_MP3, MKTAG('.', 'm', 'p', '3') }, /* MPEG layer 3 */ /* sample files at <A HREF="http://www.3ivx.com/showcase.html">http://www.3ivx.com/showcase.html</A> use this tag */
+     { CODEC_ID_MP3, MKTAG( 'm', 'p', '4','a') },
+     { CODEC_ID_MP2, MKTAG( 'm', 'p', '4', 'a') },
+    // /MEANX
     { CODEC_ID_MP3, 0x6D730055 }, /* MPEG layer 3 */
 
 /*  { CODEC_ID_OGG_VORBIS, MKTAG('O', 'g', 'g', 'S') }, *//* sample files at <A HREF="http://heroinewarrior.com/xmovie.php3">http://heroinewarrior.com/xmovie.php3</A> use this tag */

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/ivfdec.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/ivfdec.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/ivfdec.c	2010-07-25 10:07:46 UTC (rev 6481)
@@ -0,0 +1,91 @@
+/*
+ * Copyright (c) 2010 David Conrad
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include &quot;avformat.h&quot;
+#include &quot;riff.h&quot;
+#include &quot;libavutil/intreadwrite.h&quot;
+
+static int probe(AVProbeData *p)
+{
+    if (AV_RL32(p-&gt;buf) == MKTAG('D','K','I','F')
+        &amp;&amp; !AV_RL16(p-&gt;buf+4) &amp;&amp; AV_RL16(p-&gt;buf+6) == 32)
+        return AVPROBE_SCORE_MAX-2;
+
+    return 0;
+}
+
+static int read_header(AVFormatContext *s, AVFormatParameters *ap)
+{
+    AVStream *st;
+    AVRational time_base;
+
+    get_le32(s-&gt;pb); // DKIF
+    get_le16(s-&gt;pb); // version
+    get_le16(s-&gt;pb); // header size
+
+    st = av_new_stream(s, 0);
+    if (!st)
+        return AVERROR(ENOMEM);
+
+
+    st-&gt;codec-&gt;codec_type = AVMEDIA_TYPE_VIDEO;
+    st-&gt;codec-&gt;codec_tag  = get_le32(s-&gt;pb);
+    st-&gt;codec-&gt;codec_id   = ff_codec_get_id(ff_codec_bmp_tags, st-&gt;codec-&gt;codec_tag);
+    st-&gt;codec-&gt;width      = get_le16(s-&gt;pb);
+    st-&gt;codec-&gt;height     = get_le16(s-&gt;pb);
+    time_base.den         = get_le32(s-&gt;pb);
+    time_base.num         = get_le32(s-&gt;pb);
+    st-&gt;duration          = get_le64(s-&gt;pb);
+
+    st-&gt;need_parsing      = AVSTREAM_PARSE_HEADERS;
+
+    if (!time_base.den || !time_base.num) {
+        av_log(s, AV_LOG_ERROR, &quot;Invalid frame rate\n&quot;);
+        return AVERROR_INVALIDDATA;
+    }
+
+    av_set_pts_info(st, 64, time_base.num, time_base.den);
+
+    return 0;
+}
+
+static int read_packet(AVFormatContext *s, AVPacket *pkt)
+{
+    int ret, size = get_le32(s-&gt;pb);
+    int64_t   pts = get_le64(s-&gt;pb);
+
+    ret = av_get_packet(s-&gt;pb, pkt, size);
+    pkt-&gt;stream_index = 0;
+    pkt-&gt;pts          = pts;
+    pkt-&gt;pos         -= 12;
+
+    return ret;
+}
+
+AVInputFormat ivf_demuxer = {
+    &quot;ivf&quot;,
+    NULL_IF_CONFIG_SMALL(&quot;On2 IVF&quot;),
+    0,
+    probe,
+    read_header,
+    read_packet,
+    .flags= AVFMT_GENERIC_INDEX,
+    .codec_tag = (const AVCodecTag*[]){ff_codec_bmp_tags, 0},
+};

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/matroskaenc.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/matroskaenc.c	2010-07-25 10:07:43 UTC (rev 6480)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/matroskaenc.c	2010-07-25 10:07:46 UTC (rev 6481)
@@ -407,6 +407,7 @@
 
 static int put_xiph_codecpriv(AVFormatContext *s, ByteIOContext *pb, AVCodecContext *codec)
 {
+#if 0 // MEANX avidemux does thing differently
     uint8_t *header_start[3];
     int header_len[3];
     int first_header_size;
@@ -431,6 +432,28 @@
         put_buffer(pb, header_start[j], header_len[j]);
 
     return 0;
+#else
+   // Not endian safe....
+      uint32_t packetLen[3],*ptr=(uint32_t *)codec-&gt;extradata;
+      uint8_t *data[3],i,j;
+      if( 3*4+ptr[0]+ptr[1]+ptr[2]!=codec-&gt;extradata_size)
+      {
+        av_log(s, AV_LOG_ERROR, &quot;Broken avidemux xiph header.\n&quot;);
+        return -1;
+      }
+      data[0]=codec-&gt;extradata+3*4;
+      data[1]=data[0]+ptr[0];
+      data[2]=data[1]+ptr[1];
+      put_byte(pb, 2);                    // number packets - 1
+      for (j = 0; j &lt; 2; j++) 
+      {
+          put_xiph_size(pb, ptr[j]);
+      }
+      for (j = 0; j &lt; 3; j++)
+        put_buffer(pb, data[j], ptr[j]);
+      
+      return 0; // /MEANX
+#endif
 }
 
 static void get_aac_sample_rates(AVFormatContext *s, AVCodecContext *codec, int *sample_rate, int *output_sample_rate)
@@ -548,6 +571,23 @@
         put_ebml_uint (pb, MATROSKA_ID_TRACKNUMBER     , i + 1);
         put_ebml_uint (pb, MATROSKA_ID_TRACKUID        , i + 1);
         put_ebml_uint (pb, MATROSKA_ID_TRACKFLAGLACING , 0);    // no lacing (yet)
+/**  MEANX : Add a default duration for video **/
+        if(codec-&gt;codec_type==CODEC_TYPE_VIDEO)
+        {
+          if(codec-&gt;time_base.den &amp;&amp; codec-&gt;time_base.num)
+          {
+            int num=codec-&gt;time_base.num;
+            int den=codec-&gt;time_base.den;
+            unsigned int default_duration;
+            float period=num;
+                  period/=den;
+                  period*=1000*1000*1000; // in ns
+                  default_duration=(unsigned int)floor(period);
+                  put_ebml_uint (pb, MATROSKA_ID_TRACKDEFAULTDURATION ,default_duration);
+          }
+        }
+        
+/**  MEANX : Add a default duration for video **/
 
         if ((tag = av_metadata_get(st-&gt;metadata, &quot;title&quot;, NULL, 0)))
             put_ebml_string(pb, MATROSKA_ID_TRACKNAME, tag-&gt;value);
@@ -1087,3 +1127,17 @@
     .codec_tag = (const AVCodecTag* const []){ff_codec_wav_tags, 0},
 };
 #endif
+
+ // MEANX
+ //
+ int matroskaenc_init(void)
+ {
+     av_register_output_format(&amp;matroska_muxer);
+#if CONFIG_WEBM_MUXER
+     av_register_output_format(&amp;webm_muxer);
+#endif
+     return 0;
+ }
+ // /MEANX
+
+

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/md5proto.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/md5proto.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/md5proto.c	2010-07-25 10:07:46 UTC (rev 6481)
@@ -0,0 +1,92 @@
+/*
+ * Copyright (c) 2010 Mans Rullgard
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include &lt;stdio.h&gt;
+#include &quot;libavutil/avstring.h&quot;
+#include &quot;libavutil/md5.h&quot;
+#include &quot;libavutil/mem.h&quot;
+#include &quot;libavutil/error.h&quot;
+#include &quot;avformat.h&quot;
+#include &quot;avio.h&quot;
+
+#define PRIV_SIZE 128
+
+static int md5_open(URLContext *h, const char *filename, int flags)
+{
+    if (PRIV_SIZE &lt; av_md5_size) {
+        av_log(NULL, AV_LOG_ERROR, &quot;Insuffient size for MD5 context\n&quot;);
+        return -1;
+    }
+
+    if (flags != URL_WRONLY)
+        return AVERROR(EINVAL);
+
+    av_md5_init(h-&gt;priv_data);
+
+    return 0;
+}
+
+static int md5_write(URLContext *h, const unsigned char *buf, int size)
+{
+    av_md5_update(h-&gt;priv_data, buf, size);
+    return size;
+}
+
+static int md5_close(URLContext *h)
+{
+    const char *filename = h-&gt;filename;
+    uint8_t md5[16], buf[64];
+    URLContext *out;
+    int i, err = 0;
+
+    av_md5_final(h-&gt;priv_data, md5);
+    for (i = 0; i &lt; sizeof(md5); i++)
+        snprintf(buf + i*2, 3, &quot;%02x&quot;, md5[i]);
+    buf[i*2] = '\n';
+
+    av_strstart(filename, &quot;md5:&quot;, &amp;filename);
+
+    if (*filename) {
+        err = url_open(&amp;out, filename, URL_WRONLY);
+        if (err)
+            return err;
+        err = url_write(out, buf, i*2+1);
+        url_close(out);
+    } else {
+        if (fwrite(buf, 1, i*2+1, stdout) &lt; i*2+1)
+            err = AVERROR(errno);
+    }
+
+    return err;
+}
+
+static int md5_get_handle(URLContext *h)
+{
+    return (intptr_t)h-&gt;priv_data;
+}
+
+URLProtocol md5_protocol = {
+    .name                = &quot;md5&quot;,
+    .url_open            = md5_open,
+    .url_write           = md5_write,
+    .url_close           = md5_close,
+    .url_get_file_handle = md5_get_handle,
+    .priv_data_size      = PRIV_SIZE,
+};

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/mmst.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/mmst.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/mmst.c	2010-07-25 10:07:46 UTC (rev 6481)
@@ -0,0 +1,716 @@
+/*
+ * MMS protocol over TCP
+ * Copyright (c) 2006,2007 Ryan Martell
+ * Copyright (c) 2007 Bj&#246;rn Axelsson
+ * Copyright (c) 2010 Zhentan Feng &lt;spyfeng at gmail dot com&gt;
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/* References
+ * MMS protocol specification:
+ *  [1]<A HREF="http://msdn.microsoft.com/en-us/library/cc234711(PROT.10">http://msdn.microsoft.com/en-us/library/cc234711(PROT.10</A>).aspx
+ * ASF specification. Revision 01.20.03.
+ *  [2]<A HREF="http://msdn.microsoft.com/en-us/library/bb643323.aspx">http://msdn.microsoft.com/en-us/library/bb643323.aspx</A>
+ */
+
+#include &quot;avformat.h&quot;
+#include &quot;internal.h&quot;
+#include &quot;libavutil/intreadwrite.h&quot;
+#include &quot;libavcodec/bytestream.h&quot;
+#include &quot;network.h&quot;
+#include &quot;asf.h&quot;
+
+#define LOCAL_ADDRESS 0xc0a80081    // FIXME get and use correct local ip address.
+#define LOCAL_PORT    1037          // as above.
+/** Client to server packet types. */
+typedef enum {
+    CS_PKT_INITIAL                  = 0x01,
+    CS_PKT_PROTOCOL_SELECT          = 0x02,
+    CS_PKT_MEDIA_FILE_REQUEST       = 0x05,
+    CS_PKT_START_FROM_PKT_ID        = 0x07,
+    CS_PKT_STREAM_PAUSE             = 0x09,
+    CS_PKT_STREAM_CLOSE             = 0x0d,
+    CS_PKT_MEDIA_HEADER_REQUEST     = 0x15,
+    CS_PKT_TIMING_DATA_REQUEST      = 0x18,
+    CS_PKT_USER_PASSWORD            = 0x1a,
+    CS_PKT_KEEPALIVE                = 0x1b,
+    CS_PKT_STREAM_ID_REQUEST        = 0x33,
+} MMSCSPacketType;
+
+/** Server to client packet types. */
+typedef enum {
+    /** Control packets. */
+    /*@{*/
+    SC_PKT_CLIENT_ACCEPTED          = 0x01,
+    SC_PKT_PROTOCOL_ACCEPTED        = 0x02,
+    SC_PKT_PROTOCOL_FAILED          = 0x03,
+    SC_PKT_MEDIA_PKT_FOLLOWS        = 0x05,
+    SC_PKT_MEDIA_FILE_DETAILS       = 0x06,
+    SC_PKT_HEADER_REQUEST_ACCEPTED  = 0x11,
+    SC_PKT_TIMING_TEST_REPLY        = 0x15,
+    SC_PKT_PASSWORD_REQUIRED        = 0x1a,
+    SC_PKT_KEEPALIVE                = 0x1b,
+    SC_PKT_STREAM_STOPPED           = 0x1e,
+    SC_PKT_STREAM_CHANGING          = 0x20,
+    SC_PKT_STREAM_ID_ACCEPTED       = 0x21,
+    /*@}*/
+
+    /** Pseudo packets. */
+    /*@{*/
+    SC_PKT_CANCEL                   = -1,
+    SC_PKT_NO_DATA                  = -2,
+    /*@}*/
+
+    /** Data packets. */
+    /*@{*/
+    SC_PKT_ASF_HEADER               = 0x010000,// make it bigger than 0xFF in case of
+    SC_PKT_ASF_MEDIA                = 0x010001,// receiving false data packets.
+    /*@}*/
+} MMSSCPacketType;
+
+typedef struct {
+    int id;
+}MMSStream;
+
+typedef struct {
+    int outgoing_packet_seq;             ///&lt; Outgoing packet sequence number.
+    char path[256];                      ///&lt; Path of the resource being asked for.
+    char host[128];                      ///&lt; Host of the resources.
+
+    URLContext *mms_hd;                  ///&lt; TCP connection handle
+    MMSStream streams[MAX_STREAMS];
+
+    /** Buffer for outgoing packets. */
+    /*@{*/
+    uint8_t *write_out_ptr;              ///&lt; Pointer for writting the buffer.
+    uint8_t out_buffer[512];             ///&lt; Buffer for outgoing packet.
+    /*@}*/
+
+    /** Buffer for incoming packets. */
+    /*@{*/
+    uint8_t in_buffer[8192];             ///&lt; Buffer for incoming packets.
+    uint8_t *read_in_ptr;                ///&lt; Pointer for reading from incoming buffer.
+    int remaining_in_len;                ///&lt; Reading length from incoming buffer.
+    /*@}*/
+
+    int incoming_packet_seq;             ///&lt; Incoming packet sequence number.
+    int incoming_flags;                  ///&lt; Incoming packet flags.
+
+    int packet_id;                       ///&lt; Identifier for packets in the current stream.
+    unsigned int header_packet_id;       ///&lt; default is 2.
+
+    /** Internal handling of the ASF header */
+    /*@{*/
+    uint8_t *asf_header;                 ///&lt; Stored ASF header.
+    int asf_header_size;                 ///&lt; Size of stored ASF header.
+    int header_parsed;                   ///&lt; The header has been received and parsed.
+    int asf_packet_len;
+    int asf_header_read_size;
+    /*@}*/
+
+    int stream_num;                      ///&lt; stream numbers.
+    int is_playing;
+} MMSContext;
+
+/** Create MMST command packet header */
+static void start_command_packet(MMSContext *mms, MMSCSPacketType packet_type)
+{
+    mms-&gt;write_out_ptr = mms-&gt;out_buffer;
+
+    bytestream_put_le32(&amp;mms-&gt;write_out_ptr, 1); // start sequence
+    bytestream_put_le32(&amp;mms-&gt;write_out_ptr, 0xb00bface);
+    bytestream_put_le32(&amp;mms-&gt;write_out_ptr, 0); // Length starts from after the protocol type bytes
+    bytestream_put_le32(&amp;mms-&gt;write_out_ptr, MKTAG('M','M','S',' '));
+    bytestream_put_le32(&amp;mms-&gt;write_out_ptr, 0);
+    bytestream_put_le32(&amp;mms-&gt;write_out_ptr, mms-&gt;outgoing_packet_seq++);
+    bytestream_put_le64(&amp;mms-&gt;write_out_ptr, 0); // timestamp
+    bytestream_put_le32(&amp;mms-&gt;write_out_ptr, 0);
+    bytestream_put_le16(&amp;mms-&gt;write_out_ptr, packet_type);
+    bytestream_put_le16(&amp;mms-&gt;write_out_ptr, 3); // direction to server
+}
+
+/** Add prefixes to MMST command packet. */
+static void insert_command_prefixes(MMSContext *mms,
+        uint32_t prefix1, uint32_t prefix2)
+{
+    bytestream_put_le32(&amp;mms-&gt;write_out_ptr, prefix1); // first prefix
+    bytestream_put_le32(&amp;mms-&gt;write_out_ptr, prefix2); // second prefix
+}
+
+/** Send a prepared MMST command packet. */
+static int send_command_packet(MMSContext *mms)
+{
+    int len= mms-&gt;write_out_ptr - mms-&gt;out_buffer;
+    int exact_length = (len + 7) &amp; ~7;
+    int first_length= exact_length - 16;
+    int len8= first_length/8;
+    int write_result;
+
+    // update packet length fields.
+    AV_WL32(mms-&gt;out_buffer + 8, first_length);
+    AV_WL32(mms-&gt;out_buffer + 16, len8);
+    AV_WL32(mms-&gt;out_buffer + 32, len8-2);
+    memset(mms-&gt;write_out_ptr, 0, exact_length - len);
+
+    // write it out.
+    write_result= url_write(mms-&gt;mms_hd, mms-&gt;out_buffer, exact_length);
+    if(write_result != exact_length) {
+        dprintf(NULL, &quot;url_write returned: %d != %d\n&quot;,
+                write_result, exact_length);
+        return AVERROR_IO;
+    }
+
+    return 0;
+}
+
+static void mms_put_utf16(MMSContext *mms, uint8_t *src)
+{
+    ByteIOContext bic;
+    int size = mms-&gt;write_out_ptr - mms-&gt;out_buffer;
+    int len;
+    init_put_byte(&amp;bic, mms-&gt;write_out_ptr,
+            sizeof(mms-&gt;out_buffer) - size, 1, NULL, NULL, NULL, NULL);
+
+    len = ff_put_str16_nolen(&amp;bic, src);
+    mms-&gt;write_out_ptr += len;
+}
+
+static int send_time_test_data(MMSContext *mms)
+{
+    start_command_packet(mms, CS_PKT_TIMING_DATA_REQUEST);
+    insert_command_prefixes(mms, 0xf0f0f0f1, 0x0004000b);
+    return send_command_packet(mms);
+}
+
+static int send_protocol_select(MMSContext *mms)
+{
+    char data_string[256];
+
+    start_command_packet(mms, CS_PKT_PROTOCOL_SELECT);
+    insert_command_prefixes(mms, 0, 0xffffffff);
+    bytestream_put_le32(&amp;mms-&gt;write_out_ptr, 0);          // maxFunnelBytes
+    bytestream_put_le32(&amp;mms-&gt;write_out_ptr, 0x00989680); // maxbitRate
+    bytestream_put_le32(&amp;mms-&gt;write_out_ptr, 2);          // funnelMode
+    snprintf(data_string, sizeof(data_string), &quot;\\\\%d.%d.%d.%d\\%s\\%d&quot;,
+            (LOCAL_ADDRESS&gt;&gt;24)&amp;0xff,
+            (LOCAL_ADDRESS&gt;&gt;16)&amp;0xff,
+            (LOCAL_ADDRESS&gt;&gt;8)&amp;0xff,
+            LOCAL_ADDRESS&amp;0xff,
+            &quot;TCP&quot;,                                        // or UDP
+            LOCAL_PORT);
+
+    mms_put_utf16(mms, data_string);
+    return send_command_packet(mms);
+}
+
+static int send_media_file_request(MMSContext *mms)
+{
+    start_command_packet(mms, CS_PKT_MEDIA_FILE_REQUEST);
+    insert_command_prefixes(mms, 1, 0xffffffff);
+    bytestream_put_le32(&amp;mms-&gt;write_out_ptr, 0);
+    bytestream_put_le32(&amp;mms-&gt;write_out_ptr, 0);
+    mms_put_utf16(mms, mms-&gt;path + 1); // +1 for skip &quot;/&quot;
+
+    return send_command_packet(mms);
+}
+
+static void handle_packet_stream_changing_type(MMSContext *mms)
+{
+    dprintf(NULL, &quot;Stream changing!\n&quot;);
+
+    // 40 is the packet header size, 7 is the prefix size.
+    mms-&gt;header_packet_id= AV_RL32(mms-&gt;in_buffer + 40 + 7);
+    dprintf(NULL, &quot;Changed header prefix to 0x%x&quot;, mms-&gt;header_packet_id);
+}
+
+static int send_keepalive_packet(MMSContext *mms)
+{
+    // respond to a keepalive with a keepalive...
+    start_command_packet(mms, CS_PKT_KEEPALIVE);
+    insert_command_prefixes(mms, 1, 0x100FFFF);
+    return send_command_packet(mms);
+}
+
+/** Pad media packets smaller than max_packet_size and/or adjust read position
+  * after a seek. */
+static void pad_media_packet(MMSContext *mms)
+{
+    if(mms-&gt;remaining_in_len&lt;mms-&gt;asf_packet_len) {
+        int padding_size = mms-&gt;asf_packet_len - mms-&gt;remaining_in_len;
+        memset(mms-&gt;in_buffer + mms-&gt;remaining_in_len, 0, padding_size);
+        mms-&gt;remaining_in_len += padding_size;
+    }
+}
+
+/** Read incoming MMST media, header or command packet. */
+static MMSSCPacketType get_tcp_server_response(MMSContext *mms)
+{
+    int read_result;
+    MMSSCPacketType packet_type= -1;
+
+    for(;;) {
+        if((read_result= url_read_complete(mms-&gt;mms_hd, mms-&gt;in_buffer, 8))==8) {
+            // handle command packet.
+            if(AV_RL32(mms-&gt;in_buffer + 4)==0xb00bface) {
+                mms-&gt;incoming_flags= mms-&gt;in_buffer[3];
+                read_result= url_read_complete(mms-&gt;mms_hd, mms-&gt;in_buffer+8, 4);
+                if(read_result == 4) {
+                    int length_remaining= AV_RL32(mms-&gt;in_buffer+8) + 4;
+                    int hr;
+
+                    dprintf(NULL, &quot;Length remaining is %d\n&quot;, length_remaining);
+                    // read the rest of the packet.
+                    if (length_remaining &lt; 0
+                        || length_remaining &gt; sizeof(mms-&gt;in_buffer) - 12) {
+                        dprintf(NULL, &quot;Incoming message len %d exceeds buffer len %d\n&quot;,
+                            length_remaining, sizeof(mms-&gt;in_buffer) - 12);
+                        return -1;
+                    }
+                    read_result = url_read_complete(mms-&gt;mms_hd, mms-&gt;in_buffer + 12,
+                                                  length_remaining) ;
+                    if (read_result == length_remaining) {
+                        packet_type= AV_RL16(mms-&gt;in_buffer+36);
+                    } else {
+                        dprintf(NULL, &quot;read for packet type failed%d!\n&quot;, read_result);
+                        return -1;
+                    }
+                    hr = AV_RL32(mms-&gt;in_buffer + 40);
+                    if (hr) {
+                        dprintf(NULL, &quot;The server side send back error code:0x%x\n&quot;, hr);
+                        return -1;
+                    }
+                } else {
+                    dprintf(NULL, &quot;read for length remaining failed%d!\n&quot;, read_result);
+                    return -1;
+                }
+            } else {
+                int length_remaining;
+                int packet_id_type;
+                int tmp;
+
+                // note we cache the first 8 bytes,
+                // then fill up the buffer with the others
+                tmp                       = AV_RL16(mms-&gt;in_buffer + 6);
+                length_remaining          = (tmp - 8) &amp; 0xffff;
+                mms-&gt;incoming_packet_seq  = AV_RL32(mms-&gt;in_buffer);
+                packet_id_type            = mms-&gt;in_buffer[4];
+                mms-&gt;incoming_flags       = mms-&gt;in_buffer[5];
+
+                if (length_remaining &lt; 0
+                        || length_remaining &gt; sizeof(mms-&gt;in_buffer) - 8) {
+                    dprintf(NULL, &quot;Incoming data len %d exceeds buffer len %d\n&quot;,
+                            length_remaining, sizeof(mms-&gt;in_buffer));
+                    return -1;
+                }
+                mms-&gt;remaining_in_len    = length_remaining;
+                mms-&gt;read_in_ptr         = mms-&gt;in_buffer;
+                read_result= url_read_complete(mms-&gt;mms_hd, mms-&gt;in_buffer, length_remaining);
+                if(read_result != length_remaining) {
+                    dprintf(NULL, &quot;read_bytes result: %d asking for %d\n&quot;,
+                            read_result, length_remaining);
+                    return -1;
+                } else {
+                    // if we successfully read everything.
+                    if(packet_id_type == mms-&gt;header_packet_id) {
+                        packet_type = SC_PKT_ASF_HEADER;
+                        // Store the asf header
+                        if(!mms-&gt;header_parsed) {
+                            void *p = av_realloc(mms-&gt;asf_header,
+                                              mms-&gt;asf_header_size
+                                              + mms-&gt;remaining_in_len);
+                            if (!p) {
+                                av_freep(&amp;mms-&gt;asf_header);
+                                return AVERROR(ENOMEM);
+                            }
+                            mms-&gt;asf_header = p;
+                            memcpy(mms-&gt;asf_header + mms-&gt;asf_header_size,
+                                                 mms-&gt;read_in_ptr,
+                                                 mms-&gt;remaining_in_len);
+                            mms-&gt;asf_header_size += mms-&gt;remaining_in_len;
+                        }
+                        // 0x04 means asf header is sent in multiple packets.
+                        if (mms-&gt;incoming_flags == 0x04)
+                            continue;
+                    } else if(packet_id_type == mms-&gt;packet_id) {
+                        packet_type = SC_PKT_ASF_MEDIA;
+                    } else {
+                        dprintf(NULL, &quot;packet id type %d is old.&quot;, packet_id_type);
+                        continue;
+                    }
+                }
+            }
+
+            // preprocess some packet type
+            if(packet_type == SC_PKT_KEEPALIVE) {
+                send_keepalive_packet(mms);
+                continue;
+            } else if(packet_type == SC_PKT_STREAM_CHANGING) {
+                handle_packet_stream_changing_type(mms);
+            } else if(packet_type == SC_PKT_ASF_MEDIA) {
+                pad_media_packet(mms);
+            }
+            return packet_type;
+        } else {
+            if(read_result&lt;0) {
+                dprintf(NULL, &quot;Read error (or cancelled) returned %d!\n&quot;, read_result);
+                packet_type = SC_PKT_CANCEL;
+            } else {
+                dprintf(NULL, &quot;Read result of zero?!\n&quot;);
+                packet_type = SC_PKT_NO_DATA;
+            }
+            return packet_type;
+        }
+    }
+}
+
+static int mms_safe_send_recv(MMSContext *mms,
+                              int (*send_fun)(MMSContext *mms),
+                              const MMSSCPacketType expect_type)
+{
+    MMSSCPacketType type;
+    if(send_fun) {
+        int ret = send_fun(mms);
+        if (ret &lt; 0) {
+            dprintf(NULL, &quot;Send Packet error before expecting recv packet %d\n&quot;, expect_type);
+            return ret;
+        }
+    }
+
+    if ((type = get_tcp_server_response(mms)) != expect_type) {
+        dprintf(NULL,&quot;Unexpected packet type %d with type %d\n&quot;, type, expect_type);
+        return -1;
+    } else {
+        return 0;
+    }
+}
+
+static int send_media_header_request(MMSContext *mms)
+{
+    start_command_packet(mms, CS_PKT_MEDIA_HEADER_REQUEST);
+    insert_command_prefixes(mms, 1, 0);
+    bytestream_put_le32(&amp;mms-&gt;write_out_ptr, 0);
+    bytestream_put_le32(&amp;mms-&gt;write_out_ptr, 0x00800000);
+    bytestream_put_le32(&amp;mms-&gt;write_out_ptr, 0xffffffff);
+    bytestream_put_le32(&amp;mms-&gt;write_out_ptr, 0);
+    bytestream_put_le32(&amp;mms-&gt;write_out_ptr, 0);
+    bytestream_put_le32(&amp;mms-&gt;write_out_ptr, 0);
+
+    // the media preroll value in milliseconds?
+    bytestream_put_le32(&amp;mms-&gt;write_out_ptr, 0);
+    bytestream_put_le32(&amp;mms-&gt;write_out_ptr, 0x40AC2000);
+    bytestream_put_le32(&amp;mms-&gt;write_out_ptr, 2);
+    bytestream_put_le32(&amp;mms-&gt;write_out_ptr, 0);
+
+    return send_command_packet(mms);
+}
+
+/** Send the initial handshake. */
+static int send_startup_packet(MMSContext *mms)
+{
+    char data_string[256];
+    // SubscriberName is defined in MS specification linked below.
+    // The guid value can be any valid value.
+    // <A HREF="http://download.microsoft.com/">http://download.microsoft.com/</A>
+    // download/9/5/E/95EF66AF-9026-4BB0-A41D-A4F81802D92C/%5BMS-WMSP%5D.pdf
+    snprintf(data_string, sizeof(data_string),
+            &quot;NSPlayer/7.0.0.1956; {%s}; Host: %s&quot;,
+            &quot;7E667F5D-A661-495E-A512-F55686DDA178&quot;, mms-&gt;host);
+
+    start_command_packet(mms, CS_PKT_INITIAL);
+    insert_command_prefixes(mms, 0, 0x0004000b);
+    bytestream_put_le32(&amp;mms-&gt;write_out_ptr, 0x0003001c);
+    mms_put_utf16(mms, data_string);
+    return send_command_packet(mms);
+}
+
+static int asf_header_parser(MMSContext *mms)
+{
+    uint8_t *p = mms-&gt;asf_header;
+    uint8_t *end;
+    int flags, stream_id;
+    mms-&gt;stream_num = 0;
+
+    if (mms-&gt;asf_header_size &lt; sizeof(ff_asf_guid) * 2 + 22 ||
+        memcmp(p, ff_asf_header, sizeof(ff_asf_guid)))
+        return -1;
+
+    end = mms-&gt;asf_header + mms-&gt;asf_header_size;
+
+    p += sizeof(ff_asf_guid) + 14;
+    while(end - p &gt;= sizeof(ff_asf_guid) + 8) {
+        uint64_t chunksize = AV_RL64(p + sizeof(ff_asf_guid));
+        if (!chunksize || chunksize &gt; end - p) {
+            dprintf(NULL, &quot;chunksize is exceptional value:%&quot;PRId64&quot;!\n&quot;, chunksize);
+            return -1;
+        }
+        if (!memcmp(p, ff_asf_file_header, sizeof(ff_asf_guid))) {
+            /* read packet size */
+            if (end - p &gt; sizeof(ff_asf_guid) * 2 + 68) {
+                mms-&gt;asf_packet_len = AV_RL32(p + sizeof(ff_asf_guid) * 2 + 64);
+                if (mms-&gt;asf_packet_len &lt;= 0 || mms-&gt;asf_packet_len &gt; sizeof(mms-&gt;in_buffer)) {
+                    dprintf(NULL,&quot;Too large packet len:%d&quot;
+                        &quot; may overwrite in_buffer when padding&quot;, mms-&gt;asf_packet_len);
+                    return -1;
+                }
+            }
+        } else if (!memcmp(p, ff_asf_stream_header, sizeof(ff_asf_guid))) {
+            flags     = AV_RL16(p + sizeof(ff_asf_guid)*3 + 24);
+            stream_id = flags &amp; 0x7F;
+            //The second condition is for checking CS_PKT_STREAM_ID_REQUEST packet size,
+            //we can calcuate the packet size by stream_num.
+            //Please see function send_stream_selection_request().
+            if (mms-&gt;stream_num &lt; MAX_STREAMS &amp;&amp;
+                    46 + mms-&gt;stream_num * 6 &lt; sizeof(mms-&gt;out_buffer)) {
+                mms-&gt;streams[mms-&gt;stream_num].id = stream_id;
+                mms-&gt;stream_num++;
+            } else {
+                dprintf(NULL, &quot;Too many streams.\n&quot;);
+                return -1;
+            }
+        } else if (!memcmp(p, ff_asf_head1_guid, sizeof(ff_asf_guid))) {
+            chunksize = 46; // see references [2] section 3.4. This should be set 46.
+        }
+        p += chunksize;
+    }
+
+    return 0;
+}
+
+/** Send MMST stream selection command based on the AVStream-&gt;discard values. */
+static int send_stream_selection_request(MMSContext *mms)
+{
+    int i;
+
+    //  send the streams we want back...
+    start_command_packet(mms, CS_PKT_STREAM_ID_REQUEST);
+    bytestream_put_le32(&amp;mms-&gt;write_out_ptr, mms-&gt;stream_num);         // stream nums
+    for(i= 0; i&lt;mms-&gt;stream_num; i++) {
+        bytestream_put_le16(&amp;mms-&gt;write_out_ptr, 0xffff);              // flags
+        bytestream_put_le16(&amp;mms-&gt;write_out_ptr, mms-&gt;streams[i].id);  // stream id
+        bytestream_put_le16(&amp;mms-&gt;write_out_ptr, 0);                   // selection
+    }
+    return send_command_packet(mms);
+}
+
+static int read_data(MMSContext *mms, uint8_t *buf, const int buf_size)
+{
+    int read_size;
+    read_size = FFMIN(buf_size, mms-&gt;remaining_in_len);
+    memcpy(buf, mms-&gt;read_in_ptr, read_size);
+    mms-&gt;remaining_in_len -= read_size;
+    mms-&gt;read_in_ptr      += read_size;
+    return read_size;
+}
+
+/** Read at most one media packet (or a whole header). */
+static int read_mms_packet(MMSContext *mms, uint8_t *buf, int buf_size)
+{
+    int result = 0;
+    int size_to_copy;
+
+    do {
+        if(mms-&gt;asf_header_read_size &lt; mms-&gt;asf_header_size &amp;&amp; !mms-&gt;is_playing) {
+            /* Read from ASF header buffer */
+            size_to_copy= FFMIN(buf_size,
+                                mms-&gt;asf_header_size - mms-&gt;asf_header_read_size);
+            memcpy(buf, mms-&gt;asf_header + mms-&gt;asf_header_read_size, size_to_copy);
+            mms-&gt;asf_header_read_size += size_to_copy;
+            result += size_to_copy;
+            dprintf(NULL, &quot;Copied %d bytes from stored header. left: %d\n&quot;,
+                   size_to_copy, mms-&gt;asf_header_size - mms-&gt;asf_header_read_size);
+            if (mms-&gt;asf_header_size == mms-&gt;asf_header_read_size) {
+                av_freep(&amp;mms-&gt;asf_header);
+                mms-&gt;is_playing = 1;
+            }
+        } else if(mms-&gt;remaining_in_len) {
+            /* Read remaining packet data to buffer.
+             * the result can not be zero because remaining_in_len is positive.*/
+            result = read_data(mms, buf, buf_size);
+        } else {
+            /* Read from network */
+            int err = mms_safe_send_recv(mms, NULL, SC_PKT_ASF_MEDIA);
+            if (err == 0) {
+                if(mms-&gt;remaining_in_len&gt;mms-&gt;asf_packet_len) {
+                    dprintf(NULL, &quot;Incoming packet&quot;
+                            &quot;larger than the asf packet size stated (%d&gt;%d)\n&quot;,
+                            mms-&gt;remaining_in_len, mms-&gt;asf_packet_len);
+                    result= AVERROR_IO;
+                } else {
+                    // copy the data to the packet buffer.
+                    result = read_data(mms, buf, buf_size);
+                    if (result == 0) {
+                        dprintf(NULL, &quot;read asf media paket size is zero!\n&quot;);
+                        break;
+                    }
+                }
+            } else {
+                dprintf(NULL, &quot;read packet error!\n&quot;);
+                break;
+            }
+        }
+    } while(!result); // only return one packet.
+    return result;
+}
+
+static int send_close_packet(MMSContext *mms)
+{
+    start_command_packet(mms, CS_PKT_STREAM_CLOSE);
+    insert_command_prefixes(mms, 1, 1);
+
+    return send_command_packet(mms);
+}
+
+/** Close the MMSH/MMST connection */
+static int mms_close(URLContext *h)
+{
+    MMSContext *mms = (MMSContext *)h-&gt;priv_data;
+
+    if(mms-&gt;mms_hd) {
+        send_close_packet(mms);
+        url_close(mms-&gt;mms_hd);
+    }
+
+    /* free all separately allocated pointers in mms */
+    av_free(mms-&gt;asf_header);
+    av_freep(&amp;h-&gt;priv_data);
+
+    return 0;
+}
+
+static int mms_open(URLContext *h, const char *uri, int flags)
+{
+    MMSContext *mms;
+    int port, err;
+    char tcpname[256];
+
+    h-&gt;is_streamed = 1;
+    mms = h-&gt;priv_data = av_mallocz(sizeof(MMSContext));
+    if (!h-&gt;priv_data)
+        return AVERROR(ENOMEM);
+
+    // only for MMS over TCP, so set proto = NULL
+    av_url_split(NULL, 0, NULL, 0,
+            mms-&gt;host, sizeof(mms-&gt;host), &amp;port, mms-&gt;path,
+            sizeof(mms-&gt;path), uri);
+
+    if(port&lt;0)
+        port = 1755; // defaut mms protocol port
+
+    // establish tcp connection.
+    ff_url_join(tcpname, sizeof(tcpname), &quot;tcp&quot;, NULL, mms-&gt;host, port, NULL);
+    err = url_open(&amp;mms-&gt;mms_hd, tcpname, URL_RDWR);
+    if (err)
+        goto fail;
+
+    mms-&gt;packet_id        = 3;          // default, initial value.
+    mms-&gt;header_packet_id = 2;          // default, initial value.
+    err = mms_safe_send_recv(mms, send_startup_packet, SC_PKT_CLIENT_ACCEPTED);
+    if (err)
+        goto fail;
+    err = mms_safe_send_recv(mms, send_time_test_data, SC_PKT_TIMING_TEST_REPLY);
+    if (err)
+        goto fail;
+    err = mms_safe_send_recv(mms, send_protocol_select, SC_PKT_PROTOCOL_ACCEPTED);
+    if (err)
+        goto fail;
+    err = mms_safe_send_recv(mms, send_media_file_request, SC_PKT_MEDIA_FILE_DETAILS);
+    if (err)
+        goto fail;
+    err = mms_safe_send_recv(mms, send_media_header_request, SC_PKT_HEADER_REQUEST_ACCEPTED);
+    if (err)
+        goto fail;
+    err = mms_safe_send_recv(mms, NULL, SC_PKT_ASF_HEADER);
+    if (err)
+        goto fail;
+    if((mms-&gt;incoming_flags != 0X08) &amp;&amp; (mms-&gt;incoming_flags != 0X0C))
+        goto fail;
+    err = asf_header_parser(mms);
+    if (err) {
+        dprintf(NULL, &quot;asf header parsed failed!\n&quot;);
+        goto fail;
+    }
+    mms-&gt;header_parsed = 1;
+
+    if (!mms-&gt;asf_packet_len || !mms-&gt;stream_num)
+        goto fail;
+
+    dprintf(NULL, &quot;Leaving open (success)\n&quot;);
+    return 0;
+fail:
+    mms_close(h);
+    dprintf(NULL, &quot;Leaving open (failure: %d)\n&quot;, err);
+    return err;
+}
+
+static int send_media_packet_request(MMSContext *mms)
+{
+    start_command_packet(mms, CS_PKT_START_FROM_PKT_ID);
+    insert_command_prefixes(mms, 1, 0x0001FFFF);
+    bytestream_put_le64(&amp;mms-&gt;write_out_ptr, 0);          // seek timestamp
+    bytestream_put_le32(&amp;mms-&gt;write_out_ptr, 0xffffffff); // unknown
+    bytestream_put_le32(&amp;mms-&gt;write_out_ptr, 0xffffffff); // packet offset
+    bytestream_put_byte(&amp;mms-&gt;write_out_ptr, 0xff);       // max stream time limit
+    bytestream_put_byte(&amp;mms-&gt;write_out_ptr, 0xff);       // max stream time limit
+    bytestream_put_byte(&amp;mms-&gt;write_out_ptr, 0xff);       // max stream time limit
+    bytestream_put_byte(&amp;mms-&gt;write_out_ptr, 0x00);       // stream time limit flag
+
+    mms-&gt;packet_id++;                                     // new packet_id
+    bytestream_put_le32(&amp;mms-&gt;write_out_ptr, mms-&gt;packet_id);
+    return send_command_packet(mms);
+}
+
+
+static void clear_stream_buffers(MMSContext *mms)
+{
+    mms-&gt;remaining_in_len = 0;
+    mms-&gt;read_in_ptr      = mms-&gt;in_buffer;
+}
+
+/** Read ASF data through the protocol. */
+static int mms_read(URLContext *h, uint8_t *buf, int size)
+{
+    /* TODO: see tcp.c:tcp_read() about a possible timeout scheme */
+    MMSContext *mms = h-&gt;priv_data;
+    int result = 0;
+
+    /* Since we read the header at open(), this shouldn't be possible */
+    assert(mms-&gt;header_parsed);
+
+    if (!mms-&gt;is_playing) {
+        dprintf(NULL, &quot;mms_read() before play().\n&quot;);
+        clear_stream_buffers(mms);
+        result = mms_safe_send_recv(mms, send_stream_selection_request, SC_PKT_STREAM_ID_ACCEPTED);
+        if (result)
+            return result;
+        // send media packet request
+        result = mms_safe_send_recv(mms, send_media_packet_request, SC_PKT_MEDIA_PKT_FOLLOWS);
+        if (result) {
+            return result;
+        }
+    }
+    return read_mms_packet(mms, buf, size);
+}
+
+URLProtocol mmst_protocol = {
+    &quot;mmst&quot;,
+    mms_open,
+    mms_read,
+    NULL, // write
+    NULL, // seek
+    mms_close,
+};

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/movenc.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/movenc.c	2010-07-25 10:07:43 UTC (rev 6480)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/movenc.c	2010-07-25 10:07:46 UTC (rev 6481)
@@ -2298,3 +2298,15 @@
     .codec_tag = (const AVCodecTag* const []){codec_ipod_tags, 0},
 };
 #endif
+/* MEANX */
+int movenc_init(void)
+{
+    av_register_output_format(&amp;mov_muxer);
+    av_register_output_format(&amp;tgp_muxer);
+    av_register_output_format(&amp;mp4_muxer);
+    av_register_output_format(&amp;psp_muxer);
+    av_register_output_format(&amp;tg2_muxer);
+    av_register_output_format(&amp;ipod_muxer);
+    return 0;
+}
+/* MEANX */

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/movenc.c.orig
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/movenc.c.orig	2010-07-25 10:07:43 UTC (rev 6480)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/movenc.c.orig	2010-07-25 10:07:46 UTC (rev 6481)
@@ -622,15 +622,18 @@
 } mov_pix_fmt_tags[] = {
     { PIX_FMT_YUYV422, MKTAG('y','u','v','s'),  0 },
     { PIX_FMT_UYVY422, MKTAG('2','v','u','y'),  0 },
-    { PIX_FMT_BGR555,  MKTAG('r','a','w',' '), 16 },
+    { PIX_FMT_RGB555BE,MKTAG('r','a','w',' '), 16 },
     { PIX_FMT_RGB555LE,MKTAG('L','5','5','5'), 16 },
     { PIX_FMT_RGB565LE,MKTAG('L','5','6','5'), 16 },
     { PIX_FMT_RGB565BE,MKTAG('B','5','6','5'), 16 },
+    { PIX_FMT_GRAY16BE,MKTAG('b','1','6','g'), 16 },
     { PIX_FMT_RGB24,   MKTAG('r','a','w',' '), 24 },
     { PIX_FMT_BGR24,   MKTAG('2','4','B','G'), 24 },
     { PIX_FMT_ARGB,    MKTAG('r','a','w',' '), 32 },
     { PIX_FMT_BGRA,    MKTAG('B','G','R','A'), 32 },
     { PIX_FMT_RGBA,    MKTAG('R','G','B','A'), 32 },
+    { PIX_FMT_ABGR,    MKTAG('A','B','G','R'), 32 },
+    { PIX_FMT_RGB48BE, MKTAG('b','4','8','r'), 48 },
 };
 
 static int mov_get_rawvideo_codec_tag(AVFormatContext *s, MOVTrack *track)
@@ -744,6 +747,19 @@
     return updateSize(pb, pos);
 }
 
+static int mov_write_pasp_tag(ByteIOContext *pb, MOVTrack *track)
+{
+    AVRational sar;
+    av_reduce(&amp;sar.num, &amp;sar.den, track-&gt;enc-&gt;sample_aspect_ratio.num,
+              track-&gt;enc-&gt;sample_aspect_ratio.den, INT_MAX);
+
+    put_be32(pb, 16);
+    put_tag(pb, &quot;pasp&quot;);
+    put_be32(pb, track-&gt;enc-&gt;sample_aspect_ratio.num);
+    put_be32(pb, track-&gt;enc-&gt;sample_aspect_ratio.den);
+    return 16;
+}
+
 static int mov_write_video_tag(ByteIOContext *pb, MOVTrack *track)
 {
     int64_t pos = url_ftell(pb);
@@ -805,6 +821,12 @@
     } else if(track-&gt;vosLen &gt; 0)
         mov_write_glbl_tag(pb, track);
 
+    if (track-&gt;mode == MODE_MOV &amp;&amp;
+        track-&gt;enc-&gt;sample_aspect_ratio.den &amp;&amp; track-&gt;enc-&gt;sample_aspect_ratio.num &amp;&amp;
+        track-&gt;enc-&gt;sample_aspect_ratio.den != track-&gt;enc-&gt;sample_aspect_ratio.num) {
+        mov_write_pasp_tag(pb, track);
+    }
+
     return updateSize(pb, pos);
 }
 
@@ -1608,8 +1630,8 @@
         put_be32(pb, size+8);
         put_tag(pb, &quot;udta&quot;);
         put_buffer(pb, buf, size);
-        av_free(buf);
     }
+    av_free(buf);
 
     return 0;
 }

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/mpegenc.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/mpegenc.c	2010-07-25 10:07:43 UTC (rev 6480)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/mpegenc.c	2010-07-25 10:07:46 UTC (rev 6481)
@@ -1300,3 +1300,13 @@
     mpeg_mux_end,
 };
 #endif
+// MEANX
+//
+int mpegenc_init(void)
+{
+    av_register_output_format(&amp;mpeg2dvd_muxer);
+    av_register_output_format(&amp;mpeg2svcd_muxer);
+    av_register_output_format(&amp;mpeg2vob_muxer);
+    av_register_output_format(&amp;mpeg1vcd_muxer);
+    return 0;
+}
\ No newline at end of file

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/mpegtsenc.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/mpegtsenc.c	2010-07-25 10:07:43 UTC (rev 6480)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/mpegtsenc.c	2010-07-25 10:07:46 UTC (rev 6481)
@@ -947,3 +947,8 @@
     mpegts_write_packet,
     mpegts_write_end,
 };
+int mpegtsenc_init(void)
+{
+    av_register_output_format(&amp;mpegts_muxer);
+    return 0;
+}
\ No newline at end of file

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rso.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rso.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rso.c	2010-07-25 10:07:46 UTC (rev 6481)
@@ -0,0 +1,30 @@
+/*
+ * RSO format common data
+ * Copyright (c) 2010 Rafael Carre
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include &quot;avformat.h&quot;
+#include &quot;internal.h&quot;
+#include &quot;rso.h&quot;
+
+const AVCodecTag ff_codec_rso_tags[] = {
+    { CODEC_ID_PCM_U8,          0x0100 },
+    { CODEC_ID_ADPCM_IMA_WAV,   0x0101 },
+    { CODEC_ID_NONE, 0 },
+};

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rso.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rso.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rso.h	2010-07-25 10:07:46 UTC (rev 6481)
@@ -0,0 +1,32 @@
+/*
+ * RSO format common data
+ * Copyright (c) 2010 Rafael Carre
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVFORMAT_RSO_H
+#define AVFORMAT_RSO_H
+
+#include &quot;internal.h&quot;
+
+#define RSO_HEADER_SIZE 8
+
+/* The ffmpeg codecs we support, and the IDs they have in the file */
+extern const AVCodecTag ff_codec_rso_tags[];
+
+#endif /* AVFORMAT_RSO_H */

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rsodec.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rsodec.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rsodec.c	2010-07-25 10:07:46 UTC (rev 6481)
@@ -0,0 +1,102 @@
+/*
+ * RSO demuxer
+ * Copyright (c) 2001 Fabrice Bellard (original AU code)
+ * Copyright (c) 2010 Rafael Carre
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include &quot;libavutil/intreadwrite.h&quot;
+#include &quot;avformat.h&quot;
+#include &quot;internal.h&quot;
+#include &quot;raw.h&quot;
+#include &quot;riff.h&quot;
+#include &quot;rso.h&quot;
+
+static int rso_read_header(AVFormatContext *s, AVFormatParameters *ap)
+{
+    ByteIOContext *pb = s-&gt;pb;
+    int id, rate, bps;
+    unsigned int size;
+    enum CodecID codec;
+    AVStream *st;
+
+    id   = get_be16(pb);
+    size = get_be16(pb);
+    rate = get_be16(pb);
+    get_be16(pb);   /* play mode ? (0x0000 = don't loop) */
+
+    codec = ff_codec_get_id(ff_codec_rso_tags, id);
+
+    if (codec == CODEC_ID_ADPCM_IMA_WAV) {
+        av_log(s, AV_LOG_ERROR, &quot;ADPCM in RSO not implemented\n&quot;);
+        return AVERROR_PATCHWELCOME;
+    }
+
+    bps = av_get_bits_per_sample(codec);
+    if (!bps) {
+        av_log_ask_for_sample(s, &quot;could not determine bits per sample\n&quot;);
+        return AVERROR_INVALIDDATA;
+    }
+
+    /* now we are ready: build format streams */
+    st = av_new_stream(s, 0);
+    if (!st)
+        return AVERROR(ENOMEM);
+
+    st-&gt;duration            = (size * 8) / bps;
+    st-&gt;codec-&gt;codec_type   = AVMEDIA_TYPE_AUDIO;
+    st-&gt;codec-&gt;codec_tag    = id;
+    st-&gt;codec-&gt;codec_id     = codec;
+    st-&gt;codec-&gt;channels     = 1;
+    st-&gt;codec-&gt;sample_rate  = rate;
+
+    av_set_pts_info(st, 64, 1, rate);
+
+    return 0;
+}
+
+#define BLOCK_SIZE 1024 /* in samples */
+
+static int rso_read_packet(AVFormatContext *s, AVPacket *pkt)
+{
+    int bps = av_get_bits_per_sample(s-&gt;streams[0]-&gt;codec-&gt;codec_id);
+    int ret = av_get_packet(s-&gt;pb, pkt, BLOCK_SIZE * bps &gt;&gt; 3);
+
+    if (ret &lt; 0)
+        return ret;
+
+    pkt-&gt;stream_index = 0;
+
+    /* note: we need to modify the packet size here to handle the last packet */
+    pkt-&gt;size = ret;
+
+    return 0;
+}
+
+AVInputFormat rso_demuxer = {
+    .name           =   &quot;rso&quot;,
+    .long_name      =   NULL_IF_CONFIG_SMALL(&quot;Lego Mindstorms RSO format&quot;),
+    .extensions     =   &quot;rso&quot;,
+    .priv_data_size =   0,
+    .read_probe     =   NULL, /* no magic value in this format */
+    .read_header    =   rso_read_header,
+    .read_packet    =   rso_read_packet,
+    .read_close     =   NULL,
+    .read_seek      =   pcm_read_seek,
+    .codec_tag      =   (const AVCodecTag* const []){ff_codec_rso_tags, 0},
+};

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rsoenc.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rsoenc.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rsoenc.c	2010-07-25 10:07:46 UTC (rev 6481)
@@ -0,0 +1,114 @@
+/*
+ * RSO muxer
+ * Copyright (c) 2001 Fabrice Bellard (original AU code)
+ * Copyright (c) 2010 Rafael Carre
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include &quot;avformat.h&quot;
+#include &quot;internal.h&quot;
+#include &quot;riff.h&quot;
+#include &quot;rso.h&quot;
+
+static int rso_write_header(AVFormatContext *s)
+{
+    ByteIOContext  *pb  = s-&gt;pb;
+    AVCodecContext *enc = s-&gt;streams[0]-&gt;codec;
+
+    if (!enc-&gt;codec_tag)
+        return AVERROR_INVALIDDATA;
+
+    if (enc-&gt;channels != 1) {
+        av_log(s, AV_LOG_ERROR, &quot;RSO only supports mono\n&quot;);
+        return AVERROR_INVALIDDATA;
+    }
+
+    if (url_is_streamed(s-&gt;pb)) {
+        av_log(s, AV_LOG_ERROR, &quot;muxer does not support non seekable output\n&quot;);
+        return AVERROR_INVALIDDATA;
+    }
+
+    /* XXX: find legal sample rates (if any) */
+    if (enc-&gt;sample_rate &gt;= 1u&lt;&lt;16) {
+        av_log(s, AV_LOG_ERROR, &quot;Sample rate must be &lt; 65536\n&quot;);
+        return AVERROR_INVALIDDATA;
+    }
+
+    if (enc-&gt;codec_id == CODEC_ID_ADPCM_IMA_WAV) {
+        av_log(s, AV_LOG_ERROR, &quot;ADPCM in RSO not implemented\n&quot;);
+        return AVERROR_PATCHWELCOME;
+    }
+
+    /* format header */
+    put_be16(pb, enc-&gt;codec_tag);   /* codec ID */
+    put_be16(pb, 0);                /* data size, will be written at EOF */
+    put_be16(pb, enc-&gt;sample_rate);
+    put_be16(pb, 0x0000);           /* play mode ? (0x0000 = don't loop) */
+
+    put_flush_packet(pb);
+
+    return 0;
+}
+
+static int rso_write_packet(AVFormatContext *s, AVPacket *pkt)
+{
+    put_buffer(s-&gt;pb, pkt-&gt;data, pkt-&gt;size);
+    return 0;
+}
+
+static int rso_write_trailer(AVFormatContext *s)
+{
+    ByteIOContext *pb = s-&gt;pb;
+    int64_t file_size;
+    uint16_t coded_file_size;
+
+    file_size = url_ftell(pb);
+
+    if (file_size &lt; 0)
+        return file_size;
+
+    if (file_size &gt; 0xffff + RSO_HEADER_SIZE) {
+        av_log(s, AV_LOG_WARNING,
+               &quot;Output file is too big (%&quot;PRId64&quot; bytes &gt;= 64kB)\n&quot;, file_size);
+        coded_file_size = 0xffff;
+    } else {
+        coded_file_size = file_size - RSO_HEADER_SIZE;
+    }
+
+    /* update file size */
+    url_fseek(pb, 2, SEEK_SET);
+    put_be16(pb, coded_file_size);
+    url_fseek(pb, file_size, SEEK_SET);
+
+    put_flush_packet(pb);
+
+    return 0;
+}
+
+AVOutputFormat rso_muxer = {
+    .name           =   &quot;rso&quot;,
+    .long_name      =   NULL_IF_CONFIG_SMALL(&quot;Lego Mindstorms RSO format&quot;),
+    .extensions     =   &quot;rso&quot;,
+    .priv_data_size =   0,
+    .audio_codec    =   CODEC_ID_PCM_U8,
+    .video_codec    =   CODEC_ID_NONE,
+    .write_header   =   rso_write_header,
+    .write_packet   =   rso_write_packet,
+    .write_trailer  =   rso_write_trailer,
+    .codec_tag      =   (const AVCodecTag* const []){ff_codec_rso_tags, 0},
+};

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rtpdec_mpeg4.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rtpdec_mpeg4.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rtpdec_mpeg4.c	2010-07-25 10:07:46 UTC (rev 6481)
@@ -0,0 +1,281 @@
+/**
+ * Common code for the RTP depacketization of MPEG-4 formats.
+ * Copyright (c) 2010 Fabrice Bellard
+ *                    Romain Degez
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * @brief MPEG4 / RTP Code
+ * @author Fabrice Bellard
+ * @author Romain Degez
+ */
+
+#include &quot;rtpdec_mpeg4.h&quot;
+#include &quot;internal.h&quot;
+#include &quot;libavutil/avstring.h&quot;
+#include &quot;libavcodec/get_bits.h&quot;
+#include &lt;strings.h&gt;
+
+/** Structure listing useful vars to parse RTP packet payload*/
+struct PayloadContext
+{
+    int sizelength;
+    int indexlength;
+    int indexdeltalength;
+    int profile_level_id;
+    int streamtype;
+    int objecttype;
+    char *mode;
+
+    /** mpeg 4 AU headers */
+    struct AUHeaders {
+        int size;
+        int index;
+        int cts_flag;
+        int cts;
+        int dts_flag;
+        int dts;
+        int rap_flag;
+        int streamstate;
+    } *au_headers;
+    int au_headers_allocated;
+    int nb_au_headers;
+    int au_headers_length_bytes;
+    int cur_au_index;
+};
+
+/* return the length and optionally the data */
+static int hex_to_data(uint8_t *data, const char *p)
+{
+    int c, len, v;
+
+    len = 0;
+    v = 1;
+    for (;;) {
+        p += strspn(p, SPACE_CHARS);
+        if (*p == '\0')
+            break;
+        c = toupper((unsigned char) *p++);
+        if (c &gt;= '0' &amp;&amp; c &lt;= '9')
+            c = c - '0';
+        else if (c &gt;= 'A' &amp;&amp; c &lt;= 'F')
+            c = c - 'A' + 10;
+        else
+            break;
+        v = (v &lt;&lt; 4) | c;
+        if (v &amp; 0x100) {
+            if (data)
+                data[len] = v;
+            len++;
+            v = 1;
+        }
+    }
+    return len;
+}
+
+typedef struct {
+    const char *str;
+    uint16_t    type;
+    uint32_t    offset;
+} AttrNameMap;
+
+/* All known fmtp parameters and the corresponding RTPAttrTypeEnum */
+#define ATTR_NAME_TYPE_INT 0
+#define ATTR_NAME_TYPE_STR 1
+static const AttrNameMap attr_names[]=
+{
+    { &quot;SizeLength&quot;,       ATTR_NAME_TYPE_INT,
+      offsetof(PayloadContext, sizelength) },
+    { &quot;IndexLength&quot;,      ATTR_NAME_TYPE_INT,
+      offsetof(PayloadContext, indexlength) },
+    { &quot;IndexDeltaLength&quot;, ATTR_NAME_TYPE_INT,
+      offsetof(PayloadContext, indexdeltalength) },
+    { &quot;profile-level-id&quot;, ATTR_NAME_TYPE_INT,
+      offsetof(PayloadContext, profile_level_id) },
+    { &quot;StreamType&quot;,       ATTR_NAME_TYPE_INT,
+      offsetof(PayloadContext, streamtype) },
+    { &quot;mode&quot;,             ATTR_NAME_TYPE_STR,
+      offsetof(PayloadContext, mode) },
+    { NULL, -1, -1 },
+};
+
+static PayloadContext *new_context(void)
+{
+    return av_mallocz(sizeof(PayloadContext));
+}
+
+static void free_context(PayloadContext * data)
+{
+    int i;
+    for (i = 0; i &lt; data-&gt;nb_au_headers; i++) {
+         /* according to rtp_parse_mp4_au, we treat multiple
+          * au headers as one, so nb_au_headers is always 1.
+          * loop anyway in case this changes.
+          * (note: changes done carelessly might lead to a double free)
+          */
+       av_free(&amp;data-&gt;au_headers[i]);
+    }
+    av_free(data-&gt;mode);
+    av_free(data);
+}
+
+static int parse_fmtp_config(AVCodecContext * codec, char *value)
+{
+    /* decode the hexa encoded parameter */
+    int len = hex_to_data(NULL, value);
+    if (codec-&gt;extradata)
+        av_free(codec-&gt;extradata);
+    codec-&gt;extradata = av_mallocz(len + FF_INPUT_BUFFER_PADDING_SIZE);
+    if (!codec-&gt;extradata)
+        return AVERROR(ENOMEM);
+    codec-&gt;extradata_size = len;
+    hex_to_data(codec-&gt;extradata, value);
+    return 0;
+}
+
+static int rtp_parse_mp4_au(PayloadContext *data, const uint8_t *buf)
+{
+    int au_headers_length, au_header_size, i;
+    GetBitContext getbitcontext;
+
+    /* decode the first 2 bytes where the AUHeader sections are stored
+       length in bits */
+    au_headers_length = AV_RB16(buf);
+
+    if (au_headers_length &gt; RTP_MAX_PACKET_LENGTH)
+      return -1;
+
+    data-&gt;au_headers_length_bytes = (au_headers_length + 7) / 8;
+
+    /* skip AU headers length section (2 bytes) */
+    buf += 2;
+
+    init_get_bits(&amp;getbitcontext, buf, data-&gt;au_headers_length_bytes * 8);
+
+    /* XXX: Wrong if optionnal additional sections are present (cts, dts etc...) */
+    au_header_size = data-&gt;sizelength + data-&gt;indexlength;
+    if (au_header_size &lt;= 0 || (au_headers_length % au_header_size != 0))
+        return -1;
+
+    data-&gt;nb_au_headers = au_headers_length / au_header_size;
+    if (!data-&gt;au_headers || data-&gt;au_headers_allocated &lt; data-&gt;nb_au_headers) {
+        av_free(data-&gt;au_headers);
+        data-&gt;au_headers = av_malloc(sizeof(struct AUHeaders) * data-&gt;nb_au_headers);
+        data-&gt;au_headers_allocated = data-&gt;nb_au_headers;
+    }
+
+    /* XXX: We handle multiple AU Section as only one (need to fix this for interleaving)
+       In my test, the FAAD decoder does not behave correctly when sending each AU one by one
+       but does when sending the whole as one big packet...  */
+    data-&gt;au_headers[0].size = 0;
+    data-&gt;au_headers[0].index = 0;
+    for (i = 0; i &lt; data-&gt;nb_au_headers; ++i) {
+        data-&gt;au_headers[0].size += get_bits_long(&amp;getbitcontext, data-&gt;sizelength);
+        data-&gt;au_headers[0].index = get_bits_long(&amp;getbitcontext, data-&gt;indexlength);
+    }
+
+    data-&gt;nb_au_headers = 1;
+
+    return 0;
+}
+
+
+/* Follows RFC 3640 */
+static int aac_parse_packet(AVFormatContext *ctx,
+                            PayloadContext *data,
+                            AVStream *st,
+                            AVPacket *pkt,
+                            uint32_t *timestamp,
+                            const uint8_t *buf, int len, int flags)
+{
+    if (rtp_parse_mp4_au(data, buf))
+        return -1;
+
+    buf += data-&gt;au_headers_length_bytes + 2;
+    len -= data-&gt;au_headers_length_bytes + 2;
+
+    /* XXX: Fixme we only handle the case where rtp_parse_mp4_au define
+                    one au_header */
+    av_new_packet(pkt, data-&gt;au_headers[0].size);
+    memcpy(pkt-&gt;data, buf, data-&gt;au_headers[0].size);
+
+    pkt-&gt;stream_index = st-&gt;index;
+    return 0;
+}
+
+static int parse_fmtp(AVStream *stream, PayloadContext *data,
+                      char *attr, char *value)
+{
+    AVCodecContext *codec = stream-&gt;codec;
+    int res, i;
+
+    if (!strcmp(attr, &quot;config&quot;)) {
+        res = parse_fmtp_config(codec, value);
+
+        if (res &lt; 0)
+            return res;
+    }
+
+    if (codec-&gt;codec_id == CODEC_ID_AAC) {
+        /* Looking for a known attribute */
+        for (i = 0; attr_names[i].str; ++i) {
+            if (!strcasecmp(attr, attr_names[i].str)) {
+                if (attr_names[i].type == ATTR_NAME_TYPE_INT) {
+                    *(int *)((char *)data+
+                        attr_names[i].offset) = atoi(value);
+                } else if (attr_names[i].type == ATTR_NAME_TYPE_STR)
+                    *(char **)((char *)data+
+                        attr_names[i].offset) = av_strdup(value);
+            }
+        }
+    }
+    return 0;
+}
+
+static int parse_sdp_line(AVFormatContext *s, int st_index,
+                          PayloadContext *data, const char *line)
+{
+    const char *p;
+
+    if (av_strstart(line, &quot;fmtp:&quot;, &amp;p))
+        return ff_parse_fmtp(s-&gt;streams[st_index], data, p, parse_fmtp);
+
+    return 0;
+}
+
+RTPDynamicProtocolHandler ff_mp4v_es_dynamic_handler = {
+    .enc_name           = &quot;MP4V-ES&quot;,
+    .codec_type         = AVMEDIA_TYPE_VIDEO,
+    .codec_id           = CODEC_ID_MPEG4,
+    .parse_sdp_a_line   = parse_sdp_line,
+    .open               = NULL,
+    .close              = NULL,
+    .parse_packet       = NULL
+};
+
+RTPDynamicProtocolHandler ff_mpeg4_generic_dynamic_handler = {
+    .enc_name           = &quot;mpeg4-generic&quot;,
+    .codec_type         = AVMEDIA_TYPE_AUDIO,
+    .codec_id           = CODEC_ID_AAC,
+    .parse_sdp_a_line   = parse_sdp_line,
+    .open               = new_context,
+    .close              = free_context,
+    .parse_packet       = aac_parse_packet
+};

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rtpdec_mpeg4.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rtpdec_mpeg4.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rtpdec_mpeg4.h	2010-07-25 10:07:46 UTC (rev 6481)
@@ -0,0 +1,39 @@
+/**
+ * Common code for the RTP depacketization of MPEG-4 formats.
+ * Copyright (c) 2010 Fabrice Bellard
+ *                    Romain Degez
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVFORMAT_RTPDEC_MPEG4_H
+#define AVFORMAT_RTPDEC_MPEG4_H
+
+#include &quot;rtpdec.h&quot;
+
+/**
+ * MPEG-4 Video RTP callbacks. (RFC 3016)
+ */
+extern RTPDynamicProtocolHandler ff_mp4v_es_dynamic_handler;
+
+/**
+ * AAC RTP callbacks. (RFC 3640)
+ */
+extern RTPDynamicProtocolHandler ff_mpeg4_generic_dynamic_handler;
+
+#endif /* AVFORMAT_RTPDEC_MPEG4_H */
+

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rtpdec_qdm2.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rtpdec_qdm2.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rtpdec_qdm2.c	2010-07-25 10:07:46 UTC (rev 6481)
@@ -0,0 +1,316 @@
+/*
+ * QDesign Music 2 (QDM2) payload for RTP
+ * Copyright (c) 2010 Ronald S. Bultje
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * @brief RTP support for the QDM2 payload (todo: wiki)
+ * @author Ronald S. Bultje &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">rbultje at ronald.bitfreak.net</A>&gt;
+ */
+
+#include &lt;string.h&gt;
+#include &quot;libavutil/intreadwrite.h&quot;
+#include &quot;libavcodec/avcodec.h&quot;
+#include &quot;rtp.h&quot;
+#include &quot;rtpdec.h&quot;
+#include &quot;rtpdec_qdm2.h&quot;
+
+struct PayloadContext {
+    /** values read from the config header, used as packet headers */
+    //@{
+    int block_type;            ///&lt; superblock type, value 2 .. 8
+    int block_size;            ///&lt; from extradata, used as pkt length
+    int subpkts_per_block;     ///&lt; max. nr. of subpackets to add per output buffer
+    //@}
+
+    /** Temporary storage for superblock restoring, per packet ID (0x80 total) */
+    //@{
+    uint16_t len[0x80];        ///&lt; how much the temporary buffer is filled
+    uint8_t  buf[0x80][0x800]; ///&lt; the temporary storage buffer
+
+    unsigned int cache;        ///&lt; number of data packets that we have cached right now
+    unsigned int n_pkts;       ///&lt; number of RTP packets received since last packet output / config
+    uint32_t timestamp;        ///&lt; timestamp of next-to-be-returned packet
+    //@}
+};
+
+/**
+ * Parses configuration (basically the codec-specific extradata) from
+ * a RTP config subpacket (starts with 0xff).
+ *
+ * Layout of the config subpacket (in bytes):
+ * 1: 0xFF          &lt;- config ID
+ * then an array {
+ *     1: size      &lt;- of the current item
+ *     1: item type &lt;- 0 .. 4
+ *     size-2: data &lt;- data depends on the item type
+ * }
+ *
+ * Item 0 implies the end of the config subpacket, and has no data.
+ * Item 1 implies a stream configuration without extradata.
+ * Item 2 max. nr. of subpackets per superblock
+ * Item 3 superblock type for the stream
+ * Item 4 implies a stream configuration with extradata (size &gt;= 0x1c).
+ *
+ * @return &lt;0 on error, otherwise the number of bytes parsed from the
+ *         input buffer.
+ */
+static int qdm2_parse_config(PayloadContext *qdm, AVStream *st,
+                             const uint8_t *buf, const uint8_t *end)
+{
+    const uint8_t *p = buf;
+
+    while (end - p &gt;= 2) {
+        unsigned int item_len = p[0], config_item = p[1];
+
+        if (item_len &lt; 2 || end - p &lt; item_len || config_item &gt; 4)
+            return AVERROR_INVALIDDATA;
+
+        switch (config_item) {
+            case 0: /* end of config block */
+                return p - buf + item_len;
+            case 1: /* stream without extradata */
+                /* FIXME: set default qdm-&gt;block_size */
+                break;
+            case 2: /**&lt; subpackets per block */
+                if (item_len &lt; 3)
+                    return AVERROR_INVALIDDATA;
+                qdm-&gt;subpkts_per_block = p[2];
+                break;
+            case 3: /* superblock type */
+                if (item_len &lt; 4)
+                    return AVERROR_INVALIDDATA;
+                qdm-&gt;block_type = AV_RB16(p + 2);
+                break;
+            case 4: /* stream with extradata */
+                if (item_len &lt; 30)
+                    return AVERROR_INVALIDDATA;
+                av_freep(&amp;st-&gt;codec-&gt;extradata);
+                st-&gt;codec-&gt;extradata_size = 26 + item_len;
+                if (!(st-&gt;codec-&gt;extradata = av_mallocz(st-&gt;codec-&gt;extradata_size + FF_INPUT_BUFFER_PADDING_SIZE))) {
+                    st-&gt;codec-&gt;extradata_size = 0;
+                    return AVERROR(ENOMEM);
+                }
+                AV_WB32(st-&gt;codec-&gt;extradata, 12);
+                memcpy(st-&gt;codec-&gt;extradata + 4, &quot;frma&quot;, 4);
+                memcpy(st-&gt;codec-&gt;extradata + 8, &quot;QDM2&quot;, 4);
+                AV_WB32(st-&gt;codec-&gt;extradata + 12, 6 + item_len);
+                memcpy(st-&gt;codec-&gt;extradata + 16, &quot;QDCA&quot;, 4);
+                memcpy(st-&gt;codec-&gt;extradata + 20, p + 2, item_len - 2);
+                AV_WB32(st-&gt;codec-&gt;extradata + 18 + item_len, 8);
+                AV_WB32(st-&gt;codec-&gt;extradata + 22 + item_len, 0);
+
+                qdm-&gt;block_size = AV_RB32(p + 26);
+                break;
+        }
+
+        p += item_len;
+    }
+
+    return AVERROR(EAGAIN); /* not enough data */
+}
+
+/**
+ * Parses a single subpacket. We store this subpacket in an intermediate
+ * buffer (position depends on the ID (byte[0]). When called, at least
+ * 4 bytes are available for reading (see qdm2_parse_packet()).
+ *
+ * Layout of a single subpacket (RTP packets commonly contain multiple
+ * such subpackets) - length in bytes:
+ * 1:    ordering ID        &lt;- 0 .. 0x7F
+ * 1:    subpacket type     &lt;- 0 .. 0x7F; value &amp; 0x80 means subpacket length = 2 bytes, else 1 byte
+ * 1/2:  subpacket length   &lt;- length of the data following the flags/length fields
+ * if (subpacket type &amp; 0x7F) == 0x7F
+ *   1:  subpacket type, higher bits
+ * size: subpacket data
+ *
+ * The subpackets come in randomly, and should be encapsulated into 1
+ * or more superblocks (containing qdm-&gt;subpkts_per_block subpackets
+ * each) per RTP packet, in order of ascending &quot;ordering ID&quot;, see
+ * qdm2_restore_block().
+ *
+ * @return &lt;0 on error, otherwise the number of bytes parsed from the
+ *         input buffer.
+ */
+static int qdm2_parse_subpacket(PayloadContext *qdm, AVStream *st,
+                                const uint8_t *buf, const uint8_t *end)
+{
+    const uint8_t *p = buf;
+    unsigned int id, len, type, to_copy;
+
+    /* parse header so we know the size of the header/data */
+    id       = *p++;
+    type     = *p++;
+    if (type &amp; 0x80) {
+        len   = AV_RB16(p);
+        p    += 2;
+        type &amp;= 0x7F;
+    } else
+        len = *p++;
+
+    if (end - p &lt; len + (type == 0x7F) || id &gt;= 0x80)
+        return AVERROR_INVALIDDATA;
+    if (type == 0x7F)
+        type |= *p++ &lt;&lt; 8;
+
+    /* copy data into a temporary buffer */
+    to_copy = FFMIN(len + (p - &amp;buf[1]), 0x800 - qdm-&gt;len[id]);
+    memcpy(&amp;qdm-&gt;buf[id][qdm-&gt;len[id]], buf + 1, to_copy);
+    qdm-&gt;len[id] += to_copy;
+
+    return p + len - buf;
+}
+
+/**
+ * Adds a superblock header around a set of subpackets.
+ *
+ * @return &lt;0 on error, else 0.
+ */
+static int qdm2_restore_block(PayloadContext *qdm, AVStream *st, AVPacket *pkt)
+{
+    int to_copy, n, res, include_csum;
+    uint8_t *p, *csum_pos = NULL;
+
+    /* create packet to hold subpkts into a superblock */
+    assert(qdm-&gt;cache &gt; 0);
+    for (n = 0; n &lt; 0x80; n++)
+        if (qdm-&gt;len[n] &gt; 0)
+            break;
+    assert(n &lt; 0x80);
+
+    if ((res = av_new_packet(pkt, qdm-&gt;block_size)) &lt; 0)
+        return res;
+    memset(pkt-&gt;data, 0, pkt-&gt;size);
+    pkt-&gt;stream_index  = st-&gt;index;
+    p                  = pkt-&gt;data;
+
+    /* superblock header */
+    if (qdm-&gt;len[n] &gt; 0xff) {
+        *p++ = qdm-&gt;block_type | 0x80;
+        AV_WB16(p, qdm-&gt;len[n]);
+        p   += 2;
+    } else {
+        *p++ = qdm-&gt;block_type;
+        *p++ = qdm-&gt;len[n];
+    }
+    if ((include_csum = (qdm-&gt;block_type == 2 || qdm-&gt;block_type == 4))) {
+        csum_pos = p;
+        p       += 2;
+    }
+
+    /* subpacket data */
+    to_copy = FFMIN(qdm-&gt;len[n], pkt-&gt;size - (p - pkt-&gt;data));
+    memcpy(p, qdm-&gt;buf[n], to_copy);
+    qdm-&gt;len[n] = 0;
+
+    /* checksum header */
+    if (include_csum) {
+        unsigned int total = 0;
+        uint8_t *q;
+
+        for (q = pkt-&gt;data; q &lt; &amp;pkt-&gt;data[qdm-&gt;block_size]; q++)
+            total += *q;
+        AV_WB16(csum_pos, (uint16_t) total);
+    }
+
+    return 0;
+}
+
+/** return 0 on packet, no more left, 1 on packet, -1 on partial packet... */
+static int qdm2_parse_packet(AVFormatContext *s, PayloadContext *qdm,
+                             AVStream *st, AVPacket *pkt,
+                             uint32_t *timestamp,
+                             const uint8_t *buf, int len, int flags)
+{
+    int res = AVERROR_INVALIDDATA, n;
+    const uint8_t *end = buf + len, *p = buf;
+
+    if (len &gt; 0) {
+        if (len &lt; 2)
+            return AVERROR_INVALIDDATA;
+
+        /* configuration block */
+        if (*p == 0xff) {
+            if (qdm-&gt;n_pkts &gt; 0) {
+                av_log(s, AV_LOG_WARNING,
+                       &quot;Out of sequence config - dropping queue\n&quot;);
+                qdm-&gt;n_pkts = 0;
+                memset(qdm-&gt;len, 0, sizeof(qdm-&gt;len));
+            }
+
+            if ((res = qdm2_parse_config(qdm, st, ++p, end)) &lt; 0)
+                return res;
+            p += res;
+
+            /* We set codec_id to CODEC_ID_NONE initially to
+             * delay decoder initialization since extradata is
+             * carried within the RTP stream, not SDP. Here,
+             * by setting codec_id to CODEC_ID_QDM2, we are signalling
+             * to the decoder that it is OK to initialize. */
+            st-&gt;codec-&gt;codec_id = CODEC_ID_QDM2;
+        }
+
+        /* subpackets */
+        while (end - p &gt;= 4) {
+            if ((res = qdm2_parse_subpacket(qdm, st, p, end)) &lt; 0)
+                return res;
+            p += res;
+        }
+
+        qdm-&gt;timestamp = *timestamp;
+        if (++qdm-&gt;n_pkts &lt; qdm-&gt;subpkts_per_block)
+            return AVERROR(EAGAIN);
+        qdm-&gt;cache = 0;
+        for (n = 0; n &lt; 0x80; n++)
+            if (qdm-&gt;len[n] &gt; 0)
+                qdm-&gt;cache++;
+    }
+
+    /* output the subpackets into freshly created superblock structures */
+    if (!qdm-&gt;cache || (res = qdm2_restore_block(qdm, st, pkt)) &lt; 0)
+        return res;
+    if (--qdm-&gt;cache == 0)
+        qdm-&gt;n_pkts = 0;
+
+    *timestamp = qdm-&gt;timestamp;
+    qdm-&gt;timestamp = RTP_NOTS_VALUE;
+
+    return (qdm-&gt;cache &gt; 0) ? 1 : 0;
+}
+
+static PayloadContext *qdm2_extradata_new(void)
+{
+    return av_mallocz(sizeof(PayloadContext));
+}
+
+static void qdm2_extradata_free(PayloadContext *qdm)
+{
+    av_free(qdm);
+}
+
+RTPDynamicProtocolHandler ff_qdm2_dynamic_handler = {
+    &quot;X-QDM&quot;,
+    CODEC_TYPE_AUDIO,
+    CODEC_ID_NONE,
+    NULL,
+    qdm2_extradata_new,
+    qdm2_extradata_free,
+    qdm2_parse_packet,
+};

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rtpdec_qdm2.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rtpdec_qdm2.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rtpdec_qdm2.h	2010-07-25 10:07:46 UTC (rev 6481)
@@ -0,0 +1,32 @@
+/*
+ * QDesign Music 2 (QDM2) payload for RTP
+ * Copyright (c) 2010 Ronald S. Bultje
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVFORMAT_RTPDEC_QDM2_H
+#define AVFORMAT_RTPDEC_QDM2_H
+
+#include &quot;rtpdec.h&quot;
+
+/**
+ * QMD2 RTP callbacks.
+ */
+extern RTPDynamicProtocolHandler ff_qdm2_dynamic_handler;
+
+#endif /* AVFORMAT_RTPDEC_QDM2_H */

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rtpdec_svq3.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rtpdec_svq3.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rtpdec_svq3.c	2010-07-25 10:07:46 UTC (rev 6481)
@@ -0,0 +1,138 @@
+/*
+ * Sorenson-3 (SVQ3/SV3V) payload for RTP
+ * Copyright (c) 2010 Ronald S. Bultje
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * @brief RTP support for the SV3V (SVQ3) payload
+ * (<A HREF="http://wiki.multimedia.cx/index.php?title=Sorenson_Video_3#Packetization">http://wiki.multimedia.cx/index.php?title=Sorenson_Video_3#Packetization</A>)
+ * @author Ronald S. Bultje &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">rbultje at ronald.bitfreak.net</A>&gt;
+ */
+
+#include &lt;string.h&gt;
+#include &lt;libavcodec/get_bits.h&gt;
+#include &quot;rtp.h&quot;
+#include &quot;rtpdec.h&quot;
+#include &quot;rtpdec_svq3.h&quot;
+
+struct PayloadContext {
+    ByteIOContext *pktbuf;
+    int64_t        timestamp;
+    int            is_keyframe;
+};
+
+/** return 0 on packet, &lt;0 on partial packet or error... */
+static int svq3_parse_packet (AVFormatContext *s, PayloadContext *sv,
+                              AVStream *st, AVPacket *pkt,
+                              uint32_t *timestamp,
+                              const uint8_t *buf, int len, int flags)
+{
+    int config_packet, start_packet, end_packet;
+
+    if (len &lt; 2)
+        return AVERROR_INVALIDDATA;
+
+    config_packet = buf[0] &amp; 0x40;
+    start_packet  = buf[0] &amp; 0x20;
+    end_packet    = buf[0] &amp; 0x10;
+    buf += 2;     // ignore buf[1]
+    len -= 2;
+
+    if (config_packet) {
+
+        av_freep(&amp;st-&gt;codec-&gt;extradata);
+        st-&gt;codec-&gt;extradata_size = 0;
+
+        if (len &lt; 2 || !(st-&gt;codec-&gt;extradata =
+                         av_malloc(len + 8 + FF_INPUT_BUFFER_PADDING_SIZE)))
+            return AVERROR_INVALIDDATA;
+
+        st-&gt;codec-&gt;extradata_size = len + 8;
+        memcpy(st-&gt;codec-&gt;extradata, &quot;SEQH&quot;, 4);
+        AV_WB32(st-&gt;codec-&gt;extradata + 4, len);
+        memcpy(st-&gt;codec-&gt;extradata + 8, buf, len);
+
+        /* We set codec_id to CODEC_ID_NONE initially to
+         * delay decoder initialization since extradata is
+         * carried within the RTP stream, not SDP. Here,
+         * by setting codec_id to CODEC_ID_SVQ3, we are signalling
+         * to the decoder that it is OK to initialize. */
+        st-&gt;codec-&gt;codec_id = CODEC_ID_SVQ3;
+
+        return AVERROR(EAGAIN);
+    }
+
+    if (start_packet) {
+        int res;
+
+        if (sv-&gt;pktbuf) {
+            uint8_t *tmp;
+            url_close_dyn_buf(sv-&gt;pktbuf, &amp;tmp);
+            av_free(tmp);
+        }
+        if ((res = url_open_dyn_buf(&amp;sv-&gt;pktbuf)) &lt; 0)
+            return res;
+        sv-&gt;timestamp   = *timestamp;
+        sv-&gt;is_keyframe = flags &amp; RTP_FLAG_KEY;
+    }
+
+    if (!sv-&gt;pktbuf)
+        return AVERROR_INVALIDDATA;
+
+    put_buffer(sv-&gt;pktbuf, buf, len);
+
+    if (end_packet) {
+        av_init_packet(pkt);
+        pkt-&gt;stream_index = st-&gt;index;
+        *timestamp        = sv-&gt;timestamp;
+        pkt-&gt;flags        = sv-&gt;is_keyframe ? AV_PKT_FLAG_KEY : 0;
+        pkt-&gt;size         = url_close_dyn_buf(sv-&gt;pktbuf, &amp;pkt-&gt;data);
+        pkt-&gt;destruct     = av_destruct_packet;
+        sv-&gt;pktbuf        = NULL;
+        return 0;
+    }
+
+    return AVERROR(EAGAIN);
+}
+
+static PayloadContext *svq3_extradata_new(void)
+{
+    return av_mallocz(sizeof(PayloadContext));
+}
+
+static void svq3_extradata_free(PayloadContext *sv)
+{
+    if (sv-&gt;pktbuf) {
+        uint8_t *buf;
+        url_close_dyn_buf(sv-&gt;pktbuf, &amp;buf);
+        av_free(buf);
+    }
+    av_free(sv);
+}
+
+RTPDynamicProtocolHandler ff_svq3_dynamic_handler = {
+    &quot;X-SV3V-ES&quot;,
+    CODEC_TYPE_VIDEO,
+    CODEC_ID_NONE,          // see if (config_packet) above
+    NULL,                   // parse sdp line
+    svq3_extradata_new,
+    svq3_extradata_free,
+    svq3_parse_packet,
+};

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rtpdec_svq3.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rtpdec_svq3.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/rtpdec_svq3.h	2010-07-25 10:07:46 UTC (rev 6481)
@@ -0,0 +1,33 @@
+/*
+ * Sorenson-3 (SVQ3/SV3V) payload for RTP
+ * Copyright (c) 2010 Ronald S. Bultje
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVFORMAT_RTPDEC_SVQ3_H
+#define AVFORMAT_RTPDEC_SVQ3_H
+
+#include &quot;libavcodec/avcodec.h&quot;
+#include &quot;rtpdec.h&quot;
+
+/**
+ * Sorenson-3 RTP callbacks.
+ */
+extern RTPDynamicProtocolHandler ff_svq3_dynamic_handler;
+
+#endif /* AVFORMAT_RTPDEC_SVQ3_H */

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/sauce.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/sauce.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/sauce.c	2010-07-25 10:07:46 UTC (rev 6481)
@@ -0,0 +1,103 @@
+/*
+ * SAUCE header parser
+ * Copyright (c) 2010 Peter Ross &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">pross at xvid.org</A>&gt;
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * SAUCE header parser
+ */
+
+#include &quot;libavutil/intreadwrite.h&quot;
+#include &quot;avformat.h&quot;
+#include &quot;sauce.h&quot;
+
+int ff_sauce_read(AVFormatContext *avctx, uint64_t *fsize, int *got_width, int get_height)
+{
+    ByteIOContext *pb = avctx-&gt;pb;
+    char buf[36];
+    int datatype, filetype, t1, t2, nb_comments, flags;
+    uint64_t start_pos = url_fsize(pb) - 128;
+
+    url_fseek(pb, start_pos, SEEK_SET);
+    if (get_buffer(pb, buf, 7) != 7)
+        return -1;
+    if (memcmp(buf, &quot;SAUCE00&quot;, 7))
+        return -1;
+
+#define GET_SAUCE_META(name,size) \
+    if (get_buffer(pb, buf, size) == size &amp;&amp; buf[0]) { \
+        buf[size] = 0; \
+        av_metadata_set2(&amp;avctx-&gt;metadata, name, buf, 0); \
+    }
+
+    GET_SAUCE_META(&quot;title&quot;,     35)
+    GET_SAUCE_META(&quot;artist&quot;,    20)
+    GET_SAUCE_META(&quot;publisher&quot;, 20)
+    GET_SAUCE_META(&quot;date&quot;,      8)
+    url_fskip(pb, 4);
+    datatype    = get_byte(pb);
+    filetype    = get_byte(pb);
+    t1          = get_le16(pb);
+    t2          = get_le16(pb);
+    nb_comments = get_byte(pb);
+    flags       = get_byte(pb);
+    url_fskip(pb, 4);
+    GET_SAUCE_META(&quot;encoder&quot;,   22);
+
+    if (got_width &amp;&amp; datatype &amp;&amp; filetype) {
+        if ((datatype == 1 &amp;&amp; filetype &lt;=2) || (datatype == 5 &amp;&amp; filetype == 255) || datatype == 6) {
+            if (t1) {
+                avctx-&gt;streams[0]-&gt;codec-&gt;width = t1&lt;&lt;3;
+                *got_width = 1;
+            }
+            if (get_height &amp;&amp; t2)
+                avctx-&gt;streams[0]-&gt;codec-&gt;height = t2&lt;&lt;4;
+        } else if (datatype == 5) {
+            if (filetype &gt; 1) {
+                avctx-&gt;streams[0]-&gt;codec-&gt;width = (filetype == 1 ? t1 : filetype) &lt;&lt; 4;
+                *got_width = 1;
+            }
+            if (get_height &amp;&amp; t2)
+                avctx-&gt;streams[0]-&gt;codec-&gt;height = t2&lt;&lt;4;
+        }
+    }
+
+    *fsize -= 128;
+
+    if (nb_comments &gt; 0) {
+        url_fseek(pb, start_pos - 64*nb_comments - 5, SEEK_SET);
+        if (get_buffer(pb, buf, 5) == 5 &amp;&amp; !memcmp(buf, &quot;COMNT&quot;, 5)) {
+            int i;
+            char *str = av_malloc(65*nb_comments + 1);
+            *fsize -= 64*nb_comments + 5;
+            if (!str)
+                return 0;
+            for (i = 0; i &lt; nb_comments; i++) {
+                if (get_buffer(pb, str + 65*i, 64) != 64)
+                    break;
+                str[65*i + 64] = '\n';
+            }
+            str[65*i] = 0;
+            av_metadata_set2(&amp;avctx-&gt;metadata, &quot;comment&quot;, str, AV_METADATA_DONT_STRDUP_VAL);
+        }
+    }
+
+    return 0;
+}

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/sauce.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/sauce.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/sauce.h	2010-07-25 10:07:46 UTC (rev 6481)
@@ -0,0 +1,40 @@
+/*
+ * SAUCE header parser
+ * Copyright (c) 2010 Peter Ross &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">pross at xvid.org</A>&gt;
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * SAUCE header parser
+ */
+
+#ifndef AVFORMAT_SAUCE_H
+#define AVFORMAT_SAUCE_H
+
+#include &quot;avformat.h&quot;
+
+/**
+ * @param avctx AVFormatContext
+ * @param[out] fsize return length of file, less SAUCE header
+ * @param[out] got_width set to non-zero if SAUCE header reported height
+ * @param get_height Tell SAUCE header to parse height
+ */
+int ff_sauce_read(AVFormatContext *avctx, uint64_t *fsize, int *got_width, int get_height);
+
+#endif /* AVFORMAT_SAUCE_H */

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/srtdec.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/srtdec.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/srtdec.c	2010-07-25 10:07:46 UTC (rev 6481)
@@ -0,0 +1,102 @@
+/*
+ * SubRip subtitle demuxer
+ * Copyright (c) 2010  Aurelien Jacobs &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">aurel at gnuage.org</A>&gt;
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include &quot;avformat.h&quot;
+#include &quot;internal.h&quot;
+#include &quot;libavutil/intreadwrite.h&quot;
+
+static int srt_probe(AVProbeData *p)
+{
+    unsigned char *ptr = p-&gt;buf;
+    int i, v, num = 0;
+
+    if (AV_RB24(ptr) == 0xEFBBBF)
+        ptr += 3;  /* skip UTF-8 BOM */
+
+    for (i=0; i&lt;2; i++) {
+        if (num == i &amp;&amp; sscanf(ptr, &quot;%*d:%*2d:%*2d%*1[,.]%*3d --&gt; %*d:%*2d:%*2d%*1[,.]%3d&quot;, &amp;v) == 1)
+            return AVPROBE_SCORE_MAX;
+        num = atoi(ptr);
+        ptr += strcspn(ptr, &quot;\n&quot;) + 1;
+    }
+    return 0;
+}
+
+static int srt_read_header(AVFormatContext *s, AVFormatParameters *ap)
+{
+    AVStream *st = av_new_stream(s, 0);
+    if (!st)
+        return -1;
+    av_set_pts_info(st, 64, 1, 1000);
+    st-&gt;codec-&gt;codec_type = AVMEDIA_TYPE_SUBTITLE;
+    st-&gt;codec-&gt;codec_id   = CODEC_ID_SRT;
+    return 0;
+}
+
+static int64_t get_pts(const char *buf)
+{
+    int i, v, hour, min, sec, hsec;
+
+    for (i=0; i&lt;2; i++) {
+        if (sscanf(buf, &quot;%d:%2d:%2d%*1[,.]%3d --&gt; %*d:%*2d:%*2d%*1[,.]%3d&quot;,
+                   &amp;hour, &amp;min, &amp;sec, &amp;hsec, &amp;v) == 5) {
+            min += 60*hour;
+            sec += 60*min;
+            return sec*1000+hsec;
+        }
+        buf += strcspn(buf, &quot;\n&quot;) + 1;
+    }
+    return AV_NOPTS_VALUE;
+}
+
+static inline int is_eol(char c)
+{
+    return c == '\r' || c == '\n';
+}
+
+static int srt_read_packet(AVFormatContext *s, AVPacket *pkt)
+{
+    char buffer[2048], *ptr = buffer, *ptr2;
+    int64_t pos = url_ftell(s-&gt;pb);
+    int res = AVERROR_EOF;
+
+    do {
+        ptr2 = ptr;
+        ptr += ff_get_line(s-&gt;pb, ptr, sizeof(buffer)+buffer-ptr);
+    } while (!is_eol(*ptr2) &amp;&amp; !url_feof(s-&gt;pb) &amp;&amp; ptr-buffer&lt;sizeof(buffer)-1);
+
+    if (buffer[0] &amp;&amp; !(res = av_new_packet(pkt, ptr-buffer))) {
+        memcpy(pkt-&gt;data, buffer, pkt-&gt;size);
+        pkt-&gt;flags |= AV_PKT_FLAG_KEY;
+        pkt-&gt;pos = pos;
+        pkt-&gt;pts = pkt-&gt;dts = get_pts(pkt-&gt;data);
+    }
+    return res;
+}
+
+AVInputFormat srt_demuxer = {
+    .name        = &quot;srt&quot;,
+    .long_name   = NULL_IF_CONFIG_SMALL(&quot;SubRip subtitle format&quot;),
+    .read_probe  = srt_probe,
+    .read_header = srt_read_header,
+    .read_packet = srt_read_packet,
+    .flags       = AVFMT_GENERIC_INDEX,
+};

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/tty.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/tty.c	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/tty.c	2010-07-25 10:07:46 UTC (rev 6481)
@@ -0,0 +1,135 @@
+/*
+ * Tele-typewriter demuxer
+ * Copyright (c) 2010 Peter Ross &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">pross at xvid.org</A>&gt;
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * Tele-typewriter demuxer
+ */
+
+#include &quot;libavutil/intreadwrite.h&quot;
+#include &quot;libavutil/avstring.h&quot;
+#include &quot;avformat.h&quot;
+#include &quot;sauce.h&quot;
+#include &lt;strings.h&gt;
+
+#define LINE_RATE 6000 /* characters per second */
+
+typedef struct {
+    int chars_per_frame;
+    uint64_t fsize;  /** file size less metadata buffer */
+} TtyDemuxContext;
+
+/**
+ * Parse EFI header
+ */
+static int efi_read(AVFormatContext *avctx, uint64_t start_pos)
+{
+    TtyDemuxContext *s = avctx-&gt;priv_data;
+    ByteIOContext *pb = avctx-&gt;pb;
+    char buf[37];
+    int len;
+
+    url_fseek(pb, start_pos, SEEK_SET);
+    if (get_byte(pb) != 0x1A)
+        return -1;
+
+#define GET_EFI_META(name,size) \
+    len = get_byte(pb); \
+    if (len &lt; 1 || len &gt; size) \
+        return -1; \
+    if (get_buffer(pb, buf, size) == size) { \
+        buf[len] = 0; \
+        av_metadata_set2(&amp;avctx-&gt;metadata, name, buf, 0); \
+    }
+
+    GET_EFI_META(&quot;filename&quot;, 12)
+    GET_EFI_META(&quot;title&quot;,    36)
+
+    s-&gt;fsize = start_pos;
+    return 0;
+}
+
+static int read_header(AVFormatContext *avctx,
+                       AVFormatParameters *ap)
+{
+    TtyDemuxContext *s = avctx-&gt;priv_data;
+    AVStream *st = av_new_stream(avctx, 0);
+    if (!st)
+        return AVERROR(ENOMEM);
+    st-&gt;codec-&gt;codec_tag   = 0;
+    st-&gt;codec-&gt;codec_type  = CODEC_TYPE_VIDEO;
+    st-&gt;codec-&gt;codec_id    = CODEC_ID_ANSI;
+    if (ap-&gt;width)  st-&gt;codec-&gt;width  = ap-&gt;width;
+    if (ap-&gt;height) st-&gt;codec-&gt;height = ap-&gt;height;
+
+    if (!ap-&gt;time_base.num) {
+        av_set_pts_info(st, 60, 1, 25);
+    } else {
+        av_set_pts_info(st, 60, ap-&gt;time_base.num, ap-&gt;time_base.den);
+    }
+
+    /* simulate tty display speed */
+    s-&gt;chars_per_frame = FFMAX(av_q2d(st-&gt;time_base) * (ap-&gt;sample_rate ? ap-&gt;sample_rate : LINE_RATE), 1);
+
+    if (!url_is_streamed(avctx-&gt;pb)) {
+        s-&gt;fsize = url_fsize(avctx-&gt;pb);
+        st-&gt;duration = (s-&gt;fsize + s-&gt;chars_per_frame - 1) / s-&gt;chars_per_frame;
+
+        if (ff_sauce_read(avctx, &amp;s-&gt;fsize, 0, 0) &lt; 0)
+            efi_read(avctx, s-&gt;fsize - 51);
+
+        url_fseek(avctx-&gt;pb, 0, SEEK_SET);
+    }
+
+    return 0;
+}
+
+static int read_packet(AVFormatContext *avctx, AVPacket *pkt)
+{
+    TtyDemuxContext *s = avctx-&gt;priv_data;
+    int n;
+
+    if (url_feof(avctx-&gt;pb))
+        return AVERROR_EOF;
+
+    n = s-&gt;chars_per_frame;
+    if (s-&gt;fsize) {
+        // ignore metadata buffer
+        uint64_t p = url_ftell(avctx-&gt;pb);
+        if (p + s-&gt;chars_per_frame &gt; s-&gt;fsize)
+            n = s-&gt;fsize - p;
+    }
+
+    pkt-&gt;size = av_get_packet(avctx-&gt;pb, pkt, n);
+    if (pkt-&gt;size &lt;= 0)
+        return AVERROR(EIO);
+    pkt-&gt;flags |= PKT_FLAG_KEY;
+    return 0;
+}
+
+AVInputFormat tty_demuxer = {
+    .name           = &quot;tty&quot;,
+    .long_name      = NULL_IF_CONFIG_SMALL(&quot;Tele-typewriter&quot;),
+    .priv_data_size = sizeof(TtyDemuxContext),
+    .read_header    = read_header,
+    .read_packet    = read_packet,
+    .extensions     = &quot;ans,art,asc,diz,ice,nfo,txt,vt&quot;,
+};

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/utils.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/utils.c	2010-07-25 10:07:43 UTC (rev 6480)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/utils.c	2010-07-25 10:07:46 UTC (rev 6481)
@@ -49,13 +49,14 @@
 
 const char *avformat_configuration(void)
 {
-    return FFMPEG_CONFIGURATION;
+    return &quot;avidemux&quot;; // MEANX FFMPEG_CONFIGURATION;
 }
 
 const char *avformat_license(void)
 {
 #define LICENSE_PREFIX &quot;libavformat license: &quot;
-    return LICENSE_PREFIX FFMPEG_LICENSE + sizeof(LICENSE_PREFIX) - 1;
+        return LICENSE_PREFIX &quot;GPL&quot;;
+//MEANX    return LICENSE_PREFIX FFMPEG_LICENSE + sizeof(LICENSE_PREFIX) - 1;
 }
 
 /* fraction handling */

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/file.c.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/file.c.patch	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/file.c.patch	2010-07-25 10:07:46 UTC (rev 6481)
@@ -0,0 +1,77 @@
+diff --git a/avidemux_core/ADM_ffmpeg/libavformat/file.c b/avidemux_core/ADM_ffmpeg/libavformat/file.c
+index 3c3f42f..298c07a 100644
+--- a/avidemux_core/ADM_ffmpeg/libavformat/file.c
++++ b/avidemux_core/ADM_ffmpeg/libavformat/file.c
+@@ -30,6 +30,72 @@
+ #include &lt;stdlib.h&gt;
+ #include &quot;os_support.h&quot;
+ 
++// GRUNTSTER start
++#ifdef __WIN32
++#include &lt;windows.h&gt;
++
++int utf8StringToWideChar(const char *utf8String, int utf8StringLength, wchar_t *wideCharString)
++{
++	int wideCharStringLength = MultiByteToWideChar(CP_UTF8, 0, utf8String, utf8StringLength, NULL, 0);
++
++	if (wideCharString)
++		MultiByteToWideChar(CP_UTF8, 0, utf8String, utf8StringLength, wideCharString, wideCharStringLength);
++
++	return wideCharStringLength;
++}
++
++int ADM_open(const char *path, int oflag, ...)
++{
++	int fileNameLength = utf8StringToWideChar(path, -1, NULL);
++	wchar_t wcFile[fileNameLength];
++	int creation = 0, access = 0;
++	HANDLE hFile;
++
++	utf8StringToWideChar(path, -1, wcFile);
++
++	if (oflag &amp; O_WRONLY || oflag &amp; O_RDWR)
++	{
++		access = GENERIC_WRITE;
++
++		if (oflag &amp; O_RDWR)
++			access |= GENERIC_READ;
++
++		if (oflag &amp; O_CREAT)
++		{
++			if (oflag &amp; O_EXCL)
++				creation = CREATE_NEW;
++			else if (oflag &amp; O_TRUNC)
++				creation = CREATE_ALWAYS;
++			else
++				creation = OPEN_ALWAYS;
++		}
++		else if (oflag &amp; O_TRUNC)
++			creation = TRUNCATE_EXISTING;
++	}
++	else if (oflag &amp; O_RDONLY)
++		creation = OPEN_EXISTING;
++
++	if (creation &amp; GENERIC_WRITE)
++	{
++		hFile = CreateFileW(wcFile, access, 0, NULL, creation, 0, NULL);
++
++		if (hFile == INVALID_HANDLE_VALUE)
++			return -1;
++		else
++			CloseHandle(hFile);
++	}
++
++	hFile = CreateFileW(wcFile, access, FILE_SHARE_READ, NULL, creation, 0, NULL);
++
++	if (hFile == INVALID_HANDLE_VALUE)
++		return -1;
++	else
++		return _open_osfhandle((intptr_t)hFile, oflag);
++}
++
++#define open ADM_open
++#endif
++// GRUNTSTER end
+ 
+ /* standard file protocol */
+ 

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/flvenc.c.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/flvenc.c.patch	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/flvenc.c.patch	2010-07-25 10:07:46 UTC (rev 6481)
@@ -0,0 +1,25 @@
+diff --git a/avidemux_core/ADM_ffmpeg/libavformat/flvenc.c b/avidemux_core/ADM_ffmpeg/libavformat/flvenc.c
+index 709ef07..a573c63 100644
+--- a/avidemux_core/ADM_ffmpeg/libavformat/flvenc.c
++++ b/avidemux_core/ADM_ffmpeg/libavformat/flvenc.c
+@@ -406,7 +406,8 @@ AVOutputFormat flv_muxer = {
+     &quot;video/x-flv&quot;,
+     &quot;flv&quot;,
+     sizeof(FLVContext),
+-#if CONFIG_LIBMP3LAME
++//MEANX #if CONFIG_LIBMP3LAME
++#ifdef HAVE_LIBMP3LAME
+     CODEC_ID_MP3,
+ #else // CONFIG_LIBMP3LAME
+     CODEC_ID_ADPCM_SWF,
+@@ -418,3 +419,9 @@ AVOutputFormat flv_muxer = {
+     .codec_tag= (const AVCodecTag* const []){flv_video_codec_ids, flv_audio_codec_ids, 0},
+     .flags= AVFMT_GLOBALHEADER | AVFMT_VARIABLE_FPS,
+ };
++// MEANX
++int flvenc_init(void)
++{
++    av_register_output_format(&amp;flv_muxer);
++    return 0;
++}
+\ No newline at end of file

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/isom.c.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/isom.c.patch	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/isom.c.patch	2010-07-25 10:07:46 UTC (rev 6481)
@@ -0,0 +1,16 @@
+diff --git a/avidemux_core/ADM_ffmpeg/libavformat/isom.c b/avidemux_core/ADM_ffmpeg/libavformat/isom.c
+index bf2d3b1..99c8069 100644
+--- a/avidemux_core/ADM_ffmpeg/libavformat/isom.c
++++ b/avidemux_core/ADM_ffmpeg/libavformat/isom.c
+@@ -215,7 +215,10 @@ const AVCodecTag codec_movaudio_tags[] = {
+     { CODEC_ID_MP1, MKTAG('.', 'm', 'p', '1') }, /* MPEG layer 1 */
+     { CODEC_ID_MP2, MKTAG('.', 'm', 'p', '2') }, /* MPEG layer 2 */
+ 
+-    { CODEC_ID_MP3, MKTAG('.', 'm', 'p', '3') }, /* MPEG layer 3 */ /* sample files at <A HREF="http://www.3ivx.com/showcase.html">http://www.3ivx.com/showcase.html</A> use this tag */
++    //MEANX { CODEC_ID_MP3, MKTAG('.', 'm', 'p', '3') }, /* MPEG layer 3 */ /* sample files at <A HREF="http://www.3ivx.com/showcase.html">http://www.3ivx.com/showcase.html</A> use this tag */
++     { CODEC_ID_MP3, MKTAG( 'm', 'p', '4','a') },
++     { CODEC_ID_MP2, MKTAG( 'm', 'p', '4', 'a') },
++    // /MEANX
+     { CODEC_ID_MP3, 0x6D730055 }, /* MPEG layer 3 */
+ 
+ /*  { CODEC_ID_OGG_VORBIS, MKTAG('O', 'g', 'g', 'S') }, *//* sample files at <A HREF="http://heroinewarrior.com/xmovie.php3">http://heroinewarrior.com/xmovie.php3</A> use this tag */

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/matroskaenc.c.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/matroskaenc.c.patch	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/matroskaenc.c.patch	2010-07-25 10:07:46 UTC (rev 6481)
@@ -0,0 +1,83 @@
+diff --git a/avidemux_core/ADM_ffmpeg/libavformat/matroskaenc.c b/avidemux_core/ADM_ffmpeg/libavformat/matroskaenc.c
+index f275d44..a7602a9 100644
+--- a/avidemux_core/ADM_ffmpeg/libavformat/matroskaenc.c
++++ b/avidemux_core/ADM_ffmpeg/libavformat/matroskaenc.c
+@@ -407,6 +407,7 @@ static int64_t mkv_write_cues(ByteIOContext *pb, mkv_cues *cues, int num_tracks)
+ 
+ static int put_xiph_codecpriv(AVFormatContext *s, ByteIOContext *pb, AVCodecContext *codec)
+ {
++#if 0 // MEANX avidemux does thing differently
+     uint8_t *header_start[3];
+     int header_len[3];
+     int first_header_size;
+@@ -431,6 +432,28 @@ static int put_xiph_codecpriv(AVFormatContext *s, ByteIOContext *pb, AVCodecCont
+         put_buffer(pb, header_start[j], header_len[j]);
+ 
+     return 0;
++#else
++   // Not endian safe....
++      uint32_t packetLen[3],*ptr=(uint32_t *)codec-&gt;extradata;
++      uint8_t *data[3],i,j;
++      if( 3*4+ptr[0]+ptr[1]+ptr[2]!=codec-&gt;extradata_size)
++      {
++        av_log(s, AV_LOG_ERROR, &quot;Broken avidemux xiph header.\n&quot;);
++        return -1;
++      }
++      data[0]=codec-&gt;extradata+3*4;
++      data[1]=data[0]+ptr[0];
++      data[2]=data[1]+ptr[1];
++      put_byte(pb, 2);                    // number packets - 1
++      for (j = 0; j &lt; 2; j++) 
++      {
++          put_xiph_size(pb, ptr[j]);
++      }
++      for (j = 0; j &lt; 3; j++)
++        put_buffer(pb, data[j], ptr[j]);
++      
++      return 0; // /MEANX
++#endif
+ }
+ 
+ static void get_aac_sample_rates(AVFormatContext *s, AVCodecContext *codec, int *sample_rate, int *output_sample_rate)
+@@ -548,6 +571,23 @@ static int mkv_write_tracks(AVFormatContext *s)
+         put_ebml_uint (pb, MATROSKA_ID_TRACKNUMBER     , i + 1);
+         put_ebml_uint (pb, MATROSKA_ID_TRACKUID        , i + 1);
+         put_ebml_uint (pb, MATROSKA_ID_TRACKFLAGLACING , 0);    // no lacing (yet)
++/**  MEANX : Add a default duration for video **/
++        if(codec-&gt;codec_type==CODEC_TYPE_VIDEO)
++        {
++          if(codec-&gt;time_base.den &amp;&amp; codec-&gt;time_base.num)
++          {
++            int num=codec-&gt;time_base.num;
++            int den=codec-&gt;time_base.den;
++            unsigned int default_duration;
++            float period=num;
++                  period/=den;
++                  period*=1000*1000*1000; // in ns
++                  default_duration=(unsigned int)floor(period);
++                  put_ebml_uint (pb, MATROSKA_ID_TRACKDEFAULTDURATION ,default_duration);
++          }
++        }
++        
++/**  MEANX : Add a default duration for video **/
+ 
+         if ((tag = av_metadata_get(st-&gt;metadata, &quot;title&quot;, NULL, 0)))
+             put_ebml_string(pb, MATROSKA_ID_TRACKNAME, tag-&gt;value);
+@@ -1087,3 +1127,17 @@ AVOutputFormat matroska_audio_muxer = {
+     .codec_tag = (const AVCodecTag* const []){ff_codec_wav_tags, 0},
+ };
+ #endif
++
++ // MEANX
++ //
++ int matroskaenc_init(void)
++ {
++     av_register_output_format(&amp;matroska_muxer);
++#if CONFIG_WEBM_MUXER
++     av_register_output_format(&amp;webm_muxer);
++#endif
++     return 0;
++ }
++ // /MEANX
++
++

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/movenc.c.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/movenc.c.patch	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/movenc.c.patch	2010-07-25 10:07:46 UTC (rev 6481)
@@ -0,0 +1,20 @@
+diff --git a/avidemux_core/ADM_ffmpeg/libavformat/movenc.c b/avidemux_core/ADM_ffmpeg/libavformat/movenc.c
+index aed748b..ded5383 100644
+--- a/avidemux_core/ADM_ffmpeg/libavformat/movenc.c
++++ b/avidemux_core/ADM_ffmpeg/libavformat/movenc.c
+@@ -2298,3 +2298,15 @@ AVOutputFormat ipod_muxer = {
+     .codec_tag = (const AVCodecTag* const []){codec_ipod_tags, 0},
+ };
+ #endif
++/* MEANX */
++int movenc_init(void)
++{
++    av_register_output_format(&amp;mov_muxer);
++    av_register_output_format(&amp;tgp_muxer);
++    av_register_output_format(&amp;mp4_muxer);
++    av_register_output_format(&amp;psp_muxer);
++    av_register_output_format(&amp;tg2_muxer);
++    av_register_output_format(&amp;ipod_muxer);
++    return 0;
++}
++/* MEANX */

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/mpegenc.c.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/mpegenc.c.patch	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/mpegenc.c.patch	2010-07-25 10:07:46 UTC (rev 6481)
@@ -0,0 +1,19 @@
+diff --git a/avidemux_core/ADM_ffmpeg/libavformat/mpegenc.c b/avidemux_core/ADM_ffmpeg/libavformat/mpegenc.c
+index b37a774..32ce21b 100644
+--- a/avidemux_core/ADM_ffmpeg/libavformat/mpegenc.c
++++ b/avidemux_core/ADM_ffmpeg/libavformat/mpegenc.c
+@@ -1300,3 +1300,13 @@ AVOutputFormat mpeg2dvd_muxer = {
+     mpeg_mux_end,
+ };
+ #endif
++// MEANX
++//
++int mpegenc_init(void)
++{
++    av_register_output_format(&amp;mpeg2dvd_muxer);
++    av_register_output_format(&amp;mpeg2svcd_muxer);
++    av_register_output_format(&amp;mpeg2vob_muxer);
++    av_register_output_format(&amp;mpeg1vcd_muxer);
++    return 0;
++}
+\ No newline at end of file

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/mpegtsenc.c.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/mpegtsenc.c.patch	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/mpegtsenc.c.patch	2010-07-25 10:07:46 UTC (rev 6481)
@@ -0,0 +1,14 @@
+diff --git a/avidemux_core/ADM_ffmpeg/libavformat/mpegtsenc.c b/avidemux_core/ADM_ffmpeg/libavformat/mpegtsenc.c
+index ac09ab9..fe32325 100644
+--- a/avidemux_core/ADM_ffmpeg/libavformat/mpegtsenc.c
++++ b/avidemux_core/ADM_ffmpeg/libavformat/mpegtsenc.c
+@@ -947,3 +947,8 @@ AVOutputFormat mpegts_muxer = {
+     mpegts_write_packet,
+     mpegts_write_end,
+ };
++int mpegtsenc_init(void)
++{
++    av_register_output_format(&amp;mpegts_muxer);
++    return 0;
++}
+\ No newline at end of file

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/utils.c.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/utils.c.patch	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/avformat/utils.c.patch	2010-07-25 10:07:46 UTC (rev 6481)
@@ -0,0 +1,21 @@
+diff --git a/avidemux_core/ADM_ffmpeg/libavformat/utils.c b/avidemux_core/ADM_ffmpeg/libavformat/utils.c
+index 6fa4dff..8646c6c 100644
+--- a/avidemux_core/ADM_ffmpeg/libavformat/utils.c
++++ b/avidemux_core/ADM_ffmpeg/libavformat/utils.c
+@@ -49,13 +49,14 @@ unsigned avformat_version(void)
+ 
+ const char *avformat_configuration(void)
+ {
+-    return FFMPEG_CONFIGURATION;
++    return &quot;avidemux&quot;; // MEANX FFMPEG_CONFIGURATION;
+ }
+ 
+ const char *avformat_license(void)
+ {
+ #define LICENSE_PREFIX &quot;libavformat license: &quot;
+-    return LICENSE_PREFIX FFMPEG_LICENSE + sizeof(LICENSE_PREFIX) - 1;
++        return LICENSE_PREFIX &quot;GPL&quot;;
++//MEANX    return LICENSE_PREFIX FFMPEG_LICENSE + sizeof(LICENSE_PREFIX) - 1;
+ }
+ 
+ /* fraction handling */


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003667.html">[Avidemux-svn-commit] r6480 - in	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg:	libavutil patches patches/avutils
</A></li>
	<LI>Next message: <A HREF="003669.html">[Avidemux-svn-commit] r6482 - in	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libswscale:	. x86
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3668">[ date ]</a>
              <a href="thread.html#3668">[ thread ]</a>
              <a href="subject.html#3668">[ subject ]</a>
              <a href="author.html#3668">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
