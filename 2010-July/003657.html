<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r6469 - in branches/avidemux_2.6_branch_mean:	avidemux_core/ADM_coreVdpau/include avidemux_core/ADM_coreVdpau/src	avidemux_core/ADM_coreVideoFilter/include	avidemux_plugins/ADM_videoFilters6/vdpauFilters
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2010-July/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r6469%20-%20in%20branches/avidemux_2.6_branch_mean%3A%0A%09avidemux_core/ADM_coreVdpau/include%20avidemux_core/ADM_coreVdpau/src%0A%09avidemux_core/ADM_coreVideoFilter/include%0A%09avidemux_plugins/ADM_videoFilters6/vdpauFilters&In-Reply-To=%3C20100720185649.E875348018E%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003656.html">
   <LINK REL="Next"  HREF="003658.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r6469 - in branches/avidemux_2.6_branch_mean:	avidemux_core/ADM_coreVdpau/include avidemux_core/ADM_coreVdpau/src	avidemux_core/ADM_coreVideoFilter/include	avidemux_plugins/ADM_videoFilters6/vdpauFilters</H1>
    <B>mean at mail.berlios.de</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r6469%20-%20in%20branches/avidemux_2.6_branch_mean%3A%0A%09avidemux_core/ADM_coreVdpau/include%20avidemux_core/ADM_coreVdpau/src%0A%09avidemux_core/ADM_coreVideoFilter/include%0A%09avidemux_plugins/ADM_videoFilters6/vdpauFilters&In-Reply-To=%3C20100720185649.E875348018E%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r6469 - in branches/avidemux_2.6_branch_mean:	avidemux_core/ADM_coreVdpau/include avidemux_core/ADM_coreVdpau/src	avidemux_core/ADM_coreVideoFilter/include	avidemux_plugins/ADM_videoFilters6/vdpauFilters">mean at mail.berlios.de
       </A><BR>
    <I>Tue Jul 20 20:56:49 CEST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="003656.html">[Avidemux-svn-commit] r6468 -	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf
</A></li>
        <LI>Next message: <A HREF="003658.html">[Avidemux-svn-commit] r6470 - in branches/avidemux_2.6_branch_mean:	avidemux_core/ADM_coreVdpau/src avidemux_plugins/ADM_muxers/muxerAvi	avidemux_plugins/ADM_muxers/muxerRaw	avidemux_plugins/ADM_videoFilters6/printInfo	avidemux_plugins/ADM_videoFilters6/vdpauFilters
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3657">[ date ]</a>
              <a href="thread.html#3657">[ thread ]</a>
              <a href="subject.html#3657">[ subject ]</a>
              <a href="author.html#3657">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2010-07-20 20:56:49 +0200 (Tue, 20 Jul 2010)
New Revision: 6469

Added:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilterDeint.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/include/ADM_coreVdpau.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/include/ADM_coreVdpauInternal.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/ADM_coreVdpau.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/ADM_coreVdpauMixer.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_coreVideoFilter.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilter.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/vdpauFilter.conf
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/vdpauFilter.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/vdpauFilter_desc.cpp
Log:
[vdpau] Sort of working VDPAU deinterlacer (incomplete)

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/include/ADM_coreVdpau.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/include/ADM_coreVdpau.h	2010-07-20 18:56:48 UTC (rev 6468)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/include/ADM_coreVdpau.h	2010-07-20 18:56:49 UTC (rev 6469)
@@ -39,7 +39,8 @@
     static bool         isOperationnal(void);
     /* Surface */
 #ifdef USE_VDPAU
-    static const char  *getErrorString(VdpStatus er);
+    static  const char  *getErrorString(VdpStatus er);
+    static  bool        mixerIsFeatureEnabled( VdpVideoMixer mixer,VdpVideoMixerFeature feature);
     static  VdpStatus   surfaceCreate(uint32_t width,uint32_t height,VdpVideoSurface *surface);
     static  VdpStatus   surfaceDestroy(VdpVideoSurface surface);
     static  VdpStatus   getDataSurface(VdpVideoSurface surface,uint8_t *planes[3],uint32_t stride[3]);
@@ -70,6 +71,10 @@
     // Warning only RGBA32 supported!
     static VdpStatus outputSurfaceGetBitsNative(VdpOutputSurface     surface,  
                         uint8_t *buffer, uint32_t w,uint32_t h);
+    static VdpStatus outputSurfaceGetBitsNative_FieldWeave(VdpOutputSurface     surface,  
+                        uint8_t *buffer, uint32_t w,uint32_t h);
+
+
     /* Presentation queue */
     static VdpStatus presentationQueueCreate(VdpPresentationQueue *queue);
     static VdpStatus presentationQueueDestroy(VdpPresentationQueue queue);
@@ -78,9 +83,10 @@
     static VdpStatus mixerCreate(uint32_t width,uint32_t height, VdpVideoMixer *mixer,bool deinterlace=false);
     static VdpStatus mixerDestroy(VdpVideoMixer mixer);
     static VdpStatus mixerRender(VdpVideoMixer mixer,VdpVideoSurface sourceSurface,VdpOutputSurface targetOutputSurface, uint32_t targetWidth, uint32_t targetHeight );
-    static VdpStatus mixerRenderWithPastAndFuture(VdpVideoMixer mixer,
+    static VdpStatus mixerRenderWithPastAndFuture(bool topField,VdpVideoMixer mixer,
                                 VdpVideoSurface sourceSurface[3], // Past present future
-                                VdpOutputSurface targetOutputSurface,uint32_t targetWidth, uint32_t targetHeight );
+                                VdpOutputSurface targetOutputSurface,
+                                uint32_t targetWidth, uint32_t targetHeight );
 
 #endif
 };

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/include/ADM_coreVdpauInternal.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/include/ADM_coreVdpauInternal.h	2010-07-20 18:56:48 UTC (rev 6468)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/include/ADM_coreVdpauInternal.h	2010-07-20 18:56:49 UTC (rev 6469)
@@ -50,6 +50,7 @@
     VdpVideoMixerDestroy              *mixerDestroy;
     VdpVideoMixerRender               *mixerRender;
     VdpVideoMixerSetFeatureEnables    *mixerEnableFeatures;
+    VdpVideoMixerGetFeatureEnables    *mixerGetFeaturesEnabled;
     VdpVideoMixerQueryFeatureSupport  *mixerQueryFeatureSupported;
 
     VdpPresentationQueueTargetCreateX11 *presentationQueueDisplayX11Create;

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/ADM_coreVdpau.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/ADM_coreVdpau.cpp	2010-07-20 18:56:48 UTC (rev 6468)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/ADM_coreVdpau.cpp	2010-07-20 18:56:49 UTC (rev 6469)
@@ -98,7 +98,7 @@
     GetMe(mixerRender,VDP_FUNC_ID_VIDEO_MIXER_RENDER);
     GetMe(mixerEnableFeatures,VDP_FUNC_ID_VIDEO_MIXER_SET_FEATURE_ENABLES);
     GetMe(mixerQueryFeatureSupported,VDP_FUNC_ID_VIDEO_MIXER_QUERY_FEATURE_SUPPORT);
-
+    GetMe(mixerGetFeaturesEnabled,VDP_FUNC_ID_VIDEO_MIXER_GET_FEATURE_ENABLES)
     if(VDP_STATUS_OK!=ADM_coreVdpau::funcs.presentationQueueDisplayX11Create(ADM_coreVdpau::vdpDevice,x-&gt;window,&amp;queueX11))
     {
         ADM_warning(&quot;Cannot create X11 Presentation Queue\n&quot;);
@@ -287,8 +287,20 @@
      ( void * const *)ptr,
     pitches));
 }
-
 /**
+    \fn outputSurfaceGetBitsNative_FieldWeave
+*/
+VdpStatus admVdpau::outputSurfaceGetBitsNative_FieldWeave(VdpOutputSurface     surface, uint8_t *buffer, uint32_t w,uint32_t h)
+{
+    // Only support RGBA 32
+    uint32_t pitches[3]={w*8,0,0};
+    uint8_t *ptr[4]={buffer,NULL,NULL,NULL};
+    CHECK(ADM_coreVdpau::funcs.getBitsNativeOutputSurface( surface,
+    NULL, // Rect
+     ( void * const *)ptr,
+    pitches));
+}
+/**
     \fn
     \brief
 */

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/ADM_coreVdpauMixer.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/ADM_coreVdpauMixer.cpp	2010-07-20 18:56:48 UTC (rev 6468)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVdpau/src/ADM_coreVdpauMixer.cpp	2010-07-20 18:56:49 UTC (rev 6469)
@@ -19,16 +19,32 @@
 #include &quot;../include/ADM_coreVdpauInternal.h&quot;
 #include &quot;ADM_dynamicLoading.h&quot;
 
-
+#if 1
+    #define aprintf ADM_info
+#else
+    #define aprintf(...) {}
+#endif
 //GUI_WindowInfo      admVdpau::myWindowInfo;
 
 /**
+    \fn    mixerIsFeatureEnabled
+    \brief 
+*/
+bool admVdpau::mixerIsFeatureEnabled( VdpVideoMixer mixer,VdpVideoMixerFeature feature)
+{
+    VdpBool enabledFeature=true;
+    CHECKBOOL(ADM_coreVdpau::funcs.mixerGetFeaturesEnabled(mixer,1,&amp;feature,&amp;enabledFeature));
+    if(enabledFeature) return true;
+    return false;
+}
+/**
     \fn    mixerEnableFeature
     \brief enable mixer feature
 */
 
 VdpStatus admVdpau::mixerEnableFeature( VdpVideoMixer mixer,uint32_t nbFeature,VdpVideoMixerFeature *feature,VdpBool *enabledFeature)
 {
+    aprintf(&quot;Enabling %d features\n&quot;,nbFeature);
     CHECK(ADM_coreVdpau::funcs.mixerEnableFeatures(mixer,nbFeature,feature,enabledFeature));
 }
 /**
@@ -130,18 +146,61 @@
     \fn mixerRenderWithPastAndFuture
 */
 
-VdpStatus admVdpau::mixerRenderWithPastAndFuture(VdpVideoMixer mixer,
+VdpStatus admVdpau::mixerRenderWithPastAndFuture(
+                                bool topField,
+                                VdpVideoMixer mixer,
                                 VdpVideoSurface sourceSurface[3], // Past present future
                                 VdpOutputSurface targetOutputSurface, 
                                 uint32_t targetWidth, 
                                 uint32_t targetHeight )
 {
+    int nbPrev=2,nbNext=2;
+    VdpVideoMixerPictureStructure fieldType=VDP_VIDEO_MIXER_PICTURE_STRUCTURE_TOP_FIELD;
+    if(!topField) fieldType=VDP_VIDEO_MIXER_PICTURE_STRUCTURE_BOTTOM_FIELD;
+
+
+    VdpVideoSurface past[2]={VDP_INVALID_HANDLE,VDP_INVALID_HANDLE};
+    VdpVideoSurface future[2]={VDP_INVALID_HANDLE,VDP_INVALID_HANDLE};
+    VdpVideoSurface present;
+
+    present=sourceSurface[1];
+    
+
+    if(VDP_INVALID_HANDLE==sourceSurface[0] ) nbPrev=0;
+    else
+    {
+            if(topField) 
+            {
+                past[0]=sourceSurface[0];
+                past[1]=sourceSurface[0];
+            }else
+            {
+                past[0]=sourceSurface[1];
+                past[1]=sourceSurface[0];
+            }
+    }
+    if(VDP_INVALID_HANDLE==sourceSurface[2] ) nbNext=0;
+    else
+    {
+            if(topField) 
+            {
+                future[0]=sourceSurface[1];
+                future[1]=sourceSurface[2];
+            }else
+            {
+                future[0]=sourceSurface[2];
+                future[1]=sourceSurface[2];
+            }
+    }
+    // 0 &amp; 1 p
+    //ADM_info(&quot;Deint : %d\n&quot;,(int)mixerIsFeatureEnabled(mixer,VDP_VIDEO_MIXER_FEATURE_DEINTERLACE_TEMPORAL_SPATIAL));
+
       VdpStatus e=ADM_coreVdpau::funcs.mixerRender(mixer,
                 VDP_INVALID_HANDLE,NULL,    // Background
-                VDP_VIDEO_MIXER_PICTURE_STRUCTURE_FRAME,
-                1,            sourceSurface+0, // Past...
-                              sourceSurface[1], // current
-                1,            sourceSurface+2, // Future
+                fieldType,
+                nbPrev,       past, // Past...
+                              present, // current
+                nbNext,       future, // Future
                 NULL,                               // source RECT
                 targetOutputSurface,
                 NULL,                               // dest Rec
@@ -152,7 +211,7 @@
   if(VDP_STATUS_OK!=e)
     {
         
-        ADM_warning(&quot;MixerCreate  failed :%s\n&quot;,getErrorString(e));
+        ADM_warning(&quot;mixerRenderWithPastAndFuture  failed :%s\n&quot;,getErrorString(e));
         
     }
     return e;

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_coreVideoFilter.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_coreVideoFilter.h	2010-07-20 18:56:48 UTC (rev 6468)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_coreVideoFilter.h	2010-07-20 18:56:49 UTC (rev 6469)
@@ -47,7 +47,7 @@
        virtual             ~ADM_coreVideoFilter();
 
        virtual const char   *getConfiguration(void);                   /// Return  current configuration as a human readable string
-       virtual bool         goToTime(uint64_t usSeek);              
+       virtual bool         goToTime(uint64_t usSeek);                 /// Overide this if you have cleanup to do after a jump      
        virtual bool         getNextFrame(uint32_t *frameNumber,ADMImage *image)=0;              /// Dont mix getFrame &amp; getNextFrame !
        virtual FilterInfo  *getInfo(void);                             /// Return picture parameters after this filter
        virtual bool         getCoupledConf(CONFcouple **couples)=0 ;   /// Return the current filter configuration

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilter.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilter.cpp	2010-07-20 18:56:48 UTC (rev 6468)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilter.cpp	2010-07-20 18:56:49 UTC (rev 6469)
@@ -15,6 +15,9 @@
 #ifdef USE_VDPAU
 #include &quot;ADM_coreVdpau/include/ADM_coreVdpau.h&quot;
 //
+#define ADM_INVALID_FRAME_NUM 0x80000000
+#define ADM_NB_SURFACES 3
+
 /**
     \class vdpauVideoFilter
 */
@@ -22,21 +25,23 @@
 {
 protected:
                     ADMColorScalerSimple *scaler;
-                    bool passThrough;
-                    bool setupVdpau(void);
-                    bool cleanupVdpau(void);
+                    bool                 passThrough;
+                    bool                 setupVdpau(void);
+                    bool                 cleanupVdpau(void);
 
-                    uint8_t   *tempBuffer;
-                    ADMImage *original;
-                    vdpauFilter configuration;
+                    uint8_t             *tempBuffer;
+                    vdpauFilter          configuration;
                     VdpOutputSurface     surface;
-                    VdpVideoSurface      input;
+                    VdpVideoSurface      input[ADM_NB_SURFACES];
+                    uint32_t             frameDesc[ADM_NB_SURFACES];
+                    uint32_t             currentIndex;
                     VdpVideoMixer        mixer;
+                    bool                 uploadImage(ADMImage *next,uint32_t surfaceIndex,uint32_t frameNumber) ;
 
-
 public:
-                    vdpauVideoFilter(ADM_coreVideoFilter *previous,CONFcouple *conf);
-                    ~vdpauVideoFilter();
+        virtual bool         goToTime(uint64_t usSeek); 
+                             vdpauVideoFilter(ADM_coreVideoFilter *previous,CONFcouple *conf);
+                             ~vdpauVideoFilter();
 
         virtual const char   *getConfiguration(void);                 /// Return  current configuration as a human readable string
         virtual bool         getNextFrame(uint32_t *fn,ADMImage *image);           /// Return the next image
@@ -48,7 +53,7 @@
 DECLARE_VIDEO_FILTER(   vdpauVideoFilter,   // Class
                         1,0,0,              // Version
                         ADM_UI_GTK+ADM_UI_QT4,     // We need a display for VDPAU; so no cli...
-                        VF_INTERLACING,            // Category
+                        VF_TRANSFORM,            // Category
                         &quot;vdpau&quot;,            // internal name (must be uniq!)
                         &quot;vdpau&quot;,            // Display name
                         &quot;vdpau, vdpau filters.&quot; // Description
@@ -56,18 +61,32 @@
 
 //
 /**
+    \fn goToTime
+    \brief called when seeking. Need to cleanup our stuff.
+*/
+bool         vdpauVideoFilter::goToTime(uint64_t usSeek)
+{
+    return ADM_coreVideoFilter::goToTime(usSeek);
+}
+
+/**
     \fn resetVdpau
 */
 bool vdpauVideoFilter::setupVdpau(void)
 {
     scaler=NULL;
+
+    info.width=configuration.targetWidth;
+    info.height=configuration.targetHeight;
+    for(int i=0;i&lt;ADM_NB_SURFACES;i++)             frameDesc[i]=ADM_INVALID_FRAME_NUM;
+    currentIndex=0;
     if(!admVdpau::isOperationnal())
     {
         ADM_warning(&quot;Vdpau not operationnal\n&quot;);
         return false;
     }
     // check if we have something to do
-    if(!configuration.deinterlace &amp;&amp; !configuration.resizeToggle)
+    if(info.width==previousFilter-&gt;getInfo()-&gt;width &amp;&amp;  info.height==previousFilter-&gt;getInfo()-&gt;height)
         return false;
     if(VDP_STATUS_OK!=admVdpau::outputSurfaceCreate(VDP_RGBA_FORMAT_B8G8R8A8,
                         info.width,info.height,&amp;surface)) 
@@ -75,20 +94,24 @@
         ADM_error(&quot;Cannot create outputSurface0\n&quot;);
         return false;
     }
-   if(VDP_STATUS_OK!=admVdpau::surfaceCreate(   previousFilter-&gt;getInfo()-&gt;width,
-                                                previousFilter-&gt;getInfo()-&gt;height,&amp;input)) 
+    for(int i=0;i&lt;ADM_NB_SURFACES;i++)
     {
-        ADM_error(&quot;Cannot create input Surface\n&quot;);
-        goto badInit;
+        if(VDP_STATUS_OK!=admVdpau::surfaceCreate(   previousFilter-&gt;getInfo()-&gt;width,
+                                                    previousFilter-&gt;getInfo()-&gt;height,input+i)) 
+        {
+            ADM_error(&quot;Cannot create input Surface %d\n&quot;,i);
+            goto badInit;
+        }
     }
     if(VDP_STATUS_OK!=admVdpau::mixerCreate(previousFilter-&gt;getInfo()-&gt;width,
-                                            previousFilter-&gt;getInfo()-&gt;height,&amp;mixer,configuration.deinterlace)) 
+                                            previousFilter-&gt;getInfo()-&gt;height,&amp;mixer)) 
     {
         ADM_error(&quot;Cannot create mixer\n&quot;);
         goto badInit;
     } 
     tempBuffer=new uint8_t[info.width*info.height*4];
     scaler=new ADMColorScalerSimple( info.width,info.height, ADM_COLOR_BGR32A,ADM_COLOR_YV12);
+    ADM_info(&quot;VDPAU setup ok\n&quot;);
     return true;
 badInit:
     cleanupVdpau();
@@ -100,11 +123,13 @@
 */
 bool vdpauVideoFilter::cleanupVdpau(void)
 {
-    if(input!=VDP_INVALID_HANDLE) admVdpau::surfaceDestroy(input);
+    for(int i=0;i&lt;ADM_NB_SURFACES;i++)
+        if(input[i]!=VDP_INVALID_HANDLE) admVdpau::surfaceDestroy(input[i]);
     if(surface!=VDP_INVALID_HANDLE)  admVdpau::outputSurfaceDestroy(surface);
     if(mixer!=VDP_INVALID_HANDLE) admVdpau::mixerDestroy(mixer);
     surface=VDP_INVALID_HANDLE;
-    input=VDP_INVALID_HANDLE;
+    for(int i=0;i&lt;ADM_NB_SURFACES;i++)
+        input[i]=VDP_INVALID_HANDLE;
     mixer=VDP_INVALID_HANDLE;
     if(tempBuffer) delete [] tempBuffer;
     tempBuffer=NULL;
@@ -117,19 +142,17 @@
 */
 vdpauVideoFilter::vdpauVideoFilter(ADM_coreVideoFilter *in, CONFcouple *setup): ADM_coreVideoFilter(in,setup)
 {
-    input=VDP_INVALID_HANDLE;
+    for(int i=0;i&lt;ADM_NB_SURFACES;i++)
+        input[i]=VDP_INVALID_HANDLE;
     mixer=VDP_INVALID_HANDLE;
     surface=VDP_INVALID_HANDLE;
     if(!setup || !ADM_paramLoad(setup,vdpauFilter_param,&amp;configuration))
     {
         // Default value
-        configuration.resizeToggle=false;
-        configuration.deinterlace=false;
         configuration.targetWidth=info.width;
         configuration.targetHeight=info.height;
     }
     vidCache = new VideoCache (5, in);
-    original=new ADMImageDefault(previousFilter-&gt;getInfo()-&gt;width,previousFilter-&gt;getInfo()-&gt;height);
     myName=&quot;vdpau&quot;;
     tempBuffer=NULL;
     passThrough=!setupVdpau();
@@ -141,7 +164,7 @@
 */
 vdpauVideoFilter::~vdpauVideoFilter()
 {
-        delete original;
+//        delete original;
         delete vidCache;
         vidCache = NULL;
         cleanupVdpau();
@@ -152,29 +175,20 @@
 bool vdpauVideoFilter::configure( void) 
 {
     
-     uint32_t resize=configuration.resizeToggle;
-     uint32_t deinterlace=configuration.deinterlace;
-  
-     diaElemToggle resizeT(&amp;(resize),   QT_TR_NOOP(&quot;Resize:&quot;));
-     diaElemToggle deinterlaceT(&amp;(deinterlace),   QT_TR_NOOP(&quot;Deinterlace:&quot;));
      
      diaElemUInteger  tWidth(&amp;(configuration.targetWidth),QT_TR_NOOP(&quot;Width :&quot;),16,2048);
      diaElemUInteger  tHeight(&amp;(configuration.targetHeight),QT_TR_NOOP(&quot;Height :&quot;),16,2048);
      
-     diaElem *elems[]={&amp;resizeT,&amp;deinterlaceT,&amp;tWidth,&amp;tHeight};
+     diaElem *elems[]={&amp;tWidth,&amp;tHeight};
      
      if(diaFactoryRun(QT_TR_NOOP(&quot;vdpau&quot;),sizeof(elems)/sizeof(diaElem *),elems))
      {
-         configuration.resizeToggle=resize;
-         configuration.deinterlace=deinterlace;
-         if(resize)
-         {
                 info.width=configuration.targetWidth;
                 info.height=configuration.targetHeight;
-         }
-        cleanupVdpau();
-        passThrough=!setupVdpau();
-        return 1;
+                ADM_info(&quot;New dimension : %d x %d\n&quot;,info.width,info.height);
+                cleanupVdpau();
+                passThrough=!setupVdpau();
+                return 1;
      }
      return 0;
 }
@@ -196,7 +210,7 @@
     char conf2[80];
     conf2[0]=0;
     sprintf(conf,&quot;vdpau:&quot;);
-    if(configuration.resizeToggle)
+    if(1) //configuration.resizeToggle)
     {
         sprintf(conf2,&quot;%d x %d -&gt; %d x %d&quot;,
                         previousFilter-&gt;getInfo()-&gt;width, 
@@ -204,54 +218,74 @@
                         info.width,info.height);
         strcat(conf,conf2);
     }
-    if(configuration.deinterlace)
-    {
-        sprintf(conf2,&quot; deinterlace&quot;);
-        strcat(conf,conf2);
-
-    }
     conf[79]=0;
     return conf;
 }
-
 /**
-    \fn getConfiguration
-    \brief Return current setting as a string
+    \fn uploadImage
+    \brief upload an image to a vdpau surface
 */
-bool vdpauVideoFilter::getNextFrame(uint32_t *fn,ADMImage *image)
+bool vdpauVideoFilter::uploadImage(ADMImage *next,uint32_t surfaceIndex,uint32_t frameNumber) 
 {
-    // 1- Get image...
-      if(passThrough) return previousFilter-&gt;getNextFrame(fn,image);
-    // 
-     if(false==previousFilter-&gt;getNextFrame(fn,original)) return false;
-     // Blit our image to surface
+    if(!next) // empty image
+    {
+        frameDesc[surfaceIndex%ADM_NB_SURFACES]=ADM_INVALID_FRAME_NUM;
+        ADM_warning(&quot;No image to upload\n&quot;);
+        return false;
+    }
+  // Blit our image to surface
     uint32_t pitches[3];
     uint8_t *planes[3];
-    original-&gt;GetPitches(pitches);
-    original-&gt;GetReadPlanes(planes);
+    next-&gt;GetPitches(pitches);
+    next-&gt;GetReadPlanes(planes);
 
     // Put out stuff in input...
+    printf(&quot;Uploading image to surface %d\n&quot;,surfaceIndex%ADM_NB_SURFACES);
 
     if(VDP_STATUS_OK!=admVdpau::surfacePutBits( 
-            input,
+            input[surfaceIndex%ADM_NB_SURFACES],
             planes,pitches))
     {
         ADM_warning(&quot;[Vdpau] video surface : Cannot putbits\n&quot;);
         return false;
     }
-
+    frameDesc[surfaceIndex%ADM_NB_SURFACES]=frameNumber;
+    return true;
+}
+/**
+    \fn getConfiguration
+    \brief Return current setting as a string
+*/
+bool vdpauVideoFilter::getNextFrame(uint32_t *fn,ADMImage *image)
+{
+    
+     if(passThrough) return previousFilter-&gt;getNextFrame(fn,image);
+    // regular image, in fact we get the next image here
+    ADMImage *next= vidCache-&gt;getImage(nextFrame);
+    if(false==uploadImage(next,0,nextFrame)) 
+            {
+                vidCache-&gt;unlockAll();
+                return false;
+            }
+    
+   
     // Call mixer...
-    VdpOutputSurface surfaces[3]={surface,surface,surface};
-    if(VDP_STATUS_OK!=admVdpau::mixerRenderWithPastAndFuture( mixer,input,surfaces, info.width,info.height))
+    if(VDP_STATUS_OK!=admVdpau::mixerRender( 
+                mixer,
+                input[0],
+                surface, 
+                info.width,info.height))
 
     {
         ADM_warning(&quot;[Vdpau] Cannot mixerRender\n&quot;);
+        vidCache-&gt;unlockAll();
         return false;
     }
     // Now get our image back from surface...
     if(VDP_STATUS_OK!=admVdpau::outputSurfaceGetBitsNative(surface,tempBuffer, info.width,info.height))
     {
         ADM_warning(&quot;[Vdpau] Cannot copy back data from output surface\n&quot;);
+        vidCache-&gt;unlockAll();
         return false;
     }
     // Convert from VDP_RGBA_FORMAT_B8G8R8A8 to YV12
@@ -272,7 +306,10 @@
 
     scaler-&gt;convertPlanes(  sourceStride,destStride,     
                             sourceData,destData);
-      return true;
+    nextFrame++;
+    currentIndex++;
+    vidCache-&gt;unlockAll();
+    return true;
 }
 #endif
 //****************

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilterDeint.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilterDeint.cpp	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilterDeint.cpp	2010-07-20 18:56:49 UTC (rev 6469)
@@ -0,0 +1,346 @@
+/**
+    \brief VDPAU filters Deinterlacer
+    \author mean (C) 2010
+    This is slow as we copy back and forth data to/from the video cards
+    
+
+*/
+#include &quot;ADM_default.h&quot;
+#include &quot;ADM_coreVideoFilterInternal.h&quot;
+#include &quot;ADM_videoFilterCache.h&quot;
+#include &quot;DIA_factory.h&quot;
+#include &quot;vdpauFilter.h&quot;
+#include &quot;vdpauFilter_desc.cpp&quot;
+#ifdef USE_VDPAU
+#include &quot;ADM_coreVdpau/include/ADM_coreVdpau.h&quot;
+//
+#define ADM_INVALID_FRAME_NUM 0x80000000
+#define ADM_NB_SURFACES 3
+
+/**
+    \class vdpauVideoFilterDeint
+*/
+class vdpauVideoFilterDeint : public  ADM_coreVideoFilter
+{
+protected:
+                    ADMColorScalerSimple *scaler;
+                    bool                 passThrough;
+                    bool                 setupVdpau(void);
+                    bool                 cleanupVdpau(void);
+
+                    uint8_t             *tempBuffer;
+                    vdpauFilter          configuration;
+                    VdpOutputSurface     surface;
+                    VdpVideoSurface      input[ADM_NB_SURFACES];
+                    uint32_t             frameDesc[ADM_NB_SURFACES];
+                    uint32_t             currentIndex;
+                    VdpVideoMixer        mixer;
+                    bool                 uploadImage(ADMImage *next,uint32_t surfaceIndex,uint32_t frameNumber) ;
+
+public:
+        virtual bool         goToTime(uint64_t usSeek); 
+                             vdpauVideoFilterDeint(ADM_coreVideoFilter *previous,CONFcouple *conf);
+                             ~vdpauVideoFilterDeint();
+
+        virtual const char   *getConfiguration(void);                 /// Return  current configuration as a human readable string
+        virtual bool         getNextFrame(uint32_t *fn,ADMImage *image);           /// Return the next image
+        virtual bool         getCoupledConf(CONFcouple **couples) ;   /// Return the current filter configuration
+        virtual bool         configure(void) ;                        /// Start graphical user interface
+};
+
+// Add the hook to make it valid plugin
+DECLARE_VIDEO_FILTER(   vdpauVideoFilterDeint,   // Class
+                        1,0,0,              // Version
+                        ADM_UI_GTK+ADM_UI_QT4,     // We need a display for VDPAU; so no cli...
+                        VF_INTERLACING,            // Category
+                        &quot;vdpauDeint&quot;,            // internal name (must be uniq!)
+                        &quot;vdpauDeint&quot;,            // Display name
+                        &quot;VDPAU deinterlacer.&quot; // Description
+                    );
+
+//
+/**
+    \fn goToTime
+    \brief called when seeking. Need to cleanup our stuff.
+*/
+bool         vdpauVideoFilterDeint::goToTime(uint64_t usSeek)
+{
+    for(int i=0;i&lt;ADM_NB_SURFACES;i++)             frameDesc[i]=ADM_INVALID_FRAME_NUM;
+    currentIndex=0;
+    return ADM_coreVideoFilter::goToTime(usSeek);
+}
+
+/**
+    \fn resetVdpau
+*/
+bool vdpauVideoFilterDeint::setupVdpau(void)
+{
+    scaler=NULL;
+    for(int i=0;i&lt;ADM_NB_SURFACES;i++)             frameDesc[i]=ADM_INVALID_FRAME_NUM;
+    currentIndex=0;
+    if(!admVdpau::isOperationnal())
+    {
+        ADM_warning(&quot;Vdpau not operationnal\n&quot;);
+        return false;
+    }   
+    if(VDP_STATUS_OK!=admVdpau::outputSurfaceCreate(VDP_RGBA_FORMAT_B8G8R8A8,
+                        info.width,info.height,&amp;surface)) 
+    {
+        ADM_error(&quot;Cannot create outputSurface0\n&quot;);
+        return false;
+    }
+    for(int i=0;i&lt;ADM_NB_SURFACES;i++)
+    {
+        if(VDP_STATUS_OK!=admVdpau::surfaceCreate(   previousFilter-&gt;getInfo()-&gt;width,
+                                                    previousFilter-&gt;getInfo()-&gt;height,input+i)) 
+        {
+            ADM_error(&quot;Cannot create input Surface %d\n&quot;,i);
+            goto badInit;
+        }
+    }
+    if(VDP_STATUS_OK!=admVdpau::mixerCreate(previousFilter-&gt;getInfo()-&gt;width,
+                                            previousFilter-&gt;getInfo()-&gt;height,&amp;mixer,true)) 
+    {
+        ADM_error(&quot;Cannot create mixer\n&quot;);
+        goto badInit;
+    } 
+    tempBuffer=new uint8_t[info.width*info.height*4];
+    scaler=new ADMColorScalerSimple( info.width,info.height, ADM_COLOR_BGR32A,ADM_COLOR_YV12);
+    ADM_info(&quot;VDPAU setup ok\n&quot;);
+    return true;
+badInit:
+    cleanupVdpau();
+    passThrough=true;
+    return false;
+}
+/**
+    \fn cleanupVdpau
+*/
+bool vdpauVideoFilterDeint::cleanupVdpau(void)
+{
+    for(int i=0;i&lt;ADM_NB_SURFACES;i++)
+        if(input[i]!=VDP_INVALID_HANDLE) admVdpau::surfaceDestroy(input[i]);
+    if(surface!=VDP_INVALID_HANDLE)  admVdpau::outputSurfaceDestroy(surface);
+    if(mixer!=VDP_INVALID_HANDLE) admVdpau::mixerDestroy(mixer);
+    surface=VDP_INVALID_HANDLE;
+    for(int i=0;i&lt;ADM_NB_SURFACES;i++)
+        input[i]=VDP_INVALID_HANDLE;
+    mixer=VDP_INVALID_HANDLE;
+    if(tempBuffer) delete [] tempBuffer;
+    tempBuffer=NULL;
+    if(scaler) delete scaler;
+    scaler=NULL;
+    return true;
+}
+
+/**
+    \fn constructor
+*/
+vdpauVideoFilterDeint::vdpauVideoFilterDeint(ADM_coreVideoFilter *in, CONFcouple *setup): ADM_coreVideoFilter(in,setup)
+{
+    for(int i=0;i&lt;ADM_NB_SURFACES;i++)
+        input[i]=VDP_INVALID_HANDLE;
+    mixer=VDP_INVALID_HANDLE;
+    surface=VDP_INVALID_HANDLE;
+    if(!setup || !ADM_paramLoad(setup,vdpauFilter_param,&amp;configuration))
+    {
+        // Default value
+        configuration.targetWidth=info.width;
+        configuration.targetHeight=info.height;
+    }
+    vidCache = new VideoCache (5, in);
+    myName=&quot;vdpauDeint&quot;;
+    tempBuffer=NULL;
+    passThrough=!setupVdpau();
+    
+    
+}
+/**
+    \fn destructor
+*/
+vdpauVideoFilterDeint::~vdpauVideoFilterDeint()
+{
+//        delete original;
+        delete vidCache;
+        vidCache = NULL;
+        cleanupVdpau();
+}
+/**
+    \fn updateInfo
+*/
+bool vdpauVideoFilterDeint::configure( void) 
+{
+    
+     
+        cleanupVdpau();
+        passThrough=!setupVdpau();
+        return 1;
+     
+}
+/**
+    \fn getCoupledConf
+    \brief Return our current configuration as couple name=value
+*/
+bool         vdpauVideoFilterDeint::getCoupledConf(CONFcouple **couples)
+{
+    *couples=NULL;
+    return true;
+}
+/**
+    \fn getConfiguration
+    \brief Return current setting as a string
+*/
+const char *vdpauVideoFilterDeint::getConfiguration(void)
+{
+    static char conf[80];
+    sprintf(conf,&quot;Vdpau Deinterlace.&quot;);
+    conf[79]=0;
+    return conf;
+}
+/**
+    \fn uploadImage
+    \brief upload an image to a vdpau surface
+*/
+bool vdpauVideoFilterDeint::uploadImage(ADMImage *next,uint32_t surfaceIndex,uint32_t frameNumber) 
+{
+    if(!next) // empty image
+    {
+        frameDesc[surfaceIndex%ADM_NB_SURFACES]=ADM_INVALID_FRAME_NUM;
+        ADM_warning(&quot;No image to upload\n&quot;);
+        return false;
+    }
+  // Blit our image to surface
+    uint32_t pitches[3];
+    uint8_t *planes[3];
+    next-&gt;GetPitches(pitches);
+    next-&gt;GetReadPlanes(planes);
+
+  
+    // Put out stuff in input...
+#if VDP_DEBUG
+    printf(&quot;Uploading image to surface %d\n&quot;,surfaceIndex%ADM_NB_SURFACES);
+#endif
+    if(VDP_STATUS_OK!=admVdpau::surfacePutBits( 
+            input[surfaceIndex%ADM_NB_SURFACES],
+            planes,pitches))
+    {
+        ADM_warning(&quot;[Vdpau] video surface : Cannot putbits\n&quot;);
+        return false;
+    }
+    frameDesc[surfaceIndex%ADM_NB_SURFACES]=frameNumber;
+    return true;
+}
+/**
+    \fn getConfiguration
+    \brief Return current setting as a string
+    The &quot;input&quot; arrays contains
+
+        T0 B0 T1 B1 T2 B2
+              ^ CurrentIndex
+    So in most case we have at least 2 fiels in the past and 2 in the future
+
+
+*/
+bool vdpauVideoFilterDeint::getNextFrame(uint32_t *fn,ADMImage *image)
+{
+    
+     if(passThrough) return previousFilter-&gt;getNextFrame(fn,image);
+    ADMImage *prev=NULL;
+    // our first frame, we need to send it + the next one
+    if(!nextFrame)
+    {
+            ADMImage *prev= vidCache-&gt;getImage( 0);
+            // Upload top field
+            if(false==uploadImage(prev,currentIndex,0)) 
+            {
+                vidCache-&gt;unlockAll();
+                return false;
+            }
+
+    }
+    // regular image, in fact we get the next image here
+    ADMImage *next= vidCache-&gt;getImage(nextFrame+1);
+    if(false==uploadImage(next,currentIndex+1,nextFrame+1)) 
+            {
+                vidCache-&gt;unlockAll();
+                return false;
+            }
+   
+    // Call mixer...
+    VdpVideoSurface in[3];
+        // PREVIOUS
+    if(!nextFrame) // First image, we dont have previous
+    {
+             in[0]=VDP_INVALID_HANDLE;
+    }else
+    {
+             in[0]=input[(currentIndex+ADM_NB_SURFACES-1)%ADM_NB_SURFACES];
+    }
+        // CURRENT
+     in[1]=input[currentIndex%ADM_NB_SURFACES];
+        // NEXT
+    if(next)
+    {
+     in[2]=input[(currentIndex+1)%ADM_NB_SURFACES];
+    }
+    else
+    {
+      in[2]=VDP_INVALID_HANDLE;
+    }
+
+    //
+#if VDP_DEBUG
+    printf(&quot;Current index=%d\n&quot;,(int)currentIndex);
+    for(int i=0;i&lt;3;i++) printf(&quot;Calling with in[%d]=%d\n&quot;,i,in[i]);
+    for(int i=0;i&lt;3;i++) printf(&quot;Desc[%d]=%d\n&quot;,i, frameDesc[i]);
+#endif
+    // ---------- Top field ------------
+    if(VDP_STATUS_OK!=admVdpau::mixerRenderWithPastAndFuture(true, 
+                mixer,
+                in,
+                surface, 
+                info.width,info.height))
+
+    {
+        ADM_warning(&quot;[Vdpau] Cannot mixerRender\n&quot;);
+        vidCache-&gt;unlockAll();
+        return false;
+    }
+    // Now get our image back from surface...
+    // Top Field..
+    if(VDP_STATUS_OK!=admVdpau::outputSurfaceGetBitsNative(surface,
+                                                            tempBuffer, 
+                                                            info.width,info.height))
+    {
+        ADM_warning(&quot;[Vdpau] Cannot copy back data from output surface\n&quot;);
+        vidCache-&gt;unlockAll();
+        return false;
+    }
+
+    // Convert from VDP_RGBA_FORMAT_B8G8R8A8 to YV12
+    uint32_t sourceStride[3]={info.width*4,0,0};
+    uint8_t  *sourceData[3]={tempBuffer,NULL,NULL};
+    uint32_t destStride[3];
+    uint8_t  *destData[3];
+
+    image-&gt;GetPitches(destStride);
+    image-&gt;GetWritePlanes(destData);
+
+    // Invert U&amp;V
+    uint32_t ts;
+    uint8_t  *td;
+
+    ts=destStride[2];destStride[2]=destStride[1];destStride[1]=ts;
+    td=destData[2];destData[2]=destData[1];destData[1]=td;
+
+    scaler-&gt;convertPlanes(  sourceStride,destStride,     
+                            sourceData,destData);
+    nextFrame++;
+    currentIndex+=2; // Two fields at a time...
+    vidCache-&gt;unlockAll();
+    return true;
+}
+#endif
+
+//****************
+// EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/CMakeLists.txt	2010-07-20 18:56:48 UTC (rev 6468)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/CMakeLists.txt	2010-07-20 18:56:49 UTC (rev 6469)
@@ -1,9 +1,13 @@
 INCLUDE(vf_plugin)
 IF(NOT WIN32 AND NOT APPLE)
         SET(ADM_vf_vdpauFilter_SRCS ADM_vidVdpauFilter.cpp )
+        SET(ADM_vf_vdpauFilterDeint_SRCS ADM_vidVdpauFilterDeint.cpp )
 
         ADD_VIDEO_FILTER(ADM_vf_vdpauFilter ${ADM_vf_vdpauFilter_SRCS})
+        ADD_VIDEO_FILTER(ADM_vf_vdpauFilterDeint ${ADM_vf_vdpauFilterDeint_SRCS})
 
         INIT_VIDEO_FILTER(ADM_vf_vdpauFilter)
+        INIT_VIDEO_FILTER(ADM_vf_vdpauFilterDeint)
         INSTALL_VIDEO_FILTER(ADM_vf_vdpauFilter)
+        INSTALL_VIDEO_FILTER(ADM_vf_vdpauFilterDeint)
 ENDIF(NOT WIN32 AND NOT APPLE)

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/vdpauFilter.conf
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/vdpauFilter.conf	2010-07-20 18:56:48 UTC (rev 6468)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/vdpauFilter.conf	2010-07-20 18:56:49 UTC (rev 6469)
@@ -1,4 +1,2 @@
-bool:resizeToggle;
 uint32_t:targetWidth;
-uint32_t:targetHeight;
-bool:deinterlace;
\ No newline at end of file
+uint32_t:targetHeight;
\ No newline at end of file

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/vdpauFilter.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/vdpauFilter.h	2010-07-20 18:56:48 UTC (rev 6468)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/vdpauFilter.h	2010-07-20 18:56:49 UTC (rev 6469)
@@ -2,10 +2,8 @@
 #ifndef ADM_vdpauFilter_CONF_H
 #define ADM_vdpauFilter_CONF_H
 typedef struct {
-   bool resizeToggle;
    uint32_t targetWidth;
    uint32_t targetHeight;
-   bool deinterlace;
 }vdpauFilter;
 #endif //vdpauFilter
 //EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/vdpauFilter_desc.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/vdpauFilter_desc.cpp	2010-07-20 18:56:48 UTC (rev 6468)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/vdpauFilter_desc.cpp	2010-07-20 18:56:49 UTC (rev 6469)
@@ -1,8 +1,6 @@
 // Automatically generated, do not edit!
 const ADM_paramList vdpauFilter_param[]={
- {&quot;resizeToggle&quot;,offsetof( vdpauFilter,resizeToggle),&quot;bool&quot;,ADM_param_bool},
  {&quot;targetWidth&quot;,offsetof( vdpauFilter,targetWidth),&quot;uint32_t&quot;,ADM_param_uint32_t},
  {&quot;targetHeight&quot;,offsetof( vdpauFilter,targetHeight),&quot;uint32_t&quot;,ADM_param_uint32_t},
- {&quot;deinterlace&quot;,offsetof( vdpauFilter,deinterlace),&quot;bool&quot;,ADM_param_bool},
 {NULL,0,NULL}
 };


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003656.html">[Avidemux-svn-commit] r6468 -	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf
</A></li>
	<LI>Next message: <A HREF="003658.html">[Avidemux-svn-commit] r6470 - in branches/avidemux_2.6_branch_mean:	avidemux_core/ADM_coreVdpau/src avidemux_plugins/ADM_muxers/muxerAvi	avidemux_plugins/ADM_muxers/muxerRaw	avidemux_plugins/ADM_videoFilters6/printInfo	avidemux_plugins/ADM_videoFilters6/vdpauFilters
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3657">[ date ]</a>
              <a href="thread.html#3657">[ thread ]</a>
              <a href="subject.html#3657">[ subject ]</a>
              <a href="author.html#3657">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
